void sub_100093658( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26)
{
  void *v26;
  uint64_t v27;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  v29 = *(void **)(v27 - 80);
  if (v29 == v26)
  {
    v30 = 4LL;
    v29 = (void *)(v27 - 104);
  }

  else
  {
    if (!v29) {
      goto LABEL_6;
    }
    v30 = 5LL;
  }

  (*(void (**)(void))(*v29 + 8 * v30))();
LABEL_6:
  sub_100093748(&a9);
  sub_100093748(&a26);
  sub_1000114F0(v27 - 216);
  v31 = *(void *)(v27 - 200);
  *(void *)(v27 - 200) = 0LL;
  if (v31) {
    (*(void (**)(uint64_t))(*(void *)v31 + 24LL))(v31);
  }
  v32 = *(void *)(v27 - 152);
  *(void *)(v27 - 152) = 0LL;
  if (v32) {
    (*(void (**)(uint64_t))(*(void *)v32 + 24LL))(v32);
  }
  _Unwind_Resume(a1);
}

uint64_t *sub_100093748(uint64_t *a1)
{
  uint64_t v2 = a1[6];
  a1[6] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  }
  uint64_t v3 = *a1;
  *a1 = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24LL))(v3);
  }
  return a1;
}

uint64_t sub_1000937A0@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  v4 = operator new(0xB0uLL);
  uint64_t result = sub_100092D24((uint64_t)v4, a1);
  *a2 = v4;
  return result;
}

void sub_1000937E0(_Unwind_Exception *a1)
{
}

uint64_t sub_1000937F4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 96);
  *(void *)(a1 + 96) = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24LL))(v3);
  }
  return a1;
}

void sub_10009384C(void *a1)
{
  uint64_t v2 = a1[12];
  a1[12] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  }
  uint64_t v3 = a1[6];
  a1[6] = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24LL))(v3);
  }
  operator delete(a1);
}

void *sub_1000938A4(void *a1)
{
  uint64_t v2 = a1 + 7;
  uint64_t v3 = (void *)a1[10];
  if (v3 == v2)
  {
    uint64_t v4 = 4LL;
    uint64_t v3 = v2;
  }

  else
  {
    if (!v3) {
      goto LABEL_6;
    }
    uint64_t v4 = 5LL;
  }

  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  uint64_t v5 = a1[4];
  a1[4] = 0LL;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 40LL))(v5);
  }
  return a1;
}

uint64_t sub_10009390C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24LL))(*v3, a1);
      return a1;
    }

    *(void *)(a1 + 24) = v4;
  }

  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }

  *uint64_t v3 = 0LL;
  return a1;
}

uint64_t sub_100093970@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = (char *)operator new(0x30uLL);
  uint64_t result = sub_1000939C8((uint64_t)v4, a1);
  *a2 = v4 + 24;
  a2[1] = v4;
  return result;
}

void sub_1000939B4(_Unwind_Exception *a1)
{
}

uint64_t sub_1000939C8(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 8) = 0u;
  *(void *)a1 = off_100177E58;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 24) = 0LL;
  sub_100093A78( (void *)(a1 + 24),  *(const void **)a2,  *(void *)(a2 + 8),  (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 5);
  return a1;
}

void sub_100093A18(_Unwind_Exception *a1)
{
}

void sub_100093A2C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_100177E58;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100093A3C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_100177E58;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_100093A5C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }

void *sub_100093A78(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    v6 = result;
    uint64_t result = sub_100093AF0(result, a4);
    uint64_t v7 = v6[1];
    uint64_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8 - 4);
    }
    v6[1] = v7 + v8;
  }

  return result;
}

void sub_100093AD4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

char *sub_100093AF0(void *a1, unint64_t a2)
{
  if (a2 >> 59) {
    sub_100016F4C();
  }
  uint64_t result = (char *)sub_100093B30((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[32 * v4];
  return result;
}

void *sub_100093B30(uint64_t a1, unint64_t a2)
{
  if (a2 >> 59) {
    sub_1000116A8();
  }
  return operator new(32 * a2);
}

void *sub_100093B64(void *a1)
{
  *a1 = off_100177EA8;
  sub_1000114F0((uint64_t)(a1 + 13));
  uint64_t v2 = a1[7];
  a1[7] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  }
  uint64_t v3 = a1[1];
  a1[1] = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24LL))(v3);
  }
  return a1;
}

void sub_100093BC4(void *a1)
{
  *a1 = off_100177EA8;
  sub_1000114F0((uint64_t)(a1 + 13));
  uint64_t v2 = a1[7];
  a1[7] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  }
  uint64_t v3 = a1[1];
  a1[1] = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24LL))(v3);
  }
  operator delete(a1);
}

void *sub_100093C24(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  uint64_t v2 = operator new(0x78uLL);
  *uint64_t v2 = off_100177EA8;
  sub_100093DA0((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100093C64(_Unwind_Exception *a1)
{
}

uint64_t sub_100093C78(uint64_t a1, void *a2)
{
  *a2 = off_100177EA8;
  return sub_100093DA0((uint64_t)(a2 + 1), (void *)(a1 + 8));
}

uint64_t sub_100093C94(uint64_t a1)
{
  return sub_100093E18((uint64_t *)(a1 + 8));
}

void sub_100093C9C(uint64_t *a1)
{
}

uint64_t sub_100093CC4@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, void *a4@<X8>)
{
  uint64_t v7 = a1 + 1;
  uint64_t v8 = *a3;
  v9 = operator new(0xB0uLL);
  __int128 v11 = *(_OWORD *)(a2 + 8);
  uint64_t v12 = *(void *)(a2 + 24);
  uint64_t result = sub_100092DE8((uint64_t)v9, a2, (uint64_t)&v11, v8, v7, a1 + 7, a1[13]);
  *a4 = v9;
  return result;
}

void sub_100093D44(_Unwind_Exception *a1)
{
}

uint64_t sub_100093D58(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100093D94()
{
}

uint64_t sub_100093DA0(uint64_t a1, void *a2)
{
  uint64_t v4 = sub_1000E46E8(a1, a2);
  sub_1000E46E8(v4 + 48, a2 + 6);
  uint64_t v5 = a2[13];
  *(void *)(a1 + 96) = a2[12];
  *(void *)(a1 + 104) = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  return a1;
}

void sub_100093DF4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *v1;
  uint64_t *v1 = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24LL))(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100093E18(uint64_t *a1)
{
  uint64_t v2 = a1[6];
  a1[6] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  }
  uint64_t result = *a1;
  *a1 = 0LL;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 24LL))(result);
  }
  return result;
}

void sub_100094190( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

uint64_t sub_1000941BC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_1000941CC(uint64_t a1)
{
}

void sub_1000941D4(uint64_t a1, void *a2, void *a3)
{
  id v7 = a2;
  id v6 = a3;
  if (!v6) {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL), a2);
  }
  [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) signalCommandCompletedWithXpcError:v6];
}

const void **sub_1000942C0(const __CFString *a1, void *a2, __CFDictionary *a3)
{
  CFTypeID TypeID = CFStringGetTypeID();
  if (a1)
  {
    uint64_t v7 = TypeID;
    if (CFGetTypeID(a1) != TypeID)
    {
      exception = __cxa_allocate_exception(0x40uLL);
      CFTypeID v15 = CFGetTypeID(a1);
LABEL_19:
      v16 = sub_1000974F0(exception, v15, v7);
    }
  }

  int v8 = sub_1000F6698(a1);
  if (v8 == 1651272568 || v8 == 1970628964 || v8 == 1886155636)
  {
    __int128 v11 = __cxa_allocate_exception(0x40uLL);
    uint64_t v12 = "User data contains reserved key(s)";
    goto LABEL_16;
  }

  CFTypeID v9 = CFDataGetTypeID();
  if (!a2)
  {
    __int128 v11 = __cxa_allocate_exception(0x40uLL);
    uint64_t v12 = "Invalid user data content";
LABEL_16:
    v13 = (void *)sub_100004870((uint64_t)v11, (uint64_t)v12, 0x16u);
  }

  uint64_t v7 = v9;
  if (CFGetTypeID(a2) != v9)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    CFTypeID v15 = CFGetTypeID(a2);
    goto LABEL_19;
  }

  sub_100004CB0(v21, "");
  LOBYTE(__p[0]) = 0;
  char v20 = 0;
  sub_1000974F4(&v17, 80);
  sub_1000F0120((uint64_t)v21, (uint64_t)__p, 0, &v17, a2, (CFDictionaryRef *)&v23);
  if (v20 && v19 < 0) {
    operator delete(__p[0]);
  }
  if (v22 < 0) {
    operator delete(v21[0]);
  }
  __p[0] = v23;
  v21[0] = CFArrayCreate(kCFAllocatorDefault, (const void **)__p, 1LL, &kCFTypeArrayCallBacks);
  CFDictionarySetValue(a3, a1, v21[0]);
  sub_1000982B0((const void **)v21);
  return sub_1000114C0((const void **)&v23);
}

void sub_1000944AC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23)
{
}

uint64_t sub_100094514(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 284);
  if (v1) {
    uint64_t v2 = *(__int128 **)(a1 + 72);
  }
  else {
    uint64_t v2 = 0LL;
  }
  uint64_t v3 = *(void *)(a1 + 8);
  int v4 = *(_DWORD *)(a1 + 280);
  if (v4)
  {
    __int128 v16 = *(_OWORD *)(a1 + 96);
    LOBYTE(v4) = 1;
  }

  else
  {
    LOBYTE(v16) = 0;
  }

  uint64_t v5 = *(__int128 **)(a1 + 80);
  BOOL v6 = v1 == 0;
  char v17 = v4;
  uint64_t v7 = *(void *)(v3 + 72);
  uint64_t v22 = *(void *)(v7 + 352);
  __int128 v27 = *(_OWORD *)(v7 + 424);
  __int128 v28 = *(_OWORD *)(v7 + 440);
  __int128 v29 = *(_OWORD *)(v7 + 456);
  __int128 v30 = *(_OWORD *)(v7 + 472);
  __int128 v23 = *(_OWORD *)(v7 + 360);
  __int128 v24 = *(_OWORD *)(v7 + 376);
  __int128 v25 = *(_OWORD *)(v7 + 392);
  __int128 v26 = *(_OWORD *)(v7 + 408);
  *(void *)&__int128 v21 = sub_1000EAB20((unsigned int *)&v22);
  *((void *)&v21 + 1) = v8;
  if (v6)
  {
    if (!v17) {
      return 1LL;
    }
  }

  else
  {
    CFTypeID v9 = *(void **)(v3 + 32);
    if (v9 == (void *)(v3 + 40) || v2 == v5) {
      goto LABEL_23;
    }
    BOOL v10 = 1;
    do
    {
      __int128 v20 = *v2;
      if (v10) {
        BOOL v10 = sub_1000EC49C((_DWORD *)v9 + 15, (uint64_t)&v20);
      }
      sub_100004CB0(__p, "BLX");
      sub_1000EEE84(v3, (uint64_t)__p, (uint64_t)&v20, (unsigned __int8 *)v9 + 60);
      if (v19 < 0) {
        operator delete(__p[0]);
      }
      __int128 v21 = *(_OWORD *)sub_1000982E0((uint64_t)&v21, (uint64_t)&v20);
      __int128 v11 = (void *)v9[1];
      if (v11)
      {
        do
        {
          uint64_t v12 = v11;
          __int128 v11 = (void *)*v11;
        }

        while (v11);
      }

      else
      {
        do
        {
          uint64_t v12 = (void *)v9[2];
          BOOL v13 = *v12 == (void)v9;
          CFTypeID v9 = v12;
        }

        while (!v13);
      }

      if (v12 == (void *)(v3 + 40)) {
        break;
      }
      uint64_t v2 = (__int128 *)((char *)v2 + 184);
      CFTypeID v9 = v12;
    }

    while (v2 != v5);
    if (v10) {
LABEL_23:
    }
      BOOL v10 = sub_1000EC49C(&v22, (uint64_t)&v21);
    sub_100004CB0(__p, "Master checksum");
    sub_1000EEE84(v3, (uint64_t)__p, (uint64_t)&v21, (unsigned __int8 *)&v22);
    if (v19 < 0) {
      operator delete(__p[0]);
    }
    if (!v17) {
      return v10;
    }
    if (!v10)
    {
      BOOL v14 = 0LL;
      goto LABEL_31;
    }
  }

  BOOL v14 = sub_1000EC49C((_DWORD *)(*(void *)(v3 + 72) + 80LL), (uint64_t)&v16);
LABEL_31:
  sub_100004CB0(__p, "Data Fork");
  sub_1000EEE84(v3, (uint64_t)__p, (uint64_t)&v16, (unsigned __int8 *)(*(void *)(v3 + 72) + 80LL));
  if (v19 < 0) {
    operator delete(__p[0]);
  }
  return v14;
}

void sub_1000947AC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000947D8(uint64_t a1)
{
  uint64_t v3 = &v4;
  uint64_t v1 = *(unsigned int *)(a1 + 12);
  if ((_DWORD)v1 == -1) {
    sub_100017130();
  }
  uint64_t v5 = &v3;
  ((void (*)(unsigned __int8 ***, uint64_t))off_1001780E8[v1])(&v5, a1 + 4);
  return v4;
}

uint64_t sub_10009482C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = a2;
  *(void *)(a1 + _Block_object_dispose(va, 8) = a3;
  *(void *)(a1 + 16) = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 24LL))(a2);
  uint64_t v5 = sub_1000EEE74(*(void *)(a1 + 8));
  *(void *)(a1 + 56) = v6;
  *(void *)(a1 + 24) = v5;
  *(void *)(a1 + 32) = v6;
  *(void *)(a1 + 40) = v5;
  *(void *)(a1 + 72) = 0LL;
  *(void *)(a1 + 80) = 0LL;
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = 0LL;
  uint64_t v7 = *(void *)(a3 + 72);
  uint64_t v8 = *(void *)(a1 + 16) * *(void *)(a3 + 80);
  v11[0] = 0LL;
  v11[1] = v8;
  char v12 = 2;
  sub_100094924((__int128 *)(a1 + 40), (__int128 *)(a1 + 56), (uint64_t)v11, (unsigned int *)(v7 + 80), a1 + 96);
  else {
    int v9 = 0;
  }
  *(_DWORD *)(a1 + 284) = v9;
  *(_DWORD *)(a1 + 280) = sub_1000947D8(a1 + 96) ^ 1;
  return a1;
}

void sub_1000948FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100094924( __int128 *a1@<X0>, __int128 *a2@<X1>, uint64_t a3@<X2>, unsigned int *a4@<X3>, uint64_t a5@<X8>)
{
  uLong v9 = sub_1000EAB20(a4);
  *(void *)char v12 = 850045863LL;
  v14[0] = 0LL;
  v14[1] = 0LL;
  memset(&v12[8], 0, 60);
  BOOL v13 = v14;
  __int128 v15 = *a1;
  __int128 v16 = v15;
  __int128 v17 = *a2;
  char v19 = 0;
  uint64_t v11 = v15;
  if ((void)v15 != (void)v17)
  {
    uint64_t v11 = *(void *)(v15 + 32);
    if ((*(_BYTE *)(v15 + 48) & 2) == 0) {
      ++v11;
    }
    uint64_t v18 = v11;
  }

  v20[0] = v9;
  v20[1] = v10;
  memset(&v21[8], 0, 60);
  v23[0] = 0LL;
  v23[1] = 0LL;
  *(void *)__int128 v21 = 850045863LL;
  uint64_t v22 = v23;
  __int128 v24 = *a1;
  __int128 v25 = v24;
  __int128 v26 = *a2;
  uint64_t v27 = v11;
  char v28 = 0;
  char v29 = 0;
  sub_100098454(a5, (uint64_t)v20, a3);
  sub_100097750((uint64_t)&v22, v23[0]);
  std::mutex::~mutex((std::mutex *)v21);
  sub_100097750((uint64_t)&v13, v14[0]);
  std::mutex::~mutex((std::mutex *)v12);
}

void sub_100094A9C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, void *a41)
{
}

uint64_t sub_100094AD0(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 16);
  sub_100097750(a1 + 88, *(void **)(a1 + 96));
  std::mutex::~mutex(v2);
  return a1;
}

uint64_t sub_100094B08(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  *(_DWORD *)(sub_10009482C(a1, a2, a3) + 284) = 4 * (a4 & 1);
  if ((a4 & 2) != 0) {
    int v6 = sub_1000947D8(a1 + 96) ^ 1;
  }
  else {
    int v6 = 0;
  }
  *(_DWORD *)(a1 + 280) = v6;
  return a1;
}

void sub_100094B54(_Unwind_Exception *a1)
{
}

uint64_t sub_100094B68(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 112);
  sub_100097750(a1 + 184, *(void **)(a1 + 192));
  std::mutex::~mutex(v2);
  unsigned __int8 v4 = (void **)(a1 + 72);
  sub_100097798(&v4);
  return a1;
}

uint64_t sub_100094BB8(uint64_t a1, void *a2)
{
  uint64_t v2 = (unsigned int *)(a2 + 1);
  uint64_t v3 = (unsigned int *)*a2;
  if ((void *)*a2 == a2 + 1) {
    return 0LL;
  }
  LODWORD(v5) = 0;
  int v6 = (__int128 *)(a1 + 40);
  uint64_t v7 = (__int128 *)(a1 + 56);
  __int128 v15 = (uint64_t *)(a1 + 72);
  do
  {
    sub_100094924(v6, v7, (uint64_t)(v3 + 8), v3 + 15, (uint64_t)v16);
    unint64_t v8 = *(void *)(a1 + 80);
    if (v8 >= *(void *)(a1 + 88))
    {
      uint64_t v9 = sub_100097838(v15, (uint64_t)v16);
    }

    else
    {
      sub_100097954(*(void *)(a1 + 80), (uint64_t)v16);
      uint64_t v9 = v8 + 184;
      *(void *)(a1 + 80) = v8 + 184;
    }

    *(void *)(a1 + 80) = v9;
    sub_100097750((uint64_t)v18, v18[1]);
    std::mutex::~mutex(&v17);
    unsigned int v10 = v3[15];
    BOOL v11 = v10 == 10 || v10 == 0;
    if (v11) {
      uint64_t v5 = v5;
    }
    else {
      uint64_t v5 = 2LL;
    }
    char v12 = (unsigned int *)*((void *)v3 + 1);
    if (v12)
    {
      do
      {
        BOOL v13 = v12;
        char v12 = *(unsigned int **)v12;
      }

      while (v12);
    }

    else
    {
      do
      {
        BOOL v13 = (unsigned int *)*((void *)v3 + 2);
        BOOL v11 = *(void *)v13 == (void)v3;
        uint64_t v3 = v13;
      }

      while (!v11);
    }

    uint64_t v3 = v13;
  }

  while (v13 != v2);
  return v5;
}

void sub_100094D10(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100094D38@<X0>( uint64_t *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, unsigned int a4@<W3>, uint64_t a5@<X8>)
{
  uint64_t v8 = a5;
  uint64_t v62 = a2;
  uint64_t result = sub_100098614(a5, a4);
  if (a4)
  {
    uint64_t v10 = 0LL;
    uint64_t v11 = a4;
    v52 = a1;
    uint64_t v53 = v8;
    do
    {
      uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)*a1 + 136LL))(*a1);
      uint64_t v61 = v12;
      __int128 v60 = 0uLL;
      __int128 v59 = 0uLL;
      if ((sub_1000951E8(*a1) & 1) == 0)
      {
        BOOL v13 = *(std::__shared_weak_count **)(v12 + 48);
        v57 = *(const void **)(v12 + 40);
        v58 = v13;
        if (v13)
        {
          p_shared_owners = (unint64_t *)&v13->__shared_owners_;
          do
            unint64_t v15 = __ldxr(p_shared_owners);
          while (__stxr(v15 + 1, p_shared_owners));
        }

        __int128 v16 = *(void **)(v12 + 16);
        if (v16 != (void *)(v12 + 24))
        {
          do
          {
            if ((void)v59)
            {
              if (!(void)v60)
              {
                sub_100038CDC((void **)v59);
                __int128 v17 = v56;
                __int128 v56 = 0uLL;
                uint64_t v18 = (std::__shared_weak_count *)*((void *)&v60 + 1);
                __int128 v60 = v17;
                if (v18)
                {
                  char v19 = (unint64_t *)&v18->__shared_owners_;
                  do
                    unint64_t v20 = __ldaxr(v19);
                  while (__stlxr(v20 - 1, v19));
                  if (!v20)
                  {
                    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
                    std::__shared_weak_count::__release_weak(v18);
                  }
                }

                __int128 v21 = (std::__shared_weak_count *)*((void *)&v56 + 1);
                if (*((void *)&v56 + 1))
                {
                  uint64_t v22 = (unint64_t *)(*((void *)&v56 + 1) + 8LL);
                  do
                    unint64_t v23 = __ldaxr(v22);
                  while (__stlxr(v23 - 1, v22));
                  if (!v23)
                  {
                    ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
                    std::__shared_weak_count::__release_weak(v21);
                  }
                }
              }
            }

            else
            {
              LODWORD(v63) = 1;
              BOOL v55 = a3 != 1;
              sub_1000987FC((uint64_t)&v57, &v62, (int *)&v63, (unsigned __int8 *)&v55, &v56);
              __int128 v24 = v56;
              __int128 v56 = 0uLL;
              __int128 v25 = (std::__shared_weak_count *)*((void *)&v59 + 1);
              __int128 v59 = v24;
              if (v25)
              {
                __int128 v26 = (unint64_t *)&v25->__shared_owners_;
                do
                  unint64_t v27 = __ldaxr(v26);
                while (__stlxr(v27 - 1, v26));
                if (!v27)
                {
                  ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
                  std::__shared_weak_count::__release_weak(v25);
                }
              }

              char v28 = (std::__shared_weak_count *)*((void *)&v56 + 1);
              if (*((void *)&v56 + 1))
              {
                char v29 = (unint64_t *)(*((void *)&v56 + 1) + 8LL);
                do
                  unint64_t v30 = __ldaxr(v29);
                while (__stlxr(v30 - 1, v29));
                if (!v30)
                {
                  ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
                  std::__shared_weak_count::__release_weak(v28);
                }
              }

              sub_100026A1C(&v60, (uint64_t *)&v59);
            }

            if (a3 == 1 || (const void *)v16[5] == v57)
            {
              unsigned int v54 = *((_DWORD *)v16 + 8);
              __int128 v56 = v60;
              if (*((void *)&v60 + 1))
              {
                v36 = (unint64_t *)(*((void *)&v60 + 1) + 8LL);
                do
                  unint64_t v37 = __ldxr(v36);
                while (__stxr(v37 + 1, v36));
              }

              v63 = &v54;
              v38 = sub_10004CF9C((uint64_t **)(v12 + 16), &v54, (uint64_t)&unk_100139230, &v63);
              sub_100026A1C(v38 + 5, (uint64_t *)&v56);
              v33 = (std::__shared_weak_count *)*((void *)&v56 + 1);
              if (!*((void *)&v56 + 1)) {
                goto LABEL_48;
              }
              v39 = (unint64_t *)(*((void *)&v56 + 1) + 8LL);
              do
                unint64_t v35 = __ldaxr(v39);
              while (__stlxr(v35 - 1, v39));
            }

            else
            {
              __int128 v56 = v60;
              if (*((void *)&v60 + 1))
              {
                v31 = (unint64_t *)(*((void *)&v60 + 1) + 8LL);
                do
                  unint64_t v32 = __ldxr(v31);
                while (__stxr(v32 + 1, v31));
              }

              sub_100116FE4((uint64_t)(v16 + 5), &v57, (uint64_t *)&v56);
              v33 = (std::__shared_weak_count *)*((void *)&v56 + 1);
              if (!*((void *)&v56 + 1)) {
                goto LABEL_48;
              }
              v34 = (unint64_t *)(*((void *)&v56 + 1) + 8LL);
              do
                unint64_t v35 = __ldaxr(v34);
              while (__stlxr(v35 - 1, v34));
            }

            if (!v35)
            {
              ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
              std::__shared_weak_count::__release_weak(v33);
            }

void sub_100095178(_Unwind_Exception *a1)
{
}

uint64_t sub_1000951E8(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 168);
  uint64_t v2 = (void *)(a1 + 176);
  if (v1 == (void *)(a1 + 176)) {
    return 1LL;
  }
  do
  {
    sub_100116E98((uint64_t)(v1 + 5), &v13);
    uint64_t v3 = v1[5];
    uint64_t v5 = v13;
    unsigned __int8 v4 = v14;
    BOOL v6 = v3 == v13;
    if (v14)
    {
      p_shared_owners = (unint64_t *)&v14->__shared_owners_;
      do
        unint64_t v8 = __ldaxr(p_shared_owners);
      while (__stlxr(v8 - 1, p_shared_owners));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }

    if (v3 != v5) {
      break;
    }
    uint64_t v9 = (void *)v1[1];
    if (v9)
    {
      do
      {
        uint64_t v10 = v9;
        uint64_t v9 = (void *)*v9;
      }

      while (v9);
    }

    else
    {
      do
      {
        uint64_t v10 = (void *)v1[2];
        BOOL v11 = *v10 == (void)v1;
        uint64_t v1 = v10;
      }

      while (!v11);
    }

    uint64_t v1 = v10;
  }

  while (v10 != v2);
  return v6;
}

void *sub_1000952C4(uint64_t a1, uint64_t *a2, __int128 *a3)
{
  BOOL v6 = (char *)operator new(0x18uLL);
  uint64_t v7 = *a2;
  *a2 = 0LL;
  __int128 v8 = *a3;
  *(void *)a3 = 0LL;
  *((void *)a3 + 1) = 0LL;
  unint64_t v9 = *(void *)(a1 + 24);
  *(void *)BOOL v6 = v7;
  *(_OWORD *)(v6 + _Block_object_dispose(va, 8) = v8;
  uint64_t v10 = *(void **)(a1 + 16);
  if ((unint64_t)v10 >= v9)
  {
    uint64_t v12 = *(void *)(a1 + 8);
    uint64_t v13 = ((uint64_t)v10 - v12) >> 3;
    uint64_t v14 = v9 - v12;
    uint64_t v15 = v14 >> 2;
    else {
      unint64_t v16 = v15;
    }
    if (v16) {
      __int128 v17 = (char *)sub_10001848C(a1 + 24, v16);
    }
    else {
      __int128 v17 = 0LL;
    }
    uint64_t v18 = &v17[8 * v13];
    char v19 = &v17[8 * v16];
    *(void *)uint64_t v18 = v6;
    BOOL v11 = v18 + 8;
    __int128 v21 = *(char **)(a1 + 8);
    unint64_t v20 = *(char **)(a1 + 16);
    if (v20 != v21)
    {
      do
      {
        uint64_t v22 = *((void *)v20 - 1);
        v20 -= 8;
        *((void *)v18 - 1) = v22;
        v18 -= 8;
      }

      while (v20 != v21);
      unint64_t v20 = *(char **)(a1 + 8);
    }

    *(void *)(a1 + _Block_object_dispose(va, 8) = v18;
    *(void *)(a1 + 16) = v11;
    *(void *)(a1 + 24) = v19;
    if (v20) {
      operator delete(v20);
    }
  }

  else
  {
    *uint64_t v10 = v6;
    BOOL v11 = v10 + 1;
  }

  *(void *)(a1 + 16) = v11;
  uint64_t result = v11 - 1;
  ++*(_DWORD *)a1;
  return result;
}

uint64_t sub_1000953D8(void *a1, uint64_t a2)
{
  unsigned __int8 v4 = sub_100037420();
  unint64_t v57 = (*(uint64_t (**)(void))(*(void *)*a1 + 24LL))(*a1);
  uint64_t v5 = (*(void *(**)(void *__return_ptr))(*(void *)*a1 + 72LL))(v89);
  else {
    unint64_t v6 = v89[0];
  }
  int v7 = *((_DWORD *)v4 + 2);
  if (v7 == 1)
  {
    unsigned int v8 = ((uint64_t (*)(void *))*v4)(v5);
  }

  else
  {
    if (v7) {
      sub_100017130();
    }
    unsigned int v8 = *(_DWORD *)v4;
  }

  unint64_t v9 = (unint64_t)v4[3] / v6;
  else {
    uint64_t v10 = v9;
  }
  (*(void (**)(void *__return_ptr))(*(void *)*a1 + 72LL))(v89);
  uint64_t v56 = v90 + v6;
  sub_1000F7D8C((uint64_t)v89, v90 + v6, 0, v10);
  uint64_t v85 = 0LL;
  v86 = 0LL;
  uint64_t v11 = a1[1];
  uint64_t v12 = sub_1000EEE74(v11);
  BOOL v55 = v13;
  uint64_t v14 = (void *)v12;
  if (*((_DWORD *)a1 + 71))
  {
    int v15 = sub_100094BB8((uint64_t)a1, (void *)(v11 + 32));
    *((_DWORD *)a1 + 71) = v15;
  }

  else
  {
    int v15 = 0;
  }

  int v16 = *((_DWORD *)a1 + 70);
  int v17 = sub_1000951E8(*a1);
  if (v17)
  {
    a1[35] = vbic_s8((int8x8_t)0x200000002LL, (int8x8_t)vceqz_s32((int32x2_t)a1[35]));
    int v18 = 2;
  }

  else
  {
    int v18 = v16 | v15;
  }

  sub_100094D38(a1, v56, v18, v10, (uint64_t)v88);
  sub_100040300(a2, v10, (uint64_t)v87);
  uint64_t v19 = a1[9];
  unsigned int v84 = 0;
  unint64_t v20 = *(void **)(v11 + 32);
  if (v20 != (void *)(v11 + 40) && v14 != v55)
  {
    unint64_t v21 = (v57 + v6 - 1) / v57;
    while ((unint64_t)(v14[6] & 1) + v14[5] - 1 > (unint64_t)(v20[6] & 1) + v20[5] - 1)
    {
LABEL_23:
      uint64_t v22 = (void *)v20[1];
      if (v22)
      {
        do
        {
          unint64_t v23 = v22;
          uint64_t v22 = (void *)*v22;
        }

        while (v22);
      }

      else
      {
        do
        {
          unint64_t v23 = (void *)v20[2];
          BOOL v47 = *v23 == (void)v20;
          unint64_t v20 = v23;
        }

        while (!v47);
      }

      if (v23 != (void *)(v11 + 40))
      {
        v19 += 184LL;
        unint64_t v20 = v23;
        if (v14 != v55) {
          continue;
        }
      }

      goto LABEL_83;
    }

    __int128 v24 = v14;
    while (1)
    {
      __int128 v79 = *((_OWORD *)v20 + 2);
      uint64_t v80 = v20[6];
      sub_10005A620((unint64_t *)&v79, v24 + 4, (uint64_t)&v81);
      unint64_t v25 = v81;
      if ((v83 & 2) == 0) {
        unint64_t v25 = v81 + 1;
      }
LABEL_69:
      v46 = (void *)v24[1];
      if (v46)
      {
        do
        {
          uint64_t v14 = v46;
          v46 = (void *)*v46;
        }

        while (v46);
      }

      else
      {
        do
        {
          uint64_t v14 = (void *)v24[2];
          BOOL v47 = *v14 == (void)v24;
          __int128 v24 = v14;
        }

        while (!v47);
      }

      BOOL v47 = (unint64_t)(v14[6] & 1) + v14[5] - 1 > (unint64_t)(v20[6] & 1) + v20[5] - 1 || v14 == v55;
      __int128 v24 = v14;
      if (v47) {
        goto LABEL_23;
      }
    }

    while (!atomic_load(&v84))
    {
      unint64_t v27 = v25 + v21;
      v75[0] = v25;
      v75[1] = v25 + v21;
      char v76 = 2;
      sub_10005A620(v75, &v81, (uint64_t)&v77);
      if (v18 == 1)
      {
        uint64_t v73 = v85;
        v74 = v86;
        if (v86)
        {
          p_shared_owners = (unint64_t *)&v86->__shared_owners_;
          do
            unint64_t v29 = __ldxr(p_shared_owners);
          while (__stxr(v29 + 1, p_shared_owners));
        }
      }

      else
      {
        sub_1000F7E38((uint64_t)v89, &v73);
      }

      sub_100095A78((uint64_t)v88, &v71);
      v58[0] = _NSConcreteStackBlock;
      v58[1] = 1174405120LL;
      v58[2] = sub_100095BCC;
      v58[3] = &unk_100177F40;
      __int128 v59 = v77;
      uint64_t v60 = v78;
      v58[4] = a1;
      unint64_t v61 = v57;
      uint64_t v62 = v73;
      v63 = v74;
      if (v74)
      {
        unint64_t v30 = (unint64_t *)&v74->__shared_owners_;
        do
          unint64_t v31 = __ldxr(v30);
        while (__stxr(v31 + 1, v30));
      }

      uint64_t v64 = v56;
      uint64_t v65 = v71;
      v66 = v72;
      if (v72)
      {
        unint64_t v32 = (unint64_t *)&v72->__shared_owners_;
        do
          unint64_t v33 = __ldxr(v32);
        while (__stxr(v33 + 1, v32));
      }

      int v69 = v18;
      v67 = &v84;
      uint64_t v68 = v19;
      char v70 = v17;
      sub_100040120(v87, v58);
      v34 = v66;
      if (v66)
      {
        unint64_t v35 = (unint64_t *)&v66->__shared_owners_;
        do
          unint64_t v36 = __ldaxr(v35);
        while (__stlxr(v36 - 1, v35));
        if (!v36)
        {
          ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
          std::__shared_weak_count::__release_weak(v34);
        }
      }

      unint64_t v37 = v63;
      if (v63)
      {
        v38 = (unint64_t *)&v63->__shared_owners_;
        do
          unint64_t v39 = __ldaxr(v38);
        while (__stlxr(v39 - 1, v38));
        if (!v39)
        {
          ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
          std::__shared_weak_count::__release_weak(v37);
        }
      }

      v40 = v72;
      if (v72)
      {
        uint64_t v41 = (unint64_t *)&v72->__shared_owners_;
        do
          unint64_t v42 = __ldaxr(v41);
        while (__stlxr(v42 - 1, v41));
        if (!v42)
        {
          ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
          std::__shared_weak_count::__release_weak(v40);
        }
      }

      uint64_t v43 = v74;
      if (v74)
      {
        v44 = (unint64_t *)&v74->__shared_owners_;
        do
          unint64_t v45 = __ldaxr(v44);
        while (__stlxr(v45 - 1, v44));
        if (!v45)
        {
          ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
          std::__shared_weak_count::__release_weak(v43);
        }
      }

      unint64_t v25 = v27;
    }

    uint64_t v48 = a1[9];
    for (uint64_t i = a1[10]; v48 != i; v48 += 184LL)
    {
      *(_BYTE *)(v48 + 176) = 1;
      sub_100098910(v48 + 16);
    }

    *((_BYTE *)a1 + 272) = 1;
    sub_100098910((uint64_t)(a1 + 14));
  }

LABEL_83:
  uint64_t v50 = atomic_load(&v84);
  sub_100040280(v87);
  sub_100098764((uint64_t)v88);
  unint64_t v51 = v86;
  if (v86)
  {
    v52 = (unint64_t *)&v86->__shared_owners_;
    do
      unint64_t v53 = __ldaxr(v52);
    while (__stlxr(v53 - 1, v52));
    if (!v53)
    {
      ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
      std::__shared_weak_count::__release_weak(v51);
    }
  }

  sub_1000F7E34(v89);
  return v50;
}

void sub_1000959EC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,char a52,uint64_t a53,char a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
}

void sub_100095A78(uint64_t a1@<X0>, void *a2@<X8>)
{
  __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 32);
  __lk.__owns_ = 1;
  std::mutex::lock((std::mutex *)(a1 + 32));
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  if (*(_BYTE *)(a1 + 144)) {
    BOOL v6 = v5 == v4;
  }
  else {
    BOOL v6 = 0;
  }
  if (v6)
  {
    uint64_t v13 = 0LL;
    __int128 v12 = 0uLL;
    sub_1000952C4(a1, &v13, &v12);
    int v7 = (std::__shared_weak_count *)*((void *)&v12 + 1);
    if (*((void *)&v12 + 1))
    {
      unsigned int v8 = (unint64_t *)(*((void *)&v12 + 1) + 8LL);
      do
        unint64_t v9 = __ldaxr(v8);
      while (__stlxr(v9 - 1, v8));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }

    uint64_t v10 = v13;
    uint64_t v13 = 0LL;
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 40LL))(v10);
    }
    uint64_t v4 = *(void *)(a1 + 16);
  }

  else if (v5 == v4)
  {
    do
    {
      std::condition_variable::wait((std::condition_variable *)(a1 + 96), &__lk);
      uint64_t v4 = *(void *)(a1 + 16);
    }

    while (*(void *)(a1 + 8) == v4);
  }

  uint64_t v11 = *(void *)(v4 - 8);
  *(void *)(a1 + 16) = v4 - 8;
  sub_100098958(a2, v11, a1);
  if (__lk.__owns_) {
    std::mutex::unlock(__lk.__m_);
  }
}

void sub_100095B88( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, std::mutex *a13, char a14)
{
  uint64_t v15 = a12;
  a12 = 0LL;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 40LL))(v15);
  }
  std::mutex::unlock(a13);
  _Unwind_Resume(a1);
}

void sub_100095BCC(uint64_t a1)
{
  unsigned int v2 = *(unsigned __int8 *)(a1 + 56);
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 64);
  uint64_t v6 = (*(void *)(a1 + 48) - v3 + (v2 & 1) + (int)(((v2 >> 1) & 1) - 1)) * v5;
  if ((v2 & 2) != 0) {
    uint64_t v7 = *(void *)(a1 + 40);
  }
  else {
    uint64_t v7 = v3 + 1;
  }
  uint64_t v8 = v7 * v5;
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 80);
  uint64_t v9 = *(void *)(a1 + 88);
  uint64_t v119 = *(void *)(a1 + 72);
  v120 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }

  unint64_t v121 = v6;
  uint64_t v122 = v8;
  uint64_t v123 = v9;
  char v124 = 0;
  uint64_t v13 = *(uint64_t **)(a1 + 96);
  sub_10002D554(&v119, (uint64_t *)&v131);
  sub_10002B7D4((uint64_t)v136, (uint64_t)&v128);
  sub_10002B3A4((uint64_t)v136, (uint64_t)&v125);
  uint64_t v14 = sub_1000127FC(*v13);
  uint64_t v16 = v15;
  int v17 = v127;
  if (v127)
  {
    int v18 = (unint64_t *)&v127->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  unint64_t v20 = v126;
  if (v126)
  {
    unint64_t v21 = (unint64_t *)&v126->__shared_owners_;
    do
      unint64_t v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }

  unint64_t v23 = v130;
  if (v130)
  {
    __int128 v24 = (unint64_t *)&v130->__shared_owners_;
    do
      unint64_t v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }

  __int128 v26 = (std::__shared_weak_count *)*((void *)&v128 + 1);
  if (*((void *)&v128 + 1))
  {
    unint64_t v27 = (unint64_t *)(*((void *)&v128 + 1) + 8LL);
    do
      unint64_t v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }

  unint64_t v29 = v143;
  if (v143)
  {
    unint64_t v30 = (unint64_t *)&v143->__shared_owners_;
    do
      unint64_t v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }

  unint64_t v32 = v142;
  if (v142)
  {
    unint64_t v33 = (unint64_t *)&v142->__shared_owners_;
    do
      unint64_t v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }

  unint64_t v35 = v141;
  if (v141)
  {
    unint64_t v36 = (unint64_t *)&v141->__shared_owners_;
    do
      unint64_t v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }

  v38 = v140;
  if (v140)
  {
    unint64_t v39 = (unint64_t *)&v140->__shared_owners_;
    do
      unint64_t v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }

  uint64_t v41 = v139;
  if (v139)
  {
    unint64_t v42 = (unint64_t *)&v139->__shared_owners_;
    do
      unint64_t v43 = __ldaxr(v42);
    while (__stlxr(v43 - 1, v42));
    if (!v43)
    {
      ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
      std::__shared_weak_count::__release_weak(v41);
    }
  }

  v44 = v137;
  if (v137)
  {
    unint64_t v45 = (unint64_t *)&v137->__shared_owners_;
    do
      unint64_t v46 = __ldaxr(v45);
    while (__stlxr(v46 - 1, v45));
    if (!v46)
    {
      ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
      std::__shared_weak_count::__release_weak(v44);
    }
  }

  if (v134 && &v135 != __p) {
    operator delete(__p);
  }
  sub_100014E54((uint64_t)&v131);
  if ((v14 & 0x8000000000000000LL) == 0 || !(_DWORD)v14)
  {
    uint64_t v47 = *(void *)(a1 + 80);
    *(void *)&__int128 v128 = *(void *)(a1 + 72) + v8 - v16;
    *((void *)&v128 + 1) = v47;
    if (v47)
    {
      uint64_t v48 = (unint64_t *)(v47 + 8);
      do
        unint64_t v49 = __ldxr(v48);
      while (__stxr(v49 + 1, v48));
    }

    uint64_t v50 = 0LL;
    unint64_t v51 = *(void *)(a1 + 64);
    unint64_t v52 = v122;
    if (v121 <= v51) {
      unint64_t v53 = *(void *)(a1 + 64);
    }
    else {
      unint64_t v53 = v121;
    }
    if (v121) {
      unint64_t v54 = v53;
    }
    else {
      unint64_t v54 = 0LL;
    }
    unint64_t v55 = v51 + v122 + v54 - 1;
    uint64_t v125 = 0LL;
    v126 = 0LL;
    if ((*(_BYTE *)(a1 + 128) & 1) != 0 && v8 == v16)
    {
      uint64_t v56 = *(void *)(a1 + 96);
      uint64_t v57 = *(void *)(v56 + 8);
      uint64_t v58 = *(void *)(v57 + 72);
      *(void *)&__int128 v131 = *(void *)(v57 + 64);
      *((void *)&v131 + 1) = v58;
      if (v58)
      {
        __int128 v59 = (unint64_t *)(v58 + 8);
        do
          unint64_t v60 = __ldxr(v59);
        while (__stxr(v60 + 1, v59));
        unint64_t v61 = (std::__shared_weak_count *)*((void *)&v131 + 1);
        *(_OWORD *)v132 = *(_OWORD *)(v57 + 80);
        *(_OWORD *)&v132[9] = *(_OWORD *)(v57 + 89);
        if (*((void *)&v131 + 1))
        {
          uint64_t v62 = (unint64_t *)(*((void *)&v131 + 1) + 8LL);
          do
            unint64_t v63 = __ldaxr(v62);
          while (__stlxr(v63 - 1, v62));
          if (!v63)
          {
            ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
            std::__shared_weak_count::__release_weak(v61);
          }
        }
      }

      sub_100026A1C(&v125, (uint64_t *)&v131);
      uint64_t v64 = *(void *)(v56 + 8);
      uint64_t v65 = *(std::__shared_weak_count **)(v64 + 72);
      if (v65)
      {
        v66 = (unint64_t *)&v65->__shared_owners_;
        do
          unint64_t v67 = __ldxr(v66);
        while (__stxr(v67 + 1, v66));
        uint64_t v50 = *(void *)(v64 + 80);
        do
          unint64_t v68 = __ldaxr(v66);
        while (__stlxr(v68 - 1, v66));
        if (!v68)
        {
          ((void (*)(std::__shared_weak_count *))v65->__on_zero_shared)(v65);
          std::__shared_weak_count::__release_weak(v65);
        }
      }

      else
      {
        uint64_t v50 = *(void *)(v64 + 80);
      }
    }

    int v69 = *(_DWORD *)(v4 + 284);
    uint64_t v70 = v50;
    if (v69 != 1)
    {
      if (v69 != 2) {
        goto LABEL_120;
      }
      uint64_t v70 = v6;
    }

    if (v70)
    {
      uint64_t v71 = *(void *)(a1 + 120);
      if (v69 == 2)
      {
        uint64_t v73 = (std::__shared_weak_count *)*((void *)&v128 + 1);
        v117 = (std::__shared_weak_count *)*((void *)&v128 + 1);
        uint64_t v72 = v128;
        if (*((void *)&v128 + 1))
        {
          char v76 = (unint64_t *)(*((void *)&v128 + 1) + 8LL);
          do
            unint64_t v77 = __ldxr(v76);
          while (__stxr(v77 + 1, v76));
        }
      }

      else
      {
        uint64_t v72 = v125;
        uint64_t v73 = v126;
        v117 = v126;
        if (v126)
        {
          v74 = (unint64_t *)&v126->__shared_owners_;
          do
            unint64_t v75 = __ldxr(v74);
          while (__stxr(v75 + 1, v74));
        }
      }

      int v78 = *(_DWORD *)(v4 + 284);
      if (v78 == 1) {
        uint64_t v79 = v50;
      }
      else {
        uint64_t v79 = 0LL;
      }
      if (v78 == 2) {
        uint64_t v80 = v6;
      }
      else {
        uint64_t v80 = v79;
      }
      *(void *)&__int128 v131 = v52 / v51;
      *((void *)&v131 + 1) = v55 / v51;
      v132[0] = 2;
      *(void *)&v132[8] = v72;
      *(void *)&v132[16] = v73;
      if (v73)
      {
        unint64_t v81 = (unint64_t *)&v73->__shared_owners_;
        do
          unint64_t v82 = __ldxr(v81);
        while (__stxr(v82 + 1, v81));
      }

      *(void *)&v132[24] = v80;
      sub_1000965DC(v71, &v131);
      char v83 = *(std::__shared_weak_count **)&v132[16];
      if (*(void *)&v132[16])
      {
        unsigned int v84 = (unint64_t *)(*(void *)&v132[16] + 8LL);
        do
          unint64_t v85 = __ldaxr(v84);
        while (__stlxr(v85 - 1, v84));
        if (!v85)
        {
          ((void (*)(std::__shared_weak_count *))v83->__on_zero_shared)(v83);
          std::__shared_weak_count::__release_weak(v83);
        }
      }

      if (v117)
      {
        v86 = (unint64_t *)&v117->__shared_owners_;
        do
          unint64_t v87 = __ldaxr(v86);
        while (__stlxr(v87 - 1, v86));
        if (!v87)
        {
          ((void (*)(std::__shared_weak_count *))v117->__on_zero_shared)(v117);
          std::__shared_weak_count::__release_weak(v117);
        }
      }
    }

LABEL_120:
    int v88 = *(_DWORD *)(v4 + 280);
    uint64_t v89 = v50;
    if (v88 != 1)
    {
      if (v88 != 2)
      {
LABEL_151:
        if (!*(_BYTE *)(a1 + 132)) {
          sub_100096B2C(*(void *)(*(void *)(a1 + 96) + 8LL));
        }
        v106 = v126;
        if (v126)
        {
          v107 = (unint64_t *)&v126->__shared_owners_;
          do
            unint64_t v108 = __ldaxr(v107);
          while (__stlxr(v108 - 1, v107));
          if (!v108)
          {
            ((void (*)(std::__shared_weak_count *))v106->__on_zero_shared)(v106);
            std::__shared_weak_count::__release_weak(v106);
          }
        }

        v109 = (std::__shared_weak_count *)*((void *)&v128 + 1);
        if (*((void *)&v128 + 1))
        {
          v110 = (unint64_t *)(*((void *)&v128 + 1) + 8LL);
          do
            unint64_t v111 = __ldaxr(v110);
          while (__stlxr(v111 - 1, v110));
          if (!v111)
          {
            ((void (*)(std::__shared_weak_count *))v109->__on_zero_shared)(v109);
            std::__shared_weak_count::__release_weak(v109);
          }
        }

        goto LABEL_163;
      }

      uint64_t v89 = v6;
    }

    if (v89)
    {
      if (v88 == 2)
      {
        v91 = (std::__shared_weak_count *)*((void *)&v128 + 1);
        v118 = (std::__shared_weak_count *)*((void *)&v128 + 1);
        uint64_t v90 = v128;
        if (*((void *)&v128 + 1))
        {
          v94 = (unint64_t *)(*((void *)&v128 + 1) + 8LL);
          do
            unint64_t v95 = __ldxr(v94);
          while (__stxr(v95 + 1, v94));
        }
      }

      else
      {
        uint64_t v90 = v125;
        v91 = v126;
        v118 = v126;
        if (v126)
        {
          v92 = (unint64_t *)&v126->__shared_owners_;
          do
            unint64_t v93 = __ldxr(v92);
          while (__stxr(v93 + 1, v92));
        }
      }

      int v96 = *(_DWORD *)(v4 + 280);
      if (v96 == 1) {
        uint64_t v97 = v50;
      }
      else {
        uint64_t v97 = 0LL;
      }
      if (v96 == 2) {
        uint64_t v98 = v6;
      }
      else {
        uint64_t v98 = v97;
      }
      *(void *)&__int128 v131 = v52 / v51;
      *((void *)&v131 + 1) = v55 / v51;
      v132[0] = 2;
      *(void *)&v132[8] = v90;
      *(void *)&v132[16] = v91;
      if (v91)
      {
        v99 = (unint64_t *)&v91->__shared_owners_;
        do
          unint64_t v100 = __ldxr(v99);
        while (__stxr(v100 + 1, v99));
      }

      *(void *)&v132[24] = v98;
      sub_1000965DC(v4 + 96, &v131);
      v101 = *(std::__shared_weak_count **)&v132[16];
      if (*(void *)&v132[16])
      {
        v102 = (unint64_t *)(*(void *)&v132[16] + 8LL);
        do
          unint64_t v103 = __ldaxr(v102);
        while (__stlxr(v103 - 1, v102));
        if (!v103)
        {
          ((void (*)(std::__shared_weak_count *))v101->__on_zero_shared)(v101);
          std::__shared_weak_count::__release_weak(v101);
        }
      }

      if (v118)
      {
        v104 = (unint64_t *)&v118->__shared_owners_;
        do
          unint64_t v105 = __ldaxr(v104);
        while (__stlxr(v105 - 1, v104));
        if (!v105)
        {
          ((void (*)(std::__shared_weak_count *))v118->__on_zero_shared)(v118);
          std::__shared_weak_count::__release_weak(v118);
        }
      }
    }

    goto LABEL_151;
  }

  v115 = *(unsigned int **)(a1 + 112);
  while (!__ldaxr(v115))
  {
    if (!__stlxr(v14, v115))
    {
      *(void *)&__int128 v128 = "details::udif_verify::calculate_checksums(workqueue::workqueue &)_block_invoke";
      *((void *)&v128 + 1) = 41LL;
      int v129 = 16;
      sub_1000964F4(&v131, &v128);
      sub_100004E4C(&v138, (uint64_t)"Error reading sectors for verify ", 33LL);
      std::ostream::operator<<(&v138, v14);
      sub_10009659C((uint64_t)&v131);
      goto LABEL_163;
    }
  }

  __clrex();
LABEL_163:
  v112 = v120;
  if (v120)
  {
    v113 = (unint64_t *)&v120->__shared_owners_;
    do
      unint64_t v114 = __ldaxr(v113);
    while (__stlxr(v114 - 1, v113));
    if (!v114)
    {
      ((void (*)(std::__shared_weak_count *))v112->__on_zero_shared)(v112);
      std::__shared_weak_count::__release_weak(v112);
    }
  }

void sub_100096450( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57)
{
}

void *sub_1000964F4(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_100098B74((uint64_t)a1, a2);
  *a1 = off_100178110;
  a1[45] = &off_100178210;
  a1[46] = &off_100178238;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose(va, 8) = -1;
  *a1 = off_100178110;
  a1[45] = off_100178198;
  a1[46] = off_1001781C0;
  return a1;
}

void sub_100096578(_Unwind_Exception *a1)
{
}

uint64_t sub_10009659C(uint64_t a1)
{
  return a1;
}

uint64_t sub_1000965DC(uint64_t a1, __int128 *a2)
{
  uint64_t v3 = (std::mutex *)(a1 + 16);
  __int128 v50 = *a2;
  uint64_t v4 = *((void *)a2 + 3);
  uint64_t v51 = *((void *)a2 + 2);
  uint64_t v5 = (std::__shared_weak_count *)*((void *)a2 + 4);
  uint64_t v6 = *((void *)a2 + 5);
  *((void *)a2 + 3) = 0LL;
  *((void *)a2 + 4) = 0LL;
  unint64_t v52 = v5;
  uint64_t v7 = v50;
  int v53 = *(_DWORD *)((char *)&v51 + 1);
  HIBYTE(v53) = BYTE4(v51);
  std::mutex::lock((std::mutex *)(a1 + 16));
  if (*(_BYTE *)(a1 + 168))
  {
    std::mutex::unlock(v3);
  }

  else
  {
    *(_OWORD *)unint64_t v55 = v50;
    v55[16] = v51;
    *(_DWORD *)&v55[17] = v53;
    *(_DWORD *)&v55[20] = HIDWORD(v51);
    uint64_t v56 = a1;
    __int128 v57 = v50;
    uint64_t v58 = v51;
    uint64_t v59 = v4;
    unint64_t v52 = 0LL;
    unint64_t v60 = v5;
    uint64_t v61 = v6;
    sub_100098BF0((uint64_t **)(a1 + 88), (unint64_t *)v55, (uint64_t)v55);
    uint64_t v8 = v60;
    if (v60)
    {
      p_shared_owners = (unint64_t *)&v60->__shared_owners_;
      do
        unint64_t v10 = __ldaxr(p_shared_owners);
      while (__stlxr(v10 - 1, p_shared_owners));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }

    if ((v51 & 2) == 0) {
      uint64_t v7 = v50 + 1;
    }
    uint64_t v11 = *(void *)(a1 + 160);
    std::mutex::unlock(v3);
    if (v7 == v11)
    {
      unint64_t v12 = (uint64_t *)(a1 + 96);
      while (1)
      {
        *(void *)unint64_t v55 = &v56;
        *(_OWORD *)&v55[8] = xmmword_1001388C0;
        std::mutex::lock(v3);
        uint64_t v13 = *(uint64_t **)(a1 + 88);
        unint64_t v14 = *(void *)(a1 + 160);
        if (v13 != v12)
        {
          uint64_t v15 = *(void **)(a1 + 144);
          uint64_t v16 = *(void **)(a1 + 112);
          int v17 = *(uint64_t **)(a1 + 88);
          while (v16 != v15)
          {
            uint64_t v18 = v17[4];
            if ((v17[6] & 2) == 0) {
              ++v18;
            }
            if (v18 != v14) {
              break;
            }
            unint64_t v14 = v17[5] + (v17[6] & 1);
            for (uint64_t i = (v16[6] & 1) + v16[5]; v14 > i - 1; uint64_t i = (v16[6] & 1) + v16[5])
            {
              unint64_t v20 = (void *)v16[1];
              unint64_t v21 = v16;
              if (v20)
              {
                do
                {
                  uint64_t v16 = v20;
                  unint64_t v20 = (void *)*v20;
                }

                while (v20);
              }

              else
              {
                do
                {
                  uint64_t v16 = (void *)v21[2];
                  BOOL v22 = *v16 == (void)v21;
                  unint64_t v21 = v16;
                }

                while (!v22);
              }

              *(void *)(a1 + 112) = v16;
              if (v16 == v15)
              {
                uint64_t v16 = v15;
                break;
              }

              if ((v16[6] & 2) != 0) {
                unint64_t v14 = v16[4];
              }
              else {
                unint64_t v14 = v16[4] + 1LL;
              }
            }

            unint64_t v23 = (uint64_t *)v17[1];
            if (v23)
            {
              do
              {
                __int128 v24 = v23;
                unint64_t v23 = (uint64_t *)*v23;
              }

              while (v23);
            }

            else
            {
              do
              {
                __int128 v24 = (uint64_t *)v17[2];
                BOOL v22 = *v24 == (void)v17;
                int v17 = v24;
              }

              while (!v22);
            }

            int v17 = v24;
            if (v24 == v12)
            {
              int v17 = (uint64_t *)(a1 + 96);
              break;
            }
          }

          if (v13 != v17)
          {
            uint64_t v25 = 0LL;
            __int128 v26 = v13;
            do
            {
              unint64_t v27 = v25;
              unint64_t v28 = (uint64_t *)v26[1];
              if (v28)
              {
                do
                {
                  unint64_t v29 = v28;
                  unint64_t v28 = (uint64_t *)*v28;
                }

                while (v28);
              }

              else
              {
                do
                {
                  unint64_t v29 = (uint64_t *)v26[2];
                  BOOL v22 = *v29 == (void)v26;
                  __int128 v26 = v29;
                }

                while (!v22);
              }

              ++v25;
              __int128 v26 = v29;
            }

            while (v29 != v17);
            if (*(void *)&v55[16] <= v27)
            {
              if (v27 >= 0x249249249249249LL) {
                sub_100014AD4("get_next_capacity, allocator's max size reached");
              }
              unint64_t v30 = operator new(56 * v25);
              sub_100098E90((uint64_t *)v55, (uint64_t)v30, v25, *(void *)v55 + 56LL * *(void *)&v55[8], 0LL, 0LL);
            }

            do
            {
              uint64_t v31 = *(void *)v55;
              uint64_t v32 = *(void *)&v55[8];
              unint64_t v33 = (void *)(*(void *)v55 + 56LL * *(void *)&v55[8]);
              if (*(void *)&v55[8] == *(void *)&v55[16])
              {
                sub_100099030((uint64_t *)v55, (uint64_t)v33, 1LL, (uint64_t)(v13 + 7), v54);
              }

              else
              {
                void *v33 = v13[7];
                uint64_t v34 = v31 + 56 * v32;
                __int128 v35 = *((_OWORD *)v13 + 4);
                *(void *)(v34 + 24) = v13[10];
                *(_OWORD *)(v34 + _Block_object_dispose(va, 8) = v35;
                *(_OWORD *)(v34 + 32) = *(_OWORD *)(v13 + 11);
                v13[11] = 0LL;
                v13[12] = 0LL;
                *(void *)(v34 + 4_Block_object_dispose(va, 8) = v13[13];
                ++*(void *)&v55[8];
              }

              unint64_t v36 = sub_10003F4FC((uint64_t **)(a1 + 88), v13);
              sub_1000114F0((uint64_t)(v13 + 11));
              operator delete(v13);
              uint64_t v13 = v36;
            }

            while (v17 != v36);
          }
        }

        std::mutex::unlock(v3);
        if (*(void *)&v55[8])
        {
          unint64_t v37 = *(uint64_t **)v55;
          uint64_t v38 = *(void *)v55 + 56LL * *(void *)&v55[8];
          do
          {
            uint64_t v39 = *v37;
            uint64_t v40 = v37[6];
            v54[0] = v37[4];
            v54[1] = v40;
            sub_1000983BC(v39, (uint64_t)v54);
            v37 += 7;
          }

          while (v37 != (uint64_t *)v38);
          uint64_t v41 = *(void *)&v55[8];
          if (*(void *)&v55[8])
          {
            uint64_t v42 = *(void *)v55 + 32LL;
            do
            {
              --v41;
              uint64_t v42 = sub_1000114F0(v42) + 56;
            }

            while (v41);
          }
        }

        *(void *)&v55[8] = 0LL;
        std::mutex::lock(v3);
        *(void *)(a1 + 160) = v14;
        uint64_t v43 = *(void *)(a1 + 88);
        char v44 = *(_BYTE *)(v43 + 48);
        uint64_t v45 = *(void *)(v43 + 32);
        if ((v44 & 2) != 0) {
          uint64_t v46 = v45;
        }
        else {
          uint64_t v46 = v45 + 1;
        }
        std::mutex::unlock(v3);
        if (v46 != v14) {
          goto LABEL_68;
        }
        sub_1000992E4((uint64_t)v55);
      }

      std::mutex::unlock(v3);
LABEL_68:
      sub_1000992E4((uint64_t)v55);
    }
  }

  if (v52)
  {
    uint64_t v47 = (unint64_t *)&v52->__shared_owners_;
    do
      unint64_t v48 = __ldaxr(v47);
    while (__stlxr(v48 - 1, v47));
    if (!v48)
    {
      ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
      std::__shared_weak_count::__release_weak(v52);
    }
  }

  return a1;
}

void sub_100096AD0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24)
{
}

void sub_100096B2C(uint64_t a1)
{
  *(_OWORD *)(a1 + 80) = v5[1];
  *(_OWORD *)(a1 + 89) = *(__int128 *)((char *)&v5[1] + 9);
  uint64_t v2 = (std::__shared_weak_count *)*((void *)&v5[0] + 1);
  if (*((void *)&v5[0] + 1))
  {
    uint64_t v3 = (unint64_t *)(*((void *)&v5[0] + 1) + 8LL);
    do
      unint64_t v4 = __ldaxr(v3);
    while (__stlxr(v4 - 1, v3));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }

void *sub_100096BB0(void *result, void *a2)
{
  uint64_t v2 = a2[10];
  result[9] = a2[9];
  result[10] = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  uint64_t v5 = a2[13];
  result[12] = a2[12];
  result[13] = v5;
  if (v5)
  {
    uint64_t v6 = (unint64_t *)(v5 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  return result;
}

uint64_t sub_100096BF4(uint64_t a1)
{
  uint64_t v1 = a1 + 72;
  sub_1000114F0(a1 + 96);
  return sub_1000114F0(v1);
}

const void **sub_100096C1C@<X0>(uint64_t a1@<X0>, CFMutableDictionaryRef *a2@<X8>)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)sub_100096CA8, Mutable);
  *a2 = Mutable;
  return sub_1000114C0((const void **)&theDict);
}

void sub_100096C94(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100096CA8(const __CFString *a1, const void *a2, __CFDictionary *a3)
{
  CFTypeID TypeID = CFStringGetTypeID();
  if (a1)
  {
    CFTypeID v7 = TypeID;
    if (CFGetTypeID(a1) != TypeID)
    {
      exception = __cxa_allocate_exception(0x40uLL);
      CFTypeID v15 = CFGetTypeID(a1);
LABEL_16:
      uint64_t v16 = exception;
      uint64_t v17 = v7;
      goto LABEL_17;
    }
  }

  int v8 = sub_1000F6698(a1);
  switch(v8)
  {
    case 1651272568:
      return;
    case 1886155636:
      return;
    case 1970628964:
      return;
  }

  CFTypeID v9 = CFArrayGetTypeID();
  if (!a2) {
    return;
  }
  CFTypeID v7 = v9;
  if (CFGetTypeID(a2) != v9)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    CFTypeID v15 = CFGetTypeID(a2);
    goto LABEL_16;
  }

  if (CFArrayGetCount((CFArrayRef)a2) >= 1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a2, 0LL);
    CFTypeID v11 = CFDictionaryGetTypeID();
    if (ValueAtIndex)
    {
      CFTypeID v12 = v11;
      if (CFGetTypeID(ValueAtIndex) != v11)
      {
LABEL_19:
        unint64_t v19 = __cxa_allocate_exception(0x40uLL);
        CFTypeID v15 = CFGetTypeID(ValueAtIndex);
        uint64_t v16 = v19;
        uint64_t v17 = v12;
LABEL_17:
        uint64_t v18 = sub_1000974F0(v16, v15, v17);
      }

      ValueAtIndex = CFDictionaryGetValue((CFDictionaryRef)ValueAtIndex, @"Data");
      CFTypeID v13 = CFDataGetTypeID();
      if (ValueAtIndex)
      {
        CFTypeID v12 = v13;
        if (CFGetTypeID(ValueAtIndex) == v13)
        {
          CFDictionaryAddValue(a3, a1, ValueAtIndex);
          return;
        }

        goto LABEL_19;
      }
    }
  }

void sub_100096E60(_Unwind_Exception *a1)
{
}

const void **sub_100096E80(uint64_t a1, const __CFDictionary *a2)
{
  uint64_t v4 = a1 + 64;
  sub_1000EFB18(a1 + 64, &theDict);
  CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, theDict);
  CFMutableDictionaryRef v14 = MutableCopy;
  if (!MutableCopy)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = &off_100189E78;
    unint64_t v10 = std::generic_category();
    exception[1] = 22LL;
    exception[2] = v10;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 4_Block_object_dispose(va, 8) = 0;
    exception[7] = "Failed creating CFAutoRelease instance.";
  }

  CFDictionaryApplyFunction(a2, (CFDictionaryApplierFunction)sub_1000942C0, MutableCopy);
  unint64_t v6 = sub_1000EC828(v4, v14);
  unsigned int v7 = (*(uint64_t (**)(void, unint64_t))(**(void **)(a1 + 48) + 56LL))(*(void *)(a1 + 48), v6);
  if (v7)
  {
    CFTypeID v11 = "UDIFDiskImage: failed truncating image";
    goto LABEL_8;
  }

  unsigned int v7 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 16LL))(*(void *)(a1 + 48), 2LL);
  if (v7)
  {
    CFTypeID v11 = "UDIFDiskImage: failed flush after user data write";
LABEL_8:
    CFTypeID v12 = __cxa_allocate_exception(0x40uLL);
    *CFTypeID v12 = &off_100189E78;
    CFTypeID v13 = std::generic_category();
    v12[1] = v7;
    v12[2] = v13;
    *((_BYTE *)v12 + 24) = 0;
    *((_BYTE *)v12 + 4_Block_object_dispose(va, 8) = 0;
    v12[7] = v11;
  }

  sub_100026DC0((const void **)&v14);
  return sub_1000114C0((const void **)&theDict);
}

void sub_100096FFC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

uint64_t sub_10009702C(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5 = a1 + 64;
  if (a3)
  {
    sub_100094B08((uint64_t)v9, a1, v5, 3);
  }

  else
  {
    sub_10009482C((uint64_t)v9, a1, v5);
    if (!sub_1000953D8(v9, a2))
    {
LABEL_6:
      uint64_t v6 = sub_100094514((uint64_t)v9);
      goto LABEL_7;
    }
  }

  uint64_t v6 = 0LL;
LABEL_7:
  sub_100097750((uint64_t)v12, v12[1]);
  std::mutex::~mutex(&v11);
  int v8 = (void **)&v10;
  sub_100097798(&v8);
  return v6;
}

void sub_100097118(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *sub_100097138@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  unint64_t v2 = result[5];
  uint64_t v4 = (void *)result[8];
  uint64_t v3 = (void *)result[9];
  if (v4 == v3)
  {
LABEL_9:
    int v8 = 0;
    int v9 = 1;
    uint64_t v4 = v3;
    goto LABEL_21;
  }

  while (1)
  {
    unint64_t v5 = v4[5];
    if (v2 <= (v4[6] & 1) + v5 - 1) {
      break;
    }
    uint64_t v6 = (void *)v4[1];
    if (v6)
    {
      do
      {
        unsigned int v7 = v6;
        uint64_t v6 = (void *)*v6;
      }

      while (v6);
    }

    else
    {
      do
      {
        unsigned int v7 = (void *)v4[2];
        BOOL v16 = *v7 == (void)v4;
        uint64_t v4 = v7;
      }

      while (!v16);
    }

    result[8] = v7;
    uint64_t v4 = v7;
    if (v7 == v3) {
      goto LABEL_9;
    }
  }

  unint64_t v10 = v4[4];
  if ((v4[6] & 2) != 0)
  {
    if (v2 < v10) {
      goto LABEL_20;
    }
  }

  else if (v10 >= v2)
  {
    goto LABEL_20;
  }

  if ((v4[6] & 1) != 0)
  {
    if (v5 >= v2) {
      goto LABEL_18;
    }
LABEL_20:
    int v8 = 0;
    int v9 = 1;
    goto LABEL_21;
  }

  if (v2 >= v5) {
    goto LABEL_20;
  }
LABEL_18:
  int v11 = *((_DWORD *)v4 + 14);
  if (v11 != 1 && (v11 & 0xFF000000) != 0x80000000) {
    goto LABEL_20;
  }
  int v9 = 0;
  int v8 = 1;
LABEL_21:
  unint64_t v12 = result[3];
  unint64_t v13 = v2;
  if (v2 < v12)
  {
    unint64_t v13 = v2;
    do
    {
      unint64_t v14 = v12;
      if (v4 == v3) {
        goto LABEL_27;
      }
      unint64_t v14 = v4[4];
      if ((v4[6] & 2) == 0) {
        ++v14;
      }
      if (v14 > v13)
      {
LABEL_27:
        if ((v8 & 1) != 0) {
          break;
        }
      }

      else
      {
        if (v8)
        {
          int v15 = *((_DWORD *)v4 + 14);
          BOOL v16 = v15 == 1 || (v15 & 0xFF000000) == 0x80000000;
          if (!v16) {
            break;
          }
        }

        if (v9)
        {
          int v17 = *((_DWORD *)v4 + 14);
          if (v17 == 1 || (v17 & 0xFF000000) == 0x80000000) {
            break;
          }
        }

        uint64_t v18 = (void *)v4[1];
        unint64_t v19 = v4;
        if (v18)
        {
          do
          {
            unint64_t v20 = v18;
            uint64_t v18 = (void *)*v18;
          }

          while (v18);
        }

        else
        {
          do
          {
            unint64_t v20 = (void *)v19[2];
            BOOL v16 = *v20 == (void)v19;
            unint64_t v19 = v20;
          }

          while (!v16);
        }

        unint64_t v14 = (v4[6] & 1) + v4[5];
        result[8] = v20;
        uint64_t v4 = v20;
      }

      unint64_t v13 = v14;
    }

    while (v14 < v12);
  }

  *(void *)a2 = v2;
  *(void *)(a2 + _Block_object_dispose(va, 8) = v13;
  *(_BYTE *)(a2 + 16) = 2;
  *(_DWORD *)(a2 + 24) = v8;
  return result;
}

__n128 sub_1000972F0@<Q0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = (char *)operator new(0x50uLL);
  *(_OWORD *)(v4 + _Block_object_dispose(va, 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v4 + 24) = *(_OWORD *)(a1 + 24);
  *((void *)v4 + 5) = *(void *)(a1 + 40);
  *(void *)uint64_t v4 = off_100177F80;
  __n128 result = *(__n128 *)(a1 + 48);
  __int128 v6 = *(_OWORD *)(a1 + 64);
  *((__n128 *)v4 + 3) = result;
  *((_OWORD *)v4 + 4) = v6;
  *a2 = v4;
  return result;
}

void *sub_100097350(void *a1)
{
  *a1 = &off_10016C5B8;
  uint64_t v2 = (uint64_t)(a1 + 6);
  sub_10004E010((uint64_t)(a1 + 8));
  sub_1000114F0(v2);
  return a1;
}

void sub_100097390(void *a1)
{
  *a1 = &off_10016C5B8;
  uint64_t v2 = (uint64_t)(a1 + 6);
  sub_10004E010((uint64_t)(a1 + 8));
  sub_1000114F0(v2);
  operator delete(a1);
}

uint64_t sub_1000973D0()
{
  return 0LL;
}

uint64_t sub_1000973D8@<X0>(uint64_t *a1@<X0>, char a2@<W1>, void *a3@<X8>)
{
  __int128 v6 = operator new(0x120uLL);
  uint64_t result = sub_100024E30((uint64_t)v6, a1, a2);
  *a3 = (char *)v6 + *(void *)(*v6 - 104LL);
  return result;
}

void sub_10009742C(_Unwind_Exception *a1)
{
}

uint64_t sub_100097440()
{
  return 1LL;
}

uint64_t sub_100097448@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, void *a6@<X8>)
{
  unint64_t v12 = operator new(0x50uLL);
  v12[1] = *(_OWORD *)a4;
  *((void *)v12 + 4) = *(void *)(a4 + 16);
  *((void *)v12 + 5) = a5;
  *((void *)v12 + 6) = a1;
  *((void *)v12 + 7) = a3;
  *(void *)unint64_t v12 = off_100177F80;
  *((void *)v12 + 1) = a2;
  *((void *)v12 + _Block_object_dispose(va, 8) = 0LL;
  *((void *)v12 + 9) = 0LL;
  uint64_t result = sub_1000EEE2C(a1 + 64, (uint64_t)(v12 + 1));
  *((void *)v12 + _Block_object_dispose(va, 8) = result;
  *((void *)v12 + 9) = v14;
  *a6 = v12;
  return result;
}

void sub_1000974D4(_Unwind_Exception *a1)
{
}

uint64_t sub_1000974E8()
{
  return -78LL;
}

_WORD *sub_1000974F4(_WORD *result, int a2)
{
  uint64_t v2 = 0LL;
  *uint64_t result = a2;
  uint64_t v5 = 0x10000800040002LL;
  int v6 = 4194336;
  __int16 v7 = 128;
  do
  {
    a2 &= *(unsigned __int16 *)((char *)&v5 + v2) ^ 0xFFFF;
    v2 += 2LL;
  }

  while (v2 != 14);
  if (a2)
  {
    __int16 v3 = a2;
    exception = __cxa_allocate_exception(0x28uLL);
    exception[2] = "invalid flags";
    exception[3] = "flags validator";
    void *exception = &off_1001780C8;
    exception[1] = "block_attributes";
    *((_WORD *)exception + 16) = v3;
  }

  return result;
}

void sub_1000975D8(std::exception *a1)
{
}

void sub_1000975EC(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = (char *)sub_100109388(a1);
  sub_100004CB0(v16, v4);
  sub_100026C20((uint64_t)v11);
  if ((v17 & 0x80u) == 0) {
    uint64_t v5 = v16;
  }
  else {
    uint64_t v5 = (void **)v16[0];
  }
  if ((v17 & 0x80u) == 0) {
    uint64_t v6 = v17;
  }
  else {
    uint64_t v6 = (uint64_t)v16[1];
  }
  __int16 v7 = sub_100004E4C(&v12, (uint64_t)v5, v6);
  int v8 = sub_100004E4C(v7, (uint64_t)" [", 2LL);
  *(_DWORD *)((char *)v8 + *(void *)(*v8 - 24LL) + _Block_object_dispose(va, 8) = *(_DWORD *)((_BYTE *)v8 + *(void *)(*v8 - 24LL) + 8) & 0xFFFFFFB5 | 8;
  int v9 = (void *)std::ostream::operator<<(v8, *(unsigned __int16 *)(a1 + 32));
  sub_100004E4C(v9, (uint64_t)"]", 1LL);
  sub_1000049D8((uint64_t)v13, a2);
  *(void *)((char *)v11
  uint64_t v12 = v10;
  if (v14 < 0) {
    operator delete((void *)v13[8]);
  }
  std::streambuf::~streambuf(v13);
  std::ios::~ios(&v15);
}

_BYTE ***sub_10009772C(_BYTE ***result)
{
  ***uint64_t result = 1;
  return result;
}

_BYTE ***sub_100097740(_BYTE ***result)
{
  ***uint64_t result = 0;
  return result;
}

void sub_100097750(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_100097750(a1, *a2);
    sub_100097750(a1, a2[1]);
    sub_1000114F0((uint64_t)(a2 + 11));
    operator delete(a2);
  }

void sub_100097798(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_1000977D8((uint64_t)v2, (uint64_t)*v2);
    operator delete(**a1);
  }

void sub_1000977D8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4 != a2)
  {
    do
    {
      uint64_t v5 = v4 - 184;
      uint64_t v6 = (std::mutex *)(v4 - 168);
      sub_100097750(v4 - 96, *(void **)(v4 - 88));
      std::mutex::~mutex(v6);
      uint64_t v4 = v5;
    }

    while (v5 != a2);
  }

  *(void *)(a1 + _Block_object_dispose(va, 8) = a2;
}

uint64_t sub_100097838(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xD37A6F4DE9BD37A7LL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x1642C8590B21642LL) {
    sub_100016F4C();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xD37A6F4DE9BD37A7LL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0xB21642C8590B21LL) {
    unint64_t v9 = 0x1642C8590B21642LL;
  }
  else {
    unint64_t v9 = v5;
  }
  unsigned __int8 v17 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)sub_100097A60(v7, v9);
  }
  else {
    uint64_t v10 = 0LL;
  }
  unint64_t v13 = v10;
  char v14 = &v10[184 * v4];
  BOOL v16 = &v10[184 * v9];
  sub_100097954((uint64_t)v14, a2);
  uint64_t v15 = v14 + 184;
  sub_1000979EC(a1, &v13);
  uint64_t v11 = a1[1];
  sub_100097C70((uint64_t)&v13);
  return v11;
}

void sub_100097940(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

__n128 sub_100097954(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = 850045863LL;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 72) = 0LL;
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a2 + 80);
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = *(void *)(a2 + 88);
  uint64_t v2 = (void *)(a2 + 96);
  uint64_t v3 = *(void *)(a2 + 96);
  *(void *)(a1 + 96) = v3;
  uint64_t v4 = a1 + 96;
  uint64_t v5 = *(void *)(a2 + 104);
  *(void *)(a1 + 104) = v5;
  if (v5)
  {
    *(void *)(v3 + 16) = v4;
    *(void *)(a2 + 8_Block_object_dispose(va, 8) = v2;
    *uint64_t v2 = 0LL;
    *(void *)(a2 + 104) = 0LL;
  }

  else
  {
    *(void *)(a1 + 8_Block_object_dispose(va, 8) = v4;
  }

  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(a1 + 12_Block_object_dispose(va, 8) = *(_OWORD *)(a2 + 128);
  __n128 result = *(__n128 *)(a2 + 144);
  *(__n128 *)(a1 + 144) = result;
  *(void *)(a1 + 160) = *(void *)(a2 + 160);
  *(_BYTE *)(a1 + 16_Block_object_dispose(va, 8) = 0;
  *(_BYTE *)(a1 + 176) = *(_BYTE *)(a2 + 176);
  return result;
}

uint64_t sub_1000979EC(uint64_t *a1, void *a2)
{
  uint64_t result = sub_100097AA8((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_100097A60(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x1642C8590B21643LL) {
    sub_1000116A8();
  }
  return operator new(184 * a2);
}

uint64_t sub_100097AA8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&__int128 v15 = a6;
  *((void *)&v15 + 1) = a7;
  __int128 v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  char v13 = 0;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }

  else
  {
    uint64_t v9 = a3;
    do
    {
      v9 -= 184LL;
      sub_100097954(v7 - 184, v9);
      uint64_t v7 = *((void *)&v15 + 1) - 184LL;
      *((void *)&v15 + 1) -= 184LL;
    }

    while (v9 != a5);
    uint64_t v10 = v15;
  }

  char v13 = 1;
  sub_100097B60((uint64_t)v12);
  return v10;
}

void sub_100097B4C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100097B60(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_100097B94((uint64_t *)a1);
  }
  return a1;
}

void sub_100097B94(uint64_t *a1)
{
  uint64_t v1 = (uint64_t *)a1[2];
  uint64_t v3 = *v1;
  uint64_t v2 = v1[1];
  uint64_t v14 = v3;
  uint64_t v15 = v2;
  uint64_t v16 = v3;
  uint64_t v17 = v2;
  uint64_t v4 = *a1;
  uint64_t v5 = (uint64_t *)a1[1];
  uint64_t v7 = *v5;
  uint64_t v6 = v5[1];
  uint64_t v9 = v7;
  uint64_t v10 = v6;
  uint64_t v11 = v7;
  uint64_t v12 = v6;
  sub_100097C08(v4, (uint64_t)v13, (uint64_t)v8);
}

void sub_100097C08(uint64_t a1, uint64_t a2, uint64_t a3)
{
  for (uint64_t i = *(void *)(a2 + 32); i != *(void *)(a3 + 32); *(void *)(a2 + 32) = i)
  {
    uint64_t v6 = (std::mutex *)(i + 16);
    sub_100097750(i + 88, *(void **)(i + 96));
    std::mutex::~mutex(v6);
    uint64_t i = *(void *)(a2 + 32) + 184LL;
  }

uint64_t sub_100097C70(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100097CA4(uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 16); i != a2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 184;
    uint64_t v5 = (std::mutex *)(i - 168);
    sub_100097750(i - 96, *(void **)(i - 88));
    std::mutex::~mutex(v5);
  }

uint64_t sub_100097D04(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_1001781D8);
  sub_100097EC8(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_100097D3C(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001781D8);
  sub_100097EC8(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_100097D7C(char *a1)
{
}

uint64_t sub_100097DC0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_100097DF4(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_100097E40(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_1001781D8);
  sub_100097EC8((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_100097E80(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001781D8);
  sub_100097EC8((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_100097EC8(uint64_t a1)
{
  *(void *)a1 = off_1001782A8;
  sub_100097F64(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_100097F64(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000980CC((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_10009808C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000980B8(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100097EC8(a1);
  operator delete(v1);
}

int *sub_1000980CC(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      uint64_t v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 337LL;
    __int16 v25 = 2082;
    __int128 v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    char v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 337LL;
      __int16 v25 = 2082;
      __int128 v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

const void **sub_1000982B0(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t sub_1000982E0(uint64_t a1, uint64_t a2)
{
  int v4 = v15;
  __int128 v9 = v20;
  __int128 v10 = v21;
  __int128 v11 = v22;
  __int128 v12 = v23;
  __int128 v5 = v16;
  __int128 v6 = v17;
  __int128 v7 = v18;
  __int128 v8 = v19;
  sub_1000EC618((uint64_t)&v4, (uint64_t)v13);
  int v4 = &v14;
  *(void *)&__int128 v5 = (unint64_t)HIDWORD(v15) >> 3;
  sub_1000983BC(a1, (uint64_t)&v4);
  return a1;
}

uint64_t sub_1000983BC(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a2;
  uint64_t v2 = *(unsigned int *)(a1 + 12);
  if ((_DWORD)v2 == -1) {
    sub_100017130();
  }
  __int128 v6 = &v5;
  ((void (*)(uint64_t **, uint64_t))off_100178318[v2])(&v6, a1 + 4);
  return a1;
}

uLong sub_10009841C(const Bytef ****a1, _DWORD *a2)
{
  uLong result = crc32(*a2, ***a1, *((_DWORD *)**a1 + 2));
  *a2 = result;
  return result;
}

uint64_t sub_100098454(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)uLong result = *(_OWORD *)a2;
  if ((*(_BYTE *)(a3 + 16) & 2) != 0) {
    unint64_t v3 = *(void *)a3;
  }
  else {
    unint64_t v3 = *(void *)a3 + 1LL;
  }
  uint64_t v5 = (_OWORD *)(a2 + 144);
  int v4 = *(void **)(a2 + 144);
  __int128 v6 = *(void **)(a2 + 128);
  uint64_t v7 = *(void *)(a2 + 136);
  if (v6 != v4)
  {
    while (1)
    {
      unint64_t v8 = v6[4];
      if ((v6[6] & 2) == 0) {
        ++v8;
      }
      if (v8 >= v3) {
        break;
      }
      __int128 v9 = (void *)v6[1];
      if (v9)
      {
        do
        {
          __int128 v10 = v9;
          __int128 v9 = (void *)*v9;
        }

        while (v9);
      }

      else
      {
        do
        {
          __int128 v10 = (void *)v6[2];
          BOOL v11 = *v10 == (void)v6;
          __int128 v6 = v10;
        }

        while (!v11);
      }

      __int128 v6 = v10;
      if (v10 == v4) {
        goto LABEL_29;
      }
    }
  }

  if (v6 == v4)
  {
LABEL_29:
    int v17 = *(_DWORD *)(a2 + 80);
    *(void *)(result + 96) = 0LL;
    *(void *)(result + 16) = 850045863LL;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(void *)(result + 72) = 0LL;
    *(_DWORD *)(result + 80) = v17;
    *(void *)(result + 104) = 0LL;
    *(void *)(result + 8_Block_object_dispose(va, 8) = result + 96;
    *(_OWORD *)(result + 112) = *v5;
    *(_OWORD *)(result + 12_Block_object_dispose(va, 8) = *v5;
    *(_OWORD *)(result + 144) = *v5;
    *(_BYTE *)(result + 16_Block_object_dispose(va, 8) = 0;
    __int128 v6 = *(void **)(result + 112);
    if (v6 == *(void **)(result + 144)) {
      goto LABEL_33;
    }
    goto LABEL_30;
  }

  __int128 v12 = v6;
  while (1)
  {
    unint64_t v13 = v12[4];
    if ((v12[6] & 2) == 0) {
      ++v13;
    }
    uint64_t v14 = (void *)v12[1];
    if (v14)
    {
      do
      {
        uint64_t v15 = v14;
        uint64_t v14 = (void *)*v14;
      }

      while (v14);
    }

    else
    {
      do
      {
        uint64_t v15 = (void *)v12[2];
        BOOL v11 = *v15 == (void)v12;
        __int128 v12 = v15;
      }

      while (!v11);
    }

    __int128 v12 = v15;
    if (v15 == v4)
    {
      __int128 v12 = *(void **)(a2 + 144);
      break;
    }
  }

  int v16 = *(_DWORD *)(a2 + 80);
  *(void *)(result + 96) = 0LL;
  *(void *)(result + 16) = 850045863LL;
  *(_OWORD *)(result + 24) = 0u;
  *(_OWORD *)(result + 40) = 0u;
  *(_OWORD *)(result + 56) = 0u;
  *(void *)(result + 72) = 0LL;
  *(_DWORD *)(result + 80) = v16;
  *(void *)(result + 8_Block_object_dispose(va, 8) = result + 96;
  *(void *)(result + 104) = 0LL;
  *(void *)(result + 112) = v6;
  *(void *)(result + 120) = v7;
  *(void *)(result + 12_Block_object_dispose(va, 8) = v6;
  *(void *)(result + 136) = v7;
  *(void *)(result + 144) = v12;
  *(void *)(result + 152) = v7;
  *(_BYTE *)(result + 16_Block_object_dispose(va, 8) = 0;
  if (v6 != v12)
  {
LABEL_30:
    char v18 = *((_BYTE *)v6 + 48);
    uint64_t v19 = v6[4];
    if ((v18 & 2) == 0) {
      ++v19;
    }
    *(void *)(result + 160) = v19;
  }

LABEL_33:
  *(_BYTE *)(result + 176) = 0;
  return result;
}

uint64_t sub_100098614(uint64_t a1, unsigned int a2)
{
  *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + 24) = 0LL;
  *(void *)(a1 + 32) = 850045863LL;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 96) = 1018212795LL;
  *(_DWORD *)a1 = 0;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 129) = 0u;
  if (a2) {
    sub_1000986D0((void **)(a1 + 8), a2);
  }
  return a1;
}

void sub_1000986A4(_Unwind_Exception *a1)
{
  __int128 v6 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 16) = v6;
    operator delete(v6);
  }

  _Unwind_Resume(a1);
}

void sub_1000986D0(void **a1, unint64_t a2)
{
  int v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 3)
  {
    if (a2 >> 61) {
      sub_100016F4C();
    }
    int64_t v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    __int128 v6 = (char *)sub_10001848C(v3, a2);
    uint64_t v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8LL];
    __int128 v9 = &v6[8 * v8];
    BOOL v11 = (char *)*a1;
    __int128 v10 = (char *)a1[1];
    __int128 v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        uint64_t v13 = *((void *)v10 - 1);
        v10 -= 8;
        *((void *)v12 - 1) = v13;
        v12 -= 8;
      }

      while (v10 != v11);
      __int128 v10 = (char *)*a1;
    }

    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10) {
      operator delete(v10);
    }
  }

uint64_t sub_100098764(uint64_t a1)
{
  uint64_t v2 = *(uint64_t ***)(a1 + 8);
  uint64_t v3 = *(uint64_t ***)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      int v4 = *v2;
      if (*v2)
      {
        sub_1000114F0((uint64_t)(v4 + 1));
        uint64_t v5 = *v4;
        uint64_t *v4 = 0LL;
        if (v5) {
          (*(void (**)(uint64_t))(*(void *)v5 + 40LL))(v5);
        }
        operator delete(v4);
      }

      ++v2;
    }

    while (v2 != v3);
    uint64_t v2 = *(uint64_t ***)(a1 + 8);
  }

  *(void *)(a1 + 16) = v2;
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 96));
  std::mutex::~mutex((std::mutex *)(a1 + 32));
  __int128 v6 = *(void **)(a1 + 8);
  if (v6)
  {
    *(void *)(a1 + 16) = v6;
    operator delete(v6);
  }

  return a1;
}

void sub_1000987FC( uint64_t a1@<X1>, void *a2@<X2>, int *a3@<X3>, unsigned __int8 *a4@<X4>, void *a5@<X8>)
{
  __int128 v10 = operator new(0x90uLL);
  sub_10009887C(v10, a1, a2, a3, a4);
  *a5 = v10 + 3;
  a5[1] = v10;
  sub_100018774((uint64_t)a5, v10 + 4, (uint64_t)(v10 + 3));
}

void sub_100098868(_Unwind_Exception *a1)
{
}

void *sub_10009887C(void *a1, uint64_t a2, void *a3, int *a4, unsigned __int8 *a5)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_100178338;
  sub_100117374(a1 + 3, a2, *a3, *a4, *a5);
  return a1;
}

void sub_1000988BC(_Unwind_Exception *a1)
{
}

void sub_1000988D0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_100178338;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000988E0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_100178338;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_100098900(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void sub_100098910(uint64_t a1)
{
  *(_BYTE *)(a1 + 152) = 1;
  sub_100097750(a1 + 72, *(void **)(a1 + 80));
  *(void *)(a1 + 72) = a1 + 80;
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 80) = 0LL;
  std::mutex::unlock((std::mutex *)a1);
}

void *sub_100098958(void *a1, uint64_t a2, uint64_t a3)
{
  *a1 = a2;
  __int128 v6 = operator new(0x28uLL);
  void *v6 = &off_100178388;
  v6[1] = 0LL;
  v6[2] = 0LL;
  v6[3] = a2;
  v6[4] = a3;
  a1[1] = v6;
  return a1;
}

void sub_1000989B8(void *a1, uint64_t a2, ...)
{
}

void sub_1000989D0(_Unwind_Exception *a1)
{
}

void sub_1000989E4(void *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  int v4 = (std::mutex *)(*a1 + 32LL);
  std::mutex::lock(v4);
  uint64_t v5 = *(void **)(v3 + 16);
  unint64_t v6 = *(void *)(v3 + 24);
  if ((unint64_t)v5 >= v6)
  {
    uint64_t v8 = *(void *)(v3 + 8);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    uint64_t v10 = v6 - v8;
    uint64_t v11 = v10 >> 2;
    else {
      unint64_t v12 = v11;
    }
    if (v12) {
      uint64_t v13 = (char *)sub_10001848C(v3 + 24, v12);
    }
    else {
      uint64_t v13 = 0LL;
    }
    uint64_t v14 = &v13[8 * v9];
    uint64_t v15 = &v13[8 * v12];
    *(void *)uint64_t v14 = a2;
    uint64_t v7 = v14 + 8;
    int v17 = *(char **)(v3 + 8);
    int v16 = *(char **)(v3 + 16);
    if (v16 != v17)
    {
      do
      {
        uint64_t v18 = *((void *)v16 - 1);
        v16 -= 8;
        *((void *)v14 - 1) = v18;
        v14 -= 8;
      }

      while (v16 != v17);
      int v16 = *(char **)(v3 + 8);
    }

    *(void *)(v3 + _Block_object_dispose(va, 8) = v14;
    *(void *)(v3 + 16) = v7;
    *(void *)(v3 + 24) = v15;
    if (v16) {
      operator delete(v16);
    }
  }

  else
  {
    *uint64_t v5 = a2;
    uint64_t v7 = v5 + 1;
  }

  *(void *)(v3 + 16) = v7;
  std::mutex::unlock(v4);
  std::condition_variable::notify_one((std::condition_variable *)(v3 + 96));
}

void sub_100098AE4(_Unwind_Exception *a1)
{
}

void sub_100098AFC(std::__shared_weak_count *a1)
{
}

void sub_100098B10(uint64_t a1)
{
}

uint64_t sub_100098B34(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

uint64_t sub_100098B74(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_1001782A8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_100098BDC(_Unwind_Exception *a1)
{
}

_OWORD *sub_100098BF0(uint64_t **a1, unint64_t *a2, uint64_t a3)
{
  __int128 v5 = (void **)sub_100098CC4((uint64_t)a1, &v12, a2);
  unint64_t v6 = *v5;
  if (!*v5)
  {
    uint64_t v7 = (uint64_t **)v5;
    unint64_t v6 = operator new(0x70uLL);
    v10[1] = a1 + 1;
    v6[2] = *(_OWORD *)a3;
    uint64_t v8 = *(void *)(a3 + 24);
    *((void *)v6 + 6) = *(void *)(a3 + 16);
    *((void *)v6 + 7) = v8;
    v6[4] = *(_OWORD *)(a3 + 32);
    *((void *)v6 + 10) = *(void *)(a3 + 48);
    *(_OWORD *)((char *)v6 + 8_Block_object_dispose(va, 8) = *(_OWORD *)(a3 + 56);
    *(void *)(a3 + 56) = 0LL;
    *(void *)(a3 + 64) = 0LL;
    *((void *)v6 + 13) = *(void *)(a3 + 72);
    char v11 = 1;
    sub_100027200(a1, v12, v7, (uint64_t *)v6);
    v10[0] = 0LL;
    sub_100098E4C((uint64_t)v10, 0LL);
  }

  return v6;
}

void *sub_100098CC4(uint64_t a1, void *a2, unint64_t *a3)
{
  __int128 v5 = (void *)(a1 + 8);
  char v4 = *(void **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        uint64_t v7 = v4;
        uint64_t v8 = v4 + 4;
        char v4 = (void *)*v7;
        __int128 v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }

      __int128 v5 = v7 + 1;
      char v4 = (void *)v7[1];
    }

    while (v4);
  }

  else
  {
    uint64_t v7 = (void *)(a1 + 8);
  }

uint64_t sub_100098D54(unint64_t *a1, unint64_t *a2)
{
  int v2 = *((unsigned __int8 *)a1 + 16);
  if (*((_BYTE *)a1 + 16))
  {
    if (v2 == 3)
    {
      unint64_t v4 = *a1;
      unint64_t v3 = a1[1];
      if (v3 >= *a1)
      {
LABEL_4:
        if ((v2 & 2) != 0) {
          unint64_t v5 = v4;
        }
        else {
          unint64_t v5 = v4 + 1;
        }
        unint64_t v6 = *a2;
        if ((a2[2] & 2) == 0) {
          ++v6;
        }
        if (v5 < v6) {
          return 1LL;
        }
        if (v6 == v5) {
          return (v2 & 1) + v3 - 1 < (a2[2] & 1) + a2[1] - 1;
        }
        return 0LL;
      }
    }

    else
    {
      unint64_t v4 = *a1;
      unint64_t v3 = a1[1];
      if (*a1 < v3) {
        goto LABEL_4;
      }
    }
  }

  else
  {
    unint64_t v4 = *a1;
    unint64_t v3 = a1[1];
    if (*a1 < v3 && *a1 + 1 < v3) {
      goto LABEL_4;
    }
  }

  if (*((_BYTE *)a2 + 16))
  {
    if (*((_BYTE *)a2 + 16) == 3) {
      BOOL v9 = a2[1] < *a2;
    }
    else {
      BOOL v9 = *a2 >= a2[1];
    }
  }

  else
  {
    unint64_t v10 = a2[1];
    BOOL v9 = *a2 >= v10 || *a2 + 1 >= v10;
  }

  return !v9;
}

void sub_100098E4C(uint64_t a1, uint64_t a2)
{
  int v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16)) {
      sub_1000114F0((uint64_t)v2 + 88);
    }
    operator delete(v2);
  }

void sub_100098E90(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10 = *a1;
  sub_100098F58((uint64_t)a1, *a1, a4, *a1 + 56 * a1[1], a2, a5, a6);
  if (v10)
  {
    uint64_t v11 = a1[1];
    if (v11)
    {
      uint64_t v12 = v10 + 32;
      do
      {
        --v11;
        uint64_t v12 = sub_1000114F0(v12) + 56;
      }

      while (v11);
    }
  }

  uint64_t v13 = a1[1] + a5;
  *a1 = a2;
  a1[1] = v13;
  a1[2] = a3;
}

void sub_100098F34(_Unwind_Exception *exception_object)
{
  if (v1)
  {
  }

  _Unwind_Resume(exception_object);
}

__n128 sub_100098F58(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  while (a2 != a3)
  {
    *(void *)a5 = *(void *)a2;
    __int128 v7 = *(_OWORD *)(a2 + 8);
    *(void *)(a5 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a5 + _Block_object_dispose(va, 8) = v7;
    __n128 result = *(__n128 *)(a2 + 32);
    *(__n128 *)(a5 + 32) = result;
    *(void *)(a2 + 32) = 0LL;
    *(void *)(a2 + 40) = 0LL;
    *(void *)(a5 + 4_Block_object_dispose(va, 8) = *(void *)(a2 + 48);
    a5 += 56LL;
    a2 += 56LL;
  }

  if (a6)
  {
    uint64_t v9 = a6;
    uint64_t v10 = a5;
    do
    {
      *(void *)uint64_t v10 = *(void *)a7;
      __int128 v11 = *(_OWORD *)(a7 + 8);
      *(void *)(v10 + 24) = *(void *)(a7 + 24);
      *(_OWORD *)(v10 + _Block_object_dispose(va, 8) = v11;
      __n128 result = *(__n128 *)(a7 + 32);
      *(__n128 *)(v10 + 32) = result;
      *(void *)(a7 + 32) = 0LL;
      *(void *)(a7 + 40) = 0LL;
      *(void *)(v10 + 4_Block_object_dispose(va, 8) = *(void *)(a7 + 48);
      a7 += 56LL;
      v10 += 56LL;
      --v9;
    }

    while (v9);
  }

  if (a3 != a4)
  {
    uint64_t v12 = a5 + 56 * a6;
    do
    {
      *(void *)uint64_t v12 = *(void *)a3;
      __int128 v13 = *(_OWORD *)(a3 + 8);
      *(void *)(v12 + 24) = *(void *)(a3 + 24);
      *(_OWORD *)(v12 + _Block_object_dispose(va, 8) = v13;
      __n128 result = *(__n128 *)(a3 + 32);
      *(__n128 *)(v12 + 32) = result;
      *(void *)(a3 + 32) = 0LL;
      *(void *)(a3 + 40) = 0LL;
      *(void *)(v12 + 4_Block_object_dispose(va, 8) = *(void *)(a3 + 48);
      a3 += 56LL;
      v12 += 56LL;
    }

    while (a3 != a4);
  }

  return result;
}

void sub_100099030(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  uint64_t v10 = *a1;
  unint64_t v11 = sub_1000990E0((uint64_t)a1, a3);
  if (v11 >= 0x24924924924924ALL) {
    sub_100014AD4("get_next_capacity, allocator's max size reached");
  }
  uint64_t v12 = v11;
  __int128 v13 = operator new(56 * v11);
  sub_100099160(a1, (uint64_t)v13, v12, a2, a3, a4);
  *a5 = *a1 + a2 - v10;
}

unint64_t sub_1000990E0(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = 0x249249249249249LL;
  uint64_t v3 = *(void *)(a1 + 8);
  unint64_t v4 = *(void *)(a1 + 16);
  if (0x249249249249249LL - v4 < a2 - v4 + v3) {
    sub_100014AD4("get_next_capacity, allocator's max size reached");
  }
  unint64_t v5 = v4 >> 61;
  unint64_t v6 = 8 * v4;
  if (v5 > 4) {
    uint64_t v7 = -1LL;
  }
  else {
    uint64_t v7 = v6;
  }
  unint64_t v8 = v6 / 5;
  if (v5) {
    unint64_t v8 = v7;
  }
  unint64_t v9 = v3 + a2;
  if (v8 < 0x249249249249249LL) {
    unint64_t v2 = v8;
  }
  if (v9 <= v2) {
    return v2;
  }
  else {
    return v9;
  }
}

void sub_100099160(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10 = *a1;
  sub_100099228((uint64_t)a1, *a1, a4, *a1 + 56 * a1[1], a2, a5, a6);
  if (v10)
  {
    uint64_t v11 = a1[1];
    if (v11)
    {
      uint64_t v12 = v10 + 32;
      do
      {
        --v11;
        uint64_t v12 = sub_1000114F0(v12) + 56;
      }

      while (v11);
    }
  }

  uint64_t v13 = a1[1] + a5;
  *a1 = a2;
  a1[1] = v13;
  a1[2] = a3;
}

void sub_100099204(_Unwind_Exception *exception_object)
{
  if (v1)
  {
  }

  _Unwind_Resume(exception_object);
}

__n128 sub_100099228(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  while (a2 != a3)
  {
    *(void *)a5 = *(void *)a2;
    __int128 v7 = *(_OWORD *)(a2 + 8);
    *(void *)(a5 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a5 + _Block_object_dispose(va, 8) = v7;
    *(_OWORD *)(a5 + 32) = *(_OWORD *)(a2 + 32);
    *(void *)(a2 + 32) = 0LL;
    *(void *)(a2 + 40) = 0LL;
    *(void *)(a5 + 4_Block_object_dispose(va, 8) = *(void *)(a2 + 48);
    a5 += 56LL;
    a2 += 56LL;
  }

  *(void *)a5 = *(void *)a7;
  __int128 v8 = *(_OWORD *)(a7 + 8);
  *(void *)(a5 + 24) = *(void *)(a7 + 24);
  *(_OWORD *)(a5 + _Block_object_dispose(va, 8) = v8;
  __n128 result = *(__n128 *)(a7 + 32);
  *(__n128 *)(a5 + 32) = result;
  *(void *)(a7 + 32) = 0LL;
  *(void *)(a7 + 40) = 0LL;
  *(void *)(a5 + 4_Block_object_dispose(va, 8) = *(void *)(a7 + 48);
  if (a3 != a4)
  {
    uint64_t v10 = a5 + 56 * a6;
    do
    {
      *(void *)uint64_t v10 = *(void *)a3;
      __int128 v11 = *(_OWORD *)(a3 + 8);
      *(void *)(v10 + 24) = *(void *)(a3 + 24);
      *(_OWORD *)(v10 + _Block_object_dispose(va, 8) = v11;
      __n128 result = *(__n128 *)(a3 + 32);
      *(__n128 *)(v10 + 32) = result;
      *(void *)(a3 + 32) = 0LL;
      *(void *)(a3 + 40) = 0LL;
      *(void *)(v10 + 4_Block_object_dispose(va, 8) = *(void *)(a3 + 48);
      a3 += 56LL;
      v10 += 56LL;
    }

    while (a3 != a4);
  }

  return result;
}

uint64_t sub_1000992E4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = *(void *)a1 + 32LL;
    do
    {
      --v2;
      uint64_t v3 = sub_1000114F0(v3) + 56;
    }

    while (v2);
  }

  if (*(void *)(a1 + 16) && a1 + 24 != *(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_100099340(uint64_t a1, void *a2, uint64_t a3)
{
  *(_BYTE *)(a1 + _Block_object_dispose(va, 8) = 0;
  *(void *)a1 = off_1001783E8;
  uint64_t v6 = a1 + 24;
  sub_10003DD30(a1 + 24, a1);
  *(void *)(a1 + 560) = *a2;
  uint64_t v7 = a2[1];
  *(void *)(a1 + 56_Block_object_dispose(va, 8) = v7;
  if (v7)
  {
    __int128 v8 = (unint64_t *)(v7 + 8);
    do
      unint64_t v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }

  uint64_t v10 = (uint64_t *)(a1 + 560);
  *(void *)(a1 + 576) = 850045863LL;
  *(void *)(a1 + 632) = 0LL;
  *(_OWORD *)(a1 + 584) = 0u;
  *(_OWORD *)(a1 + 600) = 0u;
  *(_OWORD *)(a1 + 616) = 0u;
  sub_100004CB0(__p, "com.apple.diskimages.band_unmap");
  sub_1000373A8();
  sub_10004001C((void *)(a1 + 640));
  if (SHIBYTE(v28) < 0) {
    operator delete(__p[0]);
  }
  *(_OWORD *)(a1 + 704) = 0u;
  *(_OWORD *)(a1 + 720) = 0u;
  sub_1000996CC(a1);
  *(void *)(a1 + 64) = *(void *)(*(void *)(a1 + 560) + 128LL);
  *(void *)(a1 + 72) = a3;
  sub_100099798((uint64_t *)(a1 + 712), *(void *)(a1 + 16));
  if (*(void *)(a1 + 16))
  {
    unint64_t v11 = 0LL;
    do
    {
      uint64_t v12 = operator new(0x28uLL);
      *uint64_t v12 = 1LL;
      v12[1] = v6;
      v12[2] = 0LL;
      void v12[3] = v11;
      v12[4] = 1LL;
      __p[0] = v12;
      __p[1] = 0LL;
      uint64_t v28 = -1LL;
      unint64_t v13 = *(void *)(a1 + 720);
      if (v13 >= *(void *)(a1 + 728))
      {
        uint64_t v14 = sub_10009E440((uint64_t *)(a1 + 712), (uint64_t)__p);
      }

      else
      {
        sub_100074ACC(*(void *)(a1 + 720), (uint64_t)__p);
        uint64_t v14 = v13 + 24;
        *(void *)(a1 + 720) = v13 + 24;
      }

      *(void *)(a1 + 720) = v14;
      sub_100074A00((uint64_t)__p);
      ++v11;
    }

    while (v11 < *(void *)(a1 + 16));
  }

  *(void *)&__int128 v25 = "DiskImageSparseBundle::DiskImageSparseBundle(const shared_ptr<SparseBundleBackend> &, size_t)";
  *((void *)&v25 + 1) = 44LL;
  int v26 = 0;
  sub_100099848(__p, &v25);
  sub_100004E4C(&v29, (uint64_t)"Initialized bands array of size ", 32LL);
  std::ostream::operator<<(&v29, *(void *)(a1 + 16));
  std::ostream::~ostream(&v29, off_100178658);
  sub_10009E708((uint64_t)__p);
  std::ios::~ios(&v30);
  sub_10006B730(*v10, __p);
  uint64_t v15 = __p[0];
  __p[0] = 0LL;
  uint64_t v16 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = v15;
  if (v16)
  {
    (*(void (**)(uint64_t))(*(void *)v16 + 16LL))(v16);
    int v17 = __p[0];
    __p[0] = 0LL;
    if (v17) {
      (*(void (**)(void *))(*(void *)v17 + 16LL))(v17);
    }
  }

  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 40LL))(a1))
  {
    sub_10006B7E0(*v10, __p);
    uint64_t v18 = __p[0];
    __p[0] = 0LL;
    uint64_t v19 = *(void *)(a1 + 40);
    *(void *)(a1 + 40) = v18;
    if (v19)
    {
      (*(void (**)(uint64_t))(*(void *)v19 + 16LL))(v19);
      __int128 v20 = __p[0];
      __p[0] = 0LL;
      if (v20) {
        (*(void (**)(void *))(*(void *)v20 + 16LL))(v20);
      }
    }

    sub_10006B9E4(*v10, __p);
    __int128 v21 = __p[0];
    __p[0] = 0LL;
    uint64_t v22 = *(void *)(a1 + 344);
    *(void *)(a1 + 344) = v21;
    if (v22)
    {
      (*(void (**)(uint64_t))(*(void *)v22 + 8LL))(v22);
      __int128 v23 = __p[0];
      __p[0] = 0LL;
      if (v23) {
        (*(void (**)(void *))(*(void *)v23 + 8LL))(v23);
      }
    }
  }

  return a1;
}

void sub_100099630( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
}

uint64_t sub_1000996CC(uint64_t a1)
{
  uint64_t result = sub_100099934(*(void *)(a1 + 560) + 24LL);
  if ((_DWORD)result)
  {
    *(void *)&__int128 v4 = "DiskImageSparseBundle::init_bands_array_size()";
    *((void *)&v4 + 1) = 44LL;
    int v5 = 0;
    sub_1000999C4(v6, &v4);
    sub_100004E4C(&v7, (uint64_t)"Mounted on AFP, max open bands is set to ", 41LL);
    std::ostream::operator<<(&v7, *(void *)(a1 + 16));
    std::ostream::~ostream(&v7, off_100178878);
    sub_10009EDF4((uint64_t)v6);
    uint64_t result = std::ios::~ios(&v8);
    uint64_t v3 = 3LL;
  }

  else
  {
    uint64_t v3 = 64LL;
  }

  *(void *)(a1 + 16) = v3;
  return result;
}

void sub_100099784(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t sub_100099798(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3) < a2)
  {
    if (a2 >= 0xAAAAAAAAAAAAAABLL) {
      sub_100016F4C();
    }
    uint64_t v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = sub_1000502FC(result, a2);
    v7[1] = v7[0] + v5;
    v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 24 * v6;
    sub_10009E2F0(a1, v7);
    return sub_10009E3F4((uint64_t)v7);
  }

  return result;
}

void sub_100099834(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *sub_100099848(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000AA92C((uint64_t)a1, a2);
  *a1 = off_100178590;
  a1[45] = &off_100178690;
  a1[46] = &off_1001786B8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose(va, 8) = -1;
  *a1 = off_100178590;
  a1[45] = off_100178618;
  a1[46] = off_100178640;
  return a1;
}

void sub_1000998CC(_Unwind_Exception *a1)
{
}

uint64_t sub_1000998F0(uint64_t a1)
{
  return a1;
}

BOOL sub_100099934(uint64_t a1)
{
  unint64_t v1 = v9;
  if ((v9 & 0x80u) != 0) {
    unint64_t v1 = (unint64_t)__p[1];
  }
  if (v1 == 5)
  {
    uint64_t v2 = (void **)__p[0];
    if ((v9 & 0x80u) == 0) {
      uint64_t v2 = __p;
    }
    int v3 = *(_DWORD *)v2;
    int v4 = *((unsigned __int8 *)v2 + 4);
    BOOL v6 = v3 == 1718642273 && v4 == 115;
  }

  else
  {
    BOOL v6 = 0LL;
    if ((char)v9 < 0) {
LABEL_15:
    }
      operator delete(__p[0]);
  }

  return v6;
}

void *sub_1000999C4(void *a1, __int128 *a2)
{
  int v3 = (std::ios_base *)(a1 + 46);
  sub_1000AA9A8((uint64_t)a1, a2);
  *a1 = off_1001787B0;
  a1[45] = &off_1001788B0;
  a1[46] = &off_1001788D8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose(va, 8) = -1;
  *a1 = off_1001787B0;
  a1[45] = off_100178838;
  a1[46] = off_100178860;
  return a1;
}

void sub_100099A48(_Unwind_Exception *a1)
{
}

uint64_t sub_100099A6C(uint64_t a1)
{
  return a1;
}

uint64_t sub_100099AAC(uint64_t a1)
{
  unsigned int v10 = 0;
  sub_100040300(a1 + 352, 0LL, (uint64_t)v11);
  uint64_t v2 = *(void *)(a1 + 712);
  uint64_t v3 = *(void *)(a1 + 720);
  if (v2 != v3)
  {
    uint64_t v4 = 0LL;
    do
    {
      sub_100074AC8(v8, v2);
      if (v9 && (*(_BYTE *)(v9 + 68) & 1) != 0)
      {
        v6[0] = _NSConcreteStackBlock;
        v6[1] = 1174405120LL;
        v6[2] = sub_100099C08;
        v6[3] = &unk_1001784A8;
        sub_100074AC8(v7, v8);
        v7[3] = &v10;
        sub_100040120(v11, v6);
        ++v4;
        sub_100074A00((uint64_t)v7);
      }

      sub_100074A00((uint64_t)v8);
      v2 += 24LL;
    }

    while (v2 != v3);
  }

  sub_100040280(v11);
  return atomic_load(&v10);
}

void sub_100099BF8(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10000491C(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100099C08(uint64_t a1)
{
  if (sub_1000B866C())
  {
    *(void *)&__int128 v3 = "size_t> DiskImageSparseBundle::flush_open_bands()_block_invoke";
    *((void *)&v3 + 1) = 47LL;
    int v4 = 2;
    sub_100099CD4(v5, &v3);
    sub_100004E4C(&v6, (uint64_t)"Flushing ", 9LL);
    sub_100074930(&v6, *(void *)(a1 + 40));
    std::ostream::~ostream(&v6, off_100178A98);
    sub_10009F3A0((uint64_t)v5);
    std::ios::~ios(&v7);
  }

  uint64_t result = sub_100074728(*(void *)(a1 + 40));
  if ((_DWORD)result) {
    atomic_store(result, *(unsigned int **)(a1 + 56));
  }
  return result;
}

void sub_100099CC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void *sub_100099CD4(void *a1, __int128 *a2)
{
  __int128 v3 = (std::ios_base *)(a1 + 46);
  sub_1000AAA24((uint64_t)a1, a2);
  *a1 = off_1001789D0;
  a1[45] = &off_100178AD0;
  a1[46] = &off_100178AF8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose(va, 8) = -1;
  *a1 = off_1001789D0;
  a1[45] = off_100178A58;
  a1[46] = off_100178A80;
  return a1;
}

void sub_100099D58(_Unwind_Exception *a1)
{
}

uint64_t sub_100099D7C(uint64_t a1)
{
  return a1;
}

uint64_t sub_100099DBC(uint64_t a1, uint64_t a2)
{
  return sub_100074AC8(a1 + 32, a2 + 32);
}

uint64_t sub_100099DC8(uint64_t a1)
{
  return sub_100074A00(a1 + 32);
}

uint64_t sub_100099DD0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (sub_1000B866C())
  {
    *(void *)&__int128 v9 = "int DiskImageSparseBundle::flush(DiskImage::Context &, di_flush_mode)";
    *((void *)&v9 + 1) = 32LL;
    int v10 = 2;
    sub_10009A008(v11, &v9);
    sub_100004E4C(&v12, (uint64_t)"Starting flush", 14LL);
    std::ostream::~ostream(&v12, off_100178CB8);
    sub_10009F94C((uint64_t)v11);
    std::ios::~ios(v13);
  }

  std::mutex::lock((std::mutex *)(a1 + 576));
  sub_10003D2D8(a1 + 80);
  uint64_t v5 = sub_100099AAC(a1);
  uint64_t v7 = v6;
  sub_10003D2F4(a1 + 80);
  if ((_DWORD)v5)
  {
    *(void *)&__int128 v9 = "int DiskImageSparseBundle::flush(DiskImage::Context &, di_flush_mode)";
    *((void *)&v9 + 1) = 32LL;
    int v10 = 16;
    sub_10009A0F0(v11, &v9);
    sub_100004E4C(&v12, (uint64_t)"Flush failed - returning ", 25LL);
    std::ostream::operator<<(&v12, v5);
    std::ostream::~ostream(&v12, off_100178ED8);
    sub_10009FEF8((uint64_t)v11);
    std::ios::~ios(v13);
  }

  else
  {
    if (sub_1000B866C())
    {
      *(void *)&__int128 v9 = "int DiskImageSparseBundle::flush(DiskImage::Context &, di_flush_mode)";
      *((void *)&v9 + 1) = 32LL;
      int v10 = 2;
      sub_10009A1D8(v11, &v9);
      std::ostream::operator<<(&v12, v7);
      sub_100004E4C(&v12, (uint64_t)" bands flushed, calling ", 24LL);
      sub_100116C34(&v12, a3);
      std::ostream::~ostream(&v12, off_1001790F8);
      sub_1000A04A4((uint64_t)v11);
      std::ios::~ios(v13);
    }

    uint64_t v5 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 560) + 16LL))(*(void *)(a1 + 560), a3);
  }

  std::mutex::unlock((std::mutex *)(a1 + 576));
  return v5;
}

void sub_100099FB8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
}

void *sub_10009A008(void *a1, __int128 *a2)
{
  __int128 v3 = (std::ios_base *)(a1 + 46);
  sub_1000AAAA0((uint64_t)a1, a2);
  *a1 = off_100178BF0;
  a1[45] = &off_100178CF0;
  a1[46] = &off_100178D18;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose(va, 8) = -1;
  *a1 = off_100178BF0;
  a1[45] = off_100178C78;
  a1[46] = off_100178CA0;
  return a1;
}

void sub_10009A08C(_Unwind_Exception *a1)
{
}

uint64_t sub_10009A0B0(uint64_t a1)
{
  return a1;
}

void *sub_10009A0F0(void *a1, __int128 *a2)
{
  __int128 v3 = (std::ios_base *)(a1 + 46);
  sub_1000AAB1C((uint64_t)a1, a2);
  *a1 = off_100178E10;
  a1[45] = &off_100178F10;
  a1[46] = &off_100178F38;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose(va, 8) = -1;
  *a1 = off_100178E10;
  a1[45] = off_100178E98;
  a1[46] = off_100178EC0;
  return a1;
}

void sub_10009A174(_Unwind_Exception *a1)
{
}

uint64_t sub_10009A198(uint64_t a1)
{
  return a1;
}

void *sub_10009A1D8(void *a1, __int128 *a2)
{
  __int128 v3 = (std::ios_base *)(a1 + 46);
  sub_1000AAB98((uint64_t)a1, a2);
  *a1 = off_100179030;
  a1[45] = &off_100179130;
  a1[46] = &off_100179158;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose(va, 8) = -1;
  *a1 = off_100179030;
  a1[45] = off_1001790B8;
  a1[46] = off_1001790E0;
  return a1;
}

void sub_10009A25C(_Unwind_Exception *a1)
{
}

uint64_t sub_10009A280(uint64_t a1)
{
  return a1;
}

uint64_t sub_10009A2C0@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, int a3@<W2>, void *a4@<X8>)
{
  else {
    int v8 = 0;
  }
  if (a3) {
    int v9 = v8 | 0x200;
  }
  else {
    int v9 = v8;
  }
  sub_10009A444(a1, a2, (uint64_t)v11);
  if (v12)
  {
LABEL_10:
    sub_100074ACC((uint64_t)a4, (uint64_t)v11);
  }

  else
  {
    while (!sub_10003D378(a1 + 208, a2))
    {
      sub_100074A00((uint64_t)v11);
      sub_10009A444(a1, a2, (uint64_t)v11);
      if (v12) {
        goto LABEL_10;
      }
    }

    sub_10009A670(a1, a2, v9, a4);
  }

  return sub_100074A00((uint64_t)v11);
}

std::chrono::steady_clock::time_point sub_10009A444@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 16);
  if (!v5)
  {
LABEL_14:
    result.__d_.__rep_ = (std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep)operator new(0x28uLL);
    *(void *)result.__d_.__rep_ = 1LL;
    *(void *)(result.__d_.__rep_ + _Block_object_dispose(va, 8) = a1 + 24;
    *(void *)(result.__d_.__rep_ + 24) = 0LL;
    *(void *)(result.__d_.__rep_ + 32) = 0LL;
    *(void *)(result.__d_.__rep_ + 16) = 0LL;
    *(std::chrono::steady_clock::time_point *)a3 = result;
    *(void *)(a3 + _Block_object_dispose(va, 8) = 0LL;
    *(void *)(a3 + 16) = -1LL;
    return result;
  }

  uint64_t v7 = 0LL;
  uint64_t v8 = *(void *)(a1 + 712);
  while (*(void *)(v8 + 16) != a2)
  {
    ++v7;
    v8 += 24LL;
    if (v5 == v7) {
      goto LABEL_14;
    }
  }

  sub_100074AC8(a3, v8);
  uint64_t v9 = *(void *)(a3 + 8);
  if (!v9 || *(void *)(v9 + 32) != a2)
  {
    if (sub_1000B866C())
    {
      *(void *)&__int128 v11 = "DiskImageSparseBundle::find_band_in_array(uint64_t)";
      *((void *)&v11 + 1) = 41LL;
      int v12 = 2;
      sub_10009B07C(v13, &v11);
      sub_100004E4C(&v14, (uint64_t)"Band ", 5LL);
      *(_DWORD *)&v15[*(void *)(v14 - 24)] = *(_DWORD *)&v15[*(void *)(v14 - 24)] & 0xFFFFFFB5 | 8;
      std::ostream::operator<<(&v14, a2);
      *(_DWORD *)&v15[*(void *)(v14 - 24)] = *(_DWORD *)&v15[*(void *)(v14 - 24)] & 0xFFFFFFB5 | 2;
      sub_100004E4C(&v14, (uint64_t)" changed before retain completed", 32LL);
      std::ostream::~ostream(&v14, off_100179978);
      sub_1000A1B54((uint64_t)v13);
      std::ios::~ios(v15);
    }

    sub_100074A00(a3);
    goto LABEL_14;
  }

  if (sub_1000B866C())
  {
    *(void *)&__int128 v11 = "DiskImageSparseBundle::find_band_in_array(uint64_t)";
    *((void *)&v11 + 1) = 41LL;
    int v12 = 2;
    sub_10009AF94(v13, &v11);
    sub_100004E4C(&v14, (uint64_t)"Found ", 6LL);
    sub_100074930(&v14, *(void *)(a3 + 8));
    sub_100004E4C(&v14, (uint64_t)" at index ", 10LL);
    std::ostream::operator<<(&v14, v7);
    std::ostream::~ostream(&v14, off_100179758);
    sub_1000A15A8((uint64_t)v13);
    std::ios::~ios(v15);
  }

  result.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  *(std::chrono::steady_clock::time_point *)(*(void *)a3 + 16LL) = result;
  return result;
}

void sub_10009A670(uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, void *a4@<X8>)
{
  uint64_t v16 = 0LL;
  int v17 = &v16;
  uint64_t v18 = 0x2000000000LL;
  uint64_t v19 = 0LL;
  if (sub_1000B866C())
  {
    *(void *)&__int128 v11 = "DiskImageSparseBundle::open_band(uint64_t, int)";
    *((void *)&v11 + 1) = 32LL;
    int v12 = 2;
    sub_100074578(v13, &v11);
    sub_100004E4C(&v14, (uint64_t)"Opening band ", 13LL);
    *(_DWORD *)&v15[*(void *)(v14 - 24)] = *(_DWORD *)&v15[*(void *)(v14 - 24)] & 0xFFFFFFB5 | 8;
    std::ostream::operator<<(&v14, a2);
    *(_DWORD *)&v15[*(void *)(v14 - 24)] = *(_DWORD *)&v15[*(void *)(v14 - 24)] & 0xFFFFFFB5 | 2;
    std::ostream::~ostream(&v14, off_100174A50);
    sub_100078E40((uint64_t)v13);
    std::ios::~ios(v15);
  }

  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000LL;
  v9[2] = sub_10009A9C4;
  v9[3] = &unk_1001784E0;
  v9[4] = &v16;
  v9[5] = a1;
  v9[6] = a2;
  int v10 = a3;
  sub_10003DD34(a1 + 24, (uint64_t)v9);
  sub_10009AA04(a1, (std::chrono::steady_clock::time_point *)v17[3], a4);
  if (a4[1])
  {
    uint64_t v8 = 0LL;
  }

  else
  {
    uint64_t v8 = 0LL;
    do
    {
      if (!v8 && sub_1000B866C())
      {
        *(void *)&__int128 v11 = "DiskImageSparseBundle::open_band(uint64_t, int)";
        *((void *)&v11 + 1) = 32LL;
        int v12 = 2;
        sub_10009AEAC(v13, &v11);
        sub_100004E4C(&v14, (uint64_t)"Failed to evict band to make room for ", 38LL);
        sub_100074930(&v14, v17[3]);
        sub_100004E4C(&v14, (uint64_t)", retrying", 10LL);
        std::ostream::~ostream(&v14, off_100179538);
        sub_1000A0FFC((uint64_t)v13);
        std::ios::~ios(v15);
      }

      usleep(0x3E8u);
      sub_100074A00((uint64_t)a4);
      ++v8;
      sub_10009AA04(a1, (std::chrono::steady_clock::time_point *)v17[3], a4);
    }

    while (!a4[1]);
  }

  if (sub_1000B866C())
  {
    *(void *)&__int128 v11 = "DiskImageSparseBundle::open_band(uint64_t, int)";
    *((void *)&v11 + 1) = 32LL;
    int v12 = 2;
    sub_10009ADC4(v13, &v11);
    sub_100074930(&v14, a4[1]);
    sub_100004E4C(&v14, (uint64_t)" opened and replaced at attempt ", 32LL);
    std::ostream::operator<<(&v14, v8);
    std::ostream::~ostream(&v14, off_100179318);
    sub_1000A0A50((uint64_t)v13);
    std::ios::~ios(v15);
  }

  _Block_object_dispose(&v16, 8);
}

void sub_10009A95C(_Unwind_Exception *a1)
{
}

void *sub_10009A9C4(uint64_t a1)
{
  std::chrono::steady_clock::time_point result = sub_10007384C( *(void *)(a1 + 48),  *(void *)(a1 + 40) + 24LL,  *(_DWORD *)(a1 + 56),  (void *)(*(void *)(*(void *)(a1 + 40) + 560LL) + 96LL));
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

void sub_10009AA04(uint64_t a1@<X0>, std::chrono::steady_clock::time_point *a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = v25;
  __p = v25;
  __int128 v24 = xmmword_10013C6C0;
  if (*(void *)(a1 + 16))
  {
    uint64_t v7 = 0LL;
    unint64_t v8 = 0LL;
    do
    {
      unint64_t v9 = atomic_load(*(unint64_t **)(*(void *)(a1 + 712) + v7));
      if (v9 == 1)
      {
        *(void *)&v20[0] = *(void *)(*(void *)(*(void *)(a1 + 712) + v7) + 16LL);
        *((void *)&v20[0] + 1) = v8;
        int v10 = (char *)__p + 16 * v24;
        if ((void)v24 == *((void *)&v24 + 1))
        {
          sub_1000AAE04(&__p, v10, 1LL, v20, &v18);
        }

        else
        {
          *(_OWORD *)int v10 = v20[0];
          *(void *)&__int128 v24 = v24 + 1;
        }
      }

      ++v8;
      v7 += 24LL;
    }

    while (v8 < *(void *)(a1 + 16));
    uint64_t v6 = __p;
    __int128 v11 = (uint64_t *)((char *)__p + 16 * v24);
    if ((void)v24)
    {
      uint64_t v12 = 126 - 2 * __clz(v24);
      goto LABEL_13;
    }
  }

  else
  {
    __int128 v11 = (uint64_t *)v25;
  }

  uint64_t v12 = 0LL;
LABEL_13:
  sub_1000A1F3C((uint64_t)v6, v11, (uint64_t)v20, v12, 1);
  if (sub_1000B866C())
  {
    *(void *)&__int128 v18 = "DiskImageSparseBundle::replace_oldest_band(Band *)";
    *((void *)&v18 + 1) = 42LL;
    int v19 = 2;
    sub_10009B164(v20, &v18);
    sub_100004E4C(&v21, (uint64_t)"Looking for an evictable slot for ", 34LL);
    sub_100074930(&v21, (uint64_t)a2);
    std::ostream::~ostream(&v21, off_100179B98);
    sub_1000A3268((uint64_t)v20);
    std::ios::~ios(v22);
  }

  if ((void)v24)
  {
    unint64_t v13 = (uint64_t *)((char *)__p + 8);
    uint64_t v14 = 16 * v24;
    while (1)
    {
      uint64_t v16 = *v13;
      v13 += 2;
      uint64_t v15 = v16;
      sub_100074B34((std::chrono::steady_clock::time_point **)(*(void *)(a1 + 712) + 24 * v16), a2, a3);
      if (a3[1]) {
        break;
      }
      if (sub_1000B866C())
      {
        *(void *)&__int128 v18 = "DiskImageSparseBundle::replace_oldest_band(Band *)";
        *((void *)&v18 + 1) = 42LL;
        int v19 = 2;
        sub_10009B334(v20, &v18);
        sub_100004E4C(&v21, (uint64_t)"Failed placing new ", 19LL);
        sub_100074930(&v21, (uint64_t)a2);
        sub_100004E4C(&v21, (uint64_t)" at index ", 10LL);
        std::ostream::operator<<(&v21, v15);
        std::ostream::~ostream(&v21, off_100179FD8);
        sub_1000A3DC0((uint64_t)v20);
        std::ios::~ios(v22);
      }

      sub_100074A00((uint64_t)a3);
      v14 -= 16LL;
      if (!v14) {
        goto LABEL_21;
      }
    }

    if (sub_1000B866C())
    {
      *(void *)&__int128 v18 = "DiskImageSparseBundle::replace_oldest_band(Band *)";
      *((void *)&v18 + 1) = 42LL;
      int v19 = 2;
      sub_10009B24C(v20, &v18);
      sub_100004E4C(&v21, (uint64_t)"Placed new ", 11LL);
      sub_100074930(&v21, (uint64_t)a2);
      sub_100004E4C(&v21, (uint64_t)" at index ", 10LL);
      std::ostream::operator<<(&v21, v15);
      std::ostream::~ostream(&v21, off_100179DB8);
      sub_1000A3814((uint64_t)v20);
      std::ios::~ios(v22);
    }

    sub_10003D800(a1 + 208, a2[4].__d_.__rep_, 1);
  }

  else
  {
LABEL_21:
    int v17 = operator new(0x28uLL);
    *int v17 = 1LL;
    v17[1] = a1 + 24;
    v17[3] = 0LL;
    v17[4] = 0LL;
    v17[2] = 0LL;
    *a3 = v17;
    a3[1] = 0LL;
    a3[2] = -1LL;
  }

  if (*((void *)&v24 + 1))
  {
    if (v25 != __p) {
      operator delete(__p);
    }
  }

void sub_10009ADAC(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10000491C(a1);
  }
  _Unwind_Resume(a1);
}

void *sub_10009ADC4(void *a1, __int128 *a2)
{
  __int128 v3 = (std::ios_base *)(a1 + 46);
  sub_1000AAC14((uint64_t)a1, a2);
  *a1 = off_100179250;
  a1[45] = &off_100179350;
  a1[46] = &off_100179378;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_100179250;
  a1[45] = off_1001792D8;
  a1[46] = off_100179300;
  return a1;
}

void sub_10009AE48(_Unwind_Exception *a1)
{
}

uint64_t sub_10009AE6C(uint64_t a1)
{
  return a1;
}

void *sub_10009AEAC(void *a1, __int128 *a2)
{
  __int128 v3 = (std::ios_base *)(a1 + 46);
  sub_1000AAC90((uint64_t)a1, a2);
  *a1 = off_100179470;
  a1[45] = &off_100179570;
  a1[46] = &off_100179598;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_100179470;
  a1[45] = off_1001794F8;
  a1[46] = off_100179520;
  return a1;
}

void sub_10009AF30(_Unwind_Exception *a1)
{
}

uint64_t sub_10009AF54(uint64_t a1)
{
  return a1;
}

void *sub_10009AF94(void *a1, __int128 *a2)
{
  __int128 v3 = (std::ios_base *)(a1 + 46);
  sub_1000AAD0C((uint64_t)a1, a2);
  *a1 = off_100179690;
  a1[45] = &off_100179790;
  a1[46] = &off_1001797B8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_100179690;
  a1[45] = off_100179718;
  a1[46] = off_100179740;
  return a1;
}

void sub_10009B018(_Unwind_Exception *a1)
{
}

uint64_t sub_10009B03C(uint64_t a1)
{
  return a1;
}

void *sub_10009B07C(void *a1, __int128 *a2)
{
  __int128 v3 = (std::ios_base *)(a1 + 46);
  sub_1000AAD88((uint64_t)a1, a2);
  *a1 = off_1001798B0;
  a1[45] = &off_1001799B0;
  a1[46] = &off_1001799D8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_1001798B0;
  a1[45] = off_100179938;
  a1[46] = off_100179960;
  return a1;
}

void sub_10009B100(_Unwind_Exception *a1)
{
}

uint64_t sub_10009B124(uint64_t a1)
{
  return a1;
}

void *sub_10009B164(void *a1, __int128 *a2)
{
  __int128 v3 = (std::ios_base *)(a1 + 46);
  sub_1000AAFE4((uint64_t)a1, a2);
  *a1 = off_100179AD0;
  a1[45] = &off_100179BD0;
  a1[46] = &off_100179BF8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_100179AD0;
  a1[45] = off_100179B58;
  a1[46] = off_100179B80;
  return a1;
}

void sub_10009B1E8(_Unwind_Exception *a1)
{
}

uint64_t sub_10009B20C(uint64_t a1)
{
  return a1;
}

void *sub_10009B24C(void *a1, __int128 *a2)
{
  __int128 v3 = (std::ios_base *)(a1 + 46);
  sub_1000AB060((uint64_t)a1, a2);
  *a1 = off_100179CF0;
  a1[45] = &off_100179DF0;
  a1[46] = &off_100179E18;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_100179CF0;
  a1[45] = off_100179D78;
  a1[46] = off_100179DA0;
  return a1;
}

void sub_10009B2D0(_Unwind_Exception *a1)
{
}

uint64_t sub_10009B2F4(uint64_t a1)
{
  return a1;
}

void *sub_10009B334(void *a1, __int128 *a2)
{
  __int128 v3 = (std::ios_base *)(a1 + 46);
  sub_1000AB0DC((uint64_t)a1, a2);
  *a1 = off_100179F10;
  a1[45] = &off_10017A010;
  a1[46] = &off_10017A038;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_100179F10;
  a1[45] = off_100179F98;
  a1[46] = off_100179FC0;
  return a1;
}

void sub_10009B3B8(_Unwind_Exception *a1)
{
}

uint64_t sub_10009B3DC(uint64_t a1)
{
  return a1;
}

uint64_t sub_10009B41C(uint64_t a1)
{
  *(void *)a1 = off_1001783E8;
  *(void *)&__int128 v7 = "DiskImageSparseBundle::~DiskImageSparseBundle()";
  *((void *)&v7 + 1) = 45LL;
  int v8 = 0;
  sub_10009B5A0(v9, &v7);
  sub_100004E4C(&v10, (uint64_t)"Closing bands", 13LL);
  std::ostream::~ostream(&v10, off_10017A1F8);
  sub_1000A436C((uint64_t)v9);
  std::ios::~ios(&v11);
  unint64_t v2 = *(void *)(a1 + 16);
  if (v2)
  {
    unint64_t v3 = 0LL;
    uint64_t v4 = 8LL;
    do
    {
      if (*(void *)(*(void *)(a1 + 712) + v4))
      {
        v6[0] = _NSConcreteStackBlock;
        v6[1] = 0x40000000LL;
        v6[2] = sub_10009B688;
        v6[3] = &unk_100178500;
        void v6[4] = a1;
        v6[5] = v3;
        sub_100040120((dispatch_group_t *)(a1 + 416), v6);
        unint64_t v2 = *(void *)(a1 + 16);
      }

      ++v3;
      v4 += 24LL;
    }

    while (v3 < v2);
  }

  sub_100040234(a1 + 416, 0xFFFFFFFFFFFFFFFFLL);
  v9[0] = (void **)(a1 + 712);
  sub_10009EAF0(v9);
  v9[0] = (void **)(a1 + 664);
  sub_100019334(v9);
  std::mutex::~mutex((std::mutex *)(a1 + 576));
  sub_1000114F0(a1 + 560);
  sub_10009EB60(a1 + 24);
  return a1;
}

void *sub_10009B5A0(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000AB158((uint64_t)a1, a2);
  *a1 = off_10017A130;
  a1[45] = &off_10017A230;
  a1[46] = &off_10017A258;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_10017A130;
  a1[45] = off_10017A1B8;
  a1[46] = off_10017A1E0;
  return a1;
}

void sub_10009B624(_Unwind_Exception *a1)
{
}

uint64_t sub_10009B648(uint64_t a1)
{
  return a1;
}

uint64_t sub_10009B688(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (sub_1000B866C())
  {
    *(void *)&__int128 v5 = "DiskImageSparseBundle::~DiskImageSparseBundle()_block_invoke";
    *((void *)&v5 + 1) = 45LL;
    int v6 = 2;
    sub_10009B824(v7, &v5);
    sub_100004E4C(&v8, (uint64_t)"Background close of band at index ", 34LL);
    std::ostream::operator<<(&v8, *(void *)(a1 + 40));
    std::ostream::~ostream(&v8, off_10017A418);
    sub_1000A4918((uint64_t)v7);
    std::ios::~ios(v9);
  }

  unint64_t v3 = operator new(0x28uLL);
  *unint64_t v3 = 1LL;
  v3[1] = v2 + 24;
  v3[3] = 0LL;
  v3[4] = 0LL;
  v3[2] = 0LL;
  v7[0] = v3;
  v7[1] = 0LL;
  v7[2] = -1LL;
  sub_100074AEC(*(void *)(v2 + 712) + 24LL * *(void *)(a1 + 40), (uint64_t)v7);
  sub_100074A00((uint64_t)v7);
  uint64_t result = sub_1000B866C();
  if ((_DWORD)result)
  {
    *(void *)&__int128 v5 = "DiskImageSparseBundle::~DiskImageSparseBundle()_block_invoke";
    *((void *)&v5 + 1) = 45LL;
    int v6 = 2;
    sub_10009B90C(v7, &v5);
    sub_100004E4C(&v8, (uint64_t)"Closed band at index ", 21LL);
    std::ostream::operator<<(&v8, *(void *)(a1 + 40));
    std::ostream::~ostream(&v8, off_10017A638);
    sub_1000A4EC4((uint64_t)v7);
    return std::ios::~ios(v9);
  }

  return result;
}

void sub_10009B7F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void *sub_10009B824(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000AB1D4((uint64_t)a1, a2);
  *a1 = off_10017A350;
  a1[45] = &off_10017A450;
  a1[46] = &off_10017A478;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_10017A350;
  a1[45] = off_10017A3D8;
  a1[46] = off_10017A400;
  return a1;
}

void sub_10009B8A8(_Unwind_Exception *a1)
{
}

uint64_t sub_10009B8CC(uint64_t a1)
{
  return a1;
}

void *sub_10009B90C(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000AB250((uint64_t)a1, a2);
  *a1 = off_10017A570;
  a1[45] = &off_10017A670;
  a1[46] = &off_10017A698;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_10017A570;
  a1[45] = off_10017A5F8;
  a1[46] = off_10017A620;
  return a1;
}

void sub_10009B990(_Unwind_Exception *a1)
{
}

uint64_t sub_10009B9B4(uint64_t a1)
{
  return a1;
}

void sub_10009B9F8(uint64_t a1)
{
  uint64_t v1 = (void *)sub_10009B41C(a1);
  operator delete(v1);
}

uint64_t sub_10009BA0C(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  uint64_t v7 = 0LL;
  unint64_t v8 = *(void *)(a1 + 64);
  size_t v10 = a4[2];
  unint64_t v9 = a4[3];
  unint64_t v11 = v9 / v8;
  unint64_t v70 = v8;
  unint64_t v12 = v9 % v8;
  while (v10)
  {
    if (v10 >= v70 - v12) {
      size_t v13 = v70 - v12;
    }
    else {
      size_t v13 = v10;
    }
    uint64_t v14 = a4[4];
    uint64_t v15 = (std::__shared_weak_count *)a4[1];
    uint64_t v81 = *a4 + v7;
    unint64_t v82 = v15;
    if (v15)
    {
      p_shared_owners = (unint64_t *)&v15->__shared_owners_;
      do
        unint64_t v17 = __ldxr(p_shared_owners);
      while (__stxr(v17 + 1, p_shared_owners));
    }

    size_t v83 = v13;
    unint64_t v84 = v12;
    uint64_t v85 = v14 - v7;
    char v86 = 0;
    sub_10009A2C0(a1, v11, a3, &v79);
    uint64_t v18 = v80;
    if (!v80)
    {
      if (sub_1000B866C())
      {
        *(void *)&__int128 v76 = "DiskImageSparseBundle::perform_io(ContextSparseBundle &, BOOL, const sg_entry &)";
        *((void *)&v76 + 1) = 33LL;
        int v77 = 2;
        sub_10009C394(v87, &v76);
        sub_100004E4C(&v93, (uint64_t)"Band ", 5LL);
        *(_DWORD *)((char *)v94 + *(void *)(v93 - 24)) = *(_DWORD *)((_BYTE *)v94 + *(void *)(v93 - 24)) & 0xFFFFFFB5 | 8;
        std::ostream::operator<<(&v93, v11);
        *(_DWORD *)((char *)v94 + *(void *)(v93 - 24)) = *(_DWORD *)((_BYTE *)v94 + *(void *)(v93 - 24)) & 0xFFFFFFB5 | 2;
        sub_100004E4C(&v93, (uint64_t)" doesn't exist, returning zeros", 31LL);
        std::ostream::~ostream(&v93, off_10017A858);
        sub_1000A5470((uint64_t)v87);
        std::ios::~ios(v94);
      }

      bzero((void *)(*a4 + v7), v13);
      goto LABEL_96;
    }

    uint64_t v19 = *(void *)(v79 + 24);
    uint64_t v20 = 16 * v19;
    if (*(void *)(*(void *)(a2 + 16) + 16 * v19))
    {
      uint64_t v18 = v80;
    }

    sub_100074678(v18, v87);
    sub_100014DF0(*(void *)(a2 + 16) + 16 * v19, v87);
    uint64_t v21 = (std::__shared_weak_count *)*((void *)&v87[0] + 1);
    if (*((void *)&v87[0] + 1))
    {
      uint64_t v22 = (unint64_t *)(*((void *)&v87[0] + 1) + 8LL);
      do
        unint64_t v23 = __ldaxr(v22);
      while (__stlxr(v23 - 1, v22));
      if (!v23)
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
    }

void sub_10009C090( _Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int a17, int a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, __int128 a39, int a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,char a58,uint64_t a59,uint64_t a60,char a61,uint64_t a62,uint64_t a63)
{
  if (a2)
  {
    sub_100074A00((uint64_t)&a58);
    sub_1000114F0((uint64_t)&a61);
    if (a2 == 2)
    {
      unint64_t v70 = (unsigned int *)__cxa_begin_catch(a1);
      *(void *)&a39 = "DiskImageSparseBundle::perform_io(ContextSparseBundle &, BOOL, const sg_entry &)";
      *((void *)&a39 + 1) = 33LL;
      a40 = 16;
      sub_10009C47C(&a67, &a39);
      if (a18) {
        uint64_t v71 = "Write error: ";
      }
      else {
        uint64_t v71 = "Read error: ";
      }
      if (a18) {
        uint64_t v72 = 13LL;
      }
      else {
        uint64_t v72 = 12LL;
      }
      sub_100004E4C(&STACK[0x338], (uint64_t)v71, v72);
      uint64_t v73 = (const char *)(*(uint64_t (**)(unsigned int *))(*(void *)v70 + 16LL))(v70);
      size_t v74 = strlen(v73);
      sub_100004E4C(&STACK[0x338], (uint64_t)v73, v74);
      sub_100004E4C(&STACK[0x338], (uint64_t)" (band ", 7LL);
      *(_DWORD *)((char *)&STACK[0x338] + *(void *)(STACK[0x338] - 24) + _Block_object_dispose((const void *)(v2 - 120), 8) = *(_DWORD *)((_BYTE *)&STACK[0x338]
                                                                                          + *(void *)(STACK[0x338] - 24)
                                                                                          + 8) & 0xFFFFFFB5 | 8;
      std::ostream::operator<<(&STACK[0x338], v67);
      *(_DWORD *)((char *)&STACK[0x338] + *(void *)(STACK[0x338] - 24) + _Block_object_dispose((const void *)(v2 - 120), 8) = *(_DWORD *)((_BYTE *)&STACK[0x338]
                                                                                          + *(void *)(STACK[0x338] - 24)
                                                                                          + 8) & 0xFFFFFFB5 | 2;
      sub_100004E4C(&STACK[0x338], (uint64_t)", err ", 6LL);
      std::ostream::operator<<(&STACK[0x338], v70[2]);
      sub_100004E4C(&STACK[0x338], (uint64_t)")", 1LL);
      sub_10009C524((uint64_t)&a67);
      __cxa_end_catch();
      JUMPOUT(0x10009C04CLL);
    }

    sub_10000491C(a1);
  }

  _Unwind_Resume(a1);
}

void sub_10009C2F8(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x10009C2E8LL);
  }
  JUMPOUT(0x10009C194LL);
}

uint64_t sub_10009C308(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result)
  {
    if (result)
    {
      unint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
      if (v3)
      {
        p_shared_owners = (unint64_t *)&v3->__shared_owners_;
        do
          unint64_t v5 = __ldxr(p_shared_owners);
        while (__stxr(v5 + 1, p_shared_owners));
        do
          unint64_t v6 = __ldaxr(p_shared_owners);
        while (__stlxr(v6 - 1, p_shared_owners));
        if (!v6)
        {
          ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
          std::__shared_weak_count::__release_weak(v3);
        }
      }

      return 1LL;
    }
  }

  return result;
}

void *sub_10009C394(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000AB2CC((uint64_t)a1, a2);
  *a1 = off_10017A790;
  a1[45] = &off_10017A890;
  a1[46] = &off_10017A8B8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_10017A790;
  a1[45] = off_10017A818;
  a1[46] = off_10017A840;
  return a1;
}

void sub_10009C418(_Unwind_Exception *a1)
{
}

uint64_t sub_10009C43C(uint64_t a1)
{
  return a1;
}

void *sub_10009C47C(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000AB348((uint64_t)a1, a2);
  *a1 = off_10017A9B0;
  a1[45] = &off_10017AAB0;
  a1[46] = &off_10017AAD8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_10017A9B0;
  a1[45] = off_10017AA38;
  a1[46] = off_10017AA60;
  return a1;
}

void sub_10009C500(_Unwind_Exception *a1)
{
}

uint64_t sub_10009C524(uint64_t a1)
{
  return a1;
}

uint64_t sub_10009C564(uint64_t a1)
{
  unsigned int v6 = 0;
  uint64_t v2 = (unint64_t *)(a1 + 704);
  v5[0] = a1;
  v5[1] = &v6;
  unint64_t v3 = atomic_load(v2);
  if (v3 != -1LL)
  {
    unint64_t v8 = v5;
    uint64_t v7 = &v8;
    std::__call_once(v2, &v7, (void (__cdecl *)(void *))sub_1000AB3C4);
  }

  return v6;
}

uint64_t sub_10009C5C0(uint64_t a1, uint64_t a2, void *a3)
{
  int v6 = sub_10009C564(a1);
  if (v6)
  {
    if (v6 >= 0) {
      uint64_t v7 = v6;
    }
    else {
      uint64_t v7 = -v6;
    }
    return -v7;
  }

  else
  {
    uint64_t v9 = sub_10009BA0C(a1, a2, 1, a3);
    uint64_t v8 = v9;
    if (v9 < 0 && (_DWORD)v9) {
      sub_10009C63C(a2);
    }
  }

  return v8;
}

uint64_t sub_10009C63C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  *(void *)&__int128 v3 = "DiskImage::terminate()";
  *((void *)&v3 + 1) = 20LL;
  int v4 = 16;
  sub_1000A5E04(v5, &v3);
  sub_100004E4C(&v6, (uint64_t)"Encountered an inrecoverable I/O error, all future I/Os will be invalidated", 75LL);
  std::ostream::~ostream(&v6, off_10017AC98);
  sub_1000A5F68((uint64_t)v5);
  std::ios::~ios(&v7);
  atomic_store(1u, (unsigned __int8 *)(v1 + 8));
  return sub_100118E88();
}

void sub_10009C6D8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58)
{
}

unint64_t sub_10009C708(void **a1)
{
  unint64_t v2 = (*(uint64_t (**)(void *))(*a1[70] + 40LL))(a1[70]);
  if (v2 % ((uint64_t (*)(void **))(*a1)[3])(a1))
  {
    exception = __cxa_allocate_exception(0x40uLL);
    unint64_t v5 = (void *)sub_100004870((uint64_t)exception, (uint64_t)"Size is not a multiple of block size", 0x16u);
  }

  return v2 / ((uint64_t (*)(void **))(*a1)[3])(a1);
}

uint64_t sub_10009C794(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  BOOL v8 = v11 != 0;
  if (v11 && sub_1000737B4(v11, a4))
  {
    sub_100074A00((uint64_t)v10);
    return sub_1000751DC(*(void *)(a1 + 712) + 24 * a2, a3);
  }

  else
  {
    sub_100074A00((uint64_t)v10);
  }

  return v8;
}

void sub_10009C834(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_10009C848(uint64_t a1, unint64_t a2, void *a3)
{
  uint64_t v6 = a1 + 208;
  uint64_t v7 = sub_10003D378(a1 + 208, a2);
  if ((_DWORD)v7)
  {
    uint64_t v8 = a1 + 24;
    if (sub_1000ABBF8(a3) == *(void *)(a1 + 64))
    {
      if (sub_1000B866C())
      {
        *(void *)&__int128 v19 = "DiskImageSparseBundle::try_unmap_band_extents_without_list(uint64_t, const extents_set_t &)";
        *((void *)&v19 + 1) = 58LL;
        int v20 = 2;
        sub_1000755D0(&v21, &v19);
        sub_100004E4C(&v24, (uint64_t)"Unmapping band ", 15LL);
        *(_DWORD *)&v25[*(void *)(v24 - 24)] = *(_DWORD *)&v25[*(void *)(v24 - 24)] & 0xFFFFFFB5 | 8;
        std::ostream::operator<<(&v24, a2);
        *(_DWORD *)&v25[*(void *)(v24 - 24)] = *(_DWORD *)&v25[*(void *)(v24 - 24)] & 0xFFFFFFB5 | 2;
        sub_100004E4C(&v24, (uint64_t)" completely", 11LL);
        std::ostream::~ostream(&v24, off_100175710);
        sub_10007B048((uint64_t)&v21);
        std::ios::~ios(v25);
      }

      sub_100073A68(v8, a2);
    }

    else
    {
      if (sub_1000B866C())
      {
        *(void *)&__int128 v19 = "DiskImageSparseBundle::try_unmap_band_extents_without_list(uint64_t, const extents_set_t &)";
        *((void *)&v19 + 1) = 58LL;
        int v20 = 2;
        sub_1000756B8(&v21, &v19);
        sub_100004E4C(&v24, (uint64_t)"Unmapping band ", 15LL);
        *(_DWORD *)&v25[*(void *)(v24 - 24)] = *(_DWORD *)&v25[*(void *)(v24 - 24)] & 0xFFFFFFB5 | 8;
        std::ostream::operator<<(&v24, a2);
        *(_DWORD *)&v25[*(void *)(v24 - 24)] = *(_DWORD *)&v25[*(void *)(v24 - 24)] & 0xFFFFFFB5 | 2;
        sub_100004E4C(&v24, (uint64_t)" directly (without list)", 24LL);
        std::ostream::~ostream(&v24, off_100175930);
        sub_10007B5F4((uint64_t)&v21);
        std::ios::~ios(v25);
      }

      sub_100114618((uint64_t)&v21, v8, a2, 0LL, 0);
      uint64_t v11 = (void *)*a3;
      uint64_t v9 = a3 + 1;
      size_t v10 = v11;
      if (v11 != v9)
      {
        do
        {
          if ((v10[6] & 2) != 0) {
            unint64_t v12 = v10[4];
          }
          else {
            unint64_t v12 = v10[4] + 1LL;
          }
          sub_100114DAC((uint64_t)&v21, v12, (v10[6] & 1) + v10[5] - 1LL);
          size_t v13 = (void *)v10[1];
          if (v13)
          {
            do
            {
              uint64_t v14 = v13;
              size_t v13 = (void *)*v13;
            }

            while (v13);
          }

          else
          {
            do
            {
              uint64_t v14 = (void *)v10[2];
              BOOL v15 = *v14 == (void)v10;
              size_t v10 = v14;
            }

            while (!v15);
          }

          size_t v10 = v14;
        }

        while (v14 != v9);
      }

      if (sub_10008F97C(v22)) {
        sub_100073A68(v8, a2);
      }
      else {
        sub_10011494C((uint64_t)&v21);
      }
      uint64_t v16 = v23;
      uint64_t v23 = 0LL;
      if (v16) {
        (*(void (**)(uint64_t))(*(void *)v16 + 8LL))(v16);
      }
      uint64_t v17 = v22;
      uint64_t v22 = 0LL;
      if (v17) {
        (*(void (**)(uint64_t))(*(void *)v17 + 8LL))(v17);
      }
    }

    sub_10003D890(v6, a2);
  }

  return v7;
}

void sub_10009CB3C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14)
{
  if (a2 == 1)
  {
    uint64_t v16 = __cxa_begin_catch(exception_object);
    sub_10003D890(v15, v14);
    exception = __cxa_allocate_exception(0x40uLL);
    sub_10009CC2C((uint64_t)exception, (uint64_t)v16);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_10009CC2C(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &off_100189E78;
  *(_OWORD *)(a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = *(_OWORD *)(a2 + 8);
  sub_1000A6514(a1 + 24, (__int128 *)(a2 + 24));
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  return a1;
}

void sub_10009CC78(_Unwind_Exception *a1)
{
}

uint64_t sub_10009CC8C(uint64_t a1, unint64_t a2, void *a3)
{
  do
  {
    while (1)
    {
      uint64_t v6 = *(void *)(a1 + 16);
      if (!v6) {
        break;
      }
      uint64_t v7 = 0LL;
      uint64_t v8 = (uint64_t *)(*(void *)(a1 + 712) + 16LL);
      while (1)
      {
        uint64_t v9 = *v8;
        v8 += 3;
        if (v9 == a2) {
          break;
        }
        if (v6 == ++v7) {
          goto LABEL_9;
        }
      }

      if (v7 < 0) {
        break;
      }
      uint64_t result = sub_10009C794(a1, v7, a2, a3);
      if ((result & 1) != 0) {
        return result;
      }
      usleep(0x3E8u);
    }

uint64_t sub_10009CD20(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (sub_1000B866C())
  {
    *(void *)&__int128 v38 = "int DiskImageSparseBundle::unmap(DiskImage::Context &, const unmap_extent_t *, size_t)";
    *((void *)&v38 + 1) = 32LL;
    int v39 = 2;
    sub_10009D460(&v30, &v38);
    sub_100004E4C(&v36, (uint64_t)"Starting unmap of ", 18LL);
    std::ostream::operator<<(&v36, a4);
    sub_100004E4C(&v36, (uint64_t)" extents", 8LL);
    std::ostream::~ostream(&v36, off_10017AEB8);
    sub_1000A6778((uint64_t)&v30);
    std::ios::~ios(v37);
  }

  unint64_t v6 = a1[8];
  unsigned int v29 = 0;
  v28[0] = 0LL;
  v28[1] = 0LL;
  unint64_t v27 = (uint64_t *)v28;
  if (a1[43])
  {
    uint64_t v7 = sub_10009C564((uint64_t)a1);
    if (!(_DWORD)v7)
    {
      sub_100040300((uint64_t)(a1 + 80), 0LL, (uint64_t)&v38);
      if (a4)
      {
        uint64_t v8 = 0LL;
        unint64_t v9 = 0LL;
        uint64_t v21 = a3;
        do
        {
          uint64_t v10 = *(void *)(a3 + 16 * v8);
          uint64_t v11 = (*(uint64_t (**)(void *))(*a1 + 24LL))(a1);
          uint64_t v23 = v8;
          uint64_t v12 = *(void *)(a3 + 16 * v8 + 8);
          unint64_t v13 = v11 * v10;
          unint64_t v14 = (*(uint64_t (**)(void *))(*a1 + 24LL))(a1) * v12;
          if (sub_1000B866C())
          {
            *(void *)&__int128 v25 = "int DiskImageSparseBundle::unmap(DiskImage::Context &, const unmap_extent_t *, size_t)";
            *((void *)&v25 + 1) = 32LL;
            int v26 = 2;
            sub_10009D630(&v30, &v25);
            sub_100004E4C(&v36, (uint64_t)"Extent ", 7LL);
            std::ostream::operator<<(&v36, v23);
            sub_100004E4C(&v36, (uint64_t)": [", 3LL);
            uint64_t v15 = v36;
            *(_DWORD *)&v37[*(void *)(v36 - 24)] |= 0x200u;
            *(_DWORD *)&v37[*(void *)(v15 - 24)] = *(_DWORD *)&v37[*(void *)(v15 - 24)] & 0xFFFFFFB5 | 8;
            std::ostream::operator<<(&v36, v13);
            sub_100004E4C(&v36, (uint64_t)"-", 1LL);
            std::ostream::operator<<(&v36, v13 + v14 - 1);
            sub_100004E4C(&v36, (uint64_t)"]", 1LL);
            uint64_t v16 = v36;
            *(_DWORD *)&v37[*(void *)(v36 - 24)] &= ~0x200u;
            *(_DWORD *)&v37[*(void *)(v16 - 24)] = *(_DWORD *)&v37[*(void *)(v16 - 24)] & 0xFFFFFFB5 | 2;
            std::ostream::~ostream(&v36, off_10017B2F8);
            sub_1000A72D0((uint64_t)&v30);
            std::ios::~ios(v37);
          }

          if (v14)
          {
            unint64_t v17 = v13 / v6;
            unint64_t v18 = v13 % v6;
            do
            {
              if (v17 != v9 && v27 != (uint64_t *)v28)
              {
                unint64_t v30 = 0LL;
                uint64_t v31 = &v30;
                uint64_t v32 = 0x4002000000LL;
                unint64_t v33 = sub_10009D718;
                uint64_t v34 = sub_10009D754;
                sub_1000ABE54((uint64_t)v35, (uint64_t)&v27);
                v24[0] = _NSConcreteStackBlock;
                v24[1] = 0x40000000LL;
                v24[2] = sub_10009D764;
                v24[3] = &unk_100178528;
                v24[4] = &v30;
                v24[5] = a1;
                v24[6] = v9;
                v24[7] = &v29;
                sub_100040120((dispatch_group_t *)&v38, v24);
                sub_1000AC034(&v27, v27, (uint64_t *)v28);
                _Block_object_dispose(&v30, 8);
                sub_100026AC4((uint64_t)v35, v35[1]);
              }

              if (v14 >= v6 - v18) {
                unint64_t v19 = v6 - v18;
              }
              else {
                unint64_t v19 = v14;
              }
              if (sub_10008FA8C(a1[43], v17))
              {
                unint64_t v30 = v18;
                uint64_t v31 = (unint64_t *)(v19 + v18);
                LOBYTE(v32) = 2;
                sub_1000AC090(&v27, (uint64_t)&v30);
                unint64_t v9 = v17;
              }

              unint64_t v18 = 0LL;
              ++v17;
              v14 -= v19;
            }

            while (v14);
          }

          uint64_t v8 = v23 + 1;
          a3 = v21;
        }

        while (v23 + 1 != a4);
      }

      else
      {
        unint64_t v9 = 0LL;
      }

      sub_100040280(&v38);
      if (sub_1000B866C())
      {
        *(void *)&__int128 v38 = "int DiskImageSparseBundle::unmap(DiskImage::Context &, const unmap_extent_t *, size_t)";
        *((void *)&v38 + 1) = 32LL;
        int v39 = 2;
        sub_10009DAD4(&v30, &v38);
        sub_100004E4C(&v36, (uint64_t)"Unmap done", 10LL);
        std::ostream::~ostream(&v36, off_10017B958);
        sub_1000A83D4((uint64_t)&v30);
        std::ios::~ios(v37);
      }

      uint64_t v7 = atomic_load(&v29);
    }
  }

  else
  {
    *(void *)&__int128 v38 = "int DiskImageSparseBundle::unmap(DiskImage::Context &, const unmap_extent_t *, size_t)";
    *((void *)&v38 + 1) = 32LL;
    int v39 = 16;
    sub_10009D548(&v30, &v38);
    sub_100004E4C(&v36, (uint64_t)"Unexpected unmap command received on read only image", 52LL);
    std::ostream::~ostream(&v36, off_10017B0D8);
    sub_1000A6D24((uint64_t)&v30);
    std::ios::~ios(v37);
    uint64_t v7 = 4294967277LL;
  }

  sub_100026AC4((uint64_t)&v27, v28[0]);
  return v7;
}

void sub_10009D240( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26, void *a27, uint64_t a28, uint64_t a29, char a30)
{
}

void *sub_10009D460(void *a1, __int128 *a2)
{
  __int128 v3 = (std::ios_base *)(a1 + 46);
  sub_1000ABCE0((uint64_t)a1, a2);
  *a1 = off_10017ADF0;
  a1[45] = &off_10017AEF0;
  a1[46] = &off_10017AF18;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_10017ADF0;
  a1[45] = off_10017AE78;
  a1[46] = off_10017AEA0;
  return a1;
}

void sub_10009D4E4(_Unwind_Exception *a1)
{
}

uint64_t sub_10009D508(uint64_t a1)
{
  return a1;
}

void *sub_10009D548(void *a1, __int128 *a2)
{
  __int128 v3 = (std::ios_base *)(a1 + 46);
  sub_1000ABD5C((uint64_t)a1, a2);
  *a1 = off_10017B010;
  a1[45] = &off_10017B110;
  a1[46] = &off_10017B138;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_10017B010;
  a1[45] = off_10017B098;
  a1[46] = off_10017B0C0;
  return a1;
}

void sub_10009D5CC(_Unwind_Exception *a1)
{
}

uint64_t sub_10009D5F0(uint64_t a1)
{
  return a1;
}

void *sub_10009D630(void *a1, __int128 *a2)
{
  __int128 v3 = (std::ios_base *)(a1 + 46);
  sub_1000ABDD8((uint64_t)a1, a2);
  *a1 = off_10017B230;
  a1[45] = &off_10017B330;
  a1[46] = &off_10017B358;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_10017B230;
  a1[45] = off_10017B2B8;
  a1[46] = off_10017B2E0;
  return a1;
}

void sub_10009D6B4(_Unwind_Exception *a1)
{
}

uint64_t sub_10009D6D8(uint64_t a1)
{
  return a1;
}

void *sub_10009D718(void *result, void *a2)
{
  result[5] = a2[5];
  uint64_t v2 = a2 + 6;
  uint64_t v3 = a2[6];
  result[6] = v3;
  int v4 = result + 6;
  uint64_t v5 = a2[7];
  result[7] = v5;
  if (v5)
  {
    *(void *)(v3 + 16) = v4;
    a2[5] = v2;
    *uint64_t v2 = 0LL;
    a2[7] = 0LL;
  }

  else
  {
    result[5] = v4;
  }

  return result;
}

void sub_10009D754(uint64_t a1)
{
}

uint64_t sub_10009D764(void *a1)
{
  return sub_10009CC8C(a1[5], a1[6], (void *)(*(void *)(a1[4] + 8LL) + 40LL));
}

void *sub_10009D904(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000ABFB8((uint64_t)a1, a2);
  *a1 = off_10017B450;
  a1[45] = &off_10017B550;
  a1[46] = &off_10017B578;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_10017B450;
  a1[45] = off_10017B4D8;
  a1[46] = off_10017B500;
  return a1;
}

void sub_10009D988(_Unwind_Exception *a1)
{
}

uint64_t sub_10009D9AC(uint64_t a1)
{
  return a1;
}

void *sub_10009D9EC(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000AC8B0((uint64_t)a1, a2);
  *a1 = off_10017B670;
  a1[45] = &off_10017B770;
  a1[46] = &off_10017B798;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_10017B670;
  a1[45] = off_10017B6F8;
  a1[46] = off_10017B720;
  return a1;
}

void sub_10009DA70(_Unwind_Exception *a1)
{
}

uint64_t sub_10009DA94(uint64_t a1)
{
  return a1;
}

void *sub_10009DAD4(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000AC92C((uint64_t)a1, a2);
  *a1 = off_10017B890;
  a1[45] = &off_10017B990;
  a1[46] = &off_10017B9B8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_10017B890;
  a1[45] = off_10017B918;
  a1[46] = off_10017B940;
  return a1;
}

void sub_10009DB58(_Unwind_Exception *a1)
{
}

uint64_t sub_10009DB7C(uint64_t a1)
{
  return a1;
}

uint64_t sub_10009DBBC(uint64_t a1)
{
  if (sub_1000B866C())
  {
    *(void *)&__int128 v6 = "void DiskImageSparseBundle::on_eject()";
    *((void *)&v6 + 1) = 36LL;
    int v7 = 2;
    sub_10009DD1C(v8, &v6);
    sub_100004E4C(&v9, (uint64_t)"Evicting all bands for eject", 28LL);
    std::ostream::~ostream(&v9, off_10017BB78);
    sub_1000A8980((uint64_t)v8);
    std::ios::~ios(v10);
  }

  if (*(void *)(a1 + 16))
  {
    uint64_t v2 = 0LL;
    unint64_t v3 = 0LL;
    do
    {
      sub_100074B34((std::chrono::steady_clock::time_point **)(*(void *)(a1 + 712) + v2), 0LL, v5);
      sub_100074A00((uint64_t)v5);
      ++v3;
      v2 += 24LL;
    }

    while (v3 < *(void *)(a1 + 16));
  }

  sub_100040234(a1 + 416, 0xFFFFFFFFFFFFFFFFLL);
  *(void *)&__int128 v6 = "void DiskImageSparseBundle::on_eject()";
  *((void *)&v6 + 1) = 36LL;
  int v7 = 0;
  sub_10009DE04(v8, &v6);
  sub_100004E4C(&v9, (uint64_t)"Sparse bundle ejected", 21LL);
  std::ostream::~ostream(&v9, off_10017BD98);
  sub_1000A8F2C((uint64_t)v8);
  return std::ios::~ios(v10);
}

void sub_10009DCF8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

void *sub_10009DD1C(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000AC9A8((uint64_t)a1, a2);
  *a1 = off_10017BAB0;
  a1[45] = &off_10017BBB0;
  a1[46] = &off_10017BBD8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_10017BAB0;
  a1[45] = off_10017BB38;
  a1[46] = off_10017BB60;
  return a1;
}

void sub_10009DDA0(_Unwind_Exception *a1)
{
}

uint64_t sub_10009DDC4(uint64_t a1)
{
  return a1;
}

void *sub_10009DE04(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000ACA24((uint64_t)a1, a2);
  *a1 = off_10017BCD0;
  a1[45] = &off_10017BDD0;
  a1[46] = &off_10017BDF8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_10017BCD0;
  a1[45] = off_10017BD58;
  a1[46] = off_10017BD80;
  return a1;
}

void sub_10009DE88(_Unwind_Exception *a1)
{
}

uint64_t sub_10009DEAC(uint64_t a1)
{
  return a1;
}

uint64_t sub_10009DEEC(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_10009E00C(a1, a2);
  if (!(_DWORD)result)
  {
    unint64_t v5 = (a2 + 4095) & 0xFFFFFFFFFFFFF000LL;
    if (v5 < 0x200000000000001LL)
    {
      return (*(uint64_t (**)(void, unint64_t))(**(void **)(a1 + 560) + 56LL))( *(void *)(a1 + 560),  v5);
    }

    else
    {
      *(void *)&__int128 v6 = "int DiskImageSparseBundle::set_size(uint64_t)";
      *((void *)&v6 + 1) = 35LL;
      int v7 = 16;
      sub_10009E12C(v8, &v6);
      std::ostream::operator<<(&v9, v5);
      sub_100004E4C(&v9, (uint64_t)" bytes are above the sparsebundle limit of ", 43LL);
      std::ostream::operator<<(&v9, 0x200000000000000LL);
      sub_100004E4C(&v9, (uint64_t)" bytes", 6LL);
      std::ostream::~ostream(&v9, off_10017BFB8);
      sub_1000A94D8((uint64_t)v8);
      std::ios::~ios(&v10);
      return 4294967269LL;
    }
  }

  return result;
}

void sub_10009DFF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t sub_10009E00C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 32LL))(a1);
  unint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24LL))(a1) * v4;
  unint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24LL))(a1);
  unint64_t v7 = (a2 + v6 - 1) / v6 * v6;
  if (v5 <= v7) {
    return 0LL;
  }
  v11[0] = v7 / (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24LL))(a1);
  v11[1] = (v5 - v7) / (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24LL))(a1);
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 136LL))(a1);
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)a1 + 184LL))(a1, v8, v11, 1LL);
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 40LL))(v8);
  }
  return v9;
}

void sub_10009E10C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 40LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10009E12C(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000ACAA0((uint64_t)a1, a2);
  *a1 = off_10017BEF0;
  a1[45] = &off_10017BFF0;
  a1[46] = &off_10017C018;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_10017BEF0;
  a1[45] = off_10017BF78;
  a1[46] = off_10017BFA0;
  return a1;
}

void sub_10009E1B0(_Unwind_Exception *a1)
{
}

uint64_t sub_10009E1D4(uint64_t a1)
{
  return a1;
}

  ;
}

uint64_t sub_10009E21C(uint64_t a1)
{
  return *(void *)(a1 + 72);
}

uint64_t sub_10009E224(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 560) + 48LL))(*(void *)(a1 + 560));
}

uint64_t sub_10009E234@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0xB8uLL);
  uint64_t result = sub_10002ED6C((uint64_t)v4, a1);
  *a2 = (char *)v4 + *(void *)(*v4 - 104LL);
  return result;
}

void sub_10009E280(_Unwind_Exception *a1)
{
}

uint64_t sub_10009E294()
{
  return 1LL;
}

void *sub_10009E29C(uint64_t a1)
{
  uint64_t v2 = operator new(0x28uLL);
  sub_1000A98C0(v2, a1);
  return v2;
}

void sub_10009E2D0(_Unwind_Exception *a1)
{
}

uint64_t sub_10009E2E4(uint64_t a1, uint64_t a2, void *a3)
{
  return sub_10009BA0C(a1, a2, 0, a3);
}

uint64_t sub_10009E2F0(uint64_t *a1, void *a2)
{
  uint64_t result = sub_10009E364((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_10009E364(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = 0LL;
  uint64_t v11 = a7 - 24;
  while (a3 + v10 != a5)
  {
    uint64_t v12 = v11 + v10;
    v10 -= 24LL;
    sub_100074AC8(v12, v10 + a3);
  }

  return a6;
}

uint64_t sub_10009E3F4(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 24;
    sub_100074A00(i - 24);
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_10009E440(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL) {
    sub_100016F4C();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x555555555555555LL) {
    unint64_t v9 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v9 = v5;
  }
  unint64_t v17 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)sub_1000502FC(v7, v9);
  }
  else {
    uint64_t v10 = 0LL;
  }
  unint64_t v13 = v10;
  unint64_t v14 = &v10[24 * v4];
  uint64_t v16 = &v10[24 * v9];
  sub_100074ACC((uint64_t)v14, a2);
  uint64_t v15 = v14 + 24;
  sub_10009E2F0(a1, &v13);
  uint64_t v11 = a1[1];
  sub_10009E3F4((uint64_t)&v13);
  return v11;
}

void sub_10009E530(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_10009E544(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100178658);
  sub_10009E708(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_10009E57C(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100178658);
  sub_10009E708(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_10009E5BC(char *a1)
{
}

uint64_t sub_10009E600(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_10009E634(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_10009E680(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100178658);
  sub_10009E708((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_10009E6C0(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100178658);
  sub_10009E708((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_10009E708(uint64_t a1)
{
  *(void *)a1 = off_100178728;
  sub_10009E7A4(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_10009E7A4(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_10009E90C((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_10009E8CC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10009E8F8(uint64_t a1)
{
  uint64_t v1 = (void *)sub_10009E708(a1);
  operator delete(v1);
}

int *sub_10009E90C(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      uint64_t v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 46LL;
    __int16 v25 = 2082;
    int v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    unint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 46LL;
      __int16 v25 = 2082;
      int v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

void sub_10009EAF0(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    int v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        uint64_t v4 = sub_100074A00(v4 - 24);
      while ((void *)v4 != v2);
      int v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

uint64_t sub_10009EB60(uint64_t a1)
{
  char v6 = (void **)(a1 + 352);
  sub_100019334(&v6);
  uint64_t v2 = *(void *)(a1 + 320);
  *(void *)(a1 + 320) = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 272));
  std::mutex::~mutex((std::mutex *)(a1 + 208));
  sub_100026AC4(a1 + 184, *(void **)(a1 + 192));
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 136));
  std::mutex::~mutex((std::mutex *)(a1 + 64));
  sub_1000114F0(a1 + 24);
  uint64_t v3 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 16LL))(v3);
  }
  uint64_t v4 = *(void *)(a1 + 8);
  *(void *)(a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 16LL))(v4);
  }
  return a1;
}

uint64_t sub_10009EC30(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100178878);
  sub_10009EDF4(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_10009EC68(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100178878);
  sub_10009EDF4(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_10009ECA8(char *a1)
{
}

uint64_t sub_10009ECEC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_10009ED20(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_10009ED6C(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100178878);
  sub_10009EDF4((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_10009EDAC(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100178878);
  sub_10009EDF4((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_10009EDF4(uint64_t a1)
{
  *(void *)a1 = off_100178948;
  sub_10009EE90(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_10009EE90(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_10009EFF8((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_10009EFB8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10009EFE4(uint64_t a1)
{
  uint64_t v1 = (void *)sub_10009EDF4(a1);
  operator delete(v1);
}

int *sub_10009EFF8(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      uint64_t v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 59LL;
    __int16 v25 = 2082;
    int v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    unint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 59LL;
      __int16 v25 = 2082;
      int v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_10009F1DC(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100178A98);
  sub_10009F3A0(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_10009F214(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100178A98);
  sub_10009F3A0(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_10009F254(char *a1)
{
}

uint64_t sub_10009F298(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_10009F2CC(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_10009F318(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100178A98);
  sub_10009F3A0((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_10009F358(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100178A98);
  sub_10009F3A0((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_10009F3A0(uint64_t a1)
{
  *(void *)a1 = off_100178B68;
  sub_10009F43C(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_10009F43C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_10009F5A4((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_10009F564( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10009F590(uint64_t a1)
{
  uint64_t v1 = (void *)sub_10009F3A0(a1);
  operator delete(v1);
}

int *sub_10009F5A4(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      uint64_t v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 80LL;
    __int16 v25 = 2082;
    int v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    unint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 80LL;
      __int16 v25 = 2082;
      int v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_10009F788(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100178CB8);
  sub_10009F94C(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_10009F7C0(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100178CB8);
  sub_10009F94C(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_10009F800(char *a1)
{
}

uint64_t sub_10009F844(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_10009F878(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_10009F8C4(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100178CB8);
  sub_10009F94C((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_10009F904(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100178CB8);
  sub_10009F94C((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_10009F94C(uint64_t a1)
{
  *(void *)a1 = off_100178D88;
  sub_10009F9E8(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_10009F9E8(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_10009FB50((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_10009FB10( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10009FB3C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_10009F94C(a1);
  operator delete(v1);
}

int *sub_10009FB50(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      uint64_t v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 101LL;
    __int16 v25 = 2082;
    int v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    unint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 101LL;
      __int16 v25 = 2082;
      int v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_10009FD34(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100178ED8);
  sub_10009FEF8(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_10009FD6C(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100178ED8);
  sub_10009FEF8(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_10009FDAC(char *a1)
{
}

uint64_t sub_10009FDF0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_10009FE24(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_10009FE70(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100178ED8);
  sub_10009FEF8((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_10009FEB0(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100178ED8);
  sub_10009FEF8((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_10009FEF8(uint64_t a1)
{
  *(void *)a1 = off_100178FA8;
  sub_10009FF94(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_10009FF94(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000A00FC((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000A00BC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000A00E8(uint64_t a1)
{
  uint64_t v1 = (void *)sub_10009FEF8(a1);
  operator delete(v1);
}

int *sub_1000A00FC(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      uint64_t v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 107LL;
    __int16 v25 = 2082;
    int v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    unint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 107LL;
      __int16 v25 = 2082;
      int v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000A02E0(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_1001790F8);
  sub_1000A04A4(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000A0318(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001790F8);
  sub_1000A04A4(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000A0358(char *a1)
{
}

uint64_t sub_1000A039C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000A03D0(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000A041C(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_1001790F8);
  sub_1000A04A4((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000A045C(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001790F8);
  sub_1000A04A4((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000A04A4(uint64_t a1)
{
  *(void *)a1 = off_1001791C8;
  sub_1000A0540(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000A0540(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000A06A8((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000A0668( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000A0694(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000A04A4(a1);
  operator delete(v1);
}

int *sub_1000A06A8(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      uint64_t v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 111LL;
    __int16 v25 = 2082;
    int v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    unint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 111LL;
      __int16 v25 = 2082;
      int v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000A088C(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100179318);
  sub_1000A0A50(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000A08C4(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100179318);
  sub_1000A0A50(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000A0904(char *a1)
{
}

uint64_t sub_1000A0948(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000A097C(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000A09C8(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100179318);
  sub_1000A0A50((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000A0A08(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100179318);
  sub_1000A0A50((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000A0A50(uint64_t a1)
{
  *(void *)a1 = off_1001793E8;
  sub_1000A0AEC(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000A0AEC(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000A0C54((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000A0C14( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000A0C40(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000A0A50(a1);
  operator delete(v1);
}

int *sub_1000A0C54(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      uint64_t v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 165LL;
    __int16 v25 = 2082;
    int v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    unint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 165LL;
      __int16 v25 = 2082;
      int v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000A0E38(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100179538);
  sub_1000A0FFC(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000A0E70(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100179538);
  sub_1000A0FFC(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000A0EB0(char *a1)
{
}

uint64_t sub_1000A0EF4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000A0F28(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000A0F74(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100179538);
  sub_1000A0FFC((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000A0FB4(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100179538);
  sub_1000A0FFC((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000A0FFC(uint64_t a1)
{
  *(void *)a1 = off_100179608;
  sub_1000A1098(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000A1098(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000A1200((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000A11C0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000A11EC(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000A0FFC(a1);
  operator delete(v1);
}

int *sub_1000A1200(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      uint64_t v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 172LL;
    __int16 v25 = 2082;
    int v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    unint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 172LL;
      __int16 v25 = 2082;
      int v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000A13E4(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100179758);
  sub_1000A15A8(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000A141C(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100179758);
  sub_1000A15A8(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000A145C(char *a1)
{
}

uint64_t sub_1000A14A0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000A14D4(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000A1520(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100179758);
  sub_1000A15A8((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000A1560(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100179758);
  sub_1000A15A8((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000A15A8(uint64_t a1)
{
  *(void *)a1 = off_100179828;
  sub_1000A1644(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000A1644(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000A17AC((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000A176C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000A1798(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000A15A8(a1);
  operator delete(v1);
}

int *sub_1000A17AC(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      uint64_t v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 190LL;
    __int16 v25 = 2082;
    int v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    unint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 190LL;
      __int16 v25 = 2082;
      int v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000A1990(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100179978);
  sub_1000A1B54(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000A19C8(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100179978);
  sub_1000A1B54(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000A1A08(char *a1)
{
}

uint64_t sub_1000A1A4C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000A1A80(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000A1ACC(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100179978);
  sub_1000A1B54((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000A1B0C(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100179978);
  sub_1000A1B54((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000A1B54(uint64_t a1)
{
  *(void *)a1 = off_100179A48;
  sub_1000A1BF0(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000A1BF0(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000A1D58((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000A1D18( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000A1D44(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000A1B54(a1);
  operator delete(v1);
}

int *sub_1000A1D58(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      uint64_t v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 194LL;
    __int16 v25 = 2082;
    int v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    unint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 194LL;
      __int16 v25 = 2082;
      int v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000A1F3C(uint64_t result, uint64_t *a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t v8 = (uint64_t *)result;
LABEL_2:
  uint64_t v9 = v8;
LABEL_3:
  uint64_t v10 = 1 - a4;
  while (2)
  {
    uint64_t v8 = v9;
    uint64_t v11 = v10;
    uint64_t v12 = (char *)a2 - (char *)v9;
    unint64_t v13 = ((char *)a2 - (char *)v9) >> 4;
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        uint64_t v26 = *(a2 - 2);
        uint64_t v27 = *v9;
        char v28 = -1;
        if (v26 >= *v9) {
          char v28 = 1;
        }
        if (v26 == *v9)
        {
          unint64_t v29 = *(a2 - 1);
          unint64_t v30 = v9[1];
          BOOL v31 = v29 >= v30;
          BOOL v32 = v29 == v30;
          char v28 = -1;
          if (v31) {
            char v28 = 1;
          }
          if (v32) {
            char v28 = 0;
          }
        }

        if (v28 < 0)
        {
          uint64_t v33 = v9[1];
          uint64_t v34 = *(a2 - 1);
          uint64_t *v9 = v26;
          v9[1] = v34;
          *(a2 - 2) = v27;
          *(a2 - 1) = v33;
        }

        return result;
      case 3uLL:
        return sub_1000A2420(v9, v9 + 2, a2 - 2);
      case 4uLL:
        return sub_1000A2A44(v9, v9 + 2, v9 + 4, a2 - 2);
      case 5uLL:
        return sub_1000A2B50(v9, v9 + 2, v9 + 4, v9 + 6, a2 - 2);
      default:
        if (v12 <= 383)
        {
          if ((a5 & 1) != 0) {
            return (uint64_t)sub_1000A22BC(v9, a2);
          }
          else {
            return (uint64_t)sub_1000A237C(v9, a2);
          }
        }

        if (v11 != 1)
        {
          unint64_t v14 = v13 >> 1;
          uint64_t v15 = &v9[2 * (v13 >> 1)];
          if ((unint64_t)v12 < 0x801)
          {
            sub_1000A2420(&v9[2 * (v13 >> 1)], v9, a2 - 2);
            if ((a5 & 1) != 0) {
              goto LABEL_22;
            }
          }

          else
          {
            sub_1000A2420(v9, &v9[2 * (v13 >> 1)], a2 - 2);
            sub_1000A2420(v9 + 2, v15 - 2, a2 - 4);
            sub_1000A2420(v9 + 4, &v9[2 * v14 + 2], a2 - 6);
            sub_1000A2420(v15 - 2, v15, &v9[2 * v14 + 2]);
            __int128 v16 = *(_OWORD *)v9;
            *(_OWORD *)uint64_t v9 = *(_OWORD *)v15;
            *(_OWORD *)uint64_t v15 = v16;
            if ((a5 & 1) != 0) {
              goto LABEL_22;
            }
          }

          uint64_t v17 = *(v9 - 2);
          BOOL v18 = v17 == *v9;
          if (v17 >= *v9) {
            char v19 = 1;
          }
          else {
            char v19 = -1;
          }
          if (v18)
          {
            unint64_t v20 = *(v9 - 1);
            unint64_t v21 = v9[1];
            BOOL v22 = v20 == v21;
            char v19 = v20 >= v21 ? 1 : -1;
            if (v22) {
              char v19 = 0;
            }
          }

          if ((v19 & 0x80) == 0)
          {
            uint64_t result = (uint64_t)sub_1000A2574(v9, a2);
            uint64_t v9 = (uint64_t *)result;
            goto LABEL_27;
          }

uint64_t *sub_1000A22BC(uint64_t *result, uint64_t *a2)
{
  if (result != a2)
  {
    uint64_t v2 = result + 2;
    if (result + 2 != a2)
    {
      uint64_t v3 = 0LL;
      int v4 = result;
      do
      {
        int v5 = v2;
        uint64_t v6 = v4[2];
        uint64_t v7 = *v4;
        if (v6 >= *v4) {
          char v8 = 1;
        }
        else {
          char v8 = -1;
        }
        if (v6 == *v4)
        {
          unint64_t v9 = v4[3];
          unint64_t v10 = v4[1];
          BOOL v11 = v9 == v10;
          char v8 = v9 >= v10 ? 1 : -1;
          if (v11) {
            char v8 = 0;
          }
        }

        if (v8 < 0)
        {
          unint64_t v12 = v4[3];
          uint64_t v13 = v3;
          while (1)
          {
            unint64_t v14 = (char *)result + v13;
            uint64_t v15 = *(uint64_t *)((char *)result + v13 + 8);
            *((void *)v14 + 2) = v7;
            *((void *)v14 + 3) = v15;
            if (!v13) {
              break;
            }
            uint64_t v7 = *((void *)v14 - 2);
            if (v6 >= v7) {
              char v16 = 1;
            }
            else {
              char v16 = -1;
            }
            if (v6 == v7)
            {
              unint64_t v17 = *(uint64_t *)((char *)result + v13 - 8);
              BOOL v18 = v12 == v17;
              if (v12 >= v17) {
                char v16 = 1;
              }
              else {
                char v16 = -1;
              }
              if (v18) {
                char v16 = 0;
              }
            }

            v13 -= 16LL;
            if ((v16 & 0x80) == 0)
            {
              char v19 = (uint64_t *)((char *)result + v13 + 16);
              goto LABEL_28;
            }
          }

          char v19 = result;
LABEL_28:
          *char v19 = v6;
          v19[1] = v12;
        }

        uint64_t v2 = v5 + 2;
        v3 += 16LL;
        int v4 = v5;
      }

      while (v5 + 2 != a2);
    }
  }

  return result;
}

uint64_t *sub_1000A237C(uint64_t *result, uint64_t *a2)
{
  if (result != a2)
  {
    uint64_t v2 = result + 2;
    if (result + 2 != a2)
    {
      uint64_t v3 = (unint64_t *)(result + 3);
      do
      {
        int v4 = v2;
        uint64_t v5 = result[2];
        uint64_t v6 = *result;
        if (v5 >= *result) {
          char v7 = 1;
        }
        else {
          char v7 = -1;
        }
        if (v5 == *result)
        {
          unint64_t v8 = result[3];
          unint64_t v9 = result[1];
          BOOL v10 = v8 == v9;
          char v7 = v8 >= v9 ? 1 : -1;
          if (v10) {
            char v7 = 0;
          }
        }

        if (v7 < 0)
        {
          unint64_t v11 = result[3];
          unint64_t v12 = v3;
          do
          {
            *(v12 - 1) = v6;
            *unint64_t v12 = *(v12 - 2);
            uint64_t v6 = *(v12 - 5);
            if (v5 >= v6) {
              char v13 = 1;
            }
            else {
              char v13 = -1;
            }
            if (v5 == v6)
            {
              unint64_t v14 = *(v12 - 4);
              BOOL v15 = v11 == v14;
              if (v11 >= v14) {
                char v13 = 1;
              }
              else {
                char v13 = -1;
              }
              if (v15) {
                char v13 = 0;
              }
            }

            v12 -= 2;
          }

          while (v13 < 0);
          *(v12 - 1) = v5;
          *unint64_t v12 = v11;
        }

        uint64_t v2 = v4 + 2;
        v3 += 2;
        uint64_t result = v4;
      }

      while (v4 + 2 != a2);
    }
  }

  return result;
}

uint64_t sub_1000A2420(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *a1;
  if (*a2 >= *a1) {
    char v5 = 1;
  }
  else {
    char v5 = -1;
  }
  if (*a2 == *a1)
  {
    unint64_t v6 = a2[1];
    unint64_t v7 = a1[1];
    BOOL v8 = v6 >= v7;
    BOOL v9 = v6 == v7;
    char v10 = -1;
    if (v8) {
      char v10 = 1;
    }
    if (v9) {
      char v5 = 0;
    }
    else {
      char v5 = v10;
    }
  }

  uint64_t v11 = *a3;
  char v12 = -1;
  if (*a3 >= v3) {
    char v12 = 1;
  }
  if (v5 < 0)
  {
    if (v11 == v3)
    {
      unint64_t v18 = a3[1];
      unint64_t v19 = a2[1];
      BOOL v8 = v18 >= v19;
      BOOL v20 = v18 == v19;
      char v12 = -1;
      if (v8) {
        char v12 = 1;
      }
      if (v20) {
        char v12 = 0;
      }
    }

    if (v12 < 0)
    {
      uint64_t v36 = a1[1];
      uint64_t v37 = a3[1];
      *a1 = v11;
      a1[1] = v37;
      *a3 = v4;
      a3[1] = v36;
    }

    else
    {
      unint64_t v21 = a1[1];
      uint64_t v22 = a2[1];
      *a1 = v3;
      a1[1] = v22;
      *a2 = v4;
      a2[1] = v21;
      char v23 = -1;
      if (*a3 >= v4) {
        char v23 = 1;
      }
      if (*a3 == v4)
      {
        unint64_t v24 = a3[1];
        BOOL v8 = v24 >= v21;
        BOOL v25 = v24 == v21;
        char v23 = -1;
        if (v8) {
          char v23 = 1;
        }
        if (v25) {
          char v23 = 0;
        }
      }

      if (v23 < 0)
      {
        uint64_t v26 = a3[1];
        *a2 = *a3;
        a2[1] = v26;
        *a3 = v4;
        a3[1] = v21;
        return 2LL;
      }
    }
  }

  else
  {
    if (v11 == v3)
    {
      unint64_t v13 = a3[1];
      unint64_t v14 = a2[1];
      BOOL v8 = v13 >= v14;
      BOOL v15 = v13 == v14;
      char v16 = -1;
      if (v8) {
        char v16 = 1;
      }
      if (v15) {
        char v12 = 0;
      }
      else {
        char v12 = v16;
      }
    }

    if ((v12 & 0x80) == 0) {
      return 0LL;
    }
    *a2 = v11;
    *a3 = v3;
    uint64_t v27 = *a2;
    uint64_t v28 = a2[1];
    a2[1] = a3[1];
    a3[1] = v28;
    uint64_t v29 = *a1;
    char v30 = -1;
    if (v27 >= *a1) {
      char v30 = 1;
    }
    if (v27 == *a1)
    {
      unint64_t v31 = a2[1];
      unint64_t v32 = a1[1];
      BOOL v8 = v31 >= v32;
      BOOL v33 = v31 == v32;
      char v30 = -1;
      if (v8) {
        char v30 = 1;
      }
      if (v33) {
        char v30 = 0;
      }
    }

    if (v30 < 0)
    {
      uint64_t v34 = a1[1];
      uint64_t v35 = a2[1];
      *a1 = v27;
      a1[1] = v35;
      *a2 = v29;
      a2[1] = v34;
      return 2LL;
    }
  }

  return 1LL;
}

void *sub_1000A2574(void *a1, void *a2)
{
  uint64_t v2 = *a1;
  unint64_t v3 = a1[1];
  uint64_t v4 = *(a2 - 2);
  BOOL v5 = *a1 == v4;
  if (*a1 >= v4) {
    char v6 = 1;
  }
  else {
    char v6 = -1;
  }
  if (v5)
  {
    unint64_t v7 = *(a2 - 1);
    BOOL v8 = v3 >= v7;
    BOOL v9 = v3 == v7;
    char v6 = -1;
    if (v8) {
      char v6 = 1;
    }
    if (v9) {
      char v6 = 0;
    }
  }

  if (v6 < 0)
  {
    BOOL v15 = a1;
    uint64_t v11 = a1;
    do
    {
      uint64_t v16 = v11[2];
      v11 += 2;
      BOOL v17 = v2 == v16;
      if (v2 >= v16) {
        char v18 = 1;
      }
      else {
        char v18 = -1;
      }
      if (v17)
      {
        unint64_t v19 = v15[3];
        BOOL v20 = v3 == v19;
        char v18 = v3 >= v19 ? 1 : -1;
        if (v20) {
          char v18 = 0;
        }
      }

      BOOL v15 = v11;
    }

    while ((v18 & 0x80) == 0);
  }

  else
  {
    char v10 = a1 + 2;
    do
    {
      uint64_t v11 = v10;
      if (v10 >= a2) {
        break;
      }
      if (v2 >= *v10) {
        char v12 = 1;
      }
      else {
        char v12 = -1;
      }
      if (v2 == *v10)
      {
        unint64_t v13 = v10[1];
        BOOL v14 = v3 == v13;
        char v12 = v3 >= v13 ? 1 : -1;
        if (v14) {
          char v12 = 0;
        }
      }

      v10 += 2;
    }

    while ((v12 & 0x80) == 0);
  }

  if (v11 >= a2)
  {
    unint64_t v21 = a2;
  }

  else
  {
    unint64_t v21 = a2;
    do
    {
      uint64_t v22 = *(v21 - 2);
      v21 -= 2;
      BOOL v23 = v2 == v22;
      if (v2 >= v22) {
        char v24 = 1;
      }
      else {
        char v24 = -1;
      }
      if (v23)
      {
        unint64_t v25 = *(a2 - 1);
        BOOL v26 = v3 == v25;
        char v24 = v3 >= v25 ? 1 : -1;
        if (v26) {
          char v24 = 0;
        }
      }

      a2 = v21;
    }

    while (v24 < 0);
  }

  if (v11 < v21)
  {
    uint64_t v27 = *v11;
    uint64_t v28 = *v21;
    do
    {
      uint64_t v29 = v11[1];
      uint64_t v30 = v21[1];
      *uint64_t v11 = v28;
      v11[1] = v30;
      *unint64_t v21 = v27;
      v21[1] = v29;
      unint64_t v31 = v11;
      do
      {
        uint64_t v32 = v11[2];
        v11 += 2;
        uint64_t v27 = v32;
        BOOL v33 = v2 == v32;
        if (v2 >= v32) {
          char v34 = 1;
        }
        else {
          char v34 = -1;
        }
        if (v33)
        {
          unint64_t v35 = v31[3];
          BOOL v36 = v3 == v35;
          char v34 = v3 >= v35 ? 1 : -1;
          if (v36) {
            char v34 = 0;
          }
        }

        unint64_t v31 = v11;
      }

      while ((v34 & 0x80) == 0);
      uint64_t v37 = v21;
      do
      {
        uint64_t v38 = *(v21 - 2);
        v21 -= 2;
        uint64_t v28 = v38;
        BOOL v39 = v2 == v38;
        if (v2 >= v38) {
          char v40 = 1;
        }
        else {
          char v40 = -1;
        }
        if (v39)
        {
          unint64_t v41 = *(v37 - 1);
          BOOL v42 = v3 == v41;
          char v40 = v3 >= v41 ? 1 : -1;
          if (v42) {
            char v40 = 0;
          }
        }

        uint64_t v37 = v21;
      }

      while (v40 < 0);
    }

    while (v11 < v21);
  }

  if (v11 - 2 != a1) {
    *(_OWORD *)a1 = *((_OWORD *)v11 - 1);
  }
  *(v11 - 2) = v2;
  *(v11 - 1) = v3;
  return v11;
}

uint64_t *sub_1000A26FC(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = 0LL;
  uint64_t v3 = *a1;
  unint64_t v4 = a1[1];
  do
  {
    uint64_t v5 = a1[v2 + 2];
    if (v5 >= v3) {
      char v6 = 1;
    }
    else {
      char v6 = -1;
    }
    if (v5 == v3)
    {
      unint64_t v7 = a1[v2 + 3];
      BOOL v8 = v7 == v4;
      char v6 = v7 >= v4 ? 1 : -1;
      if (v8) {
        char v6 = 0;
      }
    }

    v2 += 2LL;
  }

  while (v6 < 0);
  BOOL v9 = &a1[v2];
  if (v2 == 2)
  {
    while (v9 < a2)
    {
      char v10 = a2 - 2;
      uint64_t v16 = *(a2 - 2);
      BOOL v17 = v16 == v3;
      if (v16 >= v3) {
        char v18 = 1;
      }
      else {
        char v18 = -1;
      }
      if (v17)
      {
        unint64_t v19 = *(a2 - 1);
        BOOL v20 = v19 == v4;
        char v18 = v19 >= v4 ? 1 : -1;
        if (v20) {
          char v18 = 0;
        }
      }

      a2 -= 2;
      if (v18 < 0) {
        goto LABEL_39;
      }
    }

    char v10 = a2;
  }

  else
  {
    char v10 = a2;
    do
    {
      uint64_t v11 = *(v10 - 2);
      v10 -= 2;
      BOOL v12 = v11 == v3;
      if (v11 >= v3) {
        char v13 = 1;
      }
      else {
        char v13 = -1;
      }
      if (v12)
      {
        unint64_t v14 = *(a2 - 1);
        BOOL v15 = v14 == v4;
        char v13 = v14 >= v4 ? 1 : -1;
        if (v15) {
          char v13 = 0;
        }
      }

      a2 = v10;
    }

    while ((v13 & 0x80) == 0);
  }

BOOL sub_1000A2864(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 4;
  BOOL result = 1LL;
  switch(v4)
  {
    case 0LL:
    case 1LL:
      return result;
    case 2LL:
      uint64_t v6 = *(a2 - 2);
      uint64_t v7 = *a1;
      char v8 = -1;
      if (v6 >= *a1) {
        char v8 = 1;
      }
      if (v6 == *a1)
      {
        unint64_t v9 = *(a2 - 1);
        unint64_t v10 = a1[1];
        BOOL v11 = v9 >= v10;
        BOOL v12 = v9 == v10;
        char v8 = -1;
        if (v11) {
          char v8 = 1;
        }
        if (v12) {
          char v8 = 0;
        }
      }

      if (v8 < 0)
      {
        uint64_t v13 = a1[1];
        uint64_t v14 = *(a2 - 1);
        *a1 = v6;
        a1[1] = v14;
        *(a2 - 2) = v7;
        *(a2 - 1) = v13;
      }

      return result;
    case 3LL:
      sub_1000A2420(a1, a1 + 2, a2 - 2);
      return 1LL;
    case 4LL:
      sub_1000A2A44(a1, a1 + 2, a1 + 4, a2 - 2);
      return 1LL;
    case 5LL:
      sub_1000A2B50(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2);
      return 1LL;
    default:
      BOOL v15 = a1 + 4;
      sub_1000A2420(a1, a1 + 2, a1 + 4);
      uint64_t v16 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1LL;
      }
      uint64_t v17 = 0LL;
      int v18 = 0;
      break;
  }

  while (1)
  {
    uint64_t v19 = *v16;
    uint64_t v20 = *v15;
    if (*v16 >= *v15) {
      char v21 = 1;
    }
    else {
      char v21 = -1;
    }
    if (*v16 == *v15)
    {
      unint64_t v22 = v16[1];
      unint64_t v23 = v15[1];
      BOOL v24 = v22 == v23;
      char v21 = v22 >= v23 ? 1 : -1;
      if (v24) {
        char v21 = 0;
      }
    }

    if (v21 < 0)
    {
      unint64_t v25 = v16[1];
      uint64_t v26 = v17;
      while (1)
      {
        uint64_t v27 = (uint64_t *)((char *)a1 + v26);
        uint64_t v28 = *(uint64_t *)((char *)a1 + v26 + 40);
        v27[6] = v20;
        v27[7] = v28;
        if (v26 == -32) {
          break;
        }
        uint64_t v20 = v27[2];
        if (v19 >= v20) {
          char v29 = 1;
        }
        else {
          char v29 = -1;
        }
        if (v19 == v20)
        {
          unint64_t v30 = *(uint64_t *)((char *)a1 + v26 + 24);
          BOOL v31 = v25 == v30;
          char v29 = v25 >= v30 ? 1 : -1;
          if (v31) {
            char v29 = 0;
          }
        }

        v26 -= 16LL;
        if ((v29 & 0x80) == 0)
        {
          uint64_t v32 = (uint64_t *)((char *)a1 + v26 + 48);
          goto LABEL_38;
        }
      }

      uint64_t v32 = a1;
LABEL_38:
      *uint64_t v32 = v19;
      v32[1] = v25;
      if (++v18 == 8) {
        return v16 + 2 == a2;
      }
    }

    BOOL v15 = v16;
    v17 += 16LL;
    v16 += 2;
    if (v16 == a2) {
      return 1LL;
    }
  }

uint64_t sub_1000A2A44(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t result = sub_1000A2420(a1, a2, a3);
  uint64_t v9 = *a3;
  char v10 = -1;
  if (*a4 >= *a3) {
    char v10 = 1;
  }
  if (*a4 == *a3)
  {
    unint64_t v11 = a4[1];
    unint64_t v12 = a3[1];
    BOOL v13 = v11 >= v12;
    BOOL v14 = v11 == v12;
    char v10 = -1;
    if (v13) {
      char v10 = 1;
    }
    if (v14) {
      char v10 = 0;
    }
  }

  if (v10 < 0)
  {
    *a3 = *a4;
    *a4 = v9;
    uint64_t v15 = *a3;
    uint64_t v16 = a3[1];
    a3[1] = a4[1];
    a4[1] = v16;
    uint64_t v17 = *a2;
    char v18 = -1;
    if (v15 >= *a2) {
      char v18 = 1;
    }
    if (v15 == *a2)
    {
      unint64_t v19 = a3[1];
      unint64_t v20 = a2[1];
      BOOL v13 = v19 >= v20;
      BOOL v21 = v19 == v20;
      char v18 = -1;
      if (v13) {
        char v18 = 1;
      }
      if (v21) {
        char v18 = 0;
      }
    }

    if (v18 < 0)
    {
      *a2 = v15;
      *a3 = v17;
      uint64_t v22 = *a2;
      uint64_t v23 = a2[1];
      a2[1] = a3[1];
      a3[1] = v23;
      uint64_t v24 = *a1;
      char v25 = -1;
      if (v22 >= *a1) {
        char v25 = 1;
      }
      if (v22 == *a1)
      {
        unint64_t v26 = a2[1];
        unint64_t v27 = a1[1];
        BOOL v13 = v26 >= v27;
        BOOL v28 = v26 == v27;
        char v25 = -1;
        if (v13) {
          char v25 = 1;
        }
        if (v28) {
          char v25 = 0;
        }
      }

      if (v25 < 0)
      {
        uint64_t v29 = a1[1];
        uint64_t v30 = a2[1];
        *a1 = v22;
        a1[1] = v30;
        *a2 = v24;
        a2[1] = v29;
      }
    }
  }

  return result;
}

uint64_t sub_1000A2B50(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t result = sub_1000A2A44(a1, a2, a3, a4);
  uint64_t v11 = *a4;
  char v12 = -1;
  if (*a5 >= *a4) {
    char v12 = 1;
  }
  if (*a5 == *a4)
  {
    unint64_t v13 = a5[1];
    unint64_t v14 = a4[1];
    BOOL v15 = v13 >= v14;
    BOOL v16 = v13 == v14;
    char v12 = -1;
    if (v15) {
      char v12 = 1;
    }
    if (v16) {
      char v12 = 0;
    }
  }

  if (v12 < 0)
  {
    *a4 = *a5;
    *a5 = v11;
    uint64_t v17 = *a4;
    uint64_t v18 = a4[1];
    a4[1] = a5[1];
    a5[1] = v18;
    uint64_t v19 = *a3;
    char v20 = -1;
    if (v17 >= *a3) {
      char v20 = 1;
    }
    if (v17 == *a3)
    {
      unint64_t v21 = a4[1];
      unint64_t v22 = a3[1];
      BOOL v15 = v21 >= v22;
      BOOL v23 = v21 == v22;
      char v20 = -1;
      if (v15) {
        char v20 = 1;
      }
      if (v23) {
        char v20 = 0;
      }
    }

    if (v20 < 0)
    {
      *a3 = v17;
      *a4 = v19;
      uint64_t v24 = *a3;
      uint64_t v25 = a3[1];
      a3[1] = a4[1];
      a4[1] = v25;
      uint64_t v26 = *a2;
      char v27 = -1;
      if (v24 >= *a2) {
        char v27 = 1;
      }
      if (v24 == *a2)
      {
        unint64_t v28 = a3[1];
        unint64_t v29 = a2[1];
        BOOL v15 = v28 >= v29;
        BOOL v30 = v28 == v29;
        char v27 = -1;
        if (v15) {
          char v27 = 1;
        }
        if (v30) {
          char v27 = 0;
        }
      }

      if (v27 < 0)
      {
        *a2 = v24;
        *a3 = v26;
        uint64_t v31 = *a2;
        uint64_t v32 = a2[1];
        a2[1] = a3[1];
        a3[1] = v32;
        uint64_t v33 = *a1;
        char v34 = -1;
        if (v31 >= *a1) {
          char v34 = 1;
        }
        if (v31 == *a1)
        {
          unint64_t v35 = a2[1];
          unint64_t v36 = a1[1];
          BOOL v15 = v35 >= v36;
          BOOL v37 = v35 == v36;
          char v34 = -1;
          if (v15) {
            char v34 = 1;
          }
          if (v37) {
            char v34 = 0;
          }
        }

        if (v34 < 0)
        {
          uint64_t v38 = a1[1];
          uint64_t v39 = a2[1];
          *a1 = v31;
          a1[1] = v39;
          *a2 = v33;
          a2[1] = v38;
        }
      }
    }
  }

  return result;
}

char *sub_1000A2CB0(char *a1, char *a2, char *a3, uint64_t a4)
{
  if (a1 != a2)
  {
    uint64_t v8 = a2 - a1;
    uint64_t v9 = (a2 - a1) >> 4;
    if (a2 - a1 >= 17)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      char v12 = &a1[16 * v10];
      do
      {
        sub_1000A2E20((uint64_t)a1, a4, v9, v12);
        v12 -= 16;
        --v11;
      }

      while (v11);
    }

    unint64_t v13 = a2;
    if (a2 != a3)
    {
      unint64_t v14 = a2;
      do
      {
        uint64_t v15 = *(void *)v14;
        if (*(void *)v14 >= *(void *)a1) {
          char v16 = 1;
        }
        else {
          char v16 = -1;
        }
        if (*(void *)v14 == *(void *)a1)
        {
          unint64_t v17 = *((void *)v14 + 1);
          unint64_t v18 = *((void *)a1 + 1);
          BOOL v19 = v17 == v18;
          char v16 = v17 >= v18 ? 1 : -1;
          if (v19) {
            char v16 = 0;
          }
        }

        if (v16 < 0)
        {
          uint64_t v20 = *((void *)v14 + 1);
          uint64_t v21 = *((void *)a1 + 1);
          *(void *)unint64_t v14 = *(void *)a1;
          *((void *)v14 + 1) = v21;
          *(void *)a1 = v15;
          *((void *)a1 + 1) = v20;
          sub_1000A2E20((uint64_t)a1, a4, v9, a1);
        }

        v14 += 16;
      }

      while (v14 != a3);
      unint64_t v13 = a3;
    }

    if (v8 >= 17)
    {
      uint64_t v22 = (unint64_t)v8 >> 4;
      BOOL v23 = a2 - 16;
      do
      {
        uint64_t v25 = *(void *)a1;
        uint64_t v24 = *((void *)a1 + 1);
        uint64_t v26 = (char *)sub_1000A2F74(a1, a4, v22);
        if (v23 == v26)
        {
          *(void *)uint64_t v26 = v25;
          *((void *)v26 + 1) = v24;
        }

        else
        {
          *(_OWORD *)uint64_t v26 = *(_OWORD *)v23;
          *(void *)BOOL v23 = v25;
          *((void *)v23 + 1) = v24;
          sub_1000A3008((uint64_t)a1, (uint64_t)(v26 + 16), a4, (v26 + 16 - a1) >> 4);
        }

        v23 -= 16;
      }

      while (v22-- > 2);
    }

    return v13;
  }

  return a3;
}

uint64_t sub_1000A2E20(uint64_t result, uint64_t a2, uint64_t a3, void *a4)
{
  if (a3 >= 2)
  {
    uint64_t v4 = (uint64_t)a4 - result;
    int64_t v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 4)
    {
      uint64_t v6 = v4 >> 3;
      uint64_t v7 = (v4 >> 3) + 1;
      uint64_t v8 = (void *)(result + 16 * v7);
      uint64_t v9 = v6 + 2;
      if (v9 < a3)
      {
        uint64_t v10 = v8[2];
        BOOL v11 = *v8 == v10;
        if (*v8 >= v10) {
          char v12 = 1;
        }
        else {
          char v12 = -1;
        }
        if (v11)
        {
          unint64_t v13 = *(void *)(result + 16 * v7 + 8);
          unint64_t v14 = v8[3];
          BOOL v15 = v13 >= v14;
          BOOL v16 = v13 == v14;
          char v12 = -1;
          if (v15) {
            char v12 = 1;
          }
          if (v16) {
            char v12 = 0;
          }
        }

        if (v12 < 0)
        {
          v8 += 2;
          uint64_t v7 = v9;
        }
      }

      uint64_t v17 = *v8;
      uint64_t v18 = *a4;
      char v19 = -1;
      if (*v8 >= *a4) {
        char v19 = 1;
      }
      if (*v8 == *a4)
      {
        unint64_t v20 = v8[1];
        unint64_t v21 = a4[1];
        BOOL v15 = v20 >= v21;
        BOOL v22 = v20 == v21;
        char v19 = -1;
        if (v15) {
          char v19 = 1;
        }
        if (v22) {
          char v19 = 0;
        }
      }

      if ((v19 & 0x80) == 0)
      {
        unint64_t v23 = a4[1];
        do
        {
          uint64_t v24 = a4;
          a4 = v8;
          uint64_t v25 = v8[1];
          *uint64_t v24 = v17;
          v24[1] = v25;
          if (v5 < v7) {
            break;
          }
          uint64_t v26 = (2 * v7) | 1;
          uint64_t v8 = (void *)(result + 16 * v26);
          uint64_t v7 = 2 * v7 + 2;
          if (v7 >= a3)
          {
            uint64_t v7 = v26;
          }

          else
          {
            uint64_t v27 = v8[2];
            BOOL v28 = *v8 == v27;
            if (*v8 >= v27) {
              char v29 = 1;
            }
            else {
              char v29 = -1;
            }
            if (v28)
            {
              unint64_t v30 = *(void *)(result + 16 * v26 + 8);
              unint64_t v31 = v8[3];
              BOOL v32 = v30 == v31;
              char v29 = v30 >= v31 ? 1 : -1;
              if (v32) {
                char v29 = 0;
              }
            }

            if (v29 < 0) {
              v8 += 2;
            }
            else {
              uint64_t v7 = v26;
            }
          }

          uint64_t v17 = *v8;
          if (*v8 >= v18) {
            char v33 = 1;
          }
          else {
            char v33 = -1;
          }
          if (*v8 == v18)
          {
            unint64_t v34 = v8[1];
            BOOL v35 = v34 == v23;
            if (v34 >= v23) {
              char v33 = 1;
            }
            else {
              char v33 = -1;
            }
            if (v35) {
              char v33 = 0;
            }
          }
        }

        while ((v33 & 0x80) == 0);
        *a4 = v18;
        a4[1] = v23;
      }
    }
  }

  return result;
}

void *sub_1000A2F74(_OWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 0LL;
  uint64_t v4 = a3 - 2;
  if (a3 < 2) {
    uint64_t v4 = a3 - 1;
  }
  uint64_t v5 = v4 >> 1;
  do
  {
    uint64_t v6 = v3 + 1;
    uint64_t v7 = &a1[v3 + 1];
    uint64_t v8 = (2 * v3) | 1;
    uint64_t v9 = 2 * v3 + 2;
    if (v9 < a3)
    {
      uint64_t v10 = v7[2];
      BOOL v11 = *v7 == v10;
      if (*v7 >= v10) {
        char v12 = 1;
      }
      else {
        char v12 = -1;
      }
      if (v11)
      {
        unint64_t v13 = *((void *)&a1[v6] + 1);
        unint64_t v14 = v7[3];
        BOOL v15 = v13 == v14;
        if (v13 >= v14) {
          char v16 = 1;
        }
        else {
          char v16 = -1;
        }
        if (v15) {
          char v12 = 0;
        }
        else {
          char v12 = v16;
        }
      }

      if (v12 < 0)
      {
        v7 += 2;
        uint64_t v8 = v9;
      }
    }

    *a1 = *(_OWORD *)v7;
    a1 = v7;
    uint64_t v3 = v8;
  }

  while (v8 <= v5);
  return v7;
}

uint64_t sub_1000A3008(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = a4 - 2;
  if (a4 >= 2)
  {
    unint64_t v5 = v4 >> 1;
    uint64_t v6 = (void *)(result + 16 * (v4 >> 1));
    uint64_t v7 = (void *)(a2 - 16);
    uint64_t v8 = *(void *)(a2 - 16);
    uint64_t v9 = *v6;
    char v10 = -1;
    if (*v6 >= v8) {
      char v10 = 1;
    }
    if (*v6 == v8)
    {
      unint64_t v11 = v6[1];
      unint64_t v12 = *(void *)(a2 - 8);
      BOOL v13 = v11 >= v12;
      BOOL v14 = v11 == v12;
      char v10 = -1;
      if (v13) {
        char v10 = 1;
      }
      if (v14) {
        char v10 = 0;
      }
    }

    if (v10 < 0)
    {
      unint64_t v15 = *(void *)(a2 - 8);
      do
      {
        char v16 = v7;
        uint64_t v7 = v6;
        uint64_t v17 = v6[1];
        void *v16 = v9;
        v16[1] = v17;
        if (!v5) {
          break;
        }
        unint64_t v5 = (v5 - 1) >> 1;
        uint64_t v6 = (void *)(result + 16 * v5);
        uint64_t v9 = *v6;
        if (*v6 >= v8) {
          char v18 = 1;
        }
        else {
          char v18 = -1;
        }
        if (*v6 == v8)
        {
          unint64_t v19 = v6[1];
          BOOL v20 = v19 == v15;
          if (v19 >= v15) {
            char v18 = 1;
          }
          else {
            char v18 = -1;
          }
          if (v20) {
            char v18 = 0;
          }
        }
      }

      while (v18 < 0);
      *uint64_t v7 = v8;
      v7[1] = v15;
    }
  }

  return result;
}

uint64_t sub_1000A30A4(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100179B98);
  sub_1000A3268(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000A30DC(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100179B98);
  sub_1000A3268(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000A311C(char *a1)
{
}

uint64_t sub_1000A3160(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000A3194(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000A31E0(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100179B98);
  sub_1000A3268((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000A3220(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100179B98);
  sub_1000A3268((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000A3268(uint64_t a1)
{
  *(void *)a1 = off_100179C68;
  sub_1000A3304(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000A3304(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000A346C((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000A342C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000A3458(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000A3268(a1);
  operator delete(v1);
}

int *sub_1000A346C(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      char v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 213LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      unint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    BOOL v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        char v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 213LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000A3650(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100179DB8);
  sub_1000A3814(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000A3688(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100179DB8);
  sub_1000A3814(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000A36C8(char *a1)
{
}

uint64_t sub_1000A370C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000A3740(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000A378C(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100179DB8);
  sub_1000A3814((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000A37CC(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100179DB8);
  sub_1000A3814((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000A3814(uint64_t a1)
{
  *(void *)a1 = off_100179E88;
  sub_1000A38B0(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000A38B0(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000A3A18((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000A39D8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000A3A04(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000A3814(a1);
  operator delete(v1);
}

int *sub_1000A3A18(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      char v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 218LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      unint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    BOOL v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        char v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 218LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000A3BFC(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100179FD8);
  sub_1000A3DC0(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000A3C34(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100179FD8);
  sub_1000A3DC0(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000A3C74(char *a1)
{
}

uint64_t sub_1000A3CB8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000A3CEC(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000A3D38(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100179FD8);
  sub_1000A3DC0((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000A3D78(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100179FD8);
  sub_1000A3DC0((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000A3DC0(uint64_t a1)
{
  *(void *)a1 = off_10017A0A8;
  sub_1000A3E5C(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000A3E5C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000A3FC4((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000A3F84( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000A3FB0(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000A3DC0(a1);
  operator delete(v1);
}

int *sub_1000A3FC4(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      char v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 222LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      unint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    BOOL v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        char v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 222LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000A41A8(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_10017A1F8);
  sub_1000A436C(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000A41E0(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017A1F8);
  sub_1000A436C(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000A4220(char *a1)
{
}

uint64_t sub_1000A4264(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000A4298(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000A42E4(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_10017A1F8);
  sub_1000A436C((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000A4324(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017A1F8);
  sub_1000A436C((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000A436C(uint64_t a1)
{
  *(void *)a1 = off_10017A2C8;
  sub_1000A4408(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000A4408(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000A4570((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000A4530( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000A455C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000A436C(a1);
  operator delete(v1);
}

int *sub_1000A4570(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      char v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 231LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      unint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    BOOL v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        char v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 231LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000A4754(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_10017A418);
  sub_1000A4918(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000A478C(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017A418);
  sub_1000A4918(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000A47CC(char *a1)
{
}

uint64_t sub_1000A4810(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000A4844(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000A4890(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_10017A418);
  sub_1000A4918((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000A48D0(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017A418);
  sub_1000A4918((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000A4918(uint64_t a1)
{
  *(void *)a1 = off_10017A4E8;
  sub_1000A49B4(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000A49B4(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000A4B1C((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000A4ADC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000A4B08(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000A4918(a1);
  operator delete(v1);
}

int *sub_1000A4B1C(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      char v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 235LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      unint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    BOOL v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        char v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 235LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000A4D00(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_10017A638);
  sub_1000A4EC4(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000A4D38(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017A638);
  sub_1000A4EC4(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000A4D78(char *a1)
{
}

uint64_t sub_1000A4DBC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000A4DF0(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000A4E3C(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_10017A638);
  sub_1000A4EC4((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000A4E7C(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017A638);
  sub_1000A4EC4((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000A4EC4(uint64_t a1)
{
  *(void *)a1 = off_10017A708;
  sub_1000A4F60(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000A4F60(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000A50C8((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000A5088( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000A50B4(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000A4EC4(a1);
  operator delete(v1);
}

int *sub_1000A50C8(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      char v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 237LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      unint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    BOOL v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        char v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 237LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000A52AC(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_10017A858);
  sub_1000A5470(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000A52E4(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017A858);
  sub_1000A5470(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000A5324(char *a1)
{
}

uint64_t sub_1000A5368(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000A539C(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000A53E8(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_10017A858);
  sub_1000A5470((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000A5428(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017A858);
  sub_1000A5470((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000A5470(uint64_t a1)
{
  *(void *)a1 = off_10017A928;
  sub_1000A550C(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000A550C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000A5674((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000A5634( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000A5660(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000A5470(a1);
  operator delete(v1);
}

int *sub_1000A5674(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      char v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 284LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      unint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    BOOL v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        char v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 284LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000A5858(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_10017AA78);
  sub_1000A5A1C(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000A5890(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017AA78);
  sub_1000A5A1C(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000A58D0(char *a1)
{
}

uint64_t sub_1000A5914(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000A5948(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000A5994(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_10017AA78);
  sub_1000A5A1C((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000A59D4(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017AA78);
  sub_1000A5A1C((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000A5A1C(uint64_t a1)
{
  *(void *)a1 = off_10017AB48;
  sub_1000A5AB8(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000A5AB8(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000A5C20((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000A5BE0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000A5C0C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000A5A1C(a1);
  operator delete(v1);
}

int *sub_1000A5C20(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      char v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 295LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      unint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    BOOL v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        char v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 295LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

void *sub_1000A5E04(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000A5EEC((uint64_t)a1, a2);
  *a1 = off_10017ABD0;
  a1[45] = &off_10017ACD0;
  a1[46] = &off_10017ACF8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_10017ABD0;
  a1[45] = off_10017AC58;
  a1[46] = off_10017AC80;
  return a1;
}

void sub_1000A5E88(_Unwind_Exception *a1)
{
}

uint64_t sub_1000A5EAC(uint64_t a1)
{
  return a1;
}

uint64_t sub_1000A5EEC(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_10017AD68;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000A5F54(_Unwind_Exception *a1)
{
}

uint64_t sub_1000A5F68(uint64_t a1)
{
  *(void *)a1 = off_10017AD68;
  sub_1000A61E0(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

void sub_1000A6004(char *a1)
{
}

uint64_t sub_1000A6048(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000A607C(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

uint64_t sub_1000A60C8(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_10017AC98);
  sub_1000A5F68(v2);
  return std::ios::~ios(a1 + 8);
}

void sub_1000A6100(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_10017AC98);
  sub_1000A5F68((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

uint64_t sub_1000A6140(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017AC98);
  sub_1000A5F68(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000A6180(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017AC98);
  sub_1000A5F68((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

void sub_1000A61CC(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000A5F68(a1);
  operator delete(v1);
}

uint64_t sub_1000A61E0(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000A6330((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000A6308( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

int *sub_1000A6330(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      char v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 241LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      unint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    BOOL v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        char v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 241LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000A6514(uint64_t a1, __int128 *a2)
{
  *(_BYTE *)a1 = 0;
  *(_BYTE *)(a1 + 24) = 0;
  sub_1000A655C((_OWORD *)a1, a2);
  return a1;
}

void sub_1000A6540(_Unwind_Exception *exception_object)
{
  if (*(_BYTE *)(v1 + 24)) {
    sub_10011BC20(v1);
  }
  _Unwind_Resume(exception_object);
}

_OWORD *sub_1000A655C(_OWORD *__dst, __int128 *a2)
{
  if (*((_BYTE *)a2 + 24))
  {
    uint64_t v2 = __dst;
    if (*((char *)a2 + 23) < 0)
    {
      __dst = sub_100040504(__dst, *(void **)a2, *((void *)a2 + 1));
    }

    else
    {
      __int128 v3 = *a2;
      *((void *)__dst + 2) = *((void *)a2 + 2);
      *__dst = v3;
    }

    v2[24] = 1;
  }

  return __dst;
}

uint64_t sub_1000A65B4(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_10017AEB8);
  sub_1000A6778(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000A65EC(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017AEB8);
  sub_1000A6778(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000A662C(char *a1)
{
}

uint64_t sub_1000A6670(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000A66A4(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000A66F0(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_10017AEB8);
  sub_1000A6778((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000A6730(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017AEB8);
  sub_1000A6778((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000A6778(uint64_t a1)
{
  *(void *)a1 = off_10017AF88;
  sub_1000A6814(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000A6814(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000A697C((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000A693C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000A6968(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000A6778(a1);
  operator delete(v1);
}

int *sub_1000A697C(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      char v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 434LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      unint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    BOOL v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        char v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 434LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000A6B60(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_10017B0D8);
  sub_1000A6D24(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000A6B98(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017B0D8);
  sub_1000A6D24(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000A6BD8(char *a1)
{
}

uint64_t sub_1000A6C1C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000A6C50(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000A6C9C(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_10017B0D8);
  sub_1000A6D24((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000A6CDC(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017B0D8);
  sub_1000A6D24((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000A6D24(uint64_t a1)
{
  *(void *)a1 = off_10017B1A8;
  sub_1000A6DC0(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000A6DC0(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000A6F28((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000A6EE8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000A6F14(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000A6D24(a1);
  operator delete(v1);
}

int *sub_1000A6F28(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      char v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 443LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      unint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    BOOL v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        char v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 443LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000A710C(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_10017B2F8);
  sub_1000A72D0(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000A7144(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017B2F8);
  sub_1000A72D0(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000A7184(char *a1)
{
}

uint64_t sub_1000A71C8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000A71FC(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000A7248(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_10017B2F8);
  sub_1000A72D0((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000A7288(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017B2F8);
  sub_1000A72D0((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000A72D0(uint64_t a1)
{
  *(void *)a1 = off_10017B3C8;
  sub_1000A736C(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000A736C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000A74D4((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000A7494( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000A74C0(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000A72D0(a1);
  operator delete(v1);
}

int *sub_1000A74D4(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      char v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 460LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      unint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    BOOL v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        char v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 460LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000A76B8(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_10017B518);
  sub_1000A787C(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000A76F0(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017B518);
  sub_1000A787C(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000A7730(char *a1)
{
}

uint64_t sub_1000A7774(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000A77A8(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000A77F4(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_10017B518);
  sub_1000A787C((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000A7834(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017B518);
  sub_1000A787C((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000A787C(uint64_t a1)
{
  *(void *)a1 = off_10017B5E8;
  sub_1000A7918(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000A7918(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000A7A80((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000A7A40( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000A7A6C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000A787C(a1);
  operator delete(v1);
}

int *sub_1000A7A80(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      char v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 469LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      unint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    BOOL v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        char v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 469LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000A7C64(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_10017B738);
  sub_1000A7E28(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000A7C9C(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017B738);
  sub_1000A7E28(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000A7CDC(char *a1)
{
}

uint64_t sub_1000A7D20(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000A7D54(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000A7DA0(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_10017B738);
  sub_1000A7E28((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000A7DE0(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017B738);
  sub_1000A7E28((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000A7E28(uint64_t a1)
{
  *(void *)a1 = off_10017B808;
  sub_1000A7EC4(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000A7EC4(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000A802C((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000A7FEC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000A8018(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000A7E28(a1);
  operator delete(v1);
}

int *sub_1000A802C(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      char v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 492LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      unint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    BOOL v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        char v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 492LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000A8210(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_10017B958);
  sub_1000A83D4(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000A8248(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017B958);
  sub_1000A83D4(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000A8288(char *a1)
{
}

uint64_t sub_1000A82CC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000A8300(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000A834C(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_10017B958);
  sub_1000A83D4((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000A838C(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017B958);
  sub_1000A83D4((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000A83D4(uint64_t a1)
{
  *(void *)a1 = off_10017BA28;
  sub_1000A8470(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000A8470(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000A85D8((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000A8598( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000A85C4(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000A83D4(a1);
  operator delete(v1);
}

int *sub_1000A85D8(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      char v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 498LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      unint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    BOOL v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        char v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 498LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000A87BC(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_10017BB78);
  sub_1000A8980(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000A87F4(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017BB78);
  sub_1000A8980(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000A8834(char *a1)
{
}

uint64_t sub_1000A8878(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000A88AC(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000A88F8(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_10017BB78);
  sub_1000A8980((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000A8938(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017BB78);
  sub_1000A8980((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000A8980(uint64_t a1)
{
  *(void *)a1 = off_10017BC48;
  sub_1000A8A1C(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000A8A1C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000A8B84((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000A8B44( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000A8B70(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000A8980(a1);
  operator delete(v1);
}

int *sub_1000A8B84(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      char v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 505LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      unint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    BOOL v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        char v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 505LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000A8D68(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_10017BD98);
  sub_1000A8F2C(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000A8DA0(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017BD98);
  sub_1000A8F2C(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000A8DE0(char *a1)
{
}

uint64_t sub_1000A8E24(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000A8E58(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000A8EA4(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_10017BD98);
  sub_1000A8F2C((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000A8EE4(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017BD98);
  sub_1000A8F2C((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000A8F2C(uint64_t a1)
{
  *(void *)a1 = off_10017BE68;
  sub_1000A8FC8(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000A8FC8(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000A9130((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000A90F0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000A911C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000A8F2C(a1);
  operator delete(v1);
}

int *sub_1000A9130(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      char v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 511LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      unint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    BOOL v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        char v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 511LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000A9314(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_10017BFB8);
  sub_1000A94D8(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000A934C(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017BFB8);
  sub_1000A94D8(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000A938C(char *a1)
{
}

uint64_t sub_1000A93D0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000A9404(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000A9450(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_10017BFB8);
  sub_1000A94D8((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000A9490(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017BFB8);
  sub_1000A94D8((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000A94D8(uint64_t a1)
{
  *(void *)a1 = off_10017C088;
  sub_1000A9574(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000A9574(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000A96DC((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000A969C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000A96C8(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000A94D8(a1);
  operator delete(v1);
}

int *sub_1000A96DC(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      char v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 523LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      unint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    BOOL v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        char v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 523LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

void *sub_1000A98C0(void *a1, uint64_t a2)
{
  *a1 = off_10017C108;
  a1[1] = a2;
  sub_1000A9ABC(a1 + 2, 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 720) - *(void *)(a2 + 712)) >> 3));
  if (sub_1000B866C())
  {
    *(void *)&__int128 v4 = "DiskImageSparseBundle::ContextSparseBundle::ContextSparseBundle(DiskImageSparseBundle &)";
    *((void *)&v4 + 1) = 63LL;
    int v5 = 2;
    sub_1000A99BC(v6, &v4);
    sub_100004E4C(&v7, (uint64_t)"Constructing sb context", 23LL);
    std::ostream::~ostream(&v7, off_10017C230);
    sub_1000A9BB4((uint64_t)v6);
    std::ios::~ios(&v8);
  }

  return a1;
}

void sub_1000A9990(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void *sub_1000A99BC(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000A9B38((uint64_t)a1, a2);
  *a1 = off_10017C168;
  a1[45] = &off_10017C268;
  a1[46] = &off_10017C290;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_10017C168;
  a1[45] = off_10017C1F0;
  a1[46] = off_10017C218;
  return a1;
}

void sub_1000A9A40(_Unwind_Exception *a1)
{
}

uint64_t sub_1000A9A64(uint64_t a1)
{
  return a1;
}

void sub_1000A9AA8(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000AA160(a1);
  operator delete(v1);
}

void *sub_1000A9ABC(void *a1, unint64_t a2)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if (a2)
  {
    sub_100017080(a1, a2);
    __int128 v4 = (char *)a1[1];
    bzero(v4, 16 * a2);
    a1[1] = &v4[16 * a2];
  }

  return a1;
}

void sub_1000A9B24( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

uint64_t sub_1000A9B38(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_10017C300;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000A9BA0(_Unwind_Exception *a1)
{
}

uint64_t sub_1000A9BB4(uint64_t a1)
{
  *(void *)a1 = off_10017C300;
  sub_1000A9E2C(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

void sub_1000A9C50(char *a1)
{
}

uint64_t sub_1000A9C94(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000A9CC8(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

uint64_t sub_1000A9D14(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_10017C230);
  sub_1000A9BB4(v2);
  return std::ios::~ios(a1 + 8);
}

void sub_1000A9D4C(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_10017C230);
  sub_1000A9BB4((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

uint64_t sub_1000A9D8C(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017C230);
  sub_1000A9BB4(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000A9DCC(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017C230);
  sub_1000A9BB4((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

void sub_1000A9E18(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000A9BB4(a1);
  operator delete(v1);
}

uint64_t sub_1000A9E2C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000A9F7C((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000A9F54( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

int *sub_1000A9F7C(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      char v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 37LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      unint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    BOOL v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        char v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 37LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000AA160(uint64_t a1)
{
  *(void *)a1 = off_10017C108;
  if (sub_1000B866C())
  {
    *(void *)&__int128 v3 = "DiskImageSparseBundle::ContextSparseBundle::~ContextSparseBundle()";
    *((void *)&v3 + 1) = 64LL;
    int v4 = 2;
    sub_1000AA21C(v5, &v3);
    sub_100004E4C(&v6, (uint64_t)"Destructing sb context", 22LL);
    std::ostream::~ostream(&v6, off_10017C450);
    sub_1000AA380((uint64_t)v5);
    std::ios::~ios(&v7);
  }

  v5[0] = (void **)(a1 + 16);
  sub_1000170C0(v5);
  return a1;
}

void *sub_1000AA21C(void *a1, __int128 *a2)
{
  __int128 v3 = (std::ios_base *)(a1 + 46);
  sub_1000AA304((uint64_t)a1, a2);
  *a1 = off_10017C388;
  a1[45] = &off_10017C488;
  a1[46] = &off_10017C4B0;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_10017C388;
  a1[45] = off_10017C410;
  a1[46] = off_10017C438;
  return a1;
}

void sub_1000AA2A0(_Unwind_Exception *a1)
{
}

uint64_t sub_1000AA2C4(uint64_t a1)
{
  return a1;
}

uint64_t sub_1000AA304(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_10017C520;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000AA36C(_Unwind_Exception *a1)
{
}

uint64_t sub_1000AA380(uint64_t a1)
{
  *(void *)a1 = off_10017C520;
  sub_1000AA5F8(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

void sub_1000AA41C(char *a1)
{
}

uint64_t sub_1000AA460(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000AA494(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

uint64_t sub_1000AA4E0(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_10017C450);
  sub_1000AA380(v2);
  return std::ios::~ios(a1 + 8);
}

void sub_1000AA518(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_10017C450);
  sub_1000AA380((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

uint64_t sub_1000AA558(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017C450);
  sub_1000AA380(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000AA598(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017C450);
  sub_1000AA380((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

void sub_1000AA5E4(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000AA380(a1);
  operator delete(v1);
}

uint64_t sub_1000AA5F8(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000AA748((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000AA720( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

int *sub_1000AA748(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      char v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 41LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      unint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    BOOL v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        char v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 41LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000AA92C(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_100178728;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000AA994(_Unwind_Exception *a1)
{
}

uint64_t sub_1000AA9A8(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_100178948;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000AAA10(_Unwind_Exception *a1)
{
}

uint64_t sub_1000AAA24(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_100178B68;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000AAA8C(_Unwind_Exception *a1)
{
}

uint64_t sub_1000AAAA0(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_100178D88;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000AAB08(_Unwind_Exception *a1)
{
}

uint64_t sub_1000AAB1C(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_100178FA8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000AAB84(_Unwind_Exception *a1)
{
}

uint64_t sub_1000AAB98(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_1001791C8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000AAC00(_Unwind_Exception *a1)
{
}

uint64_t sub_1000AAC14(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_1001793E8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000AAC7C(_Unwind_Exception *a1)
{
}

uint64_t sub_1000AAC90(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_100179608;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000AACF8(_Unwind_Exception *a1)
{
}

uint64_t sub_1000AAD0C(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_100179828;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000AAD74(_Unwind_Exception *a1)
{
}

uint64_t sub_1000AAD88(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_100179A48;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000AADF0(_Unwind_Exception *a1)
{
}

void sub_1000AAE04(void **a1@<X0>, char *a2@<X1>, uint64_t a3@<X2>, _OWORD *a4@<X3>, void *a5@<X8>)
{
  char v10 = *a1;
  unint64_t v11 = sub_1000AAEA0((uint64_t)a1, a3);
  if (v11 >> 59) {
    sub_100014AD4("get_next_capacity, allocator's max size reached");
  }
  unint64_t v12 = (char *)v11;
  BOOL v13 = operator new(16 * v11);
  sub_1000AAF14(a1, v13, v12, a2, a3, a4);
  *a5 = (char *)*a1 + a2 - v10;
}

unint64_t sub_1000AAEA0(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = 0x7FFFFFFFFFFFFFFLL;
  uint64_t v3 = *(void *)(a1 + 8);
  unint64_t v4 = *(void *)(a1 + 16);
  if (0x7FFFFFFFFFFFFFFLL - v4 < a2 - v4 + v3) {
    sub_100014AD4("get_next_capacity, allocator's max size reached");
  }
  unint64_t v5 = v4 >> 61;
  unint64_t v6 = 8 * v4;
  if (v5 > 4) {
    uint64_t v7 = -1LL;
  }
  else {
    uint64_t v7 = v6;
  }
  unint64_t v8 = v6 / 5;
  if (v5) {
    unint64_t v8 = v7;
  }
  unint64_t v9 = v3 + a2;
  if (v8 < 0x7FFFFFFFFFFFFFFLL) {
    unint64_t v2 = v8;
  }
  if (v9 <= v2) {
    return v2;
  }
  else {
    return v9;
  }
}

void sub_1000AAF14(void **a1, _OWORD *__dst, char *a3, char *__src, uint64_t a5, _OWORD *a6)
{
  unint64_t v12 = (char *)*a1;
  BOOL v13 = (char *)a1[1];
  if (*a1) {
    BOOL v14 = __dst == 0LL;
  }
  else {
    BOOL v14 = 1;
  }
  BOOL v15 = v14 || v12 == __src;
  char v16 = __dst;
  if (!v15)
  {
    memmove(__dst, v12, __src - v12);
    char v16 = (_OWORD *)((char *)__dst + __src - v12);
  }

  _OWORD *v16 = *a6;
  if (__src)
  {
    uint64_t v17 = &v12[16 * (void)v13];
    if (v17 != __src && v16 != 0LL) {
      memmove(&v16[a5], __src, v17 - __src);
    }
  }

  if (v12 && a1 + 3 != *a1) {
    operator delete(*a1);
  }
  unint64_t v19 = (char *)a1[1] + a5;
  *a1 = __dst;
  a1[1] = v19;
  a1[2] = a3;
}

uint64_t sub_1000AAFE4(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_100179C68;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000AB04C(_Unwind_Exception *a1)
{
}

uint64_t sub_1000AB060(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_100179E88;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000AB0C8(_Unwind_Exception *a1)
{
}

uint64_t sub_1000AB0DC(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_10017A0A8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000AB144(_Unwind_Exception *a1)
{
}

uint64_t sub_1000AB158(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_10017A2C8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000AB1C0(_Unwind_Exception *a1)
{
}

uint64_t sub_1000AB1D4(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_10017A4E8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000AB23C(_Unwind_Exception *a1)
{
}

uint64_t sub_1000AB250(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_10017A708;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000AB2B8(_Unwind_Exception *a1)
{
}

uint64_t sub_1000AB2CC(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_10017A928;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000AB334(_Unwind_Exception *a1)
{
}

uint64_t sub_1000AB348(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_10017AB48;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000AB3B0(_Unwind_Exception *a1)
{
}

void sub_1000AB3C4(uint64_t ***a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 560);
  *(void *)(v3 + 136) = sub_100118D8C();
  *(void *)(v3 + 144) = v4;
  sub_100069A0C(*(void *)(v2 + 560));
}

void sub_1000AB40C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, __int128 a11, int a12, int a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60)
{
  uint64_t v64 = v60;
  if (a2 == 1)
  {
    unint64_t v61 = (unsigned int *)__cxa_begin_catch(exception_object);
    *(void *)&a11 = "DiskImageSparseBundle::void_stackable_identifier()::(anonymous class)::operator()() const";
    *((void *)&a11 + 1) = 81LL;
    a12 = 16;
    sub_1000AB4E8(&a14, &a11);
    sub_100118CE8(&a59, v61);
    std::ostream::~ostream(&a59, off_10017C670);
    sub_1000AB64C((uint64_t)&a14);
    std::ios::~ios(&a60);
    int v62 = v61[2];
    if (v62 < 0) {
      int v63 = v61[2];
    }
    else {
      int v63 = -v62;
    }
    **(_DWORD **)(v64 + _Block_object_dispose((const void *)(v2 - 120), 8) = v63;
    __cxa_end_catch();
    JUMPOUT(0x1000AB3F8LL);
  }

  _Unwind_Resume(exception_object);
}

void *sub_1000AB4E8(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000AB5D0((uint64_t)a1, a2);
  *a1 = off_10017C5A8;
  a1[45] = &off_10017C6A8;
  a1[46] = &off_10017C6D0;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_10017C5A8;
  a1[45] = off_10017C630;
  a1[46] = off_10017C658;
  return a1;
}

void sub_1000AB56C(_Unwind_Exception *a1)
{
}

uint64_t sub_1000AB590(uint64_t a1)
{
  return a1;
}

uint64_t sub_1000AB5D0(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_10017C740;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000AB638(_Unwind_Exception *a1)
{
}

uint64_t sub_1000AB64C(uint64_t a1)
{
  *(void *)a1 = off_10017C740;
  sub_1000AB8C4(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

void sub_1000AB6E8(char *a1)
{
}

uint64_t sub_1000AB72C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000AB760(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

uint64_t sub_1000AB7AC(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_10017C670);
  sub_1000AB64C(v2);
  return std::ios::~ios(a1 + 8);
}

void sub_1000AB7E4(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_10017C670);
  sub_1000AB64C((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

uint64_t sub_1000AB824(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017C670);
  sub_1000AB64C(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000AB864(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017C670);
  sub_1000AB64C((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

void sub_1000AB8B0(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000AB64C(a1);
  operator delete(v1);
}

uint64_t sub_1000AB8C4(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000ABA14((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000AB9EC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

int *sub_1000ABA14(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      char v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 307LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      unint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    BOOL v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        char v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 307LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000ABBF8(void *a1)
{
  uint64_t v1 = qword_100198710;
  uint64_t v2 = a1 + 1;
  uint64_t v3 = (void *)*a1;
  if ((void *)*a1 != a1 + 1)
  {
    do
    {
      uint64_t v4 = sub_1000ABC78(v3 + 4);
      int v5 = (void *)v3[1];
      if (v5)
      {
        do
        {
          char v6 = v5;
          int v5 = (void *)*v5;
        }

        while (v5);
      }

      else
      {
        do
        {
          char v6 = (void *)v3[2];
          BOOL v7 = *v6 == (void)v3;
          uint64_t v3 = v6;
        }

        while (!v7);
      }

      v1 += v4;
      uint64_t v3 = v6;
    }

    while (v6 != v2);
  }

  return v1;
}

uint64_t sub_1000ABC78(unint64_t *a1)
{
  unsigned int v1 = *((unsigned __int8 *)a1 + 16);
  if (*((_BYTE *)a1 + 16))
  {
    if (v1 == 3)
    {
      unint64_t v3 = *a1;
      unint64_t v2 = a1[1];
      if (v2 >= *a1) {
        return (v1 & 1) + (uint64_t)(int)(((v1 >> 1) & 1) - 1) + v2 - v3;
      }
    }

    else
    {
      unint64_t v3 = *a1;
      unint64_t v2 = a1[1];
      if (*a1 < v2) {
        return (v1 & 1) + (uint64_t)(int)(((v1 >> 1) & 1) - 1) + v2 - v3;
      }
    }
  }

  else
  {
    unint64_t v3 = *a1;
    unint64_t v2 = a1[1];
    if (*a1 < v2 && *a1 + 1 < v2) {
      return (v1 & 1) + (uint64_t)(int)(((v1 >> 1) & 1) - 1) + v2 - v3;
    }
  }

  return qword_100198710;
}

uint64_t sub_1000ABCE0(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_10017AF88;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000ABD48(_Unwind_Exception *a1)
{
}

uint64_t sub_1000ABD5C(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_10017B1A8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000ABDC4(_Unwind_Exception *a1)
{
}

uint64_t sub_1000ABDD8(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_10017B3C8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000ABE40(_Unwind_Exception *a1)
{
}

uint64_t sub_1000ABE54(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = 0LL;
  *(void *)a1 = a1 + 8;
  sub_1000ABEA8((_OWORD *)a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_1000ABE90(_Unwind_Exception *a1)
{
}

_OWORD *sub_1000ABEA8(_OWORD *result, void *a2, void *a3)
{
  if (a2 != a3)
  {
    char v4 = a2;
    __int128 v5 = (uint64_t **)result;
    char v6 = (uint64_t *)result + 1;
    do
    {
      uint64_t result = sub_1000ABF2C(v5, v6, (uint64_t)(v4 + 4), (uint64_t)(v4 + 4));
      BOOL v7 = (void *)v4[1];
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          BOOL v7 = (void *)*v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          uint64_t v8 = (void *)v4[2];
          BOOL v9 = *v8 == (void)v4;
          char v4 = v8;
        }

        while (!v9);
      }

      char v4 = v8;
    }

    while (v8 != a3);
  }

  return result;
}

_OWORD *sub_1000ABF2C(uint64_t **a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  char v6 = sub_100027088(a1, a2, &v11, &v10, a3);
  BOOL v7 = (_OWORD *)*v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    BOOL v7 = operator new(0x38uLL);
    v7[2] = *(_OWORD *)a4;
    *((void *)v7 + 6) = *(void *)(a4 + 16);
    sub_100027200(a1, (uint64_t)v11, v8, (uint64_t *)v7);
  }

  return v7;
}

uint64_t sub_1000ABFB8(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_10017B5E8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000AC020(_Unwind_Exception *a1)
{
}

uint64_t *sub_1000AC034(uint64_t **a1, uint64_t *a2, uint64_t *a3)
{
  if (a2 != a3)
  {
    char v4 = a2;
    do
    {
      char v6 = sub_10003F4FC(a1, v4);
      operator delete(v4);
      char v4 = v6;
    }

    while (v6 != a3);
  }

  return a3;
}

uint64_t **sub_1000AC090(uint64_t **a1, uint64_t a2)
{
  if (!*(_BYTE *)(a2 + 16))
  {
    unint64_t v11 = *(void *)(a2 + 8);
    if (*(void *)a2 < v11 && *(void *)a2 + 1LL < v11) {
      goto LABEL_4;
    }
    return a1 + 1;
  }

  if (*(_BYTE *)(a2 + 16) == 3)
  {
    if (*(void *)(a2 + 8) >= *(void *)a2) {
      goto LABEL_4;
    }
    return a1 + 1;
  }

  if (*(void *)a2 >= *(void *)(a2 + 8)) {
    return a1 + 1;
  }
LABEL_4:
  char v4 = (uint64_t *)sub_1000AC1C4(a1, a2, a2);
  if ((v5 & 1) != 0)
  {
    BOOL v13 = v4;
    sub_1000AC24C(a1, &v13);
    return sub_1000AC348(a1, (uint64_t ***)&v13);
  }

  else
  {
    char v6 = (void *)sub_1000AC540((uint64_t)a1, a2);
    BOOL v7 = (void *)*v6;
    if (*v6)
    {
      do
      {
        uint64_t v8 = v7;
        BOOL v7 = (void *)v7[1];
      }

      while (v7);
    }

    else
    {
      do
      {
        uint64_t v8 = (void *)v6[2];
        BOOL v9 = *v8 == (void)v6;
        char v6 = v8;
      }

      while (v9);
    }

    return sub_1000AC180(a1, (unint64_t *)a2, (uint64_t)v8);
  }

uint64_t **sub_1000AC180(uint64_t **a1, unint64_t *a2, uint64_t a3)
{
  char v5 = (uint64_t *)sub_1000AC588(a1, a2, a3);
  sub_1000AC24C(a1, &v5);
  return sub_1000AC348(a1, (uint64_t ***)&v5);
}

_OWORD *sub_1000AC1C4(uint64_t **a1, uint64_t a2, uint64_t a3)
{
  char v5 = (void **)sub_100027254((uint64_t)a1, &v9, a2);
  char v6 = *v5;
  if (!*v5)
  {
    BOOL v7 = (uint64_t **)v5;
    char v6 = operator new(0x38uLL);
    v6[2] = *(_OWORD *)a3;
    *((void *)v6 + 6) = *(void *)(a3 + 16);
    sub_100027200(a1, v9, v7, (uint64_t *)v6);
  }

  return v6;
}

uint64_t *sub_1000AC24C(uint64_t **a1, uint64_t **a2)
{
  unint64_t v2 = *a2;
  if (*a2 == *a1) {
    return *a1;
  }
  uint64_t v4 = *v2;
  if (*v2)
  {
    do
    {
      uint64_t v5 = v4;
      uint64_t v4 = *(void *)(v4 + 8);
    }

    while (v4);
  }

  else
  {
    uint64_t v6 = (uint64_t)*a2;
    do
    {
      uint64_t v5 = *(void *)(v6 + 16);
      BOOL v7 = *(void *)v5 == v6;
      uint64_t v6 = v5;
    }

    while (v7);
  }

  uint64_t v8 = v2[4];
  if ((v2[6] & 2) == 0) {
    ++v8;
  }
  if (v8 == (*(_BYTE *)(v5 + 48) & 1) + *(void *)(v5 + 40))
  {
    __int128 v14 = *((_OWORD *)v2 + 2);
    uint64_t v15 = v2[6];
    sub_10003F4FC(a1, v2);
    operator delete(v2);
    __int128 v10 = *(_OWORD *)(v5 + 32);
    uint64_t v11 = *(void *)(v5 + 48);
    sub_1000AC44C((unint64_t *)&v10, (unint64_t *)&v14, (uint64_t)&v12);
    *(_OWORD *)(v5 + 32) = v12;
    *(_BYTE *)(v5 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = v13;
    *a2 = (uint64_t *)v5;
    return (uint64_t *)v5;
  }

  return v2;
}

uint64_t **sub_1000AC348(uint64_t **a1, uint64_t ***a2)
{
  unint64_t v3 = a1 + 1;
  uint64_t result = *a2;
  if (*a2 == v3) {
    return v3;
  }
  uint64_t v6 = result[1];
  if (v6)
  {
    do
    {
      BOOL v7 = (uint64_t **)v6;
      uint64_t v6 = (uint64_t *)*v6;
    }

    while (v6);
  }

  else
  {
    uint64_t v8 = *a2;
    do
    {
      BOOL v7 = (uint64_t **)v8[2];
      BOOL v9 = *v7 == (uint64_t *)v8;
      uint64_t v8 = v7;
    }

    while (!v9);
  }

  if (v7 != v3)
  {
    __int128 v10 = v7[4];
    if (((_BYTE)v7[6] & 2) == 0) {
      __int128 v10 = (uint64_t *)((char *)v10 + 1);
    }
    if (v10 == (uint64_t *)((char *)result[5] + ((_BYTE)result[6] & 1)))
    {
      __int128 v17 = *((_OWORD *)v7 + 2);
      uint64_t v18 = v7[6];
      sub_10003F4FC(a1, (uint64_t *)v7);
      operator delete(v7);
      uint64_t v11 = *a2;
      __int128 v13 = *((_OWORD *)*a2 + 2);
      __int128 v14 = v11[6];
      sub_1000AC44C((unint64_t *)&v13, (unint64_t *)&v17, (uint64_t)&v15);
      __int128 v12 = *a2;
      *((_OWORD *)v12 + 2) = v15;
      *((_BYTE *)v12 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = v16;
      return *a2;
    }
  }

  return result;
}

unint64_t *sub_1000AC44C@<X0>( unint64_t *result@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  int v3 = *((unsigned __int8 *)a2 + 16);
  if (*((_BYTE *)a2 + 16))
  {
    if (v3 == 3)
    {
      uint64_t v5 = (uint64_t *)*a2;
      unint64_t v4 = a2[1];
      if (v4 >= *a2) {
        goto LABEL_4;
      }
LABEL_24:
      *(_OWORD *)a3 = *(_OWORD *)result;
      unint64_t v15 = result[2];
LABEL_33:
      *(void *)(a3 + 16) = v15;
      return result;
    }

    uint64_t v5 = (uint64_t *)*a2;
    unint64_t v4 = a2[1];
    if (*a2 >= v4) {
      goto LABEL_24;
    }
  }

  else
  {
    uint64_t v5 = (uint64_t *)*a2;
    unint64_t v4 = a2[1];
    if (*a2 >= v4 || *a2 + 1 >= v4) {
      goto LABEL_24;
    }
  }

LABEL_7:
  char v9 = v6 & 2;
  if ((v6 & 2) != 0) {
    unint64_t v10 = (unint64_t)v8;
  }
  else {
    unint64_t v10 = (unint64_t)v8 + 1;
  }
  char v11 = v3 & 2;
  if ((v3 & 2) != 0) {
    uint64_t result = (unint64_t *)v5;
  }
  else {
    uint64_t result = (unint64_t *)((char *)v5 + 1);
  }
  int v12 = v6 & 1;
  int v13 = v3 & 1;
  else {
    uint64_t v5 = v8;
  }
  if (v7 + v12 - 1 >= v4 + v13 - 1)
  {
    unint64_t v4 = v7;
    LOBYTE(v13) = v12;
  }

  *(void *)a3 = v5;
  *(void *)(a3 + _Block_object_dispose((const void *)(v2 - 120), 8) = v4;
  *(_BYTE *)(a3 + 16) = v13 | v9;
  return result;
}

    uint64_t result = 0LL;
    atomic_store(a2, (unint64_t *)(*(void *)(a1 + 40) + 64LL));
    return result;
  }

  if (v4 <= a2 || ftruncate(**(_DWORD **)(a1 + 56), a2) != -1) {
    goto LABEL_7;
  }
  *(void *)&unint64_t v10 = "int FileLocal::truncate(uint64_t)";
  *((void *)&v10 + 1) = 23LL;
  char v11 = 16;
  sub_1000FBD60(v12, &v10);
  sub_100004E4C(&v13, (uint64_t)"ftruncate failed, errno: ", 25LL);
  char v9 = __error();
  std::ostream::operator<<(&v13, *v9);
  std::ostream::~ostream(&v13, off_100185EB8);
  sub_1001008A8((uint64_t)v12);
  std::ios::~ios(v14);
  return -*__error();
}

uint64_t sub_1000AC540(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t result = a1 + 8;
  uint64_t v3 = v4;
  if (v4)
  {
    unint64_t v5 = (*(_BYTE *)(a2 + 16) & 1) + *(void *)(a2 + 8) - 1LL;
    do
    {
      unint64_t v6 = *(void *)(v3 + 32);
      if ((*(_BYTE *)(v3 + 48) & 2) == 0) {
        ++v6;
      }
      BOOL v7 = v5 >= v6;
      if (v5 >= v6) {
        uint64_t v8 = (uint64_t *)(v3 + 8);
      }
      else {
        uint64_t v8 = (uint64_t *)v3;
      }
      if (!v7) {
        uint64_t result = v3;
      }
      uint64_t v3 = *v8;
    }

    while (*v8);
  }

  return result;
}

uint64_t sub_1000AC588(uint64_t **a1, unint64_t *a2, uint64_t a3)
{
  uint64_t v6 = sub_1000AC868((uint64_t)a1, (uint64_t)a2);
  uint64_t v7 = v6;
  uint64_t v8 = *(uint64_t **)(v6 + 8);
  if (v8)
  {
    do
    {
      char v9 = v8;
      uint64_t v8 = (uint64_t *)*v8;
    }

    while (v8);
  }

  else
  {
    uint64_t v10 = v6;
    do
    {
      char v9 = *(uint64_t **)(v10 + 16);
      BOOL v11 = *v9 == v10;
      uint64_t v10 = (uint64_t)v9;
    }

    while (!v11);
  }

  int v12 = *(uint64_t **)(a3 + 8);
  if (v12)
  {
    do
    {
      int v13 = v12;
      int v12 = (uint64_t *)*v12;
    }

    while (v12);
  }

  else
  {
    __int128 v14 = (uint64_t *)a3;
    do
    {
      int v13 = (uint64_t *)v14[2];
      BOOL v11 = *v13 == (void)v14;
      __int128 v14 = v13;
    }

    while (!v11);
  }

  __int128 v24 = *(_OWORD *)(v6 + 32);
  uint64_t v25 = *(void *)(v6 + 48);
  sub_1000AC6C0((unint64_t *)&v24, (uint64_t)a2, (uint64_t)&v26);
  __int128 v21 = *(_OWORD *)(a3 + 32);
  uint64_t v22 = *(void *)(a3 + 48);
  sub_1000AC794((uint64_t)&v21, (uint64_t)a2, (uint64_t)v23);
  sub_1000AC034(a1, v9, v13);
  __int128 v16 = v26;
  uint64_t v17 = v27;
  sub_1000AC44C((unint64_t *)&v16, a2, (uint64_t)v18);
  sub_1000AC44C(v18, v23, (uint64_t)&v19);
  *(_OWORD *)(v7 + 32) = v19;
  *(_BYTE *)(v7 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = v20;
  return v7;
}

unint64_t *sub_1000AC6C0@<X0>(unint64_t *result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v3 = *((unsigned __int8 *)result + 16);
  if (*((_BYTE *)result + 16))
  {
    if (v3 == 3)
    {
      unint64_t v4 = *result;
      unint64_t v5 = result[1];
      if (v5 < *result) {
        goto LABEL_27;
      }
    }

    else
    {
      unint64_t v4 = *result;
      unint64_t v5 = result[1];
      if (*result >= v5) {
        goto LABEL_27;
      }
    }
  }

  else
  {
    unint64_t v4 = *result;
    unint64_t v5 = result[1];
    if (*result >= v5 || *result + 1 >= v5) {
      goto LABEL_27;
    }
  }

  int v7 = *(unsigned __int8 *)(a2 + 16);
  if (!*(_BYTE *)(a2 + 16))
  {
    unint64_t v8 = *(void *)a2;
    unint64_t v9 = *(void *)(a2 + 8);
    if (*(void *)a2 >= v9 || *(void *)a2 + 1LL >= v9) {
      goto LABEL_27;
    }
    goto LABEL_23;
  }

  if (v7 != 3)
  {
    unint64_t v8 = *(void *)a2;
    if (*(void *)a2 < *(void *)(a2 + 8)) {
      goto LABEL_23;
    }
LABEL_27:
    *(_OWORD *)a3 = *(_OWORD *)result;
    *(void *)(a3 + 16) = result[2];
    return result;
  }

  unint64_t v8 = *(void *)a2;
  if (*(void *)(a2 + 8) < *(void *)a2) {
    goto LABEL_27;
  }
LABEL_23:
  unint64_t v11 = (v3 & 1) + v5 - 1;
  if ((v7 & 2) != 0) {
    unint64_t v12 = v8;
  }
  else {
    unint64_t v12 = v8 + 1;
  }
  if (v11 < v12) {
    goto LABEL_27;
  }
  *(void *)a3 = v4;
  *(void *)(a3 + _Block_object_dispose((const void *)(v2 - 120), 8) = v8;
  *(_BYTE *)(a3 + 16) = v3 & 2 | ((~v7 & 2) != 0);
  return result;
}

uint64_t sub_1000AC794@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v3 = *(unsigned __int8 *)(a2 + 16);
  if (*(_BYTE *)(a2 + 16))
  {
    if (v3 == 3)
    {
      unint64_t v4 = *(void *)(a2 + 8);
      if (v4 < *(void *)a2) {
        goto LABEL_26;
      }
    }

    else
    {
      unint64_t v4 = *(void *)(a2 + 8);
      if (*(void *)a2 >= v4) {
        goto LABEL_26;
      }
    }
  }

  else
  {
    unint64_t v4 = *(void *)(a2 + 8);
    if (*(void *)a2 >= v4 || *(void *)a2 + 1LL >= v4) {
      goto LABEL_26;
    }
  }

  int v6 = *(unsigned __int8 *)(result + 16);
  if (!*(_BYTE *)(result + 16))
  {
    unint64_t v8 = *(void *)result;
    unint64_t v7 = *(void *)(result + 8);
    if (*(void *)result >= v7 || *(void *)result + 1LL >= v7) {
      goto LABEL_26;
    }
    goto LABEL_23;
  }

  if (v6 != 3)
  {
    unint64_t v8 = *(void *)result;
    unint64_t v7 = *(void *)(result + 8);
    if (*(void *)result < v7) {
      goto LABEL_23;
    }
LABEL_26:
    *(_OWORD *)a3 = *(_OWORD *)result;
    *(void *)(a3 + 16) = *(void *)(result + 16);
    return result;
  }

  unint64_t v8 = *(void *)result;
  unint64_t v7 = *(void *)(result + 8);
  if (v7 < *(void *)result) {
    goto LABEL_26;
  }
LABEL_23:
  if ((v6 & 2) == 0) {
    ++v8;
  }
  if ((v3 & 1) + v4 - 1 < v8) {
    goto LABEL_26;
  }
  *(void *)a3 = v4;
  *(void *)(a3 + _Block_object_dispose((const void *)(v2 - 120), 8) = v7;
  *(_BYTE *)(a3 + 16) = v6 & 1 | (2 * ((v3 & 1) == 0));
  return result;
}

uint64_t sub_1000AC868(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t result = a1 + 8;
  uint64_t v3 = v4;
  if (v4)
  {
    unint64_t v5 = *(void *)a2;
    if ((*(_BYTE *)(a2 + 16) & 2) == 0) {
      ++v5;
    }
    do
    {
      unint64_t v6 = (*(_BYTE *)(v3 + 48) & 1) + *(void *)(v3 + 40) - 1LL;
      BOOL v7 = v6 >= v5;
      if (v6 >= v5) {
        unint64_t v8 = (uint64_t *)v3;
      }
      else {
        unint64_t v8 = (uint64_t *)(v3 + 8);
      }
      if (v7) {
        uint64_t result = v3;
      }
      uint64_t v3 = *v8;
    }

    while (*v8);
  }

  return result;
}

uint64_t sub_1000AC8B0(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_10017B808;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000AC918(_Unwind_Exception *a1)
{
}

uint64_t sub_1000AC92C(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_10017BA28;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000AC994(_Unwind_Exception *a1)
{
}

uint64_t sub_1000AC9A8(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_10017BC48;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000ACA10(_Unwind_Exception *a1)
{
}

uint64_t sub_1000ACA24(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_10017BE68;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000ACA8C(_Unwind_Exception *a1)
{
}

uint64_t sub_1000ACAA0(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_10017C088;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000ACB08(_Unwind_Exception *a1)
{
}

void sub_1000ACB84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000ACBFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000ACC5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000ACE1C(_Unwind_Exception *a1, int a2)
{
  unint64_t v6 = v5;

  if (a2 == 1)
  {
    unint64_t v9 = +[DIError errorWithDIException:description:prefix:error:]( &OBJC_CLASS___DIError,  "errorWithDIException:description:prefix:error:",  __cxa_begin_catch(a1),  0LL,  0LL,  0LL);
    uint64_t v10 = objc_claimAutoreleasedReturnValue(v9);
    unint64_t v11 = (void *)v3[6];
    v3[6] = v10;

    __cxa_end_catch();
    JUMPOUT(0x1000ACDFCLL);
  }

  _Unwind_Resume(a1);
}

void sub_1000ACEA8()
{
}

void sub_1000ACEB0()
{
}

void sub_1000ACFDC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1000AD174(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000AD3B0(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    id v7 = [objc_begin_catch(a1) reason];
    unint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
    +[DIError failWithEnumValue:verboseInfo:error:]( &OBJC_CLASS___DIError,  "failWithEnumValue:verboseInfo:error:",  150LL,  v8,  v2);

    objc_end_catch();
    JUMPOUT(0x1000AD378LL);
  }

  _Unwind_Resume(a1);
}

void sub_1000AD988(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000ADBF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000ADF58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000AE074(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000AE288( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, uint64_t a11, uint64_t a12, uint8_t buf, int a14, __int16 a15, uint64_t a16, __int16 a17, uint64_t a18, __int16 a19, uint64_t a20, __int16 a21, int a22)
{
  if (a2 == 1)
  {
    +[DIError failWithDIException:prefix:error:]( &OBJC_CLASS___DIError,  "failWithDIException:prefix:error:",  __cxa_begin_catch(a1),  @"Failed opening the shadow/cache file(s)",  v23);
    __cxa_end_catch();
    JUMPOUT(0x1000AE244LL);
  }

  _Unwind_Resume(a1);
}

void sub_1000AE640(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000AE6F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000AE73C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000AE788( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_1000AE964( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void sub_1000AEA94( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1000AEB00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000AEBB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000AEC44( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_1000AED4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000AEDFC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1000AEEA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000AEF78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000AF00C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000AF108(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000AF284(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000AF4A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000AF564(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000AF604(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000AF614(uint64_t a1, void *a2, _BYTE *a3)
{
  id v5 = a2;
  unint64_t v6 = v5;
  uint64_t v7 = 514LL;
  if (*(_BYTE *)(a1 + 40))
  {
    if (*(_BYTE *)(a1 + 41)) {
      uint64_t v7 = 514LL;
    }
    else {
      uint64_t v7 = 2562LL;
    }
  }

  if ([v5 isCache])
  {
    [v6 createBackendWithFlags:v7];
    int v8 = *__error();
    if (sub_1000B8654())
    {
      uint64_t v40 = 0LL;
      uint64_t v9 = sub_1000B85DC();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v11 = 3LL;
      }
      else {
        uint64_t v11 = 2LL;
      }
      unint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v6 URL]);
      int v13 = (void *)objc_claimAutoreleasedReturnValue([v12 path]);
      *(_DWORD *)buf = 68158211;
      int v42 = 61;
      __int16 v43 = 2080;
      char v44 = "-[DIShadowChain openWritable:createNonExisting:]_block_invoke";
      __int16 v45 = 2113;
      uint64_t v46 = v13;
      __int128 v14 = (char *)_os_log_send_and_compose_impl( v11,  &v40,  0LL,  0LL,  &_mh_execute_header,  v10,  0LL,  "%.*s: Cache file %{private}@ opened with RW access",  buf,  28);

      if (v14)
      {
        fprintf(__stderrp, "%s\n", v14);
        free(v14);
      }
    }

    else
    {
      uint64_t v17 = sub_1000B85DC();
      uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v17);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        __int128 v19 = (void *)objc_claimAutoreleasedReturnValue([v6 URL]);
        char v20 = (void *)objc_claimAutoreleasedReturnValue([v19 path]);
        *(_DWORD *)buf = 68158211;
        int v42 = 61;
        __int16 v43 = 2080;
        char v44 = "-[DIShadowChain openWritable:createNonExisting:]_block_invoke";
        __int16 v45 = 2113;
        uint64_t v46 = v20;
        _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "%.*s: Cache file %{private}@ opened with RW access",  buf,  0x1Cu);
      }
    }

    goto LABEL_42;
  }

  if (*(_BYTE *)(a1 + 40))
  {
    unint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) nodes]);
    else {
      uint64_t v16 = 0LL;
    }
  }

  else
  {
    uint64_t v16 = 0LL;
  }

  [v6 createBackendWithFlags:v16];
  if ((v16 & 3) != 0)
  {
    int v8 = *__error();
    if (sub_1000B8654())
    {
      uint64_t v40 = 0LL;
      uint64_t v21 = sub_1000B85DC();
      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue(v21);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v23 = 3LL;
      }
      else {
        uint64_t v23 = 2LL;
      }
      __int128 v24 = (void *)objc_claimAutoreleasedReturnValue([v6 URL]);
      uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue([v24 path]);
      *(_DWORD *)buf = 68158211;
      int v42 = 61;
      __int16 v43 = 2080;
      char v44 = "-[DIShadowChain openWritable:createNonExisting:]_block_invoke";
      __int16 v45 = 2113;
      uint64_t v46 = v25;
      __int128 v26 = (char *)_os_log_send_and_compose_impl( v23,  &v40,  0LL,  0LL,  &_mh_execute_header,  v22,  0LL,  "%.*s: Shadow file %{private}@ opened with RW access",  buf,  28);

      if (!v26) {
        goto LABEL_42;
      }
      goto LABEL_34;
    }

    uint64_t v32 = sub_1000B85DC();
    char v33 = (os_log_s *)objc_claimAutoreleasedReturnValue(v32);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v34 = (void *)objc_claimAutoreleasedReturnValue([v6 URL]);
      BOOL v35 = (void *)objc_claimAutoreleasedReturnValue([v34 path]);
      *(_DWORD *)buf = 68158211;
      int v42 = 61;
      __int16 v43 = 2080;
      char v44 = "-[DIShadowChain openWritable:createNonExisting:]_block_invoke";
      __int16 v45 = 2113;
      uint64_t v46 = v35;
      _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEFAULT,  "%.*s: Shadow file %{private}@ opened with RW access",  buf,  0x1Cu);
    }
  }

  else
  {
    int v8 = *__error();
    if (sub_1000B8654())
    {
      uint64_t v40 = 0LL;
      uint64_t v27 = sub_1000B85DC();
      BOOL v28 = (os_log_s *)objc_claimAutoreleasedReturnValue(v27);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v29 = 3LL;
      }
      else {
        uint64_t v29 = 2LL;
      }
      unint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v6 URL]);
      unint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v30 path]);
      *(_DWORD *)buf = 68158211;
      int v42 = 61;
      __int16 v43 = 2080;
      char v44 = "-[DIShadowChain openWritable:createNonExisting:]_block_invoke";
      __int16 v45 = 2113;
      uint64_t v46 = v31;
      __int128 v26 = (char *)_os_log_send_and_compose_impl( v29,  &v40,  0LL,  0LL,  &_mh_execute_header,  v28,  0LL,  "%.*s: Using an existing shadow file: %{private}@",  buf,  28);

      if (!v26) {
        goto LABEL_42;
      }
LABEL_34:
      fprintf(__stderrp, "%s\n", v26);
      free(v26);
      goto LABEL_42;
    }

    uint64_t v36 = sub_1000B85DC();
    BOOL v37 = (os_log_s *)objc_claimAutoreleasedReturnValue(v36);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue([v6 URL]);
      uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue([v38 path]);
      *(_DWORD *)buf = 68158211;
      int v42 = 61;
      __int16 v43 = 2080;
      char v44 = "-[DIShadowChain openWritable:createNonExisting:]_block_invoke";
      __int16 v45 = 2113;
      uint64_t v46 = v39;
      _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "%.*s: Using an existing shadow file: %{private}@",  buf,  0x1Cu);
    }
  }

void sub_1000AFBD4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, uint64_t a11, uint64_t a12, uint8_t buf, int a14, __int16 a15, uint64_t a16, __int16 a17, uint64_t a18)
{
  _Unwind_Resume(a1);
}

void sub_1000B0324(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000B04C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000B0530(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000B05D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000B0660(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000B06E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_1000B0704(id a1, DIShadowNode *a2, NSDictionary *a3)
{
  return !-[DIShadowNode isCache](a2, "isCache", a3);
}

void sub_1000B0AF4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20, char a21)
{
  if (a21) {
    diskimage_uio::diskimage_open_params::~diskimage_open_params((diskimage_uio::diskimage_open_params *)&a19);
  }
  sub_1000114F0((uint64_t)&a13);

  _Unwind_Resume(a1);
}

void sub_1000B0CC4(_Unwind_Exception *a1)
{
  char v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1000B0D8C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1000B0E08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000B166C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000B1688(void *a1@<X0>, void *a2@<X8>)
{
  uint64_t v8 = 0LL;
  id v3 = a1;
  id v4 = [v3 decodeBytesForKey:@"crypto_header" returnedLength:&v8];
  if (v4)
  {
    if (v8 != 76)
    {
      exception = __cxa_allocate_exception(0x40uLL);
      sub_100004D60((uint64_t)v7);
      sub_100004E4C(v7, (uint64_t)"Unexpected crypto header length (", 33LL);
      std::ostream::operator<<(v7, v8);
      sub_100004E4C(v7, (uint64_t)")", 1LL);
      sub_10001161C((uint64_t)exception, (uint64_t)v7, 0x9Au);
    }

    id v5 = operator new(0x4CuLL);
    sub_10010D558((uint64_t)v5, (uint64_t)v4);
  }

  else
  {
    id v5 = 0LL;
  }

  *a2 = v5;
}

void sub_1000B1788( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1000B1824( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_1000B1974(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

void sub_1000B1A64( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

void sub_1000B1B40( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1000B1C7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000B1EFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000B2244(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v19 = va_arg(va2, void);
  uint64_t v21 = va_arg(va2, void);
  sub_100056854((uint64_t)va);

  sub_1000114F0((uint64_t)va1);
  sub_1000114F0((uint64_t)va2);

  _Unwind_Resume(a1);
}

void sub_1000B23A8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Unwind_Resume(a1);
}

void sub_1000B26A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000B285C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  sub_1000114F0((uint64_t)va1);
  sub_1000114F0((uint64_t)va);

  _Unwind_Resume(a1);
}

void sub_1000B29F8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(a1);
}

void sub_1000B2B68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  _Unwind_Resume(a1);
}

void sub_1000B2E40( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  _Unwind_Resume(a1);
}

void sub_1000B2EA8()
{
}

void sub_1000B2EB0(void *a1@<X0>, uint64_t *a2@<X1>, void *a3@<X8>)
{
  id v5 = a1;
  id v6 = [v5 decodeBytesForKey:@"encKeys" returnedLength:&v23];
  id v7 = v5;
  id v8 = [v7 decodeBytesForKey:@"prngKeys" returnedLength:&v22];
  if (v6 && (uint64_t v9 = v8) != 0LL)
  {
    char v20 = 0LL;
    uint64_t v21 = 0LL;
    uint64_t v19 = 0LL;
    sub_1000B6EB8(&v19, v6, (uint64_t)v6 + v23, v23);
    uint64_t v18 = 0LL;
    __n128 v17 = 0uLL;
    sub_1000B6EB8(&v17, v9, (uint64_t)v9 + v22, v22);
    sub_10010F3B8(v11, (uint64_t)&v19, &v17, a2);
    sub_1000589DC(a3);
    if (__p)
    {
      uint64_t v16 = __p;
      operator delete(__p);
    }

    uint64_t v10 = v14;
    uint64_t v14 = 0LL;
    if (v10) {
      operator delete(v10);
    }
    if (v12)
    {
      uint64_t v13 = v12;
      operator delete(v12);
    }

    if (v11[0])
    {
      v11[1] = v11[0];
      operator delete(v11[0]);
    }

    if (v17.n128_u64[0])
    {
      v17.n128_u64[1] = v17.n128_u64[0];
      operator delete((void *)v17.n128_u64[0]);
    }

    if (v19)
    {
      char v20 = v19;
      operator delete(v19);
    }
  }

  else
  {
    *a3 = 0LL;
    a3[1] = 0LL;
  }
}

void sub_1000B2FF8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p, uint64_t a21)
{
  if (__p)
  {
    a21 = (uint64_t)__p;
    operator delete(__p);
  }

  __int128 v24 = *(void **)(v22 - 96);
  if (v24)
  {
    *(void *)(v22 - 8_Block_object_dispose((const void *)(v2 - 120), 8) = v24;
    operator delete(v24);
  }

  _Unwind_Resume(a1);
}

void sub_1000B324C(_Unwind_Exception *a1)
{
  sub_1000114F0(v4 - 48);
  _Unwind_Resume(a1);
}

void sub_1000B32A4(void *a1, void *a2)
{
  id v3 = a1;
  [v3 encodeBytes:a2[6] length:76 forKey:@"crypto_header"];
  [v3 encodeBytes:*a2 length:a2[1] - *a2 forKey:@"encKeys"];
  [v3 encodeBytes:a2[3] length:a2[4] - a2[3] forKey:@"prngKeys"];
}

void sub_1000B3318( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_1000B344C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  sub_1000114F0((uint64_t)va1);
  sub_1000114F0((uint64_t)va);

  _Unwind_Resume(a1);
}

void sub_1000B3594(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  sub_1000114F0((uint64_t)va1);
  sub_1000114F0((uint64_t)va);

  _Unwind_Resume(a1);
}

void sub_1000B3640(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_1000B379C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  _Unwind_Resume(a1);
}

void sub_1000B3930( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  _Unwind_Resume(a1);
}

void sub_1000B3A4C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(a1);
}

#error "1000B3D54: call analysis failed (funcsize=120)"
RamXPC *__cdecl -[RamXPC initWithCoder:](RamXPC *self, SEL a2, id a3)
{
  id v4;
  RamXPC *v5;
  uint64_t v6;
  id v7;
  void *v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  __int128 v16;
  __int128 v17;
  id v18;
  objc_super v19;
  uint64_t v20[2];
  uint64_t v4 = a3;
  v19.receiver = self;
  v19.super_class = (Class)&OBJC_CLASS___RamXPC;
  id v5 = -[BackendXPC initWithCoder:](&v19, "initWithCoder:", v4);
  if (v5)
  {
    uint64_t v18 = [v4 decodeInt64ForKey:@"size"];
    id v7 = objc_msgSend(v4, "decodeObjectOfClass:forKey:", objc_opt_class(NSUUID, v6), @"identifier");
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
    [v8 getUUIDBytes:v20];
    sub_1000B79D4((uint64_t *)&v18, v20, &v16);
    __n128 v17 = v16;
    uint64_t v16 = 0uLL;
    -[BackendXPC setBackend:](v5, "setBackend:", &v17, 0LL);
    uint64_t v9 = (std::__shared_weak_count *)*((void *)&v17 + 1);
    if (*((void *)&v17 + 1))
    {
      uint64_t v10 = (unint64_t *)(*((void *)&v17 + 1) + 8LL);
      do
        uint64_t v11 = __ldaxr(v10);
      while (__stlxr(v11 - 1, v10));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }

    uint64_t v12 = (std::__shared_weak_count *)*((void *)&v16 + 1);
    if (*((void *)&v16 + 1))
    {
      uint64_t v13 = (unint64_t *)(*((void *)&v16 + 1) + 8LL);
      do
        uint64_t v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
  }

  return v5;
}

void sub_1000B3FF0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(a1);
}

void sub_1000B4124(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000B4224(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000B43C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000B4638( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  _Unwind_Resume(a1);
}

void sub_1000B47BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  sub_1000114F0((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1000B4900( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  _Unwind_Resume(a1);
}

void sub_1000B4ACC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000B4CA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000B4D64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000B4F34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000B51BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000B52A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000B5514(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  sub_1000114F0((uint64_t)va2);
  sub_1000114F0((uint64_t)va1);
  sub_1000114F0((uint64_t)va);

  _Unwind_Resume(a1);
}

void sub_1000B57EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  sub_1000114F0((uint64_t)va1);
  sub_1000114F0((uint64_t)va);
  sub_1000114F0((uint64_t)va2);

  _Unwind_Resume(a1);
}

void sub_1000B58F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000B5BB0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  _Unwind_Resume(a1);
}

void sub_1000B5E74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v9 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v14 = va_arg(va2, void);
  uint64_t v15 = va_arg(va2, void);
  uint64_t v16 = va_arg(va2, void);
  uint64_t v17 = va_arg(va2, void);
  uint64_t v18 = va_arg(va2, void);
  sub_1000114F0((uint64_t)va1);
  sub_1000114F0((uint64_t)va);
  sub_1000114F0((uint64_t)va2);

  _Unwind_Resume(a1);
}

uint64_t sub_1000B5EE4(void *a1, uint64_t a2, void *a3)
{
  if (a1 && a2 && a3)
  {
    id v5 = a1;
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a2));
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:v6]);
    if (v8)
    {
      uint64_t v9 = objc_opt_class(&OBJC_CLASS___NSData, v7);
      if ((objc_opt_isKindOfClass(v8, v9) & 1) != 0 && [v8 length])
      {
        uint64_t v10 = malloc((size_t)[v8 length]);
        *a3 = v10;
        if (v10)
        {
          uint64_t v11 = v10;
          id v12 = v8;
          memcpy(v11, [v12 bytes], (size_t)objc_msgSend(v12, "length"));
          uint64_t v13 = (uint64_t)[v12 length];
        }

        else
        {
          int v29 = *__error();
          if (sub_1000B8654())
          {
            uint64_t v39 = 0LL;
            uint64_t v30 = sub_1000B85DC();
            unint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue(v30);
            BOOL v32 = os_log_type_enabled(v31, OS_LOG_TYPE_ERROR);
            id v33 = [v8 length];
            *(_DWORD *)buf = 68158466;
            if (v32) {
              uint64_t v34 = 3LL;
            }
            else {
              uint64_t v34 = 2LL;
            }
            int v41 = 59;
            __int16 v42 = 2080;
            __int16 v43 = "ssize_t plugin_decode_buffer(void *, const char *, void **)";
            __int16 v44 = 2048;
            id v45 = v33;
            __int16 v46 = 2112;
            uint64_t v47 = v6;
            BOOL v35 = (char *)_os_log_send_and_compose_impl( v34,  &v39,  0LL,  0LL,  &_mh_execute_header,  v31,  16LL,  "%.*s: Out of memory, failed to allocated %zu bytes for key %@",  buf,  38);

            if (v35)
            {
              fprintf(__stderrp, "%s\n", v35);
              free(v35);
            }
          }

          else
          {
            uint64_t v36 = sub_1000B85DC();
            BOOL v37 = (os_log_s *)objc_claimAutoreleasedReturnValue(v36);
            if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 68158466;
              int v41 = 59;
              __int16 v42 = 2080;
              __int16 v43 = "ssize_t plugin_decode_buffer(void *, const char *, void **)";
              __int16 v44 = 2048;
              id v45 = [v8 length];
              __int16 v46 = 2112;
              uint64_t v47 = v6;
              _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_ERROR,  "%.*s: Out of memory, failed to allocated %zu bytes for key %@",  buf,  0x26u);
            }
          }

          *__error() = v29;
          uint64_t v13 = -12LL;
        }
      }

      else
      {
        int v21 = *__error();
        if (sub_1000B8654())
        {
          uint64_t v39 = 0LL;
          uint64_t v22 = sub_1000B85DC();
          size_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
            uint64_t v24 = 3LL;
          }
          else {
            uint64_t v24 = 2LL;
          }
          *(_DWORD *)buf = 68158210;
          int v41 = 59;
          __int16 v42 = 2080;
          __int16 v43 = "ssize_t plugin_decode_buffer(void *, const char *, void **)";
          __int16 v44 = 2112;
          id v45 = v6;
          uint64_t v25 = (char *)_os_log_send_and_compose_impl( v24,  &v39,  0LL,  0LL,  &_mh_execute_header,  v23,  16LL,  "%.*s: Invalid key: %@",  buf,  28);

          if (v25)
          {
            fprintf(__stderrp, "%s\n", v25);
            free(v25);
          }
        }

        else
        {
          uint64_t v26 = sub_1000B85DC();
          uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue(v26);
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 68158210;
            int v41 = 59;
            __int16 v42 = 2080;
            __int16 v43 = "ssize_t plugin_decode_buffer(void *, const char *, void **)";
            __int16 v44 = 2112;
            id v45 = v6;
            _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "%.*s: Invalid key: %@", buf, 0x1Cu);
          }
        }

        *__error() = v21;
        uint64_t v13 = -22LL;
      }
    }

    else
    {
      uint64_t v13 = -2LL;
    }
  }

  else
  {
    int v14 = *__error();
    if (sub_1000B8654())
    {
      uint64_t v39 = 0LL;
      uint64_t v15 = sub_1000B85DC();
      uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
        uint64_t v17 = 3LL;
      }
      else {
        uint64_t v17 = 2LL;
      }
      *(_DWORD *)buf = 68157954;
      int v41 = 59;
      __int16 v42 = 2080;
      __int16 v43 = "ssize_t plugin_decode_buffer(void *, const char *, void **)";
      LODWORD(v3_Block_object_dispose((const void *)(v2 - 120), 8) = 18;
      uint64_t v18 = (char *)_os_log_send_and_compose_impl( v17,  &v39,  0LL,  0LL,  &_mh_execute_header,  v16,  16LL,  "%.*s: Missing parameters",  (int)buf,  v38);

      if (v18)
      {
        fprintf(__stderrp, "%s\n", v18);
        free(v18);
      }
    }

    else
    {
      uint64_t v19 = sub_1000B85DC();
      char v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 68157954;
        int v41 = 59;
        __int16 v42 = 2080;
        __int16 v43 = "ssize_t plugin_decode_buffer(void *, const char *, void **)";
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "%.*s: Missing parameters", buf, 0x12u);
      }
    }

    *__error() = v14;
    return -22LL;
  }

  return v13;
}

void sub_1000B643C(_Unwind_Exception *a1)
{
  id v5 = v4;

  _Unwind_Resume(a1);
}

uint64_t sub_1000B6498(void *a1, uint64_t a2)
{
  if (a1 && a2)
  {
    id v3 = a1;
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a2));
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v4]);
    if (v6)
    {
      uint64_t v7 = objc_opt_class(&OBJC_CLASS___NSFileHandle, v5);
      if ((objc_opt_isKindOfClass(v6, v7) & 1) != 0)
      {
        uint64_t v8 = dup((int)[v6 fileDescriptor]);
        if ((v8 & 0x80000000) != 0) {
          uint64_t v8 = -*__error();
        }
      }

      else
      {
        int v16 = *__error();
        if (sub_1000B8654())
        {
          uint64_t v25 = 0LL;
          uint64_t v17 = sub_1000B85DC();
          uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v17);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
            uint64_t v19 = 3LL;
          }
          else {
            uint64_t v19 = 2LL;
          }
          *(_DWORD *)buf = 68158210;
          int v27 = 42;
          __int16 v28 = 2080;
          int v29 = "int plugin_decode_fd(void *, const char *)";
          __int16 v30 = 2112;
          unint64_t v31 = v4;
          char v20 = (char *)_os_log_send_and_compose_impl( v19,  &v25,  0LL,  0LL,  &_mh_execute_header,  v18,  16LL,  "%.*s: Invalid key: %@",  buf,  28);

          if (v20)
          {
            fprintf(__stderrp, "%s\n", v20);
            free(v20);
          }
        }

        else
        {
          uint64_t v21 = sub_1000B85DC();
          uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue(v21);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 68158210;
            int v27 = 42;
            __int16 v28 = 2080;
            int v29 = "int plugin_decode_fd(void *, const char *)";
            __int16 v30 = 2112;
            unint64_t v31 = v4;
            _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "%.*s: Invalid key: %@", buf, 0x1Cu);
          }
        }

        *__error() = v16;
        uint64_t v8 = 4294967274LL;
      }
    }

    else
    {
      uint64_t v8 = 4294967294LL;
    }
  }

  else
  {
    int v9 = *__error();
    if (sub_1000B8654())
    {
      uint64_t v25 = 0LL;
      uint64_t v10 = sub_1000B85DC();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        uint64_t v12 = 3LL;
      }
      else {
        uint64_t v12 = 2LL;
      }
      *(_DWORD *)buf = 68157954;
      int v27 = 42;
      __int16 v28 = 2080;
      int v29 = "int plugin_decode_fd(void *, const char *)";
      LODWORD(v24) = 18;
      uint64_t v13 = (char *)_os_log_send_and_compose_impl( v12,  &v25,  0LL,  0LL,  &_mh_execute_header,  v11,  16LL,  "%.*s: Missing parameters",  (int)buf,  v24);

      if (v13)
      {
        fprintf(__stderrp, "%s\n", v13);
        free(v13);
      }
    }

    else
    {
      uint64_t v14 = sub_1000B85DC();
      uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 68157954;
        int v27 = 42;
        __int16 v28 = 2080;
        int v29 = "int plugin_decode_fd(void *, const char *)";
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%.*s: Missing parameters", buf, 0x12u);
      }
    }

    *__error() = v9;
    return 4294967274LL;
  }

  return v8;
}

void sub_1000B6824(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000B6948(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000B696C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 && a2 && a3 && a4)
  {
    id v17 = a1;
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a2));
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", a3, a4));
    [v17 setObject:v8 forKeyedSubscript:v7];
  }

  else
  {
    int v9 = *__error();
    if (sub_1000B8654())
    {
      uint64_t v18 = 0LL;
      uint64_t v10 = sub_1000B85DC();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        uint64_t v12 = 3LL;
      }
      else {
        uint64_t v12 = 2LL;
      }
      *(_DWORD *)buf = 68157954;
      int v20 = 69;
      __int16 v21 = 2080;
      uint64_t v22 = "void plugin_encode_buffer(void *, const char *, const void *, size_t)";
      LODWORD(v16) = 18;
      uint64_t v13 = (char *)_os_log_send_and_compose_impl( v12,  &v18,  0LL,  0LL,  &_mh_execute_header,  v11,  16LL,  "%.*s: Missing parameters",  (int)buf,  v16);

      if (v13)
      {
        fprintf(__stderrp, "%s\n", v13);
        free(v13);
      }
    }

    else
    {
      uint64_t v14 = sub_1000B85DC();
      uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 68157954;
        int v20 = 69;
        __int16 v21 = 2080;
        uint64_t v22 = "void plugin_encode_buffer(void *, const char *, const void *, size_t)";
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%.*s: Missing parameters", buf, 0x12u);
      }
    }

    *__error() = v9;
  }

void sub_1000B6B98( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id a11)
{
  _Unwind_Resume(a1);
}

void sub_1000B6BCC(void *a1, uint64_t a2, uint64_t a3)
{
  if (a1 && a2 && (a3 & 0x80000000) == 0)
  {
    id v15 = a1;
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a2));
    uint64_t v6 = -[NSFileHandle initWithFileDescriptor:](objc_alloc(&OBJC_CLASS___NSFileHandle), "initWithFileDescriptor:", a3);
    [v15 setObject:v6 forKeyedSubscript:v5];
  }

  else
  {
    int v7 = *__error();
    if (sub_1000B8654())
    {
      uint64_t v16 = 0LL;
      uint64_t v8 = sub_1000B85DC();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        uint64_t v10 = 3LL;
      }
      else {
        uint64_t v10 = 2LL;
      }
      *(_DWORD *)buf = 68157954;
      int v18 = 48;
      __int16 v19 = 2080;
      int v20 = "void plugin_encode_fd(void *, const char *, int)";
      LODWORD(v14) = 18;
      uint64_t v11 = (char *)_os_log_send_and_compose_impl( v10,  &v16,  0LL,  0LL,  &_mh_execute_header,  v9,  16LL,  "%.*s: Missing parameters",  (int)buf,  v14);

      if (v11)
      {
        fprintf(__stderrp, "%s\n", v11);
        free(v11);
      }
    }

    else
    {
      uint64_t v12 = sub_1000B85DC();
      uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 68157954;
        int v18 = 48;
        __int16 v19 = 2080;
        int v20 = "void plugin_encode_fd(void *, const char *, int)";
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%.*s: Missing parameters", buf, 0x12u);
      }
    }

    *__error() = v7;
  }

void sub_1000B6DEC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id a11)
{
  uint64_t v13 = v12;

  _Unwind_Resume(a1);
}

void *sub_1000B6EB8(void *result, const void *a2, uint64_t a3, size_t __sz)
{
  if (__sz)
  {
    uint64_t v6 = result;
    uint64_t result = sub_10005692C(result, __sz);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }

  return result;
}

void sub_1000B6F14(_Unwind_Exception *exception_object)
{
  id v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose((const void *)(v2 - 120), 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void *sub_1000B6F30@<X0>(void *a1@<X8>)
{
  uint64_t v2 = operator new(0x60uLL);
  uint64_t result = sub_1000B6FA8(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_1000B6F94(_Unwind_Exception *a1)
{
}

void *sub_1000B6FA8(void *a1)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10016ECA0;
  sub_10010FCDC((_DWORD)a1 + 24);
  return a1;
}

void sub_1000B6FE4(_Unwind_Exception *a1)
{
}

void sub_1000B6FF8(char **a1@<X1>, unsigned int *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x470uLL);
  sub_1000B7060(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  sub_100018774((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_1000B704C(_Unwind_Exception *a1)
{
}

void *sub_1000B7060(void *a1, char **a2, unsigned int *a3)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10016D710;
  sub_1000B70A8((uint64_t)(a1 + 3), a2, a3);
  return a1;
}

void sub_1000B7094(_Unwind_Exception *a1)
{
}

uint64_t sub_1000B70A8(uint64_t a1, char **a2, unsigned int *a3)
{
  uint64_t v5 = *a3;
  uint64_t v6 = sub_1000FA260((uint64_t)__p, v5);
  sub_100045554(a1, v6, (v5 & 3) != 0, 0);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  return a1;
}

void sub_1000B7118( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000B7134(unsigned int *a1@<X1>, unsigned __int8 *a2@<X2>, char *a3@<X3>, void *a4@<X8>)
{
  size_t v8 = operator new(0x470uLL);
  sub_1000B71AC(v8, a1, a2, a3);
  *a4 = v8 + 3;
  a4[1] = v8;
  sub_100018774((uint64_t)a4, v8 + 4, (uint64_t)(v8 + 3));
}

void sub_1000B7198(_Unwind_Exception *a1)
{
}

void *sub_1000B71AC(void *a1, unsigned int *a2, unsigned __int8 *a3, char *a4)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10016D710;
  sub_100045554((uint64_t)(a1 + 3), *a2, *a3, *a4);
  return a1;
}

void sub_1000B71EC(_Unwind_Exception *a1)
{
}

void sub_1000B7200(unsigned int *a1@<X1>, unsigned __int8 *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0xB0uLL);
  sub_1000B7280(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  sub_100018774((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_1000B726C(_Unwind_Exception *a1)
{
}

void *sub_1000B7280(void *a1, unsigned int *a2, unsigned __int8 *a3)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10017C850;
  sub_100069920(a1 + 3, *a2, *a3);
  return a1;
}

void sub_1000B72BC(_Unwind_Exception *a1)
{
}

void sub_1000B72D0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10017C850;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000B72E0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10017C850;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_1000B7300(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void sub_1000B7310(char **a1@<X1>, _DWORD *a2@<X2>, unint64_t *a3@<X3>, void *a4@<X8>)
{
  size_t v8 = operator new(0xB0uLL);
  sub_1000B7388(v8, a1, a2, a3);
  *a4 = v8 + 3;
  a4[1] = v8;
  sub_100018774((uint64_t)a4, v8 + 4, (uint64_t)(v8 + 3));
}

void sub_1000B7374(_Unwind_Exception *a1)
{
}

void *sub_1000B7388(void *a1, char **a2, _DWORD *a3, unint64_t *a4)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10017C850;
  sub_1000B73D0((uint64_t)(a1 + 3), a2, a3, a4);
  return a1;
}

void sub_1000B73BC(_Unwind_Exception *a1)
{
}

uint64_t sub_1000B73D0(uint64_t a1, char **a2, _DWORD *a3, unint64_t *a4)
{
  LODWORD(a3) = *a3;
  unint64_t v7 = *a4;
  *(void *)&__int128 v12 = sub_100118D8C();
  *((void *)&v12 + 1) = v8;
  sub_100069644(a1, (uint64_t)__p, (__int16)a3, v7, &v12);
  if (v11 < 0) {
    operator delete(__p[0]);
  }
  return a1;
}

void sub_1000B7478( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

void sub_1000B749C(char **a1@<X1>, _DWORD *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0xB0uLL);
  sub_1000B7504(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  sub_100018774((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_1000B74F0(_Unwind_Exception *a1)
{
}

void *sub_1000B7504(void *a1, char **a2, _DWORD *a3)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10017C850;
  sub_1000B754C((uint64_t)(a1 + 3), a2, a3);
  return a1;
}

void sub_1000B7538(_Unwind_Exception *a1)
{
}

uint64_t sub_1000B754C(uint64_t a1, char **a2, _DWORD *a3)
{
  LODWORD(a3) = *a3;
  *(void *)&__int128 v9 = sub_100118D8C();
  *((void *)&v9 + 1) = v5;
  sub_100069644(a1, (uint64_t)__p, (__int16)a3, 0LL, &v9);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  return a1;
}

void sub_1000B75E4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

void sub_1000B7608(uint64_t *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x48uLL);
  sub_1000B7668(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  sub_100018774((uint64_t)a2, v4 + 4, (uint64_t)(v4 + 3));
}

void sub_1000B7654(_Unwind_Exception *a1)
{
}

void *sub_1000B7668(void *a1, uint64_t *a2)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10016BF00;
  uint64_t v3 = *a2;
  uint64_t v4 = sub_100118D8C();
  uint64_t v6 = v5;
  sub_100116E6C(a1 + 3);
  a1[3] = &off_10016BF50;
  a1[6] = v3;
  a1[7] = v4;
  a1[8] = v6;
  return a1;
}

void sub_1000B76CC(_Unwind_Exception *a1)
{
}

void sub_1000B76E0(size_t *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x80uLL);
  sub_1000B7748(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  sub_100018774((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_1000B7734(_Unwind_Exception *a1)
{
}

void *sub_1000B7748(void *a1, size_t *a2, uint64_t *a3)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10017C8A0;
  sub_1000B77DC(a1 + 3, *a2, *a3, a3[1]);
  return a1;
}

void sub_1000B7788(_Unwind_Exception *a1)
{
}

void sub_1000B779C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10017C8A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000B77AC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10017C8A0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_1000B77CC(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void *sub_1000B77DC(void *a1, size_t a2, uint64_t a3, uint64_t a4)
{
  char v8 = sub_100116E6C(a1);
  *char v8 = off_100187DE0;
  v8[3] = 0LL;
  __int128 v9 = v8 + 3;
  v8[7] = 0LL;
  v8[9] = a2;
  v8[10] = a3;
  v8[11] = a4;
  uint64_t v10 = valloc(a2);
  if (!v10)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    id v15 = std::bad_alloc::bad_alloc(exception);
  }

  v18[0] = &off_10017C8F0;
  __int16 v19 = v18;
  uint64_t v16 = v10;
  sub_1000172D0((uint64_t)&v17, (uint64_t)v18);
  char v11 = v19;
  if (v19 == v18)
  {
    uint64_t v12 = 4LL;
    char v11 = v18;
    goto LABEL_6;
  }

  if (v19)
  {
    uint64_t v12 = 5LL;
LABEL_6:
    (*(void (**)(void *))(*v11 + 8 * v12))(v11);
  }

  sub_100010FDC(v9, (uint64_t *)&v16);
  sub_100016DE0((uint64_t *)&v16);
  a1[8] = a1[3];
  a1[12] = getpagesize();
  return a1;
}

void sub_1000B7920(_Unwind_Exception *a1)
{
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 16);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  _Unwind_Resume(a1);
}

void *sub_1000B7948()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &off_10017C8F0;
  return result;
}

void sub_1000B796C(uint64_t a1, void *a2)
{
  *a2 = &off_10017C8F0;
}

void sub_1000B7984(uint64_t a1, void **a2)
{
}

uint64_t sub_1000B798C(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_1000B79C8()
{
  return &off_10017C950;
}

void sub_1000B79D4(uint64_t *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x48uLL);
  sub_1000B7A3C(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  sub_100018774((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_1000B7A28(_Unwind_Exception *a1)
{
}

void *sub_1000B7A3C(void *a1, uint64_t *a2, uint64_t *a3)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10016BF00;
  uint64_t v4 = *a2;
  uint64_t v5 = *a3;
  uint64_t v6 = a3[1];
  sub_100116E6C(a1 + 3);
  a1[3] = &off_10016BF50;
  a1[6] = v4;
  a1[7] = v5;
  a1[8] = v6;
  return a1;
}

void sub_1000B7A94(_Unwind_Exception *a1)
{
}

void sub_1000B7AA8(uint64_t a1@<X1>, uint64_t a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0xE0uLL);
  sub_1000B7B10(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  sub_100018774((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_1000B7AFC(_Unwind_Exception *a1)
{
}

void *sub_1000B7B10(void *a1, uint64_t a2, uint64_t a3)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10016ECF0;
  int v5 = 0;
  sub_100110E10(a1 + 3, a2, a3, &v5);
  return a1;
}

void sub_1000B7B54(_Unwind_Exception *a1)
{
}

void sub_1000B7B68(uint64_t a1@<X1>, uint64_t a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0xE0uLL);
  sub_1000B7BD0(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  sub_100018774((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_1000B7BBC(_Unwind_Exception *a1)
{
}

void *sub_1000B7BD0(void *a1, uint64_t a2, uint64_t a3)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10016ECF0;
  int v5 = 0;
  sub_100110E10(a1 + 3, a2, a3, &v5);
  return a1;
}

void sub_1000B7C14(_Unwind_Exception *a1)
{
}

void sub_1000B7C28(void *a1@<X8>)
{
  uint64_t v2 = operator new(0x68uLL);
  sub_1000B7C88(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  sub_100018774((uint64_t)a1, v2 + 4, (uint64_t)(v2 + 3));
}

void sub_1000B7C74(_Unwind_Exception *a1)
{
}

void *sub_1000B7C88(void *a1)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10017C970;
  sub_1000E6DEC(a1 + 3);
  return a1;
}

void sub_1000B7CBC(_Unwind_Exception *a1)
{
}

void sub_1000B7CD0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10017C970;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000B7CE0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10017C970;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_1000B7D00(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void sub_1000B7D10(void *a1@<X8>)
{
  uint64_t v2 = operator new(0x68uLL);
  sub_1000B7D70(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  sub_100018774((uint64_t)a1, v2 + 4, (uint64_t)(v2 + 3));
}

void sub_1000B7D5C(_Unwind_Exception *a1)
{
}

void *sub_1000B7D70(void *a1)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10017C970;
  sub_1000E6DEC(a1 + 3);
  return a1;
}

void sub_1000B7DA4(_Unwind_Exception *a1)
{
}

void sub_1000B7DB8(void *a1@<X8>)
{
  uint64_t v2 = operator new(0x70uLL);
  sub_1000B7E20(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  sub_100018774((uint64_t)a1, v2 + 4, (uint64_t)(v2 + 3));
}

void sub_1000B7E0C(_Unwind_Exception *a1)
{
}

void *sub_1000B7E20(void *a1)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10017C9C0;
  sub_1000F84BC(a1 + 3);
  return a1;
}

void sub_1000B7E54(_Unwind_Exception *a1)
{
}

void sub_1000B7E68(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10017C9C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000B7E78(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10017C9C0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_1000B7E98(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void *sub_1000B7EA8@<X0>(char **a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x30uLL);
  uint64_t result = sub_1000B7F00(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1000B7EEC(_Unwind_Exception *a1)
{
}

void *sub_1000B7F00(void *a1, char **a2)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10017CA10;
  sub_100004CB0(a1 + 3, *a2);
  return a1;
}

void sub_1000B7F3C(_Unwind_Exception *a1)
{
}

void sub_1000B7F50(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10017CA10;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000B7F64(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10017CA10;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_1000B7F88(uint64_t a1)
{
}

void sub_1000B7FA0(uint64_t a1@<X1>, int *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x50uLL);
  sub_1000B8018(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  sub_100018774((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_1000B8004(_Unwind_Exception *a1)
{
}

void *sub_1000B8018(void *a1, uint64_t a2, int *a3)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10017CA60;
  sub_1001065E4(a1 + 3, a2, *a3);
  return a1;
}

void sub_1000B8050(_Unwind_Exception *a1)
{
}

void sub_1000B8064(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10017CA60;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000B8074(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10017CA60;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_1000B8094(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void *sub_1000B80A4@<X0>(char **a1@<X1>, uint64_t *a2@<X2>, unsigned int *a3@<X3>, void *a4@<X8>)
{
  char v8 = operator new(0x40uLL);
  uint64_t result = sub_1000B8114(v8, a1, a2, a3);
  *a4 = v8 + 3;
  a4[1] = v8;
  return result;
}

void sub_1000B8100(_Unwind_Exception *a1)
{
}

void *sub_1000B8114(void *a1, char **a2, uint64_t *a3, unsigned int *a4)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10017CAB0;
  sub_1000B8198((uint64_t)(a1 + 3), a2, a3, a4);
  return a1;
}

void sub_1000B8148(_Unwind_Exception *a1)
{
}

void sub_1000B815C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10017CAB0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000B816C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10017CAB0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_1000B818C(uint64_t a1)
{
  return sub_1000B8230(a1 + 24);
}

uint64_t sub_1000B8198(uint64_t a1, char **a2, uint64_t *a3, unsigned int *a4)
{
  uint64_t v7 = *a3;
  uint64_t v8 = *a4;
  memset(v10, 0, sizeof(v10));
  sub_10006120C(a1, __p, v7, v8 | (unint64_t)&_mh_execute_header, v10, 0LL);
  if (v12 < 0) {
    operator delete(__p[0]);
  }
  return a1;
}

void sub_1000B8214( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000B8230(uint64_t a1)
{
  return sub_1000114F0(a1);
}

void sub_1000B8260(void *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x40uLL);
  sub_1000B82C0(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  sub_100018774((uint64_t)a2, v4 + 4, (uint64_t)(v4 + 3));
}

void sub_1000B82AC(_Unwind_Exception *a1)
{
}

void *sub_1000B82C0(void *a1, void *a2)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10017CB00;
  sub_100116E6C(a1 + 3);
  a1[3] = off_10017CB50;
  uint64_t v4 = a2[1];
  a1[6] = *a2;
  a1[7] = v4;
  if (v4)
  {
    int v5 = (unint64_t *)(v4 + 8);
    do
      unint64_t v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }

  return a1;
}

void sub_1000B8324(_Unwind_Exception *a1)
{
}

void sub_1000B8338(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10017CB00;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000B8348(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10017CB00;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_1000B8368(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void *sub_1000B8378(void *a1)
{
  *a1 = off_10017CB50;
  sub_1000114F0((uint64_t)(a1 + 3));
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1000B83B4(void *a1)
{
  *a1 = off_10017CB50;
  sub_1000114F0((uint64_t)(a1 + 3));
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  operator delete(a1);
}

uint64_t sub_1000B83F0()
{
  return 4294967251LL;
}

uint64_t sub_1000B83F8(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 16LL))();
  return (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 8LL))() * v2;
}

void *sub_1000B843C(uint64_t a1)
{
  return (*(void *(**)(void *__return_ptr))(**(void **)(a1 + 24) + 24LL))(*(void **)(a1 + 24));
}

uint64_t sub_1000B844C()
{
  return 4294967251LL;
}

void *sub_1000B8454(uint64_t a1, void *a2)
{
  return sub_100004E4C(a2, (uint64_t)"BackendPlugin", 13LL);
}

uint64_t sub_1000B8468()
{
  return 4294967251LL;
}

uint64_t sub_1000B8470()
{
  return 4294967251LL;
}

uint64_t sub_1000B8478(uint64_t a1)
{
  return sub_10005E27C(*(void *)(a1 + 24));
}

void *sub_1000B8480@<X0>( char **a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, void *a5@<X5>, void *a6@<X8>)
{
  char v12 = operator new(0x40uLL);
  uint64_t result = sub_1000B8508(v12, a1, a2, a3, a4, a5);
  *a6 = v12 + 3;
  a6[1] = v12;
  return result;
}

void sub_1000B84F4(_Unwind_Exception *a1)
{
}

void *sub_1000B8508(void *a1, char **a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10017CAB0;
  sub_1000B8550((uint64_t)(a1 + 3), a2, a3, a4, a5, a6);
  return a1;
}

void sub_1000B853C(_Unwind_Exception *a1)
{
}

uint64_t sub_1000B8550(uint64_t a1, char **a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  if (v11 < 0) {
    operator delete(__p[0]);
  }
  return a1;
}

void sub_1000B85C0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000B85DC()
{
  if (qword_100198FC8 != -1) {
    dispatch_once(&qword_100198FC8, &stru_10017CC38);
  }
  return qword_100198FC0;
}

void sub_1000B861C(id a1)
{
  qword_100198FC0 = (uint64_t)os_log_create("com.apple.DiskImages2", "Default");
}

uint64_t sub_1000B8648(uint64_t result)
{
  byte_100198FD0 = result;
  return result;
}

uint64_t sub_1000B8654()
{
  return byte_100198FD0;
}

uint64_t sub_1000B8660(uint64_t result)
{
  byte_100198FD1 = result;
  return result;
}

uint64_t sub_1000B866C()
{
  return byte_100198FD1;
}

const void **sub_1000B8678@<X0>(uint64_t a1@<X1>, char a2@<W2>, const __CFArray **a3@<X8>)
{
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable( kCFAllocatorDefault,  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 4),  &kCFTypeArrayCallBacks);
  CFArrayRef theArray = Mutable;
  uint64_t v7 = *(int **)(a1 + 16);
  uint64_t v8 = *(int **)(a1 + 24);
  if (v7 != v8)
  {
    do
    {
      (*(void (**)(char **__return_ptr, void, void))(**((void **)v7 + 3) + 48LL))( &v22,  *((void *)v7 + 3),  0LL);
      CFIndex Count = CFArrayGetCount(theArray);
      uint64_t v10 = @"Base";
      __int16 v21 = v10;
      char v11 = theArray;
      if ((a2 & 4) != 0)
      {
        uint64_t v24 = @"Role";
        uint64_t v25 = v10;
        CFRetain(v10);
        (*(void (**)(uint64_t *__return_ptr))(*(void *)&v22[*(void *)(*(void *)v22 - 96LL)] + 16LL))(&v17);
        uint64_t v26 = @"Image";
        uint64_t v27 = v17;
        uint64_t v17 = 0LL;
        int v18 = &v24;
        uint64_t v19 = 2LL;
        sub_1000F6F08((uint64_t *)&v18, (CFMutableDictionaryRef *)&value);
        CFArrayAppendValue(v11, value);
        sub_100026DC0((const void **)&value);
        for (uint64_t i = 24LL; i != -8; i -= 16LL)
          sub_100026D90((const void **)((char *)&v24 + i));
        sub_1000114C0((const void **)&v17);
      }

      else
      {
        uint64_t v24 = @"Role";
        uint64_t v25 = v10;
        CFRetain(v10);
        uint64_t v12 = (*(uint64_t (**)(char *))(*(void *)&v22[*(void *)(*(void *)v22 - 96LL)] + 24LL))(&v22[*(void *)(*(void *)v22 - 96LL)]);
        uint64_t v26 = @"Image Format";
        uint64_t v27 = v12;
        int v18 = &v24;
        uint64_t v19 = 2LL;
        sub_1000F6F08((uint64_t *)&v18, (CFMutableDictionaryRef *)&value);
        CFArrayAppendValue(v11, value);
        sub_100026DC0((const void **)&value);
        for (uint64_t j = 24LL; j != -8; j -= 16LL)
          sub_100026D90((const void **)((char *)&v24 + j));
      }

      sub_100026A94((const void **)&v21);
      id v15 = v22;
      uint64_t v22 = 0LL;
      if (v15) {
        (*(void (**)(char *))(*(void *)v15 + 8LL))(v15);
      }
      v7 += 12;
    }

    while (v7 != v8);
    CFMutableDictionaryRef Mutable = theArray;
  }

  *a3 = Mutable;
  CFArrayRef theArray = 0LL;
  return sub_100026EB4((const void **)&theArray);
}

void sub_1000B88EC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, const void *a11, uint64_t a12, uint64_t a13, const void *a14, const void *a15, uint64_t a16, const void *a17, char a18)
{
  for (uint64_t i = 24LL; i != -8; i -= 16LL)
    sub_100026D90((const void **)(&a18 + i));
  sub_1000114C0(&a11);
  sub_100026A94(&a15);
  uint64_t v20 = a16;
  a16 = 0LL;
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 8LL))(v20);
  }
  sub_100026EB4(&a17);
  _Unwind_Resume(a1);
}

CFTypeRef *sub_1000B89B8(CFTypeRef *a1, CFTypeRef *a2)
{
  if (*a2) {
    CFRetain(*a2);
  }
  if (*a1) {
    CFRelease(*a1);
  }
  *a1 = *a2;
  return a1;
}

uint64_t *sub_1000B89FC(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  *a1 = (uint64_t)off_10017D190;
  a1[7] = (uint64_t)off_10017D2F8;
  a1[8] = (uint64_t)off_10017D340;
  a1[9] = (uint64_t)&off_10017D5C8;
  a1[3] = (uint64_t)off_10017D620;
  a1[4] = (uint64_t)off_10017D220;
  *((_BYTE *)a1 + 96) = 0;
  *((_BYTE *)a1 + 104) = 0;
  *((_BYTE *)a1 + 112) = 0;
  *((_BYTE *)a1 + 120) = 0;
  a1[17] = (uint64_t)off_10017D710;
  a1[5] = (uint64_t)off_10017D768;
  a1[6] = (uint64_t)off_10017D2B0;
  *((_BYTE *)a1 + 144) = 0;
  *((_BYTE *)a1 + 152) = 0;
  a1[20] = 0LL;
  sub_1000B8D8C(a1 + 21, (uint64_t *)&off_10017D110, a2);
  *a1 = (uint64_t)off_10017CCD8;
  a1[3] = (uint64_t)off_10017CD20;
  a1[4] = (uint64_t)off_10017CD68;
  a1[5] = (uint64_t)off_10017CDB0;
  a1[6] = (uint64_t)off_10017CDF8;
  a1[7] = (uint64_t)off_10017CE40;
  a1[8] = (uint64_t)off_10017CE88;
  a1[9] = (uint64_t)off_10017CEE8;
  a1[17] = (uint64_t)off_10017CF58;
  a1[1] = 0LL;
  unint64_t v6 = (CFTypeRef *)(a1 + 1);
  a1[2] = 0LL;
  uint64_t v7 = (CFTypeRef *)(a1 + 2);
  a1[21] = (uint64_t)off_10017CFC8;
  uint64_t v8 = *(void *)(a2 + 16);
  uint64_t v9 = *(void *)(v8 + 24);
  uint64_t v10 = *(std::__shared_weak_count **)(v8 + 32);
  v26[1] = v9;
  v26[2] = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }

  (*(void (**)(void *__return_ptr, uint64_t, uint64_t))(*(void *)v9 + 48LL))(v26, v9, a3);
  uint64_t v13 = (*(uint64_t (**)(void))(*(void *)(v26[0] + *(void *)(*(void *)v26[0] - 24LL)) + 16LL))(v26[0] + *(void *)(*(void *)v26[0] - 24LL));
  uint64_t v14 = *a1;
  *(uint64_t *)((char *)a1 + *(void *)(*a1 - 112) + 16) = *(void *)(v13 + 16);
  *(uint64_t *)((char *)a1 + *(void *)(v14 - 112) + _Block_object_dispose((const void *)(v2 - 120), 8) = *(void *)(v13 + 8);
  *(uint64_t *)((char *)a1 + *(void *)(v14 - 112) + 56) = *(void *)(v13 + 56);
  uint64_t v15 = (uint64_t)a1 + *(void *)(v14 - 112);
  uint64_t v16 = *(void *)(v13 + 40);
  *(_BYTE *)(v15 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = *(_BYTE *)(v13 + 48);
  *(void *)(v15 + 40) = v16;
  uint64_t v17 = (uint64_t)a1 + *(void *)(*a1 - 112);
  uint64_t v18 = *(void *)(v13 + 24);
  *(_BYTE *)(v17 + sub_1000114F0(v6 - 32) = *(_BYTE *)(v13 + 32);
  *(void *)(v17 + 24) = v18;
  uint64_t v19 = (*(uint64_t (**)(void))(*(void *)(v26[0] + *(void *)(*(void *)v26[0] - 64LL)) + 16LL))(v26[0] + *(void *)(*(void *)v26[0] - 64LL));
  sub_1000B89B8((CFTypeRef *)((char *)a1 + *(void *)(*a1 - 128) + 16), (CFTypeRef *)(v19 + 16));
  sub_1000B89B8((CFTypeRef *)((char *)a1 + *(void *)(*a1 - 128) + 24), (CFTypeRef *)(v19 + 24));
  sub_1000B8678(a2, a3, (const __CFArray **)&v25);
  if (*v6) {
    CFRelease(*v6);
  }
  CFTypeRef *v6 = v25;
  uint64_t v25 = 0LL;
  sub_1000982B0(&v25);
  uint64_t v25 = v20;
  if (*v7)
  {
    CFRelease(*v7);
    uint64_t v20 = v25;
  }

  *uint64_t v7 = v20;
  uint64_t v25 = 0LL;
  sub_100026A94(&v25);
  uint64_t v21 = v26[0];
  v26[0] = 0LL;
  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 8LL))(v21);
  }
  if (v10)
  {
    uint64_t v22 = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  return a1;
}

void sub_1000B8CF0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, char a11)
{
  uint64_t v18 = a10;
  a10 = 0LL;
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
  }
  sub_1000114F0((uint64_t)&a11);
  sub_100026A94(v14);
  sub_1000982B0(v15);
  sub_100025288(v13, (uint64_t *)&off_10017D110);
  *(void *)(v11 + 136) = v16;
  *(void *)(v11 + 40) = v16 + 88;
  sub_100026A94(v12);
  _Unwind_Resume(a1);
}

uint64_t *sub_1000B8D8C(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  *a1 = (uint64_t)off_100168D68;
  uint64_t v4 = a2[1];
  *a1 = v4;
  *(uint64_t *)((char *)a1 + *(void *)(v4 - 24)) = a2[2];
  uint64_t v5 = *a2;
  *a1 = *a2;
  *(uint64_t *)((char *)a1 + *(void *)(v5 - 24)) = a2[3];
  a1[1] = 0LL;
  a1[2] = 0LL;
  unint64_t v6 = (CFTypeRef *)(a1 + 1);
  a1[3] = 0LL;
  uint64_t v7 = sub_100059028(*(uint64_t (****)(void))(*(void *)(a3 + 16) + 24LL));
  uint64_t v9 = v8;
  *(void *)&v14.byte0 = v7;
  *(void *)&v14.byte8 = v9;
  uint64_t v13 = CFUUIDCreateFromUUIDBytes(kCFAllocatorDefault, v14);
  CFStringRef v10 = CFUUIDCreateString(kCFAllocatorDefault, v13);
  unint64_t v12 = v10;
  if (*v6)
  {
    CFRelease(*v6);
    CFStringRef v10 = v12;
  }

  a1[1] = (uint64_t)v10;
  unint64_t v12 = 0LL;
  sub_100026A94((const void **)&v12);
  sub_100026EE4((const void **)&v13);
  return a1;
}

void sub_1000B8E6C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

uint64_t sub_1000B8EB8(uint64_t a1)
{
  *(void *)a1 = off_10017CCD8;
  *(void *)(a1 + 24) = off_10017CD20;
  *(void *)(a1 + sub_1000114F0(v6 - 32) = off_10017CD68;
  *(void *)(a1 + 40) = off_10017CDB0;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = off_10017CDF8;
  *(void *)(a1 + 56) = off_10017CE40;
  *(void *)(a1 + 64) = off_10017CE88;
  *(void *)(a1 + 72) = off_10017CEE8;
  *(void *)(a1 + 136) = off_10017CF58;
  *(void *)(a1 + 16_Block_object_dispose((const void *)(v2 - 120), 8) = off_10017CFC8;
  sub_100026A94((const void **)(a1 + 16));
  sub_1000982B0((const void **)(a1 + 8));
  *(void *)(a1 + 16_Block_object_dispose((const void *)(v2 - 120), 8) = off_10017D858;
  *(void *)(a1 + 64) = off_10017D8B0;
  sub_100026A94((const void **)(a1 + 192));
  sub_100026A94((const void **)(a1 + 184));
  sub_100026A94((const void **)(a1 + 176));
  *(void *)(a1 + 136) = off_10017D710;
  *(void *)(a1 + 40) = off_10017D768;
  sub_100026A94((const void **)(a1 + 160));
  return a1;
}

void sub_1000B8F78(void *a1)
{
  *(void *)a1 = off_10017CCD8;
  *((void *)a1 + 3) = off_10017CD20;
  *((void *)a1 + 4) = off_10017CD68;
  *((void *)a1 + 5) = off_10017CDB0;
  *((void *)a1 + 6) = off_10017CDF8;
  *((void *)a1 + 7) = off_10017CE40;
  *((void *)a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = off_10017CE88;
  *((void *)a1 + 9) = off_10017CEE8;
  *((void *)a1 + 17) = off_10017CF58;
  *((void *)a1 + 21) = off_10017CFC8;
  sub_100026A94((const void **)a1 + 2);
  sub_1000982B0((const void **)a1 + 1);
  *((void *)a1 + 21) = off_10017D858;
  *((void *)a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = off_10017D8B0;
  sub_100026A94((const void **)a1 + 24);
  sub_100026A94((const void **)a1 + 23);
  sub_100026A94((const void **)a1 + 22);
  *((void *)a1 + 17) = off_10017D710;
  *((void *)a1 + 5) = off_10017D768;
  sub_100026A94((const void **)a1 + 20);
  operator delete(a1);
}

const void **sub_1000B9038@<X0>(CFArrayRef *a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = (*((uint64_t (**)(CFArrayRef *))*a1 + 3))(a1);
  v13[0] = @"Image Format";
  v13[1] = v4;
  v13[2] = @"Format Description";
  v13[3] = @"Stackable image";
  sub_1000258AC((uint64_t)a1 + *((void *)*a1 - 14), &valuePtr);
  v13[4] = @"Size Info";
  v13[5] = valuePtr;
  CFIndex valuePtr = 0LL;
  sub_1000114C0((const void **)&valuePtr);
  sub_100025BB0((uint64_t)a1 + *((void *)*a1 - 15), &valuePtr);
  v13[6] = @"Encryption Info";
  v13[7] = valuePtr;
  CFIndex valuePtr = 0LL;
  sub_1000114C0((const void **)&valuePtr);
  sub_10002631C((CFArrayRef *)((char *)a1 + *((void *)*a1 - 16)), &valuePtr);
  _BYTE v13[8] = @"Identity Info";
  v13[9] = valuePtr;
  CFIndex valuePtr = 0LL;
  sub_1000114C0((const void **)&valuePtr);
  CFIndex valuePtr = CFArrayGetCount(a1[1]);
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongType, &valuePtr);
  void v13[10] = @"Images Count";
  v13[11] = v5;
  uint64_t v9 = 0LL;
  CFArrayRef v6 = a1[1];
  v13[12] = @"Stack Info";
  v13[13] = v6;
  if (v6) {
    CFRetain(v6);
  }
  v10[0] = (uint64_t)v13;
  v10[1] = 7LL;
  sub_1000F6F08(v10, (CFMutableDictionaryRef *)&v11);
  *a2 = v11;
  uint64_t v11 = 0LL;
  sub_100026DC0(&v11);
  for (uint64_t i = 13LL; i != -1; i -= 2LL)
    sub_100026D90((const void **)&v13[i]);
  return sub_1000B95A8(&v9);
}

void sub_1000B9208( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  do
  {
    sub_100026D90(v14 - 1);
    v14 -= 2;
  }

  while (v14 != (const void **)&a14);
  _Unwind_Resume(a1);
}

CFStringRef sub_1000B9270()
{
  return @"STCK";
}

const void **sub_1000B927C(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  *(void *)uint64_t v1 = off_10017CCD8;
  *((void *)v1 + 3) = off_10017CD20;
  *((void *)v1 + 4) = off_10017CD68;
  *((void *)v1 + 5) = off_10017CDB0;
  *((void *)v1 + 6) = off_10017CDF8;
  *((void *)v1 + 7) = off_10017CE40;
  *((void *)v1 + _Block_object_dispose((const void *)(v2 - 120), 8) = off_10017CE88;
  *((void *)v1 + 9) = off_10017CEE8;
  *((void *)v1 + 17) = off_10017CF58;
  *((void *)v1 + 21) = off_10017CFC8;
  sub_100026A94((const void **)v1 + 2);
  sub_1000982B0((const void **)v1 + 1);
  *((void *)v1 + 21) = off_10017D858;
  *((void *)v1 + _Block_object_dispose((const void *)(v2 - 120), 8) = off_10017D8B0;
  sub_100026A94((const void **)v1 + 24);
  sub_100026A94((const void **)v1 + 23);
  sub_100026A94((const void **)v1 + 22);
  *((void *)v1 + 17) = off_10017D710;
  *((void *)v1 + 5) = off_10017D768;
  return sub_100026A94((const void **)v1 + 20);
}

void sub_1000B933C(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  *(void *)uint64_t v1 = off_10017CCD8;
  *((void *)v1 + 3) = off_10017CD20;
  *((void *)v1 + 4) = off_10017CD68;
  *((void *)v1 + 5) = off_10017CDB0;
  *((void *)v1 + 6) = off_10017CDF8;
  *((void *)v1 + 7) = off_10017CE40;
  *((void *)v1 + _Block_object_dispose((const void *)(v2 - 120), 8) = off_10017CE88;
  *((void *)v1 + 9) = off_10017CEE8;
  *((void *)v1 + 17) = off_10017CF58;
  *((void *)v1 + 21) = off_10017CFC8;
  sub_100026A94((const void **)v1 + 2);
  sub_1000982B0((const void **)v1 + 1);
  *((void *)v1 + 21) = off_10017D858;
  *((void *)v1 + _Block_object_dispose((const void *)(v2 - 120), 8) = off_10017D8B0;
  sub_100026A94((const void **)v1 + 24);
  sub_100026A94((const void **)v1 + 23);
  sub_100026A94((const void **)v1 + 22);
  *((void *)v1 + 17) = off_10017D710;
  *((void *)v1 + 5) = off_10017D768;
  sub_100026A94((const void **)v1 + 20);
  operator delete(v1);
}

const void **sub_1000B9404(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 32LL);
  *(void *)uint64_t v1 = off_10017CCD8;
  *((void *)v1 + 3) = off_10017CD20;
  *((void *)v1 + 4) = off_10017CD68;
  *((void *)v1 + 5) = off_10017CDB0;
  *((void *)v1 + 6) = off_10017CDF8;
  *((void *)v1 + 7) = off_10017CE40;
  *((void *)v1 + _Block_object_dispose((const void *)(v2 - 120), 8) = off_10017CE88;
  *((void *)v1 + 9) = off_10017CEE8;
  *((void *)v1 + 17) = off_10017CF58;
  *((void *)v1 + 21) = off_10017CFC8;
  sub_100026A94((const void **)v1 + 2);
  sub_1000982B0((const void **)v1 + 1);
  *((void *)v1 + 21) = off_10017D858;
  *((void *)v1 + _Block_object_dispose((const void *)(v2 - 120), 8) = off_10017D8B0;
  sub_100026A94((const void **)v1 + 24);
  sub_100026A94((const void **)v1 + 23);
  sub_100026A94((const void **)v1 + 22);
  *((void *)v1 + 17) = off_10017D710;
  *((void *)v1 + 5) = off_10017D768;
  return sub_100026A94((const void **)v1 + 20);
}

void sub_1000B94C4(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 32LL);
  *(void *)uint64_t v1 = off_10017CCD8;
  *((void *)v1 + 3) = off_10017CD20;
  *((void *)v1 + 4) = off_10017CD68;
  *((void *)v1 + 5) = off_10017CDB0;
  *((void *)v1 + 6) = off_10017CDF8;
  *((void *)v1 + 7) = off_10017CE40;
  *((void *)v1 + _Block_object_dispose((const void *)(v2 - 120), 8) = off_10017CE88;
  *((void *)v1 + 9) = off_10017CEE8;
  *((void *)v1 + 17) = off_10017CF58;
  *((void *)v1 + 21) = off_10017CFC8;
  sub_100026A94((const void **)v1 + 2);
  sub_1000982B0((const void **)v1 + 1);
  *((void *)v1 + 21) = off_10017D858;
  *((void *)v1 + _Block_object_dispose((const void *)(v2 - 120), 8) = off_10017D8B0;
  sub_100026A94((const void **)v1 + 24);
  sub_100026A94((const void **)v1 + 23);
  sub_100026A94((const void **)v1 + 22);
  *((void *)v1 + 17) = off_10017D710;
  *((void *)v1 + 5) = off_10017D768;
  sub_100026A94((const void **)v1 + 20);
  operator delete(v1);
}

const void **sub_1000B958C@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  return sub_1000B9038((CFArrayRef *)((char *)a1 + *(void *)(*a1 - 40LL)), a2);
}

CFStringRef sub_1000B959C()
{
  return @"STCK";
}

const void **sub_1000B95A8(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void sub_1000B95D8(uint64_t *a1, uint64_t a2)
{
  if (*(void *)sub_1000BB2D4(a2 + 32, *(void *)(a2 + 176)))
  {
    uint64_t v4 = *(void *)(a2 + 352);
    uint64_t v5 = *(void *)(a2 + 360);
    __int128 v28 = 0u;
    __int128 v29 = 0u;
    sub_1000BE4C4(a2 + 200, v26);
    CFArrayRef v6 = a1 + 2;
    if (v4 == v5)
    {
      uint64_t v11 = 0LL;
    }

    else
    {
      uint64_t v7 = 0LL;
      uint64_t v8 = 0LL;
      do
      {
        unint64_t v9 = *(void *)(v4 + 8 * v8) * *(unsigned int *)(a2 + 96);
        if (v9)
        {
          ++*(uint64_t *)((char *)v6 + *(void *)(*a1 - 136));
          sub_1000C71EC(a2 + 200, (uint64_t)v26, v8, v9, 0, 1, (unint64_t *)buf);
          if (*(void *)buf && !*(_BYTE *)(*(void *)buf + 520LL))
          {
            if (*(_BYTE *)(*(void *)buf + 400LL)) {
              uint64_t v10 = *(void *)buf + 40LL;
            }
            else {
              uint64_t v10 = 0LL;
            }
            sub_1000BA584(a1, v10, (uint64_t)v26, &v28);
          }

          sub_1000BB354((unint64_t *)buf);
        }

        ++v8;
        v7 += 8LL;
      }

      while (v4 + v7 != v5);
      uint64_t v11 = *((void *)&v28 + 1);
    }

    uint64_t v12 = *v6;
    *(uint64_t *)((char *)a1 + *(void *)(*a1 - 112) + 56) -= v12
    uint64_t v13 = *((void *)&v29 + 1);
    if (*((void *)&v29 + 1) && sub_1000B866C())
    {
      int v14 = *__error();
      if (sub_1000B8654())
      {
        uint64_t v25 = 0LL;
        uint64_t v15 = (os_log_s *)sub_1000B85DC();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG)) {
          uint64_t v16 = 3LL;
        }
        else {
          uint64_t v16 = 2LL;
        }
        *(_DWORD *)buf = 68158210;
        *(_DWORD *)&uint8_t buf[4] = 71;
        __int16 v31 = 2080;
        BOOL v32 = "void info::DiskImageInfoASIF::count_used_extents(const DiskImageASIF &)";
        __int16 v33 = 2048;
        uint64_t v34 = v13;
        LODWORD(v23) = 28;
        uint64_t v17 = (const char *)_os_log_send_and_compose_impl( v16,  &v25,  0LL,  0LL,  &_mh_execute_header,  v15,  2LL,  "%.*s: WARNING: Found %llu sectors with invalid flags (has_bitmap)",  (int)buf,  v23,  v24);
        if (v17)
        {
          uint64_t v18 = (char *)v17;
          fprintf(__stderrp, "%s\n", v17);
          free(v18);
        }
      }

      else
      {
        uint64_t v19 = (os_log_s *)sub_1000B85DC();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 68158210;
          *(_DWORD *)&uint8_t buf[4] = 71;
          __int16 v31 = 2080;
          BOOL v32 = "void info::DiskImageInfoASIF::count_used_extents(const DiskImageASIF &)";
          __int16 v33 = 2048;
          uint64_t v34 = v13;
          _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEBUG,  "%.*s: WARNING: Found %llu sectors with invalid flags (has_bitmap)",  buf,  0x1Cu);
        }
      }

      *__error() = v14;
    }

    v26[0] = off_10017E998;
    uint64_t v20 = v27;
    if (v27)
    {
      p_shared_owners = (unint64_t *)&v27->__shared_owners_;
      do
        unint64_t v22 = __ldaxr(p_shared_owners);
      while (__stlxr(v22 - 1, p_shared_owners));
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
    }
  }

void sub_1000B98E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_1000B9948(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = (std::__shared_weak_count *)a1[1];
  *(void *)&__int128 v26 = *a1;
  *((void *)&v26 + 1) = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      unint64_t v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
    uint64_t v24 = v3;
    uint64_t v25 = v4;
    do
      unint64_t v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }

  else
  {
    uint64_t v24 = v3;
    uint64_t v25 = 0LL;
  }

  do
  {
    (*(void (**)(void, uint64_t))(*(void *)v26 + 168LL))(v26, a2);
    sub_100026A1C(&v24, (uint64_t *)&v26);
    sub_1001171D0((uint64_t)&v26, &v23);
    __int128 v8 = v23;
    __int128 v23 = 0uLL;
    unint64_t v9 = (std::__shared_weak_count *)*((void *)&v26 + 1);
    __int128 v26 = v8;
    if (v9)
    {
      uint64_t v10 = (unint64_t *)&v9->__shared_owners_;
      do
        unint64_t v11 = __ldaxr(v10);
      while (__stlxr(v11 - 1, v10));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }

    uint64_t v12 = v26;
    uint64_t v13 = (std::__shared_weak_count *)*((void *)&v23 + 1);
    uint64_t v14 = v24;
    if (*((void *)&v23 + 1))
    {
      uint64_t v15 = (unint64_t *)(*((void *)&v23 + 1) + 8LL);
      do
        unint64_t v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
  }

  while (v12 != v14);
  uint64_t v17 = v25;
  if (v25)
  {
    uint64_t v18 = (unint64_t *)&v25->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  uint64_t v20 = (std::__shared_weak_count *)*((void *)&v26 + 1);
  if (*((void *)&v26 + 1))
  {
    uint64_t v21 = (unint64_t *)(*((void *)&v26 + 1) + 8LL);
    do
      unint64_t v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }

void sub_1000B9AD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  sub_1000114F0((uint64_t)va);
  sub_1000114F0((uint64_t)va1);
  _Unwind_Resume(a1);
}

CFStringRef sub_1000B9AF4(void *a1, void *a2)
{
  uint64_t v4 = sub_1000CE42C(a2);
  v14[4] = v4;
  v14[5] = (const void *)v5;
  if ((unint64_t)v4 | v5)
  {
    *(void *)&v15.byte8 = v5;
    *(void *)&v15.byte0 = v4;
    v14[0] = CFUUIDCreateFromUUIDBytes(kCFAllocatorDefault, v15);
    CFStringRef v6 = CFUUIDCreateString(kCFAllocatorDefault, (CFUUIDRef)v14[0]);
    v13[0] = v6;
    unint64_t v7 = (CFTypeRef *)((char *)a1 + *(void *)(*a1 - 128LL));
    if (v7[3])
    {
      CFRelease(v7[3]);
      CFStringRef v6 = (CFStringRef)v13[0];
    }

    v7[3] = v6;
    v13[0] = 0LL;
    sub_100026A94(v13);
    sub_100026EE4(v14);
  }

  uint64_t result = sub_1000CE420(a2);
  *(void *)&v9.byte8 = *(void *)&v9.byte0;
  v14[0] = result;
  v14[1] = *(const void **)&v9.byte0;
  if ((unint64_t)result | *(void *)&v9.byte0)
  {
    *(void *)&v9.byte0 = result;
    v13[0] = CFUUIDCreateFromUUIDBytes(kCFAllocatorDefault, v9);
    CFStringRef v10 = CFUUIDCreateString(kCFAllocatorDefault, (CFUUIDRef)v13[0]);
    uint64_t v12 = v10;
    unint64_t v11 = (CFTypeRef *)((char *)a1 + *(void *)(*a1 - 128LL));
    if (v11[2])
    {
      CFRelease(v11[2]);
      CFStringRef v10 = v12;
    }

    void v11[2] = v10;
    uint64_t v12 = 0LL;
    sub_100026A94((const void **)&v12);
    return (const __CFString *)sub_100026EE4(v13);
  }

  return result;
}

void sub_1000B9C48(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3 = va_arg(va1, const void *);
  sub_100026A94((const void **)va);
  sub_100026EE4((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_1000B9C90(void *a1, const void *a2)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  v44[0] = Mutable;
  unint64_t v5 = (CFTypeRef *)((char *)a1 + *(void *)(*a1 - 136LL));
  if (v5[10])
  {
    CFRelease(v5[10]);
    CFMutableArrayRef Mutable = (CFMutableArrayRef)v44[0];
  }

  v5[10] = Mutable;
  v44[0] = 0LL;
  sub_100026EB4(v44);
  sub_1000BE4C4((uint64_t)a2 + 200, v37);
  CFStringRef v6 = *(const void **)((char *)a1 + *(void *)(*a1 - 112LL) + 16);
  v44[0] = a2;
  v44[1] = 0LL;
  v44[2] = v6;
  char v45 = 2;
  uint64_t v46 = 0LL;
  uint64_t v47 = v37;
  int v48 = 2;
  unint64_t v7 = v49;
  v49[0] = &off_10016D460;
  __int128 v50 = v49;
  sub_1000506D8((uint64_t)v44, (uint64_t)&v32);
  sub_10005080C((uint64_t)v44, (uint64_t)v31);
  while (sub_1000E47F0((uint64_t)&v32, (uint64_t)v31))
  {
    if (v36 == 3)
    {
      int v20 = *__error();
      if (sub_1000B8654())
      {
        uint64_t v30 = 0LL;
        uint64_t v21 = (os_log_s *)sub_1000B85DC();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR)) {
          uint64_t v22 = 3LL;
        }
        else {
          uint64_t v22 = 2LL;
        }
        value = (void *)0x4B04100302LL;
        __int16 v40 = 2080;
        int v41 = "void info::DiskImageInfoASIF::examine_mapped_extents(const DiskImageASIF &)";
        __int16 v42 = 2048;
        uint64_t v43 = v33;
        LODWORD(v2_Block_object_dispose((const void *)(v2 - 120), 8) = 28;
        __int128 v23 = (const char *)_os_log_send_and_compose_impl( v22,  &v30,  0LL,  0LL,  &_mh_execute_header,  v21,  16LL,  "%.*s: Failed during ASIF extents enumeration on offset: %llu",  (int)&value,  v28,  v29);
        if (v23)
        {
          uint64_t v24 = (char *)v23;
          fprintf(__stderrp, "%s\n", v23);
          free(v24);
        }
      }

      else
      {
        uint64_t v25 = (os_log_s *)sub_1000B85DC();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          value = (void *)0x4B04100302LL;
          __int16 v40 = 2080;
          int v41 = "void info::DiskImageInfoASIF::examine_mapped_extents(const DiskImageASIF &)";
          __int16 v42 = 2048;
          uint64_t v43 = v33;
          _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_ERROR,  "%.*s: Failed during ASIF extents enumeration on offset: %llu",  (uint8_t *)&value,  0x1Cu);
        }
      }

      *__error() = v20;
      exception = __cxa_allocate_exception(0x40uLL);
      void *exception = &off_100189E78;
      uint64_t v27 = std::generic_category();
      exception[1] = 22LL;
      exception[2] = v27;
      *((_BYTE *)exception + 24) = 0;
      *((_BYTE *)exception + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
      exception[7] = "Failed during ASIF extents enumeration.";
    }

    uint64_t v9 = v33;
    uint64_t v8 = v34;
    char v10 = v35;
    CFMutableArrayRef v11 = CFArrayCreateMutable(kCFAllocatorDefault, 2LL, &kCFTypeArrayCallBacks);
    value = v11;
    if ((v10 & 2) != 0) {
      uint64_t v12 = v9;
    }
    else {
      uint64_t v12 = v9 + 1;
    }
    sub_1000F6758(v11, v12);
    sub_1000F6758(value, (v10 & 1) + v8 - 1);
    CFArrayAppendValue(*(CFMutableArrayRef *)((char *)a1 + *(void *)(*a1 - 136LL) + 80), value);
    sub_100026EB4((const void **)&value);
    sub_1000E4A20(&v32);
  }

  uint64_t v13 = v31[0];
  v31[0] = 0LL;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 24LL))(v13);
  }
  uint64_t v14 = v32;
  uint64_t v32 = 0LL;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 24LL))(v14);
  }
  if (v50 == v49)
  {
    uint64_t v15 = 4LL;
  }

  else
  {
    if (!v50) {
      goto LABEL_19;
    }
    uint64_t v15 = 5LL;
    unint64_t v7 = v50;
  }

  (*(void (**)(void *))(*v7 + 8 * v15))(v7);
LABEL_19:
  uint64_t v16 = v46;
  uint64_t v46 = 0LL;
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 40LL))(v16);
  }
  v37[0] = off_10017E998;
  uint64_t v17 = v38;
  if (v38)
  {
    p_shared_owners = (unint64_t *)&v38->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(p_shared_owners);
    while (__stlxr(v19 - 1, p_shared_owners));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

void sub_1000BA0A8(_Unwind_Exception *a1)
{
}

uint64_t *sub_1000BA190(uint64_t *a1, void *a2, char a3)
{
  *a1 = (uint64_t)off_10017DFA8;
  a1[9] = (uint64_t)off_10017E110;
  a1[10] = (uint64_t)off_10017E158;
  a1[11] = (uint64_t)&off_10017E3E0;
  a1[5] = (uint64_t)off_10017E438;
  a1[6] = (uint64_t)off_10017E038;
  *((_BYTE *)a1 + 112) = 0;
  *((_BYTE *)a1 + 120) = 0;
  *((_BYTE *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
  *((_BYTE *)a1 + 136) = 0;
  a1[19] = (uint64_t)off_10017E528;
  a1[7] = (uint64_t)off_10017E580;
  a1[8] = (uint64_t)off_10017E0C8;
  *((_BYTE *)a1 + 160) = 0;
  *((_BYTE *)a1 + 16_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
  a1[22] = 0LL;
  sub_1000BA45C(a1 + 23, (uint64_t *)&off_10017DF08, (uint64_t)a2);
  a1[29] = 0LL;
  a1[37] = 0LL;
  *(_OWORD *)(a1 + 31) = 0u;
  *(_OWORD *)(a1 + 33) = 0u;
  *a1 = (uint64_t)off_10017DA58;
  a1[5] = (uint64_t)off_10017DAA0;
  a1[6] = (uint64_t)off_10017DAE8;
  a1[7] = (uint64_t)off_10017DB30;
  a1[8] = (uint64_t)off_10017DB78;
  a1[9] = (uint64_t)off_10017DBC0;
  a1[10] = (uint64_t)off_10017DC08;
  a1[11] = (uint64_t)off_10017DC68;
  a1[19] = (uint64_t)off_10017DCD8;
  a1[23] = (uint64_t)off_10017DD48;
  a1[27] = (uint64_t)off_10017DDB8;
  *(_OWORD *)(a1 + 1) = 0u;
  *(_OWORD *)(a1 + 3) = 0u;
  uint64_t v6 = (*(uint64_t (**)(void *))(*a2 + 32LL))(a2);
  uint64_t v7 = *a1;
  *(uint64_t *)((char *)a1 + *(void *)(*a1 - 112) + 16) = v6;
  uint64_t v8 = *(uint64_t *)((char *)a1 + *(void *)(v7 - 112) + 16);
  uint64_t v9 = (*(uint64_t (**)(void *))(*a2 + 24LL))(a2);
  uint64_t v10 = *a1;
  *(uint64_t *)((char *)a1 + *(void *)(*a1 - 112) + _Block_object_dispose((const void *)(v2 - 120), 8) = v9 * v8;
  uint64_t v11 = *((unsigned int *)a2 + 24);
  *(uint64_t *)((char *)a1 + *(void *)(v10 - 136) + 24) = v11;
  *(uint64_t *)((char *)a1 + *(void *)(v10 - 136) + 64) = a2[11];
  *(uint64_t *)((char *)a1 + *(void *)(v10 - 136) + _Block_object_dispose((const void *)(v2 - 120), 8) = a2[476];
  *(uint64_t *)((char *)a1 + *(void *)(v10 - 112) + 56) = *(uint64_t *)((char *)a1 + *(void *)(v10 - 112) + 8);
  uint64_t v12 = a2[13];
  if (v12)
  {
    uint64_t v13 = v12 * v11;
  }

  else
  {
    uint64_t v14 = a2[11];
    uint64_t v13 = (*(uint64_t (**)(void *))(*a2 + 24LL))(a2) * v14;
    uint64_t v10 = *a1;
  }

  uint64_t v15 = (uint64_t)a1 + *(void *)(v10 - 112);
  *(void *)(v15 + 40) = v13;
  *(_BYTE *)(v15 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 1;
  uint64_t v16 = (uint64_t)a1 + *(void *)(*a1 - 112);
  uint64_t v17 = *((unsigned int *)a2 + 24);
  if (!*(_BYTE *)(v16 + 32)) {
    *(_BYTE *)(v16 + sub_1000114F0(v6 - 32) = 1;
  }
  *(void *)(v16 + 24) = v17;
  *((_BYTE *)a1 + *(void *)(*a1 - 136) + 72) = *((_BYTE *)a2 + 44) & 1;
  sub_1000B95D8(a1, (uint64_t)a2);
  sub_1000B9948(a2 + 2, (uint64_t)a1 + *(void *)(*a1 - 104));
  sub_1000B9AF4(a1, a2);
  if ((a3 & 2) != 0) {
    sub_1000B9C90(a1, a2);
  }
  return a1;
}

void sub_1000BA404(_Unwind_Exception *a1)
{
  *(void *)(v1 + 216) = off_10017E7B8;
  *(void *)(v1 + 72) = off_10017E810;
  sub_100026EB4((const void **)(v1 + 296));
  sub_100025288(v3, (uint64_t *)&off_10017DF08);
  *(void *)(v1 + 152) = v4;
  *(void *)(v1 + 56) = v4 + 88;
  sub_100026A94(v2);
  _Unwind_Resume(a1);
}

uint64_t *sub_1000BA45C(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  *a1 = (uint64_t)off_100168D68;
  uint64_t v4 = a2[1];
  *a1 = v4;
  *(uint64_t *)((char *)a1 + *(void *)(v4 - sub_100026A94((const void **)(v10 + 24)) = a2[2];
  uint64_t v5 = *a2;
  *a1 = *a2;
  *(uint64_t *)((char *)a1 + *(void *)(v5 - sub_100026A94((const void **)(v10 + 24)) = a2[3];
  a1[1] = 0LL;
  a1[2] = 0LL;
  uint64_t v6 = (CFTypeRef *)(a1 + 1);
  a1[3] = 0LL;
  uint64_t v7 = sub_1000CE438(a3);
  uint64_t v9 = v8;
  *(void *)&v14.byte0 = v7;
  *(void *)&v14.byte8 = v9;
  uint64_t v13 = CFUUIDCreateFromUUIDBytes(kCFAllocatorDefault, v14);
  CFStringRef v10 = CFUUIDCreateString(kCFAllocatorDefault, v13);
  uint64_t v12 = v10;
  if (*v6)
  {
    CFRelease(*v6);
    CFStringRef v10 = v12;
  }

  a1[1] = (uint64_t)v10;
  uint64_t v12 = 0LL;
  sub_100026A94((const void **)&v12);
  sub_100026EE4((const void **)&v13);
  return a1;
}

void sub_1000BA538( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

uint64_t sub_1000BA584(uint64_t *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t result = sub_1000BF4D8(a2, a2, (uint64_t)v22);
  unint64_t v7 = *(void *)(a2 + 352);
  uint64_t v8 = a1 + 1;
  uint64_t v9 = a1 + 3;
  uint64_t v10 = a1 + 4;
  while (v22[0] != v22[5] || v22[1] != v22[6])
  {
    uint64_t v11 = (void *)sub_1000BC370((uint64_t)v22);
    sub_1000BF55C(a2, v11, (uint64_t)v21);
    while (v21[0] != v21[5] || v21[1] != v21[6])
    {
      *(_OWORD *)int v20 = *(_OWORD *)sub_1000BC370((uint64_t)v21);
      int v12 = sub_1000BCEB4(v20);
      uint64_t v13 = *a1;
      unint64_t v14 = *(void *)((char *)v8 + *(void *)(*a1 - 112));
      BOOL v15 = v14 > v7;
      unint64_t v16 = v14 - v7;
      if (v15)
      {
        else {
          uint64_t v17 = v16;
        }
      }

      else
      {
        uint64_t v17 = 0LL;
      }

      switch(v12)
      {
        case 0:
          ++*(void *)((char *)v10 + *(void *)(v13 - 136));
          *v8 += v17;
          break;
        case 1:
          ++*(uint64_t *)((char *)a1 + *(void *)(v13 - 136) + 40);
          a1[2] += v17;
          break;
        case 2:
          ++*(uint64_t *)((char *)a1 + *(void *)(v13 - 136) + 48);
          *v10 += v17;
          break;
        case 3:
          ++*(uint64_t *)((char *)a1 + *(void *)(v13 - 136) + 56);
          *v9 += v17;
          if (v17)
          {
            sub_1000BA7B4(a1, a2, a3, v20[0], v20[1], a4, v17);
            uint64_t v13 = *a1;
          }

          break;
        default:
          break;
      }

      v7 += *(void *)((char *)v9 + *(void *)(v13 - 136));
      sub_1000BC538((uint64_t)v21, (uint64_t)v20);
    }

    uint64_t result = sub_1000BC428((uint64_t)v22, (uint64_t)v21);
  }

  return result;
}

void *sub_1000BA784(void *a1)
{
  *a1 = off_10017E998;
  sub_1000114F0((uint64_t)(a1 + 2));
  return a1;
}

unint64_t *sub_1000BA7B4( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7)
{
  v28[0] = a4;
  v28[1] = a5;
  unint64_t v12 = sub_1000BD16C(v28);
  sub_1000BCED0(a2, a3, v12, 0, 1LL, &v27);
  uint64_t v13 = (char *)a1 + *(void *)(*a1 - 112LL);
  unint64_t v14 = *((void *)v13 + 1);
  unint64_t v15 = *((void *)v13 + 2);
  if (v15 - 1 >= v14)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = &off_100189E78;
    __int128 v26 = std::generic_category();
    exception[1] = 22LL;
    exception[2] = v26;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
    exception[7] = "Corrupted ASIF image.";
  }

  unint64_t v16 = sub_1000BD2A4(v28);
  unint64_t v17 = v16 + a7;
  if (v16 < v17)
  {
    int v18 = 0;
    unint64_t v19 = v14 / v15;
    do
    {
      while (1)
      {
        if (v27) {
          int v20 = *(_BYTE *)(v27 + 224) ? (void *)(v27 + 40) : 0LL;
        }
        else {
          int v20 = 0LL;
        }
        unint64_t v21 = sub_1000BD2CC(v20, a2, v18, v16, v17);
        uint64_t v22 = a6;
        unint64_t v23 = (v21 - v16) / v19;
        if (v18)
        {
          uint64_t v22 = a6 + 1;
          if (v18 == 2) {
            break;
          }
        }

        *v22 += v23;
        ++v18;
        unint64_t v16 = v21;
      }

      int v18 = 0;
      a6[2] += v23;
      unint64_t v16 = v21;
    }

    while (v21 < v17);
  }

  return sub_1000BBEA0(&v27);
}

void sub_1000BA950(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_1000BA96C(uint64_t a1)
{
  *(void *)a1 = off_10017EC18;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = off_10017EC70;
  sub_100026EB4((const void **)(a1 + 80));
  return a1;
}

void sub_1000BA9A8(void *a1)
{
  *(void *)a1 = off_10017EC18;
  *((void *)a1 + 11) = off_10017EC70;
  sub_100026EB4((const void **)a1 + 10);
  operator delete(a1);
}

const void **sub_1000BA9E4@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t valuePtr = *(void *)(a1 + 8);
  uint64_t v11 = (uint64_t **)@"Dir Pointer Version";
  uint64_t v12 = (uint64_t)CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  uint64_t v13 = @"Num Tables";
  uint64_t valuePtr = *(void *)(a1 + 16);
  CFNumberRef v14 = 0LL;
  CFNumberRef v14 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  unint64_t v15 = @"Chunk Size";
  uint64_t valuePtr = *(void *)(a1 + 24);
  CFNumberRef v16 = 0LL;
  CFNumberRef v16 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  unint64_t v17 = @"Uninitialized Entries";
  uint64_t valuePtr = *(void *)(a1 + 32);
  CFNumberRef v18 = 0LL;
  CFNumberRef v18 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  unint64_t v19 = @"Full Entries";
  uint64_t valuePtr = *(void *)(a1 + 40);
  CFNumberRef v20 = 0LL;
  CFNumberRef v20 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  unint64_t v21 = @"Unmapped Entries";
  uint64_t valuePtr = *(void *)(a1 + 48);
  CFNumberRef v22 = 0LL;
  CFNumberRef v22 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  unint64_t v23 = @"Bitmapped Entries";
  uint64_t valuePtr = *(void *)(a1 + 56);
  CFNumberRef v24 = 0LL;
  CFNumberRef v24 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  uint64_t v25 = @"Max Sector Count";
  uint64_t valuePtr = *(void *)(a1 + 64);
  CFNumberRef v26 = 0LL;
  CFNumberRef v4 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  uint64_t v5 = *(unsigned __int8 *)(a1 + 72);
  CFNumberRef v26 = v4;
  unint64_t v27 = @"Is Cache";
  uint64_t valuePtr = v5;
  CFNumberRef v28 = 0LL;
  CFNumberRef v28 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  uint64_t v29 = (uint64_t *)&v11;
  uint64_t v30 = 9LL;
  sub_1000F6F08((uint64_t *)&v29, (CFMutableDictionaryRef *)&v9);
  for (uint64_t i = 17LL; i != -1; i -= 2LL)
    sub_100026D90((const void **)&(&v11)[i]);
  unint64_t v7 = *(const void **)(a1 + 80);
  if (v7)
  {
    uint64_t v29 = (uint64_t *)@"Mapped Sectors";
    uint64_t v30 = (uint64_t)v7;
    CFRetain(v7);
    uint64_t v11 = &v29;
    uint64_t v12 = 1LL;
    sub_1000F6EC0((CFMutableDictionaryRef *)&v9, (uint64_t *)&v11);
    sub_100026D90((const void **)&v30);
  }

  *a2 = v9;
  uint64_t v9 = 0LL;
  return sub_100026DC0(&v9);
}

void sub_1000BAC68(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_1000BACEC()
{
}

CFStringRef sub_1000BACF4()
{
  return @"ASIF Info";
}

const void **sub_1000BAD08(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  *(void *)uint64_t v1 = off_10017EC18;
  *((void *)v1 + 11) = off_10017EC70;
  return sub_100026EB4((const void **)v1 + 10);
}

void sub_1000BAD30(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  *(void *)uint64_t v1 = off_10017EC18;
  *((void *)v1 + 11) = off_10017EC70;
  sub_100026EB4((const void **)v1 + 10);
  operator delete(v1);
}

char *sub_1000BAD74(void *a1)
{
  return (char *)a1 + *(void *)(*a1 - 32LL);
}

char *sub_1000BAD84(void *a1)
{
  return (char *)a1 + *(void *)(*a1 - 40LL);
}

uint64_t sub_1000BAD94(uint64_t a1)
{
  *(void *)(a1 + 216) = off_10017E7B8;
  *(void *)(a1 + 72) = off_10017E810;
  sub_100026EB4((const void **)(a1 + 296));
  *(void *)(a1 + 184) = off_10017E670;
  *(void *)(a1 + 80) = off_10017E6C8;
  sub_100026A94((const void **)(a1 + 208));
  sub_100026A94((const void **)(a1 + 200));
  sub_100026A94((const void **)(a1 + 192));
  *(void *)(a1 + 152) = off_10017E528;
  *(void *)(a1 + 56) = off_10017E580;
  sub_100026A94((const void **)(a1 + 176));
  return a1;
}

void sub_1000BAE18(uint64_t a1)
{
  *(void *)(a1 + 216) = off_10017E7B8;
  *(void *)(a1 + 72) = off_10017E810;
  sub_100026EB4((const void **)(a1 + 296));
  *(void *)(a1 + 184) = off_10017E670;
  *(void *)(a1 + 80) = off_10017E6C8;
  sub_100026A94((const void **)(a1 + 208));
  sub_100026A94((const void **)(a1 + 200));
  sub_100026A94((const void **)(a1 + 192));
  *(void *)(a1 + 152) = off_10017E528;
  *(void *)(a1 + 56) = off_10017E580;
  sub_100026A94((const void **)(a1 + 176));
  operator delete((void *)a1);
}

const void **sub_1000BAE9C@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24LL))(a1);
  v10[0] = @"Image Format";
  v10[1] = v4;
  uint64_t v10[2] = @"Format Description";
  v10[3] = @"Apple sparse image";
  sub_1000258AC(a1 + *(void *)(*(void *)a1 - 112LL), &v9);
  v10[4] = @"Size Info";
  v10[5] = v9;
  uint64_t v9 = 0LL;
  sub_1000114C0(&v9);
  sub_100025BB0(a1 + *(void *)(*(void *)a1 - 120LL), &v9);
  v10[6] = @"Encryption Info";
  v10[7] = v9;
  uint64_t v9 = 0LL;
  sub_1000114C0(&v9);
  sub_1000BA9E4(a1 + *(void *)(*(void *)a1 - 136LL), &v9);
  _BYTE v10[8] = @"ASIF Info";
  v10[9] = v9;
  uint64_t v9 = 0LL;
  sub_1000114C0(&v9);
  sub_10002631C((void *)(a1 + *(void *)(*(void *)a1 - 128LL)), &v9);
  v10[10] = @"Identity Info";
  v10[11] = v9;
  uint64_t v9 = 0LL;
  sub_1000114C0(&v9);
  v7[0] = (uint64_t)v10;
  v7[1] = 6LL;
  sub_1000F6F08(v7, (CFMutableDictionaryRef *)&v8);
  *a2 = v8;
  uint64_t v8 = 0LL;
  sub_100026DC0(&v8);
  for (uint64_t i = 11LL; i != -1; i -= 2LL)
    uint64_t result = sub_100026D90((const void **)&v10[i]);
  return result;
}

void sub_1000BB048(_Unwind_Exception *a1)
{
  for (uint64_t i = 88LL; i != -8; i -= 16LL)
    sub_100026D90((const void **)(v1 + i));
  _Unwind_Resume(a1);
}

CFStringRef sub_1000BB08C()
{
  return @"ASIF";
}

const void **sub_1000BB098(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  *((void *)v1 + 27) = off_10017E7B8;
  *((void *)v1 + 9) = off_10017E810;
  sub_100026EB4((const void **)v1 + 37);
  *((void *)v1 + 23) = off_10017E670;
  *((void *)v1 + 10) = off_10017E6C8;
  sub_100026A94((const void **)v1 + 26);
  sub_100026A94((const void **)v1 + 25);
  sub_100026A94((const void **)v1 + 24);
  *((void *)v1 + 19) = off_10017E528;
  *((void *)v1 + 7) = off_10017E580;
  return sub_100026A94((const void **)v1 + 22);
}

void sub_1000BB11C(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  *((void *)v1 + 27) = off_10017E7B8;
  *((void *)v1 + 9) = off_10017E810;
  sub_100026EB4((const void **)v1 + 37);
  *((void *)v1 + 23) = off_10017E670;
  *((void *)v1 + 10) = off_10017E6C8;
  sub_100026A94((const void **)v1 + 26);
  sub_100026A94((const void **)v1 + 25);
  sub_100026A94((const void **)v1 + 24);
  *((void *)v1 + 19) = off_10017E528;
  *((void *)v1 + 7) = off_10017E580;
  sub_100026A94((const void **)v1 + 22);
  operator delete(v1);
}

const void **sub_1000BB1A8(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 32LL);
  *((void *)v1 + 27) = off_10017E7B8;
  *((void *)v1 + 9) = off_10017E810;
  sub_100026EB4((const void **)v1 + 37);
  *((void *)v1 + 23) = off_10017E670;
  *((void *)v1 + 10) = off_10017E6C8;
  sub_100026A94((const void **)v1 + 26);
  sub_100026A94((const void **)v1 + 25);
  sub_100026A94((const void **)v1 + 24);
  *((void *)v1 + 19) = off_10017E528;
  *((void *)v1 + 7) = off_10017E580;
  return sub_100026A94((const void **)v1 + 22);
}

void sub_1000BB22C(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 32LL);
  *((void *)v1 + 27) = off_10017E7B8;
  *((void *)v1 + 9) = off_10017E810;
  sub_100026EB4((const void **)v1 + 37);
  *((void *)v1 + 23) = off_10017E670;
  *((void *)v1 + 10) = off_10017E6C8;
  sub_100026A94((const void **)v1 + 26);
  sub_100026A94((const void **)v1 + 25);
  sub_100026A94((const void **)v1 + 24);
  *((void *)v1 + 19) = off_10017E528;
  *((void *)v1 + 7) = off_10017E580;
  sub_100026A94((const void **)v1 + 22);
  operator delete(v1);
}

const void **sub_1000BB2B8@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  return sub_1000BAE9C((uint64_t)a1 + *(void *)(*a1 - 40LL), a2);
}

CFStringRef sub_1000BB2C8()
{
  return @"ASIF";
}

uint64_t sub_1000BB2D4(uint64_t a1, uint64_t a2)
{
  if (a2 == 1) {
    return a1 + 24;
  }
  if (a2)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    uint64_t v4 = (void *)sub_100004870((uint64_t)exception, (uint64_t)"ASIF: invalid dir index to header", 0x16u);
  }

  return a1 + 16;
}

void sub_1000BB324(void *a1)
{
  *a1 = off_10017E998;
  sub_1000114F0((uint64_t)(a1 + 2));
  operator delete(a1);
}

unint64_t *sub_1000BB354(unint64_t *a1)
{
  do
    uint64_t result = (unint64_t *)__ldaxr(a1);
  while (__stlxr(0LL, a1));
  if (result)
  {
    do
    {
      unint64_t v3 = __ldaxr(result);
      unint64_t v4 = v3 - 1;
    }

    while (__stlxr(v4, result));
    if (!v4)
    {
      uint64_t v5 = result[4];
      result[4] = -1LL;
      return (unint64_t *)sub_1000BB394((uint64_t)result, v5, 1u);
    }
  }

  return result;
}

uint64_t sub_1000BB394(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (*(_BYTE *)(a1 + 520) || (unsigned int v6 = atomic_load((unsigned int *)(a1 + 24)), v6 != 2))
  {
    int v8 = (a3 >> 1) & 2;
    goto LABEL_9;
  }

  uint64_t v7 = sub_1000BB538(a1);
  int v8 = (a3 >> 1) & 2;
  if (!(_DWORD)v7)
  {
LABEL_9:
    atomic_store(0, (unsigned int *)(a1 + 24));
    sub_1000BB694((uint64_t *)(a1 + 40));
    sub_1000BB650(a1 + 408, a1, a2, v8);
    std::__cxx_atomic_notify_all((const void *)(a1 + 24));
    return 1LL;
  }

  if ((a3 & 2) != 0)
  {
    *(void *)&__int128 v10 = "ref::details::ctrl_blk<di_asif::details::table, unsigned long long>::reset_val(tag_t, details::reset_val_option_set) [T = di_asif::details::table, tag_t = unsigned long long]";
    *((void *)&v10 + 1) = 78LL;
    int v11 = 16;
    sub_1000BB568(v12, &v10);
    sub_100004E4C(&v13, (uint64_t)"Got error when trying to close ", 31LL);
    std::ostream::operator<<(&v13, a2);
    sub_100004E4C(&v13, (uint64_t)" with ret ", 10LL);
    std::ostream::operator<<(&v13, v7);
    sub_100004E4C(&v13, (uint64_t)", Force closing.", 16LL);
    std::ostream::~ostream(&v13, off_10017EAC0);
    sub_1000BB770((uint64_t)v12);
    std::ios::~ios(&v14);
    goto LABEL_9;
  }

  if ((a3 & 1) != 0) {
    sub_1000BB650(a1 + 408, a1, a2, v8 | 1);
  }
  return 0LL;
}

void sub_1000BB520(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t sub_1000BB538(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 400)) {
    return 0LL;
  }
  uint64_t v1 = a1 + 40;
  uint64_t v2 = *(void *)(a1 + 496);
  if (v2) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v2 + 48LL))(v2, v1);
  }
  else {
    return sub_1000C6418(v1);
  }
}

void *sub_1000BB568(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000BB6F4((uint64_t)a1, a2);
  *a1 = off_10017E9F8;
  a1[45] = &off_10017EAF8;
  a1[46] = &off_10017EB20;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_10017E9F8;
  a1[45] = off_10017EA80;
  a1[46] = off_10017EAA8;
  return a1;
}

void sub_1000BB5EC(_Unwind_Exception *a1)
{
}

uint64_t sub_1000BB610(uint64_t a1)
{
  return a1;
}

uint64_t sub_1000BB650(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int v8 = a4;
  uint64_t v6 = a3;
  uint64_t v7 = a2;
  uint64_t v4 = *(void *)(a1 + 24);
  if (!v4) {
    sub_100016D94();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *, int *))(*(void *)v4 + 48LL))(v4, &v7, &v6, &v8);
}

uint64_t *sub_1000BB694(uint64_t *result)
{
  if (*((_BYTE *)result + 360))
  {
    uint64_t v1 = result;
    std::mutex::~mutex((std::mutex *)(result + 35));
    sub_1000BBD1C(v1 + 29);
    std::mutex::~mutex((std::mutex *)(v1 + 21));
    std::mutex::~mutex((std::mutex *)(v1 + 13));
    uint64_t v2 = (void *)v1[9];
    if (v2)
    {
      v1[10] = (uint64_t)v2;
      operator delete(v2);
    }

    uint64_t result = sub_1000BBDFC(v1 + 2);
    *((_BYTE *)v1 + 360) = 0;
  }

  return result;
}

uint64_t sub_1000BB6F4(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_10017EB90;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000BB75C(_Unwind_Exception *a1)
{
}

uint64_t sub_1000BB770(uint64_t a1)
{
  *(void *)a1 = off_10017EB90;
  sub_1000BB9E8(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

void sub_1000BB80C(char *a1)
{
}

uint64_t sub_1000BB850(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000BB884(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

uint64_t sub_1000BB8D0(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_10017EAC0);
  sub_1000BB770(v2);
  return std::ios::~ios(a1 + 8);
}

void sub_1000BB908(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_10017EAC0);
  sub_1000BB770((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

uint64_t sub_1000BB948(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017EAC0);
  sub_1000BB770(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000BB988(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017EAC0);
  sub_1000BB770((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

void sub_1000BB9D4(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000BB770(a1);
  operator delete(v1);
}

uint64_t sub_1000BB9E8(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000BBB38((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000BBB10( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

int *sub_1000BBB38(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      __int128 v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 210LL;
    __int16 v25 = 2082;
    CFNumberRef v26 = v10;
    int v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        CFNumberRef v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 210LL;
      __int16 v25 = 2082;
      CFNumberRef v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000BBD1C(void *a1)
{
  uint64_t v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  a1[5] = 0LL;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8LL);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }

    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }

  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 256LL;
  }

  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 512LL;
  }

  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    uint64_t v7 = *v2++;
    operator delete(v7);
  }

  return sub_1000BBDB0((uint64_t)a1);
}

uint64_t sub_1000BBDB0(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3) {
    *(void *)(a1 + 16) = v2 + ((v3 - v2 + 7) & 0xFFFFFFFFFFFFFFF8LL);
  }
  unint64_t v4 = *(void **)a1;
  if (*(void *)a1) {
    operator delete(v4);
  }
  return a1;
}

uint64_t *sub_1000BBDFC(uint64_t *a1)
{
  uint64_t v2 = (uint64_t *)a1[4];
  if (v2 == a1 + 1)
  {
    uint64_t v3 = 4LL;
    uint64_t v2 = a1 + 1;
    goto LABEL_5;
  }

  if (v2)
  {
    uint64_t v3 = 5LL;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }

  return a1;
}

uint64_t *sub_1000BBE54(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  *uint64_t result = a2;
  if (v2)
  {
    uint64_t v4 = v2;
    uint64_t v3 = result[4];
    if (!v3) {
      sub_100016D94();
    }
    return (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v3 + 48LL))(v3, &v4);
  }

  return result;
}

unint64_t *sub_1000BBEA0(unint64_t *a1)
{
  do
    uint64_t result = (unint64_t *)__ldaxr(a1);
  while (__stlxr(0LL, a1));
  if (result)
  {
    do
    {
      unint64_t v3 = __ldaxr(result);
      unint64_t v4 = v3 - 1;
    }

    while (__stlxr(v4, result));
    if (!v4)
    {
      uint64_t v5 = result[4];
      result[4] = -1LL;
      return (unint64_t *)sub_1000BBEE0((uint64_t)result, v5, 1u);
    }
  }

  return result;
}

uint64_t sub_1000BBEE0(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (*(_BYTE *)(a1 + 344)
    || (unsigned int v6 = atomic_load((unsigned int *)(a1 + 24)), v6 != 2)
    || !*(_BYTE *)(a1 + 224)
    || (uint64_t v7 = *(void *)(a1 + 320)) == 0)
  {
    int v9 = (a3 >> 1) & 2;
    goto LABEL_11;
  }

  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v7 + 48LL))(v7, a1 + 40);
  int v9 = (a3 >> 1) & 2;
  if (!(_DWORD)v8)
  {
LABEL_11:
    atomic_store(0, (unsigned int *)(a1 + 24));
    sub_1000BC098((uint64_t *)(a1 + 40));
    sub_1000BB650(a1 + 232, a1, a2, v9);
    std::__cxx_atomic_notify_all((const void *)(a1 + 24));
    return 1LL;
  }

  if ((a3 & 2) != 0)
  {
    *(void *)&__int128 v11 = "ref::details::ctrl_blk<di_asif::details::map_element, unsigned long long>::reset_val(tag_t, details::reset_val_option_set) [T = di_asif::details::map_element, tag_t = unsigned long long]";
    *((void *)&v11 + 1) = 84LL;
    int v12 = 16;
    sub_1000BB568(v13, &v11);
    sub_100004E4C(&v14, (uint64_t)"Got error when trying to close ", 31LL);
    std::ostream::operator<<(&v14, a2);
    sub_100004E4C(&v14, (uint64_t)" with ret ", 10LL);
    std::ostream::operator<<(&v14, v8);
    sub_100004E4C(&v14, (uint64_t)", Force closing.", 16LL);
    std::ostream::~ostream(&v14, off_10017EAC0);
    sub_1000BB770((uint64_t)v13);
    std::ios::~ios(&v15);
    goto LABEL_11;
  }

  if ((a3 & 1) != 0) {
    sub_1000BB650(a1 + 232, a1, a2, v9 | 1);
  }
  return 0LL;
}

void sub_1000BC080(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t *sub_1000BC098(uint64_t *result)
{
  if (*((_BYTE *)result + 184))
  {
    uint64_t v1 = result;
    std::mutex::~mutex((std::mutex *)(result + 15));
    v1[4] = (uint64_t)off_1001731C0;
    uint64_t result = sub_100071324(v1 + 7);
    *((_BYTE *)v1 + 184) = 0;
  }

  return result;
}

uint64_t sub_1000BC15C(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 32);
  unint64_t v2 = v1 % (*(void *)(a1 + 48) + 1LL);
  uint64_t result = v1 - v2;
  if (v1 == v2)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    uint64_t v5 = (void *)sub_100004870((uint64_t)exception, (uint64_t)"Invalid chunk size", 0xFFFFFFEA);
  }

  return result;
}

unint64_t sub_1000BC1B4(uint64_t *a1)
{
  unint64_t v1 = (void *)a1[2];
  unint64_t v2 = a1[7];
  uint64_t v3 = v2 * *v1;
  unint64_t v4 = a1[5];
  unint64_t v5 = v3 + v4;
  unint64_t v6 = v1[1] * v2;
  if (v4 < v6) {
    return v5 / v2;
  }
  a1[5] = 0LL;
  uint64_t v7 = *a1;
  unint64_t v8 = a1[1];
  a1[2] = (uint64_t)(v1 + 2);
  if (v8 != ((uint64_t)v1 - v7 + 16) >> 4)
  {
    unint64_t v9 = v1[2] * v2;
    if (v9 < a1[9])
    {
      unint64_t v5 = v1[2] * v2;
      return v5 / v2;
    }
  }

  return 0LL;
}

uint64_t *sub_1000BC270( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, unint64_t a7, uint64_t a8)
{
  *a1 = a2;
  a1[1] = a3;
  a1[5] = 0LL;
  a1[6] = a4;
  a1[7] = a5;
  a1[8] = a6;
  unint64_t v9 = (uint64_t *)(a2 + 16 * a8);
  a1[9] = a7;
  if (a8 == a3)
  {
LABEL_6:
    a1[2] = (uint64_t)v9;
  }

  else
  {
    uint64_t v10 = 16 * a3 - 16 * a8;
    while (1)
    {
      uint64_t v11 = *v9;
      if ((v9[1] + *v9) * a5 >= a6) {
        break;
      }
      v9 += 2;
      v10 -= 16LL;
      if (!v10)
      {
        unint64_t v9 = (uint64_t *)(a2 + 16 * a3);
        goto LABEL_6;
      }
    }

    a1[2] = (uint64_t)v9;
    unint64_t v13 = v11 * a5;
    if (v11 * a5 < a7)
    {
      BOOL v14 = a6 >= v13;
      uint64_t v15 = a6 - v13;
      if (v15 != 0 && v14) {
        a1[5] = v15;
      }
      a1[3] = sub_1000BC1B4(a1);
      a1[4] = v16;
    }
  }

  return a1;
}

uint64_t sub_1000BC30C(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  sub_1000D02DC( &v4,  a1,  *(void *)(v2 + 48)
  + (*(void *)(v2 + 48) + 1LL)
  * ((a2 / *(unsigned __int16 *)(v2 + 18) - *(void *)(a1 + 352) / (unint64_t)*(unsigned __int16 *)(v2 + 18))
   / (*(void *)(v2 + 48)
    * (unint64_t)(*(_DWORD *)(v2 + 20) / *(unsigned __int16 *)(v2 + 18)))));
  return v4;
}

uint64_t sub_1000BC370(uint64_t a1)
{
  return a1 + 16;
}

uint64_t sub_1000BC378(uint64_t a1)
{
  uint64_t v2 = *(void *)a1;
  uint64_t v3 = *(void *)(v2 + 8);
  unint64_t v4 = *(void *)(a1 + 8)
     + *(unsigned __int16 *)(v3 + 18)
  *(void *)(a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = v4;
  if (v4 >= *(void *)(v2 + 352) + *(void *)(v3 + 80))
  {
    uint64_t v7 = 0LL;
    unint64_t v6 = 0LL;
    int v8 = 0;
  }

  else
  {
    uint64_t v5 = sub_1000BC30C(v2, v4);
    unint64_t v6 = v5 & 0xFFFFFFFFFFFFFF00LL;
    uint64_t v7 = v5;
    int v8 = 1;
  }

  if (*(unsigned __int8 *)(a1 + 32) == v8)
  {
    if (*(_BYTE *)(a1 + 32)) {
      *(void *)(a1 + 24) = v4;
    }
  }

  else if (*(_BYTE *)(a1 + 32))
  {
    *(_BYTE *)(a1 + sub_1000114F0(v6 - 32) = 0;
  }

  else
  {
    *(void *)(a1 + 16) = v6 | v7;
    *(void *)(a1 + 24) = v4;
    *(_BYTE *)(a1 + sub_1000114F0(v6 - 32) = 1;
  }

  return a1;
}

uint64_t sub_1000BC428@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __int128 v2 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(_OWORD *)(a2 + 16) = v2;
  *(void *)(a2 + sub_1000114F0(v6 - 32) = *(void *)(a1 + 32);
  return sub_1000BC378(a1);
}

uint64_t sub_1000BC43C(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  unint64_t v3 = *(unsigned __int16 *)(v2 + 18);
  sub_1000D026C( &v5,  a1,  ((a2 / v3 - *(void *)(a1 + 352) / v3) / (*(_DWORD *)(v2 + 20) / v3)
  return v5;
}

uint64_t sub_1000BC498(uint64_t a1)
{
  uint64_t v2 = *(void *)a1;
  uint64_t v3 = *(void *)(v2 + 8);
  unint64_t v4 = *(void *)(a1 + 8) + *(unsigned int *)(v3 + 20);
  *(void *)(a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = v4;
  if (v4 >= *(void *)(v2 + 352) + *(void *)(v3 + 80))
  {
    uint64_t v7 = 0LL;
    unint64_t v6 = 0LL;
    int v8 = 0;
  }

  else
  {
    uint64_t v5 = sub_1000BC43C(v2, v4);
    unint64_t v6 = v5 & 0xFFFFFFFFFFFFFF00LL;
    uint64_t v7 = v5;
    int v8 = 1;
  }

  if (*(unsigned __int8 *)(a1 + 32) == v8)
  {
    if (*(_BYTE *)(a1 + 32)) {
      *(void *)(a1 + 24) = v4;
    }
  }

  else if (*(_BYTE *)(a1 + 32))
  {
    *(_BYTE *)(a1 + sub_1000114F0(v6 - 32) = 0;
  }

  else
  {
    *(void *)(a1 + 16) = v6 | v7;
    *(void *)(a1 + 24) = v4;
    *(_BYTE *)(a1 + sub_1000114F0(v6 - 32) = 1;
  }

  return a1;
}

uint64_t sub_1000BC538@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __int128 v2 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(_OWORD *)(a2 + 16) = v2;
  *(void *)(a2 + sub_1000114F0(v6 - 32) = *(void *)(a1 + 32);
  return sub_1000BC498(a1);
}

uint64_t sub_1000BC54C(uint64_t a1, uint64_t a2, void *a3, unint64_t a4, uint64_t a5, int a6)
{
  char v6 = a6;
  *(void *)a1 = 0LL;
  *(void *)(a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = a2;
  sub_1000DC614((uint64_t *)(a1 + 16), *(void *)(a2 + 56), a6);
  sub_1000CE9C8((void *)(a1 + 72), *(void *)(a2 + 64));
  *(void *)(a1 + 104) = 850045863LL;
  *(_DWORD *)(a1 + 96) = 0;
  *(_BYTE *)(a1 + 101) = 1;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(void *)(a1 + 160) = 0LL;
  *(void *)(a1 + 16_Block_object_dispose((const void *)(v2 - 120), 8) = 850045863LL;
  *(void *)(a1 + 280) = 850045863LL;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 20_Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(void *)(a1 + 272) = 0LL;
  *(_OWORD *)(a1 + 28_Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(void *)(a1 + 336) = 0LL;
  *(void *)(a1 + 344) = a4;
  *(void *)(a1 + 352) = a5;
  if (a4 && a4 % *(unsigned int *)(a2 + 20))
  {
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = &off_100189E78;
    int v20 = std::generic_category();
    exception[1] = 4294967274LL;
    exception[2] = v20;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
    exception[7] = "ASIF: table is not aligned to chunk size";
  }

  if ((v6 & 1) != 0)
  {
    unsigned int v12 = 1;
  }

  else
  {
    unint64_t v13 = (std::__shared_weak_count *)a3[1];
    v21[0] = *a3;
    v21[1] = v13;
    if (v13)
    {
      p_shared_owners = (unint64_t *)&v13->__shared_owners_;
      do
        unint64_t v15 = __ldxr(p_shared_owners);
      while (__stxr(v15 + 1, p_shared_owners));
    }

    sub_1000BC780((void *)a1, v21);
    if (v13)
    {
      uint64_t v16 = (unint64_t *)&v13->__shared_owners_;
      do
        unint64_t v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }

    unsigned int v12 = 0;
  }

  atomic_store(v12, (unsigned int *)(a1 + 96));
  *(_BYTE *)(a1 + 100) = v12;
  return a1;
}

void sub_1000BC720(_Unwind_Exception *a1, uint64_t a2, uint64_t *a3, ...)
{
  unint64_t v9 = *v4;
  if (*v4)
  {
    *(void *)(v3 + 80) = v9;
    operator delete(v9);
  }

  sub_1000BBDFC(a3);
  _Unwind_Resume(a1);
}

void sub_1000BC780(void *a1, void *a2)
{
  uint64_t v4 = a1[1];
  uint64_t v5 = *(void *)(v4 + 56);
  size_t v6 = ((unint64_t)*(unsigned __int16 *)(v4 + 18) + 8 * v5 - 1)
  uint64_t v7 = operator new[](v6);
  bzero(v7, v6);
  unint64_t v8 = (*(uint64_t (**)(void))(*(void *)*a2 + 40LL))(*a2);
  unint64_t v9 = a1[43];
  size_t v10 = v8 - v9;
  if (v8 < v9) {
    size_t v10 = 0LL;
  }
  if (v10 >= v6) {
    size_t v11 = v6;
  }
  else {
    size_t v11 = v10;
  }
  unsigned int v12 = (std::__shared_weak_count *)*((void *)sub_100118DDC() + 1);
  uint64_t v24 = v7;
  __int16 v25 = v12;
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      unint64_t v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
  }

  size_t v26 = v11;
  unint64_t v27 = v9;
  size_t v28 = v11;
  char v29 = 0;
  unsigned int v15 = (*(uint64_t (**)(void, void **))(*(void *)*a2 + 88LL))(*a2, &v24);
  if (v11 != v15)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = &off_100189E78;
    __int16 v23 = std::generic_category();
    exception[1] = v15;
    exception[2] = v23;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
    exception[7] = "Read returned an error";
  }

  bzero(v7, v6 - v11);
  if (v5)
  {
    uint64_t v16 = 0LL;
    unint64_t v17 = (unint64_t *)v7;
    do
    {
      unint64_t v18 = *v17++;
      atomic_store(0LL, (unint64_t *)(a1[7] + v16));
      atomic_store(bswap64(v18), (unint64_t *)(a1[7] + v16 + 8));
      v16 += 16LL;
      --v5;
    }

    while (v5);
  }

  unint64_t v19 = v25;
  if (v25)
  {
    int v20 = (unint64_t *)&v25->__shared_owners_;
    do
      unint64_t v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }

  operator delete[](v7);
}

void sub_1000BC940(_Unwind_Exception *a1)
{
}

void sub_1000BC968(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  if (a2)
  {
    uint64_t v3 = (std::mutex *)(a1 + 280);
    std::mutex::lock((std::mutex *)(a1 + 280));
    sub_1000BC9D4((void *)(a1 + 232), &v4);
    atomic_store(1u, (unsigned int *)(a1 + 96));
    std::mutex::unlock(v3);
  }

void sub_1000BC9C0(_Unwind_Exception *a1)
{
}

uint64_t sub_1000BC9D4(void *a1, void *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[4];
  uint64_t v8 = a1[5];
  unint64_t v9 = v8 + v7;
  if (v6 == v8 + v7)
  {
    sub_1000DC8A0(a1);
    uint64_t v7 = a1[4];
    uint64_t v8 = a1[5];
    uint64_t v5 = a1[1];
    unint64_t v9 = v7 + v8;
  }

  *(void *)(*(void *)(v5 + ((v9 >> 6) & 0x3FFFFFFFFFFFFF8LL)) + 8 * (v9 & 0x1FF)) = *a2;
  uint64_t v10 = v8 + 1;
  a1[5] = v10;
  unint64_t v11 = v7 + v10;
  unsigned int v12 = (void *)(v5 + 8 * (v11 >> 9));
  uint64_t v13 = v11 & 0x1FF;
  if (v13) {
    uint64_t v14 = *v12 + 8 * v13;
  }
  else {
    uint64_t v14 = *(v12 - 1) + 4096LL;
  }
  return v14 - 8;
}

uint64_t sub_1000BCA84(uint64_t a1, uint64_t a2, void *a3)
{
  unint64_t v3 = atomic_load((unint64_t *)(*(void *)(*a3 + 56LL) + 16LL * a3[1] + 8));
  if (v3 >> 62 != 3) {
    return 0LL;
  }
  uint64_t v7 = (unint64_t *)(*(void *)(*a3 + 56LL) + 16LL * a3[1]);
  while (*v7)
  {
LABEL_10:
    if ((sub_1000D6EAC(v7, 1) & 1) == 0)
    {
      char v45 = 0;
      uint64_t v43 = off_100189898;
      __int16 v44 = v7;
      uint64_t v46 = 0LL;
      exception = __cxa_allocate_exception(0x40uLL);
      void *exception = &off_100189E78;
      uint64_t v10 = std::generic_category();
      exception[1] = 4294967291LL;
      exception[2] = v10;
      *((_BYTE *)exception + 24) = 0;
      *((_BYTE *)exception + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
      exception[7] = "Can't take exclusive lock on entry";
    }
  }

  while (1)
  {
    unint64_t v8 = __ldaxr(v7);
    if (!v8) {
      break;
    }
    __clrex();
LABEL_9:
    if (v8) {
      goto LABEL_10;
    }
  }

  if (__stlxr(0xFFFFFFFFFFFFFFFFLL, v7)) {
    goto LABEL_9;
  }
  int v12 = 1;
  char v45 = 1;
  uint64_t v43 = off_100189898;
  __int16 v44 = v7;
  uint64_t v46 = 0LL;
  unint64_t v13 = atomic_load((unint64_t *)(*(void *)(*a3 + 56LL) + 16LL * a3[1] + 8));
  if (v13 >> 62 == 3)
  {
    uint64_t v14 = *(void *)(*a3 + 8LL);
    sub_1000BCED0( a1,  a2,  (*(void *)(*a3 + 352LL)
     + (*(void *)(v14 + 48) + *(void *)(v14 + 48) * a3[1])
     / (unint64_t)(*(void *)(v14 + 48) + 1LL)
     * *(unsigned int *)(v14 + 20))
    / *(unsigned __int16 *)(v14 + 18),
      0,
      1LL,
      &v42);
    if (!v42 || *(_BYTE *)(v42 + 344))
    {
      uint64_t v15 = 0LL;
      BOOL v16 = 0;
      uint64_t v17 = 0LL;
      goto LABEL_17;
    }

    if (*(_BYTE *)(v42 + 224)) {
      uint64_t v18 = v42 + 40;
    }
    else {
      uint64_t v18 = 0LL;
    }
    unsigned int v19 = sub_1000BD220(a3);
    uint64_t v20 = sub_1000BD19C(v18, v19);
    uint64_t v21 = *(void *)(*a3 + 8LL);
    uint64_t v22 = *(void *)(v21 + 48);
    uint64_t v23 = *(unsigned int *)(v21 + 20);
    if (v42)
    {
      if (*(_BYTE *)(v42 + 224)) {
        __int16 v25 = (void *)(v42 + 40);
      }
      else {
        __int16 v25 = 0LL;
      }
    }

    else
    {
      __int16 v25 = 0LL;
    }

    unint64_t v24 = *(void *)(*a3 + 352LL) + (v22 + v22 * a3[1]) / (unint64_t)(v22 + 1) * v23;
    if (sub_1000C670C(v25, a1, v20, v24, v24 + v23, 0) == v24 + v23)
    {
      size_t v26 = (unint64_t *)(*(void *)(*a3 + 56LL) + 16LL * a3[1] + 8);
      unint64_t v27 = *v26;
      uint64_t v28 = *(unsigned int *)(*(void *)(*a3 + 8LL) + 20LL);
      BOOL v16 = v20 == 2;
      unint64_t v29 = *v26;
      unint64_t v30 = __ldaxr(v26);
      if (v30 == v29)
      {
        if (!__stlxr((v20 << 62) | v29 & 0x3FFFFFFFFFFFFFFFLL, v26))
        {
          char v31 = 1;
          goto LABEL_41;
        }
      }

      else
      {
        __clrex();
      }

      char v31 = 0;
LABEL_41:
      uint64_t v32 = v27 & 0x7FFFFFFFFFFFFFLL;
      if ((v31 & 1) == 0)
      {
        while (2)
        {
          unint64_t v33 = __ldaxr(v26);
          if (v33 == v30)
          {
            if (!__stlxr(v30 & 0x3FFFFFFFFFFFFFFFLL | (v20 << 62), v26))
            {
              int v34 = 1;
              goto LABEL_47;
            }
          }

          else
          {
            __clrex();
          }

          int v34 = 0;
LABEL_47:
          unint64_t v30 = v33;
          if (v34) {
            break;
          }
          continue;
        }
      }

      uint64_t v15 = v32 * v28;
      if ((_DWORD)v20 != 1)
      {
        char v35 = (unint64_t *)(*(void *)(*a3 + 56LL) + 16LL * a3[1] + 8);
        if (*(_DWORD *)(*(void *)(*a3 + 8LL) + 20LL))
        {
          do
            unint64_t v36 = __ldxr(v35);
          while (__stxr(v36 & 0xFF80000000000000LL, v35));
          goto LABEL_64;
        }

        unint64_t v37 = *v35;
        unint64_t v38 = __ldxr(v35);
        if (v38 == v37)
        {
          if (!__stxr(v37 & 0xFF80000000000000LL, v35))
          {
            char v39 = 1;
LABEL_57:
            if ((v39 & 1) != 0) {
              goto LABEL_64;
            }
            while (2)
            {
              unint64_t v40 = __ldxr(v35);
              if (v40 == v38)
              {
                if (!__stxr(v38 & 0xFF80000000000000LL, v35))
                {
                  char v41 = 1;
                  goto LABEL_63;
                }
              }

              else
              {
                __clrex();
              }

              char v41 = 0;
LABEL_63:
              unint64_t v38 = v40;
              if ((v41 & 1) != 0) {
                goto LABEL_64;
              }
              continue;
            }
          }
        }

        else
        {
          __clrex();
        }

        char v39 = 0;
        goto LABEL_57;
      }

LABEL_64:
      int v12 = 0;
      uint64_t v17 = 1LL;
      atomic_store(1u, (unsigned int *)(a1 + 96));
    }

    else
    {
      uint64_t v15 = 0LL;
      BOOL v16 = 0;
      uint64_t v17 = 0LL;
      int v12 = 0;
    }

LABEL_17:
    sub_1000BBEA0(&v42);
  }

  else
  {
    uint64_t v15 = 0LL;
    BOOL v16 = 0;
    uint64_t v17 = 0LL;
  }

  sub_100116BAC(&v43);
  if (v12) {
    uint64_t result = 0LL;
  }
  else {
    uint64_t result = v17;
  }
  if (!v12 && v16)
  {
    sub_1000BC968(a1, v15);
    return v17;
  }

  return result;
}

          uint64_t v7 = 1000 * v6.__d_.__rep_;
LABEL_18:
          if (v7 > (v5.__d_.__rep_ ^ 0x7FFFFFFFFFFFFFFFLL))
          {
            v8.__d_.__rep_ = 0x7FFFFFFFFFFFFFFFLL;
LABEL_21:
            std::condition_variable::__do_timed_wait((std::condition_variable *)(a1 + 3624), &__lk, v8);
            std::chrono::steady_clock::now();
            goto LABEL_22;
          }
        }

        v8.__d_.__rep_ = v7 + v5.__d_.__rep_;
        goto LABEL_21;
      }

      v13.__d_.__rep_ = v12 + v10.__d_.__rep_;
      goto LABEL_18;
    }
  }

  while (std::chrono::steady_clock::now().__d_.__rep_ < *a3);
  if ((*(_DWORD *)(**(void **)a4 + 368LL) & 1) != 0) {
    return 1LL;
  }
  uint64_t v14 = *(void *)(a4 + 8);
  return *(void *)v14
      && !*(_BYTE *)(*(void *)v14 + 344LL)
      && *(void *)(*(void *)v14 + 32LL) == **(void **)(a4 + 16);
}

      v13.__d_.__rep_ = v12 + v10.__d_.__rep_;
      goto LABEL_18;
    }
  }

  while (std::chrono::steady_clock::now().__d_.__rep_ < *a3);
  if ((*(_DWORD *)(**(void **)a4 + 544LL) & 1) != 0) {
    return 1LL;
  }
  uint64_t v14 = *(void *)(a4 + 8);
  return *(void *)v14
      && !*(_BYTE *)(*(void *)v14 + 520LL)
      && *(void *)(*(void *)v14 + 32LL) == **(void **)(a4 + 16);
}

      v13.__d_.__rep_ = v12 + v10.__d_.__rep_;
      goto LABEL_18;
    }
  }

  while (std::chrono::steady_clock::now().__d_.__rep_ < *a3);
  if ((*(_DWORD *)(**(void **)a4 + 336LL) & 1) != 0) {
    return 1LL;
  }
  uint64_t v14 = *(void *)(a4 + 8);
  return *(void *)v14
      && !*(_BYTE *)(*(void *)v14 + 312LL)
      && *(void *)(*(void *)v14 + 32LL) == **(void **)(a4 + 16);
}

void sub_1000BCE80(_Unwind_Exception *a1, uint64_t a2, ...)
{
  unint64_t v3 = va_arg(va1, void);
  sub_1000BBEA0((unint64_t *)va);
  sub_100116BAC(va1);
  _Unwind_Resume(a1);
}

unint64_t sub_1000BCEB4(void *a1)
{
  unint64_t v1 = atomic_load((unint64_t *)(*(void *)(*a1 + 56LL) + 16LL * a1[1] + 8));
  return v1 >> 62;
}

void sub_1000BCED0( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char a4@<W3>, uint64_t a5@<X4>, unint64_t *a6@<X8>)
{
  unint64_t v12 = (a3 - *(void *)(a1 + 352) / (unint64_t)*(unsigned __int16 *)(*(void *)(a1 + 8) + 18LL))
      / (*(void *)(*(void *)(a1 + 8) + 48LL)
  unint64_t v13 = sub_1000BD37C(a1, v12);
  sub_1000BD3EC((unint64_t *)(*(void *)(a1 + 72) + 8 * v12), v13, a6);
  if (!*a6 || *(_BYTE *)(*a6 + 344))
  {
    uint64_t v14 = *(void *)(a1 + 8);
    uint64_t v30 = *(void *)(v14 + 48)
        + (*(void *)(v14 + 48) + 1LL)
        * ((a3 - *(void *)(a1 + 352) / (unint64_t)*(unsigned __int16 *)(v14 + 18))
         / (*(void *)(v14 + 48)
          * (unint64_t)(*(_DWORD *)(v14 + 20) / *(unsigned __int16 *)(v14 + 18))));
    sub_1000D02DC(&v27, a1, v30);
    uint64_t v15 = v27;
    uint64_t v16 = v28;
    if ((a4 & 1) != 0)
    {
      LOBYTE(v27) = 0;
      char v29 = 0;
    }

    else
    {
      uint64_t v17 = (unint64_t *)(*(void *)(v27 + 56) + 16 * v28);
      BOOL v18 = sub_1000D6E20(v17);
      v25[0] = (uint64_t)off_100189878;
      v25[1] = (uint64_t)v17;
      BOOL v26 = v18;
      sub_100116A14((uint64_t)&v27, (uint64_t)v25);
      char v29 = 1;
      sub_100116A88(v25);
    }

    (*(void (**)(uint64_t *__return_ptr, void, unint64_t, uint64_t))(**(void **)(a1 + 8) + 32LL))( v25,  *(void *)(a1 + 8),  v13,  a5);
    sub_1000BD48C(a6, (unint64_t *)v25);
    sub_1000BBEA0((unint64_t *)v25);
    if (*a6)
    {
      if (!*(_BYTE *)(*a6 + 344))
      {
        if (!*a6 || (unsigned int v19 = atomic_load((unsigned int *)(*a6 + 24)), v19 != 2))
        {
          unint64_t v20 = atomic_load(a6);
          v25[0] = v20;
          uint64_t v21 = *(void *)(a1 + 72);
          do
            unint64_t v22 = __ldaxr((unint64_t *)v25);
          while (__stlxr(0LL, (unint64_t *)v25));
          atomic_store(v22, (unint64_t *)(v21 + 8 * v12));
          v25[0] = (*(void *)(*(void *)(v15 + 56) + 16 * v16 + 8) & 0x7FFFFFFFFFFFFFLL)
                 * *(unsigned int *)(*(void *)(v15 + 8) + 20LL);
          if (v25[0])
          {
            sub_1000BD4D0((uint64_t *)a6, a2, a1, (unint64_t *)&v30, v25);
          }

          else
          {
            uint64_t v24 = sub_1000BD544(*(unsigned int **)(a1 + 8), a2, 1);
            char v23 = 1;
            sub_1000BD670((uint64_t *)a6, a2, a1, (unint64_t *)&v30, &v24, &v23);
          }
        }
      }
    }

    if (v29) {
      sub_100116A88(&v27);
    }
  }

void sub_1000BD11C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, char a17)
{
  if (a17) {
    sub_100116A88(&a14);
  }
  sub_1000BBEA0(v17);
  _Unwind_Resume(a1);
}

unint64_t sub_1000BD16C(void *a1)
{
  uint64_t v1 = *(void *)(*a1 + 8LL);
  return (*(void *)(*a1 + 352LL)
        + (*(void *)(v1 + 48) + *(void *)(v1 + 48) * a1[1])
        / (unint64_t)(*(void *)(v1 + 48) + 1LL)
}

uint64_t sub_1000BD19C(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = a1 + 32;
  unsigned int v4 = sub_10008FA8C(a1 + 32, a2);
  else {
    int v5 = 0;
  }
  uint64_t result = v5 | v4;
  if ((_DWORD)result == 3)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    unint64_t v8 = (void *)sub_100004870((uint64_t)exception, (uint64_t)"bitmap flag value invalid", 0xFFFFFFEA);
  }

  return result;
}

unint64_t sub_1000BD220(void *a1)
{
  unint64_t v1 = *(void *)(*a1 + 352LL);
  uint64_t v2 = *(void *)(*a1 + 8LL);
  uint64_t v3 = *(void *)(v2 + 48);
  uint64_t v4 = *(unsigned int *)(v2 + 20);
  unint64_t v5 = (v3 + v3 * a1[1]) / (unint64_t)(v3 + 1) * v4;
  unint64_t v6 = *(unsigned __int16 *)(v2 + 18);
  return ((2
         * ((v5
                         - ((v5 + v1) / v6 - v1 / v6)
                         / (v3
                          * (unint64_t)(v4 / v6))
                         * v3
                         * v4)
                        / v6)) | (((v4
                                  - v6
                                  + v5
                                  - ((v4 - v6 + v5 + v1) / v6 - v1 / v6)
                                  / (v3
                                   * (unint64_t)(v4 / v6))
                                  * v3
                                  * v4)
                                 / v6) << 33))
       + 0x200000000LL;
}

unint64_t sub_1000BD2A4(void *a1)
{
  return *(void *)(*a1 + 352LL)
       + (*(void *)(*(void *)(*a1 + 8LL) + 48LL) + *(void *)(*(void *)(*a1 + 8LL) + 48LL) * a1[1])
}

unint64_t sub_1000BD2CC(void *a1, uint64_t a2, char a3, unint64_t a4, uint64_t a5)
{
  return sub_1000C670C(a1, a2, a3, a4, a5, 0);
}

void *sub_1000BD2D4(void *result, unint64_t a2)
{
  unint64_t v2 = *(unsigned int *)(*(void *)(*result + 8LL) + 20LL);
  uint64_t v3 = (unint64_t *)(*(void *)(*result + 56LL) + 16LL * result[1] + 8);
  if (v2 > a2)
  {
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 & 0xFF80000000000000LL, v3));
    return result;
  }

  unint64_t v5 = *v3;
  unint64_t v6 = __ldxr(v3);
  unint64_t v7 = a2 / v2;
  if (v6 != v5)
  {
    __clrex();
LABEL_8:
    while (1)
    {
      unint64_t v8 = __ldxr(v3);
      if (v8 != v6) {
        break;
      }
      if (__stxr(v6 & 0xFF80000000000000LL | v7, v3)) {
        goto LABEL_12;
      }
      int v9 = 1;
LABEL_13:
      unint64_t v6 = v8;
      if (v9) {
        return result;
      }
    }

    __clrex();
LABEL_12:
    int v9 = 0;
    goto LABEL_13;
  }

  if (__stxr(v5 & 0xFF80000000000000LL | v7, v3)) {
    goto LABEL_8;
  }
  return result;
}

unint64_t sub_1000BD37C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  unint64_t v3 = *(void *)(v2 + 64);
  if ((v3 & (v3 - 1)) != 0)
  {
    char v4 = 0;
    unint64_t v5 = 2 * v3;
    do
    {
      v5 >>= 1;
      ++v4;
    }

    while (v5 != 1);
    unint64_t v3 = 1 << v4;
  }

  unint64_t v6 = *(void *)(v2 + 80);
  if (v3 == 1)
  {
    char v7 = 0;
  }

  else
  {
    char v7 = 0;
    do
    {
      v3 >>= 1;
      ++v7;
    }

    while (v3 != 1);
  }

  return ((*(void *)(a1 + 352) / v6) << v7) | a2;
}

unint64_t *sub_1000BD3EC@<X0>( unint64_t *result@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t v4 = atomic_load(result);
  if (v4 && *(void *)(v4 + 32) == a2)
  {
    unint64_t v6 = (unint64_t *)atomic_load(result);
    sub_1000DB36C(&v9, v6, 1);
    if (v9 && !*(_BYTE *)(v9 + 344))
    {
      uint64_t v7 = *(void *)(v9 + 32);
      *a3 = 0LL;
      if (v7 == a2)
      {
        do
          unint64_t v8 = __ldaxr(&v9);
        while (__stlxr(0LL, &v9));
        atomic_store(v8, a3);
      }
    }

    else
    {
      *a3 = 0LL;
    }

    return sub_1000BBEA0(&v9);
  }

  else
  {
    *a3 = 0LL;
  }

  return result;
}

unint64_t *sub_1000BD48C(unint64_t *a1, unint64_t *a2)
{
  if (a2 != a1)
  {
    do
      unint64_t v3 = __ldaxr(a2);
    while (__stlxr(0LL, a2));
    sub_1000BBEA0(a1);
    atomic_store(v3, a1);
  }

  return a1;
}

void sub_1000BD4D0(uint64_t *a1, uint64_t a2, uint64_t a3, unint64_t *a4, uint64_t *a5)
{
}

void sub_1000BD4FC( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (*v10)
  {
    uint64_t v11 = *(void *)(*v10 + 288);
    if (v11)
    {
      a10 = *v10;
      (*(void (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)v11 + 48LL))(v11, &a10, v10);
    }
  }

  __cxa_rethrow();
}

void sub_1000BD530(_Unwind_Exception *a1)
{
}

uint64_t sub_1000BD544(unsigned int *a1, uint64_t a2, int a3)
{
  unint64_t v6 = (unint64_t *)(a1 + 2);
  do
    unint64_t v7 = __ldaxr(v6);
  while (__stlxr(v7 + 1, v6));
  uint64_t v8 = (*(uint64_t (**)(unsigned int *))(*(void *)a1 + 16LL))(a1);
  if (a3)
  {
    uint64_t v9 = a1[5];
    v14[0] = &off_10017F070;
    v14[1] = a2;
    v14[2] = v9;
    uint64_t v15 = v14;
  }

  else
  {
    uint64_t v15 = 0LL;
  }

  uint64_t v10 = sub_1000CEA3C(v8, (uint64_t)v14);
  uint64_t v11 = v15;
  if (v15 == v14)
  {
    uint64_t v12 = 4LL;
    uint64_t v11 = v14;
    goto LABEL_10;
  }

  if (v15)
  {
    uint64_t v12 = 5LL;
LABEL_10:
    (*(void (**)(void))(*v11 + 8 * v12))();
  }

  return v10;
}

void sub_1000BD634( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  uint64_t v15 = a13;
  if (a13 == v13)
  {
    uint64_t v16 = 4LL;
    uint64_t v15 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v16 = 5LL;
  }

  (*(void (**)(void))(*(void *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_1000BD670(uint64_t *a1, uint64_t a2, uint64_t a3, unint64_t *a4, uint64_t *a5, char *a6)
{
}

void sub_1000BD69C( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (*v10)
  {
    uint64_t v11 = *(void *)(*v10 + 288);
    if (v11)
    {
      a10 = *v10;
      (*(void (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)v11 + 48LL))(v11, &a10, v10);
    }
  }

  __cxa_rethrow();
}

void sub_1000BD6D0(_Unwind_Exception *a1)
{
}

uint64_t sub_1000BD6E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((*(void *)(*(void *)(a3 + 56) + 16 * a4 + 8) & 0x7FFFFFFFFFFFFFLL)
     * *(unsigned int *)(*(void *)(a3 + 8) + 20LL))
  {
    return 0LL;
  }

  unint64_t v8 = sub_1000BD544(*(unsigned int **)(a1 + 8), a2, 0);
  if (v8)
  {
    uint64_t v9 = *(void *)(a3 + 56) + 16 * a4;
    unint64_t v10 = *(void *)(v9 + 8);
    if ((v10 & 0x7FFFFFFFFFFFFFLL) == 0)
    {
      uint64_t v11 = (unint64_t *)(v9 + 8);
      unint64_t v12 = v8 / *(unsigned int *)(*(void *)(a3 + 8) + 20LL);
      while (1)
      {
        unint64_t v13 = __ldxr(v11);
        if (v13 != v10) {
          break;
        }
        if (__stxr(v10 & 0xFF80000000000000LL | v12, v11)) {
          goto LABEL_9;
        }
        char v14 = 1;
LABEL_10:
        if ((v14 & 1) != 0) {
          return 0LL;
        }
        unint64_t v10 = v13;
        if ((v13 & 0x7FFFFFFFFFFFFFLL) != 0) {
          goto LABEL_12;
        }
      }

      __clrex();
LABEL_9:
      char v14 = 0;
      goto LABEL_10;
    }

LABEL_12:
    sub_1000BD7C0(*(unint64_t **)(a1 + 8), v8, a2);
    return 0LL;
  }

  return 4294967268LL;
}

    if ((v28 & 2) != 0) {
      uint64_t v11 = v8;
    }
    else {
      uint64_t v11 = v8 + 1;
    }
    unint64_t v12 = v11 * *(unsigned __int16 *)(a1 + 18);
    sub_1000BE844(a1, a2, v12 / *(void *)(a1 + 80), 0, 1, &v26);
    if (v26 && *(_BYTE *)(v26 + 520))
    {
      exception = __cxa_allocate_exception(0x40uLL);
      void *exception = &off_100189E78;
      uint64_t v21 = std::generic_category();
      exception[1] = 4294967291LL;
      exception[2] = v21;
      *((_BYTE *)exception + 24) = 0;
      *((_BYTE *)exception + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
      exception[7] = "Can't load table to get extents";
    }

    if (v26 && !*(_BYTE *)(v26 + 520))
    {
      if (*(_BYTE *)(v26 + 400)) {
        uint64_t v15 = v26 + 40;
      }
      else {
        uint64_t v15 = 0LL;
      }
      unint64_t v13 = sub_1000C86DC(v15, a2, (uint64_t)&v27, (uint64_t)&v29);
    }

    else
    {
      unint64_t v13 = 0LL;
      char v14 = (*(void *)(a1 + 80) + *(void *)(a1 + 80) * (v12 / *(void *)(a1 + 80)) + 1)
          / *(unsigned __int16 *)(a1 + 18);
      if (v14 >= v9) {
        char v14 = v9;
      }
      char v29 = v11;
      uint64_t v30 = v14;
      char v31 = 2;
    }

    if ((_DWORD)v13 == (_DWORD)v7)
    {
LABEL_36:
      *((void *)&v32 + 1) = v30;
      unint64_t v33 = 2;
      unint64_t v22 = v27;
      char v23 = v28;
      sub_1000AC794((uint64_t)&v22, (uint64_t)&v32, (uint64_t)&v24);
      uint64_t v27 = v24;
      LOBYTE(v2_Block_object_dispose((const void *)(v2 - 120), 8) = v25;
      BOOL v18 = 1;
      unint64_t v7 = v13;
      goto LABEL_40;
    }

    if (v33)
    {
      if (v33 == 3)
      {
        uint64_t v16 = *((void *)&v32 + 1);
        uint64_t v17 = v32;
      }

      else
      {
        uint64_t v16 = *((void *)&v32 + 1);
        uint64_t v17 = v32;
      }
    }

    else
    {
      uint64_t v16 = *((void *)&v32 + 1);
      uint64_t v17 = v32;
      if ((unint64_t)v32 < *((void *)&v32 + 1) && (unint64_t)(v32 + 1) < *((void *)&v32 + 1))
      {
LABEL_35:
        goto LABEL_39;
      }
    }

    if (!qword_1001985E0) {
      goto LABEL_36;
    }
LABEL_39:
    BOOL v18 = 0;
LABEL_40:
    sub_1000BB354(&v26);
  }

  while ((v18 & 1) != 0);
  *(_OWORD *)a4 = v32;
  *(_BYTE *)(a4 + 16) = v33;
  return v7;
}

void *sub_1000BD7C0(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (*(uint64_t (**)(unint64_t *))(*a1 + 16))(a1);
  v11[0] = &off_10017F100;
  v11[1] = a3;
  unint64_t v12 = v11;
  sub_1000CF5C8(v6, a2, (uint64_t)v11);
  uint64_t result = v12;
  if (v12 == v11)
  {
    uint64_t v8 = 4LL;
    uint64_t result = v11;
    goto LABEL_5;
  }

  if (v12)
  {
    uint64_t v8 = 5LL;
LABEL_5:
    uint64_t result = (void *)(*(uint64_t (**)(void))(*result + 8 * v8))();
  }

  uint64_t v9 = a1 + 1;
  do
    unint64_t v10 = __ldaxr(v9);
  while (__stlxr(v10 - 1, v9));
  return result;
}

void sub_1000BD88C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  uint64_t v15 = a13;
  if (a13 == v13)
  {
    uint64_t v16 = 4LL;
    uint64_t v15 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v16 = 5LL;
  }

  (*(void (**)(void))(*(void *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

unint64_t *sub_1000BD8C4( uint64_t a1, uint64_t a2, void *a3, unsigned int *a4, unsigned int a5, uint64_t a6)
{
  uint64_t v11 = *(void *)(*a3 + 8LL);
  sub_1000BCED0( a1,  a2,  (*(void *)(*a3 + 352LL)
   + (*(void *)(v11 + 48) + *(void *)(v11 + 48) * a3[1])
   / (unint64_t)(*(void *)(v11 + 48) + 1LL)
   * *(unsigned int *)(v11 + 20))
  / *(unsigned __int16 *)(v11 + 18),
    0,
    1LL,
    (unint64_t *)&v31);
  if (!(void)v31 || *(_BYTE *)(v31 + 344))
  {
    *(void *)&__int128 v34 = "di_asif::details::table::set_entry_bitmap_range(ContextASIF &, data_entry_t &, const bits_range_t &, data_entry_t::flags, std::optional<data_entry_t::flags>)";
    *((void *)&v34 + 1) = 47LL;
    int v35 = 16;
    sub_1000BDC9C(&v36, &v34);
    sub_100004E4C(v38, (uint64_t)"Can't load bitmap while setting range", 37LL);
    sub_1000BDD44((uint64_t)&v36);
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = &off_100189E78;
    uint64_t v28 = std::generic_category();
    exception[1] = 5LL;
    exception[2] = v28;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
    exception[7] = "Can't load bitmap while setting range";
  }

  BOOL v12 = (a6 & 0xFF00000000LL) == 0 || (_DWORD)a6 == 3;
  char v13 = v12;
  if (!v12)
  {
    if (*(_BYTE *)(v31 + 224)) {
      uint64_t v14 = v31 + 40;
    }
    else {
      uint64_t v14 = 0LL;
    }
    unint64_t v36 = sub_1000BD220(a3);
    sub_1000BDD84(v14, a1, (unsigned int *)&v36, a6);
  }

  if ((void)v31)
  {
    if (*(_BYTE *)(v31 + 224)) {
      uint64_t v15 = v31 + 40;
    }
    else {
      uint64_t v15 = 0LL;
    }
  }

  else
  {
    uint64_t v15 = 0LL;
  }

  sub_1000BDD84(v15, a1, a4, a5);
  uint64_t result = sub_1000BBEA0((unint64_t *)&v31);
  if ((v13 & 1) != 0) {
    return result;
  }
  uint64_t v17 = *(void *)(*a3 + 8LL);
  uint64_t v18 = *(void *)(a1 + 8);
  uint64_t v19 = *(void *)(v18 + 48);
  sub_1000D02DC( &v36,  a1,  v19 + (v19 + 1)
  * (((*(void *)(*a3 + 352LL)
     + (*(void *)(v17 + 48) + *(void *)(v17 + 48) * a3[1])
     / (unint64_t)(*(void *)(v17 + 48) + 1LL)
     * *(unsigned int *)(v17 + 20))
    / *(unsigned __int16 *)(v17 + 18)
    - *(void *)(a1 + 352) / (unint64_t)*(unsigned __int16 *)(v18 + 18))
   / (v19
    * (unint64_t)(*(_DWORD *)(v18 + 20) / *(unsigned __int16 *)(v18 + 18)))));
  v33[0] = v36;
  v33[1] = v37;
  unint64_t v20 = (unint64_t *)(*(void *)(v36 + 56) + 16 * v37);
  BOOL v21 = sub_1000D6E20(v20);
  *(void *)&__int128 v34 = off_100189878;
  *((void *)&v34 + 1) = v20;
  LOBYTE(v35) = v21;
  if (!v21)
  {
    *(void *)&__int128 v31 = "di_asif::details::table::set_entry_bitmap_range(ContextASIF &, data_entry_t &, const bits_range_t &, data_entry_t::flags, std::optional<data_entry_t::flags>)";
    *((void *)&v31 + 1) = 47LL;
    int v32 = 16;
    sub_1000BDE9C(&v36, &v31);
    sub_100004E4C(v38, (uint64_t)"Couldn't lock entry ", 20LL);
    sub_1000BDE08((uint64_t)&v36, v33);
    sub_1000BDF44((uint64_t)&v36);
    char v29 = __cxa_allocate_exception(0x40uLL);
    *char v29 = &off_100189E78;
    uint64_t v30 = std::generic_category();
    v29[1] = 4294967282LL;
    v29[2] = v30;
    *((_BYTE *)v29 + 24) = 0;
    *((_BYTE *)v29 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
    v29[7] = "Couldn't lock entry";
  }

  unint64_t v22 = (unint64_t *)(*(void *)(*a3 + 56LL) + 16LL * a3[1] + 8);
  unint64_t v23 = *v22;
  unint64_t v24 = __ldaxr(v22);
  if (v24 != v23)
  {
    __clrex();
LABEL_25:
    while (1)
    {
      unint64_t v25 = __ldaxr(v22);
      if (v25 != v24) {
        break;
      }
      if (__stlxr(v24 | 0xC000000000000000LL, v22)) {
        goto LABEL_29;
      }
      int v26 = 1;
LABEL_30:
      unint64_t v24 = v25;
      if (v26) {
        goto LABEL_31;
      }
    }

    __clrex();
LABEL_29:
    int v26 = 0;
    goto LABEL_30;
  }

  if (__stlxr(v23 | 0xC000000000000000LL, v22)) {
    goto LABEL_25;
  }
LABEL_31:
  atomic_store(1u, (unsigned int *)(a1 + 96));
  return (unint64_t *)sub_100116A88(&v34);
}

void sub_1000BDC44( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void *sub_1000BDC9C(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000DCD68((uint64_t)a1, a2);
  *a1 = off_10017F188;
  a1[45] = &off_10017F288;
  a1[46] = &off_10017F2B0;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_10017F188;
  a1[45] = off_10017F210;
  a1[46] = off_10017F238;
  return a1;
}

void sub_1000BDD20(_Unwind_Exception *a1)
{
}

uint64_t sub_1000BDD44(uint64_t a1)
{
  return a1;
}

void *sub_1000BDD84(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned int a4)
{
  unint64_t v6 = *a3;
  unint64_t v7 = a3[1];
  LOWORD(v11[0]) = a4 & 1 | (((a4 >> 1) & 1) << 8);
  uint64_t result = (void *)sub_10008F304(a1 + 32, v6, v7, (unsigned __int8 *)v11);
  if ((_DWORD)result)
  {
    *(_BYTE *)(a1 + 113) = 1;
    uint64_t result = sub_1000D02DC(v11, a2, *(void *)a1);
    uint64_t v9 = (unint64_t *)(*(void *)(v11[0] + 56LL) + 16LL * v11[1] + 8);
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 | 0x8000000000000000LL, v9));
  }

  return result;
}

uint64_t sub_1000BDE08(uint64_t a1, void *a2)
{
  unint64_t v4 = sub_100004E4C((void *)(a1 + 360), (uint64_t)"table entry map@", 16LL);
  unint64_t v5 = (void *)std::ostream::operator<<( v4,  *(void *)(*a2 + 352LL)
                 + a2[1]
                 / (unint64_t)(*(void *)(*(void *)(*a2 + 8LL) + 48LL) + 1LL)
                 * *(void *)(*(void *)(*a2 + 8LL) + 48LL)
                 * *(unsigned int *)(*(void *)(*a2 + 8LL) + 20LL));
  unint64_t v6 = sub_100004E4C(v5, (uint64_t)" = offset = ", 12LL);
  std::ostream::operator<<( v6,  (*(void *)(*(void *)(*a2 + 56LL) + 16LL * a2[1] + 8) & 0x7FFFFFFFFFFFFFLL)
  * *(unsigned int *)(*(void *)(*a2 + 8LL) + 20LL));
  return a1;
}

void *sub_1000BDE9C(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000DCDE4((uint64_t)a1, a2);
  *a1 = off_10017F3A8;
  a1[45] = &off_10017F4A8;
  a1[46] = &off_10017F4D0;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_10017F3A8;
  a1[45] = off_10017F430;
  a1[46] = off_10017F458;
  return a1;
}

void sub_1000BDF20(_Unwind_Exception *a1)
{
}

uint64_t sub_1000BDF44(uint64_t a1)
{
  return a1;
}

void *sub_1000BDF84(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t result = sub_1000D02DC(v14, a1, a2);
  unint64_t v6 = *(unsigned int *)(*(void *)(v14[0] + 8LL) + 20LL);
  unint64_t v7 = (unint64_t *)(*(void *)(v14[0] + 56LL) + 16LL * v14[1] + 8);
  if (v6 > a3)
  {
    do
      unint64_t v8 = __ldxr(v7);
    while (__stxr(v8 & 0xFF80000000000000LL, v7));
    goto LABEL_14;
  }

  unint64_t v9 = *v7;
  unint64_t v10 = __ldxr(v7);
  unint64_t v11 = a3 / v6;
  if (v10 != v9)
  {
    __clrex();
LABEL_8:
    while (1)
    {
      unint64_t v12 = __ldxr(v7);
      if (v12 != v10) {
        break;
      }
      if (__stxr(v10 & 0xFF80000000000000LL | v11, v7)) {
        goto LABEL_12;
      }
      int v13 = 1;
LABEL_13:
      unint64_t v10 = v12;
      if (v13) {
        goto LABEL_14;
      }
    }

    __clrex();
LABEL_12:
    int v13 = 0;
    goto LABEL_13;
  }

  if (__stxr(v9 & 0xFF80000000000000LL | v11, v7)) {
    goto LABEL_8;
  }
LABEL_14:
  atomic_store(1u, (unsigned int *)(a1 + 96));
  return result;
}

__n128 sub_1000BE06C@<Q0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unint64_t a5@<X4>, unint64_t a6@<X5>, uint64_t a7@<X8>)
{
  __int128 v13 = v15[3];
  *(_OWORD *)(a7 + sub_1000114F0(v6 - 32) = v15[2];
  *(_OWORD *)(a7 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = v13;
  *(_OWORD *)(a7 + 64) = v15[4];
  __n128 result = (__n128)v15[1];
  *(_OWORD *)a7 = v15[0];
  *(__n128 *)(a7 + 16) = result;
  return result;
}

void sub_1000BE114(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  v18[0] = off_10017E998;
  v18[1] = v3;
  (*(void (**)(void))(**(void **)(v3 + 16) + 72LL))(*(void *)(v3 + 16));
  if (*(_BYTE *)(a1 + 16)) {
    goto LABEL_41;
  }
  do
  {
    __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 3680);
    __lk.__owns_ = 1;
    std::mutex::lock((std::mutex *)(a1 + 3680));
    while (!*(_BYTE *)(a1 + 16) && !*(_BYTE *)(a1 + 3672))
      std::condition_variable::wait((std::condition_variable *)(a1 + 3624), &__lk);
    v4.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_ + 2000000000;
    while (!*(_BYTE *)(a1 + 16) && v4.__d_.__rep_ > std::chrono::steady_clock::now().__d_.__rep_)
    {
      v5.__d_.__rep_ = v4.__d_.__rep_ - std::chrono::steady_clock::now().__d_.__rep_;
      if (v5.__d_.__rep_ >= 1)
      {
        std::chrono::steady_clock::now();
        v6.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
        if (!v6.__d_.__rep_)
        {
          std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v7 = 0LL;
          goto LABEL_18;
        }

        if (v6.__d_.__rep_ < 1)
        {
          std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v7 = 0x8000000000000000LL;
        }

        else
        {
          if ((unint64_t)v6.__d_.__rep_ > 0x20C49BA5E353F7LL)
          {
            std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v7 = 0x7FFFFFFFFFFFFFFFLL;
            goto LABEL_18;
          }

void sub_1000BE474( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

void sub_1000BE4A0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  *(void *)(v12 - 120) = off_10017E998;
  sub_1000114F0(a12);
  _Unwind_Resume(a1);
}

uint64_t sub_1000BE4C4@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 24);
  *a2 = off_10017E998;
  a2[1] = v2;
  return (*(uint64_t (**)(void))(**(void **)(v2 + 16) + 72LL))(*(void *)(v2 + 16));
}

uint64_t sub_1000BE4F4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = atomic_load((unint64_t *)(a1 + 8));
  uint64_t v4 = *(unsigned int *)(a1 + 20);
  uint64_t v5 = *(void *)(*(void *)(a1 + 152) + 8 * a3) * v4;
  uint64_t v26 = v5;
  if (v5 && 3 * v5 > 4 * v3 * v4)
  {
    unint64_t v9 = (unint64_t *)(*(void *)(a1 + 128) + 8 * a3);
    sub_1000C7688(v9, a3, (unint64_t *)&v25);
    if (v25 && !*(_BYTE *)(v25 + 520))
    {
      uint64_t v11 = *(void *)(v25 + 464);
      if (v11)
      {
        uint64_t v27 = v25;
        (*(void (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)v11 + 48LL))(v11, &v27, &v25);
      }

      sub_1000C7688(v9, a3, (unint64_t *)&v27);
      sub_1000C755C((unint64_t *)&v25, (unint64_t *)&v27);
      sub_1000BB354((unint64_t *)&v27);
      if (v25)
      {
        if (!*(_BYTE *)(v25 + 520))
        {
LABEL_15:
          (*(void (**)(uint64_t))(*(void *)a1 + 24LL))(a1);
LABEL_16:
          uint64_t v10 = 4294967248LL;
LABEL_17:
          sub_1000BB354((unint64_t *)&v25);
          return v10;
        }
      }
    }

    sub_1000C7374(a1 + 280, a3, 1, (unint64_t *)&v27);
    sub_1000C755C((unint64_t *)&v25, (unint64_t *)&v27);
    sub_1000BB354((unint64_t *)&v27);
    if (!v25 || *(_BYTE *)(v25 + 520) || (unsigned int v13 = atomic_load((unsigned int *)(v25 + 24)), v13 == 2))
    {
      if (!v25 || *(_BYTE *)(v25 + 520)) {
        goto LABEL_16;
      }
      goto LABEL_15;
    }

    uint64_t v14 = valloc(*(unsigned int *)(a1 + 20));
    if (!v14)
    {
      exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
      unint64_t v24 = std::bad_alloc::bad_alloc(exception);
    }

    v29[0] = &off_10017F7E0;
    uint64_t v30 = v29;
    uint64_t v27 = (uint64_t)v14;
    sub_1000172D0((uint64_t)&v28, (uint64_t)v29);
    unint64_t v15 = v30;
    if (v30 == v29)
    {
      uint64_t v16 = 4LL;
      unint64_t v15 = v29;
    }

    else
    {
      if (!v30)
      {
LABEL_26:
        unint64_t v17 = *(unsigned int *)(a1 + 20);
        uint64_t v18 = (*(uint64_t (**)(void))(**(void **)(a2 + 16) + 40LL))(*(void *)(a2 + 16));
        if (v18 - v26 >= v17) {
          uint64_t v19 = v17;
        }
        else {
          uint64_t v19 = v18 - v26;
        }
        uint64_t v10 = sub_1000BEE7C((unsigned int *)a1, a2, v27, v19, v26);
        uint64_t v21 = v20;
        if (v25)
        {
          uint64_t v22 = *(void *)(v25 + 464);
          if (v22)
          {
            v29[0] = v25;
            (*(void (**)(uint64_t, void *, uint64_t *))(*(void *)v22 + 48LL))(v22, v29, &v25);
          }
        }

        if ((v10 & 0x8000000000000000LL) == 0)
        {
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 40LL))(a1, *(void *)(a1 + 80) * a3, v21);
          std::mutex::lock((std::mutex *)(a1 + 3792));
          sub_1000BC9D4((void *)(a1 + 3744), &v26);
          atomic_store(1u, (unsigned int *)(a1 + 3592));
          std::mutex::unlock((std::mutex *)(a1 + 3792));
          uint64_t v10 = 0LL;
        }

        sub_100016DE0(&v27);
        goto LABEL_17;
      }

      uint64_t v16 = 5LL;
    }

    (*(void (**)(void))(*v15 + 8 * v16))();
    goto LABEL_26;
  }

  return 4294967274LL;
}

void sub_1000BE7D4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

unint64_t *sub_1000BE844@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, char a5@<W4>, unint64_t *a6@<X8>)
{
  __n128 result = sub_1000C7688((unint64_t *)(*(void *)(a1 + 128) + 8 * a3), a3, a6);
  if (!*a6 || *(_BYTE *)(*a6 + 520))
  {
    sub_1000C71EC(a1, a2, a3, *(void *)(*(void *)(a1 + 152) + 8 * a3) * *(unsigned int *)(a1 + 20), a4, a5, &v16);
    sub_1000C755C(a6, &v16);
    __n128 result = sub_1000BB354(&v16);
    if (*a6 && !*(_BYTE *)(*a6 + 520))
    {
      unint64_t v13 = atomic_load(a6);
      unint64_t v16 = v13;
      uint64_t v14 = *(void *)(a1 + 128);
      do
        unint64_t v15 = __ldaxr(&v16);
      while (__stlxr(0LL, &v16));
      atomic_store(v15, (unint64_t *)(v14 + 8 * a3));
    }
  }

  return result;
}

void sub_1000BE928(_Unwind_Exception *a1)
{
}

uint64_t sub_1000BE940(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = atomic_load((unint64_t *)(*(void *)(a1 + 8) + 8LL));
  size_t v5 = *(unsigned int *)(*(void *)(a1 + 8) + 20LL);
  std::chrono::system_clock::time_point v6 = valloc(v5);
  if (!v6)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    unint64_t v17 = std::bad_alloc::bad_alloc(exception);
  }

  v20[0] = &off_10017F7E0;
  uint64_t v22 = v20;
  uint64_t v25 = (uint64_t)v6;
  sub_1000172D0((uint64_t)&v26, (uint64_t)v20);
  std::chrono::time_point<std::chrono::system_clock, std::chrono::duration<long long, std::ratio<1, 1000000000>>> v8 = v22;
  if (v22 == v20)
  {
    uint64_t v9 = 4LL;
    std::chrono::time_point<std::chrono::system_clock, std::chrono::duration<long long, std::ratio<1, 1000000000>>> v8 = v20;
    goto LABEL_6;
  }

  if (v22)
  {
    uint64_t v9 = 5LL;
LABEL_6:
    (*(void (**)(void))(*v8 + 8 * v9))();
  }

  sub_1000BF4D8(a1, v7, (uint64_t)v20);
  char v10 = 0;
  uint64_t v11 = v4 * v5;
  while ((v20[0] != v23 || v20[1] != v24) && !*(_BYTE *)(*(void *)(a1 + 8) + 16LL))
  {
    int v12 = sub_1000BF14C(a1, a2, &v21, v11, v25);
    sub_1000BF55C(a1, &v21, (uint64_t)v18);
    for (BOOL i = v12 == 0; ; BOOL i = v14 != 0)
    {
      v10 |= i;
      if (v18[0] == v19[3] && v18[1] == v19[4]) {
        break;
      }
      if (*(_BYTE *)(*(void *)(a1 + 8) + 16LL)) {
        break;
      }
      int v14 = sub_1000BEC88(a1, a2, v19, v11, v25);
      sub_1000BC498((uint64_t)v18);
    }

    sub_1000BC378((uint64_t)v20);
  }

  sub_100016DE0(&v25);
  return v10 & 1;
}

void sub_1000BEB3C(_Unwind_Exception *a1)
{
}

void *sub_1000BEB64(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000DCE60((uint64_t)a1, a2);
  *a1 = off_10017F5C8;
  a1[45] = &off_10017F6C8;
  a1[46] = &off_10017F6F0;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_10017F5C8;
  a1[45] = off_10017F650;
  a1[46] = off_10017F678;
  return a1;
}

void sub_1000BEBE8(_Unwind_Exception *a1)
{
}

uint64_t sub_1000BEC0C(uint64_t a1)
{
  return a1;
}

void sub_1000BEC4C(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 3680);
  std::mutex::lock((std::mutex *)(a1 + 3680));
  *(_BYTE *)(a1 + 3672) = 1;
  std::condition_variable::notify_one((std::condition_variable *)(a1 + 3624));
  std::mutex::unlock(v2);
}

uint64_t sub_1000BEC88(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = a3[1];
  uint64_t v6 = *(void *)(*a3 + 56LL);
  uint64_t v7 = (*(void *)(v6 + 16 * v5 + 8) & 0x7FFFFFFFFFFFFFLL) * *(unsigned int *)(*(void *)(*a3 + 8LL) + 20LL);
  uint64_t v9 = (unint64_t *)(v6 + 16 * v5);
  if (*v9)
  {
LABEL_4:
    char v16 = 0;
    int v14 = off_100189898;
    unint64_t v15 = v9;
    uint64_t v17 = 0LL;
    (*(void (**)(void))(**(void **)(a1 + 8) + 24LL))(*(void *)(a1 + 8));
    sub_100116BAC(&v14);
    return 4294967282LL;
  }

  while (1)
  {
    unint64_t v12 = __ldaxr(v9);
    if (!v12) {
      break;
    }
    __clrex();
LABEL_10:
    if (v12) {
      goto LABEL_4;
    }
  }

  if (__stlxr(0xFFFFFFFFFFFFFFFFLL, v9)) {
    goto LABEL_10;
  }
  char v16 = 1;
  int v14 = off_100189898;
  unint64_t v15 = v9;
  uint64_t v17 = 0LL;
  uint64_t v13 = (*(void *)(*(void *)(*a3 + 56LL) + 16LL * a3[1] + 8) & 0x7FFFFFFFFFFFFFLL)
      * *(unsigned int *)(*(void *)(*a3 + 8LL) + 20LL);
  uint64_t v10 = sub_1000BEDEC(a1, a2, a3, v13, a5);
  sub_100116BAC(&v14);
  if ((v10 & 0x80000000) == 0)
  {
    atomic_store(1u, (unsigned int *)(a1 + 96));
    sub_1000BC968(a1, v13);
  }

  return v10;
}

void sub_1000BEDD8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1000BEDEC(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  if (!a4) {
    return 0LL;
  }
  unint64_t v10 = *(unsigned int *)(*(void *)(a1 + 8) + 20LL);
  uint64_t v11 = (*(uint64_t (**)(void))(**(void **)(a2 + 16) + 40LL))(*(void *)(a2 + 16));
  if (v11 - a4 >= v10) {
    uint64_t v12 = v10;
  }
  else {
    uint64_t v12 = v11 - a4;
  }
  uint64_t result = sub_1000BEE7C(*(unsigned int **)(a1 + 8), a2, a5, v12, a4);
  if ((result & 0x8000000000000000LL) == 0)
  {
    sub_1000BD2D4(a3, v14);
    return 0LL;
  }

  return result;
}

uint64_t sub_1000BEE7C(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v10 = (std::__shared_weak_count *)*((void *)sub_100118DDC() + 1);
  uint64_t v32 = a3;
  unint64_t v33 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }

  uint64_t v34 = a4;
  uint64_t v35 = a5;
  uint64_t v36 = a4;
  char v37 = 0;
  int v13 = (*(uint64_t (**)(void, uint64_t *))(**(void **)(a2 + 16) + 88LL))(*(void *)(a2 + 16), &v32);
  if (v13 != a4)
  {
    *(void *)&__int128 v27 = "di_asif::details::dir_base::move_realloc_chunk(ContextASIF &, char *, size_t, uint64_t)";
    *((void *)&v27 + 1) = 46LL;
    int v28 = 16;
    sub_1000C7728(v29, &v27);
    sub_100004E4C(&v30, (uint64_t)"Can't read for defrag", 21LL);
    std::ostream::~ostream(&v30, off_1001812B0);
    sub_1000D76A8((uint64_t)v29);
    std::ios::~ios(v31);
    if (v13 < 0) {
      int v22 = v13;
    }
    else {
      int v22 = -5;
    }
    goto LABEL_21;
  }

  uint64_t v14 = sub_1000BD544(a1, a2, 0);
  if (!v14)
  {
    a4 = -28LL;
    goto LABEL_23;
  }

  unint64_t v15 = (std::__shared_weak_count *)*((void *)sub_100118DDC() + 1);
  if (v15)
  {
    char v16 = (unint64_t *)&v15->__shared_owners_;
    do
      unint64_t v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }

  uint64_t v18 = v33;
  uint64_t v32 = a3;
  unint64_t v33 = v15;
  if (v18)
  {
    uint64_t v19 = (unint64_t *)&v18->__shared_owners_;
    do
      unint64_t v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }

  uint64_t v34 = a4;
  uint64_t v35 = v14;
  uint64_t v36 = a4;
  char v37 = 0;
  int v21 = (*(uint64_t (**)(void, uint64_t *))(**(void **)(a2 + 16) + 80LL))(*(void *)(a2 + 16), &v32);
  if (v21 != a4)
  {
    *(void *)&__int128 v27 = "di_asif::details::dir_base::move_realloc_chunk(ContextASIF &, char *, size_t, uint64_t)";
    *((void *)&v27 + 1) = 46LL;
    int v28 = 16;
    sub_1000C7810(v29, &v27);
    sub_100004E4C(&v30, (uint64_t)"Can't write table for defrag", 28LL);
    std::ostream::~ostream(&v30, off_1001814D0);
    sub_1000D7C54((uint64_t)v29);
    std::ios::~ios(v31);
    sub_1000BD7C0((unint64_t *)a1, v14, a2);
    if (v21 < 0) {
      int v22 = v21;
    }
    else {
      int v22 = -5;
    }
LABEL_21:
    a4 = -(uint64_t)-v22;
  }

LABEL_23:
  uint64_t v23 = v33;
  if (v33)
  {
    uint64_t v24 = (unint64_t *)&v33->__shared_owners_;
    do
      unint64_t v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }

  return a4;
}

      v11 += v15;
      v5 -= v15;
      if (!v5) {
        return;
      }
    }

    int v13 = v11 + v5;
LABEL_11:
    if (v13 - v11 >= v5) {
      unint64_t v15 = v5;
    }
    else {
      unint64_t v15 = v13 - v11;
    }
    sub_1000F1940((int *)&v29, 0);
    uint64_t v30 = 0uLL;
    *(void *)&__int128 v31 = v11;
    *((void *)&v31 + 1) = v15;
    uint64_t v32 = v11 - a2;
    unint64_t v33 = v15;
    unint64_t v17 = a4[1];
    uint64_t v18 = *a4 + (v17 << 6);
    if (v17 == a4[2])
    {
      sub_1000F5F2C(a4, v18, 1LL, (uint64_t)&v29, &v34);
    }

    else
    {
      *(_DWORD *)uint64_t v18 = v29;
      uint64_t v19 = v30;
      unint64_t v20 = v31;
      int v21 = v32;
      *(void *)(v18 + 56) = v33;
      *(_OWORD *)(v18 + 40) = v21;
      *(_OWORD *)(v18 + 24) = v20;
      *(_OWORD *)(v18 + _Block_object_dispose((const void *)(v2 - 120), 8) = v19;
      ++a4[1];
    }

    goto LABEL_23;
  }

void sub_1000BF108(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t sub_1000BF14C(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = a3[1];
  uint64_t v6 = *(void *)(*a3 + 56LL);
  uint64_t v7 = (*(void *)(v6 + 16 * v5 + 8) & 0x7FFFFFFFFFFFFFLL) * *(unsigned int *)(*(void *)(*a3 + 8LL) + 20LL);
  uint64_t v9 = (unint64_t *)(v6 + 16 * v5);
  if (*v9)
  {
LABEL_4:
    char v27 = 0;
    unint64_t v25 = off_100189898;
    uint64_t v26 = v9;
    uint64_t v28 = 0LL;
    (*(void (**)(void))(**(void **)(a1 + 8) + 24LL))(*(void *)(a1 + 8));
    sub_100116BAC(&v25);
    return 4294967274LL;
  }

  while (1)
  {
    unint64_t v15 = __ldaxr(v9);
    if (!v15) {
      break;
    }
    __clrex();
LABEL_10:
    if (v15) {
      goto LABEL_4;
    }
  }

  if (__stlxr(0xFFFFFFFFFFFFFFFFLL, v9)) {
    goto LABEL_10;
  }
  char v27 = 1;
  unint64_t v25 = off_100189898;
  uint64_t v26 = v9;
  uint64_t v28 = 0LL;
  uint64_t v16 = *(void *)(a1 + 8);
  unint64_t v17 = *(unsigned __int16 *)(v16 + 18);
  unint64_t v18 = ((*(void *)(*a3 + 352LL)
        + a3[1]
        / (unint64_t)(*(void *)(*(void *)(*a3 + 8LL) + 48LL) + 1LL)
        * *(void *)(*(void *)(*a3 + 8LL) + 48LL)
        * *(unsigned int *)(*(void *)(*a3 + 8LL) + 20LL))
       / v17
       - *(void *)(a1 + 352) / v17)
      / (*(void *)(v16 + 48)
       * (unint64_t)(*(_DWORD *)(v16 + 20) / v17));
  unint64_t v19 = sub_1000BD37C(a1, v18);
  sub_1000BD3EC((unint64_t *)(*(void *)(a1 + 72) + 8 * v18), v19, &v24);
  if (!v24 || *(_BYTE *)(v24 + 344)) {
    goto LABEL_14;
  }
  uint64_t v20 = *(void *)(v24 + 288);
  if (v20)
  {
    unint64_t v29 = v24;
    (*(void (**)(uint64_t, unint64_t *, unint64_t *))(*(void *)v20 + 48LL))(v20, &v29, &v24);
  }

  sub_1000BD3EC((unint64_t *)(*(void *)(a1 + 72) + 8 * v18), v19, &v29);
  sub_1000BD48C(&v24, &v29);
  sub_1000BBEA0(&v29);
  if (!v24 || *(_BYTE *)(v24 + 344))
  {
LABEL_14:
    (*(void (**)(unint64_t *__return_ptr, void, unint64_t, uint64_t))(**(void **)(a1 + 8)
                                                                                              + 32LL))( &v29,  *(void *)(a1 + 8),  v19,  1LL);
    sub_1000BD48C(&v24, &v29);
    sub_1000BBEA0(&v29);
    if (!v24 || *(_BYTE *)(v24 + 344) || (unsigned int v22 = atomic_load((unsigned int *)(v24 + 24)), v22 == 2))
    {
      if (v24 && !*(_BYTE *)(v24 + 344))
      {
        (*(void (**)(void))(**(void **)(a1 + 8) + 24LL))(*(void *)(a1 + 8));
        uint64_t v10 = 4294967248LL;
      }

      else
      {
        uint64_t v10 = 4294967274LL;
      }
    }

    else
    {
      uint64_t v7 = (*(void *)(*(void *)(*a3 + 56LL) + 16LL * a3[1] + 8) & 0x7FFFFFFFFFFFFFLL)
         * *(unsigned int *)(*(void *)(*a3 + 8LL) + 20LL);
      uint64_t v10 = sub_1000BEDEC(a1, a2, a3, v7, a5);
    }

    if (v24)
    {
      if (!*(_BYTE *)(v24 + 344))
      {
        uint64_t v23 = *(void *)(v24 + 288);
        if (v23)
        {
          unint64_t v29 = v24;
          (*(void (**)(uint64_t, unint64_t *, unint64_t *))(*(void *)v23 + 48LL))( v23,  &v29,  &v24);
        }
      }
    }

    int v21 = 1;
  }

  else
  {
    (*(void (**)(void))(**(void **)(a1 + 8) + 24LL))(*(void *)(a1 + 8));
    int v21 = 0;
    uint64_t v10 = 4294967274LL;
  }

  sub_1000BBEA0(&v24);
  sub_100116BAC(&v25);
  if (!v21) {
    return 4294967248LL;
  }
  if (!(_DWORD)v10)
  {
    atomic_store(1u, (unsigned int *)(a1 + 96));
    sub_1000BC968(a1, v7);
  }

  return v10;
}

void sub_1000BF49C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, char a10)
{
}

uint64_t sub_1000BF4D8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v5 = *(void *)(a1 + 352);
  unint64_t v6 = *(void *)(*(void *)(a1 + 8) + 80LL) + v5;
  if (v5 >= v6)
  {
    char v8 = 0;
    uint64_t result = 0LL;
  }

  else
  {
    uint64_t result = sub_1000BC30C(a1, *(void *)(a1 + 352));
    unint64_t v6 = *(void *)(*(void *)(a1 + 8) + 80LL) + *(void *)(a1 + 352);
    char v8 = 1;
  }

  *(void *)a3 = a1;
  *(void *)(a3 + _Block_object_dispose((const void *)(v2 - 120), 8) = v5;
  *(void *)(a3 + 16) = result;
  *(void *)(a3 + 24) = a2;
  *(_BYTE *)(a3 + sub_1000114F0(v6 - 32) = v8;
  *(void *)(a3 + 40) = a1;
  *(void *)(a3 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = v6;
  *(void *)(a3 + 56) = 0LL;
  *(_BYTE *)(a3 + 72) = 0;
  return result;
}

uint64_t sub_1000BF55C@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v6 = *(void *)(*a2 + 352LL)
     + a2[1]
     / (unint64_t)(*(void *)(*(void *)(*a2 + 8LL) + 48LL) + 1LL)
     * *(void *)(*(void *)(*a2 + 8LL) + 48LL)
     * *(unsigned int *)(*(void *)(*a2 + 8LL) + 20LL);
  uint64_t v7 = *(void *)(a1 + 8);
  unint64_t v8 = *(void *)(a1 + 352) + *(void *)(v7 + 80);
  if (v6 >= v8)
  {
    uint64_t v12 = 0LL;
    unint64_t v11 = 0LL;
    char v17 = 0;
    unint64_t v16 = *(void *)(*a2 + 352LL)
        + a2[1]
        / (unint64_t)(*(void *)(*(void *)(*a2 + 8LL) + 48LL) + 1LL)
        * *(void *)(*(void *)(*a2 + 8LL) + 48LL)
        * *(unsigned int *)(*(void *)(*a2 + 8LL) + 20LL);
  }

  else
  {
    uint64_t v10 = sub_1000BC43C(a1, v6);
    unint64_t v3 = a2;
    unint64_t v11 = v10 & 0xFFFFFFFFFFFFFF00LL;
    uint64_t v12 = v10;
    uint64_t v13 = *(void *)(*a2 + 8LL);
    uint64_t v14 = *(void *)(v13 + 48);
    uint64_t v15 = *(unsigned int *)(v13 + 20);
    uint64_t v7 = *(void *)(a1 + 8);
    unint64_t v16 = *(void *)(*a2 + 352LL) + a2[1] / (unint64_t)(v14 + 1) * v14 * v15;
    unint64_t v8 = *(void *)(a1 + 352) + *(void *)(v7 + 80);
    char v17 = 1;
  }

  unsigned int v18 = *(unsigned __int16 *)(v7 + 18);
  unsigned int v19 = *(_DWORD *)(v7 + 20) / v18;
  uint64_t v20 = *(void *)(v7 + 48);
  unint64_t v21 = v16 + v18 * (unint64_t)v19 * v20;
  if (v21 >= v8)
  {
    char v23 = 0;
    uint64_t result = 0LL;
  }

  else
  {
    uint64_t result = sub_1000BC43C(a1, v16 + v18 * (unint64_t)v19 * v20);
    char v23 = 1;
  }

  *(void *)a3 = a1;
  *(void *)(a3 + _Block_object_dispose((const void *)(v2 - 120), 8) = v6;
  *(void *)(a3 + 16) = v11 | v12;
  *(void *)(a3 + 24) = v3;
  *(_BYTE *)(a3 + sub_1000114F0(v6 - 32) = v17;
  *(void *)(a3 + 40) = a1;
  *(void *)(a3 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = v21;
  *(void *)(a3 + 56) = result;
  *(void *)(a3 + 64) = a2;
  *(_BYTE *)(a3 + 72) = v23;
  return result;
}

uint64_t sub_1000BF690(uint64_t a1)
{
  *(void *)a1 = off_10017ECA0;
  uint64_t v2 = (std::mutex *)(a1 + 3680);
  std::mutex::lock((std::mutex *)(a1 + 3680));
  *(_BYTE *)(a1 + 16) = 1;
  std::condition_variable::notify_one((std::condition_variable *)(a1 + 3624));
  std::mutex::unlock(v2);
  std::thread::join((std::thread *)(a1 + 3616));
  std::mutex::~mutex((std::mutex *)(a1 + 3792));
  sub_1000BBD1C((void *)(a1 + 3744));
  std::mutex::~mutex(v2);
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 3624));
  std::thread::~thread((std::thread *)(a1 + 3616));
  std::mutex::~mutex((std::mutex *)(a1 + 3528));
  sub_1000DD910(a1 + 2080);
  sub_1000DCEDC(a1 + 280);
  sub_100026AC4(a1 + 248, *(void **)(a1 + 256));
  std::mutex::~mutex((std::mutex *)(a1 + 184));
  unint64_t v3 = *(void **)(a1 + 152);
  if (v3)
  {
    *(void *)(a1 + 160) = v3;
    operator delete(v3);
  }

  uint64_t v4 = *(void **)(a1 + 128);
  if (v4)
  {
    *(void *)(a1 + 136) = v4;
    operator delete(v4);
  }

  unint64_t v5 = *(void **)(a1 + 112);
  if (v5 == (void *)(a1 + 88))
  {
    uint64_t v6 = 4LL;
    unint64_t v5 = (void *)(a1 + 88);
    goto LABEL_9;
  }

  if (v5)
  {
    uint64_t v6 = 5LL;
LABEL_9:
    (*(void (**)(void))(*v5 + 8 * v6))();
  }

  return a1;
}

uint64_t sub_1000BF7A0(uint64_t a1)
{
  return a1;
}

void sub_1000BF7D8(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000BF690(a1);
  operator delete(v1);
}

__n128 sub_1000BF7EC@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  __int128 v8 = v10[3];
  *(_OWORD *)(a4 + sub_1000114F0(v6 - 32) = v10[2];
  *(_OWORD *)(a4 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = v8;
  *(_OWORD *)(a4 + 64) = v10[4];
  __n128 result = (__n128)v10[1];
  *(_OWORD *)a4 = v10[0];
  *(__n128 *)(a4 + 16) = result;
  return result;
}

void sub_1000BF87C(void *a1, uint64_t a2, uint64_t a3)
{
  __int128 v43 = v39;
  if ((*(void *)(*(void *)(v39 + 56) + 16LL * *((void *)&v39 + 1) + 8) & 0x7FFFFFFFFFFFFFLL)
     * *(unsigned int *)(*(void *)(v39 + 8) + 20LL))
  {
    sub_1000BF55C((uint64_t)a1, &v43, (uint64_t)&v39);
    __int128 v36 = v39;
    __int128 v37 = v40;
    uint64_t v38 = v41;
    while (v36 != v42)
    {
      unint64_t v5 = atomic_load((unint64_t *)(*(void *)(v37 + 56) + 16LL * *((void *)&v37 + 1) + 8));
      if (v5 >> 62 == 3) {
        return;
      }
      sub_1000BC498((uint64_t)&v36);
    }

    if ((*(void *)(*(void *)(v43 + 56) + 16LL * *((void *)&v43 + 1) + 8) & 0x7FFFFFFFFFFFFFLL)
       * *(unsigned int *)(*(void *)(v43 + 8) + 20LL))
    {
      __int128 v36 = v39;
      if (v38 == v41)
      {
        if ((_BYTE)v38) {
          *((void *)&v37 + 1) = *((void *)&v40 + 1);
        }
      }

      else if ((_BYTE)v38)
      {
        LOBYTE(v3_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
      }

      else
      {
        __int128 v37 = v40;
        LOBYTE(v3_Block_object_dispose((const void *)(v2 - 120), 8) = 1;
      }

      uint64_t v33 = 0LL;
      unint64_t v34 = 0LL;
      unint64_t v35 = 0LL;
      while (v36 != v42)
      {
        uint64_t v6 = (unint64_t *)(*(void *)(v37 + 56) + 16LL * *((void *)&v37 + 1));
        do
        {
          if (!*v6)
          {
            do
            {
              unint64_t v7 = __ldaxr(v6);
              if (v7)
              {
                __clrex();
              }

              else if (!__stlxr(0xFFFFFFFFFFFFFFFFLL, v6))
              {
                char v8 = 1;
                goto LABEL_25;
              }
            }

            while (!v7);
          }
        }

        while ((sub_1000D6EAC(v6, 1) & 1) != 0);
        char v8 = 0;
LABEL_25:
        char v31 = v8;
        unint64_t v29 = (void **)off_100189898;
        uint64_t v30 = v6;
        uint64_t v32 = 0LL;
        uint64_t v9 = (void *)v34;
        if (v34 >= v35)
        {
          uint64_t v10 = sub_1000D0974(&v33, (uint64_t)&v29);
        }

        else
        {
          sub_100116A14(v34, (uint64_t)&v29);
          void *v9 = off_100189898;
          v9[3] = v32;
          uint64_t v10 = (uint64_t)(v9 + 4);
        }

        unint64_t v34 = v10;
        sub_100116BAC(&v29);
        unint64_t v11 = atomic_load((unint64_t *)(*(void *)(v37 + 56) + 16LL * *((void *)&v37 + 1) + 8));
        if (v11 >> 62 == 3) {
          goto LABEL_54;
        }
        sub_1000BC498((uint64_t)&v36);
      }

      uint64_t v12 = (unint64_t *)(*(void *)(v43 + 56) + 16LL * *((void *)&v43 + 1));
      if ((v12[1] & 0x7FFFFFFFFFFFFFLL) * *(unsigned int *)(*(void *)(v43 + 8) + 20LL))
      {
        do
        {
          if (!*v12)
          {
            do
            {
              unint64_t v13 = __ldaxr(v12);
              if (v13)
              {
                __clrex();
              }

              else if (!__stlxr(0xFFFFFFFFFFFFFFFFLL, v12))
              {
                char v14 = 1;
                goto LABEL_40;
              }
            }

            while (!v13);
          }
        }

        while ((sub_1000D6EAC(v12, 1) & 1) != 0);
        char v14 = 0;
LABEL_40:
        char v31 = v14;
        unint64_t v29 = (void **)off_100189898;
        uint64_t v30 = v12;
        uint64_t v32 = 0LL;
        __int128 v15 = v43;
        uint64_t v16 = *(void *)(v43 + 8);
        uint64_t v17 = *(unsigned int *)(v16 + 20);
        if ((*(void *)(*(void *)(v43 + 56) + 16LL * *((void *)&v43 + 1) + 8) & 0x7FFFFFFFFFFFFFLL) * v17)
        {
          sub_1000BCED0( (uint64_t)a1,  a2,  (*(void *)(v43 + 352)
           + *(void *)(v16 + 48) * v17 * (*((void *)&v43 + 1) / (unint64_t)(*(void *)(v16 + 48) + 1LL)))
          / *(unsigned __int16 *)(a1[1] + 18LL),
            1,
            1LL,
            &v28);
          if (v28 && !*(_BYTE *)(v28 + 344))
          {
            if (*(_BYTE *)(v28 + 224)) {
              uint64_t v18 = v28 + 40;
            }
            else {
              uint64_t v18 = 0LL;
            }
            uint64_t v19 = *(void *)(v18 + 16);
            *(void *)(v18 + 16) = 0LL;
            *(void *)(v18 + 24) = v19;
            *(_BYTE *)(v18 + sub_1000114F0(v4 - 112) = 0;
            if (v28)
            {
              uint64_t v20 = *(void *)(v28 + 288);
              if (v20)
              {
                unint64_t v44 = v28;
                (*(void (**)(uint64_t, unint64_t *, unint64_t *))(*(void *)v20 + 48LL))( v20,  &v44,  &v28);
              }
            }

            uint64_t v21 = a1[1];
            unint64_t v22 = *(unsigned __int16 *)(v21 + 18);
            unint64_t v23 = (*(void *)(v15 + 352)
                 + *((void *)&v15 + 1)
                 / (unint64_t)(*(void *)(*(void *)(v15 + 8) + 48LL) + 1LL)
                 * *(void *)(*(void *)(v15 + 8) + 48LL)
                 * *(unsigned int *)(*(void *)(v15 + 8) + 20LL))
                / v22
                - a1[44] / v22;
            unint64_t v24 = *(void *)(v21 + 48) * (*(_DWORD *)(v21 + 20) / v22);
            unint64_t v44 = 0LL;
            uint64_t v25 = a1[9];
            unint64_t v26 = v23 / v24;
            do
              unint64_t v27 = __ldaxr(&v44);
            while (__stlxr(0LL, &v44));
            atomic_store(v27, (unint64_t *)(v25 + 8 * v26));
          }

          sub_1000BBEA0(&v28);
        }

        sub_100116BAC(&v29);
      }

void sub_1000BFCC4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9, void **a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  a10 = (void **)&a14;
  sub_1000D0BF0(&a10);
  _Unwind_Resume(a1);
}

void *sub_1000BFD20(void *a1, void *a2)
{
  unint64_t v3 = sub_100004E4C(a1, (uint64_t)"table entry data@", 17LL);
  uint64_t v4 = (void *)std::ostream::operator<<( v3,  *(void *)(*a2 + 352LL)
                 + (*(void *)(*(void *)(*a2 + 8LL) + 48LL) + *(void *)(*(void *)(*a2 + 8LL) + 48LL) * a2[1])
  unint64_t v5 = sub_100004E4C(v4, (uint64_t)" = offset = ", 12LL);
  uint64_t v6 = (void *)std::ostream::operator<<( v5,  (*(void *)(*(void *)(*a2 + 56LL) + 16LL * a2[1] + 8) & 0x7FFFFFFFFFFFFFLL)
                 * *(unsigned int *)(*(void *)(*a2 + 8LL) + 20LL));
  unint64_t v7 = sub_100004E4C(v6, (uint64_t)", flags = ", 10LL);
  unint64_t v8 = atomic_load((unint64_t *)(*(void *)(*a2 + 56LL) + 16LL * a2[1] + 8));
  int v10 = v8 >> 62;
  return sub_1000C9DCC(v7, &v10);
}

__n128 sub_1000BFDE4@<Q0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _OWORD *a5@<X8>)
{
  uint64_t v71 = (std::mutex *)(a1 + 104);
  std::mutex::lock((std::mutex *)(a1 + 104));
  sub_1000BE06C( a3,  a4,  *(unsigned int *)(*(void *)(a1 + 8) + 20LL),  *(unsigned __int16 *)(*(void *)(a1 + 8) + 18LL),  *(void *)(a1 + 352),  *(void *)(*(void *)(a1 + 8) + 80LL) + *(void *)(a1 + 352),  (uint64_t)v84);
  int v9 = 0;
  LOBYTE(v82) = 0;
  char v83 = 0;
  int v72 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 8) + 24LL) + 184LL);
LABEL_2:
  while (*(void *)v84 != v87
       || *(_OWORD *)&v84[8] != v88
       || *(void *)&v84[16] != *(void *)v84 + 16LL * *(void *)&v84[8]
       && (*(_OWORD *)&v85[8] != v89 || *(void *)&v85[24] != v90))
  {
    uint64_t v10 = *(void *)&v84[24];
    uint64_t v11 = *(void *)v85;
    *(void *)&v85[8] += *(void *)&v85[24] * *(void *)v85;
    *(void *)&v84[24] = sub_1000BC1B4((uint64_t *)v84);
    *(void *)uint64_t v85 = v12;
    unint64_t v13 = v10 * *(unsigned __int16 *)(*(void *)(a1 + 8) + 18LL);
    uint64_t v14 = sub_1000BC43C(a1, v13);
    uint64_t v16 = (void *)v14;
    uint64_t v17 = v15;
    *(void *)&__int128 v81 = v14;
    *((void *)&v81 + 1) = v15;
    if (v83)
    {
      uint64_t v18 = v82;
      if (*(void *)(v14 + 352) != *(void *)(v82 + 352) || v15 != *((void *)&v82 + 1))
      {
        v9 |= sub_1000BCA84(a1, a2, &v82);
        uint64_t v20 = *(void *)(v18 + 8);
        unint64_t v21 = (*(void *)(v18 + 352)
             + (*(void *)(v20 + 48) + *(void *)(v20 + 48) * *((void *)&v82 + 1))
             / (unint64_t)(*(void *)(v20 + 48) + 1LL)
        uint64_t v22 = *(void *)(a1 + 8);
        uint64_t v23 = *(void *)(v22 + 48);
        unsigned int v24 = *(_DWORD *)(v22 + 20);
        unint64_t v25 = *(unsigned __int16 *)(v22 + 18);
        unint64_t v26 = v23 * (v24 / v25);
        unint64_t v27 = *(void *)(a1 + 352) / v25;
        ++v23;
        uint64_t v28 = v23 + v23 * ((v21 - v27) / v26);
        uint64_t v29 = v16[1];
        if (v28 != v23
                  + v23
                  * (((v16[44]
                     + (*(void *)(v29 + 48) + *(void *)(v29 + 48) * v17)
                     / (unint64_t)(*(void *)(v29 + 48) + 1LL)
                     * *(unsigned int *)(v29 + 20))
                    / *(unsigned __int16 *)(v29 + 18)
                    - v27)
                   / v26)
          && (v9 & 1) != 0)
        {
          sub_1000BF87C((void *)a1, a2, v28 - 1);
          int v9 = 0;
        }
      }

      *((void *)&v82 + 1) = v17;
    }

    else
    {
      __int128 v82 = v81;
      char v83 = 1;
    }

    unint64_t v30 = atomic_load((unint64_t *)(v16[7] + 16 * v17 + 8));
    unint64_t v31 = v30 >> 62;
    if (v30 >> 62 != 2)
    {
      uint64_t v32 = *(void *)(v81 + 8);
      uint64_t v33 = *(void *)(v32 + 48);
      uint64_t v34 = *(unsigned int *)(v32 + 20);
      if (*(void *)(v81 + 352) + (v33 + v33 * *((void *)&v81 + 1)) / (unint64_t)(v33 + 1) * v34 == v13
        && v11 * *(unsigned __int16 *)(*(void *)(a1 + 8) + 18LL) == v34)
      {
        unint64_t v35 = (unint64_t *)(*(void *)(v81 + 56) + 16LL * *((void *)&v81 + 1));
        while (*v35)
        {
LABEL_28:
          if ((sub_1000D6EAC(v35, 1) & 1) == 0)
          {
            char v79 = 0;
            int v78 = v35;
            int v77 = off_100189898;
            uint64_t v80 = 0LL;
            *(void *)&__int128 v73 = "di_asif::details::table::unmap(ContextASIF &, const unmap_extent_t *, size_t)";
            *((void *)&v73 + 1) = 30LL;
            int v74 = 16;
            sub_1000C0788(v75, &v73);
            sub_100004E4C(v76, (uint64_t)"Couldn't lock entry ", 20LL);
            sub_1000BFD20(v76, &v81);
            sub_1000C0830((uint64_t)v75);
            exception = __cxa_allocate_exception(0x40uLL);
            void *exception = &off_100189E78;
            char v65 = std::generic_category();
            exception[1] = 4294967282LL;
            exception[2] = v65;
            *((_BYTE *)exception + 24) = 0;
            *((_BYTE *)exception + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
            exception[7] = "Couldn't lock entry";
          }
        }

        while (1)
        {
          unint64_t v36 = __ldaxr(v35);
          if (!v36) {
            break;
          }
          __clrex();
LABEL_27:
          if (v36) {
            goto LABEL_28;
          }
        }

        if (__stlxr(0xFFFFFFFFFFFFFFFFLL, v35)) {
          goto LABEL_27;
        }
        char v79 = 1;
        int v78 = v35;
        int v77 = off_100189898;
        uint64_t v80 = 0LL;
        unint64_t v42 = atomic_load((unint64_t *)(*(void *)(v81 + 56) + 16LL * *((void *)&v81 + 1) + 8));
        if ((_DWORD)v31 != 1 && (v42 & 0xC000000000000000LL) == 0x4000000000000000LL) {
          goto LABEL_49;
        }
        __int128 v43 = (unint64_t *)(*(void *)(v81 + 56) + 16LL * *((void *)&v81 + 1) + 8);
        unint64_t v44 = *v43;
        unint64_t v45 = __ldaxr(v43);
        if (v45 == v44)
        {
          if (!__stlxr(v44 & 0x3FFFFFFFFFFFFFFFLL | 0x8000000000000000LL, v43)) {
            goto LABEL_56;
          }
        }

        else
        {
          __clrex();
        }

        do
        {
          while (1)
          {
            unint64_t v44 = v45;
            unint64_t v45 = __ldaxr(v43);
            if (v45 == v44) {
              break;
            }
            __clrex();
          }
        }

        while (__stlxr(v44 & 0x3FFFFFFFFFFFFFFFLL | 0x8000000000000000LL, v43));
LABEL_56:
        BOOL v48 = v44 >> 62 == 3;
        unint64_t v49 = (unint64_t *)(*(void *)(v81 + 56) + 16LL * *((void *)&v81 + 1) + 8);
        unint64_t v50 = *v49;
        uint64_t v51 = *(unsigned int *)(*(void *)(v81 + 8) + 20LL);
        if ((_DWORD)v51)
        {
          do
            unint64_t v52 = __ldxr(v49);
          while (__stxr(v52 & 0xFF80000000000000LL, v49));
          goto LABEL_69;
        }

        unint64_t v53 = *v49;
        unint64_t v54 = __ldxr(v49);
        if (v54 != v53)
        {
          __clrex();
LABEL_63:
          while (1)
          {
            unint64_t v55 = __ldxr(v49);
            if (v55 != v54) {
              break;
            }
            if (__stxr(v54 & 0xFF80000000000000LL, v49)) {
              goto LABEL_67;
            }
            int v56 = 1;
LABEL_68:
            unint64_t v54 = v55;
            if (v56) {
              goto LABEL_69;
            }
          }

          __clrex();
LABEL_67:
          int v56 = 0;
          goto LABEL_68;
        }

        if (__stxr(v53 & 0xFF80000000000000LL, v49)) {
          goto LABEL_63;
        }
LABEL_69:
        v9 |= v48;
        uint64_t v57 = (v50 & 0x7FFFFFFFFFFFFFLL) * v51;
        atomic_store(1u, (unsigned int *)(a1 + 96));
        sub_100116BAC(&v77);
        if (v57) {
          sub_1000BC968(a1, v57);
        }
      }

      else
      {
        if ((v30 & 0x4000000000000000LL) == 0)
        {
          if (v72) {
            continue;
          }
          __int128 v37 = (unint64_t *)(*(void *)(v81 + 56) + 16LL * *((void *)&v81 + 1));
          while (*v37)
          {
LABEL_40:
            if ((sub_1000D6EAC(v37, 1) & 1) == 0)
            {
              char v79 = 0;
              int v78 = v37;
              int v77 = off_100189898;
              uint64_t v80 = 0LL;
              *(void *)&__int128 v73 = "di_asif::details::table::unmap(ContextASIF &, const unmap_extent_t *, size_t)";
              *((void *)&v73 + 1) = 30LL;
              int v74 = 16;
              sub_1000C0958(v75, &v73);
              sub_100004E4C(v76, (uint64_t)"Couldn't exclusively lock entry ", 32LL);
              sub_1000BFD20(v76, &v81);
              sub_1000C0A00((uint64_t)v75);
              v66 = __cxa_allocate_exception(0x40uLL);
              void *v66 = &off_100189E78;
              uint64_t v67 = std::generic_category();
              v66[1] = 4294967282LL;
              v66[2] = v67;
              *((_BYTE *)v66 + 24) = 0;
              *((_BYTE *)v66 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
              v66[7] = "Couldn't lock entry";
            }
          }

          while (1)
          {
            unint64_t v38 = __ldaxr(v37);
            if (v38)
            {
              __clrex();
            }

            else if (!__stlxr(0xFFFFFFFFFFFFFFFFLL, v37))
            {
              char v79 = 1;
              int v78 = v37;
              int v77 = off_100189898;
              uint64_t v80 = 0LL;
              unint64_t v46 = atomic_load((unint64_t *)(*(void *)(v81 + 56) + 16LL * *((void *)&v81 + 1) + 8));
              uint64_t v47 = *(unsigned __int16 *)(*(void *)(a1 + 8) + 18LL);
              *(void *)unint64_t v75 = sub_1000C67C8(a1, v10 * v47, v11 * v47);
              sub_1000BD8C4( a1,  a2,  &v81,  v75,  2u,  (unint64_t)&_mh_execute_header & 0xFFFFFFFFFFFFFFFCLL | (v46 >> 62));
LABEL_49:
              sub_100116BAC(&v77);
              goto LABEL_2;
            }

            if (v38) {
              goto LABEL_40;
            }
          }
        }

        __int128 v39 = (unint64_t *)(*(void *)(v81 + 56) + 16LL * *((void *)&v81 + 1));
        BOOL v40 = sub_1000D6E20(v39);
        int v77 = off_100189878;
        int v78 = v39;
        char v79 = v40;
        if (!v40)
        {
          *(void *)&__int128 v73 = "di_asif::details::table::unmap(ContextASIF &, const unmap_extent_t *, size_t)";
          *((void *)&v73 + 1) = 30LL;
          int v74 = 16;
          sub_1000C0870(v75, &v73);
          sub_100004E4C(v76, (uint64_t)"Couldn't lock entry ", 20LL);
          sub_1000BFD20(v76, &v81);
          sub_1000C0918((uint64_t)v75);
          unint64_t v68 = __cxa_allocate_exception(0x40uLL);
          *unint64_t v68 = &off_100189E78;
          int v69 = std::generic_category();
          v68[1] = 4294967282LL;
          v68[2] = v69;
          *((_BYTE *)v68 + 24) = 0;
          *((_BYTE *)v68 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
          v68[7] = "Couldn't lock entry";
        }

        uint64_t v41 = *(unsigned __int16 *)(*(void *)(a1 + 8) + 18LL);
        *(void *)unint64_t v75 = sub_1000C67C8(a1, v10 * v41, v11 * v41);
        sub_1000BD8C4(a1, a2, &v81, v75, 2u, v31 | (unint64_t)&_mh_execute_header);
        sub_100116A88(&v77);
      }
    }
  }

  if (v83 && ((sub_1000BCA84(a1, a2, &v82) | v9) & 1) != 0)
  {
    uint64_t v58 = *(void *)(v82 + 8);
    uint64_t v59 = *(void *)(a1 + 8);
    uint64_t v60 = *(void *)(v59 + 48);
    sub_1000BF87C( (void *)a1,  a2,  v60 + (v60 + 1)
    * (((*(void *)(v82 + 352)
       + (*(void *)(v58 + 48) + *(void *)(v58 + 48) * *((void *)&v82 + 1))
       / (unint64_t)(*(void *)(v58 + 48) + 1LL)
       * *(unsigned int *)(v58 + 20))
      / *(unsigned __int16 *)(v58 + 18)
      - *(void *)(a1 + 352) / (unint64_t)*(unsigned __int16 *)(v59 + 18))
     / (v60
      * (unint64_t)(*(_DWORD *)(v59 + 20) / *(unsigned __int16 *)(v59 + 18)))));
  }

  __int128 v61 = *(_OWORD *)&v85[16];
  a5[2] = *(_OWORD *)v85;
  a5[3] = v61;
  a5[4] = v86;
  __int128 v62 = *(_OWORD *)&v84[16];
  *a5 = *(_OWORD *)v84;
  a5[1] = v62;
  std::mutex::unlock(v71);
  return result;
}

void sub_1000C06F0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::mutex *a11)
{
}

void *sub_1000C0788(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000DDD94((uint64_t)a1, a2);
  *a1 = off_10017F868;
  a1[45] = &off_10017F968;
  a1[46] = &off_10017F990;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_10017F868;
  a1[45] = off_10017F8F0;
  a1[46] = off_10017F918;
  return a1;
}

void sub_1000C080C(_Unwind_Exception *a1)
{
}

uint64_t sub_1000C0830(uint64_t a1)
{
  return a1;
}

void *sub_1000C0870(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000DDE10((uint64_t)a1, a2);
  *a1 = off_10017FA88;
  a1[45] = &off_10017FB88;
  a1[46] = &off_10017FBB0;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_10017FA88;
  a1[45] = off_10017FB10;
  a1[46] = off_10017FB38;
  return a1;
}

void sub_1000C08F4(_Unwind_Exception *a1)
{
}

uint64_t sub_1000C0918(uint64_t a1)
{
  return a1;
}

void *sub_1000C0958(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000DDE8C((uint64_t)a1, a2);
  *a1 = off_10017FCA8;
  a1[45] = &off_10017FDA8;
  a1[46] = &off_10017FDD0;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_10017FCA8;
  a1[45] = off_10017FD30;
  a1[46] = off_10017FD58;
  return a1;
}

void sub_1000C09DC(_Unwind_Exception *a1)
{
}

uint64_t sub_1000C0A00(uint64_t a1)
{
  return a1;
}

BOOL sub_1000C0A40(uint64_t a1, uint64_t a2)
{
  __int128 v69 = 0u;
  __int128 v70 = 0u;
  __int128 v68 = 0u;
  uint64_t v2 = (unsigned int *)(a1 + 96);
  do
    unsigned int v3 = __ldaxr(v2);
  while (__stlxr(0, v2));
  unsigned int v57 = v3;
  std::mutex::lock((std::mutex *)(a1 + 280));
  __int128 v4 = v68;
  __int128 v5 = v69;
  __int128 v6 = *(_OWORD *)(a1 + 248);
  __int128 v7 = *(_OWORD *)(a1 + 264);
  __int128 v68 = *(_OWORD *)(a1 + 232);
  __int128 v69 = v6;
  *(_OWORD *)(a1 + 2sub_1000114F0(v6 - 32) = v4;
  *(_OWORD *)(a1 + 24_Block_object_dispose((const void *)(v2 - 120), 8) = v5;
  __int128 v8 = v70;
  __int128 v70 = v7;
  *(_OWORD *)(a1 + 264) = v8;
  std::mutex::unlock((std::mutex *)(a1 + 280));
  size_t v9 = ((unint64_t)*(unsigned __int16 *)(*(void *)(a1 + 8) + 18LL)
      + 8LL * *(void *)(*(void *)(a1 + 8) + 56LL)
      - 1)
  uint64_t v10 = valloc(v9);
  if (!v10)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    unint64_t v55 = std::bad_alloc::bad_alloc(exception);
  }

  v73[0] = &off_10017F7E0;
  unint64_t v75 = (unint64_t)v73;
  uint64_t v78 = (uint64_t)v10;
  sub_1000172D0((uint64_t)&v79, (uint64_t)v73);
  uint64_t v11 = (void *)v75;
  if ((void *)v75 == v73)
  {
    uint64_t v12 = 4LL;
    uint64_t v11 = v73;
    goto LABEL_8;
  }

  if (v75)
  {
    uint64_t v12 = 5LL;
LABEL_8:
    (*(void (**)(void))(*v11 + 8 * v12))();
  }

  uint64_t v13 = v78;
  std::mutex::lock((std::mutex *)(a1 + 168));
  sub_1000BF4D8(a1, v14, (uint64_t)v73);
  uint64_t v15 = 0LL;
  size_t v16 = v13 + v9;
  uint64_t v67 = *(void *)(a1 + 344);
  char v66 = 0;
  *(void *)&__int128 v64 = a2;
  *((void *)&v64 + 1) = &v67;
  *(void *)&__int128 v65 = v13;
  *((void *)&v65 + 1) = &v66;
  uint64_t v17 = (void *)v13;
  while (v73[0] != v76 || v73[1] != v77)
  {
    uint64_t v18 = (unint64_t *)(v74[7] + 16 * v75 + 8);
    do
      unint64_t v19 = __ldaxr(v18);
    while (__stlxr(v19 & 0x7FFFFFFFFFFFFFFFLL, v18));
    if ((v19 & 0x8000000000000000LL) != 0)
    {
      sub_1000BCED0( a1,  a2,  (v74[44] + v75 / (*(void *)(v74[1] + 48LL) + 1LL) * *(void *)(v74[1] + 48LL) * *(unsigned int *)(v74[1] + 20LL))
      / *(unsigned __int16 *)(*(void *)(a1 + 8) + 18LL),
        0,
        0LL,
        v59);
      if (v59[0] && !*(_BYTE *)(v59[0] + 344))
      {
        if (*(_BYTE *)(v59[0] + 224)) {
          uint64_t v20 = v59[0] + 40;
        }
        else {
          uint64_t v20 = 0LL;
        }
        int v21 = sub_1000C148C(v20, a2, a1);
        if (v21)
        {
          sub_10009C63C(a2);
          unint64_t v50 = __cxa_allocate_exception(0x40uLL);
          uint64_t v51 = v50;
          if (v21 < 0) {
            uint64_t v52 = v21;
          }
          else {
            uint64_t v52 = -v21;
          }
          void *v50 = &off_100189E78;
          unint64_t v53 = std::generic_category();
          v51[1] = v52;
          v51[2] = v53;
          *((_BYTE *)v51 + 24) = 0;
          *((_BYTE *)v51 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
          v51[7] = "Can't flush asif, bitmap flush failed";
        }

        char v66 = 1;
      }

      sub_1000BBEA0(v59);
    }

    uint64_t v22 = (unint64_t *)(v74[7] + 16 * v75);
    while (*v22)
    {
LABEL_31:
      if ((sub_1000D6EAC(v22, 1) & 1) == 0)
      {
        char v24 = 0;
        goto LABEL_33;
      }
    }

    while (1)
    {
      unint64_t v23 = __ldaxr(v22);
      if (!v23) {
        break;
      }
      __clrex();
LABEL_30:
      if (v23) {
        goto LABEL_31;
      }
    }

    if (__stlxr(0xFFFFFFFFFFFFFFFFLL, v22)) {
      goto LABEL_30;
    }
    char v24 = 1;
LABEL_33:
    char v62 = v24;
    v61[0] = off_100189898;
    v61[1] = v22;
    uint64_t v63 = 0LL;
    unint64_t v25 = (unint64_t *)(v74[7] + 16 * v75 + 8);
    do
      unint64_t v26 = __ldaxr(v25);
    while (__stlxr(v26 & 0x7FFFFFFFFFFFFFFFLL, v25));
    sub_1000C1500(&v74);
    if ((v26 & 0x8000000000000000LL) != 0)
    {
      sub_1000BCED0( a1,  a2,  (v74[44] + v75 / (*(void *)(v74[1] + 48LL) + 1LL) * *(void *)(v74[1] + 48LL) * *(unsigned int *)(v74[1] + 20LL))
      / *(unsigned __int16 *)(*(void *)(a1 + 8) + 18LL),
        1,
        0LL,
        v59);
      if (v59[0] && !*(_BYTE *)(v59[0] + 344))
      {
        if (*(_BYTE *)(v59[0] + 224)) {
          uint64_t v27 = v59[0] + 40;
        }
        else {
          uint64_t v27 = 0LL;
        }
        int v28 = sub_1000C148C(v27, a2, a1);
        if (v28)
        {
          sub_10009C63C(a2);
          unint64_t v46 = __cxa_allocate_exception(0x40uLL);
          uint64_t v47 = v46;
          if (v28 < 0) {
            uint64_t v48 = v28;
          }
          else {
            uint64_t v48 = -v28;
          }
          void *v46 = &off_100189E78;
          unint64_t v49 = std::generic_category();
          v47[1] = v48;
          v47[2] = v49;
          *((_BYTE *)v47 + 24) = 0;
          *((_BYTE *)v47 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
          v47[7] = "Can't flush asif, bitmap flush failed";
        }

        char v66 = 1;
      }

      sub_1000BBEA0(v59);
    }

    ++v15;
    if (!v57)
    {
      if (v17 != (void *)v13) {
        sub_1000C15F0((uint64_t)&v64, (uint64_t)v17);
      }
      uint64_t v67 = *(void *)(a1 + 344) + 8 * (v15 + v15 * *(void *)(*(void *)(a1 + 8) + 48LL));
      goto LABEL_66;
    }

    sub_1000BF55C(a1, &v74, (uint64_t)v59);
    while (2)
    {
      if (v59[0] != v60[3] || v59[1] != v60[4])
      {
        sub_1000C17B4(v60);
        unint64_t v29 = atomic_load((unint64_t *)(*(void *)(v60[0] + 56LL) + 16LL * v60[1] + 8));
        *v17++ = bswap64(v29);
        unint64_t v30 = operator new(0x28uLL);
        *(void *)unint64_t v30 = &off_100182350;
        __int128 v31 = v65;
        *(_OWORD *)(v30 + _Block_object_dispose((const void *)(v2 - 120), 8) = v64;
        *(_OWORD *)(v30 + 24) = v31;
        int v72 = v30;
        sub_1000C15F0((uint64_t)(v30 + 8), (uint64_t)v17);
        unint64_t v30 = v72;
        uint64_t v17 = (void *)v13;
        if (v72 != v71)
        {
          if (v72)
          {
            uint64_t v17 = (void *)v13;
LABEL_52:
            uint64_t v32 = 5LL;
LABEL_54:
            (*(void (**)(void))(*(void *)v30 + 8 * v32))();
          }

          sub_1000BC498((uint64_t)v59);
          continue;
        }

        unint64_t v30 = v71;
        uint64_t v32 = 4LL;
        goto LABEL_54;
      }

      break;
    }

    unint64_t v33 = atomic_load((unint64_t *)(v74[7] + 16 * v75 + 8));
    *v17++ = bswap64(v33);
    uint64_t v34 = operator new(0x28uLL);
    *(void *)uint64_t v34 = &off_100182350;
    __int128 v35 = v65;
    *(_OWORD *)(v34 + _Block_object_dispose((const void *)(v2 - 120), 8) = v64;
    *(_OWORD *)(v34 + 24) = v35;
    int v72 = v34;
    sub_1000C15F0((uint64_t)(v34 + 8), (uint64_t)v17);
    uint64_t v34 = v72;
    uint64_t v17 = (void *)v13;
    if (v72 == v71)
    {
      uint64_t v34 = v71;
      uint64_t v36 = 4LL;
      goto LABEL_65;
    }

    if (v72)
    {
      uint64_t v17 = (void *)v13;
LABEL_60:
      uint64_t v36 = 5LL;
LABEL_65:
      (*(void (**)(void))(*(void *)v34 + 8 * v36))();
    }

LABEL_66:
    sub_100116BAC(v61);
    sub_1000BC378((uint64_t)v73);
  }

  if (v17 != (void *)v13)
  {
    unint64_t v37 = *(unsigned __int16 *)(*(void *)(a1 + 8) + 18LL);
    size_t v38 = v37 + ((unint64_t)v17 - v13) / v37 * v37 - ((void)v17 - v13);
    bzero(v17, v38);
    sub_1000C15F0((uint64_t)&v64, (uint64_t)v17 + v38);
  }

  std::mutex::unlock((std::mutex *)(a1 + 168));
  sub_100016DE0(&v78);
  uint64_t v39 = *((void *)&v70 + 1);
  BOOL v40 = (unint64_t **)(*((void *)&v68 + 1) + 8 * ((unint64_t)v70 >> 9));
  if ((void)v69 == *((void *)&v68 + 1))
  {
    uint64_t v41 = 0LL;
    __int128 v43 = 0LL;
    unint64_t v42 = (char *)(*((void *)&v68 + 1) + 8LL * (((void)v70 + *((void *)&v70 + 1)) >> 9));
  }

  else
  {
    uint64_t v41 = &(*v40)[v70 & 0x1FF];
    unint64_t v42 = (char *)(*((void *)&v68 + 1) + 8LL * (((void)v70 + *((void *)&v70 + 1)) >> 9));
    __int128 v43 = (unint64_t *)(*(void *)v42 + 8 * ((v70 + *((void *)&v70 + 1)) & 0x1FF));
  }

  sub_1000C18EC(*(unint64_t **)(a1 + 8), v40, v41, v42, v43, a2);
  if (v39) {
    (*(void (**)(void))(**(void **)(a1 + 8) + 24LL))(*(void *)(a1 + 8));
  }
  int v44 = *(unsigned __int8 *)(a1 + 100);
  if (*(_BYTE *)(a1 + 100))
  {
    (*(void (**)(void, void, void))(**(void **)(a1 + 8) + 40LL))( *(void *)(a1 + 8),  *(void *)(a1 + 352),  *(void *)(a1 + 344));
    *(_BYTE *)(a1 + 100) = 0;
  }

  sub_1000BBD1C(&v68);
  return v44 != 0;
}

void sub_1000C1270( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, std::mutex *a11, std::mutex *a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, unint64_t a41, uint64_t a42)
{
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    std::mutex::lock(a11);
    unint64_t v46 = a16[33] + a16[34];
    uint64_t v47 = a16[30];
    uint64_t v48 = (char *)(v47 + 8 * (v46 >> 9));
    if (a16[31] == v47) {
      uint64_t v49 = 0LL;
    }
    else {
      uint64_t v49 = *(void *)v48 + 8 * (v46 & 0x1FF);
    }
    unint64_t v50 = (char *)(a38 + 8 * (a41 >> 9));
    if (a39 == a38)
    {
      uint64_t v51 = 0LL;
      uint64_t v52 = 0LL;
      unint64_t v53 = (char *)(a38 + 8 * ((a42 + a41) >> 9));
    }

    else
    {
      uint64_t v51 = (char *)(*(void *)v50 + 8 * (a41 & 0x1FF));
      unint64_t v53 = (char *)(a38 + 8 * ((a42 + a41) >> 9));
      uint64_t v52 = (char *)(*(void *)v53 + 8 * ((a42 + a41) & 0x1FF));
    }

    sub_1000C18B8(a10, v48, v49, v50, v51, v53, v52);
    std::mutex::unlock(a11);
    do
      unsigned int v54 = __ldaxr(v42);
    while (__stlxr(v54 | ((_DWORD)a15 != 0), v42));
    __cxa_rethrow();
  }

  sub_1000BBD1C(&a37);
  _Unwind_Resume(a1);
}

void sub_1000C1450()
{
}

uint64_t sub_1000C148C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int128 v6 = (std::mutex *)(a1 + 120);
  std::mutex::lock((std::mutex *)(a1 + 120));
  uint64_t v7 = sub_1000C6A80(a1, a2, a3, *(unsigned int *)(*(void *)(a3 + 8) + 20LL));
  std::mutex::unlock(v6);
  return v7;
}

void sub_1000C14EC(_Unwind_Exception *a1)
{
}

BOOL sub_1000C1500(void *a1)
{
  unint64_t v1 = atomic_load((unint64_t *)(*(void *)(*a1 + 56LL) + 16LL * a1[1] + 8));
  if ((v1 & 0x7F80000000000000LL) != 0)
  {
    *(void *)&__int128 v3 = "di_asif::details::table_entry_map::validate() const";
    *((void *)&v3 + 1) = 43LL;
    int v4 = 16;
    sub_1000837DC(v5, &v3);
    sub_100004E4C(&v6, (uint64_t)"Diskimages2 - ASIF - bad map entry reserved bits ", 49LL);
    *(_DWORD *)((char *)&v6 + *(void *)(v6 - 24) + _Block_object_dispose((const void *)(v2 - 120), 8) = *(_DWORD *)((_BYTE *)&v6 + *(void *)(v6 - 24) + 8) & 0xFFFFFFB5 | 8;
    std::ostream::operator<<(&v6, v1);
    std::ostream::~ostream(&v6, off_100176C50);
    sub_100083940((uint64_t)v5);
    std::ios::~ios(&v7);
  }

  return (v1 & 0x7F80000000000000LL) == 0;
}

void sub_1000C15DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void sub_1000C15F0(uint64_t a1, uint64_t a2)
{
  if (**(_BYTE **)(a1 + 24))
  {
    int v4 = (*(uint64_t (**)(void, void))(**(void **)(*(void *)a1 + 16LL) + 16LL))( *(void *)(*(void *)a1 + 16LL),  0LL);
    if (v4)
    {
      uint64_t v21 = *(void *)a1;
      int v22 = v4;
      sub_10009C63C(v21);
      exception = __cxa_allocate_exception(0x40uLL);
      if (v22 < 0) {
        unsigned int v24 = v22;
      }
      else {
        unsigned int v24 = -v22;
      }
      unint64_t v25 = (void *)sub_100004870((uint64_t)exception, (uint64_t)"Can't flush asif, backend flush failed", v24);
    }

    **(_BYTE **)(a1 + 24) = 0;
  }

  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v6 = a2 - v5;
  uint64_t v7 = **(void **)(a1 + 8);
  __int128 v8 = (std::__shared_weak_count *)*((void *)sub_100118DDC() + 1);
  uint64_t v26 = v5;
  uint64_t v27 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      unint64_t v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }

  uint64_t v28 = v6;
  uint64_t v29 = v7;
  uint64_t v30 = v6;
  char v31 = 0;
  int v11 = (*(uint64_t (**)(void, uint64_t *))(**(void **)(*(void *)a1 + 16LL) + 80LL))( *(void *)(*(void *)a1 + 16LL),  &v26);
  **(void **)(a1 + 8) += v6;
  if (v6 != v11)
  {
    uint64_t v15 = *(void *)a1;
    int v16 = v11;
    sub_10009C63C(v15);
    LODWORD(v17) = v16;
    uint64_t v18 = __cxa_allocate_exception(0x40uLL);
    unint64_t v19 = v18;
    else {
      uint64_t v17 = -(int)v17;
    }
    *uint64_t v18 = &off_100189E78;
    uint64_t v20 = std::generic_category();
    v19[1] = v17;
    v19[2] = v20;
    *((_BYTE *)v19 + 24) = 0;
    *((_BYTE *)v19 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
    v19[7] = "Can't flush asif";
  }

  uint64_t v12 = v27;
  if (v27)
  {
    uint64_t v13 = (unint64_t *)&v27->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

void sub_1000C17A0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL sub_1000C17B4(void *a1)
{
  unint64_t v1 = atomic_load((unint64_t *)(*(void *)(*a1 + 56LL) + 16LL * a1[1] + 8));
  if ((v1 & 0x3F80000000000000LL) != 0)
  {
    *(void *)&__int128 v3 = "di_asif::details::table_entry_data::validate() const";
    *((void *)&v3 + 1) = 44LL;
    int v4 = 16;
    sub_1000D1D80(v5, &v3);
    sub_100004E4C(&v6, (uint64_t)"Diskimages2 - ASIF - bad reserved bits ", 39LL);
    *(_DWORD *)((char *)&v6 + *(void *)(v6 - 24) + _Block_object_dispose((const void *)(v2 - 120), 8) = *(_DWORD *)((_BYTE *)&v6 + *(void *)(v6 - 24) + 8) & 0xFFFFFFB5 | 8;
    std::ostream::operator<<(&v6, v1);
    std::ostream::~ostream(&v6, off_10017FF90);
    sub_1000D1EE4((uint64_t)v5);
    std::ios::~ios(&v7);
  }

  return (v1 & 0x3F80000000000000LL) == 0;
}

void sub_1000C18A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void *sub_1000C18B8(void **a1, char *a2, uint64_t a3, char *a4, char *a5, char *a6, char *a7)
{
  if (a7 == a5) {
    unint64_t v7 = 0LL;
  }
  else {
    unint64_t v7 = ((uint64_t)&a7[-*(void *)a6] >> 3) + ((a6 - a4) << 6) - ((uint64_t)&a5[-*(void *)a4] >> 3);
  }
  return sub_1000DDFCC(a1, a2, a3, a4, a5, a6, a7, v7);
}

void *sub_1000C18EC( unint64_t *a1, unint64_t **a2, unint64_t *a3, char *a4, unint64_t *a5, uint64_t a6)
{
  uint64_t v12 = (*(uint64_t (**)(unint64_t *))(*a1 + 16))(a1);
  v18[0] = &off_10017F100;
  v18[1] = a6;
  unint64_t v19 = v18;
  sub_1000DF394(v12, a2, a3, (uint64_t)a4, a5, (uint64_t)v18);
  __n128 result = v19;
  if (v19 == v18)
  {
    uint64_t v14 = 4LL;
    __n128 result = v18;
  }

  else
  {
    if (!v19) {
      goto LABEL_6;
    }
    uint64_t v14 = 5LL;
  }

  __n128 result = (void *)(*(uint64_t (**)(void))(*result + 8 * v14))();
LABEL_6:
  if (a5 == a3) {
    uint64_t v15 = 0LL;
  }
  else {
    uint64_t v15 = (((char *)a2 - a4) << 6) - (((uint64_t)a5 - *(void *)a4) >> 3) + a3 - *a2;
  }
  int v16 = a1 + 1;
  do
    unint64_t v17 = __ldaxr(v16);
  while (__stlxr(v17 + v15, v16));
  return result;
}

void sub_1000C1A08( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  uint64_t v15 = a13;
  if (a13 == v13)
  {
    uint64_t v16 = 4LL;
    uint64_t v15 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v16 = 5LL;
  }

  (*(void (**)(void))(*(void *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

unint64_t sub_1000C1A40(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  *(_WORD *)uint64_t v119 = 0;
  char v121 = 0;
  unint64_t v7 = (std::__shared_weak_count *)a3[1];
  uint64_t v106 = *a3;
  v107 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }

  *(_OWORD *)unint64_t v108 = *((_OWORD *)a3 + 1);
  *(_OWORD *)&v108[9] = *(_OWORD *)((char *)a3 + 25);
  uint64_t v109 = a3[6];
  __int128 v110 = *(_OWORD *)(a3 + 7);
  __int128 v111 = *(_OWORD *)(a3 + 9);
  __int128 v112 = *(_OWORD *)(a3 + 11);
  char v113 = *((_BYTE *)a3 + 104);
  unint64_t v10 = (std::__shared_weak_count *)a3[15];
  uint64_t v114 = a3[14];
  v115 = v10;
  if (v10)
  {
    int v11 = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }

  unint64_t v79 = 0LL;
  __int128 v116 = *((_OWORD *)a3 + 8);
  uint64_t v117 = a3[18];
  char v118 = *((_BYTE *)a3 + 152);
  while (!sub_10002B1FC((uint64_t)&v106, a4))
  {
    v104 = (void *)sub_1000BC43C(a1, *(unint64_t *)&v108[8]);
    uint64_t v105 = v13;
    uint64_t v14 = v104[1];
    uint64_t v15 = *(void *)(v14 + 48);
    uint64_t v16 = *(unsigned int *)(v14 + 20);
    v94[0] = v104[44] + (v15 + v15 * v13) / (unint64_t)(v15 + 1) * v16;
    v94[1] = v94[0] + v16;
    char v95 = 2;
    sub_10002C8E0((uint64_t)&v106, (uint64_t)v94, a4, (uint64_t)v98);
    if (sub_10002B1FC((uint64_t)v98, (uint64_t)&v101))
    {
      *(void *)&__int128 v84 = "di_asif::details::table::write(ContextASIF &, const sg_vec::iterator &, const sg_vec::iterator &)";
      *((void *)&v84 + 1) = 30LL;
      LODWORD(v85) = 16;
      sub_1000C2604(v94, &v84);
      sub_100004E4C(&v96, (uint64_t)"Couldn't trim entry in write ", 29LL);
      sub_100116CB8(&v96, &v106);
      std::ostream::~ostream(&v96, off_1001801B0);
      sub_1000D2654((uint64_t)v94);
      std::ios::~ios(v97);
      int v17 = 1;
      unint64_t v18 = -34LL;
      goto LABEL_73;
    }

    unint64_t v19 = (unint64_t *)(v104[7] + 16 * v105);
    BOOL v20 = sub_1000D6E20(v19);
    v92[0] = off_100189878;
    v92[1] = v19;
    BOOL v93 = v20;
    if (!v20)
    {
      *(void *)&__int128 v84 = "di_asif::details::table::write(ContextASIF &, const sg_vec::iterator &, const sg_vec::iterator &)";
      *((void *)&v84 + 1) = 30LL;
      LODWORD(v85) = 16;
      sub_1000C26EC(v94, &v84);
      sub_100004E4C(&v96, (uint64_t)"Couldn't lock entry ", 20LL);
      sub_1000BFD20(&v96, &v104);
      sub_1000C2794((uint64_t)v94);
      exception = __cxa_allocate_exception(0x40uLL);
      void *exception = &off_100189E78;
      int v74 = std::generic_category();
      exception[1] = 4294967282LL;
      exception[2] = v74;
      *((_BYTE *)exception + 24) = 0;
      *((_BYTE *)exception + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
      exception[7] = "Couldn't lock entry";
    }

    uint64_t v21 = v105;
    uint64_t v22 = v104[7];
    uint64_t v23 = (*(void *)(v22 + 16 * v105 + 8) & 0x7FFFFFFFFFFFFFLL) * *(unsigned int *)(v104[1] + 20LL);
    if (!v23)
    {
      unint64_t v18 = sub_1000BD6E4(a1, a2, (uint64_t)v104, v105);
      if ((_DWORD)v18)
      {
        *(void *)&__int128 v84 = "di_asif::details::table::write(ContextASIF &, const sg_vec::iterator &, const sg_vec::iterator &)";
        *((void *)&v84 + 1) = 30LL;
        LODWORD(v85) = 16;
        sub_1000C27D4(v94, &v84);
        sub_100004E4C(&v96, (uint64_t)"couldn't allocate space for entry ", 34LL);
        sub_1000BFD20(&v96, &v104);
        sub_100004E4C(&v96, (uint64_t)" ret: ", 6LL);
        std::ostream::operator<<(&v96, v18);
        std::ostream::~ostream(&v96, off_1001805F0);
        sub_1000D31AC((uint64_t)v94);
        std::ios::~ios(v97);
        unint64_t v18 = (int)v18;
        goto LABEL_71;
      }

      uint64_t v21 = v105;
      uint64_t v22 = v104[7];
    }

    unint64_t v24 = atomic_load((unint64_t *)(v22 + 16 * v21 + 8));
    unint64_t v25 = sub_1000C28BC(&v104, a2, (uint64_t)v98, (uint64_t)&v101);
    unint64_t v18 = v25;
    unint64_t v27 = v26;
    if ((v25 & 0x8000000000000000LL) != 0 && (_DWORD)v25)
    {
      if (v23) {
        goto LABEL_71;
      }
      sub_100116AA0((uint64_t)v92, 0LL, (uint64_t)v94);
      if (!v95) {
        goto LABEL_70;
      }
      unint64_t v28 = atomic_load((unint64_t *)(v104[7] + 16 * v105 + 8));
      if ((v28 & 0x4000000000000000LL) != 0) {
        goto LABEL_70;
      }
      uint64_t v29 = (unint64_t *)(v104[7] + 16 * v105 + 8);
      unint64_t v30 = *v29;
      uint64_t v31 = *(unsigned int *)(v104[1] + 20LL);
      if ((_DWORD)v31)
      {
        do
          unint64_t v32 = __ldxr(v29);
        while (__stxr(v32 & 0xFF80000000000000LL, v29));
LABEL_66:
        uint64_t v48 = (v30 & 0x7FFFFFFFFFFFFFLL) * v31;
        sub_100116BAC(v94);
        if (v48) {
          sub_1000BD7C0(*(unint64_t **)(a1 + 8), v48, a2);
        }
        goto LABEL_71;
      }

      unint64_t v44 = *v29;
      unint64_t v45 = __ldxr(v29);
      if (v45 == v44)
      {
        if (__stxr(v44 & 0xFF80000000000000LL, v29)) {
          goto LABEL_60;
        }
LABEL_70:
        sub_100116BAC(v94);
LABEL_71:
        int v17 = 1;
        goto LABEL_72;
      }

      __clrex();
LABEL_60:
      while (2)
      {
        unint64_t v46 = __ldxr(v29);
        if (v46 == v45)
        {
          if (!__stxr(v45 & 0xFF80000000000000LL, v29))
          {
            char v47 = 1;
            goto LABEL_65;
          }
        }

        else
        {
          __clrex();
        }

        char v47 = 0;
LABEL_65:
        unint64_t v45 = v46;
        if ((v47 & 1) != 0) {
          goto LABEL_66;
        }
        continue;
      }
    }

    unint64_t v33 = v24 >> 62;
    *(void *)&__int128 v84 = &v106;
    *((void *)&v84 + 1) = a4;
    uint64_t v85 = &v119[1];
    __int128 v86 = &v104;
    uint64_t v87 = v119;
    uint64_t v88 = a1;
    unint64_t v89 = v25;
    unint64_t v90 = v26;
    uint64_t v91 = a2;
    if ((_DWORD)v33 == 1) {
      goto LABEL_55;
    }
    uint64_t v34 = v104[1];
    uint64_t v35 = *(unsigned int *)(v34 + 20);
    if (v25 == v35
      && v104[44]
       + (*(void *)(v34 + 48) + *(void *)(v34 + 48) * v105) / (unint64_t)(*(void *)(v34 + 48) + 1LL) * v35 == v26)
    {
      sub_100116AA0((uint64_t)v92, 0LL, (uint64_t)v82);
      if (!v83)
      {
        *(void *)&__int128 v80 = "di_asif::details::table::write(ContextASIF &, const sg_vec::iterator &, const sg_vec::iterator &)";
        *((void *)&v80 + 1) = 30LL;
        int v81 = 16;
        sub_1000C368C(v94, &v80);
        sub_100004E4C(&v96, (uint64_t)"Couldn't upgrade lock entry ", 28LL);
        sub_1000BFD20(&v96, &v104);
        sub_1000C3734((uint64_t)v94);
        unint64_t v75 = __cxa_allocate_exception(0x40uLL);
        *unint64_t v75 = &off_100189E78;
        uint64_t v76 = std::generic_category();
        v75[1] = 4294967282LL;
        unint64_t v75[2] = v76;
        *((_BYTE *)v75 + 24) = 0;
        *((_BYTE *)v75 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
        v75[7] = "Couldn't upgrade lock entry";
      }

      unint64_t v36 = atomic_load((unint64_t *)(v104[7] + 16 * v105 + 8));
      if ((_DWORD)v33 == 2 || (v36 & 0xC000000000000000LL) != 0x8000000000000000LL)
      {
        unint64_t v37 = (unint64_t *)(v104[7] + 16 * v105 + 8);
        unint64_t v38 = *v37;
        unint64_t v39 = __ldaxr(v37);
        if (v39 == v38)
        {
          if (!__stlxr(v38 & 0x3FFFFFFFFFFFFFFFLL | 0x4000000000000000LL, v37)) {
            goto LABEL_47;
          }
        }

        else
        {
          __clrex();
        }

        do
        {
          while (1)
          {
            unint64_t v38 = v39;
            unint64_t v39 = __ldaxr(v37);
            if (v39 == v38) {
              break;
            }
            __clrex();
          }
        }

        while (__stlxr(v38 & 0x3FFFFFFFFFFFFFFFLL | 0x4000000000000000LL, v37));
LABEL_47:
        if (v119[0]) {
          BOOL v42 = 1;
        }
        else {
          BOOL v42 = v38 >> 62 == 3;
        }
        char v43 = v42;
        v119[0] = v43;
        atomic_store(1u, (unsigned int *)(a1 + 96));
      }

void sub_1000C2514( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, char a30)
{
}

void *sub_1000C2604(void *a1, __int128 *a2)
{
  __int128 v3 = (std::ios_base *)(a1 + 46);
  sub_1000DF5A0((uint64_t)a1, a2);
  *a1 = off_1001800E8;
  a1[45] = &off_1001801E8;
  a1[46] = &off_100180210;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_1001800E8;
  a1[45] = off_100180170;
  a1[46] = off_100180198;
  return a1;
}

void sub_1000C2688(_Unwind_Exception *a1)
{
}

uint64_t sub_1000C26AC(uint64_t a1)
{
  return a1;
}

void *sub_1000C26EC(void *a1, __int128 *a2)
{
  __int128 v3 = (std::ios_base *)(a1 + 46);
  sub_1000DF61C((uint64_t)a1, a2);
  *a1 = off_100180308;
  a1[45] = &off_100180408;
  a1[46] = &off_100180430;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_100180308;
  a1[45] = off_100180390;
  a1[46] = off_1001803B8;
  return a1;
}

void sub_1000C2770(_Unwind_Exception *a1)
{
}

uint64_t sub_1000C2794(uint64_t a1)
{
  return a1;
}

void *sub_1000C27D4(void *a1, __int128 *a2)
{
  __int128 v3 = (std::ios_base *)(a1 + 46);
  sub_1000DF698((uint64_t)a1, a2);
  *a1 = off_100180528;
  a1[45] = &off_100180628;
  a1[46] = &off_100180650;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_100180528;
  a1[45] = off_1001805B0;
  a1[46] = off_1001805D8;
  return a1;
}

void sub_1000C2858(_Unwind_Exception *a1)
{
}

uint64_t sub_1000C287C(uint64_t a1)
{
  return a1;
}

uint64_t sub_1000C28BC(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a1[1];
  uint64_t v5 = *(void *)(*a1 + 8LL);
  uint64_t v6 = *(unsigned int *)(v5 + 20);
  if (!((*(void *)(*(void *)(*a1 + 56LL) + 16 * v4 + 8) & 0x7FFFFFFFFFFFFFLL) * v6))
  {
    exception = __cxa_allocate_exception(0x40uLL);
    uint64_t v109 = (void *)sub_100004870((uint64_t)exception, (uint64_t)"ASIF: No data offset found (write)", 0xFFFFFFEA);
  }

  __p = (void *)(*(void *)(*a1 + 352LL)
               + (*(void *)(v5 + 48) + *(void *)(v5 + 48) * v4)
  *(void *)&__int128 v192 = (char *)__p + v6;
  BYTE8(v192) = 2;
  sub_10002C8E0(a3, (uint64_t)&__p, a4, (uint64_t)v123);
  if (sub_10002B1FC((uint64_t)v123, (uint64_t)&v126))
  {
    uint64_t v10 = -34LL;
  }

  else
  {
    __p = v193;
    __int128 v192 = xmmword_1001388C0;
    __int128 v11 = *(_OWORD *)(a3 + 72);
    __int128 v181 = *(_OWORD *)(a3 + 56);
    __int128 v182 = v11;
    __int128 v183 = *(_OWORD *)(a3 + 88);
    char v184 = *(_BYTE *)(a3 + 104);
    unint64_t v12 = *(std::__shared_weak_count **)(a3 + 120);
    uint64_t v185 = *(void *)(a3 + 112);
    v186 = v12;
    if (v12)
    {
      p_shared_owners = (unint64_t *)&v12->__shared_owners_;
      do
        unint64_t v14 = __ldxr(p_shared_owners);
      while (__stxr(v14 + 1, p_shared_owners));
    }

    __int128 v187 = *(_OWORD *)(a3 + 128);
    uint64_t v15 = *(void *)(a4 + 56);
    uint64_t v16 = *(void *)(a4 + 64);
    *(void *)&__int128 v167 = v15;
    *((void *)&v167 + 1) = v16;
    __int128 v17 = *(_OWORD *)(a4 + 88);
    __int128 v168 = *(_OWORD *)(a4 + 72);
    __int128 v169 = v17;
    char v170 = *(_BYTE *)(a4 + 104);
    unint64_t v18 = *(std::__shared_weak_count **)(a4 + 120);
    uint64_t v171 = *(void *)(a4 + 112);
    v172 = v18;
    if (v18)
    {
      unint64_t v19 = (unint64_t *)&v18->__shared_owners_;
      do
        unint64_t v20 = __ldxr(v19);
      while (__stxr(v20 + 1, v19));
    }

    size_t v21 = 0LL;
    unint64_t v22 = 0LL;
    uint64_t v110 = a3 + 128;
    __int128 v173 = *(_OWORD *)(a4 + 128);
    while (1)
    {
      BOOL v23 = (void)v181 == v15 && *((void *)&v181 + 1) == v16;
      if (v23 && (void)v182 == (void)v168) {
        break;
      }
      ++v22;
      v21 += 40LL;
      sub_10002AD0C((uint64_t)&v181);
    }

    if (v18)
    {
      unint64_t v24 = (unint64_t *)&v18->__shared_owners_;
      do
        unint64_t v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
    }

    unint64_t v26 = v186;
    if (v186)
    {
      unint64_t v27 = (unint64_t *)&v186->__shared_owners_;
      do
        unint64_t v28 = __ldaxr(v27);
      while (__stlxr(v28 - 1, v27));
      if (!v28)
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
      }
    }

    if (*((void *)&v192 + 1) < v22)
    {
      if (v22 >= 0x333333333333334LL) {
        sub_100014AD4("get_next_capacity, allocator's max size reached");
      }
      uint64_t v29 = operator new(v21);
      sub_10004C198((uint64_t *)&__p, (unint64_t)v29, v22, (uint64_t)__p + 40 * v192, 0LL, 0LL);
    }

    uint64_t v30 = *(void *)a3;
    uint64_t v31 = *(std::__shared_weak_count **)(a3 + 8);
    if (v31)
    {
      unint64_t v32 = (unint64_t *)&v31->__shared_owners_;
      do
        unint64_t v33 = __ldxr(v32);
      while (__stxr(v33 + 1, v32));
    }

    *(_OWORD *)__int128 v116 = *(_OWORD *)(a3 + 16);
    *(_OWORD *)&v116[9] = *(_OWORD *)(a3 + 25);
    __int128 v117 = *(_OWORD *)(a3 + 72);
    uint64_t v34 = *(void *)(a3 + 48);
    uint64_t v35 = *(void *)(a3 + 56);
    uint64_t v36 = *(void *)(a3 + 64);
    __int128 v118 = *(_OWORD *)(a3 + 88);
    char v119 = *(_BYTE *)(a3 + 104);
    uint64_t v37 = *(void *)(a3 + 112);
    unint64_t v38 = *(std::__shared_weak_count **)(a3 + 120);
    if (v38)
    {
      unint64_t v39 = (unint64_t *)&v38->__shared_owners_;
      do
        unint64_t v40 = __ldxr(v39);
      while (__stxr(v40 + 1, v39));
    }

    __int128 v120 = *(_OWORD *)v110;
    unint64_t v121 = *(void *)(a3 + 144);
    char v122 = *(_BYTE *)(a3 + 152);
    uint64_t v41 = *(void *)a4;
    BOOL v42 = *(std::__shared_weak_count **)(a4 + 8);
    if (v42)
    {
      char v43 = (unint64_t *)&v42->__shared_owners_;
      do
        unint64_t v44 = __ldxr(v43);
      while (__stxr(v44 + 1, v43));
    }

    *(_OWORD *)__int128 v112 = *(_OWORD *)(a4 + 16);
    *(_OWORD *)&v112[9] = *(_OWORD *)(a4 + 25);
    __int128 v113 = *(_OWORD *)(a4 + 72);
    uint64_t v46 = *(void *)(a4 + 48);
    uint64_t v45 = *(void *)(a4 + 56);
    uint64_t v47 = *(void *)(a4 + 64);
    __int128 v114 = *(_OWORD *)(a4 + 88);
    char v115 = *(_BYTE *)(a4 + 104);
    uint64_t v49 = *(void *)(a4 + 112);
    uint64_t v48 = *(std::__shared_weak_count **)(a4 + 120);
    if (v48)
    {
      unint64_t v50 = (unint64_t *)&v48->__shared_owners_;
      do
        unint64_t v51 = __ldxr(v50);
      while (__stxr(v51 + 1, v50));
    }

    uint64_t v52 = 0LL;
    v145[0] = *(_OWORD *)v116;
    *(_OWORD *)((char *)v145 + 9) = *(_OWORD *)&v116[9];
    __int128 v148 = v117;
    __int128 v149 = v118;
    __int128 v153 = v120;
    v131[0] = *(_OWORD *)v112;
    *(_OWORD *)((char *)v131 + 9) = *(_OWORD *)&v112[9];
    __int128 v136 = v114;
    uint64_t v143 = v30;
    v144 = v31;
    uint64_t v146 = v34;
    *(void *)&__int128 v147 = v35;
    *((void *)&v147 + 1) = v36;
    char v150 = v119;
    uint64_t v151 = v37;
    v152 = v38;
    unint64_t v154 = v121;
    char v155 = v122;
    uint64_t v129 = v41;
    v130 = v42;
    uint64_t v132 = v46;
    uint64_t v133 = v45;
    uint64_t v134 = v47;
    char v137 = v115;
    __int128 v135 = v113;
    uint64_t v138 = v49;
    v139 = v48;
    __int128 v140 = *(_OWORD *)(a4 + 128);
    char v142 = *(_BYTE *)(a4 + 152);
    unint64_t v141 = *(void *)(a4 + 144);
    unint64_t v53 = v141;
    LOBYTE(v181) = 0;
    char v188 = 0;
    while (!sub_10002B1FC((uint64_t)&v143, (uint64_t)&v129))
    {
      if (sub_1000B866C())
      {
        *(void *)&__int128 v177 = "details::for_each_sg_in_vec_internal(Fn &&, sg_vec_ref::iterator, sg_vec::iterator, size_t, BOOL) [Fn = (lambda at /Library/Caches/com.apple.xbs/Sources/DiskImages2/app/disk_images/formats/asif.cpp:1765:32)]";
        *((void *)&v177 + 1) = 104LL;
        LODWORD(v17_Block_object_dispose((const void *)(v2 - 120), 8) = 2;
        sub_100035DF8(&v167, &v177);
        sub_100004E4C(&v175, (uint64_t)"sg: ", 4LL);
        sub_100116CB8(&v175, &v143);
        std::ostream::~ostream(&v175, off_100169EF0);
        sub_10003602C((uint64_t)&v167);
        std::ios::~ios(&v176);
      }

      *(void *)&__int128 v167 = 0LL;
      *((void *)&v167 + 1) = v53;
      LOBYTE(v16_Block_object_dispose((const void *)(v2 - 120), 8) = 2;
      sub_100072C74(&v143, (uint64_t)&v167, (uint64_t)&v177);
      int64_t v55 = v178;
      uint64_t v56 = *(void *)(*(void *)(*a1 + 56LL) + 16LL * a1[1] + 8);
      unint64_t v57 = *(unsigned int *)(*(void *)(*a1 + 8LL) + 20LL);
      unint64_t v58 = v179;
      uint64_t v59 = v180;
      __int128 v167 = v177;
      if (*((void *)&v177 + 1))
      {
        unint64_t v60 = (unint64_t *)(*((void *)&v177 + 1) + 8LL);
        do
          unint64_t v61 = __ldxr(v60);
        while (__stxr(v61 + 1, v60));
      }

      *(void *)&__int128 v168 = v55;
      *((void *)&v168 + 1) = v58 % v57 + (v56 & 0x7FFFFFFFFFFFFFLL) * v57;
      *(void *)&__int128 v169 = v59;
      BYTE8(v169) = 0;
      (*(void (**)(void *__return_ptr, void, __int128 *))(**(void **)(a2 + 16) + 136LL))( v189,  *(void *)(a2 + 16),  &v167);
      if ((void)v192 == *((void *)&v192 + 1))
      {
        sub_10004D74C((uint64_t *)&__p, (uint64_t)__p + 40 * v192, 1LL, (uint64_t)v189, &v190);
      }

      else
      {
        sub_10003C7B8((unint64_t)__p + 40 * v192, (uint64_t)v189);
        *(void *)&__int128 v192 = v192 + 1;
      }

      unint64_t v62 = v179;
      int64_t v63 = v178;
      uint64_t v64 = (std::__shared_weak_count *)*((void *)&v167 + 1);
      if (*((void *)&v167 + 1))
      {
        uint64_t v65 = (unint64_t *)(*((void *)&v167 + 1) + 8LL);
        do
          unint64_t v66 = __ldaxr(v65);
        while (__stlxr(v66 - 1, v65));
        if (!v66)
        {
          ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
          std::__shared_weak_count::__release_weak(v64);
        }
      }

      BOOL v67 = v63 >= 0 || (_DWORD)v63 == 0;
      char v68 = v67;
      if (v67)
      {
        if (sub_10002D4E0((uint64_t)&v143, (uint64_t)&v129, v62, v63))
        {
          v156[0] = v143;
          v156[1] = v144;
          if (v144)
          {
            __int128 v73 = (unint64_t *)&v144->__shared_owners_;
            do
              unint64_t v74 = __ldxr(v73);
            while (__stxr(v74 + 1, v73));
          }

          v157[0] = v145[0];
          *(_OWORD *)((char *)v157 + 9) = *(_OWORD *)((char *)v145 + 9);
          __int128 v159 = v147;
          __int128 v160 = v148;
          __int128 v161 = v149;
          char v162 = v150;
          uint64_t v158 = v146;
          v163[0] = v151;
          v163[1] = v152;
          if (v152)
          {
            unint64_t v75 = (unint64_t *)&v152->__shared_owners_;
            do
              unint64_t v76 = __ldxr(v75);
            while (__stxr(v76 + 1, v75));
          }

          __int128 v164 = v153;
          unint64_t v165 = v154;
          char v166 = v155;
          sub_10002D4A4((uint64_t)v156, (uint64_t)&v129, v62, v63, 0xFFFFFFFFFFFFFFFFLL, (uint64_t)&v167);
          sub_100035EE0((uint64_t)&v181, (uint64_t)&v167);
          sub_10002D4FC((uint64_t)&v167);
          sub_1000114F0((uint64_t)v163);
          sub_1000114F0((uint64_t)v156);
          sub_10002B7D4((uint64_t)&v181, (uint64_t)&v167);
          sub_100035F24((uint64_t)&v143, (uint64_t)&v167);
          sub_1000114F0((uint64_t)v174);
          sub_1000114F0((uint64_t)&v167);
          sub_10002B3A4((uint64_t)&v181, (uint64_t)&v167);
          sub_100035F24((uint64_t)&v129, (uint64_t)&v167);
          sub_1000114F0((uint64_t)v174);
          sub_1000114F0((uint64_t)&v167);
        }

        sub_10002C52C((uint64_t)&v143, v63);
        uint64_t v52 = (_OWORD *)((char *)v52 + v63);
      }

      else
      {
        else {
          uint64_t v72 = -(int)v63;
        }
        uint64_t v110 = -v72;
      }

      __int128 v69 = (std::__shared_weak_count *)*((void *)&v177 + 1);
      if (*((void *)&v177 + 1))
      {
        __int128 v70 = (unint64_t *)(*((void *)&v177 + 1) + 8LL);
        do
          unint64_t v71 = __ldaxr(v70);
        while (__stlxr(v71 - 1, v70));
        if (!v71)
        {
          ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
          std::__shared_weak_count::__release_weak(v69);
        }
      }

      if ((v68 & 1) == 0) {
        goto LABEL_91;
      }
    }

    uint64_t v110 = (uint64_t)v52;
LABEL_91:
    sub_10002D8BC((uint64_t)&v181);
    uint64_t v77 = v139;
    if (v139)
    {
      uint64_t v78 = (unint64_t *)&v139->__shared_owners_;
      do
        unint64_t v79 = __ldaxr(v78);
      while (__stlxr(v79 - 1, v78));
      if (!v79)
      {
        ((void (*)(std::__shared_weak_count *))v77->__on_zero_shared)(v77);
        std::__shared_weak_count::__release_weak(v77);
      }
    }

    __int128 v80 = v130;
    if (v130)
    {
      int v81 = (unint64_t *)&v130->__shared_owners_;
      do
        unint64_t v82 = __ldaxr(v81);
      while (__stlxr(v82 - 1, v81));
      if (!v82)
      {
        ((void (*)(std::__shared_weak_count *))v80->__on_zero_shared)(v80);
        std::__shared_weak_count::__release_weak(v80);
      }
    }

    char v83 = v152;
    uint64_t v10 = v110;
    if (v152)
    {
      __int128 v84 = (unint64_t *)&v152->__shared_owners_;
      do
        unint64_t v85 = __ldaxr(v84);
      while (__stlxr(v85 - 1, v84));
      if (!v85)
      {
        ((void (*)(std::__shared_weak_count *))v83->__on_zero_shared)(v83);
        std::__shared_weak_count::__release_weak(v83);
      }
    }

    __int128 v86 = v144;
    if (v144)
    {
      uint64_t v87 = (unint64_t *)&v144->__shared_owners_;
      do
        unint64_t v88 = __ldaxr(v87);
      while (__stlxr(v88 - 1, v87));
      if (!v88)
      {
        ((void (*)(std::__shared_weak_count *))v86->__on_zero_shared)(v86);
        std::__shared_weak_count::__release_weak(v86);
      }
    }

    if ((v110 & 0x8000000000000000LL) == 0 || !(_DWORD)v110)
    {
      (*(void (**)(void))(**(void **)(a2 + 16) + 144LL))(*(void *)(a2 + 16));
      if ((void)v192)
      {
        int v89 = 0;
        unint64_t v90 = (unsigned int *)__p;
        uint64_t v91 = 40 * v192;
        do
        {
          int v92 = sub_100038120(v90);
          if (v92 < 0) {
            break;
          }
          v89 += v92;
          v90 += 10;
          int v92 = v89;
          v91 -= 40LL;
        }

        while (v91);
      }

      else
      {
        int v92 = 0;
      }

      int v93 = v92 < 0 ? v92 : -5;
      uint64_t v94 = -v93;
      if (v110 != v92) {
        uint64_t v10 = -v94;
      }
    }

    if (*((void *)&v192 + 1) && v193 != __p) {
      operator delete(__p);
    }
  }

  char v95 = v128;
  if (v128)
  {
    uint64_t v96 = (unint64_t *)&v128->__shared_owners_;
    do
      unint64_t v97 = __ldaxr(v96);
    while (__stlxr(v97 - 1, v96));
    if (!v97)
    {
      ((void (*)(std::__shared_weak_count *))v95->__on_zero_shared)(v95);
      std::__shared_weak_count::__release_weak(v95);
    }
  }

  uint64_t v98 = v127;
  if (v127)
  {
    v99 = (unint64_t *)&v127->__shared_owners_;
    do
      unint64_t v100 = __ldaxr(v99);
    while (__stlxr(v100 - 1, v99));
    if (!v100)
    {
      ((void (*)(std::__shared_weak_count *))v98->__on_zero_shared)(v98);
      std::__shared_weak_count::__release_weak(v98);
    }
  }

  uint64_t v101 = v125;
  if (v125)
  {
    v102 = (unint64_t *)&v125->__shared_owners_;
    do
      unint64_t v103 = __ldaxr(v102);
    while (__stlxr(v103 - 1, v102));
    if (!v103)
    {
      ((void (*)(std::__shared_weak_count *))v101->__on_zero_shared)(v101);
      std::__shared_weak_count::__release_weak(v101);
    }
  }

  v104 = v124;
  if (v124)
  {
    uint64_t v105 = (unint64_t *)&v124->__shared_owners_;
    do
      unint64_t v106 = __ldaxr(v105);
    while (__stlxr(v106 - 1, v105));
    if (!v106)
    {
      ((void (*)(std::__shared_weak_count *))v104->__on_zero_shared)(v104);
      std::__shared_weak_count::__release_weak(v104);
    }
  }

  return v10;
}

void sub_1000C3578( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, char a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (STACK[0x990])
  {
    if (a23 != STACK[0x980]) {
      operator delete((void *)STACK[0x980]);
    }
  }

  sub_10005A11C((uint64_t)&a67);
  _Unwind_Resume(a1);
}

void *sub_1000C368C(void *a1, __int128 *a2)
{
  __int128 v3 = (std::ios_base *)(a1 + 46);
  sub_1000DF714((uint64_t)a1, a2);
  *a1 = off_100180748;
  a1[45] = &off_100180848;
  a1[46] = &off_100180870;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_100180748;
  a1[45] = off_1001807D0;
  a1[46] = off_1001807F8;
  return a1;
}

void sub_1000C3710(_Unwind_Exception *a1)
{
}

uint64_t sub_1000C3734(uint64_t a1)
{
  return a1;
}

void *sub_1000C3774(void *a1, __int128 *a2)
{
  __int128 v3 = (std::ios_base *)(a1 + 46);
  sub_1000DF790((uint64_t)a1, a2);
  *a1 = off_100180968;
  a1[45] = &off_100180A68;
  a1[46] = &off_100180A90;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_100180968;
  a1[45] = off_1001809F0;
  a1[46] = off_100180A18;
  return a1;
}

void sub_1000C37F8(_Unwind_Exception *a1)
{
}

uint64_t sub_1000C381C(uint64_t a1)
{
  return a1;
}

uint64_t *sub_1000C385C(uint64_t *a1)
{
  __int128 v3 = (void *)a1[5];
  unint64_t v2 = a1[6];
  if ((v2 & 0x8000000000000000LL) == 0 || !a1[6])
  {
    sub_10002C354(*a1, v2);
    uint64_t v4 = a1[2];
    if (*(_BYTE *)(v4 + 16))
    {
      uint64_t v5 = (void *)a1[3];
      if (*(void *)(*v5 + 352LL) != *(void *)(*(void *)v4 + 352LL) || v5[1] != *(void *)(v4 + 8))
      {
        char v6 = sub_1000BCA84((uint64_t)v3, a1[8], (void *)v4);
        unint64_t v7 = (_BYTE *)a1[4];
        BOOL v8 = (v6 & 1) != 0 || *v7 != 0;
        *unint64_t v7 = v8;
        uint64_t v4 = a1[2];
        if (v8)
        {
          uint64_t v9 = *(void *)(*(void *)v4 + 8LL);
          uint64_t v10 = v3[1];
          uint64_t v11 = *(void *)(v10 + 48);
          unsigned int v12 = *(_DWORD *)(v10 + 20);
          unint64_t v13 = *(unsigned __int16 *)(v10 + 18);
          unint64_t v14 = v11 * (v12 / v13);
          unint64_t v15 = v3[44] / v13;
          ++v11;
          uint64_t v16 = v11
              + v11
              * (((*(void *)(*(void *)v4 + 352LL)
                 + (*(void *)(v9 + 48) + *(void *)(v9 + 48) * *(void *)(v4 + 8))
                 / (unint64_t)(*(void *)(v9 + 48) + 1LL)
                 * *(unsigned int *)(v9 + 20))
                / *(unsigned __int16 *)(v9 + 18)
                - v15)
               / v14);
          __int128 v17 = (void *)a1[3];
          uint64_t v18 = *(void *)(*v17 + 8LL);
          if (v16 != v11
                    + v11
                    * (((*(void *)(*v17 + 352LL)
                       + (*(void *)(v18 + 48) + *(void *)(v18 + 48) * v17[1])
                       / (unint64_t)(*(void *)(v18 + 48) + 1LL)
                       * *(unsigned int *)(v18 + 20))
                      / *(unsigned __int16 *)(v18 + 18)
                      - v15)
                     / v14))
          {
            sub_1000BF87C(v3, a1[8], v16 - 1);
            *(_BYTE *)a1[4] = 0;
            uint64_t v4 = a1[2];
          }
        }
      }
    }

    uint64_t v19 = a1[3];
    if (*(_BYTE *)(v4 + 16))
    {
      *(void *)(v4 + _Block_object_dispose((const void *)(v2 - 120), 8) = *(void *)(v19 + 8);
    }

    else
    {
      *(_OWORD *)uint64_t v4 = *(_OWORD *)v19;
      *(_BYTE *)(v4 + 16) = 1;
    }
  }

  return a1;
}

uint64_t sub_1000C39E8(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v5 = a2;
  uint64_t v6 = a1;
  uint64_t v133 = a3[3];
  uint64_t v7 = *a3;
  BOOL v8 = (std::__shared_weak_count *)a3[1];
  uint64_t v181 = *a3;
  __int128 v182 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      unint64_t v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }

  *(_OWORD *)__int128 v183 = *((_OWORD *)a3 + 1);
  *(_OWORD *)&v183[9] = *(_OWORD *)((char *)a3 + 25);
  uint64_t v184 = a3[6];
  __int128 v185 = *(_OWORD *)(a3 + 7);
  __int128 v186 = *(_OWORD *)(a3 + 9);
  __int128 v187 = *(_OWORD *)(a3 + 11);
  char v188 = *((_BYTE *)a3 + 104);
  uint64_t v11 = (std::__shared_weak_count *)a3[15];
  uint64_t v189 = a3[14];
  uint64_t v190 = v11;
  if (v11)
  {
    unsigned int v12 = (unint64_t *)&v11->__shared_owners_;
    do
      unint64_t v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
    BOOL v8 = v182;
  }

  __int128 v191 = *((_OWORD *)a3 + 8);
  uint64_t v192 = a3[18];
  char v193 = *((_BYTE *)a3 + 152);
  *(void *)&__int128 v194 = -78LL;
  LOBYTE(v233[0]) = 0;
  char v237 = 0;
  uint64_t v238 = v7;
  v239 = v8;
  if (v8)
  {
    unint64_t v14 = (unint64_t *)&v8->__shared_owners_;
    do
      unint64_t v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
  }

  *(_OWORD *)((char *)v240 + 9) = *(_OWORD *)&v183[9];
  v240[0] = *(_OWORD *)v183;
  __int128 v242 = v185;
  __int128 v243 = v186;
  uint64_t v241 = v184;
  char v245 = v188;
  __int128 v244 = v187;
  uint64_t v246 = v189;
  v247 = v190;
  if (v190)
  {
    uint64_t v16 = (unint64_t *)&v190->__shared_owners_;
    do
      unint64_t v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }

  uint64_t v18 = &v266;
  __int128 v248 = v191;
  char v250 = v193;
  uint64_t v249 = v192;
  v251[0] = v7;
  v251[1] = v182;
  if (v182)
  {
    uint64_t v19 = (unint64_t *)&v182->__shared_owners_;
    do
      unint64_t v20 = __ldxr(v19);
    while (__stxr(v20 + 1, v19));
  }

  *(_OWORD *)((char *)v252 + 9) = *(_OWORD *)&v183[9];
  v252[0] = *(_OWORD *)v183;
  __int128 v254 = v185;
  __int128 v255 = v186;
  uint64_t v253 = v184;
  __int128 v256 = v187;
  char v257 = v188;
  uint64_t v258 = v189;
  v259 = v190;
  if (v190)
  {
    size_t v21 = (unint64_t *)&v190->__shared_owners_;
    do
      unint64_t v22 = __ldxr(v21);
    while (__stxr(v22 + 1, v21));
  }

  uint64_t v137 = 0LL;
  char v262 = v193;
  __int128 v260 = v191;
  uint64_t v261 = v192;
  uint64_t v263 = a2;
  v264[0] = (uint64_t)&v265;
  v264[1] = 0LL;
  v264[2] = 16LL;
  LOBYTE(v266) = 0;
  char v267 = 0;
  v268 = &v271;
  uint64_t v269 = 0LL;
  uint64_t v270 = 16LL;
  uint64_t v272 = 0LL;
  v180[0] = (uint64_t)v233;
  v180[1] = (uint64_t)&v194;
  v180[2] = a2;
  while (!sub_10002B1FC((uint64_t)&v181, a4))
  {
    *(void *)&__int128 v179 = sub_1000BC43C(v6, *(unint64_t *)&v183[8]);
    *((void *)&v179 + 1) = v23;
    uint64_t v24 = *(void *)(v179 + 8);
    uint64_t v25 = *(void *)(v24 + 48);
    uint64_t v26 = *(unsigned int *)(v24 + 20);
    *(void *)&__int128 v273 = *(void *)(v179 + 352) + (v25 + v25 * v23) / (unint64_t)(v25 + 1) * v26;
    *((void *)&v273 + 1) = v273 + v26;
    v274[0] = 2;
    sub_10002C8E0((uint64_t)&v181, (uint64_t)&v273, a4, (uint64_t)&v154);
    if (sub_10002B1FC((uint64_t)&v154, (uint64_t)&v166))
    {
      *(void *)&__int128 v301 = "di_asif::details::table::read(ContextASIF &, const sg_vec::iterator &, const sg_vec::iterator &)";
      *((void *)&v301 + 1) = 29LL;
      LODWORD(v302) = 16;
      sub_1000C5268(&v273, &v301);
      sub_100004E4C(&v298, (uint64_t)"Couldn't trim entry in read ", 28LL);
      sub_100116CB8(&v298, &v181);
      std::ostream::~ostream(&v298, off_100180C50);
      sub_1000D42B0((uint64_t)&v273);
      std::ios::~ios(v299);
      *(void *)&__int128 v194 = -34LL;
      int v27 = 3;
    }

    else
    {
      if (v267 && !sub_1000C68E8(&v179, &v266) && (uint64_t v70 = sub_1000D4698((uint64_t)v233), v70 < 0) && (_DWORD)v70)
      {
        *(void *)&__int128 v149 = v70;
        *((void *)&v149 + 1) = v71;
        char v150 = v233;
        int v151 = 0;
        v152[0] = 0;
        char v153 = 0;
      }

      else
      {
        __int128 v266 = v179;
        char v267 = 1;
        unint64_t v28 = (unint64_t *)(*(void *)(v179 + 56) + 16LL * *((void *)&v179 + 1));
        BOOL v29 = sub_1000D6E20(v28);
        *(void *)&__int128 v301 = off_100189878;
        *((void *)&v301 + 1) = v28;
        LOBYTE(v302) = v29;
        if (v29)
        {
          uint64_t v30 = 0LL;
        }

        else
        {
          *(void *)&__int128 v220 = "di_asif::details::table::read(ContextASIF &, const sg_vec::iterator &, const sg_vec::iterator &)::data_entries_vectorizer_t::add_data_entry(const data_entry_t &)";
          *((void *)&v220 + 1) = 139LL;
          LODWORD(v221[0]) = 16;
          sub_1000D4768(&v273, &v220);
          sub_100004E4C(&v298, (uint64_t)"Couldn't lock entry ", 20LL);
          sub_1000BFD20(&v298, &v179);
          std::ostream::~ostream(&v298, off_100180E70);
          sub_1000D4958((uint64_t)&v273);
          std::ios::~ios(v299);
          uint64_t v30 = -5LL;
        }

        unint64_t v31 = atomic_load((unint64_t *)(*(void *)(v266 + 56) + 16LL * *((void *)&v266 + 1) + 8));
        *(void *)&__int128 v149 = v30;
        char v150 = v233;
        int v151 = v31 >> 62;
        sub_100116A14((uint64_t)v152, (uint64_t)&v301);
        char v153 = 1;
        sub_100116A88(&v301);
      }

      __int128 v194 = v149;
      if ((v149 & 0x8000000000000000LL) != 0 && (_DWORD)v194)
      {
LABEL_171:
        int v27 = 3;
      }

      else
      {
        switch(v151)
        {
          case 0:
          case 2:
            __int128 v32 = v154;
            if (*((void *)&v154 + 1))
            {
              unint64_t v33 = (unint64_t *)(*((void *)&v154 + 1) + 8LL);
              do
                unint64_t v34 = __ldxr(v33);
              while (__stxr(v34 + 1, v33));
            }

            *(_OWORD *)char v142 = v155[0];
            *(_OWORD *)&v142[9] = *(_OWORD *)((char *)v155 + 9);
            uint64_t v35 = v156;
            uint64_t v36 = v157;
            __int128 v143 = v158;
            __int128 v144 = v159;
            char v145 = v160;
            uint64_t v37 = *((void *)&v157 + 1);
            uint64_t v38 = v161;
            unint64_t v39 = v162;
            if (v162)
            {
              unint64_t v40 = (unint64_t *)&v162->__shared_owners_;
              do
                unint64_t v41 = __ldxr(v40);
              while (__stxr(v41 + 1, v40));
            }

            __int128 v146 = v163;
            unint64_t v147 = v164;
            char v148 = v165;
            uint64_t v42 = v166;
            char v43 = v167;
            if (v167)
            {
              unint64_t v44 = (unint64_t *)&v167->__shared_owners_;
              do
                unint64_t v45 = __ldxr(v44);
              while (__stxr(v45 + 1, v44));
            }

            *(_OWORD *)uint64_t v138 = v168[0];
            *(_OWORD *)&v138[9] = *(_OWORD *)((char *)v168 + 9);
            uint64_t v46 = v169;
            __int128 v47 = v170;
            uint64_t v48 = v174;
            __int128 v139 = v171;
            __int128 v140 = v172;
            char v141 = v173;
            uint64_t v49 = v175;
            if (v175)
            {
              unint64_t v50 = (unint64_t *)&v175->__shared_owners_;
              do
                unint64_t v51 = __ldxr(v50);
              while (__stxr(v51 + 1, v50));
            }

            uint64_t v52 = 0LL;
            int v53 = 0;
            uint64_t v54 = 0LL;
            __int128 v208 = v32;
            v209[0] = *(_OWORD *)v142;
            *(_OWORD *)((char *)v209 + 9) = *(_OWORD *)&v142[9];
            uint64_t v210 = v35;
            *(void *)&__int128 v211 = v36;
            __int128 v212 = v143;
            __int128 v213 = v144;
            char v214 = v145;
            *((void *)&v211 + 1) = v37;
            uint64_t v215 = v38;
            v216 = v39;
            __int128 v217 = v146;
            unint64_t v218 = v147;
            char v219 = v148;
            uint64_t v195 = v42;
            v196 = v43;
            v197[0] = *(_OWORD *)v138;
            *(_OWORD *)((char *)v197 + 9) = *(_OWORD *)&v138[9];
            uint64_t v198 = v46;
            __int128 v199 = v47;
            char v202 = v141;
            __int128 v200 = v139;
            __int128 v201 = v140;
            uint64_t v203 = v48;
            v204 = v49;
            __int128 v205 = v176;
            char v207 = v178;
            unint64_t v206 = v177;
            unint64_t v55 = v177;
            LOBYTE(v273) = 0;
            v299[160] = 0;
            while (!sub_10002B1FC((uint64_t)&v208, (uint64_t)&v195))
            {
              if (v218 >= v55 || v54 == -1) {
                break;
              }
              if (sub_1000B866C())
              {
                *(void *)&__int128 v231 = "details::for_each_sg_in_vec_internal(Fn &&, sg_vec_ref::iterator, sg_vec::iterator, size_t, BOOL) [Fn = (lambda at /Library/Caches/com.apple.xbs/Sources/DiskImages2/app/disk_images/formats/asif.cpp:1462:30)]";
                *((void *)&v231 + 1) = 104LL;
                int v232 = 2;
                sub_100035DF8(&v301, &v231);
                sub_100004E4C(&v306, (uint64_t)"sg: ", 4LL);
                sub_100116CB8(&v306, &v208);
                std::ostream::~ostream(&v306, off_100169EF0);
                sub_10003602C((uint64_t)&v301);
                std::ios::~ios(&v307);
              }

              *(void *)&__int128 v301 = 0LL;
              *((void *)&v301 + 1) = v55;
              LOBYTE(v302) = 2;
              sub_100072C74(&v208, (uint64_t)&v301, (uint64_t)&v231);
              int64_t v57 = sub_1000C69B4(&v179, &v231);
              unint64_t v59 = v57;
              BOOL v60 = v57 >= 0 || (_DWORD)v57 == 0;
              char v61 = v60;
              if (v60)
              {
                uint64_t v18 = (__int128 *)v58;
                if (!v53) {
                  uint64_t v52 = (__int128 *)v58;
                }
                if (sub_10002D4E0((uint64_t)&v208, (uint64_t)&v195, v58, v57))
                {
                  __int128 v220 = v208;
                  if (*((void *)&v208 + 1))
                  {
                    unint64_t v66 = (unint64_t *)(*((void *)&v208 + 1) + 8LL);
                    do
                      unint64_t v67 = __ldxr(v66);
                    while (__stxr(v67 + 1, v66));
                  }

                  v221[0] = v209[0];
                  *(_OWORD *)((char *)v221 + 9) = *(_OWORD *)((char *)v209 + 9);
                  __int128 v223 = v211;
                  __int128 v224 = v212;
                  __int128 v225 = v213;
                  char v226 = v214;
                  uint64_t v222 = v210;
                  v227[0] = v215;
                  v227[1] = v216;
                  if (v216)
                  {
                    char v68 = (unint64_t *)&v216->__shared_owners_;
                    do
                      unint64_t v69 = __ldxr(v68);
                    while (__stxr(v69 + 1, v68));
                  }

                  __int128 v228 = v217;
                  unint64_t v229 = v218;
                  char v230 = v219;
                  sub_10002D4A4((uint64_t)&v220, (uint64_t)&v195, (uint64_t)v18, v59, 0xFFFFFFFFFFFFFFFFLL, (uint64_t)&v301);
                  sub_100035EE0((uint64_t)&v273, (uint64_t)&v301);
                  sub_10002D4FC((uint64_t)&v301);
                  sub_1000114F0((uint64_t)v227);
                  sub_1000114F0((uint64_t)&v220);
                  sub_10002B7D4((uint64_t)&v273, (uint64_t)&v301);
                  sub_100035F24((uint64_t)&v208, (uint64_t)&v301);
                  sub_1000114F0((uint64_t)v305);
                  sub_1000114F0((uint64_t)&v301);
                  sub_10002B3A4((uint64_t)&v273, (uint64_t)&v301);
                  sub_100035F24((uint64_t)&v195, (uint64_t)&v301);
                  sub_1000114F0((uint64_t)v305);
                  sub_1000114F0((uint64_t)&v301);
                }

                sub_10002C52C((uint64_t)&v208, v59);
                v54 += v59;
                int v53 = 1;
              }

              else
              {
                else {
                  uint64_t v65 = -(int)v57;
                }
                uint64_t v136 = -v65;
              }

              unint64_t v62 = (std::__shared_weak_count *)*((void *)&v231 + 1);
              if (*((void *)&v231 + 1))
              {
                int64_t v63 = (unint64_t *)(*((void *)&v231 + 1) + 8LL);
                do
                  unint64_t v64 = __ldaxr(v63);
                while (__stlxr(v64 - 1, v63));
                if (!v64)
                {
                  ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
                  std::__shared_weak_count::__release_weak(v62);
                }
              }

              if ((v61 & 1) == 0) {
                goto LABEL_90;
              }
            }

            if (v53) {
              uint64_t v18 = v52;
            }
            else {
              uint64_t v18 = 0LL;
            }
            uint64_t v136 = v54;
LABEL_90:
            sub_10002D8BC((uint64_t)&v273);
            uint64_t v72 = v204;
            uint64_t v6 = a1;
            if (v204)
            {
              __int128 v73 = (unint64_t *)&v204->__shared_owners_;
              do
                unint64_t v74 = __ldaxr(v73);
              while (__stlxr(v74 - 1, v73));
              if (!v74)
              {
                ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
                std::__shared_weak_count::__release_weak(v72);
              }
            }

            unint64_t v75 = v196;
            uint64_t v5 = a2;
            if (v196)
            {
              unint64_t v76 = (unint64_t *)&v196->__shared_owners_;
              do
                unint64_t v77 = __ldaxr(v76);
              while (__stlxr(v77 - 1, v76));
              if (!v77)
              {
                ((void (*)(std::__shared_weak_count *))v75->__on_zero_shared)(v75);
                std::__shared_weak_count::__release_weak(v75);
              }
            }

            uint64_t v78 = v216;
            if (v216)
            {
              unint64_t v79 = (unint64_t *)&v216->__shared_owners_;
              do
                unint64_t v80 = __ldaxr(v79);
              while (__stlxr(v80 - 1, v79));
              if (!v80)
              {
                ((void (*)(std::__shared_weak_count *))v78->__on_zero_shared)(v78);
                std::__shared_weak_count::__release_weak(v78);
              }
            }

            int v81 = (std::__shared_weak_count *)*((void *)&v208 + 1);
            if (*((void *)&v208 + 1))
            {
              unint64_t v82 = (unint64_t *)(*((void *)&v208 + 1) + 8LL);
              do
                unint64_t v83 = __ldaxr(v82);
              while (__stlxr(v83 - 1, v82));
              if (!v83)
              {
                ((void (*)(std::__shared_weak_count *))v81->__on_zero_shared)(v81);
                std::__shared_weak_count::__release_weak(v81);
              }
            }

            *(void *)&__int128 v194 = v136;
            *((void *)&v194 + 1) = v18;
            uint64_t v18 = &v266;
            goto LABEL_169;
          case 1:
            goto LABEL_166;
          case 3:
            uint64_t v84 = *(void *)(v179 + 8);
            unint64_t v85 = (*(void *)(v179 + 352)
                 + (*(void *)(v84 + 48) + *(void *)(v84 + 48) * *((void *)&v179 + 1))
                 / (unint64_t)(*(void *)(v84 + 48) + 1LL)
            if (!v237)
            {
              uint64_t v86 = 0LL;
LABEL_115:
              *(void *)&__int128 v301 = 0LL;
              *((void *)&v301 + 1) = v6;
              v302 = &v304;
              __int128 v303 = xmmword_1001388C0;
              sub_1000BCED0(v6, v263, v85, 0, 1LL, (unint64_t *)&v220);
              sub_1000BD48C((unint64_t *)&v301, (unint64_t *)&v220);
              sub_1000BBEA0((unint64_t *)&v220);
              uint64_t v18 = &v266;
              if ((void)v301 && !*(_BYTE *)(v301 + 344))
              {
                sub_1000D5AFC((unint64_t *)&v273, (unint64_t *)&v301);
                *((void *)&v273 + 1) = *((void *)&v301 + 1);
                *(void *)v274 = &v274[24];
                *(_OWORD *)&v274[8] = xmmword_1001388C0;
                *(void *)&__int128 v220 = v302;
                *(void *)&__int128 v208 = &v302[40 * v303];
                sub_1000D5DFC((uint64_t *)v274, (uint64_t *)&v220, (uint64_t *)&v208);
                char v88 = 1;
              }

              else
              {
                uint64_t v87 = std::generic_category();
                char v88 = 0;
                *(void *)&__int128 v273 = 5LL;
                *((void *)&v273 + 1) = v87;
              }

              char v300 = v88;
              sub_1000D4F58((uint64_t)&v301);
              if (!v300)
              {
                else {
                  uint64_t v125 = -(int)v273;
                }
                uint64_t v86 = -v125;
                goto LABEL_164;
              }

              if (v237)
              {
                sub_1000D4F58((uint64_t)v233);
                char v237 = 0;
              }

              sub_1000D5AFC(v233, (unint64_t *)&v273);
              v233[1] = *((void *)&v273 + 1);
              v234 = &v236;
              __int128 v235 = xmmword_1001388C0;
              *(void *)&__int128 v301 = *(void *)v274;
              *(void *)&__int128 v220 = *(void *)v274 + 320LL * *(void *)&v274[8];
              sub_1000D5DFC((uint64_t *)&v234, (uint64_t *)&v301, (uint64_t *)&v220);
              char v237 = 1;
              if (v300) {
                sub_1000D4F58((uint64_t)&v273);
              }
              goto LABEL_129;
            }

            if (*(void *)(v233[0] + 40) == (v85
                                             - *(void *)(v6 + 352)
                                             / (unint64_t)*(unsigned __int16 *)(*(void *)(v6 + 8) + 18LL))
                                            / (*(void *)(*(void *)(v6 + 8) + 48LL)
                                             * (unint64_t)(*(_DWORD *)(*(void *)(v6 + 8) + 20LL)
                                                                / *(unsigned __int16 *)(*(void *)(v6 + 8) + 18LL))))
            {
              uint64_t v86 = 0LL;
              goto LABEL_129;
            }

            uint64_t v89 = sub_1000D4F04((uint64_t)v233);
            uint64_t v86 = v89;
            if (v89 < 0 && (_DWORD)v89)
            {
              uint64_t v18 = &v266;
              goto LABEL_164;
            }

            uint64_t v136 = v90;
            if (!v237) {
              goto LABEL_115;
            }
LABEL_129:
            __int128 v273 = v154;
            if (*((void *)&v154 + 1))
            {
              uint64_t v91 = (unint64_t *)(*((void *)&v154 + 1) + 8LL);
              do
                unint64_t v92 = __ldxr(v91);
              while (__stxr(v92 + 1, v91));
            }

            *(_OWORD *)v274 = v155[0];
            *(_OWORD *)&v274[9] = *(_OWORD *)((char *)v155 + 9);
            __int128 v276 = v157;
            __int128 v277 = v158;
            __int128 v278 = v159;
            char v279 = v160;
            uint64_t v275 = v156;
            uint64_t v280 = v161;
            v281 = v162;
            if (v162)
            {
              int v93 = (unint64_t *)&v162->__shared_owners_;
              do
                unint64_t v94 = __ldxr(v93);
              while (__stxr(v94 + 1, v93));
            }

            __int128 v282 = v163;
            unint64_t v283 = v164;
            char v284 = v165;
            uint64_t v285 = v166;
            v286 = v167;
            if (v167)
            {
              char v95 = (unint64_t *)&v167->__shared_owners_;
              do
                unint64_t v96 = __ldxr(v95);
              while (__stxr(v96 + 1, v95));
            }

            v287[0] = v168[0];
            *(_OWORD *)((char *)v287 + 9) = *(_OWORD *)((char *)v168 + 9);
            __int128 v289 = v170;
            __int128 v290 = v171;
            __int128 v291 = v172;
            char v292 = v173;
            uint64_t v288 = v169;
            uint64_t v293 = v174;
            v294 = v175;
            if (v175)
            {
              unint64_t v97 = (unint64_t *)&v175->__shared_owners_;
              do
                unint64_t v98 = __ldxr(v97);
              while (__stxr(v98 + 1, v97));
            }

            __int128 v295 = v176;
            unint64_t v296 = v177;
            char v297 = v178;
            if ((void)v235 == *((void *)&v235 + 1))
            {
              sub_1000D6108((uint64_t *)&v234, (uint64_t)&v234[40 * v235], 1LL, (uint64_t)&v273, &v301);
            }

            else
            {
              __n128 v99 = sub_1000D61B4((uint64_t)&v234[40 * v235], (uint64_t)&v273);
              *(void *)&__int128 v235 = v235 + 1;
            }

            unint64_t v100 = v294;
            if (v294)
            {
              uint64_t v101 = (unint64_t *)&v294->__shared_owners_;
              do
                unint64_t v102 = __ldaxr(v101);
              while (__stlxr(v102 - 1, v101));
              if (!v102)
              {
                ((void (*)(std::__shared_weak_count *, __n128))v100->__on_zero_shared)(v100, v99);
                std::__shared_weak_count::__release_weak(v100);
              }
            }

            unint64_t v103 = v286;
            if (v286)
            {
              v104 = (unint64_t *)&v286->__shared_owners_;
              do
                unint64_t v105 = __ldaxr(v104);
              while (__stlxr(v105 - 1, v104));
              if (!v105)
              {
                ((void (*)(std::__shared_weak_count *, __n128))v103->__on_zero_shared)(v103, v99);
                std::__shared_weak_count::__release_weak(v103);
              }
            }

            unint64_t v106 = v281;
            if (v281)
            {
              v107 = (unint64_t *)&v281->__shared_owners_;
              do
                unint64_t v108 = __ldaxr(v107);
              while (__stlxr(v108 - 1, v107));
              if (!v108)
              {
                ((void (*)(std::__shared_weak_count *, __n128))v106->__on_zero_shared)(v106, v99);
                std::__shared_weak_count::__release_weak(v106);
              }
            }

            uint64_t v109 = (std::__shared_weak_count *)*((void *)&v273 + 1);
            if (*((void *)&v273 + 1))
            {
              uint64_t v110 = (unint64_t *)(*((void *)&v273 + 1) + 8LL);
              do
                unint64_t v111 = __ldaxr(v110);
              while (__stlxr(v111 - 1, v110));
              if (!v111)
              {
                ((void (*)(std::__shared_weak_count *, __n128))v109->__on_zero_shared)(v109, v99);
                std::__shared_weak_count::__release_weak(v109);
              }
            }

            uint64_t v18 = &v266;
            uint64_t v90 = v136;
LABEL_164:
            *(void *)&__int128 v194 = v86;
            *((void *)&v194 + 1) = v90;
            if ((v86 & 0x8000000000000000LL) == 0 || !(_DWORD)v86)
            {
LABEL_166:
              sub_1000C5350(&v179, v5, (uint64_t)&v154, (uint64_t)&v166, v264, (unint64_t *)&v273);
              __int128 v194 = v273;
              if ((v273 & 0x8000000000000000LL) == 0 || !(_DWORD)v194) {
                v272 += *(void *)v274;
              }
            }

LABEL_169:
            uint64_t v112 = v194;
            if ((v194 & 0x8000000000000000LL) != 0 && (_DWORD)v194) {
              goto LABEL_171;
            }
            sub_10002C354((uint64_t)&v181, v194);
            v137 += v112;
            sub_1000D4850((uint64_t)v251, (uint64_t)&v181);
            int v27 = 0;
            break;
          default:
            goto LABEL_169;
        }
      }

      sub_1000C6270((uint64_t)&v149);
    }

    __int128 v113 = v175;
    if (v175)
    {
      __int128 v114 = (unint64_t *)&v175->__shared_owners_;
      do
        unint64_t v115 = __ldaxr(v114);
      while (__stlxr(v115 - 1, v114));
      if (!v115)
      {
        ((void (*)(std::__shared_weak_count *))v113->__on_zero_shared)(v113);
        std::__shared_weak_count::__release_weak(v113);
      }
    }

    __int128 v116 = v167;
    if (v167)
    {
      __int128 v117 = (unint64_t *)&v167->__shared_owners_;
      do
        unint64_t v118 = __ldaxr(v117);
      while (__stlxr(v118 - 1, v117));
      if (!v118)
      {
        ((void (*)(std::__shared_weak_count *))v116->__on_zero_shared)(v116);
        std::__shared_weak_count::__release_weak(v116);
      }
    }

    char v119 = v162;
    if (v162)
    {
      __int128 v120 = (unint64_t *)&v162->__shared_owners_;
      do
        unint64_t v121 = __ldaxr(v120);
      while (__stlxr(v121 - 1, v120));
      if (!v121)
      {
        ((void (*)(std::__shared_weak_count *))v119->__on_zero_shared)(v119);
        std::__shared_weak_count::__release_weak(v119);
      }
    }

    char v122 = (std::__shared_weak_count *)*((void *)&v154 + 1);
    if (!*((void *)&v154 + 1)) {
      goto LABEL_193;
    }
    uint64_t v123 = (unint64_t *)(*((void *)&v154 + 1) + 8LL);
    do
      unint64_t v124 = __ldaxr(v123);
    while (__stlxr(v124 - 1, v123));
    if (!v124)
    {
      ((void (*)(std::__shared_weak_count *))v122->__on_zero_shared)(v122);
      std::__shared_weak_count::__release_weak(v122);
      if (v27) {
        break;
      }
    }

    else
    {
LABEL_193:
      if (v27) {
        break;
      }
    }
  }

  if ((v194 & 0x8000000000000000LL) == 0 || !(_DWORD)v194)
  {
    *(void *)&__int128 v194 = v137;
    *((void *)&v194 + 1) = v133;
  }

  sub_1000C6330(v180);
  sub_1000C6380((uint64_t)v233);
  uint64_t v126 = v190;
  if (v190)
  {
    v127 = (unint64_t *)&v190->__shared_owners_;
    do
      unint64_t v128 = __ldaxr(v127);
    while (__stlxr(v128 - 1, v127));
    if (!v128)
    {
      ((void (*)(std::__shared_weak_count *))v126->__on_zero_shared)(v126);
      std::__shared_weak_count::__release_weak(v126);
    }
  }

  uint64_t v129 = v182;
  if (v182)
  {
    v130 = (unint64_t *)&v182->__shared_owners_;
    do
      unint64_t v131 = __ldaxr(v130);
    while (__stlxr(v131 - 1, v130));
    if (!v131)
    {
      ((void (*)(std::__shared_weak_count *))v129->__on_zero_shared)(v129);
      std::__shared_weak_count::__release_weak(v129);
    }
  }

  return v194;
}

void sub_1000C504C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
}

void *sub_1000C5268(void *a1, __int128 *a2)
{
  __int128 v3 = (std::ios_base *)(a1 + 46);
  sub_1000DF80C((uint64_t)a1, a2);
  *a1 = off_100180B88;
  a1[45] = &off_100180C88;
  a1[46] = &off_100180CB0;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_100180B88;
  a1[45] = off_100180C10;
  a1[46] = off_100180C38;
  return a1;
}

void sub_1000C52EC(_Unwind_Exception *a1)
{
}

uint64_t sub_1000C5310(uint64_t a1)
{
  return a1;
}

void sub_1000C5350( void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X4>, unint64_t *a6@<X8>)
{
  uint64_t v9 = *(void *)(*a1 + 8LL);
  uint64_t v10 = *(void *)(v9 + 48);
  uint64_t v11 = *(unsigned int *)(v9 + 20);
  *(void *)&__int128 v229 = *(void *)(*a1 + 352LL) + (v10 + v10 * a1[1]) / (unint64_t)(v10 + 1) * v11;
  *((void *)&v229 + 1) = v229 + v11;
  LOBYTE(v230[0]) = 2;
  sub_10002C8E0(a3, (uint64_t)&v229, a4, (uint64_t)&v149);
  if (sub_10002B1FC((uint64_t)&v149, (uint64_t)&v163))
  {
    *a6 = -34LL;
    a6[2] = 0LL;
  }

  else
  {
    uint64_t v12 = v149;
    if ((*(void *)(*(void *)(*a1 + 56LL) + 16LL * a1[1] + 8) & 0x7FFFFFFFFFFFFFLL)
       * *(unsigned int *)(*(void *)(*a1 + 8LL) + 20LL))
    {
      unint64_t v13 = v150;
      if (v150)
      {
        p_shared_owners = (unint64_t *)&v150->__shared_owners_;
        do
          unint64_t v15 = __ldxr(p_shared_owners);
        while (__stxr(v15 + 1, p_shared_owners));
      }

      *(_OWORD *)uint64_t v133 = v151[0];
      *(_OWORD *)&v133[9] = *(_OWORD *)((char *)v151 + 9);
      uint64_t v16 = v152;
      uint64_t v17 = v153;
      uint64_t v18 = v154;
      __int128 v134 = v155;
      __int128 v135 = v156;
      char v136 = v157;
      uint64_t v19 = v158;
      unint64_t v20 = v159;
      if (v159)
      {
        size_t v21 = (unint64_t *)&v159->__shared_owners_;
        do
          unint64_t v22 = __ldxr(v21);
        while (__stxr(v22 + 1, v21));
      }

      uint64_t v126 = a6;
      __int128 v137 = v160;
      unint64_t v138 = v161;
      char v139 = v162;
      __int128 v23 = v163;
      if (*((void *)&v163 + 1))
      {
        uint64_t v24 = (unint64_t *)(*((void *)&v163 + 1) + 8LL);
        do
          unint64_t v25 = __ldxr(v24);
        while (__stxr(v25 + 1, v24));
      }

      *(_OWORD *)uint64_t v129 = v164[0];
      *(_OWORD *)&v129[9] = *(_OWORD *)((char *)v164 + 9);
      uint64_t v26 = v165;
      __int128 v27 = v166;
      __int128 v130 = v167;
      __int128 v131 = v168;
      char v132 = v169;
      uint64_t v28 = v170;
      BOOL v29 = v171;
      if (v171)
      {
        uint64_t v30 = (unint64_t *)&v171->__shared_owners_;
        do
          unint64_t v31 = __ldxr(v30);
        while (__stxr(v31 + 1, v30));
      }

      unint64_t v127 = 0LL;
      unint64_t v32 = 0LL;
      int v33 = 0;
      unint64_t v34 = 0LL;
      v189[0] = *(_OWORD *)v133;
      *(_OWORD *)((char *)v189 + 9) = *(_OWORD *)&v133[9];
      __int128 v192 = v134;
      __int128 v193 = v135;
      __int128 v197 = v137;
      v176[0] = *(_OWORD *)v129;
      *(_OWORD *)((char *)v176 + 9) = *(_OWORD *)&v129[9];
      __int128 v180 = v131;
      __int128 v179 = v130;
      uint64_t v187 = v12;
      char v188 = v13;
      uint64_t v190 = v16;
      *(void *)&__int128 v191 = v17;
      *((void *)&v191 + 1) = v18;
      char v194 = v136;
      uint64_t v195 = v19;
      v196 = v20;
      unint64_t v198 = v138;
      char v199 = v139;
      __int128 v175 = v23;
      uint64_t v177 = v26;
      __int128 v178 = v27;
      char v181 = v132;
      uint64_t v182 = v28;
      __int128 v183 = v29;
      __int128 v184 = v172;
      char v186 = v174;
      unint64_t v185 = v173;
      unint64_t v35 = v173;
      LOBYTE(v229) = 0;
      char v242 = 0;
      while (!sub_10002B1FC((uint64_t)&v187, (uint64_t)&v175))
      {
        if (v198 >= v35 || v34 == -1LL) {
          break;
        }
        if (sub_1000B866C())
        {
          *(void *)&__int128 v245 = "details::for_each_sg_in_vec_internal(Fn &&, sg_vec_ref::iterator, sg_vec::iterator, size_t, BOOL) [Fn = (lambda at /Library/Caches/com.apple.xbs/Sources/DiskImages2/app/disk_images/formats/asif.cpp:1729:32)]";
          *((void *)&v245 + 1) = 104LL;
          LODWORD(v246) = 2;
          sub_100035DF8(&v211, &v245);
          sub_100004E4C(&v223, (uint64_t)"sg: ", 4LL);
          sub_100116CB8(&v223, &v187);
          std::ostream::~ostream(&v223, off_100169EF0);
          sub_10003602C((uint64_t)&v211);
          std::ios::~ios(&v224);
        }

        *(void *)&__int128 v211 = 0LL;
        *((void *)&v211 + 1) = v35;
        v212[0] = 2;
        sub_100072C74(&v187, (uint64_t)&v211, (uint64_t)&v225);
        int64_t v37 = v226;
        uint64_t v38 = *(void *)(*(void *)(*a1 + 56LL) + 16LL * a1[1] + 8);
        unint64_t v39 = *(unsigned int *)(*(void *)(*a1 + 8LL) + 20LL);
        unint64_t v40 = v227;
        uint64_t v41 = v228;
        __int128 v211 = v225;
        if (*((void *)&v225 + 1))
        {
          uint64_t v42 = (unint64_t *)(*((void *)&v225 + 1) + 8LL);
          do
            unint64_t v43 = __ldxr(v42);
          while (__stxr(v43 + 1, v42));
        }

        *(void *)__int128 v212 = v37;
        *(void *)&v212[8] = v40 % v39 + (v38 & 0x7FFFFFFFFFFFFFLL) * v39;
        *(void *)&v212[16] = v41;
        v212[24] = 0;
        uint64_t v44 = (*(uint64_t (**)(void))(**(void **)(a2 + 16) + 40LL))(*(void *)(a2 + 16));
        v243[0] = 0LL;
        v243[1] = v44;
        char v244 = 2;
        sub_100072C74(&v211, (uint64_t)v243, (uint64_t)&v245);
        if (v246)
        {
          (*(void (**)(void *__return_ptr, void, __int128 *))(**(void **)(a2 + 16) + 128LL))( v243,  *(void *)(a2 + 16),  &v245);
          uint64_t v45 = a5[1];
          if (v45 == a5[2])
          {
            sub_10004D74C(a5, *a5 + 40 * v45, 1LL, (uint64_t)v243, &v247);
          }

          else
          {
            sub_10003C7B8(*a5 + 40 * v45, (uint64_t)v243);
            ++a5[1];
          }

          v127 += v246;
        }

        unint64_t v46 = v227;
        int64_t v47 = v226;
        uint64_t v48 = (std::__shared_weak_count *)*((void *)&v245 + 1);
        if (*((void *)&v245 + 1))
        {
          uint64_t v49 = (unint64_t *)(*((void *)&v245 + 1) + 8LL);
          do
            unint64_t v50 = __ldaxr(v49);
          while (__stlxr(v50 - 1, v49));
          if (!v50)
          {
            ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
            std::__shared_weak_count::__release_weak(v48);
          }
        }

        unint64_t v51 = (std::__shared_weak_count *)*((void *)&v211 + 1);
        if (*((void *)&v211 + 1))
        {
          uint64_t v52 = (unint64_t *)(*((void *)&v211 + 1) + 8LL);
          do
            unint64_t v53 = __ldaxr(v52);
          while (__stlxr(v53 - 1, v52));
          if (!v53)
          {
            ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
            std::__shared_weak_count::__release_weak(v51);
          }
        }

        BOOL v54 = v47 >= 0 || (_DWORD)v47 == 0;
        char v55 = v54;
        if (v54)
        {
          if (!v33) {
            unint64_t v32 = v46;
          }
          if (sub_10002D4E0((uint64_t)&v187, (uint64_t)&v175, v46, v47))
          {
            v200[0] = v187;
            v200[1] = v188;
            if (v188)
            {
              BOOL v60 = (unint64_t *)&v188->__shared_owners_;
              do
                unint64_t v61 = __ldxr(v60);
              while (__stxr(v61 + 1, v60));
            }

            v201[0] = v189[0];
            *(_OWORD *)((char *)v201 + 9) = *(_OWORD *)((char *)v189 + 9);
            __int128 v203 = v191;
            __int128 v204 = v192;
            __int128 v205 = v193;
            char v206 = v194;
            uint64_t v202 = v190;
            v207[0] = v195;
            v207[1] = v196;
            if (v196)
            {
              unint64_t v62 = (unint64_t *)&v196->__shared_owners_;
              do
                unint64_t v63 = __ldxr(v62);
              while (__stxr(v63 + 1, v62));
            }

            __int128 v208 = v197;
            unint64_t v209 = v198;
            char v210 = v199;
            sub_10002D4A4((uint64_t)v200, (uint64_t)&v175, v46, v47, 0xFFFFFFFFFFFFFFFFLL, (uint64_t)&v211);
            sub_100035EE0((uint64_t)&v229, (uint64_t)&v211);
            sub_10002D4FC((uint64_t)&v211);
            sub_1000114F0((uint64_t)v207);
            sub_1000114F0((uint64_t)v200);
            sub_10002B7D4((uint64_t)&v229, (uint64_t)&v211);
            sub_100035F24((uint64_t)&v187, (uint64_t)&v211);
            sub_1000114F0((uint64_t)&v218);
            sub_1000114F0((uint64_t)&v211);
            sub_10002B3A4((uint64_t)&v229, (uint64_t)&v211);
            sub_100035F24((uint64_t)&v175, (uint64_t)&v211);
            sub_1000114F0((uint64_t)&v218);
            sub_1000114F0((uint64_t)&v211);
          }

          sub_10002C52C((uint64_t)&v187, v47);
          v34 += v47;
          int v33 = 1;
        }

        else
        {
          else {
            uint64_t v59 = -(int)v47;
          }
          unint64_t v125 = -v59;
        }

        uint64_t v56 = (std::__shared_weak_count *)*((void *)&v225 + 1);
        if (*((void *)&v225 + 1))
        {
          int64_t v57 = (unint64_t *)(*((void *)&v225 + 1) + 8LL);
          do
            unint64_t v58 = __ldaxr(v57);
          while (__stlxr(v58 - 1, v57));
          if (!v58)
          {
            ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
            std::__shared_weak_count::__release_weak(v56);
          }
        }

        if ((v55 & 1) == 0) {
          goto LABEL_76;
        }
      }

      if (v33) {
        unint64_t v46 = v32;
      }
      else {
        unint64_t v46 = 0LL;
      }
      unint64_t v125 = v34;
LABEL_76:
      sub_10002D8BC((uint64_t)&v229);
      unint64_t v64 = v183;
      if (v183)
      {
        uint64_t v65 = (unint64_t *)&v183->__shared_owners_;
        do
          unint64_t v66 = __ldaxr(v65);
        while (__stlxr(v66 - 1, v65));
        if (!v66)
        {
          ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
          std::__shared_weak_count::__release_weak(v64);
        }
      }

      unint64_t v67 = (std::__shared_weak_count *)*((void *)&v175 + 1);
      if (*((void *)&v175 + 1))
      {
        char v68 = (unint64_t *)(*((void *)&v175 + 1) + 8LL);
        do
          unint64_t v69 = __ldaxr(v68);
        while (__stlxr(v69 - 1, v68));
        if (!v69)
        {
          ((void (*)(std::__shared_weak_count *))v67->__on_zero_shared)(v67);
          std::__shared_weak_count::__release_weak(v67);
        }
      }

      uint64_t v70 = v196;
      if (v196)
      {
        uint64_t v71 = (unint64_t *)&v196->__shared_owners_;
        do
          unint64_t v72 = __ldaxr(v71);
        while (__stlxr(v72 - 1, v71));
        if (!v72)
        {
          ((void (*)(std::__shared_weak_count *))v70->__on_zero_shared)(v70);
          std::__shared_weak_count::__release_weak(v70);
        }
      }

      __int128 v73 = v188;
      if (v188)
      {
        unint64_t v74 = (unint64_t *)&v188->__shared_owners_;
        do
          unint64_t v75 = __ldaxr(v74);
        while (__stlxr(v75 - 1, v74));
        if (!v75)
        {
          ((void (*)(std::__shared_weak_count *))v73->__on_zero_shared)(v73);
          std::__shared_weak_count::__release_weak(v73);
        }
      }

      unint64_t *v126 = v125;
      v126[1] = v46;
      if ((v125 & 0x8000000000000000LL) != 0 && (_DWORD)v125) {
        v126[2] = 0LL;
      }
      else {
        v126[2] = v127;
      }
    }

    else
    {
      unint64_t v76 = v150;
      __int128 v140 = v150;
      if (v150)
      {
        unint64_t v77 = (unint64_t *)&v150->__shared_owners_;
        do
          unint64_t v78 = __ldxr(v77);
        while (__stxr(v78 + 1, v77));
      }

      *(_OWORD *)char v141 = v151[0];
      *(_OWORD *)&v141[9] = *(_OWORD *)((char *)v151 + 9);
      uint64_t v79 = v152;
      uint64_t v80 = v153;
      uint64_t v81 = v154;
      __int128 v142 = v155;
      __int128 v143 = v156;
      char v144 = v157;
      uint64_t v82 = v158;
      unint64_t v83 = v159;
      char v145 = v159;
      if (v159)
      {
        uint64_t v84 = (unint64_t *)&v159->__shared_owners_;
        do
          unint64_t v85 = __ldxr(v84);
        while (__stxr(v85 + 1, v84));
      }

      __int128 v146 = v160;
      unint64_t v147 = v161;
      char v148 = v162;
      *(void *)&__int128 v229 = v12;
      *((void *)&v229 + 1) = v76;
      if (v76)
      {
        uint64_t v86 = (unint64_t *)&v76->__shared_owners_;
        do
          unint64_t v87 = __ldxr(v86);
        while (__stxr(v87 + 1, v86));
      }

      v230[0] = *(_OWORD *)v141;
      *(_OWORD *)((char *)v230 + 9) = *(_OWORD *)&v141[9];
      __int128 v234 = v142;
      uint64_t v231 = v79;
      uint64_t v232 = v80;
      uint64_t v233 = v81;
      __int128 v235 = v143;
      char v236 = v144;
      uint64_t v237 = v82;
      uint64_t v238 = v83;
      if (v83)
      {
        char v88 = (unint64_t *)&v83->__shared_owners_;
        do
          unint64_t v89 = __ldxr(v88);
        while (__stxr(v89 + 1, v88));
      }

      __int128 v239 = v146;
      unint64_t v240 = v147;
      char v241 = v148;
      __int128 v211 = v163;
      if (*((void *)&v163 + 1))
      {
        uint64_t v90 = (unint64_t *)(*((void *)&v163 + 1) + 8LL);
        do
          unint64_t v91 = __ldxr(v90);
        while (__stxr(v91 + 1, v90));
      }

      *(_OWORD *)__int128 v212 = v164[0];
      *(_OWORD *)&v212[9] = *(_OWORD *)((char *)v164 + 9);
      uint64_t v213 = v165;
      __int128 v214 = v166;
      __int128 v215 = v167;
      __int128 v216 = v168;
      char v217 = v169;
      uint64_t v218 = v170;
      char v219 = v171;
      if (v171)
      {
        unint64_t v92 = (unint64_t *)&v171->__shared_owners_;
        do
          unint64_t v93 = __ldxr(v92);
        while (__stxr(v93 + 1, v92));
      }

      __int128 v220 = v172;
      unint64_t v221 = v173;
      char v222 = v174;
      unint64_t v94 = sub_1000D6F98((uint64_t (*)(__int128 *))sub_100072C48, &v229, &v211, 0xFFFFFFFFFFFFFFFFLL);
      unint64_t v96 = v95;
      unint64_t v97 = v219;
      if (v219)
      {
        unint64_t v98 = (unint64_t *)&v219->__shared_owners_;
        do
          unint64_t v99 = __ldaxr(v98);
        while (__stlxr(v99 - 1, v98));
        if (!v99)
        {
          ((void (*)(std::__shared_weak_count *))v97->__on_zero_shared)(v97);
          std::__shared_weak_count::__release_weak(v97);
        }
      }

      unint64_t v100 = (std::__shared_weak_count *)*((void *)&v211 + 1);
      if (*((void *)&v211 + 1))
      {
        uint64_t v101 = (unint64_t *)(*((void *)&v211 + 1) + 8LL);
        do
          unint64_t v102 = __ldaxr(v101);
        while (__stlxr(v102 - 1, v101));
        if (!v102)
        {
          ((void (*)(std::__shared_weak_count *))v100->__on_zero_shared)(v100);
          std::__shared_weak_count::__release_weak(v100);
        }
      }

      unint64_t v103 = v238;
      if (v238)
      {
        v104 = (unint64_t *)&v238->__shared_owners_;
        do
          unint64_t v105 = __ldaxr(v104);
        while (__stlxr(v105 - 1, v104));
        if (!v105)
        {
          ((void (*)(std::__shared_weak_count *))v103->__on_zero_shared)(v103);
          std::__shared_weak_count::__release_weak(v103);
        }
      }

      unint64_t v106 = (std::__shared_weak_count *)*((void *)&v229 + 1);
      if (*((void *)&v229 + 1))
      {
        v107 = (unint64_t *)(*((void *)&v229 + 1) + 8LL);
        do
          unint64_t v108 = __ldaxr(v107);
        while (__stlxr(v108 - 1, v107));
        if (!v108)
        {
          ((void (*)(std::__shared_weak_count *))v106->__on_zero_shared)(v106);
          std::__shared_weak_count::__release_weak(v106);
        }
      }

      *a6 = v94;
      a6[1] = v96;
      a6[2] = 0LL;
      if (v145)
      {
        uint64_t v109 = (unint64_t *)&v145->__shared_owners_;
        do
          unint64_t v110 = __ldaxr(v109);
        while (__stlxr(v110 - 1, v109));
        if (!v110)
        {
          ((void (*)(std::__shared_weak_count *))v145->__on_zero_shared)(v145);
          std::__shared_weak_count::__release_weak(v145);
        }
      }

      if (v140)
      {
        unint64_t v111 = (unint64_t *)&v140->__shared_owners_;
        do
          unint64_t v112 = __ldaxr(v111);
        while (__stlxr(v112 - 1, v111));
        if (!v112)
        {
          ((void (*)(std::__shared_weak_count *))v140->__on_zero_shared)(v140);
          std::__shared_weak_count::__release_weak(v140);
        }
      }
    }
  }

  __int128 v113 = v171;
  if (v171)
  {
    __int128 v114 = (unint64_t *)&v171->__shared_owners_;
    do
      unint64_t v115 = __ldaxr(v114);
    while (__stlxr(v115 - 1, v114));
    if (!v115)
    {
      ((void (*)(std::__shared_weak_count *))v113->__on_zero_shared)(v113);
      std::__shared_weak_count::__release_weak(v113);
    }
  }

  __int128 v116 = (std::__shared_weak_count *)*((void *)&v163 + 1);
  if (*((void *)&v163 + 1))
  {
    __int128 v117 = (unint64_t *)(*((void *)&v163 + 1) + 8LL);
    do
      unint64_t v118 = __ldaxr(v117);
    while (__stlxr(v118 - 1, v117));
    if (!v118)
    {
      ((void (*)(std::__shared_weak_count *))v116->__on_zero_shared)(v116);
      std::__shared_weak_count::__release_weak(v116);
    }
  }

  char v119 = v159;
  if (v159)
  {
    __int128 v120 = (unint64_t *)&v159->__shared_owners_;
    do
      unint64_t v121 = __ldaxr(v120);
    while (__stlxr(v121 - 1, v120));
    if (!v121)
    {
      ((void (*)(std::__shared_weak_count *))v119->__on_zero_shared)(v119);
      std::__shared_weak_count::__release_weak(v119);
    }
  }

  char v122 = v150;
  if (v150)
  {
    uint64_t v123 = (unint64_t *)&v150->__shared_owners_;
    do
      unint64_t v124 = __ldaxr(v123);
    while (__stlxr(v124 - 1, v123));
    if (!v124)
    {
      ((void (*)(std::__shared_weak_count *))v122->__on_zero_shared)(v122);
      std::__shared_weak_count::__release_weak(v122);
    }
  }

void sub_1000C6160( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, char a49)
{
}

uint64_t sub_1000C6270(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 56))
  {
    uint64_t v2 = *(void *)(a1 + 16);
    if (*(_BYTE *)(v2 + 6184) && (*(_DWORD *)(a1 + 24) | 2) != 2)
    {
      uint64_t v3 = *(void *)(v2 + 6200);
      if (v3 == *(void *)(v2 + 6208))
      {
        sub_1000D6518((uint64_t *)(v2 + 6192), *(void *)(v2 + 6192) + 24 * v3, 1LL, a1 + 32, &v5);
      }

      else
      {
        sub_100116A14(*(void *)(v2 + 6192) + 24 * v3, a1 + 32);
        ++*(void *)(v2 + 6200);
      }
    }

    if (*(_BYTE *)(a1 + 56)) {
      sub_100116A88(a1 + 32);
    }
  }

  return a1;
}

uint64_t *sub_1000C6330(uint64_t *a1)
{
  uint64_t v2 = sub_1000D4F04(*a1);
  if (v2 < 0)
  {
    if ((_DWORD)v2)
    {
      uint64_t v4 = (uint64_t *)a1[1];
      if ((*v4 & 0x8000000000000000LL) == 0 || !*v4)
      {
        uint64_t *v4 = v2;
        v4[1] = v3;
      }
    }
  }

  return a1;
}

uint64_t sub_1000C6380(uint64_t a1)
{
  if (*(void *)(a1 + 5520))
  {
    uint64_t v2 = *(void **)(a1 + 5504);
  }

  sub_1000114F0(a1 + 5440);
  sub_1000114F0(a1 + 5328);
  sub_1000114F0(a1 + 5280);
  sub_1000114F0(a1 + 5168);
  if (*(_BYTE *)(a1 + 5160)) {
    sub_1000D4F58(a1);
  }
  return a1;
}

uint64_t sub_1000C6418(uint64_t a1)
{
  uint64_t v3 = *(void *)(*(void *)(a1 + 8) + 24LL);
  unint64_t v14 = off_10017E998;
  uint64_t v15 = v3;
  uint64_t v4 = (uint64_t)&v16;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(v3 + 16) + 72LL))(&v16);
  if ((*(_BYTE *)(v15 + 8) & 1) != 0)
  {
    char v6 = 0;
    uint64_t v4 = 4294967290LL;
  }

  else
  {
    LODWORD(v5) = (*(uint64_t (**)(uint64_t, void))(*(void *)v16 + 16LL))(v16, 0LL);
    if ((_DWORD)v5)
    {
      sub_10009C63C((uint64_t)&v14);
      exception = __cxa_allocate_exception(0x40uLL);
      uint64_t v12 = exception;
      else {
        uint64_t v5 = -(int)v5;
      }
      void *exception = &off_100189E78;
      unint64_t v13 = std::generic_category();
      v12[1] = v5;
      v12[2] = v13;
      *((_BYTE *)v12 + 24) = 0;
      *((_BYTE *)v12 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
      v12[7] = "Can't flush asif on bitmap close, backend flush failed";
    }

    sub_1000C0A40(a1, (uint64_t)&v14);
    char v6 = 1;
  }

  unint64_t v14 = off_10017E998;
  uint64_t v7 = v17;
  if (v17)
  {
    p_shared_owners = (unint64_t *)&v17->__shared_owners_;
    do
      unint64_t v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
      if ((v6 & 1) == 0) {
        return v4;
      }
      return 0LL;
    }
  }

  if ((v6 & 1) != 0) {
    return 0LL;
  }
  return v4;
}

void *sub_1000C6624(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000DF888((uint64_t)a1, a2);
  *a1 = off_100180FC8;
  a1[45] = &off_1001810C8;
  a1[46] = &off_1001810F0;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_100180FC8;
  a1[45] = off_100181050;
  a1[46] = off_100181078;
  return a1;
}

void sub_1000C66A8(_Unwind_Exception *a1)
{
}

uint64_t sub_1000C66CC(uint64_t a1)
{
  return a1;
}

unint64_t sub_1000C670C(void *a1, uint64_t a2, char a3, unint64_t a4, uint64_t a5, int a6)
{
  if (a5 != a4)
  {
    unint64_t v10 = sub_1000C67C8(a2, a4, a5 - a4);
    unsigned int v11 = v10;
    unint64_t v12 = HIDWORD(v10);
    uint64_t v13 = (uint64_t)(a1 + 4);
    if (a6)
    {
      __int16 v17 = a3 & 1 | (((a3 & 2) != 0) << 8);
      unint64_t v14 = sub_10008F744(v13, v11, v12, (unsigned __int8 *)&v17);
    }

    else
    {
      __int16 v16 = a3 & 1 | (((a3 & 2) != 0) << 8);
      unint64_t v14 = sub_10008F514(v13, v11, v12, (unsigned __int8 *)&v16);
    }

    return *(void *)(a2 + 352)
         + *a1
         / (unint64_t)(*(void *)(*(void *)(a2 + 8) + 48LL) + 1LL)
         * *(void *)(*(void *)(a2 + 8) + 48LL)
  }

  return a4;
}

unint64_t sub_1000C67C8(uint64_t a1, unint64_t a2, unint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  unint64_t v4 = *(unsigned __int16 *)(v3 + 18);
  if (v4 <= a3) {
    unint64_t v5 = a3;
  }
  else {
    unint64_t v5 = *(unsigned __int16 *)(v3 + 18);
  }
  if (!a3) {
    unint64_t v5 = 0LL;
  }
  uint64_t v6 = *(unsigned int *)(v3 + 20);
  uint64_t v7 = *(void *)(v3 + 48);
  return ((2
         * ((a2
                         - (*(void *)(a1 + 352)
                          + v7
                          * v6
                          * ((a2 / v4 - *(void *)(a1 + 352) / v4)
                           / (v7
                            * (unint64_t)(v6 / v4)))))
                        / v4)) | (((v5
                                  + a2
                                  - v4
                                  - (*(void *)(a1 + 352)
                                   + ((v5 + a2 - v4) / v4 - *(void *)(a1 + 352) / v4)
                                   / (v7
                                    * (unint64_t)(v6 / v4))
                                   * v7
                                   * v6))
                                 / v4) << 33))
       + 0x200000000LL;
}

uint64_t sub_1000C6848@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v4 = (unint64_t *)result;
  while (*v4)
  {
LABEL_9:
    __n128 result = sub_1000D6EAC(v4, 1);
    if ((result & 1) == 0)
    {
      char v7 = 0;
      goto LABEL_11;
    }
  }

  while (1)
  {
    unint64_t v6 = __ldaxr(v4);
    if (!v6) {
      break;
    }
    __clrex();
LABEL_8:
    if (v6) {
      goto LABEL_9;
    }
  }

  if (__stlxr(0xFFFFFFFFFFFFFFFFLL, v4)) {
    goto LABEL_8;
  }
  char v7 = 1;
LABEL_11:
  *(_BYTE *)(a3 + 16) = v7;
  *(void *)a3 = off_100189898;
  *(void *)(a3 + _Block_object_dispose((const void *)(v2 - 120), 8) = v4;
  *(void *)(a3 + 24) = a2;
  return result;
}

BOOL sub_1000C68E8(void *a1, void *a2)
{
  uint64_t v2 = *(unsigned int *)(*(void *)(*a1 + 8LL) + 20LL);
  uint64_t v3 = (*(void *)(*(void *)(*a1 + 56LL) + 16LL * a1[1] + 8) & 0x7FFFFFFFFFFFFFLL) * v2;
  uint64_t v4 = (*(void *)(*(void *)(*a2 + 56LL) + 16LL * a2[1] + 8) & 0x7FFFFFFFFFFFFFLL)
     * *(unsigned int *)(*(void *)(*a2 + 8LL) + 20LL);
  if (v3) {
    BOOL v5 = v4 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  return v5 || v3 == v4 + v2;
}

uint64_t sub_1000C694C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (!v1) {
    return 0LL;
  }
  LODWORD(sub_1000989E4((uint64_t *)va, v2) = 0;
  uint64_t v3 = *(unsigned int **)a1;
  uint64_t v4 = 40 * v1;
  while (1)
  {
    uint64_t v5 = sub_100038120(v3);
    if ((v5 & 0x80000000) != 0) {
      break;
    }
    uint64_t v2 = (v5 + v2);
    v3 += 10;
    v4 -= 40LL;
    if (!v4) {
      return v2;
    }
  }

  return v5;
}

size_t sub_1000C69B4(void *a1, void *a2)
{
  uint64_t v2 = *(void *)(*a1 + 8LL);
  uint64_t v3 = *(void *)(v2 + 48);
  uint64_t v4 = *(unsigned int *)(v2 + 20);
  v10[0] = *(void *)(*a1 + 352LL) + (v3 + v3 * a1[1]) / (unint64_t)(v3 + 1) * v4;
  v10[1] = v10[0] + v4;
  char v11 = 2;
  sub_100072C74(a2, (uint64_t)v10, (uint64_t)&v12);
  if (v14)
  {
    bzero(v12, v14);
    size_t v5 = v14;
  }

  else
  {
    size_t v5 = -34LL;
  }

  unint64_t v6 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

  return v5;
}

uint64_t sub_1000C6A80(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!*(_BYTE *)(a1 + 113)) {
    goto LABEL_23;
  }
  *(_BYTE *)(a1 + 113) = 0;
  uint64_t v6 = *(void *)(a1 + 16);
  if (!v6) {
    goto LABEL_23;
  }
  uint64_t v9 = *(void *)(a1 + 40);
  unint64_t v10 = (std::__shared_weak_count *)*((void *)sub_100118DDC() + 1);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
    uint64_t v22 = v9;
    __int128 v23 = v10;
    do
      unint64_t v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
    uint64_t v24 = a4;
    uint64_t v25 = v6;
    uint64_t v26 = a4;
    char v27 = 1;
    do
      unint64_t v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  else
  {
    uint64_t v22 = v9;
    __int128 v23 = 0LL;
    uint64_t v24 = a4;
    uint64_t v25 = v6;
    uint64_t v26 = a4;
    char v27 = 1;
  }

  int v15 = (*(uint64_t (**)(void, uint64_t *))(**(void **)(a2 + 16) + 80LL))(*(void *)(a2 + 16), &v22);
  uint64_t v16 = v24;
  if (v24 != v15)
  {
    *(_BYTE *)(a1 + 113) = 1;
    sub_10009C63C(a2);
    if (v15 < 0) {
      a4 = v15;
    }
    else {
      a4 = -v15;
    }
  }

  __int16 v17 = v23;
  if (v23)
  {
    uint64_t v18 = (unint64_t *)&v23->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  if (v16 == v15)
  {
LABEL_23:
    a4 = 0LL;
    if (a3)
    {
      if (*(_BYTE *)(a1 + 112))
      {
        *(_BYTE *)(a1 + sub_1000114F0(v4 - 112) = 0;
        sub_1000BDF84(a3, *(void *)a1, *(void *)(a1 + 16));
        a4 = 0LL;
        if (!*(void *)(a1 + 16))
        {
          uint64_t v20 = *(void *)(a1 + 24);
          if (v20) {
            sub_1000BC968(a3, v20);
          }
          return 0LL;
        }
      }
    }
  }

  return a4;
}

void sub_1000C6C30( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

unint64_t sub_1000C6C44(unint64_t result, uint64_t a2, char **a3)
{
  unint64_t v3 = *(unsigned __int16 *)(*(void *)(a2 + 8) + 18LL);
  uint64_t v4 = a3[3];
  unint64_t v5 = (unint64_t)v4 / v3 * v3;
  unint64_t v6 = (unint64_t)&v4[(void)a3[2]];
  unint64_t v7 = (v3 + v6 - 1) / v3 * v3;
  if (v5 < v7)
  {
    uint64_t v9 = (void *)result;
    unint64_t v10 = (unint64_t)v4 % v3;
    char v11 = *a3;
    do
    {
      unint64_t v12 = sub_1000C670C(v9, a2, 1, v5, v7, 1);
      unint64_t v13 = v12;
      if (v6 >= v12) {
        unint64_t v14 = v12;
      }
      else {
        unint64_t v14 = v6;
      }
      unint64_t v15 = v5 + v10;
      if (v14 >= v5 + v10)
      {
        else {
          size_t v16 = (size_t)&(*a3)[a3[2] - v11];
        }
        bzero(v11, v16);
      }

      __n128 result = sub_1000C670C(v9, a2, 1, v13, v7, 0);
      unint64_t v5 = result;
      if (result < v14 + v10)
      {
        unint64_t v17 = 0LL;
      }

      else
      {
        unint64_t v10 = 0LL;
        unint64_t v17 = result - v15;
      }

      v11 += v17;
    }

    while (result < v6);
  }

  return result;
}

void sub_1000C6D64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 40);
  uint64_t v7 = *(unsigned int *)(*(void *)(a3 + 8) + 20LL);
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = (std::__shared_weak_count *)*((void *)sub_100118DDC() + 1);
  uint64_t v21 = v6;
  uint64_t v22 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }

  uint64_t v23 = v7;
  uint64_t v24 = v8;
  uint64_t v25 = v7;
  char v26 = 0;
  int v12 = (*(uint64_t (**)(void, uint64_t *))(**(void **)(a2 + 16) + 88LL))(*(void *)(a2 + 16), &v21);
  if (v23 != v12)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    uint64_t v18 = exception;
    if (v12 < 0) {
      uint64_t v19 = v12;
    }
    else {
      uint64_t v19 = -v12;
    }
    void *exception = &off_100189E78;
    uint64_t v20 = std::generic_category();
    v18[1] = v19;
    void v18[2] = v20;
    *((_BYTE *)v18 + 24) = 0;
    *((_BYTE *)v18 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
    v18[7] = "Can't load bitmap from backend";
  }

  if (*(void *)(*(void *)(a3 + 8) + 48LL)
     * (*(_DWORD *)(*(void *)(a3 + 8) + 20LL)
      / *(unsigned __int16 *)(*(void *)(a3 + 8) + 18LL)))
  {
    unint64_t v13 = 0LL;
    do
    {
      sub_1000BD19C(a1, v13);
      v13 += 2LL;
    }

    while (*(void *)(*(void *)(a3 + 8) + 48LL)
  }

  unint64_t v14 = v22;
  if (v22)
  {
    unint64_t v15 = (unint64_t *)&v22->__shared_owners_;
    do
      unint64_t v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }

void sub_1000C6EE4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1000C6EFC(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, char a6)
{
  *(void *)a1 = a4;
  uint64_t v9 = *(void *)(a3 + 8);
  uint64_t v10 = *(void *)(v9 + 48);
  uint64_t v11 = *(unsigned int *)(v9 + 20);
  *(void *)(a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = *(void *)(a3 + 352) + a4 / (v10 + 1) * v10 * v11;
  *(void *)(a1 + 16) = a5;
  *(void *)(a1 + 24) = 0LL;
  char v12 = a6 ^ 1;
  sub_100070FCC((void *)(a1 + 32), 2 * v10 * (v11 / *(unsigned __int16 *)(v9 + 18)), a6 ^ 1);
  *(void *)(a1 + 120) = 850045863LL;
  *(_WORD *)(a1 + sub_1000114F0(v4 - 112) = 0;
  *(_OWORD *)(a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(void *)(a1 + 176) = 0LL;
  if ((v12 & 1) != 0)
  {
    sub_1000C6D64(a1, a2, a3);
  }

  else
  {
    *(_WORD *)(a1 + sub_1000114F0(v4 - 112) = 257;
    sub_1000D02DC(v16, a3, *(void *)a1);
    unint64_t v13 = (unint64_t *)(*(void *)(v16[0] + 56LL) + 16LL * v16[1] + 8);
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 | 0x8000000000000000LL, v13));
  }

  return a1;
}

void sub_1000C7000(_Unwind_Exception *a1)
{
  *(void *)(v1 + sub_1000114F0(v6 - 32) = off_1001731C0;
  sub_100071324((uint64_t *)(v1 + 56));
  _Unwind_Resume(a1);
}

uint64_t sub_1000C702C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((*(_BYTE *)(*(void *)(a2 + 8) + 8LL) & 1) == 0)
  {
    uint64_t v8 = (std::mutex *)(a1 + 120);
    std::mutex::lock((std::mutex *)(a1 + 120));
    int v9 = (*(uint64_t (**)(void, void))(**(void **)(a2 + 16) + 16LL))(*(void *)(a2 + 16), 0LL);
    if (v9)
    {
      sub_10009C63C(a2);
      exception = __cxa_allocate_exception(0x40uLL);
      uint64_t v19 = exception;
      if (v9 < 0) {
        uint64_t v20 = v9;
      }
      else {
        uint64_t v20 = -v9;
      }
      void *exception = &off_100189E78;
      uint64_t v21 = std::generic_category();
      v19[1] = v20;
      v19[2] = v21;
      *((_BYTE *)v19 + 24) = 0;
      *((_BYTE *)v19 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
      v19[7] = "Can't flush asif on bitmap close, backend flush failed";
    }

    if (!a3) {
      goto LABEL_28;
    }
    sub_1000D02DC(&v22, a3, *(void *)a1);
    uint64_t v10 = (unint64_t *)(*(void *)(v22 + 56) + 16 * v23 + 8);
    do
      unint64_t v11 = __ldaxr(v10);
    while (__stlxr(v11 & 0x7FFFFFFFFFFFFFFFLL, v10));
    if ((v11 & 0x8000000000000000LL) != 0)
    {
      int v12 = 1;
    }

    else
    {
LABEL_28:
      if (*(_BYTE *)(a1 + 113))
      {
        int v12 = 0;
      }

      else
      {
        int v12 = 0;
        if (!*(_BYTE *)(a1 + 112))
        {
          uint64_t v13 = 0LL;
LABEL_20:
          std::mutex::unlock(v8);
          return v13;
        }
      }
    }

    uint64_t v13 = sub_1000C6A80(a1, a2, a3, a4);
    if ((_DWORD)v13) {
      int v14 = v12;
    }
    else {
      int v14 = 0;
    }
    if (a3 && v14)
    {
      sub_1000D02DC(&v22, a3, *(void *)a1);
      unint64_t v15 = (unint64_t *)(*(void *)(v22 + 56) + 16 * v23 + 8);
      do
        unint64_t v16 = __ldaxr(v15);
      while (__stlxr(v16 | 0x8000000000000000LL, v15));
    }

    goto LABEL_20;
  }

  return 4294967290LL;
}

void sub_1000C71CC(_Unwind_Exception *a1)
{
}

void sub_1000C71EC( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, int a5@<W4>, char a6@<W5>, unint64_t *a7@<X8>)
{
  unint64_t v19 = a4;
  *a7 = 0LL;
  if (a4 || a5)
  {
    sub_1000C7374(a1 + 280, a3, a6, &v18);
    sub_1000C755C(a7, &v18);
    sub_1000BB354(&v18);
    unint64_t v12 = *a7;
    if (*a7) {
      LOBYTE(v12) = *(_BYTE *)(v12 + 520) == 0;
    }
    if ((v12 & 1) != 0 || (a6 & 1) != 0)
    {
      if (!*a7 || (unsigned int v13 = atomic_load((unsigned int *)(*a7 + 24)), v13 != 2))
      {
        if (!*a7 || !*(_BYTE *)(*a7 + 520))
        {
          if (v19 | (*(void *)(*(void *)(a1 + 152) + 8 * a3) * *(unsigned int *)(a1 + 20)))
          {
            if (v19) {
              unint64_t v14 = v19;
            }
            else {
              unint64_t v14 = *(void *)(*(void *)(a1 + 152) + 8 * a3) * *(unsigned int *)(a1 + 20);
            }
            unint64_t v18 = *(void *)(a1 + 80) * a3;
            unint64_t v19 = v14;
            sub_1000C7614((uint64_t *)a7, a1, (void *)(a2 + 16), &v19, (uint64_t *)&v18);
          }

          else
          {
            uint64_t v15 = sub_1000BD544((unsigned int *)a1, a2, 1);
            uint64_t v17 = *(void *)(a1 + 80) * a3;
            unint64_t v18 = v15;
            unsigned __int8 v16 = 1;
            sub_1000C75A0((uint64_t *)a7, a1, (void *)(a2 + 16), &v18, &v17, &v16);
            *(void *)(*(void *)(a1 + 152) + 8 * a3) = v18 / *(unsigned int *)(a1 + 20);
          }
        }
      }
    }
  }

void sub_1000C734C(_Unwind_Exception *a1)
{
}

unint64_t *sub_1000C7374@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, unint64_t *a4@<X8>)
{
  unsigned __int8 v16 = 0LL;
  uint64_t v17 = a2;
  sub_1000DF904(a1, a2, a3, &v14);
  if (v14 && !*(_BYTE *)(v14 + 520) || v14 && *(_BYTE *)(v14 + 520))
  {
    *a4 = 0LL;
    do
      unint64_t v7 = __ldaxr(&v14);
    while (__stlxr(0LL, &v14));
LABEL_21:
    atomic_store(v7, a4);
    return sub_1000BB354(&v14);
  }

  if (*(_BYTE *)(a1 + 912) && v15 != (void *)(a1 + 936))
  {
    do
    {
      sub_1000DFDC4(a1, a2, &v12);
      unsigned __int8 v16 = v12;
      sub_1000C755C(&v14, &v13);
      sub_1000BB354(&v13);
      if (v14)
      {
        if (!*(_BYTE *)(v14 + 520)) {
          break;
        }
      }

      uint64_t v8 = (unint64_t *)sub_1000DFF50((void *)a1);
      if (v8)
      {
        unsigned __int8 v16 = v8;
        sub_1000DFFF4(a1, v8, a2, (unint64_t *)&v12);
        sub_1000C755C(&v14, (unint64_t *)&v12);
        sub_1000BB354((unint64_t *)&v12);
        break;
      }
    }

    while (*(_BYTE *)(a1 + 912));
    std::mutex::lock((std::mutex *)(a1 + 952));
    int v9 = sub_1000DC3D8((uint64_t **)(a1 + 928), v15, (unint64_t *)&v17, &v17, (uint64_t *)&v16);
    if (!v10) {
      v9[5] = (uint64_t)v16;
    }
    std::condition_variable::notify_all((std::condition_variable *)(a1 + 1016));
    std::mutex::unlock((std::mutex *)(a1 + 952));
    sub_1000DD3DC(a1, 0, 0LL, 0);
    *a4 = 0LL;
    do
      unint64_t v7 = __ldaxr(&v14);
    while (__stlxr(0LL, &v14));
    goto LABEL_21;
  }

  *a4 = 0LL;
  return sub_1000BB354(&v14);
}

void sub_1000C751C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

unint64_t *sub_1000C755C(unint64_t *a1, unint64_t *a2)
{
  if (a2 != a1)
  {
    do
      unint64_t v3 = __ldaxr(a2);
    while (__stlxr(0LL, a2));
    sub_1000BB354(a1);
    atomic_store(v3, a1);
  }

  return a1;
}

void sub_1000C75A0( uint64_t *a1, uint64_t a2, void *a3, unint64_t *a4, uint64_t *a5, unsigned __int8 *a6)
{
}

void sub_1000C75CC( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (*v10)
  {
    uint64_t v11 = *(void *)(*v10 + 464);
    if (v11)
    {
      a10 = *v10;
      (*(void (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)v11 + 48LL))(v11, &a10, v10);
    }
  }

  __cxa_rethrow();
}

void sub_1000C7600(_Unwind_Exception *a1)
{
}

void sub_1000C7614(uint64_t *a1, uint64_t a2, void *a3, unint64_t *a4, uint64_t *a5)
{
}

void sub_1000C7640( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (*v10)
  {
    uint64_t v11 = *(void *)(*v10 + 464);
    if (v11)
    {
      a10 = *v10;
      (*(void (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)v11 + 48LL))(v11, &a10, v10);
    }
  }

  __cxa_rethrow();
}

void sub_1000C7674(_Unwind_Exception *a1)
{
}

unint64_t *sub_1000C7688@<X0>( unint64_t *result@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t v4 = atomic_load(result);
  if (v4 && *(void *)(v4 + 32) == a2)
  {
    uint64_t v6 = (unint64_t *)atomic_load(result);
    sub_1000E02CC(&v9, v6, 1);
    if (v9 && !*(_BYTE *)(v9 + 520))
    {
      uint64_t v7 = *(void *)(v9 + 32);
      *a3 = 0LL;
      if (v7 == a2)
      {
        do
          unint64_t v8 = __ldaxr(&v9);
        while (__stlxr(0LL, &v9));
        atomic_store(v8, a3);
      }
    }

    else
    {
      *a3 = 0LL;
    }

    return sub_1000BB354(&v9);
  }

  else
  {
    *a3 = 0LL;
  }

  return result;
}

void *sub_1000C7728(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000E0DB8((uint64_t)a1, a2);
  *a1 = off_1001811E8;
  a1[45] = &off_1001812E8;
  a1[46] = &off_100181310;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_1001811E8;
  a1[45] = off_100181270;
  a1[46] = off_100181298;
  return a1;
}

void sub_1000C77AC(_Unwind_Exception *a1)
{
}

uint64_t sub_1000C77D0(uint64_t a1)
{
  return a1;
}

void *sub_1000C7810(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000E0E34((uint64_t)a1, a2);
  *a1 = off_100181408;
  a1[45] = &off_100181508;
  a1[46] = &off_100181530;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_100181408;
  a1[45] = off_100181490;
  a1[46] = off_1001814B8;
  return a1;
}

void sub_1000C7894(_Unwind_Exception *a1)
{
}

uint64_t sub_1000C78B8(uint64_t a1)
{
  return a1;
}

uint64_t sub_1000C78F8(uint64_t a1, uint64_t a2)
{
  int v4 = sub_1000DB150(a1 + 2080, 0, 0LL, 0);
  if (v4 == -1) {
    return 4294967282LL;
  }
  if (v4 == 1)
  {
    LODWORD(result) = (*(uint64_t (**)(void, void))(**(void **)(a2 + 16) + 16LL))( *(void *)(a2 + 16),  0LL);
    int v6 = result;
    uint64_t result = (int)result < 0 ? result : -(int)result;
    if (v6) {
      return result;
    }
  }

  int v7 = sub_1000DD3DC(a1 + 280, 0, 0LL, 0);
  if (v7 == -1) {
    return 4294967282LL;
  }
  if (v7 != 1) {
    return 0LL;
  }
  LODWORD(result) = (*(uint64_t (**)(void, void))(**(void **)(a2 + 16) + 16LL))( *(void *)(a2 + 16),  0LL);
  int v8 = result;
  uint64_t result = (int)result < 0 ? result : -(int)result;
  if (!v8) {
    return 0LL;
  }
  return result;
}

uint64_t sub_1000C79B4(uint64_t a1, uint64_t a2, uint64_t (***a3)())
{
  __int128 v45 = 0u;
  __int128 v46 = 0u;
  __int128 v44 = 0u;
  int v6 = (std::mutex *)(a1 + 3792);
  std::mutex::lock((std::mutex *)(a1 + 3792));
  __int128 v7 = *(_OWORD *)(a1 + 3744);
  *(_OWORD *)(a1 + 3744) = 0u;
  __int128 v8 = *(_OWORD *)(a1 + 3760);
  __int128 v44 = v7;
  __int128 v45 = v8;
  *(_OWORD *)(a1 + 3760) = 0u;
  __int128 v9 = v46;
  __int128 v46 = *(_OWORD *)(a1 + 3776);
  *(_OWORD *)(a1 + 3776) = v9;
  std::mutex::unlock(v6);
  size_t v10 = (*(void *)(a1 + 160) - *(void *)(a1 + 152) + (unint64_t)*(unsigned __int16 *)(a1 + 18) + 7)
  uint64_t v11 = valloc(v10);
  if (!v11)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    unint64_t v43 = std::bad_alloc::bad_alloc(exception);
  }

  int64_t v47 = &off_10017F7E0;
  unint64_t v50 = &v47;
  unint64_t v53 = v11;
  sub_1000172D0((uint64_t)&v54, (uint64_t)&v47);
  unint64_t v12 = v50;
  if (v50 == &v47)
  {
    uint64_t v13 = 4LL;
    unint64_t v12 = &v47;
    goto LABEL_6;
  }

  if (v50)
  {
    uint64_t v13 = 5LL;
LABEL_6:
    ((void (*)(uint64_t (***)()))(*v12)[v13])(v12);
  }

  unint64_t v14 = v53;
  unint64_t v15 = *(void *)(a1 + 3608);
  *(void *)(a1 + 360_Block_object_dispose((const void *)(v2 - 120), 8) = v15 + 1;
  *unint64_t v14 = bswap64(v15);
  unsigned __int8 v16 = v14 + 1;
  uint64_t v17 = *(unint64_t **)(a1 + 152);
  unint64_t v18 = *(unint64_t **)(a1 + 160);
  while (v17 != v18)
  {
    unint64_t v19 = *v17++;
    *v16++ = bswap64(v19);
  }

  bzero(v16, (size_t)v53 + v10 - (void)v16);
  sub_1000C7D98(a1 + 2080);
  sub_1000C7E40(a1 + 280);
  uint64_t v20 = sub_1000C78F8(a1, a2);
  if (!(_DWORD)v20)
  {
    uint64_t v22 = (uint64_t)v53;
    uint64_t v23 = (std::__shared_weak_count *)*((void *)sub_100118DDC() + 1);
    int64_t v47 = (uint64_t (**)())v22;
    uint64_t v48 = v23;
    if (v23)
    {
      p_shared_owners = (unint64_t *)&v23->__shared_owners_;
      do
        unint64_t v25 = __ldxr(p_shared_owners);
      while (__stxr(v25 + 1, p_shared_owners));
    }

    size_t v49 = v10;
    unint64_t v50 = a3;
    size_t v51 = v10;
    char v52 = 0;
    int v26 = (*(uint64_t (**)(void, uint64_t (***)()))(**(void **)(a2 + 16) + 80LL))( *(void *)(a2 + 16),  &v47);
    if (v10 == v26)
    {
      char v27 = (unint64_t **)(*((void *)&v44 + 1) + 8 * ((unint64_t)v46 >> 9));
      if ((void)v45 == *((void *)&v44 + 1))
      {
        uint64_t v28 = 0LL;
        uint64_t v30 = 0LL;
        BOOL v29 = (char *)(*((void *)&v44 + 1) + 8LL * ((*((void *)&v46 + 1) + (void)v46) >> 9));
      }

      else
      {
        uint64_t v28 = &(*v27)[v46 & 0x1FF];
        BOOL v29 = (char *)(*((void *)&v44 + 1) + 8LL * ((*((void *)&v46 + 1) + (void)v46) >> 9));
        uint64_t v30 = (unint64_t *)(*(void *)v29 + 8 * ((*((void *)&v46 + 1) + v46) & 0x1FF));
      }

      sub_1000C18EC((unint64_t *)a1, v27, v28, v29, v30, a2);
      uint64_t v20 = 1LL;
    }

    else
    {
      *(void *)(a1 + 360_Block_object_dispose((const void *)(v2 - 120), 8) = v15;
      std::mutex::lock(v6);
      unint64_t v31 = *(void *)(a1 + 3776) + *(void *)(a1 + 3784);
      uint64_t v32 = *(void *)(a1 + 3752);
      int v33 = (char *)(v32 + 8 * (v31 >> 9));
      if (*(void *)(a1 + 3760) == v32) {
        uint64_t v34 = 0LL;
      }
      else {
        uint64_t v34 = *(void *)v33 + 8 * (v31 & 0x1FF);
      }
      unint64_t v35 = (char *)(*((void *)&v44 + 1) + 8 * ((unint64_t)v46 >> 9));
      if ((void)v45 == *((void *)&v44 + 1))
      {
        uint64_t v36 = 0LL;
        uint64_t v38 = 0LL;
        int64_t v37 = (char *)(*((void *)&v44 + 1) + 8LL * ((*((void *)&v46 + 1) + (void)v46) >> 9));
      }

      else
      {
        uint64_t v36 = (char *)(*(void *)v35 + 8 * (v46 & 0x1FF));
        int64_t v37 = (char *)(*((void *)&v44 + 1) + 8LL * ((*((void *)&v46 + 1) + (void)v46) >> 9));
        uint64_t v38 = (char *)(*(void *)v37 + 8 * ((*((void *)&v46 + 1) + v46) & 0x1FF));
      }

      sub_1000C18B8((void **)(a1 + 3744), v33, v34, v35, v36, v37, v38);
      if (v26 >= 0) {
        uint64_t v20 = 4294967291LL;
      }
      else {
        uint64_t v20 = v26;
      }
      std::mutex::unlock(v6);
    }

    unint64_t v39 = v48;
    if (v48)
    {
      unint64_t v40 = (unint64_t *)&v48->__shared_owners_;
      do
        unint64_t v41 = __ldaxr(v40);
      while (__stlxr(v41 - 1, v40));
      if (!v41)
      {
        ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
        std::__shared_weak_count::__release_weak(v39);
      }
    }
  }

  sub_100016DE0((uint64_t *)&v53);
  sub_1000BBD1C(&v44);
  return v20;
}

void sub_1000C7D44( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21)
{
}

void sub_1000C7D98(uint64_t a1)
{
  if (atomic_load((unint64_t *)(a1 + 608)))
  {
    unint64_t v3 = (unint64_t *)(a1 + 616);
    do
      unint64_t v4 = __ldaxr(v3);
    while (__stlxr(v4 + 1, v3));
    v8.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 624);
    v8.__owns_ = 1;
    std::mutex::lock((std::mutex *)(a1 + 624));
    do
      unint64_t v7 = __ldaxr(v3);
    while (__stlxr(v7 - 1, v3));
    if (v8.__owns_) {
      std::mutex::unlock(v8.__m_);
    }
  }

void sub_1000C7E40(uint64_t a1)
{
  if (atomic_load((unint64_t *)(a1 + 784)))
  {
    unint64_t v3 = (unint64_t *)(a1 + 792);
    do
      unint64_t v4 = __ldaxr(v3);
    while (__stlxr(v4 + 1, v3));
    v8.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 800);
    v8.__owns_ = 1;
    std::mutex::lock((std::mutex *)(a1 + 800));
    do
      unint64_t v7 = __ldaxr(v3);
    while (__stlxr(v7 - 1, v3));
    if (v8.__owns_) {
      std::mutex::unlock(v8.__m_);
    }
  }

uint64_t sub_1000C7EE8(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, int a5)
{
  uint64_t v8 = *(void *)(a4 + 144) - a3[18];
  unint64_t v9 = a3[3];
  size_t v10 = (std::__shared_weak_count *)a3[1];
  uint64_t v56 = *a3;
  int64_t v57 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }

  v58[0] = *((_OWORD *)a3 + 1);
  uint64_t v13 = v8 & ~(v8 >> 63);
  *(_OWORD *)((char *)v58 + 9) = *(_OWORD *)((char *)a3 + 25);
  uint64_t v59 = a3[6];
  __int128 v60 = *(_OWORD *)(a3 + 7);
  __int128 v61 = *(_OWORD *)(a3 + 9);
  __int128 v62 = *(_OWORD *)(a3 + 11);
  char v63 = *((_BYTE *)a3 + 104);
  unint64_t v14 = (std::__shared_weak_count *)a3[15];
  uint64_t v64 = a3[14];
  uint64_t v65 = v14;
  if (v14)
  {
    unint64_t v15 = (unint64_t *)&v14->__shared_owners_;
    do
      unint64_t v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }

  uint64_t v17 = 0LL;
  __int128 v66 = *((_OWORD *)a3 + 8);
  uint64_t v67 = a3[18];
  char v68 = *((_BYTE *)a3 + 152);
  int v18 = a5 ^ 1;
  while (1)
  {
    uint64_t v19 = v9 / *(void *)(a1 + 80);
    sub_1000BE844(a1, a2, v19, v18, 1, &v55);
    if (v55 && *(_BYTE *)(v55 + 520))
    {
      if ((a5 & 1) == 0) {
        sub_10009C63C(a2);
      }
      int v20 = 1;
      uint64_t v5 = -5LL;
      goto LABEL_38;
    }

    sub_10002D010((uint64_t)&v56, *(void *)(a1 + 80) + *(void *)(a1 + 80) * v19, a4, 0LL, (uint64_t)&v48);
    if (!v55 || *(_BYTE *)(v55 + 520))
    {
      unint64_t v21 = 0LL;
      do
      {
        size_t v22 = v50;
        bzero(v48, v50);
        sub_10002C52C((uint64_t)&v48, v22);
        v21 += v22;
      }

      while (!sub_10002B1FC((uint64_t)&v48, (uint64_t)&v52));
      goto LABEL_17;
    }

    if (a5)
    {
      if (*(_BYTE *)(v55 + 400)) {
        uint64_t v35 = v55 + 40;
      }
      else {
        uint64_t v35 = 0LL;
      }
      uint64_t v37 = sub_1000C39E8(v35, a2, (uint64_t *)&v48, (uint64_t)&v52);
      uint64_t v5 = v37;
      if ((v37 & 0x8000000000000000LL) == 0 || !(_DWORD)v37) {
        goto LABEL_55;
      }
    }

    else
    {
      if (*(_BYTE *)(v55 + 400)) {
        uint64_t v36 = v55 + 40;
      }
      else {
        uint64_t v36 = 0LL;
      }
      unint64_t v38 = sub_1000C1A40(v36, a2, (uint64_t *)&v48, (uint64_t)&v52);
      uint64_t v5 = v38;
      if ((v38 & 0x8000000000000000LL) == 0 || !(_DWORD)v38)
      {
LABEL_55:
        unint64_t v21 = v5;
LABEL_17:
        sub_10002C354((uint64_t)&v56, v21);
        int v20 = 0;
        v9 += v21;
        v17 += v21;
        goto LABEL_18;
      }

      sub_10009C63C(a2);
    }

    int v20 = 1;
LABEL_18:
    uint64_t v23 = v54;
    if (v54)
    {
      uint64_t v24 = (unint64_t *)&v54->__shared_owners_;
      do
        unint64_t v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }

    int v26 = v53;
    if (v53)
    {
      char v27 = (unint64_t *)&v53->__shared_owners_;
      do
        unint64_t v28 = __ldaxr(v27);
      while (__stlxr(v28 - 1, v27));
      if (!v28)
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
      }
    }

    BOOL v29 = v51;
    if (v51)
    {
      uint64_t v30 = (unint64_t *)&v51->__shared_owners_;
      do
        unint64_t v31 = __ldaxr(v30);
      while (__stlxr(v31 - 1, v30));
      if (!v31)
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
    }

    uint64_t v32 = v49;
    if (v49)
    {
      int v33 = (unint64_t *)&v49->__shared_owners_;
      do
        unint64_t v34 = __ldaxr(v33);
      while (__stlxr(v34 - 1, v33));
      if (!v34)
      {
        ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
        std::__shared_weak_count::__release_weak(v32);
      }
    }

void sub_1000C82F8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

double sub_1000C8348@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = (*(_BYTE *)(a1 + 32) & 1) + *(void *)(a1 + 24);
  v10[0] = *(void *)(a1 + 40);
  v10[1] = v3;
  char v11 = 2;
  *(void *)&__int128 v8 = qword_1001985E0;
  *((void *)&v8 + 1) = qword_1001985E0;
  LOBYTE(v9) = 2;
  unsigned int v4 = sub_1000C83F8(*(void *)(a1 + 64), *(void *)(a1 + 56), v10, (uint64_t)&v8);
  if (v4 >= 3)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    unint64_t v7 = (void *)sub_100004870((uint64_t)exception, (uint64_t)"Can't convert ASIF flag.", 5u);
  }

  double result = *(double *)&v8;
  *(_OWORD *)a2 = v8;
  *(void *)(a2 + 16) = v9;
  *(_DWORD *)(a2 + 24) = v4;
  return result;
}

unint64_t sub_1000C83F8(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  unint64_t v7 = 0LL;
  *(void *)&__int128 v32 = *a3;
  *((void *)&v32 + 1) = v32;
  uint64_t v29 = qword_1001985E0;
  uint64_t v30 = qword_1001985E0;
  unsigned __int8 v33 = 2;
  char v31 = 2;
  __int128 v27 = *(_OWORD *)a3;
  uint64_t v28 = a3[2];
  do
  {
    if ((_BYTE)v28)
    {
      if (v28 == 3)
      {
        unint64_t v9 = *((void *)&v27 + 1);
        uint64_t v8 = v27;
      }

      else
      {
        unint64_t v9 = *((void *)&v27 + 1);
        uint64_t v8 = v27;
      }
    }

    else
    {
      unint64_t v9 = *((void *)&v27 + 1);
      uint64_t v8 = v27;
      if ((unint64_t)v27 >= *((void *)&v27 + 1) || (unint64_t)(v27 + 1) >= *((void *)&v27 + 1))
      {
LABEL_5:
        if (!qword_1001985E0) {
          break;
        }
        goto LABEL_12;
      }
    }

void sub_1000C86B8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

unint64_t sub_1000C86DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v5 = *(void *)a3;
  unint64_t v6 = *(void *)(a3 + 8);
  unsigned int v7 = *(unsigned __int8 *)(a3 + 16);
  v62[0] = *(_DWORD *)(a3 + 17);
  *(_DWORD *)((char *)v62 + 3) = *(_DWORD *)(a3 + 20);
  if ((v7 & 2) != 0) {
    unint64_t v8 = v5;
  }
  else {
    unint64_t v8 = v5 + 1;
  }
  unint64_t v9 = (void *)sub_1000BC43C(a1, v8 * *(unsigned __int16 *)(*(void *)(a1 + 8) + 18LL));
  unint64_t v11 = atomic_load((unint64_t *)(v9[7] + 16 * v10 + 8));
  unint64_t v48 = v11 >> 62;
  if (v11 >> 62 == 3)
  {
    uint64_t v12 = v9[1];
    sub_1000BCED0( a1,  a2,  (v9[44] + (*(void *)(v12 + 48) + *(void *)(v12 + 48) * v10)
     / (unint64_t)(*(void *)(v12 + 48) + 1LL)
     * *(unsigned int *)(v12 + 20))
    / *(unsigned __int16 *)(v12 + 18),
      0,
      1LL,
      v55);
    uint64_t v13 = *(void *)(a1 + 8);
    if (v55[0])
    {
      if (*(_BYTE *)(v55[0] + 224)) {
        uint64_t v15 = v55[0] + 40;
      }
      else {
        uint64_t v15 = 0LL;
      }
    }

    else
    {
      uint64_t v15 = 0LL;
    }

    unint64_t v14 = *(unsigned __int16 *)(v13 + 18);
    unint64_t v48 = sub_1000BD19C( v15,  2 * ((v8 * v14 - (*(void *)(a1 + 352)
             + *(void *)(v13 + 48)
             * *(unsigned int *)(v13 + 20)
             * ((v8 * v14 / v14 - *(void *)(a1 + 352) / v14)
              / (*(void *)(v13 + 48)
    sub_1000BBEA0(v55);
  }

  while (1)
  {
    if ((_BYTE)v7)
    {
      if (v7 == 3)
      {
        if (v6 >= v5) {
          goto LABEL_17;
        }
      }

      else if (v6 > v5)
      {
        goto LABEL_17;
      }
    }

    else if (v6 > v5 && v5 + 1 < v6)
    {
LABEL_17:
      goto LABEL_21;
    }

    if (!qword_1001985E0) {
      goto LABEL_41;
    }
LABEL_21:
    if ((v7 & 2) != 0) {
      unint64_t v16 = v5;
    }
    else {
      unint64_t v16 = v5 + 1;
    }
    uint64_t v17 = *(void *)(a1 + 8);
    unint64_t v18 = v16 * *(unsigned __int16 *)(v17 + 18);
    if (v18 >= *(void *)(v17 + 80) + *(void *)(a1 + 352)) {
      goto LABEL_41;
    }
    uint64_t v19 = (void *)sub_1000BC43C(a1, v18);
    unint64_t v21 = v19;
    uint64_t v22 = v20;
    __int128 v60 = v19;
    uint64_t v61 = v20;
    uint64_t v23 = *(unsigned __int16 *)(*(void *)(a1 + 8) + 18LL);
    uint64_t v24 = v19[1];
    unint64_t v25 = (*(void *)(v24 + 48) + *(void *)(v24 + 48) * v20) / (unint64_t)(*(void *)(v24 + 48) + 1LL);
    uint64_t v26 = *(unsigned int *)(v24 + 20);
    else {
      unint64_t v27 = v19[44] + v26 + v25 * v26;
    }
    uint64_t v28 = (unint64_t *)(v19[7] + 16 * v20);
    BOOL v29 = sub_1000D6E20(v28);
    v58[0] = off_100189878;
    v58[1] = v28;
    BOOL v59 = v29;
    if (!v29)
    {
      *(void *)&__int128 v53 = "di_asif::details::table::get_next_extent(ContextASIF &, const interval_sectors &, interval_sectors &)";
      *((void *)&v53 + 1) = 40LL;
      int v54 = 16;
      sub_1000C8C84(v55, &v53);
      sub_100004E4C(v57, (uint64_t)"Couldn't lock entry ", 20LL);
      sub_1000BFD20(v57, &v60);
      sub_1000C8D2C((uint64_t)v55);
      exception = __cxa_allocate_exception(0x40uLL);
      void *exception = &off_100189E78;
      unint64_t v41 = std::generic_category();
      exception[1] = 5LL;
      exception[2] = v41;
      *((_BYTE *)exception + 24) = 0;
      *((_BYTE *)exception + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
      exception[7] = "Can't lock entry";
    }

    unint64_t v30 = atomic_load((unint64_t *)(v21[7] + 16 * v22 + 8));
    unint64_t v31 = v30 >> 62;
    if ((_DWORD)v48 == (_DWORD)v31)
    {
      uint64_t v32 = *(void *)(a1 + 8);
      unint64_t v47 = v27 / *(unsigned __int16 *)(v32 + 18);
      goto LABEL_39;
    }

    if ((_DWORD)v31 != 3) {
      break;
    }
    uint64_t v33 = v60[1];
    sub_1000BCED0( a1,  a2,  (v60[44] + (*(void *)(v33 + 48) + *(void *)(v33 + 48) * v61)
     / (unint64_t)(*(void *)(v33 + 48) + 1LL)
     * *(unsigned int *)(v33 + 20))
    / *(unsigned __int16 *)(v33 + 18),
      0,
      1LL,
      &v52);
    if (!v52 || *(_BYTE *)(v52 + 344))
    {
      *(void *)&__int128 v53 = "di_asif::details::table::get_next_extent(ContextASIF &, const interval_sectors &, interval_sectors &)";
      *((void *)&v53 + 1) = 40LL;
      int v54 = 16;
      sub_1000C8D6C(v55, &v53);
      sub_100004E4C(v57, (uint64_t)"Can't read bitmap", 17LL);
      sub_1000C8E14((uint64_t)v55);
      uint64_t v42 = __cxa_allocate_exception(0x40uLL);
      void *v42 = &off_100189E78;
      unint64_t v43 = std::generic_category();
      v42[1] = 5LL;
      v42[2] = v43;
      *((_BYTE *)v42 + 24) = 0;
      *((_BYTE *)v42 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
      v42[7] = "Can't read bitmap";
    }

    unint64_t v34 = *(_BYTE *)(v52 + 224) ? (void *)(v52 + 40) : 0LL;
    unint64_t v35 = sub_1000C670C(v34, a1, v48, v18, v27, 0);
    unint64_t v36 = *(unsigned __int16 *)(*(void *)(a1 + 8) + 18LL);
    sub_1000BBEA0(&v52);
    unint64_t v47 = v35 / v36;
    if (v35 < v27) {
      break;
    }
    uint64_t v32 = *(void *)(a1 + 8);
LABEL_39:
    v49[0] = v5;
    v49[1] = v6;
    char v50 = v7;
    *(_DWORD *)size_t v51 = v62[0];
    *(_DWORD *)&v51[3] = *(_DWORD *)((char *)v62 + 3);
    unint64_t v37 = v27 / *(unsigned __int16 *)(v32 + 18);
    *(void *)&__int128 v53 = v16;
    *((void *)&v53 + 1) = v37;
    LOBYTE(v54) = 2;
    sub_1000AC794((uint64_t)v49, (uint64_t)&v53, (uint64_t)v55);
    unint64_t v5 = v55[0];
    unint64_t v6 = v55[1];
    unsigned int v7 = v56;
    sub_100116A88(v58);
  }

  sub_100116A88(v58);
LABEL_41:
  if ((*(_BYTE *)(a3 + 16) & 2) != 0) {
    uint64_t v38 = *(void *)a3;
  }
  else {
    uint64_t v38 = *(void *)a3 + 1LL;
  }
  *(void *)a4 = v38;
  *(void *)(a4 + _Block_object_dispose((const void *)(v2 - 120), 8) = v47;
  *(_BYTE *)(a4 + 16) = 2;
  return v48;
}

void sub_1000C8C10( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void *sub_1000C8C84(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000E0EB0((uint64_t)a1, a2);
  *a1 = off_100181628;
  a1[45] = &off_100181728;
  a1[46] = &off_100181750;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_100181628;
  a1[45] = off_1001816B0;
  a1[46] = off_1001816D8;
  return a1;
}

void sub_1000C8D08(_Unwind_Exception *a1)
{
}

uint64_t sub_1000C8D2C(uint64_t a1)
{
  return a1;
}

void *sub_1000C8D6C(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000E0F2C((uint64_t)a1, a2);
  *a1 = off_100181848;
  a1[45] = &off_100181948;
  a1[46] = &off_100181970;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_100181848;
  a1[45] = off_1001818D0;
  a1[46] = off_1001818F8;
  return a1;
}

void sub_1000C8DF0(_Unwind_Exception *a1)
{
}

uint64_t sub_1000C8E14(uint64_t a1)
{
  return a1;
}

uint64_t sub_1000C8E54(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v9 = *(unsigned __int8 *)(*(void *)(a1 + 24) + 184LL);
  while (v32 != v40 || v33 != v41 || v34 != v42 || v34 != v32 + 16 * v33 && (v37 != v43 || v38 != v44 || v39 != v45))
  {
    unint64_t v10 = v35 * *(unsigned __int16 *)(a1 + 18);
    sub_1000BE844(a1, a2, v10 / *(void *)(a1 + 80), v9 == 0, 1, &v31);
    if (v31 && !*(_BYTE *)(v31 + 520))
    {
      if (*(_BYTE *)(v31 + 400)) {
        uint64_t v15 = v31 + 40;
      }
      else {
        uint64_t v15 = 0LL;
      }
      sub_1000BFDE4(v15, a2, a3, a4, &v18);
      uint64_t v34 = v19;
      uint64_t v37 = v22;
      if (v33 != (v19 - v32) >> 4)
      {
        unint64_t v35 = sub_1000BC1B4(&v32);
        uint64_t v36 = v16;
      }

      int v12 = 0;
      goto LABEL_37;
    }

    if (v31)
    {
      if (*(_BYTE *)(v31 + 520)) {
        uint64_t v11 = 4294967291LL;
      }
      else {
        uint64_t v11 = 0LL;
      }
      if (!(*(unsigned __int8 *)(v31 + 520) | v9))
      {
LABEL_19:
        sub_1000BE06C( a3,  a4,  *(unsigned int *)(a1 + 20),  *(unsigned __int16 *)(a1 + 18),  v10 / *(void *)(a1 + 80) * *(void *)(a1 + 80),  *(void *)(a1 + 80) + v10 / *(void *)(a1 + 80) * *(void *)(a1 + 80),  (uint64_t)&v18);
        while ((void)v18 != v25
             || *((void *)&v18 + 1) != v26
             || v19 != v27
             || v19 != (void)v18 + 16LL * *((void *)&v18 + 1) && (v22 != v28 || v23 != v29 || v24 != v30))
        {
          v22 += v24 * v21;
          unint64_t v20 = sub_1000BC1B4((uint64_t *)&v18);
          uint64_t v21 = v13;
        }

        uint64_t v34 = v19;
        uint64_t v37 = v22;
        if (v33 != (v19 - v32) >> 4)
        {
          unint64_t v35 = sub_1000BC1B4(&v32);
          uint64_t v36 = v14;
        }

        int v12 = 2;
        goto LABEL_37;
      }

      int v12 = 1;
      uint64_t v4 = v11;
    }

    else
    {
      if (!v9) {
        goto LABEL_19;
      }
      uint64_t v4 = 0LL;
      int v12 = 1;
    }

uint64_t sub_1000C9144(uint64_t a1, uint64_t a2, uint64_t (***a3)())
{
  unint64_t v6 = (std::mutex *)(a1 + 3528);
  std::mutex::lock((std::mutex *)(a1 + 3528));
  sub_1000C7D98(a1 + 2080);
  sub_1000C7E40(a1 + 280);
  unsigned int v7 = (unsigned int *)(a1 + 3592);
  do
    unsigned int v8 = __ldaxr(v7);
  while (__stlxr(0, v7));
  int v9 = (*(uint64_t (**)(void, void))(**(void **)(a2 + 16) + 16LL))(*(void *)(a2 + 16), 0LL);
  if (v9) {
    goto LABEL_4;
  }
  uint64_t v10 = sub_1000C78F8(a1, a2);
  if ((_DWORD)v10)
  {
LABEL_10:
    if ((v10 & 0x80000000) == 0) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }

  uint64_t v13 = *(unint64_t **)(a1 + 128);
  uint64_t v14 = *(unint64_t **)(a1 + 136);
  if (v13 == v14)
  {
    uint64_t v10 = 0LL;
    if (v8) {
      goto LABEL_24;
    }
LABEL_27:
    if (*(uint64_t (****)())(a1 + 3600) == a3)
    {
LABEL_29:
      if (!v8 && (v10 & 0x80000000) == 0)
      {
        uint64_t v10 = 0LL;
        goto LABEL_8;
      }

      goto LABEL_10;
    }

LABEL_28:
    uint64_t v10 = sub_1000C79B4(a1, a2, a3);
    goto LABEL_29;
  }

  uint64_t v10 = 0LL;
  unint64_t v15 = 0LL;
  do
  {
    sub_1000C7688(v13, v15 / *(void *)(a1 + 80), &v18);
    if (v18 && !*(_BYTE *)(v18 + 520))
    {
      if (*(_BYTE *)(v18 + 400)) {
        uint64_t v16 = v18 + 40;
      }
      else {
        uint64_t v16 = 0LL;
      }
      BOOL v17 = sub_1000C0A40(v16, a2);
      if (v8) {
        unsigned int v8 = 1;
      }
      else {
        unsigned int v8 = v17;
      }
    }

    v15 += *(void *)(a1 + 80);
    sub_1000BB354(&v18);
    ++v13;
  }

  while (v13 != v14);
  if (!v8) {
    goto LABEL_27;
  }
LABEL_24:
  int v9 = (*(uint64_t (**)(void, void))(**(void **)(a2 + 16) + 16LL))(*(void *)(a2 + 16), 0LL);
  if (!v9) {
    goto LABEL_28;
  }
LABEL_4:
  if (v9 < 0) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = -v9;
  }
  do
LABEL_7:
    unsigned int v11 = __ldaxr(v7);
  while (__stlxr(v11 | v8, v7));
LABEL_8:
  std::mutex::unlock(v6);
  return v10;
}

void sub_1000C9348()
{
}

uint64_t sub_1000C9368( uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, unsigned int a5, uint64_t (***a6)(), uint64_t a7, uint64_t a8, uint64_t a9)
{
  BOOL v17 = (void *)sub_1000C99E0(a1, a2, a4, a5);
  *BOOL v17 = off_10017ECA0;
  v17[11] = &off_100182BA0;
  v17[12] = v17;
  uint64_t v43 = (uint64_t)(v17 + 11);
  v17[14] = v17 + 11;
  v17[15] = a3;
  sub_1000D8B94(v17 + 16, (unint64_t)(*(void *)(a1 + 80) + a3 - 1) / *(void *)(a1 + 80));
  sub_1000D8C08((void *)(a1 + 152), (unint64_t)(*(void *)(a1 + 80) + a3 - 1) / *(void *)(a1 + 80));
  *(void *)(a1 + 176) = a4;
  uint64_t v41 = a5 + 7LL;
  uint64_t v42 = a5 - 1LL;
  unint64_t v18 = (a4
       - 1LL
       + (v42 + (unint64_t)a6) / a5 * a5
       + (v41 + 8 * ((unint64_t)(*(void *)(a1 + 120) + *(void *)(a1 + 80) - 1LL) / *(void *)(a1 + 80)))
       / a5
       * a5
       * a7)
      / a4;
  *(void *)(a1 + 184) = 850045863LL;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 20_Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(void *)(a1 + 256) = 0LL;
  *(void *)(a1 + 240) = 0LL;
  *(void *)(a1 + 24_Block_object_dispose((const void *)(v2 - 120), 8) = a1 + 256;
  *(void *)(a1 + 264) = 0LL;
  *(void *)(a1 + 272) = v18 * a4;
  unint64_t v48 = 0LL;
  sub_1000E0FA8(a1 + 280, 2uLL, 0LL, (uint64_t)&v46);
  uint64_t v19 = v48;
  if (v48 == &v46)
  {
    uint64_t v20 = 4LL;
    uint64_t v19 = &v46;
  }

  else
  {
    if (!v48) {
      goto LABEL_6;
    }
    uint64_t v20 = 5LL;
  }

  (*(void (**)(void))(*v19 + 8 * v20))();
LABEL_6:
  uint64_t v21 = sub_100037420();
  uint64_t v22 = (int *)(a2 + 188);
  if (!*(_BYTE *)(a2 + 192)) {
    uint64_t v22 = (int *)(v21 + 4);
  }
  int v23 = *v22;
  uint64_t v24 = 64LL;
  if (v23 == 1) {
    uint64_t v24 = 32LL;
  }
  if (v23) {
    unint64_t v25 = v24;
  }
  else {
    unint64_t v25 = 16LL;
  }
  sub_1000E1E80(a1 + 2080, v25, 2LL, v43);
  *(void *)(a1 + 352_Block_object_dispose((const void *)(v2 - 120), 8) = 850045863LL;
  *(_OWORD *)(a1 + 3536) = 0u;
  *(_OWORD *)(a1 + 3552) = 0u;
  *(_OWORD *)(a1 + 356_Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  *(void *)(a1 + 3584) = 0LL;
  *(_DWORD *)(a1 + 3592) = a8 == 0;
  *(void *)(a1 + 3600) = a6;
  uint64_t v40 = (pthread_t *)(a1 + 3616);
  *(_OWORD *)(a1 + 360_Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  *(void *)(a1 + 3624) = 1018212795LL;
  *(_OWORD *)(a1 + 36sub_1000114F0(v6 - 32) = 0u;
  *(_OWORD *)(a1 + 364_Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  *(_OWORD *)(a1 + 3657) = 0u;
  *(void *)(a1 + 3680) = 850045863LL;
  *(void *)(a1 + 3784) = 0LL;
  *(_OWORD *)(a1 + 368_Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  *(_OWORD *)(a1 + 3704) = 0u;
  *(_OWORD *)(a1 + 3720) = 0u;
  *(_OWORD *)(a1 + 3736) = 0u;
  *(_OWORD *)(a1 + 3752) = 0u;
  *(_OWORD *)(a1 + 376_Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  *(void *)(a1 + 3792) = 850045863LL;
  *(_OWORD *)(a1 + 3800) = 0u;
  *(_OWORD *)(a1 + 3816) = 0u;
  *(_OWORD *)(a1 + 38sub_1000114F0(v6 - 32) = 0u;
  *(void *)(a1 + 384_Block_object_dispose((const void *)(v2 - 120), 8) = 0LL;
  if (*(void *)(a1 + 80) == 1LL && a3 == -1)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = &off_100189E78;
    uint64_t v39 = std::generic_category();
    exception[1] = 22LL;
    exception[2] = v39;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
    exception[7] = "asif: chunk size is too small, too many dir indices";
  }

  if (a8
    && (a6 != (uint64_t (***)())512
     || (unint64_t)(*(uint64_t (**)(uint64_t))(*(void *)a8 + 40LL))(a8) >= 0x201))
  {
    *(void *)(a1 + 360_Block_object_dispose((const void *)(v2 - 120), 8) = sub_1000C9A60( a8,  a6,  *(unsigned __int16 *)(a1 + 18),  (uint64_t)(*(void *)(a1 + 160) - *(void *)(a1 + 152)) >> 3,  *(void **)(a1 + 152))
                           + 1;
  }

  unint64_t v26 = a4
      - 1LL
      + ((unint64_t)a6 + v42) / a5 * a5
      + (v41 + 8 * ((unint64_t)(*(void *)(a1 + 120) + *(void *)(a1 + 80) - 1LL) / *(void *)(a1 + 80)))
      / a5
      * a5
      * a7;
  unint64_t v27 = (~(v26 % a4) + a4 + v26) / a4;
  uint64_t v28 = (unint64_t *)(a1 + 8);
  do
    unint64_t v29 = __ldaxr(v28);
  while (__stlxr(v29 + v27, v28));
  uint64_t v46 = a1;
  uint64_t v30 = v47;
  sub_1000118C0((uint64_t)v47, a9);
  unint64_t v31 = (std::__thread_struct *)operator new(8uLL);
  std::__thread_struct::__thread_struct(v31);
  uint64_t v32 = operator new(0x30uLL);
  uint64_t v33 = v46;
  uint64_t v34 = v49;
  *uint64_t v32 = v31;
  v32[1] = v33;
  if (!v34) {
    goto LABEL_24;
  }
  if (v34 != v47)
  {
    uint64_t v34 = (void *)(*(uint64_t (**)(void *))(*v34 + 16LL))(v34);
LABEL_24:
    v32[5] = v34;
    goto LABEL_26;
  }

  v32[5] = v32 + 2;
  (*(void (**)(void *))(v47[0] + 24LL))(v47);
LABEL_26:
  uint64_t v45 = v32;
  int v35 = pthread_create(&v44, 0LL, (void *(__cdecl *)(void *))sub_1000E2F40, v32);
  if (v35)
  {
    std::__throw_system_error(v35, "thread constructor failed");
    __break(1u);
LABEL_36:
    std::terminate();
  }

  uint64_t v45 = 0LL;
  sub_1000E304C((uint64_t *)&v45);
  if (*v40) {
    goto LABEL_36;
  }
  pthread_t *v40 = v44;
  pthread_t v44 = 0LL;
  std::thread::~thread((std::thread *)&v44);
  if (v49 == v47)
  {
    uint64_t v36 = 4LL;
    goto LABEL_32;
  }

  if (v49)
  {
    uint64_t v36 = 5LL;
    uint64_t v30 = v49;
LABEL_32:
    (*(void (**)(void *))(*v30 + 8 * v36))(v30);
  }

  return a1;
}

void sub_1000C9858( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, std::condition_variable *a9, uint64_t a10, uint64_t a11, void **a12, void **a13, std::thread *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, char a21, int a22, __int16 a23, char a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, void *a29)
{
  if (a29 == v32)
  {
    uint64_t v36 = 4LL;
  }

  else
  {
    if (!a29) {
      goto LABEL_6;
    }
    uint64_t v36 = 5LL;
    uint64_t v32 = a29;
  }

  (*(void (**)(void *))(*v32 + 8 * v36))(v32);
LABEL_6:
  std::mutex::~mutex(v30);
  sub_1000BBD1C((void *)(v29 + 3744));
  std::mutex::~mutex(v34);
  std::condition_variable::~condition_variable(a9);
  std::thread::~thread(a14);
  std::mutex::~mutex((std::mutex *)(v29 + 3528));
  sub_1000DD910(a10);
  sub_1000DCEDC(a11);
  sub_1000BF7A0(v31);
  uint64_t v37 = *a12;
  if (*a12)
  {
    *(void *)(v29 + 160) = v37;
    operator delete(v37);
  }

  uint64_t v38 = *a13;
  if (*a13)
  {
    *(void *)(v29 + 136) = v38;
    operator delete(v38);
  }

  uint64_t v39 = *(void **)(v29 + 112);
  if (v39 == a19)
  {
    uint64_t v40 = 4LL;
  }

  else
  {
    if (!v39) {
      goto LABEL_15;
    }
    uint64_t v40 = 5LL;
    a19 = *(void **)(v29 + 112);
  }

  (*(void (**)(void))(*a19 + 8 * v40))();
LABEL_15:
  _Unwind_Resume(a1);
}

void sub_1000C99D8()
{
}

uint64_t sub_1000C99E0(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  *(void *)a1 = off_100181A60;
  *(void *)(a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = 0LL;
  *(_BYTE *)(a1 + 16) = 0;
  *(_WORD *)(a1 + 1_Block_object_dispose((const void *)(v2 - 120), 8) = a4;
  *(_DWORD *)(a1 + 20) = a3;
  *(void *)(a1 + 24) = a2;
  *(void *)(a1 + sub_1000114F0(v6 - 32) = a3 >> 3;
  unint64_t v5 = a3 / a4;
  unint64_t v6 = 4LL * a3;
  if (v6 < v5) {
    uint64_t v7 = 1LL;
  }
  else {
    uint64_t v7 = v6 / v5;
  }
  *(void *)(a1 + 40) = v5;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = v7;
  uint64_t v8 = sub_1000BC15C(a1);
  unint64_t v9 = (*(void *)(a1 + 48) + v8) / (unint64_t)(*(void *)(a1 + 48) + 1LL);
  *(void *)(a1 + 56) = v8;
  *(void *)(a1 + 64) = v9;
  unint64_t v10 = v8 - v9;
  unint64_t v11 = v10 * *(unsigned int *)(a1 + 20);
  *(void *)(a1 + 72) = v10;
  *(void *)(a1 + 80) = v11;
  return a1;
}

unint64_t sub_1000C9A60( uint64_t a1, uint64_t (***a2)(), unint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v6 = a4;
  size_t v9 = (a3 + 8 * a4 + 7) / a3 * a3;
  unint64_t v10 = (unint64_t *)valloc(v9);
  if (!v10)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    unint64_t v26 = std::bad_alloc::bad_alloc(exception);
  }

  uint64_t v31 = &off_10017F7E0;
  uint64_t v34 = &v31;
  uint64_t v37 = v10;
  sub_1000172D0((uint64_t)&v38, (uint64_t)&v31);
  unint64_t v11 = v34;
  if (v34 == &v31)
  {
    uint64_t v12 = 4LL;
    unint64_t v11 = &v31;
  }

  else
  {
    if (!v34) {
      goto LABEL_7;
    }
    uint64_t v12 = 5LL;
  }

  (*v11)[v12]();
LABEL_7:
  uint64_t v13 = v37;
  uint64_t v14 = (std::__shared_weak_count *)*((void *)sub_100118DDC() + 1);
  uint64_t v31 = (uint64_t (**)())v13;
  uint64_t v32 = v14;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      unint64_t v16 = __ldxr(p_shared_owners);
    while (__stxr(v16 + 1, p_shared_owners));
  }

  size_t v33 = v9;
  uint64_t v34 = a2;
  size_t v35 = v9;
  char v36 = 0;
  int v17 = (*(uint64_t (**)(uint64_t, uint64_t (***)()))(*(void *)a1 + 88LL))(a1, &v31);
  if (v9 != v17)
  {
    unint64_t v27 = __cxa_allocate_exception(0x40uLL);
    uint64_t v28 = v27;
    if (v17 >= 0) {
      uint64_t v29 = 4294967291LL;
    }
    else {
      uint64_t v29 = v17;
    }
    *unint64_t v27 = &off_100189E78;
    uint64_t v30 = std::generic_category();
    v28[1] = v29;
    void v28[2] = v30;
    *((_BYTE *)v28 + 24) = 0;
    *((_BYTE *)v28 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
    v28[7] = "Can't load asif dir table";
  }

  unint64_t v18 = *v13;
  if (v6)
  {
    uint64_t v19 = v13 + 1;
    do
    {
      unint64_t v20 = *v19++;
      *a5++ = bswap64(v20);
      --v6;
    }

    while (v6);
  }

  uint64_t v21 = v32;
  if (v32)
  {
    uint64_t v22 = (unint64_t *)&v32->__shared_owners_;
    do
      unint64_t v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }

  sub_100016DE0((uint64_t *)&v37);
  return bswap64(v18);
}

void sub_1000C9C70( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

unint64_t sub_1000C9C94(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (std::__shared_weak_count *)*((void *)sub_100118DDC() + 1);
  unint64_t v15 = &v21;
  unint64_t v16 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      unint64_t v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }

  uint64_t v17 = 8LL;
  uint64_t v18 = a2;
  uint64_t v19 = 8LL;
  char v20 = 0;
  LODWORD(a1) = (*(uint64_t (**)(uint64_t, unint64_t **))(*(void *)a1 + 88LL))(a1, &v15);
  if ((_DWORD)a1 != 8)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    uint64_t v13 = exception;
    else {
      a1 = a1;
    }
    void *exception = &off_100189E78;
    uint64_t v14 = std::generic_category();
    v13[1] = a1;
    v13[2] = v14;
    *((_BYTE *)v13 + 24) = 0;
    *((_BYTE *)v13 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
    v13[7] = "Can't load asif dir version";
  }

  unint64_t v7 = bswap64(v21);
  unint64_t v21 = v7;
  uint64_t v8 = v16;
  if (v16)
  {
    size_t v9 = (unint64_t *)&v16->__shared_owners_;
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }

  return v7;
}

void sub_1000C9DB8(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *sub_1000C9DCC(void *result, _DWORD *a2)
{
  switch(*a2)
  {
    case 0:
      uint64_t v2 = "uninit";
      uint64_t v3 = 6LL;
      goto LABEL_3;
    case 1:
      uint64_t v2 = "fully";
      uint64_t v3 = 5LL;
      goto LABEL_3;
    case 2:
      uint64_t v2 = "unmapped";
      uint64_t v3 = 8LL;
      goto LABEL_3;
    case 3:
      uint64_t v2 = "has_bitmap";
      uint64_t v3 = 10LL;
LABEL_3:
      double result = sub_100004E4C(result, (uint64_t)v2, v3);
      break;
    default:
      return result;
  }

  return result;
}

void sub_1000C9E34(uint64_t a1, unint64_t a2, unint64_t a3)
{
  *(void *)(*(void *)(a1 + 152) + 8 * (a2 / *(void *)(a1 + 80))) = a3 / *(unsigned int *)(a1 + 20);
  atomic_store(1u, (unsigned int *)(a1 + 3592));
}

void *sub_1000C9E5C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16LL))(a1);
  v6[0] = &off_10017F100;
  v6[1] = a2;
  unint64_t v7 = v6;
  sub_1000C9F3C(v3, (uint64_t)v6);
  double result = v7;
  if (v7 == v6)
  {
    uint64_t v5 = 4LL;
    double result = v6;
  }

  else
  {
    if (!v7) {
      return result;
    }
    uint64_t v5 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v5))();
}

void sub_1000C9F00( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  uint64_t v14 = a13;
  if (a13 == &a10)
  {
    uint64_t v15 = 4LL;
    uint64_t v14 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v15 = 5LL;
  }

  (*(void (**)(void))(*(void *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_1000C9F3C(void *a1, uint64_t a2)
{
  if (a1[11])
  {
    char v4 = 0;
    uint64_t v5 = (uint64_t **)(a1 + 9);
    unint64_t v6 = (uint64_t **)(a1 + 10);
    while (1)
    {
      unint64_t v7 = *v6;
      uint64_t v8 = *v6;
      size_t v9 = v6;
      if (*v6)
      {
        do
        {
          unint64_t v10 = (uint64_t **)v8;
          uint64_t v8 = (uint64_t *)v8[1];
        }

        while (v8);
      }

      else
      {
        do
        {
          unint64_t v10 = (uint64_t **)v9[2];
          BOOL v11 = *v10 == (uint64_t *)v9;
          size_t v9 = v10;
        }

        while (v11);
      }

      uint64_t v12 = (uint64_t)v10[4] + *a1;
      uint64_t v13 = a1[12];
      if (v12 != v13) {
        break;
      }
      uint64_t v14 = (uint64_t *)v6;
      if (v7)
      {
        do
        {
          uint64_t v15 = v7;
          unint64_t v7 = (uint64_t *)v7[1];
        }

        while (v7);
      }

      else
      {
        do
        {
          uint64_t v15 = (uint64_t *)v14[2];
          BOOL v11 = *v15 == (void)v14;
          uint64_t v14 = v15;
        }

        while (v11);
      }

      sub_10003F4FC(v5, v15);
      operator delete(v15);
      uint64_t v16 = a1[11];
      uint64_t v13 = a1[12] - *a1;
      a1[12] = v13;
      char v4 = 1;
      if (!v16) {
        goto LABEL_15;
      }
    }

    if ((v4 & 1) == 0) {
      return;
    }
LABEL_15:
    uint64_t v17 = *(void *)(a2 + 24);
    if (v17)
    {
      v22[0] = v13;
      uint64_t v18 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v17 + 48LL))(v17, v22);
      if ((_DWORD)v18)
      {
        uint64_t v19 = v18;
        *(void *)&__int128 v20 = "space_allocators::FixedSize::trim_largest(const size_changed_fn_t &)";
        *((void *)&v20 + 1) = 41LL;
        int v21 = 16;
        sub_1000D8C7C(v22, &v20);
        sub_100004E4C(&v23, (uint64_t)"trim largest: size change callback failed with ", 47LL);
        std::ostream::operator<<(&v23, v19);
        std::ostream::~ostream(&v23, off_100181B70);
        sub_1000D8DE0((uint64_t)v22);
        std::ios::~ios(&v24);
      }
    }
  }

void sub_1000CA0C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

_OWORD *sub_1000CA0DC(_OWORD *a1, uint64_t a2)
{
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  *a1 = 0u;
  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 40LL))(a2) <= 0x1FF)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40LL))(a2);
    void *exception = &off_100181CC0;
    exception[1] = "asif_header";
    exception[2] = 512LL;
    exception[3] = v10;
  }

  char v4 = operator new[](0x200uLL);
  _OWORD *v4 = 0u;
  v4[1] = 0u;
  v4[2] = 0u;
  v4[3] = 0u;
  v4[4] = 0u;
  v4[5] = 0u;
  v4[6] = 0u;
  v4[7] = 0u;
  v4[8] = 0u;
  v4[9] = 0u;
  v4[10] = 0u;
  v4[11] = 0u;
  v4[12] = 0u;
  v4[13] = 0u;
  v4[14] = 0u;
  v4[15] = 0u;
  v4[16] = 0u;
  v4[17] = 0u;
  v4[18] = 0u;
  v4[19] = 0u;
  v4[20] = 0u;
  v4[21] = 0u;
  v4[22] = 0u;
  v4[23] = 0u;
  v4[24] = 0u;
  v4[25] = 0u;
  v4[26] = 0u;
  v4[27] = 0u;
  v4[28] = 0u;
  v4[29] = 0u;
  v4[30] = 0u;
  v4[31] = 0u;
  if (sub_100033014(a2, (uint64_t)v4, 512LL, 0LL) != 512)
  {
    BOOL v11 = __cxa_allocate_exception(0x40uLL);
    *BOOL v11 = &off_100189E78;
    uint64_t v12 = std::generic_category();
    v11[1] = 152LL;
    void v11[2] = v12;
    *((_BYTE *)v11 + 24) = 0;
    *((_BYTE *)v11 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
    v11[7] = "Couldn't read asif's header";
  }

  sub_1000CA2EC((uint64_t)a1, (uint64_t)v4);
  for (uint64_t i = 80LL; i != 512; ++i)
  {
    if (*((_BYTE *)v4 + i))
    {
      unint64_t v7 = __cxa_allocate_exception(0x40uLL);
      *unint64_t v7 = &off_100189E78;
      uint64_t v8 = std::generic_category();
      v7[1] = 161LL;
      uint64_t v7[2] = v8;
      *((_BYTE *)v7 + 24) = 0;
      *((_BYTE *)v7 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
      v7[7] = "Unsupported ASIF, contains data beyond current header struct size";
    }
  }

  operator delete[](v4);
  return a1;
}

void sub_1000CA2C0(_Unwind_Exception *a1)
{
}

_WORD *sub_1000CA2EC(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)a2;
  LODWORD(v14[0]) = 2003069043;
  sub_10007EF00((uint64_t)"header_signature", v4, v14, 1LL);
  *(_DWORD *)a1 = 2003069043;
  *(_DWORD *)(a1 + 4) = bswap32(*(_DWORD *)(a2 + 4));
  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = bswap32(*(_DWORD *)(a2 + 8));
  sub_1000DA6F0(v14, bswap32(*(_DWORD *)(a2 + 12)));
  *(_DWORD *)(a1 + 12) = v14[0];
  *(void *)(a1 + 16) = bswap64(*(void *)(a2 + 16));
  *(void *)(a1 + 24) = bswap64(*(void *)(a2 + 24));
  *(_OWORD *)(a1 + sub_1000114F0(v6 - 32) = *(_OWORD *)(a2 + 32);
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = bswap64(*(void *)(a2 + 48));
  *(void *)(a1 + 56) = bswap64(*(void *)(a2 + 56));
  *(_DWORD *)(a1 + 64) = bswap32(*(_DWORD *)(a2 + 64));
  *(_WORD *)(a1 + 6_Block_object_dispose((const void *)(v2 - 120), 8) = bswap32(*(unsigned __int16 *)(a2 + 68)) >> 16;
  double result = sub_1000E30E8(v14, *(unsigned __int16 *)(a2 + 70));
  *(_WORD *)(a1 + 70) = v14[0];
  *(void *)(a1 + 72) = bswap64(*(void *)(a2 + 72));
  if (*(_DWORD *)(a1 + 4) != 1)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    sub_100004D60((uint64_t)v14);
    sub_100004E4C(v14, (uint64_t)"Unsupported ASIF version ", 25LL);
    std::ostream::operator<<(v14, *(unsigned int *)(a1 + 4));
    sub_10001161C((uint64_t)exception, (uint64_t)v14, 0xA1u);
  }

  if ((*(_DWORD *)(a1 + 8) - 1048577) <= 0xFFF0004E)
  {
    size_t v9 = __cxa_allocate_exception(0x40uLL);
    uint64_t v10 = "Invalid ASIF header size";
LABEL_15:
    unsigned int v12 = 152;
    goto LABEL_19;
  }

  unint64_t v6 = *(unsigned __int16 *)(a1 + 68);
  if (!*(_WORD *)(a1 + 68))
  {
    size_t v9 = __cxa_allocate_exception(0x40uLL);
    uint64_t v10 = "Shadow block size is invalid (0)";
    goto LABEL_15;
  }

  unsigned int v7 = *(_DWORD *)(a1 + 64);
  if (v7 < v6 || v7 % v6)
  {
    size_t v9 = __cxa_allocate_exception(0x40uLL);
    uint64_t v10 = "ASIF max_write size in header exceed the limit";
LABEL_18:
    unsigned int v12 = 22;
LABEL_19:
    uint64_t v13 = (void *)sub_100004870((uint64_t)v9, (uint64_t)v10, v12);
  }

  if ((v6 & 0x1FF) != 0)
  {
    size_t v9 = __cxa_allocate_exception(0x40uLL);
    uint64_t v10 = "ASIF block size isn't multiple of 512";
    goto LABEL_15;
  }

  unint64_t v8 = *(void *)(a1 + 56);
  if (v8 >= 0xFFFFFFFFFFFFFFFFLL / v6)
  {
    size_t v9 = __cxa_allocate_exception(0x40uLL);
    uint64_t v10 = "Max sector count is too large";
    goto LABEL_18;
  }

  if (v8 < *(void *)(a1 + 48))
  {
    size_t v9 = __cxa_allocate_exception(0x40uLL);
    uint64_t v10 = "Sector count is too large";
    goto LABEL_18;
  }

  return result;
}

void sub_1000CA54C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

__n128 sub_1000CA584(_OWORD *a1, uint64_t a2)
{
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  *a1 = 0u;
  *a1 = *(_OWORD *)a2;
  __n128 result = *(__n128 *)(a2 + 16);
  __int128 v3 = *(_OWORD *)(a2 + 32);
  __int128 v4 = *(_OWORD *)(a2 + 64);
  a1[3] = *(_OWORD *)(a2 + 48);
  a1[4] = v4;
  a1[1] = result;
  a1[2] = v3;
  return result;
}

uint64_t sub_1000CA5B0(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a2 = *(_DWORD *)a1;
  *(_DWORD *)(a2 + 4) = bswap32(*(_DWORD *)(a1 + 4));
  *(_DWORD *)(a2 + _Block_object_dispose((const void *)(v2 - 120), 8) = bswap32(*(_DWORD *)(a1 + 8));
  *(_DWORD *)(a2 + 12) = bswap32(*(_DWORD *)(a1 + 12));
  *(void *)(a2 + 16) = bswap64(*(void *)(a1 + 16));
  *(void *)(a2 + 24) = bswap64(*(void *)(a1 + 24));
  *(_OWORD *)(a2 + sub_1000114F0(v6 - 32) = *(_OWORD *)(a1 + 32);
  *(void *)(a2 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = bswap64(*(void *)(a1 + 48));
  *(void *)(a2 + 56) = bswap64(*(void *)(a1 + 56));
  *(_DWORD *)(a2 + 64) = bswap32(*(_DWORD *)(a1 + 64));
  *(_WORD *)(a2 + 6_Block_object_dispose((const void *)(v2 - 120), 8) = bswap32(*(unsigned __int16 *)(a1 + 68)) >> 16;
  *(_WORD *)(a2 + 70) = *(_WORD *)(a1 + 70);
  *(void *)(a2 + 72) = bswap64(*(void *)(a1 + 72));
  return a2 + 80;
}

uint64_t sub_1000CA64C( uint64_t a1, _DWORD *a2, _OWORD *a3, unint64_t a4, unint64_t a5, unsigned int a6, unsigned int a7)
{
  *(_DWORD *)a1 = 2003069043;
  int v18 = 2003069043;
  sub_10007EF00((uint64_t)"header_signature", 2003069043, &v18, 1LL);
  *(void *)(a1 + 4) = 0x20000000001LL;
  *(_DWORD *)(a1 + 12) = *a2;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + sub_1000114F0(v6 - 32) = 0u;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = a4;
  *(void *)(a1 + 56) = a5;
  *(_DWORD *)(a1 + 64) = a6;
  *(_WORD *)(a1 + 6_Block_object_dispose((const void *)(v2 - 120), 8) = a7;
  sub_1000E30E8((_WORD *)(a1 + 70), 0);
  *(void *)(a1 + 72) = 0LL;
  if (!is_mul_ok(a5, a7) || !is_mul_ok(a4, a7) || (unint64_t v14 = a4 * a7 + 2LL * a6, __CFADD__(a4 * a7, 2LL * a6)))
  {
    exception = __cxa_allocate_exception(0x40uLL);
    uint64_t v17 = (void *)sub_100004870((uint64_t)exception, (uint64_t)"ASIF header calculation overflow", 0x16u);
  }

  if (v14 <= a5 * a7) {
    unint64_t v14 = a5 * a7;
  }
  *(void *)(a1 + 56) = v14 / a7;
  *(_OWORD *)(a1 + sub_1000114F0(v6 - 32) = *a3;
  return a1;
}

uint64_t sub_1000CA778(uint64_t a1, uint64_t a2)
{
  else {
    size_t v4 = *(unsigned __int16 *)(a1 + 68);
  }
  uint64_t v5 = operator new[](v4);
  bzero(v5, v4);
  unint64_t v6 = (_BYTE *)sub_1000CA5B0(a1, (uint64_t)v5);
  int64_t v7 = (_BYTE *)v5 + v4 - v6;
  if (v7 >= 1) {
    bzero(v6, v7);
  }
  int v8 = sub_100038458(a2, (uint64_t)v5, v4, 0LL);
  if (v8 >= 0) {
    unsigned int v9 = -5;
  }
  else {
    unsigned int v9 = v8;
  }
  if (v4 == v8) {
    uint64_t v10 = 0LL;
  }
  else {
    uint64_t v10 = v9;
  }
  operator delete[](v5);
  return v10;
}

void sub_1000CA818(_Unwind_Exception *a1)
{
}

uint64_t sub_1000CA82C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)a1 = 1635018093;
  int v7 = 1635018093;
  sub_10007EF00((uint64_t)"header_signature", 1635018093, &v7, 1LL);
  *(_DWORD *)(a1 + 4) = 1;
  int v8 = 1;
  sub_10007EF00((uint64_t)"version_t", 1, &v8, 1LL);
  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = 512;
  int v9 = 512;
  sub_10007EF00((uint64_t)"header_size_t", 512, &v9, 1LL);
  *(void *)(a1 + 12) = a2;
  *(void *)(a1 + 20) = a3;
  return a1;
}

uint64_t *sub_1000CA8E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v8 = valloc(0x200uLL);
  if (!v8)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    int v54 = std::bad_alloc::bad_alloc(exception);
  }

  v66[0] = (uint64_t)&off_10017F7E0;
  uint64_t v67 = v66;
  unint64_t v78 = v8;
  sub_1000172D0((uint64_t)&v79, (uint64_t)v66);
  int v9 = v67;
  if (v67 == v66)
  {
    uint64_t v10 = 4LL;
    int v9 = v66;
  }

  else
  {
    if (!v67) {
      goto LABEL_7;
    }
    uint64_t v10 = 5LL;
  }

  (*(void (**)(void))(*v9 + 8 * v10))();
LABEL_7:
  BOOL v11 = v78;
  *unint64_t v78 = *(_DWORD *)a1;
  v11[1] = bswap32(*(_DWORD *)(a1 + 4));
  void v11[2] = bswap32(*(_DWORD *)(a1 + 8));
  *(void *)(v11 + 3) = bswap64(*(void *)(a1 + 12));
  *(void *)(v11 + 5) = bswap64(*(void *)(a1 + 20));
  unsigned int v12 = v78;
  int64_t v13 = (char *)v78 - (char *)(v11 + 7) + 512;
  if (v13 >= 1) {
    bzero(v11 + 7, v13);
  }
  uint64_t v14 = *((void *)sub_100118DDC() + 1);
  *(void *)&__int128 v60 = v12;
  *((void *)&v60 + 1) = v14;
  if (v14)
  {
    uint64_t v15 = (unint64_t *)(v14 + 8);
    do
      unint64_t v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }

  uint64_t v61 = 512LL;
  uint64_t v62 = a4;
  uint64_t v63 = 512LL;
  char v64 = 0;
  sub_100058B94(v66, &v60);
  uint64_t v17 = (std::__shared_weak_count *)*((void *)&v60 + 1);
  if (*((void *)&v60 + 1))
  {
    int v18 = (unint64_t *)(*((void *)&v60 + 1) + 8LL);
    do
      unint64_t v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  sub_10002B7D4((uint64_t)v71, (uint64_t)&v60);
  sub_10002B3A4((uint64_t)v71, (uint64_t)&v57);
  uint64_t v20 = sub_1000C7EE8(a3, a2, (uint64_t *)&v60, (uint64_t)&v57, 0);
  int v21 = v59;
  if (v59)
  {
    p_shared_owners = (unint64_t *)&v59->__shared_owners_;
    do
      unint64_t v23 = __ldaxr(p_shared_owners);
    while (__stlxr(v23 - 1, p_shared_owners));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }

  uint64_t v24 = v58;
  if (v58)
  {
    unint64_t v25 = (unint64_t *)&v58->__shared_owners_;
    do
      unint64_t v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }

  unint64_t v27 = v65;
  if (v65)
  {
    uint64_t v28 = (unint64_t *)&v65->__shared_owners_;
    do
      unint64_t v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }

  uint64_t v30 = (std::__shared_weak_count *)*((void *)&v60 + 1);
  if (!*((void *)&v60 + 1)) {
    goto LABEL_36;
  }
  uint64_t v31 = (unint64_t *)(*((void *)&v60 + 1) + 8LL);
  do
    unint64_t v32 = __ldaxr(v31);
  while (__stlxr(v32 - 1, v31));
  if (!v32)
  {
    ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
    std::__shared_weak_count::__release_weak(v30);
    if ((v20 & 0x8000000000000000LL) == 0) {
      goto LABEL_38;
    }
  }

  else
  {
LABEL_36:
    if ((v20 & 0x8000000000000000LL) == 0) {
      goto LABEL_38;
    }
  }

  uint64_t v33 = v20;
  if ((_DWORD)v20)
  {
    unint64_t v55 = __cxa_allocate_exception(0x40uLL);
    *unint64_t v55 = &off_100189E78;
    unsigned __int8 v56 = std::generic_category();
    v55[1] = v33;
    unint64_t v55[2] = v56;
    *((_BYTE *)v55 + 24) = 0;
    *((_BYTE *)v55 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
    v55[7] = "Failed to write metadata header";
  }

void sub_1000CADA0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, char a49)
{
}

uint64_t sub_1000CAE0C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = 0LL;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 16) = 0LL;
  int v8 = valloc(0x200uLL);
  if (!v8)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    uint64_t v63 = std::bad_alloc::bad_alloc(exception);
  }

  v78[0] = (uint64_t)&off_10017F7E0;
  uint64_t v79 = v78;
  uint64_t v90 = v8;
  sub_1000172D0((uint64_t)&v91, (uint64_t)v78);
  int v9 = v79;
  if (v79 == v78)
  {
    uint64_t v10 = 4LL;
    int v9 = v78;
  }

  else
  {
    if (!v79) {
      goto LABEL_7;
    }
    uint64_t v10 = 5LL;
  }

  (*(void (**)(void))(*v9 + 8 * v10))();
LABEL_7:
  uint64_t v11 = (uint64_t)v90;
  uint64_t v12 = *((void *)sub_100118DDC() + 1);
  *(void *)&__int128 v71 = v11;
  *((void *)&v71 + 1) = v12;
  if (v12)
  {
    int64_t v13 = (unint64_t *)(v12 + 8);
    do
      unint64_t v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }

  uint64_t v72 = 512LL;
  uint64_t v73 = a4;
  uint64_t v74 = 512LL;
  char v75 = 0;
  sub_100058B94(v78, &v71);
  uint64_t v15 = (std::__shared_weak_count *)*((void *)&v71 + 1);
  if (*((void *)&v71 + 1))
  {
    unint64_t v16 = (unint64_t *)(*((void *)&v71 + 1) + 8LL);
    do
      unint64_t v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }

  v18.n128_f64[0] = sub_10002B3A4((uint64_t)v83, (uint64_t)&v71);
  unint64_t v19 = *(void *)(a3 + 120);
  unint64_t v20 = v77;
  int v21 = v76;
  if (v76)
  {
    p_shared_owners = (unint64_t *)&v76->__shared_owners_;
    do
      unint64_t v23 = __ldaxr(p_shared_owners);
    while (__stlxr(v23 - 1, p_shared_owners));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *, __n128))v21->__on_zero_shared)(v21, v18);
      std::__shared_weak_count::__release_weak(v21);
    }
  }

  uint64_t v24 = (std::__shared_weak_count *)*((void *)&v71 + 1);
  if (*((void *)&v71 + 1))
  {
    unint64_t v25 = (unint64_t *)(*((void *)&v71 + 1) + 8LL);
    do
      unint64_t v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *, __n128))v24->__on_zero_shared)(v24, v18);
      std::__shared_weak_count::__release_weak(v24);
    }
  }

  if (v20 > v19)
  {
    char v64 = __cxa_allocate_exception(0x40uLL);
    *char v64 = &off_100189E78;
    uint64_t v65 = std::generic_category();
    v64[1] = 152LL;
    v64[2] = v65;
    *((_BYTE *)v64 + 24) = 0;
    *((_BYTE *)v64 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
    v64[7] = "Metadata offset is invalid";
  }

  sub_10002B7D4((uint64_t)v83, (uint64_t)&v71);
  sub_10002B3A4((uint64_t)v83, (uint64_t)&v68);
  uint64_t v27 = sub_1000C7EE8(a3, a2, (uint64_t *)&v71, (uint64_t)&v68, 1);
  uint64_t v28 = v70;
  if (v70)
  {
    unint64_t v29 = (unint64_t *)&v70->__shared_owners_;
    do
      unint64_t v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }

  uint64_t v31 = v69;
  if (v69)
  {
    unint64_t v32 = (unint64_t *)&v69->__shared_owners_;
    do
      unint64_t v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }

  uint64_t v34 = v76;
  if (v76)
  {
    size_t v35 = (unint64_t *)&v76->__shared_owners_;
    do
      unint64_t v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }

  uint64_t v37 = (std::__shared_weak_count *)*((void *)&v71 + 1);
  if (!*((void *)&v71 + 1)) {
    goto LABEL_45;
  }
  uint64_t v38 = (unint64_t *)(*((void *)&v71 + 1) + 8LL);
  do
    unint64_t v39 = __ldaxr(v38);
  while (__stlxr(v39 - 1, v38));
  if (!v39)
  {
    ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
    std::__shared_weak_count::__release_weak(v37);
    if ((v27 & 0x8000000000000000LL) == 0) {
      goto LABEL_47;
    }
  }

  else
  {
LABEL_45:
    if ((v27 & 0x8000000000000000LL) == 0) {
      goto LABEL_47;
    }
  }

  if ((_DWORD)v27)
  {
    __int128 v66 = __cxa_allocate_exception(0x40uLL);
    void *v66 = &off_100189E78;
    uint64_t v67 = std::generic_category();
    v66[1] = v27;
    v66[2] = v67;
    *((_BYTE *)v66 + 24) = 0;
    *((_BYTE *)v66 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
    v66[7] = "ASIF meta header failed to read";
  }

void sub_1000CB3F0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, char a49)
{
}

uint64_t sub_1000CB468(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = *(_DWORD *)a2;
  int v14 = 1635018093;
  sub_10007EF00((uint64_t)"header_signature", v6, &v14, 1LL);
  *(_DWORD *)a1 = 1635018093;
  int v7 = bswap32(*(_DWORD *)(a2 + 4));
  int v15 = 1;
  sub_10007EF00((uint64_t)"version_t", v7, &v15, 1LL);
  *(_DWORD *)(a1 + 4) = 1;
  int v8 = bswap32(*(_DWORD *)(a2 + 8));
  int v16 = 512;
  uint64_t result = sub_10007EF00((uint64_t)"header_size_t", v8, &v16, 1LL);
  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = 512;
  unint64_t v10 = bswap64(*(void *)(a2 + 12));
  *(void *)(a1 + 12) = v10;
  *(void *)(a1 + 20) = bswap64(*(void *)(a2 + 20));
  if (v10 > (unint64_t)*(unsigned int *)(a3 + 20) - 512)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    uint64_t v12 = "ASIF meta header size exceeds its maximum";
    goto LABEL_6;
  }

  if (v10 % *(unsigned __int16 *)(a3 + 18))
  {
    exception = __cxa_allocate_exception(0x40uLL);
    uint64_t v12 = "ASIF meta header data is unaligned";
LABEL_6:
    int64_t v13 = (void *)sub_100004870((uint64_t)exception, (uint64_t)v12, 0x98u);
  }

  return result;
}

uint64_t sub_1000CB594(void *a1, uint64_t a2)
{
  if (!*(void *)(*a1 + 72LL)) {
    return 0LL;
  }
  sub_1000CB61C(a1, a2, (uint64_t *)&v4);
  uint64_t v2 = 0x6DB6DB6DB6DB6DB7LL * ((v5 - v4) >> 2);
  if (v4)
  {
    uint64_t v5 = v4;
    operator delete(v4);
  }

  return v2;
}

uint64_t sub_1000CB61C@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  uint64_t v6 = a1[1];
  unint64_t v16 = *(void *)(*a1 + 72LL) * *(unsigned int *)(v6 + 20);
  uint64_t result = sub_1000DA30C(a3, a2, v6, (uint64_t *)&v16);
LABEL_2:
  for (unint64_t i = result; ; a3[1] = i)
  {
    a3[1] = i;
    uint64_t v9 = *(void *)(i - 8);
    if (!v9) {
      break;
    }
    uint64_t v11 = *a1;
    uint64_t v10 = a1[1];
    unint64_t v12 = v9 * *(unsigned int *)(v10 + 20);
    unint64_t v16 = v12;
    uint64_t v13 = *(unsigned __int16 *)(v10 + 18);
    if (v12 < *(void *)(v11 + 48) * v13 || *(void *)(v11 + 56) * v13 <= v12)
    {
      exception = __cxa_allocate_exception(0x40uLL);
      void *exception = &off_100189E78;
      int v15 = std::generic_category();
      exception[1] = 152LL;
      exception[2] = v15;
      *((_BYTE *)exception + 24) = 0;
      *((_BYTE *)exception + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
      exception[7] = "ASIF: metadata header out of range";
    }

    if (i >= a3[2])
    {
      uint64_t result = sub_1000DA4C8(a3, a2, v10, (uint64_t *)&v16);
      goto LABEL_2;
    }

    uint64_t result = sub_1000CAE0C(i, a2, v10, v12);
    i += 28LL;
  }

  return result;
}

void sub_1000CB748(_Unwind_Exception *exception_object)
{
  __int128 v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose((const void *)(v2 - 120), 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_1000CB778(void *a1@<X0>, uint64_t a2@<X1>, CFMutableDictionaryRef *a3@<X8>)
{
  if (!*(void *)(*a1 + 72LL))
  {
    keys = @"internal metadata";
    uint64_t v63 = @"user metadata";
    sub_1000F6908((CFMutableDictionaryRef *)&v53);
    sub_1000F6908((CFMutableDictionaryRef *)&v56);
    values = v53;
    BOOL v59 = v56;
    sub_1000F686C((const void **)&keys, (const void **)&values, 2LL, a3);
    sub_100026DC0((const void **)&v56);
    sub_100026DC0((const void **)&v53);
    return;
  }

  sub_1000CBFA4(a1, a2, (uint64_t *)&v56);
  uint64_t v6 = (uint64_t *)v56;
  int v7 = v57;
  if (v56 == (std::__shared_weak_count *)v57)
  {
LABEL_65:
    int v41 = 0;
    goto LABEL_66;
  }

  do
  {
    sub_1000367BC((uint64_t *)&keys, v6);
    uint64_t v8 = a1[1];
    sub_10002B7D4((uint64_t)v67, (uint64_t)&values);
    sub_10002B3A4((uint64_t)v67, (uint64_t)&v53);
    uint64_t v9 = sub_1000C7EE8(v8, a2, (uint64_t *)&values, (uint64_t)&v53, 1);
    uint64_t v10 = v55;
    if (v55)
    {
      p_shared_owners = (unint64_t *)&v55->__shared_owners_;
      do
        unint64_t v12 = __ldaxr(p_shared_owners);
      while (__stlxr(v12 - 1, p_shared_owners));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }

    uint64_t v13 = v54;
    if (v54)
    {
      int v14 = (unint64_t *)&v54->__shared_owners_;
      do
        unint64_t v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }

    unint64_t v16 = v61;
    if (v61)
    {
      unint64_t v17 = (unint64_t *)&v61->__shared_owners_;
      do
        unint64_t v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }

    unint64_t v19 = v59;
    if (!v59) {
      goto LABEL_22;
    }
    unint64_t v20 = (unint64_t *)&v59->__shared_owners_;
    do
      unint64_t v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
      if ((v9 & 0x8000000000000000LL) == 0) {
        goto LABEL_24;
      }
    }

    else
    {
LABEL_22:
      if ((v9 & 0x8000000000000000LL) == 0) {
        goto LABEL_24;
      }
    }

    if ((_DWORD)v9)
    {
      exception = __cxa_allocate_exception(0x40uLL);
      void *exception = &off_100189E78;
      uint64_t v50 = std::generic_category();
      exception[1] = v9;
      exception[2] = v50;
      *((_BYTE *)exception + 24) = 0;
      *((_BYTE *)exception + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
      exception[7] = "ASIF: failed to deserialize metadata";
    }

void sub_1000CBC90( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, const void *a29)
{
}

const void **sub_1000CBED8@<X0>(CFMutableDictionaryRef *a1@<X8>)
{
  keys[0] = @"internal metadata";
  keys[1] = @"user metadata";
  sub_1000F6908((CFMutableDictionaryRef *)&v4);
  sub_1000F6908((CFMutableDictionaryRef *)&v3);
  values[0] = v4;
  values[1] = v3;
  sub_1000F686C((const void **)keys, (const void **)values, 2LL, a1);
  sub_100026DC0((const void **)&v3);
  return sub_100026DC0((const void **)&v4);
}

void sub_1000CBF78(_Unwind_Exception *a1, uint64_t a2, ...)
{
  __int128 v3 = va_arg(va1, const void *);
  sub_100026DC0((const void **)va);
  sub_100026DC0((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_1000CBFA4(void *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  sub_1000CB61C(a1, a2, (uint64_t *)&v26);
  uint64_t v5 = v27;
  if (v27 != v26)
  {
    unint64_t v6 = 0LL;
    uint64_t v5 = v26;
    do
    {
      size_t v7 = *(void *)&v5[28 * v6 + 12];
      size_t v25 = v7;
      uint64_t v8 = (std::__shared_weak_count_vtbl *)valloc(v7);
      if (!v8)
      {
        exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
        unint64_t v21 = std::bad_alloc::bad_alloc(exception);
      }

      uint64_t v9 = v8;
      unint64_t v23 = v8;
      uint64_t v10 = (std::__shared_weak_count *)operator new(0x20uLL);
      v10->__shared_owners_ = 0LL;
      p_shared_owners = (unint64_t *)&v10->__shared_owners_;
      v10->__vftable = (std::__shared_weak_count_vtbl *)&off_100182130;
      v10->__shared_weak_owners_ = 0LL;
      v10[1].__vftable = v9;
      unint64_t v24 = v10;
      uint64_t v12 = *(unsigned int *)(a1[1] + 20LL);
      uint64_t v13 = *(void *)(*a1 + 72LL) * v12 + 512;
      uint64_t v22 = v13;
      if (v6)
      {
        uint64_t v13 = *(void *)&v5[28 * v6 - 8] * v12 + 512;
        uint64_t v22 = v13;
      }

      unint64_t v14 = a3[1];
      if (v14 >= a3[2])
      {
        uint64_t v16 = sub_1000DA104(a3, &v23, (uint64_t *)&v25, &v22, (uint64_t *)&v25);
      }

      else
      {
        *(void *)unint64_t v14 = v9;
        *(void *)(v14 + _Block_object_dispose((const void *)(v2 - 120), 8) = v10;
        do
          unint64_t v15 = __ldxr(p_shared_owners);
        while (__stxr(v15 + 1, p_shared_owners));
        *(void *)(v14 + 16) = v7;
        *(void *)(v14 + 24) = v13;
        *(void *)(v14 + sub_1000114F0(v6 - 32) = v7;
        uint64_t v16 = v14 + 48;
        *(_BYTE *)(v14 + 40) = 0;
      }

      a3[1] = v16;
      unint64_t v17 = v24;
      if (v24)
      {
        unint64_t v18 = (unint64_t *)&v24->__shared_owners_;
        do
          unint64_t v19 = __ldaxr(v18);
        while (__stlxr(v19 - 1, v18));
        if (!v19)
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
      }

      ++v6;
      uint64_t v5 = v26;
    }

    while (v6 < 0x6DB6DB6DB6DB6DB7LL * ((v27 - v26) >> 2));
  }

  if (v5)
  {
    unint64_t v27 = v5;
    operator delete(v5);
  }

void sub_1000CC168( int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
}

void sub_1000CC198( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  if (a14)
  {
    a15 = a14;
    operator delete(a14);
  }

  sub_1000D94DC(&a14);
  _Unwind_Resume(a1);
}

void *sub_1000CC1D0(void *a1, __int128 *a2)
{
  __int128 v3 = (std::ios_base *)(a1 + 46);
  sub_1000E31D0((uint64_t)a1, a2);
  *a1 = off_100181CF8;
  a1[45] = &off_100181DF8;
  a1[46] = &off_100181E20;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_100181CF8;
  a1[45] = off_100181D80;
  a1[46] = off_100181DA8;
  return a1;
}

void sub_1000CC254(_Unwind_Exception *a1)
{
}

uint64_t sub_1000CC278(uint64_t a1)
{
  return a1;
}

void *sub_1000CC2B8(void *a1, __int128 *a2)
{
  __int128 v3 = (std::ios_base *)(a1 + 46);
  sub_1000E3154((uint64_t)a1, a2);
  *a1 = off_100181F18;
  a1[45] = &off_100182018;
  a1[46] = &off_100182040;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_100181F18;
  a1[45] = off_100181FA0;
  a1[46] = off_100181FC8;
  return a1;
}

void sub_1000CC33C(_Unwind_Exception *a1)
{
}

uint64_t sub_1000CC360(uint64_t a1)
{
  return a1;
}

const void **sub_1000CC3A0(const void **result, uint64_t a2, CFPropertyListRef propertyList, uint64_t *a4)
{
  if (propertyList)
  {
    unint64_t v6 = (uint64_t *)result;
    size_t v7 = *result;
    uint64_t v8 = (unsigned int *)result[1];
    unint64_t v9 = v8[5];
    unint64_t v10 = *((void *)*result + 9) * v9;
    uint64_t v11 = *((unsigned __int16 *)v8 + 9);
    if (!v10) {
      unint64_t v10 = (v7[7] * v11 - v9) / v9 * v9;
    }
    if (v10 < v7[6] * v11)
    {
      exception = __cxa_allocate_exception(0x40uLL);
      uint64_t v80 = (void *)sub_100004870((uint64_t)exception, (uint64_t)"Not enough space for metadata", 0x1Cu);
    }

    sub_1000F694C(propertyList, (const __CFData **)v100);
    unint64_t v12 = (unint64_t)v100[1];
    CFTypeRef cf = v100[0];
    v100[0] = 0LL;
    sub_100072048(v100);
    uint64_t v13 = *v6;
    uint64_t v14 = v6[1];
    uint64_t v15 = *(unsigned int *)(v14 + 20);
    size_t v16 = v15 - 512;
    unint64_t v17 = v12 + v15 - 512 - 1;
    unint64_t v18 = v17 / (v15 - 512);
    if (v18 * v15 > v10 + v15 - *(void *)(*v6 + 48) * *(unsigned __int16 *)(v14 + 18))
    {
      uint64_t v81 = __cxa_allocate_exception(0x40uLL);
      *uint64_t v81 = &off_100189E78;
      uint64_t v82 = std::generic_category();
      v81[1] = 28LL;
      v81[2] = v82;
      *((_BYTE *)v81 + 24) = 0;
      *((_BYTE *)v81 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
      v81[7] = "Not enough space for metadata";
    }

    if (v16 <= v17)
    {
      unint64_t v85 = a4;
      uint64_t v19 = 0LL;
      unint64_t v20 = v18 - 1;
      unint64_t v88 = v10;
      if (v18 <= 1) {
        unint64_t v18 = 1LL;
      }
      unint64_t v86 = v18;
      unint64_t v87 = v20;
      while (1)
      {
        if (v19 == v20)
        {
          uint64_t v21 = 0LL;
          uint64_t v22 = v6[1];
          uint64_t v23 = v10 - v20 * *(unsigned int *)(v22 + 20);
          size_t v24 = v12 % v16;
        }

        else
        {
          uint64_t v22 = v6[1];
          unint64_t v25 = *(unsigned int *)(v22 + 20);
          uint64_t v23 = v10 - v19 * v25;
          uint64_t v21 = (v23 - v25) / v25;
          size_t v24 = v16;
        }

        size_t v26 = v24 - 1;
        sub_1000CA82C( (uint64_t)v98,  (v24 - 1 + *(unsigned __int16 *)(v22 + 18))
        / *(unsigned __int16 *)(v22 + 18)
        * *(unsigned __int16 *)(v22 + 18),
          v21);
        sub_1000CA8E0((uint64_t)v98, a2, v6[1], v23);
        if (v12 - v24 >= v19 * v16) {
          unint64_t v27 = v19 * v16;
        }
        else {
          unint64_t v27 = v12 - v24;
        }
        unint64_t v28 = *(unsigned __int16 *)(v6[1] + 18);
        unint64_t v29 = (char *)valloc((v26 + v28) / v28 * v28);
        if (!v29)
        {
          char v75 = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
          unint64_t v76 = std::bad_alloc::bad_alloc(v75);
        }

        v100[0] = &off_10017F7E0;
        uint64_t v101 = v100;
        unint64_t v112 = v29;
        sub_1000172D0((uint64_t)&v113, (uint64_t)v100);
        unint64_t v30 = v101;
        if (v101 == v100)
        {
          unint64_t v30 = v100;
          uint64_t v31 = 4LL;
        }

        else
        {
          if (!v101) {
            goto LABEL_22;
          }
          uint64_t v31 = 5LL;
        }

        (*((void (**)(void))*v30 + v31))();
LABEL_22:
        unint64_t v32 = v112;
        BytePtr = CFDataGetBytePtr((CFDataRef)cf);
        memcpy(v32, &BytePtr[v27], v24);
        unint64_t v34 = *(unsigned __int16 *)(v6[1] + 18);
        if (v24 % v34)
        {
          bzero(&v112[v24], v34 - v24 % v34);
          unint64_t v34 = *(unsigned __int16 *)(v6[1] + 18);
        }

        uint64_t v35 = (uint64_t)v112;
        uint64_t v36 = *((void *)sub_100118DDC() + 1);
        *(void *)&__int128 v92 = v35;
        *((void *)&v92 + 1) = v36;
        if (v36)
        {
          uint64_t v37 = (unint64_t *)(v36 + 8);
          do
            unint64_t v38 = __ldxr(v37);
          while (__stxr(v38 + 1, v37));
        }

        size_t v93 = (v26 + v34) / v34 * v34;
        uint64_t v94 = v23 + 512;
        size_t v95 = v93;
        char v96 = 0;
        sub_100058B94((uint64_t *)v100, &v92);
        unint64_t v39 = (std::__shared_weak_count *)*((void *)&v92 + 1);
        if (*((void *)&v92 + 1))
        {
          uint64_t v40 = (unint64_t *)(*((void *)&v92 + 1) + 8LL);
          do
            unint64_t v41 = __ldaxr(v40);
          while (__stlxr(v41 - 1, v40));
          if (!v41)
          {
            ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
            std::__shared_weak_count::__release_weak(v39);
          }
        }

        uint64_t v42 = v6[1];
        sub_10002B7D4((uint64_t)v105, (uint64_t)&v92);
        sub_10002B3A4((uint64_t)v105, (uint64_t)v89);
        uint64_t v43 = sub_1000C7EE8(v42, a2, (uint64_t *)&v92, (uint64_t)v89, 0);
        pthread_t v44 = v91;
        if (v91)
        {
          p_shared_owners = (unint64_t *)&v91->__shared_owners_;
          do
            unint64_t v46 = __ldaxr(p_shared_owners);
          while (__stlxr(v46 - 1, p_shared_owners));
          if (!v46)
          {
            ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
            std::__shared_weak_count::__release_weak(v44);
          }
        }

        unint64_t v47 = v90;
        if (v90)
        {
          int v48 = (unint64_t *)&v90->__shared_owners_;
          do
            unint64_t v49 = __ldaxr(v48);
          while (__stlxr(v49 - 1, v48));
          if (!v49)
          {
            ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
            std::__shared_weak_count::__release_weak(v47);
          }
        }

        uint64_t v50 = v97;
        if (v97)
        {
          unint64_t v51 = (unint64_t *)&v97->__shared_owners_;
          do
            unint64_t v52 = __ldaxr(v51);
          while (__stlxr(v52 - 1, v51));
          if (!v52)
          {
            ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
            std::__shared_weak_count::__release_weak(v50);
          }
        }

        __int128 v53 = (std::__shared_weak_count *)*((void *)&v92 + 1);
        if (!*((void *)&v92 + 1)) {
          goto LABEL_51;
        }
        int v54 = (unint64_t *)(*((void *)&v92 + 1) + 8LL);
        do
          unint64_t v55 = __ldaxr(v54);
        while (__stlxr(v55 - 1, v54));
        if (!v55)
        {
          ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
          std::__shared_weak_count::__release_weak(v53);
          if (v43 < 0)
          {
LABEL_52:
            if ((_DWORD)v43)
            {
              unint64_t v77 = __cxa_allocate_exception(0x40uLL);
              *unint64_t v77 = &off_100189E78;
              unint64_t v78 = std::generic_category();
              v77[1] = v43;
              v77[2] = v78;
              *((_BYTE *)v77 + 24) = 0;
              *((_BYTE *)v77 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
              v77[7] = "Failed to write metadata";
            }
          }
        }

        else
        {
LABEL_51:
          if (v43 < 0) {
            goto LABEL_52;
          }
        }

        unsigned __int8 v56 = v111;
        if (v111)
        {
          uint64_t v57 = (unint64_t *)&v111->__shared_owners_;
          do
            unint64_t v58 = __ldaxr(v57);
          while (__stlxr(v58 - 1, v57));
          if (!v58)
          {
            ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
            std::__shared_weak_count::__release_weak(v56);
          }
        }

        BOOL v59 = v110;
        if (v110)
        {
          __int128 v60 = (unint64_t *)&v110->__shared_owners_;
          do
            unint64_t v61 = __ldaxr(v60);
          while (__stlxr(v61 - 1, v60));
          if (!v61)
          {
            ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
            std::__shared_weak_count::__release_weak(v59);
          }
        }

        uint64_t v62 = v109;
        if (v109)
        {
          uint64_t v63 = (unint64_t *)&v109->__shared_owners_;
          do
            unint64_t v64 = __ldaxr(v63);
          while (__stlxr(v64 - 1, v63));
          if (!v64)
          {
            ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
            std::__shared_weak_count::__release_weak(v62);
          }
        }

        uint64_t v65 = v108;
        if (v108)
        {
          uint64_t v66 = (unint64_t *)&v108->__shared_owners_;
          do
            unint64_t v67 = __ldaxr(v66);
          while (__stlxr(v67 - 1, v66));
          if (!v67)
          {
            ((void (*)(std::__shared_weak_count *))v65->__on_zero_shared)(v65);
            std::__shared_weak_count::__release_weak(v65);
          }
        }

        uint64_t v68 = v107;
        if (v107)
        {
          uint64_t v69 = (unint64_t *)&v107->__shared_owners_;
          do
            unint64_t v70 = __ldaxr(v69);
          while (__stlxr(v70 - 1, v69));
          if (!v70)
          {
            ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
            std::__shared_weak_count::__release_weak(v68);
          }
        }

        __int128 v71 = v106;
        if (v106)
        {
          uint64_t v72 = (unint64_t *)&v106->__shared_owners_;
          do
            unint64_t v73 = __ldaxr(v72);
          while (__stlxr(v73 - 1, v72));
          if (!v73)
          {
            ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
            std::__shared_weak_count::__release_weak(v71);
          }
        }

        if (v103 && &v104 != __p) {
          operator delete(__p);
        }
        sub_100014E54((uint64_t)v100);
        sub_100016DE0((uint64_t *)&v112);
        ++v19;
        unint64_t v20 = v87;
        unint64_t v10 = v88;
        if (v19 == v86)
        {
          uint64_t v13 = *v6;
          a4 = v85;
          break;
        }
      }
    }

    if (!*(void *)(v13 + 72))
    {
      *(void *)(v13 + 72) = v10 / *(unsigned int *)(v6[1] + 20);
      unsigned int v74 = sub_1000CA778(v13, *a4);
      if (v74)
      {
        unint64_t v83 = __cxa_allocate_exception(0x40uLL);
        *unint64_t v83 = &off_100189E78;
        uint64_t v84 = std::generic_category();
        v83[1] = v74;
        v83[2] = v84;
        *((_BYTE *)v83 + 24) = 0;
        *((_BYTE *)v83 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
        v83[7] = "Failed to update asif header";
      }
    }

    return sub_100072048(&cf);
  }

  return result;
}

void sub_1000CCB04( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,const void *a61,const void *a62)
{
}

void sub_1000CCBA8(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v15 = 0LL;
  uint64_t v16 = 0LL;
  uint64_t v14 = (uint64_t *)&v15;
  if (*(void *)sub_1000BB2D4(a1 + 32, *(void *)(a1 + 176)))
  {
    uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 136LL))(a1);
    uint64_t v5 = *(void *)(a1 + 352);
    uint64_t v6 = *(void *)(a1 + 360);
    if (v5 != v6)
    {
      uint64_t v7 = 0LL;
      uint64_t v8 = 0LL;
      do
      {
        unint64_t v9 = *(void *)(v5 + 8 * v8) * *(unsigned int *)(a1 + 96);
        unint64_t v13 = v9;
        if (v9)
        {
          sub_1000CCD30(a1 + 200, v4, v8, v9, (uint64_t)&v14, (uint64_t)v14);
          sub_1000CF65C(&v14, &v13, (uint64_t *)&v13);
        }

        ++v8;
        v7 += 8LL;
      }

      while (v5 + v7 != v6);
    }

    unint64_t v10 = v15;
    *a2 = v14;
    a2[1] = v10;
    uint64_t v11 = a2 + 1;
    uint64_t v12 = v16;
    a2[2] = v16;
    if (v12)
    {
      void v10[2] = v11;
      uint64_t v14 = (uint64_t *)&v15;
      uint64_t v15 = 0LL;
      uint64_t v16 = 0LL;
      if (!v4) {
        goto LABEL_13;
      }
      goto LABEL_12;
    }

    *a2 = v11;
    if (v4) {
LABEL_12:
    }
      (*(void (**)(uint64_t))(*(void *)v4 + 40LL))(v4);
  }

  else
  {
    a2[2] = 0LL;
    a2[1] = 0LL;
    *a2 = a2 + 1;
  }

void sub_1000CCCF8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

unint64_t *sub_1000CCD30( uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  if (v11 && !*(_BYTE *)(v11 + 520))
  {
    if (*(_BYTE *)(v11 + 400)) {
      uint64_t v9 = v11 + 40;
    }
    else {
      uint64_t v9 = 0LL;
    }
    sub_1000E324C(v9, a2, a5, a6);
  }

  return sub_1000BB354(&v11);
}

void sub_1000CCDBC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *sub_1000CCDD8(void *result, void *a2, unint64_t a3, unsigned int a4)
{
  uint64_t v7 = result;
  if (a2[2])
  {
    uint64_t v8 = a2 + 1;
    uint64_t v9 = (void *)a2[1];
    if (v9)
    {
      do
      {
        unint64_t v10 = v9;
        uint64_t v9 = (void *)v9[1];
      }

      while (v9);
    }

    else
    {
      do
      {
        unint64_t v10 = (void *)v8[2];
        BOOL v11 = *v10 == (void)v8;
        uint64_t v8 = v10;
      }

      while (v11);
    }

    unint64_t v12 = v10[4] + a4;
    uint64_t result = (void *)(*(uint64_t (**)(void *))(result[25] + 16LL))(result + 25);
    if (result[12] <= v12) {
      result[12] = v12;
    }
  }

  uint64_t v15 = (void *)*a2;
  unint64_t v13 = a2 + 1;
  uint64_t v14 = v15;
  if (v15 != v13)
  {
    uint64_t v16 = (uint64_t)(v7 + 25);
    unint64_t v17 = v7 + 26;
    do
    {
      uint64_t v18 = v14[4];
      do
        unint64_t v19 = __ldaxr(v17);
      while (__stlxr(v19 + 1, v17));
      __int128 v24 = a3;
      uint64_t v25 = a4;
      if ((v18 - a3) % a4) {
        unint64_t v20 = (v18 - a3) / a4 + 1;
      }
      else {
        unint64_t v20 = (v18 - a3) / a4;
      }
      v23[0] = a3;
      v23[1] = v20;
      v23[2] = a4;
      uint64_t result = sub_1000CCF1C(v16, &v24, (uint64_t)v23);
      uint64_t v21 = (void *)v14[1];
      if (v21)
      {
        do
        {
          uint64_t v22 = v21;
          uint64_t v21 = (void *)*v21;
        }

        while (v21);
      }

      else
      {
        do
        {
          uint64_t v22 = (void *)v14[2];
          BOOL v11 = *v22 == (void)v14;
          uint64_t v14 = v22;
        }

        while (!v11);
      }

      a3 = v18 + a4;
      uint64_t v14 = v22;
    }

    while (v22 != v13);
  }

  return result;
}

void *sub_1000CCF1C(uint64_t a1, __int128 *a2, uint64_t a3)
{
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16LL))(a1);
  __int128 v10 = *a2;
  uint64_t v11 = *((void *)a2 + 2);
  __int128 v8 = *(_OWORD *)a3;
  uint64_t v9 = *(void *)(a3 + 16);
  unint64_t v13 = 0LL;
  sub_1000E33BC(v5, (uint64_t *)&v10, &v8, (uint64_t)v12);
  uint64_t result = v13;
  if (v13 == v12)
  {
    uint64_t v7 = 4LL;
    uint64_t result = v12;
  }

  else
  {
    if (!v13) {
      return result;
    }
    uint64_t v7 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v7))();
}

void sub_1000CCFE0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, char *a19)
{
  uint64_t v21 = a19;
  if (a19 == v19)
  {
    uint64_t v22 = 4LL;
    uint64_t v21 = &a16;
  }

  else
  {
    if (!a19) {
      goto LABEL_6;
    }
    uint64_t v22 = 5LL;
  }

  (*(void (**)(void))(*(void *)v21 + 8 * v22))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000CD018( uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t (***a5)(), uint64_t *a6)
{
  *(_BYTE *)(a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = 0;
  *(void *)a1 = off_10017ECE0;
  *(void *)(a1 + 16) = *a2;
  uint64_t v11 = a2[1];
  *(void *)(a1 + 24) = v11;
  if (v11)
  {
    unint64_t v12 = (unint64_t *)(v11 + 8);
    do
      unint64_t v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }

  *(_DWORD *)(a1 + sub_1000114F0(v6 - 32) = 2003069043;
  *(void *)(a1 + 36) = *(void *)(a3 + 4);
  *(_DWORD *)(a1 + 44) = *(_DWORD *)(a3 + 12);
  __int128 v14 = *(_OWORD *)(a3 + 16);
  __int128 v15 = *(_OWORD *)(a3 + 32);
  __int128 v16 = *(_OWORD *)(a3 + 48);
  *(void *)(a1 + 94) = *(void *)(a3 + 62);
  *(_OWORD *)(a1 + 64) = v15;
  *(_OWORD *)(a1 + 80) = v16;
  *(_OWORD *)(a1 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = v14;
  *(_WORD *)(a1 + 102) = 0;
  *(void *)(a1 + 104) = *(void *)(a3 + 72);
  *(void *)(a1 + sub_1000114F0(v49 + 112) = 850045863LL;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(void *)(a1 + 16_Block_object_dispose((const void *)(v2 - 120), 8) = 0LL;
  *(void *)(a1 + 176) = a4;
  uint64_t v17 = *a6;
  *(_DWORD *)(a1 + 192) = *((_DWORD *)a6 + 2);
  *(void *)(a1 + 184) = v17;
  uint64_t v18 = *(void *)(a3 + 56);
  uint64_t v19 = *(unsigned __int16 *)(a3 + 68);
  unsigned int v20 = *(_DWORD *)(a3 + 64);
  uint64_t v21 = *a2;
  unint64_t v33 = &off_100182190;
  unint64_t v34 = (void *)a1;
  uint64_t v35 = &v33;
  sub_1000C9368(a1 + 200, a1, v18 * v19, v20, v19, a5, 2LL, v21, (uint64_t)&v33);
  uint64_t v22 = v35;
  if (v35 == &v33)
  {
    uint64_t v23 = 4LL;
    uint64_t v22 = &v33;
  }

  else
  {
    if (!v35) {
      goto LABEL_9;
    }
    uint64_t v23 = 5LL;
  }

  (*v22)[v23]();
LABEL_9:
  *(void *)(a1 + 4056) = a1 + 32;
  *(void *)(a1 + 4064) = a1 + 200;
  *(void *)(a1 + 4072) = 0LL;
  sub_1000CCBA8(a1, &v33);
  unint64_t v24 = *(unsigned __int16 *)(a3 + 68);
  unint64_t v25 = *(unsigned int *)(a3 + 64);
  sub_1000CCDD8( (void *)a1,  &v33,  (v24 + v25 - ((int)v24 + 511) % v24 + 2 * (v24 + 8 * ((unint64_t)(*(void *)(a1 + 320) + *(void *)(a1 + 280) - 1LL) / *(void *)(a1 + 280)) + 7)
   / v24
   * v24
   + 510)
  / v25
  * v25,
    v25);
  sub_100026AC4((uint64_t)&v33, v34);
  uint64_t v26 = *(void *)(a1 + 176);
  if (v26 == 1) {
    uint64_t v27 = 0LL;
  }
  else {
    uint64_t v27 = v26 + 1;
  }
  *(void *)(a1 + 176) = v27;
  uint64_t v28 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 136LL))(a1);
  sub_1000C9E5C(a1 + 200, v28);
  if (!*((_BYTE *)a6 + 2))
  {
    unint64_t v29 = atomic_load((unint64_t *)(a1 + 4072));
    if (v29 != -1LL)
    {
      unint64_t v33 = (uint64_t (**)())&v31;
      unint64_t v32 = &v33;
      std::__call_once((unint64_t *)(a1 + 4072), &v32, (void (__cdecl *)(void *))nullsub_114);
    }
  }

  (*(void (**)(uint64_t))(*(void *)v28 + 40LL))(v28);
  return a1;
}

void sub_1000CD2D4(_Unwind_Exception *a1)
{
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 40LL))(v4);
  }
  sub_1000BF690(v3);
  std::mutex::~mutex(v2);
  sub_1000114F0(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000CD368( uint64_t a1, unsigned int a2, unsigned int a3, unint64_t a4, unint64_t a5, uint64_t *a6, uint64_t *a7, _OWORD *a8, __int128 *a9)
{
  *(_BYTE *)(a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = 0;
  *(void *)a1 = off_10017ECE0;
  *(void *)(a1 + 16) = *a6;
  uint64_t v17 = a6[1];
  *(void *)(a1 + 24) = v17;
  if (v17)
  {
    uint64_t v18 = (unint64_t *)(v17 + 8);
    do
      unint64_t v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
  }

  sub_1000DA6F0(&v33, *((unsigned __int8 *)a7 + 1));
  sub_1000CA64C(a1 + 32, &v33, a8, a4, a5, a3, a2);
  *(void *)(a1 + sub_1000114F0(v49 + 112) = 850045863LL;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 16_Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  uint64_t v20 = *a7;
  *(_DWORD *)(a1 + 192) = *((_DWORD *)a7 + 2);
  *(void *)(a1 + 184) = v20;
  *(void *)&__int128 v35 = &off_100182190;
  *((void *)&v35 + 1) = a1;
  uint64_t v36 = &v35;
  sub_1000C9368(a1 + 200, a1, a2 * a5, a3, a2, (uint64_t (***)())0x200, 2LL, 0LL, (uint64_t)&v35);
  uint64_t v21 = v36;
  if (v36 == &v35)
  {
    uint64_t v22 = 4LL;
    uint64_t v21 = &v35;
  }

  else
  {
    if (!v36) {
      goto LABEL_9;
    }
    uint64_t v22 = 5LL;
  }

  (*(void (**)(void))(*(void *)v21 + 8 * v22))();
LABEL_9:
  *(void *)(a1 + 4056) = a1 + 32;
  *(void *)(a1 + 4064) = a1 + 200;
  *(void *)(a1 + 4072) = 0LL;
  if ((a2 & 0x1FF) != 0)
  {
    uint64_t v27 = "ASIF: Block size isn't a multiple of 512";
    goto LABEL_21;
  }

  if (*(_DWORD *)(a1 + 40) <= 0x50u)
  {
    uint64_t v27 = "ASIF: Header size is less than the min header size";
LABEL_21:
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = &off_100189E78;
    unint64_t v29 = std::generic_category();
    exception[1] = 152LL;
    exception[2] = v29;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
    exception[7] = v27;
  }

  if (!*((_BYTE *)a7 + 2))
  {
    unint64_t v23 = atomic_load((unint64_t *)(a1 + 4072));
    if (v23 != -1LL)
    {
      *(void *)&__int128 v35 = &v32;
      unint64_t v34 = &v35;
      std::__call_once((unint64_t *)(a1 + 4072), &v34, (void (__cdecl *)(void *))nullsub_115);
    }
  }

  unsigned int v24 = sub_1000CA778(a1 + 32, *a6);
  if (v24)
  {
    unint64_t v30 = __cxa_allocate_exception(0x40uLL);
    *unint64_t v30 = &off_100189E78;
    char v31 = std::generic_category();
    v30[1] = v24;
    v30[2] = v31;
    *((_BYTE *)v30 + 24) = 0;
    *((_BYTE *)v30 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
    v30[7] = "Couldn't write asif's header";
  }

  if (*((_BYTE *)a9 + 16))
  {
    __int128 v35 = *a9;
  }

  else
  {
    *(void *)&__int128 v35 = sub_100118D8C();
    *((void *)&v35 + 1) = v25;
  }

  sub_1000CD6CC((uint64_t *)a1, @"stable uuid", (uint64_t)&v35);
  return a1;
}

void sub_1000CD660( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t sub_1000CD6CC(uint64_t *a1, const void *a2, uint64_t a3)
{
  uint64_t v6 = (*(uint64_t (**)(uint64_t *))(*a1 + 136))(a1);
  sub_1000CB778(a1 + 507, v6, &theDict);
  uint64_t v7 = CFDictionaryGetValue(theDict, @"internal metadata");
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (!v7)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = &off_100189E78;
    uint64_t v20 = std::generic_category();
    exception[1] = 152LL;
    exception[2] = v20;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
    exception[7] = "ASIF: missing internal metadata key";
  }

  uint64_t v9 = TypeID;
  if (CFGetTypeID(v7) != TypeID)
  {
    uint64_t v21 = __cxa_allocate_exception(0x40uLL);
    CFTypeID v22 = CFGetTypeID(v7);
    unint64_t v23 = sub_100026B08(v21, v22, v9);
  }

  CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)v7);
  CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, Count + 1, (CFDictionaryRef)v7);
  value = MutableCopy;
  unint64_t v12 = "ASIF: can't copy metadata to mutable copy";
  if (!MutableCopy)
  {
    uint64_t v24 = 4294967284LL;
    goto LABEL_14;
  }

  unint64_t v13 = operator new(0x28uLL);
  __p = v13;
  __int128 v32 = xmmword_10013A810;
  _OWORD *v13 = 0u;
  v13[1] = 0u;
  *(void *)((char *)v13 + 29) = 0LL;
  sub_10006E744(a3, v13);
  BOOL v14 = sub_1000F6E24(MutableCopy, a2, (uint64_t)&__p);
  if (SHIBYTE(v32) < 0) {
    operator delete(__p);
  }
  if (!v14)
  {
    unint64_t v12 = "ASIF: can't set requested uuid";
    uint64_t v24 = 150LL;
LABEL_14:
    uint64_t v25 = __cxa_allocate_exception(0x40uLL);
    *uint64_t v25 = &off_100189E78;
    uint64_t v26 = std::generic_category();
    v25[1] = v24;
    uint64_t v25[2] = v26;
    *((_BYTE *)v25 + 24) = 0;
    *((_BYTE *)v25 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
    v25[7] = v12;
  }

  CFIndex v15 = CFDictionaryGetCount(theDict);
  CFMutableDictionaryRef v16 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, v15 + 1, theDict);
  __p = v16;
  if (!v16)
  {
    uint64_t v27 = __cxa_allocate_exception(0x40uLL);
    *uint64_t v27 = &off_100189E78;
    uint64_t v28 = std::generic_category();
    v27[1] = 4294967284LL;
    v27[2] = v28;
    *((_BYTE *)v27 + 24) = 0;
    *((_BYTE *)v27 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
    v27[7] = "ASIF: can't copy metadata to mutable copy";
  }

  CFDictionarySetValue(v16, @"internal metadata", value);
  sub_1000CC3A0((const void **)a1 + 507, v6, __p, a1 + 2);
  unsigned int v17 = (*(uint64_t (**)(uint64_t *, uint64_t, void))(*a1 + 176))(a1, v6, 0LL);
  if (v17)
  {
    unint64_t v29 = __cxa_allocate_exception(0x40uLL);
    *unint64_t v29 = &off_100189E78;
    unint64_t v30 = std::generic_category();
    v29[1] = v17;
    v29[2] = v30;
    *((_BYTE *)v29 + 24) = 0;
    *((_BYTE *)v29 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
    v29[7] = "ASIF: failed to write metadata";
  }

  sub_100026DC0((const void **)&__p);
  sub_100026DC0((const void **)&value);
  sub_1000114C0((const void **)&theDict);
  return (*(uint64_t (**)(uint64_t))(*(void *)v6 + 40LL))(v6);
}

void sub_1000CDA18( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, int a17, const void *a18)
{
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 40LL))(v18);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1000CDAAC( uint64_t a1, unsigned int a2, unsigned int a3, unint64_t a4, unint64_t a5, uint64_t *a6, uint64_t *a7, _OWORD *a8, __int128 *a9)
{
  return sub_1000CD368(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

uint64_t sub_1000CDAB8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = 0LL;
  int v5 = 0;
  int64_t v6 = 0LL;
  uint64_t v7 = 0LL;
  char v8 = 1;
  do
  {
    char v9 = v8;
    uint64_t v10 = *(void *)sub_1000BB2D4(a2, v4);
    if (v10)
    {
      int64_t v11 = sub_1000C9C94(a1, v10);
      if (!v5 || v6 < v11)
      {
        int v5 = 1;
        uint64_t v7 = v4;
        int64_t v6 = v11;
      }
    }

    char v8 = 0;
    uint64_t v4 = 1LL;
  }

  while ((v9 & 1) != 0);
  return v7;
}

uint64_t sub_1000CDB64(uint64_t a1, uint64_t a2)
{
  int v7 = 0;
  uint64_t v3 = (unint64_t *)(a1 + 4072);
  v6[0] = a1;
  v6[1] = &v7;
  v6[2] = a2;
  unint64_t v4 = atomic_load(v3);
  if (v4 != -1LL)
  {
    char v9 = v6;
    char v8 = &v9;
    std::__call_once(v3, &v8, (void (__cdecl *)(void *))sub_1000E355C);
  }

  if (v7 < 0) {
    return v7;
  }
  else {
    return -v7;
  }
}

uint64_t sub_1000CDBCC(uint64_t a1, uint64_t a2, int a3)
{
  int64_t v6 = (std::mutex *)(a1 + 112);
  std::mutex::lock((std::mutex *)(a1 + 112));
  int v7 = *(uint64_t (****)())sub_1000BB2D4(a1 + 32, *(void *)(a1 + 176));
  char v8 = v7;
  if (!v7)
  {
    unint64_t v9 = *(unsigned __int16 *)(a1 + 100);
    uint64_t v10 = *(void *)(a1 + 176);
    uint64_t v11 = *(void *)(a1 + 320);
    unint64_t v12 = *(void *)(a1 + 280);
    unint64_t v13 = (void *)sub_1000BB2D4(a1 + 32, v10);
    char v8 = (uint64_t (***)())(v9
                                    + 511
                                    - ((int)v9 + 511) % v9
                                    + (8 * ((v11 + v12 - 1) / v12) + v9 + 7) / v9 * v9 * v10);
    void *v13 = v8;
  }

  uint64_t v14 = sub_1000C9144(a1 + 200, a2, v8);
  uint64_t v15 = v14;
  if ((v14 & 0x80000000) == 0)
  {
    if ((_DWORD)v14 == 1)
    {
      uint64_t v16 = *(void *)(a1 + 176);
      if (v16 == 1) {
        uint64_t v17 = 0LL;
      }
      else {
        uint64_t v17 = v16 + 1;
      }
      *(void *)(a1 + 176) = v17;
    }

    if (v7
      || (uint64_t v15 = (*(uint64_t (**)(void, void))(**(void **)(a2 + 16) + 16LL))(*(void *)(a2 + 16), 0LL),
          !(_DWORD)v15)
      && (uint64_t v15 = sub_1000CA778(a1 + 32, *(void *)(a2 + 16)), !(_DWORD)v15))
    {
      uint64_t v15 = (*(uint64_t (**)(void, void))(**(void **)(a2 + 16) + 16LL))( *(void *)(a2 + 16),  2 * (a3 == 2));
    }
  }

  std::mutex::unlock(v6);
  return v15;
}

void sub_1000CDD20(_Unwind_Exception *a1)
{
}

__n128 sub_1000CDD64@<Q0>( unint64_t a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, __n128 *a4@<X3>, unint64_t a5@<X4>, __n128 **a6@<X8>)
{
  unint64_t v12 = a1 + 200;
  unint64_t v13 = (__n128 *)operator new(0x48uLL);
  __n128 result = *a4;
  v13[1] = *a4;
  v13[2].n128_u64[0] = a4[1].n128_u64[0];
  v13[2].n128_u64[1] = a5;
  v13[3].n128_u64[0] = a1;
  v13[3].n128_u64[1] = a3;
  v13->n128_u64[0] = (unint64_t)off_10017EDE0;
  v13->n128_u64[1] = a2;
  v13[4].n128_u64[0] = v12;
  *a6 = v13;
  return result;
}

uint64_t sub_1000CDDE0@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = (*(uint64_t (**)(void *))(*a1 + 136LL))(a1);
  sub_1000CB778(a1 + 507, v4, &theDict);
  Value = CFDictionaryGetValue(theDict, @"user metadata");
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (Value)
  {
    uint64_t v7 = TypeID;
    if (CFGetTypeID(Value) != TypeID)
    {
      exception = __cxa_allocate_exception(0x40uLL);
      CFTypeID v11 = CFGetTypeID(Value);
      unint64_t v12 = sub_100026B08(exception, v11, v7);
    }

    CFTypeID v8 = CFDictionaryGetTypeID();
    if (CFGetTypeID(Value) != v8)
    {
      unint64_t v13 = __cxa_allocate_exception(0x40uLL);
      CFTypeID v14 = CFGetTypeID(Value);
      uint64_t v15 = sub_100026B08(v13, v14, v8);
    }

    CFRetain(Value);
    *a2 = Value;
  }

  else
  {
    sub_1000F6908((CFMutableDictionaryRef *)&v16);
    *a2 = v16;
    uint64_t v16 = 0LL;
    sub_100026DC0(&v16);
  }

  sub_1000114C0((const void **)&theDict);
  return (*(uint64_t (**)(uint64_t))(*(void *)v4 + 40LL))(v4);
}

void sub_1000CDF3C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10)
{
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 40LL))(v10);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1000CDF88(uint64_t *a1, const void *a2)
{
  uint64_t v4 = (*(uint64_t (**)(uint64_t *))(*a1 + 136))(a1);
  sub_1000CB778(a1 + 507, v4, &theDict);
  if (!theDict)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = &off_100189E78;
    uint64_t v10 = std::generic_category();
    exception[1] = 4294967284LL;
    exception[2] = v10;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
    exception[7] = "ASIF: can't read/allocate asif metadata";
  }

  CFIndex Count = CFDictionaryGetCount(theDict);
  CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, Count, theDict);
  CFPropertyListRef propertyList = MutableCopy;
  if (!MutableCopy)
  {
    CFTypeID v11 = __cxa_allocate_exception(0x40uLL);
    *CFTypeID v11 = &off_100189E78;
    unint64_t v12 = std::generic_category();
    v11[1] = 4294967284LL;
    void v11[2] = v12;
    *((_BYTE *)v11 + 24) = 0;
    *((_BYTE *)v11 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
    v11[7] = "ASIF: can't copy metadata to mutable copy";
  }

  CFDictionarySetValue(MutableCopy, @"user metadata", a2);
  sub_1000CC3A0((const void **)a1 + 507, v4, propertyList, a1 + 2);
  unsigned int v7 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*a1 + 176))(a1, v4, 2LL);
  if (v7)
  {
    unint64_t v13 = __cxa_allocate_exception(0x40uLL);
    void *v13 = &off_100189E78;
    CFTypeID v14 = std::generic_category();
    v13[1] = v7;
    v13[2] = v14;
    *((_BYTE *)v13 + 24) = 0;
    *((_BYTE *)v13 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
    v13[7] = "ASIF: failed to write metadata";
  }

  sub_100026DC0(&propertyList);
  sub_1000114C0((const void **)&theDict);
  return (*(uint64_t (**)(uint64_t))(*(void *)v4 + 40LL))(v4);
}

void sub_1000CE168(_Unwind_Exception *a1, uint64_t a2, ...)
{
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 40LL))(v2);
  }
  _Unwind_Resume(a1);
}

CFStringRef sub_1000CE1B0(void *a1, const void *a2)
{
  uint64_t v4 = (*(uint64_t (**)(void *))(*a1 + 136LL))(a1);
  sub_1000CB778(a1 + 507, v4, &theDict);
  Value = CFDictionaryGetValue(theDict, @"internal metadata");
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (!Value)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = &off_100189E78;
    uint64_t v15 = std::generic_category();
    exception[1] = 152LL;
    exception[2] = v15;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
    exception[7] = "ASIF: missing internal metadata key";
  }

  uint64_t v7 = TypeID;
  if (CFGetTypeID(Value) != TypeID)
  {
    uint64_t v16 = __cxa_allocate_exception(0x40uLL);
    CFTypeID v17 = CFGetTypeID(Value);
    uint64_t v18 = sub_100026B08(v16, v17, v7);
  }

  CFTypeID v8 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)Value, a2);
  CFTypeID v9 = CFStringGetTypeID();
  if (v8)
  {
    uint64_t v10 = v9;
    if (CFGetTypeID(v8) != v9)
    {
      unint64_t v19 = __cxa_allocate_exception(0x40uLL);
      CFTypeID v20 = CFGetTypeID(v8);
      uint64_t v21 = sub_100026B08(v19, v20, v10);
    }

    sub_1000F65B4(v8, __p);
    unint64_t v11 = v23;
    if ((v23 & 0x80u) == 0) {
      unint64_t v12 = (unsigned __int8 *)__p;
    }
    else {
      unint64_t v12 = (unsigned __int8 *)__p[0];
    }
    if ((v23 & 0x80u) != 0) {
      unint64_t v11 = (unint64_t)__p[1];
    }
    CFTypeID v8 = (const __CFString *)sub_100072078((uint64_t)&v24, v12, &v12[v11]);
  }

  sub_1000114C0((const void **)&theDict);
  (*(void (**)(uint64_t))(*(void *)v4 + 40LL))(v4);
  return v8;
}

void sub_1000CE3A4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, const void *a17)
{
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 40LL))(v17);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1000CE410(uint64_t *a1, uint64_t a2)
{
  return sub_1000CD6CC(a1, @"source uuid", a2);
}

CFStringRef sub_1000CE420(void *a1)
{
  return sub_1000CE1B0(a1, @"stable uuid");
}

CFStringRef sub_1000CE42C(void *a1)
{
  return sub_1000CE1B0(a1, @"source uuid");
}

uint64_t sub_1000CE438(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

  ;
}

uint64_t sub_1000CE44C(uint64_t a1)
{
  *(void *)a1 = off_10017ECE0;
  uint64_t v2 = a1 + 16;
  sub_1000BF690(a1 + 200);
  std::mutex::~mutex((std::mutex *)(a1 + 112));
  sub_1000114F0(v2);
  return a1;
}

void sub_1000CE494(char *a1)
{
  *(void *)a1 = off_10017ECE0;
  uint64_t v2 = (uint64_t)(a1 + 16);
  sub_1000BF690((uint64_t)(a1 + 200));
  std::mutex::~mutex((std::mutex *)(a1 + 112));
  sub_1000114F0(v2);
  operator delete(a1);
}

uint64_t sub_1000CE4DC(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 218);
}

uint64_t sub_1000CE4E4(uint64_t a1)
{
  return *(void *)(a1 + 80);
}

uint64_t sub_1000CE4EC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 48LL))(*(void *)(a1 + 16));
}

uint64_t *sub_1000CE4FC@<X0>(void *a1@<X0>, char a2@<W1>, void *a3@<X8>)
{
  int64_t v6 = (uint64_t *)operator new(0x130uLL);
  __n128 result = sub_1000BA190(v6, a1, a2);
  *a3 = (char *)v6 + *(void *)(*v6 - 104);
  return result;
}

void sub_1000CE550(_Unwind_Exception *a1)
{
}

uint64_t sub_1000CE564(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = sub_10009E00C((uint64_t)a1, a2);
  if (!(_DWORD)v4)
  {
    unint64_t v5 = (*(uint64_t (**)(uint64_t *))(*a1 + 24))(a1);
    unint64_t v6 = (a2 + v5 - 1) / v5;
    if (v6 <= a1[11])
    {
      uint64_t v7 = (*(uint64_t (**)(uint64_t *))(*a1 + 136))(a1);
      uint64_t v8 = a1[11];
      if (v8 - v6 >= sub_1000CB594(a1 + 507, v7))
      {
        a1[10] = v6;
        sub_1000CA778((uint64_t)(a1 + 4), a1[2]);
        uint64_t v4 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*a1 + 176))(a1, v7, 2LL);
      }

      else
      {
        uint64_t v4 = 4294967269LL;
      }

      (*(void (**)(uint64_t))(*(void *)v7 + 40LL))(v7);
    }

    else
    {
      return 4294967269LL;
    }
  }

  return v4;
}

void sub_1000CE640(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 40LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000CE660()
{
  return 1LL;
}

uint64_t sub_1000CE668()
{
  return 1LL;
}

void *sub_1000CE670(uint64_t a1)
{
  uint64_t v2 = operator new(0x20uLL);
  *uint64_t v2 = off_10017E998;
  v2[1] = a1;
  (*(void (**)(void))(**(void **)(a1 + 16) + 72LL))(*(void *)(a1 + 16));
  return v2;
}

void sub_1000CE6BC(_Unwind_Exception *a1)
{
}

uint64_t sub_1000CE6D0(void *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  unint64_t v8 = ((*(void *)(a4 + 144) - a3[18]) & ~((*(void *)(a4 + 144) - a3[18]) >> 63)) + a3[3];
  uint64_t v9 = a1[10];
  else {
    return sub_1000C7EE8((uint64_t)(a1 + 25), a2, a3, a4, 1);
  }
}

uint64_t sub_1000CE78C(void *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  unint64_t v8 = ((*(void *)(a4 + 144) - a3[18]) & ~((*(void *)(a4 + 144) - a3[18]) >> 63)) + a3[3];
  uint64_t v9 = a1[10];
  int v10 = sub_1000CDB64((uint64_t)a1, a2 + 16);
  if (!v10) {
    return sub_1000C7EE8((uint64_t)(a1 + 25), a2, a3, a4, 0);
  }
  if (v10 >= 0) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = -v10;
  }
  return -v11;
}

uint64_t sub_1000CE868(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    unint64_t v8 = (void *)(a3 + 8);
    uint64_t v9 = a4;
    while (1)
    {
      uint64_t v10 = *v8 + *(v8 - 1);
      unint64_t v11 = (*(uint64_t (**)(void *))(*a1 + 24LL))(a1) * v10;
      uint64_t v12 = a1[10];
      v8 += 2;
      if (!--v9) {
        goto LABEL_5;
      }
    }
  }

  else
  {
LABEL_5:
    uint64_t result = sub_1000CDB64((uint64_t)a1, a2 + 16);
    if (!(_DWORD)result) {
      return sub_1000C8E54((uint64_t)(a1 + 25), a2, a3, a4);
    }
  }

  return result;
}

__n128 sub_1000CE950@<Q0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = (char *)operator new(0x48uLL);
  *(_OWORD *)(v4 + _Block_object_dispose((const void *)(v2 - 120), 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v4 + 24) = *(_OWORD *)(a1 + 24);
  *((void *)v4 + 5) = *(void *)(a1 + 40);
  __n128 result = *(__n128 *)(a1 + 48);
  *((__n128 *)v4 + 3) = result;
  *(void *)uint64_t v4 = off_10017EDE0;
  *((void *)v4 + _Block_object_dispose((const void *)(v2 - 120), 8) = *(void *)(a1 + 64);
  *a2 = v4;
  return result;
}

uint64_t sub_1000CE9B8(uint64_t a1)
{
  return a1 + 176;
}

unint64_t *sub_1000CE9C0@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, unint64_t *a4@<X8>)
{
  return sub_1000DA760(a1 + 2080, a2, a3, a4);
}

void *sub_1000CE9C8(void *a1, unint64_t a2)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if (a2)
  {
    sub_100081F0C(a1, a2);
    uint64_t v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }

  return a1;
}

void sub_1000CEA20(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose((const void *)(v2 - 120), 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1000CEA3C(uint64_t a1, uint64_t a2)
{
  CFTypeID v14 = (std::mutex *)(a1 + 8);
  char v15 = 1;
  std::mutex::lock((std::mutex *)(a1 + 8));
  if (*(void *)(a1 + 88))
  {
    uint64_t v4 = *(uint64_t **)(a1 + 72);
    uint64_t v5 = v4[4];
    sub_10003F4FC((uint64_t **)(a1 + 72), v4);
    operator delete(v4);
  }

  else
  {
    uint64_t v5 = *(void *)(a1 + 96);
    *(void *)(a1 + 96) = *(void *)a1 + v5;
    sub_10003C718((uint64_t)&v14);
    uint64_t v7 = *(void *)(a2 + 24);
    if (v7)
    {
      v11[0] = *(void *)a1 + v5;
      uint64_t v8 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v7 + 48LL))(v7, v11);
      if ((_DWORD)v8)
      {
        *(void *)&__int128 v9 = "space_allocators::FixedSize::allocate(const size_changed_fn_t &)";
        *((void *)&v9 + 1) = 37LL;
        int v10 = 16;
        sub_1000CEBA4(v11, &v9);
        sub_100004E4C(&v12, (uint64_t)"allocated: size change callback failed with ", 44LL);
        std::ostream::operator<<(&v12, v8);
        std::ostream::~ostream(&v12, off_10017EF20);
        sub_1000CED08((uint64_t)v11);
        std::ios::~ios(&v13);
      }
    }
  }

  if (v15) {
    std::mutex::unlock(v14);
  }
  return v5;
}

void sub_1000CEB70( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  if (*(_BYTE *)(v12 - 40)) {
    std::mutex::unlock(*(std::mutex **)(v12 - 48));
  }
  _Unwind_Resume(exception_object);
}

void *sub_1000CEBA4(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000CEC8C((uint64_t)a1, a2);
  *a1 = off_10017EE58;
  a1[45] = &off_10017EF58;
  a1[46] = &off_10017EF80;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_10017EE58;
  a1[45] = off_10017EEE0;
  a1[46] = off_10017EF08;
  return a1;
}

void sub_1000CEC28(_Unwind_Exception *a1)
{
}

uint64_t sub_1000CEC4C(uint64_t a1)
{
  return a1;
}

uint64_t sub_1000CEC8C(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_10017EFF0;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000CECF4(_Unwind_Exception *a1)
{
}

uint64_t sub_1000CED08(uint64_t a1)
{
  *(void *)a1 = off_10017EFF0;
  sub_1000CEF80(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

void sub_1000CEDA4(char *a1)
{
}

uint64_t sub_1000CEDE8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000CEE1C(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

uint64_t sub_1000CEE68(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_10017EF20);
  sub_1000CED08(v2);
  return std::ios::~ios(a1 + 8);
}

void sub_1000CEEA0(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_10017EF20);
  sub_1000CED08((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

uint64_t sub_1000CEEE0(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017EF20);
  sub_1000CED08(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000CEF20(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017EF20);
  sub_1000CED08((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

void sub_1000CEF6C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000CED08(a1);
  operator delete(v1);
}

uint64_t sub_1000CEF80(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000CF0D0((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000CF0A8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

int *sub_1000CF0D0(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      int v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 137LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 137LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  __n128 result = __error();
  *__n128 result = v5;
  return result;
}

__n128 sub_1000CF2BC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &off_10017F070;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + _Block_object_dispose((const void *)(v2 - 120), 8) = result;
  return result;
}

__n128 sub_1000CF2F4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &off_10017F070;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + _Block_object_dispose((const void *)(v2 - 120), 8) = result;
  return result;
}

uint64_t sub_1000CF314(uint64_t a1, uint64_t *a2)
{
  return sub_1000CF368((uint64_t *)(a1 + 8), *a2);
}

uint64_t sub_1000CF320(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_1000CF35C()
{
  return &off_10017F0E0;
}

uint64_t sub_1000CF368(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(*a1 + 16);
  int v5 = valloc(a1[1]);
  if (!v5)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    uint64_t v12 = std::bad_alloc::bad_alloc(exception);
  }

  v15[0] = &off_10017F7E0;
  uint64_t v16 = v15;
  uint64_t v13 = v5;
  sub_1000172D0((uint64_t)&v14, (uint64_t)v15);
  char v6 = v16;
  if (v16 == v15)
  {
    uint64_t v7 = 4LL;
    char v6 = v15;
  }

  else
  {
    if (!v16) {
      goto LABEL_7;
    }
    uint64_t v7 = 5LL;
  }

  (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_7:
  bzero(v13, a1[1]);
  int v8 = sub_100038458(v4, (uint64_t)v13, a1[1], a2 - a1[1]);
  if (a1[1] == v8)
  {
    uint64_t v9 = 0LL;
  }

  else
  {
    if (v8 >= 0) {
      uint64_t v9 = 4294967291LL;
    }
    else {
      uint64_t v9 = v8;
    }
    sub_10009C63C(*a1);
  }

  sub_100016DE0((uint64_t *)&v13);
  return v9;
}

void sub_1000CF49C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_1000CF4BC(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &off_10017F100;
  result[1] = v3;
  return result;
}

uint64_t sub_1000CF4F0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_10017F100;
  a2[1] = v2;
  return result;
}

uint64_t sub_1000CF50C(uint64_t a1, unint64_t *a2)
{
  return sub_1000CF55C((uint64_t *)(a1 + 8), a2);
}

uint64_t sub_1000CF514(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_1000CF550()
{
  return &off_10017F160;
}

uint64_t sub_1000CF55C(uint64_t *a1, unint64_t *a2)
{
  unint64_t v3 = *a2;
  uint64_t v4 = *(void *)(*a1 + 16);
  if ((*(uint64_t (**)(uint64_t))(*(void *)v4 + 40LL))(v4) > v3
    && (*(unsigned int (**)(uint64_t, unint64_t))(*(void *)v4 + 56LL))(v4, v3))
  {
    sub_10009C63C(*a1);
  }

  return 0LL;
}

void sub_1000CF5C8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = a2;
  int v5 = (std::mutex *)(a1 + 8);
  std::mutex::lock((std::mutex *)(a1 + 8));
  sub_1000CF65C((uint64_t **)(a1 + 72), (unint64_t *)&v7, &v7);
  unint64_t v6 = *(void *)a1 + v7;
  if (*(void *)(a1 + 96) <= v6) {
    *(void *)(a1 + 96) = v6;
  }
  sub_1000C9F3C((void *)a1, a3);
  std::mutex::unlock(v5);
}

void sub_1000CF648(_Unwind_Exception *a1)
{
}

uint64_t *sub_1000CF65C(uint64_t **a1, unint64_t *a2, uint64_t *a3)
{
  unint64_t v6 = a1 + 1;
  int v5 = a1[1];
  if (v5)
  {
    unint64_t v7 = *a2;
    while (1)
    {
      while (1)
      {
        int v8 = (uint64_t **)v5;
        unint64_t v9 = v5[4];
        if (v7 >= v9) {
          break;
        }
        int v5 = *v8;
        unint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }

      if (v9 >= v7) {
        break;
      }
      int v5 = v8[1];
      if (!v5)
      {
        unint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    int v8 = a1 + 1;
LABEL_10:
    int v10 = (uint64_t *)operator new(0x28uLL);
    v10[4] = *a3;
    sub_100027200(a1, (uint64_t)v8, v6, v10);
    return v10;
  }

  return (uint64_t *)v8;
}

uint64_t sub_1000CF714(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_10017F250);
  sub_1000CF8D8(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000CF74C(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017F250);
  sub_1000CF8D8(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000CF78C(char *a1)
{
}

uint64_t sub_1000CF7D0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000CF804(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000CF850(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_10017F250);
  sub_1000CF8D8((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000CF890(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017F250);
  sub_1000CF8D8((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000CF8D8(uint64_t a1)
{
  *(void *)a1 = off_10017F320;
  sub_1000CF974(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000CF974(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000CFADC((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000CFA9C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000CFAC8(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000CF8D8(a1);
  operator delete(v1);
}

int *sub_1000CFADC(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      int v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 436LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 436LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  __n128 result = __error();
  *__n128 result = v5;
  return result;
}

uint64_t sub_1000CFCC0(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_10017F470);
  sub_1000CFE84(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000CFCF8(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017F470);
  sub_1000CFE84(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000CFD38(char *a1)
{
}

uint64_t sub_1000CFD7C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000CFDB0(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000CFDFC(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_10017F470);
  sub_1000CFE84((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000CFE3C(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017F470);
  sub_1000CFE84((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000CFE84(uint64_t a1)
{
  *(void *)a1 = off_10017F540;
  sub_1000CFF20(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000CFF20(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000D0088((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000D0048( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000D0074(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000CFE84(a1);
  operator delete(v1);
}

int *sub_1000D0088(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      int v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 450LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 450LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  __n128 result = __error();
  *__n128 result = v5;
  return result;
}

void *sub_1000D026C(void *result, uint64_t a2, uint64_t a3)
{
  *__n128 result = a2;
  result[1] = a3;
  atomic_load((unint64_t *)(*(void *)(a2 + 56) + 16 * a3 + 8));
  unint64_t v3 = atomic_load((unint64_t *)(*(void *)(a2 + 56) + 16 * a3 + 8));
  if ((v3 & 0x3F80000000000000LL) != 0)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    int v5 = (void *)sub_100004870((uint64_t)exception, (uint64_t)"ASIF: data entry - invalid reserved bits", 0x16u);
  }

  return result;
}

void *sub_1000D02DC(void *result, uint64_t a2, uint64_t a3)
{
  *__n128 result = a2;
  result[1] = a3;
  unint64_t v3 = atomic_load((unint64_t *)(*(void *)(a2 + 56) + 16 * a3 + 8));
  if ((v3 & 0x7F80000000000000LL) != 0)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    int v5 = (void *)sub_100004870((uint64_t)exception, (uint64_t)"ASIF: data entry - invalid reserved bits", 0x16u);
  }

  return result;
}

uint64_t sub_1000D0334(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_10017F690);
  sub_1000D04F8(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000D036C(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017F690);
  sub_1000D04F8(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000D03AC(char *a1)
{
}

uint64_t sub_1000D03F0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000D0424(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000D0470(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_10017F690);
  sub_1000D04F8((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000D04B0(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017F690);
  sub_1000D04F8((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000D04F8(uint64_t a1)
{
  *(void *)a1 = off_10017F760;
  sub_1000D0594(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000D0594(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000D06FC((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000D06BC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000D06E8(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000D04F8(a1);
  operator delete(v1);
}

int *sub_1000D06FC(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      int v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 547LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 547LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  __n128 result = __error();
  *__n128 result = v5;
  return result;
}

void *sub_1000D08E8()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &off_10017F7E0;
  return result;
}

void sub_1000D090C(uint64_t a1, void *a2)
{
  *a2 = &off_10017F7E0;
}

void sub_1000D0924(uint64_t a1, void **a2)
{
}

uint64_t sub_1000D092C(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_1000D0968()
{
  return &off_10017F840;
}

uint64_t sub_1000D0974(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = (a1[1] - *a1) >> 5;
  unint64_t v5 = v4 + 1;
  uint64_t v7 = (uint64_t)(a1 + 2);
  uint64_t v8 = a1[2] - v3;
  if (v8 >> 4 > v5) {
    unint64_t v5 = v8 >> 4;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v18 = a1 + 2;
  if (v9) {
    int v10 = (char *)sub_100093B30(v7, v9);
  }
  else {
    int v10 = 0LL;
  }
  os_log_type_t v14 = v10;
  uint64_t v15 = &v10[32 * v4];
  uint64_t v16 = (uint64_t)v15;
  uint64_t v17 = &v10[32 * v9];
  unint64_t v11 = (void *)sub_100116A14((uint64_t)v15, a2);
  *unint64_t v11 = off_100189898;
  void v11[3] = *(void *)(a2 + 24);
  v16 += 32LL;
  sub_1000D0A70(a1, &v14);
  uint64_t v12 = a1[1];
  sub_1000D0BA0((uint64_t)&v14);
  return v12;
}

void sub_1000D0A5C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_1000D0A70(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1000D0AE4((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1000D0AE4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a3 != a5)
  {
    uint64_t v11 = 0LL;
    do
    {
      *(void *)sub_100116A14(a7 + v11 - 32, a3 + v11 - sub_1000114F0(v6 - 32) = off_100189898;
      *(void *)(a7 + v11 - _Block_object_dispose((const void *)(v2 - 120), 8) = *(void *)(a3 + v11 - 8);
      v11 -= 32LL;
    }

    while (a3 + v11 != a5);
  }

  return a6;
}

void sub_1000D0B78(_Unwind_Exception *exception_object)
{
  for (; v2; v2 += 32LL)
    (**(void (***)(uint64_t))(v1 + v2))(v1 + v2);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000D0BA0(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = *(void (***)(void))(i - 32);
    *(void *)(a1 + 16) = i - 32;
    (*v4)();
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1000D0BF0(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 32;
      uint64_t v7 = v4 - 32;
      do
      {
        uint64_t v8 = *(void (***)(char *))v7;
        v7 -= 32;
        (*v8)(v6);
        BOOL v9 = v6 == v2;
        uint64_t v6 = v7;
      }

      while (!v9);
      uint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

uint64_t sub_1000D0C7C(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_10017F930);
  sub_1000D0E40(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000D0CB4(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017F930);
  sub_1000D0E40(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000D0CF4(char *a1)
{
}

uint64_t sub_1000D0D38(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000D0D6C(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000D0DB8(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_10017F930);
  sub_1000D0E40((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000D0DF8(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017F930);
  sub_1000D0E40((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000D0E40(uint64_t a1)
{
  *(void *)a1 = off_10017FA00;
  sub_1000D0EDC(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000D0EDC(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000D1044((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000D1004( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000D1030(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000D0E40(a1);
  operator delete(v1);
}

int *sub_1000D1044(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      int v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 863LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 863LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000D1228(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_10017FB50);
  sub_1000D13EC(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000D1260(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017FB50);
  sub_1000D13EC(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000D12A0(char *a1)
{
}

uint64_t sub_1000D12E4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000D1318(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000D1364(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_10017FB50);
  sub_1000D13EC((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000D13A4(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017FB50);
  sub_1000D13EC((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000D13EC(uint64_t a1)
{
  *(void *)a1 = off_10017FC20;
  sub_1000D1488(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000D1488(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000D15F0((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000D15B0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000D15DC(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000D13EC(a1);
  operator delete(v1);
}

int *sub_1000D15F0(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      int v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 888LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 888LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000D17D4(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_10017FD70);
  sub_1000D1998(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000D180C(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017FD70);
  sub_1000D1998(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000D184C(char *a1)
{
}

uint64_t sub_1000D1890(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000D18C4(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000D1910(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_10017FD70);
  sub_1000D1998((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000D1950(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017FD70);
  sub_1000D1998((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000D1998(uint64_t a1)
{
  *(void *)a1 = off_10017FE40;
  sub_1000D1A34(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000D1A34(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000D1B9C((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000D1B5C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000D1B88(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000D1998(a1);
  operator delete(v1);
}

int *sub_1000D1B9C(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      int v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 900LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 900LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

void *sub_1000D1D80(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000D1E68((uint64_t)a1, a2);
  *a1 = off_10017FEC8;
  a1[45] = &off_10017FFC8;
  a1[46] = &off_10017FFF0;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_10017FEC8;
  a1[45] = off_10017FF50;
  a1[46] = off_10017FF78;
  return a1;
}

void sub_1000D1E04(_Unwind_Exception *a1)
{
}

uint64_t sub_1000D1E28(uint64_t a1)
{
  return a1;
}

uint64_t sub_1000D1E68(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_100180060;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000D1ED0(_Unwind_Exception *a1)
{
}

uint64_t sub_1000D1EE4(uint64_t a1)
{
  *(void *)a1 = off_100180060;
  sub_1000D215C(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

void sub_1000D1F80(char *a1)
{
}

uint64_t sub_1000D1FC4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000D1FF8(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

uint64_t sub_1000D2044(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_10017FF90);
  sub_1000D1EE4(v2);
  return std::ios::~ios(a1 + 8);
}

void sub_1000D207C(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_10017FF90);
  sub_1000D1EE4((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

uint64_t sub_1000D20BC(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017FF90);
  sub_1000D1EE4(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000D20FC(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_10017FF90);
  sub_1000D1EE4((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

void sub_1000D2148(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000D1EE4(a1);
  operator delete(v1);
}

uint64_t sub_1000D215C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000D22AC((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000D2284( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

int *sub_1000D22AC(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      int v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 258LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 258LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000D2490(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_1001801B0);
  sub_1000D2654(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000D24C8(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001801B0);
  sub_1000D2654(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000D2508(char *a1)
{
}

uint64_t sub_1000D254C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000D2580(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000D25CC(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_1001801B0);
  sub_1000D2654((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000D260C(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001801B0);
  sub_1000D2654((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000D2654(uint64_t a1)
{
  *(void *)a1 = off_100180280;
  sub_1000D26F0(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000D26F0(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000D2858((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000D2818( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000D2844(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000D2654(a1);
  operator delete(v1);
}

int *sub_1000D2858(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      int v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 1075LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 1075LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000D2A3C(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_1001803D0);
  sub_1000D2C00(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000D2A74(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001803D0);
  sub_1000D2C00(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000D2AB4(char *a1)
{
}

uint64_t sub_1000D2AF8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000D2B2C(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000D2B78(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_1001803D0);
  sub_1000D2C00((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000D2BB8(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001803D0);
  sub_1000D2C00((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000D2C00(uint64_t a1)
{
  *(void *)a1 = off_1001804A0;
  sub_1000D2C9C(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000D2C9C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000D2E04((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000D2DC4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000D2DF0(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000D2C00(a1);
  operator delete(v1);
}

int *sub_1000D2E04(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      int v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 1081LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 1081LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000D2FE8(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_1001805F0);
  sub_1000D31AC(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000D3020(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001805F0);
  sub_1000D31AC(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000D3060(char *a1)
{
}

uint64_t sub_1000D30A4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000D30D8(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000D3124(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_1001805F0);
  sub_1000D31AC((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000D3164(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001805F0);
  sub_1000D31AC((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000D31AC(uint64_t a1)
{
  *(void *)a1 = off_1001806C0;
  sub_1000D3248(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000D3248(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000D33B0((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000D3370( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000D339C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000D31AC(a1);
  operator delete(v1);
}

int *sub_1000D33B0(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      int v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 1090LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 1090LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000D3594(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100180810);
  sub_1000D3758(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000D35CC(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100180810);
  sub_1000D3758(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000D360C(char *a1)
{
}

uint64_t sub_1000D3650(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000D3684(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000D36D0(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100180810);
  sub_1000D3758((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000D3710(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100180810);
  sub_1000D3758((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000D3758(uint64_t a1)
{
  *(void *)a1 = off_1001808E0;
  sub_1000D37F4(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000D37F4(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000D395C((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000D391C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000D3948(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000D3758(a1);
  operator delete(v1);
}

int *sub_1000D395C(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      int v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 1151LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 1151LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000D3B40(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100180A30);
  sub_1000D3D04(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000D3B78(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100180A30);
  sub_1000D3D04(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000D3BB8(char *a1)
{
}

uint64_t sub_1000D3BFC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000D3C30(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000D3C7C(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100180A30);
  sub_1000D3D04((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000D3CBC(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100180A30);
  sub_1000D3D04((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000D3D04(uint64_t a1)
{
  *(void *)a1 = off_100180B00;
  sub_1000D3DA0(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000D3DA0(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000D3F08((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000D3EC8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000D3EF4(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000D3D04(a1);
  operator delete(v1);
}

int *sub_1000D3F08(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      int v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 1188LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 1188LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000D40EC(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100180C50);
  sub_1000D42B0(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000D4124(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100180C50);
  sub_1000D42B0(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000D4164(char *a1)
{
}

uint64_t sub_1000D41A8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000D41DC(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000D4228(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100180C50);
  sub_1000D42B0((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000D4268(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100180C50);
  sub_1000D42B0((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000D42B0(uint64_t a1)
{
  *(void *)a1 = off_100180D20;
  sub_1000D434C(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000D434C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000D44B4((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000D4474( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000D44A0(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000D42B0(a1);
  operator delete(v1);
}

int *sub_1000D44B4(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      int v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 1441LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 1441LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000D4698(uint64_t a1)
{
  int v2 = sub_1000C694C(a1 + 5504);
  uint64_t v3 = *(void *)(a1 + 6600);
  if (v3 == v2)
  {
    sub_1000D4850(a1 + 5168, a1 + 5328);
    *(void *)(a1 + 5512) = 0LL;
    uint64_t v4 = *(void *)(a1 + 6200);
    if (v4)
    {
      int v5 = *(void (****)(void))(a1 + 6192);
      do
      {
        --v4;
        char v6 = *v5;
        v5 += 3;
        (*v6)();
      }

      while (v4);
    }

    *(void *)(a1 + 6200) = 0LL;
    if (*(_BYTE *)(a1 + 6184)) {
      *(_BYTE *)(a1 + 6184) = 0;
    }
    *(void *)(a1 + 6600) = 0LL;
  }

  else
  {
    if (v2 < 0) {
      int v7 = v2;
    }
    else {
      int v7 = -5;
    }
    return -(uint64_t)-v7;
  }

  return v3;
}

void *sub_1000D4768(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000D48DC((uint64_t)a1, a2);
  *a1 = off_100180DA8;
  a1[45] = &off_100180EA8;
  a1[46] = &off_100180ED0;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_100180DA8;
  a1[45] = off_100180E30;
  a1[46] = off_100180E58;
  return a1;
}

void sub_1000D47EC(_Unwind_Exception *a1)
{
}

uint64_t sub_1000D4810(uint64_t a1)
{
  return a1;
}

uint64_t sub_1000D4850(uint64_t a1, uint64_t a2)
{
  __int128 v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 25) = *(_OWORD *)(a2 + 25);
  *(_OWORD *)(a1 + 16) = v4;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = *(void *)(a2 + 48);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  __int128 v5 = *(_OWORD *)(a2 + 88);
  __int128 v6 = *(_OWORD *)(a2 + 72);
  *(_BYTE *)(a1 + 104) = *(_BYTE *)(a2 + 104);
  *(_OWORD *)(a1 + 72) = v6;
  *(_OWORD *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = v5;
  sub_100026A1C((void *)(a1 + 112), (uint64_t *)(a2 + 112));
  *(_OWORD *)(a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = *(_OWORD *)(a2 + 128);
  uint64_t v7 = *(void *)(a2 + 144);
  *(_BYTE *)(a1 + 152) = *(_BYTE *)(a2 + 152);
  *(void *)(a1 + 144) = v7;
  return a1;
}

uint64_t sub_1000D48DC(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_100180F40;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000D4944(_Unwind_Exception *a1)
{
}

uint64_t sub_1000D4958(uint64_t a1)
{
  *(void *)a1 = off_100180F40;
  sub_1000D4BD0(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

void sub_1000D49F4(char *a1)
{
}

uint64_t sub_1000D4A38(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000D4A6C(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

uint64_t sub_1000D4AB8(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100180E70);
  sub_1000D4958(v2);
  return std::ios::~ios(a1 + 8);
}

void sub_1000D4AF0(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100180E70);
  sub_1000D4958((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

uint64_t sub_1000D4B30(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100180E70);
  sub_1000D4958(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000D4B70(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100180E70);
  sub_1000D4958((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

void sub_1000D4BBC(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000D4958(a1);
  operator delete(v1);
}

uint64_t sub_1000D4BD0(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000D4D20((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000D4CF8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

int *sub_1000D4D20(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      int v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 1409LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 1409LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000D4F04(uint64_t a1)
{
  uint64_t v2 = sub_1000D4698(a1);
  if (*(_BYTE *)(a1 + 5160))
  {
    sub_1000D4F58(a1);
    *(_BYTE *)(a1 + 5160) = 0;
  }

  return v2;
}

uint64_t sub_1000D4F58(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = *(uint64_t **)(a1 + 16);
    uint64_t v91 = &v3[40 * v2];
    do
    {
      uint64_t v5 = *v3;
      int v4 = (std::__shared_weak_count *)v3[1];
      if (v4)
      {
        p_shared_owners = (unint64_t *)&v4->__shared_owners_;
        do
          unint64_t v7 = __ldxr(p_shared_owners);
        while (__stxr(v7 + 1, p_shared_owners));
      }

      *(_OWORD *)char v96 = *((_OWORD *)v3 + 1);
      *(_OWORD *)&v96[9] = *(_OWORD *)((char *)v3 + 25);
      uint64_t v8 = v3[6];
      __int128 v9 = *(_OWORD *)(v3 + 7);
      __int128 v10 = *(_OWORD *)(v3 + 11);
      __int128 v155 = *(_OWORD *)(v3 + 9);
      __int128 v156 = v10;
      char v157 = *((_BYTE *)v3 + 104);
      uint64_t v12 = v3[14];
      uint64_t v11 = (std::__shared_weak_count *)v3[15];
      if (v11)
      {
        uint64_t v13 = (unint64_t *)&v11->__shared_owners_;
        do
          unint64_t v14 = __ldxr(v13);
        while (__stxr(v14 + 1, v13));
      }

      __int128 v95 = *((_OWORD *)v3 + 8);
      unint64_t v93 = v3[18];
      char v94 = *((_BYTE *)v3 + 152);
      uint64_t v16 = v3[20];
      uint64_t v15 = (std::__shared_weak_count *)v3[21];
      if (v15)
      {
        uint64_t v17 = (unint64_t *)&v15->__shared_owners_;
        do
          unint64_t v18 = __ldxr(v17);
        while (__stxr(v18 + 1, v17));
      }

      *(_OWORD *)__int128 v92 = *((_OWORD *)v3 + 11);
      *(_OWORD *)&v92[9] = *(_OWORD *)((char *)v3 + 185);
      uint64_t v19 = v3[26];
      __int128 v20 = *(_OWORD *)(v3 + 27);
      __int128 v21 = *(_OWORD *)(v3 + 31);
      __int128 v152 = *(_OWORD *)(v3 + 29);
      __int128 v153 = v21;
      char v154 = *((_BYTE *)v3 + 264);
      uint64_t v23 = v3[34];
      uint64_t v22 = (std::__shared_weak_count *)v3[35];
      if (v22)
      {
        uint64_t v24 = (unint64_t *)&v22->__shared_owners_;
        do
          unint64_t v25 = __ldxr(v24);
        while (__stxr(v25 + 1, v24));
      }

      uint64_t v26 = 0LL;
      unint64_t v108 = (std::__shared_weak_count *)v3[38];
      char v109 = *((_BYTE *)v3 + 312);
      __int128 v107 = *((_OWORD *)v3 + 18);
      uint64_t v110 = v5;
      unint64_t v111 = v4;
      v112[0] = *(_OWORD *)v96;
      *(_OWORD *)((char *)v112 + 9) = *(_OWORD *)&v96[9];
      __int128 v114 = v9;
      __int128 v115 = v155;
      __int128 v116 = v156;
      char v117 = v157;
      uint64_t v113 = v8;
      uint64_t v118 = v12;
      char v119 = v11;
      __int128 v120 = v95;
      char v122 = v94;
      unint64_t v121 = v93;
      uint64_t v97 = v16;
      unint64_t v98 = v15;
      *(_OWORD *)((char *)v99 + 9) = *(_OWORD *)&v92[9];
      v99[0] = *(_OWORD *)v92;
      __int128 v101 = v20;
      char v104 = v154;
      __int128 v102 = v152;
      __int128 v103 = v153;
      uint64_t v100 = v19;
      uint64_t v105 = v23;
      unint64_t v106 = v22;
      uint64_t v27 = v108;
      v151[0] = 0;
      v151[528] = 0;
      while (!sub_10002B1FC((uint64_t)&v110, (uint64_t)&v97))
      {
        if (sub_1000B866C())
        {
          *(void *)&__int128 v148 = "details::for_each_sg_in_vec_internal(Fn &&, sg_vec_ref::iterator, sg_vec::iterator, size_t, BOOL) [Fn = (lambda at /Library/Caches/com.apple.xbs/Sources/DiskImages2/app/disk_images/formats/asif.cpp:1274:32)]";
          *((void *)&v148 + 1) = 104LL;
          LODWORD(v149) = 2;
          sub_100035DF8(&v136, &v148);
          sub_100004E4C(&v144, (uint64_t)"sg: ", 4LL);
          sub_100116CB8(&v144, &v110);
          std::ostream::~ostream(&v144, off_100169EF0);
          sub_10003602C((uint64_t)&v136);
          std::ios::~ios(&v145);
        }

        uint64_t v136 = 0LL;
        __int128 v137 = v27;
        char v138 = 2;
        sub_100072C74(&v110, (uint64_t)&v136, (uint64_t)&v148);
        unint64_t v29 = *(void *)a1;
        if (*(void *)a1)
        {
          if (*(_BYTE *)(v29 + 224)) {
            unint64_t v30 = v29 + 40;
          }
          else {
            unint64_t v30 = 0LL;
          }
        }

        else
        {
          unint64_t v30 = 0LL;
        }

        sub_1000C6C44(v30, *(void *)(a1 + 8), (char **)&v148);
        unint64_t v31 = v149;
        BOOL v32 = v149 >= 0 || (_DWORD)v149 == 0;
        char v33 = v32;
        if (v32)
        {
          uint64_t v34 = v150;
          if (sub_10002D4E0((uint64_t)&v110, (uint64_t)&v97, v150, v149))
          {
            uint64_t v123 = v110;
            unint64_t v124 = v111;
            if (v111)
            {
              unint64_t v38 = (unint64_t *)&v111->__shared_owners_;
              do
                unint64_t v39 = __ldxr(v38);
              while (__stxr(v39 + 1, v38));
            }

            v125[0] = v112[0];
            *(_OWORD *)((char *)v125 + 9) = *(_OWORD *)((char *)v112 + 9);
            uint64_t v126 = v113;
            __int128 v127 = v114;
            __int128 v128 = v115;
            __int128 v129 = v116;
            char v130 = v117;
            uint64_t v131 = v118;
            char v132 = v119;
            if (v119)
            {
              uint64_t v40 = (unint64_t *)&v119->__shared_owners_;
              do
                unint64_t v41 = __ldxr(v40);
              while (__stxr(v41 + 1, v40));
            }

            __int128 v133 = v120;
            unint64_t v134 = v121;
            char v135 = v122;
            sub_10002D4A4((uint64_t)&v123, (uint64_t)&v97, v34, v31, 0xFFFFFFFFFFFFFFFFLL, (uint64_t)&v136);
            sub_100035EE0((uint64_t)v151, (uint64_t)&v136);
            uint64_t v42 = v147;
            if (v147)
            {
              uint64_t v43 = (unint64_t *)&v147->__shared_owners_;
              do
                unint64_t v44 = __ldaxr(v43);
              while (__stlxr(v44 - 1, v43));
              if (!v44)
              {
                ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
                std::__shared_weak_count::__release_weak(v42);
              }
            }

            uint64_t v45 = v146;
            if (v146)
            {
              unint64_t v46 = (unint64_t *)&v146->__shared_owners_;
              do
                unint64_t v47 = __ldaxr(v46);
              while (__stlxr(v47 - 1, v46));
              if (!v47)
              {
                ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
                std::__shared_weak_count::__release_weak(v45);
              }
            }

            int v48 = v143;
            if (v143)
            {
              unint64_t v49 = (unint64_t *)&v143->__shared_owners_;
              do
                unint64_t v50 = __ldaxr(v49);
              while (__stlxr(v50 - 1, v49));
              if (!v50)
              {
                ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
                std::__shared_weak_count::__release_weak(v48);
              }
            }

            unint64_t v51 = v142;
            if (v142)
            {
              unint64_t v52 = (unint64_t *)&v142->__shared_owners_;
              do
                unint64_t v53 = __ldaxr(v52);
              while (__stlxr(v53 - 1, v52));
              if (!v53)
              {
                ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
                std::__shared_weak_count::__release_weak(v51);
              }
            }

            int v54 = v141;
            if (v141)
            {
              unint64_t v55 = (unint64_t *)&v141->__shared_owners_;
              do
                unint64_t v56 = __ldaxr(v55);
              while (__stlxr(v56 - 1, v55));
              if (!v56)
              {
                ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
                std::__shared_weak_count::__release_weak(v54);
              }
            }

            uint64_t v57 = v139;
            if (v139)
            {
              unint64_t v58 = (unint64_t *)&v139->__shared_owners_;
              do
                unint64_t v59 = __ldaxr(v58);
              while (__stlxr(v59 - 1, v58));
              if (!v59)
              {
                ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
                std::__shared_weak_count::__release_weak(v57);
              }
            }

            __int128 v60 = v132;
            if (v132)
            {
              unint64_t v61 = (unint64_t *)&v132->__shared_owners_;
              do
                unint64_t v62 = __ldaxr(v61);
              while (__stlxr(v62 - 1, v61));
              if (!v62)
              {
                ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
                std::__shared_weak_count::__release_weak(v60);
              }
            }

            uint64_t v63 = v124;
            if (v124)
            {
              unint64_t v64 = (unint64_t *)&v124->__shared_owners_;
              do
                unint64_t v65 = __ldaxr(v64);
              while (__stlxr(v65 - 1, v64));
              if (!v65)
              {
                ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
                std::__shared_weak_count::__release_weak(v63);
              }
            }

            sub_10002B7D4((uint64_t)v151, (uint64_t)&v136);
            sub_100035F24((uint64_t)&v110, (uint64_t)&v136);
            uint64_t v66 = v140;
            if (v140)
            {
              unint64_t v67 = (unint64_t *)&v140->__shared_owners_;
              do
                unint64_t v68 = __ldaxr(v67);
              while (__stlxr(v68 - 1, v67));
              if (!v68)
              {
                ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
                std::__shared_weak_count::__release_weak(v66);
              }
            }

            uint64_t v69 = v137;
            if (v137)
            {
              unint64_t v70 = (unint64_t *)&v137->__shared_owners_;
              do
                unint64_t v71 = __ldaxr(v70);
              while (__stlxr(v71 - 1, v70));
              if (!v71)
              {
                ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
                std::__shared_weak_count::__release_weak(v69);
              }
            }

            sub_10002B3A4((uint64_t)v151, (uint64_t)&v136);
            sub_100035F24((uint64_t)&v97, (uint64_t)&v136);
            uint64_t v72 = v140;
            if (v140)
            {
              unint64_t v73 = (unint64_t *)&v140->__shared_owners_;
              do
                unint64_t v74 = __ldaxr(v73);
              while (__stlxr(v74 - 1, v73));
              if (!v74)
              {
                ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
                std::__shared_weak_count::__release_weak(v72);
              }
            }

            char v75 = v137;
            if (v137)
            {
              unint64_t v76 = (unint64_t *)&v137->__shared_owners_;
              do
                unint64_t v77 = __ldaxr(v76);
              while (__stlxr(v77 - 1, v76));
              if (!v77)
              {
                ((void (*)(std::__shared_weak_count *))v75->__on_zero_shared)(v75);
                std::__shared_weak_count::__release_weak(v75);
              }
            }
          }

          sub_10002C354((uint64_t)&v110, v31);
          v26 += v31;
        }

        __int128 v35 = (std::__shared_weak_count *)*((void *)&v148 + 1);
        if (!*((void *)&v148 + 1)) {
          goto LABEL_42;
        }
        uint64_t v36 = (unint64_t *)(*((void *)&v148 + 1) + 8LL);
        do
          unint64_t v37 = __ldaxr(v36);
        while (__stlxr(v37 - 1, v36));
        if (!v37)
        {
          ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
          std::__shared_weak_count::__release_weak(v35);
          if ((v33 & 1) == 0) {
            break;
          }
        }

        else
        {
LABEL_42:
          if ((v33 & 1) == 0) {
            break;
          }
        }
      }

      sub_10002D8BC((uint64_t)v151);
      unint64_t v78 = v106;
      if (v106)
      {
        uint64_t v79 = (unint64_t *)&v106->__shared_owners_;
        do
          unint64_t v80 = __ldaxr(v79);
        while (__stlxr(v80 - 1, v79));
        if (!v80)
        {
          ((void (*)(std::__shared_weak_count *))v78->__on_zero_shared)(v78);
          std::__shared_weak_count::__release_weak(v78);
        }
      }

      uint64_t v81 = v98;
      if (v98)
      {
        uint64_t v82 = (unint64_t *)&v98->__shared_owners_;
        do
          unint64_t v83 = __ldaxr(v82);
        while (__stlxr(v83 - 1, v82));
        if (!v83)
        {
          ((void (*)(std::__shared_weak_count *))v81->__on_zero_shared)(v81);
          std::__shared_weak_count::__release_weak(v81);
        }
      }

      uint64_t v84 = v119;
      if (v119)
      {
        unint64_t v85 = (unint64_t *)&v119->__shared_owners_;
        do
          unint64_t v86 = __ldaxr(v85);
        while (__stlxr(v86 - 1, v85));
        if (!v86)
        {
          ((void (*)(std::__shared_weak_count *))v84->__on_zero_shared)(v84);
          std::__shared_weak_count::__release_weak(v84);
        }
      }

      unint64_t v87 = v111;
      if (v111)
      {
        unint64_t v88 = (unint64_t *)&v111->__shared_owners_;
        do
          unint64_t v89 = __ldaxr(v88);
        while (__stlxr(v89 - 1, v88));
        if (!v89)
        {
          ((void (*)(std::__shared_weak_count *))v87->__on_zero_shared)(v87);
          std::__shared_weak_count::__release_weak(v87);
        }
      }

      v3 += 40;
    }

    while (v3 != v91);
  }

  sub_1000D5A7C((void **)(a1 + 16));
  sub_1000BBEA0((unint64_t *)a1);
  return a1;
}

void sub_1000D57F8( _Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, char a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,char a58)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  unint64_t v59 = (std::__shared_weak_count *)STACK[0x4E0];
  if (STACK[0x4E0])
  {
    p_shared_owners = (unint64_t *)&v59->__shared_owners_;
    do
      unint64_t v61 = __ldaxr(p_shared_owners);
    while (__stlxr(v61 - 1, p_shared_owners));
    if (!v61)
    {
      ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
      std::__shared_weak_count::__release_weak(v59);
    }
  }

  sub_10002D8BC((uint64_t)&STACK[0x508]);
  sub_1000114F0(a10);
  sub_1000114F0((uint64_t)&a38);
  sub_1000114F0(a11);
  sub_1000114F0((uint64_t)&a58);
  sub_10000491C(a1);
}

void **sub_1000D5A7C(void **a1)
{
  uint64_t v2 = (char *)a1[1];
  if (v2)
  {
    uint64_t v3 = (char *)*a1;
    do
    {
      --v2;
      sub_1000114F0((uint64_t)(v3 + 272));
      sub_1000114F0((uint64_t)(v3 + 160));
      sub_1000114F0((uint64_t)(v3 + 112));
      sub_1000114F0((uint64_t)v3);
      v3 += 320;
    }

    while (v2);
  }

  if (a1[2] && a1 + 3 != *a1) {
    operator delete(*a1);
  }
  return a1;
}

unint64_t *sub_1000D5AFC(unint64_t *a1, unint64_t *a2)
{
  *a1 = 0LL;
  uint64_t v3 = (unint64_t *)atomic_load(a2);
  if (!v3) {
    goto LABEL_9;
  }
  unint64_t v4 = atomic_load(v3);
  if (!v4) {
    goto LABEL_8;
  }
  while (1)
  {
    unint64_t v5 = __ldaxr(v3);
    if (v5 != v4)
    {
      __clrex();
      goto LABEL_7;
    }

    if (!__stlxr(v4 + 1, v3)) {
      break;
    }
LABEL_7:
    unint64_t v4 = v5;
    if (!v5) {
      goto LABEL_8;
    }
  }

  unint64_t v7 = (unint64_t *)v3[41];
  if (v7)
  {
    do
      unint64_t v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
    v3[42] = v8;
  }

  if (!sub_1000D5BCC((uint64_t)v3))
  {
    do
      unint64_t v9 = __ldaxr(v3);
    while (__stlxr(v9 - 1, v3));
    if (v9 == 1)
    {
      uint64_t v10 = v3[4];
      v3[4] = -1LL;
      sub_1000BBEE0((uint64_t)v3, v10, 1u);
    }

BOOL sub_1000D5BCC(uint64_t a1)
{
  uint64_t v2 = (unsigned int *)(a1 + 24);
  unsigned int v3 = atomic_load((unsigned int *)(a1 + 24));
  if (v3 == 2)
  {
    unint64_t v4 = atomic_load((unint64_t *)a1);
    return v4 > 1;
  }

  else
  {
    char v6 = (unint64_t *)(a1 + 8);
    do
      unint64_t v7 = __ldaxr(v6);
    while (__stlxr(v7 + 1, v6));
    unsigned int v8 = atomic_load(v2);
    if (v8 != 2 && !*(_BYTE *)(a1 + 344)) {
      sub_1000D5C78(a1 + 24, 1u, 5u);
    }
    do
      unint64_t v9 = __ldaxr(v6);
    while (__stlxr(v9 - 1, v6));
    unint64_t v10 = atomic_load((unint64_t *)a1);
    if (v10 < 2)
    {
      return 0LL;
    }

    else
    {
      unsigned int v11 = atomic_load(v2);
      return v11 == 2;
    }
  }

BOOL sub_1000D5C78(uint64_t a1, unsigned int a2, unsigned int a3)
{
  *(void *)&__int128 v4 = a1;
  *((void *)&v4 + 1) = __PAIR64__(a3, a2);
  uint64_t v5 = a1;
  __int128 v6 = v4;
  return sub_1000D5CB8((uint64_t)&v4, (uint64_t)&v5, 0LL);
}

BOOL sub_1000D5CB8( uint64_t a1, uint64_t a2, std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep a3)
{
  v6.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  unsigned int v7 = 0;
  while (1)
  {
    unsigned int v8 = *(unsigned int **)a1;
    int v9 = *(_DWORD *)(a1 + 12);
    else {
      unsigned int v10 = *v8;
    }
    int v11 = *(_DWORD *)(a1 + 8);
    if (v10 != v11) {
      break;
    }
    if (v7 <= 0x3F)
    {
      ++v7;
    }

    else
    {
      v12.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_ - v6.__d_.__rep_;
    }
  }

  return v10 != v11;
}

uint64_t sub_1000D5D70(uint64_t a1, uint64_t a2)
{
  if (a2 < 64001)
  {
    if (a2 >= 4001) {
      sched_yield();
    }
    return 0LL;
  }

  std::__cxx_contention_t v3 = std::__libcpp_atomic_monitor(*(const void **)a1);
  __int128 v4 = *(unsigned int **)(a1 + 8);
  int v5 = *(_DWORD *)(a1 + 20);
  else {
    unsigned int v6 = *v4;
  }
  if (v6 == *(_DWORD *)(a1 + 16))
  {
    std::__libcpp_atomic_wait(*(const void **)a1, v3);
    return 0LL;
  }

  return 1LL;
}

void sub_1000D5DFC(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  int64_t v4 = *a3 - *a2;
  unint64_t v5 = 0xCCCCCCCCCCCCCCCDLL * (v4 >> 6);
  if (v5 <= a1[2])
  {
    uint64_t v11 = *a2;
    sub_1000D5FE4((uint64_t)a1, &v11, v5, *a1, a1[1]);
    a1[1] = v5;
  }

  else
  {
    if (v5 >= 0x66666666666667LL) {
      sub_100014AD4("get_next_capacity, allocator's max size reached");
    }
    unsigned int v8 = operator new(v4);
    int v9 = (uint64_t *)*a1;
    if (*a1)
    {
      sub_1000D5EF0(a1);
      if (a1 + 3 != v9) {
        operator delete(v9);
      }
    }

    a1[1] = 0LL;
    a1[2] = v5;
    *a1 = (uint64_t)v8;
    uint64_t v10 = *a2;
    uint64_t v12 = *a3;
    uint64_t v13 = v10;
    sub_1000D5F54(a1, &v13, &v12);
  }

uint64_t *sub_1000D5EF0(uint64_t *result)
{
  uint64_t v1 = result;
  uint64_t v2 = result[1];
  if (v2)
  {
    uint64_t v3 = *result;
    do
    {
      --v2;
      sub_1000114F0(v3 + 272);
      sub_1000114F0(v3 + 160);
      sub_1000114F0(v3 + 112);
      uint64_t result = (uint64_t *)sub_1000114F0(v3);
      v3 += 320LL;
    }

    while (v2);
  }

  v1[1] = 0LL;
  return result;
}

void sub_1000D5F54(void *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v4 = a1[1];
  uint64_t v5 = *a1 + 320 * v4;
  uint64_t v6 = *a2;
  uint64_t v7 = *a3;
  uint64_t v8 = v5;
  if (*a2 != *a3)
  {
    do
    {
      sub_10002D61C(v8, v6);
      sub_10002D61C(v8 + 160, v6 + 160);
      v6 += 320LL;
      v8 += 320LL;
    }

    while (v6 != v7);
    uint64_t v4 = a1[1];
  }

  a1[1] = v4 - 0x3333333333333333LL * ((v8 - v5) >> 6);
}

void sub_1000D5FE4(uint64_t a1, uint64_t *a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v9 = a5 - a3;
  if (a5 >= a3)
  {
    if (a3)
    {
      uint64_t v13 = *a2;
      unint64_t v14 = a3;
      do
      {
        --v14;
        sub_1000D4850(a4, v13);
        sub_1000D4850(a4 + 160, v13 + 160);
        a4 += 320LL;
        v13 += 320LL;
      }

      while (v14);
    }

    if (a5 != a3)
    {
      unint64_t v15 = a3 - a5;
      do
      {
        sub_1000114F0(a4 + 272);
        sub_1000114F0(a4 + 160);
        sub_1000114F0(a4 + 112);
        sub_1000114F0(a4);
        a4 += 320LL;
        BOOL v12 = __CFADD__(v15++, 1LL);
      }

      while (!v12);
    }
  }

  else
  {
    uint64_t v10 = *a2;
    if (a5)
    {
      unint64_t v11 = a5;
      do
      {
        --v11;
        sub_1000D4850(a4, v10);
        sub_1000D4850(a4 + 160, v10 + 160);
        v10 += 320LL;
        a4 += 320LL;
      }

      while (v11);
    }

    *a2 = v10;
    if (a3 != a5)
    {
      do
      {
        sub_10002D61C(a4, v10);
        sub_10002D61C(a4 + 160, v10 + 160);
        v10 += 320LL;
        a4 += 320LL;
        BOOL v12 = __CFADD__(v9++, 1LL);
      }

      while (!v12);
    }
  }

void sub_1000D6108(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  uint64_t v10 = *a1;
  unint64_t v11 = sub_1000D6298((uint64_t)a1, a3);
  if (v11 >= 0x66666666666667LL) {
    sub_100014AD4("get_next_capacity, allocator's max size reached");
  }
  uint64_t v12 = v11;
  uint64_t v13 = operator new(320 * v11);
  sub_1000D6310(a1, (uint64_t)v13, v12, a2, a3, a4);
  *a5 = *a1 + a2 - v10;
}

__n128 sub_1000D61B4(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)a2 = 0LL;
  *(void *)(a2 + _Block_object_dispose((const void *)(v2 - 120), 8) = 0LL;
  __int128 v2 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 25) = *(_OWORD *)(a2 + 25);
  *(_OWORD *)(a1 + 16) = v2;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = *(void *)(a2 + 48);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  __int128 v3 = *(_OWORD *)(a2 + 72);
  __int128 v4 = *(_OWORD *)(a2 + 88);
  *(_BYTE *)(a1 + 104) = *(_BYTE *)(a2 + 104);
  *(_OWORD *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = v4;
  *(_OWORD *)(a1 + 72) = v3;
  *(_OWORD *)(a1 + sub_1000114F0(v49 + 112) = *(_OWORD *)(a2 + 112);
  *(void *)(a2 + sub_1000114F0(v49 + 112) = 0LL;
  *(void *)(a2 + 120) = 0LL;
  *(_OWORD *)(a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = *(_OWORD *)(a2 + 128);
  uint64_t v5 = *(void *)(a2 + 144);
  *(_BYTE *)(a1 + 152) = *(_BYTE *)(a2 + 152);
  *(void *)(a1 + 144) = v5;
  *(_OWORD *)(a1 + 160) = *(_OWORD *)(a2 + 160);
  *(void *)(a2 + 160) = 0LL;
  *(void *)(a2 + 16_Block_object_dispose((const void *)(v2 - 120), 8) = 0LL;
  __int128 v6 = *(_OWORD *)(a2 + 176);
  *(_OWORD *)(a1 + 185) = *(_OWORD *)(a2 + 185);
  *(_OWORD *)(a1 + 176) = v6;
  *(void *)(a1 + 20_Block_object_dispose((const void *)(v2 - 120), 8) = *(void *)(a2 + 208);
  *(void *)(a1 + 216) = *(void *)(a2 + 216);
  *(void *)(a1 + 224) = *(void *)(a2 + 224);
  __int128 v7 = *(_OWORD *)(a2 + 232);
  __int128 v8 = *(_OWORD *)(a2 + 248);
  *(_BYTE *)(a1 + 264) = *(_BYTE *)(a2 + 264);
  *(_OWORD *)(a1 + 24_Block_object_dispose((const void *)(v2 - 120), 8) = v8;
  *(_OWORD *)(a1 + 2sub_1000114F0(v6 - 32) = v7;
  *(_OWORD *)(a1 + 272) = *(_OWORD *)(a2 + 272);
  *(void *)(a2 + 272) = 0LL;
  *(void *)(a2 + 280) = 0LL;
  __n128 result = *(__n128 *)(a2 + 288);
  *(__n128 *)(a1 + 28_Block_object_dispose((const void *)(v2 - 120), 8) = result;
  uint64_t v10 = *(void *)(a2 + 304);
  *(_BYTE *)(a1 + 312) = *(_BYTE *)(a2 + 312);
  *(void *)(a1 + 304) = v10;
  return result;
}

unint64_t sub_1000D6298(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = 0x66666666666666LL;
  uint64_t v3 = *(void *)(a1 + 8);
  unint64_t v4 = *(void *)(a1 + 16);
  if (0x66666666666666LL - v4 < a2 - v4 + v3) {
    sub_100014AD4("get_next_capacity, allocator's max size reached");
  }
  unint64_t v5 = v4 >> 61;
  unint64_t v6 = 8 * v4;
  if (v5 > 4) {
    uint64_t v7 = -1LL;
  }
  else {
    uint64_t v7 = v6;
  }
  unint64_t v8 = v6 / 5;
  if (v5) {
    unint64_t v8 = v7;
  }
  unint64_t v9 = v3 + a2;
  if (v8 < 0x66666666666666LL) {
    unint64_t v2 = v8;
  }
  if (v9 <= v2) {
    return v2;
  }
  else {
    return v9;
  }
}

void sub_1000D6310(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10 = *a1;
  sub_1000D63FC((uint64_t)a1, *a1, a4, *a1 + 320 * a1[1], a2, a5, a6);
  if (v10)
  {
    for (uint64_t i = a1[1]; i; v10 += 320LL)
    {
      --i;
      sub_1000114F0(v10 + 272);
      sub_1000114F0(v10 + 160);
      sub_1000114F0(v10 + 112);
      sub_1000114F0(v10);
    }
  }

  uint64_t v12 = a1[1] + a5;
  *a1 = a2;
  a1[1] = v12;
  a1[2] = a3;
}

void sub_1000D63D8(_Unwind_Exception *exception_object)
{
  if (v1)
  {
  }

  _Unwind_Resume(exception_object);
}

uint64_t *sub_1000D63FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = a3;
  void v16[2] = a1;
  if (a2 != a3)
  {
    uint64_t v12 = a2;
    do
    {
      sub_1000D61B4(a5, v12);
      v12 += 320LL;
      a5 += 320LL;
    }

    while (v12 != v11);
  }

  sub_1000D61B4(a5, a7);
  if (v11 != a4)
  {
    uint64_t v13 = a5 + 320 * a6;
    do
    {
      sub_1000D61B4(v13, v11);
      v11 += 320LL;
      uint64_t v13 = v14 + 320;
    }

    while (v11 != a4);
  }

  v16[0] = 0LL;
  v16[1] = 0LL;
  return sub_1000D64AC(v16);
}

uint64_t *sub_1000D64AC(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1 != a1[1])
  {
    do
    {
      sub_1000114F0(v2 + 272);
      sub_1000114F0(v2 + 160);
      sub_1000114F0(v2 + 112);
      sub_1000114F0(v2);
      uint64_t v3 = a1[1];
      uint64_t v2 = *a1 + 320;
      *a1 = v2;
    }

    while (v2 != v3);
  }

  return a1;
}

void sub_1000D6518(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  uint64_t v10 = *a1;
  unint64_t v11 = sub_10005F3B4((uint64_t)a1, a3);
  if (v11 >= 0x555555555555556LL) {
    sub_100014AD4("get_next_capacity, allocator's max size reached");
  }
  uint64_t v12 = v11;
  uint64_t v13 = operator new(24 * v11);
  sub_1000D65C4(a1, (uint64_t)v13, v12, a2, a3, a4);
  *a5 = *a1 + a2 - v10;
}

void sub_1000D65C4(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10 = *a1;
  sub_1000D66A0((uint64_t)a1, *a1, a4, *a1 + 24 * a1[1], a2, a5, a6);
  if (v10)
  {
    uint64_t v11 = a1[1];
    if (v11)
    {
      uint64_t v12 = (void (***)(uint64_t))v10;
      do
      {
        --v11;
        uint64_t v13 = *v12;
        v12 += 3;
        (*v13)(v10);
        uint64_t v10 = (uint64_t)v12;
      }

      while (v11);
    }
  }

  uint64_t v14 = a1[1] + a5;
  *a1 = a2;
  a1[1] = v14;
  a1[2] = a3;
}

void sub_1000D667C(_Unwind_Exception *exception_object)
{
  if (v1)
  {
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1000D66A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v12 = a5;
  if (a2 != a3)
  {
    uint64_t v14 = 0LL;
    do
    {
      sub_100116A14(a5 + v14, a2 + v14);
      v14 += 24LL;
    }

    while (a2 + v14 != a3);
    uint64_t v12 = a5 + v14;
  }

  uint64_t result = sub_100116A14(v12, a7);
  if (a3 != a4)
  {
    uint64_t v16 = 0LL;
    uint64_t v17 = v12 + 24 * a6;
    do
    {
      uint64_t result = sub_100116A14(v17 + v16, a3 + v16);
      v16 += 24LL;
    }

    while (a3 + v16 != a4);
  }

  return result;
}

void sub_1000D6754(_Unwind_Exception *exception_object)
{
  if (v2 != v1)
  {
    unint64_t v4 = v1;
    do
    {
      unint64_t v5 = *v4;
      v4 += 3;
      (*v5)(v1);
      uint64_t v1 = v4;
    }

    while (v4 != v2);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1000D6808(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = *(void (****)(void))a1;
    do
    {
      --v2;
      unint64_t v4 = *v3;
      v3 += 3;
      (*v4)();
    }

    while (v2);
  }

  if (*(void *)(a1 + 16) && a1 + 24 != *(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1000D6874(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100181090);
  sub_1000D6A38(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000D68AC(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100181090);
  sub_1000D6A38(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000D68EC(char *a1)
{
}

uint64_t sub_1000D6930(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000D6964(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000D69B0(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100181090);
  sub_1000D6A38((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000D69F0(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100181090);
  sub_1000D6A38((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000D6A38(uint64_t a1)
{
  *(void *)a1 = off_100181160;
  sub_1000D6AD4(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000D6AD4(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000D6C3C((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000D6BFC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000D6C28(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000D6A38(a1);
  operator delete(v1);
}

int *sub_1000D6C3C(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      uint64_t v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 1513LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 1513LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

BOOL sub_1000D6E20(unint64_t *a1)
{
  while (1)
  {
    unint64_t v2 = *a1;
    if ((*a1 & 0x8000000000000000LL) != 0)
    {
      unint64_t v3 = *a1;
    }

    else
    {
      do
      {
        unint64_t v3 = __ldaxr(a1);
        if (v3 == v2)
        {
          if (!__stlxr(v2 + 1, a1)) {
            return v2 != -1LL;
          }
        }

        else
        {
          __clrex();
        }

        unint64_t v2 = v3;
      }

      while ((v3 & 0x8000000000000000LL) == 0);
    }

    unint64_t v2 = v3;
    if (v3 != -1LL) {
      break;
    }
    if ((sub_1000D6EAC(a1, 0) & 1) == 0)
    {
      unint64_t v2 = -1LL;
      return v2 != -1LL;
    }
  }

  return v2 != -1LL;
}

uint64_t sub_1000D6EAC(unint64_t *a1, int a2)
{
  unint64_t v2 = atomic_load(a1);
  BOOL v3 = v2 == 0;
  BOOL v4 = v2 != -1LL;
  if (a2) {
    BOOL v4 = v3;
  }
  if (!v4)
  {
    v16.__m_ = (std::unique_lock<std::mutex>::mutex_type *)sub_100116890((unint64_t)a1);
    v16.__owns_ = 1;
    std::mutex::lock(v16.__m_);
    uint64_t v7 = sub_100116950((unint64_t)a1);
    unint64_t v8 = atomic_load(a1);
    BOOL v9 = v8 == 0;
    BOOL v10 = v8 != -1LL;
    if (a2) {
      BOOL v10 = v9;
    }
    if (!v10)
    {
      uint64_t v11 = (std::condition_variable *)v7;
      do
      {
        std::condition_variable::wait(v11, &v16);
        unint64_t v12 = atomic_load(a1);
        BOOL v13 = v12 == 0;
        BOOL v14 = v12 != -1LL;
        if (a2) {
          BOOL v14 = v13;
        }
      }

      while (!v14);
    }

    if (v16.__owns_) {
      std::mutex::unlock(v16.__m_);
    }
  }

  return 1LL;
}

void sub_1000D6F84(_Unwind_Exception *a1)
{
}

unint64_t sub_1000D6F98( uint64_t (*a1)(__int128 *), __int128 *a2, __int128 *a3, unint64_t a4)
{
  __int128 v4 = *a2;
  __int128 v5 = a2[1];
  *(void *)a2 = 0LL;
  *((void *)a2 + 1) = 0LL;
  __int128 v40 = v4;
  v41[0] = v5;
  *(_OWORD *)((char *)v41 + 9) = *(__int128 *)((char *)a2 + 25);
  uint64_t v42 = *((void *)a2 + 6);
  __int128 v43 = *(__int128 *)((char *)a2 + 56);
  __int128 v44 = *(__int128 *)((char *)a2 + 72);
  __int128 v45 = *(__int128 *)((char *)a2 + 88);
  char v46 = *((_BYTE *)a2 + 104);
  __int128 v6 = a2[7];
  __int128 v7 = a2[8];
  *((void *)a2 + 14) = 0LL;
  *((void *)a2 + 15) = 0LL;
  __int128 v47 = v6;
  __int128 v48 = v7;
  char v50 = *((_BYTE *)a2 + 152);
  uint64_t v49 = *((void *)a2 + 18);
  __int128 v8 = *a3;
  __int128 v9 = a3[1];
  *(void *)a3 = 0LL;
  *((void *)a3 + 1) = 0LL;
  __int128 v29 = v8;
  v30[0] = v9;
  *(_OWORD *)((char *)v30 + 9) = *(__int128 *)((char *)a3 + 25);
  uint64_t v31 = *((void *)a3 + 6);
  __int128 v32 = *(__int128 *)((char *)a3 + 56);
  __int128 v10 = *(__int128 *)((char *)a3 + 72);
  __int128 v11 = *(__int128 *)((char *)a3 + 88);
  char v35 = *((_BYTE *)a3 + 104);
  __int128 v34 = v11;
  __int128 v33 = v10;
  __int128 v12 = a3[7];
  __int128 v13 = a3[8];
  *((void *)a3 + 14) = 0LL;
  *((void *)a3 + 15) = 0LL;
  __int128 v36 = v12;
  __int128 v37 = v13;
  uint64_t v14 = *((void *)a3 + 18);
  char v39 = *((_BYTE *)a3 + 152);
  uint64_t v38 = v14;
  unint64_t v15 = sub_1000D71B4(a1, &v40, (uint64_t)&v29, a4, 0);
  std::unique_lock<std::mutex> v16 = (std::__shared_weak_count *)*((void *)&v36 + 1);
  if (*((void *)&v36 + 1))
  {
    uint64_t v17 = (unint64_t *)(*((void *)&v36 + 1) + 8LL);
    do
      unint64_t v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }

  uint64_t v19 = (std::__shared_weak_count *)*((void *)&v29 + 1);
  if (*((void *)&v29 + 1))
  {
    int v20 = (unint64_t *)(*((void *)&v29 + 1) + 8LL);
    do
      unint64_t v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }

  uint64_t v22 = (std::__shared_weak_count *)*((void *)&v47 + 1);
  if (*((void *)&v47 + 1))
  {
    __int16 v23 = (unint64_t *)(*((void *)&v47 + 1) + 8LL);
    do
      unint64_t v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }

  __int16 v25 = (std::__shared_weak_count *)*((void *)&v40 + 1);
  if (*((void *)&v40 + 1))
  {
    uint64_t v26 = (unint64_t *)(*((void *)&v40 + 1) + 8LL);
    do
      unint64_t v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }

  return v15;
}

void sub_1000D7188( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29)
{
}

unint64_t sub_1000D71B4( uint64_t (*a1)(__int128 *), void *a2, uint64_t a3, unint64_t a4, char a5)
{
  unint64_t v7 = 0LL;
  unint64_t v8 = *(void *)(a3 + 144);
  v34[0] = 0;
  v34[528] = 0;
  while (!sub_10002B1FC((uint64_t)a2, a3))
  {
    if (a2[18] >= v8 || v7 >= a4) {
      break;
    }
    if (sub_1000B866C())
    {
      *(void *)&__int128 v32 = "details::for_each_sg_in_vec_internal(Fn &&, sg_vec_ref::iterator, sg_vec::iterator, size_t, BOOL) [Fn = io_result_t (&)(const sg_entry &)]";
      *((void *)&v32 + 1) = 119LL;
      int v33 = 2;
      sub_100035DF8(v27, &v32);
      sub_100004E4C(&v30, (uint64_t)"sg: ", 4LL);
      sub_100116CB8(&v30, a2);
      std::ostream::~ostream(&v30, off_100169EF0);
      sub_10003602C((uint64_t)v27);
      std::ios::~ios(&v31);
    }

    v27[0] = 0LL;
    v27[1] = v8;
    char v28 = 2;
    sub_100072C74(a2, (uint64_t)v27, (uint64_t)&v32);
    int64_t v10 = a1(&v32);
    unint64_t v12 = v10;
    BOOL v13 = v10 >= 0 || (_DWORD)v10 == 0;
    char v14 = v13;
    if (v13)
    {
      uint64_t v15 = v11;
      if (sub_10002D4E0((uint64_t)a2, a3, v11, v10))
      {
        sub_10002D61C((uint64_t)v25, (uint64_t)a2);
        sub_10002D4A4((uint64_t)v25, a3, v15, v12, a4, (uint64_t)v27);
        sub_100035EE0((uint64_t)v34, (uint64_t)v27);
        sub_10002D4FC((uint64_t)v27);
        sub_1000114F0((uint64_t)&v26);
        sub_1000114F0((uint64_t)v25);
        sub_10002B7D4((uint64_t)v34, (uint64_t)v27);
        sub_100035F24((uint64_t)a2, (uint64_t)v27);
        sub_1000114F0((uint64_t)v29);
        sub_1000114F0((uint64_t)v27);
        sub_10002B3A4((uint64_t)v34, (uint64_t)v27);
        sub_100035F24(a3, (uint64_t)v27);
        sub_1000114F0((uint64_t)v29);
        sub_1000114F0((uint64_t)v27);
      }

      if ((a5 & 1) != 0) {
        sub_10002C354((uint64_t)a2, v12);
      }
      else {
        sub_10002C52C((uint64_t)a2, v12);
      }
      v7 += v12;
    }

    else
    {
      else {
        uint64_t v19 = -(int)v10;
      }
      unint64_t v21 = -v19;
    }

    std::unique_lock<std::mutex> v16 = (std::__shared_weak_count *)*((void *)&v32 + 1);
    if (*((void *)&v32 + 1))
    {
      uint64_t v17 = (unint64_t *)(*((void *)&v32 + 1) + 8LL);
      do
        unint64_t v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }

    if ((v14 & 1) == 0) {
      goto LABEL_35;
    }
  }

  unint64_t v21 = v7;
LABEL_35:
  sub_10002D8BC((uint64_t)v34);
  return v21;
}

void sub_1000D7470(_Unwind_Exception *a1)
{
}

uint64_t sub_1000D74E4(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_1001812B0);
  sub_1000D76A8(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000D751C(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001812B0);
  sub_1000D76A8(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000D755C(char *a1)
{
}

uint64_t sub_1000D75A0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000D75D4(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000D7620(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_1001812B0);
  sub_1000D76A8((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000D7660(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001812B0);
  sub_1000D76A8((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000D76A8(uint64_t a1)
{
  *(void *)a1 = off_100181380;
  sub_1000D7744(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000D7744(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000D78AC((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000D786C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000D7898(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000D76A8(a1);
  operator delete(v1);
}

int *sub_1000D78AC(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      int64_t v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 2061LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      unint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    BOOL v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        std::unique_lock<std::mutex> v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 2061LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000D7A90(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_1001814D0);
  sub_1000D7C54(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000D7AC8(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001814D0);
  sub_1000D7C54(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000D7B08(char *a1)
{
}

uint64_t sub_1000D7B4C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000D7B80(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000D7BCC(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_1001814D0);
  sub_1000D7C54((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000D7C0C(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001814D0);
  sub_1000D7C54((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000D7C54(uint64_t a1)
{
  *(void *)a1 = off_1001815A0;
  sub_1000D7CF0(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000D7CF0(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000D7E58((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000D7E18( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000D7E44(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000D7C54(a1);
  operator delete(v1);
}

int *sub_1000D7E58(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      int64_t v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 2071LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      unint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    BOOL v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        std::unique_lock<std::mutex> v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 2071LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000D803C(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_1001816F0);
  sub_1000D8200(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000D8074(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001816F0);
  sub_1000D8200(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000D80B4(char *a1)
{
}

uint64_t sub_1000D80F8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000D812C(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000D8178(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_1001816F0);
  sub_1000D8200((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000D81B8(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001816F0);
  sub_1000D8200((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000D8200(uint64_t a1)
{
  *(void *)a1 = off_1001817C0;
  sub_1000D829C(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000D829C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000D8404((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000D83C4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000D83F0(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000D8200(a1);
  operator delete(v1);
}

int *sub_1000D8404(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      int64_t v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 2311LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      unint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    BOOL v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        std::unique_lock<std::mutex> v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 2311LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000D85E8(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100181910);
  sub_1000D87AC(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000D8620(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100181910);
  sub_1000D87AC(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000D8660(char *a1)
{
}

uint64_t sub_1000D86A4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000D86D8(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000D8724(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100181910);
  sub_1000D87AC((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000D8764(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100181910);
  sub_1000D87AC((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000D87AC(uint64_t a1)
{
  *(void *)a1 = off_1001819E0;
  sub_1000D8848(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000D8848(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000D89B0((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000D8970( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000D899C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000D87AC(a1);
  operator delete(v1);
}

int *sub_1000D89B0(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      int64_t v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 2321LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      unint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    BOOL v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        std::unique_lock<std::mutex> v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 2321LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

void *sub_1000D8B94(void *a1, unint64_t a2)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if (a2)
  {
    sub_100081F0C(a1, a2);
    int v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }

  return a1;
}

void sub_1000D8BEC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose((const void *)(v2 - 120), 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void *sub_1000D8C08(void *a1, unint64_t a2)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if (a2)
  {
    sub_100081F0C(a1, a2);
    int v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }

  return a1;
}

void sub_1000D8C60(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose((const void *)(v2 - 120), 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void *sub_1000D8C7C(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000D8D64((uint64_t)a1, a2);
  *a1 = off_100181AA8;
  a1[45] = &off_100181BA8;
  a1[46] = &off_100181BD0;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_100181AA8;
  a1[45] = off_100181B30;
  a1[46] = off_100181B58;
  return a1;
}

void sub_1000D8D00(_Unwind_Exception *a1)
{
}

uint64_t sub_1000D8D24(uint64_t a1)
{
  return a1;
}

uint64_t sub_1000D8D64(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_100181C40;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000D8DCC(_Unwind_Exception *a1)
{
}

uint64_t sub_1000D8DE0(uint64_t a1)
{
  *(void *)a1 = off_100181C40;
  sub_1000D9058(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

void sub_1000D8E7C(char *a1)
{
}

uint64_t sub_1000D8EC0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000D8EF4(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

uint64_t sub_1000D8F40(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100181B70);
  sub_1000D8DE0(v2);
  return std::ios::~ios(a1 + 8);
}

void sub_1000D8F78(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100181B70);
  sub_1000D8DE0((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

uint64_t sub_1000D8FB8(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100181B70);
  sub_1000D8DE0(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000D8FF8(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100181B70);
  sub_1000D8DE0((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

void sub_1000D9044(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000D8DE0(a1);
  operator delete(v1);
}

uint64_t sub_1000D9058(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000D91A8((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000D9180( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

int *sub_1000D91A8(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      int64_t v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 158LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      unint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    BOOL v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        std::unique_lock<std::mutex> v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 158LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

void sub_1000D938C(std::exception *a1)
{
}

const char *sub_1000D93A0()
{
  return "File too small.";
}

void sub_1000D93AC(void *a1@<X0>, void *a2@<X8>)
{
  int v4 = (char *)(*(uint64_t (**)(void *))(*a1 + 16LL))(a1);
  sub_100004CB0(v17, v4);
  sub_100026C20((uint64_t)v12);
  if ((v18 & 0x80u) == 0) {
    int v5 = v17;
  }
  else {
    int v5 = (void **)v17[0];
  }
  if ((v18 & 0x80u) == 0) {
    uint64_t v6 = v18;
  }
  else {
    uint64_t v6 = (uint64_t)v17[1];
  }
  uint64_t v7 = sub_100004E4C(&v13, (uint64_t)v5, v6);
  uint64_t v8 = sub_100004E4C(v7, (uint64_t)" header size ", 13LL);
  uint64_t v9 = (void *)std::ostream::operator<<(v8, a1[2]);
  int64_t v10 = sub_100004E4C(v9, (uint64_t)", but file size only ", 21LL);
  std::ostream::operator<<(v10, a1[3]);
  sub_1000049D8((uint64_t)v14, a2);
  *(void *)((char *)v12
  uint64_t v13 = v11;
  if (v15 < 0) {
    operator delete((void *)v14[8]);
  }
  std::streambuf::~streambuf(v14);
  std::ios::~ios(&v16);
}

void sub_1000D94DC(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    int v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        uint64_t v4 = sub_1000114F0(v4 - 48);
      while ((void *)v4 != v2);
      int v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

uint64_t sub_1000D954C(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100181DC0);
  sub_1000D9710(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000D9584(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100181DC0);
  sub_1000D9710(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000D95C4(char *a1)
{
}

uint64_t sub_1000D9608(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000D963C(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000D9688(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100181DC0);
  sub_1000D9710((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000D96C8(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100181DC0);
  sub_1000D9710((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000D9710(uint64_t a1)
{
  *(void *)a1 = off_100181E90;
  sub_1000D97AC(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000D97AC(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000D9914((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000D98D4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000D9900(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000D9710(a1);
  operator delete(v1);
}

int *sub_1000D9914(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      int64_t v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 2831LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      unint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 2831LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000D9AF8(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100181FE0);
  sub_1000D9CBC(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000D9B30(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100181FE0);
  sub_1000D9CBC(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000D9B70(char *a1)
{
}

uint64_t sub_1000D9BB4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000D9BE8(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000D9C34(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100181FE0);
  sub_1000D9CBC((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000D9C74(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100181FE0);
  sub_1000D9CBC((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000D9CBC(uint64_t a1)
{
  *(void *)a1 = off_1001820B0;
  sub_1000D9D58(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000D9D58(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000D9EC0((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000D9E80( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000D9EAC(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000D9CBC(a1);
  operator delete(v1);
}

int *sub_1000D9EC0(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      int64_t v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 2828LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      unint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 2828LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

void sub_1000DA0A8(std::__shared_weak_count *a1)
{
}

void sub_1000DA0BC(uint64_t a1)
{
}

uint64_t sub_1000DA0C4(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

uint64_t sub_1000DA104(uint64_t *a1, void *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v6 = *a1;
  unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 4);
  unint64_t v8 = v7 + 1;
  if (v7 + 1 > 0x555555555555555LL) {
    sub_100016F4C();
  }
  uint64_t v13 = (uint64_t)(a1 + 2);
  unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v6) >> 4);
  if (2 * v14 > v8) {
    unint64_t v8 = 2 * v14;
  }
  if (v14 >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v15 = 0x555555555555555LL;
  }
  else {
    unint64_t v15 = v8;
  }
  v27[4] = a1 + 2;
  if (v15) {
    uint64_t v16 = (char *)sub_10005E400(v13, v15);
  }
  else {
    uint64_t v16 = 0LL;
  }
  uint64_t v17 = &v16[48 * v7];
  v27[0] = v16;
  v27[1] = v17;
  v27[3] = &v16[48 * v15];
  uint64_t v18 = *a3;
  uint64_t v19 = *a4;
  uint64_t v20 = *a5;
  *(void *)uint64_t v17 = *a2;
  uint64_t v21 = a2[1];
  *((void *)v17 + 1) = v21;
  if (v21)
  {
    uint64_t v22 = (unint64_t *)(v21 + 8);
    do
      unint64_t v23 = __ldxr(v22);
    while (__stxr(v23 + 1, v22));
  }

  uint64_t v24 = &v16[48 * v7];
  *((void *)v24 + 2) = v18;
  *((void *)v24 + 3) = v19;
  *((void *)v24 + 4) = v20;
  v24[40] = 0;
  void v27[2] = v17 + 48;
  sub_1000DA254(a1, v27);
  uint64_t v25 = a1[1];
  sub_1000DA2C0((uint64_t)v27);
  return v25;
}

void sub_1000DA240(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t *sub_1000DA254(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  while (v2 != v3)
  {
    __int128 v5 = *(_OWORD *)(v2 - 48);
    v2 -= 48LL;
    *(_OWORD *)(v4 - 4_Block_object_dispose((const void *)(v2 - 120), 8) = v5;
    v4 -= 48LL;
    *(void *)uint64_t v2 = 0LL;
    *(void *)(v2 + _Block_object_dispose((const void *)(v2 - 120), 8) = 0LL;
    __int128 v6 = *(_OWORD *)(v2 + 16);
    *(_OWORD *)(v4 + 25) = *(_OWORD *)(v2 + 25);
    *(_OWORD *)(v4 + 16) = v6;
  }

  a2[1] = v4;
  uint64_t v7 = *result;
  *uint64_t result = v4;
  a2[1] = v7;
  uint64_t v8 = result[1];
  result[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = result[2];
  result[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1000DA2C0(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 48;
    sub_1000114F0(i - 48);
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1000DA30C(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  __int128 v5 = (char *)*a1;
  uint64_t v6 = 0x6DB6DB6DB6DB6DB7LL * ((a1[1] - *a1) >> 2);
  unint64_t v7 = v6 + 1;
  uint64_t v11 = (uint64_t)(a1 + 2);
  unint64_t v12 = 0x6DB6DB6DB6DB6DB7LL * ((a1[2] - (uint64_t)v5) >> 2);
  if (2 * v12 > v7) {
    unint64_t v7 = 2 * v12;
  }
  if (v12 >= 0x492492492492492LL) {
    unint64_t v13 = 0x924924924924924LL;
  }
  else {
    unint64_t v13 = v7;
  }
  if (v13)
  {
    unint64_t v14 = (char *)sub_1000DA480(v11, v13);
    uint64_t v16 = v15;
  }

  else
  {
    unint64_t v14 = 0LL;
    uint64_t v16 = 0LL;
  }

  uint64_t v17 = sub_1000CAE0C((uint64_t)&v14[28 * v6], a2, a3, *a4);
  uint64_t v18 = v17 + 28;
  uint64_t v20 = (char *)*a1;
  uint64_t v19 = (char *)a1[1];
  if (v19 != (char *)*a1)
  {
    uint64_t v21 = 0LL;
    do
    {
      uint64_t v22 = v17 + v21;
      *(void *)(v22 - 2_Block_object_dispose((const void *)(v2 - 120), 8) = 0x16174656DLL;
      *(_DWORD *)(v22 - 20) = 512;
      *(_OWORD *)(v22 - 16) = *(_OWORD *)&v19[v21 - 16];
      v21 -= 28LL;
    }

    while (&v19[v21] != v20);
    uint64_t v19 = (char *)*a1;
    v17 += v21;
  }

  *a1 = v17;
  a1[1] = v18;
  a1[2] = (uint64_t)&v14[28 * v16];
  if (v19) {
    operator delete(v19);
  }
  return v18;
}

void sub_1000DA468(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1000DA480(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x924924924924925LL) {
    sub_1000116A8();
  }
  return operator new(28 * a2);
}

uint64_t sub_1000DA4C8(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  __int128 v5 = (char *)*a1;
  uint64_t v6 = 0x6DB6DB6DB6DB6DB7LL * ((a1[1] - *a1) >> 2);
  unint64_t v7 = v6 + 1;
  uint64_t v11 = (uint64_t)(a1 + 2);
  unint64_t v12 = 0x6DB6DB6DB6DB6DB7LL * ((a1[2] - (uint64_t)v5) >> 2);
  if (2 * v12 > v7) {
    unint64_t v7 = 2 * v12;
  }
  if (v12 >= 0x492492492492492LL) {
    unint64_t v13 = 0x924924924924924LL;
  }
  else {
    unint64_t v13 = v7;
  }
  if (v13)
  {
    unint64_t v14 = (char *)sub_1000DA480(v11, v13);
    uint64_t v16 = v15;
  }

  else
  {
    unint64_t v14 = 0LL;
    uint64_t v16 = 0LL;
  }

  uint64_t v17 = sub_1000CAE0C((uint64_t)&v14[28 * v6], a2, a3, *a4);
  uint64_t v18 = v17 + 28;
  uint64_t v20 = (char *)*a1;
  uint64_t v19 = (char *)a1[1];
  if (v19 != (char *)*a1)
  {
    uint64_t v21 = 0LL;
    do
    {
      uint64_t v22 = v17 + v21;
      *(void *)(v22 - 2_Block_object_dispose((const void *)(v2 - 120), 8) = 0x16174656DLL;
      *(_DWORD *)(v22 - 20) = 512;
      *(_OWORD *)(v22 - 16) = *(_OWORD *)&v19[v21 - 16];
      v21 -= 28LL;
    }

    while (&v19[v21] != v20);
    uint64_t v19 = (char *)*a1;
    v17 += v21;
  }

  *a1 = v17;
  a1[1] = v18;
  a1[2] = (uint64_t)&v14[28 * v16];
  if (v19) {
    operator delete(v19);
  }
  return v18;
}

void sub_1000DA624(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1000DA644(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &off_100182190;
  result[1] = v3;
  return result;
}

uint64_t sub_1000DA678(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_100182190;
  a2[1] = v2;
  return result;
}

uint64_t sub_1000DA694(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, uint64_t, void))(**(void **)(a1 + 8) + 176LL))( *(void *)(a1 + 8),  a2,  0LL);
}

uint64_t sub_1000DA6A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000DA6E4()
{
}

_DWORD *sub_1000DA6F0(_DWORD *result, int a2)
{
  *uint64_t result = a2;
  if ((a2 & 0xFFFFFFFE) != 0)
  {
    unsigned int v2 = a2 & 0xFFFFFFFE;
    exception = __cxa_allocate_exception(0x28uLL);
    exception[2] = "invalid flags";
    exception[3] = "flags validator";
    void *exception = &off_10016D430;
    exception[1] = "header_flags";
    *((_DWORD *)exception + _Block_object_dispose((const void *)(v2 - 120), 8) = v2;
  }

  return result;
}

unint64_t *sub_1000DA760@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, unint64_t *a4@<X8>)
{
  uint64_t v16 = 0LL;
  uint64_t v17 = a2;
  sub_1000DA948(a1, a2, a3, &v14);
  if (v14 && !*(_BYTE *)(v14 + 344) || v14 && *(_BYTE *)(v14 + 344))
  {
    *a4 = 0LL;
    do
      unint64_t v7 = __ldaxr(&v14);
    while (__stlxr(0LL, &v14));
LABEL_21:
    atomic_store(v7, a4);
    return sub_1000BBEA0(&v14);
  }

  if (*(_BYTE *)(a1 + 736) && v15 != (void *)(a1 + 760))
  {
    do
    {
      sub_1000DAE08(a1, a2, &v12);
      uint64_t v16 = v12;
      sub_1000BD48C(&v14, &v13);
      sub_1000BBEA0(&v13);
      if (v14)
      {
        if (!*(_BYTE *)(v14 + 344)) {
          break;
        }
      }

      uint64_t v8 = (unint64_t *)sub_1000DAF90((void *)a1);
      if (v8)
      {
        uint64_t v16 = v8;
        sub_1000DB034(a1, v8, a2, (unint64_t *)&v12);
        sub_1000BD48C(&v14, (unint64_t *)&v12);
        sub_1000BBEA0((unint64_t *)&v12);
        break;
      }
    }

    while (*(_BYTE *)(a1 + 736));
    std::mutex::lock((std::mutex *)(a1 + 776));
    uint64_t v9 = sub_1000DC3D8((uint64_t **)(a1 + 752), v15, (unint64_t *)&v17, &v17, (uint64_t *)&v16);
    if (!v10) {
      v9[5] = (uint64_t)v16;
    }
    std::condition_variable::notify_all((std::condition_variable *)(a1 + 840));
    std::mutex::unlock((std::mutex *)(a1 + 776));
    sub_1000DB150(a1, 0, 0LL, 0);
    *a4 = 0LL;
    do
      unint64_t v7 = __ldaxr(&v14);
    while (__stlxr(0LL, &v14));
    goto LABEL_21;
  }

  *a4 = 0LL;
  return sub_1000BBEA0(&v14);
}

void sub_1000DA908(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_1000DA948(uint64_t a1@<X0>, unint64_t a2@<X1>, int a3@<W2>, unint64_t *a4@<X8>)
{
  unint64_t v50 = a2;
  unint64_t v7 = (std::mutex *)(a1 + 776);
  uint64_t v8 = (void *)(a1 + 760);
  uint64_t v9 = (unint64_t *)(a1 + 1008);
  char v10 = (unint64_t *)(a1 + 592);
  __int128 v43 = (unint64_t *)(a1 + 104);
  __int128 v44 = (std::condition_variable *)(a1 + 840);
  __int128 v45 = (uint64_t **)(a1 + 752);
  while (2)
  {
    __lk.__m_ = v7;
    __lk.__owns_ = 1;
    std::mutex::lock(v7);
    if (a3)
    {
      uint64_t v11 = v50;
    }

    else
    {
      uint64_t v16 = (void *)*v8;
      if (!*v8) {
        goto LABEL_20;
      }
      uint64_t v11 = v50;
      uint64_t v17 = v8;
      do
      {
        unint64_t v18 = v16[4];
        BOOL v19 = v18 >= v50;
        if (v18 >= v50) {
          uint64_t v20 = v16;
        }
        else {
          uint64_t v20 = v16 + 1;
        }
        if (v19) {
          uint64_t v17 = v16;
        }
        uint64_t v16 = (void *)*v20;
      }

      while (*v20);
      if (v17 == v8 || v50 < v17[4] || (unint64_t *)v17[5] == v9)
      {
LABEL_20:
        unint64_t v51 = 0LL;
        *a4 = 0LL;
        do
          unint64_t v21 = __ldaxr((unint64_t *)&v51);
        while (__stlxr(0LL, (unint64_t *)&v51));
        atomic_store(v21, a4);
        a4[1] = (unint64_t)v8;
        sub_1000BBEA0((unint64_t *)&v51);
        goto LABEL_23;
      }
    }

    unint64_t v51 = (unint64_t *)v11;
    unint64_t v52 = v9;
    unint64_t v12 = sub_1000DB2B4(v45, (unint64_t *)&v51, (uint64_t *)&v51);
    unint64_t v13 = v12;
    if (v14)
    {
      unint64_t v51 = 0LL;
      *a4 = 0LL;
      do
        unint64_t v15 = __ldaxr((unint64_t *)&v51);
      while (__stlxr(0LL, (unint64_t *)&v51));
      atomic_store(v15, a4);
      a4[1] = (unint64_t)v12;
      sub_1000BBEA0((unint64_t *)&v51);
LABEL_23:
      int v22 = 1;
      goto LABEL_24;
    }

    __int128 v48 = (unint64_t *)v12[5];
    if (v48 == v9)
    {
      char v28 = (void *)*v8;
      if (*v8)
      {
        unint64_t v29 = v50;
        uint64_t v30 = v8;
        while (1)
        {
          unint64_t v31 = v28[4];
          BOOL v32 = v31 >= v29;
          if (v31 >= v29) {
            int v33 = v28;
          }
          else {
            int v33 = v28 + 1;
          }
          if (v32) {
            uint64_t v30 = v28;
          }
          char v28 = (void *)*v33;
          if (!*v33)
          {
            if (v30 == v8) {
              break;
            }
            if (v29 < v30[4]) {
              break;
            }
            __int128 v34 = (unint64_t *)v30[5];
            if (v34 != v9)
            {
              unint64_t v35 = v34[45];
              if (v35)
              {
                if (!*(_BYTE *)(v35 + 344)) {
                  break;
                }
              }
            }

            if (!*(_BYTE *)(a1 + 736)) {
              break;
            }
            std::condition_variable::wait(v44, &__lk);
            char v28 = (void *)*v8;
            uint64_t v30 = v8;
            if (!*v8) {
              break;
            }
          }
        }
      }

      int v22 = 0;
      goto LABEL_24;
    }

    sub_10003C718((uint64_t)&__lk);
    sub_1000D5AFC(&v47, v48 + 45);
    if (v47 && !*(_BYTE *)(v47 + 344))
    {
      uint64_t v23 = v50;
      if (*(void *)(v47 + 32) == v50)
      {
        *a4 = 0LL;
        do
          unint64_t v37 = __ldaxr(&v47);
        while (__stlxr(0LL, &v47));
        atomic_store(v37, a4);
        a4[1] = (unint64_t)v13;
        goto LABEL_84;
      }

      if (*(void *)(v47 + 32) == -1LL)
      {
        uint64_t v24 = v43;
        if ((a3 & 1) == 0)
        {
          unint64_t v51 = 0LL;
          *a4 = 0LL;
          do
            unint64_t v36 = __ldaxr((unint64_t *)&v51);
          while (__stlxr(0LL, (unint64_t *)&v51));
          goto LABEL_83;
        }

        goto LABEL_35;
      }
    }

    else
    {
      if (!a3)
      {
        unint64_t v51 = 0LL;
        *a4 = 0LL;
        do
          unint64_t v36 = __ldaxr((unint64_t *)&v51);
        while (__stlxr(0LL, (unint64_t *)&v51));
        goto LABEL_83;
      }

      uint64_t v23 = v50;
    }

    uint64_t v24 = v43;
LABEL_35:
    if (sub_1000DB150(a1, 0, v23, 1u) != -1)
    {
      do
        unint64_t v25 = __ldaxr(v10);
      while (__stlxr(v25 + 1, v10));
      v46.__m_ = (std::unique_lock<std::mutex>::mutex_type *)sub_100116890((unint64_t)v48);
      v46.__owns_ = 1;
      std::mutex::lock(v46.__m_);
      uint64_t v26 = sub_100116950((unint64_t)v48);
      std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v54 = std::chrono::steady_clock::now().__d_.__rep_ + 200000000;
      unint64_t v51 = (unint64_t *)&v48;
      unint64_t v52 = &v47;
      unint64_t v53 = &v50;
      sub_1000DB440((std::condition_variable *)v26, &v46, &v54, (uint64_t)&v51);
      do
        unint64_t v27 = __ldaxr(v10);
      while (__stlxr(v27 - 1, v10));
      if (v46.__owns_) {
        std::mutex::unlock(v46.__m_);
      }
      int v22 = 3;
      goto LABEL_85;
    }

    unint64_t v51 = 0LL;
    unint64_t v38 = atomic_load(v24);
    if (!v38) {
      goto LABEL_81;
    }
    while (1)
    {
      unint64_t v39 = __ldaxr(v24);
      if (v39 != v38)
      {
        __clrex();
        goto LABEL_71;
      }

      if (!__stlxr(v38 + 1, v24)) {
        break;
      }
LABEL_71:
      unint64_t v38 = v39;
      if (!v39) {
        goto LABEL_81;
      }
    }

    __int128 v40 = *(unint64_t **)(a1 + 432);
    unint64_t v38 = (unint64_t)v24;
    if (v40)
    {
      do
        unint64_t v41 = __ldxr(v40);
      while (__stxr(v41 + 1, v40));
      *(void *)(a1 + 440) = v41;
      unint64_t v38 = (unint64_t)v24;
    }

LABEL_81:
    atomic_store(v38, (unint64_t *)&v51);
    *a4 = 0LL;
    do
      unint64_t v36 = __ldaxr((unint64_t *)&v51);
    while (__stlxr(0LL, (unint64_t *)&v51));
LABEL_83:
    atomic_store(v36, a4);
    a4[1] = (unint64_t)v8;
    sub_1000BBEA0((unint64_t *)&v51);
LABEL_84:
    int v22 = 1;
LABEL_85:
    sub_1000BBEA0(&v47);
LABEL_24:
    if (__lk.__owns_) {
      std::mutex::unlock(__lk.__m_);
    }
    if (v22 != 1)
    {
      if (!*(_BYTE *)(a1 + 736))
      {
        unint64_t v51 = 0LL;
        *a4 = 0LL;
        do
          unint64_t v42 = __ldaxr((unint64_t *)&v51);
        while (__stlxr(0LL, (unint64_t *)&v51));
        atomic_store(v42, a4);
        a4[1] = (unint64_t)v8;
        sub_1000BBEA0((unint64_t *)&v51);
        return;
      }

      continue;
    }

    break;
  }

    atomic_store(v38, (unint64_t *)&v51);
    *a4 = 0LL;
    do
      unint64_t v36 = __ldaxr((unint64_t *)&v51);
    while (__stlxr(0LL, (unint64_t *)&v51));
LABEL_83:
    atomic_store(v36, a4);
    a4[1] = (unint64_t)v8;
    sub_1000BB354((unint64_t *)&v51);
LABEL_84:
    int v22 = 1;
LABEL_85:
    sub_1000BB354(&v47);
LABEL_24:
    if (__lk.__owns_) {
      std::mutex::unlock(__lk.__m_);
    }
    if (v22 != 1)
    {
      if (!*(_BYTE *)(a1 + 912))
      {
        unint64_t v51 = 0LL;
        *a4 = 0LL;
        do
          unint64_t v42 = __ldaxr((unint64_t *)&v51);
        while (__stlxr(0LL, (unint64_t *)&v51));
        atomic_store(v42, a4);
        a4[1] = (unint64_t)v8;
        sub_1000BB354((unint64_t *)&v51);
        return;
      }

      continue;
    }

    break;
  }

    atomic_store(v38, (unint64_t *)&v51);
    *a4 = 0LL;
    do
      unint64_t v36 = __ldaxr((unint64_t *)&v51);
    while (__stlxr(0LL, (unint64_t *)&v51));
LABEL_83:
    atomic_store(v36, a4);
    a4[1] = (unint64_t)v8;
    sub_1000E7B68((unint64_t *)&v51);
LABEL_84:
    int v22 = 1;
LABEL_85:
    sub_1000E7B68(&v47);
LABEL_24:
    if (__lk.__owns_) {
      std::mutex::unlock(__lk.__m_);
    }
    if (v22 != 1)
    {
      if (!*(_BYTE *)(a1 + 704))
      {
        unint64_t v51 = 0LL;
        *a4 = 0LL;
        do
          unint64_t v42 = __ldaxr((unint64_t *)&v51);
        while (__stlxr(0LL, (unint64_t *)&v51));
        atomic_store(v42, a4);
        a4[1] = (unint64_t)v8;
        sub_1000E7B68((unint64_t *)&v51);
        return;
      }

      continue;
    }

    break;
  }

void sub_1000DADA8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::mutex *a12, char a13, int a14, unint64_t a15, uint64_t a16, std::mutex *a17, char a18)
{
  if (a18) {
    std::mutex::unlock(a17);
  }
  _Unwind_Resume(a1);
}

unint64_t *sub_1000DAE08@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t **a3@<X8>)
{
  unint64_t v12 = 0LL;
  uint64_t v6 = (std::mutex *)(a1 + 520);
  std::mutex::lock((std::mutex *)(a1 + 520));
  uint64_t v7 = *(void *)(a1 + 512);
  if (v7)
  {
    ++*(void *)(a1 + 504);
    *(void *)(a1 + 512) = v7 - 1;
    sub_1000DB5C4(a1 + 472, 1);
    sub_1000DB034(a1, v8, a2, v13);
    sub_1000BD48C(&v12, v13);
    sub_1000BBEA0(v13);
  }

  else
  {
    uint64_t v8 = 0LL;
  }

  std::mutex::unlock(v6);
  unint64_t v9 = atomic_load((unint64_t *)(a1 + 608));
  if (v9 + v7 >= *(void *)(a1 + 464))
  {
    sub_1000DB150(a1, 0, 0LL, 0);
  }

  else
  {
    v13[0] = (unint64_t)_NSConcreteStackBlock;
    v13[1] = 0x40000000LL;
    v13[2] = (unint64_t)sub_1000DB620;
    v13[3] = (unint64_t)&unk_100182210;
    v13[4] = a1;
    sub_1000F96B0((dispatch_queue_t *)(a1 + 744), v13);
  }

  *a3 = v8;
  a3[1] = 0LL;
  do
    unint64_t v10 = __ldaxr(&v12);
  while (__stlxr(0LL, &v12));
  atomic_store(v10, (unint64_t *)a3 + 1);
  return sub_1000BBEA0(&v12);
}

void sub_1000DAF5C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9)
{
}

unint64_t sub_1000DAF90(void *a1)
{
  unint64_t v1 = atomic_load(a1 + 75);
  uint64_t v2 = a1[57];
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = 0LL;
  int v4 = 0;
  unint64_t v5 = 0LL;
  do
  {
    uint64_t v6 = a1[73];
    uint64_t v7 = *(void *)(v6 + 8 * v3);
    if (v7 && v1 - *(void *)(v7 + 344) != -1LL)
    {
      unint64_t v5 = *(void *)(v6 + 8 * v3);
      int v4 = v3;
    }

    ++v3;
  }

  while (v2 != v3);
  if (!v5) {
    return 0LL;
  }
  uint64_t v8 = (unint64_t *)(a1[73] + 8LL * v4);
  do
  {
    unint64_t v9 = __ldaxr(v8);
    if (v9 != v5)
    {
      __clrex();
      return 0LL;
    }
  }

  while (__stlxr(0LL, v8));
  return v5;
}

unint64_t *sub_1000DB034@<X0>( uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, unint64_t *a4@<X8>)
{
  uint64_t v7 = a2 + 1;
  unint64_t v17 = 0LL;
  unint64_t v8 = atomic_load(a2 + 1);
  if (!v8)
  {
LABEL_7:
    uint64_t v7 = 0LL;
    goto LABEL_11;
  }

  while (1)
  {
    unint64_t v9 = __ldaxr(v7);
    if (v9 != v8)
    {
      __clrex();
      goto LABEL_6;
    }

    if (!__stlxr(v8 + 1, v7)) {
      break;
    }
LABEL_6:
    unint64_t v8 = v9;
    if (!v9) {
      goto LABEL_7;
    }
  }

  unint64_t v10 = (unint64_t *)a2[42];
  if (v10)
  {
    do
      unint64_t v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
    a2[43] = v11;
  }

LABEL_11:
  atomic_store((unint64_t)v7, &v17);
  if (*(void *)(a1 + 456))
  {
    uint64_t v12 = 0LL;
    while (2)
    {
      unint64_t v13 = (unint64_t *)(*(void *)(a1 + 584) + 8 * v12);
      while (!__ldaxr(v13))
      {
        if (!__stlxr((unint64_t)a2, v13))
        {
          *a4 = 0LL;
          do
            unint64_t v15 = __ldaxr(&v17);
          while (__stlxr(0LL, &v17));
          atomic_store(v15, a4);
          return sub_1000BBEA0(&v17);
        }
      }

      __clrex();
      break;
    }
  }

  *a4 = 0LL;
  return sub_1000BBEA0(&v17);
}

  atomic_store(v4, &v12);
  sub_1000BD48C((unint64_t *)(a1 + 360), &v12);
  uint64_t result = sub_1000BBEA0(&v12);
  do
  {
    unint64_t v9 = __ldaxr(v3);
    unint64_t v10 = v9 - 1;
  }

  while (__stlxr(v10, v3));
  if (!v10)
  {
    unint64_t v11 = *(void *)(a1 + 40);
    *(void *)(a1 + 40) = -1LL;
    return (unint64_t *)sub_1000BBEE0((uint64_t)v3, v11, 1u);
  }

  return result;
}

  atomic_store((unint64_t)v7, &v17);
  if (*(void *)(a1 + 632))
  {
    uint64_t v12 = 0LL;
    while (2)
    {
      unint64_t v13 = (unint64_t *)(*(void *)(a1 + 760) + 8 * v12);
      while (!__ldaxr(v13))
      {
        if (!__stlxr((unint64_t)a2, v13))
        {
          *a4 = 0LL;
          do
            unint64_t v15 = __ldaxr(&v17);
          while (__stlxr(0LL, &v17));
          atomic_store(v15, a4);
          return sub_1000BB354(&v17);
        }
      }

      __clrex();
      break;
    }
  }

  *a4 = 0LL;
  return sub_1000BB354(&v17);
}

  atomic_store(v4, &v12);
  sub_1000C755C((unint64_t *)(a1 + 536), &v12);
  uint64_t result = sub_1000BB354(&v12);
  do
  {
    unint64_t v9 = __ldaxr(v3);
    unint64_t v10 = v9 - 1;
  }

  while (__stlxr(v10, v3));
  if (!v10)
  {
    unint64_t v11 = *(void *)(a1 + 40);
    *(void *)(a1 + 40) = -1LL;
    return (unint64_t *)sub_1000BB394((uint64_t)v3, v11, 1u);
  }

  return result;
}

  atomic_store((unint64_t)v7, &v17);
  if (*(void *)(a1 + 424))
  {
    uint64_t v12 = 0LL;
    while (2)
    {
      unint64_t v13 = (unint64_t *)(*(void *)(a1 + 552) + 8 * v12);
      while (!__ldaxr(v13))
      {
        if (!__stlxr((unint64_t)a2, v13))
        {
          *a4 = 0LL;
          do
            unint64_t v15 = __ldaxr(&v17);
          while (__stlxr(0LL, &v17));
          atomic_store(v15, a4);
          return sub_1000E7B68(&v17);
        }
      }

      __clrex();
      break;
    }
  }

  *a4 = 0LL;
  return sub_1000E7B68(&v17);
}

  atomic_store(v4, &v12);
  sub_1000E6D34((unint64_t *)(a1 + 328), &v12);
  uint64_t result = sub_1000E7B68(&v12);
  do
  {
    unint64_t v9 = __ldaxr(v3);
    unint64_t v10 = v9 - 1;
  }

  while (__stlxr(v10, v3));
  if (!v10)
  {
    unint64_t v11 = *(void *)(a1 + 40);
    *(void *)(a1 + 40) = -1LL;
    return (unint64_t *)sub_1000E790C((uint64_t)v3, v11, 1u);
  }

  return result;
}

  sub_1000114C0((const void **)&theDict);
  return Value;
}

  return v13;
}

uint64_t sub_1000DB150(uint64_t a1, int a2, uint64_t a3, unsigned __int8 a4)
{
  if (!*(void *)(a1 + 968)) {
    return 0LL;
  }
  BOOL v19 = (std::mutex *)(a1 + 888);
  std::mutex::lock((std::mutex *)(a1 + 888));
  if (*(void *)(a1 + 968))
  {
    unint64_t v8 = *(uint64_t **)(a1 + 960);
    if (v8 == (uint64_t *)(a1 + 952))
    {
      uint64_t v11 = 1LL;
    }

    else
    {
      uint64_t v9 = a4;
      if (a2) {
        unsigned int v10 = 6;
      }
      else {
        unsigned int v10 = 4;
      }
      uint64_t v11 = 1LL;
      do
      {
        unint64_t v12 = v8[2];
        if ((sub_1000BBEE0(v12 + 8, v8[3], v10) | a2) == 1)
        {
          unint64_t v13 = sub_100116890(v12);
          std::mutex::lock((std::mutex *)v13);
          char v14 = (unsigned int *)(v12 + 368);
          do
            unsigned int v15 = __ldaxr(v14);
          while (__stlxr(v15 & 0xFFFFFFFB, v14));
          std::mutex::unlock((std::mutex *)v13);
          uint64_t v16 = *v8;
          unint64_t v17 = (uint64_t *)v8[1];
          *(void *)(v16 + _Block_object_dispose((const void *)(v2 - 120), 8) = v17;
          *(void *)v8[1] = v16;
          --*(void *)(a1 + 968);
          operator delete(v8);
          unint64_t v8 = v17;
        }

        else
        {
          if (!v9 || v8[3] == a3) {
            uint64_t v11 = 0xFFFFFFFFLL;
          }
          unint64_t v8 = (uint64_t *)v8[1];
        }
      }

      while (v8 != (uint64_t *)(a1 + 952));
    }
  }

  else
  {
    uint64_t v11 = 0LL;
  }

  std::mutex::unlock(v19);
  return v11;
}

void sub_1000DB29C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::mutex *a10)
{
}

uint64_t *sub_1000DB2B4(uint64_t **a1, unint64_t *a2, uint64_t *a3)
{
  uint64_t v6 = a1 + 1;
  unint64_t v5 = a1[1];
  if (v5)
  {
    unint64_t v7 = *a2;
    while (1)
    {
      while (1)
      {
        unint64_t v8 = (uint64_t **)v5;
        unint64_t v9 = v5[4];
        if (v7 >= v9) {
          break;
        }
        unint64_t v5 = *v8;
        uint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }

      if (v9 >= v7) {
        break;
      }
      unint64_t v5 = v8[1];
      if (!v5)
      {
        uint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    unint64_t v8 = a1 + 1;
LABEL_10:
    unsigned int v10 = (uint64_t *)operator new(0x30uLL);
    uint64_t v11 = a3[1];
    v10[4] = *a3;
    _OWORD v10[5] = v11;
    sub_100027200(a1, (uint64_t)v8, v6, v10);
    return v10;
  }

  return (uint64_t *)v8;
}

unint64_t *sub_1000DB36C(unint64_t *a1, unint64_t *a2, int a3)
{
  uint64_t v3 = a2;
  *a1 = 0LL;
  if (!a2) {
    goto LABEL_9;
  }
  unint64_t v5 = atomic_load(a2);
  if (!v5) {
    goto LABEL_8;
  }
  while (1)
  {
    unint64_t v6 = __ldaxr(a2);
    if (v6 != v5)
    {
      __clrex();
      goto LABEL_7;
    }

    if (!__stlxr(v5 + 1, a2)) {
      break;
    }
LABEL_7:
    unint64_t v5 = v6;
    if (!v6) {
      goto LABEL_8;
    }
  }

  unint64_t v8 = (unint64_t *)a2[41];
  if (v8)
  {
    do
      unint64_t v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
    a2[42] = v9;
  }

  if (a3 && !sub_1000D5BCC((uint64_t)a2))
  {
    do
      unint64_t v10 = __ldaxr(v3);
    while (__stlxr(v10 - 1, v3));
    if (v10 == 1)
    {
      uint64_t v11 = v3[4];
      v3[4] = -1LL;
      sub_1000BBEE0((uint64_t)v3, v11, 1u);
    }

BOOL sub_1000DB440( std::condition_variable *a1, std::unique_lock<std::mutex> *a2, std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep *a3, uint64_t a4)
{
  do
  {
    if ((*(_DWORD *)(**(void **)a4 + 368LL) & 1) != 0) {
      return 1LL;
    }
    uint64_t v8 = *(void *)(a4 + 8);
    if (*(void *)v8)
    {
      if (!*(_BYTE *)(*(void *)v8 + 344LL) && *(void *)(*(void *)v8 + 32LL) == **(void **)(a4 + 16)) {
        return 1LL;
      }
    }

    if (*a3 <= std::chrono::steady_clock::now().__d_.__rep_) {
      break;
    }
    std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v9 = *a3;
    v10.__d_.__rep_ = v9 - std::chrono::steady_clock::now().__d_.__rep_;
    if (v10.__d_.__rep_ >= 1)
    {
      std::chrono::steady_clock::now();
      v11.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
      if (v11.__d_.__rep_)
      {
        if (v11.__d_.__rep_ < 1)
        {
          if ((unint64_t)v11.__d_.__rep_ < 0xFFDF3B645A1CAC09LL)
          {
            std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v12 = 0x8000000000000000LL;
            goto LABEL_17;
          }
        }

        else if ((unint64_t)v11.__d_.__rep_ > 0x20C49BA5E353F7LL)
        {
          std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v12 = 0x7FFFFFFFFFFFFFFFLL;
          goto LABEL_15;
        }

        std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v12 = 1000 * v11.__d_.__rep_;
      }

      else
      {
        std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v12 = 0LL;
      }

uint64_t sub_1000DB5C4(uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0x200) {
    a2 = 1;
  }
  if (v2 < 0x400) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8LL;
    *(void *)(a1 + 32) -= 512LL;
  }

  return v4 ^ 1u;
}

uint64_t sub_1000DB620(uint64_t a1)
{
  unint64_t v1 = *(void **)(a1 + 32);
  unint64_t v2 = sub_1000DAF90(v1);
  if (v2) {
    sub_1000DB664((uint64_t)v1, v2);
  }
  return sub_1000DB150((uint64_t)v1, 0, 0LL, 0);
}

void sub_1000DB664(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  uint64_t v3 = (std::mutex *)(a1 + 520);
  std::mutex::lock((std::mutex *)(a1 + 520));
  sub_1000DB6C0((void *)(a1 + 472), &v4);
  std::mutex::unlock(v3);
}

void sub_1000DB6AC(_Unwind_Exception *a1)
{
}

void sub_1000DB6C0(void *a1, void *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    sub_1000DB744(a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = a1[4] + v7;
  }

  *(void *)(*(void *)(v5 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8LL)) + 8 * (v8 & 0x1FF)) = *a2;
  a1[5] = v7 + 1;
}

void sub_1000DB744(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      __int128 v34 = (char *)sub_10001848C(v5, v33);
      unint64_t v35 = &v34[8 * (v33 >> 2)];
      unint64_t v37 = &v34[8 * v36];
      unint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        unint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)unint64_t v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    BOOL v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v9 = (char *)a1[1];
    }

    unint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }

  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&__int128 v54 = operator new(0x1000uLL);
      sub_1000DBA58(a1, &v54);
      return;
    }

    *(void *)&__int128 v54 = operator new(0x1000uLL);
    sub_1000DBB6C((uint64_t)a1, &v54);
    __int128 v44 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      __int128 v34 = (char *)sub_10001848C((uint64_t)(a1 + 3), v46);
      unint64_t v35 = &v34[8 * (v46 >> 2)];
      unint64_t v37 = &v34[8 * v47];
      __int128 v48 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        unint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v50 = 8 * (v49 >> 3);
        unint64_t v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)unint64_t v51 = v52;
          v51 += 8;
          v50 -= 8LL;
        }

        while (v50);
      }

    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    BOOL v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v9 = (char *)a1[1];
    }

    unint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }

  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&__int128 v54 = operator new(0x1000uLL);
      sub_1000DBA58(a1, &v54);
      return;
    }

    *(void *)&__int128 v54 = operator new(0x1000uLL);
    sub_1000DBB6C((uint64_t)a1, &v54);
    __int128 v44 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      __int128 v34 = (char *)sub_10001848C((uint64_t)(a1 + 3), v46);
      unint64_t v35 = &v34[8 * (v46 >> 2)];
      unint64_t v37 = &v34[8 * v47];
      __int128 v48 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        unint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v50 = 8 * (v49 >> 3);
        unint64_t v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)unint64_t v51 = v52;
          v51 += 8;
          v50 -= 8LL;
        }

        while (v50);
      }

    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    BOOL v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v9 = (char *)a1[1];
    }

    unint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }

  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&__int128 v54 = operator new(0x1000uLL);
      sub_1000DBA58(a1, &v54);
      return;
    }

    *(void *)&__int128 v54 = operator new(0x1000uLL);
    sub_1000DBB6C((uint64_t)a1, &v54);
    __int128 v44 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      __int128 v34 = (char *)sub_10001848C((uint64_t)(a1 + 3), v46);
      unint64_t v35 = &v34[8 * (v46 >> 2)];
      unint64_t v37 = &v34[8 * v47];
      __int128 v48 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        unint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v50 = 8 * (v49 >> 3);
        unint64_t v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)unint64_t v51 = v52;
          v51 += 8;
          v50 -= 8LL;
        }

        while (v50);
      }

    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    BOOL v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v9 = (char *)a1[1];
    }

    unint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }

  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&__int128 v54 = operator new(0x1000uLL);
      sub_1000DBA58(a1, &v54);
      return;
    }

    *(void *)&__int128 v54 = operator new(0x1000uLL);
    sub_1000DBB6C((uint64_t)a1, &v54);
    __int128 v44 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      __int128 v34 = (char *)sub_10001848C((uint64_t)(a1 + 3), v46);
      unint64_t v35 = &v34[8 * (v46 >> 2)];
      unint64_t v37 = &v34[8 * v47];
      __int128 v48 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        unint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v50 = 8 * (v49 >> 3);
        unint64_t v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)unint64_t v51 = v52;
          v51 += 8;
          v50 -= 8LL;
        }

        while (v50);
      }

LABEL_30:
      __int128 v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        unint64_t v8 = (char *)a1[2];
      }

      goto LABEL_33;
    }

    goto LABEL_5;
  }

  if (v23 == *a1) {
    unint64_t v25 = 1LL;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  unint64_t v56 = a1 + 3;
  *(void *)&__int128 v54 = sub_10001848C((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&__int128 v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  unint64_t v53 = operator new(0x1000uLL);
  sub_1000DBC88(&v54, &v53);
  unint64_t v27 = (void *)a1[2];
  uint64_t v28 = -7LL - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8LL;
    sub_1000DBD9C((uint64_t)&v54, v27);
  }

  unint64_t v29 = (char *)*a1;
  __int128 v30 = v54;
  __int128 v31 = v55;
  *(void *)&__int128 v54 = *a1;
  *((void *)&v54 + 1) = v27;
  __int128 v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  __int128 v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&__int128 v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8LL);
  }
  if (v29) {
    operator delete(v29);
  }
}

      __int128 v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        unint64_t v8 = (char *)a1[2];
      }

      goto LABEL_33;
    }

    goto LABEL_5;
  }

  if (v23 == *a1) {
    unint64_t v25 = 1LL;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  unint64_t v56 = a1 + 3;
  *(void *)&__int128 v54 = sub_10001848C((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&__int128 v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  unint64_t v53 = operator new(0x1000uLL);
  sub_1000DBC88(&v54, &v53);
  unint64_t v27 = (void *)a1[2];
  uint64_t v28 = -7LL - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8LL;
    sub_1000DBD9C((uint64_t)&v54, v27);
  }

  unint64_t v29 = (char *)*a1;
  __int128 v30 = v54;
  __int128 v31 = v55;
  *(void *)&__int128 v54 = *a1;
  *((void *)&v54 + 1) = v27;
  __int128 v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  __int128 v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&__int128 v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8LL);
  }
  if (v29) {
    operator delete(v29);
  }
}

      __int128 v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        unint64_t v8 = (char *)a1[2];
      }

      goto LABEL_33;
    }

    goto LABEL_5;
  }

  if (v23 == *a1) {
    unint64_t v25 = 1LL;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  unint64_t v56 = a1 + 3;
  *(void *)&__int128 v54 = sub_10001848C((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&__int128 v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  unint64_t v53 = operator new(0x1000uLL);
  sub_1000DBC88(&v54, &v53);
  unint64_t v27 = (void *)a1[2];
  uint64_t v28 = -7LL - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8LL;
    sub_1000DBD9C((uint64_t)&v54, v27);
  }

  unint64_t v29 = (char *)*a1;
  __int128 v30 = v54;
  __int128 v31 = v55;
  *(void *)&__int128 v54 = *a1;
  *((void *)&v54 + 1) = v27;
  __int128 v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  __int128 v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&__int128 v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8LL);
  }
  if (v29) {
    operator delete(v29);
  }
}

      __int128 v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        unint64_t v8 = (char *)a1[2];
      }

      goto LABEL_33;
    }

    goto LABEL_5;
  }

  if (v23 == *a1) {
    unint64_t v25 = 1LL;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  unint64_t v56 = a1 + 3;
  *(void *)&__int128 v54 = sub_10001848C((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&__int128 v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  unint64_t v53 = operator new(0x1000uLL);
  sub_1000DBC88(&v54, &v53);
  unint64_t v27 = (void *)a1[2];
  uint64_t v28 = -7LL - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8LL;
    sub_1000DBD9C((uint64_t)&v54, v27);
  }

  unint64_t v29 = (char *)*a1;
  __int128 v30 = v54;
  __int128 v31 = v55;
  *(void *)&__int128 v54 = *a1;
  *((void *)&v54 + 1) = v27;
  __int128 v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  __int128 v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&__int128 v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8LL);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_1000DBA0C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1000DBA58(void *a1, void *a2)
{
  uint64_t v5 = (char *)a1[3];
  uint64_t v4 = (uint64_t)(a1 + 3);
  uint64_t v6 = *(char **)(v4 - 8);
  if (v6 == v5)
  {
    uint64_t v7 = (char *)a1[1];
    uint64_t v8 = (uint64_t)&v7[-*a1];
    if ((unint64_t)v7 <= *a1)
    {
      else {
        unint64_t v18 = (uint64_t)&v6[-*a1] >> 2;
      }
      BOOL v19 = (char *)sub_10001848C(v4, v18);
      uint64_t v21 = &v19[8 * (v18 >> 2)];
      unint64_t v22 = (uint64_t *)a1[1];
      uint64_t v6 = v21;
      uint64_t v23 = a1[2] - (void)v22;
      if (v23)
      {
        uint64_t v6 = &v21[v23 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v24 = 8 * (v23 >> 3);
        unint64_t v25 = &v19[8 * (v18 >> 2)];
        do
        {
          uint64_t v26 = *v22++;
          *(void *)unint64_t v25 = v26;
          v25 += 8;
          v24 -= 8LL;
        }

        while (v24);
      }

      unint64_t v27 = (char *)*a1;
      *a1 = v19;
      a1[1] = v21;
      a1[2] = v6;
      a1[3] = &v19[8 * v20];
      if (v27)
      {
        operator delete(v27);
        uint64_t v6 = (char *)a1[2];
      }
    }

    else
    {
      uint64_t v9 = v8 >> 3;
      BOOL v10 = v8 >> 3 < -1;
      uint64_t v11 = (v8 >> 3) + 2;
      if (v10) {
        uint64_t v12 = v11;
      }
      else {
        uint64_t v12 = v9 + 1;
      }
      uint64_t v13 = -(v12 >> 1);
      uint64_t v14 = v12 >> 1;
      uint64_t v15 = &v7[-8 * v14];
      int64_t v16 = v6 - v7;
      if (v6 != v7)
      {
        memmove(&v7[-8 * v14], v7, v6 - v7);
        uint64_t v6 = (char *)a1[1];
      }

      uint64_t v17 = &v6[8 * v13];
      uint64_t v6 = &v15[v16];
      a1[1] = v17;
      a1[2] = &v15[v16];
    }
  }

  *(void *)uint64_t v6 = *a2;
  a1[2] += 8LL;
}

void sub_1000DBB6C(uint64_t a1, void *a2)
{
  uint64_t v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    uint64_t v6 = a1 + 24;
    uint64_t v7 = *(_BYTE **)(a1 + 24);
    uint64_t v8 = *(_BYTE **)(a1 + 16);
    if (v8 >= v7)
    {
      if (v7 == v4) {
        unint64_t v12 = 1LL;
      }
      else {
        unint64_t v12 = (v7 - v4) >> 2;
      }
      uint64_t v13 = 2 * v12;
      uint64_t v14 = (char *)sub_10001848C(v6, v12);
      uint64_t v5 = &v14[(v13 + 6) & 0xFFFFFFFFFFFFFFF8LL];
      int64_t v16 = *(uint64_t **)(a1 + 8);
      uint64_t v17 = v5;
      uint64_t v18 = *(void *)(a1 + 16) - (void)v16;
      if (v18)
      {
        uint64_t v17 = &v5[v18 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v19 = 8 * (v18 >> 3);
        uint64_t v20 = v5;
        do
        {
          uint64_t v21 = *v16++;
          *(void *)uint64_t v20 = v21;
          v20 += 8;
          v19 -= 8LL;
        }

        while (v19);
      }

      unint64_t v22 = *(char **)a1;
      *(void *)a1 = v14;
      *(void *)(a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = v5;
      *(void *)(a1 + 16) = v17;
      *(void *)(a1 + 24) = &v14[8 * v15];
      if (v22)
      {
        operator delete(v22);
        uint64_t v5 = *(char **)(a1 + 8);
      }
    }

    else
    {
      uint64_t v9 = (v7 - v8) >> 3;
      if (v9 >= -1) {
        uint64_t v10 = v9 + 1;
      }
      else {
        uint64_t v10 = v9 + 2;
      }
      uint64_t v11 = v10 >> 1;
      uint64_t v5 = &v4[8 * (v10 >> 1)];
      if (v8 != v4)
      {
        memmove(&v4[8 * (v10 >> 1)], v4, v8 - v4);
        uint64_t v4 = *(char **)(a1 + 16);
      }

      *(void *)(a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = v5;
      *(void *)(a1 + 16) = &v4[8 * v11];
    }
  }

  else
  {
    uint64_t v5 = *(char **)(a1 + 8);
  }

  *((void *)v5 - 1) = *a2;
  *(void *)(a1 + 8) -= 8LL;
}

void sub_1000DBC88(void *a1, void *a2)
{
  uint64_t v4 = (char *)a1[2];
  if (v4 == (char *)a1[3])
  {
    uint64_t v5 = (char *)a1[1];
    uint64_t v6 = (uint64_t)&v5[-*a1];
    if ((unint64_t)v5 <= *a1)
    {
      else {
        unint64_t v16 = (uint64_t)&v4[-*a1] >> 2;
      }
      uint64_t v17 = (char *)sub_10001848C(a1[4], v16);
      uint64_t v19 = &v17[8 * (v16 >> 2)];
      uint64_t v20 = (uint64_t *)a1[1];
      uint64_t v4 = v19;
      uint64_t v21 = a1[2] - (void)v20;
      if (v21)
      {
        uint64_t v4 = &v19[v21 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v22 = 8 * (v21 >> 3);
        uint64_t v23 = &v17[8 * (v16 >> 2)];
        do
        {
          uint64_t v24 = *v20++;
          *(void *)uint64_t v23 = v24;
          v23 += 8;
          v22 -= 8LL;
        }

        while (v22);
      }

      unint64_t v25 = (char *)*a1;
      *a1 = v17;
      a1[1] = v19;
      a1[2] = v4;
      a1[3] = &v17[8 * v18];
      if (v25)
      {
        operator delete(v25);
        uint64_t v4 = (char *)a1[2];
      }
    }

    else
    {
      uint64_t v7 = v6 >> 3;
      BOOL v8 = v6 >> 3 < -1;
      uint64_t v9 = (v6 >> 3) + 2;
      if (v8) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = v7 + 1;
      }
      uint64_t v11 = -(v10 >> 1);
      uint64_t v12 = v10 >> 1;
      uint64_t v13 = &v5[-8 * v12];
      int64_t v14 = v4 - v5;
      if (v4 != v5)
      {
        memmove(&v5[-8 * v12], v5, v4 - v5);
        uint64_t v4 = (char *)a1[1];
      }

      uint64_t v15 = &v4[8 * v11];
      uint64_t v4 = &v13[v14];
      a1[1] = v15;
      a1[2] = &v13[v14];
    }
  }

  *(void *)uint64_t v4 = *a2;
  a1[2] += 8LL;
}

void sub_1000DBD9C(uint64_t a1, void *a2)
{
  uint64_t v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    uint64_t v6 = *(_BYTE **)(a1 + 16);
    uint64_t v7 = *(_BYTE **)(a1 + 24);
    if (v6 >= v7)
    {
      if (v7 == v4) {
        unint64_t v11 = 1LL;
      }
      else {
        unint64_t v11 = (v7 - v4) >> 2;
      }
      uint64_t v12 = 2 * v11;
      uint64_t v13 = (char *)sub_10001848C(*(void *)(a1 + 32), v11);
      uint64_t v5 = &v13[(v12 + 6) & 0xFFFFFFFFFFFFFFF8LL];
      uint64_t v15 = *(uint64_t **)(a1 + 8);
      unint64_t v16 = v5;
      uint64_t v17 = *(void *)(a1 + 16) - (void)v15;
      if (v17)
      {
        unint64_t v16 = &v5[v17 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v18 = 8 * (v17 >> 3);
        uint64_t v19 = v5;
        do
        {
          uint64_t v20 = *v15++;
          *(void *)uint64_t v19 = v20;
          v19 += 8;
          v18 -= 8LL;
        }

        while (v18);
      }

      uint64_t v21 = *(char **)a1;
      *(void *)a1 = v13;
      *(void *)(a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = v5;
      *(void *)(a1 + 16) = v16;
      *(void *)(a1 + 24) = &v13[8 * v14];
      if (v21)
      {
        operator delete(v21);
        uint64_t v5 = *(char **)(a1 + 8);
      }
    }

    else
    {
      uint64_t v8 = (v7 - v6) >> 3;
      if (v8 >= -1) {
        uint64_t v9 = v8 + 1;
      }
      else {
        uint64_t v9 = v8 + 2;
      }
      uint64_t v10 = v9 >> 1;
      uint64_t v5 = &v4[8 * (v9 >> 1)];
      if (v6 != v4)
      {
        memmove(&v4[8 * (v9 >> 1)], v4, v6 - v4);
        uint64_t v4 = *(char **)(a1 + 16);
      }

      *(void *)(a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = v5;
      *(void *)(a1 + 16) = &v4[8 * v10];
    }
  }

  else
  {
    uint64_t v5 = *(char **)(a1 + 8);
  }

  *((void *)v5 - 1) = *a2;
  *(void *)(a1 + 8) -= 8LL;
}

uint64_t sub_1000DBEB4(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t *a4)
{
  uint64_t v8 = a3 & 0x100;
  uint64_t v9 = (a3 >> 8) & 1;
  uint64_t v10 = (unint64_t *)(a1 + 608);
  do
    unint64_t v11 = __ldaxr(v10);
  while (__stlxr(v11 + 1, v10));
  if ((a3 & 1) != 0)
  {
    uint64_t v12 = (unint64_t *)(a1 + 592);
    do
      unint64_t v13 = __ldaxr(v12);
    while (__stlxr(v13 + 1, v12));
  }

  uint64_t v14 = (unsigned int *)(a2 + 368);
  do
    unsigned int v15 = __ldaxr(v14);
  while (__stlxr(v15 | 2, v14));
  sub_1000BBEA0((unint64_t *)(a2 + 360));
  if (a4) {
    sub_1000BBEA0(a4);
  }
  if ((a3 & 1) != 0)
  {
    char v16 = atomic_load(v14);
    if ((v16 & 4) == 0)
    {
      uint64_t v17 = (a3 >> 16) & 1;
      do
      {
        if ((*v14 & 1) != 0) {
          break;
        }
        if ((_DWORD)v9)
        {
          std::mutex::lock((std::mutex *)(a1 + 520));
          uint64_t v18 = *(void *)(a1 + 512);
          std::mutex::unlock((std::mutex *)(a1 + 520));
          if (v18) {
            break;
          }
        }

        if (sub_1000DB150(a1, v17, 0LL, 0) == -1)
        {
          __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)sub_100116890(a2);
          __lk.__owns_ = 1;
          std::mutex::lock(__lk.__m_);
          uint64_t v24 = sub_100116950(a2);
          v25.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
          uint64_t v35 = a1;
          std::chrono::duration<long long, std::ratio<1, 1000000>>::rep v36 = v25.__d_.__rep_ + 200000;
          unint64_t v32 = a2;
          char v33 = v9;
          *(_DWORD *)__int128 v34 = *(_DWORD *)v38;
          *(_DWORD *)&v34[3] = *(_DWORD *)&v38[3];
          sub_1000DC10C((std::condition_variable *)v24, &__lk, &v36, (uint64_t)&v32);
        }

        else
        {
          __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)sub_100116890(a2);
          __lk.__owns_ = 1;
          std::mutex::lock(__lk.__m_);
          uint64_t v19 = sub_100116950(a2);
          char v20 = atomic_load(v14);
          if ((v20 & 4) == 0)
          {
            uint64_t v21 = (std::condition_variable *)v19;
            do
            {
              if ((*v14 & 1) != 0) {
                break;
              }
              if ((_DWORD)v9)
              {
                std::mutex::lock((std::mutex *)(a1 + 520));
                uint64_t v22 = *(void *)(a1 + 512);
                std::mutex::unlock((std::mutex *)(a1 + 520));
                if (v22) {
                  break;
                }
              }

              std::condition_variable::wait(v21, &__lk);
              char v23 = atomic_load(v14);
            }

            while ((v23 & 4) == 0);
          }
        }

        if (__lk.__owns_) {
          std::mutex::unlock(__lk.__m_);
        }
        unsigned int v26 = *v14;
        if (!v8 || (v26 & 1) != 0)
        {
          if ((v26 & 1) != 0) {
            break;
          }
        }

        else if (*(void *)(a1 + 512))
        {
          break;
        }

        char v27 = atomic_load(v14);
      }

      while ((v27 & 4) == 0);
    }

    uint64_t v28 = (unint64_t *)(a1 + 592);
    do
      unint64_t v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
  }

  do
    unsigned int v30 = __ldaxr(v14);
  while (__stlxr(v30 & 0xFFFFFFFD, v14));
  return v30 & 1;
}

void sub_1000DC0E4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::mutex *a14, char a15)
{
  if (a15) {
    std::mutex::unlock(a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000DC10C( std::condition_variable *a1, std::unique_lock<std::mutex> *a2, uint64_t *a3, uint64_t a4)
{
  do
  {
    uint64_t v8 = *(void *)(a4 + 16);
    char v9 = atomic_load((unsigned int *)(*(void *)a4 + 368LL));
    if ((v9 & 4) != 0) {
      return 1LL;
    }
    if ((*(_DWORD *)(*(void *)a4 + 368LL) & 1) != 0) {
      return 1LL;
    }
    if (*(_BYTE *)(a4 + 8))
    {
      uint64_t v10 = (std::mutex *)(v8 + 520);
      std::mutex::lock((std::mutex *)(v8 + 520));
      uint64_t v11 = *(void *)(v8 + 512);
      std::mutex::unlock(v10);
      if (v11) {
        return 1LL;
      }
    }

    v12.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
    uint64_t v13 = *a3;
    if (*a3 <= v12.__d_.__rep_) {
      break;
    }
    if (!v13)
    {
      v14.__d_.__rep_ = 0LL;
      goto LABEL_14;
    }

    if (v13 < 1)
    {
      if ((unint64_t)v13 < 0xFFDF3B645A1CAC09LL)
      {
        v14.__d_.__rep_ = 0x8000000000000000LL;
        goto LABEL_14;
      }
    }

    else if ((unint64_t)v13 > 0x20C49BA5E353F7LL)
    {
      v14.__d_.__rep_ = 0x7FFFFFFFFFFFFFFFLL;
      goto LABEL_14;
    }

    v14.__d_.__rep_ = 1000 * v13;
LABEL_14:
    std::condition_variable::__do_timed_wait(a1, a2, v14);
  }

  while (std::chrono::system_clock::now().__d_.__rep_ < *a3);
  uint64_t v15 = *(void *)(a4 + 16);
  char v16 = atomic_load((unsigned int *)(*(void *)a4 + 368LL));
  if ((v16 & 4) != 0 || (*(_DWORD *)(*(void *)a4 + 368LL) & 1) != 0) {
    return 1LL;
  }
  if (!*(_BYTE *)(a4 + 8)) {
    return 0LL;
  }
  std::mutex::lock((std::mutex *)(v15 + 520));
  BOOL v17 = *(void *)(v15 + 512) != 0LL;
  std::mutex::unlock((std::mutex *)(v15 + 520));
  return v17;
}

unint64_t *sub_1000DC27C(uint64_t a1, uint64_t a2)
{
  BOOL v3 = (unint64_t *)(a1 + 8);
  sub_1000DC36C(a1 + 8, a2);
  unint64_t v12 = 0LL;
  unint64_t v4 = atomic_load(v3);
  if (!v4) {
    goto LABEL_11;
  }
  while (1)
  {
    unint64_t v5 = __ldaxr(v3);
    if (v5 != v4)
    {
      __clrex();
      goto LABEL_6;
    }

    if (!__stlxr(v4 + 1, v3)) {
      break;
    }
LABEL_6:
    unint64_t v4 = v5;
    if (!v5) {
      goto LABEL_11;
    }
  }

  uint64_t v6 = *(unint64_t **)(a1 + 336);
  unint64_t v4 = (unint64_t)v3;
  if (v6)
  {
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
    *(void *)(a1 + 344) = v7;
    unint64_t v4 = (unint64_t)v3;
  }

uint64_t *sub_1000DC36C(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + sub_1000114F0(v6 - 32) = a2;
  *(_BYTE *)(a1 + 344) = 0;
  atomic_store(1uLL, (unint64_t *)a1);
  atomic_store(0LL, (unint64_t *)(a1 + 8));
  atomic_store(0LL, (unint64_t *)(a1 + 16));
  uint64_t result = sub_1000BC098((uint64_t *)(a1 + 40));
  unint64_t v4 = *(unint64_t **)(a1 + 328);
  if (v4)
  {
    do
      unint64_t v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
    *(void *)(a1 + 336) = v5;
  }

  atomic_store(1u, (unsigned int *)(a1 + 24));
  __dmb(0xBu);
  return result;
}

uint64_t *sub_1000DC3D8(uint64_t **a1, void *a2, unint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v8 = (uint64_t **)sub_1000DC46C(a1, a2, &v14, &v13, a3);
  unint64_t v9 = *v8;
  if (!*v8)
  {
    unint64_t v10 = v8;
    unint64_t v9 = (uint64_t *)operator new(0x30uLL);
    uint64_t v11 = *a5;
    v9[4] = *a4;
    v9[5] = v11;
    sub_100027200(a1, v14, v10, v9);
  }

  return v9;
}

void *sub_1000DC46C(void *a1, void *a2, void *a3, void *a4, unint64_t *a5)
{
  unint64_t v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = *a5, unint64_t v7 = a2[4], *a5 < v7))
  {
    uint64_t v8 = *a2;
    if ((void *)*a1 == a2)
    {
      unint64_t v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }

      else
      {
        *a3 = a2;
        return a2;
      }
    }

    if (v8)
    {
      unint64_t v9 = (void *)*a2;
      do
      {
        unint64_t v10 = v9;
        unint64_t v9 = (void *)v9[1];
      }

      while (v9);
    }

    else
    {
      uint64_t v13 = a2;
      do
      {
        unint64_t v10 = (void *)v13[2];
        BOOL v14 = *v10 == (void)v13;
        uint64_t v13 = v10;
      }

      while (v14);
    }

    unint64_t v15 = *a5;
    if (v10[4] < *a5) {
      goto LABEL_17;
    }
    char v16 = (void *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          BOOL v17 = v16;
          unint64_t v18 = v16[4];
          if (v15 >= v18) {
            break;
          }
          char v16 = (void *)*v17;
          unint64_t v5 = v17;
          if (!*v17) {
            goto LABEL_29;
          }
        }

        if (v18 >= v15) {
          break;
        }
        unint64_t v5 = v17 + 1;
        char v16 = (void *)v17[1];
      }

      while (v16);
    }

    else
    {
      BOOL v17 = a1 + 1;
    }

uint64_t *sub_1000DC614(uint64_t *a1, uint64_t a2, int a3)
{
  uint64_t v4 = a2;
  uint64_t result = sub_1000DC664(a1, a2);
  result[5] = *result;
  result[6] = v4;
  if (v4 && a3)
  {
    uint64_t v6 = 0LL;
    do
    {
      unint64_t v7 = (void *)(*result + v6);
      *unint64_t v7 = 0LL;
      v7[1] = 0LL;
      v6 += 16LL;
      --v4;
    }

    while (v4);
  }

  return result;
}

uint64_t *sub_1000DC664(uint64_t *a1, uint64_t a2)
{
  *a1 = 0LL;
  a1[4] = 0LL;
  BOOL v3 = valloc(16 * a2);
  if (!v3)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    uint64_t v8 = std::bad_alloc::bad_alloc(exception);
  }

  v9[0] = &off_100182240;
  unint64_t v10 = v9;
  uint64_t v11 = v3;
  sub_1000DC83C((uint64_t)&v12, (uint64_t)v9);
  sub_1000DC768(a1, (uint64_t *)&v11);
  sub_1000BBDFC((uint64_t *)&v11);
  uint64_t v4 = v10;
  if (v10 == v9)
  {
    uint64_t v5 = 4LL;
    uint64_t v4 = v9;
    goto LABEL_6;
  }

  if (v10)
  {
    uint64_t v5 = 5LL;
LABEL_6:
    (*(void (**)(void))(*v4 + 8 * v5))();
  }

  return a1;
}

void sub_1000DC754(_Unwind_Exception *a1)
{
}

uint64_t *sub_1000DC768(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *a2 = 0LL;
  sub_1000BBE54(a1, v4);
  sub_100017334(a1 + 1, (uint64_t)(a2 + 1));
  return a1;
}

void *sub_1000DC7B0()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &off_100182240;
  return result;
}

void sub_1000DC7D4(uint64_t a1, void *a2)
{
  *a2 = &off_100182240;
}

void sub_1000DC7EC(uint64_t a1, void **a2)
{
}

uint64_t sub_1000DC7F4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000DC830()
{
}

uint64_t sub_1000DC83C(uint64_t a1, uint64_t a2)
{
  BOOL v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24LL))(*v3, a1);
      return a1;
    }

    *(void *)(a1 + 24) = v4;
  }

  else
  {
    BOOL v3 = (void *)(a1 + 24);
  }

  *BOOL v3 = 0LL;
  return a1;
}

void sub_1000DC8A0(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    uint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    unint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)uint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      __int128 v34 = (char *)sub_10001848C(v5, v33);
      uint64_t v35 = &v34[8 * (v33 >> 2)];
      unint64_t v37 = &v34[8 * v36];
      unint64_t v38 = (uint64_t *)a1[1];
      uint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        uint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        unint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)unint64_t v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_1000DCB68( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1000DCBB4(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4, uint64_t *a5)
{
  *(void *)(a1 + 336) = **(void **)(a1 + 328);
  uint64_t v10 = a1 + 40;
  sub_1000BC098((uint64_t *)(a1 + 40));
  sub_1000C6EFC(v10, a2, a3, *a4, *a5, 0);
  *(_BYTE *)(a1 + 224) = 1;
  atomic_store(2u, (unsigned int *)(a1 + 24));
  sub_1000DCC74(a1);
}

void sub_1000DCC3C(void *a1)
{
  *(_BYTE *)(v1 + 344) = 1;
  sub_1000DCC74(v1);
  __cxa_rethrow();
}

void sub_1000DCC60(_Unwind_Exception *a1)
{
}

void sub_1000DCC74(uint64_t a1)
{
}

void sub_1000DCC9C(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4, uint64_t *a5, char *a6)
{
  *(void *)(a1 + 336) = **(void **)(a1 + 328);
  uint64_t v12 = a1 + 40;
  sub_1000BC098((uint64_t *)(a1 + 40));
  sub_1000C6EFC(v12, a2, a3, *a4, *a5, *a6);
  *(_BYTE *)(a1 + 224) = 1;
  atomic_store(2u, (unsigned int *)(a1 + 24));
  sub_1000DCC74(a1);
}

void sub_1000DCD30(void *a1)
{
  *(_BYTE *)(v1 + 344) = 1;
  sub_1000DCC74(v1);
  __cxa_rethrow();
}

void sub_1000DCD54(_Unwind_Exception *a1)
{
}

uint64_t sub_1000DCD68(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_10017F320;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000DCDD0(_Unwind_Exception *a1)
{
}

uint64_t sub_1000DCDE4(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_10017F540;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000DCE4C(_Unwind_Exception *a1)
{
}

uint64_t sub_1000DCE60(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_10017F760;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000DCEC8(_Unwind_Exception *a1)
{
}

void *sub_1000DCEDC(uint64_t a1)
{
  *(_BYTE *)(a1 + 912) = 0;
  if (*(void *)(a1 + 632))
  {
    unint64_t v3 = 0LL;
    do
    {
      char v4 = (unint64_t *)(*(void *)(a1 + 760) + 8 * v3);
      do
        __int128 v5 = (unint64_t *)__ldaxr(v4);
      while (__stlxr(0LL, v4));
      if (v5)
      {
        unint64_t v1 = v1 & 0xFFFFFFFFFF000000LL | 0x10001;
        sub_1000DD14C(a1, (unint64_t)v5, v1, 0LL);
        sub_1000BB354(v5 + 67);
        sub_1000DD6B0(v5 + 1);
        operator delete(v5);
      }

      ++v3;
    }

    while (*(void *)(a1 + 632) > v3);
  }

  sub_1000F9738((dispatch_queue_t *)(a1 + 920), &stru_1001822E0);
  uint64_t v6 = *(void **)(a1 + 760);
  if (v6) {
    operator delete[](v6);
  }
  std::mutex::lock((std::mutex *)(a1 + 696));
  uint64_t v7 = *(void *)(a1 + 656);
  if (*(void *)(a1 + 664) != v7)
  {
    unint64_t v8 = *(void *)(a1 + 680);
    unint64_t v9 = (void *)(v7 + 8 * (v8 >> 9));
    uint64_t v10 = (unint64_t **)(*v9 + 8 * (v8 & 0x1FF));
    uint64_t v11 = *(void *)(v7 + (((*(void *)(a1 + 688) + v8) >> 6) & 0x3FFFFFFFFFFFFF8LL))
        + 8 * ((*(void *)(a1 + 688) + v8) & 0x1FF);
    while (v10 != (unint64_t **)v11)
    {
      uint64_t v12 = *v10;
      if (*v10)
      {
        sub_1000BB354(v12 + 67);
        sub_1000DD6B0(v12 + 1);
        operator delete(v12);
      }

      if ((unint64_t **)((char *)++v10 - *v9) == (unint64_t **)4096)
      {
        uint64_t v13 = (unint64_t **)v9[1];
        ++v9;
        uint64_t v10 = v13;
      }
    }
  }

  std::mutex::unlock((std::mutex *)(a1 + 696));
  BOOL v14 = *(void **)(a1 + 1792);
  if (v14 == (void *)(a1 + 1768))
  {
    uint64_t v15 = 4LL;
    BOOL v14 = (void *)(a1 + 1768);
  }

  else
  {
    if (!v14) {
      goto LABEL_22;
    }
    uint64_t v15 = 5LL;
  }

  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_22:
  uint64_t v16 = *(void **)(a1 + 1760);
  if (v16 == (void *)(a1 + 1736))
  {
    uint64_t v17 = 4LL;
    uint64_t v16 = (void *)(a1 + 1736);
  }

  else
  {
    if (!v16) {
      goto LABEL_27;
    }
    uint64_t v17 = 5LL;
  }

  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_27:
  sub_1000BB354((unint64_t *)(a1 + 1720));
  sub_1000DD6B0((void *)(a1 + 1192));
  uint64_t v18 = *(void **)(a1 + 1176);
  if (v18 == (void *)(a1 + 1152))
  {
    uint64_t v19 = 4LL;
    uint64_t v18 = (void *)(a1 + 1152);
    goto LABEL_31;
  }

  if (v18)
  {
    uint64_t v19 = 5LL;
LABEL_31:
    (*(void (**)(void))(*v18 + 8 * v19))();
  }

  sub_1000DD7C8((void *)(a1 + 1128));
  std::mutex::~mutex((std::mutex *)(a1 + 1064));
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 1016));
  std::mutex::~mutex((std::mutex *)(a1 + 952));
  sub_100026AC4(a1 + 928, *(void **)(a1 + 936));
  sub_1000F95F0((dispatch_object_s **)(a1 + 920));
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 864));
  std::mutex::~mutex((std::mutex *)(a1 + 800));
  std::mutex::~mutex((std::mutex *)(a1 + 696));
  sub_1000BBD1C((void *)(a1 + 648));
  return sub_1000DD828((void *)a1);
}

uint64_t sub_1000DD14C(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t *a4)
{
  uint64_t v8 = a3 & 0x100;
  uint64_t v9 = (a3 >> 8) & 1;
  uint64_t v10 = (unint64_t *)(a1 + 784);
  do
    unint64_t v11 = __ldaxr(v10);
  while (__stlxr(v11 + 1, v10));
  if ((a3 & 1) != 0)
  {
    uint64_t v12 = (unint64_t *)(a1 + 768);
    do
      unint64_t v13 = __ldaxr(v12);
    while (__stlxr(v13 + 1, v12));
  }

  BOOL v14 = (unsigned int *)(a2 + 544);
  do
    unsigned int v15 = __ldaxr(v14);
  while (__stlxr(v15 | 2, v14));
  sub_1000BB354((unint64_t *)(a2 + 536));
  if (a4) {
    sub_1000BB354(a4);
  }
  if ((a3 & 1) != 0)
  {
    char v16 = atomic_load(v14);
    if ((v16 & 4) == 0)
    {
      uint64_t v17 = (a3 >> 16) & 1;
      do
      {
        if ((*v14 & 1) != 0) {
          break;
        }
        if ((_DWORD)v9)
        {
          std::mutex::lock((std::mutex *)(a1 + 696));
          uint64_t v18 = *(void *)(a1 + 688);
          std::mutex::unlock((std::mutex *)(a1 + 696));
          if (v18) {
            break;
          }
        }

        if (sub_1000DD3DC(a1, v17, 0LL, 0) == -1)
        {
          __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)sub_100116890(a2);
          __lk.__owns_ = 1;
          std::mutex::lock(__lk.__m_);
          uint64_t v24 = sub_100116950(a2);
          v25.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
          uint64_t v35 = a1;
          std::chrono::duration<long long, std::ratio<1, 1000000>>::rep v36 = v25.__d_.__rep_ + 200000;
          unint64_t v32 = a2;
          char v33 = v9;
          *(_DWORD *)__int128 v34 = *(_DWORD *)v38;
          *(_DWORD *)&v34[3] = *(_DWORD *)&v38[3];
          sub_1000DD540((std::condition_variable *)v24, &__lk, &v36, (uint64_t)&v32);
        }

        else
        {
          __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)sub_100116890(a2);
          __lk.__owns_ = 1;
          std::mutex::lock(__lk.__m_);
          uint64_t v19 = sub_100116950(a2);
          char v20 = atomic_load(v14);
          if ((v20 & 4) == 0)
          {
            uint64_t v21 = (std::condition_variable *)v19;
            do
            {
              if ((*v14 & 1) != 0) {
                break;
              }
              if ((_DWORD)v9)
              {
                std::mutex::lock((std::mutex *)(a1 + 696));
                uint64_t v22 = *(void *)(a1 + 688);
                std::mutex::unlock((std::mutex *)(a1 + 696));
                if (v22) {
                  break;
                }
              }

              std::condition_variable::wait(v21, &__lk);
              char v23 = atomic_load(v14);
            }

            while ((v23 & 4) == 0);
          }
        }

        if (__lk.__owns_) {
          std::mutex::unlock(__lk.__m_);
        }
        unsigned int v26 = *v14;
        if (!v8 || (v26 & 1) != 0)
        {
          if ((v26 & 1) != 0) {
            break;
          }
        }

        else if (*(void *)(a1 + 688))
        {
          break;
        }

        char v27 = atomic_load(v14);
      }

      while ((v27 & 4) == 0);
    }

    uint64_t v28 = (unint64_t *)(a1 + 768);
    do
      unint64_t v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
  }

  do
    unsigned int v30 = __ldaxr(v14);
  while (__stlxr(v30 & 0xFFFFFFFD, v14));
  return v30 & 1;
}

void sub_1000DD37C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::mutex *a14, char a15)
{
  if (a15) {
    std::mutex::unlock(a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000DD3A4(uint64_t a1)
{
  return a1;
}

uint64_t sub_1000DD3DC(uint64_t a1, int a2, uint64_t a3, unsigned __int8 a4)
{
  if (!*(void *)(a1 + 1144)) {
    return 0LL;
  }
  uint64_t v19 = (std::mutex *)(a1 + 1064);
  std::mutex::lock((std::mutex *)(a1 + 1064));
  if (*(void *)(a1 + 1144))
  {
    uint64_t v8 = *(uint64_t **)(a1 + 1136);
    if (v8 == (uint64_t *)(a1 + 1128))
    {
      uint64_t v11 = 1LL;
    }

    else
    {
      uint64_t v9 = a4;
      if (a2) {
        unsigned int v10 = 6;
      }
      else {
        unsigned int v10 = 4;
      }
      uint64_t v11 = 1LL;
      do
      {
        unint64_t v12 = v8[2];
        if ((sub_1000BB394(v12 + 8, v8[3], v10) | a2) == 1)
        {
          unint64_t v13 = sub_100116890(v12);
          std::mutex::lock((std::mutex *)v13);
          BOOL v14 = (unsigned int *)(v12 + 544);
          do
            unsigned int v15 = __ldaxr(v14);
          while (__stlxr(v15 & 0xFFFFFFFB, v14));
          std::mutex::unlock((std::mutex *)v13);
          uint64_t v16 = *v8;
          uint64_t v17 = (uint64_t *)v8[1];
          *(void *)(v16 + _Block_object_dispose((const void *)(v2 - 120), 8) = v17;
          *(void *)v8[1] = v16;
          --*(void *)(a1 + 1144);
          operator delete(v8);
          uint64_t v8 = v17;
        }

        else
        {
          if (!v9 || v8[3] == a3) {
            uint64_t v11 = 0xFFFFFFFFLL;
          }
          uint64_t v8 = (uint64_t *)v8[1];
        }
      }

      while (v8 != (uint64_t *)(a1 + 1128));
    }
  }

  else
  {
    uint64_t v11 = 0LL;
  }

  std::mutex::unlock(v19);
  return v11;
}

void sub_1000DD528( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::mutex *a10)
{
}

uint64_t sub_1000DD540( std::condition_variable *a1, std::unique_lock<std::mutex> *a2, uint64_t *a3, uint64_t a4)
{
  do
  {
    uint64_t v8 = *(void *)(a4 + 16);
    char v9 = atomic_load((unsigned int *)(*(void *)a4 + 544LL));
    if ((v9 & 4) != 0) {
      return 1LL;
    }
    if ((*(_DWORD *)(*(void *)a4 + 544LL) & 1) != 0) {
      return 1LL;
    }
    if (*(_BYTE *)(a4 + 8))
    {
      unsigned int v10 = (std::mutex *)(v8 + 696);
      std::mutex::lock((std::mutex *)(v8 + 696));
      uint64_t v11 = *(void *)(v8 + 688);
      std::mutex::unlock(v10);
      if (v11) {
        return 1LL;
      }
    }

    v12.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
    uint64_t v13 = *a3;
    if (*a3 <= v12.__d_.__rep_) {
      break;
    }
    if (!v13)
    {
      v14.__d_.__rep_ = 0LL;
      goto LABEL_14;
    }

    if (v13 < 1)
    {
      if ((unint64_t)v13 < 0xFFDF3B645A1CAC09LL)
      {
        v14.__d_.__rep_ = 0x8000000000000000LL;
        goto LABEL_14;
      }
    }

    else if ((unint64_t)v13 > 0x20C49BA5E353F7LL)
    {
      v14.__d_.__rep_ = 0x7FFFFFFFFFFFFFFFLL;
      goto LABEL_14;
    }

    v14.__d_.__rep_ = 1000 * v13;
LABEL_14:
    std::condition_variable::__do_timed_wait(a1, a2, v14);
  }

  while (std::chrono::system_clock::now().__d_.__rep_ < *a3);
  uint64_t v15 = *(void *)(a4 + 16);
  char v16 = atomic_load((unsigned int *)(*(void *)a4 + 544LL));
  if ((v16 & 4) != 0 || (*(_DWORD *)(*(void *)a4 + 544LL) & 1) != 0) {
    return 1LL;
  }
  if (!*(_BYTE *)(a4 + 8)) {
    return 0LL;
  }
  std::mutex::lock((std::mutex *)(v15 + 696));
  BOOL v17 = *(void *)(v15 + 688) != 0LL;
  std::mutex::unlock((std::mutex *)(v15 + 696));
  return v17;
}

void *sub_1000DD6B0(void *a1)
{
  unint64_t v2 = a1 + 59;
  unint64_t v3 = (void *)a1[62];
  if (v3 == v2)
  {
    uint64_t v4 = 4LL;
    unint64_t v3 = v2;
  }

  else
  {
    if (!v3) {
      goto LABEL_6;
    }
    uint64_t v4 = 5LL;
  }

  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  __int128 v5 = (void *)a1[58];
  if (v5 == a1 + 55)
  {
    uint64_t v6 = 4LL;
    __int128 v5 = a1 + 55;
  }

  else
  {
    if (!v5) {
      goto LABEL_11;
    }
    uint64_t v6 = 5LL;
  }

  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_11:
  uint64_t v7 = (void *)a1[54];
  if (v7 == a1 + 51)
  {
    uint64_t v8 = 4LL;
    uint64_t v7 = a1 + 51;
    goto LABEL_15;
  }

  if (v7)
  {
    uint64_t v8 = 5LL;
LABEL_15:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }

  sub_1000DD768((uint64_t)(a1 + 5));
  return a1;
}

uint64_t sub_1000DD768(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 360))
  {
    std::mutex::~mutex((std::mutex *)(a1 + 280));
    sub_1000BBD1C((void *)(a1 + 232));
    std::mutex::~mutex((std::mutex *)(a1 + 168));
    std::mutex::~mutex((std::mutex *)(a1 + 104));
    unint64_t v2 = *(void **)(a1 + 72);
    if (v2)
    {
      *(void *)(a1 + 80) = v2;
      operator delete(v2);
    }

    sub_1000BBDFC((uint64_t *)(a1 + 16));
  }

  return a1;
}

void *sub_1000DD7C8(void *result)
{
  if (result[2])
  {
    unint64_t v1 = result;
    uint64_t result = (void *)result[1];
    uint64_t v2 = *v1;
    uint64_t v3 = *result;
    *(void *)(v3 + _Block_object_dispose((const void *)(v2 - 120), 8) = *(void *)(*v1 + 8LL);
    **(void **)(v2 + _Block_object_dispose((const void *)(v2 - 120), 8) = v3;
    v1[2] = 0LL;
    if (result != v1)
    {
      do
      {
        uint64_t v4 = (void *)result[1];
        operator delete(result);
        uint64_t result = v4;
      }

      while (v4 != v1);
    }
  }

  return result;
}

void *sub_1000DD828(void *a1)
{
  uint64_t v2 = a1 + 13;
  do
  {
    unint64_t v3 = __ldaxr(v2);
    unint64_t v4 = v3 - 1;
  }

  while (__stlxr(v4, v2));
  if (!v4)
  {
    uint64_t v5 = a1[17];
    a1[17] = -1LL;
    sub_1000BB394((uint64_t)(a1 + 13), v5, 1u);
  }

  sub_1000DD6B0(v2);
  uint64_t v6 = (void *)a1[11];
  if (v6 == a1 + 8)
  {
    uint64_t v7 = 4LL;
    uint64_t v6 = a1 + 8;
  }

  else
  {
    if (!v6) {
      goto LABEL_10;
    }
    uint64_t v7 = 5LL;
  }

  (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_10:
  uint64_t v8 = (void *)a1[7];
  if (v8 == a1 + 4)
  {
    uint64_t v9 = 4LL;
    uint64_t v8 = a1 + 4;
  }

  else
  {
    if (!v8) {
      goto LABEL_15;
    }
    uint64_t v9 = 5LL;
  }

  (*(void (**)(void))(*v8 + 8 * v9))();
LABEL_15:
  unsigned int v10 = (void *)a1[3];
  if (v10 == a1)
  {
    uint64_t v11 = 4LL;
    unsigned int v10 = a1;
    goto LABEL_19;
  }

  if (v10)
  {
    uint64_t v11 = 5LL;
LABEL_19:
    (*(void (**)(void))(*v10 + 8 * v11))();
  }

  return a1;
}

void *sub_1000DD910(uint64_t a1)
{
  *(_BYTE *)(a1 + 736) = 0;
  if (*(void *)(a1 + 456))
  {
    unint64_t v3 = 0LL;
    do
    {
      unint64_t v4 = (unint64_t *)(*(void *)(a1 + 584) + 8 * v3);
      do
        uint64_t v5 = (unint64_t *)__ldaxr(v4);
      while (__stlxr(0LL, v4));
      if (v5)
      {
        unint64_t v1 = v1 & 0xFFFFFFFFFF000000LL | 0x10001;
        sub_1000DBEB4(a1, (unint64_t)v5, v1, 0LL);
        sub_1000BBEA0(v5 + 45);
        sub_1000DDBB0(v5 + 1);
        operator delete(v5);
      }

      ++v3;
    }

    while (*(void *)(a1 + 456) > v3);
  }

  sub_1000F9738((dispatch_queue_t *)(a1 + 744), &stru_100182320);
  uint64_t v6 = *(void **)(a1 + 584);
  if (v6) {
    operator delete[](v6);
  }
  std::mutex::lock((std::mutex *)(a1 + 520));
  uint64_t v7 = *(void *)(a1 + 480);
  if (*(void *)(a1 + 488) != v7)
  {
    unint64_t v8 = *(void *)(a1 + 504);
    uint64_t v9 = (void *)(v7 + 8 * (v8 >> 9));
    unsigned int v10 = (unint64_t **)(*v9 + 8 * (v8 & 0x1FF));
    uint64_t v11 = *(void *)(v7 + (((*(void *)(a1 + 512) + v8) >> 6) & 0x3FFFFFFFFFFFFF8LL))
        + 8 * ((*(void *)(a1 + 512) + v8) & 0x1FF);
    while (v10 != (unint64_t **)v11)
    {
      std::chrono::system_clock::time_point v12 = *v10;
      if (*v10)
      {
        sub_1000BBEA0(v12 + 45);
        sub_1000DDBB0(v12 + 1);
        operator delete(v12);
      }

      if ((unint64_t **)((char *)++v10 - *v9) == (unint64_t **)4096)
      {
        uint64_t v13 = (unint64_t **)v9[1];
        ++v9;
        unsigned int v10 = v13;
      }
    }
  }

  std::mutex::unlock((std::mutex *)(a1 + 520));
  std::chrono::time_point<std::chrono::system_clock, std::chrono::duration<long long, std::ratio<1, 1000000000>>> v14 = *(void **)(a1 + 1440);
  if (v14 == (void *)(a1 + 1416))
  {
    uint64_t v15 = 4LL;
    std::chrono::time_point<std::chrono::system_clock, std::chrono::duration<long long, std::ratio<1, 1000000000>>> v14 = (void *)(a1 + 1416);
  }

  else
  {
    if (!v14) {
      goto LABEL_22;
    }
    uint64_t v15 = 5LL;
  }

  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_22:
  char v16 = *(void **)(a1 + 1408);
  if (v16 == (void *)(a1 + 1384))
  {
    uint64_t v17 = 4LL;
    char v16 = (void *)(a1 + 1384);
  }

  else
  {
    if (!v16) {
      goto LABEL_27;
    }
    uint64_t v17 = 5LL;
  }

  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_27:
  sub_1000BBEA0((unint64_t *)(a1 + 1368));
  sub_1000DDBB0((void *)(a1 + 1016));
  uint64_t v18 = *(void **)(a1 + 1000);
  if (v18 == (void *)(a1 + 976))
  {
    uint64_t v19 = 4LL;
    uint64_t v18 = (void *)(a1 + 976);
    goto LABEL_31;
  }

  if (v18)
  {
    uint64_t v19 = 5LL;
LABEL_31:
    (*(void (**)(void))(*v18 + 8 * v19))();
  }

  sub_1000DD7C8((void *)(a1 + 952));
  std::mutex::~mutex((std::mutex *)(a1 + 888));
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 840));
  std::mutex::~mutex((std::mutex *)(a1 + 776));
  sub_100026AC4(a1 + 752, *(void **)(a1 + 760));
  sub_1000F95F0((dispatch_object_s **)(a1 + 744));
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 688));
  std::mutex::~mutex((std::mutex *)(a1 + 624));
  std::mutex::~mutex((std::mutex *)(a1 + 520));
  sub_1000BBD1C((void *)(a1 + 472));
  return sub_1000DDCAC((void *)a1);
}

uint64_t sub_1000DDB78(uint64_t a1)
{
  return a1;
}

void *sub_1000DDBB0(void *a1)
{
  uint64_t v2 = a1 + 37;
  unint64_t v3 = (void *)a1[40];
  if (v3 == v2)
  {
    uint64_t v4 = 4LL;
    unint64_t v3 = v2;
  }

  else
  {
    if (!v3) {
      goto LABEL_6;
    }
    uint64_t v4 = 5LL;
  }

  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  uint64_t v5 = (void *)a1[36];
  if (v5 == a1 + 33)
  {
    uint64_t v6 = 4LL;
    uint64_t v5 = a1 + 33;
  }

  else
  {
    if (!v5) {
      goto LABEL_11;
    }
    uint64_t v6 = 5LL;
  }

  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_11:
  uint64_t v7 = (void *)a1[32];
  if (v7 == a1 + 29)
  {
    uint64_t v8 = 4LL;
    uint64_t v7 = a1 + 29;
    goto LABEL_15;
  }

  if (v7)
  {
    uint64_t v8 = 5LL;
LABEL_15:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }

  sub_1000DDC68((uint64_t)(a1 + 5));
  return a1;
}

uint64_t sub_1000DDC68(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 184))
  {
    std::mutex::~mutex((std::mutex *)(a1 + 120));
    *(void *)(a1 + sub_1000114F0(v6 - 32) = off_1001731C0;
    sub_100071324((uint64_t *)(a1 + 56));
  }

  return a1;
}

void *sub_1000DDCAC(void *a1)
{
  uint64_t v2 = a1 + 13;
  do
  {
    unint64_t v3 = __ldaxr(v2);
    unint64_t v4 = v3 - 1;
  }

  while (__stlxr(v4, v2));
  if (!v4)
  {
    uint64_t v5 = a1[17];
    a1[17] = -1LL;
    sub_1000BBEE0((uint64_t)(a1 + 13), v5, 1u);
  }

  sub_1000DDBB0(v2);
  uint64_t v6 = (void *)a1[11];
  if (v6 == a1 + 8)
  {
    uint64_t v7 = 4LL;
    uint64_t v6 = a1 + 8;
  }

  else
  {
    if (!v6) {
      goto LABEL_10;
    }
    uint64_t v7 = 5LL;
  }

  (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_10:
  uint64_t v8 = (void *)a1[7];
  if (v8 == a1 + 4)
  {
    uint64_t v9 = 4LL;
    uint64_t v8 = a1 + 4;
  }

  else
  {
    if (!v8) {
      goto LABEL_15;
    }
    uint64_t v9 = 5LL;
  }

  (*(void (**)(void))(*v8 + 8 * v9))();
LABEL_15:
  unsigned int v10 = (void *)a1[3];
  if (v10 == a1)
  {
    uint64_t v11 = 4LL;
    unsigned int v10 = a1;
    goto LABEL_19;
  }

  if (v10)
  {
    uint64_t v11 = 5LL;
LABEL_19:
    (*(void (**)(void))(*v10 + 8 * v11))();
  }

  return a1;
}

uint64_t sub_1000DDD94(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_10017FA00;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000DDDFC(_Unwind_Exception *a1)
{
}

uint64_t sub_1000DDE10(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_10017FC20;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000DDE78(_Unwind_Exception *a1)
{
}

uint64_t sub_1000DDE8C(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_10017FE40;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000DDEF4(_Unwind_Exception *a1)
{
}

__n128 sub_1000DDF10(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &off_100182350;
  *(_OWORD *)(v2 + _Block_object_dispose((const void *)(v2 - 120), 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1000DDF50(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &off_100182350;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + _Block_object_dispose((const void *)(v2 - 120), 8) = result;
  return result;
}

void sub_1000DDF78(uint64_t a1, uint64_t *a2)
{
}

uint64_t sub_1000DDF84(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_1000DDFC0()
{
}

void *sub_1000DDFCC( void **a1, char *a2, uint64_t a3, void *a4, char *a5, void *a6, char *a7, unint64_t a8)
{
  unint64_t v8 = a8;
  unint64_t v14 = (unint64_t)a1[4];
  unint64_t v15 = v14 >> 9;
  char v16 = a1[1];
  uint64_t v17 = a1[2];
  uint64_t v18 = &v16[8 * (v14 >> 9)];
  if (v17 == v16) {
    uint64_t v19 = 0LL;
  }
  else {
    uint64_t v19 = *(void *)v18 + 8 * ((unint64_t)a1[4] & 0x1FF);
  }
  if (a3 == v19) {
    unint64_t v20 = 0LL;
  }
  else {
    unint64_t v20 = ((a3 - *(void *)a2) >> 3) + ((a2 - v18) << 6) - ((v19 - *(void *)v18) >> 3);
  }
  uint64_t v21 = (char *)a1[5];
  if (v20 >= (unint64_t)&v21[-v20])
  {
    uint64_t v24 = ((v17 - v16) << 6) - 1;
    if (v17 == v16) {
      uint64_t v24 = 0LL;
    }
    unint64_t v25 = (unint64_t)&v21[v14];
    unint64_t v26 = v24 - v25;
    if (a8 > v26)
    {
      sub_1000DEA98(a1, a8 - v26);
      uint64_t v21 = (char *)a1[5];
      char v16 = a1[1];
      uint64_t v17 = a1[2];
      unint64_t v25 = (unint64_t)&v21[(void)a1[4]];
    }

    unint64_t v88 = (char **)a6;
    char v27 = (char **)&v16[8 * (v25 >> 9)];
    if (v17 == v16) {
      uint64_t v28 = 0LL;
    }
    else {
      uint64_t v28 = &(*v27)[8 * (v25 & 0x1FF)];
    }
    v90.n128_u64[0] = (unint64_t)&v16[8 * (v25 >> 9)];
    v90.n128_u64[1] = (unint64_t)v28;
    unint64_t v31 = (unint64_t)&v21[-v20];
    unint64_t v87 = (char **)a4;
    if ((unint64_t)&v21[-v20] >= v8)
    {
      __int128 v34 = a7;
      if (!v8) {
        goto LABEL_90;
      }
      goto LABEL_78;
    }

    if (v31 >= v8 >> 1)
    {
      uint64_t v32 = (uint64_t)&v21[-v20 - v8 + ((a7 - *v88) >> 3)];
      if (v32 >= 1)
      {
        v88 += (unint64_t)v32 >> 9;
        char v33 = *v88;
        goto LABEL_39;
      }

      unint64_t v37 = 511 - v32;
      __int16 v38 = ~(_WORD)v37;
      v88 -= v37 >> 9;
      uint64_t v39 = *v88;
    }

    else
    {
      if (!v31)
      {
        unint64_t v88 = (char **)a4;
        __int128 v34 = a5;
        goto LABEL_69;
      }

      uint64_t v32 = v31 + ((uint64_t)&a5[-*a4] >> 3);
      if (v32 >= 1)
      {
        unint64_t v88 = (char **)&a4[(unint64_t)v32 >> 9];
        char v33 = *v88;
LABEL_39:
        __int128 v34 = &v33[8 * (v32 & 0x1FF)];
        goto LABEL_69;
      }

      unint64_t v64 = 511 - v32;
      __int16 v38 = ~(_WORD)v64;
      unint64_t v88 = (char **)&a4[-(v64 >> 9)];
      uint64_t v39 = *v88;
    }

    __int128 v34 = &v39[8 * (v38 & 0x1FF)];
LABEL_69:
    if (v34 != a7)
    {
      unint64_t v65 = *v27;
      uint64_t v66 = v88;
      unint64_t v67 = v34;
      do
      {
        *(void *)uint64_t v28 = *(void *)v67;
        v28 += 8;
        if (v28 - v65 == 4096)
        {
          unint64_t v68 = v27[1];
          ++v27;
          unint64_t v65 = v68;
          uint64_t v28 = v68;
        }

        v67 += 8;
        if (v67 - *v66 == 4096)
        {
          uint64_t v69 = v66[1];
          ++v66;
          unint64_t v67 = v69;
        }

        ++v21;
      }

      while (v67 != a7);
      a1[5] = v21;
    }

    unint64_t v8 = v31;
    if (!v31) {
      goto LABEL_90;
    }
LABEL_78:
    unint64_t v70 = (char **)sub_1000DF020((uint64_t)&v90, v8);
    uint64_t v72 = v70;
    unint64_t v73 = v71;
    unint64_t v74 = (char *)v90.n128_u64[1];
    if ((char *)v90.n128_u64[1] != v71)
    {
      char v75 = (char *)a1[5];
      unint64_t v76 = *v27;
      unint64_t v77 = v70;
      unint64_t v78 = v71;
      do
      {
        *(void *)uint64_t v28 = *(void *)v78;
        v28 += 8;
        if (v28 - v76 == 4096)
        {
          uint64_t v79 = v27[1];
          ++v27;
          unint64_t v76 = v79;
          uint64_t v28 = v79;
        }

        v78 += 8;
        if (&v78[-*v77] == (char *)4096)
        {
          unint64_t v80 = (char *)v77[1];
          ++v77;
          unint64_t v78 = v80;
        }

        ++v75;
      }

      while (v78 != v74);
      a1[5] = v75;
    }

    if (v8 >= v31)
    {
      unint64_t v83 = (void *)v90.n128_u64[0];
    }

    else
    {
      uint64_t v81 = (char **)sub_1000DF020((uint64_t)&v90, v31);
      sub_1000DF210(v81, v82, v72, v73, v90.n128_u64[0], (char *)v90.n128_u64[1], &v91);
      unint64_t v74 = (char *)v92.n128_u64[1];
      unint64_t v83 = (void *)v92.n128_u64[0];
      __n128 v90 = v92;
    }

    sub_1000DF210(v87, a5, v88, v34, v83, v74, &v91);
    goto LABEL_90;
  }

  if (a8 > v14)
  {
    sub_1000DE56C(a1, a8 - v14);
    unint64_t v14 = (unint64_t)a1[4];
    char v16 = a1[1];
    uint64_t v17 = a1[2];
    unint64_t v15 = v14 >> 9;
  }

  uint64_t v22 = (uint64_t *)&v16[8 * v15];
  if (v17 == v16) {
    uint64_t v23 = 0LL;
  }
  else {
    uint64_t v23 = *v22 + 8 * (v14 & 0x1FF);
  }
  v90.n128_u64[0] = (unint64_t)&v16[8 * v15];
  v90.n128_u64[1] = v23;
  if (v8 <= v20)
  {
    unsigned int v30 = a5;
    if (!v8) {
      goto LABEL_90;
    }
    goto LABEL_55;
  }

  if (v20 >= v8 >> 1)
  {
    uint64_t v29 = v8 - v20 + ((uint64_t)&a5[-*a4] >> 3);
    if (v29 >= 1)
    {
      a4 += (unint64_t)v29 >> 9;
      goto LABEL_36;
    }

    unint64_t v35 = 511 - v29;
    __int16 v36 = ~(_WORD)v35;
    a4 -= v35 >> 9;
  }

  else
  {
    if (!v20)
    {
      a4 = a6;
      unsigned int v30 = a7;
      goto LABEL_46;
    }

    uint64_t v29 = ((uint64_t)&a7[-*a6] >> 3) - v20;
    if (v29 >= 1)
    {
      a4 = &a6[(unint64_t)v29 >> 9];
LABEL_36:
      unsigned int v30 = (char *)(*a4 + 8 * (v29 & 0x1FF));
      goto LABEL_46;
    }

    unint64_t v40 = 511 - v29;
    __int16 v36 = ~(_WORD)v40;
    a4 = &a6[-(v40 >> 9)];
  }

  unsigned int v30 = (char *)(*a4 + 8LL * (v36 & 0x1FF));
LABEL_46:
  if (v30 != a5)
  {
    unint64_t v41 = (char *)a1[5];
    uint64_t v42 = *v22;
    __int128 v43 = (char **)a4;
    __int128 v44 = v30;
    do
    {
      if (v23 == v42)
      {
        uint64_t v45 = *--v22;
        uint64_t v42 = v45;
        uint64_t v23 = v45 + 4096;
      }

      if (v44 == *v43)
      {
        uint64_t v46 = (uint64_t)*--v43;
        __int128 v44 = (char *)(v46 + 4096);
      }

      uint64_t v47 = *((void *)v44 - 1);
      v44 -= 8;
      *(void *)(v23 - _Block_object_dispose((const void *)(v2 - 120), 8) = v47;
      v23 -= 8LL;
      --v14;
      ++v41;
    }

    while (v44 != a5);
    a1[4] = (void *)v14;
    a1[5] = v41;
  }

  unint64_t v8 = v20;
  if (v20)
  {
LABEL_55:
    unint64_t v89 = (char **)a6;
    __int128 v48 = (char **)a4;
    uint64_t v49 = (char **)sub_1000DEA34((uint64_t)&v90, v8);
    unint64_t v51 = v49;
    uint64_t v52 = v50;
    unint64_t v53 = v90.n128_u64[1];
    if ((char *)v90.n128_u64[1] != v50)
    {
      int64x2_t v54 = *((int64x2_t *)a1 + 2);
      uint64_t v55 = *v22;
      unint64_t v56 = v49;
      uint64_t v57 = v50;
      do
      {
        if (v23 == v55)
        {
          uint64_t v58 = *--v22;
          uint64_t v55 = v58;
          uint64_t v23 = v58 + 4096;
        }

        if (v57 == *v56)
        {
          uint64_t v59 = (uint64_t)*--v56;
          uint64_t v57 = (char *)(v59 + 4096);
        }

        uint64_t v60 = *((void *)v57 - 1);
        v57 -= 8;
        *(void *)(v23 - _Block_object_dispose((const void *)(v2 - 120), 8) = v60;
        v23 -= 8LL;
        int64x2_t v54 = vaddq_s64(v54, (int64x2_t)xmmword_10013D640);
      }

      while (v57 != (char *)v53);
      *((int64x2_t *)a1 + 2) = v54;
    }

    if (v8 >= v20)
    {
      unint64_t v63 = v90.n128_u64[0];
    }

    else
    {
      unint64_t v61 = (char **)sub_1000DEA34((uint64_t)&v90, v20);
      __n128 v91 = v90;
      sub_1000DF088(v51, v52, v61, v62, (uint64_t)&v91);
      unint64_t v53 = v91.n128_u64[1];
      unint64_t v63 = v91.n128_u64[0];
      __n128 v90 = v91;
    }

    v91.n128_u64[0] = v63;
    v91.n128_u64[1] = v53;
    sub_1000DF088(v48, v30, v89, a7, (uint64_t)&v91);
  }

LABEL_90:
  uint64_t v84 = a1[1];
  if (a1[2] == v84) {
    uint64_t v85 = 0LL;
  }
  else {
    uint64_t v85 = v84[(unint64_t)a1[4] >> 9] + 8 * ((unint64_t)a1[4] & 0x1FF);
  }
  v91.n128_u64[0] = (unint64_t)&v84[(unint64_t)a1[4] >> 9];
  v91.n128_u64[1] = v85;
  return sub_1000DEA34((uint64_t)&v91, v20);
}

void sub_1000DE56C(void **a1, unint64_t a2)
{
  unint64_t v3 = a1[1];
  char v4 = a1[2];
  uint64_t v5 = v4 - v3;
  if (v4 == v3) {
    unint64_t v6 = a2 + 1;
  }
  else {
    unint64_t v6 = a2;
  }
  if (v4 == v3) {
    uint64_t v7 = 0LL;
  }
  else {
    uint64_t v7 = ((v4 - v3) << 6) - 1;
  }
  if ((v6 & 0x1FF) != 0) {
    unint64_t v8 = (v6 >> 9) + 1;
  }
  else {
    unint64_t v8 = v6 >> 9;
  }
  uint64_t v9 = (uint64_t)a1[4];
  unint64_t v10 = v7 - ((void)a1[5] + v9);
  if (v8 >= v10 >> 9) {
    unint64_t v11 = v10 >> 9;
  }
  else {
    unint64_t v11 = v8;
  }
  if (v8 <= v10 >> 9)
  {
    for (a1[4] = (void *)(v9 + (v11 << 9)); v11; --v11)
    {
      uint64_t v19 = (void **)a1[2];
      __p[0] = *(v19 - 1);
      a1[2] = v19 - 1;
      sub_1000DBB6C((uint64_t)a1, __p);
    }
  }

  else
  {
    uint64_t v12 = (uint64_t)(a1 + 3);
    unint64_t v13 = v8 - v11;
    uint64_t v14 = (_BYTE *)a1[3] - (_BYTE *)*a1;
    if (v8 - v11 <= (v14 >> 3) - (v5 >> 3))
    {
      if (v13)
      {
        if (v3 == *a1)
        {
LABEL_30:
          unint64_t v22 = v13;
          do
          {
            __p[0] = operator new(0x1000uLL);
            sub_1000DBA58(a1, __p);
            --v22;
          }

          while (v22);
          v11 += v13;
          uint64_t v9 = (uint64_t)a1[4];
        }

        else
        {
          while (1)
          {
            __p[0] = operator new(0x1000uLL);
            sub_1000DBB6C((uint64_t)a1, __p);
            unint64_t v20 = a1[1];
            uint64_t v21 = (_BYTE *)a1[2] - v20 == 8 ? 511LL : 512LL;
            uint64_t v9 = (uint64_t)a1[4] + v21;
            a1[4] = (void *)v9;
            if (!--v13) {
              break;
            }
            if (v20 == *a1) {
              goto LABEL_30;
            }
          }
        }
      }

      for (a1[4] = (void *)(v9 + (v11 << 9)); v11; --v11)
      {
        uint64_t v23 = (void **)a1[2];
        __p[0] = *(v23 - 1);
        a1[2] = v23 - 1;
        sub_1000DBB6C((uint64_t)a1, __p);
      }
    }

    else
    {
      BOOL v15 = v4 == v3;
      unint64_t v16 = v8 << 9;
      if (v14 >> 2 <= v13 + (v5 >> 3)) {
        unint64_t v17 = v13 + (v5 >> 3);
      }
      else {
        unint64_t v17 = v14 >> 2;
      }
      unint64_t v70 = a1 + 3;
      if (v17) {
        uint64_t v18 = (char *)sub_10001848C(v12, v17);
      }
      else {
        uint64_t v18 = 0LL;
      }
      unint64_t v24 = v16 - v15;
      __p[0] = v18;
      __p[1] = v18;
      unint64_t v68 = v18;
      uint64_t v69 = &v18[8 * v17];
      do
      {
        uint64_t v66 = operator new(0x1000uLL);
        sub_1000DBC88(__p, &v66);
        --v13;
      }

      while (v13);
      unint64_t v25 = (char *)a1[2];
      for (uint64_t i = v68; v11; --v11)
      {
        if (i == v69)
        {
          int64_t v27 = (char *)__p[1] - (char *)__p[0];
          if (__p[1] <= __p[0])
          {
            if (i == __p[0]) {
              unint64_t v35 = 1LL;
            }
            else {
              unint64_t v35 = (i - (char *)__p[0]) >> 2;
            }
            __int16 v36 = (char *)sub_10001848C((uint64_t)v70, v35);
            __int16 v38 = (uint64_t *)__p[1];
            uint64_t i = &v36[8 * (v35 >> 2)];
            uint64_t v39 = v68 - (char *)__p[1];
            if (v68 != __p[1])
            {
              uint64_t i = &v36[8 * (v35 >> 2) + (v39 & 0xFFFFFFFFFFFFFFF8LL)];
              uint64_t v40 = 8 * (v39 >> 3);
              unint64_t v41 = &v36[8 * (v35 >> 2)];
              do
              {
                uint64_t v42 = *v38++;
                *(void *)unint64_t v41 = v42;
                v41 += 8;
                v40 -= 8LL;
              }

              while (v40);
            }

            __int128 v43 = __p[0];
            __p[0] = v36;
            __p[1] = &v36[8 * (v35 >> 2)];
            unint64_t v68 = i;
            uint64_t v69 = &v36[8 * v37];
            if (v43)
            {
              operator delete(v43);
              uint64_t i = v68;
            }
          }

          else
          {
            uint64_t v28 = v27 >> 3;
            BOOL v29 = v27 >> 3 < -1;
            uint64_t v30 = (v27 >> 3) + 2;
            if (v29) {
              uint64_t v31 = v30;
            }
            else {
              uint64_t v31 = v28 + 1;
            }
            uint64_t v32 = (char *)__p[1] - 8 * (v31 >> 1);
            int64_t v33 = i - (char *)__p[1];
            if (i != __p[1])
            {
              memmove((char *)__p[1] - 8 * (v31 >> 1), __p[1], i - (char *)__p[1]);
              uint64_t i = (char *)__p[1];
            }

            __int128 v34 = &i[-8 * (v31 >> 1)];
            uint64_t i = &v32[v33];
            __p[1] = v34;
            unint64_t v68 = &v32[v33];
          }
        }

        *(void *)uint64_t i = *((void *)v25 - 1);
        uint64_t i = v68 + 8;
        v68 += 8;
        unint64_t v25 = (char *)a1[2] - 8;
        a1[2] = v25;
      }

      __int128 v44 = (char *)a1[1];
      if (v44 == v25)
      {
        __int128 v44 = v25;
      }

      else
      {
        do
        {
          if (i == v69)
          {
            int64_t v45 = (char *)__p[1] - (char *)__p[0];
            if (__p[1] <= __p[0])
            {
              if (i == __p[0]) {
                unint64_t v52 = 1LL;
              }
              else {
                unint64_t v52 = (i - (char *)__p[0]) >> 2;
              }
              unint64_t v53 = (char *)sub_10001848C((uint64_t)v70, v52);
              uint64_t v55 = (uint64_t *)__p[1];
              uint64_t i = &v53[8 * (v52 >> 2)];
              uint64_t v56 = v68 - (char *)__p[1];
              if (v68 != __p[1])
              {
                uint64_t i = &v53[8 * (v52 >> 2) + (v56 & 0xFFFFFFFFFFFFFFF8LL)];
                uint64_t v57 = 8 * (v56 >> 3);
                uint64_t v58 = &v53[8 * (v52 >> 2)];
                do
                {
                  uint64_t v59 = *v55++;
                  *(void *)uint64_t v58 = v59;
                  v58 += 8;
                  v57 -= 8LL;
                }

                while (v57);
              }

              uint64_t v60 = __p[0];
              __p[0] = v53;
              __p[1] = &v53[8 * (v52 >> 2)];
              unint64_t v68 = i;
              uint64_t v69 = &v53[8 * v54];
              if (v60)
              {
                operator delete(v60);
                uint64_t i = v68;
              }
            }

            else
            {
              uint64_t v46 = v45 >> 3;
              BOOL v29 = v45 >> 3 < -1;
              uint64_t v47 = (v45 >> 3) + 2;
              if (v29) {
                uint64_t v48 = v47;
              }
              else {
                uint64_t v48 = v46 + 1;
              }
              uint64_t v49 = (char *)__p[1] - 8 * (v48 >> 1);
              int64_t v50 = i - (char *)__p[1];
              if (i != __p[1])
              {
                memmove((char *)__p[1] - 8 * (v48 >> 1), __p[1], i - (char *)__p[1]);
                uint64_t i = (char *)__p[1];
              }

              unint64_t v51 = &i[-8 * (v48 >> 1)];
              uint64_t i = &v49[v50];
              __p[1] = v51;
              unint64_t v68 = &v49[v50];
            }
          }

          uint64_t v61 = *(void *)v44;
          v44 += 8;
          *(void *)uint64_t i = v61;
          uint64_t i = v68 + 8;
          v68 += 8;
        }

        while (v44 != a1[2]);
        unint64_t v25 = (char *)a1[1];
      }

      unint64_t v62 = v69;
      unint64_t v63 = (char *)a1[3];
      unint64_t v64 = (char *)a1[4];
      a1[2] = i;
      a1[3] = v62;
      unint64_t v65 = *a1;
      *(_OWORD *)a1 = *(_OWORD *)__p;
      __p[0] = v65;
      __p[1] = v25;
      unint64_t v68 = v44;
      uint64_t v69 = v63;
      a1[4] = &v64[v24];
      if (v44 != v25) {
        unint64_t v68 = &v44[(v25 - v44 + 7) & 0xFFFFFFFFFFFFFFF8LL];
      }
      if (v65) {
        operator delete(v65);
      }
    }
  }

void sub_1000DE9C0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1000DEA34(uint64_t a1, uint64_t a2)
{
  __n128 result = *(void **)a1;
  if (a2)
  {
    uint64_t v4 = a2 + ((uint64_t)(*(void *)(a1 + 8) - *result) >> 3);
    if (v4 < 1) {
      result -= (unint64_t)(511 - v4) >> 9;
    }
    else {
      result += (unint64_t)v4 >> 9;
    }
  }

  return result;
}

void sub_1000DEA98(void *a1, unint64_t a2)
{
  unint64_t v3 = (char *)a1[2];
  uint64_t v4 = (uint64_t)&v3[-a1[1]];
  if (v4) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = a2 + 1;
  }
  if ((v5 & 0x1FF) != 0) {
    unint64_t v6 = (v5 >> 9) + 1;
  }
  else {
    unint64_t v6 = v5 >> 9;
  }
  unint64_t v7 = a1[4];
  if (v6 >= v7 >> 9) {
    unint64_t v8 = v7 >> 9;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v6 <= v7 >> 9)
  {
    for (a1[4] = v7 - (v8 << 9); v8; --v8)
    {
      unint64_t v16 = (void *)a1[1];
      uint64_t v19 = *v16;
      unint64_t v17 = (char *)(v16 + 1);
      uint64_t v18 = v19;
      a1[1] = v17;
      if (v3 == (char *)a1[3])
      {
        uint64_t v20 = (uint64_t)&v17[-*a1];
        if ((unint64_t)v17 <= *a1)
        {
          else {
            unint64_t v28 = (uint64_t)&v3[-*a1] >> 2;
          }
          BOOL v29 = (char *)sub_10001848C((uint64_t)(a1 + 3), v28);
          uint64_t v31 = &v29[8 * (v28 >> 2)];
          uint64_t v32 = (uint64_t *)a1[1];
          unint64_t v3 = v31;
          uint64_t v33 = a1[2] - (void)v32;
          if (v33)
          {
            unint64_t v3 = &v31[v33 & 0xFFFFFFFFFFFFFFF8LL];
            uint64_t v34 = 8 * (v33 >> 3);
            unint64_t v35 = &v29[8 * (v28 >> 2)];
            do
            {
              uint64_t v36 = *v32++;
              *(void *)unint64_t v35 = v36;
              v35 += 8;
              v34 -= 8LL;
            }

            while (v34);
          }

          uint64_t v37 = (char *)*a1;
          *a1 = v29;
          a1[1] = v31;
          a1[2] = v3;
          a1[3] = &v29[8 * v30];
          if (v37)
          {
            operator delete(v37);
            unint64_t v3 = (char *)a1[2];
          }
        }

        else
        {
          uint64_t v21 = v20 >> 3;
          BOOL v22 = v20 >> 3 < -1;
          uint64_t v23 = (v20 >> 3) + 2;
          if (v22) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = v21 + 1;
          }
          unint64_t v25 = &v17[-8 * (v24 >> 1)];
          int64_t v26 = v3 - v17;
          if (v3 != v17)
          {
            memmove(&v17[-8 * (v24 >> 1)], v17, v3 - v17);
            unint64_t v3 = (char *)a1[1];
          }

          int64_t v27 = &v3[-8 * (v24 >> 1)];
          unint64_t v3 = &v25[v26];
          a1[1] = v27;
          a1[2] = &v25[v26];
        }
      }

      *(void *)unint64_t v3 = v18;
      unint64_t v3 = (char *)(a1[2] + 8LL);
      a1[2] = v3;
    }
  }

  else
  {
    unint64_t v9 = v6 - v8;
    uint64_t v10 = a1[3] - *a1;
    if (v6 - v8 <= (v10 >> 3) - (v4 >> 3))
    {
      if (v9)
      {
        while (a1[3] != a1[2])
        {
          __p[0] = operator new(0x1000uLL);
          sub_1000DBA58(a1, __p);
          --v6;
          if (!--v9) {
            goto LABEL_75;
          }
        }

        for (uint64_t i = 0LL; i != v9; ++i)
        {
          __p[0] = operator new(0x1000uLL);
          sub_1000DBB6C((uint64_t)a1, __p);
          if (a1[2] - a1[1] == 8LL) {
            uint64_t v64 = 511LL;
          }
          else {
            uint64_t v64 = 512LL;
          }
          uint64_t v65 = v64 + a1[4];
          a1[4] = v65;
        }

        unint64_t v8 = v6;
      }

      else
      {
LABEL_75:
        uint64_t v65 = a1[4];
      }

      a1[4] = v65 - (v8 << 9);
      if (v8)
      {
        uint64_t v66 = (char *)a1[2];
        do
        {
          unint64_t v67 = (void *)a1[1];
          uint64_t v70 = *v67;
          unint64_t v68 = (char *)(v67 + 1);
          uint64_t v69 = v70;
          a1[1] = v68;
          if (v66 == (char *)a1[3])
          {
            uint64_t v71 = (uint64_t)&v68[-*a1];
            if ((unint64_t)v68 <= *a1)
            {
              else {
                unint64_t v78 = (uint64_t)&v66[-*a1] >> 2;
              }
              uint64_t v79 = (char *)sub_10001848C((uint64_t)(a1 + 3), v78);
              uint64_t v81 = &v79[8 * (v78 >> 2)];
              uint64_t v82 = (uint64_t *)a1[1];
              uint64_t v66 = v81;
              uint64_t v83 = a1[2] - (void)v82;
              if (v83)
              {
                uint64_t v66 = &v81[v83 & 0xFFFFFFFFFFFFFFF8LL];
                uint64_t v84 = 8 * (v83 >> 3);
                uint64_t v85 = &v79[8 * (v78 >> 2)];
                do
                {
                  uint64_t v86 = *v82++;
                  *(void *)uint64_t v85 = v86;
                  v85 += 8;
                  v84 -= 8LL;
                }

                while (v84);
              }

              unint64_t v87 = (char *)*a1;
              *a1 = v79;
              a1[1] = v81;
              a1[2] = v66;
              a1[3] = &v79[8 * v80];
              if (v87)
              {
                operator delete(v87);
                uint64_t v66 = (char *)a1[2];
              }
            }

            else
            {
              uint64_t v72 = v71 >> 3;
              BOOL v22 = v71 >> 3 < -1;
              uint64_t v73 = (v71 >> 3) + 2;
              if (v22) {
                uint64_t v74 = v73;
              }
              else {
                uint64_t v74 = v72 + 1;
              }
              char v75 = &v68[-8 * (v74 >> 1)];
              int64_t v76 = v66 - v68;
              if (v66 != v68)
              {
                memmove(&v68[-8 * (v74 >> 1)], v68, v66 - v68);
                uint64_t v66 = (char *)a1[1];
              }

              unint64_t v77 = &v66[-8 * (v74 >> 1)];
              uint64_t v66 = &v75[v76];
              a1[1] = v77;
              a1[2] = &v75[v76];
            }
          }

          *(void *)uint64_t v66 = v69;
          uint64_t v66 = (char *)(a1[2] + 8LL);
          a1[2] = v66;
          --v8;
        }

        while (v8);
      }
    }

    else
    {
      uint64_t v11 = v4 >> 3;
      unint64_t v12 = v10 >> 2;
      if (v12 <= v9 + v11) {
        unint64_t v13 = v9 + v11;
      }
      else {
        unint64_t v13 = v12;
      }
      unint64_t v14 = v11 - v8;
      __n128 v91 = a1 + 3;
      if (v13) {
        BOOL v15 = (char *)sub_10001848C((uint64_t)(a1 + 3), v13);
      }
      else {
        BOOL v15 = 0LL;
      }
      uint64_t v38 = v8 << 9;
      __p[0] = v15;
      __p[1] = &v15[8 * v14];
      *(void **)&__int128 v90 = __p[1];
      *((void *)&v90 + 1) = &v15[8 * v13];
      do
      {
        unint64_t v88 = operator new(0x1000uLL);
        sub_1000DBC88(__p, &v88);
        --v9;
      }

      while (v9);
      if (v8)
      {
        uint64_t v39 = (void *)a1[1];
        uint64_t v40 = (char *)v90;
        do
        {
          if (v40 == *((char **)&v90 + 1))
          {
            int64_t v41 = (char *)__p[1] - (char *)__p[0];
            if (__p[1] <= __p[0])
            {
              if (v40 == __p[0]) {
                unint64_t v48 = 1LL;
              }
              else {
                unint64_t v48 = (v40 - (char *)__p[0]) >> 2;
              }
              uint64_t v49 = (char *)sub_10001848C((uint64_t)v91, v48);
              unint64_t v51 = (uint64_t *)__p[1];
              uint64_t v40 = &v49[8 * (v48 >> 2)];
              uint64_t v52 = v90 - (unint64_t)__p[1];
              if ((void *)v90 != __p[1])
              {
                uint64_t v40 = &v49[8 * (v48 >> 2) + (v52 & 0xFFFFFFFFFFFFFFF8LL)];
                uint64_t v53 = 8 * (v52 >> 3);
                uint64_t v54 = &v49[8 * (v48 >> 2)];
                do
                {
                  uint64_t v55 = *v51++;
                  *(void *)uint64_t v54 = v55;
                  v54 += 8;
                  v53 -= 8LL;
                }

                while (v53);
              }

              uint64_t v56 = __p[0];
              __p[0] = v49;
              __p[1] = &v49[8 * (v48 >> 2)];
              *(void *)&__int128 v90 = v40;
              *((void *)&v90 + 1) = &v49[8 * v50];
              if (v56)
              {
                operator delete(v56);
                uint64_t v40 = (char *)v90;
              }
            }

            else
            {
              uint64_t v42 = v41 >> 3;
              BOOL v22 = v41 >> 3 < -1;
              uint64_t v43 = (v41 >> 3) + 2;
              if (v22) {
                uint64_t v44 = v43;
              }
              else {
                uint64_t v44 = v42 + 1;
              }
              int64_t v45 = (char *)__p[1] - 8 * (v44 >> 1);
              int64_t v46 = v40 - (char *)__p[1];
              if (v40 != __p[1])
              {
                memmove((char *)__p[1] - 8 * (v44 >> 1), __p[1], v40 - (char *)__p[1]);
                uint64_t v40 = (char *)__p[1];
              }

              uint64_t v47 = &v40[-8 * (v44 >> 1)];
              uint64_t v40 = &v45[v46];
              __p[1] = v47;
              *(void *)&__int128 v90 = &v45[v46];
            }
          }

          *(void *)uint64_t v40 = *v39;
          uint64_t v40 = (char *)(v90 + 8);
          *(void *)&__int128 v90 = v90 + 8;
          uint64_t v39 = (void *)(a1[1] + 8LL);
          a1[1] = v39;
          --v8;
        }

        while (v8);
      }

      uint64_t v57 = (void *)a1[2];
      uint64_t v58 = -7LL - (void)v57;
      while (v57 != (void *)a1[1])
      {
        --v57;
        v58 += 8LL;
        sub_1000DBD9C((uint64_t)__p, v57);
      }

      uint64_t v59 = (char *)*a1;
      __int128 v60 = *(_OWORD *)__p;
      __int128 v61 = v90;
      __p[0] = *(void **)a1;
      __p[1] = v57;
      __int128 v62 = *((_OWORD *)a1 + 1);
      *(_OWORD *)a1 = v60;
      *((_OWORD *)a1 + 1) = v61;
      __int128 v90 = v62;
      a1[4] -= v38;
      if (v57 != (void *)v62) {
        *(void *)&__int128 v90 = v62 + (-(v62 + v58) & 0xFFFFFFFFFFFFFFF8LL);
      }
      if (v59) {
        operator delete(v59);
      }
    }
  }

void sub_1000DEFAC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1000DF020(uint64_t a1, uint64_t a2)
{
  __n128 result = *(void **)a1;
  if (a2)
  {
    uint64_t v4 = ((uint64_t)(*(void *)(a1 + 8) - *result) >> 3) - a2;
    if (v4 < 1) {
      result -= (unint64_t)(511 - v4) >> 9;
    }
    else {
      result += (unint64_t)v4 >> 9;
    }
  }

  return result;
}

double sub_1000DF088(char **a1, char *__src, char **a3, char *a4, uint64_t a5)
{
  if (a1 == a3)
  {
    uint64_t v11 = *(void ***)a5;
    unint64_t v12 = *(char **)(a5 + 8);
    uint64_t v10 = __src;
  }

  else
  {
    unint64_t v8 = a1 + 1;
    sub_1000DF154(__src, *(char **)(a5 + 8), *a1 + 4096, *(void ***)a5, &v14);
    for (*(_OWORD *)a5 = v15; v8 != a3; *(_OWORD *)a5 = v15)
    {
      unint64_t v9 = *v8++;
      sub_1000DF154(v9, *(char **)(a5 + 8), v9 + 4096, *(void ***)a5, &v14);
    }

    uint64_t v10 = *a3;
    uint64_t v11 = *(void ***)a5;
    unint64_t v12 = *(char **)(a5 + 8);
  }

  sub_1000DF154(v10, v12, a4, v11, &v14);
  double result = *(double *)&v15;
  *(_OWORD *)a5 = v15;
  return result;
}

char *sub_1000DF154@<X0>(char *__src@<X0>, char *__dst@<X3>, char *a3@<X1>, void **a4@<X2>, char **a5@<X8>)
{
  unint64_t v6 = a4;
  if (__src != a3)
  {
    unint64_t v9 = __src;
    unint64_t v6 = a4 + 1;
    uint64_t v10 = (char *)*a4;
    while (1)
    {
      uint64_t v11 = v10 - __dst + 4096;
      uint64_t v12 = (a3 - v9) >> 3 >= v11 >> 3 ? v11 >> 3 : (a3 - v9) >> 3;
      if (v12) {
        __src = (char *)memmove(__dst, v9, 8 * v12);
      }
      v9 += 8 * v12;
      if (v9 == a3) {
        break;
      }
      unint64_t v13 = (char *)*v6++;
      uint64_t v10 = v13;
      __dst = v13;
    }

    __dst += 8 * v12;
    else {
      --v6;
    }
  }

  *a5 = a3;
  a5[1] = (char *)v6;
  a5[2] = __dst;
  return __src;
}

__n128 sub_1000DF210@<Q0>( char **a1@<X1>, char *a2@<X2>, char **a3@<X3>, char *a4@<X4>, void *a5@<X5>, char *a6@<X6>, __n128 *a7@<X8>)
{
  if (a1 == a3)
  {
    uint64_t v19 = a2;
    uint64_t v18 = a4;
    __int128 v15 = a5;
    unint64_t v16 = a6;
  }

  else
  {
    unint64_t v13 = a3 - 1;
    uint64_t v12 = *a3;
    unint64_t v14 = a4;
    __int128 v15 = a5;
    unint64_t v16 = a6;
    while (1)
    {
      sub_1000DF2DC(v12, v14, v15, v16, &v21);
      unint64_t v16 = (char *)v22.n128_u64[1];
      __int128 v15 = (void *)v22.n128_u64[0];
      if (v13 == a1) {
        break;
      }
      unint64_t v17 = *v13--;
      uint64_t v12 = v17;
      unint64_t v14 = v17 + 4096;
    }

    uint64_t v18 = *a1 + 4096;
    uint64_t v19 = a2;
  }

  sub_1000DF2DC(v19, v18, v15, v16, &v21);
  __n128 result = v22;
  a7->n128_u64[0] = (unint64_t)a3;
  a7->n128_u64[1] = (unint64_t)a4;
  a7[1] = result;
  return result;
}

void *sub_1000DF2DC@<X0>(char *a1@<X1>, char *a2@<X2>, void *a3@<X3>, char *a4@<X4>, void *a5@<X8>)
{
  unint64_t v6 = a3;
  if (a1 == a2)
  {
    unint64_t v9 = a1;
  }

  else
  {
    unint64_t v9 = a2;
    uint64_t v10 = *a3;
    uint64_t v11 = a2;
    while (1)
    {
      uint64_t v12 = (uint64_t)&a4[-v10];
      if ((v11 - a1) >> 3 >= v12 >> 3) {
        uint64_t v13 = v12 >> 3;
      }
      else {
        uint64_t v13 = (v11 - a1) >> 3;
      }
      v11 -= 8 * v13;
      a4 -= 8 * v13;
      if (v13) {
        __n128 result = memmove(a4, v11, 8 * v13);
      }
      if (v11 == a1) {
        break;
      }
      uint64_t v15 = *--v6;
      uint64_t v10 = v15;
      a4 = (char *)(v15 + 4096);
    }

    if ((char *)(*v6 + 4096LL) == a4)
    {
      unint64_t v16 = (char *)v6[1];
      ++v6;
      a4 = v16;
    }
  }

  *a5 = v9;
  a5[1] = v6;
  a5[2] = a4;
  return result;
}

void sub_1000DF394( uint64_t a1, unint64_t **a2, unint64_t *a3, uint64_t a4, unint64_t *a5, uint64_t a6)
{
  if (a3 != a5)
  {
    uint64_t v12 = *a2;
    uint64_t v13 = a3;
    unint64_t v14 = a3;
    uint64_t v15 = a2;
    while (1)
    {
      if ((char *)++v14 - (char *)v12 == 4096)
      {
        unint64_t v16 = v15[1];
        ++v15;
        uint64_t v12 = v16;
        unint64_t v14 = v16;
      }

      if (v14 == a5) {
        break;
      }
      if (*v13 < *v14) {
        uint64_t v13 = v14;
      }
    }

    std::mutex::lock((std::mutex *)(a1 + 8));
    sub_1000DF4A4((uint64_t *)(a1 + 72), a2, a3, a4, a5);
    if (*v13 >= *(void *)(a1 + 96)) {
      *(void *)(a1 + 96) = *(void *)a1 + *v13;
    }
    sub_1000C9F3C((void *)a1, a6);
    std::mutex::unlock((std::mutex *)(a1 + 8));
  }

void sub_1000DF490(_Unwind_Exception *a1)
{
}

uint64_t *sub_1000DF4A4(uint64_t *result, void *a2, unint64_t *a3, uint64_t a4, unint64_t *a5)
{
  if (a3 != a5)
  {
    unint64_t v6 = a3;
    unint64_t v8 = (uint64_t **)result;
    unint64_t v9 = result + 1;
    do
    {
      __n128 result = sub_1000DF51C(v8, v9, v6, (uint64_t *)v6);
      if ((unint64_t *)((char *)++v6 - *a2) == (unint64_t *)4096)
      {
        uint64_t v10 = (unint64_t *)a2[1];
        ++a2;
        unint64_t v6 = v10;
      }
    }

    while (v6 != a5);
  }

  return result;
}

uint64_t *sub_1000DF51C(uint64_t **a1, void *a2, unint64_t *a3, uint64_t *a4)
{
  unint64_t v6 = (uint64_t **)sub_1000DC46C(a1, a2, &v11, &v10, a3);
  unint64_t v7 = *v6;
  if (!*v6)
  {
    unint64_t v8 = v6;
    unint64_t v7 = (uint64_t *)operator new(0x28uLL);
    void v7[4] = *a4;
    sub_100027200(a1, v11, v8, v7);
  }

  return v7;
}

uint64_t sub_1000DF5A0(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_100180280;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000DF608(_Unwind_Exception *a1)
{
}

uint64_t sub_1000DF61C(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_1001804A0;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000DF684(_Unwind_Exception *a1)
{
}

uint64_t sub_1000DF698(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_1001806C0;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000DF700(_Unwind_Exception *a1)
{
}

uint64_t sub_1000DF714(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_1001808E0;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000DF77C(_Unwind_Exception *a1)
{
}

uint64_t sub_1000DF790(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_100180B00;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000DF7F8(_Unwind_Exception *a1)
{
}

uint64_t sub_1000DF80C(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_100180D20;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000DF874(_Unwind_Exception *a1)
{
}

uint64_t sub_1000DF888(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_100181160;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000DF8F0(_Unwind_Exception *a1)
{
}

void sub_1000DF904(uint64_t a1@<X0>, unint64_t a2@<X1>, int a3@<W2>, unint64_t *a4@<X8>)
{
  unint64_t v50 = a2;
  unint64_t v7 = (std::mutex *)(a1 + 952);
  unint64_t v8 = (void *)(a1 + 936);
  unint64_t v9 = (unint64_t *)(a1 + 1184);
  uint64_t v10 = (unint64_t *)(a1 + 768);
  uint64_t v43 = (unint64_t *)(a1 + 104);
  uint64_t v44 = (std::condition_variable *)(a1 + 1016);
  int64_t v45 = (uint64_t **)(a1 + 928);
  while (2)
  {
    __lk.__m_ = v7;
    __lk.__owns_ = 1;
    std::mutex::lock(v7);
    if (a3)
    {
      uint64_t v11 = v50;
    }

    else
    {
      unint64_t v16 = (void *)*v8;
      if (!*v8) {
        goto LABEL_20;
      }
      uint64_t v11 = v50;
      unint64_t v17 = v8;
      do
      {
        unint64_t v18 = v16[4];
        BOOL v19 = v18 >= v50;
        if (v18 >= v50) {
          uint64_t v20 = v16;
        }
        else {
          uint64_t v20 = v16 + 1;
        }
        if (v19) {
          unint64_t v17 = v16;
        }
        unint64_t v16 = (void *)*v20;
      }

      while (*v20);
      if (v17 == v8 || v50 < v17[4] || (unint64_t *)v17[5] == v9)
      {
LABEL_20:
        unint64_t v51 = 0LL;
        *a4 = 0LL;
        do
          unint64_t v21 = __ldaxr((unint64_t *)&v51);
        while (__stlxr(0LL, (unint64_t *)&v51));
        atomic_store(v21, a4);
        a4[1] = (unint64_t)v8;
        sub_1000BB354((unint64_t *)&v51);
        goto LABEL_23;
      }
    }

    unint64_t v51 = (unint64_t *)v11;
    uint64_t v52 = v9;
    uint64_t v12 = sub_1000DB2B4(v45, (unint64_t *)&v51, (uint64_t *)&v51);
    uint64_t v13 = v12;
    if (v14)
    {
      unint64_t v51 = 0LL;
      *a4 = 0LL;
      do
        unint64_t v15 = __ldaxr((unint64_t *)&v51);
      while (__stlxr(0LL, (unint64_t *)&v51));
      atomic_store(v15, a4);
      a4[1] = (unint64_t)v12;
      sub_1000BB354((unint64_t *)&v51);
LABEL_23:
      int v22 = 1;
      goto LABEL_24;
    }

    unint64_t v48 = (unint64_t *)v12[5];
    if (v48 == v9)
    {
      unint64_t v28 = (void *)*v8;
      if (*v8)
      {
        unint64_t v29 = v50;
        uint64_t v30 = v8;
        while (1)
        {
          unint64_t v31 = v28[4];
          BOOL v32 = v31 >= v29;
          if (v31 >= v29) {
            uint64_t v33 = v28;
          }
          else {
            uint64_t v33 = v28 + 1;
          }
          if (v32) {
            uint64_t v30 = v28;
          }
          unint64_t v28 = (void *)*v33;
          if (!*v33)
          {
            if (v30 == v8) {
              break;
            }
            if (v29 < v30[4]) {
              break;
            }
            uint64_t v34 = (unint64_t *)v30[5];
            if (v34 != v9)
            {
              unint64_t v35 = v34[67];
              if (v35)
              {
                if (!*(_BYTE *)(v35 + 520)) {
                  break;
                }
              }
            }

            if (!*(_BYTE *)(a1 + 912)) {
              break;
            }
            std::condition_variable::wait(v44, &__lk);
            unint64_t v28 = (void *)*v8;
            uint64_t v30 = v8;
            if (!*v8) {
              break;
            }
          }
        }
      }

      int v22 = 0;
      goto LABEL_24;
    }

    sub_10003C718((uint64_t)&__lk);
    sub_1000E0110(&v47, v48 + 67);
    if (v47 && !*(_BYTE *)(v47 + 520))
    {
      uint64_t v23 = v50;
      if (*(void *)(v47 + 32) == v50)
      {
        *a4 = 0LL;
        do
          unint64_t v37 = __ldaxr(&v47);
        while (__stlxr(0LL, &v47));
        atomic_store(v37, a4);
        a4[1] = (unint64_t)v13;
        goto LABEL_84;
      }

      if (*(void *)(v47 + 32) == -1LL)
      {
        uint64_t v24 = v43;
        if ((a3 & 1) == 0)
        {
          unint64_t v51 = 0LL;
          *a4 = 0LL;
          do
            unint64_t v36 = __ldaxr((unint64_t *)&v51);
          while (__stlxr(0LL, (unint64_t *)&v51));
          goto LABEL_83;
        }

        goto LABEL_35;
      }
    }

    else
    {
      if (!a3)
      {
        unint64_t v51 = 0LL;
        *a4 = 0LL;
        do
          unint64_t v36 = __ldaxr((unint64_t *)&v51);
        while (__stlxr(0LL, (unint64_t *)&v51));
        goto LABEL_83;
      }

      uint64_t v23 = v50;
    }

    uint64_t v24 = v43;
LABEL_35:
    if (sub_1000DD3DC(a1, 0, v23, 1u) != -1)
    {
      do
        unint64_t v25 = __ldaxr(v10);
      while (__stlxr(v25 + 1, v10));
      v46.__m_ = (std::unique_lock<std::mutex>::mutex_type *)sub_100116890((unint64_t)v48);
      v46.__owns_ = 1;
      std::mutex::lock(v46.__m_);
      int64_t v26 = sub_100116950((unint64_t)v48);
      std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v54 = std::chrono::steady_clock::now().__d_.__rep_ + 200000000;
      unint64_t v51 = (unint64_t *)&v48;
      uint64_t v52 = &v47;
      uint64_t v53 = &v50;
      sub_1000E03A0((std::condition_variable *)v26, &v46, &v54, (uint64_t)&v51);
      do
        unint64_t v27 = __ldaxr(v10);
      while (__stlxr(v27 - 1, v10));
      if (v46.__owns_) {
        std::mutex::unlock(v46.__m_);
      }
      int v22 = 3;
      goto LABEL_85;
    }

    unint64_t v51 = 0LL;
    unint64_t v38 = atomic_load(v24);
    if (!v38) {
      goto LABEL_81;
    }
    while (1)
    {
      unint64_t v39 = __ldaxr(v24);
      if (v39 != v38)
      {
        __clrex();
        goto LABEL_71;
      }

      if (!__stlxr(v38 + 1, v24)) {
        break;
      }
LABEL_71:
      unint64_t v38 = v39;
      if (!v39) {
        goto LABEL_81;
      }
    }

    uint64_t v40 = *(unint64_t **)(a1 + 608);
    unint64_t v38 = (unint64_t)v24;
    if (v40)
    {
      do
        unint64_t v41 = __ldxr(v40);
      while (__stxr(v41 + 1, v40));
      *(void *)(a1 + 616) = v41;
      unint64_t v38 = (unint64_t)v24;
    }

void sub_1000DFD64( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::mutex *a12, char a13, int a14, unint64_t a15, uint64_t a16, std::mutex *a17, char a18)
{
  if (a18) {
    std::mutex::unlock(a17);
  }
  _Unwind_Resume(a1);
}

unint64_t *sub_1000DFDC4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t **a3@<X8>)
{
  unint64_t v13 = 0LL;
  unint64_t v6 = (std::mutex *)(a1 + 696);
  std::mutex::lock((std::mutex *)(a1 + 696));
  uint64_t v7 = *(void *)(a1 + 688);
  if (v7)
  {
    unint64_t v8 = *(void *)(a1 + 680);
    unint64_t v9 = *(unint64_t **)(*(void *)(*(void *)(a1 + 656) + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8LL)) + 8 * (v8 & 0x1FF));
    *(void *)(a1 + 68_Block_object_dispose((const void *)(v2 - 120), 8) = v7 - 1;
    *(void *)(a1 + 680) = v8 + 1;
    sub_1000DB5C4(a1 + 648, 1);
    sub_1000DFFF4(a1, v9, a2, v14);
    sub_1000C755C(&v13, v14);
    sub_1000BB354(v14);
  }

  else
  {
    unint64_t v9 = 0LL;
  }

  std::mutex::unlock(v6);
  unint64_t v10 = atomic_load((unint64_t *)(a1 + 784));
  if (v10 + v7 >= *(void *)(a1 + 640))
  {
    sub_1000DD3DC(a1, 0, 0LL, 0);
  }

  else
  {
    v14[0] = (unint64_t)_NSConcreteStackBlock;
    v14[1] = 0x40000000LL;
    void v14[2] = (unint64_t)sub_1000E0524;
    void v14[3] = (unint64_t)&unk_1001823D0;
    v14[4] = a1;
    sub_1000F96B0((dispatch_queue_t *)(a1 + 920), v14);
  }

  *a3 = v9;
  a3[1] = 0LL;
  do
    unint64_t v11 = __ldaxr(&v13);
  while (__stlxr(0LL, &v13));
  atomic_store(v11, (unint64_t *)a3 + 1);
  return sub_1000BB354(&v13);
}

void sub_1000DFF1C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9)
{
}

unint64_t sub_1000DFF50(void *a1)
{
  unint64_t v1 = atomic_load(a1 + 97);
  uint64_t v2 = a1[79];
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = 0LL;
  int v4 = 0;
  unint64_t v5 = 0LL;
  do
  {
    uint64_t v6 = a1[95];
    uint64_t v7 = *(void *)(v6 + 8 * v3);
    if (v7 && v1 - *(void *)(v7 + 520) != -1LL)
    {
      unint64_t v5 = *(void *)(v6 + 8 * v3);
      int v4 = v3;
    }

    ++v3;
  }

  while (v2 != v3);
  if (!v5) {
    return 0LL;
  }
  unint64_t v8 = (unint64_t *)(a1[95] + 8LL * v4);
  do
  {
    unint64_t v9 = __ldaxr(v8);
    if (v9 != v5)
    {
      __clrex();
      return 0LL;
    }
  }

  while (__stlxr(0LL, v8));
  return v5;
}

unint64_t *sub_1000DFFF4@<X0>( uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, unint64_t *a4@<X8>)
{
  uint64_t v7 = a2 + 1;
  unint64_t v17 = 0LL;
  unint64_t v8 = atomic_load(a2 + 1);
  if (!v8)
  {
LABEL_7:
    uint64_t v7 = 0LL;
    goto LABEL_11;
  }

  while (1)
  {
    unint64_t v9 = __ldaxr(v7);
    if (v9 != v8)
    {
      __clrex();
      goto LABEL_6;
    }

    if (!__stlxr(v8 + 1, v7)) {
      break;
    }
LABEL_6:
    unint64_t v8 = v9;
    if (!v9) {
      goto LABEL_7;
    }
  }

  unint64_t v10 = (unint64_t *)a2[64];
  if (v10)
  {
    do
      unint64_t v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
    a2[65] = v11;
  }

unint64_t *sub_1000E0110(unint64_t *a1, unint64_t *a2)
{
  *a1 = 0LL;
  uint64_t v3 = (unint64_t *)atomic_load(a2);
  if (!v3) {
    goto LABEL_9;
  }
  unint64_t v4 = atomic_load(v3);
  if (!v4) {
    goto LABEL_8;
  }
  while (1)
  {
    unint64_t v5 = __ldaxr(v3);
    if (v5 != v4)
    {
      __clrex();
      goto LABEL_7;
    }

    if (!__stlxr(v4 + 1, v3)) {
      break;
    }
LABEL_7:
    unint64_t v4 = v5;
    if (!v5) {
      goto LABEL_8;
    }
  }

  uint64_t v7 = (unint64_t *)v3[63];
  if (v7)
  {
    do
      unint64_t v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
    v3[64] = v8;
  }

  if (!sub_1000E01E0((uint64_t)v3))
  {
    do
      unint64_t v9 = __ldaxr(v3);
    while (__stlxr(v9 - 1, v3));
    if (v9 == 1)
    {
      uint64_t v10 = v3[4];
      v3[4] = -1LL;
      sub_1000BB394((uint64_t)v3, v10, 1u);
    }

BOOL sub_1000E01E0(uint64_t a1)
{
  uint64_t v2 = (unsigned int *)(a1 + 24);
  unsigned int v3 = atomic_load((unsigned int *)(a1 + 24));
  if (v3 == 2)
  {
    unint64_t v4 = atomic_load((unint64_t *)a1);
    return v4 > 1;
  }

  else
  {
    uint64_t v6 = (unint64_t *)(a1 + 8);
    do
      unint64_t v7 = __ldaxr(v6);
    while (__stlxr(v7 + 1, v6));
    unsigned int v8 = atomic_load(v2);
    if (v8 != 2 && !*(_BYTE *)(a1 + 520)) {
      sub_1000E028C(a1 + 24, 1u, 5u);
    }
    do
      unint64_t v9 = __ldaxr(v6);
    while (__stlxr(v9 - 1, v6));
    unint64_t v10 = atomic_load((unint64_t *)a1);
    if (v10 < 2)
    {
      return 0LL;
    }

    else
    {
      unsigned int v11 = atomic_load(v2);
      return v11 == 2;
    }
  }

BOOL sub_1000E028C(uint64_t a1, unsigned int a2, unsigned int a3)
{
  *(void *)&__int128 v4 = a1;
  *((void *)&v4 + 1) = __PAIR64__(a3, a2);
  uint64_t v5 = a1;
  __int128 v6 = v4;
  return sub_1000D5CB8((uint64_t)&v4, (uint64_t)&v5, 0LL);
}

unint64_t *sub_1000E02CC(unint64_t *a1, unint64_t *a2, int a3)
{
  unsigned int v3 = a2;
  *a1 = 0LL;
  if (!a2) {
    goto LABEL_9;
  }
  unint64_t v5 = atomic_load(a2);
  if (!v5) {
    goto LABEL_8;
  }
  while (1)
  {
    unint64_t v6 = __ldaxr(a2);
    if (v6 != v5)
    {
      __clrex();
      goto LABEL_7;
    }

    if (!__stlxr(v5 + 1, a2)) {
      break;
    }
LABEL_7:
    unint64_t v5 = v6;
    if (!v6) {
      goto LABEL_8;
    }
  }

  unsigned int v8 = (unint64_t *)a2[63];
  if (v8)
  {
    do
      unint64_t v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
    a2[64] = v9;
  }

  if (a3 && !sub_1000E01E0((uint64_t)a2))
  {
    do
      unint64_t v10 = __ldaxr(v3);
    while (__stlxr(v10 - 1, v3));
    if (v10 == 1)
    {
      uint64_t v11 = v3[4];
      v3[4] = -1LL;
      sub_1000BB394((uint64_t)v3, v11, 1u);
    }

BOOL sub_1000E03A0( std::condition_variable *a1, std::unique_lock<std::mutex> *a2, std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep *a3, uint64_t a4)
{
  do
  {
    if ((*(_DWORD *)(**(void **)a4 + 544LL) & 1) != 0) {
      return 1LL;
    }
    uint64_t v8 = *(void *)(a4 + 8);
    if (*(void *)v8)
    {
      if (!*(_BYTE *)(*(void *)v8 + 520LL) && *(void *)(*(void *)v8 + 32LL) == **(void **)(a4 + 16)) {
        return 1LL;
      }
    }

    if (*a3 <= std::chrono::steady_clock::now().__d_.__rep_) {
      break;
    }
    std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v9 = *a3;
    v10.__d_.__rep_ = v9 - std::chrono::steady_clock::now().__d_.__rep_;
    if (v10.__d_.__rep_ >= 1)
    {
      std::chrono::steady_clock::now();
      v11.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
      if (v11.__d_.__rep_)
      {
        if (v11.__d_.__rep_ < 1)
        {
          if ((unint64_t)v11.__d_.__rep_ < 0xFFDF3B645A1CAC09LL)
          {
            std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v12 = 0x8000000000000000LL;
            goto LABEL_17;
          }
        }

        else if ((unint64_t)v11.__d_.__rep_ > 0x20C49BA5E353F7LL)
        {
          std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v12 = 0x7FFFFFFFFFFFFFFFLL;
          goto LABEL_15;
        }

        std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v12 = 1000 * v11.__d_.__rep_;
      }

      else
      {
        std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v12 = 0LL;
      }

uint64_t sub_1000E0524(uint64_t a1)
{
  unint64_t v1 = *(void **)(a1 + 32);
  unint64_t v2 = sub_1000DFF50(v1);
  if (v2) {
    sub_1000E0568((uint64_t)v1, v2);
  }
  return sub_1000DD3DC((uint64_t)v1, 0, 0LL, 0);
}

void sub_1000E0568(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  unsigned int v3 = (std::mutex *)(a1 + 696);
  std::mutex::lock((std::mutex *)(a1 + 696));
  sub_1000E05C4((void *)(a1 + 648), &v4);
  std::mutex::unlock(v3);
}

void sub_1000E05B0(_Unwind_Exception *a1)
{
}

void sub_1000E05C4(void *a1, void *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    sub_1000E0648(a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = a1[4] + v7;
  }

  *(void *)(*(void *)(v5 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8LL)) + 8 * (v8 & 0x1FF)) = *a2;
  a1[5] = v7 + 1;
}

void sub_1000E0648(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_10001848C(v5, v33);
      unint64_t v35 = &v34[8 * (v33 >> 2)];
      unint64_t v37 = &v34[8 * v36];
      unint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        unint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)unint64_t v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_1000E0910( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

unint64_t *sub_1000E095C(uint64_t a1, uint64_t a2)
{
  BOOL v3 = (unint64_t *)(a1 + 8);
  sub_1000E0A4C(a1 + 8, a2);
  unint64_t v12 = 0LL;
  unint64_t v4 = atomic_load(v3);
  if (!v4) {
    goto LABEL_11;
  }
  while (1)
  {
    unint64_t v5 = __ldaxr(v3);
    if (v5 != v4)
    {
      __clrex();
      goto LABEL_6;
    }

    if (!__stlxr(v4 + 1, v3)) {
      break;
    }
LABEL_6:
    unint64_t v4 = v5;
    if (!v5) {
      goto LABEL_11;
    }
  }

  uint64_t v6 = *(unint64_t **)(a1 + 512);
  unint64_t v4 = (unint64_t)v3;
  if (v6)
  {
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
    *(void *)(a1 + 520) = v7;
    unint64_t v4 = (unint64_t)v3;
  }

uint64_t *sub_1000E0A4C(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + sub_1000114F0(v6 - 32) = a2;
  *(_BYTE *)(a1 + 520) = 0;
  atomic_store(1uLL, (unint64_t *)a1);
  atomic_store(0LL, (unint64_t *)(a1 + 8));
  atomic_store(0LL, (unint64_t *)(a1 + 16));
  __n128 result = sub_1000BB694((uint64_t *)(a1 + 40));
  unint64_t v4 = *(unint64_t **)(a1 + 504);
  if (v4)
  {
    do
      unint64_t v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
    *(void *)(a1 + 512) = v5;
  }

  atomic_store(1u, (unsigned int *)(a1 + 24));
  __dmb(0xBu);
  return result;
}

void sub_1000E0AB8( uint64_t a1, uint64_t a2, void *a3, unint64_t *a4, uint64_t *a5, unsigned __int8 *a6)
{
  *(void *)(a1 + 512) = **(void **)(a1 + 504);
  uint64_t v12 = a1 + 40;
  sub_1000BB694((uint64_t *)(a1 + 40));
  sub_1000E0BAC(v12, a2, a3, a4, a5, a6);
  *(_BYTE *)(a1 + 400) = 1;
  atomic_store(2u, (unsigned int *)(a1 + 24));
  sub_1000E0B84(a1);
}

void sub_1000E0B4C(void *a1)
{
  *(_BYTE *)(v1 + 520) = 1;
  sub_1000E0B84(v1);
  __cxa_rethrow();
}

void sub_1000E0B70(_Unwind_Exception *a1)
{
}

void sub_1000E0B84(uint64_t a1)
{
}

uint64_t sub_1000E0BAC( uint64_t a1, uint64_t a2, void *a3, unint64_t *a4, uint64_t *a5, unsigned __int8 *a6)
{
  unint64_t v7 = (std::__shared_weak_count *)a3[1];
  v13[0] = *a3;
  v13[1] = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }

  sub_1000BC54C(a1, a2, v13, *a4, *a5, *a6);
  if (v7)
  {
    unint64_t v10 = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

  return a1;
}

void sub_1000E0C40( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1000E0C54(uint64_t a1, uint64_t a2, void *a3, unint64_t *a4, uint64_t *a5)
{
  *(void *)(a1 + 512) = **(void **)(a1 + 504);
  uint64_t v10 = a1 + 40;
  sub_1000BB694((uint64_t *)(a1 + 40));
  sub_1000E0D10(v10, a2, a3, a4, a5);
  *(_BYTE *)(a1 + 400) = 1;
  atomic_store(2u, (unsigned int *)(a1 + 24));
  sub_1000E0B84(a1);
}

void sub_1000E0CD8(void *a1)
{
  *(_BYTE *)(v1 + 520) = 1;
  sub_1000E0B84(v1);
  __cxa_rethrow();
}

void sub_1000E0CFC(_Unwind_Exception *a1)
{
}

uint64_t sub_1000E0D10(uint64_t a1, uint64_t a2, void *a3, unint64_t *a4, uint64_t *a5)
{
  uint64_t v6 = (std::__shared_weak_count *)a3[1];
  v12[0] = *a3;
  v12[1] = v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      unint64_t v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }

  sub_1000BC54C(a1, a2, v12, *a4, *a5, 0);
  if (v6)
  {
    unint64_t v9 = (unint64_t *)&v6->__shared_owners_;
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

  return a1;
}

void sub_1000E0DA4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1000E0DB8(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_100181380;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000E0E20(_Unwind_Exception *a1)
{
}

uint64_t sub_1000E0E34(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_1001815A0;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000E0E9C(_Unwind_Exception *a1)
{
}

uint64_t sub_1000E0EB0(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_1001817C0;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000E0F18(_Unwind_Exception *a1)
{
}

uint64_t sub_1000E0F2C(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_1001819E0;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000E0F94(_Unwind_Exception *a1)
{
}

uint64_t sub_1000E0FA8(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = sub_1000E13AC(a1);
  *(void *)(v8 + 6sub_1000114F0(v6 - 32) = a2;
  *(void *)(v8 + 640) = a3;
  unint64_t v9 = (void *)(v8 + 648);
  *(_OWORD *)(v8 + 64_Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  *(_OWORD *)(v8 + 664) = 0u;
  *(_OWORD *)(v8 + 680) = 0u;
  *(void *)(v8 + 696) = 850045863LL;
  *(_OWORD *)(v8 + 704) = 0u;
  *(_OWORD *)(v8 + 720) = 0u;
  *(_OWORD *)(v8 + 736) = 0u;
  *(void *)(v8 + 752) = 0LL;
  *(_OWORD *)(v8 + 76_Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  *(_OWORD *)(v8 + 784) = 0u;
  *(void *)(v8 + 800) = 850045863LL;
  *(_OWORD *)(v8 + 80_Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  *(_OWORD *)(v8 + 824) = 0u;
  *(_OWORD *)(v8 + 840) = 0u;
  *(void *)(v8 + 856) = 0LL;
  *(void *)(v8 + 864) = 1018212795LL;
  *(void *)(v8 + 904) = 0LL;
  *(_OWORD *)(v8 + 88_Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  *(_BYTE *)(v8 + 912) = 1;
  *(_OWORD *)(v8 + 872) = 0u;
  uint64_t v16 = (dispatch_object_t *)(v8 + 920);
  sub_1000F969C(v8 + 920, "dealloc_queue");
  *(void *)(a1 + 944) = 0LL;
  *(void *)(a1 + 936) = 0LL;
  *(void *)(a1 + 92_Block_object_dispose((const void *)(v2 - 120), 8) = a1 + 936;
  *(void *)(a1 + 952) = 850045863LL;
  *(_OWORD *)(a1 + 960) = 0u;
  *(_OWORD *)(a1 + 976) = 0u;
  *(_OWORD *)(a1 + 992) = 0u;
  *(void *)(a1 + 100_Block_object_dispose((const void *)(v2 - 120), 8) = 0LL;
  *(void *)(a1 + 1016) = 1018212795LL;
  *(_OWORD *)(a1 + 1024) = 0u;
  *(_OWORD *)(a1 + 1040) = 0u;
  *(void *)(a1 + 1056) = 0LL;
  *(void *)(a1 + 1064) = 850045863LL;
  *(_OWORD *)(a1 + 1072) = 0u;
  *(_OWORD *)(a1 + 108_Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  *(_OWORD *)(a1 + 1104) = 0u;
  *(void *)(a1 + 1120) = 0LL;
  *(void *)(a1 + 112_Block_object_dispose((const void *)(v2 - 120), 8) = a1 + 1128;
  *(void *)(a1 + 1136) = a1 + 1128;
  *(void *)(a1 + 1144) = 0LL;
  sub_1000118C0(a1 + 1152, a4);
  sub_1000E1768(a1 + 1184, a1);
  *(void *)(a1 + 1736) = &off_1001826B0;
  *(void *)(a1 + 1744) = a1;
  *(void *)(a1 + 1760) = a1 + 1736;
  *(void *)(a1 + 176_Block_object_dispose((const void *)(v2 - 120), 8) = &off_100182740;
  *(void *)(a1 + 1776) = a1;
  *(void *)(a1 + 1792) = a1 + 1768;
  if (a2 >> 61) {
    size_t v10 = -1LL;
  }
  else {
    size_t v10 = 8 * a2;
  }
  unint64_t v11 = operator new[](v10);
  uint64_t v12 = v11;
  if (a2) {
    bzero(v11, 8 * a2);
  }
  *(void *)(a1 + 760) = v12;
  sub_1000F9750(v16, 3);
  if (a2)
  {
    uint64_t v13 = 0LL;
    do
    {
      BOOL v14 = operator new(0x228uLL);
      sub_1000E1768((uint64_t)v14, a1);
      uint64_t v17 = v14;
      sub_1000E12F0(v9, &v17);
      atomic_store(0LL, (unint64_t *)(*(void *)(a1 + 760) + 8 * v13++));
    }

    while (a2 != v13);
  }

  return a1;
}

void sub_1000E11B4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, std::condition_variable *a11, void *a12, dispatch_object_s **a13)
{
  uint64_t v18 = *(void **)(v13 + 1176);
  if (v18 == a12)
  {
    uint64_t v19 = 4LL;
    uint64_t v18 = a12;
  }

  else
  {
    if (!v18) {
      goto LABEL_6;
    }
    uint64_t v19 = 5LL;
  }

  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_6:
  sub_1000DD7C8(v16);
  std::mutex::~mutex((std::mutex *)(v13 + 1064));
  std::condition_variable::~condition_variable((std::condition_variable *)(v13 + 1016));
  std::mutex::~mutex((std::mutex *)(v13 + 952));
  sub_100026AC4(v13 + 928, *a10);
  sub_1000F95F0(a13);
  std::condition_variable::~condition_variable(a11);
  std::mutex::~mutex(v15);
  std::mutex::~mutex((std::mutex *)(v13 + 696));
  sub_1000BBD1C(v14);
  sub_1000DD828((void *)v13);
  _Unwind_Resume(a1);
}

uint64_t sub_1000E12F0(void *a1, void *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[4];
  uint64_t v8 = a1[5];
  unint64_t v9 = v8 + v7;
  if (v6 == v8 + v7)
  {
    sub_1000E0648(a1);
    uint64_t v7 = a1[4];
    uint64_t v8 = a1[5];
    uint64_t v5 = a1[1];
    unint64_t v9 = v7 + v8;
  }

  *(void *)(*(void *)(v5 + ((v9 >> 6) & 0x3FFFFFFFFFFFFF8LL)) + 8 * (v9 & 0x1FF)) = *a2;
  a1[5] = v8 + 1;
  unint64_t v10 = v7 + v8 + 1;
  uint64_t v11 = a1[1];
  uint64_t v12 = (void *)(v11 + 8 * (v10 >> 9));
  uint64_t v13 = *v12 + 8 * (v10 & 0x1FF);
  if (a1[2] == v11) {
    uint64_t v13 = 0LL;
  }
  if (v13 == *v12) {
    uint64_t v13 = *(v12 - 1) + 4096LL;
  }
  return v13 - 8;
}

uint64_t sub_1000E13AC(uint64_t a1)
{
  *(void *)(a1 + sub_1000114F0(v6 - 32) = &off_100182490;
  *(void *)(a1 + 56) = a1 + 32;
  *(void *)a1 = &off_100182400;
  *(void *)(a1 + 64) = &off_100182520;
  *(void *)(a1 + 24) = a1;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = a1 + 64;
  *(void *)(a1 + 96) = 0LL;
  uint64_t v2 = sub_1000E1654(a1 + 104, a1, a1 + 32, a1 + 64, a1 + 96);
  sub_1000E0A4C(v2, -1LL);
  atomic_store(0, (unsigned int *)(a1 + 128));
  *(_BYTE *)(a1 + 624) = 1;
  return a1;
}

void sub_1000E1450(_Unwind_Exception *a1)
{
  uint64_t v4 = *(void **)(v1 + 88);
  if (v4 == v2)
  {
    uint64_t v5 = 4LL;
  }

  else
  {
    if (!v4) {
      goto LABEL_6;
    }
    uint64_t v5 = 5LL;
    uint64_t v2 = *(void **)(v1 + 88);
  }

  (*(void (**)(void *))(*v2 + 8 * v5))(v2);
LABEL_6:
  sub_10011BC94();
  _Unwind_Resume(a1);
}

void *sub_1000E14A8()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &off_100182400;
  return result;
}

void sub_1000E14CC(uint64_t a1, void *a2)
{
  *a2 = &off_100182400;
}

uint64_t sub_1000E14E8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000E1524()
{
}

void *sub_1000E1538()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &off_100182490;
  return result;
}

void sub_1000E155C(uint64_t a1, void *a2)
{
  *a2 = &off_100182490;
}

uint64_t sub_1000E1578(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000E15B4()
{
}

void *sub_1000E15C8()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &off_100182520;
  return result;
}

void sub_1000E15EC(uint64_t a1, void *a2)
{
  *a2 = &off_100182520;
}

uint64_t sub_1000E1604()
{
  return 0LL;
}

uint64_t sub_1000E160C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000E1648()
{
}

uint64_t sub_1000E1654(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = 0LL;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + sub_1000114F0(v6 - 32) = -1LL;
  *(_BYTE *)(a1 + 40) = 0;
  *(_BYTE *)(a1 + 400) = 0;
  sub_1000118C0(a1 + 408, a2);
  sub_1000118C0(a1 + 440, a3);
  sub_1000118C0(a1 + 472, a4);
  *(void *)(a1 + 504) = a5;
  *(void *)(a1 + 512) = 0LL;
  *(_BYTE *)(a1 + 520) = 0;
  return a1;
}

void sub_1000E16E8(_Unwind_Exception *a1)
{
  uint64_t v6 = *(void **)(v2 + 464);
  if (v6 == v4)
  {
    uint64_t v7 = 4LL;
  }

  else
  {
    if (!v6) {
      goto LABEL_6;
    }
    uint64_t v7 = 5LL;
    uint64_t v4 = *(void **)(v2 + 464);
  }

  (*(void (**)(void *))(*v4 + 8 * v7))(v4);
LABEL_6:
  uint64_t v8 = *(void **)(v2 + 432);
  if (v8 == v3)
  {
    uint64_t v9 = 4LL;
    uint64_t v8 = v3;
  }

  else
  {
    if (!v8) {
      goto LABEL_11;
    }
    uint64_t v9 = 5LL;
  }

  (*(void (**)(void))(*v8 + 8 * v9))();
LABEL_11:
  sub_1000DD768(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000E1768(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a2;
  v10[0] = &off_1001825B0;
  v10[1] = a1;
  uint64_t v11 = v10;
  v8[0] = &off_100182630;
  v8[1] = a1;
  uint64_t v9 = v8;
  sub_1000E1654(a1 + 8, (uint64_t)v10, (uint64_t)v8, a2 + 1152, a2 + 776);
  BOOL v3 = v9;
  if (v9 == v8)
  {
    uint64_t v4 = 4LL;
    BOOL v3 = v8;
  }

  else
  {
    if (!v9) {
      goto LABEL_6;
    }
    uint64_t v4 = 5LL;
  }

  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  uint64_t v5 = v11;
  if (v11 == v10)
  {
    uint64_t v6 = 4LL;
    uint64_t v5 = v10;
    goto LABEL_10;
  }

  if (v11)
  {
    uint64_t v6 = 5LL;
LABEL_10:
    (*(void (**)(void))(*v5 + 8 * v6))();
  }

  *(void *)(a1 + 536) = 0LL;
  *(_DWORD *)(a1 + 544) = 0;
  return a1;
}

void sub_1000E1860( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  uint64_t v19 = a13;
  if (a13 == v17)
  {
    uint64_t v20 = 4LL;
    uint64_t v19 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v20 = 5LL;
  }

  (*(void (**)(void))(*(void *)v19 + 8 * v20))();
LABEL_6:
  uint64_t v21 = a17;
  if (a17 == &a14)
  {
    uint64_t v22 = 4LL;
    uint64_t v21 = &a14;
  }

  else
  {
    if (!a17) {
      goto LABEL_11;
    }
    uint64_t v22 = 5LL;
  }

  (*(void (**)(void))(*(void *)v21 + 8 * v22))();
LABEL_11:
  _Unwind_Resume(exception_object);
}

void *sub_1000E18D0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &off_1001825B0;
  result[1] = v3;
  return result;
}

uint64_t sub_1000E1904(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_1001825B0;
  a2[1] = v2;
  return result;
}

uint64_t sub_1000E1920(uint64_t a1, uint64_t a2, uint64_t *a3, int *a4)
{
  return sub_1000BB650(**(void **)(a1 + 8) + 1736LL, *(void *)(a1 + 8), *a3, *a4);
}

uint64_t sub_1000E1938(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000E1974()
{
}

void *sub_1000E1988(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &off_100182630;
  result[1] = v3;
  return result;
}

uint64_t sub_1000E19BC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_100182630;
  a2[1] = v2;
  return result;
}

uint64_t sub_1000E19D8(uint64_t a1)
{
  return sub_1000E1A28((uint64_t **)(a1 + 8));
}

uint64_t sub_1000E19E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000E1A1C()
{
}

uint64_t sub_1000E1A28(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v4 = *a1;
  uint64_t v2 = *(void *)(v1 + 1792);
  if (!v2) {
    sub_100016D94();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t **))(*(void *)v2 + 48LL))(v2, &v4);
}

void *sub_1000E1A70(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &off_1001826B0;
  result[1] = v3;
  return result;
}

uint64_t sub_1000E1AA4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_1001826B0;
  a2[1] = v2;
  return result;
}

void sub_1000E1AC0(uint64_t a1, unint64_t *a2, unint64_t *a3, _DWORD *a4)
{
}

uint64_t sub_1000E1AD4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000E1B10()
{
}

void sub_1000E1B1C(uint64_t a1, unint64_t a2, unint64_t a3, char a4)
{
  if ((*(_DWORD *)(a2 + 544) & 1) == 0)
  {
    uint64_t v7 = (unsigned int *)(a2 + 544);
    if ((a4 & 3) == 1LL)
    {
      uint64_t v8 = (char *)(a1 + 1064);
      std::mutex::lock((std::mutex *)(a1 + 1064));
      uint64_t v9 = operator new(0x20uLL);
      v9[2] = a2;
      void v9[3] = a3;
      uint64_t v10 = *(void *)(a1 + 1128);
      void *v9 = v10;
      v9[1] = a1 + 1128;
      *(void *)(v10 + _Block_object_dispose((const void *)(v2 - 120), 8) = v9;
      *(void *)(a1 + 112_Block_object_dispose((const void *)(v2 - 120), 8) = v9;
      ++*(void *)(a1 + 1144);
      do
        unsigned int v11 = __ldaxr(v7);
      while (__stlxr(v11 | 4, v7));
      uint64_t v12 = sub_100116890(a2);
      std::mutex::lock((std::mutex *)v12);
      uint64_t v13 = sub_100116950(a2);
      std::condition_variable::notify_all((std::condition_variable *)v13);
      std::mutex::unlock((std::mutex *)v12);
LABEL_20:
      std::mutex::unlock((std::mutex *)v8);
      return;
    }

    sub_1000E1CC8(a1, a3);
    sub_1000BB354((unint64_t *)(a2 + 536));
    do
      unsigned int v14 = __ldaxr(v7);
    while (__stlxr(v14 | 1, v7));
    if ((v14 & 2) == 0) {
      sub_1000E0568(a1, a2);
    }
    uint64_t v15 = (unint64_t *)(a1 + 784);
    do
    {
      unint64_t v16 = __ldaxr(v15);
      unint64_t v17 = v16 - 1;
    }

    while (__stlxr(v17, v15));
    if (!v17)
    {
      if (atomic_load((unint64_t *)(a1 + 792)))
      {
        std::mutex::lock((std::mutex *)(a1 + 800));
        std::mutex::unlock((std::mutex *)(a1 + 800));
      }
    }

    uint64_t v20 = (unint64_t *)(a1 + 768);
    if (atomic_load(v20))
    {
      uint64_t v8 = sub_100116890(a2);
      std::mutex::lock((std::mutex *)v8);
      if (atomic_load(v20))
      {
        uint64_t v23 = sub_100116950(a2);
        std::condition_variable::notify_all((std::condition_variable *)v23);
      }

      goto LABEL_20;
    }
  }

void sub_1000E1C9C(_Unwind_Exception *a1)
{
}

void sub_1000E1CC8(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = a2;
  uint64_t v3 = (std::mutex *)(a1 + 952);
  std::mutex::lock((std::mutex *)(a1 + 952));
  sub_10003F484(a1 + 928, &v4);
  std::condition_variable::notify_all((std::condition_variable *)(a1 + 1016));
  std::mutex::unlock(v3);
}

void sub_1000E1D18(_Unwind_Exception *a1)
{
}

void *sub_1000E1D34(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &off_100182740;
  result[1] = v3;
  return result;
}

uint64_t sub_1000E1D68(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_100182740;
  a2[1] = v2;
  return result;
}

void sub_1000E1D84(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
}

uint64_t sub_1000E1D90(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000E1DCC()
{
}

void sub_1000E1DD8(uint64_t a1, unint64_t a2, unint64_t *a3)
{
  uint64_t v3 = *(void *)(a1 + 632);
  if (v3 >= 1)
  {
    uint64_t v6 = 0LL;
    uint64_t v7 = *(void *)(a1 + 760);
    unint64_t v8 = v7 + 8 * v3;
    while (!(v7 + v6) || *(void *)(v7 + v6) != a2)
    {
      v6 += 8LL;
      if (v7 + v6 >= v8) {
        return;
      }
    }

    if ((v6 & 0x8000000000000000LL) == 0)
    {
      uint64_t v9 = (unint64_t *)(v7 + v6);
      while (1)
      {
        unint64_t v10 = __ldaxr(v9);
        if (v10 != a2) {
          break;
        }
        if (!__stlxr(0LL, v9))
        {
          sub_1000DD14C(a1, a2, 1uLL, a3);
          sub_1000E0568(a1, a2);
          return;
        }
      }

      __clrex();
    }
  }

uint64_t sub_1000E1E80(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = sub_1000E2278(a1);
  *(void *)(v8 + 456) = a2;
  *(void *)(v8 + 464) = a3;
  uint64_t v9 = (void *)(v8 + 472);
  *(_OWORD *)(v8 + 472) = 0u;
  *(_OWORD *)(v8 + 48_Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  *(_OWORD *)(v8 + 504) = 0u;
  *(void *)(v8 + 520) = 850045863LL;
  *(_OWORD *)(v8 + 52_Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  *(_OWORD *)(v8 + 544) = 0u;
  *(_OWORD *)(v8 + 560) = 0u;
  *(void *)(v8 + 576) = 0LL;
  *(_OWORD *)(v8 + 592) = 0u;
  *(_OWORD *)(v8 + 60_Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  *(void *)(v8 + 624) = 850045863LL;
  *(_OWORD *)(v8 + 6sub_1000114F0(v6 - 32) = 0u;
  *(_OWORD *)(v8 + 64_Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  *(_OWORD *)(v8 + 664) = 0u;
  *(void *)(v8 + 680) = 0LL;
  *(void *)(v8 + 68_Block_object_dispose((const void *)(v2 - 120), 8) = 1018212795LL;
  *(void *)(v8 + 72_Block_object_dispose((const void *)(v2 - 120), 8) = 0LL;
  *(_OWORD *)(v8 + 712) = 0u;
  *(_BYTE *)(v8 + 736) = 1;
  *(_OWORD *)(v8 + 696) = 0u;
  unint64_t v16 = (dispatch_object_t *)(v8 + 744);
  sub_1000F969C(v8 + 744, "dealloc_queue");
  *(void *)(a1 + 76_Block_object_dispose((const void *)(v2 - 120), 8) = 0LL;
  *(void *)(a1 + 760) = 0LL;
  *(void *)(a1 + 752) = a1 + 760;
  *(void *)(a1 + 776) = 850045863LL;
  *(_OWORD *)(a1 + 784) = 0u;
  *(_OWORD *)(a1 + 800) = 0u;
  *(_OWORD *)(a1 + 816) = 0u;
  *(void *)(a1 + 8sub_1000114F0(v6 - 32) = 0LL;
  *(void *)(a1 + 840) = 1018212795LL;
  *(_OWORD *)(a1 + 84_Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  *(_OWORD *)(a1 + 864) = 0u;
  *(void *)(a1 + 880) = 0LL;
  *(void *)(a1 + 88_Block_object_dispose((const void *)(v2 - 120), 8) = 850045863LL;
  *(_OWORD *)(a1 + 896) = 0u;
  *(_OWORD *)(a1 + 912) = 0u;
  *(_OWORD *)(a1 + 92_Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  *(void *)(a1 + 944) = 0LL;
  *(void *)(a1 + 952) = a1 + 952;
  *(void *)(a1 + 960) = a1 + 952;
  *(void *)(a1 + 96_Block_object_dispose((const void *)(v2 - 120), 8) = 0LL;
  sub_1000118C0(a1 + 976, a4);
  sub_1000E2634(a1 + 1008, a1);
  *(void *)(a1 + 1384) = &off_100182A80;
  *(void *)(a1 + 1392) = a1;
  *(void *)(a1 + 140_Block_object_dispose((const void *)(v2 - 120), 8) = a1 + 1384;
  *(void *)(a1 + 1416) = &off_100182B10;
  *(void *)(a1 + 1424) = a1;
  *(void *)(a1 + 1440) = a1 + 1416;
  if (a2 >> 61) {
    size_t v10 = -1LL;
  }
  else {
    size_t v10 = 8 * a2;
  }
  unsigned int v11 = operator new[](v10);
  uint64_t v12 = v11;
  if (a2) {
    bzero(v11, 8 * a2);
  }
  *(void *)(a1 + 584) = v12;
  sub_1000F9750(v16, 3);
  if (a2)
  {
    uint64_t v13 = 0LL;
    do
    {
      unsigned int v14 = operator new(0x178uLL);
      sub_1000E2634((uint64_t)v14, a1);
      unint64_t v17 = v14;
      sub_1000E21BC(v9, &v17);
      atomic_store(0LL, (unint64_t *)(*(void *)(a1 + 584) + 8 * v13++));
    }

    while (a2 != v13);
  }

  return a1;
}

void sub_1000E2080( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, std::condition_variable *a11, void *a12, dispatch_object_s **a13)
{
  uint64_t v18 = *(void **)(v13 + 1000);
  if (v18 == a12)
  {
    uint64_t v19 = 4LL;
    uint64_t v18 = a12;
  }

  else
  {
    if (!v18) {
      goto LABEL_6;
    }
    uint64_t v19 = 5LL;
  }

  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_6:
  sub_1000DD7C8(v16);
  std::mutex::~mutex((std::mutex *)(v13 + 888));
  std::condition_variable::~condition_variable((std::condition_variable *)(v13 + 840));
  std::mutex::~mutex((std::mutex *)(v13 + 776));
  sub_100026AC4(v13 + 752, *a10);
  sub_1000F95F0(a13);
  std::condition_variable::~condition_variable(a11);
  std::mutex::~mutex(v15);
  std::mutex::~mutex((std::mutex *)(v13 + 520));
  sub_1000BBD1C(v14);
  sub_1000DDCAC((void *)v13);
  _Unwind_Resume(a1);
}

uint64_t sub_1000E21BC(void *a1, void *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[4];
  uint64_t v8 = a1[5];
  unint64_t v9 = v8 + v7;
  if (v6 == v8 + v7)
  {
    sub_1000DB744(a1);
    uint64_t v7 = a1[4];
    uint64_t v8 = a1[5];
    uint64_t v5 = a1[1];
    unint64_t v9 = v7 + v8;
  }

  *(void *)(*(void *)(v5 + ((v9 >> 6) & 0x3FFFFFFFFFFFFF8LL)) + 8 * (v9 & 0x1FF)) = *a2;
  a1[5] = v8 + 1;
  unint64_t v10 = v7 + v8 + 1;
  uint64_t v11 = a1[1];
  uint64_t v12 = (void *)(v11 + 8 * (v10 >> 9));
  uint64_t v13 = *v12 + 8 * (v10 & 0x1FF);
  if (a1[2] == v11) {
    uint64_t v13 = 0LL;
  }
  if (v13 == *v12) {
    uint64_t v13 = *(v12 - 1) + 4096LL;
  }
  return v13 - 8;
}

uint64_t sub_1000E2278(uint64_t a1)
{
  *(void *)(a1 + sub_1000114F0(v6 - 32) = &off_100182860;
  *(void *)(a1 + 56) = a1 + 32;
  *(void *)a1 = &off_1001827D0;
  *(void *)(a1 + 64) = &off_1001828F0;
  *(void *)(a1 + 24) = a1;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = a1 + 64;
  *(void *)(a1 + 96) = 0LL;
  uint64_t v2 = sub_1000E2520(a1 + 104, a1, a1 + 32, a1 + 64, a1 + 96);
  sub_1000DC36C(v2, -1LL);
  atomic_store(0, (unsigned int *)(a1 + 128));
  *(_BYTE *)(a1 + 44_Block_object_dispose((const void *)(v2 - 120), 8) = 1;
  return a1;
}

void sub_1000E231C(_Unwind_Exception *a1)
{
  uint64_t v4 = *(void **)(v1 + 88);
  if (v4 == v2)
  {
    uint64_t v5 = 4LL;
  }

  else
  {
    if (!v4) {
      goto LABEL_6;
    }
    uint64_t v5 = 5LL;
    uint64_t v2 = *(void **)(v1 + 88);
  }

  (*(void (**)(void *))(*v2 + 8 * v5))(v2);
LABEL_6:
  sub_10011BC94();
  _Unwind_Resume(a1);
}

void *sub_1000E2374()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &off_1001827D0;
  return result;
}

void sub_1000E2398(uint64_t a1, void *a2)
{
  *a2 = &off_1001827D0;
}

uint64_t sub_1000E23B4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000E23F0()
{
}

void *sub_1000E2404()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &off_100182860;
  return result;
}

void sub_1000E2428(uint64_t a1, void *a2)
{
  *a2 = &off_100182860;
}

uint64_t sub_1000E2444(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000E2480()
{
}

void *sub_1000E2494()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &off_1001828F0;
  return result;
}

void sub_1000E24B8(uint64_t a1, void *a2)
{
  *a2 = &off_1001828F0;
}

uint64_t sub_1000E24D0()
{
  return 0LL;
}

uint64_t sub_1000E24D8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000E2514()
{
}

uint64_t sub_1000E2520(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = 0LL;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + sub_1000114F0(v6 - 32) = -1LL;
  *(_BYTE *)(a1 + 40) = 0;
  *(_BYTE *)(a1 + 224) = 0;
  sub_1000118C0(a1 + 232, a2);
  sub_1000118C0(a1 + 264, a3);
  sub_1000118C0(a1 + 296, a4);
  *(void *)(a1 + 32_Block_object_dispose((const void *)(v2 - 120), 8) = a5;
  *(void *)(a1 + 336) = 0LL;
  *(_BYTE *)(a1 + 344) = 0;
  return a1;
}

void sub_1000E25B4(_Unwind_Exception *a1)
{
  uint64_t v6 = *(void **)(v2 + 288);
  if (v6 == v4)
  {
    uint64_t v7 = 4LL;
  }

  else
  {
    if (!v6) {
      goto LABEL_6;
    }
    uint64_t v7 = 5LL;
    uint64_t v4 = *(void **)(v2 + 288);
  }

  (*(void (**)(void *))(*v4 + 8 * v7))(v4);
LABEL_6:
  uint64_t v8 = *(void **)(v2 + 256);
  if (v8 == v3)
  {
    uint64_t v9 = 4LL;
    uint64_t v8 = v3;
  }

  else
  {
    if (!v8) {
      goto LABEL_11;
    }
    uint64_t v9 = 5LL;
  }

  (*(void (**)(void))(*v8 + 8 * v9))();
LABEL_11:
  sub_1000DDC68(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000E2634(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a2;
  v10[0] = &off_100182980;
  v10[1] = a1;
  uint64_t v11 = v10;
  v8[0] = &off_100182A00;
  v8[1] = a1;
  uint64_t v9 = v8;
  sub_1000E2520(a1 + 8, (uint64_t)v10, (uint64_t)v8, a2 + 976, a2 + 600);
  uint64_t v3 = v9;
  if (v9 == v8)
  {
    uint64_t v4 = 4LL;
    uint64_t v3 = v8;
  }

  else
  {
    if (!v9) {
      goto LABEL_6;
    }
    uint64_t v4 = 5LL;
  }

  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  uint64_t v5 = v11;
  if (v11 == v10)
  {
    uint64_t v6 = 4LL;
    uint64_t v5 = v10;
    goto LABEL_10;
  }

  if (v11)
  {
    uint64_t v6 = 5LL;
LABEL_10:
    (*(void (**)(void))(*v5 + 8 * v6))();
  }

  *(void *)(a1 + 360) = 0LL;
  *(_DWORD *)(a1 + 36_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
  return a1;
}

void sub_1000E272C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  uint64_t v19 = a13;
  if (a13 == v17)
  {
    uint64_t v20 = 4LL;
    uint64_t v19 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v20 = 5LL;
  }

  (*(void (**)(void))(*(void *)v19 + 8 * v20))();
LABEL_6:
  uint64_t v21 = a17;
  if (a17 == &a14)
  {
    uint64_t v22 = 4LL;
    uint64_t v21 = &a14;
  }

  else
  {
    if (!a17) {
      goto LABEL_11;
    }
    uint64_t v22 = 5LL;
  }

  (*(void (**)(void))(*(void *)v21 + 8 * v22))();
LABEL_11:
  _Unwind_Resume(exception_object);
}

void *sub_1000E279C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &off_100182980;
  result[1] = v3;
  return result;
}

uint64_t sub_1000E27D0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_100182980;
  a2[1] = v2;
  return result;
}

uint64_t sub_1000E27EC(uint64_t a1, uint64_t a2, uint64_t *a3, int *a4)
{
  return sub_1000BB650(**(void **)(a1 + 8) + 1384LL, *(void *)(a1 + 8), *a3, *a4);
}

uint64_t sub_1000E2804(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000E2840()
{
}

void *sub_1000E2854(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &off_100182A00;
  result[1] = v3;
  return result;
}

uint64_t sub_1000E2888(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_100182A00;
  a2[1] = v2;
  return result;
}

uint64_t sub_1000E28A4(uint64_t a1)
{
  return sub_1000E28F4((uint64_t **)(a1 + 8));
}

uint64_t sub_1000E28AC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000E28E8()
{
}

uint64_t sub_1000E28F4(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v4 = *a1;
  uint64_t v2 = *(void *)(v1 + 1440);
  if (!v2) {
    sub_100016D94();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t **))(*(void *)v2 + 48LL))(v2, &v4);
}

void *sub_1000E293C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &off_100182A80;
  result[1] = v3;
  return result;
}

uint64_t sub_1000E2970(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_100182A80;
  a2[1] = v2;
  return result;
}

void sub_1000E298C(uint64_t a1, unint64_t *a2, unint64_t *a3, _DWORD *a4)
{
}

uint64_t sub_1000E29A0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000E29DC()
{
}

void sub_1000E29E8(uint64_t a1, unint64_t a2, unint64_t a3, char a4)
{
  if ((*(_DWORD *)(a2 + 368) & 1) == 0)
  {
    uint64_t v7 = (unsigned int *)(a2 + 368);
    if ((a4 & 3) == 1LL)
    {
      uint64_t v8 = (char *)(a1 + 888);
      std::mutex::lock((std::mutex *)(a1 + 888));
      uint64_t v9 = operator new(0x20uLL);
      v9[2] = a2;
      void v9[3] = a3;
      uint64_t v10 = *(void *)(a1 + 952);
      void *v9 = v10;
      v9[1] = a1 + 952;
      *(void *)(v10 + _Block_object_dispose((const void *)(v2 - 120), 8) = v9;
      *(void *)(a1 + 952) = v9;
      ++*(void *)(a1 + 968);
      do
        unsigned int v11 = __ldaxr(v7);
      while (__stlxr(v11 | 4, v7));
      uint64_t v12 = sub_100116890(a2);
      std::mutex::lock((std::mutex *)v12);
      uint64_t v13 = sub_100116950(a2);
      std::condition_variable::notify_all((std::condition_variable *)v13);
      std::mutex::unlock((std::mutex *)v12);
LABEL_20:
      std::mutex::unlock((std::mutex *)v8);
      return;
    }

    sub_1000E2B94(a1, a3);
    sub_1000BBEA0((unint64_t *)(a2 + 360));
    do
      unsigned int v14 = __ldaxr(v7);
    while (__stlxr(v14 | 1, v7));
    if ((v14 & 2) == 0) {
      sub_1000DB664(a1, a2);
    }
    uint64_t v15 = (unint64_t *)(a1 + 608);
    do
    {
      unint64_t v16 = __ldaxr(v15);
      unint64_t v17 = v16 - 1;
    }

    while (__stlxr(v17, v15));
    if (!v17)
    {
      if (atomic_load((unint64_t *)(a1 + 616)))
      {
        std::mutex::lock((std::mutex *)(a1 + 624));
        std::mutex::unlock((std::mutex *)(a1 + 624));
      }
    }

    uint64_t v20 = (unint64_t *)(a1 + 592);
    if (atomic_load(v20))
    {
      uint64_t v8 = sub_100116890(a2);
      std::mutex::lock((std::mutex *)v8);
      if (atomic_load(v20))
      {
        uint64_t v23 = sub_100116950(a2);
        std::condition_variable::notify_all((std::condition_variable *)v23);
      }

      goto LABEL_20;
    }
  }

void sub_1000E2B68(_Unwind_Exception *a1)
{
}

void sub_1000E2B94(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = a2;
  uint64_t v3 = (std::mutex *)(a1 + 776);
  std::mutex::lock((std::mutex *)(a1 + 776));
  sub_10003F484(a1 + 752, &v4);
  std::condition_variable::notify_all((std::condition_variable *)(a1 + 840));
  std::mutex::unlock(v3);
}

void sub_1000E2BE4(_Unwind_Exception *a1)
{
}

void *sub_1000E2C00(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &off_100182B10;
  result[1] = v3;
  return result;
}

uint64_t sub_1000E2C34(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_100182B10;
  a2[1] = v2;
  return result;
}

void sub_1000E2C50(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
}

uint64_t sub_1000E2C5C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000E2C98()
{
}

void sub_1000E2CA4(uint64_t a1, unint64_t a2, unint64_t *a3)
{
  uint64_t v3 = *(void *)(a1 + 456);
  if (v3 >= 1)
  {
    uint64_t v6 = 0LL;
    uint64_t v7 = *(void *)(a1 + 584);
    unint64_t v8 = v7 + 8 * v3;
    while (!(v7 + v6) || *(void *)(v7 + v6) != a2)
    {
      v6 += 8LL;
      if (v7 + v6 >= v8) {
        return;
      }
    }

    if ((v6 & 0x8000000000000000LL) == 0)
    {
      uint64_t v9 = (unint64_t *)(v7 + v6);
      while (1)
      {
        unint64_t v10 = __ldaxr(v9);
        if (v10 != a2) {
          break;
        }
        if (!__stlxr(0LL, v9))
        {
          sub_1000DBEB4(a1, a2, 1uLL, a3);
          sub_1000DB664(a1, a2);
          return;
        }
      }

      __clrex();
    }
  }

void *sub_1000E2D54(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &off_100182BA0;
  result[1] = v3;
  return result;
}

uint64_t sub_1000E2D88(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_100182BA0;
  a2[1] = v2;
  return result;
}

uint64_t sub_1000E2DA4(uint64_t a1, uint64_t a2)
{
  return sub_1000E2DF4((uint64_t *)(a1 + 8), a2);
}

uint64_t sub_1000E2DAC(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_1000E2DE8()
{
  return &off_100182C00;
}

uint64_t sub_1000E2DF4(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = *(void *)(*a1 + 24);
  v12[0] = off_10017E998;
  v12[1] = v4;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(v4 + 16) + 72LL))(&v13);
  if (*(_BYTE *)(a2 + 113)) {
    sub_1000BE844(v3, (uint64_t)v12, *(void *)(a2 + 8) / *(void *)(v3 + 80), 0, 0, &v11);
  }
  else {
    unint64_t v11 = 0LL;
  }
  if (v11 && !*(_BYTE *)(v11 + 520))
  {
    if (*(_BYTE *)(v11 + 400)) {
      uint64_t v5 = v11 + 40;
    }
    else {
      uint64_t v5 = 0LL;
    }
  }

  else
  {
    uint64_t v5 = 0LL;
  }

  uint64_t v6 = sub_1000C702C(a2, (uint64_t)v12, v5, *(unsigned int *)(v3 + 20));
  sub_1000BB354(&v11);
  v12[0] = off_10017E998;
  uint64_t v7 = v14;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      unint64_t v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

  return v6;
}

void sub_1000E2F10(_Unwind_Exception *a1)
{
}

uint64_t sub_1000E2F40(uint64_t a1)
{
  uint64_t v7 = a1;
  uint64_t v1 = std::__thread_local_data();
  uint64_t v2 = *(const void **)v7;
  *(void *)uint64_t v7 = 0LL;
  pthread_setspecific(v1->__key_, v2);
  uint64_t v3 = *(void *)(v7 + 8);
  sub_1000118C0((uint64_t)v8, v7 + 16);
  sub_1000BE114(v3, (uint64_t)v8);
  uint64_t v4 = v9;
  if (v9 == v8)
  {
    uint64_t v5 = 4LL;
    uint64_t v4 = v8;
    goto LABEL_5;
  }

  if (v9)
  {
    uint64_t v5 = 5LL;
LABEL_5:
    (*(void (**)(void))(*v4 + 8 * v5))();
  }

  sub_1000E304C(&v7);
  return 0LL;
}

void sub_1000E3004( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  uint64_t v15 = a13;
  if (a13 == v13)
  {
    uint64_t v16 = 4LL;
    uint64_t v15 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v16 = 5LL;
  }

  (*(void (**)(void))(*(void *)v15 + 8 * v16))();
LABEL_6:
  sub_1000E304C(&a9);
  _Unwind_Resume(a1);
}

uint64_t *sub_1000E304C(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0LL;
  if (v2)
  {
    uint64_t v3 = *(void **)(v2 + 40);
    if (v3 == (void *)(v2 + 16))
    {
      uint64_t v4 = 4LL;
      uint64_t v3 = (void *)(v2 + 16);
    }

    else
    {
      if (!v3)
      {
LABEL_7:
        sub_1000E30BC((std::__thread_struct **)v2, 0LL);
        operator delete((void *)v2);
        return a1;
      }

      uint64_t v4 = 5LL;
    }

    (*(void (**)(void))(*v3 + 8 * v4))();
    goto LABEL_7;
  }

  return a1;
}

void sub_1000E30BC(std::__thread_struct **a1, std::__thread_struct *a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    std::__thread_struct::~__thread_struct(v3);
    operator delete(v4);
  }

_WORD *sub_1000E30E8(_WORD *result, int a2)
{
  *__n128 result = 0;
  if (a2)
  {
    __int16 v2 = a2;
    exception = __cxa_allocate_exception(0x28uLL);
    exception[2] = "invalid value";
    exception[3] = "value validator";
    void *exception = &off_1001780C8;
    exception[1] = "total_segments_t";
    *((_WORD *)exception + 16) = v2;
  }

  return result;
}

uint64_t sub_1000E3154(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_1001820B0;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000E31BC(_Unwind_Exception *a1)
{
}

uint64_t sub_1000E31D0(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_100181E90;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000E3238(_Unwind_Exception *a1)
{
}

uint64_t sub_1000E324C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v14[0] = a3;
  v14[1] = a4;
  uint64_t result = sub_1000BF4D8(a1, a2, (uint64_t)v12);
  while (v12[0] != v13[3] || v12[1] != v13[4])
  {
    v7[0] = (*(void *)(*(void *)(v13[0] + 56LL) + 16LL * v13[1] + 8) & 0x7FFFFFFFFFFFFFLL)
          * *(unsigned int *)(*(void *)(v13[0] + 8LL) + 20LL);
    if (v7[0]) {
      sub_1000E3354((uint64_t)v14, v7);
    }
    sub_1000BF55C(a1, v13, (uint64_t)v7);
    while (v7[0] != v10 || v7[1] != v11)
    {
      uint64_t v6 = (*(void *)(*(void *)(v8 + 56) + 16 * v9 + 8) & 0x7FFFFFFFFFFFFFLL)
         * *(unsigned int *)(*(void *)(v8 + 8) + 20LL);
      if (v6) {
        sub_1000E3354((uint64_t)v14, (unint64_t *)&v6);
      }
      sub_1000BC498((uint64_t)v7);
    }

    uint64_t result = sub_1000BC378((uint64_t)v12);
  }

  return result;
}

uint64_t sub_1000E3354(uint64_t a1, unint64_t *a2)
{
  uint64_t v3 = sub_1000DF51C(*(uint64_t ***)a1, *(void **)(a1 + 8), a2, (uint64_t *)a2);
  *(void *)(a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = v3;
  char v4 = (uint64_t *)v3[1];
  if (v4)
  {
    do
    {
      __int128 v5 = v4;
      char v4 = (uint64_t *)*v4;
    }

    while (v4);
  }

  else
  {
    do
    {
      __int128 v5 = (uint64_t *)v3[2];
      BOOL v6 = *v5 == (void)v3;
      uint64_t v3 = v5;
    }

    while (!v6);
  }

  *(void *)(a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = v5;
  return a1;
}

void sub_1000E33BC(uint64_t a1, uint64_t *a2, __int128 *a3, uint64_t a4)
{
  uint64_t v4 = a2[1];
  uint64_t v5 = *((void *)a3 + 1);
  if (v4 != v5)
  {
    uint64_t v10 = *a2;
    uint64_t v11 = a2[2];
    uint64_t v12 = v4 + 1;
    if (v4 + 1 != v5)
    {
      unint64_t v13 = v10 + v11 * v12;
      uint64_t v14 = a2[1];
      do
      {
        if (v10 + v14 * v11 < v13)
        {
          uint64_t v4 = v12;
          uint64_t v14 = v12;
        }

        ++v12;
        v13 += v11;
      }

      while (v5 != v12);
    }

    std::mutex::lock((std::mutex *)(a1 + 8));
    __int128 v18 = *(_OWORD *)a2;
    uint64_t v19 = a2[2];
    __int128 v16 = *a3;
    uint64_t v17 = *((void *)a3 + 2);
    sub_1000E34D0((uint64_t *)(a1 + 72), &v18, (uint64_t)&v16);
    unint64_t v15 = v10 + v4 * v11;
    if (v15 >= *(void *)(a1 + 96)) {
      *(void *)(a1 + 96) = *(void *)a1 + v15;
    }
    sub_1000C9F3C((void *)a1, a4);
    std::mutex::unlock((std::mutex *)(a1 + 8));
  }

void sub_1000E34BC(_Unwind_Exception *a1)
{
}

uint64_t *sub_1000E34D0(uint64_t *result, void *a2, uint64_t a3)
{
  uint64_t v3 = a2[1];
  if (v3 != *(void *)(a3 + 8))
  {
    BOOL v6 = (uint64_t **)result;
    uint64_t v7 = result + 1;
    do
    {
      uint64_t v8 = *a2 + a2[2] * v3;
      uint64_t result = sub_1000DF51C(v6, v7, (unint64_t *)&v8, &v8);
      uint64_t v3 = a2[1] + 1LL;
      a2[1] = v3;
    }

    while (v3 != *(void *)(a3 + 8));
  }

  return result;
}

uint64_t ****sub_1000E355C(uint64_t ****result)
{
  uint64_t v1 = **result;
  __int16 v2 = *v1;
  if (*((_DWORD *)*v1 + 11) != 1)
  {
    v2[8] = sub_100118D8C();
    v2[9] = v3;
    uint64_t result = (uint64_t ****)sub_1000CA778((uint64_t)(v2 + 4), v2[2]);
    *(_DWORD *)v1[1] = (_DWORD)result;
  }

  return result;
}

uint64_t sub_1000E35AC(uint64_t a1, uint64_t (*a2)(void))
{
  return a2();
}

uint64_t sub_1000E35B4@<X0>(void *a1@<X1>, uint64_t a2@<X8>)
{
  return (*(uint64_t (**)(void *))(*a1 + 8 * a2))(a1);
}

  ;
}

void sub_1000E3690(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000E37AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000E3918( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10)
{
  uint64_t v11 = a10;
  a10 = 0LL;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8LL))(v11);
  }
  _Unwind_Resume(a1);
}

AAByteStream *sub_1000E39D4@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  int v3 = (*(uint64_t (**)(void))(*(void *)*a1 + 176LL))(*a1);
  if (v3 < 0)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    BOOL v6 = (void *)sub_100004870((uint64_t)exception, (uint64_t)"AEAHelper: Invalid file descriptor.", 0x16u);
  }

  AEAContext v7 = AAFileStreamOpenWithFD(v3, 0);
  sub_1000E6458(&v8, &v7);
  sub_1000E652C(&v7, &v8);
  sub_1000E67A4(a2, &v7);
  sub_1000E6530(&v7);
  return sub_1000E645C(&v8);
}

void sub_1000E3A78( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, AEAContext a9, AAByteStream a10)
{
}

void sub_1000E3A9C(AEAAuthData *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = operator new[](0x20uLL);
  _OWORD *v4 = 0u;
  v4[1] = 0u;
  v23[0] = 0LL;
  v23[1] = 0LL;
  uint64_t v24 = 0LL;
  char v25 = 1;
  sub_100004CB0(__p, "encryption_key");
  sub_1000E3F2C(a1, (uint64_t)__p, (uint64_t)&__dst);
  if (v27 < 0) {
    operator delete(__p[0]);
  }
  if (!v30)
  {
    sub_100004CB0(v21, "com.apple.wkms.fcs-key-url");
    sub_1000E3F2C(a1, (uint64_t)v21, (uint64_t)&__dst);
    int v9 = *(unsigned __int8 *)(sub_1000E41F4((uint64_t)v23, &__dst) + 24);
    if (v30 && SHIBYTE(v29) < 0) {
      operator delete((void *)__dst);
    }
    if (v22 < 0)
    {
      operator delete(v21[0]);
      if (v9) {
        goto LABEL_21;
      }
    }

    else if (v9)
    {
LABEL_21:
      if (SHIBYTE(v24) < 0)
      {
        sub_100040504(&__dst, v23[0], (unint64_t)v23[1]);
      }

      else
      {
        __int128 __dst = *(_OWORD *)v23;
        uint64_t v29 = v24;
      }

      *(_OWORD *)a2 = __dst;
      *(void *)(a2 + 16) = v29;
      *(void *)(a2 + 24) = a1;
      int v11 = 3;
LABEL_46:
      *(_DWORD *)(a2 + sub_1000114F0(v6 - 32) = v11;
      goto LABEL_47;
    }

    sub_100004CB0(v19, "saksKey");
    sub_1000E3F2C(a1, (uint64_t)v19, (uint64_t)&__dst);
    int v10 = *(unsigned __int8 *)(sub_1000E41F4((uint64_t)v23, &__dst) + 24);
    if (v30 && SHIBYTE(v29) < 0) {
      operator delete((void *)__dst);
    }
    if (v20 < 0)
    {
      operator delete(v19[0]);
      if (v10) {
        goto LABEL_29;
      }
    }

    else if (v10)
    {
LABEL_29:
      if (SHIBYTE(v24) < 0)
      {
        sub_100040504(&__dst, v23[0], (unint64_t)v23[1]);
      }

      else
      {
        __int128 __dst = *(_OWORD *)v23;
        uint64_t v29 = v24;
      }

      *(_OWORD *)a2 = __dst;
      *(void *)(a2 + 16) = v29;
      int v11 = 1;
      goto LABEL_46;
    }

    sub_100004CB0(v17, "com.apple.knox.url");
    sub_1000E3F2C(a1, (uint64_t)v17, (uint64_t)&__dst);
    int v12 = *(unsigned __int8 *)(sub_1000E41F4((uint64_t)v23, &__dst) + 24);
    if (v30 && SHIBYTE(v29) < 0) {
      operator delete((void *)__dst);
    }
    if (v18 < 0) {
      operator delete(v17[0]);
    }
    if (!v12)
    {
      exception = __cxa_allocate_exception(0x40uLL);
      void *exception = &off_100189E78;
      __int128 v16 = std::generic_category();
      exception[1] = 22LL;
      exception[2] = v16;
      *((_BYTE *)exception + 24) = 0;
      *((_BYTE *)exception + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
      exception[7] = "Missing Expected AUTH DATA in AEA.";
    }

    if (SHIBYTE(v24) < 0)
    {
      sub_100040504(&__dst, v23[0], (unint64_t)v23[1]);
    }

    else
    {
      __int128 __dst = *(_OWORD *)v23;
      uint64_t v29 = v24;
    }

    *(_OWORD *)a2 = __dst;
    *(void *)(a2 + 16) = v29;
    int v11 = 2;
    goto LABEL_46;
  }

  if (v29 >= 0) {
    p_dst = (const char *)&__dst;
  }
  else {
    p_dst = (const char *)__dst;
  }
  if (strlen(p_dst) != 64)
  {
    AEAContext v7 = "Key is not 32 bytes size.";
LABEL_54:
    unint64_t v13 = __cxa_allocate_exception(0x40uLL);
    void *v13 = &off_100189E78;
    uint64_t v14 = std::generic_category();
    v13[1] = 22LL;
    void v13[2] = v14;
    *((_BYTE *)v13 + 24) = 0;
    *((_BYTE *)v13 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
    v13[7] = v7;
  }

  uint64_t v6 = 0LL;
  char v32 = 0;
  AEAContext v7 = "Key is not hexadecimal number.";
  do
  {
    *(_WORD *)__str = *(_WORD *)&p_dst[2 * v6];
    char v8 = strtol(__str, 0LL, 16);
    *((_BYTE *)v4 + v6) = v8;
    ++v6;
  }

  while (v6 != 32);
  if (v30 && SHIBYTE(v29) < 0) {
    operator delete((void *)__dst);
  }
  *(void *)a2 = v4;
  *(_DWORD *)(a2 + sub_1000114F0(v6 - 32) = 0;
  uint64_t v4 = 0LL;
LABEL_47:
  if (v25 && SHIBYTE(v24) < 0) {
    operator delete(v23[0]);
  }
  if (v4) {
    operator delete[](v4);
  }
}

void sub_1000E3E74( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, uint64_t a21, uint64_t a22, int a23, __int16 a24, char a25, char a26, void *__p, uint64_t a28, int a29, __int16 a30, char a31, char a32, char a33, int a34, __int16 a35, char a36, char a37, uint64_t a38, int a39, __int16 a40, char a41, char a42)
{
  if (a33)
  {
    if (a32 < 0) {
      operator delete(__p);
    }
  }

  operator delete[](v42);
  _Unwind_Resume(a1);
}

uint64_t *sub_1000E3F2C@<X0>(AEAAuthData *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = (char *)valloc(0x800uLL);
  if (!v6)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    uint64_t v23 = std::bad_alloc::bad_alloc(exception);
  }

  __s = (char *)&off_100182C20;
  p_s = &__s;
  __s2 = v6;
  sub_1000172D0((uint64_t)&v31, (uint64_t)&__s);
  AEAContext v7 = p_s;
  if (p_s == &__s)
  {
    uint64_t v8 = 4LL;
    AEAContext v7 = &__s;
  }

  else
  {
    if (!p_s) {
      goto LABEL_7;
    }
    uint64_t v8 = 5LL;
  }

  (*(void (**)(void))&(*v7)[8 * v8])();
LABEL_7:
  int v9 = sub_1000E67D4(a1);
  if (!v9)
  {
LABEL_15:
    uint64_t v14 = std::generic_category();
    uint64_t v15 = 22LL;
    goto LABEL_16;
  }

  uint32_t v10 = 0;
  int v11 = __s2;
  while (1)
  {
    bzero(v11, 0x800uLL);
    if (sub_1000E67DC(a1, v10, 0x800uLL, v11, 0LL, 0LL, 0LL, &v26))
    {
      uint64_t v14 = std::generic_category();
      *(_DWORD *)a3 = 1;
      goto LABEL_18;
    }

    if (*(char *)(a2 + 23) < 0)
    {
      unint64_t v13 = *(const char **)a2;
      size_t v12 = *(void *)(a2 + 8);
    }

    else
    {
      size_t v12 = *(unsigned __int8 *)(a2 + 23);
      unint64_t v13 = (const char *)a2;
    }

    int v11 = __s2;
    if (!strncmp(v13, __s2, v12)) {
      break;
    }
    if (v9 == ++v10) {
      goto LABEL_15;
    }
  }

  if (v26 < 0x100000)
  {
    uint64_t v17 = (char *)valloc(v26 + 1);
    if (!v17)
    {
      uint64_t v24 = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
      char v25 = std::bad_alloc::bad_alloc(v24);
    }

    v32[0] = &off_100182C20;
    unint64_t v33 = v32;
    __s = v17;
    sub_1000172D0((uint64_t)&v28, (uint64_t)v32);
    char v18 = v33;
    if (v33 == v32)
    {
      uint64_t v19 = 4LL;
      char v18 = v32;
    }

    else
    {
      if (!v33)
      {
LABEL_28:
        bzero(__s, v26 + 1);
        if (sub_1000E67DC(a1, v10, 0x800uLL, __s2, 0LL, v26, (uint8_t *)__s, 0LL))
        {
          char v20 = std::generic_category();
          char v21 = 0;
          *(_DWORD *)a3 = 1;
          *(void *)(a3 + _Block_object_dispose((const void *)(v2 - 120), 8) = v20;
        }

        else
        {
          sub_100004CB0((void *)a3, __s);
          char v21 = 1;
        }

        *(_BYTE *)(a3 + 24) = v21;
        sub_100016DE0((uint64_t *)&__s);
        return sub_100016DE0((uint64_t *)&__s2);
      }

      uint64_t v19 = 5LL;
    }

    (*(void (**)(void))(*v18 + 8 * v19))();
    goto LABEL_28;
  }

  uint64_t v14 = std::generic_category();
  uint64_t v15 = 84LL;
LABEL_16:
  *(void *)a3 = v15;
LABEL_18:
  *(void *)(a3 + _Block_object_dispose((const void *)(v2 - 120), 8) = v14;
  *(_BYTE *)(a3 + 24) = 0;
  return sub_100016DE0((uint64_t *)&__s2);
}

void sub_1000E41C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  sub_100016DE0((uint64_t *)va);
  sub_100016DE0((uint64_t *)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000E41F4(uint64_t a1, __int128 *a2)
{
  if (*(_BYTE *)(a1 + 24))
  {
    int v4 = *(char *)(a1 + 23);
    if (*((_BYTE *)a2 + 24))
    {
      if (v4 < 0) {
        operator delete(*(void **)a1);
      }
      __int128 v5 = *a2;
      *(void *)(a1 + 16) = *((void *)a2 + 2);
      *(_OWORD *)a1 = v5;
      *((_BYTE *)a2 + 23) = 0;
      *(_BYTE *)a2 = 0;
    }

    else
    {
      if (v4 < 0) {
        operator delete(*(void **)a1);
      }
      *(_OWORD *)a1 = *a2;
      *(_BYTE *)(a1 + 24) = 0;
    }
  }

  else if (*((_BYTE *)a2 + 24))
  {
    __int128 v6 = *a2;
    *(void *)(a1 + 16) = *((void *)a2 + 2);
    *(_OWORD *)a1 = v6;
    *((void *)a2 + 1) = 0LL;
    *((void *)a2 + 2) = 0LL;
    *(void *)a2 = 0LL;
    *(_BYTE *)(a1 + 24) = 1;
  }

  else
  {
    *(_OWORD *)a1 = *a2;
  }

  return a1;
}

AEAAuthData *sub_1000E42A0(AEAAuthData *a1, void *a2)
{
  return a1;
}

void sub_1000E42D8(_Unwind_Exception *a1)
{
}

void *sub_1000E42F8()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &off_100182C20;
  return result;
}

void sub_1000E431C(uint64_t a1, void *a2)
{
  *a2 = &off_100182C20;
}

void sub_1000E4334(uint64_t a1, void **a2)
{
}

uint64_t sub_1000E433C(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_1000E4378()
{
  return &off_100182C80;
}

uint64_t sub_1000E4384(uint64_t a1)
{
  (*(void (**)(uint64_t (**__return_ptr)()))(*(void *)a1 + 72LL))(v4);
  uint64_t v1 = sub_100037420()[2];
  else {
    unsigned int v2 = v5;
  }
  if (v5) {
    return v2;
  }
  else {
    return v1;
  }
}

uint64_t sub_1000E43D4(uint64_t a1)
{
  (*(void (**)(unint64_t *__return_ptr))(*(void *)a1 + 72LL))(v6);
  unint64_t v2 = v6[0];
  (*(void (**)(uint64_t (**__return_ptr)(), uint64_t))(*(void *)a1 + 72LL))(v7, a1);
  unint64_t v3 = (unint64_t)sub_100037420()[2];
  if (v8 >= v3) {
    int v4 = v3;
  }
  else {
    int v4 = v8;
  }
  if (v8) {
    LODWORD(v3) = v4;
  }
  else {
    unint64_t v3 = v2;
  }
  if (v3 <= 0x1000) {
    return 4096LL;
  }
  else {
    return v3;
  }
}

void sub_1000E4460()
{
  exception = __cxa_allocate_exception(0x40uLL);
  uint64_t v1 = (void *)sub_100004870((uint64_t)exception, (uint64_t)"User data is not supported in this image format", 0x2Du);
}

void sub_1000E4494()
{
  exception = __cxa_allocate_exception(0x40uLL);
  uint64_t v1 = (void *)sub_100004870((uint64_t)exception, (uint64_t)"User data is not supported in this image format", 0x2Du);
}

void *sub_1000E44C8(void *a1, uint64_t a2)
{
  int v4 = *(unsigned __int8 *)(a2 + 16);
  if (*(_BYTE *)(a2 + 16))
  {
    if (v4 == 3)
    {
      if (*(void *)(a2 + 8) >= *(void *)a2)
      {
LABEL_4:
        if ((v4 & 2) != 0) {
          unint64_t v5 = "[";
        }
        else {
          unint64_t v5 = "(";
        }
        sub_100004CB0(&v26, v5);
        if ((v28 & 0x80u) == 0) {
          __int128 v6 = &v26;
        }
        else {
          __int128 v6 = v26;
        }
        if ((v28 & 0x80u) == 0) {
          uint64_t v7 = v28;
        }
        else {
          uint64_t v7 = v27;
        }
        unint64_t v8 = sub_100004E4C(a1, (uint64_t)v6, v7);
        int v9 = (void *)std::ostream::operator<<(v8, *(void *)a2);
        uint32_t v10 = sub_100004E4C(v9, (uint64_t)",", 1LL);
        int v11 = (void *)std::ostream::operator<<(v10, *(void *)(a2 + 8));
        if ((*(_BYTE *)(a2 + 16) & 1) != 0) {
          size_t v12 = "]";
        }
        else {
          size_t v12 = ")";
        }
        sub_100004CB0(&__p, v12);
        if ((v25 & 0x80u) == 0) {
          p_p = &__p;
        }
        else {
          p_p = __p;
        }
        if ((v25 & 0x80u) == 0) {
          uint64_t v14 = v25;
        }
        else {
          uint64_t v14 = v24;
        }
        goto LABEL_45;
      }
    }

    else if (*(void *)a2 < *(void *)(a2 + 8))
    {
      goto LABEL_4;
    }
  }

  else
  {
    unint64_t v15 = *(void *)(a2 + 8);
    if (*(void *)a2 < v15 && *(void *)a2 + 1LL < v15) {
      goto LABEL_4;
    }
  }

  if ((v4 & 2) != 0) {
    uint64_t v17 = "[";
  }
  else {
    uint64_t v17 = "(";
  }
  sub_100004CB0(&v26, v17);
  if ((v28 & 0x80u) == 0) {
    char v18 = &v26;
  }
  else {
    char v18 = v26;
  }
  if ((v28 & 0x80u) == 0) {
    uint64_t v19 = v28;
  }
  else {
    uint64_t v19 = v27;
  }
  int v11 = sub_100004E4C(a1, (uint64_t)v18, v19);
  if ((*(_BYTE *)(a2 + 16) & 1) != 0) {
    char v20 = "]";
  }
  else {
    char v20 = ")";
  }
  sub_100004CB0(&__p, v20);
  if ((v25 & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = __p;
  }
  if ((v25 & 0x80u) == 0) {
    uint64_t v14 = v25;
  }
  else {
    uint64_t v14 = v24;
  }
LABEL_45:
  char v21 = sub_100004E4C(v11, (uint64_t)p_p, v14);
  return v21;
}

void sub_1000E46A4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000E46E8(uint64_t a1, void *a2)
{
  __int128 v4 = *(_OWORD *)(a2 + 1);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 3);
  *(_OWORD *)(a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = v4;
  *(_DWORD *)(a1 + 40) = *((_DWORD *)a2 + 10);
  return a1;
}

BOOL sub_1000E4738(uint64_t a1, uint64_t a2)
{
  BOOL result = sub_1000E4778(*(void *)a1, *(void *)a2);
  if (result) {
    return *(_DWORD *)(a1 + 40) == *(_DWORD *)(a2 + 40);
  }
  return result;
}

BOOL sub_1000E4778(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a2 + 8);
  if (*(void *)v2 != *(void *)v3) {
    return 0LL;
  }
  BOOL result = sub_10005EA1C((unint64_t *)(v2 + 8), (unint64_t *)(v3 + 8));
  if (result)
  {
    if (*(_DWORD *)(v2 + 48) == *(_DWORD *)(v3 + 48)) {
      return *(void *)(a1 + 40) == *(void *)(a2 + 40);
    }
    return 0LL;
  }

  return result;
}

BOOL sub_1000E47F0(uint64_t a1, uint64_t a2)
{
  return !sub_1000E4778(*(void *)a1, *(void *)a2) || *(_DWORD *)(a1 + 40) != *(_DWORD *)(a2 + 40);
}

void *sub_1000E4838@<X0>(_DWORD *a1@<X0>, uint64_t a2@<X8>)
{
  BOOL result = *(void **)a1;
  unint64_t v5 = result[5];
  unint64_t v6 = result[3];
  *(void *)a2 = v5;
  *(void *)(a2 + _Block_object_dispose((const void *)(v2 - 120), 8) = v6;
  *(_BYTE *)(a2 + 16) = 2;
  *(_DWORD *)(a2 + 24) = 3;
  if ((*(_BYTE *)(*(void *)result[1] + 8LL) & 1) != 0)
  {
    BOOL result = (void *)sub_1000B866C();
    if ((_DWORD)result)
    {
      *(void *)uint64_t v7 = "DiskImage::const_extents_iterator_t::make_val() const";
      *(void *)&v7[8] = 45LL;
      *(_DWORD *)&v7[16] = 2;
      sub_100012984(v8, (__int128 *)v7);
      sub_100004E4C(&v9, (uint64_t)"Disk image is terminated, skipping ...", 38LL);
      std::ostream::~ostream(&v9, off_100166570);
      sub_100016084((uint64_t)v8);
      return (void *)std::ios::~ios(&v10);
    }
  }

  else if (v5 < v6 && a1[8] != 3)
  {
    BOOL result = (*(void *(**)(_BYTE *__return_ptr))*result)(v8);
    if (*(_DWORD *)&v8[24] != 3 && (a1[10] & (1 << v8[24])) == 0)
    {
      do
      {
        BOOL result = *(void **)a1;
        if (*(void *)(*(void *)a1 + 40LL) >= (unint64_t)(*(_BYTE *)(*(void *)a1 + 32LL) & 1)
                                                + *(void *)(*(void *)a1 + 24LL))
          break;
        result[5] = (v8[16] & 1) + *(void *)&v8[8];
        BOOL result = (*(void *(**)(_BYTE *__return_ptr))*result)(v7);
        *(_OWORD *)&v8[12] = *(_OWORD *)&v7[12];
        *(_OWORD *)unint64_t v8 = *(_OWORD *)v7;
        if (*(_DWORD *)&v7[24] == 3) {
          break;
        }
      }

      while ((a1[10] & (1 << v7[24])) == 0);
    }

    *(_OWORD *)a2 = *(_OWORD *)v8;
    *(_OWORD *)(a2 + 12) = *(_OWORD *)&v8[12];
  }

  return result;
}

void sub_1000E49CC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    uint64_t v15 = *(void *)(*(void *)v14 + 24LL);
    *(void *)uint64_t v13 = *(void *)(*(void *)v14 + 40LL);
    *(void *)(v13 + _Block_object_dispose((const void *)(v2 - 120), 8) = v15;
    *(_BYTE *)(v13 + 16) = 2;
    *(_DWORD *)(v13 + 24) = 3;
    __cxa_end_catch();
    JUMPOUT(0x1000E49B8LL);
  }

  _Unwind_Resume(a1);
}

uint64_t *sub_1000E4A20(uint64_t *a1)
{
  uint64_t v2 = *a1;
  unint64_t v3 = (a1[3] & 1) + a1[2];
  *(void *)(v2 + 40) = v3;
  if (v3 < (unint64_t)(*(_BYTE *)(v2 + 32) & 1) + *(void *)(v2 + 24))
  {
    sub_1000E4838(a1, (uint64_t)v5);
    *(_OWORD *)(a1 + 1) = v5[0];
    *(_OWORD *)((char *)a1 + 20) = *(_OWORD *)((char *)v5 + 12);
  }

  return a1;
}

uint64_t *sub_1000E4A94@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  (*(void (**)(void *__return_ptr))(*(void *)*a1 + 8LL))((void *)a2);
  *(_OWORD *)(a2 + _Block_object_dispose((const void *)(v2 - 120), 8) = *(_OWORD *)(a1 + 1);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 3);
  *(_DWORD *)(a2 + 40) = *((_DWORD *)a1 + 10);
  return sub_1000E4A20(a1);
}

void sub_1000E4AE8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *v1;
  uint64_t *v1 = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24LL))(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000E4B0C(uint64_t a1, uint64_t a2)
{
  __int128 v4 = *(_OWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 24) = *(_BYTE *)(a2 + 24);
  *(_OWORD *)(a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = v4;
  *(_DWORD *)(a1 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = *(_DWORD *)(a2 + 48);
  uint64_t v5 = *(void *)(a2 + 32);
  *(void *)(a2 + sub_1000114F0(v6 - 32) = 0LL;
  uint64_t v6 = *(void *)(a1 + 32);
  *(void *)(a1 + sub_1000114F0(v6 - 32) = v5;
  if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40LL))(v6);
    uint64_t v5 = *(void *)(a1 + 32);
  }

  *(void *)(a1 + 40) = v5;
  sub_100017334((void *)(a1 + 56), a2 + 56);
  return a1;
}

uint64_t sub_1000E4B80@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = qword_1001985E0;
  *(void *)a2 = qword_1001985E0;
  *(void *)(a2 + _Block_object_dispose((const void *)(v2 - 120), 8) = v4;
  *(_BYTE *)(a2 + 16) = 2;
  *(_DWORD *)(a2 + 24) = 0;
  sub_1000506D8(a1, (uint64_t)v12);
  sub_10005080C(a1, (uint64_t)v10);
  while (!sub_1000E4778(v12[0], v10[0]) || v13 != v11)
  {
    sub_1000E4A94(v12, (uint64_t)&v8);
    *(_OWORD *)a2 = v9[0];
    *(_OWORD *)(a2 + 12) = *(_OWORD *)((char *)v9 + 12);
    uint64_t v5 = v8;
    uint64_t v8 = 0LL;
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 24LL))(v5);
    }
  }

  uint64_t v6 = v10[0];
  v10[0] = 0LL;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 24LL))(v6);
  }
  uint64_t result = v12[0];
  v12[0] = 0LL;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 24LL))(result);
  }
  return result;
}

void sub_1000E4C64( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  uint64_t v17 = *(void *)(v15 - 64);
  *(void *)(v15 - 64) = 0LL;
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 24LL))(v17);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1000E4CAC(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000E5BC8((uint64_t)a1, a2);
  *a1 = off_100182CD0;
  a1[45] = &off_100182DD0;
  a1[46] = &off_100182DF8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_100182CD0;
  a1[45] = off_100182D58;
  a1[46] = off_100182D80;
  return a1;
}

void sub_1000E4D30(_Unwind_Exception *a1)
{
}

uint64_t sub_1000E4D54(uint64_t a1)
{
  return a1;
}

uint64_t sub_1000E4D94(mach_port_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  else {
    uint64_t v7 = -(int)a4;
  }
  input[0] = a3;
  input[1] = v7;
  if (sub_1000B866C())
  {
    *(void *)&__int128 v10 = "complete_function_uc(io_connect_t, const DIDeviceCommand &, unsigned int, int)";
    *((void *)&v10 + 1) = 20LL;
    int v11 = 2;
    sub_1000E4F88(v12, &v10);
    sub_100004E4C(&v13, (uint64_t)"index=", 6LL);
    std::ostream::operator<<(&v13, a3);
    sub_100004E4C(&v13, (uint64_t)" status=", 8LL);
    std::ostream::operator<<(&v13, a4);
    std::ostream::~ostream(&v13, off_100182FB8);
    sub_1000E57E0((uint64_t)v12);
    std::ios::~ios(v14);
  }

  uint64_t result = IOConnectCallMethod(a1, 1u, input, 2u, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL);
  uint64_t v9 = result;
  if ((_DWORD)result)
  {
    *(void *)&__int128 v10 = "complete_function_uc(io_connect_t, const DIDeviceCommand &, unsigned int, int)";
    *((void *)&v10 + 1) = 20LL;
    int v11 = 16;
    sub_100067BA0(v12, &v10);
    sub_100004E4C(&v13, (uint64_t)"Kernel returned error for complete command, command = ", 54LL);
    std::ostream::operator<<(&v13, a3);
    sub_100004E4C(&v13, (uint64_t)" error = ", 9LL);
    std::ostream::operator<<(&v13, v9);
    std::ostream::~ostream(&v13, off_1001710F0);
    sub_100067D04((uint64_t)v12);
    return std::ios::~ios(v14);
  }

  return result;
}

void sub_1000E4F5C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void *sub_1000E4F88(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000E5C44((uint64_t)a1, a2);
  *a1 = off_100182EF0;
  a1[45] = &off_100182FF0;
  a1[46] = &off_100183018;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_100182EF0;
  a1[45] = off_100182F78;
  a1[46] = off_100182FA0;
  return a1;
}

void sub_1000E500C(_Unwind_Exception *a1)
{
}

uint64_t sub_1000E5030(uint64_t a1)
{
  return a1;
}

uint64_t sub_1000E5070(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100182D98);
  sub_1000E5234(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000E50A8(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100182D98);
  sub_1000E5234(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000E50E8(char *a1)
{
}

uint64_t sub_1000E512C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000E5160(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000E51AC(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100182D98);
  sub_1000E5234((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000E51EC(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100182D98);
  sub_1000E5234((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000E5234(uint64_t a1)
{
  *(void *)a1 = off_100182E68;
  sub_1000E52D0(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000E52D0(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000E5438((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000E53F8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000E5424(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000E5234(a1);
  operator delete(v1);
}

int *sub_1000E5438(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      __int128 v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 114LL;
    __int16 v25 = 2082;
    size_t v26 = v10;
    int v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      size_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        __int128 v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 114LL;
      __int16 v25 = 2082;
      size_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000E561C(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100182FB8);
  sub_1000E57E0(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000E5654(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100182FB8);
  sub_1000E57E0(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000E5694(char *a1)
{
}

uint64_t sub_1000E56D8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000E570C(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000E5758(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100182FB8);
  sub_1000E57E0((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000E5798(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100182FB8);
  sub_1000E57E0((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000E57E0(uint64_t a1)
{
  *(void *)a1 = off_100183088;
  sub_1000E587C(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000E587C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000E59E4((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000E59A4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000E59D0(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000E57E0(a1);
  operator delete(v1);
}

int *sub_1000E59E4(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      __int128 v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 162LL;
    __int16 v25 = 2082;
    size_t v26 = v10;
    int v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      size_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        __int128 v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 162LL;
      __int16 v25 = 2082;
      size_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000E5BC8(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_100182E68;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000E5C30(_Unwind_Exception *a1)
{
}

uint64_t sub_1000E5C44(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(a1) = off_100183088;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 72) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000E5CAC(_Unwind_Exception *a1)
{
}

void sub_1000E5F7C(id a1)
{
  int v1 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v9 = 0LL;
    uint64_t v2 = sub_1000B85DC();
    uint64_t v3 = (os_log_s *)objc_claimAutoreleasedReturnValue(v2);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v4 = 3LL;
    }
    else {
      uint64_t v4 = 2LL;
    }
    *(_DWORD *)buf = 68157954;
    int v11 = 60;
    __int16 v12 = 2080;
    uint64_t v13 = "-[DIClient2IODaemonXPCHandler createConnection]_block_invoke";
    LODWORD(v_Block_object_dispose((const void *)(v2 - 120), 8) = 18;
    __int128 v5 = (char *)_os_log_send_and_compose_impl( v4,  &v9,  0LL,  0LL,  &_mh_execute_header,  v3,  0LL,  "%.*s: Reached an invalidation handler for the IO daemon connection",  (int)buf,  v8);

    if (v5)
    {
      fprintf(__stderrp, "%s\n", v5);
      free(v5);
    }
  }

  else
  {
    uint64_t v6 = sub_1000B85DC();
    uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 68157954;
      int v11 = 60;
      __int16 v12 = 2080;
      uint64_t v13 = "-[DIClient2IODaemonXPCHandler createConnection]_block_invoke";
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "%.*s: Reached an invalidation handler for the IO daemon connection",  buf,  0x12u);
    }
  }

  *__error() = v1;
}

void sub_1000E6108(id a1)
{
  int v1 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v9 = 0LL;
    uint64_t v2 = sub_1000B85DC();
    uint64_t v3 = (os_log_s *)objc_claimAutoreleasedReturnValue(v2);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v4 = 3LL;
    }
    else {
      uint64_t v4 = 2LL;
    }
    *(_DWORD *)buf = 68157954;
    int v11 = 60;
    __int16 v12 = 2080;
    uint64_t v13 = "-[DIClient2IODaemonXPCHandler createConnection]_block_invoke";
    LODWORD(v_Block_object_dispose((const void *)(v2 - 120), 8) = 18;
    __int128 v5 = (char *)_os_log_send_and_compose_impl( v4,  &v9,  0LL,  0LL,  &_mh_execute_header,  v3,  0LL,  "%.*s: Reached an interruption handler for the IO daemon connection",  (int)buf,  v8);

    if (v5)
    {
      fprintf(__stderrp, "%s\n", v5);
      free(v5);
    }
  }

  else
  {
    uint64_t v6 = sub_1000B85DC();
    uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 68157954;
      int v11 = 60;
      __int16 v12 = 2080;
      uint64_t v13 = "-[DIClient2IODaemonXPCHandler createConnection]_block_invoke";
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "%.*s: Reached an interruption handler for the IO daemon connection",  buf,  0x12u);
    }
  }

  *__error() = v1;
}

void sub_1000E6368( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

void sub_1000E6390(uint64_t a1, void *a2)
{
  uint64_t v2 = (id *)(a1 + 32);
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained(v2);
  [WeakRetained signalCommandCompletedWithXpcError:v3];
}

uint64_t *sub_1000E6410(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *uint64_t result = *a2;
  if (!v2)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    uint64_t v4 = (void *)sub_100004870((uint64_t)exception, (uint64_t)"Error opening ByteStream", 0x16u);
  }

  return result;
}

AAByteStream *sub_1000E645C(AAByteStream *a1)
{
  return a1;
}

ssize_t sub_1000E6488(AAByteStream *a1, void *a2, size_t a3, off_t a4)
{
  return AAByteStreamPRead(*a1, a2, a3, a4);
}

uint64_t *sub_1000E6490@<X0>( AAByteStream *a1@<X0>, AEAContext *a2@<X1>, size_t a3@<X2>, AAFlagSet a4@<X3>, int a5@<W4>, uint64_t *a6@<X8>)
{
  AAByteStream v8 = AEADecryptionRandomAccessInputStreamOpen(*a1, *a2, a3, a4, a5);
  return sub_1000E6410(a6, (uint64_t *)&v8);
}

AEAContext *sub_1000E64D0(AEAContext *a1, AAByteStream *a2)
{
  AEAContext v3 = AEAContextCreateWithEncryptedStream(*a2);
  *a1 = v3;
  if (!v3)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    uint64_t v6 = (void *)sub_100004870((uint64_t)exception, (uint64_t)"Context creation failed.", 0x16u);
  }

  return a1;
}

AEAContext *sub_1000E6530(AEAContext *a1)
{
  return a1;
}

uint64_t sub_1000E655C(AEAContext *a1, uint8_t *buf, size_t buf_size)
{
  uint64_t result = AEAContextSetFieldBlob(*a1, 9u, 0, buf, buf_size);
  if ((result & 0x80000000) != 0)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    __int128 v5 = (void *)sub_100004870((uint64_t)exception, (uint64_t)"Context setup failed.", 0x16u);
  }

  return result;
}

uint64_t (**sub_1000E65B4(AEAContext_impl **a1))()
{
  int v1 = *a1;
  size_t buf_size = 0LL;
  if (AEAContextGetFieldBlob(v1, 0x12u, 0, 0LL, 0LL, &buf_size) < 0) {
    return 0LL;
  }
  size_t v2 = buf_size;
  if (buf_size >= 0x100000) {
    size_t v3 = 0x100000LL;
  }
  else {
    size_t v3 = buf_size;
  }
  uint64_t v4 = (uint8_t *)valloc(v3);
  if (!v4)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    __int16 v12 = std::bad_alloc::bad_alloc(exception);
  }

  __int128 __dst = &off_100183148;
  p_dst = &__dst;
  buf = v4;
  sub_1000172D0((uint64_t)&v15, (uint64_t)&__dst);
  __int128 v5 = p_dst;
  if (p_dst == &__dst)
  {
    uint64_t v6 = 4LL;
    __int128 v5 = &__dst;
    goto LABEL_11;
  }

  if (p_dst)
  {
    uint64_t v6 = 5LL;
LABEL_11:
    (*v5)[v6]();
  }

  AAByteStream v8 = buf;
  if (AEAContextGetFieldBlob(v1, 0x12u, 0, v3, buf, 0LL) < 0)
  {
    uint64_t v7 = 0LL;
  }

  else
  {
    if (v2 >= 0x10) {
      size_t v9 = 16LL;
    }
    else {
      size_t v9 = v2;
    }
    memcpy(&__dst, v8, v9);
    uint64_t v7 = __dst;
  }

  sub_100016DE0((uint64_t *)&buf);
  return v7;
}

void sub_1000E672C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

AEAAuthData *sub_1000E6748(AEAAuthData *a1, AEAContext *a2)
{
  AEAAuthData v3 = AEAAuthDataCreateWithContext(*a2);
  *a1 = v3;
  if (!v3)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    uint64_t v6 = (void *)sub_100004870((uint64_t)exception, (uint64_t)"Authentication Data creation failed.", 0x16u);
  }

  return a1;
}

AEAAuthData *sub_1000E67A8(AEAAuthData *a1)
{
  return a1;
}

uint64_t sub_1000E67D4(AEAAuthData *a1)
{
  return AEAAuthDataGetEntryCount(*a1);
}

uint64_t sub_1000E67DC( AEAAuthData *a1, uint32_t a2, size_t a3, char *a4, size_t *a5, size_t a6, uint8_t *a7, size_t *a8)
{
  return AEAAuthDataGetEntry(*a1, a2, a3, a4, a5, a6, a7, a8);
}

void *sub_1000E67E4(void *result, void *a2, uint64_t *a3, void *a4)
{
  uint64_t v4 = *a3;
  *uint64_t result = *a2;
  *a2 = 0LL;
  result[1] = v4;
  *a3 = 0LL;
  result[2] = *a4;
  *a4 = 0LL;
  return result;
}

uint64_t sub_1000E680C(uint64_t a1)
{
  return AEAContextGetFieldUInt(*(AEAContext *)(a1 + 8), 4u);
}

uint64_t sub_1000E6818(uint64_t a1)
{
  return AEAContextGetFieldUInt(*(AEAContext *)(a1 + 8), 0xDu);
}

ssize_t sub_1000E6824(uint64_t a1, void *a2, size_t a3, off_t a4)
{
  return AAByteStreamPRead(*(AAByteStream *)(a1 + 16), a2, a3, a4);
}

void *sub_1000E6834()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &off_100183148;
  return result;
}

void sub_1000E6858(uint64_t a1, void *a2)
{
  *a2 = &off_100183148;
}

void sub_1000E6870(uint64_t a1, void **a2)
{
}

uint64_t sub_1000E6878(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_1000E68B4()
{
  return &off_1001831A8;
}

void *sub_1000E68C0(void *a1, void *a2)
{
  AEAAuthData v3 = sub_1000376FC(a1, a2);
  *AEAAuthData v3 = off_1001831C8;
  *(_OWORD *)(v3 + 5) = 0u;
  uint64_t v4 = (uint64_t **)(v3 + 5);
  *(_OWORD *)(v3 + 7) = 0u;
  __int128 v5 = v3 + 7;
  v3[9] = 0LL;
  uint64_t v6 = v3 + 9;
  uint64_t v7 = sub_100037420();
  int v8 = *((_DWORD *)v7 + 2);
  if (v8 == 1)
  {
    unsigned int v9 = (*v7)();
  }

  else
  {
    if (v8) {
      sub_100017130();
    }
    unsigned int v9 = *(_DWORD *)v7;
  }

  LODWORD(v25) = v9 + 1;
  int v26 = 0;
  sub_1000E7BA8((unsigned int *)&v25, &v26, &v27);
  sub_100014DF0((uint64_t)v5, &v27);
  __int128 v10 = (std::__shared_weak_count *)*((void *)&v27 + 1);
  if (*((void *)&v27 + 1))
  {
    int v11 = (unint64_t *)(*((void *)&v27 + 1) + 8LL);
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  uint64_t v13 = operator new(0x18uLL);
  sub_1000E76DC(v13, v9);
  sub_1000E9A34(&v27, (uint64_t)v13);
  sub_100014DF0((uint64_t)v4, &v27);
  os_log_type_t v14 = (std::__shared_weak_count *)*((void *)&v27 + 1);
  if (*((void *)&v27 + 1))
  {
    uint64_t v15 = (unint64_t *)(*((void *)&v27 + 1) + 8LL);
    do
      unint64_t v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }

  sub_1000E6B4C(*v5, -2LL, 1, (unint64_t *)&v27);
  sub_1000E6D34(v6, (unint64_t *)&v27);
  sub_1000E7B68((unint64_t *)&v27);
  __int128 v27 = 0uLL;
  uint64_t v25 = 0LL;
  sub_1000E6D78((uint64_t *)v6, (uint64_t *)&v27, &v25);
  uint64_t v17 = (std::__shared_weak_count *)*((void *)&v27 + 1);
  if (*((void *)&v27 + 1))
  {
    uint64_t v18 = (unint64_t *)(*((void *)&v27 + 1) + 8LL);
    do
      unint64_t v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  if ((*v4)[1] != **v4)
  {
    unint64_t v20 = 0LL;
    do
    {
      *(void *)&__int128 v27 = 0LL;
      unint64_t v21 = atomic_load(v6);
      atomic_store(v21, (unint64_t *)&v27);
      uint64_t v22 = **v4;
      do
        unint64_t v23 = __ldaxr((unint64_t *)&v27);
      while (__stlxr(0LL, (unint64_t *)&v27));
      atomic_store(v23, (unint64_t *)(v22 + 8 * v20++));
    }

    while (v20 < ((*v4)[1] - **v4) >> 3);
  }

  return a1;
}

void sub_1000E6AEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

unint64_t *sub_1000E6B4C@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, unint64_t *a4@<X8>)
{
  unint64_t v16 = 0LL;
  uint64_t v17 = a2;
  sub_1000E9B38(a1, a2, a3, &v14);
  if (v14 && !*(_BYTE *)(v14 + 312) || v14 && *(_BYTE *)(v14 + 312))
  {
    *a4 = 0LL;
    do
      unint64_t v7 = __ldaxr(&v14);
    while (__stlxr(0LL, &v14));
LABEL_21:
    atomic_store(v7, a4);
    return sub_1000E7B68(&v14);
  }

  if (*(_BYTE *)(a1 + 704) && v15 != (void *)(a1 + 728))
  {
    do
    {
      sub_1000E9FF8(a1, a2, &v12);
      unint64_t v16 = v12;
      sub_1000E6D34(&v14, &v13);
      sub_1000E7B68(&v13);
      if (v14)
      {
        if (!*(_BYTE *)(v14 + 312)) {
          break;
        }
      }

      int v8 = (unint64_t *)sub_1000EA180((void *)a1);
      if (v8)
      {
        unint64_t v16 = v8;
        sub_1000EA224(a1, v8, a2, (unint64_t *)&v12);
        sub_1000E6D34(&v14, (unint64_t *)&v12);
        sub_1000E7B68((unint64_t *)&v12);
        break;
      }
    }

    while (*(_BYTE *)(a1 + 704));
    std::mutex::lock((std::mutex *)(a1 + 744));
    unsigned int v9 = sub_1000DC3D8((uint64_t **)(a1 + 720), v15, (unint64_t *)&v17, &v17, (uint64_t *)&v16);
    if (!v10) {
      v9[5] = (uint64_t)v16;
    }
    std::condition_variable::notify_all((std::condition_variable *)(a1 + 808));
    std::mutex::unlock((std::mutex *)(a1 + 744));
    sub_1000E940C(a1, 0, 0LL, 0);
    *a4 = 0LL;
    do
      unint64_t v7 = __ldaxr(&v14);
    while (__stlxr(0LL, &v14));
    goto LABEL_21;
  }

  *a4 = 0LL;
  return sub_1000E7B68(&v14);
}

void sub_1000E6CF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

unint64_t *sub_1000E6D34(unint64_t *a1, unint64_t *a2)
{
  if (a2 != a1)
  {
    do
      unint64_t v3 = __ldaxr(a2);
    while (__stlxr(0LL, a2));
    sub_1000E7B68(a1);
    atomic_store(v3, a1);
  }

  return a1;
}

void sub_1000E6D78(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
}

void sub_1000E6DA4( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (*v10)
  {
    uint64_t v11 = *(void *)(*v10 + 256);
    if (v11)
    {
      a10 = *v10;
      (*(void (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)v11 + 48LL))(v11, &a10, v10);
    }
  }

  __cxa_rethrow();
}

void sub_1000E6DD8(_Unwind_Exception *a1)
{
}

unint64_t *sub_1000E6DF0@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = a2[3];
  unint64_t v7 = *(unint64_t ***)(a1 + 40);
  int v8 = *v7;
  unsigned int v9 = v7[1];
  while (v8 != v9)
  {
    sub_1000E7098(v8, v6, (unint64_t *)&v26);
    if (v26 && !*(_BYTE *)(v26 + 312))
    {
      sub_1000E7750((unint64_t *)&v24, (unint64_t *)&v26);
      uint64_t v25 = -2LL;
      *(void *)a3 = 0LL;
      do
        unint64_t v22 = __ldaxr((unint64_t *)&v24);
      while (__stlxr(0LL, (unint64_t *)&v24));
      atomic_store(v22, (unint64_t *)a3);
      *(_DWORD *)(a3 + _Block_object_dispose((const void *)(v2 - 120), 8) = v25;
      sub_1000E7B68((unint64_t *)&v24);
      return sub_1000E7B68((unint64_t *)&v26);
    }

    sub_1000E7B68((unint64_t *)&v26);
    ++v8;
  }

  sub_1000E6B4C(*(void *)(a1 + 56), v6, 1, (unint64_t *)&v26);
  if (!v26 || (unsigned int v10 = atomic_load((unsigned int *)(v26 + 24)), v10 != 2))
  {
    uint64_t v24 = a2[3];
    sub_1000E7138(&v26, a2, &v24);
    unint64_t v12 = *(unint64_t ***)(a1 + 40);
    unint64_t v13 = *v12;
    unint64_t v14 = v12[1];
    if (*v12 == v14)
    {
      int v15 = 0;
      goto LABEL_37;
    }

    int v15 = 0;
    while (1)
    {
      unint64_t v16 = atomic_load(v13);
      while (!v16 || *(void *)(v16 + 32) == -2LL)
      {
        unint64_t v17 = atomic_load((unint64_t *)&v26);
        unint64_t v18 = __ldaxr(v13);
        if (v18 != v16)
        {
          __clrex();
LABEL_20:
          int v19 = 0;
          goto LABEL_21;
        }

        if (__stlxr(v17, v13)) {
          goto LABEL_20;
        }
        int v19 = 1;
LABEL_21:
        unint64_t v16 = v18;
        if (v19)
        {
          sub_1000E7750((unint64_t *)&v24, (unint64_t *)&v26);
          goto LABEL_24;
        }
      }

      uint64_t v24 = 0LL;
      atomic_store(0LL, (unint64_t *)&v24);
LABEL_24:
      if (v24) {
        int v20 = *(unsigned __int8 *)(v24 + 312) == 0;
      }
      else {
        int v20 = 0;
      }
      if (v26) {
        int v21 = *(unsigned __int8 *)(v26 + 312) == 0;
      }
      else {
        int v21 = 0;
      }
      sub_1000E7B68((unint64_t *)&v24);
      if (v20 != v21)
      {
        ++v15;
        if (++v13 != v14) {
          continue;
        }
      }

void sub_1000E7044(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

unint64_t *sub_1000E7098@<X0>( unint64_t *result@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t v4 = atomic_load(result);
  if (v4 && *(void *)(v4 + 32) == a2)
  {
    uint64_t v6 = (unint64_t *)atomic_load(result);
    sub_1000EA340(&v9, v6, 1);
    if (v9 && !*(_BYTE *)(v9 + 312))
    {
      uint64_t v7 = *(void *)(v9 + 32);
      *a3 = 0LL;
      if (v7 == a2)
      {
        do
          unint64_t v8 = __ldaxr(&v9);
        while (__stlxr(0LL, &v9));
        atomic_store(v8, a3);
      }
    }

    else
    {
      *a3 = 0LL;
    }

    return sub_1000E7B68(&v9);
  }

  else
  {
    *a3 = 0LL;
  }

  return result;
}

void sub_1000E7138(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
}

void sub_1000E7164( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (*v10)
  {
    uint64_t v11 = *(void *)(*v10 + 256);
    if (v11)
    {
      a10 = *v10;
      (*(void (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)v11 + 48LL))(v11, &a10, v10);
    }
  }

  __cxa_rethrow();
}

void sub_1000E7198(_Unwind_Exception *a1)
{
}

uint64_t sub_1000E71AC(uint64_t a1, uint64_t *a2, int *a3, void **a4)
{
  if (*(_BYTE *)(*a2 + 192)) {
    uint64_t v4 = *a2 + 40;
  }
  else {
    uint64_t v4 = 0LL;
  }
  unsigned __int8 v5 = atomic_load((unsigned __int8 *)(v4 + 140));
  if ((v5 & 1) != 0)
  {
    uint64_t v7 = *(_BYTE *)(*a2 + 192) ? *a2 + 40 : 0LL;
    size_t v8 = atomic_load((unsigned int *)(v7 + 144));
    *a3 = v8;
    if ((v8 & 0x80000000) == 0)
    {
      unint64_t v9 = *a4;
      if (*(_BYTE *)(*a2 + 192)) {
        uint64_t v10 = *a2 + 40;
      }
      else {
        uint64_t v10 = 0LL;
      }
      uint64_t v11 = *(const void **)v10;
      unint64_t v12 = *(std::__shared_weak_count **)(v10 + 8);
      if (v12)
      {
        p_shared_owners = (unint64_t *)&v12->__shared_owners_;
        do
          unint64_t v14 = __ldxr(p_shared_owners);
        while (__stxr(v14 + 1, p_shared_owners));
        memcpy(v9, v11, *a3);
        do
          unint64_t v15 = __ldaxr(p_shared_owners);
        while (__stlxr(v15 - 1, p_shared_owners));
        if (!v15)
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
      }

      else
      {
        memcpy(v9, v11, v8);
      }

      uint64_t v16 = *a2;
      if (*a2)
      {
        if (*(_BYTE *)(v16 + 192)) {
          v16 += 40LL;
        }
        else {
          uint64_t v16 = 0LL;
        }
      }

      unint64_t v17 = (unsigned int *)(v16 + 136);
      do
        unsigned int v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
    }
  }

  return v5 & 1;
}

void sub_1000E72B8(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  if (*a2)
  {
    if (*(_BYTE *)(v3 + 192)) {
      v3 += 40LL;
    }
    else {
      uint64_t v3 = 0LL;
    }
  }

  uint64_t v4 = (std::mutex *)(v3 + 72);
  std::mutex::lock((std::mutex *)(v3 + 72));
  if (*(_BYTE *)(*a2 + 192)) {
    uint64_t v5 = *a2 + 40;
  }
  else {
    uint64_t v5 = 0LL;
  }
  if (atomic_load((unsigned int *)(v5 + 136)))
  {
    uint64_t v7 = *a2;
    if (*a2)
    {
      if (*(_BYTE *)(v7 + 192)) {
        v7 += 40LL;
      }
      else {
        uint64_t v7 = 0LL;
      }
    }

    std::condition_variable::notify_all((std::condition_variable *)(v7 + 24));
  }

  std::mutex::unlock(v4);
}

uint64_t sub_1000E733C(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6 = *a2;
  if (*a2)
  {
    if (*(_BYTE *)(v6 + 192)) {
      v6 += 40LL;
    }
    else {
      uint64_t v6 = 0LL;
    }
  }

  uint64_t v7 = (std::mutex *)(v6 + 72);
  std::mutex::lock((std::mutex *)(v6 + 72));
  uint64_t v8 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 88LL))(*(void *)(a1 + 24), a3);
  uint64_t v9 = v8;
  if (*(_BYTE *)(*a2 + 192)) {
    uint64_t v10 = *a2 + 40;
  }
  else {
    uint64_t v10 = 0LL;
  }
  atomic_store(v8, (unsigned int *)(v10 + 144));
  if (*(_BYTE *)(*a2 + 192)) {
    uint64_t v11 = *a2 + 40;
  }
  else {
    uint64_t v11 = 0LL;
  }
  atomic_store(1u, (unsigned __int8 *)(v11 + 140));
  std::mutex::unlock(v7);
  return v9;
}

void sub_1000E73EC(_Unwind_Exception *a1)
{
}

uint64_t sub_1000E7400(uint64_t a1, uint64_t *a2)
{
  uint64_t p_shared_owners = (uint64_t)a2;
  uint64_t v4 = sub_1000E6DF0(a1, a2, (uint64_t)&v29);
  unint64_t v5 = v30;
  if (v30 != -2)
  {
    uint64_t v13 = sub_1000E733C(a1, &v29, p_shared_owners);
    unsigned int v31 = v13;
    sub_1000E72B8(v13, &v29);
    if (v5 < (uint64_t)(*(void *)(*(void *)(a1 + 40) + 8LL) - **(void **)(a1 + 40)) >> 3)
    {
      __lk.__m_ = 0LL;
      unint64_t v14 = atomic_load((unint64_t *)(a1 + 72));
      atomic_store(v14, (unint64_t *)&__lk);
      uint64_t v15 = **(void **)(a1 + 40);
      do
        unint64_t v16 = __ldaxr((unint64_t *)&__lk);
      while (__stlxr(0LL, (unint64_t *)&__lk));
      atomic_store(v16, (unint64_t *)(v15 + 8 * v5));
    }

    if (v29)
    {
      uint64_t v17 = *(void *)(v29 + 256);
      if (v17)
      {
        __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)v29;
        (*(void (**)(uint64_t, std::unique_lock<std::mutex> *, uint64_t *))(*(void *)v17 + 48LL))( v17,  &__lk,  &v29);
      }
    }

    goto LABEL_44;
  }

  uint64_t v6 = v29;
  if (v29)
  {
    if (*(_BYTE *)(v29 + 192)) {
      uint64_t v6 = v29 + 40;
    }
    else {
      uint64_t v6 = 0LL;
    }
  }

  uint64_t v7 = (unsigned int *)(v6 + 136);
  do
    unsigned int v8 = __ldaxr(v7);
  while (__stlxr(v8 + 1, v7));
  uint64_t v9 = v29;
  if (v29)
  {
    if (*(_BYTE *)(v29 + 192)) {
      uint64_t v9 = v29 + 40;
    }
    else {
      uint64_t v9 = 0LL;
    }
  }

  __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(v9 + 72);
  __lk.__owns_ = 1;
  std::mutex::lock((std::mutex *)(v9 + 72));
  int v11 = sub_1000E71AC(v10, &v29, (int *)&v31, (void **)p_shared_owners);
  char v12 = v11;
  if (v11)
  {
    uint64_t p_shared_owners = v31;
  }

  else
  {
    uint64_t v18 = v29;
    if (v29)
    {
      if (*(_BYTE *)(v29 + 192)) {
        uint64_t v18 = v29 + 40;
      }
      else {
        uint64_t v18 = 0LL;
      }
    }

    std::condition_variable::wait((std::condition_variable *)(v18 + 24), &__lk);
    if (*(_BYTE *)(v29 + 192)) {
      uint64_t v19 = v29 + 40;
    }
    else {
      uint64_t v19 = 0LL;
    }
    size_t v20 = atomic_load((unsigned int *)(v19 + 144));
    unsigned int v31 = v20;
    if ((int)v20 >= 1)
    {
      int v21 = *(void **)p_shared_owners;
      if (*(_BYTE *)(v29 + 192)) {
        uint64_t v22 = v29 + 40;
      }
      else {
        uint64_t v22 = 0LL;
      }
      unint64_t v23 = *(const void **)v22;
      uint64_t v24 = *(std::__shared_weak_count **)(v22 + 8);
      if (v24)
      {
        uint64_t p_shared_owners = (uint64_t)&v24->__shared_owners_;
        do
          unint64_t v25 = __ldxr((unint64_t *)p_shared_owners);
        while (__stxr(v25 + 1, (unint64_t *)p_shared_owners));
        memcpy(v21, v23, v20);
        do
          unint64_t v26 = __ldaxr((unint64_t *)p_shared_owners);
        while (__stlxr(v26 - 1, (unint64_t *)p_shared_owners));
        if (!v26)
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
      }

      else
      {
        memcpy(v21, v23, v20);
      }
    }
  }

  if (__lk.__owns_) {
    std::mutex::unlock(__lk.__m_);
  }
  if ((v12 & 1) == 0) {
LABEL_44:
  }
    uint64_t p_shared_owners = v31;
  sub_1000E7B68((unint64_t *)&v29);
  return p_shared_owners;
}

void sub_1000E7638( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::mutex *a10, char a11, int a12, unint64_t a13)
{
  if (a11) {
    std::mutex::unlock(a10);
  }
  sub_1000E7B68(&a13);
  _Unwind_Resume(a1);
}

double sub_1000E7670@<D0>(void *a1@<X0>, void *a2@<X1>, _OWORD *a3@<X8>)
{
  double result = v5[0];
  *a3 = *(_OWORD *)v5;
  return result;
}

void sub_1000E76B4(void *a1)
{
  int v1 = sub_1000E7B04(a1);
  operator delete(v1);
}

void *sub_1000E76C8(uint64_t a1, void *a2)
{
  return sub_100004E4C(a2, (uint64_t)"readSynchronizer", 16LL);
}

void *sub_1000E76DC(void *a1, unint64_t a2)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if (a2)
  {
    sub_100081F0C(a1, a2);
    uint64_t v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }

  return a1;
}

void sub_1000E7734(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose((const void *)(v2 - 120), 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

unint64_t *sub_1000E7750(unint64_t *a1, unint64_t *a2)
{
  *a1 = 0LL;
  uint64_t v3 = (unint64_t *)atomic_load(a2);
  if (!v3) {
    goto LABEL_9;
  }
  unint64_t v4 = atomic_load(v3);
  if (!v4) {
    goto LABEL_8;
  }
  while (1)
  {
    unint64_t v5 = __ldaxr(v3);
    if (v5 != v4)
    {
      __clrex();
      goto LABEL_7;
    }

    if (!__stlxr(v4 + 1, v3)) {
      break;
    }
LABEL_7:
    unint64_t v4 = v5;
    if (!v5) {
      goto LABEL_8;
    }
  }

  uint64_t v7 = (unint64_t *)v3[37];
  if (v7)
  {
    do
      unint64_t v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
    v3[38] = v8;
  }

  if (!sub_1000E7820((uint64_t)v3))
  {
    do
      unint64_t v9 = __ldaxr(v3);
    while (__stlxr(v9 - 1, v3));
    if (v9 == 1)
    {
      uint64_t v10 = v3[4];
      v3[4] = -1LL;
      sub_1000E790C((uint64_t)v3, v10, 1u);
    }

BOOL sub_1000E7820(uint64_t a1)
{
  size_t v2 = (unsigned int *)(a1 + 24);
  unsigned int v3 = atomic_load((unsigned int *)(a1 + 24));
  if (v3 == 2)
  {
    unint64_t v4 = atomic_load((unint64_t *)a1);
    return v4 > 1;
  }

  else
  {
    uint64_t v6 = (unint64_t *)(a1 + 8);
    do
      unint64_t v7 = __ldaxr(v6);
    while (__stlxr(v7 + 1, v6));
    unsigned int v8 = atomic_load(v2);
    if (v8 != 2 && !*(_BYTE *)(a1 + 312)) {
      sub_1000E78CC(a1 + 24, 1u, 5u);
    }
    do
      unint64_t v9 = __ldaxr(v6);
    while (__stlxr(v9 - 1, v6));
    unint64_t v10 = atomic_load((unint64_t *)a1);
    if (v10 < 2)
    {
      return 0LL;
    }

    else
    {
      unsigned int v11 = atomic_load(v2);
      return v11 == 2;
    }
  }

BOOL sub_1000E78CC(uint64_t a1, unsigned int a2, unsigned int a3)
{
  *(void *)&__int128 v4 = a1;
  *((void *)&v4 + 1) = __PAIR64__(a3, a2);
  uint64_t v5 = a1;
  __int128 v6 = v4;
  return sub_1000D5CB8((uint64_t)&v4, (uint64_t)&v5, 0LL);
}

uint64_t sub_1000E790C(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (*(_BYTE *)(a1 + 312)
    || (unsigned int v6 = atomic_load((unsigned int *)(a1 + 24)), v6 != 2)
    || !*(_BYTE *)(a1 + 192)
    || (uint64_t v7 = *(void *)(a1 + 288)) == 0)
  {
    int v9 = (a3 >> 1) & 2;
    goto LABEL_11;
  }

  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v7 + 48LL))(v7, a1 + 40);
  int v9 = (a3 >> 1) & 2;
  if (!(_DWORD)v8)
  {
LABEL_11:
    atomic_store(0, (unsigned int *)(a1 + 24));
    sub_1000E7AC4(a1 + 40);
    sub_1000BB650(a1 + 200, a1, a2, v9);
    std::__cxx_atomic_notify_all((const void *)(a1 + 24));
    return 1LL;
  }

  if ((a3 & 2) != 0)
  {
    *(void *)&__int128 v11 = "ref::details::ctrl_blk<CurrentReader, unsigned long long>::reset_val(tag_t, details::reset_val_option_set) [T = CurrentReader, tag_t = unsigned long long]";
    *((void *)&v11 + 1) = 68LL;
    int v12 = 16;
    sub_1000BB568(v13, &v11);
    sub_100004E4C(&v14, (uint64_t)"Got error when trying to close ", 31LL);
    std::ostream::operator<<(&v14, a2);
    sub_100004E4C(&v14, (uint64_t)" with ret ", 10LL);
    std::ostream::operator<<(&v14, v8);
    sub_100004E4C(&v14, (uint64_t)", Force closing.", 16LL);
    std::ostream::~ostream(&v14, off_10017EAC0);
    sub_1000BB770((uint64_t)v13);
    std::ios::~ios(&v15);
    goto LABEL_11;
  }

  if ((a3 & 1) != 0) {
    sub_1000BB650(a1 + 200, a1, a2, v9 | 1);
  }
  return 0LL;
}

void sub_1000E7AAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t sub_1000E7AC4(uint64_t result)
{
  if (*(_BYTE *)(result + 152))
  {
    uint64_t v1 = result;
    std::mutex::~mutex((std::mutex *)(result + 72));
    std::condition_variable::~condition_variable((std::condition_variable *)(v1 + 24));
    double result = sub_1000114F0(v1);
    *(_BYTE *)(v1 + 152) = 0;
  }

  return result;
}

void *sub_1000E7B04(void *a1)
{
  *a1 = off_1001831C8;
  sub_1000E7B68(a1 + 9);
  sub_1000114F0((uint64_t)(a1 + 7));
  sub_1000114F0((uint64_t)(a1 + 5));
  *a1 = off_10016A598;
  sub_1000114F0((uint64_t)(a1 + 3));
  size_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

unint64_t *sub_1000E7B68(unint64_t *a1)
{
  do
    double result = (unint64_t *)__ldaxr(a1);
  while (__stlxr(0LL, a1));
  if (result)
  {
    do
    {
      unint64_t v3 = __ldaxr(result);
      unint64_t v4 = v3 - 1;
    }

    while (__stlxr(v4, result));
    if (!v4)
    {
      uint64_t v5 = result[4];
      result[4] = -1LL;
      return (unint64_t *)sub_1000E790C((uint64_t)result, v5, 1u);
    }
  }

  return result;
}

void *sub_1000E7BA8@<X0>(unsigned int *a1@<X1>, int *a2@<X2>, void *a3@<X8>)
{
  unsigned int v6 = operator new(0x580uLL);
  double result = sub_1000E7C08(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_1000E7BF4(_Unwind_Exception *a1)
{
}

void *sub_1000E7C08(void *a1, unsigned int *a2, int *a3)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_1001832A8;
  sub_1000E7C8C((uint64_t)(a1 + 3), a2, a3);
  return a1;
}

void sub_1000E7C3C(_Unwind_Exception *a1)
{
}

void sub_1000E7C50(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1001832A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000E7C60(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1001832A8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void *sub_1000E7C80(uint64_t a1)
{
  return sub_1000E97C8(a1 + 24);
}

uint64_t sub_1000E7C8C(uint64_t a1, unsigned int *a2, int *a3)
{
  unint64_t v4 = *a2;
  uint64_t v5 = *a3;
  unint64_t v10 = 0LL;
  sub_1000E7D5C(a1, v4, v5, (uint64_t)v9);
  unsigned int v6 = v10;
  if (v10 == v9)
  {
    uint64_t v7 = 4LL;
    unsigned int v6 = v9;
    goto LABEL_5;
  }

  if (v10)
  {
    uint64_t v7 = 5LL;
LABEL_5:
    (*(void (**)(void))(*v6 + 8 * v7))();
  }

  return a1;
}

void sub_1000E7D24( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  uint64_t v15 = a13;
  if (a13 == v13)
  {
    uint64_t v16 = 4LL;
    uint64_t v15 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v16 = 5LL;
  }

  (*(void (**)(void))(*(void *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000E7D5C(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = sub_1000E8188(a1);
  *(void *)(v8 + 424) = a2;
  *(void *)(v8 + 4sub_1000114F0(v6 - 32) = a3;
  int v9 = (void *)(v8 + 440);
  *(_OWORD *)(v8 + 440) = 0u;
  *(_OWORD *)(v8 + 456) = 0u;
  *(_OWORD *)(v8 + 472) = 0u;
  *(void *)(v8 + 48_Block_object_dispose((const void *)(v2 - 120), 8) = 850045863LL;
  *(_OWORD *)(v8 + 496) = 0u;
  *(_OWORD *)(v8 + 512) = 0u;
  *(_OWORD *)(v8 + 52_Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  *(void *)(v8 + 544) = 0LL;
  *(_OWORD *)(v8 + 560) = 0u;
  *(_OWORD *)(v8 + 576) = 0u;
  *(void *)(v8 + 592) = 850045863LL;
  *(_OWORD *)(v8 + 600) = 0u;
  *(_OWORD *)(v8 + 616) = 0u;
  *(_OWORD *)(v8 + 6sub_1000114F0(v6 - 32) = 0u;
  *(void *)(v8 + 64_Block_object_dispose((const void *)(v2 - 120), 8) = 0LL;
  *(void *)(v8 + 656) = 1018212795LL;
  *(void *)(v8 + 696) = 0LL;
  *(_OWORD *)(v8 + 680) = 0u;
  *(_BYTE *)(v8 + 704) = 1;
  *(_OWORD *)(v8 + 664) = 0u;
  uint64_t v16 = (dispatch_object_t *)(v8 + 712);
  sub_1000F969C(v8 + 712, "dealloc_queue");
  *(void *)(a1 + 736) = 0LL;
  *(void *)(a1 + 72_Block_object_dispose((const void *)(v2 - 120), 8) = 0LL;
  *(void *)(a1 + 720) = a1 + 728;
  *(void *)(a1 + 744) = 850045863LL;
  *(_OWORD *)(a1 + 752) = 0u;
  *(_OWORD *)(a1 + 76_Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  *(_OWORD *)(a1 + 784) = 0u;
  *(void *)(a1 + 800) = 0LL;
  *(void *)(a1 + 80_Block_object_dispose((const void *)(v2 - 120), 8) = 1018212795LL;
  *(_OWORD *)(a1 + 816) = 0u;
  *(_OWORD *)(a1 + 8sub_1000114F0(v6 - 32) = 0u;
  *(void *)(a1 + 84_Block_object_dispose((const void *)(v2 - 120), 8) = 0LL;
  *(void *)(a1 + 856) = 850045863LL;
  *(_OWORD *)(a1 + 864) = 0u;
  *(_OWORD *)(a1 + 880) = 0u;
  *(_OWORD *)(a1 + 896) = 0u;
  *(void *)(a1 + 912) = 0LL;
  *(void *)(a1 + 920) = a1 + 920;
  *(void *)(a1 + 92_Block_object_dispose((const void *)(v2 - 120), 8) = a1 + 920;
  *(void *)(a1 + 936) = 0LL;
  sub_1000118C0(a1 + 944, a4);
  sub_1000E86A8(a1 + 976, a1);
  *(void *)(a1 + 1320) = &off_1001835A8;
  *(void *)(a1 + 132_Block_object_dispose((const void *)(v2 - 120), 8) = a1;
  *(void *)(a1 + 1344) = a1 + 1320;
  *(void *)(a1 + 1352) = &off_100183638;
  *(void *)(a1 + 1360) = a1;
  *(void *)(a1 + 1376) = a1 + 1352;
  if (a2 >> 61) {
    size_t v10 = -1LL;
  }
  else {
    size_t v10 = 8 * a2;
  }
  __int128 v11 = operator new[](v10);
  int v12 = v11;
  if (a2) {
    bzero(v11, 8 * a2);
  }
  *(void *)(a1 + 552) = v12;
  sub_1000F9750(v16, 3);
  if (a2)
  {
    uint64_t v13 = 0LL;
    do
    {
      uint64_t v14 = operator new(0x158uLL);
      sub_1000E86A8((uint64_t)v14, a1);
      uint64_t v17 = v14;
      sub_1000E8098(v9, &v17);
      atomic_store(0LL, (unint64_t *)(*(void *)(a1 + 552) + 8 * v13++));
    }

    while (a2 != v13);
  }

  return a1;
}

void sub_1000E7F5C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, std::condition_variable *a11, void *a12, dispatch_object_s **a13)
{
  uint64_t v18 = *(void **)(v13 + 968);
  if (v18 == a12)
  {
    uint64_t v19 = 4LL;
    uint64_t v18 = a12;
  }

  else
  {
    if (!v18) {
      goto LABEL_6;
    }
    uint64_t v19 = 5LL;
  }

  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_6:
  sub_1000DD7C8(v16);
  std::mutex::~mutex((std::mutex *)(v13 + 856));
  std::condition_variable::~condition_variable((std::condition_variable *)(v13 + 808));
  std::mutex::~mutex((std::mutex *)(v13 + 744));
  sub_100026AC4(v13 + 720, *a10);
  sub_1000F95F0(a13);
  std::condition_variable::~condition_variable(a11);
  std::mutex::~mutex(v15);
  std::mutex::~mutex((std::mutex *)(v13 + 488));
  sub_1000BBD1C(v14);
  sub_1000E96E0((void *)v13);
  _Unwind_Resume(a1);
}

uint64_t sub_1000E8098(void *a1, void *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[4];
  uint64_t v8 = a1[5];
  unint64_t v9 = v8 + v7;
  if (v6 == v8 + v7)
  {
    sub_1000E8D4C(a1);
    uint64_t v7 = a1[4];
    uint64_t v8 = a1[5];
    uint64_t v5 = a1[1];
    unint64_t v9 = v7 + v8;
  }

  *(void *)(*(void *)(v5 + ((v9 >> 6) & 0x3FFFFFFFFFFFFF8LL)) + 8 * (v9 & 0x1FF)) = *a2;
  a1[5] = v8 + 1;
  unint64_t v10 = v7 + v8 + 1;
  uint64_t v11 = a1[1];
  int v12 = (void *)(v11 + 8 * (v10 >> 9));
  uint64_t v13 = *v12 + 8 * (v10 & 0x1FF);
  if (a1[2] == v11) {
    uint64_t v13 = 0LL;
  }
  if (v13 == *v12) {
    uint64_t v13 = *(v12 - 1) + 4096LL;
  }
  return v13 - 8;
}

uint64_t sub_1000E8154(uint64_t a1)
{
  return a1;
}

uint64_t sub_1000E8188(uint64_t a1)
{
  *(void *)(a1 + sub_1000114F0(v6 - 32) = &off_100183388;
  *(void *)(a1 + 56) = a1 + 32;
  *(void *)a1 = &off_1001832F8;
  *(void *)(a1 + 64) = &off_100183418;
  *(void *)(a1 + 24) = a1;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = a1 + 64;
  *(void *)(a1 + 96) = 0LL;
  uint64_t v2 = sub_1000E849C(a1 + 104, a1, a1 + 32, a1 + 64, a1 + 96);
  sub_1000E827C(v2, -1LL);
  atomic_store(0, (unsigned int *)(a1 + 128));
  *(_BYTE *)(a1 + 416) = 1;
  return a1;
}

void sub_1000E822C(_Unwind_Exception *a1)
{
  uint64_t v7 = *(void **)(v1 + 88);
  if (v7 == v5)
  {
    uint64_t v8 = 4LL;
  }

  else
  {
    if (!v7) {
      goto LABEL_6;
    }
    uint64_t v8 = 5LL;
    uint64_t v5 = *(void **)(v1 + 88);
  }

  (*(void (**)(void *))(*v5 + 8 * v8))(v5);
LABEL_6:
  sub_10011BCFC(v4, v3, v2, v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000E827C(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + sub_1000114F0(v6 - 32) = a2;
  *(_BYTE *)(a1 + 312) = 0;
  atomic_store(1uLL, (unint64_t *)a1);
  atomic_store(0LL, (unint64_t *)(a1 + 8));
  atomic_store(0LL, (unint64_t *)(a1 + 16));
  uint64_t result = sub_1000E7AC4(a1 + 40);
  uint64_t v4 = *(unint64_t **)(a1 + 296);
  if (v4)
  {
    do
      unint64_t v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
    *(void *)(a1 + 304) = v5;
  }

  atomic_store(1u, (unsigned int *)(a1 + 24));
  __dmb(0xBu);
  return result;
}

void *sub_1000E82F0()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &off_1001832F8;
  return result;
}

void sub_1000E8314(uint64_t a1, void *a2)
{
  *a2 = &off_1001832F8;
}

uint64_t sub_1000E8330(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000E836C()
{
}

void *sub_1000E8380()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &off_100183388;
  return result;
}

void sub_1000E83A4(uint64_t a1, void *a2)
{
  *a2 = &off_100183388;
}

uint64_t sub_1000E83C0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000E83FC()
{
}

void *sub_1000E8410()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &off_100183418;
  return result;
}

void sub_1000E8434(uint64_t a1, void *a2)
{
  *a2 = &off_100183418;
}

uint64_t sub_1000E844C()
{
  return 0LL;
}

uint64_t sub_1000E8454(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000E8490()
{
}

uint64_t sub_1000E849C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = 0LL;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + sub_1000114F0(v6 - 32) = -1LL;
  *(_BYTE *)(a1 + 40) = 0;
  *(_BYTE *)(a1 + 192) = 0;
  sub_1000118C0(a1 + 200, a2);
  sub_1000118C0(a1 + 232, a3);
  sub_1000118C0(a1 + 264, a4);
  *(void *)(a1 + 296) = a5;
  *(void *)(a1 + 304) = 0LL;
  *(_BYTE *)(a1 + 312) = 0;
  return a1;
}

void sub_1000E8530(_Unwind_Exception *a1)
{
  uint64_t v6 = *(void **)(v2 + 256);
  if (v6 == v4)
  {
    uint64_t v7 = 4LL;
  }

  else
  {
    if (!v6) {
      goto LABEL_6;
    }
    uint64_t v7 = 5LL;
    uint64_t v4 = *(void **)(v2 + 256);
  }

  (*(void (**)(void *))(*v4 + 8 * v7))(v4);
LABEL_6:
  uint64_t v8 = *(void **)(v2 + 224);
  if (v8 == v3)
  {
    uint64_t v9 = 4LL;
    uint64_t v8 = v3;
  }

  else
  {
    if (!v8) {
      goto LABEL_11;
    }
    uint64_t v9 = 5LL;
  }

  (*(void (**)(void))(*v8 + 8 * v9))();
LABEL_11:
  sub_1000E85B0(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000E85B0(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 152))
  {
    std::mutex::~mutex((std::mutex *)(a1 + 72));
    std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 24));
    sub_1000114F0(a1);
  }

  return a1;
}

void *sub_1000E85F0(void *a1)
{
  uint64_t v2 = a1 + 33;
  unint64_t v3 = (void *)a1[36];
  if (v3 == v2)
  {
    uint64_t v4 = 4LL;
    unint64_t v3 = v2;
  }

  else
  {
    if (!v3) {
      goto LABEL_6;
    }
    uint64_t v4 = 5LL;
  }

  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  unint64_t v5 = (void *)a1[32];
  if (v5 == a1 + 29)
  {
    uint64_t v6 = 4LL;
    unint64_t v5 = a1 + 29;
  }

  else
  {
    if (!v5) {
      goto LABEL_11;
    }
    uint64_t v6 = 5LL;
  }

  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_11:
  uint64_t v7 = (void *)a1[28];
  if (v7 == a1 + 25)
  {
    uint64_t v8 = 4LL;
    uint64_t v7 = a1 + 25;
    goto LABEL_15;
  }

  if (v7)
  {
    uint64_t v8 = 5LL;
LABEL_15:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }

  sub_1000E85B0((uint64_t)(a1 + 5));
  return a1;
}

uint64_t sub_1000E86A8(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a2;
  v10[0] = &off_1001834A8;
  v10[1] = a1;
  uint64_t v11 = v10;
  v8[0] = &off_100183528;
  v8[1] = a1;
  uint64_t v9 = v8;
  sub_1000E849C(a1 + 8, (uint64_t)v10, (uint64_t)v8, a2 + 944, a2 + 568);
  unint64_t v3 = v9;
  if (v9 == v8)
  {
    uint64_t v4 = 4LL;
    unint64_t v3 = v8;
  }

  else
  {
    if (!v9) {
      goto LABEL_6;
    }
    uint64_t v4 = 5LL;
  }

  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  unint64_t v5 = v11;
  if (v11 == v10)
  {
    uint64_t v6 = 4LL;
    unint64_t v5 = v10;
    goto LABEL_10;
  }

  if (v11)
  {
    uint64_t v6 = 5LL;
LABEL_10:
    (*(void (**)(void))(*v5 + 8 * v6))();
  }

  *(void *)(a1 + 32_Block_object_dispose((const void *)(v2 - 120), 8) = 0LL;
  *(_DWORD *)(a1 + 336) = 0;
  return a1;
}

void sub_1000E87A0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  uint64_t v19 = a13;
  if (a13 == v17)
  {
    uint64_t v20 = 4LL;
    uint64_t v19 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v20 = 5LL;
  }

  (*(void (**)(void))(*(void *)v19 + 8 * v20))();
LABEL_6:
  int v21 = a17;
  if (a17 == &a14)
  {
    uint64_t v22 = 4LL;
    int v21 = &a14;
  }

  else
  {
    if (!a17) {
      goto LABEL_11;
    }
    uint64_t v22 = 5LL;
  }

  (*(void (**)(void))(*(void *)v21 + 8 * v22))();
LABEL_11:
  _Unwind_Resume(exception_object);
}

void *sub_1000E8810(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &off_1001834A8;
  result[1] = v3;
  return result;
}

uint64_t sub_1000E8844(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_1001834A8;
  a2[1] = v2;
  return result;
}

uint64_t sub_1000E8860(uint64_t a1, uint64_t a2, uint64_t *a3, int *a4)
{
  return sub_1000BB650(**(void **)(a1 + 8) + 1320LL, *(void *)(a1 + 8), *a3, *a4);
}

uint64_t sub_1000E8878(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000E88B4()
{
}

void *sub_1000E88C8(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &off_100183528;
  result[1] = v3;
  return result;
}

uint64_t sub_1000E88FC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_100183528;
  a2[1] = v2;
  return result;
}

uint64_t sub_1000E8918(uint64_t a1)
{
  return sub_1000E8968((uint64_t **)(a1 + 8));
}

uint64_t sub_1000E8920(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000E895C()
{
}

uint64_t sub_1000E8968(uint64_t **a1)
{
  uint64_t v1 = **a1;
  uint64_t v4 = *a1;
  uint64_t v2 = *(void *)(v1 + 1376);
  if (!v2) {
    sub_100016D94();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t **))(*(void *)v2 + 48LL))(v2, &v4);
}

void *sub_1000E89B0(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &off_1001835A8;
  result[1] = v3;
  return result;
}

uint64_t sub_1000E89E4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_1001835A8;
  a2[1] = v2;
  return result;
}

void sub_1000E8A00(uint64_t a1, unint64_t *a2, unint64_t *a3, _DWORD *a4)
{
}

uint64_t sub_1000E8A14(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000E8A50()
{
}

void sub_1000E8A5C(uint64_t a1, unint64_t a2, unint64_t a3, char a4)
{
  if ((*(_DWORD *)(a2 + 336) & 1) == 0)
  {
    uint64_t v7 = (unsigned int *)(a2 + 336);
    if ((a4 & 3) == 1LL)
    {
      uint64_t v8 = (char *)(a1 + 856);
      std::mutex::lock((std::mutex *)(a1 + 856));
      uint64_t v9 = operator new(0x20uLL);
      _OWORD v9[2] = a2;
      void v9[3] = a3;
      uint64_t v10 = *(void *)(a1 + 920);
      void *v9 = v10;
      v9[1] = a1 + 920;
      *(void *)(v10 + _Block_object_dispose((const void *)(v2 - 120), 8) = v9;
      *(void *)(a1 + 920) = v9;
      ++*(void *)(a1 + 936);
      do
        unsigned int v11 = __ldaxr(v7);
      while (__stlxr(v11 | 4, v7));
      int v12 = sub_100116890(a2);
      std::mutex::lock((std::mutex *)v12);
      uint64_t v13 = sub_100116950(a2);
      std::condition_variable::notify_all((std::condition_variable *)v13);
      std::mutex::unlock((std::mutex *)v12);
LABEL_20:
      std::mutex::unlock((std::mutex *)v8);
      return;
    }

    sub_1000E8C08(a1, a3);
    sub_1000E7B68((unint64_t *)(a2 + 328));
    do
      unsigned int v14 = __ldaxr(v7);
    while (__stlxr(v14 | 1, v7));
    if ((v14 & 2) == 0) {
      sub_1000E8C6C(a1, a2);
    }
    uint64_t v15 = (unint64_t *)(a1 + 576);
    do
    {
      unint64_t v16 = __ldaxr(v15);
      unint64_t v17 = v16 - 1;
    }

    while (__stlxr(v17, v15));
    if (!v17)
    {
      if (atomic_load((unint64_t *)(a1 + 584)))
      {
        std::mutex::lock((std::mutex *)(a1 + 592));
        std::mutex::unlock((std::mutex *)(a1 + 592));
      }
    }

    uint64_t v20 = (unint64_t *)(a1 + 560);
    if (atomic_load(v20))
    {
      uint64_t v8 = sub_100116890(a2);
      std::mutex::lock((std::mutex *)v8);
      if (atomic_load(v20))
      {
        unint64_t v23 = sub_100116950(a2);
        std::condition_variable::notify_all((std::condition_variable *)v23);
      }

      goto LABEL_20;
    }
  }

void sub_1000E8BDC(_Unwind_Exception *a1)
{
}

void sub_1000E8C08(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = a2;
  uint64_t v3 = (std::mutex *)(a1 + 744);
  std::mutex::lock((std::mutex *)(a1 + 744));
  sub_10003F484(a1 + 720, &v4);
  std::condition_variable::notify_all((std::condition_variable *)(a1 + 808));
  std::mutex::unlock(v3);
}

void sub_1000E8C58(_Unwind_Exception *a1)
{
}

void sub_1000E8C6C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  uint64_t v3 = (std::mutex *)(a1 + 488);
  std::mutex::lock((std::mutex *)(a1 + 488));
  sub_1000E8CC8((void *)(a1 + 440), &v4);
  std::mutex::unlock(v3);
}

void sub_1000E8CB4(_Unwind_Exception *a1)
{
}

void sub_1000E8CC8(void *a1, void *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    sub_1000E8D4C(a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = a1[4] + v7;
  }

  *(void *)(*(void *)(v5 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8LL)) + 8 * (v8 & 0x1FF)) = *a2;
  a1[5] = v7 + 1;
}

void sub_1000E8D4C(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_10001848C(v5, v33);
      unint64_t v35 = &v34[8 * (v33 >> 2)];
      unint64_t v37 = &v34[8 * v36];
      unint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        unint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)unint64_t v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_1000E9014( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void *sub_1000E9068(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &off_100183638;
  result[1] = v3;
  return result;
}

uint64_t sub_1000E909C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_100183638;
  a2[1] = v2;
  return result;
}

void sub_1000E90B8(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
}

uint64_t sub_1000E90C4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000E9100()
{
}

void sub_1000E910C(uint64_t a1, unint64_t a2, unint64_t *a3)
{
  uint64_t v3 = *(void *)(a1 + 424);
  if (v3 >= 1)
  {
    uint64_t v6 = 0LL;
    uint64_t v7 = *(void *)(a1 + 552);
    unint64_t v8 = v7 + 8 * v3;
    while (!(v7 + v6) || *(void *)(v7 + v6) != a2)
    {
      v6 += 8LL;
      if (v7 + v6 >= v8) {
        return;
      }
    }

    if ((v6 & 0x8000000000000000LL) == 0)
    {
      uint64_t v9 = (unint64_t *)(v7 + v6);
      while (1)
      {
        unint64_t v10 = __ldaxr(v9);
        if (v10 != a2) {
          break;
        }
        if (!__stlxr(0LL, v9))
        {
          sub_1000E91B4(a1, a2, 1uLL, a3);
          sub_1000E8C6C(a1, a2);
          return;
        }
      }

      __clrex();
    }
  }

uint64_t sub_1000E91B4(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t *a4)
{
  uint64_t v8 = a3 & 0x100;
  uint64_t v9 = (a3 >> 8) & 1;
  unint64_t v10 = (unint64_t *)(a1 + 576);
  do
    unint64_t v11 = __ldaxr(v10);
  while (__stlxr(v11 + 1, v10));
  if ((a3 & 1) != 0)
  {
    uint64_t v12 = (unint64_t *)(a1 + 560);
    do
      unint64_t v13 = __ldaxr(v12);
    while (__stlxr(v13 + 1, v12));
  }

  BOOL v14 = (unsigned int *)(a2 + 336);
  do
    unsigned int v15 = __ldaxr(v14);
  while (__stlxr(v15 | 2, v14));
  sub_1000E7B68((unint64_t *)(a2 + 328));
  if (a4) {
    sub_1000E7B68(a4);
  }
  if ((a3 & 1) != 0)
  {
    char v16 = atomic_load(v14);
    if ((v16 & 4) == 0)
    {
      uint64_t v17 = (a3 >> 16) & 1;
      do
      {
        if ((*v14 & 1) != 0) {
          break;
        }
        if ((_DWORD)v9)
        {
          std::mutex::lock((std::mutex *)(a1 + 488));
          uint64_t v18 = *(void *)(a1 + 480);
          std::mutex::unlock((std::mutex *)(a1 + 488));
          if (v18) {
            break;
          }
        }

        if (sub_1000E940C(a1, v17, 0LL, 0) == -1)
        {
          __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)sub_100116890(a2);
          __lk.__owns_ = 1;
          std::mutex::lock(__lk.__m_);
          uint64_t v24 = sub_100116950(a2);
          v25.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
          uint64_t v35 = a1;
          std::chrono::duration<long long, std::ratio<1, 1000000>>::rep v36 = v25.__d_.__rep_ + 200000;
          unint64_t v32 = a2;
          char v33 = v9;
          *(_DWORD *)uint64_t v34 = *(_DWORD *)v38;
          *(_DWORD *)&v34[3] = *(_DWORD *)&v38[3];
          sub_1000E9570((std::condition_variable *)v24, &__lk, &v36, (uint64_t)&v32);
        }

        else
        {
          __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)sub_100116890(a2);
          __lk.__owns_ = 1;
          std::mutex::lock(__lk.__m_);
          uint64_t v19 = sub_100116950(a2);
          char v20 = atomic_load(v14);
          if ((v20 & 4) == 0)
          {
            uint64_t v21 = (std::condition_variable *)v19;
            do
            {
              if ((*v14 & 1) != 0) {
                break;
              }
              if ((_DWORD)v9)
              {
                std::mutex::lock((std::mutex *)(a1 + 488));
                uint64_t v22 = *(void *)(a1 + 480);
                std::mutex::unlock((std::mutex *)(a1 + 488));
                if (v22) {
                  break;
                }
              }

              std::condition_variable::wait(v21, &__lk);
              char v23 = atomic_load(v14);
            }

            while ((v23 & 4) == 0);
          }
        }

        if (__lk.__owns_) {
          std::mutex::unlock(__lk.__m_);
        }
        unsigned int v26 = *v14;
        if (!v8 || (v26 & 1) != 0)
        {
          if ((v26 & 1) != 0) {
            break;
          }
        }

        else if (*(void *)(a1 + 480))
        {
          break;
        }

        char v27 = atomic_load(v14);
      }

      while ((v27 & 4) == 0);
    }

    uint64_t v28 = (unint64_t *)(a1 + 560);
    do
      unint64_t v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
  }

  do
    unsigned int v30 = __ldaxr(v14);
  while (__stlxr(v30 & 0xFFFFFFFD, v14));
  return v30 & 1;
}

void sub_1000E93E4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::mutex *a14, char a15)
{
  if (a15) {
    std::mutex::unlock(a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000E940C(uint64_t a1, int a2, uint64_t a3, unsigned __int8 a4)
{
  if (!*(void *)(a1 + 936)) {
    return 0LL;
  }
  uint64_t v19 = (std::mutex *)(a1 + 856);
  std::mutex::lock((std::mutex *)(a1 + 856));
  if (*(void *)(a1 + 936))
  {
    uint64_t v8 = *(uint64_t **)(a1 + 928);
    if (v8 == (uint64_t *)(a1 + 920))
    {
      uint64_t v11 = 1LL;
    }

    else
    {
      uint64_t v9 = a4;
      if (a2) {
        unsigned int v10 = 6;
      }
      else {
        unsigned int v10 = 4;
      }
      uint64_t v11 = 1LL;
      do
      {
        unint64_t v12 = v8[2];
        if ((sub_1000E790C(v12 + 8, v8[3], v10) | a2) == 1)
        {
          unint64_t v13 = sub_100116890(v12);
          std::mutex::lock((std::mutex *)v13);
          BOOL v14 = (unsigned int *)(v12 + 336);
          do
            unsigned int v15 = __ldaxr(v14);
          while (__stlxr(v15 & 0xFFFFFFFB, v14));
          std::mutex::unlock((std::mutex *)v13);
          uint64_t v16 = *v8;
          uint64_t v17 = (uint64_t *)v8[1];
          *(void *)(v16 + _Block_object_dispose((const void *)(v2 - 120), 8) = v17;
          *(void *)v8[1] = v16;
          --*(void *)(a1 + 936);
          operator delete(v8);
          uint64_t v8 = v17;
        }

        else
        {
          if (!v9 || v8[3] == a3) {
            uint64_t v11 = 0xFFFFFFFFLL;
          }
          uint64_t v8 = (uint64_t *)v8[1];
        }
      }

      while (v8 != (uint64_t *)(a1 + 920));
    }
  }

  else
  {
    uint64_t v11 = 0LL;
  }

  std::mutex::unlock(v19);
  return v11;
}

void sub_1000E9558( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::mutex *a10)
{
}

uint64_t sub_1000E9570( std::condition_variable *a1, std::unique_lock<std::mutex> *a2, uint64_t *a3, uint64_t a4)
{
  do
  {
    uint64_t v8 = *(void *)(a4 + 16);
    char v9 = atomic_load((unsigned int *)(*(void *)a4 + 336LL));
    if ((v9 & 4) != 0) {
      return 1LL;
    }
    if ((*(_DWORD *)(*(void *)a4 + 336LL) & 1) != 0) {
      return 1LL;
    }
    if (*(_BYTE *)(a4 + 8))
    {
      unsigned int v10 = (std::mutex *)(v8 + 488);
      std::mutex::lock((std::mutex *)(v8 + 488));
      uint64_t v11 = *(void *)(v8 + 480);
      std::mutex::unlock(v10);
      if (v11) {
        return 1LL;
      }
    }

    v12.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
    uint64_t v13 = *a3;
    if (*a3 <= v12.__d_.__rep_) {
      break;
    }
    if (!v13)
    {
      v14.__d_.__rep_ = 0LL;
      goto LABEL_14;
    }

    if (v13 < 1)
    {
      if ((unint64_t)v13 < 0xFFDF3B645A1CAC09LL)
      {
        v14.__d_.__rep_ = 0x8000000000000000LL;
        goto LABEL_14;
      }
    }

    else if ((unint64_t)v13 > 0x20C49BA5E353F7LL)
    {
      v14.__d_.__rep_ = 0x7FFFFFFFFFFFFFFFLL;
      goto LABEL_14;
    }

    v14.__d_.__rep_ = 1000 * v13;
LABEL_14:
    std::condition_variable::__do_timed_wait(a1, a2, v14);
  }

  while (std::chrono::system_clock::now().__d_.__rep_ < *a3);
  uint64_t v15 = *(void *)(a4 + 16);
  char v16 = atomic_load((unsigned int *)(*(void *)a4 + 336LL));
  if ((v16 & 4) != 0 || (*(_DWORD *)(*(void *)a4 + 336LL) & 1) != 0) {
    return 1LL;
  }
  if (!*(_BYTE *)(a4 + 8)) {
    return 0LL;
  }
  std::mutex::lock((std::mutex *)(v15 + 488));
  BOOL v17 = *(void *)(v15 + 480) != 0LL;
  std::mutex::unlock((std::mutex *)(v15 + 488));
  return v17;
}

void *sub_1000E96E0(void *a1)
{
  uint64_t v2 = a1 + 13;
  do
  {
    unint64_t v3 = __ldaxr(v2);
    unint64_t v4 = v3 - 1;
  }

  while (__stlxr(v4, v2));
  if (!v4)
  {
    uint64_t v5 = a1[17];
    a1[17] = -1LL;
    sub_1000E790C((uint64_t)(a1 + 13), v5, 1u);
  }

  sub_1000E85F0(v2);
  uint64_t v6 = (void *)a1[11];
  if (v6 == a1 + 8)
  {
    uint64_t v7 = 4LL;
    uint64_t v6 = a1 + 8;
  }

  else
  {
    if (!v6) {
      goto LABEL_10;
    }
    uint64_t v7 = 5LL;
  }

  (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_10:
  uint64_t v8 = (void *)a1[7];
  if (v8 == a1 + 4)
  {
    uint64_t v9 = 4LL;
    uint64_t v8 = a1 + 4;
  }

  else
  {
    if (!v8) {
      goto LABEL_15;
    }
    uint64_t v9 = 5LL;
  }

  (*(void (**)(void))(*v8 + 8 * v9))();
LABEL_15:
  unsigned int v10 = (void *)a1[3];
  if (v10 == a1)
  {
    uint64_t v11 = 4LL;
    unsigned int v10 = a1;
    goto LABEL_19;
  }

  if (v10)
  {
    uint64_t v11 = 5LL;
LABEL_19:
    (*(void (**)(void))(*v10 + 8 * v11))();
  }

  return a1;
}

void *sub_1000E97C8(uint64_t a1)
{
  *(_BYTE *)(a1 + 704) = 0;
  if (*(void *)(a1 + 424))
  {
    unint64_t v3 = 0LL;
    do
    {
      unint64_t v4 = (unint64_t *)(*(void *)(a1 + 552) + 8 * v3);
      do
        uint64_t v5 = (unint64_t *)__ldaxr(v4);
      while (__stlxr(0LL, v4));
      if (v5)
      {
        unint64_t v1 = v1 & 0xFFFFFFFFFF000000LL | 0x10001;
        sub_1000E91B4(a1, (unint64_t)v5, v1, 0LL);
        sub_1000E7B68(v5 + 41);
        sub_1000E85F0(v5 + 1);
        operator delete(v5);
      }

      ++v3;
    }

    while (*(void *)(a1 + 424) > v3);
  }

  sub_1000F9738((dispatch_queue_t *)(a1 + 712), &stru_1001836D8);
  uint64_t v6 = *(void **)(a1 + 552);
  if (v6) {
    operator delete[](v6);
  }
  std::mutex::lock((std::mutex *)(a1 + 488));
  uint64_t v7 = *(void *)(a1 + 448);
  if (*(void *)(a1 + 456) != v7)
  {
    unint64_t v8 = *(void *)(a1 + 472);
    uint64_t v9 = (void *)(v7 + 8 * (v8 >> 9));
    unsigned int v10 = (unint64_t **)(*v9 + 8 * (v8 & 0x1FF));
    uint64_t v11 = *(void *)(v7 + (((*(void *)(a1 + 480) + v8) >> 6) & 0x3FFFFFFFFFFFFF8LL))
        + 8 * ((*(void *)(a1 + 480) + v8) & 0x1FF);
    while (v10 != (unint64_t **)v11)
    {
      std::chrono::system_clock::time_point v12 = *v10;
      if (*v10)
      {
        sub_1000E7B68(v12 + 41);
        sub_1000E85F0(v12 + 1);
        operator delete(v12);
      }

      if ((unint64_t **)((char *)++v10 - *v9) == (unint64_t **)4096)
      {
        uint64_t v13 = (unint64_t **)v9[1];
        ++v9;
        unsigned int v10 = v13;
      }
    }
  }

  std::mutex::unlock((std::mutex *)(a1 + 488));
  std::chrono::time_point<std::chrono::system_clock, std::chrono::duration<long long, std::ratio<1, 1000000000>>> v14 = *(void **)(a1 + 1376);
  if (v14 == (void *)(a1 + 1352))
  {
    uint64_t v15 = 4LL;
    std::chrono::time_point<std::chrono::system_clock, std::chrono::duration<long long, std::ratio<1, 1000000000>>> v14 = (void *)(a1 + 1352);
  }

  else
  {
    if (!v14) {
      goto LABEL_22;
    }
    uint64_t v15 = 5LL;
  }

  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_22:
  char v16 = *(void **)(a1 + 1344);
  if (v16 == (void *)(a1 + 1320))
  {
    uint64_t v17 = 4LL;
    char v16 = (void *)(a1 + 1320);
  }

  else
  {
    if (!v16) {
      goto LABEL_27;
    }
    uint64_t v17 = 5LL;
  }

  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_27:
  sub_1000E7B68((unint64_t *)(a1 + 1304));
  sub_1000E85F0((void *)(a1 + 984));
  uint64_t v18 = *(void **)(a1 + 968);
  if (v18 == (void *)(a1 + 944))
  {
    uint64_t v19 = 4LL;
    uint64_t v18 = (void *)(a1 + 944);
    goto LABEL_31;
  }

  if (v18)
  {
    uint64_t v19 = 5LL;
LABEL_31:
    (*(void (**)(void))(*v18 + 8 * v19))();
  }

  sub_1000DD7C8((void *)(a1 + 920));
  std::mutex::~mutex((std::mutex *)(a1 + 856));
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 808));
  std::mutex::~mutex((std::mutex *)(a1 + 744));
  sub_100026AC4(a1 + 720, *(void **)(a1 + 728));
  sub_1000F95F0((dispatch_object_s **)(a1 + 712));
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 656));
  std::mutex::~mutex((std::mutex *)(a1 + 592));
  std::mutex::~mutex((std::mutex *)(a1 + 488));
  sub_1000BBD1C((void *)(a1 + 440));
  return sub_1000E96E0((void *)a1);
}

void *sub_1000E9A34(void *a1, uint64_t a2)
{
  *a1 = a2;
  unint64_t v4 = operator new(0x20uLL);
  void *v4 = &off_100183708;
  v4[1] = 0LL;
  v4[2] = 0LL;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_1000E9A80( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  a10 = 0LL;
  if (v10) {
    sub_1000E9B00((int)&a10, v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000E9AA4(std::__shared_weak_count *a1)
{
}

void sub_1000E9AB8(uint64_t a1)
{
}

uint64_t sub_1000E9AC0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }

  else
  {
    return 0LL;
  }

void sub_1000E9B00(int a1, void **__p)
{
  if (__p)
  {
    unint64_t v3 = *__p;
    if (*__p)
    {
      __p[1] = v3;
      operator delete(v3);
    }

    operator delete(__p);
  }

void sub_1000E9B38(uint64_t a1@<X0>, unint64_t a2@<X1>, int a3@<W2>, unint64_t *a4@<X8>)
{
  unint64_t v50 = a2;
  uint64_t v7 = (std::mutex *)(a1 + 744);
  unint64_t v8 = (void *)(a1 + 728);
  uint64_t v9 = (unint64_t *)(a1 + 976);
  unsigned int v10 = (unint64_t *)(a1 + 560);
  uint64_t v43 = (unint64_t *)(a1 + 104);
  uint64_t v44 = (std::condition_variable *)(a1 + 808);
  uint64_t v45 = (uint64_t **)(a1 + 720);
  while (2)
  {
    __lk.__m_ = v7;
    __lk.__owns_ = 1;
    std::mutex::lock(v7);
    if (a3)
    {
      uint64_t v11 = v50;
    }

    else
    {
      char v16 = (void *)*v8;
      if (!*v8) {
        goto LABEL_20;
      }
      uint64_t v11 = v50;
      uint64_t v17 = v8;
      do
      {
        unint64_t v18 = v16[4];
        BOOL v19 = v18 >= v50;
        if (v18 >= v50) {
          char v20 = v16;
        }
        else {
          char v20 = v16 + 1;
        }
        if (v19) {
          uint64_t v17 = v16;
        }
        char v16 = (void *)*v20;
      }

      while (*v20);
      if (v17 == v8 || v50 < v17[4] || (unint64_t *)v17[5] == v9)
      {
LABEL_20:
        unint64_t v51 = 0LL;
        *a4 = 0LL;
        do
          unint64_t v21 = __ldaxr((unint64_t *)&v51);
        while (__stlxr(0LL, (unint64_t *)&v51));
        atomic_store(v21, a4);
        a4[1] = (unint64_t)v8;
        sub_1000E7B68((unint64_t *)&v51);
        goto LABEL_23;
      }
    }

    unint64_t v51 = (unint64_t *)v11;
    uint64_t v52 = v9;
    std::chrono::system_clock::time_point v12 = sub_1000DB2B4(v45, (unint64_t *)&v51, (uint64_t *)&v51);
    uint64_t v13 = v12;
    if (v14)
    {
      unint64_t v51 = 0LL;
      *a4 = 0LL;
      do
        unint64_t v15 = __ldaxr((unint64_t *)&v51);
      while (__stlxr(0LL, (unint64_t *)&v51));
      atomic_store(v15, a4);
      a4[1] = (unint64_t)v12;
      sub_1000E7B68((unint64_t *)&v51);
LABEL_23:
      int v22 = 1;
      goto LABEL_24;
    }

    unint64_t v48 = (unint64_t *)v12[5];
    if (v48 == v9)
    {
      uint64_t v28 = (void *)*v8;
      if (*v8)
      {
        unint64_t v29 = v50;
        unsigned int v30 = v8;
        while (1)
        {
          unint64_t v31 = v28[4];
          BOOL v32 = v31 >= v29;
          if (v31 >= v29) {
            char v33 = v28;
          }
          else {
            char v33 = v28 + 1;
          }
          if (v32) {
            unsigned int v30 = v28;
          }
          uint64_t v28 = (void *)*v33;
          if (!*v33)
          {
            if (v30 == v8) {
              break;
            }
            if (v29 < v30[4]) {
              break;
            }
            uint64_t v34 = (unint64_t *)v30[5];
            if (v34 != v9)
            {
              unint64_t v35 = v34[41];
              if (v35)
              {
                if (!*(_BYTE *)(v35 + 312)) {
                  break;
                }
              }
            }

            if (!*(_BYTE *)(a1 + 704)) {
              break;
            }
            std::condition_variable::wait(v44, &__lk);
            uint64_t v28 = (void *)*v8;
            unsigned int v30 = v8;
            if (!*v8) {
              break;
            }
          }
        }
      }

      int v22 = 0;
      goto LABEL_24;
    }

    sub_10003C718((uint64_t)&__lk);
    sub_1000E7750(&v47, v48 + 41);
    if (v47 && !*(_BYTE *)(v47 + 312))
    {
      uint64_t v23 = v50;
      if (*(void *)(v47 + 32) == v50)
      {
        *a4 = 0LL;
        do
          unint64_t v37 = __ldaxr(&v47);
        while (__stlxr(0LL, &v47));
        atomic_store(v37, a4);
        a4[1] = (unint64_t)v13;
        goto LABEL_84;
      }

      if (*(void *)(v47 + 32) == -1LL)
      {
        uint64_t v24 = v43;
        if ((a3 & 1) == 0)
        {
          unint64_t v51 = 0LL;
          *a4 = 0LL;
          do
            unint64_t v36 = __ldaxr((unint64_t *)&v51);
          while (__stlxr(0LL, (unint64_t *)&v51));
          goto LABEL_83;
        }

        goto LABEL_35;
      }
    }

    else
    {
      if (!a3)
      {
        unint64_t v51 = 0LL;
        *a4 = 0LL;
        do
          unint64_t v36 = __ldaxr((unint64_t *)&v51);
        while (__stlxr(0LL, (unint64_t *)&v51));
        goto LABEL_83;
      }

      uint64_t v23 = v50;
    }

    uint64_t v24 = v43;
LABEL_35:
    if (sub_1000E940C(a1, 0, v23, 1u) != -1)
    {
      do
        unint64_t v25 = __ldaxr(v10);
      while (__stlxr(v25 + 1, v10));
      v46.__m_ = (std::unique_lock<std::mutex>::mutex_type *)sub_100116890((unint64_t)v48);
      v46.__owns_ = 1;
      std::mutex::lock(v46.__m_);
      unsigned int v26 = sub_100116950((unint64_t)v48);
      std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v54 = std::chrono::steady_clock::now().__d_.__rep_ + 200000000;
      unint64_t v51 = (unint64_t *)&v48;
      uint64_t v52 = &v47;
      uint64_t v53 = &v50;
      sub_1000EA414((std::condition_variable *)v26, &v46, &v54, (uint64_t)&v51);
      do
        unint64_t v27 = __ldaxr(v10);
      while (__stlxr(v27 - 1, v10));
      if (v46.__owns_) {
        std::mutex::unlock(v46.__m_);
      }
      int v22 = 3;
      goto LABEL_85;
    }

    unint64_t v51 = 0LL;
    unint64_t v38 = atomic_load(v24);
    if (!v38) {
      goto LABEL_81;
    }
    while (1)
    {
      unint64_t v39 = __ldaxr(v24);
      if (v39 != v38)
      {
        __clrex();
        goto LABEL_71;
      }

      if (!__stlxr(v38 + 1, v24)) {
        break;
      }
LABEL_71:
      unint64_t v38 = v39;
      if (!v39) {
        goto LABEL_81;
      }
    }

    uint64_t v40 = *(unint64_t **)(a1 + 400);
    unint64_t v38 = (unint64_t)v24;
    if (v40)
    {
      do
        unint64_t v41 = __ldxr(v40);
      while (__stxr(v41 + 1, v40));
      *(void *)(a1 + 40_Block_object_dispose((const void *)(v2 - 120), 8) = v41;
      unint64_t v38 = (unint64_t)v24;
    }

void sub_1000E9F98( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::mutex *a12, char a13, int a14, unint64_t a15, uint64_t a16, std::mutex *a17, char a18)
{
  if (a18) {
    std::mutex::unlock(a17);
  }
  _Unwind_Resume(a1);
}

unint64_t *sub_1000E9FF8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t **a3@<X8>)
{
  unint64_t v12 = 0LL;
  uint64_t v6 = (std::mutex *)(a1 + 488);
  std::mutex::lock((std::mutex *)(a1 + 488));
  uint64_t v7 = *(void *)(a1 + 480);
  if (v7)
  {
    ++*(void *)(a1 + 472);
    *(void *)(a1 + 480) = v7 - 1;
    sub_1000DB5C4(a1 + 440, 1);
    sub_1000EA224(a1, v8, a2, v13);
    sub_1000E6D34(&v12, v13);
    sub_1000E7B68(v13);
  }

  else
  {
    unint64_t v8 = 0LL;
  }

  std::mutex::unlock(v6);
  unint64_t v9 = atomic_load((unint64_t *)(a1 + 576));
  if (v9 + v7 >= *(void *)(a1 + 432))
  {
    sub_1000E940C(a1, 0, 0LL, 0);
  }

  else
  {
    v13[0] = (unint64_t)_NSConcreteStackBlock;
    v13[1] = 0x40000000LL;
    void v13[2] = (unint64_t)sub_1000EA598;
    v13[3] = (unint64_t)&unk_100183770;
    v13[4] = a1;
    sub_1000F96B0((dispatch_queue_t *)(a1 + 712), v13);
  }

  *a3 = v8;
  a3[1] = 0LL;
  do
    unint64_t v10 = __ldaxr(&v12);
  while (__stlxr(0LL, &v12));
  atomic_store(v10, (unint64_t *)a3 + 1);
  return sub_1000E7B68(&v12);
}

void sub_1000EA14C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t a9)
{
}

unint64_t sub_1000EA180(void *a1)
{
  unint64_t v1 = atomic_load(a1 + 71);
  uint64_t v2 = a1[53];
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = 0LL;
  int v4 = 0;
  unint64_t v5 = 0LL;
  do
  {
    uint64_t v6 = a1[69];
    uint64_t v7 = *(void *)(v6 + 8 * v3);
    if (v7 && v1 - *(void *)(v7 + 312) != -1LL)
    {
      unint64_t v5 = *(void *)(v6 + 8 * v3);
      int v4 = v3;
    }

    ++v3;
  }

  while (v2 != v3);
  if (!v5) {
    return 0LL;
  }
  unint64_t v8 = (unint64_t *)(a1[69] + 8LL * v4);
  do
  {
    unint64_t v9 = __ldaxr(v8);
    if (v9 != v5)
    {
      __clrex();
      return 0LL;
    }
  }

  while (__stlxr(0LL, v8));
  return v5;
}

unint64_t *sub_1000EA224@<X0>( uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, unint64_t *a4@<X8>)
{
  uint64_t v7 = a2 + 1;
  unint64_t v17 = 0LL;
  unint64_t v8 = atomic_load(a2 + 1);
  if (!v8)
  {
LABEL_7:
    uint64_t v7 = 0LL;
    goto LABEL_11;
  }

  while (1)
  {
    unint64_t v9 = __ldaxr(v7);
    if (v9 != v8)
    {
      __clrex();
      goto LABEL_6;
    }

    if (!__stlxr(v8 + 1, v7)) {
      break;
    }
LABEL_6:
    unint64_t v8 = v9;
    if (!v9) {
      goto LABEL_7;
    }
  }

  unint64_t v10 = (unint64_t *)a2[38];
  if (v10)
  {
    do
      unint64_t v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
    a2[39] = v11;
  }

unint64_t *sub_1000EA340(unint64_t *a1, unint64_t *a2, int a3)
{
  uint64_t v3 = a2;
  *a1 = 0LL;
  if (!a2) {
    goto LABEL_9;
  }
  unint64_t v5 = atomic_load(a2);
  if (!v5) {
    goto LABEL_8;
  }
  while (1)
  {
    unint64_t v6 = __ldaxr(a2);
    if (v6 != v5)
    {
      __clrex();
      goto LABEL_7;
    }

    if (!__stlxr(v5 + 1, a2)) {
      break;
    }
LABEL_7:
    unint64_t v5 = v6;
    if (!v6) {
      goto LABEL_8;
    }
  }

  unint64_t v8 = (unint64_t *)a2[37];
  if (v8)
  {
    do
      unint64_t v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
    a2[38] = v9;
  }

  if (a3 && !sub_1000E7820((uint64_t)a2))
  {
    do
      unint64_t v10 = __ldaxr(v3);
    while (__stlxr(v10 - 1, v3));
    if (v10 == 1)
    {
      uint64_t v11 = v3[4];
      v3[4] = -1LL;
      sub_1000E790C((uint64_t)v3, v11, 1u);
    }

BOOL sub_1000EA414( std::condition_variable *a1, std::unique_lock<std::mutex> *a2, std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep *a3, uint64_t a4)
{
  do
  {
    if ((*(_DWORD *)(**(void **)a4 + 336LL) & 1) != 0) {
      return 1LL;
    }
    uint64_t v8 = *(void *)(a4 + 8);
    if (*(void *)v8)
    {
      if (!*(_BYTE *)(*(void *)v8 + 312LL) && *(void *)(*(void *)v8 + 32LL) == **(void **)(a4 + 16)) {
        return 1LL;
      }
    }

    if (*a3 <= std::chrono::steady_clock::now().__d_.__rep_) {
      break;
    }
    std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v9 = *a3;
    v10.__d_.__rep_ = v9 - std::chrono::steady_clock::now().__d_.__rep_;
    if (v10.__d_.__rep_ >= 1)
    {
      std::chrono::steady_clock::now();
      v11.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
      if (v11.__d_.__rep_)
      {
        if (v11.__d_.__rep_ < 1)
        {
          if ((unint64_t)v11.__d_.__rep_ < 0xFFDF3B645A1CAC09LL)
          {
            std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v12 = 0x8000000000000000LL;
            goto LABEL_17;
          }
        }

        else if ((unint64_t)v11.__d_.__rep_ > 0x20C49BA5E353F7LL)
        {
          std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v12 = 0x7FFFFFFFFFFFFFFFLL;
          goto LABEL_15;
        }

        std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v12 = 1000 * v11.__d_.__rep_;
      }

      else
      {
        std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v12 = 0LL;
      }

uint64_t sub_1000EA598(uint64_t a1)
{
  unint64_t v1 = *(void **)(a1 + 32);
  unint64_t v2 = sub_1000EA180(v1);
  if (v2) {
    sub_1000E8C6C((uint64_t)v1, v2);
  }
  return sub_1000E940C((uint64_t)v1, 0, 0LL, 0);
}

unint64_t *sub_1000EA5DC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (unint64_t *)(a1 + 8);
  sub_1000E827C(a1 + 8, a2);
  unint64_t v12 = 0LL;
  unint64_t v4 = atomic_load(v3);
  if (!v4) {
    goto LABEL_11;
  }
  while (1)
  {
    unint64_t v5 = __ldaxr(v3);
    if (v5 != v4)
    {
      __clrex();
      goto LABEL_6;
    }

    if (!__stlxr(v4 + 1, v3)) {
      break;
    }
LABEL_6:
    unint64_t v4 = v5;
    if (!v5) {
      goto LABEL_11;
    }
  }

  unint64_t v6 = *(unint64_t **)(a1 + 304);
  unint64_t v4 = (unint64_t)v3;
  if (v6)
  {
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
    *(void *)(a1 + 312) = v7;
    unint64_t v4 = (unint64_t)v3;
  }

void sub_1000EA6CC(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  *(void *)(a1 + 304) = **(void **)(a1 + 296);
  uint64_t v6 = a1 + 40;
  sub_1000E7AC4(a1 + 40);
  sub_1000EA798(v6, a2, a3);
  *(_BYTE *)(a1 + 192) = 1;
  atomic_store(2u, (unsigned int *)(a1 + 24));
  sub_1000EA770(a1);
}

void sub_1000EA738(void *a1)
{
  *(_BYTE *)(v1 + 312) = 1;
  sub_1000EA770(v1);
  __cxa_rethrow();
}

void sub_1000EA75C(_Unwind_Exception *a1)
{
}

void sub_1000EA770(uint64_t a1)
{
}

uint64_t sub_1000EA798(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v4 = *a2;
  unint64_t v5 = (std::__shared_weak_count *)a2[1];
  *a2 = 0LL;
  a2[1] = 0LL;
  uint64_t v6 = *a3;
  *(void *)a1 = v4;
  *(void *)(a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = v5;
  if (v5)
  {
    uint64_t p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      unint64_t v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }

  *(void *)(a1 + 16) = v6;
  *(void *)(a1 + 24) = 1018212795LL;
  *(_OWORD *)(a1 + sub_1000114F0(v6 - 32) = 0u;
  *(_OWORD *)(a1 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  *(void *)(a1 + 64) = 0LL;
  *(void *)(a1 + 72) = 850045863LL;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + sub_1000114F0(v49 + 112) = 0u;
  *(_OWORD *)(a1 + 125) = 0u;
  *(_DWORD *)(a1 + 144) = -1;
  if (v5)
  {
    unint64_t v9 = (unint64_t *)&v5->__shared_owners_;
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }

  return a1;
}

void sub_1000EA848(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  *(void *)(a1 + 304) = **(void **)(a1 + 296);
  uint64_t v6 = a1 + 40;
  sub_1000E7AC4(a1 + 40);
  sub_1000EA8EC(v6, a2, a3);
  *(_BYTE *)(a1 + 192) = 1;
  atomic_store(2u, (unsigned int *)(a1 + 24));
  sub_1000EA770(a1);
}

void sub_1000EA8B4(void *a1)
{
  *(_BYTE *)(v1 + 312) = 1;
  sub_1000EA770(v1);
  __cxa_rethrow();
}

void sub_1000EA8D8(_Unwind_Exception *a1)
{
}

uint64_t sub_1000EA8EC(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v4 = *a2;
  unint64_t v5 = (std::__shared_weak_count *)a2[1];
  if (v5)
  {
    uint64_t p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      unint64_t v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
    uint64_t v8 = *a3;
    *(void *)a1 = v4;
    *(void *)(a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = v5;
    do
      unint64_t v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }

  else
  {
    uint64_t v8 = *a3;
    *(void *)a1 = v4;
    *(void *)(a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = 0LL;
  }

  *(void *)(a1 + 16) = v8;
  *(void *)(a1 + 24) = 1018212795LL;
  *(_OWORD *)(a1 + sub_1000114F0(v6 - 32) = 0u;
  *(_OWORD *)(a1 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  *(void *)(a1 + 64) = 0LL;
  *(void *)(a1 + 72) = 850045863LL;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + sub_1000114F0(v49 + 112) = 0u;
  *(_OWORD *)(a1 + 125) = 0u;
  *(_DWORD *)(a1 + 144) = -1;
  if (v5)
  {
    unint64_t v10 = (unint64_t *)&v5->__shared_owners_;
    do
      unint64_t v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }

  return a1;
}

void sub_1000EA9B4(void *a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x68uLL);
  sub_1000EAA1C(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  sub_100018774((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_1000EAA08(_Unwind_Exception *a1)
{
}

void *sub_1000EAA1C(void *a1, void *a2, void *a3)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10017C970;
  sub_1000EAA64(a1 + 3, a2, a3);
  return a1;
}

void sub_1000EAA50(_Unwind_Exception *a1)
{
}

void *sub_1000EAA64(void *a1, void *a2, void *a3)
{
  unint64_t v5 = sub_1000376FC(a1, a3);
  *unint64_t v5 = off_1001831C8;
  uint64_t v6 = a2[6];
  v5[5] = a2[5];
  v5[6] = v6;
  if (v6)
  {
    unint64_t v7 = (unint64_t *)(v6 + 8);
    do
      unint64_t v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }

  uint64_t v9 = a2[8];
  a1[7] = a2[7];
  a1[8] = v9;
  if (v9)
  {
    unint64_t v10 = (unint64_t *)(v9 + 8);
    do
      unint64_t v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }

  sub_1000E7750(a1 + 9, a2 + 9);
  return a1;
}

void sub_1000EAAFC(_Unwind_Exception *a1)
{
}

uLong sub_1000EAB20(unsigned int *a1)
{
  uLong result = *a1;
  if ((_DWORD)result)
  {
    if ((_DWORD)result != 2)
    {
      exception = __cxa_allocate_exception(0x40uLL);
      uint64_t v3 = (void *)sub_100004870((uint64_t)exception, (uint64_t)"Unknown checksum found", 0x16u);
    }

    return crc32(0LL, 0LL, 0) << 32;
  }

  return result;
}

uint64_t sub_1000EAB88(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  uint64_t v4 = (void *)(a1 + 16);
  *(_OWORD *)(a1 + sub_1000114F0(v6 - 32) = 0u;
  unint64_t v5 = (void *)(a1 + 32);
  *(_OWORD *)(a1 + 44) = 0u;
  *(_OWORD *)a1 = 0u;
  unint64_t v37 = &_mh_execute_header;
  sub_10007EF00((uint64_t)"segment_num_t", 0, &v37, 2LL);
  *(_DWORD *)(a1 + 60) = 0;
  unint64_t v37 = &_mh_execute_header;
  sub_10007EF00((uint64_t)"segment_count_t", 0, &v37, 2LL);
  *(_OWORD *)(a1 + 64) = 0u;
  *(void *)(a1 + 20_Block_object_dispose((const void *)(v2 - 120), 8) = 0LL;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + sub_1000114F0(v49 + 112) = 0u;
  *(_OWORD *)(a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  sub_1000F4400((_DWORD *)(a1 + 80));
  *(_OWORD *)(a1 + 216) = 0u;
  *(_DWORD *)(a1 + 84) = 0;
  *(_OWORD *)(a1 + 2sub_1000114F0(v6 - 32) = 0u;
  *(_OWORD *)(a1 + 24_Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 32_Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 40_Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  sub_1000F4400((_DWORD *)(a1 + 352));
  *(_DWORD *)(a1 + 356) = 0;
  *(_DWORD *)(a1 + 48_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
  unint64_t v37 = &_mh_execute_header;
  LODWORD(v3_Block_object_dispose((const void *)(v2 - 120), 8) = 2;
  sub_10007EF00((uint64_t)"image_variant_type", 0, &v37, 3LL);
  *(void *)(a1 + 492) = 0LL;
  int v6 = *(_DWORD *)a2;
  LODWORD(v37) = 2037149547;
  sub_10007EF00((uint64_t)"header_signature", v6, &v37, 1LL);
  *(_DWORD *)a1 = 2037149547;
  int v7 = bswap32(*(_DWORD *)(a2 + 4));
  LODWORD(v37) = 4;
  sub_10007EF00((uint64_t)"version_t", v7, &v37, 1LL);
  *(_DWORD *)(a1 + 4) = 4;
  int v8 = bswap32(*(_DWORD *)(a2 + 8));
  LODWORD(v37) = 512;
  sub_10007EF00((uint64_t)"header_size_t", v8, &v37, 1LL);
  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = 512;
  sub_1000F4330(&v37, bswap32(*(_DWORD *)(a2 + 12)));
  *(_DWORD *)(a1 + 12) = (_DWORD)v37;
  void *v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 24) = bswap64(*(void *)(a2 + 24));
  *unint64_t v5 = bswap64(*(void *)(a2 + 32));
  *(void *)(a1 + 40) = bswap64(*(void *)(a2 + 40));
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = bswap64(*(void *)(a2 + 48));
  LODWORD(v5) = bswap32(*(_DWORD *)(a2 + 56));
  unint64_t v37 = &_mh_execute_header;
  sub_10007EF00((uint64_t)"segment_num_t", (int)v5, &v37, 2LL);
  *(_DWORD *)(a1 + 56) = (_DWORD)v5;
  LODWORD(v5) = bswap32(*(_DWORD *)(a2 + 60));
  unint64_t v37 = &_mh_execute_header;
  sub_10007EF00((uint64_t)"segment_count_t", (int)v5, &v37, 2LL);
  *(_DWORD *)(a1 + 60) = (_DWORD)v5;
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  sub_1000F4400(v36);
  __int128 v9 = *(_OWORD *)(a2 + 192);
  *(_OWORD *)&v36[96] = *(_OWORD *)(a2 + 176);
  *(_OWORD *)&v36[112] = v9;
  *(void *)&v36[128] = *(void *)(a2 + 208);
  __int128 v10 = *(_OWORD *)(a2 + 128);
  *(_OWORD *)&v36[32] = *(_OWORD *)(a2 + 112);
  *(_OWORD *)&v36[48] = v10;
  __int128 v11 = *(_OWORD *)(a2 + 160);
  *(_OWORD *)&v36[64] = *(_OWORD *)(a2 + 144);
  *(_OWORD *)&v36[80] = v11;
  __int128 v12 = *(_OWORD *)(a2 + 96);
  *(_OWORD *)unint64_t v36 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)&v36[16] = v12;
  __int128 v42 = *(_OWORD *)&v36[72];
  __int128 v43 = *(_OWORD *)&v36[88];
  __int128 v44 = *(_OWORD *)&v36[104];
  __int128 v45 = *(_OWORD *)&v36[120];
  __int128 v38 = *(_OWORD *)&v36[8];
  __int128 v39 = *(_OWORD *)&v36[24];
  __int128 v40 = *(_OWORD *)&v36[40];
  __int128 v41 = *(_OWORD *)&v36[56];
  unint64_t v37 = *(const mach_header_64 **)v36;
  sub_1000EC37C((uint64_t)&v37, (int *)&v27);
  *(void *)(a1 + 80) = v27;
  *(_OWORD *)(a1 + 152) = v32;
  *(_OWORD *)(a1 + 16_Block_object_dispose((const void *)(v2 - 120), 8) = v33;
  *(_OWORD *)(a1 + 184) = v34;
  *(_OWORD *)(a1 + 200) = v35;
  *(_OWORD *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = v28;
  *(_OWORD *)(a1 + 104) = v29;
  *(_OWORD *)(a1 + 120) = v30;
  *(_OWORD *)(a1 + 136) = v31;
  *(void *)(a1 + 216) = bswap64(*(void *)(a2 + 216));
  *(void *)(a1 + 224) = bswap64(*(void *)(a2 + 224));
  __int128 v13 = *(_OWORD *)(a2 + 232);
  __int128 v14 = *(_OWORD *)(a2 + 248);
  __int128 v15 = *(_OWORD *)(a2 + 280);
  *(_OWORD *)(a1 + 264) = *(_OWORD *)(a2 + 264);
  *(_OWORD *)(a1 + 280) = v15;
  *(_OWORD *)(a1 + 24_Block_object_dispose((const void *)(v2 - 120), 8) = v14;
  *(_OWORD *)(a1 + 2sub_1000114F0(v6 - 32) = v13;
  *(void *)(a1 + 296) = bswap64(*(void *)(a2 + 296));
  *(void *)(a1 + 304) = bswap64(*(void *)(a2 + 304));
  __int128 v16 = *(_OWORD *)(a2 + 312);
  __int128 v17 = *(_OWORD *)(a2 + 328);
  *(void *)(a1 + 344) = *(void *)(a2 + 344);
  *(_OWORD *)(a1 + 312) = v16;
  *(_OWORD *)(a1 + 32_Block_object_dispose((const void *)(v2 - 120), 8) = v17;
  sub_1000F4400(v36);
  __int128 v18 = *(_OWORD *)(a2 + 464);
  *(_OWORD *)&v36[96] = *(_OWORD *)(a2 + 448);
  *(_OWORD *)&v36[112] = v18;
  *(void *)&v36[128] = *(void *)(a2 + 480);
  __int128 v19 = *(_OWORD *)(a2 + 400);
  *(_OWORD *)&v36[32] = *(_OWORD *)(a2 + 384);
  *(_OWORD *)&v36[48] = v19;
  __int128 v20 = *(_OWORD *)(a2 + 432);
  *(_OWORD *)&v36[64] = *(_OWORD *)(a2 + 416);
  *(_OWORD *)&v36[80] = v20;
  __int128 v21 = *(_OWORD *)(a2 + 368);
  *(_OWORD *)unint64_t v36 = *(_OWORD *)(a2 + 352);
  *(_OWORD *)&v36[16] = v21;
  __int128 v42 = *(_OWORD *)&v36[72];
  __int128 v43 = *(_OWORD *)&v36[88];
  __int128 v44 = *(_OWORD *)&v36[104];
  __int128 v45 = *(_OWORD *)&v36[120];
  __int128 v38 = *(_OWORD *)&v36[8];
  __int128 v39 = *(_OWORD *)&v36[24];
  __int128 v40 = *(_OWORD *)&v36[40];
  __int128 v41 = *(_OWORD *)&v36[56];
  unint64_t v37 = *(const mach_header_64 **)v36;
  sub_1000EC37C((uint64_t)&v37, (int *)&v27);
  *(void *)(a1 + 352) = v27;
  __int128 v22 = v33;
  *(_OWORD *)(a1 + 424) = v32;
  *(_OWORD *)(a1 + 440) = v22;
  __int128 v23 = v35;
  *(_OWORD *)(a1 + 456) = v34;
  *(_OWORD *)(a1 + 472) = v23;
  __int128 v24 = v29;
  *(_OWORD *)(a1 + 360) = v28;
  *(_OWORD *)(a1 + 376) = v24;
  __int128 v25 = v31;
  *(_OWORD *)(a1 + 392) = v30;
  *(_OWORD *)(a1 + 40_Block_object_dispose((const void *)(v2 - 120), 8) = v25;
  LODWORD(v5) = bswap32(*(_DWORD *)(a2 + 488));
  unint64_t v37 = &_mh_execute_header;
  LODWORD(v3_Block_object_dispose((const void *)(v2 - 120), 8) = 2;
  sub_10007EF00((uint64_t)"image_variant_type", (int)v5, &v37, 3LL);
  *(_DWORD *)(a1 + 48_Block_object_dispose((const void *)(v2 - 120), 8) = (_DWORD)v5;
  *(void *)(a1 + 492) = bswap64(*(void *)(a2 + 492));
  return a1;
}

void sub_1000EB074(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10000491C(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1000EB088(uint64_t a1, uint64_t a2)
{
  if (sub_1000B866C())
  {
    *(void *)&__int128 v13 = "*udif::header::write(char *)";
    *((void *)&v13 + 1) = 20LL;
    int v14 = 2;
    sub_1000EB23C(v15, &v13);
    uint64_t v4 = sub_1000EB324(&v16, a1);
    std::ostream::~ostream(v4, off_1001838D0);
    sub_1000F0E90((uint64_t)v15);
    std::ios::~ios(&v17);
  }

  *(_DWORD *)a2 = *(_DWORD *)a1;
  *(_DWORD *)(a2 + 4) = bswap32(*(_DWORD *)(a1 + 4));
  *(_DWORD *)(a2 + _Block_object_dispose((const void *)(v2 - 120), 8) = bswap32(*(_DWORD *)(a1 + 8));
  *(_DWORD *)(a2 + 12) = bswap32(*(_DWORD *)(a1 + 12));
  *(void *)(a2 + 16) = *(void *)(a1 + 16);
  *(void *)(a2 + 24) = bswap64(*(void *)(a1 + 24));
  *(void *)(a2 + sub_1000114F0(v6 - 32) = bswap64(*(void *)(a1 + 32));
  *(void *)(a2 + 40) = bswap64(*(void *)(a1 + 40));
  *(void *)(a2 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = bswap64(*(void *)(a1 + 48));
  *(_DWORD *)(a2 + 56) = bswap32(*(_DWORD *)(a1 + 56));
  *(_DWORD *)(a2 + 60) = bswap32(*(_DWORD *)(a1 + 60));
  *(_OWORD *)(a2 + 64) = *(_OWORD *)(a1 + 64);
  uint64_t v5 = sub_1000EC618(a1 + 80, a2 + 80);
  *(void *)uint64_t v5 = bswap64(*(void *)(a1 + 216));
  *(void *)(v5 + _Block_object_dispose((const void *)(v2 - 120), 8) = bswap64(*(void *)(a1 + 224));
  __int128 v6 = *(_OWORD *)(a1 + 232);
  __int128 v7 = *(_OWORD *)(a1 + 248);
  __int128 v8 = *(_OWORD *)(a1 + 280);
  *(_OWORD *)(v5 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = *(_OWORD *)(a1 + 264);
  *(_OWORD *)(v5 + 64) = v8;
  *(_OWORD *)(v5 + 16) = v6;
  *(_OWORD *)(v5 + sub_1000114F0(v6 - 32) = v7;
  *(void *)(v5 + 80) = bswap64(*(void *)(a1 + 296));
  *(void *)(v5 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = bswap64(*(void *)(a1 + 304));
  __int128 v10 = *(_OWORD *)(a1 + 312);
  __int128 v9 = *(_OWORD *)(a1 + 328);
  *(void *)(v5 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = *(void *)(a1 + 344);
  *(_OWORD *)(v5 + 96) = v10;
  *(_OWORD *)(v5 + sub_1000114F0(v49 + 112) = v9;
  uint64_t v11 = sub_1000EC618(a1 + 352, v5 + 136);
  *(_DWORD *)uint64_t v11 = bswap32(*(_DWORD *)(a1 + 488));
  *(void *)(v11 + 4) = bswap64(*(void *)(a1 + 492));
  return v11 + 12;
}

void sub_1000EB228(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void *sub_1000EB23C(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000F4498((uint64_t)a1, a2);
  *a1 = off_100183808;
  a1[45] = &off_100183908;
  a1[46] = &off_100183930;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_100183808;
  a1[45] = off_100183890;
  a1[46] = off_1001838B8;
  return a1;
}

void sub_1000EB2C0(_Unwind_Exception *a1)
{
}

uint64_t sub_1000EB2E4(uint64_t a1)
{
  return a1;
}

void *sub_1000EB324(void *a1, uint64_t a2)
{
  uint64_t v4 = sub_100004E4C(a1, (uint64_t)"header (", 8LL);
  uint64_t v5 = (void *)std::ostream::operator<<(v4, 500LL);
  __int128 v6 = sub_100004E4C(v5, (uint64_t)"):", 2LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v6 + *(void *)(*v6 - 24LL)));
  __int128 v7 = std::locale::use_facet((const std::locale *)v183, &std::ctype<char>::id);
  uint64_t v8 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v7->__vftable[2].~facet_0)(v7, 10LL);
  std::locale::~locale((std::locale *)v183);
  std::ostream::put(v6, v8);
  std::ostream::flush(v6);
  int v9 = *(_DWORD *)(a2 + 12);
  uint64_t v10 = *(void *)(a2 + 16);
  uint64_t v11 = *(void *)(a2 + 24);
  uint64_t v13 = *(void *)(a2 + 32);
  uint64_t v12 = *(void *)(a2 + 40);
  uint64_t v14 = *(void *)(a2 + 48);
  int v157 = *(_DWORD *)(a2 + 60);
  int v158 = *(_DWORD *)(a2 + 56);
  uint64_t v155 = *(void *)(a2 + 72);
  uint64_t v156 = *(void *)(a2 + 64);
  uint64_t v15 = *(void *)(a2 + 80);
  __int128 v16 = *(_OWORD *)(a2 + 168);
  __int128 v179 = *(_OWORD *)(a2 + 152);
  __int128 v180 = v16;
  __int128 v17 = *(_OWORD *)(a2 + 200);
  __int128 v181 = *(_OWORD *)(a2 + 184);
  __int128 v182 = v17;
  __int128 v18 = *(_OWORD *)(a2 + 104);
  __int128 v175 = *(_OWORD *)(a2 + 88);
  __int128 v176 = v18;
  __int128 v19 = *(_OWORD *)(a2 + 136);
  __int128 v177 = *(_OWORD *)(a2 + 120);
  __int128 v178 = v19;
  uint64_t v153 = *(void *)(a2 + 224);
  uint64_t v154 = *(void *)(a2 + 216);
  __int128 v20 = *(_OWORD *)(a2 + 248);
  __int128 v171 = *(_OWORD *)(a2 + 232);
  __int128 v172 = v20;
  __int128 v21 = *(_OWORD *)(a2 + 280);
  __int128 v173 = *(_OWORD *)(a2 + 264);
  __int128 v174 = v21;
  uint64_t v151 = *(void *)(a2 + 304);
  uint64_t v152 = *(void *)(a2 + 296);
  __int128 v22 = *(_OWORD *)(a2 + 328);
  __int128 v168 = *(_OWORD *)(a2 + 312);
  __int128 v169 = v22;
  uint64_t v170 = *(void *)(a2 + 344);
  uint64_t v23 = *(void *)(a2 + 352);
  __int128 v24 = *(_OWORD *)(a2 + 440);
  __int128 v164 = *(_OWORD *)(a2 + 424);
  __int128 v165 = v24;
  __int128 v25 = *(_OWORD *)(a2 + 472);
  __int128 v166 = *(_OWORD *)(a2 + 456);
  __int128 v167 = v25;
  __int128 v26 = *(_OWORD *)(a2 + 376);
  __int128 v160 = *(_OWORD *)(a2 + 360);
  __int128 v161 = v26;
  __int128 v27 = *(_OWORD *)(a2 + 408);
  __int128 v162 = *(_OWORD *)(a2 + 392);
  __int128 v163 = v27;
  int v150 = *(_DWORD *)(a2 + 488);
  uint64_t v149 = *(void *)(a2 + 492);
  __int128 v28 = sub_100004E4C(a1, (uint64_t)"signature", 9LL);
  __int128 v29 = sub_100004E4C(v28, (uint64_t)": ", 2LL);
  v183[23] = 4;
  strcpy(v183, "koly");
  __int128 v30 = sub_100004E4C(v29, (uint64_t)v183, 4LL);
  if ((v183[23] & 0x80000000) != 0) {
    operator delete(*(void **)v183);
  }
  std::ios_base::getloc((const std::ios_base *)((char *)v30 + *(void *)(*v30 - 24LL)));
  __int128 v31 = std::locale::use_facet((const std::locale *)v183, &std::ctype<char>::id);
  uint64_t v32 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v31->__vftable[2].~facet_0)(v31, 10LL);
  std::locale::~locale((std::locale *)v183);
  std::ostream::put(v30, v32);
  std::ostream::flush(v30);
  __int128 v33 = sub_100004E4C(a1, (uint64_t)"version", 7LL);
  __int128 v34 = sub_100004E4C(v33, (uint64_t)": ", 2LL);
  __int128 v35 = (void *)std::ostream::operator<<(v34, 4LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v35 + *(void *)(*v35 - 24LL)));
  unint64_t v36 = std::locale::use_facet((const std::locale *)v183, &std::ctype<char>::id);
  uint64_t v37 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v36->__vftable[2].~facet_0)(v36, 10LL);
  std::locale::~locale((std::locale *)v183);
  std::ostream::put(v35, v37);
  std::ostream::flush(v35);
  __int128 v38 = sub_100004E4C(a1, (uint64_t)"header_size", 11LL);
  __int128 v39 = sub_100004E4C(v38, (uint64_t)": ", 2LL);
  __int128 v40 = (void *)std::ostream::operator<<(v39, 512LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v40 + *(void *)(*v40 - 24LL)));
  __int128 v41 = std::locale::use_facet((const std::locale *)v183, &std::ctype<char>::id);
  uint64_t v42 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v41->__vftable[2].~facet_0)(v41, 10LL);
  std::locale::~locale((std::locale *)v183);
  std::ostream::put(v40, v42);
  std::ostream::flush(v40);
  __int128 v43 = sub_100004E4C(a1, (uint64_t)"flags", 5LL);
  __int128 v44 = sub_100004E4C(v43, (uint64_t)": ", 2LL);
  LODWORD(v159.__locale_) = v9;
  __int128 v45 = sub_1000F4514(v44, (int *)&v159);
  std::ios_base::getloc((const std::ios_base *)((char *)v45 + *(void *)(*v45 - 24LL)));
  std::unique_lock<std::mutex> v46 = std::locale::use_facet((const std::locale *)v183, &std::ctype<char>::id);
  uint64_t v47 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v46->__vftable[2].~facet_0)(v46, 10LL);
  std::locale::~locale((std::locale *)v183);
  std::ostream::put(v45, v47);
  std::ostream::flush(v45);
  unint64_t v48 = sub_100004E4C(a1, (uint64_t)"run_data_fork_offset", 20LL);
  uint64_t v49 = sub_100004E4C(v48, (uint64_t)": ", 2LL);
  uint64_t v50 = *v49;
  unint64_t v51 = (char *)v49 + *(void *)(*v49 - 24);
  LODWORD(v47) = *((_DWORD *)v51 + 2);
  *((_DWORD *)v51 + 2) = v47 & 0xFFFFFFB5 | 8;
  *(_DWORD *)((char *)v49 + *(void *)(v50 - 24) + 8) |= 0x200u;
  v183[0] = 48;
  uint64_t v52 = sub_1000166BC(v49, v183);
  std::ostream::operator<<(v52, v10);
  uint64_t v53 = *v49;
  *(_DWORD *)((char *)v49 + *(void *)(*v49 - 24) + _Block_object_dispose((const void *)(v2 - 120), 8) = v47;
  std::ios_base::getloc((const std::ios_base *)((char *)v49 + *(void *)(v53 - 24)));
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v54 = std::locale::use_facet((const std::locale *)v183, &std::ctype<char>::id);
  uint64_t v55 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v54->__vftable[2].~facet_0)(v54, 10LL);
  std::locale::~locale((std::locale *)v183);
  std::ostream::put(v49, v55);
  std::ostream::flush(v49);
  uint64_t v56 = sub_100004E4C(a1, (uint64_t)"data_fork_offset", 16LL);
  uint64_t v57 = sub_100004E4C(v56, (uint64_t)": ", 2LL);
  uint64_t v58 = *v57;
  uint64_t v59 = (char *)v57 + *(void *)(*v57 - 24);
  LODWORD(v49) = *((_DWORD *)v59 + 2);
  *((_DWORD *)v59 + 2) = v49 & 0xFFFFFFB5 | 8;
  *(_DWORD *)((char *)v57 + *(void *)(v58 - 24) + 8) |= 0x200u;
  v183[0] = 48;
  __int128 v60 = sub_1000166BC(v57, v183);
  std::ostream::operator<<(v60, v11);
  uint64_t v61 = *v57;
  *(_DWORD *)((char *)v57 + *(void *)(*v57 - 24) + _Block_object_dispose((const void *)(v2 - 120), 8) = (_DWORD)v49;
  std::ios_base::getloc((const std::ios_base *)((char *)v57 + *(void *)(v61 - 24)));
  __int128 v62 = std::locale::use_facet((const std::locale *)v183, &std::ctype<char>::id);
  uint64_t v63 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v62->__vftable[2].~facet_0)(v62, 10LL);
  std::locale::~locale((std::locale *)v183);
  std::ostream::put(v57, v63);
  std::ostream::flush(v57);
  uint64_t v64 = sub_100004E4C(a1, (uint64_t)"data_fork_len", 13LL);
  uint64_t v65 = sub_100004E4C(v64, (uint64_t)": ", 2LL);
  uint64_t v66 = (void *)std::ostream::operator<<(v65, v13);
  std::ios_base::getloc((const std::ios_base *)((char *)v66 + *(void *)(*v66 - 24LL)));
  unint64_t v67 = std::locale::use_facet((const std::locale *)v183, &std::ctype<char>::id);
  uint64_t v68 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v67->__vftable[2].~facet_0)(v67, 10LL);
  std::locale::~locale((std::locale *)v183);
  std::ostream::put(v66, v68);
  std::ostream::flush(v66);
  uint64_t v69 = sub_100004E4C(a1, (uint64_t)"rsrc_fork_offset", 16LL);
  uint64_t v70 = sub_100004E4C(v69, (uint64_t)": ", 2LL);
  uint64_t v71 = *v70;
  uint64_t v72 = (char *)v70 + *(void *)(*v70 - 24);
  LODWORD(v6_Block_object_dispose((const void *)(v2 - 120), 8) = *((_DWORD *)v72 + 2);
  *((_DWORD *)v72 + 2) = v68 & 0xFFFFFFB5 | 8;
  *(_DWORD *)((char *)v70 + *(void *)(v71 - 24) + 8) |= 0x200u;
  v183[0] = 48;
  uint64_t v73 = sub_1000166BC(v70, v183);
  std::ostream::operator<<(v73, v12);
  uint64_t v74 = *v70;
  *(_DWORD *)((char *)v70 + *(void *)(*v70 - 24) + _Block_object_dispose((const void *)(v2 - 120), 8) = v68;
  std::ios_base::getloc((const std::ios_base *)((char *)v70 + *(void *)(v74 - 24)));
  char v75 = std::locale::use_facet((const std::locale *)v183, &std::ctype<char>::id);
  uint64_t v76 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v75->__vftable[2].~facet_0)(v75, 10LL);
  std::locale::~locale((std::locale *)v183);
  std::ostream::put(v70, v76);
  std::ostream::flush(v70);
  unint64_t v77 = sub_100004E4C(a1, (uint64_t)"rsrc_fork_len", 13LL);
  unint64_t v78 = sub_100004E4C(v77, (uint64_t)": ", 2LL);
  uint64_t v79 = (void *)std::ostream::operator<<(v78, v14);
  std::ios_base::getloc((const std::ios_base *)((char *)v79 + *(void *)(*v79 - 24LL)));
  uint64_t v80 = std::locale::use_facet((const std::locale *)v183, &std::ctype<char>::id);
  uint64_t v81 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v80->__vftable[2].~facet_0)(v80, 10LL);
  std::locale::~locale((std::locale *)v183);
  std::ostream::put(v79, v81);
  std::ostream::flush(v79);
  uint64_t v82 = sub_100004E4C(a1, (uint64_t)"segment_num", 11LL);
  uint64_t v83 = sub_100004E4C(v82, (uint64_t)": ", 2LL);
  LODWORD(v159.__locale_) = v158;
  uint64_t v84 = sub_1000F45D0(v83, &v159);
  std::ios_base::getloc((const std::ios_base *)((char *)v84 + *(void *)(*v84 - 24LL)));
  uint64_t v85 = std::locale::use_facet((const std::locale *)v183, &std::ctype<char>::id);
  uint64_t v86 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v85->__vftable[2].~facet_0)(v85, 10LL);
  std::locale::~locale((std::locale *)v183);
  std::ostream::put(v84, v86);
  std::ostream::flush(v84);
  unint64_t v87 = sub_100004E4C(a1, (uint64_t)"segment_count", 13LL);
  unint64_t v88 = sub_100004E4C(v87, (uint64_t)": ", 2LL);
  LODWORD(v159.__locale_) = v157;
  unint64_t v89 = sub_1000F4614(v88, &v159);
  std::ios_base::getloc((const std::ios_base *)((char *)v89 + *(void *)(*v89 - 24LL)));
  __int128 v90 = std::locale::use_facet((const std::locale *)v183, &std::ctype<char>::id);
  uint64_t v91 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v90->__vftable[2].~facet_0)(v90, 10LL);
  std::locale::~locale((std::locale *)v183);
  std::ostream::put(v89, v91);
  std::ostream::flush(v89);
  *(void *)__int128 v183 = v156;
  *(void *)&v183[8] = v155;
  __n128 v92 = sub_100004E4C(a1, (uint64_t)"segment_id", 10LL);
  unint64_t v93 = sub_100004E4C(v92, (uint64_t)": ", 2LL);
  sub_1000F4658(v93, v183, 16LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v93 + *(void *)(*v93 - 24LL)));
  char v94 = std::locale::use_facet(&v159, &std::ctype<char>::id);
  uint64_t v95 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v94->__vftable[2].~facet_0)(v94, 10LL);
  std::locale::~locale(&v159);
  std::ostream::put(v93, v95);
  std::ostream::flush(v93);
  *(void *)__int128 v183 = v15;
  __int128 v184 = v179;
  __int128 v185 = v180;
  __int128 v186 = v181;
  __int128 v187 = v182;
  *(_OWORD *)&v183[8] = v175;
  *(_OWORD *)&v183[24] = v176;
  *(_OWORD *)&v183[40] = v177;
  *(_OWORD *)&v183[56] = v178;
  char v96 = sub_100004E4C(a1, (uint64_t)"data_fork_checksum", 18LL);
  uint64_t v97 = sub_100004E4C(v96, (uint64_t)": ", 2LL);
  sub_1000ED4B8(v97, v183);
  std::ios_base::getloc((const std::ios_base *)((char *)v97 + *(void *)(*v97 - 24LL)));
  unint64_t v98 = std::locale::use_facet(&v159, &std::ctype<char>::id);
  uint64_t v99 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v98->__vftable[2].~facet_0)(v98, 10LL);
  std::locale::~locale(&v159);
  std::ostream::put(v97, v99);
  std::ostream::flush(v97);
  uint64_t v100 = sub_100004E4C(a1, (uint64_t)"xml_offset", 10LL);
  __int128 v101 = sub_100004E4C(v100, (uint64_t)": ", 2LL);
  uint64_t v102 = *v101;
  __int128 v103 = (char *)v101 + *(void *)(*v101 - 24);
  LODWORD(v99) = *((_DWORD *)v103 + 2);
  *((_DWORD *)v103 + 2) = v99 & 0xFFFFFFB5 | 8;
  *(_DWORD *)((char *)v101 + *(void *)(v102 - 24) + 8) |= 0x200u;
  v183[0] = 48;
  char v104 = sub_1000166BC(v101, v183);
  std::ostream::operator<<(v104, v154);
  uint64_t v105 = *v101;
  *(_DWORD *)((char *)v101 + *(void *)(*v101 - 24) + _Block_object_dispose((const void *)(v2 - 120), 8) = v99;
  std::ios_base::getloc((const std::ios_base *)((char *)v101 + *(void *)(v105 - 24)));
  unint64_t v106 = std::locale::use_facet((const std::locale *)v183, &std::ctype<char>::id);
  uint64_t v107 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v106->__vftable[2].~facet_0)(v106, 10LL);
  std::locale::~locale((std::locale *)v183);
  std::ostream::put(v101, v107);
  std::ostream::flush(v101);
  unint64_t v108 = sub_100004E4C(a1, (uint64_t)"xml_length", 10LL);
  char v109 = sub_100004E4C(v108, (uint64_t)": ", 2LL);
  uint64_t v110 = (void *)std::ostream::operator<<(v109, v153);
  std::ios_base::getloc((const std::ios_base *)((char *)v110 + *(void *)(*v110 - 24LL)));
  unint64_t v111 = std::locale::use_facet((const std::locale *)v183, &std::ctype<char>::id);
  uint64_t v112 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v111->__vftable[2].~facet_0)(v111, 10LL);
  std::locale::~locale((std::locale *)v183);
  std::ostream::put(v110, v112);
  std::ostream::flush(v110);
  *(_OWORD *)__int128 v183 = v171;
  *(_OWORD *)&v183[16] = v172;
  *(_OWORD *)&v183[32] = v173;
  *(_OWORD *)&v183[48] = v174;
  uint64_t v113 = sub_100004E4C(a1, (uint64_t)"external", 8LL);
  __int128 v114 = sub_100004E4C(v113, (uint64_t)": ", 2LL);
  sub_1000F4658(v114, v183, 64LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v114 + *(void *)(*v114 - 24LL)));
  __int128 v115 = std::locale::use_facet(&v159, &std::ctype<char>::id);
  uint64_t v116 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v115->__vftable[2].~facet_0)(v115, 10LL);
  std::locale::~locale(&v159);
  std::ostream::put(v114, v116);
  std::ostream::flush(v114);
  char v117 = sub_100004E4C(a1, (uint64_t)"code_sign_offset", 16LL);
  uint64_t v118 = sub_100004E4C(v117, (uint64_t)": ", 2LL);
  uint64_t v119 = *v118;
  __int128 v120 = (char *)v118 + *(void *)(*v118 - 24);
  LODWORD(v116) = *((_DWORD *)v120 + 2);
  *((_DWORD *)v120 + 2) = v116 & 0xFFFFFFB5 | 8;
  *(_DWORD *)((char *)v118 + *(void *)(v119 - 24) + 8) |= 0x200u;
  v183[0] = 48;
  unint64_t v121 = sub_1000166BC(v118, v183);
  std::ostream::operator<<(v121, v152);
  uint64_t v122 = *v118;
  *(_DWORD *)((char *)v118 + *(void *)(*v118 - 24) + _Block_object_dispose((const void *)(v2 - 120), 8) = v116;
  std::ios_base::getloc((const std::ios_base *)((char *)v118 + *(void *)(v122 - 24)));
  uint64_t v123 = std::locale::use_facet((const std::locale *)v183, &std::ctype<char>::id);
  uint64_t v124 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v123->__vftable[2].~facet_0)(v123, 10LL);
  std::locale::~locale((std::locale *)v183);
  std::ostream::put(v118, v124);
  std::ostream::flush(v118);
  unint64_t v125 = sub_100004E4C(a1, (uint64_t)"code_sign_length", 16LL);
  uint64_t v126 = sub_100004E4C(v125, (uint64_t)": ", 2LL);
  __int128 v127 = (void *)std::ostream::operator<<(v126, v151);
  std::ios_base::getloc((const std::ios_base *)((char *)v127 + *(void *)(*v127 - 24LL)));
  __int128 v128 = std::locale::use_facet((const std::locale *)v183, &std::ctype<char>::id);
  uint64_t v129 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v128->__vftable[2].~facet_0)(v128, 10LL);
  std::locale::~locale((std::locale *)v183);
  std::ostream::put(v127, v129);
  std::ostream::flush(v127);
  *(_OWORD *)__int128 v183 = v168;
  *(_OWORD *)&v183[16] = v169;
  *(void *)&v183[32] = v170;
  char v130 = sub_100004E4C(a1, (uint64_t)"reserved", 8LL);
  uint64_t v131 = sub_100004E4C(v130, (uint64_t)": ", 2LL);
  sub_1000F4658(v131, v183, 40LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v131 + *(void *)(*v131 - 24LL)));
  char v132 = std::locale::use_facet(&v159, &std::ctype<char>::id);
  uint64_t v133 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v132->__vftable[2].~facet_0)(v132, 10LL);
  std::locale::~locale(&v159);
  std::ostream::put(v131, v133);
  std::ostream::flush(v131);
  *(void *)__int128 v183 = v23;
  __int128 v184 = v164;
  __int128 v185 = v165;
  __int128 v186 = v166;
  __int128 v187 = v167;
  *(_OWORD *)&v183[8] = v160;
  *(_OWORD *)&v183[24] = v161;
  *(_OWORD *)&v183[40] = v162;
  *(_OWORD *)&v183[56] = v163;
  unint64_t v134 = sub_100004E4C(a1, (uint64_t)"master_checksum", 15LL);
  char v135 = sub_100004E4C(v134, (uint64_t)": ", 2LL);
  sub_1000ED4B8(v135, v183);
  std::ios_base::getloc((const std::ios_base *)((char *)v135 + *(void *)(*v135 - 24LL)));
  uint64_t v136 = std::locale::use_facet(&v159, &std::ctype<char>::id);
  uint64_t v137 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v136->__vftable[2].~facet_0)(v136, 10LL);
  std::locale::~locale(&v159);
  std::ostream::put(v135, v137);
  std::ostream::flush(v135);
  char v138 = sub_100004E4C(a1, (uint64_t)"image_variant", 13LL);
  char v139 = sub_100004E4C(v138, (uint64_t)": ", 2LL);
  LODWORD(v159.__locale_) = v150;
  __int128 v140 = sub_1000F47A4(v139, &v159);
  std::ios_base::getloc((const std::ios_base *)((char *)v140 + *(void *)(*v140 - 24LL)));
  char v141 = std::locale::use_facet((const std::locale *)v183, &std::ctype<char>::id);
  uint64_t v142 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v141->__vftable[2].~facet_0)(v141, 10LL);
  std::locale::~locale((std::locale *)v183);
  std::ostream::put(v140, v142);
  std::ostream::flush(v140);
  __int128 v143 = sub_100004E4C(a1, (uint64_t)"sector_count", 12LL);
  uint64_t v144 = sub_100004E4C(v143, (uint64_t)": ", 2LL);
  uint64_t v145 = (void *)std::ostream::operator<<(v144, v149);
  std::ios_base::getloc((const std::ios_base *)((char *)v145 + *(void *)(*v145 - 24LL)));
  __int128 v146 = std::locale::use_facet((const std::locale *)v183, &std::ctype<char>::id);
  uint64_t v147 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v146->__vftable[2].~facet_0)(v146, 10LL);
  std::locale::~locale((std::locale *)v183);
  std::ostream::put(v145, v147);
  std::ostream::flush(v145);
  return a1;
}

void sub_1000EC2E8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
}

__n128 sub_1000EC37C@<Q0>(uint64_t a1@<X0>, int *a2@<X8>)
{
  *a2 = v8;
  a2[1] = 0;
  unsigned int v7 = bswap32(*(_DWORD *)(a1 + 4));
  sub_1000EC440(a2 + 1, &v7);
  int v5 = *a2;
  if (*a2) {
    BOOL v6 = v5 == 10;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    if (v5 == 2)
    {
      a2[2] = bswap32(*(_DWORD *)(a1 + 8));
    }

    else
    {
      *(_OWORD *)(a2 + 1_Block_object_dispose((const void *)(v2 - 120), 8) = *(_OWORD *)(a1 + 72);
      *(_OWORD *)(a2 + 22) = *(_OWORD *)(a1 + 88);
      *(_OWORD *)(a2 + 26) = *(_OWORD *)(a1 + 104);
      *(_OWORD *)(a2 + 30) = *(_OWORD *)(a1 + 120);
      *(_OWORD *)(a2 + 2) = *(_OWORD *)(a1 + 8);
      *(_OWORD *)(a2 + 6) = *(_OWORD *)(a1 + 24);
      *(_OWORD *)(a2 + 10) = *(_OWORD *)(a1 + 40);
      __n128 result = *(__n128 *)(a1 + 56);
      *(__n128 *)(a2 + 14) = result;
    }
  }

  return result;
}

_DWORD *sub_1000EC440(_DWORD *result, _DWORD *a2)
{
  if (*a2 >= 0x408u)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    void *exception = &off_100183A38;
    exception[1] = "_checksum";
    exception[2] = "field size too large";
  }

  *__n128 result = *a2;
  return result;
}

BOOL sub_1000EC49C(_DWORD *a1, uint64_t a2)
{
  return sub_10004A1C4(a1, v4);
}

uint64_t sub_1000EC500(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a2 + 12);
  if ((_DWORD)v2 == -1) {
    sub_100017130();
  }
  BOOL v6 = &v5;
  ((void (*)(uint64_t *__return_ptr, char **, uint64_t))off_100183A58[v2])(&v7, &v6, a2 + 4);
  *(void *)a1 = v7;
  *(_OWORD *)(a1 + 72) = v12;
  *(_OWORD *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = v13;
  *(_OWORD *)(a1 + 104) = v14;
  *(_OWORD *)(a1 + 120) = v15;
  *(_OWORD *)(a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = v8;
  *(_OWORD *)(a1 + 24) = v9;
  *(_OWORD *)(a1 + 40) = v10;
  *(_OWORD *)(a1 + 56) = v11;
  return a1;
}

unsigned int *sub_1000EC5D4@<X0>(unsigned int *result@<X0>, unsigned int *a2@<X8>)
{
  unsigned int v3 = bswap32(*result);
  if ((v3 & 0x80000000) != 0)
  {
    __n128 result = sub_1000F1778(&v4, v3);
    unsigned int v3 = v4;
  }

  *a2 = v3;
  return result;
}

uint64_t sub_1000EC618(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a2 = bswap32(*(_DWORD *)a1);
  *(_DWORD *)(a2 + 4) = bswap32(*(_DWORD *)(a1 + 4));
  uint64_t v2 = (_OWORD *)(a2 + 8);
  unsigned int v3 = *(_DWORD *)a1;
  if (*(_DWORD *)a1) {
    BOOL v4 = v3 == 10;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4)
  {
    uint64_t v5 = 0LL;
  }

  else if (v3 == 2)
  {
    *(_DWORD *)(a2 + _Block_object_dispose((const void *)(v2 - 120), 8) = bswap32(*(_DWORD *)(a1 + 8));
    uint64_t v2 = (_OWORD *)(a2 + 12);
    uint64_t v5 = 4LL;
  }

  else
  {
    __int128 v6 = *(_OWORD *)(a1 + 8);
    __int128 v7 = *(_OWORD *)(a1 + 24);
    __int128 v8 = *(_OWORD *)(a1 + 56);
    *(_OWORD *)(a2 + 40) = *(_OWORD *)(a1 + 40);
    *(_OWORD *)(a2 + 56) = v8;
    *uint64_t v2 = v6;
    *(_OWORD *)(a2 + 24) = v7;
    __int128 v9 = *(_OWORD *)(a1 + 72);
    __int128 v10 = *(_OWORD *)(a1 + 88);
    __int128 v11 = *(_OWORD *)(a1 + 120);
    *(_OWORD *)(a2 + 104) = *(_OWORD *)(a1 + 104);
    *(_OWORD *)(a2 + 120) = v11;
    *(_OWORD *)(a2 + 72) = v9;
    *(_OWORD *)(a2 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = v10;
    uint64_t v5 = 128LL;
  }

  bzero(v2, 128 - v5);
  return (uint64_t)v2 - v5 + 128;
}

uint64_t sub_1000EC6D0@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v3 = *(void *)(a2 + 8);
  unint64_t v4 = *(void *)(result + 8) + v3;
  unint64_t v5 = v4 + *(void *)(result + 16);
  *(void *)a3 = v4;
  *(void *)(a3 + _Block_object_dispose((const void *)(v2 - 120), 8) = v5;
  *(_BYTE *)(a3 + 16) = 2;
  if (v4 < v5 && (v4 < v3 || v3 + *(void *)(a2 + 16) - 1 < v5 - 1))
  {
    exception = __cxa_allocate_exception(0x40uLL);
    __int128 v7 = (void *)sub_100004870((uint64_t)exception, (uint64_t)"Invalid UDIF, run is not within block boundary", 0x16u);
  }

  return result;
}

uint64_t sub_1000EC750@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = *(void *)(a1 + 72);
  size_t v5 = *(void *)(v4 + 224);
  __int128 v6 = operator new[](v5);
  bzero(v6, v5);
  *a2 = v6;
  uint64_t result = sub_100033014(*(void *)(a1 + 56), (uint64_t)v6, v5, *(void *)(v4 + 216));
  if ((result & 0x80000000) != 0)
  {
    unsigned int v8 = result;
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = &off_100189E78;
    __int128 v10 = std::generic_category();
    exception[1] = v8;
    exception[2] = v10;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
    exception[7] = "Can't read UDIF trailer";
  }

  return result;
}

void sub_1000EC810(_Unwind_Exception *a1)
{
  void *v1 = 0LL;
  operator delete[](v2);
  _Unwind_Resume(a1);
}

unint64_t sub_1000EC828(uint64_t a1, void *a2)
{
  values = a2;
  keys = @"resource-fork";
  sub_1000F686C((const void **)&keys, (const void **)&values, 1LL, (CFMutableDictionaryRef *)&propertyList);
  if (sub_1000B866C())
  {
    int v3 = *__error();
    if (sub_1000B8654())
    {
      v37[0] = 0LL;
      uint64_t v4 = (os_log_s *)sub_1000B85DC();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG)) {
        uint64_t v5 = 3LL;
      }
      else {
        uint64_t v5 = 2LL;
      }
      *(_DWORD *)buf = 68158210;
      *(_DWORD *)&uint8_t buf[4] = 41;
      *(_WORD *)__int128 v40 = 2080;
      *(void *)&v40[2] = "udif::details::UDIF_base::write_resources(CFDictionaryRef)";
      *(_WORD *)&v40[10] = 2114;
      *(void *)&v40[12] = propertyList;
      __int128 v6 = (const char *)_os_log_send_and_compose_impl( v5,  v37,  0LL,  0LL,  &_mh_execute_header,  v4,  2LL,  "%.*s: res_dict: %{public}@",  buf,  28);
      if (v6)
      {
        __int128 v7 = (char *)v6;
        fprintf(__stderrp, "%s\n", v6);
        free(v7);
      }
    }

    else
    {
      unsigned int v8 = (os_log_s *)sub_1000B85DC();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 68158210;
        *(_DWORD *)&uint8_t buf[4] = 41;
        *(_WORD *)__int128 v40 = 2080;
        *(void *)&v40[2] = "udif::details::UDIF_base::write_resources(CFDictionaryRef)";
        *(_WORD *)&v40[10] = 2114;
        *(void *)&v40[12] = propertyList;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "%.*s: res_dict: %{public}@", buf, 0x1Cu);
      }
    }

    *__error() = v3;
  }

  sub_1000F694C(propertyList, (const __CFData **)v37);
  uint64_t v9 = *(void *)(*(void *)(a1 + 72) + 216LL);
  uint64_t v10 = *(void *)(a1 + 56);
  __int128 v11 = (char *)v37[1];
  BytePtr = CFDataGetBytePtr((CFDataRef)v37[0]);
  uint64_t v13 = *((void *)sub_100118DDC() + 1);
  *(void *)buf = BytePtr;
  *(void *)__int128 v40 = v13;
  if (v13)
  {
    __int128 v14 = (unint64_t *)(v13 + 8);
    do
      unint64_t v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
  }

  *(void *)&v40[8] = v11;
  *(void *)&v40[16] = v9;
  __int128 v41 = v11;
  char v42 = 0;
  unsigned int v16 = (*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v10 + 96LL))(v10, buf);
  __int128 v17 = *(std::__shared_weak_count **)v40;
  if (*(void *)v40)
  {
    uint64_t v18 = (unint64_t *)(*(void *)v40 + 8LL);
    do
      unint64_t v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  if ((v16 & 0x80000000) != 0)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = &off_100189E78;
    __int128 v34 = std::generic_category();
    exception[1] = v16;
    exception[2] = v34;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
    exception[7] = "Can't write UDIF resource part";
  }

  uint64_t v20 = *(void *)(a1 + 72);
  *(void *)(v20 + 224) = v11;
  __int128 v21 = &v11[v9];
  unint64_t v22 = (unint64_t)(v21 + 511) & 0xFFFFFFFFFFFFFE00LL;
  uint64_t v23 = operator new[](v22 - (void)v21 + 512);
  bzero(v23, v22 - (void)v21 + 512);
  sub_1000EB088(v20, (uint64_t)v23 + v22 - (void)v21);
  uint64_t v24 = *(void *)(a1 + 56);
  uint64_t v25 = *((void *)sub_100118DDC() + 1);
  *(void *)buf = v23;
  *(void *)__int128 v40 = v25;
  if (v25)
  {
    __int128 v26 = (unint64_t *)(v25 + 8);
    do
      unint64_t v27 = __ldxr(v26);
    while (__stxr(v27 + 1, v26));
  }

  *(void *)&v40[8] = v22 - (void)v21 + 512;
  *(void *)&v40[16] = v21;
  __int128 v41 = *(char **)&v40[8];
  char v42 = 0;
  unsigned int v28 = (*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v24 + 96LL))(v24, buf);
  __int128 v29 = *(std::__shared_weak_count **)v40;
  if (*(void *)v40)
  {
    __int128 v30 = (unint64_t *)(*(void *)v40 + 8LL);
    do
      unint64_t v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }

  if ((v28 & 0x80000000) != 0)
  {
    __int128 v35 = __cxa_allocate_exception(0x40uLL);
    *__int128 v35 = &off_100189E78;
    unint64_t v36 = std::generic_category();
    v35[1] = v28;
    v35[2] = v36;
    *((_BYTE *)v35 + 24) = 0;
    *((_BYTE *)v35 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
    v35[7] = "Can't write UDIF header";
  }

  operator delete[](v23);
  sub_100072048(v37);
  sub_1000114C0(&propertyList);
  return v22 + 512;
}

void sub_1000ECC30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

void *sub_1000ECCA8(void *a1, _DWORD *a2)
{
  if ((*a2 & 0x80000000) != 0)
  {
    uint64_t v5 = sub_100004E4C(a1, (uint64_t)"special: ", 9LL);
    if (*a2 == -1) {
      __int128 v6 = "ddm";
    }
    else {
      __int128 v6 = "entire_device";
    }
    if (*a2 == -1) {
      uint64_t v7 = 3LL;
    }
    else {
      uint64_t v7 = 13LL;
    }
    return sub_100004E4C(v5, (uint64_t)v6, v7);
  }

  else
  {
    int v3 = sub_100004E4C(a1, (uint64_t)"partition_num: ", 15LL);
    return (void *)std::ostream::operator<<(v3, *a2);
  }

void *sub_1000ECD24(void *a1, uint64_t a2)
{
  uint64_t v4 = sub_100004E4C(a1, (uint64_t)"Blocks header", 13LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v4 + *(void *)(*v4 - 24LL)));
  uint64_t v5 = std::locale::use_facet((const std::locale *)v81, &std::ctype<char>::id);
  uint64_t v6 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v5->__vftable[2].~facet_0)(v5, 10LL);
  std::locale::~locale((std::locale *)v81);
  std::ostream::put(v4, v6);
  std::ostream::flush(v4);
  uint64_t v8 = *(void *)(a2 + 8);
  uint64_t v7 = *(void *)(a2 + 16);
  uint64_t v9 = *(void *)(a2 + 24);
  uint64_t v10 = *(unsigned int *)(a2 + 32);
  int v11 = *(_DWORD *)(a2 + 36);
  __int128 v79 = *(_OWORD *)(a2 + 40);
  uint64_t v80 = *(void *)(a2 + 56);
  uint64_t v12 = *(void *)(a2 + 64);
  __int128 v13 = *(_OWORD *)(a2 + 152);
  __int128 v75 = *(_OWORD *)(a2 + 136);
  __int128 v76 = v13;
  __int128 v14 = *(_OWORD *)(a2 + 184);
  __int128 v77 = *(_OWORD *)(a2 + 168);
  __int128 v78 = v14;
  __int128 v15 = *(_OWORD *)(a2 + 88);
  __int128 v71 = *(_OWORD *)(a2 + 72);
  __int128 v72 = v15;
  __int128 v16 = *(_OWORD *)(a2 + 120);
  __int128 v73 = *(_OWORD *)(a2 + 104);
  __int128 v74 = v16;
  uint64_t v17 = *(unsigned int *)(a2 + 200);
  uint64_t v18 = sub_100004E4C(a1, (uint64_t)"signature", 9LL);
  unint64_t v19 = sub_100004E4C(v18, (uint64_t)": ", 2LL);
  v81[23] = 4;
  strcpy(v81, "mish");
  uint64_t v20 = sub_100004E4C(v19, (uint64_t)v81, 4LL);
  if ((v81[23] & 0x80000000) != 0) {
    operator delete(*(void **)v81);
  }
  std::ios_base::getloc((const std::ios_base *)((char *)v20 + *(void *)(*v20 - 24LL)));
  __int128 v21 = std::locale::use_facet((const std::locale *)v81, &std::ctype<char>::id);
  uint64_t v22 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v21->__vftable[2].~facet_0)(v21, 10LL);
  std::locale::~locale((std::locale *)v81);
  std::ostream::put(v20, v22);
  std::ostream::flush(v20);
  uint64_t v23 = sub_100004E4C(a1, (uint64_t)"version", 7LL);
  uint64_t v24 = sub_100004E4C(v23, (uint64_t)": ", 2LL);
  uint64_t v25 = (void *)std::ostream::operator<<(v24, 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v25 + *(void *)(*v25 - 24LL)));
  __int128 v26 = std::locale::use_facet((const std::locale *)v81, &std::ctype<char>::id);
  uint64_t v27 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v26->__vftable[2].~facet_0)(v26, 10LL);
  std::locale::~locale((std::locale *)v81);
  std::ostream::put(v25, v27);
  std::ostream::flush(v25);
  unsigned int v28 = sub_100004E4C(a1, (uint64_t)"first_sector_number", 19LL);
  __int128 v29 = sub_100004E4C(v28, (uint64_t)": ", 2LL);
  __int128 v30 = (void *)std::ostream::operator<<(v29, v8);
  std::ios_base::getloc((const std::ios_base *)((char *)v30 + *(void *)(*v30 - 24LL)));
  unint64_t v31 = std::locale::use_facet((const std::locale *)v81, &std::ctype<char>::id);
  uint64_t v32 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v31->__vftable[2].~facet_0)(v31, 10LL);
  std::locale::~locale((std::locale *)v81);
  std::ostream::put(v30, v32);
  std::ostream::flush(v30);
  __int128 v33 = sub_100004E4C(a1, (uint64_t)"sector_count", 12LL);
  __int128 v34 = sub_100004E4C(v33, (uint64_t)": ", 2LL);
  __int128 v35 = (void *)std::ostream::operator<<(v34, v7);
  std::ios_base::getloc((const std::ios_base *)((char *)v35 + *(void *)(*v35 - 24LL)));
  unint64_t v36 = std::locale::use_facet((const std::locale *)v81, &std::ctype<char>::id);
  uint64_t v37 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v36->__vftable[2].~facet_0)(v36, 10LL);
  std::locale::~locale((std::locale *)v81);
  std::ostream::put(v35, v37);
  std::ostream::flush(v35);
  __int128 v38 = sub_100004E4C(a1, (uint64_t)"data_start", 10LL);
  __int128 v39 = sub_100004E4C(v38, (uint64_t)": ", 2LL);
  uint64_t v40 = *v39;
  __int128 v41 = (char *)v39 + *(void *)(*v39 - 24);
  LODWORD(v37) = *((_DWORD *)v41 + 2);
  *((_DWORD *)v41 + 2) = v37 & 0xFFFFFFB5 | 8;
  *(_DWORD *)((char *)v39 + *(void *)(v40 - 24) + 8) |= 0x200u;
  v81[0] = 48;
  char v42 = sub_1000166BC(v39, v81);
  std::ostream::operator<<(v42, v9);
  uint64_t v43 = *v39;
  *(_DWORD *)((char *)v39 + *(void *)(*v39 - 24) + _Block_object_dispose((const void *)(v2 - 120), 8) = v37;
  std::ios_base::getloc((const std::ios_base *)((char *)v39 + *(void *)(v43 - 24)));
  __int128 v44 = std::locale::use_facet((const std::locale *)v81, &std::ctype<char>::id);
  uint64_t v45 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v44->__vftable[2].~facet_0)(v44, 10LL);
  std::locale::~locale((std::locale *)v81);
  std::ostream::put(v39, v45);
  std::ostream::flush(v39);
  std::unique_lock<std::mutex> v46 = sub_100004E4C(a1, (uint64_t)"decompression_buffer_req", 24LL);
  uint64_t v47 = sub_100004E4C(v46, (uint64_t)": ", 2LL);
  unint64_t v48 = (void *)std::ostream::operator<<(v47, v10);
  std::ios_base::getloc((const std::ios_base *)((char *)v48 + *(void *)(*v48 - 24LL)));
  uint64_t v49 = std::locale::use_facet((const std::locale *)v81, &std::ctype<char>::id);
  uint64_t v50 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v49->__vftable[2].~facet_0)(v49, 10LL);
  std::locale::~locale((std::locale *)v81);
  std::ostream::put(v48, v50);
  std::ostream::flush(v48);
  LODWORD(v70.__locale_) = v11;
  unint64_t v51 = sub_100004E4C(a1, (uint64_t)"descriptor", 10LL);
  uint64_t v52 = sub_100004E4C(v51, (uint64_t)": ", 2LL);
  uint64_t v53 = sub_1000ECCA8(v52, &v70);
  std::ios_base::getloc((const std::ios_base *)((char *)v53 + *(void *)(*v53 - 24LL)));
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v54 = std::locale::use_facet((const std::locale *)v81, &std::ctype<char>::id);
  uint64_t v55 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v54->__vftable[2].~facet_0)(v54, 10LL);
  std::locale::~locale((std::locale *)v81);
  std::ostream::put(v53, v55);
  std::ostream::flush(v53);
  *(_OWORD *)uint64_t v81 = v79;
  *(void *)&v81[16] = v80;
  uint64_t v56 = sub_100004E4C(a1, (uint64_t)"reserved", 8LL);
  uint64_t v57 = sub_100004E4C(v56, (uint64_t)": ", 2LL);
  sub_1000F4658(v57, v81, 24LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v57 + *(void *)(*v57 - 24LL)));
  uint64_t v58 = std::locale::use_facet(&v70, &std::ctype<char>::id);
  uint64_t v59 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v58->__vftable[2].~facet_0)(v58, 10LL);
  std::locale::~locale(&v70);
  std::ostream::put(v57, v59);
  std::ostream::flush(v57);
  *(void *)uint64_t v81 = v12;
  __int128 v85 = v75;
  __int128 v86 = v76;
  __int128 v87 = v77;
  __int128 v88 = v78;
  *(_OWORD *)&v81[8] = v71;
  __int128 v82 = v72;
  __int128 v83 = v73;
  __int128 v84 = v74;
  __int128 v60 = sub_100004E4C(a1, (uint64_t)"checksum", 8LL);
  uint64_t v61 = sub_100004E4C(v60, (uint64_t)": ", 2LL);
  sub_1000ED4B8(v61, v81);
  std::ios_base::getloc((const std::ios_base *)((char *)v61 + *(void *)(*v61 - 24LL)));
  __int128 v62 = std::locale::use_facet(&v70, &std::ctype<char>::id);
  uint64_t v63 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v62->__vftable[2].~facet_0)(v62, 10LL);
  std::locale::~locale(&v70);
  std::ostream::put(v61, v63);
  std::ostream::flush(v61);
  uint64_t v64 = sub_100004E4C(a1, (uint64_t)"run_count", 9LL);
  uint64_t v65 = sub_100004E4C(v64, (uint64_t)": ", 2LL);
  uint64_t v66 = (void *)std::ostream::operator<<(v65, v17);
  std::ios_base::getloc((const std::ios_base *)((char *)v66 + *(void *)(*v66 - 24LL)));
  unint64_t v67 = std::locale::use_facet((const std::locale *)v81, &std::ctype<char>::id);
  uint64_t v68 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v67->__vftable[2].~facet_0)(v67, 10LL);
  std::locale::~locale((std::locale *)v81);
  std::ostream::put(v66, v68);
  std::ostream::flush(v66);
  return a1;
}

void sub_1000ED454( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, void *__p, uint64_t a32, int a33, __int16 a34, char a35, char a36)
{
  if (a36 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1000ED4B8(void *a1, unsigned __int8 *a2)
{
  int v4 = *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24LL) + 8);
  uint64_t v5 = sub_100004E4C(a1, (uint64_t)"type: ", 6LL);
  int v17 = *(_DWORD *)a2;
  uint64_t v6 = sub_10002538C(v5, &v17);
  uint64_t v7 = sub_100004E4C(v6, (uint64_t)" ", 1LL);
  *(_DWORD *)((char *)v7 + *(void *)(*v7 - 24LL) + _Block_object_dispose((const void *)(v2 - 120), 8) = *(_DWORD *)((_BYTE *)v7 + *(void *)(*v7 - 24LL) + 8) & 0xFFFFFFB5 | 8;
  char v16 = 48;
  uint64_t v8 = sub_1000166BC(v7, &v16);
  uint64_t v9 = *v8;
  *(uint64_t *)((char *)v8 + *(void *)(*v8 - 24) + 24) = 2LL;
  int v10 = *(_DWORD *)((char *)v8 + *(void *)(v9 - 24) + 8);
  int v11 = sub_100004E4C(v8, (uint64_t)"len: ", 5LL);
  uint64_t v12 = (void *)std::ostream::operator<<(v11, *((unsigned int *)a2 + 1));
  __int128 v13 = sub_100004E4C(v12, (uint64_t)" data: ", 7LL);
  *(_DWORD *)((char *)v13 + *(void *)(*v13 - 24LL) + _Block_object_dispose((const void *)(v2 - 120), 8) = *(_DWORD *)((_BYTE *)v13 + *(void *)(*v13 - 24LL) + 8) & 0xFFFFFFB5 | 8;
  uint64_t v14 = *((unsigned int *)a2 + 1);
  if ((_DWORD)v14) {
    sub_1000F4658(v8, a2 + 8, v14);
  }
  else {
    sub_100004E4C(v8, (uint64_t)"(empty)", 7LL);
  }
  *(_DWORD *)((char *)v8 + *(void *)(*v8 - 24) + _Block_object_dispose((const void *)(v2 - 120), 8) = v10;
  *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24LL) + _Block_object_dispose((const void *)(v2 - 120), 8) = v4;
  return a1;
}

void *sub_1000ED618()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_100198FF0);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_100198FF0))
  {
    sub_1000F1940(v2, -2147483643);
    v2[1] = 0;
    sub_1000F1940(v3, -2147483641);
    v3[1] = 1;
    sub_1000F1940(v4, -2147483640);
    v4[1] = 2;
    sub_1000F1940(v5, -2147483642);
    v5[1] = 4;
    sub_1000F47E8((uint64_t)&unk_100198FD8, (unsigned int *)v2, 4LL);
    __cxa_atexit((void (*)(void *))sub_1000ED758, &unk_100198FD8, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_100198FF0);
  }

  return &unk_100198FD8;
}

void sub_1000ED730(_Unwind_Exception *a1)
{
}

uint64_t sub_1000ED758(uint64_t a1)
{
  return a1;
}

void *sub_1000ED780@<X0>(unsigned int *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v4 = qword_100198FE0;
  if (!qword_100198FE0) {
    goto LABEL_12;
  }
  unsigned int v5 = *a1;
  uint64_t v6 = &qword_100198FE0;
  do
  {
    unsigned int v7 = *(_DWORD *)(v4 + 28);
    BOOL v8 = v7 >= v5;
    if (v7 >= v5) {
      uint64_t v9 = (uint64_t *)v4;
    }
    else {
      uint64_t v9 = (uint64_t *)(v4 + 8);
    }
    if (v8) {
      uint64_t v6 = (uint64_t *)v4;
    }
    uint64_t v4 = *v9;
  }

  while (*v9);
  if (v6 != &qword_100198FE0 && v5 >= *((_DWORD *)v6 + 7))
  {
    uint64_t result = sub_1000ED618();
    *(_DWORD *)a2 = *((_DWORD *)v6 + 8);
    char v11 = 1;
  }

  else
  {
LABEL_12:
    uint64_t result = sub_1000ED618();
    char v11 = 0;
    *(_BYTE *)a2 = 0;
  }

  *(_BYTE *)(a2 + 4) = v11;
  return result;
}

uint64_t **sub_1000ED814(uint64_t **result, uint64_t **a2, _DWORD *a3, uint64_t *a4, uint64_t *a5)
{
  if (HIBYTE(*a3) == 128)
  {
    uint64_t v9 = result;
    int v14 = *a3;
    ((void (*)(_DWORD **__return_ptr, uint64_t **, int *))(*result)[2])(v13, result, &v14);
    if (!BYTE4(v13[0]))
    {
      exception = __cxa_allocate_exception(0x40uLL);
      sub_100004D60((uint64_t)v13);
      sub_100004E4C(v13, (uint64_t)"Unsupported compressed run (", 28LL);
      int v15 = *a3;
      sub_100026D4C(v13, &v15);
      sub_100004E4C(v13, (uint64_t)")", 1LL);
      sub_10001161C((uint64_t)exception, (uint64_t)v13, 0x2Du);
    }

    v13[0] = a3;
    int v10 = sub_1000F4A90(a2, a3, (uint64_t)&unk_100139230, v13)[5];
    if (v10)
    {
      v13[0] = a3;
      int v10 = sub_1000F4A90(a2, a3, (uint64_t)&unk_100139230, v13)[5];
    }

    if (v10 > a4) {
      a4 = v10;
    }
    v13[0] = a3;
    uint64_t result = sub_1000F4A90(a2, a3, (uint64_t)&unk_100139230, v13);
    result[5] = a4;
    *((_BYTE *)v9 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = 1;
    char v11 = v9[12];
    if (v11 <= a5) {
      char v11 = a5;
    }
    v9[12] = v11;
  }

  return result;
}

void sub_1000ED994( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1000ED9C8(uint64_t a1, void *a2)
{
  uint64_t v6 = (void *)*a2;
  uint64_t v4 = a2 + 1;
  unsigned int v5 = v6;
  if (v6 != v4)
  {
    do
    {
      int v10 = *((_DWORD *)v5 + 8);
      sub_1000EDA70(a1, &v10, v5[5]);
      unsigned int v7 = (void *)v5[1];
      if (v7)
      {
        do
        {
          BOOL v8 = v7;
          unsigned int v7 = (void *)*v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          BOOL v8 = (void *)v5[2];
          BOOL v9 = *v8 == (void)v5;
          unsigned int v5 = v8;
        }

        while (!v9);
      }

      unsigned int v5 = v8;
    }

    while (v8 != v4);
  }

void sub_1000EDA70(uint64_t a1, _DWORD *a2, size_t a3)
{
  if (*a2 == 1)
  {
    sub_1000F1940((int *)&v17, 1);
    *(void *)&__int128 v14 = &v17;
    uint64_t v4 = sub_10004CF9C((uint64_t **)(a1 + 104), (unsigned int *)&v17, (uint64_t)&unk_100139230, (_DWORD **)&v14);
    sub_100026A1C(v4 + 5, (uint64_t *)(a1 + 56));
  }

  else
  {
    int v15 = *a2;
    (*(void (**)(uint64_t *__return_ptr, uint64_t, int *))(*(void *)a1 + 16LL))(&v16, a1, &v15);
    if (!BYTE4(v16))
    {
      exception = __cxa_allocate_exception(0x40uLL);
      uint64_t v12 = (void *)sub_100004870((uint64_t)exception, (uint64_t)"UDIF: compression algo is invalid", 0x16u);
    }

    int v13 = v16;
    sub_100037604((void *)(a1 + 56), &v13, a3, &v14);
    int v17 = a2;
    unsigned int v7 = sub_10004CF9C((uint64_t **)(a1 + 104), a2, (uint64_t)&unk_100139230, &v17);
    sub_100014DF0((uint64_t)(v7 + 5), &v14);
    BOOL v8 = (std::__shared_weak_count *)*((void *)&v14 + 1);
    if (*((void *)&v14 + 1))
    {
      BOOL v9 = (unint64_t *)(*((void *)&v14 + 1) + 8LL);
      do
        unint64_t v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
  }

void sub_1000EDBC8(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_1000EDBDC(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __int128 v35 = 0LL;
  uint64_t v36 = 0LL;
  __int128 v34 = (uint64_t *)&v35;
  (*(void (**)(__int128 *__return_ptr))(**(void **)(a1 + 56) + 72LL))(&v33);
  uint64_t v4 = *(unsigned int **)(a1 + 104);
  if (v4 != (unsigned int *)(a1 + 112))
  {
    do
    {
      unsigned int v5 = (const void *)*((void *)v4 + 5);
      if (v5 == *(const void **)(a1 + 56))
      {
        unint64_t v31 = v4 + 8;
        uint64_t v22 = sub_10004CF9C(&v34, v4 + 8, (uint64_t)&unk_100139230, &v31);
        sub_100026A1C(v22 + 5, (uint64_t *)&v33);
      }

      else if (v5)
      {
        if (v6)
        {
          unsigned int v7 = (std::__shared_weak_count *)*((void *)v4 + 6);
          unint64_t v31 = v6;
          uint64_t v32 = v7;
          if (v7)
          {
            uint64_t p_shared_owners = (unint64_t *)&v7->__shared_owners_;
            do
              unint64_t v9 = __ldxr(p_shared_owners);
            while (__stxr(v9 + 1, p_shared_owners));
          }

          __int128 v29 = v33;
          if (*((void *)&v33 + 1))
          {
            unint64_t v10 = (unint64_t *)(*((void *)&v33 + 1) + 8LL);
            do
              unint64_t v11 = __ldxr(v10);
            while (__stxr(v11 + 1, v10));
          }

          (*(void (**)(__int128 *__return_ptr, _DWORD *, __int128 *))(*(void *)v6 + 176LL))(&v30, v6, &v29);
          uint64_t v37 = v4 + 8;
          uint64_t v12 = sub_10004CF9C(&v34, v4 + 8, (uint64_t)&unk_100139230, &v37);
          sub_100014DF0((uint64_t)(v12 + 5), &v30);
          int v13 = (std::__shared_weak_count *)*((void *)&v30 + 1);
          if (*((void *)&v30 + 1))
          {
            __int128 v14 = (unint64_t *)(*((void *)&v30 + 1) + 8LL);
            do
              unint64_t v15 = __ldaxr(v14);
            while (__stlxr(v15 - 1, v14));
            if (!v15)
            {
              ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
              std::__shared_weak_count::__release_weak(v13);
            }
          }

          uint64_t v16 = (std::__shared_weak_count *)*((void *)&v29 + 1);
          if (*((void *)&v29 + 1))
          {
            int v17 = (unint64_t *)(*((void *)&v29 + 1) + 8LL);
            do
              unint64_t v18 = __ldaxr(v17);
            while (__stlxr(v18 - 1, v17));
            if (!v18)
            {
              ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
              std::__shared_weak_count::__release_weak(v16);
            }
          }

          unint64_t v19 = v32;
          if (v32)
          {
            uint64_t v20 = (unint64_t *)&v32->__shared_owners_;
            do
              unint64_t v21 = __ldaxr(v20);
            while (__stlxr(v21 - 1, v20));
            if (!v21)
            {
              ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
              std::__shared_weak_count::__release_weak(v19);
            }
          }
        }
      }

      uint64_t v23 = (unsigned int *)*((void *)v4 + 1);
      if (v23)
      {
        do
        {
          uint64_t v24 = v23;
          uint64_t v23 = *(unsigned int **)v23;
        }

        while (v23);
      }

      else
      {
        do
        {
          uint64_t v24 = (unsigned int *)*((void *)v4 + 2);
          BOOL v25 = *(void *)v24 == (void)v4;
          uint64_t v4 = v24;
        }

        while (!v25);
      }

      uint64_t v4 = v24;
    }

    while (v24 != (unsigned int *)(a1 + 112));
  }

  __int128 v26 = v35;
  *(void *)a2 = v34;
  *(void *)(a2 + _Block_object_dispose((const void *)(v2 - 120), 8) = v26;
  uint64_t v27 = a2 + 8;
  uint64_t v28 = v36;
  *(void *)(a2 + 16) = v36;
  if (v28)
  {
    v26[2] = v27;
    __int128 v34 = (uint64_t *)&v35;
    __int128 v35 = 0LL;
    uint64_t v36 = 0LL;
    __int128 v26 = 0LL;
  }

  else
  {
    *(void *)a2 = v27;
  }

  *(_OWORD *)(a2 + 24) = v33;
  sub_10004BB88((uint64_t)&v34, v26);
}

void sub_1000EDE68( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, void *a19)
{
}

uint64_t sub_1000EDEB8(uint64_t result)
{
  uint64_t v1 = *(void **)(result + 8);
  if (v1 != (void *)(result + 16))
  {
    do
    {
      if (*((unsigned __int8 *)v1 + 59) == 128
        && (v1[5] - v1[4] + (unint64_t)(v1[6] & 1) + ((*((unsigned __int8 *)v1 + 48) >> 1) & 1) - 1) << 9 > 0x400000)
      {
        uint64_t v7 = (v1[5] - v1[4] + (v1[6] & 1) + ((*((unsigned __int8 *)v1 + 48) >> 1) & 1) - 1) << 9;
        BOOL v8 = v1;
        *(void *)&__int128 v10 = "udif::details::UDIF_base::validate_runs()";
        *((void *)&v10 + sub_1000F1940(&v11, 1) = 39LL;
        int v11 = 16;
        sub_1000EE0BC(v12, &v10);
        sub_100004E4C(v13, (uint64_t)"Run interval: ", 14LL);
        sub_1000E44C8(v13, (uint64_t)(v8 + 4));
        sub_100004E4C(v13, (uint64_t)" of type ", 9LL);
        LODWORD(v9) = *((_DWORD *)v8 + 14);
        sub_100026D4C(v13, &v9);
        sub_100004E4C(v13, (uint64_t)" has size ", 10LL);
        std::ostream::operator<<(v13, v7);
        sub_100004E4C(v13, (uint64_t)"which is larger than allowed ", 29LL);
        std::ostream::operator<<(v13, 0x400000LL);
        sub_100004E4C(v13, (uint64_t)" or exceeds size_t size ", 24LL);
        uint64_t v9 = -1LL;
        sub_1000EE090((uint64_t)v12, &v9);
        sub_1000EE164((uint64_t)v12);
        exception = __cxa_allocate_exception(0x40uLL);
        uint64_t v6 = (void *)sub_100004870((uint64_t)exception, (uint64_t)"UDIF: compressed runs should be <= 1MB", 0x16u);
      }

      uint64_t v2 = (void *)v1[1];
      if (v2)
      {
        do
        {
          int v3 = v2;
          uint64_t v2 = (void *)*v2;
        }

        while (v2);
      }

      else
      {
        do
        {
          int v3 = (void *)v1[2];
          BOOL v4 = *v3 == (void)v1;
          uint64_t v1 = v3;
        }

        while (!v4);
      }

      uint64_t v1 = v3;
    }

    while (v3 != (void *)(result + 16));
  }

  return result;
}

void sub_1000EE074( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

uint64_t sub_1000EE090(uint64_t a1, void *a2)
{
  return a1;
}

void *sub_1000EE0BC(void *a1, __int128 *a2)
{
  int v3 = (std::ios_base *)(a1 + 46);
  sub_1000F4B50((uint64_t)a1, a2);
  *a1 = off_100183AC8;
  a1[45] = &off_100183BC8;
  a1[46] = &off_100183BF0;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_100183AC8;
  a1[45] = off_100183B50;
  a1[46] = off_100183B78;
  return a1;
}

void sub_1000EE140(_Unwind_Exception *a1)
{
}

uint64_t sub_1000EE164(uint64_t a1)
{
  return a1;
}

uint64_t *sub_1000EE1A4(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  unsigned int v5 = (uint64_t **)(a1 + 32);
  if (a1 + 40 != sub_1000F4BCC(a1 + 32, a2))
  {
    exception = __cxa_allocate_exception(0x40uLL);
    __int128 v10 = (void *)sub_100004870((uint64_t)exception, (uint64_t)"Invalid UDIF format, contains intersected blocks", 0x16u);
  }

  int v6 = *((_DWORD *)a3 + 2);
  __int128 v19 = *(_OWORD *)((char *)a3 + 76);
  __int128 v20 = *(_OWORD *)((char *)a3 + 92);
  __int128 v21 = *(_OWORD *)((char *)a3 + 108);
  __int128 v22 = *(_OWORD *)((char *)a3 + 124);
  __int128 v15 = *(_OWORD *)((char *)a3 + 12);
  __int128 v16 = *(_OWORD *)((char *)a3 + 28);
  __int128 v17 = *(_OWORD *)((char *)a3 + 44);
  __int128 v18 = *(_OWORD *)((char *)a3 + 60);
  uint64_t v7 = *a3;
  uint64_t v12 = *(void *)(a2 + 16);
  __int128 v11 = *(_OWORD *)a2;
  uint64_t v13 = v7;
  int v14 = v6;
  char v23 = 1;
  return sub_1000F4C50(v5, (uint64_t)&v11);
}

void sub_1000EE2C0(uint64_t a1, CFArrayRef theArray)
{
  unint64_t Count = CFArrayGetCount(theArray);
  CFIndex v5 = Count;
  if (Count >> 61) {
    size_t v6 = -1LL;
  }
  else {
    size_t v6 = 8 * Count;
  }
  uint64_t v7 = operator new[](v6);
  bzero(v7, v6);
  v45[0] = 0LL;
  v45[1] = 0LL;
  __int128 v44 = (uint64_t *)v45;
  v69.location = 0LL;
  v69.length = v5;
  __p = v7;
  CFArrayGetValues(theArray, v69, (const void **)v7);
  if (v5 < 1)
  {
    unint64_t v26 = 0LL;
  }

  else
  {
    unint64_t v8 = 0LL;
    uint64_t v9 = 0LL;
    unsigned int v36 = 0;
    CFIndex v33 = v5;
    do
    {
      uint64_t v35 = v9;
      __int128 v10 = (const void *)__p[v9];
      CFTypeID TypeID = CFDictionaryGetTypeID();
      if (v10)
      {
        CFTypeID v12 = TypeID;
        if (CFGetTypeID(v10) != TypeID)
        {
          exception = __cxa_allocate_exception(0x40uLL);
          CFTypeID v30 = CFGetTypeID(v10);
          unint64_t v31 = exception;
          uint64_t v32 = v12;
LABEL_34:
          sub_100026B08(v31, v30, v32);
        }
      }

      Value = CFDictionaryGetValue((CFDictionaryRef)v10, @"Data");
      CFTypeID v14 = CFDataGetTypeID();
      if (!Value)
      {
        uint64_t v27 = __cxa_allocate_exception(0x40uLL);
        *uint64_t v27 = &off_100189E78;
        uint64_t v28 = std::generic_category();
        v27[1] = 22LL;
        void v27[2] = v28;
        *((_BYTE *)v27 + 24) = 0;
        *((_BYTE *)v27 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
        v27[7] = "UDIF: Can't find data key in dictionary";
      }

      CFTypeID v15 = v14;
      if (CFGetTypeID(Value) != v14)
      {
        exception = __cxa_allocate_exception(0x40uLL);
        CFTypeID v30 = CFGetTypeID(Value);
        unint64_t v31 = exception;
        uint64_t v32 = v15;
        goto LABEL_34;
      }

      CFIndex Length = CFDataGetLength((CFDataRef)Value);
      __int128 v17 = operator new[](Length);
      bzero(v17, Length);
      v70.length = CFDataGetLength((CFDataRef)Value);
      v70.location = 0LL;
      CFDataGetBytes((CFDataRef)Value, v70, (UInt8 *)v17);
      sub_1000EFE14((uint64_t)&v55, (uint64_t)v17);
      if (sub_1000B866C())
      {
        *(void *)&__int128 v40 = "udif::details::UDIF_base::generate_blocks(CFArrayRef)";
        *((void *)&v40 + sub_1000F1940(&v11, 1) = 41LL;
        int v41 = 2;
        sub_1000EE8C4(v46, &v40);
        sub_1000ECD24(&v53, (uint64_t)&v55);
        std::ios_base::getloc((const std::ios_base *)&v54[*(void *)(v53 - 24) - 8]);
        __int128 v18 = std::locale::use_facet(v38, &std::ctype<char>::id);
        uint64_t v19 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v18->__vftable[2].~facet_0)(v18, 10LL);
        std::locale::~locale(v38);
        std::ostream::put(&v53, v19);
        std::ostream::flush(&v53);
        std::ostream::~ostream(&v53, off_100183DB0);
        sub_1000F2150((uint64_t)v46);
        std::ios::~ios(v54);
      }

      *(void *)&__int128 v40 = *((void *)&v55 + 1);
      *((void *)&v40 + sub_1000F1940(&v11, 1) = v56 + *((void *)&v55 + 1);
      LOBYTE(vmemset(v5, 0, 41) = 2;
      *(_DWORD *)std::unique_lock<std::mutex> v46 = v58;
      *(void *)&v46[4] = v59;
      __int128 v49 = v64;
      __int128 v50 = v65;
      __int128 v51 = v66;
      __int128 v52 = v67;
      *(_OWORD *)&v46[12] = v60;
      *(_OWORD *)uint64_t v47 = v61;
      *(_OWORD *)&v47[16] = v62;
      __int128 v48 = v63;
      sub_1000EE1A4(a1, (uint64_t)&v40, (uint64_t *)v46);
      if (v68)
      {
        unsigned int v20 = 0;
        uint64_t v21 = (uint64_t)v17 + 204;
        do
        {
          sub_1000F008C((uint64_t)&v40, v21);
          sub_1000EC6D0((uint64_t)&v40, (uint64_t)&v55, (uint64_t)v38);
          if (v40 < 2 || (v40 & 0xFF000000) == 0x80000000)
          {
            int v37 = v40;
            sub_1000ED814( (uint64_t **)a1,  &v44,  &v37,  v43,  (uint64_t *)((v38[1].__locale_ - v38[0].__locale_ + (v39 & 1) + ((v39 >> 1) & 1) - 1) << 9));
            uint64_t v23 = v57 + v42 + *(void *)(*(void *)(a1 + 72) + 24LL);
            *(_OWORD *)std::unique_lock<std::mutex> v46 = *(_OWORD *)&v38[0].__locale_;
            *(void *)&v46[16] = v39;
            *(_DWORD *)&v46[24] = v40;
            *(void *)&v47[4] = v23;
            *(void *)&v47[12] = v43;
            sub_1000F5430((uint64_t **)(a1 + 8), (uint64_t)v46);
            unint64_t v24 = v42;
            if (v42 < v8) {
              *(_BYTE *)(a1 + 89) = 0;
            }
          }

          else
          {
            unint64_t v24 = v8;
          }

          ++v20;
          v21 += 40LL;
          unint64_t v8 = v24;
        }

        while (v20 < v68);
      }

      else
      {
        unint64_t v24 = v8;
      }

      if (v36 <= v58) {
        unsigned int v25 = v58;
      }
      else {
        unsigned int v25 = v36;
      }
      unsigned int v36 = v25;
      operator delete[](v17);
      uint64_t v9 = v35 + 1;
      unint64_t v8 = v24;
    }

    while (v35 + 1 != v33);
    unint64_t v26 = (unint64_t)v36 << 9;
  }

  sub_1000EDEB8(a1);
  *(void *)&__int128 v55 = "udif::details::UDIF_base::generate_blocks(CFArrayRef)";
  *((void *)&v55 + sub_1000F1940(&v11, 1) = 41LL;
  LODWORD(v56) = 0;
  sub_1000EE9B0(v46, &v55);
  sub_100004E4C(&v53, (uint64_t)"UDIF - max compressed run size: ", 32LL);
  std::ostream::operator<<(&v53, *(void *)(a1 + 96));
  sub_100004E4C(&v53, (uint64_t)", required decompression buffer size: ", 38LL);
  std::ostream::operator<<(&v53, v26);
  std::ostream::~ostream(&v53, off_100183FD0);
  sub_1000F26FC((uint64_t)v46);
  std::ios::~ios(v54);
  sub_1000ED9C8(a1, &v44);
  sub_100026AC4((uint64_t)&v44, v45[0]);
  operator delete[](__p);
}

void sub_1000EE81C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, uint64_t a17, std::locale a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26, void *a27, uint64_t a28, char a29)
{
}

void *sub_1000EE8C4(void *a1, __int128 *a2)
{
  int v3 = (std::ios_base *)(a1 + 46);
  sub_1000F53B4((uint64_t)a1, a2);
  *a1 = off_100183CE8;
  a1[45] = &off_100183DE8;
  a1[46] = &off_100183E10;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_100183CE8;
  a1[45] = off_100183D70;
  a1[46] = off_100183D98;
  return a1;
}

void sub_1000EE948(_Unwind_Exception *a1)
{
}

uint64_t sub_1000EE96C(uint64_t a1)
{
  return a1;
}

void *sub_1000EE9B0(void *a1, __int128 *a2)
{
  int v3 = (std::ios_base *)(a1 + 46);
  sub_1000F5C10((uint64_t)a1, a2);
  *a1 = off_100183F08;
  a1[45] = &off_100184008;
  a1[46] = &off_100184030;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_100183F08;
  a1[45] = off_100183F90;
  a1[46] = off_100183FB8;
  return a1;
}

void sub_1000EEA34(_Unwind_Exception *a1)
{
}

uint64_t sub_1000EEA58(uint64_t a1)
{
  return a1;
}

uint64_t *sub_1000EEA98()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_100199010);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_100199010))
  {
    sub_1000F1940(&v2, 0);
    __int128 v3 = xmmword_100140DF0;
    char v4 = 2;
    int v5 = v2;
    uint64_t v6 = 0LL;
    uint64_t v7 = 0LL;
    sub_1000F5C8C((uint64_t)&qword_100198FF8, (unint64_t *)&v3, 1LL);
    __cxa_atexit((void (*)(void *))sub_1000EEB98, &qword_100198FF8, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_100199010);
  }

  return &qword_100198FF8;
}

void sub_1000EEB7C(_Unwind_Exception *a1)
{
}

uint64_t sub_1000EEB98(uint64_t a1)
{
  return a1;
}

uint64_t sub_1000EEBC0(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  v6[0] = a2 / a4;
  v6[1] = (a3 + a2) / a4;
  char v7 = 2;
  uint64_t result = sub_1000AC868(a1 + 8, (uint64_t)v6);
  if (a1 + 16 == result)
  {
    sub_1000EEA98();
    return qword_100198FF8;
  }

  return result;
}

void sub_1000EEC20(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v5 = a3;
  uint64_t v8 = sub_1000EEBC0(a1, a2, a3, 0x200uLL);
  if (v5)
  {
    uint64_t v9 = (void *)v8;
    uint64_t v10 = a1 + 16;
    unint64_t v11 = a2;
    while (v9 != (void *)v10)
    {
      uint64_t v12 = v9[4];
      unint64_t v13 = v12 << 9;
      if (v11 < v12 << 9) {
        goto LABEL_11;
      }
      uint64_t v14 = (v9[5] - v12) << 9;
      if (v14 - (v11 - v13) >= v5) {
        unint64_t v15 = v5;
      }
      else {
        unint64_t v15 = v14 - (v11 - v13);
      }
      unsigned int v16 = *((_DWORD *)v9 + 14);
      unsigned int v29 = v16;
      if (HIBYTE(v16) == 128)
      {
        __int128 v30 = *((_OWORD *)v9 + 4);
        *(void *)&__int128 v31 = v13;
        *((void *)&v31 + sub_1000F1940(&v11, 1) = v14;
        *(void *)&__int128 v32 = v11 - a2;
        *((void *)&v32 + sub_1000F1940(&v11, 1) = v11 - v13;
      }

      else
      {
        *(void *)&__int128 v30 = v9[8] + v11 - v13;
        *((void *)&v30 + sub_1000F1940(&v11, 1) = v15;
        *(void *)&__int128 v31 = v11;
        *((void *)&v31 + sub_1000F1940(&v11, 1) = v15;
        __int128 v32 = v11 - a2;
      }

      unint64_t v33 = v15;
      uint64_t v22 = a4[1];
      uint64_t v23 = *a4 + (v22 << 6);
      if (v22 == a4[2])
      {
        sub_1000F5F2C(a4, v23, 1LL, (uint64_t)&v29, &v34);
      }

      else
      {
        *(_DWORD *)uint64_t v23 = v16;
        __int128 v24 = v30;
        __int128 v25 = v31;
        __int128 v26 = v32;
        *(void *)(v23 + 56) = v33;
        *(_OWORD *)(v23 + 40) = v26;
        *(_OWORD *)(v23 + 24) = v25;
        *(_OWORD *)(v23 + _Block_object_dispose((const void *)(v2 - 120), 8) = v24;
        ++a4[1];
      }

      uint64_t v27 = (void *)v9[1];
      if (v27)
      {
        do
        {
          uint64_t v9 = v27;
          uint64_t v27 = (void *)*v27;
        }

        while (v27);
      }

      else
      {
        do
        {
          uint64_t v28 = v9;
          uint64_t v9 = (void *)v9[2];
        }

        while ((void *)*v9 != v28);
      }

uint64_t sub_1000EEE2C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1 + 8;
  uint64_t v4 = sub_1000AC868(a1 + 8, a2);
  sub_1000AC540(v3, a2);
  return v4;
}

uint64_t sub_1000EEE74(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t sub_1000EEE84(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4)
{
  if (sub_10004A1C4(a4, v16))
  {
    *(void *)&__int128 v14 = "udif::details::UDIF_base::print_checksum_verification_status(const std::string &, const csum_any &, const details::checksum &) const";
    *((void *)&v14 + sub_1000F1940(&v11, 1) = 60LL;
    int v15 = 0;
    sub_1000EF070(v16, &v14);
    int v7 = *(char *)(a2 + 23);
    if (v7 >= 0) {
      uint64_t v8 = a2;
    }
    else {
      uint64_t v8 = *(void *)a2;
    }
    if (v7 >= 0) {
      uint64_t v9 = *(unsigned __int8 *)(a2 + 23);
    }
    else {
      uint64_t v9 = *(void *)(a2 + 8);
    }
    sub_100004E4C(&v17, v8, v9);
    sub_100004E4C(&v17, (uint64_t)" - same ", 8LL);
    sub_1000F61D0((uint64_t)&v17, a3);
    std::ostream::~ostream(&v17, off_1001841F0);
    sub_1000F2CA8((uint64_t)v16);
  }

  else
  {
    *(void *)&__int128 v14 = "udif::details::UDIF_base::print_checksum_verification_status(const std::string &, const csum_any &, const details::checksum &) const";
    *((void *)&v14 + sub_1000F1940(&v11, 1) = 60LL;
    int v15 = 0;
    sub_1000EF158(v16, &v14);
    int v10 = *(char *)(a2 + 23);
    if (v10 >= 0) {
      uint64_t v11 = a2;
    }
    else {
      uint64_t v11 = *(void *)a2;
    }
    if (v10 >= 0) {
      uint64_t v12 = *(unsigned __int8 *)(a2 + 23);
    }
    else {
      uint64_t v12 = *(void *)(a2 + 8);
    }
    sub_100004E4C(&v17, v11, v12);
    sub_100004E4C(&v17, (uint64_t)" - different calculated: <", 26LL);
    sub_1000F61D0((uint64_t)&v17, a3);
    sub_100004E4C(&v17, (uint64_t)"> real: <", 9LL);
    sub_1000ED4B8(&v17, a4);
    sub_100004E4C(&v17, (uint64_t)">", 1LL);
    std::ostream::~ostream(&v17, off_100184410);
    sub_1000F3254((uint64_t)v16);
  }

  return std::ios::~ios(&v18);
}

void sub_1000EF044(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

void *sub_1000EF070(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000F6154((uint64_t)a1, a2);
  *a1 = off_100184128;
  a1[45] = &off_100184228;
  a1[46] = &off_100184250;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_100184128;
  a1[45] = off_1001841B0;
  a1[46] = off_1001841D8;
  return a1;
}

void sub_1000EF0F4(_Unwind_Exception *a1)
{
}

uint64_t sub_1000EF118(uint64_t a1)
{
  return a1;
}

void *sub_1000EF158(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000F62C4((uint64_t)a1, a2);
  *a1 = off_100184348;
  a1[45] = &off_100184448;
  a1[46] = &off_100184470;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_100184348;
  a1[45] = off_1001843D0;
  a1[46] = off_1001843F8;
  return a1;
}

void sub_1000EF1DC(_Unwind_Exception *a1)
{
}

uint64_t sub_1000EF200(uint64_t a1)
{
  return a1;
}

uint64_t sub_1000EF240(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + 16) = 0LL;
  uint64_t v3 = (void *)(a1 + 16);
  *(void *)a1 = off_1001837A0;
  *(void *)(a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = a1 + 16;
  uint64_t v4 = (void *)(a1 + 8);
  *(void *)(a1 + 24) = 0LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + sub_1000114F0(v6 - 32) = a1 + 40;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0LL;
  *(void *)(a1 + 56) = a2[1];
  uint64_t v5 = a2[2];
  *(void *)(a1 + 64) = v5;
  if (v5)
  {
    uint64_t v6 = (unint64_t *)(v5 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  uint64_t v8 = *a2;
  *a2 = 0LL;
  *(void *)(a1 + sub_1000114F0(v49 + 112) = 0LL;
  *(void *)(a1 + 104) = a1 + 112;
  *(void *)(a1 + 72) = v8;
  *(_BYTE *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 120) = 0LL;
  sub_1000ED618();
  sub_1000EEA98();
  *(_BYTE *)(a1 + 89) = *(void *)(*(void *)(a1 + 72) + 216LL) >= *(void *)(*(void *)(a1 + 72) + 32LL)
                                                                   + *(void *)(*(void *)(a1 + 72) + 24LL);
  sub_1000EF628(a1, (uint64_t)&v36);
  while (1)
  {
    if (v36 != v41) {
      goto LABEL_15;
    }
    int v9 = v44;
    BOOL v10 = !v39 || v44 == 0;
    if (!v10) {
      break;
    }
    if ((v39 != 0) == (v44 != 0)) {
      goto LABEL_14;
    }
LABEL_15:
    int v11 = sub_1000F076C(&v36);
    sub_1000F0860((uint64_t)&v36);
    if (v11 == 1651272568)
    {
      sub_1000F076C(&v36);
      uint64_t v12 = (const __CFArray *)sub_1000F0860((uint64_t)&v36);
      sub_1000EE2C0(a1, v12);
    }

    sub_100011548((uint64_t)v32, &v36);
    ++v40;
    if (v35) {
      sub_1000114C0(&v34);
    }
    unint64_t v13 = v33;
    if (v33)
    {
      uint64_t p_shared_owners = (unint64_t *)&v33->__shared_owners_;
      do
        unint64_t v15 = __ldaxr(p_shared_owners);
      while (__stlxr(v15 - 1, p_shared_owners));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
  }

  if (v38 != v43) {
    goto LABEL_15;
  }
LABEL_14:
  if (v40 != v45) {
    goto LABEL_15;
  }
  uint64_t v16 = *(void *)(*(void *)(a1 + 72) + 492LL);
  *(void *)(a1 + 80) = v16;
  if (!v16 && (void *)*v4 != v3)
  {
    uint64_t v17 = (void *)*v3;
    if (*v3)
    {
      do
      {
        uint64_t v18 = v17;
        uint64_t v17 = (void *)v17[1];
      }

      while (v17);
    }

    else
    {
      __int128 v19 = v3;
      do
      {
        uint64_t v18 = (void *)v19[2];
        BOOL v10 = *v18 == (void)v19;
        __int128 v19 = v18;
      }

      while (v10);
    }

    *(void *)(a1 + 80) = v18[5];
    *(void *)&__int128 v27 = "udif::details::UDIF_base::UDIF_base(UDIF_header &&)";
    *((void *)&v27 + sub_1000F1940(&v11, 1) = 35LL;
    int v28 = 0;
    sub_1000EF844(v29, &v27);
    sub_100004E4C(&v30, (uint64_t)"UDIF header doesn't contain a valid sector count, using runs upper value: ", 74LL);
    std::ostream::operator<<(&v30, *(void *)(a1 + 80));
    std::ostream::~ostream(&v30, off_100184630);
    sub_1000F3800((uint64_t)v29);
    std::ios::~ios(&v31);
    int v9 = v44;
  }

  if (v9) {
    sub_1000114C0(&v43);
  }
  __int128 v20 = v42;
  if (v42)
  {
    __int128 v21 = (unint64_t *)&v42->__shared_owners_;
    do
      unint64_t v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }

  if (v39) {
    sub_1000114C0(&v38);
  }
  uint64_t v23 = v37;
  if (v37)
  {
    __int128 v24 = (unint64_t *)&v37->__shared_owners_;
    do
      unint64_t v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }

  return a1;
}

void sub_1000EF5B0(_Unwind_Exception *a1)
{
  BOOL v10 = *(void **)(v1 + 72);
  *(void *)(v1 + 72) = 0LL;
  if (v10) {
    operator delete(v10);
  }
  sub_1000114F0(v4);
  sub_100026AC4(v3, *v6);
  sub_100026AC4(v2, *v7);
  _Unwind_Resume(a1);
}

const void **sub_1000EF628@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t Count = CFDictionaryGetCount(v29);
  uint64_t v4 = Count;
  if (Count >> 61) {
    size_t v5 = -1LL;
  }
  else {
    size_t v5 = 8 * Count;
  }
  uint64_t v6 = operator new[](v5);
  sub_1000F63BC(&v27, (uint64_t)v6);
  if (!v27)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = &off_100189E78;
    uint64_t v18 = std::generic_category();
    exception[1] = 12LL;
    exception[2] = v18;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
    exception[7] = "UDIF: Can't get types array from UDIF";
  }

  CFDictionaryGetKeysAndValues(v29, v27, 0LL);
  sub_1000F3BE8((uint64_t)v23, &v27, (const void **)&v29, 0LL);
  sub_1000F3BE8((uint64_t)v19, &v27, (const void **)&v29, v4);
  sub_1000F3C60(a2, (uint64_t)v23, (uint64_t)v19);
  if (v22) {
    sub_1000114C0(&v21);
  }
  unint64_t v7 = v20;
  if (v20)
  {
    uint64_t p_shared_owners = (unint64_t *)&v20->__shared_owners_;
    do
      unint64_t v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

  if (v26) {
    sub_1000114C0(&v25);
  }
  BOOL v10 = v24;
  if (v24)
  {
    int v11 = (unint64_t *)&v24->__shared_owners_;
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  unint64_t v13 = v28;
  if (v28)
  {
    __int128 v14 = (unint64_t *)&v28->__shared_owners_;
    do
      unint64_t v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }

  return sub_1000114C0((const void **)&v29);
}

void sub_1000EF7F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_100011444((uint64_t)va);
  sub_100011444((uint64_t)va1);
  sub_1000114F0(v2 - 40);
  sub_1000114C0((const void **)(v2 - 24));
  _Unwind_Resume(a1);
}

void *sub_1000EF844(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1000F6340((uint64_t)a1, a2);
  *a1 = off_100184568;
  a1[45] = &off_100184668;
  a1[46] = &off_100184690;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_100184568;
  a1[45] = off_1001845F0;
  a1[46] = off_100184618;
  return a1;
}

void sub_1000EF8C8(_Unwind_Exception *a1)
{
}

uint64_t sub_1000EF8EC(uint64_t a1)
{
  return a1;
}

const void *sub_1000EF92C(uint64_t a1)
{
  Value = CFDictionaryGetValue(theDict, @"uuid");
  CFTypeID TypeID = CFArrayGetTypeID();
  if (Value)
  {
    uint64_t v3 = TypeID;
    if (CFGetTypeID(Value) != TypeID)
    {
      exception = __cxa_allocate_exception(0x40uLL);
      CFTypeID v13 = CFGetTypeID(Value);
      __int128 v14 = sub_100026B08(exception, v13, v3);
    }

    if (CFArrayGetCount((CFArrayRef)Value) < 1) {
      goto LABEL_10;
    }
    ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)Value, 0LL);
    CFTypeID v5 = CFDictionaryGetTypeID();
    if (ValueAtIndex)
    {
      uint64_t v6 = v5;
      if (CFGetTypeID(ValueAtIndex) != v5)
      {
        unint64_t v15 = __cxa_allocate_exception(0x40uLL);
        CFTypeID v16 = CFGetTypeID(ValueAtIndex);
        uint64_t v17 = sub_100026B08(v15, v16, v6);
      }
    }

    uint64_t v7 = CFDictionaryGetValue((CFDictionaryRef)ValueAtIndex, @"Data");
    CFTypeID v8 = CFDataGetTypeID();
    if (!v7)
    {
      Value = 0LL;
      goto LABEL_11;
    }

    uint64_t v9 = v8;
    if (CFGetTypeID(v7) != v8)
    {
      uint64_t v18 = __cxa_allocate_exception(0x40uLL);
      CFTypeID v19 = CFGetTypeID(v7);
      __int128 v20 = sub_100026B08(v18, v19, v9);
    }

    BytePtr = CFDataGetBytePtr((CFDataRef)v7);
    if (BytePtr) {
      Value = *(const void **)BytePtr;
    }
    else {
LABEL_10:
    }
      Value = 0LL;
  }

void sub_1000EFAE0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10)
{
}

void sub_1000EFB18(uint64_t a1@<X0>, void *a2@<X8>)
{
  CFIndex v4 = *(void *)(*(void *)(a1 + 72) + 224LL);
  CFTypeID v5 = bytes;
  sub_1000F6AA8(bytes, v4, &theDict);
  Value = CFDictionaryGetValue(theDict, @"resource-fork");
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (!Value)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = &off_100189E78;
    CFTypeID v16 = std::generic_category();
    exception[1] = 22LL;
    exception[2] = v16;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
    exception[7] = "UDIF: Can't create dictionary resource fork";
  }

  uint64_t v8 = TypeID;
  if (CFGetTypeID(Value) != TypeID)
  {
    uint64_t v17 = __cxa_allocate_exception(0x40uLL);
    CFTypeID v18 = CFGetTypeID(Value);
    CFTypeID v19 = sub_100026B08(v17, v18, v8);
  }

  if (sub_1000B866C())
  {
    int v9 = *__error();
    if (sub_1000B8654())
    {
      uint64_t v20 = 0LL;
      BOOL v10 = (os_log_s *)sub_1000B85DC();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
        uint64_t v11 = 3LL;
      }
      else {
        uint64_t v11 = 2LL;
      }
      *(_DWORD *)buf = 68158210;
      int v24 = 39;
      __int16 v25 = 2080;
      char v26 = "udif::details::UDIF_base::get_resources() const";
      __int16 v27 = 2114;
      int v28 = Value;
      unint64_t v12 = (const char *)_os_log_send_and_compose_impl( v11,  &v20,  0LL,  0LL,  &_mh_execute_header,  v10,  2LL,  "%.*s: XML_RSRC_FORK: %{public}@",  buf,  28);
      if (v12)
      {
        CFTypeID v13 = (char *)v12;
        fprintf(__stderrp, "%s\n", v12);
        free(v13);
      }
    }

    else
    {
      __int128 v14 = (os_log_s *)sub_1000B85DC();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 68158210;
        int v24 = 39;
        __int16 v25 = 2080;
        char v26 = "udif::details::UDIF_base::get_resources() const";
        __int16 v27 = 2114;
        int v28 = Value;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "%.*s: XML_RSRC_FORK: %{public}@", buf, 0x1Cu);
      }
    }

    *__error() = v9;
  }

  CFRetain(Value);
  *a2 = Value;
  sub_1000114C0((const void **)&theDict);
  if (v5) {
    operator delete[](v5);
  }
}

void sub_1000EFDC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  if (v5) {
    operator delete[](v5);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1000EFE14(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  CFIndex v4 = (void *)(a1 + 16);
  *(void *)(a1 + sub_1000114F0(v6 - 32) = 0xFFFFFFFE00000000LL;
  CFTypeID v5 = (_DWORD *)(a1 + 32);
  *(_OWORD *)(a1 + 40) = 0u;
  uint64_t v6 = a1 + 40;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 16_Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  sub_1000F4400((_DWORD *)(a1 + 64));
  *(_DWORD *)(a1 + 6_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
  *(_DWORD *)(a1 + 200) = 0;
  int v7 = *(_DWORD *)a2;
  LODWORD(v25) = 1752394093;
  sub_10007EF00((uint64_t)"blocks_signature", v7, &v25, 1LL);
  *(_DWORD *)a1 = 1752394093;
  int v8 = bswap32(*(_DWORD *)(a2 + 4));
  LODWORD(v25) = 1;
  sub_10007EF00((uint64_t)"version", v8, &v25, 1LL);
  *(_DWORD *)(a1 + 4) = 1;
  *(void *)(a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = bswap64(*(void *)(a2 + 8));
  void *v4 = bswap64(*(void *)(a2 + 16));
  *(void *)(a1 + 24) = bswap64(*(void *)(a2 + 24));
  *CFTypeID v5 = bswap32(*(_DWORD *)(a2 + 32));
  LODWORD(v25) = *(_DWORD *)(a2 + 36);
  sub_1000EC5D4((unsigned int *)&v25, (unsigned int *)v24);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)v24;
  __int128 v9 = *(_OWORD *)(a2 + 40);
  *(void *)(v6 + 16) = *(void *)(a2 + 56);
  *(_OWORD *)uint64_t v6 = v9;
  sub_1000F4400(v24);
  __int128 v10 = *(_OWORD *)(a2 + 176);
  *(_OWORD *)&v24[96] = *(_OWORD *)(a2 + 160);
  *(_OWORD *)&v24[112] = v10;
  *(void *)&v24[128] = *(void *)(a2 + 192);
  __int128 v11 = *(_OWORD *)(a2 + 112);
  *(_OWORD *)&v24[32] = *(_OWORD *)(a2 + 96);
  *(_OWORD *)&v24[48] = v11;
  __int128 v12 = *(_OWORD *)(a2 + 144);
  *(_OWORD *)&v24[64] = *(_OWORD *)(a2 + 128);
  *(_OWORD *)&v24[80] = v12;
  __int128 v13 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)int v24 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)&v24[16] = v13;
  __int128 v30 = *(_OWORD *)&v24[72];
  __int128 v31 = *(_OWORD *)&v24[88];
  __int128 v32 = *(_OWORD *)&v24[104];
  __int128 v33 = *(_OWORD *)&v24[120];
  __int128 v26 = *(_OWORD *)&v24[8];
  __int128 v27 = *(_OWORD *)&v24[24];
  __int128 v28 = *(_OWORD *)&v24[40];
  __int128 v29 = *(_OWORD *)&v24[56];
  uint64_t v25 = *(void *)v24;
  sub_1000EC37C((uint64_t)&v25, (int *)&v15);
  *(void *)(a1 + 64) = v15;
  *(_OWORD *)(a1 + 136) = v20;
  *(_OWORD *)(a1 + 152) = v21;
  *(_OWORD *)(a1 + 16_Block_object_dispose((const void *)(v2 - 120), 8) = v22;
  *(_OWORD *)(a1 + 184) = v23;
  *(_OWORD *)(a1 + 72) = v16;
  *(_OWORD *)(a1 + 8_Block_object_dispose((const void *)(v2 - 120), 8) = v17;
  *(_OWORD *)(a1 + 104) = v18;
  *(_OWORD *)(a1 + 120) = v19;
  *(_DWORD *)(a1 + 200) = bswap32(*(_DWORD *)(a2 + 200));
  return a1;
}

void sub_1000F0080(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10000491C(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1000F008C(uint64_t a1, uint64_t a2)
{
  CFIndex v4 = sub_1000F6494((_DWORD *)a1);
  v4[9] = 0;
  *(_OWORD *)(v4 + 5) = 0u;
  *(_OWORD *)(v4 + sub_1000F1940(&v11, 1) = 0u;
  sub_1000F1940(&v6, bswap32(*(_DWORD *)a2));
  *(_DWORD *)a1 = v6;
  *(_DWORD *)(a1 + 4) = bswap32(*(_DWORD *)(a2 + 4));
  *(void *)(a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = bswap64(*(void *)(a2 + 8));
  *(void *)(a1 + 16) = bswap64(*(void *)(a2 + 16));
  *(void *)(a1 + 24) = bswap64(*(void *)(a2 + 24));
  *(void *)(a1 + sub_1000114F0(v6 - 32) = bswap64(*(void *)(a2 + 32));
  return a1;
}

const void **sub_1000F0120@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, unsigned __int16 *a4@<X3>, void *a5@<X4>, CFDictionaryRef *a6@<X8>)
{
  else {
    __int128 v11 = *(const char **)a1;
  }
  CFTypeRef cf = 0LL;
  CFStringRef v23 = CFStringCreateWithCString(kCFAllocatorDefault, v11, 0x8000100u);
  if (*(_BYTE *)(a2 + 24))
  {
    else {
      __int128 v12 = *(const char **)a2;
    }
    CFTypeRef cf = CFStringCreateWithCString(kCFAllocatorDefault, v12, 0x8000100u);
  }

  else
  {
    CFTypeRef cf = &stru_10018AD20;
  }

  keys[0] = 0LL;
  sub_100026A94((const void **)keys);
  std::to_string(&v21, a3);
  if ((v21.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    __int128 v13 = &v21;
  }
  else {
    __int128 v13 = (std::string *)v21.__r_.__value_.__r.__words[0];
  }
  CFStringRef v20 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)v13, 0x600u);
  sub_100026C20((uint64_t)keys);
  sub_100004E4C(&v26, (uint64_t)"0x", 2LL);
  *(_DWORD *)((char *)&v26 + *(void *)(v26 - 24) + _Block_object_dispose((const void *)(v2 - 120), 8) = *(_DWORD *)((_BYTE *)&v26 + *(void *)(v26 - 24) + 8) & 0xFFFFFFB5 | 8;
  LOBYTE(values[0]) = 48;
  sub_1000166BC(&v26, (char *)values);
  *(void *)&v28[*(void *)(v26 - 24)] = 4LL;
  std::ostream::operator<<(&v26, *a4);
  sub_1000F4288((uint64_t)&v26 + 8, &v19);
  *(void **)((char *)keys
  *(void *)&__int128 v26 = v14;
  if (v30 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf((char *)&v26 + 8);
  std::ios::~ios(&v31);
  if ((v19.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v15 = &v19;
  }
  else {
    uint64_t v15 = (std::string *)v19.__r_.__value_.__r.__words[0];
  }
  CFStringRef v18 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)v15, 0x600u);
  *(_OWORD *)keys = *(_OWORD *)off_1001837B8;
  __int128 v26 = *(_OWORD *)off_1001837C8;
  __int128 v27 = @"CFName";
  values[0] = a5;
  values[1] = (void *)v23;
  values[2] = (void *)v20;
  values[3] = (void *)v18;
  if (*(_BYTE *)(a2 + 24)) {
    CFIndex v16 = 5LL;
  }
  else {
    CFIndex v16 = 4LL;
  }
  values[4] = (void *)cf;
  *a6 = CFDictionaryCreate( kCFAllocatorDefault,  (const void **)keys,  (const void **)values,  v16,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  sub_100026A94((const void **)&v18);
  sub_100026A94((const void **)&v20);
  sub_100026A94(&cf);
  return sub_100026A94((const void **)&v23);
}

void sub_1000F0408( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, const void *a24, const void *a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, const void *a31)
{
}

uint64_t sub_1000F04A0(uint64_t a1)
{
  uint64_t v4 = a1 + 24;
  *(void *)(a1 + 16) = v3;
  std::streambuf::~streambuf(v4);
  std::ios::~ios(a1 + 128);
  return a1;
}

void *sub_1000F0528(void *a1, int *a2)
{
  int v4 = *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24LL) + 8);
  CFTypeID v5 = sub_100004E4C(a1, (uint64_t)"type: ", 6LL);
  int v27 = *a2;
  int v6 = sub_100026D4C(v5, &v27);
  int v7 = sub_100004E4C(v6, (uint64_t)" data: ", 7LL);
  uint64_t v8 = *v7;
  *(_DWORD *)((char *)v7 + *(void *)(*v7 - 24) + _Block_object_dispose((const void *)(v2 - 120), 8) = *(_DWORD *)((_BYTE *)v7 + *(void *)(*v7 - 24) + 8) & 0xFFFFFFB5 | 8;
  *(_DWORD *)((char *)v7 + *(void *)(v8 - 24) + 8) |= 0x200u;
  __int128 v9 = (void *)std::ostream::operator<<(v7, *((void *)a2 + 1));
  __int128 v10 = sub_100004E4C(v9, (uint64_t)"/", 1LL);
  uint64_t v11 = *v10;
  *(_DWORD *)((char *)v10 + *(void *)(*v10 - 24) + _Block_object_dispose((const void *)(v2 - 120), 8) = *(_DWORD *)((_BYTE *)v10 + *(void *)(*v10 - 24) + 8) & 0xFFFFFFB5 | 2;
  *(_DWORD *)((char *)v10 + *(void *)(v11 - 24) + 8) &= ~0x200u;
  __int128 v12 = (void *)std::ostream::operator<<(v10, *((void *)a2 + 2));
  __int128 v13 = sub_100004E4C(v12, (uint64_t)" logical: ", 10LL);
  uint64_t v14 = *v13;
  *(_DWORD *)((char *)v13 + *(void *)(*v13 - 24) + _Block_object_dispose((const void *)(v2 - 120), 8) = *(_DWORD *)((_BYTE *)v13 + *(void *)(*v13 - 24) + 8) & 0xFFFFFFB5 | 8;
  *(_DWORD *)((char *)v13 + *(void *)(v14 - 24) + 8) |= 0x200u;
  uint64_t v15 = (void *)std::ostream::operator<<(v13, *((void *)a2 + 3));
  CFIndex v16 = sub_100004E4C(v15, (uint64_t)"/", 1LL);
  uint64_t v17 = *v16;
  *(_DWORD *)((char *)v16 + *(void *)(*v16 - 24) + _Block_object_dispose((const void *)(v2 - 120), 8) = *(_DWORD *)((_BYTE *)v16 + *(void *)(*v16 - 24) + 8) & 0xFFFFFFB5 | 2;
  *(_DWORD *)((char *)v16 + *(void *)(v17 - 24) + 8) &= ~0x200u;
  CFStringRef v18 = (void *)std::ostream::operator<<(v16, *((void *)a2 + 4));
  std::string v19 = sub_100004E4C(v18, (uint64_t)" io: ", 5LL);
  uint64_t v20 = *v19;
  *(_DWORD *)((char *)v19 + *(void *)(*v19 - 24) + _Block_object_dispose((const void *)(v2 - 120), 8) = *(_DWORD *)((_BYTE *)v19 + *(void *)(*v19 - 24) + 8) & 0xFFFFFFB5 | 8;
  *(_DWORD *)((char *)v19 + *(void *)(v20 - 24) + 8) |= 0x200u;
  std::string v21 = (void *)std::ostream::operator<<(v19, *((void *)a2 + 5));
  __int128 v22 = sub_100004E4C(v21, (uint64_t)",", 1LL);
  uint64_t v23 = *v22;
  *(_DWORD *)((char *)v22 + *(void *)(*v22 - 24) + _Block_object_dispose((const void *)(v2 - 120), 8) = *(_DWORD *)((_BYTE *)v22 + *(void *)(*v22 - 24) + 8) & 0xFFFFFFB5 | 2;
  *(_DWORD *)((char *)v22 + *(void *)(v23 - 24) + 8) &= ~0x200u;
  int v24 = (void *)std::ostream::operator<<(v22, *((void *)a2 + 6));
  uint64_t v25 = sub_100004E4C(v24, (uint64_t)"/", 1LL);
  std::ostream::operator<<(v25, *((void *)a2 + 7));
  *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24LL) + _Block_object_dispose((const void *)(v2 - 120), 8) = v4;
  return a1;
}

uint64_t sub_1000F076C(void *a1)
{
  uint64_t result = sub_1000F6698(*(const __CFString **)(*a1 + 8LL * a1[4]));
  if (!(_DWORD)result)
  {
    uint64_t v3 = a1;
    exception = __cxa_allocate_exception(0x40uLL);
    sub_100004D60((uint64_t)v5);
    sub_100004E4C(v5, (uint64_t)"UDIF: Failed converting type array string (", 43LL);
    std::ostream::operator<<(v5, *(void *)(*v3 + 8LL * v3[4]));
    sub_100004E4C(v5, (uint64_t)") to type", 9LL);
    sub_10001161C((uint64_t)exception, (uint64_t)v5, 0x16u);
  }

  return result;
}

void sub_1000F082C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

const void *sub_1000F0860(uint64_t a1)
{
  uint64_t result = CFDictionaryGetValue( *(CFDictionaryRef *)(a1 + 16),  *(const void **)(*(void *)a1 + 8LL * *(void *)(a1 + 32)));
  if (!result)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    uint64_t v3 = (void *)sub_100004870((uint64_t)exception, (uint64_t)"UDIF: Can't get resource array", 0x16u);
  }

  return result;
}

BOOL sub_1000F08B8(uint64_t a1, uint64_t a2)
{
  if (*(void *)a1 != *(void *)a2) {
    return 0LL;
  }
  int v3 = *(unsigned __int8 *)(a2 + 24);
  if (*(_BYTE *)(a1 + 24)) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4)
  {
    if ((*(_BYTE *)(a1 + 24) != 0) == (v3 != 0)) {
      return *(void *)(a1 + 32) == *(void *)(a2 + 32);
    }
    return 0LL;
  }

  if (*(void *)(a1 + 16) != *(void *)(a2 + 16)) {
    return 0LL;
  }
  return *(void *)(a1 + 32) == *(void *)(a2 + 32);
}

uint64_t *sub_1000F0924(uint64_t *a1, uint64_t *a2)
{
  *a1 = 0LL;
  a1[1] = *a2;
  uint64_t v4 = a2[1];
  a1[2] = v4;
  if (v4)
  {
    CFTypeID v5 = (unint64_t *)(v4 + 8);
    do
      unint64_t v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }

  int v7 = operator new[](0x1F4uLL);
  v7[124] = 0;
  *((_OWORD *)v7 + 29) = 0u;
  *((_OWORD *)v7 + 30) = 0u;
  *((_OWORD *)v7 + 27) = 0u;
  *((_OWORD *)v7 + 2_Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  *((_OWORD *)v7 + 25) = 0u;
  *((_OWORD *)v7 + 26) = 0u;
  *((_OWORD *)v7 + 23) = 0u;
  *((_OWORD *)v7 + 24) = 0u;
  *((_OWORD *)v7 + 2sub_1000F1940(&v11, 1) = 0u;
  *((_OWORD *)v7 + 22) = 0u;
  *((_OWORD *)v7 + 19) = 0u;
  *((_OWORD *)v7 + 20) = 0u;
  *((_OWORD *)v7 + 17) = 0u;
  *((_OWORD *)v7 + 1_Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  *((_OWORD *)v7 + 15) = 0u;
  *((_OWORD *)v7 + 16) = 0u;
  *((_OWORD *)v7 + 13) = 0u;
  *((_OWORD *)v7 + 14) = 0u;
  *((_OWORD *)v7 + 1sub_1000F1940(&v11, 1) = 0u;
  *((_OWORD *)v7 + 12) = 0u;
  *((_OWORD *)v7 + 9) = 0u;
  *((_OWORD *)v7 + 10) = 0u;
  *((_OWORD *)v7 + 7) = 0u;
  *((_OWORD *)v7 + _Block_object_dispose((const void *)(v2 - 120), 8) = 0u;
  *((_OWORD *)v7 + 5) = 0u;
  *((_OWORD *)v7 + 6) = 0u;
  *((_OWORD *)v7 + 3) = 0u;
  *((_OWORD *)v7 + 4) = 0u;
  *((_OWORD *)v7 + sub_1000F1940(&v11, 1) = 0u;
  *((_OWORD *)v7 + 2) = 0u;
  *(_OWORD *)int v7 = 0u;
  unint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)*a2 + 40LL))(*a2);
  if (v8 <= 0x1FF)
  {
    unint64_t v14 = v8;
    exception = __cxa_allocate_exception(0x20uLL);
    void *exception = &off_100181CC0;
    exception[1] = "UDIF_header";
    exception[2] = 8LL;
    exception[3] = v14;
  }

  unsigned int v9 = sub_100033014(*a2, (uint64_t)v7, 500LL, v8 - 512);
  if ((v9 & 0x80000000) != 0)
  {
    CFIndex v16 = __cxa_allocate_exception(0x40uLL);
    void *v16 = &off_100189E78;
    uint64_t v17 = std::generic_category();
    v16[1] = v9;
    void v16[2] = v17;
    *((_BYTE *)v16 + 24) = 0;
    *((_BYTE *)v16 + 4_Block_object_dispose((const void *)(v2 - 120), 8) = 0;
    v16[7] = "UDIF: Can't read UDIF trailer";
  }

  __int128 v10 = operator new(0x1F4uLL);
  sub_1000EAB88((uint64_t)v10, (uint64_t)v7);
  uint64_t v11 = (void *)*a1;
  *a1 = (uint64_t)v10;
  if (v11) {
    operator delete(v11);
  }
  if (sub_1000B866C())
  {
    *(void *)&__int128 v18 = "UDIF_header::UDIF_header(const std::shared_ptr<Backend> &)";
    *((void *)&v18 + sub_1000F1940(&v11, 1) = 24LL;
    int v19 = 2;
    sub_1000F0B98(v20, &v18);
    __int128 v12 = sub_1000EB324(&v21, *a1);
    std::ostream::~ostream(v12, off_100184850);
    sub_1000F3EA0((uint64_t)v20);
    std::ios::~ios(&v22);
  }

  operator delete[](v7);
  return a1;
}

void sub_1000F0B34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  unint64_t v8 = *v4;
  _DWORD *v4 = 0LL;
  if (v8) {
    operator delete(v8);
  }
  _Unwind_Resume(a1);
}

void *sub_1000F0B98(void *a1, __int128 *a2)
{
  int v3 = (std::ios_base *)(a1 + 46);
  sub_1000F6538((uint64_t)a1, a2);
  *a1 = off_100184788;
  a1[45] = &off_100184888;
  a1[46] = &off_1001848B0;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose((const void *)(v2 - 120), 8) = -1;
  *a1 = off_100184788;
  a1[45] = off_100184810;
  a1[46] = off_100184838;
  return a1;
}

void sub_1000F0C1C(_Unwind_Exception *a1)
{
}

uint64_t sub_1000F0C40(uint64_t a1)
{
  return a1;
}

void *sub_1000F0C84(void *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a2;
  *a2 = 0LL;
  uint64_t v5 = *a3;
  uint64_t v4 = a3[1];
  *uint64_t result = v3;
  result[1] = v5;
  result[2] = v4;
  if (v4)
  {
    unint64_t v6 = (unint64_t *)(v4 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  return result;
}

void sub_1000F0CB8(uint64_t a1)
{
  uint64_t v1 = (void *)sub_10004E010(a1);
  operator delete(v1);
}

uint64_t sub_1000F0CCC(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_1001838D0);
  sub_1000F0E90(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000F0D04(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001838D0);
  sub_1000F0E90(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000F0D44(char *a1)
{
}

uint64_t sub_1000F0D88(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000F0DBC(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000F0E08(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_1001838D0);
  sub_1000F0E90((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000F0E48(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001838D0);
  sub_1000F0E90((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000F0E90(uint64_t a1)
{
  *(void *)a1 = off_1001839A0;
  sub_1000F0F2C(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000F0F2C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000F1094((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000F1054( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000F1080(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000F0E90(a1);
  operator delete(v1);
}

int *sub_1000F1094(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      __int128 v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 85LL;
    __int16 v25 = 2082;
    __int128 v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      __int128 v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    __int128 v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        CFIndex v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 85LL;
      __int16 v25 = 2082;
      __int128 v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

int *sub_1000F1278(int *a1, int a2)
{
  *a1 = a2;
  v4[0] = xmmword_100140E00;
  v4[1] = xmmword_100140E10;
  uint64_t v5 = 0x900000008LL;
  int v6 = 10;
  sub_10007EF00((uint64_t)"checksum_type", a2, v4, 11LL);
  return a1;
}

void sub_1000F1310(std::exception *a1)
{
}

uint64_t sub_1000F1324(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t sub_1000F132C@<X0>(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  size_t v4 = strlen(*(const char **)(a1 + 8));
  sub_100004E4C(&v12, *(void *)(a1 + 8), v4);
  sub_100004E4C(&v12, (uint64_t)" - ", 3LL);
  uint64_t v5 = *(const char **)(a1 + 16);
  size_t v6 = strlen(v5);
  sub_100004E4C(&v12, (uint64_t)v5, v6);
  sub_1000F149C((uint64_t)v16, v11);
  *(uint64_t *)((char *)v11
  uint64_t v12 = v8;
  if (v14 < 0) {
    operator delete((void *)v13[8]);
  }
  std::streambuf::~streambuf(v13);
  std::ios::~ios(&v15);
  sub_1000F4288((uint64_t)v17, a2);
  v16[0] = v7;
  *(void *)((char *)v16 + *(void *)(v7 - atomic_store(0, (unsigned int *)(v1 + 24)) = v9;
  void v16[2] = v8;
  if (v18 < 0) {
    operator delete((void *)v17[8]);
  }
  std::streambuf::~streambuf(v17);
  return std::ios::~ios(&v19);
}

uint64_t sub_1000F149C(uint64_t a1, uint64_t *a2)
{
  *(void *)a1 = v4;
  *(void *)(a1 + *(void *)(v4 - atomic_store(0, (unsigned int *)(v1 + 24)) = v5;
  uint64_t v6 = *a2;
  *(void *)(a1 + _Block_object_dispose((const void *)(v2 - 120), 8) = a2[1];
  a2[1] = 0LL;
  uint64_t v7 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24LL));
  uint64_t v8 = (std::ios_base *)((char *)a2 + *(void *)(v6 - 24));
  std::ios_base::move(v7, v8);
  v7[1].__vftable = v8[1].__vftable;
  v8[1].__vftable = 0LL;
  v7[1].__fmtflags_ = v8[1].__fmtflags_;
  *(void *)(a1 + 16) = v9;
  *(void *)(a1 + 16 + *(void *)(v9 - atomic_store(0, (unsigned int *)(v1 + 24)) = v10;
  *(void *)a1 = v11;
  *(void *)(a1 + *(void *)(*(void *)a1 - 24LL) + 40) = std::stringbuf::basic_stringbuf( (std::stringbuf *)(a1 + 24),  (std::stringbuf *)(a2 + 3));
  return a1;
}

void sub_1000F15A0(_Unwind_Exception *a1)
{
}

uint64_t sub_1000F15C8@<X0>(uint64_t a1@<X8>)
{
  return sub_1000F15E0(a1);
}

uint64_t sub_1000F15D4@<X0>(_DWORD *a1@<X1>, uint64_t a2@<X8>)
{
  return sub_1000F1684(a2, (uint64_t)a1, a1);
}

uint64_t sub_1000F15E0(uint64_t a1)
{
  *(void *)a1 = v3;
  int v4 = 0;
  sub_1000EC440(v5, &v4);
  *(_DWORD *)(a1 + 4) = v5[0];
  *(_OWORD *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 4sub_1000F1278((int *)&v3, 0) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 12sub_1000F1278((int *)&v3, 0) = 0u;
  return a1;
}

uint64_t sub_1000F1684(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  *(_DWORD *)a1 = v6;
  *(_DWORD *)(a1 + 4) = 0;
  LODWORD(a3) = *a3;
  int v7 = 32;
  sub_1000EC440(&v8, &v7);
  *(_DWORD *)uint64_t v9 = (_DWORD)a3;
  memset(&v9[4], 0, 124);
  *(_DWORD *)(a1 + 4) = v8;
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = *(_OWORD *)&v9[64];
  *(_OWORD *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = *(_OWORD *)&v9[80];
  *(_OWORD *)(a1 + 104) = *(_OWORD *)&v9[96];
  *(_OWORD *)(a1 + 12sub_1000F1278((int *)&v3, 0) = *(_OWORD *)&v9[112];
  *(_OWORD *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = *(_OWORD *)v9;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)&v9[16];
  *(_OWORD *)(a1 + 4sub_1000F1278((int *)&v3, 0) = *(_OWORD *)&v9[32];
  *(_OWORD *)(a1 + 56) = *(_OWORD *)&v9[48];
  return a1;
}

unsigned int *sub_1000F1778(unsigned int *result, unsigned int a2)
{
  *uint64_t result = a2;
  if (a2 <= 0xFFFFFFFD)
  {
    exception = __cxa_allocate_exception(0x28uLL);
    exception[2] = "invalid value";
    exception[3] = "value validator";
    void *exception = &off_100183A90;
    exception[1] = "descriptor_special";
    *((_DWORD *)exception + std::iostream::~basic_iostream(v2, v3 + 8) = a2;
  }

  return result;
}

void sub_1000F17EC(std::exception *a1)
{
}

void sub_1000F1800(uint64_t a1@<X0>, void *a2@<X8>)
{
  int v4 = (char *)sub_100109388(a1);
  sub_100004CB0(v16, v4);
  sub_100026C20((uint64_t)v11);
  if ((v17 & 0x80u) == 0) {
    uint64_t v5 = v16;
  }
  else {
    uint64_t v5 = (void **)v16[0];
  }
  if ((v17 & 0x80u) == 0) {
    uint64_t v6 = v17;
  }
  else {
    uint64_t v6 = (uint64_t)v16[1];
  }
  int v7 = sub_100004E4C(&v12, (uint64_t)v5, v6);
  int v8 = sub_100004E4C(v7, (uint64_t)" [", 2LL);
  *(_DWORD *)((char *)v8 + *(void *)(*v8 - 24LL) + std::iostream::~basic_iostream(v2, v3 + 8) = *(_DWORD *)((_BYTE *)v8 + *(void *)(*v8 - 24LL) + 8) & 0xFFFFFFB5 | 8;
  uint64_t v9 = (void *)std::ostream::operator<<(v8, *(unsigned int *)(a1 + 32));
  sub_100004E4C(v9, (uint64_t)"]", 1LL);
  sub_1000049D8((uint64_t)v13, a2);
  *(void *)((char *)v11
  uint64_t v12 = v10;
  if (v14 < 0) {
    operator delete((void *)v13[8]);
  }
  std::streambuf::~streambuf(v13);
  std::ios::~ios(&v15);
}

int *sub_1000F1940(int *a1, int a2)
{
  *a1 = a2;
  v4[0] = xmmword_100140E20;
  v4[1] = xmmword_100140E30;
  _OWORD v4[2] = xmmword_100140E40;
  unint64_t v5 = 0x8000000880000007LL;
  int v6 = -1;
  sub_10007EF00((uint64_t)"run_type", a2, v4, 15LL);
  return a1;
}

uint64_t sub_1000F19E0(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100183B90);
  sub_1000F1BA4(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000F1A18(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100183B90);
  sub_1000F1BA4(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000F1A58(char *a1)
{
}

uint64_t sub_1000F1A9C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000F1AD0(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000F1B1C(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100183B90);
  sub_1000F1BA4((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000F1B5C(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100183B90);
  sub_1000F1BA4((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000F1BA4(uint64_t a1)
{
  *(void *)a1 = off_100183C60;
  sub_1000F1C40(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000F1C40(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000F1DA8((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000F1D68( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000F1D94(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000F1BA4(a1);
  operator delete(v1);
}

int *sub_1000F1DA8(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      uint64_t v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 417LL;
    __int16 v25 = 2082;
    __int128 v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    __int128 v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        CFIndex v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 417LL;
      __int16 v25 = 2082;
      __int128 v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000F1F8C(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100183DB0);
  sub_1000F2150(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000F1FC4(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100183DB0);
  sub_1000F2150(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000F2004(char *a1)
{
}

uint64_t sub_1000F2048(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000F207C(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000F20C8(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100183DB0);
  sub_1000F2150((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000F2108(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100183DB0);
  sub_1000F2150((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000F2150(uint64_t a1)
{
  *(void *)a1 = off_100183E80;
  sub_1000F21EC(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000F21EC(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000F2354((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000F2314( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000F2340(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000F2150(a1);
  operator delete(v1);
}

int *sub_1000F2354(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      uint64_t v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 458LL;
    __int16 v25 = 2082;
    __int128 v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    __int128 v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        CFIndex v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 458LL;
      __int16 v25 = 2082;
      __int128 v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000F2538(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100183FD0);
  sub_1000F26FC(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000F2570(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100183FD0);
  sub_1000F26FC(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000F25B0(char *a1)
{
}

uint64_t sub_1000F25F4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000F2628(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000F2674(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100183FD0);
  sub_1000F26FC((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000F26B4(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100183FD0);
  sub_1000F26FC((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000F26FC(uint64_t a1)
{
  *(void *)a1 = off_1001840A0;
  sub_1000F2798(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000F2798(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000F2900((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000F28C0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000F28EC(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000F26FC(a1);
  operator delete(v1);
}

int *sub_1000F2900(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      uint64_t v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 500LL;
    __int16 v25 = 2082;
    __int128 v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    __int128 v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        CFIndex v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 500LL;
      __int16 v25 = 2082;
      __int128 v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000F2AE4(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_1001841F0);
  sub_1000F2CA8(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000F2B1C(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001841F0);
  sub_1000F2CA8(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000F2B5C(char *a1)
{
}

uint64_t sub_1000F2BA0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000F2BD4(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000F2C20(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_1001841F0);
  sub_1000F2CA8((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000F2C60(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001841F0);
  sub_1000F2CA8((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000F2CA8(uint64_t a1)
{
  *(void *)a1 = off_1001842C0;
  sub_1000F2D44(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000F2D44(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000F2EAC((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000F2E6C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000F2E98(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000F2CA8(a1);
  operator delete(v1);
}

int *sub_1000F2EAC(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      uint64_t v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 601LL;
    __int16 v25 = 2082;
    __int128 v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    __int128 v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        CFIndex v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 601LL;
      __int16 v25 = 2082;
      __int128 v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000F3090(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100184410);
  sub_1000F3254(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000F30C8(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100184410);
  sub_1000F3254(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000F3108(char *a1)
{
}

uint64_t sub_1000F314C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000F3180(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000F31CC(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100184410);
  sub_1000F3254((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000F320C(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100184410);
  sub_1000F3254((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000F3254(uint64_t a1)
{
  *(void *)a1 = off_1001844E0;
  sub_1000F32F0(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000F32F0(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000F3458((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000F3418( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000F3444(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000F3254(a1);
  operator delete(v1);
}

int *sub_1000F3458(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      uint64_t v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 603LL;
    __int16 v25 = 2082;
    __int128 v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    __int128 v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        CFIndex v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 603LL;
      __int16 v25 = 2082;
      __int128 v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000F363C(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100184630);
  sub_1000F3800(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000F3674(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100184630);
  sub_1000F3800(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000F36B4(char *a1)
{
}

uint64_t sub_1000F36F8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000F372C(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000F3778(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100184630);
  sub_1000F3800((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000F37B8(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100184630);
  sub_1000F3800((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000F3800(uint64_t a1)
{
  *(void *)a1 = off_100184700;
  sub_1000F389C(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000F389C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000F3A04((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000F39C4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000F39F0(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000F3800(a1);
  operator delete(v1);
}

int *sub_1000F3A04(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      uint64_t v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 638LL;
    __int16 v25 = 2082;
    __int128 v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    __int128 v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        CFIndex v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 638LL;
      __int16 v25 = 2082;
      __int128 v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1000F3BE8(uint64_t a1, void *a2, const void **a3, uint64_t a4)
{
  uint64_t v6 = a2[1];
  *(void *)a1 = *a2;
  *(void *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = v6;
  if (v6)
  {
    uint64_t v7 = (unint64_t *)(v6 + 8);
    do
      unint64_t v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }

  *(void *)(a1 + 16) = 0LL;
  uint64_t v9 = *a3;
  *(void *)(a1 + 16) = *a3;
  if (v9) {
    CFRetain(v9);
  }
  *(_BYTE *)(a1 + 24) = 1;
  *(void *)(a1 + sub_1000114F0(v6 - 32) = a4;
  return a1;
}

void sub_1000F3C4C(_Unwind_Exception *a1)
{
}

uint64_t sub_1000F3C60(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)uint64_t result = *(_OWORD *)a2;
  *(void *)a2 = 0LL;
  *(void *)(a2 + std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
  *(_BYTE *)(result + 16) = 0;
  *(_BYTE *)(result + 24) = 0;
  if (*(_BYTE *)(a2 + 24))
  {
    *(void *)(result + 16) = 0LL;
    *(void *)(result + 16) = *(void *)(a2 + 16);
    *(void *)(a2 + 16) = 0LL;
    *(_BYTE *)(result + 24) = 1;
  }

  *(void *)(result + sub_1000114F0(v6 - 32) = *(void *)(a2 + 32);
  *(_OWORD *)(result + 4sub_1000F1278((int *)&v3, 0) = *(_OWORD *)a3;
  *(void *)a3 = 0LL;
  *(void *)(a3 + std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
  *(_BYTE *)(result + 56) = 0;
  *(_BYTE *)(result + 64) = 0;
  if (*(_BYTE *)(a3 + 24))
  {
    *(void *)(result + 56) = 0LL;
    *(void *)(result + 56) = *(void *)(a3 + 16);
    *(void *)(a3 + 16) = 0LL;
    *(_BYTE *)(result + 64) = 1;
  }

  *(void *)(result + 7sub_1000F1278(&v6, 2) = *(void *)(a3 + 32);
  return result;
}

uint64_t sub_1000F3CDC(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100184850);
  sub_1000F3EA0(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000F3D14(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100184850);
  sub_1000F3EA0(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000F3D54(char *a1)
{
}

uint64_t sub_1000F3D98(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000F3DCC(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000F3E18(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100184850);
  sub_1000F3EA0((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000F3E58(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100184850);
  sub_1000F3EA0((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000F3EA0(uint64_t a1)
{
  *(void *)a1 = off_100184920;
  sub_1000F3F3C(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000F3F3C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000F40A4((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000F4064( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000F4090(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000F3EA0(a1);
  operator delete(v1);
}

int *sub_1000F40A4(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      uint64_t v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 898LL;
    __int16 v25 = 2082;
    __int128 v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    __int128 v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        CFIndex v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 898LL;
      __int16 v25 = 2082;
      __int128 v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

void sub_1000F4288(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  uint64_t v4 = sub_100004A74(a1);
  if (v5)
  {
    char v6 = (void *)(a1 + 64);
    std::string::size_type v7 = v4 - (void)v6;
  }

  else
  {
    std::string::size_type v7 = 0LL;
  }

  *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 64);
  a2->__r_.__value_.__l.__cap_ = *(void *)(a1 + 80);
  *(void *)(a1 + 7sub_1000F1278(&v6, 2) = 0LL;
  *(void *)(a1 + 8sub_1000F1278((int *)&v3, 0) = 0LL;
  *(void *)(a1 + 64) = 0LL;
  std::string::resize(a2, v7 + v5, 0);
  std::string::erase(a2, 0LL, v7);
  sub_100004BA0(a1);
}

void sub_1000F4314(_Unwind_Exception *exception_object)
{
}

_DWORD *sub_1000F4330(_DWORD *result, int a2)
{
  uint64_t v2 = 0LL;
  *uint64_t result = a2;
  uint64_t v5 = 0x200000001LL;
  int v6 = 4;
  do
  {
    a2 &= ~*(_DWORD *)((char *)&v5 + v2);
    v2 += 4LL;
  }

  while (v2 != 12);
  if (a2)
  {
    int v3 = a2;
    exception = __cxa_allocate_exception(0x28uLL);
    exception[2] = "invalid flags";
    exception[3] = "flags validator";
    void *exception = &off_10016D430;
    exception[1] = "header_flags";
    *((_DWORD *)exception + std::iostream::~basic_iostream(v2, v3 + 8) = v3;
  }

  return result;
}

_DWORD *sub_1000F4400(_DWORD *a1)
{
  *a1 = 0;
  v3[0] = xmmword_100140E00;
  v3[1] = xmmword_100140E10;
  uint64_t v4 = 0x900000008LL;
  int v5 = 10;
  sub_10007EF00((uint64_t)"checksum_type", 0, v3, 11LL);
  return a1;
}

uint64_t sub_1000F4498(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_1001839A0;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000F4500(_Unwind_Exception *a1)
{
}

void *sub_1000F4514(void *a1, int *a2)
{
  int v3 = *a2;
  if (!*a2) {
    return sub_100004E4C(a1, (uint64_t)"none", 4LL);
  }
  for (uint64_t i = 0LL; i != 18; i += 6LL)
  {
    int v5 = dword_100184990[i];
    if ((v5 & v3) != 0)
    {
      v3 &= ~v5;
      sub_100004E4C(a1, *(void *)&dword_100184990[i + 2], *(void *)&dword_100184990[i + 4]);
      if (v3)
      {
        char v7 = 44;
        sub_100004E4C(a1, (uint64_t)&v7, 1LL);
      }
    }
  }

  return a1;
}

void *sub_1000F45D0(void *a1, _DWORD *a2)
{
  uint64_t v2 = 0LL;
  while (dword_1001849D8[v2] != *a2)
  {
    v2 += 6LL;
    if (v2 == 12)
    {
      int v3 = "no_match";
      uint64_t v4 = 8LL;
      return sub_100004E4C(a1, (uint64_t)v3, v4);
    }
  }

  int v5 = &dword_1001849D8[v2];
  int v3 = (const char *)*((void *)v5 + 1);
  uint64_t v4 = *((void *)v5 + 2);
  return sub_100004E4C(a1, (uint64_t)v3, v4);
}

void *sub_1000F4614(void *a1, _DWORD *a2)
{
  uint64_t v2 = 0LL;
  while (dword_100184A08[v2] != *a2)
  {
    v2 += 6LL;
    if (v2 == 12)
    {
      int v3 = "no_match";
      uint64_t v4 = 8LL;
      return sub_100004E4C(a1, (uint64_t)v3, v4);
    }
  }

  int v5 = &dword_100184A08[v2];
  int v3 = (const char *)*((void *)v5 + 1);
  uint64_t v4 = *((void *)v5 + 2);
  return sub_100004E4C(a1, (uint64_t)v3, v4);
}

void *sub_1000F4658(void *a1, unsigned __int8 *a2, uint64_t a3)
{
  int v5 = a1 + 1;
  uint64_t v6 = *(void *)(*a1 - 24LL);
  int v7 = *(_DWORD *)((char *)a1 + v6 + 8);
  uint64_t v8 = a3 - 1;
  if (a3 == 1)
  {
    int v14 = *(_DWORD *)((char *)a1 + v6 + 8);
  }

  else
  {
    uint64_t v9 = a2;
    uint64_t v10 = a3 - 1;
    do
    {
      *(_DWORD *)((char *)v5 + *(void *)(*a1 - 24LL)) = *(_DWORD *)((_BYTE *)v5 + *(void *)(*a1 - 24LL)) & 0xFFFFFFB5 | 8;
      char v18 = 48;
      uint64_t v11 = sub_1000166BC(a1, &v18);
      *(void *)((char *)v11 + *(void *)(*v11 - 24LL) + 24) = 2LL;
      unsigned int v12 = *v9++;
      __int128 v13 = (void *)std::ostream::operator<<(v11, v12);
      sub_100004E4C(v13, (uint64_t)" ", 1LL);
      --v10;
    }

    while (v10);
    uint64_t v6 = *(void *)(*a1 - 24LL);
    int v14 = *(_DWORD *)((char *)a1 + v6 + 8);
  }

  *(_DWORD *)((char *)a1 + v6 + std::iostream::~basic_iostream(v2, v3 + 8) = v14 & 0xFFFFFFB5 | 8;
  char v17 = 48;
  uint64_t v15 = sub_1000166BC(a1, &v17);
  *(void *)((char *)v15 + *(void *)(*v15 - 24LL) + 24) = 2LL;
  std::ostream::operator<<(v15, a2[v8]);
  *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24LL) + std::iostream::~basic_iostream(v2, v3 + 8) = v7;
  return a1;
}

void *sub_1000F47A4(void *a1, _DWORD *a2)
{
  uint64_t v2 = 0LL;
  while (dword_100184A38[v2] != *a2)
  {
    v2 += 6LL;
    if (v2 == 18)
    {
      int v3 = "no_match";
      uint64_t v4 = 8LL;
      return sub_100004E4C(a1, (uint64_t)v3, v4);
    }
  }

  int v5 = &dword_100184A38[v2];
  int v3 = (const char *)*((void *)v5 + 1);
  uint64_t v4 = *((void *)v5 + 2);
  return sub_100004E4C(a1, (uint64_t)v3, v4);
}

uint64_t sub_1000F47E8(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  *(void *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
  uint64_t v4 = (uint64_t *)(a1 + 8);
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = a1 + 8;
  if (a3)
  {
    uint64_t v6 = 8 * a3;
    do
    {
      sub_1000F4864((uint64_t **)a1, v4, a2, (uint64_t *)a2);
      a2 += 2;
      v6 -= 8LL;
    }

    while (v6);
  }

  return a1;
}

void sub_1000F484C(_Unwind_Exception *a1)
{
}

uint64_t *sub_1000F4864(uint64_t **a1, uint64_t *a2, unsigned int *a3, uint64_t *a4)
{
  uint64_t v6 = sub_1000F48E8(a1, a2, &v11, &v10, a3);
  int v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    int v7 = (uint64_t *)operator new(0x28uLL);
    *(uint64_t *)((char *)v7 + 2std::iostream::~basic_iostream(v2, v3 + 8) = *a4;
    sub_100027200(a1, (uint64_t)v11, v8, v7);
  }

  return v7;
}

uint64_t *sub_1000F48E8(void *a1, uint64_t *a2, uint64_t **a3, uint64_t *a4, unsigned int *a5)
{
  int v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = *a5, unsigned int v7 = *((_DWORD *)a2 + 7), *a5 < v7))
  {
    uint64_t v8 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      uint64_t v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }

      else
      {
        *a3 = a2;
        return a2;
      }
    }

    if (v8)
    {
      uint64_t v9 = (uint64_t *)*a2;
      do
      {
        uint64_t v10 = v9;
        uint64_t v9 = (uint64_t *)v9[1];
      }

      while (v9);
    }

    else
    {
      __int128 v13 = a2;
      do
      {
        uint64_t v10 = (uint64_t *)v13[2];
        BOOL v14 = *v10 == (void)v13;
        __int128 v13 = v10;
      }

      while (v14);
    }

    unsigned int v15 = *a5;
    if (*((_DWORD *)v10 + 7) < *a5) {
      goto LABEL_17;
    }
    uint64_t v16 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          char v17 = (uint64_t *)v16;
          unsigned int v18 = *(_DWORD *)(v16 + 28);
          if (v15 >= v18) {
            break;
          }
          uint64_t v16 = *v17;
          int v5 = v17;
          if (!*v17) {
            goto LABEL_29;
          }
        }

        if (v18 >= v15) {
          break;
        }
        int v5 = v17 + 1;
        uint64_t v16 = v17[1];
      }

      while (v16);
    }

    else
    {
      char v17 = a1 + 1;
    }

uint64_t **sub_1000F4A90(uint64_t **a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  unsigned int v7 = a1 + 1;
  unsigned int v6 = a1[1];
  if (v6)
  {
    unsigned int v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        unsigned int v10 = *((_DWORD *)v6 + 8);
        if (v8 >= v10) {
          break;
        }
        unsigned int v6 = *v9;
        unsigned int v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }

      if (v10 >= v8) {
        break;
      }
      unsigned int v6 = v9[1];
      if (!v6)
      {
        unsigned int v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = operator new(0x30uLL);
    _BYTE v11[8] = **a4;
    *((void *)v11 + 5) = 0LL;
    sub_100027200(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }

  return v9;
}

uint64_t sub_1000F4B50(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_100183C60;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000F4BB8(_Unwind_Exception *a1)
{
}

uint64_t sub_1000F4BCC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v2 = a1 + 8;
  uint64_t v3 = v4;
  if (!v4) {
    return v2;
  }
  unint64_t v5 = (*(_BYTE *)(a2 + 16) & 2) != 0 ? *(void *)a2 : *(void *)a2 + 1LL;
  uint64_t v6 = v2;
  do
  {
    unint64_t v7 = (*(_BYTE *)(v3 + 48) & 1) + *(void *)(v3 + 40) - 1LL;
    BOOL v8 = v7 >= v5;
    if (v7 >= v5) {
      uint64_t v9 = (uint64_t *)v3;
    }
    else {
      uint64_t v9 = (uint64_t *)(v3 + 8);
    }
    if (v8) {
      uint64_t v6 = v3;
    }
    uint64_t v3 = *v9;
  }

  while (*v9);
  if (v6 == v2) {
    return v2;
  }
  unint64_t v10 = *(void *)(v6 + 32);
  if ((*(_BYTE *)(v6 + 48) & 2) == 0) {
    ++v10;
  }
  return v6;
}

uint64_t *sub_1000F4C50(uint64_t **a1, uint64_t a2)
{
  __int128 v14 = *(_OWORD *)a2;
  uint64_t v15 = *(void *)(a2 + 16);
  if ((_BYTE)v15)
  {
    if (v15 == 3)
    {
    }

    else if ((unint64_t)v14 >= *((void *)&v14 + 1))
    {
      return (uint64_t *)(a1 + 1);
    }
  }

  else if ((unint64_t)v14 >= *((void *)&v14 + 1) || (unint64_t)(v14 + 1) >= *((void *)&v14 + 1))
  {
    return (uint64_t *)(a1 + 1);
  }

  unint64_t v5 = (uint64_t *)(a2 + 24);
  if (sub_1000F4D6C(a2 + 24)) {
    return (uint64_t *)(a1 + 1);
  }
  uint64_t result = sub_1000F5200(a1, a2, a2);
  if ((v7 & 1) == 0)
  {
    BOOL v8 = (uint64_t *)sub_1000AC868((uint64_t)a1, (uint64_t)&v14);
    uint64_t v9 = (uint64_t **)sub_1000AC540((uint64_t)a1, (uint64_t)&v14);
    unint64_t v10 = *v9;
    if (*v9)
    {
      do
      {
        uint64_t v11 = v10;
        unint64_t v10 = (uint64_t *)v10[1];
      }

      while (v10);
    }

    else
    {
      do
      {
        uint64_t v11 = v9[2];
        BOOL v12 = *v11 == (void)v9;
        uint64_t v9 = (uint64_t **)v11;
      }

      while (v12);
    }

    __int128 v13 = v11;
    uint64_t v16 = v8;
    sub_1000F4E2C(a1, &v14, v5, &v16, &v13);
    return v16;
  }

  return result;
}

BOOL sub_1000F4D6C(uint64_t a1)
{
  LOBYTE(sub_1000989E4((uint64_t *)va, v2) = 0;
  char v12 = 0;
  if (byte_100198804)
  {
    uint64_t v2 = qword_100198778;
    int v3 = dword_100198780;
    __int128 v8 = unk_1001987C4;
    __int128 v9 = unk_1001987D4;
    __int128 v10 = unk_1001987E4;
    __int128 v11 = unk_1001987F4;
    __int128 v4 = *(_OWORD *)algn_100198784;
    __int128 v5 = unk_100198794;
    __int128 v6 = unk_1001987A4;
    __int128 v7 = unk_1001987B4;
    char v12 = 1;
  }

  return sub_1000F51AC(a1, (uint64_t)&v2);
}

uint64_t sub_1000F4E2C(uint64_t **a1, __int128 *a2, uint64_t *a3, uint64_t **a4, uint64_t **a5)
{
  __int128 v8 = *a5;
  __int128 v9 = (uint64_t *)(*a5)[1];
  if (v9)
  {
    do
    {
      __int128 v10 = v9;
      __int128 v9 = (uint64_t *)*v9;
    }

    while (v9);
  }

  else
  {
    __int128 v11 = *a5;
    do
    {
      __int128 v10 = (uint64_t *)v11[2];
      BOOL v12 = *v10 == (void)v11;
      __int128 v11 = v10;
    }

    while (!v12);
  }

  __int128 v13 = *a4;
  if (*a1 == *a4)
  {
    uint64_t v15 = (uint64_t *)(a1 + 1);
  }

  else
  {
    __int128 v14 = (uint64_t *)*v13;
    if (*v13)
    {
      do
      {
        uint64_t v15 = v14;
        __int128 v14 = (uint64_t *)v14[1];
      }

      while (v14);
    }

    else
    {
      uint64_t v16 = *a4;
      do
      {
        uint64_t v15 = (uint64_t *)v16[2];
        BOOL v12 = *v15 == (void)v16;
        uint64_t v16 = v15;
      }

      while (v12);
    }
  }

  __int128 v39 = *a2;
  uint64_t v40 = *((void *)a2 + 2);
  *(void *)&__int128 v37 = qword_1001985E0;
  *((void *)&v37 + sub_1000F1940(&v11, 1) = qword_1001985E0;
  char v38 = 2;
  __int128 v35 = *((_OWORD *)v8 + 2);
  uint64_t v36 = v8[6];
  if (v13 != v10)
  {
    char v17 = (__int128 *)((char *)a3 + 12);
    do
    {
      __int128 v37 = *((_OWORD *)v13 + 2);
      char v38 = *((_BYTE *)v13 + 48);
      __int128 v33 = v39;
      uint64_t v34 = v40;
      sub_1000AC6C0((unint64_t *)&v33, (uint64_t)&v37, (uint64_t)&v41);
      if ((_BYTE)v42)
      {
        if (v42 == 3)
        {
        }

        else if ((unint64_t)v41 < *((void *)&v41 + 1))
        {
          goto LABEL_24;
        }
      }

      else if ((unint64_t)v41 < *((void *)&v41 + 1) && (unint64_t)(v41 + 1) < *((void *)&v41 + 1))
      {
LABEL_24:
        LOBYTE(v43) = 0;
        char v53 = 0;
        if (*((_BYTE *)a3 + 140))
        {
          uint64_t v43 = *a3;
          int v44 = *((_DWORD *)a3 + 2);
          __int128 v18 = *(_OWORD *)((char *)a3 + 92);
          __int128 v49 = *(_OWORD *)((char *)a3 + 76);
          __int128 v50 = v18;
          __int128 v19 = *(_OWORD *)((char *)a3 + 124);
          __int128 v51 = *(_OWORD *)((char *)a3 + 108);
          __int128 v52 = v19;
          __int128 v20 = *(_OWORD *)((char *)a3 + 28);
          __int128 v45 = *v17;
          __int128 v46 = v20;
          __int128 v21 = *(_OWORD *)((char *)a3 + 60);
          __int128 v47 = *(_OWORD *)((char *)a3 + 44);
          __int128 v48 = v21;
          char v53 = 1;
        }

        *a4 = sub_1000F5334(a1, v15, (uint64_t)&v41, (uint64_t)&v41);
      }

      __int128 v31 = v39;
      uint64_t v32 = v40;
      sub_1000AC794((uint64_t)&v31, (uint64_t)&v37, (uint64_t)&v41);
      __int128 v39 = v41;
      LOBYTE(v4sub_1000F1278((int *)&v3, 0) = v42;
      uint64_t v15 = *a4;
      unsigned int v22 = (uint64_t *)(*a4)[1];
      __int16 v23 = *a4;
      if (v22)
      {
        do
        {
          __int128 v13 = v22;
          unsigned int v22 = (uint64_t *)*v22;
        }

        while (v22);
      }

      else
      {
        do
        {
          __int128 v13 = (uint64_t *)v23[2];
          BOOL v12 = *v13 == (void)v23;
          __int16 v23 = v13;
        }

        while (!v12);
      }

      *a4 = v13;
    }

    while (v13 != v10);
  }

  __int128 v27 = v39;
  uint64_t v28 = v40;
  uint64_t result = sub_1000AC794((uint64_t)&v27, (uint64_t)&v35, (uint64_t)&v29);
  if (!(_BYTE)v30)
  {
    unint64_t v25 = *((void *)&v29 + 1);
    unint64_t v26 = v29 + 1;
    goto LABEL_40;
  }

  if (v30 != 3)
  {
    unint64_t v25 = *((void *)&v29 + 1);
    unint64_t v26 = v29;
LABEL_40:
    if (v26 >= v25) {
      goto LABEL_44;
    }
    goto LABEL_41;
  }

BOOL sub_1000F51AC(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 140)) {
    BOOL v2 = *(_BYTE *)(a2 + 140) == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (v2) {
    return (*(_BYTE *)(a1 + 140) != 0) == (*(_BYTE *)(a2 + 140) != 0);
  }
  if (*(_DWORD *)a1 == *(_DWORD *)a2) {
    return sub_10004A1C4((_DWORD *)(a1 + 4), (_DWORD *)(a2 + 4));
  }
  return 0LL;
}

uint64_t *sub_1000F5200(uint64_t **a1, uint64_t a2, uint64_t a3)
{
  __int128 v5 = (uint64_t **)sub_100027254((uint64_t)a1, &v8, a2);
  uint64_t result = *v5;
  if (!*v5)
  {
    sub_1000F527C((uint64_t)a1, a3, (uint64_t)&v7);
    sub_100027200(a1, v8, v5, v7);
    return v7;
  }

  return result;
}

_OWORD *sub_1000F527C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t result = operator new(0xC8uLL);
  *(void *)a3 = result;
  *(void *)(a3 + std::iostream::~basic_iostream(v2, v3 + 8) = v5;
  result[2] = *(_OWORD *)a2;
  *((void *)result + 6) = *(void *)(a2 + 16);
  *((_BYTE *)result + 56) = 0;
  *((_BYTE *)result + 196) = 0;
  if (*(_BYTE *)(a2 + 164))
  {
    *((void *)result + 7) = *(void *)(a2 + 24);
    *((_DWORD *)result + 16) = *(_DWORD *)(a2 + 32);
    *(_OWORD *)((char *)result + 1sub_1000114F0(v6 - 32) = *(_OWORD *)(a2 + 100);
    *(_OWORD *)((char *)result + 14std::iostream::~basic_iostream(v2, v3 + 8) = *(_OWORD *)(a2 + 116);
    *(_OWORD *)((char *)result + 164) = *(_OWORD *)(a2 + 132);
    *(_OWORD *)((char *)result + 18sub_1000F1278((int *)&v3, 0) = *(_OWORD *)(a2 + 148);
    *(_OWORD *)((char *)result + 6std::iostream::~basic_iostream(v2, v3 + 8) = *(_OWORD *)(a2 + 36);
    *(_OWORD *)((char *)result + 84) = *(_OWORD *)(a2 + 52);
    *(_OWORD *)((char *)result + 10sub_1000F1278((int *)&v3, 0) = *(_OWORD *)(a2 + 68);
    *(_OWORD *)((char *)result + 116) = *(_OWORD *)(a2 + 84);
    *((_BYTE *)result + 196) = 1;
  }

  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

uint64_t *sub_1000F5334(uint64_t **a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  __int128 v6 = (uint64_t **)sub_100027088(a1, a2, &v10, &v9, a3);
  uint64_t result = *v6;
  if (!*v6)
  {
    sub_1000F527C((uint64_t)a1, a4, (uint64_t)&v8);
    sub_100027200(a1, (uint64_t)v10, v6, v8);
    return v8;
  }

  return result;
}

uint64_t sub_1000F53B4(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_100183E80;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000F541C(_Unwind_Exception *a1)
{
}

uint64_t **sub_1000F5430(uint64_t **a1, uint64_t a2)
{
  __int128 v14 = *(_OWORD *)a2;
  uint64_t v15 = *(void *)(a2 + 16);
  if ((_BYTE)v15)
  {
    if (v15 == 3)
    {
    }

    else if ((unint64_t)v14 >= *((void *)&v14 + 1))
    {
      return a1 + 1;
    }
  }

  else if ((unint64_t)v14 >= *((void *)&v14 + 1) || (unint64_t)(v14 + 1) >= *((void *)&v14 + 1))
  {
    return a1 + 1;
  }

  __int128 v5 = (int *)(a2 + 24);
  if (sub_1000F5568(a2 + 24)) {
    return a1 + 1;
  }
  __int128 v7 = (uint64_t *)sub_1000F5918(a1, a2, a2);
  if ((v8 & 1) != 0)
  {
    char v17 = v7;
    sub_1000F59B0(a1, &v17);
    return sub_1000F5ADC(a1, (uint64_t ***)&v17);
  }

  else
  {
    __int128 v9 = (uint64_t *)sub_1000AC868((uint64_t)a1, (uint64_t)&v14);
    __int128 v10 = (uint64_t **)sub_1000AC540((uint64_t)a1, (uint64_t)&v14);
    __int128 v11 = *v10;
    if (*v10)
    {
      do
      {
        BOOL v12 = v11;
        __int128 v11 = (uint64_t *)v11[1];
      }

      while (v11);
    }

    else
    {
      do
      {
        BOOL v12 = v10[2];
        BOOL v13 = *v12 == (void)v10;
        __int128 v10 = (uint64_t **)v12;
      }

      while (v13);
    }

    uint64_t v16 = v9;
    char v17 = v12;
    sub_1000F5628(a1, &v14, v5, &v16, &v17);
    return (uint64_t **)v16;
  }

BOOL sub_1000F5568(uint64_t a1)
{
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)&qword_100198820);
  if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_100198820))
  {
    sub_1000F1940(&dword_100198808, 2);
    qword_100198810 = 0LL;
    qword_100198818 = 0LL;
    __cxa_guard_release(&qword_100198820);
  }

  return *(_DWORD *)a1 == dword_100198808
      && *(void *)(a1 + 8) == qword_100198810
      && *(void *)(a1 + 16) == qword_100198818;
}

void sub_1000F5610(_Unwind_Exception *a1)
{
}

uint64_t sub_1000F5628(uint64_t **a1, __int128 *a2, int *a3, uint64_t **a4, uint64_t **a5)
{
  char v8 = *a5;
  __int128 v9 = (uint64_t *)(*a5)[1];
  if (v9)
  {
    do
    {
      __int128 v10 = v9;
      __int128 v9 = (uint64_t *)*v9;
    }

    while (v9);
  }

  else
  {
    __int128 v11 = *a5;
    do
    {
      __int128 v10 = (uint64_t *)v11[2];
      BOOL v12 = *v10 == (void)v11;
      __int128 v11 = v10;
    }

    while (!v12);
  }

  BOOL v13 = *a4;
  if (*a1 == *a4)
  {
    uint64_t v15 = (uint64_t *)(a1 + 1);
  }

  else
  {
    __int128 v14 = (uint64_t *)*v13;
    if (*v13)
    {
      do
      {
        uint64_t v15 = v14;
        __int128 v14 = (uint64_t *)v14[1];
      }

      while (v14);
    }

    else
    {
      uint64_t v16 = *a4;
      do
      {
        uint64_t v15 = (uint64_t *)v16[2];
        BOOL v12 = *v15 == (void)v16;
        uint64_t v16 = v15;
      }

      while (v12);
    }
  }

  __int128 v39 = *a2;
  uint64_t v40 = *((void *)a2 + 2);
  *(void *)&__int128 v37 = qword_1001985E0;
  *((void *)&v37 + sub_1000F1940(&v11, 1) = qword_1001985E0;
  char v38 = 2;
  __int128 v35 = *((_OWORD *)v8 + 2);
  uint64_t v36 = v8[6];
  if (v13 != v10)
  {
    char v17 = (__int128 *)(a3 + 2);
    while (1)
    {
      __int128 v37 = *((_OWORD *)v13 + 2);
      char v38 = *((_BYTE *)v13 + 48);
      __int128 v33 = v39;
      uint64_t v34 = v40;
      sub_1000AC6C0((unint64_t *)&v33, (uint64_t)&v37, (uint64_t)&v29);
      if ((_BYTE)v30) {
        break;
      }
LABEL_23:
      __int128 v27 = v39;
      uint64_t v28 = v40;
      sub_1000AC794((uint64_t)&v27, (uint64_t)&v37, (uint64_t)&v29);
      __int128 v39 = v29;
      LOBYTE(v4sub_1000F1278((int *)&v3, 0) = v30;
      uint64_t v15 = *a4;
      __int128 v18 = (uint64_t *)(*a4)[1];
      __int128 v19 = *a4;
      if (v18)
      {
        do
        {
          BOOL v13 = v18;
          __int128 v18 = (uint64_t *)*v18;
        }

        while (v18);
      }

      else
      {
        do
        {
          BOOL v13 = (uint64_t *)v19[2];
          BOOL v12 = *v13 == (void)v19;
          __int128 v19 = v13;
        }

        while (!v12);
      }

      *a4 = v13;
      if (v13 == v10) {
        goto LABEL_32;
      }
    }

    if (v30 == 3)
    {
    }

    else if ((unint64_t)v29 >= *((void *)&v29 + 1))
    {
      goto LABEL_23;
    }

_OWORD *sub_1000F5918(uint64_t **a1, uint64_t a2, uint64_t a3)
{
  __int128 v5 = (void **)sub_100027254((uint64_t)a1, &v9, a2);
  __int128 v6 = *v5;
  if (!*v5)
  {
    __int128 v7 = (uint64_t **)v5;
    __int128 v6 = operator new(0x50uLL);
    void v6[2] = *(_OWORD *)a3;
    *((void *)v6 + 6) = *(void *)(a3 + 16);
    *((_DWORD *)v6 + 14) = *(_DWORD *)(a3 + 24);
    unint64_t v6[4] = *(_OWORD *)(a3 + 32);
    sub_100027200(a1, v9, v7, (uint64_t *)v6);
  }

  return v6;
}

uint64_t *sub_1000F59B0(uint64_t **a1, uint64_t **a2)
{
  unsigned __int8 v2 = *a2;
  if (*a2 == *a1) {
    return *a1;
  }
  uint64_t v4 = *v2;
  if (*v2)
  {
    do
    {
      uint64_t v5 = v4;
      uint64_t v4 = *(void *)(v4 + 8);
    }

    while (v4);
  }

  else
  {
    uint64_t v6 = (uint64_t)*a2;
    do
    {
      uint64_t v5 = *(void *)(v6 + 16);
      BOOL v7 = *(void *)v5 == v6;
      uint64_t v6 = v5;
    }

    while (v7);
  }

  uint64_t v8 = v2[4];
  if ((v2[6] & 2) == 0) {
    ++v8;
  }
  if (v8 == (*(_BYTE *)(v5 + 48) & 1) + *(void *)(v5 + 40)
    && *(_DWORD *)(v5 + 56) == *((_DWORD *)v2 + 14)
    && *(void *)(v5 + 64) == v2[8]
    && *(void *)(v5 + 72) == v2[9])
  {
    __int128 v14 = *((_OWORD *)v2 + 2);
    uint64_t v15 = v2[6];
    sub_10003F4FC(a1, v2);
    operator delete(v2);
    __int128 v10 = *(_OWORD *)(v5 + 32);
    uint64_t v11 = *(void *)(v5 + 48);
    sub_1000AC44C((unint64_t *)&v10, (unint64_t *)&v14, (uint64_t)&v12);
    *(_OWORD *)(v5 + sub_1000114F0(v6 - 32) = v12;
    *(_BYTE *)(v5 + 4std::iostream::~basic_iostream(v2, v3 + 8) = v13;
    *a2 = (uint64_t *)v5;
    return (uint64_t *)v5;
  }

  return v2;
}

uint64_t **sub_1000F5ADC(uint64_t **a1, uint64_t ***a2)
{
  int v3 = a1 + 1;
  uint64_t result = *a2;
  if (*a2 == v3) {
    return v3;
  }
  uint64_t v6 = result[1];
  if (v6)
  {
    do
    {
      BOOL v7 = (uint64_t **)v6;
      uint64_t v6 = (uint64_t *)*v6;
    }

    while (v6);
  }

  else
  {
    uint64_t v8 = *a2;
    do
    {
      BOOL v7 = (uint64_t **)v8[2];
      BOOL v9 = *v7 == (uint64_t *)v8;
      uint64_t v8 = v7;
    }

    while (!v9);
  }

  if (v7 != v3)
  {
    __int128 v10 = v7[4];
    if (((_BYTE)v7[6] & 2) == 0) {
      __int128 v10 = (uint64_t *)((char *)v10 + 1);
    }
    if (v10 == (uint64_t *)((char *)result[5] + ((_BYTE)result[6] & 1))
      && *((_DWORD *)result + 14) == *((_DWORD *)v7 + 14)
      && result[8] == v7[8]
      && result[9] == v7[9])
    {
      __int128 v17 = *((_OWORD *)v7 + 2);
      __int128 v18 = v7[6];
      sub_10003F4FC(a1, (uint64_t *)v7);
      operator delete(v7);
      uint64_t v11 = *a2;
      __int128 v13 = *((_OWORD *)*a2 + 2);
      __int128 v14 = v11[6];
      sub_1000AC44C((unint64_t *)&v13, (unint64_t *)&v17, (uint64_t)&v15);
      __int128 v12 = *a2;
      *((_OWORD *)v12 + sub_1000F1278(&v6, 2) = v15;
      *((_BYTE *)v12 + 4std::iostream::~basic_iostream(v2, v3 + 8) = v16;
      return *a2;
    }
  }

  return result;
}

uint64_t sub_1000F5C10(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_1001840A0;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000F5C78(_Unwind_Exception *a1)
{
}

uint64_t sub_1000F5C8C(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  *(void *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
  char v4 = (void *)(a1 + 8);
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = a1 + 8;
  if (a3)
  {
    uint64_t v6 = 48 * a3;
    do
    {
      sub_1000F5D0C((uint64_t **)a1, v4, a2, (uint64_t)a2);
      a2 += 6;
      v6 -= 48LL;
    }

    while (v6);
  }

  return a1;
}

void sub_1000F5CF4(_Unwind_Exception *a1)
{
}

_OWORD *sub_1000F5D0C(uint64_t **a1, void *a2, unint64_t *a3, uint64_t a4)
{
  uint64_t v6 = sub_1000F5DA8(a1, a2, &v11, &v10, a3);
  BOOL v7 = (_OWORD *)*v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    BOOL v7 = operator new(0x50uLL);
    unint64_t v7[2] = *(_OWORD *)a4;
    *((void *)v7 + 6) = *(void *)(a4 + 16);
    *((_DWORD *)v7 + 14) = *(_DWORD *)(a4 + 24);
    void v7[4] = *(_OWORD *)(a4 + 32);
    sub_100027200(a1, v11, v8, (uint64_t *)v7);
  }

  return v7;
}

uint64_t *sub_1000F5DA8(void *a1, void *a2, void *a3, uint64_t *a4, unint64_t *a5)
{
  BOOL v9 = a1 + 1;
  if (a1 + 1 == a2 || sub_100098D54(a5, a2 + 4))
  {
    if ((void *)*a1 == a2)
    {
      __int128 v12 = a2;
LABEL_16:
      if (*a2)
      {
        *a3 = v12;
        return v12 + 1;
      }

      else
      {
        *a3 = a2;
        return a2;
      }
    }

    uint64_t v11 = (void *)*a2;
    if (*a2)
    {
      do
      {
        __int128 v12 = v11;
        uint64_t v11 = (void *)v11[1];
      }

      while (v11);
    }

    else
    {
      char v16 = a2;
      do
      {
        __int128 v12 = (void *)v16[2];
        BOOL v17 = *v12 == (void)v16;
        char v16 = v12;
      }

      while (v17);
    }

    return sub_100098CC4((uint64_t)a1, a3, a5);
  }

  if (sub_100098D54(a2 + 4, a5))
  {
    a4 = a2 + 1;
    uint64_t v13 = a2[1];
    if (v13)
    {
      __int128 v14 = (void *)a2[1];
      do
      {
        __int128 v15 = v14;
        __int128 v14 = (void *)*v14;
      }

      while (v14);
    }

    else
    {
      __int128 v18 = a2;
      do
      {
        __int128 v15 = (void *)v18[2];
        BOOL v17 = *v15 == (void)v18;
        __int128 v18 = v15;
      }

      while (!v17);
    }

    if (v15 != v9)
    {
      uint64_t v13 = *a4;
    }

    if (v13)
    {
      *a3 = v15;
      return v15;
    }

    else
    {
      *a3 = a2;
    }

    return a4;
  }

  *a3 = a2;
  *a4 = (uint64_t)a2;
  return a4;
}

void sub_1000F5F2C(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  uint64_t v10 = *a1;
  unint64_t v11 = sub_1000F5FC8((uint64_t)a1, a3);
  if (v11 >> 57) {
    sub_100014AD4("get_next_capacity, allocator's max size reached");
  }
  uint64_t v12 = v11;
  uint64_t v13 = operator new(v11 << 6);
  sub_1000F603C(a1, (uint64_t)v13, v12, a2, a3, a4);
  *a5 = *a1 + a2 - v10;
}

unint64_t sub_1000F5FC8(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = 0x1FFFFFFFFFFFFFFLL;
  uint64_t v3 = *(void *)(a1 + 8);
  unint64_t v4 = *(void *)(a1 + 16);
  if (0x1FFFFFFFFFFFFFFLL - v4 < a2 - v4 + v3) {
    sub_100014AD4("get_next_capacity, allocator's max size reached");
  }
  unint64_t v5 = v4 >> 61;
  unint64_t v6 = 8 * v4;
  if (v5 > 4) {
    uint64_t v7 = -1LL;
  }
  else {
    uint64_t v7 = v6;
  }
  unint64_t v8 = v6 / 5;
  if (v5) {
    unint64_t v8 = v7;
  }
  unint64_t v9 = v3 + a2;
  if (v8 < 0x1FFFFFFFFFFFFFFLL) {
    unint64_t v2 = v8;
  }
  if (v9 <= v2) {
    return v2;
  }
  else {
    return v9;
  }
}

void sub_1000F603C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10 = (void *)*a1;
  uint64_t v11 = *a1 + (a1[1] << 6);
  uint64_t v12 = a2;
  if (*a1 != a4)
  {
    uint64_t v13 = (void *)*a1;
    uint64_t v12 = a2;
    do
    {
      *(_DWORD *)uint64_t v12 = *(_DWORD *)v13;
      __int128 v14 = *(_OWORD *)(v13 + 1);
      __int128 v15 = *(_OWORD *)(v13 + 3);
      __int128 v16 = *(_OWORD *)(v13 + 5);
      *(void *)(v12 + 56) = v13[7];
      *(_OWORD *)(v12 + 4sub_1000F1278((int *)&v3, 0) = v16;
      *(_OWORD *)(v12 + 24) = v15;
      *(_OWORD *)(v12 + std::iostream::~basic_iostream(v2, v3 + 8) = v14;
      v12 += 64LL;
      v13 += 8;
    }

    while (v13 != (void *)a4);
  }

  *(_DWORD *)uint64_t v12 = *(_DWORD *)a6;
  __int128 v17 = *(_OWORD *)(a6 + 8);
  __int128 v18 = *(_OWORD *)(a6 + 24);
  __int128 v19 = *(_OWORD *)(a6 + 40);
  *(void *)(v12 + 56) = *(void *)(a6 + 56);
  *(_OWORD *)(v12 + 4sub_1000F1278((int *)&v3, 0) = v19;
  *(_OWORD *)(v12 + 24) = v18;
  *(_OWORD *)(v12 + std::iostream::~basic_iostream(v2, v3 + 8) = v17;
  if (v11 != a4)
  {
    uint64_t v20 = v12 + (a5 << 6);
    do
    {
      *(_DWORD *)uint64_t v20 = *(_DWORD *)a4;
      __int128 v21 = *(_OWORD *)(a4 + 8);
      __int128 v22 = *(_OWORD *)(a4 + 24);
      __int128 v23 = *(_OWORD *)(a4 + 40);
      *(void *)(v20 + 56) = *(void *)(a4 + 56);
      *(_OWORD *)(v20 + 4sub_1000F1278((int *)&v3, 0) = v23;
      *(_OWORD *)(v20 + 24) = v22;
      *(_OWORD *)(v20 + std::iostream::~basic_iostream(v2, v3 + 8) = v21;
      a4 += 64LL;
      v20 += 64LL;
    }

    while (a4 != v11);
  }

  if (v10)
  {
    uint64_t v24 = (void *)*a1;
    if (a1 + 3 != (void *)*a1) {
      operator delete(v24);
    }
  }

  uint64_t v25 = a1[1] + a5;
  *a1 = a2;
  a1[1] = v25;
  a1[2] = a3;
}

uint64_t sub_1000F6154(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_1001842C0;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000F61BC(_Unwind_Exception *a1)
{
}

uint64_t sub_1000F61D0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1;
  uint64_t v2 = *(unsigned int *)(a2 + 12);
  if ((_DWORD)v2 == -1) {
    sub_100017130();
  }
  __int128 v5 = &v4;
  return ((uint64_t (*)(uint64_t **, uint64_t))off_100184A80[v2])(&v5, a2 + 4);
}

void *sub_1000F621C(void ***a1)
{
  return sub_1000F6234(**a1);
}

void *sub_1000F6228(void ***a1, int *a2)
{
  return sub_1000F6270(**a1, a2);
}

void *sub_1000F6234(void *a1)
{
  uint64_t v1 = sub_100004E4C(a1, (uint64_t)"none {", 6LL);
  uint64_t v2 = sub_100004E4C(v1, (uint64_t)"[empty]", 7LL);
  return sub_100004E4C(v2, (uint64_t)"}", 1LL);
}

void *sub_1000F6270(void *a1, int *a2)
{
  uint64_t v3 = sub_100004E4C(a1, (uint64_t)"crc32 {", 7LL);
  int v6 = *a2;
  uint64_t v4 = sub_1000F4658(v3, (unsigned __int8 *)&v6, 4LL);
  return sub_100004E4C(v4, (uint64_t)"}", 1LL);
}

uint64_t sub_1000F62C4(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_1001844E0;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000F632C(_Unwind_Exception *a1)
{
}

uint64_t sub_1000F6340(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_100184700;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000F63A8(_Unwind_Exception *a1)
{
}

void *sub_1000F63BC(void *a1, uint64_t a2)
{
  *a1 = a2;
  char v4 = operator new(0x20uLL);
  void *v4 = &off_100184AA0;
  v4[1] = 0LL;
  _OWORD v4[2] = 0LL;
  _OWORD v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_1000F6400(void *a1)
{
  if (v1) {
    operator delete[](v1);
  }
  __cxa_rethrow();
}

void sub_1000F6418(_Unwind_Exception *a1)
{
}

void sub_1000F6430(std::__shared_weak_count *a1)
{
}

void sub_1000F6444(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 24);
  if (v1) {
    operator delete[](v1);
  }
}

uint64_t sub_1000F6454(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_DWORD *sub_1000F6494(_DWORD *a1)
{
  *a1 = 0;
  v3[0] = xmmword_100140E20;
  v3[1] = xmmword_100140E30;
  _OWORD v3[2] = xmmword_100140E40;
  unint64_t v4 = 0x8000000880000007LL;
  int v5 = -1;
  sub_10007EF00((uint64_t)"run_type", 0, v3, 15LL);
  return a1;
}

uint64_t sub_1000F6538(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_100184920;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1000F65A0(_Unwind_Exception *a1)
{
}

void sub_1000F65B4(const __CFString *a1@<X0>, void *a2@<X8>)
{
  CFIndex Length = CFStringGetLength(a1);
  CFIndex v5 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
  int v6 = operator new[](v5);
  bzero(v6, v5);
  if (!CFStringGetCString(a1, (char *)v6, v5, 0x8000100u))
  {
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = &off_100189E78;
    unint64_t v8 = std::generic_category();
    exception[1] = 22LL;
    exception[2] = v8;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 4std::iostream::~basic_iostream(v2, v3 + 8) = 0;
    exception[7] = "Couldn't convert CFStringRef to a proper std string";
  }

  sub_100004CB0(a2, (char *)v6);
  operator delete[](v6);
}

void sub_1000F6684(_Unwind_Exception *a1)
{
}

uint64_t sub_1000F6698(const __CFString *a1)
{
  if (!a1)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    CFIndex v5 = "Invalid resource key";
    goto LABEL_8;
  }

  unint64_t Length = CFStringGetLength(a1);
  if (Length >= 5)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    CFIndex v5 = "Resource name is too long to fit uint32_t";
    goto LABEL_8;
  }

  v8.length = Length;
  v8.location = 0LL;
  if (CFStringGetBytes(a1, v8, 0, 0, 0, buffer, 4LL, 0LL) != 4)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    CFIndex v5 = "Can't get key in cstring format";
LABEL_8:
    int v6 = (void *)sub_100004870((uint64_t)exception, (uint64_t)v5, 0x16u);
  }

  return bswap32(*(unsigned int *)buffer);
}

BOOL sub_1000F675C(__CFArray *a1, uint64_t a2)
{
  uint64_t valuePtr = a2;
  CFNumberRef v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  CFNumberRef v5 = v3;
  if (v3) {
    CFArrayAppendValue(a1, v3);
  }
  sub_1000B95A8((const void **)&v5);
  return v3 != 0LL;
}

void sub_1000F67C8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

BOOL sub_1000F67DC(__CFDictionary *a1, const void *a2, uint64_t a3)
{
  uint64_t valuePtr = a3;
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  CFNumberRef v7 = v5;
  if (v5) {
    CFDictionarySetValue(a1, a2, v5);
  }
  sub_1000B95A8((const void **)&v7);
  return v5 != 0LL;
}

void sub_1000F6858( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

__CFDictionary *sub_1000F686C@<X0>( const void **keys@<X0>, const void **values@<X1>, CFIndex numValues@<X2>, CFMutableDictionaryRef *a4@<X8>)
{
  if (keys && values && numValues)
  {
    uint64_t result = CFDictionaryCreate( kCFAllocatorDefault,  keys,  values,  numValues,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    CFMutableDictionaryRef Mutable = result;
  }

  else
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    CFNumberRef v7 = 0LL;
    uint64_t result = (__CFDictionary *)sub_100026DC0(&v7);
  }

  *a4 = Mutable;
  return result;
}

CFMutableDictionaryRef sub_1000F6908@<X0>(CFMutableDictionaryRef *a1@<X8>)
{
  CFMutableDictionaryRef result = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  *a1 = result;
  return result;
}

const void **sub_1000F694C@<X0>(CFPropertyListRef propertyList@<X0>, const __CFData **a2@<X8>)
{
  CFErrorRef error = 0LL;
  CFNumberRef v3 = CFPropertyListCreateData(kCFAllocatorDefault, propertyList, kCFPropertyListXMLFormat_v1_0, 0LL, &error);
  char v4 = v3;
  if (v3) {
    BOOL v5 = error == 0LL;
  }
  else {
    BOOL v5 = 0;
  }
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = &off_100189E78;
    uint64_t v10 = std::generic_category();
    exception[1] = 22LL;
    exception[2] = v10;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 4std::iostream::~basic_iostream(v2, v3 + 8) = 0;
    exception[7] = "Can't serialize property list";
  }

  CFIndex Length = CFDataGetLength(v3);
  CFTypeID TypeID = CFDataGetTypeID();
  if (CFGetTypeID(v4) != TypeID)
  {
    uint64_t v11 = __cxa_allocate_exception(0x40uLL);
    CFTypeID v12 = CFGetTypeID(v4);
    uint64_t v13 = sub_100026B08(v11, v12, TypeID);
  }

  __int128 v14 = 0LL;
  *a2 = v4;
  a2[1] = (const __CFData *)Length;
  sub_100072048(&v14);
  return sub_10007246C((const void **)&error);
}

void sub_1000F6A7C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10)
{
}

const void **sub_1000F6AA8@<X0>(UInt8 *bytes@<X0>, CFIndex length@<X1>, void *a3@<X8>)
{
  CFErrorRef error = 0LL;
  CFDataRef v4 = CFDataCreate(kCFAllocatorDefault, bytes, length);
  CFDataRef v19 = v4;
  if (v4) {
    BOOL v5 = error == 0LL;
  }
  else {
    BOOL v5 = 0;
  }
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = &off_100189E78;
    uint64_t v11 = std::generic_category();
    exception[1] = 12LL;
    exception[2] = v11;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 4std::iostream::~basic_iostream(v2, v3 + 8) = 0;
    exception[7] = "Can't create data for plist deserialization";
  }

  CFPropertyListFormat format = kCFPropertyListXMLFormat_v1_0;
  CFPropertyListRef v6 = CFPropertyListCreateWithData(kCFAllocatorDefault, v4, 0LL, &format, &error);
  if (v6) {
    BOOL v7 = error == 0LL;
  }
  else {
    BOOL v7 = 0;
  }
  if (!v7)
  {
    CFTypeID v12 = __cxa_allocate_exception(0x40uLL);
    unsigned int Code = CFErrorGetCode(error);
    *CFTypeID v12 = &off_100189E78;
    __int128 v14 = std::generic_category();
    v12[1] = Code;
    void v12[2] = v14;
    *((_BYTE *)v12 + 24) = 0;
    *((_BYTE *)v12 + 4std::iostream::~basic_iostream(v2, v3 + 8) = 0;
    v12[7] = "Can't convert data to property list";
  }

  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (CFGetTypeID(v6) != TypeID)
  {
    __int128 v15 = __cxa_allocate_exception(0x40uLL);
    CFTypeID v16 = CFGetTypeID(v6);
    __int128 v17 = sub_100026B08(v15, v16, TypeID);
  }

  *a3 = v6;
  sub_100072048((const void **)&v19);
  return sub_10007246C((const void **)&error);
}

void sub_1000F6C58( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, const void *a11, const void *a12)
{
}

char *sub_1000F6CA0@<X0>( const __CFData *a1@<X0>, unsigned int a2@<W1>, size_t a3@<X2>, unint64_t *a4@<X8>)
{
  unint64_t Length = CFDataGetLength(a1);
  if (!a3) {
    a3 = Length;
  }
  unint64_t v9 = a3 + a2;
  if (__CFADD__(a3, a2) || Length < v9)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    uint64_t v13 = (void *)sub_100004870((uint64_t)exception, (uint64_t)"Unable to convert data to vector.", 0x16u);
  }

  *a4 = 0LL;
  a4[1] = 0LL;
  a4[2] = 0LL;
  BytePtr = CFDataGetBytePtr(a1);
  sub_1000F6D7C(a4, a3);
  return sub_1000F6F70((uint64_t)a4, (char *)*a4, (char *)&BytePtr[a2], (char *)&BytePtr[v9], a3);
}

void sub_1000F6D5C(_Unwind_Exception *exception_object)
{
  CFNumberRef v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + std::iostream::~basic_iostream(v2, v3 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_1000F6D7C(unint64_t *a1, size_t __sz)
{
  unint64_t v2 = *a1;
  if (a1[2] - *a1 < __sz)
  {
    if ((__sz & 0x8000000000000000LL) != 0) {
      sub_100016F4C();
    }
    BOOL v5 = (char *)a1[1];
    CFPropertyListRef v6 = operator new(__sz);
    BOOL v7 = &v5[(void)v6 - v2];
    CFRange v8 = v7;
    if (v5 != (char *)v2)
    {
      unint64_t v9 = &v5[~v2];
      do
      {
        char v10 = *--v5;
        (v9--)[(void)v6] = v10;
      }

      while (v5 != (char *)v2);
      CFRange v8 = v6;
    }

    *a1 = (unint64_t)v8;
    a1[1] = (unint64_t)v7;
    a1[2] = (unint64_t)&v6[__sz];
    if (v2) {
      operator delete((void *)v2);
    }
  }

BOOL sub_1000F6E24(__CFDictionary *a1, const void *a2, uint64_t a3)
{
  else {
    BOOL v5 = *(const char **)a3;
  }
  CFStringRef v6 = CFStringCreateWithCString(kCFAllocatorDefault, v5, 0x8000100u);
  CFStringRef v8 = v6;
  if (v6) {
    CFDictionarySetValue(a1, a2, v6);
  }
  sub_100026A94((const void **)&v8);
  return v6 != 0LL;
}

void sub_1000F6EAC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_1000F6EC0(CFMutableDictionaryRef *a1, uint64_t *a2)
{
  uint64_t v2 = a2[1];
  if (v2)
  {
    uint64_t v4 = *a2;
    uint64_t v5 = *a2 + 16 * v2;
    do
    {
      CFStringRef v6 = *(const void **)v4;
      BOOL v7 = *(const void **)(v4 + 8);
      v4 += 16LL;
      CFDictionaryAddValue(*a1, v6, v7);
    }

    while (v4 != v5);
  }

void sub_1000F6F08(uint64_t *a1@<X0>, CFMutableDictionaryRef *a2@<X8>)
{
  *a2 = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  sub_1000F6EC0(a2, a1);
}

void sub_1000F6F5C(_Unwind_Exception *a1)
{
}

char *sub_1000F6F70(uint64_t a1, char *__dst, char *__src, char *a4, int64_t a5)
{
  uint64_t v5 = __dst;
  if (a5 < 1) {
    return v5;
  }
  char v10 = *(char **)(a1 + 8);
  uint64_t v9 = *(void *)(a1 + 16);
  if (v9 - (uint64_t)v10 < a5)
  {
    uint64_t v11 = *(char **)a1;
    uint64_t v12 = (uint64_t)&v10[a5 - *(void *)a1];
    if (v12 < 0) {
      sub_100016F4C();
    }
    uint64_t v13 = (char *)(__dst - v11);
    unint64_t v14 = v9 - (void)v11;
    if (2 * v14 > v12) {
      uint64_t v12 = 2 * v14;
    }
    if (v14 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v15 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v15 = v12;
    }
    if (v15)
    {
      size_t v16 = v15;
      __int128 v17 = (char *)operator new(v15);
    }

    else
    {
      size_t v16 = 0LL;
      __int128 v17 = 0LL;
    }

    __int128 v27 = &v13[(void)v17];
    memcpy(&v13[(void)v17], __src, a5);
    uint64_t v28 = &v13[(void)v17];
    size_t v29 = v16;
    if (v11 != v5)
    {
      do
      {
        v13[(void)v17 - 1] = v13[(void)(v11 - 1)];
        --v13;
      }

      while (v13);
      char v10 = *(char **)(a1 + 8);
      uint64_t v28 = v17;
    }

    uint64_t v30 = &v27[a5];
    int v31 = &v17[v29];
    if (v10 != v5) {
      memmove(v30, v5, v10 - v5);
    }
    __int128 v32 = *(char **)a1;
    *(void *)a1 = v28;
    *(void *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = &v30[v10 - v5];
    *(void *)(a1 + 16) = v31;
    if (v32) {
      operator delete(v32);
    }
    return v27;
  }

  uint64_t v18 = v10 - __dst;
  if (v10 - __dst >= a5)
  {
    CFDataRef v19 = &__src[a5];
    __int128 v21 = *(char **)(a1 + 8);
LABEL_17:
    __int128 v22 = &v5[a5];
    __int128 v23 = &v21[-a5];
    uint64_t v24 = v21;
    if (&v21[-a5] < v10)
    {
      int64_t v25 = &v10[a5] - v21;
      uint64_t v24 = v21;
      do
      {
        char v26 = *v23++;
        *v24++ = v26;
        --v25;
      }

      while (v25);
    }

    *(void *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = v24;
    if (v21 != v22) {
      memmove(&v5[a5], v5, v21 - v22);
    }
    if (v19 != __src) {
      memmove(v5, __src, v19 - __src);
    }
    return v5;
  }

  CFDataRef v19 = &__src[v18];
  int64_t v20 = a4 - &__src[v18];
  if (a4 != &__src[v18]) {
    memmove(*(void **)(a1 + 8), &__src[v18], a4 - &__src[v18]);
  }
  __int128 v21 = &v10[v20];
  *(void *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = &v10[v20];
  if (v18 >= 1) {
    goto LABEL_17;
  }
  return v5;
}

void sub_1000F7574(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000F75EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000F76A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000F7700(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000F7928( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v18 = v17;

  _Unwind_Resume(a1);
}

void sub_1000F7B44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000F7BE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1000F7C28(uint64_t a1)
{
  uint64_t v2 = operator new[](*(void *)a1);
  unint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void **)(a1 + 32);
  if ((unint64_t)v4 >= v3)
  {
    uint64_t v6 = *(void *)(a1 + 24);
    uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
    uint64_t v8 = v3 - v6;
    uint64_t v9 = v8 >> 2;
    else {
      unint64_t v10 = v9;
    }
    if (v10) {
      uint64_t v11 = (char *)sub_10001848C(a1 + 40, v10);
    }
    else {
      uint64_t v11 = 0LL;
    }
    uint64_t v12 = &v11[8 * v7];
    uint64_t v13 = &v11[8 * v10];
    *(void *)uint64_t v12 = v2;
    uint64_t v5 = v12 + 8;
    size_t v15 = *(char **)(a1 + 24);
    unint64_t v14 = *(char **)(a1 + 32);
    if (v14 != v15)
    {
      do
      {
        uint64_t v16 = *((void *)v14 - 1);
        v14 -= 8;
        *((void *)v12 - sub_1000F1940(&v11, 1) = v16;
        v12 -= 8;
      }

      while (v14 != v15);
      unint64_t v14 = *(char **)(a1 + 24);
    }

    *(void *)(a1 + 24) = v12;
    *(void *)(a1 + sub_1000114F0(v6 - 32) = v5;
    *(void *)(a1 + 4sub_1000F1278((int *)&v3, 0) = v13;
    if (v14) {
      operator delete(v14);
    }
  }

  else
  {
    void *v4 = v2;
    uint64_t v5 = v4 + 1;
  }

  *(void *)(a1 + sub_1000114F0(v6 - 32) = v5;
  ++*(_DWORD *)(a1 + 8);
}

uint64_t sub_1000F7D18(uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 24);
  unint64_t v3 = *(void ***)(a1 + 32);
  if (v2 != v3)
  {
    do
    {
      if (*v2) {
        operator delete[](*v2);
      }
      ++v2;
    }

    while (v2 != v3);
    uint64_t v2 = *(void ***)(a1 + 24);
  }

  *(void *)(a1 + sub_1000114F0(v6 - 32) = v2;
  std::mutex::~mutex((std::mutex *)(a1 + 96));
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 48));
  uint64_t v4 = *(void **)(a1 + 24);
  if (v4)
  {
    *(void *)(a1 + sub_1000114F0(v6 - 32) = v4;
    operator delete(v4);
  }

  return a1;
}

uint64_t sub_1000F7D8C(uint64_t a1, uint64_t a2, unsigned int a3, unint64_t a4)
{
  unsigned int v4 = a3;
  *(void *)a1 = a2;
  *(_DWORD *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = 0;
  *(void *)(a1 + sub_1000114F0(v6 - 32) = 0LL;
  *(void *)(a1 + 4sub_1000F1278((int *)&v3, 0) = 0LL;
  *(void *)(a1 + 24) = 0LL;
  uint64_t v6 = (void **)(a1 + 24);
  *(void *)(a1 + 4std::iostream::~basic_iostream(v2, v3 + 8) = 1018212795LL;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = 0u;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
  *(void *)(a1 + 96) = 850045863LL;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 12sub_1000F1278((int *)&v3, 0) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(void *)(a1 + 15sub_1000F1278(&v6, 2) = 0LL;
  if (a3 <= a4) {
    unint64_t v7 = a4;
  }
  else {
    unint64_t v7 = a3;
  }
  *(void *)(a1 + 16) = v7;
  sub_1000986D0(v6, a3);
  for (; v4; --v4)
    sub_1000F7C28(a1);
  return a1;
}

void sub_1000F7E1C(_Unwind_Exception *a1)
{
}

void sub_1000F7E38(uint64_t a1@<X0>, void *a2@<X8>)
{
  __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 96);
  __lk.__owns_ = 1;
  std::mutex::lock((std::mutex *)(a1 + 96));
  uint64_t v4 = *(void *)(a1 + 32);
  if (*(void *)(a1 + 24) == v4)
  {
    if (*(void *)(a1 + 16) <= (unint64_t)*(unsigned int *)(a1 + 8))
    {
      do
      {
        std::condition_variable::wait((std::condition_variable *)(a1 + 48), &__lk);
        uint64_t v4 = *(void *)(a1 + 32);
      }

      while (*(void *)(a1 + 24) == v4);
    }

    else
    {
      sub_1000F7C28(a1);
      uint64_t v4 = *(void *)(a1 + 32);
    }
  }

  uint64_t v5 = *(void *)(v4 - 8);
  *(void *)(a1 + sub_1000114F0(v6 - 32) = v4 - 8;
  uint64_t v8 = a1;
  *a2 = v5;
  uint64_t v6 = operator new(0x28uLL);
  void *v6 = &off_100184B40;
  v6[1] = 0LL;
  void v6[2] = 0LL;
  void v6[3] = v5;
  unint64_t v6[4] = a1;
  a2[1] = v6;
  if (__lk.__owns_) {
    std::mutex::unlock(__lk.__m_);
  }
}

void sub_1000F7F04( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::mutex *a10, char a11, int a12, __int16 a13, char a14, char a15)
{
}

void sub_1000F7F48(void *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = (std::mutex *)(*a1 + 96LL);
  std::mutex::lock(v4);
  uint64_t v5 = *(void **)(v3 + 32);
  unint64_t v6 = *(void *)(v3 + 40);
  if ((unint64_t)v5 >= v6)
  {
    uint64_t v8 = *(void *)(v3 + 24);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    uint64_t v10 = v6 - v8;
    uint64_t v11 = v10 >> 2;
    else {
      unint64_t v12 = v11;
    }
    if (v12) {
      uint64_t v13 = (char *)sub_10001848C(v3 + 40, v12);
    }
    else {
      uint64_t v13 = 0LL;
    }
    unint64_t v14 = &v13[8 * v9];
    size_t v15 = &v13[8 * v12];
    *(void *)unint64_t v14 = a2;
    unint64_t v7 = v14 + 8;
    __int128 v17 = *(char **)(v3 + 24);
    uint64_t v16 = *(char **)(v3 + 32);
    if (v16 != v17)
    {
      do
      {
        uint64_t v18 = *((void *)v16 - 1);
        v16 -= 8;
        *((void *)v14 - sub_1000F1940(&v11, 1) = v18;
        v14 -= 8;
      }

      while (v16 != v17);
      uint64_t v16 = *(char **)(v3 + 24);
    }

    *(void *)(v3 + 24) = v14;
    *(void *)(v3 + sub_1000114F0(v6 - 32) = v7;
    *(void *)(v3 + 4sub_1000F1278((int *)&v3, 0) = v15;
    if (v16) {
      operator delete(v16);
    }
  }

  else
  {
    *uint64_t v5 = a2;
    unint64_t v7 = v5 + 1;
  }

  *(void *)(v3 + sub_1000114F0(v6 - 32) = v7;
  std::mutex::unlock(v4);
  std::condition_variable::notify_one((std::condition_variable *)(v3 + 48));
}

void sub_1000F8048(_Unwind_Exception *a1)
{
}

void sub_1000F8060(std::__shared_weak_count *a1)
{
}

void sub_1000F8074(uint64_t a1)
{
}

uint64_t sub_1000F8098(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

void *sub_1000F80D8(void *a1, uint64_t *a2, uint64_t *a3)
{
  unint64_t v6 = sub_1000376FC(a1, a2);
  void *v6 = off_100184BA0;
  unint64_t v7 = (uint64_t **)(v6 + 5);
  uint64_t v8 = *a2;
  uint64_t v9 = (std::__shared_weak_count *)a2[1];
  __int128 v27 = v9;
  if (v9)
  {
    uint64_t p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }

  int v12 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 176LL))(v8);
  uint64_t v14 = *a3;
  uint64_t v13 = (std::__shared_weak_count *)a3[1];
  if (v13)
  {
    size_t v15 = (unint64_t *)&v13->__shared_owners_;
    do
      unint64_t v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }

  __int128 v17 = operator new(0x38uLL);
  v17[1] = 0LL;
  v17[2] = 0LL;
  *__int128 v17 = off_100184C80;
  v17[3] = 0LL;
  uint64_t v18 = (char *)(v17 + 3);
  *((_DWORD *)v17 + std::iostream::~basic_iostream(v2, v3 + 8) = v12;
  v17[5] = v14;
  v17[6] = v13;
  if (v13)
  {
    CFDataRef v19 = (unint64_t *)&v13->__shared_owners_;
    do
      unint64_t v20 = __ldxr(v19);
    while (__stxr(v20 + 1, v19));
    a1[5] = v18;
    a1[6] = v17;
    do
      unint64_t v21 = __ldaxr(v19);
    while (__stlxr(v21 - 1, v19));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }

  else
  {
    a1[5] = v18;
    a1[6] = v17;
  }

  if (v27)
  {
    __int128 v22 = (unint64_t *)&v27->__shared_owners_;
    do
      unint64_t v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }

  a1[7] = 0LL;
  a1[8] = 0LL;
  uint64_t v24 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v24 = 850045863LL;
  *(_OWORD *)(v24 + std::iostream::~basic_iostream(v2, v3 + 8) = 0u;
  *(_OWORD *)(v24 + 24) = 0u;
  *(_OWORD *)(v24 + 4sub_1000F1278((int *)&v3, 0) = 0u;
  *((void *)v24 + 7) = 0LL;
  sub_1000F8724(a1 + 9, (uint64_t)v24);
  sub_1000F82F4((uint64_t)a1, *(_DWORD *)(a1[5] + 8LL));
  int64_t v25 = *v7;
  *int64_t v25 = sub_1000E6818(a1[7]);
  return a1;
}

void sub_1000F829C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1000F82F4(uint64_t a1, int a2)
{
  uint64_t v4 = *(std::mutex **)(a1 + 72);
  std::mutex::lock(v4);
  lseek(a2, 0LL, 0);
  AAByteStream v18 = AAFileStreamOpenWithFD(a2, 0);
  sub_1000E6458(&v21, &v18);
  sub_1000E652C(&v20, &v21);
  uint64_t v5 = *(void *)(a1 + 40);
  unint64_t v6 = *(uint8_t **)(v5 + 16);
  unint64_t v7 = *(std::__shared_weak_count **)(v5 + 24);
  AAByteStream v18 = (AAByteStream)v6;
  CFDataRef v19 = v7;
  if (v7)
  {
    uint64_t p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }

  sub_1000E655C(&v20, v6, 0x20uLL);
  sub_1000E6490(&v21, &v20, 0xFFFFFFFFFFFFFFFFLL, 0x4000000000000000uLL, 1, (uint64_t *)&v17);
  sub_1000F8800(&v21, (uint64_t *)&v20, &v17, &v16);
  sub_100014DF0(a1 + 56, &v16);
  uint64_t v10 = (std::__shared_weak_count *)*((void *)&v16 + 1);
  if (*((void *)&v16 + 1))
  {
    unint64_t v11 = (unint64_t *)(*((void *)&v16 + 1) + 8LL);
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  sub_1000E645C(&v17);
  uint64_t v13 = v19;
  if (v19)
  {
    uint64_t v14 = (unint64_t *)&v19->__shared_owners_;
    do
      unint64_t v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }

  sub_1000E6530(&v20);
  sub_1000E645C(&v21);
  std::mutex::unlock(v4);
}

void sub_1000F8468(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  AAByteStream v5 = va_arg(va1, AAByteStream);
  va_copy(va2, va1);
  uint64_t v7 = va_arg(va2, void);
  uint64_t v9 = va_arg(va2, void);
  va_copy(va3, va2);
  AEAContext v10 = va_arg(va3, AEAContext);
  sub_1000E645C((AAByteStream *)va);
  sub_1000114F0((uint64_t)va1);
  sub_1000E6530((AEAContext *)va2);
  sub_1000E645C((AAByteStream *)va3);
  std::mutex::unlock(v3);
  _Unwind_Resume(a1);
}

void *sub_1000F84C0(void *a1, void *a2, void *a3)
{
  AAByteStream v5 = sub_1000376FC(a1, a3);
  *AAByteStream v5 = off_100184BA0;
  uint64_t v6 = a2[6];
  v5[5] = a2[5];
  v5[6] = v6;
  if (v6)
  {
    uint64_t v7 = (unint64_t *)(v6 + 8);
    do
      unint64_t v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }

  a1[7] = 0LL;
  a1[8] = 0LL;
  uint64_t v9 = a2[10];
  a1[9] = a2[9];
  a1[10] = v9;
  if (v9)
  {
    AEAContext v10 = (unint64_t *)(v9 + 8);
    do
      unint64_t v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }

  sub_1000F82F4((uint64_t)a1, *(_DWORD *)(a1[5] + 8LL));
  return a1;
}

void sub_1000F8570(_Unwind_Exception *a1)
{
}

double sub_1000F859C@<D0>(void *a1@<X0>, void *a2@<X1>, _OWORD *a3@<X8>)
{
  double result = v5[0];
  *a3 = *(_OWORD *)v5;
  return result;
}

ssize_t sub_1000F85DC(uint64_t a1, uint64_t a2)
{
  return sub_1000E6824(*(void *)(a1 + 56), *(void **)a2, *(void *)(a2 + 16), *(void *)(a2 + 24));
}

uint64_t sub_1000F8600(uint64_t a1)
{
  return **(void **)(a1 + 40);
}

uint64_t sub_1000F860C(uint64_t a1)
{
  return sub_1000E680C(*(void *)(a1 + 56));
}

void *sub_1000F8614(void *a1)
{
  *a1 = off_100184BA0;
  sub_1000114F0((uint64_t)(a1 + 9));
  sub_1000114F0((uint64_t)(a1 + 7));
  sub_1000114F0((uint64_t)(a1 + 5));
  *a1 = off_10016A598;
  sub_1000114F0((uint64_t)(a1 + 3));
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1000F8674(void *a1)
{
  *a1 = off_100184BA0;
  sub_1000114F0((uint64_t)(a1 + 9));
  sub_1000114F0((uint64_t)(a1 + 7));
  sub_1000114F0((uint64_t)(a1 + 5));
  *a1 = off_10016A598;
  sub_1000114F0((uint64_t)(a1 + 3));
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  operator delete(a1);
}

void *sub_1000F86D4(uint64_t a1, void *a2)
{
  return sub_100004E4C(a2, (uint64_t)"AEA", 3LL);
}

void sub_1000F86E8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_100184C80;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000F86F8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_100184C80;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_1000F8718(uint64_t a1)
{
  return sub_1000114F0(a1 + 40);
}

void *sub_1000F8724(void *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  void *v4 = &off_100184CD0;
  v4[1] = 0LL;
  _OWORD v4[2] = 0LL;
  _OWORD v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_1000F8768(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    std::mutex::~mutex(v1);
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_1000F8788(std::__shared_weak_count *a1)
{
}

void sub_1000F879C(uint64_t a1)
{
  uint64_t v1 = *(std::mutex **)(a1 + 24);
  if (v1)
  {
    std::mutex::~mutex(v1);
    operator delete(v2);
  }

uint64_t sub_1000F87C0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }

  else
  {
    return 0LL;
  }

void *sub_1000F8800@<X0>(void *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X3>, void *a4@<X8>)
{
  unint64_t v8 = operator new(0x30uLL);
  double result = sub_1000F8870(v8, a1, a2, a3);
  *a4 = v8 + 3;
  a4[1] = v8;
  return result;
}

void sub_1000F885C(_Unwind_Exception *a1)
{
}

void *sub_1000F8870(void *a1, void *a2, uint64_t *a3, void *a4)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_100184D48;
  sub_1000E67E4(a1 + 3, a2, a3, a4);
  return a1;
}

void sub_1000F88A4(_Unwind_Exception *a1)
{
}

void sub_1000F88B8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_100184D48;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000F88C8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_100184D48;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

AAByteStream *sub_1000F88E8(AAByteStream *a1)
{
  uint64_t v2 = a1 + 3;
  sub_1000E645C(a1 + 5);
  sub_1000E6530(a1 + 4);
  return sub_1000E645C(v2);
}

void sub_1000F8920(void *a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x70uLL);
  sub_1000F8988(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  sub_100018774((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_1000F8974(_Unwind_Exception *a1)
{
}

void *sub_1000F8988(void *a1, void *a2, void *a3)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10017C9C0;
  sub_1000F84C0(a1 + 3, a2, a3);
  return a1;
}

void sub_1000F89BC(_Unwind_Exception *a1)
{
}

dispatch_group_t *sub_1000F95C8(dispatch_group_t *a1)
{
  *a1 = dispatch_group_create();
  return a1;
}

dispatch_object_s **sub_1000F95F0(dispatch_object_s **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    dispatch_release(v2);
  }
  return a1;
}

uint64_t sub_1000F961C(dispatch_group_t *a1, dispatch_time_t a2)
{
  return dispatch_group_wait(*a1, a2);
}

dispatch_queue_t *sub_1000F9624(dispatch_queue_t *a1, char *label, int a3)
{
  switch(a3)
  {
    case 2:
      uint64_t v6 = &_dispatch_queue_attr_concurrent;
      AAByteStream v5 = label;
      goto LABEL_6;
    case 1:
      dispatch_queue_global_t global_queue = dispatch_get_global_queue(21LL, 0LL);
      dispatch_queue_t v7 = dispatch_queue_create_with_target_V2(label, 0LL, global_queue);
      goto LABEL_8;
    case 0:
      AAByteStream v5 = label;
      uint64_t v6 = 0LL;
LABEL_6:
      dispatch_queue_t v7 = dispatch_queue_create(v5, v6);
LABEL_8:
      *a1 = v7;
      break;
  }

  return a1;
}

void *sub_1000F96A0(void *result, void *a2)
{
  *double result = *a2;
  *a2 = 0LL;
  return result;
}

void sub_1000F96B0(dispatch_queue_t *a1, void *a2)
{
}

void sub_1000F96B8(dispatch_queue_t *a1, dispatch_group_t *a2, void *a3)
{
}

void sub_1000F96C8(dispatch_queue_t *a1, dispatch_block_t *a2, uint64_t a3)
{
  dispatch_block_t v4 = *a2;
  if (v4)
  {
    if (a3)
    {
      dispatch_time_t v6 = dispatch_time(0LL, 1000 * a3);
      dispatch_after(v6, *a1, *a2);
    }

    else
    {
      dispatch_async(*a1, v4);
    }
  }

void sub_1000F9728(dispatch_queue_t *a1, void *a2)
{
}

void sub_1000F9730(dispatch_queue_t *a1, void *a2)
{
}

void sub_1000F9738(dispatch_queue_t *a1, void *a2)
{
}

void sub_1000F9740(dispatch_object_t *a1)
{
}

void sub_1000F9748(dispatch_object_t *a1)
{
}

uint64_t sub_1000F9750(dispatch_object_t *a1, int a2)
{
  else {
    uint64_t v3 = *(void *)&asc_1001415F0[8 * a2 - 8];
  }
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(v3, 0LL);
  if (!global_queue) {
    return 22LL;
  }
  dispatch_set_target_queue(*a1, global_queue);
  return 0LL;
}

void sub_1000F97B0(uint64_t a1)
{
  uint64_t v2 = *(dispatch_object_s **)(a1 + 8);
  if (v2)
  {
    dispatch_release(v2);
    *(void *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
  }

  uint64_t v5 = *(void *)(a1 + 40);
  dispatch_block_t v4 = (void *)(a1 + 40);
  uint64_t v3 = v5;
  if (v5)
  {
    sub_1000F97F8(v3);
    sub_100051780(v4);
  }

void sub_1000F97F8(uint64_t a1)
{
  uint64_t v2 = (unint64_t *)(a1 + 128);
  do
  {
    unint64_t v3 = __ldaxr(v2);
    unint64_t v4 = v3 - 1;
  }

  while (__stlxr(v4, v2));
  if (!v4)
  {
    std::mutex::lock((std::mutex *)(a1 + 64));
    std::condition_variable::notify_all((std::condition_variable *)(a1 + 16));
    std::mutex::unlock((std::mutex *)(a1 + 64));
  }

uint64_t sub_1000F9850(uint64_t a1, __int128 *a2, uint64_t *a3, void *a4, uint64_t a5, uint64_t a6)
{
  AEAContext v10 = (uint64_t **)a2;
  *(void *)a1 = off_100184D98;
  if (*((char *)a2 + 23) < 0)
  {
    sub_100040504((_BYTE *)(a1 + 16), *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v12 = *a2;
    *(void *)(a1 + sub_1000114F0(v6 - 32) = *((void *)a2 + 2);
    *(_OWORD *)(a1 + 16) = v12;
  }

  uint64_t v13 = a4[1];
  *(void *)(a1 + 4sub_1000F1278((int *)&v3, 0) = *a4;
  *(void *)(a1 + 4std::iostream::~basic_iostream(v2, v3 + 8) = v13;
  if (v13)
  {
    uint64_t v14 = (unint64_t *)(v13 + 8);
    do
      unint64_t v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
  }

  uint64_t v16 = *a3;
  v26[0] = _NSConcreteStackBlock;
  v26[1] = 1174405120LL;
  v26[2] = sub_1000F9A68;
  void v26[3] = &unk_100184DA8;
  v26[4] = a1;
  AAByteStream v17 = v27;
  sub_1000118C0((uint64_t)v27, a5);
  sub_1000118C0((uint64_t)v29, a6);
  *(void *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = dispatch_mach_create(v10, v16, v26);
  __int128 v22 = v30;
  if (v30 == v29)
  {
    uint64_t v23 = 4LL;
    __int128 v22 = v29;
  }

  else
  {
    if (!v30) {
      goto LABEL_14;
    }
    uint64_t v23 = 5LL;
  }

  (*(void (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))(*v22 + 8 * v23))(v22, v18, v19, v20, v21);
LABEL_14:
  if (v28 == v27)
  {
    uint64_t v24 = 4LL;
    goto LABEL_18;
  }

  if (v28)
  {
    uint64_t v24 = 5LL;
    AAByteStream v17 = v28;
LABEL_18:
    (*(void (**)(void *))(*v17 + 8 * v24))(v17);
  }

  return a1;
}

void sub_1000F9A0C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  if (a17 == v19)
  {
    uint64_t v22 = 4LL;
  }

  else
  {
    if (!a17) {
      goto LABEL_6;
    }
    uint64_t v22 = 5LL;
    uint64_t v19 = a17;
  }

  (*(void (**)(void *))(*v19 + 8 * v22))(v19);
LABEL_6:
  sub_1000114F0(v20);
  _Unwind_Resume(a1);
}

void sub_1000F9A68(uint64_t a1, uint64_t a2, uint64_t a3)
{
  switch(a2)
  {
    case 8LL:
      uint64_t v5 = *(void *)(a1 + 96);
      if (v5) {
        (*(void (**)(uint64_t))(*(void *)v5 + 48LL))(v5);
      }
      break;
    case 7LL:
      sub_1000F97B0(*(void *)(a1 + 32));
      break;
    case 2LL:
      uint64_t v6 = 0LL;
      uint64_t msg = dispatch_mach_msg_get_msg(a3, &v6);
      sub_1000F9AFC(a1 + 40, msg, v6);
      break;
  }

uint64_t sub_1000F9AFC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a3;
  uint64_t v6 = a2;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    sub_100016D94();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)v3 + 48LL))(v3, &v6, &v5);
}

uint64_t sub_1000F9B38(uint64_t a1, uint64_t a2)
{
  return sub_1000118C0(a1 + 72, a2 + 72);
}

void sub_1000F9B7C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = v2;
  uint64_t v5 = *(void **)(v3 + 64);
  if (v5 == v1)
  {
    uint64_t v6 = 4LL;
  }

  else
  {
    if (!v5) {
      goto LABEL_6;
    }
    uint64_t v6 = 5LL;
    uint64_t v1 = v5;
  }

  (*(void (**)(void *))(*v1 + 8 * v6))(v1);
LABEL_6:
  _Unwind_Resume(exception_object);
}

void *sub_1000F9BBC(void *a1)
{
  uint64_t v2 = a1 + 5;
  uint64_t v3 = a1 + 9;
  unint64_t v4 = (void *)a1[12];
  if (v4 == v3)
  {
    uint64_t v5 = 4LL;
    unint64_t v4 = v3;
  }

  else
  {
    if (!v4) {
      goto LABEL_6;
    }
    uint64_t v5 = 5LL;
  }

  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_6:
  double result = (void *)a1[8];
  if (result == v2)
  {
    uint64_t v7 = 4LL;
    double result = v2;
  }

  else
  {
    if (!result) {
      return result;
    }
    uint64_t v7 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v7))();
}

uint64_t sub_1000F9C44(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (a2) {
    a2 = *(unsigned int *)(a2 + 8);
  }
  if (a3) {
    a3 = *(unsigned int *)(a3 + 8);
  }
  return dispatch_mach_connect(v3, a2, a3, 0LL);
}

uint64_t sub_1000F9C60(uint64_t a1)
{
  return dispatch_mach_cancel(*(void *)(a1 + 8));
}

uint64_t sub_1000F9C68(uint64_t a1)
{
  *(void *)a1 = off_100184D98;
  uint64_t v2 = *(dispatch_object_s **)(a1 + 8);
  if (v2)
  {
    dispatch_release(v2);
    *(void *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
  }

  sub_1000114F0(a1 + 40);
  return a1;
}

void sub_1000F9CC0(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000F9C68(a1);
  operator delete(v1);
}

dispatch_semaphore_t *sub_1000F9CD4(dispatch_semaphore_t *a1, uint64_t value)
{
  *a1 = dispatch_semaphore_create(value);
  return a1;
}

uint64_t sub_1000F9D00(dispatch_semaphore_t *a1, dispatch_time_t a2)
{
  return dispatch_semaphore_wait(*a1, a2);
}

uint64_t sub_1000F9D08(dispatch_semaphore_t *a1)
{
  return dispatch_semaphore_signal(*a1);
}

dispatch_block_t *sub_1000F9D10(dispatch_block_t *a1, void *a2)
{
  *a1 = dispatch_block_create((dispatch_block_flags_t)0LL, a2);
  return a1;
}

void sub_1000F9D3C(void **a1)
{
  uint64_t v1 = *a1;
  if (v1) {
    dispatch_block_cancel(v1);
  }
}

const void **sub_1000F9D4C(const void **a1)
{
  uint64_t v2 = (void *)*a1;
  if (v2)
  {
    dispatch_block_cancel(v2);
    if (*a1) {
      _Block_release(*a1);
    }
  }

  return a1;
}

uint64_t sub_1000F9D8C@<X0>(int a1@<W0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, void *a5@<X8>)
{
  AEAContext v10 = sub_100004E4C(&v42, (uint64_t)"Couldn't open ", 14LL);
  int v11 = *(char *)(a2 + 23);
  if (v11 >= 0) {
    uint64_t v12 = a2;
  }
  else {
    uint64_t v12 = *(void *)a2;
  }
  if (v11 >= 0) {
    uint64_t v13 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v13 = *(void *)(a2 + 8);
  }
  uint64_t v14 = sub_100004E4C(v10, v12, v13);
  unint64_t v15 = sub_100004E4C(v14, (uint64_t)"' with flags ", 13LL);
  uint64_t v16 = *v15;
  *(_DWORD *)((char *)v15 + *(void *)(*v15 - 24) + std::iostream::~basic_iostream(v2, v3 + 8) = *(_DWORD *)((_BYTE *)v15 + *(void *)(*v15 - 24) + 8) & 0xFFFFFFB5 | 8;
  *(_DWORD *)((char *)v15 + *(void *)(v16 - 24) + 8) |= 0x200u;
  uint64_t v17 = (void *)std::ostream::operator<<(v15, a3);
  *(_DWORD *)((char *)v17 + *(void *)(*v17 - 24LL) + std::iostream::~basic_iostream(v2, v3 + 8) = *(_DWORD *)((_BYTE *)v17 + *(void *)(*v17 - 24LL) + 8) & 0xFFFFFFB5 | 2;
  if (a4 == 13)
  {
    else {
      uint64_t v18 = *(const char **)a2;
    }
    if (fstatat(a1, v18, &v40, 0))
    {
      v39.__r_.__value_.__r.__words[0] = (std::string::size_type)"std::string FileDescriptorWrapper::handle_open_from_error_message(int, const std::string &, int, int)";
      v39.__r_.__value_.__l.__size_ = 65LL;
      LODWORD(v39.__r_.__value_.__r.__words[2]) = 16;
      sub_1000FA178(&v36, (__int128 *)&v39);
      sub_100004E4C(&v37, (uint64_t)"fstatfs failed with err code", 28LL);
      uint64_t v19 = __error();
      std::ostream::operator<<(&v37, *v19);
      sub_100004E4C(&v37, (uint64_t)" trying to check permission after EACCES", 40LL);
      std::ostream::~ostream(&v37, off_1001851F8);
      sub_1000FE6A0((uint64_t)&v36);
      std::ios::~ios(&v38);
    }

    else
    {
      std::to_string(&v36, v40.st_gid);
      uint64_t v20 = getgrgid(v40.st_gid);
      if (v20) {
        sub_10003F294(&v36, v20->gr_name);
      }
      uint64_t v21 = sub_100004E4C(&v42, (uint64_t)", UID:GID(Name)=", 16LL);
      std::to_string(&v39, v40.st_uid);
      if ((v39.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v22 = &v39;
      }
      else {
        uint64_t v22 = (std::string *)v39.__r_.__value_.__r.__words[0];
      }
      if ((v39.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t size = v39.__r_.__value_.__s.__size_;
      }
      else {
        uint64_t size = v39.__r_.__value_.__l.__size_;
      }
      uint64_t v24 = sub_100004E4C(v21, (uint64_t)v22, size);
      int64_t v25 = sub_100004E4C(v24, (uint64_t)":", 1LL);
      if ((v36.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        char v26 = &v36;
      }
      else {
        char v26 = (std::string *)v36.__r_.__value_.__r.__words[0];
      }
      if ((v36.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v27 = v36.__r_.__value_.__s.__size_;
      }
      else {
        uint64_t v27 = v36.__r_.__value_.__l.__size_;
      }
      sub_100004E4C(v25, (uint64_t)v26, v27);
      uint64_t v28 = sub_100004E4C(&v42, (uint64_t)" mode=", 6LL);
      uint64_t v29 = *v28;
      *(_DWORD *)((char *)v28 + *(void *)(*v28 - 24) + std::iostream::~basic_iostream(v2, v3 + 8) = *(_DWORD *)((_BYTE *)v28 + *(void *)(*v28 - 24) + 8) & 0xFFFFFFB5 | 8;
      *(_DWORD *)((char *)v28 + *(void *)(v29 - 24) + 8) |= 0x200u;
      uint64_t v30 = (void *)std::ostream::operator<<(v28, v40.st_mode);
      *(_DWORD *)((char *)v30 + *(void *)(*v30 - 24LL) + std::iostream::~basic_iostream(v2, v3 + 8) = *(_DWORD *)((_BYTE *)v30 + *(void *)(*v30 - 24LL) + 8) & 0xFFFFFFB5 | 2;
      int v31 = sub_100004E4C(v30, (uint64_t)" (our euid is ", 14LL);
      uint64_t v32 = geteuid();
      __int128 v33 = (void *)std::ostream::operator<<(v31, v32);
      sub_100004E4C(v33, (uint64_t)")", 1LL);
    }
  }

  sub_1000049D8((uint64_t)v43, a5);
  *(void *)((char *)v41
  uint64_t v42 = v34;
  if (v44 < 0) {
    operator delete((void *)v43[8]);
  }
  std::streambuf::~streambuf(v43);
  return std::ios::~ios(&v45);
}

void sub_1000FA114( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_1000F04A0((uint64_t)&STACK[0x2B8]);
  _Unwind_Resume(a1);
}

void *sub_1000FA178(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_100104E5C((uint64_t)a1, a2);
  *a1 = off_100185130;
  a1[45] = &off_100185230;
  a1[46] = &off_100185258;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12std::iostream::~basic_iostream(v2, v3 + 8) = -1;
  *a1 = off_100185130;
  a1[45] = off_1001851B8;
  a1[46] = off_1001851E0;
  return a1;
}

void sub_1000FA1FC(_Unwind_Exception *a1)
{
}

uint64_t sub_1000FA220(uint64_t a1)
{
  return a1;
}

uint64_t sub_1000FA260(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1;
  uint64_t v4 = open((const char *)a1, a2, 438LL);
  if ((_DWORD)v4 == -1)
  {
    int v12 = *__error();
    if (sub_1000B8654())
    {
      *(void *)&__int128 v24 = 0LL;
      uint64_t v13 = (os_log_s *)sub_1000B85DC();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        uint64_t v14 = 3LL;
      }
      else {
        uint64_t v14 = 2LL;
      }
      int v15 = *__error();
      *(_DWORD *)buf = 68158467;
      *(_DWORD *)&uint8_t buf[4] = 69;
      __int16 v27 = 2080;
      uint64_t v28 = "static int FileDescriptorWrapper::open_file(const std::string &, int)";
      __int16 v29 = 2081;
      uint64_t v30 = v3;
      __int16 v31 = 1024;
      int v32 = v15;
      int v23 = 34;
      uint64_t v16 = (const char *)_os_log_send_and_compose_impl( v14,  &v24,  0LL,  0LL,  &_mh_execute_header,  v13,  16LL,  "%.*s: Failed opening %{private}s, errno %d",  buf,  v23);
      if (v16)
      {
        uint64_t v17 = (char *)v16;
        fprintf(__stderrp, "%s\n", v16);
        free(v17);
      }
    }

    else
    {
      uint64_t v18 = (os_log_s *)sub_1000B85DC();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        int v19 = *__error();
        *(_DWORD *)buf = 68158467;
        *(_DWORD *)&uint8_t buf[4] = 69;
        __int16 v27 = 2080;
        uint64_t v28 = "static int FileDescriptorWrapper::open_file(const std::string &, int)";
        __int16 v29 = 2081;
        uint64_t v30 = v3;
        __int16 v31 = 1024;
        int v32 = v19;
        _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_ERROR,  "%.*s: Failed opening %{private}s, errno %d",  buf,  0x22u);
      }
    }

    *__error() = v12;
    exception = __cxa_allocate_exception(0x40uLL);
    sub_100004D60((uint64_t)buf);
    sub_100004E4C(buf, (uint64_t)"Couldn't open file with flags ", 30LL);
    uint64_t v21 = *(void *)buf;
    *(_DWORD *)&buf[*(void *)(*(void *)buf - 24LL) + 8] = *(_DWORD *)&buf[*(void *)(*(void *)buf - 24LL) + 8] & 0xFFFFFFB5 | 8;
    *(_DWORD *)&buf[*(void *)(v21 - 24) + 8] |= 0x200u;
    std::ostream::operator<<(buf, a2);
    uint64_t v22 = __error();
    sub_10001161C((uint64_t)exception, (uint64_t)buf, *v22);
  }

  uint64_t v5 = v4;
  if (sub_1000B866C())
  {
    *(void *)&__int128 v24 = "int FileDescriptorWrapper::open_file(const std::string &, int)";
    *((void *)&v24 + sub_1000F1940(&v11, 1) = 36LL;
    int v25 = 2;
    sub_1000FA694(buf, &v24);
    sub_100004E4C(&v33, (uint64_t)"'", 1LL);
    int v6 = *(char *)(v3 + 23);
    if (v6 >= 0) {
      uint64_t v7 = v3;
    }
    else {
      uint64_t v7 = *(void *)v3;
    }
    if (v6 >= 0) {
      uint64_t v8 = *(unsigned __int8 *)(v3 + 23);
    }
    else {
      uint64_t v8 = *(void *)(v3 + 8);
    }
    sub_100004E4C(&v33, v7, v8);
    sub_100004E4C(&v33, (uint64_t)"' opened successfully with flags ", 33LL);
    uint64_t v9 = v33;
    *(_DWORD *)((char *)&v33 + *(void *)(v33 - 24) + std::iostream::~basic_iostream(v2, v3 + 8) = *(_DWORD *)((_BYTE *)&v33 + *(void *)(v33 - 24) + 8) & 0xFFFFFFB5 | 8;
    *(_DWORD *)((char *)&v33 + *(void *)(v9 - 24) + 8) |= 0x200u;
    std::ostream::operator<<(&v33, a2);
    uint64_t v10 = v33;
    *(_DWORD *)((char *)&v33 + *(void *)(v33 - 24) + 8) &= ~0x200u;
    *(_DWORD *)((char *)&v33 + *(void *)(v10 - 24) + std::iostream::~basic_iostream(v2, v3 + 8) = *(_DWORD *)((_BYTE *)&v33 + *(void *)(v10 - 24) + 8) & 0xFFFFFFB5 | 2;
    sub_100004E4C(&v33, (uint64_t)", fd=", 5LL);
    std::ostream::operator<<(&v33, v5);
    std::ostream::~ostream(&v33, off_100185418);
    sub_1000FEC4C((uint64_t)buf);
    std::ios::~ios(&v34);
  }

  return v5;
}

void sub_1000FA648( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void *sub_1000FA694(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_100104ED8((uint64_t)a1, a2);
  *a1 = off_100185350;
  a1[45] = &off_100185450;
  a1[46] = &off_100185478;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12std::iostream::~basic_iostream(v2, v3 + 8) = -1;
  *a1 = off_100185350;
  a1[45] = off_1001853D8;
  a1[46] = off_100185400;
  return a1;
}

void sub_1000FA718(_Unwind_Exception *a1)
{
}

uint64_t sub_1000FA73C(uint64_t a1)
{
  return a1;
}

uint64_t sub_1000FA77C(int a1, uint64_t a2, int a3)
{
  uint64_t v5 = a3 | 0x100u;
  int v26 = a3 | 0x100;
  __int16 v27 = 438;
  else {
    uint64_t v6 = *(void *)a2;
  }
  uint64_t v28 = v6;
  uint64_t v7 = fcntl(a1, 56, &v26);
  if ((_DWORD)v7 == -1)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    sub_100004D60((uint64_t)v20);
    uint64_t v16 = __error();
    sub_1000F9D8C(a1, a2, v5, *v16, &v23);
    if ((v25 & 0x80u) == 0) {
      uint64_t v17 = &v23;
    }
    else {
      uint64_t v17 = (__int128 *)v23;
    }
    if ((v25 & 0x80u) == 0) {
      uint64_t v18 = v25;
    }
    else {
      uint64_t v18 = *((void *)&v23 + 1);
    }
    sub_100004E4C(v20, (uint64_t)v17, v18);
    int v19 = __error();
    sub_10001161C((uint64_t)exception, (uint64_t)v20, *v19);
  }

  uint64_t v8 = v7;
  if (sub_1000B866C())
  {
    *(void *)&__int128 v23 = "int FileDescriptorWrapper::open_from(int, const std::string &, int)";
    *((void *)&v23 + sub_1000F1940(&v11, 1) = 36LL;
    int v24 = 2;
    sub_1000FAA1C(v20, &v23);
    sub_100004E4C(&v21, (uint64_t)"'", 1LL);
    int v9 = *(char *)(a2 + 23);
    if (v9 >= 0) {
      uint64_t v10 = a2;
    }
    else {
      uint64_t v10 = *(void *)a2;
    }
    if (v9 >= 0) {
      uint64_t v11 = *(unsigned __int8 *)(a2 + 23);
    }
    else {
      uint64_t v11 = *(void *)(a2 + 8);
    }
    sub_100004E4C(&v21, v10, v11);
    sub_100004E4C(&v21, (uint64_t)"' opened successfully with flags ", 33LL);
    uint64_t v12 = v21;
    *(_DWORD *)((char *)&v21 + *(void *)(v21 - 24) + std::iostream::~basic_iostream(v2, v3 + 8) = *(_DWORD *)((_BYTE *)&v21 + *(void *)(v21 - 24) + 8) & 0xFFFFFFB5 | 8;
    *(_DWORD *)((char *)&v21 + *(void *)(v12 - 24) + 8) |= 0x200u;
    std::ostream::operator<<(&v21, v5);
    uint64_t v13 = v21;
    *(_DWORD *)((char *)&v21 + *(void *)(v21 - 24) + 8) &= ~0x200u;
    *(_DWORD *)((char *)&v21 + *(void *)(v13 - 24) + std::iostream::~basic_iostream(v2, v3 + 8) = *(_DWORD *)((_BYTE *)&v21 + *(void *)(v13 - 24) + 8) & 0xFFFFFFB5 | 2;
    sub_100004E4C(&v21, (uint64_t)", fd=", 5LL);
    std::ostream::operator<<(&v21, v8);
    std::ostream::~ostream(&v21, off_100185638);
    sub_1000FF1F8((uint64_t)v20);
    std::ios::~ios(&v22);
  }

  return v8;
}

void sub_1000FA9B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  if (*(char *)(v5 - 65) < 0)
  {
    operator delete(*(void **)(v5 - 88));
    sub_10000F218((uint64_t)va);
    if ((v4 & 1) == 0) {
LABEL_6:
    }
      _Unwind_Resume(a1);
  }

  else
  {
    sub_10000F218((uint64_t)va);
    if (!v4) {
      goto LABEL_6;
    }
  }

  __cxa_free_exception(v3);
  goto LABEL_6;
}

void *sub_1000FAA1C(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_100104F54((uint64_t)a1, a2);
  *a1 = off_100185570;
  a1[45] = &off_100185670;
  a1[46] = &off_100185698;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12std::iostream::~basic_iostream(v2, v3 + 8) = -1;
  *a1 = off_100185570;
  a1[45] = off_1001855F8;
  a1[46] = off_100185620;
  return a1;
}

void sub_1000FAAA0(_Unwind_Exception *a1)
{
}

uint64_t sub_1000FAAC4(uint64_t a1)
{
  return a1;
}

uint64_t sub_1000FAB04(uint64_t a1)
{
  *(void *)a1 = off_100184DF8;
  int v2 = *(_DWORD *)(a1 + 8);
  if (v2 != -1)
  {
    close(v2);
    if (sub_1000B866C())
    {
      *(void *)&__int128 v4 = "FileDescriptorWrapper::~FileDescriptorWrapper()";
      *((void *)&v4 + sub_1000F1940(&v11, 1) = 45LL;
      int v5 = 2;
      sub_1000FABE0(v6, &v4);
      sub_100004E4C(&v7, (uint64_t)"File descriptor ", 16LL);
      std::ostream::operator<<(&v7, *(unsigned int *)(a1 + 8));
      sub_100004E4C(&v7, (uint64_t)" closed", 7LL);
      std::ostream::~ostream(&v7, off_100185858);
      sub_1000FF7A4((uint64_t)v6);
      std::ios::~ios(&v8);
    }
  }

  return a1;
}

void *sub_1000FABE0(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_100104FD0((uint64_t)a1, a2);
  *a1 = off_100185790;
  a1[45] = &off_100185890;
  a1[46] = &off_1001858B8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12std::iostream::~basic_iostream(v2, v3 + 8) = -1;
  *a1 = off_100185790;
  a1[45] = off_100185818;
  a1[46] = off_100185840;
  return a1;
}

void sub_1000FAC64(_Unwind_Exception *a1)
{
}

uint64_t sub_1000FAC88(uint64_t a1)
{
  return a1;
}

void sub_1000FACCC(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000FAB04(a1);
  operator delete(v1);
}

uint64_t sub_1000FACE0(uint64_t a1, int a2, char a3)
{
  *(_DWORD *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = a2;
  *(void *)a1 = off_10016C150;
  *(_BYTE *)(a1 + 1sub_1000F1278(&v6, 2) = a3;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + sub_1000114F0(v6 - 32) = 0u;
  sub_1000FAD34(a1);
  return a1;
}

void sub_1000FAD20(_Unwind_Exception *a1)
{
}

uint64_t sub_1000FAD34(uint64_t a1)
{
  uint64_t result = sub_1000FB12C(a1, &v35);
  if ((v35.st_mode & 0xB000) != 0x2000)
  {
    *(void *)(a1 + 16) = v35.st_size;
    goto LABEL_17;
  }

  bzero(v38, 0x400uLL);
  bzero(bsdName, 0x400uLL);
  if (fcntl(*(_DWORD *)(a1 + 8), 50, v38) < 0)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    uint64_t v20 = __error();
    uint64_t v21 = (void *)sub_100004870((uint64_t)exception, (uint64_t)"get path failed", *v20);
  }

  if (!basename_r(v38, bsdName))
  {
    uint64_t v22 = __cxa_allocate_exception(0x40uLL);
    __int128 v23 = __error();
    int v24 = (void *)sub_100004870((uint64_t)v22, (uint64_t)"basename_r failed", *v23);
  }

  uint64_t v3 = IOBSDNameMatching(kIOMainPortDefault, 0, bsdName);
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v3);
  io_registry_entry_t v5 = MatchingService;
  if (!MatchingService)
  {
    unsigned __int8 v25 = __cxa_allocate_exception(0x40uLL);
    int v26 = (void *)sub_100004870((uint64_t)v25, (uint64_t)"device not found in registry", 0x13u);
  }

  CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(MatchingService, @"Size", kCFAllocatorDefault, 0);
  CFTypeID TypeID = CFNumberGetTypeID();
  if (CFProperty)
  {
    uint64_t v8 = TypeID;
    if (CFGetTypeID(CFProperty) != TypeID)
    {
      __int16 v27 = __cxa_allocate_exception(0x40uLL);
      CFTypeID v28 = CFGetTypeID(CFProperty);
      __int16 v29 = sub_1000974F0(v27, v28, v8);
    }
  }

  CFTypeRef cf = CFProperty;
  CFTypeRef v9 = IORegistryEntryCreateCFProperty(v5, @"Preferred Block Size", kCFAllocatorDefault, 0);
  CFTypeID v10 = CFNumberGetTypeID();
  if (v9)
  {
    uint64_t v11 = v10;
    if (CFGetTypeID(v9) != v10)
    {
      uint64_t v30 = __cxa_allocate_exception(0x40uLL);
      CFTypeID v31 = CFGetTypeID(v9);
      int v32 = sub_100026B08(v30, v31, v11);
    }
  }

  CFTypeRef v33 = v9;
  IOObjectRelease(v5);
  if (!cf || (CFTypeID v12 = CFGetTypeID(cf), v12 != CFNumberGetTypeID()))
  {
    int v15 = "device size not found in registry";
LABEL_20:
    uint64_t v16 = 19LL;
    goto LABEL_22;
  }

  if (!CFNumberGetValue((CFNumberRef)cf, kCFNumberLongLongType, &valuePtr))
  {
LABEL_21:
    int v15 = "Failed converting CFNumber to longlong";
    uint64_t v16 = 22LL;
LABEL_22:
    uint64_t v17 = __cxa_allocate_exception(0x40uLL);
    *uint64_t v17 = &off_100189E78;
    uint64_t v18 = std::generic_category();
    v17[1] = v16;
    v17[2] = v18;
    *((_BYTE *)v17 + 24) = 0;
    *((_BYTE *)v17 + 4std::iostream::~basic_iostream(v2, v3 + 8) = 0;
    v17[7] = v15;
  }

  *(void *)(a1 + 16) = valuePtr;
  if (!v33 || (CFTypeID v13 = CFGetTypeID(v33), v13 != CFNumberGetTypeID()))
  {
    int v15 = "device block size not found in registry";
    goto LABEL_20;
  }

  if (!CFNumberGetValue((CFNumberRef)v33, kCFNumberLongLongType, &valuePtr)) {
    goto LABEL_21;
  }
  *(void *)(a1 + 24) = valuePtr;
  sub_1000B95A8(&v33);
  uint64_t result = (uint64_t)sub_1000B95A8(&cf);
LABEL_17:
  __darwin_ino64_t st_ino = v35.st_ino;
  *(void *)(a1 + sub_1000114F0(v6 - 32) = v35.st_dev;
  *(void *)(a1 + 4sub_1000F1278((int *)&v3, 0) = st_ino;
  return result;
}

void sub_1000FB0D4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, int a12, const void *a13)
{
}

uint64_t sub_1000FB12C@<X0>(uint64_t a1@<X0>, stat *a2@<X8>)
{
  uint64_t result = fstat(*(_DWORD *)(a1 + 8), a2);
  if ((_DWORD)result)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    __int128 v4 = __error();
    io_registry_entry_t v5 = (void *)sub_100004870((uint64_t)exception, (uint64_t)"fstat failed", *v4);
  }

  return result;
}

void sub_1000FB18C(_Unwind_Exception *a1)
{
}

uint64_t sub_1000FB1A0@<X0>(uint64_t a1@<X0>, statfs *a2@<X8>)
{
  uint64_t result = fstatfs(*(_DWORD *)(a1 + 8), a2);
  if ((result & 0x80000000) != 0)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    __int128 v4 = __error();
    io_registry_entry_t v5 = (void *)sub_100004870((uint64_t)exception, (uint64_t)"fstatfs failed", *v4);
  }

  return result;
}

void sub_1000FB200(_Unwind_Exception *a1)
{
}

BOOL sub_1000FB214(uint64_t a1)
{
  return (*(_WORD *)(a1 + 4) & 0xB000) == 0x2000;
}

BOOL sub_1000FB22C(uint64_t a1)
{
  return (v2.st_mode & 0xB000) == 0x2000;
}

uint64_t sub_1000FB260@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)&__int128 v7 = "FileDescriptor::get_mounted_on_fs() const";
  *((void *)&v7 + sub_1000F1940(&v11, 1) = 33LL;
  int v8 = 2;
  sub_1000151C8(&__src, &v7);
  sub_100004E4C(&__src.f_mntonname[272], (uint64_t)"File system is ", 15LL);
  int v3 = *(char *)(a2 + 23);
  if (v3 >= 0) {
    uint64_t v4 = a2;
  }
  else {
    uint64_t v4 = *(void *)a2;
  }
  if (v3 >= 0) {
    uint64_t v5 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v5 = *(void *)(a2 + 8);
  }
  sub_100004E4C(&__src.f_mntonname[272], v4, v5);
  std::ostream::~ostream(&__src.f_mntonname[272], off_100166130);
  sub_10001532C((uint64_t)&__src);
  return std::ios::~ios(&__src.f_mntonname[280]);
}

void sub_1000FB37C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
}

BOOL sub_1000FB3F8(uint64_t a1, uint64_t a2)
{
  int32_t v3 = v7.f_fsid.val[0];
  int32_t v4 = v7.f_fsid.val[1];
  sub_1000FB1A0(a2, &v7);
  return v3 == v7.f_fsid.val[0] && v4 == v7.f_fsid.val[1];
}

void sub_1000FB498(uint64_t a1)
{
  stat v2 = (unint64_t *)(a1 + 144);
  uint64_t v4 = a1;
  unint64_t v3 = atomic_load(v2);
  if (v3 != -1LL)
  {
    uint64_t v6 = &v4;
    uint64_t v5 = &v6;
    std::__call_once(v2, &v5, (void (__cdecl *)(void *))sub_10010504C);
  }

uint64_t sub_1000FB4E8(int a1, uint64_t *a2)
{
  else {
    stat v2 = (uint64_t *)*a2;
  }
  if (fcntl(a1, 57, v2) < 0) {
    return -*__error();
  }
  else {
    return 0LL;
  }
}

off_t sub_1000FB534(int a1, uint64_t a2)
{
  uint64_t v2 = a2;
  if (*__error() != 13 && *__error() != 1)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    sub_100004D60((uint64_t)v13);
    sub_100004E4C(v13, (uint64_t)"Cannot stat ", 12LL);
    int v9 = *(char *)(v2 + 23);
    if (v9 >= 0) {
      uint64_t v10 = v2;
    }
    else {
      uint64_t v10 = *(void *)v2;
    }
    if (v9 >= 0) {
      uint64_t v11 = *(unsigned __int8 *)(v2 + 23);
    }
    else {
      uint64_t v11 = *(void *)(v2 + 8);
    }
    sub_100004E4C(v13, v10, v11);
    uint64_t v12 = __error();
    sub_10001161C((uint64_t)exception, (uint64_t)v13, *v12);
  }

  uint64_t v4 = operator new(0x458uLL);
  uint64_t v5 = sub_1000FA77C(a1, v2, 0);
  sub_100045554((uint64_t)v4, v5, 0LL, 0);
  uint64_t v6 = (*(uint64_t (**)(void *))(*(void *)v4 + 40LL))(v4);
  (*(void (**)(void *))(*(void *)v4 + 8LL))(v4);
  return v6;
}

void sub_1000FB67C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_1000FB6D8(uint64_t a1, uint64_t a2)
{
  ssize_t v4 = pwrite(**(_DWORD **)(a1 + 56), *(const void **)a2, *(void *)(a2 + 16), *(void *)(a2 + 24));
  ssize_t v5 = v4;
  if (v4 < 0 || v4 != *(void *)(a2 + 16))
  {
    *(void *)&__int128 v12 = "int FileLocal::write(const sg_entry &)";
    *((void *)&v12 + sub_1000F1940(&v11, 1) = 20LL;
    int v13 = 16;
    sub_1000FB870(v14, &v12);
    sub_100004E4C(&v15, (uint64_t)"Error writing file @ ", 21LL);
    sub_100116CB8(&v15, (void *)a2);
    sub_100004E4C(&v15, (uint64_t)". returned ", 11LL);
    std::ostream::operator<<(&v15, v5);
    sub_100004E4C(&v15, (uint64_t)" with errno: ", 13LL);
    uint64_t v10 = __error();
    std::ostream::operator<<(&v15, *v10);
    std::ostream::~ostream(&v15, off_100185A78);
    sub_1000FFD50((uint64_t)v14);
    std::ios::~ios(&v16);
    if (v5 == -1) {
      return -*__error();
    }
    else {
      return 4294967291LL;
    }
  }

  else
  {
    unint64_t v6 = *(void *)(a2 + 24) + v4;
    statfs v7 = (unint64_t *)(*(void *)(a1 + 40) + 64LL);
    unint64_t v8 = atomic_load(v7);
    if (v8 < v6)
    {
      do
      {
        unint64_t v9 = __ldaxr(v7);
        if (v9 == v8)
        {
          if (!__stlxr(v6, v7)) {
            return v5;
          }
        }

        else
        {
          __clrex();
        }

        unint64_t v8 = v9;
      }

      while (v9 < v6);
    }
  }

  return v5;
}

void sub_1000FB85C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void *sub_1000FB870(void *a1, __int128 *a2)
{
  unint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_100105AD4((uint64_t)a1, a2);
  *a1 = off_1001859B0;
  a1[45] = &off_100185AB0;
  a1[46] = &off_100185AD8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12std::iostream::~basic_iostream(v2, v3 + 8) = -1;
  *a1 = off_1001859B0;
  a1[45] = off_100185A38;
  a1[46] = off_100185A60;
  return a1;
}

void sub_1000FB8F4(_Unwind_Exception *a1)
{
}

uint64_t sub_1000FB918(uint64_t a1)
{
  return a1;
}

uint64_t sub_1000FB958(uint64_t a1, uint64_t a2)
{
  ssize_t v3 = pread(**(_DWORD **)(a1 + 56), *(void **)a2, *(void *)(a2 + 16), *(void *)(a2 + 24));
  ssize_t v4 = v3;
  if (v3 < 0 || v3 != *(void *)(a2 + 16))
  {
    *(void *)&__int128 v7 = "int FileLocal::read(const sg_entry &)";
    *((void *)&v7 + sub_1000F1940(&v11, 1) = 19LL;
    int v8 = 16;
    sub_1000FBA94(v9, &v7);
    sub_100004E4C(&v10, (uint64_t)"Error reading file @ ", 21LL);
    sub_100116CB8(&v10, (void *)a2);
    sub_100004E4C(&v10, (uint64_t)". returned ", 11LL);
    std::ostream::operator<<(&v10, v4);
    sub_100004E4C(&v10, (uint64_t)" with errno: ", 13LL);
    ssize_t v5 = __error();
    std::ostream::operator<<(&v10, *v5);
    std::ostream::~ostream(&v10, off_100185C98);
    sub_1001002FC((uint64_t)v9);
    std::ios::~ios(&v11);
    if (v4 == -1) {
      return -*__error();
    }
    else {
      return 4294967291LL;
    }
  }

  return v4;
}

void sub_1000FBA80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void *sub_1000FBA94(void *a1, __int128 *a2)
{
  ssize_t v3 = (std::ios_base *)(a1 + 46);
  sub_100105B50((uint64_t)a1, a2);
  *a1 = off_100185BD0;
  a1[45] = &off_100185CD0;
  a1[46] = &off_100185CF8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12std::iostream::~basic_iostream(v2, v3 + 8) = -1;
  *a1 = off_100185BD0;
  a1[45] = off_100185C58;
  a1[46] = off_100185C80;
  return a1;
}

void sub_1000FBB18(_Unwind_Exception *a1)
{
}

uint64_t sub_1000FBB3C(uint64_t a1)
{
  return a1;
}

uint64_t sub_1000FBB7C(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40LL))(a1);
  if (v4 < a2)
  {
    char __buf = 0;
    ssize_t v5 = pwrite(**(_DWORD **)(a1 + 56), &__buf, 1uLL, a2 - 1);
    if (v5 != 1)
    {
      ssize_t v6 = v5;
      *(void *)&__int128 v10 = "int FileLocal::truncate(uint64_t)";
      *((void *)&v10 + sub_1000F1940(&v11, 1) = 23LL;
      int v11 = 16;
      sub_100074DCC(v12, &v10);
      sub_100004E4C(&v13, (uint64_t)"Failed to increase file size, pwrite returned ", 46LL);
      std::ostream::operator<<(&v13, v6);
      sub_100004E4C(&v13, (uint64_t)" errno: ", 8LL);
      __int128 v7 = __error();
      std::ostream::operator<<(&v13, *v7);
      std::ostream::~ostream(&v13, off_100174E90);
      sub_100079998((uint64_t)v12);
      std::ios::~ios(v14);
      if (v6 != -1) {
        return 4294967291LL;
      }
      return -*__error();
    }

void sub_1000FBD3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

void *sub_1000FBD60(void *a1, __int128 *a2)
{
  ssize_t v3 = (std::ios_base *)(a1 + 46);
  sub_100105BCC((uint64_t)a1, a2);
  *a1 = off_100185DF0;
  a1[45] = &off_100185EF0;
  a1[46] = &off_100185F18;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12std::iostream::~basic_iostream(v2, v3 + 8) = -1;
  *a1 = off_100185DF0;
  a1[45] = off_100185E78;
  a1[46] = off_100185EA0;
  return a1;
}

void sub_1000FBDE4(_Unwind_Exception *a1)
{
}

uint64_t sub_1000FBE08(uint64_t a1)
{
  return a1;
}

uint64_t sub_1000FBE48(uint64_t a1, uint64_t a2)
{
  if (sub_1000B866C())
  {
    *(void *)&__int128 v17 = "int FileLocal::flush(di_flush_mode)";
    *((void *)&v17 + sub_1000F1940(&v11, 1) = 20LL;
    int v18 = 2;
    sub_10006B464(v19, &v17);
    sub_100004E4C(&v20, (uint64_t)"Calling ", 8LL);
    sub_100116C34(&v20, a2);
    sub_100004E4C(&v20, (uint64_t)" on ", 4LL);
    sub_100116E80((uint64_t)&v20, a1);
    std::ostream::~ostream(&v20, off_100172E50);
    sub_1000705DC((uint64_t)v19);
    std::ios::~ios(v21);
  }

  if ((_DWORD)a2 == 1)
  {
    if (fsync(**(_DWORD **)(a1 + 56)) == -1)
    {
      uint64_t v4 = -*__error();
      goto LABEL_6;
    }

    return 0LL;
  }

  if ((_DWORD)a2 == 2) {
    uint64_t v5 = 2LL;
  }
  else {
    uint64_t v5 = 1LL;
  }
  if ((*(void *)(*(void *)(a1 + 40) + 56LL) & v5) != 0)
  {
    if (sub_1000B866C())
    {
      *(void *)&__int128 v17 = "int FileLocal::flush(di_flush_mode)";
      *((void *)&v17 + sub_1000F1940(&v11, 1) = 20LL;
      int v18 = 2;
      sub_1000FC210(v19, &v17);
      sub_100116C34(&v20, a2);
      sub_100004E4C(&v20, (uint64_t)" is not supported", 17LL);
      std::ostream::~ostream(&v20, off_1001860D8);
      sub_100100E54((uint64_t)v19);
      std::ios::~ios(v21);
    }

    return (*(uint64_t (**)(uint64_t, BOOL))(*(void *)a1 + 16LL))(a1, (_DWORD)a2 != 2);
  }

  int v7 = **(_DWORD **)(a1 + 56);
  if ((_DWORD)a2 == 2) {
    int v8 = fcntl(v7, 51, 0LL);
  }
  else {
    int v8 = fcntl(v7, 85, 0LL);
  }
  if (v8 != -1) {
    return 0LL;
  }
  __int128 v10 = __error();
  uint64_t v4 = -*v10;
  unsigned int v11 = 45 - *v10;
  if (v11 <= 0x17 && ((1 << v11) & 0x900001) != 0)
  {
    __int128 v12 = (unint64_t *)(*(void *)(a1 + 40) + 56LL);
    do
      unint64_t v13 = __ldxr(v12);
    while (__stxr(v13 | v5, v12));
    *(void *)&__int128 v17 = "int FileLocal::flush(di_flush_mode)";
    *((void *)&v17 + sub_1000F1940(&v11, 1) = 20LL;
    int v18 = 0;
    sub_1000FC2F8(v19, &v17);
    sub_100116C34(&v20, a2);
    sub_100004E4C(&v20, (uint64_t)" is not supported (err code ", 28LL);
    stat v14 = __error();
    std::ostream::operator<<(&v20, *v14);
    sub_100004E4C(&v20, (uint64_t)")", 1LL);
    std::ostream::~ostream(&v20, off_1001862F8);
    sub_100101400((uint64_t)v19);
    std::ios::~ios(v21);
    if ((_DWORD)a2 == 2) {
      return (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 16LL))(a1, 0LL);
    }
    uint64_t v15 = (unint64_t *)(*(void *)(a1 + 40) + 56LL);
    do
      unint64_t v16 = __ldxr(v15);
    while (__stxr(v16 | 2, v15));
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 16LL))(a1, 1LL);
  }

void sub_1000FC1CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

void *sub_1000FC210(void *a1, __int128 *a2)
{
  ssize_t v3 = (std::ios_base *)(a1 + 46);
  sub_100105C48((uint64_t)a1, a2);
  *a1 = off_100186010;
  a1[45] = &off_100186110;
  a1[46] = &off_100186138;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12std::iostream::~basic_iostream(v2, v3 + 8) = -1;
  *a1 = off_100186010;
  a1[45] = off_100186098;
  a1[46] = off_1001860C0;
  return a1;
}

void sub_1000FC294(_Unwind_Exception *a1)
{
}

uint64_t sub_1000FC2B8(uint64_t a1)
{
  return a1;
}

void *sub_1000FC2F8(void *a1, __int128 *a2)
{
  ssize_t v3 = (std::ios_base *)(a1 + 46);
  sub_100105CC4((uint64_t)a1, a2);
  *a1 = off_100186230;
  a1[45] = &off_100186330;
  a1[46] = &off_100186358;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12std::iostream::~basic_iostream(v2, v3 + 8) = -1;
  *a1 = off_100186230;
  a1[45] = off_1001862B8;
  a1[46] = off_1001862E0;
  return a1;
}

void sub_1000FC37C(_Unwind_Exception *a1)
{
}

uint64_t sub_1000FC3A0(uint64_t a1)
{
  return a1;
}

void *sub_1000FC3E0(void *a1, __int128 *a2)
{
  ssize_t v3 = (std::ios_base *)(a1 + 46);
  sub_100105D40((uint64_t)a1, a2);
  *a1 = off_100186450;
  a1[45] = &off_100186550;
  a1[46] = &off_100186578;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12std::iostream::~basic_iostream(v2, v3 + 8) = -1;
  *a1 = off_100186450;
  a1[45] = off_1001864D8;
  a1[46] = off_100186500;
  return a1;
}

void sub_1000FC464(_Unwind_Exception *a1)
{
}

uint64_t sub_1000FC488(uint64_t a1)
{
  return a1;
}

uint64_t sub_1000FC4C8(uint64_t a1, unint64_t a2, size_t a3)
{
  uint64_t v6 = *(void *)(a1 + 40);
  sub_1000FB498(v6);
  size_t v7 = *(void *)(v6 + 72);
  int v8 = *(unsigned __int8 *)(v6 + 88);
  uint64_t v9 = *(void *)(a1 + 40);
  sub_1000FB498(v9);
  if (!*(_BYTE *)(v9 + 136) || !v8)
  {
    *(void *)&__int128 v40 = "int FileLocal::unmap_range(uint64_t, uint64_t)";
    *((void *)&v40 + sub_1000F1940(&v11, 1) = 26LL;
    LODWORD(vmemset(v5, 0, 41) = 0;
    sub_1000FC9E8(&v42, &v40);
    sub_100004E4C(&v48, (uint64_t)"fd block size retrieval failed (err code ", 41LL);
    std::ostream::operator<<(&v48, v7);
    sub_100004E4C(&v48, (uint64_t)")", 1LL);
    std::ostream::~ostream(&v48, off_100186738);
    sub_100101F58((uint64_t)&v42);
    goto LABEL_14;
  }

  __int128 v10 = *(void **)(v9 + 96);
  unint64_t v11 = (a2 + v7 - 1) / v7 * v7;
  unint64_t v12 = a3 + a2;
  if (a2 <= v11 && v11 < v12)
  {
    unint64_t v14 = a2 - v11 + a3;
    size_t v15 = v14 / v7 * v7;
    unint64_t v16 = v14 == v14 % v7 ? 0LL : (a2 + v7 - 1) / v7 * v7;
    if (v14 != v14 % v7)
    {
      *(void *)&__int128 v40 = 0LL;
      *((void *)&v40 + sub_1000F1940(&v11, 1) = v16;
      size_t v41 = v14 / v7 * v7;
      size_t v20 = fcntl(**(_DWORD **)(a1 + 56), 99, &v40);
      if (!(_DWORD)v20)
      {
        unint64_t v22 = v16 - a2;
        if (v16 != a2)
        {
          __int128 v23 = (std::__shared_weak_count *)*((void *)sub_100118DDC() + 1);
          uint64_t v42 = v10;
          uint64_t v43 = v23;
          if (v23)
          {
            uint64_t p_shared_owners = (unint64_t *)&v23->__shared_owners_;
            do
              unint64_t v25 = __ldxr(p_shared_owners);
            while (__stxr(v25 + 1, p_shared_owners));
          }

          unint64_t v44 = v16 - a2;
          unint64_t v45 = a2;
          unint64_t v46 = v16 - a2;
          char v47 = 0;
          size_t v7 = (*(uint64_t (**)(uint64_t, void **))(*(void *)a1 + 80LL))(a1, &v42);
          int v26 = v43;
          if (v43)
          {
            __int16 v27 = (unint64_t *)&v43->__shared_owners_;
            do
              unint64_t v28 = __ldaxr(v27);
            while (__stlxr(v28 - 1, v27));
            if (!v28)
            {
              ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
              std::__shared_weak_count::__release_weak(v26);
            }
          }

          if ((v7 & 0x80000000) != 0)
          {
            *(void *)&__int128 v38 = "int FileLocal::unmap_range(uint64_t, uint64_t)";
            *((void *)&v38 + sub_1000F1940(&v11, 1) = 26LL;
            int v39 = 16;
            sub_1000FCBB8(&v42, &v38);
            sub_100004E4C(&v48, (uint64_t)"Write zeros to unmap unaligned start region failed (err code", 60LL);
            uint64_t v37 = __error();
            std::ostream::operator<<(&v48, *v37);
            sub_100004E4C(&v48, (uint64_t)")", 1LL);
            sub_1000FCC60((uint64_t)&v42);
            return v7;
          }
        }

        if (v15 + v16 < v12)
        {
          size_t v29 = a3 - (v22 + v15);
          uint64_t v30 = (std::__shared_weak_count *)*((void *)sub_100118DDC() + 1);
          uint64_t v42 = v10;
          uint64_t v43 = v30;
          if (v30)
          {
            CFTypeID v31 = (unint64_t *)&v30->__shared_owners_;
            do
              unint64_t v32 = __ldxr(v31);
            while (__stxr(v32 + 1, v31));
          }

          unint64_t v44 = v29;
          unint64_t v45 = v15 + v16;
          unint64_t v46 = v29;
          char v47 = 0;
          size_t v7 = (*(uint64_t (**)(uint64_t, void **))(*(void *)a1 + 80LL))(a1, &v42);
          CFTypeRef v33 = v43;
          if (v43)
          {
            uint64_t v34 = (unint64_t *)&v43->__shared_owners_;
            do
              unint64_t v35 = __ldaxr(v34);
            while (__stlxr(v35 - 1, v34));
            if (!v35)
            {
              ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
              std::__shared_weak_count::__release_weak(v33);
            }
          }

          if ((v7 & 0x80000000) != 0)
          {
            *(void *)&__int128 v38 = "int FileLocal::unmap_range(uint64_t, uint64_t)";
            *((void *)&v38 + sub_1000F1940(&v11, 1) = 26LL;
            int v39 = 16;
            sub_1000FCCA0(&v42, &v38);
            sub_100004E4C(&v48, (uint64_t)"Write zeros to unmap unaligned end region failed (err code", 58LL);
            std::string v36 = __error();
            std::ostream::operator<<(&v48, *v36);
            sub_100004E4C(&v48, (uint64_t)")", 1LL);
            sub_1000FCD48((uint64_t)&v42);
            return v7;
          }
        }

        return 0LL;
      }

      size_t v7 = v20;
      *(void *)&__int128 v38 = "int FileLocal::unmap_range(uint64_t, uint64_t)";
      *((void *)&v38 + sub_1000F1940(&v11, 1) = 26LL;
      int v39 = 0;
      sub_1000FCAD0(&v42, &v38);
      sub_100004E4C(&v48, (uint64_t)"Punch hole is not supported (err code ", 38LL);
      uint64_t v21 = __error();
      std::ostream::operator<<(&v48, *v21);
      sub_100004E4C(&v48, (uint64_t)")", 1LL);
      std::ostream::~ostream(&v48, off_100186958);
      sub_100102504((uint64_t)&v42);
LABEL_14:
      std::ios::~ios(v49);
      return v7;
    }
  }

  ssize_t v17 = sub_1000FCD88(a1, a2, a3, v7, v10);
  if (v17 == a3) {
    return 0LL;
  }
  size_t v7 = v17;
  *(void *)&__int128 v40 = "int FileLocal::unmap_range(uint64_t, uint64_t)";
  *((void *)&v40 + sub_1000F1940(&v11, 1) = 26LL;
  LODWORD(vmemset(v5, 0, 41) = 16;
  sub_1000FCF40(&v42, &v40);
  sub_100004E4C(&v48, (uint64_t)"Write zeros to unmap region failed (err code", 44LL);
  int v19 = __error();
  std::ostream::operator<<(&v48, *v19);
  sub_100004E4C(&v48, (uint64_t)")", 1LL);
  std::ostream::~ostream(&v48, off_100186FB8);
  sub_100103608((uint64_t)&v42);
  std::ios::~ios(v49);
  if ((v7 & 0x8000000000000000LL) == 0LL) {
    return 4294967291LL;
  }
  else {
    return v7;
  }
}

void sub_1000FC97C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

void *sub_1000FC9E8(void *a1, __int128 *a2)
{
  ssize_t v3 = (std::ios_base *)(a1 + 46);
  sub_100105DBC((uint64_t)a1, a2);
  *a1 = off_100186670;
  a1[45] = &off_100186770;
  a1[46] = &off_100186798;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12std::iostream::~basic_iostream(v2, v3 + 8) = -1;
  *a1 = off_100186670;
  a1[45] = off_1001866F8;
  a1[46] = off_100186720;
  return a1;
}

void sub_1000FCA6C(_Unwind_Exception *a1)
{
}

uint64_t sub_1000FCA90(uint64_t a1)
{
  return a1;
}

void *sub_1000FCAD0(void *a1, __int128 *a2)
{
  ssize_t v3 = (std::ios_base *)(a1 + 46);
  sub_100105E38((uint64_t)a1, a2);
  *a1 = off_100186890;
  a1[45] = &off_100186990;
  a1[46] = &off_1001869B8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12std::iostream::~basic_iostream(v2, v3 + 8) = -1;
  *a1 = off_100186890;
  a1[45] = off_100186918;
  a1[46] = off_100186940;
  return a1;
}

void sub_1000FCB54(_Unwind_Exception *a1)
{
}

uint64_t sub_1000FCB78(uint64_t a1)
{
  return a1;
}

void *sub_1000FCBB8(void *a1, __int128 *a2)
{
  ssize_t v3 = (std::ios_base *)(a1 + 46);
  sub_100105EB4((uint64_t)a1, a2);
  *a1 = off_100186AB0;
  a1[45] = &off_100186BB0;
  a1[46] = &off_100186BD8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12std::iostream::~basic_iostream(v2, v3 + 8) = -1;
  *a1 = off_100186AB0;
  a1[45] = off_100186B38;
  a1[46] = off_100186B60;
  return a1;
}

void sub_1000FCC3C(_Unwind_Exception *a1)
{
}

uint64_t sub_1000FCC60(uint64_t a1)
{
  return a1;
}

void *sub_1000FCCA0(void *a1, __int128 *a2)
{
  ssize_t v3 = (std::ios_base *)(a1 + 46);
  sub_100105F30((uint64_t)a1, a2);
  *a1 = off_100186CD0;
  a1[45] = &off_100186DD0;
  a1[46] = &off_100186DF8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12std::iostream::~basic_iostream(v2, v3 + 8) = -1;
  *a1 = off_100186CD0;
  a1[45] = off_100186D58;
  a1[46] = off_100186D80;
  return a1;
}

void sub_1000FCD24(_Unwind_Exception *a1)
{
}

uint64_t sub_1000FCD48(uint64_t a1)
{
  return a1;
}

ssize_t sub_1000FCD88(uint64_t a1, off_t a2, size_t a3, size_t a4, void *a5)
{
  size_t v7 = a3;
  unint64_t v22 = 0LL;
  __int128 v23 = 0LL;
  int v24 = 0LL;
  sub_1000FD028((void **)&v22, (a3 + a4 - 1) / a4 * a4);
  if (v7)
  {
    __int128 v10 = v23;
    do
    {
      if (v7 >= a4) {
        size_t v11 = a4;
      }
      else {
        size_t v11 = v7;
      }
      if (v10 >= v24)
      {
        uint64_t v12 = v10 - v22;
        unint64_t v13 = ((char *)v24 - (char *)v22) >> 3;
        if (v13 <= v12 + 1) {
          unint64_t v13 = v12 + 1;
        }
        else {
          unint64_t v14 = v13;
        }
        if (v14) {
          size_t v15 = (char *)sub_100016F60((uint64_t)&v24, v14);
        }
        else {
          size_t v15 = 0LL;
        }
        unint64_t v16 = (iovec *)&v15[16 * v12];
        v16->iov_base = a5;
        v16->iov_len = v11;
        int v18 = v22;
        ssize_t v17 = v23;
        int v19 = v16;
        if (v23 != v22)
        {
          do
          {
            v19[-1] = v17[-1];
            --v19;
            --v17;
          }

          while (v17 != v18);
          ssize_t v17 = v22;
        }

        __int128 v10 = v16 + 1;
        unint64_t v22 = v19;
        __int128 v23 = v16 + 1;
        int v24 = (iovec *)&v15[16 * v14];
        if (v17) {
          operator delete(v17);
        }
      }

      else
      {
        v10->iov_base = a5;
        v10->iov_len = v11;
        ++v10;
      }

      __int128 v23 = v10;
      v7 -= v11;
    }

    while (v7);
  }

  else
  {
    __int128 v10 = v23;
  }

  ssize_t v20 = pwritev(**(_DWORD **)(a1 + 56), v22, (unint64_t)((char *)v10 - (char *)v22) >> 4, a2);
  if (v22)
  {
    __int128 v23 = v22;
    operator delete(v22);
  }

  return v20;
}

void sub_1000FCF1C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1000FCF40(void *a1, __int128 *a2)
{
  ssize_t v3 = (std::ios_base *)(a1 + 46);
  sub_100105FAC((uint64_t)a1, a2);
  *a1 = off_100186EF0;
  a1[45] = &off_100186FF0;
  a1[46] = &off_100187018;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12std::iostream::~basic_iostream(v2, v3 + 8) = -1;
  *a1 = off_100186EF0;
  a1[45] = off_100186F78;
  a1[46] = off_100186FA0;
  return a1;
}

void sub_1000FCFC4(_Unwind_Exception *a1)
{
}

uint64_t sub_1000FCFE8(uint64_t a1)
{
  return a1;
}

void sub_1000FD028(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 4)
  {
    if (a2 >> 60) {
      sub_100016F4C();
    }
    int64_t v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    uint64_t v6 = (char *)sub_100016F60(v3, a2);
    size_t v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF0LL];
    uint64_t v9 = &v6[16 * v8];
    size_t v11 = (char *)*a1;
    __int128 v10 = (char *)a1[1];
    uint64_t v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        *((_OWORD *)v12 - sub_1000F1940(&v11, 1) = *((_OWORD *)v10 - 1);
        v12 -= 16;
        v10 -= 16;
      }

      while (v10 != v11);
      __int128 v10 = (char *)*a1;
    }

    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10) {
      operator delete(v10);
    }
  }

uint64_t sub_1000FD0C8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (*(_BYTE *)(v1 + 48)
    || ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 48LL))(a1) & 1) == 0 && sub_1000457D0(*(void *)(a1 + 40)))
  {
    return 0LL;
  }

  int v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 48LL))(a1);
  if (v4) {
    int v5 = 6;
  }
  else {
    int v5 = 5;
  }
  if (!flock(**(_DWORD **)(a1 + 56), v5))
  {
    *(void *)&__int128 v10 = "int FileLocal::lock()";
    *((void *)&v10 + sub_1000F1940(&v11, 1) = 19LL;
    int v11 = 0;
    sub_100053470(v12, &v10);
    sub_100004E4C(&v13, (uint64_t)"File (fd ", 9LL);
    std::ostream::operator<<(&v13, **(unsigned int **)(a1 + 56));
    sub_100004E4C(&v13, (uint64_t)") is locked", 11LL);
    std::ostream::~ostream(&v13, off_10016DC70);
    sub_1000535D4((uint64_t)v12);
    std::ios::~ios(v14);
    uint64_t result = 0LL;
    *(_BYTE *)(v1 + 4std::iostream::~basic_iostream(v2, v3 + 8) = 1;
    return result;
  }

  if (*__error() != 35)
  {
    *(void *)&__int128 v10 = "int FileLocal::lock()";
    *((void *)&v10 + sub_1000F1940(&v11, 1) = 19LL;
    int v11 = 0;
    sub_10009D9EC(v12, &v10);
    sub_100004E4C(&v13, (uint64_t)"flock returned errno ", 21LL);
    uint64_t v9 = __error();
    std::ostream::operator<<(&v13, *v9);
    sub_100004E4C(&v13, (uint64_t)", keeping file unlocked", 23LL);
    std::ostream::~ostream(&v13, off_10017B738);
    sub_1000A7E28((uint64_t)v12);
    std::ios::~ios(v14);
    return 0LL;
  }

  *(void *)&__int128 v10 = "int FileLocal::lock()";
  *((void *)&v10 + sub_1000F1940(&v11, 1) = 19LL;
  int v11 = 16;
  sub_1000FD378(v12, &v10);
  sub_100004E4C(&v13, (uint64_t)"Cannot acquire ", 15LL);
  if (v4) {
    uint64_t v6 = "exclusive";
  }
  else {
    uint64_t v6 = "shared";
  }
  if (v4) {
    uint64_t v7 = 9LL;
  }
  else {
    uint64_t v7 = 6LL;
  }
  sub_100004E4C(&v13, (uint64_t)v6, v7);
  sub_100004E4C(&v13, (uint64_t)" lock, errno ", 13LL);
  uint64_t v8 = __error();
  std::ostream::operator<<(&v13, *v8);
  std::ostream::~ostream(&v13, off_1001871D8);
  sub_100103BB4((uint64_t)v12);
  std::ios::~ios(v14);
  return -*__error();
}

void sub_1000FD340(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void *sub_1000FD378(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_100106028((uint64_t)a1, a2);
  *a1 = off_100187110;
  a1[45] = &off_100187210;
  a1[46] = &off_100187238;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12std::iostream::~basic_iostream(v2, v3 + 8) = -1;
  *a1 = off_100187110;
  a1[45] = off_100187198;
  a1[46] = off_1001871C0;
  return a1;
}

void sub_1000FD3FC(_Unwind_Exception *a1)
{
}

uint64_t sub_1000FD420(uint64_t a1)
{
  return a1;
}

uint64_t sub_1000FD460(uint64_t a1)
{
  return sub_1000FD0C8(a1 - 24);
}

uint64_t sub_1000FD468(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (!*(_BYTE *)(v1 + 48)) {
    return 0LL;
  }
  if (flock(**(_DWORD **)(a1 + 56), 8))
  {
    *(void *)&__int128 v5 = "int FileLocal::unlock_all()";
    *((void *)&v5 + sub_1000F1940(&v11, 1) = 25LL;
    int v6 = 16;
    sub_1000FD608(v7, &v5);
    sub_100004E4C(&v8, (uint64_t)"Failed unlocking file with fd ", 30LL);
    std::ostream::operator<<(&v8, **(unsigned int **)(a1 + 56));
    sub_100004E4C(&v8, (uint64_t)", errno ", 8LL);
    uint64_t v3 = __error();
    std::ostream::operator<<(&v8, *v3);
    std::ostream::~ostream(&v8, off_1001873F8);
    sub_100104160((uint64_t)v7);
    std::ios::~ios(v9);
    return -*__error();
  }

  else
  {
    *(void *)&__int128 v5 = "int FileLocal::unlock_all()";
    *((void *)&v5 + sub_1000F1940(&v11, 1) = 25LL;
    int v6 = 0;
    sub_10009DD1C(v7, &v5);
    sub_100004E4C(&v8, (uint64_t)"File (fd ", 9LL);
    std::ostream::operator<<(&v8, **(unsigned int **)(a1 + 56));
    sub_100004E4C(&v8, (uint64_t)") is unlocked", 13LL);
    std::ostream::~ostream(&v8, off_10017BB78);
    sub_1000A8980((uint64_t)v7);
    std::ios::~ios(v9);
    uint64_t result = 0LL;
    *(_BYTE *)(v1 + 4std::iostream::~basic_iostream(v2, v3 + 8) = 0;
  }

  return result;
}

void sub_1000FD5E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void *sub_1000FD608(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1001060A4((uint64_t)a1, a2);
  *a1 = off_100187330;
  a1[45] = &off_100187430;
  a1[46] = &off_100187458;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12std::iostream::~basic_iostream(v2, v3 + 8) = -1;
  *a1 = off_100187330;
  a1[45] = off_1001873B8;
  a1[46] = off_1001873E0;
  return a1;
}

void sub_1000FD68C(_Unwind_Exception *a1)
{
}

uint64_t sub_1000FD6B0(uint64_t a1)
{
  return a1;
}

uint64_t sub_1000FD6F0(uint64_t a1)
{
  return sub_1000FD468(a1 - 24);
}

uint64_t sub_1000FD6F8(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(a1 + 40) + 48LL);
}

uint64_t sub_1000FD704(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(a1 + 16) + 48LL);
}

uint64_t sub_1000FD710(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t result = *(unsigned __int8 *)(v1 + 48);
  *(_BYTE *)(v1 + 4std::iostream::~basic_iostream(v2, v3 + 8) = 0;
  return result;
}

void *sub_1000FD720(void *result)
{
  uint64_t v1 = result[9];
  if (v1)
  {
    uint64_t v2 = result;
    int v38 = *(unsigned __int8 *)(result[5] + 49LL);
    uint64_t v37 = result + 8;
    uint64_t v3 = (void *)result[8];
    int v4 = v3;
    while (1)
    {
      size_t v41 = (iovec *)v43;
      uint64_t v5 = v4[2];
      v43[0] = *v4;
      v43[1] = v5;
      __int128 v42 = xmmword_100141610;
      int v6 = &v3[8 * v1];
      __int128 v40 = &v41;
      if (v4 == v6)
      {
        uint64_t v7 = 1LL;
        unint64_t v8 = (unint64_t)v4;
      }

      else
      {
        uint64_t v7 = 1LL;
        unint64_t v8 = (unint64_t)v4;
        if (v4 + 8 != v6)
        {
          uint64_t v9 = v4;
          while (v9[2] + v9[3] == v9[11] && *((_DWORD *)v9 + 12) == *((_DWORD *)v9 + 28))
          {
            *(void *)&__int128 v39 = v9[8];
            *((void *)&v39 + sub_1000F1940(&v11, 1) = v9[10];
            sub_100106120((uint64_t *)&v40, &v39);
            unint64_t v8 = (unint64_t)(v9 + 8);
            __int128 v10 = v9 + 16;
            v9 += 8;
            if (v10 == v6) {
              goto LABEL_11;
            }
          }

          unint64_t v8 = (unint64_t)v9;
LABEL_11:
          uint64_t v7 = v42;
        }
      }

      unint64_t v11 = v8 + 64;
      int v12 = *((_DWORD *)v4 + 12);
      if (v12 == 1)
      {
        uint64_t v15 = v4[3];
        int v16 = *(_DWORD *)v2[7];
        if (v7 == 1) {
          ssize_t v17 = pwrite(v16, v41->iov_base, v41->iov_len, v4[3]);
        }
        else {
          ssize_t v17 = pwritev(v16, v41, (v11 - (unint64_t)v4) >> 6, v4[3]);
        }
        uint64_t v19 = v17;
        if (v17 < 1) {
          goto LABEL_45;
        }
        unint64_t v28 = v17 + v15;
        size_t v29 = (unint64_t *)(v2[5] + 64LL);
        unint64_t v30 = atomic_load(v29);
        if (v30 < v17 + v15)
        {
          do
          {
            unint64_t v31 = __ldaxr(v29);
            if (v31 == v30)
            {
              if (!__stlxr(v28, v29)) {
                goto LABEL_45;
              }
            }

            else
            {
              __clrex();
            }

            unint64_t v30 = v31;
          }

          while (v31 < v28);
          goto LABEL_45;
        }
      }

      else
      {
        if (!v12)
        {
          off_t v13 = v4[3];
          if (v7 == 1)
          {
            ssize_t v14 = pread(*(_DWORD *)v2[7], v41->iov_base, v41->iov_len, v4[3]);
LABEL_44:
            uint64_t v19 = v14;
LABEL_45:
            if (v19 == -1) {
              uint64_t v19 = -(uint64_t)*__error();
            }
            goto LABEL_47;
          }

          if (!v38)
          {
            ssize_t v14 = preadv(*(_DWORD *)v2[7], v41, (v11 - (unint64_t)v4) >> 6, v13);
            goto LABEL_44;
          }

          uint64_t v18 = v11 - (void)v4;
          if ((v11 - (void)v4) << 26)
          {
            uint64_t v19 = 0LL;
            uint64_t v20 = 0LL;
            int v21 = *(_DWORD *)v2[7];
            uint64_t v22 = 16LL * (int)(v18 >> 6);
            p_iov_len = &v41->iov_len;
            do
            {
              if ((v20 & 0x8000000000000000LL) == 0)
              {
                ssize_t v24 = pread(v21, (void *)*(p_iov_len - 1), *p_iov_len, v20 + v13);
                size_t v25 = *p_iov_len;
                uint64_t v26 = v19 + v24;
                uint64_t v27 = -5LL;
                if (v24 == -1) {
                  uint64_t v27 = -1LL;
                }
                if (v24 == v25) {
                  v19 += v24;
                }
                else {
                  uint64_t v19 = v27;
                }
                if (v24 == v25) {
                  uint64_t v20 = v26;
                }
                else {
                  uint64_t v20 = v27;
                }
              }

              p_iov_len += 2;
              v22 -= 16LL;
            }

            while (v22);
            goto LABEL_45;
          }
        }

        uint64_t v19 = 0LL;
      }

void sub_1000FDA88( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18)
{
  if (a18)
  {
    if (v18 != __p) {
      operator delete(__p);
    }
  }

  _Unwind_Resume(exception_object);
}

BOOL sub_1000FDAC0(uint64_t a1, uint64_t a2)
{
  return sub_1000FB3F8(*(void *)(a1 + 40), *(void *)(a2 + 40));
}

uint64_t sub_1000FDACC(uint64_t a1)
{
  *(void *)a1 = off_100184E20;
  *(void *)(a1 + 24) = off_100184F00;
  *(void *)(a1 + sub_1000114F0(v6 - 32) = off_100184F38;
  if (futimes(**(_DWORD **)(a1 + 56), 0LL))
  {
    *(void *)&__int128 v5 = "PurgeableFileBackend::~PurgeableFileBackend()";
    *((void *)&v5 + sub_1000F1940(&v11, 1) = 43LL;
    int v6 = 16;
    sub_1000FDBF4(v7, &v5);
    sub_100004E4C(&v8, (uint64_t)"futimes failed on ", 18LL);
    sub_100116E80((uint64_t)&v8, a1);
    sub_100004E4C(&v8, (uint64_t)", errno ", 8LL);
    uint64_t v2 = __error();
    std::ostream::operator<<(&v8, *v2);
    std::ostream::~ostream(&v8, off_100187618);
    sub_10010470C((uint64_t)v7);
    std::ios::~ios(&v9);
  }

  *(void *)a1 = off_100184F88;
  *(void *)(a1 + 24) = off_100185068;
  *(void *)(a1 + sub_1000114F0(v6 - 32) = off_1001850A0;
  sub_1000458AC(a1 + 64);
  sub_1000114F0(a1 + 40);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void *sub_1000FDBF4(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1001061D0((uint64_t)a1, a2);
  *a1 = off_100187550;
  a1[45] = &off_100187650;
  a1[46] = &off_100187678;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12std::iostream::~basic_iostream(v2, v3 + 8) = -1;
  *a1 = off_100187550;
  a1[45] = off_1001875D8;
  a1[46] = off_100187600;
  return a1;
}

void sub_1000FDC78(_Unwind_Exception *a1)
{
}

uint64_t sub_1000FDC9C(uint64_t a1)
{
  return a1;
}

uint64_t sub_1000FDCE0(uint64_t a1)
{
  return sub_1000FDACC(a1 - 24);
}

uint64_t sub_1000FDCE8(uint64_t a1)
{
  return sub_1000FDACC(a1 - 32);
}

void sub_1000FDCF0(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000FDACC(a1);
  operator delete(v1);
}

void sub_1000FDD04(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000FDACC(a1 - 24);
  operator delete(v1);
}

void sub_1000FDD1C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000FDACC(a1 - 32);
  operator delete(v1);
}

uint64_t sub_1000FDD34(uint64_t a1)
{
  uint64_t v1 = *(const void **)a1;
  if (!*(void *)a1) {
    return 0xFFFFFFFFLL;
  }
  if (!v3)
  {
    if (v11)
    {
      int v4 = *(std::__shared_weak_count **)(a1 + 8);
      if (v4)
      {
        uint64_t p_shared_owners = (unint64_t *)&v4->__shared_owners_;
        do
          unint64_t v13 = __ldxr(p_shared_owners);
        while (__stxr(v13 + 1, p_shared_owners));
      }

      uint64_t v7 = (*(uint64_t (**)(void *))(*(void *)v11 + 176LL))(v11);
      if (v4)
      {
        ssize_t v14 = (unint64_t *)&v4->__shared_owners_;
        do
          unint64_t v15 = __ldaxr(v14);
        while (__stlxr(v15 - 1, v14));
        if (!v15) {
          goto LABEL_13;
        }
      }

      return v7;
    }

    return 0xFFFFFFFFLL;
  }

  int v4 = *(std::__shared_weak_count **)(a1 + 8);
  if (v4)
  {
    __int128 v5 = (unint64_t *)&v4->__shared_owners_;
    do
      unint64_t v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }

  uint64_t v7 = (**v3)(v3);
  if (v4)
  {
    uint64_t v8 = (unint64_t *)&v4->__shared_owners_;
    do
      unint64_t v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
LABEL_13:
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

  return v7;
}

void sub_1000FDE88( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void sub_1000FDEAC(void *a1)
{
  *a1 = off_100184F88;
  a1[3] = off_100185068;
  a1[4] = off_1001850A0;
  sub_1000458AC((uint64_t)(a1 + 8));
  sub_1000114F0((uint64_t)(a1 + 5));
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  operator delete(a1);
}

BOOL sub_1000FDF00(uint64_t a1)
{
  return sub_10008DD9C(*(void *)(a1 + 40));
}

unint64_t sub_1000FDF08(uint64_t a1)
{
  return atomic_load((unint64_t *)(*(void *)(a1 + 40) + 64LL));
}

uint64_t sub_1000FDF18(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(a1 + 40) + 12LL);
}

void *sub_1000FDF24(uint64_t a1, void *a2)
{
  uint64_t v3 = sub_100004E4C(a2, (uint64_t)"file(", 5LL);
  int v4 = (void *)std::ostream::operator<<(v3, **(unsigned int **)(a1 + 56));
  return sub_100004E4C(v4, (uint64_t)")", 1LL);
}

double sub_1000FDF70@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  double result = v4[0];
  *a2 = *(_OWORD *)v4;
  return result;
}

unint64_t sub_1000FDFAC@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, unint64_t a3@<X8>)
{
  LOBYTE(v2sub_1000F1940(&v11, 1) = 0;
  BYTE4(v2sub_1000F1940(&v11, 1) = 0;
  uint64_t v22 = 0LL;
  *(void *)&v23[0] = sub_100116890((unint64_t)&v21);
  unint64_t v6 = sub_100116950((unint64_t)&v21);
  unint64_t v28 = &v21;
  *((void *)&v23[0] + sub_1000F1940(&v11, 1) = v6;
  *(void *)&v23[1] = &v28;
  sub_10003C7B8((unint64_t)v26, (uint64_t)&v21);
  uint64_t v7 = v28;
  uint64_t v27 = v28;
  v28[4] = (uint64_t)&v27;
  uint64_t v8 = *a2;
  unint64_t v9 = (std::__shared_weak_count *)a2[1];
  uint64_t v21 = *a2;
  uint64_t v22 = v9;
  if (v9)
  {
    uint64_t p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
    uint64_t v7 = v27;
  }

  *(_OWORD *)((char *)v23 + 9) = *(_OWORD *)((char *)a2 + 25);
  v23[0] = *((_OWORD *)a2 + 1);
  int v24 = 0;
  size_t v25 = v7;
  uint64_t v27 = 0LL;
  void v7[4] = (uint64_t)&v25;
  uint64_t v12 = a1[9];
  uint64_t v13 = a1[8] + (v12 << 6);
  if (v12 == a1[10])
  {
    sub_100104C10(a1 + 8, v13, 1LL, (uint64_t)&v21, &v28);
    if (v25) {
      v25[4] = 0LL;
    }
  }

  else
  {
    *(void *)uint64_t v13 = v8;
    *(void *)(v13 + std::iostream::~basic_iostream(v2, v3 + 8) = v9;
    uint64_t v21 = 0LL;
    uint64_t v22 = 0LL;
    __int128 v14 = v23[0];
    *(_OWORD *)(v13 + 25) = *(_OWORD *)((char *)v23 + 9);
    *(_OWORD *)(v13 + 16) = v14;
    int v15 = v24;
    *(void *)(v13 + 56) = v25;
    uint64_t v16 = v13 + 56;
    *(_DWORD *)(v16 - std::iostream::~basic_iostream(v2, v3 + 8) = v15;
    size_t v25 = 0LL;
    *(void *)(*(void *)v16 + 32LL) = v16;
    ++a1[9];
  }

  ssize_t v17 = v22;
  if (v22)
  {
    uint64_t v18 = (unint64_t *)&v22->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  unint64_t result = sub_10003C7B8(a3, (uint64_t)v26);
  if (v27) {
    v27[4] = 0LL;
  }
  return result;
}

void sub_1000FE148( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23)
{
  if (a17) {
    *(void *)(a17 + sub_1000114F0(v6 - 32) = 0LL;
  }
  sub_1000114F0((uint64_t)&a10);
  if (a23) {
    *(void *)(a23 + sub_1000114F0(v6 - 32) = 0LL;
  }
  _Unwind_Resume(a1);
}

void sub_1000FE17C()
{
  if (!*(void *)(v0 - 40)) {
    JUMPOUT(0x1000FE174LL);
  }
  JUMPOUT(0x1000FE170LL);
}

unint64_t sub_1000FE18C@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, unint64_t a3@<X8>)
{
  LOBYTE(v2sub_1000F1940(&v11, 1) = 0;
  BYTE4(v2sub_1000F1940(&v11, 1) = 0;
  uint64_t v22 = 0LL;
  *(void *)&v23[0] = sub_100116890((unint64_t)&v21);
  unint64_t v6 = sub_100116950((unint64_t)&v21);
  unint64_t v28 = &v21;
  *((void *)&v23[0] + sub_1000F1940(&v11, 1) = v6;
  *(void *)&v23[1] = &v28;
  sub_10003C7B8((unint64_t)v26, (uint64_t)&v21);
  uint64_t v7 = v28;
  uint64_t v27 = v28;
  v28[4] = (uint64_t)&v27;
  uint64_t v8 = *a2;
  unint64_t v9 = (std::__shared_weak_count *)a2[1];
  uint64_t v21 = *a2;
  uint64_t v22 = v9;
  if (v9)
  {
    uint64_t p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
    uint64_t v7 = v27;
  }

  *(_OWORD *)((char *)v23 + 9) = *(_OWORD *)((char *)a2 + 25);
  v23[0] = *((_OWORD *)a2 + 1);
  int v24 = 1;
  size_t v25 = v7;
  uint64_t v27 = 0LL;
  void v7[4] = (uint64_t)&v25;
  uint64_t v12 = a1[9];
  uint64_t v13 = a1[8] + (v12 << 6);
  if (v12 == a1[10])
  {
    sub_100104C10(a1 + 8, v13, 1LL, (uint64_t)&v21, &v28);
    if (v25) {
      v25[4] = 0LL;
    }
  }

  else
  {
    *(void *)uint64_t v13 = v8;
    *(void *)(v13 + std::iostream::~basic_iostream(v2, v3 + 8) = v9;
    uint64_t v21 = 0LL;
    uint64_t v22 = 0LL;
    __int128 v14 = v23[0];
    *(_OWORD *)(v13 + 25) = *(_OWORD *)((char *)v23 + 9);
    *(_OWORD *)(v13 + 16) = v14;
    int v15 = v24;
    *(void *)(v13 + 56) = v25;
    uint64_t v16 = v13 + 56;
    *(_DWORD *)(v16 - std::iostream::~basic_iostream(v2, v3 + 8) = v15;
    size_t v25 = 0LL;
    *(void *)(*(void *)v16 + 32LL) = v16;
    ++a1[9];
  }

  ssize_t v17 = v22;
  if (v22)
  {
    uint64_t v18 = (unint64_t *)&v22->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  unint64_t result = sub_10003C7B8(a3, (uint64_t)v26);
  if (v27) {
    v27[4] = 0LL;
  }
  return result;
}

void sub_1000FE32C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23)
{
  if (a17) {
    *(void *)(a17 + sub_1000114F0(v6 - 32) = 0LL;
  }
  sub_1000114F0((uint64_t)&a10);
  if (a23) {
    *(void *)(a23 + sub_1000114F0(v6 - 32) = 0LL;
  }
  _Unwind_Resume(a1);
}

void sub_1000FE360()
{
  if (!*(void *)(v0 - 40)) {
    JUMPOUT(0x1000FE358LL);
  }
  JUMPOUT(0x1000FE354LL);
}

uint64_t sub_1000FE370(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 40) + 32LL);
}

uint64_t sub_1000FE37C(uint64_t a1)
{
  return **(unsigned int **)(a1 + 56);
}

void sub_1000FE388(void *a1)
{
  *(a1 - 3) = off_100184F88;
  *a1 = off_100185068;
  a1[1] = off_1001850A0;
  sub_1000458AC((uint64_t)(a1 + 5));
  sub_1000114F0((uint64_t)(a1 + 2));
  uint64_t v2 = (std::__shared_weak_count *)*(a1 - 1);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void sub_1000FE3D4(void *a1)
{
  *(a1 - 3) = off_100184F88;
  uint64_t v2 = a1 - 3;
  *a1 = off_100185068;
  a1[1] = off_1001850A0;
  sub_1000458AC((uint64_t)(a1 + 5));
  sub_1000114F0((uint64_t)(a1 + 2));
  uint64_t v3 = (std::__shared_weak_count *)*(a1 - 1);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  operator delete(v2);
}

uint64_t sub_1000FE428(uint64_t a1)
{
  return **(unsigned int **)(a1 + 24);
}

void sub_1000FE434(void *a1)
{
  *(a1 - 4) = off_100184F88;
  *(a1 - sub_1000F1940(&v11, 1) = off_100185068;
  *a1 = off_1001850A0;
  sub_1000458AC((uint64_t)(a1 + 4));
  sub_1000114F0((uint64_t)(a1 + 1));
  uint64_t v2 = (std::__shared_weak_count *)*(a1 - 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void sub_1000FE484(void *a1)
{
  *(a1 - 4) = off_100184F88;
  uint64_t v2 = a1 - 4;
  *(a1 - sub_1000F1940(&v11, 1) = off_100185068;
  *a1 = off_1001850A0;
  sub_1000458AC((uint64_t)(a1 + 4));
  sub_1000114F0((uint64_t)(a1 + 1));
  uint64_t v3 = (std::__shared_weak_count *)*(a1 - 2);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  operator delete(v2);
}

uint64_t sub_1000FE4DC(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_1001851F8);
  sub_1000FE6A0(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000FE514(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001851F8);
  sub_1000FE6A0(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000FE554(char *a1)
{
}

uint64_t sub_1000FE598(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000FE5CC(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000FE618(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_1001851F8);
  sub_1000FE6A0((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000FE658(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001851F8);
  sub_1000FE6A0((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000FE6A0(uint64_t a1)
{
  *(void *)a1 = off_1001852C8;
  sub_1000FE73C(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000FE73C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000FE8A4((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000FE864( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000FE890(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000FE6A0(a1);
  operator delete(v1);
}

int *sub_1000FE8A4(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      __int128 v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 66LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 66LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  unint64_t result = __error();
  *unint64_t result = v5;
  return result;
}

uint64_t sub_1000FEA88(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100185418);
  sub_1000FEC4C(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000FEAC0(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100185418);
  sub_1000FEC4C(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000FEB00(char *a1)
{
}

uint64_t sub_1000FEB44(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000FEB78(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000FEBC4(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100185418);
  sub_1000FEC4C((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000FEC04(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100185418);
  sub_1000FEC4C((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000FEC4C(uint64_t a1)
{
  *(void *)a1 = off_1001854E8;
  sub_1000FECE8(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000FECE8(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000FEE50((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000FEE10( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000FEE3C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000FEC4C(a1);
  operator delete(v1);
}

int *sub_1000FEE50(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      __int128 v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 78LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 78LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  unint64_t result = __error();
  *unint64_t result = v5;
  return result;
}

uint64_t sub_1000FF034(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100185638);
  sub_1000FF1F8(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000FF06C(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100185638);
  sub_1000FF1F8(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000FF0AC(char *a1)
{
}

uint64_t sub_1000FF0F0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000FF124(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000FF170(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100185638);
  sub_1000FF1F8((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000FF1B0(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100185638);
  sub_1000FF1F8((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000FF1F8(uint64_t a1)
{
  *(void *)a1 = off_100185708;
  sub_1000FF294(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000FF294(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000FF3FC((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000FF3BC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000FF3E8(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000FF1F8(a1);
  operator delete(v1);
}

int *sub_1000FF3FC(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      __int128 v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 95LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 95LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  unint64_t result = __error();
  *unint64_t result = v5;
  return result;
}

uint64_t sub_1000FF5E0(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100185858);
  sub_1000FF7A4(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000FF618(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100185858);
  sub_1000FF7A4(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000FF658(char *a1)
{
}

uint64_t sub_1000FF69C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000FF6D0(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000FF71C(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100185858);
  sub_1000FF7A4((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000FF75C(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100185858);
  sub_1000FF7A4((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000FF7A4(uint64_t a1)
{
  *(void *)a1 = off_100185928;
  sub_1000FF840(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000FF840(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000FF9A8((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000FF968( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000FF994(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000FF7A4(a1);
  operator delete(v1);
}

int *sub_1000FF9A8(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      __int128 v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 103LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 103LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  unint64_t result = __error();
  *unint64_t result = v5;
  return result;
}

uint64_t sub_1000FFB8C(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100185A78);
  sub_1000FFD50(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1000FFBC4(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100185A78);
  sub_1000FFD50(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1000FFC04(char *a1)
{
}

uint64_t sub_1000FFC48(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1000FFC7C(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1000FFCC8(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100185A78);
  sub_1000FFD50((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1000FFD08(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100185A78);
  sub_1000FFD50((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1000FFD50(uint64_t a1)
{
  *(void *)a1 = off_100185B48;
  sub_1000FFDEC(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1000FFDEC(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1000FFF54((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1000FFF14( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000FFF40(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000FFD50(a1);
  operator delete(v1);
}

int *sub_1000FFF54(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      __int128 v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 298LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 298LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  unint64_t result = __error();
  *unint64_t result = v5;
  return result;
}

uint64_t sub_100100138(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100185C98);
  sub_1001002FC(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_100100170(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100185C98);
  sub_1001002FC(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1001001B0(char *a1)
{
}

uint64_t sub_1001001F4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_100100228(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_100100274(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100185C98);
  sub_1001002FC((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1001002B4(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100185C98);
  sub_1001002FC((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1001002FC(uint64_t a1)
{
  *(void *)a1 = off_100185D68;
  sub_100100398(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_100100398(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_100100500((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1001004C0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001004EC(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1001002FC(a1);
  operator delete(v1);
}

int *sub_100100500(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      __int128 v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 313LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 313LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  unint64_t result = __error();
  *unint64_t result = v5;
  return result;
}

uint64_t sub_1001006E4(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100185EB8);
  sub_1001008A8(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_10010071C(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100185EB8);
  sub_1001008A8(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_10010075C(char *a1)
{
}

uint64_t sub_1001007A0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1001007D4(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_100100820(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100185EB8);
  sub_1001008A8((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_100100860(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100185EB8);
  sub_1001008A8((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1001008A8(uint64_t a1)
{
  *(void *)a1 = off_100185F88;
  sub_100100944(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_100100944(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_100100AAC((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_100100A6C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100100A98(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1001008A8(a1);
  operator delete(v1);
}

int *sub_100100AAC(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      __int128 v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 336LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 336LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  unint64_t result = __error();
  *unint64_t result = v5;
  return result;
}

uint64_t sub_100100C90(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_1001860D8);
  sub_100100E54(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_100100CC8(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001860D8);
  sub_100100E54(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_100100D08(char *a1)
{
}

uint64_t sub_100100D4C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_100100D80(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_100100DCC(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_1001860D8);
  sub_100100E54((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_100100E0C(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001860D8);
  sub_100100E54((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_100100E54(uint64_t a1)
{
  *(void *)a1 = off_1001861A8;
  sub_100100EF0(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_100100EF0(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_100101058((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_100101018( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100101044(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100100E54(a1);
  operator delete(v1);
}

int *sub_100101058(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      __int128 v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 381LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 381LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  unint64_t result = __error();
  *unint64_t result = v5;
  return result;
}

uint64_t sub_10010123C(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_1001862F8);
  sub_100101400(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_100101274(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001862F8);
  sub_100101400(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1001012B4(char *a1)
{
}

uint64_t sub_1001012F8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_10010132C(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_100101378(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_1001862F8);
  sub_100101400((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1001013B8(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001862F8);
  sub_100101400((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_100101400(uint64_t a1)
{
  *(void *)a1 = off_1001863C8;
  sub_10010149C(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_10010149C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_100101604((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1001015C4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001015F0(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100101400(a1);
  operator delete(v1);
}

int *sub_100101604(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      __int128 v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 388LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 388LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  unint64_t result = __error();
  *unint64_t result = v5;
  return result;
}

uint64_t sub_1001017E8(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100186518);
  sub_1001019AC(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_100101820(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100186518);
  sub_1001019AC(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_100101860(char *a1)
{
}

uint64_t sub_1001018A4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1001018D8(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_100101924(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100186518);
  sub_1001019AC((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_100101964(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100186518);
  sub_1001019AC((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1001019AC(uint64_t a1)
{
  *(void *)a1 = off_1001865E8;
  sub_100101A48(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_100101A48(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_100101BB0((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_100101B70( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100101B9C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1001019AC(a1);
  operator delete(v1);
}

int *sub_100101BB0(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      __int128 v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 398LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 398LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  unint64_t result = __error();
  *unint64_t result = v5;
  return result;
}

uint64_t sub_100101D94(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100186738);
  sub_100101F58(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_100101DCC(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100186738);
  sub_100101F58(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_100101E0C(char *a1)
{
}

uint64_t sub_100101E50(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_100101E84(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_100101ED0(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100186738);
  sub_100101F58((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_100101F10(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100186738);
  sub_100101F58((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_100101F58(uint64_t a1)
{
  *(void *)a1 = off_100186808;
  sub_100101FF4(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_100101FF4(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_10010215C((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_10010211C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100102148(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100101F58(a1);
  operator delete(v1);
}

int *sub_10010215C(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      __int128 v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 411LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 411LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  unint64_t result = __error();
  *unint64_t result = v5;
  return result;
}

uint64_t sub_100102340(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100186958);
  sub_100102504(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_100102378(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100186958);
  sub_100102504(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1001023B8(char *a1)
{
}

uint64_t sub_1001023FC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_100102430(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_10010247C(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100186958);
  sub_100102504((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1001024BC(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100186958);
  sub_100102504((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_100102504(uint64_t a1)
{
  *(void *)a1 = off_100186A28;
  sub_1001025A0(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1001025A0(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_100102708((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1001026C8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001026F4(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100102504(a1);
  operator delete(v1);
}

int *sub_100102708(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      __int128 v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 424LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 424LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  unint64_t result = __error();
  *unint64_t result = v5;
  return result;
}

uint64_t sub_1001028EC(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100186B78);
  sub_100102AB0(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_100102924(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100186B78);
  sub_100102AB0(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_100102964(char *a1)
{
}

uint64_t sub_1001029A8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1001029DC(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_100102A28(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100186B78);
  sub_100102AB0((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_100102A68(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100186B78);
  sub_100102AB0((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_100102AB0(uint64_t a1)
{
  *(void *)a1 = off_100186C48;
  sub_100102B4C(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_100102B4C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_100102CB4((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_100102C74( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100102CA0(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100102AB0(a1);
  operator delete(v1);
}

int *sub_100102CB4(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      __int128 v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 432LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 432LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  unint64_t result = __error();
  *unint64_t result = v5;
  return result;
}

uint64_t sub_100102E98(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100186D98);
  sub_10010305C(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_100102ED0(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100186D98);
  sub_10010305C(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_100102F10(char *a1)
{
}

uint64_t sub_100102F54(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_100102F88(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_100102FD4(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100186D98);
  sub_10010305C((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_100103014(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100186D98);
  sub_10010305C((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_10010305C(uint64_t a1)
{
  *(void *)a1 = off_100186E68;
  sub_1001030F8(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1001030F8(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_100103260((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_100103220( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10010324C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_10010305C(a1);
  operator delete(v1);
}

int *sub_100103260(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      __int128 v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 441LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 441LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  unint64_t result = __error();
  *unint64_t result = v5;
  return result;
}

uint64_t sub_100103444(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100186FB8);
  sub_100103608(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_10010347C(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100186FB8);
  sub_100103608(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1001034BC(char *a1)
{
}

uint64_t sub_100103500(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_100103534(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_100103580(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100186FB8);
  sub_100103608((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1001035C0(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100186FB8);
  sub_100103608((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_100103608(uint64_t a1)
{
  *(void *)a1 = off_100187088;
  sub_1001036A4(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1001036A4(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_10010380C((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1001037CC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001037F8(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100103608(a1);
  operator delete(v1);
}

int *sub_10010380C(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      __int128 v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 449LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 449LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  unint64_t result = __error();
  *unint64_t result = v5;
  return result;
}

uint64_t sub_1001039F0(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_1001871D8);
  sub_100103BB4(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_100103A28(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001871D8);
  sub_100103BB4(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_100103A68(char *a1)
{
}

uint64_t sub_100103AAC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_100103AE0(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_100103B2C(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_1001871D8);
  sub_100103BB4((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_100103B6C(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001871D8);
  sub_100103BB4((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_100103BB4(uint64_t a1)
{
  *(void *)a1 = off_1001872A8;
  sub_100103C50(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_100103C50(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_100103DB8((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_100103D78( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100103DA4(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100103BB4(a1);
  operator delete(v1);
}

int *sub_100103DB8(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      __int128 v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 489LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 489LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  unint64_t result = __error();
  *unint64_t result = v5;
  return result;
}

uint64_t sub_100103F9C(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_1001873F8);
  sub_100104160(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_100103FD4(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001873F8);
  sub_100104160(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_100104014(char *a1)
{
}

uint64_t sub_100104058(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_10010408C(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1001040D8(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_1001873F8);
  sub_100104160((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_100104118(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001873F8);
  sub_100104160((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_100104160(uint64_t a1)
{
  *(void *)a1 = off_1001874C8;
  sub_1001041FC(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1001041FC(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_100104364((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_100104324( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100104350(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100104160(a1);
  operator delete(v1);
}

int *sub_100104364(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      __int128 v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 502LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 502LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  unint64_t result = __error();
  *unint64_t result = v5;
  return result;
}

uint64_t sub_100104548(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100187618);
  sub_10010470C(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_100104580(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100187618);
  sub_10010470C(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1001045C0(char *a1)
{
}

uint64_t sub_100104604(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_100104638(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_100104684(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100187618);
  sub_10010470C((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_1001046C4(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100187618);
  sub_10010470C((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_10010470C(uint64_t a1)
{
  *(void *)a1 = off_1001876E8;
  sub_1001047A8(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_1001047A8(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_100104910((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1001048D0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001048FC(uint64_t a1)
{
  uint64_t v1 = (void *)sub_10010470C(a1);
  operator delete(v1);
}

int *sub_100104910(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      __int128 v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 643LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    unint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      uint64_t v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 643LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  unint64_t result = __error();
  *unint64_t result = v5;
  return result;
}

void sub_100104AF4(uint64_t a1@<X1>, void *a2@<X8>)
{
  int v4 = operator new(0x470uLL);
  sub_100104B54(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  sub_100018774((uint64_t)a2, v4 + 4, (uint64_t)(v4 + 3));
}

void sub_100104B40(_Unwind_Exception *a1)
{
}

void *sub_100104B54(void *a1, uint64_t a2)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10016D710;
  sub_100104B9C(a1 + 3, a2);
  return a1;
}

void sub_100104B88(_Unwind_Exception *a1)
{
}

double sub_100104B9C(void *a1, uint64_t a2)
{
  uint64_t v3 = sub_100116E6C(a1);
  *uint64_t v3 = off_100184F88;
  _OWORD v3[3] = off_100185068;
  v3[4] = off_1001850A0;
  uint64_t v4 = *(void *)(a2 + 40);
  uint64_t v5 = *(void *)(a2 + 48);
  v3[5] = v4;
  v3[6] = v5;
  if (v5)
  {
    char v6 = (unint64_t *)(v5 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
    uint64_t v4 = v3[5];
  }

  v3[7] = v4 + 8;
  v3[8] = v3 + 11;
  double result = 0.0;
  *(_OWORD *)(v3 + 9) = xmmword_1001388C0;
  return result;
}

void sub_100104C10(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  uint64_t v10 = *a1;
  unint64_t v11 = sub_1000F5FC8((uint64_t)a1, a3);
  if (v11 >> 57) {
    sub_100014AD4("get_next_capacity, allocator's max size reached");
  }
  uint64_t v12 = v11;
  uint64_t v13 = operator new(v11 << 6);
  sub_100104CAC(a1, (uint64_t)v13, v12, a2, a3, a4);
  *a5 = *a1 + a2 - v10;
}

void sub_100104CAC(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10 = *a1;
  sub_100104D7C((uint64_t)a1, *a1, a4, *a1 + (a1[1] << 6), a2, a5, a6);
  if (v10)
  {
    for (uint64_t i = a1[1]; i; v10 += 64LL)
    {
      uint64_t v12 = *(void *)(v10 + 56);
      if (v12) {
        *(void *)(v12 + sub_1000114F0(v6 - 32) = 0LL;
      }
      --i;
      sub_1000114F0(v10);
    }
  }

  uint64_t v13 = a1[1] + a5;
  *a1 = a2;
  a1[1] = v13;
  a1[2] = a3;
}

void sub_100104D58(_Unwind_Exception *exception_object)
{
  if (v1)
  {
  }

  _Unwind_Resume(exception_object);
}

__n128 sub_100104D7C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  while (a2 != a3)
  {
    *(_OWORD *)a5 = *(_OWORD *)a2;
    *(void *)a2 = 0LL;
    *(void *)(a2 + std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
    __int128 v7 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)(a5 + 25) = *(_OWORD *)(a2 + 25);
    *(_OWORD *)(a5 + 16) = v7;
    int v8 = *(_DWORD *)(a2 + 48);
    *(void *)(a5 + 56) = *(void *)(a2 + 56);
    uint64_t v9 = a5 + 56;
    *(_DWORD *)(v9 - std::iostream::~basic_iostream(v2, v3 + 8) = v8;
    *(void *)(a2 + 56) = 0LL;
    *(void *)(*(void *)v9 + 32LL) = v9;
    a5 = v9 + 8;
    a2 += 64LL;
  }

  *(_OWORD *)a5 = *(_OWORD *)a7;
  *(void *)a7 = 0LL;
  *(void *)(a7 + std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
  __n128 result = *(__n128 *)(a7 + 16);
  *(_OWORD *)(a5 + 25) = *(_OWORD *)(a7 + 25);
  *(__n128 *)(a5 + 16) = result;
  *(void *)(a5 + 56) = *(void *)(a7 + 56);
  *(_DWORD *)(a5 + 4std::iostream::~basic_iostream(v2, v3 + 8) = *(_DWORD *)(a7 + 48);
  *(void *)(a7 + 56) = 0LL;
  *(void *)(*(void *)(a5 + 56) + 32LL) = a5 + 56;
  if (a3 != a4)
  {
    uint64_t v11 = a5 + (a6 << 6);
    do
    {
      *(_OWORD *)uint64_t v11 = *(_OWORD *)a3;
      *(void *)a3 = 0LL;
      *(void *)(a3 + std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
      __n128 result = *(__n128 *)(a3 + 16);
      *(_OWORD *)(v11 + 25) = *(_OWORD *)(a3 + 25);
      *(__n128 *)(v11 + 16) = result;
      int v12 = *(_DWORD *)(a3 + 48);
      *(void *)(v11 + 56) = *(void *)(a3 + 56);
      uint64_t v13 = v11 + 56;
      *(_DWORD *)(v13 - std::iostream::~basic_iostream(v2, v3 + 8) = v12;
      *(void *)(a3 + 56) = 0LL;
      *(void *)(*(void *)v13 + 32LL) = v13;
      a3 += 64LL;
      uint64_t v11 = v13 + 8;
    }

    while (a3 != a4);
  }

  return result;
}

uint64_t sub_100104E5C(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_1001852C8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_100104EC4(_Unwind_Exception *a1)
{
}

uint64_t sub_100104ED8(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_1001854E8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_100104F40(_Unwind_Exception *a1)
{
}

uint64_t sub_100104F54(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_100185708;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_100104FBC(_Unwind_Exception *a1)
{
}

uint64_t sub_100104FD0(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_100185928;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_100105038(_Unwind_Exception *a1)
{
}

void sub_10010504C(uint64_t ***a1)
{
  uint64_t v1 = **a1;
  uint64_t v2 = *v1;
  if ((fstatfs(*(_DWORD *)(*v1 + 8), &v21) & 0x80000000) == 0)
  {
    f_buint64_t size = v21.f_bsize;
    if (!*(_BYTE *)(v2 + 88)) {
      *(_BYTE *)(v2 + 8std::iostream::~basic_iostream(v2, v3 + 8) = 1;
    }
    *(void *)(v2 + 7sub_1000F1278(&v6, 2) = f_bsize;
    char v4 = valloc(f_bsize);
    if (!v4)
    {
      exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
      uint64_t v16 = std::bad_alloc::bad_alloc(exception);
    }

    *(void *)&__int128 v22 = &off_100187988;
    uint64_t v24 = &v22;
    ssize_t v17 = v4;
    sub_1000172D0((uint64_t)&v18, (uint64_t)&v22);
    __int128 v5 = v24;
    if (v24 == &v22)
    {
      uint64_t v6 = 4LL;
      __int128 v5 = &v22;
    }

    else
    {
      if (!v24) {
        goto LABEL_14;
      }
      uint64_t v6 = 5LL;
    }

    (*(void (**)(void))(*(void *)v5 + 8 * v6))();
LABEL_14:
    sub_100105380(v2 + 96, (uint64_t *)&v17);
    sub_100016DE0((uint64_t *)&v17);
    int64_t v14 = *(void *)(v2 + 72);
    if (v14 >= 1) {
      bzero(*(void **)(v2 + 96), v14);
    }
    return;
  }

  *(void *)&__int128 v22 = "FileLocal::shared_state_t::init_unmap_zeros()::(anonymous class)::operator()() const";
  *((void *)&v22 + sub_1000F1940(&v11, 1) = 76LL;
  int v23 = 16;
  sub_100105298(&v17, &v22);
  sub_100004E4C(&v19, (uint64_t)"fstatfs failed with err code ", 29LL);
  __int128 v7 = __error();
  std::ostream::operator<<(&v19, *v7);
  std::ostream::~ostream(&v19, off_100187838);
  sub_100105444((uint64_t)&v17);
  std::ios::~ios(&v20);
  int v8 = *__error();
  uint64_t v9 = std::generic_category();
  int v10 = *(unsigned __int8 *)(v2 + 88);
  *(_DWORD *)(v2 + 7sub_1000F1278(&v6, 2) = v8;
  *(void *)(v2 + 8sub_1000F1278((int *)&v3, 0) = v9;
  if (v10) {
    *(_BYTE *)(v2 + 8std::iostream::~basic_iostream(v2, v3 + 8) = 0;
  }
  int v11 = *__error();
  int v12 = std::generic_category();
  uint64_t v13 = v12;
  if (*(_BYTE *)(v2 + 136))
  {
    sub_100016DE0((uint64_t *)(v2 + 96));
    *(_DWORD *)(v2 + 96) = v11;
    *(void *)(v2 + 104) = v13;
    *(_BYTE *)(v2 + 136) = 0;
  }

  else
  {
    *(_DWORD *)(v2 + 96) = v11;
    *(void *)(v2 + 104) = v12;
  }

void sub_100105250(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *sub_100105298(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_1001053C8((uint64_t)a1, a2);
  *a1 = off_100187770;
  a1[45] = &off_100187870;
  a1[46] = &off_100187898;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12std::iostream::~basic_iostream(v2, v3 + 8) = -1;
  *a1 = off_100187770;
  a1[45] = off_1001877F8;
  a1[46] = off_100187820;
  return a1;
}

void sub_10010531C(_Unwind_Exception *a1)
{
}

uint64_t sub_100105340(uint64_t a1)
{
  return a1;
}

uint64_t sub_100105380(uint64_t a1, uint64_t *a2)
{
  if (*(_BYTE *)(a1 + 40)) {
    sub_100010FDC((uint64_t *)a1, a2);
  }
  else {
    sub_100105A84(a1, a1, a2);
  }
  return a1;
}

uint64_t sub_1001053C8(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_100187908;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_100105430(_Unwind_Exception *a1)
{
}

uint64_t sub_100105444(uint64_t a1)
{
  *(void *)a1 = off_100187908;
  sub_1001056BC(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

void sub_1001054E0(char *a1)
{
}

uint64_t sub_100105524(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_100105558(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

uint64_t sub_1001055A4(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100187838);
  sub_100105444(v2);
  return std::ios::~ios(a1 + 8);
}

void sub_1001055DC(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100187838);
  sub_100105444((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

uint64_t sub_10010561C(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100187838);
  sub_100105444(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_10010565C(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100187838);
  sub_100105444((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

void sub_1001056A8(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100105444(a1);
  operator delete(v1);
}

uint64_t sub_1001056BC(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_10010580C((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_1001057E4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

int *sub_10010580C(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      int v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 236LL;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    int v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      int v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        uint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 236LL;
      __int16 v25 = 2082;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  __n128 result = __error();
  *__n128 result = v5;
  return result;
}

void *sub_1001059F8()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &off_100187988;
  return result;
}

void sub_100105A1C(uint64_t a1, void *a2)
{
  *a2 = &off_100187988;
}

void sub_100105A34(uint64_t a1, void **a2)
{
}

uint64_t sub_100105A3C(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100105A78()
{
  return &off_1001879E8;
}

uint64_t sub_100105A84(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (*(_BYTE *)(a1 + 40)) {
    sub_100016DE0((uint64_t *)a1);
  }
  uint64_t v5 = *a3;
  *a3 = 0LL;
  *(void *)a1 = v5;
  uint64_t result = sub_1000172D0(a1 + 8, (uint64_t)(a3 + 1));
  *(_BYTE *)(a1 + 4sub_1000F1278((int *)&v3, 0) = 1;
  return result;
}

uint64_t sub_100105AD4(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_100185B48;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_100105B3C(_Unwind_Exception *a1)
{
}

uint64_t sub_100105B50(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_100185D68;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_100105BB8(_Unwind_Exception *a1)
{
}

uint64_t sub_100105BCC(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_100185F88;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_100105C34(_Unwind_Exception *a1)
{
}

uint64_t sub_100105C48(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_1001861A8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_100105CB0(_Unwind_Exception *a1)
{
}

uint64_t sub_100105CC4(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_1001863C8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_100105D2C(_Unwind_Exception *a1)
{
}

uint64_t sub_100105D40(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_1001865E8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_100105DA8(_Unwind_Exception *a1)
{
}

uint64_t sub_100105DBC(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_100186808;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_100105E24(_Unwind_Exception *a1)
{
}

uint64_t sub_100105E38(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_100186A28;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_100105EA0(_Unwind_Exception *a1)
{
}

uint64_t sub_100105EB4(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_100186C48;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_100105F1C(_Unwind_Exception *a1)
{
}

uint64_t sub_100105F30(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_100186E68;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_100105F98(_Unwind_Exception *a1)
{
}

uint64_t sub_100105FAC(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_100187088;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_100106014(_Unwind_Exception *a1)
{
}

uint64_t sub_100106028(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_1001872A8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_100106090(_Unwind_Exception *a1)
{
}

uint64_t sub_1001060A4(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_1001874C8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_10010610C(_Unwind_Exception *a1)
{
}

uint64_t *sub_100106120(uint64_t *a1, _OWORD *a2)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(void *)(v4 + 8);
  char v6 = (char *)(*(void *)v4 + 16 * v5);
  if (v5 == *(void *)(v4 + 16))
  {
    sub_1000AAE04((void **)v4, v6, 1LL, a2, &v8);
  }

  else
  {
    *(_OWORD *)char v6 = *a2;
    ++*(void *)(v4 + 8);
  }

  return a1;
}

void *sub_100106188(void *result)
{
  uint64_t v1 = result;
  uint64_t v2 = result[1];
  if (v2)
  {
    uint64_t result = (void *)*result;
    do
    {
      uint64_t v3 = result[7];
      if (v3) {
        *(void *)(v3 + sub_1000114F0(v6 - 32) = 0LL;
      }
      --v2;
      uint64_t result = (void *)(sub_1000114F0((uint64_t)result) + 64);
    }

    while (v2);
  }

  v1[1] = 0LL;
  return result;
}

uint64_t sub_1001061D0(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_1001876E8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_100106238(_Unwind_Exception *a1)
{
}

void *sub_10010624C(void *__dst, __int128 *a2, uint64_t a3, void *a4, uint64_t a5)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_100040504(__dst, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v10 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)__int128 __dst = v10;
  }

  uint64_t v11 = a4[1];
  __dst[4] = *a4;
  __dst[3] = a3;
  __dst[5] = v11;
  if (v11)
  {
    int v12 = (unint64_t *)(v11 + 8);
    do
      unint64_t v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }

  int v14 = *((char *)a2 + 23);
  if (v14 >= 0) {
    uint64_t v15 = (char *)a2;
  }
  else {
    uint64_t v15 = *(char **)a2;
  }
  if (v14 >= 0) {
    uint64_t v16 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    uint64_t v16 = *((void *)a2 + 1);
  }
  __dst[6] = sub_100118C90(v15, v16);
  __dst[7] = v17;
  __dst[8] = a5;
  return __dst;
}

void sub_100106304(_Unwind_Exception *a1)
{
}

AAByteStream *sub_100106328(uint64_t a1, char *a2, uint64_t a3, uint8_t **a4)
{
  if (a2[23] >= 0) {
    char v6 = a2;
  }
  else {
    char v6 = *(char **)a2;
  }
  *(void *)&__int128 v11 = AAS3DownloadStreamOpen(v6, 0LL, 0LL, 0);
  sub_1000E6458(&v14, &v11);
  sub_1000E652C(&v13, &v14);
  sub_1000E655C(&v13, *a4, 0x20uLL);
  sub_1000E6490(&v14, &v13, 0xFFFFFFFFFFFFFFFFLL, 0x4000000000000000uLL, 0, (uint64_t *)&v12);
  sub_1000F8800(&v14, (uint64_t *)&v13, &v12, &v11);
  sub_100014DF0(a1 + 40, &v11);
  uint64_t v7 = (std::__shared_weak_count *)*((void *)&v11 + 1);
  if (*((void *)&v11 + 1))
  {
    uint64_t v8 = (unint64_t *)(*((void *)&v11 + 1) + 8LL);
    do
      unint64_t v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

  sub_1000E645C(&v12);
  sub_1000E6530(&v13);
  return sub_1000E645C(&v14);
}

void sub_10010642C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  AAByteStream v4 = va_arg(va1, AAByteStream);
  va_copy(va2, va1);
  AEAContext v6 = va_arg(va2, AEAContext);
  sub_1000E645C((AAByteStream *)va);
  sub_1000E6530((AEAContext *)va1);
  sub_1000E645C((AAByteStream *)va2);
  _Unwind_Resume(a1);
}

void *sub_100106464(void *a1, char **a2, uint64_t a3, uint8_t **a4)
{
  uint64_t v7 = sub_100116E6C(a1);
  *(_OWORD *)(v7 + 3) = 0u;
  uint64_t v9 = (uint64_t)(v7 + 3);
  *(_OWORD *)(v7 + 5) = 0u;
  __int128 v10 = v7 + 5;
  *uint64_t v7 = off_100187A08;
  __int128 v11 = *a2;
  AAByteStream v12 = a4[1];
  v25[0] = *a4;
  v25[1] = v12;
  if (v12)
  {
    AEAContext v13 = (unint64_t *)(v12 + 8);
    do
      unint64_t v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }

  sub_100106328((uint64_t)a1, v11, v8, v25);
  if (v12)
  {
    uint64_t v15 = (unint64_t *)(v12 + 8);
    do
      unint64_t v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      (*(void (**)(uint8_t *))(*(void *)v12 + 16LL))(v12);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v12);
    }
  }

  uint64_t v17 = (__int128 *)*a2;
  uint64_t v23 = sub_1000E6818(*v10);
  uint64_t v22 = sub_1000E680C(*v10);
  sub_1001067F8(v17, (uint64_t *)&v23, a4, (uint64_t *)&v22, &v24);
  sub_100014DF0(v9, &v24);
  uint64_t v18 = (std::__shared_weak_count *)*((void *)&v24 + 1);
  if (*((void *)&v24 + 1))
  {
    uint64_t v19 = (unint64_t *)(*((void *)&v24 + 1) + 8LL);
    do
      unint64_t v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }

  return a1;
}

void sub_1001065A8(_Unwind_Exception *a1)
{
  __int128 v5 = *(std::__shared_weak_count **)(v1 + 16);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  _Unwind_Resume(a1);
}

ssize_t sub_1001065E8(uint64_t a1, uint64_t a2)
{
  return sub_1000E6824(*(void *)(a1 + 40), *(void **)a2, *(void *)(a2 + 16), *(void *)(a2 + 24));
}

void sub_100106610(void *a1)
{
  uint64_t v1 = sub_1001066AC(a1);
  operator delete(v1);
}

uint64_t sub_100106624()
{
  return 4294967251LL;
}

uint64_t sub_10010662C(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 24) + 24LL);
}

uint64_t sub_100106638()
{
  return 0LL;
}

uint64_t sub_100106640()
{
  return 4294967251LL;
}

void *sub_100106648(uint64_t a1, void *a2)
{
  return sub_100004E4C(a2, (uint64_t)"knox", 4LL);
}

double sub_10010665C@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  double result = v4[0];
  *a2 = *(_OWORD *)v4;
  return result;
}

uint64_t sub_100106698()
{
  return 4294967251LL;
}

uint64_t sub_1001066A0(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 24) + 48LL);
}

void *sub_1001066AC(void *a1)
{
  *a1 = off_100187A08;
  sub_1000114F0((uint64_t)(a1 + 5));
  sub_1000114F0((uint64_t)(a1 + 3));
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1001066F0(uint64_t a1@<X1>, void *a2@<X8>)
{
  AAByteStream v4 = operator new(0x50uLL);
  sub_100106750(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  sub_100018774((uint64_t)a2, v4 + 4, (uint64_t)(v4 + 3));
}

void sub_10010673C(_Unwind_Exception *a1)
{
}

void *sub_100106750(void *a1, uint64_t a2)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10017CA60;
  sub_100106798(a1 + 3, a2);
  return a1;
}

void sub_100106784(_Unwind_Exception *a1)
{
}

void *sub_100106798(void *a1, uint64_t a2)
{
  AAByteStream v4 = sub_100116E6C(a1);
  void *v4 = off_100187A08;
  *(_OWORD *)(v4 + 5) = 0u;
  __int128 v5 = v4 + 5;
  *(_OWORD *)(v4 + 3) = 0u;
  sub_100026A1C(v4 + 3, (uint64_t *)(a2 + 24));
  sub_100026A1C(v5, (uint64_t *)(a2 + 40));
  return a1;
}

void *sub_1001067F8@<X0>( __int128 *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X3>, uint64_t *a4@<X4>, void *a5@<X8>)
{
  __int128 v10 = operator new(0x60uLL);
  double result = sub_100106870(v10, a1, a2, a3, a4);
  *a5 = v10 + 3;
  a5[1] = v10;
  return result;
}

void sub_10010685C(_Unwind_Exception *a1)
{
}

void *sub_100106870(void *a1, __int128 *a2, uint64_t *a3, void *a4, uint64_t *a5)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_100187AE0;
  sub_10010624C(a1 + 3, a2, *a3, a4, *a5);
  return a1;
}

void sub_1001068AC(_Unwind_Exception *a1)
{
}

void sub_1001068C0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_100187AE0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1001068D0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_100187AE0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_1001068F0(uint64_t a1)
{
}

void sub_1001068FC(uint64_t a1)
{
}

void sub_100106938(void *a1@<X0>, char a2@<W1>, char **a3@<X8>)
{
  id v5 = a1;
  a3[1] = 0LL;
  a3[2] = 0LL;
  *a3 = 0LL;
  id v53 = v5;
  AEAContext v6 = (void *)objc_claimAutoreleasedReturnValue([v5 activeNode]);
  if (v6)
  {
    unsigned int v7 = 3;
    do
    {
      if ([v6 isCache])
      {
        uint64_t v9 = 2LL;
        uint64_t v10 = 1LL;
      }

      else
      {
        __int128 v11 = (void *)objc_claimAutoreleasedReturnValue([v6 parent]);
        if (v11) {
          uint64_t v10 = v7;
        }
        else {
          uint64_t v10 = 0LL;
        }

        uint64_t v9 = 0LL;
      }

      if (*a3 == a3[1] && (a2 & 1) == 0)
      {
        uint64_t v9 = 1LL;
        if ((_DWORD)v10)
        {
          if ((_DWORD)v10 != 3)
          {
            exception = __cxa_allocate_exception(0x40uLL);
            uint64_t error_code = make_error_code(150LL);
            void *exception = &off_100189E78;
            exception[1] = error_code;
            exception[2] = v52;
            *((_BYTE *)exception + 24) = 0;
            *((_BYTE *)exception + 4std::iostream::~basic_iostream(v2, v3 + 8) = 0;
            exception[7] = "Stack with cache as top image cannot be opened for writing.";
          }
        }
      }

      uint64_t v12 = objc_opt_class(&OBJC_CLASS___DiskImageGraphNodeNative, v8);
      if ((objc_opt_isKindOfClass(v6, v12) & 1) != 0)
      {
        id v13 = (id)objc_claimAutoreleasedReturnValue([v6 filePath]);
        id v14 = objc_claimAutoreleasedReturnValue([v13 path]);
        std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v54 = (char *)[v14 UTF8String];
        sub_1001073E8(&v55, &v54);
        else {
          std::string __dst = v55;
        }
        uint64_t v26 = operator new(0x40uLL);
        __p = 0LL;
        int64x2_t v58 = 0uLL;
        diskimage_uio::stack_image_node::stack_image_node(v26, v10, v9, &__dst, &__p, 0LL);
        if (v58.i8[15] < 0) {
          operator delete(__p);
        }
        unint64_t v28 = a3[1];
        unint64_t v27 = (unint64_t)a3[2];
        if ((unint64_t)v28 >= v27)
        {
          uint64_t v30 = (v28 - *a3) >> 3;
          uint64_t v31 = v27 - (void)*a3;
          uint64_t v32 = v31 >> 2;
          else {
            unint64_t v33 = v32;
          }
          __int128 v60 = a3 + 2;
          if (v33) {
            uint64_t v34 = (char *)sub_10001848C((uint64_t)(a3 + 2), v33);
          }
          else {
            uint64_t v34 = 0LL;
          }
          unint64_t v35 = &v34[8 * v30];
          std::string v36 = &v34[8 * v33];
          uint64_t v59 = v36;
          *(void *)unint64_t v35 = v26;
          size_t v29 = v35 + 8;
          v58.i64[1] = (uint64_t)(v35 + 8);
          int v38 = *a3;
          uint64_t v37 = a3[1];
          if (v37 == *a3)
          {
            int64x2_t v40 = vdupq_n_s64((unint64_t)v37);
          }

          else
          {
            do
            {
              uint64_t v39 = *((void *)v37 - 1);
              v37 -= 8;
              *(void *)uint64_t v37 = 0LL;
              *((void *)v35 - sub_1000F1940(&v11, 1) = v39;
              v35 -= 8;
            }

            while (v37 != v38);
            int64x2_t v40 = *(int64x2_t *)a3;
            size_t v29 = (char *)v58.i64[1];
            std::string v36 = v59;
          }

          *a3 = v35;
          a3[1] = v29;
          int64x2_t v58 = v40;
          size_t v41 = a3[2];
          a3[2] = v36;
          uint64_t v59 = v41;
          __p = (void *)v40.i64[0];
          sub_100048A6C((uint64_t)&__p);
        }

        else
        {
          *(void *)unint64_t v28 = v26;
          size_t v29 = v28 + 8;
        }

        a3[1] = v29;
      }

      else
      {
        id v13 = v6;
        id v15 = objc_claimAutoreleasedReturnValue([v13 pluginName]);
        sub_100004CB0(&__dst, (char *)[v15 UTF8String]);

        unint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v13 pluginParams]);
        uint64_t v17 = operator new(0x40uLL);
        sub_100004CB0(&__p, "");
        diskimage_uio::stack_image_node::stack_image_node(v17, v10, v9, &__p, &__dst, v16);
        if (v58.i8[15] < 0) {
          operator delete(__p);
        }
        uint64_t v19 = a3[1];
        unint64_t v18 = (unint64_t)a3[2];
        if ((unint64_t)v19 >= v18)
        {
          uint64_t v21 = (v19 - *a3) >> 3;
          uint64_t v22 = v18 - (void)*a3;
          uint64_t v23 = v22 >> 2;
          else {
            unint64_t v24 = v23;
          }
          __int128 v60 = a3 + 2;
          if (v24) {
            __int16 v25 = (char *)sub_10001848C((uint64_t)(a3 + 2), v24);
          }
          else {
            __int16 v25 = 0LL;
          }
          __int128 v42 = &v25[8 * v21];
          uint64_t v43 = &v25[8 * v24];
          uint64_t v59 = v43;
          *(void *)__int128 v42 = v17;
          unint64_t v20 = v42 + 8;
          v58.i64[1] = (uint64_t)(v42 + 8);
          unint64_t v45 = *a3;
          unint64_t v44 = a3[1];
          if (v44 == *a3)
          {
            int64x2_t v47 = vdupq_n_s64((unint64_t)v44);
          }

          else
          {
            do
            {
              uint64_t v46 = *((void *)v44 - 1);
              v44 -= 8;
              *(void *)unint64_t v44 = 0LL;
              *((void *)v42 - sub_1000F1940(&v11, 1) = v46;
              v42 -= 8;
            }

            while (v44 != v45);
            int64x2_t v47 = *(int64x2_t *)a3;
            unint64_t v20 = (char *)v58.i64[1];
            uint64_t v43 = v59;
          }

          *a3 = v42;
          a3[1] = v20;
          int64x2_t v58 = v47;
          uint64_t v48 = a3[2];
          a3[2] = v43;
          uint64_t v59 = v48;
          __p = (void *)v47.i64[0];
          sub_100048A6C((uint64_t)&__p);
        }

        else
        {
          *(void *)uint64_t v19 = v17;
          unint64_t v20 = v19 + 8;
        }

        a3[1] = v20;
      }

      uint64_t v49 = objc_claimAutoreleasedReturnValue([v6 parent]);
      unsigned int v7 = 2;
      AEAContext v6 = (void *)v49;
    }

    while (v49);
  }
}

void sub_100106DAC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23, void *a24, uint64_t a25, int a26, __int16 a27, char a28, char a29)
{
  _Unwind_Resume(a1);
}

void sub_100106ED4(uint64_t a1@<X0>, uint64_t *a2@<X1>, char a3@<W2>, uint64_t a4@<X8>)
{
  unsigned int v7 = -[NSFileHandle initWithFileDescriptor:closeOnDealloc:]( objc_alloc(&OBJC_CLASS___NSFileHandle),  "initWithFileDescriptor:closeOnDealloc:",  a1,  0LL);
  id v39 = 0LL;
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(-[NSFileHandle readDataUpToLength:error:](v7, "readDataUpToLength:error:", 0x100000LL, &v39));
  id v9 = v39;
  if (!v8)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    uint64_t error_code = make_error_code(154LL);
    void *exception = &off_100189E78;
    exception[1] = error_code;
    exception[2] = v20;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 4std::iostream::~basic_iostream(v2, v3 + 8) = 0;
    exception[7] = "Failed to read from fd.";
  }

  id v38 = 0LL;
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSPropertyListSerialization propertyListWithData:options:format:error:]( &OBJC_CLASS___NSPropertyListSerialization,  "propertyListWithData:options:format:error:",  v8,  0LL,  v40,  &v38));
  id v11 = v38;

  if (v10 && (uint64_t v13 = objc_opt_class(&OBJC_CLASS___NSDictionary, v12), (objc_opt_isKindOfClass(v10, v13) & 1) != 0))
  {
    if (*((char *)a2 + 23) < 0)
    {
      if (!a2[1]) {
        goto LABEL_14;
      }
      a2 = (uint64_t *)*a2;
    }

    else if (!*((_BYTE *)a2 + 23))
    {
LABEL_14:
      uint64_t v21 = __cxa_allocate_exception(0x40uLL);
      uint64_t v22 = std::generic_category();
      *uint64_t v21 = &off_100189E78;
      v21[1] = 22LL;
      void v21[2] = v22;
      *((_BYTE *)v21 + 24) = 0;
      *((_BYTE *)v21 + 4std::iostream::~basic_iostream(v2, v3 + 8) = 0;
      v21[7] = "Cannot initialize pstack disk image without path.";
    }

    id v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithCString:encoding:]( &OBJC_CLASS___NSString,  "stringWithCString:encoding:",  a2,  +[NSString defaultCStringEncoding](&OBJC_CLASS___NSString, "defaultCStringEncoding")));
    id v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:](&OBJC_CLASS___NSURL, "fileURLWithPath:", v14));

    id v37 = v11;
    unint64_t v16 = -[DiskImageGraph initWithData:pstackURL:imported:error:]( objc_alloc(&OBJC_CLASS___DiskImageGraph),  "initWithData:pstackURL:imported:error:",  v10,  v15,  0LL,  &v37);
    id v17 = v37;

    if (!v16)
    {
      int v23 = *__error();
      if (sub_1000B8654())
      {
        uint64_t v36 = 0LL;
        uint64_t v24 = sub_1000B85DC();
        __int16 v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);
        BOOL v26 = os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
        unint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([v17 description]);
        if (v26) {
          uint64_t v28 = 3LL;
        }
        else {
          uint64_t v28 = 2LL;
        }
        *(_DWORD *)buf = 68158210;
        int v42 = 127;
        __int16 v43 = 2080;
        unint64_t v44 = "std::vector<diskimage_uio::stack_image_node_ptr_t> create_stack_vector_from_single_fd(int, const std::file"
              "system::path &, BOOL)";
        __int16 v45 = 2112;
        uint64_t v46 = v27;
        size_t v29 = (char *)_os_log_send_and_compose_impl( v28,  &v36,  0LL,  0LL,  &_mh_execute_header,  v25,  16LL,  "%.*s: Failed to create graph from plist: %@.",  buf,  28);

        if (v29)
        {
          fprintf(__stderrp, "%s\n", v29);
          free(v29);
        }
      }

      else
      {
        uint64_t v30 = sub_1000B85DC();
        uint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue(v30);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
        {
          uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue([v17 description]);
          *(_DWORD *)buf = 68158210;
          int v42 = 127;
          __int16 v43 = 2080;
          unint64_t v44 = "std::vector<diskimage_uio::stack_image_node_ptr_t> create_stack_vector_from_single_fd(int, const std::fi"
                "lesystem::path &, BOOL)";
          __int16 v45 = 2112;
          uint64_t v46 = v32;
          _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_ERROR,  "%.*s: Failed to create graph from plist: %@.",  buf,  0x1Cu);
        }
      }

      *__error() = v23;
      unint64_t v33 = __cxa_allocate_exception(0x40uLL);
      uint64_t v34 = make_error_code(161LL);
      void *v33 = &off_100189E78;
      v33[1] = v34;
      void v33[2] = v35;
      *((_BYTE *)v33 + 24) = 0;
      *((_BYTE *)v33 + 4std::iostream::~basic_iostream(v2, v3 + 8) = 0;
      v33[7] = "Failed to create graph from plist.";
    }

    sub_100106938(v16, a3, (char **)a4);

    id v11 = v17;
  }

  else
  {
    *(void *)a4 = 0LL;
    *(void *)(a4 + std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
    *(void *)(a4 + 16) = 0LL;
  }
}

void sub_10010733C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

std::string *sub_1001073E8(std::string *this, char **a2)
{
  *(_OWORD *)&this->__r_.__value_.__l.__data_ = 0uLL;
  this->__r_.__value_.__l.__cap_ = 0LL;
  uint64_t v3 = *a2;
  AAByteStream v4 = v3 - 1;
  while (*++v4)
    ;
  sub_100058CF4(this, v3, v4);
  return this;
}

void sub_100107428(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100107444(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = a3;
  unsigned int v4 = sub_100090E24(a3, a2);
  if ((v4 & 0x80000000) != 0)
  {
    unsigned int v6 = v4;
    exception = __cxa_allocate_exception(0x40uLL);
    uint64_t v8 = (void *)sub_100004870((uint64_t)exception, (uint64_t)"Failed to subscribe to the plugin's IO ring", v6);
  }

  *(_DWORD *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = v4;
  return a1;
}

uint64_t sub_1001074A8(uint64_t a1)
{
  return a1;
}

uint64_t sub_1001074E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  LODWORD(v18[0]) = io_rings_get_max_version(0LL, 0);
  HIDWORD(v18[0]) = 48;
  v18[1] = 0LL;
  void v18[2] = sub_100107880;
  uint64_t v19 = 0LL;
  uint64_t v20 = a3;
  uint64_t v21 = a4;
  uint64_t v17 = 0LL;
  unsigned int v8 = io_rings_setup(0x100u, (uint64_t)v18, &v17);
  if (v8)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    id v14 = (void *)sub_100004870((uint64_t)exception, (uint64_t)"Failed to setup the plugin's IO ring", v8);
  }

  v18[0] = &off_100187D50;
  uint64_t v19 = v18;
  *(void *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = v17;
  sub_100108050(a1 + 16, (uint64_t)v18);
  id v9 = v19;
  if (v19 == v18)
  {
    uint64_t v10 = 4LL;
    id v9 = v18;
  }

  else
  {
    if (!v19) {
      goto LABEL_7;
    }
    uint64_t v10 = 5LL;
  }

  (*(void (**)(void))(*v9 + 8 * v10))();
LABEL_7:
  *(void *)(a1 + 4std::iostream::~basic_iostream(v2, v3 + 8) = *(void *)(*(void *)(a1 + 8) + 24LL);
  uint64_t v11 = (*(uint64_t (**)(uint64_t))(a2 + 56))(a2);
  if (!v11)
  {
    id v15 = __cxa_allocate_exception(0x40uLL);
    *id v15 = &off_100189E78;
    unint64_t v16 = std::generic_category();
    v15[1] = 4294967284LL;
    v15[2] = v16;
    *((_BYTE *)v15 + 24) = 0;
    *((_BYTE *)v15 + 4std::iostream::~basic_iostream(v2, v3 + 8) = 0;
    v15[7] = "Cannot get subscriber from plugin";
  }

  sub_100107444(a1 + 56, v11, *(void *)(a1 + 48));
  *(void *)(a1 + 7sub_1000F1278(&v6, 2) = 0LL;
  *(void *)(a1 + 8sub_1000F1278((int *)&v3, 0) = 0LL;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = 1018212795LL;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + sub_1000114F0(v49 + 112) = 0u;
  *(void *)(a1 + 12std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
  *(void *)(a1 + 136) = 850045863LL;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 16sub_1000F1278((int *)&v3, 0) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(void *)(a1 + 19sub_1000F1278(&v6, 2) = 0LL;
  return a1;
}

void sub_1001076C4(_Unwind_Exception *exception_object)
{
}

uint64_t sub_1001076E4(uint64_t a1)
{
  return a1;
}

double sub_100107740(uint64_t a1)
{
  unsigned int v1 = atomic_load((unsigned int *)(a1 + 76));
  uint64_t v2 = (unsigned int *)(a1 + 72);
  unsigned int v3 = atomic_load((unsigned int *)(a1 + 72));
  if (v3 - v1 < *(_DWORD *)(*(void *)(a1 + 8) + 8LL))
  {
    do
    {
      while (1)
      {
        unsigned int v4 = __ldaxr(v2);
        if (v4 == v3) {
          break;
        }
        __clrex();
        unsigned int v5 = atomic_load((unsigned int *)(a1 + 76));
        unsigned int v6 = v4 - v5;
        unsigned int v3 = v4;
        if (v6 >= *(_DWORD *)(*(void *)(a1 + 8) + 8LL)) {
          return result;
        }
      }
    }

    while (__stlxr(v3 + 1, v2));
    return io_rings_sqe_allocate(*(void *)(a1 + 48));
  }

  return result;
}

void sub_1001077C4(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t cqe = io_rings_get_cqe(*(void *)(a1 + 48));
  if ((v5 & 0x100000000LL) != 0)
  {
    uint64_t v7 = cqe;
    uint64_t v8 = v5;
    id v9 = (unsigned int *)(a1 + 76);
    do
      unsigned int v10 = __ldaxr(v9);
    while (__stlxr(v10 + 1, v9));
    if (atomic_load((unint64_t *)(a1 + 80)))
    {
      unsigned int v12 = atomic_load((unsigned int *)(a1 + 72));
      if (v10 + 1 == v12)
      {
        std::mutex::lock((std::mutex *)(a1 + 136));
        std::condition_variable::notify_all((std::condition_variable *)(a1 + 88));
        std::mutex::unlock((std::mutex *)(a1 + 136));
      }
    }

    *(void *)a2 = v7;
    *(void *)(a2 + std::iostream::~basic_iostream(v2, v3 + 8) = v8;
    char v6 = 1;
  }

  else
  {
    char v6 = 0;
    *(_BYTE *)a2 = 0;
  }

  *(_BYTE *)(a2 + 16) = v6;
}

uint64_t sub_100107874(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(a2 + std::iostream::~basic_iostream(v2, v3 + 8) = *(_DWORD *)(result + 64);
  return result;
}

uint64_t sub_100107880(uint64_t a1)
{
  uint64_t overruns = io_rings_cq_get_overruns(a1);
  *(void *)&__int128 v4 = "di_plugin_cq_event_callback(io_uhandle_t, void *, enum io_rings_event_type_t, struct io_rings_event_type_data_t *)";
  *((void *)&v4 + sub_1000F1940(&v11, 1) = 27LL;
  int v5 = 16;
  sub_100107940(v6, &v4);
  std::ostream::operator<<(&v7, overruns);
  sub_100004E4C(&v7, (uint64_t)" overrun events occurred in the plugin's ring!", 46LL);
  std::ostream::~ostream(&v7, off_100187C00);
  sub_100107AA4((uint64_t)v6);
  std::ios::~ios(&v8);
  return io_rings_cq_clear_overruns(a1);
}

void sub_10010792C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void *sub_100107940(void *a1, __int128 *a2)
{
  unsigned int v3 = (std::ios_base *)(a1 + 46);
  sub_100107A28((uint64_t)a1, a2);
  *a1 = off_100187B38;
  a1[45] = &off_100187C38;
  a1[46] = &off_100187C60;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12std::iostream::~basic_iostream(v2, v3 + 8) = -1;
  *a1 = off_100187B38;
  a1[45] = off_100187BC0;
  a1[46] = off_100187BE8;
  return a1;
}

void sub_1001079C4(_Unwind_Exception *a1)
{
}

uint64_t sub_1001079E8(uint64_t a1)
{
  return a1;
}

uint64_t sub_100107A28(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_100187CD0;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_100107A90(_Unwind_Exception *a1)
{
}

uint64_t sub_100107AA4(uint64_t a1)
{
  *(void *)a1 = off_100187CD0;
  sub_100107D1C(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

void sub_100107B40(char *a1)
{
}

uint64_t sub_100107B84(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_100107BB8(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

uint64_t sub_100107C04(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100187C00);
  sub_100107AA4(v2);
  return std::ios::~ios(a1 + 8);
}

void sub_100107C3C(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100187C00);
  sub_100107AA4((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

uint64_t sub_100107C7C(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100187C00);
  sub_100107AA4(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_100107CBC(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100187C00);
  sub_100107AA4((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

void sub_100107D08(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100107AA4(a1);
  operator delete(v1);
}

uint64_t sub_100107D1C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_100107E6C((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_100107E44( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

int *sub_100107E6C(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      unsigned int v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 57LL;
    __int16 v25 = 2082;
    BOOL v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      unsigned int v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        unint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 57LL;
      __int16 v25 = 2082;
      BOOL v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  double result = __error();
  *double result = v5;
  return result;
}

uint64_t sub_100108050(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24LL))(*v3, a1);
      return a1;
    }

    *(void *)(a1 + 24) = v4;
  }

  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }

  *uint64_t v3 = 0LL;
  return a1;
}

uint64_t *sub_1001080B4(uint64_t *a1)
{
  uint64_t v2 = (uint64_t *)a1[4];
  if (v2 == a1 + 1)
  {
    uint64_t v3 = 4LL;
    uint64_t v2 = a1 + 1;
    goto LABEL_5;
  }

  if (v2)
  {
    uint64_t v3 = 5LL;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }

  return a1;
}

uint64_t *sub_10010810C(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  *double result = a2;
  if (v2)
  {
    uint64_t v4 = v2;
    uint64_t v3 = result[4];
    if (!v3) {
      sub_100016D94();
    }
    return (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v3 + 48LL))(v3, &v4);
  }

  return result;
}

void *sub_100108160()
{
  double result = operator new(0x10uLL);
  *double result = &off_100187D50;
  return result;
}

void sub_100108184(uint64_t a1, void *a2)
{
  *a2 = &off_100187D50;
}

uint64_t sub_10010819C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)a2 + 32LL))();
}

uint64_t sub_1001081A8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1001081E4()
{
}

uint64_t sub_1001081F0(uint64_t a1, uint64_t a2)
{
  size_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v3 + v4 <= *(void *)(a1 + 72))
  {
    memcpy((void *)(*(void *)(a1 + 64) + v4), *(const void **)a2, v3);
    return *(unsigned int *)(a2 + 16);
  }

  else
  {
    *(void *)&__int128 v6 = "int Ram::write(const sg_entry &)";
    *((void *)&v6 + sub_1000F1940(&v11, 1) = 14LL;
    int v7 = 16;
    sub_10010830C(v8, &v6);
    sub_100004E4C(&v9, (uint64_t)"Trying to write @ ", 18LL);
    std::ostream::operator<<(&v9, *(void *)(a2 + 24));
    sub_100004E4C(&v9, (uint64_t)" ", 1LL);
    std::ostream::operator<<(&v9, *(void *)(a2 + 16));
    sub_100004E4C(&v9, (uint64_t)"bytes, which is after end of ramdisk", 36LL);
    std::ostream::~ostream(&v9, off_100187F88);
    sub_1001088C0((uint64_t)v8);
    std::ios::~ios(&v10);
    return 4294967274LL;
  }

void sub_1001082F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void *sub_10010830C(void *a1, __int128 *a2)
{
  size_t v3 = (std::ios_base *)(a1 + 46);
  sub_100109290((uint64_t)a1, a2);
  *a1 = off_100187EC0;
  a1[45] = &off_100187FC0;
  a1[46] = &off_100187FE8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12std::iostream::~basic_iostream(v2, v3 + 8) = -1;
  *a1 = off_100187EC0;
  a1[45] = off_100187F48;
  a1[46] = off_100187F70;
  return a1;
}

void sub_100108390(_Unwind_Exception *a1)
{
}

uint64_t sub_1001083B4(uint64_t a1)
{
  return a1;
}

uint64_t sub_1001083F4(uint64_t a1, uint64_t a2)
{
  size_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v3 + v4 <= *(void *)(a1 + 72))
  {
    memcpy(*(void **)a2, (const void *)(*(void *)(a1 + 64) + v4), v3);
    return *(unsigned int *)(a2 + 16);
  }

  else
  {
    *(void *)&__int128 v6 = "int Ram::read(const sg_entry &)";
    *((void *)&v6 + sub_1000F1940(&v11, 1) = 13LL;
    int v7 = 16;
    sub_100108514(v8, &v6);
    sub_100004E4C(&v9, (uint64_t)"Trying to read @ ", 17LL);
    std::ostream::operator<<(&v9, *(void *)(a2 + 24));
    sub_100004E4C(&v9, (uint64_t)" ", 1LL);
    std::ostream::operator<<(&v9, *(void *)(a2 + 16));
    sub_100004E4C(&v9, (uint64_t)"bytes, which is after end of ramdisk", 36LL);
    std::ostream::~ostream(&v9, off_1001881A8);
    sub_100108E6C((uint64_t)v8);
    std::ios::~ios(&v10);
    return 4294967274LL;
  }

void sub_1001084F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void *sub_100108514(void *a1, __int128 *a2)
{
  size_t v3 = (std::ios_base *)(a1 + 46);
  sub_10010930C((uint64_t)a1, a2);
  *a1 = off_1001880E0;
  a1[45] = &off_1001881E0;
  a1[46] = &off_100188208;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12std::iostream::~basic_iostream(v2, v3 + 8) = -1;
  *a1 = off_1001880E0;
  a1[45] = off_100188168;
  a1[46] = off_100188190;
  return a1;
}

void sub_100108598(_Unwind_Exception *a1)
{
}

uint64_t sub_1001085BC(uint64_t a1)
{
  return a1;
}

void sub_100108600(void *a1)
{
  uint64_t v1 = sub_100109254(a1);
  operator delete(v1);
}

uint64_t sub_100108614()
{
  return 0LL;
}

uint64_t sub_10010861C(void *a1, unint64_t a2, uint64_t a3)
{
  if (a3 == -1) {
    return 0LL;
  }
  unint64_t v3 = a1[12];
  unint64_t v4 = (a2 + v3 - 1) / v3 * v3;
  if (a2 > v4 || v4 >= a3 + a2) {
    return 0LL;
  }
  unint64_t v6 = a2 - v4 + a3;
  size_t v7 = v6 / v3 * v3;
  if (v6 == v6 % v3) {
    return 0LL;
  }
  uint64_t v8 = 4294967262LL;
  if (__CFADD__(v4, v7)) {
    return v8;
  }
  unint64_t v10 = a1[9];
  if (v4 > v10 || v7 + v4 > v10) {
    return v8;
  }
  return madvise((void *)(a1[8] + v4), v7, 5);
}

uint64_t sub_1001086A0()
{
  return 1LL;
}

uint64_t sub_1001086A8(uint64_t a1)
{
  return *(void *)(a1 + 72);
}

uint64_t sub_1001086B0()
{
  return 1LL;
}

uint64_t sub_1001086B8(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 72) < a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0LL;
  *(void *)(a1 + 7sub_1000F1278(&v6, 2) = a2;
  return result;
}

void *sub_1001086DC(uint64_t a1, void *a2)
{
  return sub_100004E4C(a2, (uint64_t)"ram", 3LL);
}

uint64_t sub_1001086F0(uint64_t a1)
{
  return *(void *)(a1 + 80);
}

uint64_t sub_1001086FC(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100187F88);
  sub_1001088C0(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_100108734(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100187F88);
  sub_1001088C0(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_100108774(char *a1)
{
}

uint64_t sub_1001087B8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1001087EC(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_100108838(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100187F88);
  sub_1001088C0((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_100108878(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100187F88);
  sub_1001088C0((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1001088C0(uint64_t a1)
{
  *(void *)a1 = off_100188058;
  sub_10010895C(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_10010895C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_100108AC4((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_100108A84( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100108AB0(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1001088C0(a1);
  operator delete(v1);
}

int *sub_100108AC4(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      unint64_t v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 30LL;
    __int16 v25 = 2082;
    BOOL v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      unsigned int v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        unint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 30LL;
      __int16 v25 = 2082;
      BOOL v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_100108CA8(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_1001881A8);
  sub_100108E6C(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_100108CE0(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001881A8);
  sub_100108E6C(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_100108D20(char *a1)
{
}

uint64_t sub_100108D64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_100108D98(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_100108DE4(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_1001881A8);
  sub_100108E6C((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_100108E24(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001881A8);
  sub_100108E6C((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_100108E6C(uint64_t a1)
{
  *(void *)a1 = off_100188278;
  sub_100108F08(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_100108F08(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_100109070((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_100109030( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10010905C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100108E6C(a1);
  operator delete(v1);
}

int *sub_100109070(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      unint64_t v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 42LL;
    __int16 v25 = 2082;
    BOOL v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      unsigned int v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        unint64_t v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 42LL;
      __int16 v25 = 2082;
      BOOL v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

void *sub_100109254(void *a1)
{
  *a1 = off_100187DE0;
  sub_100016DE0(a1 + 3);
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

uint64_t sub_100109290(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_100188058;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1001092F8(_Unwind_Exception *a1)
{
}

uint64_t sub_10010930C(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_100188278;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_100109374(_Unwind_Exception *a1)
{
}

uint64_t sub_100109388(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void sub_10010B990(_Unwind_Exception *a1)
{
}

uint64_t sub_10010B9BC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 4sub_1000F1278((int *)&v3, 0) = *(void *)(a2 + 40);
  *(void *)(a2 + 4sub_1000F1278((int *)&v3, 0) = 0LL;
  return result;
}

void sub_10010B9CC(uint64_t a1)
{
}

void sub_10010B9D4(void *a1, uint64_t a2, void *a3, _BYTE *a4)
{
  id v6 = a3;
  uint64_t v8 = objc_opt_class(&OBJC_CLASS___DiskImageGraphNodeNative, v7);
  if ((objc_opt_isKindOfClass(v6, v8) & 1) != 0)
  {
    id v9 = v6;
    unint64_t v10 = (void *)a1[4];
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v9 filePath]);
    unsigned int v12 = (void *)objc_claimAutoreleasedReturnValue([v11 lastPathComponent]);
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v10 URLByAppendingPathComponent:v12]);

    os_log_type_t v14 = (void *)a1[5];
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v9 filePath]);
    uint64_t v16 = *(void *)(a1[6] + 8LL);
    obuint64_t j = *(id *)(v16 + 40);
    LOBYTE(v14) = [v14 copyItemAtURL:v15 toURL:v13 error:&obj];
    objc_storeStrong((id *)(v16 + 40), obj);

    else {
      *a4 = 1;
    }
  }

  else
  {
    *a4 = 1;
    uint64_t v17 = *(void *)(a1[6] + 8LL);
    id v20 = *(id *)(v17 + 40);
    +[DIError failWithPOSIXCode:verboseInfo:error:]( &OBJC_CLASS___DIError,  "failWithPOSIXCode:verboseInfo:error:",  45LL,  @"Clone of plugin nodes is not supported.",  &v20);
    id v18 = v20;
    id v9 = *(id *)(v17 + 40);
    *(void *)(v17 + 4sub_1000F1278((int *)&v3, 0) = v18;
  }
}

id sub_10010BB3C(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) removeItemAtURL:a2 error:0];
}

void sub_10010C080( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_10010C098(uint64_t a1, void *a2, uint64_t a3, _BYTE *a4)
{
  uint64_t v6 = *(unsigned __int8 *)(a1 + 56);
  uint64_t v7 = *(void **)(a1 + 32);
  id v8 = a2;
  id v9 = (void *)objc_claimAutoreleasedReturnValue([v7 URLByDeletingLastPathComponent]);
  uint64_t v10 = *(void *)(*(void *)(a1 + 48) + 8LL);
  obuint64_t j = *(id *)(v10 + 40);
  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue( +[DiskImageGraphNode GraphNodeWithDictionary:updateChangesToDict:workDir:error:]( &OBJC_CLASS___DiskImageGraphNode,  "GraphNodeWithDictionary:updateChangesToDict:workDir:error:",  v8,  v6,  v9,  &obj));

  objc_storeStrong((id *)(v10 + 40), obj);
  if (v11)
  {
    unsigned int v12 = *(void **)(a1 + 40);
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v11 UUID]);
    os_log_type_t v14 = (void *)objc_claimAutoreleasedReturnValue([v13 UUIDString]);
    [v12 setObject:v11 forKey:v14];
  }

  else
  {
    *a4 = 1;
  }
}

void sub_10010C274( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10010C28C(uint64_t a1, uint64_t a2, void *a3, _BYTE *a4)
{
  id v15 = a3;
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v15 parentUUID]);

  if (v6)
  {
    uint64_t v7 = *(void **)(a1 + 32);
    id v8 = (void *)objc_claimAutoreleasedReturnValue([v15 parentUUID]);
    id v9 = (void *)objc_claimAutoreleasedReturnValue([v8 UUIDString]);
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v7 objectForKey:v9]);

    if (v10)
    {
      [v15 setParent:v10];
      uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v15 parent]);
      unsigned int v12 = (void *)objc_claimAutoreleasedReturnValue([v11 children]);
      [v12 addObject:v15];
    }

    else
    {
      *a4 = 1;
      uint64_t v13 = objc_claimAutoreleasedReturnValue( +[DIError errorWithPOSIXCode:verboseInfo:]( &OBJC_CLASS___DIError,  "errorWithPOSIXCode:verboseInfo:",  22LL,  @"Missing parent node in graph."));
      uint64_t v14 = *(void *)(*(void *)(a1 + 40) + 8LL);
      uint64_t v11 = *(void **)(v14 + 40);
      *(void *)(v14 + 4sub_1000F1278((int *)&v3, 0) = v13;
    }
  }
}

void sub_10010C76C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

id sub_10010C784(uint64_t a1, uint64_t a2, void *a3)
{
  char v4 = (void *)objc_claimAutoreleasedReturnValue([a3 tag]);
  id v5 = [v4 isEqualToString:*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)];

  return v5;
}

uint64_t sub_10010CEA8(uint64_t a1, _DWORD *a2)
{
  *(_DWORD *)a1 = 1919118949;
  int v6 = 1919118949;
  sub_10007EF00((uint64_t)"sig1_t", 1919118949, &v6, 1LL);
  *(_DWORD *)(a1 + 4) = 1634952291;
  int v6 = 1634952291;
  sub_10007EF00((uint64_t)"sig2_t", 1634952291, &v6, 1LL);
  *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = 2;
  int v6 = 2;
  sub_10007EF00((uint64_t)"version_t", 2, &v6, 1LL);
  *(_DWORD *)(a1 + 1sub_1000F1278(&v6, 2) = 16;
  int v6 = 16;
  sub_10007EF00((uint64_t)"iv_size_t", 16, &v6, 1LL);
  *(_DWORD *)(a1 + 16) = 5;
  int v6 = 5;
  sub_10007EF00((uint64_t)"encryption_mode", 5, &v6, 1LL);
  *(_DWORD *)(a1 + 2sub_1000F1278((int *)&v3, 0) = -2147483647;
  int v6 = -2147483647;
  sub_10007EF00((uint64_t)"algorithm_type", -2147483647, &v6, 1LL);
  *(_DWORD *)(a1 + 24) = *a2;
  *(_DWORD *)(a1 + 2_Block_object_dispose(va, 8) = 91;
  int v6 = 91;
  sub_10007EF00((uint64_t)"prng_algorithm_type", 91, &v6, 1LL);
  *(_DWORD *)(a1 + sub_1000114F0(v6 - 32) = 160;
  int v6 = 160;
  sub_10007EF00((uint64_t)"prng_key_bits_size_t", 160, &v6, 1LL);
  *(_DWORD *)(a1 + 5sub_1000F1278(&v6, 2) = 512;
  *(_OWORD *)(a1 + 56) = xmmword_100142080;
  *(_DWORD *)(a1 + 7sub_1000F1278(&v6, 2) = 0;
  *(void *)(a1 + 36) = sub_100118D8C();
  *(void *)(a1 + 44) = v4;
  return a1;
}

uint64_t sub_10010D030(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + sub_1000114F0(v6 - 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 5sub_1000F1278(&v6, 2) = 0LL;
  *(void *)(a1 + 6_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 6sub_1000F1278((int *)&v3, 0) = 0LL;
  unint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40LL))(a2);
  if (v4 >= 0xC
    && (sub_100033014(a2, (uint64_t)v25, 12LL, v4 - 12) & 0x80000000) == 0
    && v25[0] == 0x1000000
    && v25[1] == 1634952291
    && v25[2] == 1919118949)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    uint64_t v24 = (void *)sub_100004870( (uint64_t)exception,  (uint64_t)"The image is encrypted with obsolete encoding version 1",  0xA0u);
  }

  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 40LL))(a2) <= 0x4B)
  {
    id v18 = __cxa_allocate_exception(0x20uLL);
    uint64_t v19 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40LL))(a2);
    *id v18 = &off_100181CC0;
    v18[1] = "crypto";
    void v18[2] = 76LL;
    void v18[3] = v19;
  }

  id v5 = (char *)operator new[](0x4CuLL);
  *(_OWORD *)(v5 + 6sub_1000F1278((int *)&v3, 0) = 0u;
  *((_OWORD *)v5 + sub_1000F1278(&v6, 2) = 0u;
  *((_OWORD *)v5 + 3) = 0u;
  *(_OWORD *)id v5 = 0u;
  *((_OWORD *)v5 + sub_1000F1940(&v11, 1) = 0u;
  unsigned int v6 = sub_100033014(a2, (uint64_t)v5, 76LL, 0LL);
  if ((v6 & 0x80000000) != 0)
  {
    id v20 = __cxa_allocate_exception(0x40uLL);
    *id v20 = &off_100189E78;
    __int16 v21 = std::generic_category();
    v20[1] = v6;
    uint64_t v22 = "Crypto: can't read crypto header";
    goto LABEL_13;
  }

  int v7 = *(_DWORD *)v5;
  LODWORD(v26) = 1919118949;
  sub_10007EF00((uint64_t)"sig1_t", v7, &v26, 1LL);
  *(_DWORD *)a1 = 1919118949;
  int v8 = *((_DWORD *)v5 + 1);
  LODWORD(v26) = 1634952291;
  sub_10007EF00((uint64_t)"sig2_t", v8, &v26, 1LL);
  *(_DWORD *)(a1 + 4) = 1634952291;
  int v9 = bswap32(*((_DWORD *)v5 + 2));
  LODWORD(v26) = 2;
  sub_10007EF00((uint64_t)"version_t", v9, &v26, 1LL);
  *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = v9;
  int v10 = bswap32(*((_DWORD *)v5 + 3));
  LODWORD(v26) = 16;
  sub_10007EF00((uint64_t)"iv_size_t", v10, &v26, 1LL);
  *(_DWORD *)(a1 + 1sub_1000F1278(&v6, 2) = v10;
  int v11 = bswap32(*((_DWORD *)v5 + 4));
  LODWORD(v26) = 5;
  sub_10007EF00((uint64_t)"encryption_mode", v11, &v26, 1LL);
  *(_DWORD *)(a1 + 16) = v11;
  int v12 = bswap32(*((_DWORD *)v5 + 5));
  LODWORD(v26) = -2147483647;
  sub_10007EF00((uint64_t)"algorithm_type", v12, &v26, 1LL);
  *(_DWORD *)(a1 + 2sub_1000F1278((int *)&v3, 0) = v12;
  int v13 = bswap32(*((_DWORD *)v5 + 6));
  uint64_t v26 = 0x10000000080LL;
  sub_10007EF00((uint64_t)"encryption_key_bits_size_t", v13, &v26, 2LL);
  *(_DWORD *)(a1 + 24) = v13;
  int v14 = bswap32(*((_DWORD *)v5 + 7));
  LODWORD(v26) = 91;
  sub_10007EF00((uint64_t)"prng_algorithm_type", v14, &v26, 1LL);
  *(_DWORD *)(a1 + 2_Block_object_dispose(va, 8) = v14;
  int v15 = bswap32(*((_DWORD *)v5 + 8));
  LODWORD(v26) = 160;
  sub_10007EF00((uint64_t)"prng_key_bits_size_t", v15, &v26, 1LL);
  *(_DWORD *)(a1 + sub_1000114F0(v6 - 32) = v15;
  *(_OWORD *)(a1 + 36) = *(_OWORD *)(v5 + 36);
  *(_DWORD *)(a1 + 5sub_1000F1278(&v6, 2) = bswap32(*((_DWORD *)v5 + 13));
  *(int8x16_t *)(a1 + 56) = vrev64q_s8(*(int8x16_t *)(v5 + 56));
  unsigned int v16 = bswap32(*((_DWORD *)v5 + 18));
  *(_DWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v16;
  if (v16 - 2049 <= 0xFFFFF7FF)
  {
    id v20 = __cxa_allocate_exception(0x40uLL);
    *id v20 = &off_100189E78;
    __int16 v21 = std::generic_category();
    v20[1] = 152LL;
    uint64_t v22 = "crypto header contains invalid number of auth entries";
LABEL_13:
    void v20[2] = v21;
    *((_BYTE *)v20 + 24) = 0;
    *((_BYTE *)v20 + 4_Block_object_dispose(va, 8) = 0;
    v20[7] = v22;
  }

  operator delete[](v5);
  return a1;
}

void sub_10010D42C(_Unwind_Exception *a1)
{
}

void sub_10010D43C()
{
}

void sub_10010D444(_Unwind_Exception *a1)
{
}

void sub_10010D4F8(uint64_t a1, ...)
{
}

void sub_10010D544(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_10000491C(a1);
  }
  _Unwind_Resume(a1);
}

__n128 sub_10010D558(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + sub_1000114F0(v6 - 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 5sub_1000F1278(&v6, 2) = 0LL;
  *(void *)(a1 + 6_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 6sub_1000F1278((int *)&v3, 0) = 0LL;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  __n128 result = *(__n128 *)(a2 + 16);
  __int128 v3 = *(_OWORD *)(a2 + 32);
  __int128 v4 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 6sub_1000F1278((int *)&v3, 0) = *(_OWORD *)(a2 + 60);
  *(_OWORD *)(a1 + sub_1000114F0(v6 - 32) = v3;
  *(_OWORD *)(a1 + 4_Block_object_dispose(va, 8) = v4;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

uint64_t sub_10010D594(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a2 = *(_DWORD *)a1;
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a2 + _Block_object_dispose(va, 8) = bswap32(*(_DWORD *)(a1 + 8));
  *(_DWORD *)(a2 + 1sub_1000F1278(&v6, 2) = bswap32(*(_DWORD *)(a1 + 12));
  *(_DWORD *)(a2 + 16) = bswap32(*(_DWORD *)(a1 + 16));
  *(_DWORD *)(a2 + 2sub_1000F1278((int *)&v3, 0) = bswap32(*(_DWORD *)(a1 + 20));
  *(_DWORD *)(a2 + 24) = bswap32(*(_DWORD *)(a1 + 24));
  *(_DWORD *)(a2 + 2_Block_object_dispose(va, 8) = bswap32(*(_DWORD *)(a1 + 28));
  *(_DWORD *)(a2 + sub_1000114F0(v6 - 32) = bswap32(*(_DWORD *)(a1 + 32));
  *(_OWORD *)(a2 + 36) = *(_OWORD *)(a1 + 36);
  *(_DWORD *)(a2 + 5sub_1000F1278(&v6, 2) = bswap32(*(_DWORD *)(a1 + 52));
  *(void *)(a2 + 56) = bswap64(*(void *)(a1 + 56));
  *(void *)(a2 + 64) = bswap64(*(void *)(a1 + 64));
  *(_DWORD *)(a2 + 7sub_1000F1278(&v6, 2) = bswap32(*(_DWORD *)(a1 + 72));
  return a2 + 76;
}

const void **sub_10010D638(uint64_t a1, char *a2)
{
  uint64_t v3 = (*(uint64_t (**)(char *))(*(void *)&a2[*(void *)(*(void *)a2 - 40LL)] + 16LL))(&a2[*(void *)(*(void *)a2 - 40LL)]);
  if (!v3)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    int v9 = (void *)sub_100004870( (uint64_t)exception,  (uint64_t)"Image contains crypto format but info class is missing EncryptionInfo",  0x16u);
  }

  uint64_t v4 = v3;
  uint64_t v5 = *(unsigned int *)(a1 + 24);
  if (!*(_BYTE *)(v3 + 16)) {
    *(_BYTE *)(v3 + 16) = 1;
  }
  *(void *)(v3 + _Block_object_dispose(va, 8) = v5;
  int v11 = CFUUIDCreateFromUUIDBytes(kCFAllocatorDefault, *(CFUUIDBytes *)(a1 + 36));
  CFStringRef v6 = CFUUIDCreateString(kCFAllocatorDefault, v11);
  int v10 = v6;
  if (*(void *)(v4 + 24))
  {
    CFRelease(*(CFTypeRef *)(v4 + 24));
    CFStringRef v6 = v10;
  }

  *(void *)(v4 + 24) = v6;
  int v10 = 0LL;
  sub_100026A94((const void **)&v10);
  return sub_100026EE4((const void **)&v11);
}

void sub_10010D724( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

uint64_t sub_10010D748(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + sub_1000114F0(v6 - 32) = 0u;
  *(_OWORD *)a1 = 0u;
  LODWORD(v9) = 0;
  sub_10007EF00((uint64_t)"public_key_crypto_algo_mode", 0, &v9, 1LL);
  bzero((void *)(a1 + 48), 0x204uLL);
  LODWORD(v9) = bswap32(*(_DWORD *)a2);
  sub_10010DD48((_DWORD *)a1, &v9);
  __int128 v4 = *(_OWORD *)(a2 + 20);
  *(_OWORD *)(a1 + 4) = *(_OWORD *)(a2 + 4);
  *(_OWORD *)(a1 + 2sub_1000F1278((int *)&v3, 0) = v4;
  int v5 = bswap32(*(_DWORD *)(a2 + 36));
  LODWORD(v9) = 42;
  sub_10007EF00((uint64_t)"public_key_crypto_algo", v5, &v9, 1LL);
  *(_DWORD *)(a1 + 36) = v5;
  int v6 = bswap32(*(_DWORD *)(a2 + 40));
  unint64_t v9 = 0x800000010000000ALL;
  sub_10007EF00((uint64_t)"public_key_padding_algo", v6, &v9, 2LL);
  *(_DWORD *)(a1 + 4sub_1000F1278((int *)&v3, 0) = v6;
  int v7 = bswap32(*(_DWORD *)(a2 + 44));
  LODWORD(v9) = 0;
  sub_10007EF00((uint64_t)"public_key_crypto_algo_mode", v7, &v9, 1LL);
  *(_DWORD *)(a1 + 44) = v7;
  LODWORD(v9) = bswap32(*(_DWORD *)(a2 + 48));
  sub_10010DE1C((_DWORD *)(a1 + 48), &v9);
  memcpy((void *)(a1 + 52), (const void *)(a2 + 52), 0x200uLL);
  return a1;
}

uint64_t sub_10010D8C4(uint64_t a1, uint64_t a2, SecKeyRef *a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + sub_1000114F0(v6 - 32) = 0x2A00000000LL;
  LODWORD(__p) = 42;
  sub_10007EF00((uint64_t)"public_key_crypto_algo", 42, &__p, 1LL);
  *(_DWORD *)(a1 + 4sub_1000F1278((int *)&v3, 0) = 10;
  __p = (void *)0x800000010000000ALL;
  sub_10007EF00((uint64_t)"public_key_padding_algo", 10, &__p, 2LL);
  *(_DWORD *)(a1 + 44) = 0;
  LODWORD(__p) = 0;
  sub_10007EF00((uint64_t)"public_key_crypto_algo_mode", 0, &__p, 1LL);
  bzero((void *)(a1 + 48), 0x204uLL);
  sub_10010DC20(a2, &__p);
  CFErrorRef error = 0LL;
  CFDataRef v23 = SecKeyCopyExternalRepresentation(*a3, &error);
  if (!v23)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    unsigned int Code = CFErrorGetCode(error);
    void *exception = &off_100189E78;
    int v14 = std::generic_category();
    exception[1] = Code;
    exception[2] = v14;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 4_Block_object_dispose(va, 8) = 0;
    exception[7] = "Key from the certificate is not exportable.";
  }

  sub_10010DCB0((uint64_t *)&v23, (uint64_t *)&theData);
  BytePtr = CFDataGetBytePtr(theData);
  CC_LONG Length = CFDataGetLength(theData);
  CC_SHA1(BytePtr, Length, (unsigned __int8 *)(a1 + 4));
  LODWORD(plaintext) = 20;
  sub_10010DD48((_DWORD *)a1, &plaintext);
  CFDataRef v20 = CFDataCreate(kCFAllocatorDefault, (const UInt8 *)__p, v26 - (_BYTE *)__p);
  sub_10010DCB0((uint64_t *)&v20, (uint64_t *)&plaintext);
  int v8 = *a3;
  unint64_t v9 = sub_10010DDA4(a1);
  CFDataRef v20 = SecKeyCreateEncryptedData(v8, v9, plaintext, &error);
  if (!v20)
  {
    int v15 = __cxa_allocate_exception(0x40uLL);
    unsigned int v16 = CFErrorGetCode(error);
    *int v15 = &off_100189E78;
    uint64_t v17 = std::generic_category();
    v15[1] = v16;
    v15[2] = v17;
    *((_BYTE *)v15 + 24) = 0;
    *((_BYTE *)v15 + 4_Block_object_dispose(va, 8) = 0;
    v15[7] = "Failed to encrypt data using public key from certificate.";
  }

  sub_10010DCB0((uint64_t *)&v20, (uint64_t *)&v19);
  int v18 = CFDataGetLength(v19);
  sub_10010DE1C((_DWORD *)(a1 + 48), &v18);
  int v10 = v19;
  v27.length = CFDataGetLength(v19);
  v27.location = 0LL;
  CFDataGetBytes(v10, v27, (UInt8 *)(a1 + 52));
  sub_100072048((const void **)&v19);
  sub_100072048((const void **)&plaintext);
  sub_100072048((const void **)&theData);
  if (__p)
  {
    uint64_t v26 = __p;
    operator delete(__p);
  }

  return a1;
}

void sub_10010DB98( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, const void *a13, const void *a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  if (__p)
  {
    a18 = (uint64_t)__p;
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void **sub_10010DC20@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  __n128 result = (void **)sub_100111834( a2,  *(void *)(a1 + 8) + *(void *)(a1 + 32) - (*(void *)a1 + *(void *)(a1 + 24)) + 5LL);
  __int128 v4 = (char *)*result;
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = v5 - *(void *)a1;
  if (v5 != *(void *)a1) {
    __n128 result = (void **)memmove(*result, *(const void **)a1, v5 - *(void *)a1);
  }
  int v7 = &v4[v6];
  int v8 = *(_BYTE **)(a1 + 24);
  unint64_t v9 = *(_BYTE **)(a1 + 32);
  int64_t v10 = v9 - v8;
  if (v9 != v8) {
    __n128 result = (void **)memmove(v7, v8, v9 - v8);
  }
  strcpy(&v7[v10], "CKIE");
  return result;
}

uint64_t *sub_10010DCB0@<X0>(uint64_t *result@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v2 = *result;
  *a2 = *result;
  if (!v2)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = &off_100189E78;
    __int128 v4 = std::generic_category();
    exception[1] = 22LL;
    exception[2] = v4;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 4_Block_object_dispose(va, 8) = 0;
    exception[7] = "Failed creating CFAutoRelease instance.";
  }

  return result;
}

void sub_10010DD34( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void **a10)
{
}

_DWORD *sub_10010DD48(_DWORD *result, _DWORD *a2)
{
  if (*a2 >= 0x21u)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    void *exception = &off_100183A38;
    exception[1] = "_publicKeyHash";
    exception[2] = "field size too large";
  }

  *__n128 result = *a2;
  return result;
}

SecKeyAlgorithm sub_10010DDA4(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 36) != 42) {
    goto LABEL_7;
  }
  int v1 = *(_DWORD *)(a1 + 40);
  if (v1 == 10)
  {
    uint64_t v2 = &kSecKeyAlgorithmRSAEncryptionPKCS1;
    return *v2;
  }

  if (v1 != -2147483647)
  {
LABEL_7:
    exception = __cxa_allocate_exception(0x40uLL);
    uint64_t v5 = (void *)sub_100004870((uint64_t)exception, (uint64_t)"Unsupported public key algorithm.", 0xA1u);
  }

  uint64_t v2 = &kSecKeyAlgorithmRSAEncryptionOAEPSHA1;
  return *v2;
}

_DWORD *sub_10010DE1C(_DWORD *result, _DWORD *a2)
{
  if (*a2 >= 0x201u)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    void *exception = &off_100183A38;
    exception[1] = "_encryptedBlob";
    exception[2] = "field size too large";
  }

  *__n128 result = *a2;
  return result;
}

int *sub_10010DE78(int *a1, uint64_t a2)
{
  __int128 v4 = a1 + 3;
  uint64_t v5 = a1 + 12;
  uint64_t v6 = a1 + 25;
  bzero(a1, 0x268uLL);
  int v7 = bswap32(*(_DWORD *)a2);
  LODWORD(v1sub_1000F1278(&v6, 2) = 103;
  sub_10007EF00((uint64_t)"key_derivation_algorithm_t", v7, &v12, 1LL);
  *a1 = v7;
  int v8 = bswap32(*(_DWORD *)(a2 + 4));
  LODWORD(v1sub_1000F1278(&v6, 2) = 0;
  sub_10007EF00((uint64_t)"key_derivation_prng_algorithm_t", v8, &v12, 1LL);
  a1[1] = v8;
  a1[2] = bswap32(*(_DWORD *)(a2 + 8));
  LODWORD(v1sub_1000F1278(&v6, 2) = bswap32(*(_DWORD *)(a2 + 12));
  sub_10010E2A4(v4, &v12);
  __int128 v9 = *(_OWORD *)(a2 + 32);
  *((_OWORD *)a1 + sub_1000F1940(&v11, 1) = *(_OWORD *)(a2 + 16);
  *((_OWORD *)a1 + sub_1000F1278(&v6, 2) = v9;
  LODWORD(v1sub_1000F1278(&v6, 2) = bswap32(*(_DWORD *)(a2 + 48));
  sub_10010E300(v5, &v12);
  __int128 v10 = *(_OWORD *)(a2 + 68);
  *(_OWORD *)(a1 + 13) = *(_OWORD *)(a2 + 52);
  *(_OWORD *)(a1 + 17) = v10;
  a1[21] = bswap32(*(_DWORD *)(a2 + 84));
  LODWORD(v5) = bswap32(*(_DWORD *)(a2 + 88));
  unint64_t v12 = 0x8000000100000011LL;
  sub_10007EF00((uint64_t)"wrap_key_crypto_algo", (int)v5, &v12, 2LL);
  a1[22] = (int)v5;
  LODWORD(v5) = bswap32(*(_DWORD *)(a2 + 92));
  LODWORD(v1sub_1000F1278(&v6, 2) = 7;
  sub_10007EF00((uint64_t)"wrap_key_crypto_padding_algo", (int)v5, &v12, 1LL);
  a1[23] = (int)v5;
  LODWORD(v5) = bswap32(*(_DWORD *)(a2 + 96));
  LODWORD(v1sub_1000F1278(&v6, 2) = 6;
  sub_10007EF00((uint64_t)"crypto_mode", (int)v5, &v12, 1LL);
  a1[24] = (int)v5;
  LODWORD(v1sub_1000F1278(&v6, 2) = bswap32(*(_DWORD *)(a2 + 100));
  sub_10010E620(v6, &v12);
  memcpy(a1 + 26, (const void *)(a2 + 104), 0x200uLL);
  return a1;
}

uint64_t sub_10010E05C(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a2 = bswap32(*(_DWORD *)a1);
  *(_DWORD *)(a2 + 4) = bswap32(*(_DWORD *)(a1 + 4));
  *(_DWORD *)(a2 + _Block_object_dispose(va, 8) = bswap32(*(_DWORD *)(a1 + 8));
  *(_DWORD *)(a2 + 1sub_1000F1278(&v6, 2) = bswap32(*(_DWORD *)(a1 + 12));
  __int128 v3 = *(_OWORD *)(a1 + 32);
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 16);
  *(_OWORD *)(a2 + sub_1000114F0(v6 - 32) = v3;
  *(_DWORD *)(a2 + 4_Block_object_dispose(va, 8) = bswap32(*(_DWORD *)(a1 + 48));
  __int128 v4 = *(_OWORD *)(a1 + 52);
  *(_OWORD *)(a2 + 6_Block_object_dispose(va, 8) = *(_OWORD *)(a1 + 68);
  *(_OWORD *)(a2 + 5sub_1000F1278(&v6, 2) = v4;
  *(_DWORD *)(a2 + 84) = bswap32(*(_DWORD *)(a1 + 84));
  *(_DWORD *)(a2 + 8_Block_object_dispose(va, 8) = bswap32(*(_DWORD *)(a1 + 88));
  *(_DWORD *)(a2 + 9sub_1000F1278(&v6, 2) = bswap32(*(_DWORD *)(a1 + 92));
  *(_DWORD *)(a2 + 96) = bswap32(*(_DWORD *)(a1 + 96));
  *(_DWORD *)(a2 + 10sub_1000F1278((int *)&v3, 0) = bswap32(*(_DWORD *)(a1 + 100));
  memcpy((void *)(a2 + 104), (const void *)(a1 + 104), 0x200uLL);
  return a2 + 616;
}

uint64_t sub_10010E120(uint64_t a1)
{
  *(_DWORD *)a1 = 103;
  LODWORD(v3) = 103;
  sub_10007EF00((uint64_t)"key_derivation_algorithm_t", 103, &v3, 1LL);
  *(_DWORD *)(a1 + 4) = 0;
  LODWORD(v3) = 0;
  sub_10007EF00((uint64_t)"key_derivation_prng_algorithm_t", 0, &v3, 1LL);
  *(_OWORD *)(a1 + 6_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 4sub_1000F1278((int *)&v3, 0) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + _Block_object_dispose(va, 8) = 0u;
  *(void *)(a1 + 84) = 0x11000000C0LL;
  unint64_t v3 = 0x8000000100000011LL;
  sub_10007EF00((uint64_t)"wrap_key_crypto_algo", 17, &v3, 2LL);
  *(_DWORD *)(a1 + 9sub_1000F1278(&v6, 2) = 7;
  LODWORD(v3) = 7;
  sub_10007EF00((uint64_t)"wrap_key_crypto_padding_algo", 7, &v3, 1LL);
  *(_DWORD *)(a1 + 96) = 6;
  LODWORD(v3) = 6;
  sub_10007EF00((uint64_t)"crypto_mode", 6, &v3, 1LL);
  bzero((void *)(a1 + 100), 0x204uLL);
  LODWORD(v3) = 20;
  sub_10010E2A4((_DWORD *)(a1 + 12), &v3);
  LODWORD(v3) = 8;
  sub_10010E300((_DWORD *)(a1 + 48), &v3);
  sub_10010E35C((void *)(a1 + 16), *(unsigned int *)(a1 + 12));
  sub_10010E35C((void *)(a1 + 52), *(unsigned int *)(a1 + 48));
  return a1;
}

_DWORD *sub_10010E2A4(_DWORD *result, _DWORD *a2)
{
  if (*a2 >= 0x21u)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    void *exception = &off_100183A38;
    exception[1] = "_salt";
    exception[2] = "field size too large";
  }

  *__n128 result = *a2;
  return result;
}

_DWORD *sub_10010E300(_DWORD *result, _DWORD *a2)
{
  if (*a2 >= 0x21u)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    void *exception = &off_100183A38;
    exception[1] = "_blob_encryption_iv";
    exception[2] = "field size too large";
  }

  *__n128 result = *a2;
  return result;
}

uint64_t sub_10010E35C(void *a1, size_t a2)
{
  uint64_t result = CCRandomGenerateBytes(a1, a2);
  if ((_DWORD)result)
  {
    unsigned int v4 = result;
    exception = __cxa_allocate_exception(0x40uLL);
    sub_100004D60((uint64_t)v5);
    sub_100004E4C(v5, (uint64_t)"random generation failed with err code ", 39LL);
    std::ostream::operator<<(v5, v4);
    sub_10001161C((uint64_t)exception, (uint64_t)v5, 0x9Au);
  }

  return result;
}

void sub_10010E3F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_10010E424(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 88);
  if (v1 == -2147483647) {
    return 0LL;
  }
  if (v1 != 17)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    sub_100004D60((uint64_t)v4);
    sub_100004E4C(v4, (uint64_t)"Unsupported key decryption algo", 31LL);
    sub_10001161C((uint64_t)exception, (uint64_t)v4, 0xA1u);
  }

  return 2LL;
}

void sub_10010E4C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_10010E4F8@<X0>(uint64_t a1@<X0>, const char *a2@<X1>, uint8_t **a3@<X8>)
{
  unint64_t v4 = *(unsigned int *)(a1 + 84);
  if ((v4 & 7) != 0)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    int v11 = (void *)sub_100004870((uint64_t)exception, (uint64_t)"crypto_format: key size isn't a multiple of 8", 0x16u);
  }

  char v14 = 0;
  sub_100111018(a3, v4 >> 3, &v14);
  size_t v7 = strlen(a2);
  uint64_t result = CCKeyDerivationPBKDF( 2u,  a2,  v7,  (const uint8_t *)(a1 + 16),  *(unsigned int *)(a1 + 12),  1u,  *(_DWORD *)(a1 + 8),  *a3,  a3[1] - *a3);
  unsigned int v9 = result;
  if ((_DWORD)result)
  {
    unint64_t v12 = __cxa_allocate_exception(0x40uLL);
    *unint64_t v12 = &off_100189E78;
    int v13 = std::generic_category();
    v12[1] = v9;
    void v12[2] = v13;
    *((_BYTE *)v12 + 24) = 0;
    *((_BYTE *)v12 + 4_Block_object_dispose(va, 8) = 0;
    v12[7] = "crypto_format: Can't derive key";
  }

  return result;
}

void sub_10010E604(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(va, 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

_DWORD *sub_10010E620(_DWORD *result, _DWORD *a2)
{
  if (*a2 >= 0x201u)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    void *exception = &off_100183A38;
    exception[1] = "_blob";
    exception[2] = "field size too large";
  }

  *uint64_t result = *a2;
  return result;
}

_DWORD *sub_10010E67C(_DWORD *a1, uint64_t a2, const char *a3)
{
  uint64_t v6 = sub_10010E120((uint64_t)a1);
  LODWORD(v12[0]) = 8;
  sub_10010E300((_DWORD *)(v6 + 48), v12);
  size_t v7 = strlen(a3);
  a1[2] = CCCalibratePBKDF(2u, v7, a1[3], 1u, (unint64_t)a1[21] >> 3, 0x64u);
  sub_10010DC20(a2, &v16);
  size_t dataOutMoved = 0LL;
  sub_10010E4F8((uint64_t)a1, a3, &v13);
  CCAlgorithm v8 = sub_10010E424((uint64_t)a1);
  uint64_t v9 = CCCrypt(0, v8, 1u, v13, v14 - v13, a1 + 13, v16, v17 - (_BYTE *)v16, a1 + 26, 0x200uLL, &dataOutMoved);
  bzero(v13, v14 - v13);
  if ((_DWORD)v9)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    sub_100004D60((uint64_t)v12);
    sub_100004E4C(v12, (uint64_t)"Image key encoding failed with err code ", 40LL);
    std::ostream::operator<<(v12, v9);
    sub_10001161C((uint64_t)exception, (uint64_t)v12, 0x9Au);
  }

  LODWORD(v12[0]) = dataOutMoved;
  sub_10010E620(a1 + 25, v12);
  if (v13)
  {
    char v14 = v13;
    operator delete(v13);
  }

  if (v16)
  {
    uint64_t v17 = v16;
    operator delete(v16);
  }

  return a1;
}

void sub_10010E800(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  size_t v7 = *(void **)(v5 - 88);
  if (v7)
  {
    *(void *)(v5 - 8sub_1000F1278((int *)&v3, 0) = v7;
    operator delete(v7);
  }

  CCAlgorithm v8 = *(void **)(v5 - 56);
  if (v8)
  {
    *(void *)(v5 - 4_Block_object_dispose(va, 8) = v8;
    operator delete(v8);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_10010E868(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
  *(_DWORD *)(a1 + 16) = 0;
  int v4 = bswap32(*(_DWORD *)a2);
  __int128 v6 = xmmword_100140E00;
  int v7 = 9;
  sub_10007EF00((uint64_t)"auth_table_entry_mechanism", v4, &v6, 5LL);
  *(_DWORD *)a1 = v4;
  *(void *)(a1 + 4) = bswap64(*(void *)(a2 + 4));
  *(void *)(a1 + 1sub_1000F1278(&v6, 2) = bswap64(*(void *)(a2 + 12));
  return a1;
}

void sub_10010E924(unsigned int *a1@<X1>, const char *a2@<X2>, unint64_t *a3@<X8>)
{
  CCAlgorithm v5 = sub_10010E424((uint64_t)a1);
  unsigned int v6 = CCCrypt(1u, v5, 1u, __p, v10 - (_BYTE *)__p, a1 + 13, a1 + 26, a1[25], __src, a1[25], &__sz);
  if (v6)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = &off_100189E78;
    CCAlgorithm v8 = std::generic_category();
    exception[1] = v6;
    exception[2] = v8;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 4_Block_object_dispose(va, 8) = 0;
    exception[7] = "crypto_format: Can't decrypt wrapped key";
  }

  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  sub_1000F6D7C(a3, __sz);
  sub_1000F6F70((uint64_t)a3, (char *)*a3, __src, &__src[__sz], __sz);
  if (__p)
  {
    __int128 v10 = __p;
    operator delete(__p);
  }

void sub_10010EA68( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  unsigned int v16 = *(void **)v14;
  if (*(void *)v14)
  {
    *(void *)(v14 + _Block_object_dispose(va, 8) = v16;
    operator delete(v16);
  }

  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_10010EAA8@<D0>(uint64_t a1@<X1>, const void **a2@<X2>, uint64_t a3@<X8>)
{
  if (!sub_10010EBA4(a1, a2))
  {
    exception = __cxa_allocate_exception(0x40uLL);
    uint64_t v14 = (void *)sub_100004870((uint64_t)exception, (uint64_t)"crypto_format: Cookie differs", 0x23u);
  }

  unsigned int v6 = *a2;
  size_t v7 = (unint64_t)*(unsigned int *)(a1 + 24) >> 3;
  uint64_t v18 = 0LL;
  __int128 v17 = 0uLL;
  sub_100111094(&v17, v6, (uint64_t)v6 + v7, v7);
  unint64_t v8 = *(unsigned int *)(a1 + 24);
  uint64_t v9 = (char *)*a2 + (v8 >> 3);
  uint64_t v10 = (*(_DWORD *)(a1 + 32) + v8) >> 3;
  uint64_t v11 = (uint64_t)*a2 + v10;
  uint64_t v16 = 0LL;
  __int128 v15 = 0uLL;
  sub_100111094(&v15, v9, v11, v10 - (v8 >> 3));
  *(_OWORD *)a3 = v17;
  *(void *)(a3 + 16) = v18;
  double result = *(double *)&v15;
  *(_OWORD *)(a3 + 24) = v15;
  *(void *)(a3 + 4sub_1000F1278((int *)&v3, 0) = v16;
  return result;
}

void sub_10010EB88( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10010EBA4(uint64_t a1, void *a2)
{
  uint64_t v2 = ((*(_DWORD *)(a1 + 32) + *(_DWORD *)(a1 + 24)) >> 3) + 5;
  if (a2[1] - *a2 != v2) {
    return 0LL;
  }
  uint64_t v3 = *a2 + v2;
  v6.__r_.__value_.__s.__size_ = 4;
  LODWORD(v6.__r_.__value_.__l.__data_) = *(_DWORD *)(v3 - 5);
  v6.__r_.__value_.__s.__data_[4] = 0;
  BOOL v4 = std::string::compare(&v6, "CKIE") == 0;
  return v4;
}

void sub_10010EC34( uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, const char *a5@<X5>, uint64_t a6@<X8>)
{
  if (a4 != 616)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    uint64_t v14 = (void *)sub_100004870((uint64_t)exception, (uint64_t)"UDIF encryption: password header size mismatch", 0x16u);
  }

  uint64_t v11 = operator new[](0x268uLL);
  bzero(v11, 0x268uLL);
  unsigned int v12 = sub_100033014(a1, (uint64_t)v11, 616LL, a3);
  if ((v12 & 0x80000000) != 0)
  {
    __int128 v15 = __cxa_allocate_exception(0x40uLL);
    *__int128 v15 = &off_100189E78;
    uint64_t v16 = std::generic_category();
    v15[1] = v12;
    v15[2] = v16;
    *((_BYTE *)v15 + 24) = 0;
    *((_BYTE *)v15 + 4_Block_object_dispose(va, 8) = 0;
    v15[7] = "Can't read UDIF crypto header";
  }

  sub_10010DE78((int *)v18, (uint64_t)v11);
  sub_10010E924(v18, a5, (unint64_t *)__p);
  sub_10010EAA8(a2, (const void **)__p, a6);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

  operator delete[](v11);
}

void sub_10010EDA8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  operator delete[](v11);
  _Unwind_Resume(a1);
}

uint64_t sub_10010EDDC(uint64_t a1, uint64_t a2, uint64_t *a3, __SecKey *a4, uint64_t a5)
{
  uint64_t v9 = (void *)(a1 + 24);
  *(_OWORD *)(a1 + 4_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + sub_1000114F0(v6 - 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(void *)&__int128 v21 = CFDataCreate(kCFAllocatorDefault, (const UInt8 *)(a5 + 52), *(unsigned int *)(a5 + 48));
  sub_10010DCB0((uint64_t *)&v21, (uint64_t *)&v27);
  uint64_t v10 = sub_10010DDA4(a5);
  CFDataRef v26 = SecKeyCreateDecryptedData(a4, v10, v27, &error);
  if (!v26)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    unsigned int Code = CFErrorGetCode(error);
    void *exception = &off_100189E78;
    CFDataRef v19 = std::generic_category();
    exception[1] = Code;
    exception[2] = v19;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 4_Block_object_dispose(va, 8) = 0;
    exception[7] = "Error while decrypting data using keychain";
  }

  sub_10010DCB0((uint64_t *)&v26, (uint64_t *)&v25);
  uint64_t v11 = *a3;
  sub_1000F6CA0(v25, 0, 0LL, (unint64_t *)__p);
  sub_10010EAA8(v11, (const void **)__p, (uint64_t)&v21);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

  uint64_t v12 = *a3;
  *a3 = 0LL;
  int v13 = *(void **)(a1 + 48);
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = v12;
  if (v13) {
    operator delete(v13);
  }
  uint64_t v14 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + _Block_object_dispose(va, 8) = v14;
    operator delete(v14);
    *(void *)a1 = 0LL;
    *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
    *(void *)(a1 + 16) = 0LL;
  }

  *(_OWORD *)a1 = v21;
  *(void *)(a1 + 16) = v22;
  __int128 v15 = *(void **)(a1 + 24);
  if (v15)
  {
    *(void *)(a1 + sub_1000114F0(v6 - 32) = v15;
    operator delete(v15);
    void *v9 = 0LL;
    v9[1] = 0LL;
    _OWORD v9[2] = 0LL;
  }

  *(_OWORD *)(a1 + 24) = v23;
  *(void *)(a1 + 4sub_1000F1278((int *)&v3, 0) = v24;
  sub_100072048((const void **)&v25);
  sub_100072048((const void **)&v27);
  return a1;
}

void sub_10010EF9C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  uint64_t v24 = *(void **)(v19 + 56);
  if (v24)
  {
    *(void *)(v19 + 64) = v24;
    operator delete(v24);
  }

  __int16 v25 = *(void **)(v19 + 48);
  *(void *)(v19 + 4_Block_object_dispose(va, 8) = 0LL;
  if (v25) {
    operator delete(v25);
  }
  CFDataRef v26 = *v21;
  if (*v21)
  {
    *(void *)(v19 + sub_1000114F0(v6 - 32) = v26;
    operator delete(v26);
  }

  CFRange v27 = *(void **)v19;
  if (*(void *)v19)
  {
    *(void *)(v19 + _Block_object_dispose(va, 8) = v27;
    operator delete(v27);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_10010F034(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + sub_1000114F0(v6 - 32) = v2;
    operator delete(v2);
  }

  uint64_t v3 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + _Block_object_dispose(va, 8) = v3;
    operator delete(v3);
  }

  return a1;
}

uint64_t sub_10010F078(uint64_t a1, uint64_t a2, uint64_t *a3, const char *a4)
{
  size_t v7 = (void *)(a1 + 24);
  *(_OWORD *)(a1 + 4_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + sub_1000114F0(v6 - 32) = 0u;
  *(_OWORD *)a1 = 0u;
  uint64_t v8 = 20LL * *(unsigned int *)(*a3 + 72);
  uint64_t v9 = operator new[](v8);
  bzero(v9, v8);
  unsigned int v10 = sub_100033014(a2, (uint64_t)v9, v8, 76LL);
  CFDataRef v26 = v9;
  if ((v10 & 0x80000000) != 0)
  {
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = &off_100189E78;
    __int16 v25 = std::generic_category();
    exception[1] = v10;
    exception[2] = v25;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 4_Block_object_dispose(va, 8) = 0;
    exception[7] = "Crypto: Can't read encryption table";
  }

  if (!*(_DWORD *)(*a3 + 72))
  {
LABEL_15:
    uint64_t v22 = __cxa_allocate_exception(0x40uLL);
    *uint64_t v22 = &off_100189E78;
    __int128 v23 = std::generic_category();
    v22[1] = 80LL;
    v22[2] = v23;
    *((_BYTE *)v22 + 24) = 0;
    *((_BYTE *)v22 + 4_Block_object_dispose(va, 8) = 0;
    v22[7] = "Invalid passphrase or key";
  }

  unint64_t v11 = 0LL;
  uint64_t v12 = (uint64_t)v9;
  while (1)
  {
    sub_10010E868((uint64_t)&v36, v12);
    if (v36 == 1) {
      break;
    }
    ++v11;
    v12 += 20LL;
  }

  *(_OWORD *)uint64_t v34 = 0u;
  __int128 v35 = 0u;
  *(_OWORD *)__p = 0u;
  sub_10010EC34(a2, *a3, v37, v38, a4, (uint64_t)&v29);
  int v13 = v29;
  __p[0] = v29;
  *(_OWORD *)uint64_t v28 = v30;
  __p[1] = (void *)v30;
  uint64_t v14 = v31;
  uint64_t v15 = v32;
  v34[1] = v31;
  __int128 v35 = v32;
  uint64_t v16 = *((void *)&v32 + 1);
  uint64_t v17 = *a3;
  *a3 = 0LL;
  uint64_t v18 = *(void **)(a1 + 48);
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = v17;
  if (v18) {
    operator delete(v18);
  }
  uint64_t v19 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + _Block_object_dispose(va, 8) = v19;
    operator delete(v19);
    *(void *)a1 = 0LL;
    *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
    *(void *)(a1 + 16) = 0LL;
  }

  *(void *)a1 = v13;
  *(_OWORD *)(a1 + _Block_object_dispose(va, 8) = *(_OWORD *)v28;
  __p[1] = 0LL;
  v34[0] = 0LL;
  __p[0] = 0LL;
  CFDataRef v20 = *(void **)(a1 + 24);
  if (v20)
  {
    *(void *)(a1 + sub_1000114F0(v6 - 32) = v20;
    operator delete(v20);
    *size_t v7 = 0LL;
    v7[1] = 0LL;
    unint64_t v7[2] = 0LL;
  }

  *(void *)(a1 + 24) = v14;
  *(void *)(a1 + sub_1000114F0(v6 - 32) = v15;
  *(void *)(a1 + 4sub_1000F1278((int *)&v3, 0) = v16;
  if (__p[0]) {
    operator delete(__p[0]);
  }
  operator delete[](v26);
  return a1;
}

void sub_10010F324()
{
}

void sub_10010F348()
{
}

__n128 sub_10010F3B8(void *a1, uint64_t a2, __n128 *a3, uint64_t *a4)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  a1[2] = *(void *)(a2 + 16);
  *(void *)a2 = 0LL;
  *(void *)(a2 + _Block_object_dispose(va, 8) = 0LL;
  *(void *)(a2 + 16) = 0LL;
  a1[3] = 0LL;
  a1[4] = 0LL;
  a1[5] = 0LL;
  __n128 result = *a3;
  *(__n128 *)(a1 + 3) = *a3;
  a1[5] = a3[1].n128_u64[0];
  a3->n128_u64[0] = 0LL;
  a3->n128_u64[1] = 0LL;
  a3[1].n128_u64[0] = 0LL;
  uint64_t v5 = *a4;
  *a4 = 0LL;
  a1[6] = v5;
  a1[7] = 0LL;
  a1[8] = 0LL;
  a1[9] = 0LL;
  return result;
}

const void **sub_10010F40C(uint64_t a1, char *a2)
{
  return sub_10010D638(*(void *)(a1 + 48), a2);
}

uint64_t sub_10010F414(uint64_t a1, CCOperation a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)(a1 + 24) = 0LL;
  uint64_t v10 = a1 + 24;
  *(_DWORD *)(a1 + 16) = a2;
  *(void *)(a1 + sub_1000114F0(v6 - 32) = 0LL;
  *(void *)(a1 + 4sub_1000F1278((int *)&v3, 0) = 0LL;
  sub_1000568B4((void *)(a1 + 24), *(const void **)a3, *(void *)(a3 + 8), *(void *)(a3 + 8) - *(void *)a3);
  *(void *)(v10 + 24) = a5;
  *(void *)(v10 + sub_1000114F0(v6 - 32) = a4;
  CCCryptorStatus v11 = CCCryptorCreate( a2,  0,  0,  *(const void **)a3,  *(void *)(a3 + 8) - *(void *)a3,  0LL,  (CCCryptorRef *)(v10 - 16));
  if (v11)
  {
    unsigned int v13 = v11;
    exception = __cxa_allocate_exception(0x40uLL);
    void *exception = &off_100189E78;
    uint64_t v15 = std::generic_category();
    exception[1] = v13;
    exception[2] = v15;
    *((_BYTE *)exception + 24) = 0;
    *((_BYTE *)exception + 4_Block_object_dispose(va, 8) = 0;
    exception[7] = "crypto_format: Can't initialize aes cryptor";
  }

  *(_BYTE *)a1 = 1;
  return a1;
}

void sub_10010F4FC(_Unwind_Exception *exception_object)
{
  BOOL v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + sub_1000114F0(v6 - 32) = v4;
    operator delete(v4);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_10010F518(uint64_t a1)
{
  if (*(_BYTE *)a1) {
    CCCryptorRelease(*(CCCryptorRef *)(a1 + 8));
  }
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + sub_1000114F0(v6 - 32) = v2;
    operator delete(v2);
  }

  return a1;
}

uint64_t sub_10010F55C(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 16) = 0LL;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = 0LL;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(void *)(a1 + 4sub_1000F1278((int *)&v3, 0) = 0LL;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(void *)(a1 + 4sub_1000F1278((int *)&v3, 0) = *(void *)(a2 + 40);
  *(_OWORD *)(a2 + 24) = 0u;
  uint64_t v3 = *(void *)(a2 + 48);
  *(_OWORD *)(a2 + 4sub_1000F1278((int *)&v3, 0) = 0u;
  *(void *)(a1 + 56) = 0LL;
  uint64_t v4 = a1 + 56;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = v3;
  *(void *)(a1 + 64) = 0LL;
  sub_100113ADC(a1 + 24, &v9);
  sub_100014DF0(v4, &v9);
  uint64_t v5 = (std::__shared_weak_count *)*((void *)&v9 + 1);
  if (*((void *)&v9 + 1))
  {
    std::string v6 = (unint64_t *)(*((void *)&v9 + 1) + 8LL);
    do
      unint64_t v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }

  return a1;
}

void sub_10010F63C(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;
  sub_1000114F0(v4);
  std::string v6 = *(void **)(v1 + 48);
  *(void *)(v1 + 4_Block_object_dispose(va, 8) = 0LL;
  if (v6) {
    operator delete(v6);
  }
  unint64_t v7 = *v2;
  if (*v2)
  {
    *(void *)(v1 + sub_1000114F0(v6 - 32) = v7;
    operator delete(v7);
  }

  uint64_t v8 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(va, 8) = v8;
    operator delete(v8);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_10010F688(uint64_t a1, uint64_t *a2, uint64_t a3, const char *a4, __SecKey *a5)
{
  SecKeyRef v28 = a5;
  uint64_t v8 = (unint64_t *)(a1 + 24);
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + sub_1000114F0(v6 - 32) = 0u;
  uint64_t v9 = *a2;
  *a2 = 0LL;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = v9;
  *(void *)(a1 + 56) = 0LL;
  uint64_t v10 = a1 + 56;
  *(void *)(a1 + 64) = 0LL;
  unint64_t v11 = (unint64_t)*(unsigned int *)(v9 + 24) >> 3;
  uint64_t v12 = *(char **)a1;
  unsigned int v13 = *(char **)(a1 + 8);
  if (v11 <= v13 - v12)
  {
    if (v11 < v13 - v12)
    {
      unsigned int v13 = &v12[v11];
      *(void *)(a1 + _Block_object_dispose(va, 8) = &v12[v11];
    }
  }

  else
  {
    sub_10011110C((unint64_t *)a1, v11 - (v13 - v12));
    uint64_t v12 = *(char **)a1;
    unsigned int v13 = *(char **)(a1 + 8);
  }

  sub_10010E35C(v12, v13 - v12);
  unint64_t v15 = (unint64_t)*(unsigned int *)(*(void *)(a1 + 48) + 32LL) >> 3;
  uint64_t v16 = *(char **)(a1 + 24);
  uint64_t v17 = *(char **)(a1 + 32);
  if (v15 <= v17 - v16)
  {
    if (v15 < v17 - v16)
    {
      uint64_t v17 = &v16[v15];
      *(void *)(a1 + sub_1000114F0(v6 - 32) = &v16[v15];
    }
  }

  else
  {
    sub_10011110C(v8, v15 - (v17 - v16));
    uint64_t v16 = *(char **)(a1 + 24);
    uint64_t v17 = *(char **)(a1 + 32);
  }

  sub_10010E35C(v16, v17 - v16);
  sub_100113ADC((uint64_t)v8, &v29);
  sub_100014DF0(v10, (__int128 *)&v29);
  uint64_t v18 = *(std::__shared_weak_count **)((char *)&v30 + 4);
  if (*(void *)((char *)&v30 + 4))
  {
    uint64_t v19 = (unint64_t *)(*(void *)((char *)&v30 + 4) + 8LL);
    do
      unint64_t v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }

  __p = 0LL;
  unint64_t v26 = 0LL;
  unint64_t v27 = 0LL;
  if (a4)
  {
    sub_10010E67C(&v29, a1, a4);
    unint64_t v26 = sub_100111234((uint64_t *)&__p, (uint64_t)&v29);
  }

  if (v28)
  {
    sub_10010D8C4((uint64_t)&v29, a1, &v28);
    unint64_t v21 = v26;
    if (v26 >= v27)
    {
      uint64_t v23 = sub_100111640((uint64_t *)&__p, (uint64_t)&v29);
    }

    else
    {
      *(_DWORD *)(v26 + sub_1000114F0(v6 - 32) = 0;
      *(_OWORD *)unint64_t v21 = 0u;
      *(_OWORD *)(v21 + 16) = 0u;
      *(_DWORD *)unint64_t v21 = v29;
      __int128 v22 = v30;
      *(_OWORD *)(v21 + 2sub_1000F1278((int *)&v3, 0) = v31;
      *(_OWORD *)(v21 + 4) = v22;
      *(void *)(v21 + 36) = v32;
      *(_DWORD *)(v21 + 44) = v33;
      bzero((void *)(v21 + 48), 0x204uLL);
      *(_DWORD *)(v21 + 4_Block_object_dispose(va, 8) = v34;
      memcpy((void *)(v21 + 52), v35, 0x200uLL);
      *(_DWORD *)(v21 + 616) = 1;
      uint64_t v23 = v21 + 620;
    }

    unint64_t v26 = v23;
  }

  sub_10010FA0C(a1, a3, (uint64_t *)&__p);
  if (__p)
  {
    unint64_t v26 = (unint64_t)__p;
    operator delete(__p);
  }

  return a1;
}

void sub_10010F9A4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  sub_1000114F0(v12);
  uint64_t v14 = *(void **)(v10 + 48);
  *(void *)(v10 + 4_Block_object_dispose(va, 8) = 0LL;
  if (v14) {
    operator delete(v14);
  }
  unint64_t v15 = *v11;
  if (*v11)
  {
    *(void *)(v10 + sub_1000114F0(v6 - 32) = v15;
    operator delete(v15);
  }

  uint64_t v16 = *(void **)v10;
  if (*(void *)v10)
  {
    *(void *)(v10 + _Block_object_dispose(va, 8) = v16;
    operator delete(v16);
  }

  _Unwind_Resume(a1);
}

void sub_10010FA0C(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6 = (a3[1] - *a3) >> 2;
  *(_DWORD *)(*(void *)(a1 + 48) + 72LL) = 1496311187 * v6;
  uint64_t v35 = 76LL;
  unint64_t v7 = 0xBDEF7BDEF7BDEF7CLL * v6 + 76;
  unint64_t v34 = v7;
  uint64_t v8 = sub_10010FCE0(a1, a3);
  sub_1001118B4(&__p, v8 + v7);
  sub_10010D594(*(void *)(a1 + 48), (uint64_t)__p);
  uint64_t v9 = *a3;
  for (uint64_t i = a3[1]; v9 != i; v9 += 620LL)
  {
    unint64_t v26 = &v35;
    unint64_t v27 = (std::__shared_weak_count *)&v34;
    p_p = &__p;
    uint64_t v11 = *(unsigned int *)(v9 + 616);
    if ((_DWORD)v11 == -1) {
      sub_100017130();
    }
    int v36 = &v26;
    ((void (*)(uint64_t ***, uint64_t))off_1001884E8[v11])(&v36, v9);
  }

  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 40LL))(a2) < *(void *)(*(void *)(a1 + 48) + 64LL))
  {
    unsigned int v12 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 56LL))(a2);
    if (v12)
    {
      exception = __cxa_allocate_exception(0x40uLL);
      void *exception = &off_100189E78;
      __int16 v25 = std::generic_category();
      exception[1] = v12;
      exception[2] = v25;
      *((_BYTE *)exception + 24) = 0;
      *((_BYTE *)exception + 4_Block_object_dispose(va, 8) = 0;
      exception[7] = "Failed truncating crypto header";
    }
  }

  unsigned int v13 = (uint64_t *)__p;
  uint64_t v14 = v33;
  unint64_t v15 = (std::__shared_weak_count *)*((void *)sub_100118DDC() + 1);
  unint64_t v26 = v13;
  unint64_t v27 = v15;
  if (v15)
  {
    uint64_t p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      unint64_t v17 = __ldxr(p_shared_owners);
    while (__stxr(v17 + 1, p_shared_owners));
  }

  p_p = (void **)(v14 - (_BYTE *)v13);
  uint64_t v29 = 0LL;
  int64_t v30 = v14 - (_BYTE *)v13;
  char v31 = 0;
  unsigned int v18 = (*(uint64_t (**)(uint64_t, uint64_t **))(*(void *)a2 + 80LL))(a2, &v26);
  if (p_p != (void **)(int)v18)
  {
    __int128 v22 = __cxa_allocate_exception(0x40uLL);
    *__int128 v22 = &off_100189E78;
    uint64_t v23 = std::generic_category();
    v22[1] = v18;
    v22[2] = v23;
    *((_BYTE *)v22 + 24) = 0;
    *((_BYTE *)v22 + 4_Block_object_dispose(va, 8) = 0;
    v22[7] = "Failed writing crypto header";
  }

  uint64_t v19 = v27;
  if (v27)
  {
    unint64_t v20 = (unint64_t *)&v27->__shared_owners_;
    do
      unint64_t v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }

  if (__p)
  {
    int v33 = __p;
    operator delete(__p);
  }

void sub_10010FCA0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10010FCE0(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2[1];
  if (*a2 == v3) {
    return 0LL;
  }
  int v4 = 0;
  do
  {
    uint64_t v5 = *(unsigned int *)(v2 + 616);
    if ((_DWORD)v5 == -1) {
      sub_100017130();
    }
    uint64_t v8 = &v7;
    v4 += ((uint64_t (*)(char **, uint64_t))off_1001884D8[v5])(&v8, v2);
    v2 += 620LL;
  }

  while (v2 != v3);
  return v4;
}

uint64_t sub_10010FD6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!a4) {
    return 0LL;
  }
  uint64_t v6 = a4;
  uint64_t v9 = 0LL;
  unint64_t v10 = *(unsigned int *)(*(void *)(*(void *)(a1 + 40) + 48LL) + 52LL);
  while (1)
  {
    uint64_t v11 = sub_10010FEBC(a2, (a5 + v9) / v10, (const void *)(a3 + v9), (void *)(a3 + v9), 1LL);
    if ((_DWORD)v11) {
      break;
    }
    v9 += v10;
    if (!--v6) {
      return 0LL;
    }
  }

  uint64_t v13 = v11;
  *(void *)&__int128 v14 = "crypto_format_backend::crypt_chunk(crypto::format::aes_context &, char *, size_t, uint64_t)";
  *((void *)&v14 + sub_1000F1940(&v11, 1) = 34LL;
  int v15 = 16;
  sub_10011014C(v16, &v14);
  sub_100004E4C(&v17, (uint64_t)"Crypto operation on data of ", 28LL);
  std::ostream::operator<<(&v17, (a5 + v9) / v10);
  sub_100004E4C(&v17, (uint64_t)" failed with ", 13LL);
  std::ostream::operator<<(&v17, v13);
  std::ostream::~ostream(&v17, off_100188A18);
  sub_100112B2C((uint64_t)v16);
  std::ios::~ios(&v18);
  else {
    return -(int)v13;
  }
}

void sub_10010FEA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t sub_10010FEBC(uint64_t a1, uint64_t a2, const void *a3, void *a4, uint64_t a5)
{
  unint64_t v10 = *(const void **)(a1 + 56);
  LODWORD(v13) = bswap32(a2);
  memcpy(&__dst, v10, sizeof(__dst));
  CCHmacUpdate(&__dst, &v13, 4uLL);
  CCHmacFinal(&__dst, macOut);
  uint64_t v11 = CCCryptorReset(*(CCCryptorRef *)(a1 + 8), macOut);
  if ((_DWORD)v11)
  {
    *(void *)&__int128 v13 = "crypto::format::aes_context::crypt(uint32_t, const void *, void *, size_t)";
    *((void *)&v13 + sub_1000F1940(&v11, 1) = 34LL;
    int v14 = 16;
    sub_100111B48(&__dst, &v13);
    sub_100004E4C(&__dst.ctx[90], (uint64_t)"CommonCryptoReset @ ", 20LL);
    std::ostream::operator<<(&__dst.ctx[90], a2);
    sub_100004E4C(&__dst.ctx[90], (uint64_t)"/", 1LL);
    std::ostream::operator<<(&__dst.ctx[90], *(void *)(a1 + 48) * a5);
    sub_100004E4C(&__dst.ctx[90], (uint64_t)" returned ", 10LL);
    std::ostream::operator<<(&__dst.ctx[90], v11);
    std::ostream::~ostream(&__dst.ctx[90], off_1001885D8);
    sub_100111D94((uint64_t)&__dst);
  }

  else
  {
    uint64_t v11 = CCCryptorUpdate(*(CCCryptorRef *)(a1 + 8), a3, *(void *)(a1 + 48) * a5, a4, *(void *)(a1 + 48) * a5, 0LL);
    if (!(_DWORD)v11) {
      return 0LL;
    }
    *(void *)&__int128 v13 = "crypto::format::aes_context::crypt(uint32_t, const void *, void *, size_t)";
    *((void *)&v13 + sub_1000F1940(&v11, 1) = 34LL;
    int v14 = 16;
    sub_100111C30(&__dst, &v13);
    sub_100004E4C(&__dst.ctx[90], (uint64_t)"CommonCryptoUpdate @ ", 21LL);
    std::ostream::operator<<(&__dst.ctx[90], a2);
    sub_100004E4C(&__dst.ctx[90], (uint64_t)"/", 1LL);
    std::ostream::operator<<(&__dst.ctx[90], *(void *)(a1 + 48) * a5);
    sub_100004E4C(&__dst.ctx[90], (uint64_t)" returned ", 10LL);
    std::ostream::operator<<(&__dst.ctx[90], v11);
    std::ostream::~ostream(&__dst.ctx[90], off_1001887F8);
    sub_1001123BC((uint64_t)&__dst);
  }

  std::ios::~ios(&__dst.ctx[92]);
  else {
    return -(int)v11;
  }
}

void sub_100110118(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void *sub_10011014C(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_100113BC0((uint64_t)a1, a2);
  *a1 = off_100188950;
  a1[45] = &off_100188A50;
  a1[46] = &off_100188A78;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose(va, 8) = -1;
  *a1 = off_100188950;
  a1[45] = off_1001889D8;
  a1[46] = off_100188A00;
  return a1;
}

void sub_1001101D0(_Unwind_Exception *a1)
{
}

uint64_t sub_1001101F4(uint64_t a1)
{
  return a1;
}

uint64_t sub_100110234(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  if (a4 < 0x21) {
    return sub_10010FD6C(a1, a2, a3, a4, a5);
  }
  int v10 = *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 48LL) + 52LL);
  if (qos_class_self() <= 0x14) {
    return sub_10010FD6C(a1, a2, a3, a4, a5);
  }
  unsigned int v14 = 0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = sub_100110320;
  block[3] = &unk_1001883C8;
  block[4] = a1;
  block[5] = a4;
  block[6] = a2;
  block[7] = a3;
  int v13 = v10;
  block[8] = a5;
  block[9] = &v14;
  dispatch_apply((a4 + 31) >> 5, 0LL, block);
  return atomic_load(&v14);
}

uint64_t sub_100110320(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = 32 * a2;
  uint64_t v4 = *(void *)(a1 + 32);
  else {
    uint64_t v5 = *(void *)(a1 + 40) - 32 * a2;
  }
  sub_10010F414( (uint64_t)v8,  *(_DWORD *)(*(void *)(a1 + 48) + 16LL),  *(void *)(a1 + 48) + 24LL,  *(void *)(*(void *)(a1 + 48) + 56LL),  *(void *)(*(void *)(a1 + 48) + 48LL));
  unsigned int v6 = sub_10010FD6C( v4,  (uint64_t)v8,  *(void *)(a1 + 56) + v3 * *(unsigned int *)(a1 + 80),  v5,  v3 * *(unsigned int *)(a1 + 80) + *(void *)(a1 + 64));
  if (v6) {
    atomic_store(v6, *(unsigned int **)(a1 + 72));
  }
  return sub_10010F518((uint64_t)v8);
}

void sub_1001103B4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1001103C8(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  if (!a3) {
    return 0LL;
  }
  uint64_t v8 = *(void *)(*(void *)(a1 + 40) + 48LL);
  uint64_t v9 = *(unsigned int *)(v8 + 52);
  if ((*(_BYTE *)(a1 + 192) & 1) != 0) {
    uint64_t v10 = 0LL;
  }
  else {
    uint64_t v10 = *(void *)(v8 + 64);
  }
  uint64_t v11 = v10 + a4;
  unint64_t v12 = v9 * a3;
  uint64_t v13 = sub_100033014(*(void *)(a1 + 24), a2, v9 * a3, v10 + a4);
  if ((v13 & 0x80000000) == 0) {
    return sub_100110234(a1, a1 + 120, a2, a3, a4);
  }
  uint64_t v15 = v13;
  *(void *)&__int128 v16 = "crypto_format_backend::read_aligned(char *, ssize_t, uint64_t)";
  *((void *)&v16 + sub_1000F1940(&v11, 1) = 35LL;
  int v17 = 16;
  sub_10011053C(v18, &v16);
  sub_100004E4C(&v19, (uint64_t)"Crypto couldn't read from inner backend @ ", 42LL);
  std::ostream::operator<<(&v19, v11);
  sub_100004E4C(&v19, (uint64_t)"/", 1LL);
  std::ostream::operator<<(&v19, v12);
  std::ostream::~ostream(&v19, off_100188C38);
  sub_1001130D8((uint64_t)v18);
  std::ios::~ios(&v20);
  return v15;
}

void sub_100110524(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void *sub_10011053C(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_100113C3C((uint64_t)a1, a2);
  *a1 = off_100188B70;
  a1[45] = &off_100188C70;
  a1[46] = &off_100188C98;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose(va, 8) = -1;
  *a1 = off_100188B70;
  a1[45] = off_100188BF8;
  a1[46] = off_100188C20;
  return a1;
}

void sub_1001105C0(_Unwind_Exception *a1)
{
}

uint64_t sub_1001105E4(uint64_t a1)
{
  return a1;
}

uint64_t sub_100110624(uint64_t a1, char **a2)
{
  uint64_t v4 = *a2;
  uint64_t v6 = (uint64_t)a2[2];
  uint64_t v5 = a2[3];
  uint64_t v7 = *(unsigned int *)(*(void *)(*(void *)(a1 + 40) + 48LL) + 52LL);
  uint64_t v8 = (unint64_t)v5 / v7 * v7;
  unint64_t v9 = (unint64_t)v5 % v7;
  if ((unint64_t)v5 % v7)
  {
    uint64_t result = sub_1001103C8(a1, *(void *)(a1 + 184), 1uLL, (unint64_t)v5 / v7 * v7);
    if ((_DWORD)result) {
      return result;
    }
    unint64_t v11 = v9;
    else {
      size_t v12 = v6;
    }
    memcpy(v4, (const void *)(*(void *)(a1 + 184) + v11), v12);
    v6 -= v12;
    v4 += v12;
    v8 += v7;
  }

  uint64_t result = sub_1001103C8(a1, (uint64_t)v4, v6 / v7, v8);
  if ((_DWORD)result) {
    return result;
  }
  if (!(v6 % v7)) {
    return *((unsigned int *)a2 + 4);
  }
  uint64_t result = sub_1001103C8(a1, *(void *)(a1 + 184), 1uLL, v6 - v6 % v7 + v8);
  if (!(_DWORD)result)
  {
    memcpy(&v4[v6 / v7 * v7], *(const void **)(a1 + 184), v6 % v7);
    return *((unsigned int *)a2 + 4);
  }

  return result;
}

uint64_t sub_100110730(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(*(void *)(a1 + 40) + 48LL);
  if ((*(_BYTE *)(a1 + 192) & 1) != 0) {
    uint64_t v9 = 0LL;
  }
  else {
    uint64_t v9 = *(void *)(v8 + 64);
  }
  uint64_t v10 = *(unsigned int *)(v8 + 52);
  uint64_t v11 = sub_100110234(a1, a1 + 56, a2, a3, a4);
  if (!(_DWORD)v11)
  {
    uint64_t v12 = v9 + a4;
    uint64_t v13 = v10 * a3;
    uint64_t v14 = sub_100038458(*(void *)(a1 + 24), a2, v13, v12);
    if ((v14 & 0x80000000) != 0)
    {
      uint64_t v11 = v14;
      *(void *)&__int128 v16 = "crypto_format_backend::write_aligned(char *, ssize_t, uint64_t)";
      *((void *)&v16 + sub_1000F1940(&v11, 1) = 36LL;
      int v17 = 16;
      sub_100110890(v18, &v16);
      sub_100004E4C(&v19, (uint64_t)"Crypto couldn't write to inner backend @ ", 41LL);
      std::ostream::operator<<(&v19, v12);
      sub_100004E4C(&v19, (uint64_t)"/", 1LL);
      std::ostream::operator<<(&v19, v13);
      std::ostream::~ostream(&v19, off_100188E58);
      sub_100113684((uint64_t)v18);
      std::ios::~ios(&v20);
    }

    else
    {
      return 0LL;
    }
  }

  return v11;
}

void sub_100110878(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void *sub_100110890(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_100113CB8((uint64_t)a1, a2);
  *a1 = off_100188D90;
  a1[45] = &off_100188E90;
  a1[46] = &off_100188EB8;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose(va, 8) = -1;
  *a1 = off_100188D90;
  a1[45] = off_100188E18;
  a1[46] = off_100188E40;
  return a1;
}

void sub_100110914(_Unwind_Exception *a1)
{
}

uint64_t sub_100110938(uint64_t a1)
{
  return a1;
}

uint64_t sub_100110978(uint64_t a1, char **a2)
{
  uint64_t v4 = *a2;
  int64_t v6 = (int64_t)a2[2];
  uint64_t v5 = a2[3];
  int64_t v7 = *(unsigned int *)(*(void *)(*(void *)(a1 + 40) + 48LL) + 52LL);
  uint64_t v8 = (unint64_t)v5 / v7 * v7;
  unint64_t v9 = (unint64_t)v5 % v7;
  if ((unint64_t)v5 % v7)
  {
    uint64_t result = sub_1001103C8(a1, *(void *)(a1 + 184), 1uLL, (unint64_t)v5 / v7 * v7);
    if ((_DWORD)result) {
      return result;
    }
    uint64_t v12 = &v4[v9];
    size_t v13 = v6 >= (uint64_t)(v7 - v9) ? v7 - v9 : v6;
    memcpy(*(void **)(a1 + 184), v12, v13);
    uint64_t result = sub_100110730(a1, *(void *)(a1 + 184), 1uLL, v8);
    if ((_DWORD)result) {
      return result;
    }
    v6 -= v13;
    v4 += v13;
    v8 += v13;
  }

  if (!*((_BYTE *)a2 + 40))
  {
    uint64_t v10 = v6 / v7;
    uint64_t result = sub_100110730(a1, (uint64_t)v4, v6 / v7, v8);
    if ((_DWORD)result) {
      return result;
    }
    v4 += v10 * v7;
    v8 += v10 * v7;
    v6 %= v7;
    goto LABEL_5;
  }

  if (v6 < v7)
  {
LABEL_5:
    if (!v6) {
      return *((unsigned int *)a2 + 4);
    }
    uint64_t result = sub_1001103C8(a1, *(void *)(a1 + 184), 1uLL, v8);
    if (!(_DWORD)result)
    {
      memcpy(*(void **)(a1 + 184), v4, v6);
      uint64_t result = sub_100110730(a1, *(void *)(a1 + 184), 1uLL, v8);
      if (!(_DWORD)result) {
        return *((unsigned int *)a2 + 4);
      }
    }

    return result;
  }

  uint64_t v14 = 0LL;
  while (1)
  {
    memcpy(*(void **)(a1 + 184), &v4[v14], v7);
    uint64_t result = sub_100110730(a1, *(void *)(a1 + 184), 1uLL, v8 + v14);
    if ((_DWORD)result) {
      return result;
    }
    v6 -= v7;
    v14 += v7;
    if (v6 < v7)
    {
      v4 += v14;
      v8 += v14;
      goto LABEL_5;
    }
  }

uint64_t sub_100110B04(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  if ((*(_BYTE *)(a1 + 192) & 1) != 0) {
    uint64_t v4 = 0LL;
  }
  else {
    uint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 40) + 48LL) + 64LL);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 24LL))(v3, v4 + a2);
}

uint64_t sub_100110B38(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a1 + 192);
  uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 48LL);
  if ((v3 & 2) == 0) {
    *(void *)(v4 + 56) = a2;
  }
  uint64_t v5 = *(void *)(a1 + 24);
  if ((v3 & 1) != 0) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = *(void *)(v4 + 64);
  }
  uint64_t v7 = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v5 + 56LL))( v5,  (a2 + (unint64_t)*(unsigned int *)(v4 + 52) - 1)
       / *(unsigned int *)(v4 + 52)
  if (!(_DWORD)v7)
  {
    sub_10010D594(*(void *)(*(void *)(a1 + 40) + 48LL), (uint64_t)v21);
    unint64_t v9 = (std::__shared_weak_count *)*((void *)sub_100118DDC() + 1);
    __int128 v16 = v21;
    int v17 = v9;
    if (v9)
    {
      uint64_t p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        unint64_t v11 = __ldxr(p_shared_owners);
      while (__stxr(v11 + 1, p_shared_owners));
    }

    __int128 v18 = xmmword_100142090;
    uint64_t v19 = 76LL;
    char v20 = 0;
    unsigned int v12 = (*(uint64_t (**)(void, _BYTE **))(**(void **)(a1 + 24) + 80LL))(*(void *)(a1 + 24), &v16);
    size_t v13 = v17;
    if ((void)v18 == v12) {
      uint64_t v7 = 0LL;
    }
    else {
      uint64_t v7 = v12;
    }
    if (v17)
    {
      uint64_t v14 = (unint64_t *)&v17->__shared_owners_;
      do
        unint64_t v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
  }

  return v7;
}

void sub_100110C88(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

const void **sub_100110CA4(uint64_t a1, char *a2)
{
  return sub_10010D638(*(void *)(*(void *)(a1 + 40) + 48LL), a2);
}

uint64_t sub_100110CB0(uint64_t a1, uint64_t a2, uint64_t *a3, _DWORD *a4)
{
  (*(void (**)(uint64_t *__return_ptr))(**(void **)a2 + 72LL))(&v14);
  sub_1000376FC((void *)a1, &v14);
  uint64_t v7 = v15;
  if (v15)
  {
    uint64_t p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      unint64_t v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

  *(void *)a1 = off_1001883F8;
  *(void *)(a1 + 4sub_1000F1278((int *)&v3, 0) = *a3;
  uint64_t v10 = a3[1];
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = v10;
  if (v10)
  {
    unint64_t v11 = (unint64_t *)(v10 + 8);
    do
      unint64_t v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }

  sub_10010F414(a1 + 56, 0, *a3, *(void *)(*a3 + 56), *(unsigned int *)(*(void *)(*a3 + 48) + 52LL));
  sub_10010F414(a1 + 120, 1u, *a3, *(void *)(*a3 + 56), *(unsigned int *)(*(void *)(*a3 + 48) + 52LL));
  *(void *)(a1 + 184) = operator new[](*(unsigned int *)(*(void *)(*a3 + 48) + 52LL));
  *(_DWORD *)(a1 + 19sub_1000F1278(&v6, 2) = *a4;
  return a1;
}

void sub_100110DD4(_Unwind_Exception *a1)
{
}

uint64_t sub_100110E14(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = sub_1000376FC((void *)a1, a3);
  *uint64_t v5 = off_1001883F8;
  uint64_t v6 = *(void *)(a2 + 48);
  v5[5] = *(void *)(a2 + 40);
  v5[6] = v6;
  if (v6)
  {
    uint64_t v7 = (unint64_t *)(v6 + 8);
    do
      unint64_t v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }

  sub_10010F414(a1 + 56, *(_DWORD *)(a2 + 72), a2 + 80, *(void *)(a2 + 112), *(void *)(a2 + 104));
  sub_10010F414(a1 + 120, *(_DWORD *)(a2 + 136), a2 + 144, *(void *)(a2 + 176), *(void *)(a2 + 168));
  *(void *)(a1 + 184) = operator new[](*(unsigned int *)(*(void *)(*(void *)(a2 + 40) + 48LL) + 52LL));
  *(_DWORD *)(a1 + 19sub_1000F1278(&v6, 2) = *(_DWORD *)(a2 + 192);
  return a1;
}

void sub_100110ED0(_Unwind_Exception *a1)
{
}

double sub_100110F0C@<D0>(uint64_t a1@<X0>, void *a2@<X1>, _OWORD *a3@<X8>)
{
  double result = v5[0];
  *a3 = *(_OWORD *)v5;
  return result;
}

uint64_t sub_100110F4C(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 192) & 2) != 0 || (uint64_t result = *(void *)(*(void *)(*(void *)(a1 + 40) + 48LL) + 56LL)) == 0)
  {
    unint64_t v3 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 40LL))(*(void *)(a1 + 24));
    if ((*(_BYTE *)(a1 + 192) & 1) != 0) {
      unint64_t v4 = 0LL;
    }
    else {
      unint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 40) + 48LL) + 64LL);
    }
    if (v3 <= v4)
    {
      return 0LL;
    }

    else
    {
      uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 40LL))(*(void *)(a1 + 24));
      if ((*(_BYTE *)(a1 + 192) & 1) != 0) {
        uint64_t v6 = 0LL;
      }
      else {
        uint64_t v6 = *(void *)(*(void *)(*(void *)(a1 + 40) + 48LL) + 64LL);
      }
      return v5 - v6;
    }
  }

  return result;
}

void sub_100110FF0(void *a1)
{
  uint64_t v1 = sub_100113A6C(a1);
  operator delete(v1);
}

void *sub_100111004(uint64_t a1, void *a2)
{
  return sub_100004E4C(a2, (uint64_t)"crypto", 6LL);
}

void *sub_100111018(void *a1, size_t a2, _BYTE *a3)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if (a2)
  {
    size_t v5 = a2;
    sub_10005692C(a1, a2);
    uint64_t v6 = (_BYTE *)a1[1];
    uint64_t v7 = &v6[v5];
    do
    {
      *v6++ = *a3;
      --v5;
    }

    while (v5);
    a1[1] = v7;
  }

  return a1;
}

void sub_100111078(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(va, 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void *sub_100111094(void *result, const void *a2, uint64_t a3, size_t __sz)
{
  if (__sz)
  {
    uint64_t v6 = result;
    uint64_t result = sub_10005692C(result, __sz);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }

  return result;
}

void sub_1001110F0(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(va, 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_10011110C(unint64_t *a1, size_t a2)
{
  size_t v5 = (char *)a1[1];
  unint64_t v4 = (char *)a1[2];
  if (v4 - v5 >= a2)
  {
    if (a2)
    {
      bzero((void *)a1[1], a2);
      v5 += a2;
    }

    a1[1] = (unint64_t)v5;
  }

  else
  {
    unint64_t v6 = *a1;
    uint64_t v7 = &v5[-*a1];
    unint64_t v8 = (unint64_t)&v7[a2];
    unint64_t v9 = (unint64_t)&v4[-v6];
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v10 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v10 = v8;
    }
    if (v10) {
      unint64_t v11 = (unint64_t)operator new(v10);
    }
    else {
      unint64_t v11 = 0LL;
    }
    unint64_t v12 = &v7[v11];
    size_t v13 = (char *)(v11 + v10);
    bzero(v12, a2);
    if (v5 == (char *)v6)
    {
      unint64_t v11 = (unint64_t)v12;
    }

    else
    {
      uint64_t v14 = &v5[~v6];
      do
      {
        char v15 = *--v5;
        (v14--)[v11] = v15;
      }

      while (v5 != (char *)v6);
      size_t v5 = (char *)*a1;
    }

    *a1 = v11;
    a1[1] = (unint64_t)&v12[a2];
    a1[2] = (unint64_t)v13;
    if (v5) {
      operator delete(v5);
    }
  }

uint64_t sub_100111234(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = 0x2FE592FE592FE593LL * ((a1[1] - *a1) >> 2);
  unint64_t v5 = v4 + 1;
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x2FE592FE592FE593LL * ((a1[2] - v3) >> 2);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x34DA034DA034DALL) {
    unint64_t v9 = 0x69B4069B4069B4LL;
  }
  else {
    unint64_t v9 = v5;
  }
  int v17 = a1 + 2;
  if (v9) {
    size_t v10 = (char *)sub_100111570(v7, v9);
  }
  else {
    size_t v10 = 0LL;
  }
  __p = v10;
  uint64_t v14 = &v10[620 * v4];
  uint64_t v15 = (uint64_t)v14;
  __int128 v16 = &v10[620 * v9];
  *(_DWORD *)(sub_1001113D4((uint64_t)v14, a2) + 616) = 0;
  v15 += 620LL;
  sub_100111494(a1, &__p);
  uint64_t v11 = a1[1];
  if (__p) {
    operator delete(__p);
  }
  return v11;
}

void sub_100111380( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1001113D4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = *(_DWORD *)(a2 + 8);
  *(_OWORD *)(a1 + 1sub_1000F1278(&v6, 2) = 0u;
  *(_OWORD *)(a1 + 2_Block_object_dispose(va, 8) = 0u;
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 1sub_1000F1278(&v6, 2) = *(_DWORD *)(a2 + 12);
  __int128 v4 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + sub_1000114F0(v6 - 32) = v4;
  *(_OWORD *)(a1 + 4_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_DWORD *)(a1 + 8sub_1000F1278((int *)&v3, 0) = 0;
  *(_DWORD *)(a1 + 4_Block_object_dispose(va, 8) = *(_DWORD *)(a2 + 48);
  __int128 v5 = *(_OWORD *)(a2 + 52);
  *(_OWORD *)(a1 + 6_Block_object_dispose(va, 8) = *(_OWORD *)(a2 + 68);
  *(_OWORD *)(a1 + 5sub_1000F1278(&v6, 2) = v5;
  *(_DWORD *)(a1 + 84) = *(_DWORD *)(a2 + 84);
  *(_DWORD *)(a1 + 8_Block_object_dispose(va, 8) = *(_DWORD *)(a2 + 88);
  *(_DWORD *)(a1 + 9sub_1000F1278(&v6, 2) = *(_DWORD *)(a2 + 92);
  *(_DWORD *)(a1 + 96) = *(_DWORD *)(a2 + 96);
  bzero((void *)(a1 + 100), 0x204uLL);
  *(_DWORD *)(a1 + 10sub_1000F1278((int *)&v3, 0) = *(_DWORD *)(a2 + 100);
  memcpy((void *)(a1 + 104), (const void *)(a2 + 104), 0x200uLL);
  return a1;
}

uint64_t *sub_100111494(uint64_t *result, void *a2)
{
  uint64_t v3 = result;
  uint64_t v5 = *result;
  uint64_t v4 = result[1];
  uint64_t v6 = a2[1];
  if (v4 != *result)
  {
    uint64_t v7 = v6 - 620;
    do
    {
      uint64_t v8 = v4 - 620;
      *(_BYTE *)uint64_t v7 = 0;
      *(_DWORD *)(v7 + 616) = -1;
      uint64_t v9 = *(unsigned int *)(v4 - 4);
      if ((_DWORD)v9 != -1)
      {
        uint64_t result = (uint64_t *)((uint64_t (*)(char *, uint64_t, uint64_t))off_1001884C8[v9])(&v13, v7, v8);
        *(_DWORD *)(v7 + 616) = v9;
      }

      v7 -= 620LL;
      uint64_t v4 = v8;
    }

    while (v8 != v5);
    uint64_t v6 = v7 + 620;
  }

  a2[1] = v6;
  uint64_t v10 = *v3;
  *uint64_t v3 = v6;
  a2[1] = v10;
  uint64_t v11 = v3[1];
  v3[1] = a2[2];
  a2[2] = v11;
  uint64_t v12 = v3[2];
  _OWORD v3[2] = a2[3];
  a2[3] = v12;
  *a2 = a2[1];
  return result;
}

void *sub_100111570(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x69B4069B4069B5LL) {
    sub_1000116A8();
  }
  return operator new(620 * a2);
}

uint64_t sub_1001115B8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1001113D4(a2, a3);
}

void *sub_1001115C4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)(a2 + sub_1000114F0(v6 - 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_DWORD *)a2 = *(_DWORD *)a3;
  __int128 v5 = *(_OWORD *)(a3 + 4);
  *(_OWORD *)(a2 + 2sub_1000F1278((int *)&v3, 0) = *(_OWORD *)(a3 + 20);
  *(_OWORD *)(a2 + 4) = v5;
  *(_DWORD *)(a2 + 36) = *(_DWORD *)(a3 + 36);
  *(_DWORD *)(a2 + 4sub_1000F1278((int *)&v3, 0) = *(_DWORD *)(a3 + 40);
  *(_DWORD *)(a2 + 44) = *(_DWORD *)(a3 + 44);
  bzero((void *)(a2 + 48), 0x204uLL);
  *(_DWORD *)(a2 + 4_Block_object_dispose(va, 8) = *(_DWORD *)(a3 + 48);
  return memcpy((void *)(a2 + 52), (const void *)(a3 + 52), 0x200uLL);
}

uint64_t sub_100111640(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = 0x2FE592FE592FE593LL * ((a1[1] - *a1) >> 2);
  unint64_t v5 = v4 + 1;
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x2FE592FE592FE593LL * ((a1[2] - v3) >> 2);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x34DA034DA034DALL) {
    unint64_t v9 = 0x69B4069B4069B4LL;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v19 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)sub_100111570(v7, v9);
  }
  else {
    uint64_t v10 = 0LL;
  }
  uint64_t v11 = &v10[620 * v4];
  __p = v10;
  __int128 v16 = v11;
  __int128 v18 = &v10[620 * v9];
  *((_DWORD *)v11 + _Block_object_dispose(va, 8) = 0;
  *(_OWORD *)uint64_t v11 = 0u;
  *((_OWORD *)v11 + sub_1000F1940(&v11, 1) = 0u;
  *(_DWORD *)uint64_t v11 = *(_DWORD *)a2;
  __int128 v12 = *(_OWORD *)(a2 + 4);
  *(_OWORD *)(v11 + 2sub_1000F1278((int *)&v3, 0) = *(_OWORD *)(a2 + 20);
  *(_OWORD *)(v11 + 4) = v12;
  *((_DWORD *)v11 + 9) = *(_DWORD *)(a2 + 36);
  *((_DWORD *)v11 + 1sub_1000F1278((int *)&v3, 0) = *(_DWORD *)(a2 + 40);
  *((_DWORD *)v11 + 1sub_1000F1940(&v11, 1) = *(_DWORD *)(a2 + 44);
  bzero(v11 + 48, 0x204uLL);
  *((_DWORD *)v11 + 1sub_1000F1278(&v6, 2) = *(_DWORD *)(a2 + 48);
  memcpy(v11 + 52, (const void *)(a2 + 52), 0x200uLL);
  *((_DWORD *)v11 + 154) = 1;
  int v17 = v11 + 620;
  sub_100111494(a1, &__p);
  uint64_t v13 = a1[1];
  if (v17 != v16) {
    int v17 = &v16[(v17 - v16 - 620) % 0x26CuLL];
  }
  if (__p) {
    operator delete(__p);
  }
  return v13;
}

void sub_1001117E0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100111834(void *a1, size_t a2)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if (a2)
  {
    sub_10005692C(a1, a2);
    uint64_t v4 = (char *)a1[1];
    unint64_t v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }

  return a1;
}

void sub_100111888(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(va, 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1001118A4()
{
  return 616LL;
}

uint64_t sub_1001118AC()
{
  return 564LL;
}

void *sub_1001118B4(void *a1, size_t a2)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if (a2)
  {
    sub_10005692C(a1, a2);
    uint64_t v4 = (char *)a1[1];
    unint64_t v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }

  return a1;
}

void sub_100111908(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(va, 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_100111924(void ***a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  __int128 v7 = xmmword_100140E00;
  int v8 = 9;
  sub_10007EF00((uint64_t)"auth_table_entry_mechanism", 1, &v7, 5LL);
  unint64_t v4 = *v3[1];
  uint64_t v5 = *v3[2] + **v3;
  *(_DWORD *)uint64_t v5 = 0x1000000;
  *(void *)(v5 + 4) = bswap64(v4);
  *(void *)(v5 + 1sub_1000F1278(&v6, 2) = 0x6802000000000000LL;
  **v3 += 20LL;
  uint64_t result = sub_10010E05C(a2, *v3[2] + *v3[1]);
  *v3[1] += 616LL;
  return result;
}

void *sub_100111A0C(void ***a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  __int128 v9 = xmmword_100140E00;
  int v10 = 9;
  sub_10007EF00((uint64_t)"auth_table_entry_mechanism", 2, &v9, 5LL);
  unint64_t v4 = *v3[1];
  uint64_t v5 = *v3[2] + **v3;
  *(_DWORD *)uint64_t v5 = 0x2000000;
  *(void *)(v5 + 4) = bswap64(v4);
  *(void *)(v5 + 1sub_1000F1278(&v6, 2) = 0x3402000000000000LL;
  **v3 += 20LL;
  uint64_t v6 = *v3[2] + *v3[1];
  *(_DWORD *)uint64_t v6 = bswap32(*(_DWORD *)a2);
  __int128 v7 = *(_OWORD *)(a2 + 4);
  *(_OWORD *)(v6 + 2sub_1000F1278((int *)&v3, 0) = *(_OWORD *)(a2 + 20);
  *(_OWORD *)(v6 + 4) = v7;
  *(_DWORD *)(v6 + 36) = bswap32(*(_DWORD *)(a2 + 36));
  *(_DWORD *)(v6 + 4sub_1000F1278((int *)&v3, 0) = bswap32(*(_DWORD *)(a2 + 40));
  *(_DWORD *)(v6 + 44) = bswap32(*(_DWORD *)(a2 + 44));
  *(_DWORD *)(v6 + 4_Block_object_dispose(va, 8) = bswap32(*(_DWORD *)(a2 + 48));
  uint64_t result = memcpy((void *)(v6 + 52), (const void *)(a2 + 52), 0x200uLL);
  *v3[1] += 564LL;
  return result;
}

void *sub_100111B48(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_100111D18((uint64_t)a1, a2);
  *a1 = off_100188510;
  a1[45] = &off_100188610;
  a1[46] = &off_100188638;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose(va, 8) = -1;
  *a1 = off_100188510;
  a1[45] = off_100188598;
  a1[46] = off_1001885C0;
  return a1;
}

void sub_100111BCC(_Unwind_Exception *a1)
{
}

uint64_t sub_100111BF0(uint64_t a1)
{
  return a1;
}

void *sub_100111C30(void *a1, __int128 *a2)
{
  uint64_t v3 = (std::ios_base *)(a1 + 46);
  sub_100112340((uint64_t)a1, a2);
  *a1 = off_100188730;
  a1[45] = &off_100188830;
  a1[46] = &off_100188858;
  std::ios_base::init(v3, a1);
  a1[63] = 0LL;
  *((_DWORD *)a1 + 12_Block_object_dispose(va, 8) = -1;
  *a1 = off_100188730;
  a1[45] = off_1001887B8;
  a1[46] = off_1001887E0;
  return a1;
}

void sub_100111CB4(_Unwind_Exception *a1)
{
}

uint64_t sub_100111CD8(uint64_t a1)
{
  return a1;
}

uint64_t sub_100111D18(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_1001886A8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_100111D80(_Unwind_Exception *a1)
{
}

uint64_t sub_100111D94(uint64_t a1)
{
  *(void *)a1 = off_1001886A8;
  sub_10011200C(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

void sub_100111E30(char *a1)
{
}

uint64_t sub_100111E74(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_100111EA8(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

uint64_t sub_100111EF4(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_1001885D8);
  sub_100111D94(v2);
  return std::ios::~ios(a1 + 8);
}

void sub_100111F2C(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_1001885D8);
  sub_100111D94((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

uint64_t sub_100111F6C(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001885D8);
  sub_100111D94(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_100111FAC(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001885D8);
  sub_100111D94((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

void sub_100111FF8(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100111D94(a1);
  operator delete(v1);
}

uint64_t sub_10011200C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_10011215C((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_100112134( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

int *sub_10011215C(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      int v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 564LL;
    __int16 v25 = 2082;
    unint64_t v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      __int128 v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        __int128 v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 564LL;
      __int16 v25 = 2082;
      unint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_100112340(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_1001888C8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_1001123A8(_Unwind_Exception *a1)
{
}

uint64_t sub_1001123BC(uint64_t a1)
{
  *(void *)a1 = off_1001888C8;
  sub_100112634(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

void sub_100112458(char *a1)
{
}

uint64_t sub_10011249C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1001124D0(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

uint64_t sub_10011251C(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_1001887F8);
  sub_1001123BC(v2);
  return std::ios::~ios(a1 + 8);
}

void sub_100112554(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_1001887F8);
  sub_1001123BC((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

uint64_t sub_100112594(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001887F8);
  sub_1001123BC(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1001125D4(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_1001887F8);
  sub_1001123BC((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

void sub_100112620(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1001123BC(a1);
  operator delete(v1);
}

uint64_t sub_100112634(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_100112784((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_10011275C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

int *sub_100112784(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      int v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 578LL;
    __int16 v25 = 2082;
    unint64_t v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      __int128 v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        __int128 v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 578LL;
      __int16 v25 = 2082;
      unint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_100112968(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100188A18);
  sub_100112B2C(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1001129A0(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100188A18);
  sub_100112B2C(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_1001129E0(char *a1)
{
}

uint64_t sub_100112A24(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_100112A58(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_100112AA4(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100188A18);
  sub_100112B2C((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_100112AE4(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100188A18);
  sub_100112B2C((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_100112B2C(uint64_t a1)
{
  *(void *)a1 = off_100188AE8;
  sub_100112BC8(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_100112BC8(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_100112D30((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_100112CF0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100112D1C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100112B2C(a1);
  operator delete(v1);
}

int *sub_100112D30(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      int v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 690LL;
    __int16 v25 = 2082;
    unint64_t v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      __int128 v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        __int128 v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 690LL;
      __int16 v25 = 2082;
      unint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_100112F14(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100188C38);
  sub_1001130D8(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_100112F4C(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100188C38);
  sub_1001130D8(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_100112F8C(char *a1)
{
}

uint64_t sub_100112FD0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_100113004(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_100113050(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100188C38);
  sub_1001130D8((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_100113090(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100188C38);
  sub_1001130D8((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_1001130D8(uint64_t a1)
{
  *(void *)a1 = off_100188D08;
  sub_100113174(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_100113174(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_1001132DC((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_10011329C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001132C8(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1001130D8(a1);
  operator delete(v1);
}

int *sub_1001132DC(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      int v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 738LL;
    __int16 v25 = 2082;
    unint64_t v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      __int128 v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        __int128 v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 738LL;
      __int16 v25 = 2082;
      unint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

uint64_t sub_1001134C0(uint64_t a1)
{
  uint64_t v2 = a1 - 360;
  std::ostream::~ostream(a1, off_100188E58);
  sub_100113684(v2);
  return std::ios::~ios(a1 + 8);
}

uint64_t sub_1001134F8(void *a1)
{
  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100188E58);
  sub_100113684(v1);
  return std::ios::~ios(v1 + 368);
}

void sub_100113538(char *a1)
{
}

uint64_t sub_10011357C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 64)) {
    std::ostream::write(a1 + 96, a2, a3);
  }
  return a3;
}

uint64_t sub_1001135B0(_BYTE *a1, int a2)
{
  unsigned __int8 v2 = a2;
  if (a1[64])
  {
    if (a2 == -1) {
      (*(void (**)(_BYTE *))(*(void *)a1 + 48LL))(a1);
    }
    else {
      std::ostream::put(a1 + 96, (char)a2);
    }
  }

  return v2;
}

void sub_1001135FC(uint64_t a1)
{
  unsigned __int8 v2 = (void *)(a1 - 360);
  std::ostream::~ostream(a1, off_100188E58);
  sub_100113684((uint64_t)v2);
  std::ios::~ios(a1 + 8);
  operator delete(v2);
}

void sub_10011363C(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24LL);
  std::ostream::~ostream(v1 + 360, off_100188E58);
  sub_100113684((uint64_t)v1);
  std::ios::~ios(v1 + 368);
  operator delete(v1);
}

uint64_t sub_100113684(uint64_t a1)
{
  *(void *)a1 = off_100188F28;
  sub_100113720(a1);
  std::streambuf::~streambuf(a1 + 104);
  std::ios::~ios(a1 + 208);
  return std::streambuf::~streambuf(a1);
}

uint64_t sub_100113720(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v2 = (void *)(a1 + 96);
    uint64_t v3 = a1 + 96 + *(void *)(*(void *)(a1 + 96) - 24LL);
    if ((*(_BYTE *)(v3 + 32) & 5) == 0)
    {
      (*(void (**)(void **__return_ptr, void, void, uint64_t, uint64_t))(**(void **)(v3 + 40) + 32LL))( __p,  *(void *)(v3 + 40),  0LL,  1LL,  16LL);
      if (v7 >= 1)
      {
        sub_1000049D8(a1 + 104, __p);
        sub_100113888((uint64_t *)(a1 + 72), (uint64_t *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
        std::ios_base::clear((std::ios_base *)((char *)v2 + *(void *)(*v2 - 24LL)), 0);
        sub_100004CB0(__p, "");
        sub_100004B48(a1 + 104, (__int128 *)__p);
        if (v6 < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }

  return 0LL;
}

void sub_100113848( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100113874(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100113684(a1);
  operator delete(v1);
}

int *sub_100113888(uint64_t *a1, uint64_t *a2)
{
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *__error();
  if (sub_1000B8654())
  {
    uint64_t v18 = 0LL;
    char v6 = (os_log_s *)sub_1000B85DC();
    uint64_t v7 = *((unsigned __int8 *)a1 + 16);
    if (os_log_type_enabled(v6, *((os_log_type_t *)a1 + 16))) {
      uint64_t v8 = 3LL;
    }
    else {
      uint64_t v8 = 2LL;
    }
    uint64_t v9 = *a1;
    else {
      int v10 = (uint64_t *)*a2;
    }
    *(_DWORD *)buf = 68158466;
    int v20 = v4;
    __int16 v21 = 2080;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = 806LL;
    __int16 v25 = 2082;
    unint64_t v26 = v10;
    uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  v7,  "%.*s: <%lu> %{public}s",  buf,  38);
    if (v11)
    {
      __int128 v12 = (char *)v11;
      fprintf(__stderrp, "%s\n", v11);
      free(v12);
    }
  }

  else
  {
    uint64_t v13 = (os_log_s *)sub_1000B85DC();
    os_log_type_t v14 = *((_DWORD *)a1 + 4);
    if (os_log_type_enabled(v13, v14))
    {
      uint64_t v15 = *a1;
      else {
        __int128 v16 = (uint64_t *)*a2;
      }
      *(_DWORD *)buf = 68158466;
      int v20 = v4;
      __int16 v21 = 2080;
      uint64_t v22 = v15;
      __int16 v23 = 2048;
      uint64_t v24 = 806LL;
      __int16 v25 = 2082;
      unint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, v14, "%.*s: <%lu> %{public}s", buf, 0x26u);
    }
  }

  uint64_t result = __error();
  *uint64_t result = v5;
  return result;
}

void *sub_100113A6C(void *a1)
{
  *a1 = off_1001883F8;
  uint64_t v2 = (void *)a1[23];
  if (v2) {
    operator delete[](v2);
  }
  sub_10010F518((uint64_t)(a1 + 15));
  sub_10010F518((uint64_t)(a1 + 7));
  sub_1000114F0((uint64_t)(a1 + 5));
  *a1 = off_10016A598;
  sub_1000114F0((uint64_t)(a1 + 3));
  uint64_t v3 = (std::__shared_weak_count *)a1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t sub_100113ADC@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  int v4 = (char *)operator new(0x198uLL);
  uint64_t result = sub_100113B34((uint64_t)v4, a1);
  *a2 = v4 + 24;
  a2[1] = v4;
  return result;
}

void sub_100113B20(_Unwind_Exception *a1)
{
}

uint64_t sub_100113B34(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = off_100188FA8;
  CCHmacInit((CCHmacContext *)(a1 + 24), 0, *(const void **)a2, *(void *)(a2 + 8) - *(void *)a2);
  return a1;
}

void sub_100113B74(_Unwind_Exception *a1)
{
}

void sub_100113B88(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_100188FA8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100113B98(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_100188FA8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_100113BC0(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_100188AE8;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_100113C28(_Unwind_Exception *a1)
{
}

uint64_t sub_100113C3C(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_100188D08;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_100113CA4(_Unwind_Exception *a1)
{
}

uint64_t sub_100113CB8(uint64_t a1, __int128 *a2)
{
  *(void *)std::streambuf::basic_streambuf(asub_1000F1940(&v11, 1) = off_100188F28;
  if (*((_DWORD *)a2 + 4) == 2) {
    char v4 = sub_1000B866C();
  }
  else {
    char v4 = 1;
  }
  *(_BYTE *)(a1 + 64) = v4;
  __int128 v5 = *a2;
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = *((void *)a2 + 2);
  *(_OWORD *)(a1 + 7sub_1000F1278(&v6, 2) = v5;
  sub_100004D60(a1 + 96);
  return a1;
}

void sub_100113D20(_Unwind_Exception *a1)
{
}

void sub_100113D34(uint64_t a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  char v6 = operator new(0xE0uLL);
  sub_100113D9C(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  sub_100018774((uint64_t)a3, v6 + 4, (uint64_t)(v6 + 3));
}

void sub_100113D88(_Unwind_Exception *a1)
{
}

void *sub_100113D9C(void *a1, uint64_t a2, void *a3)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10016ECF0;
  sub_100110E14((uint64_t)(a1 + 3), a2, a3);
  return a1;
}