uint64_t sub_100002898(uint64_t result)
{
  int *v1;
  char *v2;
  in_addr v3;
  char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _DWORD *v24;
  uint64_t v25;
  _DWORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _DWORD *v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  int *v48;
  uint64_t v49;
  uint64_t v50;
  int *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  _DWORD *v59;
  _DWORD *v60;
  uint64_t v61;
  uint64_t *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  unsigned int v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  unsigned int v86;
  uint64_t v87;
  int v88;
  int v89;
  int *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  int *v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  int *v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  int *v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  int v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  char v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  in_addr v168;
  uint64_t v169;
  size_t v170;
  int v171;
  int *v172;
  int v173;
  int v174;
  uint64_t *v175;
  _DWORD *v176;
  int *v177;
  uint64_t v178;
  int i;
  _DWORD *v180;
  _DWORD *v181;
  _DWORD *v182;
  _DWORD *v183;
  __int128 v184;
  int v185;
  char __str[1024];
  _BYTE v187[2];
  uint64_t v188;
  char v189;
  __int16 v190;
  char v191;
  int v192;
  int v193;
  int v194;
  int v195;
  int v196;
  int v197;
  __int128 v198;
  _BYTE v199[64];
  _OWORD v200[8];
  _BYTE v201[1236];
  v182 = 0LL;
  v183 = 0LL;
  v180 = 0LL;
  v181 = 0LL;
  v173 = 0;
  if (**(_BYTE **)result != 1) {
    return result;
  }
  v1 = (int *)result;
  v2 = sub_1000501FC( *(unsigned __int8 *)(*(void *)result + 1LL),  *(unsigned __int8 *)(*(void *)result + 2LL),  (unsigned __int8 *)(*(void *)result + 28LL));
  v3.s_addr = *(_DWORD *)(*(void *)v1 + 24LL);
  if (v3.s_addr) {
    v4 = inet_ntoa(v3);
  }
  else {
    v4 = (char *)(*((void *)v1 + 13) + 132LL);
  }
  snprintf(__str, 0x400uLL, "BOOTREQUEST from %s via %s", v2, v4);
  sub_100011A00( (uint64_t)&v180,  (uint64_t)v1,  *((void *)v1 + 19),  0LL,  0LL,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/bootp.c",  82LL);
  v24 = v180;
  if (v180)
  {
    v25 = *((void *)v180 + 15);
    if (!v25 || (sub_100033920(&v183, v25), (v24 = v180) != 0LL))
    {
      if ((*((_BYTE *)v24 + 221) & 1) != 0)
      {
        sub_1000347D8( (uint64_t *)&v181,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/bootp.c",  159LL,  v19,  v20,  v21,  v22,  v23);
        sub_10003E0AC( 0LL,  v1,  (uint64_t)v180,  0LL,  *((void *)v1 + 20),  (uint64_t)v181,  (uint64_t *)v180 + 14,  *(void *)(*((void *)v180 + 16) + 128LL),  0LL);
        v42 = v1[42];
        for (i = v42; i; --i)
        {
          sub_10003E0AC( 0LL,  v1,  (uint64_t)v180,  0LL,  *((void *)v1 + 20),  (uint64_t)v181,  (uint64_t *)v180 + 14,  *(void *)(*(void *)&v1[2 * (v42 - 1) + 44] + 136LL),  *(void **)(*((void *)v180 + 16) + 128LL));
          v42 = i - 1;
        }

        sub_10003E0AC( 0LL,  v1,  (uint64_t)v180,  0LL,  *((void *)v1 + 20),  (uint64_t)v181,  (uint64_t *)v180 + 14,  *((void *)v183 + 19),  *(void **)(*((void *)v180 + 16) + 128LL));
        v48 = (int *)sub_100040D4C(&qword_10008BF80, (uint64_t)v181, 8LL, v43, v44, v45, v46, v47);
        v175 = (uint64_t *)v48;
        if (v48)
        {
          result = sub_100057AF8( &v174,  (unsigned int *)v1,  (uint64_t)v180,  0LL,  *((void *)v1 + 20),  (uint64_t)v181,  (uint64_t *)v180 + 14,  (uint64_t)v48,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/bootp.c",  0xBEu);
          if (!(_DWORD)result)
          {
            if (!v174) {
              result = sub_1000622D4("%s: bootp disallowed", v49, v50, v37, v38, v39, v40, v41, (char)__str);
            }
            goto LABEL_97;
          }
        }

        v51 = (int *)sub_100040D4C(&qword_10008BF80, (uint64_t)v181, 9LL, v37, v38, v39, v40, v41);
        v175 = (uint64_t *)v51;
        if (v51)
        {
          result = sub_100057AF8( &v174,  (unsigned int *)v1,  (uint64_t)v180,  0LL,  *((void *)v1 + 20),  (uint64_t)v181,  (uint64_t *)v180 + 14,  (uint64_t)v51,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/bootp.c",  0xC9u);
          if (!(_DWORD)result)
          {
            if (!v174) {
              result = sub_1000622D4("%s: booting disallowed", v52, v53, v37, v38, v39, v40, v41, (char)__str);
            }
            goto LABEL_97;
          }
        }

        bzero(&v189, 0x5C0uLL);
        if (v1[18]
          || (v59 = v180,
              v60 = v181,
              v61 = *((void *)v1 + 20),
              v62 = (uint64_t *)(v180 + 28),
              v63 = sub_100040D4C(&qword_10008BF80, (uint64_t)v181, 20LL, v54, v55, v56, v57, v58),
              sub_100057AF8( &v174,  (unsigned int *)v1,  (uint64_t)v59,  0LL,  v61,  (uint64_t)v60,  v62,  v63,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/bootp.c",  0xDBu)))
        {
          v175 = 0LL;
          i = 1;
          if (!sub_100040D4C(&qword_10008C168, (uint64_t)v181, 1LL, v54, v55, v56, v57, v58)
            && sub_100034540( &v175,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/bootp.c",  231LL,  v64,  v65,  v66,  v67,  v68))
          {
            if (sub_1000545BC( v175 + 2,  (const void *)(*((void *)v180 + 16) + 108LL),  *(_DWORD *)(*((void *)v180 + 16) + 104LL),  0LL,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/bootp.c",  236LL,  v69))
            {
              sub_100029804( v175 + 3,  qword_10008C1E0,  &i,  0LL,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/bootp.c",  239LL);
              sub_100043E20(&qword_10008C168, (uint64_t)v181, (uint64_t)v175, v75, v76, v77, v78, v79);
            }

            sub_100040E08( (int **)&v175,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/bootp.c",  243LL,  v70,  v71,  v72,  v73,  v74);
          }

          v80 = sub_100041504( (uint64_t)v1,  (uint64_t)&v189,  (uint64_t)v180,  0LL,  0LL,  *((int **)v1 + 20),  v181,  (uint64_t *)v180 + 14,  0,  0,  1,  0LL,  0LL);
          if (v80 <= 0x12C) {
            v86 = 300;
          }
          else {
            v86 = v80;
          }
          v87 = *(void *)v1;
        }

        else
        {
          v87 = *(void *)v1;
          memcpy(v201, (const void *)(*(void *)v1 + 236LL), sizeof(v201));
          v86 = 300;
        }

        v189 = 2;
        v190 = *(_WORD *)(v87 + 1);
        v198 = *(_OWORD *)(v87 + 28);
        v191 = *(_BYTE *)(v87 + 3);
        v88 = *(_DWORD *)(v87 + 8);
        v192 = *(_DWORD *)(v87 + 4);
        v193 = v88;
        v89 = v180[15];
        v194 = *(_DWORD *)(v87 + 12);
        v195 = v89;
        v90 = (int *)sub_100040D4C(&qword_10008BF80, (uint64_t)v181, 22LL, v81, v82, v83, v84, v85);
        v175 = (uint64_t *)v90;
        if (v90
          && sub_100057AF8( &v174,  (unsigned int *)v1,  (uint64_t)v180,  0LL,  *((void *)v1 + 20),  (uint64_t)v181,  (uint64_t *)v180 + 14,  (uint64_t)v90,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/bootp.c",  0x11Bu))
        {
          HIWORD(v193) |= 0x80u;
        }

        v176 = 0LL;
        v177 = 0LL;
        v178 = 0LL;
        v96 = (int *)sub_100040D4C(&qword_10008BF80, (uint64_t)v181, 17LL, v91, v92, v93, v94, v95);
        v175 = (uint64_t *)v96;
        if (v96
          && sub_100057AA4( &v176,  (unsigned int *)v1,  (uint64_t)v180,  0LL,  *((void *)v1 + 20),  (uint64_t)v181,  (uint64_t *)v180 + 14,  (uint64_t)v96,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/bootp.c",  0x125u))
        {
          sub_100034EA8( &v176,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/bootp.c",  297LL,  v97,  v98,  v99,  v100,  v101);
        }

        else
        {
          v108 = *(void *)(*(void *)(*((void *)v180 + 16) + 48LL) + 64LL);
          if (v108 && *(_DWORD *)(v108 + 80) || (v108 = *((void *)v1 + 13), *(_DWORD *)(v108 + 80))) {
            v196 = **(_DWORD **)(v108 + 72);
          }
        }

        v197 = *(_DWORD *)(*(void *)v1 + 24LL);
        v109 = (int *)sub_100040D4C(&qword_10008BF80, (uint64_t)v181, 15LL, v97, v98, v99, v100, v101);
        v175 = (uint64_t *)v109;
        if (v109
          && sub_100057AA4( &v176,  (unsigned int *)v1,  (uint64_t)v180,  0LL,  *((void *)v1 + 20),  (uint64_t)v181,  (uint64_t *)v180 + 14,  (uint64_t)v109,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/bootp.c",  0x13Bu))
        {
          v115 = v178;
          else {
            v116 = v178;
          }
          __memcpy_chk(v200, v177, v116, 1364LL);
          sub_100034EA8( &v176,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/bootp.c",  321LL,  v117,  v118,  v119,  v120,  v121);
        }

        else
        {
          v122 = *(void *)v1;
          v123 = *(_OWORD *)(*(void *)v1 + 124LL);
          v124 = *(_OWORD *)(*(void *)v1 + 140LL);
          v125 = *(_OWORD *)(*(void *)v1 + 156LL);
          v200[0] = *(_OWORD *)(*(void *)v1 + 108LL);
          v200[3] = v125;
          v200[2] = v124;
          v200[1] = v123;
          v126 = *(_OWORD *)(v122 + 188);
          v127 = *(_OWORD *)(v122 + 204);
          v128 = *(_OWORD *)(v122 + 220);
          v200[4] = *(_OWORD *)(v122 + 172);
          v200[7] = v128;
          v200[6] = v127;
          v200[5] = v126;
        }

        v129 = (int *)sub_100040D4C(&qword_10008BF80, (uint64_t)v181, 16LL, v110, v111, v112, v113, v114);
        v175 = (uint64_t *)v129;
        if (v129
          && sub_100057AA4( &v176,  (unsigned int *)v1,  (uint64_t)v180,  0LL,  *((void *)v1 + 20),  (uint64_t)v181,  (uint64_t *)v180 + 14,  (uint64_t)v129,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/bootp.c",  0x14Bu))
        {
          v130 = v178;
          else {
            v131 = v178;
          }
          __memcpy_chk(v199, v177, v131, 1428LL);
          sub_100034EA8( &v176,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/bootp.c",  337LL,  v132,  v133,  v134,  v135,  v136);
        }

        sub_10003D510( 0LL,  v1,  (uint64_t)v180,  0LL,  *((void *)v1 + 20),  (uint64_t)v181,  (uint64_t *)v180 + 14,  *((_DWORD **)v180 + 21));
        sub_100034894( &v181,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/bootp.c",  347LL,  v137,  v138,  v139,  v140,  v141);
        v142 = *(void *)v1;
        v187[1] = *(_BYTE *)(*(void *)v1 + 1LL);
        v143 = *(unsigned __int8 *)(v142 + 2);
        v187[0] = v143 + 1;
        __memcpy_chk(&v188, v142 + 28, v143, 16LL);
        v151 = *((void *)v1 + 13);
        if (!*(_DWORD *)(v151 + 80))
        {
          result = sub_10006221C( "%s: Interface %s appears to have no IPv4 addresses, and so dhcpd cannot select a source address.",  v144,  v145,  v146,  v147,  v148,  v149,  v150,  (char)__str);
          goto LABEL_97;
        }

        v152 = **(_DWORD **)(v151 + 72);
        sub_1000622D4("%s", v144, v145, v146, v147, v148, v149, v150, (char)__str);
        v184 = *(_OWORD *)(v180 + 14);
        v185 = v180[18];
        v160 = sub_100040144((int *)&v184, v153, v154, v155, v156, v157, v158, v159);
        sub_1000501FC( *(unsigned __int8 *)(*(void *)v1 + 1LL),  *(unsigned __int8 *)(*(void *)v1 + 2LL),  (unsigned __int8 *)(*(void *)v1 + 28LL));
        v168.s_addr = *(_DWORD *)(*(void *)v1 + 24LL);
        if (v168.s_addr) {
          inet_ntoa(v168);
        }
        sub_1000622D4("BOOTREPLY for %s to %s (%s) via %s", v161, v162, v163, v164, v165, v166, v167, v160);
        LOWORD(v184) = 528;
        *((void *)&v184 + 1) = 0LL;
        if (v197)
        {
          DWORD1(v184) = v197;
          WORD1(v184) = word_10008C0F4;
          v169 = qword_10008C0A8;
          if (qword_10008C0A8)
          {
            v170 = v86;
            v171 = 0;
LABEL_96:
            result = sub_100039F14(v169, v171, &v189, v170, v152, (uint64_t)&v184, (uint64_t)v187);
            goto LABEL_97;
          }
        }

        else
        {
          else {
            v172 = &v195;
          }
          DWORD1(v184) = *v172;
          WORD1(v184) = word_10008C104;
        }

        *__error() = 0;
        v169 = *((void *)v1 + 13);
        v170 = v86;
        v171 = (int)v1;
        goto LABEL_96;
      }
    }
  }

  v26 = v183;
  if (v183
    || (sub_100029DE4( &v183,  *(_BYTE *)(*(void *)v1 + 1LL),  *(void *)v1 + 28LL,  *(unsigned __int8 *)(*(void *)v1 + 2LL),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/bootp.c",  98LL),  (v26 = v183) != 0LL))
  {
    while (*((void *)v26 + 17))
    {
      v26 = (_DWORD *)*((void *)v26 + 4);
      if (!v26) {
        goto LABEL_17;
      }
    }

    sub_100033920(&v182, (uint64_t)v26);
    if (!v183) {
      goto LABEL_18;
    }
LABEL_17:
    sub_100033924(&v183, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/bootp.c", 108LL);
  }

LABEL_18:
  if (v182)
  {
    sub_100033920(&v183, (uint64_t)v182);
    sub_100033924(&v182, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/bootp.c", 112LL);
  }

  v33 = v180;
  if (!v180)
  {
    sub_1000129D8((uint64_t)&v180, v1, *(void *)(*((void *)v1 + 19) + 72LL), &v173, v29, v30, v31, v32);
    v33 = v180;
    if (!v180)
    {
      result = sub_1000622D4( "%s: BOOTP from dynamic client and no dynamic leases",  0LL,  v27,  v28,  v29,  v30,  v31,  v32,  (char)__str);
      goto LABEL_97;
    }
  }

  v34 = *((void *)v33 + 17);
  if (!v34) {
    goto LABEL_55;
  }
  v35 = *(void *)(v34 + 160);
  if (!v35) {
    goto LABEL_55;
  }
  v36 = *(_DWORD *)(v35 + 216);
  if ((v36 - 4) >= 2)
  {
    if (v36 == 1)
    {
      if (!sub_100028D28((uint64_t *)v1, v35, v27, v28, v29, v30, v31, v32))
      {
        result = sub_1000622D4("%s: load balance to peer %s", v102, v103, v104, v105, v106, v107, v32, (char)__str);
        goto LABEL_97;
      }

      v33 = v180;
    }

  sub_100054390( (uint64_t *)&v34,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  v29,  v12,  v13,  v14,  v15,  v16);
  return v30;
}

LABEL_55:
    result = (uint64_t)sub_100012C74((_DWORD **)v1, (uint64_t)v33, 0LL, 0LL, (uint64_t)__str, 0LL, (uint64_t)v183, v32);
    goto LABEL_97;
  }

  result = sub_1000622D4("%s: not responding%s", (uint64_t)v33, v27, v28, v29, v30, v31, v32, (char)__str);
LABEL_97:
  if (v181) {
    result = sub_100034894( &v181,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/bootp.c",  415LL,  v37,  v38,  v39,  v40,  v41);
  }
  if (v180) {
    result = sub_10003389C(&v180, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/bootp.c", 417LL);
  }
  if (v183) {
    result = sub_100033924(&v183, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/bootp.c", 419LL);
  }
  if (v182) {
    return sub_100033924(&v182, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/bootp.c", 421LL);
  }
  return result;
}

    sub_10005EF20((uint64_t)v18, &v43);
    if (v43)
    {
      if (sub_10005D348( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/protocol.c",  630LL,  (void *)(a1 + 72),  2,  v27,  v28,  v29,  v30,  (const char *)v43))
      {
LABEL_87:
        i = 1LL;
        goto LABEL_39;
      }

      *(_DWORD *)(a1 + 44) = 5;
LABEL_58:
      sub_10005E974((char *)(*(void *)(a1 + 72) + 12LL), (uint64_t)v18, *(_DWORD *)(*(void *)(a1 + 72) + 8LL));
    }

    v31 = *(void *)(a1 + 56);
    if (*(_DWORD *)(a1 + 48))
    {
      v32 = *(void *)(a1 + 56);
    }

    else
    {
      v32 = *(void *)(v31 + 48);
      if (!v32)
      {
        v20 = sub_100062444( (void **)(v31 + 48),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/protocol.c",  658LL);
        if ((_DWORD)v20)
        {
LABEL_38:
          i = v20;
LABEL_39:
          v16 = (uint64_t)v18;
          goto LABEL_16;
        }

        v32 = *(void *)(*(void *)(a1 + 56) + 48LL);
      }
    }

    v20 = sub_100067E40(v32);
    if (!(_DWORD)v20)
    {
      sub_10005D658((int **)(a1 + 64));
      if (*(void *)(a1 + 72)) {
        sub_10005D538( (int **)(a1 + 72),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/protocol.c",  675LL);
      }
      while (1)
      {
        *(_DWORD *)(a1 + 44) = 4;
LABEL_51:
        sub_10005EF90((uint64_t)v18, &v44);
        if (v44)
        {
          *(_DWORD *)(a1 + 44) = 3;
LABEL_54:
          sub_10005E974((char *)(*(void *)(a1 + 64) + 8LL), (uint64_t)v18, *(_DWORD *)(*(void *)(a1 + 64) + 4LL));
          *(_DWORD *)(a1 + 44) = 6;
          goto LABEL_55;
        }

        if (*(_DWORD *)(a1 + 48))
        {
          *(_DWORD *)(a1 + 48) = 0;
        }

        else
        {
          v33 = *(_DWORD *)(*(void *)(a1 + 56) + 72LL);
          if (v33)
          {
            *(_DWORD *)(a1 + 44) = 2;
LABEL_71:
            v34 = *(void *)(a1 + 56);
            if (*(void *)(v34 + 96))
            {
              v45 = 0LL;
              v20 = sub_1000683F8((uint64_t)v18, 0, "input-signature");
              if ((_DWORD)v20) {
                goto LABEL_38;
              }
              v35 = sub_100067E68((uint64_t)v18, 0, "input-authenticator");
              if ((_DWORD)v35)
              {
                i = v35;
                sub_10005D71C(&v45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/protocol.c", 696LL);
                goto LABEL_39;
              }

              v34 = *(void *)(a1 + 56);
            }

            if (sub_10005D348( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/protocol.c",  703LL,  (void *)(v34 + 80),  2,  v8,  v9,  v10,  v11,  (const char *)*(unsigned int *)(v34 + 72)))
            {
              sub_10005D71C(&v45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/protocol.c", 709LL);
              goto LABEL_87;
            }

            sub_10005E974( (char *)(*(void *)(*(void *)(a1 + 56) + 80LL) + 12LL),  (uint64_t)v18,  *(_DWORD *)(*(void *)(a1 + 56) + 72LL));
            v36 = *(void *)(a1 + 56);
            if (*(void *)(v36 + 96))
            {
              v37 = v45[2];
              v38 = v37[2];
              if ((_DWORD)v38 != *(_DWORD *)(v36 + 72)
                || memcmp(v37 + 3, (const void *)(*(void *)(v36 + 80) + 12LL), v38))
              {
                *(_DWORD *)(a1 + 80) = 48;
              }
            }

            sub_10005D71C(&v45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/protocol.c", 728LL);
          }

          v39 = *(void *)(a1 + 56);
          v40 = (const char *)*(unsigned int *)(a1 + 80);
          if ((_DWORD)v40) {
            v41 = sub_100066E1C((void *)a1, 0LL, v40, (const char *)*(unsigned int *)(v39 + 112), 0LL);
          }
          else {
            v41 = sub_100064CB8(v39, (void *)a1);
          }
          if (v41) {
            goto LABEL_87;
          }
          sub_1000235C8(a1 + 56, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/protocol.c", 745LL);
LABEL_40:
          *(_DWORD *)(a1 + 44) = 1;
LABEL_41:
          v21 = a1 + 56;
          v20 = sub_100064338( (void *)(a1 + 56),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/protocol.c",  505LL);
          if ((_DWORD)v20) {
            goto LABEL_38;
          }
          *(_DWORD *)(a1 + 80) = 0;
          sub_10005EF20((uint64_t)v18, (_DWORD *)(*(void *)(a1 + 56) + 88LL));
          v22 = *(void *)(a1 + 56);
          v23 = *(_DWORD *)(v22 + 88);
          if (v23)
          {
            v24 = sub_100066DC8((void *)(v22 + 96), (void *)a1, v23);
            if (v24) {
              *(_DWORD *)(a1 + 80) = v24;
            }
            v20 = sub_100068188((uint64_t)v18, 0, "input-authenticator", *(const char **)(*(void *)v21 + 96LL));
            if ((_DWORD)v20) {
              goto LABEL_38;
            }
            v22 = *(void *)v21;
          }

          sub_10005EF20((uint64_t)v18, (_DWORD *)(v22 + 72));
          sub_10005EF20((uint64_t)v18, (_DWORD *)(*(void *)(a1 + 56) + 104LL));
          sub_10005EF20((uint64_t)v18, &v42);
          v25 = *(void *)(a1 + 56);
          *(_DWORD *)(v25 + 108) = v42;
          sub_10005EF20((uint64_t)v18, (_DWORD *)(v25 + 112));
          sub_10005EF20((uint64_t)v18, (_DWORD *)(*(void *)(a1 + 56) + 116LL));
          v26 = *(_DWORD *)(a1 + 32);
          if (v26 >= 0x19) {
            sub_10005E974(0LL, (uint64_t)v18, v26 - 24);
          }
          *(_DWORD *)(a1 + 48) = 1;
        }
      }
    }

    goto LABEL_38;
  }

  v12 = *(void *)(a1 + 24);
  if (!v12) {
    return 23LL;
  }
  v13 = *(uint64_t (**)(uint64_t, char *, unsigned int *))(*(void *)v12 + 40LL);
  if (!v13) {
    return 23LL;
  }
  return v13(a1, __s1, a3);
}

void *sub_100003390()
{
  qword_10008BD78 = 0LL;
  if (!sub_100034984( &qword_10008BD78,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/class.c",  55LL)) {
    sub_100061FB4("Can't allocate check of default collection", v0, v1, v2, v3, v4, v5, v6, v17);
  }
  uint64_t v7 = qword_10008BD78;
  *(_DWORD *)(qword_10008BD78 + 16) = 3;
  result = sub_1000343B4( (void *)(v7 + 24),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/class.c",  61LL,  v2,  v3,  v4,  v5,  v6);
  if (!(_DWORD)result) {
    sub_100061FB4("Can't allocate default check expression", v9, v10, v11, v12, v13, v14, v15, v17);
  }
  uint64_t v16 = qword_10008BD78;
  *(_DWORD *)(*(void *)(qword_10008BD78 + 24) + 4LL) = 2;
  *(void *)(*(void *)(v16 + 24) + 8LL) = &qword_100088000;
  return result;
}

uint64_t sub_100003428(uint64_t a1)
{
  return sub_10003D510( 0LL,  (int *)a1,  0LL,  0LL,  *(void *)(a1 + 160),  0LL,  &qword_10008C730,  (_DWORD *)qword_10008BD78);
}

uint64_t sub_100003454(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 16);
  if (v3)
  {
    uint64_t v6 = 0LL;
    if (a2) {
      uint64_t v7 = (void *)(a2 + 112);
    }
    else {
      uint64_t v7 = &unk_10008C730;
    }
    while (1)
    {
      v55 = 0LL;
      uint64_t v56 = 0LL;
      uint64_t v57 = 0LL;
      uint64_t v8 = *(void *)(v3 + 112);
      if (v8)
      {
        uint64_t v9 = *(void *)(v3 + 120);
        if (!v9)
        {
          sub_100003728((int *)a1, v3);
LABEL_16:
          uint64_t v6 = 1LL;
          goto LABEL_17;
        }
      }

      else
      {
        uint64_t v9 = *(void *)(v3 + 120);
        if (!v9) {
          goto LABEL_17;
        }
      }

      if (sub_10005618C( &v55,  a1,  a2,  0LL,  *(void *)(a1 + 160),  0LL,  v7,  v9,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/class.c",  129)) {
        BOOL v10 = (_DWORD)v57 == 0;
      }
      else {
        BOOL v10 = 1;
      }
      if (v10) {
        goto LABEL_17;
      }
      v58 = 0LL;
      uint64_t v11 = (uint64_t *)(v3 + 80);
      if (sub_100029804( &v58,  *(void *)(v3 + 80),  v56,  v57,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/class.c",  134LL))
      {
        sub_100034EA8( &v55,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/class.c",  140LL,  v12,  v13,  v14,  v15,  v16);
        sub_100003728((int *)a1, (uint64_t)v58);
        sub_1000338C0(&v58, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/class.c", 143LL);
        goto LABEL_16;
      }

      if (*(_DWORD *)(v3 + 128))
      {
        sub_1000338A0((void **)&v58, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/class.c", 155LL);
        sub_100034128( (uint64_t *)v58 + 17,  *(void *)(v3 + 136),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/class.c",  157LL,  v17,  v18,  v19,  v20);
        sub_1000338BC(v58 + 40, v3, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/class.c", 159LL);
        int v25 = *(_DWORD *)(v3 + 56);
        v26 = v58;
        *((_DWORD *)v58 + 14) = v25;
        *((_DWORD *)v26 + 18) = 1;
        if (!v25) {
          goto LABEL_23;
        }
        v27 = sub_10005CDE4((8 * v25));
        v35 = v58;
        *((void *)v58 + 8) = v27;
        if (v27)
        {
          bzero(v27, 8LL * *((int *)v35 + 14));
          v26 = v58;
LABEL_23:
          sub_100034E60( (uint64_t)(v26 + 88),  (uint64_t)&v55,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/class.c",  184LL,  v21,  v22,  v23,  v24);
          sub_100034EA8( &v55,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/class.c",  185LL,  v36,  v37,  v38,  v39,  v40);
          uint64_t v45 = *v11;
          if (!*v11)
          {
            sub_10002D664( (uint64_t *)(v3 + 80),  0x2EE7u,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/class.c",  188LL,  v41,  v42,  v43,  v44);
            uint64_t v45 = *v11;
          }

          sub_100029214( v45,  *((const char **)v58 + 12),  *((unsigned int *)v58 + 26),  (uint64_t)v58,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/class.c",  193LL,  v43,  v44,  v53);
          sub_100003728((int *)a1, (uint64_t)v58);
          sub_1000338C0(&v58, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/class.c", 195LL);
          goto LABEL_17;
        }

        sub_10006221C("no memory for%s", v28, v29, v30, v31, v32, v33, v34, (char)" billing");
        sub_100034EA8( (_DWORD **)v58 + 11,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/class.c",  173LL,  v47,  v48,  v49,  v50,  v51);
        sub_1000338C0(&v58, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/class.c", 174LL);
        uint64_t v46 = 176LL;
      }

      else
      {
        uint64_t v46 = 147LL;
      }

      sub_100034EA8( &v55,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/class.c",  v46,  v12,  v13,  v14,  v15,  v16);
LABEL_17:
      uint64_t v3 = *(void *)(v3 + 32);
      if (!v3) {
        return v6;
      }
    }
  }

  return 0LL;
}

uint64_t sub_100003728(int *a1, uint64_t a2)
{
  uint64_t v2 = a1[42];
  if ((int)v2 > 4)
  {
    char v4 = sub_1000501FC( *(unsigned __int8 *)(*(void *)a1 + 1LL),  *(unsigned __int8 *)(*(void *)a1 + 2LL),  (unsigned __int8 *)(*(void *)a1 + 28LL));
    return sub_10006221C("too many classes match %s", v5, v6, v7, v8, v9, v10, v11, v4);
  }

  else
  {
    a1[42] = v2 + 1;
    return sub_1000338BC(&a1[2 * v2 + 44], a2, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/class.c", 208LL);
  }
}

uint64_t sub_100003798(uint64_t *a1)
{
  uint64_t v1 = off_100088018;
  if (!off_100088018) {
    return 23LL;
  }
  while (1)
  {
    uint64_t v2 = v1[2];
    if (v2) {
      break;
    }
LABEL_7:
    uint64_t v1 = (uint64_t *)*v1;
    if (!v1) {
      return 23LL;
    }
  }

  uint64_t v3 = *a1;
  if (v2 != *a1)
  {
    while (1)
    {
      uint64_t v4 = *(void *)(v2 + 32);
      if (!v4) {
        goto LABEL_7;
      }
      uint64_t v5 = v2;
      uint64_t v2 = *(void *)(v2 + 32);
      if (v4 == v3) {
        goto LABEL_10;
      }
    }
  }

  uint64_t v5 = 0LL;
LABEL_10:
  uint64_t v7 = v1 + 2;
  if (v5) {
    uint64_t v7 = (void *)(v5 + 32);
  }
  *uint64_t v7 = *(void *)(v3 + 32);
  *(void *)(v3 + 32) = 0LL;
  sub_1000338C0();
  return 0LL;
}

uint64_t sub_100003828(uint64_t a1, char *__s1, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = off_100088018;
  if (!off_100088018) {
    return 23LL;
  }
  while (1)
  {
    uint64_t v9 = v4[2];
    if (v9) {
      break;
    }
LABEL_6:
    uint64_t v4 = (uint64_t *)*v4;
    if (!v4) {
      return 23LL;
    }
  }

  while (1)
  {
    uint64_t v10 = *(const char **)(v9 + 48);
    if (v10)
    {
      if (!strcmp(__s1, v10)) {
        return sub_1000338BC(a1, v9, a3, a4);
      }
    }

    uint64_t v9 = *(void *)(v9 + 32);
    if (!v9) {
      goto LABEL_6;
    }
  }

uint64_t sub_1000038C0( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(unsigned int *)(a2 + 56);
  if ((int)v9 < 1)
  {
    LODWORD(v10) = 0;
  }

  else
  {
    uint64_t v10 = 0LL;
    while (*(void *)(*(void *)(a2 + 64) + 8 * v10) != a1)
    {
      if (v9 == ++v10) {
        goto LABEL_8;
      }
    }
  }

  if ((_DWORD)v10 == (_DWORD)v9)
  {
LABEL_8:
    __int128 v20 = *(_OWORD *)(a1 + 56);
    int v21 = *(_DWORD *)(a1 + 72);
    char v11 = sub_100040144((int *)&v20, a2, a3, a4, a5, a6, a7, a8);
    sub_10006221C("lease %s unbilled with no billing arrangement.", v12, v13, v14, v15, v16, v17, v18, v11);
    return 0LL;
  }

  else
  {
    sub_1000338C0(a1 + 144, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/class.c", 268LL);
    sub_10003389C( (_DWORD **)(*(void *)(a2 + 64) + 8LL * v10),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/class.c",  269LL);
    --*(_DWORD *)(a2 + 60);
    return 1LL;
  }

uint64_t sub_1000039C0( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = a1 + 144;
  if (*(void *)(a1 + 144))
  {
    sub_10006221C("lease billed with existing billing arrangement.", a2, a3, a4, a5, a6, a7, a8, v20);
    sub_1000038C0(a1, *(void *)(a1 + 144), v11, v12, v13, v14, v15, v16);
  }

  uint64_t v17 = *(unsigned int *)(a2 + 56);
  if (*(_DWORD *)(a2 + 60) == (_DWORD)v17) {
    return 0LL;
  }
  if ((int)v17 < 1)
  {
    LODWORD(v18) = 0;
  }

  else
  {
    uint64_t v18 = 0LL;
    while (*(void *)(*(void *)(a2 + 64) + 8 * v18))
    {
      if (v17 == ++v18) {
        goto LABEL_11;
      }
    }
  }

  if ((_DWORD)v18 == (_DWORD)v17)
  {
LABEL_11:
    sub_10006221C("class billing consumption disagrees with leases.", a2, a3, a4, a5, a6, a7, a8, v20);
    return 0LL;
  }

  sub_100033898( *(void *)(a2 + 64) + 8LL * v18,  a1,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/class.c",  297LL);
  sub_1000338BC(v10, a2, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/class.c", 298LL);
  ++*(_DWORD *)(a2 + 60);
  return 1LL;
}

void *sub_100003AA4()
{
  qword_10008BD88 = (uint64_t)sub_100068E0C( "readconf",  0LL,  (uint64_t)sub_100003B2C,  (uint64_t)nullsub_1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  51LL);
  result = sub_100068E0C( "readleases",  0LL,  (uint64_t)sub_100003B2C,  (uint64_t)nullsub_1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  54LL);
  qword_10008BD90 = (uint64_t)result;
  return result;
}

uint64_t **sub_100003B2C(uint64_t a1, int a2, char *__s)
{
  uint64_t v29 = 0LL;
  int v6 = strlen(__s);
  unsigned int v7 = ~v6 + a2;
  uint64_t v8 = &__s[v6 + 1];
  if (sub_100068D58()) {
    sub_1000693B0( a1,  a2,  (uint64_t)__s,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  198LL,  v9,  v10,  v11);
  }
  int v19 = sub_100036AA8(&v29, -1, (uint64_t)v8, v7, (uint64_t)__s, 0);
  result = (uint64_t **)v29;
  if (v19) {
    BOOL v21 = v29 == 0LL;
  }
  else {
    BOOL v21 = 0;
  }
  if (!v21)
  {
    if (qword_10008BD90 == a1) {
      sub_100003F68(v29);
    }
    else {
      sub_10000412C(v29, qword_10008C140, 0LL);
    }
    result = (uint64_t **)sub_100036BD4((uint64_t *)&v29, v22, v23, v24, v25, v26, v27, v28);
  }

  if ((byte_10008CF90 & 1) == 0 && qword_10008BD88 == a1)
  {
    result = (uint64_t **)sub_100017784(0, v12, v13, v14, v15, v16, v17, v18);
    byte_10008CF90 = 1;
  }

  if ((byte_10008CF94 & 1) == 0 && qword_10008BD90 == a1)
  {
    sub_10000E250(0);
    byte_10008CF94 = 1;
    return sub_1000182E8();
  }

  return result;
}

uint64_t sub_100003C68()
{
  return sub_100003C8C(off_100088B40[0], qword_10008C140, 0LL, 0);
}

uint64_t sub_100003C8C(const char *a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v8 = &qword_10008BD88;
  if (a4) {
    uint64_t v8 = &qword_10008BD90;
  }
  uint64_t v9 = (void *)*v8;
  if (sub_100068D4C())
  {
    __s = 0LL;
    int v82 = 0;
    uint64_t v10 = sub_100069C24(v9, a1, &v82, (void **)&__s);
    if ((_DWORD)v10) {
      return v10;
    }
    int v11 = v82;
    int v82 = strlen(__s);
    LODWORD(v12) = v11 + ~v82;
    uint64_t v13 = &__s[v82 + 1];
  }

  else
  {
    int v14 = open(a1, 0);
    int v22 = v14;
    if (v14 < 0)
    {
      if (a4)
      {
        sub_10006221C("Can't open lease database %s: %m --", v15, v16, v17, v18, v19, v20, v21, (char)off_100088B48[0]);
        sub_10006221C("  check for failed database %s!", v23, v24, v25, v26, v27, v28, v29, (char)"rewrite attempt");
        sub_10006221C("Please read the dhcpd.leases manual%s", v30, v31, v32, v33, v34, v35, v36, (char)" page if you");
        uint64_t v37 = "don't know what to do about this.";
      }

      else
      {
        char v81 = (char)a1;
        uint64_t v37 = "Can't open %s: %m";
      }

      sub_100061FB4(v37, v15, v16, v17, v18, v19, v20, v21, v81);
    }

    v84 = 0LL;
    unint64_t v12 = lseek(v14, 0LL, 2);
    if ((v12 & 0x8000000000000000LL) != 0 || lseek(v22, 0LL, 0) < 0) {
      sub_100061FB4("Can't lseek on %s: %m", v38, v39, v40, v41, v42, v43, v44, (char)a1);
    }
    if (v12 >> 31) {
      sub_100061FB4("%s: file is too long to buffer.", v38, v39, v40, v41, v42, v43, v44, (char)a1);
    }
    int v45 = strlen(a1);
    int v82 = v45;
    uint64_t v46 = (char *)sub_10005CDE4((v12 + v45 + 1));
    int v54 = v46;
    __s = v46;
    if (!v46) {
      sub_100061FB4("No memory for %s (%d bytes)", v47, v48, v49, v50, v51, v52, v53, (char)a1);
    }
    strcpy(v46, a1);
    uint64_t v13 = &v54[v45 + 1];
    int v55 = read(v22, v13, v12);
    if (v55 < 0) {
      sub_100061FB4("Can't read in %s: %m", v56, v57, v58, v59, v60, v61, v62, (char)a1);
    }
    if (v55 != (_DWORD)v12) {
      sub_100061FB4("%s: short read of %d bytes instead of %d.", v56, v57, v58, v59, v60, v61, v62, (char)a1);
    }
    close(v22);
  }

  if (sub_100068D58()) {
    sub_1000693B0( (uint64_t)v9,  v12 + v82 + 1,  (uint64_t)__s,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  160LL,  v63,  v64,  v65);
  }
  uint64_t v10 = sub_100036AA8(&v84, -1, (uint64_t)v13, v12, (uint64_t)a1, 0);
  if ((_DWORD)v10) {
    BOOL v66 = 1;
  }
  else {
    BOOL v66 = v84 == 0LL;
  }
  if (!v66)
  {
    if (a4) {
      uint64_t v67 = sub_100003F68();
    }
    else {
      uint64_t v67 = sub_10000412C(v84, a2, a3);
    }
    uint64_t v10 = v67;
    sub_100036BD4((uint64_t *)&v84, v68, v69, v70, v71, v72, v73, v74);
    sub_10005CE20( __s,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  174LL,  v75,  v76,  v77,  v78,  v79);
  }

  return v10;
}

uint64_t sub_100003F68(int32x2_t *a1)
{
  while (2)
  {
    while (1)
    {
      int v2 = sub_100036D00(&v19, 0LL, (uint64_t)a1);
      if (v2 > 364) {
        break;
      }
      if (v2 <= 270)
      {
        if (v2 == 256)
        {
          sub_100007FE0(a1, qword_10008C140);
        }

        else
        {
          if (v2 != 270) {
            goto LABEL_22;
          }
          sub_10000745C(0LL, a1, qword_10008C140, 2LL, v6, v7, v8, v9);
        }
      }

      else
      {
        switch(v2)
        {
          case 271:
            uint64_t v18 = 0LL;
            if (sub_100004E94((uint64_t)&v18, a1))
            {
              sub_10002B044((uint64_t)v18, v10, v11, v12, v13, v14, v15, v16);
              sub_10003389C(&v18, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 271LL);
            }

            else
            {
              sub_100046D6C((uint64_t)a1, "possibly corrupt lease file", v11, v12, v13, v14, v15, v16, (char)v18);
            }

            break;
          case 293:
            sub_100008728(a1, qword_10008C140, v4, v5, v6, v7, v8, v9);
            break;
          case 346:
            sub_10000745C(0LL, a1, qword_10008C140, 3LL, v6, v7, v8, v9);
            break;
          default:
            goto LABEL_22;
        }
      }
    }

    switch(v2)
    {
      case 638:
        sub_100005BE8(a1, v3, v4, v5, v6, v7, v8, v9);
        continue;
      case 639:
        sub_10000640C(a1, v3, v4, v5, v6, v7, v8, v9);
        continue;
      case 640:
        sub_100006C30(a1, v3, v4, v5, v6, v7, v8, v9);
        continue;
      case 641:
      case 642:
      case 643:
      case 644:
      case 645:
      case 646:
        goto LABEL_22;
      case 647:
        sub_100008CDC(a1);
        continue;
      default:
        if (v2 == 365)
        {
          sub_1000089F8(a1, 0LL);
          continue;
        }

        if (v2 != 607)
        {
LABEL_22:
          sub_10006221C("Corrupt lease file - possible data loss!", v3, v4, v5, v6, v7, v8, v9, (char)v18);
          sub_100046C44(a1);
          continue;
        }

        if (a1[218].i32[0]) {
          return 45LL;
        }
        else {
          return 0LL;
        }
    }
  }

uint64_t sub_10000412C(int32x2_t *a1, uint64_t a2, uint64_t a3)
{
  if (sub_1000374AC(&v8, 0LL, a1) != 607)
  {
    uint64_t v6 = 0LL;
    do
      uint64_t v6 = sub_1000041D0(a1, a2, a3, 0LL, v6);
    while (sub_1000374AC(&v8, 0LL, a1) != 607);
  }

  sub_100036D00(&v8, 0LL, (uint64_t)a1);
  if (a1[218].i32[0]) {
    return 45LL;
  }
  else {
    return 0LL;
  }
}

uint64_t sub_1000041D0(int32x2_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v221 = 0LL;
  uint64_t v10 = sub_1000374AC(&v223, 0LL, a1);
  uint64_t v17 = v10;
  if ((int)v10 > 345)
  {
    if ((int)v10 <= 633)
    {
      if ((int)v10 <= 379)
      {
        if ((_DWORD)v10 != 346)
        {
          if ((_DWORD)v10 == 351)
          {
            sub_100036D00(&v223, 0LL, (uint64_t)a1);
            if ((_DWORD)a3 == 6)
            {
              v85 = "pool declared within pool.";
            }

            else
            {
              if ((a3 - 4) > 0xFFFFFFFD)
              {
                sub_100009798(a1, a2, a3);
                return a5;
              }

              v85 = "pool declared outside of network";
            }

            goto LABEL_168;
          }

          if ((_DWORD)v10 == 365)
          {
            if ((a3 & 0xFFFFFFFD) == 0)
            {
              sub_100036D00(&v223, 0LL, (uint64_t)a1);
              sub_10000AC14(a1, a2, a3);
              return 0LL;
            }

            sub_100046D6C( (uint64_t)a1,  "failover peers may only be %s",  v11,  v12,  v13,  v14,  v15,  v16,  (char)"defined in shared-network");
            sub_10006221C("declarations and the outer scope.", v27, v28, v29, v30, v31, v32, v33, v219);
            goto LABEL_63;
          }

          goto LABEL_83;
        }

        sub_100036D00(&v223, 0LL, (uint64_t)a1);
        if ((_DWORD)a3 == 4)
        {
LABEL_61:
          BOOL v66 = "class declarations not allowed here.";
LABEL_62:
          sub_100046D6C((uint64_t)a1, v66, v18, v19, v20, v21, v22, v23, (char)v218);
LABEL_63:
          sub_100046C44(a1);
          return 0LL;
        }

        uint64_t v24 = a1;
        uint64_t v25 = a2;
        uint64_t v26 = 3LL;
LABEL_118:
        sub_10000745C(0LL, v24, v25, v26);
        return 1LL;
      }

      switch((_DWORD)v10)
      {
        case 0x17C:
          sub_100036D00(&v223, 0LL, (uint64_t)a1);
          int v86 = 1;
          break;
        case 0x17D:
          sub_100036D00(&v223, 0LL, (uint64_t)a1);
          if (sub_100036D00(&v223, 0LL, (uint64_t)a1) != 380)
          {
            BOOL v66 = "expecting assertion";
            goto LABEL_62;
          }

          int v86 = 0;
          break;
        case 0x239:
          sub_100036D00(&v223, 0LL, (uint64_t)a1);
          if (sub_100036D00(&v223, 0LL, (uint64_t)a1) == 262)
          {
            sub_100046D08(a1);
            return 1LL;
          }

          uint64_t v41 = "filename string expected.";
          goto LABEL_116;
        default:
          goto LABEL_83;
      }

      *(_DWORD *)(a2 + 40) = v86;
      if ((_DWORD)a3 == 1) {
        sub_100046D6C((uint64_t)a1, "authority makes no sense here.", v18, v19, v20, v21, v22, v23, (char)v218);
      }
      sub_100046D08(a1);
      return 0LL;
    }

    if ((int)v10 > 650)
    {
      if ((_DWORD)v10 == 651)
      {
        sub_100036D00(0LL, 0LL, (uint64_t)a1);
        if ((_DWORD)a3 == 3 && *(void *)(a2 + 24))
        {
          sub_10000A4DC(a1, a2, v73, v74, v75, v76, v77, v78);
          return a5;
        }

        v85 = "range6 declaration not allowed here.";
        goto LABEL_168;
      }

      if ((_DWORD)v10 == 657)
      {
        sub_100036D00(0LL, 0LL, (uint64_t)a1);
        if ((_DWORD)a3 == 3 && *(void *)(a2 + 24))
        {
          sub_10000A790(a1, a2, v73, v74, v75, v76, v77, v78);
          return a5;
        }

        v85 = "prefix6 declaration not allowed here.";
        goto LABEL_168;
      }

      if ((_DWORD)v10 != 658) {
        goto LABEL_83;
      }
      sub_100036D00(&v223, 0LL, (uint64_t)a1);
      if (!a4)
      {
        BOOL v66 = "fixed-prefix6 declaration not allowed here.";
        goto LABEL_62;
      }

      sub_10000AA04(a1, a4);
    }

    else
    {
      switch((_DWORD)v10)
      {
        case 0x27A:
LABEL_39:
          sub_100036D00(&v223, 0LL, (uint64_t)a1);
          *(void *)&__int128 v224 = 0LL;
          if (sub_100009634(&v224, a1, v17, v48, v49, v50, v51, v52))
          {
            if (a4)
            {
              if (!*(void *)(a4 + 136))
              {
                a5 = 0LL;
                *(void *)(a4 + 136) = v224;
                return a5;
              }

              sub_100040E08( (int **)&v224,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  587LL,  v54,  v55,  v56,  v57,  v58);
              uint64_t v65 = "Only one fixed address declaration per host.";
LABEL_143:
              sub_100046D6C((uint64_t)a1, v65, v59, v60, v61, v62, v63, v64, (char)v218);
            }

            else
            {
              sub_100046D6C( (uint64_t)a1,  "fixed-address parameter not allowed here.",  v53,  v54,  v55,  v56,  v57,  v58,  (char)v218);
              sub_100040E08( (int **)&v224,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  598LL,  v151,  v152,  v153,  v154,  v155);
            }
          }

          break;
        case 0x27C:
LABEL_43:
          sub_100036D00(&v223, 0LL, (uint64_t)a1);
          if (a3 > 4 || ((1 << a3) & 0x1A) == 0)
          {
            uint64_t v150 = *(void *)(a2 + 32);
            if (v150)
            {
              if ((_DWORD)v17 == 278) {
                sub_100009028(a1, v150);
              }
              else {
                sub_1000092EC(a1, v150, v35, v36, v37, v38, v39, v40);
              }
              return 0LL;
            }

            *(void *)&__int128 v224 = 0LL;
            unsigned int v157 = sub_1000358E4( (void **)&v224,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  456LL);
            if (v157)
            {
              char v162 = sub_100067900(v157);
              sub_100061FB4("Can't allocate shared subnet: %s", v163, v164, v165, v166, v167, v168, v169, v162);
            }

            if (!sub_1000406C0( (uint64_t *)(v224 + 96),  a2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  460LL,  v158,  v159,  v160,  v161)) {
              sub_100061FB4("Can't allocate group for shared net", v170, v171, v172, v173, v174, v175, v176, (char)v218);
            }
            sub_1000235CC( *(void *)(v224 + 96) + 32LL,  v224,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  463LL);
            uint64_t v183 = v224;
            *(_DWORD *)(v224 + 48) |= 1u;
            if ((_DWORD)v17 == 278) {
              sub_100009028(a1, v183);
            }
            else {
              sub_1000092EC(a1, v183, v177, v178, v179, v180, v181, v182);
            }
            uint64_t v185 = *(void *)(v224 + 56);
            if (v185)
            {
              sub_1000235CC( v224 + 64,  *(void *)(v185 + 56),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  481LL);
              v192 = *(_DWORD **)(v224 + 56);
              v193 = v192 + 21;
              if ((_DWORD)v17 == 278) {
                v194 = sub_1000401D8(v193, v192 + 26, v186, v187, v188, v189, v190, v191);
              }
              else {
                v194 = sub_1000402E0(v193, v192[31], v186, v187, v188, v189, v190, v191);
              }
              char v195 = (char)v194;
              v203 = strdup(v194);
              uint64_t v204 = v224;
              *(void *)(v224 + 40) = v203;
              if (!v203) {
                sub_100061FB4( "Out of memory allocating default shared network name (%s).",  v196,  v197,  v198,  v199,  v200,  v201,  v202,  v195);
              }
              *(_DWORD *)(*(void *)(v204 + 96) + 40LL) = *(_DWORD *)(*(void *)(*(void *)(v204 + 56) + 128LL) + 40LL);
              sub_10002AE50(v204);
            }

            sub_1000235C8(&v224, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 504LL);
            return 1LL;
          }

          uint64_t v41 = "subnet declarations not allowed here.";
LABEL_116:
          sub_100046D6C((uint64_t)a1, v41, v35, v36, v37, v38, v39, v40, (char)v218);
          sub_100046C44(a1);
          return 1LL;
        case 0x287:
          sub_10000B5B0(a1);
          break;
        default:
LABEL_83:
          *(void *)&__int128 v224 = 0LL;
          int v220 = 0;
          if (sub_100049EC4((void **)&v224, a1, &v220, 0LL))
          {
            if (!(void)v224) {
              return a5;
            }
LABEL_85:
            v101 = *(void **)(a2 + 48);
            v100 = (void **)(a2 + 48);
            v99 = v101;
            if (v101)
            {
              v102 = (void *)v99[1];
              if (v102)
              {
                int v103 = 0;
                do
                {
                  int v104 = *(_DWORD *)v99;
                  v99 = v102;
                  if (v104 > 1) {
                    int v103 = 1;
                  }
                  v102 = (void *)v102[1];
                }

                while (v102);
                v222 = v99;
                if (v103)
                {
                  v222 = 0LL;
                  if (!sub_100034984( &v222,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  854LL)) {
                    sub_100061FB4("No memory for statements.", v105, v106, v107, v108, v109, v110, v111, (char)v218);
                  }
                  v112 = v222;
                  v222[4] = 10;
                  sub_100033F18( (void *)v112 + 3,  *v100,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  859LL,  v108,  v109,  v110,  v111);
                  sub_100033F18( (void *)v222 + 1,  (_DWORD *)v224,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  860LL,  v113,  v114,  v115,  v116);
                  sub_10003DC78( v100,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  862LL,  v117,  v118,  v119,  v120,  v121);
                  sub_100033F18( v100,  v222,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  864LL,  v122,  v123,  v124,  v125);
                  sub_10003DC78( (void **)&v222,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  865LL,  v126,  v127,  v128,  v129,  v130);
                  goto LABEL_127;
                }
              }

              else
              {
                v222 = v99;
              }

              sub_100033F18( v99 + 1,  (_DWORD *)v224,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  845LL,  v75,  v76,  v77,  v78);
              uint64_t v156 = 846LL;
              goto LABEL_140;
            }

            sub_100033F18( v100,  (_DWORD *)v224,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  868LL,  v75,  v76,  v77,  v78);
LABEL_127:
            uint64_t v156 = 870LL;
LABEL_140:
            sub_10003DC78( (void **)&v224,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  v156,  v131,  v132,  v133,  v134,  v135);
            return a5;
          }

          if (v220) {
            return a5;
          }
          if ((_DWORD)a5)
          {
            v85 = "expecting a declaration";
          }

          else
          {
            v218 = "or declaration";
            v85 = "expecting a parameter %s";
          }

LABEL_168:
          sub_100046D6C((uint64_t)a1, v85, v73, v74, v75, v76, v77, v78, (char)v218);
          sub_100046C44(a1);
          return a5;
      }
    }

    return 0LL;
  }

  if ((int)v10 > 269)
  {
    switch((int)v10)
    {
      case 270:
        sub_100036D00(&v223, 0LL, (uint64_t)a1);
        if ((_DWORD)a3 == 4) {
          goto LABEL_61;
        }
        uint64_t v24 = a1;
        uint64_t v25 = a2;
        uint64_t v26 = 2LL;
        goto LABEL_118;
      case 271:
      case 273:
      case 274:
      case 275:
      case 276:
      case 277:
      case 279:
      case 280:
      case 281:
        goto LABEL_83;
      case 272:
        sub_100036D00(&v223, 0LL, (uint64_t)a1);
        if ((_DWORD)a3 == 3 && *(void *)(a2 + 24))
        {
          sub_100009FC0(a1, a2, 3, 0LL, 0LL);
          return a5;
        }

        v85 = "range declaration not allowed here.";
        goto LABEL_168;
      case 278:
        goto LABEL_43;
      case 282:
        sub_100036D00(&v223, 0LL, (uint64_t)a1);
        if ((_DWORD)a3 == 4) {
          goto LABEL_61;
        }
        uint64_t v24 = a1;
        uint64_t v25 = a2;
        uint64_t v26 = 0LL;
        goto LABEL_118;
      case 283:
        sub_100036D00(&v223, 0LL, (uint64_t)a1);
        if ((_DWORD)a3 == 4) {
          goto LABEL_61;
        }
        a5 = 1LL;
        sub_10000745C(0LL, a1, a2, 1LL);
        return a5;
      case 284:
        sub_100036D00(&v223, 0LL, (uint64_t)a1);
        if ((a3 - 1) <= 3)
        {
          sub_100046D6C( (uint64_t)a1,  "shared-network parameters not %s.",  v79,  v80,  v81,  v82,  v83,  v84,  (char)"allowed here");
          goto LABEL_63;
        }

        sub_100008DBC(a1, a2);
        return 1LL;
      default:
        if ((_DWORD)v10 == 287)
        {
          int v220 = 54;
          if (!sub_100029804( &v221,  qword_10008C1E0,  &v220,  0LL,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  692LL)) {
            sub_100061FB4( "Server identifier not in hash (%s:%d).",  v87,  v88,  v89,  v90,  v91,  v92,  v93,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c");
          }
          sub_100036D00(&v223, 0LL, (uint64_t)a1);
          goto LABEL_81;
        }

        if ((_DWORD)v10 != 293) {
          goto LABEL_83;
        }
        sub_100036D00(&v223, 0LL, (uint64_t)a1);
        if ((_DWORD)a3 == 1 || (_DWORD)a3 == 4)
        {
          uint64_t v41 = "group declarations not allowed here.";
          goto LABEL_116;
        }

        sub_100008728(a1, a2, v35, v36, v37, v38, v39, v40);
        break;
    }

    return 1LL;
  }

  switch((int)v10)
  {
    case 256:
      sub_100036D00(&v223, 0LL, (uint64_t)a1);
      if ((_DWORD)a3 == 1 || (_DWORD)a3 == 4)
      {
        uint64_t v41 = "host declarations not allowed here.";
        goto LABEL_116;
      }

      if ((a3 & 0xFFFFFFFE) == 2 && (byte_10008CF95 & 1) == 0)
      {
        byte_10008CF95 = 1;
        sub_10006221C( "WARNING: Host declarations are global.  They are not limited to the scope you declared them in.",  v34,  v35,  v36,  v37,  v38,  v39,  v40,  (char)v218);
      }

      sub_100007FE0(a1, a2);
      return 1LL;
    case 257:
      sub_100036D00(&v223, 0LL, (uint64_t)a1);
      if (dword_100089B0C == 30)
      {
        BOOL v66 = "You can not use a hardware parameter for DHCPv6 hosts. Use the host-identifier parameter instead.";
        goto LABEL_62;
      }

      __int128 v224 = 0uLL;
      unsigned __int16 v225 = 0;
      if (!a4)
      {
        sub_100047D90(a1, &v224);
        v218 = "not allowed here.";
        uint64_t v65 = "hardware address parameter %s";
        goto LABEL_143;
      }

      if ((void)v224 != *(void *)(a4 + 56)
        || *((void *)&v224 + 1) != *(void *)(a4 + 64)
        || v225 != (unint64_t)*(unsigned __int16 *)(a4 + 72))
      {
        sub_100046D6C( (uint64_t)a1,  "Host %s hardware address already configured.",  v18,  v19,  v20,  v21,  v22,  v23,  *(void *)(a4 + 48));
        return 0LL;
      }

      sub_100047D90(a1, &v224);
      a5 = 0LL;
      *(_OWORD *)(a4 + 56) = v224;
      *(_WORD *)(a4 + 72) = v225;
      return a5;
    case 259:
      goto LABEL_39;
    case 260:
      sub_100036D00(&v223, 0LL, (uint64_t)a1);
      if (sub_1000374AC(&v223, 0LL, a1) == 397)
      {
        if ((_DWORD)a3)
        {
          sub_100046D6C( (uint64_t)a1,  "option space definitions %s",  v67,  v68,  v69,  v70,  v71,  v72,  (char)"may not be scoped.");
          goto LABEL_63;
        }

        sub_100048B98(a1);
        return a5;
      }

      int v220 = 0;
      if (sub_1000374AC(&v223, 0LL, a1) == 388)
      {
        if ((_DWORD)a3)
        {
          sub_100046D6C( (uint64_t)a1,  "option definitions%s",  v139,  v140,  v141,  v142,  v143,  v144,  (char)" may not be scoped.");
          sub_100046C44(a1);
          sub_100052CE4( &v221,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  723LL,  v145,  v146,  v147,  v148,  v149);
          return 0LL;
        }

        sub_100036D00(&v223, 0LL, (uint64_t)a1);
        if (v220)
        {
          sub_100029210( *(void *)(*(void *)(v221 + 16) + 112LL),  *(const char **)v221,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  735LL,  v206,  v207,  v208);
          sub_100029210( *(void *)(*(void *)(v221 + 16) + 120LL),  (const char *)(v221 + 24),  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  738LL,  v209,  v210,  v211);
        }

        sub_100049110(a1, v221);
        uint64_t v217 = 742LL;
        goto LABEL_174;
      }

      if (!v220)
      {
        sub_100046D6C((uint64_t)a1, "unknown option %s.%s", v139, v140, v141, v142, v143, v144, **(void **)(v221 + 16));
        sub_100046C44(a1);
        uint64_t v217 = 753LL;
LABEL_174:
        sub_100052CE4( &v221,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  v217,  v212,  v213,  v214,  v215,  v216);
        return a5;
      }

      int v184 = *(_DWORD *)(v221 + 24);
      if (v184 == 51 || (v184 & 0xFFFFFFFE) == 0x3A && dword_100089B0C != 30) {
        sub_10006221C( "WARNING: server ignoring option %s in configuration file.",  v138,  v139,  v140,  v141,  v142,  v143,  v144,  *(void *)v221);
      }
LABEL_81:
      *(void *)&__int128 v224 = 0LL;
      if (sub_10004B414(&v224, a1, 1LL, v221, 6))
      {
        sub_100052CE4( &v221,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  783LL,  v94,  v95,  v96,  v97,  v98);
        goto LABEL_85;
      }

      return a5;
    default:
      goto LABEL_83;
  }

uint64_t sub_100004E94(uint64_t a1, int32x2_t *a2)
{
  unsigned int __n = 4;
  __size[0] = 0;
  uint64_t v215 = 0LL;
  int v5 = sub_10003387C((void **)&v215, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 2951LL);
  uint64_t result = 0LL;
  if (v5) {
    return result;
  }
  if (!sub_100047540(a2, &__n_4, &__n, 46, 10LL, 8LL))
  {
    uint64_t v208 = 2957LL;
    goto LABEL_162;
  }

  uint64_t v7 = v215;
  unsigned int v8 = __n;
  memcpy(v215 + 60, &__n_4, __n);
  *((_DWORD *)v7 + 14) = v8;
  if (!sub_10000BC3C(a2))
  {
    uint64_t v208 = 2964LL;
    goto LABEL_162;
  }

  int v9 = 0;
  uint64_t v10 = "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c";
  while (1)
  {
    int v11 = sub_100036D00(&__src, 0LL, (uint64_t)a2);
    if (v11 == 125) {
      goto LABEL_165;
    }
    int v18 = v11;
    if (v11 == 607)
    {
      sub_100046D6C((uint64_t)a2, "unexpected end of file", v12, v13, v14, v15, v16, v17, v209);
LABEL_165:
      uint64_t v204 = v215;
      if ((v9 & 0x100) == 0)
      {
        if (*((void *)v215 + 11) > qword_10008CE80 || *((void *)v215 + 20) || *((void *)v215 + 22))
        {
          v215[222] = 2;
          uint64_t v205 = *((void *)v204 + 17);
          if (v205 && *(void *)(v205 + 160)) {
            char v206 = 3;
          }
          else {
            char v206 = 1;
          }
        }

        else
        {
          uint64_t v207 = *((void *)v215 + 17);
          if (v207 && *(void *)(v207 + 160)) {
            char v206 = 3;
          }
          else {
            char v206 = 1;
          }
          v215[222] = v206;
        }

        v204[223] = v206;
      }

      if ((v9 & 0x10000) == 0) {
        *((void *)v204 + 30) = *((void *)v204 + 11);
      }
      sub_100033898(a1, v204, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 3441LL);
      sub_10003389C( (_DWORD **)&v215,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  3442LL);
      return 1LL;
    }

    uint64_t v19 = __src;
    strncpy(__dst, __src, 0x20uLL);
    __dst[31] = 0;
    if (v18 <= 362)
    {
      if (v18 > 285)
      {
        if (v18 <= 324)
        {
          if (v18 != 286)
          {
            if (v18 == 319)
            {
              *((_WORD *)v215 + 111) = 1285;
              sub_100046D08(a2);
              int v27 = 256;
              goto LABEL_156;
            }

            goto LABEL_80;
          }

          uint64_t v57 = v215;
          char v58 = v215[221] | 2;
LABEL_70:
          v57[221] = v58;
LABEL_71:
          sub_100046D08(a2);
          goto LABEL_103;
        }

        if (v18 == 325)
        {
LABEL_49:
          *(void *)&__size[1] = 0LL;
          if (sub_10004F5A0(&__size[1], a2))
          {
            if (*(uint64_t **)(*(void *)(*(void *)&__size[1] + 24LL) + 16LL) != &qword_10008BEF0)
            {
              sub_100046D6C((uint64_t)a2, "agent option expected.", v21, v22, v23, v24, v25, v26, v209);
              uint64_t v50 = (uint64_t)v10;
              uint64_t v51 = 3293LL;
              goto LABEL_102;
            }

            uint64_t v118 = *((void *)v215 + 19);
            if (v118)
            {
LABEL_99:
              uint64_t v126 = (void *)(v118 + 8);
              do
              {
                uint64_t v127 = v126;
                uint64_t v128 = *v126;
                uint64_t v126 = (void *)(*v126 + 8LL);
              }

              while (v128);
              uint64_t v129 = sub_10005415C(0LL, 0LL);
              *uint64_t v127 = v129;
              sub_100033F18(v129, *(_DWORD **)&__size[1], (uint64_t)v10, 3307LL, v130, v131, v132, v133);
              uint64_t v50 = (uint64_t)v10;
              uint64_t v51 = 3308LL;
LABEL_102:
              sub_100040E08((int **)&__size[1], v50, v51, v45, v46, v47, v48, v49);
            }

            else
            {
              if (sub_100033E60((void *)v215 + 19, (uint64_t)v10, 3298LL, v22, v23, v24, v25, v26))
              {
                uint64_t v118 = *((void *)v215 + 19);
                goto LABEL_99;
              }

              sub_10006221C("no memory to stash agent option", v119, v120, v121, v122, v123, v124, v125, v209);
            }
          }

LABEL_103:
          int v27 = 0;
          goto LABEL_156;
        }

        if (v18 != 329) {
          goto LABEL_80;
        }
        if (sub_1000374AC(&__src, 0LL, a2) == 262)
        {
          if (!sub_100046FEC(a2, (void *)v215 + 13, 0LL))
          {
            uint64_t v208 = 3199LL;
            goto LABEL_162;
          }
        }

        else
        {
          uint64_t v111 = sub_1000470FC(a2);
          *((void *)v215 + 13) = v111;
          if (!v111)
          {
            sub_100046D6C((uint64_t)a2, "expecting a hostname.", v112, v113, v114, v115, v116, v117, v209);
            sub_100046C44(a2);
            uint64_t v208 = 3211LL;
            goto LABEL_162;
          }

          sub_100046D08(a2);
        }

        int v27 = 1024;
      }

      else
      {
        switch(v18)
        {
          case 257:
            sub_100047D90(a2, v215 + 203);
            int v27 = 64;
            goto LABEL_156;
          case 260:
            goto LABEL_49;
          case 266:
          case 267:
          case 268:
            goto LABEL_35;
          case 269:
            if (sub_1000374AC(&__src, 0LL, a2) == 262)
            {
              sub_100036D00(&__src, __size, (uint64_t)a2);
              unsigned __int16 v52 = __size[0];
              if (__size[0] > 6)
              {
                uint64_t v186 = (char *)sub_10005CDE4(__size[0]);
                if (!v186)
                {
                  sub_10006221C("no space for uid", v187, v188, v189, v190, v191, v192, v193, v209);
                  uint64_t v208 = 3043LL;
                  goto LABEL_162;
                }

                uint64_t v54 = v186;
                __int16 v55 = __size[0];
                unsigned __int16 v52 = __size[0];
                uint64_t v53 = v215;
              }

              else
              {
                uint64_t v53 = v215;
                uint64_t v54 = v215 + 196;
                __int16 v55 = 7;
              }

              *((_WORD *)v53 + 97) = v55;
              *((_WORD *)v53 + 96) = v52;
              memcpy(v54, __src, v52);
              *((void *)v215 + 23) = v54;
            }

            else
            {
              __size[0] = 0;
              v102 = sub_100047540(a2, 0LL, __size, 58, 16LL, 8LL);
              uint64_t v109 = v215;
              *((void *)v215 + 23) = v102;
              if (!v102)
              {
                uint64_t v208 = 3057LL;
                goto LABEL_162;
              }

              int v110 = LOWORD(__size[0]);
              *((_WORD *)v109 + 96) = __size[0];
              *((_WORD *)v109 + 97) = v110;
              if (!v110)
              {
                *((void *)v109 + 23) = 0LL;
                sub_100046D6C((uint64_t)a2, "zero-length uid", v103, v104, v105, v106, v107, v108, v209);
                goto LABEL_71;
              }
            }

            sub_100046D08(a2);
            if (!*((void *)v215 + 23)) {
              sub_100061FB4("No memory for lease uid", v20, v21, v22, v23, v24, v25, v26, v209);
            }
            int v27 = 8;
            goto LABEL_156;
          case 270:
            unsigned int v56 = sub_100036D00(&__src, 0LL, (uint64_t)a2);
            if (v56 < 0x100)
            {
              if (v56 != 59) {
LABEL_184:
              }
                sub_100046C4C(a2, 1u);
              uint64_t v208 = 3082LL;
              goto LABEL_162;
            }

            if (v56 - 262 < 2 || v56 == 607) {
              goto LABEL_184;
            }
            sub_100046D08(a2);
            int v27 = 32;
            break;
          default:
            goto LABEL_80;
        }
      }

      goto LABEL_156;
    }

    if (v18 <= 567) {
      break;
    }
    if (v18 <= 576)
    {
      if (v18 == 568)
      {
LABEL_35:
        uint64_t v44 = sub_1000487A0(a2);
        if (v18 > 422)
        {
          switch(v18)
          {
            case 423:
              *((void *)v215 + 31) = v44;
              int v27 = 0x20000;
              break;
            case 568:
              *((void *)v215 + 33) = v44;
              int v27 = 0x80000;
              break;
            case 616:
              *((void *)v215 + 32) = v44;
              int v27 = 0x40000;
              break;
            default:
LABEL_182:
              sub_100061FB4("Impossible error at %s:%d.", v20, v21, v22, v23, v24, v25, v26, (char)v10);
          }
        }

        else
        {
          switch(v18)
          {
            case 267:
              *((void *)v215 + 10) = v44;
              int v27 = 1;
              break;
            case 268:
              *((void *)v215 + 11) = v44;
              int v27 = 2;
              break;
            case 422:
              *((void *)v215 + 30) = v44;
              int v27 = 0x10000;
              break;
            default:
              goto LABEL_182;
          }
        }

        goto LABEL_156;
      }

      if (v18 != 570) {
        goto LABEL_80;
      }
      int v27 = 256;
      int v43 = 1;
    }

    else
    {
      if (v18 == 577)
      {
        uint64_t v57 = v215;
        char v58 = v215[221] | 4;
        goto LABEL_70;
      }

      if (v18 != 579)
      {
        if (v18 == 616) {
          goto LABEL_35;
        }
        goto LABEL_80;
      }

      if (sub_100036D00(&__src, 0LL, (uint64_t)a2) != 570)
      {
        sub_100046D6C((uint64_t)a2, "expecting 'binding'", v59, v60, v61, v62, v63, v64, v209);
        sub_100046C44(a2);
        int v27 = 128;
        goto LABEL_156;
      }

      int v43 = 0;
      int v27 = 128;
    }

    if (sub_100036D00(&__src, 0LL, (uint64_t)a2) == 466)
    {
      int v71 = sub_100036D00(&__src, 0LL, (uint64_t)a2);
      switch(v71)
      {
        case 571:
          char v78 = 1;
          goto LABEL_152;
        case 572:
          goto LABEL_151;
        case 573:
          char v78 = 3;
          goto LABEL_152;
        case 574:
          char v78 = 4;
          goto LABEL_152;
        case 575:
          char v78 = 6;
          goto LABEL_152;
        case 576:
          char v78 = 7;
          goto LABEL_152;
        case 577:
          char v195 = v215;
          char v196 = v215[221] | 4;
          goto LABEL_150;
        case 578:
          char v195 = v215;
          char v196 = v215[221] | 2;
LABEL_150:
          v195[221] = v196;
LABEL_151:
          char v78 = 2;
          goto LABEL_152;
        default:
          if (v71 != 319)
          {
            sub_100046D6C((uint64_t)a2, "%s: expecting a binding state.", v72, v73, v74, v75, v76, v77, (char)__src);
            sub_100046C44(a2);
            return 0LL;
          }

          char v78 = 5;
LABEL_152:
          uint64_t v197 = v215;
          if (!v43 || (v215[222] = v78, (v9 & 0x80) == 0)) {
            v197[223] = v78;
          }
          sub_100046D08(a2);
          break;
      }
    }

    else
    {
      sub_100046D6C((uint64_t)a2, "expecting 'state'", v65, v66, v67, v68, v69, v70, v209);
      sub_100046C44(a2);
    }

LABEL_156:
    if ((v27 & v9) != 0)
    {
      __int128 v219 = *(_OWORD *)(v215 + 56);
      int v220 = *((_DWORD *)v215 + 18);
      sub_100040144((int *)&v219, v20, v21, v22, v23, v24, v25, v26);
      sub_100046D6C( (uint64_t)a2,  "Too many %s parameters in lease %s\n",  v198,  v199,  v200,  v201,  v202,  v203,  (char)__dst);
    }

    else
    {
      v9 |= v27;
    }
  }

  if (v18 <= 421)
  {
    if (v18 == 363)
    {
      uint64_t v210 = 0LL;
      int v79 = sub_100036D00(&__src, 0LL, (uint64_t)a2);
      if (v79 == 346)
      {
        if (*((void *)v215 + 18)) {
          sub_1000338C0(v215 + 144, v10, 3242LL);
        }
        sub_10000745C((uint64_t)&v210, a2, 0LL, 3LL, v82, v83, v84, v85);
      }

      else
      {
        int v86 = v79;
        if (v79 == 270)
        {
          int v87 = sub_100036D00(&__src, 0LL, (uint64_t)a2);
          if (v87 == 262)
          {
            if (*((void *)v215 + 18)) {
              sub_1000338C0(v215 + 144, v10, 3233LL);
            }
            sub_100003828((uint64_t)&v210, __src, (uint64_t)v10, 3234LL);
            if (!v210) {
              sub_100046D6C((uint64_t)a2, "unknown class %s", v94, v95, v96, v97, v98, v99, (char)__src);
            }
            sub_100046D08(a2);
            goto LABEL_131;
          }

          int v194 = v87;
          sub_100046D6C((uint64_t)a2, "expecting string", v88, v89, v90, v91, v92, v93, v209);
          if (v194 != 59) {
            sub_100046C44(a2);
          }
LABEL_133:
          int v27 = 2048;
          goto LABEL_156;
        }

        sub_100046D6C((uint64_t)a2, "expecting class", v80, v81, v82, v83, v84, v85, v209);
        if (v86 != 59) {
          sub_100046C44(a2);
        }
      }

LABEL_131:
      uint64_t v20 = v210;
      if (v210)
      {
        sub_1000338BC(v215 + 144, v210, v10, 3252LL);
        sub_1000338C0(&v210, v10, 3253LL);
      }

      goto LABEL_133;
    }

    if (v18 != 408) {
      goto LABEL_80;
    }
    uint64_t v214 = 0LL;
    int v213 = 0;
    if (!sub_10004B594((void **)&v214, a2, &v213))
    {
      sub_100046C4C(a2, 1u);
      uint64_t v208 = 3262LL;
      goto LABEL_162;
    }

    uint64_t v40 = v214;
    int v41 = v214[6];
    if ((v41 & 2) != 0 && (uint64_t v42 = (_DWORD *)*((void *)v214 + 4)) != 0LL)
    {
      sub_100033F18((void *)v215 + 20, v42, (uint64_t)v10, 3271LL, v36, v37, v38, v39);
      uint64_t v40 = v214;
      int v41 = v214[6];
      int v27 = 0x4000;
    }

    else
    {
      int v27 = 0;
    }

    if ((v41 & 4) != 0)
    {
      v101 = (_DWORD *)*((void *)v40 + 4);
      if (v101)
      {
        v27 |= 0x8000u;
        sub_100033F18((void *)v215 + 22, v101, (uint64_t)v10, 3278LL, v36, v37, v38, v39);
      }
    }

    sub_10003DC78((void **)&v214, (uint64_t)v10, 3280LL, v35, v36, v37, v38, v39);
    goto LABEL_156;
  }

  if (v18 == 449)
  {
    if (sub_100036D00(&__src, 0LL, (uint64_t)a2) - 266 <= 0xFFFFFFFD)
    {
      sub_100046D6C((uint64_t)a2, "%s can't be a variable name", v28, v29, v30, v31, v32, v33, (char)__src);
      goto LABEL_191;
    }

    int v27 = 0;
    int v34 = 1;
    goto LABEL_105;
  }

LABEL_80:
  if (!strcasecmp(v19, "ddns-fwd-name"))
  {
    int v34 = 0;
    int v27 = 4096;
  }

  else
  {
    if (strcasecmp(v19, "ddns-rev-name"))
    {
      sub_100046D6C((uint64_t)a2, "Unexpected configuration directive.", v100, v29, v30, v31, v32, v33, v209);
      sub_100046C44(a2);
      uint64_t v208 = 3403LL;
      goto LABEL_162;
    }

    int v34 = 0;
    int v27 = 0x2000;
  }

        sub_100034EA8( &v143,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  1320LL,  a4,  (uint64_t)a5,  a6,  a7,  (uint64_t)a8);
        int v86 = &v149;
        int v87 = 1321LL;
        goto LABEL_81;
      }

          sub_100046D6C((uint64_t)a2, "option data buffer %s", v5, v6, v7, v8, v9, v10, (char)"overflow");
          goto LABEL_97;
        }

        int v71 = 0;
        LOBYTE(v73) = 0;
      }

      else
      {
        if ((char)v14 <= 114)
        {
          if ((char)v14 != 102)
          {
LABEL_22:
            uint64_t v22 = sub_100036D00(&v74, 0LL, (uint64_t)a2);
            uint64_t v23 = &v73;
            sub_100047FD0(a2, &v73, (unsigned __int8 *)v74, 0LL, 32LL, v8, v9, v10);
            uint64_t v24 = 4;
            goto LABEL_39;
          }

          uint64_t v35 = sub_100036D00(&v74, 0LL, (uint64_t)a2);
          uint64_t v36 = v35;
          if (v35 >= 256)
          {
            if ((v35 - 262) < 2 || v35 == 607)
            {
              uint64_t v63 = "expecting identifier.";
              goto LABEL_96;
            }

            uint64_t v37 = v74;
            uint64_t v24 = 1;
            if (!strcasecmp(v74, "true") || !strcasecmp(v37, "on"))
            {
              uint64_t v38 = 1;
            }

            else
            {
              if (strcasecmp(v37, "false") && strcasecmp(v37, "off"))
              {
                uint64_t v63 = "expecting BOOLean.";
LABEL_96:
                sub_100046D6C((uint64_t)a2, v63, v5, v6, v7, v8, v9, v10, v66);
                goto LABEL_97;
              }

              uint64_t v38 = 0;
            }

            LOBYTE(v73) = v38;
            int v71 = 1;
            uint64_t v23 = &v73;
            goto LABEL_68;
          }

          uint64_t v62 = "expecting identifier.";
LABEL_82:
          sub_100046D6C((uint64_t)a2, v62, v5, v6, v7, v8, v9, v10, v66);
          if (v36 != 59) {
            goto LABEL_97;
          }
          goto LABEL_100;
        }

        if ((char)v14 == 115)
        {
LABEL_37:
          uint64_t v22 = sub_100036D00(&v74, 0LL, (uint64_t)a2);
          uint64_t v23 = &v73;
          sub_100047FD0(a2, &v73, (unsigned __int8 *)v74, 0LL, 16LL, v8, v9, v10);
          uint64_t v24 = 2;
          goto LABEL_39;
        }

        if (sub_1000374AC(&v74, &v71, a2) == 59 && i[1] == 111)
        {
          ++i;
          continue;
        }

        if (sub_100036D00(&v74, &v71, (uint64_t)a2) != 262)
        {
          uint64_t v63 = "expecting string.";
          goto LABEL_96;
        }

        uint64_t v16 = v71 + v12;
        if (v71 + v12 - 1024 <= 0xFFFFFBFE) {
          goto LABEL_80;
        }
        memcpy(&__src[v12], v74, v71 + 1);
        uint64_t v67 = 1;
LABEL_65:
        uint64_t v12 = v16;
      }
    }

    uint64_t v39 = sub_100036D00(&v74, 0LL, (uint64_t)a2);
  }

  while (*i == 65 && v39 == 44);
  if (v39 != 59)
  {
LABEL_86:
    uint64_t v63 = "semicolon expected.";
    goto LABEL_96;
  }

  uint64_t v70 = 0LL;
  if (!sub_1000345C4( &v70,  v67 + v12,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  5597LL)) {
    sub_100061FB4("no memory to store option declaration.", v40, v41, v42, v43, v44, v45, v46, v66);
  }
  memcpy((void *)(v70 + 4), __src, (v67 + v12));
  if (!sub_100034540( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  5603LL,  v47,  v48,  v49,  v50,  v51)) {
    sub_100061FB4("out of memory allocating option cache.", v52, v53, v54, v55, v56, v57, v58, v66);
  }
  uint64_t v59 = v70;
  *(void *)(*a1 + 32LL) = v70;
  *(void *)(*a1 + 40LL) = v59 + 4;
  uint64_t v60 = *a1;
  *(_DWORD *)(v60 + 48) = v12;
  *(_DWORD *)(v60 + 52) = v67;
  sub_100052CB0((void *)(v60 + 24), v72);
  int v11 = 1LL;
  uint64_t v61 = 5611LL;
LABEL_101:
  sub_100052CE4(&v72, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c", v61, v6, v7, v8, v9, v10);
  return v11;
}

LABEL_105:
  uint64_t v134 = v215;
  uint64_t v135 = *((void *)v215 + 14);
  if (!v135) {
    goto LABEL_199;
  }
  v136 = sub_100055100(v135, __src);
  if (v136)
  {
    v137 = v136;
    uint64_t v138 = (uint64_t)v10;
    uint64_t v139 = v2;
    int v140 = 0;
    goto LABEL_116;
  }

  uint64_t v134 = v215;
  if (!*((void *)v215 + 14))
  {
LABEL_199:
  }

  uint64_t v148 = (uint64_t **)sub_10005CDE4(0x18uLL);
  v137 = v148;
  if (!v148) {
    sub_100061FB4("No memory for lease %s.", v149, v150, v151, v152, v153, v154, v155, (char)"binding");
  }
  uint64_t v139 = v2;
  *uint64_t v148 = 0LL;
  v148[1] = 0LL;
  v148[2] = 0LL;
  int v156 = strlen(__src);
  uint64_t v138 = (uint64_t)v10;
  unsigned int v157 = (char *)sub_10005CDE4((v156 + 1));
  v137[1] = (uint64_t *)v157;
  if (!v157) {
    sub_100061FB4("No memory for binding %s.", v158, v159, v160, v161, v162, v163, v164, (char)"name");
  }
  strcpy(v157, __src);
  int v140 = 1;
LABEL_116:
  uint64_t v212 = 0LL;
  if (!v34 || sub_100036D00(&__src, 0LL, (uint64_t)a2) == 61)
  {
    if (!sub_10000BF94(a2, (uint64_t)v212, v166, v167, v168, v169, v170, v171))
    {
      sub_1000577E8( (uint64_t *)&v212,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  3368LL,  v172,  v173,  v174,  v175,  v176);
      uint64_t v208 = 3369LL;
      goto LABEL_162;
    }

    uint64_t v10 = (const char *)v138;
    if (v140)
    {
      sub_100033F18(v137 + 2, v212, v138, 3375LL, v173, v174, v175, v176);
      *v137 = *(uint64_t **)(*((void *)v215 + 14) + 16LL);
      *(void *)(*((void *)v215 + 14) + 16LL) = v137;
    }

    else
    {
      sub_1000577E8((uint64_t *)v137 + 2, v138, 3379LL, v172, v173, v174, v175, v176);
      sub_100033F18(v137 + 2, v212, v138, 3381LL, v182, v183, v184, v185);
    }

    sub_1000577E8((uint64_t *)&v212, v138, 3384LL, v177, v178, v179, v180, v181);
    sub_100046D08(a2);
    uint64_t v2 = v139;
    goto LABEL_156;
  }

  sub_100046D6C((uint64_t)a2, "expecting '=' in set statement.", v166, v167, v168, v169, v170, v171, v209);
LABEL_191:
  sub_100046C44(a2);
  uint64_t v208 = 3322LL;
LABEL_162:
  sub_10003389C((_DWORD **)&v215, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", v208);
  return 0LL;
}

uint64_t sub_100005BE8( int32x2_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v176 = 0LL;
  *(void *)uint64_t v177 = 0LL;
  if (dword_100089B0C != 30)
  {
    sub_100046D6C((uint64_t)a1, "IA_NA is only supported in DHCPv6 mode.", a3, a4, a5, a6, a7, a8, (char)v174);
    return sub_100046C44(a1);
  }

  if (sub_100036D00(&__s, &v180, (uint64_t)a1) != 262)
  {
    uint64_t v15 = "corrupt lease file; expecting an iaid+ia_na string";
    goto LABEL_75;
  }

  uint64_t v10 = v180 - 4;
  if (v180 <= 4)
  {
    uint64_t v15 = "corrupt lease file; iaid+ia_na string too short";
    goto LABEL_75;
  }

  uint64_t v17 = *(unsigned int *)__s;
  uint64_t v182 = 0LL;
  if (sub_10002DBB4( &v182,  v17,  __s + 4,  v10,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4187LL,  v13,  v14)) {
    sub_100061FB4("Out of memory.", v18, v19, v20, v21, v22, v23, v24, (char)v174);
  }
  *((_WORD *)v182 + 16) = 3;
  if (sub_100036D00(&__s, 0LL, (uint64_t)a1) != 123)
  {
LABEL_74:
    uint64_t v15 = "corrupt lease file; expecting left brace";
    goto LABEL_75;
  }

LABEL_10:
  while (1)
  {
    int v25 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
    if (v25 != 568) {
      break;
    }
    uint64_t v120 = sub_1000487A0(a1);
    *((void *)v182 + 6) = v120;
  }

  if (v25 != 641)
  {
    if (v25 == 125)
    {
      *(void *)uint64_t v183 = 0LL;
      if (sub_100029804( v183,  qword_10008BE60,  *((void *)v182 + 2),  v182[6],  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4484LL))
      {
        sub_100029210( qword_10008BE60,  *((const char **)v182 + 2),  v182[6],  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4487LL,  v159,  v160,  v161);
        sub_10002D71C( (void **)v183,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4488LL,  v162,  v163,  v164,  v165,  v166);
      }

      uint64_t v167 = (uint64_t)v182;
      if ((int)v182[9] >= 1) {
        sub_100029214( qword_10008BE60,  *((const char **)v182 + 2),  v182[6],  (uint64_t)v182,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4497LL,  v160,  v161,  (char)v174);
      }
      return sub_10002D71C( (void **)&v182,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4499LL,  v167,  v158,  v159,  v160,  v161);
    }

    uint64_t v15 = "corrupt lease file; expecting IAADDR or right brace";
    goto LABEL_75;
  }

  if (!sub_100047820(a1, &v184, v9, v10, v11, v12, v13, v14))
  {
    uint64_t v15 = "corrupt lease file; expecting IPv6 address";
    goto LABEL_75;
  }

  int v26 = 0;
  int v27 = 0;
  uint64_t v28 = -1LL;
  int v29 = 8;
  while (1)
  {
    while (1)
    {
      while (1)
      {
        int v30 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
        if (v30 <= 569) {
          break;
        }
        switch(v30)
        {
          case 644:
            if (sub_100036D00(&__s, 0LL, (uint64_t)a1) == 263)
            {
              int v26 = atoi(__s);
              goto LABEL_39;
            }

            sub_100046D6C((uint64_t)a1, "%s is not a valid preferred time", v49, v50, v51, v52, v53, v54, (char)__s);
LABEL_30:
            sub_100046C44(a1);
            break;
          case 645:
            if (sub_100036D00(&__s, 0LL, (uint64_t)a1) != 263)
            {
              sub_100046D6C((uint64_t)a1, "%s is not a valid max time", v37, v38, v39, v40, v41, v42, (char)__s);
              goto LABEL_30;
            }

            int v27 = atoi(__s);
LABEL_39:
            else {
LABEL_62:
            }
              sub_100046D6C( (uint64_t)a1,  "corrupt lease file; expecting semicolon.",
                v64,
                v65,
                v66,
                v67,
                v68,
                v69,
                (char)v174);
            break;
          case 570:
            if (sub_100036D00(&__s, 0LL, (uint64_t)a1) == 466)
            {
              int v63 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
              switch(v63)
              {
                case 571:
                  int v29 = 1;
                  goto LABEL_61;
                case 572:
                  int v29 = 2;
                  goto LABEL_61;
                case 573:
                  int v29 = 3;
                  goto LABEL_61;
                case 574:
                  int v29 = 4;
                  goto LABEL_61;
                default:
                  if (v63 != 319)
                  {
                    uint64_t v15 = "corrupt lease file; expecting a binding state.";
                    goto LABEL_75;
                  }

                  int v29 = 5;
LABEL_61:
                  continue;
              }
            }

            uint64_t v15 = "corrupt lease file; expecting state";
LABEL_75:
            sub_100046D6C((uint64_t)a1, v15, v9, v10, v11, v12, v13, v14, (char)v174);
            return sub_100046C44(a1);
          default:
LABEL_29:
            sub_100046D6C( (uint64_t)a1,  "corrupt lease file; expecting ia_na contents, got '%s'",
              v31,
              v32,
              v33,
              v34,
              v35,
              v36,
              (char)__s);
            goto LABEL_30;
        }
      }

      if (v30 == 449) {
        break;
      }
      if (v30 == 125)
      {
        if (v29 == 8)
        {
          uint64_t v168 = "corrupt lease file; missing state in iaaddr";
          return sub_100046D6C((uint64_t)a1, v168, v31, v32, v33, v34, v35, v36, (char)v174);
        }

        if (v28 == -1)
        {
          uint64_t v168 = "corrupt lease file; missing end time in iaaddr";
          return sub_100046D6C((uint64_t)a1, v168, v31, v32, v33, v34, v35, v36, (char)v174);
        }

        uint64_t v179 = 0LL;
        if (sub_10002D9A0( &v179,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4445LL,  v32,  v33,  v34,  v35,  v36)) {
          sub_100061FB4("Out of memory.", v121, v122, v123, v124, v125, v126, v127, (char)v174);
        }
        uint64_t v128 = v179;
        *(_OWORD *)(v179 + 4) = v185;
        v128[20] = 0;
        v128[21] = v29;
        *((_DWORD *)v128 + 12) = v26;
        *((_DWORD *)v128 + 13) = v27;
        if (v29 == 4) {
          *((void *)v128 + 4) = v28;
        }
        if (*(void *)v177)
        {
          sub_100033F18( (void *)v128 + 3,  *(_DWORD **)v177,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4457LL,  v124,  v125,  v126,  v127);
          sub_10005515C( v177,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4458LL,  v129,  v130,  v131,  v132,  v133);
          uint64_t v128 = v179;
        }

        sub_10002DC94( (uint64_t)v182,  v128,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4462LL,  v124,  v125,  v126,  v127);
        sub_10002D6B4( (void *)v179 + 7,  v182,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4463LL,  v134,  v135,  v136,  v137);
        uint64_t v178 = 0LL;
        if (sub_10002F750(&v178, 3LL, (__int128 *)(v179 + 4), v138, v139, v140, v141, v142))
        {
          inet_ntop(30, v179 + 4, v183, 0x2Eu);
          uint64_t v174 = v183;
          uint64_t v168 = "no pool found for address %s";
          return sub_100046D6C((uint64_t)a1, v168, v31, v32, v33, v34, v35, v36, (char)v174);
        }

        sub_10002E7BC(v178, (uint64_t)v179, v28, v143, v144, v145, v146, v147);
        sub_10002DA28( (void **)&v178,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4474LL,  v148,  v149,  v150,  v151,  v152);
        sub_10002D8B8( (void **)&v179,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4475LL,  v153,  v154,  v155,  v156,  v157);
        goto LABEL_10;
      }

      if (v30 != 268) {
        goto LABEL_29;
      }
      uint64_t v28 = sub_1000487A0(a1);
    }

    if (sub_100036D00(&__s, 0LL, (uint64_t)a1) - 266 <= 0xFFFFFFFD)
    {
      sub_100046D6C((uint64_t)a1, "%s is not a valid variable name", v43, v44, v45, v46, v47, v48, (char)__s);
      goto LABEL_30;
    }

    int v175 = v29;
    if (*(void *)v177)
    {
      __int16 v55 = sub_100055100(*(uint64_t *)v177, __s);
      if (v55)
      {
        uint64_t v61 = v55;
        int v62 = 0;
        goto LABEL_48;
      }
    }

    else if (!sub_100034DAC( v177,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4359LL,  v44,  v45,  v46,  v47,  v48))
    {
      sub_100061FB4("Out of memory for lease binding scope.", v70, v71, v72, v73, v74, v75, v76, (char)v174);
    }

    uint64_t v61 = sub_10005CDE4(0x18uLL);
    if (!v61) {
      sub_100061FB4("No memory for lease binding.", v77, v78, v79, v80, v81, v82, v83, (char)v174);
    }
    int v84 = strlen(__s);
    uint64_t v85 = (char *)sub_10005CDE4((v84 + 1));
    v61[1] = v85;
    if (!v85) {
      sub_100061FB4("No memory for binding name.", v86, v87, v88, v89, v90, v91, v92, (char)v174);
    }
    strcpy(v85, __s);
    int v62 = 1;
LABEL_48:
    if (!sub_10003444C( &v176,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4389LL,  v56,  v57,  v58,  v59,  v60)) {
      sub_100061FB4("no memory for binding value.", v93, v94, v95, v96, v97, v98, v99, (char)v174);
    }
    if (v62)
    {
      sub_100033F18( v61 + 2,  v176,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4410LL,  v107,  v108,  v109,  v110);
      *uint64_t v61 = *(void *)(*(void *)v177 + 16LL);
      *(void *)(*(void *)v177 + 16LL) = v61;
    }

    else
    {
      sub_1000577E8( v61 + 2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4415LL,  v106,  v107,  v108,  v109,  v110);
      sub_100033F18( v61 + 2,  v176,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4417LL,  v116,  v117,  v118,  v119);
    }

    int v29 = v175;
    sub_1000577E8( (uint64_t *)&v176,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4420LL,  v111,  v112,  v113,  v114,  v115);
    sub_100046D08(a1);
  }

  sub_100046D6C((uint64_t)a1, "expecting '=' in set statement.", v100, v101, v102, v103, v104, v105, (char)v174);
LABEL_86:
  sub_1000577E8( (uint64_t *)&v176,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4403LL,  v106,  v107,  v108,  v109,  v110);
  return sub_10005515C( v177,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4404LL,  v169,  v170,  v171,  v172,  v173);
}

  while (1)
  {
    int v25 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
    if (v25 != 568) {
      break;
    }
    uint64_t v120 = sub_1000487A0(a1);
    *((void *)v182 + 6) = v120;
  }

  if (v25 != 641)
  {
    if (v25 == 125)
    {
      *(void *)uint64_t v183 = 0LL;
      if (sub_100029804( v183,  qword_10008BE70,  *((void *)v182 + 2),  v182[6],  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4847LL))
      {
        sub_100029210( qword_10008BE70,  *((const char **)v182 + 2),  v182[6],  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4850LL,  v159,  v160,  v161);
        sub_10002D71C( (void **)v183,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4851LL,  v162,  v163,  v164,  v165,  v166);
      }

      uint64_t v167 = (uint64_t)v182;
      if ((int)v182[9] >= 1) {
        sub_100029214( qword_10008BE70,  *((const char **)v182 + 2),  v182[6],  (uint64_t)v182,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4860LL,  v160,  v161,  (char)v174);
      }
      return sub_10002D71C( (void **)&v182,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4862LL,  v167,  v158,  v159,  v160,  v161);
    }

    uint64_t v15 = "corrupt lease file; expecting IAADDR or right brace";
    goto LABEL_75;
  }

  if (!sub_100047820(a1, &v184, v9, v10, v11, v12, v13, v14))
  {
    uint64_t v15 = "corrupt lease file; expecting IPv6 address";
    goto LABEL_75;
  }

  int v26 = 0;
  int v27 = 0;
  uint64_t v28 = -1LL;
  int v29 = 8;
  while (1)
  {
    while (1)
    {
      while (1)
      {
        int v30 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
        if (v30 <= 569) {
          break;
        }
        switch(v30)
        {
          case 644:
            if (sub_100036D00(&__s, 0LL, (uint64_t)a1) == 263)
            {
              int v26 = atoi(__s);
              goto LABEL_39;
            }

            sub_100046D6C((uint64_t)a1, "%s is not a valid preferred time", v49, v50, v51, v52, v53, v54, (char)__s);
LABEL_30:
            sub_100046C44(a1);
            break;
          case 645:
            if (sub_100036D00(&__s, 0LL, (uint64_t)a1) != 263)
            {
              sub_100046D6C((uint64_t)a1, "%s is not a valid max time", v37, v38, v39, v40, v41, v42, (char)__s);
              goto LABEL_30;
            }

            int v27 = atoi(__s);
LABEL_39:
            else {
LABEL_62:
            }
              sub_100046D6C( (uint64_t)a1,  "corrupt lease file; expecting semicolon.",
                v64,
                v65,
                v66,
                v67,
                v68,
                v69,
                (char)v174);
            break;
          case 570:
            if (sub_100036D00(&__s, 0LL, (uint64_t)a1) == 466)
            {
              int v63 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
              switch(v63)
              {
                case 571:
                  int v29 = 1;
                  goto LABEL_61;
                case 572:
                  int v29 = 2;
                  goto LABEL_61;
                case 573:
                  int v29 = 3;
                  goto LABEL_61;
                case 574:
                  int v29 = 4;
                  goto LABEL_61;
                default:
                  if (v63 != 319)
                  {
                    uint64_t v15 = "corrupt lease file; expecting a binding state.";
                    goto LABEL_75;
                  }

                  int v29 = 5;
LABEL_61:
                  continue;
              }
            }

            uint64_t v15 = "corrupt lease file; expecting state";
LABEL_75:
            sub_100046D6C((uint64_t)a1, v15, v9, v10, v11, v12, v13, v14, (char)v174);
            return sub_100046C44(a1);
          default:
LABEL_29:
            sub_100046D6C( (uint64_t)a1,  "corrupt lease file; expecting ia_ta contents, got '%s'",
              v31,
              v32,
              v33,
              v34,
              v35,
              v36,
              (char)__s);
            goto LABEL_30;
        }
      }

      if (v30 == 449) {
        break;
      }
      if (v30 == 125)
      {
        if (v29 == 8)
        {
          uint64_t v168 = "corrupt lease file; missing state in iaaddr";
          return sub_100046D6C((uint64_t)a1, v168, v31, v32, v33, v34, v35, v36, (char)v174);
        }

        if (v28 == -1)
        {
          uint64_t v168 = "corrupt lease file; missing end time in iaaddr";
          return sub_100046D6C((uint64_t)a1, v168, v31, v32, v33, v34, v35, v36, (char)v174);
        }

        uint64_t v179 = 0LL;
        if (sub_10002D9A0( &v179,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4808LL,  v32,  v33,  v34,  v35,  v36)) {
          sub_100061FB4("Out of memory.", v121, v122, v123, v124, v125, v126, v127, (char)v174);
        }
        uint64_t v128 = v179;
        *(_OWORD *)(v179 + 4) = v185;
        v128[20] = 0;
        v128[21] = v29;
        *((_DWORD *)v128 + 12) = v26;
        *((_DWORD *)v128 + 13) = v27;
        if (v29 == 4) {
          *((void *)v128 + 4) = v28;
        }
        if (*(void *)v177)
        {
          sub_100033F18( (void *)v128 + 3,  *(_DWORD **)v177,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4820LL,  v124,  v125,  v126,  v127);
          sub_10005515C( v177,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4821LL,  v129,  v130,  v131,  v132,  v133);
          uint64_t v128 = v179;
        }

        sub_10002DC94( (uint64_t)v182,  v128,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4825LL,  v124,  v125,  v126,  v127);
        sub_10002D6B4( (void *)v179 + 7,  v182,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4826LL,  v134,  v135,  v136,  v137);
        uint64_t v178 = 0LL;
        if (sub_10002F750(&v178, 4LL, (__int128 *)(v179 + 4), v138, v139, v140, v141, v142))
        {
          inet_ntop(30, v179 + 4, v183, 0x2Eu);
          uint64_t v174 = v183;
          uint64_t v168 = "no pool found for address %s";
          return sub_100046D6C((uint64_t)a1, v168, v31, v32, v33, v34, v35, v36, (char)v174);
        }

        sub_10002E7BC(v178, (uint64_t)v179, v28, v143, v144, v145, v146, v147);
        sub_10002DA28( (void **)&v178,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4837LL,  v148,  v149,  v150,  v151,  v152);
        sub_10002D8B8( (void **)&v179,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4838LL,  v153,  v154,  v155,  v156,  v157);
        goto LABEL_10;
      }

      if (v30 != 268) {
        goto LABEL_29;
      }
      uint64_t v28 = sub_1000487A0(a1);
    }

    if (sub_100036D00(&__s, 0LL, (uint64_t)a1) - 266 <= 0xFFFFFFFD)
    {
      sub_100046D6C((uint64_t)a1, "%s is not a valid variable name", v43, v44, v45, v46, v47, v48, (char)__s);
      goto LABEL_30;
    }

    int v175 = v29;
    if (*(void *)v177)
    {
      __int16 v55 = sub_100055100(*(uint64_t *)v177, __s);
      if (v55)
      {
        uint64_t v61 = v55;
        int v62 = 0;
        goto LABEL_48;
      }
    }

    else if (!sub_100034DAC( v177,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4722LL,  v44,  v45,  v46,  v47,  v48))
    {
      sub_100061FB4("Out of memory for lease binding scope.", v70, v71, v72, v73, v74, v75, v76, (char)v174);
    }

    uint64_t v61 = sub_10005CDE4(0x18uLL);
    if (!v61) {
      sub_100061FB4("No memory for lease binding.", v77, v78, v79, v80, v81, v82, v83, (char)v174);
    }
    int v84 = strlen(__s);
    uint64_t v85 = (char *)sub_10005CDE4((v84 + 1));
    v61[1] = v85;
    if (!v85) {
      sub_100061FB4("No memory for binding name.", v86, v87, v88, v89, v90, v91, v92, (char)v174);
    }
    strcpy(v85, __s);
    int v62 = 1;
LABEL_48:
    if (!sub_10003444C( &v176,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4752LL,  v56,  v57,  v58,  v59,  v60)) {
      sub_100061FB4("no memory for binding value.", v93, v94, v95, v96, v97, v98, v99, (char)v174);
    }
    if (v62)
    {
      sub_100033F18( v61 + 2,  v176,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4773LL,  v107,  v108,  v109,  v110);
      *uint64_t v61 = *(void *)(*(void *)v177 + 16LL);
      *(void *)(*(void *)v177 + 16LL) = v61;
    }

    else
    {
      sub_1000577E8( v61 + 2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4778LL,  v106,  v107,  v108,  v109,  v110);
      sub_100033F18( v61 + 2,  v176,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4780LL,  v116,  v117,  v118,  v119);
    }

    int v29 = v175;
    sub_1000577E8( (uint64_t *)&v176,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4783LL,  v111,  v112,  v113,  v114,  v115);
    sub_100046D08(a1);
  }

  sub_100046D6C((uint64_t)a1, "expecting '=' in set statement.", v100, v101, v102, v103, v104, v105, (char)v174);
LABEL_86:
  sub_1000577E8( (uint64_t *)&v176,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4766LL,  v106,  v107,  v108,  v109,  v110);
  return sub_10005515C( v177,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4767LL,  v169,  v170,  v171,  v172,  v173);
}

  while (1)
  {
    int v25 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
    if (v25 != 568) {
      break;
    }
    uint64_t v120 = sub_1000487A0(a1);
    *((void *)v183 + 6) = v120;
  }

  if (v25 != 642)
  {
    if (v25 == 125)
    {
      *(void *)int v184 = 0LL;
      if (sub_100029804( v184,  qword_10008BE68,  *((void *)v183 + 2),  v183[6],  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  5211LL))
      {
        sub_100029210( qword_10008BE68,  *((const char **)v183 + 2),  v183[6],  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  5214LL,  v159,  v160,  v161);
        sub_10002D71C( (void **)v184,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  5215LL,  v162,  v163,  v164,  v165,  v166);
      }

      uint64_t v167 = (uint64_t)v183;
      if ((int)v183[9] >= 1) {
        sub_100029214( qword_10008BE68,  *((const char **)v183 + 2),  v183[6],  (uint64_t)v183,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  5224LL,  v160,  v161,  (char)v174);
      }
      return sub_10002D71C( (void **)&v183,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  5226LL,  v167,  v158,  v159,  v160,  v161);
    }

    uint64_t v15 = "corrupt lease file; expecting IAPREFIX or right brace";
    goto LABEL_75;
  }

  if (!sub_100047A64(a1, &v185, &v180, v10, v11, v12, v13, v14))
  {
    uint64_t v15 = "corrupt lease file; expecting IPv6 prefix";
    goto LABEL_75;
  }

  int v26 = 0;
  int v27 = 0;
  uint64_t v28 = -1LL;
  int v29 = 8;
  while (1)
  {
    while (1)
    {
      while (1)
      {
        int v30 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
        if (v30 <= 569) {
          break;
        }
        switch(v30)
        {
          case 644:
            if (sub_100036D00(&__s, 0LL, (uint64_t)a1) == 263)
            {
              int v26 = atoi(__s);
              goto LABEL_39;
            }

            sub_100046D6C((uint64_t)a1, "%s is not a valid preferred time", v49, v50, v51, v52, v53, v54, (char)__s);
LABEL_30:
            sub_100046C44(a1);
            break;
          case 645:
            if (sub_100036D00(&__s, 0LL, (uint64_t)a1) != 263)
            {
              sub_100046D6C((uint64_t)a1, "%s is not a valid max time", v37, v38, v39, v40, v41, v42, (char)__s);
              goto LABEL_30;
            }

            int v27 = atoi(__s);
LABEL_39:
            else {
LABEL_62:
            }
              sub_100046D6C( (uint64_t)a1,  "corrupt lease file; expecting semicolon.",
                v64,
                v65,
                v66,
                v67,
                v68,
                v69,
                (char)v174);
            break;
          case 570:
            if (sub_100036D00(&__s, 0LL, (uint64_t)a1) == 466)
            {
              int v63 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
              switch(v63)
              {
                case 571:
                  int v29 = 1;
                  goto LABEL_61;
                case 572:
                  int v29 = 2;
                  goto LABEL_61;
                case 573:
                  int v29 = 3;
                  goto LABEL_61;
                case 574:
                  int v29 = 4;
                  goto LABEL_61;
                default:
                  if (v63 != 319)
                  {
                    uint64_t v15 = "corrupt lease file; expecting a binding state.";
                    goto LABEL_75;
                  }

                  int v29 = 5;
LABEL_61:
                  continue;
              }
            }

            uint64_t v15 = "corrupt lease file; expecting state";
LABEL_75:
            sub_100046D6C((uint64_t)a1, v15, v9, v10, v11, v12, v13, v14, (char)v174);
            return sub_100046C44(a1);
          default:
LABEL_29:
            sub_100046D6C( (uint64_t)a1,  "corrupt lease file; expecting ia_pd contents, got '%s'",
              v31,
              v32,
              v33,
              v34,
              v35,
              v36,
              (char)__s);
            goto LABEL_30;
        }
      }

      if (v30 == 449) {
        break;
      }
      if (v30 == 125)
      {
        if (v29 == 8)
        {
          uint64_t v168 = "corrupt lease file; missing state in iaprefix";
          return sub_100046D6C((uint64_t)a1, v168, v31, v32, v33, v34, v35, v36, (char)v174);
        }

        if (v28 == -1)
        {
          uint64_t v168 = "corrupt lease file; missing end time in iaprefix";
          return sub_100046D6C((uint64_t)a1, v168, v31, v32, v33, v34, v35, v36, (char)v174);
        }

        uint64_t v179 = 0LL;
        if (sub_10002D9A0( &v179,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  5172LL,  v32,  v33,  v34,  v35,  v36)) {
          sub_100061FB4("Out of memory.", v121, v122, v123, v124, v125, v126, v127, (char)v174);
        }
        uint64_t v128 = v179;
        *(_OWORD *)(v179 + 4) = v186;
        v128[20] = v180;
        v128[21] = v29;
        *((_DWORD *)v128 + 12) = v26;
        *((_DWORD *)v128 + 13) = v27;
        if (v29 == 4) {
          *((void *)v128 + 4) = v28;
        }
        if (*(void *)v177)
        {
          sub_100033F18( (void *)v128 + 3,  *(_DWORD **)v177,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  5184LL,  v124,  v125,  v126,  v127);
          sub_10005515C( v177,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  5185LL,  v129,  v130,  v131,  v132,  v133);
          uint64_t v128 = v179;
        }

        sub_10002DC94( (uint64_t)v183,  v128,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  5189LL,  v124,  v125,  v126,  v127);
        sub_10002D6B4( (void *)v179 + 7,  v183,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  5190LL,  v134,  v135,  v136,  v137);
        uint64_t v178 = 0LL;
        if (sub_10002F750(&v178, 25LL, (__int128 *)(v179 + 4), v138, v139, v140, v141, v142))
        {
          inet_ntop(30, v179 + 4, v184, 0x2Eu);
          uint64_t v174 = v184;
          uint64_t v168 = "no pool found for address %s";
          return sub_100046D6C((uint64_t)a1, v168, v31, v32, v33, v34, v35, v36, (char)v174);
        }

        sub_10002E7BC(v178, (uint64_t)v179, v28, v143, v144, v145, v146, v147);
        sub_10002DA28( (void **)&v178,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  5201LL,  v148,  v149,  v150,  v151,  v152);
        sub_10002D8B8( (void **)&v179,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  5202LL,  v153,  v154,  v155,  v156,  v157);
        goto LABEL_10;
      }

      if (v30 != 268) {
        goto LABEL_29;
      }
      uint64_t v28 = sub_1000487A0(a1);
    }

    if (sub_100036D00(&__s, 0LL, (uint64_t)a1) - 266 <= 0xFFFFFFFD)
    {
      sub_100046D6C((uint64_t)a1, "%s is not a valid variable name", v43, v44, v45, v46, v47, v48, (char)__s);
      goto LABEL_30;
    }

    int v175 = v29;
    if (*(void *)v177)
    {
      __int16 v55 = sub_100055100(*(uint64_t *)v177, __s);
      if (v55)
      {
        uint64_t v61 = v55;
        int v62 = 0;
        goto LABEL_48;
      }
    }

    else if (!sub_100034DAC( v177,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  5086LL,  v44,  v45,  v46,  v47,  v48))
    {
      sub_100061FB4("Out of memory for lease binding scope.", v70, v71, v72, v73, v74, v75, v76, (char)v174);
    }

    uint64_t v61 = sub_10005CDE4(0x18uLL);
    if (!v61) {
      sub_100061FB4("No memory for prefix binding.", v77, v78, v79, v80, v81, v82, v83, (char)v174);
    }
    int v84 = strlen(__s);
    uint64_t v85 = (char *)sub_10005CDE4((v84 + 1));
    v61[1] = v85;
    if (!v85) {
      sub_100061FB4("No memory for binding name.", v86, v87, v88, v89, v90, v91, v92, (char)v174);
    }
    strcpy(v85, __s);
    int v62 = 1;
LABEL_48:
    if (!sub_10003444C( &v176,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  5116LL,  v56,  v57,  v58,  v59,  v60)) {
      sub_100061FB4("no memory for binding value.", v93, v94, v95, v96, v97, v98, v99, (char)v174);
    }
    if (v62)
    {
      sub_100033F18( v61 + 2,  v176,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  5137LL,  v107,  v108,  v109,  v110);
      *uint64_t v61 = *(void *)(*(void *)v177 + 16LL);
      *(void *)(*(void *)v177 + 16LL) = v61;
    }

    else
    {
      sub_1000577E8( v61 + 2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  5142LL,  v106,  v107,  v108,  v109,  v110);
      sub_100033F18( v61 + 2,  v176,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  5144LL,  v116,  v117,  v118,  v119);
    }

    int v29 = v175;
    sub_1000577E8( (uint64_t *)&v176,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  5147LL,  v111,  v112,  v113,  v114,  v115);
    sub_100046D08(a1);
  }

  sub_100046D6C((uint64_t)a1, "expecting '=' in set statement.", v100, v101, v102, v103, v104, v105, (char)v174);
LABEL_86:
  sub_1000577E8( (uint64_t *)&v176,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  5130LL,  v106,  v107,  v108,  v109,  v110);
  return sub_10005515C( v177,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  5131LL,  v169,  v170,  v171,  v172,  v173);
}

      uint64_t result = sub_10003389C(v7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", v8);
LABEL_11:
      *(_BYTE *)(a2 + 221) &= ~0x20u;
      *(_DWORD *)(a2 + 272) = 0;
      uint64_t v10 = *(_DWORD *)(v3 + 312) - 1;
      *(_DWORD *)(v3 + 312) = v10;
      if (!v10) {
        return sub_10000E1BC();
      }
    }

    else
    {
      while (v4)
      {
        int v5 = v4;
        uint64_t v4 = *(void *)(v4 + 280);
        if (v4 == a2)
        {
          sub_10003389C( (_DWORD **)(v5 + 280),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  2885LL);
          uint64_t v6 = *(void *)(a2 + 280);
          if (v6)
          {
            sub_100033898(v5 + 280, v6, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 2888LL);
            uint64_t v7 = (_DWORD **)(a2 + 280);
            unsigned int v8 = 2889LL;
            goto LABEL_10;
          }

          uint64_t v11 = sub_10003389C( (_DWORD **)(v3 + 296),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  2891LL);
          if (*(void *)(v5 + 280)) {
            sub_10006FC2C(v11, v12, v13, v14, v15, v16, v17, v18);
          }
          uint64_t result = sub_100033898( v3 + 296,  v5,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  2896LL);
          goto LABEL_11;
        }
      }
    }
  }

  return result;
}

        *v6++ = v8;
        ++v4;
        --v5;
      }

      while (v5);
      int v5 = *v4;
      if (!*v4)
      {
LABEL_15:
        *uint64_t v6 = 0;
        return ((_DWORD)v6 - v3 + 1);
      }
    }
  }

  *__error() = 40;
  return 0xFFFFFFFFLL;
}

uint64_t sub_10000640C( int32x2_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v176 = 0LL;
  *(void *)uint64_t v177 = 0LL;
  if (dword_100089B0C != 30)
  {
    sub_100046D6C((uint64_t)a1, "IA_TA is only supported in DHCPv6 mode.", a3, a4, a5, a6, a7, a8, (char)v174);
    return sub_100046C44(a1);
  }

  if (sub_100036D00(&__s, &v180, (uint64_t)a1) != 262)
  {
    uint64_t v15 = "corrupt lease file; expecting an iaid+ia_ta string";
    goto LABEL_75;
  }

  uint64_t v10 = v180 - 4;
  if (v180 <= 4)
  {
    uint64_t v15 = "corrupt lease file; iaid+ia_ta string too short";
    goto LABEL_75;
  }

  uint64_t v17 = *(unsigned int *)__s;
  uint64_t v182 = 0LL;
  if (sub_10002DBB4( &v182,  v17,  __s + 4,  v10,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4550LL,  v13,  v14)) {
    sub_100061FB4("Out of memory.", v18, v19, v20, v21, v22, v23, v24, (char)v174);
  }
  *((_WORD *)v182 + 16) = 4;
  if (sub_100036D00(&__s, 0LL, (uint64_t)a1) != 123)
  {
LABEL_74:
    uint64_t v15 = "corrupt lease file; expecting left brace";
    goto LABEL_75;
  }

uint64_t sub_100006C30( int32x2_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v176 = 0LL;
  *(void *)uint64_t v177 = 0LL;
  if (dword_100089B0C != 30)
  {
    sub_100046D6C((uint64_t)a1, "IA_PD is only supported in DHCPv6 mode.", a3, a4, a5, a6, a7, a8, (char)v174);
    return sub_100046C44(a1);
  }

  if (sub_100036D00(&__s, &v181, (uint64_t)a1) != 262)
  {
    uint64_t v15 = "corrupt lease file; expecting an iaid+ia_pd string";
    goto LABEL_75;
  }

  uint64_t v10 = v181 - 4;
  if (v181 <= 4)
  {
    uint64_t v15 = "corrupt lease file; iaid+ia_pd string too short";
    goto LABEL_75;
  }

  uint64_t v17 = *(unsigned int *)__s;
  uint64_t v183 = 0LL;
  if (sub_10002DBB4( &v183,  v17,  __s + 4,  v10,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4914LL,  v13,  v14)) {
    sub_100061FB4("Out of memory.", v18, v19, v20, v21, v22, v23, v24, (char)v174);
  }
  *((_WORD *)v183 + 16) = 25;
  if (sub_100036D00(&__s, 0LL, (uint64_t)a1) != 123)
  {
LABEL_74:
    uint64_t v15 = "corrupt lease file; expecting left brace";
    goto LABEL_75;
  }

BOOL sub_10000745C( uint64_t a1, int32x2_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a4;
  uint64_t v181 = 0LL;
  uint64_t v182 = 0LL;
  int v180 = 0;
  uint64_t v177 = 0LL;
  if ((byte_10008CF96 & 1) == 0 && dword_100089B0C == 30)
  {
    byte_10008CF96 = 1;
    sub_10006221C( "WARNING: class declarations are not supported for DHCPv6.",  (uint64_t)a2,  a3,  a4,  a5,  a6,  a7,  a8,  v173);
  }

  if (sub_100036D00(&__s, 0LL, (uint64_t)a2) != 262)
  {
    uint64_t v23 = "Expecting class name";
LABEL_19:
    sub_100046D6C((uint64_t)a2, v23, v12, v13, v14, v15, v16, v17, v173);
    sub_100046C44(a2);
    return 0LL;
  }

  sub_100003828((uint64_t)&v181, __s, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 2069LL);
  BOOL v18 = v8 != 2 || v181 == 0;
  int v19 = !v18;
  if (!v18)
  {
    sub_1000338BC(&v182, v181, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 2076LL);
    sub_1000338C0(&v181, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 2078LL);
    goto LABEL_13;
  }

  if (v8 != 2 && !v181)
  {
    char v173 = (char)__s;
    uint64_t v23 = "no class named %s";
    goto LABEL_19;
  }

  BOOL v20 = v8 == 0;
  if (v8 <= 1)
  {
    LODWORD(v179) = strlen(__s);
    *(void *)&__int128 v178 = 0LL;
    if (!sub_1000345C4( &v178,  (int)v179 + 1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2095LL)) {
      sub_100061FB4("no memory for class name.", v25, v26, v27, v28, v29, v30, v31, v173);
    }
    *((void *)&v178 + 1) = v178 + 4;
    char v22 = 1;
    HIDWORD(v179) = 1;
    if (v8) {
      uint64_t v21 = "implicit-vendor-class";
    }
    else {
      uint64_t v21 = "implicit-user-class";
    }
    goto LABEL_27;
  }

  if (v8 != 2)
  {
    if (v8 == 3)
    {
      int v75 = sub_1000374AC(&__s, 0LL, a2);
      if (v75 == 262)
      {
        sub_100036D00(&__s, &v179, (uint64_t)a2);
        *(void *)&__int128 v178 = 0LL;
        if (!sub_1000345C4( &v178,  (int)v179 + 1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2122LL))
        {
          if (!v181) {
            return 0LL;
          }
          uint64_t v158 = 2124LL;
          goto LABEL_120;
        }

        HIDWORD(v179) = 1;
        *((void *)&v178 + 1) = v178 + 4;
        memcpy((void *)(v178 + 4), __s, (v179 + 1));
      }

      else
      {
        if ((v75 - 263) > 1)
        {
          sub_100046D6C((uint64_t)a2, "Expecting string or hex list.", v76, v77, v78, v79, v80, v81, v173);
          if (!v181) {
            return 0LL;
          }
          uint64_t v158 = 2142LL;
          goto LABEL_120;
        }

        __int128 v178 = 0uLL;
        uint64_t v179 = 0LL;
        if (!sub_100049BDC((uint64_t)&v178, a2))
        {
          if (!v181) {
            return 0LL;
          }
          uint64_t v158 = 2136LL;
          goto LABEL_120;
        }
      }
    }

    BOOL v20 = 0;
    char v22 = 0;
    uint64_t v41 = 0LL;
    goto LABEL_30;
  }

LABEL_13:
  BOOL v20 = 0;
  uint64_t v21 = __s;
  if (!__s)
  {
    uint64_t v41 = 0LL;
    char v22 = 0;
    goto LABEL_32;
  }

  char v22 = 0;
LABEL_27:
  int v32 = strlen(v21);
  uint64_t v33 = (char *)sub_10005CDE4((v32 + 1));
  uint64_t v41 = v33;
  if (!v33) {
    sub_100061FB4("No memory for class name %s.", v34, v35, v36, v37, v38, v39, v40, (char)v21);
  }
  strcpy(v33, __s);
  if (v8 != 2) {
LABEL_30:
  }
    sub_100029804( &v182,  *(void *)(v181 + 80),  *((void *)&v178 + 1),  v179,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2151LL);
LABEL_32:
  uint64_t v42 = v182;
  if (v182)
  {
    int v43 = 25;
  }

  else
  {
    int v43 = sub_1000338A0( (void **)&v182,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2156LL);
    uint64_t v49 = (uint64_t *)v182;
    uint64_t v50 = (uint64_t *)(v182 + 136);
    if (v181)
    {
      sub_100034128( v50,  *(void *)(v181 + 136),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2158LL,  v45,  v46,  v47,  v48);
      sub_1000338BC(v182 + 40, v181, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 2159LL);
      int v55 = *(_DWORD *)(v181 + 56);
      uint64_t v56 = v182;
      *((_DWORD *)v182 + 14) = v55;
      if (v55)
      {
        uint64_t v57 = sub_10005CDE4((8 * v55));
        uint64_t v65 = v182;
        *((void *)v182 + 8) = v57;
        if (!v57) {
          sub_100061FB4("no memory for billing", v58, v59, v60, v61, v62, v63, v64, v173);
        }
        bzero(v57, 8LL * *((int *)v65 + 14));
        uint64_t v56 = v182;
      }

      sub_100034E60( (uint64_t)(v56 + 88),  (uint64_t)&v178,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2171LL,  v51,  v52,  v53,  v54);
      if (!*(void *)(v181 + 80)
        && !sub_10002D664( (uint64_t *)(v181 + 80),  0x2EE7u,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2173LL,  v66,  v67,  v68,  v69))
      {
        sub_100061FB4("No memory for subclass hash.", v70, v71, v72, v73, v74, v68, v69, v173);
      }

      sub_100029214( *(void *)(v181 + 80),  *((const char **)v182 + 12),  *((unsigned int *)v182 + 26),  (uint64_t)v182,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2178LL,  v68,  v69,  v173);
    }

    else
    {
      if (*v50)
      {
        sub_100034198( (char **)v50,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2181LL,  v44,  v45,  v46,  v47,  v48);
        uint64_t v49 = (uint64_t *)v182;
      }

      if (!sub_1000406C0( v49 + 17,  a3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2182LL,  v45,  v46,  v47,  v48)) {
        sub_100061FB4("no memory to clone class group.", v82, v83, v13, v14, v15, v16, v17, v173);
      }
    }

    if ((v22 & 1) != 0)
    {
      uint64_t v177 = 0LL;
      if (!sub_100034984( &v177,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2191LL)) {
        sub_100061FB4("no memory for class statement.", v84, v85, v86, v87, v88, v89, v90, v173);
      }
      uint64_t v91 = v177;
      *(_DWORD *)(v177 + 16) = 6;
      if (sub_100034540( (void *)(v91 + 24),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2195LL,  v86,  v87,  v88,  v89,  v90))
      {
        uint64_t v92 = v177;
        uint64_t v93 = *(void *)(v177 + 24);
        *(_OWORD *)(v93 + 32) = v178;
        *(void *)(v93 + 48) = v179;
        if (v20) {
          int v94 = 60;
        }
        else {
          int v94 = 77;
        }
        int v176 = v94;
        sub_100029804( *(void *)(v92 + 24) + 24LL,  qword_10008C1E0,  &v176,  0LL,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2203LL);
      }

      uint64_t v42 = v182;
      *((void *)v182 + 18) = v177;
    }

    else
    {
      uint64_t v42 = v182;
    }

    uint64_t v95 = (void *)*((void *)v42 + 6);
    if (v95)
    {
      sub_10005CE20( v95,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2210LL,  v13,  v14,  v15,  v16,  v17);
      uint64_t v42 = v182;
    }

    *((void *)v42 + 6) = v41;
  }

  if (v8 != 2)
  {
    sub_100034EA8( (_DWORD **)&v178,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2215LL,  v13,  v14,  v15,  v16,  v17);
    uint64_t v42 = v182;
  }

  if (*((void *)v42 + 5))
  {
    if (sub_1000374AC(&__s, 0LL, a2) == 59)
    {
      sub_100036D00(&__s, 0LL, (uint64_t)a2);
      if (a1) {
        int v43 = sub_1000338BC(a1, v182, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 2223LL);
      }
      sub_1000338C0(&v182, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 2224LL);
      if (v181)
      {
        uint64_t v100 = 2226LL;
        goto LABEL_151;
      }

      return !a1 || v43 == 0;
    }

    if (!sub_1000406C0( (uint64_t *)v182 + 17,  *((void *)v182 + 17),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2230LL,  v96,  v97,  v98,  v99)) {
      sub_100061FB4("can't clone class group.", v101, v102, v103, v104, v105, v106, v107, v173);
    }
  }

  if (!sub_10000BC3C(a2))
  {
    sub_1000338C0(&v182, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 2236LL);
    if (v181)
    {
      uint64_t v158 = 2238LL;
LABEL_120:
      sub_1000338C0(&v181, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", v158);
    }

    return 0LL;
  }

  int v174 = v19;
  uint64_t v108 = 0LL;
  int v109 = 0;
  int v110 = 0;
  while (1)
  {
    while (1)
    {
      while (1)
      {
        int v111 = sub_1000374AC(&__s, 0LL, a2);
        if (v111 <= 347) {
          break;
        }
        if (v111 > 416)
        {
          if (v111 == 417)
          {
            uint64_t v118 = v182;
            int v119 = *((_DWORD *)v182 + 38) | 1;
            goto LABEL_93;
          }

          if (v111 == 607)
          {
            sub_100036D00(&__s, 0LL, (uint64_t)a2);
            sub_100046D6C((uint64_t)a2, "unexpected end of file", v159, v160, v161, v162, v163, v164, v173);
            goto LABEL_136;
          }

  if (v104) {
    sub_10003389C(&v104, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 5287LL);
  }
  if (v103) {
    sub_10003389C(&v103, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 5289LL);
  }
  return 0LL;
}

    sub_100060130(v2, 1);
    return v1;
  }

  uint64_t v6 = *(void *)(v5 + 8);
  if (*(_DWORD *)(v6 + 28LL * (int)v4) != 2)
  {
    sub_100060130(v2, 1);
    return 39LL;
  }

  uint64_t v7 = *(_DWORD *)(v6 + 28 * v4 + 8);
  *(_WORD *)(v2 + 44) = 528;
  *(_DWORD *)(v2 + 48) = v7;
  *(_WORD *)(v2 + 46) = bswap32(*(unsigned __int16 *)(*(void *)(v5 + 8) + 28 * v4 + 24)) >> 16;
  *(void *)(v2 + 52) = 0LL;
  *(_DWORD *)(v2 + 88) = v4 + 1;
  uint64_t v10 = connect(*(_DWORD *)(v2 + 32), (const sockaddr *)(v2 + 44), 0x10u);
  if ((v10 & 0x80000000) == 0)
  {
LABEL_11:
    *(_DWORD *)(v2 + 40) = 2;
LABEL_12:
    uint64_t v9 = 16;
    getsockname(*(_DWORD *)(v2 + 32), (sockaddr *)(v2 + 60), &v9);
    uint64_t v1 = sub_100060F90( v2,  (uint64_t)sub_100060330,  (uint64_t)sub_10005F7CC,  (uint64_t)sub_10005E478,  (uint64_t)sub_10005EBC0,  (uint64_t)sub_10005F84C);
    if (!(_DWORD)v1)
    {
      sub_100067DF8(v2);
      sub_10005D658((int **)(v2 + 80));
      return v1;
    }

    goto LABEL_13;
  }

  uint64_t v10 = *__error();
  if (v10 == 36)
  {
    *(_DWORD *)(v2 + 40) = 1;
    return 49LL;
  }

  else
  {
    sub_100060130(v2, 1);
    if (v10 == 61)
    {
      return 12LL;
    }

    else if (v10 == 51)
    {
      return 8LL;
    }

    else
    {
      return sub_100068C8C(v10);
    }
  }

LABEL_114:
          uint64_t v108 = sub_1000041D0(a2, *((void *)v182 + 17), 4LL, 0LL, v108);
        }

        else
        {
          if (v111 == 348)
          {
            sub_100036D00(&__s, 0LL, (uint64_t)a2);
            if (v181)
            {
              uint64_t v165 = "invalid spawn in subclass.";
            }

            else
            {
              *((_DWORD *)v182 + 32) = 1;
              uint64_t v165 = "expecting with after spawn";
            }

LABEL_134:
            sub_100046D6C((uint64_t)a2, v165, v112, v113, v114, v115, v116, v117, v173);
            goto LABEL_135;
          }

          if (v111 != 358) {
            goto LABEL_114;
          }
          uint64_t v118 = v182;
          int v119 = *((_DWORD *)v182 + 38) | 2;
LABEL_93:
          *((_DWORD *)v118 + 38) = v119;
          sub_100036D00(&__s, 0LL, (uint64_t)a2);
        }
      }

      if (v111 == 271) {
        break;
      }
      if (v111 != 347)
      {
        if (v111 == 125)
        {
          sub_100036D00(&__s, 0LL, (uint64_t)a2);
          goto LABEL_136;
        }

        goto LABEL_114;
      }

      if (v181)
      {
        uint64_t v165 = "invalid match in subclass.";
        goto LABEL_134;
      }

      sub_100036D00(&__s, 0LL, (uint64_t)a2);
      if (sub_1000374AC(&__s, 0LL, a2) == 341)
      {
        sub_100036D00(&__s, 0LL, (uint64_t)a2);
        if (v109)
        {
          uint64_t v165 = "A class may only have one 'match if' clause.";
          goto LABEL_134;
        }

        uint64_t v120 = (uint64_t *)v182;
        if (*((void *)v182 + 14))
        {
          sub_100054390( (uint64_t *)v182 + 14,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2283LL,  v113,  v114,  v115,  v116,  v117);
          uint64_t v120 = (uint64_t *)v182;
        }

        if (sub_10004C790(v120 + 14, a2, &v180, v113, v114, v115, v116, v117))
        {
          sub_100046D08(a2);
          int v109 = 1;
        }

        else
        {
          int v109 = 1;
          if (!v180)
          {
            uint64_t v156 = (uint64_t)a2;
            uint64_t v157 = "expecting BOOLean expr.";
LABEL_117:
            sub_100046D6C(v156, v157, v121, v122, v123, v124, v125, v126, v173);
            sub_100046C44(a2);
          }
        }
      }

      else
      {
LABEL_97:
        if (v110)
        {
          sub_100046D6C( (uint64_t)a2,  "can't override existing %s.",  v112,  v113,  v114,  v115,  v116,  v117,  (char)"submatch/spawn");
          goto LABEL_135;
        }

        uint64_t v130 = (uint64_t *)v182;
        if (*((void *)v182 + 15))
        {
          sub_100054390( (uint64_t *)v182 + 15,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2324LL,  v113,  v114,  v115,  v116,  v117);
          uint64_t v130 = (uint64_t *)v182;
        }

        if (sub_10004C02C(v130 + 15, (uint64_t)a2, &v180))
        {
          sub_100046D08(a2);
          int v110 = 1;
        }

        else
        {
          int v110 = 1;
          if (!v180)
          {
            uint64_t v156 = (uint64_t)a2;
            uint64_t v157 = "expecting data expr.";
            goto LABEL_117;
          }
        }
      }
    }

    sub_100036D00(&__s, 0LL, (uint64_t)a2);
    int v131 = sub_100036D00(&__s, 0LL, (uint64_t)a2);
    if (v131 != 362)
    {
      int v166 = v131;
      uint64_t v167 = "expecting limit";
      goto LABEL_128;
    }

    int v138 = sub_100036D00(&__s, 0LL, (uint64_t)a2);
    if (v138 != 263) {
      break;
    }
    int v139 = atoi(__s);
    uint64_t v145 = v182;
    *((_DWORD *)v182 + 14) = v139;
    uint64_t v146 = (void *)*((void *)v145 + 8);
    if (v146)
    {
      sub_10005CE20( v146,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2357LL,  v140,  v141,  v142,  v143,  v144);
      int v139 = *((_DWORD *)v182 + 14);
    }

    uint64_t v147 = sub_10005CDE4((8 * v139));
    uint64_t v155 = v182;
    *((void *)v182 + 8) = v147;
    if (!v147) {
      sub_100061FB4("no memory for billed leases.", v148, v149, v150, v151, v152, v153, v154, v173);
    }
    bzero(v147, 8LL * *((int *)v155 + 14));
    dword_10008BD80 = 1;
    sub_100046D08(a2);
  }

  int v166 = v138;
  uint64_t v167 = "expecting a number";
LABEL_128:
  sub_100046D6C((uint64_t)a2, v167, v132, v133, v134, v135, v136, v137, v173);
  if (v166 == 59) {
    goto LABEL_136;
  }
LABEL_135:
  sub_100046C44(a2);
LABEL_136:
  if ((v182[152] & 1) != 0)
  {
    if (v8 == 2)
    {
      uint64_t v175 = 0LL;
      int v43 = sub_100003828( (uint64_t)&v175,  *((char **)v182 + 6),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2380LL);
      if (!v43)
      {
        sub_100029D78(v175, 0);
        sub_1000338C0(&v175, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 2383LL);
      }
    }

    else
    {
      sub_100029210( *(void *)(v181 + 80),  *((const char **)v182 + 12),  *((unsigned int *)v182 + 26),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2388LL,  v127,  v128,  v129);
    }
  }

  else if ((v8 == 2) != v174)
  {
    uint64_t v168 = off_100088018 + 2;
    uint64_t v169 = off_100088018[2];
    if (v169)
    {
      do
      {
        uint64_t v170 = v169;
        uint64_t v169 = *(void *)(v169 + 32);
      }

      while (v169);
      uint64_t v168 = (uint64_t *)(v170 + 32);
      uint64_t v171 = 2398LL;
    }

    else
    {
      uint64_t v171 = 2392LL;
    }

    sub_1000338BC(v168, v182, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", v171);
  }

  if (a1) {
    int v43 = sub_1000338BC(a1, v182, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 2403LL);
  }
  sub_1000338C0(&v182, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 2404LL);
  if (v181)
  {
    uint64_t v100 = 2406LL;
LABEL_151:
    sub_1000338C0(&v181, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", v100);
  }

  return !a1 || v43 == 0;
}

        uint64_t v145 = sub_100040D4C(&qword_10008BF80, a6, 52LL, v40, v41, v42, v43, v44);
        if (!v145
          || sub_100057AF8( (_DWORD *)&v174 + 1,  (unsigned int *)a1,  a2,  0LL,  *(void *)(a1 + 160),  a6,  v14,  v145,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  0x287u))
        {
          if ((_DWORD)v174
            && (uint64_t v146 = sub_100040D4C(&qword_10008C318, *(void *)(a1 + 160), 2LL, v40, v41, v42, v43, v44)) != 0
            && !sub_100057AF8( (_DWORD *)&v174 + 1,  (unsigned int *)a1,  a2,  0LL,  *(void *)(a1 + 160),  a6,  v14,  v146,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  0x297u))
          {
            uint64_t v160 = sub_100040D4C(&qword_10008C318, *(void *)(a1 + 160), 8LL, v40, v41, v42, v43, v44);
            if (v160)
            {
              if (sub_100057AA4( &v176,  (unsigned int *)a1,  a2,  0LL,  *(void *)(a1 + 160),  a6,  v14,  v160,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  0x29Bu))
              {
                if ((_DWORD)v178)
                {
                  if (sub_1000345C4( &v175,  (int)v178 + 5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  669LL))
                  {
                    *((_BYTE *)v175 + 4) = 0;
                    if (sub_100040F30( &qword_10008C318,  a6,  (uint64_t)v175,  (uint64_t)(v175 + 1),  1LL,  2LL,  0LL,  v44))
                    {
                      *((_BYTE *)v175 + 5) = 0;
                      if (sub_100040F30( &qword_10008C318,  a6,  (uint64_t)v175,  (uint64_t)v175 + 5,  1LL,  1LL,  0LL,  v44))
                      {
                        uint64_t v161 = sub_100040D4C(&qword_10008C318, *(void *)(a1 + 160), 3LL, v40, v41, v42, v43, v44);
                        uint64_t v163 = v161
                            && sub_100057AF8( (_DWORD *)&v174 + 1,  (unsigned int *)a1,  a2,  0LL,  *(void *)(a1 + 160),  a6,  v14,  v161,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  0x2B6u);
                        *((_BYTE *)v175 + 6) = v163;
                        if (sub_100040F30( &qword_10008C318,  a6,  (uint64_t)v175,  (uint64_t)v175 + 6,  1LL,  3LL,  0LL,  v162))
                        {
                          *((_BYTE *)v175 + 7) = -1;
                          if (sub_100040F30( &qword_10008C318,  a6,  (uint64_t)v175,  (uint64_t)v175 + 7,  1LL,  4LL,  0LL,  v44))
                          {
                            uint64_t v164 = v175;
                            uint64_t v165 = v175;
                            *((_BYTE *)v175 + 8) = -1;
                            if (sub_100040F30( &qword_10008C318,  a6,  (uint64_t)v164,  (uint64_t)(v165 + 2),  1LL,  5LL,  0LL,  v44))
                            {
                              int v166 = v175;
                              uint64_t v167 = (char *)v175 + 9;
                              memcpy((char *)v175 + 9, v177, v178);
                              if (sub_100040F30( &qword_10008C318,  a6,  (uint64_t)v166,  (uint64_t)v167,  v178,  8LL,  0LL,  v168)) {
                                sub_100034EA8( &v176,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  731LL,  v40,  v41,  v42,  v43,  v44);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }

          else
          {
            uint64_t v147 = v45;
            uint64_t v148 = sub_100040D4C(&qword_10008C318, *(void *)(a1 + 160), 3LL, v40, v41, v42, v43, v44);
            if (v148)
            {
              uint64_t v149 = v148;
              if (sub_1000345C4( &v175,  (int)v187 + 5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  741LL))
              {
                *((_BYTE *)v175 + 4) = v147;
                if (sub_100040F30( &qword_10008C318,  a6,  (uint64_t)v175,  (uint64_t)(v175 + 1),  1LL,  2LL,  0LL,  v44))
                {
                  *((_BYTE *)v175 + 5) = v147;
                  if (sub_100040F30( &qword_10008C318,  a6,  (uint64_t)v175,  (uint64_t)v175 + 5,  1LL,  1LL,  0LL,  v44))
                  {
                    uint64_t v150 = sub_100057AF8( (_DWORD *)&v174 + 1,  (unsigned int *)a1,  a2,  0LL,  *(void *)(a1 + 160),  a6,  v14,  v149,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  0x2F4u) != 0;
                    *((_BYTE *)v175 + 6) = v150;
                    if (sub_100040F30( &qword_10008C318,  a6,  (uint64_t)v175,  (uint64_t)v175 + 6,  1LL,  3LL,  0LL,  v151))
                    {
                      *((_BYTE *)v175 + 7) = sub_100068CB0(v50);
                      if (sub_100040F30( &qword_10008C318,  a6,  (uint64_t)v175,  (uint64_t)v175 + 7,  1LL,  4LL,  0LL,  v152))
                      {
                        uint64_t v153 = sub_100068CB0(v61);
                        uint64_t v154 = v175;
                        uint64_t v155 = v175;
                        *((_BYTE *)v175 + 8) = v153;
                        if (sub_100040F30( &qword_10008C318,  a6,  (uint64_t)v154,  (uint64_t)(v155 + 2),  1LL,  5LL,  0LL,  v156))
                        {
                          if ((_DWORD)v187)
                          {
                            uint64_t v157 = v175;
                            uint64_t v158 = (char *)v175 + 9;
                            memcpy((char *)v175 + 9, __s2, v187);
                            sub_100040F30( &qword_10008C318,  a6,  (uint64_t)v157,  (uint64_t)v158,  v187,  8LL,  0LL,  v159);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

        goto LABEL_60;
      }
    }

    uint64_t v60 = sub_100040D4C(&qword_10008BF80, a6, 41LL, v52, v53, v54, v55, (uint64_t)v57);
    if (!v60
      || sub_100057AF8( (_DWORD *)&v174 + 1,  (unsigned int *)a1,  a2,  0LL,  *(void *)(a1 + 160),  a6,  v14,  v60,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  0x199u))
    {
      uint64_t v50 = 0;
      uint64_t v61 = 0;
      unsigned int v8 = 1LL;
      goto LABEL_134;
    }

    goto LABEL_55;
  }

  unsigned int v8 = 0LL;
  if (sub_10000F3C0(a2, a4))
  {
    uint64_t v48 = v187;
    if ((_DWORD)v187) {
      goto LABEL_56;
    }
  }

uint64_t sub_100007FE0(int32x2_t *a1, uint64_t a2)
{
  uint64_t v137 = 0LL;
  uint64_t v4 = sub_1000470FC(a1);
  if (!v4)
  {
    sub_100046D6C((uint64_t)a1, "expecting a name for host declaration.", v5, v6, v7, v8, v9, v10, v135);
    return sub_100046C44(a1);
  }

  uint64_t v11 = v4;
  uint64_t v140 = 0LL;
  unsigned int v12 = sub_100033904( (void **)&v140,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  1812LL);
  if (v12)
  {
    sub_100067900(v12);
    sub_100061FB4("can't allocate host decl struct %s: %s", v17, v18, v19, v20, v21, v22, v23, (char)v11);
  }

  uint64_t v24 = (uint64_t *)v140;
  *((void *)v140 + 6) = v11;
  if (!sub_1000406C0( v24 + 19,  a2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  1817LL,  v13,  v14,  v15,  v16)) {
    sub_100061FB4("can't clone group for host %s", v25, v26, v27, v28, v29, v30, v31, (char)v11);
  }
  if (!sub_10000BC3C(a1))
  {
    uint64_t v100 = 1820LL;
    return sub_100033924( (_DWORD **)&v140,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  v100);
  }

  uint64_t v32 = 0LL;
  int v33 = 0;
  int v34 = 0;
  while (1)
  {
    while (1)
    {
      while (1)
      {
        int v35 = sub_1000374AC(&__s, 0LL, a1);
        if (v35 > 357) {
          break;
        }
        switch(v35)
        {
          case 269:
            sub_100036D00(&__s, 0LL, (uint64_t)a1);
            sub_100034EA8( (_DWORD **)v140 + 10,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  1891LL,  v65,  v66,  v67,  v68,  v69);
            if (!*((_DWORD *)v140 + 24))
            {
              if (sub_1000374AC(&__s, 0LL, a1) == 262)
              {
                sub_100036D00(&__s, &v136, (uint64_t)a1);
                uint64_t v76 = 0LL;
                uint64_t v77 = __s;
                *((_DWORD *)v140 + 25) = 1;
              }

              else
              {
                LODWORD(v136) = 0;
                uint64_t v77 = sub_100047540(a1, 0LL, (unsigned int *)&v136, 58, 16LL, 8LL);
                uint64_t v76 = v77;
                if (!v77)
                {
                  sub_100046D6C((uint64_t)a1, "expecting hex list.", v78, v79, v80, v81, v82, v83, v135);
                  sub_100046C44(a1);
                }
              }

              if (!sub_1000345C4( (void *)v140 + 10,  *((_DWORD *)v140 + 25) + (int)v136,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  1920LL)) {
                sub_100061FB4( "no memory for uid for host %s.",  v84,  v85,  v86,  v87,  v88,  v89,  v90,  *((void *)v140 + 6));
              }
              uint64_t v91 = v140;
              uint64_t v92 = (void *)(*((void *)v140 + 10) + 4LL);
              *((void *)v140 + 11) = v92;
              int v93 = (int)v136;
              *((_DWORD *)v91 + 24) = (_DWORD)v136;
              memcpy(v92, v77, (*((_DWORD *)v91 + 25) + v93));
              if (v76) {
                sub_10005CE20( v76,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  1929LL,  v94,  v95,  v96,  v97,  v98);
              }
              goto LABEL_38;
            }

            uint64_t v135 = *((void *)v140 + 6);
            uint64_t v102 = "Host %s already has a client identifier.";
            goto LABEL_59;
          case 293:
            sub_100036D00(&__s, 0LL, (uint64_t)a1);
            unsigned int v42 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
            if (v42 != 262 && (v42 < 0x100 || v42 == 607 || v42 == 263))
            {
              uint64_t v101 = "expecting string or identifier.";
LABEL_63:
              sub_100046D6C((uint64_t)a1, v101, v36, v37, v38, v39, v40, v41, v135);
              sub_100046C4C(a1, 1u);
LABEL_64:
              if (!v34) {
                goto LABEL_70;
              }
LABEL_65:
              uint64_t v136 = 0LL;
              size_t v103 = strlen(*((const char **)v140 + 6));
              if (sub_100029804( &v136,  qword_10008BE20,  *((void *)v140 + 6),  v103,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  1995LL))
              {
                sub_100029808((uint64_t)v136, 0, v104, v105, v106, v107, v108, v109);
                sub_100033924(&v136, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 1997LL);
              }

              goto LABEL_84;
            }

            uint64_t v136 = 0LL;
            size_t v43 = strlen(__s);
            if (sub_100029804( &v136,  qword_10008C130,  __s,  v43,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  1869LL))
            {
              uint64_t v50 = v140;
              if (*((void *)v140 + 20))
              {
                sub_1000235C8(v140 + 160, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 1875LL);
                uint64_t v50 = v140;
              }

              sub_1000235CC(v50 + 160, v136, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 1877LL);
              sub_1000235C8(&v136, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 1878LL);
            }

            else
            {
              sub_100046D6C((uint64_t)a1, "unknown group %s in host %s", v44, v45, v46, v47, v48, v49, (char)__s);
            }

LABEL_38:
            break;
          case 125:
            sub_100036D00(&__s, 0LL, (uint64_t)a1);
            if (!v34) {
              goto LABEL_70;
            }
            goto LABEL_65;
          default:
LABEL_45:
            uint64_t v32 = sub_1000041D0(a1, *((void *)v140 + 19), 1LL, v140, v32);
            break;
        }
      }

      if (v35 > 636) {
        break;
      }
      switch(v35)
      {
        case 358:
          sub_100036D00(&__s, 0LL, (uint64_t)a1);
          int v33 = 1;
          break;
        case 417:
          sub_100036D00(&__s, 0LL, (uint64_t)a1);
          int v34 = 1;
          break;
        case 607:
          sub_100036D00(&__s, 0LL, (uint64_t)a1);
          uint64_t v102 = "unexpected end of file";
LABEL_59:
          sub_100046D6C((uint64_t)a1, v102, v70, v71, v72, v73, v74, v75, v135);
          if (!v34) {
            goto LABEL_70;
          }
          goto LABEL_65;
        default:
          goto LABEL_45;
      }
    }

    if (v35 != 637) {
      goto LABEL_45;
    }
    if (*((void *)v140 + 13))
    {
      uint64_t v101 = "only one host-identifier allowed per host";
      goto LABEL_63;
    }

    sub_100036D00(&__s, 0LL, (uint64_t)a1);
    if (sub_100036D00(&__s, 0LL, (uint64_t)a1) != 260)
    {
      uint64_t v101 = "host-identifier must be an option";
      goto LABEL_63;
    }

    int v139 = 0;
    uint64_t v138 = 0LL;
    uint64_t v37 = v138;
    if (!v138) {
      goto LABEL_64;
    }
    if (!v139)
    {
      uint64_t v135 = **(void **)(v138 + 16);
      uint64_t v101 = "unknown option %s.%s";
      goto LABEL_63;
    }

    if (!sub_10004E968(&v137, a1, 1LL, v138, v38, v39, v40, v41))
    {
      sub_100046C4C(a1, 1u);
      uint64_t v115 = 1968LL;
      goto LABEL_69;
    }

    sub_100052CB0((void *)v140 + 13, v138);
    sub_100052CE4( &v138,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  1980LL,  v51,  v52,  v53,  v54,  v55);
    sub_100034E60( (uint64_t)(v140 + 112),  v137 + 8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  1982LL,  v56,  v57,  v58,  v59);
    sub_100054390( &v137,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  1983LL,  v60,  v61,  v62,  v63,  v64);
  }

  sub_100046C4C(a1, 1u);
  sub_100054390( &v137,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  1974LL,  v116,  v117,  v118,  v119,  v120);
  uint64_t v115 = 1975LL;
LABEL_69:
  sub_100052CE4( &v138,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  v115,  v110,  v111,  v112,  v113,  v114);
  if (v34) {
    goto LABEL_65;
  }
LABEL_70:
  uint64_t v121 = *((void *)v140 + 20);
  if (v121)
  {
    uint64_t v122 = *(void *)(v121 + 40);
    if (v122)
    {
      uint64_t v123 = (char **)*((void *)v140 + 19);
      if (v123[6] || *((_DWORD *)v123 + 10) != *(_DWORD *)(v122 + 40))
      {
        if (*v123)
        {
          sub_100034198( v123,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2006LL,  v37,  v38,  v39,  v40,  v41);
          uint64_t v123 = (char **)*((void *)v140 + 19);
          uint64_t v122 = *(void *)(*((void *)v140 + 20) + 40LL);
        }

        uint64_t v124 = 2009LL;
      }

      else
      {
        sub_100034198( (char **)v140 + 19,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2011LL,  v37,  v38,  v39,  v40,  v41);
        uint64_t v123 = (char **)(v140 + 152);
        uint64_t v122 = *(void *)(*((void *)v140 + 20) + 40LL);
        uint64_t v124 = 2014LL;
      }

      sub_100034128( (uint64_t *)v123,  v122,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  v124,  v38,  v39,  v40,  v41);
    }
  }

  uint64_t v125 = (uint64_t)v140;
  if (v33) {
    int v126 = 2;
  }
  else {
    int v126 = 4;
  }
  *((_DWORD *)v140 + 48) |= v126;
  unsigned int v127 = sub_100029218(v125, v33, 0, v37, v38, v39, v40, v41);
  if (v127)
  {
    uint64_t v128 = *((void *)v140 + 6);
    sub_100067900(v127);
    sub_100046D6C((uint64_t)a1, "host %s: %s", v129, v130, v131, v132, v133, v134, v128);
  }

    uint64_t v10 = *(void *)(*(void *)(qword_10009D1D8 + 56) + 8 * v9);
    goto LABEL_43;
  }

  if (qword_10009D180)
  {
    uint64_t v8 = qword_10009D180 + 144;
    while (1)
    {
      uint64_t v8 = *(void *)v8;
      if (!v8) {
        break;
      }
      if (*(_DWORD *)(v8 + 28) == dword_10009D228) {
        goto LABEL_56;
      }
    }

    uint64_t v8 = *(void *)(qword_10009D180 + 144);
LABEL_56:
    *(_OWORD *)uint64_t v57 = *(_OWORD *)(v8 + 8);
    *(void *)&v57[16] = *(void *)(v8 + 24);
    uint64_t v37 = &qword_10008C730;
    goto LABEL_57;
  }

  return 39LL;
}

  uint64_t v52 = sub_100057DA8(v94);
  uint64_t v53 = sub_100057DA8(v92);
  if (v52 && v53 && v52 != v53)
  {
    sub_100046D6C((uint64_t)a2, "illegal expression relating different types", v54, v26, v27, v28, v29, v30, v92);
    sub_100046C4C(a2, 0);
    sub_100054390( &v94,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  4802LL,  v80,  v81,  v82,  v83,  v84);
    uint64_t v90 = &v92;
    uint64_t v91 = 4803LL;
    goto LABEL_82;
  }

  if (v8 > 46)
  {
    if ((v8 - 47) >= 8)
    {
      if (v8 == 58 && sub_100057DA8(v94) != 2)
      {
        sub_100046D6C((uint64_t)a2, "expecting data expression", v55, v26, v27, v28, v29, v30, v92);
        sub_100046C4C(a2, 0);
        uint64_t v90 = &v94;
        uint64_t v91 = 4828LL;
        goto LABEL_82;
      }
    }

    else if (v52 && v52 != 3)
    {
      sub_100046D6C((uint64_t)a2, "expecting numeric expressions", v54, v26, v27, v28, v29, v30, v92);
      sub_100046C4C(a2, 0);
      uint64_t v90 = &v94;
      uint64_t v91 = 4864LL;
      goto LABEL_82;
    }

    sub_100060130((uint64_t)v7, 1);
    return v4;
  }

  while (1)
  {
    uint64_t v11 = *(void *)v11;
    if (!v11) {
      return 47LL;
    }
    if (*(void *)(v11 + 16) == a2) {
      goto LABEL_16;
    }
  }

LABEL_84:
  uint64_t v100 = 2028LL;
  return sub_100033924( (_DWORD **)&v140,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  v100);
}

uint64_t sub_100008728( int32x2_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v70 = 0LL;
  if (!sub_1000406C0( (uint64_t *)&v70,  a2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2778LL,  a5,  a6,  a7,  a8)) {
    sub_100061FB4("no memory for explicit group.", v9, v10, v11, v12, v13, v14, v15, v68);
  }
  unsigned int v16 = sub_1000374AC(&__s, 0LL, a1);
  BOOL v19 = v16 > 0xFF && v16 - 264 < 0xFFFFFFFE && v16 != 607;
  if (v16 == 262 || (uint64_t v20 = 0LL, v19))
  {
    sub_100036D00(&__s, 0LL, (uint64_t)a1);
    int v21 = strlen(__s);
    uint64_t v22 = (char *)sub_10005CDE4((v21 + 1));
    uint64_t v20 = v22;
    if (!v22) {
      sub_100061FB4("no memory for group decl name %s", v23, v24, v25, v26, v27, v28, v29, (char)__s);
    }
    strcpy(v22, __s);
  }

  if (!sub_10000BC3C(a1)) {
    return sub_100034198( &v70,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2792LL,  v30,  v31,  v32,  v33,  v34);
  }
  uint64_t v35 = 0LL;
  int v36 = 0;
  int v37 = 0;
  int v38 = 0;
  while (1)
  {
    int v39 = sub_1000374AC(&__s, 0LL, a1);
    if (v39 > 413) {
      break;
    }
    if (v39 == 358)
    {
      int v37 = 1;
      goto LABEL_26;
    }

    if (v39 == 125)
    {
      uint64_t result = sub_100036D00(&__s, 0LL, (uint64_t)a1);
      if (!v20) {
        return result;
      }
      goto LABEL_35;
    }

LABEL_27:
    uint64_t v35 = sub_1000041D0(a1, v70, 5LL, 0LL, v35);
  }

  if (v39 == 414)
  {
    int v38 = 1;
    goto LABEL_26;
  }

  if (v39 == 417)
  {
    int v36 = 1;
LABEL_26:
    sub_100036D00(&__s, 0LL, (uint64_t)a1);
    sub_100046D08(a1);
    goto LABEL_27;
  }

  if (v39 != 607) {
    goto LABEL_27;
  }
  sub_100036D00(&__s, 0LL, (uint64_t)a1);
  uint64_t result = sub_100046D6C((uint64_t)a1, "unexpected end of file", v40, v41, v42, v43, v44, v45, v68);
  if (!v20) {
    return result;
  }
LABEL_35:
  if (v36)
  {
    if (qword_10008C130)
    {
      uint64_t v69 = 0LL;
      size_t v47 = strlen(v20);
      uint64_t result = sub_100029804( &v69,  qword_10008C130,  v20,  v47,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2829LL);
      if ((_DWORD)result) {
        uint64_t result = sub_10004042C((uint64_t)v69, 0);
      }
    }
  }

  else
  {
    uint64_t v69 = 0LL;
    unsigned int v48 = sub_1000358FC( (void **)&v69,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2835LL);
    if (v48)
    {
      char v53 = (char)__s;
      sub_100067900(v48);
      sub_100061FB4("no memory for group decl %s: %s", v54, v55, v56, v57, v58, v59, v60, v53);
    }

    sub_100034128( v69 + 5,  (uint64_t)v70,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2839LL,  v49,  v50,  v51,  v52);
    uint64_t v61 = v69;
    v69[6] = (uint64_t)v20;
    *((_DWORD *)v61 + 14) = (2 * (v37 != 0)) | (4 * (v38 != 0));
    uint64_t result = sub_100040544((uint64_t)v61, 0, v62, v63, v64, v65, v66, v67);
  }

  if (v69) {
    return sub_1000235C8(&v69, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 2847LL);
  }
  return result;
}

        unsigned int v16 = "unknown failover state";
        break;
    }
  }

  else
  {
    switch(v6)
    {
      case 374:
        uint64_t v13 = 4;
        break;
      case 375:
        uint64_t v13 = 2;
        break;
      case 376:
        uint64_t v13 = 3;
        break;
      case 377:
        uint64_t v13 = 5;
        break;
      case 378:
        uint64_t v13 = 6;
        break;
      default:
        if (v6 == 465)
        {
          uint64_t v13 = 10;
        }

        else
        {
          if (v6 != 567) {
            goto LABEL_27;
          }
          uint64_t v13 = 0;
        }

        break;
    }

  uint64_t v23 = *(void *)(a1 + 24);
  if (!v23) {
    return 69LL;
  }
  uint64_t v24 = *(uint64_t (**)(void))(*(void *)v23 + 24LL);
  if (!v24) {
    return 69LL;
  }
  uint64_t result = v24();
  if ((_DWORD)result) {
    return 69LL;
  }
  return result;
}

          int v21 = *((void *)v11 + 3);
          unsigned int v16 = (uint64_t *)(v11 + 24);
          if (v21) {
            goto LABEL_28;
          }
          break;
        case 0xF:
        case 0x15:
          if (*((void *)v11 + 3))
          {
            sub_10005CE20(*((void **)v11 + 3), a2, a3, a4, a5, a6, a7, a8);
            uint64_t v11 = (char *)*a1;
          }

          uint64_t v17 = *((void *)v11 + 4);
          unsigned int v16 = (uint64_t *)(v11 + 32);
          if (!v17) {
            break;
          }
LABEL_28:
          sub_100054390(v16, a2, a3, a4, a5, a6, a7, a8);
          break;
        case 0x10:
          uint64_t v22 = (void *)*((void *)v11 + 3);
          if (v22) {
            sub_10005CE20(v22, a2, a3, a4, a5, a6, a7, a8);
          }
          break;
        default:
          break;
      }

      sub_10005CE20(*a1, a2, a3, a4, a5, a6, a7, a8);
      goto LABEL_30;
    }

    sub_10006221C("%s(%d): negative refcnt!", a2, a3, a4, a5, a6, a7, a8, a2);
    return 0LL;
  }

uint64_t sub_1000089F8(int32x2_t *a1, uint64_t a2)
{
  if (!a2)
  {
    if (sub_100036D00(&__s, 0LL, (uint64_t)a1) == 364)
    {
      unsigned int v26 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
      BOOL v29 = v26 > 0xFF && v26 - 264 < 0xFFFFFFFE && v26 != 607;
      if (v26 == 262 || v29)
      {
        int v34 = strlen(__s);
        uint64_t v35 = (char *)sub_10005CDE4((v34 + 1));
        uint64_t v43 = v35;
        if (!v35) {
          sub_100061FB4("failover peer name %s: no memory", v36, v37, v38, v39, v40, v41, v42, 0);
        }
        strcpy(v35, __s);
        uint64_t v59 = 0LL;
        sub_100022168(&v59, v43);
        if (v59)
        {
          int v50 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
          if (v50 == 466) {
            goto LABEL_3;
          }
          int v57 = v50;
          uint64_t result = sub_100046D6C((uint64_t)a1, "expecting 'state'", v51, v52, v53, v54, v55, v56, v58);
          if (v57 == 59) {
            return result;
          }
        }

        else
        {
          sub_100046D6C((uint64_t)a1, "unknown failover peer: %s", v44, v45, v46, v47, v48, v49, (char)v43);
        }

        return sub_100046C44(a1);
      }

      uint64_t v30 = "expecting failover peer name.";
    }

    else
    {
      uint64_t v30 = "expecting peer";
    }

    sub_100046D6C((uint64_t)a1, v30, v20, v21, v22, v23, v24, v25, v58);
    return sub_100046C44(a1);
  }

  uint64_t v59 = 0LL;
  sub_100021D08(&v59, a2);
LABEL_3:
  int v3 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
  if (v3 != 123)
  {
    int v31 = v3;
    sub_100046D6C((uint64_t)a1, "expecting left brace", v4, v5, v6, v7, v8, v9, v58);
    if (v31 != 59) {
      sub_100046C44(a1);
    }
    uint64_t v32 = 1255LL;
    return sub_100021D0C(&v59, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", v32);
  }

  uint64_t v10 = "expecting state setting.";
  while (1)
  {
    int v11 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
    if (v11 <= 366) {
      break;
    }
    if (v11 == 367)
    {
      BOOL v19 = v59 + 22;
LABEL_14:
      if (sub_100036D00(&__s, 0LL, (uint64_t)a1) != 466)
      {
        uint64_t v10 = "expecting 'state'";
        goto LABEL_46;
      }

      sub_10000BA54(a1, v19 + 4, (uint64_t *)v19 + 3);
    }

    else
    {
      if (v11 != 428) {
        goto LABEL_46;
      }
      if (!v59[60])
      {
        uint64_t v10 = "mclt not valid for primary";
        goto LABEL_46;
      }

      if (sub_100036D00(&__s, 0LL, (uint64_t)a1) != 263)
      {
        uint64_t v10 = "expecting a number.";
        goto LABEL_46;
      }

      int v18 = atoi(__s);
      v59[40] = v18;
      sub_100046D08(a1);
    }
  }

  if (v11 == 366)
  {
    BOOL v19 = v59 + 12;
    goto LABEL_14;
  }

  if (v11 == 125)
  {
    uint64_t v32 = 1302LL;
    return sub_100021D0C(&v59, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", v32);
  }

LABEL_46:
  sub_100046D6C((uint64_t)a1, v10, v12, v13, v14, v15, v16, v17, v58);
  sub_100046C4C(a1, 1u);
  uint64_t v32 = 1298LL;
  return sub_100021D0C(&v59, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", v32);
}
  }

  return 0xFFFFFFFFLL;
}

    if ((*(_BYTE *)(v5 + 1048) & 1) != 0) {
      sub_10006E3A4(*(void **)(v5 + 1056));
    }
    free((void *)v5);
    if (!v4) {
      break;
    }
LABEL_49:
    uint64_t v4 = 0LL;
    break;
  }

uint64_t sub_100008CDC(int32x2_t *a1)
{
  if (sub_100036D00(&v34, &v33, (uint64_t)a1) != 262)
  {
    uint64_t v28 = "corrupt lease file; expecting a DUID";
    goto LABEL_7;
  }

  int v31 = 0LL;
  uint64_t v30 = 0LL;
  uint64_t v32 = v33;
  if (!sub_1000345C4( &v30,  v33,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  5255LL)) {
    sub_100061FB4("Out of memory storing DUID", v8, v9, v10, v11, v12, v13, v14, v29);
  }
  int v31 = v30 + 1;
  memcpy(v30 + 1, v34, v33);
  sub_10001A004((uint64_t)&v30, v15, v16, v17, v18, v19, v20, v21);
  sub_100034EA8( &v30,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  5263LL,  v22,  v23,  v24,  v25,  v26);
  uint64_t result = sub_100036D00(&v34, &v33, (uint64_t)a1);
  if ((_DWORD)result != 59)
  {
    uint64_t v28 = "corrupt lease file; expecting a semicolon";
LABEL_7:
    sub_100046D6C((uint64_t)a1, v28, v2, v3, v4, v5, v6, v7, v29);
    return sub_100046C44(a1);
  }

  return result;
}

uint64_t sub_100008DBC(int32x2_t *a1, uint64_t a2)
{
  uint64_t v62 = 0LL;
  unsigned int v4 = sub_1000358E4((void **)&v62, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 2425LL);
  if (v4)
  {
    char v9 = sub_100067900(v4);
    sub_100061FB4("Can't allocate shared subnet: %s", v10, v11, v12, v13, v14, v15, v16, v9);
  }

  sub_1000406C0( v62 + 12,  a2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2429LL,  v5,  v6,  v7,  v8);
  sub_1000235CC(v62[12] + 32, v62, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 2431LL);
  if (sub_1000374AC(&__src, 0LL, a1) == 262)
  {
    sub_100036D00(&__src, 0LL, (uint64_t)a1);
    uint64_t v23 = __src;
    if (!*__src)
    {
      sub_100046D6C((uint64_t)a1, "zero-length shared network name", v17, v18, v19, v20, v21, v22, v61);
      uint64_t v23 = "<no-name-given>";
      __src = "<no-name-given>";
    }

    int v24 = strlen(v23);
    uint64_t v25 = (char *)sub_10005CDE4((v24 + 1));
    unsigned int v33 = v25;
    if (!v25) {
      sub_100061FB4("no memory for shared network name", v26, v27, v28, v29, v30, v31, v32, v61);
    }
    strcpy(v25, __src);
  }

  else
  {
    unsigned int v33 = sub_1000470FC(a1);
    if (!v33)
    {
      sub_100046D6C((uint64_t)a1, "expecting a name for shared-network", v34, v35, v36, v37, v38, v39, v61);
      sub_100046C44(a1);
      uint64_t v47 = 2452LL;
      return sub_1000235C8(&v62, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", v47);
    }
  }

  v62[5] = (uint64_t)v33;
  if (sub_10000BC3C(a1))
  {
    for (uint64_t i = 0LL; ; uint64_t i = sub_1000041D0(a1, v62[12], 2LL, 0LL, i))
    {
      while (1)
      {
        int v41 = sub_1000374AC(&__src, 0LL, a1);
        if (v41 != 305) {
          break;
        }
        sub_100036D00(&__src, 0LL, (uint64_t)a1);
        sub_100036D00(&__src, 0LL, (uint64_t)a1);
        sub_10002AEBC((uint64_t)a1, (uint64_t)v62, __src, v42, v43, v44, v45, v46);
      }

      if (v41 == 607)
      {
        sub_100036D00(&__src, 0LL, (uint64_t)a1);
        sub_100046D6C((uint64_t)a1, "unexpected end of file", v48, v49, v50, v51, v52, v53, v61);
LABEL_21:
        uint64_t v47 = 2492LL;
        return sub_1000235C8(&v62, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", v47);
      }

      if (v41 == 125) {
        break;
      }
    }

    sub_100036D00(&__src, 0LL, (uint64_t)a1);
    if (v62[7]) {
      sub_10002AE50((uint64_t)v62);
    }
    else {
      sub_100046D6C((uint64_t)a1, "empty shared-network decl", v54, v55, v56, v57, v58, v59, v61);
    }
    uint64_t v47 = 2472LL;
  }

  else
  {
    uint64_t v47 = 2459LL;
  }

  return sub_1000235C8(&v62, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", v47);
}

uint64_t sub_100009028(int32x2_t *a1, uint64_t a2)
{
  unsigned int v69 = 4;
  uint64_t v71 = 0LL;
  unsigned int v4 = sub_1000358CC((void **)&v71, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 2581LL);
  if (v4)
  {
    char v5 = sub_100067900(v4);
    sub_100061FB4("Allocation of new subnet failed: %s", v6, v7, v8, v9, v10, v11, v12, v5);
  }

  sub_1000235CC(v71 + 48, a2, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 2585LL);
  uint64_t v17 = (uint64_t *)(v71 + 128);
  uint64_t v18 = *(void *)(a2 + 96);
  if ((*(_BYTE *)(a2 + 48) & 1) != 0)
  {
    sub_100034128( v17,  v18,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2596LL,  v13,  v14,  v15,  v16);
  }

  else if (!sub_1000406C0( v17,  v18,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2598LL,  v13,  v14,  v15,  v16))
  {
    sub_100061FB4("Allocation of group for new subnet failed.", v19, v20, v21, v22, v23, v24, v25, v68);
  }

  sub_1000235CC( *((void *)v71 + 16) + 24LL,  v71,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2602LL);
  if (!sub_100047540(a1, &v70, &v69, 46, 10LL, 8LL))
  {
    uint64_t v66 = 2606LL;
    return sub_1000235C8(&v71, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", v66);
  }

  unsigned int v26 = v69;
  __memcpy_chk((char *)&v77 + 4, &v70, v69, 16LL);
  LODWORD(v77) = v26;
  uint64_t v27 = v71;
  *((_DWORD *)v71 + 25) = v78;
  *(_OWORD *)(v27 + 84) = v77;
  if (sub_100036D00(&v72, 0LL, (uint64_t)a1) != 279)
  {
    sub_100046D6C((uint64_t)a1, "Expecting netmask", v28, v29, v30, v31, v32, v33, v68);
    return sub_100046C44(a1);
  }

  if (!sub_100047540(a1, &v70, &v69, 46, 10LL, 8LL))
  {
    uint64_t v66 = 2622LL;
    return sub_1000235C8(&v71, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", v66);
  }

  unsigned int v34 = v69;
  __memcpy_chk((char *)&v77 + 4, &v70, v69, 16LL);
  LODWORD(v77) = v34;
  uint64_t v35 = v71;
  int v36 = v78;
  *((_DWORD *)v71 + 30) = v78;
  __int128 v37 = v77;
  *(_OWORD *)(v35 + 104) = v77;
  __int128 v75 = *(_OWORD *)(v35 + 84);
  int v76 = *((_DWORD *)v35 + 25);
  __int128 v73 = v37;
  int v74 = v36;
  if (sub_10003FA78(&v75, &v73, v38, v39, v40, v41, v42, v43))
  {
    __int128 v75 = *(_OWORD *)(v71 + 104);
    int v76 = *((_DWORD *)v71 + 30);
    uint64_t v50 = sub_100040144((int *)&v75, v44, (uint64_t)v71, v45, v46, v47, v48, v49);
    uint64_t v51 = strdup(v50);
    __int128 v75 = *(_OWORD *)(v71 + 84);
    int v76 = *((_DWORD *)v71 + 25);
    char v59 = sub_100040144((int *)&v75, v52, v53, v54, v55, v56, v57, v58);
    sub_100046D6C( (uint64_t)a1,  "subnet %s netmask %s: bad subnet number/mask combination.",  v60,  v61,  v62,  v63,  v64,  v65,  v59);
    free(v51);
    sub_1000235C8(&v71, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 2638LL);
    return sub_100046C44(a1);
  }

  return sub_10000BD5C(a1, a2, (uint64_t)v71);
}

uint64_t sub_1000092EC( int32x2_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (dword_100089B0C != 30)
  {
    sub_100046D6C((uint64_t)a1, "subnet6 statement is only supported in DHCPv6 mode.", a3, a4, a5, a6, a7, a8, v66);
    return sub_100046C44(a1);
  }

  unsigned int v69 = 0LL;
  unsigned int v10 = sub_1000358CC((void **)&v69, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 2673LL);
  if (v10)
  {
    char v11 = sub_100067900(v10);
    sub_100061FB4("Allocation of new subnet failed: %s", v12, v13, v14, v15, v16, v17, v18, v11);
  }

  sub_1000235CC(v69 + 48, a2, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 2678LL);
  uint64_t v23 = (uint64_t *)(v69 + 128);
  uint64_t v24 = *(void *)(a2 + 96);
  if ((*(_BYTE *)(a2 + 48) & 1) != 0)
  {
    sub_100034128( v23,  v24,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2689LL,  v19,  v20,  v21,  v22);
  }

  else if (!sub_1000406C0( v23,  v24,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2691LL,  v19,  v20,  v21,  v22))
  {
    sub_100061FB4("Allocation of group for new subnet failed.", v25, v26, v27, v28, v29, v30, v31, v66);
  }

  sub_1000235CC( *((void *)v69 + 16) + 24LL,  v69,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2695LL);
  if (sub_100036D00(&__str, 0LL, (uint64_t)a1) != 47)
  {
    uint64_t v47 = "Expecting a '/'.";
    goto LABEL_18;
  }

  if (sub_100036D00(&__str, 0LL, (uint64_t)a1) != 263)
  {
    uint64_t v47 = "Expecting a number.";
    goto LABEL_18;
  }

  unsigned int v45 = strtol(__str, &__endptr, 10);
  uint64_t v46 = v69;
  *((_DWORD *)v69 + 31) = v45;
  if (v45 > 0x80 || *__endptr)
  {
    uint64_t v47 = "Expecting a number between 0 and 128.";
LABEL_18:
    sub_100046D6C((uint64_t)a1, v47, v39, v40, v41, v42, v43, v44, v66);
    return sub_100046C44(a1);
  }

  if (!sub_10003FD5C((_DWORD *)v46 + 21, v45))
  {
    uint64_t v47 = "New subnet mask too short.";
    goto LABEL_18;
  }

  uint64_t v48 = v69;
  *((_DWORD *)v69 + 26) = 16;
  int v49 = *((_DWORD *)v48 + 31);
  uint64_t v50 = (v49 / 8);
  if (v49 >= 8)
  {
    unint64_t v51 = v50 + 1;
    do
      v69[(v51-- - 2) + 108] = -1;
    while (v51 > 1);
  }

  __int128 v72 = *(_OWORD *)(v69 + 84);
  int v73 = *((_DWORD *)v69 + 25);
  __int128 v70 = *(_OWORD *)(v69 + 104);
  int v71 = *((_DWORD *)v69 + 30);
  sub_10003F7A4(&v72, &v70, v39, v40, v41, v42, v43, v44, (unint64_t)v74);
  if (v74[0] != *(void *)(v69 + 84) || v74[1] != *(void *)(v69 + 92))
  {
    __int128 v72 = *(_OWORD *)(v69 + 84);
    int v73 = *((_DWORD *)v69 + 25);
    char v59 = sub_100040144((int *)&v72, v52, (uint64_t)v69, v53, v54, v55, v56, v57);
    sub_100046D6C((uint64_t)a1, "subnet %s/%d: prefix not long enough for address.", v60, v61, v62, v63, v64, v65, v59);
    sub_1000235C8(&v69, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 2749LL);
    return sub_100046C44(a1);
  }

  return sub_10000BD5C(a1, a2, (uint64_t)v69);
}

uint64_t sub_100009634( void *a1, int32x2_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  uint64_t v34 = 0LL;
  do
  {
    uint64_t v33 = 0LL;
    if (v8 == 259) {
      int v11 = sub_100047324((uint64_t *)&v33, a2, 1);
    }
    else {
      int v11 = sub_1000479D8((uint64_t *)&v33, a2, a3, a4, a5, a6, a7, a8);
    }
    if (!v11)
    {
      uint64_t v30 = 0LL;
      if (!v34) {
        return v30;
      }
      uint64_t v29 = 2889LL;
      goto LABEL_18;
    }

    if (v34)
    {
      uint64_t v32 = 0LL;
      uint64_t v17 = &v32;
      int v18 = sub_10005470C(&v32, v34, v33, v12, v13, v14, v15, v16);
      sub_100054390( (uint64_t *)&v34,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2878LL,  v19,  v20,  v21,  v22,  v23);
      sub_100054390( (uint64_t *)&v33,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2879LL,  v24,  v25,  v26,  v27,  v28);
      if (!v18) {
        return 0LL;
      }
    }

    else
    {
      uint64_t v17 = (uint64_t *)&v33;
    }

    uint64_t v34 = (_DWORD *)*v17;
  }

  while (sub_1000374AC(&v35, 0LL, a2) == 44 && sub_100036D00(&v35, 0LL, (uint64_t)a2) == 44);
  if (sub_100046D08(a2))
  {
    uint64_t v30 = sub_100054A34( a1,  0LL,  v34,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  2906LL,  v15,  v16);
    uint64_t v29 = 2907LL;
  }

  else
  {
    uint64_t v30 = 0LL;
    if (!v34) {
      return v30;
    }
    uint64_t v29 = 2901LL;
  }

uint64_t sub_100009798(int32x2_t *a1, uint64_t a2, int a3)
{
  uint64_t v175 = 0LL;
  int v176 = 0LL;
  unsigned int v6 = sub_1000338E0((void **)&v176, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 1446LL);
  if (v6)
  {
    char v13 = sub_100067900(v6);
    sub_100061FB4("no memory for pool: %s", v14, v15, v16, v17, v18, v19, v20, v13);
  }

  if (a3 == 2)
  {
    uint64_t v21 = (char *)(v176 + 6);
    uint64_t v22 = *(void *)(a2 + 32);
    uint64_t v23 = 1457LL;
  }

  else
  {
    if (a3 != 3)
    {
      sub_100046D6C( (uint64_t)a1,  "Dynamic pools are only valid inside subnet or shared-network statements.",  v7,  v8,  v9,  v10,  v11,  v12,  v171);
      return sub_100046C44(a1);
    }

    uint64_t v21 = (char *)(v176 + 6);
    uint64_t v22 = *(void *)(*(void *)(a2 + 24) + 48LL);
    uint64_t v23 = 1454LL;
  }

  sub_1000235CC(v21, v22, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", v23);
  uint64_t v31 = v176[6];
  if (!v31
    || !sub_1000406C0( v176 + 5,  *(void *)(v31 + 96),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  1466LL,  v27,  v28,  v29,  v30))
  {
    sub_100061FB4("can't clone pool group.", v24, v25, v26, v27, v28, v29, v30, v171);
  }

  uint64_t v32 = *(void *)(v176[6] + 104LL);
  if (v32) {
    sub_100021D08(v176 + 20, v32);
  }
  if (!sub_10000BC3C(a1))
  {
    uint64_t v135 = 1478LL;
    return sub_100033900( (_DWORD **)&v176,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  v135);
  }

  for (uint64_t i = 0LL; ; uint64_t i = sub_1000041D0(a1, v176[5], 6LL, 0LL, i))
  {
    while (1)
    {
      while (1)
      {
        int v34 = sub_1000374AC(&__s1, 0LL, a1);
        if (v34 <= 311) {
          break;
        }
        if (v34 > 430)
        {
          if (v34 != 431)
          {
            if (v34 == 607)
            {
              sub_100046D6C((uint64_t)a1, "unexpected end of file", v35, v36, v37, v38, v39, v40, v171);
              goto LABEL_98;
            }

            goto LABEL_49;
          }

          sub_100036D00(&__s1, 0LL, (uint64_t)a1);
          if (sub_100036D00(&__s1, 0LL, (uint64_t)a1) != 365
            || sub_100036D00(&__s1, 0LL, (uint64_t)a1) != 364)
          {
            uint64_t v75 = (uint64_t)a1;
            int v76 = "expecting failover peer.";
            goto LABEL_51;
          }

          if (v176[20]) {
            sub_100021D0C( (_DWORD **)v176 + 20,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  1499LL);
          }
        }

        else if (v34 == 312)
        {
          uint64_t v57 = v176 + 8;
          char v56 = 1;
LABEL_33:
          sub_100033A7C();
          uint64_t v66 = v65;
          if (!v65) {
            sub_100061FB4("no memory for permit", v58, v59, v60, v61, v62, v63, v64, v171);
          }
          sub_100036D00(&__s1, 0LL, (uint64_t)a1);
          int v67 = sub_100036D00(&__s1, 0LL, (uint64_t)a1);
          if (v67 <= 614)
          {
            int v74 = 1;
            switch(v67)
            {
              case 352:
                int v74 = 0;
                goto LABEL_58;
              case 353:
                goto LABEL_54;
              case 354:
                goto LABEL_58;
              case 355:
                int v74 = 2;
                goto LABEL_58;
              case 356:
                int v74 = 3;
                goto LABEL_58;
              case 357:
                int v74 = 4;
LABEL_58:
                *(_DWORD *)(v66 + 8) = v74;
                goto LABEL_59;
              case 358:
                *(_DWORD *)(v66 + 8) = 5;
                if (sub_100036D00(&__s1, 0LL, (uint64_t)a1) == 578)
                {
LABEL_59:
                  sub_100046D6C((uint64_t)a1, "expecting clients", v82, v83, v84, v85, v86, v87, v171);
                  sub_100046C44(a1);
                  sub_100033AA8( v66,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  1557LL,  v88,  v89,  v90,  v91,  v92);
                }

                else
                {
                  sub_100046D6C((uint64_t)a1, "expecting bootp", v93, v94, v95, v96, v97, v98, v171);
                  sub_100046C44(a1);
                  sub_100033AA8( v66,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  1595LL,  v99,  v100,  v101,  v102,  v103);
                }

                continue;
              case 359:
                if (sub_100036D00(&__s1, 0LL, (uint64_t)a1) != 360)
                {
                  sub_100046D6C((uint64_t)a1, "expecting of", v104, v105, v106, v107, v108, v109, v171);
                  sub_100046C44(a1);
                  sub_100033AA8( v66,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  1605LL,  v123,  v124,  v125,  v126,  v127);
                  continue;
                }

                if (sub_100036D00(&__s1, 0LL, (uint64_t)a1) != 262)
                {
                  sub_100046D6C((uint64_t)a1, "expecting class name.", v110, v111, v112, v113, v114, v115, v171);
                  sub_100046C44(a1);
                  sub_100033AA8( v66,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  1613LL,  v128,  v129,  v130,  v131,  v132);
                  continue;
                }

                *(void *)(v66 + 16) = 0LL;
                *(_DWORD *)(v66 + 8) = 6;
                sub_100003828( v66 + 16,  __s1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  1618LL);
                if (!*(void *)(v66 + 16)) {
                  sub_100046D6C((uint64_t)a1, "no such class: %s", v116, v117, v118, v119, v120, v121, (char)__s1);
                }
                break;
              default:
                if (v67 != 309) {
                  goto LABEL_54;
                }
                *(_DWORD *)(v66 + 8) = 0;
                goto LABEL_68;
            }

            goto LABEL_68;
          }

          if (v67 == 615)
          {
            *(_DWORD *)(v66 + 8) = 1;
            goto LABEL_68;
          }

          if (v67 != 654)
          {
LABEL_54:
            sub_100046D6C((uint64_t)a1, "expecting permit type.", v68, v69, v70, v71, v72, v73, v171);
            sub_100046C44(a1);
            goto LABEL_68;
          }

          if (!v176[18] && !v176[19])
          {
            uint64_t v133 = sub_100048258(a1);
            *(_DWORD *)(v66 + 8) = 7;
            *(void *)(v66 + 24) = v133;
            if ((v56 & 1) != 0) {
              v176[19] = v133;
            }
            else {
              v176[18] = v133;
            }
            do
            {
LABEL_68:
              uint64_t v122 = v57;
              uint64_t v57 = (uint64_t *)*v57;
            }

            while (v57);
            *uint64_t v122 = v66;
            goto LABEL_70;
          }

          sub_100046D6C((uint64_t)a1, "duplicate after clause.", v68, v69, v70, v71, v72, v73, v171);
          sub_100046C44(a1);
          sub_100033AA8( v66,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  1629LL,  v77,  v78,  v79,  v80,  v81);
        }

        else
        {
          if (v34 != 365) {
            goto LABEL_49;
          }
          sub_100036D00(&__s1, 0LL, (uint64_t)a1);
          if (sub_100036D00(&__s1, 0LL, (uint64_t)a1) != 364)
          {
            uint64_t v75 = (uint64_t)a1;
            int v76 = "expecting 'peer'.";
            goto LABEL_51;
          }

          if (sub_100036D00(&__s1, 0LL, (uint64_t)a1) == 262)
          {
            uint64_t v47 = v176;
            if (v176[20])
            {
              sub_100021D0C( (_DWORD **)v176 + 20,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  1520LL);
              uint64_t v47 = v176;
            }

            unsigned int v48 = sub_100022168(v47 + 20, __s1);
            if (v48)
            {
              char v49 = (char)__s1;
              sub_100067900(v48);
              sub_100046D6C((uint64_t)a1, "failover peer %s: %s", v50, v51, v52, v53, v54, v55, v49);
            }

            else
            {
              ++*(_DWORD *)(v176[20] + 340LL);
            }

LABEL_70:
            sub_100046D08(a1);
          }

          else
          {
            uint64_t v75 = (uint64_t)a1;
            int v76 = "expecting string.";
LABEL_51:
            sub_100046D6C(v75, v76, v41, v42, v43, v44, v45, v46, v171);
            sub_100046C44(a1);
          }
        }
      }

      if (v34 != 272) {
        break;
      }
      sub_100036D00(&__s1, 0LL, (uint64_t)a1);
      sub_100009FC0(a1, a2, a3, v176, &v175);
    }

    if (v34 == 310)
    {
      char v56 = 0;
      uint64_t v57 = v176 + 7;
      goto LABEL_33;
    }

    if (v34 == 125) {
      break;
    }
LABEL_49:
    ;
  }

  sub_100036D00(&__s1, 0LL, (uint64_t)a1);
  uint64_t v136 = v176;
  uint64_t v137 = v176[6];
  uint64_t v140 = *(void **)(v137 + 72);
  int v139 = (void *)(v137 + 72);
  uint64_t v138 = v140;
  if (!v140)
  {
    do
    {
LABEL_92:
      uint64_t v153 = v139;
      uint64_t v154 = *v139;
      int v139 = (void *)(*v139 + 32LL);
    }

    while (v154);
    sub_1000338FC(v153, (uint64_t)v136);
    goto LABEL_94;
  }

  uint64_t v141 = *(void *)(v176[5] + 48LL);
  while (1)
  {
    if (*(void *)(v138[5] + 48LL) == v141 && v136[20] == v138[20])
    {
      uint64_t v142 = (uint64_t *)v138[7];
      uint64_t v143 = (uint64_t *)v136[7];
      if (sub_10000BBD8(v142, v143))
      {
        if (sub_10000BBD8(v143, v142))
        {
          uint64_t v144 = (uint64_t *)v138[8];
          uint64_t v145 = (uint64_t *)v136[8];
          if (sub_10000BBD8(v144, v145))
          {
          }
        }
      }
    }

    uint64_t v138 = (void *)v138[4];
    if (!v138) {
      goto LABEL_92;
    }
  }

  uint64_t v152 = v175;
  int v174 = v175;
  if (v175)
  {
    do
    {
      sub_100033900( (_DWORD **)v152 + 17,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  1703LL);
      sub_1000338FC((void *)v174 + 17, (uint64_t)v138);
      uint64_t v152 = (_DWORD *)*((void *)v174 + 4);
      int v174 = v152;
    }

    while (v152);
LABEL_94:
    uint64_t v155 = v175;
    if (v175)
    {
      int v174 = 0LL;
      goto LABEL_99;
    }
  }

  sub_100046D6C((uint64_t)a1, "Pool declaration with no address range.", v146, v147, v148, v149, v150, v151, v171);
  sub_10006221C("Pool declarations must always contain at least", v156, v157, v158, v159, v160, v161, v162, v172);
  sub_10006221C("one range statement.", v163, v164, v165, v166, v167, v168, v169, v173);
LABEL_98:
  uint64_t v155 = v175;
  int v174 = 0LL;
  if (!v175) {
    goto LABEL_102;
  }
  do
  {
LABEL_99:
    sub_100033898(&v174, v155, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 1730LL);
    sub_10003389C(&v175, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 1731LL);
    uint64_t v170 = *((void *)v174 + 4);
    if (v170)
    {
      sub_100033898(&v175, v170, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 1733LL);
      sub_10003389C( (_DWORD **)v174 + 4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  1734LL);
      sub_10003389C(&v174, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 1735LL);
    }

    uint64_t v155 = v175;
  }

  while (v175);
LABEL_102:
  uint64_t v135 = 1738LL;
  return sub_100033900( (_DWORD **)&v176,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  v135);
}

char *sub_100009FC0(int32x2_t *a1, uint64_t a2, int a3, uint64_t *a4, _DWORD **a5)
{
  unsigned int v164 = 4;
  int v10 = sub_1000374AC(&v163, 0LL, a1);
  if (v10 == 286) {
    sub_100036D00(&v163, 0LL, (uint64_t)a1);
  }
  uint64_t result = sub_100047540(a1, &v165, &v164, 46, 10LL, 8LL);
  if (!result) {
    return result;
  }
  unsigned int v12 = v164;
  __memcpy_chk((char *)&v174 + 4, &v165, v164, 16LL);
  LODWORD(v174) = v12;
  if (sub_1000374AC(&v163, 0LL, a1) == 59)
  {
    __int128 v172 = v174;
    int v173 = v175;
  }

  else
  {
    uint64_t result = sub_100047540(a1, &v165, &v164, 46, 10LL, 8LL);
    if (!result) {
      return result;
    }
    unsigned int v13 = v164;
    __memcpy_chk((char *)&v172 + 4, &v165, v164, 16LL);
    LODWORD(v172) = v13;
  }

  if (sub_100036D00(&v163, 0LL, (uint64_t)a1) != 59)
  {
    sub_100046D6C((uint64_t)a1, "semicolon expected.", v14, v15, v16, v17, v18, v19, v151);
    return (char *)sub_100046C44(a1);
  }

  if (a3 != 3)
  {
    uint64_t v21 = *(void **)(a2 + 32);
    uint64_t v20 = v21[7];
    if (v20)
    {
      do
      {
        __int128 v168 = v174;
        int v169 = v175;
        __int128 v166 = *(_OWORD *)(v20 + 104);
        int v167 = *(_DWORD *)(v20 + 120);
        sub_10003F7A4(&v168, &v166, v14, v15, v16, v17, v18, v19, (unint64_t)&v170);
        __int128 v168 = v170;
        int v169 = v171;
        __int128 v166 = *(_OWORD *)(v20 + 84);
        int v167 = *(_DWORD *)(v20 + 100);
        uint64_t v20 = *(void *)(v20 + 40);
      }

      while (v20);
      uint64_t v21 = *(void **)(a2 + 32);
    }

    sub_100046D6C((uint64_t)a1, "address range not on network %s", v14, v15, v16, v17, v18, v19, v21[5]);
    return (char *)sub_10006221C( "Be sure to place pool statement after %s",  v34,  v35,  v36,  v37,  v38,  v39,  v40,  (char)"related subnet declarations.");
  }

  uint64_t v20 = *(void *)(a2 + 24);
  uint64_t v21 = *(void **)(v20 + 48);
LABEL_11:
  if (a4)
  {
    uint64_t v162 = 0LL;
    uint64_t v22 = a4;
    goto LABEL_13;
  }

  uint64_t v22 = (uint64_t *)v21[9];
  uint64_t v162 = v22;
  uint64_t v41 = 0LL;
  if (!v22)
  {
LABEL_36:
    unsigned int v46 = sub_1000338E0( (void **)&v162,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  3632LL);
    if (v46)
    {
      char v47 = sub_100067900(v46);
      sub_100061FB4("no memory for ad-hoc pool: %s", v48, v49, v50, v51, v52, v53, v54, v47);
    }

    sub_100033A7C();
    if (!v55) {
      sub_100061FB4("no memory for ad-hoc permit.", v56, v57, v58, v59, v60, v61, v62, v151);
    }
    uint64_t v63 = v162;
    uint64_t v64 = 8LL;
    if (v10 == 286)
    {
      uint64_t v64 = 7LL;
      int v65 = 4;
    }

    else
    {
      int v65 = 5;
    }

    v162[v64] = v55;
    *(_DWORD *)(v55 + 8) = v65;
    if (v21[9]) {
      uint64_t v66 = v41 + 4;
    }
    else {
      uint64_t v66 = v21 + 9;
    }
    sub_1000338FC(v66, (uint64_t)v63);
    sub_1000235CC(v162 + 6, v21, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 3655LL);
    if (!sub_1000406C0( v162 + 5,  v21[12],  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  3656LL,  v67,  v68,  v69,  v70)) {
      sub_100061FB4("no memory for anon pool group.", v71, v23, v24, v72, v25, v26, v27, v151);
    }
    goto LABEL_48;
  }

  uint64_t v42 = v22;
  while (1)
  {
    uint64_t v43 = v41;
    uint64_t v41 = v42;
    if (v10 != 286) {
      break;
    }
    if (!v42[8])
    {
      uint64_t v44 = v42[7];
      if (v44)
      {
        if (!*(void *)v44 && *(_DWORD *)(v44 + 8) == 4) {
          goto LABEL_34;
        }
      }
    }

LABEL_29:
    uint64_t v42 = (uint64_t *)v41[4];
    uint64_t v162 = v42;
    if (!v42) {
      goto LABEL_36;
    }
  }

  if (v42[7]) {
    goto LABEL_29;
  }
  uint64_t v45 = v42[8];
  if (!v45 || *(void *)v45 || *(_DWORD *)(v45 + 8) != 5) {
    goto LABEL_29;
  }
LABEL_34:
  uint64_t v162 = 0LL;
  if (v43) {
    uint64_t v22 = v43;
  }
LABEL_13:
  sub_1000338FC(&v162, (uint64_t)v22);
LABEL_48:
  uint64_t v73 = v162;
  if (v10 == 286)
  {
    if (v162[20])
    {
      sub_100046D6C( (uint64_t)a1,  "dynamic-bootp flag is %s",  v23,  v24,  (uint64_t)v162,  v25,  v26,  v27,  (char)"not permitted for address");
      sub_10006221C("range declarations where there is a failover", v74, v75, v76, v77, v78, v79, v80, v152);
      sub_10006221C("peer in scope.   If you wish to declare an", v81, v82, v83, v84, v85, v86, v87, v153);
      sub_10006221C("address range from which dynamic bootp leases", v88, v89, v90, v91, v92, v93, v94, v154);
      sub_10006221C("can be allocated, please declare it within a", v95, v96, v97, v98, v99, v100, v101, v155);
      sub_10006221C("pool declaration that also contains the no", v102, v103, v104, v105, v106, v107, v108, v156);
      sub_10006221C("failover statement.   The failover protocol", v109, v110, v111, v112, v113, v114, v115, v157);
      sub_10006221C("itself does not permit dynamic bootp - this", v116, v117, v118, v119, v120, v121, v122, v158);
      sub_10006221C("is not a limitation specific to the ISC DHCP", v123, v124, v125, v126, v127, v128, v129, v159);
      sub_10006221C("server.   Please don't ask me to defend this", v130, v131, v132, v133, v134, v135, v136, v160);
      sub_10006221C( "until you have read and really tried %s",  v137,  v138,  v139,  v140,  v141,  v142,  v143,  (char)"to understand");
      sub_10006221C("the failover protocol specification.", v144, v145, v146, v147, v148, v149, v150, v161);
      uint64_t v73 = v162;
    }
  }

  __int128 v168 = v174;
  int v169 = v175;
  __int128 v166 = v172;
  int v167 = v173;
  sub_10002A270((uint64_t)a1, (uint64_t)&v168, (uint64_t)&v166, v20, (uint64_t)v73, a5, v26, v27);
  return (char *)sub_100033900( (_DWORD **)&v162,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  3697LL);
}

            uint64_t v22 = sub_10006B974(*(_BYTE **)(v9 + 40), v12, v7, v101, (uint64_t)&v102);
            if ((v22 & 0x80000000) != 0) {
              return 0xFFFFFFFFLL;
            }
            uint64_t v23 = v7 - v22 - 4;
            uint64_t v24 = &v12[v22];
            *uint64_t v24 = v21;
            v24[1] = v18;
            v24[2] = BYTE1(v19);
            v24[3] = v19;
            if ((_DWORD)v14)
            {
              uint64_t v7 = v7 - v22 - 10;
              *((_DWORD *)v24 + 1) = bswap32(v93);
              unsigned int v12 = v24 + 10;
              uint64_t v25 = *(unsigned int *)(v9 + 80);
              uint64_t v11 = v96;
              uint64_t v26 = v24;
              if ((_DWORD)v25)
              {
                uint64_t v99 = *(unsigned __int8 **)(v9 + 64);
                uint64_t v27 = &v99[v25];
                uint64_t v28 = (unint64_t)(v27 - 1);
                switch(*(_DWORD *)(v9 + 52))
                {
                  case 1:
                    uint64_t v45 = v23;
                    if (!sub_10006DC34((uint64_t)v104, (unint64_t *)&v99, (unint64_t)(v27 - 1))
                      || !inet_aton(v104, &v98))
                    {
                      return 0xFFFFFFFFLL;
                    }

                    uint64_t v7 = v45 - 10;
                    *(in_addr *)(v26 + 10) = v98;
                    unsigned int v12 = v26 + 14;
                    goto LABEL_125;
                  case 2:
                  case 5:
                  case 7:
                  case 8:
                  case 9:
                  case 0xC:
                    goto LABEL_123;
                  case 6:
                  case 0xE:
                  case 0x11:
                    uint64_t v29 = 1;
                    do
                    {
                      uint64_t v30 = v29;
                      uint64_t v31 = sub_10006B974(v104, v12, v7, v101, (uint64_t)&v102);
                      if ((v31 & 0x80000000) != 0) {
                        return 0xFFFFFFFFLL;
                      }
                      uint64_t v29 = 0;
                      v7 -= v31;
                      v12 += v31;
                    }

                    while ((v30 & 1) != 0);
                    if (*(_DWORD *)(v9 + 52) != 6) {
                      goto LABEL_125;
                    }
                    uint64_t v32 = v99;
                    do
                    {
                      uint64_t v33 = *v32;
                      else {
                        uint64_t v34 = _DefaultRuneLocale.__runetype[*v32] & 0x4000;
                      }
                      ++v32;
                      if (v33) {
                        uint64_t v35 = v34 == 0;
                      }
                      else {
                        uint64_t v35 = 0;
                      }
                    }

                    while (!v35);
                    uint64_t v94 = v26;
                    uint64_t v36 = 0LL;
                    v7 -= 20;
                    uint64_t v37 = v32 - 1;
                    if (v33 == 40) {
                      uint64_t v37 = v32;
                    }
                    uint64_t v99 = v37;
                    do
                    {
                      uint64_t v38 = sub_10006DDDC(&v99, v28);
                      if ((v38 & 0x80000000) != 0) {
                        return 0xFFFFFFFFLL;
                      }
                      *(_DWORD *)&v12[v36] = bswap32(v38);
                      v36 += 4LL;
                    }

                    while ((_DWORD)v36 != 20);
                    v12 += v36;
                    if (v33 == 40)
                    {
                      uint64_t v39 = v99 - 1;
                      uint64_t v26 = v94;
                      do
                      {
                        uint64_t v40 = v39[1];
                        else {
                          uint64_t v41 = _DefaultRuneLocale.__runetype[v39[1]] & 0x4000;
                        }
                        ++v39;
                        if (v40) {
                          uint64_t v42 = v41 == 0;
                        }
                        else {
                          uint64_t v42 = 0;
                        }
                      }

                      while (!v42);
                      uint64_t v99 = v39;
                      if (v40 != 41) {
                        return 0xFFFFFFFFLL;
                      }
                    }

                    else
                    {
                      uint64_t v26 = v94;
                    }

uint64_t sub_10000A4DC( int32x2_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (dword_100089B0C != 30)
  {
    sub_100046D6C((uint64_t)a1, "range6 statement is only supported in DHCPv6 mode.", a3, a4, a5, a6, a7, a8, v42);
    return sub_100046C44(a1);
  }

  if (!*(void *)(a2 + 24)) {
    sub_100061FB4( "Impossible condition at %s:%d.",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c");
  }
  uint64_t result = sub_100047820(a1, v46, a3, a4, a5, a6, a7, a8);
  if ((_DWORD)result)
  {
    int v11 = sub_1000374AC(&v44, 0LL, a1);
    if (v11 == 656)
    {
      sub_100036D00(0LL, 0LL, (uint64_t)a1);
      if (sub_10003FD5C(v46, 0x40u))
      {
        uint64_t v26 = *(void *)(a2 + 24);
        uint64_t v27 = 4LL;
        uint64_t v28 = 64LL;
LABEL_31:
        sub_10000C210(v26, v27, (uint64_t)v46, v28, 128LL, v21, v22, v23);
LABEL_32:
        uint64_t result = sub_100036D00(0LL, 0LL, (uint64_t)a1);
        if ((_DWORD)result == 59) {
          return result;
        }
        uint64_t v25 = "semicolon expected.";
        goto LABEL_34;
      }
    }

    else
    {
      if (v11 != 47)
      {
        uint64_t result = sub_100047820(a1, v45, v12, v13, v14, v15, v16, v17);
        if (!(_DWORD)result) {
          return result;
        }
        uint64_t v43 = 0LL;
        for (uint64_t i = v43; i; uint64_t i = *(void *)i)
          sub_10000C210(*(void *)(a2 + 24), 3LL, i + 8, *(unsigned int *)(i + 28), 128LL, v33, v34, v35);
        sub_1000400E8(&v43, v29, v30, v31, v32, v33, v34, v35);
        goto LABEL_32;
      }

      sub_100036D00(0LL, 0LL, (uint64_t)a1);
      if (sub_100036D00(&v44, 0LL, (uint64_t)a1) != 263)
      {
        uint64_t v25 = "expecting number";
        goto LABEL_34;
      }

      uint64_t v24 = atoi(v44);
      if (v24 >= 0x81)
      {
        uint64_t v25 = "networks have 0 to 128 bits";
LABEL_34:
        sub_100046D6C((uint64_t)a1, v25, v18, v19, v20, v21, v22, v23, v42);
        return sub_100046C44(a1);
      }

      uint64_t v37 = v24;
      if (sub_10003FD5C(v46, v24))
      {
        if (sub_1000374AC(&v44, 0LL, a1) != 656)
        {
          uint64_t v27 = 3LL;
LABEL_30:
          uint64_t v26 = *(void *)(a2 + 24);
          uint64_t v28 = v37;
          goto LABEL_31;
        }

        if (v37 >= 0x40)
        {
          if ((_DWORD)v37 != 128)
          {
LABEL_29:
            sub_100036D00(0LL, 0LL, (uint64_t)a1);
            uint64_t v27 = 4LL;
            goto LABEL_30;
          }

          uint64_t v41 = "temporary singleton?";
        }

        else
        {
          uint64_t v41 = "temporary mask too short";
        }

        sub_100046D6C((uint64_t)a1, v41, v38, v39, v40, v21, v22, v23, v42);
        goto LABEL_29;
      }
    }

    uint64_t v25 = "network mask too short";
    goto LABEL_34;
  }

  return result;
}

uint64_t sub_10000A790( int32x2_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (dword_100089B0C != 30)
  {
    sub_100046D6C((uint64_t)a1, "prefix6 statement is only supported in DHCPv6 mode.", a3, a4, a5, a6, a7, a8, v51);
    return sub_100046C44(a1);
  }

  if (!*(void *)(a2 + 24)) {
    sub_100061FB4( "Impossible condition at %s:%d.",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c");
  }
  uint64_t result = sub_100047820(a1, v55, a3, a4, a5, a6, a7, a8);
  if ((_DWORD)result)
  {
    uint64_t result = sub_100047820(a1, v54, v11, v12, v13, v14, v15, v16);
    if ((_DWORD)result)
    {
      int v17 = sub_100036D00(0LL, 0LL, (uint64_t)a1);
      if (v17 == 47)
      {
        int v24 = sub_100036D00(&v53, 0LL, (uint64_t)a1);
        if (v24 == 263)
        {
          uint64_t v25 = atoi(v53);
          if ((v25 - 128) <= 0xFFFFFF80)
          {
            uint64_t v32 = "networks have 0 to 128 bits (exclusive)";
            return sub_100046D6C((uint64_t)a1, v32, v26, v27, v28, v29, v30, v31, v51);
          }

          uint64_t v35 = v25;
          if (!sub_10003FD5C(v55, v25) || !sub_10003FD5C(v54, v35))
          {
            uint64_t v32 = "network mask too short";
            return sub_100046D6C((uint64_t)a1, v32, v26, v27, v28, v29, v30, v31, v51);
          }

          if (sub_100036D00(0LL, 0LL, (uint64_t)a1) == 59)
          {
            uint64_t v52 = 0LL;
            uint64_t v49 = v52;
            if (!v52) {
              return sub_1000400E8(&v52, v42, v43, v44, v45, v46, v47, v48);
            }
            while (1)
            {
              uint64_t v50 = *(unsigned int *)(v49 + 28);
              if ((_DWORD)v50 == 128) {
                break;
              }
              sub_100046D6C((uint64_t)a1, "impossible mask length", v43, v50, v45, v46, v47, v48, v51);
LABEL_26:
              uint64_t v49 = *(void *)v49;
              if (!v49) {
                return sub_1000400E8(&v52, v42, v43, v44, v45, v46, v47, v48);
              }
            }

            *(_DWORD *)(v49 + 28) = v35;
            uint64_t v50 = v35;
LABEL_25:
            sub_10000C210(*(void *)(a2 + 24), 25LL, v49 + 8, v50, v35, v46, v47, v48);
            goto LABEL_26;
          }

          sub_100046D6C((uint64_t)a1, "semicolon expected.", v36, v37, v38, v39, v40, v41, v51);
          return sub_100046C44(a1);
        }

        int v33 = v24;
        uint64_t v34 = "expecting number";
      }

      else
      {
        int v33 = v17;
        uint64_t v34 = "expecting '/'";
      }

      uint64_t result = sub_100046D6C((uint64_t)a1, v34, v18, v19, v20, v21, v22, v23, v51);
      if (v33 == 59) {
        return result;
      }
      return sub_100046C44(a1);
    }
  }

  return result;
}

void sub_10000AA04(int32x2_t *a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 144);
  do
  {
    unsigned int v4 = v3;
    uint64_t v3 = (void *)*v3;
  }

  while (v3);
  uint64_t v12 = sub_10005CDE4(0x20uLL);
  if (!v12) {
    sub_100061FB4("Out of memory", v5, v6, v7, v8, v9, v10, v11, v73);
  }
  if (!sub_100047820(a1, v12 + 2, v6, v7, v8, v9, v10, v11))
  {
    sub_10005CE20( v12,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4019LL,  v13,  v14,  v15,  v16,  v17);
    return;
  }

  int v18 = sub_100036D00(0LL, 0LL, (uint64_t)a1);
  if (v18 != 47)
  {
    int v48 = v18;
    sub_10005CE20( v12,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4024LL,  v19,  v20,  v21,  v22,  v23);
    sub_100046D6C((uint64_t)a1, "expecting '/'", v49, v50, v51, v52, v53, v54, v73);
    if (v48 != 59) {
      sub_100046C44(a1);
    }
    return;
  }

  int v24 = sub_100036D00(&v74, 0LL, (uint64_t)a1);
  if (v24 != 263)
  {
    int v55 = v24;
    sub_10005CE20( v12,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4032LL,  v25,  v26,  v27,  v28,  v29);
    sub_100046D6C((uint64_t)a1, "expecting number", v56, v57, v58, v59, v60, v61, v73);
    if (v55 == 59) {
      return;
    }
LABEL_17:
    sub_100046C44(a1);
    return;
  }

  if (sub_100036D00(0LL, 0LL, (uint64_t)a1) != 59)
  {
    sub_10005CE20( v12,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4040LL,  v30,  v31,  v32,  v33,  v34);
    sub_100046D6C((uint64_t)a1, "semicolon expected.", v62, v63, v64, v65, v66, v67, v73);
    goto LABEL_17;
  }

  unsigned int v35 = atoi(v74);
  v12[7] = v35;
  if (v35 < 0x81)
  {
    if (sub_10003FD5C(v12 + 2, v35))
    {
      *unsigned int v4 = v12;
      return;
    }

    sub_10005CE20( v12,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4056LL,  v68,  v69,  v70,  v71,  v72);
    uint64_t v47 = "network mask too short";
  }

  else
  {
    sub_10005CE20( v12,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4051LL,  v36,  v37,  v38,  v39,  v40);
    uint64_t v47 = "networks have 0 to 128 bits";
  }

  sub_100046D6C((uint64_t)a1, v47, v41, v42, v43, v44, v45, v46, v73);
}

uint64_t sub_10000AC14(int32x2_t *a1, uint64_t a2, int a3)
{
  unsigned int v151 = 32;
  if (sub_100036D00(&__s, 0LL, (uint64_t)a1) != 364)
  {
    uint64_t v17 = "expecting peer";
    goto LABEL_15;
  }

  unsigned int v13 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
  BOOL v15 = v13 <= 0xFF || v13 - 264 >= 0xFFFFFFFE || v13 == 607;
  int v16 = !v15;
  if (v13 != 262 && !v16)
  {
    uint64_t v17 = "expecting failover peer name.";
LABEL_15:
    sub_100046D6C((uint64_t)a1, v17, v7, v8, v9, v10, v11, v12, v149);
    return sub_100046C44(a1);
  }

  int v19 = strlen(__s);
  uint64_t v20 = (char *)sub_10005CDE4((v19 + 1));
  uint64_t v28 = v20;
  if (!v20) {
    sub_100061FB4("no memory for peer name %s", v21, v22, v23, v24, v25, v26, v27, 0);
  }
  strcpy(v20, __s);
  char v152 = 0LL;
  sub_100022168(&v152, v28);
  int v29 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
  if (v29 == 59)
  {
    sub_10005CE20( v28,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  921LL,  v31,  v32,  v33,  v34,  v35);
    if (a3 == 2)
    {
      if (!v152) {
        return sub_100046D6C( (uint64_t)a1,  "reference to unknown%s%s",  v37,  v38,  v39,  v40,  v41,  v42,  (char)" failover peer ");
      }
      sub_100021D08((void *)(*(void *)(a2 + 32) + 104LL), (uint64_t)v152);
    }

    else
    {
      sub_100046D6C( (uint64_t)a1,  "failover peer reference not %s",  v37,  v38,  v39,  v40,  v41,  v42,  (char)"in shared-network declaration");
    }

    uint64_t v36 = 935LL;
    return sub_100021D0C( (_DWORD **)&v152,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  v36);
  }

  if (v29 != 123)
  {
    if (v29 == 466)
    {
      if (v152)
      {
        sub_1000089F8(a1, (uint64_t)v152);
        uint64_t v36 = 944LL;
        return sub_100021D0C( (_DWORD **)&v152,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  v36);
      }

      return sub_100046D6C( (uint64_t)a1,  "state declaration for unknown%s%s",  v30,  v31,  v32,  v33,  v34,  v35,  (char)" failover peer ");
    }

    sub_100046D6C((uint64_t)a1, "expecting left brace", v30, v31, v32, v33, v34, v35, v149);
    sub_100046C44(a1);
  }

  if (v152)
  {
    sub_100046D6C((uint64_t)a1, "redeclaration of failover peer %s", v30, v31, v32, v33, v34, v35, (char)v28);
    sub_100046C4C(a1, 1u);
    uint64_t v36 = 955LL;
    return sub_100021D0C( (_DWORD **)&v152,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  v36);
  }

  unsigned int v43 = sub_100023B44((void **)&v152, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 959LL);
  if (v43)
  {
    sub_100067900(v43);
    sub_100061FB4("Can't allocate failover peer %s: %s", v44, v45, v46, v47, v48, v49, v50, (char)v28);
  }

  uint64_t v51 = "load balance settings.";
  v152[5] = v28;
  uint64_t v52 = "secondary may not define %s";
  while (2)
  {
    uint64_t v53 = (char *)(v152 + 6);
    while (2)
    {
      int v54 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
      if (v54 <= 425)
      {
        switch(v54)
        {
          case 364:
            uint64_t v53 = (char *)(v152 + 11);
            continue;
          case 365:
          case 366:
          case 367:
          case 370:
          case 372:
            goto LABEL_101;
          case 368:
            *((_DWORD *)v152 + 60) = 0;
            goto LABEL_85;
          case 369:
            uint64_t v94 = v152;
            *((_DWORD *)v152 + 60) = 1;
            if (v94[21]) {
              sub_100046D6C((uint64_t)a1, v52, v55, v56, v57, v58, v59, v60, (char)v51);
            }
            goto LABEL_85;
          case 371:
            uint64_t v73 = v3;
            uint64_t v74 = v52;
            uint64_t v75 = v51;
            int v101 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
            if (v101 != 263)
            {
              sub_100046D6C((uint64_t)a1, "expecting number", v95, v96, v97, v98, v99, v100, v149);
              sub_100046C4C(a1, 1u);
            }

            *((_DWORD *)v53 + 2) = atoi(__s);
            goto LABEL_84;
          case 373:
            uint64_t v72 = v53 + 32;
            goto LABEL_71;
          default:
            if (v54 == 125) {
              goto LABEL_91;
            }
            goto LABEL_101;
        }
      }

      break;
    }

    if (v54 > 463)
    {
      switch(v54)
      {
        case 626:
          uint64_t v72 = (char *)v152 + 180;
          goto LABEL_71;
        case 627:
          uint64_t v72 = (char *)(v152 + 23);
          goto LABEL_71;
        case 628:
          uint64_t v72 = (char *)v152 + 188;
          goto LABEL_71;
        case 629:
          uint64_t v72 = (char *)(v152 + 24);
LABEL_71:
          if (sub_100036D00(&__s, 0LL, (uint64_t)a1) != 263)
          {
            sub_100046D6C((uint64_t)a1, "expecting number.", v116, v117, v118, v119, v120, v121, v149);
            sub_100046C4C(a1, 1u);
            uint64_t v36 = 1036LL;
            return sub_100021D0C( (_DWORD **)&v152,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  v36);
          }

          *(_DWORD *)uint64_t v72 = atoi(__s);
          goto LABEL_85;
        default:
          if (v54 != 464)
          {
LABEL_101:
            sub_100046D6C((uint64_t)a1, "invalid statement in peer declaration", v55, v56, v57, v58, v59, v60, v149);
            sub_100046C4C(a1, 1u);
            uint64_t v36 = 1132LL;
            return sub_100021D0C( (_DWORD **)&v152,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  v36);
          }

          uint64_t v150 = 0LL;
          if (!sub_100047324((uint64_t *)&v150, a1, 0))
          {
            sub_100046C4C(a1, 1u);
            uint64_t v36 = 995LL;
            return sub_100021D0C( (_DWORD **)&v152,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  v36);
          }

          sub_100054A34( v53,  0LL,  v150,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  1000LL,  v87,  v88);
          sub_100054390( (uint64_t *)&v150,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  1001LL,  v89,  v90,  v91,  v92,  v93);
          break;
      }

      goto LABEL_85;
    }

    switch(v54)
    {
      case 426:
        unsigned int v151 = 32;
        if (*((_DWORD *)v152 + 60) == 1) {
          sub_100046D6C((uint64_t)a1, v52, v55, v56, v57, v58, v59, v60, (char)v51);
        }
        if (!sub_100047540(a1, &v154, &v151, 58, 16LL, 8LL))
        {
          sub_100046C4C(a1, 1u);
          uint64_t v36 = 1059LL;
          return sub_100021D0C( (_DWORD **)&v152,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  v36);
        }

        if (v151 == 32) {
          goto LABEL_77;
        }
        sub_100046D6C((uint64_t)a1, "HBA must be exactly 32 bytes.", v61, v62, v63, v64, v65, v66, v149);
        sub_10005CE20( &v154,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  1065LL,  v67,  v68,  v69,  v70,  v71);
        goto LABEL_85;
      case 427:
        uint64_t v72 = v53 + 12;
        goto LABEL_71;
      case 428:
        uint64_t v72 = (char *)(v152 + 20);
        goto LABEL_71;
      case 429:
        int v108 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
        if (*((_DWORD *)v152 + 60) == 1) {
          sub_100046D6C((uint64_t)a1, v52, v102, v103, v104, v105, v106, v107, (char)v51);
        }
        if (v108 != 263)
        {
          sub_100046D6C((uint64_t)a1, "expecting number", v102, v103, v104, v105, v106, v107, v149);
          sub_100046C4C(a1, 1u);
          uint64_t v36 = 1086LL;
          return sub_100021D0C( (_DWORD **)&v152,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  v36);
        }

        unsigned int v109 = atoi(__s);
        if (v109 < 0x100)
        {
          __int128 v154 = 0u;
          __int128 v155 = 0u;
          if (v109)
          {
            for (unsigned int i = 0; i != v109; ++i)
              *((_BYTE *)&v154 + ((unint64_t)i >> 3)) |= 1 << (i & 7);
          }

LABEL_77:
          uint64_t v124 = sub_10005CDE4(0x20uLL);
          uint64_t v130 = v152;
          v152[21] = v124;
          if (!v124)
          {
            sub_10005CE20( (void *)v130[5],  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  1071LL,  v125,  v126,  v127,  v128,  v129);
            sub_10005CE20( v152,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  1072LL,  v131,  v132,  v133,  v134,  v135);
            uint64_t v124 = (_OWORD *)v152[21];
          }

          __int128 v136 = v155;
          *uint64_t v124 = v154;
          v124[1] = v136;
        }

        else
        {
          sub_100046D6C((uint64_t)a1, "split must be < 256", v110, v111, v112, v113, v114, v115, v149);
        }

        goto LABEL_85;
      default:
        if (v54 != 460) {
          goto LABEL_101;
        }
        uint64_t v73 = v3;
        uint64_t v74 = v52;
        uint64_t v75 = v51;
        int v76 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
        if (v76 == 461)
        {
          int v83 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
          if (v83 != 462)
          {
            int v101 = v83;
            uint64_t v122 = "expecting 'max'";
            goto LABEL_83;
          }

          int v84 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
          if (v84 != 463)
          {
            int v101 = v84;
            uint64_t v122 = "expecting 'secs'";
            goto LABEL_83;
          }

          int v85 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
          if (v85 != 263)
          {
            int v101 = v85;
            uint64_t v122 = "expecting number";
            goto LABEL_83;
          }

          int v86 = atoi(__s);
          *((_DWORD *)v152 + 44) = v86;
          uint64_t v52 = v74;
          uint64_t v3 = v73;
LABEL_85:
          if (!sub_100046D08(a1))
          {
            sub_100046C4C(a1, 1u);
            uint64_t v36 = 1137LL;
            return sub_100021D0C( (_DWORD **)&v152,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  v36);
          }

          continue;
        }

        int v101 = v76;
        uint64_t v122 = "expecting 'balance'";
LABEL_83:
        sub_100046D6C((uint64_t)a1, v122, v77, v78, v79, v80, v81, v82, v149);
        sub_100046C4C(a1, 1u);
LABEL_84:
        BOOL v15 = v101 == 125;
        uint64_t v51 = v75;
        uint64_t v52 = v74;
        uint64_t v3 = v73;
        if (!v15) {
          goto LABEL_85;
        }
LABEL_91:
        uint64_t v137 = v152;
        if (!v152[11])
        {
          sub_100046D6C((uint64_t)a1, "peer address may not be omitted", v55, v56, v57, v58, v59, v60, v149);
          uint64_t v137 = v152;
        }

        if (!*((_DWORD *)v137 + 14))
        {
          sub_100046D6C((uint64_t)a1, "local port may not be omitted", v55, v56, v57, v58, v59, v60, v149);
          uint64_t v137 = v152;
        }

        if (!*((_DWORD *)v137 + 24))
        {
          sub_100046D6C((uint64_t)a1, "peer port may not be omitted", v55, v56, v57, v58, v59, v60, v149);
          uint64_t v137 = v152;
        }

        if (!*((_DWORD *)v137 + 60))
        {
          if (v137[21])
          {
            if (!*((_DWORD *)v137 + 40))
            {
              uint64_t v138 = "primary failover server must have mclt.";
              goto LABEL_105;
            }
          }

          else
          {
            uint64_t v138 = "primary failover server must have hba or split.";
LABEL_105:
            sub_100046D6C((uint64_t)a1, v138, v55, v56, v57, v58, v59, v60, v149);
          }
        }

        uint64_t v139 = v152;
        if (!*((_DWORD *)v152 + 45)) {
          *((_DWORD *)v152 + 45) = 15;
        }
        if (!v139[46]) {
          v139[46] = 10;
        }
        if (!v139[47]) {
          v139[47] = 3600;
        }
        if (!v139[48]) {
          v139[48] = 60;
        }
        if (!v139[15]) {
          v139[15] = 100;
        }
        if (!v139[20]) {
          v139[20] = 20;
        }
        if (a3 == 2) {
          *(void *)(*(void *)(a2 + 32) + 104LL) = v139;
        }
        uint64_t v140 = qword_10008CE80;
        v139[16] = 6;
        *((void *)v139 + 9) = v140;
        v139[26] = 0;
        *((void *)v139 + 14) = v140;
        unsigned int v141 = sub_1000220A0((uint64_t)v139);
        if (v141)
        {
          uint64_t v142 = v152[5];
          sub_100067900(v141);
          sub_100046D6C((uint64_t)a1, "failover peer %s: %s", v143, v144, v145, v146, v147, v148, v142);
        }

        uint64_t v36 = 1197LL;
        return sub_100021D0C( (_DWORD **)&v152,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  v36);
    }
  }

uint64_t sub_10000B5B0(int32x2_t *a1)
{
  int v2 = sub_100036D00(&v99, 0LL, (uint64_t)a1);
  uint64_t v9 = "DUID type of LLT, EN, or LL expected";
  if (v2 > 648)
  {
    if (v2 == 650)
    {
      if (sub_1000374AC(0LL, 0LL, a1) == 59)
      {
        uint64_t v10 = 3LL;
        goto LABEL_19;
      }

      int v50 = sub_100036D00(0LL, 0LL, (uint64_t)a1);
      switch(v50)
      {
        case 261:
          unsigned int v51 = 1;
          break;
        case 379:
          unsigned int v51 = 8;
          break;
        case 292:
          unsigned int v51 = 6;
          break;
        default:
          goto LABEL_30;
      }

      size_t __n = 0LL;
      __src = 0LL;
      size_t v98 = 0LL;
      uint64_t result = sub_100049BDC((uint64_t)&__n, a1);
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v94 = 0LL;
      uint64_t v93 = 0LL;
      uint64_t v95 = (v98 + 4);
      if (!sub_1000345C4( &v93,  (int)v98 + 4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  5386LL)) {
        sub_100061FB4("Out of memory storing DUID", v73, v74, v75, v76, v77, v78, v79, v92);
      }
      uint64_t v94 = v93 + 1;
      sub_100060B78((_WORD *)v93 + 2, 3u);
      sub_100060B6C((_DWORD *)((char *)v93 + 6), v51);
      memcpy(v93 + 2, __src, v98);
      sub_10001A004((uint64_t)&v93, v80, v81, v82, v83, v84, v85, v86);
      sub_100034EA8( &v93,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  5396LL,  v87,  v88,  v89,  v90,  v91);
      p_n = &__n;
      uint64_t v32 = 5397LL;
LABEL_45:
      sub_100034EA8( (_DWORD **)p_n,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  v32,  v26,  v27,  v28,  v29,  v30);
      goto LABEL_46;
    }

    if (v2 != 649) {
      goto LABEL_48;
    }
    if (sub_100036D00(&v99, 0LL, (uint64_t)a1) != 263)
    {
      uint64_t v9 = "enterprise number expected";
      goto LABEL_48;
    }

    unsigned int v11 = atoi(v99);
    if (sub_100036D00(&v99, &__n, (uint64_t)a1) == 262)
    {
      uint64_t v94 = 0LL;
      uint64_t v93 = 0LL;
      uint64_t v95 = (__n + 6);
      if (!sub_1000345C4( &v93,  (int)__n + 6,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  5334LL)) {
        sub_100061FB4("Out of memory storing DUID", v12, v13, v14, v15, v16, v17, v18, v92);
      }
      uint64_t v94 = v93 + 1;
      sub_100060B78((_WORD *)v93 + 2, 2u);
      sub_100060B6C((_DWORD *)((char *)v93 + 6), v11);
      memcpy((char *)v93 + 10, v99, __n);
      sub_10001A004((uint64_t)&v93, v19, v20, v21, v22, v23, v24, v25);
      p_n = (size_t *)&v93;
      uint64_t v32 = 5343LL;
      goto LABEL_45;
    }

LABEL_20:
    uint64_t v9 = "identifier expected";
    goto LABEL_48;
  }

  if (v2 == 263)
  {
    unsigned int v33 = atoi(v99);
    if (sub_100036D00(&v99, &__n, (uint64_t)a1) == 262)
    {
      uint64_t v94 = 0LL;
      uint64_t v93 = 0LL;
      uint64_t v95 = (__n + 2);
      if (!sub_1000345C4( &v93,  (int)__n + 2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  5490LL)) {
        sub_100061FB4("Out of memory storing DUID", v34, v35, v36, v37, v38, v39, v40, v92);
      }
      uint64_t v94 = v93 + 1;
      sub_100060B78((_WORD *)v93 + 2, v33);
      memcpy((char *)v93 + 6, v99, __n);
      sub_10001A004((uint64_t)&v93, v41, v42, v43, v44, v45, v46, v47);
      p_n = (size_t *)&v93;
      uint64_t v32 = 5498LL;
      goto LABEL_45;
    }

    goto LABEL_20;
  }

  if (v2 != 648) {
    goto LABEL_48;
  }
  if (sub_1000374AC(0LL, 0LL, a1) != 59)
  {
    int v48 = sub_100036D00(0LL, 0LL, (uint64_t)a1);
    switch(v48)
    {
      case 261:
        unsigned int v49 = 1;
        goto LABEL_33;
      case 379:
        unsigned int v49 = 8;
        goto LABEL_33;
      case 292:
        unsigned int v49 = 6;
LABEL_33:
        if (sub_100036D00(&v99, 0LL, (uint64_t)a1) != 263)
        {
          uint64_t v9 = "timestamp expected";
          goto LABEL_48;
        }

        unsigned int v52 = atoi(v99);
        __src = 0LL;
        size_t v98 = 0LL;
        size_t __n = 0LL;
        uint64_t result = sub_100049BDC((uint64_t)&__n, a1);
        if (!(_DWORD)result) {
          return result;
        }
        uint64_t v94 = 0LL;
        uint64_t v93 = 0LL;
        uint64_t v95 = (v98 + 8);
        if (!sub_1000345C4( &v93,  (int)v98 + 8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  5450LL)) {
          sub_100061FB4("Out of memory storing DUID", v54, v55, v56, v57, v58, v59, v60, v92);
        }
        uint64_t v94 = v93 + 1;
        sub_100060B78((_WORD *)v93 + 2, 1u);
        sub_100060B6C((_DWORD *)((char *)v93 + 6), v49);
        sub_100060B6C(v93 + 2, v52);
        memcpy(v93 + 3, __src, v98);
        sub_10001A004((uint64_t)&v93, v61, v62, v63, v64, v65, v66, v67);
        sub_100034EA8( &v93,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  5461LL,  v68,  v69,  v70,  v71,  v72);
        p_n = &__n;
        uint64_t v32 = 5462LL;
        goto LABEL_45;
    }

          *__error() = 0;
          fwrite("\n  deleted;", 0xBuLL, 1uLL, (FILE *)qword_10008BDA0);
          goto LABEL_21;
        }
      }

      else if ((v5 & 4) == 0)
      {
        goto LABEL_8;
      }

      *__error() = 0;
      fwrite("\n  static;", 0xAuLL, 1uLL, (FILE *)qword_10008BDA0);
      if (*__error()) {
        ++v4;
      }
      if ((*(_DWORD *)(a1 + 56) & 1) == 0) {
        goto LABEL_9;
      }
      goto LABEL_20;
    }
  }

  return result;
}

    sub_100046D6C((uint64_t)a2, v21, v13, v14, v15, v16, v17, v18, v25);
    uint64_t v23 = 0;
    *a3 = 1;
    uint64_t v22 = 3081LL;
    goto LABEL_21;
  }

  if (!*a3)
  {
    uint64_t v21 = "expecting data or numeric expression.";
    goto LABEL_20;
  }

  uint64_t v22 = 3081LL;
LABEL_22:
  sub_10003DC78( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  v22,  v14,  v15,  v16,  v17,  v18);
  return 0LL;
}

LABEL_30:
    uint64_t v9 = "hardware type expected";
    goto LABEL_48;
  }

  uint64_t v10 = 1LL;
LABEL_19:
  sub_10001A17C(v10);
LABEL_46:
  uint64_t result = sub_100036D00(0LL, 0LL, (uint64_t)a1);
  if ((_DWORD)result == 59) {
    return result;
  }
  uint64_t v9 = "semicolon expected";
LABEL_48:
  sub_100046D6C((uint64_t)a1, v9, v3, v4, v5, v6, v7, v8, v92);
  return sub_100046C44(a1);
}

  *a1 = 0LL;
  return 1LL;
}

uint64_t sub_10000BA54(int32x2_t *a1, int *a2, uint64_t *a3)
{
  int v6 = sub_100036D00(&v18, 0LL, (uint64_t)a1);
  if (v6 > 586)
  {
    switch(v6)
    {
      case 587:
        int v13 = 7;
        goto LABEL_21;
      case 588:
        int v13 = 9;
        goto LABEL_21;
      case 589:
        int v13 = 8;
        goto LABEL_21;
      case 590:
        int v13 = 1;
        goto LABEL_21;
      default:
        if (v6 == 608)
        {
          int v13 = 254;
          goto LABEL_21;
        }

        if (v6 == 660)
        {
          int v13 = 11;
          goto LABEL_21;
        }

LABEL_21:
    int v14 = sub_100036D00(&v18, 0LL, (uint64_t)a1);
    if (v14 == 430)
    {
      uint64_t result = sub_1000487A0(a1);
      if (!result) {
        return result;
      }
      goto LABEL_25;
    }

    if (v14 == 59)
    {
      uint64_t result = qword_10008CE80;
LABEL_25:
      *a3 = result;
      *a2 = v13;
      return result;
    }

    uint64_t v16 = "expecting at";
  }

  sub_100046D6C((uint64_t)a1, v16, v7, v8, v9, v10, v11, v12, v17);
  return sub_100046C44(a1);
}

uint64_t sub_10000BBD8(uint64_t *a1, uint64_t *a2)
{
  if (!a1) {
    return 1LL;
  }
  if (!a2) {
    return 0LL;
  }
  do
  {
    int v2 = *((_DWORD *)a1 + 2);
    uint64_t v3 = a2;
    while (*((_DWORD *)v3 + 2) != v2 || v2 == 6 && v3[2] != a1[2])
    {
      uint64_t v3 = (uint64_t *)*v3;
      if (!v3) {
        return 0LL;
      }
    }

    a1 = (uint64_t *)*a1;
    uint64_t v4 = 1LL;
  }

  while (a1);
  return v4;
}

uint64_t sub_10000BC3C(int32x2_t *a1)
{
  return 0LL;
}

uint64_t sub_10000BC9C(int32x2_t *a1)
{
  uint64_t v2 = v12;
  if (!strcasecmp(v12, "true") || !strcasecmp(v2, "on"))
  {
    uint64_t v9 = 1LL;
LABEL_8:
    sub_100046D08(a1);
    return v9;
  }

  if (!strcasecmp(v2, "false") || !strcasecmp(v2, "off"))
  {
    uint64_t v9 = 0LL;
    goto LABEL_8;
  }

  sub_100046D6C((uint64_t)a1, "BOOLean value (true/false/on/off) expected", v3, v4, v5, v6, v7, v8, v11);
  sub_100046C44(a1);
  return 0LL;
}

uint64_t sub_10000BD5C(int32x2_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v43 = a3;
  sub_10002AC64(a3);
  if (!sub_10000BC3C(a1))
  {
    uint64_t v17 = 2508LL;
    return sub_1000235C8(&v43, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", v17);
  }

  for (uint64_t i = 0LL; ; uint64_t i = sub_1000041D0(a1, *(void *)(v43 + 128), 3LL, 0LL, i))
  {
    while (1)
    {
      int v6 = sub_1000374AC(&__s2, 0LL, a1);
      if (v6 != 305) {
        break;
      }
      sub_100036D00(&__s2, 0LL, (uint64_t)a1);
      sub_100036D00(&__s2, 0LL, (uint64_t)a1);
      sub_10002AEBC((uint64_t)a1, a2, __s2, v7, v8, v9, v10, v11);
    }

    if (v6 == 607)
    {
      sub_100036D00(&__s2, 0LL, (uint64_t)a1);
      sub_100046D6C((uint64_t)a1, "unexpected end of file", v18, v19, v20, v21, v22, v23, (char)__s2);
      goto LABEL_12;
    }

    if (v6 == 125) {
      break;
    }
  }

  sub_100036D00(&__s2, 0LL, (uint64_t)a1);
LABEL_12:
  uint64_t v26 = *(void *)(a2 + 56);
  uint64_t v24 = a2 + 56;
  uint64_t v25 = v26;
  if (!v26)
  {
    uint64_t v34 = v43;
    uint64_t v27 = v24;
    uint64_t v35 = 2537LL;
LABEL_23:
    sub_1000235CC(v27, v34, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", v35);
    uint64_t v17 = 2561LL;
    return sub_1000235C8(&v43, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", v17);
  }

  uint64_t v27 = v25 + 40;
  if (!*(void *)(v25 + 40))
  {
LABEL_22:
    uint64_t v34 = v43;
    uint64_t v35 = 2559LL;
    goto LABEL_23;
  }

  if (!sub_10002AA88(v43, v25, 0LL, v12, v13, v14, v15, v16))
  {
    uint64_t v36 = v25;
    while (1)
    {
      uint64_t v25 = *(void *)(v36 + 40);
      uint64_t v27 = v25 + 40;
      if (!*(void *)(v25 + 40)) {
        goto LABEL_22;
      }
      BOOL v37 = sub_10002AA88(v43, *(void *)(v36 + 40), 0LL, v28, v29, v30, v31, v32);
      uint64_t v33 = v36;
      uint64_t v36 = v25;
      if (v37) {
        goto LABEL_20;
      }
    }
  }

  uint64_t v33 = 0LL;
LABEL_20:
  sub_1000235CC(v43 + 40, v25, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 2542LL);
  if (v33)
  {
    sub_1000235C8(v33 + 40, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 2545LL);
    uint64_t v38 = v43;
    uint64_t v39 = v33 + 40;
    uint64_t v40 = 2547LL;
  }

  else
  {
    sub_1000235C8(v24, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 2550LL);
    uint64_t v38 = v43;
    uint64_t v39 = v24;
    uint64_t v40 = 2552LL;
  }

  sub_1000235CC(v39, v38, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", v40);
  uint64_t v17 = 2554LL;
  return sub_1000235C8(&v43, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", v17);
}

uint64_t sub_10000BF94( int32x2_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || !a2) {
    sub_100061FB4( "Invalid arguments at %s:%d.",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c");
  }
  int v10 = sub_1000374AC(&__src, 0LL, a1);
  int v17 = v10;
  if (v10 > 263)
  {
    if (v10 == 264)
    {
      *(_DWORD *)(a2 + 4) = 1;
      uint64_t v30 = sub_100047540(a1, 0LL, (unsigned int *)(a2 + 24), 58, 16LL, 8LL);
      if (!v30) {
        goto LABEL_25;
      }
      int v31 = *(_DWORD *)(a2 + 24);
      if (v31)
      {
        uint64_t v32 = v30;
        if (!sub_1000345C4( (void *)(a2 + 8),  v31 + 1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  3493LL)) {
          sub_100061FB4("No memory for binding.", v33, v34, v35, v36, v37, v38, v39, v46);
        }
        memcpy((void *)(*(void *)(a2 + 8) + 4LL), v32, *(unsigned int *)(a2 + 24));
        *(void *)(a2 + 16) = *(void *)(a2 + 8) + 4LL;
        sub_10005CE20( v32,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  3499LL,  v40,  v41,  v42,  v43,  v44);
      }
    }

    else
    {
      if (v10 != 265) {
        goto LABEL_22;
      }
      int v17 = sub_100036D00(&__src, 0LL, (uint64_t)a1);
      *(_DWORD *)(a2 + 4) = 0;
      uint64_t v27 = (const char *)__src;
      if (!strcasecmp((const char *)__src, "true"))
      {
        uint64_t v18 = 1LL;
        *(_DWORD *)(a2 + 8) = 1;
        return v18;
      }

      if (strcasecmp(v27, "false"))
      {
        uint64_t v28 = "expecting true or false";
        goto LABEL_24;
      }

      *(_DWORD *)(a2 + 8) = 0;
    }

    return 1LL;
  }

  if (v10 == 37)
  {
    sub_100036D00(&__src, 0LL, (uint64_t)a1);
    int v29 = sub_100036D00(&__src, 0LL, (uint64_t)a1);
    if (v29 != 263)
    {
      int v17 = v29;
      uint64_t v28 = "expecting decimal number.";
LABEL_24:
      sub_100046D6C((uint64_t)a1, v28, v11, v12, v13, v14, v15, v16, v46);
      if (v17 == 59) {
        return 0LL;
      }
LABEL_25:
      sub_100046C44(a1);
      return 0LL;
    }

    *(_DWORD *)(a2 + 4) = 2;
    *(void *)(a2 + 8) = atol((const char *)__src);
    return 1LL;
  }

  if (v10 != 262)
  {
LABEL_22:
    uint64_t v28 = "expecting a constant value.";
    goto LABEL_24;
  }

  sub_100036D00(&__src, &v47, (uint64_t)a1);
  uint64_t v18 = 1LL;
  *(_DWORD *)(a2 + 4) = 1;
  int v19 = v47;
  *(_DWORD *)(a2 + 24) = v47;
  if (!sub_1000345C4( (void *)(a2 + 8),  v19 + 1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  3473LL)) {
    sub_100061FB4("No memory for binding.", v20, v21, v22, v23, v24, v25, v26, v46);
  }
  memcpy((void *)(*(void *)(a2 + 8) + 4LL), __src, (v47 + 1));
  *(void *)(a2 + 16) = *(void *)(a2 + 8) + 4LL;
  *(_DWORD *)(a2 + 28) = 1;
  return v18;
}

uint64_t sub_10000C210( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 48);
  if (*(_DWORD *)a3 != 16) {
    sub_100061FB4( "Internal error: Attempt to add non-IPv6 address to IPv6 shared network.",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  v40);
  }
  __int128 v40 = *(_OWORD *)(a3 + 4);
  uint64_t v41 = 0LL;
  if (sub_10002DFA8( &v41,  a2,  &v40,  a4,  a5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  3722LL,  a8)) {
    sub_100061FB4("Out of memory", v10, v11, v12, v13, v14, v15, v16, v40);
  }
  uint64_t v24 = v41;
  *((void *)v41 + 10) = 0LL;
  sub_1000235CC(v24 + 20, a1, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 3737LL);
  uint64_t v25 = v41;
  *((void *)v41 + 9) = 0LL;
  sub_1000235CC(v25 + 18, v9, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c", 3739LL);
  uint64_t v26 = *(uint64_t **)(v9 + 80);
  if (v26)
  {
    unsigned int v27 = -1;
    do
    {
      uint64_t v28 = *v26++;
      ++v27;
    }

    while (v28);
  }

  else
  {
    unsigned int v27 = 0;
  }

  int v29 = sub_10005CDE4(8 * v27 + 16);
  uint64_t v37 = v29;
  if (!v29) {
    sub_100061FB4("Out of memory", v30, v31, v32, v33, v34, v35, v36, v40);
  }
  if (v27) {
    memcpy(v29, *(const void **)(v9 + 80), 8LL * v27);
  }
  uint64_t v38 = *(void **)(v9 + 80);
  if (v38) {
    sub_10005CE20( v38,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  3761LL,  v32,  v33,  v34,  v35,  v36);
  }
  *(void *)(v9 + 80) = v37;
  uint64_t result = sub_10002E154( &v37[v27],  v41,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  3768LL,  v33,  v34,  v35,  v36);
  *(void *)(*(void *)(v9 + 80) + 8LL * (v27 + 1)) = 0LL;
  return result;
}

void sub_10000C3A0()
{
  if (!v0) {
    JUMPOUT(0x10000C33CLL);
  }
  JUMPOUT(0x10000C32CLL);
}

uint64_t sub_10000C3A8( void *a1, int32x2_t *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v36 = a3;
  uint64_t v33 = 0LL;
  uint64_t v34 = 0LL;
  if (!sub_1000545BC( (uint64_t *)&v33,  &v36,  1,  0LL,  1LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4087LL,  a8)) {
    return 0LL;
  }
  int v10 = sub_100036D00(&v37, 0LL, (uint64_t)a2);
  if (v10 > 420)
  {
    if (v10 > 600)
    {
      if (v10 == 601)
      {
        int v17 = 40;
        goto LABEL_21;
      }

      if (v10 == 631)
      {
        int v17 = 49;
        goto LABEL_21;
      }
    }

    else
    {
      if (v10 == 421)
      {
        int v17 = 29;
        goto LABEL_21;
      }

      if (v10 == 578)
      {
        int v17 = 8;
        goto LABEL_21;
      }
    }

    goto LABEL_24;
  }

  if (v10 > 312)
  {
    if (v10 == 313)
    {
      int v17 = 9;
      goto LABEL_21;
    }

    if (v10 == 420)
    {
      int v17 = 28;
      goto LABEL_21;
    }

    goto LABEL_24;
  }

  if (v10 == 286)
  {
    int v17 = 7;
    goto LABEL_21;
  }

  if (v10 != 309)
  {
LABEL_24:
    sub_100046D6C((uint64_t)a2, "expecting allow/deny key", v11, v12, v13, v14, v15, v16, v32);
    sub_100046C44(a2);
    return 0LL;
  }

  int v17 = 6;
LABEL_21:
  int v35 = v17;
  if (!sub_100029804( &v34,  qword_10008BFF8,  &v35,  0LL,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4131LL)) {
    sub_100061FB4("Unable to find server option %u (%s:%d).", v18, v19, v20, v21, v22, v23, v24, v35);
  }
  uint64_t v25 = sub_100054A34( a1,  0LL,  v33,  v34,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4134LL,  v23,  v24);
  sub_100054390( (uint64_t *)&v33,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/confpars.c",  4135LL,  v26,  v27,  v28,  v29,  v30);
  sub_100046D08(a2);
  return v25;
}

uint64_t sub_10000C554(uint64_t a1)
{
  if (!dword_10008BD98 || (uint64_t result = sub_10000CBC0(), (_DWORD)result))
  {
    if (byte_10008CF98 == 1) {
      ++dword_10008CF9C;
    }
    *__error() = 0;
    uint64_t v3 = (FILE *)qword_10008BDA0;
    __int128 v98 = *(_OWORD *)(a1 + 56);
    int v99 = *(_DWORD *)(a1 + 72);
    uint64_t v11 = sub_100040144((int *)&v98, v4, v5, v6, v7, v8, v9, v10);
    fprintf(v3, "lease %s {", v11);
    int v12 = *__error();
    int v13 = v12 != 0;
    time_t v14 = *(void *)(a1 + 80);
    if (v14)
    {
      uint64_t v15 = sub_10005207C(v14);
      if (!v15 || fprintf((FILE *)qword_10008BDA0, "\n  starts %s", v15) < 0)
      {
        if (v12) {
          int v13 = 2;
        }
        else {
          int v13 = 1;
        }
      }
    }

    time_t v16 = *(void *)(a1 + 88);
    if (v16)
    {
      int v17 = sub_10005207C(v16);
    }

    time_t v18 = *(void *)(a1 + 240);
    if (v18)
    {
      uint64_t v19 = sub_10005207C(v18);
    }

    time_t v20 = *(void *)(a1 + 248);
    if (v20)
    {
      uint64_t v21 = sub_10005207C(v20);
    }

    time_t v22 = *(void *)(a1 + 256);
    if (v22)
    {
      uint64_t v23 = sub_10005207C(v22);
    }

    time_t v24 = *(void *)(a1 + 264);
    if (v24)
    {
      uint64_t v25 = sub_10005207C(v24);
    }

    int v26 = *(unsigned __int8 *)(a1 + 222);
    else {
      uint64_t v27 = off_1000890A8[v26 - 1];
    }
    unsigned int v33 = v13 + (fprintf((FILE *)qword_10008BDA0, "\n  binding state %s;", v27) >> 31);
    int v34 = *(unsigned __int8 *)(a1 + 223);
    if (*(unsigned __int8 *)(a1 + 222) != v34)
    {
      else {
        int v35 = off_1000890A8[v34 - 1];
      }
      v33 += fprintf((FILE *)qword_10008BDA0, "\n  next binding state %s;", v35) >> 31;
    }

    char v36 = *(_BYTE *)(a1 + 221);
    if ((v36 & 4) != 0)
    {
      v33 += fprintf((FILE *)qword_10008BDA0, "\n  reserved;") >> 31;
      char v36 = *(_BYTE *)(a1 + 221);
    }

    if ((v36 & 2) != 0) {
      v33 += fprintf((FILE *)qword_10008BDA0, "\n  dynamic-bootp;") >> 31;
    }
    uint64_t v37 = *(void *)(a1 + 144);
    if (v37 && *(void *)(a1 + 88) > qword_10008CE80 && !sub_10000CE38(v37))
    {
      sub_10006221C( "unable to write class %s",  v38,  v39,  v28,  v29,  v30,  v31,  v32,  *(void *)(*(void *)(a1 + 144) + 48LL));
      ++v33;
    }

    if (*(_BYTE *)(a1 + 203))
    {
      *__error() = 0;
      __int128 v40 = (FILE *)qword_10008BDA0;
      uint64_t v41 = off_100089E58[*(unsigned __int8 *)(a1 + 204)];
      uint64_t v42 = sub_1000501FC( *(unsigned __int8 *)(a1 + 204),  *(unsigned __int8 *)(a1 + 203) - 1,  (unsigned __int8 *)(a1 + 205));
      fprintf(v40, "\n  hardware %s %s;", v41, v42);
      if (*__error()) {
        ++v33;
      }
    }

    if (*(_WORD *)(a1 + 192))
    {
      uint64_t v43 = sub_10004FF50(*(unsigned __int8 **)(a1 + 184), *(unsigned __int16 *)(a1 + 192));
      if (v43)
      {
        uint64_t v44 = v43;
        *__error() = 0;
        fprintf((FILE *)qword_10008BDA0, "\n  uid %s;", v44);
        if (*__error()) {
          ++v33;
        }
        sub_10005CE20( v44,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/db.c",  206LL,  v45,  v46,  v47,  v48,  v49);
      }

      else
      {
        ++v33;
      }
    }

    uint64_t v50 = *(void *)(a1 + 112);
    if (v50)
    {
      for (uint64_t i = *(void **)(v50 + 16); i; uint64_t i = (void *)*i)
      {
      }
    }

    uint64_t v52 = *(void *)(a1 + 152);
    if (v52)
    {
      for (j = *(void **)(v52 + 8); j; j = (void *)j[1])
      {
        uint64_t v54 = *j;
        if (*(_DWORD *)(*j + 48LL))
        {
          *__error() = 0;
          uint64_t v55 = (FILE *)qword_10008BDA0;
          uint64_t v56 = *(const char ***)(v54 + 24);
          uint64_t v57 = *v56;
          uint64_t v61 = sub_100042FF0(v56, *(char **)(v54 + 40), *(unsigned int *)(v54 + 48), 1LL, 1LL, v58, v59, v60);
          fprintf(v55, "\n  option agent.%s %s;", v57, v61);
          if (*__error()) {
            ++v33;
          }
        }
      }
    }

    uint64_t v62 = *(unsigned __int8 **)(a1 + 104);
    if (v62 && sub_10000D0B0(*(_BYTE **)(a1 + 104)))
    {
      uint64_t v63 = sub_10004FDF0(v62);
      if (v63)
      {
        uint64_t v64 = v63;
        *__error() = 0;
        fprintf((FILE *)qword_10008BDA0, "\n  client-hostname %s;", v64);
        if (*__error()) {
          ++v33;
        }
        sub_10005CE20( v64,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/db.c",  248LL,  v65,  v66,  v67,  v68,  v69);
      }

      else
      {
        ++v33;
      }
    }

    if (*(void *)(a1 + 160))
    {
      *__error() = 0;
      uint64_t v70 = *(void *)(a1 + 160) == *(void *)(a1 + 176) ? " or release" : &byte_1000728D2;
      fprintf((FILE *)qword_10008BDA0, "\n  on expiry%s {", v70);
      sub_10003E18C(qword_10008BDA0, *(void *)(a1 + 160), 4LL, v71, v72, v73, v74, v75);
      fwrite("\n  }", 4uLL, 1uLL, (FILE *)qword_10008BDA0);
      if (*__error()) {
        ++v33;
      }
    }

    uint64_t v76 = *(void *)(a1 + 176);
    if (v76)
    {
      if (v76 != *(void *)(a1 + 160))
      {
        *__error() = 0;
        fwrite("\n  on release {", 0xFuLL, 1uLL, (FILE *)qword_10008BDA0);
        sub_10003E18C(qword_10008BDA0, *(void *)(a1 + 176), 4LL, v77, v78, v79, v80, v81);
        fwrite("\n  }", 4uLL, 1uLL, (FILE *)qword_10008BDA0);
        if (*__error()) {
          ++v33;
        }
      }
    }

    *__error() = 0;
    fputs("\n}\n", (FILE *)qword_10008BDA0);
    if (*__error()) {
      int v89 = -1;
    }
    else {
      int v89 = 0;
    }
    if (v33 != v89)
    {
      __int128 v98 = *(_OWORD *)(a1 + 56);
      int v99 = *(_DWORD *)(a1 + 72);
      char v90 = sub_100040144((int *)&v98, v82, v83, v84, v85, v86, v87, v88);
      sub_1000622D4("write_lease: unable to write lease %s", v91, v92, v93, v94, v95, v96, v97, v90);
      dword_10008BD98 = 1;
    }

    return v33 == v89;
  }

  return result;
}

uint64_t sub_10000CBC0()
{
  int v0 = dword_10008BD98;
  int v8 = open(__str, 1537);
  if ((v8 & 0x80000000) == 0)
  {
    int v16 = v8;
    int v17 = fdopen(v8, "w");
    if (!v17)
    {
      sub_10006221C("Can't fdopen new lease file: %m", v18, v19, v20, v21, v22, v23, v24, 180);
      close(v16);
      goto LABEL_12;
    }

    uint64_t v25 = (uint64_t)v17;
    if (qword_10008BDA0) {
      fclose((FILE *)qword_10008BDA0);
    }
    qword_10008BDA0 = v25;
    *__error() = 0;
    fprintf( (FILE *)qword_10008BDA0,  "# The format of this file is documented in the %s",  "dhcpd.leases(5) manual page.\n");
    if (!*__error())
    {
      fprintf((FILE *)qword_10008BDA0, "# This lease file was written by isc-dhcp-%s\n\n", "4.1-ESV");
      int v26 = __error();
      if (!*v26)
      {
        dword_10008BD98 = 0;
        byte_10008CF98 = 0;
        if (sub_10002CEFC((uint64_t)v26, v27, v28, v29, v30, v31, v32, v33))
        {
          if (unlink(v66) < 0 && *__error() != 2)
          {
            sub_10006221C("Can't remove old lease database backup %s: %m", v42, v43, v44, v45, v46, v47, v48, (char)v66);
            goto LABEL_9;
          }

          if ((link(off_100088B48[0], v66) & 0x80000000) == 0)
          {
LABEL_24:
            if ((rename(__str, off_100088B48[0]) & 0x80000000) == 0)
            {
              uint64_t result = 1LL;
              byte_10008CF98 = 1;
              return result;
            }

            sub_10006221C( "Can't install new lease database %s to %s: %m",  v56,  v57,  v58,  v59,  v60,  v61,  v62,  (char)__str);
            goto LABEL_9;
          }

          if (*__error() == 2)
          {
            sub_10006221C( "%s is missing - no lease db to backup.",  v49,  v50,  v51,  v52,  v53,  v54,  v55,  (char)off_100088B48[0]);
            goto LABEL_24;
          }

          sub_10006221C( "Can't backup lease database %s to %s: %m",  v49,  v50,  v51,  v52,  v53,  v54,  v55,  (char)off_100088B48[0]);
        }
      }
    }

LABEL_9:
    dword_10008BD98 = v0;
LABEL_12:
    unlink(__str);
    return 0LL;
  }

  sub_10006221C("Can't create new lease file: %m", v9, v10, v11, v12, v13, v14, v15, 180);
  return 0LL;
}

  uint64_t v31 = *(_WORD *)(a1 + 21);
  *(_BYTE *)(a5 + 3) = *(_BYTE *)(a1 + 23);
  *(_WORD *)(a5 + 1) = v31;
  if (!sub_100040D4C(&qword_10008C1F8, *a4, 2LL, v25, v26, v27, v28, v29))
  {
    uint64_t v32 = &qword_10009D160;
    if (a3) {
      uint64_t v32 = a3;
    }
    if (!sub_100040F30( &qword_10008C1F8,  *a4,  0LL,  (uint64_t)v32[1],  *((unsigned int *)v32 + 4),  2LL,  0LL,  v19))
    {
      uint64_t v30 = "start_reply: error saving server identifier.";
      goto LABEL_20;
    }
  }

  if (*(void *)a2
    && !sub_100040F30( &qword_10008C1F8,  *a4,  *(void *)a2,  *(void *)(a2 + 8),  *(unsigned int *)(a2 + 16),  1LL,  0LL,  v19))
  {
    uint64_t v30 = "start_reply: error saving client identifier.";
    goto LABEL_20;
  }

  if (!sub_100040D4C(&qword_10008C1F8, *(void *)(a1 + 160), 20LL, v15, v16, v17, v18, v19)
    || sub_100040F30(&qword_10008C1F8, *a4, 0LL, (uint64_t)&byte_1000728D2, 0LL, 20LL, 0LL, v33))
  {
    return 1LL;
  }

  sub_10006221C("start_reply: error saving RECONF_ACCEPT option.", v34, v35, v36, v37, v38, v39, v40, v47);
  sub_100034894( a4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  927LL,  v42,  v43,  v44,  v45,  v46);
  return 0LL;
}

    uint64_t result = (uint64_t)sub_10005415C(0LL, 0LL);
    *uint64_t v18 = result;
    if (result)
    {
      uint64_t v22 = (_DWORD *)a3;
      uint64_t v23 = 3551LL;
      return sub_100033F18( (void *)result,  v22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  v23,  a5,  a6,  a7,  a8);
    }
  }

  return result;
}

  a2[5] = v19;
  uint64_t v22 = v20 / 8;
  uint64_t v23 = a2 + 6;
  uint64_t v24 = (uint64_t)v11 >> 3;
  memset(a2 + 6, 255, v24);
  if (v20 / 8 < v19)
  {
    *((_BYTE *)a2 + v24 + 24) = byte_100082A9C[v20 % 8];
    bzero((char *)v23 + v24 + 1, a2[5] + ~v22);
    uint64_t v62 = *(_OWORD *)a2;
    char v63 = a2[4];
    uint64_t v32 = sub_100040144((int *)&v62, v25, v26, v27, v28, v29, v30, v31);
    uint64_t v40 = 1;
LABEL_11:
    uint64_t v41 = (char *)v23 + v22;
    do
    {
      uint64_t v42 = *(v41 - 20);
      uint64_t v43 = (*v41 & v42);
      if (v43 != v42)
      {
        uint64_t v40 = 0;
        *(v41 - 20) = v43;
        if (++v22 < a2[5]) {
          goto LABEL_11;
        }
        goto LABEL_18;
      }

      ++v22;
      ++v41;
    }

    while (a2[5] > v22);
    if ((v40 & 1) != 0) {
      return 1LL;
    }
LABEL_18:
    sub_10006221C( "Warning: Extraneous bits removed in address component of %s/%d.",  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v32);
    uint64_t v62 = *(_OWORD *)a2;
    char v63 = a2[4];
    uint64_t v51 = sub_100040144((int *)&v62, v44, v45, v46, v47, v48, v49, v50);
    sub_10006221C("New value: %s/%d.", v52, v53, v54, v55, v56, v57, v58, v51);
  }

  return 1LL;
}

uint64_t sub_10000CE38(uint64_t a1)
{
  if (!dword_10008BD98 || (uint64_t result = sub_10000CBC0(), (_DWORD)result))
  {
    uint64_t v3 = *(void *)(a1 + 40);
    if (v3)
    {
      unsigned int v4 = fprintf((FILE *)qword_10008BDA0, "\n  billing subclass %s", *(const char **)(v3 + 48)) >> 31;
      int v5 = sub_10000E030((FILE *)qword_10008BDA0, a1) - 1;
      BOOL v6 = fprintf((FILE *)qword_10008BDA0, ";") >= 0 && v5 == v4;
      int v7 = v6;
      *(_DWORD *)(a1 + 72) = v7;
      uint64_t result = 1LL;
      if (!v6)
      {
        dword_10008BD98 = 1;
        return 0LL;
      }
    }

    else
    {
      *__error() = 0;
      fprintf((FILE *)qword_10008BDA0, "\n  billing class %s;", *(const char **)(a1 + 48));
      return *__error() == 0;
    }
  }

  return result;
}

uint64_t sub_10000CF20( FILE *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = 39LL;
  if (a1 && a3)
  {
    uint64_t v12 = *(void *)(a2 + 16);
    switch(*(_DWORD *)(v12 + 4))
    {
      case 0:
        *__error() = 0;
        fprintf(a1, "%sset %s = %s;");
        goto LABEL_11;
      case 1:
        uint64_t v13 = *(unsigned __int8 **)(v12 + 16);
        if (!v13) {
          goto LABEL_15;
        }
        uint64_t v14 = sub_10004FF50(v13, *(_DWORD *)(v12 + 24));
        if (!v14) {
          goto LABEL_12;
        }
        uint64_t v15 = v14;
        *__error() = 0;
        fprintf(a1, "%sset %s = %s;", a3, *(const char **)(a2 + 8), v15);
        if (*__error()) {
          goto LABEL_12;
        }
        sub_10005CE20( v15,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/db.c",  70LL,  v16,  v17,  v18,  v19,  v20);
        goto LABEL_15;
      case 2:
        *__error() = 0;
        fprintf(a1, "%sset %s = %%%ld;");
LABEL_11:
        if (!*__error()) {
          goto LABEL_15;
        }
LABEL_12:
        uint64_t result = 25LL;
        break;
      case 3:
        sub_10006221C( "%s: persistent dns values not supported.",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  *(void *)(a2 + 8));
        goto LABEL_15;
      case 4:
        sub_10006221C( "%s: persistent functions not supported.",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  *(void *)(a2 + 8));
LABEL_15:
        uint64_t result = 0LL;
        break;
      default:
        sub_100061FB4("%s: unknown binding type %d", a2, (uint64_t)a3, a4, a5, a6, a7, a8, *(void *)(a2 + 8));
    }
  }

  return result;
}

uint64_t sub_10000D0B0(_BYTE *a1)
{
  int v1 = *a1;
  if (!*a1) {
    return 1LL;
  }
  uint64_t v2 = a1 + 1;
  while ((v1 & 0x80) == 0 && (_DefaultRuneLocale.__runetype[v1] & 0x40000) != 0)
  {
    uint64_t result = 0LL;
    if (v1 == 92 || v1 == 34) {
      return result;
    }
    int v4 = *v2++;
    int v1 = v4;
    if (!v4) {
      return 1LL;
    }
  }

  return 0LL;
}

uint64_t sub_10000D100(uint64_t a1)
{
  if (!dword_10008BD98 || (uint64_t result = sub_10000CBC0(), (_DWORD)result))
  {
    uint64_t result = sub_10000D0B0(*(_BYTE **)(a1 + 48));
    if ((_DWORD)result)
    {
      if (byte_10008CF98 == 1) {
        ++dword_10008CF9C;
      }
      *__error() = 0;
      fprintf((FILE *)qword_10008BDA0, "host %s {", *(const char **)(a1 + 48));
      int v3 = *__error();
      int v4 = v3 != 0;
      int v5 = *(_DWORD *)(a1 + 192);
      if ((v5 & 2) != 0)
      {
        *__error() = 0;
        fwrite("\n  dynamic;", 0xBuLL, 1uLL, (FILE *)qword_10008BDA0);
        int v6 = *__error();
        if (v3) {
          int v7 = 2;
        }
        else {
          int v7 = 1;
        }
        if (v6) {
          int v4 = v7;
        }
        int v5 = *(_DWORD *)(a1 + 192);
      }

      if ((v5 & 1) != 0)
      {
        *__error() = 0;
        fwrite("\n  deleted;", 0xBuLL, 1uLL, (FILE *)qword_10008BDA0);
      }

      else
      {
        if (*(_BYTE *)(a1 + 56))
        {
          *__error() = 0;
          int v8 = (FILE *)qword_10008BDA0;
          uint64_t v9 = off_100089E58[*(unsigned __int8 *)(a1 + 57)];
          uint64_t v10 = sub_1000501FC( *(unsigned __int8 *)(a1 + 57),  *(unsigned __int8 *)(a1 + 56) - 1,  (unsigned __int8 *)(a1 + 58));
          fprintf(v8, "\n  hardware %s %s;", v9, v10);
          if (*__error()) {
            ++v4;
          }
        }

        if (*(_DWORD *)(a1 + 96))
        {
          *__error() = 0;
          uint64_t v11 = *(char **)(a1 + 88);
          unsigned int v12 = *(_DWORD *)(a1 + 96);
          if (sub_10000D57C(v11, v12))
          {
            fprintf((FILE *)qword_10008BDA0, "\n  uid %.*s;", v12, v11);
          }

          else
          {
            fprintf((FILE *)qword_10008BDA0, "\n  uid %2.2x", *v11);
            if (*__error()) {
              ++v4;
            }
            if (*(_DWORD *)(a1 + 96) >= 2u)
            {
              unint64_t v13 = 1LL;
              do
              {
                *__error() = 0;
                fprintf((FILE *)qword_10008BDA0, ":%2.2x", *(unsigned __int8 *)(*(void *)(a1 + 88) + v13));
                if (*__error()) {
                  ++v4;
                }
                ++v13;
              }

              while (v13 < *(unsigned int *)(a1 + 96));
            }

            *__error() = 0;
            fputc(59, (FILE *)qword_10008BDA0);
          }

          if (*__error()) {
            ++v4;
          }
        }

        uint64_t v33 = 0LL;
        uint64_t v34 = 0LL;
        uint64_t v35 = 0LL;
        uint64_t v14 = *(void *)(a1 + 136);
        if (v14
          && sub_100057AA4( &v33,  0LL,  0LL,  0LL,  0LL,  0LL,  &qword_10008C730,  v14,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/db.c",  0x177u))
        {
          *__error() = 0;
          fwrite("\n  fixed-address ", 0x11uLL, 1uLL, (FILE *)qword_10008BDA0);
          if (*__error()) {
            int v15 = v4 + 1;
          }
          else {
            int v15 = v4;
          }
          if ((_DWORD)v35 != 3)
          {
            unint64_t v16 = 0LL;
            do
            {
              *__error() = 0;
              else {
                uint64_t v17 = ",";
              }
              fprintf( (FILE *)qword_10008BDA0,  "%u.%u.%u.%u%s",  *(unsigned __int8 *)(v34 + v16),  *(unsigned __int8 *)(v34 + v16 + 1),  *(unsigned __int8 *)(v34 + v16 + 2),  *(unsigned __int8 *)(v34 + v16 + 3),  v17);
              if (*__error()) {
                ++v15;
              }
              v16 += 4LL;
            }

            while (v16 < (v35 - 3));
          }

          *__error() = 0;
          fputc(59, (FILE *)qword_10008BDA0);
          if (*__error()) {
            int v4 = v15 + 1;
          }
          else {
            int v4 = v15;
          }
        }

        if (*(void *)(a1 + 160))
        {
          *__error() = 0;
          fprintf((FILE *)qword_10008BDA0, "\n  group %s;", *(const char **)(*(void *)(a1 + 160) + 48LL));
          if (*__error()) {
            ++v4;
          }
        }

        uint64_t v18 = *(void *)(a1 + 152);
        if (!v18) {
          goto LABEL_57;
        }
        uint64_t v19 = *(void *)(a1 + 160);
        if (v19)
        {
          if (v18 == *(void *)(v19 + 40)) {
            goto LABEL_57;
          }
        }

        if (v18 == qword_10008C140) {
          goto LABEL_57;
        }
        *__error() = 0;
        sub_10003E18C(qword_10008BDA0, *(void *)(*(void *)(a1 + 152) + 48LL), 8LL, v20, v21, v22, v23, v24);
      }

      if (*__error()) {
        ++v4;
      }
LABEL_57:
      *__error() = 0;
      fputs("\n}\n", (FILE *)qword_10008BDA0);
      if (*__error()) {
        int v32 = -1;
      }
      else {
        int v32 = 0;
      }
      if (v4 != v32)
      {
        sub_1000622D4("write_host: unable to write host %s", v25, v26, v27, v28, v29, v30, v31, *(void *)(a1 + 48));
        dword_10008BD98 = 1;
      }

      return v4 == v32;
    }
  }

  return result;
}

uint64_t sub_10000D57C(char *a1, unsigned int a2)
{
  if (!a2) {
    return 1LL;
  }
  uint64_t v2 = a2;
  while (1)
  {
    int v4 = *a1++;
    unsigned __int8 v3 = v4;
    if (v4 < 0) {
      break;
    }
    int v5 = v3;
    if ((_DefaultRuneLocale.__runetype[v3] & 0x40000) == 0) {
      break;
    }
    uint64_t v6 = 0LL;
    if (v5 == 92 || v5 == 34) {
      return v6;
    }
    if (!--v2) {
      return 1LL;
    }
  }

  return 0LL;
}

uint64_t sub_10000D5D4(uint64_t a1)
{
  if (!dword_10008BD98 || (uint64_t result = sub_10000CBC0(), (_DWORD)result))
  {
    uint64_t result = sub_10000D0B0(*(_BYTE **)(a1 + 48));
    if ((_DWORD)result)
    {
      if (byte_10008CF98 == 1) {
        ++dword_10008CF9C;
      }
      *__error() = 0;
      fprintf((FILE *)qword_10008BDA0, "group %s {", *(const char **)(a1 + 48));
      int v3 = *__error();
      int v4 = v3 != 0;
      int v5 = *(_DWORD *)(a1 + 56);
      if ((v5 & 2) != 0)
      {
        *__error() = 0;
        fwrite("\n  dynamic;", 0xBuLL, 1uLL, (FILE *)qword_10008BDA0);
        int v11 = *__error();
        if (v3) {
          int v12 = 2;
        }
        else {
          int v12 = 1;
        }
        if (v11) {
          int v4 = v12;
        }
        int v5 = *(_DWORD *)(a1 + 56);
        if ((v5 & 4) == 0)
        {
LABEL_8:
          if ((v5 & 1) == 0)
          {
LABEL_9:
            if (!*(void *)(a1 + 40))
            {
LABEL_23:
              *__error() = 0;
              fputs("\n}\n", (FILE *)qword_10008BDA0);
              if (*__error()) {
                int v20 = -1;
              }
              else {
                int v20 = 0;
              }
              if (v4 != v20)
              {
                sub_1000622D4( "write_group: unable to write group %s",  v13,  v14,  v15,  v16,  v17,  v18,  v19,  *(void *)(a1 + 48));
                dword_10008BD98 = 1;
              }

              return v4 == v20;
            }

            *__error() = 0;
            sub_10003E18C(qword_10008BDA0, *(void *)(*(void *)(a1 + 40) + 48LL), 8LL, v6, v7, v8, v9, v10);
LABEL_21:
            if (*__error()) {
              ++v4;
            }
            goto LABEL_23;
          }

uint64_t sub_10000D7B4(uint64_t a1)
{
  if (!dword_10008BD98 || (uint64_t result = sub_10000CBC0(), (_DWORD)result))
  {
    if (byte_10008CF98 == 1) {
      ++dword_10008CF9C;
    }
    int v3 = sub_10004FF50(*(unsigned __int8 **)(a1 + 16), *(_DWORD *)(a1 + 24));
    if (v3)
    {
      int v11 = v3;
      int v12 = *(unsigned __int16 *)(a1 + 32);
      switch(v12)
      {
        case 3:
          int v13 = fprintf((FILE *)qword_10008BDA0, "ia-na %s {\n");
          goto LABEL_12;
        case 25:
          int v13 = fprintf((FILE *)qword_10008BDA0, "ia-pd %s {\n");
          goto LABEL_12;
        case 4:
          int v13 = fprintf((FILE *)qword_10008BDA0, "ia-ta %s {\n");
LABEL_12:
          int v19 = v13;
          sub_10005CE20( v11,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/db.c",  547LL,  v14,  v15,  v16,  v17,  v18);
          if ((v19 & 0x80000000) == 0)
          {
            time_t v20 = *(void *)(a1 + 48);
            if (!v20
              || (uint64_t v21 = sub_10005207C(v20)) != 0LL
              && (fprintf((FILE *)qword_10008BDA0, "  cltt %s\n", v21) & 0x80000000) == 0)
            {
              if (*(int *)(a1 + 36) < 1)
              {
LABEL_47:
                if ((fprintf((FILE *)qword_10008BDA0, "}\n\n") & 0x80000000) == 0)
                {
                  fflush((FILE *)qword_10008BDA0);
                  return 1LL;
                }
              }

              else
              {
                uint64_t v22 = 0LL;
                while (1)
                {
                  uint64_t v23 = *(void *)(*(void *)(a1 + 56) + 8 * v22);
                  inet_ntop(30, (const void *)(v23 + 4), v37, 0x2Eu);
                  if (*(_WORD *)(a1 + 32) == 25) {
                    goto LABEL_21;
                  }
                  if (*(_WORD *)(a1 + 32) == 25)
                  {
LABEL_21:
                  }

                  int v24 = *(unsigned __int8 *)(v23 + 21);
                  if (fprintf( (FILE *)qword_10008BDA0,  "    binding state %s;\n",
                         off_1000890A8[*(unsigned __int8 *)(v23 + 21) - 1]) < 0
                    || fprintf((FILE *)qword_10008BDA0, "    preferred-life %u;\n", *(_DWORD *)(v23 + 48)) < 0
                    || fprintf((FILE *)qword_10008BDA0, "    max-life %u;\n", *(_DWORD *)(v23 + 52)) < 0)
                  {
                    break;
                  }

                  int v25 = *(unsigned __int8 *)(v23 + 21);
                  BOOL v26 = v25 == 2 || v25 == 5;
                  uint64_t v27 = (time_t *)(v26 || *(void *)(v23 + 32) ? v23 + 32 : v23 + 40);
                  uint64_t v28 = sub_10005207C(*v27);
                  uint64_t v29 = *(void *)(v23 + 24);
                  if (v29)
                  {
                    uint64_t v30 = *(void **)(v29 + 16);
                    if (v30)
                    {
                      while (!v30[2]
                           || !sub_10000CF20( (FILE *)qword_10008BDA0,  (uint64_t)v30,  "\n    ",  v6,  v7,  v8,  v9,  v10))
                      {
                        uint64_t v30 = (void *)*v30;
                        if (!v30) {
                          goto LABEL_40;
                        }
                      }

                      goto LABEL_45;
                    }
                  }

LABEL_40:
                }
              }
            }
          }

          goto LABEL_45;
      }

      sub_10006221C("Unknown ia type %u for %s at %s:%d", v4, v5, v6, v7, v8, v9, v10, v12);
      sub_10005CE20( v11,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/db.c",  547LL,  v31,  v32,  v33,  v34,  v35);
    }

LABEL_45:
    sub_1000622D4("write_ia: unable to write ia", v4, v5, v6, v7, v8, v9, v10, v36);
    uint64_t result = 0LL;
    dword_10008BD98 = 1;
  }

  return result;
}

        sub_100034EA8( v97,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4816LL,  v68,  v69,  v70,  v71,  v72);
        uint64_t v56 = v107;
      }

      goto LABEL_46;
    }

    uint64_t v107 = v112;
LABEL_20:
    while (1)
    {
      uint64_t v59 = *(void *)(v56 + 136);
      if (v59) {
        break;
      }
LABEL_28:
      uint64_t v56 = *(void *)(v56 + 32);
      uint64_t v107 = v56;
      if (!v56) {
        goto LABEL_29;
      }
    }

    if (!sub_100057AA4( &__n[1],  0LL,  0LL,  0LL,  0LL,  0LL,  &qword_10008C730,  v59,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  0x129Fu))
    {
      uint64_t v95 = "iterate_over_ia_na: error evaluating host address.";
      goto LABEL_60;
    }

    if (v106 < 0x10 || (*v102 == *v105 ? (uint64_t v60 = v102[1] == v105[1]) : (uint64_t v60 = 0), !v60))
    {
      sub_100034EA8( (_DWORD **)&__n[1],  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4777LL,  v21,  v22,  v23,  v24,  v25);
      uint64_t v56 = v107;
      goto LABEL_28;
    }

    sub_100034EA8( (_DWORD **)&__n[1],  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4774LL,  v21,  v22,  v23,  v24,  v25);
    uint64_t v56 = v107;
    if (!v107) {
      goto LABEL_29;
    }
LABEL_46:
    if (v56 | v100) {
      v4(v8, &v104);
    }
    else {
      v2(v8, &v104, v110, v10, &__src, __n, 0x10000LL);
    }
    if (v100) {
      sub_10002D8B8( (void **)&v100,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4829LL,  v76,  v77,  v78,  v79,  v80);
    }
    sub_100034EA8( &v104,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4832LL,  v76,  v77,  v78,  v79,  v80);
    uint64_t v57 = 4834LL;
    uint64_t v58 = 4833LL;
LABEL_52:
    sub_100034894( &v108,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  v58,  v51,  v52,  v53,  v54,  v55);
    sub_100034EA8( &v109,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  v57,  v81,  v82,  v83,  v84,  v85);
    uint64_t v43 = *(void *)(v43 + 8);
  }

  while (v43);
LABEL_53:
  uint64_t v86 = __n[0];
  *(_DWORD *)(v11 + 16) = __n[0];
  *(void *)int v11 = 0LL;
  if (!sub_1000345C4( (void *)v11,  v86,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4842LL)) {
    sub_100061FB4("No memory to store reply.", v87, v88, v89, v90, v91, v92, v93, v96);
  }
  uint64_t v94 = (void *)(*(void *)v11 + 4LL);
  *(void *)(v11 + 8) = v94;
  uint64_t result = (uint64_t)memcpy(v94, &__src, __n[0]);
LABEL_61:
  if (v100) {
    uint64_t result = sub_10002D8B8( (void **)&v100,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4850LL,  v32,  v33,  v34,  v35,  v36);
  }
  if (*(void *)&__n[1]) {
    uint64_t result = (uint64_t)sub_100034EA8( (_DWORD **)&__n[1],  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4856LL,  v32,  v33,  v34,  v35,  v36);
  }
  if (v104) {
    uint64_t result = (uint64_t)sub_100034EA8( &v104,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4859LL,  v32,  v33,  v34,  v35,  v36);
  }
  if (v108) {
    uint64_t result = sub_100034894( &v108,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4862LL,  v32,  v33,  v34,  v35,  v36);
  }
  if (v109) {
    uint64_t result = (uint64_t)sub_100034EA8( &v109,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4865LL,  v32,  v33,  v34,  v35,  v36);
  }
  if (v113) {
    return sub_100034894( &v113,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4868LL,  v32,  v33,  v34,  v35,  v36);
  }
  return result;
}

      uint64_t v31 = sub_100065D28(2, 1, 0);
      *(_DWORD *)(a1 + 500) = v31;
      uint64_t v32 = __error();
      if (v31 >= 0x400)
      {
        sub_100068C8C(*v32);
        return 0xFFFFFFFFLL;
      }

      *uint64_t v32 = 0;
      if ((sub_100065CD4(*(_DWORD *)(a1 + 500), v94, 0x10u) & 0x80000000) != 0)
      {
        uint64_t v75 = __error();
        uint64_t v6 = sub_100068C8C(*v75);
        v87 |= v22;
LABEL_138:
        uint64_t v73 = *(_DWORD *)(a1 + 500);
LABEL_139:
        if (v73 < 0)
        {
LABEL_141:
          uint64_t v88 = v24;
          uint64_t v18 = v90;
LABEL_142:
          int v19 = v87;
          goto LABEL_19;
        }

uint64_t sub_10000DB2C()
{
  if (!sub_100019FDC()) {
    return 1LL;
  }
  if (!dword_10008BD98 || (uint64_t result = sub_10000CBC0(), (_DWORD)result))
  {
    BOOL v26 = 0LL;
    uint64_t v27 = 0LL;
    uint64_t v28 = 0LL;
    sub_100019FF0( (uint64_t)&v26,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/db.c",  676LL,  v0,  v1,  v2,  v3,  v4);
    uint64_t v6 = sub_10004FF50(v27, v28);
    sub_100034EA8( &v26,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/db.c",  678LL,  v7,  v8,  v9,  v10,  v11);
    if (v6)
    {
      int v19 = fprintf((FILE *)qword_10008BDA0, "server-duid %s;\n\n", v6);
      sub_10005CE20( v6,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/db.c",  687LL,  v20,  v21,  v22,  v23,  v24);
      if ((v19 & 0x80000000) == 0)
      {
        fflush((FILE *)qword_10008BDA0);
        return 1LL;
      }
    }

    sub_1000622D4("write_server_duid: unable to write server-duid", v12, v13, v14, v15, v16, v17, v18, v25);
    uint64_t result = 0LL;
    dword_10008BD98 = 1;
  }

  return result;
}

uint64_t sub_10000DC18(uint64_t a1)
{
  *__error() = 0;
  fprintf((FILE *)qword_10008BDA0, "\nfailover peer %s state {", *(const char **)(a1 + 40));
  int v2 = *__error();
  int v3 = v2 != 0;
  uint64_t v4 = sub_10005207C(*(void *)(a1 + 72));
  if (!v4) {
    goto LABEL_7;
  }
  uint64_t v5 = v4;
  uint64_t v6 = (FILE *)qword_10008BDA0;
  int v7 = *(_DWORD *)(a1 + 64);
  if (v7 == 1) {
    int v7 = *(_DWORD *)(a1 + 128);
  }
  uint64_t v8 = sub_100025FF8(v7);
  if (fprintf(v6, "\n  my state %s at %s", v8, v5) < 0)
  {
LABEL_7:
    if (v2) {
      int v3 = 2;
    }
    else {
      int v3 = 1;
    }
  }

  uint64_t v9 = sub_10005207C(*(void *)(a1 + 112));
  if (!v9
    || (uint64_t v10 = v9,
        uint64_t v11 = (FILE *)qword_10008BDA0,
        uint64_t v12 = sub_100025FF8(*(_DWORD *)(a1 + 104)),
        fprintf(v11, "\n  partner state %s at %s", v12, v10) < 0))
  {
    ++v3;
  }

  if (*(_DWORD *)(a1 + 240) == 1)
  {
    *__error() = 0;
    fprintf((FILE *)qword_10008BDA0, "\n  mclt %ld;", *(unsigned int *)(a1 + 160));
    if (*__error()) {
      ++v3;
    }
  }

  *__error() = 0;
  uint64_t v13 = 1LL;
  fwrite("\n}\n", 3uLL, 1uLL, (FILE *)qword_10008BDA0);
  if (*__error()) {
    int v21 = -1;
  }
  else {
    int v21 = 0;
  }
  if (v3 != v21)
  {
    sub_1000622D4( "write_failover_state: unable to write state %s",  v14,  v15,  v16,  v17,  v18,  v19,  v20,  *(void *)(a1 + 40));
    dword_10008BD98 = 1;
    return 0LL;
  }

  return v13;
}

uint64_t sub_10000DDB8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((*(_BYTE *)(a3 + 152) & 2) != 0)
  {
    ++dword_10008BE48;
    uint64_t v5 = *(void *)(a3 + 40);
    if (v5)
    {
      if (fprintf((FILE *)qword_10008BDA0, "subclass %s", *(const char **)(v5 + 48)) < 1
        || !sub_10000E030((FILE *)qword_10008BDA0, a3))
      {
        return 26LL;
      }

      int v6 = fprintf((FILE *)qword_10008BDA0, " {\n");
    }

    else
    {
      int v6 = fprintf((FILE *)qword_10008BDA0, "class %s {\n");
    }

    if (v6 >= 1)
    {
      int v7 = (*(_BYTE *)(a3 + 152) & 1) != 0
      if (v7 >= 1
        && (*(int *)(a3 + 56) < 1 || fprintf((FILE *)qword_10008BDA0, "  lease limit %d;\n", *(_DWORD *)(a3 + 56)) >= 1))
      {
        if (!*(void *)(a3 + 112)
          || fprintf((FILE *)qword_10008BDA0, "  match if ") >= 1
          && (*__error() = 0,
              sub_100057E58((FILE *)qword_10008BDA0, *(void *)(a3 + 112), 5LL, 5LL, 0LL, v8, v9, v10),
              !*__error())
          && fprintf((FILE *)qword_10008BDA0, ";\n") >= 1)
        {
          if (!*(void *)(a3 + 120)
            || (!*(_DWORD *)(a3 + 128)
              ? (int v11 = fprintf((FILE *)qword_10008BDA0, "  match "))
              : (int v11 = fprintf((FILE *)qword_10008BDA0, "  spawn ")),
                v11 >= 1
             && (*__error() = 0,
                 sub_100057E58((FILE *)qword_10008BDA0, *(void *)(a3 + 120), 5LL, 5LL, 0LL, v12, v13, v14),
                 !*__error())
             && fprintf((FILE *)qword_10008BDA0, ";\n") >= 1))
          {
            if (!*(void *)(a3 + 144)
              || (*__error() = 0,
                  sub_10003E18C(qword_10008BDA0, *(void *)(a3 + 144), 8LL, v15, v16, v17, v18, v19),
                  !*__error()))
            {
              uint64_t v20 = *(void *)(a3 + 136);
              if (!v20
                || !*(_DWORD *)(v20 + 40)
                || (*__error() = 0,
                    sub_10003E18C( qword_10008BDA0,  *(void *)(*(void *)(a3 + 136) + 48LL),  8LL,  v21,  v22,  v23,  v24,  v25),  !*__error()))
              {
              }
            }
          }
        }
      }
    }

    return 26LL;
  }

LABEL_2:
  uint64_t result = *(void *)(a3 + 80);
  if (result)
  {
    sub_10002D4E8((unsigned int *)result, (unsigned int (*)(uint64_t, uint64_t, uint64_t))sub_10000DDB8);
    return 0LL;
  }

  return result;
}

uint64_t sub_10000E030(FILE *a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a2 + 104);
  if ((_DWORD)v4)
  {
    uint64_t v5 = 0LL;
    while ((*(char *)(*(void *)(a2 + 96) + v5) & 0x80000000) == 0
         && (_DefaultRuneLocale.__runetype[*(unsigned __int8 *)(*(void *)(a2 + 96) + v5)] & 0x40000) != 0)
    {
      if (v4 == ++v5) {
        goto LABEL_9;
      }
    }
  }

  else
  {
    LODWORD(v5) = 0;
  }

  if ((_DWORD)v5 == (_DWORD)v4)
  {
LABEL_9:
    return 1LL;
  }

  if (fprintf(a1, " %2.2x", **(unsigned __int8 **)(a2 + 96)) >= 1)
  {
    if (*(_DWORD *)(a2 + 104) >= 2u)
    {
      uint64_t v13 = 1LL;
      while (fprintf(a1, ":%2.2x", *(unsigned __int8 *)(*(void *)(a2 + 96) + v13)) > 0)
      {
      }

      goto LABEL_17;
    }

    return 1LL;
  }

LABEL_17:
  sub_10006221C("Failure writing hash string: %m", v6, v7, v8, v9, v10, v11, v12, v15);
  return 0LL;
}

      uint64_t v12 = *(void *)(a1 + 88);
LABEL_18:
      uint64_t v14 = 0LL;
      *(void *)(a1 + 96) = v12;
      if ((dword_1000BD2B0 & 2) == 0) {
        goto LABEL_28;
      }
      char v15 = v10;
      if (v10 == (uint64_t *)qword_1000BD2B8)
      {
        if (qword_1000BD2C0 == a1)
        {
          uint64_t v14 = 0LL;
LABEL_28:
          char v15 = v10;
        }

        else
        {
          uint64_t v16 = *(void *)(qword_1000BD2C0 + 96);
          if (v16 <= v12) {
            uint64_t v14 = qword_1000BD2C0;
          }
          else {
            uint64_t v14 = 0LL;
          }
          if (v16 <= v12) {
            char v15 = (uint64_t *)(qword_1000BD2C0 + 32);
          }
          else {
            char v15 = v10;
          }
        }
      }

      uint64_t v17 = *v15;
      if (!v17) {
        goto LABEL_33;
      }
      break;
    default:
      sub_10006221C("Lease with bogus binding state: %d", a2, a3, a4, a5, a6, a7, a8, *(_BYTE *)(a1 + 222));
      return 0LL;
  }

  while (*(void *)(v17 + 96) < v12)
  {
    uint64_t v14 = v17;
    uint64_t v17 = *(void *)(v17 + 32);
    if (!v17) {
      goto LABEL_34;
    }
  }

void sub_10000E154()
{
  for (uint64_t i = off_100088018; i; uint64_t i = (uint64_t *)*i)
  {
    for (uint64_t j = i[2]; j; uint64_t j = *(void *)(j + 32))
    {
      if (*(_DWORD *)(j + 128))
      {
        int v2 = *(unsigned int **)(j + 80);
        if (v2) {
          sub_10002D4E8(v2, (unsigned int (*)(uint64_t, uint64_t, uint64_t))sub_10000DDB8);
        }
      }
    }
  }

uint64_t sub_10000E1BC()
{
  if (fflush((FILE *)qword_10008BDA0) == -1 || (int v7 = fileno((FILE *)qword_10008BDA0), fsync(v7) < 0))
  {
    sub_1000622D4("commit_leases: unable to commit: %m", v0, v1, v2, v3, v4, v5, v6, v9);
    return 0LL;
  }

  else
  {
    sub_100016194(0LL, v0, v1, v2, v3, v4, v5, v6);
    if (dword_10008CF9C)
    {
      if (qword_10008CE80 - qword_10008BDA8 >= 3601)
      {
        dword_10008CF9C = 0;
        qword_10008BDA8 = qword_10008CE80;
        sub_10000CBC0();
      }
    }

    return 1LL;
  }

uint64_t sub_10000E250(int a1)
{
  uint64_t result = sub_100068D4C();
  if ((_DWORD)result) {
    uint64_t result = sub_10000CBC0();
  }
  if (!a1)
  {
    qword_10008BDA0 = (uint64_t)fopen(off_100088B48[0], "a");
    if (!qword_10008BDA0) {
      sub_100061FB4("Can't open %s for append.", v3, v4, v5, v6, v7, v8, v9, (char)off_100088B48[0]);
    }
    sub_10002D2F4();
    else {
      time(&qword_10008BDA8);
    }
    return sub_10000CBC0();
  }

  return result;
}

uint64_t sub_10000E320(uint64_t a1)
{
  uint64_t result = sub_10000D5D4(a1);
  if ((_DWORD)result) {
    return sub_10000E1BC();
  }
  return result;
}

uint64_t sub_10000E340( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = 0LL;
  uint64_t v174 = 0LL;
  int v175 = 0LL;
  if (dword_10008BDD0 != 2) {
    return v8;
  }
  if (a2)
  {
    uint64_t v14 = (uint64_t *)(a2 + 112);
    *(_OWORD *)uint64_t v199 = *(_OWORD *)(a2 + 56);
    *(_DWORD *)&v199[16] = *(_DWORD *)(a2 + 72);
  }

  else
  {
    if (!a4) {
      sub_100061FB4( "Impossible condition at %s:%d.",  0LL,  a3,  0LL,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c");
    }
    uint64_t v14 = (uint64_t *)(a4 + 24);
    *(_OWORD *)&v199[4] = *(_OWORD *)(a4 + 4);
    *(_DWORD *)uint64_t v199 = 16;
  }

  int v176 = 0LL;
  uint64_t v177 = 0LL;
  size_t v178 = 0LL;
  uint64_t v179 = 0LL;
  char v195 = 0LL;
  uint64_t v196 = 0LL;
  int v194 = 0LL;
  __src = 0LL;
  size_t __n = 0LL;
  size_t v190 = 0LL;
  uint64_t v191 = 0LL;
  uint64_t v188 = 0LL;
  __s1 = 0LL;
  __s2 = 0LL;
  size_t v187 = 0LL;
  uint64_t v184 = 0LL;
  int v185 = 0LL;
  uint64_t v182 = 0LL;
  __s = 0LL;
  uint64_t v180 = 0LL;
  uint64_t v181 = 0LL;
  uint64_t v15 = sub_100040D4C(&qword_10008BF80, a6, 40LL, a4, a5, a6, a7, a8);
  if ((!v15
     || sub_100057AF8( &v174,  (unsigned int *)a1,  a2,  0LL,  *(void *)(a1 + 160),  a6,  v14,  v15,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  0x10Fu))
    && (uint64_t v21 = sub_100040D4C(&qword_10008C318, *(void *)(a1 + 160), 2LL, v16, v17, v18, v19, v20)) != 0
    && !sub_100057AF8( (_DWORD *)&v174 + 1,  (unsigned int *)a1,  a2,  0LL,  *(void *)(a1 + 160),  a6,  v14,  v21,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  0x117u)
    && sub_100040D4C(&qword_10008C318, *(void *)(a1 + 160), 7LL, v16, v17, v18, v19, v20)
    && (uint64_t v47 = sub_100040D4C(&qword_10008C318, *(void *)(a1 + 160), 8LL, v16, v17, v18, v19, v20)) != 0
    && sub_100057AA4( &v185,  (unsigned int *)a1,  a2,  0LL,  *(void *)(a1 + 160),  a6,  v14,  v47,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  0x122u))
  {
    int v45 = 0;
  }

  else
  {
    uint64_t v22 = sub_100040D4C(&qword_10008BF80, a6, 45LL, v16, v17, v18, v19, v20);
    if (v22
      && !sub_100057AF8( (_DWORD *)&v174 + 1,  (unsigned int *)a1,  a2,  0LL,  *(void *)(a1 + 160),  a6,  v14,  v22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  0x12Fu))
    {
      return 0LL;
    }

    if (a2)
    {
      if ((*(_BYTE *)(a2 + 221) & 1) != 0)
      {
        uint64_t v28 = sub_100040D4C(&qword_10008BF80, a6, 43LL, v23, v24, v25, v26, v27);
        if (!v28
          || !sub_100057AF8( (_DWORD *)&v174 + 1,  (unsigned int *)a1,  a2,  0LL,  *(void *)(a1 + 160),  a6,  v14,  v28,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  0x13Cu))
        {
          return 0LL;
        }
      }
    }

    uint64_t v29 = sub_100040D4C(&qword_10008BF80, a6, 24LL, v23, v24, v25, v26, v27);
    if (v29) {
      int v35 = sub_100057AA4( &v194,  (unsigned int *)a1,  a2,  0LL,  *(void *)(a1 + 160),  a6,  v14,  v29,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  0x147u);
    }
    else {
      int v35 = 0;
    }
    uint64_t v36 = sub_100040D4C(&qword_10008BF80, a6, 23LL, v30, v31, v32, v33, v34);
    if (v36)
    {
      int v37 = sub_100057AA4( &v191,  (unsigned int *)a1,  a2,  0LL,  *(void *)(a1 + 160),  a6,  v14,  v36,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  0x14Fu);
      int v45 = 1;
      if (v35 && v37)
      {
        if ((__n + v196) >= 0xFE)
        {
          uint64_t v46 = "ddns_update: host.domain name too long";
LABEL_58:
          sub_10006221C(v46, v38, v39, v40, v41, v42, v43, v44, v169);
          goto LABEL_59;
        }

        sub_1000345C4( &v185,  __n + v196 + 2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  348LL);
        if (v185)
        {
          __s2 = v185 + 1;
          memcpy((char *)v185 + v187 + 4, v195, v196);
          LODWORD(v187) = v187 + v196;
          *((_BYTE *)v185 + v187 + 4) = 46;
          LODWORD(v187) = v187 + 1;
          memcpy((char *)v185 + v187 + 4, __src, __n);
          LODWORD(v187) = v187 + __n;
          *((_BYTE *)v185 + v187 + 4) = 0;
          HIDWORD(v187) = 1;
        }
      }
    }

    else
    {
      int v45 = 1;
    }
  }

  if (!sub_10005939C((uint64_t)&v188, *v14, "ddns-fwd-name"))
  {
    if (sub_10005939C((uint64_t)&v188, *v14, "ddns-client-fqdn"))
    {
      uint64_t v39 = v190;
      if ((_DWORD)v190 == (_DWORD)v187 && !memcmp(__s1, __s2, v190))
      {
        uint64_t v49 = sub_100040D4C(&qword_10008BF80, a6, 41LL, v40, v41, v42, v43, v44);
        if (!v49
          || sub_100057AF8( (_DWORD *)&v174 + 1,  (unsigned int *)a1,  a2,  0LL,  *(void *)(a1 + 160),  a6,  v14,  v49,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  0x1ACu))
        {
          uint64_t v8 = 0LL;
          int v50 = 0;
LABEL_133:
          int v61 = 0;
          goto LABEL_134;
        }
      }
    }

    goto LABEL_55;
  }

  if ((_DWORD)v190 == (_DWORD)v187 && !memcmp(__s1, __s2, v190))
  {
    int v51 = sub_10005939C((uint64_t)&v179, *v14, "ddns-txt");
    if (!a3 || v51)
    {
      sub_100034EA8( &v179,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  400LL,  v52,  v53,  v54,  v55,  v56);
    }

    else
    {
      uint64_t v59 = *(_DWORD **)(a3 + 160);
      uint64_t v58 = (void **)(a3 + 160);
      uint64_t v57 = v59;
      if (v59 == v58[2])
      {
        sub_10003D510(0LL, 0LL, a2, 0LL, 0LL, 0LL, v14, v57);
        if (*v58) {
          sub_10003DC78( v58,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  392LL,  v40,  v41,  v42,  v43,  v44);
        }
        if (v58[2]) {
          sub_10003DC78( v58 + 2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  395LL,  v40,  v41,  v42,  v43,  v44);
        }
LABEL_55:
        unsigned int v48 = v187;
        if (!(_DWORD)v187)
        {
LABEL_59:
          uint64_t v8 = 0LL;
          goto LABEL_60;
        }

LABEL_56:
        if (v48 >= 0x100)
        {
          uint64_t v46 = "client provided fqdn: too long";
          goto LABEL_58;
        }

        uint64_t v97 = sub_100040D4C(&qword_10008BF80, a6, 38LL, v40, v41, v42, v43, v44);
        if (v97
          && sub_100057AA4( &v176,  (unsigned int *)a1,  a2,  0LL,  *(void *)(a1 + 160),  a6,  v14,  v97,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  0x1C3u))
        {
          if ((_DWORD)v178 == 4) {
            uint64_t v103 = sub_100060B50((unsigned int *)v177);
          }
          else {
            uint64_t v103 = 3600LL;
          }
          uint64_t v173 = v103;
          sub_100034EA8( &v176,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  454LL,  v98,  v99,  v100,  v101,  v102);
        }

        else
        {
          uint64_t v173 = 3600LL;
        }

        uint64_t v104 = sub_100040D4C(&qword_10008BF80, a6, 25LL, v98, v99, v100, v101, v102);
        if (v104) {
          int v112 = sub_100057AA4( &v176,  (unsigned int *)a1,  a2,  0LL,  *(void *)(a1 + 160),  a6,  v14,  v104,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  0x1D1u);
        }
        else {
          int v112 = 0;
        }
        int v113 = *(_DWORD *)v199;
        if (*(_DWORD *)v199 == 16)
        {
          int v116 = 74;
          int v112 = 1;
        }

        else
        {
          if (*(_DWORD *)v199 != 4) {
            sub_100061FB4("invalid address length %d", v105, v106, v107, v108, v109, v110, v111, v199[0]);
          }
          int v116 = snprintf((char *)&__str, 0x11uLL, "%u.%u.%u.%u.", v199[7], v199[6], v199[5], v199[4]) + 1;
          if (v112)
          {
            v116 += v178;
            if (v116 >= 256)
            {
              sub_10006221C( "ddns_update: Calculated rev domain name too long.",  v114,  v115,  v107,  v108,  v109,  v110,  v111,  v170);
              sub_100034EA8( &v176,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  489LL,  v117,  v118,  v119,  v120,  v121);
              int v112 = 0;
            }
          }
        }

        uint64_t v122 = sub_100040D4C(&qword_10008BF80, a6, 51LL, v107, v108, v109, v110, v111);
        if (v122) {
          BOOL v125 = sub_100057AF8( (_DWORD *)&v174 + 1,  (unsigned int *)a1,  a2,  0LL,  *(void *)(a1 + 160),  a6,  v14,  v122,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  0x204u) != 0;
        }
        else {
          BOOL v125 = 1;
        }
        BOOL v172 = v125;
        if (v112)
        {
          sub_1000345C4(&v182, v116, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c", 521LL);
          if (v182)
          {
            uint64_t v127 = (char *)(v182 + 1);
            __s = (char *)(v182 + 1);
            if (v113 == 16)
            {
              int v171 = v45;
              uint64_t v128 = 0LL;
              uint64_t v129 = &v199[19];
              do
              {
                unsigned int v130 = *v129--;
                sprintf(&v127[v128], "%x.%x.", v130 & 0xF, v130 >> 4);
                v128 += 4LL;
              }

              while ((_DWORD)v128 != 64);
              strcat(&v127[v128], "ip6.arpa.");
              LODWORD(v184) = strlen(__s);
              int v45 = v171;
            }

            else
            {
              LODWORD(v184) = sprintf(v127, "%u.%u.%u.%u.", v199[7], v199[6], v199[5], v199[4]);
              memcpy((char *)v182 + v184 + 4, v177, v178);
              LODWORD(v184) = v184 + v178;
              *((_BYTE *)v182 + v184 + 4) = 0;
            }

            HIDWORD(v184) = 1;
          }

          if (v177) {
            sub_100034EA8( &v176,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  559LL,  v40,  v41,  v42,  v43,  v44);
          }
        }

        if (v45)
        {
          uint64_t v179 = 0LL;
          uint64_t v180 = 0LL;
          uint64_t v181 = 0LL;
          if (a4)
          {
            int v131 = v45;
            uint64_t v132 = *(void *)(a4 + 56);
            uint64_t v133 = *(unsigned int **)(v132 + 16);
            unsigned int v134 = *(_DWORD *)(v132 + 24);
            unsigned int v135 = 2;
          }

          else
          {
            if (!a2) {
              sub_100061FB4( "Impossible condition at %s:%d.",  v123,  v124,  v40,  v41,  v42,  v43,  v44,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c");
            }
            uint64_t v133 = *(unsigned int **)(a2 + 184);
            if (v133 && (unsigned int v134 = *(unsigned __int16 *)(a2 + 192), *(_WORD *)(a2 + 192)))
            {
              int v131 = v45;
              unsigned int v135 = 61;
            }

            else
            {
              int v131 = v45;
              uint64_t v133 = (unsigned int *)(a2 + 204);
              unsigned int v134 = *(unsigned __int8 *)(a2 + 203);
              unsigned int v135 = 0;
            }
          }

          uint64_t v8 = sub_10003CB08((uint64_t *)&v179, v135, v133, v134);
          if (!(_DWORD)v8) {
            goto LABEL_60;
          }
        }

        else
        {
          int v131 = 0;
          uint64_t v8 = 0LL;
        }

        if (!dword_10008C728)
        {
          sub_10006C408((uint64_t)qword_10008C738);
          dword_10008C728 = 1;
          qword_10008C738[0] = 0x100000001LL;
        }

        int v50 = 0;
        if ((_DWORD)v187)
        {
          int v45 = v131;
          BOOL v136 = v172;
          if ((_DWORD)v181)
          {
            uint64_t v137 = sub_100040D4C(&qword_10008BF80, a6, 48LL, v40, v41, v42, v43, v44);
            if (v137) {
              BOOL v140 = sub_100057AF8( (_DWORD *)&v174 + 1,  (unsigned int *)a1,  a2,  0LL,  *(void *)(a1 + 160),  a6,  v14,  v137,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  0x260u) != 0;
            }
            else {
              BOOL v140 = 1LL;
            }
            __int128 __str = *(_OWORD *)v199;
            int v198 = *(_DWORD *)&v199[16];
            int v50 = sub_10003CC64((uint64_t)&v185, &__str, (uint64_t)&v179, v173, 0LL, v140, v138, v139);
          }
        }

        else
        {
          int v45 = v131;
          BOOL v136 = v172;
        }

        char v141 = !v136;
        if (v50) {
          char v141 = 1;
        }
        int v61 = v50;
        if ((v141 & 1) == 0)
        {
          int v61 = 0;
          if ((_DWORD)v187)
          {
            if ((_DWORD)v184) {
              int v61 = sub_10000F6E0((uint64_t)&v185, (uint64_t)&v182, v173);
            }
          }
        }

        if (v61) {
          int v142 = v45;
        }
        else {
          int v142 = 1;
        }
        if (!v50 && v142)
        {
          uint64_t v143 = v45 ? "ddns-fwd-name" : "ddns-client-fqdn";
          sub_100059318(v14, v143, (uint64_t)&v185, v40, v41, v42, v43, v44);
          if (v45) {
            sub_100059318(v14, "ddns-txt", (uint64_t)&v179, v40, v41, v42, v43, v44);
          }
        }

        char v144 = !v136;
        if (v61) {
          char v144 = 1;
        }
        if ((v144 & 1) == 0)
        {
          sub_100059318(v14, "ddns-rev-name", (uint64_t)&v182, v40, v41, v42, v43, v44);
          goto LABEL_133;
        }

        if (!*(_WORD *)(a2 + 192)
          || v623
          && !v623[24]
          && (uint64_t v58 = (int *)sub_100040D4C(&qword_10008BF80, *(void *)(v23 + 32), 28LL, v38, v39, v40, v41, v42),
              (v619 = (uint64_t *)v58) != 0LL)
          && !sub_100057AF8( &v616,  (unsigned int *)v12,  a2,  0LL,  *(void *)(v12 + 160),  *(void *)(v23 + 32),  (uint64_t *)(a2 + 112),  (uint64_t)v58,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x68Eu))
        {
LABEL_61:
          v620 = 0LL;
          sub_10002CE28( &v620,  (const char *)(a2 + 204),  *(unsigned __int8 *)(a2 + 203),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1683LL,  v40,  v41,  v42);
          uint64_t v59 = v620;
          if (v620)
          {
            while (v59 != (_DWORD *)a2 || *(void *)(a2 + 48))
            {
              v624 = 0LL;
              do
              {
                uint64_t v60 = *((void *)v59 + 6);
                if (v60)
                {
                  sub_100033898(&v624, v60, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 1693LL);
                  uint64_t v59 = v620;
                }

                if (v59 != (_DWORD *)a2)
                {
                  int v61 = *((unsigned __int8 *)v59 + 222);
                  uint64_t v52 = v61 > 7;
                  uint64_t v62 = (1 << v61) & 0xDA;
                  if (v52 || v62 == 0) {
                    break;
                  }
                }

                sub_10003389C(&v620, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 1701LL);
                if (v624)
                {
                  sub_100033898(&v620, v624, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 1703LL);
                  sub_10003389C(&v624, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 1704LL);
                }

                uint64_t v59 = v620;
              }

              while (v620);
              if (v624)
              {
                sub_10003389C(&v624, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 1708LL);
                uint64_t v59 = v620;
              }

              if (v59)
              {
                sub_10002CAA0((uint64_t)v59, v12);
                sub_10003389C(&v620, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 1711LL);
                v620 = 0LL;
                sub_10002CE28( &v620,  (const char *)(a2 + 204),  *(unsigned __int8 *)(a2 + 203),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1683LL,  v64,  v65,  v66);
                uint64_t v59 = v620;
                if (v620) {
                  continue;
                }
              }

              goto LABEL_81;
            }

            sub_10003389C(&v620, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 1687LL);
          }
        }
      }
    }
  }

    uint64_t v102 = "dhcpv6_leasequery: no memory for option state.";
    goto LABEL_57;
  }

  uint64_t v101 = "OPTION_LQ_QUERY too short.";
LABEL_22:
  if (!sub_100019AE8(8u, v101))
  {
    uint64_t v102 = "dhcpv6_leasequery: unable to set MalformedQuery status code.";
LABEL_57:
    uint64_t result = sub_10006221C(v102, v78, v79, v80, v81, v82, v36, v37, v149);
    goto LABEL_33;
  }

  if ((_DWORD)v4 != 45 && (v4 - 48) > 9)
  {
    if ((_DefaultRuneLocale.__runetype[v4] & 0x100) != 0)
    {
      *(_BYTE *)(a1 + 244) = v4;
      *(_DWORD *)a1 = v2;
      *(_DWORD *)(a1 + 4) = v3;
      uint64_t v23 = 264LL;
      uint64_t v24 = 245LL;
      while (1)
      {
        uint64_t v25 = sub_1000374BC(a1);
        if (v25 > 0x7F) {
          break;
        }
        uint64_t v32 = &_DefaultRuneLocale.__magic[4 * v25];
        if (v25 != 45 && v25 != 95 && (*((_DWORD *)v32 + 15) & 0x500) == 0)
        {
          uint64_t v33 = v24 - 244;
          goto LABEL_120;
        }

        if ((*((_DWORD *)v32 + 15) & 0x10000) != 0) {
          uint64_t v23 = v23;
        }
        else {
          uint64_t v23 = 265LL;
        }
        *(_BYTE *)(a1 + v24++) = v25;
        if (v24 == 1744)
        {
          sub_100046D6C(a1, "token larger than internal buffer", v26, v27, v28, v29, v30, v31, v53);
          uint64_t v33 = 1499;
          goto LABEL_121;
        }
      }

      uint64_t v33 = v24 - 244;
      if (v25 == -1) {
        goto LABEL_121;
      }
LABEL_120:
      --*(void *)(a1 + 1760);
      *(_DWORD *)(a1 + 228) = 1;
LABEL_121:
      *(_BYTE *)(a1 + v33 + 244) = 0;
      *(_DWORD *)(a1 + 240) = v33;
      *(void *)(a1 + 232) = a1 + 244;
      return sub_100037580((const char *)(a1 + 244), v23);
    }

LABEL_60:
  sub_100034EA8( &v176,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  790LL,  v40,  v41,  v42,  v43,  v44);
  sub_100034EA8( &v194,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  791LL,  v62,  v63,  v64,  v65,  v66);
  sub_100034EA8( &v191,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  792LL,  v67,  v68,  v69,  v70,  v71);
  sub_100034EA8( &v188,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  793LL,  v72,  v73,  v74,  v75,  v76);
  sub_100034EA8( &v185,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  794LL,  v77,  v78,  v79,  v80,  v81);
  sub_100034EA8( &v182,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  795LL,  v82,  v83,  v84,  v85,  v86);
  sub_100034EA8( &v179,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  796LL,  v87,  v88,  v89,  v90,  v91);
  if (v175) {
    sub_10003462C( &v175,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  798LL,  v92,  v93,  v94,  v95,  v96);
  }
  return v8;
}

  dword_10008D158 += sub_1000425E0( (uint64_t)&xmmword_10008D0E0 + dword_10008D158 + 124,  (0x10000 - dword_10008D158),  qword_10008D150,  (unsigned int *)xmmword_10008D0E0,  dword_1000825B8,  0LL,  v36,  v37);
  *(_DWORD *)(a1 + 16) = dword_10008D158;
  *(void *)a1 = 0LL;
  if (!sub_1000345C4( (void *)a1,  dword_10008D158,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  1180LL)) {
    sub_100061FB4("dhcpv6_leasequery: no memory to store Reply.", v142, v143, v144, v145, v146, v147, v148, v149);
  }
  uint64_t result = (uint64_t)memcpy((void *)(*(void *)a1 + 4LL), byte_10008D15C, dword_10008D158);
  *(void *)(a1 + 8) = *(void *)a1 + 4LL;
LABEL_33:
  if ((void)xmmword_10008D0E0) {
    uint64_t result = sub_100034B48( (uint64_t *)&xmmword_10008D0E0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  1189LL,  v33,  v34,  v35,  v36,  v37);
  }
  if (qword_10008D0F0) {
    uint64_t result = (uint64_t)sub_100034EA8( (_DWORD **)&xmmword_10008D0E0 + 1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  1191LL,  v33,  v34,  v35,  v36,  v37);
  }
  if (*((void *)&xmmword_10008D100 + 1)) {
    uint64_t result = (uint64_t)sub_100034EA8( (_DWORD **)&xmmword_10008D100,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  1193LL,  v33,  v34,  v35,  v36,  v37);
  }
  if ((void)xmmword_10008D120) {
    uint64_t result = (uint64_t)sub_100034EA8( &qword_10008D118,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  1195LL,  v33,  v34,  v35,  v36,  v37);
  }
  if (qword_10008D148) {
    uint64_t result = sub_100034894( &qword_10008D148,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  1197LL,  v33,  v34,  v35,  v36,  v37);
  }
  if (qword_10008D150) {
    return sub_100034894( &qword_10008D150,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  1199LL,  v33,  v34,  v35,  v36,  v37);
  }
  return result;
}

        if (v10 == 254)
        {
LABEL_42:
          uint64_t v32 = v8;
          uint64_t v33 = 5;
LABEL_53:
          sub_1000258A8(v32, v33);
        }

      uint64_t result = 0LL;
      if (v54 != 59 && (*a3)[1] != 111) {
        goto LABEL_46;
      }
      return result;
    default:
      switch(**a3)
      {
        case 'B':
          goto LABEL_15;
        case 'C':
        case 'F':
        case 'G':
        case 'H':
        case 'J':
        case 'K':
        case 'M':
          goto LABEL_36;
        case 'D':
          uint64_t v57 = *((unsigned __int8 *)v12 + 1);
          uint64_t v56 = v12 + 1;
          if (v57 == 99) {
            *a3 = v56;
          }
          uint64_t v81 = (_DWORD *)sub_10004F3A8();
          if (v81) {
            goto LABEL_23;
          }
          if ((*a3)[1] == 111) {
            return 0LL;
          }
          goto LABEL_46;
        case 'E':
          uint64_t v58 = strchr(*a3, 46);
          if (v58)
          {
            *a3 = v58;
            goto LABEL_67;
          }

          uint64_t v40 = "malformed encapsulation format (bug!)";
          goto LABEL_37;
        case 'I':
          if ((_DWORD)a6)
          {
            uint64_t result = sub_100047324((uint64_t *)&v81, a2, a5);
            if ((_DWORD)result) {
              goto LABEL_23;
            }
            return result;
          }

          LODWORD(v82[0]) = 4;
          uint64_t result = (uint64_t)sub_100047540(a2, (_DWORD *)v82 + 1, (unsigned int *)v82, 46, 10LL, 8LL);
          if (!result) {
            return result;
          }
          uint64_t v31 = (int)v82[0];
          uint64_t v30 = (int *)v82 + 1;
          uint64_t v32 = 5224LL;
          goto LABEL_22;
        case 'L':
          goto LABEL_17;
        case 'N':
          uint64_t v64 = strchr(*a3, 46);
          if (!v64)
          {
            sub_100046D6C((uint64_t)a2, "malformed %s (bug!)", v65, v66, v67, v68, v69, v70, (char)"enumeration format");
            goto LABEL_46;
          }

          *a3 = v64;
          uint64_t v71 = sub_100036D00(v82, 0LL, (uint64_t)a2);
          if (v71 < 0x100 || v71 - 262 < 2 || v71 == 607)
          {
            uint64_t v40 = "identifier expected";
            goto LABEL_37;
          }

          uint64_t v77 = sub_100046BE8(v12 + 1, *(_DWORD *)a3 - ((int)v12 + 1), &v80, v82[0]);
          if (v77)
          {
            uint64_t v30 = (int *)(v77 + 1);
            uint64_t v31 = v80;
            uint64_t v32 = 5212LL;
            goto LABEL_22;
          }

          uint64_t v40 = "unknown value";
          break;
        default:
          if (v13 != 54) {
            goto LABEL_36;
          }
          uint64_t result = sub_100047820(a2, v82, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8);
          if (!(_DWORD)result) {
            return result;
          }
          uint64_t v30 = (int *)v82 + 1;
          uint64_t v31 = (int)v82[0];
          uint64_t v32 = 5233LL;
          goto LABEL_22;
      }

      goto LABEL_37;
  }

void *sub_10000F3C0(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v2 = (uint64_t *)(a1 + 112);
    int v3 = *(_DWORD *)(a1 + 56);
    uint64_t v4 = (__int128 *)(a1 + 60);
    goto LABEL_5;
  }

  if (a2)
  {
    uint64_t v2 = (uint64_t *)(a2 + 24);
    uint64_t v4 = (__int128 *)(a2 + 4);
    int v3 = 16;
LABEL_5:
    __int128 v61 = *v4;
    uint64_t v5 = *v2;
    if (*v2) {
      BOOL v6 = dword_10008BDD0 == 2;
    }
    else {
      BOOL v6 = 0;
    }
    if (!v6) {
      return 0LL;
    }
    v57[0] = 0LL;
    v57[1] = 0LL;
    uint64_t v58 = 0LL;
    uint64_t v55 = 0LL;
    uint64_t v56 = 0LL;
    uint64_t v54 = 0LL;
    memset(v53, 0, sizeof(v53));
    if (!dword_10008C728)
    {
      sub_10006C408((uint64_t)qword_10008C738);
      dword_10008C728 = 1;
      qword_10008C738[0] = 0x100000001LL;
      uint64_t v5 = *v2;
    }

    int v8 = sub_10005939C((uint64_t)v57, v5, "ddns-fwd-name");
    uint64_t v9 = *v2;
    if (v8)
    {
      if (sub_10005939C((uint64_t)v53, v9, "ddns-txt"))
      {
        if ((_DWORD)v58)
        {
          int v59 = v3;
          __int128 v60 = v61;
          if (sub_10003D0C0((uint64_t)v57, &v59, (uint64_t)v53, v10, v11, v12, v13, v14))
          {
            uint64_t v7 = 0LL;
LABEL_40:
            sub_100034EA8( v57,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  898LL,  v15,  v16,  v17,  v18,  v19);
            sub_100034EA8( &v54,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  899LL,  v42,  v43,  v44,  v45,  v46);
            sub_100034EA8( v53,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/ddns.c",  900LL,  v47,  v48,  v49,  v50,  v51);
            return v7;
          }
        }

        sub_10005945C(*v2, "ddns-fwd-name");
        sub_10005945C(*v2, "ddns-txt");
      }

      uint64_t v20 = 1LL;
      BOOL v21 = 1;
    }

    else
    {
      uint64_t v20 = 0LL;
      BOOL v21 = sub_10005939C((uint64_t)v57, v9, "ddns-client-fqdn") == 0;
    }

    if (sub_10005939C((uint64_t)&v54, *v2, "ddns-rev-name"))
    {
      uint64_t v22 = sub_10006E324(2, v55, 1, 12, 0);
      uint64_t v7 = v22;
      if (!v22) {
        goto LABEL_40;
      }
      v22[8] = 0LL;
      v22[10] = 0LL;
      *uint64_t v22 = 0LL;
      v22[1] = 0LL;
      unsigned int v23 = sub_10006F8C0((unsigned int *)qword_10008C738, (uint64_t)v22);
      unsigned int v31 = v23;
      if (v23 != 57 && v23 != 52)
      {
        if (v23)
        {
          char v32 = v56;
          sub_100067900(v23);
          sub_10006221C("can't remove reverse map on %.*s: %s", v33, v34, v35, v36, v37, v38, v39, v32);
        }

        else
        {
          sub_1000622D4("removed reverse map on %.*s", v24, v25, v26, v27, v28, v29, v30, v56);
        }
      }

      do
      {
        uint64_t v40 = (void *)v7[1];
        if (v40) {
          *uint64_t v40 = *v7;
        }
        if (*v7)
        {
          *(void *)(*v7 + 8LL) = v40;
          uint64_t v40 = v7;
        }

        *uint64_t v7 = -1LL;
        v7[1] = -1LL;
        sub_10006E3A4(v7);
        uint64_t v7 = v40;
      }

      while (v40);
      if (v31 > 0x39 || ((1LL << v31) & 0x210000000000001LL) == 0) {
        goto LABEL_40;
      }
      sub_10005945C(*v2, "ddns-rev-name");
      if (!v21)
      {
        uint64_t v41 = "ddns-client-fqdn";
        goto LABEL_38;
      }

      if (!(_DWORD)v58)
      {
        uint64_t v41 = "ddns-text";
LABEL_38:
        sub_10005945C(*v2, v41);
      }
    }

    uint64_t v7 = (void *)v20;
    goto LABEL_40;
  }

  return 0LL;
}

uint64_t sub_10000F6E0(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = 1LL;
  uint64_t v7 = sub_10006E324(2, *(const char **)(a2 + 8), 1, 12, 0);
  if (v7)
  {
    int v8 = v7;
    v7[8] = 0LL;
    v7[10] = 0LL;
    *uint64_t v7 = 0LL;
    v7[1] = 0LL;
    uint64_t v9 = sub_10006E324(2, *(const char **)(a2 + 8), 1, 12, a3);
    if (v9)
    {
      v9[8] = *(void *)(a1 + 8);
      *((_DWORD *)v9 + 20) = *(_DWORD *)(a1 + 16);
      *((_DWORD *)v9 + 21) = 1;
      v8[1] = v9;
      *uint64_t v9 = v8;
      v9[1] = 0LL;
      uint64_t v10 = sub_10006F8C0((unsigned int *)qword_10008C738, (uint64_t)v8);
      uint64_t v6 = v10;
      int v18 = *(_DWORD *)(a2 + 16);
      if ((_DWORD)v10)
      {
        sub_100067900(v10);
        sub_10006221C("unable to add reverse map from %.*s to %.*s: %s", v19, v20, v21, v22, v23, v24, v25, v18);
      }

      else
      {
        sub_1000622D4("added reverse map from %.*s to %.*s", v11, v12, v13, v14, v15, v16, v17, v18);
      }
    }

    do
    {
      uint64_t v26 = (void *)v8[1];
      if (v26) {
        void *v26 = *v8;
      }
      if (*v8)
      {
        *(void *)(*v8 + 8LL) = v26;
        uint64_t v26 = v8;
      }

      *int v8 = -1LL;
      v8[1] = -1LL;
      sub_10006E3A4(v8);
      int v8 = v26;
    }

    while (v26);
  }

  return v6;
}

uint64_t sub_10000F81C( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v33 = 0LL;
  BOOL v9 = sub_10000FBE8((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
  int v17 = *((_DWORD *)a1 + 4);
  if (v9)
  {
    if (v17 != 3) {
      goto LABEL_12;
    }
  }

  else if (v17 != 3)
  {
    if (v17 != 8 && v17 != 10)
    {
LABEL_18:
      if ((v17 - 1) > 0xC)
      {
        uint64_t v23 = v34;
        __sprintf_chk(v34, 0, 0x20uLL, "type %d", v17);
      }

      else
      {
        uint64_t v23 = off_1000844C8[v17 - 1];
      }

      uint64_t v28 = *a1;
      if (*(_BYTE *)(*a1 + 1))
      {
        sub_1000501FC(*(unsigned __int8 *)(*a1 + 1), *(unsigned __int8 *)(v28 + 2), (unsigned __int8 *)(v28 + 28));
        uint64_t v28 = *a1;
      }

      v29.s_addr = *(_DWORD *)(v28 + 24);
      if (v29.s_addr) {
        inet_ntoa(v29);
      }
      uint64_t result = sub_1000622D4("%s from %s via %s: %s", v10, v11, v12, v13, v14, v15, v16, (char)v23);
      goto LABEL_42;
    }

    goto LABEL_12;
  }

  int v19 = *(_DWORD *)(*a1 + 12);
  if (v19)
  {
    if (!*(_DWORD *)(*a1 + 24))
    {
      uint64_t v24 = a1[20];
      if (*(_DWORD *)(v24 + 4) <= dword_10008BF78 || !*(void *)(v24 + 8LL * dword_10008BF78 + 16))
      {
        LODWORD(v35) = 4;
        HIDWORD(v35) = v19;
        if (sub_10002A978( &v33,  (const char *)&v35,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  149LL,  v13,  v14,  v15,  v16))
        {
          uint64_t v25 = (_DWORD *)*((void *)v33 + 19);
          if (v25)
          {
            if (*((void *)v33 + 11) >= (uint64_t)xmmword_10008CE80)
            {
              if (*((_WORD *)v33 + 96))
              {
                uint64_t v26 = sub_100040D4C(&qword_10008C168, a1[20], 61LL, v12, v13, v14, v15, v16);
                if (!v26) {
                  goto LABEL_12;
                }
                uint64_t v35 = 0LL;
                uint64_t v36 = 0LL;
                uint64_t v37 = 0LL;
                if (!sub_100057AA4( &v35,  (unsigned int *)a1,  0LL,  0LL,  a1[20],  0LL,  &qword_10008C730,  v26,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0xAFu)) {
                  goto LABEL_12;
                }
                size_t v27 = *((unsigned __int16 *)v33 + 96);
                if ((_DWORD)v37 != (_DWORD)v27 || memcmp(*((const void **)v33 + 23), v36, v27))
                {
                  sub_100034EA8( &v35,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  179LL,  v12,  v13,  v14,  v15,  v16);
                  goto LABEL_12;
                }

                sub_100034EA8( &v35,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  182LL,  v12,  v13,  v14,  v15,  v16);
                uint64_t v25 = (_DWORD *)*((void *)v33 + 19);
              }

              else
              {
                uint64_t v30 = *a1;
                size_t v31 = *(unsigned __int8 *)(v30 + 2);
                if (*((unsigned __int8 *)v33 + 203) - 1 != (_DWORD)v31
                  || memcmp((char *)v33 + 205, (const void *)(v30 + 28), v31))
                {
                  goto LABEL_12;
                }
              }

              sub_100033F18( (void *)(a1[20] + 8LL * dword_10008BF78 + 16),  v25,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  197LL,  v13,  v14,  v15,  v16);
              uint64_t v32 = a1[20];
              if (*(_DWORD *)(v32 + 4) <= dword_10008BF78) {
                *(_DWORD *)(v32 + 4) = dword_10008BF78 + 1;
              }
              *((_DWORD *)a1 + 56) = 1;
            }
          }
        }
      }
    }
  }

LABEL_12:
  uint64_t v20 = sub_100040D4C(&qword_10008C168, a1[20], 12LL, v12, v13, v14, v15, v16);
  if (v20 && !*(void *)(v20 + 16)) {
    uint64_t v21 = *(_DWORD *)(v20 + 56) & 1;
  }
  else {
    uint64_t v21 = 0LL;
  }
  uint64_t result = sub_100003428((uint64_t)a1);
  int v17 = *((_DWORD *)a1 + 4);
  switch(v17)
  {
    case 1:
      uint64_t result = sub_10000FD70(a1, v21);
      break;
    case 2:
    case 5:
    case 6:
    case 11:
    case 12:
    case 13:
      break;
    case 3:
      uint64_t result = sub_1000100EC(a1, v21, (uint64_t)v33, v12, v13, v14, v15, v16);
      break;
    case 4:
      uint64_t result = (uint64_t)sub_100010AE4((uint64_t)a1, v10, v11, v12, v13, v14, v15, v16);
      break;
    case 7:
      uint64_t result = sub_1000106D8(a1, v10, v11, v12, v13, v14, v15, v16);
      break;
    case 8:
      uint64_t result = sub_100010EBC((uint64_t)a1, v10, v11, v12, v13, v14, v15, v16);
      break;
    case 10:
      uint64_t result = sub_1000188A8((uint64_t)a1);
      break;
    default:
      goto LABEL_18;
  }

  if (*(_DWORD *)(a2 + 16)) {
    sub_100034EA8( (_DWORD **)a2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  660LL,  v31,  v32,  v33,  v34,  v35);
  }
  return 0LL;
}

  uint64_t v22 = *(_DWORD **)(a2 + 112);
  uint64_t v23 = v33;
  if (v22)
  {
    sub_100033F18( (void *)v33 + 14,  v22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1607LL,  v8,  v9,  v10,  v11);
    uint64_t v23 = v33;
  }

  uint64_t v24 = *(_DWORD **)(a2 + 152);
  if (v24)
  {
    sub_100033F18( (void *)v23 + 19,  v24,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1610LL,  v8,  v9,  v10,  v11);
    uint64_t v23 = v33;
  }

  sub_100033920((void *)v23 + 15, *(void *)(a2 + 120));
  sub_1000235CC(v33 + 128, *(void *)(a2 + 128), a3, a4);
  sub_1000338FC((void *)v33 + 17, *(void *)(a2 + 136));
  sub_1000338BC(v33 + 144, *(void *)(a2 + 144), a3, a4);
  in_addr v29 = v33;
  uint64_t v30 = *(_OWORD *)(a2 + 203);
  *(_WORD *)(v33 + 219) = *(_WORD *)(a2 + 219);
  *(_OWORD *)(v29 + 203) = v30;
  if (*(void *)(a2 + 160))
  {
    sub_100033F18((void *)v29 + 20, *(_DWORD **)(a2 + 160), a3, a4, v25, v26, v27, v28);
    in_addr v29 = v33;
  }

  if (*(void *)(a2 + 168))
  {
    sub_100033F18((void *)v29 + 21, *(_DWORD **)(a2 + 168), a3, a4, v25, v26, v27, v28);
    in_addr v29 = v33;
  }

  if (*(void *)(a2 + 176))
  {
    sub_100033F18((void *)v29 + 22, *(_DWORD **)(a2 + 176), a3, a4, v25, v26, v27, v28);
    in_addr v29 = v33;
  }

  *(_WORD *)(v29 + 221) = *(_WORD *)(a2 + 221);
  *((_OWORD *)v29 + 15) = *(_OWORD *)(a2 + 240);
  *((_OWORD *)v29 + 16) = *(_OWORD *)(a2 + 256);
  v29[223] = *(_BYTE *)(a2 + 223);
  size_t v31 = sub_100033898(a1, v29, a3, a4);
  sub_10003389C((_DWORD **)&v33, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 1637LL);
  return v31 == 0;
}

  if (*(void *)(a1 + 32)) {
    sub_10005CFEC( (_DWORD **)(a1 + 32),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/discover.c",  1728LL);
  }
  if (qword_10008C0A0)
  {
    sub_10005CFB8((void *)(a1 + 32), qword_10008C0A0);
    sub_10005CFEC( (_DWORD **)&qword_10008C0A0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/discover.c",  1740LL);
  }

  sub_10005CFB8(&qword_10008C0A0, a1);
  if (off_10008C088) {
    off_10008C088(a1);
  }
  sub_100060FC8(a1);
  if (dword_100089B0C == 2)
  {
    sub_100035238(a1);
    sub_10003547C(a1);
  }

  else
  {
    sub_1000526E8(a1, v9, v10, v11, v12, v13, v14, v15);
  }

  return 0LL;
}

  while (v17)
  {
    in_addr v29 = *(_DWORD *)(v17 + 16);
    int v17 = *(void *)(v17 + 8);
    if (v29 == 14)
    {
      uint64_t v30 = a1;
      size_t v31 = (_DWORD *)v17;
      uint64_t v32 = 1070LL;
      goto LABEL_15;
    }
  }

  return 0LL;
}

        in_addr v29 = *(_DWORD *)(a8 + 100);
        if (v29 == 4)
        {
          sub_100060B6C((_DWORD *)(*a9 + *((int *)a9 + 3)), __n);
          uint64_t v33 = *((_DWORD *)a9 + 3) + 4;
        }

        else
        {
          if (v29 != 2)
          {
            if (v29 == 1)
            {
              uint64_t v30 = __n;
              size_t v31 = *a9;
              uint64_t v32 = *((int *)a9 + 3);
              *((_DWORD *)a9 + 3) = v32 + 1;
              *(_BYTE *)(v31 + v32) = v30;
            }

            goto LABEL_19;
          }

          sub_100060B78((_WORD *)(*a9 + *((int *)a9 + 3)), __n);
          uint64_t v33 = *((_DWORD *)a9 + 3) + 2;
        }

        *((_DWORD *)a9 + 3) = v33;
LABEL_19:
        memcpy((void *)(*a9 + *((int *)a9 + 3)), __src, __n);
        *((_DWORD *)a9 + 3) += __n;
        return sub_100034EA8( &v34,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  901LL,  v20,  v21,  v22,  v23,  v24);
      }

      sub_100060B78((_WORD *)(*a9 + v19), *(_DWORD *)(*(void *)(a1 + 24) + 24LL));
      uint64_t v28 = *((_DWORD *)a9 + 3) + 2;
    }

    *((_DWORD *)a9 + 3) = v28;
    goto LABEL_12;
  }

  sub_10006238C( "No space for option %d in VSIO space %s.",  v11,  v12,  v13,  v14,  v15,  v16,  v17,  *(_DWORD *)(*(void *)(a1 + 24) + 24LL));
  return sub_100034EA8( &v34,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  901LL,  v20,  v21,  v22,  v23,  v24);
}

    sub_10005CFEC((_DWORD **)v23, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/protocol.c", v12);
  }

  return v8;
}

  uint64_t result = 0LL;
  *(_WORD *)&a2[v8] = 46;
  return result;
}

  uint64_t v10 = *a2;
  if (v10) {
    uint64_t v11 = a4 < 1;
  }
  else {
    uint64_t v11 = 1;
  }
  if (!v11)
  {
    do
    {
      if (sub_10006ACC8(*(const char **)(v10 + 16), a1) != 1)
      {
        uint64_t v12 = *(void *)(v10 + 24);
        if (v12)
        {
          uint64_t v13 = 0LL;
          while (a4 != (_DWORD)v13)
          {
            *(_DWORD *)(a3 + 4 * v13) = *(_DWORD *)(v12 + 16);
            uint64_t v12 = *(void *)(v12 + 8);
            ++v13;
            if (!v12) {
              goto LABEL_23;
            }
          }
        }

        LODWORD(v13) = 0;
LABEL_23:
        a3 += 4LL * (int)v13;
        a4 -= v13;
        int v8 = (v13 + v8);
      }

      uint64_t v10 = *(void *)(v10 + 8);
      if (v10) {
        uint64_t v14 = a4 <= 0;
      }
      else {
        uint64_t v14 = 1;
      }
    }

    while (!v14);
  }

  return v8;
}

LABEL_42:
  if (v33) {
    return sub_10003389C(&v33, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 258LL);
  }
  return result;
}

BOOL sub_10000FBE8( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v26 = 0LL;
  uint64_t v13 = sub_100040D4C(&qword_10008BEF0, *(void *)(a1 + 160), 5LL, a4, a5, a6, a7, a8);
  if (v13 || (uint64_t v13 = sub_100040D4C(&qword_10008C168, *(void *)(a1 + 160), 118LL, v9, v10, v11, v12, 0LL)) != 0)
  {
    size_t v27 = 0LL;
    uint64_t v28 = 0LL;
    uint64_t v29 = 0LL;
    if (sub_100057AA4( &v27,  (unsigned int *)a1,  0LL,  0LL,  *(void *)(a1 + 160),  0LL,  &qword_10008C730,  v13,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x1070u)) {
      BOOL v22 = (_DWORD)v29 == 4;
    }
    else {
      BOOL v22 = 0;
    }
    if (!v22) {
      return 0LL;
    }
    int v24 = *v28;
    sub_100034EA8( &v27,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  4216LL,  v17,  v18,  v19,  v20,  v21);
  }

  else
  {
    int v24 = *(_DWORD *)(*(void *)a1 + 24LL);
    if (!v24)
    {
      uint64_t v25 = *(void *)(*(void *)(a1 + 104) + 40LL);
      if (!v25) {
        return 0LL;
      }
      sub_1000235CC(a1 + 152, v25, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 4193LL);
      return 1LL;
    }
  }

  LODWORD(v30) = 4;
  DWORD1(v30) = v24;
  BOOL result = sub_10002A994( (uint64_t)&v26,  &v30,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  4223LL,  v14,  v15,  v16,  v13);
  if (!result) {
    return result;
  }
  sub_1000235CC(a1 + 152, *(void *)(v26 + 48), "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 4225LL);
  sub_1000235C8(&v26, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 4226LL);
  return 1LL;
}

uint64_t sub_10000FD70(uint64_t *a1, uint64_t a2)
{
  uint64_t v44 = 0LL;
  int v43 = 0;
  sub_100011A00( (uint64_t)&v44,  (uint64_t)a1,  a1[19],  0LL,  &v43,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  275LL);
  if (v44 && (uint64_t v4 = (_BYTE *)*((void *)v44 + 13)) != 0LL)
  {
    else {
      uint64_t v5 = "Hostname Unsuitable for Printing";
    }
  }

  else
  {
    uint64_t v5 = 0LL;
  }

  if (*(_BYTE *)(*a1 + 1))
  {
    uint64_t v6 = (uint64_t)sub_1000501FC( *(unsigned __int8 *)(*a1 + 1),  *(unsigned __int8 *)(*a1 + 2),  (unsigned __int8 *)(*a1 + 28));
LABEL_12:
    uint64_t v7 = (const char *)v6;
    goto LABEL_13;
  }

  if (v44)
  {
    uint64_t v6 = sub_100050770((void *)*((unsigned __int16 *)v44 + 96), *((unsigned __int8 **)v44 + 23), 0x3Cu, 0);
    goto LABEL_12;
  }

  uint64_t v7 = "<no identifier>";
LABEL_13:
  BOOL v8 = v5 == 0LL;
  if (v5) {
    uint64_t v9 = "(";
  }
  else {
    uint64_t v9 = &byte_1000728D2;
  }
  if (!v5) {
    uint64_t v5 = &byte_1000728D2;
  }
  if (v8) {
    uint64_t v10 = &byte_1000728D2;
  }
  else {
    uint64_t v10 = ") ";
  }
  v11.s_addr = *(_DWORD *)(*a1 + 24);
  if (v11.s_addr) {
    uint64_t v12 = inet_ntoa(v11);
  }
  else {
    uint64_t v12 = (char *)(a1[13] + 132);
  }
  snprintf(__str, 0x400uLL, "DHCPDISCOVER from %s %s%s%svia %s", v7, v9, v5, v10, v12);
  uint64_t v20 = a1[19];
  if (!v20)
  {
    v27.s_addr = *(_DWORD *)(*a1 + 24);
    char v42 = inet_ntoa(v27);
    uint64_t result = sub_1000622D4("Packet from unknown subnet: %s", v28, v29, v30, v31, v32, v33, v34, v42);
    goto LABEL_53;
  }

  if (v44)
  {
    uint64_t v21 = *((void *)v44 + 17);
    if (v21
      && *(void *)(v21 + 160)
      && *((_BYTE *)v44 + 222) != 2
      && !sub_100028EA0((uint64_t)v44, v13, v14, v15, v16, v17, v18, v19))
    {
      sub_10003389C(&v44, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 329LL);
    }

    BOOL v22 = v44;
    if (v44)
    {
LABEL_35:
      uint64_t v23 = *((void *)v22 + 17);
      if (!v23) {
        goto LABEL_46;
      }
      uint64_t v24 = *(void *)(v23 + 160);
      if (!v24) {
        goto LABEL_46;
      }
      int v25 = *(_DWORD *)(v24 + 216);
      if ((v25 & 0xFFFFFFFE) == 4)
      {
        uint64_t result = sub_1000622D4("%s: not responding%s", v13, v14, v15, v16, v17, v18, v19, (char)__str);
        goto LABEL_53;
      }

      if (v25 != 1 || sub_100028D28(a1, v24, v14, v15, v16, v17, v18, v19))
      {
LABEL_46:
        uint64_t v37 = v44;
        uint64_t v38 = *((void *)v44 + 11);
        uint64_t v39 = xmmword_10008CE80;
        if (v38 < (uint64_t)xmmword_10008CE80 && *((void *)v44 + 14))
        {
          sub_10005515C( (void *)v44 + 14,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  378LL,  v15,  v16,  v17,  v18,  v19);
          uint64_t v39 = xmmword_10008CE80;
          uint64_t v37 = v44;
          uint64_t v38 = *((void *)v44 + 11);
        }

        uint64_t v40 = v39 + 120;
        if (v40 <= v38) {
          uint64_t v41 = v38;
        }
        else {
          uint64_t v41 = v40;
        }
        uint64_t result = (uint64_t)sub_100012C74((_DWORD **)a1, (uint64_t)v37, 2LL, v41, (uint64_t)__str, a2, 0LL, v19);
        goto LABEL_53;
      }

      if (!v43)
      {
        sub_10006238C("%s: cancel load balance to peer %s - %s", v35, v36, v15, v16, v17, v18, v19, (char)__str);
        goto LABEL_46;
      }

      uint64_t result = sub_10006238C("%s: load balance to peer %s", v35, v36, v15, v16, v17, v18, v19, (char)__str);
LABEL_53:
      if (v44) {
        return sub_10003389C(&v44, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 390LL);
      }
      return result;
    }

    uint64_t v20 = a1[19];
  }

  if (sub_1000129D8((uint64_t)&v44, a1, *(void *)(v20 + 72), &v43, v16, v17, v18, v19))
  {
    BOOL v22 = v44;
    if (!v44) {
      goto LABEL_46;
    }
    goto LABEL_35;
  }

  if (v43) {
    return sub_10006221C("%s: peer holds all free leases", v13, v14, v15, v16, v17, v18, v19, (char)__str);
  }
  else {
    return sub_10006221C("%s: network %s: no free leases", v13, v14, v15, v16, v17, v18, v19, (char)__str);
  }
}

uint64_t sub_1000100EC( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v90 = 0;
  uint64_t v11 = sub_100040D4C(&qword_10008C168, a1[20], 50LL, a4, a5, a6, a7, a8);
  uint64_t v88 = 0LL;
  uint64_t v89 = 0LL;
  uint64_t v87 = 0LL;
  if (v11
    && sub_100057AA4( &v87,  (unsigned int *)a1,  0LL,  0LL,  a1[20],  0LL,  &qword_10008C730,  v11,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x1A5u))
  {
    int v17 = *v88;
    LODWORD(v98) = 4;
    DWORD1(v98) = v17;
    sub_100034EA8( &v87,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  424LL,  v16,  v12,  v13,  v14,  v15);
    char v18 = 0;
  }

  else
  {
    int v19 = *(_DWORD *)(*a1 + 12);
    LODWORD(v98) = 4;
    DWORD1(v98) = v19;
    char v18 = 1;
  }

  uint64_t v91 = 0LL;
  uint64_t v92 = 0LL;
  *(_OWORD *)__int128 __str = v98;
  int v97 = v99;
  if (sub_10002A994( (uint64_t)&v91,  (__int128 *)__str,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  437LL,  v12,  v13,  v14,  v15))
  {
    sub_100011A00( (uint64_t)&v92,  (uint64_t)a1,  *(void *)(v91 + 48),  &v90,  0LL,  a3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  439LL);
  }

  if (v92 && (int v25 = (_BYTE *)*((void *)v92 + 13)) != 0LL)
  {
    else {
      uint64_t v26 = "Hostname Unsuitable for Printing";
    }
  }

  else
  {
    uint64_t v26 = 0LL;
  }

  uint64_t v27 = sub_100040D4C(&qword_10008C168, a1[20], 54LL, v20, v21, v22, v23, v24);
  uint64_t v88 = 0LL;
  uint64_t v89 = 0LL;
  uint64_t v87 = 0LL;
  if (v27
    && sub_100057AA4( &v87,  (unsigned int *)a1,  0LL,  0LL,  a1[20],  0LL,  &qword_10008C730,  v27,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x1C9u))
  {
    int v35 = *v88;
    sub_100034EA8( &v87,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  460LL,  v30,  v31,  v32,  v33,  v34);
    *(_DWORD *)__int128 __str = 4;
    *(_DWORD *)&__str[4] = v35;
    int v43 = sub_100040144((int *)__str, v36, v37, v38, v39, v40, v41, v42);
    __sprintf_chk(v95, 0, 0x13uLL, " (%s)", v43);
  }

  else
  {
    v95[0] = 0;
  }

  *(_OWORD *)__int128 __str = v98;
  int v97 = v99;
  uint64_t v44 = sub_100040144((int *)__str, v28, v29, v30, v31, v32, v33, v34);
  if (*(_BYTE *)(*a1 + 1))
  {
    uint64_t v45 = (uint64_t)sub_1000501FC( *(unsigned __int8 *)(*a1 + 1),  *(unsigned __int8 *)(*a1 + 2),  (unsigned __int8 *)(*a1 + 28));
LABEL_22:
    uint64_t v46 = (const char *)v45;
    goto LABEL_23;
  }

  if (v92)
  {
    uint64_t v45 = sub_100050770((void *)*((unsigned __int16 *)v92 + 96), *((unsigned __int8 **)v92 + 23), 0x3Cu, 0);
    goto LABEL_22;
  }

  uint64_t v46 = "<no identifier>";
LABEL_23:
  BOOL v47 = v26 == 0LL;
  if (v26) {
    uint64_t v48 = "(";
  }
  else {
    uint64_t v48 = &byte_1000728D2;
  }
  if (!v26) {
    uint64_t v26 = &byte_1000728D2;
  }
  if (v47) {
    uint64_t v49 = &byte_1000728D2;
  }
  else {
    uint64_t v49 = ") ";
  }
  v50.s_addr = *(_DWORD *)(*a1 + 24);
  if (v50.s_addr) {
    uint64_t v51 = inet_ntoa(v50);
  }
  else {
    uint64_t v51 = (char *)(a1[13] + 132);
  }
  snprintf(__str, 0x400uLL, "DHCPREQUEST for %s%s from %s %s%s%svia %s", v44, v95, v46, v48, v26, v49, v51);
  int v59 = v92;
  if (!v92) {
    goto LABEL_48;
  }
  uint64_t v60 = *((void *)v92 + 17);
  if (!v60) {
    goto LABEL_48;
  }
  uint64_t v61 = *(void *)(v60 + 160);
  if (!v61) {
    goto LABEL_48;
  }
  if ((*(_DWORD *)(v61 + 216) & 0xFFFFFFFE) != 4)
  {
    int v63 = *((unsigned __int8 *)v92 + 222);
    if (v63 == 7 || v63 == 1)
    {
      if (!sub_100028EA0((uint64_t)v92, v52, v53, v54, v55, v56, v57, v58))
      {
        uint64_t result = sub_10006238C("%s: lease owned by peer", v52, v53, v54, v55, v56, v57, v58, (char)__str);
        goto LABEL_69;
      }

      int v59 = v92;
      int v63 = *((unsigned __int8 *)v92 + 222);
    }

    if ((v63 - 3) <= 1)
    {
      int v64 = sub_100028EA0((uint64_t)v59, v52, v53, v54, v55, v56, v57, v58);
      int v59 = v92;
      int v63 = *((unsigned __int8 *)v92 + 222);
      if (!v64)
      {
        uint64_t result = sub_10006238C("%s: lease in transition state %s", v52, v53, v54, v55, v56, v57, v58, (char)__str);
        goto LABEL_69;
      }
    }

    if (v63 == 6 && !sub_100028EA0((uint64_t)v59, v52, v53, v54, v55, v56, v57, v58))
    {
      sub_10006238C("%s: lease reset by administrator", v65, v53, v54, v55, v56, v57, v58, (char)__str);
      goto LABEL_67;
    }

LABEL_48:
    uint64_t v66 = a1[19];
    if (v66)
    {
      if (*(_DWORD *)(*a1 + 12))
      {
        if (!*(_DWORD *)(*a1 + 24))
        {
LABEL_59:
          if (v92 || !v90)
          {
            if (v92)
            {
              uint64_t result = (uint64_t)sub_100012C74((_DWORD **)a1, (uint64_t)v92, 5LL, 0LL, (uint64_t)__str, a2, 0LL, v58);
            }

            else
            {
              __int128 v93 = v98;
              int v94 = v99;
              sub_100040144((int *)&v93, 0LL, v53, v54, v55, v56, v57, v58);
              uint64_t result = sub_1000622D4("%s: unknown lease %s.", v80, v81, v82, v83, v84, v85, v86, (char)__str);
            }

            goto LABEL_69;
          }

          __int128 v93 = v98;
          int v94 = v99;
          sub_100040144((int *)&v93, 0LL, v53, v54, v55, v56, v57, v58);
          sub_1000622D4("%s: lease %s unavailable.", v67, v68, v69, v70, v71, v72, v73, (char)__str);
          goto LABEL_67;
        }
      }

      else if ((v18 & 1) != 0)
      {
        goto LABEL_59;
      }

      if (v91)
      {
        sub_1000235C8(&v91, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 636LL);
        uint64_t v66 = a1[19];
      }

      __int128 v93 = v98;
      int v94 = v99;
      if (sub_10002A180( (uint64_t)&v91,  v66,  (uint64_t)&v93,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  638LL,  v56,  v57,  v58))
      {
        goto LABEL_59;
      }

      if (!*(_DWORD *)(*(void *)(a1[19] + 96) + 40LL)) {
        return sub_1000622D4("%s: ignored (not authoritative).", v66, v53, v54, v55, v56, v57, v58, (char)__str);
      }
    }

    else if (!v91 || !*(_DWORD *)(*(void *)(v91 + 128) + 40LL))
    {
      uint64_t result = sub_1000622D4("%s: ignored (%s).", 0LL, v53, v54, v55, v56, v57, v58, (char)__str);
      goto LABEL_69;
    }

    sub_1000622D4("%s: wrong network.", v66, v53, v54, v55, v56, v57, v58, (char)__str);
LABEL_67:
    uint64_t result = sub_100015424(a1, &v98, v74, v75, v76, v77, v78, v79);
    goto LABEL_69;
  }

  uint64_t result = sub_1000622D4("%s: not responding%s", v52, v53, v54, v55, v56, v57, v58, (char)__str);
LABEL_69:
  if (v91) {
    uint64_t result = sub_1000235C8(&v91, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 667LL);
  }
  if (v92) {
    return sub_10003389C(&v92, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 669LL);
  }
  return result;
}

  uint64_t v69 = *(void *)(a1 + 104);
  if (!v69) {
    goto LABEL_65;
  }
  uint64_t v70 = (uint64_t *)qword_1000BD2A8;
  if (qword_1000BD2A8)
  {
    uint64_t v71 = *(_DWORD *)(v69 + 24);
    while (*(_DWORD *)(*v70 + 24) != v71)
    {
      uint64_t v70 = (uint64_t *)v70[2];
      if (!v70) {
        goto LABEL_53;
      }
    }
  }

  else
  {
LABEL_53:
    uint64_t v72 = (uint64_t *)sub_10005CDE4(0x18uLL);
    uint64_t v70 = v72;
    if (!v72) {
      sub_100061FB4("No memory for host-identifier option information.", v73, v74, v75, v76, v77, v78, v79, v91);
    }
    sub_100052CB0(v72, *(void *)(a1 + 104));
    if (!sub_100063100( v70 + 1,  (uint64_t)sub_100033920,  (uint64_t)sub_100033924,  0x57E5u,  (uint64_t (*)(char *, int, unsigned int))sub_1000632A8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  384LL,  v80)) {
      sub_100061FB4("No memory for host-identifier option hash.", v81, v82, v83, v84, v85, v52, v53, v91);
    }
    v70[2] = qword_1000BD2A8;
    qword_1000BD2A8 = (uint64_t)v70;
  }

  if (sub_100063738( &v93,  (uint64_t (**)(unsigned __int8 *, int, unsigned int))v70[1],  *(const char **)(a1 + 120),  *(unsigned int *)(a1 + 128),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  393LL,  v52,  v53))
  {
    if (!v51)
    {
      uint64_t v88 = v93;
      do
      {
        uint64_t v89 = v88;
        uint64_t v88 = (_DWORD *)*((void *)v88 + 4);
      }

      while (v88);
      if (v89 != (_DWORD *)a1) {
        sub_100033920((void *)v89 + 4, a1);
      }
    }

    sub_100033924(&v93, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 413LL);
LABEL_65:
    if (!a2) {
      return 0LL;
    }
    goto LABEL_66;
  }

  sub_1000634B8( v70[1],  *(const char **)(a1 + 120),  *(unsigned int *)(a1 + 128),  a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  418LL,  v86,  v87,  v91);
  if (!a2) {
    return 0LL;
  }
LABEL_66:
  return 0LL;
}

      if (v9) {
        *uint64_t v6 = 0LL;
      }
      break;
    }
  }

  *__error() = 40;
  return 0xFFFFFFFFLL;
}

uint64_t sub_1000106D8( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v63 = 0LL;
  int v64 = 0LL;
  if (sub_100040D4C(&qword_10008C168, a1[20], 50LL, a4, a5, a6, a7, a8))
  {
    char v14 = sub_1000501FC( *(unsigned __int8 *)(*a1 + 1),  *(unsigned __int8 *)(*a1 + 2),  (unsigned __int8 *)(*a1 + 28));
    sub_1000622D4("DHCPRELEASE from %s specified requested-address.", v15, v16, v17, v18, v19, v20, v21, v14);
  }

  uint64_t v22 = sub_100040D4C(&qword_10008C168, a1[20], 61LL, v9, v10, v11, v12, v13);
  uint64_t v61 = 0LL;
  uint64_t v62 = 0LL;
  uint64_t v60 = 0LL;
  if (v22
    && sub_100057AA4( &v60,  (unsigned int *)a1,  0LL,  0LL,  a1[20],  0LL,  &qword_10008C730,  v22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x2BFu))
  {
    sub_10002CE00( &v64,  v61,  v62,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  704LL,  v24,  v25,  v26);
    sub_100034EA8( &v60,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  705LL,  v27,  v28,  v29,  v30,  v31);
    while (1)
    {
      uint64_t v32 = v64;
      if (!v64) {
        break;
      }
      uint64_t v33 = *((void *)v64 + 5);
      if (v33)
      {
        sub_100033898(&v63, v33, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 711LL);
        uint64_t v32 = v64;
      }

      if (*(_DWORD *)(*a1 + 12) == v32[15]) {
        break;
      }
      sub_10003389C(&v64, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 716LL);
      if (v63)
      {
        sub_100033898(&v64, v63, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 718LL);
        sub_10003389C(&v63, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 719LL);
      }
    }

    if (v63) {
      sub_10003389C(&v63, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 723LL);
    }
  }

  uint64_t v34 = v64;
  uint64_t v35 = *a1;
  if (!v64)
  {
    int v36 = *(_DWORD *)(v35 + 12);
    *(_DWORD *)__int128 __str = 4;
    int v67 = v36;
    sub_10002A978( &v64,  __str,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  732LL,  v23,  v24,  v25,  v26);
    uint64_t v34 = v64;
    if (!v64)
    {
LABEL_25:
      uint64_t v39 = 0LL;
      goto LABEL_27;
    }

    uint64_t v35 = *a1;
  }

  size_t v37 = *(unsigned __int8 *)(v35 + 2);
  if ((_DWORD)v37 + 1 != *((unsigned __int8 *)v34 + 203)
    || *((unsigned __int8 *)v34 + 204) != *(unsigned __int8 *)(v35 + 1)
    || memcmp((char *)v34 + 205, (const void *)(v35 + 28), v37))
  {
    sub_10003389C(&v64, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 742LL);
    uint64_t v34 = v64;
    if (!v64) {
      goto LABEL_25;
    }
  }

  uint64_t v38 = (char *)*((void *)v34 + 13);
  if (!v38) {
    goto LABEL_25;
  }
  else {
    uint64_t v39 = "Hostname Unsuitable for Printing";
  }
LABEL_27:
  v40.s_addr = *(_DWORD *)(*a1 + 12);
  uint64_t v41 = inet_ntoa(v40);
  strncpy(__dst, v41, 0xFuLL);
  __dst[15] = 0;
  if (*(_BYTE *)(*a1 + 1))
  {
    uint64_t v42 = (uint64_t)sub_1000501FC( *(unsigned __int8 *)(*a1 + 1),  *(unsigned __int8 *)(*a1 + 2),  (unsigned __int8 *)(*a1 + 28));
LABEL_31:
    int v43 = (const char *)v42;
    goto LABEL_32;
  }

  if (v64)
  {
    uint64_t v42 = sub_100050770((void *)*((unsigned __int16 *)v64 + 96), *((unsigned __int8 **)v64 + 23), 0x3Cu, 0);
    goto LABEL_31;
  }

  int v43 = "<no identifier>";
LABEL_32:
  BOOL v44 = v39 == 0LL;
  if (v39) {
    uint64_t v45 = "(";
  }
  else {
    uint64_t v45 = &byte_1000728D2;
  }
  if (!v39) {
    uint64_t v39 = &byte_1000728D2;
  }
  if (v44) {
    uint64_t v46 = &byte_1000728D2;
  }
  else {
    uint64_t v46 = ") ";
  }
  v47.s_addr = *(_DWORD *)(*a1 + 24);
  if (v47.s_addr) {
    uint64_t v48 = inet_ntoa(v47);
  }
  else {
    uint64_t v48 = (char *)(a1[13] + 132);
  }
  if (v64) {
    uint64_t v49 = &byte_1000728D2;
  }
  else {
    uint64_t v49 = "not ";
  }
  snprintf(__str, 0x400uLL, "DHCPRELEASE of %s from %s %s%s%svia %s (%sfound)", __dst, v43, v45, v39, v46, v48, v49);
  if (v64)
  {
    uint64_t v57 = *((void *)v64 + 17);
    if (v57)
    {
      uint64_t v58 = *(void *)(v57 + 160);
      if (v58)
      {
        if ((*(_DWORD *)(v58 + 216) & 0xFFFFFFFE) == 4)
        {
          uint64_t result = sub_1000622D4("%s: ignored%s", v50, v51, v52, v53, v54, v55, v56, *(void *)(v58 + 40));
          goto LABEL_54;
        }
      }
    }
  }

  uint64_t result = sub_1000622D4("%s", v50, v51, v52, v53, v54, v55, v56, (char)__str);
LABEL_54:
  if (v64) {
    return sub_10003389C(&v64, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 807LL);
  }
  return result;
}

_DWORD *sub_100010AE4( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v64 = 0LL;
  uint64_t v65 = 0LL;
  int v63 = 0;
  uint64_t result = (_DWORD *)sub_100040D4C(&qword_10008C168, *(void *)(a1 + 160), 50LL, a4, a5, a6, a7, a8);
  if (!result) {
    return result;
  }
  uint64_t v60 = 0LL;
  uint64_t v61 = 0LL;
  uint64_t v62 = 0LL;
  uint64_t result = (_DWORD *)sub_100057AA4( &v60,  (unsigned int *)a1,  0LL,  0LL,  *(void *)(a1 + 160),  0LL,  &qword_10008C730,  (uint64_t)result,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x342u);
  if (!(_DWORD)result) {
    return result;
  }
  int v15 = *v61;
  sub_100034EA8( &v60,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  839LL,  v10,  v11,  v12,  v13,  v14);
  *(_DWORD *)__int128 __str = 4;
  int v67 = v15;
  sub_10002A978( &v65,  __str,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  840LL,  v16,  v17,  v18,  v19);
  if (v65 && (uint64_t v27 = (_BYTE *)*((void *)v65 + 13)) != 0LL)
  {
    else {
      uint64_t v28 = "Hostname Unsuitable for Printing";
    }
  }

  else
  {
    uint64_t v28 = 0LL;
  }

  *(_DWORD *)__int128 __str = 4;
  int v67 = v15;
  uint64_t v29 = sub_100040144((int *)__str, v20, v21, v22, v23, v24, v25, v26);
  if (*(_BYTE *)(*(void *)a1 + 1LL))
  {
    uint64_t v30 = (uint64_t)sub_1000501FC( *(unsigned __int8 *)(*(void *)a1 + 1LL),  *(unsigned __int8 *)(*(void *)a1 + 2LL),  (unsigned __int8 *)(*(void *)a1 + 28LL));
LABEL_14:
    uint64_t v31 = (const char *)v30;
    goto LABEL_15;
  }

  if (v65)
  {
    uint64_t v30 = sub_100050770((void *)*((unsigned __int16 *)v65 + 96), *((unsigned __int8 **)v65 + 23), 0x3Cu, 0);
    goto LABEL_14;
  }

  uint64_t v31 = "<no identifier>";
LABEL_15:
  BOOL v32 = v28 == 0LL;
  if (v28) {
    uint64_t v33 = "(";
  }
  else {
    uint64_t v33 = &byte_1000728D2;
  }
  if (!v28) {
    uint64_t v28 = &byte_1000728D2;
  }
  if (v32) {
    uint64_t v34 = &byte_1000728D2;
  }
  else {
    uint64_t v34 = ") ";
  }
  v35.s_addr = *(_DWORD *)(*(void *)a1 + 24LL);
  if (v35.s_addr) {
    int v36 = inet_ntoa(v35);
  }
  else {
    int v36 = (char *)(*(void *)(a1 + 104) + 132LL);
  }
  snprintf(__str, 0x400uLL, "DHCPDECLINE of %s from %s %s%s%svia %s", v29, v31, v33, v28, v34, v36);
  sub_1000347D8( &v64,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  869LL,  v37,  v38,  v39,  v40,  v41);
  if (v65) {
    sub_10003E0AC( 0LL,  (int *)a1,  0LL,  0LL,  *(void *)(a1 + 160),  v64,  &qword_10008C730,  *(void *)(*((void *)v65 + 16) + 128LL),  0LL);
  }
  uint64_t v47 = *(unsigned int *)(a1 + 168);
  if ((int)v47 >= 1)
  {
    unint64_t v48 = v47 + 1;
    do
    {
      uint64_t v49 = v65;
      if (v65) {
        uint64_t v49 = *(void **)(*((void *)v65 + 16) + 128LL);
      }
      sub_10003E0AC( 0LL,  (int *)a1,  0LL,  0LL,  *(void *)(a1 + 160),  v64,  &qword_10008C730,  *(void *)(*(void *)(a1 + 8LL * (v48-- - 2) + 176) + 136LL),  v49);
    }

    while (v48 > 1);
  }

  uint64_t v50 = sub_100040D4C(&qword_10008BF80, v64, 29LL, v42, v43, v44, v45, v46);
  if (v50)
  {
    uint64_t result = (_DWORD *)sub_100057AF8( &v63,  (unsigned int *)a1,  (uint64_t)v65,  0LL,  *(void *)(a1 + 160),  v64,  (uint64_t *)v65 + 14,  v50,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x380u);
    if (!(_DWORD)result) {
      goto LABEL_42;
    }
  }

  uint64_t result = v65;
  if (!v65) {
    goto LABEL_42;
  }
  uint64_t v58 = *((void *)v65 + 17);
  if (!v58 || (uint64_t v59 = *(void *)(v58 + 160)) == 0 || (*(_DWORD *)(v59 + 216) & 0xFFFFFFFE) != 4)
  {
    uint64_t result = (_DWORD *)sub_10002CBE4((uint64_t)v65);
LABEL_42:
    if (!v63) {
      uint64_t result = (_DWORD *)sub_1000622D4("%s: %s", v51, v52, v53, v54, v55, v56, v57, (char)__str);
    }
    goto LABEL_44;
  }

  if (!v63) {
    uint64_t result = (_DWORD *)sub_1000622D4("%s: ignored%s", v51, v52, v53, v54, v55, v56, v57, *(void *)(v59 + 40));
  }
LABEL_44:
  if (v64) {
    uint64_t result = (_DWORD *)sub_100034894( &v64,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  933LL,  v53,  v54,  v55,  v56,  v57);
  }
  if (v65) {
    return (_DWORD *)sub_10003389C(&v65, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 935LL);
  }
  return result;
}

uint64_t sub_100010EBC( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v265 = 0LL;
  char v264 = 5;
  uint64_t v263 = 0LL;
  int v9 = *(_DWORD *)(*(void *)a1 + 12LL);
  int v10 = v9;
  if (!v9) {
    int v10 = *(_DWORD *)(a1 + 84);
  }
  int v11 = *(_DWORD *)(*(void *)a1 + 24LL);
  LODWORD(v299) = 4;
  DWORD1(v299) = v10;
  uint64_t v13 = sub_100040144((int *)&v299, a2, a3, a4, a5, a6, a7, a8);
  v14.s_addr = *(_DWORD *)(*(void *)a1 + 24LL);
  if (v14.s_addr) {
    int v15 = inet_ntoa(v14);
  }
  else {
    int v15 = (char *)(*(void *)(a1 + 104) + 132LL);
  }
  snprintf(__str, 0x400uLL, "DHCPINFORM from %s via %s", v13, v15);
  if (!v10) {
    return sub_1000622D4("%s: ignored (null source address).", v16, v17, v18, v19, v20, v21, v22, (char)__str);
  }
  BOOL v12 = v11 != 0;
  int v23 = 4 * v12;
  if (v9) {
    BOOL v24 = 1;
  }
  else {
    BOOL v24 = v11 == 0;
  }
  if (v24)
  {
    LODWORD(v299) = 4;
    DWORD1(v299) = v10;
    sub_10002A994( (uint64_t)&v263,  &v299,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1002LL,  v19,  v20,  v21,  v22);
    uint64_t v25 = v263;
    if (!v263)
    {
      LODWORD(v299) = 4;
      DWORD1(v299) = v10;
      sub_100040144((int *)&v299, v34, v35, v36, v37, v38, v39, v40);
      return sub_1000622D4("%s: unknown subnet for %s address %s", v26, v27, v28, v29, v30, v31, v32, (char)__str);
    }
  }

  else
  {
    LODWORD(v299) = 4 * v12;
    DWORD1(v299) = v11;
    sub_10002A994( (uint64_t)&v263,  &v299,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  993LL,  v19,  v20,  v21,  v22);
    uint64_t v25 = v263;
    if (!v263)
    {
      LODWORD(v299) = 4 * v12;
      DWORD1(v299) = v11;
      sub_100040144((int *)&v299, v34, v35, v36, v37, v38, v39, v40);
      return sub_1000622D4( "%s: unknown subnet for relay address %s",  v103,  v104,  v105,  v106,  v107,  v108,  v109,  (char)__str);
    }
  }

  if (!*(_DWORD *)(*(void *)(v25 + 128) + 40LL))
  {
    __int128 v299 = *(_OWORD *)(v25 + 84);
    int v300 = *(_DWORD *)(v25 + 100);
    sub_100040144((int *)&v299, v34, v35, v36, v37, v38, v39, v40);
    sub_1000622D4("%s: not authoritative for subnet %s", v58, v59, v60, v61, v62, v63, v64, (char)__str);
    int v72 = dword_10008CFA0;
    if (!dword_10008CFA0)
    {
      sub_1000622D4( "If this DHCP server is authoritative for%s",  v65,  v66,  v67,  v68,  v69,  v70,  v71,  (char)" that subnet,");
        v73,
        v74,
        v75,
        v76,
        v77,
        v78,
        v79,
        (char)"ve either in the");
      sub_1000622D4( "subnet declaration or in some scope that%s",  v80,  v81,  v82,  v83,  v84,  v85,  v86,  (char)" encloses the");
      sub_1000622D4( "subnet declaration - for example, write %s",  v87,  v88,  v89,  v90,  v91,  v92,  v93,  (char)"it at the top");
      sub_1000622D4("of the dhcpd.conf file.", v94, v95, v96, v97, v98, v99, v100, v260);
      int v72 = dword_10008CFA0;
    }

    if (v72 == 100) {
      int v101 = 0;
    }
    else {
      int v101 = v72 + 1;
    }
    dword_10008CFA0 = v101;
    uint64_t v102 = 1033LL;
    return sub_1000235C8(&v263, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", v102);
  }

  sub_1000347D8( (uint64_t *)&v265,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1037LL,  v36,  v37,  v38,  v39,  v40);
  __int128 v285 = 0u;
  __int128 v286 = 0u;
  __int128 v287 = 0u;
  __int128 v288 = 0u;
  __int128 v289 = 0u;
  __int128 v290 = 0u;
  __int128 v291 = 0u;
  __int128 v292 = 0u;
  __int128 v293 = 0u;
  __int128 v294 = 0u;
  __int128 v295 = 0u;
  __int128 v296 = 0u;
  __int128 v297 = 0u;
  __int128 v298 = 0u;
  bzero(&v299, 0x5C0uLL);
  v284 = &v299;
  if (v263) {
    sub_10003E0AC( 0LL,  (int *)a1,  0LL,  0LL,  *(void *)(a1 + 160),  (uint64_t)v265,  &qword_10008C730,  *(void *)(v263 + 128),  0LL);
  }
  int v46 = *(_DWORD *)(a1 + 168);
  for (int i = v46; i; --i)
  {
    uint64_t v47 = (void *)v263;
    if (v263) {
      uint64_t v47 = *(void **)(v263 + 128);
    }
    sub_10003E0AC( 0LL,  (int *)a1,  0LL,  0LL,  *(void *)(a1 + 160),  (uint64_t)v265,  &qword_10008C730,  *(void *)(*(void *)(a1 + 8LL * (v46 - 1) + 176) + 136LL),  v47);
    int v46 = i - 1;
  }

  v269 = 0LL;
  v270 = 0LL;
  uint64_t v271 = 0LL;
  unint64_t v48 = (int *)sub_100040D4C(&qword_10008BF80, (uint64_t)v265, 15LL, v41, v42, v43, v44, v45);
  v266 = (uint64_t *)v48;
  if (v48
    && sub_100057AA4( &v269,  (unsigned int *)a1,  0LL,  0LL,  *(void *)(a1 + 160),  0LL,  &qword_10008C730,  (uint64_t)v48,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x42Bu))
  {
    unsigned int v56 = v271;
    int i = v271;
    if (v271 < 0x80)
    {
      v305[v271] = 0;
      unsigned int v57 = v56;
    }

    else
    {
      unsigned int v57 = 128;
      sub_1000622D4( "file name longer than packet field truncated - field: %lu name: %d %.*s",  v54,  v55,  v49,  v50,  v51,  v52,  v53,  128);
      int i = 128;
    }

    __memcpy_chk(v305, v270, v57, 1364LL);
    sub_100034EA8( &v269,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1078LL,  v110,  v111,  v112,  v113,  v114);
  }

  uint64_t v115 = (int *)sub_100040D4C(&qword_10008BF80, (uint64_t)v265, 16LL, v49, v50, v51, v52, v53);
  v266 = (uint64_t *)v115;
  if (v115
    && sub_100057AA4( &v269,  (unsigned int *)a1,  0LL,  0LL,  *(void *)(a1 + 160),  0LL,  &qword_10008C730,  (uint64_t)v115,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x43Fu))
  {
    unsigned int v123 = v271;
    int i = v271;
    if (v271 < 0x40)
    {
      v304[v271] = 0;
      unsigned int v124 = v123;
    }

    else
    {
      unsigned int v124 = 64;
      sub_1000622D4( "server name longer than packet field truncated - field: %lu name: %d %.*s",  v121,  v122,  v116,  v117,  v118,  v119,  v120,  64);
      int i = 64;
    }

    __memcpy_chk(v304, v270, v124, 1428LL);
    sub_100034EA8( &v269,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1098LL,  v125,  v126,  v127,  v128,  v129);
  }

  uint64_t v130 = sub_100040D4C(&qword_10008C168, *(void *)(a1 + 160), 12LL, v116, v117, v118, v119, v120);
  if (v130 && !*(void *)(v130 + 16)) {
    int v136 = *(_DWORD *)(v130 + 56) & 1;
  }
  else {
    int v136 = 0;
  }
  int i = 53;
  v266 = 0LL;
  if (sub_100034540( &v266,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1113LL,  v131,  v132,  v133,  v134,  v135))
  {
    if (sub_1000545BC( v266 + 2,  &v264,  1,  0LL,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1115LL,  v141))
    {
      sub_100029804( v266 + 3,  qword_10008C1E0,  &i,  0LL,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1118LL);
      sub_100043E20(&qword_10008C168, (uint64_t)v265, (uint64_t)v266, v147, v148, v149, v150, v151);
    }

    sub_100040E08( (int **)&v266,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1121LL,  v142,  v143,  v144,  v145,  v146);
  }

  sub_1000158D4(&v261, (uint64_t)v265, a1, v137, v138, v139, v140, v141);
  int i = 1;
  if (v263)
  {
    if (!sub_100040D4C(&qword_10008C168, (uint64_t)v265, 1LL, v152, v153, v154, v155, v156))
    {
      v266 = 0LL;
      if (sub_100034540( &v266,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1131LL,  v152,  v153,  v154,  v155,  v156))
      {
        if (sub_1000545BC( v266 + 2,  (const void *)(v263 + 108),  *(_DWORD *)(v263 + 104),  0LL,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1135LL,  v156))
        {
          sub_100029804( v266 + 3,  qword_10008C1E0,  &i,  0LL,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1138LL);
          sub_100043E20(&qword_10008C168, (uint64_t)v265, (uint64_t)v266, v162, v163, v164, v165, v166);
        }

        sub_100040E08( (int **)&v266,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1141LL,  v157,  v158,  v159,  v160,  v161);
      }
    }
  }

  int i = 21;
  int v167 = (int *)sub_100040D4C(&qword_10008BF80, (uint64_t)v265, 21LL, v152, v153, v154, v155, v156);
  v266 = (uint64_t *)v167;
  if (!v167
    || !sub_100057AA4( &v269,  (unsigned int *)a1,  0LL,  0LL,  *(void *)(a1 + 160),  (uint64_t)v265,  &qword_10008C730,  (uint64_t)v167,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x480u))
  {
    size_t v187 = v265;
    *((void *)v265 + 1) = dword_10008C1F0;
    goto LABEL_61;
  }

  v267[0] = 0LL;
  if (sub_100029804( v267,  qword_10008C560,  v270,  v271,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1157LL))
  {
    uint64_t v180 = v267[0];
    v265[2] = v267[0][34];
    int v181 = sub_100015A70((uint64_t)v180);
    v265[3] = v181;
    sub_100034EA8( &v269,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1167LL,  v182,  v183,  v184,  v185,  v186);
    size_t v187 = v265;
LABEL_61:
    v267[0] = 0LL;
    v267[1] = 0LL;
    uint64_t v268 = 0LL;
    uint64_t v192 = (int *)sub_100040D4C(&qword_10008C168, (uint64_t)v187, 55LL, v168, v169, v170, v171, v172);
    v266 = (uint64_t *)v192;
    if (v192
      || (uint64_t v192 = (int *)sub_100040D4C(&qword_10008C168, *(void *)(a1 + 160), 55LL, v188, v189, v190, v191, 0LL),
          (v266 = (uint64_t *)v192) != 0LL))
    {
      sub_100057AA4( v267,  (unsigned int *)a1,  0LL,  0LL,  *(void *)(a1 + 160),  (uint64_t)v265,  &qword_10008C730,  (uint64_t)v192,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x4A7u);
    }

    sub_1000622D4("%s", v193, v194, v195, v196, v197, v198, (uint64_t)v192, (char)__str);
    uint64_t v204 = (int *)sub_100040D4C(&qword_10008BF80, (uint64_t)v265, 17LL, v199, v200, v201, v202, v203);
    v266 = (uint64_t *)v204;
    if (v204
      && sub_100057AA4( &v269,  (unsigned int *)a1,  0LL,  0LL,  *(void *)(a1 + 160),  (uint64_t)v265,  &qword_10008C730,  (uint64_t)v204,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x4B6u))
    {
      sub_100034EA8( &v269,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1211LL,  v205,  v206,  v207,  v208,  v209);
    }

    sub_10004463C(&qword_10008C168, (uint64_t)v265, 51LL, v205, v206, v207, v208, v209);
    sub_10004463C(&qword_10008C168, (uint64_t)v265, 58LL, v210, v211, v212, v213, v214);
    sub_10004463C(&qword_10008C168, (uint64_t)v265, 59LL, v215, v216, v217, v218, v219);
    int v220 = v267;
    if (!(_DWORD)v268) {
      int v220 = 0LL;
    }
    unsigned int v221 = sub_100041504( a1,  (uint64_t)&v299,  0LL,  0LL,  0LL,  *(int **)(a1 + 160),  v265,  &qword_10008C730,  0,  v136,  0,  (uint64_t)v220,  0LL);
    DWORD1(v285) = v221;
    sub_100034894( &v265,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1230LL,  v222,  v223,  v224,  v225,  v226);
    sub_100034EA8( v267,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1231LL,  v227,  v228,  v229,  v230,  v231);
    if (v221 <= 0x12B)
    {
      unsigned int v221 = 300;
      DWORD1(v285) = 300;
    }

    uint64_t v239 = *(void *)a1;
    int v302 = *(_DWORD *)(*(void *)a1 + 24LL);
    int v240 = *(_DWORD *)(v239 + 12);
    HIDWORD(v299) = v240;
    __int128 v303 = *(_OWORD *)(v239 + 28);
    *(_WORD *)((char *)&v299 + 1) = *(_WORD *)(v239 + 1);
    DWORD1(v299) = *(_DWORD *)(v239 + 4);
    WORD4(v299) = *(_WORD *)(v239 + 8);
    __int16 v241 = *(_WORD *)(v239 + 10);
    WORD5(v299) = v241;
    BYTE3(v299) = *(_BYTE *)(v239 + 3);
    LOBYTE(v299) = 2;
    v276[1] = 2;
    v276[0] = 16;
    uint64_t v279 = 0LL;
    if (!v11 || v240)
    {
      int v23 = 0;
      __int16 v242 = word_10008C104;
      int v243 = v10;
    }

    else
    {
      __int16 v242 = word_10008C0F4;
      WORD5(v299) = v241 | 0x80;
      int v243 = v11;
    }

    int v278 = v243;
    __int16 v277 = v242;
    int v272 = 4;
    int v273 = v10;
    uint64_t v274 = v282;
    int v275 = v283;
    v244 = sub_100040144(&v272, v232, v233, v234, v235, v236, v237, v238);
    uint64_t v245 = *(void *)a1;
    if (*(_BYTE *)(*(void *)a1 + 1LL) && *(_BYTE *)(v245 + 2)) {
      v246 = sub_1000501FC( *(unsigned __int8 *)(*(void *)a1 + 1LL),  *(unsigned __int8 *)(v245 + 2),  (unsigned __int8 *)(v245 + 28));
    }
    else {
      v246 = "<no client hardware address>";
    }
    snprintf(__str, 0x400uLL, "DHCPACK to %s (%s) via", v244, v246);
    if (v23)
    {
      int v272 = v23;
      int v273 = v11;
      uint64_t v274 = v280;
      int v275 = v281;
      sub_100040144(&v272, v247, v248, v249, v250, v251, v252, v253);
    }

    sub_1000622D4("%s %s", v247, v248, v249, v250, v251, v252, v253, (char)__str);
    *__error() = 0;
    uint64_t v254 = qword_10008C0A8;
    if (!qword_10008C0A8) {
      uint64_t v254 = *(void *)(a1 + 104);
    }
    uint64_t result = sub_100039F14(v254, (int)&v284, &v299, v221, v261, (uint64_t)v276, 0LL);
    if (v263)
    {
      uint64_t v102 = 1304LL;
      return sub_1000235C8(&v263, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", v102);
    }

    return result;
  }

  sub_10006221C("unknown option space %s.", v173, v174, v175, v176, v177, v178, v179, (char)v270);
  uint64_t result = sub_100034894( &v265,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1159LL,  v255,  v256,  v257,  v258,  v259);
  if (v263)
  {
    uint64_t v102 = 1161LL;
    return sub_1000235C8(&v263, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", v102);
  }

  return result;
}

uint64_t sub_100011A00( uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, _DWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v143 = a8;
  uint64_t v156 = 0LL;
  uint64_t v157 = 0LL;
  uint64_t v154 = 0LL;
  unint64_t v155 = 0LL;
  uint64_t v153 = 0LL;
  uint64_t v151 = 0LL;
  __int128 v152 = 0uLL;
  if (a5)
  {
    for (uint64_t i = *(void *)(a3 + 72); i; uint64_t i = *(void *)(i + 32))
    {
      uint64_t v15 = *(void *)(i + 160);
      if (v15)
      {
        int v16 = *(_DWORD *)(v15 + 240);
        if (v16 == 1)
        {
          if (*(_DWORD *)(i + 132)) {
            goto LABEL_11;
          }
        }

        else if (!v16 && *(_DWORD *)(i + 136))
        {
LABEL_11:
          *a5 = 1;
          break;
        }
      }
    }
  }

  int v17 = *(_DWORD *)(*(void *)a2 + 12LL);
  if (v17)
  {
    unsigned int v18 = 4;
    LODWORD(v163) = 4;
    DWORD1(v163) = v17;
  }

  else
  {
    uint64_t v19 = sub_100040D4C(&qword_10008C168, *(void *)(a2 + 160), 50LL, (uint64_t)a4, (uint64_t)a5, a6, a7, a8);
    uint64_t v149 = 0LL;
    uint64_t v150 = 0LL;
    uint64_t v148 = 0LL;
    if (v19
      && sub_100057AA4( &v148,  (unsigned int *)a2,  0LL,  0LL,  *(void *)(a2 + 160),  0LL,  &qword_10008C730,  v19,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0xCC1u))
    {
      *(_DWORD *)(a2 + 148) = 1;
      unsigned int v18 = 4;
      int v20 = *v149;
      LODWORD(v163) = 4;
      DWORD1(v163) = v20;
      sub_100034EA8( &v148,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  3269LL,  (uint64_t)a4,  (uint64_t)a5,  a6,  a7,  a8);
    }

    else
    {
      unsigned int v18 = 0;
      LODWORD(v163) = 0;
    }
  }

  uint64_t v21 = sub_100040D4C(&qword_10008C168, *(void *)(a2 + 160), 61LL, (uint64_t)a4, (uint64_t)a5, a6, a7, a8);
  __s2 = 0LL;
  uint64_t v147 = 0LL;
  uint64_t v145 = 0LL;
  if (v21
    && sub_100057AA4( &v145,  (unsigned int *)a2,  0LL,  0LL,  *(void *)(a2 + 160),  0LL,  &qword_10008C730,  v21,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0xCD4u))
  {
    if (sub_100029E98( &v153,  (const char *)__s2,  v147,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  3291LL,  v26,  v27,  v28))
    {
      *(_DWORD *)(a2 + 216) = 1;
      sub_100016290((uint64_t)&v152, v29, a3, (uint64_t)v153);
    }

    if (v153)
    {
      if (!(void)v152) {
        sub_100033920((void *)&v152 + 1, (uint64_t)v153);
      }
      sub_100033924(&v153, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3306LL);
    }

    sub_10002CE00( &v157,  (const char *)__s2,  v147,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  3310LL,  v30,  v31,  v32);
    char v33 = 0;
  }

  else
  {
    char v33 = 1;
  }

  if (v152 == 0
    && sub_100029DE4( &v153,  *(_BYTE *)(*(void *)a2 + 1LL),  *(void *)a2 + 28LL,  *(unsigned __int8 *)(*(void *)a2 + 2LL),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  3318LL))
  {
    *(_DWORD *)(a2 + 216) = 1;
    if (*((void *)&v152 + 1)) {
      sub_100033924( (_DWORD **)&v152 + 1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  3322LL);
    }
    sub_100033920((void *)&v152 + 1, (uint64_t)v153);
    sub_100033924(&v153, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3324LL);
    sub_100016290((uint64_t)&v152, v34, a3, *((uint64_t *)&v152 + 1));
  }

  if (*(_DWORD *)(a2 + 16) == 3
    && (void)v152
    && (*(_DWORD *)(v152 + 56) != v18 || memcmp((const void *)(v152 + 60), (char *)&v163 + 4, v18)))
  {
    if (a4) {
      *a4 = 1;
    }
    strcpy((char *)xmmword_10008CFA4, "requested address is incorrect");
    goto LABEL_240;
  }

  for (uint64_t j = (_DWORD *)v157; v157; uint64_t j = (_DWORD *)v157)
  {
    if (*((_BYTE *)j + 222) == 2
      || (int v36 = sub_100028EA0((uint64_t)j, (uint64_t)v22, v23, v24, v25, v26, v27, v28), j = (_DWORD *)v157, v36))
    {
      if (*(void *)(*((void *)j + 16) + 48LL) == a3)
      {
        uint64_t v37 = *((void *)j + 17);
        uint64_t v38 = *(uint64_t **)(v37 + 64);
        if (!v38 || !sub_100016450((_DWORD *)a2, v38))
        {
          uint64_t v39 = *(uint64_t **)(v37 + 56);
        }
      }
    }

    uint64_t v40 = *((void *)j + 5);
    if (v40) {
      sub_100033898(&v151, v40, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3401LL);
    }
    if (!*(_DWORD *)(*(void *)a2 + 12LL)) {
      sub_10002CAA0(v157, a2);
    }
    sub_10003389C((_DWORD **)&v157, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3404LL);
    uint64_t v22 = v151;
    if (v151)
    {
      sub_100033898(&v157, v151, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3406LL);
      sub_10003389C(&v151, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3407LL);
    }
  }

  uint64_t v41 = *(void *)a2;
  uint64_t v42 = *(unsigned __int8 *)(*(void *)a2 + 2LL);
  unsigned __int8 v43 = v42 + 1;
  char v160 = v42 + 1;
  char v161 = *(_BYTE *)(v41 + 1);
  __memcpy_chk(&v162, v41 + 28, v42, 16LL);
  sub_10002CE28( &v155,  &v161,  v43,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  3429LL,  v44,  v45,  v46);
  uint64_t v49 = (_DWORD *)v155;
  while (v155)
  {
    if (*((_BYTE *)v49 + 222) != 2)
    {
      int v52 = sub_100028EA0((uint64_t)v49, (uint64_t)v47, v48, v24, v25, v26, v27, v28);
      uint64_t v49 = (_DWORD *)v155;
      if (!v52) {
        goto LABEL_75;
      }
      int v53 = *(unsigned __int8 *)(v155 + 222);
      if (v53 == 1 || v53 == 7)
      {
LABEL_68:
        if (*(void *)(*((void *)v49 + 16) + 48LL) == a3)
        {
          uint64_t v55 = *((void *)v49 + 17);
          unsigned int v56 = *(uint64_t **)(v55 + 64);
          if (!v56 || !sub_100016450((_DWORD *)a2, v56))
          {
            uint64_t v47 = *(uint64_t **)(v55 + 56);
          }

          if (!*(_DWORD *)(*(void *)a2 + 12LL))
          {
            sub_10002CAA0((uint64_t)v49, a2);
            uint64_t v49 = (_DWORD *)v155;
          }
        }

        goto LABEL_75;
      }
    }

    uint64_t v50 = (const void *)*((void *)v49 + 23);
    if (!v50) {
      goto LABEL_68;
    }
    if ((v33 & 1) == 0)
    {
      size_t v51 = *((unsigned __int16 *)v49 + 96);
      if ((_DWORD)v147 == (_DWORD)v51 && !memcmp(v50, __s2, v51)) {
        goto LABEL_68;
      }
    }

LABEL_75:
    uint64_t v57 = *((void *)v49 + 6);
    if (v57) {
      sub_100033898(&v151, v57, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3481LL);
    }
    sub_10003389C((_DWORD **)&v155, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3482LL);
    uint64_t v47 = (uint64_t *)v151;
    if (v151)
    {
      sub_100033898(&v155, v151, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3484LL);
      sub_10003389C(&v151, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3485LL);
    }

    uint64_t v49 = (_DWORD *)v155;
  }

  if (a6)
  {
    sub_100033898(&v156, a6, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3500LL);
  }

  else if ((_DWORD)v163)
  {
    __int128 v158 = v163;
    int v159 = v164;
    sub_10002A978( &v156,  (const char *)&v158,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  3502LL,  v25,  v26,  v27,  v28);
  }

  uint64_t v58 = v156;
  if (a4 && v156)
  {
    *a4 = 1;
LABEL_88:
    if (*(void *)(*((void *)v58 + 16) + 48LL) != a3)
    {
      if (a4) {
        *a4 = 1;
      }
      strcpy((char *)xmmword_10008CFA4, "requested address on bad subnet");
      sub_10003389C(&v156, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3530LL);
      uint64_t v58 = v156;
      if (!v156) {
        goto LABEL_112;
      }
    }

    uint64_t v59 = (const void *)*((void *)v58 + 23);
    if (v59)
    {
      if ((v33 & 1) != 0) {
        goto LABEL_100;
      }
      size_t v48 = *((unsigned __int16 *)v58 + 96);
      if ((_DWORD)v147 != (_DWORD)v48) {
        goto LABEL_100;
      }
      uint64_t v60 = __s2;
    }

    else
    {
      uint64_t v61 = *(void *)a2;
      int v62 = *((unsigned __int8 *)v58 + 203);
      uint64_t v59 = (char *)v58 + 205;
      uint64_t v60 = (void *)(v61 + 28);
      size_t v48 = (v62 - 1);
    }

    if (!memcmp(v59, v60, v48))
    {
LABEL_106:
      if (v157 | v155
        && *((_BYTE *)v58 + 222) != 2
        && !sub_100028EA0((uint64_t)v58, (uint64_t)v47, v48, v24, v25, v26, v27, v28)
        && *(_DWORD *)(a2 + 16) == 1)
      {
        sub_10003389C(&v156, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3575LL);
      }

      uint64_t v58 = v156;
      goto LABEL_112;
    }

LABEL_100:
    int v63 = *((unsigned __int8 *)v58 + 222);
    if (v63 != 1 && v63 != 7)
    {
      if (a4 && v63 != 2) {
        *a4 = 0;
      }
      sub_10003389C(&v156, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3560LL);
      uint64_t v58 = v156;
      if (!v156) {
        goto LABEL_112;
      }
    }

    goto LABEL_106;
  }

  if (v156) {
    goto LABEL_88;
  }
LABEL_112:
  if (!v58) {
    goto LABEL_141;
  }
  if (*((_BYTE *)v58 + 222) != 2) {
    goto LABEL_141;
  }
  uint64_t v47 = (uint64_t *)*((void *)v58 + 23);
  if (!v47) {
    goto LABEL_141;
  }
  uint64_t v64 = v157;
  if (v58 == (_DWORD *)v157) {
    goto LABEL_141;
  }
  if ((v33 & 1) == 0)
  {
    size_t v48 = *((unsigned __int16 *)v58 + 96);
    if ((_DWORD)v147 == (_DWORD)v48)
    {
      int v65 = memcmp(__s2, v47, v48);
      if (v64)
      {
        if (!v65)
        {
          if (*(_BYTE *)(v64 + 222) == 2)
          {
            char v66 = sub_1000501FC( *(unsigned __int8 *)(*(void *)a2 + 1LL),  *(unsigned __int8 *)(*(void *)a2 + 2LL),  (unsigned __int8 *)(*(void *)a2 + 28LL));
            sub_10006221C("client %s has duplicate%s on %s", v67, v68, v69, v70, v71, v72, v73, v66);
            if (v157)
            {
              if (*(_BYTE *)(v157 + 222) == 2
                && !*(_DWORD *)(*(void *)a2 + 12LL)
                && *(void *)(*(void *)(v157 + 128) + 48LL) == a3
                && *(_DWORD *)(a2 + 16) == 3)
              {
                sub_10002CAA0(v157, a2);
              }
            }
          }

          sub_10003389C( (_DWORD **)&v157,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  3609LL);
          sub_100033898(&v157, v156, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3610LL);
        }
      }
    }
  }

  if (*(_DWORD *)(a2 + 16) != 3 || !(void)v152) {
    goto LABEL_138;
  }
  sub_10003389C((_DWORD **)&v152, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3618LL);
  do
  {
    __int128 v158 = v163;
    int v159 = v164;
    char v74 = sub_100040144((int *)&v158, (uint64_t)v47, v48, v24, v25, v26, v27, v28);
    sub_10006221C("Dynamic and static leases present for %s.", v75, v76, v77, v78, v79, v80, v81, v74);
    if (!(void)v152 || (uint64_t v89 = *(void *)(v152 + 120)) == 0 || (v90 = *(void *)(v89 + 48)) == 0)
    {
      __int128 v158 = v163;
      int v159 = v164;
      LOBYTE(v90) = sub_100040144((int *)&v158, v82, v83, v84, v85, v86, v87, v88);
    }

    __int128 v158 = v163;
    int v159 = v164;
    sub_100040144((int *)&v158, v82, v83, v84, v85, v86, v87, v88);
    sub_10006221C("Remove host declaration %s or remove %s", v91, v92, v93, v94, v95, v96, v97, v90);
    sub_10006221C( "from the dynamic address pool for %s",  v98,  v99,  v100,  v101,  v102,  v103,  v104,  *(void *)(*(void *)(*((void *)v156 + 16) + 48LL) + 40LL));
    if ((void)v152) {
      sub_10003389C(&v156, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3633LL);
    }
    strcpy((char *)xmmword_10008CFA4, "database conflict - call for help!");
LABEL_138:
    uint64_t v58 = v156;
    if (v156 && v156 != (_DWORD *)v157)
    {
      sub_10003389C(&v156, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3642LL);
      uint64_t v58 = v156;
    }

  uint64_t v39 = 265LL;
  if (v41 == 45 || v41 == 95) {
    goto LABEL_106;
  }
  if (v41 > 0x7F ? __maskrune(v41, 0x500uLL) : _DefaultRuneLocale.__runetype[v41] & 0x500) {
    goto LABEL_106;
  }
LABEL_113:
  size_t v51 = v40 - 244;
  if (v48 != -1)
  {
    --*(void *)(a1 + 1760);
    *(_DWORD *)(a1 + 228) = 1;
  }

LABEL_141:
    if (*(_DWORD *)(a2 + 16) != 3) {
      break;
    }
  }

  while ((void)v152 && v58 != 0LL);
  unint64_t v106 = v155;
  if (v155 && v155 == v157)
  {
    sub_10003389C((_DWORD **)&v155, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3656LL);
    unint64_t v106 = v155;
    uint64_t v58 = v156;
  }

  if (v58 && v58 == (_DWORD *)v106)
  {
    sub_10003389C((_DWORD **)&v155, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3659LL);
    uint64_t v58 = v156;
  }

  if (v58 && v58 == (_DWORD *)v157)
  {
    sub_10003389C((_DWORD **)&v157, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3665LL);
    uint64_t v58 = v156;
  }

  if (v58)
  {
    if ((uint64_t v107 = *((void *)v58 + 17), (v108 = *(uint64_t **)(v107 + 64)) != 0LL)
      && sub_100016450((_DWORD *)a2, v108)
      || (uint64_t v109 = *(uint64_t **)(v107 + 56)) != 0LL && !sub_100016450((_DWORD *)a2, v109))
    {
      if (!*(_DWORD *)(*(void *)a2 + 12LL) && *((_BYTE *)v58 + 222) == 2) {
        sub_10002CAA0((uint64_t)v58, a2);
      }
      sub_10003389C(&v156, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3681LL);
    }
  }

  uint64_t v110 = (_DWORD *)v157;
  if (v157)
  {
    if ((uint64_t v111 = *(void *)(v157 + 136), (v112 = *(uint64_t **)(v111 + 64)) != 0LL)
      && sub_100016450((_DWORD *)a2, v112)
      || (uint64_t v113 = *(uint64_t **)(v111 + 56)) != 0LL && !sub_100016450((_DWORD *)a2, v113))
    {
      if (!*(_DWORD *)(*(void *)a2 + 12LL)) {
        sub_10002CAA0((uint64_t)v110, a2);
      }
      sub_10003389C((_DWORD **)&v157, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3691LL);
    }
  }

  uint64_t v114 = (_DWORD *)v155;
  if (v155)
  {
    if ((uint64_t v115 = *(void *)(v155 + 136), (v116 = *(uint64_t **)(v115 + 64)) != 0LL)
      && sub_100016450((_DWORD *)a2, v116)
      || (uint64_t v117 = *(uint64_t **)(v115 + 56)) != 0LL && !sub_100016450((_DWORD *)a2, v117))
    {
      if (!*(_DWORD *)(*(void *)a2 + 12LL)) {
        sub_10002CAA0((uint64_t)v114, a2);
      }
      sub_10003389C((_DWORD **)&v155, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3701LL);
    }
  }

  uint64_t v118 = v156;
  if (!v156)
  {
    strcpy((char *)xmmword_10008CFA4, "requested address not available");
    if (*(_DWORD *)(a2 + 16) == 3 && !(void)v152) {
      goto LABEL_240;
    }
  }

  if ((void)v152)
  {
    sub_100033898(&v154, v152, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3725LL);
    sub_10003389C((_DWORD **)&v152, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3726LL);
    uint64_t v118 = v156;
  }

  if (v118)
  {
    if (v154)
    {
      if (!*(_DWORD *)(*(void *)a2 + 12LL)) {
        sub_10002CAA0((uint64_t)v118, a2);
      }
    }

    else
    {
      sub_100033898(&v154, v118, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3745LL);
      if (*((void *)v154 + 15)) {
        sub_100033924( (_DWORD **)v154 + 15,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  3747LL);
      }
    }

    sub_10003389C(&v156, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3749LL);
  }

  uint64_t v119 = (_DWORD *)v157;
  if (v157)
  {
    if (v154)
    {
      __int128 v158 = *(_OWORD *)(v157 + 56);
      int v159 = *(_DWORD *)(v157 + 72);
      char v120 = sub_100040144((int *)&v158, v157, v48, v24, v25, v26, v27, v28);
      sub_1000501FC( *(unsigned __int8 *)(*(void *)a2 + 1LL),  *(unsigned __int8 *)(*(void *)a2 + 2LL),  (unsigned __int8 *)(*(void *)a2 + 28LL));
      sub_10006221C("uid lease %s for client %s is duplicate on %s", v121, v122, v123, v124, v125, v126, v127, v120);
      if (!*(_DWORD *)(*(void *)a2 + 12LL) && *(_DWORD *)(a2 + 16) == 3 && *(_BYTE *)(v157 + 222) == 2) {
        sub_10002CAA0(v157, a2);
      }
    }

    else
    {
      sub_100033898(&v154, v157, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3773LL);
      if (*((void *)v154 + 15)) {
        sub_100033924( (_DWORD **)v154 + 15,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  3775LL);
      }
    }

    sub_10003389C((_DWORD **)&v157, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3780LL);
  }

  unint64_t v128 = v155;
  if (v155)
  {
    if (v154)
    {
LABEL_204:
      sub_10003389C((_DWORD **)&v155, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3815LL);
      goto LABEL_205;
    }

    size_t v131 = *(unsigned __int16 *)(v155 + 192);
    if (*(_WORD *)(v155 + 192))
    {
      if ((v33 & 1) != 0)
      {
        if (*(_DWORD *)(a2 + 16)) {
          goto LABEL_204;
        }
      }

      else if ((_DWORD)v147 != (_DWORD)v131 || memcmp(*(const void **)(v155 + 184), __s2, v131))
      {
        goto LABEL_204;
      }
    }

    sub_100033898(&v154, v128, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3802LL);
    if (*((void *)v154 + 15)) {
      sub_100033924( (_DWORD **)v154 + 15,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  3804LL);
    }
    goto LABEL_204;
  }

LABEL_205:
  uint64_t v129 = v154;
  if (!v154) {
    goto LABEL_228;
  }
  uint64_t v119 = (_DWORD *)*((void *)&v152 + 1);
  if (!*((void *)&v152 + 1)) {
    goto LABEL_228;
  }
  if (!*((void *)v154 + 15))
  {
    *(void *)&__int128 v158 = 0LL;
    uint64_t v144 = 0LL;
    sub_100033920(&v158, *((uint64_t *)&v152 + 1));
    uint64_t v119 = (_DWORD *)v158;
    if ((void)v158)
    {
      while (*((void *)v119 + 17))
      {
        uint64_t v130 = *((void *)v119 + 4);
        if (v130) {
          sub_100033920(&v144, v130);
        }
        sub_100033924((_DWORD **)&v158, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3854LL);
        if (v144)
        {
          sub_100033920(&v158, (uint64_t)v144);
          sub_100033924(&v144, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3857LL);
        }

        uint64_t v119 = (_DWORD *)v158;
        if (!(void)v158) {
          goto LABEL_227;
        }
      }

      if (*((_BYTE *)v154 + 222) == 2) {
        sub_100033920((void *)v154 + 15, (uint64_t)v119);
      }
      sub_100033924((_DWORD **)&v158, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3849LL);
    }

LABEL_227:
    uint64_t v129 = v154;
LABEL_228:
    if (!v129) {
      goto LABEL_240;
    }
  }

  int v132 = *((unsigned __int8 *)v129 + 222);
  if (v132 == 5 && v129 == v156)
  {
    if (*(_DWORD *)(a2 + 16) == 3)
    {
      __int128 v158 = *(_OWORD *)(v129 + 14);
      int v159 = v129[18];
      char v134 = sub_100040144((int *)&v158, (uint64_t)v119, v48, v24, v25, v26, v27, v28);
      sub_10006221C("Reclaiming REQUESTed abandoned IP address %s.", v135, v136, v137, v138, v139, v140, v141, v134);
      goto LABEL_240;
    }
  }

  else if (v132 != 5)
  {
    goto LABEL_240;
  }

  if (a4) {
    *a4 = 1;
  }
  sub_10003389C(&v154, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3879LL);
LABEL_240:
  if ((v33 & 1) == 0) {
    sub_100034EA8( &v145,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  3884LL,  v24,  v25,  v26,  v27,  v28);
  }
  if ((void)v152) {
    sub_10003389C((_DWORD **)&v152, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3887LL);
  }
  if (v155) {
    sub_10003389C((_DWORD **)&v155, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3889LL);
  }
  if (v157) {
    sub_10003389C((_DWORD **)&v157, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3891LL);
  }
  if (v156) {
    sub_10003389C(&v156, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3893LL);
  }
  if (*((void *)&v152 + 1)) {
    sub_100033924((_DWORD **)&v152 + 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3895LL);
  }
  if (!v154) {
    return 0LL;
  }
  sub_100033898(a1, v154, a7, v143);
  sub_10003389C(&v154, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3903LL);
  return 1LL;
}

uint64_t sub_1000129D8( uint64_t a1, _DWORD *a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a3) {
    return 0LL;
  }
  int v9 = (void *)a3;
  uint64_t v12 = 0LL;
  do
  {
    uint64_t v13 = (uint64_t *)v9[8];
    in_addr v14 = (uint64_t *)v9[7];
    if (v14)
    {
    }

    uint64_t v15 = v9[20];
    if (!v15)
    {
      uint64_t v17 = v9[11];
      if (v17) {
        goto LABEL_28;
      }
      unsigned int v18 = v9 + 13;
      goto LABEL_27;
    }

    if (!*(_DWORD *)(v15 + 240))
    {
      uint64_t v17 = v9[11];
      uint64_t v19 = v9[12];
      if (v19)
      {
        if (v17 && *(void *)(v17 + 88) <= *(void *)(v19 + 88)
          || !sub_100028EA0(v19, (uint64_t)v14, a3, (uint64_t)a4, a5, a6, a7, a8))
        {
LABEL_24:
          *a4 = 1;
          if (v17) {
            goto LABEL_28;
          }
          goto LABEL_25;
        }

        uint64_t v17 = v9[12];
      }

LABEL_22:
      if (v17) {
        goto LABEL_28;
      }
      goto LABEL_25;
    }

    uint64_t v16 = v9[11];
    uint64_t v17 = v9[12];
    if (!v16) {
      goto LABEL_22;
    }
    if (v17 && *(void *)(v17 + 88) <= *(void *)(v16 + 88)
      || !sub_100028EA0(v16, (uint64_t)v14, a3, (uint64_t)a4, a5, a6, a7, a8))
    {
      goto LABEL_24;
    }

    uint64_t v17 = v9[11];
    if (v17) {
      goto LABEL_28;
    }
LABEL_25:
    unsigned int v18 = v9 + 13;
    uint64_t v20 = v9[13];
LABEL_27:
    uint64_t v17 = *v18;
    if (!v17) {
      goto LABEL_42;
    }
LABEL_28:
    uint64_t v21 = *(void *)(v17 + 88);
    if (!v12)
    {
LABEL_41:
      uint64_t v12 = v17;
      goto LABEL_42;
    }

    int v22 = *(unsigned __int8 *)(v17 + 222);
    if (*(_BYTE *)(v12 + 222) == 5)
    {
      if (v22 != 5) {
        goto LABEL_41;
      }
LABEL_32:
      if (v21 < *(void *)(v12 + 88)) {
        uint64_t v12 = v17;
      }
      goto LABEL_42;
    }

    if (v22 == 5) {
      goto LABEL_42;
    }
    if (*(_WORD *)(v12 + 192) || *(_BYTE *)(v12 + 203))
    {
      int v23 = *(unsigned __int16 *)(v17 + 192);
      if (!*(_WORD *)(v17 + 192) && !*(_BYTE *)(v17 + 203) || v21 < *(void *)(v12 + 88)) {
        goto LABEL_41;
      }
    }

    else
    {
      int v23 = *(unsigned __int16 *)(v17 + 192);
    }

    if (!v23 && !*(_BYTE *)(v17 + 203)) {
      goto LABEL_32;
    }
LABEL_42:
    int v9 = (void *)v9[4];
  }

  while (v9);
  if (!v12) {
    return 0LL;
  }
  if (*(_BYTE *)(v12 + 222) == 5)
  {
    __int128 v40 = *(_OWORD *)(v12 + 56);
    int v41 = *(_DWORD *)(v12 + 72);
    char v24 = sub_100040144((int *)&v40, (uint64_t)v14, a3, (uint64_t)a4, a5, a6, a7, a8);
    sub_10006221C("Reclaiming abandoned lease %s.", v25, v26, v27, v28, v29, v30, v31, v24);
  }

  if (*(void *)(v12 + 120))
  {
    __int128 v40 = *(_OWORD *)(v12 + 56);
    int v41 = *(_DWORD *)(v12 + 72);
    sub_100040144((int *)&v40, (uint64_t)v14, a3, (uint64_t)a4, a5, a6, a7, a8);
    sub_10006238C( "soft impossible condition (%s:%d): stale host %s found on lease %s",  v32,  v33,  v34,  v35,  v36,  v37,  v38,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c");
    sub_100033924( (_DWORD **)(v12 + 120),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  4096LL);
  }

  sub_100033898(a1, v12, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 4099LL);
  return 1LL;
}

  uint64_t v17 = "Invalid IPv6 address.";
LABEL_23:
  sub_100046D6C((uint64_t)a1, v17, a3, a4, a5, a6, a7, a8, (char)__s);
  sub_100046C4C(a1, 0);
  return 0LL;
}

_DWORD **sub_100012C74( _DWORD **result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v623 = 0LL;
  if (*(void *)(a2 + 232)) {
    return result;
  }
  char v8 = a5;
  int v10 = a3;
  uint64_t v12 = (uint64_t)result;
  int v615 = a6;
  uint64_t v13 = *(void *)(a2 + 264);
  if (a7)
  {
    uint64_t v14 = a7;
LABEL_5:
    sub_100033920(&v623, v14);
    goto LABEL_6;
  }

  uint64_t v14 = *(void *)(a2 + 120);
  if (v14) {
    goto LABEL_5;
  }
LABEL_6:
  uint64_t v614 = a4;
  uint64_t v15 = sub_100033928( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1519LL,  a3,  a4,  a5,  a6,  a7,  a8);
  uint64_t v23 = (uint64_t)v15;
  if (!v15) {
    sub_100061FB4("unable to allocate lease state!", v16, v17, v18, v19, v20, v21, v22, v606);
  }
  v15[32] = *(_DWORD *)(v12 + 148);
  sub_1000235CC( v15 + 34,  *(void *)(*(void *)(v12 + 104) + 40LL),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1524LL);
  if (sub_100040D4C(&qword_10008C168, *(void *)(v12 + 160), 54LL, v24, v25, v26, v27, v28)) {
    *(_DWORD *)(v23 + 132) = 1;
  }
  if (!*(_DWORD *)(v12 + 224))
  {
    uint64_t v34 = *(void *)(v12 + 160);
    if (*(_DWORD *)(v34 + 4) > dword_10008BF78)
    {
      uint64_t v35 = *(_DWORD **)(v34 + 8LL * dword_10008BF78 + 16);
      if (v35)
      {
        uint64_t v36 = *(void *)(v23 + 32);
        if (*(_DWORD *)(v36 + 4) <= dword_10008BF78 || !*(void *)(v36 + 8LL * dword_10008BF78 + 16))
        {
          sub_100033F18( (void *)(v36 + 8LL * dword_10008BF78 + 16),  v35,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1553LL,  v30,  v31,  v32,  v33);
          uint64_t v37 = *(void *)(v23 + 32);
          if (*(_DWORD *)(v37 + 4) <= dword_10008BF78) {
            *(_DWORD *)(v37 + 4) = dword_10008BF78 + 1;
          }
        }
      }
    }
  }

  if (v10 != 2 && *(void *)(a2 + 88) <= (uint64_t)xmmword_10008CE80)
  {
    if (*(void *)(a2 + 160)) {
      sub_10003DC78( (void **)(a2 + 160),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1571LL,  v29,  v30,  v31,  v32,  v33);
    }
    if (*(void *)(a2 + 168)) {
      sub_10003DC78( (void **)(a2 + 168),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1574LL,  v29,  v30,  v31,  v32,  v33);
    }
    if (*(void *)(a2 + 176)) {
      sub_10003DC78( (void **)(a2 + 176),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1577LL,  v29,  v30,  v31,  v32,  v33);
    }
  }

  sub_10003E0AC( 0LL,  (int *)v12,  a2,  0LL,  *(void *)(v12 + 160),  *(void *)(v23 + 32),  (uint64_t *)(a2 + 112),  *(void *)(*(void *)(a2 + 128) + 128LL),  0LL);
  uint64_t v43 = *(void *)(a2 + 136);
  if (v43) {
    sub_10003E0AC( 0LL,  (int *)v12,  a2,  0LL,  *(void *)(v12 + 160),  *(void *)(v23 + 32),  (uint64_t *)(a2 + 112),  *(void *)(v43 + 40),  *(void **)(*(void *)(v43 + 48) + 96LL));
  }
  int v44 = *(_DWORD *)(v12 + 168);
  for (int i = v44; i; --i)
  {
    uint64_t v45 = *(void *)(a2 + 136);
    if (v45) {
      uint64_t v46 = (void **)(v45 + 40);
    }
    else {
      uint64_t v46 = (void **)(*(void *)(a2 + 128) + 128LL);
    }
    sub_10003E0AC( 0LL,  (int *)v12,  a2,  0LL,  *(void *)(v12 + 160),  *(void *)(v23 + 32),  (uint64_t *)(a2 + 112),  *(void *)(*(void *)(v12 + 8LL * (v44 - 1) + 176) + 136LL),  *v46);
    int v44 = i - 1;
  }

  if (*(_DWORD *)(v12 + 16) == 3)
  {
    uint64_t v47 = (int *)sub_100040D4C(&qword_10008BF80, *(void *)(v23 + 32), 10LL, v38, v39, v40, v41, v42);
    v619 = (uint64_t *)v47;
    if (v47)
    {
      if (sub_100057AF8( &v616,  (unsigned int *)v12,  a2,  0LL,  *(void *)(v12 + 160),  *(void *)(v23 + 32),  (uint64_t *)(a2 + 112),  (uint64_t)v47,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x659u))
      {
        uint64_t v48 = *(unsigned __int16 *)(a2 + 192);
        if (!*(_WORD *)(a2 + 192)) {
          goto LABEL_61;
        }
        v620 = 0LL;
        sub_10002CE00( &v620,  *(const char **)(a2 + 184),  v48,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1631LL,  v40,  v41,  v42);
        uint64_t v49 = v620;
        if (v620)
        {
          while (v49 != (_DWORD *)a2 || *(void *)(a2 + 40))
          {
            v624 = 0LL;
            do
            {
              uint64_t v50 = *((void *)v49 + 5);
              if (v50)
              {
                sub_100033898(&v624, v50, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 1645LL);
                uint64_t v49 = v620;
              }

              if (v49 != (_DWORD *)a2)
              {
                unsigned int v51 = *((unsigned __int8 *)v49 + 222);
                BOOL v52 = v51 > 7;
                int v53 = (1 << v51) & 0xDA;
                if (v52 || v53 == 0) {
                  break;
                }
              }

              sub_10003389C(&v620, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 1653LL);
              if (v624)
              {
                sub_100033898(&v620, v624, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 1655LL);
                sub_10003389C(&v624, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 1656LL);
              }

              uint64_t v49 = v620;
            }

            while (v620);
            if (v624)
            {
              sub_10003389C(&v624, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 1660LL);
              uint64_t v49 = v620;
            }

            if (v49)
            {
              sub_10002CAA0((uint64_t)v49, v12);
              sub_10003389C(&v620, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 1663LL);
              v620 = 0LL;
              sub_10002CE00( &v620,  *(const char **)(a2 + 184),  *(unsigned __int16 *)(a2 + 192),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1631LL,  v55,  v56,  v57);
              uint64_t v49 = v620;
              if (v620) {
                continue;
              }
            }

            goto LABEL_56;
          }

          sub_10003389C(&v620, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 1635LL);
        }

LABEL_81:
  v620 = 0LL;
  __src = 0LL;
  size_t __n = 0LL;
  if (v10 == 2)
  {
    uint64_t v67 = (int *)sub_100040D4C(&qword_10008BF80, *(void *)(v23 + 32), 14LL, v38, v39, v40, v41, v42);
    v619 = (uint64_t *)v67;
    if (v67)
    {
      if (sub_100057AA4( &v620,  (unsigned int *)v12,  a2,  0LL,  *(void *)(v12 + 160),  *(void *)(v23 + 32),  (uint64_t *)(a2 + 112),  (uint64_t)v67,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x6C0u))
      {
        if ((_DWORD)__n && bswap32(*(unsigned __int16 *)(*(void *)v12 + 8LL)) >> 16 < *(unsigned __int8 *)__src)
        {
          sub_1000622D4( "%s: configured min-secs value (%d) is greater than secs field (%d).  message dropped.",  v68,  v69,  v38,  v39,  v40,  v41,  v42,  v8);
          sub_100034EA8( &v620,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1735LL,  v70,  v71,  v72,  v73,  v74);
          uint64_t result = sub_1000339CC( v23,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1736LL,  v75,  v76,  v77,  v78,  v79);
          if (!v623) {
            return result;
          }
          uint64_t v80 = 1738LL;
          return (_DWORD **)sub_100033924( &v623,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  v80);
        }

        sub_100034EA8( &v620,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1741LL,  v38,  v39,  v40,  v41,  v42);
      }
    }
  }

  uint64_t v81 = v623;
  if (!v623)
  {
    *(void *)&__int128 v626 = 0LL;
    uint64_t v82 = (int *)sub_100040D4C(&qword_10008C168, *(void *)(v12 + 160), 61LL, v38, v39, v40, v41, v42);
    v619 = (uint64_t *)v82;
    if (v82)
    {
      if (sub_100057AA4( &v620,  (unsigned int *)v12,  a2,  0LL,  *(void *)(v12 + 160),  *(void *)(v23 + 32),  (uint64_t *)(a2 + 112),  (uint64_t)v82,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x6E2u))
      {
        sub_100029E98( &v626,  (const char *)__src,  __n,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1763LL,  v83,  v84,  v85);
        sub_100034EA8( &v620,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1764LL,  v86,  v87,  v88,  v89,  v90);
        uint64_t v91 = v626;
        if ((void)v626)
        {
          uint64_t v92 = v626;
          while (*(void *)(v92 + 136))
          {
            uint64_t v92 = *(void *)(v92 + 32);
            if (!v92) {
              goto LABEL_98;
            }
          }

          sub_100033920(&v623, v92);
          uint64_t v91 = v626;
LABEL_98:
          if (v91) {
            sub_100033924( (_DWORD **)&v626,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1772LL);
          }
        }
      }
    }

    uint64_t v81 = v623;
    if (!v623)
    {
      sub_100029DE4( &v626,  *(_BYTE *)(*(void *)v12 + 1LL),  *(void *)v12 + 28LL,  *(unsigned __int8 *)(*(void *)v12 + 2LL),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1779LL);
      uint64_t v98 = v626;
      if ((void)v626)
      {
        uint64_t v99 = v626;
        while (*(void *)(v99 + 136))
        {
          uint64_t v99 = *(void *)(v99 + 32);
          if (!v99) {
            goto LABEL_107;
          }
        }

        sub_100033920(&v623, v99);
        uint64_t v98 = v626;
LABEL_107:
        if (v98) {
          sub_100033924( (_DWORD **)&v626,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1787LL);
        }
      }

      uint64_t v81 = v623;
      if (!v623) {
        goto LABEL_115;
      }
    }
  }

  uint64_t v100 = *((void *)v81 + 19);
  uint64_t v101 = *(void *)(a2 + 136);
  uint64_t v102 = (void **)(v101 ? v101 + 40 : *(void *)(a2 + 128) + 128LL);
  sub_10003E0AC( 0LL,  (int *)v12,  a2,  0LL,  *(void *)(v12 + 160),  *(void *)(v23 + 32),  (uint64_t *)(a2 + 112),  v100,  *v102);
  if (!v623)
  {
LABEL_115:
    uint64_t v103 = (int *)sub_100040D4C(&qword_10008BF80, *(void *)(v23 + 32), 6LL, v93, v94, v95, v96, v97);
    v619 = (uint64_t *)v103;
    if (v103)
    {
      if (!sub_100057AF8( &v616,  (unsigned int *)v12,  a2,  0LL,  *(void *)(v12 + 160),  *(void *)(v23 + 32),  (uint64_t *)(a2 + 112),  (uint64_t)v103,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x716u))
      {
        if (!v616) {
          sub_1000622D4("%s: unknown client", v104, v105, v93, v94, v95, v96, v97, v8);
        }
        uint64_t result = sub_1000339CC( v23,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1817LL,  v93,  v94,  v95,  v96,  v97);
        if (v623)
        {
          uint64_t v80 = 1819LL;
          return (_DWORD **)sub_100033924( &v623,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  v80);
        }

        return result;
      }
    }
  }

  if (!v10)
  {
    uint64_t v117 = (int *)sub_100040D4C(&qword_10008BF80, *(void *)(v23 + 32), 8LL, v93, v94, v95, v96, v97);
    v619 = (uint64_t *)v117;
    if (v117)
    {
      if (!sub_100057AF8( &v616,  (unsigned int *)v12,  a2,  0LL,  *(void *)(v12 + 160),  *(void *)(v23 + 32),  (uint64_t *)(a2 + 112),  (uint64_t)v117,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x728u))
      {
        if (!v616) {
          sub_1000622D4("%s: bootp disallowed", v118, v119, v93, v94, v95, v96, v97, v8);
        }
        uint64_t result = sub_1000339CC( v23,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1835LL,  v93,  v94,  v95,  v96,  v97);
        if (v623)
        {
          uint64_t v80 = 1837LL;
          return (_DWORD **)sub_100033924( &v623,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  v80);
        }

        return result;
      }
    }
  }

  unint64_t v106 = (int *)sub_100040D4C(&qword_10008BF80, *(void *)(v23 + 32), 9LL, v93, v94, v95, v96, v97);
  v619 = (uint64_t *)v106;
  if (!v106
    || sub_100057AF8( &v616,  (unsigned int *)v12,  a2,  0LL,  *(void *)(v12 + 160),  *(void *)(v23 + 32),  (uint64_t *)(a2 + 112),  (uint64_t)v106,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x73Au))
  {
    if (dword_10008BD80 && (*(_BYTE *)(a2 + 221) & 1) == 0)
    {
      uint64_t v114 = *(void *)(a2 + 144);
      if (!v114) {
        goto LABEL_145;
      }
      uint64_t v115 = *(unsigned int *)(v12 + 168);
      if ((_DWORD)v115)
      {
        uint64_t v116 = 0LL;
        while (*(void *)(v12 + 176 + 8 * v116) != v114)
        {
          if (v115 == ++v116)
          {
            int i = *(_DWORD *)(v12 + 168);
            goto LABEL_143;
          }
        }
      }

      else
      {
        LODWORD(v116) = 0;
      }

      int i = v116;
      if ((_DWORD)v116 == (_DWORD)v115)
      {
LABEL_143:
        sub_1000038C0(a2, v114, v107, v108, v109, v110, v111, v112);
        uint64_t v114 = *(void *)(a2 + 144);
      }

      if (!v114)
      {
LABEL_145:
        int i = 0;
        unsigned int v120 = *(_DWORD *)(v12 + 168);
        if (v120)
        {
          int v121 = 0;
          for (j = 0; j < v120; int i = j)
          {
            uint64_t v123 = *(void *)(v12 + 8LL * j + 176);
            if (*(_DWORD *)(v123 + 56))
            {
              ++v121;
              unsigned int j = i;
              unsigned int v120 = *(_DWORD *)(v12 + 168);
            }

            ++j;
          }

          if (v121 && i == *(_DWORD *)(v12 + 168))
          {
            sub_1000622D4( "%s: no available billing: lease limit reached in all matching classes",  v123,  v107,  v108,  v109,  v110,  v111,  v112,  v8);
            uint64_t result = sub_1000339CC( v23,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1889LL,  v124,  v125,  v126,  v127,  v128);
            if (!v623) {
              return result;
            }
            uint64_t v80 = 1891LL;
            return (_DWORD **)sub_100033924( &v623,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  v80);
          }
        }

        if (v10 == 2)
        {
          uint64_t v129 = *(void *)(a2 + 144);
          if (v129)
          {
            if (*(_BYTE *)(a2 + 222) != 2) {
              sub_1000038C0(a2, v129, v107, v108, v109, v110, v111, v112);
            }
          }
        }
      }
    }

    uint64_t v130 = (int *)sub_100040D4C(&qword_10008BF80, *(void *)(v23 + 32), 15LL, v108, v109, v110, v111, v112);
    v619 = (uint64_t *)v130;
    if (v130) {
      sub_100057AA4( (void *)(v23 + 80),  (unsigned int *)v12,  a2,  0LL,  *(void *)(v12 + 160),  *(void *)(v23 + 32),  (uint64_t *)(a2 + 112),  (uint64_t)v130,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x77Cu);
    }
    uint64_t v136 = (int *)sub_100040D4C(&qword_10008BF80, *(void *)(v23 + 32), 16LL, v131, v132, v133, v134, v135);
    v619 = (uint64_t *)v136;
    if (v136) {
      sub_100057AA4( (void *)(v23 + 104),  (unsigned int *)v12,  a2,  0LL,  *(void *)(v12 + 160),  *(void *)(v23 + 32),  (uint64_t *)(a2 + 112),  (uint64_t)v136,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x785u);
    }
    v625 = 0LL;
    unsigned int v137 = sub_10003387C((void **)&v625, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 1931LL);
    if (v137)
    {
      sub_100067900(v137);
      sub_1000622D4("%s: can't allocate temporary lease structure: %s", v143, v144, v145, v146, v147, v148, v149, v8);
      uint64_t result = sub_1000339CC( v23,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1935LL,  v150,  v151,  v152,  v153,  v154);
      if (!v623) {
        return result;
      }
      uint64_t v80 = 1937LL;
      return (_DWORD **)sub_100033924( &v623,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  v80);
    }

    unint64_t v155 = v625;
    v609 = (_DWORD *)(a2 + 56);
    int v156 = *(_DWORD *)(a2 + 72);
    *(_OWORD *)(v625 + 56) = *(_OWORD *)(a2 + 56);
    *((_DWORD *)v155 + 18) = v156;
    uint64_t v157 = xmmword_10008CE80;
    *((void *)v155 + 10) = xmmword_10008CE80;
    char v158 = v155[221];
    if (!v10)
    {
      v155[221] = v158 | 2;
      uint64_t v166 = 0x7FFFFFFF - v157;
      int v167 = (int *)sub_100040D4C(&qword_10008BF80, *(void *)(v23 + 32), 5LL, v138, v139, v140, v141, v142);
      v619 = (uint64_t *)v167;
      if (v167
        && sub_100057AA4( &v620,  (unsigned int *)v12,  a2,  0LL,  *(void *)(v12 + 160),  *(void *)(v23 + 32),  (uint64_t *)(a2 + 112),  (uint64_t)v167,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x8D5u))
      {
        if ((_DWORD)__n == 4) {
          uint64_t v166 = sub_100060B50((unsigned int *)__src);
        }
        sub_100034EA8( &v620,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2264LL,  v168,  v169,  v170,  v171,  v172);
      }

      uint64_t v173 = (int *)sub_100040D4C(&qword_10008BF80, *(void *)(v23 + 32), 4LL, v168, v169, v170, v171, v172);
      v619 = (uint64_t *)v173;
      if (v173
        && sub_100057AA4( &v620,  (unsigned int *)v12,  a2,  0LL,  *(void *)(v12 + 160),  *(void *)(v23 + 32),  (uint64_t *)(a2 + 112),  (uint64_t)v173,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x8E2u))
      {
        if ((_DWORD)__n == 4) {
          uint64_t v166 = sub_100060B50((unsigned int *)__src) - (void)xmmword_10008CE80;
        }
        sub_100034EA8( &v620,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2278LL,  v174,  v175,  v176,  v177,  v178);
      }

      uint64_t v179 = xmmword_10008CE80;
      uint64_t v180 = xmmword_10008CE80 + v166;
      *(void *)(v23 + 24) = xmmword_10008CE80 + v166;
      int v181 = v625;
      *((void *)v625 + 11) = v180;
      goto LABEL_253;
    }

    v155[221] = v158 & 0xFD;
    int v159 = (int *)sub_100040D4C(&qword_10008BF80, *(void *)(v23 + 32), 1LL, v138, v139, v140, v141, v142);
    v619 = (uint64_t *)v159;
    if (v159
      && sub_100057AA4( &v620,  (unsigned int *)v12,  a2,  0LL,  *(void *)(v12 + 160),  *(void *)(v23 + 32),  (uint64_t *)(a2 + 112),  (uint64_t)v159,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x7A8u))
    {
      if ((_DWORD)__n == 4) {
        uint64_t v165 = sub_100060B50((unsigned int *)__src);
      }
      else {
        uint64_t v165 = 43200LL;
      }
      sub_100034EA8( &v620,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1964LL,  v160,  v161,  v162,  v163,  v164);
    }

    else
    {
      uint64_t v165 = 43200LL;
    }

    uint64_t v182 = (int *)sub_100040D4C(&qword_10008C168, *(void *)(v12 + 160), 51LL, v160, v161, v162, v163, v164);
    v619 = (uint64_t *)v182;
    unint64_t v188 = v165;
    if (!v182) {
      goto LABEL_194;
    }
    int v189 = sub_100057AA4( &v620,  (unsigned int *)v12,  a2,  0LL,  *(void *)(v12 + 160),  *(void *)(v23 + 32),  (uint64_t *)(a2 + 112),  (uint64_t)v182,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x7B6u);
    if (v189 && (_DWORD)__n == 4)
    {
      int v618 = -1;
      if (*(_DWORD *)__src == -1)
      {
        uint64_t v210 = (int *)sub_100040D4C(&qword_10008BF80, *(void *)(v23 + 32), 47LL, v183, v184, v185, v186, v187);
        v619 = (uint64_t *)v210;
        if (v210)
        {
          if (sub_100057AF8( &v616,  (unsigned int *)v12,  a2,  0LL,  *(void *)(v12 + 160),  *(void *)(v23 + 32),  (uint64_t *)(a2 + 112),  (uint64_t)v210,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x7DCu))
          {
            uint64_t v218 = v625;
            v625[221] |= 4u;
            if (!v616)
            {
              __int128 v626 = *(_OWORD *)(v218 + 56);
              int v627 = *((_DWORD *)v218 + 18);
              char v219 = sub_100040144((int *)&v626, v211, v212, v213, v214, v215, v216, v217);
              sub_1000622D4( "Infinite-leasetime reservation made on %s.",  v220,  v221,  v222,  v223,  v224,  v225,  v226,  v219);
            }
          }
        }
      }

      unint64_t v188 = sub_100060B50((unsigned int *)__src);
    }

    else
    {
      unint64_t v188 = v165;
      if (!v189) {
        goto LABEL_194;
      }
    }

    sub_100034EA8( &v620,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2025LL,  v183,  v184,  v185,  v186,  v187);
LABEL_194:
    uint64_t v190 = (int *)sub_100040D4C(&qword_10008BF80, *(void *)(v23 + 32), 2LL, v183, v184, v185, v186, v187);
    v619 = (uint64_t *)v190;
    uint64_t v610 = v165;
    if (v190
      && sub_100057AA4( &v620,  (unsigned int *)v12,  a2,  0LL,  *(void *)(v12 + 160),  *(void *)(v23 + 32),  (uint64_t *)(a2 + 112),  (uint64_t)v190,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x7F3u))
    {
      uint64_t v196 = v13;
      if ((_DWORD)__n == 4) {
        unint64_t v197 = sub_100060B50((unsigned int *)__src);
      }
      else {
        unint64_t v197 = 86400LL;
      }
      sub_100034EA8( &v620,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2039LL,  v191,  v192,  v193,  v194,  v195);
      if (v188 >= v197) {
        uint64_t v198 = v197;
      }
      else {
        uint64_t v198 = v188;
      }
      if (v197 >= 0x12C) {
        uint64_t v199 = 300LL;
      }
      else {
        uint64_t v199 = v197;
      }
      uint64_t v13 = v196;
    }

    else
    {
      if (v188 >= 0x15180) {
        uint64_t v198 = 86400LL;
      }
      else {
        uint64_t v198 = v188;
      }
      uint64_t v199 = 300LL;
    }

    uint64_t v200 = (int *)sub_100040D4C(&qword_10008BF80, *(void *)(v23 + 32), 3LL, v191, v192, v193, v194, v195);
    v619 = (uint64_t *)v200;
    if (v200
      && sub_100057AA4( &v620,  (unsigned int *)v12,  a2,  0LL,  *(void *)(v12 + 160),  *(void *)(v23 + 32),  (uint64_t *)(a2 + 112),  (uint64_t)v200,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x80Au))
    {
      if ((_DWORD)__n == 4) {
        uint64_t v199 = sub_100060B50((unsigned int *)__src);
      }
      sub_100034EA8( &v620,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2061LL,  v174,  v175,  v176,  v177,  v178);
    }

    v620 = 0LL;
    __src = 0LL;
    size_t __n = 0LL;
    if (!*(void *)(a2 + 136)) {
      goto LABEL_243;
    }
    uint64_t v201 = (int *)sub_100040D4C(&qword_10008BF80, *(void *)(v23 + 32), 50LL, v174, v175, v176, v177, v178);
    v619 = (uint64_t *)v201;
    if (!v201
      || !sub_100057AA4( &v620,  (unsigned int *)v12,  a2,  0LL,  *(void *)(v12 + 160),  *(void *)(v23 + 32),  (uint64_t *)(a2 + 112),  (uint64_t)v201,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x81Bu))
    {
LABEL_238:
      uint64_t v237 = *(void **)(a2 + 136);
      if (v237)
      {
        uint64_t v238 = v237[18];
        uint64_t v179 = xmmword_10008CE80;
        if (v238 && (uint64_t)xmmword_10008CE80 < v238)
        {
          int v239 = *((_DWORD *)v625 + 15);
          LODWORD(v626) = 4;
          DWORD1(v626) = v239;
          sub_100015424((void *)v12, &v626, v202, v174, v175, v176, v177, v178);
          sub_1000339CC( v23,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2128LL,  v240,  v241,  v242,  v243,  v244);
          uint64_t result = (_DWORD **)sub_10003389C( (_DWORD **)&v625,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2129LL);
          if (v623)
          {
            uint64_t v80 = 2131LL;
            return (_DWORD **)sub_100033924( &v623,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  v80);
          }

          return result;
        }

        uint64_t v299 = v237[19];
        if (v299)
        {
          BOOL v52 = v299 <= (uint64_t)xmmword_10008CE80;
          uint64_t v300 = v299 - xmmword_10008CE80;
          if (v52)
          {
            int v598 = *((_DWORD *)v625 + 15);
            LODWORD(v626) = 4;
            DWORD1(v626) = v598;
            sub_100015424((void *)v12, &v626, v202, v174, v175, v176, v177, v178);
            sub_1000339CC( v23,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2158LL,  v599,  v600,  v601,  v602,  v603);
            uint64_t result = (_DWORD **)sub_10003389C( (_DWORD **)&v625,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2159LL);
            if (v623)
            {
              uint64_t v80 = 2161LL;
              return (_DWORD **)sub_100033924( &v623,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  v80);
            }

            return result;
          }

          if (v198 >= v300) {
            uint64_t v198 = v300;
          }
        }

        uint64_t v301 = v610;
        if (v199) {
          uint64_t v301 = v199;
        }
        if (v198 >= v199) {
          uint64_t v302 = v198;
        }
        else {
          uint64_t v302 = v301;
        }
        uint64_t v303 = v237[20];
        if (v303)
        {
          v304 = v625;
          __int128 v305 = *(_OWORD *)(a2 + 248);
          *(_OWORD *)(v625 + 248) = v305;
          uint64_t v306 = *(unsigned int *)(v303 + 160);
          uint64_t v246 = v302;
          uint64_t v247 = v614;
          if (v302 > v306)
          {
            if ((uint64_t)v305 <= v179)
            {
              uint64_t v246 = v306;
            }

            else if (v179 + v302 <= (uint64_t)v305 + v306)
            {
              uint64_t v246 = v302;
            }

            else
            {
              uint64_t v246 = v305 + v306 - v179;
            }
          }

          if (v10 == 5)
          {
            if (v246 >= 0) {
              uint64_t v604 = v246;
            }
            else {
              uint64_t v604 = v246 + 1;
            }
            uint64_t v605 = v302 + (v604 >> 1) + v179;
            *((void *)v304 + 30) = v605;
          }

          else
          {
            *((void *)v304 + 30) = *(void *)(a2 + 240);
          }
        }

        else
        {
          uint64_t v246 = v302;
          uint64_t v247 = v614;
        }

        if (v246 < 0)
        {
          uint64_t v248 = 2147483646LL;
LABEL_250:
          *(void *)(v23 + 24) = v248;
          int v181 = v625;
          if (v247) {
            uint64_t v248 = v247;
          }
          *((void *)v625 + 11) = v248;
          if (v10 != 5)
          {
            char v249 = *(_BYTE *)(a2 + 222);
            goto LABEL_255;
          }

LABEL_253:
          char v249 = 2;
LABEL_255:
          v181[223] = v249;
          *((void *)v181 + 33) = v179;
          uint64_t v250 = (int *)sub_100040D4C(&qword_10008C168, *(void *)(v12 + 160), 61LL, v174, v175, v176, v177, v178);
          v619 = (uint64_t *)v250;
          if (v250
            && sub_100057AA4( &v620,  (unsigned int *)v12,  a2,  0LL,  *(void *)(v12 + 160),  *(void *)(v23 + 32),  (uint64_t *)(a2 + 112),  (uint64_t)v250,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x8F8u))
          {
            uint64_t v256 = v13;
            unsigned __int16 v257 = __n;
            uint64_t v258 = v625;
            if (__n > 7)
            {
              *((_WORD *)v625 + 97) = __n;
              *((_WORD *)v258 + 96) = v257;
              char v264 = sub_10005CDE4(v257);
              int v272 = v264;
              if (!v264) {
                sub_100061FB4("no memory for large uid.", v265, v266, v267, v268, v269, v270, v271, v607);
              }
              memcpy(v264, __src, *((unsigned __int16 *)v625 + 96));
              *((void *)v625 + 23) = v272;
            }

            else
            {
              memcpy(v625 + 196, __src, __n);
              *((void *)v258 + 23) = v258 + 196;
              *((_WORD *)v258 + 97) = 7;
              *((_WORD *)v258 + 96) = v257;
            }

            uint64_t v13 = v256;
            sub_100034EA8( &v620,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2313LL,  v259,  v260,  v261,  v262,  v263);
          }

          if (v623)
          {
            sub_100033920((void *)v625 + 15, (uint64_t)v623);
            sub_100033924(&v623, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 2318LL);
          }

          uint64_t v273 = *(void *)(a2 + 128);
          if (v273) {
            sub_1000235CC(v625 + 128, v273, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 2321LL);
          }
          uint64_t v274 = *(void *)(a2 + 144);
          if (v274) {
            sub_1000338BC(v625 + 144, v274, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 2324LL);
          }
          *(_BYTE *)(a2 + 221) = *(_BYTE *)(a2 + 221) & 0xF7 | (8 * (v615 != 0));
          int v275 = *(_DWORD **)(a2 + 112);
          if (v275)
          {
            sub_100033F18( (void *)v625 + 14,  v275,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2335LL,  v252,  v253,  v254,  v255);
            sub_10005515C( (void *)(a2 + 112),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2336LL,  v276,  v277,  v278,  v279,  v280);
          }

          int v281 = *(_DWORD **)(a2 + 152);
          if (v281) {
            sub_100033F18( (void *)v625 + 19,  v281,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2340LL,  v252,  v253,  v254,  v255);
          }
          if (!*(_DWORD *)(v12 + 224))
          {
            uint64_t v282 = *(void *)(v12 + 160);
            if (*(_DWORD *)(v282 + 4) > dword_10008BF78)
            {
              if (*(void *)(v282 + 8LL * dword_10008BF78 + 16))
              {
                int v283 = (int *)sub_100040D4C(&qword_10008BF80, *(void *)(v23 + 32), 37LL, v251, v252, v253, v254, v255);
                v619 = (uint64_t *)v283;
                if (!v283
                  || sub_100057AF8( &v616,  (unsigned int *)v12,  a2,  0LL,  *(void *)(v12 + 160),  *(void *)(v23 + 32),  (uint64_t *)(a2 + 112),  (uint64_t)v283,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x936u))
                {
                  v284 = v625;
                  if (*((void *)v625 + 19))
                  {
                    sub_100033F88( (void *)v625 + 19,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2360LL,  v251,  v252,  v253,  v254,  v255);
                    v284 = v625;
                  }

                  sub_100033F18( (void *)v284 + 19,  *(_DWORD **)(*(void *)(v12 + 160) + 8LL * dword_10008BF78 + 16),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2365LL,  v252,  v253,  v254,  v255);
                }
              }
            }
          }

          __int128 v285 = (int *)sub_100040D4C(&qword_10008C168, *(void *)(v12 + 160), 12LL, v251, v252, v253, v254, v255);
          v619 = (uint64_t *)v285;
          if (v285)
          {
            int v290 = sub_100057AA4( &v620,  (unsigned int *)v12,  0LL,  0LL,  *(void *)(v12 + 160),  0LL,  &qword_10008C730,  (uint64_t)v285,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x948u);
            if (v619)
            {
              if (v290)
              {
                __int128 v291 = *(const void **)(a2 + 104);
                if (v291)
                {
                  size_t v292 = strlen(*(const char **)(a2 + 104));
                  int v293 = __n;
                  if (v292 == __n && !memcmp(v291, __src, v292))
                  {
                    sub_100034EA8( &v620,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2385LL,  v294,  v295,  v296,  v297,  v298);
                    *((void *)v625 + 13) = *(void *)(a2 + 104);
                    *(void *)(a2 + 104) = 0LL;
                    goto LABEL_308;
                  }
                }

                else
                {
                  int v293 = __n;
                }

                v307 = sub_10005CDE4((v293 + 1));
                *((void *)v625 + 13) = v307;
                if (v307)
                {
                  memcpy(v307, __src, __n);
                  *(_BYTE *)(*((void *)v625 + 13) + __n) = 0;
                }

                else
                {
                  sub_10006221C("no memory for client hostname.", v308, v309, v310, v311, v312, v313, v314, v608);
                }

                sub_100034EA8( &v620,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2396LL,  v315,  v316,  v317,  v318,  v319);
              }
            }
          }

LABEL_308:
          uint64_t v320 = *(void *)v12;
          v321 = v625;
          v625[203] = *(_BYTE *)(*(void *)v12 + 2LL) + 1;
          v321[204] = *(_BYTE *)(v320 + 1);
          *(_OWORD *)(v321 + 205) = *(_OWORD *)(*(void *)v12 + 28LL);
          v322 = *(_DWORD **)(a2 + 168);
          v321[221] = *(_BYTE *)(a2 + 221) & 0xCF;
          if (v322 && (v10 == 5 || !v10))
          {
            sub_10003D510( 0LL,  (int *)v12,  (uint64_t)v321,  0LL,  *(void *)(v12 + 160),  *(void *)(v23 + 32),  (uint64_t *)v321 + 14,  v322);
            if (*(void *)(a2 + 168)) {
              sub_10003DC78( (void **)(a2 + 168),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2417LL,  v286,  v287,  v288,  v289,  (uint64_t)v322);
            }
          }

          size_t v323 = v10 == 5 || v10 == 0;
          if (v10 == 5 || !v10)
          {
            v324 = (int *)sub_100040D4C( &qword_10008BF80,  *(void *)(v23 + 32),  30LL,  v286,  v287,  v288,  v289,  (uint64_t)v322);
            v619 = (uint64_t *)v324;
            if (!v324
              || sub_100057AF8( &v616,  (unsigned int *)v12,  (uint64_t)v625,  0LL,  *(void *)(v12 + 160),  *(void *)(v23 + 32),  (uint64_t *)v625 + 14,  (uint64_t)v324,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x97Du))
            {
              sub_10000E340(v12, (uint64_t)v625, a2, 0LL, 0LL, *(void *)(v23 + 32), v289, (uint64_t)v322);
            }
          }

          if ((*(_BYTE *)(a2 + 221) & 1) != 0)
          {
            uint64_t v337 = *(void *)v12;
            *(_BYTE *)(a2 + 203) = *(_BYTE *)(*(void *)v12 + 2LL) + 1;
            *(_BYTE *)(a2 + 204) = *(_BYTE *)(v337 + 1);
            *(_OWORD *)(a2 + 205) = *(_OWORD *)(*(void *)v12 + 28LL);
          }

          else if (!sub_10002B1D0(a2, (uint64_t)v625, v323, v10 == 5, v10 == 5, v288, v289, (uint64_t)v322))
          {
            sub_1000622D4("%s: database update failed", v325, v326, v327, v328, v329, v330, v331, v8);
            sub_1000339CC( v23,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2469LL,  v332,  v333,  v334,  v335,  v336);
            return (_DWORD **)sub_10003389C( (_DWORD **)&v625,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2470LL);
          }

          sub_10003389C( (_DWORD **)&v625,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2474LL);
          uint64_t v338 = *(void *)(v12 + 104);
          *(_BYTE *)(v23 + 165) = v10;
          *(void *)(v23 + 8) = v338;
          uint64_t v339 = *(void *)v12;
          *(_DWORD *)(v23 + 160) = *(_DWORD *)(*(void *)v12 + 24LL);
          *(_DWORD *)(v23 + 152) = *(_DWORD *)(v339 + 12);
          *(_DWORD *)(v23 + 144) = *(_DWORD *)(v339 + 4);
          *(_DWORD *)(v23 + 148) = *(_DWORD *)(v339 + 8);
          *(_BYTE *)(v23 + 164) = *(_BYTE *)(v339 + 3);
          v345 = (int *)sub_100040D4C(&qword_10008BF80, *(void *)(v23 + 32), 22LL, v340, v341, v342, v343, v344);
          v619 = (uint64_t *)v345;
          if (v345
            && sub_100057AF8( &v616,  (unsigned int *)v12,  a2,  0LL,  *(void *)(v12 + 160),  *(void *)(v23 + 32),  (uint64_t *)(a2 + 112),  (uint64_t)v345,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x9BFu))
          {
            *(_WORD *)(v23 + 150) |= 0x80u;
          }

          v351 = (int *)sub_100040D4C(&qword_10008C168, *(void *)(v12 + 160), 57LL, v346, v347, v348, v349, v350);
          v619 = (uint64_t *)v351;
          if (v351
            && sub_100057AA4( &v620,  (unsigned int *)v12,  a2,  0LL,  *(void *)(v12 + 160),  *(void *)(v23 + 32),  (uint64_t *)(a2 + 112),  (uint64_t)v351,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x9CAu))
          {
            int v357 = __n;
            uint64_t v358 = 2509LL;
          }

          else
          {
            v359 = (int *)sub_100040D4C(&qword_10008C168, *(void *)(v23 + 32), 57LL, v352, v353, v354, v355, v356);
            v619 = (uint64_t *)v359;
            if (!v359
              || !sub_100057AA4( &v620,  (unsigned int *)v12,  a2,  0LL,  *(void *)(v12 + 160),  *(void *)(v23 + 32),  (uint64_t *)(a2 + 112),  (uint64_t)v359,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x9D5u))
            {
LABEL_337:
              char v613 = v8;
              v619 = (uint64_t *)sub_100040D4C( &qword_10008C168,  *(void *)(v12 + 160),  118LL,  v352,  v353,  v354,  v355,  v356);
              if (v619)
              {
                *(void *)&__int128 v626 = 0LL;
                if (sub_100034540( &v626,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2532LL,  v360,  v361,  v362,  v363,  v364))
                {
                  v370 = v619;
                  if (*((_DWORD *)v619 + 12))
                  {
                    sub_100034E60( v626 + 32,  (uint64_t)(v619 + 4),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2535LL,  v366,  v367,  v368,  v369);
                    v370 = v619;
                  }

                  v371 = (_DWORD *)v370[2];
                  if (v371)
                  {
                    sub_100033F18( (void *)(v626 + 16),  v371,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2538LL,  v366,  v367,  v368,  v369);
                    v370 = v619;
                  }

                  uint64_t v372 = v370[3];
                  if (v372) {
                    sub_100052CB0((void *)(v626 + 24), v372);
                  }
                }

                sub_100043E20(&qword_10008C168, *(void *)(v23 + 32), v626, v365, v366, v367, v368, v369);
                sub_100040E08( (int **)&v626,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2545LL,  v373,  v374,  v375,  v376,  v377);
              }

              if (*(_BYTE *)(v23 + 165))
              {
                int i = 53;
                v619 = 0LL;
                if (sub_100034540( &v619,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2553LL,  v360,  v361,  v362,  v363,  v364))
                {
                  if (sub_1000545BC( v619 + 2,  (const void *)(v23 + 165),  1,  0LL,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2555LL,  v382))
                  {
                    sub_100029804( v619 + 3,  qword_10008C1E0,  &i,  0LL,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2558LL);
                    sub_100043E20(&qword_10008C168, *(void *)(v23 + 32), (uint64_t)v619, v388, v389, v390, v391, v392);
                  }

                  sub_100040E08( (int **)&v619,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2562LL,  v383,  v384,  v385,  v386,  v387);
                }

                sub_1000158D4(&v618, *(void *)(v23 + 32), v12, v378, v379, v380, v381, v382);
                int v393 = v618;
                *(_DWORD *)(v23 + 168) = 4;
                *(_DWORD *)(v23 + 172) = v393;
                uint64_t v394 = *(void *)(v23 + 24);
                uint64_t v395 = v394 - xmmword_10008CE80;
                sub_100060B6C((_DWORD *)(v23 + 68), v394 - xmmword_10008CE80);
                int i = 51;
                v619 = 0LL;
                if (sub_100034540( &v619,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2575LL,  v396,  v397,  v398,  v399,  v400))
                {
                  if (sub_1000545BC( v619 + 2,  (const void *)(v23 + 68),  4,  0LL,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2577LL,  v401))
                  {
                    sub_100029804( v619 + 3,  qword_10008C1E0,  &i,  0LL,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2580LL);
                    sub_100043E20(&qword_10008C168, *(void *)(v23 + 32), (uint64_t)v619, v407, v408, v409, v410, v411);
                  }

                  sub_100040E08( (int **)&v619,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2584LL,  v402,  v403,  v404,  v405,  v406);
                }

                if (v395 >= 0) {
                  uint64_t v412 = v395;
                }
                else {
                  uint64_t v412 = v395 + 1;
                }
                uint64_t v413 = v412 >> 1;
                sub_100060B6C((_DWORD *)(v23 + 72), v412 >> 1);
                int i = 58;
                v619 = 0LL;
                if (sub_100034540( &v619,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2592LL,  v414,  v415,  v416,  v417,  v418))
                {
                  if (sub_1000545BC( v619 + 2,  (const void *)(v23 + 72),  4,  0LL,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2594LL,  v419))
                  {
                    sub_100029804( v619 + 3,  qword_10008C1E0,  &i,  0LL,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2597LL);
                    sub_100043E20(&qword_10008C168, *(void *)(v23 + 32), (uint64_t)v619, v425, v426, v427, v428, v429);
                  }

                  sub_100040E08( (int **)&v619,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2601LL,  v420,  v421,  v422,  v423,  v424);
                }

                sub_100060B6C((_DWORD *)(v23 + 76), v395 / 4 + v395 / 8 + v413);
                int i = 59;
                v619 = 0LL;
                if (sub_100034540( &v619,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2610LL,  v430,  v431,  v432,  v433,  v434))
                {
                  if (sub_1000545BC( v619 + 2,  (const void *)(v23 + 76),  4,  0LL,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2612LL,  v364))
                  {
                    sub_100029804( v619 + 3,  qword_10008C1E0,  &i,  0LL,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2615LL);
                    sub_100043E20(&qword_10008C168, *(void *)(v23 + 32), (uint64_t)v619, v440, v441, v442, v443, v444);
                  }

                  sub_100040E08( (int **)&v619,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2619LL,  v435,  v436,  v437,  v438,  v439);
                }
              }

              else
              {
                uint64_t v445 = *(void *)(v23 + 8);
                if (*(_DWORD *)(v445 + 80))
                {
                  *(_DWORD *)(v23 + 168) = 4;
                  *(_DWORD *)(v23 + 172) = **(_DWORD **)(v445 + 72);
                }
              }

              *(_DWORD *)(v23 + 156) = 0;
              v446 = (int *)sub_100040D4C(&qword_10008BF80, *(void *)(v23 + 32), 17LL, v360, v361, v362, v363, v364);
              v619 = (uint64_t *)v446;
              if (v446
                && sub_100057AA4( &v620,  (unsigned int *)v12,  a2,  0LL,  *(void *)(v12 + 160),  *(void *)(v23 + 32),  (uint64_t *)(a2 + 112),  (uint64_t)v446,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0xA50u))
              {
                sub_100034EA8( &v620,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2645LL,  v447,  v448,  v449,  v450,  v451);
              }

              int i = 1;
              if (!sub_100040D4C(&qword_10008C168, *(void *)(v23 + 32), 1LL, v447, v448, v449, v450, v451))
              {
                v619 = 0LL;
                if (sub_100034540( &v619,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2654LL,  v452,  v453,  v454,  v455,  v456))
                {
                  if (sub_1000545BC( v619 + 2,  (const void *)(*(void *)(a2 + 128) + 108LL),  *(_DWORD *)(*(void *)(a2 + 128) + 104LL),  0LL,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2658LL,  v456))
                  {
                    sub_100029804( v619 + 3,  qword_10008C1E0,  &i,  0LL,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2661LL);
                    sub_100043E20(&qword_10008C168, *(void *)(v23 + 32), (uint64_t)v619, v462, v463, v464, v465, v466);
                  }

                  sub_100040E08( (int **)&v619,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2665LL,  v457,  v458,  v459,  v460,  v461);
                }
              }

              int i = 12;
              if (!sub_100040D4C(&qword_10008C168, *(void *)(v23 + 32), 12LL, v452, v453, v454, v455, v456))
              {
                uint64_t v550 = *(void *)(a2 + 120);
                if (v550)
                {
                  if (*(void *)(v550 + 48))
                  {
                    uint64_t v551 = *(void *)(v12 + 160);
                    uint64_t v552 = *(void *)(v23 + 32);
                    uint64_t v553 = sub_100040D4C(&qword_10008BF80, v552, 12LL, v467, v468, v469, v470, v471);
                    if (sub_100057AF8( &v616,  (unsigned int *)v12,  a2,  0LL,  v551,  v552,  (uint64_t *)(a2 + 112),  v553,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0xA77u))
                    {
                      v619 = 0LL;
                      if (sub_100034540( &v619,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2681LL,  v467,  v468,  v469,  v470,  v471))
                      {
                        int v554 = strlen(*(const char **)(*(void *)(a2 + 120) + 48LL));
                        if (sub_1000545BC( v619 + 2,  *(const void **)(*(void *)(a2 + 120) + 48LL),  v554,  1LL,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2686LL,  v555))
                        {
                          sub_100029804( v619 + 3,  qword_10008C1E0,  &i,  0LL,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2689LL);
                          sub_100043E20( &qword_10008C168,  *(void *)(v23 + 32),  (uint64_t)v619,  v561,  v562,  v563,  v564,  v565);
                        }

                        sub_100040E08( (int **)&v619,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2693LL,  v556,  v557,  v558,  v559,  v560);
                      }
                    }
                  }
                }
              }

              int i = 12;
              if (!sub_100040D4C(&qword_10008C168, *(void *)(v23 + 32), 12LL, v467, v468, v469, v470, v471))
              {
                uint64_t v566 = *(void *)(v12 + 160);
                uint64_t v567 = *(void *)(v23 + 32);
                uint64_t v568 = sub_100040D4C(&qword_10008BF80, v567, 11LL, v472, v473, v474, v475, v476);
                if (sub_100057AF8( &v616,  (unsigned int *)v12,  a2,  0LL,  v566,  v567,  (uint64_t *)(a2 + 112),  v568,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0xA91u))
                {
                  LODWORD(v626) = *(_DWORD *)(a2 + 60);
                  v569 = gethostbyaddr(&v626, 4u, 2);
                  if (v569)
                  {
                    p_h_name = (const char **)&v569->h_name;
                    v619 = 0LL;
                    if (sub_100034540( &v619,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2716LL,  v570,  v571,  v572,  v573,  v574))
                    {
                      v576 = *p_h_name;
                      int v577 = strlen(v576);
                      if (sub_1000545BC( v619 + 2,  v576,  v577 + 1,  1LL,  1LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2721LL,  v578))
                      {
                        sub_100029804( v619 + 3,  qword_10008C1E0,  &i,  0LL,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2724LL);
                        sub_100043E20( &qword_10008C168,  *(void *)(v23 + 32),  (uint64_t)v619,  v584,  v585,  v586,  v587,  v588);
                      }

                      sub_100040E08( (int **)&v619,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2728LL,  v579,  v580,  v581,  v582,  v583);
                    }
                  }

                  else
                  {
                    v589.s_addr = v626;
                    char v590 = inet_ntoa(v589);
                    sub_10006221C("No hostname for %s", v591, v592, v593, v594, v595, v596, v597, v590);
                  }
                }
              }

              uint64_t v477 = *(void *)(v12 + 160);
              uint64_t v478 = *(void *)(v23 + 32);
              uint64_t v479 = sub_100040D4C(&qword_10008BF80, v478, 13LL, v472, v473, v474, v475, v476);
              if (sub_100057AF8( &v616,  (unsigned int *)v12,  a2,  0LL,  v477,  v478,  (uint64_t *)(a2 + 112),  v479,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0xAB5u))
              {
                int i = 3;
                v619 = (uint64_t *)sub_100040D4C( &qword_10008C168,  *(void *)(v23 + 32),  3LL,  v480,  v481,  v482,  v483,  v484);
                if (!v619)
                {
                  v619 = 0LL;
                  if (sub_100034540( &v619,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2746LL,  v480,  v481,  v482,  v483,  v484))
                  {
                    if (sub_1000545BC( v619 + 2,  (const void *)(a2 + 60),  *(_DWORD *)(a2 + 56),  0LL,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2750LL,  v484))
                    {
                      sub_100029804( v619 + 3,  qword_10008C1E0,  &i,  0LL,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2753LL);
                      sub_100043E20( &qword_10008C168,  *(void *)(v23 + 32),  (uint64_t)v619,  v490,  v491,  v492,  v493,  v494);
                    }

                    sub_100040E08( (int **)&v619,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2757LL,  v485,  v486,  v487,  v488,  v489);
                  }
                }
              }

              int i = 21;
              v495 = (int *)sub_100040D4C(&qword_10008BF80, *(void *)(v23 + 32), 21LL, v480, v481, v482, v483, v484);
              v619 = (uint64_t *)v495;
              if (v495
                && sub_100057AA4( &v620,  (unsigned int *)v12,  a2,  0LL,  *(void *)(v12 + 160),  *(void *)(v23 + 32),  (uint64_t *)(a2 + 112),  (uint64_t)v495,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0xAD1u))
              {
                *(void *)&__int128 v626 = 0LL;
                if (!sub_100029804( &v626,  qword_10008C560,  __src,  __n,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2774LL)) {
                  return (_DWORD **)sub_10006221C( "unknown option space %s.",  v501,  v502,  v503,  v504,  v505,  v506,  v507,  (char)__src);
                }
                uint64_t v508 = v626;
                *(_DWORD *)(*(void *)(v23 + 32) + 8LL) = *(_DWORD *)(v626 + 136);
                *(_DWORD *)(*(void *)(v23 + 32) + 12LL) = sub_100015A70(v508);
                sub_100034EA8( &v620,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2781LL,  v509,  v510,  v511,  v512,  v513);
                uint64_t v514 = *(void *)(v23 + 32);
              }

              else
              {
                uint64_t v514 = *(void *)(v23 + 32);
                *(_DWORD *)(v514 + 12) = 0;
                *(_DWORD *)(v514 + 8) = dword_10008C1F0;
              }

              v519 = (int *)sub_100040D4C(&qword_10008C168, v514, 55LL, v496, v497, v498, v499, v500);
              v619 = (uint64_t *)v519;
              if (v519
                || (v519 = (int *)sub_100040D4C( &qword_10008C168,  *(void *)(v12 + 160),  55LL,  v515,  v516,  v517,  v518,  0LL),  (v619 = (uint64_t *)v519) != 0LL))
              {
                sub_100057AA4( (void *)(v23 + 40),  (unsigned int *)v12,  a2,  0LL,  *(void *)(v12 + 160),  *(void *)(v23 + 32),  (uint64_t *)(a2 + 112),  (uint64_t)v519,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0xAF2u);
              }

              *(void *)(a2 + 232) = v23;
              sub_1000622D4("%s", v520, v521, v522, v523, v524, v525, (uint64_t)v519, v613);
              sub_100034AD8( (uint64_t *)(*(void *)(a2 + 232) + 16LL),  v12,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2814LL,  v526,  v527,  v528,  v529);
              if (v10 != 2
                || (*(_BYTE *)(a2 + 221) & 1) != 0
                || (uint64_t)xmmword_10008CE80 - v13 < 61
                || (v537 = (int *)sub_100040D4C( &qword_10008BF80,  *(void *)(v23 + 32),  42LL,  v532,  v533,  v534,  v535,  v536),  (v619 = (uint64_t *)v537) != 0LL)
                && !sub_100057AF8( &v616,  (unsigned int *)v12,  a2,  0LL,  *(void *)(v12 + 160),  *(void *)(v23 + 32),  (uint64_t *)(a2 + 112),  (uint64_t)v537,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0xB0Au))
              {
                *(void *)(a2 + 264) = xmmword_10008CE80;
                return sub_100015AF0(a2, v530, v531, v532, v533, v534, v535, v536);
              }

              else
              {
                sub_10003F5FC(v609, v530, v531, v532, v533, v534, v535, v536);
                v543 = (int *)sub_100040D4C(&qword_10008BF80, *(void *)(v23 + 32), 46LL, v538, v539, v540, v541, v542);
                v619 = (uint64_t *)v543;
                if (v543
                  && sub_100057AA4( &v620,  (unsigned int *)v12,  a2,  0LL,  *(void *)(v12 + 160),  *(void *)(v23 + 32),  (uint64_t *)(a2 + 112),  (uint64_t)v543,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0xB14u))
                {
                  if ((_DWORD)__n == 4) {
                    uint64_t v549 = sub_100060B50((unsigned int *)__src);
                  }
                  else {
                    uint64_t v549 = 1LL;
                  }
                  sub_100034EA8( &v620,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2842LL,  v544,  v545,  v546,  v547,  v548);
                }

                else
                {
                  uint64_t v549 = 1LL;
                }

                *(void *)&__int128 v626 = xmmword_10008CE80 + v549;
                DWORD2(v626) = 0;
                uint64_t result = (_DWORD **)sub_10003BEE8( (uint64_t **)&v626,  (uint64_t)sub_1000183F8,  (uint64_t *)a2,  sub_100033898,  (uint64_t)sub_10003389C);
                ++dword_10008BDCC;
              }

              return result;
            }

            int v357 = __n;
            uint64_t v358 = 2521LL;
          }

          if (v357 == 2) {
            *(_DWORD *)(v23 + 64) = sub_100060B5C((unsigned __int16 *)__src);
          }
          sub_100034EA8( &v620,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  v358,  v352,  v353,  v354,  v355,  v356);
          goto LABEL_337;
        }

LABEL_249:
        uint64_t v248 = v179 + v246;
        goto LABEL_250;
      }

LABEL_243:
      uint64_t v245 = v610;
      if (v199) {
        uint64_t v245 = v199;
      }
      else {
        uint64_t v246 = v245;
      }
      uint64_t v179 = xmmword_10008CE80;
      uint64_t v247 = v614;
      goto LABEL_249;
    }

    uint64_t v611 = v13;
    char v612 = v8;
    if (v199) {
      uint64_t v204 = v199;
    }
    else {
      uint64_t v204 = 300LL;
    }
    if (*(void *)(a2 + 88) - (void)xmmword_10008CE80 <= v204) {
      unint64_t v205 = v204;
    }
    else {
      unint64_t v205 = *(void *)(a2 + 88) - xmmword_10008CE80;
    }
    uint64_t v206 = *(_DWORD **)(a2 + 136);
    int v207 = v206[32];
    int v208 = v207 - (v206[33] + v206[34]);
    if (v208 < 21474837) {
      int v209 = 100 * v208 / v207;
    }
    else {
      int v209 = v208 / (v207 / 100);
    }
    sub_10006238C( "Adap-lease: Total: %d, Free: %d, Ends: %d, Adaptive: %d, Fill: %d, Threshold: %d",  v203,  v202,  v174,  v175,  v176,  v177,  v178,  v207);
    if (v209 < *(unsigned __int8 *)__src)
    {
      unint64_t v205 = v198;
      char v8 = v612;
      goto LABEL_237;
    }

    char v8 = v612;
    if (v198 > v205)
    {
      __int128 v626 = *(_OWORD *)v609;
      int v627 = *(_DWORD *)(a2 + 72);
      char v229 = sub_100040144((int *)&v626, v227, v228, v174, v175, v176, v177, v178);
      sub_1000622D4( "Pool over threshold, time for %s reduced from %d to %d.",  v230,  v231,  v232,  v233,  v234,  v235,  v236,  v229);
    }

    else
    {
LABEL_236:
      unint64_t v205 = v198;
    }

LABEL_237:
    sub_100034EA8( &v620,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2118LL,  v174,  v175,  v176,  v177,  v178);
    uint64_t v198 = v205;
    uint64_t v13 = v611;
    goto LABEL_238;
  }

  if (!v616) {
    sub_1000622D4("%s: booting disallowed", v113, v107, v108, v109, v110, v111, v112, v8);
  }
  uint64_t result = sub_1000339CC( v23,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1853LL,  v108,  v109,  v110,  v111,  v112);
  if (v623)
  {
    uint64_t v80 = 1855LL;
    return (_DWORD **)sub_100033924(&v623, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", v80);
  }

  return result;
}

uint64_t sub_100015424( void *a1, __int128 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v134 = 6;
  uint64_t v131 = 0LL;
  uint64_t v132 = 0LL;
  sub_1000347D8( (uint64_t *)&v132,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1322LL,  a4,  a5,  a6,  a7,  a8);
  bzero(&v138, 0x5C0uLL);
  if (!sub_100034540( &v131,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1328LL,  v10,  v11,  v12,  v13,  v14))
  {
    sub_10006221C("No memory for DHCPNAK message type.", v15, v16, v17, v18, v19, v20, v21, v130);
    uint64_t v111 = 1330LL;
    return sub_100034894( &v132,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  v111,  v106,  v107,  v108,  v109,  v110);
  }

  if (!sub_1000545BC( v131 + 2,  &v134,  1,  0LL,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1334LL,  v21))
  {
    sub_10006221C("No memory for expr_const expression.", v22, v23, v24, v25, v26, v27, v28, v130);
    sub_100040E08( (int **)&v131,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1336LL,  v112,  v113,  v114,  v115,  v116);
    uint64_t v111 = 1337LL;
    return sub_100034894( &v132,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  v111,  v106,  v107,  v108,  v109,  v110);
  }

  int v133 = 53;
  sub_100029804( v131 + 3,  qword_10008C1E0,  &v133,  0LL,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1342LL);
  sub_100043E20(&qword_10008C168, (uint64_t)v132, (uint64_t)v131, v29, v30, v31, v32, v33);
  sub_100040E08( (int **)&v131,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1344LL,  v34,  v35,  v36,  v37,  v38);
  if (!sub_100034540( &v131,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1347LL,  v39,  v40,  v41,  v42,  v43))
  {
    sub_10006221C("No memory for DHCPNAK message type.", v44, v45, v46, v47, v48, v49, v50, v130);
    uint64_t v111 = 1349LL;
    return sub_100034894( &v132,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  v111,  v106,  v107,  v108,  v109,  v110);
  }

  int v51 = strlen((const char *)xmmword_10008CFA4);
  if (!sub_1000545BC( v131 + 2,  xmmword_10008CFA4,  v51,  1LL,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1354LL,  v52))
  {
    sub_10006221C("No memory for expr_const expression.", v53, v54, v55, v56, v57, v58, v59, v130);
    sub_100040E08( (int **)&v131,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1356LL,  v117,  v118,  v119,  v120,  v121);
    uint64_t v111 = 1357LL;
    return sub_100034894( &v132,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  v111,  v106,  v107,  v108,  v109,  v110);
  }

  int v133 = 56;
  sub_100029804( v131 + 3,  qword_10008C1E0,  &v133,  0LL,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1362LL);
  sub_100043E20(&qword_10008C168, (uint64_t)v132, (uint64_t)v131, v60, v61, v62, v63, v64);
  sub_100040E08( (int **)&v131,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1364LL,  v65,  v66,  v67,  v68,  v69);
  sub_1000158D4(&v135, (uint64_t)v132, (uint64_t)a1, v70, v71, v72, v73, v74);
  uint64_t v80 = a1[20];
  if (*(_DWORD *)(v80 + 4) > dword_10008BF78)
  {
    uint64_t v81 = *(_DWORD **)(v80 + 8LL * dword_10008BF78 + 16);
    if (v81)
    {
      sub_100033F18( &v132[2 * dword_10008BF78 + 4],  v81,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1380LL,  v76,  v77,  v78,  v79);
      uint64_t v80 = a1[20];
    }
  }

  sub_10004463C(&qword_10008C168, v80, 55LL, v75, v76, v77, v78, v79);
  unsigned int v82 = sub_100041504( (uint64_t)a1,  (uint64_t)&v138,  0LL,  0LL,  0LL,  (int *)a1[20],  v132,  &qword_10008C730,  0,  0,  0,  0LL,  0LL);
  sub_100034894( &v132,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  1393LL,  v83,  v84,  v85,  v86,  v87);
  uint64_t v95 = a1[13];
  if (*(_DWORD *)(v95 + 80)) {
    int v144 = **(_DWORD **)(v95 + 72);
  }
  uint64_t v96 = *a1;
  int v145 = *(_DWORD *)(*a1 + 24LL);
  __int128 v146 = *(_OWORD *)(v96 + 28);
  __int16 v139 = *(_WORD *)(v96 + 1);
  int v141 = *(_DWORD *)(v96 + 4);
  __int16 v142 = *(_WORD *)(v96 + 8);
  __int16 v143 = *(_WORD *)(v96 + 10) | 0x80;
  char v140 = *(_BYTE *)(v96 + 3);
  char v138 = 2;
  __int128 v136 = *a2;
  int v137 = *((_DWORD *)a2 + 4);
  char v97 = sub_100040144((int *)&v136, v88, v89, v90, v91, v92, v93, v94);
  sub_1000501FC(*(unsigned __int8 *)(*a1 + 1LL), *(unsigned __int8 *)(*a1 + 2LL), (unsigned __int8 *)(*a1 + 28LL));
  v105.s_addr = *(_DWORD *)(*a1 + 24LL);
  if (v105.s_addr) {
    inet_ntoa(v105);
  }
  sub_1000622D4("DHCPNAK on %s to %s via %s", v98, v99, v100, v101, v102, v103, v104, v97);
  __int16 v147 = 528;
  uint64_t v150 = 0LL;
  if (v82 <= 0x12C) {
    uint64_t v123 = 300LL;
  }
  else {
    uint64_t v123 = v82;
  }
  if (!v145)
  {
    int v149 = dword_10008C0DC;
    __int16 v148 = word_10008C104;
LABEL_27:
    *__error() = 0;
    uint64_t v125 = a1[13];
    int v126 = v135;
    int v128 = (int)a1;
    size_t v129 = v123;
    uint64_t v127 = 0LL;
    return sub_100039F14(v125, v128, &v138, v129, v126, (uint64_t)&v147, (uint64_t)v127);
  }

  int v149 = v145;
  if (v145 == 16777343) {
    uint64_t v124 = &word_10008C104;
  }
  else {
    uint64_t v124 = &word_10008C0F4;
  }
  __int16 v148 = *v124;
  uint64_t v125 = qword_10008C0A8;
  if (!qword_10008C0A8) {
    goto LABEL_27;
  }
  int v126 = v135;
  uint64_t v127 = &v136;
  int v128 = (int)a1;
  size_t v129 = v123;
  return sub_100039F14(v125, v128, &v138, v129, v126, (uint64_t)&v147, (uint64_t)v127);
}

int *sub_1000158D4( _DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v28 = 0LL;
  uint64_t v29 = 0LL;
  uint64_t v30 = 0LL;
  int v32 = 54;
  uint64_t result = (int *)sub_100040D4C(&qword_10008C168, a2, 54LL, a4, a5, a6, a7, a8);
  uint64_t v31 = result;
  if (result)
  {
    uint64_t result = (int *)sub_100057AA4( &v28,  (unsigned int *)a3,  0LL,  0LL,  *(void *)(a3 + 160),  a2,  &qword_10008C730,  (uint64_t)result,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  0x10A3u);
    if ((_DWORD)result)
    {
      if ((_DWORD)v30 == 4)
      {
        *a1 = *v29;
        return (int *)sub_100034EA8( &v28,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  4262LL,  v12,  v13,  v14,  v15,  v16);
      }

      uint64_t result = (int *)sub_100034EA8( &v28,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  4265LL,  v12,  v13,  v14,  v15,  v16);
    }
  }

  if (*(int *)(*(void *)(a3 + 104) + 80LL) < 1)
  {
    *a1 = 0;
  }

  else
  {
    uint64_t result = (int *)sub_100034540( &v31,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  4269LL,  v12,  v13,  v14,  v15,  v16);
    if ((_DWORD)result)
    {
      if (sub_1000545BC( (uint64_t *)v31 + 2,  *(const void **)(*(void *)(a3 + 104) + 72LL),  4,  0LL,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  4273LL,  v17))
      {
        sub_100029804( v31 + 6,  qword_10008C1E0,  &v32,  0LL,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  4276LL);
        sub_100043E20(&qword_10008C168, a2, (uint64_t)v31, v23, v24, v25, v26, v27);
      }

      uint64_t result = (int *)sub_100040E08( &v31,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  4279LL,  v18,  v19,  v20,  v21,  v22);
    }

    *a1 = **(_DWORD **)(*(void *)(a3 + 104) + 72LL);
  }

  return result;
}

uint64_t sub_100015A70(uint64_t a1)
{
  uint64_t result = *(unsigned int *)(a1 + 104);
  if (!(_DWORD)result)
  {
    dword_10008D0C0 = 224;
    sub_10002D4E8(*(unsigned int **)(a1 + 120), (unsigned int (*)(uint64_t, uint64_t, uint64_t))sub_10001653C);
    uint64_t result = dword_10008D0C0;
    if (dword_10008D0C0 <= 223)
    {
      sub_10006221C( "WARNING: site-local option codes less than 224 have been deprecated by RFC3942.  You have options listed in site local space %s that number as low as %d.  Please investigate if these should be declared as regular options rat her than site-local options, or migrated up past 224.",  v3,  v4,  v5,  v6,  v7,  v8,  v9,  *(void *)a1);
      uint64_t result = dword_10008D0C0;
      if (dword_10008D0C0 <= 127)
      {
        uint64_t result = 128LL;
        dword_10008D0C0 = 128;
      }
    }

    *(_DWORD *)(a1 + 104) = result;
  }

  return result;
}

_DWORD **sub_100015AF0( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 232);
  if (!v9) {
    sub_100061FB4("dhcp_reply was supplied lease with no state!", a2, a3, a4, a5, a6, a7, a8, v60);
  }
  bzero(v67, 0x5C0uLL);
  uint64_t v10 = *(unsigned int *)(v9 + 96);
  if ((_DWORD)v10 && *(void *)(v9 + 88))
  {
    else {
      uint64_t v11 = v10;
    }
    __memcpy_chk(v74, *(void *)(v9 + 88), v11, 1364LL);
    if (v10 > 0x7F) {
      sub_1000622D4( "file name longer than packet field truncated - field: %lu name: %d %.*s",  v12,  v13,  v14,  v15,  v16,  v17,  v18,  128);
    }
    else {
      bzero(&v74[v10], 128 - v10);
    }
    int v19 = 0;
  }

  else
  {
    int v19 = 1;
  }

  uint64_t v20 = *(unsigned int *)(v9 + 120);
  if ((_DWORD)v20 && *(void *)(v9 + 112))
  {
    else {
      uint64_t v21 = v20;
    }
    __memcpy_chk(v73, *(void *)(v9 + 112), v21, 1428LL);
    if (v20 > 0x3F) {
      sub_1000622D4( "server name longer than packet field truncated - field: %lu name: %d %.*s",  v22,  v23,  v24,  v25,  v26,  v27,  v28,  64);
    }
    else {
      bzero(&v73[v20], 64 - v20);
    }
  }

  else
  {
    v19 |= 2u;
  }

  char v29 = *(_BYTE *)(a1 + 204);
  __int128 v72 = *(_OWORD *)(a1 + 205);
  v67[2] = *(_BYTE *)(a1 + 203) - 1;
  v67[1] = v29;
  unsigned int v37 = sub_100041504( *(void *)(v9 + 16),  (uint64_t)v67,  a1,  0LL,  *(unsigned int *)(v9 + 64),  *(int **)(*(void *)(v9 + 16) + 160LL),  *(_DWORD **)(v9 + 32),  &qword_10008C730,  v19,  (*(unsigned __int8 *)(a1 + 221) >> 3) & 1,  *(_BYTE *)(v9 + 165) == 0,  v9 + 40,  0LL);
  int v38 = *(_DWORD *)(a1 + 60);
  int v69 = *(_DWORD *)(v9 + 152);
  int v70 = v38;
  uint64_t v71 = *(void *)(v9 + 156);
  uint64_t v68 = *(void *)(v9 + 144);
  v67[3] = *(_BYTE *)(v9 + 164);
  v67[0] = 2;
  uint64_t v39 = *(_BYTE **)(a1 + 104);
  uint64_t v40 = "DHCPOFFER";
  if (*(_BYTE *)(v9 + 165) == 5) {
    uint64_t v40 = "DHCPACK";
  }
  if (*(_BYTE *)(v9 + 165)) {
    LOBYTE(v41) = (_BYTE)v40;
  }
  else {
    uint64_t v41 = "BOOTREPLY";
  }
  __int128 v61 = *(_OWORD *)(a1 + 56);
  int v62 = *(_DWORD *)(a1 + 72);
  sub_100040144((int *)&v61, v30, v31, v32, v33, v34, v35, v36);
  if (*(_BYTE *)(a1 + 203)) {
    sub_1000501FC(*(unsigned __int8 *)(a1 + 204), *(unsigned __int8 *)(a1 + 203) - 1, (unsigned __int8 *)(a1 + 205));
  }
  else {
    sub_100050770((void *)*(unsigned __int16 *)(a1 + 192), *(unsigned __int8 **)(a1 + 184), 0x3Cu, 0);
  }
  v49.s_addr = *(_DWORD *)(v9 + 160);
  if (v49.s_addr) {
    inet_ntoa(v49);
  }
  sub_1000622D4("%s on %s to %s %s%s%svia %s", v42, v43, v44, v45, v46, v47, v48, (char)v41);
  LOBYTE(v61) = *(_BYTE *)(a1 + 203);
  __memcpy_chk((char *)&v61 + 1, a1 + 204, v61, 17LL);
  __int16 v63 = 528;
  uint64_t v66 = 0LL;
  if (v37 <= 0x12C) {
    size_t v50 = 300LL;
  }
  else {
    size_t v50 = v37;
  }
  if (!HIDWORD(v71))
  {
    if (!v69
      || (*(_DWORD *)(v9 + 132) || (v68 & 0x80000000000000LL) != 0)
      && *(void *)(v9 + 136) == *(void *)(*(void *)(a1 + 128) + 48LL)
      || *(_BYTE *)(v9 + 165) != 5)
    {
      if ((v68 & 0x80000000000000LL) != 0 || !sub_100035828())
      {
        int v65 = dword_10008C0DC;
        __int16 v64 = word_10008C104;
        if ((*(_BYTE *)(a1 + 221) & 0x40) != 0) {
          uint64_t v58 = &v61;
        }
        else {
          uint64_t v58 = 0LL;
        }
        goto LABEL_58;
      }

      int v65 = v70;
      __int16 v64 = word_10008C104;
    }

    else
    {
      int v65 = v69;
      __int16 v64 = word_10008C104;
      if (qword_10008C0A8)
      {
        sub_100039F14(qword_10008C0A8, 0, v67, v50, v71, (uint64_t)&v63, 0LL);
        uint64_t v57 = 3178LL;
        goto LABEL_59;
      }
    }

LABEL_54:
    uint64_t v58 = &v61;
LABEL_58:
    sub_100039F14(*(void *)(v9 + 8), 0, v67, v50, *(_DWORD *)(v9 + 172), (uint64_t)&v63, (uint64_t)v58);
    uint64_t v57 = 3210LL;
    goto LABEL_59;
  }

  int v65 = HIDWORD(v71);
  if (HIDWORD(v71) == 16777343) {
    int v51 = &word_10008C104;
  }
  else {
    int v51 = &word_10008C0F4;
  }
  __int16 v64 = *v51;
  if (!qword_10008C0A8) {
    goto LABEL_54;
  }
  sub_100039F14(qword_10008C0A8, 0, v67, v50, v71, (uint64_t)&v63, 0LL);
  uint64_t v57 = 3146LL;
LABEL_59:
  uint64_t result = sub_1000339CC( v9,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  v57,  v52,  v53,  v54,  v55,  v56);
  *(void *)(a1 + 232) = 0LL;
  return result;
}

  if ((*(_BYTE *)(a2 + 16) & 0x10) != 0)
  {
    if (*(_BYTE *)(a2 + 29) == 5)
    {
      uint64_t v17 = 6LL;
      uint64_t v18 = "BNDUPD to ABANDONED with client-id";
      goto LABEL_11;
    }

    uint64_t v40 = v104;
    uint64_t v41 = *((unsigned __int16 *)v104 + 96);
    uint64_t v42 = *(_DWORD *)(a2 + 96);
    uint64_t v43 = (_DWORD *)*((void *)v104 + 23);
    uint64_t v39 = v42 != (_DWORD)v41 || !v43 || memcmp(*((const void **)v104 + 23), *(const void **)(a2 + 104), v41);
    uint64_t v44 = (unsigned __int16)v42;
    *((_WORD *)v40 + 96) = v42;
    if (v43 && v43 != v40 + 49)
    {
      if (*((unsigned __int16 *)v40 + 97) >= (unsigned __int16)v42)
      {
LABEL_74:
        memcpy(v43, *(const void **)(a2 + 104), v44);
        goto LABEL_78;
      }

      sub_10005CE20( v43,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  5096LL,  v28,  a5,  a6,  a7,  a8);
      uint64_t v40 = v104;
      uint64_t v44 = *((unsigned __int16 *)v104 + 96);
    }

    if (v44 < 8)
    {
      *((_WORD *)v40 + 97) = 7;
      uint64_t v43 = v40 + 49;
      *((void *)v40 + 23) = v40 + 49;
      goto LABEL_74;
    }

    *((_WORD *)v40 + 97) = v44;
    uint64_t v44 = (size_t)sub_10005CDE4(v44);
    uint64_t v45 = v104;
    *((void *)v104 + 23) = v44;
    if (v44)
    {
      uint64_t v43 = (_DWORD *)v44;
      LODWORD(v44) = *((unsigned __int16 *)v45 + 96);
      goto LABEL_74;
    }

        uint64_t v34 = *(_DWORD *)(v8 + 64);
LABEL_55:
        if (v34 == 1)
        {
          uint64_t v22 = *(unsigned int *)(v8 + 128);
          if ((_DWORD)v22 != 1) {
            sub_1000258A8(v8, v22);
          }
        }

        sub_100025EC0(v8, v22, v23, v24, v25, v26, v27, v28);
        break;
      case 11:
        if (v10 != 8 && v10 != 2) {
          sub_100061FB4( "Peer %s: Invalid attempt to move from %s to %s while local state is conflict-done.",  v22,  v23,  v24,  v25,  v26,  v27,  v28,  *(void *)(v8 + 40));
        }
        uint64_t v32 = v8;
        uint64_t v33 = v10;
        goto LABEL_53;
      default:
        if (v30 != 254) {
LABEL_19:
        }
          sub_100061FB4( "Impossible condition at %s:%d.",  v22,  v23,  v24,  v25,  v26,  v27,  v28,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c");
        goto LABEL_54;
    }
  }

  return 0LL;
}

uint64_t **sub_100015FCC(uint64_t a1)
{
  uint64_t result = (uint64_t **)sub_10000C554(a1);
  if ((_DWORD)result)
  {
    uint64_t v3 = (void *)qword_10008D0A8;
    if (qword_10008D0A8)
    {
      qword_10008D0A8 = *(void *)(qword_10008D0A8 + 8);
    }

    else
    {
      uint64_t v3 = sub_10005CDE4(0x18uLL);
      if (!v3) {
        sub_10006FC14(0LL, v4, v5, v6, v7, v8, v9, v10);
      }
    }

    *uint64_t v3 = 0LL;
    v3[1] = 0LL;
    v3[2] = 0LL;
    uint64_t result = (uint64_t **)sub_100033898( v3 + 2,  a1,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2893LL);
    uint64_t v11 = qword_10008BDB8;
    v3[1] = qword_10008BDB8;
    qword_10008BDB8 = (uint64_t)v3;
    if (qword_10008BDC0) {
      uint64_t v12 = (uint64_t *)v11;
    }
    else {
      uint64_t v12 = &qword_10008BDC0;
    }
    *uint64_t v12 = (uint64_t)v3;
    int v13 = dword_10008BDC8++;
    if (v13 >= dword_100088020) {
      uint64_t result = (uint64_t **)sub_10000E1BC();
    }
    if (!qword_10008D0B0 && !dword_10008D0B8)
    {
      qword_10008D0B0 = qword_10008CE80 + dword_10008BDB0;
      dword_10008D0B8 = dword_100088024 + dword_10008CE88;
      if (dword_100088024 + dword_10008CE88 >= 1000000)
      {
        qword_10008D0B0 = qword_10008CE80 + dword_10008BDB0 + 1;
        dword_10008D0B8 = dword_100088024 + dword_10008CE88 - 1000000;
      }

      return sub_10003BEE8((uint64_t **)&qword_10008D0B0, (uint64_t)sub_100016128, 0LL, 0LL, 0LL);
    }
  }

  return result;
}

uint64_t sub_100016128()
{
  if (dword_10008BDC8)
  {
    uint64_t result = sub_10000E1BC();
    qword_10008D0B0 = 0LL;
    *(void *)&dword_10008D0B8 = 0LL;
  }

  return result;
}

uint64_t sub_100016154()
{
  if (dword_10008BDC8)
  {
    sub_10000E1BC();
    qword_10008D0B0 = 0LL;
    *(void *)&dword_10008D0B8 = 0LL;
    return sub_10003C09C((uint64_t)sub_100016128, 0LL);
  }

  return result;
}

void sub_100016194( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = qword_10008BDC0;
  if (qword_10008BDC0)
  {
    do
    {
      uint64_t v9 = *(void *)v8;
      uint64_t v10 = *(void *)(v8 + 16);
      if (*(void *)(v10 + 232))
      {
        sub_100015AF0(v10, a2, a3, a4, a5, a6, a7, a8);
      }

      else
      {
        __int128 v19 = *(_OWORD *)(v10 + 56);
        int v20 = *(_DWORD *)(v10 + 72);
        char v11 = sub_100040144((int *)&v19, a2, a3, a4, a5, a6, a7, a8);
        sub_10006221C("delayed ack for %s has gone stale", v12, v13, v14, v15, v16, v17, v18, v11);
      }

      sub_10003389C( (_DWORD **)(v8 + 16),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  2961LL);
      *(void *)(v8 + 8) = qword_10008D0A8;
      qword_10008D0A8 = v8;
      uint64_t v8 = v9;
    }

    while (v9);
  }

  qword_10008BDB8 = 0LL;
  qword_10008BDC0 = 0LL;
  dword_10008BDC8 = 0;
}

uint64_t sub_100016290(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v14 = 0LL;
  uint64_t v15 = 0LL;
  if (sub_10003387C( (void **)&v15,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c",  3922LL)) {
    return 0LL;
  }
  if (!sub_100033920(&v14, a4))
  {
    if (sub_100029FD0((uint64_t)(v15 + 16), (uint64_t *)&v14, (_DWORD *)v15 + 14, a3))
    {
      sub_100033920(v15 + 15, (uint64_t)v14);
      size_t v7 = *((unsigned int *)v14 + 24);
      if (v7 <= 7)
      {
        uint64_t v8 = (char *)v15 + 196;
        v15[23] = (char *)v15 + 196;
      }

      else
      {
        uint64_t v8 = (char *)sub_10005CDE4(v7);
        v15[23] = v8;
        if (!v8)
        {
          sub_10003389C((_DWORD **)&v15, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3940LL);
          uint64_t v9 = 3941LL;
LABEL_9:
          sub_100033924((_DWORD **)&v14, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", v9);
          return 0LL;
        }
      }

      memcpy(v8, v14[11], *((unsigned int *)v14 + 24));
      uint64_t v12 = v14;
      char v11 = v15;
      *((_WORD *)v15 + 96) = *((_DWORD *)v14 + 24);
      __int16 v13 = *((_WORD *)v12 + 36);
      *(_OWORD *)((char *)v11 + 203) = *(_OWORD *)(v12 + 7);
      *(_WORD *)((char *)v11 + 219) = v13;
      v11[33] = 0LL;
      v11[10] = 0LL;
      v11[11] = 0LL;
      *(_WORD *)((char *)v11 + 221) = 257;
      sub_100033898(a1, v11, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3952LL);
      sub_10003389C((_DWORD **)&v15, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3954LL);
      sub_100033924((_DWORD **)&v14, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3955LL);
      return 1LL;
    }

    sub_10003389C((_DWORD **)&v15, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3930LL);
    uint64_t v9 = 3931LL;
    goto LABEL_9;
  }

  sub_10003389C((_DWORD **)&v15, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcp.c", 3925LL);
  return 0LL;
}

uint64_t sub_100016450(_DWORD *a1, uint64_t *a2)
{
  if (a2)
  {
    while (2)
    {
      uint64_t v2 = 1LL;
      switch(*((_DWORD *)a2 + 2))
      {
        case 0:
          if (a1[54]) {
            goto LABEL_25;
          }
          return 1LL;
        case 1:
          if (a1[54]) {
            return 1LL;
          }
          goto LABEL_25;
        case 2:
          if (a1[55]) {
            return 1LL;
          }
          goto LABEL_25;
        case 3:
          if (!a1[55]) {
            return 1LL;
          }
          goto LABEL_25;
        case 4:
          return v2;
        case 5:
          if (!a1[18] || !a1[4]) {
            return 1LL;
          }
          goto LABEL_25;
        case 6:
          uint64_t v3 = a1[42];
          uint64_t v4 = a2[2];
          uint64_t v5 = (uint64_t *)(a1 + 44);
          break;
        case 7:
          if (qword_10008CE80 <= a2[3]) {
            goto LABEL_25;
          }
          return 1LL;
        default:
          goto LABEL_25;
      }

      do
      {
        uint64_t v6 = *v5;
        if (v4 == *v5) {
          return 1LL;
        }
        if (v6)
        {
          uint64_t v7 = *(void *)(v6 + 40);
          if (v7 && v7 == v4) {
            return 1LL;
          }
        }

        ++v5;
        --v3;
      }

      while (v3);
LABEL_25:
      a2 = (uint64_t *)*a2;
      if (a2) {
        continue;
      }
      break;
    }
  }

  return 0LL;
}

uint64_t sub_10001653C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return 0LL;
}

void start(int a1, uint64_t a2)
{
  int v4 = open("/dev/null", 2);
  if (!v4) {
    int v4 = open("/dev/null", 2);
  }
  if (v4 == 1) {
    int v4 = open("/dev/null", 2);
  }
  if (v4 != -1)
  {
    if (v4 == 2) {
      dword_10008BBA0 = 0;
    }
    else {
      close(v4);
    }
  }

  sub_100003390();
  v5.__sa_handler = (void (__cdecl *)(int))1;
  unsigned int v13 = sub_100067960();
  if (v13)
  {
    char v14 = sub_100067900(v13);
    sub_100061FB4("Can't initialize OMAPI: %s", v15, v16, v17, v18, v19, v20, v21, v14);
  }

  sub_10002FC94();
  sub_10003592C();
  openlog("dhcpd", 8, 24);
  uint64_t v22 = &qword_100088000;
  if (a1 >= 2)
  {
    uint64_t v336 = 0LL;
    uint64_t v337 = 0LL;
    uint64_t v334 = 0LL;
    uint64_t v335 = 0LL;
    uint64_t v338 = 0LL;
    uint64_t v339 = 0LL;
    int v340 = 0;
    uint64_t v23 = "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c";
    LODWORD(v24) = 1;
    int v25 = 1;
    while (1)
    {
      uint64_t v26 = (uint64_t)v23;
      int v27 = v24;
      uint64_t v28 = *(const char **)(a2 + 8LL * (int)v24);
      uint64_t v29 = strcmp(v28, "-p");
      if (!(_DWORD)v29)
      {
        uint64_t v24 = (int)v24 + 1LL;
        if (v27 + 1 == a1) {
          sub_10001735C(v29, v30, v31, v32, v33, v34, v35, v36, v326);
        }
        unsigned int v64 = sub_100040384(*(const char **)(a2 + 8 * v24));
        word_10008C0F4 = v64;
        sub_10006238C("binding to user-specified port %d", v65, v66, v67, v68, v69, v70, v71, __rev16(v64));
        goto LABEL_47;
      }

      if (!strcmp(v28, "-f"))
      {
        int v25 = 0;
      }

      else
      {
        if (!strcmp(v28, "-d"))
        {
          int v25 = 0;
          __int128 v72 = &dword_10008BBA0;
          int v73 = -1;
LABEL_37:
          *__int128 v72 = v73;
          goto LABEL_47;
        }

        uint64_t v44 = strcmp(v28, "-s");
        if (!(_DWORD)v44)
        {
          uint64_t v24 = (int)v24 + 1LL;
          uint64_t v23 = (const char *)v26;
          if (v27 + 1 == a1) {
            sub_10001735C(v44, v37, v38, v39, v40, v41, v42, v43, v326);
          }
          uint64_t v339 = *(const char **)(a2 + 8 * v24);
          goto LABEL_48;
        }

        uint64_t v45 = strcmp(v28, "-cf");
        if (!(_DWORD)v45)
        {
          uint64_t v24 = (int)v24 + 1LL;
          if (v27 + 1 == a1) {
            sub_10001735C(v45, v37, v38, v39, v40, v41, v42, v43, v326);
          }
          off_100088B40[0] = *(char **)(a2 + 8 * v24);
          HIDWORD(v335) = 1;
          goto LABEL_47;
        }

        uint64_t v46 = strcmp(v28, "-lf");
        if (!(_DWORD)v46)
        {
          uint64_t v24 = (int)v24 + 1LL;
          if (v27 + 1 == a1) {
            sub_10001735C(v46, v37, v38, v39, v40, v41, v42, v43, v326);
          }
          off_100088B48[0] = *(char **)(a2 + 8 * v24);
          LODWORD(v338) = 1;
          goto LABEL_47;
        }

        uint64_t v47 = strcmp(v28, "-pf");
        if (!(_DWORD)v47)
        {
          uint64_t v24 = (int)v24 + 1LL;
          uint64_t v23 = (const char *)v26;
          if (v27 + 1 == a1) {
            sub_10001735C(v47, v37, v38, v39, v40, v41, v42, v43, v326);
          }
          off_100088B50 = *(char **)(a2 + 8 * v24);
          LODWORD(v335) = 1;
          goto LABEL_48;
        }

        if (!strcmp(v28, "-t"))
        {
          int v25 = 0;
          dword_10008BBA0 = -1;
          int v340 = 1;
          goto LABEL_47;
        }

        if (!strcmp(v28, "-T"))
        {
          int v25 = 0;
          dword_10008BBA0 = -1;
          int v340 = 1;
          HIDWORD(v334) = 1;
          goto LABEL_47;
        }

        if (!strcmp(v28, "-q"))
        {
          int v73 = 1;
          HIDWORD(v338) = 1;
          __int128 v72 = &dword_10008C100;
          goto LABEL_37;
        }

        if (!strcmp(v28, "-4"))
        {
          uint64_t v23 = (const char *)v26;
          if ((_DWORD)v334 && dword_100089B0C != 2) {
            sub_100061FB4( "Server cannot run in both IPv4 and IPv6 mode at the same time.",  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v326);
          }
          dword_100089B0C = 2;
          LODWORD(v334) = 1;
          goto LABEL_48;
        }

        if (!strcmp(v28, "-6"))
        {
          if ((_DWORD)v334 && dword_100089B0C != 30) {
            sub_100061FB4( "Server cannot run in both IPv4 and IPv6 mode at the same time.",  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v326);
          }
          dword_100089B0C = 30;
          LODWORD(v334) = 1;
        }

        else
        {
          if (!strcmp(v28, "--version"))
          {
            sub_1000622D4("isc-dhcpd-%s", v48, v49, v50, v51, v52, v53, v54, (char)"4.1-ESV");
            goto LABEL_180;
          }

          uint64_t v55 = strcmp(v28, "-tf");
          if ((_DWORD)v55)
          {
            uint64_t v56 = strcmp(v28, "-play");
            if ((_DWORD)v56)
            {
              if (*v28 == 45) {
                sub_10001735C(v56, v57, v58, v59, v60, v61, v62, v63, v326);
              }
              *(void *)__s = 0LL;
              if (strlen(v28) >= 0x10) {
                sub_100061FB4("%s: interface name too long (is %ld)", v74, v75, v76, v77, v78, v79, v80, (char)v28);
              }
              uint64_t v23 = (const char *)v26;
              unsigned int v81 = sub_10003A174((void **)__s, v26, 412LL);
              if (v81)
              {
                sub_100067900(v81);
                sub_100061FB4( "Insufficient memory to %s %s: %s",  v82,  v83,  v84,  v85,  v86,  v87,  v88,  (char)"record interface");
              }

              __strcpy_chk(*(void *)__s + 132LL);
              if (qword_10008C0D0)
              {
                sub_1000235CC(*(void *)__s + 32LL, qword_10008C0D0, v26, 420LL);
                sub_1000235C8(&qword_10008C0D0, v26, 421LL);
              }

              sub_1000235CC(&qword_10008C0D0, *(void *)__s, v26, 423LL);
              *(_DWORD *)(*(void *)__s + 204LL) = 1;
              goto LABEL_48;
            }

            uint64_t v24 = (int)v24 + 1LL;
            if (v27 + 1 == a1) {
              sub_10001735C(v56, v57, v58, v59, v60, v61, v62, v63, v326);
            }
            uint64_t v336 = *(const char **)(a2 + 8 * v24);
            sub_1000695FC();
          }

          else
          {
            uint64_t v24 = (int)v24 + 1LL;
            if (v27 + 1 == a1) {
              sub_10001735C(v55, v37, v38, v39, v40, v41, v42, v43, v326);
            }
            uint64_t v337 = *(const char **)(a2 + 8 * v24);
          }
        }
      }

LABEL_47:
      uint64_t v23 = (const char *)v26;
LABEL_48:
      LODWORD(v24) = v24 + 1;
      if ((int)v24 >= a1)
      {
        uint64_t v22 = &qword_100088000;
        int v91 = HIDWORD(v334);
        int v89 = v335;
        uint64_t v90 = v339;
        if (!HIDWORD(v335)) {
          goto LABEL_79;
        }
        goto LABEL_81;
      }
    }
  }

  uint64_t v336 = 0LL;
  uint64_t v337 = 0LL;
  int v89 = 0;
  uint64_t v338 = 0LL;
  uint64_t v90 = 0LL;
  int v91 = 0;
  int v340 = 0;
  int v25 = 1;
LABEL_79:
  uint64_t v92 = getenv("PATH_DHCPD_CONF");
  if (v92) {
    off_100088B40[0] = v92;
  }
LABEL_81:
  if (dword_100089B0C == 30)
  {
    if ((_DWORD)v338)
    {
      if (!v89)
      {
LABEL_93:
        uint64_t v111 = getenv("PATH_DHCPD6_PID");
        if (v111) {
          v22[362] = (uint64_t)v111;
        }
        else {
          v22[362] = (uint64_t)"/var/run/dhcpd6.pid";
        }
      }
    }

    else
    {
      uint64_t v109 = getenv("PATH_DHCPD6_DB");
      uint64_t v110 = "/var/db/dhcpd6.leases";
      if (v109) {
        uint64_t v110 = v109;
      }
      off_100088B48[0] = v110;
      if (!v89) {
        goto LABEL_93;
      }
    }
  }

  else if (*off_100088B48[0] != 47)
  {
    uint64_t v100 = (char *)sub_10005CDE4(0x400uLL);
    if (!v100) {
      sub_100061FB4("No memory for filename\n", v93, v94, v95, v96, v97, v98, v99, v326);
    }
    off_100088B48[0] = realpath_DARWIN_EXTSN(off_100088B48[0], v100);
    if (!off_100088B48[0])
    {
      uint64_t v101 = __error();
      strerror(*v101);
      sub_100061FB4("%s: %s", v102, v103, v104, v105, v106, v107, v108, (char)v100);
    }
  }

  if (HIDWORD(v338))
  {
    dword_10008BBA0 = 0;
  }

  else
  {
    uint64_t v333 = "4.1-ESV";
    sub_1000622D4("%s %s", v37, v38, v39, v40, v41, v42, v43, (char)"Internet Systems Consortium DHCP Server");
    sub_1000622D4("Copyright 2004-2011 Internet Systems Consortium.", v112, v113, v114, v115, v116, v117, v118, v327);
    sub_1000622D4("All rights reserved.", v119, v120, v121, v122, v123, v124, v125, v328);
    sub_1000622D4( "For info, please visit https://www.isc.org/software/dhcp/",  v126,  v127,  v128,  v129,  v130,  v131,  v132,  v329);
  }

  sub_100068D7C(sub_10003BDA0, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c", 483LL);
  if (v337)
  {
    unsigned int v138 = sub_1000690C0( v337,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  485LL,  v133,  v134,  v135,  v136,  v137);
    if (v138)
    {
      char v139 = sub_100067900(v138);
      sub_100061FB4("Unable to begin trace: %s", v140, v141, v142, v143, v144, v145, v146, v139);
    }
  }

  sub_10003A9F4();
  sub_100003AA4();
  qword_10008BDF8 = (uint64_t)sub_100068E0C( "random-seed",  0LL,  (uint64_t)sub_10003A12C,  (uint64_t)nullsub_7,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  494LL);
  if (word_10008C0F4) {
    goto LABEL_112;
  }
  uint64_t v154 = getenv("DHCPD_PORT");
  if (v154)
  {
    unsigned int v155 = sub_100040384(v154);
    word_10008C0F4 = v155;
    sub_10006238C("binding to environment-specified port %d", v156, v157, v158, v159, v160, v161, v162, __rev16(v155));
LABEL_112:
    if (dword_100089B0C == 2)
    {
      unsigned int s_port = bswap32((bswap32((unsigned __int16)word_10008C0F4) >> 16) + 1) >> 16;
    }

    else
    {
      uint64_t v166 = getservbyname("dhcpv6-client", "udp");
      if (v166) {
        unsigned int s_port = v166->s_port;
      }
      else {
        LOWORD(s_port) = 8706;
      }
    }

    word_10008C104 = s_port;
    if (!v90) {
      goto LABEL_123;
    }
    if (dword_100089B0C != 2) {
      sub_100061FB4( "You can only specify address to send replies to when running an IPv4 server.",  v147,  v148,  v149,  v150,  v151,  v152,  v153,  v326);
    }
    if (inet_aton(v90, (in_addr *)&dword_10008C0DC))
    {
LABEL_125:
      gettimeofday((timeval *)&xmmword_10008CE80, 0LL);
      uint64_t v169 = sub_100052DCC();
      sub_100033B00(v169, v170, v171, v172, v173, v174, v175, v176);
      sub_100046B60(&qword_100089120);
      sub_100046B60(&qword_100089290);
      if (!sub_100034064( &qword_10008C140,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  607LL,  v177,  v178,  v179,  v180,  v181)) {
        sub_100061FB4("Can't allocate root group!", v182, v183, v184, v185, v186, v187, v188, v326);
      }
      *(_DWORD *)(qword_10008C140 + 40) = 0;
      off_10008C080 = (uint64_t (*)(void, void))sub_1000173B4;
      off_10008C070 = (uint64_t (*)(void))sub_100045F18;
      off_10008C098 = (uint64_t (*)(void, void, void, void, void, void))sub_1000461A0;
      uint64_t v342 = 0LL;
      if (sub_100036AA8( &v342,  -1,  (uint64_t)aOptionServerDd,  0x11Fu,  (uint64_t)"standard name service update routine",  0)) {
        sub_100061FB4("can't begin parsing name service updater!", v189, v190, v191, v192, v193, v194, v195, v326);
      }
      uint64_t v196 = v342;
      if (v342)
      {
        int v341 = 0;
        if (!sub_100049E64((void **)(qword_10008C140 + 48), v342, &v341, 0LL))
        {
          sub_100036BD4((uint64_t *)&v342, v197, v198, v199, v200, v201, v202, v203);
          sub_100061FB4("can't parse standard name service updater!", v204, v205, v206, v207, v208, v209, v210, v326);
        }

        sub_100036BD4((uint64_t *)&v342, v197, v198, v199, v200, v201, v202, v203);
      }

      if (!(v340 | v91)) {
        sub_10003F168(1LL, (uint64_t)sub_1000175C8, v190, v191, v192, v193, v194, v195, v326);
      }
      if (v336)
      {
        if (!(_DWORD)v338)
        {
          sub_10006221C("%s", (uint64_t)v196, v190, v191, v192, v193, v194, v195, (char)&byte_1000728D2);
          sub_10006221C("** You must specify a lease file with -lf.", v305, v306, v307, v308, v309, v310, v311, v330);
          sub_10006221C("   Dhcpd will not overwrite your default", v312, v313, v314, v315, v316, v317, v318, v331);
          sub_100061FB4("   lease file when playing back a trace. **", v319, v320, v321, v322, v323, v324, v325, v332);
        }

        sub_10006960C(v336);
      }

      else
      {
        if (!sub_10002D68C( &qword_10008BE60,  0x26F5u,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  663LL,  v192,  v193,  v194,  v195)) {
          sub_100061FB4("Out of memory creating hash for active IA_NA.", v211, v212, v213, v214, v215, v216, v217, v326);
        }
        if (!sub_10002D68C( &qword_10008BE70,  0x26F5u,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  666LL,  v214,  v215,  v216,  v217)) {
          sub_100061FB4("Out of memory creating hash for active IA_TA.", v218, v219, v220, v221, v222, v223, v224, v326);
        }
        if (!sub_10002D68C( &qword_10008BE68,  0x26F5u,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  669LL,  v221,  v222,  v223,  v224)) {
          sub_100061FB4("Out of memory creating hash for active IA_PD.", v225, v226, v227, v228, v229, v230, v231, v326);
        }
        if (sub_100003C68()) {
          sub_100061FB4( "Configuration file errors encountered -- exiting",  v232,  v233,  v234,  v235,  v236,  v237,  v238,  v326);
        }
        sub_100017784(0, v232, v233, v234, v235, v236, v237, v238);
        if (!v340 || v91)
        {
          off_10008C138 = sub_10000E320;
          sub_10000E250(v91);
          if (!v91)
          {
            sub_10003ADA0(1);
            if (dword_100089B0C == 30)
            {
              sub_10002F9C8();
              uint64_t v239 = sub_10002FAFC();
              sub_10002FBB0(v239, v240, v241, v242, v243, v244, v245, v246);
            }

            uint64_t v247 = qword_10008C0D0;
            if (qword_10008C0D0)
            {
              int v248 = 0;
              do
              {
                unsigned int v250 = *(unsigned __int8 *)(v247 + 48);
                uint64_t v249 = v247 + 48;
                v248 += *(_DWORD *)(v250 + v249 - 3);
                uint64_t v247 = *(void *)(v249 - 16);
              }

              while (v247);
            }

            else
            {
              int v248 = 0;
            }

            srandom(v248 + xmmword_10008CE80);
            sub_10003A0D8(qword_10008BDF8, v248 + xmmword_10008CE80);
            uint64_t v251 = sub_1000182E8();
            if (sub_10001A05C((uint64_t)v251, v252, v253, v254, v255, v256, v257, v258))
            {
              BOOL v259 = sub_100019FDC();
              if (v259)
              {
                if (!v25) {
                  goto LABEL_165;
                }
LABEL_161:
                pid_t v274 = fork();
                if (v274 < 0) {
                  sub_100061FB4("Can't fork daemon: %m", v275, v276, v277, v278, v279, v280, v281, v326);
                }
                if (v274) {
                  goto LABEL_180;
                }
LABEL_165:
                int v282 = open((const char *)v22[362], 0);
                if ((v282 & 0x80000000) == 0)
                {
                  int v283 = v282;
                  int v284 = read(v282, __s, 0x13uLL);
                  close(v283);
                  if (v284 >= 1)
                  {
                    __s[v284] = 0;
                    int v285 = atoi(__s);
                    if (!v285 || (pid_t v293 = v285, v285 != getpid()) && !kill(v293, 0)) {
                      sub_100061FB4( "There's already a DHCP server running.",  v286,  v287,  v288,  v289,  v290,  v291,  v292,  v326);
                    }
                  }
                }

                int v294 = open((const char *)v22[362], 1537, 420LL, v333);
                if (v294 < 0)
                {
                  sub_10006221C("Can't create PID file %s: %m.", v295, v296, v297, v298, v299, v300, v301, v22[362]);
                }

                else
                {
                  int v302 = v294;
                  pid_t v303 = getpid();
                  __sprintf_chk(__s, 0, 0x14uLL, "%d\n", v303);
                  size_t v304 = strlen(__s);
                  write(v302, __s, v304);
                  close(v302);
                }

                dword_10008BBA0 = dword_10008BBA0 == -1;
                if (v25)
                {
                  setsid();
                  close(0);
                  close(1);
                  close(2);
                  open("/dev/null", 2);
                  open("/dev/null", 2);
                  open("/dev/null", 2);
                  dword_10008BBA0 = 0;
                  chdir("/");
                }

                sub_100068064(qword_10008C040, 0, "state", (const char *)1);
                sub_100060D14(&qword_10008CE90, (uint64_t)sub_100016154);
                sub_10003BEA0();
              }
            }

            sub_10000DB2C();
            if (!v25) {
              goto LABEL_165;
            }
            goto LABEL_161;
          }
        }
      }

            if (v16)
            {
              do
              {
LABEL_48:
                uint64_t v59 = (void *)v16[1];
                if (v59) {
                  *uint64_t v59 = *v16;
                }
                if (*v16)
                {
                  *(void *)(*v16 + 8LL) = v59;
                  uint64_t v59 = v16;
                }

                *uint64_t v16 = -1LL;
                v16[1] = -1LL;
                sub_10006E3A4(v16);
                uint64_t v16 = v59;
              }

              while (v59);
            }
          }
        }

        else
        {
          uint64_t v44 = sub_10006E324(2, v41, 1, 16, 0);
          if (v44)
          {
            uint64_t v45 = v44;
            v44[8] = 0LL;
            uint64_t v16 = v44;
            v44[10] = 0LL;
            if (v21)
            {
              uint64_t v16 = 0LL;
              v21[1] = v44;
            }

            *uint64_t v44 = v21;
            v44[1] = 0LL;
            uint64_t v46 = sub_10006E324(2, *(const char **)(a1 + 8), 1, 16, v10);
            if (v46)
            {
              uint64_t v43 = v46;
              v46[8] = *(void *)(a3 + 8);
              *((_DWORD *)v46 + 20) = *(_DWORD *)(a3 + 16);
              *((_DWORD *)v46 + 21) = 1;
              v45[1] = v46;
              *uint64_t v46 = v45;
              goto LABEL_36;
            }

            goto LABEL_47;
          }
        }

        return v14;
      }
    }

    uint64_t v21 = (void *)*v16;
    if (!v31) {
      goto LABEL_19;
    }
LABEL_18:
    *(void *)(v31 + 8) = v32;
    uint64_t v32 = v16;
    goto LABEL_19;
  }

  return v14;
}

LABEL_180:
      exit(0);
    }

    int v167 = gethostbyname(v90);
    if (v167) {
      int v168 = **(_DWORD **)v167->h_addr_list;
    }
    else {
LABEL_123:
    }
      int v168 = -1;
    dword_10008C0DC = v168;
    goto LABEL_125;
  }

  if (dword_100089B0C == 2)
  {
    uint64_t v163 = getservbyname("dhcp", "udp");
    if (!v163)
    {
      LOWORD(v164) = 17152;
LABEL_111:
      word_10008C0F4 = v164;
      endservent();
      goto LABEL_112;
    }
  }

  else
  {
    uint64_t v163 = getservbyname("dhcpv6-server", "udp");
    if (!v163)
    {
      LOWORD(v164) = 8962;
      goto LABEL_111;
    }
  }

  int v164 = v163->s_port;
  goto LABEL_111;
}

void sub_10001735C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

uint64_t sub_1000173B4( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    uint64_t v37 = 0LL;
    __int128 v38 = *(_OWORD *)a2;
    int v39 = *(_DWORD *)(a2 + 16);
    if (sub_10002A994( (uint64_t)&v37,  &v38,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  1291LL,  a5,  a6,  a7,  a8))
    {
      uint64_t v17 = v37;
      uint64_t v18 = *(void *)(v37 + 56);
      if (v18)
      {
        if (v18 != a1)
        {
          sub_10006221C( "Multiple interfaces match the %s: %s %s",  v10,  v11,  v12,  v13,  v14,  v15,  v16,  (char)"same subnet");
          uint64_t v17 = v37;
        }
      }

      else
      {
        sub_1000235CC(v37 + 56, a1, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c", 1295LL);
        uint64_t v17 = v37;
        int v30 = *(_DWORD *)(a2 + 16);
        *(_OWORD *)(v37 + 64) = *(_OWORD *)a2;
        *(_DWORD *)(v17 + 80) = v30;
      }

      uint64_t v31 = *(void *)(v17 + 48);
      uint64_t v32 = *(void *)(a1 + 40);
      if (v32 && v32 != v31) {
        sub_100061FB4("Interface %s matches multiple shared %s", v10, v11, v12, v13, v14, v15, v16, a1 - 124);
      }
      if (!v32) {
        sub_1000235CC(a1 + 40, v31, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c", 1310LL);
      }
      uint64_t v35 = *(void *)(v31 + 64);
      uint64_t v34 = v31 + 64;
      uint64_t v33 = v35;
      if (v35)
      {
        if (v33 != a1) {
          sub_10006221C( "Multiple interfaces match the %s: %s %s",  v10,  v11,  v12,  v13,  v14,  v15,  v16,  (char)"same shared network");
        }
      }

      else
      {
        sub_1000235CC(v34, a1, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c", 1314LL);
      }

      sub_1000235C8(&v37, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c", 1320LL);
    }
  }

  else
  {
    uint64_t v19 = a1 + 40;
    unsigned int v20 = sub_1000358E4( (void **)(a1 + 40),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  1279LL);
    if (v20)
    {
      char v21 = sub_100067900(v20);
      sub_100061FB4("No memory for shared subnet: %s", v22, v23, v24, v25, v26, v27, v28, v21);
    }

    uint64_t v29 = (char *)sub_10005CDE4(0xDuLL);
    *(void *)(*(void *)v19 + 40LL) = v29;
    strcpy(v29, "fallback-net");
  }

  return 1LL;
}

uint64_t sub_1000175C8( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (dword_10008BDCC)
  {
    uint64_t v8 = result;
    uint64_t v48 = 0LL;
    __int128 v49 = *(_OWORD *)result;
    int v50 = *(_DWORD *)(result + 16);
    if (sub_10002A978( &v48,  (const char *)&v49,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  1212LL,  a5,  a6,  a7,  a8))
    {
      uint64_t v16 = *((void *)v48 + 29);
      if (v16)
      {
        if (*((void *)v48 + 11) > qword_10008CE80)
        {
          __int128 v49 = *(_OWORD *)v8;
          int v50 = *(_DWORD *)(v8 + 16);
          char v17 = sub_100040144((int *)&v49, v9, v10, v11, v12, v13, v14, v15);
          sub_10006238C("ICMP Echo reply while lease %s valid.", v18, v19, v20, v21, v22, v23, v24, v17);
          uint64_t v16 = *((void *)v48 + 29);
        }

        sub_100034EA8( (_DWORD **)(v16 + 40),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  1235LL,  v11,  v12,  v13,  v14,  v15);
        sub_1000339CC( *((void *)v48 + 29),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  1236LL,  v25,  v26,  v27,  v28,  v29);
        int v30 = v48;
        *((void *)v48 + 29) = 0LL;
        sub_10002CBE4((uint64_t)v30);
        sub_10003C09C((uint64_t)sub_1000183F8, (uint64_t)v48);
        --dword_10008BDCC;
      }

      else
      {
        uint64_t v39 = *((void *)v48 + 17);
        if (!v39 || !*(void *)(v39 + 160))
        {
          __int128 v49 = *(_OWORD *)v8;
          int v50 = *(_DWORD *)(v8 + 16);
          char v40 = sub_100040144((int *)&v49, v9, v10, v11, v12, v13, v14, v15);
          sub_10006238C("ICMP Echo Reply for %s late or spurious.", v41, v42, v43, v44, v45, v46, v47, v40);
        }
      }

      return sub_10003389C(&v48, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c", 1243LL);
    }

    else
    {
      __int128 v49 = *(_OWORD *)v8;
      int v50 = *(_DWORD *)(v8 + 16);
      char v31 = sub_100040144((int *)&v49, v9, v10, v11, v12, v13, v14, v15);
      return sub_10006238C("unexpected ICMP Echo Reply from %s", v32, v33, v34, v35, v36, v37, v38, v31);
    }
  }

  return result;
}

uint64_t sub_100017784( int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v304 = 0LL;
  sub_1000347D8( &v304,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  863LL,  a4,  a5,  a6,  a7,  a8);
  sub_10003E0AC(0LL, 0LL, 0LL, 0LL, 0LL, v304, &qword_10008C730, qword_10008C140, 0LL);
  uint64_t v301 = 0LL;
  __src = 0LL;
  size_t __n = 0LL;
  uint64_t v14 = sub_100040D4C(&qword_10008BF80, v304, 26LL, v9, v10, v11, v12, v13);
  if (v14
    && sub_100057AA4( &v301,  0LL,  0LL,  0LL,  v304,  0LL,  &qword_10008C730,  v14,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  0x36Fu))
  {
    uint64_t v20 = (char *)sub_10005CDE4((__n + 1));
    uint64_t v28 = v20;
    if (!v20) {
      sub_100061FB4("no memory for lease db filename.", v21, v22, v23, v24, v25, v26, v27, v294);
    }
    memcpy(v20, __src, __n);
    v28[__n] = 0;
    sub_100034EA8( &v301,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  885LL,  v29,  v30,  v31,  v32,  v33);
    off_100088B48[0] = v28;
  }

  uint64_t v34 = sub_100040D4C(&qword_10008BF80, v304, 27LL, v15, v16, v17, v18, v19);
  if (v34
    && sub_100057AA4( &v301,  0LL,  0LL,  0LL,  v304,  0LL,  &qword_10008C730,  v34,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  0x37Eu))
  {
    char v40 = (char *)sub_10005CDE4((__n + 1));
    uint64_t v48 = v40;
    if (!v40) {
      sub_100061FB4("no memory for lease db filename.", v41, v42, v43, v44, v45, v46, v47, v294);
    }
    memcpy(v40, __src, __n);
    v48[__n] = 0;
    sub_100034EA8( &v301,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  900LL,  v49,  v50,  v51,  v52,  v53);
    off_100088B50 = v48;
  }

  if (dword_100089B0C == 30)
  {
    uint64_t v54 = sub_100040D4C(&qword_10008BF80, v304, 54LL, v35, v36, v37, v38, v39);
    if (v54
      && sub_100057AA4( &v301,  0LL,  0LL,  0LL,  v304,  0LL,  &qword_10008C730,  v54,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  0x393u))
    {
      uint64_t v60 = (char *)sub_10005CDE4((__n + 1));
      uint64_t v68 = v60;
      if (!v60) {
        sub_100061FB4("no memory for lease db filename.", v61, v62, v63, v64, v65, v66, v67, v294);
      }
      memcpy(v60, __src, __n);
      v68[__n] = 0;
      sub_100034EA8( &v301,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  921LL,  v69,  v70,  v71,  v72,  v73);
      off_100088B48[0] = v68;
    }

    uint64_t v74 = sub_100040D4C(&qword_10008BF80, v304, 55LL, v55, v56, v57, v58, v59);
    if (v74
      && sub_100057AA4( &v301,  0LL,  0LL,  0LL,  v304,  0LL,  &qword_10008C730,  v74,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  0x3A2u))
    {
      uint64_t v75 = (char *)sub_10005CDE4((__n + 1));
      uint64_t v83 = v75;
      if (!v75) {
        sub_100061FB4("no memory for lease db filename.", v76, v77, v78, v79, v80, v81, v82, v294);
      }
      memcpy(v75, __src, __n);
      v83[__n] = 0;
      sub_100034EA8( &v301,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  936LL,  v84,  v85,  v86,  v87,  v88);
      off_100088B50 = v83;
    }
  }

  dword_10008BDD4 = -1;
  uint64_t v89 = sub_100040D4C(&qword_10008BF80, v304, 31LL, v35, v36, v37, v38, v39);
  if (v89
    && sub_100057AA4( &v301,  0LL,  0LL,  0LL,  v304,  0LL,  &qword_10008C730,  v89,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  0x3B4u))
  {
    if ((_DWORD)__n != 2) {
      sub_100061FB4("invalid omapi port data length", v95, v96, v90, v91, v92, v93, v94, v294);
    }
    dword_10008BDD4 = sub_100060B5C((unsigned __int16 *)__src);
    sub_100034EA8( &v301,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  953LL,  v97,  v98,  v99,  v100,  v101);
  }

  uint64_t v102 = sub_100040D4C(&qword_10008BF80, v304, 36LL, v90, v91, v92, v93, v94);
  if (v102
    && sub_100057AA4( &v301,  0LL,  0LL,  0LL,  v304,  0LL,  &qword_10008C730,  v102,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  0x3C2u))
  {
    uint64_t v108 = (char *)sub_10005CDE4((__n + 1));
    uint64_t v116 = v108;
    if (!v108) {
      sub_100061FB4("no memory for OMAPI key filename.", v109, v110, v111, v112, v113, v114, v115, v294);
    }
    memcpy(v108, __src, __n);
    v116[__n] = 0;
    sub_100034EA8( &v301,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  968LL,  v117,  v118,  v119,  v120,  v121);
    unsigned int v128 = sub_10005DDB8(&qword_10008D0C8, v116, v122, v123, v124, v125, v126, v127);
    sub_10005CE20( v116,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  970LL,  v129,  v130,  v131,  v132,  v133);
    if (v128)
    {
      sub_100067900(v128);
      sub_100061FB4("OMAPI key %s: %s", v134, v135, v136, v137, v138, v139, v140, (char)v116);
    }
  }

  uint64_t v141 = sub_100040D4C(&qword_10008BF80, v304, 32LL, v103, v104, v105, v106, v107);
  if (v141
    && sub_100057AA4( &v301,  0LL,  0LL,  0LL,  v304,  0LL,  &qword_10008C730,  v141,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  0x3D6u))
  {
    if ((_DWORD)__n != 2) {
      sub_100061FB4("invalid local port data length", v147, v148, v142, v143, v144, v145, v146, v294);
    }
    word_10008C0F4 = bswap32(sub_100060B5C((unsigned __int16 *)__src)) >> 16;
    sub_100034EA8( &v301,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  987LL,  v149,  v150,  v151,  v152,  v153);
  }

  uint64_t v154 = sub_100040D4C(&qword_10008BF80, v304, 34LL, v142, v143, v144, v145, v146);
  if (v154
    && sub_100057AA4( &v301,  0LL,  0LL,  0LL,  v304,  0LL,  &qword_10008C730,  v154,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  0x3E3u))
  {
    if ((_DWORD)__n != 2) {
      sub_100061FB4("invalid remote port data length", v160, v161, v155, v156, v157, v158, v159, v294);
    }
    word_10008C104 = bswap32(sub_100060B5C((unsigned __int16 *)__src)) >> 16;
    sub_100034EA8( &v301,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  1000LL,  v162,  v163,  v164,  v165,  v166);
  }

  uint64_t v167 = sub_100040D4C(&qword_10008BF80, v304, 33LL, v155, v156, v157, v158, v159);
  if (v167
    && sub_100057AA4( &v301,  0LL,  0LL,  0LL,  v304,  0LL,  &qword_10008C730,  v167,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  0x3F1u))
  {
    if ((_DWORD)__n != 4) {
      sub_100061FB4("invalid broadcast address data length", v173, v174, v168, v169, v170, v171, v172, v294);
    }
    dword_10008C0DC = *(_DWORD *)__src;
    sub_100034EA8( &v301,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  1014LL,  v168,  v169,  v170,  v171,  v172);
  }

  uint64_t v175 = sub_100040D4C(&qword_10008BF80, v304, 35LL, v168, v169, v170, v171, v172);
  if (v175
    && sub_100057AA4( &v301,  0LL,  0LL,  0LL,  v304,  0LL,  &qword_10008C730,  v175,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  0x3FFu))
  {
    if ((_DWORD)__n != 4) {
      sub_100061FB4("invalid local address data length", v181, v182, v176, v177, v178, v179, v180, v294);
    }
    dword_10008C0E0 = *(_DWORD *)__src;
    sub_100034EA8( &v301,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  1028LL,  v176,  v177,  v178,  v179,  v180);
  }

  uint64_t v183 = sub_100040D4C(&qword_10008BF80, v304, 39LL, v176, v177, v178, v179, v180);
  if (v183)
  {
    if (sub_100057AA4( &v301,  0LL,  0LL,  0LL,  v304,  0LL,  &qword_10008C730,  v183,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  0x40Eu))
    {
      if ((_DWORD)__n != 1) {
        sub_100061FB4("invalid dns update type", v189, v190, v184, v185, v186, v187, v188, v294);
      }
      dword_10008BDD0 = *(unsigned __int8 *)__src;
      sub_100034EA8( &v301,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  1043LL,  v184,  v185,  v186,  v187,  v188);
    }
  }

  else
  {
    dword_10008BDD0 = 0;
  }

  uint64_t v191 = sub_100040D4C(&qword_10008BF80, v304, 44LL, v184, v185, v186, v187, v188);
  if (v191
    && sub_100057AA4( &v301,  0LL,  0LL,  0LL,  v304,  0LL,  &qword_10008C730,  v191,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  0x420u))
  {
    if ((_DWORD)__n != 1) {
      sub_100061FB4("invalid log facility", v197, v198, v192, v193, v194, v195, v196, v294);
    }
    closelog();
    openlog("dhcpd", 8, *(unsigned __int8 *)__src);
    if (!a1)
    {
      int v206 = dword_10008BBA0;
      int v299 = dword_10008BBA0;
      dword_10008BBA0 = 0;
      sub_1000622D4("%s %s", v199, v200, v201, v202, v203, v204, v205, (char)"Internet Systems Consortium DHCP Server");
      sub_1000622D4("Copyright 2004-2011 Internet Systems Consortium.", v207, v208, v209, v210, v211, v212, v213, v295);
      sub_1000622D4("All rights reserved.", v214, v215, v216, v217, v218, v219, v220, v296);
      sub_1000622D4( "For info, please visit https://www.isc.org/software/dhcp/",  v221,  v222,  v223,  v224,  v225,  v226,  v227,  v297);
      dword_10008BBA0 = v206;
    }

    sub_100034EA8( &v301,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  1075LL,  v201,  v202,  v203,  v204,  v205);
  }

  uint64_t v228 = sub_100040D4C(&qword_10008BF80, v304, 58LL, v192, v193, v194, v195, v196);
  if (v228
    && sub_100057AA4( &v301,  0LL,  0LL,  0LL,  v304,  0LL,  &qword_10008C730,  v228,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  0x43Au))
  {
    if ((_DWORD)__n != 2) {
      sub_100061FB4("invalid max delayed ACK count ", v234, v235, v229, v230, v231, v232, v233, v294);
    }
    dword_100088020 = bswap32(sub_100060B5C((unsigned __int16 *)__src)) >> 16;
    sub_100034EA8( &v301,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  1088LL,  v236,  v237,  v238,  v239,  v240);
  }

  uint64_t v241 = sub_100040D4C(&qword_10008BF80, v304, 59LL, v229, v230, v231, v232, v233);
  if (v241
    && sub_100057AA4( &v301,  0LL,  0LL,  0LL,  v304,  0LL,  &qword_10008C730,  v241,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  0x446u))
  {
    if ((_DWORD)__n != 4) {
      sub_100061FB4("invalid max ack delay configuration", v247, v248, v242, v243, v244, v245, v246, v294);
    }
    unsigned int v249 = sub_100060B50((unsigned int *)__src);
    dword_10008BDB0 = v249 / 0xF4240;
    dword_100088024 = v249 % 0xF4240;
    sub_100034EA8( &v301,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  1104LL,  v250,  v251,  v252,  v253,  v254);
  }

  uint64_t result = sub_100034894( &v304,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  1108LL,  v242,  v243,  v244,  v245,  v246);
  if (dword_10008BDD0 == 1)
  {
    uint64_t v256 = (void **)(qword_10008C140 + 48);
    if (*(void *)(qword_10008C140 + 48))
    {
      uint64_t v298 = 0LL;
      if (!sub_100034984( &v298,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  1118LL)) {
        sub_100061FB4("no memory for ddns updater", v257, v258, v259, v260, v261, v262, v263, v294);
      }
      sub_100033F18( v298 + 1,  *(_DWORD **)(qword_10008C140 + 48),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  1121LL,  v260,  v261,  v262,  v263);
      sub_10003DC78( (void **)(qword_10008C140 + 48),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  1123LL,  v264,  v265,  v266,  v267,  v268);
      sub_100033F18( (void *)(qword_10008C140 + 48),  v298,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  1125LL,  v269,  v270,  v271,  v272);
      uint64_t v273 = v298;
      *((_DWORD *)v298 + 4) = 10;
      uint64_t v256 = (void **)(v273 + 3);
      sub_10003DC78( (void **)&v298,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  1128LL,  v274,  v275,  v276,  v277,  v278);
    }

    uint64_t v300 = 0LL;
    if (sub_100036AA8( &v300,  -1,  (uint64_t)aOnCommitIfNotS,  0x9F2u,  (uint64_t)"old name service update routine",  0)) {
      sub_100061FB4("can't begin parsing old ddns updater!", v279, v280, v281, v282, v283, v284, v285, v294);
    }
    uint64_t v286 = v300;
    if (v300)
    {
      int v299 = 0;
      if (!sub_100049E64(v256, v300, &v299, 0LL))
      {
        sub_100036BD4((uint64_t *)&v300, (uint64_t)v286, v280, v281, v282, v283, v284, v285);
        sub_100061FB4("can't parse standard ddns updater!", v287, v288, v289, v290, v291, v292, v293, v294);
      }
    }

    return sub_100036BD4((uint64_t *)&v300, (uint64_t)v286, v280, v281, v282, v283, v284, v285);
  }

  return result;
}

uint64_t **sub_1000182E8()
{
  if (dword_10008BDD4 != -1) {
    sub_100018310();
  }
  sub_100021524();
  return sub_10002F620();
}

uint64_t sub_100018310()
{
  uint64_t v22 = 0LL;
  unsigned int v0 = sub_100062444((void **)&v22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c", 191LL);
  if (v0)
  {
    char v1 = sub_100067900(v0);
    sub_100061FB4("Can't allocate new generic object: %s", v2, v3, v4, v5, v6, v7, v8, v1);
  }

  unsigned int v9 = sub_1000673F0(v22, dword_10008BDD4, 1);
  if (v9) {
    BOOL v10 = 1;
  }
  else {
    BOOL v10 = qword_10008D0C8 == 0;
  }
  if (!v10) {
    unsigned int v9 = sub_1000673AC(v22, (uint64_t)sub_1000187E4, (uint64_t)sub_1000187EC);
  }
  if (v9)
  {
    char v11 = sub_100067900(v9);
    sub_10006221C("Can't start OMAPI protocol: %s", v12, v13, v14, v15, v16, v17, v18, v11);
    uint64_t v20 = (uint64_t *)(qword_10008CE80 + 5);
    int v21 = 0;
    sub_10003BEE8(&v20, (uint64_t)sub_100018310, 0LL, 0LL, 0LL);
  }

  return sub_10005CFEC((_DWORD **)&v22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c", 207LL);
}

_DWORD **sub_1000183F8( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_100015AF0(a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_100018410(uint64_t *a1)
{
  int v2 = dword_10008BDF0;
  uint64_t v3 = *a1;
  if (dword_10008BDF0) {
    BOOL v4 = 0;
  }
  else {
    BOOL v4 = v3 == qword_10008CF28;
  }
  if (v4)
  {
    uint64_t v5 = (void *)a1[3];
    if (v5)
    {
      if (*v5 == qword_10008CF40)
      {
        sub_10006423C((uint64_t)a1);
        return 0LL;
      }
    }
  }

  if (v3 == qword_10008CF08)
  {
    uint64_t v7 = (void *)a1[3];
    if (v7)
    {
      if (*v7 == qword_10008CF38)
      {
        if (dword_10008BDF0 == 2)
        {
          sub_100060130((uint64_t)a1, 1);
          int v2 = dword_10008BDF0;
        }

        ++dword_10008D0D0;
        if (v2 == 1)
        {
          sub_100060130((uint64_t)a1, 0);
          return 0LL;
        }

        uint64_t v3 = *a1;
      }
    }
  }

  if (v3 == qword_10008C058 && v2 == 3) {
    sub_10003A854((uint64_t)a1);
  }
  return 0LL;
}

uint64_t sub_10001852C(uint64_t a1, int a2)
{
  if (a2 != 2) {
    return 39LL;
  }
  qword_10008D0D8 = qword_10008CE80;
  dword_10008BDF0 = 0;
  sub_100018570();
  return 0LL;
}

uint64_t sub_100018570()
{
  int i = dword_10008BDF0;
  if (dword_10008BDF0 <= 3)
  {
LABEL_2:
    dword_10008D0D0 = 0;
    sub_100061F60((uint64_t (*)(uint64_t, uint64_t))sub_100018410, 0LL);
    for (int i = dword_10008BDF0; dword_10008BDF0 <= 2 && dword_10008D0D0 == 0; int i = dword_10008BDF0)
    {
      dword_10008BDF0 = 3;
      qword_10008D0D8 = qword_10008CE80;
      dword_10008D0D0 = 0;
      sub_100061F60((uint64_t (*)(uint64_t, uint64_t))sub_100018410, 0LL);
    }
  }

  while (2)
  {
    switch(i)
    {
      case 0:
        uint64_t v6 = qword_10008CE80;
        if (qword_10008CE80 - qword_10008D0D8 <= 4) {
          goto LABEL_33;
        }
        int v7 = 1;
        goto LABEL_32;
      case 1:
        uint64_t v6 = qword_10008CE80;
        if (qword_10008CE80 - qword_10008D0D8 <= 4) {
          goto LABEL_33;
        }
        int v7 = 2;
LABEL_32:
        dword_10008BDF0 = v7;
        qword_10008D0D8 = v6;
        goto LABEL_33;
      case 2:
        if (qword_10008CE80 - qword_10008D0D8 < 5) {
          goto LABEL_33;
        }
        dword_10008BDF0 = 3;
        qword_10008D0D8 = qword_10008CE80;
        goto LABEL_2;
      case 3:
        if (qword_10008CE80 - qword_10008D0D8 >= 5)
        {
          dword_10008BDF0 = 4;
          qword_10008D0D8 = qword_10008CE80;
LABEL_37:
          for (uint64_t j = qword_10008BE08; j; uint64_t j = *(void *)(j + 32))
          {
            if (*(_DWORD *)(j + 64) == 8)
            {
              if (*(void *)(j + 232)) {
                sub_100022208( (_DWORD **)(j + 232),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpd.c",  1425LL);
              }
              sub_1000258A8(j, 6);
            }
          }

          exit(0);
        }

        uint64_t v3 = qword_10008BE08;
        if (qword_10008BE08)
        {
          int v4 = 0;
          do
          {
            int v5 = *(_DWORD *)(v3 + 64);
            if (v5 == 2)
            {
              sub_1000258A8(v3, 8);
              ++v4;
              int v5 = *(_DWORD *)(v3 + 64);
            }

            if (v5 == 8 && *(_DWORD *)(v3 + 104) != 4) {
              ++v4;
            }
            uint64_t v3 = *(void *)(v3 + 32);
          }

          while (v3);
          int i = dword_10008BDF0;
LABEL_23:
          if (i == 4) {
            goto LABEL_37;
          }
        }

        else
        {
          int v4 = 0;
          int i = 3;
        }

        if (i == 3 && !v4)
        {
          int i = 4;
          dword_10008BDF0 = 4;
          qword_10008D0D8 = qword_10008CE80;
          continue;
        }

LABEL_33:
        BOOL v10 = (uint64_t *)(qword_10008CE80 + 1);
        int v11 = dword_10008CE88;
        sub_10003BEE8(&v10, (uint64_t)sub_100018570, 0LL, 0LL, 0LL);
        return 0LL;
      default:
        int v4 = 0;
        goto LABEL_23;
    }
  }

  if (v14)
  {
LABEL_34:
    uint64_t v20 = *(void *)(v14 + 32);
    uint64_t v19 = (uint64_t *)(v14 + 32);
    uint64_t v18 = v20;
    if (v20)
    {
      sub_100033898(a1 + 32, v18, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 2425LL);
      sub_10003389C((_DWORD **)v19, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 2426LL);
    }

    int v21 = v19;
    uint64_t v22 = a1;
    uint64_t v23 = 2428LL;
    goto LABEL_40;
  }

  if (*v10)
  {
    sub_100033898(a1 + 32, *v10, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 2431LL);
    sub_10003389C((_DWORD **)v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 2432LL);
  }

  int v21 = v10;
  uint64_t v22 = a1;
  uint64_t v23 = 2434LL;
LABEL_40:
  sub_100033898(v21, v22, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", v23);
  qword_1000BD2C0 = a1;
  qword_1000BD2B8 = (uint64_t)v10;
  return 1LL;
}

    a4 = sub_100057DA8(v94);
    if (v92) {
      break;
    }
    uint64_t v92 = v94;
    uint64_t v94 = 0LL;
    sub_100036D00(&v95, 0LL, (uint64_t)a2);
LABEL_61:
    uint64_t v8 = v37;
  }

  if (!v8) {
    goto LABEL_58;
  }
  if ((sub_100057CF8(v8, v37) & 0x80000000) != 0)
  {
    sub_100036D00(&v95, 0LL, (uint64_t)a2);
    uint64_t v93 = v94;
    uint64_t v94 = 0LL;
    uint64_t v45 = sub_100057DEC(v37);
    if (!*a3)
    {
      sub_100046D6C((uint64_t)a2, "expecting a subexpression", v46, v47, v48, v49, v50, v51, v92);
      goto LABEL_83;
    }

    return 0LL;
  }

        switch(*(_DWORD *)(a8 + 4))
        {
          case '""':
            char v40 = *a1;
            uint64_t v41 = 1;
            goto LABEL_48;
          case '#':
            *(_DWORD *)(*a1 + 84) = 0;
            goto LABEL_39;
          case '$':
            char v40 = *a1;
            uint64_t v41 = 7;
            goto LABEL_48;
          case '%':
            char v40 = *a1;
            uint64_t v41 = 8;
LABEL_48:
            *(_DWORD *)(v40 + 84) = v41;
            break;
          default:
            goto LABEL_39;
        }

        goto LABEL_39;
      case 0x29:
        uint64_t v17 = "%s: dns values for variables not supported.";
        goto LABEL_26;
      case 0x2D:
LABEL_26:
        sub_10006221C(v17, a2, a3, a4, a5, a6, a7, a8, *(void *)(a8 + 8));
        goto LABEL_27;
      case 0x2E:
        sub_10006221C("Function opcode in evaluate_dns_expression: %d", a2, a3, a4, a5, a6, a7, a8, 46);
        return 0LL;
      default:
LABEL_27:
        sub_10006221C("Bogus opcode in evaluate_dns_expression: %d", a2, a3, a4, a5, a6, a7, a8, *(_DWORD *)(a8 + 4));
        return 0LL;
    }
  }

  sub_10006221C("evaluate_dns_expression called with non-null %s", a2, a3, a4, a5, a6, a7, a8, (char)"result pointer");
  return 0LL;
}

uint64_t sub_1000187E4()
{
  return 0LL;
}

uint64_t sub_1000187EC(uint64_t a1, uint64_t a2)
{
  if (qword_10008D0C8 == a2) {
    return 0LL;
  }
  else {
    return 48LL;
  }
}

void *sub_100018804(void *result, uint64_t a2, uint64_t (*a3)(uint64_t))
{
  int *result = 0LL;
  if (a2)
  {
    uint64_t v4 = a2;
    int v5 = result;
    uint64_t v6 = a2;
    while (1)
    {
      uint64_t v6 = a3(v6);
      if (!v6) {
        return (void *)sub_100033898( v5,  v4,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  95LL);
      }
      if (*(_BYTE *)(v4 + 222) != 2) {
        break;
      }
      if (*(_BYTE *)(v6 + 222) == 2)
      {
        int v7 = (void *)(v6 + 264);
        uint64_t v8 = (void *)(v4 + 264);
LABEL_8:
        if (*v7 > *v8) {
          uint64_t v4 = v6;
        }
      }
    }

    int v7 = (void *)(v6 + 88);
    uint64_t v8 = (void *)(v4 + 88);
    goto LABEL_8;
  }

  return result;
}

uint64_t sub_1000188A8(uint64_t a1)
{
  v2.in_addr_t s_addr = *(_DWORD *)(*(void *)a1 + 24LL);
  uint64_t v3 = inet_ntoa(v2);
  snprintf(__str, 0x100uLL, "DHCPLEASEQUERY from %s", v3);
  int v8 = *(_DWORD *)(*(void *)a1 + 24LL);
  if (!v8)
  {
    v74.in_addr_t s_addr = *(_DWORD *)(*(void *)a1 + 12LL);
    inet_ntoa(v74);
    return sub_1000622D4( "%s: missing giaddr, ciaddr is %s, no reply sent",  v75,  v76,  v77,  v78,  v79,  v80,  v81,  (char)__str);
  }

  uint64_t v208 = 0LL;
  LODWORD(v218[0]) = 4;
  DWORD1(v218[0]) = v8;
  sub_10002A994( (uint64_t)&v208,  v218,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  190LL,  v4,  v5,  v6,  v7);
  if (!v208)
  {
    LODWORD(v218[0]) = 4;
    DWORD1(v218[0]) = v8;
    sub_100040144((int *)v218, v9, v10, v11, v12, v13, v14, v15);
    return sub_1000622D4("%s: unknown subnet for address %s", v83, v84, v85, v86, v87, v88, v89, (char)__str);
  }

  uint64_t v207 = 0LL;
  if (!sub_1000347D8( (uint64_t *)&v207,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  198LL,  v11,  v12,  v13,  v14,  v15))
  {
    sub_1000235C8(&v208, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c", 199LL);
    sub_10006221C("No memory for option state.", v96, v97, v98, v99, v100, v101, v102, v198);
    return sub_1000622D4("%s: out of memory, no reply sent", v103, v104, v105, v106, v107, v108, v109, (char)__str);
  }

  sub_10003E0AC( 0LL,  (int *)a1,  0LL,  0LL,  *(void *)(a1 + 160),  (uint64_t)v207,  &qword_10008C730,  *(void *)(v208 + 128),  0LL);
  uint64_t v16 = *(unsigned int *)(a1 + 168);
  if ((int)v16 >= 1)
  {
    unint64_t v17 = v16 + 1;
    do
      sub_10003E0AC( 0LL,  (int *)a1,  0LL,  0LL,  *(void *)(a1 + 160),  (uint64_t)v207,  &qword_10008C730,  *(void *)(*(void *)(a1 + 8LL * (v17-- - 2) + 176) + 136LL),  *(void **)(v208 + 128));
    while (v17 > 1);
  }

  sub_1000235C8(&v208, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c", 226LL);
  uint64_t v23 = sub_100040D4C(&qword_10008BF80, (uint64_t)v207, 49LL, v18, v19, v20, v21, v22);
  if (!v23
    || !sub_100057AF8( &v206,  (unsigned int *)a1,  0LL,  0LL,  *(void *)(a1 + 160),  (uint64_t)v207,  &qword_10008C730,  v23,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  0xF0u))
  {
    sub_1000622D4("%s: LEASEQUERY not allowed, query ignored", v24, v25, v26, v27, v28, v29, v30, (char)__str);
    uint64_t v95 = 245LL;
    return sub_100034894( &v207,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  v95,  v90,  v91,  v92,  v93,  v94);
  }

  int v31 = *(_DWORD *)(*(void *)a1 + 12LL);
  uint64_t v210 = 0LL;
  uint64_t v211 = 0LL;
  if (v31)
  {
    LODWORD(v218[0]) = 4;
    DWORD1(v218[0]) = v31;
    uint64_t v32 = sub_100040144((int *)v218, v24, v25, v26, v27, v28, v29, v30);
    snprintf(v222, 0x80uLL, "IP %s", v32);
    LODWORD(v218[0]) = 4;
    DWORD1(v218[0]) = v31;
    sub_10002A978( &v210,  (const char *)v218,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  267LL,  v33,  v34,  v35,  v36);
    int v37 = 0;
    goto LABEL_11;
  }

  uint64_t v212 = 0LL;
  uint64_t v213 = 0LL;
  uint64_t v214 = 0LL;
  if (!sub_100043AE8( (uint64_t)&v212,  (uint64_t)&qword_10008C168,  a1,  0LL,  0LL,  *(void *)(a1 + 160),  0LL,  *(void *)(a1 + 160),  (uint64_t)&qword_10008C730,  0x3Du,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  291))
  {
    uint64_t v178 = *(void *)a1;
    uint64_t v179 = *(unsigned __int8 *)(*(void *)a1 + 2LL);
    if (v179 >= 0x11)
    {
      sub_1000622D4( "%s: hardware length too long, no reply sent",  v110,  v111,  v112,  v113,  v114,  v115,  v116,  (char)__str);
      uint64_t v95 = 312LL;
      return sub_100034894( &v207,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  v95,  v90,  v91,  v92,  v93,  v94);
    }

    unsigned __int8 v219 = v179 + 1;
    unsigned __int8 v220 = *(_BYTE *)(v178 + 1);
    uint64_t v180 = v220;
    __memcpy_chk(v221, v178 + 28, v179, 16LL);
    uint64_t v181 = sub_1000501FC(v180, v179, v221);
    snprintf(v222, 0x80uLL, "MAC address %s", v181);
    sub_10002CE28( &v211,  (const char *)&v220,  v219,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  329LL,  v182,  v183,  v184);
    uint64_t v185 = v211;
    uint64_t v210 = 0LL;
    if (!v211) {
      goto LABEL_95;
    }
    uint64_t v186 = *((void *)v211 + 6);
    if (!v186)
    {
LABEL_86:
      sub_100033898(&v210, v185, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c", 95LL);
      uint64_t v189 = v211;
      if (v211)
      {
        int v37 = 0;
        uint64_t v190 = v210;
        do
        {
          if (v189 != v190 && *((_BYTE *)v189 + 222) == 2)
          {
            ++v37;
          }

          uint64_t v189 = (_DWORD *)*((void *)v189 + 6);
        }

        while (v189);
        goto LABEL_96;
      }

      goto LABEL_95;
    }

    while (*((_BYTE *)v185 + 222) == 2)
    {
      if (*(_BYTE *)(v186 + 222) == 2)
      {
        uint64_t v187 = (void *)(v186 + 264);
        uint64_t v188 = v185 + 66;
        goto LABEL_83;
      }

LABEL_85:
      uint64_t v186 = *(void *)(v186 + 48);
      if (!v186) {
        goto LABEL_86;
      }
    }

    uint64_t v187 = (void *)(v186 + 88);
    uint64_t v188 = v185 + 22;
LABEL_83:
    if (*v187 > *v188) {
      uint64_t v185 = (_DWORD *)v186;
    }
    goto LABEL_85;
  }

  uint64_t v117 = (const char *)sub_100050770((void *)v214, v213, 0x3Cu, 0);
  snprintf(v222, 0x80uLL, "client-id %s", v117);
  sub_10002CE00( &v211,  (const char *)v213,  v214,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  298LL,  v118,  v119,  v120);
  sub_100034EA8( &v212,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  299LL,  v121,  v122,  v123,  v124,  v125);
  uint64_t v126 = v211;
  uint64_t v210 = 0LL;
  if (v211)
  {
    uint64_t v127 = *((void *)v211 + 5);
    if (v127)
    {
      while (*((_BYTE *)v126 + 222) == 2)
      {
        if (*(_BYTE *)(v127 + 222) == 2)
        {
          unsigned int v128 = (void *)(v127 + 264);
          uint64_t v129 = v126 + 66;
          goto LABEL_49;
        }

          uint64_t v135 = v31;
          uint64_t v93 = 1;
          if (a15)
          {
            if (v147)
            {
              uint64_t v94 = sub_100042DBC(*(char **)(v147 + 8), a2, a3, a4, (uint64_t)a5, a6, a7, (uint64_t)a8);
              uint64_t v93 = v94 == 0;
              if (v94) {
                ++v42;
              }
            }
          }

          if (!v42)
          {
LABEL_136:
            sub_100034EA8( &v149,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  1456LL,  a4,  (uint64_t)a5,  a6,  a7,  (uint64_t)a8);
            uint64_t v18 = v136;
            int v31 = v135;
            uint64_t v32 = a9;
            uint64_t v33 = v123;
            goto LABEL_137;
          }

          uint64_t v95 = 0;
          uint64_t v121 = v153[0];
          uint64_t v120 = v152;
          uint64_t v96 = v42 > 0xFF;
          uint64_t v97 = v146;
          uint64_t v138 = v150;
          while (2)
          {
            if (v96)
            {
LABEL_92:
              if (HIDWORD(v153[0]) + 6 < v139)
              {
                uint64_t v98 = v139 - 5 - HIDWORD(v153[0]);
                uint64_t v99 = (int *)v153 + 1;
                uint64_t v96 = 1;
                goto LABEL_105;
              }

              if (v136 && LODWORD(v153[0]) + v136 + 4 < v132)
              {
                uint64_t v98 = v132 - 3 - (LODWORD(v153[0]) + v136);
                uint64_t v99 = (int *)v153;
                uint64_t v96 = 1;
                goto LABEL_116;
              }

              if (!v133 || v152 + v133 + 4 >= v131)
              {
                v153[0] = v121;
                uint64_t v152 = v120;
                goto LABEL_136;
              }

              uint64_t v98 = v131 - 3 - (v152 + v133);
              uint64_t v99 = &v152;
              uint64_t v96 = 1;
LABEL_112:
              uint64_t v102 = v130;
            }

            else if ((v135 != v134 {
                    || (!LODWORD(v153[0]) ? (uint64_t v100 = v152 == 0) : (uint64_t v100 = 0),
            }
                        v100 ? (uint64_t v101 = v42 + HIDWORD(v153[0]) + 2 >= v139) : (uint64_t v101 = 1),
                        v101))
                   && v42 + HIDWORD(v153[0]) + 5 >= v139)
            {
              if (!v136 || v124 + v42 + LODWORD(v153[0]) >= v132)
              {
                if (!v133 || v122 + v42 + v152 >= v131) {
                  goto LABEL_92;
                }
                uint64_t v96 = 0;
                uint64_t v99 = &v152;
                uint64_t v98 = v42;
                goto LABEL_112;
              }

              uint64_t v96 = 0;
              uint64_t v99 = (int *)v153;
              uint64_t v98 = v42;
LABEL_116:
              uint64_t v102 = v129;
            }

            else
            {
              uint64_t v96 = 0;
              uint64_t v99 = (int *)v153 + 1;
              uint64_t v98 = v42;
LABEL_105:
              uint64_t v102 = v137;
            }

            if (v98 >= v42) {
              uint64_t v98 = v42;
            }
            if (v98 >= 0xFF) {
              uint64_t v103 = 255LL;
            }
            else {
              uint64_t v103 = v98;
            }
            uint64_t v104 = *v99;
            uint64_t v105 = (_BYTE *)(v102 + v104);
            *uint64_t v105 = v97;
            v105[1] = v103;
            uint64_t v106 = v42 != (_DWORD)v103 || v93;
            if ((v106 & 1) != 0)
            {
              memcpy(v105 + 2, &v138[v95], v103);
            }

            else
            {
              if (v42 >= 2) {
                memcpy(v105 + 2, &v138[v95], v42 - 1);
              }
              *(_BYTE *)(v102 + v42 + v104 + 1) = 0;
            }

            v95 += v103;
            const char *v99 = v103 + v104 + 2;
            v42 -= v103;
            if (!v42) {
              goto LABEL_136;
            }
            continue;
          }
        }

LABEL_51:
        uint64_t v127 = *(void *)(v127 + 40);
        if (!v127) {
          goto LABEL_52;
        }
      }

      unsigned int v128 = (void *)(v127 + 88);
      uint64_t v129 = v126 + 22;
LABEL_49:
      if (*v128 > *v129) {
        uint64_t v126 = (_DWORD *)v127;
      }
      goto LABEL_51;
    }

          uint64_t v10 = 0LL;
LABEL_39:
          *uint64_t v11 = v15;
          goto LABEL_40;
        }
      }

      if (v15 == 98)
      {
        uint64_t v10 = 0LL;
        uint64_t v22 = 8;
LABEL_50:
        *uint64_t v11 = v22;
        goto LABEL_40;
      }

      if (v15 == 110)
      {
        uint64_t v10 = 0LL;
        uint64_t v22 = 10;
        goto LABEL_50;
      }

      if (v15 != 114) {
        goto LABEL_51;
      }
      uint64_t v10 = 0LL;
      *uint64_t v11 = 13;
LABEL_40:
      if (++v7 == 1500) {
        goto LABEL_80;
      }
    }
  }

  if (v4 > 0x7F)
  {
    if ((_DWORD)v4 == -1)
    {
      *(_DWORD *)(a1 + 240) = 0;
      return 607LL;
    }

    goto LABEL_109;
  }

  if (v183) {
    sub_100061FB4("Error getting interface information.", v10, v11, v12, v13, v14, v15, v16, v178);
  }
  freeifaddrs(v184[0]);
  v184[0] = 0LL;
  v184[1] = 0LL;
  uint64_t v36 = (in_addr_t **)qword_10008C0D0;
  uint64_t v182 = (in_addr_t **)qword_10008C0D0;
  if (qword_10008C0D0)
  {
    do
    {
      if (!v36[24])
      {
        int v37 = (in_addr_t *)sub_10005CDE4(0x20uLL);
        uint64_t v45 = v37;
        if (!v37) {
          sub_100061FB4("no space for ifp mockup.", v38, v39, v40, v41, v42, v43, v44, v178);
        }
        __strcpy_chk(v37);
        uint64_t v36 = v182;
        v182[24] = v45;
      }

      uint64_t v36 = (in_addr_t **)v36[4];
      uint64_t v182 = v36;
    }

    while (v36);
  }

  if (a1 != 2)
  {
    uint64_t v181 = 0LL;
    uint64_t v182 = 0LL;
    uint64_t v46 = (_DWORD *)qword_10008C0D0;
    if (qword_10008C0D0)
    {
      sub_10005CFB8(&v182, qword_10008C0D0);
      uint64_t v47 = v182;
      if (v182)
      {
        uint64_t v48 = 0LL;
        uint64_t v49 = 0;
        while (1)
        {
          unsigned int v50 = v48;
          unsigned int v51 = (uint64_t *)(v48 + 4);
          uint64_t v48 = v47;
          while (1)
          {
            if (v181)
            {
              sub_10005CFEC(&v181, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/discover.c", 1078LL);
              uint64_t v48 = v182;
            }

            uint64_t v52 = (uint64_t)v48[4];
            if (v52)
            {
              sub_10005CFB8(&v181, v52);
              uint64_t v48 = v182;
            }

            uint64_t v53 = *((_DWORD *)v48 + 51);
            if ((v53 & 4) == 0) {
              break;
            }
            sub_10005CFEC( (_DWORD **)&v182,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/discover.c",  1083LL);
            uint64_t v46 = v181;
            if (v181) {
              goto LABEL_90;
            }
LABEL_91:
            uint64_t v48 = v182;
            if (!v182) {
              goto LABEL_134;
            }
          }

          if (a1 == 4 && (v53 & 2) != 0)
          {
            v53 &= 0xFFFFFFFC;
            *((_DWORD *)v48 + 51) = v53;
          }

          if ((v53 & 1) == 0) {
            break;
          }
          uint64_t v57 = v48[5];
          uint64_t v58 = v48;
          if (a1 != 1 || v57)
          {
            if (v57)
            {
              unsigned int v128 = *((void *)v57 + 7);
              if (v128)
              {
                do
                {
                  if (!*(_DWORD *)(v128 + 64))
                  {
                    uint64_t v129 = v182;
                    if (*((int *)v182 + 20) < 1)
                    {
                      if (*((int *)v182 + 24) < 1)
                      {
                        sub_10006221C( "%s missing an interface address",  v52,  v30,  v31,  v32,  v33,  v34,  v35,  (_BYTE)v182 - 124);
                      }

                      else
                      {
                        *(_DWORD *)(v128 + 64) = 16;
                        *(_OWORD *)(v128 + 68) = *(_OWORD *)v129[11];
                      }
                    }

                    else
                    {
                      *(_DWORD *)(v128 + 64) = 4;
                      *(_DWORD *)(v128 + 68) = *v129[9];
                    }
                  }

                  unsigned int v128 = *(void *)(v128 + 40);
                }

                while (v128);
                uint64_t v58 = v182;
              }
            }

            *((_DWORD *)v58 + 37) = -1;
            if (dword_100089B0C == 2)
            {
              sub_1000352C4((uint64_t)v58);
              sub_1000351AC((uint64_t)v182);
            }

            else
            {
              sub_1000524CC((uint64_t)v58, (a1 | 2) == 3);
            }

            sub_10003B884((uint64_t)v182);
            if (fcntl(*((_DWORD *)v182 + 38), 2, 1LL) < 0) {
              sub_10006221C( "Can't set close-on-exec on %s: %m",  v130,  v131,  v132,  v133,  v134,  v135,  v136,  (_BYTE)v182 - 124);
            }
            ++v49;
            uint64_t v137 = *((_DWORD *)v182 + 39);
            if (*((_DWORD *)v182 + 38) != v137 && fcntl(v137, 2, 1LL) < 0) {
              sub_10006221C( "Can't set close-on-exec on %s: %m",  v138,  v139,  v140,  v141,  v142,  v143,  v144,  (_BYTE)v182 - 124);
            }
          }

          else
          {
            sub_10006221C("%s", v52, v30, v31, v32, v33, v34, v35, (char)&byte_1000728D2);
            uint64_t v66 = (char)v182;
            if (dword_100089B0C == 2)
            {
              uint64_t v67 = v182[9];
              if (v67)
              {
                v68.in_addr_t s_addr = *v67;
                inet_ntoa(v68);
              }

              sub_10006221C("No subnet declaration for %s (%s).", v59, v60, v61, v62, v63, v64, v65, v66 - 124);
            }

            else
            {
              uint64_t v69 = v182[11];
              if (v69)
              {
                inet_ntop(30, v69, (char *)v185, 0x2Eu);
                uint64_t v66 = (char)v182;
              }

              else
              {
                strcpy((char *)v185, "no IPv6 addresses");
              }

              sub_10006221C( "No subnet6 declaration for %s (%s).",  (uint64_t)v69,  v60,  v61,  v62,  v63,  v64,  v65,  v66 - 124);
            }

            if (!sub_100035828())
            {
              uint64_t v106 = "subnet6 declaration for this";
              if (dword_100089B0C == 2) {
                uint64_t v106 = "subnet declaration for this";
              }
              sub_10006221C("You must write a %s", v70, v71, v72, v73, v74, v75, v76, (char)v106);
              sub_10006221C( "subnet.   You cannot prevent %s",  v107,  v108,  v109,  v110,  v111,  v112,  v113,  (char)"the DHCP server");
              sub_10006221C( "from listening on this subnet %s",  v114,  v115,  v116,  v117,  v118,  v119,  v120,  (char)"because your");
              sub_100061FB4( "operating system does not %s.",  v121,  v122,  v123,  v124,  v125,  v126,  v127,  (char)"support this capability");
            }

            sub_10006221C("** Ignoring requests on %s.  %s", v70, v71, v72, v73, v74, v75, v76, (_BYTE)v182 - 124);
            uint64_t v84 = "a subnet6 declaration";
            if (dword_100089B0C == 2) {
              uint64_t v84 = "a subnet declaration";
            }
            sub_10006221C("   you want, please write %s", v77, v78, v79, v80, v81, v82, v83, (char)v84);
            sub_10006221C( "   in your dhcpd.conf file %s",  v85,  v86,  v87,  v88,  v89,  v90,  v91,  (char)"for the network segment");
            sub_10006221C("   to %s %s %s", v92, v93, v94, v95, v96, v97, v98, (char)"which interface");
            sub_10006221C("%s", v99, v100, v101, v102, v103, v104, v105, (char)&byte_1000728D2);
          }

          sub_10005CFEC( (_DWORD **)&v182,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/discover.c",  1245LL);
          uint64_t v46 = v181;
          if (v181) {
            sub_10005CFB8(&v182, (uint64_t)v181);
          }
          uint64_t v47 = v182;
          if (!v182) {
            goto LABEL_134;
          }
        }

        if ((v180 & 1) == 0) {
          sub_100061FB4("%s: not found", v52, v30, v31, v32, v33, v34, v35, (_BYTE)v48 - 124);
        }
        if (v50)
        {
          sub_10005CFEC( (_DWORD **)v51,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/discover.c",  1107LL);
          uint64_t v54 = v181;
          if (!v181) {
            goto LABEL_85;
          }
          uint64_t v55 = v51;
        }

        else
        {
          if (qword_10008C0D0) {
            sub_10005CFEC( (_DWORD **)&qword_10008C0D0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/discover.c",  1103LL);
          }
          uint64_t v54 = v181;
          if (!v181)
          {
LABEL_85:
            uint64_t v56 = v182;
            if (v182[4])
            {
              sub_10005CFEC( v182 + 4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/discover.c",  1113LL);
              uint64_t v56 = v182;
            }

            if (qword_10008C0A0)
            {
              sub_10005CFB8(v56 + 4, qword_10008C0A0);
              sub_10005CFEC( (_DWORD **)&qword_10008C0A0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/discover.c",  1120LL);
              uint64_t v56 = v182;
            }

            sub_10005CFB8(&qword_10008C0A0, (uint64_t)v56);
            sub_10005CFEC( (_DWORD **)&v182,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/discover.c",  1123LL);
            uint64_t v46 = v181;
            if (!v181) {
              goto LABEL_91;
            }
LABEL_90:
            sub_10005CFB8(&v182, (uint64_t)v46);
            goto LABEL_91;
          }

          uint64_t v55 = &qword_10008C0D0;
        }

        sub_10005CFB8(v55, (uint64_t)v54);
        goto LABEL_85;
      }

      uint64_t v49 = 0;
LABEL_134:
      uint64_t v145 = (in_addr_t **)qword_10008C0D0;
      uint64_t v182 = (in_addr_t **)qword_10008C0D0;
      if (qword_10008C0D0)
      {
        do
        {
          if ((*((_BYTE *)v145 + 204) & 4) == 0 && *((_DWORD *)v145 + 38) != -1)
          {
            if (dword_100089B0C == 30) {
              uint64_t v146 = sub_10003BA14;
            }
            else {
              uint64_t v146 = sub_10003BB68;
            }
            uint64_t v147 = sub_100060E24((uint64_t)v145, (uint64_t)sub_10003B9F0, 0LL, (uint64_t)v146, 0LL, 0LL);
            if (v147)
            {
              uint64_t v148 = (_BYTE)v182 - 124;
              sub_100067900(v147);
              sub_100061FB4("Can't register I/O handle for %s: %s", v149, v150, v151, v152, v153, v154, v155, v148);
            }

            if (dword_100089B0C == 30) {
              break;
            }
            uint64_t v145 = v182;
          }

          uint64_t v145 = (in_addr_t **)v145[4];
          uint64_t v182 = v145;
        }

        while (v145);
      }
    }

    else
    {
      uint64_t v49 = 0;
      uint64_t v182 = 0LL;
    }

    if (a1 == 1 && !v49)
    {
      sub_1000622D4("%s", (uint64_t)v46, v30, v31, v32, v33, v34, v35, (char)&byte_1000728D2);
      sub_100061FB4("Not configured to listen on any interfaces!", v156, v157, v158, v159, v160, v161, v162, v179);
    }

    if (dword_100089B0C == 2 && (byte_1000BD314 & 1) == 0)
    {
      byte_1000BD314 = 1;
      sub_100035830();
    }

    if (qword_10008C0A8)
    {
      if (fcntl(*(_DWORD *)(qword_10008C0A8 + 152), 2) < 0) {
        sub_10006221C("Can't set close-on-exec on fallback: %m", v163, v164, v165, v166, v167, v168, v169, 1);
      }
      uint64_t v170 = *(_DWORD *)(qword_10008C0A8 + 156);
      if (*(_DWORD *)(qword_10008C0A8 + 152) != v170 && fcntl(v170, 2) < 0) {
        sub_10006221C("Can't set close-on-exec on fallback: %m", v171, v172, v173, v174, v175, v176, v177, 1);
      }
    }
  }

LABEL_52:
    sub_100033898(&v210, v126, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c", 95LL);
    uint64_t v130 = v211;
    if (v211)
    {
      int v37 = 0;
      uint64_t v131 = v210;
      do
      {
        if (v130 != v131 && *((_BYTE *)v130 + 222) == 2)
        {
          ++v37;
        }

        uint64_t v130 = (_DWORD *)*((void *)v130 + 5);
      }

      while (v130);
      goto LABEL_96;
    }
  }

    sub_10005E974(0LL, (uint64_t)v32, (unsigned __int16)__size);
    *(_DWORD *)(a1 + 76) += (unsigned __int16)__size;
LABEL_53:
    unsigned int v50 = *(_DWORD *)(a1 + 76);
    uint64_t v53 = *(unsigned __int16 *)(a1 + 72);
    if (v50 >= v53) {
      goto LABEL_83;
    }
  }

  uint64_t v58 = *((unsigned int *)&unk_100088C60 + 8 * (unsigned __int16)v117 + 4);
  if ((_DWORD)v58 == 10)
  {
    *(_DWORD *)(a1 + 76) = v56;
    if (v56 == v57)
    {
      sub_10005E974(0LL, (uint64_t)v32, v52);
      goto LABEL_53;
    }

    uint64_t v97 = "FAILOVER: digest not at end of message";
LABEL_109:
    sub_10006221C(v97, v44, v52, v45, v46, v47, v48, v49, v116);
    goto LABEL_110;
  }

  if ((_DWORD)v58 == 9) {
    goto LABEL_52;
  }
  uint64_t v59 = *(void *)v43;
  unsigned int v60 = (char *)&unk_100088C60 + 32 * (unsigned __int16)v117;
  unsigned int v61 = *((_DWORD *)v60 + 7);
  if ((v61 & *(_DWORD *)(*(void *)v43 + 16LL)) != 0)
  {
    sub_10006221C( "FAILOVER: duplicate option %s",  v44,  (unsigned __int16)__size,  v45,  v46,  v47,  v48,  v49,  *((void *)v60 + 1));
    goto LABEL_110;
  }

  uint64_t v62 = (char *)&unk_100088C60 + 32 * (unsigned __int16)v117;
  uint64_t v63 = *((_DWORD *)v62 + 5);
  if (v63)
  {
    uint64_t v64 = dword_100089054[v58];
    if (v64 * v63 != (unsigned __int16)__size)
    {
      sub_10006221C( "FAILOVER: option size (%d:%d), option %s",  v44,  (unsigned __int16)__size,  v45,  v46,  v47,  v48,  v49,  __size);
      goto LABEL_110;
    }

    uint64_t v65 = (char *)(v59 + *((int *)v62 + 6));
    goto LABEL_70;
  }

  if ((_DWORD)v58 == 6)
  {
    uint64_t v66 = v59 + *((int *)&unk_100088C60 + 8 * (unsigned __int16)v117 + 6);
    sub_10005E974((char *)v66, (uint64_t)v32, 1u);
    ++*(_DWORD *)(a1 + 76);
    *(_BYTE *)(v66 + 1) = 0;
    uint64_t v67 = (unsigned __int16)__size - 1;
    *(_DWORD *)(v66 + 4) = v67;
    uint64_t v68 = (char *)sub_10005CDE4(v67);
    *(void *)(v66 + 8) = v68;
    if (!v68)
    {
      sub_10006221C("FAILOVER: no memory getting%s(%d)", v69, v70, v71, v72, v73, v74, v75, (char)" DNS data ");
      goto LABEL_110;
    }

    sub_10005E974(v68, (uint64_t)v32, v67);
    goto LABEL_82;
  }

  uint64_t v64 = dword_100089054[v58];
  uint64_t v63 = (unsigned __int16)__size / v64;
  if (v64 < 2 || !((unsigned __int16)__size % v64))
  {
    uint64_t v76 = v59 + *((int *)&unk_100088C60 + 8 * (unsigned __int16)v117 + 6);
    *(_DWORD *)uint64_t v76 = v63;
    uint64_t v77 = (char *)sub_10005CDE4(v52);
    *(void *)(v76 + 8) = v77;
    if (!v77)
    {
      sub_10006221C("FAILOVER: no memory getting %s (%d)", v44, v52, v45, v46, v47, v48, v49, (char)"option data");
      goto LABEL_110;
    }

    uint64_t v65 = v77;
LABEL_70:
    if (v64 == 1 || *((_DWORD *)&unk_100088C60 + 8 * (unsigned __int16)v117 + 4) == 1)
    {
      sub_10005E974(v65, (uint64_t)v32, (unsigned __int16)__size);
      uint64_t v78 = (unsigned __int16)__size;
      *(_DWORD *)(a1 + 76) += (unsigned __int16)__size;
      if ((unsigned __int16)v117 == 11 && v78 >= 0xA && !strncmp(v65, "isc-V3.0.", 9uLL)) {
        sub_10006221C( "WARNING: failover as of versions 3.1.0 and on are not reverse compatible with versions 3.0.x.",  v44,  v52,  v45,  v46,  v47,  v48,  v49,  v116);
      }
    }

    else
    {
      for (; v63; --v63)
      {
        uint64_t v79 = *((_DWORD *)&unk_100088C60 + 8 * (unsigned __int16)v117 + 4);
        if (v79 == 7)
        {
          sub_10005EF90((uint64_t)v32, v65);
          uint64_t v80 = 2LL;
          uint64_t v81 = 2;
        }

        else
        {
          if (v79 != 2)
          {
            sub_10006221C( "FAILOVER: option %s: bad type %d",  v44,  v52,  v45,  v46,  v47,  v48,  v49,  *((void *)&unk_100088C60 + 4 * (unsigned __int16)v117 + 1));
            goto LABEL_110;
          }

          sub_10005EF20((uint64_t)v32, v65);
          uint64_t v80 = 4LL;
          uint64_t v81 = 4;
        }

        v65 += v80;
        *(_DWORD *)(a1 + 76) += v81;
      }
    }

        uint64_t v20 = &byte_1000728D2;
        uint64_t v21 = ")";
        uint64_t v84 = v11;
        goto LABEL_85;
      case 0x1F:
        uint64_t v20 = &byte_1000728D2;
        uint64_t v21 = "lease-time";
        goto LABEL_84;
      case 0x20:
        uint64_t v88 = sub_10005179C(v11, v9, v8, &byte_1000728D2, &byte_1000728D2, "ns-update");
        uint64_t v89 = sub_10005179C(v11, v88, v8, " ", &byte_1000728D2, "(");
        uint64_t v90 = 0LL;
        break;
      case 0x21:
        uint64_t v20 = &byte_1000728D2;
        uint64_t v21 = "static";
        goto LABEL_84;
      case 0x22:
        uint64_t v92 = sub_10005179C(v11, v9, v8, &byte_1000728D2, &byte_1000728D2, "update");
        uint64_t v93 = sub_10005179C(v11, v92, v8, " ", &byte_1000728D2, "(");
        __sprintf_chk(__s, 0, 0x41uLL, "%d", *(_DWORD *)(v10 + 8));
        uint64_t v94 = sub_10005179C(v11, v93, v93, &byte_1000728D2, &byte_1000728D2, __s);
        uint64_t v95 = sub_10005179C(v11, v94, v93, &byte_1000728D2, " ", ",");
        __sprintf_chk(__s, 0, 0x41uLL, "%d", *(_DWORD *)(v10 + 12));
        uint64_t v96 = sub_10005179C(v11, v95, v93, &byte_1000728D2, &byte_1000728D2, __s);
        uint64_t v97 = sub_10005179C(v11, v96, v93, &byte_1000728D2, " ", ",");
        uint64_t v98 = sub_100057E58(v11, *(void *)(v10 + 16), v97, v93, 0LL);
        uint64_t v99 = sub_10005179C(v11, v98, v93, &byte_1000728D2, " ", ",");
        uint64_t v100 = sub_100057E58(v11, *(void *)(v10 + 24), v99, v93, 0LL);
        uint64_t v101 = sub_10005179C(v11, v100, v93, &byte_1000728D2, " ", ",");
        uint64_t v102 = *(void *)(v10 + 32);
        goto LABEL_67;
      case 0x23:
        uint64_t v16 = "delete";
        goto LABEL_66;
      case 0x24:
        goto LABEL_66;
      case 0x25:
        uint64_t v16 = "not exists";
LABEL_66:
        uint64_t v103 = sub_10005179C(v11, v9, v8, &byte_1000728D2, &byte_1000728D2, v16);
        uint64_t v93 = sub_10005179C(v11, v103, v8, " ", &byte_1000728D2, "(");
        __sprintf_chk(__s, 0, 0x41uLL, "%d", *(_DWORD *)(v10 + 8));
        uint64_t v104 = sub_10005179C(v11, v93, v93, &byte_1000728D2, &byte_1000728D2, __s);
        uint64_t v105 = sub_10005179C(v11, v104, v93, &byte_1000728D2, " ", ",");
        __sprintf_chk(__s, 0, 0x41uLL, "%d", *(_DWORD *)(v10 + 12));
        uint64_t v106 = sub_10005179C(v11, v105, v93, &byte_1000728D2, &byte_1000728D2, __s);
        uint64_t v107 = sub_10005179C(v11, v106, v93, &byte_1000728D2, " ", ",");
        uint64_t v108 = sub_100057E58(v11, *(void *)(v10 + 16), v107, v93, 0LL);
        uint64_t v101 = sub_10005179C(v11, v108, v93, &byte_1000728D2, " ", ",");
        uint64_t v102 = *(void *)(v10 + 24);
LABEL_67:
        uint64_t v63 = sub_100057E58(v11, v102, v101, v93, 0LL);
LABEL_68:
        uint64_t v66 = v63;
        uint64_t v64 = ")";
        uint64_t v65 = v11;
        uint64_t v67 = v8;
        return sub_10005179C(v65, v66, v67, &byte_1000728D2, &byte_1000728D2, v64);
      case 0x26:
        uint64_t v19 = "!=";
        goto LABEL_92;
      case 0x28:
        uint64_t v109 = sub_10005179C(v11, v8, v8, &byte_1000728D2, &byte_1000728D2, "defined");
        uint64_t v110 = sub_10005179C(v11, v109, v8, " ", &byte_1000728D2, "(");
        uint64_t v44 = sub_10005179C(v11, v110, v8, &byte_1000728D2, &byte_1000728D2, *(char **)(v10 + 8));
        uint64_t v21 = ")";
        goto LABEL_73;
      case 0x29:
        uint64_t v21 = *(char **)(v10 + 8);
        uint64_t v20 = &byte_1000728D2;
        uint64_t v84 = v11;
        uint64_t v44 = v8;
        goto LABEL_85;
      case 0x2F:
        uint64_t v19 = "+";
        goto LABEL_92;
      case 0x30:
        uint64_t v19 = "-";
        goto LABEL_92;
      case 0x31:
        uint64_t v19 = "*";
        goto LABEL_92;
      case 0x32:
        uint64_t v19 = "/";
        goto LABEL_92;
      case 0x33:
        uint64_t v19 = "%";
        goto LABEL_92;
      case 0x34:
        uint64_t v19 = "&";
        goto LABEL_92;
      case 0x35:
        uint64_t v19 = "|";
        goto LABEL_92;
      case 0x36:
        uint64_t v19 = "^";
        goto LABEL_92;
      case 0x37:
        uint64_t v20 = &byte_1000728D2;
        uint64_t v21 = "client-state";
LABEL_84:
        uint64_t v84 = v11;
        uint64_t v44 = v9;
        goto LABEL_85;
      case 0x38:
        uint64_t v39 = "ucase";
        goto LABEL_87;
      case 0x39:
LABEL_14:
        uint64_t v39 = "lcase";
LABEL_87:
        uint64_t v111 = sub_10005179C(v11, v9, v8, &byte_1000728D2, &byte_1000728D2, v39);
        uint64_t v32 = sub_10005179C(v11, v111, v8, " ", &byte_1000728D2, "(");
        uint64_t v33 = *(void *)(v10 + 8);
        uint64_t v77 = v11;
        uint64_t v78 = v32;
        uint64_t v79 = 1LL;
LABEL_88:
        unsigned int v50 = sub_100057E58(v77, v33, v32, v78, v79);
LABEL_89:
        uint64_t v44 = v50;
        uint64_t v21 = ")";
        uint64_t v84 = v11;
        uint64_t v85 = v8;
        uint64_t v20 = &byte_1000728D2;
        return sub_10005179C(v84, v44, v85, v20, &byte_1000728D2, v21);
      case 0x3A:
        goto LABEL_92;
      case 0x3B:
        uint64_t v19 = "~~";
LABEL_92:
        uint64_t v112 = sub_100057E58(v11, *(void *)(v10 + 8), v9, v8, 1LL);
        uint64_t v113 = sub_10005179C(v11, v112, v8, " ", " ", v19);
        a2 = *(void *)(v10 + 16);
        a3 = v113;
        a4 = (v8 + 2);
        a1 = v11;
        a5 = 0LL;
        continue;
      default:
        sub_100061FB4( "invalid expression type in print_expression: %d",  a2,  a3,  a4,  a5,  (uint64_t)"exists",  a7,  a8,  *(_DWORD *)(v10 + 4));
    }

    break;
  }

  while (*(_DWORD *)(v10 + 4) == 32)
  {
    uint64_t v91 = (_DWORD)v90 == 0;
    if ((_DWORD)v90) {
      uint64_t v90 = v90;
    }
    else {
      uint64_t v90 = v89;
    }
    LODWORD(v89) = sub_100057E58(v11, *(void *)(v10 + 8), v89, v90, v91);
    if (*(void *)(v10 + 16))
    {
      uint64_t v89 = sub_10005179C(v11, v89, v90, &byte_1000728D2, " ", ",");
      uint64_t v10 = *(void *)(v10 + 16);
      if (v10) {
        continue;
      }
    }

    goto LABEL_95;
  }

  LODWORD(v89) = sub_100057E58(v11, v10, v89, v90, 0LL);
LABEL_95:
  uint64_t v20 = &byte_1000728D2;
  uint64_t v21 = ")";
  uint64_t v84 = v11;
  uint64_t v44 = v89;
LABEL_85:
  uint64_t v85 = v8;
  return sub_10005179C(v84, v44, v85, v20, &byte_1000728D2, v21);
}

  if (v50) {
    sub_10003C8CC(&v50, v8, v9, v10, v11, v12, v13, v14);
  }
  return v23;
}

LABEL_95:
  int v37 = 0;
LABEL_96:
  sub_10003389C(&v211, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c", 339LL);
  if (v210) {
    *(_DWORD *)(*(void *)a1 + 12LL) = v210[15];
  }
  if (v37 >= 41) {
    sub_1000622D4( "%d IP addresses associated with %s, only %d sent in reply.",  v191,  v192,  v193,  v194,  v195,  v196,  v197,  v37);
  }
LABEL_11:
  v38.in_addr_t s_addr = *(_DWORD *)(*(void *)a1 + 24LL);
  uint64_t v39 = inet_ntoa(v38);
  snprintf(__str, 0x100uLL, "DHCPLEASEQUERY from %s for %s", v39, v222);
  uint64_t v44 = v210;
  if (v210)
  {
    if (*((_BYTE *)v210 + 222) == 2)
    {
      char v209 = 13;
      uint64_t v45 = *(void *)a1;
      *(_BYTE *)(v45 + 2) = *((_BYTE *)v210 + 203) - 1;
      *(_BYTE *)(v45 + 1) = *((_BYTE *)v44 + 204);
      *(_OWORD *)(v45 + 28) = *(_OWORD *)((char *)v44 + 205);
      if (*((_WORD *)v44 + 96))
      {
        if (!sub_100046588( (uint64_t)v207,  61,  *((const void **)v44 + 23),  *((unsigned __int16 *)v44 + 96)))
        {
          sub_100034894( &v207,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  407LL,  v46,  v40,  v41,  v42,  v43);
          uint64_t v73 = 408LL;
          goto LABEL_105;
        }

        uint64_t v44 = v210;
      }

      uint64_t v48 = v44 + 20;
      uint64_t v47 = *((void *)v44 + 10);
      uint64_t v49 = *((void *)v48 + 1) - v47;
      unsigned int v50 = (v49 >> 1) + v47;
      unsigned int v51 = (v49 >> 3) + (v49 >> 2) + v50;
      unsigned int v204 = v51;
      unsigned int v205 = v50;
      uint64_t v52 = xmmword_10008CE80;
      if ((uint64_t)xmmword_10008CE80 < v50)
      {
        unsigned int v205 = bswap32(v50 - xmmword_10008CE80);
        if (!sub_100046588((uint64_t)v207, 58, &v205, 4))
        {
          sub_100034894( &v207,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  438LL,  v53,  v40,  v41,  v42,  v43);
          uint64_t v73 = 439LL;
          goto LABEL_105;
        }

        uint64_t v52 = xmmword_10008CE80;
      }

      if (v52 < v51)
      {
        unsigned int v204 = bswap32(v51 - v52);
        if (!sub_100046588((uint64_t)v207, 59, &v204, 4))
        {
          sub_100034894( &v207,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  452LL,  v54,  v40,  v41,  v42,  v43);
          uint64_t v73 = 453LL;
          goto LABEL_105;
        }

        uint64_t v52 = xmmword_10008CE80;
      }

      uint64_t v55 = v210;
      uint64_t v56 = *((void *)v210 + 11);
      if (v56 > v52)
      {
        unsigned int v203 = bswap32(v56 - v52);
        if (!sub_100046588((uint64_t)v207, 51, &v203, 4))
        {
          sub_100034894( &v207,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  466LL,  v57,  v40,  v41,  v42,  v43);
          uint64_t v73 = 467LL;
          goto LABEL_105;
        }

        uint64_t v55 = v210;
      }

      uint64_t v58 = (_DWORD *)*((void *)v55 + 19);
      if (v58)
      {
        sub_100033F18( &v207[2 * dword_10008BF78 + 4],  v58,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  488LL,  v40,  v41,  v42,  v43);
        uint64_t v55 = v210;
      }

      uint64_t v59 = *((void *)v55 + 33);
      if (v59)
      {
        unsigned int v60 = bswap32(xmmword_10008CE80 - v59);
        unsigned int v61 = (uint64_t)xmmword_10008CE80 <= v59 ? 0 : v60;
        unsigned int v202 = v61;
        if (!sub_100046588((uint64_t)v207, 91, &v202, 4))
        {
          sub_100034894( &v207,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  510LL,  v62,  v63,  v64,  v65,  v66);
          uint64_t v73 = 511LL;
          goto LABEL_105;
        }
      }

      uint64_t v67 = "DHCPLEASEACTIVE";
      if (!v31 && v37 >= 1 && !sub_100046588((uint64_t)v207, 92, v218, 4 * v37))
      {
        sub_100034894( &v207,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  526LL,  v68,  v69,  v70,  v71,  v72);
        uint64_t v73 = 527LL;
LABEL_105:
        sub_10003389C(&v210, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c", v73);
        return sub_1000622D4("%s: out of memory, no reply sent", v103, v104, v105, v106, v107, v108, v109, (char)__str);
      }
    }

    else
    {
      char v209 = 11;
      uint64_t v67 = "DHCPLEASEUNASSIGNED";
    }
  }

  else
  {
    char v209 = 12;
    uint64_t v67 = "DHCPLEASEUNKNOWN";
  }

  **(_BYTE **)a1 = 2;
  if (sub_100046588((uint64_t)v207, 53, &v209, 1))
  {
    sub_1000622D4("%s", v132, v133, v134, v135, v136, v137, v138, (char)__str);
    sub_1000158D4(&v201, (uint64_t)v207, a1, v139, v140, v141, v142, v143);
    v199[0] = 0LL;
    v199[1] = 0LL;
    uint64_t v200 = 0LL;
    uint64_t v149 = sub_100040D4C(&qword_10008C168, (uint64_t)v207, 55LL, v144, v145, v146, v147, v148);
    if (v149)
    {
      sub_100057AA4( v199,  (unsigned int *)a1,  0LL,  0LL,  *(void *)(a1 + 160),  (uint64_t)v207,  &qword_10008C730,  v149,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  0x244u);
      if ((_DWORD)v200) {
        uint64_t v150 = v199;
      }
      else {
        uint64_t v150 = 0LL;
      }
    }

    else
    {
      uint64_t v150 = 0LL;
    }

    *(_DWORD *)(a1 + 12) = sub_100041504( a1,  *(void *)a1,  (uint64_t)v210,  0LL,  0LL,  *(int **)(a1 + 160),  v207,  &qword_10008C730,  0,  0,  0,  (uint64_t)v150,  0LL);
    sub_100034EA8( v199,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  602LL,  v158,  v159,  v160,  v161,  v162);
    sub_100034894( &v207,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  603LL,  v163,  v164,  v165,  v166,  v167);
    sub_10003389C(&v210, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c", 604LL);
    v215[0] = 528;
    uint64_t v217 = 0LL;
    v168.in_addr_t s_addr = *(_DWORD *)(*(void *)a1 + 24LL);
    in_addr_t s_addr = v168.s_addr;
    uint64_t v169 = &word_10008C104;
    if (v168.s_addr != 16777343) {
      uint64_t v169 = &word_10008C0F4;
    }
    v215[1] = *v169;
    uint64_t v170 = qword_10008C0A8;
    if (!qword_10008C0A8) {
      uint64_t v170 = *(void *)(a1 + 104);
    }
    inet_ntoa(v168);
    sub_1000622D4("%s to %s for %s (%d associated IPs)", v171, v172, v173, v174, v175, v176, v177, (char)v67);
    return sub_100035510(v170, 0, *(void **)a1, *(unsigned int *)(a1 + 12), v201, (uint64_t)v215, 0LL);
  }

  else
  {
    sub_100034894( &v207,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  548LL,  v134,  v135,  v136,  v137,  v138);
    sub_10003389C(&v210, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c", 549LL);
    return sub_1000622D4( "%s: error adding option, no reply sent",  v151,  v152,  v153,  v154,  v155,  v156,  v157,  (char)__str);
  }

uint64_t sub_100019374( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  xmmword_10008D0E0 = 0u;
  *(_OWORD *)&qword_10008D0F0 = 0u;
  xmmword_10008D100 = 0u;
  *(_OWORD *)&dword_10008D110 = 0u;
  xmmword_10008D120 = 0u;
  qword_10008D148 = 0LL;
  qword_10008D150 = 0LL;
  sub_100034AD8( (uint64_t *)&xmmword_10008D0E0,  a2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  1021LL,  a5,  a6,  a7,  a8);
  uint64_t v9 = xmmword_10008D0E0;
  int v16 = sub_10001A334(xmmword_10008D0E0, (uint64_t)&xmmword_10008D0E0 + 8, v10, v11, v12, v13, v14, v15);
  if (v16)
  {
    uint64_t v24 = qword_100089DB8[*(unsigned __int8 *)(v9 + 20)];
    __int128 v150 = *(_OWORD *)(v9 + 80);
    int v151 = *(_DWORD *)(v9 + 96);
    if (v16 == 23)
    {
      sub_100040144((int *)&v150, v17, v18, v19, v20, v21, v22, v23);
      uint64_t result = sub_10006238C("Discarding %s from %s; client identifier missing", v25, v26, v27, v28, v29, v30, v31, v24);
    }

    else
    {
      sub_100040144((int *)&v150, v17, v18, v19, v20, v21, v22, v23);
      uint64_t result = sub_10006221C( "Error processing %s from %s; unable to evaluate Client Identifier",
                 v62,
                 v63,
                 v64,
                 v65,
                 v66,
                 v67,
                 v68,
                 v24);
    }

    goto LABEL_27;
  }

  uint64_t v38 = sub_100040D4C(&qword_10008C1F8, *(void *)(v9 + 160), 2LL, v19, v20, v21, v22, v23);
  if (v38)
  {
    int v46 = sub_100057AA4( &xmmword_10008D100,  (unsigned int *)v9,  0LL,  0LL,  *(void *)(v9 + 160),  0LL,  &qword_10008C730,  v38,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  0x303u);
    uint64_t v54 = qword_100089DB8[*(unsigned __int8 *)(v9 + 20)];
    if (v46)
    {
      __int128 v150 = *(_OWORD *)(v9 + 80);
      int v151 = *(_DWORD *)(v9 + 96);
      sub_100040144((int *)&v150, v47, v48, v49, v50, v51, v52, v53);
      sub_100050770((void *)dword_10008D0F8, (unsigned __int8 *)qword_10008D0F0, 0x3Cu, 0);
      sub_100050770((void *)dword_10008D110, *((unsigned __int8 **)&xmmword_10008D100 + 1), 0x3Cu, 1);
      uint64_t result = sub_10006238C( "Discarding %s from %s; server identifier found (CLIENTID %s, SERVERID %s)",
                 v55,
                 v56,
                 v57,
                 v58,
                 v59,
                 v60,
                 v61,
                 v54);
    }

    else
    {
      sub_100050770((void *)dword_10008D0F8, (unsigned __int8 *)qword_10008D0F0, 0x3Cu, 0);
      __int128 v150 = *(_OWORD *)(v9 + 80);
      int v151 = *(_DWORD *)(v9 + 96);
      sub_100040144((int *)&v150, v103, v104, v105, v106, v107, v108, v109);
      uint64_t result = sub_10006238C( "Discarding %s from %s; server identifier found (CLIENTID %s)",
                 v110,
                 v111,
                 v112,
                 v113,
                 v114,
                 v115,
                 v116,
                 v54);
    }

    goto LABEL_27;
  }

  if ((void)xmmword_10008D120 || DWORD2(xmmword_10008D120)) {
    goto LABEL_25;
  }
  uint64_t v69 = xmmword_10008D0E0;
  uint64_t v70 = sub_100040D4C(&qword_10008C1F8, *(void *)(xmmword_10008D0E0 + 160), 44LL, v41, v42, v43, v44, v45);
  if (!v70)
  {
    uint64_t v125 = qword_100089DB8[*(unsigned __int8 *)(v9 + 20)];
    __int128 v150 = *(_OWORD *)(v9 + 80);
    int v151 = *(_DWORD *)(v9 + 96);
    sub_100040144((int *)&v150, v71, v72, v73, v74, v75, v76, v77);
    uint64_t result = sub_10006238C("Discarding %s from %s; lq-query missing", v126, v127, v128, v129, v130, v131, v132, v125);
    goto LABEL_27;
  }

  if (!sub_100057AA4( &qword_10008D118,  (unsigned int *)v69,  0LL,  0LL,  *(void *)(v69 + 160),  0LL,  &qword_10008C730,  v70,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  0x2DBu))
  {
LABEL_25:
    uint64_t v117 = qword_100089DB8[*(unsigned __int8 *)(v9 + 20)];
    __int128 v150 = *(_OWORD *)(v9 + 80);
    int v151 = *(_DWORD *)(v9 + 96);
    sub_100040144((int *)&v150, v39, v40, v41, v42, v43, v44, v45);
    uint64_t result = sub_10006221C( "Error processing %s from %s; unable to evaluate LQ-Query",
               v118,
               v119,
               v120,
               v121,
               v122,
               v123,
               v124,
               v117);
LABEL_27:
    if (dword_10008D0F8) {
      uint64_t result = (uint64_t)sub_100034EA8( (_DWORD **)&xmmword_10008D0E0 + 1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  815LL,  v33,  v34,  v35,  v36,  v37);
    }
    if (dword_10008D110) {
      uint64_t result = (uint64_t)sub_100034EA8( (_DWORD **)&xmmword_10008D100,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  818LL,  v33,  v34,  v35,  v36,  v37);
    }
    if (DWORD2(xmmword_10008D120)) {
      uint64_t result = (uint64_t)sub_100034EA8( &qword_10008D118,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  821LL,  v33,  v34,  v35,  v36,  v37);
    }
    goto LABEL_33;
  }

  if (!sub_1000347D8( &qword_10008D150,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  1033LL,  v41,  v42,  v43,  v44,  v45)) {
    goto LABEL_56;
  }
  sub_10003E0AC( 0LL,  (int *)xmmword_10008D0E0,  0LL,  0LL,  *(void *)(xmmword_10008D0E0 + 160),  qword_10008D150,  &qword_10008C730,  qword_10008C140,  0LL);
  byte_10008D15C[0] = 15;
  char v83 = *(_BYTE *)(xmmword_10008D0E0 + 23);
  unk_10008D15D = *(_WORD *)(xmmword_10008D0E0 + 21);
  byte_10008D15F = v83;
  uint64_t v89 = sub_100040D4C(&qword_10008BF80, qword_10008D150, 49LL, v84, v85, v86, v87, v88);
  if (!v89
    || !sub_100057AF8( 0LL,  (unsigned int *)xmmword_10008D0E0,  0LL,  0LL,  *(void *)(xmmword_10008D0E0 + 160),  qword_10008D150,  &qword_10008C730,  v89,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  0x427u))
  {
    uint64_t result = sub_1000622D4("dhcpv6_leasequery: not allowed, query ignored.", v90, v91, v92, v93, v94, v95, v96, v149);
    goto LABEL_33;
  }

  if (!sub_100040D4C(&qword_10008C1F8, qword_10008D150, 2LL, v92, v93, v94, v95, v96))
  {
    uint64_t v100 = *((void *)&xmmword_10008D100 + 1);
    if (!*((void *)&xmmword_10008D100 + 1))
    {
      sub_100019FF0( (uint64_t)&xmmword_10008D100,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  1081LL,  0LL,  v97,  v98,  v99,  v37);
      uint64_t v100 = *((void *)&xmmword_10008D100 + 1);
    }

    if (!sub_100040F30( &qword_10008C1F8,  qword_10008D150,  0LL,  v100,  dword_10008D110,  2LL,  0LL,  v37))
    {
      uint64_t v102 = "dhcpv6_leasequery: error saving server identifier.";
      goto LABEL_57;
    }
  }

  if (!sub_100040F30( &qword_10008C1F8,  qword_10008D150,  *((uint64_t *)&xmmword_10008D0E0 + 1),  qword_10008D0F0,  dword_10008D0F8,  1LL,  0LL,  v37))
  {
    uint64_t v102 = "dhcpv6_leasequery: error saving client identifier.";
    goto LABEL_57;
  }

  dword_10008D158 = 4;
  if (DWORD2(xmmword_10008D120) > 0x11)
  {
    byte_10008D130 = *(_BYTE *)xmmword_10008D120;
    unk_10008D134 = *(_OWORD *)(xmmword_10008D120 + 1);
    if (byte_10008D130 != 1)
    {
      if (byte_10008D130 == 2) {
        uint64_t v133 = "QUERY_BY_CLIENTID not supported.";
      }
      else {
        uint64_t v133 = "Unknown query-type.";
      }
      if (!sub_100019AE8(7u, v133))
      {
        uint64_t v102 = "dhcpv6_leasequery: unable to set UnknownQueryType status code.";
        goto LABEL_57;
      }

      goto LABEL_60;
    }

    if (sub_1000347D8( &qword_10008D148,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  1146LL,  v80,  v81,  v82,  v36,  v37))
    {
      uint64_t v134 = sub_100040920( qword_10008D148,  (char *)(xmmword_10008D120 + 17),  DWORD2(xmmword_10008D120) - 17,  (uint64_t)&qword_10008C1F8);
      if ((_DWORD)v134)
      {
        uint64_t result = sub_100019BD0(v134, v135, v136, v137, v138, v139, v140, v141);
        if (!(_DWORD)result) {
          goto LABEL_33;
        }
        goto LABEL_60;
      }

      sub_10006221C("dhcpv6_leasequery: error parsing query-options.", v135, v136, v137, v138, v139, v140, v141, v149);
      uint64_t v101 = "Bad query-options.";
      goto LABEL_22;
    }

uint64_t sub_100019AE8(unsigned int a1, char *__s)
{
  uint64_t v22 = 0LL;
  uint64_t v23 = 0LL;
  uint64_t v24 = strlen(__s) + 2;
  if (!sub_1000345C4( &v22,  v24,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  837LL)) {
    sub_100061FB4("set_error: no memory for status code.", v4, v5, v6, v7, v8, v9, v10, v21);
  }
  uint64_t v23 = v22 + 1;
  sub_100060B78((_WORD *)v22 + 2, a1);
  memcpy((char *)v22 + 6, __s, v24 - 2LL);
  if (sub_100040F30( &qword_10008C1F8,  qword_10008D150,  (uint64_t)v22,  (uint64_t)v23,  v24,  13LL,  0LL,  v11))
  {
    uint64_t v19 = 1LL;
  }

  else
  {
    sub_10006221C("set_error: error saving status code.", v12, v13, v14, v15, v16, v17, v18, v21);
    uint64_t v19 = 0LL;
  }

  sub_100034EA8( &v22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  851LL,  v14,  v15,  v16,  v17,  v18);
  return v19;
}

uint64_t sub_100019BD0( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = (unsigned int *)xmmword_10008D0E0;
  uint64_t v51 = 0LL;
  uint64_t v45 = 0LL;
  int v46 = 0LL;
  uint64_t v9 = sub_100040D4C(&qword_10008C1F8, qword_10008D148, 5LL, a4, a5, a6, a7, a8);
  if (!v9)
  {
    sub_10006221C( "process_lq_by_address: unable to set MalformedQuery status code.",  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v42);
    return 0LL;
  }

  uint64_t v48 = 0LL;
  uint64_t v49 = 0LL;
  uint64_t v50 = 0LL;
  if (sub_100057AA4( &v48,  v8,  0LL,  0LL,  qword_10008D148,  0LL,  &qword_10008C730,  v9,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  0x378u)) {
    BOOL v17 = v50 > 0x17;
  }
  else {
    BOOL v17 = 0;
  }
  if (v17)
  {
    __int128 v47 = *v49;
    sub_100034EA8( &v48,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  894LL,  v12,  v13,  v14,  v15,  v16);
    if (sub_10002F750(&v51, 3LL, &v47, v27, v28, v29, v30, v31))
    {
      if (!sub_100019AE8(9u, "Address not in a pool."))
      {
        uint64_t v18 = "process_lq_by_address: unable to set NotConfigured status code.";
        goto LABEL_7;
      }
    }

    else if (sub_100029804( &v46,  v51[4],  &v47,  16LL,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  913LL))
    {
      if (v46)
      {
        if (v46[21] == 2)
        {
          uint64_t v32 = *((void *)v46 + 7);
          if (v32)
          {
            if (*(_DWORD *)(v32 + 24) >= 5u)
            {
              if (!sub_1000347D8( &v45,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  926LL,  v12,  v13,  v14,  v15,  v16))
              {
                uint64_t v18 = "process_lq_by_address: no memory for option state.";
                goto LABEL_7;
              }

              sub_100034E60( (uint64_t)&v48,  *((void *)v46 + 7) + 8LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  932LL,  v13,  v14,  v15,  v16);
              uint64_t v49 = (__int128 *)((char *)v49 + 4);
              LODWORD(v50) = v50 - 4;
              if (!sub_100040F30( &qword_10008C1F8,  v45,  0LL,  (uint64_t)v49,  v50,  1LL,  0LL,  v34))
              {
                uint64_t v18 = "process_lq_by_address: error saving client ID.";
                goto LABEL_7;
              }

              sub_100034EA8( &v48,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  941LL,  v12,  v13,  v14,  v15,  v16);
              LODWORD(v50) = 24;
              if (!sub_1000345C4( &v48,  24,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  944LL))
              {
                uint64_t v18 = "process_lq_by_address: no memory for ia-addr.";
                goto LABEL_7;
              }

              uint64_t v49 = (__int128 *)(v48 + 1);
              uint64_t v35 = v46;
              *(_OWORD *)(v48 + 1) = *(_OWORD *)(v46 + 4);
              sub_100060B6C(v48 + 5, *((_DWORD *)v35 + 12));
              unsigned int v44 = *((_DWORD *)v46 + 13);
              sub_100060B6C(v48 + 6, v44);
              if (!sub_100040F30( &qword_10008C1F8,  v45,  0LL,  (uint64_t)v49,  v50,  5LL,  0LL,  v36))
              {
                uint64_t v18 = "process_lq_by_address: error saving ia-addr.";
                goto LABEL_7;
              }

              sub_100034EA8( &v48,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  960LL,  v12,  v13,  v14,  v15,  v16);
              unsigned int v44 = bswap32(*(_DWORD *)(*((void *)v46 + 7) + 48LL));
              if (!sub_100040F30(&qword_10008C1F8, v45, 0LL, (uint64_t)&v44, 4LL, 46LL, 0LL, v37))
              {
                uint64_t v18 = "process_lq_by_address: error saving clt time.";
                goto LABEL_7;
              }

              uint64_t v38 = dword_10008D158;
              sub_100060B78(&byte_10008D15C[dword_10008D158], 0x2Du);
              int v39 = dword_10008D158;
              dword_10008D158 += 4;
              dword_10008D158 += sub_1000425E0( (uint64_t)&byte_10008D15C[dword_10008D158],  (65532 - v39),  v45,  (unsigned int *)xmmword_10008D0E0,  dword_1000825D4,  0LL,  v40,  v41);
              sub_100060B78(&byte_10008D15C[v38 + 2], dword_10008D158 - v38 - 4);
            }
          }
        }
      }
    }

    uint64_t v19 = 1LL;
    goto LABEL_20;
  }

  uint64_t v18 = "process_lq_by_address: error evaluating IAADDR.";
LABEL_7:
  sub_10006221C(v18, v10, v11, v12, v13, v14, v15, v16, v43);
  uint64_t v19 = 0LL;
LABEL_20:
  if (v49) {
    sub_100034EA8( &v48,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  992LL,  v12,  v13,  v14,  v15,  v16);
  }
  if (v51) {
    sub_10002DA28( (void **)&v51,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  994LL,  v12,  v13,  v14,  v15,  v16);
  }
  if (v46) {
    sub_10002D8B8( (void **)&v46,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  996LL,  v12,  v13,  v14,  v15,  v16);
  }
  if (v45) {
    sub_100034894( &v45,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpleasequery.c",  998LL,  v12,  v13,  v14,  v15,  v16);
  }
  return v19;
}

BOOL sub_100019FDC()
{
  return qword_10009D168 != 0;
}

double sub_100019FF0( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_100034E60(a1, (uint64_t)&unk_10009D160, a2, a3, a5, a6, a7, a8);
}

double sub_10001A004( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (qword_10009D168) {
    sub_100034EA8( &qword_10009D160,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  208LL,  a4,  a5,  a6,  a7,  a8);
  }
  return sub_100034E60( (uint64_t)&qword_10009D160,  a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  210LL,  a5,  a6,  a7,  a8);
}

uint64_t sub_10001A05C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v37 = 0LL;
  if (!sub_1000347D8( &v37,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  227LL,  a4,  a5,  a6,  a7,  a8)) {
    sub_100061FB4("No memory for server DUID.", v8, v9, v10, v11, v12, v13, v14, v35);
  }
  sub_10003E0AC(0LL, 0LL, 0LL, 0LL, 0LL, v37, &qword_10008C730, qword_10008C140, 0LL);
  uint64_t v20 = sub_100040D4C(&qword_10008C1F8, v37, 2LL, v15, v16, v17, v18, v19);
  if (v20)
  {
    memset(v36, 0, sizeof(v36));
    if (sub_100057AA4( v36,  0LL,  0LL,  0LL,  v37,  0LL,  &qword_10008C730,  v20,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  0xF1u))
    {
      sub_10001A004((uint64_t)v36, v26, v27, v21, v22, v23, v24, v25);
      sub_100034EA8( v36,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  245LL,  v28,  v29,  v30,  v31,  v32);
      uint64_t v33 = 0LL;
    }

    else
    {
      uint64_t v33 = 34LL;
    }
  }

  else
  {
    uint64_t v33 = 23LL;
  }

  sub_100034894( &v37,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  250LL,  v21,  v22,  v23,  v24,  v25);
  return v33;
}

uint64_t sub_10001A17C(uint64_t result)
{
  dword_100088B5C = result;
  return result;
}

uint64_t sub_10001A188( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((dword_100088B5C & 0xFFFFFFFD) == 1)
  {
    uint64_t v8 = qword_10008C0D0;
    if (qword_10008C0D0)
    {
      while (1)
      {
        int v9 = *(unsigned __int8 *)(v8 + 48);
        if (*(_BYTE *)(v8 + 48)) {
          break;
        }
        uint64_t v8 = *(void *)(v8 + 32);
        if (!v8) {
          return 34LL;
        }
      }

      uint64_t v40 = 0LL;
      uint64_t v41 = 0LL;
      uint64_t v42 = 0LL;
      if (dword_100088B5C == 3)
      {
        LODWORD(v42) = v9 + 3;
        if (!sub_1000345C4( &v40,  v9 + 3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  328LL)) {
          sub_100061FB4("No memory for server DUID.", v20, v21, v22, v23, v24, v25, v26, v39);
        }
        uint64_t v41 = v40 + 1;
        sub_100060B78((_WORD *)v40 + 2, 3u);
        sub_100060B78((_WORD *)v40 + 3, *(unsigned __int8 *)(v8 + 49));
        uint64_t v19 = v40 + 2;
      }

      else
      {
        if (dword_100088B5C != 1) {
          sub_100061FB4("Unsupported server DUID type %d.", a2, a3, a4, a5, a6, a7, a8, dword_100088B5C);
        }
        unsigned int v11 = time(0LL) - 946684800;
        LODWORD(v42) = *(unsigned __int8 *)(v8 + 48) + 7;
        if (!sub_1000345C4( &v40,  v42,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  315LL)) {
          sub_100061FB4("No memory for server DUID.", v12, v13, v14, v15, v16, v17, v18, v39);
        }
        uint64_t v41 = v40 + 1;
        sub_100060B78((_WORD *)v40 + 2, 1u);
        sub_100060B78((_WORD *)v40 + 3, *(unsigned __int8 *)(v8 + 49));
        sub_100060B6C(v40 + 2, v11);
        uint64_t v19 = v40 + 3;
      }

      memcpy(v19, (const void *)(v8 + 50), *(unsigned __int8 *)(v8 + 48) - 1LL);
      sub_10001A004((uint64_t)&v40, v27, v28, v29, v30, v31, v32, v33);
      sub_100034EA8( &v40,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  342LL,  v34,  v35,  v36,  v37,  v38);
      return 0LL;
    }

    else
    {
      return 34LL;
    }
  }

  else
  {
    sub_10006221C( "Invalid DUID type %d specified, only LL and LLT types supported",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  dword_100088B5C);
    return 39LL;
  }

uint64_t sub_10001A334( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 8) || *(_DWORD *)(a2 + 16)) {
    return 39LL;
  }
  uint64_t v11 = sub_100040D4C(&qword_10008C1F8, *(void *)(a1 + 160), 1LL, a4, a5, a6, a7, a8);
  if (!v11) {
    return 23LL;
  }
  if (sub_100057AA4( (void *)a2,  (unsigned int *)a1,  0LL,  0LL,  *(void *)(a1 + 160),  0LL,  &qword_10008C730,  v11,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  0x170u)) {
    return 0LL;
  }
  return 25LL;
}

uint64_t sub_10001A3DC( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)a2 = 0LL;
  *(void *)(a2 + 8) = 0LL;
  *(void *)(a2 + 16) = 0LL;
  uint64_t v81 = 0LL;
  uint64_t v82 = 0LL;
  uint64_t v80 = 0LL;
  int v10 = sub_10001A334(a1, a2, a3, a4, a5, a6, a7, a8);
  if (v10)
  {
    uint64_t v18 = qword_100089DB8[*(unsigned __int8 *)(a1 + 20)];
    __int128 v83 = *(_OWORD *)(a1 + 80);
    int v84 = *(_DWORD *)(a1 + 96);
    if (v10 == 23)
    {
      sub_100040144((int *)&v83, v11, v12, v13, v14, v15, v16, v17);
      sub_10006238C("Discarding %s from %s; client identifier missing", v19, v20, v21, v22, v23, v24, v25, v18);
    }

    else
    {
      sub_100040144((int *)&v83, v11, v12, v13, v14, v15, v16, v17);
      sub_10006221C( "Error processing %s from %s; unable to evaluate Client Identifier",
        v39,
        v40,
        v41,
        v42,
        v43,
        v44,
        v45,
        v18);
    }

    goto LABEL_7;
  }

  if (*(_DWORD *)(a1 + 228))
  {
    uint64_t v31 = qword_100089DB8[*(unsigned __int8 *)(a1 + 20)];
    __int128 v83 = *(_OWORD *)(a1 + 80);
    int v84 = *(_DWORD *)(a1 + 96);
    sub_100040144((int *)&v83, v11, v12, v13, v14, v15, v16, v17);
    sub_100050770((void *)*(unsigned int *)(a2 + 16), *(unsigned __int8 **)(a2 + 8), 0x3Cu, 0);
    sub_10006238C("Discarding %s from %s; packet sent unicast (CLIENTID %s)", v32, v33, v34, v35, v36, v37, v38, v31);
LABEL_7:
    uint64_t v46 = 0LL;
    int v47 = 1;
    goto LABEL_8;
  }

  uint64_t v49 = sub_100040D4C(&qword_10008C1F8, *(void *)(a1 + 160), 2LL, v13, v14, v15, v16, v17);
  if (v49)
  {
    int v50 = sub_100057AA4( &v80,  (unsigned int *)a1,  0LL,  0LL,  *(void *)(a1 + 160),  0LL,  &qword_10008C730,  v49,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  0x1AAu);
    uint64_t v58 = qword_100089DB8[*(unsigned __int8 *)(a1 + 20)];
    if (!v50)
    {
      sub_100050770((void *)*(unsigned int *)(a2 + 16), *(unsigned __int8 **)(a2 + 8), 0x3Cu, 0);
      __int128 v83 = *(_OWORD *)(a1 + 80);
      int v84 = *(_DWORD *)(a1 + 96);
      sub_100040144((int *)&v83, v66, v67, v68, v69, v70, v71, v72);
      sub_10006238C( "Discarding %s from %s; server identifier found (CLIENTID %s)",
        v73,
        v74,
        v75,
        v76,
        v77,
        v78,
        v79,
        v58);
      goto LABEL_7;
    }

    __int128 v83 = *(_OWORD *)(a1 + 80);
    int v84 = *(_DWORD *)(a1 + 96);
    sub_100040144((int *)&v83, v51, v52, v53, v54, v55, v56, v57);
    int v47 = 1;
    sub_100050770((void *)*(unsigned int *)(a2 + 16), *(unsigned __int8 **)(a2 + 8), 0x3Cu, 0);
    sub_100050770((void *)v82, v81, 0x3Cu, 1);
    sub_10006238C( "Discarding %s from %s; server identifier found (CLIENTID %s, SERVERID %s)",
      v59,
      v60,
      v61,
      v62,
      v63,
      v64,
      v65,
      v58);
    uint64_t v46 = 0LL;
  }

  else
  {
    int v47 = 0;
    uint64_t v46 = 1LL;
  }

LABEL_8:
  if ((_DWORD)v82) {
    sub_100034EA8( &v80,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  453LL,  v26,  v27,  v28,  v29,  v30);
  }
  if (v47 && *(_DWORD *)(a2 + 16)) {
    sub_100034EA8( (_DWORD **)a2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  457LL,  v26,  v27,  v28,  v29,  v30);
  }
  return v46;
}

    sub_10004463C(&qword_10008C1F8, *a4, 14LL, v25, v26, v27, v28, v29);
  }

  uint64_t v8 = v3 % 8;
  return !v8 || (*((char *)a1 + (v2 + ~v5) + 4) & ~(-1 << v8)) == 0;
}

  if (sub_100036D00(&v78, 0LL, (uint64_t)a2) != 123)
  {
    sub_100046D6C((uint64_t)a2, "left brace expected.", v42, v43, v44, v45, v46, v47, v77);
    sub_100046C4C(a2, 0);
    *a3 = 1;
    uint64_t v40 = a1;
    uint64_t v41 = 3224LL;
    goto LABEL_31;
  }

  if (*a3)
  {
    do
      uint64_t v52 = sub_100036D00(&v78, 0LL, (uint64_t)a2);
    while (v52 != 607 && v52 != 125);
    uint64_t v40 = a1;
    uint64_t v41 = 3235LL;
    goto LABEL_31;
  }

  if (sub_100036D00(&v78, 0LL, (uint64_t)a2) != 125)
  {
    sub_100046D6C((uint64_t)a2, "right brace expected.", v53, v54, v55, v56, v57, v58, v77);
    sub_100046C4C(a2, 0);
    *a3 = 1;
    uint64_t v40 = a1;
    uint64_t v41 = 3244LL;
    goto LABEL_31;
  }

  uint64_t v59 = sub_1000374AC(&v78, 0LL, a2);
  if (v59 == 345)
  {
    sub_100036D00(&v78, 0LL, (uint64_t)a2);
    if (!sub_10004AFE4((char *)*a1 + 32, a2, a3))
    {
      if (!*a3) {
        sub_100046D6C((uint64_t)a2, "expecting conditional.", v69, v24, v25, v26, v27, v28, v77);
      }
      uint64_t v49 = a1;
      int v50 = 3292LL;
      goto LABEL_15;
    }

    return 1LL;
  }

  if (v59 != 344)
  {
    *((void *)*a1 + 4) = 0LL;
    return 1LL;
  }

  sub_100036D00(&v78, 0LL, (uint64_t)a2);
  uint64_t v60 = sub_1000374AC(&v78, 0LL, a2);
  if (v60 == 123)
  {
    sub_100036D00(&v78, 0LL, (uint64_t)a2);
    if (*a3)
    {
      uint64_t v40 = a1;
      uint64_t v41 = 3273LL;
    }

    else
    {
      uint64_t v51 = 1LL;
      sub_100046D6C((uint64_t)a2, "right brace expected.", v71, v72, v73, v74, v75, v76, v77);
      sub_100046C4C(a2, 0);
      *a3 = 1;
      uint64_t v40 = a1;
      uint64_t v41 = 3281LL;
    }

    goto LABEL_31;
  }

  if (v60 != 341)
  {
    sub_100046D6C((uint64_t)a2, "left brace or if expected.", v61, v62, v63, v64, v65, v66, v77);
    sub_100046C4C(a2, 0);
    *a3 = 1;
    uint64_t v40 = a1;
    uint64_t v41 = 3266LL;
    goto LABEL_31;
  }

  sub_100036D00(&v78, 0LL, (uint64_t)a2);
  if (!*a3) {
    sub_100046D6C((uint64_t)a2, "expecting if statement", v67, v24, v25, v26, v27, v28, v77);
  }
  uint64_t v49 = a1;
  int v50 = 3258LL;
LABEL_15:
  sub_10003DC78( v49,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  v50,  v24,  v25,  v26,  v27,  v28);
  uint64_t v51 = 0LL;
  *a3 = 1;
  return v51;
}

    uint64_t v16 = *(unsigned __int8 *)v12;
    if (v16 != 90)
    {
      else {
        uint64_t v13 = v13;
      }
      uint64_t v16 = *(unsigned __int8 *)v12;
    }

    while (v16 == 111)
    {
LABEL_22:
      if (!v16) {
        goto LABEL_30;
      }
    }

    if (v16 == 65 || v16 == 97)
    {
      if (sub_1000374AC(&v25, 0LL, a2) == 44)
      {
        sub_100036D00(&v25, 0LL, (uint64_t)a2);
LABEL_30:
        uint64_t v13 = 0LL;
      }

      else
      {
        uint64_t v21 = *(unsigned __int8 *)v12;
        if (v21 != 65 && v12[1])
        {
          if (v21 == 97)
          {
            uint64_t v24 = ++v12;
            continue;
          }

          goto LABEL_30;
        }
      }

      return 1LL;
    }

    break;
  }

  uint64_t v23 = (_DWORD *)*a1;
  uint64_t v17 = v23;
  *a1 = 0LL;
  if (sub_10004EB38(a1, a2, &v24, v17, v13, a3, a7, a8))
  {
    if (v23) {
      sub_100054390( (uint64_t *)&v23,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  4974LL,  v18,  v19,  v20,  a7,  a8);
    }
    goto LABEL_21;
  }

  if (v24[1] == 111)
  {
    *a1 = v23;
    uint64_t v23 = 0LL;
LABEL_21:
    uint64_t v12 = v24 + 1;
    uint64_t v16 = *(unsigned __int8 *)++v24;
    goto LABEL_22;
  }

  if (v23) {
    sub_100054390( (uint64_t *)&v23,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  4967LL,  v18,  v19,  v20,  a7,  a8);
  }
  return 0LL;
}

  if (*(void *)a1)
  {
    **(_BYTE **)a1 = 0;
    free(*(void **)a1);
  }

  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  free((void *)a1);
  return 0LL;
}

uint64_t sub_10001A698( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)a2 = 0LL;
  *(void *)(a2 + 8) = 0LL;
  *(void *)(a2 + 16) = 0LL;
  *(void *)a3 = 0LL;
  *(void *)(a3 + 8) = 0LL;
  *(void *)(a3 + 16) = 0LL;
  int v11 = sub_10001A334(a1, a2, a3, a4, a5, a6, a7, a8);
  if (v11)
  {
    if (v11 == 23)
    {
      uint64_t v19 = qword_100089DB8[*(unsigned __int8 *)(a1 + 20)];
      __int128 v81 = *(_OWORD *)(a1 + 80);
      int v82 = *(_DWORD *)(a1 + 96);
      sub_100040144((int *)&v81, v12, v13, v14, v15, v16, v17, v18);
      sub_10006238C("Discarding %s from %s; client identifier missing", v20, v21, v22, v23, v24, v25, v26, v19);
    }

    else
    {
      uint64_t v56 = qword_100089DB8[*(unsigned __int8 *)(a1 + 20)];
      __int128 v81 = *(_OWORD *)(a1 + 80);
      int v82 = *(_DWORD *)(a1 + 96);
      sub_100040144((int *)&v81, v12, v13, v14, v15, v16, v17, v18);
      sub_10006221C( "Error processing %s from %s; unable to evaluate Client Identifier",
        v57,
        v58,
        v59,
        v60,
        v61,
        v62,
        v63,
        v56);
    }
  }

  else
  {
    uint64_t v32 = sub_100040D4C(&qword_10008C1F8, *(void *)(a1 + 160), 2LL, v14, v15, v16, v17, v18);
    if (v32)
    {
      if (sub_100057AA4( (void *)a3,  (unsigned int *)a1,  0LL,  0LL,  *(void *)(a1 + 160),  0LL,  &qword_10008C730,  v32,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  0x205u))
      {
        uint64_t v47 = dword_10009D170;
        if (dword_10009D170 == *(_DWORD *)(a3 + 16)
          && !memcmp((const void *)qword_10009D168, *(const void **)(a3 + 8), dword_10009D170))
        {
          return 1LL;
        }

        uint64_t v48 = qword_100089DB8[*(unsigned __int8 *)(a1 + 20)];
        __int128 v81 = *(_OWORD *)(a1 + 80);
        int v82 = *(_DWORD *)(a1 + 96);
        sub_100040144((int *)&v81, v40, v47, v42, v43, v44, v45, v46);
        sub_100050770((void *)*(unsigned int *)(a2 + 16), *(unsigned __int8 **)(a2 + 8), 0x3Cu, 0);
        sub_100050770((void *)*(unsigned int *)(a3 + 16), *(unsigned __int8 **)(a3 + 8), 0x3Cu, 1);
        sub_100050770((void *)dword_10009D170, (unsigned __int8 *)qword_10009D168, 0x3Cu, 2);
        sub_10006238C( "Discarding %s from %s; not our server identifier (CLIENTID %s, SERVERID %s, server DUID %s)",
          v49,
          v50,
          v51,
          v52,
          v53,
          v54,
          v55,
          v48);
      }

      else
      {
        uint64_t v73 = qword_100089DB8[*(unsigned __int8 *)(a1 + 20)];
        __int128 v81 = *(_OWORD *)(a1 + 80);
        int v82 = *(_DWORD *)(a1 + 96);
        sub_100040144((int *)&v81, v40, v41, v42, v43, v44, v45, v46);
        sub_100050770((void *)*(unsigned int *)(a2 + 16), *(unsigned __int8 **)(a2 + 8), 0x3Cu, 0);
        sub_10006221C( "Error processing %s from %s; unable to evaluate Server Identifier (CLIENTID %s)",
          v74,
          v75,
          v76,
          v77,
          v78,
          v79,
          v80,
          v73);
      }
    }

    else
    {
      uint64_t v64 = qword_100089DB8[*(unsigned __int8 *)(a1 + 20)];
      __int128 v81 = *(_OWORD *)(a1 + 80);
      int v82 = *(_DWORD *)(a1 + 96);
      sub_100040144((int *)&v81, v33, v34, v35, v36, v37, v38, v39);
      sub_100050770((void *)*(unsigned int *)(a2 + 16), *(unsigned __int8 **)(a2 + 8), 0x3Cu, 0);
      sub_10006238C( "Discarding %s from %s: server identifier missing (CLIENTID %s)",  v65,  v66,  v67,  v68,  v69,  v70,  v71,  v64);
    }
  }

  if (*(_DWORD *)(a3 + 16)) {
    sub_100034EA8( (_DWORD **)a3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  544LL,  v27,  v28,  v29,  v30,  v31);
  }
  if (*(_DWORD *)(a2 + 16)) {
    sub_100034EA8( (_DWORD **)a2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  547LL,  v27,  v28,  v29,  v30,  v31);
  }
  return 0LL;
}

uint64_t sub_10001A990( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)a2 = 0LL;
  *(void *)(a2 + 8) = 0LL;
  *(void *)(a2 + 16) = 0LL;
  if (sub_10001A334(a1, (uint64_t)v107, a3, a4, a5, a6, a7, a8))
  {
    __str[0] = 0;
  }

  else
  {
    uint64_t v17 = (const char *)sub_100050770((void *)v108, (unsigned __int8 *)v107[1], 0x3Cu, 0);
    snprintf(__str, 0x50uLL, " (CLIENTID %s)", v17);
    sub_100034EA8( v107,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  586LL,  v18,  v19,  v20,  v21,  v22);
  }

  if (*(_DWORD *)(a1 + 228))
  {
    uint64_t v23 = qword_100089DB8[*(unsigned __int8 *)(a1 + 20)];
    __int128 v109 = *(_OWORD *)(a1 + 80);
    int v110 = *(_DWORD *)(a1 + 96);
    sub_100040144((int *)&v109, v10, v11, v12, v13, v14, v15, v16);
    sub_10006238C("Discarding %s from %s; packet sent unicast%s", v24, v25, v26, v27, v28, v29, v30, v23);
  }

  else if (sub_100040D4C(&qword_10008C1F8, *(void *)(a1 + 160), 3LL, v12, v13, v14, v15, v16))
  {
    uint64_t v43 = qword_100089DB8[*(unsigned __int8 *)(a1 + 20)];
    __int128 v109 = *(_OWORD *)(a1 + 80);
    int v110 = *(_DWORD *)(a1 + 96);
    sub_100040144((int *)&v109, v36, v37, v38, v39, v40, v41, v42);
    sub_10006238C("Discarding %s from %s; IA_NA option present%s", v44, v45, v46, v47, v48, v49, v50, v43);
  }

  else if (sub_100040D4C(&qword_10008C1F8, *(void *)(a1 + 160), 4LL, v38, v39, v40, v41, v42))
  {
    uint64_t v58 = qword_100089DB8[*(unsigned __int8 *)(a1 + 20)];
    __int128 v109 = *(_OWORD *)(a1 + 80);
    int v110 = *(_DWORD *)(a1 + 96);
    sub_100040144((int *)&v109, v51, v52, v53, v54, v55, v56, v57);
    sub_10006238C("Discarding %s from %s; IA_TA option present%s", v59, v60, v61, v62, v63, v64, v65, v58);
  }

  else if (sub_100040D4C(&qword_10008C1F8, *(void *)(a1 + 160), 25LL, v53, v54, v55, v56, v57))
  {
    uint64_t v73 = qword_100089DB8[*(unsigned __int8 *)(a1 + 20)];
    __int128 v109 = *(_OWORD *)(a1 + 80);
    int v110 = *(_DWORD *)(a1 + 96);
    sub_100040144((int *)&v109, v66, v67, v68, v69, v70, v71, v72);
    sub_10006238C("Discarding %s from %s; IA_PD option present%s", v74, v75, v76, v77, v78, v79, v80, v73);
  }

  else
  {
    uint64_t v82 = sub_100040D4C(&qword_10008C1F8, *(void *)(a1 + 160), 2LL, v68, v69, v70, v71, v72);
    if (!v82) {
      return 1LL;
    }
    if (!sub_100057AA4( (void *)a2,  (unsigned int *)a1,  0LL,  0LL,  *(void *)(a1 + 160),  0LL,  &qword_10008C730,  v82,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  0x276u))
    {
      uint64_t v99 = qword_100089DB8[*(unsigned __int8 *)(a1 + 20)];
      __int128 v109 = *(_OWORD *)(a1 + 80);
      int v110 = *(_DWORD *)(a1 + 96);
      sub_100040144((int *)&v109, v83, v84, v85, v86, v87, v88, v89);
      sub_10006221C( "Error processing %s from %s; unable to evaluate Server Identifier%s",
        v100,
        v101,
        v102,
        v103,
        v104,
        v105,
        v106,
        v99);
      goto LABEL_12;
    }

    uint64_t v90 = dword_10009D170;
    if (dword_10009D170 == *(_DWORD *)(a2 + 16)
      && !memcmp((const void *)qword_10009D168, *(const void **)(a2 + 8), dword_10009D170))
    {
      return 1LL;
    }

    uint64_t v91 = qword_100089DB8[*(unsigned __int8 *)(a1 + 20)];
    __int128 v109 = *(_OWORD *)(a1 + 80);
    int v110 = *(_DWORD *)(a1 + 96);
    sub_100040144((int *)&v109, v83, v90, v85, v86, v87, v88, v89);
    sub_100050770((void *)*(unsigned int *)(a2 + 16), *(unsigned __int8 **)(a2 + 8), 0x3Cu, 0);
    sub_100050770((void *)dword_10009D170, (unsigned __int8 *)qword_10009D168, 0x3Cu, 1);
    sub_10006238C( "Discarding %s from %s; not our server identifier (SERVERID %s, server DUID %s)%s",
      v92,
      v93,
      v94,
      v95,
      v96,
      v97,
      v98,
      v91);
  }

_DWORD **sub_10001AD00( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v80 = 0LL;
  uint64_t v81 = 0LL;
  uint64_t v79 = 0LL;
  unsigned __int8 v9 = *(_BYTE *)(a1 + 20);
  if (v9 >= 0x10u)
  {
    *(_OWORD *)uint64_t v84 = *(_OWORD *)(a1 + 80);
    *(_DWORD *)&v84[16] = *(_DWORD *)(a1 + 96);
    sub_100040144((int *)v84, a2, a3, a4, a5, a6, a7, a8);
    sub_100053FE4((uint64_t)&v79, "Unknown message type %d from %s port %d", v23, v24, v25, v26, v27, v28, v9);
  }

  else
  {
    uint64_t v10 = qword_100089DB8[*(unsigned __int8 *)(a1 + 20)];
    *(_OWORD *)uint64_t v84 = *(_OWORD *)(a1 + 80);
    *(_DWORD *)&v84[16] = *(_DWORD *)(a1 + 96);
    sub_100040144((int *)v84, a2, a3, a4, a5, a6, a7, a8);
    sub_100053FE4((uint64_t)&v79, "%s message from %s port %d", v11, v12, v13, v14, v15, v16, v10);
  }

  if ((*(_BYTE *)(a1 + 20) & 0xFE) == 0xC)
  {
    char v29 = inet_ntop(30, (const void *)(a1 + 28), v84, 0x2Eu);
    sub_100053FE4((uint64_t)&v79, ", link address %s", v30, v31, v32, v33, v34, v35, v29);
    char v78 = inet_ntop(30, (const void *)(a1 + 44), v84, 0x2Eu);
    sub_100053FE4((uint64_t)&v79, ", peer address %s", v36, v37, v38, v39, v40, v41, v78);
  }

  else
  {
    sub_100053FE4((uint64_t)&v79, ", transaction ID 0x%06X", v17, v18, v19, v20, v21, v22, 0);
  }

  sub_1000622D4("%s", v42, v43, v44, v45, v46, v47, v48, (char)v80);
  sub_100034EA8( &v79,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5833LL,  v49,  v50,  v51,  v52,  v53);
  uint64_t result = (_DWORD **)sub_10001AF58();
  if (v80)
  {
    *(void *)&v84[8] = 0LL;
    *(void *)&v84[16] = 0LL;
    *(void *)uint64_t v84 = 7680LL;
    int v85 = 0;
    *(_WORD *)&v84[2] = *(_WORD *)(a1 + 76);
    *(_OWORD *)&v84[8] = *(_OWORD *)(a1 + 84);
    uint64_t v62 = qword_100089DB8[*v80];
    __int128 v82 = *(_OWORD *)(a1 + 80);
    int v83 = *(_DWORD *)(a1 + 96);
    sub_100040144((int *)&v82, v55, v56, v57, v58, v59, v60, v61);
    sub_1000622D4("Sending %s to %s port %d", v63, v64, v65, v66, v67, v68, v69, v62);
    int v70 = sub_100052890(*(void *)(a1 + 104), (uint64_t)v80, v81, v84);
    if ((_DWORD)v81 != v70) {
      sub_10006221C("dhcpv6: send_packet6() sent %d of %d bytes", v71, v72, v73, v74, v75, v76, v77, v70);
    }
    return sub_100034EA8( &v79,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5880LL,  v73,  v74,  v75,  v76,  v77);
  }

  return result;
}

uint64_t sub_10001AF58()
{
  unsigned int v0 = (void *)__chkstk_darwin();
  uint64_t v8 = v1;
  *unsigned int v0 = 0LL;
  v0[1] = 0LL;
  v0[2] = 0LL;
  char v9 = *(_BYTE *)(v1 + 20);
  uint64_t v10 = (uint64_t)v0;
  switch(v9)
  {
    case 1:
      uint64_t result = sub_10001A3DC(v1, (uint64_t)__src, v2, v3, v4, v5, v6, v7);
      if ((_DWORD)result)
      {
        sub_10001C3B4(v10, v8, (uint64_t)__src, 0LL, v12, v13, v14, v15);
        uint64_t v21 = __src;
        uint64_t v22 = 4111LL;
        return (uint64_t)sub_100034EA8( (_DWORD **)v21,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  v22,  v16,  v17,  v18,  v19,  v20);
      }

      return result;
    case 2:
      char v48 = (char)off_100089DC8[0];
      goto LABEL_60;
    case 3:
      uint64_t result = sub_10001A698(v1, (uint64_t)__src, (uint64_t)&v392, v3, v4, v5, v6, v7);
      if (!(_DWORD)result) {
        return result;
      }
      sub_10001C3B4(v10, v8, (uint64_t)__src, &v392, v30, v31, v32, v33);
      sub_100034EA8( (_DWORD **)__src,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4141LL,  v34,  v35,  v36,  v37,  v38);
      uint64_t v21 = (char *)&v392;
      uint64_t v22 = 4142LL;
      return (uint64_t)sub_100034EA8( (_DWORD **)v21,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  v22,  v16,  v17,  v18,  v19,  v20);
    case 4:
      uint64_t v380 = 0LL;
      uint64_t v381 = 0LL;
      uint64_t v379 = 0LL;
      uint64_t result = sub_10001A3DC(v1, (uint64_t)&v379, v2, v3, v4, v5, v6, v7);
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v70 = sub_100040D4C(&qword_10008C1F8, *(void *)(v8 + 160), 3LL, v65, v66, v67, v68, v69);
      uint64_t result = sub_100040D4C(&qword_10008C1F8, *(void *)(v8 + 160), 4LL, v71, v72, v73, v74, v75);
      uint64_t v367 = result;
      if (!(v70 | result)) {
        return result;
      }
      sub_10004463C(&qword_10008C1F8, *(void *)(v8 + 160), 25LL, v76, v77, v78, v79, v80);
      uint64_t v373 = 0LL;
      uint64_t v374 = 0LL;
      uint64_t v393 = 0LL;
      uint64_t v394 = 0LL;
      uint64_t v392 = 0LL;
      uint64_t v383 = 0LL;
      uint64_t v384 = 0LL;
      uint64_t v382 = 0LL;
      uint64_t v377 = 0LL;
      uint64_t v378 = 0LL;
      uint64_t v375 = 0LL;
      uint64_t v376 = 0LL;
      uint64_t result = sub_10001F36C(&v375, v8, v81, v82, v83, v84, v85, v86);
      if ((_DWORD)result || !v375 || !*(void *)(v375 + 56)) {
        goto LABEL_201;
      }
      int v365 = 0;
      int v92 = 3;
      do
      {
        if (v92 == 3 && v70 == 0) {
          uint64_t v93 = v367;
        }
        else {
          uint64_t v93 = v70;
        }
        if (v92 == 3 && v70 == 0) {
          int v92 = 4;
        }
        if (!v93) {
          break;
        }
        if (v92 == 4) {
          unsigned int v94 = 4;
        }
        else {
          unsigned int v94 = 12;
        }
        uint64_t result = sub_10001FA3C(&v374, &v392, v8, v93, v94);
        if (!(_DWORD)result) {
          goto LABEL_201;
        }
        uint64_t v95 = sub_100040D4C(&qword_10008C1F8, v374, 5LL, v87, v88, v89, v90, v91);
        if (v95)
        {
          uint64_t v101 = v95;
          while (1)
          {
            if (sub_100057AA4( &v382,  (unsigned int *)v8,  0LL,  0LL,  *(void *)(v8 + 160),  0LL,  &qword_10008C730,  v101,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  0x10EDu)) {
              BOOL v109 = v384 > 0x17;
            }
            else {
              BOOL v109 = 0;
            }
            if (!v109)
            {
              uint64_t result = sub_10006221C( "dhcpv6_confirm: error evaluating IAADDR.",  v102,  v103,  v104,  v105,  v106,  v107,  v108,  v362);
              goto LABEL_201;
            }

            *(_OWORD *)uint64_t v385 = *(_OWORD *)v383;
            sub_100034EA8( &v382,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4344LL,  v104,  v105,  v106,  v107,  v108);
            uint64_t v111 = *(void *)(v375 + 56);
            BOOL v112 = v111 != 0;
            if (!v111) {
              break;
            }
            while (1)
            {
              *(_DWORD *)__src = 16;
              *(_OWORD *)&__src[4] = *(_OWORD *)v385;
              __int128 v386 = *(_OWORD *)(v111 + 104);
              unsigned int v387 = *(_DWORD *)(v111 + 120);
              sub_10003F7A4(__src, &v386, v110, v96, v97, v98, v99, v100, (unint64_t)&v389);
              *(_OWORD *)__src = *(_OWORD *)(v111 + 84);
              *(_DWORD *)&__src[16] = *(_DWORD *)(v111 + 100);
              uint64_t v111 = *(void *)(v111 + 40);
              if (!v111) {
                goto LABEL_49;
              }
            }

            uint64_t v101 = *(void *)(v101 + 8);
            if (!v101) {
              goto LABEL_50;
            }
          }

LABEL_49:
          BOOL v112 = 0;
LABEL_50:
          int v365 = 1;
        }

        else
        {
          BOOL v112 = 1;
        }

        sub_100034894( &v374,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4371LL,  v96,  v97,  v98,  v99,  v100);
        uint64_t result = (uint64_t)sub_100034EA8( &v392,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4372LL,  v119,  v120,  v121,  v122,  v123);
        uint64_t v70 = *(void *)(v93 + 8);
      }

      while (v112);
      if (v365)
      {
        uint64_t result = sub_10001F50C(v8, (uint64_t)&v379, 0LL, &v373, (uint64_t)__src, v89, v90, v91);
        if ((_DWORD)result)
        {
          if (v93)
          {
            uint64_t v124 = "Some of the addresses are not on link.";
            unsigned int v125 = 4;
          }

          else
          {
            uint64_t v124 = "All addresses still on link.";
            unsigned int v125 = 0;
          }

          uint64_t result = sub_10001F94C(v125, v124, v373);
          if ((_DWORD)result)
          {
            int v353 = sub_1000425E0( (uint64_t)&__src[4],  65532LL,  v373,  (unsigned int *)v8,  dword_100082664,  (uint64_t)&v376,  v90,  v91)
                 + 4;
            *(_DWORD *)(v10 + 16) = v353;
            *(void *)uint64_t v10 = 0LL;
            if (!sub_1000345C4( (void *)v10,  v353,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4419LL)) {
              sub_100061FB4("No memory to store reply.", v354, v355, v356, v357, v358, v359, v360, v362);
            }
            uint64_t v361 = (void *)(*(void *)v10 + 4LL);
            *(void *)(v10 + 8) = v361;
            uint64_t result = (uint64_t)memcpy(v361, __src, v353);
          }
        }
      }

        uint64_t v30 = qword_10009D178;
        uint64_t v31 = *(uint64_t **)(qword_10009D178 + 80);
        if (v31)
        {
          uint64_t v32 = *v31;
          if (*v31)
          {
            uint64_t v33 = dword_10009D228;
            uint64_t v34 = 1LL;
            uint64_t v35 = *v31;
            do
            {
              if (*(_WORD *)(v35 + 4) == 25)
              {
                uint64_t v38 = 1LL;
                while (1)
                {
                  if (*(_WORD *)(v32 + 4) == 25 && (v33 < 0 || *(_DWORD *)(v32 + 28) == v33))
                  {
                    if (!sub_10002ED80( v32,  &qword_10009D200,  &v56,  (uint64_t)&unk_10009D1A0,  xmmword_10008CE80 + 120,  a6,  a7,  a8))
                    {
                      uint64_t v46 = inet_ntop(30, (const void *)(qword_10009D200 + 4), v57, 0x2Eu);
                      sub_10006238C("Picking pool prefix %s/%u", v47, v48, v49, v50, v51, v52, v53, v46);
LABEL_73:
                      if (!qword_10009D200) {
                        sub_100061FB4( "Impossible condition at %s:%d.",  v22,  v23,  v24,  v25,  v26,  v27,  v28,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c");
                      }
                      uint64_t v37 = (uint64_t *)(qword_10009D200 + 24);
                      *(_DWORD *)uint64_t v57 = 16;
                      *(_OWORD *)&v57[4] = *(_OWORD *)(qword_10009D200 + 4);
                      *(_DWORD *)&v57[20] = *(unsigned __int8 *)(qword_10009D200 + 20);
LABEL_57:
                      uint64_t result = sub_10002051C(v37, *(void **)(qword_10009D178 + 96));
                      if (!(_DWORD)result) {
                        return sub_10002089C((uint64_t)v57);
                      }
                      return result;
                    }

                    uint64_t v31 = *(uint64_t **)(v30 + 80);
                  }

                  uint64_t v32 = v31[v38++];
                  if (!v32)
                  {
                    uint64_t v36 = "Unable to pick client prefix: no prefixes available";
                    goto LABEL_68;
                  }
                }
              }

              uint64_t v35 = v31[v34++];
            }

            while (v35);
          }

          uint64_t v36 = "Unable to pick client prefix: no IPv6 prefix pools on this shared network";
        }

        else
        {
          uint64_t v36 = "Unable to pick client prefix: no IPv6 pools on this shared network";
        }

LABEL_201:
      if (v392) {
        uint64_t result = (uint64_t)sub_100034EA8( &v392,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4428LL,  v87,  v88,  v89,  v90,  v91);
      }
      if (v382) {
        uint64_t result = (uint64_t)sub_100034EA8( &v382,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4430LL,  v87,  v88,  v89,  v90,  v91);
      }
      if (v379) {
        uint64_t result = (uint64_t)sub_100034EA8( &v379,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4432LL,  v87,  v88,  v89,  v90,  v91);
      }
      if (v376) {
        uint64_t result = (uint64_t)sub_100034EA8( &v376,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4434LL,  v87,  v88,  v89,  v90,  v91);
      }
      if (v374) {
        uint64_t result = sub_100034894( &v374,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4438LL,  v87,  v88,  v89,  v90,  v91);
      }
      if (v373) {
        return sub_100034894( &v373,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4440LL,  v87,  v88,  v89,  v90,  v91);
      }
      return result;
    case 5:
      uint64_t result = sub_10001A698(v1, (uint64_t)__src, (uint64_t)&v392, v3, v4, v5, v6, v7);
      if (!(_DWORD)result) {
        return result;
      }
      sub_10001C3B4(v10, v8, (uint64_t)__src, &v392, v39, v40, v41, v42);
      sub_100034EA8( &v392,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4471LL,  v43,  v44,  v45,  v46,  v47);
      uint64_t v21 = __src;
      uint64_t v22 = 4472LL;
      return (uint64_t)sub_100034EA8( (_DWORD **)v21,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  v22,  v16,  v17,  v18,  v19,  v20);
    case 6:
      uint64_t result = sub_10001A3DC(v1, (uint64_t)__src, v2, v3, v4, v5, v6, v7);
      if (!(_DWORD)result) {
        return result;
      }
      sub_10001C3B4(v10, v8, (uint64_t)__src, 0LL, v126, v127, v128, v129);
      uint64_t v21 = __src;
      uint64_t v22 = 4492LL;
      return (uint64_t)sub_100034EA8( (_DWORD **)v21,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  v22,  v16,  v17,  v18,  v19,  v20);
    case 7:
      char v48 = (char)off_100089DF0[0];
      goto LABEL_60;
    case 8:
      uint64_t result = sub_10001A698(v1, (uint64_t)&v386, (uint64_t)v385, v3, v4, v5, v6, v7);
      if (!(_DWORD)result) {
        return result;
      }
      sub_1000209A8();
      uint64_t v383 = 0LL;
      uint64_t v384 = 0LL;
      uint64_t v381 = 0LL;
      uint64_t v382 = 0LL;
      uint64_t v379 = 0LL;
      uint64_t v380 = 0LL;
      uint64_t v372 = 0LL;
      uint64_t v373 = 0LL;
      uint64_t v377 = 0LL;
      uint64_t v378 = 0LL;
      uint64_t v376 = 0LL;
      unint64_t v370 = 0LL;
      int v368 = *(_DWORD *)(v10 + 16);
      if (!sub_100029E98( &v373,  *((const char **)&v386 + 1),  v387,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5152LL,  v137,  v138,  v139))
      {
        uint64_t v373 = 0LL;
        if (!sub_100029EB4( &v373,  (unsigned int *)v8,  *(void *)(v8 + 160),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5161LL,  v142,  v143,  v144)) {
          uint64_t v373 = 0LL;
        }
      }

      uint64_t v374 = 0LL;
      if (!sub_1000347D8( &v374,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5170LL,  v140,  v141,  v142,  v143,  v144))
      {
        uint64_t v293 = "iterate_over_ia_pd: no memory for option_state.";
LABEL_138:
        sub_10006221C(v293, v145, v146, v147, v148, v149, v150, v151, v362);
        goto LABEL_144;
      }

      sub_10003E0AC(0LL, (int *)v8, 0LL, 0LL, *(void *)(v8 + 160), v374, &qword_10008C730, qword_10008C140, 0LL);
      uint64_t v157 = sub_100040D4C(&qword_10008C1F8, *(void *)(v8 + 160), 25LL, v152, v153, v154, v155, v156);
      if (v157)
      {
        uint64_t v158 = v157;
        int v159 = 0;
        while (1)
        {
          uint64_t v366 = v158;
          int v165 = sub_100060B50(v380);
          uint64_t v171 = sub_100040D4C(&qword_10008C1F8, v372, 26LL, v166, v167, v168, v169, v170);
          if (v171) {
            break;
          }
          uint64_t v243 = 5199LL;
          uint64_t v244 = 5198LL;
LABEL_120:
          sub_100034894( &v372,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  v244,  v172,  v173,  v174,  v175,  v176);
          sub_100034EA8( &v379,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  v243,  v245,  v246,  v247,  v248,  v249);
          uint64_t v158 = *(void *)(v366 + 8);
          if (!v158) {
            goto LABEL_141;
          }
        }

        uint64_t v177 = v171;
        while (1)
        {
          uint64_t v376 = 0LL;
          uint64_t v377 = 0LL;
          uint64_t v378 = 0LL;
          if (!sub_100057AA4( &v376,  (unsigned int *)v8,  0LL,  0LL,  *(void *)(v8 + 160),  0LL,  &qword_10008C730,  v177,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  0x1457u))
          {
            uint64_t v293 = "iterate_over_ia_pd: error evaluating IAPREFIX.";
            goto LABEL_138;
          }

          uint64_t v371 = 0LL;
          if (sub_100029EB4( &v371,  (unsigned int *)v8,  v372,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5222LL,  v149,  v150,  v151))
          {
            uint64_t v178 = v371;
            if (v371) {
              goto LABEL_77;
            }
          }

          else
          {
            uint64_t v178 = v373;
            if (!v373)
            {
              uint64_t v371 = 0LL;
LABEL_89:
              if (v378 >= 0x19)
              {
                if (sub_10002DB34( &v389,  v165,  *((const void **)&v386 + 1),  v387,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5256LL)) {
                  sub_100061FB4( "iterate_over_ia_pd: no memory for key.",  v182,  v183,  v184,  v185,  v186,  v187,  v188,  v362);
                }
                uint64_t v369 = 0LL;
                if (sub_100029804( &v369,  qword_10008BE68,  v390,  v391,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5264LL)
                  && *(int *)(v369 + 36) >= 1)
                {
                  uint64_t v194 = 0LL;
                  while (1)
                  {
                    unsigned __int8 v195 = sub_100060BA0((unsigned __int8 *)(v377 + 8));
                    uint64_t v196 = *(void *)(*(void *)(v369 + 56) + 8 * v194);
                    if (*(unsigned __int8 *)(v196 + 20) == v195
                      && *(void *)(v196 + 4) == *(void *)(v377 + 9)
                      && *(void *)(v196 + 12) == *(void *)(v377 + 17))
                    {
                      break;
                    }
                  }

                  sub_10002D850( &v370,  (_DWORD *)v196,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5281LL,  v190,  v191,  v192,  v193);
                }

LABEL_104:
                sub_100034EA8( &v389,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5287LL,  v189,  v190,  v191,  v192,  v193);
                uint64_t v178 = v371;
              }

              goto LABEL_105;
            }

            uint64_t v371 = v373;
LABEL_77:
            do
            {
              if (*(void *)(v178 + 144))
              {
                int v179 = sub_100060BA0((unsigned __int8 *)(v377 + 8));
                uint64_t v178 = v371;
                uint64_t v180 = *(uint64_t **)(v371 + 144);
                if (v180)
                {
                  while (v179 != *((_DWORD *)v180 + 7)
                       || *(void *)(v377 + 9) != *(uint64_t *)((char *)v180 + 12)
                       || *(void *)(v377 + 17) != *(uint64_t *)((char *)v180 + 20))
                  {
                    uint64_t v180 = (uint64_t *)*v180;
                    if (!v180) {
                      goto LABEL_87;
                    }
                  }
                }
              }

LABEL_87:
              uint64_t v178 = *(void *)(v178 + 32);
              uint64_t v371 = v178;
            }

            while (v178);
          }

          if (!v178) {
            goto LABEL_89;
          }
LABEL_105:
          char v198 = (void *)v370;
          if (v178 | v370)
          {
            char v199 = sub_100050770((void *)v387, *((unsigned __int8 **)&v386 + 1), 0x3Cu, 0);
            inet_ntop(30, (const void *)(v377 + 9), (char *)&v392, 0x2Eu);
            sub_100060BA0((unsigned __int8 *)(v377 + 8));
            sub_1000622D4("Client %s releases prefix %s/%u", v200, v201, v202, v203, v204, v205, v206, v199);
            if (v198)
            {
              sub_10002ED64(v198[8], (uint64_t)v198);
              uint64_t v212 = v198[7];
              *(void *)(v212 + 48) = xmmword_10008CE80;
              sub_10000D7B4(v212);
            }
          }

          else
          {
            uint64_t v213 = v380;
            char v214 = sub_100050770((void *)v387, *((unsigned __int8 **)&v386 + 1), 0x3Cu, 0);
            inet_ntop(30, (const void *)(v377 + 9), (char *)&v392, 0x2Eu);
            sub_100060BA0((unsigned __int8 *)(v377 + 8));
            sub_1000622D4( "Client %s releases prefix %s/%u, which is not leased to it.",  v215,  v216,  v217,  v218,  v219,  v220,  v221,  v214);
            uint64_t v375 = 0LL;
            if (sub_1000347D8( &v375,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5047LL,  v222,  v223,  v224,  v225,  v226))
            {
              if (sub_10001F94C(3u, "Release for non-leased prefix.", v375))
              {
                if (v159 + 16 <= 0x10000 - (v159 + v368))
                {
                  uint64_t v241 = &__src[v159];
                  int v242 = sub_1000425E0( (uint64_t)(v241 + 16),  (65520 - (v159 + v159 + v368)),  v375,  (unsigned int *)v8,  (unsigned int *)&unk_100082678,  0LL,  v239,  v240);
                  sub_100060B78(v241, 0x19u);
                  sub_100060B78((_WORD *)v241 + 1, v242 + 12);
                  *((_DWORD *)v241 + 1) = *v213;
                  sub_100060B6C((_DWORD *)v241 + 2, 0);
                  sub_100060B6C((_DWORD *)v241 + 3, 0);
                  v159 += v242 + 16;
                }

                else
                {
                  sub_10006221C( "ia_pd_nomatch_release: out of space for reply packet.",  v234,  v235,  v236,  v237,  v238,  v239,  v240,  v364);
                }
              }
            }

            else
            {
              sub_10006221C( "ia_pd_nomatch_release: out of memory allocating option_state.",  v227,  v228,  v229,  v230,  v231,  v232,  v233,  v364);
            }

            sub_100034894( &v375,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5097LL,  v236,  v237,  v238,  v239,  v240);
          }

          if (v370) {
            sub_10002D8B8( (void **)&v370,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5300LL,  v207,  v208,  v209,  v210,  v211);
          }
          sub_100034EA8( &v376,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5303LL,  v207,  v208,  v209,  v210,  v211);
          uint64_t v177 = *(void *)(v177 + 8);
          if (!v177)
          {
            uint64_t v243 = 5307LL;
            uint64_t v244 = 5306LL;
            goto LABEL_120;
          }
        }
      }

      int v159 = 0;
LABEL_141:
      LODWORD(v384) = *(_DWORD *)(v10 + 16) + v159;
      if (!sub_1000345C4( &v382,  v384,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5315LL)) {
        sub_100061FB4("No memory to store reply.", v294, v295, v296, v297, v298, v299, v300, v364);
      }
      uint64_t v383 = v382 + 1;
      memcpy(v382 + 1, (const void *)(*(void *)v10 + 4LL), *(unsigned int *)(v10 + 16));
      memcpy((char *)v382 + *(unsigned int *)(v10 + 16) + 4, __src, v159);
      sub_100034EA8( (_DWORD **)v10,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5323LL,  v301,  v302,  v303,  v304,  v305);
      sub_100034E60( v10,  (uint64_t)&v382,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5324LL,  v306,  v307,  v308,  v309);
      sub_100034EA8( &v382,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5325LL,  v310,  v311,  v312,  v313,  v314);
LABEL_144:
      if (v370) {
        sub_10002D8B8( (void **)&v370,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5329LL,  v160,  v161,  v162,  v163,  v164);
      }
      if (v376) {
        sub_100034EA8( &v376,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5335LL,  v160,  v161,  v162,  v163,  v164);
      }
      if (v372) {
        sub_100034894( &v372,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5338LL,  v160,  v161,  v162,  v163,  v164);
      }
      if (v379) {
        sub_100034EA8( &v379,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5341LL,  v160,  v161,  v162,  v163,  v164);
      }
      if (v374) {
        sub_100034894( &v374,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5344LL,  v160,  v161,  v162,  v163,  v164);
      }
      sub_100034EA8( (_DWORD **)v385,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5377LL,  v160,  v161,  v162,  v163,  v164);
      uint64_t v21 = (char *)&v386;
      uint64_t v22 = 5378LL;
      return (uint64_t)sub_100034EA8( (_DWORD **)v21,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  v22,  v16,  v17,  v18,  v19,  v20);
    case 9:
      uint64_t result = sub_10001A698(v1, (uint64_t)__src, (uint64_t)&v392, v3, v4, v5, v6, v7);
      if (!(_DWORD)result) {
        return result;
      }
      sub_10004463C(&qword_10008C1F8, *(void *)(v8 + 160), 25LL, v250, v251, v252, v253, v254);
      sub_1000209A8();
      sub_100034EA8( &v392,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4910LL,  v255,  v256,  v257,  v258,  v259);
      uint64_t v21 = __src;
      uint64_t v22 = 4911LL;
      return (uint64_t)sub_100034EA8( (_DWORD **)v21,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  v22,  v16,  v17,  v18,  v19,  v20);
    case 10:
      char v48 = (char)off_100089E08[0];
      goto LABEL_60;
    case 11:
      uint64_t result = sub_10001A990(v1, (uint64_t)&v392, v2, v3, v4, v5, v6, v7);
      if (!(_DWORD)result) {
        return result;
      }
      memset(__src, 0, 24);
      if (sub_10001A334(v8, (uint64_t)__src, v260, v261, v262, v263, v264, v265)) {
        sub_100034EA8( (_DWORD **)__src,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5403LL,  v266,  v267,  v268,  v269,  v270);
      }
      if (v393) {
        uint64_t v271 = &v392;
      }
      else {
        uint64_t v271 = 0LL;
      }
      sub_10001C3B4(v10, v8, (uint64_t)__src, v271, v267, v268, v269, v270);
      if (*(void *)&__src[8]) {
        sub_100034EA8( (_DWORD **)__src,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5419LL,  v16,  v17,  v18,  v19,  v20);
      }
      uint64_t v21 = (char *)&v392;
      uint64_t v22 = 5421LL;
      return (uint64_t)sub_100034EA8( (_DWORD **)v21,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  v22,  v16,  v17,  v18,  v19,  v20);
    case 12:
      uint64_t v375 = 0LL;
      uint64_t v376 = 0LL;
      uint64_t v377 = 0LL;
      uint64_t v378 = 0LL;
      uint64_t v390 = 0LL;
      uint64_t v391 = 0LL;
      uint64_t v389 = 0LL;
      uint64_t v380 = 0LL;
      uint64_t v381 = 0LL;
      uint64_t v379 = 0LL;
      uint64_t v383 = 0LL;
      uint64_t v384 = 0LL;
      uint64_t v382 = 0LL;
      v385[0] = 0LL;
      uint64_t v49 = sub_100040D4C(&qword_10008C1F8, *(void *)(v1 + 160), 9LL, v3, v4, v5, v6, v7);
      if (!v49)
      {
        inet_ntop(30, (const void *)(v8 + 28), __src, 0x2Eu);
        inet_ntop(30, (const void *)(v8 + 44), (char *)&v392, 0x2Eu);
        __int128 v386 = *(_OWORD *)(v8 + 80);
        unsigned int v387 = *(_DWORD *)(v8 + 96);
        char v279 = sub_100040144((int *)&v386, v272, v273, v274, v275, v276, v277, v278);
        uint64_t result = sub_1000622D4( "Relay-forward from %s with link address=%s and peer address=%s missing Relay Message option.",  v280,  v281,  v282,  v283,  v284,  v285,  v286,  v279);
        goto LABEL_160;
      }

      if (!sub_100057AA4( &v382,  0LL,  0LL,  0LL,  0LL,  0LL,  &qword_10008C730,  v49,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  0x1564u))
      {
        uint64_t v292 = "dhcpv6_forw_relay: error evaluating relayed message.";
        goto LABEL_159;
      }

      if (!sub_10004616C(v383, v384))
      {
        uint64_t v292 = "dhcpv6_forw_relay: encapsulated packet too short.";
        goto LABEL_159;
      }

      v385[0] = 0LL;
      if (!sub_1000349E8( v385,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5491LL,  v52,  v53,  v54,  v55,  v56))
      {
        uint64_t v292 = "dhcpv6_forw_relay: no memory for encapsulated packet.";
        goto LABEL_159;
      }

      if (!sub_1000347D8( (uint64_t *)(v385[0] + 160),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5497LL,  v52,  v53,  v54,  v55,  v56))
      {
        uint64_t v292 = "dhcpv6_forw_relay: no memory for encapsulated packet's options.";
        goto LABEL_159;
      }

      uint64_t v57 = v385[0];
      *(_DWORD *)(v385[0] + 76) = *(_DWORD *)(v8 + 76);
      __int128 v58 = *(_OWORD *)(v8 + 80);
      *(_DWORD *)(v57 + 96) = *(_DWORD *)(v8 + 96);
      *(_OWORD *)(v57 + 80) = v58;
      sub_1000235CC( v57 + 104,  *(void *)(v8 + 104),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5505LL);
      uint64_t v59 = v385[0];
      *(void *)(v385[0] + 64) = v8;
      uint64_t v60 = v383;
      int v61 = *v383 & 0xFE;
      *(_BYTE *)(v59 + 20) = *v383;
      if (v61 == 12)
      {
        *(_BYTE *)(v59 + 24) = v60[1];
        *(_OWORD *)(v59 + 28) = *(_OWORD *)(v60 + 2);
        *(_OWORD *)(v59 + 44) = *(_OWORD *)(v60 + 18);
        uint64_t v62 = *(void *)(v59 + 160);
        uint64_t v63 = v60 + 34;
        unsigned int v64 = v384 - 34;
      }

      else
      {
        __int16 v315 = *(_WORD *)(v60 + 1);
        *(_BYTE *)(v59 + 23) = v60[3];
        *(_WORD *)(v59 + 21) = v315;
        uint64_t v62 = *(void *)(v59 + 160);
        uint64_t v63 = v60 + 4;
        unsigned int v64 = v384 - 4;
      }

      uint64_t result = sub_100040920(v62, v63, v64, (uint64_t)&qword_10008C1F8);
      if ((_DWORD)result)
      {
        uint64_t result = sub_10001AF58(&v379, v385[0]);
        if (v380)
        {
          byte_1000AD230 = 13;
          byte_1000AD231 = *(_BYTE *)(v8 + 24);
          unk_1000AD232 = *(_OWORD *)(v8 + 28);
          unk_1000AD242 = *(_OWORD *)(v8 + 44);
          uint64_t v375 = 0LL;
          if (sub_1000347D8( &v375,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5579LL,  v287,  v288,  v289,  v290,  v291))
          {
            uint64_t v316 = sub_100040D4C(&qword_10008C1F8, *(void *)(v8 + 160), 18LL, v52, v53, v54, v55, v56);
            if (v316)
            {
              if (!sub_100057AA4( &v376,  (unsigned int *)v8,  0LL,  0LL,  *(void *)(v8 + 160),  0LL,  &qword_10008C730,  v316,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  0x15D9u))
              {
                uint64_t v292 = "dhcpv6_relay_forw: error evaluating Interface ID.";
                goto LABEL_159;
              }

              if (!sub_100040F30(&qword_10008C1F8, v375, 0LL, v377, v378, 18LL, 0LL, v56))
              {
                uint64_t v292 = "dhcpv6_relay_forw: error saving Interface ID.";
                goto LABEL_159;
              }

              sub_100034EA8( &v376,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5606LL,  v52,  v53,  v54,  v55,  v56);
            }

            if (sub_100040F30( &qword_10008C1F8,  v375,  0LL,  (uint64_t)v380,  v381,  9LL,  0LL,  v317))
            {
              uint64_t v318 = sub_100040D4C(&qword_10008C1F8, *(void *)(v8 + 160), 43LL, v52, v53, v54, v55, v56);
              if (!v318)
              {
LABEL_192:
                int v344 = sub_1000425E0( (uint64_t)&unk_1000AD252,  65502LL,  v375,  (unsigned int *)v8,  dword_100082680,  (uint64_t)&v389,  v55,  v56)
                     + 34;
                *(_DWORD *)(v10 + 16) = v344;
                *(void *)uint64_t v10 = 0LL;
                if (!sub_1000345C4( (void *)v10,  v344,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5683LL)) {
                  sub_100061FB4("No memory to store reply.", v345, v346, v347, v348, v349, v350, v351, v363);
                }
                uint64_t v352 = (void *)(*(void *)v10 + 4LL);
                *(void *)(v10 + 8) = v352;
                uint64_t result = (uint64_t)memcpy(v352, &byte_1000AD230, v344);
                goto LABEL_160;
              }

              if (sub_100057AA4( &v389,  (unsigned int *)v8,  0LL,  0LL,  *(void *)(v8 + 160),  0LL,  &qword_10008C730,  v318,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  0x15FFu)
                && (v391 & 1) == 0)
              {
                if ((_DWORD)v391)
                {
                  unint64_t v319 = 0LL;
                  while (1)
                  {
                    uint64_t v320 = sub_100060B5C((unsigned __int16 *)(v390 + v319));
                    if (!sub_100040D4C(&qword_10008C1F8, v375, v320, v321, v322, v323, v324, v325))
                    {
                      uint64_t v329 = sub_100040D4C(&qword_10008C1F8, *(void *)(v8 + 160), v320, v326, v327, v328, v55, v56);
                      if (v329)
                      {
                        if (!sub_100057AA4( &v376,  (unsigned int *)v8,  0LL,  0LL,  *(void *)(v8 + 160),  0LL,  &qword_10008C730,  v329,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  0x1615u))
                        {
                          uint64_t result = sub_10006221C( "dhcpv6_relay_forw: error evaluating option %u.",  v330,  v331,  v332,  v333,  v334,  v335,  v336,  v320);
                          goto LABEL_160;
                        }

                        if (!sub_100040F30( &qword_10008C1F8,  v375,  0LL,  v377,  v378,  v320,  0LL,  v336))
                        {
                          uint64_t result = sub_10006221C( "dhcpv6_relay_forw: error saving option %u.",  v337,  v338,  v339,  v340,  v341,  v342,  v343,  v320);
                          goto LABEL_160;
                        }

                        sub_100034EA8( &v376,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5669LL,  v339,  v340,  v341,  v342,  v343);
                      }
                    }

                    v319 += 2LL;
                  }
                }

                goto LABEL_192;
              }

              uint64_t v292 = "dhcpv6_relay_forw: error evaluating ERO.";
            }

            else
            {
              uint64_t v292 = "dhcpv6_relay_forw: error saving Relay MSG.";
            }
          }

          else
          {
            uint64_t v292 = "dhcpv6_relay_forw: no memory for option state.";
          }

LABEL_159:
          uint64_t result = sub_10006221C(v292, v50, v51, v52, v53, v54, v55, v56, v363);
        }
      }

LABEL_160:
      if (v375) {
        uint64_t result = sub_100034894( &v375,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5691LL,  v287,  v288,  v289,  v290,  v291);
      }
      if (v377) {
        uint64_t result = (uint64_t)sub_100034EA8( &v376,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5693LL,  v287,  v288,  v289,  v290,  v291);
      }
      if (v390) {
        uint64_t result = (uint64_t)sub_100034EA8( &v389,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5696LL,  v287,  v288,  v289,  v290,  v291);
      }
      if (v380) {
        uint64_t result = (uint64_t)sub_100034EA8( &v379,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5699LL,  v287,  v288,  v289,  v290,  v291);
      }
      if (v383) {
        uint64_t result = (uint64_t)sub_100034EA8( &v382,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5702LL,  v287,  v288,  v289,  v290,  v291);
      }
      if (v385[0]) {
        return sub_100034B48( v385,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5705LL,  v287,  v288,  v289,  v290,  v291);
      }
      return result;
    case 13:
      char v48 = (char)off_100089E20[0];
      goto LABEL_60;
    case 14:
      return sub_100019374((uint64_t)v0, v1, v2, v3, v4, v5, v6, v7);
    case 15:
      char v48 = (char)off_100089E30;
LABEL_60:
      *(_OWORD *)__src = *(_OWORD *)(v1 + 80);
      *(_DWORD *)&__src[16] = *(_DWORD *)(v1 + 96);
      sub_100040144((int *)__src, v1, v2, v3, v4, v5, v6, v7);
      return sub_10006238C( "Discarding %s from %s; message type not handled by server",
               v130,
               v131,
               v132,
               v133,
               v134,
               v135,
               v136,
               v48);
    default:
      *(_OWORD *)__src = *(_OWORD *)(v1 + 80);
      *(_DWORD *)&__src[16] = *(_DWORD *)(v1 + 96);
      sub_100040144((int *)__src, v1, v2, v3, v4, v5, v6, v7);
      return sub_1000622D4("Discarding unknown DHCPv6 message type %d from %s", v23, v24, v25, v26, v27, v28, v29, v9);
  }

uint64_t sub_10001C3B4( uint64_t a1, uint64_t a2, uint64_t a3, _DWORD **a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = sub_10001F36C(&qword_10009D178, a2, a3, (uint64_t)a4, a5, a6, a7, a8);
  uint64_t v16 = &unk_10009D000;
  if ((_DWORD)result) {
    goto LABEL_589;
  }
  sub_100034AD8( &qword_10009D198,  a2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  1251LL,  v12,  v13,  v14,  v15);
  sub_100034E60( (uint64_t)&qword_10009D1A0,  a3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  1252LL,  v17,  v18,  v19,  v20);
  uint64_t result = sub_10001F50C(a2, a3, a4, &qword_10009D190, (uint64_t)byte_10009D230, v21, v22, v23);
  if (!(_DWORD)result) {
    goto LABEL_589;
  }
  dword_10009D22C = 4;
  uint64_t v24 = sub_100040D4C(&qword_10008C1F8, *(void *)(a2 + 160), 6LL, v11, v12, v13, v14, v15);
  memset(v497, 0, sizeof(v497));
  if (v24
    && !sub_100057AA4( v497,  (unsigned int *)a2,  0LL,  0LL,  *(void *)(a2 + 160),  0LL,  &qword_10008C730,  v24,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  0x4F6u))
  {
    uint64_t v329 = "lease_to_client: error evaluating ORO.";
    goto LABEL_588;
  }

  if (sub_100029EB4( &qword_10009D180,  (unsigned int *)a2,  *(void *)(a2 + 160),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  1280LL,  v13,  v14,  v15)) {
    sub_10001F748(qword_10009D178);
  }
  if (!qword_10009D180
    && sub_100029E98( &qword_10009D180,  *(const char **)(a3 + 8),  *(unsigned int *)(a3 + 16),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  1286LL,  v29,  v30,  v31))
  {
    sub_10001F748(qword_10009D178);
  }

  LODWORD(qword_10009D1B8) = 0;
  uint64_t v32 = sub_100040D4C(&qword_10008C1F8, *(void *)(a2 + 160), 3LL, v27, v28, v29, v30, v31);
  uint64_t v33 = &unk_10009D000;
  if (!v32)
  {
    int v35 = 0;
    goto LABEL_263;
  }

  uint64_t v34 = v32;
  int v35 = 0;
  do
  {
    qword_10009D1C0 = 0LL;
    uint64_t v498 = 0LL;
    memset(v507, 0, sizeof(v507));
    uint64_t v506 = 0LL;
    __int128 v505 = 0uLL;
    if ((dword_10009D22C - 65521) <= 0xFFFEFFFE)
    {
      uint64_t v329 = "reply_process_ia_na: Reply too long for IA.";
      goto LABEL_588;
    }

    if (!sub_10001FA3C(&v498, v507, v16[51], v34, 0xCu))
    {
      uint64_t v53 = "reply_process_ia_na: error evaluating ia";
LABEL_18:
      uint64_t result = sub_10006221C(v53, v36, v37, v38, v39, v40, v14, v15, v487);
      unsigned int v52 = 25;
      goto LABEL_19;
    }

    uint64_t v41 = sub_100060B50(v507[1]);
    LODWORD(qword_10009D208) = sub_100060B50(v507[1] + 1);
    HIDWORD(qword_10009D208) = sub_100060B50(v507[1] + 2);
    if (sub_10002DBB4( &qword_10009D1D0,  v41,  (const void *)qword_10009D1A8,  dword_10009D1B0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  1566LL,  v42,  v43))
    {
      uint64_t v51 = "reply_process_ia_na: no memory for ia.";
LABEL_16:
      uint64_t result = sub_10006221C(v51, v44, v45, v46, v47, v48, v49, v50, v487);
      unsigned int v52 = 1;
      goto LABEL_19;
    }

    uint64_t v54 = qword_10009D1D0;
    *(_WORD *)(qword_10009D1D0 + 32) = 3;
    sub_100029804( &qword_10009D1D8,  qword_10008BE60,  *(void *)(v54 + 16),  *(unsigned int *)(v54 + 24),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  1576LL);
    uint64_t result = sub_1000347D8( &qword_10009D1E0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  1582LL,  v55,  v56,  v57,  v58,  v59);
    if (!(_DWORD)result)
    {
      unsigned int v52 = 1;
      uint64_t v16 = (void *)&unk_10009D000;
      goto LABEL_19;
    }

    if (qword_10009D180 && (uint64_t v60 = *(void *)(qword_10009D180 + 136)) != 0)
    {
      uint64_t v16 = (void *)&unk_10009D000;
      if (!sub_100057AA4( &qword_10009D1E8,  0LL,  0LL,  0LL,  0LL,  0LL,  &qword_10008C730,  v60,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  0x639u))
      {
        unsigned int v52 = 25;
        uint64_t v68 = "reply_process_ia_na: unable to evaluate fixed address.";
        goto LABEL_163;
      }

      if (dword_10009D1F8 < 0x10)
      {
        unsigned int v52 = 39;
        uint64_t v68 = "reply_process_ia_na: invalid fixed address.";
LABEL_163:
        uint64_t result = sub_10006221C(v68, v61, v62, v63, v64, v65, v66, v67, v487);
        goto LABEL_19;
      }

      *(_OWORD *)uint64_t v508 = *(_OWORD *)qword_10009D1F0;
      *(_DWORD *)uint64_t v510 = 16;
      *(_OWORD *)&v510[4] = *(_OWORD *)v508;
      if (!sub_10002A180( (uint64_t)&qword_10009D188,  qword_10009D178,  (uint64_t)v510,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  1611LL,  v65,  v66,  v67)) {
        sub_100061FB4( "Impossible condition at %s:%d.",  v179,  v180,  v181,  v182,  v183,  v184,  v185,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c");
      }
      dword_10009D1C8 = 1;
    }

    else
    {
      dword_10009D1C8 = 0;
    }

    int v488 = dword_10009D22C;
    uint64_t v492 = &byte_10009D230[dword_10009D22C];
    sub_100060B78(v492, 3u);
    dword_10009D22C += 2;
    sub_100060B78(&byte_10009D230[dword_10009D22C], 0xCu);
    dword_10009D22C += 2;
    sub_100060B6C(&byte_10009D230[dword_10009D22C], v41);
    dword_10009D22C += 4;
    sub_100060B6C(&byte_10009D230[dword_10009D22C], qword_10009D208);
    dword_10009D22C += 4;
    sub_100060B6C(&byte_10009D230[dword_10009D22C], HIDWORD(qword_10009D208));
    dword_10009D22C += 4;
    uint64_t result = sub_100040D4C(&qword_10008C1F8, v498, 5LL, v69, v70, v71, v72, v73);
    *(_OWORD *)&dword_10009D210 = xmmword_100082690;
    if (result)
    {
      uint64_t v74 = result;
      uint64_t v16 = &unk_10009D000;
      uint64_t v33 = (void *)&unk_10009D000;
      while (1)
      {
        memset(v508, 0, sizeof(v508));
        uint64_t v500 = 0LL;
        uint64_t v501 = 0LL;
        uint64_t v499 = 0LL;
        if ((dword_10009D22C - 65509) <= 0xFFFEFFFE)
        {
          uint64_t result = sub_10006221C( "reply_process_addr: Out of room for address.",  v25,  v26,  v11,  v12,  v13,  v14,  v15,  v487);
          unsigned int v52 = 19;
          goto LABEL_19;
        }

        if (sub_100057AA4( v508,  (unsigned int *)v16[51],  0LL,  0LL,  *(void *)(v16[51] + 160LL),  0LL,  &qword_10008C730,  v74,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  0x792u)) {
          BOOL v75 = *(_DWORD *)&v508[16] > 0x17u;
        }
        else {
          BOOL v75 = 0;
        }
        if (!v75)
        {
          uint64_t v76 = "reply_process_addr: error evaluating IAADDR.";
LABEL_58:
          uint64_t result = sub_10006221C(v76, v25, v26, v11, v12, v13, v14, v15, v487);
          unsigned int v52 = 25;
          goto LABEL_59;
        }

        unsigned int v77 = sub_100060B50((unsigned int *)(*(void *)&v508[8] + 16LL));
        uint64_t result = sub_100060B50((unsigned int *)(*(void *)&v508[8] + 20LL));
        if (dword_10009D21C - 1 >= v77) {
          dword_10009D21C = v77;
        }
        LODWORD(v504[0]) = 16;
        *(void *)((char *)v504 + 4) = 0LL;
        *(void *)((char *)v504 + 12) = 0LL;
        if (**(void **)&v508[8]) {
          BOOL v78 = 0;
        }
        else {
          BOOL v78 = *(void *)(*(void *)&v508[8] + 8LL) == *(void *)((char *)v504 + 12);
        }
        if (v78)
        {
          unsigned int v52 = 0;
          if (!*(void *)&v508[8]) {
            goto LABEL_61;
          }
LABEL_60:
          uint64_t result = (uint64_t)sub_100034EA8( (_DWORD **)v508,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2195LL,  v11,  v12,  v13,  v14,  v15);
          goto LABEL_61;
        }

        *(_OWORD *)((char *)v504 + 4) = **(_OWORD **)&v508[8];
        uint64_t v79 = *(void *)(qword_10009D178 + 56);
        if (v79)
        {
          while (1)
          {
            *(_OWORD *)uint64_t v510 = v504[0];
            *(_DWORD *)&v510[16] = v504[1];
            int32x4_t v502 = *(int32x4_t *)(v79 + 104);
            int v503 = *(_DWORD *)(v79 + 120);
            sub_10003F7A4(v510, &v502, v26, v11, v12, v13, v14, v15, (unint64_t)v509);
            *(_OWORD *)uint64_t v510 = *(_OWORD *)(v79 + 84);
            *(_DWORD *)&v510[16] = *(_DWORD *)(v79 + 100);
            uint64_t v79 = *(void *)(v79 + 40);
            if (!v79) {
              goto LABEL_80;
            }
          }

          uint64_t result = sub_10001FB94((uint64_t)v504, v25, v26, v11, v12, v13, v14, v15);
          if ((_DWORD)result)
          {
            unsigned int v52 = 0;
LABEL_88:
            if (dword_10009D1C8)
            {
              uint64_t v87 = &qword_10009D188;
              if (!qword_10009D180) {
                sub_100061FB4( "Impossible condition at %s:%d.",  v25,  v26,  v11,  v12,  v13,  v14,  v15,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c");
              }
              uint64_t v88 = &qword_10008C730;
            }

            else
            {
              if (!qword_10009D200) {
                sub_100061FB4( "Impossible condition at %s:%d.",  v25,  v26,  v11,  v12,  v13,  v14,  v15,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c");
              }
              uint64_t v88 = (uint64_t *)(qword_10009D200 + 24);
              uint64_t v87 = (uint64_t *)(*(void *)(qword_10009D200 + 64) + 80LL);
            }

            uint64_t v104 = *(void **)(*v87 + 128);
            if (!(_DWORD)qword_10009D1C0) {
              goto LABEL_615;
            }
            uint64_t result = sub_100040D4C(&qword_10008BF80, qword_10009D190, 56LL, v11, v12, v13, v14, v15);
            if (result)
            {
              if (!sub_100057AA4( &v499,  (unsigned int *)qword_10009D198,  0LL,  0LL,  *(void *)(qword_10009D198 + 160),  qword_10009D190,  v88,  result,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  0x876u)
                || (_DWORD)v501 != 4)
              {
                uint64_t v76 = "reply_process_addr: unable to evaluate addrs-per-ia value.";
                goto LABEL_58;
              }

              unsigned int v105 = sub_100060B50(v500);
              uint64_t result = (uint64_t)sub_100034EA8( &v499,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2175LL,  v106,  v107,  v108,  v109,  v110);
            }

            else
            {
              unsigned int v105 = 1;
            }

            BOOL v111 = qword_10009D1C0 >= v105;
            uint64_t v16 = (void *)&unk_10009D000;
            if (!v111)
            {
LABEL_615:
              uint64_t result = sub_10001FC78(v88, v104);
              unsigned int v52 = result;
              if (!(_DWORD)result) {
                goto LABEL_143;
              }
            }
          }

          else
          {
            switch(*(_BYTE *)(v16[51] + 20LL))
            {
              case 1:
              case 3:
              case 6:
                uint64_t v101 = qword_10009D178;
                if (!qword_10009D178
                  || ((v102 = *(uint64_t **)(qword_10009D178 + 80)) != 0LL ? (BOOL v103 = qword_10009D200 == 0) : (BOOL v103 = 0),
                      !v103))
                {
                  unsigned int v52 = 39;
                  goto LABEL_59;
                }

                *(void *)&v510[8] = (char *)v504 + 4;
                unsigned int v117 = v504[0];
                *(void *)&v510[16] = LODWORD(v504[0]);
                *(void *)uint64_t v510 = 0LL;
                uint64_t v118 = *v102;
                if (!*v102)
                {
                  uint64_t result = (uint64_t)sub_100034EA8( (_DWORD **)v510,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2719LL,  v11,  v12,  v13,  v14,  v15);
                  unsigned int v52 = 13;
                  uint64_t v16 = (void *)&unk_10009D000;
                  goto LABEL_59;
                }

                unsigned int v52 = 13;
                uint64_t v119 = 8LL;
                break;
              case 5:
                sub_100034894( &qword_10009D1E0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2101LL,  v11,  v12,  v13,  v14,  v15);
                if (!sub_1000347D8( &qword_10009D1E0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2102LL,  v112,  v113,  v114,  v115,  v116)) {
                  goto LABEL_121;
                }
                uint64_t result = sub_10001F94C(3u, "Address not bound to this interface.", qword_10009D1E0);
                if ((_DWORD)result) {
                  goto LABEL_93;
                }
                uint64_t v76 = "reply_process_addr: Unable to attach status code.";
                goto LABEL_58;
              default:
                uint64_t v76 = "It is impossible to lease a client that is not sending a solicit, request, renew, or rebind message.";
                goto LABEL_58;
            }

            do
            {
              if (*(_WORD *)(v118 + 4) == 3)
              {
                if (v117 >= 0x10)
                {
                  int32x4_t v502 = *(int32x4_t *)((char *)v504 + 4);
                  if ((vmaxv_u16((uint16x4_t)vmovn_s32(vtstq_s32(v502, v502))) & 1) != 0)
                  {
                    if (sub_10002F674((__int128 *)v502.i8, v118, v26, v11, v12, v13, v14, v15))
                    {
                      if (sub_10002E9A4(v118, v502.i8, v26, v11, v12, v13, v14, v15))
                      {
                        unsigned int v52 = 5;
                      }

                      else
                      {
                        unsigned int v52 = sub_10002D9A0( &qword_10009D200,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  971LL,  v11,  v12,  v13,  v14,  v15);
                        if (!v52)
                        {
                          *(int32x4_t *)(qword_10009D200 + 4) = v502;
                          uint64_t v120 = qword_10009D200;
                          *(_BYTE *)(qword_10009D200 + 20) = 0;
                          unsigned int v52 = sub_10002E7BC(v118, v120, xmmword_10008CE80 + 120, v11, v12, v13, v14, v15);
                          if (!v52)
                          {
                            uint64_t result = (uint64_t)sub_100034EA8( (_DWORD **)v510,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2719LL,  v121,  v122,  v123,  v124,  v125);
                            uint64_t v16 = (void *)&unk_10009D000;
                            goto LABEL_140;
                          }

                          sub_10002D8B8( (void **)&qword_10009D200,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  981LL,  v121,  v122,  v123,  v124,  v125);
                        }
                      }
                    }

                    else
                    {
                      unsigned int v52 = 4;
                    }
                  }

                  else
                  {
                    unsigned int v52 = 25;
                  }
                }

                else
                {
                  unsigned int v52 = 39;
                }

                uint64_t v101 = qword_10009D178;
              }

              uint64_t v118 = *(void *)(*(void *)(v101 + 80) + v119);
              v119 += 8LL;
            }

            while (v118);
            uint64_t result = (uint64_t)sub_100034EA8( (_DWORD **)v510,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2719LL,  v11,  v12,  v13,  v14,  v15);
            uint64_t v16 = &unk_10009D000;
            if (v52 > 5 || ((1 << v52) & 0x31) == 0) {
              goto LABEL_59;
            }
LABEL_140:
            if (qword_10009D200) {
              goto LABEL_88;
            }
            if (*(_BYTE *)(v16[51] + 20LL) == 6)
            {
LABEL_142:
              qword_10009D220 = 0LL;
LABEL_143:
              uint64_t result = sub_10001FFF8((uint64_t)v504);
              unsigned int v52 = result;
            }
          }
        }

        else
        {
LABEL_80:
          int v86 = *(unsigned __int8 *)(v16[51] + 20LL);
          if (v86 == 3)
          {
            sub_100034894( &qword_10009D1E0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2005LL,  v11,  v12,  v13,  v14,  v15);
            if (sub_1000347D8( &qword_10009D1E0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2006LL,  v89,  v90,  v91,  v92,  v93))
            {
              uint64_t result = sub_10001F94C(4u, "Address not for use on this link.", qword_10009D1E0);
              if (!(_DWORD)result)
              {
                uint64_t v76 = "reply_process_addr: Failure setting status code.";
                goto LABEL_58;
              }

LABEL_93:
              unsigned int v52 = 20;
            }

            else
            {
LABEL_121:
              uint64_t result = sub_10006221C( "reply_process_addr: No memory for option state wipe.",  v94,  v95,  v96,  v97,  v98,  v99,  v100,  v487);
              unsigned int v52 = 1;
            }
          }

          else
          {
            if (v86 != 1)
            {
              uint64_t v76 = "It is impossible to lease a client that is not sending a solicit, request, renew, or rebind.";
              goto LABEL_58;
            }

            byte_10009D230[0] = 2;
            uint64_t result = sub_10004463C(&qword_10008C1F8, qword_10009D190, 14LL, v11, v12, v13, v14, v15);
            unsigned int v52 = 0;
          }
        }

LABEL_59:
        if (*(void *)&v508[8]) {
          goto LABEL_60;
        }
LABEL_61:
        uint64_t v33 = &unk_10009D000;
        if (v500) {
          uint64_t result = (uint64_t)sub_100034EA8( &v499,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2197LL,  v11,  v12,  v13,  v14,  v15);
        }
        if (qword_10009D200) {
          uint64_t result = sub_10002D8B8( (void **)&qword_10009D200,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2199LL,  v11,  v12,  v13,  v14,  v15);
        }
        if (v52 - 4 >= 2 && v52)
        {
          if (v52 == 20)
          {
            LODWORD(qword_10009D1B8) = qword_10009D1B8 + 1;
            goto LABEL_149;
          }

          goto LABEL_19;
        }

        uint64_t v74 = *(void *)(v74 + 8);
        if (!v74) {
          goto LABEL_148;
        }
      }
    }

    unsigned int v52 = 0;
    uint64_t v16 = (void *)&unk_10009D000;
    uint64_t v33 = (void *)&unk_10009D000;
LABEL_148:
    LODWORD(qword_10009D1B8) = qword_10009D1B8 + 1;
    if ((_DWORD)qword_10009D1C0) {
      goto LABEL_149;
    }
    if (dword_10009D1C8)
    {
      if (qword_10009D180)
      {
        *(_DWORD *)uint64_t v508 = 16;
        *(_OWORD *)&v508[4] = *(_OWORD *)qword_10009D1F0;
        uint64_t v144 = *(void **)(qword_10009D188 + 128);
        uint64_t v145 = &qword_10008C730;
        goto LABEL_157;
      }

      unsigned int v52 = 39;
      goto LABEL_19;
    }

    if (!qword_10009D1D8 || (int v186 = *(_DWORD *)(qword_10009D1D8 + 36), v186 < 1))
    {
      uint64_t v188 = 0LL;
      goto LABEL_225;
    }

    uint64_t v187 = 0LL;
    uint64_t v188 = 0LL;
    uint64_t v189 = *(void *)(qword_10009D1D8 + 56);
    do
    {
      uint64_t v190 = *(void *)(v189 + 8 * v187);
      if (*(void *)(*(void *)(v190 + 64) + 72LL) != qword_10009D178) {
        goto LABEL_220;
      }
      if (!v188)
      {
LABEL_219:
        uint64_t v188 = *(void *)(v189 + 8 * v187);
        goto LABEL_220;
      }

      int v191 = *(unsigned __int8 *)(v190 + 21);
      switch(v191)
      {
        case 5:
          int v193 = *(unsigned __int8 *)(v188 + 21);
          if (v193 != 5
            || (v194 = *(void *)(v188 + 32), uint64_t v188 = *(void *)(v189 + 8 * v187), *(void *)(v190 + 32) >= v194))
          {
LABEL_222:
            sub_100061FB4( "Impossible condition at %s:%d.",  v25,  v26,  v11,  v12,  v13,  v14,  v15,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c");
          }

          break;
        case 3:
          int v195 = *(unsigned __int8 *)(v188 + 21);
          if (v195 != 2)
          {
            if (v195 == 5) {
              goto LABEL_219;
            }
            if (v195 != 3) {
              goto LABEL_222;
            }
            uint64_t v196 = *(void *)(v190 + 32);
            uint64_t v197 = *(void *)(v188 + 32);
            if (v196 >= v197 && (v196 != v197 || *(void *)(v190 + 40) >= *(void *)(v188 + 40))) {
              goto LABEL_219;
            }
          }

          break;
        case 2:
          int v192 = *(unsigned __int8 *)(v188 + 21);
          if (v192 == 5 || v192 == 3) {
            goto LABEL_219;
          }
          if (v192 != 2) {
            goto LABEL_222;
          }
          if (*(void *)(v190 + 32) >= *(void *)(v188 + 32)) {
            uint64_t v188 = *(void *)(v189 + 8 * v187);
          }
          break;
        default:
          goto LABEL_222;
      }

      uint64_t v19 = (const char **)v94[5];
      if (!v19) {
        goto LABEL_66;
      }
    }

    while (*((_DWORD *)v19 + 4) == 17);
    if (!v89) {
      goto LABEL_89;
    }
    if (a7 && *a7)
    {
      sub_100033F18( (void *)(v89 + 8),  (_DWORD *)*a7,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  472LL,  v16,  v17,  v18,  (uint64_t)v19);
      uint64_t v19 = (const char **)v94[5];
    }

    sub_10003D510(a1, a2, a3, a4, a5, a6, &v89, v19);
LABEL_66:
    if (v89) {
      sub_10005515C( &v89,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  480LL,  v22,  v16,  v17,  v18,  (uint64_t)v19);
    }
LABEL_89:
    sub_10003DC78( (void **)&v95,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  523LL,  v22,  v16,  v17,  v18,  (uint64_t)v19);
    if (v93)
    {
      sub_100033F18( &v95,  v93,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  525LL,  v16,  v17,  v18,  (uint64_t)v19);
      sub_10003DC78( (void **)&v93,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  526LL,  v79,  v80,  v81,  v82,  v83);
    }

    uint64_t v20 = v95;
  }

  while (v95);
  return 1LL;
}

LABEL_220:
      ++v187;
    }

    while (v187 < v186);
    if (v188 && *(_BYTE *)(v188 + 21) != 5)
    {
      sub_10002D850( &qword_10009D200,  (_DWORD *)v188,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2774LL,  v12,  v13,  v14,  v15);
      uint64_t v16 = (void *)&unk_10009D000;
      goto LABEL_259;
    }

LABEL_225:
    uint64_t v198 = qword_10009D178;
    char v199 = *(uint64_t **)(qword_10009D178 + 80);
    if (!v199)
    {
      uint64_t v202 = "Unable to pick client address: no IPv6 pools on this shared network";
LABEL_244:
      uint64_t result = sub_10006238C(v202, v25, v26, v11, v12, v13, v14, v15, v487);
      uint64_t v16 = &unk_10009D000;
      if (v188) {
        uint64_t result = sub_10006221C( "Reclaiming abandoned addresses is not yet supported.  Treating this as an out of space condition.",  v25,  v26,  v11,  v12,  v13,  v14,  v15,  v487);
      }
      goto LABEL_246;
    }

    uint64_t v200 = *v199;
    if (!*v199)
    {
LABEL_230:
      uint64_t v202 = "Unable to pick client address: no IPv6 address pools on this shared network";
      goto LABEL_244;
    }

    uint64_t v201 = 1LL;
    while (*(_WORD *)(v200 + 4) != 3)
    {
      uint64_t v200 = v199[v201++];
      if (!v200) {
        goto LABEL_230;
      }
    }

    int v210 = *(_DWORD *)(qword_10009D178 + 88);
    int v211 = v210;
    while (2)
    {
      uint64_t v212 = v199[v211];
      if (*(_WORD *)(v212 + 4) != 3)
      {
LABEL_239:
        if (v199[v211 + 1]) {
          ++v211;
        }
        else {
          int v211 = 0;
        }
        if (v211 == v210)
        {
          uint64_t v202 = "Unable to pick client address: no addresses available";
          uint64_t v33 = (void *)&unk_10009D000;
          goto LABEL_244;
        }

        continue;
      }

      break;
    }

    if (sub_10002E220( v212,  &qword_10009D200,  (unsigned int *)&v499,  (uint64_t)&qword_10009D1A0,  xmmword_10008CE80 + 120,  v13,  v14,  v15))
    {
      char v199 = *(uint64_t **)(v198 + 80);
      goto LABEL_239;
    }

    if (v499 >= 2)
    {
      if (*(void *)(*(void *)(v198 + 80) + 8 * (v211 + 1LL))) {
        ++v211;
      }
      else {
        int v211 = 0;
      }
    }

    *(_DWORD *)(v198 + 88) = v211;
    uint64_t v33 = &unk_10009D000;
    char v218 = inet_ntop(30, (const void *)(qword_10009D200 + 4), v510, 0x2Eu);
    sub_10006238C("Picking pool address %s", v219, v220, v221, v222, v223, v224, v225, v218);
    uint64_t v16 = (void *)&unk_10009D000;
LABEL_259:
    uint64_t v226 = v33[64];
    if (!v226) {
      sub_100061FB4( "Impossible condition at %s:%d.",  v203,  v204,  v205,  v206,  v207,  v208,  v209,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c");
    }
    uint64_t v145 = (uint64_t *)(v226 + 24);
    uint64_t v144 = *(void **)(*(void *)(*(void *)(v226 + 64) + 80LL) + 128LL);
    *(_DWORD *)uint64_t v508 = 16;
    *(_OWORD *)&v508[4] = *(_OWORD *)(v226 + 4);
LABEL_157:
    uint64_t result = sub_10001FC78(v145, v144);
    unsigned int v52 = result;
    if (!(_DWORD)result)
    {
      uint64_t result = sub_10001FFF8((uint64_t)v508);
      unsigned int v52 = result;
    }

    if (!v52) {
      goto LABEL_149;
    }
    if (v52 != 13) {
      goto LABEL_19;
    }
LABEL_246:
    if ((*(unsigned __int8 *)(v16[51] + 20LL) | 2) != 3)
    {
      if (!HIDWORD(qword_10009D1C0))
      {
        unsigned int v52 = 13;
        goto LABEL_19;
      }

      goto LABEL_251;
    }

    sub_100034894( &qword_10009D1E0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  1704LL,  v11,  v12,  v13,  v14,  v15);
    if (!sub_1000347D8( &qword_10009D1E0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  1706LL,  v213,  v214,  v215,  v216,  v217))
    {
      uint64_t v51 = "reply_process_ia_na: No memory for option state wipe.";
      goto LABEL_16;
    }

    if (!sub_10001F94C(2u, "No addresses available for this interface.", qword_10009D1E0))
    {
      uint64_t v53 = "reply_process_ia_na: Unable to set NoAddrsAvail status code.";
      goto LABEL_18;
    }

LABEL_251:
    unsigned int v52 = 0;
LABEL_149:
    dword_10009D22C += sub_1000425E0( (uint64_t)&qword_10009D178 + dword_10009D22C + 184,  (0x10000 - dword_10009D22C),  qword_10009D1E0,  (unsigned int *)qword_10009D198,  dword_10008264C,  0LL,  v14,  v15);
    sub_100060B78((_WORD *)v492 + 1, dword_10009D22C - v488 - 4);
    LODWORD(qword_10009D208) = 0;
    uint64_t v131 = sub_100040D4C(&qword_10008C168, qword_10009D190, 58LL, v126, v127, v128, v129, v130);
    if (v131)
    {
      if (sub_100057AA4( &v505,  (unsigned int *)qword_10009D198,  0LL,  0LL,  *(void *)(qword_10009D198 + 160),  qword_10009D190,  &qword_10008C730,  v131,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  0x6F4u)
        && (_DWORD)v506 == 4)
      {
        LODWORD(qword_10009D208) = sub_100060B50(*((unsigned int **)&v505 + 1));
      }

      else
      {
        sub_10006221C("Invalid renewal time.", v132, v133, v134, v135, v136, v137, v138, v487);
      }

      if (*((void *)&v505 + 1)) {
        sub_100034EA8( (_DWORD **)&v505,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  1788LL,  v139,  v140,  v141,  v142,  v143);
      }
    }

    sub_100060B6C((_DWORD *)v492 + 2, qword_10009D208);
    HIDWORD(qword_10009D208) = 0;
    uint64_t v151 = sub_100040D4C(&qword_10008C168, qword_10009D190, 59LL, v146, v147, v148, v149, v150);
    uint64_t v33 = (void *)&unk_10009D000;
    if (v151)
    {
      if (sub_100057AA4( &v505,  (unsigned int *)qword_10009D198,  0LL,  0LL,  *(void *)(qword_10009D198 + 160),  qword_10009D190,  &qword_10008C730,  v151,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  0x708u)
        && (_DWORD)v506 == 4)
      {
        HIDWORD(qword_10009D208) = sub_100060B50(*((unsigned int **)&v505 + 1));
      }

      else
      {
        sub_10006221C("Invalid rebinding time.", v152, v153, v154, v155, v156, v157, v158, v487);
      }

      if (*((void *)&v505 + 1)) {
        sub_100034EA8( (_DWORD **)&v505,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  1808LL,  v159,  v160,  v161,  v162,  v163);
      }
    }

    uint64_t result = (uint64_t)sub_100060B6C((_DWORD *)v492 + 3, HIDWORD(qword_10009D208));
    if (v52 != 20 && !dword_10009D1C8 && byte_10009D230[0] == 7)
    {
      uint64_t v11 = qword_10009D1D0;
      int v164 = *(_DWORD *)(qword_10009D1D0 + 36);
      if (v164)
      {
        if (v164 >= 1)
        {
          uint64_t v165 = 0LL;
          do
          {
            uint64_t v166 = *(uint64_t **)(*(void *)(v11 + 56) + 8 * v165);
            uint64_t v167 = (void **)(v166 + 7);
            if (v166[7])
            {
              sub_10002D71C( v167,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  1831LL,  v11,  v12,  v13,  v14,  v15);
              uint64_t v11 = qword_10009D1D0;
            }

            sub_10002D6B4( v167,  (_DWORD *)v11,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  1832LL,  v12,  v13,  v14,  v15);
            v166[4] = v166[5];
            v166[5] = 0LL;
            sub_10002E9FC(v166[8], (uint64_t)v166);
            sub_10002F2A0((uint64_t **)v166[8]);
            uint64_t v173 = sub_100040D4C(&qword_10008BF80, qword_10009D190, 30LL, v168, v169, v170, v171, v172);
            if (!v173
              || sub_100057AF8( 0LL,  (unsigned int *)qword_10009D198,  0LL,  0LL,  *(void *)(qword_10009D198 + 160),  qword_10009D190,  v166 + 3,  v173,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  0x73Cu))
            {
              sub_10000E340(qword_10009D198, 0LL, 0LL, (uint64_t)v166, 0LL, qword_10009D190, v14, v15);
            }

            ++v165;
            uint64_t v11 = qword_10009D1D0;
          }

          while (v165 < *(int *)(qword_10009D1D0 + 36));
        }

        if (qword_10009D1D8)
        {
          sub_100029210( qword_10008BE60,  *(const char **)(qword_10009D1D8 + 16),  *(unsigned int *)(qword_10009D1D8 + 24),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  1863LL,  v13,  v14,  v15);
          sub_10002D71C( (void **)&qword_10009D1D8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  1864LL,  v174,  v175,  v176,  v177,  v178);
          uint64_t v11 = qword_10009D1D0;
        }

        *(void *)(v11 + 48) = xmmword_10008CE80;
        sub_100029214( qword_10008BE60,  *(const char **)(v11 + 16),  *(unsigned int *)(v11 + 24),  v11,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  1871LL,  v14,  v15,  v487);
        uint64_t result = sub_10000D7B4(qword_10009D1D0);
        uint64_t v16 = (void *)&unk_10009D000;
        uint64_t v33 = (void *)&unk_10009D000;
      }
    }

LABEL_19:
    if (v498) {
      uint64_t result = sub_100034894( &v498,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  1878LL,  v11,  v12,  v13,  v14,  v15);
    }
    if (qword_10009D1E0) {
      uint64_t result = sub_100034894( &qword_10009D1E0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  1880LL,  v11,  v12,  v13,  v14,  v15);
    }
    if (v507[1]) {
      uint64_t result = (uint64_t)sub_100034EA8( v507,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  1882LL,  v11,  v12,  v13,  v14,  v15);
    }
    if (*((void *)&v505 + 1)) {
      uint64_t result = (uint64_t)sub_100034EA8( (_DWORD **)&v505,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  1884LL,  v11,  v12,  v13,  v14,  v15);
    }
    if (qword_10009D1D0) {
      uint64_t result = sub_10002D71C( (void **)&qword_10009D1D0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  1886LL,  v11,  v12,  v13,  v14,  v15);
    }
    if (qword_10009D1D8) {
      uint64_t result = sub_10002D71C( (void **)&qword_10009D1D8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  1888LL,  v11,  v12,  v13,  v14,  v15);
    }
    if (v33[64]) {
      uint64_t result = sub_10002D8B8( (void **)&qword_10009D200,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  1890LL,  v11,  v12,  v13,  v14,  v15);
    }
    if (qword_10009D1F0) {
      uint64_t result = (uint64_t)sub_100034EA8( &qword_10009D1E8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  1892LL,  v11,  v12,  v13,  v14,  v15);
    }
    if (qword_10009D188) {
      uint64_t result = sub_1000235C8(&qword_10009D188, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c", 1894LL);
    }
    if (v52 > 0x14 || ((1 << v52) & 0x102001) == 0) {
      goto LABEL_589;
    }
    if (!(_DWORD)qword_10009D1C0) {
      int v35 = 1;
    }
    uint64_t v34 = *(void *)(v34 + 8);
  }

  while (v34);
LABEL_263:
  uint64_t v227 = sub_100040D4C(&qword_10008C1F8, *(void *)(a2 + 160), 4LL, v11, v12, v13, v14, v15);
  if (!v227)
  {
    uint64_t v247 = "registered trace type for type name %.*s";
    goto LABEL_385;
  }

  uint64_t v228 = v227;
  do
  {
    qword_10009D1C0 = 0LL;
    uint64_t v498 = 0LL;
    uint64_t v499 = 0LL;
    memset(v510, 0, 24);
    memset(v508, 0, sizeof(v508));
    uint64_t v500 = 0LL;
    uint64_t v501 = 0LL;
    if ((dword_10009D22C - 65529) <= 0xFFFEFFFE)
    {
      uint64_t v329 = "reply_process_ia_ta: Reply too long for IA.";
      goto LABEL_588;
    }

    if (!sub_10001FA3C(&v498, v510, v16[51], v228, 4u))
    {
      uint64_t v246 = "reply_process_ia_ta: error evaluating ia";
      goto LABEL_272;
    }

    uint64_t v234 = sub_100060B50(*(unsigned int **)&v510[8]);
    unsigned int v235 = v234;
    if (sub_10002DBB4( &qword_10009D1D0,  v234,  (const void *)qword_10009D1A8,  dword_10009D1B0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2285LL,  v236,  v237))
    {
      uint64_t result = sub_10006221C("reply_process_ia_ta: no memory for ia.", v238, v239, v240, v241, v242, v243, v244, v487);
LABEL_269:
      unsigned int v245 = 1;
      goto LABEL_270;
    }

    uint64_t v248 = qword_10009D1D0;
    *(_WORD *)(qword_10009D1D0 + 32) = 4;
    sub_100029804( &qword_10009D1D8,  qword_10008BE70,  *(void *)(v248 + 16),  *(unsigned int *)(v248 + 24),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2295LL);
    uint64_t result = sub_1000347D8( &qword_10009D1E0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2301LL,  v249,  v250,  v251,  v252,  v253);
    if (!(_DWORD)result)
    {
      unsigned int v245 = 1;
LABEL_337:
      uint64_t v16 = (void *)&unk_10009D000;
      goto LABEL_270;
    }

    dword_10009D1C8 = 0;
    uint64_t v489 = &byte_10009D230[dword_10009D22C];
    int v490 = dword_10009D22C;
    sub_100060B78(v489, 4u);
    dword_10009D22C += 2;
    sub_100060B78(&byte_10009D230[dword_10009D22C], 4u);
    dword_10009D22C += 2;
    sub_100060B6C(&byte_10009D230[dword_10009D22C], v235);
    dword_10009D22C += 4;
    *(_OWORD *)&dword_10009D210 = xmmword_100082690;
    uint64_t v259 = sub_100040D4C(&qword_10008C1F8, v498, 5LL, v254, v255, v256, v257, v258);
    if (v259)
    {
      uint64_t v260 = v259;
      unsigned int v245 = 0;
      uint64_t v16 = &unk_10009D000;
      while (1)
      {
        uint64_t v499 = 0LL;
        uint64_t v500 = 0LL;
        uint64_t v501 = 0LL;
        if (!sub_100057AA4( &v499,  (unsigned int *)v16[51],  0LL,  0LL,  *(void *)(v16[51] + 160LL),  0LL,  &qword_10008C730,  v260,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  0x927u)
          || v501 <= 0x17)
        {
          break;
        }

        unsigned int v269 = sub_100060B50(v500 + 4);
        unsigned int v270 = sub_100060B50(v500 + 5);
        if (dword_10009D218 - 1 >= v270) {
          dword_10009D218 = v270;
        }
        if (dword_10009D21C - 1 >= v269) {
          dword_10009D21C = v269;
        }
        if (v245 == 20)
        {
          uint64_t v16 = (void *)&unk_10009D000;
          goto LABEL_334;
        }

        *(_DWORD *)uint64_t v509 = 16;
        *(_OWORD *)&v509[4] = *(_OWORD *)v500;
        int32x4_t v502 = *(int32x4_t *)&v509[4];
        if ((vmaxv_u16((uint16x4_t)vmovn_s32(vtstq_s32(v502, v502))) & 1) != 0)
        {
          uint64_t v271 = *(void *)(qword_10009D178 + 56);
          if (v271)
          {
            while (1)
            {
              __int128 v505 = *(_OWORD *)v509;
              LODWORD(v506) = *(_DWORD *)&v509[16];
              v504[0] = *(_OWORD *)(v271 + 104);
              LODWORD(v504[1]) = *(_DWORD *)(v271 + 120);
              sub_10003F7A4(&v505, v504, v26, v11, v12, v13, v14, v15, (unint64_t)v507);
              __int128 v505 = *(_OWORD *)(v271 + 84);
              LODWORD(v506) = *(_DWORD *)(v271 + 100);
              uint64_t v271 = *(void *)(v271 + 40);
              if (!v271) {
                goto LABEL_330;
              }
            }

            uint64_t v281 = qword_10009D178;
            uint64_t v282 = *(uint64_t **)(qword_10009D178 + 80);
            if (v282)
            {
              uint64_t v283 = *v282;
              if (*v282)
              {
                uint64_t v284 = 8LL;
                do
                {
                  if (*(_WORD *)(v283 + 4) == 4)
                  {
                    if (sub_10002F674((__int128 *)v502.i8, v283, v279, v11, v12, v13, v14, v15))
                    {
                      if (sub_10002D9A0( &qword_10009D200,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2612LL,  v11,  v12,  v13,  v14,  v15)) {
                        break;
                      }
                      *(int32x4_t *)(qword_10009D200 + 4) = v502;
                      uint64_t v285 = qword_10009D200;
                      *(_BYTE *)(qword_10009D200 + 20) = 0;
LABEL_315:
                      if (sub_10001FC78( (uint64_t *)(qword_10009D200 + 24),  *(void **)(qword_10009D178 + 96))
                        || sub_10001FFF8((uint64_t)v509))
                      {
                        break;
                      }

                      unsigned int v245 = 0;
                      uint64_t v16 = (void *)&unk_10009D000;
                      if (qword_10009D200)
                      {
                        uint64_t v280 = 2379LL;
                        goto LABEL_333;
                      }

                      goto LABEL_334;
                    }

                    uint64_t v281 = qword_10009D178;
                  }

                  uint64_t v283 = *(void *)(*(void *)(v281 + 80) + v284);
                  v284 += 8LL;
                }

                while (v283);
              }
            }
          }
        }

    if ((*a3)[1] == 111) {
      return 0LL;
    }
    uint64_t v33 = "expecting number.";
LABEL_45:
    sub_100046D6C((uint64_t)a2, v33, v15, v16, v17, v18, v19, v20, v79);
    if (v29 != 59) {
LABEL_46:
    }
      sub_100046C4C(a2, 0);
    return 0LL;
  }

  switch(**a3)
  {
    case 'S':
      goto LABEL_12;
    case 'T':
      uint64_t v29 = sub_100036D00(v82, 0LL, (uint64_t)a2);
      if (v29 != 416) {
        goto LABEL_18;
      }
      sub_10005ACE8(&v80, 0xFFFFFFFF);
      uint64_t v30 = &v80;
      uint64_t v31 = 4;
      uint64_t v32 = 5243LL;
      goto LABEL_22;
    case 'U':
      uint64_t v41 = sub_100036D00(v82, &v80, (uint64_t)a2);
      uint64_t v29 = v41;
      if (v41 >= 0x100 && v41 - 262 >= 2 && v41 != 607)
      {
        if (!sub_1000545BC( (uint64_t *)&v81,  v82[0],  v80,  1LL,  1LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  5099LL,  v20)) {
          sub_100061FB4("No memory for %s", v74, v75, v24, v25, v26, v27, v28, (char)v82[0]);
        }
        goto LABEL_23;
      }

      if ((*a3)[1] == 111) {
        return 0LL;
      }
      uint64_t v33 = "expecting identifier.";
      goto LABEL_45;
    case 'V':
    case 'W':
    case 'Y':
    case '[':
    case '\\':
    case ']':
    case '^':
    case '_':
    case 'a':
    case 'c':
    case 'e':
      goto LABEL_36;
    case 'X':
LABEL_67:
      if (sub_1000374AC(v82, 0LL, a2) - 263 <= 1)
      {
        uint64_t result = (uint64_t)sub_1000343B4( &v81,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  5115LL,  v59,  v60,  v61,  v62,  v63);
        if (!(_DWORD)result) {
          return result;
        }
        if (sub_100049BDC((uint64_t)(v81 + 2), a2))
        {
          v81[1] = 14;
          goto LABEL_23;
        }

        sub_100054390( (uint64_t *)&v81,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  5118LL,  v24,  v25,  v26,  v27,  v28);
        return 0LL;
      }

      if (sub_100036D00(v82, &v80, (uint64_t)a2) == 262)
      {
        if (!sub_1000545BC( (uint64_t *)&v81,  v82[0],  v80,  1LL,  1LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  5128LL,  a8)) {
          sub_100061FB4("No memory for %s", v72, v73, v24, v25, v26, v27, v28, (char)v82[0]);
        }
        goto LABEL_23;
      }

      if ((*a3)[1] == 111) {
        return 0LL;
      }
      uint64_t v40 = "expecting string or hexadecimal data.";
      goto LABEL_37;
    case 'Z':
      if (sub_1000374AC(v82, 0LL, a2) != 59)
      {
        sub_100046D6C((uint64_t)a2, "semicolon expected.", v42, v43, v44, v45, v46, a8, v79);
        sub_100046C4C(a2, 0);
      }

      LOBYTE(v80) = 0;
      uint64_t v30 = &v80;
      uint64_t v31 = 0;
      uint64_t v32 = 5326LL;
      goto LABEL_22;
    case 'b':
LABEL_15:
      uint64_t v29 = sub_100036D00(v82, 0LL, (uint64_t)a2);
      sub_100047FD0(a2, &v80, (unsigned __int8 *)v82[0], 0LL, 8LL, v18, v19, v20);
      uint64_t v30 = &v80;
      uint64_t v31 = 1;
      uint64_t v32 = 5281LL;
      goto LABEL_22;
    case 'd':
      uint64_t v47 = sub_1000470FC(a2);
      v82[0] = v47;
      if (v47)
      {
        uint64_t v80 = strlen(v47);
        uint64_t v21 = 1;
        goto LABEL_7;
      }

      uint64_t v40 = "not a valid domain name.";
      goto LABEL_37;
    case 'f':
      uint64_t v48 = sub_100036D00(v82, 0LL, (uint64_t)a2);
      uint64_t v54 = v48;
      if (v48 >= 0x100 && v48 - 262 >= 2 && v48 != 607)
      {
        uint64_t v76 = v82[0];
        if (!strcasecmp(v82[0], "true") || !strcasecmp(v76, "on"))
        {
          BOOL v78 = 1;
        }

        else
        {
          if (!strcasecmp(v76, "false") || !strcasecmp(v76, "off"))
          {
            LOBYTE(v80) = 0;
            goto LABEL_107;
          }

          if (strcasecmp(v76, "ignore"))
          {
            if ((*a3)[1] == 111) {
              goto LABEL_60;
            }
            uint64_t v55 = "expecting BOOLean.";
            goto LABEL_59;
          }

          BOOL v78 = 2;
        }

        LOBYTE(v80) = v78;
LABEL_107:
        uint64_t v30 = &v80;
        uint64_t v31 = 1;
        uint64_t v32 = 5310LL;
        goto LABEL_22;
      }

      if ((*a3)[1] != 111)
      {
        uint64_t v55 = "expecting identifier.";
LABEL_59:
        sub_100046D6C((uint64_t)a2, v55, v49, v50, v51, v52, v53, a8, v79);
      }

LABEL_330:
        sub_100034894( &qword_10009D1E0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2384LL,  v11,  v12,  v13,  v14,  v15);
        uint64_t result = sub_1000347D8( &qword_10009D1E0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2385LL,  v286,  v287,  v288,  v289,  v290);
        uint64_t v16 = (void *)&unk_10009D000;
        if (!(_DWORD)result) {
          goto LABEL_269;
        }
        qword_10009D1C0 = 0LL;
        unsigned int v245 = 20;
        if (qword_10009D200)
        {
          uint64_t v280 = 2393LL;
LABEL_333:
          sub_10002D8B8( (void **)&qword_10009D200,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  v280,  v11,  v12,  v13,  v14,  v15);
        }

LABEL_334:
        uint64_t v260 = *(void *)(v260 + 8);
        if (!v260) {
          goto LABEL_339;
        }
      }

      uint64_t result = sub_10006221C( "reply_process_ia_ta: error evaluating IAADDR.",  v261,  v262,  v263,  v264,  v265,  v266,  v267,  v487);
      unsigned int v245 = 25;
      goto LABEL_270;
    }

    unsigned int v245 = 0;
    uint64_t v16 = (void *)&unk_10009D000;
LABEL_339:
    LODWORD(qword_10009D1B8) = qword_10009D1B8 + 1;
    if ((_DWORD)qword_10009D1C0) {
      goto LABEL_340;
    }
    uint64_t v306 = qword_10009D178;
    uint64_t v307 = *(uint64_t **)(qword_10009D178 + 80);
    if (!v307)
    {
      uint64_t result = sub_10006238C( "Unable to get client addresses: no IPv6 pools on this shared network",  v25,  v26,  v11,  v12,  v13,  v14,  v15,  v487);
      uint64_t v16 = (void *)&unk_10009D000;
      uint64_t v33 = (void *)&unk_10009D000;
      goto LABEL_374;
    }

    uint64_t result = *v307;
    if (!*v307)
    {
      unsigned int v245 = 13;
      goto LABEL_370;
    }

    unsigned int v245 = 13;
    uint64_t v308 = 8LL;
    while (1)
    {
      if (*(_WORD *)(result + 4) != 4) {
        goto LABEL_364;
      }
      unsigned int v309 = sub_10002E220( result,  &qword_10009D200,  (unsigned int *)&v505,  (uint64_t)&qword_10009D1A0,  xmmword_10008CE80 + 120,  v13,  v14,  v15);
      if (v309) {
        break;
      }
      uint64_t result = sub_10001FC78( (uint64_t *)(qword_10009D200 + 24),  *(void **)(*(void *)(*(void *)(qword_10009D200 + 64) + 80LL) + 128LL));
      if ((_DWORD)result
        || (LODWORD(v507[0]) = 16,
            *(_OWORD *)((char *)v507 + 4) = *(_OWORD *)(qword_10009D200 + 4),
            uint64_t result = sub_10001FFF8((uint64_t)v507),
            (_DWORD)result))
      {
        unsigned int v245 = result;
        goto LABEL_370;
      }

      if (qword_10009D200) {
        sub_10002D8B8( (void **)&qword_10009D200,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2678LL,  v11,  v12,  v13,  v14,  v15);
      }
      unsigned int v245 = 0;
LABEL_364:
      uint64_t result = *(void *)(*(void *)(v306 + 80) + v308);
      v308 += 8LL;
      if (!result) {
        goto LABEL_370;
      }
    }

    unsigned int v245 = v309;
    uint64_t result = sub_10006238C("Unable to get a temporary address.", v310, v311, v312, v313, v314, v315, v316, v487);
LABEL_370:
    uint64_t v33 = &unk_10009D000;
    if (qword_10009D200) {
      uint64_t result = sub_10002D8B8( (void **)&qword_10009D200,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2684LL,  v11,  v12,  v13,  v14,  v15);
    }
    uint64_t v16 = &unk_10009D000;
    if (!v245) {
      goto LABEL_340;
    }
    if (v245 != 13) {
      goto LABEL_273;
    }
LABEL_374:
    if ((*(unsigned __int8 *)(v16[51] + 20LL) | 2) != 3)
    {
      if (!HIDWORD(qword_10009D1C0))
      {
        unsigned int v245 = 13;
        goto LABEL_273;
      }

LABEL_379:
      unsigned int v245 = 0;
LABEL_340:
      dword_10009D22C += sub_1000425E0( (uint64_t)&qword_10009D178 + dword_10009D22C + 184,  (0x10000 - dword_10009D22C),  qword_10009D1E0,  (unsigned int *)qword_10009D198,  dword_10008264C,  0LL,  v14,  v15);
      uint64_t result = (uint64_t)sub_100060B78((_WORD *)v489 + 1, dword_10009D22C - v490 - 4);
      if (v245 != 20)
      {
        uint64_t v33 = (void *)&unk_10009D000;
        if (byte_10009D230[0] != 7) {
          goto LABEL_273;
        }
        uint64_t v11 = qword_10009D1D0;
        int v291 = *(_DWORD *)(qword_10009D1D0 + 36);
        if (!v291) {
          goto LABEL_273;
        }
        if (v291 >= 1)
        {
          uint64_t v292 = 0LL;
          do
          {
            uint64_t v293 = *(uint64_t **)(*(void *)(v11 + 56) + 8 * v292);
            uint64_t v294 = (void **)(v293 + 7);
            if (v293[7])
            {
              sub_10002D71C( v294,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2487LL,  v11,  v12,  v13,  v14,  v15);
              uint64_t v11 = qword_10009D1D0;
            }

            sub_10002D6B4( v294,  (_DWORD *)v11,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2488LL,  v12,  v13,  v14,  v15);
            v293[4] = v293[5];
            v293[5] = 0LL;
            sub_10002E9FC(v293[8], (uint64_t)v293);
            sub_10002F2A0((uint64_t **)v293[8]);
            uint64_t v300 = sub_100040D4C(&qword_10008BF80, qword_10009D190, 30LL, v295, v296, v297, v298, v299);
            if (!v300
              || sub_100057AF8( 0LL,  (unsigned int *)qword_10009D198,  0LL,  0LL,  *(void *)(qword_10009D198 + 160),  qword_10009D190,  v293 + 3,  v300,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  0x9CCu))
            {
              sub_10000E340(qword_10009D198, 0LL, 0LL, (uint64_t)v293, 0LL, qword_10009D190, v14, v15);
            }

            ++v292;
            uint64_t v11 = qword_10009D1D0;
          }

          while (v292 < *(int *)(qword_10009D1D0 + 36));
        }

        if (qword_10009D1D8)
        {
          sub_100029210( qword_10008BE70,  *(const char **)(qword_10009D1D8 + 16),  *(unsigned int *)(qword_10009D1D8 + 24),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2519LL,  v13,  v14,  v15);
          sub_10002D71C( (void **)&qword_10009D1D8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2520LL,  v301,  v302,  v303,  v304,  v305);
          uint64_t v11 = qword_10009D1D0;
        }

        *(void *)(v11 + 48) = xmmword_10008CE80;
        sub_100029214( qword_10008BE70,  *(const char **)(v11 + 16),  *(unsigned int *)(v11 + 24),  v11,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2527LL,  v14,  v15,  v487);
        uint64_t result = sub_10000D7B4(qword_10009D1D0);
        goto LABEL_337;
      }

LABEL_270:
      uint64_t v33 = (void *)&unk_10009D000;
      goto LABEL_273;
    }

    sub_100034894( &qword_10009D1E0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2422LL,  v11,  v12,  v13,  v14,  v15);
    if (!sub_1000347D8( &qword_10009D1E0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2423LL,  v317,  v318,  v319,  v320,  v321))
    {
      uint64_t result = sub_10006221C( "reply_process_ia_ta: No memory for option state wipe.",  v322,  v323,  v324,  v325,  v326,  v327,  v328,  v487);
      unsigned int v245 = 1;
      goto LABEL_273;
    }

    uint64_t v246 = "reply_process_ia_ta: Unable to set NoAddrsAvail status code.";
LABEL_272:
    uint64_t result = sub_10006221C(v246, v229, v230, v231, v232, v233, v14, v15, v487);
    unsigned int v245 = 25;
LABEL_273:
    if (v498) {
      uint64_t result = sub_100034894( &v498,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2534LL,  v11,  v12,  v13,  v14,  v15);
    }
    if (v500) {
      uint64_t result = (uint64_t)sub_100034EA8( &v499,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2536LL,  v11,  v12,  v13,  v14,  v15);
    }
    if (qword_10009D1E0) {
      uint64_t result = sub_100034894( &qword_10009D1E0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2538LL,  v11,  v12,  v13,  v14,  v15);
    }
    if (*(void *)&v510[8]) {
      uint64_t result = (uint64_t)sub_100034EA8( (_DWORD **)v510,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2540LL,  v11,  v12,  v13,  v14,  v15);
    }
    if (*(void *)&v508[8]) {
      uint64_t result = (uint64_t)sub_100034EA8( (_DWORD **)v508,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2542LL,  v11,  v12,  v13,  v14,  v15);
    }
    if (qword_10009D1D0) {
      uint64_t result = sub_10002D71C( (void **)&qword_10009D1D0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2544LL,  v11,  v12,  v13,  v14,  v15);
    }
    if (qword_10009D1D8) {
      uint64_t result = sub_10002D71C( (void **)&qword_10009D1D8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2546LL,  v11,  v12,  v13,  v14,  v15);
    }
    if (v33[64]) {
      uint64_t result = sub_10002D8B8( (void **)&qword_10009D200,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2548LL,  v11,  v12,  v13,  v14,  v15);
    }
    if (v245 > 0x14 || ((1 << v245) & 0x102001) == 0) {
      goto LABEL_589;
    }
    if (!(_DWORD)qword_10009D1C0) {
      int v35 = 1;
    }
    uint64_t v228 = *(void *)(v228 + 8);
    uint64_t v247 = "No registered trace type for type name %.*s" + 3;
  }

  while (v228);
LABEL_385:
  HIDWORD(qword_10009D1B8) = 0;
  uint64_t result = sub_100040D4C(&qword_10008C1F8, *(void *)(a2 + 160), 25LL, v11, v12, v13, v14, v15);
  if (!result)
  {
LABEL_577:
    if (!qword_10009D1B8)
    {
      uint64_t v472 = v16[51];
      if (*(_BYTE *)(v472 + 20) != 11) {
        goto LABEL_589;
      }
      sub_10003E0AC( 0LL,  (int *)v472,  0LL,  0LL,  *(void *)(v472 + 160),  qword_10009D190,  &qword_10008C730,  *(void *)(qword_10009D178 + 96),  (void *)qword_10008C140);
      if (qword_10009D180) {
        sub_10003E0AC( 0LL,  (int *)qword_10009D198,  0LL,  0LL,  *(void *)(qword_10009D198 + 160),  qword_10009D190,  &qword_10008C730,  *(void *)(qword_10009D180 + 152),  *(void **)(qword_10009D178 + 96));
      }
    }

    if (v35 && (_DWORD)qword_10009D1B8)
    {
      uint64_t v473 = v16[51];
      uint64_t v474 = a1;
      if (*(_BYTE *)(v473 + 20) == 1)
      {
        if (!sub_10001F94C(2u, "No addresses available for this interface.", qword_10009D190))
        {
          uint64_t v329 = "lease_to_client: Unable to set NoAddrsAvail status code.";
          goto LABEL_588;
        }

        dword_10009D22C = 4;
        byte_10009D230[0] = 2;
LABEL_605:
        uint64_t v475 = qword_10009D190;
        uint64_t v473 = qword_10009D198;
        uint64_t v476 = (char *)&unk_10009D234;
        uint64_t v477 = (unsigned int *)&unk_100082614;
        uint64_t v478 = 65532LL;
        uint64_t v479 = 0LL;
LABEL_608:
        dword_10009D22C += sub_1000425E0((uint64_t)v476, v478, v475, (unsigned int *)v473, v477, (uint64_t)v479, v14, v15);
        *(_DWORD *)(v474 + 16) = dword_10009D22C;
        *(void *)uint64_t v474 = 0LL;
        if (!sub_1000345C4( (void *)v474,  dword_10009D22C,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  1502LL)) {
          sub_100061FB4("No memory to store Reply.", v480, v481, v482, v483, v484, v485, v486, v487);
        }
        uint64_t result = (uint64_t)memcpy((void *)(*(void *)v474 + 4LL), byte_10009D230, dword_10009D22C);
        *(void *)(v474 + 8) = *(void *)v474 + 4LL;
        goto LABEL_589;
      }
    }

    else
    {
      uint64_t v473 = v16[51];
      if (v35)
      {
        uint64_t v474 = a1;
        if (!(_DWORD)qword_10009D1B8 && *(_BYTE *)(v473 + 20) == 1)
        {
          if (!sub_10001F94C(6u, "No prefixes available for this interface.", qword_10009D190))
          {
            uint64_t v329 = "lease_to_client: Unable to set NoPrefixAvail status code.";
            goto LABEL_588;
          }

          dword_10009D22C = 4;
          byte_10009D230[0] = 2;
          goto LABEL_605;
        }
      }

      else
      {
        uint64_t v474 = a1;
      }
    }

    uint64_t v476 = (char *)&qword_10009D178 + dword_10009D22C + 184;
    uint64_t v478 = (0x10000 - dword_10009D22C);
    uint64_t v475 = qword_10009D190;
    uint64_t v477 = (unsigned int *)&unk_100082624;
    uint64_t v479 = v497;
    goto LABEL_608;
  }

  uint64_t v330 = result;
  __int128 v491 = *((_OWORD *)v247 + 105);
  while (1)
  {
    qword_10009D1C0 = 0LL;
    uint64_t v498 = 0LL;
    uint64_t v506 = 0LL;
    __int128 v505 = 0uLL;
    memset(v504, 0, 24);
    if (!sub_10001FA3C(&v498, &v505, v16[51], v330, 0xCu))
    {
      uint64_t result = sub_10006221C("reply_process_ia_pd: error evaluating ia", v331, v332, v333, v334, v335, v336, v337, v487);
      unsigned int v349 = 25;
      goto LABEL_393;
    }

    uint64_t v338 = sub_100060B50(*((unsigned int **)&v505 + 1));
    LODWORD(qword_10009D208) = sub_100060B50((unsigned int *)(*((void *)&v505 + 1) + 4LL));
    HIDWORD(qword_10009D208) = sub_100060B50((unsigned int *)(*((void *)&v505 + 1) + 8LL));
    uint64_t v348 = (void *)&unk_10009D000;
    if (sub_10002DBB4( &qword_10009D1D0,  v338,  (const void *)qword_10009D1A8,  dword_10009D1B0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3137LL,  v339,  v340))
    {
      uint64_t result = sub_10006221C("reply_process_ia_pd: no memory for ia.", v341, v342, v343, v344, v345, v346, v347, v487);
      unsigned int v349 = 1;
LABEL_391:
      uint64_t v33 = (void *)&unk_10009D000;
      goto LABEL_394;
    }

    uint64_t v350 = qword_10009D1D0;
    *(_WORD *)(qword_10009D1D0 + 32) = 25;
    sub_100029804( &qword_10009D1D8,  qword_10008BE68,  *(void *)(v350 + 16),  *(unsigned int *)(v350 + 24),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3147LL);
    uint64_t result = sub_1000347D8( &qword_10009D1E0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3153LL,  v351,  v352,  v353,  v354,  v355);
    if (!(_DWORD)result)
    {
      unsigned int v349 = 1;
      uint64_t v16 = (void *)&unk_10009D000;
      goto LABEL_391;
    }

    dword_10009D1CC = 0;
    if (qword_10009D180)
    {
      uint64_t v356 = *(void **)(qword_10009D180 + 144);
      if (v356)
      {
        int v357 = 0;
        do
        {
          ++v357;
          uint64_t v356 = (void *)*v356;
        }

        while (v356);
        dword_10009D1CC = v357;
      }
    }

    int v493 = dword_10009D22C;
    uint64_t v496 = &byte_10009D230[dword_10009D22C];
    sub_100060B78(v496, 0x19u);
    dword_10009D22C += 2;
    sub_100060B78(&byte_10009D230[dword_10009D22C], 0xCu);
    dword_10009D22C += 2;
    sub_100060B6C(&byte_10009D230[dword_10009D22C], v338);
    dword_10009D22C += 4;
    sub_100060B6C(&byte_10009D230[dword_10009D22C], qword_10009D208);
    dword_10009D22C += 4;
    sub_100060B6C(&byte_10009D230[dword_10009D22C], HIDWORD(qword_10009D208));
    dword_10009D22C += 4;
    uint64_t result = sub_100040D4C(&qword_10008C1F8, v498, 26LL, v358, v359, v360, v361, v362);
    *(_OWORD *)&dword_10009D210 = v491;
    dword_10009D228 = -1;
    if (result)
    {
      uint64_t v363 = result;
      uint64_t v16 = &unk_10009D000;
      uint64_t v33 = (void *)&unk_10009D000;
      while (1)
      {
        uint64_t v500 = 0LL;
        uint64_t v501 = 0LL;
        uint64_t v499 = 0LL;
        memset(v507, 0, sizeof(v507));
        if ((dword_10009D22C - 65508) <= 0xFFFEFFFE)
        {
          uint64_t result = sub_10006221C( "reply_process_prefix: Out of room for prefix.",  v25,  v26,  v11,  v12,  v13,  v14,  v15,  v487);
          unsigned int v349 = 19;
          goto LABEL_393;
        }

        if (sub_100057AA4( &v499,  (unsigned int *)v16[51],  0LL,  0LL,  *(void *)(v16[51] + 160LL),  0LL,  &qword_10008C730,  v363,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  0xD6Du)) {
          BOOL v364 = v501 > 0x18;
        }
        else {
          BOOL v364 = 0;
        }
        if (!v364)
        {
          int v365 = "reply_process_prefix: error evaluating IAPREFIX.";
LABEL_428:
          uint64_t result = sub_10006221C(v365, v25, v26, v11, v12, v13, v14, v15, v487);
          unsigned int v349 = 25;
          goto LABEL_524;
        }

        unsigned int v366 = sub_100060B50(v500);
        uint64_t result = sub_100060B50(v500 + 1);
        if (dword_10009D21C - 1 >= v366) {
          dword_10009D21C = v366;
        }
        *(_DWORD *)uint64_t v508 = 16;
        *(_OWORD *)&v508[4] = 0uLL;
        int v367 = *((unsigned __int8 *)v500 + 8);
        if (!*((_BYTE *)v500 + 8)
          && *(void *)((char *)v500 + 9) == *(void *)&v508[4]
          && *(void *)((char *)v500 + 17) == *(void *)&v508[12])
        {
          goto LABEL_453;
        }

        *(_DWORD *)&v508[20] = *((unsigned __int8 *)v500 + 8);
        if (dword_10009D228 < 0) {
          dword_10009D228 = v367;
        }
        if (*(void *)((char *)v500 + 9) == *(void *)&v508[4]
          && *(void *)((char *)v500 + 17) == *(void *)&v508[12])
        {
LABEL_453:
          unsigned int v349 = 0;
LABEL_523:
          uint64_t v16 = (void *)&unk_10009D000;
          goto LABEL_524;
        }

        *(_OWORD *)&v508[4] = *(_OWORD *)((char *)v500 + 9);
        if (dword_10009D1CC)
        {
          unint64_t v370 = *(uint64_t **)(qword_10009D180 + 144);
          uint64_t v371 = (void *)&unk_10009D000;
          if (!v370) {
            goto LABEL_463;
          }
          while (*((_DWORD *)v370 + 7) != v367
               || *(void *)&v508[4] != *(uint64_t *)((char *)v370 + 12)
               || *(void *)&v508[12] != *(uint64_t *)((char *)v370 + 20))
          {
            unint64_t v370 = (uint64_t *)*v370;
            if (!v370) {
              goto LABEL_463;
            }
          }
        }

        else
        {
          uint64_t v371 = &unk_10009D000;
          if (!qword_10009D1D8 || (uint64_t v373 = *(unsigned int *)(qword_10009D1D8 + 36), (int)v373 < 1))
          {
LABEL_463:
            switch(*(_BYTE *)(qword_10009D198 + 20))
            {
              case 1:
              case 3:
              case 6:
                if (!qword_10009D178
                  || (*(void *)(qword_10009D178 + 80) ? (BOOL v376 = v371[64] == 0LL) : (BOOL v376 = 0), !v376))
                {
                  unsigned int v349 = 39;
                  goto LABEL_523;
                }

                *(void *)&v510[8] = 0LL;
                *(void *)&v510[16] = 17LL;
                *(void *)uint64_t v510 = 0LL;
                if (!sub_1000345C4( v510,  17,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3687LL))
                {
                  uint64_t v400 = "reply_process_try_prefix: out of memory.";
                  goto LABEL_500;
                }

                *(void *)&v510[8] = *(void *)v510 + 4LL;
                *(_BYTE *)(*(void *)v510 + 4LL) = v367;
                *(_OWORD *)(*(void *)v510 + 5LL) = *(_OWORD *)&v508[4];
                uint64_t v389 = qword_10009D178;
                uint64_t v390 = **(void **)(qword_10009D178 + 80);
                if (!v390)
                {
                  uint64_t result = (uint64_t)sub_100034EA8( (_DWORD **)v510,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3704LL,  v384,  v385,  v386,  v387,  v388);
                  unsigned int v349 = 13;
                  goto LABEL_523;
                }

                unsigned int v349 = 13;
                uint64_t v391 = 8LL;
                break;
              case 5:
                sub_100034894( &qword_10009D1E0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3524LL,  v11,  v12,  v13,  v14,  v15);
                if (!sub_1000347D8( &qword_10009D1E0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3525LL,  v377,  v378,  v379,  v380,  v381))
                {
                  uint64_t v400 = "reply_process_prefix: No memory for option state wipe.";
LABEL_500:
                  uint64_t result = sub_10006221C(v400, v382, v383, v384, v385, v386, v387, v388, v487);
                  unsigned int v349 = 1;
                  goto LABEL_523;
                }

                uint64_t result = sub_10001F94C(3u, "Prefix not bound to this interface.", qword_10009D1E0);
                uint64_t v16 = (void *)&unk_10009D000;
                if ((_DWORD)result)
                {
                  unsigned int v349 = 20;
                  goto LABEL_524;
                }

                int v365 = "reply_process_prefix: Unable to attach status code.";
                goto LABEL_428;
              default:
                uint64_t result = sub_10006221C( "It is impossible to lease a client that is not sending a solicit, request, renew, or rebind message.",  v25,  v26,  v11,  v12,  v13,  v14,  v15,  v487);
                unsigned int v349 = 25;
                goto LABEL_523;
            }

            do
            {
              if (*(_WORD *)(v390 + 4) == 25)
              {
                if (*(_DWORD *)&v510[16] >= 0x11u)
                {
                  unsigned int v392 = **(_BYTE **)&v510[8];
                  if ((v392 + 127) >= 0x82u
                    && (int32x4_t v502 = *(int32x4_t *)(*(void *)&v510[8] + 1LL),
                        (vmaxv_u16((uint16x4_t)vmovn_s32(vtstq_s32(v502, v502))) & 1) != 0)
                    && (*(_DWORD *)uint64_t v509 = 16, *(int32x4_t *)&v509[4] = v502, sub_10003FD5C(v509, v392))
                    && *(_DWORD *)(v390 + 28) == v392
                    && sub_10002F674((__int128 *)v502.i8, v390, v393, v384, v385, v386, v387, v388))
                  {
                    if (sub_10002F0F4(v390, v502.i8, v392, v384, v385, v386, v387, v388))
                    {
                      unsigned int v349 = 5;
                    }

                    else
                    {
                      unsigned int v349 = sub_10002D9A0( &qword_10009D200,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  1116LL,  v384,  v385,  v386,  v387,  v388);
                      if (!v349)
                      {
                        *(int32x4_t *)(qword_10009D200 + 4) = v502;
                        uint64_t v394 = qword_10009D200;
                        *(_BYTE *)(qword_10009D200 + 20) = v392;
                        unsigned int v349 = sub_10002E7BC(v390, v394, xmmword_10008CE80 + 120, v384, v385, v386, v387, v388);
                        if (!v349)
                        {
                          uint64_t result = (uint64_t)sub_100034EA8( (_DWORD **)v510,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3704LL,  v395,  v396,  v397,  v398,  v399);
                          uint64_t v16 = (void *)&unk_10009D000;
                          goto LABEL_496;
                        }

                        sub_10002D8B8( (void **)&qword_10009D200,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  1126LL,  v395,  v396,  v397,  v398,  v399);
                      }
                    }
                  }

                  else
                  {
                    unsigned int v349 = 25;
                  }
                }

                else
                {
                  unsigned int v349 = 39;
                }

                uint64_t v389 = qword_10009D178;
              }

              uint64_t v390 = *(void *)(*(void *)(v389 + 80) + v391);
              v391 += 8LL;
            }

            while (v390);
            uint64_t result = (uint64_t)sub_100034EA8( (_DWORD **)v510,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3704LL,  v384,  v385,  v386,  v387,  v388);
            uint64_t v16 = &unk_10009D000;
            if (v349 != 5) {
              goto LABEL_524;
            }
LABEL_496:
            uint64_t v371 = &unk_10009D000;
            if (qword_10009D200) {
              goto LABEL_503;
            }
            if (*(_BYTE *)(v16[51] + 20LL) == 6)
            {
              qword_10009D220 = 0LL;
              goto LABEL_520;
            }

            goto LABEL_524;
          }

          uint64_t v374 = *(uint64_t **)(qword_10009D1D8 + 56);
          while (1)
          {
            uint64_t v25 = *v374;
            if (v367 == *(unsigned __int8 *)(*v374 + 20)
              && *(void *)&v508[4] == *(void *)(v25 + 4)
              && *(void *)&v508[12] == *(void *)(v25 + 12))
            {
              break;
            }

            ++v374;
            if (!--v373) {
              goto LABEL_463;
            }
          }

          sub_10002D850( &qword_10009D200,  (_DWORD *)v25,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3660LL,  v12,  v13,  v14,  v15);
        }

        unsigned int v349 = 0;
        uint64_t v16 = (void *)&unk_10009D000;
LABEL_503:
        if (dword_10009D1CC)
        {
          uint64_t v401 = &qword_10008C730;
          if (!qword_10009D180) {
            sub_100061FB4( "Impossible condition at %s:%d.",  v25,  v26,  v11,  v12,  v13,  v14,  v15,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c");
          }
        }

        else
        {
          uint64_t v402 = v371[64];
          if (!v402) {
            sub_100061FB4( "Impossible condition at %s:%d.",  v25,  v26,  v11,  v12,  v13,  v14,  v15,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c");
          }
          uint64_t v401 = (uint64_t *)(v402 + 24);
        }

        if (!(_DWORD)qword_10009D1C0) {
          goto LABEL_519;
        }
        uint64_t result = sub_100040D4C(&qword_10008BF80, qword_10009D190, 57LL, v11, v12, v13, v14, v15);
        if (result)
        {
          if (sub_100057AA4( v507,  (unsigned int *)qword_10009D198,  0LL,  0LL,  *(void *)(qword_10009D198 + 160),  qword_10009D190,  v401,  result,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  0xE03u)) {
            BOOL v403 = LODWORD(v507[2]) == 4;
          }
          else {
            BOOL v403 = 0;
          }
          if (!v403)
          {
            int v365 = "reply_process_prefix: unable to evaluate prefs-per-ia value.";
            goto LABEL_428;
          }

          unsigned int v404 = sub_100060B50(v507[1]);
          uint64_t result = (uint64_t)sub_100034EA8( v507,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3596LL,  v405,  v406,  v407,  v408,  v409);
        }

        else
        {
          unsigned int v404 = 1;
        }

        BOOL v111 = qword_10009D1C0 >= v404;
        uint64_t v16 = (void *)&unk_10009D000;
        if (!v111)
        {
LABEL_519:
          uint64_t result = sub_10002051C(v401, *(void **)(qword_10009D178 + 96));
          unsigned int v349 = result;
          if (!(_DWORD)result)
          {
LABEL_520:
            uint64_t result = sub_10002089C((uint64_t)v508);
            unsigned int v349 = result;
          }
        }

LABEL_524:
        if (v500) {
          uint64_t result = (uint64_t)sub_100034EA8( &v499,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3616LL,  v11,  v12,  v13,  v14,  v15);
        }
        uint64_t v33 = &unk_10009D000;
        if (v507[1]) {
          uint64_t result = (uint64_t)sub_100034EA8( v507,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3618LL,  v11,  v12,  v13,  v14,  v15);
        }
        if (qword_10009D200) {
          uint64_t result = sub_10002D8B8( (void **)&qword_10009D200,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3620LL,  v11,  v12,  v13,  v14,  v15);
        }
        if (v349 && v349 != 5)
        {
          if (v349 == 20)
          {
            ++HIDWORD(qword_10009D1B8);
            goto LABEL_549;
          }

LABEL_393:
          uint64_t v348 = &unk_10009D000;
          goto LABEL_394;
        }

        uint64_t v363 = *(void *)(v363 + 8);
        if (!v363) {
          goto LABEL_537;
        }
      }
    }

    unsigned int v349 = 0;
    uint64_t v16 = &unk_10009D000;
    uint64_t v33 = (void *)&unk_10009D000;
LABEL_537:
    ++HIDWORD(qword_10009D1B8);
    if (!(_DWORD)qword_10009D1C0)
    {
      uint64_t result = sub_100020104(result, v25, v26, v11, v12, v13, v14, v15);
      unsigned int v349 = result;
      if ((_DWORD)result)
      {
        uint64_t v348 = (void *)&unk_10009D000;
        if ((_DWORD)result != 13) {
          goto LABEL_394;
        }
        if ((*(unsigned __int8 *)(v16[51] + 20LL) | 2) == 3)
        {
          sub_100034894( &qword_10009D1E0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3240LL,  v11,  v12,  v13,  v14,  v15);
          if (!sub_1000347D8( &qword_10009D1E0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3242LL,  v410,  v411,  v412,  v413,  v414))
          {
            uint64_t result = sub_10006221C( "reply_process_ia_pd: No memory for option state wipe.",  v415,  v416,  v417,  v418,  v419,  v420,  v421,  v487);
            unsigned int v349 = 1;
            goto LABEL_394;
          }

          if (!sub_10001F94C(6u, "No prefixes available for this interface.", qword_10009D1E0))
          {
            uint64_t result = sub_10006221C( "reply_process_ia_pd: Unable to set NoPrefixAvail status code.",  v422,  v423,  v424,  v425,  v426,  v14,  v15,  v487);
            unsigned int v349 = 25;
            goto LABEL_394;
          }
        }

        else if (!HIDWORD(qword_10009D1C0))
        {
          unsigned int v349 = 13;
          goto LABEL_394;
        }

        unsigned int v349 = 0;
      }
    }

LABEL_549:
    dword_10009D22C += sub_1000425E0( (uint64_t)&qword_10009D178 + dword_10009D22C + 184,  (0x10000 - dword_10009D22C),  qword_10009D1E0,  (unsigned int *)qword_10009D198,  dword_100082658,  0LL,  v14,  v15);
    sub_100060B78((_WORD *)v496 + 1, dword_10009D22C - v493 - 4);
    LODWORD(qword_10009D208) = 0;
    uint64_t v432 = sub_100040D4C(&qword_10008C168, qword_10009D190, 58LL, v427, v428, v429, v430, v431);
    if (v432)
    {
      if (sub_100057AA4( v504,  (unsigned int *)qword_10009D198,  0LL,  0LL,  *(void *)(qword_10009D198 + 160),  qword_10009D190,  &qword_10008C730,  v432,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  0xCE5u)
        && LODWORD(v504[1]) == 4)
      {
        LODWORD(qword_10009D208) = sub_100060B50(*((unsigned int **)&v504[0] + 1));
      }

      else
      {
        sub_10006221C("Invalid renewal time.", v433, v434, v435, v436, v437, v438, v439, v487);
      }

      if (*((void *)&v504[0] + 1)) {
        sub_100034EA8( (_DWORD **)v504,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3309LL,  v440,  v441,  v442,  v443,  v444);
      }
    }

    sub_100060B6C((_DWORD *)v496 + 2, qword_10009D208);
    HIDWORD(qword_10009D208) = 0;
    uint64_t v450 = sub_100040D4C(&qword_10008C168, qword_10009D190, 59LL, v445, v446, v447, v448, v449);
    uint64_t v348 = &unk_10009D000;
    uint64_t v33 = (void *)&unk_10009D000;
    if (v450)
    {
      if (sub_100057AA4( v504,  (unsigned int *)qword_10009D198,  0LL,  0LL,  *(void *)(qword_10009D198 + 160),  qword_10009D190,  &qword_10008C730,  v450,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  0xCF9u)
        && LODWORD(v504[1]) == 4)
      {
        HIDWORD(qword_10009D208) = sub_100060B50(*((unsigned int **)&v504[0] + 1));
      }

      else
      {
        sub_10006221C("Invalid rebinding time.", v451, v452, v453, v454, v455, v456, v457, v487);
      }

      if (*((void *)&v504[0] + 1)) {
        sub_100034EA8( (_DWORD **)v504,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3329LL,  v458,  v459,  v460,  v461,  v462);
      }
    }

    uint64_t result = (uint64_t)sub_100060B6C((_DWORD *)v496 + 3, HIDWORD(qword_10009D208));
    if (v349 != 20 && !dword_10009D1CC && byte_10009D230[0] == 7)
    {
      uint64_t v11 = qword_10009D1D0;
      int v463 = *(_DWORD *)(qword_10009D1D0 + 36);
      if (v463)
      {
        if (v463 >= 1)
        {
          uint64_t v464 = 0LL;
          do
          {
            uint64_t v465 = *(void **)(*(void *)(v11 + 56) + 8 * v464);
            uint64_t v466 = (void **)(v465 + 7);
            if (v465[7])
            {
              sub_10002D71C( v466,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3352LL,  v11,  v12,  v13,  v14,  v15);
              uint64_t v11 = qword_10009D1D0;
            }

            sub_10002D6B4( v466,  (_DWORD *)v11,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3353LL,  v12,  v13,  v14,  v15);
            v465[4] = v465[5];
            v465[5] = 0LL;
            sub_10002E9FC(v465[8], (uint64_t)v465);
            sub_10002F2A0((uint64_t **)v465[8]);
            ++v464;
            uint64_t v11 = qword_10009D1D0;
          }

          while (v464 < *(int *)(qword_10009D1D0 + 36));
        }

        if (qword_10009D1D8)
        {
          sub_100029210( qword_10008BE68,  *(const char **)(qword_10009D1D8 + 16),  *(unsigned int *)(qword_10009D1D8 + 24),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3368LL,  v13,  v14,  v15);
          sub_10002D71C( (void **)&qword_10009D1D8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3369LL,  v467,  v468,  v469,  v470,  v471);
          uint64_t v11 = qword_10009D1D0;
        }

        *(void *)(v11 + 48) = xmmword_10008CE80;
        sub_100029214( qword_10008BE68,  *(const char **)(v11 + 16),  *(unsigned int *)(v11 + 24),  v11,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3376LL,  v14,  v15,  v487);
        uint64_t result = sub_10000D7B4(qword_10009D1D0);
        uint64_t v16 = (void *)&unk_10009D000;
        goto LABEL_391;
      }
    }

LABEL_394:
    if (v498) {
      uint64_t result = sub_100034894( &v498,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3383LL,  v11,  v12,  v13,  v14,  v15);
    }
    if (qword_10009D1E0) {
      uint64_t result = sub_100034894( &qword_10009D1E0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3385LL,  v11,  v12,  v13,  v14,  v15);
    }
    if (*((void *)&v505 + 1)) {
      uint64_t result = (uint64_t)sub_100034EA8( (_DWORD **)&v505,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3387LL,  v11,  v12,  v13,  v14,  v15);
    }
    if (*((void *)&v504[0] + 1)) {
      uint64_t result = (uint64_t)sub_100034EA8( (_DWORD **)v504,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3389LL,  v11,  v12,  v13,  v14,  v15);
    }
    if (v348[58]) {
      uint64_t result = sub_10002D71C( (void **)&qword_10009D1D0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3391LL,  v11,  v12,  v13,  v14,  v15);
    }
    if (qword_10009D1D8) {
      uint64_t result = sub_10002D71C( (void **)&qword_10009D1D8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3393LL,  v11,  v12,  v13,  v14,  v15);
    }
    if (v33[64]) {
      uint64_t result = sub_10002D8B8( (void **)&qword_10009D200,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3395LL,  v11,  v12,  v13,  v14,  v15);
    }
    if (v349 > 0x14 || ((1 << v349) & 0x102001) == 0) {
      goto LABEL_589;
    }
    if (!(_DWORD)qword_10009D1C0) {
      int v35 = 1;
    }
    uint64_t v330 = *(void *)(v330 + 8);
    if (!v330) {
      goto LABEL_577;
    }
  }

  uint64_t v329 = "reply_process_ia_pd: Reply too long for IA.";
LABEL_588:
  uint64_t result = sub_10006221C(v329, v25, v26, v11, v12, v13, v14, v15, v487);
LABEL_589:
  if (qword_10009D178) {
    uint64_t result = sub_1000235C8(&qword_10009D178, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c", 1511LL);
  }
  if (qword_10009D180) {
    uint64_t result = sub_100033924( (_DWORD **)&qword_10009D180,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  1513LL);
  }
  if (qword_10009D190) {
    uint64_t result = sub_100034894( &qword_10009D190,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  1515LL,  v11,  v12,  v13,  v14,  v15);
  }
  if (v16[51]) {
    uint64_t result = sub_100034B48( &qword_10009D198,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  1517LL,  v11,  v12,  v13,  v14,  v15);
  }
  if (qword_10009D1A8) {
    uint64_t result = (uint64_t)sub_100034EA8( &qword_10009D1A0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  1519LL,  v11,  v12,  v13,  v14,  v15);
  }
  dword_10009D22C = 0;
  qword_10009D208 = 0LL;
  *(void *)&dword_10009D210 = 0LL;
  return result;
}

uint64_t sub_10001F36C( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 39LL;
  }
  uint64_t v9 = 39LL;
  if (!a2 || *a1) {
    return v9;
  }
  for (uint64_t i = *(void *)(a2 + 64); i; uint64_t i = *(void *)(i + 64))
  {
    if (*(_DWORD *)(i + 28))
    {
      if ((*(_DWORD *)(i + 28) & 0xC0FF) != 0x80FE) {
        goto LABEL_15;
      }
    }

    else if (*(_DWORD *)(i + 32) || *(_DWORD *)(i + 36) || *(_DWORD *)(i + 40))
    {
LABEL_15:
      __int128 v20 = *(_OWORD *)(i + 28);
      uint64_t v38 = 0LL;
      int v39 = 16;
      __int128 v40 = *(_OWORD *)(i + 28);
      __int128 v41 = v20;
      if (sub_10002A994( (uint64_t)&v38,  (__int128 *)&v39,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4186LL,  a5,  a6,  a7,  a8))
      {
        uint64_t v9 = sub_1000235CC( a1,  *(void *)(v38 + 48),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4192LL);
        sub_1000235C8(&v38, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c", 4193LL);
      }

      else
      {
        int v39 = 16;
        __int128 v40 = v41;
        char v29 = sub_100040144(&v39, v21, v22, v23, v24, v25, v26, v27);
        sub_10006238C("No subnet found for link-address %s.", v30, v31, v32, v33, v34, v35, v36, v29);
        return 23LL;
      }

      return v9;
    }
  }

  uint64_t v12 = *(void *)(a2 + 104);
  if (!v12)
  {
    sub_10006221C("No interface and no link address can't determine pool", a2, a3, a4, a5, a6, a7, a8, v37);
    return 39LL;
  }

  uint64_t v9 = sub_1000235CC(a1, *(void *)(v12 + 40), "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c", 4202LL);
  if (*(void *)(a2 + 64)) {
    sub_1000622D4( "[L2 Relay] No link address in relay packet assuming L2 relay and using receiving interface",  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v37);
  }
  return v9;
}

uint64_t sub_10001F50C( uint64_t a1, uint64_t a2, _DWORD **a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *a4 = 0LL;
  if (!sub_1000347D8( a4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  815LL,  (uint64_t)a4,  a5,  a6,  a7,  a8))
  {
    uint64_t v30 = "start_reply: no memory for option_state.";
LABEL_20:
    sub_10006221C(v30, v13, v14, v15, v16, v17, v18, v19, v47);
    return 0LL;
  }

  sub_10003E0AC(0LL, (int *)a1, 0LL, 0LL, *(void *)(a1 + 160), *a4, &qword_10008C730, qword_10008C140, 0LL);
  if (*(_BYTE *)(a1 + 20) != 1)
  {
    *(_BYTE *)a5 = 7;
    if (!sub_100040D4C(&qword_10008C1F8, *a4, 14LL, v20, v21, v22, v23, v24)) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }

  *(_BYTE *)a5 = 2;
  if (sub_100040D4C(&qword_10008C1F8, *a4, 14LL, v20, v21, v22, v23, v24))
  {
    if (sub_100040D4C(&qword_10008C1F8, *(void *)(a1 + 160), 14LL, v25, v26, v27, v28, v29))
    {
      *(_BYTE *)a5 = 7;
      goto LABEL_9;
    }

uint64_t sub_10001F748(uint64_t a1)
{
  uint64_t v22 = 0LL;
  sub_100033920(&v22, qword_10009D180);
  uint64_t result = sub_100033924( (_DWORD **)&qword_10009D180,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5895LL);
  uint64_t v3 = v22;
  if (!v22)
  {
    uint64_t v4 = 0LL;
    char v20 = 1;
    goto LABEL_17;
  }

  uint64_t result = 0LL;
  while (1)
  {
    uint64_t v4 = result;
    uint64_t v5 = *(void *)(v3 + 136);
    uint64_t result = v3;
    if (v5) {
      break;
    }
LABEL_13:
    uint64_t v3 = *(void *)(v3 + 32);
    if (!v3)
    {
      char v20 = 1;
      uint64_t v4 = result;
      goto LABEL_17;
    }
  }

  uint64_t v24 = 0LL;
  uint64_t v25 = 0LL;
  uint64_t v23 = 0LL;
  if (!sub_100057AA4( &v23,  0LL,  0LL,  0LL,  0LL,  0LL,  &qword_10008C730,  v5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  0x1725u))
  {
LABEL_12:
    uint64_t result = v4;
    goto LABEL_13;
  }

  if (v25 < 0x10)
  {
    uint64_t v12 = 5929LL;
LABEL_11:
    sub_100034EA8( &v23,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  v12,  v7,  v8,  v9,  v10,  v11);
    goto LABEL_12;
  }

  __int128 v30 = *v24;
  uint64_t v13 = *(void *)(a1 + 56);
  if (!v13)
  {
LABEL_10:
    uint64_t v12 = 5946LL;
    goto LABEL_11;
  }

  while (1)
  {
    *(_DWORD *)uint64_t v28 = 16;
    *(_OWORD *)&v28[4] = v30;
    __int128 v26 = *(_OWORD *)(v13 + 104);
    int v27 = *(_DWORD *)(v13 + 120);
    sub_10003F7A4(v28, &v26, v6, v7, v8, v9, v10, v11, (unint64_t)v29);
    *(_OWORD *)uint64_t v28 = *(_OWORD *)(v13 + 84);
    *(_DWORD *)&v28[16] = *(_DWORD *)(v13 + 100);
    if (sub_10003FB78(v29, v28, v14, v15, v16, v17, v18, v19)) {
      break;
    }
    uint64_t v13 = *(void *)(v13 + 40);
    if (!v13) {
      goto LABEL_10;
    }
  }

  uint64_t result = (uint64_t)sub_100034EA8( &v23,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5946LL,  v7,  v8,  v9,  v10,  v11);
  char v20 = 0;
LABEL_17:
  else {
    uint64_t v21 = v3;
  }
  if (v21) {
    return sub_100033920(&qword_10009D180, v21);
  }
  return result;
}

uint64_t sub_10001F94C(unsigned int a1, char *__s, uint64_t a3)
{
  uint64_t v24 = 0LL;
  uint64_t v25 = 0LL;
  uint64_t v26 = strlen(__s) + 2;
  if (!sub_1000345C4( &v24,  v26,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  777LL)) {
    sub_100061FB4("set_status_code: no memory for status code.", v6, v7, v8, v9, v10, v11, v12, v23);
  }
  uint64_t v25 = v24 + 1;
  sub_100060B78((_WORD *)v24 + 2, a1);
  memcpy((char *)v24 + 6, __s, v26 - 2LL);
  if (sub_100040F30(&qword_10008C1F8, a3, (uint64_t)v24, (uint64_t)v25, v26, 13LL, 0LL, v13))
  {
    uint64_t v21 = 1LL;
  }

  else
  {
    sub_10006221C("set_status_code: error saving status code.", v14, v15, v16, v17, v18, v19, v20, v23);
    uint64_t v21 = 0LL;
  }

  sub_100034EA8( &v24,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  792LL,  v16,  v17,  v18,  v19,  v20);
  return v21;
}

uint64_t sub_10001FA3C(uint64_t *a1, void *a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  *a2 = 0LL;
  a2[1] = 0LL;
  a2[2] = 0LL;
  if (sub_100057AA4( a2,  (unsigned int *)a3,  0LL,  0LL,  *(void *)(a3 + 160),  0LL,  &qword_10008C730,  a4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  0x2DEu))
  {
    if (*((_DWORD *)a2 + 4) >= a5)
    {
      *a1 = 0LL;
      if (sub_1000347D8( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  750LL,  v10,  v11,  v12,  v13,  v14))
      {
        sub_10006221C("get_encapsulated_IA_state: error parsing options.", v29, v30, v31, v32, v33, v34, v35, v42);
        sub_100034894( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  760LL,  v37,  v38,  v39,  v40,  v41);
        uint64_t v20 = (_DWORD **)a2;
        uint64_t v21 = 761LL;
      }

      else
      {
        sub_10006221C("get_encapsulated_IA_state: no memory for options.", v22, v23, v24, v25, v26, v27, v28, v42);
        uint64_t v20 = (_DWORD **)a2;
        uint64_t v21 = 752LL;
      }
    }

    else
    {
      sub_10006221C("get_encapsulated_IA_state: raw option too small.", v8, v9, v10, v11, v12, v13, v14, v42);
      uint64_t v20 = (_DWORD **)a2;
      uint64_t v21 = 741LL;
    }

    sub_100034EA8( v20,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  v21,  v15,  v16,  v17,  v18,  v19);
  }

  else
  {
    sub_10006221C("get_encapsulated_IA_state: error evaluating raw option.", v8, v9, v10, v11, v12, v13, v14, v42);
  }

  return 0LL;
}

BOOL sub_10001FB94( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (dword_10009D1C8)
  {
    if (!qword_10009D1F0) {
      sub_100061FB4( "Impossible condition at %s:%d.",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c");
    }
    return *(void *)(a1 + 4) == *(void *)qword_10009D1F0 && *(void *)(a1 + 12) == *(void *)(qword_10009D1F0 + 8);
  }

  else if (qword_10009D1D8 && (uint64_t v10 = *(unsigned int *)(qword_10009D1D8 + 36), (int)v10 >= 1))
  {
    for (uint64_t i = *(_DWORD ***)(qword_10009D1D8 + 56);
          *(void *)(a1 + 4) != *(void *)(*i + 1) || *(void *)(a1 + 12) != *(void *)(*i + 3);
          ++i)
    {
      if (!--v10) {
        return 0LL;
      }
    }

    sub_10002D850( &qword_10009D200,  *i,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2236LL,  a5,  a6,  a7,  a8);
    return 1LL;
  }

  else
  {
    return 0LL;
  }

uint64_t sub_10001FC78(uint64_t *a1, void *a2)
{
  uint64_t v63 = 0LL;
  uint64_t v64 = 0LL;
  uint64_t v65 = 0LL;
  sub_10003E0AC( 0LL,  (int *)qword_10009D198,  0LL,  0LL,  *(void *)(qword_10009D198 + 160),  qword_10009D190,  a1,  (uint64_t)a2,  (void *)qword_10008C140);
  if (qword_10009D180) {
    sub_10003E0AC( 0LL,  (int *)qword_10009D198,  0LL,  0LL,  *(void *)(qword_10009D198 + 160),  qword_10009D190,  a1,  *(void *)(qword_10009D180 + 152),  a2);
  }
  int v9 = dword_10009D218;
  if (!dword_10009D218) {
    int v9 = 43200;
  }
  LODWORD(qword_10009D220) = v9;
  uint64_t v10 = sub_100040D4C(&qword_10008BF80, qword_10009D190, 1LL, v4, v5, v6, v7, v8);
  if (v10)
  {
    if (sub_100057AA4( &v63,  (unsigned int *)qword_10009D198,  0LL,  0LL,  *(void *)(qword_10009D198 + 160),  qword_10009D190,  a1,  v10,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  0xB2Cu)) {
      BOOL v23 = (_DWORD)v65 == 4;
    }
    else {
      BOOL v23 = 0;
    }
    if (!v23)
    {
      uint64_t v24 = "reply_process_is_addressed: unable to evaluate default lease time";
LABEL_32:
      sub_10006221C(v24, v16, v17, v18, v19, v20, v21, v22, v62);
      uint64_t v47 = 25LL;
      goto LABEL_36;
    }

    LODWORD(qword_10009D220) = sub_100060B50(v64);
    sub_100034EA8( &v63,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2869LL,  v25,  v26,  v27,  v28,  v29);
  }

  unsigned int v30 = dword_10009D21C;
  if (!dword_10009D21C) {
    unsigned int v30 = qword_10009D220;
  }
  HIDWORD(qword_10009D220) = v30;
  uint64_t v31 = sub_100040D4C(&qword_10008BF80, qword_10009D190, 53LL, v11, v12, v13, v14, v15);
  if (v31)
  {
    if (!sub_100057AA4( &v63,  (unsigned int *)qword_10009D198,  0LL,  0LL,  *(void *)(qword_10009D198 + 160),  qword_10009D190,  a1,  v31,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  0xB47u)
      || (_DWORD)v65 != 4)
    {
      uint64_t v24 = "reply_process_is_addressed: unable to evaluate preferred lease time";
      goto LABEL_32;
    }

    HIDWORD(qword_10009D220) = sub_100060B50(v64);
    sub_100034EA8( &v63,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2896LL,  v36,  v37,  v38,  v39,  v40);
  }

  uint64_t v41 = qword_10009D200;
  if (qword_10009D200)
  {
    *(_DWORD *)(qword_10009D200 + 48) = HIDWORD(qword_10009D220);
    *(_DWORD *)(v41 + 52) = qword_10009D220;
    if (byte_10009D230 == 7) {
      *(void *)(v41 + 40) = xmmword_10008CE80 + qword_10009D220;
    }
    uint64_t v42 = sub_10002DC94( qword_10009D1D0,  (_DWORD *)v41,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2934LL,  v32,  v33,  v34,  v35);
    uint64_t v47 = v42;
    if ((_DWORD)v42)
    {
      char v48 = sub_100067900(v42);
      sub_100061FB4( "reply_process_is_addressed: Unable to attach lease to new IA: %s",  v49,  v50,  v51,  v52,  v53,  v54,  v55,  v48);
    }

    if (!*(void *)(qword_10009D200 + 56)) {
      sub_10002D6B4( (void *)(qword_10009D200 + 56),  (_DWORD *)qword_10009D1D0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2945LL,  v43,  v44,  v45,  v46);
    }
  }

  else
  {
    uint64_t v47 = 0LL;
  }

  sub_10003E0AC( 0LL,  (int *)qword_10009D198,  0LL,  0LL,  *(void *)(qword_10009D198 + 160),  qword_10009D1E0,  a1,  (uint64_t)a2,  (void *)qword_10008C140);
  if (qword_10009D180) {
    sub_10003E0AC( 0LL,  (int *)qword_10009D198,  0LL,  0LL,  *(void *)(qword_10009D198 + 160),  qword_10009D1E0,  a1,  *(void *)(qword_10009D180 + 152),  a2);
  }
LABEL_36:
  if (v64) {
    sub_100034EA8( &v63,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2966LL,  v56,  v57,  v58,  v59,  v60);
  }
  if (!(_DWORD)v47) {
    LODWORD(qword_10009D1C0) = qword_10009D1C0 + 1;
  }
  return v47;
}

uint64_t sub_10001FFF8(uint64_t a1)
{
  uint64_t v21 = 0LL;
  uint64_t v20 = 0LL;
  uint64_t v22 = 24LL;
  if (sub_1000345C4( &v20,  24,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  2984LL))
  {
    uint64_t v21 = v20 + 1;
    *(_OWORD *)(v20 + 1) = *(_OWORD *)(a1 + 4);
    sub_100060B6C(v20 + 5, HIDWORD(qword_10009D220));
    sub_100060B6C(v20 + 6, qword_10009D220);
    if (sub_10004416C( &qword_10008C1F8,  qword_10009D1E0,  (uint64_t)v20,  (uint64_t)(v20 + 1),  v22,  5LL,  0LL,  v9))
    {
      uint64_t v17 = 0LL;
      HIDWORD(qword_10009D1C0) = 1;
    }

    else
    {
      sub_10006221C("reply_process_send_addr: unable to save IAADDR option", v10, v11, v12, v13, v14, v15, v16, v19);
      uint64_t v17 = 25LL;
    }
  }

  else
  {
    sub_10006221C( "reply_process_send_addr: out of memoryallocating new IAADDR buffer.",  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v19);
    uint64_t v17 = 1LL;
  }

  if (v21) {
    sub_100034EA8( &v20,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3009LL,  v12,  v13,  v14,  v15,  v16);
  }
  return v17;
}

uint64_t sub_100020104( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!dword_10009D1CC)
  {
    if (!qword_10009D1D8 || *(int *)(qword_10009D1D8 + 36) < 1)
    {
      uint64_t v10 = 0LL;
      goto LABEL_49;
    }

    uint64_t v9 = 0LL;
    uint64_t v10 = 0LL;
    while (1)
    {
      uint64_t v11 = *(void *)(*(void *)(qword_10009D1D8 + 56) + 8 * v9);
      uint64_t v12 = *(void *)(*(void *)(v11 + 64) + 72LL);
      if (v12) {
        BOOL v13 = v12 == qword_10009D178;
      }
      else {
        BOOL v13 = 1;
      }
      if (!v13) {
        goto LABEL_43;
      }
      if (!v10) {
        goto LABEL_38;
      }
      if (dword_10009D228 < 0) {
        goto LABEL_21;
      }
      int v14 = *(unsigned __int8 *)(v10 + 20);
      if (dword_10009D228 != v14) {
        goto LABEL_21;
      }
LABEL_43:
      if (++v9 >= *(int *)(qword_10009D1D8 + 36))
      {
        if (v10 && *(_BYTE *)(v10 + 21) != 5)
        {
          sub_10002D850( &qword_10009D200,  (_DWORD *)v10,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3772LL,  a5,  a6,  a7,  a8);
          goto LABEL_73;
        }

LABEL_68:
        sub_10006238C(v36, a2, a3, a4, a5, a6, a7, a8, v54);
        if (v10) {
          sub_10006221C( "Reclaiming abandoned prefixes is not yet supported.  Treating this as an out of space condition.",  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v55);
        }
        return 13LL;
      }
    }

    if (dword_10009D228 == v14)
    {
LABEL_21:
      int v15 = *(unsigned __int8 *)(v11 + 21);
      switch(v15)
      {
        case 5:
          int v20 = *(unsigned __int8 *)(v10 + 21);
          if ((v20 - 2) >= 2)
          {
            if (v20 != 5
              || (uint64_t v21 = *(void *)(v10 + 32),
                  uint64_t v10 = *(void *)(*(void *)(qword_10009D1D8 + 56) + 8 * v9),
                  *(void *)(v11 + 32) >= v21))
            {
LABEL_42:
              sub_100061FB4( "Impossible condition at %s:%d.",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c");
            }

            goto LABEL_43;
          }

          break;
        case 3:
          int v17 = *(unsigned __int8 *)(v10 + 21);
          if (v17 == 2) {
            goto LABEL_43;
          }
          if (v17 != 5)
          {
            if (v17 != 3) {
              goto LABEL_42;
            }
            uint64_t v18 = *(void *)(v11 + 32);
            uint64_t v19 = *(void *)(v10 + 32);
            if (v18 < v19 || v18 == v19 && *(void *)(v11 + 40) < *(void *)(v10 + 40)) {
              goto LABEL_43;
            }
          }

          break;
        case 2:
          int v16 = *(unsigned __int8 *)(v10 + 21);
          if (v16 != 5 && v16 != 3)
          {
            if (v16 != 2) {
              goto LABEL_42;
            }
            if (*(void *)(v11 + 32) >= *(void *)(v10 + 32)) {
              uint64_t v10 = *(void *)(*(void *)(qword_10009D1D8 + 56) + 8 * v9);
            }
            goto LABEL_43;
          }

          break;
        default:
          goto LABEL_42;
      }
    }

        if (v8 != 607 && (v8 - 264) <= 0xFFFFFFFD && v8 >= 0x100)
        {
          if (qword_10008C160)
          {
            uint64_t v320 = 0LL;
            sub_100029804( &v320,  *(void *)(qword_10008C160 + 112),  __s,  0LL,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  2656LL);
            if (v320)
            {
              sub_100036D00(&__s, 0LL, (uint64_t)a2);
              a4 = sub_10004B414(a1, a2, 1LL, v320, 6);
              uint64_t v107 = 2663LL;
              goto LABEL_144;
            }
          }
        }

        if ((v15 & 0xFFFFFFFE) != 0x108)
        {
          a4 = 0LL;
          *a3 = 0;
          return a4;
        }

        if (!sub_100034984( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  2671LL)) {
          sub_100061FB4("no memory for eval statement.", v244, v245, v246, v247, v248, v249, v250, v319);
        }
        uint64_t v251 = *a1;
        v251[4] = 3;
        if (sub_10004BA40((void *)v251 + 3, a2, a3, 2LL, 0LL, 0LL, v249, v250))
        {
          a4 = 1LL;
          *a3 = 1;
          uint64_t v99 = a1;
          uint64_t v100 = 2690LL;
        }

        else
        {
          if (*a3) {
            *a3 = 1;
          }
          else {
            sub_100046D6C((uint64_t)a2, "expecting function call.", v252, v253, v254, v255, v256, v257, v319);
          }
          sub_100046C4C(a2, 0);
          uint64_t v99 = a1;
          uint64_t v100 = 2685LL;
        }

        goto LABEL_211;
      }

      if (v8 <= 383)
      {
        if (v8 != 342)
        {
          if (v8 == 343)
          {
            sub_100036D00(&__s, 0LL, (uint64_t)a2);
            if (sub_100046D08(a2))
            {
              if (!sub_100034984( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  2133LL)) {
                sub_100061FB4("no memory for new statement.", v16, v17, v18, v19, v20, v21, v22, v319);
              }
              uint64_t v23 = *a1;
              uint64_t v24 = 4;
LABEL_116:
              v23[4] = v24;
              return 1LL;
            }

            goto LABEL_190;
          }

          goto LABEL_68;
        }

        sub_100036D00(&__s, 0LL, (uint64_t)a2);
        if (sub_100036D00(&__s, 0LL, (uint64_t)a2) == 262)
        {
          uint64_t v321 = 0LL;
          char v199 = sub_100003828( (uint64_t)&v321,  __s,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  2109LL);
          if (v199)
          {
            uint64_t v200 = (char)__s;
            sub_100067900(v199);
            sub_100046D6C((uint64_t)a2, "class %s: %s", v201, v202, v203, v204, v205, v206, v200);
LABEL_189:
            sub_100046C4C(a2, 0);
            goto LABEL_190;
          }

          if (sub_100046D08(a2))
          {
            if (!sub_100034984( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  2121LL)) {
              sub_100061FB4("no memory for new statement.", v294, v295, v296, v297, v298, v299, v300, v319);
            }
            uint64_t v242 = *a1;
            uint64_t v243 = 2;
LABEL_123:
            v242[4] = v243;
            *((void *)v242 + 3) = v321;
            return 1LL;
          }

    if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  4879LL,  v26,  v27,  v28,  v29,  v30)) {
      sub_100061FB4("Can't allocate expression!", v72, v73, v74, v75, v76, v77, v78, v92);
    }
    uint64_t v79 = *a1;
    *(_DWORD *)(v79 + 4) = v8;
    *(void *)(v79 + 8) = v92;
    *(void *)(*a1 + 16LL) = v94;
    return 1LL;
  }

  if ((v8 - 8) < 2)
  {
    if (v52 >= 2)
    {
      sub_100046D6C((uint64_t)a2, "expecting BOOLean expressions", v54, v26, v27, v28, v29, v30, v92);
      sub_100046C4C(a2, 0);
      uint64_t v90 = &v94;
      uint64_t v91 = 4846LL;
      goto LABEL_82;
    }

    goto LABEL_57;
  }

  if (v8 != 3 && v8 != 38 || v52 <= 5 && ((1 << v52) & 0x2D) != 0) {
    goto LABEL_57;
  }
  sub_100046D6C((uint64_t)a2, "expecting data/numeric expression", v54, v26, v27, v28, v29, v30, v92);
  sub_100046C4C(a2, 0);
  uint64_t v90 = &v94;
  uint64_t v91 = 4817LL;
LABEL_82:
  sub_100054390( v90,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  v91,  v85,  v86,  v87,  v88,  v89);
LABEL_83:
  uint64_t result = 0LL;
  *a3 = 1;
  return result;
}

uint64_t sub_10002051C(uint64_t *a1, void *a2)
{
  uint64_t v63 = 0LL;
  uint64_t v64 = 0LL;
  uint64_t v65 = 0LL;
  sub_10003E0AC( 0LL,  (int *)qword_10009D198,  0LL,  0LL,  *(void *)(qword_10009D198 + 160),  qword_10009D190,  a1,  (uint64_t)a2,  (void *)qword_10008C140);
  if (qword_10009D180) {
    sub_10003E0AC( 0LL,  (int *)qword_10009D198,  0LL,  0LL,  *(void *)(qword_10009D198 + 160),  qword_10009D190,  a1,  *(void *)(qword_10009D180 + 152),  a2);
  }
  int v9 = dword_10009D218;
  if (!dword_10009D218) {
    int v9 = 43200;
  }
  LODWORD(qword_10009D220) = v9;
  uint64_t v10 = sub_100040D4C(&qword_10008BF80, qword_10009D190, 1LL, v4, v5, v6, v7, v8);
  if (v10)
  {
    if (sub_100057AA4( &v63,  (unsigned int *)qword_10009D198,  0LL,  0LL,  *(void *)(qword_10009D198 + 160),  qword_10009D190,  a1,  v10,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  0xF0Eu)) {
      BOOL v23 = (_DWORD)v65 == 4;
    }
    else {
      BOOL v23 = 0;
    }
    if (!v23)
    {
      uint64_t v24 = "reply_process_is_prefixed: unable to evaluate default prefix time";
LABEL_32:
      sub_10006221C(v24, v16, v17, v18, v19, v20, v21, v22, v62);
      uint64_t v47 = 25LL;
      goto LABEL_36;
    }

    LODWORD(qword_10009D220) = sub_100060B50(v64);
    sub_100034EA8( &v63,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3863LL,  v25,  v26,  v27,  v28,  v29);
  }

  unsigned int v30 = dword_10009D21C;
  if (!dword_10009D21C) {
    unsigned int v30 = qword_10009D220;
  }
  HIDWORD(qword_10009D220) = v30;
  uint64_t v31 = sub_100040D4C(&qword_10008BF80, qword_10009D190, 53LL, v11, v12, v13, v14, v15);
  if (v31)
  {
    if (!sub_100057AA4( &v63,  (unsigned int *)qword_10009D198,  0LL,  0LL,  *(void *)(qword_10009D198 + 160),  qword_10009D190,  a1,  v31,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  0xF29u)
      || (_DWORD)v65 != 4)
    {
      uint64_t v24 = "reply_process_is_prefixed: unable to evaluate preferred prefix time";
      goto LABEL_32;
    }

    HIDWORD(qword_10009D220) = sub_100060B50(v64);
    sub_100034EA8( &v63,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3890LL,  v36,  v37,  v38,  v39,  v40);
  }

  uint64_t v41 = qword_10009D200;
  if (qword_10009D200)
  {
    *(_DWORD *)(qword_10009D200 + 48) = HIDWORD(qword_10009D220);
    *(_DWORD *)(v41 + 52) = qword_10009D220;
    if (byte_10009D230 == 7) {
      *(void *)(v41 + 40) = xmmword_10008CE80 + qword_10009D220;
    }
    uint64_t v42 = sub_10002DC94( qword_10009D1D0,  (_DWORD *)v41,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3913LL,  v32,  v33,  v34,  v35);
    uint64_t v47 = v42;
    if ((_DWORD)v42)
    {
      char v48 = sub_100067900(v42);
      sub_100061FB4( "reply_process_is_prefixed: Unable to attach prefix to new IA_PD: %s",  v49,  v50,  v51,  v52,  v53,  v54,  v55,  v48);
    }

    if (!*(void *)(qword_10009D200 + 56)) {
      sub_10002D6B4( (void *)(qword_10009D200 + 56),  (_DWORD *)qword_10009D1D0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3924LL,  v43,  v44,  v45,  v46);
    }
  }

  else
  {
    uint64_t v47 = 0LL;
  }

  sub_10003E0AC( 0LL,  (int *)qword_10009D198,  0LL,  0LL,  *(void *)(qword_10009D198 + 160),  qword_10009D1E0,  a1,  (uint64_t)a2,  (void *)qword_10008C140);
  if (qword_10009D180) {
    sub_10003E0AC( 0LL,  (int *)qword_10009D198,  0LL,  0LL,  *(void *)(qword_10009D198 + 160),  qword_10009D1E0,  a1,  *(void *)(qword_10009D180 + 152),  a2);
  }
LABEL_36:
  if (v64) {
    sub_100034EA8( &v63,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3945LL,  v56,  v57,  v58,  v59,  v60);
  }
  if (!(_DWORD)v47) {
    LODWORD(qword_10009D1C0) = qword_10009D1C0 + 1;
  }
  return v47;
}

uint64_t sub_10002089C(uint64_t a1)
{
  uint64_t v22 = 0LL;
  uint64_t v21 = 0LL;
  uint64_t v23 = 25LL;
  if (sub_1000345C4( &v21,  25,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3964LL))
  {
    uint64_t v22 = v21 + 1;
    sub_100060B6C(v21 + 1, HIDWORD(qword_10009D220));
    sub_100060B6C(v21 + 2, qword_10009D220);
    int v9 = v21;
    *((_BYTE *)v21 + 12) = *(_DWORD *)(a1 + 20);
    *(_OWORD *)((char *)v9 + 13) = *(_OWORD *)(a1 + 4);
    if (sub_10004416C( &qword_10008C1F8,  qword_10009D1E0,  (uint64_t)v9,  (uint64_t)(v9 + 1),  v23,  26LL,  0LL,  v10))
    {
      uint64_t v18 = 0LL;
      HIDWORD(qword_10009D1C0) = 1;
    }

    else
    {
      sub_10006221C("reply_process_send_prefix: unable to save IAPREFIX option", v11, v12, v13, v14, v15, v16, v17, v20);
      uint64_t v18 = 25LL;
    }
  }

  else
  {
    sub_10006221C( "reply_process_send_prefix: out of memoryallocating new IAPREFIX buffer.",  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v20);
    uint64_t v18 = 1LL;
  }

  if (v22) {
    sub_100034EA8( &v21,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  3990LL,  v13,  v14,  v15,  v16,  v17);
  }
  return v18;
}

uint64_t sub_1000209A8()
{
  uint64_t v0 = __chkstk_darwin();
  uint64_t v2 = (void (*)(uint64_t, _DWORD **, unsigned int *, uint64_t, char *, _DWORD *, uint64_t))v1;
  uint64_t v4 = v3;
  uint64_t v6 = v5;
  uint64_t v8 = v7;
  uint64_t v10 = v9;
  uint64_t v11 = v0;
  __n[0] = 4;
  uint64_t v110 = 0LL;
  uint64_t v111 = 0LL;
  uint64_t v108 = 0LL;
  uint64_t v109 = 0LL;
  unsigned int v105 = 0LL;
  uint64_t v106 = 0LL;
  uint64_t v103 = 0LL;
  uint64_t v104 = 0LL;
  *(void *)&__n[1] = 0LL;
  uint64_t v102 = 0LL;
  unint64_t v100 = 0LL;
  uint64_t v112 = 0LL;
  if (!sub_100029E98( &v112,  *(const char **)(v7 + 8),  *(unsigned int *)(v7 + 16),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4634LL,  v1,  v12,  v13))
  {
    uint64_t v112 = 0LL;
    if (!sub_100029EB4( &v112,  (unsigned int *)v10,  *(void *)(v10 + 160),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4643LL,  v16,  v17,  v18)) {
      uint64_t v112 = 0LL;
    }
  }

  char __src = 7;
  __int16 v116 = *(_WORD *)(v10 + 21);
  char v117 = *(_BYTE *)(v10 + 23);
  uint64_t v113 = 0LL;
  if (!sub_1000347D8( &v113,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4659LL,  v14,  v15,  v16,  v17,  v18))
  {
    uint64_t v95 = "iterate_over_ia_na: no memory for option_state.";
LABEL_60:
    uint64_t result = sub_10006221C(v95, v19, v20, v21, v22, v23, v24, v25, v96);
    goto LABEL_61;
  }

  sub_10003E0AC(0LL, (int *)v10, 0LL, 0LL, *(void *)(v10 + 160), v113, &qword_10008C730, qword_10008C140, 0LL);
  if (!sub_100040D4C(&qword_10008C1F8, v113, 2LL, v26, v27, v28, v29, v30)
    && !sub_100040F30( &qword_10008C1F8,  v113,  0LL,  qword_10009D168,  dword_10009D170,  2LL,  0LL,  v25))
  {
    uint64_t v95 = "iterate_over_ia_na: error saving server identifier.";
    goto LABEL_60;
  }

  if (!sub_100040F30( &qword_10008C1F8,  v113,  *(void *)v8,  *(void *)(v8 + 8),  *(unsigned int *)(v8 + 16),  1LL,  0LL,  v25))
  {
    uint64_t v95 = "iterate_over_ia_na: error saving client identifier.";
    goto LABEL_60;
  }

  snprintf(__str, 0x20uLL, "%s received.", v6);
  uint64_t result = sub_10001F94C(0, __str, v113);
  if (!(_DWORD)result) {
    goto LABEL_61;
  }
  __n[0] += sub_1000425E0( (uint64_t)(&__src + __n[0]),  (0x10000 - __n[0]),  v113,  (unsigned int *)v10,  dword_100082664,  0LL,  v35,  v36);
  uint64_t v42 = sub_100040D4C(&qword_10008C1F8, *(void *)(v10 + 160), 3LL, v37, v38, v39, v40, v41);
  if (!v42) {
    goto LABEL_53;
  }
  uint64_t v43 = v42;
  do
  {
    uint64_t result = sub_10001FA3C(&v108, &v109, v10, v43, 0xCu);
    if (!(_DWORD)result) {
      goto LABEL_61;
    }
    int v44 = sub_100060B50(v110);
    uint64_t v50 = sub_100040D4C(&qword_10008C1F8, v108, 5LL, v45, v46, v47, v48, v49);
    if (!v50)
    {
      uint64_t v57 = 4732LL;
      uint64_t v58 = 4731LL;
      goto LABEL_52;
    }

    uint64_t v104 = 0LL;
    unsigned int v105 = 0LL;
    uint64_t v106 = 0LL;
    if (!sub_100057AA4( &v104,  (unsigned int *)v10,  0LL,  0LL,  *(void *)(v10 + 160),  0LL,  &qword_10008C730,  v50,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  0x1283u))
    {
      uint64_t v95 = "iterate_over_ia_na: error evaluating IAADDR.";
      goto LABEL_60;
    }

    uint64_t v107 = 0LL;
    if (sub_100029EB4( &v107,  (unsigned int *)v10,  v108,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4754LL,  v23,  v24,  v25))
    {
      uint64_t v56 = v107;
      if (v107) {
        goto LABEL_20;
      }
      goto LABEL_29;
    }

    uint64_t v56 = v112;
    if (!v112)
    {
      uint64_t v107 = 0LL;
LABEL_29:
      if (v106 >= 0x18)
      {
        if (sub_10002DB34( v97,  v44,  *(const void **)(v8 + 8),  *(_DWORD *)(v8 + 16),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4789LL)) {
          sub_100061FB4("iterate_over_ia_na: no memory for key.", v61, v62, v63, v64, v65, v66, v67, v96);
        }
        uint64_t v99 = 0LL;
        if (sub_100029804( &v99,  qword_10008BE60,  v97[1],  v98,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4797LL))
        {
          uint64_t v73 = *(unsigned int *)(v99 + 36);
          if ((int)v73 >= 1)
          {
            uint64_t v74 = *(_DWORD ***)(v99 + 56);
            while (*(void *)(*v74 + 1) != *v105 || *(void *)(*v74 + 3) != v105[1])
            {
              ++v74;
              if (!--v73) {
                goto LABEL_45;
              }
            }

            sub_10002D850( &v100,  *v74,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4810LL,  v69,  v70,  v71,  v72);
          }
        }

uint64_t sub_10002100C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  char v5 = sub_100050770((void *)*(unsigned int *)(a1 + 16), *(unsigned __int8 **)(a1 + 8), 0x3Cu, 0);
  inet_ntop(30, *(const void **)(a2 + 8), v15, 0x2Eu);
  uint64_t result = sub_1000622D4("Client %s releases address %s", v6, v7, v8, v9, v10, v11, v12, v5);
  if (a3)
  {
    sub_10002ED64(*(void *)(a3 + 64), a3);
    uint64_t v14 = *(void *)(a3 + 56);
    *(void *)(v14 + 48) = xmmword_10008CE80;
    return sub_10000D7B4(v14);
  }

  return result;
}

uint64_t sub_1000210D0(uint64_t a1, uint64_t a2, _DWORD *a3, unsigned int *a4, uint64_t a5, int *a6, int a7)
{
  char v13 = sub_100050770((void *)*(unsigned int *)(a1 + 16), *(unsigned __int8 **)(a1 + 8), 0x3Cu, 0);
  inet_ntop(30, *(const void **)(a2 + 8), v39, 0x2Eu);
  sub_1000622D4("Client %s releases address %s, which is not leased to it.", v14, v15, v16, v17, v18, v19, v20, v13);
  uint64_t v38 = 0LL;
  if (!sub_1000347D8( &v38,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4952LL,  v21,  v22,  v23,  v24,  v25))
  {
    uint64_t v34 = "ia_na_nomatch_release: out of memory allocating option_state.";
LABEL_6:
    sub_10006221C(v34, v26, v27, v28, v29, v30, v31, v32, v37);
    return sub_100034894( &v38,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5002LL,  v28,  v29,  v30,  v31,  v32);
  }

  if (sub_10001F94C(3u, "Release for non-leased address.", v38))
  {
    uint64_t v33 = *a6;
    if ((int)v33 + 16 <= a7)
    {
      int v35 = sub_1000425E0( a5 + v33 + 16,  (a7 - v33 - 16),  v38,  a4,  (unsigned int *)&unk_100082678,  0LL,  v31,  v32);
      sub_100060B78((_WORD *)(a5 + *a6), 3u);
      sub_100060B78((_WORD *)(a5 + *a6 + 2), v35 + 12);
      *(_DWORD *)(a5 + *a6 + 4) = *a3;
      sub_100060B6C((_DWORD *)(a5 + *a6 + 8), 0);
      sub_100060B6C((_DWORD *)(a5 + *a6 + 12), 0);
      *a6 += v35 + 16;
      return sub_100034894( &v38,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5002LL,  v28,  v29,  v30,  v31,  v32);
    }

    uint64_t v34 = "ia_na_nomatch_release: out of space for reply packet.";
    goto LABEL_6;
  }

  return sub_100034894( &v38,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  5002LL,  v28,  v29,  v30,  v31,  v32);
}

uint64_t sub_100021298(uint64_t a1, uint64_t a2, uint64_t a3)
{
  char v5 = sub_100050770((void *)*(unsigned int *)(a1 + 16), *(unsigned __int8 **)(a1 + 8), 0x3Cu, 0);
  inet_ntop(30, *(const void **)(a2 + 8), v15, 0x2Eu);
  uint64_t result = sub_10006221C( "Client %s reports address %s is already in use by another host!",  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v5);
  if (a3)
  {
    sub_10002ED00(*(void *)(a3 + 64), a3);
    uint64_t v14 = *(void *)(a3 + 56);
    *(void *)(v14 + 48) = xmmword_10008CE80;
    return sub_10000D7B4(v14);
  }

  return result;
}

uint64_t sub_10002135C(uint64_t a1, uint64_t a2, _DWORD *a3, unsigned int *a4, uint64_t a5, int *a6, int a7)
{
  char v13 = sub_100050770((void *)*(unsigned int *)(a1 + 16), *(unsigned __int8 **)(a1 + 8), 0x3Cu, 0);
  inet_ntop(30, *(const void **)(a2 + 8), v39, 0x2Eu);
  sub_1000622D4("Client %s declines address %s, which is not offered to it.", v14, v15, v16, v17, v18, v19, v20, v13);
  uint64_t v38 = 0LL;
  if (!sub_1000347D8( &v38,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4535LL,  v21,  v22,  v23,  v24,  v25))
  {
    uint64_t v34 = "ia_na_nomatch_decline: out of memory allocating option_state.";
LABEL_6:
    sub_10006221C(v34, v26, v27, v28, v29, v30, v31, v32, v37);
    return sub_100034894( &v38,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4584LL,  v28,  v29,  v30,  v31,  v32);
  }

  if (sub_10001F94C(3u, "Decline for unknown address.", v38))
  {
    uint64_t v33 = *a6;
    if ((int)v33 + 16 <= a7)
    {
      int v35 = sub_1000425E0( a5 + v33 + 16,  (a7 - v33 - 16),  v38,  a4,  (unsigned int *)&unk_100082678,  0LL,  v31,  v32);
      sub_100060B78((_WORD *)(a5 + *a6), 3u);
      sub_100060B78((_WORD *)(a5 + *a6 + 2), v35 + 12);
      *(_DWORD *)(a5 + *a6 + 4) = *a3;
      sub_100060B6C((_DWORD *)(a5 + *a6 + 8), 0);
      sub_100060B6C((_DWORD *)(a5 + *a6 + 12), 0);
      *a6 += v35 + 16;
      return sub_100034894( &v38,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4584LL,  v28,  v29,  v30,  v31,  v32);
    }

    uint64_t v34 = "ia_na_nomatch_decline: out of space for reply packet.";
    goto LABEL_6;
  }

  return sub_100034894( &v38,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/dhcpv6.c",  4584LL,  v28,  v29,  v30,  v31,  v32);
}

void sub_100021524()
{
  for (uint64_t i = qword_10008BE08; i; uint64_t i = *(void *)(i + 32))
  {
    sub_1000216AC(i, "startup");
    if (!*(_DWORD *)(i + 340))
    {
      sub_10006221C("failover peer declaration with no %s", v1, v2, v3, v4, v5, v6, v7, (char)"referring pools.");
      sub_10006221C( "In order to use failover, you MUST %s",  v8,  v9,  v10,  v11,  v12,  v13,  v14,  (char)"refer to your main failover declaration");
      sub_10006221C( "in each pool declaration.   You MUST %s",  v15,  v16,  v17,  v18,  v19,  v20,  v21,  (char)"NOT use range declarations outside");
      sub_100061FB4("of pool declarations.", v22, v23, v24, v25, v26, v27, v28, v39);
    }

    unsigned int v29 = sub_100021918(i);
    if (v29)
    {
      unsigned int v30 = v29;
      if (v29 != 49)
      {
        uint64_t v40 = (uint64_t *)(qword_10008CE80 + 90);
        int v41 = 0;
        sub_10003BEE8( &v40,  (uint64_t)sub_100021C74,  (uint64_t *)i,  (uint64_t (*)(void, void, void, void))sub_100021D08,  (uint64_t)sub_100021D0C);
        uint64_t v31 = *(void *)(i + 40);
        sub_100067900(v30);
        sub_10006221C("failover peer %s: %s", v32, v33, v34, v35, v36, v37, v38, v31);
      }
    }

    if (sub_100021D10(i))
    {
      uint64_t v40 = (uint64_t *)(qword_10008CE80 + 90);
      int v41 = 0;
      sub_10003BEE8( &v40,  (uint64_t)sub_100021FE4,  (uint64_t *)i,  (uint64_t (*)(void, void, void, void))sub_10005CFB8,  (uint64_t)sub_10005CFEC);
    }
  }

uint64_t sub_1000216AC(uint64_t a1, char *__s1)
{
  if (!strcmp(__s1, "disconnect"))
  {
    if (*(void *)(a1 + 232))
    {
      sub_1000622D4("peer %s: disconnected", v4, v5, v6, v7, v8, v9, v10, *(void *)(a1 + 40));
      uint64_t v20 = *(void *)(a1 + 232);
      uint64_t v22 = *(void *)(v20 + 64);
      uint64_t v21 = (_DWORD **)(v20 + 64);
      if (v22) {
        sub_10005CFEC(v21, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 1506LL);
      }
      sub_10005CFEC( (_DWORD **)(a1 + 232),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  1508LL);
    }

    sub_10003C09C((uint64_t)sub_100024468, a1);
    sub_10003C09C((uint64_t)sub_1000244E0, a1);
    sub_10003C09C((uint64_t)sub_10002589C, a1);
    int v23 = *(_DWORD *)(a1 + 64);
    int v24 = v23;
    if (v23 == 1) {
      int v24 = *(_DWORD *)(a1 + 128);
    }
    switch(v24)
    {
      case 0:
      case 5:
        goto LABEL_23;
      case 1:
        goto LABEL_34;
      case 2:
        goto LABEL_32;
      case 3:
      case 4:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
        goto LABEL_16;
      default:
        if (v24 != 254) {
          goto LABEL_34;
        }
LABEL_16:
        if (v23 != 1) {
          return 0LL;
        }
        int v25 = *(_DWORD *)(a1 + 128);
        uint64_t v26 = a1;
        break;
    }

    return sub_1000258A8(v26, v25);
  }

  if (!strcmp(__s1, "connect"))
  {
    unsigned int v27 = *(_DWORD *)(a1 + 64);
    if (v27 > 0xB)
    {
      if (v27 != 254) {
        goto LABEL_34;
      }
    }

    else if (((1 << v27) & 0xBF7) == 0)
    {
      if (v27 == 3)
      {
        uint64_t v29 = sub_1000258A8(a1, 2);
        sub_100025D00(a1);
        return v29;
      }

      uint64_t v26 = a1;
      int v25 = 5;
      return sub_1000258A8(v26, v25);
    }

    return sub_1000240E8(a1, v11, v12, v13, v14, v15, v16, v17);
  }

  if (!strcmp(__s1, "startup"))
  {
    sub_1000258A8(a1, 1);
    return 0LL;
  }

  if (!strcmp(__s1, "connect-timeout"))
  {
    unsigned int v18 = *(_DWORD *)(a1 + 64);
    if (v18 <= 0xB)
    {
      int v19 = 1 << v18;
      if ((v19 & 0xD9A) == 0)
      {
        if ((v19 & 0x245) == 0)
        {
LABEL_23:
          uint64_t v26 = a1;
          int v25 = 10;
          return sub_1000258A8(v26, v25);
        }

LABEL_32:
        uint64_t v26 = a1;
        int v25 = 3;
        return sub_1000258A8(v26, v25);
      }

      return 0LL;
    }

    if (v18 == 254) {
      goto LABEL_32;
    }
LABEL_34:
    sub_100061FB4( "Impossible case at %s:%d.",  v11,  v12,  v13,  v14,  v15,  v16,  v17,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c");
  }

  return 39LL;
}

    sub_10005CE20( v16,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  4198LL,  v28,  v29,  v30,  v31,  v32);
    goto LABEL_33;
  }

  if (v16)
  {
    uint64_t v33 = sub_10005E7A4(a2, (uint64_t)v16, v11);
    if ((_DWORD)v33) {
      goto LABEL_32;
    }
    sub_10005CE20( v16,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  4175LL,  v28,  v29,  v30,  v31,  v32);
  }

  uint64_t v35 = *(void *)(a1 + 64);
  if (v35 && *(void *)(v35 + 232) == a1)
  {
    int v41 = (uint64_t *)(qword_10008CE80 + *(_DWORD *)(v35 + 120) / 3);
    uint64_t v42 = 0;
    sub_10003BEE8( &v41,  (uint64_t)sub_100024468,  (uint64_t *)v35,  (uint64_t (*)(void, void, void, void))sub_100021D08,  (uint64_t)sub_100021D0C);
  }

  return 0LL;
}

    uint64_t v34 = 0;
    goto LABEL_33;
  }

  *((_BYTE *)v44 + 4) |= 4u;
  uint64_t v28 = __n;
  if (!(_DWORD)__n) {
    goto LABEL_32;
  }
  uint64_t v33 = sub_100045350((_BYTE *)v44 + 7, v17 + 2, *((uint64_t *)&v56 + 1), __n);
  if (v33 < 0)
  {
LABEL_31:
    unsigned int v18 = 0LL;
    uint64_t v34 = 1;
    goto LABEL_34;
  }

  uint64_t v34 = 0;
  uint64_t v35 = *(_DWORD *)(v9 + 16) + v33;
LABEL_29:
  *(_DWORD *)(v9 + 16) = v35;
  *(_DWORD *)(v9 + 20) = 0;
LABEL_33:
  unsigned int v18 = 1LL;
LABEL_34:
  for (uint64_t i = 0LL; i != 192; i += 24LL)
  {
    if (*(_DWORD *)((char *)&v46 + i + 8)) {
      sub_100034EA8( (_DWORD **)((char *)&v45[1] + i + 8),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  3167LL,  v28,  v29,  v30,  v31,  v32);
    }
  }

  sub_10003462C( &v44,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  3169LL,  v28,  v29,  v30,  v31,  v32);
  if (v34) {
    sub_100034EA8( (_DWORD **)v9,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  3171LL,  v37,  v38,  v39,  v40,  v41);
  }
  return v18;
}

          *__error() = 40;
          return 0xFFFFFFFFLL;
        }

        uint64_t v10 = 0;
      }

      while (v11 == 92);
      if (v11 != 46)
      {
        uint64_t v9 = a1;
LABEL_16:
        if ((unint64_t)v8 < v4)
        {
          *uint64_t v8 = v11;
          uint64_t v6 = v9;
          uint64_t v7 = v8;
          a1 = v9;
          continue;
        }

        goto LABEL_32;
      }

      break;
    }

    unsigned int v18 = (_DWORD)v8 + ~(_DWORD)v5;
    *uint64_t v5 = v18;
    if (*a1)
    {
      if (!v18) {
        goto LABEL_32;
      }
      uint64_t v5 = v7 + 1;
      if (*a1 == 46) {
        goto LABEL_32;
      }
      continue;
    }

    break;
  }

  if (v18)
  {
    uint64_t v8 = v7 + 2;
    v7[1] = 0;
  }

  if (v8 - a2 > 255) {
    goto LABEL_32;
  }
  return 1LL;
}

uint64_t sub_100021918(uint64_t a1)
{
  uint64_t v33 = 0LL;
  do
  {
    uint64_t v1 = a1;
    a1 = *(void *)(a1 + 16);
  }

  while (a1);
  while (*(void *)v1 != qword_10008BEA0)
  {
    uint64_t v1 = *(void *)(v1 + 24);
    if (!v1) {
      return 39LL;
    }
  }

  uint64_t v37 = 0LL;
  uint64_t v2 = sub_10005CE50( (void **)&v37,  (void *)qword_10008BE90,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  202LL);
  if (!(_DWORD)v2)
  {
    sub_100033F18( v37 + 4,  *(_DWORD **)(v1 + 88),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  206LL,  v3,  v4,  v5,  v6);
    uint64_t v7 = v37;
    *((_DWORD *)v37 + 10) = *(_DWORD *)(v1 + 96);
    sub_10005CFB8(v7 + 8, v1);
    uint64_t v35 = 0LL;
    uint64_t v36 = 0LL;
    uint64_t v34 = 0LL;
    if (sub_100057AA4( &v34,  0LL,  0LL,  0LL,  0LL,  0LL,  &qword_10008C730,  v37[4],  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  0xD7u))
    {
      uint64_t v8 = sub_10005D7F4(&v33, v36 >> 2);
      if ((_DWORD)v8)
      {
        uint64_t v2 = v8;
        uint64_t v14 = 224LL;
      }

      else
      {
        if (v33[1])
        {
          uint64_t v15 = 0LL;
          unint64_t v16 = 0LL;
          uint64_t v17 = *((void *)v33 + 1);
          do
          {
            uint64_t v18 = v17 + v15;
            *(void *)uint64_t v18 = 0x400000002LL;
            *(_DWORD *)(v18 + 8) = v35[v16];
            int v19 = v33;
            uint64_t v17 = *((void *)v33 + 1);
            *(_DWORD *)(v17 + v15 + 24) = *((_DWORD *)v37 + 10);
            ++v16;
            v15 += 28LL;
          }

          while (v16 < v19[1]);
        }

        sub_100034EA8( &v34,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  235LL,  v9,  v10,  v11,  v12,  v13);
        uint64_t v26 = *(void *)(v1 + 48);
        if (v26
          && sub_100057AA4( &v34,  0LL,  0LL,  0LL,  0LL,  0LL,  &qword_10008C730,  v26,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  0xF5u))
        {
          if ((_DWORD)v36 != 4)
          {
            sub_10006221C( "failover peer %s: 'address' parameter fails to resolve to an IPv4 address",  v20,  v21,  v22,  v23,  v24,  v25,  v26,  *(void *)(v1 + 40));
            sub_100034EA8( &v34,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  258LL,  v28,  v29,  v30,  v31,  v32);
            sub_10005CFEC( (_DWORD **)&v37,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  259LL);
            sub_10005D658(&v33);
            return 39LL;
          }

          uint64_t v38 = 0x400000002LL;
          LODWORD(v39) = *v35;
          if (!*(_DWORD *)(v1 + 152)) {
            sub_100034E60( v1 + 136,  (uint64_t)&v34,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  268LL,  v23,  v24,  v25,  v26);
          }
          sub_100034EA8( &v34,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  269LL,  v22,  v23,  v24,  v25,  v26);
          int v41 = 0;
        }

        else
        {
          uint64_t v39 = 0LL;
          uint64_t v40 = 0LL;
          int v41 = 0;
          uint64_t v38 = 0x400000002LL;
          if (!*(_DWORD *)(v1 + 152)) {
            sub_100061FB4( "failover peer %s: no local address.",  v20,  v21,  v22,  v23,  v24,  v25,  v26,  *(void *)(v1 + 40));
          }
        }

        uint64_t v2 = sub_10005F3F4((uint64_t)v37, v33, (uint64_t)&v38);
        sub_10005D658(&v33);
        uint64_t v14 = 277LL;
      }

      sub_10005CFEC((_DWORD **)&v37, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", v14);
    }

    else
    {
      sub_10005CFEC((_DWORD **)&v37, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 216LL);
      return 34LL;
    }
  }

  return v2;
}

uint64_t **sub_100021C74(uint64_t **result)
{
  if (!result[29])
  {
    uint64_t v1 = (uint64_t *)result;
    uint64_t result = (uint64_t **)sub_100021918((uint64_t)result);
    if ((_DWORD)result)
    {
      if ((_DWORD)result != 49)
      {
        uint64_t v2 = v1[5];
        sub_100067900(result);
        sub_1000622D4("failover peer %s: %s", v3, v4, v5, v6, v7, v8, v9, v2);
        uint64_t v10 = (uint64_t *)(qword_10008CE80 + 90);
        int v11 = 0;
        return sub_10003BEE8( &v10,  (uint64_t)sub_100021C74,  v1,  (uint64_t (*)(void, void, void, void))sub_100021D08,  (uint64_t)sub_100021D0C);
      }
    }
  }

  return result;
}

uint64_t sub_100021D10(uint64_t a1)
{
  uint64_t v15 = 0LL;
  uint64_t v2 = sub_1000683F8(a1, 0, "local-port");
  if ((_DWORD)v2) {
    return v2;
  }
  uint64_t v3 = v15[2];
  if (!v3)
  {
    uint64_t v11 = 987LL;
LABEL_19:
    sub_10005D71C(&v15, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", v11);
    return 39LL;
  }

  uint64_t v2 = sub_100068C24(&v14, v3);
  sub_10005D71C(&v15, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 992LL);
  if ((_DWORD)v2) {
    return v2;
  }
  int v4 = v14;
  *(_DWORD *)&v17[24] = v14;
  uint64_t v2 = sub_1000683F8(a1, 0, "local-address");
  if ((_DWORD)v2) {
    return v2;
  }
  uint64_t v5 = v15[2];
  if (!v5 || v5[1] != 2 || v5[2] != 4)
  {
    uint64_t v11 = 1003LL;
    goto LABEL_19;
  }

  *(_DWORD *)&v17[8] = v5[3];
  *(void *)uint64_t v17 = 0x400000002LL;
  sub_10005D71C(&v15, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 1016LL);
  uint64_t v6 = qword_10008BE00;
  if (!qword_10008BE00)
  {
LABEL_14:
    unint64_t v16 = 0LL;
    uint64_t v2 = sub_10005CE50( (void **)&v16,  (void *)qword_10008BE98,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  1032LL);
    if ((_DWORD)v2) {
      return v2;
    }
    uint64_t v7 = v16;
    uint64_t v8 = v16 + 40;
    *(_OWORD *)(v16 + 40) = *(_OWORD *)v17;
    *(_OWORD *)(v7 + 52) = *(_OWORD *)&v17[12];
    uint64_t v2 = sub_10006394C((uint64_t)v7, (uint64_t)v8, 1);
    if ((_DWORD)v2) {
      return v2;
    }
    uint64_t v9 = sub_10005CFB8((void *)(a1 + 16), (uint64_t)v16);
    if ((_DWORD)v9)
    {
      uint64_t v2 = v9;
      uint64_t v10 = 1044LL;
    }

    else
    {
      uint64_t v13 = sub_10005CFB8((void *)v16 + 3, a1);
      if (!(_DWORD)v13)
      {
        if (qword_10008BE00)
        {
          sub_10005CFB8((void *)v16 + 4, qword_10008BE00);
          sub_10005CFEC( (_DWORD **)&qword_10008BE00,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  1057LL);
        }

        sub_10005CFB8(&qword_10008BE00, (uint64_t)v16);
        return sub_10005CFEC( (_DWORD **)&v16,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  1061LL);
      }

      uint64_t v2 = v13;
      uint64_t v10 = 1049LL;
    }

    sub_10005CFEC((_DWORD **)&v16, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", v10);
    return v2;
  }

  while (*(_DWORD *)(v6 + 64) != v4
       || *(_DWORD *)(v6 + 40) != 2
       || *(void *)(v6 + 44) != __PAIR64__(*(unsigned int *)&v17[8], 4))
  {
    uint64_t v6 = *(void *)(v6 + 32);
    if (!v6) {
      goto LABEL_14;
    }
  }

  return 0LL;
}

uint64_t **sub_100021FE4(uint64_t *a1)
{
  uint64_t result = (uint64_t **)sub_100021D10((uint64_t)a1);
  if ((_DWORD)result)
  {
    uint64_t v3 = a1[5];
    sub_100067900(result);
    sub_1000622D4("failover peer %s: %s", v4, v5, v6, v7, v8, v9, v10, v3);
    uint64_t v11 = (uint64_t *)(qword_10008CE80 + 90);
    int v12 = 0;
    return sub_10003BEE8( &v11,  (uint64_t)sub_100021FE4,  a1,  (uint64_t (*)(void, void, void, void))sub_100021D08,  (uint64_t)sub_100021D0C);
  }

  return result;
}

uint64_t sub_100022064()
{
  uint64_t v0 = qword_10008BE08;
  if (!qword_10008BE08) {
    return 1LL;
  }
  while (1)
  {
    uint64_t result = sub_10000DC18(v0);
    if (!(_DWORD)result) {
      break;
    }
    uint64_t v0 = *(void *)(v0 + 32);
    if (!v0) {
      return 1LL;
    }
  }

  return result;
}

uint64_t sub_1000220A0(uint64_t a1)
{
  uint64_t v5 = 0LL;
  unsigned int v2 = sub_100022168(&v5, *(char **)(a1 + 40));
  if (v2 == 23)
  {
    if (qword_10008BE08)
    {
      sub_10005CFB8((void *)(a1 + 32), qword_10008BE08);
      sub_10005CFEC( (_DWORD **)&qword_10008BE08,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  136LL);
    }

    sub_10005CFB8(&qword_10008BE08, a1);
    return 0LL;
  }

  else
  {
    unsigned int v4 = v2;
    sub_10005CFEC(&v5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 141LL);
    if (v4) {
      return v4;
    }
    else {
      return 18LL;
    }
  }

uint64_t sub_100022168(void *a1, char *__s1)
{
  uint64_t v2 = qword_10008BE08;
  if (!qword_10008BE08) {
    return 23LL;
  }
  while (strcmp(__s1, *(const char **)(v2 + 40)))
  {
    uint64_t v2 = *(void *)(v2 + 32);
    if (!v2) {
      return 23LL;
    }
  }

  return sub_10005CFB8(a1, v2);
}

uint64_t sub_1000221EC(void **a1, uint64_t a2, uint64_t a3)
{
  return sub_10005CE50(a1, (void *)qword_10008BE90, 0LL, a2, a3);
}

uint64_t sub_10002220C(uint64_t a1, char *__s1, int *a3)
{
  uint64_t v119 = 0LL;
  uint64_t v120 = a3;
  if (*(void *)a1 != qword_10008BE90) {
    return 34LL;
  }
  if (!strcmp(__s1, "connect"))
  {
    if (*(_DWORD *)(*(void *)(a1 + 64) + 240LL))
    {
      uint64_t v3 = 0LL;
    }

    else
    {
      uint64_t v23 = sub_100022CE4(a1);
      uint64_t v3 = v23;
      if ((_DWORD)v23)
      {
        char v24 = sub_100067900(v23);
        sub_1000622D4("dhcp_failover_send_connect: %s", v25, v26, v27, v28, v29, v30, v31, v24);
        sub_100060130(*(void *)(a1 + 16), 1);
      }
    }

    char v117 = (uint64_t *)(qword_10008CE80 + 15);
    int v118 = 0;
    sub_10003BEE8( &v117,  (uint64_t)sub_100022E74,  (uint64_t *)a1,  (uint64_t (*)(void, void, void, void))sub_100022ED8,  (uint64_t)sub_100022208);
    return v3;
  }

  if (!strcmp(__s1, "disconnect"))
  {
    uint64_t v16 = *(void *)(a1 + 64);
    if (v16)
    {
      sub_10005CFB8(&v119, v16);
      *(_DWORD *)(a1 + 48) = 3;
      uint64_t v17 = v119;
      if (v119[29] == a1)
      {
        sub_1000216AC(*(void *)(a1 + 64), __s1);
        uint64_t v17 = v119;
      }

      char v117 = (uint64_t *)(qword_10008CE80 + 5);
      int v118 = dword_10008CE88;
      sub_10003BEE8( &v117,  (uint64_t)sub_100021C74,  v17,  (uint64_t (*)(void, void, void, void))sub_100021D08,  (uint64_t)sub_100021D0C);
      uint64_t v18 = 344LL;
      goto LABEL_25;
    }

    return 0LL;
  }

  if (!strcmp(__s1, "status"))
  {
    uint64_t v19 = *(void *)(a1 + 64);
    if (v19)
    {
      uint64_t v20 = v120;
      v120 += 2;
      int v21 = *v20;
      if (v21 == 9 || v21 == 2)
      {
        sub_10005CFB8(&v119, v19);
        *(_DWORD *)(a1 + 48) = 3;
        sub_1000216AC(*(void *)(a1 + 64), "disconnect");
        char v117 = (uint64_t *)(qword_10008CE80 + 5);
        int v118 = 0;
        sub_10003BEE8( &v117,  (uint64_t)sub_100021C74,  v119,  (uint64_t (*)(void, void, void, void))sub_100021D08,  (uint64_t)sub_100021D0C);
      }

      uint64_t v18 = 376LL;
LABEL_25:
      sub_10005CFEC((_DWORD **)&v119, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", v18);
      return 0LL;
    }

    return 0LL;
  }

  if (strcmp(__s1, "ready"))
  {
    uint64_t v14 = *(void *)(a1 + 24);
    if (!v14) {
      return 23LL;
    }
    uint64_t v15 = *(uint64_t (**)(void))(*(void *)v14 + 40LL);
    if (!v15) {
      return 23LL;
    }
    return v15();
  }

  uint64_t v32 = *(void **)(a1 + 16);
  if (!v32 || *v32 != qword_10008CF08) {
    return 39LL;
  }
  int v33 = *(_DWORD *)(a1 + 48);
  if (v33 == 2) {
    goto LABEL_43;
  }
  if (v33 == 1) {
    goto LABEL_40;
  }
  if (v33) {
    sub_100061FB4( "Impossible case at %s:%d.",  v7,  v8,  v9,  v10,  v11,  v12,  v13,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c");
  }
  *(_DWORD *)(a1 + 48) = 1;
  while (1)
  {
LABEL_40:
    *(_DWORD *)(a1 + 48) = 2;
    uint64_t v34 = sub_10005CDE4(0x100uLL);
    *(void *)(a1 + 56) = v34;
    unsigned int v40 = 1;
    if (!v34) {
      goto LABEL_111;
    }
    v34[14] = 0u;
    v34[15] = 0u;
    v34[12] = 0u;
    v34[13] = 0u;
    v34[10] = 0u;
    v34[11] = 0u;
    v34[8] = 0u;
    v34[9] = 0u;
    v34[6] = 0u;
    v34[7] = 0u;
    v34[4] = 0u;
    v34[5] = 0u;
    v34[2] = 0u;
    v34[3] = 0u;
    *uint64_t v34 = 0u;
    v34[1] = 0u;
    **(_DWORD **)(a1 + 56) = 1;
    sub_10005EF90((uint64_t)v32, (_WORD *)(a1 + 72));
    *(_DWORD *)(a1 + 76) = 0;
    int v41 = *(unsigned __int16 *)(a1 + 72);
    if ((v41 - 2049) < 0xFFFFF80B)
    {
      unsigned int v40 = 34;
      goto LABEL_111;
    }

LABEL_43:
    uint64_t v43 = a1 + 56;
    uint64_t v42 = *(void *)(a1 + 56);
    *(_DWORD *)(a1 + 76) += 2;
    sub_10005E974((char *)(v42 + 28), (uint64_t)v32, 1u);
    ++*(_DWORD *)(a1 + 76);
    sub_10005E974((char *)(a1 + 80), (uint64_t)v32, 1u);
    ++*(_DWORD *)(a1 + 76);
    sub_10005EF20((uint64_t)v32, (_DWORD *)(*(void *)(a1 + 56) + 20LL));
    *(_DWORD *)(a1 + 76) += 4;
    sub_10005EF20((uint64_t)v32, (_DWORD *)(*(void *)(a1 + 56) + 24LL));
    unsigned int v50 = *(_DWORD *)(a1 + 76) + 4;
    *(_DWORD *)(a1 + 76) = v50;
    int v51 = *(unsigned __int8 *)(a1 + 80);
    size_t v52 = v51 - v50;
    if (v51 != v50)
    {
      sub_10005E974(0LL, (uint64_t)v32, v52);
      unsigned int v50 = *(unsigned __int8 *)(a1 + 80);
      *(_DWORD *)(a1 + 76) = v50;
    }

    unsigned int v53 = *(unsigned __int16 *)(a1 + 72);
    if (v50 < v53) {
      break;
    }
LABEL_83:
    uint64_t v82 = *(_DWORD **)v43;
    if (*(_BYTE *)(*(void *)v43 + 28LL) == 5)
    {
      int v83 = v82[4];
      if ((v83 & 0x400000) == 0)
      {
        uint64_t v85 = (const char **)v119;
        uint64_t v106 = "missing relationship-name";
        unsigned int v107 = 8;
        if (!v119)
        {
          LOBYTE(v108) = 7;
LABEL_127:
          sub_10006221C("Failover CONNECT from %.*s: %s", v44, v52, v45, v46, v47, v48, v49, v108);
          sub_100023050((void *)a1, (uint64_t)v119, v107, v106);
          sub_1000622D4("failover: disconnect: %s", v109, v110, v111, v112, v113, v114, v115, (char)v106);
          sub_100060130((uint64_t)v32, 0);
          uint64_t v3 = 0LL;
          *(_DWORD *)(a1 + 48) = 3;
          return v3;
        }

    uint64_t v84 = 0LL;
    int v83 = 0LL;
    uint64_t v85 = (__n + 16);
    if (!sub_1000345C4( &v83,  (int)__n + 16,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  840LL))
    {
      sub_100034EA8( &v88,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  841LL,  v42,  v43,  v44,  v45,  v46);
      return 1LL;
    }

    uint64_t v84 = v83 + 1;
    memcpy(v83 + 1, v89, __n);
    *(_OWORD *)((char *)v83 + __n + 4) = __dst;
    sub_100034EA8( &v88,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  847LL,  v47,  v48,  v49,  v50,  v51);
    sub_100034E60( (uint64_t)&v88,  (uint64_t)&v83,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  848LL,  v52,  v53,  v54,  v55);
    sub_100034EA8( &v83,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  849LL,  v56,  v57,  v58,  v59,  v60);
    int v61 = *a3 + 1;
    *a3 = v61;
    if (v61 > 0x64)
    {
      sub_100034EA8( &v88,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  782LL,  v12,  v13,  v14,  v15,  v16);
      return 13LL;
    }
  }

  if (sub_100063738( &v86,  *(uint64_t (***)(unsigned __int8 *, int, unsigned int))(a1 + 32),  (const char *)&__dst,  16LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  829LL,  v27,  v28))
  {
    if (v86) {
      sub_10002D8B8( &v86,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  833LL,  v37,  v38,  v39,  v40,  v41);
    }
    goto LABEL_43;
  }

  sub_100034EA8( &v88,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  852LL,  v37,  v38,  v39,  v40,  v41);
  v91[0] = 0LL;
  uint64_t v62 = sub_10002D9A0( v91,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  859LL,  v65,  v66,  v67,  v68,  v69);
  if (!(_DWORD)v62)
  {
    uint64_t v75 = (char *)v91[0];
    *((_BYTE *)v91[0] + 20) = 0;
    *(_OWORD *)(v75 + 4) = __dst;
    uint64_t v62 = sub_10002E7BC(a1, (uint64_t)v75, a5, v70, v71, v72, v73, v74);
    if (!(_DWORD)v62) {
      sub_10002D850( a2,  (_DWORD *)v91[0],  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  871LL,  v77,  v78,  v79,  v80);
    }
    sub_10002D8B8( v91,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  873LL,  v76,  v77,  v78,  v79,  v80);
  }

  return v62;
}

                  if (sub_100067900(v51)) {
                    goto LABEL_46;
                  }
                }

                sub_1000622D4( "Added new forward map from %.*s to %s",  v52,  v53,  v54,  v55,  v56,  v57,  v58,  *(_DWORD *)(a1 + 16));
              }
            }

LABEL_126:
        LOBYTE(v108) = strlen(v85[5]);
        goto LABEL_127;
      }

      for (uint64_t i = qword_10008BE08; i; uint64_t i = *(void *)(i + 32))
      {
      }

      uint64_t v85 = (const char **)v119;
      if (!v119)
      {
        int v108 = v82[40];
        uint64_t v106 = "unknown failover relationship name";
        unsigned int v107 = 8;
        goto LABEL_127;
      }

      uint64_t v86 = v82[5];
      if (qword_10008CE80 > v86 && qword_10008CE80 - v86 > 60 || v86 > qword_10008CE80 && v86 - qword_10008CE80 > 60)
      {
        uint64_t v106 = "time offset too large";
        unsigned int v107 = 4;
        goto LABEL_126;
      }

      if ((v83 & 0x800) == 0 || v82[28] != 32)
      {
        uint64_t v106 = "invalid HBA";
        unsigned int v107 = 18;
        goto LABEL_126;
      }

      uint64_t v87 = (void *)v119[21];
      if (v87) {
        sub_10005CE20( v87,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  567LL,  v45,  v46,  v47,  v48,  v49);
      }
      uint64_t v88 = sub_10005CDE4(0x20uLL);
      uint64_t v85 = (const char **)v119;
      v119[21] = (uint64_t)v88;
      if (!v88)
      {
        uint64_t v106 = "no memory";
        unsigned int v107 = 6;
        goto LABEL_126;
      }

      uint64_t v89 = *(_OWORD **)(*(void *)(a1 + 56) + 120LL);
      __int128 v90 = v89[1];
      *uint64_t v88 = *v89;
      v88[1] = v90;
      if (!*(void *)(a1 + 64)) {
        sub_10005CFB8((void *)(a1 + 64), (uint64_t)v119);
      }
      if (!*(void *)(a1 + 32)) {
        sub_100033F18( (void *)(a1 + 32),  (_DWORD *)v119[11],  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  582LL,  v46,  v47,  v48,  v49);
      }
    }

    uint64_t v91 = *(void *)(a1 + 64);
    if (!v91)
    {
      sub_1000622D4("failover: connect: no matching state.", v44, v52, v45, v46, v47, v48, v49, v116);
      sub_100060130((uint64_t)v32, 1);
      *(_DWORD *)(a1 + 48) = 3;
      return 39LL;
    }

    char v116 = a1;
    sub_100067DAC(v91);
    *(_DWORD *)(a1 + 48) = 1;
    if (*(void *)(a1 + 56)) {
      sub_100022EDC( (void **)(a1 + 56),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  601LL,  v92,  v93,  v94,  v95,  v96);
    }
  }

  while (1)
  {
    if (v50 + 2 > v53)
    {
      uint64_t v97 = "FAILOVER: message overflow at option code.";
      goto LABEL_109;
    }

    sub_10005EF90((uint64_t)v32, &v117);
    int v54 = *(_DWORD *)(a1 + 76);
    *(_DWORD *)(a1 + 76) = v54 + 2;
    if (v54 + 4 > *(unsigned __int16 *)(a1 + 72))
    {
      uint64_t v97 = "FAILOVER: message overflow at length.";
      goto LABEL_109;
    }

    sub_10005EF90((uint64_t)v32, &__size);
    int v55 = *(_DWORD *)(a1 + 76) + 2;
    *(_DWORD *)(a1 + 76) = v55;
    size_t v52 = (unsigned __int16)__size;
    unsigned int v56 = v55 + (unsigned __int16)__size;
    unsigned int v57 = *(unsigned __int16 *)(a1 + 72);
    if (v56 > v57)
    {
      uint64_t v97 = "FAILOVER: message overflow at data.";
      goto LABEL_109;
    }

LABEL_82:
    *(_DWORD *)(*(void *)v43 + 16LL) |= *((_DWORD *)&unk_100088C60 + 8 * (unsigned __int16)v117 + 7);
    goto LABEL_53;
  }

  sub_10006221C( "FAILOVER: option_len %d not %s%d",  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  (unsigned __int16)__size,  v45,  v46,  v47,  v48,  v49,  __size);
LABEL_110:
  unsigned int v40 = 38;
LABEL_111:
  if (*(void *)(a1 + 56)) {
    sub_100022EDC( (void **)(a1 + 56),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  410LL,  v35,  v36,  v37,  v38,  v39);
  }
  *(_DWORD *)(a1 + 48) = 3;
  char v98 = sub_100067900(v40);
  sub_1000622D4("message length wait: %s", v99, v100, v101, v102, v103, v104, v105, v98);
  sub_100060130((uint64_t)v32, 1);
  return 34LL;
}

uint64_t sub_100022CE4(uint64_t a1)
{
  if (!a1) {
    return 39LL;
  }
  if (*(void *)a1 != qword_10008BE90) {
    return 39LL;
  }
  uint64_t v3 = *(void **)(a1 + 16);
  if (!v3 || *v3 != qword_10008CF08) {
    return 39LL;
  }
  uint64_t v4 = *(void *)(a1 + 64);
  uint64_t v5 = *(unsigned int *)(a1 + 84);
  *(_DWORD *)(a1 + 84) = v5 + 1;
  unsigned int v6 = strlen(*(const char **)(v4 + 40));
  uint64_t v62 = sub_1000281F8(0x16u, v7, v8, v9, v10, v11, v12, v13, v6, *(void *)(v4 + 40));
  int v21 = sub_1000281F8(0xEu, v14, v15, v16, v17, v18, v19, v20, *(_DWORD *)(v4 + 60), v58);
  sub_1000281F8(0x13u, v22, v23, v24, v25, v26, v27, v28, *(_DWORD *)(v4 + 80), v59);
  sub_10002814C(0x1Cu, 0LL, 0LL, 0LL, "isc-%s", "4.1-ESV");
  sub_1000281F8(0x14u, v29, v30, v31, v32, v33, v34, v35, 1u, v60);
  sub_1000281F8(0x1Bu, v36, v37, v38, v39, v40, v41, v42, 0, 0LL);
  sub_1000281F8(0xFu, v43, v44, v45, v46, v47, v48, v49, *(_DWORD *)(v4 + 160), v61);
  uint64_t v57 = *(void *)(v4 + 168);
  if (v57) {
    sub_1000281F8(0xBu, v50, v51, v52, v53, v54, v55, v56, 0x20u, v57);
  }
  return sub_10002856C(a1, (uint64_t)v3, 5, v5, v53, v54, v55, v56, v62, (uint64_t)v21);
}

uint64_t sub_100022E74( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  do
  {
    uint64_t v8 = (void *)result;
    uint64_t result = *(void *)(result + 24);
  }

  while (result);
  while (*v8 != qword_10008CF08)
  {
    uint64_t v8 = (void *)v8[2];
    if (!v8) {
      return result;
    }
  }

  sub_1000622D4("failover: link startup timeout", a2, a3, a4, a5, a6, a7, a8, v9);
  return sub_100060130((uint64_t)v8, 1);
}

void sub_100022EDC( void **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v9 = *a1;
  int v10 = *(_DWORD *)*a1 - 1;
  *(_DWORD *)*a1 = v10;
  if (!v10)
  {
    if (v9[1]) {
      sub_100022EDC(v9 + 1, a2, a3);
    }
    uint64_t v13 = (void *)v9[11];
    if (v13) {
      sub_10005CE20(v13, a2, a3, a4, a5, a6, a7, a8);
    }
    uint64_t v14 = (void *)v9[13];
    if (v14) {
      sub_10005CE20(v14, a2, a3, a4, a5, a6, a7, a8);
    }
    uint64_t v15 = (void *)v9[15];
    if (v15) {
      sub_10005CE20(v15, a2, a3, a4, a5, a6, a7, a8);
    }
    uint64_t v16 = (void *)v9[17];
    if (v16) {
      sub_10005CE20(v16, a2, a3, a4, a5, a6, a7, a8);
    }
    uint64_t v17 = (void *)v9[23];
    if (v17) {
      sub_10005CE20(v17, a2, a3, a4, a5, a6, a7, a8);
    }
    uint64_t v18 = (void *)v9[25];
    if (v18) {
      sub_10005CE20(v18, a2, a3, a4, a5, a6, a7, a8);
    }
    uint64_t v19 = (void *)v9[27];
    if (v19) {
      sub_10005CE20(v19, a2, a3, a4, a5, a6, a7, a8);
    }
    uint64_t v20 = (void *)v9[29];
    if (v20) {
      sub_10005CE20(v20, a2, a3, a4, a5, a6, a7, a8);
    }
    int v21 = (void *)v9[31];
    if (v21) {
      sub_10005CE20(v21, a2, a3, a4, a5, a6, a7, a8);
    }
    sub_10005CE20(*a1, a2, a3, a4, a5, a6, a7, a8);
  }

  *a1 = 0LL;
}

BOOL sub_100022FFC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(const char **)(a1 + 40);
  size_t v4 = strlen(v3);
  return v4 == *(_DWORD *)a2 && !memcmp(v3, *(const void **)(a2 + 8), v4);
}

uint64_t sub_100023050(void *a1, uint64_t a2, unsigned int a3, const char *a4)
{
  if (!a1) {
    return 39LL;
  }
  if (*a1 != qword_10008BE90) {
    return 39LL;
  }
  unsigned int v6 = (void *)a1[2];
  if (!v6 || *v6 != qword_10008CF08) {
    return 39LL;
  }
  uint64_t v10 = a1[7];
  unsigned int v62 = *(_DWORD *)(v10 + 24);
  if (a2)
  {
    uint64_t v11 = *(const char **)(a2 + 40);
    unsigned int v12 = strlen(v11);
    uint64_t v20 = sub_1000281F8(0x16u, v13, v14, v15, v16, v17, v18, v19, v12, (uint64_t)v11);
    uint64_t v28 = sub_1000281F8(0xEu, v21, v22, v23, v24, v25, v26, v27, *(_DWORD *)(a2 + 60), v59);
    sub_1000281F8(0x13u, v29, v30, v31, v32, v33, v34, v35, *(_DWORD *)(a2 + 80), v60);
  }

  else
  {
    uint64_t v28 = &unk_10008BEE0;
    if ((*(_BYTE *)(v10 + 18) & 0x40) != 0) {
      uint64_t v20 = (void *)(v10 + 160);
    }
    else {
      uint64_t v20 = &unk_10008BEE0;
    }
  }

  sub_10002814C(0x1Cu, 0LL, 0LL, 0LL, "isc-%s", "4.1-ESV");
  sub_1000281F8(0x14u, v36, v37, v38, v39, v40, v41, v42, 1u, v58);
  if ((*(_BYTE *)(a1[7] + 19LL) & 8) != 0)
  {
    sub_1000281F8(0x1Au, v43, v44, v45, v46, v47, v48, v49, 0, 0LL);
    if (a3)
    {
LABEL_13:
      sub_1000281F8(0x15u, v43, v44, v45, v46, v47, v48, v49, a3, v61);
      if (a4)
      {
        unsigned int v50 = strlen(a4);
        sub_1000281F8(0x10u, v51, v52, v53, v54, v55, v56, v57, v50, (uint64_t)a4);
      }
    }
  }

  else if (a3)
  {
    goto LABEL_13;
  }

  return sub_10002856C((uint64_t)a1, (uint64_t)v6, 6, v62, v46, v47, v48, v49, v20, (uint64_t)v28);
}

uint64_t sub_100023230(void *a1, int a2, uint64_t a3)
{
  if (*a1 != qword_10008CF38) {
    return 39LL;
  }
  if (!sub_100068648(a3, "link-port")
    || !sub_100068648(a3, "link-name")
    || !sub_100068648(a3, "link-state"))
  {
    return 6LL;
  }

  uint64_t v6 = a1[3];
  else {
    return 23LL;
  }
}

uint64_t sub_1000232F8(uint64_t a1, int a2, _DWORD *a3, int ***a4)
{
  if (*(void *)a1 != qword_10008CF38) {
    return 39LL;
  }
  if (!sub_100068648((uint64_t)a3, "link-port")) {
    return sub_100068920( a4,  a3,  (const char *)*(unsigned int *)(a1 + 40),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  893LL);
  }
  if (sub_100068648((uint64_t)a3, "link-state"))
  {
    uint64_t v8 = *(void *)(a1 + 24);
    else {
      return 23LL;
    }
  }

  else
  {
    uint64_t v10 = *(unsigned int *)(a1 + 48);
    if (v10 < 4)
    {
      uint64_t v11 = off_100089080[v10];
      unsigned int v12 = a4;
      uint64_t v13 = a3;
      uint64_t v14 = 902LL;
    }

    else
    {
      uint64_t v11 = "invalid link state";
      unsigned int v12 = a4;
      uint64_t v13 = a3;
      uint64_t v14 = 899LL;
    }

    return sub_100068B64(v12, v13, v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", v14);
  }

uint64_t sub_100023428( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)a1 != qword_10008BE90) {
    return 39LL;
  }
  uint64_t v13 = *(void *)(a1 + 32);
  unsigned int v12 = (int **)(a1 + 32);
  if (v13) {
    sub_100040E08(v12, a2, a3, a4, a5, a6, a7, a8);
  }
  if (*(void *)(a1 + 56)) {
    sub_100022EDC((void **)(a1 + 56), a2, a3, a4, a5, a6, a7, a8);
  }
  uint64_t v15 = *(void *)(a1 + 64);
  uint64_t v14 = (_DWORD **)(a1 + 64);
  if (v15) {
    sub_10005CFEC(v14, a2, a3);
  }
  return 0LL;
}

uint64_t sub_1000234BC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)a3 != qword_10008BE90) {
    return 39LL;
  }
  uint64_t result = sub_10005F114(a1, "link-port");
  if (!(_DWORD)result)
  {
    uint64_t result = sub_10005EF64(a1, 4u);
    if (!(_DWORD)result)
    {
      uint64_t result = sub_10005EF64(a1, *(_DWORD *)(a3 + 40));
      if (!(_DWORD)result)
      {
        uint64_t result = sub_10005F114(a1, "link-state");
        if (!(_DWORD)result)
        {
          uint64_t v7 = *(unsigned int *)(a3 + 48);
          uint64_t v8 = v7 < 4 ? off_100089080[v7] : "invalid link state";
          uint64_t result = sub_10005F180(a1, v8);
          if (!(_DWORD)result)
          {
            uint64_t v9 = *(void *)(a3 + 24);
            else {
              return 0LL;
            }
          }
        }
      }
    }
  }

  return result;
}

uint64_t sub_1000235AC(void **a1, uint64_t a2, uint64_t a3)
{
  return sub_10005CE50(a1, (void *)qword_10008BE98, 0LL, a2, a3);
}

uint64_t sub_1000235D0(void *a1, char *__s1, uint64_t *a3)
{
  uint64_t v28 = a3;
  if (!a1 || *a1 != qword_10008BE98) {
    return 39LL;
  }
  if (!strcmp(__s1, "connect"))
  {
    uint64_t v15 = v28++;
    uint64_t v16 = *v15;
    if (*v15 && *(void *)v16 == qword_10008CF08)
    {
      uint64_t v17 = qword_10008BE08;
      if (qword_10008BE08)
      {
        while (!sub_1000237F0(v17, (const void *)(v16 + 48), 4u))
        {
          uint64_t v17 = *(void *)(v17 + 32);
          if (!v17) {
            goto LABEL_15;
          }
        }

        uint64_t v27 = 0LL;
        uint64_t v4 = sub_10005CE50( (void **)&v27,  (void *)qword_10008BE90,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  1108LL);
        if ((_DWORD)v4) {
          return v4;
        }
        uint64_t v19 = v27;
        v27[10] = bswap32(*(unsigned __int16 *)(v16 + 46)) >> 16;
        uint64_t v4 = sub_10005CFB8((void *)v19 + 2, v16);
        if ((_DWORD)v4
          || (uint64_t v4 = sub_10005CFB8((void *)(v16 + 24), (uint64_t)v27), (_DWORD)v4)
          || (uint64_t v4 = sub_10005CFB8((void *)v27 + 8, v17), (_DWORD)v4))
        {
          sub_10005CFEC(&v27, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 1117LL);
          sub_1000622D4("failover: listener: picayune failure.", v20, v21, v22, v23, v24, v25, v26, (char)v27);
          sub_100060130(v16, 1);
          return v4;
        }

        sub_100067DF8((uint64_t)v27);
        return sub_10005CFEC(&v27, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 1135LL);
      }

      else
      {
LABEL_15:
        sub_1000622D4("failover: listener: no matching state", v6, v7, v8, v9, v10, v11, v12, (char)v27);
        return sub_100060130(v16, 1);
      }
    }

    return 39LL;
  }

  uint64_t v13 = a1[3];
  if (!v13) {
    return 23LL;
  }
  uint64_t v14 = *(uint64_t (**)(void))(*(void *)v13 + 40LL);
  if (!v14) {
    return 23LL;
  }
  return v14();
}

uint64_t sub_1000237F0(uint64_t a1, const void *a2, unsigned int a3)
{
  uint64_t v18 = 0LL;
  uint64_t v19 = 0LL;
  uint64_t v20 = 0LL;
  if (!sub_100057AA4( &v18,  0LL,  0LL,  0LL,  0LL,  0LL,  &qword_10008C730,  *(void *)(a1 + 88),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  0xDC1u)) {
    return 0LL;
  }
  int v10 = 0;
  unsigned int v11 = v20;
  uint64_t v12 = v19;
  while (a3 - 1 + v10 < v11)
  {
    int v13 = v10 + a3;
    int v14 = memcmp((const void *)(v12 + v10), a2, a3);
    int v10 = v13;
    if (!v14)
    {
      uint64_t v15 = 1LL;
      uint64_t v16 = 3525LL;
      goto LABEL_8;
    }
  }

  uint64_t v15 = 0LL;
  uint64_t v16 = 3529LL;
LABEL_8:
  sub_100034EA8( &v18,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  v16,  v5,  v6,  v7,  v8,  v9);
  return v15;
}

uint64_t sub_1000238E4(void *a1)
{
  if (*a1 != qword_10008BE98) {
    return 39LL;
  }
  uint64_t v2 = a1[3];
  else {
    return 23LL;
  }
}

uint64_t sub_100023924(void *a1)
{
  if (*a1 != qword_10008BE98) {
    return 39LL;
  }
  uint64_t v2 = a1[3];
  else {
    return 23LL;
  }
}

uint64_t sub_100023964(void *a1, uint64_t a2, uint64_t a3)
{
  if (*a1 != qword_10008BE98) {
    return 39LL;
  }
  uint64_t v5 = a1[4];
  uint64_t v4 = (_DWORD **)(a1 + 4);
  if (v5) {
    sub_10005CFEC(v4, a2, a3);
  }
  return 0LL;
}

uint64_t sub_1000239A4(uint64_t a1, uint64_t a2, void *a3)
{
  if (*a3 != qword_10008BE98) {
    return 39LL;
  }
  uint64_t v4 = a3[3];
  else {
    return 0LL;
  }
}

uint64_t sub_1000239E4(uint64_t a1)
{
  int v10 = 0LL;
  uint64_t v2 = sub_1000683F8(a1, 0, "local-port");
  if (!(_DWORD)v2)
  {
    uint64_t v4 = v10[2];
    if (v4)
    {
      uint64_t v2 = sub_100068C24(&v11, v4);
      sub_10005D71C(&v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 1215LL);
      if (!(_DWORD)v2)
      {
        uint64_t v12 = 0LL;
        sub_10005CE50( (void **)&v12,  (void *)qword_10008BEA0,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  1220LL);
        int v5 = v11;
        uint64_t v6 = (uint64_t)v12;
        v12[14] = v11;
        uint64_t v7 = sub_1000638EC(v6, v5, 1);
        if ((_DWORD)v7)
        {
          uint64_t v2 = v7;
          uint64_t v8 = 1225LL;
        }

        else
        {
          uint64_t v9 = sub_10005CFB8((void *)(a1 + 16), (uint64_t)v12);
          if ((_DWORD)v9)
          {
            uint64_t v2 = v9;
            uint64_t v8 = 1232LL;
          }

          else
          {
            uint64_t v2 = sub_10005CFB8((void *)v12 + 3, a1);
            uint64_t v8 = 1236LL;
          }
        }

        sub_10005CFEC(&v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", v8);
      }
    }

    else
    {
      sub_10005D71C(&v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 1210LL);
      return 39LL;
    }
  }

  return v2;
}

uint64_t sub_100023B44(void **a1, uint64_t a2, uint64_t a3)
{
  return sub_10005CE50(a1, (void *)qword_10008BEA0, 0LL, a2, a3);
}

uint64_t sub_100023B60(uint64_t a1, char *__s1, uint64_t *a3)
{
  uint64_t v89 = a3;
  if (!a1 || *(void *)a1 != qword_10008BEA0) {
    return 39LL;
  }
  if (!strcmp(__s1, "disconnect"))
  {
    ++v89;
    sub_10005CFEC( (_DWORD **)(a1 + 232),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  1268LL);
    sub_1000216AC(a1, "disconnect");
    if (!*(_DWORD *)(a1 + 240))
    {
      uint64_t v87 = (uint64_t *)(qword_10008CE80 + 90);
      int v88 = 0;
      int v14 = sub_100021C74;
LABEL_34:
      sub_10003BEE8( &v87,  (uint64_t)v14,  (uint64_t *)a1,  (uint64_t (*)(void, void, void, void))sub_100021D08,  (uint64_t)sub_100021D0C);
    }

    return 0LL;
  }

  if (strcmp(__s1, "message"))
  {
    uint64_t v12 = *(void *)(a1 + 24);
    else {
      return 23LL;
    }
  }

  uint64_t v15 = v89++;
  uint64_t v16 = *v15;
  uint64_t v17 = *(void *)(*v15 + 56);
  switch(*(_BYTE *)(v17 + 28))
  {
    case 1:
      sub_100025400(a1);
      goto LABEL_30;
    case 2:
      sub_1000622D4("pool response: %ld leases", v17, v6, v7, v8, v9, v10, v11, *(_DWORD *)(v17 + 40));
      goto LABEL_30;
    case 3:
      sub_100024570((_DWORD *)a1, v17, v6, v7, v8, v9, v10, v11);
      goto LABEL_30;
    case 4:
      sub_100024DA0(a1, v17, v6, v7, v8, v9, v10, v11);
      goto LABEL_30;
    case 5:
      if (*(void *)(a1 + 232))
      {
        uint64_t v18 = "already connected";
        uint64_t v19 = (void *)*v15;
        uint64_t v20 = a1;
        unsigned int v21 = 7;
LABEL_42:
        sub_100023050(v19, v20, v21, v18);
LABEL_43:
        uint64_t v48 = *(void *)(v16 + 16);
        int v38 = 1;
        goto LABEL_46;
      }

      if ((*(_BYTE *)(v17 + 17) & 0x80) == 0)
      {
        uint64_t v18 = "no MCLT provided";
        uint64_t v19 = (void *)*v15;
        uint64_t v20 = a1;
        unsigned int v21 = 5;
        goto LABEL_42;
      }

      sub_10005CFB8((void *)(a1 + 232), v16);
      unsigned int v57 = sub_100023050((void *)v16, a1, 0, 0LL);
      if (v57)
      {
        unsigned int v65 = v57;
        sub_10005CFEC( (_DWORD **)(a1 + 232),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  1315LL);
        char v66 = sub_100067900(v65);
        sub_1000622D4("dhcp_failover_send_connectack: %s", v67, v68, v69, v70, v71, v72, v73, v66);
        goto LABEL_43;
      }

      uint64_t v74 = *(_DWORD **)(v16 + 56);
      int v75 = v74[4];
      if ((v75 & 0x4000) != 0) {
        *(_DWORD *)(a1 + 100) = v74[14];
      }
      if ((v75 & 0x80000) != 0) {
        *(_DWORD *)(a1 + 120) = v74[17];
      }
      *(_DWORD *)(a1 + 160) = v74[15];
      sub_1000240E8(a1, v58, v59, v60, v61, v62, v63, v64);
      sub_10003C09C((uint64_t)sub_100022E74, v16);
LABEL_30:
      uint64_t result = 0LL;
      uint64_t v47 = *(void *)(a1 + 232);
      if (v47 && v47 == v16)
      {
        if (*(_DWORD *)(v16 + 48) != 3)
        {
          uint64_t v87 = (uint64_t *)(qword_10008CE80 + *(int *)(a1 + 80));
          int v88 = 0;
          int v14 = sub_1000244E0;
          goto LABEL_34;
        }

        return 0LL;
      }

      return result;
    case 6:
      sub_10003C09C((uint64_t)sub_100022E74, v16);
      uint64_t v29 = *(void *)(v16 + 56);
      int v30 = *(_DWORD *)(v29 + 16);
      if ((v30 & 0x400000) != 0)
      {
        if ((v30 & 0x200000) != 0)
        {
          uint64_t v49 = *(void *)(a1 + 40);
          sub_1000241E8(*(unsigned __int8 *)(v29 + 32));
          sub_10006221C("Failover CONNECT to %s rejected: %s", v50, v51, v52, v53, v54, v55, v56, v49);
          int v38 = 1;
LABEL_45:
          uint64_t v48 = *(void *)(v16 + 16);
LABEL_46:
          sub_100060130(v48, v38);
          return 0LL;
        }

        if (sub_100022FFC(a1, v29 + 160))
        {
          if (*(void *)(a1 + 232))
          {
            uint64_t v31 = 7LL;
            uint64_t v32 = "already connected";
          }

          else
          {
            uint64_t v76 = *(unsigned int *)(v29 + 20);
            if ((qword_10008CE80 <= v76 || qword_10008CE80 - v76 <= 60)
              && (v76 <= qword_10008CE80 || v76 - qword_10008CE80 <= 60))
            {
              sub_10005CFB8((void *)(a1 + 232), v16);
              sub_1000240E8(a1, v77, v78, v79, v80, v81, v82, v83);
              uint64_t v84 = *(_DWORD **)(v16 + 56);
              int v85 = v84[4];
              if ((v85 & 0x4000) != 0) {
                *(_DWORD *)(a1 + 100) = v84[14];
              }
              if ((v85 & 0x80000) != 0)
              {
                int v86 = v84[17];
                *(_DWORD *)(a1 + 120) = v86;
              }

              else
              {
                int v86 = *(_DWORD *)(a1 + 120);
              }

              uint64_t v87 = (uint64_t *)(qword_10008CE80 + v86 / 3);
              int v88 = 0;
              sub_10003BEE8( &v87,  (uint64_t)sub_100024468,  (uint64_t *)a1,  (uint64_t (*)(void, void, void, void))sub_100021D08,  (uint64_t)sub_100021D0C);
              uint64_t v87 = (uint64_t *)(qword_10008CE80 + *(int *)(a1 + 80));
              int v88 = 0;
              sub_10003BEE8( &v87,  (uint64_t)sub_1000244E0,  (uint64_t *)a1,  (uint64_t (*)(void, void, void, void))sub_100021D08,  (uint64_t)sub_100021D0C);
              goto LABEL_30;
            }

            uint64_t v31 = 4LL;
            uint64_t v32 = "time offset too large";
          }
        }

        else
        {
          uint64_t v32 = __str;
          snprintf( __str,  0x400uLL,  "remote failover relationship name %.*s does not match",  *(_DWORD *)(v29 + 160),  *(const char **)(v29 + 168));
          uint64_t v31 = 8LL;
        }
      }

      else
      {
        uint64_t v31 = 8LL;
        uint64_t v32 = "missing relationship-name";
      }

      sub_10006221C("Failover CONNECTACK from %s: %s", v22, v23, v24, v25, v26, v27, v28, *(void *)(a1 + 40));
      sub_100024374(v16, v31, (uint64_t)v32, v33, v34, v35, v36, v37);
      int v38 = 0;
      goto LABEL_45;
    case 7:
      sub_1000251FC(a1, v17, v6, v7, v8, v9, v10, v11);
      goto LABEL_30;
    case 8:
      sub_1000252BC(a1, v17, v6, v7, v8, v9, v10, v11);
      goto LABEL_30;
    case 9:
      sub_10002513C(a1, v17, v6, v7, v8, v9, v10, v11);
      goto LABEL_30;
    case 0xA:
      sub_100025480(a1, v17, v6, v7, v8, v9, v10, v11);
      goto LABEL_30;
    case 0xC:
      if (*(_BYTE *)(v17 + 32))
      {
        uint64_t v39 = *(void *)(a1 + 40);
        sub_1000241E8(*(unsigned __int8 *)(v17 + 32));
        sub_10006221C("Failover DISCONNECT from %s: %s", v40, v41, v42, v43, v44, v45, v46, v39);
      }

      sub_100060130(*(void *)(v16 + 16), 1);
      goto LABEL_30;
    default:
      goto LABEL_30;
  }

uint64_t sub_1000240E8( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 39LL;
  }
  if (*(void *)a1 != qword_10008BEA0) {
    return 39LL;
  }
  uint64_t v10 = *(void *)(a1 + 232);
  if (!v10) {
    return 39LL;
  }
  uint64_t v11 = *(void **)(v10 + 16);
  if (!v11 || *v11 != qword_10008CF08) {
    return 39LL;
  }
  uint64_t v12 = *(unsigned int *)(v10 + 84);
  *(_DWORD *)(v10 + 84) = v12 + 1;
  unsigned int v13 = *(_DWORD *)(a1 + 64);
  if (v13 == 1) {
    unsigned int v13 = *(_DWORD *)(a1 + 128);
  }
  int v14 = sub_1000281F8(0x18u, a2, a3, a4, a5, a6, a7, a8, v13, v34);
  uint64_t v22 = sub_1000281F8(0x17u, v15, v16, v17, v18, v19, v20, v21, *(_DWORD *)(a1 + 216) == 5, v35);
  sub_1000281F8(0x19u, v23, v24, v25, v26, v27, v28, v29, *(void *)(a1 + 72), v36);
  sub_10002856C(v10, (uint64_t)v11, 10, v12, v30, v31, v32, v33, v14, (uint64_t)v22);
  return 0LL;
}

const char *sub_1000241E8(unsigned int a1)
{
  if (a1 > 0xFF) {
    return "Reason code out of range.";
  }
  uint64_t v1 = "Illegal IP address (not part of any address pool).";
  switch(a1)
  {
    case 1u:
      return v1;
    case 2u:
      uint64_t v1 = "Fatal conflict exists: address in use by other client.";
      break;
    case 3u:
      uint64_t v1 = "Missing binding information.";
      break;
    case 4u:
      uint64_t v1 = "Connection rejected, time mismatch too great.";
      break;
    case 5u:
      uint64_t v1 = "Connection rejected, invalid MCLT.";
      break;
    case 6u:
      uint64_t v1 = "Connection rejected, unknown reason.";
      break;
    case 7u:
      uint64_t v1 = "Connection rejected, duplicate connection.";
      break;
    case 8u:
      uint64_t v1 = "Connection rejected, invalid failover partner.";
      break;
    case 9u:
      uint64_t v1 = "TLS not supported.";
      break;
    case 0xAu:
      uint64_t v1 = "TLS supported but not configured.";
      break;
    case 0xBu:
      uint64_t v1 = "TLS required but not supported by partner.";
      break;
    case 0xCu:
      uint64_t v1 = "Message digest not supported.";
      break;
    case 0xDu:
      uint64_t v1 = "Message digest not configured.";
      break;
    case 0xEu:
      uint64_t v1 = "Protocol version mismatch.";
      break;
    case 0xFu:
      uint64_t v1 = "Outdated binding information.";
      break;
    case 0x10u:
      uint64_t v1 = "Less critical binding information.";
      break;
    case 0x11u:
      uint64_t v1 = "No traffic within sufficient time.";
      break;
    case 0x12u:
      uint64_t v1 = "Hash bucket assignment conflict.";
      break;
    case 0x13u:
      uint64_t v1 = "IP not reserved on this server.";
      break;
    case 0x14u:
      uint64_t v1 = "Message digest failed to compare.";
      break;
    case 0x15u:
      uint64_t v1 = "Missing message digest.";
      break;
    default:
      if (a1 == 254)
      {
        uint64_t v1 = "Unknown Error.";
      }

      else
      {
        uint64_t v1 = byte_1000BD230;
        __sprintf_chk( byte_1000BD230,  0,  0x49uLL,  "Undefined-%d: This reason code is not defined in the protocol standard.",  a1);
      }

      break;
  }

  return v1;
}

uint64_t sub_100024374( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 39LL;
  }
  if (*(void *)a1 != qword_10008BE90) {
    return 39LL;
  }
  uint64_t v10 = *(void **)(a1 + 16);
  if (!v10 || *v10 != qword_10008CF08) {
    return 39LL;
  }
  uint64_t v11 = (const char *)a3;
  unsigned int v12 = a2;
  if ((_DWORD)a2 && !a3)
  {
    uint64_t v11 = sub_1000241E8(a2);
    uint64_t v10 = *(void **)(a1 + 16);
  }

  uint64_t v13 = *(unsigned int *)(a1 + 84);
  *(_DWORD *)(a1 + 84) = v13 + 1;
  uint64_t v18 = sub_1000281F8(0x15u, a2, a3, a4, a5, a6, a7, a8, v12, v28);
  if (v11)
  {
    unsigned int v19 = strlen(v11);
    uint64_t v27 = sub_1000281F8(0x10u, v20, v21, v22, v23, v24, v25, v26, v19, (uint64_t)v11);
  }

  else
  {
    uint64_t v27 = &unk_10008BEE0;
  }

  return sub_10002856C(a1, (uint64_t)v10, 12, v13, v14, v15, v16, v17, v18, (uint64_t)v27);
}

uint64_t sub_100024468(uint64_t result)
{
  if (result)
  {
    if (*(void *)result == qword_10008BEA0)
    {
      uint64_t result = *(void *)(result + 232);
      if (result)
      {
        uint64_t v1 = *(void **)(result + 16);
        if (v1)
        {
          if (*v1 == qword_10008CF08)
          {
            ++*(_DWORD *)(result + 84);
            return sub_10002856C(result);
          }
        }
      }
    }
  }

  return result;
}

void *sub_1000244E0( void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    if (*result == qword_10008BEA0)
    {
      uint64_t v8 = result[29];
      if (v8)
      {
        uint64_t v9 = *(void **)(v8 + 16);
        if (v9)
        {
          if (*v9 == qword_10008CF08)
          {
            sub_10006221C("timeout waiting for failover peer %s", a2, a3, a4, a5, a6, a7, a8, result[5]);
            return (void *)sub_100060130(*(void *)(v8 + 16), 1);
          }
        }
      }
    }
  }

  return result;
}

uint64_t sub_100024570( _DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((~*(_DWORD *)(a2 + 16) & 0xC) != 0)
  {
    uint64_t v17 = 3LL;
    uint64_t v18 = "binding update lacks required options";
    goto LABEL_11;
  }

  int v10 = *(_DWORD *)(a2 + 44);
  uint64_t v103 = 0LL;
  uint64_t v104 = 0LL;
  *(_DWORD *)__int128 __str = 4;
  *(_DWORD *)&char __str[4] = v10;
  if (!sub_10002A978( &v103,  __str,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  4994LL,  a5,  a6,  a7,  a8))
  {
    uint64_t v17 = 1LL;
    uint64_t v18 = "unknown IP address";
    goto LABEL_11;
  }

  uint64_t v13 = v103;
  uint64_t v14 = *((void *)v103 + 17);
  if (!v14 || ((uint64_t v15 = *(_DWORD **)(v14 + 160)) != 0LL ? (v16 = v15 == a1) : (v16 = 0), !v16))
  {
    uint64_t v17 = 1LL;
    uint64_t v18 = "IP address is covered by a different failover relationship state";
LABEL_11:
    uint64_t v19 = (uint64_t)a1;
    uint64_t v20 = a2;
LABEL_12:
    sub_100026F48(v19, v20, v17, (uint64_t)v18, a5, a6, a7, a8);
    goto LABEL_13;
  }

  if ((*((_BYTE *)v103 + 221) & 0x20) != 0)
  {
    int v22 = *((unsigned __int8 *)v103 + 224);
    if ((*(_BYTE *)(a2 + 16) & 0x40) != 0) {
      uint64_t v23 = *(unsigned int *)(a2 + 48);
    }
    else {
      uint64_t v23 = 0LL;
    }
    if (v22 != 2) {
      sub_100061FB4( "Impossible condition at %s:%d.",  (uint64_t)v103,  v11,  v12,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c");
    }
    int v24 = *(unsigned __int8 *)(a2 + 29);
    if (v24 == 3) {
      goto LABEL_34;
    }
    if (v24 != 2)
    {
LABEL_23:
      if (*(_BYTE *)(a2 + 29) == 2) {
        goto LABEL_34;
      }
    }

    else
    {
      uint64_t v25 = *((void *)v103 + 33);
      if (v23 < v25) {
        goto LABEL_25;
      }
      if (v23 > v25) {
        goto LABEL_34;
      }
    }

    if (!a1[60])
    {
LABEL_25:
      uint64_t v17 = 16LL;
      uint64_t v18 = "incoming update is less critical than outgoing update";
      goto LABEL_11;
    }

LABEL_34:
    sub_100026DD0((uint64_t)a1, (uint64_t)v103);
    uint64_t v13 = v103;
  }

  if (!sub_10002C7F0( (uint64_t)&v104,  (uint64_t)v13,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  5035LL)) {
    goto LABEL_72;
  }
  int v29 = *(unsigned __int8 *)(a2 + 29);
  if ((*(_BYTE *)(a2 + 16) & 0x20) != 0)
  {
    if (v29 == 5)
    {
      uint64_t v17 = 6LL;
      uint64_t v18 = "BNDUPD to ABANDONED with a CHADDR";
      goto LABEL_11;
    }

    size_t v30 = *(unsigned int *)(a2 + 80);
    if (v30 > 0x11)
    {
      uint64_t v17 = 6LL;
      uint64_t v18 = "chaddr too long";
      goto LABEL_11;
    }

    uint64_t v34 = v104;
    if ((_DWORD)v30 == *((unsigned __int8 *)v104 + 203))
    {
      uint64_t v35 = *(const void **)(a2 + 88);
      if (!memcmp(v104 + 51, v35, *(unsigned int *)(a2 + 80)))
      {
        int v33 = 0;
LABEL_53:
        *((_BYTE *)v34 + 203) = v30;
        memcpy(v34 + 51, v35, v30);
        goto LABEL_54;
      }
    }

    else
    {
      uint64_t v35 = *(const void **)(a2 + 88);
    }

    int v33 = 1;
    goto LABEL_53;
  }

  if ((v29 - 2) < 3)
  {
    uint64_t v17 = 3LL;
    uint64_t v18 = "BNDUPD without CHADDR";
    goto LABEL_11;
  }

  if (v29 == 5)
  {
    uint64_t v31 = v104 + 28;
    uint64_t v32 = *((void *)v104 + 14);
    *((_BYTE *)v104 + 203) = 0;
    if (v32) {
      sub_10005515C( v31,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  5068LL,  v28,  a5,  a6,  a7,  a8);
    }
    int v33 = 1;
  }

  else
  {
    int v33 = 0;
  }

            sub_100033898(&v53, v26, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 2519LL);
LABEL_38:
            int v22 = v53;
          }

          while (v53);
        }

        if (v52) {
          sub_10003389C(&v52, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 2527LL);
        }
        if (v53) {
          sub_10003389C(&v53, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 2529LL);
        }
        uint64_t v43 = (void (*)(const char *, ...))sub_1000622D4;
        if (v16 > v50) {
          uint64_t v43 = (void (*)(const char *, ...))sub_10006221C;
        }
        size_t v44 = "balanced";
        if (v16 > v50) {
          size_t v44 = "IMBALANCED";
        }
        uint64_t v45 = *(void *)(i + 48);
        if (v45) {
          int v46 = *(const char **)(v45 + 40);
        }
        else {
          int v46 = &byte_1000728D2;
        }
        v43( "%s pool %lx %s  total %d  free %d  backup %d  lts %d  max-misbal %d",  v44,  i,  v46,  *(_DWORD *)(i + 128),  *(_DWORD *)(i + 132),  *(_DWORD *)(i + 136),  v16,  v50);
        sub_1000268CC(i);
      }
    }

    uint64_t v9 = *(void *)(v48 + 32);
  }

  while (v9);
  if ((_DWORD)v10) {
    sub_10000E1BC();
  }
  return v10;
}

          sub_100061FB4( "Impossible case at %s:%d.",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c");
        }

        return result;
      case 3:
        if ((_DWORD)a3 != 7 && (_DWORD)a3 != 1) {
          goto LABEL_34;
        }
        return 3LL;
      case 4:
        return a3;
      case 6:
        if ((_DWORD)a3 != 7 && (_DWORD)a3 != 1) {
          goto LABEL_34;
        }
        return a3;
      case 7:
        return a3;
      default:
        goto LABEL_34;
    }
  }

  return a3;
}

    while (1)
    {
      uint64_t v6 = *v7;
      if (!*v7) {
        break;
      }
      if (v6 == 9 || v6 == 32) {
        goto LABEL_5;
      }
      ++v7;
    }
  }

  return result;
}

LABEL_72:
    uint64_t v17 = 6LL;
    uint64_t v18 = "no memory";
    goto LABEL_11;
  }

  uint64_t v36 = v104;
  uint64_t v37 = (_DWORD *)*((void *)v104 + 23);
  if (v37 && ((unsigned int v38 = *(unsigned __int8 *)(a2 + 29), v38 > 7) || ((1 << v38) & 0xC2) == 0))
  {
    if (v37 != v104 + 49)
    {
      sub_10005CE20( v37,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  5117LL,  v28,  a5,  a6,  a7,  a8);
      uint64_t v36 = v104;
    }

    *((void *)v36 + 23) = 0LL;
    v36[48] = 0;
    BOOL v39 = 1;
  }

  else
  {
    BOOL v39 = 0;
  }

      uint64_t v48 = 0;
LABEL_73:
      a8 = v148;
      if (v148) {
        goto LABEL_75;
      }
LABEL_74:
      if (v48)
      {
LABEL_75:
        LODWORD(v151) = 0;
        if (!a8)
        {
          if (v48)
          {
            int v42 = v145;
            sub_100034E60( (uint64_t)&v149,  (uint64_t)&v143,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  1336LL,  (uint64_t)a5,  a6,  a7,  0LL);
            sub_100034EA8( &v143,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  1337LL,  v88,  v89,  v90,  v91,  v92);
          }

          else
          {
            int v42 = 0;
          }

          goto LABEL_85;
        }

        sub_100057AA4( &v149,  a5,  a6,  a7,  v128,  v32,  a10,  (uint64_t)a8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  0x51Du);
        int v42 = v151;
        if ((_DWORD)v151)
        {
          if (v48)
          {
            int v42 = v145 + v151;
            uint64_t v140 = 0LL;
            if (sub_1000345C4( &v140,  (int)v145 + (int)v151,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  1340LL))
            {
              memcpy(v140 + 1, v150, v151);
              memcpy((char *)v140 + v151 + 4, v144, v145);
              sub_100034EA8( &v149,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  1349LL,  v62,  v63,  v64,  v65,  v66);
              sub_100034EA8( &v143,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  1350LL,  v67,  v68,  v69,  v70,  v71);
              uint64_t v150 = (char *)(v140 + 1);
              sub_100033F18( &v149,  v140,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  1352LL,  v72,  v73,  v74,  v75);
              sub_10003462C( &v140,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  1353LL,  v76,  v77,  v78,  v79,  v80);
              uint64_t v151 = v42;
              goto LABEL_85;
            }

            sub_100040E08( &v148,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  1341LL,  v57,  v58,  v59,  v60,  v61);
            sub_100034EA8( &v149,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  1342LL,  v107,  v108,  v109,  v110,  v111);
            int v86 = &v143;
            uint64_t v87 = 1343LL;
LABEL_81:
            sub_100034EA8( v86,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  v87,  v81,  v82,  v83,  v84,  v85);
LABEL_137:
            uint64_t v34 = (void *)&unk_1000BD000;
            goto LABEL_138;
          }

LABEL_78:
  if (*(_BYTE *)(a2 + 29) == 2)
  {
    if (v39 | v33)
    {
      sub_10000F3C0((uint64_t)v103, 0LL);
      if (*((void *)v103 + 14)) {
        sub_10005515C( (void *)v103 + 14,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  5152LL,  v28,  a5,  a6,  a7,  a8);
      }
    }
  }

  int v46 = *(_DWORD *)(a2 + 16);
  if ((v46 & 0x2000000) != 0)
  {
    *((void *)v104 + 10) = *(unsigned int *)(a2 + 72);
    if ((v46 & 0x2000) == 0)
    {
LABEL_84:
      if ((v46 & 0x40000) == 0) {
        goto LABEL_85;
      }
LABEL_89:
      uint64_t v47 = *(unsigned int *)(a2 + 64);
      uint64_t v48 = v104;
      *((void *)v104 + 31) = v47;
      *((void *)v48 + 32) = v47;
      if ((v46 & 0x1000) == 0) {
        goto LABEL_86;
      }
      goto LABEL_90;
    }
  }

  else if ((v46 & 0x2000) == 0)
  {
    goto LABEL_84;
  }

  *((void *)v104 + 11) = *(unsigned int *)(a2 + 52);
  if ((v46 & 0x40000) != 0) {
    goto LABEL_89;
  }
LABEL_85:
  if ((v46 & 0x1000) == 0)
  {
LABEL_86:
    *((_BYTE *)v104 + 221) &= 0xF9u;
    goto LABEL_112;
  }

LABEL_90:
  unsigned int v49 = *(unsigned __int16 *)(a2 + 38);
  if ((v49 & 1) == 0)
  {
    uint64_t v50 = v104;
    char v51 = *((_BYTE *)v104 + 221) & 0xFB;
    goto LABEL_100;
  }

  int v52 = a1[60];
  if (v52 != 1)
  {
    if (v52) {
      goto LABEL_99;
    }
    uint64_t v53 = v103;
    if (*((_BYTE *)v103 + 222) != 1) {
      goto LABEL_99;
    }
LABEL_97:
    if ((*((_BYTE *)v53 + 221) & 4) == 0)
    {
      uint64_t v17 = 19LL;
      uint64_t v18 = "Address is not reserved.";
      goto LABEL_11;
    }

    goto LABEL_99;
  }

  uint64_t v53 = v103;
  if (*((_BYTE *)v103 + 222) == 7) {
    goto LABEL_97;
  }
LABEL_99:
  uint64_t v50 = v104;
  char v51 = *((_BYTE *)v104 + 221) | 4;
LABEL_100:
  *((_BYTE *)v50 + 221) = v51;
  if ((v49 & 2) == 0)
  {
    char v54 = v51 & 0xFD;
    goto LABEL_110;
  }

  int v55 = a1[60];
  if (v55 != 1)
  {
    if (v55) {
      goto LABEL_109;
    }
    uint64_t v56 = v103;
    if (*((_BYTE *)v103 + 222) != 1) {
      goto LABEL_109;
    }
LABEL_107:
    if ((*((_BYTE *)v56 + 221) & 2) == 0)
    {
      uint64_t v17 = 6LL;
      uint64_t v18 = "Address is not allocated to BOOTP.";
      goto LABEL_11;
    }

    goto LABEL_109;
  }

  uint64_t v56 = v103;
  if (*((_BYTE *)v103 + 222) == 7) {
    goto LABEL_107;
  }
LABEL_109:
  char v54 = v51 | 2;
LABEL_110:
  *((_BYTE *)v50 + 221) = v54;
  if (v49 >= 4) {
    sub_1000622D4("Unknown IP-flags set in BNDUPD (0x%x).", v26, v27, v28, a5, a6, a7, a8, v49);
  }
LABEL_112:
  uint64_t v57 = *(unsigned __int8 *)(a2 + 29);
  if (a1[16] == 2) {
    unsigned int v58 = sub_100028978((uint64_t)v103, (uint64_t)a1, v57, *(unsigned int *)(a2 + 64), a5, a6, a7, a8);
  }
  else {
    unsigned int v58 = sub_100028B74((uint64_t)v103, v26, v57, v28, a5, a6, a7, a8);
  }
  if (v58 != *(unsigned __int8 *)(a2 + 29))
  {
    *(_OWORD *)__int128 __str = *(_OWORD *)(v103 + 14);
    int v106 = v103[18];
    uint64_t v68 = sub_100040144((int *)__str, v59, v60, v61, v62, v63, v64, v65);
    unsigned int v69 = *((unsigned __int8 *)v103 + 222) - 1;
    if (v69 > 6) {
      uint64_t v70 = "unknown";
    }
    else {
      uint64_t v70 = off_1000846B8[(char)v69];
    }
    unsigned int v71 = *(unsigned __int8 *)(a2 + 29) - 1;
    if (v71 > 6) {
      uint64_t v72 = "unknown";
    }
    else {
      uint64_t v72 = off_1000846B8[(char)v71];
    }
    if (snprintf(__str, 0x64uLL, "%s: invalid state transition: %s to %s", v68, v70, v72) >= 0x64) {
      sub_100061FB4( "%s: impossible outbuf overflow",  v73,  v74,  v75,  a5,  a6,  a7,  a8,  (char)"dhcp_failover_process_bind_update");
    }
    uint64_t v18 = __str;
    uint64_t v19 = (uint64_t)a1;
    uint64_t v20 = a2;
    uint64_t v17 = 2LL;
    goto LABEL_12;
  }

  if (v58 <= 6 && ((1 << v58) & 0x58) != 0)
  {
    char v66 = v104;
    *((_BYTE *)v104 + 223) = 1;
    if (a1[60] || (*((_BYTE *)v66 + 221) & 6) != 0) {
      int v67 = 0;
    }
    else {
      int v67 = sub_100028C60((uint64_t)v66);
    }
    LOBYTE(v58) = 1;
  }

  else
  {
    int v67 = 0;
    char v66 = v104;
    *((_BYTE *)v104 + 223) = v58;
  }

  *(_BYTE *)(a2 + 29) = v58;
  if (!sub_10002B1D0((uint64_t)v103, (uint64_t)v66, 0LL, 0LL, 0LL, v63, v64, v65)
    || !sub_10000C554((uint64_t)v103))
  {
    uint64_t v17 = 6LL;
    uint64_t v18 = "database update failed";
    goto LABEL_11;
  }

  sub_100027090((uint64_t)a1, (int *)a2, v76, v77, a5, a6, a7, a8);
  if (v67)
  {
    uint64_t v81 = v103;
    uint64_t v82 = *((void *)v103 + 17);
    int v83 = *(_DWORD *)(v82 + 132);
    LODWORD(v82) = *(_DWORD *)(v82 + 136);
    unsigned int v84 = (((int)v82 + v83) * a1[46] + 50) / 0x64u;
    BOOL v85 = __OFSUB__(v83, (_DWORD)v82);
    int v86 = v83 - v82;
    if (v86 < 0 != v85) {
      ++v86;
    }
    if ((signed int)-v84 < v86 >> 1)
    {
      *((_BYTE *)v103 + 223) = 7;
      uint64_t v87 = qword_10008CE80;
      *((void *)v81 + 30) = qword_10008CE80;
      *((void *)v81 + 10) = v87;
      if (!sub_10002B1D0((uint64_t)v81, 0LL, 0LL, 1LL, 0LL, v78, v79, v80)
        || !sub_10000C554((uint64_t)v103))
      {
        *(_OWORD *)__int128 __str = *(_OWORD *)(v103 + 14);
        int v106 = v103[18];
        char v95 = sub_100040144((int *)__str, v88, v89, v90, v91, v92, v93, v94);
        sub_10006221C("can't commit lease %s for mac addr affinity", v96, v97, v98, v99, v100, v101, v102, v95);
      }

      sub_100025D00((uint64_t)a1);
    }
  }

uint64_t sub_100024DA0( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v78 = 0LL;
  int v10 = *(_DWORD *)(a2 + 44);
  LODWORD(v79) = 4;
  DWORD1(v79) = v10;
  if (!sub_10002A978( &v78,  (const char *)&v79,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  5336LL,  a5,  a6,  a7,  a8)) {
    goto LABEL_28;
  }
  int v18 = *(_DWORD *)(a2 + 16);
  if ((v18 & 0x200000) != 0)
  {
    LODWORD(v79) = 4;
    DWORD1(v79) = v10;
    char v29 = sub_100040144((int *)&v79, v11, v12, v13, v14, v15, v16, v17);
    if ((*(_DWORD *)(a2 + 16) & 0x10000) == 0)
    {
      size_t v30 = sub_1000241E8(*(unsigned __int8 *)(a2 + 32));
      strlen(v30);
      if ((*(_DWORD *)(a2 + 16) & 0x10000) == 0) {
        sub_1000241E8(*(unsigned __int8 *)(a2 + 32));
      }
    }

    sub_10006221C("bind update on %s from %s rejected: %.*s", v22, v23, v24, v25, v26, v27, v28, v29);
    goto LABEL_14;
  }

  uint64_t v19 = v78;
  int v20 = v78[68];
  if (!v20)
  {
LABEL_14:
    char v31 = 1;
    goto LABEL_15;
  }

  if (v20 != *(_DWORD *)(a2 + 24))
  {
LABEL_28:
    LODWORD(v79) = 4;
    DWORD1(v79) = v10;
    char v64 = sub_100040144((int *)&v79, v11, v12, v13, v14, v15, v16, v17);
    sub_1000622D4("bind update on %s got ack from %s: %s.", v65, v66, v67, v68, v69, v70, v71, v64);
    goto LABEL_29;
  }

  if ((v18 & 0x12) != 0) {
    unsigned int v21 = *(_DWORD *)(a2 + 64);
  }
  else {
    unsigned int v21 = v78[60];
  }
  unsigned int v73 = *((unsigned __int8 *)v78 + 224);
  if (v73 > 6 || ((1 << v73) & 0x58) == 0)
  {
    *((void *)v78 + 31) = v21;
    *((void *)v19 + 32) = v21;
    if (v73 != *((unsigned __int8 *)v19 + 222))
    {
      *((_BYTE *)v19 + 223) = v73;
      sub_10002B1D0((uint64_t)v19, 0LL, 0LL, 0LL, 0LL, v15, v16, v17);
      uint64_t v19 = v78;
    }

    sub_10000C554((uint64_t)v19);
    uint64_t v76 = (uint64_t *)(qword_10008CE80 + 2);
    int v77 = 0;
    sub_10003BEE8(&v76, (uint64_t)sub_10000E1B8, 0LL, 0LL, 0LL);
    goto LABEL_14;
  }

  *((void *)v78 + 31) = v21;
  *((void *)v19 + 32) = v21;
  if (*(_DWORD *)(a1 + 240) == 1 && (*((_BYTE *)v19 + 221) & 4) != 0) {
    char v75 = 7;
  }
  else {
    char v75 = 1;
  }
  *((_BYTE *)v19 + 223) = v75;
  *((_BYTE *)v19 + 224) = v75;
  sub_10002B1D0((uint64_t)v19, 0LL, 0LL, 0LL, 0LL, v15, v16, v17);
  sub_10000C554((uint64_t)v78);
  if (*(_DWORD *)(a1 + 240) || (*((_BYTE *)v78 + 221) & 6) != 0 || !sub_100028C60((uint64_t)v78))
  {
    if (*(_DWORD *)(a1 + 64) == 2) {
      sub_10000E1BC();
    }
    goto LABEL_14;
  }

  char v31 = 0;
LABEL_15:
  sub_100026DD0(a1, (uint64_t)v78);
  if (*(_DWORD **)(a1 + 304) != v78)
  {
    if ((v31 & 1) != 0) {
      goto LABEL_27;
    }
LABEL_19:
    int v42 = v78;
    uint64_t v43 = *((void *)v78 + 17);
    int v44 = *(_DWORD *)(v43 + 132);
    LODWORD(v43) = *(_DWORD *)(v43 + 136);
    unsigned int v45 = (((int)v43 + v44) * *(_DWORD *)(a1 + 184) + 50) / 0x64u;
    BOOL v46 = __OFSUB__(v44, (_DWORD)v43);
    int v47 = v44 - v43;
    if (v47 < 0 != v46) {
      ++v47;
    }
    if ((signed int)-v45 < v47 >> 1)
    {
      *((_BYTE *)v78 + 223) = 7;
      uint64_t v48 = qword_10008CE80;
      *((void *)v42 + 10) = qword_10008CE80;
      *((void *)v42 + 30) = v48;
      if (!sub_10002B1D0((uint64_t)v42, 0LL, 0LL, 1LL, 0LL, v32, v33, v34)
        || !sub_10000C554((uint64_t)v78))
      {
        __int128 v79 = *(_OWORD *)(v78 + 14);
        int v80 = v78[18];
        char v56 = sub_100040144((int *)&v79, v49, v50, v51, v52, v53, v54, v55);
        sub_10006221C("can't commit lease %s for client affinity", v57, v58, v59, v60, v61, v62, v63, v56);
      }

      if (*(_DWORD *)(a1 + 64) == 2) {
        sub_10000E1BC();
      }
    }

    goto LABEL_27;
  }

  sub_10003389C( (_DWORD **)(a1 + 304),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  5444LL);
  sub_1000288D0(a1, v35, v36, v37, v38, v39, v40, v41);
  if ((v31 & 1) == 0) {
    goto LABEL_19;
  }
LABEL_27:
  sub_100025D00(a1);
LABEL_29:
  sub_10003389C(&v78, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 5469LL);
  return 0LL;
}

uint64_t sub_10002513C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = (_DWORD **)(a1 + 304);
  if (*(void *)(a1 + 304))
  {
    sub_1000622D4( "Received update request while old update still flying!  Silently discarding old request.",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  v27);
    sub_10003389C(v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 5533LL);
  }

  sub_1000260BC(a1, 0);
  *(_DWORD *)(a1 + 348) = *(_DWORD *)(a2 + 24);
  uint64_t v17 = *(void *)(a1 + 280);
  if (v17)
  {
    sub_100033898(v10, v17, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 5546LL);
    sub_100025D00(a1);
    uint64_t v25 = "Update request from %s: sending update";
  }

  else
  {
    sub_1000288D0(a1, 0LL, v11, v12, v13, v14, v15, v16);
    uint64_t v25 = "Update request from %s: nothing pending";
  }

  sub_1000622D4(v25, v18, v19, v20, v21, v22, v23, v24, *(void *)(a1 + 40));
  return 0LL;
}

uint64_t sub_1000251FC( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = (_DWORD **)(a1 + 304);
  if (*(void *)(a1 + 304))
  {
    sub_1000622D4( "Received update request while old update still flying!  Silently discarding old request.",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  v27);
    sub_10003389C(v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 5568LL);
  }

  sub_1000260BC(a1, 1);
  *(_DWORD *)(a1 + 348) = *(_DWORD *)(a2 + 24);
  uint64_t v17 = *(void *)(a1 + 280);
  if (v17)
  {
    sub_100033898(v10, v17, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 5578LL);
    sub_100025D00(a1);
    uint64_t v25 = "Update request all from %s: sending update";
  }

  else
  {
    sub_1000288D0(a1, 0LL, v11, v12, v13, v14, v15, v16);
    uint64_t v25 = "Update request all from %s: nothing pending";
  }

  sub_1000622D4(v25, v18, v19, v20, v21, v22, v23, v24, *(void *)(a1 + 40));
  return 0LL;
}

uint64_t sub_1000252BC( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(_DWORD *)(a1 + 344) = 0;
  int v16 = *(_DWORD *)(a1 + 64);
  switch(v16)
  {
    case 11:
LABEL_12:
      sub_10006221C("Spurious update-done message.", v9, v10, v11, v12, v13, v14, v15, v22);
      return 0LL;
    case 6:
      if (*(void *)(a1 + 72) + *(unsigned int *)(a1 + 160) > qword_10008CE80)
      {
        int v20 = *(_DWORD *)(a1 + 104);
        if (v20 != 6 && v20 != 9)
        {
          sub_1000258A8(a1, 254);
          uint64_t v23 = (uint64_t *)(*(_DWORD *)(a1 + 160) + *(_DWORD *)(a1 + 72));
          int v24 = 0;
          sub_10003BEE8( &v23,  (uint64_t)sub_1000262B4,  (uint64_t *)a1,  (uint64_t (*)(void, void, void, void))sub_10005CFB8,  (uint64_t)sub_10005CFEC);
          return 0LL;
        }
      }

      uint64_t v18 = a1;
      int v19 = 9;
      goto LABEL_15;
    case 5:
      int v17 = *(_DWORD *)(a1 + 240);
      if (*(_DWORD *)(a1 + 104) == 11)
      {
        if (v17 == 1)
        {
          uint64_t v18 = a1;
          int v19 = 2;
        }

        else
        {
          sub_10006221C( "Secondary is in conflict_done state after conflict resolution, this is illegal.",  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v22);
          uint64_t v18 = a1;
          int v19 = 8;
        }

        goto LABEL_15;
      }

      if (!v17)
      {
        uint64_t v18 = a1;
        int v19 = 11;
LABEL_15:
        sub_1000258A8(v18, v19);
        return 0LL;
      }

      goto LABEL_12;
  }

  return 0LL;
}

uint64_t sub_100025400(uint64_t a1)
{
  *(void *)(a1 + 208) = 0LL;
  uint64_t v8 = sub_10002643C(a1, 0LL, v2, v3, v4, v5, v6, v7);
  int v9 = v8;
  sub_100028834(a1, v8, v10, v11, v12, v13, v14, v15);
  if (v9) {
    return sub_100025D00(a1);
  }
  else {
    return sub_1000622D4( "peer %s: Got POOLREQ, answering negatively!  Peer may be out of leases or database inconsistent.",  v16,  v17,  v18,  v19,  v20,  v21,  v22,  *(void *)(a1 + 40));
  }
}

uint64_t sub_100025480( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1;
  int v9 = *(_DWORD *)(a1 + 104);
  unsigned int v10 = *(unsigned __int8 *)(a2 + 34);
  char v11 = *(_BYTE *)(a2 + 33);
  if (v9 != v10) {
    goto LABEL_4;
  }
  unsigned int v12 = *(_DWORD *)(a1 + 64);
  if (v12 > 0xB)
  {
    if (v12 != 254) {
      sub_100061FB4( "Impossible case at %s:%d.",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c");
    }
    return 0LL;
  }

  int v13 = 1 << v12;
  if ((v13 & 0xC59) == 0)
  {
    if ((v13 & 0x3A4) == 0)
    {
      int v31 = *(_DWORD *)(a1 + 128);
LABEL_17:
      sub_1000258A8(a1, v31);
    }
  }

  else
  {
LABEL_4:
    *(_DWORD *)(a1 + 104) = v10;
    uint64_t v14 = *(void *)(a1 + 40);
    sub_100025FF8(v9);
    sub_100025FF8(v10);
    sub_1000622D4("failover peer %s: peer moves from %s to %s", v15, v16, v17, v18, v19, v20, v21, v14);
    if (!sub_10000DC18(v8) || !sub_10000E1BC()) {
      sub_10006221C( "Unable to record current failover state for %s",  v22,  v23,  v24,  v25,  v26,  v27,  v28,  *(void *)(v8 + 40));
    }
    if (v10 >= 0xC && v10 != 254)
    {
      sub_10006221C("failover peer %s: Invalid state: %d", v22, v23, v24, v25, v26, v27, v28, *(void *)(v8 + 40));
      a1 = v8;
      int v31 = 8;
      goto LABEL_17;
    }

    int v29 = *(_DWORD *)(v8 + 64);
    int v30 = v29;
    if (v29 == 1) {
      int v30 = *(_DWORD *)(v8 + 128);
    }
    switch(v30)
    {
      case 0:
      case 7:
      case 8:
        goto LABEL_54;
      case 1:
        goto LABEL_19;
      case 2:
        switch(v10)
        {
          case 2u:
            sub_100026388(v8);
            break;
          case 4u:
            if (v29 == 1) {
              goto LABEL_64;
            }
            goto LABEL_42;
          case 5u:
          case 0xAu:
          case 0xBu:
            sub_10006221C( "Peer %s: Invalid state transition %s to %s.",  v22,  v23,  v24,  v25,  v26,  v27,  v28,  *(void *)(v8 + 40));
            goto LABEL_31;
          case 6u:
          case 8u:
            goto LABEL_52;
          case 7u:
            uint64_t v32 = v8;
            int v33 = 3;
            goto LABEL_53;
          default:
            goto LABEL_54;
        }

        goto LABEL_54;
      case 3:
        switch(v10)
        {
          case 2u:
          case 3u:
          case 9u:
            goto LABEL_23;
          case 4u:
          case 5u:
          case 0xAu:
          case 0xBu:
            goto LABEL_42;
          case 6u:
          case 8u:
            goto LABEL_52;
          case 7u:
            goto LABEL_54;
          default:
            if (v10 != 254) {
              goto LABEL_54;
            }
LABEL_23:
            sub_100025D00(v8);
            break;
        }

        goto LABEL_39;
      case 4:
        if ((v11 & 1) != 0 || v10 > 0xB) {
          goto LABEL_54;
        }
        if (((1 << v10) & 0xC3C) != 0) {
          goto LABEL_42;
        }
        if (v10 != 9) {
          goto LABEL_54;
        }
        goto LABEL_39;
      case 5:
        switch(v10)
        {
          case 2u:
            sub_10006221C( "Peer %s moves to normal during conflict resolution - panic, shutting down.",  v22,  v23,  v24,  v25,  v26,  v27,  v28,  *(void *)(v8 + 40));
LABEL_31:
            uint64_t v32 = v8;
            int v33 = 8;
            goto LABEL_53;
          case 6u:
LABEL_64:
            uint64_t v32 = v8;
            int v33 = 6;
            goto LABEL_53;
          case 8u:
            goto LABEL_52;
          case 0xBu:
            if (v9 == 5) {
              sub_1000261F0(v8, v22, v23, v24, v25, v26, v27, v28);
            }
            else {
              sub_10006221C( "Peer %s: Unexpected move to conflict-done.",  v22,  v23,  v24,  v25,  v26,  v27,  v28,  *(void *)(v8 + 40));
            }
            break;
          default:
            goto LABEL_54;
        }

        goto LABEL_54;
      case 6:
        switch(v10)
        {
          case 2u:
          case 5u:
          case 0xAu:
          case 0xBu:
            goto LABEL_42;
          case 3u:
          case 4u:
            if (v29 != 6) {
              goto LABEL_54;
            }
            goto LABEL_67;
          case 6u:
            sub_1000622D4("failover peer %s: requesting %s", v22, v23, v24, v25, v26, v27, v28, *(void *)(v8 + 40));
            int v34 = *(_DWORD *)(v8 + 64);
            if (v34 != 6) {
              goto LABEL_55;
            }
LABEL_67:
            sub_1000262BC(v8, v22, v23, v24, v25, v26, v27, v28);
            break;
          case 8u:
            goto LABEL_52;
          default:
            goto LABEL_54;
        }

        goto LABEL_54;
      case 9:
        if (v10 == 2) {
          goto LABEL_39;
        }
        if (v10 == 8) {
          goto LABEL_52;
        }
        if (v10 != 9) {
          goto LABEL_54;
        }
        sub_10006221C("Both servers have entered recover-done!", v22, v23, v24, v25, v26, v27, v28, v36);
LABEL_39:
        uint64_t v32 = v8;
        int v33 = 2;
        goto LABEL_53;
      case 10:
        if (v10 > 0xB) {
          goto LABEL_60;
        }
        if (((1 << v10) & 0xE7C) != 0) {
          goto LABEL_42;
        }
        if (v10 == 8)
        {
LABEL_52:
          uint64_t v32 = v8;
          int v33 = 4;
          goto LABEL_53;
        }

uint64_t sub_10002589C(int a1)
{
  return sub_1000216AC(a1, "disconnect");
}

uint64_t sub_1000258A8(uint64_t a1, int a2)
{
  unsigned int v4 = *(_DWORD *)(a1 + 64);
  if (v4 <= 5 && ((1 << v4) & 0x34) != 0)
  {
    uint64_t v6 = *(void *)(a1 + 296);
    if (v6)
    {
      for (uint64_t i = *(void *)(a1 + 288); i; uint64_t i = *(void *)(i + 280))
        *(_BYTE *)(i + 221) = *(_BYTE *)(i + 221) & 0xCF | 0x10;
      uint64_t v8 = *(void *)(a1 + 272);
      if (v8)
      {
        sub_100033898(v6 + 280, v8, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 1733LL);
        sub_10003389C( (_DWORD **)(a1 + 272),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  1734LL);
      }

      sub_100033898( a1 + 272,  *(void *)(a1 + 288),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  1737LL);
      if (!*(void *)(a1 + 280)) {
        sub_100033898( a1 + 280,  *(void *)(a1 + 296),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  1746LL);
      }
      sub_10003389C( (_DWORD **)(a1 + 296),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  1748LL);
      sub_10003389C( (_DWORD **)(a1 + 288),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  1749LL);
      *(_DWORD *)(a1 + 312) = 0;
    }

    sub_10003C09C((uint64_t)nullsub_2, a1);
    unsigned int v4 = *(_DWORD *)(a1 + 64);
  }

  uint64_t v9 = *(void *)(a1 + 72);
  if (v4 == 1)
  {
    *(_DWORD *)(a1 + 64) = a2;
  }

  else
  {
    if (a2 != 1 && a2 != 254) {
      *(void *)(a1 + 72) = qword_10008CE80;
    }
    if (a2 == 6 && v4 == 8)
    {
      if (*(_DWORD *)(a1 + 104) == 4 && !*(void *)(a1 + 272) && !*(void *)(a1 + 288)) {
        *(void *)(a1 + 72) = qword_10008CE80 - *(unsigned int *)(a1 + 160);
      }
      *(_DWORD *)(a1 + 64) = 6;
    }

    else
    {
      *(_DWORD *)(a1 + 64) = a2;
      if (a2 == 1) {
        *(_DWORD *)(a1 + 128) = v4;
      }
    }
  }

  if (sub_10000DC18(a1) && sub_10000E1BC())
  {
    uint64_t v17 = *(void *)(a1 + 40);
    sub_100025FF8(v4);
    sub_100025FF8(*(_DWORD *)(a1 + 64));
    sub_1000622D4("failover peer %s: I move from %s to %s", v18, v19, v20, v21, v22, v23, v24, v17);
    if (a2 != 1 && v4 == 1) {
      sub_10003C09C((uint64_t)sub_10002589C, a1);
    }
    sub_100025EC0(a1, v25, v26, v27, v28, v29, v30, v31);
    if (*(void *)(a1 + 232)) {
      sub_1000240E8(a1, v32, v33, v34, v35, v36, v37, v38);
    }
    uint64_t result = 0LL;
    switch(a2)
    {
      case 1:
        uint64_t v62 = (uint64_t *)(qword_10008CE80 + 15);
        int v63 = 0;
        uint64_t v40 = sub_10002589C;
        goto LABEL_41;
      case 2:
        sub_10003C09C((uint64_t)sub_1000263EC, a1);
        *(void *)(a1 + 208) = 0LL;
        sub_10002643C(a1, 0LL, v42, v43, v44, v45, v46, v47);
        sub_1000260BC(a1, 0);
        if (*(void *)(a1 + 280))
        {
          sub_100025D00(a1);
          sub_1000622D4("Sending updates to %s.", v48, v49, v50, v51, v52, v53, v54, *(void *)(a1 + 40));
        }

        goto LABEL_64;
      case 3:
        return result;
      case 4:
        for (uint64_t j = qword_10008BE50; j; uint64_t j = *(void *)(j + 32))
        {
          for (k = *(uint64_t **)(j + 72); k; k = (uint64_t *)k[4])
          {
            if (k[20] == a1)
            {
              uint64_t v57 = (void *)k[10];
              if (v57)
              {
                uint64_t v58 = *(void *)(a1 + 72) + *(unsigned int *)(a1 + 160);
                do
                {
                  v57[31] = v58;
                  uint64_t v59 = v57[11];
                  if (v58 > v59) {
                    uint64_t v59 = v58;
                  }
                  v57[12] = v59;
                  uint64_t v57 = (void *)v57[4];
                }

                while (v57);
                uint64_t v60 = k[10];
                if (v60)
                {
                  uint64_t v61 = *(uint64_t **)(v60 + 96);
                  if ((uint64_t)v61 < k[15])
                  {
                    k[15] = (uint64_t)v61;
                    uint64_t v62 = v61;
                    int v63 = 0;
                    sub_10003BEE8( &v62,  (uint64_t)sub_10002C5DC,  k,  (uint64_t (*)(void, void, void, void))sub_1000338FC,  (uint64_t)sub_100033900);
                  }
                }
              }
            }
          }
        }

        goto LABEL_64;
      case 5:
        if (!*(_DWORD *)(a1 + 240)) {
          sub_1000261F0(a1, v32, v33, v34, v35, v36, v37, v38);
        }
        goto LABEL_64;
      case 6:
        if (*(void *)(a1 + 232)) {
          sub_1000262BC(a1, v32, v33, v34, v35, v36, v37, v38);
        }
        goto LABEL_64;
      default:
        if (a2 != 254) {
          return result;
        }
        uint64_t v41 = *(void *)(a1 + 72) + *(unsigned int *)(a1 + 160);
        if (v41 <= qword_10008CE80)
        {
          sub_1000258A8(a1, 9LL);
        }

        else
        {
          uint64_t v62 = (uint64_t *)(int)v41;
          int v63 = 0;
          uint64_t v40 = sub_1000262B4;
LABEL_41:
          sub_10003BEE8( &v62,  (uint64_t)v40,  (uint64_t *)a1,  (uint64_t (*)(void, void, void, void))sub_10005CFB8,  (uint64_t)sub_10005CFEC);
        }

LABEL_64:
        uint64_t result = 0LL;
        break;
    }
  }

  else
  {
    sub_10006221C( "Unable to record current failover state for %s",  v10,  v11,  v12,  v13,  v14,  v15,  v16,  *(void *)(a1 + 40));
    *(_DWORD *)(a1 + 64) = v4;
    *(void *)(a1 + 72) = v9;
    return 26LL;
  }

  return result;
}

uint64_t sub_100025D00(uint64_t a1)
{
  uint64_t v16 = 0LL;
  if (*(void *)(a1 + 232))
  {
    if (*(void *)(a1 + 320)) {
      sub_100026A2C(a1);
    }
    if (*(_DWORD *)(a1 + 100) > *(_DWORD *)(a1 + 312))
    {
      uint64_t v2 = (void *)(a1 + 272);
      while (*v2)
      {
        sub_100033898(&v16, *v2, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 2684LL);
        uint64_t v9 = sub_100026AFC(a1, (uint64_t)v16, v3, v4, v5, v6, v7, v8);
        if ((_DWORD)v9)
        {
          uint64_t v14 = v9;
          sub_10003389C(&v16, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 2689LL);
          return v14;
        }

        *((_BYTE *)v16 + 221) &= ~0x10u;
        sub_10003389C( (_DWORD **)(a1 + 272),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  2696LL);
        uint64_t v10 = *((void *)v16 + 35);
        if (v10)
        {
          sub_100033898(a1 + 272, v10, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 2699LL);
          uint64_t v11 = (_DWORD **)(v16 + 70);
          uint64_t v12 = 2700LL;
        }

        else
        {
          uint64_t v11 = (_DWORD **)(a1 + 280);
          uint64_t v12 = 2702LL;
        }

        sub_10003389C(v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", v12);
        if (*(void *)(a1 + 288))
        {
          sub_100033898( *(void *)(a1 + 296) + 280LL,  v16,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  2708LL);
          sub_10003389C( (_DWORD **)(a1 + 296),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  2709LL);
        }

        else
        {
          sub_100033898(a1 + 288, v16, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 2711LL);
        }

        sub_100033898(a1 + 296, v16, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 2719LL);
        *((_BYTE *)v16 + 221) |= 0x20u;
        sub_10003389C(&v16, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 2721LL);
        unsigned int v13 = *(_DWORD *)(a1 + 312) + 1;
        *(_DWORD *)(a1 + 312) = v13;
        if (*(_DWORD *)(a1 + 100) <= v13) {
          return 0LL;
        }
      }
    }
  }

  return 0LL;
}

uint64_t sub_100025EC0( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *(_DWORD *)(a1 + 64);
  uint64_t v9 = &byte_1000728D2;
  int v10 = 3;
  uint64_t v11 = " (my state unknown)";
  switch(v8)
  {
    case 0:
      goto LABEL_15;
    case 1:
      uint64_t v9 = " (startup)";
      int v10 = 5;
      goto LABEL_8;
    case 2:
      int v10 = 1;
      goto LABEL_8;
    case 3:
      int v10 = 2;
      goto LABEL_8;
    case 4:
LABEL_8:
      *(_DWORD *)(a1 + 216) = v10;
      *(void *)(a1 + 224) = v9;
      unsigned int v12 = *(_DWORD *)(a1 + 104) - 4;
      if (v12 > 7 || ((0xC3u >> v12) & 1) == 0) {
        return 0LL;
      }
      uint64_t v11 = off_100084530[v12];
LABEL_15:
      *(_DWORD *)(a1 + 216) = 4;
      *(void *)(a1 + 224) = v11;
      return 0LL;
    case 5:
    case 10:
    case 11:
      uint64_t v11 = " (resolving conflicts)";
      goto LABEL_15;
    case 6:
      uint64_t v11 = " (recovering)";
      goto LABEL_15;
    case 7:
      uint64_t v11 = " (paused)";
      goto LABEL_15;
    case 8:
      uint64_t v11 = " (shut down)";
      goto LABEL_15;
    case 9:
      uint64_t v11 = " (recover done)";
      goto LABEL_15;
    default:
      if (v8 != 254) {
        sub_100061FB4( "Impossible case at %s:%d.\n",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c");
      }
      uint64_t v11 = " (recover wait)";
      goto LABEL_15;
  }

const char *sub_100025FF8(int a1)
{
  switch(a1)
  {
    case 1:
      uint64_t result = "startup";
      break;
    case 2:
      uint64_t result = "normal";
      break;
    case 3:
      uint64_t result = "communications-interrupted";
      break;
    case 4:
      uint64_t result = "partner-down";
      break;
    case 5:
      uint64_t result = "potential-conflict";
      break;
    case 6:
      uint64_t result = "recover";
      break;
    case 7:
      uint64_t result = "paused";
      break;
    case 8:
      uint64_t result = "shutdown";
      break;
    case 9:
      uint64_t result = "recover-done";
      break;
    case 10:
      uint64_t result = "resolution-interrupted";
      break;
    case 11:
      uint64_t result = "conflict-done";
      break;
    default:
      if (a1 == 254) {
        uint64_t result = "recover-wait";
      }
      else {
        uint64_t result = "unknown-state";
      }
      break;
  }

  return result;
}

uint64_t sub_1000260BC(uint64_t a1, int a2)
{
  for (uint64_t i = qword_10008BE50; i; uint64_t i = *(void *)(i + 32))
  {
    for (uint64_t j = *(void *)(i + 72); j; uint64_t j = *(void *)(j + 32))
    {
      if (*(void *)(j + 160) == a1)
      {
        uint64_t v6 = 0LL;
        v9[0] = j + 88;
        v9[1] = j + 72;
        v9[2] = j + 80;
        v9[3] = j + 104;
        v9[4] = j + 96;
        v9[5] = j + 112;
        do
        {
          for (uint64_t k = *(void *)v9[v6]; k; uint64_t k = *(void *)(k + 32))
          {
            if ((*(_BYTE *)(k + 221) & 0x30) == 0 && (a2 || v6 == 2 || *(void *)(k + 240) > *(void *)(k + 256)))
            {
              *(_BYTE *)(k + 224) = *(_BYTE *)(k + 222);
              sub_100026CEC(k, 0);
            }
          }

          ++v6;
        }

        while (v6 != 6);
      }
    }
  }

  return 0LL;
}

uint64_t sub_1000261F0( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 232);
  if (!v9) {
    return 39LL;
  }
  if (*(void *)v9 != qword_10008BE90) {
    return 39LL;
  }
  unsigned int v12 = *(void **)(v9 + 16);
  if (!v12 || *v12 != qword_10008CF08) {
    return 39LL;
  }
  if (*(_DWORD *)(a1 + 344)) {
    return 35LL;
  }
  uint64_t v13 = *(unsigned int *)(v9 + 84);
  *(_DWORD *)(v9 + 84) = v13 + 1;
  uint64_t v10 = sub_10002856C(v9, (uint64_t)v12, 9, v13, a5, a6, a7, a8, 0LL, v21);
  if (!(_DWORD)v10) {
    *(_DWORD *)(a1 + 344) = 9;
  }
  sub_1000622D4("Sent update request message to %s", v14, v15, v16, v17, v18, v19, v20, *(void *)(a1 + 40));
  return v10;
}

uint64_t sub_1000262B4(uint64_t a1)
{
  return sub_1000258A8(a1, 9LL);
}

uint64_t sub_1000262BC( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 232);
  if (!v9) {
    return 39LL;
  }
  if (*(void *)v9 != qword_10008BE90) {
    return 39LL;
  }
  unsigned int v12 = *(void **)(v9 + 16);
  if (!v12 || *v12 != qword_10008CF08) {
    return 39LL;
  }
  int v13 = *(_DWORD *)(a1 + 344);
  if (v13 != 9 && v13) {
    return 35LL;
  }
  uint64_t v14 = *(unsigned int *)(v9 + 84);
  *(_DWORD *)(v9 + 84) = v14 + 1;
  uint64_t v10 = sub_10002856C(v9, (uint64_t)v12, 7, v14, a5, a6, a7, a8, 0LL, v22);
  if (!(_DWORD)v10) {
    *(_DWORD *)(a1 + 344) = 7;
  }
  sub_1000622D4("Sent update request all message to %s", v15, v16, v17, v18, v19, v20, v21, *(void *)(a1 + 40));
  return v10;
}

uint64_t sub_100026388(uint64_t a1)
{
  for (uint64_t i = qword_10008BE50; i; uint64_t i = *(void *)(i + 32))
  {
    for (uint64_t j = *(void *)(i + 72); j; uint64_t j = *(void *)(j + 32))
    {
      if (*(void *)(j + 160) == a1) {
        sub_1000268CC(j);
      }
    }
  }

  return 0LL;
}

uint64_t sub_1000263EC( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v17 = 0;
  *(void *)(a1 + 208) = 0LL;
  uint64_t result = sub_10002643C(a1, &v17, a3, a4, a5, a6, a7, a8);
  if ((_DWORD)result) {
    uint64_t result = sub_100025D00(a1);
  }
  if (v17) {
    return sub_100026854(a1, v10, v11, v12, v13, v14, v15, v16);
  }
  return result;
}

uint64_t sub_10002643C( uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v52 = 0LL;
  uint64_t v53 = 0LL;
  if (*(_DWORD *)(a1 + 64) != 2) {
    return 0LL;
  }
  *(void *)(a1 + 200) = qword_10008CE80;
  uint64_t v9 = qword_10008BE50;
  if (!qword_10008BE50) {
    return 0LL;
  }
  uint64_t v10 = 0LL;
  do
  {
    uint64_t v48 = v9;
    for (uint64_t i = *(void *)(v9 + 72); i; uint64_t i = *(void *)(i + 32))
    {
      if (*(void *)(i + 160) == a1)
      {
        int v12 = *(_DWORD *)(i + 132);
        int v13 = *(_DWORD *)(i + 136);
        if (*(_DWORD *)(a1 + 240))
        {
          int v14 = v13 - v12;
          uint64_t v51 = (void *)(i + 96);
          char v15 = 1;
        }

        else
        {
          int v14 = v12 - v13;
          uint64_t v51 = (void *)(i + 88);
          char v15 = 7;
        }

        int v16 = v14 / 2;
        int v17 = v12 + v13;
        int v18 = *(_DWORD *)(a1 + 184);
        unsigned int v19 = v17 * *(_DWORD *)(a1 + 180) + 50;
        if (a2)
        {
          signed int v20 = v19 >= 0x64 ? -2 * (v19 / 0x64) : -1;
          if (v16 < v20) {
            *a2 = 1;
          }
        }

        signed int v50 = v19 / 0x64;
        signed int v21 = (v18 * v17 + 50) / 0x64u;
        sub_1000622D4( "balancing pool %lx %s  total %d  free %d  backup %d  lts %d  max-own (+/-)%d%s",  (uint64_t)a2,  a3,  a4,  a5,  a6,  a7,  a8,  i);
        sub_100033898(&v53, *v51, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 2468LL);
        uint64_t v22 = v53;
        if (v53)
        {
          int v23 = 0;
          do
          {
            if (v52)
            {
              sub_10003389C(&v52, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 2472LL);
              uint64_t v22 = v53;
            }

            uint64_t v24 = *((void *)v22 + 4);
            if (v24) {
              sub_100033898(&v52, v24, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 2474LL);
            }
            if (v23)
            {
              uint64_t v25 = v53;
              if (*((void *)v53 + 11))
              {
                if (v16 <= v21) {
                  break;
                }
              }

              else if (v16 < 1)
              {
                break;
              }
            }

            else
            {
              if (v16 <= -v21) {
                break;
              }
              uint64_t v25 = v53;
              if (!sub_100028C60((uint64_t)v53))
              {
                sub_10003389C(&v53, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 2517LL);
                uint64_t v26 = v52;
                if (!v52) {
                  goto LABEL_36;
                }
                goto LABEL_34;
              }
            }

            *((_BYTE *)v25 + 223) = v15;
            uint64_t v27 = qword_10008CE80;
            *((void *)v25 + 30) = qword_10008CE80;
            *((void *)v25 + 10) = v27;
            if (!sub_10002B1D0(v25, 0LL, 0LL, 1LL, 0LL) || !sub_10000C554((uint64_t)v53))
            {
              __int128 v54 = *(_OWORD *)(v53 + 14);
              int v55 = v53[18];
              char v35 = sub_100040144((int *)&v54, v28, v29, v30, v31, v32, v33, v34);
              sub_10006221C("can't commit lease %s on giveaway", v36, v37, v38, v39, v40, v41, v42, v35);
            }

            --v16;
            uint64_t v10 = (v10 + 1);
            sub_10003389C(&v53, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 2517LL);
            uint64_t v26 = v52;
            if (!v52)
            {
              if (!v23) {
LABEL_36:
              }
                sub_100033898(&v53, *v51, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 2522LL);
              int v23 = 1;
              goto LABEL_38;
            }

uint64_t sub_100026854( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 232);
  if (!v8) {
    return 39LL;
  }
  if (*(void *)v8 != qword_10008BE90) {
    return 39LL;
  }
  uint64_t v10 = *(void **)(v8 + 16);
  if (!v10 || *v10 != qword_10008CF08) {
    return 39LL;
  }
  uint64_t v11 = *(unsigned int *)(v8 + 84);
  *(_DWORD *)(v8 + 84) = v11 + 1;
  return sub_10002856C(v8, (uint64_t)v10, 1, v11, a5, a6, a7, a8, 0LL, v12);
}

uint64_t sub_1000268CC(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 160);
  if (v1 && *(_DWORD *)(v1 + 64) == 2)
  {
    uint64_t v2 = *(void *)(result + 88);
    if (v2)
    {
      uint64_t v3 = *(void *)(v2 + 88);
      BOOL v4 = __OFSUB__(qword_10008CE80, v3);
      uint64_t v2 = qword_10008CE80 - v3;
      if ((v2 < 0) ^ v4 | (v2 == 0)) {
        uint64_t v2 = 0LL;
      }
    }

    uint64_t v5 = *(void *)(result + 96);
    if (v5)
    {
      uint64_t v6 = *(void *)(v5 + 88);
      BOOL v4 = __OFSUB__(qword_10008CE80, v6);
      uint64_t v5 = qword_10008CE80 - v6;
      if ((v5 < 0) ^ v4 | (v5 == 0)) {
        uint64_t v5 = 0LL;
      }
    }

    uint64_t v7 = *(unsigned int *)(v1 + 180);
    uint64_t v8 = v2 * v7 + 50;
    uint64_t v9 = (v5 * v7 + 50) / 100;
    LODWORD(v7) = *(_DWORD *)(v1 + 240);
    BOOL v17 = (_DWORD)v7 == 0;
    char v10 = (_DWORD)v7 != 0;
    char v11 = v17;
    uint64_t v12 = (v8 / 100) << v11;
    uint64_t v13 = v9 << v10;
    if (v12 >= v13) {
      uint64_t v12 = v13;
    }
    uint64_t v14 = *(unsigned int *)(v1 + 192);
    uint64_t v15 = v12 + qword_10008CE80;
    uint64_t v16 = *(void *)(v1 + 200);
    BOOL v17 = v15 >= v16 + v14 || v16 == 0;
    if (v17) {
      uint64_t v18 = v15;
    }
    else {
      uint64_t v18 = v16 + v14;
    }
    uint64_t result = random();
    unsigned int v19 = (uint64_t *)(v18 + result % 5);
    uint64_t v20 = *(void *)(v1 + 208);
    if (v20)
    {
      sub_10003C09C((uint64_t)sub_1000263EC, v1);
    }

    *(void *)(v1 + 208) = v19;
    signed int v21 = v19;
    int v22 = 0;
    return (uint64_t)sub_10003BEE8( &v21,  (uint64_t)sub_1000263EC,  (uint64_t *)v1,  (uint64_t (*)(void, void, void, void))sub_100021D08,  (uint64_t)sub_100021D0C);
  }

  return result;
}

uint64_t sub_100026A2C(uint64_t a1)
{
  uint64_t result = sub_10000E1BC();
  if ((_DWORD)result)
  {
    for (uint64_t i = *(void **)(a1 + 320); i; uint64_t i = *(void **)(a1 + 320))
    {
      unsigned int v19 = i;
      ++*(_DWORD *)i;
      sub_100022EDC( (void **)(a1 + 320),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  2787LL,  v3,  v4,  v5,  v6,  v7);
      uint64_t v13 = (_DWORD *)i[1];
      if (v13)
      {
        *(void *)(a1 + 320) = v13;
        ++*v13;
      }

      sub_100026F48(a1, (uint64_t)i, 0LL, 0LL, v9, v10, v11, v12);
      sub_100022EDC( &v19,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  2795LL,  v14,  v15,  v16,  v17,  v18);
    }

    if (*(void *)(a1 + 328)) {
      sub_100022EDC( (void **)(a1 + 328),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  2799LL,  v3,  v4,  v5,  v6,  v7);
    }
    *(_DWORD *)(a1 + 336) = 0;
    return 1LL;
  }

  return result;
}

uint64_t sub_100026AFC( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 232);
  if (!v8) {
    return 39LL;
  }
  if (*(void *)v8 != qword_10008BE90) {
    return 39LL;
  }
  uint64_t v10 = *(void **)(v8 + 16);
  if (!v10 || *v10 != qword_10008CF08) {
    return 39LL;
  }
  unsigned int v12 = *(unsigned __int8 *)(a2 + 221);
  unsigned int v13 = *(_DWORD *)(v8 + 84);
  if (v13 <= 1) {
    uint64_t v14 = 1LL;
  }
  else {
    uint64_t v14 = v13;
  }
  *(_DWORD *)(v8 + 84) = v14 + 1;
  *(_DWORD *)(a2 + 272) = v14;
  uint64_t v57 = sub_1000281F8(2u, a2, a3, a4, a5, a6, a7, a8, *(_DWORD *)(a2 + 56), a2 + 60);
  char v56 = sub_1000281F8(3u, v15, v16, v17, v18, v19, v20, v21, *(unsigned __int8 *)(a2 + 224), v51);
  if (*(_WORD *)(a2 + 192)) {
    sub_1000281F8(4u, v22, v23, v24, v25, v26, v27, v28, *(unsigned __int16 *)(a2 + 192), *(void *)(a2 + 184));
  }
  unsigned int v29 = v12 & 2 | (v12 >> 2) & 1;
  if (*(_BYTE *)(a2 + 203)) {
    sub_1000281F8(5u, v22, v23, v24, v25, v26, v27, v28, *(unsigned __int8 *)(a2 + 203), a2 + 204);
  }
  sub_1000281F8(0xDu, v22, v23, v24, v25, v26, v27, v28, *(void *)(a2 + 88), v52);
  sub_1000281F8(0x12u, v30, v31, v32, v33, v34, v35, v36, *(void *)(a2 + 240), v53);
  sub_1000281F8(0x19u, v37, v38, v39, v40, v41, v42, v43, *(void *)(a2 + 80), v54);
  if (*(void *)(a2 + 264)) {
    sub_1000281F8(6u, v44, v45, v46, v47, v48, v49, v50, *(void *)(a2 + 264), v55);
  }
  if (v29) {
    sub_1000281F8(0xCu, v44, v45, v46, v47, v48, v49, v50, v29, v55);
  }
  return sub_10002856C(v8, (uint64_t)v10, 3, v14, v47, v48, v49, v50, v57, (uint64_t)v56);
}

uint64_t sub_100026CEC(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 136);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 160);
    if (v3)
    {
      if ((*(_BYTE *)(a1 + 221) & 0x10) == 0)
      {
        if ((*(_BYTE *)(a1 + 221) & 0x20) != 0) {
          sub_100026DD0(v3, a1);
        }
        if (*(void *)(v3 + 272))
        {
          sub_100033898( *(void *)(v3 + 280) + 280LL,  a1,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  2754LL);
          sub_10003389C( (_DWORD **)(v3 + 280),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  2755LL);
        }

        else
        {
          sub_100033898(v3 + 272, a1, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 2757LL);
        }

        sub_100033898(v3 + 280, a1, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 2768LL);
        *(_BYTE *)(a1 + 221) |= 0x10u;
        if (a2) {
          sub_100025D00(v3);
        }
      }
    }
  }

  return 1LL;
}

uint64_t sub_100026DD0(uint64_t result, uint64_t a2)
{
  if ((*(_BYTE *)(a2 + 221) & 0x20) != 0)
  {
    uint64_t v3 = result;
    uint64_t v4 = *(void *)(result + 288);
    if (v4 == a2)
    {
      sub_10003389C( (_DWORD **)(result + 288),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  2868LL);
      uint64_t v9 = *(void *)(a2 + 280);
      if (v9)
      {
        sub_100033898(v3 + 288, v9, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 2871LL);
        uint64_t v7 = (_DWORD **)(a2 + 280);
        uint64_t v8 = 2872LL;
      }

      else
      {
        uint64_t v7 = (_DWORD **)(v3 + 296);
        uint64_t v8 = 2874LL;
      }

uint64_t sub_100026F48( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void **)(a1 + 232);
  if (!v8) {
    return 39LL;
  }
  if (*v8 != qword_10008BE90) {
    return 39LL;
  }
  int v10 = (void *)v8[2];
  if (!v10 || *v10 != qword_10008CF08) {
    return 39LL;
  }
  uint64_t v11 = (const char *)a4;
  unsigned int v12 = a3;
  if ((_DWORD)a3 && !a4)
  {
    uint64_t v11 = sub_1000241E8(a3);
    int v10 = (void *)v8[2];
    uint64_t v14 = *(unsigned int *)(a2 + 24);
    unsigned int v29 = sub_1000281F8(2u, v15, v16, v17, v18, v19, v20, v21, 4u, a2 + 44);
    goto LABEL_10;
  }

  uint64_t v14 = *(unsigned int *)(a2 + 24);
  unsigned int v29 = sub_1000281F8(2u, a2, a3, a4, a5, a6, a7, a8, 4u, a2 + 44);
  if (v12)
  {
LABEL_10:
    uint64_t v30 = sub_1000281F8(0x15u, v22, v23, v24, v25, v26, v27, v28, v12, v39);
    if (v12)
    {
      if (v11)
      {
        unsigned int v31 = strlen(v11);
        sub_1000281F8(0x10u, v32, v33, v34, v35, v36, v37, v38, v31, (uint64_t)v11);
      }
    }

    return sub_10002856C((uint64_t)v8, (uint64_t)v10, 4, v14, v25, v26, v27, v28, v29, (uint64_t)v30);
  }

  uint64_t v30 = &unk_10008BEE0;
  return sub_10002856C((uint64_t)v8, (uint64_t)v10, 4, v14, v25, v26, v27, v28, v29, (uint64_t)v30);
}

uint64_t sub_100027090( uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 320))
  {
    *(void *)(*(void *)(a1 + 328) + 8LL) = a2;
    ++*a2;
    sub_100022EDC( (void **)(a1 + 328),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  2827LL,  a4,  a5,  a6,  a7,  a8);
    int v10 = *a2;
  }

  else
  {
    *(void *)(a1 + 320) = a2;
    int v10 = *a2 + 1;
  }

  *(void *)(a1 + 328) = a2;
  *a2 = v10 + 1;
  int v11 = *(_DWORD *)(a1 + 336) + 1;
  *(_DWORD *)(a1 + 336) = v11;
  if (v11 >= *(_DWORD *)(a1 + 100) >> 1)
  {
    sub_100026A2C(a1);
    int v11 = *(_DWORD *)(a1 + 336);
  }

  if (v11 >= 1)
  {
    uint64_t v13 = (uint64_t *)(qword_10008CE80 + 2);
    int v14 = 0;
    sub_10003BEE8( &v13,  (uint64_t)sub_10002708C,  (uint64_t *)a1,  (uint64_t (*)(void, void, void, void))sub_100021D08,  (uint64_t)sub_100021D0C);
  }

  return 1LL;
}

uint64_t sub_100027174(void *a1, int a2, uint64_t a3, _DWORD *a4)
{
  if (*a1 != qword_10008BEA0) {
    return 39LL;
  }
  uint64_t result = sub_100068648(a3, "name");
  if ((_DWORD)result)
  {
    uint64_t result = sub_100068648(a3, "partner-address");
    if ((_DWORD)result)
    {
      uint64_t result = sub_100068648(a3, "local-address");
      if ((_DWORD)result)
      {
        uint64_t result = sub_100068648(a3, "partner-port");
        if ((_DWORD)result)
        {
          uint64_t result = sub_100068648(a3, "local-port");
          if ((_DWORD)result)
          {
            uint64_t result = sub_100068648(a3, "max-outstanding-updates");
            if ((_DWORD)result)
            {
              uint64_t result = sub_100068648(a3, "mclt");
              if ((_DWORD)result)
              {
                uint64_t result = sub_100068648(a3, "load-balance-max-secs");
                if ((_DWORD)result)
                {
                  uint64_t result = sub_100068648(a3, "load-balance-hba");
                  if ((_DWORD)result)
                  {
                    uint64_t result = sub_100068648(a3, "partner-state");
                    if ((_DWORD)result)
                    {
                      if (sub_100068648(a3, "local-state"))
                      {
                        uint64_t result = sub_100068648(a3, "partner-stos");
                        if ((_DWORD)result)
                        {
                          uint64_t result = sub_100068648(a3, "local-stos");
                          if ((_DWORD)result)
                          {
                            uint64_t result = sub_100068648(a3, "hierarchy");
                            if ((_DWORD)result)
                            {
                              uint64_t result = sub_100068648(a3, "last-packet-sent");
                              if ((_DWORD)result)
                              {
                                uint64_t result = sub_100068648(a3, "last-timestamp-received");
                                if ((_DWORD)result)
                                {
                                  uint64_t result = sub_100068648(a3, "skew");
                                  if ((_DWORD)result)
                                  {
                                    uint64_t result = sub_100068648(a3, "max-response-delay");
                                    if ((_DWORD)result)
                                    {
                                      uint64_t result = sub_100068648(a3, "cur-unacked-updates");
                                      if ((_DWORD)result)
                                      {
                                        uint64_t v8 = a1[3];
                                        else {
                                          return 23LL;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }

                      else
                      {
                        uint64_t result = sub_100068C24(&v10, a4);
                        if (!(_DWORD)result) {
                          return sub_1000258A8((uint64_t)a1, v10);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  return result;
}

uint64_t sub_1000273A0(uint64_t a1, int a2, _DWORD *a3, int ***a4)
{
  if (*(void *)a1 != qword_10008BEA0) {
    return 39LL;
  }
  if (!sub_100068648((uint64_t)a3, "name"))
  {
    int v11 = *(const char **)(a1 + 40);
    if (!v11) {
      return 23LL;
    }
    return sub_100068B64( a4,  a3,  v11,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  3087LL);
  }

  if (!sub_100068648((uint64_t)a3, "partner-address"))
  {
    unsigned int v12 = (uint64_t *)(a1 + 88);
    goto LABEL_30;
  }

  if (!sub_100068648((uint64_t)a3, "local-address"))
  {
    unsigned int v12 = (uint64_t *)(a1 + 48);
LABEL_30:
    uint64_t v13 = *v12;
    uint64_t v21 = 0LL;
    uint64_t v22 = 0LL;
    uint64_t v20 = 0LL;
    if (sub_100057AA4( &v20,  0LL,  0LL,  0LL,  0LL,  0LL,  &qword_10008C730,  v13,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  0xC1Au))
    {
      uint64_t v4 = sub_10006883C( a4,  a3,  v21,  (const char *)v22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  3102LL);
      if (v13 == *(void *)(a1 + 48) && !*(_DWORD *)(a1 + 152)) {
        sub_100034E60( a1 + 136,  (uint64_t)&v20,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  3105LL,  v15,  v16,  v17,  v18);
      }
      sub_100034EA8( &v20,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  3106LL,  v14,  v15,  v16,  v17,  v18);
      return v4;
    }

    return 23LL;
  }

  if (!sub_100068648((uint64_t)a3, "partner-port")) {
    return sub_100068920( a4,  a3,  (const char *)*(unsigned int *)(a1 + 96),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  3113LL);
  }
  if (!sub_100068648((uint64_t)a3, "local-port")) {
    return sub_100068920( a4,  a3,  (const char *)*(unsigned int *)(a1 + 56),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  3116LL);
  }
  if (!sub_100068648((uint64_t)a3, "max-outstanding-updates")) {
    return sub_1000689D0( a4,  a3,  (const char *)*(unsigned int *)(a1 + 60),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  3120LL);
  }
  if (!sub_100068648((uint64_t)a3, "mclt")) {
    return sub_1000689D0( a4,  a3,  (const char *)*(unsigned int *)(a1 + 160),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  3122LL);
  }
  if (!sub_100068648((uint64_t)a3, "load-balance-max-secs")) {
    return sub_100068920( a4,  a3,  (const char *)*(unsigned int *)(a1 + 176),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  3125LL);
  }
  if (sub_100068648((uint64_t)a3, "load-balance-hba"))
  {
    if (sub_100068648((uint64_t)a3, "partner-state"))
    {
      if (sub_100068648((uint64_t)a3, "local-state"))
      {
        if (sub_100068648((uint64_t)a3, "partner-stos"))
        {
          if (sub_100068648((uint64_t)a3, "local-stos"))
          {
            if (sub_100068648((uint64_t)a3, "hierarchy"))
            {
              if (sub_100068648((uint64_t)a3, "last-packet-sent"))
              {
                if (sub_100068648((uint64_t)a3, "last-timestamp-received"))
                {
                  if (sub_100068648((uint64_t)a3, "skew"))
                  {
                    if (sub_100068648((uint64_t)a3, "max-response-delay"))
                    {
                      if (sub_100068648((uint64_t)a3, "cur-unacked-updates"))
                      {
                        uint64_t v9 = *(void *)(a1 + 24);
                        if (v9)
                        {
                          uint64_t v10 = *(uint64_t (**)(void))(*(void *)v9 + 24LL);
                          if (v10) {
                            return v10();
                          }
                        }

                        return 23LL;
                      }

                      return sub_100068920( a4,  a3,  (const char *)*(unsigned int *)(a1 + 312),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  3160LL);
                    }

                    else
                    {
                      return sub_1000689D0( a4,  a3,  (const char *)*(unsigned int *)(a1 + 80),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  3157LL);
                    }
                  }

                  else
                  {
                    return sub_100068920( a4,  a3,  (const char *)*(unsigned int *)(a1 + 264),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  3153LL);
                  }
                }

                else
                {
                  return sub_100068920( a4,  a3,  (const char *)*(unsigned int *)(a1 + 256),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  3151LL);
                }
              }

              else
              {
                return sub_100068920( a4,  a3,  (const char *)*(unsigned int *)(a1 + 248),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  3147LL);
              }
            }

            else
            {
              return sub_1000689D0( a4,  a3,  (const char *)*(unsigned int *)(a1 + 240),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  3144LL);
            }
          }

          else
          {
            return sub_100068920( a4,  a3,  (const char *)*(unsigned int *)(a1 + 72),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  3142LL);
          }
        }

        else
        {
          return sub_100068920( a4,  a3,  (const char *)*(unsigned int *)(a1 + 112),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  3139LL);
        }
      }

      else
      {
        return sub_1000689D0( a4,  a3,  (const char *)*(unsigned int *)(a1 + 64),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  3136LL);
      }
    }

    else
    {
      return sub_1000689D0( a4,  a3,  (const char *)*(unsigned int *)(a1 + 104),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  3133LL);
    }
  }

  else
  {
    uint64_t v19 = *(const void **)(a1 + 168);
    if (!v19) {
      return 23LL;
    }
    return sub_10006883C( a4,  a3,  v19,  (const char *)0x20,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  3129LL);
  }

uint64_t sub_100027898( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)a1 != qword_10008BEA0) {
    return 39LL;
  }
  uint64_t v13 = *(void *)(a1 + 232);
  unsigned int v12 = (_DWORD **)(a1 + 232);
  if (v13) {
    sub_10005CFEC(v12, a2, a3);
  }
  uint64_t v14 = *(void **)(a1 + 40);
  if (v14)
  {
    sub_10005CE20( v14,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  3181LL,  a4,  a5,  a6,  a7,  a8);
    *(void *)(a1 + 40) = 0LL;
  }

  if (*(void *)(a1 + 88)) {
    sub_100040E08((int **)(a1 + 88), a2, a3, a4, a5, a6, a7, a8);
  }
  if (*(void *)(a1 + 48)) {
    sub_100040E08((int **)(a1 + 48), a2, a3, a4, a5, a6, a7, a8);
  }
  uint64_t v15 = *(void **)(a1 + 168);
  if (v15)
  {
    sub_10005CE20(v15, a2, a3, a4, a5, a6, a7, a8);
    *(void *)(a1 + 168) = 0LL;
  }

  if (*(void *)(a1 + 272)) {
    sub_10003389C((_DWORD **)(a1 + 272), a2, a3);
  }
  if (*(void *)(a1 + 280)) {
    sub_10003389C((_DWORD **)(a1 + 280), a2, a3);
  }
  if (*(void *)(a1 + 288)) {
    sub_10003389C((_DWORD **)(a1 + 288), a2, a3);
  }
  if (*(void *)(a1 + 296)) {
    sub_10003389C((_DWORD **)(a1 + 296), a2, a3);
  }
  if (*(void *)(a1 + 304)) {
    sub_10003389C((_DWORD **)(a1 + 304), a2, a3);
  }
  if (*(void *)(a1 + 320)) {
    sub_100022EDC((void **)(a1 + 320), a2, a3, a4, a5, a6, a7, a8);
  }
  if (*(void *)(a1 + 328)) {
    sub_100022EDC((void **)(a1 + 328), a2, a3, a4, a5, a6, a7, a8);
  }
  return 0LL;
}

uint64_t sub_100027A08(void *a1, uint64_t a2, uint64_t a3)
{
  if (*a1 != qword_10008CF08 || *(void *)a3 != qword_10008BEA0) {
    return 39LL;
  }
  uint64_t result = sub_10005F114((uint64_t)a1, "name");
  if (!(_DWORD)result)
  {
    uint64_t result = sub_10005F180((uint64_t)a1, *(char **)(a3 + 40));
    if (!(_DWORD)result)
    {
      uint64_t result = sub_10005F114((uint64_t)a1, "partner-address");
      if (!(_DWORD)result)
      {
        uint64_t result = sub_10005EF64((uint64_t)a1, 8u);
        if (!(_DWORD)result)
        {
          uint64_t result = sub_10005E7A4((uint64_t)a1, a3 + 88, 8u);
          if (!(_DWORD)result)
          {
            uint64_t result = sub_10005F114((uint64_t)a1, "partner-port");
            if (!(_DWORD)result)
            {
              uint64_t result = sub_10005EF64((uint64_t)a1, 4u);
              if (!(_DWORD)result)
              {
                uint64_t result = sub_10005EF64((uint64_t)a1, *(_DWORD *)(a3 + 96));
                if (!(_DWORD)result)
                {
                  uint64_t result = sub_10005F114((uint64_t)a1, "local-address");
                  if (!(_DWORD)result)
                  {
                    uint64_t result = sub_10005EF64((uint64_t)a1, 8u);
                    if (!(_DWORD)result)
                    {
                      uint64_t result = sub_10005E7A4((uint64_t)a1, a3 + 48, 8u);
                      if (!(_DWORD)result)
                      {
                        uint64_t result = sub_10005F114((uint64_t)a1, "local-port");
                        if (!(_DWORD)result)
                        {
                          uint64_t result = sub_10005EF64((uint64_t)a1, 4u);
                          if (!(_DWORD)result)
                          {
                            uint64_t result = sub_10005EF64((uint64_t)a1, *(_DWORD *)(a3 + 56));
                            if (!(_DWORD)result)
                            {
                              uint64_t result = sub_10005F114((uint64_t)a1, "max-outstanding-updates");
                              if (!(_DWORD)result)
                              {
                                uint64_t result = sub_10005EF64((uint64_t)a1, 4u);
                                if (!(_DWORD)result)
                                {
                                  uint64_t result = sub_10005EF64((uint64_t)a1, *(_DWORD *)(a3 + 60));
                                  if (!(_DWORD)result)
                                  {
                                    uint64_t result = sub_10005F114((uint64_t)a1, "mclt");
                                    if (!(_DWORD)result)
                                    {
                                      uint64_t result = sub_10005EF64((uint64_t)a1, 4u);
                                      if (!(_DWORD)result)
                                      {
                                        uint64_t result = sub_10005EF64((uint64_t)a1, *(_DWORD *)(a3 + 160));
                                        if (!(_DWORD)result)
                                        {
                                          uint64_t result = sub_10005F114((uint64_t)a1, "load-balance-max-secs");
                                          if (!(_DWORD)result)
                                          {
                                            uint64_t result = sub_10005EF64((uint64_t)a1, 4u);
                                            if (!(_DWORD)result)
                                            {
                                              uint64_t result = sub_10005EF64((uint64_t)a1, *(_DWORD *)(a3 + 176));
                                              if (!(_DWORD)result)
                                              {
                                                if (!*(void *)(a3 + 168)
                                                  || (uint64_t result = sub_10005F114((uint64_t)a1, "load-balance-hba"),
                                                      !(_DWORD)result)
                                                  && (uint64_t result = sub_10005EF64((uint64_t)a1, 0x20u), !(_DWORD)result)
                                                  && (uint64_t result = sub_10005E7A4((uint64_t)a1, *(void *)(a3 + 168), 0x20u),
                                                      !(_DWORD)result))
                                                {
                                                  uint64_t result = sub_10005F114((uint64_t)a1, "partner-state");
                                                  if (!(_DWORD)result)
                                                  {
                                                    uint64_t result = sub_10005EF64((uint64_t)a1, 4u);
                                                    if (!(_DWORD)result)
                                                    {
                                                      uint64_t result = sub_10005EF64((uint64_t)a1, *(_DWORD *)(a3 + 104));
                                                      if (!(_DWORD)result)
                                                      {
                                                        uint64_t result = sub_10005F114((uint64_t)a1, "local-state");
                                                        if (!(_DWORD)result)
                                                        {
                                                          uint64_t result = sub_10005EF64((uint64_t)a1, 4u);
                                                          if (!(_DWORD)result)
                                                          {
                                                            uint64_t result = sub_10005EF64((uint64_t)a1, *(_DWORD *)(a3 + 64));
                                                            if (!(_DWORD)result)
                                                            {
                                                              uint64_t result = sub_10005F114((uint64_t)a1, "partner-stos");
                                                              if (!(_DWORD)result)
                                                              {
                                                                uint64_t result = sub_10005EF64((uint64_t)a1, 4u);
                                                                if (!(_DWORD)result)
                                                                {
                                                                  uint64_t result = sub_10005EF64( (uint64_t)a1,  *(_DWORD *)(a3 + 112));
                                                                  if (!(_DWORD)result)
                                                                  {
                                                                    uint64_t result = sub_10005F114((uint64_t)a1, "local-stos");
                                                                    if (!(_DWORD)result)
                                                                    {
                                                                      uint64_t result = sub_10005EF64((uint64_t)a1, 4u);
                                                                      if (!(_DWORD)result)
                                                                      {
                                                                        uint64_t result = sub_10005EF64( (uint64_t)a1,  *(_DWORD *)(a3 + 72));
                                                                        if (!(_DWORD)result)
                                                                        {
                                                                          uint64_t result = sub_10005F114( (uint64_t)a1,  "hierarchy");
                                                                          if (!(_DWORD)result)
                                                                          {
                                                                            uint64_t result = sub_10005EF64((uint64_t)a1, 4u);
                                                                            if (!(_DWORD)result)
                                                                            {
                                                                              uint64_t result = sub_10005EF64( (uint64_t)a1,  *(_DWORD *)(a3 + 240));
                                                                              if (!(_DWORD)result)
                                                                              {
                                                                                uint64_t result = sub_10005F114( (uint64_t)a1,  "last-packet-sent");
                                                                                if (!(_DWORD)result)
                                                                                {
                                                                                  uint64_t result = sub_10005EF64( (uint64_t)a1,  4u);
                                                                                  if (!(_DWORD)result)
                                                                                  {
                                                                                    uint64_t result = sub_10005EF64( (uint64_t)a1,  *(_DWORD *)(a3 + 248));
                                                                                    if (!(_DWORD)result)
                                                                                    {
                                                                                      uint64_t result = sub_10005F114( (uint64_t)a1,  "last-timestamp-received");
                                                                                      if (!(_DWORD)result)
                                                                                      {
                                                                                        uint64_t result = sub_10005EF64( (uint64_t)a1,  4u);
                                                                                        if (!(_DWORD)result)
                                                                                        {
                                                                                          uint64_t result = sub_10005EF64( (uint64_t)a1,  *(_DWORD *)(a3 + 256));
                                                                                          if (!(_DWORD)result)
                                                                                          {
                                                                                            uint64_t result = sub_10005F114((uint64_t)a1, "skew");
                                                                                            if (!(_DWORD)result)
                                                                                            {
                                                                                              uint64_t result = sub_10005EF64((uint64_t)a1, 4u);
                                                                                              if (!(_DWORD)result)
                                                                                              {
                                                                                                uint64_t result = sub_10005EF64((uint64_t)a1, *(_DWORD *)(a3 + 264));
                                                                                                if (!(_DWORD)result)
                                                                                                {
                                                                                                  uint64_t result = sub_10005F114((uint64_t)a1, "max-response-delay");
                                                                                                  if (!(_DWORD)result)
                                                                                                  {
                                                                                                    uint64_t result = sub_10005EF64((uint64_t)a1, 4u);
                                                                                                    if (!(_DWORD)result)
                                                                                                    {
                                                                                                      uint64_t result = sub_10005EF64((uint64_t)a1, *(_DWORD *)(a3 + 80));
                                                                                                      if (!(_DWORD)result)
                                                                                                      {
                                                                                                        uint64_t result = sub_10005F114((uint64_t)a1, "cur-unacked-updates");
                                                                                                        if (!(_DWORD)result)
                                                                                                        {
                                                                                                          uint64_t result = sub_10005EF64((uint64_t)a1, 4u);
                                                                                                          if (!(_DWORD)result)
                                                                                                          {
                                                                                                            uint64_t result = sub_10005EF64((uint64_t)a1, *(_DWORD *)(a3 + 312));
                                                                                                            if (!(_DWORD)result)
                                                                                                            {
                                                                                                              uint64_t v7 = *(void *)(a3 + 24);
                                                                                                              else {
                                                                                                                return 0LL;
                                                                                                              }
                                                                                                            }
                                                                                                          }
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  return result;
}

uint64_t sub_100027E78(void *a1, int a2, uint64_t a3)
{
  uint64_t v15 = 0LL;
  if (!a3) {
    return 46LL;
  }
  if (!sub_1000683F8(a3, a2, "handle"))
  {
    uint64_t v6 = sub_100062F48(a1, v15[2]);
    sub_10005D71C(&v15, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 3451LL);
    if ((_DWORD)v6) {
      return v6;
    }
    if (*(void *)*a1 != qword_10008BEA0)
    {
      sub_10005CFEC((_DWORD **)a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 3457LL);
      return 39LL;
    }
  }

  uint64_t v7 = qword_10008BE08;
  if (qword_10008BE08)
  {
    uint64_t v8 = v15[2];
    int v9 = v8[2];
    uint64_t v10 = v8 + 3;
    while (1)
    {
      unsigned int v11 = strlen(*(const char **)(v7 + 40));
      uint64_t v7 = *(void *)(v7 + 32);
      if (!v7) {
        goto LABEL_16;
      }
    }

    int v12 = 0;
  }

  else
  {
LABEL_16:
    int v12 = 1;
  }

  sub_10005D71C(&v15, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 3472LL);
  uint64_t v13 = (_DWORD *)*a1;
  if (*a1 && v13 != (_DWORD *)v7)
  {
    sub_10005CFEC((_DWORD **)a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 3477LL);
    return 44LL;
  }

  if (!v12)
  {
    if (!v13) {
      sub_10005CFB8(a1, v7);
    }
LABEL_4:
    if (*a1) {
      return 0LL;
    }
    else {
      return 46LL;
    }
  }

  if (v13) {
    sub_10005CFEC((_DWORD **)a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c", 3481LL);
  }
  return 23LL;
}

uint64_t sub_10002804C()
{
  return 27LL;
}

uint64_t sub_100028054()
{
  return 27LL;
}

const char *sub_10002805C(unsigned int a1)
{
  if (a1 > 0xFF) {
    return "invalid-message";
  }
  if (a1 - 1 < 0xC) {
    return off_100084570[a1 - 1];
  }
  uint64_t v1 = byte_1000BD279;
  __sprintf_chk(byte_1000BD279, 0, 0x14uLL, "unknown-message-%u", a1);
  return v1;
}

const char *sub_1000280D4(unsigned int a1)
{
  if (HIWORD(a1)) {
    return "invalid-option";
  }
  if (a1 - 1 < 0x1D) {
    return off_1000845D0[a1 - 1];
  }
  uint64_t v1 = byte_1000BD28D;
  __sprintf_chk(byte_1000BD28D, 0, 0x15uLL, "unknown-option-%u", a1);
  return v1;
}

void *sub_10002814C(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, char *__format, ...)
{
  unsigned int v13 = strlen(__str);
  return sub_1000281F8(a1, v14, v15, v16, v17, v18, v19, v20, v13, (uint64_t)__str);
}

void *sub_1000281F8( unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9, uint64_t a10)
{
  if (a1 - 30 < 0xFFFFFFE3) {
    return &unk_10008BED0;
  }
  uint64_t v12 = (char *)&unk_100088C60 + 32 * a1;
  int v14 = *((_DWORD *)v12 + 4);
  unsigned int v13 = (int *)(v12 + 16);
  if (v14 != 9)
  {
    uint64_t v57 = (const void **)&a9;
    int v15 = *v13;
    if ((*v13 - 5) > 1)
    {
      unsigned int v18 = *((_DWORD *)&unk_100088C60 + 8 * a1 + 5);
      if (!v18)
      {
        uint64_t v57 = (const void **)&a10;
        unsigned int v18 = a9;
      }

      uint64_t v16 = 0LL;
      int v17 = 0;
      unsigned int v19 = v18;
      switch(v15)
      {
        case 0:
        case 3:
        case 10:
          break;
        case 1:
          uint64_t v16 = 0LL;
          uint64_t v21 = (int *)v57++;
          int v17 = *v21;
          unsigned int v19 = *v21 * v18;
          break;
        case 2:
          uint64_t v16 = 0LL;
          int v17 = 0;
          unsigned int v19 = 4 * v18;
          break;
        case 4:
        case 8:
          int v17 = 0;
          uint64_t v20 = v57++;
          uint64_t v16 = *v20;
          unsigned int v19 = v18;
          break;
        case 7:
          uint64_t v16 = 0LL;
          int v17 = 0;
          unsigned int v19 = 2 * v18;
          break;
        default:
          sub_100061FB4("bogus type in failover_make_option: %d", a2, a3, a4, a5, a6, a7, a8, v15);
      }
    }

    else
    {
      uint64_t v16 = 0LL;
      int v17 = 0;
      unsigned int v18 = v15 == 5 ? 1 : 2;
      uint64_t v57 = (const void **)&a10;
      unsigned int v19 = a9 + v18;
    }

    uint64_t v22 = sub_10005CDE4(v19 + 4);
    if (v22)
    {
      uint64_t v23 = v22;
      sub_100060B78(v22, a1);
      sub_100060B78(v23 + 1, v19);
      switch(*v13)
      {
        case 0:
          if (v18)
          {
            uint64_t v39 = v18;
            uint64_t v40 = v23 + 2;
            do
            {
              uint64_t v41 = v57++;
              *v40++ = *(_DWORD *)v41;
              --v39;
            }

            while (v39);
          }

          goto LABEL_25;
        case 1:
          if (!v18) {
            goto LABEL_25;
          }
          uint64_t v42 = 0LL;
          break;
        case 2:
          if (v18)
          {
            uint64_t v44 = v18;
            uint64_t v45 = v23 + 2;
            do
            {
              uint64_t v46 = (unsigned int *)v57++;
              sub_100060B6C(v45++, *v46);
              --v44;
            }

            while (v44);
          }

          goto LABEL_25;
        case 3:
        case 10:
          unsigned int v29 = *v57;
          uint64_t v30 = (char *)(v23 + 2);
          size_t v31 = v18;
          goto LABEL_24;
        case 4:
        case 8:
          uint64_t v30 = (char *)(v23 + 2);
          size_t v31 = v18;
          unsigned int v29 = v16;
          goto LABEL_24;
        case 5:
        case 6:
          uint64_t v32 = v57;
          uint64_t v58 = v57 + 1;
          *((_BYTE *)v23 + 4) = *(_DWORD *)v32;
          if (v18 == 2)
          {
            uint64_t v33 = v58++;
            *((_BYTE *)v23 + 5) = *(_DWORD *)v33;
          }

          unsigned int v29 = *v58;
          uint64_t v30 = (char *)v23 + v18 + 4;
          size_t v31 = v19 - v18;
LABEL_24:
          memcpy(v30, v29, v31);
          goto LABEL_25;
        case 7:
          if (v18)
          {
            uint64_t v47 = v18;
            uint64_t v48 = v23 + 2;
            do
            {
              uint64_t v49 = (unsigned int *)v57++;
              sub_100060B78(v48++, *v49);
              --v47;
            }

            while (v47);
          }

          goto LABEL_25;
        default:
          goto LABEL_25;
      }

      do
      {
        uint64_t v43 = v57++;
        if (v17 != 4)
        {
          sub_10005CE20( v23,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  3975LL,  v24,  v25,  v26,  v27,  v28);
          sub_10006221C("IP addrlen=%d, should be 4.", v50, v51, v52, v53, v54, v55, v56, v17);
          return &unk_10008BED0;
        }

        v42 += 4LL;
        *(_DWORD *)((char *)v23 + (v42 & 0xFFFFFFFC)) = *(_DWORD *)*v43;
      }

      while (4LL * v18 != v42);
LABEL_25:
      uint64_t result = sub_10005CDE4(0x10uLL);
      if (result)
      {
        *(_DWORD *)uint64_t result = v19 + 4;
        result[1] = v23;
        return result;
      }

      sub_10005CE20( v23,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  4079LL,  v34,  v35,  v36,  v37,  v38);
    }
  }

  return &unk_10008BED0;
}

uint64_t sub_10002856C( uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, _DWORD *a9, uint64_t a10)
{
  uint64_t v44 = (void **)&a10;
  uint64_t v10 = a9;
  unsigned int v38 = a4;
  size_t v11 = 0LL;
  if (a9)
  {
    int v12 = 0;
    do
    {
      if (v10 != (_DWORD *)&unk_10008BEE0) {
        size_t v11 = (*v10 + v11);
      }
      if (v10 == (_DWORD *)&unk_10008BED0) {
        int v12 = 1;
      }
      unsigned int v13 = v44++;
      uint64_t v10 = *v13;
    }

    while (v10);
    BOOL v14 = v12 == 0;
    if (v12) {
      BOOL v15 = 1;
    }
    else {
      BOOL v15 = (_DWORD)v11 == 0;
    }
    if (v15)
    {
      uint64_t v16 = 0LL;
      goto LABEL_16;
    }

    uint64_t v16 = (char *)sub_10005CDE4(v11);
  }

  else
  {
    uint64_t v16 = 0LL;
  }

  BOOL v14 = 1;
LABEL_16:
  int v17 = 0;
  uint64_t v44 = (void **)&a9;
  if (v16) {
    BOOL v18 = v14;
  }
  else {
    BOOL v18 = 0;
  }
  while (1)
  {
    unsigned int v19 = v44++;
    uint64_t v20 = (unsigned int *)*v19;
    if (!*v19) {
      break;
    }
    if (v20 != (unsigned int *)&unk_10008BEE0)
    {
      if (v18) {
        memcpy(&v16[v17], *((const void **)v20 + 1), *v20);
      }
      if (v20 != (unsigned int *)&unk_10008BED0)
      {
        v17 += *v20;
        sub_10005CE20( *((void **)v20 + 1),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  4132LL,  a4,  a5,  a6,  a7,  a8);
        sub_10005CE20( v20,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  4133LL,  v21,  v22,  v23,  v24,  v25);
      }
    }
  }

  if (!v14) {
    return 39LL;
  }
  uint64_t v33 = sub_10005EFD8(a2, (int)v11 + 12);
  if ((_DWORD)v33
    || (v43 = a3, uint64_t v33 = sub_10005E7A4(a2, (uint64_t)&v43, 1u), (_DWORD)v33)
    || (v43 = 12, uint64_t v33 = sub_10005E7A4(a2, (uint64_t)&v43, 1u), (_DWORD)v33)
    || (uint64_t v33 = sub_10005EF64(a2, qword_10008CE80), (_DWORD)v33)
    || (uint64_t v33 = sub_10005EF64(a2, v38), (_DWORD)v33))
  {
    if (!v16)
    {
LABEL_33:
      sub_1000622D4("dhcp_failover_put_message: something went wrong.", v26, v27, v28, v29, v30, v31, v32, v36);
      sub_100060130(a2, 1);
      return v33;
    }

uint64_t sub_100028834( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void **)(a1 + 232);
  if (!v8) {
    return 39LL;
  }
  if (*v8 != qword_10008BE90) {
    return 39LL;
  }
  uint64_t v10 = (void *)v8[2];
  if (!v10 || *v10 != qword_10008CF08) {
    return 39LL;
  }
  uint64_t v11 = *(unsigned int *)(v8[7] + 24LL);
  int v12 = sub_1000281F8(1u, a2, a3, a4, a5, a6, a7, a8, a2, v17);
  return sub_10002856C((uint64_t)v8, (uint64_t)v10, 2, v11, v13, v14, v15, v16, v12, 0LL);
}

uint64_t sub_1000288D0( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void **)(a1 + 232);
  if (!v9) {
    return 39LL;
  }
  if (*v9 != qword_10008BE90) {
    return 39LL;
  }
  uint64_t v11 = (void *)v9[2];
  if (!v11 || *v11 != qword_10008CF08) {
    return 39LL;
  }
  uint64_t v12 = sub_10002856C((uint64_t)v9, (uint64_t)v11, 8, *(unsigned int *)(a1 + 348), a5, a6, a7, a8, 0LL, v20);
  sub_1000622D4("Sent update done message to %s", v13, v14, v15, v16, v17, v18, v19, *(void *)(a1 + 40));
  --*(_DWORD *)(a1 + 348);
  sub_10000E1BC();
  return v12;
}

uint64_t sub_100028978( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned __int8 *)(a1 + 222) != (_DWORD)a3)
  {
    switch(*(_BYTE *)(a1 + 222))
    {
      case 1:
      case 5:
        return a3;
      case 2:
        if (!*(_DWORD *)(a2 + 240))
        {
          if ((_DWORD)a3 == 4) {
            return a3;
          }
          return 2LL;
        }

        if (((1 << a3) & 0x74) == 0)
        {
          if (((1 << a3) & 0x82) != 0)
          {
            return 2LL;
          }

          if ((_DWORD)a3 == 3)
          {
            if (*(void *)(a1 + 88) - 65LL <= qword_10008CE80) {
              return 3LL;
            }
            return 2LL;
          }

uint64_t sub_100028B74( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *(unsigned __int8 *)(a1 + 222);
  if (v8 != (_DWORD)a3 && (v8 - 3) >= 5 && v8 != 1)
  {
    if (v8 == 2)
    {
      switch((int)a3)
      {
        case 1:
        case 7:
          LOBYTE(a3) = 2;
          return a3;
        case 3:
          if (*(void *)(a1 + 88) - 65LL > qword_10008CE80) {
            LOBYTE(a3) = 2;
          }
          else {
            LOBYTE(a3) = 3;
          }
          return a3;
        case 4:
        case 5:
        case 6:
          return a3;
        default:
          break;
      }
    }

    sub_100061FB4( "Impossible case at %s:%d.",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c");
  }

  return a3;
}

const char *sub_100028C38(int a1)
{
  else {
    return off_1000846B8[a1 - 1];
  }
}

uint64_t sub_100028C60(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 136);
  if (!v1) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(v1 + 160);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = *(void *)(v2 + 168);
  if (!v3) {
    return 0LL;
  }
  unint64_t v4 = *(unsigned __int16 *)(a1 + 192);
  if (!*(_WORD *)(a1 + 192))
  {
    unsigned int v7 = *(unsigned __int8 *)(a1 + 203);
    unsigned int v8 = v7 - 2;
    if (v7 >= 2)
    {
      uint64_t v5 = v7 - 1;
      unint64_t v9 = v5 + 1;
      do
      {
        LODWORD(v5) = byte_100088B60[(*(_BYTE *)(a1 + 205 + v8) ^ v5)];
        --v9;
        --v8;
      }

      while (v9 > 1);
      goto LABEL_11;
    }

    return 0LL;
  }

  LOWORD(v5) = *(_WORD *)(a1 + 192);
  do
  {
    BOOL v6 = v4-- > 1;
    LODWORD(v5) = byte_100088B60[(*(_BYTE *)(*(void *)(a1 + 184) + v4) ^ v5)];
  }

  while (v6);
LABEL_11:
  uint64_t result = (1 << (v5 & 7)) & *(unsigned __int8 *)(v3 + ((unint64_t)v5 >> 3));
  if (!*(_DWORD *)(v2 + 240)) {
    return (_DWORD)result == 0;
  }
  return result;
}

uint64_t sub_100028D28( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(void *)(a2 + 168)) {
    return 0LL;
  }
  uint64_t v11 = sub_100040D4C(&qword_10008C168, a1[20], 61LL, a4, a5, a6, a7, a8);
  uint64_t v24 = 0LL;
  uint64_t v25 = 0LL;
  uint64_t v23 = 0LL;
  if (v11
    && sub_100057AA4( &v23,  (unsigned int *)a1,  0LL,  0LL,  a1[20],  0LL,  &qword_10008C730,  v11,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  0x168Bu))
  {
    unsigned int v17 = v25;
    if ((int)v25 >= 1)
    {
      unint64_t v18 = v25 + 1LL;
      unsigned int v19 = v25 - 1;
      do
      {
        unsigned int v17 = byte_100088B60[*(unsigned __int8 *)(v24 + v19) ^ v17];
        --v18;
        --v19;
      }

      while (v18 > 1);
    }

    sub_100034EA8( &v23,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c",  5774LL,  v12,  v13,  v14,  v15,  v16);
  }

  else
  {
    unint64_t v20 = *(unsigned __int8 *)(*a1 + 2);
    if (*(_BYTE *)(*a1 + 2))
    {
      uint64_t v21 = *a1 + 28;
      unsigned int v17 = *(unsigned __int8 *)(*a1 + 2);
      do
      {
        BOOL v22 = v20-- > 1;
        unsigned int v17 = byte_100088B60[*(unsigned __int8 *)(v21 + v20) ^ v17];
      }

      while (v22);
    }

    else
    {
      unsigned int v17 = 0;
    }
  }

  uint64_t result = (1 << (v17 & 7)) & *(unsigned __int8 *)(*(void *)(a2 + 168) + ((unint64_t)v17 >> 3));
  if (*(_DWORD *)(a2 + 240)) {
    return (_DWORD)result == 0;
  }
  return result;
}

uint64_t sub_100028EA0( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    uint64_t v8 = result;
    uint64_t v9 = *(void *)(result + 136);
    if (v9 && (uint64_t v10 = *(void *)(v9 + 160)) != 0)
    {
      uint64_t result = 0LL;
      switch(*(_BYTE *)(v8 + 222))
      {
        case 1:
        case 5:
          if (*(_DWORD *)(v10 + 240)) {
            goto LABEL_14;
          }
          goto LABEL_20;
        case 2:
          return result;
        case 3:
        case 4:
        case 6:
          if (*(_DWORD *)(v10 + 216) != 3) {
            goto LABEL_18;
          }
          BOOL v11 = *(void *)(v8 + 248) < (uint64_t)xmmword_10008CE80;
          goto LABEL_23;
        case 7:
          if (*(_DWORD *)(v10 + 240) == 1)
          {
LABEL_20:
            uint64_t result = 1LL;
          }

          else
          {
LABEL_14:
            if (*(_DWORD *)(v10 + 216) == 3)
            {
              uint64_t v14 = *(void *)(v8 + 248);
              uint64_t v15 = *(void *)(v10 + 72);
              uint64_t v16 = *(unsigned int *)(v10 + 160);
              if (v14 >= v15) {
                uint64_t v17 = v14 + v16;
              }
              else {
                uint64_t v17 = v15 + v16;
              }
              BOOL v11 = v17 < (uint64_t)xmmword_10008CE80;
LABEL_23:
              uint64_t result = v11;
            }

            else
            {
LABEL_18:
              uint64_t result = 0LL;
            }
          }

          break;
        default:
          sub_100061FB4( "Impossible case at %s:%d.",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/failover.c");
      }
    }

    else
    {
      int v12 = *(unsigned __int8 *)(result + 222);
      return v12 == 1 || v12 == 7;
    }
  }

  return result;
}

uint64_t sub_100028FB4(uint64_t a1, int a2, int a3)
{
  BOOL v6 = off_100088018 + 2;
  unsigned int v7 = *(char **)(a1 + 48);
  if (off_100088018[2])
  {
    if (!v7) {
      goto LABEL_10;
    }
    uint64_t v14 = 0LL;
    if (sub_100003828( (uint64_t)&v14,  v7,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  84LL) != 23)
    {
      sub_1000338C0(&v14, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 85LL);
      return 18LL;
    }

    uint64_t v8 = off_100088018[2];
    do
    {
      uint64_t v9 = v8;
      uint64_t v8 = *(void *)(v8 + 32);
    }

    while (v8);
    BOOL v6 = (uint64_t *)(v9 + 32);
    uint64_t v14 = v9;
    uint64_t v10 = a1;
    uint64_t v11 = 93LL;
  }

  else
  {
    if (!v7) {
      return 39LL;
    }
    uint64_t v10 = a1;
    uint64_t v11 = 80LL;
  }

  sub_1000338BC(v6, v10, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", v11);
  if (!a2 || !a3) {
    return 0LL;
  }
LABEL_10:
  uint64_t v12 = *(void *)(a1 + 48);
  if (!v12) {
    uint64_t v12 = *(void *)(*(void *)(a1 + 40) + 48LL);
  }
  sub_10000DDB8(v12, 0LL, a1);
  else {
    return 0LL;
  }
}

uint64_t sub_1000290C4( uint64_t a1, const void *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (!qword_10008BE28
    && !sub_100063100( &qword_10008BE28,  (uint64_t)sub_100033920,  (uint64_t)sub_100033924,  0x57E5u,  (uint64_t (*)(char *, int, unsigned int))sub_1000632A8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  183LL,  a8))
  {
    sub_100061FB4("Can't allocate host/uid hash", v12, v13, v14, v15, a6, a7, a8, v33);
  }

  uint64_t v16 = *(const char **)(a1 + 88);
  if (v16)
  {
    sub_100063620( qword_10008BE28,  v16,  *(unsigned int *)(a1 + 96),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  195LL,  a6,  a7,  a8);
    sub_100034EA8( (_DWORD **)(a1 + 80),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  196LL,  v17,  v18,  v19,  v20,  v21);
  }

  *(void *)(a1 + 88) = 0LL;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 80) = 0LL;
  *(_DWORD *)(a1 + 96) = a3;
  if (!sub_1000345C4( (void *)(a1 + 80),  a3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  204LL)) {
    sub_100061FB4("Can't allocate uid buffer", v22, v23, v24, v25, v26, v27, v28, v33);
  }
  uint64_t v29 = (void *)(*(void *)(a1 + 80) + 4LL);
  *(void *)(a1 + 88) = v29;
  memcpy(v29, a2, a3);
  return sub_1000634B8( qword_10008BE28,  *(const char **)(a1 + 88),  *(unsigned int *)(a1 + 96),  a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  214LL,  v30,  v31,  a9);
}

uint64_t sub_1000291E8( uint64_t *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_100063100( a1,  (uint64_t)sub_100033920,  (uint64_t)sub_100033924,  a2,  (uint64_t (*)(char *, int, unsigned int))sub_1000632A8,  a3,  a4,  a8);
}

uint64_t sub_100029218( uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v93 = 0LL;
  if (qword_10008BE20)
  {
    uint64_t v11 = *(const char **)(a1 + 48);
    size_t v12 = strlen(v11);
    sub_100063738( &v93,  (uint64_t (**)(unsigned __int8 *, int, unsigned int))qword_10008BE20,  v11,  v12,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  236LL,  v13,  v14);
    uint64_t v15 = v93;
    if (v93)
    {
      if ((v93[48] & 1) != 0)
      {
        size_t v16 = strlen(*(const char **)(a1 + 48));
        sub_100063620( qword_10008BE20,  *(const char **)(a1 + 48),  v16,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  242LL,  v17,  v18,  v19);
        if ((v93[48] & 4) != 0) {
          *(_DWORD *)(a1 + 192) |= 4u;
        }
        sub_100033924(&v93, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 248LL);
        uint64_t v15 = v93;
      }

      if (v15 && v15 == (_DWORD *)a1)
      {
        sub_100033924(&v93, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 254LL);
        sub_100029808(a1, 0, v20, v21, v22, v23, v24, v25);
        *(_DWORD *)(a1 + 192) &= ~1u;
        uint64_t v15 = v93;
      }

      if (v15)
      {
        sub_100033924(&v93, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 270LL);
        return 18LL;
      }
    }

    size_t v34 = strlen(*(const char **)(a1 + 48));
    uint64_t v37 = qword_10008BE20;
    unsigned int v38 = *(const char **)(a1 + 48);
    uint64_t v39 = a1;
    uint64_t v40 = 266LL;
  }

  else
  {
    if (!sub_100063100( &qword_10008BE20,  (uint64_t)sub_100033920,  (uint64_t)sub_100033924,  0x57E5u,  (uint64_t (*)(char *, int, unsigned int))sub_1000632A8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  228LL,  a8)) {
      sub_100061FB4("Can't allocate host name hash", v27, v28, v29, v30, v31, v32, v33, v90);
    }
    size_t v34 = strlen(*(const char **)(a1 + 48));
    uint64_t v37 = qword_10008BE20;
    unsigned int v38 = *(const char **)(a1 + 48);
    uint64_t v39 = a1;
    uint64_t v40 = 232LL;
  }

  sub_1000634B8( v37,  v38,  v34,  v39,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  v40,  v35,  v36,  v90);
  if (*(void *)(a1 + 32)) {
    sub_100033924((_DWORD **)(a1 + 32), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 276LL);
  }
  if (!*(void *)a1) {
    *(void *)a1 = qword_10008BE10;
  }
  if (!*(_BYTE *)(a1 + 56)) {
    goto LABEL_30;
  }
  if (qword_10008BE18)
  {
    sub_100063738( &v93,  (uint64_t (**)(unsigned __int8 *, int, unsigned int))qword_10008BE18,  (const char *)(a1 + 57),  *(unsigned __int8 *)(a1 + 56),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  291LL,  v41,  v42);
  }

  else if (!sub_100063100( &qword_10008BE18,  (uint64_t)sub_100033920,  (uint64_t)sub_100033924,  0x57E5u,  (uint64_t (*)(char *, int, unsigned int))sub_1000632A8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  284LL,  v42))
  {
    sub_100061FB4("Can't allocate host/hw hash", v45, v46, v47, v48, v49, v43, v44, v91);
  }

  uint64_t v50 = v93;
  if (!v93)
  {
    sub_1000634B8( qword_10008BE18,  (const char *)(a1 + 57),  *(unsigned __int8 *)(a1 + 56),  a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  295LL,  v43,  v44,  v91);
LABEL_30:
    uint64_t v51 = 0LL;
    goto LABEL_31;
  }

  do
  {
    uint64_t v51 = v50;
    uint64_t v50 = (_DWORD *)*((void *)v50 + 4);
  }

  while (v50);
  sub_100033920((void *)v51 + 4, a1);
  sub_100033924(&v93, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 303LL);
LABEL_31:
  uint64_t v92 = 0LL;
  if (sub_10003E960( *(void *)(*(void *)(a1 + 152) + 48LL),  (unsigned int (*)(uint64_t, uint64_t, uint64_t))sub_100029CC4,  (uint64_t)&v92,  0LL)) {
    sub_100057AA4( (void *)(a1 + 80),  0LL,  0LL,  0LL,  0LL,  0LL,  &qword_10008C730,  *(void *)(v92 + 24),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  0x13Fu);
  }
  uint64_t v54 = *(unsigned int *)(a1 + 96);
  if ((_DWORD)v54)
  {
    if (qword_10008BE28)
    {
      if (sub_100063738( &v93,  (uint64_t (**)(unsigned __int8 *, int, unsigned int))qword_10008BE28,  *(const char **)(a1 + 88),  v54,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  343LL,  v52,  v53))
      {
        if (!v51)
        {
          uint64_t v57 = v93;
          do
          {
            uint64_t v58 = v57;
            if (v57 == (_DWORD *)a1) {
              break;
            }
            uint64_t v57 = (_DWORD *)*((void *)v57 + 4);
          }

          while (v57);
          uint64_t v51 = (_DWORD *)a1;
          if (v58 != (_DWORD *)a1)
          {
            sub_100033920((void *)v58 + 4, a1);
            uint64_t v51 = v58;
          }
        }

        sub_100033924(&v93, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 355LL);
        goto LABEL_48;
      }

      uint64_t v64 = qword_10008BE28;
      uint64_t v65 = *(const char **)(a1 + 88);
      uint64_t v66 = *(unsigned int *)(a1 + 96);
      uint64_t v67 = a1;
      uint64_t v68 = 360LL;
    }

    else
    {
      if (!sub_100063100( &qword_10008BE28,  (uint64_t)sub_100033920,  (uint64_t)sub_100033924,  0x57E5u,  (uint64_t (*)(char *, int, unsigned int))sub_1000632A8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  329LL,  v53)) {
        sub_100061FB4("Can't allocate host/uid hash", v59, v60, v61, v62, v63, v55, v56, v91);
      }
      uint64_t v64 = qword_10008BE28;
      uint64_t v65 = *(const char **)(a1 + 88);
      uint64_t v66 = *(unsigned int *)(a1 + 96);
      uint64_t v67 = a1;
      uint64_t v68 = 335LL;
    }

    sub_1000634B8( v64,  v65,  v66,  v67,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  v68,  v55,  v56,  v91);
  }

uint64_t sub_100029808( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v43 = 0LL;
  uint64_t v44 = 0LL;
  int v8 = *(_DWORD *)(a1 + 192);
  if ((v8 & 1) != 0) {
    return 0LL;
  }
  *(_DWORD *)(a1 + 192) = v8 | 1;
  BOOL v11 = !*(_BYTE *)(a1 + 56) || qword_10008BE18 == 0;
  if (v11
    || !sub_100063738( &v44,  (uint64_t (**)(unsigned __int8 *, int, unsigned int))qword_10008BE18,  (const char *)(a1 + 57),  *(unsigned __int8 *)(a1 + 56),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  476LL,  a7,  a8))
  {
    int v17 = 0;
  }

  else
  {
    if (v44 == (_DWORD *)a1)
    {
      sub_100063620( qword_10008BE18,  (const char *)(a1 + 57),  *(unsigned __int8 *)(a1 + 56),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  480LL,  a6,  a7,  a8);
      int v17 = 1;
    }

    else
    {
      uint64_t v42 = 0LL;
      uint64_t v43 = 0LL;
      sub_100033920(&v42, (uint64_t)v44);
      size_t v12 = v42;
      for (BOOL i = v42 == 0LL; v42 && v42 != (_DWORD *)a1; BOOL i = v42 == 0LL)
      {
        if (v43)
        {
          sub_100033924(&v43, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 490LL);
          size_t v12 = v42;
        }

        sub_100033920(&v43, (uint64_t)v12);
        sub_100033924(&v42, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 492LL);
        uint64_t v14 = *((void *)v43 + 4);
        if (v14) {
          sub_100033920(&v42, v14);
        }
        size_t v12 = v42;
      }

      uint64_t v15 = v43;
      if (!i)
      {
        sub_100033924((_DWORD **)v43 + 4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 498LL);
        uint64_t v16 = *(void *)(a1 + 32);
        if (v16) {
          sub_100033920((void *)v43 + 4, v16);
        }
        sub_100033924(&v42, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 502LL);
        uint64_t v15 = v43;
      }

      if (v15) {
        sub_100033924(&v43, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 505LL);
      }
      int v17 = 0;
    }

    sub_100033924(&v44, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 507LL);
  }

  uint64_t v18 = *(unsigned int *)(a1 + 96);
  if ((_DWORD)v18) {
    BOOL v19 = qword_10008BE28 == 0;
  }
  else {
    BOOL v19 = 1;
  }
  if (!v19
    && sub_100063738( &v44,  (uint64_t (**)(unsigned __int8 *, int, unsigned int))qword_10008BE28,  *(const char **)(a1 + 88),  v18,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  518LL,  a7,  a8))
  {
    if (v44 == (_DWORD *)a1)
    {
      sub_100063620( qword_10008BE28,  *(const char **)(a1 + 88),  *(unsigned int *)(a1 + 96),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  522LL,  a6,  a7,  a8);
    }

    else
    {
      uint64_t v42 = 0LL;
      uint64_t v43 = 0LL;
      sub_100033920(&v42, (uint64_t)v44);
      uint64_t v20 = v42;
      for (BOOL j = v42 == 0LL; v42 && v42 != (_DWORD *)a1; BOOL j = v42 == 0LL)
      {
        if (v43)
        {
          sub_100033924(&v43, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 532LL);
          uint64_t v20 = v42;
        }

        sub_100033920(&v43, (uint64_t)v20);
        sub_100033924(&v42, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 534LL);
        uint64_t v22 = *((void *)v43 + 4);
        if (v22) {
          sub_100033920(&v42, v22);
        }
        uint64_t v20 = v42;
      }

      uint64_t v23 = v43;
      if (!j)
      {
        sub_100033924((_DWORD **)v43 + 4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 540LL);
        uint64_t v24 = *(void *)(a1 + 32);
        if (v24) {
          sub_100033920((void *)v43 + 4, v24);
        }
        sub_100033924(&v42, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 544LL);
        uint64_t v23 = v43;
      }

      if (v23) {
        sub_100033924(&v43, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 547LL);
      }
    }

    sub_100033924(&v44, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 549LL);
  }

  if (*(void *)(a1 + 104))
  {
    sub_100052CE4( (uint64_t *)(a1 + 104),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  555LL,  v18,  a5,  a6,  a7,  a8);
    sub_100034EA8( (_DWORD **)(a1 + 112),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  556LL,  v25,  v26,  v27,  v28,  v29);
  }

  uint64_t v31 = (uint64_t *)(a1 + 32);
  uint64_t v30 = *(void *)(a1 + 32);
  if (v30)
  {
    uint64_t v32 = *(unsigned int *)(v30 + 96);
    if ((_DWORD)v32) {
      sub_1000634B8( qword_10008BE28,  *(const char **)(v30 + 88),  v32,  v30,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  565LL,  a7,  a8,  v41);
    }
    if (v17 && *(_BYTE *)(*v31 + 56)) {
      sub_1000634B8( qword_10008BE18,  (const char *)(*v31 + 57),  *(unsigned __int8 *)(*v31 + 56),  *v31,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  571LL,  a7,  a8,  v41);
    }
    sub_100033924((_DWORD **)(a1 + 32), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 573LL);
  }

  if (qword_10008BE20)
  {
    size_t v33 = strlen(*(const char **)(a1 + 48));
    if (sub_100063738( &v44,  (uint64_t (**)(unsigned __int8 *, int, unsigned int))qword_10008BE20,  *(const char **)(a1 + 48),  v33,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  579LL,  v34,  v35))
    {
      if (v44 == (_DWORD *)a1 && (*(_BYTE *)(a1 + 192) & 4) == 0)
      {
        size_t v36 = strlen(*(const char **)(a1 + 48));
        sub_100063620( qword_10008BE20,  *(const char **)(a1 + 48),  v36,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  583LL,  v37,  v38,  v39);
      }

      sub_100033924(&v44, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 585LL);
    }
  }

  else {
    return 26LL;
  }
}

uint64_t sub_100029CC4( uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 16) == 6)
  {
    uint64_t v8 = *(void *)(a1 + 24);
    if (v8)
    {
      uint64_t v9 = *(void *)(v8 + 24);
      if (*(uint64_t **)(v9 + 16) == &qword_10008C168 && *(_DWORD *)(v9 + 24) == 61)
      {
        if ((_DWORD)a3)
        {
          sub_10006221C( "dhcp client identifier may not be %s",  (uint64_t)a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)"specified conditionally.");
        }

        else
        {
          if (!*a2)
          {
            sub_100033F18( a2,  (_DWORD *)a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  136LL,  a5,  a6,  a7,  a8);
            return 1LL;
          }

          sub_10006221C( "only one dhcp client identifier may be %s",  (uint64_t)a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)"specified");
        }
      }
    }
  }

  return 0LL;
}

uint64_t sub_100029D78(uint64_t a1, int a2)
{
  uint64_t v3 = a1;
  *(_DWORD *)(a1 + 152) |= 1u;
  if (a2)
  {
    sub_10000DDB8(*(void *)(a1 + 48), 0LL, a1);
  }

  sub_100003798(&v3);
  sub_1000338C0(&v3, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 450LL);
  return 0LL;
}

uint64_t sub_100029DE4(void *a1, char a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6)
{
  unsigned __int8 v9 = a4 + 1;
  char v13 = a2;
  __memcpy_chk(&v14, a3, a4, 16LL);
  return sub_100063738( a1,  (uint64_t (**)(unsigned __int8 *, int, unsigned int))qword_10008BE18,  &v13,  v9,  a5,  a6,  v10,  v11);
}

uint64_t sub_100029E98( void *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_100063738( a1,  (uint64_t (**)(unsigned __int8 *, int, unsigned int))qword_10008BE28,  a2,  a3,  a4,  a5,  a7,  a8);
}

uint64_t sub_100029EB4( void *a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = qword_1000BD2A8;
  if (!qword_1000BD2A8) {
    return 0LL;
  }
  while (1)
  {
    uint64_t v14 = sub_100040D4C( *(void **)(*(void *)v8 + 16LL),  a3,  *(unsigned int *)(*(void *)v8 + 24LL),  a4,  a5,  a6,  a7,  a8);
    if (v14)
    {
      uint64_t v30 = 0LL;
      uint64_t v31 = 0LL;
      uint64_t v32 = 0LL;
      if (!sub_100057AA4( &v30,  a2,  0LL,  0LL,  a3,  0LL,  &qword_10008C730,  v14,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  0x27Du))
      {
        sub_10006221C("Error evaluating option cache", v15, v16, v17, v18, v19, v20, v21, v29);
        return 0LL;
      }

      int v22 = sub_100063738( a1,  *(uint64_t (***)(unsigned __int8 *, int, unsigned int))(v8 + 8),  v31,  v32,  a4,  a5,  v20,  v21);
      sub_100034EA8( &v30,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  646LL,  v23,  v24,  v25,  v26,  v27);
      if (v22) {
        break;
      }
    }

    uint64_t v8 = *(void *)(v8 + 16);
    if (!v8) {
      return 0LL;
    }
  }

  return 1LL;
}

uint64_t sub_100029FD0(uint64_t a1, uint64_t *a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v23 = 0LL;
  uint64_t v24 = 0LL;
  uint64_t v25 = 0LL;
  uint64_t v4 = *a2;
  if (!*a2) {
    return 0LL;
  }
  while (1)
  {
    uint64_t v9 = *(void *)(v4 + 136);
    if (!v9
      || !sub_100057AA4( &v23,  0LL,  0LL,  0LL,  0LL,  0LL,  &qword_10008C730,  v9,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  0x2ABu))
    {
      goto LABEL_9;
    }

    if ((_DWORD)v25) {
      break;
    }
LABEL_8:
    sub_100034EA8( &v23,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  705LL,  v10,  v11,  v12,  v13,  v14);
LABEL_9:
    uint64_t v4 = *(void *)(v4 + 32);
    if (!v4) {
      return 0LL;
    }
  }

  unint64_t v15 = 0LL;
  while (1)
  {
    int v16 = *(_DWORD *)(v24 + v15);
    LODWORD(v26[0]) = 4;
    HIDWORD(v26[0]) = v16;
    if (sub_10002A180( a1,  a4,  (uint64_t)v26,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  689LL,  v12,  v13,  v14))
    {
      break;
    }

    v15 += 4LL;
  }

  v26[0] = 0LL;
  *a3 = 4;
  a3[1] = v16;
  sub_100033920(v26, *a2);
  sub_100033924((_DWORD **)a2, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 698LL);
  sub_100033920(a2, v4);
  sub_100033924(v26, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 700LL);
  sub_100034EA8( &v23,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  701LL,  v18,  v19,  v20,  v21,  v22);
  return 1LL;
}

BOOL sub_10002A180( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a2 + 56);
  if (!v8) {
    return 0LL;
  }
  while (1)
  {
    __int128 v22 = *(_OWORD *)a3;
    int v23 = *(_DWORD *)(a3 + 16);
    __int128 v20 = *(_OWORD *)(v8 + 104);
    int v21 = *(_DWORD *)(v8 + 120);
    sub_10003F7A4(&v22, &v20, a3, a4, a5, a6, a7, a8, (unint64_t)v24);
    __int128 v22 = *(_OWORD *)(v8 + 84);
    int v23 = *(_DWORD *)(v8 + 100);
    if (sub_10003FB78(v24, &v22, v13, v14, v15, v16, v17, v18)) {
      break;
    }
    uint64_t v8 = *(void *)(v8 + 40);
    if (!v8) {
      return 0LL;
    }
  }

  return sub_1000235CC(a1, v8, a4, a5) == 0;
}

uint64_t sub_10002A270( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD **a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = *(void *)(a4 + 48);
  uint64_t v168 = 0LL;
  if (!v11)
  {
    __int128 v175 = *(_OWORD *)(a4 + 84);
    int v176 = *(_DWORD *)(a4 + 100);
    sub_100040144((int *)&v175, a2, a3, a4, a5, (uint64_t)a6, a7, a8);
    __strcpy_chk(v177);
    __int128 v175 = *(_OWORD *)(a4 + 104);
    int v176 = *(_DWORD *)(a4 + 120);
    sub_100040144((int *)&v175, v12, v13, v14, v15, v16, v17, v18);
    sub_100061FB4("No shared network for network %s (%s)", v19, v20, v21, v22, v23, v24, v25, (char)v177);
  }

  if (!qword_10008BE40
    && !sub_100063100( &qword_10008BE40,  (uint64_t)sub_100033898,  (uint64_t)sub_10003389C,  0x186A3u,  (uint64_t (*)(char *, int, unsigned int))sub_1000632E4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  737LL,  a8))
  {
    sub_100061FB4("Can't allocate lease/uid hash", v26, a3, a4, a5, (uint64_t)a6, a7, a8, v163);
  }

  if (!qword_10008BE38
    && !sub_100063100( &qword_10008BE38,  (uint64_t)sub_100033898,  (uint64_t)sub_10003389C,  0x186A3u,  (uint64_t (*)(char *, int, unsigned int))sub_100063380,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  742LL,  a8))
  {
    sub_100061FB4("Can't allocate lease/ip hash", v27, a3, a4, a5, (uint64_t)a6, a7, a8, v163);
  }

  if (!qword_10008BE30
    && !sub_100063100( &qword_10008BE30,  (uint64_t)sub_100033898,  (uint64_t)sub_10003389C,  0x186A3u,  (uint64_t (*)(char *, int, unsigned int))sub_1000632E4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  747LL,  a8))
  {
    sub_100061FB4("Can't allocate lease/hw hash", v28, a3, a4, a5, (uint64_t)a6, a7, a8, v163);
  }

  char v29 = (__int128 *)(a4 + 84);
  uint64_t v30 = (__int128 *)(a4 + 104);
  __int128 v175 = *(_OWORD *)a2;
  int v176 = *(_DWORD *)(a2 + 16);
  __int128 v172 = *(_OWORD *)(a4 + 104);
  int v173 = *(_DWORD *)(a4 + 120);
  sub_10003F7A4(&v175, &v172, a3, a4, a5, (uint64_t)a6, a7, a8, (unint64_t)v174);
  __int128 v175 = *(_OWORD *)(a4 + 84);
  int v176 = *(_DWORD *)(a4 + 100);
  if (!sub_10003FB78((unsigned int *)&v175, v174, v31, v32, v33, v34, v35, v36))
  {
    __int128 v175 = *(_OWORD *)a2;
    int v176 = *(_DWORD *)(a2 + 16);
    sub_100040144((int *)&v175, v37, v38, v39, v40, v41, v42, v43);
    __strcpy_chk(v179);
    __int128 v175 = *v29;
    int v176 = *(_DWORD *)(a4 + 100);
    sub_100040144((int *)&v175, v44, v45, v46, v47, v48, v49, v50);
    __strcpy_chk(v177);
    __int128 v175 = *v30;
    int v176 = *(_DWORD *)(a4 + 120);
    sub_100040144((int *)&v175, v51, v52, v53, v54, v55, v56, v57);
    sub_100061FB4("bad range, address %s not in subnet %s netmask %s", v58, v59, v60, v61, v62, v63, v64, (char)v179);
  }

  __int128 v175 = *(_OWORD *)a3;
  int v176 = *(_DWORD *)(a3 + 16);
  __int128 v172 = *v30;
  int v173 = *(_DWORD *)(a4 + 120);
  sub_10003F7A4(&v175, &v172, v38, v39, v40, v41, v42, v43, (unint64_t)v171);
  __int128 v175 = *v29;
  int v176 = *(_DWORD *)(a4 + 100);
  if (!sub_10003FB78((unsigned int *)&v175, v171, v65, v66, v67, v68, v69, v70))
  {
    __int128 v175 = *(_OWORD *)a3;
    int v176 = *(_DWORD *)(a3 + 16);
    sub_100040144((int *)&v175, v71, v72, v73, v74, v75, v76, v77);
    __strcpy_chk(v178);
    __int128 v175 = *v29;
    int v176 = *(_DWORD *)(a4 + 100);
    sub_100040144((int *)&v175, v78, v79, v80, v81, v82, v83, v84);
    __strcpy_chk(v177);
    __int128 v175 = *v30;
    int v176 = *(_DWORD *)(a4 + 120);
    sub_100040144((int *)&v175, v85, v86, v87, v88, v89, v90, v91);
    sub_100061FB4("bad range, address %s not in subnet %s netmask %s", v92, v93, v94, v95, v96, v97, v98, (char)v178);
  }

  __int128 v175 = *(_OWORD *)a3;
  int v176 = *(_DWORD *)(a3 + 16);
  __int128 v172 = *v30;
  int v173 = *(_DWORD *)(a4 + 120);
  unsigned int v99 = sub_10003FA78(&v175, &v172, v72, v73, v74, v75, v76, v77);
  __int128 v175 = *(_OWORD *)a2;
  int v176 = *(_DWORD *)(a2 + 16);
  __int128 v172 = *v30;
  int v173 = *(_DWORD *)(a4 + 120);
  uint64_t v112 = sub_10003FA78(&v175, &v172, v100, v101, v102, v103, v104, v105);
  if (v112 > v99)
  {
    __int128 v175 = *(_OWORD *)a3;
    int v176 = *(_DWORD *)(a3 + 16);
    __int128 v172 = *v30;
    int v173 = *(_DWORD *)(a4 + 120);
    unsigned int v99 = v112;
    uint64_t v112 = sub_10003FA78(&v175, &v172, v106, v107, v108, v109, v110, v111);
  }

  int v113 = v99 - v112;
  uint64_t v114 = v99 - v112 + 1;
  uint64_t result = (uint64_t)sub_1000337E0(v113 + 1);
  uint64_t v123 = (void *)result;
  if (!result)
  {
    __int128 v175 = *(_OWORD *)a2;
    int v176 = *(_DWORD *)(a2 + 16);
    sub_100040144((int *)&v175, v116, v117, v118, v119, v120, v121, v122);
    __strcpy_chk(v179);
    __int128 v175 = *(_OWORD *)a3;
    int v176 = *(_DWORD *)(a3 + 16);
    sub_100040144((int *)&v175, v124, v125, v126, v127, v128, v129, v130);
    __strcpy_chk(v178);
    sub_100061FB4("No memory for address range %s-%s.", v131, v132, v133, v134, v135, v136, v137, (char)v179);
  }

  if ((_DWORD)v114)
  {
    while (1)
    {
      uint64_t v167 = 0LL;
      sub_10005CF60( v123,  qword_10008BEA8,  0,  0x120uLL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  793LL);
      sub_100033898(&v167, v123, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 794LL);
      uint64_t v138 = v167;
      __int128 v172 = *v29;
      int v173 = *(_DWORD *)(a4 + 100);
      __int128 v169 = *v30;
      int v170 = *(_DWORD *)(a4 + 120);
      sub_10003F870(&v172, &v169, v112, v139, v140, v141, v142, v143, (uint64_t)&v175);
      *(_OWORD *)(v138 + 14) = v175;
      v138[18] = v176;
      uint64_t v144 = v167;
      uint64_t v145 = v167 + 32;
      *((void *)v167 + 10) = 0LL;
      *((void *)v144 + 11) = 0LL;
      sub_1000235CC(v145, a4, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 808LL);
      sub_1000338FC((void *)v167 + 17, a5);
      uint64_t v146 = v167;
      *((_BYTE *)v167 + 223) = 1;
      *(_WORD *)((char *)v146 + 221) = 256;
      __int128 v175 = *(_OWORD *)(v146 + 14);
      int v176 = v146[18];
      if (sub_100063738( &v168,  (uint64_t (**)(unsigned __int8 *, int, unsigned int))qword_10008BE38,  (const char *)&v175 + 4,  v175,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  815LL,  v147,  v148)) {
        break;
      }
      sub_1000634B8( qword_10008BE38,  (const char *)v167 + 60,  v167[14],  (uint64_t)v167,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  826LL,  v154,  v155,  v163);
      if (a6) {
        goto LABEL_28;
      }
LABEL_31:
      uint64_t result = sub_10003389C(&v167, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 835LL);
      uint64_t v112 = (v112 + 1);
      v123 += 36;
      if (!--v114) {
        return result;
      }
    }

    if (*((void *)v168 + 17))
    {
      __int128 v175 = *(_OWORD *)(v167 + 14);
      int v176 = v167[18];
      char v156 = sub_100040144((int *)&v175, v149, v150, v151, v152, v153, v154, v155);
      sub_100046D6C(a1, "lease %s is declared twice!", v157, v158, v159, v160, v161, v162, v156);
    }

    else
    {
      sub_1000338FC((void *)v168 + 17, a5);
    }

    sub_10003389C(&v168, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 822LL);
    if (!a6) {
      goto LABEL_31;
    }
LABEL_28:
    if (*a6)
    {
      sub_100033898(v167 + 8, *a6, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 830LL);
      sub_10003389C(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 831LL);
    }

    sub_100033898(a6, v167, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 833LL);
    goto LABEL_31;
  }

  return result;
}

uint64_t sub_10002A928( uint64_t *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_100063100( a1,  (uint64_t)sub_100033898,  (uint64_t)sub_10003389C,  a2,  (uint64_t (*)(char *, int, unsigned int))sub_1000632E4,  a3,  a4,  a8);
}

uint64_t sub_10002A950( uint64_t *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_100063100( a1,  (uint64_t)sub_100033898,  (uint64_t)sub_10003389C,  a2,  (uint64_t (*)(char *, int, unsigned int))sub_100063380,  a3,  a4,  a8);
}

uint64_t sub_10002A978( void *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_100063738( a1,  (uint64_t (**)(unsigned __int8 *, int, unsigned int))qword_10008BE38,  a2 + 4,  *(unsigned int *)a2,  a3,  a4,  a7,  a8);
}

BOOL sub_10002A994( uint64_t a1, __int128 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = qword_10008BE58;
  if (!qword_10008BE58) {
    return 0LL;
  }
  while (1)
  {
    __int128 v22 = *a2;
    int v23 = *((_DWORD *)a2 + 4);
    __int128 v20 = *(_OWORD *)(v8 + 104);
    int v21 = *(_DWORD *)(v8 + 120);
    sub_10003F7A4(&v22, &v20, a3, a4, a5, a6, a7, a8, (unint64_t)v24);
    __int128 v22 = *(_OWORD *)(v8 + 84);
    int v23 = *(_DWORD *)(v8 + 100);
    if (sub_10003FB78(v24, &v22, v13, v14, v15, v16, v17, v18)) {
      break;
    }
    uint64_t v8 = *(void *)(v8 + 32);
    if (!v8) {
      return 0LL;
    }
  }

  return sub_1000235CC(a1, v8, a3, a4) == 0;
}

BOOL sub_10002AA88( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  uint64_t v11 = (__int128 *)(a1 + 84);
  __int128 v49 = *(_OWORD *)(a1 + 84);
  int v50 = *(_DWORD *)(a1 + 100);
  __int128 v52 = *(_OWORD *)(a2 + 104);
  int v53 = *(_DWORD *)(a2 + 120);
  sub_10003F7A4(&v49, &v52, a3, a4, a5, a6, a7, a8, (unint64_t)v54);
  uint64_t v12 = (__int128 *)(a2 + 84);
  __int128 v49 = *(_OWORD *)(a2 + 84);
  int v50 = *(_DWORD *)(a2 + 100);
  if (!sub_10003FB78(v54, &v49, v13, v14, v15, v16, v17, v18))
  {
    __int128 v49 = *v12;
    int v50 = *(_DWORD *)(a2 + 100);
    __int128 v52 = *(_OWORD *)(a1 + 104);
    int v53 = *(_DWORD *)(a1 + 120);
    sub_10003F7A4(&v49, &v52, v20, v21, v22, v23, v24, v25, (unint64_t)v51);
    __int128 v49 = *v11;
    int v50 = *((_DWORD *)v11 + 4);
    if (!sub_10003FB78(v51, &v49, v26, v27, v28, v29, v30, v31)) {
      return 0LL;
    }
  }

  for (unsigned int i = 0; i != 128; ++i)
  {
  }

  for (unsigned int j = 0; j != 128; ++j)
  {
  }

  if (v8)
  {
    __int128 v49 = *v11;
    int v50 = *((_DWORD *)v11 + 4);
    sub_100040144((int *)&v49, v19, v20, v21, v22, v23, v24, v25);
    __strcpy_chk(&v49);
    __int128 v52 = *v12;
    int v53 = *(_DWORD *)(a2 + 100);
    sub_100040144((int *)&v52, v34, v35, v36, v37, v38, v39, v40);
    sub_10006221C("Warning: subnet %s/%d overlaps subnet %s/%d", v41, v42, v43, v44, v45, v46, v47, (char)&v49);
  }

  return i < j;
}

uint64_t sub_10002AC64(uint64_t a1)
{
  uint64_t v11 = 0LL;
  uint64_t v12 = 0LL;
  uint64_t v10 = 0LL;
  if (!qword_10008BE58) {
    return sub_1000235CC(&qword_10008BE58, a1, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 944LL);
  }
  sub_1000235CC(&v11, qword_10008BE58, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 911LL);
  uint64_t v2 = v11;
  if (!v11)
  {
LABEL_7:
    if (qword_10008BE58)
    {
      sub_1000235CC(a1 + 32, qword_10008BE58, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 941LL);
      sub_1000235C8(&qword_10008BE58, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 942LL);
    }

    return sub_1000235CC(&qword_10008BE58, a1, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 944LL);
  }

  while (1)
  {
    sub_1000235CC(&v12, v2, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 913LL);
    sub_1000235C8(&v11, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 914LL);
    if (sub_10002AA88(a1, v12, 1LL, v3, v4, v5, v6, v7)) {
      break;
    }
    sub_1000235CC(&v10, v12, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 933LL);
    sub_1000235C8(&v12, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 934LL);
    uint64_t v2 = v11;
    if (!v11)
    {
      if (v10) {
        sub_1000235C8(&v10, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 937LL);
      }
      goto LABEL_7;
    }
  }

  uint64_t v9 = v10;
  if (v10)
  {
    if (*(void *)(v10 + 32))
    {
      sub_1000235C8(v10 + 32, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 922LL);
      uint64_t v9 = v10;
    }

    sub_1000235CC(v9 + 32, a1, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 923LL);
    sub_1000235C8(&v10, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 924LL);
  }

  else
  {
    sub_1000235C8(&qword_10008BE58, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 926LL);
    sub_1000235CC(&qword_10008BE58, a1, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 927LL);
  }

  sub_1000235CC(a1 + 32, v12, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 929LL);
  return sub_1000235C8(&v12, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 930LL);
}

uint64_t sub_10002AE50(uint64_t a1)
{
  if (qword_10008BE50)
  {
    sub_1000235CC(a1 + 32, qword_10008BE50, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 954LL);
    sub_1000235C8(&qword_10008BE50, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 955LL);
  }

  return sub_1000235CC(&qword_10008BE50, a1, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 957LL);
}

uint64_t sub_10002AEBC( uint64_t a1, uint64_t a2, char *__s2, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a2 + 64;
  if (*(void *)(a2 + 64)) {
    return sub_100046D6C( a1,  "A subnet or shared network can't be connected %s",  (uint64_t)__s2,  a4,  a5,  a6,  a7,  a8,  (char)"to two interfaces.");
  }
  uint64_t v12 = qword_10008C0D0;
  if (qword_10008C0D0)
  {
    while (1)
    {
      uint64_t result = strcmp((const char *)(v12 + 132), __s2);
      if (!(_DWORD)result) {
        break;
      }
      uint64_t v12 = *(void *)(v12 + 32);
      if (!v12) {
        goto LABEL_6;
      }
    }
  }

  else
  {
LABEL_6:
    uint64_t v26 = 0LL;
    unsigned int v13 = sub_10003A174((void **)&v26, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 979LL);
    if (v13)
    {
      sub_100067900(v13);
      sub_100061FB4("new_shared_network_interface %s: %s", v14, v15, v16, v17, v18, v19, v20, (char)__s2);
    }

    size_t v21 = strlen(__s2);
    uint64_t v22 = v26;
    uint64_t v23 = v26 + 132;
    if (v21 < 0x11)
    {
      __strcpy_chk(v23);
      uint64_t v22 = v26;
    }

    else
    {
      uint64_t v24 = *(void *)__s2;
      *(void *)(v26 + 139) = *(void *)(__s2 + 7);
      *uint64_t v23 = v24;
      v22[147] = 0;
    }

    if (qword_10008C0D0)
    {
      sub_1000235CC(v22 + 32, qword_10008C0D0, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 989LL);
      sub_1000235C8(&qword_10008C0D0, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 990LL);
      uint64_t v22 = v26;
    }

    sub_1000235CC(&qword_10008C0D0, v22, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 992LL);
    uint64_t v25 = v26;
    *((_DWORD *)v26 + 51) = 1;
    sub_1000235CC(v25 + 40, a2, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 995LL);
    return sub_1000235CC(v8, v26, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 996LL);
  }

  return result;
}

uint64_t sub_10002B044( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v40 = 0LL;
  uint64_t v9 = a1 + 56;
  __int128 v41 = *(_OWORD *)(a1 + 56);
  int v42 = *(_DWORD *)(a1 + 72);
  if (sub_100063738( &v40,  (uint64_t (**)(unsigned __int8 *, int, unsigned int))qword_10008BE38,  (const char *)&v41 + 4,  v41,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1011LL,  a7,  a8))
  {
    uint64_t v17 = *((void *)v40 + 17);
    if (v17)
    {
      sub_1000338FC((void *)(a1 + 136), v17);
    }

    else
    {
      __int128 v41 = *(_OWORD *)v9;
      int v42 = *(_DWORD *)(v9 + 16);
      char v21 = sub_100040144((int *)&v41, 0LL, v11, v12, v13, v14, v15, v16);
      sub_10006221C("undeclared lease found in database: %s", v22, v23, v24, v25, v26, v27, v28, v21);
    }

    uint64_t v29 = *((void *)v40 + 16);
    if (v29) {
      sub_1000235CC(a1 + 128, v29, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 1020LL);
    }
    sub_100063620( qword_10008BE38,  (const char *)(a1 + 60),  *(unsigned int *)(a1 + 56),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1023LL,  v18,  v19,  v20);
    sub_10003389C(&v40, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 1024LL);
  }

  if (*(void *)(a1 + 128)) {
    return sub_1000634B8( qword_10008BE38,  (const char *)(a1 + 60),  *(unsigned int *)(a1 + 56),  a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1041LL,  v15,  v16,  v39);
  }
  __int128 v41 = *(_OWORD *)v9;
  int v42 = *(_DWORD *)(v9 + 16);
  char v31 = sub_100040144((int *)&v41, v10, v11, v12, v13, v14, v15, v16);
  return sub_10006221C("lease %s: no subnet.", v32, v33, v34, v35, v36, v37, v38, v31);
}

uint64_t sub_10002B1D0( uint64_t a1, uint64_t a2, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a5;
  int v9 = a4;
  int v10 = a3;
  uint64_t v11 = a2;
  if (!(_DWORD)a3 && (_DWORD)a5) {
    return 0LL;
  }
  if (!a2) {
    goto LABEL_65;
  }
  if ((*(_BYTE *)(a2 + 221) & 1) != 0) {
    return 1LL;
  }
  if (*(_BYTE *)(a2 + 222) != 5 && *(_BYTE *)(a2 + 223) != 5 && *(_BYTE *)(a1 + 222) == 2)
  {
    uint64_t v13 = *(const void **)(a1 + 184);
    if (v13)
    {
      a2 = *(void *)(a2 + 184);
      if (!a2) {
        goto LABEL_16;
      }
      a3 = *(unsigned __int16 *)(a1 + 192);
    }

    else
    {
      a3 = *(unsigned __int8 *)(a1 + 203);
      if ((_DWORD)a3 != *(unsigned __int8 *)(a2 + 203))
      {
LABEL_15:
        __int128 v81 = *(_OWORD *)(a1 + 56);
        int v82 = *(_DWORD *)(a1 + 72);
        char v14 = sub_100040144((int *)&v81, a2, a3, a4, a5, a6, a7, a8);
        sub_10006221C("Lease conflict at %s", v15, v16, v17, v18, v19, v20, v21, v14);
        goto LABEL_16;
      }

      uint64_t v13 = (const void *)(a1 + 204);
      a2 += 204LL;
    }
  }

LABEL_16:
  if (*(void *)(a1 + 184))
  {
    sub_10002B928(a1, a2, a3, a4, a5, a6, a7, a8);
    uint64_t v22 = *(void **)(a1 + 184);
    if (v22 != (void *)(a1 + 196))
    {
      sub_10005CE20( v22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1105LL,  a4,  a5,  a6,  a7,  a8);
      *(_DWORD *)(a1 + 192) = 0;
    }

    *(void *)(a1 + 184) = 0LL;
  }

  uint64_t v23 = (_OWORD *)(a1 + 203);
  if (*(_BYTE *)(a1 + 203)) {
    sub_10002BA70(a1, a2, a3, a4, a5, a6, a7, a8);
  }
  uint64_t v24 = *(void *)(a1 + 144);
  uint64_t v25 = *(void *)(v11 + 144);
  if (v24 != v25)
  {
    if (v24)
    {
      sub_1000038C0(a1, *(void *)(a1 + 144), a3, a4, a5, a6, a7, a8);
      uint64_t v25 = *(void *)(v11 + 144);
    }

    if (v25) {
      sub_1000039C0(a1, v25, a3, a4, a5, a6, a7, a8);
    }
  }

  *(void *)(a1 + 80) = *(void *)(v11 + 80);
  uint64_t v26 = *(const void **)(v11 + 184);
  if (v26)
  {
    size_t v27 = *(unsigned __int16 *)(v11 + 192);
    if (v27 > 7)
    {
      *(void *)(a1 + 184) = v26;
      *(_WORD *)(a1 + 194) = *(_WORD *)(v11 + 194);
      *(void *)(v11 + 184) = 0LL;
      *(_WORD *)(v11 + 194) = 0;
      *(_WORD *)(a1 + 192) = v27;
      *(_WORD *)(v11 + 192) = 0;
    }

    else
    {
      memcpy((void *)(a1 + 196), v26, v27);
      *(void *)(a1 + 184) = a1 + 196;
      *(_WORD *)(a1 + 194) = 7;
      *(_WORD *)(a1 + 192) = *(_WORD *)(v11 + 192);
    }
  }

  else
  {
    *(void *)(a1 + 184) = 0LL;
    *(_DWORD *)(a1 + 192) = 0;
  }

  if (*(void *)(a1 + 120)) {
    sub_100033924((_DWORD **)(a1 + 120), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 1150LL);
  }
  sub_100033920((void *)(a1 + 120), *(void *)(v11 + 120));
  __int128 v28 = *(_OWORD *)(v11 + 203);
  *(_WORD *)(a1 + 219) = *(_WORD *)(v11 + 219);
  *uint64_t v23 = v28;
  uint64_t v29 = *(void *)(a1 + 112);
  *(_BYTE *)(a1 + 221) = *(_BYTE *)(a1 + 221) & 0xB1 | *(_BYTE *)(v11 + 221) & 0xCF;
  if (v29) {
    sub_10005515C( (void *)(a1 + 112),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1156LL,  a4,  a5,  a6,  a7,  a8);
  }
  uint64_t v30 = *(_DWORD **)(v11 + 112);
  if (v30)
  {
    sub_100033F18( (void *)(a1 + 112),  v30,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1158LL,  a5,  a6,  a7,  a8);
    sub_10005515C( (void *)(v11 + 112),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1159LL,  v31,  v32,  v33,  v34,  v35);
  }

  if (*(void *)(a1 + 152)) {
    sub_100033F88( (void *)(a1 + 152),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1163LL,  a4,  a5,  a6,  a7,  a8);
  }
  uint64_t v36 = *(_DWORD **)(v11 + 152);
  if (v36)
  {
    if ((*(_BYTE *)(v11 + 223) & 0xFE) == 2) {
      sub_100033F18( (void *)(a1 + 152),  v36,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1171LL,  a5,  a6,  a7,  a8);
    }
    sub_100033F88( (void *)(v11 + 152),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1172LL,  a4,  a5,  a6,  a7,  a8);
  }

  uint64_t v37 = *(void **)(a1 + 104);
  if (v37) {
    sub_10005CE20( v37,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1177LL,  a4,  a5,  a6,  a7,  a8);
  }
  *(void *)(a1 + 104) = *(void *)(v11 + 104);
  *(void *)(v11 + 104) = 0LL;
  uint64_t v38 = *(_DWORD **)(v11 + 160);
  if (v38)
  {
    if (*(void *)(a1 + 160))
    {
      sub_10003DC78( (void **)(a1 + 160),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1184LL,  a4,  a5,  a6,  a7,  a8);
      uint64_t v38 = *(_DWORD **)(v11 + 160);
    }

    sub_100033F18( (void *)(a1 + 160),  v38,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1187LL,  a5,  a6,  a7,  a8);
  }

  char v39 = *(_DWORD **)(v11 + 168);
  if (v39)
  {
    if (*(void *)(a1 + 168))
    {
      sub_10003DC78( (void **)(a1 + 168),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1192LL,  a4,  a5,  a6,  a7,  a8);
      char v39 = *(_DWORD **)(v11 + 168);
    }

    sub_100033F18( (void *)(a1 + 168),  v39,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1195LL,  a5,  a6,  a7,  a8);
  }

  a2 = *(void *)(v11 + 176);
  if (a2)
  {
    if (*(void *)(a1 + 176))
    {
      sub_10003DC78( (void **)(a1 + 176),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1200LL,  a4,  a5,  a6,  a7,  a8);
      a2 = *(void *)(v11 + 176);
    }

    sub_100033F18( (void *)(a1 + 176),  (_DWORD *)a2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1202LL,  a5,  a6,  a7,  a8);
  }

  if (*(void *)(a1 + 184)) {
    sub_10002BC20(a1, a2, a3, a4, a5, a6, a7, a8);
  }
  if (*(_BYTE *)v23) {
    sub_10002BE60(a1, a2, a3, a4, a5, a6, a7, a8);
  }
  *(void *)(a1 + 264) = *(void *)(v11 + 264);
  *(_OWORD *)(a1 + 240) = *(_OWORD *)(v11 + 240);
  *(void *)(a1 + 256) = *(void *)(v11 + 256);
  *(void *)(a1 + 88) = *(void *)(v11 + 88);
  *(_BYTE *)(a1 + 223) = *(_BYTE *)(v11 + 223);
LABEL_65:
  if (v9) {
    *(void *)(a1 + 256) = 0LL;
  }
  uint64_t v40 = *(void *)(a1 + 136);
  if (!v40)
  {
    __int128 v81 = *(_OWORD *)(a1 + 56);
    int v82 = *(_DWORD *)(a1 + 72);
    char v80 = sub_100040144((int *)&v81, a2, a3, a4, a5, a6, a7, a8);
    sub_10006221C("Supersede_lease: lease %s with no pool.", v43, v44, v45, v46, v47, v48, v49, v80);
    return 0LL;
  }

  int v41 = *(unsigned __int8 *)(a1 + 222);
  switch(*(_BYTE *)(a1 + 222))
  {
    case 1:
      if ((*(_BYTE *)(a1 + 221) & 4) != 0) {
        goto LABEL_127;
      }
      char v51 = 0;
      int v42 = (_DWORD **)(v40 + 88);
      --*(_DWORD *)(v40 + 132);
      break;
    case 2:
      int v42 = (_DWORD **)(v40 + 72);
      goto LABEL_77;
    case 3:
    case 4:
    case 6:
      int v42 = (_DWORD **)(v40 + 80);
      goto LABEL_77;
    case 5:
      int v42 = (_DWORD **)(v40 + 104);
LABEL_77:
      char v51 = 1;
      break;
    case 7:
      if ((*(_BYTE *)(a1 + 221) & 4) != 0)
      {
LABEL_127:
        char v51 = 0;
        int v42 = (_DWORD **)(v40 + 112);
      }

      else
      {
        char v51 = 0;
        int v42 = (_DWORD **)(v40 + 96);
        --*(_DWORD *)(v40 + 136);
      }

      break;
    default:
      sub_10006221C("Lease with bogus binding state: %d", a2, a3, a4, a5, a6, a7, a8, *(_BYTE *)(a1 + 222));
      return 0LL;
  }

  uint64_t v52 = 0LL;
  int v53 = v42;
  do
  {
    uint64_t v54 = v52;
    uint64_t v52 = *v53;
    int v53 = (void *)(*v53 + 32LL);
    if (v52) {
      BOOL v55 = v52 == a1;
    }
    else {
      BOOL v55 = 1;
    }
  }

  while (!v55);
  if (!v52)
  {
    else {
      uint64_t v65 = "unknown";
    }
    sub_100061FB4("Lease with binding state %s not on its queue.", a2, a3, a4, a5, a6, a7, a8, (char)v65);
  }

  if (v54)
  {
    sub_10003389C((_DWORD **)(v54 + 32), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 1308LL);
    uint64_t v62 = *(void *)(a1 + 32);
    if (!v62) {
      goto LABEL_95;
    }
    sub_100033898(v54 + 32, v62, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 1310LL);
    uint64_t v63 = (_DWORD **)(a1 + 32);
    uint64_t v64 = 1311LL;
  }

  else
  {
    sub_10003389C(v42, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 1314LL);
    uint64_t v62 = *(void *)(a1 + 32);
    if (!v62) {
      goto LABEL_95;
    }
    sub_100033898(v42, v62, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 1316LL);
    uint64_t v63 = (_DWORD **)(a1 + 32);
    uint64_t v64 = 1317LL;
  }

  sub_10003389C(v63, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", v64);
LABEL_95:
  if (v10) {
    BOOL v66 = 1;
  }
  else {
    BOOL v66 = v8 == 0;
  }
  char v67 = !v66;
  if (v66)
  {
    sub_10002C0AC(a1);
    uint64_t result = sub_10002C3C8(a1, v68, v69, v70, v71, v72, v73, v74);
    if (!(_DWORD)result) {
      return result;
    }
    uint64_t v75 = *(void *)(a1 + 96);
    if (v75)
    {
      if (v75 > qword_10008CE80)
      {
        uint64_t v76 = *(uint64_t **)(a1 + 136);
        uint64_t v77 = v76[15];
        if (v75 < v77 || !v77)
        {
          v76[15] = v75;
          *(void *)&__int128 v81 = v75;
          DWORD2(v81) = 0;
          sub_10003BEE8( (uint64_t **)&v81,  (uint64_t)sub_10002C5DC,  v76,  (uint64_t (*)(void, void, void, void))sub_1000338FC,  (uint64_t)sub_100033900);
        }
      }
    }

    if (v10)
    {
      uint64_t result = sub_10000C554(a1);
      if (!(_DWORD)result) {
        return result;
      }
      if ((dword_1000BD2B0 & 1) == 0)
      {
        uint64_t result = sub_10000E1BC();
        if (!(_DWORD)result) {
          return result;
        }
      }
    }
  }

  else
  {
    uint64_t result = sub_10002C3C8(a1, v62, v56, v57, v58, v59, v60, v61);
    if (!(_DWORD)result) {
      return result;
    }
  }

  if (!v9 || (*(_BYTE *)(a1 + 224) = *(_BYTE *)(a1 + 222), uint64_t result = sub_100026CEC(a1, v8), (_DWORD)result))
  {
    if ((v51 & 1) == 0)
    {
      uint64_t v78 = *(void *)(a1 + 136);
      if (*(void *)(v78 + 160)) {
        sub_1000268CC(v78);
      }
    }

    if ((v67 & 1) == 0
      && *(void *)(a1 + 96) < qword_10008CE80
      && *(unsigned __int8 *)(a1 + 223) != *(unsigned __int8 *)(a1 + 222))
    {
      sub_10002C5DC(*(void *)(a1 + 136));
    }

    return 1LL;
  }

  return result;
}

  uint64_t v21 = &v29;
  uint64_t v22 = 2176LL;
  return sub_10003389C(v21, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", v22);
}

      int v8 = *v10;
    }

    while (*v10);
  }

  return 0LL;
}

  *uint64_t v2 = 0;
  return result;
}
    }
  }

  uint64_t v5 = 0LL;
  uint64_t v6 = 0;
LABEL_3:
  uint64_t v7 = (_BYTE *)(a1 + v5);
LABEL_4:
  *uint64_t v7 = 0;
  if (v5) {
    return v5;
  }
  else {
    return (v6 - 1);
  }
}

uint64_t sub_10002B928( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = result;
  uint64_t v30 = 0LL;
  if (*(_WORD *)(result + 192)
    && (uint64_t result = sub_100063738( &v30,  (uint64_t (**)(unsigned __int8 *, int, unsigned int))qword_10008BE40,  *(const char **)(result + 184),  *(unsigned __int16 *)(result + 192),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  2013LL,  a7,  a8),  (_DWORD)result))
  {
    uint64_t v12 = v30;
    if (v30 == v8)
    {
      sub_100063620( qword_10008BE40,  *(const char **)(v8 + 184),  *(unsigned __int16 *)(v8 + 192),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  2024LL,  v9,  v10,  v11);
      uint64_t v28 = *(void *)(v8 + 40);
      size_t v27 = (_DWORD **)(v8 + 40);
      uint64_t v26 = v28;
      if (v28)
      {
        sub_1000634B8( qword_10008BE40,  *(const char **)(v26 + 184),  *(unsigned __int16 *)(v26 + 192),  v26,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  2028LL,  v24,  v25,  v29);
        uint64_t v18 = v27;
        uint64_t v19 = 2029LL;
LABEL_12:
        sub_10003389C(v18, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", v19);
      }
    }

    else
    {
      while (1)
      {
        uint64_t v13 = v12;
        uint64_t v12 = *(void *)(v12 + 40);
        if (!v12) {
          break;
        }
        if (v12 == v8)
        {
          uint64_t v14 = v13 + 40;
          sub_10003389C( (_DWORD **)(v13 + 40),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  2037LL);
          uint64_t v17 = *(void *)(v8 + 40);
          uint64_t v16 = (_DWORD **)(v8 + 40);
          uint64_t v15 = v17;
          if (!v17) {
            break;
          }
          sub_100033898(v14, v15, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 2040LL);
          uint64_t v18 = v16;
          uint64_t v19 = 2042LL;
          goto LABEL_12;
        }
      }
    }

    uint64_t v22 = &v30;
    uint64_t v23 = 2048LL;
  }

  else
  {
    uint64_t v21 = *(void *)(v8 + 40);
    uint64_t v20 = (uint64_t *)(v8 + 40);
    if (!v21) {
      return result;
    }
    uint64_t v22 = v20;
    uint64_t v23 = 2015LL;
  }

  return sub_10003389C((_DWORD **)v22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", v23);
}

uint64_t sub_10002BA70( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = result;
  uint64_t v28 = 0LL;
  char v29 = 0LL;
  if (!*(_BYTE *)(result + 203)
    || (uint64_t result = sub_100063738( &v29,  (uint64_t (**)(unsigned __int8 *, int, unsigned int))qword_10008BE30,  (const char *)(result + 204),  *(unsigned __int8 *)(result + 203),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  2134LL,  a7,  a8),  !(_DWORD)result))
  {
    uint64_t v20 = *(void *)(v8 + 48);
    uint64_t v19 = (_DWORD **)(v8 + 48);
    if (!v20) {
      return result;
    }
    uint64_t v21 = v19;
    uint64_t v22 = 2136LL;
    return sub_10003389C(v21, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", v22);
  }

  uint64_t v12 = v29;
  if (v29 == (_DWORD *)v8)
  {
    uint64_t result = sub_100063620( qword_10008BE30,  (const char *)(v8 + 204),  *(unsigned __int8 *)(v8 + 203),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  2146LL,  v9,  v10,  v11);
    uint64_t v27 = *(void *)(v8 + 48);
    uint64_t v26 = (_DWORD **)(v8 + 48);
    uint64_t v25 = v27;
    if (!v27) {
      goto LABEL_15;
    }
    sub_1000634B8( qword_10008BE30,  (const char *)(v25 + 204),  *(unsigned __int8 *)(v25 + 203),  v25,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  2151LL,  v23,  v24,  (char)v28);
    uint64_t v17 = v26;
    uint64_t v18 = 2152LL;
    goto LABEL_14;
  }

  uint64_t v13 = *((void *)v29 + 6);
  if (v13)
  {
    while (v13 != v8)
    {
      sub_100033898(&v28, v13, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 2169LL);
      sub_10003389C(&v29, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 2170LL);
      sub_100033898(&v29, v28, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 2171LL);
      sub_10003389C(&v28, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 2172LL);
      uint64_t v12 = v29;
      uint64_t v13 = *((void *)v29 + 6);
      if (!v13) {
        goto LABEL_16;
      }
    }

    uint64_t result = sub_10003389C( (_DWORD **)v12 + 6,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  2160LL);
    uint64_t v16 = *(void *)(v8 + 48);
    uint64_t v15 = (_DWORD **)(v8 + 48);
    uint64_t v14 = v16;
    if (!v16)
    {
LABEL_15:
      if (!v29) {
        return result;
      }
      goto LABEL_16;
    }

    sub_100033898(v29 + 12, v14, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 2163LL);
    uint64_t v17 = v15;
    uint64_t v18 = 2165LL;
LABEL_14:
    uint64_t result = sub_10003389C(v17, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", v18);
    goto LABEL_15;
  }

uint64_t sub_10002BC20( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v23 = 0LL;
  uint64_t v24 = 0LL;
  uint64_t v21 = 0LL;
  uint64_t v22 = 0LL;
  if (!*(_WORD *)(a1 + 192))
  {
    uint64_t v14 = 0LL;
    return sub_1000634B8( qword_10008BE40,  *(const char **)(a1 + 184),  v14,  a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1949LL,  a7,  a8,  (char)v21);
  }

  if (!sub_100063738( &v24,  (uint64_t (**)(unsigned __int8 *, int, unsigned int))qword_10008BE40,  *(const char **)(a1 + 184),  *(unsigned __int16 *)(a1 + 192),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1947LL,  a7,  a8))
  {
    uint64_t v14 = *(unsigned __int16 *)(a1 + 192);
    return sub_1000634B8( qword_10008BE40,  *(const char **)(a1 + 184),  v14,  a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1949LL,  a7,  a8,  (char)v21);
  }

  sub_100033898(&v23, v24, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 1958LL);
  uint64_t v9 = v23;
  if (!v23) {
    goto LABEL_20;
  }
  while (1)
  {
    int v10 = sub_10002CE50((uint64_t)v9, a1);
    uint64_t v11 = v22;
    if (v10) {
      break;
    }
    if (v22)
    {
      sub_10003389C(&v22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 1964LL);
      uint64_t v9 = v23;
    }

    sub_100033898(&v22, v9, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 1965LL);
    uint64_t v12 = *((void *)v23 + 5);
    if (v12) {
      sub_100033898(&v21, v12, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 1968LL);
    }
    sub_10003389C(&v23, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 1970LL);
    if (v21)
    {
      sub_100033898(&v23, v21, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 1973LL);
      sub_10003389C(&v21, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 1974LL);
    }

    uint64_t v9 = v23;
    if (!v23)
    {
      uint64_t v11 = v22;
      break;
    }
  }

  if (v11)
  {
    uint64_t v13 = *((void *)v11 + 5);
    if (v13)
    {
      sub_100033898(a1 + 40, v13, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 1990LL);
      sub_10003389C((_DWORD **)v22 + 5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 1991LL);
      uint64_t v11 = v22;
    }

    sub_100033898(v11 + 10, a1, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 1993LL);
    sub_10003389C(&v22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 1995LL);
  }

  else
  {
LABEL_20:
    sub_100033898(a1 + 40, v24, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 1982LL);
    sub_100063620( qword_10008BE40,  *(const char **)(a1 + 184),  *(unsigned __int16 *)(a1 + 192),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1984LL,  v16,  v17,  v18);
    sub_1000634B8( qword_10008BE40,  *(const char **)(a1 + 184),  *(unsigned __int16 *)(a1 + 192),  a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1986LL,  v19,  v20,  (char)v21);
  }

  if (v23) {
    sub_10003389C(&v23, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 1999LL);
  }
  return sub_10003389C(&v24, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 2000LL);
}

uint64_t sub_10002BE60( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v24 = 0LL;
  uint64_t v25 = 0LL;
  uint64_t v22 = 0LL;
  uint64_t v23 = 0LL;
  uint64_t v9 = (const char *)(a1 + 204);
  if (!*(_BYTE *)(a1 + 203))
  {
    uint64_t v15 = 0LL;
    return sub_1000634B8( qword_10008BE30,  v9,  v15,  a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  2066LL,  a7,  a8,  (char)v22);
  }

  if (!sub_100063738( &v25,  (uint64_t (**)(unsigned __int8 *, int, unsigned int))qword_10008BE30,  v9,  *(unsigned __int8 *)(a1 + 203),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  2063LL,  a7,  a8))
  {
    uint64_t v15 = *(unsigned __int8 *)(a1 + 203);
    return sub_1000634B8( qword_10008BE30,  v9,  v15,  a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  2066LL,  a7,  a8,  (char)v22);
  }

  sub_100033898(&v24, v25, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 2075LL);
  int v10 = v24;
  if (!v24) {
    goto LABEL_20;
  }
  while (1)
  {
    int v11 = sub_10002CE50((uint64_t)v10, a1);
    uint64_t v12 = v23;
    if (v11) {
      break;
    }
    if (v23)
    {
      sub_10003389C(&v23, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 2081LL);
      int v10 = v24;
    }

    sub_100033898(&v23, v10, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 2082LL);
    uint64_t v13 = *((void *)v24 + 6);
    if (v13) {
      sub_100033898(&v22, v13, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 2085LL);
    }
    sub_10003389C(&v24, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 2087LL);
    if (v22)
    {
      sub_100033898(&v24, v22, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 2090LL);
      sub_10003389C(&v22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 2091LL);
    }

    int v10 = v24;
    if (!v24)
    {
      uint64_t v12 = v23;
      break;
    }
  }

  if (v12)
  {
    uint64_t v14 = *((void *)v12 + 6);
    if (v14)
    {
      sub_100033898(a1 + 48, v14, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 2110LL);
      sub_10003389C((_DWORD **)v23 + 6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 2111LL);
      uint64_t v12 = v23;
    }

    sub_100033898(v12 + 12, a1, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 2113LL);
    sub_10003389C(&v23, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 2115LL);
  }

  else
  {
LABEL_20:
    sub_100033898(a1 + 48, v25, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 2099LL);
    sub_100063620( qword_10008BE30,  v9,  *(unsigned __int8 *)(a1 + 203),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  2102LL,  v17,  v18,  v19);
    sub_1000634B8( qword_10008BE30,  v9,  *(unsigned __int8 *)(a1 + 203),  a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  2106LL,  v20,  v21,  (char)v22);
  }

  if (v24) {
    sub_10003389C(&v24, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 2119LL);
  }
  return sub_10003389C(&v25, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 2120LL);
}

uint64_t sub_10002C0AC(uint64_t result)
{
  uint64_t v1 = result;
  if (result)
  {
    uint64_t v2 = *(void *)(result + 136);
    if (v2)
    {
      uint64_t v3 = *(void *)(v2 + 160);
      if (v3)
      {
        uint64_t v5 = (char *)(result + 223);
        int v4 = *(unsigned __int8 *)(result + 223);
        uint64_t v7 = (_BYTE *)(result + 222);
        int v6 = *(unsigned __int8 *)(result + 222);
        if (v4 == v6) {
          goto LABEL_57;
        }
        if (v6 != 3 && (v6 != 2 || *(_DWORD *)(v3 + 240) != 1) || v4 != 1 && v4 != 7) {
          goto LABEL_31;
        }
LABEL_17:
        sub_10000F3C0(result, 0LL);
        uint64_t v14 = *(_DWORD **)(v1 + 160);
        if (v14)
        {
          sub_10003D510(0LL, 0LL, v1, 0LL, 0LL, 0LL, (uint64_t *)(v1 + 112), v14);
          if (*(void *)(v1 + 160)) {
            sub_10003DC78( (void **)(v1 + 160),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1426LL,  v10,  v11,  v12,  v13,  (uint64_t)v14);
          }
        }

        if (*(void *)(v1 + 176)) {
          sub_10003DC78( (void **)(v1 + 176),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1432LL,  v10,  v11,  v12,  v13,  (uint64_t)v14);
        }
        uint64_t v15 = *(void *)(v1 + 144);
        if (v15) {
          sub_1000038C0(v1, v15, v9, v10, v11, v12, v13, (uint64_t)v14);
        }
        if (*(void *)(v1 + 152)) {
          sub_100033F88( (void *)(v1 + 152),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1439LL,  v10,  v11,  v12,  v13,  (uint64_t)v14);
        }
        uint64_t v16 = *(void **)(v1 + 104);
        if (v16)
        {
          sub_10005CE20( v16,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1441LL,  v10,  v11,  v12,  v13,  (uint64_t)v14);
          *(void *)(v1 + 104) = 0LL;
        }

        uint64_t result = v1 + 120;
        if (*(void *)(v1 + 120)) {
          uint64_t result = sub_100033924( (_DWORD **)result,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1445LL);
        }
        *(void *)(v1 + 240) = *(void *)(v1 + 88);
        int v4 = *(unsigned __int8 *)(v1 + 223);
        int v6 = *(unsigned __int8 *)(v1 + 222);
        goto LABEL_31;
      }
    }
  }

  uint64_t v5 = (char *)(result + 223);
  int v4 = *(unsigned __int8 *)(result + 223);
  uint64_t v7 = (_BYTE *)(result + 222);
  int v6 = *(unsigned __int8 *)(result + 222);
  if (v4 == v6) {
    goto LABEL_57;
  }
  uint64_t v3 = 0LL;
  if (v4 != 4 && v6 == 2) {
    goto LABEL_17;
  }
LABEL_31:
  if (v4 == v6)
  {
    int v4 = v6;
    goto LABEL_57;
  }

  if (v6 != 4 || v3 == 0)
  {
    if (v6 != 2 || v4 != 4 || v3) {
      goto LABEL_57;
    }
  }

  else if (v4 != 1 && v4 != 7)
  {
    goto LABEL_57;
  }

  sub_10000F3C0(v1, 0LL);
  uint64_t v23 = *(_DWORD **)(v1 + 176);
  if (v23)
  {
    sub_10003D510(0LL, 0LL, v1, 0LL, 0LL, 0LL, (uint64_t *)(v1 + 112), v23);
    sub_10003DC78( (void **)(v1 + 176),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1491LL,  v24,  v25,  v26,  v27,  v28);
  }

  if (*(void *)(v1 + 160)) {
    sub_10003DC78( (void **)(v1 + 160),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1497LL,  v19,  v20,  v21,  v22,  (uint64_t)v23);
  }
  uint64_t v29 = *(void *)(v1 + 144);
  if (v29) {
    sub_1000038C0(v1, v29, v18, v19, v20, v21, v22, (uint64_t)v23);
  }
  if (*(void *)(v1 + 152)) {
    sub_100033F88( (void *)(v1 + 152),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1505LL,  v19,  v20,  v21,  v22,  (uint64_t)v23);
  }
  uint64_t v30 = *(void **)(v1 + 104);
  if (v30)
  {
    sub_10005CE20( v30,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1507LL,  v19,  v20,  v21,  v22,  (uint64_t)v23);
    *(void *)(v1 + 104) = 0LL;
  }

  uint64_t result = v1 + 120;
  if (*(void *)(v1 + 120)) {
    uint64_t result = sub_100033924( (_DWORD **)result,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1511LL);
  }
  *(void *)(v1 + 240) = *(void *)(v1 + 88);
  int v4 = *(unsigned __int8 *)(v1 + 223);
LABEL_57:
  *uint64_t v7 = v4;
  if ((v4 - 3) >= 4)
  {
    if (v4 == 2)
    {
      uint64_t v32 = *(void *)(v1 + 136);
      if (v32 && *(void *)(v32 + 160)) {
        char v33 = 3;
      }
      else {
        char v33 = 1;
      }
      *uint64_t v5 = v33;
    }
  }

  else
  {
    *(_BYTE *)(v1 + 223) = 1;
    uint64_t v31 = *(void *)(*(void *)(v1 + 136) + 160LL);
    if (v31)
    {
      if (*(_DWORD *)(v31 + 64) == 4) {
        *(void *)(v1 + 248) = *(void *)(v31 + 72) + *(unsigned int *)(v31 + 160);
      }
    }
  }

  return result;
}

uint64_t sub_10002C3C8( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 136);
  if (!v8) {
    return 0LL;
  }
  switch(*(_BYTE *)(a1 + 222))
  {
    case 1:
      if ((*(_BYTE *)(a1 + 221) & 4) != 0) {
        goto LABEL_16;
      }
      uint64_t v10 = (uint64_t *)(v8 + 88);
      ++*(_DWORD *)(v8 + 132);
      goto LABEL_17;
    case 2:
      uint64_t v10 = (uint64_t *)(v8 + 72);
      goto LABEL_17;
    case 3:
    case 4:
    case 6:
      uint64_t v10 = (uint64_t *)(v8 + 80);
      uint64_t v11 = *(void *)(v8 + 160);
      if (!v11 || *(_DWORD *)(v11 + 64) != 4) {
        goto LABEL_17;
      }
      uint64_t v12 = *(void *)(a1 + 248);
      if (v12 <= *(void *)(a1 + 88)) {
        uint64_t v12 = *(void *)(a1 + 88);
      }
      goto LABEL_18;
    case 5:
      uint64_t v10 = (uint64_t *)(v8 + 104);
      goto LABEL_17;
    case 7:
      if ((*(_BYTE *)(a1 + 221) & 4) != 0)
      {
LABEL_16:
        uint64_t v10 = (uint64_t *)(v8 + 112);
      }

      else
      {
        uint64_t v10 = (uint64_t *)(v8 + 96);
        ++*(_DWORD *)(v8 + 136);
      }

uint64_t **sub_10002C5DC(uint64_t **result)
{
  uint64_t v1 = (uint64_t *)result;
  uint64_t v2 = 0LL;
  uint64_t v14 = 0LL;
  uint64_t v15 = 0LL;
  v16[0] = result + 11;
  v16[1] = result + 9;
  v16[2] = result + 10;
  v16[3] = result + 13;
  v16[4] = result + 12;
  v16[5] = result + 14;
  uint64_t v3 = 0x7FFFFFFFLL;
  do
  {
    int v4 = *(_DWORD **)v16[v2];
    if (v4)
    {
      uint64_t v5 = v1[20];
      if (!v5 || *(_DWORD *)(v5 + 64) == 4 || (_DWORD)v2 != 2 && ((_DWORD)v2 != 1 || *(_DWORD *)(v5 + 240) != 1))
      {
        uint64_t v6 = 1815LL;
LABEL_9:
        sub_100033898(&v14, v4, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", v6);
        while (1)
        {
          uint64_t result = v14;
          if (!v14) {
            break;
          }
          if (v15)
          {
            sub_10003389C(&v15, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 1820LL);
            uint64_t result = v14;
          }

          uint64_t v10 = result[4];
          if (v10)
          {
            sub_100033898(&v15, v10, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 1822LL);
            uint64_t result = v14;
          }

          uint64_t v11 = (uint64_t)result[12];
          if (v11 > qword_10008CE80)
          {
            if (v11 < v3) {
              uint64_t v3 = (uint64_t)result[12];
            }
            break;
          }

          sub_10003389C((_DWORD **)&v14, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 1842LL);
          int v4 = v15;
          if (v15)
          {
            uint64_t v6 = 1844LL;
            goto LABEL_9;
          }
        }

        if (v15)
        {
          sub_10003389C(&v15, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 1847LL);
          uint64_t result = v14;
        }

        if (result) {
          uint64_t result = (uint64_t **)sub_10003389C( (_DWORD **)&v14,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1849LL);
        }
      }
    }

    ++v2;
  }

  while (v2 != 6);
  if (v3 == 0x7FFFFFFF)
  {
    v1[15] = 0LL;
  }

  else
  {
    v1[15] = v3;
    uint64_t v12 = (uint64_t *)v3;
    int v13 = 0;
    return sub_10003BEE8( &v12,  (uint64_t)sub_10002C5DC,  v1,  (uint64_t (*)(void, void, void, void))sub_1000338FC,  (uint64_t)sub_100033900);
  }

  return result;
}

BOOL sub_10002C7F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char v33 = 0LL;
  if (sub_10003387C( (void **)&v33,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1575LL)) {
    return 0LL;
  }
  int v13 = v33;
  int v14 = *(_DWORD *)(a2 + 72);
  *(_OWORD *)(v33 + 56) = *(_OWORD *)(a2 + 56);
  *((_DWORD *)v13 + 18) = v14;
  *((_OWORD *)v13 + 5) = *(_OWORD *)(a2 + 80);
  *((_WORD *)v13 + 96) = *(_WORD *)(a2 + 192);
  size_t v15 = *(unsigned __int16 *)(a2 + 194);
  *((_WORD *)v13 + 97) = v15;
  uint64_t v16 = *(int **)(a2 + 184);
  if (v16 == (int *)(a2 + 196))
  {
    *((void *)v13 + 23) = v13 + 196;
    int v18 = *v16;
    *(_DWORD *)(v13 + 199) = *(int *)((char *)v16 + 3);
    *((_DWORD *)v13 + 49) = v18;
  }

  else if (*(_WORD *)(a2 + 194))
  {
    uint64_t v17 = sub_10005CDE4(v15);
    *((void *)v33 + 23) = v17;
    if (!v17)
    {
      uint64_t v32 = 1592LL;
      goto LABEL_26;
    }

    memcpy(v17, *(const void **)(a2 + 184), *(unsigned __int16 *)(a2 + 194));
  }

  else
  {
    *((void *)v13 + 23) = 0LL;
  }

  uint64_t v19 = *(const char **)(a2 + 104);
  if (v19)
  {
    int v20 = strlen(v19);
    uint64_t v21 = (char *)sub_10005CDE4((v20 + 1));
    *((void *)v33 + 13) = v21;
    if (v21)
    {
      strcpy(v21, *(const char **)(a2 + 104));
      goto LABEL_12;
    }

    uint64_t v32 = 1601LL;
LABEL_26:
    sub_10003389C((_DWORD **)&v33, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", v32);
    return 0LL;
  }

void **sub_10002CAA0(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = *(_DWORD **)(a1 + 176);
  if (v8)
  {
    sub_10003D510(0LL, (int *)a2, a1, 0LL, *(void *)(a2 + 160), 0LL, (uint64_t *)(a1 + 112), v8);
    if (*(void *)(a1 + 176)) {
      sub_10003DC78( (void **)(a1 + 176),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1659LL,  v4,  v5,  v6,  v7,  (uint64_t)v8);
    }
  }

  uint64_t result = (void **)(a1 + 160);
  if (*(void *)(a1 + 160)) {
    uint64_t result = (void **)sub_10003DC78( result,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1666LL,  v4,  v5,  v6,  v7,  (uint64_t)v8);
  }
  unsigned int v10 = *(unsigned __int8 *)(a1 + 222);
  BOOL v11 = v10 > 7;
  int v12 = (1 << v10) & 0xDA;
  if (v11 || v12 == 0)
  {
    if (*(void *)(a1 + 168)) {
      sub_10003DC78( (void **)(a1 + 168),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1675LL,  v4,  v5,  v6,  v7,  (uint64_t)v8);
    }
    if (*(void *)(a1 + 112)) {
      sub_10005515C( (void *)(a1 + 112),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1679LL,  v4,  v5,  v6,  v7,  (uint64_t)v8);
    }
    uint64_t v14 = xmmword_10008CE80;
    *(void *)(a1 + 88) = xmmword_10008CE80;
    *(void *)(a1 + 240) = v14;
    uint64_t v15 = *(void *)(a1 + 136);
    if (v15 && *(void *)(v15 + 160)) {
      char v16 = 4;
    }
    else {
      char v16 = 1;
    }
    *(_BYTE *)(a1 + 223) = v16;
    return (void **)sub_10002B1D0(a1, 0LL, 1uLL, 1LL, 1LL, v6, v7, (uint64_t)v8);
  }

  return result;
}

uint64_t sub_10002CBE4(uint64_t a1)
{
  uint64_t v26 = 0LL;
  sub_10000F3C0(a1, 0LL);
  uint64_t result = sub_10002C7F0( (uint64_t)&v26,  a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1713LL);
  if ((_DWORD)result)
  {
    unsigned int v10 = v26;
    if (*((void *)v26 + 14))
    {
      sub_10005515C( (void *)v26 + 14,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1717LL,  v5,  v6,  v7,  v8,  v9);
      unsigned int v10 = v26;
    }

    *((void *)v10 + 11) = qword_10008CE80;
    *((_BYTE *)v10 + 223) = 5;
    __int128 v27 = *(_OWORD *)(a1 + 56);
    int v28 = *(_DWORD *)(a1 + 72);
    char v11 = sub_100040144((int *)&v27, v3, v4, v5, v6, v7, v8, v9);
    sub_10006221C("Abandoning IP address %s: %s", v12, v13, v14, v15, v16, v17, v18, v11);
    uint64_t v24 = v26;
    *((_BYTE *)v26 + 203) = 0;
    uint64_t v25 = (_DWORD *)*((void *)v24 + 23);
    if (v25)
    {
      if (v25 != v24 + 49)
      {
        sub_10005CE20( v25,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1726LL,  v19,  v20,  v21,  v22,  v23);
        uint64_t v24 = v26;
      }
    }

    *((void *)v24 + 23) = 0LL;
    v24[48] = 0;
    sub_10002B1D0(a1, (uint64_t)v24, 1uLL, 1LL, 1LL, v21, v22, v23);
    return sub_10003389C(&v26, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 1731LL);
  }

  return result;
}

uint64_t sub_10002CD24(uint64_t a1)
{
  uint64_t v13 = 0LL;
  sub_10000F3C0(a1, 0LL);
  uint64_t result = sub_10002C7F0( (uint64_t)&v13,  a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1745LL);
  if ((_DWORD)result)
  {
    uint64_t v8 = *(void *)(a1 + 136);
    if (v8 && *(void *)(v8 + 160)) {
      char v9 = 6;
    }
    else {
      char v9 = 1;
    }
    unsigned int v10 = v13;
    *((_BYTE *)v13 + 223) = v9;
    *((void *)v10 + 11) = xmmword_10008CE80;
    *((_BYTE *)v10 + 203) = 0;
    char v11 = (_DWORD *)*((void *)v10 + 23);
    if (v11) {
      BOOL v12 = v11 == v10 + 49;
    }
    else {
      BOOL v12 = 1;
    }
    if (!v12)
    {
      sub_10005CE20( v11,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  1760LL,  v3,  v4,  v5,  v6,  v7);
      unsigned int v10 = v13;
    }

    *((void *)v10 + 23) = 0LL;
    v10[48] = 0;
    sub_10002B1D0(a1, (uint64_t)v10, 1uLL, 1LL, 1LL, v5, v6, v7);
    return sub_10003389C(&v13, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 1765LL);
  }

  return result;
}

uint64_t sub_10002CE00( void *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((_DWORD)a3) {
    return sub_100063738( a1,  (uint64_t (**)(unsigned __int8 *, int, unsigned int))qword_10008BE40,  a2,  a3,  a4,  a5,  a7,  a8);
  }
  else {
    return 0LL;
  }
}

uint64_t sub_10002CE28( void *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((_DWORD)a3) {
    return sub_100063738( a1,  (uint64_t (**)(unsigned __int8 *, int, unsigned int))qword_10008BE30,  a2,  a3,  a4,  a5,  a7,  a8);
  }
  else {
    return 0LL;
  }
}

uint64_t sub_10002CE50(uint64_t a1, uint64_t a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 222);
  if ((v2 - 3) < 2)
  {
    int v5 = *(unsigned __int8 *)(a2 + 222);
  }

  else if (v2 == 5)
  {
    if (*(_BYTE *)(a2 + 222) != 5) {
      return 1LL;
    }
  }

  else
  {
    if (v2 == 2)
    {
      if (*(_BYTE *)(a2 + 222) == 2)
      {
        uint64_t v3 = *(void *)(a2 + 88);
        uint64_t v4 = *(void *)(a1 + 88);
        return v3 >= v4;
      }

      return 0LL;
    }
  }

  uint64_t v3 = *(void *)(a2 + 264);
  uint64_t v4 = *(void *)(a1 + 264);
  return v3 >= v4;
}

uint64_t sub_10002CEFC( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = off_100088018;
  if (off_100088018[2])
  {
    dword_10008BE48 = 0;
    do
    {
      for (uint64_t i = v8[2]; i; uint64_t i = *(void *)(i + 32))
        sub_10000DDB8(*(void *)(i + 48), 0LL, i);
      uint64_t v8 = (uint64_t *)*v8;
    }

    while (v8);
    sub_1000622D4("Wrote %d class decls to leases file.", a2, a3, a4, a5, a6, a7, a8, dword_10008BE48);
  }

  uint64_t v10 = qword_10008C130;
  if (qword_10008C130)
  {
    unint64_t v11 = *(unsigned int *)qword_10008C130;
    if ((_DWORD)v11)
    {
      unint64_t v12 = 0LL;
      char v13 = 0;
      do
      {
        uint64_t v14 = *(void **)(v10 + 8 * v12 + 40);
        if (v14)
        {
          do
          {
            uint64_t v15 = v14[3];
            if ((*(_DWORD *)(v15 + 56) & 2) != 0 || (*(_DWORD *)(v15 + 56) & 5) == 5)
            {
              uint64_t result = sub_10000D5D4(v15);
              if (!(_DWORD)result) {
                return result;
              }
              ++v13;
            }

            uint64_t v14 = (void *)*v14;
          }

          while (v14);
          uint64_t v10 = qword_10008C130;
          unint64_t v11 = *(unsigned int *)qword_10008C130;
        }

        ++v12;
      }

      while (v12 < v11);
    }

    else
    {
      char v13 = 0;
    }

    sub_1000622D4("Wrote %d group decls to leases file.", a2, a3, a4, a5, a6, a7, a8, v13);
  }

  uint64_t v17 = qword_10008BE20;
  if (qword_10008BE20)
  {
    unint64_t v18 = *(unsigned int *)qword_10008BE20;
    if ((_DWORD)v18)
    {
      unint64_t v19 = 0LL;
      char v20 = 0;
      do
      {
        uint64_t v21 = *(void **)(v17 + 8 * v19 + 40);
        if (v21)
        {
          do
          {
            uint64_t v22 = v21[3];
            if ((~*(_DWORD *)(v22 + 192) & 5) == 0)
            {
              uint64_t result = sub_10000D100(v22);
              if (!(_DWORD)result) {
                return result;
              }
              ++v20;
            }

            uint64_t v21 = (void *)*v21;
          }

          while (v21);
          uint64_t v17 = qword_10008BE20;
          unint64_t v18 = *(unsigned int *)qword_10008BE20;
        }

        ++v19;
      }

      while (v19 < v18);
    }

    else
    {
      char v20 = 0;
    }

    sub_1000622D4("Wrote %d deleted host decls to leases file.", a2, a3, a4, a5, a6, a7, a8, v20);
    uint64_t v30 = qword_10008BE20;
    if (qword_10008BE20)
    {
      unint64_t v31 = *(unsigned int *)qword_10008BE20;
      if ((_DWORD)v31)
      {
        unint64_t v32 = 0LL;
        char v33 = 0;
        do
        {
          uint64_t v34 = *(void **)(v30 + 8 * v32 + 40);
          if (v34)
          {
            do
            {
              uint64_t v35 = v34[3];
              uint64_t v34 = (void *)*v34;
            }

            while (v34);
            uint64_t v30 = qword_10008BE20;
            unint64_t v31 = *(unsigned int *)qword_10008BE20;
          }

          ++v32;
        }

        while (v32 < v31);
      }

      else
      {
        char v33 = 0;
      }

      sub_1000622D4("Wrote %d new dynamic host decls to leases file.", v23, v24, v25, v26, v27, v28, v29, v33);
    }
  }

  uint64_t result = sub_100022064();
  if ((_DWORD)result)
  {
    uint64_t v43 = qword_10008BE50;
    if (qword_10008BE50)
    {
      char v44 = 0;
      do
      {
        for (uint64_t j = *(void *)(v43 + 72); j; uint64_t j = *(void *)(j + 32))
        {
          uint64_t v46 = 0LL;
          v48[0] = j + 88;
          v48[1] = j + 72;
          v48[2] = j + 80;
          v48[3] = j + 104;
          v48[4] = j + 96;
          v48[5] = j + 112;
          do
          {
            for (uint64_t k = *(void *)v48[v46]; k; uint64_t k = *(void *)(k + 32))
            {
              if (*(_BYTE *)(k + 203) || *(_WORD *)(k + 192) || *(_BYTE *)(k + 222) != 1)
              {
                uint64_t result = sub_10000C554(k);
                if (!(_DWORD)result) {
                  return result;
                }
                ++v44;
              }
            }

            ++v46;
          }

          while (v46 != 6);
        }

        uint64_t v43 = *(void *)(v43 + 32);
      }

      while (v43);
    }

    else
    {
      char v44 = 0;
    }

    sub_1000622D4("Wrote %d leases to leases file.", v36, v37, v38, v39, v40, v41, v42, v44);
    uint64_t result = sub_10002F904();
    if ((_DWORD)result) {
      return sub_10000E1BC() != 0;
    }
  }

  return result;
}

uint64_t sub_10002D1F4( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a3 + 136))
  {
    if (sub_10002C3C8(a3, a2, a3, a4, a5, a6, a7, a8))
    {
      if (*(void *)(a3 + 184)) {
        sub_10002BC20(a3, v9, v10, v11, v12, v13, v14, v15);
      }
      if (*(_BYTE *)(a3 + 203)) {
        sub_10002BE60(a3, v9, v10, v11, v12, v13, v14, v15);
      }
      uint64_t v16 = *(void *)(a3 + 144);
      if (v16)
      {
        uint64_t v25 = 0LL;
        sub_1000338BC(&v25, v16, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 2481LL);
        sub_1000338C0(a3 + 144, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 2482LL);
        unsigned int v23 = *(unsigned __int8 *)(a3 + 222);
        if (v23 <= 6 && ((1 << v23) & 0x5C) != 0) {
          sub_1000039C0(a3, v25, v17, v18, v19, v20, v21, v22);
        }
        sub_1000338C0(&v25, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c", 2490LL);
      }
    }
  }

  else
  {
    sub_100063620( qword_10008BE38,  (const char *)(a3 + 60),  *(unsigned int *)(a3 + 56),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c",  2455LL,  a6,  a7,  a8);
  }

  return 0LL;
}

uint64_t sub_10002D2F4()
{
  dword_1000BD2B0 = 3;
  uint64_t result = sub_100063840( (unsigned int *)qword_10008BE38,  (unsigned int (*)(uint64_t, uint64_t, uint64_t))sub_10002D1F4);
  dword_1000BD2B0 &= ~2u;
  for (uint64_t i = qword_10008BE50; i; uint64_t i = *(void *)(i + 32))
  {
    for (uint64_t j = *(void *)(i + 72); j; uint64_t j = *(void *)(j + 32))
    {
      uint64_t result = (uint64_t)sub_10002C5DC((uint64_t **)j);
      uint64_t v10 = 0LL;
      v14[0] = j + 88;
      v14[1] = j + 72;
      v14[2] = j + 80;
      v14[3] = j + 104;
      v14[4] = j + 96;
      v14[5] = j + 112;
      *(void *)(j + 128) = 0LL;
      *(_DWORD *)(j + 136) = 0;
      do
      {
        for (uint64_t k = *(void *)v14[v10]; k; uint64_t k = *(void *)(k + 32))
        {
          ++*(_DWORD *)(j + 128);
          if (*(void *)(k + 88) <= qword_10008CE80)
          {
            int v12 = *(unsigned __int8 *)(k + 222);
            if (v12 == 7)
            {
              if ((_DWORD)v10 != 5)
              {
                if ((_DWORD)v10 != 4) {
LABEL_16:
                }
                  sub_100061FB4( "Impossible case at %s:%d.",  v3,  v4,  v5,  v6,  v7,  v8,  v9,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb.c");
                ++*(_DWORD *)(j + 136);
              }
            }

            else if (v12 == 1 && (_DWORD)v10 != 5)
            {
              if ((_DWORD)v10) {
                goto LABEL_16;
              }
              ++*(_DWORD *)(j + 132);
            }
          }

          if (*(void *)(j + 160) && *(void *)(k + 240) > *(void *)(k + 256) && (*(_BYTE *)(k + 221) & 0x10) == 0)
          {
            *(_BYTE *)(k + 224) = *(_BYTE *)(k + 222);
            uint64_t result = sub_100026CEC(k, 1);
          }
        }

        ++v10;
      }

      while (v10 != 6);
    }
  }

  dword_1000BD2B0 = 0;
  return result;
}

uint64_t sub_10002D4EC( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  for (uint64_t i = qword_10008BE58; i; uint64_t i = *(void *)(i + 32))
  {
    __int128 v53 = *(_OWORD *)(i + 84);
    LODWORD(v54) = *(_DWORD *)(i + 100);
    char v16 = sub_100040144((int *)&v53, v8, v9, v10, v11, v12, v13, v14);
    sub_10006238C("  Subnet %s", v17, v18, v19, v20, v21, v22, v23, v16);
    __int128 v53 = *(_OWORD *)(i + 104);
    LODWORD(v54) = *(_DWORD *)(i + 120);
    char v31 = sub_100040144((int *)&v53, v24, v25, v26, v27, v28, v29, v30);
    sub_10006238C("     netmask %s", v32, v33, v34, v35, v36, v37, v38, v31);
  }

  uint64_t result = sub_1000622D4("Shared networks:", v8, v9, v10, v11, v12, v13, v14, v52);
  uint64_t v47 = (void *)qword_10008BE50;
  if (qword_10008BE50)
  {
    do
    {
      uint64_t result = sub_1000622D4("  %s", v40, v41, v42, v43, v44, v45, v46, v47[5]);
      for (uint64_t j = v47[9]; j; uint64_t j = *(void *)(j + 32))
      {
        uint64_t v49 = 0LL;
        *(void *)&__int128 v53 = j + 88;
        *((void *)&v53 + 1) = j + 72;
        uint64_t v54 = j + 80;
        uint64_t v55 = j + 104;
        uint64_t v56 = j + 96;
        uint64_t v57 = j + 112;
        do
        {
          for (uint64_t k = **((void **)&v53 + v49); k; uint64_t k = *(void *)(k + 32))
            uint64_t result = sub_100050298(k, v40, v41, v42, v43, v44, v45, v46);
          ++v49;
        }

        while (v49 != 6);
      }

      uint64_t v47 = (void *)v47[4];
    }

    while (v47);
  }

  return result;
}

uint64_t sub_10002D664( uint64_t *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_100063100( a1,  (uint64_t)sub_1000338BC,  (uint64_t)sub_1000338C0,  a2,  (uint64_t (*)(char *, int, unsigned int))sub_1000632A8,  a3,  a4,  a8);
}

uint64_t sub_10002D68C( uint64_t *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_100063100( a1,  (uint64_t)sub_10002D6B4,  (uint64_t)sub_10002D71C,  a2,  (uint64_t (*)(char *, int, unsigned int))sub_1000632A8,  a3,  a4,  a8);
}

uint64_t sub_10002D6B4( void *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
LABEL_6:
    sub_10006221C("%s(%d): NULL pointer reference", (uint64_t)a2, a3, a4, a5, a6, a7, a8, a3);
    return 39LL;
  }

  if (!*a1)
  {
    if (a2)
    {
      uint64_t result = 0LL;
      *a1 = a2;
      ++*a2;
      return result;
    }

    goto LABEL_6;
  }

  sub_10006221C("%s(%d): non-NULL pointer", (uint64_t)a2, a3, a4, a5, a6, a7, a8, a3);
  return 39LL;
}

uint64_t sub_10002D71C( void **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || (uint64_t v10 = (int *)*a1) == 0LL)
  {
    sub_10006221C("%s(%d): NULL pointer", a2, a3, a4, a5, a6, a7, a8, a2);
    return 39LL;
  }

  *a1 = 0LL;
  int v11 = *v10;
  int v12 = *v10 - 1;
  *uint64_t v10 = v12;
  if (v11 <= 0)
  {
    sub_10006221C("%s(%d): negative refcnt", a2, a3, a4, a5, a6, a7, a8, a2);
    *uint64_t v10 = 0;
LABEL_8:
    uint64_t v14 = (void *)*((void *)v10 + 7);
    if (v14)
    {
      if (v10[9] >= 1)
      {
        uint64_t v15 = 0LL;
        uint64_t v16 = 0LL;
        do
        {
          sub_10002D8B8(*((void *)v10 + 7) + v15, a2, a3);
          ++v16;
          v15 += 8LL;
        }

        while (v16 < v10[9]);
        uint64_t v14 = (void *)*((void *)v10 + 7);
      }

      sub_10005CE20(v14, a2, a3, a4, a5, a6, a7, a8);
    }

    sub_100034EA8((_DWORD **)v10 + 1, a2, a3, a4, a5, a6, a7, a8);
    sub_10005CE20(v10, a2, a3, v17, v18, v19, v20, v21);
    return 0LL;
  }

  if (!v12) {
    goto LABEL_8;
  }
  return 0LL;
}

uint64_t sub_10002D828( uint64_t *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_100063100( a1,  (uint64_t)sub_10002D850,  (uint64_t)sub_10002D8B8,  a2,  (uint64_t (*)(char *, int, unsigned int))sub_1000632A8,  a3,  a4,  a8);
}

uint64_t sub_10002D850( void *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
LABEL_6:
    sub_10006221C("%s(%d): NULL pointer reference", (uint64_t)a2, a3, a4, a5, a6, a7, a8, a3);
    return 39LL;
  }

  if (!*a1)
  {
    if (a2)
    {
      uint64_t result = 0LL;
      *a1 = a2;
      ++*a2;
      return result;
    }

    goto LABEL_6;
  }

  sub_10006221C("%s(%d): non-NULL pointer", (uint64_t)a2, a3, a4, a5, a6, a7, a8, a3);
  return 39LL;
}

uint64_t sub_10002D8B8( void **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || (uint64_t v10 = *a1) == 0LL)
  {
    sub_10006221C("%s(%d): NULL pointer", a2, a3, a4, a5, a6, a7, a8, a2);
    return 39LL;
  }

  *a1 = 0LL;
  int v11 = *(_DWORD *)v10;
  int v12 = *(_DWORD *)v10 - 1;
  *(_DWORD *)uint64_t v10 = v12;
  if (v11 <= 0)
  {
    sub_10006221C("%s(%d): negative refcnt", a2, a3, a4, a5, a6, a7, a8, a2);
    *(_DWORD *)uint64_t v10 = 0;
LABEL_8:
    if (*((void *)v10 + 7)) {
      sub_10002D71C((void **)v10 + 7, a2, a3, a4, a5, a6, a7, a8);
    }
    if (*((void *)v10 + 8)) {
      sub_10002DA28((void **)v10 + 8, a2, a3, a4, a5, a6, a7, a8);
    }
    if (*((void *)v10 + 3)) {
      sub_10005515C((void *)v10 + 3, a2, a3, a4, a5, a6, a7, a8);
    }
    sub_10005CE20(v10, a2, a3, a4, a5, a6, a7, a8);
    return 0LL;
  }

  if (!v12) {
    goto LABEL_8;
  }
  return 0LL;
}

uint64_t sub_10002D9A0( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_10006221C("%s(%d): NULL pointer reference", a2, a3, a4, a5, a6, a7, a8, a2);
    return 39LL;
  }

  if (*a1)
  {
    sub_10006221C("%s(%d): non-NULL pointer", a2, a3, a4, a5, a6, a7, a8, a2);
    return 39LL;
  }

  uint64_t v10 = sub_10005CDE4(0x50uLL);
  uint64_t result = 1LL;
  if (v10)
  {
    *uint64_t v10 = 1;
    v10[18] = -1;
    *((_WORD *)v10 + 10) = 511;
    *a1 = v10;
    return 0LL;
  }

  return result;
}

uint64_t sub_10002DA28( void **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || (uint64_t v10 = *a1) == 0LL)
  {
    sub_10006221C("%s(%d): NULL pointer", a2, a3, a4, a5, a6, a7, a8, a2);
    return 39LL;
  }

  *a1 = 0LL;
  int v11 = *(_DWORD *)v10;
  int v12 = *(_DWORD *)v10 - 1;
  *(_DWORD *)uint64_t v10 = v12;
  if (v11 <= 0)
  {
    sub_10006221C("%s(%d): negative refcnt", a2, a3, a4, a5, a6, a7, a8, a2);
    *(_DWORD *)uint64_t v10 = 0;
LABEL_8:
    sub_100063840(*((unsigned int **)v10 + 4), (unsigned int (*)(uint64_t, uint64_t, uint64_t))sub_10002E1BC);
    sub_100063044((void **)v10 + 4, a2, a3, v14, v15, v16, v17, v18);
    sub_10003EF60(*((void *)v10 + 6), (uint64_t (*)(void, uint64_t))sub_10002E1F0, 0LL);
    sub_10003EB2C((uint64_t)v10 + 48, v19, v20, v21, v22, v23, v24, v25);
    sub_10003EF60(*((void *)v10 + 8), (uint64_t (*)(void, uint64_t))sub_10002E1F0, 0LL);
    sub_10003EB2C((uint64_t)v10 + 64, v26, v27, v28, v29, v30, v31, v32);
    sub_10005CE20(v10, a2, a3, v33, v34, v35, v36, v37);
    return 0LL;
  }

  if (!v12) {
    goto LABEL_8;
  }
  return 0LL;
}

uint64_t sub_10002DB34(void *a1, int a2, const void *a3, unsigned int a4, uint64_t a5, uint64_t a6)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = 0LL;
  *((_DWORD *)a1 + 4) = a4 + 4;
  uint64_t v10 = (_DWORD *)(*a1 + 4LL);
  a1[1] = v10;
  *uint64_t v10 = a2;
  memcpy((void *)(a1[1] + 4LL), a3, a4);
  return 0LL;
}

uint64_t sub_10002DBB4( void *a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_10006221C("%s(%d): NULL pointer reference", a2, (uint64_t)a3, a4, a5, a6, a7, a8, a5);
    return 39LL;
  }

  if (*a1)
  {
    sub_10006221C("%s(%d): non-NULL pointer", a2, (uint64_t)a3, a4, a5, a6, a7, a8, a5);
    return 39LL;
  }

  unsigned int v12 = a4;
  int v14 = a2;
  uint64_t v15 = sub_10005CDE4(0x40uLL);
  if (!v15) {
    return 1LL;
  }
  uint64_t v16 = v15;
  uint64_t result = sub_10002DB34((void *)v15 + 1, v14, a3, v12, a5, a6);
  if ((_DWORD)result)
  {
    sub_10005CE20(v16, a5, a6, v17, v18, v19, v20, v21);
    return 1LL;
  }

  *uint64_t v16 = 1;
  *a1 = v16;
  return result;
}

uint64_t sub_10002DC94( uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v12 = *(_DWORD *)(a1 + 36);
  int v13 = *(_DWORD *)(a1 + 40);
  if (v13 > v12)
  {
    int v14 = *(void **)(a1 + 56);
LABEL_5:
    sub_10002D850(&v14[v12], a2, a3, a4, a5, a6, a7, a8);
    uint64_t result = 0LL;
    ++*(_DWORD *)(a1 + 36);
    return result;
  }

  int v15 = v13 + 4;
  uint64_t v16 = sub_10005CDE4((8 * (v13 + 4)));
  if (v16)
  {
    int v14 = v16;
    memcpy(v16, *(const void **)(a1 + 56), 8LL * *(int *)(a1 + 36));
    *(void *)(a1 + 56) = v14;
    *(_DWORD *)(a1 + 40) = v15;
    int v12 = *(_DWORD *)(a1 + 36);
    goto LABEL_5;
  }

  return 1LL;
}

uint64_t sub_10002DD44( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(unsigned int *)(a1 + 36);
  uint64_t v13 = 0LL;
  for (uint64_t i = *(void ***)(a1 + 56); *i != (void *)a2; ++i)
  {
    if (v10 == ++v13) {
      return sub_10006221C("%s(%d): IAADDR/PREFIX not in IA", a2, a3, a4, a5, a6, a7, a8, a3);
    }
  }

  sub_10002D8B8(i, a3, a4, a4, a5, a6, a7, a8);
  int v21 = *(_DWORD *)(a1 + 36);
  if ((int)v13 + 1 < v21)
  {
    uint64_t v22 = (v21 - 1);
    do
    {
      *(void *)(*(void *)(a1 + 56) + 8 * v13) = *(void *)(*(void *)(a1 + 56) + 8 * v13 + 8);
      ++v13;
    }

    while (v22 != v13);
  }

  uint64_t result = sub_10002D71C((void **)(a2 + 56), a3, a4, v16, v17, v18, v19, v20);
  --*(_DWORD *)(a1 + 36);
  return result;
}

uint64_t sub_10002DE24( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = result;
  if (*(int *)(result + 36) >= 1)
  {
    uint64_t v11 = 0LL;
    uint64_t v12 = 0LL;
    do
    {
      sub_10002D71C((void **)(*(void *)(*(void *)(v8 + 56) + v11) + 56LL), a2, a3, a4, a5, a6, a7, a8);
      uint64_t result = sub_10002D8B8((void **)(*(void *)(v8 + 56) + v11), a2, a3, v13, v14, v15, v16, v17);
      ++v12;
      v11 += 8LL;
    }

    while (v12 < *(int *)(v8 + 36));
  }

  *(_DWORD *)(v8 + 36) = 0;
  return result;
}

BOOL sub_10002DEB0(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return a2 == 0;
  }
  size_t v4 = *(unsigned int *)(a1 + 24);
  if ((_DWORD)v4 != *(_DWORD *)(a2 + 24)) {
    return 0LL;
  }
  uint64_t v5 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v5 != *(_DWORD *)(a2 + 36)) {
    return 0LL;
  }
  for (uint64_t i = 0LL; i != v5; ++i)
  {
    uint64_t v7 = *(void *)(*(void *)(a1 + 56) + 8 * i);
    uint64_t v8 = *(unsigned int *)(a1 + 36);
    for (uint64_t j = *(void *)(a2 + 56);
          *(unsigned __int8 *)(v7 + 20) != *(unsigned __int8 *)(*(void *)(*(void *)(a2 + 56) + 8 * i) + 20LL)
       || *(void *)(v7 + 4) != *(void *)(*(void *)j + 4LL)
       || *(void *)(v7 + 12) != *(void *)(*(void *)j + 12LL);
          j += 8LL)
    {
      BOOL result = 0LL;
      if (!--v8) {
        return result;
      }
    }

    BOOL result = 1LL;
  }

  return result;
}

uint64_t sub_10002DFA8( void *a1, uint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_10006221C("%s(%d): NULL pointer reference", a2, (uint64_t)a3, a4, a5, a6, a7, a8, a6);
    return 39LL;
  }

  if (*a1)
  {
    sub_10006221C("%s(%d): non-NULL pointer", a2, (uint64_t)a3, a4, a5, a6, a7, a8, a6);
    return 39LL;
  }

  int v12 = a5;
  int v13 = a4;
  __int16 v15 = a2;
  uint64_t v17 = (char *)sub_10005CDE4(0x58uLL);
  uint64_t result = 1LL;
  if (v17)
  {
    *(_DWORD *)uint64_t v17 = 1;
    *((_WORD *)v17 + 2) = v15;
    *(_OWORD *)(v17 + 8) = *a3;
    *((_DWORD *)v17 + 6) = v13;
    *((_DWORD *)v17 + 7) = v12;
    if (sub_100063100( (uint64_t *)v17 + 4,  (uint64_t)sub_10002D850,  (uint64_t)sub_10002D8B8,  0x26F5u,  (uint64_t (*)(char *, int, unsigned int))sub_1000632A8,  a6,  a7,  v16))
    {
      if (!sub_10003EA9C((uint64_t)sub_10002E10C, (uint64_t)sub_10002E14C, 0, (void *)v17 + 6))
      {
        uint64_t result = sub_10003EA9C((uint64_t)sub_10002E10C, (uint64_t)sub_10002E14C, 0, (void *)v17 + 8);
        if (!(_DWORD)result)
        {
          *a1 = v17;
          return result;
        }

        sub_10003EB2C((uint64_t)(v17 + 48), v28, v29, v30, v31, v32, v33, v34);
      }

      sub_100063044((void **)v17 + 4, a6, a7, v23, v24, v25, v26, v27);
    }

    sub_10005CE20(v17, a6, a7, v18, v19, v20, v21, v22);
    return 1LL;
  }

  return result;
}

BOOL sub_10002E10C(uint64_t a1, uint64_t a2)
{
  time_t v3 = *(void *)(a1 + 32);
  if (v3 == *(void *)(a2 + 32))
  {
    time_t v3 = *(void *)(a1 + 40);
    time_t v4 = *(void *)(a2 + 40);
  }

  else
  {
    time_t v4 = *(void *)(a2 + 32);
  }

  return difftime(v3, v4) < 0.0;
}

uint64_t sub_10002E14C(uint64_t result, int a2)
{
  *(_DWORD *)(result + 72) = a2;
  return result;
}

uint64_t sub_10002E154( void *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
LABEL_6:
    sub_10006221C("%s(%d): NULL pointer reference", (uint64_t)a2, a3, a4, a5, a6, a7, a8, a3);
    return 39LL;
  }

  if (!*a1)
  {
    if (a2)
    {
      uint64_t result = 0LL;
      *a1 = a2;
      ++*a2;
      return result;
    }

    goto LABEL_6;
  }

  sub_10006221C("%s(%d): non-NULL pointer", (uint64_t)a2, a3, a4, a5, a6, a7, a8, a3);
  return 39LL;
}

uint64_t sub_10002E1BC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  sub_10002D8B8(&v4, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c", 547LL);
  return 0LL;
}

uint64_t sub_10002E1F0(uint64_t a1)
{
  uint64_t v2 = a1;
  return sub_10002D8B8(&v2, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c", 559LL);
}

uint64_t sub_10002E220( uint64_t a1, void *a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((byte_1000BD2C8 & 1) == 0)
  {
    qword_1000BD2CC = 0LL;
    *(void *)algn_1000BD2D4 = 0LL;
    qword_1000BD2E0 = 0LL;
    byte_1000BD2E8 = -3;
    *(_DWORD *)algn_1000BD2E9 = -1;
    *(_WORD *)&algn_1000BD2E9[4] = -1;
    byte_1000BD2C8 = 1;
  }

  uint64_t v88 = 0LL;
  uint64_t v89 = 0LL;
  size_t __n = 0LL;
  sub_100034E60( (uint64_t)&v88,  a4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  774LL,  a5,  a6,  a7,  a8);
  uint64_t v17 = (void *)(a1 + 8);
  *a3 = 1;
  while (1)
  {
    int v18 = *(unsigned __int16 *)(a1 + 4);
    if (v18 == 3)
    {
      unint64_t v29 = *(unsigned int *)(a1 + 24);
      sub_10005AF90((uint64_t)v91);
      sub_10005AFB0(v91, (unsigned int *)v89, __n);
      sub_10005BD68((uint64_t)&__dst, (uint64_t)v91);
      if ((int)v29 < 8)
      {
        unint64_t v30 = 0LL;
      }

      else
      {
        unint64_t v30 = v29 >> 3;
        memcpy(&__dst, (const void *)(a1 + 8), v29 >> 3);
      }

      else {
        int v34 = v29 & 7;
      }
      unsigned int v35 = v34 - 1;
      if (v35 <= 6) {
        *((_BYTE *)&__dst + sub_1000622D4("Copyright 2004-2011 Internet Systems Consortium.", v9, v10, v11, v12, v13, v14, v15, v30) = *((_BYTE *)v17 + v30) & (0xFEFCF8F0E0C080uLL >> (8 * v35)) | *((_BYTE *)&__dst + v30) & (0x103070F1F3F7FuLL >> (8 * v35));
      }
      if ((_DWORD)v29 == 64) {
        BYTE8(__dst) &= ~2u;
      }
    }

    else
    {
      if (v18 != 4)
      {
        if (v18 == 25) {
          uint64_t v63 = "create_lease6: prefix pool.";
        }
        else {
          uint64_t v63 = "create_lease6: untyped pool.";
        }
        sub_10006221C(v63, v10, v11, v12, v13, v14, v15, v16, (char)a2);
        return 39LL;
      }

      int v19 = *(_DWORD *)(a1 + 24);
      sub_10005AF90((uint64_t)v91);
      sub_10005AFB0(v91, (unsigned int *)&qword_1000BD2F8, 8uLL);
      sub_10005AFB0(v91, (unsigned int *)v89, __n);
      sub_10005BD68((uint64_t)__src, (uint64_t)v91);
      if (v19 == 64)
      {
        *(void *)&__int128 __dst = *v17;
        *((void *)&__dst + 1) = __src[0];
        BYTE8(__dst) = __src[0] & 0xFD;
      }

      else
      {
        int v31 = v19 + 7;
        if (v19 >= 0) {
          int v31 = v19;
        }
        uint64_t v32 = (v31 >> 3);
        if (v19 < 8)
        {
          uint64_t v33 = 0LL;
        }

        else
        {
          memcpy(&__dst, (const void *)(a1 + 8), (v31 >> 3));
          uint64_t v33 = v32;
        }

        memcpy((char *)&__dst + (int)v32, __src, 16 - (int)v32);
        switch(~(8 * (_DWORD)v32) + v19)
        {
          case 0:
            char v36 = *((_BYTE *)v17 + v33) & 0x80 | *((_BYTE *)&__dst + v33) & 0x7F;
            goto LABEL_34;
          case 1:
            char v36 = *((_BYTE *)v17 + v33) & 0xC0 | *((_BYTE *)&__dst + v33) & 0x3F;
            goto LABEL_34;
          case 2:
            char v36 = *((_BYTE *)v17 + v33) & 0xE0 | *((_BYTE *)&__dst + v33) & 0x1F;
            goto LABEL_34;
          case 3:
            char v36 = *((_BYTE *)v17 + v33) & 0xF0 | *((_BYTE *)&__dst + v33) & 0xF;
            goto LABEL_34;
          case 4:
            char v36 = *((_BYTE *)v17 + v33) & 0xF8 | *((_BYTE *)&__dst + v33) & 7;
            goto LABEL_34;
          case 5:
            char v36 = *((_BYTE *)v17 + v33) & 0xFC | *((_BYTE *)&__dst + v33) & 3;
            goto LABEL_34;
          case 6:
            char v36 = *((_BYTE *)v17 + v33) & 0xFE | *((_BYTE *)&__dst + v33) & 1;
LABEL_34:
            *((_BYTE *)&__dst + v33) = v36;
            break;
          default:
            break;
        }
      }

      qword_1000BD2F8 = __src[1];
      ++dword_1000BD300;
    }

    if (*((void *)&__dst + 1) == qword_1000BD2CC)
    {
      uint64_t v86 = 0LL;
      goto LABEL_43;
    }

    uint64_t v86 = 0LL;
    if (DWORD2(__dst) ^ qword_1000BD2E0 | *(_DWORD *)((char *)&__dst + 11) ^ *(_DWORD *)((char *)&qword_1000BD2E0 + 3)
      || (SHIBYTE(__dst) & 0x80000000) == 0)
    {
      break;
    }

uint64_t sub_10002E7BC( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(_BYTE *)(a2 + 21)) {
    *(_BYTE *)(a2 + 21) = 2;
  }
  sub_10002E154( (void *)(a2 + 64),  (_DWORD *)a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  892LL,  a5,  a6,  a7,  a8);
  uint64_t v51 = 0LL;
  uint64_t v11 = (const char *)(a2 + 4);
  if (sub_100063738( &v51,  *(uint64_t (***)(unsigned __int8 *, int, unsigned int))(a1 + 32),  (const char *)(a2 + 4),  16LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  900LL,  v12,  v13))
  {
    int v18 = *((unsigned __int8 *)v51 + 21);
    if (v18 == 5 || v18 == 2)
    {
      sub_10003ED20(*(void *)(a1 + 48), *((unsigned int *)v51 + 18));
      uint64_t v23 = (_DWORD *)(a1 + 40);
    }

    else
    {
      sub_10003ED20(*(void *)(a1 + 64), *((unsigned int *)v51 + 18));
      uint64_t v23 = (_DWORD *)(a1 + 56);
    }

    --*v23;
    sub_100063620( *(void *)(a1 + 32),  v51 + 4,  16LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  919LL,  v20,  v21,  v22);
    uint64_t v50 = v51;
    sub_10002D8B8( (void **)&v51,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  930LL,  v24,  v25,  v26,  v27,  v28);
    sub_10002D8B8( (void **)&v50,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  931LL,  v29,  v30,  v31,  v32,  v33);
  }

  uint64_t v50 = 0LL;
  sub_10002D850( &v50,  (_DWORD *)a2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  938LL,  v14,  v15,  v16,  v17);
  char v36 = v50;
  int v37 = *((unsigned __int8 *)v50 + 21);
  if (v37 != 5 && v37 != 2)
  {
    *((void *)v50 + 5) = a3;
    uint64_t v40 = sub_10003EB84(*(int **)(a1 + 64), (uint64_t)v36);
    uint64_t v39 = v40;
    if (!(_DWORD)v40)
    {
      ++*(_DWORD *)(a1 + 56);
      return v39;
    }

    goto LABEL_19;
  }

  *((void *)v50 + 4) = a3;
  sub_1000634B8( *(void *)(a1 + 32),  v36 + 4,  16LL,  a2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  943LL,  v34,  v35,  (char)v50);
  uint64_t v39 = sub_10003EB84(*(int **)(a1 + 48), (uint64_t)v50);
  if ((_DWORD)v39)
  {
LABEL_19:
    sub_100063620( *(void *)(a1 + 32),  v11,  16LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  957LL,  v41,  v42,  v43);
    sub_10002D8B8( (void **)&v50,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  958LL,  v44,  v45,  v46,  v47,  v48);
    return v39;
  }

  ++*(_DWORD *)(a1 + 40);
  return v39;
}

uint64_t sub_10002E9A4( uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v14 = 0LL;
  uint64_t result = sub_100063738( &v14,  *(uint64_t (***)(unsigned __int8 *, int, unsigned int))(a1 + 32),  a2,  16LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  979LL,  a7,  a8);
  if ((_DWORD)result)
  {
    sub_10002D8B8( &v14,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  980LL,  v9,  v10,  v11,  v12,  v13);
    return 1LL;
  }

  return result;
}

uint64_t sub_10002E9FC(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int8 *)(a2 + 21);
  if (v3 == 5)
  {
    *(_BYTE *)(a2 + 21) = 2;
    sub_10003EEDC(*(void *)(a1 + 48), *(unsigned int *)(a2 + 72));
    char v4 = inet_ntop(30, (const void *)(a2 + 4), v13, 0x2Eu);
    sub_1000622D4("Reclaiming previously abandoned address %s", v5, v6, v7, v8, v9, v10, v11, v4);
    return 0LL;
  }

  if (v3 == 2)
  {
    sub_10003EF08(*(void *)(a1 + 48), *(unsigned int *)(a2 + 72));
    return 0LL;
  }

  return sub_10002EAD8(a1, a2);
}

uint64_t sub_10002EAD8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a2 + 72);
  uint64_t v7 = sub_10003EB84(*(int **)(a1 + 48), a2);
  if (!(_DWORD)v7)
  {
    sub_1000634B8( *(void *)(a1 + 32),  (const char *)(a2 + 4),  16LL,  a2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  999LL,  v5,  v6,  v9);
    sub_10003ED20(*(void *)(a1 + 64), v4);
    ++*(_DWORD *)(a1 + 40);
    --*(_DWORD *)(a1 + 56);
    *(_BYTE *)(a2 + 21) = 2;
  }

  return v7;
}

uint64_t sub_10002EB64( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_10006221C( "%s(%d): NULL pointer reference",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c");
    return 39LL;
  }

  if (*a1)
  {
    sub_10006221C( "%s(%d): non-NULL pointer",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c");
    return 39LL;
  }

  uint64_t v12 = sub_10003EF34(*(void *)(a2 + 48), 1u);
  if (*(void *)(v12 + 32) >= a3) {
    return 0LL;
  }
  uint64_t v13 = (_DWORD *)v12;
  uint64_t result = sub_10002EC3C(a2, v12, 3);
  if (!(_DWORD)result)
  {
    sub_10002D850( a1,  v13,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1110LL,  v14,  v15,  v16,  v17);
    return 0LL;
  }

  return result;
}

uint64_t sub_10002EC3C(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v6 = *(unsigned int *)(a2 + 72);
  uint64_t v12 = sub_10003EB84(*(int **)(a1 + 64), a2);
  if (!(_DWORD)v12)
  {
    if (*(_WORD *)(a1 + 4) != 25) {
      sub_10000F3C0(0LL, a2);
    }
    if (*(void *)(a2 + 24)) {
      sub_10005515C( (void *)(a2 + 24),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1066LL,  v7,  v8,  v9,  v10,  v11);
    }
    sub_100063620( *(void *)(a1 + 32),  (const char *)(a2 + 4),  16LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1070LL,  v9,  v10,  v11);
    sub_10003ED20(*(void *)(a1 + 48), v6);
    *(_BYTE *)(a2 + 21) = a3;
    --*(_DWORD *)(a1 + 40);
    ++*(_DWORD *)(a1 + 56);
  }

  return v12;
}

uint64_t sub_10002ED00(uint64_t a1, uint64_t a2)
{
  int v4 = *(unsigned __int8 *)(a2 + 21);
  BOOL v5 = v4 == 2 || v4 == 5;
  if (v5 || (uint64_t result = sub_10002EAD8(a1, a2), !(_DWORD)result))
  {
    *(_BYTE *)(a2 + 21) = 5;
    *(void *)(a2 + 32) = 0x7FFFFFFFLL;
    sub_10003EF08(*(void *)(a1 + 48), *(unsigned int *)(a2 + 72));
    return 0LL;
  }

  return result;
}

uint64_t sub_10002ED64(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a2 + 21) == 2) {
    return sub_10002EC3C(a1, a2, 4);
  }
  else {
    return 0LL;
  }
}

uint64_t sub_10002ED80( uint64_t a1, void *a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char __src = 0LL;
  size_t __n = 0LL;
  uint64_t v75 = 0LL;
  sub_100034E60( (uint64_t)&v75,  a4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1252LL,  a5,  a6,  a7,  a8);
  *a3 = 1;
  while (1)
  {
    int v11 = *(_DWORD *)(a1 + 24);
    int v10 = *(_DWORD *)(a1 + 28);
    sub_10005AF90((uint64_t)v78);
    sub_10005AFB0(v78, (unsigned int *)__src, __n);
    sub_10005BD68((uint64_t)&__dst, (uint64_t)v78);
    int v14 = v11 + 7;
    if (v11 >= 0) {
      int v14 = v11;
    }
    int v15 = v14 >> 3;
    if (v11 >= 8) {
      memcpy(&__dst, (const void *)(a1 + 8), (v14 >> 3));
    }
    unsigned int v16 = ~(8 * v15) + v11;
    if (v16 <= 6) {
      *((_BYTE *)&__dst + v15) = *(_BYTE *)(a1 + 8 + v15) & (0xFEFCF8F0E0C080uLL >> (8 * v16)) | *((_BYTE *)&__dst + v15) & (0x103070F1F3F7FuLL >> (8 * v16));
    }
    int v17 = v10 / 8;
    if (v10 <= 119)
    {
      if (v17 <= 14) {
        int v18 = 14;
      }
      else {
        int v18 = v10 / 8;
      }
      bzero((char *)&__dst + v17 + 1, (v18 - v17) + 1LL);
    }

    switch(v10 % 8)
    {
      case 0:
        *((_BYTE *)&__dst + v17) = 0;
        break;
      case 1:
        char v19 = *((_BYTE *)&__dst + v17) & 0x80;
        goto LABEL_22;
      case 2:
        char v19 = *((_BYTE *)&__dst + v17) & 0xC0;
        goto LABEL_22;
      case 3:
        char v19 = *((_BYTE *)&__dst + v17) & 0xE0;
        goto LABEL_22;
      case 4:
        char v19 = *((_BYTE *)&__dst + v17) & 0xF0;
        goto LABEL_22;
      case 5:
        char v19 = *((_BYTE *)&__dst + v17) & 0xF8;
        goto LABEL_22;
      case 6:
        char v19 = *((_BYTE *)&__dst + v17) & 0xFC;
        goto LABEL_22;
      case 7:
        char v19 = *((_BYTE *)&__dst + v17) & 0xFE;
LABEL_22:
        *((_BYTE *)&__dst + v17) = v19;
        break;
      default:
        break;
    }

    uint64_t v73 = 0LL;
    if (!sub_100063738( &v73,  *(uint64_t (***)(unsigned __int8 *, int, unsigned int))(a1 + 32),  (const char *)&__dst,  16LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1275LL,  v12,  v13)) {
      break;
    }
    sub_10002D8B8( &v73,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1278LL,  v20,  v21,  v22,  v23,  v24);
    uint64_t v71 = 0LL;
    uint64_t v70 = 0LL;
    uint64_t v72 = (__n + 16);
    if (!sub_1000345C4( &v70,  (int)__n + 16,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1285LL))
    {
      sub_100034EA8( &v75,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1286LL,  v25,  v26,  v27,  v28,  v29);
      return 1LL;
    }

    uint64_t v71 = v70 + 1;
    memcpy(v70 + 1, __src, __n);
    *(_OWORD *)((char *)v70 + __n + 4) = __dst;
    sub_100034EA8( &v75,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1292LL,  v30,  v31,  v32,  v33,  v34);
    sub_100034E60( (uint64_t)&v75,  (uint64_t)&v70,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1293LL,  v35,  v36,  v37,  v38);
    sub_100034EA8( &v70,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1294LL,  v39,  v40,  v41,  v42,  v43);
    unsigned int v49 = *a3 + 1;
    *a3 = v49;
    if (v49 > 0xA)
    {
      sub_100034EA8( &v75,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1260LL,  v44,  v45,  v46,  v47,  v48);
      return 13LL;
    }
  }

  sub_100034EA8( &v75,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1297LL,  v20,  v21,  v22,  v23,  v24);
  v78[0] = 0LL;
  uint64_t v50 = sub_10002D9A0( v78,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1304LL,  v51,  v52,  v53,  v54,  v55);
  if (!(_DWORD)v50)
  {
    unsigned int v61 = (char *)v78[0];
    *((_BYTE *)v78[0] + 20) = *(_DWORD *)(a1 + 28);
    *(_OWORD *)(v61 + 4) = __dst;
    uint64_t v50 = sub_10002E7BC(a1, (uint64_t)v61, a5, v56, v57, v58, v59, v60);
    if (!(_DWORD)v50) {
      sub_10002D850( a2,  (_DWORD *)v78[0],  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1316LL,  v63,  v64,  v65,  v66);
    }
    sub_10002D8B8( v78,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1318LL,  v62,  v63,  v64,  v65,  v66);
  }

  return v50;
}

uint64_t sub_10002F0F4( uint64_t a1, const char *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 28) != a3) {
    return 0LL;
  }
  int v14 = 0LL;
  uint64_t result = sub_100063738( &v14,  *(uint64_t (***)(unsigned __int8 *, int, unsigned int))(a1 + 32),  a2,  16LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1335LL,  a7,  a8);
  if ((_DWORD)result)
  {
    sub_10002D8B8( &v14,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1336LL,  v9,  v10,  v11,  v12,  v13);
    return 1LL;
  }

  return result;
}

uint64_t sub_10002F164( uint64_t a1, _OWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v17 = 0LL;
  uint64_t v12 = sub_10002D9A0( &v17,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1354LL,  a4,  a5,  a6,  a7,  a8);
  if (!(_DWORD)v12)
  {
    uint64_t v13 = v17;
    int v14 = (const char *)(v17 + 4);
    *(_OWORD *)(v17 + 4) = *a2;
    sub_1000634B8( *(void *)(a1 + 32),  v14,  16LL,  v13,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1358LL,  v10,  v11,  v16);
  }

  return v12;
}

uint64_t sub_10002F1E0(_DWORD *a1)
{
  uint64_t v2 = sub_10005CDE4((8 * dword_10008BE78 + 8));
  if (!v2) {
    return 1LL;
  }
  uint64_t v7 = (uint64_t)v2;
  int v8 = dword_10008BE78;
  if (dword_10008BE78 >= 1)
  {
    memcpy(v2, (const void *)qword_10008BE80, 8LL * dword_10008BE78);
    sub_10005CE20( (void *)qword_10008BE80,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1378LL,  v9,  v10,  v11,  v12,  v13);
    int v8 = dword_10008BE78;
  }

  qword_10008BE80 = v7;
  *(void *)(v7 + 8LL * v8) = 0LL;
  sub_10002E154( (void *)(qword_10008BE80 + 8LL * v8),  a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1383LL,  v3,  v4,  v5,  v6);
  uint64_t result = 0LL;
  ++dword_10008BE78;
  return result;
}

uint64_t **sub_10002F2A0(uint64_t **result)
{
  uint64_t v1 = result;
  if (*((int *)result + 10) < 1)
  {
    uint64_t v3 = 0x7FFFFFFFLL;
  }

  else
  {
    uint64_t result = (uint64_t **)sub_10003EF34((uint64_t)result[6], 1u);
    uint64_t v2 = (uint64_t)result[4];
    if (v2 < 0x7FFFFFFF) {
      uint64_t v3 = v2 + 1;
    }
    else {
      uint64_t v3 = 0x7FFFFFFFLL;
    }
  }

  if (*((int *)v1 + 14) >= 1)
  {
    uint64_t result = (uint64_t **)sub_10003EF34((uint64_t)v1[8], 1u);
    uint64_t v4 = result[4];
    uint64_t v5 = v4 ? (uint64_t)(v4 + 450) : (uint64_t)result[5] + 1;
    if (v5 < v3) {
      uint64_t v3 = v5;
    }
  }

  if (v3 <= 2147483646)
  {
    uint64_t v6 = (uint64_t *)v3;
    int v7 = 0;
    return sub_10003BEE8( &v6,  (uint64_t)sub_10002F364,  (uint64_t *)v1,  (uint64_t (*)(void, void, void, void))sub_10002E154,  (uint64_t)sub_10002DA28);
  }

  return result;
}

uint64_t sub_10002F364( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v44 = 0LL;
  int v9 = sub_10002EB64(&v44, a1, qword_10008CE80, a4, a5, a6, a7, a8);
  uint64_t v10 = v44;
  if (v9) {
    BOOL v11 = 1;
  }
  else {
    BOOL v11 = v44 == 0LL;
  }
  if (!v11)
  {
    do
    {
      if (*(_WORD *)(a1 + 4) != 25)
      {
        sub_10000F3C0(0LL, (uint64_t)v10);
        uint64_t v10 = v44;
      }

      sub_10000D7B4(v10[7]);
      sub_10002D8B8( (void **)&v44,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1487LL,  v12,  v13,  v14,  v15,  v16);
      uint64_t v44 = 0LL;
      int v22 = sub_10002EB64(&v44, a1, qword_10008CE80, v17, v18, v19, v20, v21);
      uint64_t v10 = v44;
      if (v22) {
        BOOL v23 = 1;
      }
      else {
        BOOL v23 = v44 == 0LL;
      }
    }

    while (!v23);
  }

  if (*(int *)(a1 + 56) >= 1)
  {
    do
    {
      uint64_t v24 = sub_10003EF34(*(void *)(a1 + 64), 1u);
      uint64_t v47 = (void *)v24;
      uint64_t v25 = *(void *)(v24 + 32);
      if (v25) {
        uint64_t v26 = v25 + 3600;
      }
      else {
        uint64_t v26 = *(void *)(v24 + 40);
      }
      if (qword_10008CE80 < v26) {
        break;
      }
      sub_10003ED20(*(void *)(a1 + 64), *(unsigned int *)(v24 + 72));
      --*(_DWORD *)(a1 + 56);
      uint64_t v32 = (uint64_t)v47;
      uint64_t v33 = (_DWORD *)v47[7];
      if (v33)
      {
        uint64_t v46 = (unsigned int *)v47[7];
        ++*v33;
        sub_10002DD44( (uint64_t)v33,  v32,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1420LL,  v28,  v29,  v30,  v31);
        uint64_t v45 = 0LL;
        uint64_t v39 = v46;
        uint64_t v40 = (const char *)*((void *)v46 + 2);
        if (*((_WORD *)v46 + 16) == 3 && (int)v46[9] <= 0)
        {
          int v41 = sub_100063738( &v45,  (uint64_t (**)(unsigned __int8 *, int, unsigned int))qword_10008BE60,  *((const char **)v46 + 2),  v46[6],  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1426LL,  v37,  v38);
          uint64_t v39 = v46;
          if (!v41 && v45 == v46)
          {
            sub_100063620( qword_10008BE60,  v40,  v46[6],  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1429LL,  v36,  v37,  v38);
            uint64_t v39 = v46;
          }
        }

        if (*((_WORD *)v39 + 16) == 4 && (int)v39[9] <= 0)
        {
          int v42 = sub_100063738( &v45,  (uint64_t (**)(unsigned __int8 *, int, unsigned int))qword_10008BE70,  v40,  v39[6],  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1434LL,  v37,  v38);
          uint64_t v39 = v46;
          if (!v42 && v45 == v46)
          {
            sub_100063620( qword_10008BE70,  v40,  v46[6],  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1437LL,  v36,  v37,  v38);
            uint64_t v39 = v46;
          }
        }

        if (*((_WORD *)v39 + 16) == 25
          && (int)v39[9] <= 0
          && !sub_100063738( &v45,  (uint64_t (**)(unsigned __int8 *, int, unsigned int))qword_10008BE68,  v40,  v39[6],  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1442LL,  v37,  v38)
          && v45 == v46)
        {
          sub_100063620( qword_10008BE68,  v40,  v45[6],  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1445LL,  v36,  v37,  v38);
        }

        sub_10002D71C( (void **)&v46,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1447LL,  v34,  v35,  v36,  v37,  v38);
      }

      sub_10002D8B8( (void **)&v47,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1449LL,  v27,  v28,  v29,  v30,  v31);
    }

    while (*(int *)(a1 + 56) > 0);
  }

  return sub_10002F2A0(a1);
}

uint64_t **sub_10002F620()
{
  if (dword_10008BE78 >= 1)
  {
    uint64_t v0 = 0LL;
    do
      uint64_t result = sub_10002F2A0(*(uint64_t ***)(qword_10008BE80 + 8 * v0++));
    while (v0 < dword_10008BE78);
  }

  return result;
}

BOOL sub_10002F674( __int128 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = *(_DWORD *)(a2 + 24);
  if (v9 >= 0x81) {
    sub_100061FB4( "ipv6_network_portion: bits %d not between 0 and 128",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  *(_DWORD *)(a2 + 24));
  }
  __int128 v18 = *a1;
  int v10 = 135 - v9;
  if (128 - v9 >= 0) {
    int v10 = 128 - v9;
  }
  signed int v11 = 128 - v9 - (v10 & 0xFFFFFFF8);
  if (v9 > 120)
  {
    uint64_t v15 = (_BYTE *)((unint64_t)&v18 | 0xF);
    if (!v11) {
      return (void)v18 == *(void *)(a2 + 8) && *((void *)&v18 + 1) == *(void *)(a2 + 16);
    }
    goto LABEL_12;
  }

  int v12 = v10 >> 3;
  if (v12 <= 1) {
    size_t v13 = 1LL;
  }
  else {
    size_t v13 = v12;
  }
  uint64_t v14 = (char *)&v18 - (v13 - 1);
  bzero(v14 + 15, v13);
  uint64_t v15 = v14 + 14;
  if (v11) {
LABEL_12:
  }
    *v15 &= byte_100082787[v11];
  return (void)v18 == *(void *)(a2 + 8) && *((void *)&v18 + 1) == *(void *)(a2 + 16);
}

uint64_t sub_10002F750( void *a1, uint64_t a2, __int128 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_10006221C( "%s(%d): NULL pointer reference",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c");
    return 39LL;
  }

  if (*a1)
  {
    sub_10006221C( "%s(%d): non-NULL pointer",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c");
    return 39LL;
  }

  int v10 = dword_10008BE78;
  if (dword_10008BE78 < 1) {
    return 23LL;
  }
  int v12 = a2;
  uint64_t v13 = 0LL;
  uint64_t v14 = qword_10008BE80;
  while (1)
  {
    uint64_t v15 = *(void *)(v14 + 8 * v13);
LABEL_11:
    if (++v13 >= v10) {
      return 23LL;
    }
  }

  BOOL v16 = sub_10002F674(a3, v15, (uint64_t)a3, a4, a5, a6, a7, a8);
  uint64_t v14 = qword_10008BE80;
  if (!v16)
  {
    int v10 = dword_10008BE78;
    goto LABEL_11;
  }

  sub_10002E154( a1,  *(_DWORD **)(qword_10008BE80 + 8 * v13),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1649LL,  a5,  a6,  a7,  a8);
  return 0LL;
}

uint64_t sub_10002F848( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_10002F854(a1, sub_10002E9FC, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_10002F854( uint64_t a1, uint64_t (*a2)(uint64_t, void), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = 0LL;
  uint64_t v11 = 0LL;
  do
  {
    uint64_t v14 = 0LL;
    if (!sub_10002F750( &v14,  *(unsigned __int16 *)(a1 + 32),  (__int128 *)(*(void *)(*(void *)(a1 + 56) + 8 * v10) + 4LL),  a4,  a5,  a6,  a7,  a8))
    {
      unsigned int v12 = a2(v14, *(void *)(*(void *)(a1 + 56) + 8 * v10));
      if (v12) {
        uint64_t v11 = v12;
      }
      else {
        uint64_t v11 = v11;
      }
    }

    ++v10;
  }

  while (v10 < *(int *)(a1 + 36));
  return v11;
}

uint64_t sub_10002F8EC( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_10002F854(a1, sub_10002ED64, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_10002F8F8( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_10002F854(a1, sub_10002ED00, a3, a4, a5, a6, a7, a8);
}

BOOL sub_10002F904()
{
  byte_1000BD2F0 = 0;
  sub_10000DB2C();
  sub_100063840((unsigned int *)qword_10008BE60, (unsigned int (*)(uint64_t, uint64_t, uint64_t))sub_10002F98C);
  BOOL result = 0LL;
  if ((byte_1000BD2F0 & 1) == 0)
  {
    sub_100063840( (unsigned int *)qword_10008BE70,  (unsigned int (*)(uint64_t, uint64_t, uint64_t))sub_10002F98C);
    if ((byte_1000BD2F0 & 1) != 0)
    {
      return 0LL;
    }

    else
    {
      sub_100063840( (unsigned int *)qword_10008BE68,  (unsigned int (*)(uint64_t, uint64_t, uint64_t))sub_10002F98C);
      return (byte_1000BD2F0 & 1) == 0;
    }
  }

  return result;
}

uint64_t sub_10002F98C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return 0LL;
}

uint64_t sub_10002F9C8()
{
  return sub_100063840( (unsigned int *)qword_10008BE20,  (unsigned int (*)(uint64_t, uint64_t, uint64_t))sub_10002F9E0);
}

uint64_t sub_10002F9E0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 136);
  if (!v3) {
    return 0LL;
  }
  uint64_t v43 = 0LL;
  uint64_t v44 = 0LL;
  uint64_t v45 = 0LL;
  if (!sub_100057AA4( &v43,  0LL,  0LL,  0LL,  0LL,  0LL,  &qword_10008C730,  v3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  0x6F0u))
  {
    uint64_t v38 = "mark_hosts_unavailable: error evaluating host address.";
LABEL_10:
    sub_10006221C(v38, v4, v5, v6, v7, v8, v9, v10, v40);
    return 0LL;
  }

  if ((_DWORD)v45 != 16)
  {
    uint64_t v38 = "mark_hosts_unavailable: host address is not 128 bits.";
    goto LABEL_10;
  }

  __int128 v42 = *v44;
  sub_100034EA8( &v43,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1787LL,  v6,  v7,  v8,  v9,  v10);
  uint64_t v41 = 0LL;
  if (!sub_10002F750(&v41, 3LL, &v42, v11, v12, v13, v14, v15))
  {
    sub_10002F164(v41, &v42, v16, v17, v18, v19, v20, v21);
    sub_10002DA28( (void **)&v41,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1797LL,  v22,  v23,  v24,  v25,  v26);
  }

  if (!sub_10002F750(&v41, 4LL, &v42, v17, v18, v19, v20, v21))
  {
    sub_10002F164(v41, &v42, v27, v28, v29, v30, v31, v32);
    sub_10002DA28( (void **)&v41,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1801LL,  v33,  v34,  v35,  v36,  v37);
  }

  return 0LL;
}

uint64_t sub_10002FAFC()
{
  return sub_100063840( (unsigned int *)qword_10008BE20,  (unsigned int (*)(uint64_t, uint64_t, uint64_t))sub_10002FB14);
}

uint64_t sub_10002FB14( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  for (uint64_t i = *(uint64_t **)(a3 + 144); i; uint64_t i = (uint64_t *)*i)
  {
    if (*((_DWORD *)i + 2) == 16)
    {
      __int128 v13 = *(_OWORD *)((char *)i + 12);
      uint64_t v12 = 0LL;
      if (!sub_10002F750(&v12, 25LL, &v13, a4, a5, a6, a7, a8))
      {
        if (*((_DWORD *)i + 7) == v12[7])
        {
          sub_10002F164((uint64_t)v12, &v13, v9, a4, a5, a6, a7, a8);
          uint64_t v10 = 1851LL;
        }

        else
        {
          uint64_t v10 = 1847LL;
        }

        sub_10002DA28( (void **)&v12,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  v10,  a4,  a5,  a6,  a7,  a8);
      }
    }
  }

  return 0LL;
}

void sub_10002FBB0( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  for (uint64_t i = qword_10008C0D0; i; uint64_t i = *(void *)(i + 32))
  {
    if (*(int *)(i + 96) >= 1)
    {
      uint64_t v9 = 0LL;
      uint64_t v10 = 0LL;
      do
      {
        uint64_t v28 = 0LL;
        if (!sub_10002F750(&v28, 3LL, (__int128 *)(*(void *)(i + 88) + v9), a4, a5, a6, a7, a8))
        {
          sub_10002F164(v28, (_OWORD *)(*(void *)(i + 88) + v9), v11, v12, v13, v14, v15, v16);
          sub_10002DA28( (void **)&v28,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1876LL,  v17,  v18,  v19,  v20,  v21);
        }

        if (!sub_10002F750(&v28, 4LL, (__int128 *)(*(void *)(i + 88) + v9), v12, v13, v14, v15, v16))
        {
          sub_10002F164(v28, (_OWORD *)(*(void *)(i + 88) + v9), v22, a4, a5, a6, a7, a8);
          sub_10002DA28( (void **)&v28,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/mdb6.c",  1882LL,  v23,  v24,  v25,  v26,  v27);
        }

        ++v10;
        v9 += 16LL;
      }

      while (v10 < *(int *)(i + 96));
    }
  }

uint64_t sub_10002FC94()
{
  unsigned int v0 = sub_100067CD0( &qword_10008BEA8,  (uint64_t)"lease",  (uint64_t)sub_1000300C8,  (uint64_t)sub_10003051C,  (uint64_t)sub_1000307F4,  (uint64_t)sub_1000309B4,  (uint64_t)sub_100030A38,  (uint64_t)sub_100030E50,  (uint64_t)sub_100031384,  (uint64_t)sub_10003138C,  (uint64_t)sub_1000337EC,  (uint64_t)sub_100033850,  0LL,  288LL,  0LL,  1);
  if (v0)
  {
    char v1 = sub_100067900(v0);
    sub_100061FB4("Can't register lease object type: %s", v2, v3, v4, v5, v6, v7, v8, v1);
  }

  unsigned int v9 = sub_100067CD0( &qword_10008BE88,  (uint64_t)"class",  (uint64_t)sub_100031394,  (uint64_t)sub_1000313B4,  (uint64_t)sub_100031468,  (uint64_t)sub_100031490,  (uint64_t)sub_1000314B0,  (uint64_t)sub_1000314F8,  (uint64_t)sub_100031504,  (uint64_t)sub_1000315AC,  0LL,  0LL,  0LL,  160LL,  0LL,  2);
  if (v9)
  {
    char v10 = sub_100067900(v9);
    sub_100061FB4("Can't register class object type: %s", v11, v12, v13, v14, v15, v16, v17, v10);
  }

  unsigned int v18 = sub_100067CD0( &qword_10008BEB8,  (uint64_t)"subclass",  (uint64_t)sub_1000315E4,  (uint64_t)sub_100031604,  (uint64_t)sub_100031468,  (uint64_t)sub_100031658,  (uint64_t)sub_100031678,  (uint64_t)sub_1000316C8,  (uint64_t)sub_1000316D4,  (uint64_t)sub_10003177C,  0LL,  0LL,  0LL,  160LL,  0LL,  2);
  if (v18)
  {
    char v19 = sub_100067900(v18);
    sub_100061FB4("Can't register subclass object type: %s", v20, v21, v22, v23, v24, v25, v26, v19);
  }

  unsigned int v27 = sub_100067CD0( &qword_10008BEB0,  (uint64_t)"pool",  (uint64_t)sub_10003179C,  (uint64_t)sub_100031808,  (uint64_t)sub_100031854,  (uint64_t)sub_100031870,  (uint64_t)sub_1000318BC,  (uint64_t)sub_100031904,  (uint64_t)sub_100031918,  (uint64_t)sub_100031920,  0LL,  0LL,  0LL,  168LL,  0LL,  2);
  if (v27)
  {
    char v28 = sub_100067900(v27);
    sub_100061FB4("Can't register pool object type: %s", v29, v30, v31, v32, v33, v34, v35, v28);
  }

  unsigned int v36 = sub_100067CD0( &qword_10008BE10,  (uint64_t)"host",  (uint64_t)sub_100031928,  (uint64_t)sub_100031E50,  (uint64_t)sub_10003208C,  (uint64_t)sub_1000320A8,  (uint64_t)sub_1000321F8,  (uint64_t)sub_1000323D8,  (uint64_t)sub_100032A90,  (uint64_t)sub_100032B38,  0LL,  0LL,  0LL,  200LL,  0LL,  2);
  if (v36)
  {
    char v37 = sub_100067900(v36);
    sub_100061FB4("Can't register host object type: %s", v38, v39, v40, v41, v42, v43, v44, v37);
  }

  unsigned int v45 = sub_100067CD0( &qword_10008BEA0,  (uint64_t)"failover-state",  (uint64_t)sub_100027174,  (uint64_t)sub_1000273A0,  (uint64_t)sub_100027898,  (uint64_t)sub_100023B60,  (uint64_t)sub_100027A08,  (uint64_t)sub_100027E78,  (uint64_t)sub_10002804C,  (uint64_t)sub_100028054,  0LL,  0LL,  0LL,  352LL,  0LL,  2);
  if (v45)
  {
    char v46 = sub_100067900(v45);
    sub_100061FB4("Can't register failover state object type: %s", v47, v48, v49, v50, v51, v52, v53, v46);
  }

  unsigned int v54 = sub_100067CD0( &qword_10008BE90,  (uint64_t)"failover-link",  (uint64_t)sub_100023230,  (uint64_t)sub_1000232F8,  (uint64_t)sub_100023428,  (uint64_t)sub_10002220C,  (uint64_t)sub_1000234BC,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  88LL,  0LL,  2);
  if (v54)
  {
    char v55 = sub_100067900(v54);
    sub_100061FB4("Can't register failover link object type: %s", v56, v57, v58, v59, v60, v61, v62, v55);
  }

  uint64_t result = sub_100067CD0( &qword_10008BE98,  (uint64_t)"failover-listener",  (uint64_t)sub_1000238E4,  (uint64_t)sub_100023924,  (uint64_t)sub_100023964,  (uint64_t)sub_1000235D0,  (uint64_t)sub_1000239A4,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  72LL,  0LL,  2);
  if ((_DWORD)result)
  {
    char v64 = sub_100067900(result);
    sub_100061FB4("Can't register failover listener object type: %s", v65, v66, v67, v68, v69, v70, v71, v64);
  }

  return result;
}

uint64_t sub_1000300C8(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  if (*(void *)a1 != qword_10008BEA8) {
    return 39LL;
  }
  if (!sub_100068648(a3, "state"))
  {
    uint64_t result = sub_100068C24(&v94, (_DWORD *)a4);
    if ((_DWORD)result) {
      return result;
    }
    *(_BYTE *)(a1 + 223) = v94;
    int v24 = sub_10002B1D0(a1, 0LL, 1uLL, 1LL, 1LL, v21, v22, v23);
    uint64_t v32 = (__int128 *)(a1 + 56);
    if (v24)
    {
      __int128 v95 = *v32;
      int v96 = *(_DWORD *)(a1 + 72);
      char v92 = sub_100040144((int *)&v95, v25, v26, v27, v28, v29, v30, v31);
      sub_1000622D4("lease %s state changed from %s to %s", v33, v34, v35, v36, v37, v38, v39, v92);
      return 0LL;
    }

    __int128 v95 = *v32;
    int v96 = *(_DWORD *)(a1 + 72);
    char v93 = sub_100040144((int *)&v95, v25, v26, v27, v28, v29, v30, v31);
    sub_1000622D4("lease %s state change from %s to %s failed.", v40, v41, v42, v43, v44, v45, v46, v93);
    return 26LL;
  }

  if (!sub_100068648(a3, "dhcp-client-identifier")
    || !sub_100068648(a3, "hostname")
    || !sub_100068648(a3, "client-hostname")
    || !sub_100068648(a3, "host"))
  {
    return 42LL;
  }

  if (!sub_100068648(a3, "ends"))
  {
    uint64_t result = sub_100068C24(&v94, (_DWORD *)a4);
    if ((_DWORD)result) {
      return result;
    }
    *(void *)(a1 + 88) = v94;
    int v50 = sub_10002B1D0(a1, 0LL, 1uLL, 1LL, 1LL, v47, v48, v49);
    uint64_t v58 = (__int128 *)(a1 + 56);
    if (v50)
    {
      __int128 v95 = *v58;
      int v96 = *(_DWORD *)(a1 + 72);
      char v59 = sub_100040144((int *)&v95, v51, v52, v53, v54, v55, v56, v57);
      sub_1000622D4("lease %s end changed from %lu to %lu", v60, v61, v62, v63, v64, v65, v66, v59);
      return 0LL;
    }

    __int128 v95 = *v58;
    int v96 = *(_DWORD *)(a1 + 72);
    char v84 = sub_100040144((int *)&v95, v51, v52, v53, v54, v55, v56, v57);
    sub_1000622D4("lease %s end change from %lu to %lu failed", v85, v86, v87, v88, v89, v90, v91, v84);
    return 26LL;
  }

  if (!sub_100068648(a3, "flags"))
  {
    if (*(_DWORD *)(a4 + 4) == 2)
    {
      int v67 = *(unsigned __int8 *)(a1 + 221);
      int v68 = *(_BYTE *)(a4 + 12) & 0x4E | v67 & 0xB1;
      *(_BYTE *)(a1 + 221) = *(_BYTE *)(a4 + 12) & 0x4E | v67 & 0xB1;
      __int128 v95 = *(_OWORD *)(a1 + 56);
      int v96 = *(_DWORD *)(a1 + 72);
      char v76 = sub_100040144((int *)&v95, v69, v70, v71, v72, v73, v74, v75);
      sub_10006221C("Failed to update flags for lease %s.", v77, v78, v79, v80, v81, v82, v83, v76);
      return 26LL;
    }

    return 39LL;
  }

  if (!sub_100068648(a3, "billing-class")
    || !sub_100068648(a3, "hardware-address")
    || !sub_100068648(a3, "hardware-type"))
  {
    return 42LL;
  }

  uint64_t v17 = (uint64_t *)(a1 + 112);
  uint64_t v16 = *(void *)(a1 + 112);
  uint64_t v18 = *(void *)(a1 + 24);
  if (!v18
    || (char v19 = *(uint64_t (**)(void))(*(void *)v18 + 16LL)) == 0LL
    || (uint64_t result = v19(), (_DWORD)result) && (_DWORD)result != 42)
  {
    uint64_t v20 = *v17;
    if (!*v17)
    {
      if (!sub_100034DAC( (void *)(a1 + 112),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  317LL,  v11,  v12,  v13,  v14,  v15)) {
        return 1LL;
      }
      uint64_t v20 = *v17;
    }

    uint64_t result = sub_100032B70(v20, 1, a3, (_DWORD *)a4);
    if (!(_DWORD)result)
    {
LABEL_53:
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_10003051C(uint64_t a1, int a2, _DWORD *a3, int ***a4)
{
  if (*(void *)a1 != qword_10008BEA8) {
    return 39LL;
  }
  if (!sub_100068648((uint64_t)a3, "state"))
  {
    uint64_t v9 = (const char *)*(unsigned __int8 *)(a1 + 222);
    uint64_t v10 = a4;
    uint64_t v11 = a3;
    uint64_t v12 = 343LL;
    return sub_100068920(v10, v11, v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", v12);
  }

  if (!sub_100068648((uint64_t)a3, "ip-address"))
  {
    uint64_t v13 = (const void *)(a1 + 60);
    uint64_t v14 = (const char *)*(unsigned int *)(a1 + 56);
    uint64_t v15 = a4;
    uint64_t v16 = a3;
    uint64_t v17 = 347LL;
    return sub_10006883C( v15,  v16,  v13,  v14,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  v17);
  }

  if (!sub_100068648((uint64_t)a3, "dhcp-client-identifier"))
  {
    uint64_t v13 = *(const void **)(a1 + 184);
    uint64_t v14 = (const char *)*(unsigned __int16 *)(a1 + 192);
    uint64_t v15 = a4;
    uint64_t v16 = a3;
    uint64_t v17 = 351LL;
    return sub_10006883C( v15,  v16,  v13,  v14,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  v17);
  }

  if (!sub_100068648((uint64_t)a3, "client-hostname"))
  {
    uint64_t v18 = *(const char **)(a1 + 104);
    if (v18) {
      return sub_100068B64(a4, a3, v18, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 355LL);
    }
    return 23LL;
  }

  if (sub_100068648((uint64_t)a3, "host"))
  {
    if (sub_100068648((uint64_t)a3, "subnet"))
    {
      if (sub_100068648((uint64_t)a3, "pool"))
      {
        if (sub_100068648((uint64_t)a3, "billing-class"))
        {
          if (sub_100068648((uint64_t)a3, "hardware-address"))
          {
            if (sub_100068648((uint64_t)a3, "hardware-type"))
            {
              uint64_t v8 = *(void *)(a1 + 112);
              if (v8)
              {
                uint64_t result = sub_100032E10(a4, v8, a3);
                if ((_DWORD)result != 23) {
                  return result;
                }
              }

              goto LABEL_27;
            }

            if (*(_BYTE *)(a1 + 203))
            {
              uint64_t v9 = (const char *)*(unsigned __int8 *)(a1 + 204);
              uint64_t v10 = a4;
              uint64_t v11 = a3;
              uint64_t v12 = 388LL;
              return sub_100068920( v10,  v11,  v9,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  v12);
            }

            return 23LL;
          }

          if (!*(_BYTE *)(a1 + 203)) {
            return 23LL;
          }
          uint64_t v13 = (const void *)(a1 + 205);
          uint64_t v14 = (const char *)(*(unsigned __int8 *)(a1 + 203) - 1);
          uint64_t v15 = a4;
          uint64_t v16 = a3;
          uint64_t v17 = 382LL;
          return sub_10006883C( v15,  v16,  v13,  v14,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  v17);
        }

        uint64_t v19 = *(void *)(a1 + 144);
        if (!v19) {
          return 23LL;
        }
        uint64_t v20 = a4;
        uint64_t v21 = a3;
        uint64_t v22 = 375LL;
      }

      else
      {
        uint64_t v19 = *(void *)(a1 + 136);
        uint64_t v20 = a4;
        uint64_t v21 = a3;
        uint64_t v22 = 369LL;
      }
    }

    else
    {
      uint64_t v19 = *(void *)(a1 + 128);
      uint64_t v20 = a4;
      uint64_t v21 = a3;
      uint64_t v22 = 365LL;
    }

    return sub_100068A94(v20, v21, v19, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", v22);
  }

  uint64_t v19 = *(void *)(a1 + 120);
  if (v19)
  {
    uint64_t v20 = a4;
    uint64_t v21 = a3;
    uint64_t v22 = 361LL;
    return sub_100068A94(v20, v21, v19, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", v22);
  }

uint64_t sub_1000307F4( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)a1 != qword_10008BEA8) {
    return 39LL;
  }
  if (*(void *)(a1 + 184)) {
    sub_10002B928(a1, a2, a3, a4, a5, a6, a7, a8);
  }
  sub_10002BA70(a1, a2, a3, a4, a5, a6, a7, a8);
  if (*(void *)(a1 + 176)) {
    sub_10003DC78((void **)(a1 + 176), a2, a3, v12, v13, v14, v15, v16);
  }
  if (*(void *)(a1 + 160)) {
    sub_10003DC78((void **)(a1 + 160), a2, a3, v12, v13, v14, v15, v16);
  }
  if (*(void *)(a1 + 168)) {
    sub_10003DC78((void **)(a1 + 168), a2, a3, v12, v13, v14, v15, v16);
  }
  if (*(void *)(a1 + 112)) {
    sub_10005515C((void *)(a1 + 112), a2, a3, v12, v13, v14, v15, v16);
  }
  if (*(void *)(a1 + 152)) {
    sub_100033F88((void *)(a1 + 152), a2, a3, v12, v13, v14, v15, v16);
  }
  uint64_t v17 = *(void **)(a1 + 184);
  if (v17 && v17 != (void *)(a1 + 196))
  {
    sub_10005CE20( v17,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  434LL,  v12,  v13,  v14,  v15,  v16);
    *(void *)(a1 + 184) = a1 + 196;
    *(_WORD *)(a1 + 192) = 0;
  }

  uint64_t v18 = *(void **)(a1 + 104);
  if (v18)
  {
    sub_10005CE20( v18,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  440LL,  v12,  v13,  v14,  v15,  v16);
    *(void *)(a1 + 104) = 0LL;
  }

  if (*(void *)(a1 + 120)) {
    sub_100033924((_DWORD **)(a1 + 120), a2, a3);
  }
  if (*(void *)(a1 + 128)) {
    sub_1000235C8(a1 + 128, a2, a3);
  }
  if (*(void *)(a1 + 136)) {
    sub_100033900((_DWORD **)(a1 + 136), a2, a3);
  }
  uint64_t v19 = *(void *)(a1 + 232);
  if (v19)
  {
    sub_1000339CC(v19, a2, a3, v12, v13, v14, v15, v16);
    *(void *)(a1 + 232) = 0LL;
    sub_10003C09C((uint64_t)sub_1000183F8, a1);
    --dword_10008BDCC;
  }

  uint64_t v21 = *(void *)(a1 + 144);
  uint64_t v20 = a1 + 144;
  if (v21) {
    sub_1000338C0(v20, a2, a3);
  }
  return 0LL;
}

uint64_t sub_1000309B4(void *a1, char *__s1)
{
  if (*a1 != qword_10008BEA8) {
    return 39LL;
  }
  uint64_t result = strcmp(__s1, "updated");
  if ((_DWORD)result)
  {
    uint64_t v4 = a1[3];
    if (!v4) {
      return 23LL;
    }
    uint64_t v5 = *(uint64_t (**)(void))(*(void *)v4 + 40LL);
    if (!v5) {
      return 23LL;
    }
    uint64_t result = v5();
    if ((_DWORD)result) {
      return 23LL;
    }
  }

  return result;
}

uint64_t sub_100030A38(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)a3 != qword_10008BEA8) {
    return 39LL;
  }
  uint64_t result = sub_10005F114(a1, "state");
  if (!(_DWORD)result)
  {
    uint64_t result = sub_10005EF64(a1, 4u);
    if (!(_DWORD)result)
    {
      uint64_t result = sub_10005EF64(a1, *(unsigned __int8 *)(a3 + 222));
      if (!(_DWORD)result)
      {
        uint64_t result = sub_10005F114(a1, "ip-address");
        if (!(_DWORD)result)
        {
          uint64_t result = sub_10005EF64(a1, *(_DWORD *)(a3 + 56));
          if (!(_DWORD)result)
          {
            uint64_t result = sub_10005E7A4(a1, a3 + 60, *(_DWORD *)(a3 + 56));
            if (!(_DWORD)result)
            {
              if (!*(_WORD *)(a3 + 192)
                || (uint64_t result = sub_10005F114(a1, "dhcp-client-identifier"), !(_DWORD)result)
                && (uint64_t result = sub_10005EF64(a1, *(unsigned __int16 *)(a3 + 192)), !(_DWORD)result)
                && (!*(_WORD *)(a3 + 192)
                 || (uint64_t result = sub_10005E7A4(a1, *(void *)(a3 + 184), *(unsigned __int16 *)(a3 + 192)), !(_DWORD)result)))
              {
                if (!*(void *)(a3 + 104)
                  || (uint64_t result = sub_10005F114(a1, "client-hostname"), !(_DWORD)result)
                  && (uint64_t result = sub_10005F180(a1, *(char **)(a3 + 104)), !(_DWORD)result))
                {
                  if (!*(void *)(a3 + 120)
                    || (uint64_t result = sub_10005F114(a1, "host"), !(_DWORD)result)
                    && (uint64_t result = sub_10005F200(a1, *(void *)(a3 + 120)), !(_DWORD)result))
                  {
                    uint64_t result = sub_10005F114(a1, "subnet");
                    if (!(_DWORD)result)
                    {
                      uint64_t result = sub_10005F200(a1, *(void *)(a3 + 128));
                      if (!(_DWORD)result)
                      {
                        uint64_t result = sub_10005F114(a1, "pool");
                        if (!(_DWORD)result)
                        {
                          uint64_t result = sub_10005F200(a1, *(void *)(a3 + 136));
                          if (!(_DWORD)result)
                          {
                            if (!*(void *)(a3 + 144)
                              || (uint64_t result = sub_10005F114(a1, "billing-class"), !(_DWORD)result)
                              && (uint64_t result = sub_10005F200(a1, *(void *)(a3 + 144)), !(_DWORD)result))
                            {
                              if (!*(_BYTE *)(a3 + 203)
                                || (uint64_t result = sub_10005F114(a1, "hardware-address"), !(_DWORD)result)
                                && (uint64_t result = sub_10005EF64(a1, *(unsigned __int8 *)(a3 + 203) - 1),
                                    !(_DWORD)result)
                                && (uint64_t result = sub_10005E7A4( a1,  a3 + 205,  *(unsigned __int8 *)(a3 + 203) - 1),  !(_DWORD)result)
                                && (uint64_t result = sub_10005F114(a1, "hardware-type"), !(_DWORD)result)
                                && (uint64_t result = sub_10005EF64(a1, 4u), !(_DWORD)result)
                                && (uint64_t result = sub_10005EF64(a1, *(unsigned __int8 *)(a3 + 204)), !(_DWORD)result))
                              {
                                unsigned int v7 = *(_DWORD *)(a3 + 88);
                                uint64_t result = sub_10005F114(a1, "ends");
                                if (!(_DWORD)result)
                                {
                                  uint64_t result = sub_10005EF64(a1, 4u);
                                  if (!(_DWORD)result)
                                  {
                                    uint64_t result = sub_10005EF64(a1, v7);
                                    if (!(_DWORD)result)
                                    {
                                      unsigned int v8 = *(_DWORD *)(a3 + 80);
                                      uint64_t result = sub_10005F114(a1, "starts");
                                      if (!(_DWORD)result)
                                      {
                                        uint64_t result = sub_10005EF64(a1, 4u);
                                        if (!(_DWORD)result)
                                        {
                                          uint64_t result = sub_10005EF64(a1, v8);
                                          if (!(_DWORD)result)
                                          {
                                            unsigned int v9 = *(_DWORD *)(a3 + 240);
                                            uint64_t result = sub_10005F114(a1, "tstp");
                                            if (!(_DWORD)result)
                                            {
                                              uint64_t result = sub_10005EF64(a1, 4u);
                                              if (!(_DWORD)result)
                                              {
                                                uint64_t result = sub_10005EF64(a1, v9);
                                                if (!(_DWORD)result)
                                                {
                                                  unsigned int v10 = *(_DWORD *)(a3 + 248);
                                                  uint64_t result = sub_10005F114(a1, "tsfp");
                                                  if (!(_DWORD)result)
                                                  {
                                                    uint64_t result = sub_10005EF64(a1, 4u);
                                                    if (!(_DWORD)result)
                                                    {
                                                      uint64_t result = sub_10005EF64(a1, v10);
                                                      if (!(_DWORD)result)
                                                      {
                                                        unsigned int v11 = *(_DWORD *)(a3 + 256);
                                                        uint64_t result = sub_10005F114(a1, "atsfp");
                                                        if (!(_DWORD)result)
                                                        {
                                                          uint64_t result = sub_10005EF64(a1, 4u);
                                                          if (!(_DWORD)result)
                                                          {
                                                            uint64_t result = sub_10005EF64(a1, v11);
                                                            if (!(_DWORD)result)
                                                            {
                                                              unsigned int v12 = *(_DWORD *)(a3 + 264);
                                                              uint64_t result = sub_10005F114(a1, "cltt");
                                                              if (!(_DWORD)result)
                                                              {
                                                                uint64_t result = sub_10005EF64(a1, 4u);
                                                                if (!(_DWORD)result)
                                                                {
                                                                  uint64_t result = sub_10005EF64(a1, v12);
                                                                  if (!(_DWORD)result)
                                                                  {
                                                                    uint64_t result = sub_10005F114(a1, "flags");
                                                                    if (!(_DWORD)result)
                                                                    {
                                                                      uint64_t result = sub_10005EF64(a1, 1u);
                                                                      if (!(_DWORD)result)
                                                                      {
                                                                        char v16 = *(_BYTE *)(a3 + 221) & 0x4E;
                                                                        uint64_t result = sub_10005E7A4(a1, (uint64_t)&v16, 1u);
                                                                        if (!(_DWORD)result)
                                                                        {
                                                                          uint64_t v13 = *(void *)(a3 + 112);
                                                                          if (!v13
                                                                            || (uint64_t result = sub_100033020(a1, v13),
                                                                                !(_DWORD)result))
                                                                          {
                                                                            uint64_t v14 = *(void *)(a3 + 24);
                                                                            if (v14)
                                                                            {
                                                                              uint64_t v15 = *(void (**)(uint64_t, uint64_t))(*(void *)v14 + 48LL);
                                                                              if (v15) {
                                                                                v15(a1, a2);
                                                                              }
                                                                            }

                                                                            return 0LL;
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  return result;
}

uint64_t sub_100030E50(void *a1, int a2, uint64_t a3)
{
  uint64_t v32 = 0LL;
  if (!a3) {
    return 46LL;
  }
  if (!sub_1000683F8(a3, a2, "handle"))
  {
    uint64_t v6 = sub_100062F48(a1, v32[2]);
    sub_10005D71C(&v32, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 750LL);
    if ((_DWORD)v6) {
      return v6;
    }
    if (*(void *)*a1 != qword_10008BEA8)
    {
      sub_10005CFEC((_DWORD **)a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 756LL);
      return 39LL;
    }
  }

  if (!sub_1000683F8(a3, a2, "ip-address"))
  {
    uint64_t v31 = 0LL;
    sub_100029804( &v31,  qword_10008BE38,  v32[2] + 3,  v32[2][2],  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  767LL);
    sub_10005D71C(&v32, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 769LL);
    unsigned int v7 = (_DWORD *)*a1;
    if (*a1 && v7 != v31)
    {
      sub_10005CFEC((_DWORD **)a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 774LL);
      uint64_t v8 = 775LL;
LABEL_29:
      sub_10003389C(&v31, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", v8);
      return 44LL;
    }

    if (!v31)
    {
      if (!v7) {
        return 23LL;
      }
      uint64_t v19 = (_DWORD **)a1;
      uint64_t v20 = 779LL;
LABEL_56:
      sub_10005CFEC(v19, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", v20);
      return 23LL;
    }

    if (!v7)
    {
      sub_10005CFB8(a1, (uint64_t)v31);
      sub_10003389C(&v31, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 786LL);
    }
  }

  uint64_t v31 = 0LL;
  sub_100029804( &v31,  qword_10008BE40,  v32[2] + 3,  v32[2][2],  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  796LL);
  sub_10005D71C(&v32, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 797LL);
  unsigned int v9 = (_DWORD *)*a1;
  if (*a1 && v9 != v31)
  {
    sub_10005CFEC((_DWORD **)a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 800LL);
    uint64_t v8 = 801LL;
    goto LABEL_29;
  }

  if (!v31)
  {
    if (!v9) {
      return 23LL;
    }
    uint64_t v19 = (_DWORD **)a1;
    uint64_t v20 = 805LL;
    goto LABEL_56;
  }

  if (*((void *)v31 + 5))
  {
    if (v9) {
      sub_10005CFEC((_DWORD **)a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 809LL);
    }
    return 43LL;
  }

  if (!v9)
  {
    sub_10005CFB8(a1, (uint64_t)v31);
    sub_10003389C(&v31, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 816LL);
  }

LABEL_5:
  if (!sub_1000683F8(a3, a2, "hardware-address"))
  {
    size_t v10 = v32[2][2];
    unsigned int v11 = (char *)sub_10005CDE4((v10 + 1));
    if (!v11)
    {
      sub_10005D71C(&v32, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 829LL);
      return 1LL;
    }

    unsigned int v12 = v11;
    memcpy(v11 + 1, v32[2] + 3, v10);
    sub_10005D71C(&v32, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 834LL);
    if (sub_1000683F8(a3, a2, "hardware-type"))
    {
      *unsigned int v12 = 1;
LABEL_26:
      uint64_t v31 = 0LL;
      sub_100029804( &v31,  qword_10008BE30,  v12,  (v10 + 1),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  869LL);
      sub_10005CE20( v12,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  870LL,  v13,  v14,  v15,  v16,  v17);
      uint64_t v18 = (_DWORD *)*a1;
      if (*a1 && v18 != v31)
      {
        sub_10005CFEC((_DWORD **)a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 873LL);
        uint64_t v8 = 874LL;
        goto LABEL_29;
      }

      if (v31)
      {
        if (!*((void *)v31 + 6))
        {
          if (!v18)
          {
            sub_10005CFB8(a1, (uint64_t)v31);
            sub_10003389C(&v31, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 890LL);
          }

          goto LABEL_6;
        }

        if (v18) {
          sub_10005CFEC((_DWORD **)a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 882LL);
        }
        sub_10003389C(&v31, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 883LL);
        return 43LL;
      }

      if (v18)
      {
        uint64_t v19 = (_DWORD **)a1;
        uint64_t v20 = 878LL;
        goto LABEL_56;
      }

      return 23LL;
    }

    uint64_t v21 = v32[2];
    int v22 = v21[1];
    if (v22)
    {
      if (v22 != 2)
      {
        sub_10005D71C(&v32, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 853LL);
        uint64_t v28 = v12;
        uint64_t v29 = 854LL;
        goto LABEL_62;
      }

      if (v21[2] != 4 || *((_BYTE *)v21 + 12) || *((_BYTE *)v21 + 13) || *((_BYTE *)v21 + 14))
      {
        sub_10005D71C(&v32, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 843LL);
        uint64_t v28 = v12;
        uint64_t v29 = 844LL;
LABEL_62:
        sub_10005CE20( v28,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  v29,  v23,  v24,  v25,  v26,  v27);
        return 39LL;
      }

      LOBYTE(v21) = *((_BYTE *)v21 + 15);
    }

    else
    {
      LODWORD(v21) = v21[2];
    }

    *unsigned int v12 = (_BYTE)v21;
    sub_10005D71C(&v32, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 858LL);
    goto LABEL_26;
  }

  uint64_t v33 = 0LL;
  sub_100029804( &v33,  qword_10008BE38,  v35[2] + 3,  v35[2][2],  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  1492LL);
  sub_10005D71C(&v35, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 1493LL);
  if (v33)
  {
    uint64_t v34 = 0LL;
    sub_100029804( &v34,  qword_10008BE18,  v33 + 51,  *((unsigned __int8 *)v33 + 203),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  1503LL);
    if (v34)
    {
      uint64_t v20 = (_DWORD *)*a1;
      if (*a1 && v20 != v34)
      {
        sub_10005CFEC((_DWORD **)a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 1506LL);
        if (!v34) {
          return 44LL;
        }
        unsigned int v9 = 1508LL;
        goto LABEL_39;
      }

      if ((v34[48] & 1) == 0)
      {
        if (!v20)
        {
          sub_10005CFB8(a1, (uint64_t)v34);
          sub_100033924(&v34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 1521LL);
        }

  uint64_t v8 = v16;
  if (v16)
  {
    if (*(char **)(a1 + 16) == v16)
    {
      sub_10005CFEC( (_DWORD **)(a1 + 16),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/listener.c",  184LL);
      uint64_t v8 = v16;
    }

    if (*((void *)v8 + 3) == a1)
    {
      sub_10005CFEC( (_DWORD **)v8 + 3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/listener.c",  188LL);
      uint64_t v8 = v16;
    }

    unsigned int v9 = *((_DWORD *)v8 + 8);
    if (v9 != -1) {
      close(v9);
    }
    size_t v10 = 193LL;
    goto LABEL_13;
  }

  return v6;
}

LABEL_6:
  if (*a1) {
    return 0LL;
  }
  else {
    return 46LL;
  }
}

    if ((_DWORD)v4 != 35) {
      break;
    }
    do
      uint64_t v6 = sub_1000374BC(a1);
    while (v6 != -1 && v6 != 10);
  }

  if ((_DWORD)v4 == 34)
  {
    unsigned int v7 = 0LL;
    uint64_t v8 = 0LL;
    unsigned int v9 = 0LL;
    size_t v10 = 0LL;
    *(_DWORD *)a1 = v2;
    *(_DWORD *)(a1 + 4) = v3;
    while (1)
    {
      unsigned int v11 = (char *)(a1 + v7 + 244);
      unsigned int v12 = v10;
      uint64_t v13 = v9;
      uint64_t v14 = v8;
      while (1)
      {
        while (1)
        {
          while (1)
          {
            uint64_t v8 = v14;
            unsigned int v9 = v13;
LABEL_14:
            size_t v10 = v12;
            uint64_t v15 = sub_1000374BC(a1);
            if (v15 == -1)
            {
              sub_100046D6C(a1, "eof in string constant", v16, v17, v18, v19, v20, v21, v53);
              goto LABEL_79;
            }

            if ((_DWORD)v10 == 1) {
              break;
            }
            if ((int)v10 < 2)
            {
              unsigned int v12 = 1LL;
              if (v15 != 92)
              {
                if (v15 != 34) {
                  goto LABEL_39;
                }
LABEL_79:
                if ((_DWORD)v7 == 1500)
                {
LABEL_80:
                  sub_100046D6C(a1, "string constant larger than internal buffer", v16, v17, v18, v19, v20, v21, v53);
                  LODWORD(v7) = 1499;
                }

                *(_BYTE *)(a1 + 244 + v7) = 0;
                *(_DWORD *)(a1 + 240) = v7;
                *(void *)(a1 + 232) = a1 + 244;
                return 262LL;
              }

              goto LABEL_14;
            }

            if ((_DWORD)v8)
            {
              if ((v15 - 48) <= 9)
              {
                uint64_t v13 = (v15 - 48 + 16 * v9);
                goto LABEL_36;
              }

              if ((v15 - 97) <= 5)
              {
                uint64_t v13 = (v15 + 16 * v9 - 87);
                goto LABEL_36;
              }

              if ((v15 - 65) > 5)
              {
                sub_100046D6C(a1, "invalid hex digit: %x", v16, v17, v18, v19, v20, v21, v15);
                size_t v10 = 0LL;
                goto LABEL_40;
              }

              uint64_t v13 = (v15 + 16 * v9 - 55);
LABEL_36:
              unsigned int v12 = (v10 + 1);
              uint64_t v14 = 1LL;
              if ((_DWORD)v10 == 3)
              {
LABEL_52:
                size_t v10 = 0LL;
                *unsigned int v11 = v13;
                unsigned int v9 = v13;
                goto LABEL_40;
              }
            }

            else if ((v15 & 0xFFFFFFF8) == 0x30)
            {
              uint64_t v14 = 0LL;
              uint64_t v13 = (v15 + 8 * v9 - 48);
              unsigned int v12 = (v10 + 1);
              if ((_DWORD)v10 == 3)
              {
                uint64_t v8 = 0LL;
                goto LABEL_52;
              }
            }

            else
            {
              if ((_DWORD)v9)
              {
                sub_100046D6C(a1, "invalid octal digit %x", v16, v17, v18, v19, v20, v21, v15);
                uint64_t v8 = 0LL;
                goto LABEL_40;
              }

              uint64_t v13 = 0LL;
              uint64_t v14 = 0LL;
              *unsigned int v11 = 0;
              unsigned int v12 = 1LL;
            }
          }

          uint64_t v13 = (v15 - 48);
          uint64_t v14 = 0LL;
          unsigned int v12 = 2LL;
        }

        if (v15 <= 115) {
          break;
        }
        uint64_t v13 = 0LL;
        uint64_t v14 = 1LL;
        unsigned int v12 = 2LL;
        if (v15 != 120)
        {
          if (v15 == 116)
          {
            size_t v10 = 0LL;
            *unsigned int v11 = 9;
            goto LABEL_40;
          }

uint64_t sub_100031384()
{
  return 27LL;
}

uint64_t sub_10003138C()
{
  return 27LL;
}

uint64_t sub_100031394(uint64_t *a1, int a2, uint64_t a3, const char *a4)
{
  if (*a1 == qword_10008BE88) {
    return sub_10003310C(a1, a2, a3, a4);
  }
  else {
    return 39LL;
  }
}

uint64_t sub_1000313B4(uint64_t a1, int a2, _DWORD *a3, int ***a4)
{
  if (*(void *)a1 != qword_10008BE88) {
    return 39LL;
  }
  if (!sub_100068648((uint64_t)a3, "name")) {
    return sub_100068B64( a4,  a3,  *(const char **)(a1 + 48),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  1940LL);
  }
  uint64_t v8 = *(void *)(a1 + 24);
  if (!v8) {
    return 69LL;
  }
  unsigned int v9 = *(uint64_t (**)(void))(*(void *)v8 + 24LL);
  if (!v9) {
    return 69LL;
  }
  uint64_t result = v9();
  if ((_DWORD)result) {
    return 69LL;
  }
  return result;
}

uint64_t sub_100031468(void *a1)
{
  if (*a1 == qword_10008BEB8 || *a1 == qword_10008BE88) {
    return 0LL;
  }
  else {
    return 39LL;
  }
}

uint64_t sub_100031490(void *a1, char *a2)
{
  if (*a1 == qword_10008BE88) {
    return sub_100033484((uint64_t)a1, a2);
  }
  else {
    return 39LL;
  }
}

uint64_t sub_1000314B0(uint64_t a1, uint64_t a2, void *a3)
{
  if (*a3 != qword_10008BE88) {
    return 39LL;
  }
  uint64_t v4 = a3[3];
  if (v4)
  {
    uint64_t v5 = *(void (**)(void))(*(void *)v4 + 48LL);
    if (v5) {
      v5();
    }
  }

  return 0LL;
}

uint64_t sub_1000314F8(void *a1, int a2, uint64_t a3)
{
  return sub_100033594(a1, a2, a3, qword_10008BE88);
}

uint64_t sub_100031504(void *a1)
{
  unsigned int v9 = 0LL;
  uint64_t v6 = sub_1000338A0((void **)&v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 2200LL);
  if (!(_DWORD)v6)
  {
    sub_100034128( v9 + 17,  qword_10008C140,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  2204LL,  v2,  v3,  v4,  v5);
    unsigned int v7 = v9;
    *((_DWORD *)v9 + 38) = 2;
    uint64_t v6 = sub_10005CFB8(a1, (uint64_t)v7);
    sub_1000338C0(&v9, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 2207LL);
  }

  return v6;
}

uint64_t sub_1000315AC(void *a1)
{
  if (*a1 != qword_10008BE88) {
    return 39LL;
  }
  sub_100029D78((uint64_t)a1, 1);
  return 0LL;
}

uint64_t sub_1000315E4(uint64_t *a1, int a2, uint64_t a3, const char *a4)
{
  if (*a1 == qword_10008BEB8) {
    return sub_10003310C(a1, a2, a3, a4);
  }
  else {
    return 39LL;
  }
}

uint64_t sub_100031604(void *a1)
{
  if (*a1 != qword_10008BE88 || a1[6]) {
    return 39LL;
  }
  uint64_t v2 = a1[3];
  if (!v2) {
    return 69LL;
  }
  uint64_t v3 = *(uint64_t (**)(void))(*(void *)v2 + 24LL);
  if (!v3) {
    return 69LL;
  }
  uint64_t result = v3();
  if ((_DWORD)result) {
    return 69LL;
  }
  return result;
}

uint64_t sub_100031658(void *a1, char *a2)
{
  if (*a1 == qword_10008BEB8) {
    return sub_100033484((uint64_t)a1, a2);
  }
  else {
    return 39LL;
  }
}

uint64_t sub_100031678(uint64_t a1, uint64_t a2, void *a3)
{
  if (*a3 != qword_10008BE88 || a3[6]) {
    return 39LL;
  }
  uint64_t v4 = a3[3];
  if (v4)
  {
    uint64_t v5 = *(void (**)(void))(*(void *)v4 + 48LL);
    if (v5) {
      v5();
    }
  }

  return 0LL;
}

uint64_t sub_1000316C8(void *a1, int a2, uint64_t a3)
{
  return sub_100033594(a1, a2, a3, qword_10008BEB8);
}

uint64_t sub_1000316D4(void *a1)
{
  unsigned int v9 = 0LL;
  uint64_t v6 = sub_1000338C4((void **)&v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 2329LL);
  if (!(_DWORD)v6)
  {
    sub_100034128( v9 + 17,  qword_10008C140,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  2332LL,  v2,  v3,  v4,  v5);
    unsigned int v7 = v9;
    *((_DWORD *)v9 + 38) = 2;
    uint64_t v6 = sub_10005CFB8(a1, (uint64_t)v7);
    sub_1000235C8(&v9, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 2337LL);
  }

  return v6;
}

void sub_10003177C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

uint64_t sub_100031790()
{
  return 0LL;
}

uint64_t sub_10003179C(void *a1)
{
  if (*a1 != qword_10008BEB0) {
    return 39LL;
  }
  uint64_t v3 = a1[3];
  if (!v3) {
    return 69LL;
  }
  uint64_t v4 = *(uint64_t (**)(void))(*(void *)v3 + 16LL);
  uint64_t v1 = 69LL;
  if (v4)
  {
    int v5 = v4();
    if (v5) {
      unsigned int v6 = 69;
    }
    else {
      unsigned int v6 = 0;
    }
    if (v5 == 42) {
      return 42LL;
    }
    else {
      return v6;
    }
  }

  return v1;
}

uint64_t sub_100031808(void *a1)
{
  if (*a1 != qword_10008BEB0) {
    return 39LL;
  }
  uint64_t v2 = a1[3];
  if (!v2) {
    return 69LL;
  }
  uint64_t v3 = *(uint64_t (**)(void))(*(void *)v2 + 24LL);
  if (!v3) {
    return 69LL;
  }
  uint64_t result = v3();
  if ((_DWORD)result) {
    return 69LL;
  }
  return result;
}

uint64_t sub_100031854(void *a1)
{
  if (*a1 == qword_10008BEB0) {
    return 0LL;
  }
  else {
    return 39LL;
  }
}

uint64_t sub_100031870(void *a1)
{
  if (*a1 != qword_10008BEB0) {
    return 39LL;
  }
  uint64_t v2 = a1[3];
  if (!v2) {
    return 23LL;
  }
  uint64_t v3 = *(uint64_t (**)(void))(*(void *)v2 + 40LL);
  if (!v3) {
    return 23LL;
  }
  uint64_t result = v3();
  if ((_DWORD)result) {
    return 23LL;
  }
  return result;
}

uint64_t sub_1000318BC(uint64_t a1, uint64_t a2, void *a3)
{
  if (*a3 != qword_10008BEB0) {
    return 39LL;
  }
  uint64_t v4 = a3[3];
  if (v4)
  {
    int v5 = *(void (**)(void))(*(void *)v4 + 48LL);
    if (v5) {
      v5();
    }
  }

  return 0LL;
}

uint64_t sub_100031904(void *a1)
{
  if (*a1) {
    return 0LL;
  }
  else {
    return 46LL;
  }
}

uint64_t sub_100031918()
{
  return 27LL;
}

uint64_t sub_100031920()
{
  return 27LL;
}

uint64_t sub_100031928(uint64_t a1, int a2, uint64_t a3, _DWORD *a4)
{
  if (*(void *)a1 != qword_10008BE10) {
    return 39LL;
  }
  if (!sub_100068648(a3, "name"))
  {
    if (!*(void *)(a1 + 48))
    {
      int v22 = sub_10005CDE4((a4[2] + 1));
      *(void *)(a1 + 48) = v22;
      if (v22)
      {
        memcpy(v22, a4 + 3, a4[2]);
        uint64_t v4 = 0LL;
        *(_BYTE *)(*(void *)(a1 + 48) + a4[2]) = 0;
        return v4;
      }

      return 1LL;
    }

    return 18LL;
  }

  if (!sub_100068648(a3, "group"))
  {
    if (a4 && (a4[1] - 1) <= 1)
    {
      uint64_t v58 = 0LL;
      sub_100029804( &v58,  qword_10008C130,  a4 + 3,  a4[2],  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  952LL);
      uint64_t v28 = v58;
      if (!v58 || (v58[7].i8[0] & 1) != 0) {
        return 23LL;
      }
      if (*(void *)(a1 + 152))
      {
        sub_100034198( (char **)(a1 + 152),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  956LL,  v23,  v24,  v25,  v26,  v27);
        uint64_t v28 = v58;
      }

      sub_100034128( (uint64_t *)(a1 + 152),  *(void *)&v28[5],  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  957LL,  v24,  v25,  v26,  v27);
      uint64_t v30 = *(void *)(a1 + 160);
      uint64_t v29 = a1 + 160;
      if (v30) {
        sub_1000235C8(v29, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 960LL);
      }
      sub_1000235CC(v29, v58, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 962LL);
      sub_1000235C8(&v58, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 963LL);
      return 0LL;
    }

    return 39LL;
  }

  if (!sub_100068648(a3, "hardware-address"))
  {
    if (!*(_BYTE *)(a1 + 56))
    {
      if (a4)
      {
        if ((a4[1] - 1) <= 1)
        {
          size_t v31 = a4[2];
          if (v31 <= 0x10)
          {
            memcpy((void *)(a1 + 58), a4 + 3, v31);
            uint64_t v4 = 0LL;
            *(_BYTE *)(a1 + 56) = *((_BYTE *)a4 + 8) + 1;
            return v4;
          }
        }
      }

      return 39LL;
    }

    return 18LL;
  }

  if (!sub_100068648(a3, "hardware-type"))
  {
    if (a4)
    {
      int v32 = a4[1];
      if (v32 == 2)
      {
        if (a4[2] != 4) {
          return 39LL;
        }
        LOBYTE(v33) = bswap32(a4[3]);
LABEL_57:
        uint64_t v4 = 0LL;
        *(_BYTE *)(a1 + 57) = v33;
        return v4;
      }
    }

    else
    {
      int v32 = MEMORY[4];
    }

    if (v32) {
      return 39LL;
    }
    int v33 = a4[2];
    goto LABEL_57;
  }

  if (!sub_100068648(a3, "dhcp-client-identifier"))
  {
    if (!*(void *)(a1 + 88))
    {
      if (sub_1000345C4( (void *)(a1 + 80),  a4[2],  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  1010LL))
      {
        uint64_t v48 = (void *)(*(void *)(a1 + 80) + 4LL);
        *(void *)(a1 + 88) = v48;
        memcpy(v48, a4 + 3, a4[2]);
        uint64_t v4 = 0LL;
        *(_DWORD *)(a1 + 96) = a4[2];
        return v4;
      }

      return 1LL;
    }

    return 18LL;
  }

  if (!sub_100068648(a3, "ip-address"))
  {
    uint64_t v35 = *(void *)(a1 + 136);
    uint64_t v34 = (int **)(a1 + 136);
    if (v35) {
      sub_100040E08( v34,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  1025LL,  v9,  v10,  v11,  v12,  v13);
    }
    if (!a4) {
      return 0LL;
    }
    char v59 = 0LL;
    size_t __n = 0LL;
    uint64_t v58 = 0LL;
    LODWORD(__n) = a4[2];
    if (sub_1000345C4( &v58,  __n,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  1033LL))
    {
      char v59 = (_DWORD *)v58 + 1;
      memcpy((char *)v58 + 4, a4 + 3, __n);
      if (sub_100054A34( v34,  (uint64_t)&v58,  0LL,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  1040LL,  v36,  v37))
      {
        sub_100034EA8( (_DWORD **)&v58,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  1044LL,  v38,  v39,  v40,  v41,  v42);
        return 0LL;
      }

      sub_100034EA8( (_DWORD **)&v58,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  1041LL,  v38,  v39,  v40,  v41,  v42);
    }

    return 1LL;
  }

  if (!sub_100068648(a3, "statements"))
  {
    uint64_t v44 = a1 + 152;
    uint64_t v43 = *(void *)(a1 + 152);
    if (!v43)
    {
      uint64_t v43 = qword_10008C140;
      uint64_t v46 = (uint64_t *)(a1 + 152);
      uint64_t v47 = 1052LL;
      goto LABEL_70;
    }

    if (!*(void *)(v43 + 48)
      || (uint64_t v45 = *(void *)(a1 + 160)) != 0 && v43 == *(void *)(v45 + 40)
      || v43 == qword_10008C140)
    {
      uint64_t v46 = (uint64_t *)(a1 + 152);
      uint64_t v47 = 1060LL;
LABEL_70:
      if (sub_1000406C0( v46,  v43,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  v47,  v14,  v15,  v16,  v17)
        && *(void *)v44)
      {
        if (a4 && (a4[1] - 1) <= 1)
        {
          int v57 = 0;
          uint64_t v58 = 0LL;
          uint64_t v4 = sub_100036AA8(&v58, -1, (uint64_t)(a4 + 3), a4[2], (uint64_t)"network client", 0);
          if ((_DWORD)v4 || !v58) {
            return v4;
          }
          BOOL v49 = sub_100049E64((void **)(*(void *)v44 + 48LL), v58, &v57, 0LL);
          sub_100036BD4((uint64_t *)&v58, v50, v51, v52, v53, v54, v55, v56);
          if (!v49) {
            return 45LL;
          }
          return 0LL;
        }

        return 39LL;
      }

      return 1LL;
    }

    return 18LL;
  }

  uint64_t v18 = *(void *)(a1 + 24);
  if (!v18) {
    return 69LL;
  }
  uint64_t v19 = *(uint64_t (**)(void))(*(void *)v18 + 16LL);
  uint64_t v4 = 69LL;
  if (v19)
  {
    int v20 = v19();
    if (v20) {
      unsigned int v21 = 69;
    }
    else {
      unsigned int v21 = 0;
    }
    if (v20 == 42) {
      return 42LL;
    }
    else {
      return v21;
    }
  }

  return v4;
}

uint64_t sub_100031E50(uint64_t a1, int a2, _DWORD *a3, int ***a4)
{
  if (*(void *)a1 != qword_10008BE10) {
    return 39LL;
  }
  if (!sub_100068648((uint64_t)a3, "ip-addresses"))
  {
    int v22 = 0LL;
    uint64_t v23 = 0LL;
    uint64_t v24 = 0LL;
    uint64_t v11 = *(void *)(a1 + 136);
    if (v11
      && sub_100057AA4( &v22,  0LL,  0LL,  0LL,  0LL,  0LL,  &qword_10008C730,  v11,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  0x468u))
    {
      uint64_t v4 = sub_10006883C( a4,  a3,  v23,  (const char *)v24,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  1131LL);
      sub_100034EA8( &v22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  1132LL,  v12,  v13,  v14,  v15,  v16);
      return v4;
    }

    return 23LL;
  }

  if (!sub_100068648((uint64_t)a3, "dhcp-client-identifier"))
  {
    uint64_t v17 = (const char *)*(unsigned int *)(a1 + 96);
    if ((_DWORD)v17)
    {
      uint64_t v18 = *(const void **)(a1 + 88);
      uint64_t v19 = a4;
      int v20 = a3;
      uint64_t v21 = 1144LL;
      return sub_10006883C( v19,  v20,  v18,  v17,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  v21);
    }

    return 23LL;
  }

  if (!sub_100068648((uint64_t)a3, "name")) {
    return sub_100068B64( a4,  a3,  *(const char **)(a1 + 48),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  1149LL);
  }
  if (!sub_100068648((uint64_t)a3, "hardware-address"))
  {
    if (*(_BYTE *)(a1 + 56))
    {
      uint64_t v18 = (const void *)(a1 + 58);
      uint64_t v17 = (const char *)(*(unsigned __int8 *)(a1 + 56) - 1);
      uint64_t v19 = a4;
      int v20 = a3;
      uint64_t v21 = 1156LL;
      return sub_10006883C( v19,  v20,  v18,  v17,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  v21);
    }

    return 23LL;
  }

  if (sub_100068648((uint64_t)a3, "hardware-type"))
  {
    uint64_t v9 = *(void *)(a1 + 24);
    else {
      return 69LL;
    }
  }

  if (!*(_BYTE *)(a1 + 56)) {
    return 23LL;
  }
  return sub_100068920( a4,  a3,  (const char *)*(unsigned __int8 *)(a1 + 57),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  1163LL);
}

uint64_t sub_10003208C(void *a1)
{
  if (*a1 == qword_10008BE10) {
    return 0LL;
  }
  else {
    return 39LL;
  }
}

uint64_t sub_1000320A8(uint64_t a1, char *__s1)
{
  if (*(void *)a1 != qword_10008BE10) {
    return 39LL;
  }
  int v9 = strcmp(__s1, "updated");
  if (!v9)
  {
    if (!*(_BYTE *)(a1 + 56) && !*(_DWORD *)(a1 + 96)) {
      return 39LL;
    }
    if (!*(void *)(a1 + 48))
    {
      __sprintf_chk(__s, 0, 0x40uLL, "nh%08lx%08lx", qword_10008CE80, a1);
      int v12 = strlen(__s);
      uint64_t v13 = (char *)sub_10005CDE4((v12 + 1));
      *(void *)(a1 + 48) = v13;
      if (!v13) {
        return 1LL;
      }
      strcpy(v13, __s);
    }

    uint64_t result = sub_100029218(a1, 1, 1, v4, v5, v6, v7, v8);
    if ((_DWORD)result) {
      return result;
    }
  }

  uint64_t v10 = *(void *)(a1 + 24);
  if (!v10 || (uint64_t v11 = *(uint64_t (**)(void))(*(void *)v10 + 40LL)) == 0LL || (result = v11(), (_DWORD)result))
  {
    if (v9) {
      return 23LL;
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_1000321F8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)a3 != qword_10008BE10) {
    return 39LL;
  }
  uint64_t v10 = 0LL;
  uint64_t v11 = 0LL;
  uint64_t v12 = 0LL;
  uint64_t v7 = *(void *)(a3 + 136);
  if (!v7
    || !sub_100057AA4( &v10,  0LL,  0LL,  0LL,  0LL,  0LL,  &qword_10008C730,  v7,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  0x4FEu)
    || (uint64_t result = sub_10005F114(a1, "ip-address"), !(_DWORD)result)
    && (uint64_t result = sub_10005EF64(a1, v12), !(_DWORD)result)
    && (uint64_t result = sub_10005E7A4(a1, v11, v12), !(_DWORD)result))
  {
    if (!*(_DWORD *)(a3 + 96)
      || (uint64_t result = sub_10005F114(a1, "dhcp-client-identifier"), !(_DWORD)result)
      && (uint64_t result = sub_10005EF64(a1, *(_DWORD *)(a3 + 96)), !(_DWORD)result)
      && (uint64_t result = sub_10005E7A4(a1, *(void *)(a3 + 88), *(_DWORD *)(a3 + 96)), !(_DWORD)result))
    {
      if (!*(void *)(a3 + 48)
        || (uint64_t result = sub_10005F114(a1, "name"), !(_DWORD)result)
        && (uint64_t result = sub_10005F180(a1, *(char **)(a3 + 48)), !(_DWORD)result))
      {
        if (!*(_BYTE *)(a3 + 56)
          || (uint64_t result = sub_10005F114(a1, "hardware-address"), !(_DWORD)result)
          && (uint64_t result = sub_10005EF64(a1, *(unsigned __int8 *)(a3 + 56) - 1), !(_DWORD)result)
          && (uint64_t result = sub_10005E7A4(a1, a3 + 58, *(unsigned __int8 *)(a3 + 56) - 1), !(_DWORD)result)
          && (uint64_t result = sub_10005F114(a1, "hardware-type"), !(_DWORD)result)
          && (uint64_t result = sub_10005EF64(a1, 4u), !(_DWORD)result)
          && (uint64_t result = sub_10005EF64(a1, *(unsigned __int8 *)(a3 + 57)), !(_DWORD)result))
        {
          uint64_t v8 = *(void *)(a3 + 24);
          if (v8)
          {
            int v9 = *(void (**)(uint64_t, uint64_t))(*(void *)v8 + 48LL);
            if (v9) {
              v9(a1, a2);
            }
          }

          return 0LL;
        }
      }
    }
  }

  return result;
}

uint64_t sub_1000323D8(void *a1, int a2, uint64_t a3)
{
  uint64_t v35 = 0LL;
  if (!a3) {
    return 46LL;
  }
  if (!sub_1000683F8(a3, a2, "handle"))
  {
    uint64_t v6 = sub_100062F48(a1, v35[2]);
    sub_10005D71C(&v35, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 1369LL);
    if ((_DWORD)v6) {
      return v6;
    }
    if (*(void *)*a1 != qword_10008BE10)
    {
      sub_10005CFEC((_DWORD **)a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 1375LL);
      return 39LL;
    }

    if ((*(_BYTE *)(*a1 + 192LL) & 1) != 0) {
      sub_10005CFEC((_DWORD **)a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 1379LL);
    }
  }

  if (!sub_1000683F8(a3, a2, "dhcp-client-identifier"))
  {
    uint64_t v34 = 0LL;
    sub_100029804( &v34,  qword_10008BE28,  v35[2] + 3,  v35[2][2],  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  1389LL);
    sub_10005D71C(&v35, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 1390LL);
    uint64_t v7 = (_DWORD *)*a1;
    uint64_t v8 = v34;
    if (*a1 && v7 != v34)
    {
      sub_10005CFEC((_DWORD **)a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 1393LL);
      if (!v34) {
        return 44LL;
      }
      uint64_t v9 = 1395LL;
LABEL_39:
      sub_100033924(&v34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", v9);
      return 44LL;
    }

    if (!v34 || (v34[48] & 1) != 0)
    {
      if (v7)
      {
        sub_10005CFEC((_DWORD **)a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 1399LL);
        uint64_t v8 = v34;
      }

      if (!v8) {
        return 23LL;
      }
      uint64_t v22 = 1401LL;
      goto LABEL_73;
    }

    if (!v7)
    {
      sub_10005CFB8(a1, (uint64_t)v34);
      sub_100033924(&v34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 1408LL);
    }
  }

  size_t v10 = v35[2][2];
  uint64_t v11 = (char *)sub_10005CDE4((v10 + 1));
  if (!v11)
  {
    sub_10005D71C(&v35, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 1421LL);
    return 1LL;
  }

  uint64_t v12 = v11;
  memcpy(v11 + 1, v35[2] + 3, v10);
  sub_10005D71C(&v35, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 1426LL);
  if (!sub_1000683F8(a3, a2, "hardware-type"))
  {
    uint64_t v23 = v35[2];
    int v24 = v23[1];
    if (v24)
    {
      if (v24 != 2)
      {
        sub_10005D71C(&v35, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 1445LL);
        uint64_t v30 = v12;
        uint64_t v31 = 1446LL;
        goto LABEL_78;
      }

      if (v23[2] != 4 || *((_BYTE *)v23 + 12) || *((_BYTE *)v23 + 13) || *((_BYTE *)v23 + 14))
      {
        sub_10005D71C(&v35, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 1435LL);
        uint64_t v30 = v12;
        uint64_t v31 = 1436LL;
LABEL_78:
        sub_10005CE20( v30,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  v31,  v25,  v26,  v27,  v28,  v29);
        return 39LL;
      }

      LOBYTE(v23) = *((_BYTE *)v23 + 15);
    }

    else
    {
      LODWORD(v23) = v23[2];
    }

    *uint64_t v12 = (_BYTE)v23;
    sub_10005D71C(&v35, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 1450LL);
    goto LABEL_21;
  }

  *uint64_t v12 = 1;
LABEL_21:
  uint64_t v34 = 0LL;
  sub_100029804( &v34,  qword_10008BE18,  v12,  (v10 + 1),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  1460LL);
  sub_10005CE20( v12,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  1461LL,  v13,  v14,  v15,  v16,  v17);
  uint64_t v18 = (_DWORD *)*a1;
  uint64_t v19 = v34;
  if (*a1 && v18 != v34)
  {
    sub_10005CFEC((_DWORD **)a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 1464LL);
    if (!v34) {
      return 44LL;
    }
    uint64_t v9 = 1466LL;
    goto LABEL_39;
  }

  if (!v34 || (v34[48] & 1) != 0)
  {
    if (v18)
    {
      sub_10005CFEC((_DWORD **)a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 1470LL);
      uint64_t v19 = v34;
    }

    if (!v19) {
      return 23LL;
    }
    uint64_t v22 = 1472LL;
    goto LABEL_73;
  }

  if (!v18)
  {
    sub_10005CFB8(a1, (uint64_t)v34);
    sub_100033924(&v34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 1479LL);
  }

LABEL_83:
        sub_10003389C(&v33, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 1523LL);
        goto LABEL_6;
      }

      sub_100033924(&v34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 1513LL);
    }

    if (!*a1) {
      return 23LL;
    }
    goto LABEL_83;
  }

  if (!*a1) {
    return 23LL;
  }
LABEL_6:
  if (!sub_1000683F8(a3, a2, "name"))
  {
    uint64_t v34 = 0LL;
    sub_100029804( &v34,  qword_10008BE20,  v35[2] + 3,  v35[2][2],  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  1533LL);
    sub_10005D71C(&v35, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 1534LL);
    uint64_t v21 = (_DWORD *)*a1;
    if (*a1 && v21 != v34)
    {
      sub_10005CFEC((_DWORD **)a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 1537LL);
      if (v34)
      {
        uint64_t v9 = 1539LL;
        goto LABEL_39;
      }

      return 44LL;
    }

    if (!v34) {
      return 23LL;
    }
    if ((v34[48] & 1) == 0)
    {
      if (!v21)
      {
        sub_10005CFB8(a1, (uint64_t)v34);
        sub_100033924(&v34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 1550LL);
      }

      goto LABEL_7;
    }

    uint64_t v22 = 1543LL;
LABEL_73:
    sub_100033924(&v34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", v22);
    return 23LL;
  }

LABEL_7:
  if (*a1) {
    return 0LL;
  }
  else {
    return 46LL;
  }
}

uint64_t sub_100032A90(void *a1)
{
  uint64_t v9 = 0LL;
  uint64_t v6 = sub_100033904((void **)&v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 1567LL);
  if (!(_DWORD)v6)
  {
    sub_100034128( v9 + 19,  qword_10008C140,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  1570LL,  v2,  v3,  v4,  v5);
    uint64_t v7 = v9;
    *((_DWORD *)v9 + 48) = 2;
    uint64_t v6 = sub_10005CFB8(a1, (uint64_t)v7);
    sub_100033924((_DWORD **)&v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 1573LL);
  }

  return v6;
}

uint64_t sub_100032B38( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a1 != qword_10008BE10) {
    return 39LL;
  }
  sub_100029808((uint64_t)a1, 1, a3, a4, a5, a6, a7, a8);
  return 0LL;
}

uint64_t sub_100032B70(uint64_t a1, int a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v8 = (char *)sub_10005CDE4((*(_DWORD *)(a3 + 4) + 1));
  if (!v8) {
    return 1LL;
  }
  uint64_t v9 = v8;
  memcpy(v8, (const void *)(a3 + 8), *(unsigned int *)(a3 + 4));
  v9[*(unsigned int *)(a3 + 4)] = 0;
  size_t v10 = sub_100055100(a1, v9);
  uint64_t v16 = v10;
  if (!a2 && !v10)
  {
    sub_10005CE20( v9,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  2381LL,  v11,  v12,  v13,  v14,  v15);
    return 69LL;
  }

  if (!a4)
  {
    sub_10005CE20( v9,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  2385LL,  v11,  v12,  v13,  v14,  v15);
    if (!v16) {
      return 69LL;
    }
    uint64_t v30 = (uint64_t *)(v16 + 2);
    uint64_t v31 = 2388LL;
    goto LABEL_24;
  }

  uint64_t v50 = 0LL;
  if (sub_10003444C( &v50,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  2393LL,  v11,  v12,  v13,  v14,  v15))
  {
    int v23 = a4[1];
    if ((v23 - 1) >= 2)
    {
      if (v23 == 3)
      {
        sub_1000577E8( (uint64_t *)&v50,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  2417LL,  v18,  v19,  v20,  v21,  v22);
        sub_10005CE20( v9,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  2418LL,  v45,  v46,  v47,  v48,  v49);
        return 39LL;
      }

      if (!v23)
      {
        int v24 = v50;
        v50[1] = 2;
        *((void *)v24 + 1) = (int)a4[2];
      }

      goto LABEL_17;
    }

    if (sub_1000345C4( (void *)v50 + 1,  a4[2],  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  2406LL))
    {
      memcpy((void *)(*((void *)v50 + 1) + 5LL), a4 + 3, a4[2]);
      v50[6] = a4[2];
LABEL_17:
      if (v16)
      {
        if (v16[2]) {
          sub_1000577E8( (uint64_t *)v16 + 2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  2436LL,  v18,  v19,  v20,  v21,  v22);
        }
        sub_10005CE20( v9,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  2437LL,  v18,  v19,  v20,  v21,  v22);
        goto LABEL_23;
      }

      uint64_t v43 = (uint64_t **)sub_10005CDE4(0x18uLL);
      if (v43)
      {
        uint64_t v16 = v43;
        v43[1] = 0LL;
        v43[2] = 0LL;
        *uint64_t v43 = 0LL;
        *uint64_t v43 = *(uint64_t **)(a1 + 16);
        v43[1] = (uint64_t *)v9;
        *(void *)(a1 + 16) = v43;
LABEL_23:
        sub_100033F18( v16 + 2,  v50,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  2439LL,  v39,  v40,  v41,  v42);
        uint64_t v30 = (uint64_t *)&v50;
        uint64_t v31 = 2440LL;
LABEL_24:
        sub_1000577E8( v30,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  v31,  v25,  v26,  v27,  v28,  v29);
        return 0LL;
      }

      sub_1000577E8( (uint64_t *)&v50,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  2425LL,  v44,  v39,  v40,  v41,  v42);
      int v32 = v9;
      uint64_t v33 = 2426LL;
      goto LABEL_28;
    }

    sub_1000577E8( (uint64_t *)&v50,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  2407LL,  v34,  v35,  v36,  v37,  v38);
    int v32 = v9;
    uint64_t v33 = 2408LL;
  }

  else
  {
    int v32 = v9;
    uint64_t v33 = 2394LL;
  }

LABEL_28:
  sub_10005CE20( v32,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  v33,  v18,  v19,  v20,  v21,  v22);
  return 1LL;
}

    sub_10003462C( &v100,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  271LL,  v15,  v16,  v17,  v18,  v19);
    return 1LL;
  }

  else
  {
    sub_10006221C("no memory for option buffer.", v8, v9, v10, v11, v12, v13, v14, v95);
    return 0LL;
  }

  *__error() = 40;
  return 0xFFFFFFFFLL;
}

            if (v5 > 1023) {
              goto LABEL_4;
            }
            uint64_t v12 = 0;
            ++v5;
            *uint64_t v7 = v14;
            uint64_t v4 = *a2;
LABEL_30:
            *a2 = ++v4;
            goto LABEL_16;
          }

          if ((v14 - 48) > 9)
          {
            uint64_t v7 = (_BYTE *)(a1 + v5);
            goto LABEL_28;
          }

          uint64_t v16 = strchr(a0123456789_0, v14) - a0123456789_0 + 10 * v16;
          if (++v11 == 3)
          {
            uint64_t v7 = (_BYTE *)(a1 + v5);
            LOBYTE(v14) = v16;
            goto LABEL_28;
          }
        }

        uint64_t v4 = *a2 + 1;
        *a2 = v4;
        uint64_t v12 = 1;
      }

uint64_t sub_100032E10(void *a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v6 = (char *)sub_10005CDE4((a3[1] + 1));
  if (!v6) {
    return 1LL;
  }
  uint64_t v7 = v6;
  memcpy(v6, a3 + 2, a3[1]);
  v7[a3[1]] = 0;
  uint64_t v8 = sub_100055100(a2, v7);
  sub_10005CE20( v7,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  2458LL,  v9,  v10,  v11,  v12,  v13);
  if (!v8) {
    return 69LL;
  }
  uint64_t v21 = v8[2];
  if (!v21) {
    return 69LL;
  }
  uint64_t v22 = 39LL;
  switch(*((_DWORD *)v21 + 1))
  {
    case 0:
      uint64_t v26 = 0LL;
      uint64_t v23 = sub_10005D348( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  2467LL,  &v26,  0,  v17,  v18,  v19,  v20,  (const char *)*((unsigned int *)v21 + 2));
      goto LABEL_13;
    case 1:
      uint64_t v26 = 0LL;
      uint64_t v22 = sub_10005D348( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  2480LL,  &v26,  2,  v17,  v18,  v19,  v20,  (const char *)*((unsigned int *)v21 + 6));
      if ((_DWORD)v22) {
        return v22;
      }
      memcpy(v26 + 3, (const void *)v8[2][2], *((unsigned int *)v8[2] + 6));
      goto LABEL_14;
    case 2:
      uint64_t v26 = 0LL;
      uint64_t v23 = sub_10005D348( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  2473LL,  &v26,  0,  v17,  v18,  v19,  v20,  (const char *)v21[1]);
LABEL_13:
      uint64_t v22 = v23;
      if (!(_DWORD)v23)
      {
LABEL_14:
        uint64_t v25 = sub_10005D6B8(a1);
        if ((_DWORD)v25)
        {
          uint64_t v22 = v25;
          sub_10005D538(&v26, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 2503LL);
        }

        else
        {
          sub_10005D504((void *)(*a1 + 8LL), a3);
          sub_10005D504((void *)(*a1 + 16LL), v26);
          sub_10005D538(&v26, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 2509LL);
          uint64_t v22 = 0LL;
        }
      }

      break;
    case 3:
    case 4:
      return v22;
    default:
      sub_100061FB4("Impossible case at %s:%d.", v14, v15, v16, v17, v18, v19, v20, 39);
  }

  return v22;
}

uint64_t sub_100033020(uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(uint64_t ***)(a2 + 16); i; uint64_t i = (uint64_t **)*i)
  {
    uint64_t v4 = i[2];
    if (v4 && (*((_DWORD *)v4 + 1) - 3) >= 2)
    {
      unsigned int v5 = strlen((const char *)i[1]);
      uint64_t result = sub_10005EFD8(a1, v5);
      if ((_DWORD)result) {
        return result;
      }
      uint64_t result = sub_10005E7A4(a1, (uint64_t)i[1], v5);
      if ((_DWORD)result) {
        return result;
      }
      uint64_t v7 = i[2];
      int v8 = *((_DWORD *)v7 + 1);
      switch(v8)
      {
        case 2:
LABEL_9:
          uint64_t result = sub_10005EF64(a1, 4u);
          if ((_DWORD)result) {
            return result;
          }
          sub_10005EF64(a1, *((_DWORD *)i[2] + 2));
          continue;
        case 1:
          uint64_t result = sub_10005EF64(a1, *((_DWORD *)v7 + 6));
          if ((_DWORD)result) {
            return result;
          }
          uint64_t v9 = i[2];
          unsigned int v10 = *((_DWORD *)v9 + 6);
          if (v10)
          {
            uint64_t result = sub_10005E7A4(a1, v9[2], v10);
            if ((_DWORD)result) {
              return result;
            }
          }

          break;
        case 0:
          goto LABEL_9;
      }
    }
  }

  return 0LL;
}

uint64_t sub_10003310C(uint64_t *a1, int a2, uint64_t a3, const char *a4)
{
  uint64_t v43 = 0LL;
  uint64_t v7 = *a1;
  uint64_t v8 = qword_10008BEB8;
  if (!sub_100068648(a3, "name"))
  {
    if (!a1[6])
    {
      uint64_t v22 = (char *)sub_10005CDE4((*((_DWORD *)a4 + 2) + 1));
      if (!v22) {
        return 1LL;
      }
      uint64_t v23 = v22;
      memcpy(v22, a4 + 12, *((unsigned int *)a4 + 2));
      if (v7 == v8)
      {
        uint64_t v11 = sub_100003828( (uint64_t)&v43,  v23,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  1792LL);
        sub_10005CE20( v23,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  1793LL,  v35,  v36,  v37,  v38,  v39);
        if ((_DWORD)v11 == 23) {
          return v11;
        }
        uint64_t v41 = a1[5];
        uint64_t v40 = a1 + 5;
        if (v41) {
          sub_1000338C0(v40, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 1799LL);
        }
        sub_1000338BC(v40, v43, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 1801LL);
        return 0LL;
      }

      int v24 = sub_10005CDE4((*((_DWORD *)a4 + 2) + 1));
      a1[6] = (uint64_t)v24;
      if (v24)
      {
        memcpy(v24, a4 + 12, *((unsigned int *)a4 + 2));
        return 0LL;
      }

      return 1LL;
    }

    return 18LL;
  }

  if (v7 == v8 && !sub_100068648(a3, "hashstring"))
  {
    if (!a1[12])
    {
      if (sub_1000345C4( a1 + 11,  *((_DWORD *)a4 + 2),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  1825LL))
      {
        uint64_t v33 = (void *)(a1[11] + 4);
        a1[12] = (uint64_t)v33;
        memcpy(v33, a4 + 12, *((unsigned int *)a4 + 2));
        uint64_t v11 = 0LL;
        *((_DWORD *)a1 + 26) = *((_DWORD *)a4 + 2);
        return v11;
      }

      return 1LL;
    }

    return 18LL;
  }

  if (!sub_100068648(a3, "group"))
  {
    uint64_t v42 = 0LL;
    sub_100029804( &v42,  qword_10008C130,  a4 + 12,  *((unsigned int *)a4 + 2),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  1845LL);
    uint64_t v19 = v42;
    if (!v42 || (*(_BYTE *)(v42 + 56) & 1) != 0) {
      return 23LL;
    }
    uint64_t v21 = a1[17];
    uint64_t v20 = (char **)(a1 + 17);
    if (v21)
    {
      sub_100034198( v20,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  1849LL,  v14,  v15,  v16,  v17,  v18);
      uint64_t v19 = v42;
    }

    sub_100034128( (uint64_t *)v20,  *(void *)(v19 + 40),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  1850LL,  v15,  v16,  v17,  v18);
    sub_1000235C8(&v42, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 1851LL);
    return 0LL;
  }

  if (!sub_100068648(a3, "match"))
  {
    unsigned int v25 = *((_DWORD *)a4 + 2);
    size_t v26 = v25 >= 8 ? 8LL : v25;
    if (strncmp("hardware", a4 + 12, v26)) {
      return 39LL;
    }
    int v32 = a1 + 15;
    if (sub_1000343B4( v32,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  1872LL,  v27,  v28,  v29,  v30,  v31))
    {
      uint64_t v11 = 0LL;
      *(_DWORD *)(*v32 + 4LL) = 12;
      return v11;
    }

    return 1LL;
  }

  uint64_t v9 = a1[3];
  if (!v9) {
    return 69LL;
  }
  unsigned int v10 = *(uint64_t (**)(void))(*(void *)v9 + 16LL);
  uint64_t v11 = 69LL;
  if (v10)
  {
    int v12 = v10();
    if (v12) {
      unsigned int v13 = 69;
    }
    else {
      unsigned int v13 = 0;
    }
    if (v12 == 42) {
      return 42LL;
    }
    else {
      return v13;
    }
  }

  return v11;
}

uint64_t sub_100033484(uint64_t a1, char *__s1)
{
  int v7 = strcmp(__s1, "updated");
  if (!v7)
  {
    if (*(void *)a1 == qword_10008BEB8)
    {
      uint64_t v12 = *(void *)(a1 + 40);
      if (!v12) {
        return 39LL;
      }
      unsigned int v13 = *(const char **)(a1 + 96);
      if (!v13) {
        return 39LL;
      }
      uint64_t v16 = *(void *)(v12 + 80);
      uint64_t v15 = (uint64_t *)(v12 + 80);
      uint64_t v14 = v16;
      if (!v16)
      {
        sub_10002D664( v15,  0x2EE7u,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  2034LL,  v3,  v4,  v5,  v6);
        uint64_t v14 = *(void *)(*(void *)(a1 + 40) + 80LL);
        unsigned int v13 = *(const char **)(a1 + 96);
      }

      sub_1000634B8( v14,  v13,  *(unsigned int *)(a1 + 104),  a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  2039LL,  v5,  v6,  v17);
    }

    else
    {
      uint64_t v11 = *(_BYTE **)(a1 + 48);
      if (!v11 || !*v11) {
        return 39LL;
      }
    }

    uint64_t result = sub_100028FB4(a1, 1, 1);
    if ((_DWORD)result) {
      return result;
    }
  }

  uint64_t v8 = *(void *)(a1 + 24);
  if (!v8 || (uint64_t v9 = *(uint64_t (**)(void))(*(void *)v8 + 40LL)) == 0LL || (result = v9(), (_DWORD)result))
  {
    if (v7) {
      return 23LL;
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_100033594(void *a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v19 = 0LL;
  uint64_t v20 = 0LL;
  uint64_t v17 = 0LL;
  uint64_t v18 = 0LL;
  *a1 = 0LL;
  uint64_t v9 = sub_10005CDE4((v20[2][2] + 1));
  memcpy(v9, v20[2] + 3, v20[2][2]);
  sub_10005D71C(&v20, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 2126LL);
  sub_100003828( (uint64_t)&v18,  (char *)v9,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  2128LL);
  sub_10005CE20( v9,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  2130LL,  v10,  v11,  v12,  v13,  v14);
  uint64_t v15 = v18;
  if (!v18) {
    return 23LL;
  }
  if (qword_10008BEB8 != a4) {
    goto LABEL_6;
  }
  if (sub_1000683F8(a3, a2, "hashstring"))
  {
    sub_1000338C0(&v18, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 2140LL);
    return 46LL;
  }

  uint64_t v16 = v19[2];
  if ((v16[1] - 1) >= 2)
  {
    sub_1000338C0(&v18, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 2146LL);
    sub_10005D71C(&v19, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 2147LL);
    return 46LL;
  }

  sub_100029804( &v17,  *(void *)(v18 + 80),  v16 + 3,  v16[2],  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c",  2154LL);
  sub_10005D71C(&v19, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 2156LL);
  sub_1000338C0(&v18, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 2158LL);
  if (!v17) {
    return 23LL;
  }
  sub_1000338BC(&v18, v17, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 2164LL);
  sub_1000338C0(&v17, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 2165LL);
  uint64_t v15 = v18;
LABEL_6:
  if (*(void *)v15 == a4)
  {
    if ((*(_BYTE *)(v15 + 152) & 1) != 0)
    {
      sub_1000338C0(&v18, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 2176LL);
      uint64_t v15 = v18;
    }

    sub_10005CFB8(a1, v15);
    return 0LL;
  }

  else
  {
    sub_1000338C0(&v18, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/omapi.c", 2171LL);
    return 39LL;
  }

void *sub_1000337E0(int a1)
{
  return sub_10005CDE4((288 * a1));
}

double sub_1000337EC(_OWORD *a1)
{
  if (*(void *)a1 == qword_10008BEA8)
  {
    double result = 0.0;
    a1[16] = 0u;
    a1[17] = 0u;
    a1[14] = 0u;
    a1[15] = 0u;
    a1[12] = 0u;
    a1[13] = 0u;
    a1[10] = 0u;
    a1[11] = 0u;
    a1[8] = 0u;
    a1[9] = 0u;
    a1[6] = 0u;
    a1[7] = 0u;
    a1[4] = 0u;
    a1[5] = 0u;
    a1[2] = 0u;
    a1[3] = 0u;
    *a1 = 0u;
    a1[1] = 0u;
    *((void *)a1 + 4) = qword_10008BEC8;
    qword_10008BEC8 = (uint64_t)a1;
  }

  return result;
}

uint64_t sub_100033850(uint64_t *a1)
{
  uint64_t v1 = qword_10008BEC8;
  if (!qword_10008BEC8) {
    return 1LL;
  }
  uint64_t result = 0LL;
  qword_10008BEC8 = *(void *)(qword_10008BEC8 + 32);
  *a1 = v1;
  return result;
}

uint64_t sub_10003387C(void **a1, uint64_t a2, uint64_t a3)
{
  return sub_10005CE50(a1, (void *)qword_10008BEA8, 0LL, a2, a3);
}

uint64_t sub_1000338A0(void **a1, uint64_t a2, uint64_t a3)
{
  return sub_10005CE50(a1, (void *)qword_10008BE88, 0LL, a2, a3);
}

uint64_t sub_1000338C4(void **a1, uint64_t a2, uint64_t a3)
{
  return sub_10005CE50(a1, (void *)qword_10008BEB8, 0LL, a2, a3);
}

uint64_t sub_1000338E0(void **a1, uint64_t a2, uint64_t a3)
{
  return sub_10005CE50(a1, (void *)qword_10008BEB0, 0LL, a2, a3);
}

uint64_t sub_100033904(void **a1, uint64_t a2, uint64_t a3)
{
  return sub_10005CE50(a1, (void *)qword_10008BE10, 0LL, a2, a3);
}

void *sub_100033928( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = (void *)qword_10008BEC0;
  if (qword_10008BEC0)
  {
    qword_10008BEC0 = *(void *)qword_10008BEC0;
  }

  else
  {
    uint64_t v10 = sub_10005CDE4(0xC0uLL);
    if (!v10) {
      return v10;
    }
  }

  *((_OWORD *)v10 + 10) = 0u;
  *((_OWORD *)v10 + 11) = 0u;
  *((_OWORD *)v10 + 8) = 0u;
  *((_OWORD *)v10 + 9) = 0u;
  *((_OWORD *)v10 + 6) = 0u;
  *((_OWORD *)v10 + 7) = 0u;
  *((_OWORD *)v10 + 4) = 0u;
  *((_OWORD *)v10 + 5) = 0u;
  *((_OWORD *)v10 + 3) = 0u;
  *(_OWORD *)uint64_t v10 = 0u;
  *((_OWORD *)v10 + 1) = 0u;
  *((_OWORD *)v10 + 2) = 0u;
  if (!sub_1000347D8((uint64_t *)v10 + 4, a1, a2, a4, a5, a6, a7, a8))
  {
    sub_1000339CC((uint64_t)v10, a1, a2, v11, v12, v13, v14, v15);
    return 0LL;
  }

  return v10;
}

_DWORD **sub_1000339CC( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12 = *(void *)(a1 + 32);
  uint64_t v11 = (void *)(a1 + 32);
  if (v12) {
    sub_100034894(v11, a2, a3, a4, a5, a6, a7, a8);
  }
  if (*(void *)(a1 + 16)) {
    sub_100034B48((uint64_t *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8);
  }
  if (*(void *)(a1 + 136)) {
    sub_1000235C8(a1 + 136, a2, a3);
  }
  sub_100034EA8((_DWORD **)(a1 + 40), a2, a3, a4, a5, a6, a7, a8);
  sub_100034EA8((_DWORD **)(a1 + 80), a2, a3, v13, v14, v15, v16, v17);
  uint64_t result = sub_100034EA8((_DWORD **)(a1 + 104), a2, a3, v18, v19, v20, v21, v22);
  *(void *)a1 = qword_10008BEC0;
  qword_10008BEC0 = a1;
  return result;
}

double sub_100033A7C()
{
  unsigned int v0 = sub_10005CDE4(0x20uLL);
  if (v0)
  {
    double result = 0.0;
    *unsigned int v0 = 0u;
    v0[1] = 0u;
  }

  return result;
}

void sub_100033AA8( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 8) == 6) {
    sub_10005CFEC((_DWORD **)(a1 + 16), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/salloc.c", 252LL);
  }
  sub_10005CE20((void *)a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_100033B00( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  qword_10008BEF0 = (uint64_t)"agent";
  *(void *)algn_10008BEF8 = sub_100045E00;
  qword_10008BF10 = (uint64_t)sub_100045D58;
  unk_10008BF18 = sub_100045E44;
  qword_10008BF00 = (uint64_t)sub_100045B34;
  unk_10008BF08 = sub_100045E60;
  qword_10008BF20 = (uint64_t)sub_100040920;
  unk_10008BF28 = sub_100045C58;
  uint64_t v8 = dword_10008C558++;
  dword_10008BF78 = v8;
  unk_10008BF7C = 0;
  qword_10008BF30 = (uint64_t)sub_100060BA0;
  unk_10008BF38 = sub_100060B98;
  qword_10008BF40 = (uint64_t)sub_100060BA0;
  unk_10008BF48 = sub_100060B98;
  xmmword_10008BF50 = xmmword_1000827A0;
  *(void *)(qword_10008C570 + 8 * v8) = &qword_10008BEF0;
  if (!sub_100052C88( &qword_10008BF60,  0xBu,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/stables.c",  360LL,  a5,  a6,  a7,  a8)
    || !sub_100052DA4( &qword_10008BF68,  0xBu,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/stables.c",  362LL,  v12,  v13,  v14,  v15))
  {
    sub_100061FB4("Can't allocate agent option hash table.", v9, v10, v11, v12, v13, v14, v15, v39);
  }

  if (off_1000892B0[0])
  {
    uint64_t v16 = off_1000892B0;
    do
    {
      sub_100029214( qword_10008BF68,  (const char *)v16 + 24,  0LL,  (uint64_t)v16,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/stables.c",  367LL,  v14,  v15,  v39);
      sub_100029214( qword_10008BF60,  *v16,  0LL,  (uint64_t)v16,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/stables.c",  370LL,  v17,  v18,  v40);
      uint64_t v19 = v16[4];
      v16 += 4;
    }

    while (v19);
  }

  int v43 = 82;
  sub_100029804( &unk_10008BF70,  qword_10008C1E0,  &v43,  0LL,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/stables.c",  380LL);
  qword_10008BF80 = (uint64_t)"server";
  *(void *)algn_10008BF88 = sub_100043E64;
  qword_10008BFA0 = (uint64_t)sub_10004467C;
  unk_10008BFA8 = sub_100044750;
  qword_10008BFB8 = (uint64_t)sub_100044B30;
  qword_10008BF90 = (uint64_t)sub_10004447C;
  unk_10008BF98 = sub_100045A5C;
  qword_10008BFC8 = (uint64_t)sub_100060B98;
  qword_10008BFD8 = (uint64_t)sub_100060B98;
  xmmword_10008BFE0 = xmmword_1000827B0;
  uint64_t v20 = dword_10008C558++;
  dword_10008C008 = v20;
  unk_10008C00C = 0;
  *(void *)(qword_10008C570 + 8 * v20) = &qword_10008BF80;
  if (!sub_100052C88( &qword_10008BFF0,  0x74u,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/stables.c",  401LL,  v21,  v22,  v23,  v24)
    || !sub_100052DA4( &qword_10008BFF8,  0x74u,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/stables.c",  403LL,  v28,  v29,  v30,  v31))
  {
    sub_100061FB4("Can't allocate server option hash table.", v25, v26, v27, v28, v29, v30, v31, v39);
  }

  if (off_100089370[0])
  {
    int v32 = off_100089370;
    do
    {
      sub_100029214( qword_10008BFF8,  (const char *)v32 + 24,  0LL,  (uint64_t)v32,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/stables.c",  408LL,  v30,  v31,  v39);
      sub_100029214( qword_10008BFF0,  *v32,  0LL,  (uint64_t)v32,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/stables.c",  411LL,  v33,  v34,  v41);
      uint64_t v35 = v32[4];
      v32 += 4;
    }

    while (v35);
  }

  sub_100029214( qword_10008C560,  (const char *)qword_10008BEF0,  0LL,  (uint64_t)&qword_10008BEF0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/stables.c",  422LL,  v30,  v31,  v39);
  sub_100029214( qword_10008C560,  (const char *)qword_10008BF80,  0LL,  (uint64_t)&qword_10008BF80,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/stables.c",  424LL,  v36,  v37,  v42);
  qword_10008C160 = (uint64_t)&qword_10008BF80;
  int v43 = 19;
  return sub_100029804( &qword_10008C148,  qword_10008BFF8,  &v43,  0LL,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/server/stables.c",  431LL);
}

uint64_t sub_100033E60( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = a2;
  if (a1)
  {
    if (*a1)
    {
      sub_10006221C("%s(%d): non-null pointer", a2, a3, a4, a5, a6, a7, a8, a2);
      *a1 = 0LL;
    }

    uint64_t result = (uint64_t)sub_10005CDE4(0x10uLL);
    if (result)
    {
      uint64_t v18 = (_DWORD *)result;
      *(void *)uint64_t result = 0LL;
      *(void *)(result + 8) = 0LL;
      if (*a1) {
        sub_10006221C("%s(%d): non-null pointer", v11, v12, v13, v14, v15, v16, v17, v8);
      }
      *a1 = v18;
      ++*v18;
      return 1LL;
    }
  }

  else
  {
    sub_10006221C("%s(%d): null pointer", a2, a3, a4, a5, a6, a7, a8, a2);
    return 0LL;
  }

  return result;
}

uint64_t sub_100033F18( void *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*a1) {
      sub_10006221C("%s(%d): non-null pointer", (uint64_t)a2, a3, a4, a5, a6, a7, a8, a3);
    }
    *a1 = a2;
    ++*a2;
    return 1LL;
  }

  else
  {
    sub_10006221C("%s(%d): null pointer", (uint64_t)a2, a3, a4, a5, a6, a7, a8, a3);
    return 0LL;
  }

uint64_t sub_100033F88( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && (uint64_t v10 = (void *)*a1) != 0LL)
  {
    *a1 = 0LL;
    int v11 = (*(_DWORD *)v10)--;
    if (v11 > 1) {
      return 1LL;
    }
    if (v11 == 1)
    {
      uint64_t v12 = v10[1];
      if (v12)
      {
        do
        {
          uint64_t v13 = *(void *)(v12 + 8);
          if (*(void *)v12) {
            sub_100040E08( (int **)v12,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/alloc.c",  144LL,  a4,  a5,  a6,  a7,  a8);
          }
          sub_10005CE20( (void *)v12,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/alloc.c",  145LL,  a4,  a5,  a6,  a7,  a8);
          uint64_t v12 = v13;
        }

        while (v13);
      }

      sub_10005CE20(v10, a2, a3, a4, a5, a6, a7, a8);
      return 1LL;
    }

    sub_10006221C("%s(%d): negative refcnt!", a2, a3, a4, a5, a6, a7, a8, a2);
  }

  else
  {
    sub_10006221C("%s(%d): null pointer", a2, a3, a4, a5, a6, a7, a8, a2);
  }

  return 0LL;
}

uint64_t sub_100034064( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = a2;
  if (a1)
  {
    if (*a1)
    {
      sub_10006221C("%s(%d): non-null pointer", a2, a3, a4, a5, a6, a7, a8, a2);
      *a1 = 0LL;
    }

    uint64_t result = (uint64_t)sub_10005CDE4(0x38uLL);
    if (result)
    {
      uint64_t v18 = result;
      *(void *)(result + 48) = 0LL;
      *(_OWORD *)(result + 16) = 0u;
      *(_OWORD *)(result + 32) = 0u;
      *(_OWORD *)uint64_t result = 0u;
      if (*a1) {
        sub_10006221C("%s(%d): non-null pointer", v11, v12, v13, v14, v15, v16, v17, v8);
      }
      *a1 = v18;
      ++*(_DWORD *)(v18 + 8);
      return 1LL;
    }
  }

  else
  {
    sub_10006221C("%s(%d): null pointer", a2, a3, a4, a5, a6, a7, a8, a2);
    return 0LL;
  }

  return result;
}

uint64_t sub_100034128( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*a1) {
      sub_10006221C("%s(%d): non-null pointer", a2, a3, a4, a5, a6, a7, a8, a3);
    }
    *a1 = a2;
    ++*(_DWORD *)(a2 + 8);
    return 1LL;
  }

  else
  {
    sub_10006221C("%s(%d): null pointer", a2, a3, a4, a5, a6, a7, a8, a3);
    return 0LL;
  }

uint64_t sub_100034198( char **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && (uint64_t v10 = *a1) != 0LL)
  {
    *a1 = 0LL;
    int v11 = *((_DWORD *)v10 + 2);
    *((_DWORD *)v10 + 2) = v11 - 1;
    if (v11 > 1) {
      return 1LL;
    }
    if (v11 == 1)
    {
      if (*((void *)v10 + 2)) {
        sub_1000235C8(v10 + 16, a2, a3);
      }
      if (*((void *)v10 + 3)) {
        sub_1000235C8(v10 + 24, a2, a3);
      }
      if (*((void *)v10 + 4)) {
        sub_1000235C8(v10 + 32, a2, a3);
      }
      if (*((void *)v10 + 6)) {
        sub_10003DC78((void **)v10 + 6, a2, a3, a4, a5, a6, a7, a8);
      }
      if (*(void *)v10) {
        sub_100034198(v10, a2, a3);
      }
      sub_10005CE20(v10, a2, a3, a4, a5, a6, a7, a8);
      return 1LL;
    }

    sub_10006221C("%s(%d): negative refcnt!", a2, a3, a4, a5, a6, a7, a8, a2);
  }

  else
  {
    sub_10006221C("%s(%d): null pointer", a2, a3, a4, a5, a6, a7, a8, a2);
  }

  return 0LL;
}

void *sub_1000342A4()
{
  return sub_10005CDE4(0x5C0uLL);
}

void *sub_1000342B4()
{
  return sub_10005CDE4(0x20uLL);
}

void *sub_1000342C4()
{
  return sub_10005CDE4(0x18uLL);
}

void *sub_1000342D8(const char *a1)
{
  int v2 = strlen(a1);
  uint64_t v3 = sub_10005CDE4((v2 + 33));
  uint64_t v4 = v3;
  if (v3)
  {
    memcpy(v3 + 4, a1, v2);
    *uint64_t v4 = v4 + 4;
  }

  return v4;
}

void *sub_100034340()
{
  return sub_10005CDE4(0x90uLL);
}

void *sub_100034350()
{
  return sub_10005CDE4(0x68uLL);
}

void *sub_100034360()
{
  uint64_t result = (void *)qword_10008C030;
  if (qword_10008C030)
  {
    qword_10008C030 = *(void *)(qword_10008C030 + 8);
  }

  else
  {
    uint64_t result = sub_10005CDE4(0x10uLL);
    if (!result) {
      return result;
    }
  }

  void *result = 0LL;
  result[1] = 0LL;
  return result;
}

uint64_t sub_1000343A0(uint64_t result)
{
  *(void *)(result + 8) = qword_10008C030;
  qword_10008C030 = result;
  return result;
}

void *sub_1000343B4( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = qword_10008C020;
  if (qword_10008C020)
  {
    qword_10008C020 = *(void *)(qword_10008C020 + 8);
  }

  else
  {
    uint64_t result = sub_10005CDE4(0x30uLL);
    uint64_t v11 = (uint64_t)result;
    if (!result) {
      return result;
    }
  }

  *(_OWORD *)(v11 + 16) = 0u;
  *(_OWORD *)(v11 + 32) = 0u;
  *(_OWORD *)uint64_t v11 = 0u;
  return (void *)sub_100033F18(a1, (_DWORD *)v11, a2, a3, a5, a6, a7, a8);
}

uint64_t sub_100034438(uint64_t result)
{
  *(void *)(result + 8) = qword_10008C020;
  qword_10008C020 = result;
  return result;
}

void *sub_10003444C( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = qword_10008C018;
  if (qword_10008C018)
  {
    qword_10008C018 = *(void *)(qword_10008C018 + 8);
  }

  else
  {
    uint64_t result = sub_10005CDE4(0x20uLL);
    uint64_t v11 = (uint64_t)result;
    if (!result) {
      return result;
    }
  }

  *(_OWORD *)uint64_t v11 = 0u;
  *(_OWORD *)(v11 + 16) = 0u;
  return (void *)sub_100033F18(a1, (_DWORD *)v11, a2, a3, a5, a6, a7, a8);
}

uint64_t sub_1000344CC(uint64_t result)
{
  *(void *)(result + 8) = qword_10008C018;
  qword_10008C018 = result;
  return result;
}

void *sub_1000344E0(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = sub_10005CDE4(0x18uLL);
  if (result)
  {
    void *result = 0LL;
    result[1] = 0LL;
    result[2] = 0LL;
    return (void *)sub_100033F18(a1, result, a2, a3, v7, v8, v9, v10);
  }

  return result;
}

void *sub_100034540( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = qword_10008C028;
  if (qword_10008C028)
  {
    qword_10008C028 = *(void *)(qword_10008C028 + 16);
  }

  else
  {
    uint64_t result = sub_10005CDE4(0x40uLL);
    uint64_t v11 = (uint64_t)result;
    if (!result) {
      return result;
    }
  }

  *(_OWORD *)(v11 + 32) = 0u;
  *(_OWORD *)(v11 + 48) = 0u;
  *(_OWORD *)uint64_t v11 = 0u;
  *(_OWORD *)(v11 + 16) = 0u;
  return (void *)sub_100033F18(a1, (_DWORD *)v11, a2, a3, a5, a6, a7, a8);
}

_DWORD *sub_1000345C4(void *a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = sub_10005CDE4((a2 + 8));
  if (result)
  {
    *(void *)uint64_t result = 0LL;
    _DWORD *result = 0;
    return (_DWORD *)sub_100033F18(a1, result, a3, a4, v8, v9, v10, v11);
  }

  return result;
}

uint64_t sub_10003462C( _DWORD **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || (uint64_t v9 = *a1) == 0LL)
  {
    sub_10006221C("%s(%d): null pointer", a2, a3, a4, a5, a6, a7, a8, a2);
    return 0LL;
  }

  int v10 = (*v9)--;
  if (v10 == 1)
  {
    sub_10005CE20(v9, a2, a3, a4, a5, a6, a7, a8);
  }

  else if (v10 <= 0)
  {
    sub_10006221C("%s(%d): negative refcnt!", a2, a3, a4, a5, a6, a7, a8, a2);
    return 0LL;
  }

  *a1 = 0LL;
  return 1LL;
}

void *sub_1000346A8(void *a1, char *__s, uint64_t a3, uint64_t a4)
{
  int v8 = strlen(__s);
  uint64_t result = sub_10005CDE4((v8 + 48));
  if (result)
  {
    int v10 = result;
    *((_OWORD *)result + 1) = 0u;
    *((_OWORD *)result + 2) = 0u;
    *(_OWORD *)uint64_t result = 0u;
    *(_DWORD *)uint64_t result = 0;
    strcpy((char *)result + 40, __s);
    return (void *)sub_100033F18(a1, v10, a3, a4, v11, v12, v13, v14);
  }

  return result;
}

uint64_t sub_10003473C( int **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = a2;
  if (a1 && (int v10 = *a1) != 0LL)
  {
    int v12 = *v10 - 1;
    BOOL v11 = *v10 == 1;
    *int v10 = v12;
    if (v11)
    {
      sub_10005CE20(v10, a2, a3, a4, a5, a6, a7, a8);
      if ((**a1 & 0x80000000) == 0) {
        goto LABEL_5;
      }
    }

    else if ((v12 & 0x80000000) == 0)
    {
LABEL_5:
      *a1 = 0LL;
      return 1LL;
    }

    sub_10006221C("%s(%d): negative refcnt!", a2, a3, a4, a5, a6, a7, a8, v8);
  }

  else
  {
    sub_10006221C("%s(%d): null pointer", a2, a3, a4, a5, a6, a7, a8, a2);
  }

  return 0LL;
}

uint64_t sub_1000347D8( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*a1)
    {
      sub_10006221C("%s(%d): non-null pointer", a2, a3, a4, a5, a6, a7, a8, a2);
      *a1 = 0LL;
    }

    size_t v9 = (8 * dword_10008C558 + 16);
    uint64_t result = (uint64_t)sub_10005CDE4(v9);
    *a1 = result;
    if (result)
    {
      bzero((void *)result, v9);
      int v11 = dword_10008C558;
      int v12 = (_DWORD *)*a1;
      uint64_t result = 1LL;
      *int v12 = 1;
      v12[1] = v11;
    }
  }

  else
  {
    sub_10006221C("%s(%d): null pointer", a2, a3, a4, a5, a6, a7, a8, a2);
    return 0LL;
  }

  return result;
}

uint64_t sub_100034894( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && (int v10 = (_DWORD *)*a1) != 0LL)
  {
    *a1 = 0LL;
    int v11 = (*v10)--;
    if (v11 > 1) {
      return 1LL;
    }
    if (v11 == 1)
    {
      int v12 = v10[1];
      if (v12 >= 1)
      {
        for (uint64_t i = 0LL; i < v12; ++i)
        {
          if (*(void *)&v10[2 * i + 4])
          {
            uint64_t v14 = *(void (**)(void))(*(void *)(qword_10008C570 + 8 * i) + 40LL);
            if (v14)
            {
              v14();
              int v12 = v10[1];
            }
          }
        }
      }

      sub_10005CE20(v10, a2, a3, a4, a5, a6, a7, a8);
      return 1LL;
    }

    sub_10006221C("%s(%d): negative refcnt!", a2, a3, a4, a5, a6, a7, a8, a2);
  }

  else
  {
    sub_10006221C("%s(%d): null pointer", a2, a3, a4, a5, a6, a7, a8, a2);
  }

  return 0LL;
}

_OWORD *sub_100034984(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = sub_10005CDE4(0x30uLL);
  if (result)
  {
    result[1] = 0u;
    result[2] = 0u;
    _OWORD *result = 0u;
    return (_OWORD *)sub_100033F18(a1, result, a2, a3, v7, v8, v9, v10);
  }

  return result;
}

uint64_t sub_1000349E8( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = a2;
  if (!a1)
  {
    sub_10006221C("%s(%d): null pointer", a2, a3, a4, a5, a6, a7, a8, a2);
    return 0LL;
  }

  if (*a1)
  {
    sub_10006221C("%s(%d): non-null pointer", a2, a3, a4, a5, a6, a7, a8, a2);
    *a1 = 0LL;
  }

  uint64_t v10 = qword_1000BD308;
  if (qword_1000BD308)
  {
    qword_1000BD308 = *(void *)qword_1000BD308;
  }

  else
  {
    uint64_t result = (uint64_t)sub_10005CDE4(0xE8uLL);
    uint64_t v10 = result;
    if (!result) {
      return result;
    }
  }

  *(void *)(v10 + 224) = 0LL;
  *(_OWORD *)(v10 + 192) = 0u;
  *(_OWORD *)(v10 + 208) = 0u;
  *(_OWORD *)(v10 + 160) = 0u;
  *(_OWORD *)(v10 + 176) = 0u;
  *(_OWORD *)(v10 + 128) = 0u;
  *(_OWORD *)(v10 + 144) = 0u;
  *(_OWORD *)(v10 + 96) = 0u;
  *(_OWORD *)(v10 + 112) = 0u;
  *(_OWORD *)(v10 + 64) = 0u;
  *(_OWORD *)(v10 + 80) = 0u;
  *(_OWORD *)(v10 + 32) = 0u;
  *(_OWORD *)(v10 + 48) = 0u;
  *(_OWORD *)uint64_t v10 = 0u;
  *(_OWORD *)(v10 + 16) = 0u;
  if (*a1) {
    sub_10006221C("%s(%d): non-null pointer", a2, a3, a4, a5, a6, a7, a8, v8);
  }
  *a1 = v10;
  ++*(_DWORD *)(v10 + 8);
  return 1LL;
}

uint64_t sub_100034AD8( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*a1) {
      sub_10006221C("%s(%d): non-null pointer", a2, a3, a4, a5, a6, a7, a8, a3);
    }
    *a1 = a2;
    ++*(_DWORD *)(a2 + 8);
    return 1LL;
  }

  else
  {
    sub_10006221C("%s(%d): null pointer", a2, a3, a4, a5, a6, a7, a8, a3);
    return 0LL;
  }

uint64_t sub_100034B48( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && (uint64_t v8 = *a1) != 0)
  {
    *a1 = 0LL;
    int v9 = *(_DWORD *)(v8 + 8);
    *(_DWORD *)(v8 + 8) = v9 - 1;
    if (v9 > 1) {
      return 1LL;
    }
    if (v9 == 1)
    {
      if (*(void *)(v8 + 160)) {
        sub_100034894((void *)(v8 + 160), a2, a3, a4, a5, a6, a7, a8);
      }
      if (*(void *)(v8 + 104)) {
        sub_1000235C8(v8 + 104, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/alloc.c", 1128LL);
      }
      if (*(void *)(v8 + 152)) {
        sub_1000235C8(v8 + 152, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/alloc.c", 1130LL);
      }
      int v10 = *(_DWORD *)(v8 + 168);
      if (v10 >= 1)
      {
        uint64_t v11 = 0LL;
        unint64_t v12 = 0LL;
        uint64_t v13 = v8 + 176;
        do
        {
          if (*(void *)(v13 + 8 * v12))
          {
            sub_10005CFEC( (_DWORD **)(v13 + v11),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/alloc.c",  1134LL);
            int v10 = *(_DWORD *)(v8 + 168);
          }

          if (v12 > 3) {
            break;
          }
          ++v12;
          v11 += 8LL;
        }

        while ((uint64_t)v12 < v10);
      }

      *(void *)uint64_t v8 = qword_1000BD308;
      qword_1000BD308 = v8;
      return 1LL;
    }

    sub_10006221C("%s(%d): negative refcnt!", a2, a3, a4, a5, a6, a7, a8, a2);
  }

  else
  {
    sub_10006221C("%s(%d): null pointer", a2, a3, a4, a5, a6, a7, a8, a2);
  }

  return 0LL;
}

uint64_t sub_100034C7C( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = a2;
  if (a1)
  {
    if (*a1)
    {
      sub_10006221C("%s(%d): non-null pointer", a2, a3, a4, a5, a6, a7, a8, a2);
      *a1 = 0LL;
    }

    uint64_t result = (uint64_t)sub_10005CDE4(0x30uLL);
    if (result)
    {
      uint64_t v18 = (_DWORD *)result;
      *(_OWORD *)(result + 16) = 0u;
      *(_OWORD *)(result + 32) = 0u;
      *(_OWORD *)uint64_t result = 0u;
      if (*a1) {
        sub_10006221C("%s(%d): non-null pointer", v11, v12, v13, v14, v15, v16, v17, v8);
      }
      *a1 = v18;
      ++*v18;
      return 1LL;
    }
  }

  else
  {
    sub_10006221C("%s(%d): null pointer", a2, a3, a4, a5, a6, a7, a8, a2);
    return 0LL;
  }

  return result;
}

uint64_t sub_100034D3C( void *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*a1) {
      sub_10006221C("%s(%d): non-null pointer", (uint64_t)a2, a3, a4, a5, a6, a7, a8, a3);
    }
    *a1 = a2;
    ++*a2;
    return 1LL;
  }

  else
  {
    sub_10006221C("%s(%d): null pointer", (uint64_t)a2, a3, a4, a5, a6, a7, a8, a3);
    return 0LL;
  }

uint64_t sub_100034DAC( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = a2;
  if (!a1)
  {
    sub_10006221C("%s(%d): null pointer", a2, a3, a4, a5, a6, a7, a8, a2);
    return 0LL;
  }

  if (*a1)
  {
    sub_10006221C("%s(%d): non-null pointer", a2, a3, a4, a5, a6, a7, a8, a2);
    return 0LL;
  }

  uint64_t result = (uint64_t)sub_10005CDE4(0x18uLL);
  if (result)
  {
    uint64_t v18 = (_DWORD *)result;
    *(void *)uint64_t result = 0LL;
    *(void *)(result + 8) = 0LL;
    *(void *)(result + 16) = 0LL;
    if (*a1) {
      sub_10006221C("%s(%d): non-null pointer", v11, v12, v13, v14, v15, v16, v17, v8);
    }
    *a1 = v18;
    ++*v18;
    return 1LL;
  }

  return result;
}

double sub_100034E60( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = *(_DWORD **)a2;
  if (v10) {
    sub_100033F18((void *)a1, v10, a3, a4, a5, a6, a7, a8);
  }
  else {
    *(void *)a1 = 0LL;
  }
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  double result = *(double *)(a2 + 16);
  *(double *)(a1 + 16) = result;
  return result;
}

_DWORD **sub_100034EA8( _DWORD **result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = result;
  if (*result) {
    double result = (_DWORD **)sub_10003462C(result, a2, a3, a4, a5, a6, a7, a8);
  }
  *char v8 = 0LL;
  v8[1] = 0LL;
  v8[2] = 0LL;
  return result;
}

uint64_t sub_100034EDC(uint64_t result, unsigned int a2)
{
  if (*(_DWORD *)(result + 16) > a2)
  {
    *(_DWORD *)(result + 16) = a2;
    *(_DWORD *)(result + 20) = 0;
  }

  return result;
}

uint64_t sub_100034EF4(uint64_t a1)
{
  uint64_t v2 = open(v20, 2);
  if ((v2 & 0x80000000) != 0)
  {
    int v3 = 1;
    do
    {
      if (*__error() != 16)
      {
        if (v3 == 1) {
          sub_100061FB4("No bpf devices.%s%s%s", v4, v5, v6, v7, v8, v9, v10, (char)"   Please read the README");
        }
        sub_100061FB4("Can't find free bpf: %m", v4, v5, v6, v7, v8, v9, v10, 0);
      }

      __sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", v3);
      uint64_t v11 = open(v20, 2);
      ++v3;
    }

    while ((v11 & 0x80000000) != 0);
    uint64_t v2 = v11;
  }

  if (ioctl(v2, 0x8020426CuLL, *(void *)(a1 + 192)) < 0) {
    sub_100061FB4("Can't attach interface %s to bpf device %s: %m", v12, v13, v14, v15, v16, v17, v18, a1 - 124);
  }
  sub_100035074((const char *)(a1 + 132), (_BYTE *)(a1 + 48));
  return v2;
}

void sub_100035074(const char *a1, _BYTE *a2)
{
  if (getifaddrs(&v16)) {
    sub_100061FB4("Error getting interface information; %m", v4, v5, v6, v7, v8, v9, v10, v15);
  }
  uint64_t v11 = v16;
  if (!v16) {
LABEL_12:
  }
    sub_100061FB4("No interface called '%s'", v4, v5, v6, v7, v8, v9, v10, (char)a1);
  while (1)
  {
    ifa_addr = v11->ifa_addr;
    if (ifa_addr->sa_family == 18) {
      break;
    }
    ifa_addr = 0LL;
LABEL_10:
    uint64_t v11 = v11->ifa_next;
    if (!v11) {
      goto LABEL_11;
    }
  }

  if (strcmp(v11->ifa_name, a1)) {
    ifa_addr = 0LL;
  }
  if (!ifa_addr) {
    goto LABEL_10;
  }
LABEL_11:
  if (!ifa_addr) {
    goto LABEL_12;
  }
  int v13 = ifa_addr->sa_data[2];
  if ((v13 - 7) >= 4)
  {
    if (v13 == 15)
    {
      *a2 = ifa_addr->sa_data[4] + 1;
      char v14 = 8;
    }

    else
    {
      if (v13 != 6) {
        sub_100061FB4("Unsupported device type %d for %s", v4, v5, v6, v7, v8, v9, v10, ifa_addr->sa_data[2]);
      }
      *a2 = ifa_addr->sa_data[4] + 1;
      char v14 = 1;
    }
  }

  else
  {
    *a2 = ifa_addr->sa_data[4] + 1;
    char v14 = 6;
  }

  a2[1] = v14;
  memcpy(a2 + 2, &ifa_addr->sa_data[ifa_addr->sa_data[3] + 6], ifa_addr->sa_data[4]);
  freeifaddrs(v16);
}

uint64_t sub_1000351AC(uint64_t result)
{
  *(_DWORD *)(result + 156) = *(_DWORD *)(result + 152);
  if (!dword_10008C100)
  {
    char v1 = result - 124;
    sub_1000501FC( *(unsigned __int8 *)(result + 49),  *(unsigned __int8 *)(result + 48) - 1,  (unsigned __int8 *)(result + 50));
    return sub_1000622D4("Sending on   BPF/%s/%s%s%s", v2, v3, v4, v5, v6, v7, v8, v1);
  }

  return result;
}

uint64_t sub_100035238(uint64_t result)
{
  *(_DWORD *)(result + 156) = -1;
  if (!dword_10008C100)
  {
    char v1 = result - 124;
    sub_1000501FC( *(unsigned __int8 *)(result + 49),  *(unsigned __int8 *)(result + 48) - 1,  (unsigned __int8 *)(result + 50));
    return sub_1000622D4("Disabling output on BPF/%s/%s%s%s", v2, v3, v4, v5, v6, v7, v8, v1);
  }

  return result;
}

uint64_t sub_1000352C4(uint64_t a1)
{
  int v52 = 1;
  int v2 = sub_100034EF4(a1);
  *(_DWORD *)(a1 + 152) = v2;
  if (ioctl(v2, 0x40044271uLL) < 0) {
    sub_100061FB4("Can't get BPF version: %m", v3, v4, v5, v6, v7, v8, v9, (char)v51);
  }
  if (v51[0] != 1 || v51[1] == 0) {
    sub_100061FB4("BPF version mismatch - recompile DHCP!", v3, v4, v5, v6, v7, v8, v9, (char)v51);
  }
  int v11 = ioctl(*(_DWORD *)(a1 + 152), 0x80044270uLL);
  if (v11 < 0) {
    sub_100061FB4("Can't set immediate mode on bpf device: %m", v12, v13, v14, v15, v16, v17, v18, (char)&v52);
  }
  if (ioctl(*(_DWORD *)(a1 + 152), 0x40044266uLL) < 0) {
    sub_100061FB4("Can't get bpf buffer length: %m", v19, v20, v21, v22, v23, v24, v25, a1 - 88);
  }
  uint64_t v26 = sub_10005CDE4(*(unsigned int *)(a1 + 168));
  *(void *)(a1 + 16__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = v26;
  if (!v26) {
    sub_100061FB4( "Can't allocate %ld bytes for bpf input buffer.",  v27,  v28,  v29,  v30,  v31,  v32,  v33,  *(_DWORD *)(a1 + 168));
  }
  *(void *)(a1 + 176) = 0LL;
  *(void *)(a1 + 184) = 0LL;
  int v49 = dword_100089B08;
  uint64_t v50 = &unk_100089AB0;
  dword_100089AF4 = bswap32((unsigned __int16)word_10008C0F4) >> 16;
  uint64_t result = ioctl(*(_DWORD *)(a1 + 152), 0x80104267uLL);
  if ((result & 0x80000000) != 0) {
    sub_100061FB4("Can't install packet filter program: %m", v35, v36, v37, v38, v39, v40, v41, (char)&v49);
  }
  if (!dword_10008C100)
  {
    sub_1000501FC(*(unsigned __int8 *)(a1 + 49), *(unsigned __int8 *)(a1 + 48) - 1, (unsigned __int8 *)(a1 + 50));
    return sub_1000622D4("Listening on BPF/%s/%s%s%s", v42, v43, v44, v45, v46, v47, v48, a1 - 124);
  }

  return result;
}

uint64_t sub_10003547C(uint64_t a1)
{
  uint64_t result = close(*(_DWORD *)(a1 + 152));
  *(_DWORD *)(a1 + 152) = -1;
  if (!dword_10008C100)
  {
    sub_1000501FC(*(unsigned __int8 *)(a1 + 49), *(unsigned __int8 *)(a1 + 48) - 1, (unsigned __int8 *)(a1 + 50));
    return sub_1000622D4("Disabling input on BPF/%s/%s%s%s", v3, v4, v5, v6, v7, v8, v9, a1 - 124);
  }

  return result;
}

uint64_t sub_100035510(uint64_t a1, int a2, void *a3, size_t a4, int a5, uint64_t a6, uint64_t a7)
{
  uint64_t v23 = 0LL;
  sub_100046788(a1, (uint64_t)v30, (_DWORD *)&v23 + 1, a7);
  sub_10004678C(a1, (uint64_t)v29, (uint64_t)&v23, a5, *(_DWORD *)(a6 + 4), *(_WORD *)(a6 + 2), (uint64_t)a3, a4);
  v24.iov_base = v30;
  v24.iov_len = HIDWORD(v23);
  uint64_t v25 = v29;
  uint64_t v26 = v23;
  uint64_t v27 = a3;
  size_t v28 = a4;
  int v21 = writev(*(_DWORD *)(a1 + 156), &v24, 3);
  if (v21 < 0) {
    sub_10006221C("send_packet: %m", v14, v15, v16, v17, v18, v19, v20, v23);
  }
  return v21;
}

uint64_t sub_100035674(uint64_t a1, void *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v10 = *(void *)(a1 + 176);
  while (1)
  {
    unint64_t v11 = *(void *)(a1 + 184);
    unint64_t v12 = v10;
    unint64_t v13 = v11;
    if (v10 == v11) {
      break;
    }
LABEL_5:
    if (v13 - v12 < 0x14) {
      goto LABEL_18;
    }
    uint64_t v16 = *(void *)(a1 + 160);
    unint64_t v17 = *(unsigned int *)(v16 + v12 + 8);
    unint64_t v18 = v12 + *(unsigned __int16 *)(v16 + v12 + 16);
    if (v18 + v17 > v13) {
      goto LABEL_18;
    }
    if ((_DWORD)v17 == *(_DWORD *)(v16 + v12 + 12))
    {
      *(void *)(a1 + 176) = v18;
      unsigned int v19 = sub_100046920(a1, v16, v18, a5);
      if ((v19 & 0x80000000) == 0)
      {
        uint64_t v22 = *(void *)(a1 + 176) + v19;
        *(void *)(a1 + 176) = v22;
        uint64_t v23 = v17 - v19;
        unsigned int v24 = sub_100046924(a1, *(void *)(a1 + 160), v22, a4, v23, &__n, v20, v21);
        uint64_t v25 = *(void *)(a1 + 176);
        if ((v24 & 0x80000000) != 0)
        {
          uint64_t v28 = v25 + v23;
        }

        else
        {
          uint64_t v26 = v25 + v24;
          *(void *)(a1 + 176) = v26;
          unint64_t v17 = v23 - v24;
          if (v17 <= a3)
          {
            uint64_t v31 = __n;
            memcpy(a2, (const void *)(*(void *)(a1 + 160) + v26), __n);
            *(void *)(a1 + 176) = (v17 + *(void *)(a1 + 176) + 3) & 0xFFFFFFFFFFFFFFFCLL;
            return v31;
          }

LABEL_14:
          uint64_t v28 = v17 + v26;
        }

        uint64_t v27 = v28 + 3;
        goto LABEL_17;
      }

      uint64_t v26 = *(void *)(a1 + 176);
      goto LABEL_14;
    }

    uint64_t v27 = v18 + v17 + 3;
LABEL_17:
    unint64_t v13 = v27 & 0xFFFFFFFFFFFFFFFCLL;
LABEL_18:
    *(void *)(a1 + 176) = v13;
    BOOL v29 = v10 == v11;
    unint64_t v10 = v13;
    if (v29) {
      return 0LL;
    }
  }

  int v14 = read(*(_DWORD *)(a1 + 152), *(void **)(a1 + 160), *(unsigned int *)(a1 + 168));
  int v15 = v14;
  if (v14 > 0)
  {
    unint64_t v12 = 0LL;
    unint64_t v13 = (v14 + 3LL) & 0x1FFFFFFFCLL;
    *(void *)(a1 + 176) = 0LL;
    *(void *)(a1 + 184) = v13;
    goto LABEL_5;
  }

  if (*__error() == 5) {
    sub_10003A854(a1);
  }
  return v15;
}

  sub_100046D6C((uint64_t)a1, v16, v7, v8, v9, v10, v11, v12, v18);
  sub_100046C4C(a1, 0);
  return 0LL;
}

  if (result < a4)
  {
    *(_BYTE *)(a3 + result) = 0;
    return result;
  }

  return 0xFFFFFFFFLL;
}

    ++v7;
  }

  while ((unint64_t)v10 < a1 + 120);
  while (1)
  {
    unint64_t v12 = *v7;
    unint64_t v13 = v12 > 0x20;
    int v14 = (1LL << v12) & 0x100000601LL;
    if (!v13 && v14 != 0) {
      break;
    }
    ++v7;
  }

  *uint64_t v7 = 0;
  *unint64_t v10 = 0LL;
LABEL_22:
  uint64_t v16 = fopen("/etc/resolv.conf", "r");
  if (!v16) {
    goto LABEL_164;
  }
  unint64_t v17 = v16;
  unint64_t v18 = 0LL;
  unsigned int v19 = 0LL;
  uint64_t v20 = (char *)&v75.tv_sec + 6;
  uint64_t v21 = (char *)(a1 + 128);
  while (2)
  {
    if (LOBYTE(v75.tv_sec) == 35 || LOBYTE(v75.tv_sec) == 59) {
      goto LABEL_125;
    }
    if (LODWORD(v75.tv_sec) == 1634561892 && WORD2(v75.tv_sec) == 28265)
    {
      uint64_t v26 = BYTE6(v75.tv_sec);
      if (BYTE6(v75.tv_sec) == 32 || BYTE6(v75.tv_sec) == 9)
      {
        if (v6) {
          goto LABEL_125;
        }
        for (uint64_t i = v20; ; ++i)
        {
          if (v26 > 9u)
          {
            if (v26 != 32)
            {
              if (v26 == 10) {
                goto LABEL_125;
              }
              goto LABEL_135;
            }
          }

          else if (v26 != 9)
          {
            if (!v26) {
              goto LABEL_125;
            }
LABEL_135:
            uint64_t v58 = strncpy(v21, i, 0xFFuLL);
            *(_BYTE *)(a1 + 383) = 0;
            char v59 = strpbrk(v58, " \t\n");
            uint64_t v8 = 0LL;
            if (v59) {
              *char v59 = 0;
            }
            goto LABEL_125;
          }

          BOOL v29 = i[1];
          uint64_t v26 = v29;
        }
      }
    }

    uint64_t v23 = LODWORD(v75.tv_sec) == 1918985587 && WORD2(v75.tv_sec) == 26723;
    if (!v23 || (uint64_t v30 = BYTE6(v75.tv_sec), BYTE6(v75.tv_sec) != 32) && BYTE6(v75.tv_sec) != 9)
    {
      if (v75.tv_sec == 0x76726573656D616ELL && LOWORD(v75.tv_usec) == 29285)
      {
        uint64_t v33 = BYTE2(v75.tv_usec);
        uint64_t v34 = BYTE2(v75.tv_usec) == 9 || BYTE2(v75.tv_usec) == 32;
        if (v34 && (int)v19 <= 2)
        {
          for (uint64_t j = (char *)&v75.tv_usec + 2; ; ++j)
          {
            if (v33 > 9)
            {
              if (v33 != 32)
              {
                if (v33 == 10) {
                  goto LABEL_125;
                }
                goto LABEL_130;
              }
            }

            else if (v33 != 9)
            {
              if (!v33) {
                goto LABEL_125;
              }
LABEL_130:
              if (inet_aton(j, &v74))
              {
                int v57 = a1 + 16LL * (int)v19;
                *(in_addr *)(v57 + 24) = v74;
                *(_BYTE *)(v57 + 21) = 2;
                *(_WORD *)(v57 + 22) = 13568;
                unsigned int v19 = (v19 + 1);
              }

              goto LABEL_125;
            }

            uint64_t v36 = *((unsigned __int8 *)j + 1);
            uint64_t v33 = v36;
          }
        }
      }

      if (v75.tv_sec != 0x7473696C74726F73LL
        || (LOBYTE(v37) = v75.tv_usec, LOBYTE(v75.tv_usec) != 32) && LOBYTE(v75.tv_usec) != 9)
      {
        uint64_t v25 = LODWORD(v75.tv_sec) == 1769238639 && *(_DWORD *)((char *)&v75.tv_sec + 3) == 1936617321;
        if (v25 && (HIBYTE(v75.tv_sec) == 32 || HIBYTE(v75.tv_sec) == 9)) {
          sub_10006CC88(a1, (char *)&v75.tv_sec + 7, "conf");
        }
        goto LABEL_125;
      }

      p_tv_usec = &v75.tv_usec;
      uint64_t v72 = v6;
      while (1)
      {
        uint64_t v73 = v18;
        uint64_t v39 = (const char *)p_tv_usec;
        while (v37 <= 0x3Bu)
        {
          if (((1LL << v37) & 0x100000200LL) == 0)
          {
            uint64_t v41 = v21;
            uint64_t v42 = v8;
            uint64_t v43 = v20;
            uint64_t v44 = v19;
            p_tv_usec = (__darwin_suseconds_t *)v39;
            if (((1LL << v37) & 0x800000000000401LL) != 0)
            {
              unint64_t v18 = v73;
              uint64_t v20 = v43;
              uint64_t v8 = v42;
              uint64_t v21 = v41;
              uint64_t v6 = v72;
              goto LABEL_125;
            }

            goto LABEL_92;
          }

          uint64_t v40 = *++v39;
          LOBYTE(v37) = v40;
        }

        uint64_t v41 = v21;
        uint64_t v42 = v8;
        uint64_t v43 = v20;
        uint64_t v44 = v19;
        p_tv_usec = (__darwin_suseconds_t *)v39;
        do
        {
LABEL_92:
          uint64_t v45 = memchr(&unk_100083258, (char)v37, 3uLL);
          if ((v37 & 0x80) != 0) {
            break;
          }
          if (v45) {
            break;
          }
          uint64_t v46 = *((unsigned __int8 *)p_tv_usec + 1);
          p_tv_usec = (__darwin_suseconds_t *)((char *)p_tv_usec + 1);
          LOBYTE(v37) = v46;
        }

        while (v46);
        *(_BYTE *)p_tv_usec = 0;
        if (inet_aton(v39, &v74))
        {
          uint64_t v47 = (in_addr *)(a1 + 8LL * (int)v73);
          in_addr_t s_addr = v74.s_addr;
          v47[99].in_addr_t s_addr = v74.s_addr;
          if (memchr(&unk_100083258, (char)v37, 3uLL))
          {
            p_in_addr_t s_addr = &v47[99].s_addr;
            *(_BYTE *)p_tv_usec = v37;
            p_tv_usec = (__darwin_suseconds_t *)((char *)p_tv_usec + 1);
            uint64_t v50 = (const char *)p_tv_usec;
            unsigned int v19 = v44;
            uint64_t v20 = v43;
            uint64_t v8 = v42;
            uint64_t v21 = v41;
            uint64_t v6 = v72;
            while (1)
            {
              uint64_t v51 = *(char *)p_tv_usec;
              uint64_t v37 = *(unsigned __int8 *)p_tv_usec;
              if (!*(_BYTE *)p_tv_usec
                || v37 == 59
                || (v51 & 0x80) != 0
                || (_DefaultRuneLocale.__runetype[v51] & 0x4000) != 0)
              {
                break;
              }

              p_tv_usec = (__darwin_suseconds_t *)((char *)p_tv_usec + 1);
            }

            *(_BYTE *)p_tv_usec = 0;
            if (inet_aton(v50, &v74))
            {
              int v52 = v74.s_addr;
            }

            else
            {
              uint64_t v55 = bswap32(*p_s_addr);
              else {
                uint64_t v56 = 0xFFFFFF;
              }
              if (v55 < 0) {
                int v52 = v56;
              }
              else {
                int v52 = 255;
              }
            }
          }

          else
          {
            uint64_t v53 = bswap32(s_addr);
            else {
              uint64_t v54 = 0xFFFFFF;
            }
            if (v53 < 0) {
              int v52 = v54;
            }
            else {
              int v52 = 255;
            }
            unsigned int v19 = v44;
            uint64_t v20 = v43;
            uint64_t v8 = v42;
            uint64_t v21 = v41;
            uint64_t v6 = v72;
          }

          *(_DWORD *)(a1 + 8LL * (int)v73 + 40__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = v52;
          unint64_t v18 = (v73 + 1);
        }

        else
        {
          unint64_t v18 = v73;
          unsigned int v19 = v44;
          uint64_t v20 = v43;
          uint64_t v8 = v42;
          uint64_t v21 = v41;
          uint64_t v6 = v72;
        }

        *(_BYTE *)p_tv_usec = v37;
      }
    }

    if (v6) {
      goto LABEL_125;
    }
    uint64_t v31 = v20;
    while (2)
    {
      if (v30 <= 9u)
      {
        if (v30 != 9)
        {
          if (!v30) {
            goto LABEL_125;
          }
          goto LABEL_140;
        }

        goto LABEL_68;
      }

      if (v30 == 32)
      {
LABEL_68:
        uint64_t v32 = *++v31;
        uint64_t v30 = v32;
        continue;
      }

      break;
    }

    if (v30 == 10) {
      goto LABEL_125;
    }
LABEL_140:
    uint64_t v60 = strncpy(v21, v31, 0xFFuLL);
    *(_BYTE *)(a1 + 383) = 0;
    uint64_t v61 = strchr(v60, 10);
    if (v61) {
      *uint64_t v61 = 0;
    }
    *(void *)(a1 + 72) = v21;
    uint64_t v62 = *(unsigned __int8 *)(a1 + 128);
    if (*(_BYTE *)(a1 + 128))
    {
      uint64_t v63 = 0;
      uint64_t v64 = (char **)(a1 + 80);
      uint64_t v65 = v21;
      do
      {
        if (v62 == 32 || v62 == 9)
        {
          *uint64_t v65 = 0;
          uint64_t v63 = 1;
        }

        else if (v63)
        {
          uint64_t v63 = 0;
          *v64++ = v65;
        }

        uint64_t v66 = *++v65;
        uint64_t v62 = v66;
        if (v66) {
          int v67 = (unint64_t)v64 >= a1 + 120;
        }
        else {
          int v67 = 1;
        }
      }

      while (!v67);
    }

    else
    {
      uint64_t v65 = v21;
      uint64_t v64 = (char **)(a1 + 80);
    }

    int v68 = (unsigned __int8 *)(v65 + 1);
    while (v62 > 0x20 || ((1LL << v62) & 0x100000201LL) == 0)
    {
      uint64_t v69 = *v68++;
      uint64_t v62 = v69;
    }

    *(v68 - 1) = 0;
    *uint64_t v64 = 0LL;
    uint64_t v8 = 1LL;
LABEL_125:
    break;
  }

uint64_t sub_100035828()
{
  return 1LL;
}

uint64_t sub_100035830()
{
  uint64_t v10 = 0LL;
  uint64_t result = sub_10003BC78(&v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/bpf.c", 539LL);
  if ((_DWORD)result)
  {
    sub_10005244C(v10);
    unsigned int v1 = sub_100060E24(v10, (uint64_t)sub_10003B9F0, 0LL, (uint64_t)sub_100052B50, 0LL, 0LL);
    if (v1)
    {
      char v2 = v10 - 124;
      sub_100067900(v1);
      sub_100061FB4("Can't register I/O handle for %s: %s", v3, v4, v5, v6, v7, v8, v9, v2);
    }

    return sub_1000235C8(&v10, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/bpf.c", 547LL);
  }

  return result;
}

uint64_t sub_1000358CC(void **a1, uint64_t a2, uint64_t a3)
{
  return sub_10005CE50(a1, (void *)qword_10008C068, 0LL, a2, a3);
}

uint64_t sub_1000358E4(void **a1, uint64_t a2, uint64_t a3)
{
  return sub_10005CE50(a1, (void *)qword_10008C060, 0LL, a2, a3);
}

uint64_t sub_1000358FC(void **a1, uint64_t a2, uint64_t a3)
{
  return sub_10005CE50(a1, (void *)qword_10008C050, 0LL, a2, a3);
}

uint64_t sub_100035914(void **a1, uint64_t a2, uint64_t a3)
{
  return sub_10005CE50(a1, (void *)qword_10008C048, 0LL, a2, a3);
}

uint64_t sub_10003592C()
{
  unsigned int v0 = sub_100067CD0( &qword_10008C048,  (uint64_t)"control",  (uint64_t)sub_100035BB0,  (uint64_t)sub_100035C98,  (uint64_t)sub_100035D4C,  (uint64_t)sub_100035D6C,  (uint64_t)sub_100035DBC,  (uint64_t)sub_100035E58,  (uint64_t)sub_100035F24,  (uint64_t)sub_100035F2C,  0LL,  0LL,  0LL,  40LL,  0LL,  2);
  if (v0)
  {
    char v1 = sub_100067900(v0);
    sub_100061FB4("Can't register control object type: %s", v2, v3, v4, v5, v6, v7, v8, v1);
  }

  unsigned int v9 = sub_10005CE50( (void **)&qword_10008C040,  (void *)qword_10008C048,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/comapi.c",  77LL);
  if (v9)
  {
    char v10 = sub_100067900(v9);
    sub_100061FB4("Can't make initial control object: %s", v11, v12, v13, v14, v15, v16, v17, v10);
  }

  *(_DWORD *)(qword_10008C040 + 32) = 0;
  unsigned int v18 = sub_100067CD0( &qword_10008C050,  (uint64_t)"group",  (uint64_t)sub_100035F34,  (uint64_t)sub_100036110,  (uint64_t)sub_1000361C4,  (uint64_t)sub_1000362DC,  (uint64_t)sub_10003641C,  (uint64_t)sub_1000364B4,  (uint64_t)sub_100036674,  (uint64_t)sub_100036708,  0LL,  0LL,  0LL,  64LL,  0LL,  2);
  if (v18)
  {
    char v19 = sub_100067900(v18);
    sub_100061FB4("Can't register group object type: %s", v20, v21, v22, v23, v24, v25, v26, v19);
  }

  unsigned int v27 = sub_100067CD0( &qword_10008C068,  (uint64_t)"subnet",  (uint64_t)sub_100036788,  (uint64_t)sub_1000367F4,  (uint64_t)sub_100036840,  (uint64_t)sub_10003685C,  (uint64_t)sub_1000368AC,  (uint64_t)sub_1000368F4,  (uint64_t)sub_100036908,  (uint64_t)sub_100036910,  0LL,  0LL,  0LL,  136LL,  0LL,  2);
  if (v27)
  {
    char v28 = sub_100067900(v27);
    sub_100061FB4("Can't register subnet object type: %s", v29, v30, v31, v32, v33, v34, v35, v28);
  }

  unsigned int v36 = sub_100067CD0( &qword_10008C060,  (uint64_t)"shared-network",  (uint64_t)sub_100036918,  (uint64_t)sub_100036984,  (uint64_t)sub_1000369D0,  (uint64_t)sub_1000369EC,  (uint64_t)sub_100036A3C,  (uint64_t)sub_100036A84,  (uint64_t)sub_100036A98,  (uint64_t)sub_100036AA0,  0LL,  0LL,  0LL,  112LL,  0LL,  2);
  if (v36)
  {
    char v37 = sub_100067900(v36);
    sub_100061FB4("Can't register shared network object type: %s", v38, v39, v40, v41, v42, v43, v44, v37);
  }

  return sub_10003A18C();
}

uint64_t sub_100035BB0(uint64_t a1, int a2, uint64_t a3, _DWORD *a4)
{
  if (*(void *)a1 != qword_10008C048) {
    return 39LL;
  }
  if (sub_100068648(a3, "state"))
  {
    uint64_t v8 = *(void *)(a1 + 24);
    if (v8)
    {
      unsigned int v9 = *(uint64_t (**)(void))(*(void *)v8 + 16LL);
      uint64_t v4 = 23LL;
      if (v9)
      {
        int v10 = v9();
        if (v10) {
          unsigned int v11 = 23;
        }
        else {
          unsigned int v11 = 0;
        }
        if (v10 == 42) {
          return 42LL;
        }
        else {
          return v11;
        }
      }
    }

    else
    {
      return 23LL;
    }
  }

  else
  {
    uint64_t v4 = sub_100068C24(&v12, a4);
    if (!(_DWORD)v4)
    {
      uint64_t v4 = sub_10001852C(*(unsigned int *)(a1 + 32), v12);
      if (!(_DWORD)v4) {
        *(_DWORD *)(a1 + 32) = a4[2];
      }
    }
  }

  return v4;
}

uint64_t sub_100035C98(uint64_t a1, int a2, _DWORD *a3, int ***a4)
{
  if (*(void *)a1 != qword_10008C048) {
    return 39LL;
  }
  if (!sub_100068648((uint64_t)a3, "state")) {
    return sub_100068920( a4,  a3,  (const char *)*(unsigned int *)(a1 + 32),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/comapi.c",  489LL);
  }
  uint64_t v8 = *(void *)(a1 + 24);
  if (!v8) {
    return 23LL;
  }
  unsigned int v9 = *(uint64_t (**)(void))(*(void *)v8 + 24LL);
  if (!v9) {
    return 23LL;
  }
  uint64_t result = v9();
  if ((_DWORD)result) {
    return 23LL;
  }
  return result;
}

uint64_t sub_100035D4C(void *a1)
{
  if (*a1 == qword_10008C048) {
    return 6LL;
  }
  else {
    return 39LL;
  }
}

uint64_t sub_100035D6C(void *a1)
{
  if (*a1 != qword_10008C048) {
    return 39LL;
  }
  uint64_t v2 = a1[3];
  if (!v2) {
    return 23LL;
  }
  if (!*(void *)(*(void *)v2 + 24LL)) {
    return 23LL;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 40LL))(v2);
  if ((_DWORD)result) {
    return 23LL;
  }
  return result;
}

uint64_t sub_100035DBC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)a3 != qword_10008C048) {
    return 39LL;
  }
  uint64_t result = sub_10005F114(a1, "state");
  if (!(_DWORD)result)
  {
    uint64_t result = sub_10005EF64(a1, 4u);
    if (!(_DWORD)result)
    {
      uint64_t result = sub_10005EF64(a1, *(_DWORD *)(a3 + 32));
      if (!(_DWORD)result)
      {
        uint64_t v7 = *(void *)(a3 + 24);
        if (v7)
        {
          uint64_t v8 = *(void (**)(uint64_t, uint64_t))(*(void *)v7 + 48LL);
          if (v8) {
            v8(a1, a2);
          }
        }

        return 0LL;
      }
    }
  }

  return result;
}

uint64_t sub_100035E58(void *a1, int a2, uint64_t a3)
{
  uint64_t v6 = 0LL;
  if (a3 && !sub_1000683F8(a3, a2, "handle"))
  {
    uint64_t v4 = sub_100062F48(a1, v6[2]);
    sub_10005D71C(&v6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/comapi.c", 576LL);
    if ((_DWORD)v4) {
      return v4;
    }
    if (*(void *)*a1 != qword_10008C048)
    {
      sub_10005CFEC((_DWORD **)a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/comapi.c", 582LL);
      return 39LL;
    }
  }

  sub_10005CFB8(a1, qword_10008C040);
  return 0LL;
}

uint64_t sub_100035F24()
{
  return 6LL;
}

uint64_t sub_100035F2C()
{
  return 6LL;
}

uint64_t sub_100035F34(void *a1, int a2, uint64_t a3, _DWORD *a4)
{
  if (*a1 != qword_10008C050) {
    return 39LL;
  }
  if (!sub_100068648(a3, "name"))
  {
    if (a1[6]) {
      return 18LL;
    }
    uint64_t v17 = sub_10005CDE4((a4[2] + 1));
    a1[6] = v17;
    if (v17)
    {
      memcpy(v17, a4 + 3, a4[2]);
      uint64_t v4 = 0LL;
      *(_BYTE *)(a1[6] + a4[2]) = 0;
      return v4;
    }

    return 1LL;
  }

  if (sub_100068648(a3, "statements"))
  {
    uint64_t v13 = a1[3];
    if (!v13) {
      return 23LL;
    }
    uint64_t v14 = *(uint64_t (**)(void))(*(void *)v13 + 16LL);
    uint64_t v4 = 23LL;
    if (v14)
    {
      int v15 = v14();
      if (v15) {
        unsigned int v16 = 23;
      }
      else {
        unsigned int v16 = 0;
      }
      if (v15 == 42) {
        return 42LL;
      }
      else {
        return v16;
      }
    }

    return v4;
  }

  uint64_t v20 = a1[5];
  char v19 = a1 + 5;
  uint64_t v18 = v20;
  if (!v20)
  {
    if (sub_1000406C0( v19,  qword_10008C140,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/comapi.c",  170LL,  v9,  v10,  v11,  v12)) {
      goto LABEL_23;
    }
    return 1LL;
  }

  if (*(void *)(v18 + 48)) {
    return 18LL;
  }
LABEL_23:
  int v29 = 0;
  uint64_t v30 = 0LL;
  uint64_t v4 = sub_100036AA8(&v30, -1, (uint64_t)(a4 + 3), a4[2], (uint64_t)"network client", 0);
  if (!(_DWORD)v4 && v30)
  {
    BOOL v21 = sub_100049E64((void **)(*v19 + 48), v30, &v29, 0LL);
    sub_100036BD4((uint64_t *)&v30, v22, v23, v24, v25, v26, v27, v28);
    if (v21) {
      return 0LL;
    }
    else {
      return 45LL;
    }
  }

  return v4;
}

uint64_t sub_100036110(uint64_t a1, int a2, _DWORD *a3, int ***a4)
{
  if (*(void *)a1 != qword_10008C050) {
    return 39LL;
  }
  if (!sub_100068648((uint64_t)a3, "name")) {
    return sub_100068B64( a4,  a3,  *(const char **)(a1 + 48),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/comapi.c",  221LL);
  }
  uint64_t v8 = *(void *)(a1 + 24);
  if (!v8) {
    return 23LL;
  }
  uint64_t v9 = *(uint64_t (**)(void))(*(void *)v8 + 24LL);
  if (!v9) {
    return 23LL;
  }
  uint64_t result = v9();
  if ((_DWORD)result) {
    return 23LL;
  }
  return result;
}

uint64_t sub_1000361C4( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)a1 != qword_10008C050) {
    return 39LL;
  }
  uint64_t v10 = *(char **)(a1 + 48);
  if (v10)
  {
    if (qword_10008C130)
    {
      BOOL v21 = 0LL;
      size_t v13 = strlen(v10);
      int v14 = sub_100029804( &v21,  qword_10008C130,  v10,  v13,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/comapi.c",  246LL);
      uint64_t v10 = *(char **)(a1 + 48);
      if (v14)
      {
        size_t v15 = strlen(*(const char **)(a1 + 48));
        sub_100029210( qword_10008C130,  v10,  v15,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/comapi.c",  250LL,  v16,  v17,  v18);
        sub_10005CFEC(&v21, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/comapi.c", 251LL);
        uint64_t v10 = *(char **)(a1 + 48);
      }
    }

    sub_10005CE20(v10, a2, a3, a4, a5, a6, a7, a8);
    *(void *)(a1 + 48) = 0LL;
  }

  uint64_t v20 = *(void *)(a1 + 40);
  char v19 = (char **)(a1 + 40);
  if (v20) {
    sub_100034198( v19,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/comapi.c",  258LL,  a4,  a5,  a6,  a7,  a8);
  }
  return 0LL;
}

uint64_t sub_1000362DC(void *a1, char *__s1, uint64_t a3)
{
  if (*a1 != qword_10008C050) {
    return 39LL;
  }
  int v13 = strcmp(__s1, "updated");
  if (!v13)
  {
    if (!a1[5]) {
      return 39LL;
    }
    if (!a1[6])
    {
      __sprintf_chk(__s, 0, 0x40uLL, "ng%08lx%08lx", qword_10008CE80, a1);
      int v14 = strlen(__s);
      size_t v15 = (char *)sub_10005CDE4((v14 + 1));
      a1[6] = v15;
      if (!v15) {
        return 1LL;
      }
      strcpy(v15, __s);
    }

    sub_100040544((uint64_t)a1, 1, v7, v8, v9, v10, v11, v12);
  }

  uint64_t v16 = a1[3];
  if (!v16
    || !*(void *)(*(void *)v16 + 24LL)
    || (uint64_t result = (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(void *)v16 + 40LL))(v16, __s1, a3),
        (_DWORD)result))
  {
    if (v13) {
      return 23LL;
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_10003641C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)a3 != qword_10008C050) {
    return 39LL;
  }
  if (!*(void *)(a3 + 48)
    || (uint64_t result = sub_10005F114(a1, "name"), !(_DWORD)result)
    && (uint64_t result = sub_10005F180(a1, *(char **)(a3 + 48)), !(_DWORD)result))
  {
    uint64_t v7 = *(void *)(a3 + 24);
    if (v7)
    {
      uint64_t v8 = *(void (**)(uint64_t, uint64_t))(*(void *)v7 + 48LL);
      if (v8) {
        v8(a1, a2);
      }
    }

    return 0LL;
  }

  return result;
}

uint64_t sub_1000364B4(void *a1, int a2, uint64_t a3)
{
  uint64_t v12 = 0LL;
  if (!a3) {
    return 46LL;
  }
  if (!sub_1000683F8(a3, a2, "handle"))
  {
    uint64_t v7 = sub_100062F48(a1, v12[2]);
    sub_10005D71C(&v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/comapi.c", 355LL);
    if ((_DWORD)v7) {
      return v7;
    }
    if (*(void *)*a1 != qword_10008C050)
    {
      uint64_t v7 = 39LL;
      uint64_t v8 = 361LL;
      goto LABEL_18;
    }
  }

  if (!sub_1000683F8(a3, a2, "name"))
  {
    uint64_t v11 = 0LL;
    if (!qword_10008C130
      || !sub_100029804( &v11,  qword_10008C130,  v12[2] + 3,  v12[2][2],  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/comapi.c",  374LL))
    {
      uint64_t v6 = (void *)*a1;
      if (!*a1) {
        return 23LL;
      }
      goto LABEL_15;
    }

    sub_10005D71C(&v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/comapi.c", 375LL);
    uint64_t v9 = (_DWORD *)*a1;
    if (*a1 && v9 != v11)
    {
      sub_10005CFEC(&v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/comapi.c", 378LL);
      uint64_t v7 = 44LL;
      uint64_t v8 = 379LL;
      goto LABEL_18;
    }

    if (!v9)
    {
      sub_10005CFB8(a1, (uint64_t)v11);
      sub_10005CFEC(&v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/comapi.c", 387LL);
    }
  }

  uint64_t v6 = (void *)*a1;
  if (*a1)
  {
LABEL_15:
    if ((v6[7] & 1) == 0) {
      return 0LL;
    }
    uint64_t v7 = 23LL;
    uint64_t v8 = 399LL;
LABEL_18:
    sub_10005CFEC((_DWORD **)a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/comapi.c", v8);
    return v7;
  }

  return 46LL;
}

uint64_t sub_100036674(void *a1)
{
  uint64_t v5 = 0LL;
  uint64_t v2 = sub_10005CE50( (void **)&v5,  (void *)qword_10008C050,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/comapi.c",  412LL);
  if (!(_DWORD)v2)
  {
    uint64_t v3 = (uint64_t)v5;
    v5[14] = 2;
    uint64_t v2 = sub_10005CFB8(a1, v3);
    sub_10005CFEC(&v5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/comapi.c", 417LL);
  }

  return v2;
}

uint64_t sub_100036708( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)a1 != qword_10008C050) {
    return 39LL;
  }
  *(_DWORD *)(a1 + 56) |= 1u;
  sub_1000361C4(a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/comapi.c", 436LL, a4, a5, a6, a7, a8);
  return 0LL;
}

uint64_t sub_100036788(void *a1)
{
  if (*a1 != qword_10008C068) {
    return 39LL;
  }
  uint64_t v3 = a1[3];
  if (!v3) {
    return 23LL;
  }
  uint64_t v4 = *(uint64_t (**)(void))(*(void *)v3 + 16LL);
  uint64_t v1 = 23LL;
  if (v4)
  {
    int v5 = v4();
    if (v5) {
      unsigned int v6 = 23;
    }
    else {
      unsigned int v6 = 0;
    }
    if (v5 == 42) {
      return 42LL;
    }
    else {
      return v6;
    }
  }

  return v1;
}

uint64_t sub_1000367F4(void *a1)
{
  if (*a1 != qword_10008C068) {
    return 39LL;
  }
  uint64_t v2 = a1[3];
  if (!v2) {
    return 23LL;
  }
  uint64_t v3 = *(uint64_t (**)(void))(*(void *)v2 + 24LL);
  if (!v3) {
    return 23LL;
  }
  uint64_t result = v3();
  if ((_DWORD)result) {
    return 23LL;
  }
  return result;
}

uint64_t sub_100036840(void *a1)
{
  if (*a1 == qword_10008C068) {
    return 0LL;
  }
  else {
    return 39LL;
  }
}

uint64_t sub_10003685C(void *a1)
{
  if (*a1 != qword_10008C068) {
    return 39LL;
  }
  uint64_t v2 = a1[3];
  if (!v2) {
    return 23LL;
  }
  if (!*(void *)(*(void *)v2 + 24LL)) {
    return 23LL;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 40LL))(v2);
  if ((_DWORD)result) {
    return 23LL;
  }
  return result;
}

uint64_t sub_1000368AC(uint64_t a1, uint64_t a2, void *a3)
{
  if (*a3 != qword_10008C068) {
    return 39LL;
  }
  uint64_t v4 = a3[3];
  if (v4)
  {
    int v5 = *(void (**)(void))(*(void *)v4 + 48LL);
    if (v5) {
      v5();
    }
  }

  return 0LL;
}

uint64_t sub_1000368F4(void *a1)
{
  if (*a1) {
    return 0LL;
  }
  else {
    return 46LL;
  }
}

uint64_t sub_100036908()
{
  return 27LL;
}

uint64_t sub_100036910()
{
  return 27LL;
}

uint64_t sub_100036918(void *a1)
{
  if (*a1 != qword_10008C060) {
    return 39LL;
  }
  uint64_t v3 = a1[3];
  if (!v3) {
    return 23LL;
  }
  uint64_t v4 = *(uint64_t (**)(void))(*(void *)v3 + 16LL);
  uint64_t v1 = 23LL;
  if (v4)
  {
    int v5 = v4();
    if (v5) {
      unsigned int v6 = 23;
    }
    else {
      unsigned int v6 = 0;
    }
    if (v5 == 42) {
      return 42LL;
    }
    else {
      return v6;
    }
  }

  return v1;
}

uint64_t sub_100036984(void *a1)
{
  if (*a1 != qword_10008C060) {
    return 39LL;
  }
  uint64_t v2 = a1[3];
  if (!v2) {
    return 23LL;
  }
  uint64_t v3 = *(uint64_t (**)(void))(*(void *)v2 + 24LL);
  if (!v3) {
    return 23LL;
  }
  uint64_t result = v3();
  if ((_DWORD)result) {
    return 23LL;
  }
  return result;
}

uint64_t sub_1000369D0(void *a1)
{
  if (*a1 == qword_10008C060) {
    return 0LL;
  }
  else {
    return 39LL;
  }
}

uint64_t sub_1000369EC(void *a1)
{
  if (*a1 != qword_10008C060) {
    return 39LL;
  }
  uint64_t v2 = a1[3];
  if (!v2) {
    return 23LL;
  }
  if (!*(void *)(*(void *)v2 + 24LL)) {
    return 23LL;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 40LL))(v2);
  if ((_DWORD)result) {
    return 23LL;
  }
  return result;
}

uint64_t sub_100036A3C(uint64_t a1, uint64_t a2, void *a3)
{
  if (*a3 != qword_10008C060) {
    return 39LL;
  }
  uint64_t v4 = a3[3];
  if (v4)
  {
    int v5 = *(void (**)(void))(*(void *)v4 + 48LL);
    if (v5) {
      v5();
    }
  }

  return 0LL;
}

uint64_t sub_100036A84(void *a1)
{
  if (*a1) {
    return 0LL;
  }
  else {
    return 46LL;
  }
}

uint64_t sub_100036A98()
{
  return 27LL;
}

uint64_t sub_100036AA0()
{
  return 27LL;
}

uint64_t sub_100036AA8(void *a1, int a2, uint64_t a3, unsigned int a4, uint64_t a5, int a6)
{
  uint64_t v12 = sub_10005CDE4(0x700uLL);
  if (!v12) {
    return 1LL;
  }
  int v13 = v12;
  *((_BYTE *)v12 + 44) = 0;
  v12[4] = a5;
  v12[26] = 0x100000001LL;
  v12[3] = (char *)v12 + 44;
  *((_BYTE *)v12 + 125) = 0;
  v12[2] = (char *)v12 + 125;
  v12[1] = (char *)v12 + 44;
  *((_DWORD *)v12 + 437) = a2;
  *((_DWORD *)v12 + 1__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = a6;
  if (!a3)
  {
    if ((fstat(a2, &v23) & 0x80000000) == 0)
    {
      off_t st_size = v23.st_size;
      if (!v23.st_size)
      {
        uint64_t v14 = 0LL;
        goto LABEL_11;
      }

      v13[221] = v23.st_size;
      v13[222] = st_size;
      BOOL v21 = mmap(0LL, st_size, 1, 1, a2, 0LL);
      v13[219] = v21;
    }

    uint64_t v14 = 26LL;
LABEL_11:
    sub_10005CE20( v13,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/conflex.c",  105LL,  v15,  v16,  v17,  v18,  v19);
    return v14;
  }

  v12[219] = a3;
  v12[221] = a4;
  v12[222] = 0LL;
LABEL_4:
  uint64_t v14 = 0LL;
  *a1 = v13;
  return v14;
}

uint64_t sub_100036BD4( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *a1;
  if (*(_DWORD *)(v9 + 1748) != -1)
  {
    munmap(*(void **)(v9 + 1752), *(void *)(v9 + 1776));
    close(*(_DWORD *)(*a1 + 1748));
    uint64_t v9 = *a1;
  }

  if (*(void *)(v9 + 1784))
  {
    sub_10005CE20( *(void **)(v9 + 1784),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/conflex.c",  119LL,  a4,  a5,  a6,  a7,  a8);
    uint64_t v9 = *a1;
  }

  sub_10005CE20( (void *)v9,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/conflex.c",  122LL,  a4,  a5,  a6,  a7,  a8);
  *a1 = 0LL;
  return 0LL;
}

uint64_t sub_100036C58( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (void *)a1[223];
  if (v9) {
    sub_10005CE20( v9,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/conflex.c",  139LL,  a4,  a5,  a6,  a7,  a8);
  }
  uint64_t v10 = sub_10005CDE4(0x700uLL);
  a1[223] = v10;
  if (!v10) {
    return 1LL;
  }
  memcpy(v10, a1, 0x700uLL);
  return 0LL;
}

uint64_t sub_100036CC0(const void **a1)
{
  uint64_t v1 = a1[223];
  if (!v1) {
    return 41LL;
  }
  memcpy(a1, a1[223], 0x700uLL);
  uint64_t result = 0LL;
  a1[223] = v1;
  return result;
}

uint64_t sub_100036D00(void *a1, _DWORD *a2, uint64_t a3)
{
  return sub_100036D08(a1, a2, a3, 0);
}

uint64_t sub_100036D08(void *a1, _DWORD *a2, uint64_t a3, int a4)
{
  uint64_t result = *(unsigned int *)(a3 + 224);
  if ((_DWORD)result)
  {
    int v9 = *(_DWORD *)(a3 + 220);
    if (*(_DWORD *)a3 != v9) {
      *(void *)(a3 + 8) = *(void *)(a3 + 24);
    }
    int v10 = *(_DWORD *)(a3 + 216);
    *(_DWORD *)a3 = v9;
    *(_DWORD *)(a3 + 4) = v10;
    *(_DWORD *)(a3 + 224) = 0;
  }

  else
  {
    uint64_t result = sub_100036E60(a3);
    *(void *)(a3 + 8) = *(void *)(a3 + 24);
  }

  if (!a4)
  {
    while ((_DWORD)result == 652)
    {
      uint64_t result = sub_100036E60(a3);
      *(void *)(a3 + 8) = *(void *)(a3 + 24);
    }
  }

  if (a1) {
    *a1 = *(void *)(a3 + 232);
  }
  if (a2) {
    *a2 = *(_DWORD *)(a3 + 240);
  }
  return result;
}

uint64_t sub_100036DB0(void *a1, _DWORD *a2, uint64_t a3)
{
  return sub_100036D08(a1, a2, a3, 1);
}

uint64_t sub_100036DB8(void *a1, _DWORD *a2, int32x2_t *a3, int a4)
{
  uint64_t result = a3[28].u32[0];
  if (!(_DWORD)result || !a4 && (_DWORD)result == 652)
  {
    a3[27] = vrev64_s32(*a3);
    do
    {
      uint64_t result = sub_100036E60((uint64_t)a3);
      a3[28].i32[0] = result;
    }

    while (!a4 && (_DWORD)result == 652);
    __int32 v9 = a3->i32[0];
    __int32 v10 = a3[27].i32[1];
    if (a3->i32[0] != v10) {
      a3[1] = a3[2];
    }
    __int32 v11 = a3->i32[1];
    __int32 v12 = a3[27].i32[0];
    a3->i32[0] = v10;
    a3->i32[1] = v12;
    a3[27].i32[0] = v11;
    a3[27].i32[1] = v9;
  }

  if (a1) {
    *a1 = a3[29];
  }
  if (a2) {
    *a2 = a3[30].i32[0];
  }
  return result;
}

uint64_t sub_100036E60(uint64_t a1)
{
  while (1)
  {
    int v3 = *(_DWORD *)(a1 + 208);
    int v2 = *(_DWORD *)(a1 + 212);
    uint64_t v4 = sub_1000374BC(a1);
    uint64_t v5 = v4;
    if ((_DWORD)v4 == 10)
    {
      if (*(_DWORD *)(a1 + 40)) {
        goto LABEL_56;
      }
    }

    else if (v4 > 0x7F)
    {
      goto LABEL_6;
    }

    if ((_DefaultRuneLocale.__runetype[v4] & 0x4000) != 0)
    {
      uint64_t v34 = 244LL;
      while (1)
      {
        uint64_t v35 = v34;
        *(_BYTE *)(a1 + v34) = v5;
        unsigned int v36 = sub_1000374BC(a1);
        LOBYTE(v5) = v36;
        if (v36 == 10)
        {
          if (*(_DWORD *)(a1 + 40)) {
            goto LABEL_75;
          }
        }

        else if (v36 > 0x7F)
        {
          uint64_t v37 = a1 + 244;
          if (v36 != -1)
          {
LABEL_76:
            --*(void *)(a1 + 1760);
            *(_DWORD *)(a1 + 228) = 1;
          }

          *(_BYTE *)(a1 + (v35 - 243) + 244) = 0;
          *(_DWORD *)(a1 + 24__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = v35 - 243;
          *(void *)(a1 + 232) = v37;
          return 652LL;
        }

        uint64_t v34 = v35 + 1;
        if ((_DefaultRuneLocale.__runetype[v36] & 0x4000) == 0)
        {
LABEL_75:
          uint64_t v37 = a1 + 244;
          goto LABEL_76;
        }
      }
    }

LABEL_109:
    *(_DWORD *)a1 = v2;
    *(_DWORD *)(a1 + 4) = v3;
    byte_1000BD310 = v4;
    byte_1000BD311 = 0;
    *(void *)(a1 + 232) = &byte_1000BD310;
    *(_DWORD *)(a1 + 24__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = 1;
    return v5;
  }

  *(_BYTE *)(a1 + 244) = v4;
  uint64_t v38 = (_BYTE *)(a1 + 244);
  uint64_t v39 = 263LL;
  *(_DWORD *)a1 = v2;
  *(_DWORD *)(a1 + 4) = v3;
  uint64_t v40 = 245LL;
  while (2)
  {
    uint64_t v5 = v39;
    unsigned int v41 = sub_1000374BC(a1);
    unsigned int v48 = v41;
    if (v41 >= 0x80) {
      int v49 = 343;
    }
    else {
      int v49 = v39;
    }
    if (v49 > 264)
    {
      if (v49 != 265) {
        goto LABEL_113;
      }
LABEL_94:
      if (v40 != 246
        || v41 > 0xFF
        || (_DefaultRuneLocale.__runetype[v41] & 0x10000) == 0
        || *v38 != 48
        || (*(unsigned __int8 *)(a1 + 245) | 0x20) != 0x78)
      {
        goto LABEL_100;
      }

LABEL_99:
      uint64_t v39 = 264LL;
LABEL_106:
      *(_BYTE *)(a1 + v40++) = v48;
      if (v40 == 1744)
      {
        sub_100046D6C(a1, "numeric token larger than internal buffer", v42, v43, v44, v45, v46, v47, v53);
        uint64_t v51 = 1499LL;
        uint64_t v5 = v39;
        goto LABEL_115;
      }

      continue;
    }

    break;
  }

  if (v49 == 263 && v41 - 48 < 0xA) {
    goto LABEL_106;
  }
  if (v41 <= 0xFF)
  {
    if ((_DefaultRuneLocale.__runetype[v41] & 0x10000) == 0) {
      goto LABEL_94;
    }
    goto LABEL_99;
  }

  v91[0] = 1666417251;
  uint64_t result = sub_100041BEC( &v86,  (size_t)v91,  4LL,  v32,  (unsigned int *)a1,  a3,  a4,  a6,  (uint64_t)a7,  a8,  (uint64_t)&v92,  v34,  v38,  v84,  v30,  v29);
  if (!(_DWORD)result) {
    return result;
  }
  uint64_t v70 = result + 4;
  uint64_t v71 = v86;
  if (v86)
  {
    uint64_t v72 = __n;
    *((_BYTE *)v91 + v7__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = 52;
    *((_BYTE *)v91 + (result + 5)) = 1;
    uint64_t v70 = result + 7;
    *((_BYTE *)v91 + (result + 6)) = v71;
    if ((v71 & 1) != 0)
    {
      uint64_t v73 = (_OWORD *)((char *)v91 + v38);
      uint64_t v74 = v73[5];
      *(_OWORD *)(__n_4 + 172) = v73[4];
      *(_OWORD *)(__n_4 + 188) = v74;
      uint64_t v75 = v73[7];
      *(_OWORD *)(__n_4 + 204) = v73[6];
      *(_OWORD *)(__n_4 + 22__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = v75;
      char v76 = v73[1];
      *(_OWORD *)(__n_4 + 108) = *v73;
      *(_OWORD *)(__n_4 + 124) = v76;
      uint64_t v77 = v73[3];
      *(_OWORD *)(__n_4 + 14__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = v73[2];
      *(_OWORD *)(__n_4 + 156) = v77;
      if ((v71 & 2) == 0)
      {
LABEL_107:
        if (!__n) {
          goto LABEL_113;
        }
        goto LABEL_108;
      }
    }

    else if ((v71 & 2) == 0)
    {
      goto LABEL_107;
    }

    uint64_t v78 = (_OWORD *)((char *)v91 + v84);
    uint64_t v79 = v78[1];
    *(_OWORD *)(__n_4 + 44) = *v78;
    *(_OWORD *)(__n_4 + 6__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = v79;
    uint64_t v80 = v78[3];
    *(_OWORD *)(__n_4 + 76) = v78[2];
    *(_OWORD *)(__n_4 + 92) = v80;
    if (!__n) {
      goto LABEL_113;
    }
  }

  else
  {
    uint64_t v72 = __n;
    if (!__n) {
      goto LABEL_113;
    }
  }

LABEL_115:
  *(_BYTE *)(a1 + v51 + 244) = 0;
  *(_DWORD *)(a1 + 24__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = v51;
  *(void *)(a1 + 232) = v38;
  return v5;
}

uint64_t sub_1000374AC(void *a1, _DWORD *a2, int32x2_t *a3)
{
  return sub_100036DB8(a1, a2, a3, 0);
}

uint64_t sub_1000374B4(void *a1, _DWORD *a2, int32x2_t *a3)
{
  return sub_100036DB8(a1, a2, a3, 1);
}

uint64_t sub_1000374BC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 1760);
  if (v1 == *(void *)(a1 + 1768))
  {
    uint64_t v2 = 0xFFFFFFFFLL;
  }

  else
  {
    uint64_t v2 = *(char *)(*(void *)(a1 + 1752) + v1);
    *(void *)(a1 + 176__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = v1 + 1;
  }

  if (*(_DWORD *)(a1 + 228))
  {
    *(_DWORD *)(a1 + 228) = 0;
  }

  else if ((_DWORD)v2 != -1)
  {
    if ((_DWORD)v2 == 10)
    {
      uint64_t v4 = *(void *)(a1 + 24);
      uint64_t v5 = a1 + 44;
      uint64_t v6 = 44LL;
      if (v4 == a1 + 44)
      {
        uint64_t v6 = 125LL;
        uint64_t v5 = a1 + 125;
      }

      else
      {
        uint64_t v4 = a1 + 125;
      }

      *(void *)(a1 + 16) = v4;
      *(void *)(a1 + 24) = v5;
      int v7 = *(_DWORD *)(a1 + 212) + 1;
      *(_DWORD *)(a1 + 208) = 1;
      *(_DWORD *)(a1 + 212) = v7;
      *(_BYTE *)(a1 + v6) = 0;
    }

    else
    {
      int v8 = *(_DWORD *)(a1 + 208);
      if (v8 <= 80)
      {
        *(_BYTE *)(v8 + *(void *)(a1 + 24) - 1LL) = v2;
        *(_BYTE *)(*(void *)(a1 + 24) + *(int *)(a1 + 208)) = 0;
        int v8 = *(_DWORD *)(a1 + 208);
      }

      *(_DWORD *)(a1 + 208) = v8 + 1;
    }
  }

  return v2;
}

uint64_t sub_100037580(const char *a1, uint64_t a2)
{
  if ((*a1 & 0x80000000) == 0)
  {
    __darwin_ct_rune_t v4 = __tolower(*(unsigned __int8 *)a1);
    switch(v4)
    {
      case 'a':
        if (!strncasecmp(a1 + 1, "uth", 3uLL))
        {
          if (!strncasecmp(a1 + 3, "uthenticat", 0xAuLL))
          {
            uint64_t v28 = a1 + 13;
            if (!strcasecmp(v28, "ed"))
            {
              return 355LL;
            }

            else if (!strcasecmp(v28, "ion"))
            {
              return 383LL;
            }
          }

          else if (!strcasecmp(a1 + 1, "uthoritative"))
          {
            return 380LL;
          }
        }

        else if (!strcasecmp(a1 + 1, "nd"))
        {
          return 334LL;
        }

        else if (!strcasecmp(a1 + 1, "ppend"))
        {
          return 326LL;
        }

        else if (!strcasecmp(a1 + 1, "llow"))
        {
          return 310LL;
        }

        else if (!strcasecmp(a1 + 1, "lias"))
        {
          return 317LL;
        }

        else if (!strcasecmp(a1 + 1, "lgorithm"))
        {
          return 459LL;
        }

        else if (!strcasecmp(a1 + 1, "lso"))
        {
          return 653LL;
        }

        else if (!strcasecmp(a1 + 1, "bandoned"))
        {
          return 319LL;
        }

        else if (!strcasecmp(a1 + 1, "dd"))
        {
          return 342LL;
        }

        else if (!strcasecmp(a1 + 1, "ll"))
        {
          return 357LL;
        }

        else if (!strcasecmp(a1 + 1, "t"))
        {
          return 430LL;
        }

        else if (!strcasecmp(a1 + 1, "rray"))
        {
          return 389LL;
        }

        else if (!strcasecmp(a1 + 1, "ddress"))
        {
          return 464LL;
        }

        else if (!strcasecmp(a1 + 1, "ctive"))
        {
          return 572LL;
        }

        else if (!strcasecmp(a1 + 1, "tsfp"))
        {
          return 616LL;
        }

        else if (!strcasecmp(a1 + 1, "fter"))
        {
          return 654LL;
        }

        return a2;
      case 'b':
        uint64_t v5 = a1 + 1;
        if (!strcasecmp(v5, "ackup")) {
          return 576LL;
        }
        if (!strcasecmp(v5, "ootp")) {
          return 578LL;
        }
        if (!strcasecmp(v5, "inding")) {
          return 570LL;
        }
        if (!strcasecmp(v5, "inary-to-ascii")) {
          return 404LL;
        }
        if (!strcasecmp(v5, "ackoff-cutoff")) {
          return 320LL;
        }
        if (!strcasecmp(v5, "ooting")) {
          return 313LL;
        }
        if (!strcasecmp(v5, "oot-unknown-clients")) {
          return 290LL;
        }
        if (!strcasecmp(v5, "reak")) {
          return 343LL;
        }
        if (!strcasecmp(v5, "illing")) {
          return 363LL;
        }
        if (!strcasecmp(v5, "oolean")) {
          return 390LL;
        }
        if (!strcasecmp(v5, "alance")) {
          return 461LL;
        }
        if (!strcasecmp(v5, "ound")) {
          return 597LL;
        }
        return a2;
      case 'c':
        uint64_t v6 = (unsigned __int8 *)(a1 + 1);
        if (!strcasecmp(a1 + 1, "ase")) {
          return 436LL;
        }
        if (!strcasecmp(a1 + 1, "heck")) {
          return 339LL;
        }
        if (!strcasecmp(a1 + 1, "iaddr")) {
          return 274LL;
        }
        if (__tolower(*v6) == 108)
        {
          if (!strcasecmp(a1 + 2, "ass"))
          {
            return 270LL;
          }

          else if (!strncasecmp(a1 + 2, "ient", 4uLL))
          {
            if (!strcasecmp(a1 + 6, "s"))
            {
              return 353LL;
            }

            else if (a1[6] == 45)
            {
              uint64_t v38 = a1 + 7;
              if (!strcasecmp(v38, "hostname"))
              {
                return 329LL;
              }

              else if (!strcasecmp(v38, "identifier"))
              {
                return 298LL;
              }

              else if (!strcasecmp(v38, "state"))
              {
                return 593LL;
              }

              else if (!strcasecmp(v38, "updates"))
              {
                return 601LL;
              }
            }
          }

          else if (!strcasecmp(a1 + 2, "ose"))
          {
            return 603LL;
          }

          else if (!strcasecmp(a1 + 2, "tt"))
          {
            return 568LL;
          }
        }

        else if ((char)*v6 < 0 || __tolower(*v6) != 111)
        {
LABEL_371:
          if (!strcasecmp(a1 + 1, "reate")) {
            return 604LL;
          }
        }

        else
        {
          uint64_t v29 = (unsigned __int8 *)(a1 + 2);
          if (!strcasecmp(a1 + 2, "de"))
          {
            return 388LL;
          }

          else if (((char)*v29 & 0x80000000) == 0)
          {
            if (__tolower(*v29) == 109)
            {
              uint64_t v30 = a1 + 3;
              if (!strcasecmp(v30, "mit"))
              {
                return 411LL;
              }

              else if (!strcasecmp(v30, "munications-interrupted"))
              {
                return 376LL;
              }

              else if (!strcasecmp(v30, "pressed"))
              {
                return 635LL;
              }
            }

            else if (((char)*v29 & 0x80000000) == 0 && __tolower(*v29) == 110)
            {
              uint64_t v45 = a1 + 3;
              if (!strcasecmp(v45, "cat"))
              {
                return 398LL;
              }

              else if (!strcasecmp(v45, "fig-option"))
              {
                return 406LL;
              }

              else if (!strcasecmp(v45, "flict-done"))
              {
                return 660LL;
              }

              else if (!strcasecmp(v45, "nect"))
              {
                return 610LL;
              }
            }
          }
        }

        return a2;
      case 'd':
        if (!strcasecmp(a1 + 1, "b-time-format")) {
          return 624LL;
        }
        if (!strcasecmp(a1 + 1, "ns-update")) {
          return 412LL;
        }
        if (!strcasecmp(a1 + 1, "ns-delete")) {
          return 419LL;
        }
        if (!strcasecmp(a1 + 1, "omain")) {
          return 323LL;
        }
        if (strncasecmp(a1 + 1, "omain-", 6uLL)) {
          goto LABEL_51;
        }
        if (!strcasecmp(a1 + 7, "name")) {
          return 613LL;
        }
        if (!strcasecmp(a1 + 7, "list")) {
          return 630LL;
        }
LABEL_51:
        if (!strcasecmp(a1 + 1, "o-forward-update")) {
          return 614LL;
        }
        if (!strcasecmp(a1 + 1, "ebug")) {
          return 584LL;
        }
        if (!strcasecmp(a1 + 1, "eny")) {
          return 312LL;
        }
        if (!strcasecmp(a1 + 1, "eleted")) {
          return 417LL;
        }
        if (!strcasecmp(a1 + 1, "elete")) {
          return 432LL;
        }
        if (!strncasecmp(a1 + 1, "efault", 6uLL))
        {
          int v48 = *((unsigned __int8 *)a1 + 7);
          uint64_t v47 = a1 + 7;
          if (v48)
          {
            if (!strcasecmp(v47, "-duid"))
            {
              return 646LL;
            }

            else if (!strcasecmp(v47, "-lease-time"))
            {
              return 280LL;
            }
          }

          else
          {
            return 314LL;
          }
        }

        else
        {
          if (strncasecmp(a1 + 1, "ynamic", 6uLL)) {
            goto LABEL_58;
          }
          if (!a1[7]) {
            return 358LL;
          }
          if (!strncasecmp(a1 + 7, "-bootp", 6uLL))
          {
            int v50 = *((unsigned __int8 *)a1 + 13);
            int v49 = a1 + 13;
            if (v50)
            {
              if (!strcasecmp(v49, "-lease-cutoff"))
              {
                return 288LL;
              }

              else if (!strcasecmp(v49, "-lease-length"))
              {
                return 289LL;
              }
            }

            else
            {
              return 286LL;
            }
          }

          else
          {
LABEL_58:
            if (!strcasecmp(a1 + 1, "uplicates"))
            {
              return 420LL;
            }

            else if (!strcasecmp(a1 + 1, "eclines"))
            {
              return 421LL;
            }

            else if (!strncasecmp(a1 + 1, "efine", 5uLL))
            {
              int v7 = a1 + 6;
              if (!strcasecmp(v7, "d"))
              {
                return 450LL;
              }

              else if (!*v7)
              {
                return 455LL;
              }
            }
          }
        }

        return a2;
      case 'e':
        if (!strcasecmp(a1 + 2, "ists")) {
          return 350LL;
        }
        if (!strcasecmp(a1 + 2, "piry")) {
          return 409LL;
        }
        if (!strcasecmp(a1 + 2, "pire")) {
          return 308LL;
        }
        if (!strcasecmp(a1 + 2, "pired")) {
          return 573LL;
        }
LABEL_71:
        if (!strcasecmp(a1 + 1, "poch")) {
          return 623LL;
        }
        if (!strcasecmp(a1 + 1, "thernet")) {
          return 261LL;
        }
        if (!strcasecmp(a1 + 1, "nds")) {
          return 268LL;
        }
        if (!strncasecmp(a1 + 1, "ls", 2uLL))
        {
          unsigned int v33 = a1 + 3;
          if (!strcasecmp(v33, "e"))
          {
            return 344LL;
          }

          else if (!strcasecmp(v33, "if"))
          {
            return 345LL;
          }
        }

        else if (!strcasecmp(a1 + 1, "rror"))
        {
          return 583LL;
        }

        else if (!strcasecmp(a1 + 1, "val"))
        {
          return 452LL;
        }

        else if (!strcasecmp(a1 + 1, "ncapsulate"))
        {
          return 591LL;
        }

        else if (!strcasecmp(a1 + 1, "xecute"))
        {
          return 632LL;
        }

        else if (!strcasecmp(a1 + 1, "n"))
        {
          return 649LL;
        }

        return a2;
      case 'f':
        int v8 = a1 + 1;
        if (!strcasecmp(v8, "atal")) {
          return 582LL;
        }
        if (!strcasecmp(v8, "ilename")) {
          return 258LL;
        }
        if (!strcasecmp(v8, "ixed-address")) {
          return 259LL;
        }
        if (!strcasecmp(v8, "ixed-address6")) {
          return 634LL;
        }
        if (!strcasecmp(v8, "ixed-prefix6")) {
          return 658LL;
        }
        if (!strcasecmp(v8, "ddi")) {
          return 379LL;
        }
        if (!strcasecmp(v8, "ormerr")) {
          return 437LL;
        }
        if (!strcasecmp(v8, "unction")) {
          return 454LL;
        }
        if (!strcasecmp(v8, "ailover")) {
          return 365LL;
        }
        if (!strcasecmp(v8, "ree")) {
          return 571LL;
        }
        return a2;
      case 'g':
        uint64_t v9 = a1 + 1;
        if (!strcasecmp(v9, "iaddr")) {
          return 277LL;
        }
        if (!strcasecmp(v9, "roup")) {
          return 293LL;
        }
        if (!strcasecmp(v9, "et-lease-hostnames")) {
          return 295LL;
        }
        return a2;
      case 'h':
        uint64_t v10 = a1 + 1;
        if (!strcasecmp(v10, "ash")) {
          return 621LL;
        }
        if (!strcasecmp(v10, "ba")) {
          return 426LL;
        }
        if (!strcasecmp(v10, "ost")) {
          return 256LL;
        }
        if (!strcasecmp(v10, "ost-decl-name")) {
          return 407LL;
        }
        if (!strcasecmp(v10, "ost-identifier")) {
          return 637LL;
        }
        if (!strcasecmp(v10, "ardware")) {
          return 257LL;
        }
        if (!strcasecmp(v10, "ostname")) {
          return 328LL;
        }
        if (!strcasecmp(v10, "elp")) {
          return 606LL;
        }
        return a2;
      case 'i':
        __int32 v11 = a1 + 1;
        if (!strcasecmp(v11, "a-na")) {
          return 638LL;
        }
        if (!strcasecmp(v11, "a-ta")) {
          return 639LL;
        }
        if (!strcasecmp(v11, "a-pd")) {
          return 640LL;
        }
        if (!strcasecmp(v11, "aaddr")) {
          return 641LL;
        }
        if (!strcasecmp(v11, "aprefix")) {
          return 642LL;
        }
        if (!strcasecmp(v11, "nclude")) {
          return 569LL;
        }
        if (!strcasecmp(v11, "nteger")) {
          return 391LL;
        }
        if (!strcasecmp(v11, "nfinite")) {
          return 416LL;
        }
        if (!strcasecmp(v11, "nfo")) {
          return 585LL;
        }
        if (!strcasecmp(v11, "p-address")) {
          return 394LL;
        }
        if (!strcasecmp(v11, "p6-address")) {
          return 633LL;
        }
        if (!strcasecmp(v11, "nterface")) {
          return 305LL;
        }
        if (!strcasecmp(v11, "dentifier")) {
          return 370LL;
        }
        if (!strcasecmp(v11, "f")) {
          return 341LL;
        }
        if (!strcasecmp(v11, "s")) {
          return 425LL;
        }
        if (!strcasecmp(v11, "gnore")) {
          return 384LL;
        }
        return a2;
      case 'j':
      case 'q':
      case 'x':
        return a2;
      case 'k':
        if (!strncasecmp(a1 + 1, "nown", 4uLL))
        {
          uint64_t v24 = a1 + 5;
          if (!strcasecmp(v24, "-clients"))
          {
            return 615LL;
          }

          else if (!*v24)
          {
            return 354LL;
          }
        }

        else if (!strcasecmp(a1 + 1, "ey"))
        {
          return 457LL;
        }

        return a2;
      case 'l':
        uint64_t v12 = a1 + 1;
        if (!strcasecmp(v12, "case")) {
          return 617LL;
        }
        if (!strcasecmp(v12, "ease")) {
          return 271LL;
        }
        if (!strcasecmp(v12, "ease6")) {
          return 643LL;
        }
        if (!strcasecmp(v12, "eased-address")) {
          return 403LL;
        }
        if (!strcasecmp(v12, "ease-time")) {
          return 413LL;
        }
        if (!strcasecmp(v12, "easequery")) {
          return 631LL;
        }
        if (!strcasecmp(v12, "ength")) {
          return 620LL;
        }
        if (!strcasecmp(v12, "imit")) {
          return 362LL;
        }
        if (!strcasecmp(v12, "et")) {
          return 453LL;
        }
        if (!strcasecmp(v12, "oad")) {
          return 460LL;
        }
        if (!strcasecmp(v12, "ocal")) {
          return 625LL;
        }
        if (!strcasecmp(v12, "og")) {
          return 581LL;
        }
        if (!strcasecmp(v12, "lt")) {
          return 648LL;
        }
        if (!strcasecmp(v12, "l")) {
          return 650LL;
        }
        return a2;
      case 'm':
        if (strncasecmp(a1 + 1, "ax", 2uLL)) {
          goto LABEL_143;
        }
        if (!a1[3]) {
          return 462LL;
        }
        if (!strcasecmp(a1 + 3, "-balance")) {
          return 628LL;
        }
        if (strncasecmp(a1 + 3, "-lease-", 7uLL)) {
          goto LABEL_274;
        }
        if (!strcasecmp(a1 + 10, "misbalance")) {
          return 626LL;
        }
        if (!strcasecmp(a1 + 10, "ownership")) {
          return 627LL;
        }
        if (!strcasecmp(a1 + 10, "time")) {
          return 281LL;
        }
LABEL_274:
        if (!strcasecmp(a1 + 3, "-life")) {
          return 645LL;
        }
        if (!strcasecmp(a1 + 3, "-transmit-idle")) {
          return 372LL;
        }
        if (!strcasecmp(a1 + 3, "-response-delay")) {
          return 373LL;
        }
        if (!strcasecmp(a1 + 3, "-unacked-updates")) {
          return 427LL;
        }
LABEL_143:
        if (!strncasecmp(a1 + 1, "in-", 3uLL))
        {
          unsigned int v25 = a1 + 4;
          if (!strcasecmp(v25, "balance"))
          {
            return 629LL;
          }

          else if (!strcasecmp(v25, "lease-time"))
          {
            return 332LL;
          }

          else if (!strcasecmp(v25, "secs"))
          {
            return 333LL;
          }
        }

        else if (!strncasecmp(a1 + 1, "edi", 3uLL))
        {
          uint64_t v27 = a1 + 4;
          if (!strcasecmp(v27, "a"))
          {
            return 315LL;
          }

          else if (!strcasecmp(v27, "um"))
          {
            return 316LL;
          }
        }

        else if (!strcasecmp(a1 + 1, "atch"))
        {
          return 347LL;
        }

        else if (!strcasecmp(a1 + 1, "embers"))
        {
          return 359LL;
        }

        else if (!strcasecmp(a1 + 1, "y"))
        {
          return 366LL;
        }

        else if (!strcasecmp(a1 + 1, "clt"))
        {
          return 428LL;
        }

        return a2;
      case 'n':
        uint64_t v13 = a1 + 1;
        if (!strcasecmp(v13, "ormal")) {
          return 375LL;
        }
        if (!strcasecmp(v13, "ameserver")) {
          return 322LL;
        }
        if (!strcasecmp(v13, "etmask")) {
          return 279LL;
        }
        if (!strcasecmp(v13, "ever")) {
          return 415LL;
        }
        if (!strcasecmp(v13, "ext-server")) {
          return 291LL;
        }
        if (!strcasecmp(v13, "ot")) {
          return 381LL;
        }
        if (!strcasecmp(v13, "o")) {
          return 431LL;
        }
        if (!strcasecmp(v13, "s-update")) {
          return 433LL;
        }
        if (!strcasecmp(v13, "oerror")) {
          return 438LL;
        }
        if (!strcasecmp(v13, "otauth")) {
          return 439LL;
        }
        if (!strcasecmp(v13, "otimp")) {
          return 440LL;
        }
        if (!strcasecmp(v13, "otzone")) {
          return 441LL;
        }
        if (!strcasecmp(v13, "xdomain")) {
          return 442LL;
        }
        if (!strcasecmp(v13, "xrrset")) {
          return 443LL;
        }
        if (!strcasecmp(v13, "ull")) {
          return 448LL;
        }
        if (!strcasecmp(v13, "ext")) {
          return 579LL;
        }
        if (!strcasecmp(v13, "ew")) {
          return 601LL;
        }
        return a2;
      case 'o':
        uint64_t v14 = a1 + 1;
        if (!strcasecmp(v14, "mapi")) {
          return 580LL;
        }
        if (!strcasecmp(v14, "r")) {
          return 335LL;
        }
        if (!strcasecmp(v14, "n")) {
          return 408LL;
        }
        if (!strcasecmp(v14, "pen")) {
          return 605LL;
        }
        if (!strcasecmp(v14, "ption")) {
          return 260LL;
        }
        if (!strcasecmp(v14, "ne-lease-per-client")) {
          return 294LL;
        }
        if (!strcasecmp(v14, "f")) {
          return 360LL;
        }
        if (!strcasecmp(v14, "wner")) {
          return 424LL;
        }
        return a2;
      case 'p':
        int v15 = a1 + 1;
        if (!strcasecmp(a1 + 1, "repend")) {
          return 327LL;
        }
        if (!strcasecmp(a1 + 1, "referred-life")) {
          return 644LL;
        }
        if (!strcasecmp(a1 + 1, "acket")) {
          return 273LL;
        }
        if (!strcasecmp(a1 + 1, "ool")) {
          return 351LL;
        }
        if (!strcasecmp(a1 + 1, "refix6")) {
          return 657LL;
        }
        if (!strcasecmp(a1 + 1, "seudo")) {
          return 361LL;
        }
        if (!strcasecmp(a1 + 1, "eer")) {
          return 364LL;
        }
        if (!strcasecmp(a1 + 1, "rimary")) {
          return 368LL;
        }
        if (strncasecmp(a1 + 1, "artner", 6uLL)) {
          goto LABEL_186;
        }
        int v41 = *((unsigned __int8 *)a1 + 7);
        uint64_t v40 = a1 + 7;
        if (!v41) {
          return 367LL;
        }
        if (!strcasecmp(v40, "-down")) {
          return 374LL;
        }
LABEL_186:
        if (!strcasecmp(v15, "ort")) {
          return 371LL;
        }
        if (!strcasecmp(v15, "otential-conflict")) {
          return 377LL;
        }
        if (!strcasecmp(v15, "ick-first-value") || !strcasecmp(v15, "ick")) {
          return 405LL;
        }
        if (!strcasecmp(v15, "aused")) {
          return 587LL;
        }
        return a2;
      case 'r':
        uint64_t v16 = a1 + 1;
        if (!strcasecmp(v16, "ange")) {
          return 272LL;
        }
        if (!strcasecmp(v16, "ange6")) {
          return 651LL;
        }
        if (!strcasecmp(v16, "ecover")) {
          return 378LL;
        }
        if (!strcasecmp(v16, "ecover-done")) {
          return 588LL;
        }
        if (!strcasecmp(v16, "ecover-wait")) {
          return 608LL;
        }
        if (!strcasecmp(v16, "equest")) {
          return 299LL;
        }
        if (!strcasecmp(v16, "equire")) {
          return 300LL;
        }
        if (!strcasecmp(v16, "etry")) {
          return 302LL;
        }
        if (!strcasecmp(v16, "eturn")) {
          return 586LL;
        }
        if (!strcasecmp(v16, "enew")) {
          return 306LL;
        }
        if (!strcasecmp(v16, "ebind")) {
          return 307LL;
        }
        if (!strcasecmp(v16, "eboot")) {
          return 318LL;
        }
        if (!strcasecmp(v16, "eject")) {
          return 330LL;
        }
        if (!strcasecmp(v16, "everse")) {
          return 402LL;
        }
        if (!strcasecmp(v16, "elease")) {
          return 410LL;
        }
        if (!strcasecmp(v16, "efused")) {
          return 444LL;
        }
        if (!strcasecmp(v16, "eleased")) {
          return 574LL;
        }
        if (!strcasecmp(v16, "eset")) {
          return 575LL;
        }
        if (!strcasecmp(v16, "eserved")) {
          return 577LL;
        }
        if (!strcasecmp(v16, "emove")) {
          return 611LL;
        }
        if (!strcasecmp(v16, "efresh")) {
          return 612LL;
        }
        return a2;
      case 's':
        uint64_t v17 = a1 + 1;
        if (!strcasecmp(a1 + 1, "cript")) {
          return 304LL;
        }
        if (*v17 < 0) {
          goto LABEL_523;
        }
        if (__tolower(*(unsigned __int8 *)v17) == 101)
        {
          uint64_t v18 = (unsigned __int8 *)(a1 + 2);
          if (!strcasecmp(a1 + 2, "arch")) {
            return 324LL;
          }
          if ((char)*v18 < 0 || __tolower(*v18) != 99)
          {
            if (!strncasecmp(a1 + 2, "lect", 4uLL))
            {
              int v36 = *((unsigned __int8 *)a1 + 6);
              uint64_t v35 = a1 + 6;
              if (v36)
              {
                if (!strcasecmp(v35, "-timeout")) {
                  return 303LL;
                }
              }

              else
              {
                return 596LL;
              }
            }

            else if (!strcasecmp(a1 + 2, "nd"))
            {
              return 297LL;
            }

            else if (!strncasecmp(a1 + 2, "rv", 2uLL))
            {
              if (!strncasecmp(a1 + 4, "er", 2uLL))
              {
                if (a1[6])
                {
                  if (a1[6] == 45)
                  {
                    uint64_t v46 = a1 + 7;
                    if (!strcasecmp(v46, "duid"))
                    {
                      return 647LL;
                    }

                    else if (!strcasecmp(v46, "name"))
                    {
                      return 285LL;
                    }

                    else if (!strcasecmp(v46, "identifier"))
                    {
                      return 287LL;
                    }
                  }
                }

                else
                {
                  return 609LL;
                }
              }

              else if (!strcasecmp(a1 + 4, "fail"))
              {
                return 445LL;
              }
            }

            else if (!strcasecmp(a1 + 2, "t"))
            {
              return 449LL;
            }
          }

          else if (!strncasecmp(a1 + 3, "ond", 3uLL))
          {
            uint64_t v39 = a1 + 6;
            if (!strcasecmp(v39, "ary"))
            {
              return 369LL;
            }

            else if (!strcasecmp(v39, "s"))
            {
              return 463LL;
            }
          }

          else if (!strcasecmp(a1 + 3, "ret"))
          {
            return 458LL;
          }

          return a2;
        }

        if (*v17 < 0) {
          goto LABEL_523;
        }
        if (__tolower(*(unsigned __int8 *)v17) == 104)
        {
          uint64_t v26 = a1 + 2;
          if (!strcasecmp(v26, "ared-network")) {
            return 284LL;
          }
          if (!strcasecmp(v26, "utdown")) {
            return 589LL;
          }
          return a2;
        }

        if (*v17 < 0) {
          goto LABEL_523;
        }
        if (__tolower(*(unsigned __int8 *)v17) == 105)
        {
          uint64_t v31 = a1 + 2;
          if (!strcasecmp(v31, "addr")) {
            return 276LL;
          }
          if (!strcasecmp(v31, "gned")) {
            return 392LL;
          }
          if (!strcasecmp(v31, "ze")) {
            return 622LL;
          }
          return a2;
        }

        if (*v17 < 0) {
          goto LABEL_523;
        }
        if (__tolower(*(unsigned __int8 *)v17) == 112)
        {
          if (a1[2] < 0 || __tolower(*((unsigned __int8 *)a1 + 2)) != 97)
          {
            if (!strcasecmp(a1 + 2, "lit")) {
              return 429LL;
            }
          }

          else
          {
            uint64_t v37 = a1 + 3;
            if (!strcasecmp(v37, "ce"))
            {
              return 397LL;
            }

            else if (!strcasecmp(v37, "wn"))
            {
              return 348LL;
            }
          }

          return a2;
        }

        if (*v17 < 0 || __tolower(*(unsigned __int8 *)v17) != 116)
        {
LABEL_523:
          if (!strncasecmp(a1 + 1, "ub", 2uLL))
          {
            uint64_t v44 = a1 + 3;
            if (!strcasecmp(v44, "class"))
            {
              a2 = 346LL;
            }

            else if (!strcasecmp(v44, "net"))
            {
              a2 = 278LL;
            }

            else if (!strcasecmp(v44, "net6"))
            {
              a2 = 636LL;
            }

            else if (!strcasecmp(v44, "string"))
            {
              a2 = 337LL;
            }
          }

          else
          {
            uint64_t v43 = a1 + 2;
            if (!strcasecmp(v43, "ffix")) {
              return 338LL;
            }
            if (!strcasecmp(v43, "persede"))
            {
              a2 = 325LL;
            }

            else
            {
LABEL_639:
              if (!strcasecmp(v17, "witch")) {
                a2 = 435LL;
              }
            }
          }
        }

        else
        {
          if (a1[2] < 0 || __tolower(*((unsigned __int8 *)a1 + 2)) != 97)
          {
LABEL_592:
            if (!strcasecmp(a1 + 2, "ring")) {
              return 396LL;
            }
            return a2;
          }

          if (strncasecmp(a1 + 3, "rt", 2uLL))
          {
            if ((a1[3] & 0x80000000) == 0 && __tolower(*((unsigned __int8 *)a1 + 3)) == 116)
            {
              uint64_t v42 = a1 + 4;
              if (!strcasecmp(v42, "e")) {
                return 466LL;
              }
              if (!strcasecmp(v42, "ic")) {
                return 414LL;
              }
              return a2;
            }

            goto LABEL_592;
          }

          uint64_t v51 = a1 + 5;
          if (!strcasecmp(v51, "s"))
          {
            a2 = 267LL;
          }

          else if (!strcasecmp(v51, "up"))
          {
            a2 = 590LL;
          }
        }

        break;
      case 't':
        uint64_t v19 = a1 + 1;
        if (!strcasecmp(v19, "imestamp")) {
          return 266LL;
        }
        if (!strcasecmp(v19, "imeout")) {
          return 301LL;
        }
        if (!strcasecmp(v19, "oken-ring")) {
          return 292LL;
        }
        if (!strcasecmp(v19, "ext")) {
          return 395LL;
        }
        if (!strcasecmp(v19, "stp")) {
          return 422LL;
        }
        if (!strcasecmp(v19, "sfp")) {
          return 423LL;
        }
        if (!strcasecmp(v19, "ransmission")) {
          return 602LL;
        }
        if (!strcasecmp(v19, "emporary")) {
          return 656LL;
        }
        return a2;
      case 'u':
        if (!strcasecmp(a1 + 1, "case")) {
          return 618LL;
        }
        if (!strcasecmp(a1 + 1, "nset")) {
          return 451LL;
        }
        if (!strcasecmp(a1 + 1, "nsigned")) {
          return 393LL;
        }
        if (!strcasecmp(a1 + 1, "id")) {
          return 269LL;
        }
        if (!strncasecmp(a1 + 1, "se", 2uLL))
        {
          uint64_t v32 = a1 + 3;
          if (!strcasecmp(v32, "r-class"))
          {
            return 283LL;
          }

          else if (!strcasecmp(v32, "-host-decl-names"))
          {
            return 296LL;
          }

          else if (!strcasecmp(v32, "-lease-addr-for-default-route"))
          {
            return 331LL;
          }
        }

        else if (!strncasecmp(a1 + 1, "nknown", 6uLL))
        {
          uint64_t v34 = a1 + 7;
          if (!strcasecmp(v34, "-clients"))
          {
            return 309LL;
          }

          else if (!strcasecmp(v34, "-state"))
          {
            return 567LL;
          }

          else if (!*v34)
          {
            return 352LL;
          }
        }

        else if (!strcasecmp(a1 + 1, "nauthenticated"))
        {
          return 356LL;
        }

        else if (!strcasecmp(a1 + 1, "pdated-dns-rr"))
        {
          return 418LL;
        }

        else if (!strcasecmp(a1 + 1, "pdate"))
        {
          return 434LL;
        }

        return a2;
      case 'v':
        uint64_t v20 = a1 + 1;
        if (!strcasecmp(v20, "endor-class")) {
          return 282LL;
        }
        if (!strcasecmp(v20, "endor")) {
          return 592LL;
        }
        return a2;
      case 'w':
        uint64_t v21 = a1 + 1;
        if (!strcasecmp(v21, "ith")) {
          return 349LL;
        }
        if (!strcasecmp(v21, "idth")) {
          return 619LL;
        }
        return a2;
      case 'y':
        char v22 = a1 + 1;
        if (!strcasecmp(v22, "iaddr")) {
          return 275LL;
        }
        if (!strcasecmp(v22, "xdomain")) {
          return 446LL;
        }
        if (!strcasecmp(v22, "xrrset")) {
          return 447LL;
        }
        return a2;
      case 'z':
        uint64_t v23 = a1 + 1;
        if (!strcasecmp(v23, "erolen")) {
          return 655LL;
        }
        if (!strcasecmp(v23, "one")) {
          return 456LL;
        }
        return a2;
      default:
        if (v4 == 45 && !a1[1]) {
          return 45LL;
        }
        return a2;
    }
  }

  return a2;
}

uint64_t sub_100039980(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_100068D58();
  if ((_DWORD)result)
  {
    memset(v8, 0, 44);
    *(_OWORD *)((char *)v8 + 8) = *(_OWORD *)(a2 + 48);
    WORD4(v8[1]) = *(_WORD *)(a2 + 64);
    if (*(_DWORD *)(a2 + 80)) {
      LODWORD(v8[0]) = **(_DWORD **)(a2 + 72);
    }
    *(_OWORD *)((char *)&v8[1] + 1__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = *(_OWORD *)(a2 + 132);
    DWORD1(v8[0]) = bswap32(*(_DWORD *)(a2 + 148));
    return sub_1000693B0( a1,  44,  (uint64_t)v8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/ctrace.c",  50LL,  v5,  v6,  v7);
  }

  return result;
}

uint64_t sub_100039A3C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((_DWORD)a2 != 44) {
    return sub_10006221C("trace interface packet size mismatch: %ld != %d", a2, a3, a4, a5, a6, a7, a8, 44);
  }
  uint64_t v43 = 0LL;
  unsigned int v9 = sub_10003A174((void **)&v43, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/ctrace.c", 70LL);
  if (v9)
  {
LABEL_3:
    char v42 = sub_100067900(v9);
    return sub_10006221C("trace_interface_input: %s.", v10, v11, v12, v13, v14, v15, v16, v42);
  }

  uint64_t v18 = sub_10005CDE4(0x20uLL);
  uint64_t v19 = v43;
  *((void *)v43 + 24) = v18;
  if (!v18)
  {
    sub_1000235C8(&v43, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/ctrace.c", 79LL);
    unsigned int v9 = 1;
    goto LABEL_3;
  }

  __int128 v20 = *(_OWORD *)(a3 + 8);
  *((_WORD *)v19 + 32) = *(_WORD *)(a3 + 24);
  *((_OWORD *)v19 + 3) = v20;
  *((void *)v19 + 1__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = 0x100000001LL;
  uint64_t v21 = sub_10005CDE4(4uLL);
  *((void *)v43 + 9) = v21;
  *uint64_t v21 = *(_DWORD *)a3;
  char v22 = v43;
  *(_OWORD *)(v43 + 132) = *(_OWORD *)(a3 + 26);
  v22[37] = bswap32(*(_DWORD *)(a3 + 4));
  sub_10003B7F8((uint64_t)v22, 0);
  if (off_10008C078) {
    off_10008C078(v43);
  }
  uint64_t v23 = v43;
  *(_OWORD *)*((void *)v43 + 24) = *(_OWORD *)(v43 + 132);
  *(_BYTE *)(v23[24] + 16LL) = 16;
  int v24 = *(_DWORD *)v23[9];
  *(_DWORD *)(v23[24] + 20LL) = v24;
  int v44 = 4;
  int v45 = v24;
  if (off_10008C080)
  {
    off_10008C080();
    uint64_t v23 = v43;
  }

  sub_10003B884((uint64_t)v23);
  if (!dword_10008C100)
  {
    char v25 = (_BYTE)v43 - 124;
    sub_1000501FC(v43[49], v43[48] - 1, (unsigned __int8 *)v43 + 50);
    sub_1000622D4("Listening on Trace/%s/%s%s%s", v26, v27, v28, v29, v30, v31, v32, v25);
    unsigned int v33 = (unsigned __int8 *)v43;
    char v34 = (_BYTE)v43 - 124;
    if (strcmp(v43 + 132, "fallback"))
    {
      sub_1000501FC(v33[49], v33[48] - 1, v33 + 50);
      sub_1000622D4("Sending   on Trace/%s/%s%s%s", v35, v36, v37, v38, v39, v40, v41, v34);
    }
  }

  return sub_1000235C8(&v43, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/ctrace.c", 133LL);
}

uint64_t sub_100039CCC(uint64_t a1, uint64_t a2, int a3, __int16 a4, __int128 *a5, __int128 *a6)
{
  uint64_t result = sub_100068D58();
  if ((_DWORD)result)
  {
    __int16 v24 = a4;
    __int128 v22 = *a5;
    int v23 = *((_DWORD *)a5 + 4);
    LODWORD(v22) = bswap32(v22);
    if (a6)
    {
      __int128 v25 = *a6;
      __int16 v26 = *((_WORD *)a6 + 8);
      char v16 = 1;
    }

    else
    {
      char v16 = 0;
      __int128 v25 = 0uLL;
      __int16 v26 = 0;
    }

    char v27 = v16;
    unsigned int v21 = bswap32(*(_DWORD *)(a1 + 148));
    uint64_t v17 = &v21;
    int v18 = 48;
    uint64_t v19 = a2;
    int v20 = a3;
    return sub_1000693DC( qword_10008C0B0,  2LL,  (uint64_t)&v17,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/ctrace.c",  168LL,  v13,  v14,  v15);
  }

  return result;
}

uint64_t sub_100039DE4( uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  unsigned int v10 = bswap32(*a3);
  a3[1] = bswap32(a3[1]);
  if (off_10008C070) {
    return off_10008C070();
  }
  return sub_10006221C("trace_input_packet: no bootp packet handler.", a2, (uint64_t)a3, a4, a5, a6, a7, a8, a9);
}

uint64_t sub_100039F14(uint64_t a1, int a2, void *a3, size_t a4, int a5, uint64_t a6, uint64_t a7)
{
  if (sub_100068D58())
  {
    if (a7)
    {
      __int128 v26 = *(_OWORD *)a7;
      __int16 v27 = *(_WORD *)(a7 + 16);
      char v17 = 1;
    }

    else
    {
      char v17 = 0;
      __int128 v26 = 0uLL;
      __int16 v27 = 0;
    }

    char v28 = v17;
    v24[1] = 4;
    v24[2] = a5;
    int v18 = *(_DWORD *)(a6 + 4);
    v24[6] = 4;
    v24[7] = v18;
    __int16 v25 = *(_WORD *)(a6 + 2);
    v24[0] = bswap32(*(_DWORD *)(a1 + 148));
    int v20 = v24;
    int v21 = 68;
    __int128 v22 = a3;
    int v23 = a4;
    sub_1000693DC( qword_10008C0F8,  2LL,  (uint64_t)&v20,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/ctrace.c",  239LL,  v14,  v15,  v16);
  }

  return a4;
}

void sub_10003A060( uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 > 0x43)
  {
    unsigned int v8 = bswap32(*a3);
  }

  else
  {
    sub_10006221C("trace_input_packet: too short - %d", a2, (uint64_t)a3, a4, a5, a6, a7, a8, a2);
  }

uint64_t sub_10003A0D8(uint64_t a1, unsigned int a2)
{
  uint64_t result = sub_100068D58();
  if ((_DWORD)result)
  {
    unsigned int v8 = bswap32(a2);
    return sub_1000693B0( a1,  4,  (uint64_t)&v8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/ctrace.c",  279LL,  v5,  v6,  v7);
  }

  return result;
}

void sub_10003A12C( uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((_DWORD)a2 != 8) {
    sub_10006221C("trace_seed_input: wrong size (%d)", a2, (uint64_t)a3, a4, a5, a6, a7, a8, a2);
  }
  srandom(bswap32(*a3));
}

uint64_t sub_10003A174(void **a1, uint64_t a2, uint64_t a3)
{
  return sub_10005CE50(a1, (void *)qword_10008C058, 0LL, a2, a3);
}

uint64_t sub_10003A18C()
{
  uint64_t result = sub_100067CD0( &qword_10008C058,  (uint64_t)"interface",  (uint64_t)sub_10003A248,  (uint64_t)sub_10003A328,  (uint64_t)sub_10003A330,  (uint64_t)sub_10003A3EC,  (uint64_t)sub_10003A4DC,  (uint64_t)sub_10003A580,  (uint64_t)sub_10003A7C0,  (uint64_t)sub_10003A854,  0LL,  0LL,  0LL,  216LL,  (uint64_t)sub_10003A9E4,  2);
  if ((_DWORD)result)
  {
    char v1 = sub_100067900(result);
    sub_100061FB4("Can't register interface object type: %s", v2, v3, v4, v5, v6, v7, v8, v1);
  }

  return result;
}

uint64_t sub_10003A248(void *a1, int a2, uint64_t a3, _DWORD *a4)
{
  if (*a1 != qword_10008C058) {
    return 39LL;
  }
  if (!sub_100068648(a3, "name"))
  {
    if ((a4[1] - 1) <= 1)
    {
      size_t v12 = a4[2];
      if (v12 <= 0xF)
      {
        uint64_t v13 = (char *)a1 + 132;
        memcpy((char *)a1 + 132, a4 + 3, v12);
        uint64_t v4 = 0LL;
        v13[a4[2]] = 0;
        return v4;
      }
    }

    return 39LL;
  }

  uint64_t v8 = a1[3];
  if (!v8) {
    return 23LL;
  }
  unsigned int v9 = *(uint64_t (**)(void))(*(void *)v8 + 16LL);
  uint64_t v4 = 23LL;
  if (v9)
  {
    int v10 = v9();
    if (v10) {
      unsigned int v11 = 23;
    }
    else {
      unsigned int v11 = 0;
    }
    if (v10 == 42) {
      return 42LL;
    }
    else {
      return v11;
    }
  }

  return v4;
}

uint64_t sub_10003A328()
{
  return 27LL;
}

uint64_t sub_10003A330( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)a1 != qword_10008C058) {
    return 39LL;
  }
  size_t v12 = *(void **)(a1 + 192);
  if (v12)
  {
    sub_10005CE20(v12, a2, a3, a4, a5, a6, a7, a8);
    *(void *)(a1 + 192) = 0LL;
  }

  if (*(void *)(a1 + 32)) {
    sub_10005CFEC((_DWORD **)(a1 + 32), a2, a3);
  }
  uint64_t v13 = *(void **)(a1 + 160);
  if (v13)
  {
    sub_10005CE20(v13, a2, a3, a4, a5, a6, a7, a8);
    *(void *)(a1 + 16__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = 0LL;
  }

  if (*(void *)(a1 + 208)) {
    *(void *)(a1 + 208) = 0LL;
  }
  uint64_t v15 = *(void *)(a1 + 40);
  uint64_t v14 = (_DWORD **)(a1 + 40);
  if (v15) {
    sub_10005CFEC(v14, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/discover.c", 1530LL);
  }
  return 0LL;
}

uint64_t sub_10003A3EC(void *a1, char *__s1)
{
  if (*a1 != qword_10008C058) {
    return 39LL;
  }
  if (strcmp(__s1, "update")) {
    goto LABEL_4;
  }
  uint64_t v6 = &qword_10008C0A0;
  do
  {
    uint64_t v7 = (void *)*v6;
    uint64_t v6 = (uint64_t *)(*v6 + 32);
  }

  while (v7 != a1 && v7 != 0LL);
  if (v7) {
    BOOL v9 = off_10008C090 == 0LL;
  }
  else {
    BOOL v9 = 1;
  }
  if (!v9) {
    return off_10008C090(v7);
  }
  int v10 = &qword_10008C0D0;
  do
  {
    unsigned int v11 = (void *)*v10;
    int v10 = (uint64_t *)(*v10 + 32);
    if (v11) {
      BOOL v12 = v11 == a1;
    }
    else {
      BOOL v12 = 1;
    }
  }

  while (!v12);
  if (v11) {
    BOOL v13 = 1;
  }
  else {
    BOOL v13 = off_10008C090 == 0LL;
  }
  if (!v13)
  {
    uint64_t v7 = 0LL;
    return off_10008C090(v7);
  }

LABEL_4:
  uint64_t v4 = a1[3];
  if (!v4) {
    return 23LL;
  }
  uint64_t v5 = *(uint64_t (**)(void))(*(void *)v4 + 40LL);
  if (!v5) {
    return 23LL;
  }
  uint64_t result = v5();
  if ((_DWORD)result) {
    return 23LL;
  }
  return result;
}

  if (fcntl(v12, 2, 1LL) < 0) {
    sub_10006221C("Can't set close-on-exec on %s: %m", v13, v14, v15, v16, v17, v18, v19, (char)a1);
  }
  __buf = xmmword_100083220;
  int v20 = write(dword_1000C5F9C, &__buf, 0x10uLL);
  int v10 = v20;
  if ((v20 & 0x80000000) != 0)
  {
    sub_10006221C("%s(%d): trace_begin write failed: %m", v21, v22, v23, v24, v25, v26, v27, a2);
    return 34LL;
  }

  if ((_DWORD)v20 != 16)
  {
    sub_10006221C("%s(%d): trace_begin: short write (%d:%ld)", v21, v22, v23, v24, v25, v26, v27, a2);
    sub_100069268();
    return 34LL;
  }

  char v28 = qword_1000C5FA8;
  if (!qword_1000C5FA8) {
    return 0LL;
  }
  qword_1000C5FA8 = 0LL;
  while (1)
  {
    uint64_t v29 = *(void *)v28;
    if (*(_DWORD *)(v28 + 8))
    {
      uint64_t v30 = strlen(*(const char **)(v28 + 16));
    }

    char v28 = v29;
    if (!v29) {
      return 0LL;
    }
  }

  return v10;
}

uint64_t sub_10003A4DC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)a3 != qword_10008C058) {
    return 39LL;
  }
  uint64_t result = sub_10005F114(a1, "state");
  if (!(_DWORD)result)
  {
    uint64_t v7 = (*(_DWORD *)(a3 + 204) & 1) != 0 ? "up" : "down";
    uint64_t result = sub_10005F180(a1, v7);
    if (!(_DWORD)result)
    {
      uint64_t v8 = *(void *)(a3 + 24);
      if (v8)
      {
        BOOL v9 = *(void (**)(uint64_t, uint64_t))(*(void *)v8 + 48LL);
        if (v9) {
          v9(a1, a2);
        }
      }

      return 0LL;
    }
  }

  return result;
}

uint64_t sub_10003A580(void *a1, int a2, uint64_t a3)
{
  int v20 = 0LL;
  if (!a3) {
    return 46LL;
  }
  if (!sub_1000683F8(a3, a2, "handle"))
  {
    uint64_t v6 = sub_100062F48(a1, v20[2]);
    sub_10005D71C(&v20, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/discover.c", 1621LL);
    if ((_DWORD)v6) {
      return v6;
    }
    if (*(void *)*a1 != qword_10008C058)
    {
      sub_10005CFEC((_DWORD **)a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/discover.c", 1627LL);
      return 39LL;
    }
  }

  uint64_t v7 = qword_10008C0D0;
  if (qword_10008C0D0)
  {
    uint64_t v8 = v20[2];
    size_t v9 = v8[2];
    int v10 = v8 + 3;
    while (1)
    {
      unsigned int v11 = memchr((const void *)(v7 + 132), 0, 0x10uLL);
      int v12 = (_DWORD)v11 - (v7 + 132);
      if (!v11) {
        int v12 = 16;
      }
      uint64_t v7 = *(void *)(v7 + 32);
      if (!v7) {
        goto LABEL_18;
      }
    }
  }

  else
  {
LABEL_18:
    uint64_t v7 = qword_10008C0A0;
    if (qword_10008C0A0)
    {
      BOOL v13 = v20[2];
      size_t v14 = v13[2];
      uint64_t v15 = v13 + 3;
      do
      {
        uint64_t v16 = memchr((const void *)(v7 + 132), 0, 0x10uLL);
        int v17 = (_DWORD)v16 - (v7 + 132);
        if (!v16) {
          int v17 = 16;
        }
        uint64_t v7 = *(void *)(v7 + 32);
      }

      while (v7);
    }
  }

  sub_10005D71C(&v20, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/discover.c", 1667LL);
  int v18 = (_DWORD *)*a1;
  if (*a1 && v18 != (_DWORD *)v7)
  {
    sub_10005CFEC((_DWORD **)a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/discover.c", 1669LL);
    return 44LL;
  }

  if (v7)
  {
    if (!v18) {
      sub_10005CFB8(a1, v7);
    }
LABEL_4:
    if (*a1) {
      return 0LL;
    }
    else {
      return 46LL;
    }
  }

  if (v18) {
    sub_10005CFEC((_DWORD **)a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/discover.c", 1673LL);
  }
  return 23LL;
}

uint64_t sub_10003A7C0(void *a1)
{
  uint64_t v5 = 0LL;
  uint64_t v2 = sub_10005CE50( (void **)&v5,  (void *)qword_10008C058,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/discover.c",  1696LL);
  if (!(_DWORD)v2)
  {
    uint64_t v3 = (uint64_t)v5;
    v5[51] = 1;
    uint64_t v2 = sub_10005CFB8(a1, v3);
    sub_10005CFEC(&v5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/discover.c", 1701LL);
  }

  return v2;
}

uint64_t sub_10003A854(uint64_t a1)
{
  uint64_t v1 = qword_10008C0D0;
  if (!qword_10008C0D0) {
    return 23LL;
  }
  if (qword_10008C0D0 != a1)
  {
    while (1)
    {
      uint64_t v3 = *(void *)(v1 + 32);
      if (!v3) {
        return 23LL;
      }
      uint64_t v4 = v1;
      uint64_t v1 = *(void *)(v1 + 32);
      if (v3 == a1)
      {
        if (!v4) {
          break;
        }
        uint64_t v5 = (uint64_t *)(v4 + 32);
        sub_10005CFEC( (_DWORD **)(v4 + 32),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/discover.c",  1717LL);
        uint64_t v6 = *(void *)(a1 + 32);
        if (v6)
        {
          uint64_t v7 = v5;
          goto LABEL_11;
        }

        goto LABEL_12;
      }
    }
  }

  sub_10005CFEC( (_DWORD **)&qword_10008C0D0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/discover.c",  1722LL);
  uint64_t v6 = *(void *)(a1 + 32);
  if (v6)
  {
    uint64_t v7 = &qword_10008C0D0;
LABEL_11:
    sub_10005CFB8(v7, v6);
  }

uint64_t sub_10003A9E4(uint64_t a1)
{
  *(void *)(a1 + 152) = -1LL;
  return 0LL;
}

void *sub_10003A9F4()
{
  qword_10008C0C0 = (uint64_t)sub_100068E0C( "interface",  0LL,  (uint64_t)sub_100039A3C,  (uint64_t)nullsub_4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/discover.c",  117LL);
  qword_10008C0B0 = (uint64_t)sub_100068E0C( "inpacket",  0LL,  (uint64_t)sub_100039DE4,  (uint64_t)nullsub_5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/discover.c",  120LL);
  uint64_t result = sub_100068E0C( "outpacket",  0LL,  (uint64_t)sub_10003A060,  (uint64_t)nullsub_6,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/discover.c",  123LL);
  qword_10008C0F8 = (uint64_t)result;
  return result;
}

uint64_t sub_10003AAA4(uint64_t a1)
{
  if (getifaddrs((ifaddrs **)a1))
  {
    sub_10006221C("Error getting interfaces; %m", v2, v3, v4, v5, v6, v7, v8, v10);
    return 0LL;
  }

  else
  {
    *(void *)(a1 + 8) = *(void *)a1;
    return 1LL;
  }

uint64_t sub_10003AAE8(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 + 8);
  if (v4)
  {
    uint64_t v7 = *(const char **)(v4 + 8);
    if (strlen(v7) < 0x10)
    {
      __strcpy_chk(a1);
      memcpy( (void *)(a1 + 16),  *(const void **)(*(void *)(a3 + 8) + 24LL),  **(unsigned __int8 **)(*(void *)(a3 + 8) + 24LL));
      LODWORD(v4) = 0;
      uint64_t v16 = *(void *)(a3 + 8);
      *(void *)(a1 + 144) = *(unsigned int *)(v16 + 16);
      *(void *)(a3 + 8) = *(void *)v16;
      uint64_t result = 1LL;
    }

    else
    {
      sub_10006221C("Interface name '%s' too long", v8, v9, v10, v11, v12, v13, v14, (char)v7);
      uint64_t result = 0LL;
      LODWORD(v4) = 1;
    }
  }

  else
  {
    uint64_t result = 0LL;
  }

  *a2 = v4;
  return result;
}

void sub_10003ABA0(uint64_t a1)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + 8) = 0LL;
}

void sub_10003ABC8(uint64_t a1, _DWORD *a2)
{
  uint64_t v4 = *(_DWORD **)(a1 + 72);
  if (v4)
  {
    int v5 = *(_DWORD *)(a1 + 80);
    int v6 = *(_DWORD *)(a1 + 84);
    if (v5 >= v6)
    {
      int v7 = v6 + 4;
      uint64_t v8 = sub_10005CDE4((4 * (v6 + 4)));
      uint64_t v4 = v8;
      if (!v8) {
        sub_100061FB4("Out of memory saving IPv4 address on interface.", v9, v10, v11, v12, v13, v14, v15, v28);
      }
      memcpy(v8, *(const void **)(a1 + 72), 4LL * *(int *)(a1 + 84));
      sub_10005CE20( *(void **)(a1 + 72),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/discover.c",  861LL,  v16,  v17,  v18,  v19,  v20);
      *(void *)(a1 + 72) = v4;
      *(_DWORD *)(a1 + 84) = v7;
      int v5 = *(_DWORD *)(a1 + 80);
    }
  }

  else
  {
    uint64_t v4 = sub_10005CDE4(0x10uLL);
    *(void *)(a1 + 72) = v4;
    if (!v4) {
      sub_100061FB4("Out of memory saving IPv4 address on interface.", v21, v22, v23, v24, v25, v26, v27, v28);
    }
    int v5 = 0;
    *(_DWORD *)(a1 + 84) = 4;
  }

  *(_DWORD *)(a1 + 8__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = v5 + 1;
  v4[v5] = *a2;
}

__n128 sub_10003ACB4(uint64_t a1, __n128 *a2)
{
  uint64_t v4 = *(__n128 **)(a1 + 88);
  if (v4)
  {
    int v5 = *(_DWORD *)(a1 + 96);
    int v6 = *(_DWORD *)(a1 + 100);
    if (v5 >= v6)
    {
      int v7 = v6 + 8;
      uint64_t v8 = (__n128 *)sub_10005CDE4((16 * (v6 + 8)));
      uint64_t v4 = v8;
      if (!v8) {
        sub_100061FB4("Out of memory saving IPv6 address on interface.", v9, v10, v11, v12, v13, v14, v15, v29);
      }
      memcpy(v8, *(const void **)(a1 + 88), 16LL * *(int *)(a1 + 100));
      sub_10005CE20( *(void **)(a1 + 88),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/discover.c",  899LL,  v16,  v17,  v18,  v19,  v20);
      *(void *)(a1 + 88) = v4;
      *(_DWORD *)(a1 + 10__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = v7;
      int v5 = *(_DWORD *)(a1 + 96);
    }
  }

  else
  {
    uint64_t v4 = (__n128 *)sub_10005CDE4(0x80uLL);
    *(void *)(a1 + 88) = v4;
    if (!v4) {
      sub_100061FB4("Out of memory saving IPv6 address on interface.", v21, v22, v23, v24, v25, v26, v27, v29);
    }
    int v5 = 0;
    *(_DWORD *)(a1 + 10__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = 8;
  }

  *(_DWORD *)(a1 + 96) = v5 + 1;
  __n128 result = *a2;
  v4[v5] = *a2;
  return result;
}

void sub_10003ADA0(int a1)
{
  if (!qword_10008C0D0 || (int v9 = 0, v180 = 1, (a1 - 3) >= 2) && a1 != 1)
  {
    char v180 = 0;
    if (a1 == 2) {
      int v9 = 3;
    }
    else {
      int v9 = 1;
    }
  }

  if (sub_10003AAE8((uint64_t)__s2, &v183, (uint64_t)v184))
  {
    while (1)
    {
      for (uint64_t i = qword_10008C0D0; ; uint64_t i = *(void *)(i + 32))
      {
        uint64_t v182 = (in_addr_t **)i;
        if (!i) {
          break;
        }
        if (!strcmp((const char *)(i + 132), __s2))
        {
          if (a1 != 2 && (v190 & 1) == 0) {
            goto LABEL_50;
          }
          goto LABEL_22;
        }
      }

      if ((v190 & 0x1A) != 2 || a1 != 2 && (v190 & 1) == 0) {
        goto LABEL_50;
      }
      unsigned int v18 = sub_10005CE50( (void **)&v182,  (void *)qword_10008C058,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/discover.c",  971LL);
      if (v18)
      {
        sub_100067900(v18);
        sub_100061FB4("Error allocating interface %s: %s", v19, v20, v21, v22, v23, v24, v25, (char)__s2);
      }

      __strcpy_chk((char *)v182 + 132);
      sub_10003B7F8((uint64_t)v182, v9);
      sub_10005CFEC((_DWORD **)&v182, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/discover.c", 978LL);
      uint64_t i = qword_10008C0D0;
      uint64_t v182 = (in_addr_t **)qword_10008C0D0;
LABEL_22:
      if (off_10008C078) {
        off_10008C078(i);
      }
      if (v187 == 2 && dword_100089B0C == 2) {
        break;
      }
      if (v187 != 30 || dword_100089B0C != 30) {
        goto LABEL_50;
      }
      unsigned __int32 v27 = v189.n128_u32[0] | v189.n128_u32[1] | v189.n128_u32[2];
      if (v27 || v189.n128_u32[3] != 0x1000000)
      {
        if (v189.n128_u32[3]) {
          BOOL v29 = 0;
        }
        else {
          BOOL v29 = v27 == 0;
        }
        uint64_t v28 = (uint64_t)v182;
        if (v29) {
          *((_DWORD *)v182 + 5__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = 1;
        }
      }

      else
      {
        uint64_t v28 = (uint64_t)v182;
        if (a1 == 1 && (*((_DWORD *)v182 + 51) & 2) != 0) {
          goto LABEL_50;
        }
      }

      sub_10003ACB4(v28, &v189);
      v185[0] = 16;
      *(__n128 *)&v185[1] = v189;
LABEL_48:
      if (off_10008C080) {
        off_10008C080(v182, v185);
      }
LABEL_50:
    }

    if (v188 == 16777343)
    {
      uint64_t v26 = v182;
      if (a1 == 1 && (*((_DWORD *)v182 + 51) & 2) != 0) {
        goto LABEL_50;
      }
    }

    else
    {
      if (!v188)
      {
        uint64_t v26 = v182;
LABEL_41:
        sub_10003ABC8((uint64_t)v26, &v188);
        v185[0] = 4;
        v185[1] = v188;
        goto LABEL_48;
      }

      uint64_t v26 = v182;
    }

    *((_DWORD *)v26 + 5__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = 1;
    goto LABEL_41;
  }

uint64_t sub_10003B7F8(uint64_t a1, int a2)
{
  uint64_t v4 = (const char *)(a1 + 132);
  *(void *)(a1 + 104) = v4;
  *(_DWORD *)(a1 + 112) = strlen(v4);
  *(void *)(a1 + 12__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = 0LL;
  *(_DWORD *)(a1 + 128) = 0;
  *(_DWORD *)(a1 + 204) = a2;
  if (qword_10008C0D0)
  {
    sub_10005CFB8((void *)(a1 + 32), qword_10008C0D0);
    sub_10005CFEC( (_DWORD **)&qword_10008C0D0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/discover.c",  1811LL);
  }

  return sub_10005CFB8(&qword_10008C0D0, a1);
}

char *sub_10003B884(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 148);
  int v3 = dword_10008C0BC;
  if (v2 == -1)
  {
    int v4 = dword_10008C0B8;
    if (dword_10008C0BC <= dword_10008C0B8) {
      int v2 = dword_10008C0B8;
    }
    else {
      int v2 = dword_10008C0BC;
    }
    uint64_t v5 = v2 - (uint64_t)dword_10008C0B8;
    uint64_t v6 = (uint64_t *)(qword_10008C0C8 + 8LL * dword_10008C0B8);
    while (v5)
    {
      uint64_t v7 = *v6++;
      ++v4;
      --v5;
      if (!v7)
      {
        int v2 = v4 - 1;
        goto LABEL_10;
      }
    }

    int v4 = v2 + 1;
LABEL_10:
    dword_10008C0B8 = v4;
    *(_DWORD *)(a1 + 148) = v2;
  }

  int v8 = v2 - v3;
  if (v2 >= v3)
  {
    __n128 result = (char *)sub_10005CDE4((8 * v2 + 80));
    if (!result) {
      return result;
    }
    int v9 = result;
    int v11 = v8 + 10;
    bzero(&result[8 * dword_10008C0BC], 8LL * v11);
    dword_10008C0BC += v11;
    if (qword_10008C0C8)
    {
      memcpy(v9, (const void *)qword_10008C0C8, 8LL * dword_10008C0B8);
      sub_10005CE20( (void *)qword_10008C0C8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/discover.c",  1789LL,  v12,  v13,  v14,  v15,  v16);
    }

    qword_10008C0C8 = (uint64_t)v9;
    int v2 = *(_DWORD *)(a1 + 148);
  }

  else
  {
    int v9 = (void *)qword_10008C0C8;
  }

  sub_10005CFB8((void *)v9 + v2, a1);
  int v17 = *(_DWORD *)(a1 + 148);
  if (v17 >= dword_10008C0B8) {
    dword_10008C0B8 = v17 + 1;
  }
  return (char *)sub_100039980(qword_10008C0C0, a1);
}

uint64_t sub_10003B9F0(uint64_t a1)
{
  if (*(void *)a1 == qword_10008C058) {
    return *(unsigned int *)(a1 + 152);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_10003BA14()
{
  unsigned int v0 = (const char *)__chkstk_darwin();
  int v13 = 0;
  if (*(void *)v0 != qword_10008C058) {
    return 39LL;
  }
  int v2 = v0;
  uint64_t v10 = sub_1000529CC((uint64_t)v0, (uint64_t)v18, 0x10000LL, v15, &v14, &v13);
  if ((v10 & 0x80000000) != 0)
  {
    sub_10006221C("receive_packet6() failed on %s: %m", v3, v4, v5, v6, v7, v8, v9, (_BYTE)v2 - 124);
    return 34LL;
  }

  else if (v13)
  {
    if (off_10008C098)
    {
      BOOL v11 = v14 != 255;
      int v19 = 16;
      __int128 v20 = v17;
      while (1)
      {
        unsigned int v12 = if_nametoindex(v2 + 132);
        if (v12 == v13) {
          break;
        }
        int v2 = (const char *)*((void *)v2 + 4);
        if (!v2) {
          return 23LL;
        }
      }

      off_10008C098(v2, v18, v10, v16, &v19, v11);
    }

    return 0LL;
  }

  else
  {
    return 23LL;
  }

uint64_t sub_10003BB68(void *a1)
{
  if (*a1 != qword_10008C058) {
    return 39LL;
  }
  while (1)
  {
    uint64_t v3 = sub_100035674((uint64_t)a1, v10, 0x1000uLL, (uint64_t)v12, (uint64_t)v11);
    if ((v3 & 0x80000000) != 0) {
      break;
    }
    if (off_10008C070) {
      ((void (*)(void *, _BYTE *))off_10008C070)(a1, v10);
    }
    if (a1[22] == a1[23]) {
      return 0LL;
    }
  }

  sub_10006221C("receive_packet failed on %s: %m", v4, v3, v5, v6, v7, v8, v9, (_BYTE)a1 - 124);
  return 34LL;
}

BOOL sub_10003BC78(void *a1, uint64_t a2, uint64_t a3)
{
  unsigned int v4 = sub_10005CE50((void **)&qword_10008C0A8, (void *)qword_10008C058, 0LL, a2, a3);
  if (v4)
  {
    char v5 = sub_100067900(v4);
    sub_100061FB4("Error allocating fallback interface: %s", v6, v7, v8, v9, v10, v11, v12, v5);
  }

  uint64_t v13 = qword_10008C0A8;
  *(_BYTE *)(qword_10008C0A8 + 14__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = 0;
  *(void *)(v13 + 132) = *(void *)"fallback";
  if (off_10008C080)
  {
    off_10008C080(v13, 0LL);
    uint64_t v13 = qword_10008C0A8;
  }

  int v14 = sub_10005CFB8(a1, v13);
  uint64_t v15 = qword_10008C0A8;
  *(_DWORD *)(qword_10008C0A8 + 148) = -1;
  sub_10003B884(v15);
  return v14 == 0;
}

uint64_t sub_10003BD48()
{
  for (uint64_t i = qword_10008C0D0; i; uint64_t i = *(void *)(i + 32))
  {
    nullsub_3(i);
    nullsub_3(i);
  }

  uint64_t result = qword_10008C0A8;
  if (qword_10008C0A8) {
    uint64_t result = nullsub_3(qword_10008C0A8);
  }
  dword_10008C0D8 = 1;
  return result;
}

uint64_t sub_10003BDA0(uint64_t result)
{
  if (qword_10008CE80 != result)
  {
    qword_10008CE80 = result;
    dword_10008CE88 = 0;
    return sub_10003BDC8(0LL);
  }

  return result;
}

uint64_t sub_10003BDC8(uint64_t a1)
{
  uint64_t v1 = qword_10008C108;
  if (!qword_10008C108) {
    return 0LL;
  }
  while (1)
  {
    uint64_t v3 = *(void *)(v1 + 8);
    if (v3 >= qword_10008CE80 && (v3 != qword_10008CE80 || *(_DWORD *)(v1 + 16) > dword_10008CE88)) {
      break;
    }
    qword_10008C108 = *(void *)v1;
    (*(void (**)(void))(v1 + 24))(*(void *)(v1 + 32));
    unsigned int v4 = *(void (**)(uint64_t, const char *, uint64_t))(v1 + 48);
    if (v4) {
      v4(v1 + 32, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/dispatch.c", 65LL);
    }
    *(void *)uint64_t v1 = qword_1000BD318;
    qword_1000BD318 = v1;
    uint64_t v1 = qword_10008C108;
    if (!qword_10008C108) {
      return 0LL;
    }
  }

  if (a1)
  {
    *(void *)a1 = v3;
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(v1 + 16);
  }

  return a1;
}

void sub_10003BEA0()
{
  do
  {
    unsigned int v0 = (__darwin_time_t *)sub_10003BDC8((uint64_t)v10);
    unsigned int v1 = sub_1000612EC(0LL, v0);
  }

  while ((v1 & 0xFFFFFFFD) == 0);
  char v2 = sub_100067900(v1);
  sub_100061FB4("omapi_one_dispatch failed: %s -- exiting.", v3, v4, v5, v6, v7, v8, v9, v2);
}

  ;
}

uint64_t **sub_10003BEE8( uint64_t **result, uint64_t a2, uint64_t *a3, uint64_t (*a4)(void, void, void, void), uint64_t a5)
{
  uint64_t v9 = result;
  uint64_t v10 = (uint64_t *)qword_10008C108;
  if (qword_10008C108)
  {
    uint64_t v11 = 0LL;
    while (1)
    {
      uint64_t v12 = v10;
      if ((!a2 || v10[3] == a2) && v10[4] == a3) {
        break;
      }
      uint64_t v10 = (uint64_t *)*v10;
      uint64_t v11 = v12;
      if (!*v12) {
        goto LABEL_7;
      }
    }

    uint64_t v20 = *v10;
    if (v11) {
      *uint64_t v11 = v20;
    }
    else {
      qword_10008C108 = v20;
    }
  }

  else
  {
LABEL_7:
    uint64_t v12 = (uint64_t *)qword_1000BD318;
    if (qword_1000BD318)
    {
      qword_1000BD318 = *(void *)qword_1000BD318;
    }

    else
    {
      uint64_t v12 = (uint64_t *)sub_10005CDE4(0x38uLL);
      if (!v12) {
        sub_10003C134(0LL, v13, v14, v15, v16, v17, v18, v19);
      }
    }

    *(_OWORD *)uint64_t v12 = 0u;
    *((_OWORD *)v12 + 1) = 0u;
    *((_OWORD *)v12 + 2) = 0u;
    uint64_t result = (uint64_t **)(v12 + 4);
    v12[3] = a2;
    v12[5] = (uint64_t)a4;
    v12[6] = a5;
    if (a4) {
      uint64_t result = (uint64_t **)a4( result,  (uint64_t *)a3,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/dispatch.c",  138LL);
    }
    else {
      char *result = (uint64_t *)a3;
    }
  }

  uint64_t v21 = *v9;
  v12[1] = (uint64_t)*v9;
  int v22 = *((_DWORD *)v9 + 2);
  *((_DWORD *)v12 + 4) = v22;
  uint64_t v23 = (uint64_t **)qword_10008C108;
  if (qword_10008C108
    && (uint64_t v24 = *(uint64_t **)(qword_10008C108 + 8), (uint64_t)v24 <= (uint64_t)v21)
    && (v24 != v21 || *(_DWORD *)(qword_10008C108 + 16) <= v22))
  {
    uint64_t v25 = *(uint64_t ***)qword_10008C108;
    if (*(void *)qword_10008C108)
    {
      uint64_t v26 = v25[1];
      if ((uint64_t)v26 <= (uint64_t)v21)
      {
        while (1)
        {
          unsigned __int32 v27 = v25;
          if (v26 == v21 && *((_DWORD *)v25 + 4) > v22) {
            break;
          }
          uint64_t v25 = (uint64_t **)*v25;
          if (!*v27)
          {
            uint64_t v23 = v27;
            goto LABEL_30;
          }

          uint64_t v26 = v25[1];
          uint64_t v23 = v27;
        }
      }

      unsigned __int32 v27 = v23;
LABEL_28:
      *uint64_t v12 = (uint64_t)v25;
      const char *v27 = v12;
    }

    else
    {
LABEL_30:
      *uint64_t v23 = v12;
      *uint64_t v12 = 0LL;
    }
  }

  else
  {
    *uint64_t v12 = qword_10008C108;
    qword_10008C108 = (uint64_t)v12;
  }

  return result;
}

uint64_t sub_10003C09C(uint64_t result, uint64_t a2)
{
  char v2 = (uint64_t *)qword_10008C108;
  if (qword_10008C108)
  {
    uint64_t v3 = 0LL;
    while (1)
    {
      uint64_t v4 = v2;
      if (v2[3] == result && v2[4] == a2) {
        break;
      }
      char v2 = (uint64_t *)*v2;
      uint64_t v3 = v4;
      if (!*v4) {
        return result;
      }
    }

    if (!v3) {
      uint64_t v3 = &qword_10008C108;
    }
    *uint64_t v3 = *v2;
    uint64_t v5 = (uint64_t (*)(uint64_t *, const char *, uint64_t))v2[6];
    if (v5) {
      uint64_t result = v5(v2 + 4, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/dispatch.c", 195LL);
    }
    *uint64_t v4 = qword_1000BD318;
    qword_1000BD318 = (uint64_t)v4;
  }

  return result;
}

void sub_10003C134( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

uint64_t sub_10003C14C(void *a1, uint64_t a2, uint64_t a3)
{
  if (!a3) {
    return 23LL;
  }
  uint64_t v4 = *(void **)(a3 + 40);
  if (!v4) {
    return 47LL;
  }
  uint64_t v6 = (const char *)v4[4];
  if (!v6) {
    return 48LL;
  }
  if (strlen(v6) > 0x401) {
    return 48LL;
  }
  uint64_t v7 = (const char *)v4[5];
  if (!v7) {
    return 48LL;
  }
  if (strlen(v7) > 0x401) {
    return 48LL;
  }
  uint64_t v8 = v4[6];
  if (!v8 || !*(_DWORD *)(v8 + 4)) {
    return 48LL;
  }
  uint64_t v9 = (char *)sub_10005CDE4(0x818uLL);
  if (v9)
  {
    uint64_t v10 = v9;
    bzero(v9, 0x818uLL);
    uint64_t v11 = sub_10005CDE4(*(unsigned int *)(*(void *)(*(void *)(a3 + 40) + 48LL) + 4LL));
    *((void *)v10 + 257) = v11;
    if (v11)
    {
      __strcpy_chk(v10);
      __strcpy_chk(v10 + 1025);
      memcpy( *((void **)v10 + 257),  (const void *)(*(void *)(*(void *)(a3 + 40) + 48LL) + 8LL),  *(unsigned int *)(*(void *)(*(void *)(a3 + 40) + 48LL) + 4LL));
      uint64_t result = 0LL;
      *((_DWORD *)v10 + 516) = *(_DWORD *)(*(void *)(*(void *)(a3 + 40) + 48LL) + 4LL);
      *a1 = v10;
      return result;
    }

    sub_10005CE20( v10,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/dns.c",  152LL,  v12,  v13,  v14,  v15,  v16);
  }

  return 1LL;
}

void sub_10003C28C( void ***a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *a1;
  if (v9[257])
  {
    sub_10005CE20( v9[257],  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/dns.c",  167LL,  a4,  a5,  a6,  a7,  a8);
    uint64_t v9 = *a1;
  }

  sub_10005CE20(v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/dns.c", 168LL, a4, a5, a6, a7, a8);
  *a1 = 0LL;
}

uint64_t sub_10003C2E0( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v21 = 0LL;
  if (qword_10008C110)
  {
    sub_100063738( &v21,  (uint64_t (**)(unsigned __int8 *, int, unsigned int))qword_10008C110,  *(const char **)(a1 + 16),  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/dns.c",  179LL,  a7,  a8);
    if (v21 == (char *)a1)
    {
      sub_10003C3F8( &v21,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/dns.c",  181LL,  v9,  v10,  v11,  v12,  v13);
      return 0LL;
    }

    if (v21)
    {
      sub_100063620( qword_10008C110,  *(const char **)(a1 + 16),  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/dns.c",  186LL,  v11,  v12,  v13);
      sub_10003C3F8( &v21,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/dns.c",  187LL,  v14,  v15,  v16,  v17,  v18);
    }
  }

  else if (!sub_100063100( &qword_10008C110,  (uint64_t)sub_100034D3C,  (uint64_t)sub_10003C3F8,  0,  sub_1000631AC,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/dns.c",  190LL,  a8))
  {
    return 1LL;
  }

  sub_1000634B8( qword_10008C110,  *(const char **)(a1 + 16),  0LL,  a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/dns.c",  193LL,  v12,  v13,  v20);
  return 0LL;
}

uint64_t sub_10003C3F8( char **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && (uint64_t v10 = *a1) != 0LL)
  {
    *a1 = 0LL;
    int v11 = (*(_DWORD *)v10)--;
    if (v11 > 1) {
      return 1LL;
    }
    if (v11 == 1)
    {
      uint64_t v12 = (void *)*((void *)v10 + 2);
      if (v12) {
        sub_10005CE20(v12, a2, a3, a4, a5, a6, a7, a8);
      }
      if (*((void *)v10 + 5)) {
        sub_10005DBA4(v10 + 40, a2, a3);
      }
      if (*((void *)v10 + 3)) {
        sub_100040E08((int **)v10 + 3, a2, a3, a4, a5, a6, a7, a8);
      }
      if (*((void *)v10 + 4)) {
        sub_100040E08((int **)v10 + 4, a2, a3, a4, a5, a6, a7, a8);
      }
      sub_10005CE20(v10, a2, a3, a4, a5, a6, a7, a8);
      return 1LL;
    }

    sub_10006221C("%s(%d): negative refcnt!", a2, a3, a4, a5, a6, a7, a8, a2);
  }

  else
  {
    sub_10006221C("%s(%d): null pointer", a2, a3, a4, a5, a6, a7, a8, a2);
  }

  return 0LL;
}

uint64_t sub_10003C4E8( uint64_t *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_100063100(a1, (uint64_t)sub_100034D3C, (uint64_t)sub_10003C3F8, a2, sub_1000631AC, a3, a4, a8);
}

uint64_t sub_10003C510(void *a1, char *__s)
{
  char v2 = (uint64_t (**)(unsigned __int8 *, int, unsigned int))qword_10008C110;
  if (!qword_10008C110) {
    return 23LL;
  }
  uint64_t v3 = __s;
  size_t v5 = strlen(__s);
  if (v3[(uint64_t)((v5 << 32) - 0x100000000LL) >> 32] == 46)
  {
    uint64_t v8 = 0LL;
  }

  else
  {
    size_t v10 = v5;
    int v11 = (char *)sub_10005CDE4((v5 + 2));
    if (!v11) {
      return 1LL;
    }
    uint64_t v8 = v11;
    uint64_t v12 = strcpy(v11, v3);
    v12[(int)v10] = 46;
    v12[(uint64_t)((uint64_t)&_mh_execute_header + (v10 << 32)) >> 32] = 0;
    char v2 = (uint64_t (**)(unsigned __int8 *, int, unsigned int))qword_10008C110;
    uint64_t v3 = v12;
  }

  if (sub_100063738( a1,  v2,  v3,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/dns.c",  216LL,  v6,  v7)) {
    uint64_t v9 = 0LL;
  }
  else {
    uint64_t v9 = 23LL;
  }
  if (v8) {
    sub_10005CE20( v8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/dns.c",  222LL,  v13,  v14,  v15,  v16,  v17);
  }
  return v9;
}

uint64_t sub_10003C61C( char *__s, uint64_t a2, char *a3, size_t a4, uint64_t a5, int a6, _DWORD *a7, void *a8)
{
  int v49 = 0LL;
  if (!a8) {
    return 23LL;
  }
  uint64_t v8 = __s;
  if (!__s || !*__s) {
    return 39LL;
  }
  while (1)
  {
    uint64_t v15 = sub_10003C510(&v49, v8);
    if (!(_DWORD)v15) {
      break;
    }
    uint64_t v21 = v15;
    int v22 = strchr(v8, 46);
    if (!v22) {
      return v21;
    }
    uint64_t v8 = v22 + 1;
  }

  uint64_t v24 = *((void *)v49 + 1);
  if (v24) {
    BOOL v25 = v24 < qword_10008CE80;
  }
  else {
    BOOL v25 = 0;
  }
  if (v25)
  {
    sub_10003C3F8( &v49,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/dns.c",  315LL,  v16,  v17,  v18,  v19,  v20);
    return 20LL;
  }

  else if (strlen(*((const char **)v49 + 2)) <= a4)
  {
    strcpy(a3, *((const char **)v49 + 2));
    uint64_t v46 = 0LL;
    uint64_t v47 = 0LL;
    uint64_t v48 = 0LL;
    uint64_t v35 = *((void *)v49 + 3);
    if (v35
      && sub_100057AA4( &v46,  0LL,  0LL,  0LL,  0LL,  0LL,  &unk_10008C730,  v35,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/dns.c",  336))
    {
      if (a6 < 1)
      {
        LODWORD(v37) = 0;
      }

      else
      {
        uint64_t v37 = 0LL;
        unint64_t v38 = v48;
        uint64_t v39 = v47;
        unint64_t v40 = 4LL;
        while (v40 <= v38)
        {
          *(_DWORD *)(a5 + 4 * v37) = *(_DWORD *)(v39 + 4 * v37);
          ++v37;
          v40 += 4LL;
          if (a6 == v37)
          {
            LODWORD(v37) = a6;
            break;
          }
        }
      }

      sub_100034EA8( &v46,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/dns.c",  345LL,  v31,  v32,  v33,  v34,  v36);
    }

    else
    {
      LODWORD(v37) = 0;
    }

    uint64_t v41 = *((void *)v49 + 4);
    if (v41
      && sub_100057AA4( &v46,  0LL,  0LL,  0LL,  0LL,  0LL,  &unk_10008C730,  v41,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/dns.c",  355))
    {
      if ((int)v37 < a6)
      {
        uint64_t v42 = 0LL;
        unint64_t v43 = v48;
        uint64_t v44 = v47;
        uint64_t v45 = a5 + 4LL * v37;
        while (v42 + 4 <= v43)
        {
          *(_DWORD *)(v45 + v42) = *(_DWORD *)(v44 + v42);
          LODWORD(v37) = v37 + 1;
          v42 += 4LL;
          if ((int)v37 >= a6)
          {
            LODWORD(v37) = a6;
            break;
          }
        }
      }

      sub_100034EA8( &v46,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/dns.c",  364LL,  v31,  v32,  v33,  v34,  v41);
    }

    if (!*a8) {
      sub_100034D3C( a8,  v49,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/dns.c",  372LL,  v32,  v33,  v34,  v41);
    }
    sub_10003C3F8( &v49,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/dns.c",  373LL,  v31,  v32,  v33,  v34,  v41);
    uint64_t v21 = 0LL;
    if (a7) {
      *a7 = v37;
    }
  }

  else
  {
    sub_10003C3F8( &v49,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/dns.c",  321LL,  v26,  v27,  v28,  v29,  v30);
    return 19LL;
  }

  return v21;
}

uint64_t sub_10003C8CC( char **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_10003C3F8( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/dns.c",  381LL,  a4,  a5,  a6,  a7,  a8);
}

uint64_t sub_10003C8DC( char **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *((void *)*a1 + 1) = qword_10008CE80 - 1;
  return sub_10003C3F8( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/dns.c",  393LL,  a4,  a5,  a6,  a7,  a8);
}

char *sub_10003C904(int a1, char *__s, const void *a3, int a4)
{
  uint64_t v37 = 0LL;
  int v7 = strlen(__s);
  if (__s[v7 - 1] == 46) {
    int v8 = 0;
  }
  else {
    int v8 = v7;
  }
  if (!sub_10003C510(&v37, __s))
  {
    uint64_t result = v37;
    if (!*((void *)v37 + 1)) {
      return result;
    }
    if (*((void *)v37 + 3))
    {
      sub_100040E08( (int **)v37 + 3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/dns.c",  412LL,  v9,  v10,  v11,  v12,  v13);
      uint64_t result = v37;
    }

    uint64_t v16 = *((void *)result + 4);
    uint64_t v15 = (int **)(result + 32);
    if (v16) {
      sub_100040E08( v15,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/dns.c",  414LL,  v9,  v10,  v11,  v12,  v13);
    }
LABEL_12:
    uint64_t v17 = v37;
    if (!*((void *)v37 + 2))
    {
      int v33 = strlen(__s);
      if (v8) {
        int v34 = 2;
      }
      else {
        int v34 = 1;
      }
      uint64_t v35 = (char *)sub_10005CDE4((v34 + v33));
      *((void *)v37 + 2) = v35;
      if (!v35)
      {
        uint64_t v36 = 422LL;
        return (char *)sub_10003C3F8( &v37,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/dns.c",  v36,  v18,  v19,  v20,  v21,  v22);
      }

      strcpy(v35, __s);
      uint64_t v17 = v37;
      if (v8)
      {
        *(_BYTE *)(*((void *)v37 + 2) + v8) = 46;
        *(_BYTE *)(*((void *)v37 + 2) + v8 + 1LL) = 0;
        uint64_t v17 = v37;
      }
    }

    *((void *)v17 + 1) = qword_10008CE80 + 1800;
    if (sub_100034540( (void *)v17 + 3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/dns.c",  437LL,  v9,  v10,  v11,  v12,  v13))
    {
      uint64_t v23 = 4LL * a4;
      if (sub_1000345C4( (void *)(*((void *)v37 + 3) + 32LL),  v23,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/dns.c",  442LL))
      {
        memcpy((void *)(*(void *)(*((void *)v37 + 3) + 32LL) + 4LL), a3, v23);
        uint64_t v24 = v37;
        uint64_t v25 = *((void *)v37 + 3);
        *(void *)(v25 + 4__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = *(void *)(v25 + 32) + 4LL;
        *(_DWORD *)(v25 + 48) = v23;
        return (char *)sub_10003C2E0((uint64_t)v24, v26, v27, v28, v29, v30, v31, v32);
      }

      uint64_t v36 = 443LL;
    }

    else
    {
      uint64_t v36 = 438LL;
    }

    return (char *)sub_10003C3F8( &v37,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/dns.c",  v36,  v18,  v19,  v20,  v21,  v22);
  }

  uint64_t result = (char *)sub_100034C7C( &v37,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/dns.c",  415LL,  v9,  v10,  v11,  v12,  v13);
  if ((_DWORD)result) {
    goto LABEL_12;
  }
  return result;
}

uint64_t sub_10003CB08(uint64_t *a1, unsigned int a2, unsigned int *a3, unsigned int a4)
{
  if (HIWORD(a2)) {
    return 0LL;
  }
  unsigned __int16 v7 = a2;
  uint64_t result = (uint64_t)sub_1000345C4(a1, 35, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/dns.c", 471LL);
  if ((_DWORD)result)
  {
    uint64_t v9 = *a1;
    a1[1] = *a1 + 4;
    *(_BYTE *)(v9 + 4) = a0123456789abcd[v7 >> 4];
    *(_BYTE *)(*a1 + 5) = a0123456789abcd[v7 % 0xFu];
    sub_10005AF90((uint64_t)v13);
    sub_10005AFB0(v13, a3, a4);
    uint64_t v10 = v14;
    sub_10005BD68((uint64_t)v14, (uint64_t)v13);
    for (uint64_t i = 0LL; i != 32; i += 2LL)
    {
      *(_BYTE *)(*a1 + i + 6) = a0123456789abcd[(unint64_t)*v10 >> 4];
      char v12 = *v10++;
      *(_BYTE *)(*a1 + i + 7) = a0123456789abcd[v12 & 0xF];
    }

    *((_DWORD *)a1 + 4) = 34;
    *(_BYTE *)(*a1 + 38) = 0;
    uint64_t result = 1LL;
    *((_DWORD *)a1 + 5) = 1;
  }

  return result;
}

uint64_t sub_10003CC64( uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a6;
  int v9 = a5;
  int v10 = a4;
  if (*a2 == 4)
  {
    int v13 = 1;
  }

  else
  {
    if (*a2 != 16) {
      return 39LL;
    }
    int v13 = 28;
  }

  *(_OWORD *)__s = *(_OWORD *)a2;
  int v62 = a2[4];
  sub_100040144((int *)__s, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  __strcpy_chk(__s);
  uint64_t v14 = 1LL;
  uint64_t v15 = sub_10006E324(1, *(const char **)(a1 + 8), 1, v13, 0);
  if (v15)
  {
    uint64_t v16 = v15;
    v15[8] = 0LL;
    if (v9) {
      int v17 = 8;
    }
    else {
      int v17 = 3;
    }
    *((_DWORD *)v15 + 2__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = 0;
    *((_DWORD *)v15 + 21) = v17;
    *uint64_t v15 = 0LL;
    v15[1] = 0LL;
    uint64_t v18 = sub_10006E324(2, *(const char **)(a1 + 8), 1, v13, v10);
    if (!v18) {
      goto LABEL_48;
    }
    uint64_t v19 = v18;
    v18[8] = __s;
    *((_DWORD *)v18 + 2__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = strlen(__s);
    *((_DWORD *)v19 + 21) = 1;
    v16[1] = v19;
    *uint64_t v19 = v16;
    v19[1] = 0LL;
    uint64_t v20 = sub_10006E324(2, *(const char **)(a1 + 8), 1, 16, v10);
    if (!v20) {
      goto LABEL_48;
    }
    uint64_t v21 = v20;
    v20[8] = *(void *)(a3 + 8);
    *((_DWORD *)v20 + 2__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = *(_DWORD *)(a3 + 16);
    *((_DWORD *)v20 + 21) = 1;
    v19[1] = v20;
    *uint64_t v20 = v19;
    v20[1] = 0LL;
    uint64_t v22 = sub_10006F8C0((unsigned int *)qword_10008C738, (uint64_t)v16);
    uint64_t v14 = v22;
    if (!(_DWORD)v22)
    {
      sub_1000622D4("Added new forward map from %.*s to %s", v23, v24, v25, v26, v27, v28, v29, *(_DWORD *)(a1 + 16));
      goto LABEL_48;
    }

    if (v9) {
      int v30 = 56;
    }
    else {
      int v30 = 55;
    }
    if ((_DWORD)v22 != v30)
    {
      int v33 = *(_DWORD *)(a1 + 16);
      sub_100067900(v22);
      sub_10006221C("Unable to add forward map from %.*s to %s: %s", v34, v35, v36, v37, v38, v39, v40, v33);
      goto LABEL_48;
    }

    while (1)
    {
      uint64_t v31 = *v16;
      uint64_t v32 = (void *)v16[1];
      if (!v32) {
        break;
      }
      *uint64_t v32 = v31;
      uint64_t v31 = *v16;
      if (*v16) {
        goto LABEL_18;
      }
LABEL_19:
      *uint64_t v16 = -1LL;
      v16[1] = -1LL;
      sub_10006E3A4(v16);
      uint64_t v16 = v32;
      if (!v32)
      {
        uint64_t v41 = *(const char **)(a1 + 8);
        uint64_t v14 = 1LL;
        if (v8)
        {
          uint64_t v42 = sub_10006E324(1, v41, 1, 16, 0);
          if (v42)
          {
            unint64_t v43 = v42;
            v42[8] = *(void *)(a3 + 8);
            *((_DWORD *)v42 + 2__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = *(_DWORD *)(a3 + 16);
            *((_DWORD *)v42 + 21) = 7;
            uint64_t v16 = v42;
            if (v21)
            {
              uint64_t v16 = 0LL;
              v21[1] = v42;
            }

            *uint64_t v42 = v21;
LABEL_36:
            v43[1] = 0LL;
            uint64_t v47 = sub_10006E324(2, *(const char **)(a1 + 8), 1, v13, 0);
            if (v47)
            {
              uint64_t v48 = v47;
              v47[8] = 0LL;
              v47[10] = 0LL;
              v43[1] = v47;
              *uint64_t v47 = v43;
              v47[1] = 0LL;
              int v49 = sub_10006E324(2, *(const char **)(a1 + 8), 1, v13, v10);
              if (v49)
              {
                int v50 = v49;
                v49[8] = __s;
                *((_DWORD *)v49 + 2__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = strlen(__s);
                *((_DWORD *)v50 + 21) = 1;
                v48[1] = v50;
                *int v50 = v48;
                v50[1] = 0LL;
                uint64_t v51 = sub_10006F8C0((unsigned int *)qword_10008C738, (uint64_t)v16);
                uint64_t v14 = v51;
                if ((int)v51 <= 54)
                {
                  if ((_DWORD)v51)
                  {
                    if ((_DWORD)v51 == 52) {
                      goto LABEL_46;
                    }
                    goto LABEL_43;
                  }
                }

                else
                {
                  if ((v51 - 55) < 2 || (_DWORD)v51 == 57)
                  {
LABEL_46:
                    sub_10006221C( "Forward map from %.*s to %s FAILED: %s",  v52,  v53,  v54,  v55,  v56,  v57,  v58,  *(_DWORD *)(a1 + 16));
                    goto LABEL_47;
                  }

uint64_t sub_10003D0C0( uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a2 == 4)
  {
    int v10 = 1;
  }

  else
  {
    if (*a2 != 16) {
      return 39LL;
    }
    int v10 = 28;
  }

  *(_OWORD *)__s = *(_OWORD *)a2;
  int v37 = a2[4];
  sub_100040144((int *)__s, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  __strcpy_chk(__s);
  uint64_t v34 = 0LL;
  uint64_t v35 = 0LL;
  uint64_t v11 = 1LL;
  char v12 = sub_10006E324(1, *(const char **)(a1 + 8), 1, 16, 0);
  if (v12)
  {
    v12[8] = *(void *)(a3 + 8);
    *((_DWORD *)v12 + 2__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = *(_DWORD *)(a3 + 16);
    *((_DWORD *)v12 + 21) = 7;
    int v13 = v35;
    if (v35)
    {
      v35[1] = v12;
      int v13 = v35;
    }

    else
    {
      uint64_t v34 = v12;
    }

    *char v12 = v13;
    v12[1] = 0LL;
    uint64_t v35 = v12;
    uint64_t v14 = sub_10006E324(1, *(const char **)(a1 + 8), 1, v10, 0);
    if (v14)
    {
      uint64_t v15 = v14;
      v14[8] = __s;
      *((_DWORD *)v14 + 2__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = strlen(__s);
      *((_DWORD *)v15 + 21) = 7;
      uint64_t v16 = v35;
      if (v35)
      {
        v35[1] = v15;
        uint64_t v16 = v35;
      }

      else
      {
        uint64_t v34 = v15;
      }

      *uint64_t v15 = v16;
      v15[1] = 0LL;
      uint64_t v35 = v15;
      int v17 = sub_10006E324(2, *(const char **)(a1 + 8), 1, v10, 0);
      if (v17)
      {
        uint64_t v18 = v17;
        v17[8] = __s;
        *((_DWORD *)v17 + 2__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = strlen(__s);
        *((_DWORD *)v18 + 21) = 0;
        uint64_t v19 = v35;
        if (v35)
        {
          v35[1] = v18;
          uint64_t v19 = v35;
        }

        else
        {
          uint64_t v34 = v18;
        }

        *uint64_t v18 = v19;
        v18[1] = 0LL;
        uint64_t v35 = v18;
        LODWORD(v11) = sub_10006F8C0((unsigned int *)qword_10008C738, (uint64_t)v34);
        sub_100051AE8(v11, (uint64_t *)&v34);
        if ((_DWORD)v11)
        {
          if ((_DWORD)v11 == 52 || (_DWORD)v11 == 57) {
            uint64_t v11 = 0LL;
          }
          else {
            uint64_t v11 = v11;
          }
        }

        else
        {
          for (uint64_t i = v34; v34; uint64_t i = v34)
          {
            uint64_t v26 = (void *)*i;
            uint64_t v27 = (void *)i[1];
            if (v27)
            {
              void *v27 = v26;
              uint64_t v26 = (void *)*i;
            }

            else
            {
              uint64_t v35 = (void *)*i;
            }

            if (v26) {
              v26[1] = i[1];
            }
            else {
              uint64_t v34 = (void *)i[1];
            }
            *uint64_t i = -1LL;
            i[1] = -1LL;
            sub_10006E3A4(i);
          }

          uint64_t v34 = 0LL;
          uint64_t v35 = 0LL;
          uint64_t v11 = 1LL;
          uint64_t v28 = sub_10006E324(1, *(const char **)(a1 + 8), 1, 1, 0);
          if (v28)
          {
            v28[8] = 0LL;
            v28[10] = 0x800000000LL;
            uint64_t v29 = v35;
            if (v35)
            {
              v35[1] = v28;
              uint64_t v29 = v35;
            }

            else
            {
              uint64_t v34 = v28;
            }

            *uint64_t v28 = v29;
            v28[1] = 0LL;
            uint64_t v35 = v28;
            int v30 = sub_10006E324(1, *(const char **)(a1 + 8), 1, 28, 0);
            if (v30)
            {
              v30[8] = 0LL;
              v30[10] = 0x800000000LL;
              uint64_t v31 = v35;
              if (v35)
              {
                v35[1] = v30;
                uint64_t v31 = v35;
              }

              else
              {
                uint64_t v34 = v30;
              }

              *int v30 = v31;
              v30[1] = 0LL;
              uint64_t v35 = v30;
              uint64_t v32 = sub_10006E324(2, *(const char **)(a1 + 8), 1, 16, 0);
              if (v32)
              {
                v32[8] = *(void *)(a3 + 8);
                *((_DWORD *)v32 + 2__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = *(_DWORD *)(a3 + 16);
                *((_DWORD *)v32 + 21) = 0;
                int v33 = v35;
                if (v35)
                {
                  v35[1] = v32;
                  int v33 = v35;
                }

                else
                {
                  uint64_t v34 = v32;
                }

                *uint64_t v32 = v33;
                v32[1] = 0LL;
                uint64_t v35 = v32;
                uint64_t v11 = sub_10006F8C0((unsigned int *)qword_10008C738, (uint64_t)v34);
                sub_100051AE8(v11, (uint64_t *)&v34);
              }
            }
          }
        }
      }
    }
  }

  for (uint64_t j = v34; v34; uint64_t j = v34)
  {
    uint64_t v22 = (void *)*j;
    uint64_t v23 = (void *)j[1];
    if (v23)
    {
      *uint64_t v23 = v22;
      uint64_t v22 = (void *)*j;
    }

    else
    {
      uint64_t v35 = (void *)*j;
    }

    if (v22) {
      v22[1] = j[1];
    }
    else {
      uint64_t v34 = (void *)j[1];
    }
    void *j = -1LL;
    j[1] = -1LL;
    sub_10006E3A4(j);
  }

  return v11;
}

uint64_t sub_10003D448(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  if (a4 && *(_BYTE *)a4 == 7)
  {
    *(_DWORD *)size_t v5 = *(_DWORD *)(a4 + 2);
    *(_WORD *)&v5[4] = *(_WORD *)(a4 + 6);
  }

  else
  {
    *(_WORD *)&v5[4] = -1;
    *(_DWORD *)size_t v5 = -1;
  }

  if (*(_BYTE *)(result + 48) == 7)
  {
    *(_DWORD *)&v5[6] = *(_DWORD *)(result + 50);
    *(_WORD *)&v5[10] = *(_WORD *)(result + 54);
  }

  else
  {
    *(_WORD *)&v5[10] = 0;
    *(_DWORD *)&v5[6] = 0;
  }

  uint64_t v4 = a2 + *a3;
  *(void *)uint64_t v4 = *(void *)v5;
  *(_DWORD *)(v4 + 8) = *(_DWORD *)&v5[8];
  *(_WORD *)(v4 + 12) = 8;
  *a3 += 14;
  return result;
}

uint64_t sub_10003D4D8(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(a2 + a3 + 6);
  *(_DWORD *)(a4 + 2) = v5;
  *(_WORD *)(a4 + 6) = WORD2(v5);
  *(_WORD *)a4 = 263;
  return 14LL;
}

uint64_t sub_10003D510( void *a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, _DWORD *a8)
{
  if (!a8) {
    return 1LL;
  }
  uint64_t v95 = 0LL;
  uint64_t v93 = 0LL;
  uint64_t v94 = 0LL;
  sub_100033F18( &v95,  a8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  64LL,  a5,  a6,  (uint64_t)a7,  (uint64_t)a8);
  uint64_t v20 = v95;
  if (!v95) {
    return 1LL;
  }
  uint64_t v86 = (void **)(a3 + 176);
  uint64_t v87 = (void **)(a3 + 160);
  uint64_t v88 = (void **)(a3 + 168);
  do
  {
    if (a1 && *a1) {
      return 1LL;
    }
    uint64_t v21 = (_DWORD *)*((void *)v20 + 1);
    if (v21)
    {
      sub_100033F18( &v93,  v21,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  67LL,  v16,  v17,  v18,  (uint64_t)v19);
      uint64_t v20 = v95;
    }

    uint64_t v22 = *((unsigned int *)v20 + 4);
    switch((int)v22)
    {
      case 1:
        if (sub_10005525C(&v92, (uint64_t)a2, a3, a4, a5, a6, a7, *((void *)v20 + 5)))
        {
          uint64_t v39 = v95;
          if (v92)
          {
            uint64_t v40 = (uint64_t *)(v95 + 24);
            goto LABEL_82;
          }
        }

        else
        {
          int v92 = 0;
          uint64_t v39 = v95;
        }

        uint64_t v40 = (uint64_t *)(v39 + 32);
LABEL_82:
        uint64_t v38 = *v40;
LABEL_83:
        sub_10003D510(a1, a2, a3, a4, a5, a6, a7, v38);
        goto LABEL_89;
      case 2:
        sub_100003728(a2, *((void *)v20 + 3));
        goto LABEL_89;
      case 3:
        sub_100054B74( 0LL,  a2,  a3,  a4,  a5,  a6,  a7,  *((void *)v20 + 3),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  179);
        goto LABEL_89;
      case 4:
        return 1LL;
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
        sub_100043B90( *(void **)(*(void *)(*((void *)v20 + 3) + 24LL) + 16LL),  a6,  *((void *)v20 + 3),  v22,  v16,  v17,  v18,  (uint64_t)v19,  v85);
        goto LABEL_89;
      case 10:
        uint64_t v38 = *((void *)v20 + 3);
        goto LABEL_83;
      case 11:
        if (a3)
        {
          if ((v20[24] & 2) != 0)
          {
            if (*v87)
            {
              sub_10003DC78( v87,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  92LL,  v22,  v16,  v17,  v18,  (uint64_t)v19);
              uint64_t v20 = v95;
            }

            uint64_t v41 = (_DWORD *)*((void *)v20 + 4);
            if (v41)
            {
              sub_100033F18( v87,  v41,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  96LL,  v16,  v17,  v18,  (uint64_t)v19);
              uint64_t v20 = v95;
            }
          }

          if ((v20[24] & 4) != 0)
          {
            if (*v86)
            {
              sub_10003DC78( v86,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  104LL,  v22,  v16,  v17,  v18,  (uint64_t)v19);
              uint64_t v20 = v95;
            }

            uint64_t v42 = (_DWORD *)*((void *)v20 + 4);
            if (v42)
            {
              sub_100033F18( v86,  v42,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  108LL,  v16,  v17,  v18,  (uint64_t)v19);
              uint64_t v20 = v95;
            }
          }

          if ((v20[24] & 1) != 0)
          {
            if (*v88)
            {
              sub_10003DC78( v88,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  116LL,  v22,  v16,  v17,  v18,  (uint64_t)v19);
              uint64_t v20 = v95;
            }

            unint64_t v43 = (_DWORD *)*((void *)v20 + 4);
            if (v43) {
              sub_100033F18( v88,  v43,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  120LL,  v16,  v17,  v18,  (uint64_t)v19);
            }
          }
        }

        goto LABEL_89;
      case 12:
        if (sub_10003DE4C( &v94,  (uint64_t)a2,  a3,  a4,  a5,  a6,  a7,  *((void *)v20 + 3),  *((void *)v20 + 4)))
        {
          sub_10003D510(a1, a2, a3, a4, a5, a6, a7, v94);
          sub_10003DC78( (void **)&v94,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  145LL,  v44,  v45,  v46,  v47,  v48);
        }

        goto LABEL_89;
      case 13:
      case 14:
        goto LABEL_89;
      case 15:
      case 18:
        if (!a7)
        {
          sub_10006221C("set %s: no scope", (uint64_t)v21, v15, v22, v16, v17, v18, (uint64_t)v19, *((void *)v20 + 3));
          goto LABEL_89;
        }

        uint64_t v23 = *a7;
        if (*a7) {
          goto LABEL_14;
        }
        if (!sub_100034DAC( a7,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  336LL,  v22,  v16,  v17,  v18,  (uint64_t)v19))
        {
          sub_10006221C("set %s: can't allocate scope", v24, v25, v26, v27, v28, v29, v30, *((void *)v95 + 3));
          goto LABEL_89;
        }

        uint64_t v23 = *a7;
        uint64_t v20 = v95;
LABEL_14:
        uint64_t v36 = sub_100055100(v23, *((char **)v20 + 3));
        if (v36) {
          goto LABEL_15;
        }
        uint64_t v71 = (uint64_t **)sub_10005CDE4(0x18uLL);
        if (!v71) {
          goto LABEL_89;
        }
        uint64_t v36 = v71;
        v71[1] = 0LL;
        v71[2] = 0LL;
        *uint64_t v71 = 0LL;
        int v72 = strlen(*((const char **)v95 + 3));
        uint64_t v73 = (char *)sub_10005CDE4((v72 + 1));
        v36[1] = (uint64_t *)v73;
        if (v73)
        {
          strcpy(v73, *((const char **)v95 + 3));
          *uint64_t v36 = *(uint64_t **)(*a7 + 16);
          *(void *)(*a7 + 16) = v36;
LABEL_15:
          int v37 = (uint64_t *)(v36 + 2);
          if (v36[2]) {
            sub_1000577E8( (uint64_t *)v36 + 2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  369LL,  v31,  v32,  v33,  v34,  v35);
          }
          if (*((_DWORD *)v95 + 4) == 15)
          {
            sub_100054B74( v36 + 2,  a2,  a3,  a4,  a5,  a6,  a7,  *((void *)v95 + 4),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  376);
          }

          else
          {
            if (!sub_10003444C( v36 + 2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  379LL,  v31,  v32,  v33,  v34,  v35)) {
              sub_10003EA80(v36, v68, v69, v22, v16, v17, v18, (uint64_t)v19);
            }
            uint64_t v70 = *v37;
            if (*v37)
            {
              *(_DWORD *)(v70 + 4) = 4;
              sub_100033F18( (void *)(v70 + 8),  *(_DWORD **)(*((void *)v95 + 4) + 8LL),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  389LL,  v16,  v17,  v18,  (uint64_t)v19);
            }
          }
        }

        else
        {
          sub_10005CE20( v36,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  361LL,  v74,  v75,  v76,  v77,  v78);
        }

        goto LABEL_89;
      case 16:
        if (a7)
        {
          if (*a7)
          {
            int v49 = sub_100055100(*a7, *((char **)v20 + 3));
            if (v49)
            {
              uint64_t v51 = v49[2];
              int v50 = (uint64_t *)(v49 + 2);
              if (v51) {
                sub_1000577E8( v50,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  408LL,  v22,  v16,  v17,  v18,  (uint64_t)v19);
              }
            }
          }
        }

        goto LABEL_89;
      case 17:
        uint64_t v89 = 0LL;
        sub_100034DAC( &v89,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  423LL,  v22,  v16,  v17,  v18,  (uint64_t)v19);
        uint64_t v19 = (const char **)v95;
        break;
      case 19:
        v90[0] = 0LL;
        v90[1] = 0LL;
        uint64_t v91 = 0LL;
        if (sub_10005618C( v90,  a2,  a3,  a4,  a5,  a6,  a7,  *((void *)v20 + 4),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  489))
        {
          switch(*((_DWORD *)v95 + 6))
          {
            case 0:
              sub_100061FB4("%.*s", v66, v67, v22, v16, v17, v18, (uint64_t)v19, v91);
            case 1:
              sub_10006221C("%.*s", v66, v67, v22, v16, v17, v18, (uint64_t)v19, v91);
              break;
            case 2:
              sub_10006238C("%.*s", v66, v67, v22, v16, v17, v18, (uint64_t)v19, v91);
              break;
            case 3:
              sub_1000622D4("%.*s", v66, v67, v22, v16, v17, v18, (uint64_t)v19, v91);
              break;
            default:
              break;
          }

          sub_100034EA8( v90,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  514LL,  v22,  v16,  v17,  v18,  (uint64_t)v19);
        }

        goto LABEL_89;
      case 20:
        sub_100054B74( a1,  a2,  a3,  a4,  a5,  a6,  a7,  *((void *)v20 + 3),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  270);
        goto LABEL_89;
      case 21:
        sub_100061FB4( "Impossible case at %s:%d (ENABLE_EXECUTE is not defined).",  (uint64_t)v21,  v15,  v22,  v16,  v17,  v18,  (uint64_t)v19,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c");
      default:
        sub_10006221C( "bogus statement type %d",  (uint64_t)v21,  v15,  v22,  v16,  v17,  v18,  (uint64_t)v19,  *((_DWORD *)v20 + 4));
        goto LABEL_89;
    }

    do
    {
      uint64_t v94 = v19;
      if (!v89) {
        goto LABEL_59;
      }
      uint64_t v52 = sub_10005CDE4(0x18uLL);
      v52[1] = 0LL;
      v52[2] = 0LL;
      *uint64_t v52 = 0LL;
      if (!v52) {
        goto LABEL_58;
      }
      uint64_t v58 = v52;
      size_t v59 = strlen(v94[3] + 1);
      uint64_t v60 = (char *)sub_10005CDE4(v59);
      v58[1] = v60;
      if (!v60)
      {
        sub_10005CE20( v58,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  442LL,  v61,  v62,  v63,  v64,  v65);
LABEL_58:
        sub_10005515C( &v89,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  432LL,  v53,  v54,  v55,  v56,  v57);
        goto LABEL_59;
      }

      strcpy(v60, v94[3]);
      if (v89)
      {
        sub_100054B74( v58 + 2,  a2,  a3,  a4,  a5,  a6,  a7,  v94[4],  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  455);
        void *v58 = *(void *)(v89 + 16);
        *(void *)(v89 + 16) = v58;
      }

uint64_t sub_10003DC78( void **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || (uint64_t v11 = (char *)*a1) == 0LL)
  {
    sub_10006221C("%s(%d): null pointer", a2, a3, a4, a5, a6, a7, a8, a2);
    return 0LL;
  }

  int v12 = (*(_DWORD *)v11)--;
  if (v12 < 2)
  {
    if (v12 == 1)
    {
      if (*((void *)v11 + 1))
      {
        sub_10003DC78(v11 + 8, a2, a3);
        uint64_t v11 = (char *)*a1;
      }

      switch(*((_DWORD *)v11 + 4))
      {
        case 1:
          if (*((void *)v11 + 5))
          {
            sub_100054390((uint64_t *)v11 + 5, a2, a3, a4, a5, a6, a7, a8);
            uint64_t v11 = (char *)*a1;
          }

          if (*((void *)v11 + 3))
          {
            sub_10003DC78(v11 + 24, a2, a3);
            uint64_t v11 = (char *)*a1;
          }

          goto LABEL_21;
        case 3:
        case 0xD:
        case 0x14:
          goto LABEL_27;
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
          uint64_t v14 = *((void *)v11 + 3);
          int v13 = (int **)(v11 + 24);
          if (v14) {
            sub_100040E08(v13, a2, a3, a4, a5, a6, a7, a8);
          }
          break;
        case 0xA:
          uint64_t v20 = *((void *)v11 + 3);
          uint64_t v18 = v11 + 24;
          if (v20) {
            goto LABEL_24;
          }
          break;
        case 0xB:
LABEL_21:
          uint64_t v19 = *((void *)v11 + 4);
          uint64_t v18 = v11 + 32;
          if (!v19) {
            break;
          }
LABEL_24:
          sub_10003DC78(v18, a2, a3);
          break;
        case 0xC:
          if (*((void *)v11 + 4))
          {
            sub_10003DC78(v11 + 32, a2, a3);
            uint64_t v11 = (char *)*a1;
          }

uint64_t sub_10003DE4C( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8, uint64_t a9)
{
  uint64_t v17 = a9;
  if (sub_100056150(a8))
  {
    uint64_t v40 = 0LL;
    __s2 = 0LL;
    uint64_t v42 = 0LL;
    __s1 = 0LL;
    size_t __n = 0LL;
    unint64_t v43 = 0LL;
    if (!sub_10005618C( &v40,  a2,  a3,  a4,  a5,  a6,  a7,  a8,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  1018)) {
      goto LABEL_12;
    }
    if (!a9)
    {
LABEL_11:
      sub_100034EA8( &v40,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  1038LL,  v18,  v19,  v20,  v21,  v22);
      goto LABEL_12;
    }

    uint64_t v23 = a9;
    while (1)
    {
      if (*(_DWORD *)(v23 + 16) == 13)
      {
        if (sub_10005618C( &v43,  a2,  a3,  a4,  a5,  a6,  a7,  *(void *)(v23 + 24),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  1025)
          && (_DWORD)__n == (_DWORD)v42
          && !memcmp(__s1, __s2, __n))
        {
          sub_100034EA8( &v43,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  1029LL,  v24,  v25,  v26,  v27,  v28);
          sub_100034EA8( &v40,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  1030LL,  v35,  v36,  v37,  v38,  v39);
          uint64_t v31 = *(_DWORD **)(v23 + 8);
          uint64_t v30 = a1;
          uint64_t v32 = 1032LL;
LABEL_15:
          sub_100033F18( v30,  v31,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  v32,  v19,  v20,  v21,  v22);
          return 1LL;
        }

        sub_100034EA8( &v43,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c",  1035LL,  v24,  v25,  v26,  v27,  v28);
      }

      uint64_t v23 = *(void *)(v23 + 8);
      if (!v23) {
        goto LABEL_11;
      }
    }
  }

  if (sub_10005591C((unint64_t *)&v43, a2, a3, a4, a5, a6, a7, a8) && a9)
  {
    uint64_t v34 = a9;
    do
    {
      if (*(_DWORD *)(v34 + 16) == 13
        && sub_10005591C((unint64_t *)&v40, a2, a3, a4, a5, a6, a7, *(void *)(v34 + 24))
        && v43 == v40)
      {
        uint64_t v31 = *(_DWORD **)(v34 + 8);
        uint64_t v30 = a1;
        uint64_t v32 = 1056LL;
        goto LABEL_15;
      }

      uint64_t v34 = *(void *)(v34 + 8);
    }

    while (v34);
  }

uint64_t sub_10003E0AC( uint64_t result, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8, void *a9)
{
  if (a8)
  {
    uint64_t v16 = (void *)result;
    if (a9)
    {
      uint64_t v17 = a9;
      while (v17 != (void *)a8)
      {
        uint64_t v17 = (void *)*v17;
        if (!v17) {
          goto LABEL_6;
        }
      }
    }

    else
    {
LABEL_6:
      if (*(void *)a8) {
        sub_10003E0AC(result, a2, a3, a4, a5, a6, a7);
      }
      return sub_10003D510(v16, a2, a3, a4, a5, a6, a7, *(_DWORD **)(a8 + 48));
    }
  }

  return result;
}

uint64_t sub_10003E18C( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    uint64_t v9 = a2;
    int v10 = (FILE *)result;
    uint64_t v11 = (a3 + 4);
    uint64_t v12 = (a3 + 6);
    int v76 = a3;
    unsigned int v74 = a3 + 8;
    unsigned int v75 = a3 + 4;
    unsigned int v71 = a3 + 5;
    unsigned int v72 = a3 + 3;
    uint64_t v13 = (a3 + 2);
    unsigned int v69 = a3 + 7;
    int v70 = a3 - 1;
    unsigned int v73 = a3 + 2;
    while (2)
    {
      uint64_t v14 = "supersede";
      switch(*(_DWORD *)(v9 + 16))
      {
        case 1:
          sub_100051AA0(v10, a3);
          fwrite("if ", 3uLL, 1uLL, v10);
          int v18 = sub_100057E58(v10, *(void *)(v9 + 40), v72, v72, 1LL, v15, v16, v17);
          sub_10005179C(v10, v18, a3, " ", &byte_1000728D2, "{");
          sub_10003E18C(v10, *(void *)(v9 + 24), v13);
          uint64_t v19 = (void *)v9;
          while (2)
          {
            uint64_t v22 = v19[4];
            uint64_t v21 = v19 + 4;
            uint64_t v20 = v22;
            if (v22)
            {
              if (*(_DWORD *)(v20 + 16) == 1 && !*(void *)(v20 + 8))
              {
                sub_100051AA0(v10, a3);
                fwrite("} elsif ", 8uLL, 1uLL, v10);
                uint64_t v19 = (void *)*v21;
                int v26 = sub_100057E58(v10, v19[5], v12, v12, 1LL, v23, v24, v25);
                sub_10005179C(v10, v26, a3, " ", &byte_1000728D2, "{");
                sub_10003E18C(v10, v19[3], v13);
                continue;
              }

              sub_100051AA0(v10, a3);
              fwrite("} else {", 8uLL, 1uLL, v10);
              sub_10003E18C(v10, *v21, v13);
            }

            break;
          }

          sub_100051AA0(v10, a3);
          uint64_t result = fputc(125, v10);
          goto LABEL_49;
        case 2:
          sub_100051AA0(v10, a3);
          uint64_t result = fprintf(v10, "add %s", *(const char **)(*(void *)(v9 + 24) + 48LL));
          goto LABEL_49;
        case 3:
          sub_100051AA0(v10, a3);
          fwrite("eval ", 5uLL, 1uLL, v10);
          sub_100057E58(v10, *(void *)(v9 + 24), v71, v71, 1LL, v27, v28, v29);
          goto LABEL_22;
        case 4:
          sub_100051AA0(v10, a3);
          uint64_t v30 = "break;";
          size_t v31 = 6LL;
          goto LABEL_39;
        case 5:
          uint64_t v14 = "default";
          goto LABEL_15;
        case 6:
        case 9:
          goto LABEL_15;
        case 7:
          uint64_t v14 = "append";
          goto LABEL_15;
        case 8:
          uint64_t v14 = "prepend";
LABEL_15:
          uint64_t v32 = *(uint64_t **)(*(void *)(*(void *)(v9 + 24) + 24LL) + 16LL);
          if (v32 == &qword_10008C168)
          {
            uint64_t v33 = &byte_1000728D2;
            uint64_t v34 = &byte_1000728D2;
          }

          else
          {
            uint64_t v33 = (const char *)*v32;
            uint64_t v34 = ".";
          }

          sub_100051AA0(v10, a3);
          fprintf(v10, "%s %s%s%s = ", v14, v33, v34, **(const char ***)(*(void *)(v9 + 24) + 24LL));
          int v35 = strlen(v14) + v76;
          int v36 = strlen(v33);
          int v37 = v35 + v36 + strlen(v34);
          uint64_t v38 = *(void *)(v9 + 24);
          int v42 = v37 + strlen(**(const char ***)(v38 + 24));
          uint64_t v43 = *(void *)(v38 + 16);
          if (v43) {
            sub_100057E58(v10, v43, (v42 + 4), v74, 1LL, v39, v40, v41);
          }
          else {
            sub_1000518C8(v10, (v42 + 4), v74, &byte_1000728D2, &byte_1000728D2, v38 + 32);
          }
          uint64_t v11 = v75;
          uint64_t v13 = v73;
          goto LABEL_22;
        case 0xA:
          uint64_t result = sub_10003E18C(v10, *(void *)(v9 + 24), a3);
          goto LABEL_49;
        case 0xB:
          sub_100051AA0(v10, a3);
          fwrite("on ", 3uLL, 1uLL, v10);
          int v45 = *(_DWORD *)(v9 + 24);
          if ((v45 & 2) != 0)
          {
            fprintf(v10, "%sexpiry", &byte_1000728D2);
            int v45 = *(_DWORD *)(v9 + 24);
            uint64_t v46 = " or ";
            if ((v45 & 1) == 0) {
              goto LABEL_43;
            }
          }

          else
          {
            uint64_t v46 = &byte_1000728D2;
            if ((v45 & 1) == 0) {
              goto LABEL_43;
            }
          }

          fprintf(v10, "%scommit", v46);
          int v45 = *(_DWORD *)(v9 + 24);
          uint64_t v46 = "or";
LABEL_43:
          if ((v45 & 4) != 0) {
            fprintf(v10, "%srelease", v46);
          }
          if (*(void *)(v9 + 32))
          {
            fwrite(" {", 2uLL, 1uLL, v10);
LABEL_47:
            sub_10003E18C(v10, *(void *)(v9 + 32), v13);
            sub_100051AA0(v10, a3);
            int v44 = 125;
          }

          else
          {
LABEL_22:
            int v44 = 59;
          }

          uint64_t result = fputc(v44, v10);
LABEL_49:
          uint64_t v9 = *(void *)(v9 + 8);
          if (!v9) {
            return result;
          }
          continue;
        case 0xC:
          sub_100051AA0(v10, a3);
          fwrite("switch (", 8uLL, 1uLL, v10);
          int v50 = sub_100057E58(v10, *(void *)(v9 + 24), v69, v69, 1LL, v47, v48, v49);
          int v51 = sub_10005179C(v10, v50, v69, &byte_1000728D2, &byte_1000728D2, ")");
          sub_10005179C(v10, v51, a3, " ", &byte_1000728D2, "{");
          goto LABEL_47;
        case 0xD:
          sub_100051AA0(v10, v70);
          fwrite("case ", 5uLL, 1uLL, v10);
          int v55 = sub_100057E58(v10, *(void *)(v9 + 24), v71, v71, 1LL, v52, v53, v54);
          uint64_t v56 = v10;
          uint64_t v57 = v71;
          uint64_t v58 = &byte_1000728D2;
          size_t v59 = ":";
          goto LABEL_37;
        case 0xE:
          sub_100051AA0(v10, v70);
          uint64_t v30 = "default: ";
          size_t v31 = 9LL;
          goto LABEL_39;
        case 0xF:
          sub_100051AA0(v10, a3);
          fwrite("set ", 4uLL, 1uLL, v10);
          int v60 = sub_10005179C(v10, v11, v11, &byte_1000728D2, &byte_1000728D2, *(char **)(v9 + 24));
          sub_10005179C(v10, v60, v11, " ", " ", "=");
          int v55 = sub_100057E58(v10, *(void *)(v9 + 32), v72, v72, 0LL, v61, v62, v63);
          uint64_t v56 = v10;
          uint64_t v57 = v11;
          uint64_t v58 = " ";
          goto LABEL_32;
        case 0x10:
          sub_100051AA0(v10, a3);
          fwrite("unset ", 6uLL, 1uLL, v10);
          int v55 = sub_10005179C(v10, v12, v12, &byte_1000728D2, &byte_1000728D2, *(char **)(v9 + 24));
          uint64_t v56 = v10;
          uint64_t v57 = v12;
          uint64_t v58 = " ";
LABEL_32:
          size_t v59 = ";";
          goto LABEL_37;
        case 0x13:
          sub_100051AA0(v10, a3);
          fwrite("log ", 4uLL, 1uLL, v10);
          int v64 = sub_10005179C(v10, v11, v11, &byte_1000728D2, &byte_1000728D2, "(");
          uint64_t v68 = *(int *)(v9 + 24);
          int v55 = sub_100057E58(v10, *(void *)(v9 + 32), v11, v11, 0LL, v65, v66, v67);
          uint64_t v56 = v10;
          uint64_t v57 = v11;
          uint64_t v58 = &byte_1000728D2;
          size_t v59 = ");";
LABEL_37:
          uint64_t result = sub_10005179C(v56, v55, v57, v58, &byte_1000728D2, v59);
          goto LABEL_49;
        case 0x14:
          sub_100051AA0(v10, a3);
          uint64_t v30 = "return;";
          size_t v31 = 7LL;
LABEL_39:
          uint64_t result = fwrite(v30, v31, 1uLL, v10);
          goto LABEL_49;
        case 0x15:
          sub_100061FB4( "Impossible case at %s:%d (ENABLE_EXECUTE is not defined).",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/execute.c");
        default:
          sub_100061FB4("bogus statement type %d\n", a2, a3, a4, a5, a6, a7, a8, *(_DWORD *)(v9 + 16));
      }
    }
  }

  return result;
}

uint64_t sub_10003E960( uint64_t a1, unsigned int (*a2)(uint64_t, uint64_t, uint64_t), uint64_t a3, uint64_t a4)
{
  if (a1)
  {
    uint64_t v7 = a1;
    LODWORD(v8) = 0;
    while (2)
    {
      if (a2(v7, a3, a4)) {
        uint64_t v8 = 1LL;
      }
      else {
        uint64_t v8 = v8;
      }
      int v9 = *(_DWORD *)(v7 + 16);
      switch(v9)
      {
        case 10:
          uint64_t v10 = *(void *)(v7 + 24);
          uint64_t v11 = a2;
          uint64_t v12 = a3;
          uint64_t v13 = a4;
          goto LABEL_12;
        case 11:
        case 12:
          uint64_t v10 = *(void *)(v7 + 32);
          uint64_t v11 = a2;
          uint64_t v12 = a3;
          uint64_t v13 = 1LL;
          goto LABEL_12;
        case 13:
        case 14:
        case 15:
        case 16:
          goto LABEL_16;
        case 17:
          uint64_t v10 = *(void *)(v7 + 40);
          uint64_t v11 = a2;
          uint64_t v12 = a3;
          uint64_t v13 = 0LL;
LABEL_12:
          BOOL v15 = sub_10003E960(v10, v11, v12, v13) == 0;
          goto LABEL_13;
        default:
          if (v9 != 1) {
            goto LABEL_16;
          }
          int v14 = sub_10003E960(*(void *)(v7 + 24), a2, a3, 1LL);
          BOOL v15 = (sub_10003E960(*(void *)(v7 + 32), a2, a3, 1LL) | v14) == 0;
LABEL_13:
          if (v15) {
            uint64_t v8 = v8;
          }
          else {
            uint64_t v8 = 1LL;
          }
LABEL_16:
          uint64_t v7 = *(void *)(v7 + 8);
          if (!v7) {
            return v8;
          }
          continue;
      }
    }
  }

  return 0LL;
}

void sub_10003EA80( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

uint64_t sub_10003EA9C(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  if (!a4 || *a4) {
    sub_10003EFC0();
  }
  if (!a1) {
    sub_10003EFE8();
  }
  uint64_t v8 = sub_10005CDE4(0x28uLL);
  if (!v8) {
    return 1LL;
  }
  int v9 = v8;
  uint64_t result = 0LL;
  if (a3) {
    int v11 = a3;
  }
  else {
    int v11 = 1024;
  }
  *int v9 = 0;
  v9[1] = v11;
  v9[2] = 0;
  *((void *)v9 + 2) = 0LL;
  *((void *)v9 + 3) = a1;
  *((void *)v9 + 4) = a2;
  *a4 = v9;
  return result;
}

void sub_10003EB2C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_10003F010();
  }
  int v9 = *(void **)a1;
  uint64_t v10 = *(void **)(*(void *)a1 + 16LL);
  if (v10) {
    sub_10005CE20( v10,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/heap.c",  112LL,  a4,  a5,  a6,  a7,  a8);
  }
  sub_10005CE20(v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/heap.c", 113LL, a4, a5, a6, a7, a8);
  *(void *)a1 = 0LL;
}

uint64_t sub_10003EB84(int *a1, uint64_t a2)
{
  uint64_t v4 = (a1[2] + 1);
  a1[2] = v4;
  if (v4 < *a1)
  {
LABEL_6:
    sub_10003EC40((uint64_t)a1, v4, a2);
    return 0LL;
  }

  int v5 = a1[1] + *a1;
  uint64_t v6 = sub_10005CDE4((8 * v5));
  if (v6)
  {
    uint64_t v7 = v6;
    uint64_t v8 = (const void *)*((void *)a1 + 2);
    if (v8)
    {
      memcpy(v6, v8, 8LL * *a1);
      sub_10005CE20( *((void **)a1 + 2),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/heap.c",  129LL,  v9,  v10,  v11,  v12,  v13);
    }

    *a1 = v5;
    *((void *)a1 + 2) = v7;
    goto LABEL_6;
  }

  return 1LL;
}

uint64_t sub_10003EC40(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  uint64_t v5 = result;
  uint64_t v6 = a2 >> 1;
  if (a2 >= 2)
  {
    do
    {
      uint64_t v7 = v6;
      uint64_t result = (*(uint64_t (**)(uint64_t, void))(v5 + 24))( a3,  *(void *)(*(void *)(v5 + 16) + 8LL * v6));
      if (!(_DWORD)result) {
        break;
      }
      uint64_t v8 = *(uint64_t (**)(void, uint64_t))(v5 + 32);
      if (v8) {
        uint64_t result = v8(*(void *)(*(void *)(v5 + 16) + 8LL * v4), v4);
      }
      uint64_t v6 = v6 >> 1;
      uint64_t v4 = v7;
    }

    while (v7 > 1);
  }

  *(void *)(*(void *)(v5 + 16) + 8LL * v4) = a3;
  uint64_t v9 = *(uint64_t (**)(void, void))(v5 + 32);
  if (v9) {
    uint64_t result = v9(*(void *)(*(void *)(v5 + 16) + 8LL * v4), v4);
  }
  if ((_DWORD)v4 != 1)
  {
    uint64_t result = (*(uint64_t (**)(void, void))(v5 + 24))( *(void *)(*(void *)(v5 + 16) + 8LL * v4),  *(void *)(*(void *)(v5 + 16) + 8LL * v6));
    if ((_DWORD)result) {
      sub_10003F038();
    }
  }

  return result;
}

uint64_t sub_10003ED20(uint64_t result, uint64_t a2)
{
  if ((_DWORD)v4 == (_DWORD)a2)
  {
    *(_DWORD *)(result + 8) = a2 - 1;
  }

  else
  {
    *(_DWORD *)(result + 8) = v4 - 1;
    uint64_t v5 = *(void *)(result + 16);
    uint64_t v6 = *(void *)(v5 + 8 * v4);
    int v7 = (*(uint64_t (**)(uint64_t, void))(result + 24))(v6, *(void *)(v5 + 8LL * a2));
    *(void *)(*(void *)(v3 + 16) + 8LL * a2) = v6;
    uint64_t v8 = *(void *)(*(void *)(v3 + 16) + 8LL * a2);
    if (v7) {
      return sub_10003EC40(v3, a2, v8);
    }
    else {
      return sub_10003EDCC(v3, a2, v8);
    }
  }

  return result;
}

uint64_t sub_10003EDCC(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  uint64_t v5 = result;
  unsigned int v6 = *(_DWORD *)(result + 8);
  if (v6 >> 1 >= a2)
  {
    while (1)
    {
      uint64_t v7 = (2 * v4);
      if (v7 < v6)
      {
        if ((*(unsigned int (**)(void, void))(v5 + 24))( *(void *)(*(void *)(v5 + 16) + 8LL * (v7 | 1)),  *(void *)(*(void *)(v5 + 16) + 8LL * v7)))
        {
          uint64_t v7 = v7 | 1;
        }

        else
        {
          uint64_t v7 = v7;
        }
      }

      uint64_t result = (*(uint64_t (**)(uint64_t, void))(v5 + 24))( a3,  *(void *)(*(void *)(v5 + 16) + 8LL * v7));
      if ((_DWORD)result) {
        break;
      }
      uint64_t v8 = *(uint64_t (**)(void, uint64_t))(v5 + 32);
      if (v8) {
        uint64_t result = v8(*(void *)(*(void *)(v5 + 16) + 8LL * v4), v4);
      }
      uint64_t v4 = v7;
    }
  }

  LODWORD(v7) = v4;
LABEL_11:
  *(void *)(*(void *)(v5 + 16) + 8LL * v7) = a3;
  uint64_t v9 = *(uint64_t (**)(void, void))(v5 + 32);
  if (v9) {
    uint64_t result = v9(*(void *)(*(void *)(v5 + 16) + 8LL * v7), v7);
  }
  if ((_DWORD)v7 != 1)
  {
    uint64_t result = (*(uint64_t (**)(void, void))(v5 + 24))( *(void *)(*(void *)(v5 + 16) + 8LL * v7),  *(void *)(*(void *)(v5 + 16) + 8LL * (v7 >> 1)));
    if ((_DWORD)result) {
      sub_10003F088();
    }
  }

  return result;
}

uint64_t sub_10003EEDC(uint64_t a1, uint64_t a2)
{
  return sub_10003EC40(a1, a2, *(void *)(*(void *)(a1 + 16) + 8LL * a2));
}

uint64_t sub_10003EF08(uint64_t a1, uint64_t a2)
{
  return sub_10003EDCC(a1, a2, *(void *)(*(void *)(a1 + 16) + 8LL * a2));
}

uint64_t sub_10003EF34(uint64_t a1, unsigned int a2)
{
  if (!a2 || *(_DWORD *)(a1 + 8) < a2) {
    sub_10003F100();
  }
  return *(void *)(*(void *)(a1 + 16) + 8LL * a2);
}

uint64_t sub_10003EF60(uint64_t result, uint64_t (*a2)(void, uint64_t), uint64_t a3)
{
  if (!a2) {
    sub_10003F128();
  }
  uint64_t v3 = result;
  if (*(_DWORD *)(result + 8))
  {
    unsigned int v6 = 1;
    do
      uint64_t result = a2(*(void *)(*(void *)(v3 + 16) + 8LL * v6++), a3);
    while (v6 <= *(_DWORD *)(v3 + 8));
  }

  return result;
}

void sub_10003EFC0()
{
  __assert_rtn("isc_heap_create", "heap.c", 83, "heapp != NULL && *heapp == NULL");
}

void sub_10003EFE8()
{
  __assert_rtn("isc_heap_create", "heap.c", 84, "compare != NULL");
}

void sub_10003F010()
{
  __assert_rtn("isc_heap_destroy", "heap.c", 108, "heapp != NULL");
}

void sub_10003F038()
{
}

void sub_10003F060()
{
  __assert_rtn("isc_heap_delete", "heap.c", 198, "index >= 1 && index <= heap->last");
}

void sub_10003F088()
{
}

void sub_10003F0B0()
{
  __assert_rtn("isc_heap_increased", "heap.c", 215, "index >= 1 && index <= heap->last");
}

void sub_10003F0D8()
{
  __assert_rtn("isc_heap_decreased", "heap.c", 222, "index >= 1 && index <= heap->last");
}

void sub_10003F100()
{
  __assert_rtn("isc_heap_element", "heap.c", 229, "index >= 1 && index <= heap->last");
}

void sub_10003F128()
{
  __assert_rtn("isc_heap_foreach", "heap.c", 238, "action != NULL");
}

uint64_t sub_10003F150(void **a1, uint64_t a2, uint64_t a3)
{
  return sub_10005CE50(a1, (void *)qword_1000BD320, 0LL, a2, a3);
}

uint64_t sub_10003F168( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (qword_1000BD320) {
    sub_100061FB4("attempted to reinitialize icmp protocol", a2, a3, a4, a5, a6, a7, a8, v52);
  }
  unsigned int v10 = sub_100067CD0( &qword_1000BD320,  (uint64_t)"icmp",  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  48LL,  0LL,  2);
  if (v10)
  {
    char v11 = sub_100067900(v10);
    sub_100061FB4("Can't register icmp object type: %s", v12, v13, v14, v15, v16, v17, v18, v11);
  }

  sub_10005CE50( (void **)&qword_10008C118,  (void *)qword_1000BD320,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/icmp.c",  75LL);
  *(void *)(qword_10008C118 + 4__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = a2;
  qword_10008C120 = (uint64_t)sub_100068E0C( "icmp-input",  0LL,  (uint64_t)sub_10003F394,  (uint64_t)nullsub_8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/icmp.c",  81LL);
  qword_10008C128 = (uint64_t)sub_100068E0C( "icmp-output",  0LL,  (uint64_t)sub_10003F420,  (uint64_t)nullsub_9,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/icmp.c",  84LL);
  uint64_t result = sub_100068D4C();
  if (!(_DWORD)result)
  {
    uint64_t v20 = getprotobyname("icmp");
    if (v20) {
      int p_proto = v20->p_proto;
    }
    else {
      int p_proto = 1;
    }
    int v22 = socket(2, 3, p_proto);
    *(_DWORD *)(qword_10008C118 + 32) = v22;
    if (v22 < 0)
    {
      byte_1000BD328 = 1;
      return sub_10006221C("unable to create icmp socket: %m", v23, v24, v25, v26, v27, v28, v29, a9);
    }

    else
    {
      char v53 = 1;
      if (fcntl(v22, 2) < 0) {
        sub_10006221C("Can't set close-on-exec on icmp: %m", v30, v31, v32, v33, v34, v35, v36, 1);
      }
      int v54 = 0;
      if (setsockopt(*(_DWORD *)(qword_10008C118 + 32), 0xFFFF, 16, &v54, 4u) < 0) {
        sub_100061FB4("Can't disable SO_DONTROUTE on ICMP: %m", v37, v38, v39, v40, v41, v42, v43, v53);
      }
      uint64_t result = sub_100060E24(qword_10008C118, (uint64_t)sub_10003F4A8, 0LL, (uint64_t)sub_10003F4B0, 0LL, 0LL);
      if ((_DWORD)result)
      {
        char v44 = sub_100067900(result);
        sub_100061FB4("Can't register icmp handle: %s", v45, v46, v47, v48, v49, v50, v51, v44);
      }
    }
  }

  return result;
}

uint64_t sub_10003F394(uint64_t a1, int a2, unsigned int *a3)
{
  *a3 = bswap32(*a3);
  uint64_t v3 = *(uint64_t (**)(__int128 *, unsigned int *, void))(qword_10008C118 + 40);
  if (v3)
  {
    __int128 v5 = *(_OWORD *)a3;
    unsigned int v6 = a3[4];
    return v3(&v5, a3 + 5, (a2 - 8));
  }

  return result;
}

uint64_t sub_10003F420( uint64_t a1, uint64_t a2, int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((_DWORD)a2 != 48) {
    return sub_10006221C("trace_icmp_output_input: data size mismatch %d:%d", a2, (uint64_t)a3, a4, a5, a6, a7, a8, a2);
  }
  int v8 = *a3;
  v18[0] = 4;
  v18[1] = v8;
  char v17 = sub_100040144(v18, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  return sub_10006221C("trace_icmp_output_input: unsent ping to %s", v9, v10, v11, v12, v13, v14, v15, v17);
}

uint64_t sub_10003F4A8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t sub_10003F4B0(uint64_t a1)
{
  socklen_t v18 = 16;
  unsigned int v2 = recvfrom(*(_DWORD *)(a1 + 32), v27, 0x5DCuLL, 0, &v28, &v18);
  if ((v2 & 0x80000000) != 0)
  {
    sub_10006221C("icmp_echoreply: %m", v3, v4, v5, v6, v7, v8, v9, v17);
    return 34LL;
  }

  else
  {
    uint64_t v10 = 4LL * (v27[0] & 0xF);
    if (v10 + 28 <= (unint64_t)v2 && !v27[4 * (v27[0] & 0xF)] && *(void *)(a1 + 40))
    {
      uint64_t v11 = v2 - v10;
      LODWORD(v25) = 4;
      DWORD1(v25) = *(_DWORD *)&v28.sa_data[2];
      if (sub_100068D58())
      {
        LODWORD(v25) = 0x4000000;
        uint64_t v21 = &v25;
        int v22 = 20;
        uint64_t v23 = v27;
        int v24 = v11;
        sub_1000693DC( qword_10008C120,  2LL,  (uint64_t)&v21,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/icmp.c",  265LL,  v12,  v13,  v14);
        LODWORD(v25) = bswap32(v25);
      }

      uint64_t v15 = *(void (**)(__int128 *, _BYTE *, uint64_t))(a1 + 40);
      __int128 v19 = v25;
      int v20 = v26;
      v15(&v19, v27, v11);
    }

    return 0LL;
  }

BOOL sub_10003F5FC( _DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((byte_1000BD328 & 1) != 0) {
    return 1LL;
  }
  if (!qword_10008C118) {
    sub_100061FB4("ICMP protocol used before initialization.", a2, a3, a4, a5, a6, a7, a8, v39);
  }
  *(void *)&v51.sa_data[6] = 0LL;
  int v9 = a1[1];
  *(_DWORD *)&v51.sa_len = 528;
  *(_DWORD *)&v51.sa_data[2] = v9;
  int v41 = 8;
  __int16 v43 = 0;
  __int16 v42 = (__int16)a1;
  uint64_t v45 = 0LL;
  uint64_t v44 = 0LL;
  int v46 = 0;
  int v10 = sub_10004670C((uint64_t)&v41, 0x1Cu, 0LL);
  HIWORD(v41) = sub_100046778(v10);
  if (sub_100068D4C())
  {
    uint64_t v47 = 0LL;
    int v40 = 0;
    unsigned int v11 = sub_100069AC8((void **)&qword_10008C128, &v40, &v47);
    if (v11)
    {
      char v17 = sub_100067900(v11);
      sub_10006221C("icmp_echorequest: %s", v18, v19, v20, v21, v22, v23, v24, v17);
    }

    if (v47) {
      sub_10005CE20( v47,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/icmp.c",  183LL,  v12,  v13,  v14,  v15,  v16);
    }
    return 1LL;
  }

  if (sub_100068D58())
  {
    uint64_t v47 = a1;
    int v48 = 20;
    uint64_t v49 = &v41;
    int v50 = 28;
    sub_1000693DC( qword_10008C128,  2LL,  (uint64_t)&v47,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/icmp.c",  191LL,  v25,  v26,  v27);
  }

  int v28 = sendto(*(_DWORD *)(qword_10008C118 + 32), &v41, 0x1CuLL, 0, &v51, 0x10u);
  if (v28 < 0)
  {
    v29.in_addr_t s_addr = *(_DWORD *)&v51.sa_data[2];
    char v30 = inet_ntoa(v29);
    sub_10006221C("icmp_echorequest %s: %m", v31, v32, v33, v34, v35, v36, v37, v30);
  }

  return v28 == 28;
}

_DWORD *sub_10003F7A4@<X0>( _DWORD *result@<X0>, _DWORD *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, unint64_t a9@<X8>)
{
  int v9 = (_DWORD *)a9;
  LODWORD(sub_100061FB4( "Usage: dhcpd [-p <UDP port #>] [-f] [-d] [-q] [-t|-T]\n [-4|-6] [-cf config-file] [-lf lease-file]\n [-tf trace-output-file]\n [-play trace-input-file]\n [-pf pid-file] [-s server] [if0 [...ifN]]",  v23,  v24,  v25,  v26,  v27,  v28,  v29, a9) = *result;
  if (*result >= 0x11u) {
    sub_100061FB4( "subnet_number():%s:%d: Invalid addr length.",  (uint64_t)a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/inet.c");
  }
  if ((_DWORD)a9 != *a2) {
    sub_100061FB4( "subnet_number():%s:%d: Addr/mask length mismatch.",  (uint64_t)a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/inet.c");
  }
  *int v9 = a9;
  if ((_DWORD)a9)
  {
    int v10 = (char *)(result + 1);
    unsigned int v11 = (char *)(a2 + 1);
    uint64_t v12 = v9 + 1;
    a9 = a9;
    do
    {
      char v14 = *v10++;
      char v13 = v14;
      char v15 = *v11++;
      *v12++ = v15 & v13;
      --a9;
    }

    while (a9);
  }

  return result;
}

_DWORD *sub_10003F870@<X0>( _DWORD *result@<X0>, _DWORD *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>)
{
  if (*result >= 0x11u) {
    sub_100061FB4( "ip_addr():%s:%d: Invalid addr length.",  (uint64_t)a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/inet.c");
  }
  if (*result != *a2) {
    sub_100061FB4( "ip_addr():%s:%d: Addr/mask length mismatch.",  (uint64_t)a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/inet.c");
  }
  uint64_t v10 = 0LL;
  unsigned int v16 = bswap32(a3);
  *(_OWORD *)a9 = *(_OWORD *)result;
  *(_DWORD *)(a9 + 16) = result[4];
  uint64_t v11 = *(_DWORD *)a9 - 4;
  uint64_t v12 = (char *)a2 + v11 + 7;
  while (!v12[v10])
  {
    *(_BYTE *)(a9 + v11 + 7 + v1__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = *((_BYTE *)&v16 + v10 + 3);
    if (--v10 == -4) {
      return result;
    }
  }

  unsigned int v13 = *((unsigned __int8 *)&v16 + v10 + 3);
  if (v13 > (v12[v10] ^ 0xFFu))
  {
LABEL_13:
    *(_DWORD *)a9 = 0;
  }

  else
  {
    uint64_t v14 = v10 + 2;
    while (v14 + 1 >= 1)
    {
    }

    *(_BYTE *)(v11 + a9 + v10 + 7) |= v13;
  }

  return result;
}

_DWORD *sub_10003F9A8@<X0>( _DWORD *result@<X0>, _DWORD *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, unsigned int *a9@<X8>)
{
  unsigned int v10 = *result;
  if (*result >= 0x11u) {
    sub_100061FB4( "broadcast_addr():%s:%d: Invalid addr length.",  (uint64_t)a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/inet.c");
  }
  if (v10 != *a2) {
    sub_100061FB4( "broadcast_addr():%s:%d: Addr/mask length mismatch.",  (uint64_t)a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/inet.c");
  }
  if (v10)
  {
    uint64_t v11 = (char *)(result + 1);
    uint64_t v12 = (char *)(a2 + 1);
    unsigned int v13 = a9 + 1;
    uint64_t v14 = v10;
    do
    {
      char v16 = *v11++;
      char v15 = v16;
      char v17 = *v12++;
      *v13++ = v15 | ~v17;
      --v14;
    }

    while (v14);
  }

  *a9 = v10;
  return result;
}

uint64_t sub_10003FA78( _DWORD *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *a1;
  if (*a1 >= 0x11u) {
    sub_100061FB4( "host_addr():%s:%d: Invalid addr length.",  (uint64_t)a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/inet.c");
  }
  if (v8 != *a2) {
    sub_100061FB4( "host_addr():%s:%d: Addr/mask length mismatch.",  (uint64_t)a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/inet.c");
  }
  unsigned int v18 = *a1;
  if (v8)
  {
    int v9 = (char *)(a1 + 1);
    unsigned int v10 = (char *)(a2 + 1);
    uint64_t v11 = &v19;
    uint64_t v12 = v8;
    do
    {
      char v14 = *v9++;
      char v13 = v14;
      char v15 = *v10++;
      *(_BYTE *)uint64_t v11 = v13 & ~v15;
      uint64_t v11 = (uint64_t *)((char *)v11 + 1);
      --v12;
    }

    while (v12);
    uint64_t v16 = v8 - 4LL;
  }

  else
  {
    uint64_t v16 = -4LL;
  }

  return bswap32(*(unsigned int *)((char *)&v18 + v16 + 4));
}

BOOL sub_10003FB78( unsigned int *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *a1;
  if (*a1 >= 0x11) {
    sub_100061FB4( "addr_eq():%s:%d: Invalid addr length.",  (uint64_t)a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/inet.c");
  }
  return v8 == *a2 && memcmp(a1 + 1, a2 + 1, v8) == 0;
}

uint64_t sub_10003FBF8(unsigned int *a1, _DWORD *a2)
{
  uint64_t v2 = *a1;
  if ((_DWORD)v2 == *a2)
  {
    if (!(_DWORD)v2) {
      return 1LL;
    }
    uint64_t v3 = (char *)(a1 + 1);
    for (uint64_t i = a2 + 6; ; ++i)
    {
      char v5 = *v3++;
      if (!--v2) {
        return 1LL;
      }
    }
  }

  return 0LL;
}

uint64_t sub_10003FC48(unsigned int *a1, _DWORD *a2)
{
  uint64_t v2 = *a1;
  if ((_DWORD)v2 != *a2 || (_DWORD)v2 == 0) {
    return 0LL;
  }
  uint64_t v4 = (unsigned __int8 *)(a1 + 1);
  char v5 = (unsigned __int8 *)(a2 + 1);
  while (1)
  {
    unsigned int v7 = *v4++;
    unsigned int v6 = v7;
    unsigned int v8 = *v5++;
    BOOL v9 = v6 > v8;
    if (v6 < v8) {
      return 0xFFFFFFFFLL;
    }
    if (v9) {
      break;
    }
    if (!--v2) {
      return 0LL;
    }
  }

  return 1LL;
}

BOOL sub_10003FC98(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  if (*a2 != *a3) {
    return 0LL;
  }
  *a1 = *a2;
  if (!*a2) {
    return 0LL;
  }
  int v3 = 1;
  uint64_t v4 = 4LL;
  do
  {
    char v5 = *((_BYTE *)a3 + v4) | *((_BYTE *)a2 + v4);
    *((_BYTE *)a1 + v4) = v5;
    if (v5) {
      int v3 = 0;
    }
    unint64_t v6 = v4 - 3;
    ++v4;
  }

  while (v6 < *a2);
  return v3 == 0;
}

BOOL sub_10003FCFC(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  if (*a2 != *a3) {
    return 0LL;
  }
  *a1 = *a2;
  if (!*a2) {
    return 0LL;
  }
  int v3 = 1;
  uint64_t v4 = 4LL;
  do
  {
    char v5 = *((_BYTE *)a3 + v4);
    BOOL v6 = (v5 & *((_BYTE *)a2 + v4)) == 0;
    *((_BYTE *)a1 + v4) = v5 & *((_BYTE *)a2 + v4);
    if (!v6) {
      int v3 = 0;
    }
    unint64_t v7 = v4 - 3;
    ++v4;
  }

  while (v7 < *a2);
  return v3 == 0;
}

BOOL sub_10003FD5C(_DWORD *a1, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0) {
    return 0LL;
  }
  int v2 = *a1;
  int v3 = 8 * *a1 - a2;
  if (8 * *a1 < a2) {
    return 0LL;
  }
  int v5 = v3 / 8;
  if (v3 >= 8)
  {
    unsigned int v6 = v2 - 1;
    uint64_t v7 = (v5 + 1) - 1LL;
    while (!*((_BYTE *)a1 + v6 + 4))
    {
      --v6;
      if (!--v7) {
        goto LABEL_8;
      }
    }

    return 0LL;
  }

uint64_t sub_10003FDE8(void *a1, unsigned int *a2, unsigned int *a3)
{
  if (!a1 || *a1) {
    return 39LL;
  }
  uint64_t result = 39LL;
  if (a2)
  {
    if (a3)
    {
      uint64_t v5 = *a2;
      if ((_DWORD)v5 == *a3)
      {
        if ((_DWORD)v5)
        {
          uint64_t v6 = -v5;
          uint64_t v7 = 4LL;
          while (1)
          {
            unsigned int v8 = *((unsigned __int8 *)a2 + v7);
            unsigned int v9 = *((unsigned __int8 *)a3 + v7);
            if (v8 < v9) {
              goto LABEL_13;
            }
            if (v8 > v9) {
              break;
            }
            ++v7;
            if (v6 + v7 == 4) {
              goto LABEL_13;
            }
          }

          unsigned int v10 = a2;
          a2 = a3;
        }

        else
        {
LABEL_13:
          unsigned int v10 = a3;
        }

        int v11 = 0;
        __int128 v49 = *(_OWORD *)a2;
        uint64_t v12 = v49;
        int v42 = v49 - 1;
        int v41 = 8 * v49;
        unsigned int v50 = a2[4];
        uint64_t v47 = 0LL;
        uint64_t v48 = 0LL;
        int v46 = v49;
        while (1)
        {
          uint64_t v13 = *v10;
          if ((_DWORD)v12)
          {
            char v14 = (unsigned __int8 *)&v49 + 4;
            char v15 = (unsigned __int8 *)(v10 + 1);
            uint64_t v16 = v12;
            if ((_DWORD)v12 == (_DWORD)v13)
            {
              do
              {
                unsigned int v18 = *v14++;
                unsigned int v17 = v18;
                unsigned int v19 = *v15++;
                BOOL v20 = v17 > v19;
                if (v17 < v19) {
                  break;
                }
                if (v20) {
                  return 0LL;
                }
                --v16;
              }

              while (v16);
            }
          }

          int v21 = v42 - v11 / 8;
          int v22 = 1 << (v11 & 7);
          if (v21 < 0) {
            break;
          }
          *((_BYTE *)&v46 + v21 + 4) |= v22;
          sub_10003FC98(&v44, &v49, &v46);
          BOOL v23 = v44 != (_DWORD)v13 || v44 == 0;
          uint64_t v24 = (unsigned __int8 *)v45;
          uint64_t v25 = (unsigned __int8 *)(v10 + 1);
          if (!v23)
          {
            do
            {
              unsigned int v27 = *v24++;
              unsigned int v26 = v27;
              unsigned int v28 = *v25++;
              BOOL v29 = v26 > v28;
              if (v26 < v28) {
                break;
              }
              if (v29) {
                goto LABEL_32;
              }
              --v13;
            }

            while (v13);
          }

          if (sub_10003FCFC(v43, &v49, &v46))
          {
LABEL_32:
            char v30 = (char *)sub_10005CDE4(0x20uLL);
            if (!v30)
            {
              char v39 = (void *)*a1;
              if (!*a1) {
                return 1LL;
              }
              do
              {
                int v40 = (void *)*v39;
                sub_10005CE20( v39,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/inet.c",  460LL,  v31,  v32,  v33,  v34,  v35);
                *a1 = v40;
                uint64_t result = 1LL;
                char v39 = v40;
              }

              while (v40);
              return result;
            }

            *(_OWORD *)(v30 + 8) = v49;
            *((_DWORD *)v30 + 6) = v50;
            *((_DWORD *)v30 + 7) = v41 - v11;
            *(void *)char v30 = *a1;
            *a1 = v30;
            unsigned int v36 = v22 + *((unsigned __int8 *)&v49 + v21 + 4);
            if ((v21 & 0x80000000) == 0 && v36 >= 0x100)
            {
              uint64_t v37 = v21;
              do
              {
                *((_BYTE *)&v49 + v37 + 4) = v36;
                int v38 = *((unsigned __int8 *)&v49 + v37 + 3);
                LOBYTE(v36) = v38 + 1;
                int v21 = v37 - 1;
                if (v37 < 1) {
                  break;
                }
                --v37;
              }

              while (v38 == 255);
            }

            if (v21 < 0) {
              return 0LL;
            }
            int v11 = 0;
            *((_BYTE *)&v49 + v21 + 4) = v36;
            uint64_t v47 = 0LL;
            uint64_t v48 = 0LL;
            v45[0] = 0LL;
            v45[1] = 0LL;
          }

          else
          {
            ++v11;
          }
        }

        sub_10003FC98(&v44, &v49, &v46);
        goto LABEL_32;
      }
    }
  }

  return result;
}

uint64_t sub_1000400E8( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 39LL;
  }
  uint64_t result = *a1;
  if (!result) {
    return 39LL;
  }
  do
  {
    *a1 = *(void *)result;
    sub_10005CE20( (void *)result,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/inet.c",  524LL,  a4,  a5,  a6,  a7,  a8);
    uint64_t result = *a1;
  }

  while (*a1);
  return result;
}

const char *sub_100040144( int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *a1;
  if (!*a1) {
    return "<null address>";
  }
  if (v8 == 16)
  {
    unsigned int v9 = a1 + 1;
    int v10 = 30;
  }

  else
  {
    if (v8 != 4) {
      sub_100061FB4( "piaddr():%s:%d: Invalid address length %d.",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/inet.c");
    }
    unsigned int v9 = a1 + 1;
    int v10 = 2;
  }

  return inet_ntop(v10, v9, byte_1000BD329, 0x2Eu);
}

char *sub_1000401D8( int *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = *a1;
  if (*a1 != 4 && v9 != 16) {
    sub_100061FB4( "piaddrmask():%s:%d: Address length %d invalid",  (uint64_t)a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/inet.c");
  }
  if (v9 != *a2) {
    sub_100061FB4( "piaddrmask():%s:%d: Address and mask size mismatch",  (uint64_t)a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/inet.c");
  }
  uint64_t v11 = (8 * v9);
  if ((int)v11 < 1)
  {
    if ((v11 & 0x80000000) == 0) {
      goto LABEL_15;
    }
LABEL_17:
    sub_100061FB4( "Impossible condition at %s:%d.",  v11,  a3,  a4,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/inet.c");
  }

  do
  {
    uint64_t v12 = (v11 - 1);
    if (*((_BYTE *)a2 + (v12 >> 3) + 4))
    {
    }

    else
    {
      uint64_t v12 = (v11 - 8);
    }

    uint64_t v11 = v12;
  }

  while ((int)v12 > 0);
  if ((v12 & 0x80000000) != 0) {
    goto LABEL_17;
  }
LABEL_15:
  uint64_t v11 = 0LL;
  return sub_1000402E0(a1, v11, a3, a4, a5, a6, a7, a8);
}

char *sub_1000402E0( _DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = a2;
  __int128 v13 = *(_OWORD *)a1;
  int v14 = a1[4];
  int v10 = sub_100040144((int *)&v13, a2, a3, a4, a5, a6, a7, a8);
  int v12 = v9;
  int v8 = byte_1000BD357;
  __sprintf_chk(byte_1000BD357, 0, 0x32uLL, "%s/%d", v10, v12);
  return v8;
}

uint64_t sub_100040384(const char *a1)
{
  *__error() = 0;
  unsigned int v9 = strtol(a1, &__endptr, 10);
  if (*__endptr || *__error() == 34 || *__error() == 22) {
    sub_100061FB4("Invalid port number specification: %s", v2, v3, v4, v5, v6, v7, v8, (char)a1);
  }
  if (v9 - 0x10000 <= 0xFFFF0000) {
    sub_100061FB4("Port number specified is out of range (%d-%d).", v2, v3, v4, v5, v6, v7, v8, 1);
  }
  return bswap32(v9) >> 16;
}

uint64_t sub_10004042C(uint64_t a1, int a2)
{
  if (!qword_10008C130) {
    return 39LL;
  }
  uint64_t v18 = 0LL;
  uint64_t v4 = *(const char **)(a1 + 48);
  size_t v5 = strlen(v4);
  sub_100029804(&v18, qword_10008C130, v4, v5, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/memory.c", 49LL);
  if (!v18 || v18 != a1) {
    return 39LL;
  }
  if ((*(_DWORD *)(a1 + 56) & 6) == 2)
  {
    size_t v13 = strlen(*(const char **)(a1 + 48));
    sub_100029210( qword_10008C130,  *(const char **)(a1 + 48),  v13,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/memory.c",  65LL,  v14,  v15,  v16);
  }

  else
  {
    uint64_t v17 = *(void *)(a1 + 40);
    *(_DWORD *)(a1 + 56) |= 1u;
    if (v17) {
      sub_100034198( (char **)(a1 + 40),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/memory.c",  69LL,  v6,  v7,  v8,  v9,  v10);
    }
  }

  else {
    return 0LL;
  }
}

uint64_t sub_100040544( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!qword_10008C130)
  {
    sub_100052C40( &qword_10008C130,  0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/memory.c",  116LL,  a5,  a6,  a7,  a8);
    uint64_t v24 = 0LL;
    goto LABEL_17;
  }

  uint64_t v24 = 0LL;
  uint64_t v10 = *(const char **)(a1 + 48);
  size_t v11 = strlen(v10);
  sub_100029804(&v24, qword_10008C130, v10, v11, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/memory.c", 90LL);
  uint64_t v12 = v24;
  if (v24) {
    BOOL v13 = v24 == a1;
  }
  else {
    BOOL v13 = 1;
  }
  if (v13)
  {
    if (!v24) {
      goto LABEL_17;
    }
  }

  else
  {
    int v14 = *(_DWORD *)(v24 + 56);
    if ((v14 & 2) == 0)
    {
      *(_DWORD *)(a1 + 56) |= 4u;
      int v14 = *(_DWORD *)(v12 + 56);
    }

    if ((v14 & 1) != 0)
    {
      size_t v15 = strlen(*(const char **)(a1 + 48));
      sub_100029210( qword_10008C130,  *(const char **)(a1 + 48),  v15,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/memory.c",  111LL,  v16,  v17,  v18);
      sub_1000235C8(&v24, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/memory.c", 112LL);
    }

    else
    {
      sub_10004042C(v12, 0);
    }

    if (!v24)
    {
LABEL_17:
      size_t v19 = strlen(*(const char **)(a1 + 48));
      sub_100029214( qword_10008C130,  *(const char **)(a1 + 48),  v19,  a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/memory.c",  125LL,  v20,  v21,  v23);
      if (a2) {
        goto LABEL_18;
      }
      return 0LL;
    }
  }

  if (!a2) {
    return 0LL;
  }
LABEL_18:
  return 26LL;
}

uint64_t sub_1000406C0( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v28 = 0LL;
  if (*a1) {
    BOOL v8 = *a1 == a2;
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8) {
    return 0LL;
  }
  uint64_t result = sub_100034064((uint64_t *)&v28, a3, a4, a4, a5, a6, a7, a8);
  if ((_DWORD)result)
  {
    if (*a1 == a2) {
      *a1 = 0LL;
    }
    sub_100034128(a1, (uint64_t)v28, a3, a4, v13, v14, v15, v16);
    uint64_t v17 = (uint64_t *)v28;
    *((_DWORD *)v28 + 1__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = *(_DWORD *)(a2 + 40);
    sub_100034128(v17, a2, a3, a4, v18, v19, v20, v21);
    sub_100034198(&v28, a3, a4, v22, v23, v24, v25, v26);
    return 1LL;
  }

  return result;
}

uint64_t sub_10004077C( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a1 + 20;
  uint64_t result = sub_1000347D8( a1 + 20,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  59LL,  a4,  a5,  a6,  a7,  a8);
  if (!(_DWORD)result)
  {
    *((_DWORD *)a1 + 18) = 0;
    return result;
  }

  if (*(_DWORD *)(*a1 + 236) != 1666417251)
  {
    *((_DWORD *)a1 + 18) = 0;
    return 1LL;
  }

  if (!*v9) {
    return 0LL;
  }
  if (!off_10008C170)
  {
    sub_10006221C("can't look up options in %s space.", *v9, v11, v12, v13, v14, v15, v16, qword_10008C168);
    return 0LL;
  }

  uint64_t result = off_10008C170(&qword_10008C168);
  if (!result) {
    return result;
  }
  uint64_t v20 = *(unsigned __int8 **)(result + 40);
  if (!v20) {
    return 0LL;
  }
  unsigned int v21 = *v20;
  BOOL v22 = v21 > 6;
  int v23 = (1 << v21) & 0x64;
  if (v22 || v23 == 0) {
    return 0LL;
  }
LABEL_6:
  if (!*v9)
  {
LABEL_26:
    uint64_t result = 1LL;
    *((_DWORD *)a1 + 18) = 1;
    return result;
  }

  if (!off_10008C170)
  {
    sub_10006221C("can't look up options in %s space.", *v9, v11, v12, v13, v14, v15, v16, qword_10008C168);
    goto LABEL_26;
  }

  uint64_t v17 = off_10008C170(&qword_10008C168);
  if (!v17) {
    goto LABEL_26;
  }
  uint64_t v18 = v17;
  char v19 = **(_BYTE **)(v17 + 40);
  if ((v19 & 1) != 0)
  {
    uint64_t result = sub_100040920(a1[20], (char *)(*a1 + 108), 0x80u, (uint64_t)&qword_10008C168);
    if (!(_DWORD)result) {
      return result;
    }
    char v19 = **(_BYTE **)(v18 + 40);
  }

  if ((v19 & 2) == 0) {
    goto LABEL_26;
  }
  uint64_t result = sub_100040920(a1[20], (char *)(*a1 + 44), 0x40u, (uint64_t)&qword_10008C168);
  if ((_DWORD)result) {
    goto LABEL_26;
  }
  return result;
}

uint64_t sub_100040920(uint64_t a1, char *a2, unsigned int a3, uint64_t a4)
{
  uint64_t v100 = 0LL;
  uint64_t v101 = 0LL;
  uint64_t v99 = 0LL;
  if (sub_1000345C4( &v100,  a3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  142LL))
  {
    memcpy(v100 + 1, a2, a3);
    if (*(_DWORD *)(a4 + 96) <= a3)
    {
      int v20 = 0;
      while (1)
      {
        unsigned int v21 = (*(uint64_t (**)(char *))(a4 + 64))(&a2[v20]);
        unsigned int v102 = v21;
        if (v21 == *(_DWORD *)(a4 + 108)) {
          goto LABEL_28;
        }
        int v24 = *(_DWORD *)(a4 + 96);
        v20 += v24;
        if (v21) {
          break;
        }
LABEL_27:
        if (v24 + v20 > a3) {
          goto LABEL_28;
        }
      }

      int v25 = *(_DWORD *)(a4 + 100);
      if (v25 + v20 > a3) {
        goto LABEL_32;
      }
      uint64_t v26 = *(uint64_t (**)(char *))(a4 + 80);
      if (v26)
      {
        uint64_t v27 = v26(&a2[v20]);
        int v25 = *(_DWORD *)(a4 + 100);
      }

      else
      {
        if (v25) {
          sub_100061FB4( "Improperly configured option space(%s): may not have a nonzero length size AND a NULL get_length function.",  v22,  v23,  v15,  v16,  v17,  v18,  v19,  *(void *)a4);
        }
        uint64_t v27 = a3 - v24;
      }

      unsigned int v28 = v25 + v20;
      sub_100029804( &v99,  *(void *)(a4 + 120),  &v102,  0LL,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  188LL);
      int v20 = v28 + v27;
      if (v28 + v27 > a3)
      {
        sub_100052CE4( &v99,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  193LL,  v30,  v31,  v32,  v33,  v34);
LABEL_32:
        sub_10006221C( "parse_option_buffer: malformed option %s.%s (code %u): %s.",  v22,  v23,  v15,  v16,  v17,  v18,  v19,  *(void *)a4);
        uint64_t v94 = 200LL;
LABEL_33:
        sub_10003462C( &v100,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  v94,  v89,  v90,  v91,  v92,  v93);
        return 0LL;
      }

      uint64_t v35 = v99;
      if (!v99
        || (**(unsigned __int8 **)(v99 + 8) | 0x20) != 0x65
        || !sub_100040D94(a1, v99, (uint64_t)v100 + v28 + 4, v27, v31, 0LL))
      {
        if (a1)
        {
          unsigned int v36 = *(uint64_t (**)(uint64_t, uint64_t, void))(a4 + 8);
          if (v36)
          {
            uint64_t v37 = v36(a4, a1, v102);
            if (v37)
            {
              uint64_t v42 = v37;
              if (*(_DWORD *)(a4 + 140))
              {
                uint64_t v96 = 0LL;
                uint64_t v97 = 0LL;
                uint64_t v98 = 0LL;
                if (!sub_1000345C4( &v96,  *(_DWORD *)(v37 + 48) + (int)v27,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  221LL))
                {
                  sub_10006221C("parse_option_buffer: No memory.", v43, v44, v45, v46, v47, v48, v49, v95);
                  uint64_t v94 = 224LL;
                  goto LABEL_33;
                }

                memcpy(v96 + 1, *(const void **)(v42 + 40), *(unsigned int *)(v42 + 48));
                memcpy((char *)v96 + *(unsigned int *)(v42 + 48) + 4, (char *)v100 + v28 + 4, v27);
                LODWORD(v98) = *(_DWORD *)(v42 + 48) + v27;
                uint64_t v97 = v96 + 1;
                sub_100034EA8( (_DWORD **)(v42 + 32),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  236LL,  v50,  v51,  v52,  v53,  v54);
                sub_100034E60( v42 + 32,  (uint64_t)&v96,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  237LL,  v55,  v56,  v57,  v58);
                sub_100034EA8( &v96,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  238LL,  v59,  v60,  v61,  v62,  v63);
              }

              else
              {
                do
                {
                  uint64_t v64 = v42;
                  uint64_t v42 = *(void *)(v42 + 8);
                }

                while (v42);
                if (!sub_100034540( &v101,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  246LL,  v38,  v39,  v40,  v41,  v34))
                {
                  sub_10006221C("parse_option_buffer: No memory.", v65, v66, v67, v68, v69, v70, v71, v95);
                  uint64_t v94 = 249LL;
                  goto LABEL_33;
                }

                sub_100052CB0((void *)v101 + 3, *(void *)(v64 + 24));
                unsigned int v73 = v100;
                unsigned int v72 = v101;
                *((void *)v101 + 4) = 0LL;
                sub_100033F18( (void *)v72 + 4,  v73,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  256LL,  v74,  v75,  v76,  v77);
                uint64_t v78 = v101;
                *((void *)v101 + 5) = (char *)v100 + v28 + 4;
                v78[12] = v27;
                sub_100033F18( (void *)(v64 + 8),  v78,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  260LL,  v79,  v80,  v81,  v82);
                sub_100040E08( &v101,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  261LL,  v83,  v84,  v85,  v86,  v87);
              }

              goto LABEL_26;
            }
          }

          else
          {
            sub_10006221C("can't look up options in %s space.", v35, v29, v30, v31, v32, v33, v34, *(void *)a4);
          }
        }

        sub_100040F30((uint64_t *)a4, a1, (uint64_t)v100, (uint64_t)v100 + v28 + 4, v27, v102, 1LL, v34);
      }

LABEL_26:
      sub_100052CE4( &v99,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  268LL,  v30,  v31,  v32,  v33,  v34);
      int v24 = *(_DWORD *)(a4 + 96);
      goto LABEL_27;
    }

    if (v13 <= 0) {
      unsigned int v36 = -(-v13 & 7);
    }
    else {
      unsigned int v36 = v13 & 7;
    }
    if (!v36) {
      return 0LL;
    }
    uint64_t v37 = 8 - v36;
    uint64_t v38 = write(dword_1000C5F9C, &unk_1000C5FB0, (8 - v36));
    if ((v38 & 0x80000000) == 0)
    {
      if (v37 != v38)
      {
        sub_10006221C("%s(%d): trace_write_packet: short write (%d:%d)", v20, v21, v22, v23, v24, v25, v26, v9);
        sub_100069268();
      }

      return 0LL;
    }
  }

  sub_10006221C("%s(%d): trace_write_packet write failed: %m", v20, v21, v22, v23, v24, v25, v26, v9);
  return 34LL;
}

uint64_t sub_100040D4C( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    uint64_t v8 = (uint64_t (*)(void))a1[1];
    if (v8) {
      return v8();
    }
    sub_10006221C("can't look up options in %s space.", a2, a3, 0LL, a5, a6, a7, a8, *a1);
  }

  return 0LL;
}

const char **sub_100040D94(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const char *a6)
{
  uint64_t result = sub_100040FE0(a2, a6);
  if (result)
  {
    uint64_t v11 = result[6];
    if (v11)
    {
      LODWORD(result) = ((uint64_t (*)(uint64_t, uint64_t, uint64_t, const char **))v11)(a1, a3, a4, result);
      if (**(_BYTE **)(a2 + 8) == 69) {
        return (const char **)result;
      }
      else {
        return 0LL;
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_100040E08( int **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && (uint64_t v11 = *a1) != 0LL)
  {
    int v13 = *v11 - 1;
    BOOL v12 = *v11 == 1;
    *uint64_t v11 = v13;
    if (v12)
    {
      if (*((void *)v11 + 4))
      {
        sub_100034EA8((_DWORD **)v11 + 4, a2, a3, a4, a5, a6, a7, a8);
        uint64_t v11 = *a1;
      }

      if (*((void *)v11 + 3))
      {
        sub_100052CE4( (uint64_t *)v11 + 3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  2620LL,  a4,  a5,  a6,  a7,  a8);
        uint64_t v11 = *a1;
      }

      if (*((void *)v11 + 2))
      {
        sub_100054390((uint64_t *)v11 + 2, a2, a3, a4, a5, a6, a7, a8);
        uint64_t v11 = *a1;
      }

      if (*((void *)v11 + 1))
      {
        sub_100040E08(v11 + 2, a2, a3);
        uint64_t v11 = *a1;
      }

      *((void *)v11 + 2) = qword_10008C028;
      qword_10008C028 = (uint64_t)*a1;
      if ((**a1 & 0x80000000) == 0) {
        goto LABEL_5;
      }
    }

    else if ((v13 & 0x80000000) == 0)
    {
LABEL_5:
      *a1 = 0LL;
      return 1LL;
    }

    sub_10006221C("%s(%d): negative refcnt!", a2, a3, a4, a5, a6, a7, a8, a2);
    uint64_t result = 0LL;
    *a1 = 0LL;
  }

  else
  {
    sub_10006221C("Null pointer in option_cache_dereference: %s(%d)", a2, a3, a4, a5, a6, a7, a8, a2);
    return 0LL;
  }

  return result;
}

uint64_t sub_100040F30( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v20 = 0LL;
  uint64_t v17 = sub_100043ED0(a1, a3, a4, a5, a6, a7, &v20, a8);
  if ((_DWORD)v17)
  {
    uint64_t v18 = (void (*)(uint64_t *, uint64_t, int *, void))a1[2];
    if (v18) {
      v18(a1, a2, v20, 0LL);
    }
    else {
      sub_10006221C("can't store options in %s space.", v10, v11, v12, v13, v14, v15, v16, *a1);
    }
  }

  if (v20) {
    sub_100040E08( &v20,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  2210LL,  v12,  v13,  v14,  v15,  v16);
  }
  return v17;
}

const char **sub_100040FE0(uint64_t a1, const char *a2)
{
  uint64_t v3 = strchr(*(const char **)(a1 + 8), 69);
  if (!v3)
  {
    uint64_t v13 = "internal encapsulation format error 1.";
    goto LABEL_6;
  }

  uint64_t v11 = v3 + 1;
  uint64_t v12 = strchr(v3 + 1, 46);
  if (!v12 || v12[1])
  {
    uint64_t v13 = "internal encapsulation format error 2.";
LABEL_6:
    sub_10006221C(v13, v4, v5, v6, v7, v8, v9, v10, v21);
    return 0LL;
  }

  if (a2 && v12 == v11)
  {
    uint64_t v16 = dword_10008C558;
    if (dword_10008C558 < 1) {
      return 0LL;
    }
    uint64_t v17 = (const char ***)qword_10008C570;
    do
    {
      uint64_t v14 = *v17;
      if (!strcmp(**v17, a2)) {
        break;
      }
      uint64_t v14 = 0LL;
      ++v17;
      --v16;
    }

    while (v16);
  }

  else
  {
    int64_t v18 = v12 - v11;
    if (v12 == v11) {
      return 0LL;
    }
    uint64_t v19 = dword_10008C558;
    if (dword_10008C558 < 1) {
      return 0LL;
    }
    int v20 = (const char ***)qword_10008C570;
    do
    {
      uint64_t v14 = *v20;
      uint64_t v14 = 0LL;
      ++v20;
      --v19;
    }

    while (v19);
  }

  return v14;
}

uint64_t sub_100041120(uint64_t a1, _BYTE *a2, unsigned int a3)
{
  unsigned int v36 = 0LL;
  if (a3 < 3) {
    return 0LL;
  }
  unsigned int v3 = a3;
  if (sub_1000345C4( &v36,  a3 + 4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  365LL))
  {
    memcpy((char *)v36 + 7, a2 + 1, v3 - 1);
    *((_BYTE *)v36 + 4) = (*a2 & 4) != 0;
    *((_BYTE *)v36 + 6) = *a2 & 1;
    *((_BYTE *)v36 + 5) = (*a2 & 2) != 0;
    int v20 = v36;
    if (!*((_BYTE *)v36 + 4))
    {
      if (!a2[v3 - 1])
      {
        *((_BYTE *)v36 + 5) = 1;
        --v3;
      }

      uint64_t v26 = v3;
      if (v3 < 4) {
        goto LABEL_36;
      }
      uint64_t v27 = 3LL;
      while (a2[v27] != 46)
      {
        if (v26 == ++v27)
        {
          LODWORD(v27) = v26;
          break;
        }
      }

      if ((_DWORD)v27 == 3)
      {
LABEL_36:
        LODWORD(v27) = 3;
      }

      else if (!sub_100040F30( &qword_10008C318,  a1,  (uint64_t)v36,  (uint64_t)v36 + 9,  (v27 - 3),  6LL,  0LL,  v19))
      {
        goto LABEL_49;
      }

      if (v26 > (int)v27 + 1
        && !sub_100040F30( &qword_10008C318,  a1,  (uint64_t)v36,  (uint64_t)v36 + (v27 + 3) + 4,  (v26 + ~(_DWORD)v27),  7LL,  1LL,  v19))
      {
        goto LABEL_49;
      }

      if (v26 >= 4)
      {
        uint64_t v29 = v36;
        uint64_t v30 = (char *)v36 + 9;
        uint64_t v31 = (v26 - 3);
        uint64_t v32 = a1;
        goto LABEL_43;
      }

      goto LABEL_44;
    }

    char v21 = (char *)v36 + 9;
    if ((char *)v36 + 9 >= (char *)v36 + v3 + 6)
    {
      unsigned int v23 = 0;
LABEL_27:
      if (v23) {
        uint64_t v28 = v23 - 1;
      }
      else {
        uint64_t v28 = 0LL;
      }
      uint64_t v22 = v28;
      if (!(_DWORD)v28)
      {
LABEL_32:
        if (v23 >= 2 && (_DWORD)v28 != (_DWORD)v22)
        {
          if (!sub_100040F30( &qword_10008C318,  a1,  (uint64_t)v36,  (uint64_t)v36 + (v22 + 6) + 4,  (v28 - v22),  7LL,  1LL,  v19)) {
            goto LABEL_49;
          }
          goto LABEL_42;
        }

        if (v23 >= 2)
        {
LABEL_42:
          uint64_t v29 = v36;
          uint64_t v30 = (char *)v36 + 10;
          uint64_t v32 = a1;
          uint64_t v31 = v28;
LABEL_43:
LABEL_49:
          sub_10003462C( &v36,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  378LL,  v15,  v16,  v17,  v18,  v19);
          return 0LL;
        }

LABEL_44:
        if (sub_100040F30(&qword_10008C318, a1, (uint64_t)v36, (uint64_t)v36 + 5, 1LL, 1LL, 0LL, v19)
          && sub_100040F30(&qword_10008C318, a1, (uint64_t)v36, (uint64_t)v36 + 6, 1LL, 2LL, 0LL, v19)
          && sub_100040F30(&qword_10008C318, a1, (uint64_t)v36, (uint64_t)v36 + 7, 1LL, 4LL, 0LL, v19)
          && sub_100040F30(&qword_10008C318, a1, (uint64_t)v36, (uint64_t)(v36 + 2), 1LL, 5LL, 0LL, v19))
        {
          sub_10003462C( &v36,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  514LL,  v15,  v16,  v17,  v18,  v19);
          return 1LL;
        }

        goto LABEL_49;
      }
    }

    else
    {
      uint64_t v22 = 0LL;
      unsigned int v23 = 0;
      while (1)
      {
        uint64_t v24 = *v21;
        if (v24 >= 0x40)
        {
          uint64_t v34 = "fancy bits in fqdn option";
LABEL_58:
          sub_1000622D4(v34, v14, (uint64_t)v20, v15, v16, v17, v18, v19, v35);
          return 0LL;
        }

        if (!*v21) {
          break;
        }
        if (&v21[v24] > (_BYTE *)v20 + v3 + 7)
        {
          uint64_t v34 = "fqdn tag longer than buffer";
          goto LABEL_58;
        }

        if ((_DWORD)v22) {
          uint64_t v22 = v22;
        }
        else {
          uint64_t v22 = *v21;
        }
        *char v21 = 46;
        uint64_t v25 = v24 + 1;
        v21 += v25;
        v23 += v25;
        int v20 = v36;
        if (v21 >= (_BYTE *)v36 + v3 + 6) {
          goto LABEL_27;
        }
      }

      if (v23) {
        uint64_t v28 = v23 - 1;
      }
      else {
        uint64_t v28 = 0LL;
      }
      if (!(_DWORD)v22) {
        goto LABEL_32;
      }
    }

    goto LABEL_32;
  }

  sub_10006221C("no memory for option buffer.", v6, v7, v8, v9, v10, v11, v12, v35);
  return 0LL;
}

uint64_t sub_100041504( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int *a6, _DWORD *a7, uint64_t *a8, int a9, int a10, int a11, uint64_t a12, uint64_t a13)
{
  int v16 = a5;
  size_t __n_4 = a2;
  int v86 = 0;
  uint64_t v88 = 0LL;
  uint64_t v89 = 0LL;
  uint64_t v87 = 0LL;
  if (a1)
  {
    a2 = *(void *)(a1 + 160);
    if (a2)
    {
      if (off_10008C170)
      {
        uint64_t v19 = off_10008C170(&qword_10008C168);
        if (v19)
        {
          sub_100057AA4( &v87,  (unsigned int *)a1,  a3,  a4,  (uint64_t)a6,  (uint64_t)a7,  a8,  v19,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  0x231u);
          if (v89 >= 2)
          {
            int v25 = sub_100060B5C(v88);
            if (v25 < v16 || v16 == 0) {
              int v16 = v25;
            }
          }

          sub_100034EA8( &v87,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  567LL,  v20,  v21,  v22,  v23,  v24);
        }
      }

      else
      {
        sub_10006221C( "can't look up options in %s space.",  a2,  a3,  a4,  a5,  (uint64_t)a6,  (uint64_t)a7,  (uint64_t)a8,  qword_10008C168);
      }
    }
  }

  if (v16)
  {
    int v27 = v16 - 264;
    if (v16 >= 576) {
      unsigned int v28 = v27;
    }
    else {
      unsigned int v28 = 312;
    }
  }

  else
  {
    if (a11) {
      unsigned int v28 = 64;
    }
    else {
      unsigned int v28 = 312;
    }
    if (a1 && a11)
    {
      else {
        unsigned int v28 = *(_DWORD *)(a1 + 12) - 264;
      }
    }
  }

  if (a4)
  {
    unsigned int __n = 0;
  }

  else
  {
    LODWORD(v92) = 82;
    unsigned int __n = sub_100041BEC( 0LL,  (size_t)__src,  0LL,  1024LL,  (unsigned int *)a1,  a3,  0LL,  a6,  (uint64_t)a7,  a8,  (uint64_t)&v92,  1,  0,  0,  0,  0LL);
    if (__n + v28 >= 0x4D4) {
      unsigned int v28 = 1236;
    }
    else {
      v28 += __n;
    }
  }

  uint64_t v29 = a13;
  int v30 = a10;
  unsigned int v31 = v28 + 128;
  if ((a9 & 1) == 0) {
    unsigned int v31 = v28;
  }
  if ((a9 & 2) != 0) {
    uint64_t v32 = v31 + 64;
  }
  else {
    uint64_t v32 = v31;
  }
  int v84 = v31 & (a9 << 30 >> 31);
  __int128 v92 = xmmword_100082880;
  uint64_t v93 = 0x5C00000032LL;
  if (a12 && *(_DWORD *)(a12 + 16))
  {
    uint64_t v33 = v32;
    if (a7)
    {
      if (off_10008C170)
      {
        if (off_10008C170(&qword_10008C168))
        {
          LODWORD(v94) = 118;
          int v34 = 7;
          goto LABEL_81;
        }
      }

      else
      {
        sub_10006221C( "can't look up options in %s space.",  a2,  a3,  v32,  a5,  (uint64_t)a6,  (uint64_t)a7,  (uint64_t)a8,  qword_10008C168);
      }
    }

    int v34 = 6;
LABEL_81:
    sub_100034EDC(a12, 300 - v34);
    uint64_t v57 = *(unsigned int *)(a12 + 16);
    if ((_DWORD)v57)
    {
      uint64_t v58 = *(unsigned __int8 **)(a12 + 8);
      int v38 = (a9 << 31 >> 31) & v28;
      int v30 = a10;
      uint64_t v32 = v33;
      uint64_t v29 = a13;
      do
      {
        int v60 = *v58++;
        int v59 = v60;
        if (v60 != 82) {
          *((_DWORD *)&v92 + v34++) = v59;
        }
        --v57;
      }

      while (v57);
      if (v34 > 299) {
        goto LABEL_99;
      }
    }

    else
    {
      int v38 = (a9 << 31 >> 31) & v28;
      int v30 = a10;
      uint64_t v32 = v33;
      uint64_t v29 = a13;
    }

    uint64_t v61 = *(void *)(a1 + 160);
    if (!v61) {
      goto LABEL_96;
    }
    if (off_10008C320)
    {
      if (off_10008C320(&qword_10008C318))
      {
        *((_DWORD *)&v92 + v34) = 81;
        int v30 = a10;
        uint64_t v32 = v33;
        uint64_t v29 = a13;
        if (v34 > 298)
        {
          int v34 = 300;
          goto LABEL_99;
        }

        ++v34;
        goto LABEL_96;
      }
    }

    else
    {
      sub_10006221C("can't look up options in %s space.", v61, v52, v32, v53, v54, v55, v56, qword_10008C318);
    }

    int v30 = a10;
    uint64_t v32 = v33;
    uint64_t v29 = a13;
LABEL_96:
    if ((*(_DWORD *)(a1 + 16) | 2) != 3) {
      goto LABEL_99;
    }
    int v51 = 1;
    goto LABEL_98;
  }

  __int128 v94 = xmmword_100082890;
  int v95 = 81;
  unsigned int v35 = a7[3];
  if (v35)
  {
    uint64_t v36 = 0LL;
    uint64_t v37 = *(void *)&a7[2 * dword_10008C1F0 + 4];
    int v34 = 11;
    int v38 = (a9 << 31 >> 31) & v28;
    do
    {
      if (v37)
      {
        for (uint64_t i = *(void **)(v37 + 8 * v36); i; uint64_t i = (void *)i[1])
        {
          unsigned int v40 = *(_DWORD *)(*(void *)(*i + 24LL) + 24LL);
          BOOL v41 = v40 == 82 || v40 >= v35;
          if (!v41 && v34 <= 299) {
            *((_DWORD *)&v92 + v34++) = v40;
          }
        }
      }

      ++v36;
    }

    while (v36 != 17);
  }

  else
  {
    int v34 = 11;
    int v38 = (a9 << 31 >> 31) & v28;
  }

  uint64_t v42 = 0LL;
  uint64_t v43 = *(void *)&a7[2 * a7[2] + 4];
  do
  {
    if (v43)
    {
      for (uint64_t j = *(void **)(v43 + 8 * v42); j; uint64_t j = (void *)j[1])
      {
        unsigned int v45 = *(_DWORD *)(*(void *)(*j + 24LL) + 24LL);
        BOOL v46 = v45 != 82 && v45 >= v35;
        if (v46 && v34 <= 299) {
          *((_DWORD *)&v92 + v34++) = v45;
        }
      }
    }

    ++v42;
  }

  while (v42 != 17);
  uint64_t v47 = a7[1];
  if ((int)v47 >= 1)
  {
    uint64_t v48 = qword_10008C570;
    do
    {
      uint64_t v49 = *(void *)(*(void *)v48 + 128LL);
      if (v49)
      {
        if (v34 <= 299 && *(uint64_t **)(v49 + 16) == &qword_10008C168)
        {
          int v50 = *(_DWORD *)(v49 + 24);
          if (v50 != 82) {
            *((_DWORD *)&v92 + v34++) = v50;
          }
        }
      }

      v48 += 8LL;
      --v47;
    }

    while (v47);
  }

  if (v34 <= 299)
  {
    int v51 = 43;
LABEL_98:
    *((_DWORD *)&v92 + v34++) = v51;
  }

LABEL_108:
  if (v28 - v70 >= v72)
  {
    memcpy((char *)v91 + v70, __src, v72);
    v70 += v72;
  }

  else
  {
    sub_10006221C("Unable to store relay agent information in reply packet.", v63, v64, v65, v66, v67, v68, v69, v81);
  }

LABEL_113:
  if (v70 < v28) {
    *((_BYTE *)v91 + v70++) = -1;
  }
  memcpy((void *)(__n_4 + 236), v91, v70);
  return v70 + 236;
}

uint64_t sub_100041BEC( _DWORD *a1, size_t a2, uint64_t a3, uint64_t a4, unsigned int *a5, uint64_t a6, uint64_t a7, int *a8, uint64_t a9, uint64_t *a10, uint64_t a11, int a12, int a13, int a14, int a15, uint64_t a16)
{
  uint64_t v128 = (uint64_t)a8;
  int v16 = a12;
  v153[0] = 0LL;
  int v152 = 0;
  uint64_t v147 = 0LL;
  unsigned int v17 = a4 - a3;
  int v139 = a13 - a3;
  if (a13) {
    unsigned int v18 = a13 - a3;
  }
  else {
    unsigned int v18 = 0;
  }
  unsigned int v131 = a4 - a3;
  unsigned int v132 = a14 - a3;
  if (a14) {
    unsigned int v19 = a14 - a3;
  }
  else {
    unsigned int v19 = 0;
  }
  if (!v18)
  {
    if (v19)
    {
      if (v19 >= v17) {
        goto LABEL_19;
      }
      int v139 = a14 - a3;
      unsigned int v132 = a4 - a3;
      goto LABEL_20;
    }

    unsigned int v20 = a4 - a3;
    int v139 = a4 - a3;
LABEL_18:
    unsigned int v132 = v20;
    goto LABEL_20;
  }

  if (v18 >= v17) {
    sub_100061FB4( "%s:%d:store_options: Invalid first cutoff.",  a2,  a3,  a4,  (uint64_t)a5,  a6,  a7,  (uint64_t)a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c");
  }
  if (!v19)
  {
    unsigned int v20 = a4 - a3;
    goto LABEL_18;
  }

  if (v19 >= v17) {
LABEL_19:
  }
    sub_100061FB4( "%s:%d:store_options: Invalid second cutoff.",  a2,  a3,  a4,  (uint64_t)a5,  a6,  a7,  (uint64_t)a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c");
LABEL_20:
  size_t v137 = a2 + a3;
  uint64_t v149 = 0LL;
  uint64_t v150 = 0LL;
  uint64_t v151 = 0LL;
  unsigned int v21 = a12 - 1;
  if (a12 > 1)
  {
    uint64_t v22 = 0LL;
    uint64_t v23 = 1LL;
    do
    {
      uint64_t v24 = v22 + 1;
      if (v22 + 1 >= v16)
      {
        int v27 = *(_DWORD *)(a11 + 4 * v22);
      }

      else
      {
        int v25 = 0;
        uint64_t v26 = v23;
        do
        {
          if (v25) {
            *(_DWORD *)(a11 + 4LL * ((int)v26 - v25)) = *(_DWORD *)(a11 + 4 * v26);
          }
          int v27 = *(_DWORD *)(a11 + 4 * v22);
          if (v27 == *(_DWORD *)(a11 + 4 * v26)) {
            ++v25;
          }
          v16 -= v27 == *(_DWORD *)(a11 + 4 * v26++);
        }

        while (v16 + v25 > (int)v26);
      }

      if (v27 == 1)
      {
        uint64_t v28 = v22;
        while (1)
        {
          uint64_t v29 = v28 - 1;
          if (v28 < 1) {
            break;
          }
          int v30 = *(_DWORD *)(a11 + 4 * v28-- - 4);
          if (v30 == 3)
          {
            *(_DWORD *)(a11 + 4 * v29) = 1;
            *(_DWORD *)(a11 + 4 * v22) = 3;
            break;
          }
        }
      }

      unsigned int v21 = v16 - 1;
      ++v23;
      ++v22;
    }

    while (v24 < v16 - 1);
  }

  unsigned int v133 = v19;
  unsigned int v136 = v18;
  if (v16 >= 1)
  {
    uint64_t v31 = 0LL;
    unsigned int v124 = v18 + 3;
    unsigned int v122 = v19 + 3;
    uint64_t v32 = a9;
    size_t v130 = v137 + (int)v19;
    size_t v129 = v137 + v18;
    uint64_t v134 = v21;
    uint64_t v33 = v16;
    int v34 = &unk_1000BD000;
    uint64_t v123 = v16;
    while (1)
    {
      uint64_t v143 = 0LL;
      uint64_t v144 = 0LL;
      uint64_t v145 = 0LL;
      if (v147) {
        sub_100052CE4( &v147,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  1217LL,  a4,  (uint64_t)a5,  a6,  a7,  (uint64_t)a8);
      }
      uint64_t v35 = *(unsigned int *)(a11 + 4 * v31);
      int v146 = v35;
      uint64_t v36 = &qword_10008C168;
      uint64_t v37 = (uint64_t (*)(uint64_t *, uint64_t))v36[1];
      if (v37)
      {
        uint64_t v38 = v37(v36, v32);
        char v148 = (int *)v38;
        if (v38)
        {
          uint64_t v39 = *(void *)(v38 + 24);
          if (v39)
          {
            sub_100052CB0(&v147, v39);
            goto LABEL_49;
          }
        }
      }

      else
      {
        sub_10006221C("can't look up options in %s space.", a2, v35, a4, (uint64_t)a5, a6, a7, (uint64_t)a8, *v36);
        char v148 = 0LL;
      }

      sub_100029804( &v147,  v36[15],  &v146,  0LL,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  1234LL);
LABEL_49:
      a8 = v148;
      if (!v147) {
        goto LABEL_62;
      }
      unsigned int v40 = *(const char **)(v147 + 8);
      int v41 = *(unsigned __int8 *)v40;
      if (v148)
      {
        if (v41 != 101)
        {
          LODWORD(v151) = 0;
          sub_100057AA4( &v149,  a5,  a6,  a7,  v128,  v32,  a10,  (uint64_t)v148,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  0x51Du);
          unsigned int v42 = v151;
          if ((_DWORD)v151) {
            goto LABEL_85;
          }
          goto LABEL_80;
        }
      }

      else if (v41 != 69)
      {
        a8 = 0LL;
LABEL_62:
        BOOL v48 = 0;
        if (a8) {
          goto LABEL_75;
        }
        goto LABEL_74;
      }

      uint64_t v43 = strchr(v40, 69);
      v34[114] = v43;
      if (!v43) {
        goto LABEL_72;
      }
      uint64_t v44 = v43 + 1;
      v34[114] = v43 + 1;
      unsigned int v45 = strchr(v43 + 1, 46);
      qword_1000BD398 = (uint64_t)v45;
      if (!v45) {
        goto LABEL_72;
      }
      uint64_t v140 = 0LL;
      uint64_t v141 = 0LL;
      uint64_t v142 = 0LL;
      if (v45 != v44)
      {
        uint64_t v141 = v44;
        int v47 = (_DWORD)v45 - (_DWORD)v44;
        goto LABEL_59;
      }

      if (qword_10008C148)
      {
        uint64_t v54 = *(void **)(qword_10008C148 + 16);
        uint64_t v55 = (uint64_t (*)(void))v54[1];
        if (v55)
        {
          uint64_t v56 = v55();
          if (v56) {
            sub_100057AA4( &v140,  a5,  a6,  a7,  v128,  v32,  a10,  v56,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  0x4F5u);
          }
        }

        else
        {
          sub_10006221C("can't look up options in %s space.", a2, a3, a4, (uint64_t)a5, a6, a7, v46, *v54);
        }
      }

      else if (a16)
      {
        uint64_t v141 = v45;
        int v47 = strlen(v45);
LABEL_59:
        LODWORD(v142) = v47;
        if (v47) {
          goto LABEL_60;
        }
        goto LABEL_72;
      }

      if ((_DWORD)v142)
      {
LABEL_60:
        BOOL v48 = sub_100042CCC((uint64_t)&v143, (uint64_t)a5, a6, a7, v128, v32, (uint64_t)a10, (uint64_t)&v140);
        sub_100034EA8( &v140,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  1286LL,  v49,  v50,  v51,  v52,  v53);
        goto LABEL_73;
      }

LABEL_138:
      if (++v31 == v33)
      {
        if (v147) {
          sub_100052CE4( &v147,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  1460LL,  a4,  (uint64_t)a5,  a6,  a7,  (uint64_t)a8);
        }
        break;
      }
    }
  }

  int v112 = v153[0];
  if (v18 && LODWORD(v153[0]))
  {
    unsigned int v113 = LODWORD(v153[0]) + v136;
    unsigned int v114 = LODWORD(v153[0]) + v136 + 1;
    a2 = v132 - v114;
    if (v132 <= v114)
    {
      if (v113 >= v132) {
        sub_100061FB4( "Second buffer overflow in overloaded options.",  a2,  a3,  a4,  (uint64_t)a5,  a6,  a7,  (uint64_t)a8,  v118);
      }
    }

    else
    {
      bzero((void *)(v137 + v114), a2);
    }

    *(_BYTE *)(v137 + v113) = -1;
    if (a1) {
      *a1 |= 1u;
    }
  }

  if (v133 && v152)
  {
    uint64_t v115 = v152 + (uint64_t)(int)v133;
    a2 = v131 - ((_DWORD)v115 + 1);
    if (v131 <= (int)v115 + 1)
    {
      if (v115 >= v131) {
        sub_100061FB4( "Third buffer overflow in overloaded options.",  a2,  a3,  a4,  (uint64_t)a5,  a6,  a7,  (uint64_t)a8,  v118);
      }
    }

    else
    {
      bzero((void *)(v137 + v115 + 1), a2);
    }

    *(_BYTE *)(v137 + v115) = -1;
    if (a1) {
      *a1 |= 2u;
    }
  }

  else if (!(v112 | v152))
  {
    return HIDWORD(v153[0]);
  }

  uint64_t v116 = HIDWORD(v153[0]);
  if (HIDWORD(v153[0]) + 3 > v139) {
    sub_100061FB4("Not enough space for option overload option.", a2, a3, a4, (uint64_t)a5, a6, a7, (uint64_t)a8, v118);
  }
  return v116;
}

uint64_t sub_1000425E0( uint64_t a1, uint64_t a2, uint64_t a3, unsigned int *a4, unsigned int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = (int *)a5;
  uint64_t v10 = a3;
  int v73 = a2;
  uint64_t v11 = qword_10008C718;
  if (!qword_10008C718) {
    goto LABEL_6;
  }
  while (1)
  {
    uint64_t v12 = *(uint64_t **)(v11 + 16);
    if (v12 == &qword_10008C1F8) {
      break;
    }
    uint64_t v11 = v12[16];
    if (!v11) {
      goto LABEL_6;
    }
  }

  int v70 = *(_DWORD *)(v11 + 24);
  if (!v70) {
LABEL_6:
  }
    sub_100061FB4("No VSIO option code found.", a2, a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v65);
  if (a5 && (a3 = *a5, (_DWORD)a3))
  {
    uint64_t v13 = 0LL;
    int v71 = 0;
    uint64_t v14 = 0LL;
    uint64_t v15 = a5;
    do
    {
      int v16 = v71;
      if ((_DWORD)a3 == v70) {
        int v16 = 1;
      }
      int v71 = v16;
      if (v10)
      {
        if (off_10008C200)
        {
          uint64_t v17 = off_10008C200();
          if (v17)
          {
            uint64_t v18 = v17;
            uint64_t v74 = 0LL;
            char __src = 0LL;
            size_t __n = 0LL;
            do
            {
              if (sub_100057AA4( &v74,  a4,  0LL,  0LL,  v10,  0LL,  &qword_10008C730,  v18,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  0x3C9u))
              {
                if ((int)__n + 4 <= (v73 - v14))
                {
                  uint64_t v31 = (_WORD *)(a1 + (int)v14);
                  sub_100060B78(v31, *v15);
                  sub_100060B78(v31 + 1, __n);
                  uint64_t v32 = v31 + 2;
                  LODWORD(sub_1000622D4("All rights reserved.", v16, v17, v18, v19, v20, v21, v22, v31) = __n;
                  memcpy(v32, __src, __n);
                  uint64_t v14 = (v14 + (_DWORD)v31 + 4);
                }

                else
                {
                  sub_10006238C("No space for option %d", v19, v20, v21, v22, v23, v24, v25, *v15);
                }

                sub_100034EA8( &v74,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  988LL,  v26,  v27,  v28,  v29,  v30);
              }

              else
              {
                sub_10006221C("Error evaluating option %d", v19, v20, v21, v22, v23, v24, v25, *v15);
              }

              uint64_t v18 = *(void *)(v18 + 8);
            }

            while (v18);
          }
        }

        else
        {
          sub_10006221C( "can't look up options in %s space.",  a2,  a3,  (uint64_t)a4,  (uint64_t)a5,  a6,  a7,  a8,  qword_10008C1F8);
        }
      }

      ++v13;
      uint64_t v8 = (int *)a5;
      uint64_t v15 = &a5[v13];
      a3 = *v15;
    }

    while ((_DWORD)a3);
  }

  else
  {
    uint64_t v14 = 0LL;
    int v71 = 0;
  }

  uint64_t v33 = a6;
  if (a6)
  {
    unint64_t v34 = *(unsigned int *)(a6 + 16);
    if (v34 >= 2)
    {
      uint64_t v35 = 0LL;
      unint64_t v67 = v34 >> 1;
      uint64_t v36 = &qword_10008C1F8;
      uint64_t v66 = v8 + 1;
      do
      {
        uint64_t v37 = bswap32(*(unsigned __int16 *)(*(void *)(v33 + 8) + 2 * v35)) >> 16;
        if (v8)
        {
          int v38 = *v8;
          if (*v8)
          {
            uint64_t v39 = v66;
            while (v38 != (_DWORD)v37)
            {
              int v40 = *v39++;
              int v38 = v40;
              if (!v40) {
                goto LABEL_36;
              }
            }

            goto LABEL_52;
          }
        }

LABEL_36:
        int v41 = v71;
        if (v70 == (_DWORD)v37) {
          int v41 = 1;
        }
        int v71 = v41;
        if (v10)
        {
          unsigned int v42 = (uint64_t (*)(uint64_t *, uint64_t, uint64_t))v36[1];
          if (v42)
          {
            uint64_t v43 = v42(v36, v10, v37);
            char __src = 0LL;
            size_t __n = 0LL;
            uint64_t v74 = 0LL;
            if (v43)
            {
              uint64_t v44 = v43;
              do
              {
                if (sub_100057AA4( &v74,  a4,  0LL,  0LL,  v10,  0LL,  &qword_10008C730,  v44,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  0x40Eu))
                {
                  if ((int)__n + 4 <= (v73 - v14))
                  {
                    uint64_t v57 = v36;
                    uint64_t v58 = (_WORD *)(a1 + (int)v14);
                    sub_100060B78(v58, v37);
                    sub_100060B78(v58 + 1, __n);
                    uint64_t v59 = v58 + 2;
                    LODWORD(v58) = __n;
                    memcpy(v59, __src, __n);
                    int v60 = v14 + (_DWORD)v58;
                    uint64_t v36 = v57;
                    uint64_t v14 = (v60 + 4);
                  }

                  else
                  {
                    sub_10006238C("No space for option %d", v45, v46, v47, v48, v49, v50, v51, v37);
                  }

                  sub_100034EA8( &v74,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  1053LL,  v52,  v53,  v54,  v55,  v56);
                }

                else
                {
                  sub_10006221C("Error evaluating option %d", v45, v46, v47, v48, v49, v50, v51, v37);
                }

                uint64_t v44 = *(void *)(v44 + 8);
              }

              while (v44);
            }

            uint64_t v8 = (int *)a5;
            goto LABEL_52;
          }

          sub_10006221C("can't look up options in %s space.", a2, a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, *v36);
        }

        uint64_t v74 = 0LL;
        char __src = 0LL;
        size_t __n = 0LL;
LABEL_52:
        uint64_t v33 = a6;
        ++v35;
      }

      while (v35 != v67);
    }
  }

  if (v71 && *(int *)(v10 + 4) >= 1)
  {
    uint64_t v61 = 0LL;
    do
    {
      if (*(void *)(v10 + 8 * v61 + 16))
      {
        uint64_t v62 = *(void *)(*(void *)(qword_10008C570 + 8 * v61) + 128LL);
        if (v62)
        {
          if (*(uint64_t **)(v62 + 16) == &qword_10008C698)
          {
            if (v63) {
              v63(a4, 0LL, 0LL, 0LL, v10, 0LL);
            }
          }
        }
      }

      ++v61;
    }

    while (v61 < *(int *)(v10 + 4));
  }

  return v14;
}

uint64_t sub_100042AB0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = *(uint64_t (**)(void))(a7 + 24);
  if (v7) {
    return v7();
  }
  return result;
}

_DWORD **sub_100042AC8( uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t *a9)
{
  unint64_t v34 = 0LL;
  char __src = 0LL;
  size_t __n = 0LL;
  if (!sub_100057AA4( &v34,  a2,  0LL,  0LL,  a6,  0LL,  &qword_10008C730,  a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  0x366u)) {
    return (_DWORD **)sub_10006221C( "Error evaluating option %d in VSIO space %s.",  v11,  v12,  v13,  v14,  v15,  v16,  v17,  *(_DWORD *)(*(void *)(a1 + 24) + 24LL));
  }
  int v18 = *(_DWORD *)(a8 + 96);
  uint64_t v19 = *((int *)a9 + 3);
  if (v18 + (int)__n + *(_DWORD *)(a8 + 100) <= *((_DWORD *)a9 + 2) - (int)v19)
  {
    if (v18 == 4)
    {
      sub_100060B6C((_DWORD *)(*a9 + v19), *(_DWORD *)(*(void *)(a1 + 24) + 24LL));
      int v28 = *((_DWORD *)a9 + 3) + 4;
    }

    else
    {
      if (v18 != 2)
      {
        if (v18 == 1)
        {
          int v26 = *(_DWORD *)(*(void *)(a1 + 24) + 24LL);
          uint64_t v27 = *a9;
          *((_DWORD *)a9 + 3) = v19 + 1;
          *(_BYTE *)(v27 + v19) = v26;
        }

BOOL sub_100042CCC( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v24 = 0LL;
  sub_100029804( &v24,  qword_10008C560,  *(void *)(a8 + 8),  *(unsigned int *)(a8 + 16),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  2822LL);
  if (v24)
  {
    uint64_t v22 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v24 + 56);
    if (v22) {
      return v22(a1, a2, a3, a4, a5, a6, a7) != 0;
    }
    sub_10006221C( "encapsulation requested for '%s' with no support.",  v16,  v17,  v18,  v19,  v20,  v21,  v24,  *(void *)(a8 + 8));
  }

  else
  {
    sub_10006221C( "option_space_encapsulate: option space '%.*s' does not exist, but is configured.",  v16,  v17,  v18,  v19,  v20,  v21,  0LL,  *(_DWORD *)(a8 + 16));
  }

  return 0LL;
}

uint64_t sub_100042DBC( char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = *a1;
  if (*a1)
  {
    char v9 = (char)a1;
    uint64_t v10 = a1;
    do
    {
      ++v10;
      if (v8 > 77)
      {
        uint64_t v11 = (v8 - 88);
        if (v11 <= 0x20)
        {
          if (v11 == 11)
          {
            sub_10006221C( "format_has_text(%s): 'c' atoms are illegal except after 'D' atoms.",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  v9);
            goto LABEL_16;
          }

          if (((1LL << (v8 - 88)) & 0x100000201LL) != 0) {
            return 0LL;
          }
          if (((1LL << (v8 - 88)) & 0x10001000) != 0) {
            return 1LL;
          }
        }

        if (v8 == 78)
        {
LABEL_14:
          do
          {
            int v12 = *v10;
            if (!*v10) {
              return 0LL;
            }
            ++v10;
          }

          while (v12 != 46);
        }
      }

      else
      {
        if (v8 == 69) {
          goto LABEL_14;
        }
        if (v8 == 65 || v8 == 68) {
          return 0LL;
        }
      }

uint64_t sub_100042EAC( char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = *a1;
  if (!*a1) {
    return 0LL;
  }
  char v9 = (char)a1;
  int v10 = 0;
  uint64_t v11 = 0LL;
  int v12 = a1;
  while (2)
  {
    ++v12;
    switch(v8)
    {
      case 'A':
      case 'D':
      case 'E':
      case 'X':
      case 'Z':
      case 'a':
      case 'd':
      case 'e':
      case 't':
      case 'x':
        return v11;
      case 'B':
      case 'F':
      case 'b':
      case 'f':
        uint64_t v11 = (v11 + 1);
        int v10 = 1;
        goto LABEL_13;
      case 'C':
      case 'G':
      case 'H':
      case 'J':
      case 'K':
      case 'M':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'U':
      case 'V':
      case 'W':
      case 'Y':
      case '[':
      case '\\':
      case ']':
      case '^':
      case '_':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'm':
      case 'n':
      case 'p':
      case 'q':
      case 'r':
      case 'u':
      case 'v':
      case 'w':
        goto LABEL_17;
      case 'I':
      case 'L':
      case 'T':
      case 'l':
        uint64_t v11 = (v11 + 4);
        int v10 = 4;
        goto LABEL_13;
      case 'N':
        uint64_t v13 = strchr(v12, 46);
        uint64_t v21 = v13;
        if (!v13) {
          sub_100061FB4("Corrupt format: %s", v14, v15, v16, v17, v18, v19, v20, v9);
        }
        uint64_t v22 = sub_100046B74(v12, (int)v13 - (int)v12);
        if (v22)
        {
          int v10 = *(_DWORD *)(v22 + 16);
          uint64_t v11 = (v10 + v11);
          int v12 = v21 + 1;
LABEL_13:
          char v8 = *v12;
          if (!*v12) {
            return v11;
          }
          continue;
        }

        sub_10006221C("Unknown enumeration: %s", a2, a3, a4, a5, a6, a7, a8, v9);
        return 0x7FFFFFFFLL;
      case 'S':
      case 's':
        uint64_t v11 = (v11 + 2);
        int v10 = 2;
        goto LABEL_13;
      case 'c':
        sub_10006221C( "format_min_length(%s): 'c' atom is illegal except after 'D' atom.",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  v9);
        return 0x7FFFFFFFLL;
      case 'o':
        return (v11 - v10);
      default:
        if (v8 != 54)
        {
LABEL_17:
          sub_10006221C( "format_min_length(%s): No safe value for unknown format symbols.",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  v9);
          return 0x7FFFFFFFLL;
        }

        uint64_t v11 = (v11 + 16);
        int v10 = 16;
        goto LABEL_13;
    }
  }

const char *sub_100042FF0( void *a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v97 = a5;
  memset(v109, 0, 32);
  uint64_t v90 = &unk_1000BD3A0;
  uint64_t v99 = a2;
  __int128 __dst = (char *)&unk_1000BD3A0;
  if ((_DWORD)a4) {
    char v10 = 44;
  }
  else {
    char v10 = 32;
  }
  memset(v106, 0, sizeof(v106));
  unsigned int v92 = a3;
  if (*(_BYTE *)a1[1])
  {
    unint64_t v11 = 0LL;
    uint64_t v12 = 0LL;
    int v13 = 0;
    unsigned int v14 = 0;
    uint64_t v15 = 0LL;
    int v95 = 0;
    int v91 = 0;
    uint64_t v93 = a3;
    int v16 = -1;
    while (2)
    {
      if (v11 >= 0x1F) {
        sub_100061FB4( "Bounds failure on internal buffer at %s:%d",  (uint64_t)a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c");
      }
      uint64_t v17 = a1[1];
      uint64_t v18 = (char *)(v17 + v12);
      if (v16)
      {
        uint64_t v19 = (v15 + 1);
        int v20 = *v18;
        v109[v11] = *v18;
        switch(v20)
        {
          case 'A':
          case 'a':
            int v16 = 0;
            v109[v11] = 0;
            uint64_t v19 = v15;
            goto LABEL_49;
          case 'B':
          case 'F':
          case 'b':
          case 'f':
            ++v14;
            int v21 = 1;
            goto LABEL_16;
          case 'C':
          case 'G':
          case 'H':
          case 'J':
          case 'K':
          case 'M':
          case 'O':
          case 'P':
          case 'Q':
          case 'R':
          case 'U':
          case 'V':
          case 'W':
          case 'Y':
          case '[':
          case '\\':
          case ']':
          case '^':
          case '_':
          case 'g':
          case 'h':
          case 'i':
          case 'j':
          case 'k':
          case 'm':
          case 'n':
          case 'p':
          case 'q':
          case 'r':
            goto LABEL_17;
          case 'D':
            if (*(_BYTE *)(v17 + v13 + 1LL) == 99) {
              ++v13;
            }
            goto LABEL_37;
          case 'E':
            uint64_t v22 = (unsigned __int8 *)(v17 + v13);
            while (1)
            {
              int v24 = *v22++;
              int v23 = v24;
              if (!v24 || v23 == 46) {
                break;
              }
              ++v13;
            }

            goto LABEL_25;
          case 'I':
          case 'L':
          case 'T':
          case 'l':
            v14 += 4;
            int v21 = 4;
            goto LABEL_16;
          case 'N':
            int v26 = (unsigned __int8 *)(v17 + v13);
            for (unsigned int i = -1; ; ++i)
            {
              int v29 = *v26++;
              int v28 = v29;
              if (!v29 || v28 == 46) {
                break;
              }
            }

            v13 += i + 1;
            uint64_t v30 = sub_100046B74(v18 + 1, i);
            v106[v11] = v30;
            if (v30)
            {
              int v95 = *(_DWORD *)(v30 + 16);
              v14 += v95;
            }

            else
            {
              ++v14;
              int v95 = 1;
            }

            goto LABEL_49;
          case 'S':
          case 's':
            v14 += 2;
            int v21 = 2;
            goto LABEL_16;
          case 'X':
LABEL_25:
            if (v92)
            {
              uint64_t v25 = 0LL;
              while ((a2[v25] & 0x80000000) == 0
                   && (_DefaultRuneLocale.__runetype[a2[v25]] & 0x40000) != 0)
              {
                if (v93 == ++v25) {
                  goto LABEL_43;
                }
              }
            }

            else
            {
              LODWORD(v25) = 0;
            }

            if ((_DWORD)v25 == v92 || (_DWORD)v25 + 1 == v92 && !a2[v25])
            {
LABEL_43:
              v109[v11] = 116;
              int v16 = -2;
              goto LABEL_47;
            }

            int v16 = 0;
            v109[v11] = 120;
            ++v14;
            char v10 = 58;
LABEL_47:
            v109[v11 + 1] = 0;
LABEL_49:
            uint64_t v12 = v13 + 1LL;
            ++v11;
            ++v13;
            uint64_t v15 = v19;
            if (!*(_BYTE *)(a1[1] + v12)) {
              goto LABEL_53;
            }
            continue;
          case 'Z':
          case 'e':
            goto LABEL_49;
          case 'c':
            sub_10006221C( "'c' atom not following D atom in format string: %s",  (uint64_t)a2,  a3,  a4,  a5,  a6,  a7,  a8,  v17);
            goto LABEL_49;
          case 'd':
            v109[v11] = 116;
            goto LABEL_37;
          case 'o':
            v91 += v95;
            goto LABEL_49;
          case 't':
LABEL_37:
            v109[v11 + 1] = 0;
            int v16 = -2;
            goto LABEL_49;
          default:
            if (v20 == 54)
            {
              v14 += 16;
              int v21 = 16;
LABEL_16:
              int v95 = v21;
            }

            else
            {
LABEL_17:
              sub_10006221C("%s: garbage in format string: %s", (uint64_t)a2, a3, a4, a5, a6, a7, a8, *a1);
            }

            goto LABEL_49;
        }
      }

      break;
    }

    sub_10006221C("%s: Extra codes in format string: %s", (uint64_t)a2, a3, a4, a5, a6, a7, a8, *a1);
    LODWORD(v19) = v15;
  }

  else
  {
    int v91 = 0;
    LODWORD(v19) = 0;
    unsigned int v14 = 0;
    int v16 = -1;
  }

LABEL_53:
  int v94 = v19;
  unsigned int v31 = v92;
  if (v14 - v91 <= v92)
  {
    int v32 = v16;
    if (v16 == -1 && v92 > v14)
    {
      sub_10006221C("%s: %d extra bytes", (uint64_t)a2, a3, a4, a5, a6, a7, a8, *a1);
      unsigned int v31 = v92;
      int v33 = v94;
LABEL_58:
      int v32 = 1;
      goto LABEL_65;
    }

    int v33 = v94;
    if (!v32) {
      int v32 = v92 / v14;
    }
    if (v32 < 1)
    {
      if (v32) {
        goto LABEL_58;
      }
    }

    else if (v92 > v32 * v14)
    {
      sub_10006221C("%s: %d extra bytes at end of array\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, *a1);
      unsigned int v31 = v92;
    }

LABEL_65:
    int v96 = v32;
    int v34 = 0;
    uint64_t v35 = &a2[v31];
    uint64_t v89 = (char *)&unk_1000BD3A0 - (v97 != 0) + 0x7FFF;
    uint64_t v36 = v33;
    uint64_t v37 = v33;
    while (1)
    {
      if (v34 >= v96) {
        return (const char *)v90;
      }
      if (v33 >= 1) {
        break;
      }
LABEL_163:
      if (++v34 < v96)
      {
        int v86 = __dst++;
        *int v86 = v10;
      }

      int v33 = v94;
      if (v99 == v35) {
        return (const char *)v90;
      }
    }

    uint64_t v38 = 0LL;
    while (1)
    {
      int v39 = (char)v109[v38];
      if (v39 <= 97) {
        break;
      }
      if (v39 <= 107)
      {
        if (v39 == 98)
        {
          int v40 = __dst;
          ++v99;
LABEL_127:
          sprintf(v40, "%d");
          goto LABEL_158;
        }

        if (v39 == 101) {
          goto LABEL_155;
        }
        if (v39 != 102) {
          goto LABEL_89;
        }
        unsigned int v42 = v99++;
        if (*v42) {
          uint64_t v43 = "true";
        }
        else {
          uint64_t v43 = "false";
        }
        strcpy(__dst, v43);
      }

      else if (v39 > 115)
      {
        if (v39 != 116)
        {
          if (v39 == 120)
          {
LABEL_86:
            ++v99;
            sprintf(__dst, "%x");
            goto LABEL_158;
          }

LABEL_89:
          sub_10006221C("Unexpected format code %c", (uint64_t)a2, a3, a4, a5, a6, a7, a8, v109[v38]);
          goto LABEL_158;
        }

        if (a2 && __dst && v99 && &__dst[2 * (v97 != 0)] <= (char *)&unk_1000C539F && v99 <= v35)
        {
          if (v97)
          {
            *__dst++ = 34;
            int v78 = sub_1000463D0(&__dst, (unint64_t)v89, &v99, v35);
            if (v78 != -1)
            {
              uint64_t v79 = __dst;
              *__dst++ = 34;
              v78 += 2;
            }
          }

          else
          {
            int v78 = sub_1000463D0(&__dst, (unint64_t)v89, &v99, v35);
          }

          if (v78 != -1) {
            goto LABEL_155;
          }
        }

        sub_10006221C("Error printing text.", (uint64_t)a2, a3, a4, a5, a6, a7, a8, v88);
      }

      else
      {
        if (v39 == 108)
        {
          uint64_t v77 = __dst;
          sub_10005ACD0((unsigned int *)v99);
          sprintf(v77, "%ld");
LABEL_124:
          uint64_t v47 = v99 + 4;
        }

        else
        {
          if (v39 != 115) {
            goto LABEL_89;
          }
          int v41 = __dst;
          sub_10005ACC0((unsigned __int16 *)v99);
          sprintf(v41, "%d");
LABEL_121:
          uint64_t v47 = v99 + 2;
        }

LABEL_125:
        uint64_t v99 = v47;
      }

                    *((_WORD *)v26 + 4) = bswap32((_DWORD)v12 - ((_DWORD)v26 + 8) - 2) >> 16;
                    break;
                  case 0xB:
                    uint64_t v46 = v23;
                    if (!inet_aton(v104, &v98)) {
                      return 0xFFFFFFFFLL;
                    }
                    *(in_addr *)(v26 + 1__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = v98;
                    uint64_t v47 = sub_10006DF1C(v104);
                    if (v47 < 0) {
                      return 0xFFFFFFFFLL;
                    }
                    v26[14] = v47;
                    memset(__src, 0, sizeof(__src));
                    uint64_t v48 = 0;
                    do
                    {
                      uint64_t v49 = sub_10006DF54(v104);
                      if (v49 - 1 > 0x3FE) {
                        return 0xFFFFFFFFLL;
                      }
                      *((_BYTE *)__src + ((unint64_t)v49 >> 3)) |= 0x80u >> (v49 & 7);
                      if (v49 > v48) {
                        uint64_t v48 = v49;
                      }
                    }

                    while (sub_10006DC34((uint64_t)v104, (unint64_t *)&v99, v28));
LABEL_87:
                    uint64_t v7 = v46 - 11 + ~(v48 >> 3);
                    memcpy(v26 + 15, __src, (v48 >> 3) + 1);
                    uint64_t v12 = &v26[(v48 >> 3) + 16];
                    goto LABEL_125;
                  case 0xD:
                    uint64_t v50 = 1;
                    while (1)
                    {
                      int v51 = v50;
                      uint64_t v52 = sub_10006DF8C((uint64_t)v104, &v99, v28);
                      if (v52 > 0xFF) {
                        return 0xFFFFFFFFLL;
                      }
                      uint64_t v53 = v52;
                      v7 += ~v52;
                      *uint64_t v12 = v52;
                      uint64_t v54 = v12 + 1;
                      memcpy(v54, v104, v52);
                      uint64_t v50 = 0;
                      uint64_t v12 = &v54[v53];
                      if ((v51 & 1) == 0) {
                        goto LABEL_125;
                      }
                    }

                  case 0xF:
                  case 0x12:
                  case 0x15:
                    uint64_t v43 = v23;
                    uint64_t v44 = sub_10006DDDC(&v99, (unint64_t)(v27 - 1));
                    if ((v44 & 0x80000000) != 0) {
                      return 0xFFFFFFFFLL;
                    }
                    *((_WORD *)v26 + 5) = bswap32(v44) >> 16;
                    uint64_t v7 = v43 - 8;
                    uint64_t v12 = v26 + 12;
                    goto LABEL_123;
                  case 0x10:
                    uint64_t v55 = sub_10006DF8C((uint64_t)v104, &v99, (unint64_t)(v27 - 1));
                    if ((v55 & 0x80000000) != 0) {
                      return 0xFFFFFFFFLL;
                    }
                    uint64_t v56 = v55;
                    uint64_t v57 = 10LL;
                    do
                    {
                      if (v56 > 0xFF) {
                        return 0xFFFFFFFFLL;
                      }
                      v7 += ~v56;
                      uint64_t v58 = v57 + 1;
                      *uint64_t v12 = v56;
                      memcpy(&v26[v58], v104, v56);
                      uint64_t v57 = v58 + v56;
                      uint64_t v12 = &v26[v57];
                      uint64_t v56 = sub_10006DF8C((uint64_t)v104, &v99, v28);
                    }

                    while ((v56 & 0x80000000) == 0);
                    if (v57 == 10) {
                      return 0xFFFFFFFFLL;
                    }
                    goto LABEL_125;
                  case 0x13:
                    int v59 = sub_10006DF8C((uint64_t)v104, &v99, (unint64_t)(v27 - 1));
                    if (v59 > 0xFF) {
                      return 0xFFFFFFFFLL;
                    }
                    int v60 = v59;
                    v7 += ~v59;
                    uint64_t v61 = v26 + 11;
                    v26[10] = v59;
                    uint64_t v62 = v59;
                    uint64_t v63 = v104;
                    goto LABEL_108;
                  case 0x14:
                    int v64 = sub_10006DF8C((uint64_t)v104, &v99, (unint64_t)(v27 - 1));
                    if (v64 - 256 < 0xFFFFFF01) {
                      return 0xFFFFFFFFLL;
                    }
                    char v65 = v64;
                    v26[10] = v64;
                    int v66 = v64;
                    memcpy(v26 + 11, v104, v64);
                    unint64_t v67 = sub_10006DF8C((uint64_t)v104, &v99, v28);
                    uint64_t v68 = v67 & ~(v67 >> 31);
                    uint64_t v69 = &v26[v66 + 11];
                    v7 += ~v65 + ~(_DWORD)v68;
                    *v69++ = v67 & ~(v67 >> 31);
                    memcpy(v69, v104, v68);
                    uint64_t v12 = &v69[v68];
                    goto LABEL_125;
                  case 0x19:
                    int v70 = v23;
                    int v71 = sub_10006E188((const char **)&v99, (unint64_t)(v27 - 1));
                    if ((v71 & 0x80000000) != 0) {
                      return 0xFFFFFFFFLL;
                    }
                    *((_WORD *)v26 + 5) = bswap32(v71) >> 16;
                    uint64_t v72 = sub_10006DDDC(&v99, v28);
                    if (v72 < 0) {
                      return 0xFFFFFFFFLL;
                    }
                    v26[12] = v72;
                    uint64_t v73 = sub_10006DDDC(&v99, v28);
                    if (v73 < 0) {
                      return 0xFFFFFFFFLL;
                    }
                    v26[13] = v73;
                    sub_10006DC34((uint64_t)v104, (unint64_t *)&v99, v28);
                    int v74 = sub_1000595D4(v104, (uint64_t)v103, 0x401uLL);
                    if ((v74 & 0x80000000) != 0) {
                      return 0xFFFFFFFFLL;
                    }
                    int v60 = v74;
                    uint64_t v61 = v26 + 14;
                    uint64_t v7 = v70 - v74 - 10;
                    uint64_t v62 = v74;
                    uint64_t v63 = v103;
LABEL_108:
                    memcpy(v61, v63, v62);
                    uint64_t v12 = &v61[v60];
                    goto LABEL_125;
                  case 0x1A:
                    int v75 = v23;
                    uint64_t v76 = sub_10006DDDC(&v99, (unint64_t)(v27 - 1));
                    if ((v76 & 0x80000000) != 0) {
                      return 0xFFFFFFFFLL;
                    }
                    *((_WORD *)v26 + 5) = bswap32(v76) >> 16;
                    uint64_t v7 = v75 - 8;
                    uint64_t v12 = v26 + 12;
                    uint64_t v77 = 1;
                    while (1)
                    {
                      int v78 = v77;
                      uint64_t v79 = sub_10006B974(v104, v12, v7, v101, (uint64_t)&v102);
                      if ((v79 & 0x80000000) != 0) {
                        return 0xFFFFFFFFLL;
                      }
                      uint64_t v77 = 0;
                      v7 -= v79;
                      v12 += v79;
                      if ((v78 & 1) == 0) {
                        goto LABEL_125;
                      }
                    }

                  case 0x1C:
                    uint64_t v80 = v23;
                    if (!sub_10006DC34((uint64_t)v104, (unint64_t *)&v99, (unint64_t)(v27 - 1))
                      || inet_pton(30, v104, &v97) < 1)
                    {
                      return 0xFFFFFFFFLL;
                    }

                    *(_OWORD *)uint64_t v12 = v97;
                    uint64_t v12 = v26 + 26;
                    uint64_t v7 = v80 - 22;
                    goto LABEL_125;
                  case 0x21:
                    uint64_t v81 = v23;
                    uint64_t v82 = sub_10006DDDC(&v99, (unint64_t)(v27 - 1));
                    if ((v82 & 0x80000000) != 0) {
                      return 0xFFFFFFFFLL;
                    }
                    *((_WORD *)v26 + 5) = bswap32(v82) >> 16;
                    int v83 = sub_10006DDDC(&v99, v28);
                    if ((v83 & 0x80000000) != 0) {
                      return 0xFFFFFFFFLL;
                    }
                    *((_WORD *)v26 + 6) = bswap32(v83) >> 16;
                    uint64_t v84 = sub_10006DDDC(&v99, v28);
                    if ((v84 & 0x80000000) != 0) {
                      return 0xFFFFFFFFLL;
                    }
                    *((_WORD *)v26 + 7) = bswap32(v84) >> 16;
                    uint64_t v7 = v81 - 12;
                    uint64_t v12 = v26 + 16;
LABEL_123:
                    uint64_t v85 = sub_10006B974(v104, v12, v7, v101, (uint64_t)&v102);
                    if ((v85 & 0x80000000) != 0) {
                      return 0xFFFFFFFFLL;
                    }
                    v12 += v85;
                    v7 -= v85;
                    goto LABEL_125;
                  case 0x25:
                    int v86 = v23;
                    uint64_t v87 = sub_10006DDDC(&v99, (unint64_t)(v27 - 1));
                    if ((v87 & 0x80000000) != 0) {
                      return 0xFFFFFFFFLL;
                    }
                    *((_WORD *)v26 + 5) = bswap32(v87) >> 16;
                    char v88 = sub_10006DDDC(&v99, v28);
                    if ((v88 & 0x80000000) != 0) {
                      return 0xFFFFFFFFLL;
                    }
                    *((_WORD *)v26 + 6) = bswap32(v88) >> 16;
                    uint64_t v89 = sub_10006DDDC(&v99, v28);
                    if (v89 < 0) {
                      return 0xFFFFFFFFLL;
                    }
                    v26[14] = v89;
                    sub_10006DC34((uint64_t)v104, (unint64_t *)&v99, v28);
                    uint64_t v90 = sub_1000595D4(v104, (uint64_t)v103, 0x401uLL);
                    uint64_t v7 = v86 - v90 - 11;
                    memcpy(v26 + 15, v103, v90);
                    uint64_t v12 = &v26[v90 + 15];
                    goto LABEL_125;
                  default:
                    fprintf(__stderrp, "NSupdate of RR type: %d not implemented\n", *(_DWORD *)(v9 + 52));
                    return 0xFFFFFFFFLL;
                }
              }

              else
              {
                *((_WORD *)v24 + 4) = 0;
              }

              int v13 = v95;
            }

            else
            {
              unint64_t v11 = v96;
              int v13 = v95;
              if (v15 || *(_DWORD *)(v9 + 52) != 6) {
                return 4294967293LL;
              }
              v12 += v22 + 4;
              uint64_t v7 = v7 - v22 - 4;
            }

            char v9 = *(void *)(v9 + 24);
            if (!v9)
            {
              uint64_t result = 0LL;
              int v91 = vmovl_u16((uint16x4_t)vrev16_s8((int8x8_t)vmovn_s32(v102)));
              unsigned int v92 = ((unint64_t)v91.u32[1] << 48) | ((unint64_t)v91.u32[0] << 32) | *a3;
              a3[2] = v91.i32[2] | (v91.i32[3] << 16);
              *(void *)a3 = v92;
              *a4 = (_DWORD)v12 - (_DWORD)a3;
              return result;
            }
          }
        }
      }

      else
      {
        return 4294967291LL;
      }
    }
  }

  return result;
}

LABEL_158:
      uint64_t v85 = &__dst[strlen(__dst)];
      __int128 __dst = v85;
      if (v99 != v35)
      {
        if (++v38 < v36 && v10 != 58)
        {
          __int128 __dst = v85 + 1;
          char *v85 = 32;
        }

        if (v38 != v37) {
          continue;
        }
      }

      goto LABEL_163;
    }

    switch(v109[v38])
    {
      case 'B':
        int v40 = __dst;
        ++v99;
        goto LABEL_127;
      case 'C':
      case 'E':
      case 'G':
      case 'H':
      case 'J':
      case 'K':
      case 'M':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'U':
      case 'V':
      case 'W':
      case 'Y':
        goto LABEL_89;
      case 'D':
        uint64_t v48 = v99;
LABEL_91:
        if (v48 >= v35) {
          break;
        }
        uint64_t v49 = a2;
        if (v48 == a2) {
          goto LABEL_97;
        }
        uint64_t v50 = __dst;
        if (v97)
        {
          ++__dst;
          *uint64_t v50 = 44;
          uint64_t v50 = __dst;
        }

        __int128 __dst = v50 + 1;
        *uint64_t v50 = 32;
        uint64_t v49 = v99;
LABEL_97:
        int v51 = sub_10006A214((unint64_t)a2, (unint64_t)v35, v49, (char *)&v101, 255LL);
        if (v51 == -1)
        {
          uint64_t v84 = "Invalid domain list.";
        }

        else
        {
          int v59 = v51;
          if (v97)
          {
            unsigned int v98 = (char *)&v101;
            int v60 = __dst;
            if (__dst && __dst + 2 <= (char *)&unk_1000C539F)
            {
              for (char j = 34; ; char j = 46)
              {
                *int v60 = j;
                uint64_t v62 = ++__dst;
                uint64_t v63 = v98;
                if (v98 >= &v105) {
                  break;
                }
                int v64 = *v98++;
                if (!v64) {
                  break;
                }
                char v65 = &v63[v64 + 1];
                if (v65 > &v105) {
                  goto LABEL_111;
                }
                int v60 = __dst;
              }

              *uint64_t v62 = 34;
              ++__dst;
            }

LABEL_111:
            uint64_t v48 = &v99[v59];
            uint64_t v99 = v48;
            goto LABEL_91;
          }

          int v66 = sub_100069DB8(&v101, __dst, (uint64_t)&unk_1000BD3A0 + ~(unint64_t)__dst + 0x8000);
          if (v66 >= 1)
          {
            unint64_t v67 = &__dst[v66 - 1];
            __int128 __dst = v67 + 1;
            *unint64_t v67 = 46;
            goto LABEL_111;
          }

          uint64_t v84 = "Invalid domain name.";
        }

        sub_10006221C(v84, v52, v53, v54, v55, v56, v57, v58, v88);
        break;
      case 'F':
        uint64_t v68 = __dst;
        __dst[4] = 0;
        *(_DWORD *)uint64_t v68 = 1702195828;
        goto LABEL_158;
      case 'I':
        uint64_t v69 = __dst;
        int v70 = *(_DWORD *)v99;
        int v101 = 4;
        int v102 = v70;
        uint64_t v103 = v107;
        int v104 = v108;
        int v71 = sub_100040144(&v101, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
        strcpy(v69, v71);
        goto LABEL_124;
      case 'L':
        uint64_t v72 = __dst;
        sub_100060B50((unsigned int *)v99);
        sprintf(v72, "%lu");
        goto LABEL_124;
      case 'N':
        uint64_t v73 = v106[v38];
        if (v73)
        {
          int v74 = *(_DWORD *)(v73 + 16);
          switch(v74)
          {
            case 4:
              int v75 = sub_100060B50((unsigned int *)v99);
              break;
            case 2:
              int v75 = sub_100060B5C((unsigned __int16 *)v99);
              break;
            case 1:
              int v75 = sub_100060BA0((unsigned __int8 *)v99);
              break;
            default:
              sub_100061FB4( "Impossible case at %s:%d.",  (uint64_t)a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c");
          }

          uint64_t v80 = *(void *)(v73 + 24);
          uint64_t v81 = *(const char **)v80;
          if (*(void *)v80)
          {
            if (v75 == *(unsigned __int8 *)(v80 + 8))
            {
              int v34 = 0;
LABEL_147:
              strcpy(__dst, v81);
              uint64_t v47 = &v99[*(unsigned int *)(v73 + 16)];
              goto LABEL_125;
            }

            int v34 = 0;
            uint64_t v82 = (unsigned __int8 *)(v80 + 24);
            while (1)
            {
              uint64_t v81 = (const char *)*((void *)v82 - 1);
              if (!v81) {
                break;
              }
              int v83 = *v82;
              v82 += 16;
              ++v34;
              if (v75 == v83) {
                goto LABEL_147;
              }
            }

            ++v34;
          }

          else
          {
            int v34 = 0;
          }
        }

        else
        {
          ++v99;
        }

LABEL_150:
        sprintf(__dst, "%lu");
        goto LABEL_158;
      case 'S':
        uint64_t v76 = __dst;
        sub_100060B5C((unsigned __int16 *)v99);
        sprintf(v76, "%u");
        goto LABEL_121;
      case 'T':
        sub_100060B50((unsigned int *)v99);
        goto LABEL_150;
      case 'X':
        goto LABEL_86;
      case 'Z':
        break;
      default:
        if (v39 != 54) {
          goto LABEL_89;
        }
        uint64_t v44 = __dst;
        int v45 = *(_DWORD *)v99;
        uint64_t v107 = *(void *)(v99 + 4);
        int v108 = *((_DWORD *)v99 + 3);
        int v101 = 16;
        int v102 = v45;
        uint64_t v103 = v107;
        int v104 = v108;
        uint64_t v46 = sub_100040144(&v101, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
        strcpy(v44, v46);
        uint64_t v47 = v99 + 16;
        goto LABEL_125;
    }

LABEL_155:
    uint64_t v79 = __dst;
LABEL_156:
    *uint64_t v79 = 0;
    goto LABEL_158;
  }

  sub_10006221C("%s: expecting at least %d bytes; got %d", (uint64_t)a2, a3, a4, a5, a6, a7, a8, *a1);
  return "<error>";
}

uint64_t sub_100043AE8( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unsigned int a10, uint64_t a11, int a12)
{
  uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t, void))(a2 + 8);
  if (!v12) {
    return 0LL;
  }
  uint64_t result = v12(a2, a8, a10);
  if (result) {
    return sub_100057AA4(a1, a3, a4, a5, a6, a7, a9, result, a11, a12) != 0;
  }
  return result;
}

void *sub_100043B90( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  switch((int)a4)
  {
    case 5:
      if (!a2) {
        goto LABEL_17;
      }
      int v32 = (uint64_t (*)(void *, uint64_t, void))a1[1];
      if (!v32) {
        goto LABEL_16;
      }
      uint64_t result = (void *)v32(a1, a2, *(unsigned int *)(*(void *)(a3 + 24) + 24LL));
      if (!result) {
        goto LABEL_17;
      }
      return result;
    case 6:
    case 9:
      goto LABEL_17;
    case 7:
    case 8:
      if (!a2) {
        goto LABEL_17;
      }
      uint64_t v12 = (uint64_t (*)(void *, uint64_t, void))a1[1];
      if (!v12)
      {
LABEL_16:
        sub_10006221C("can't look up options in %s space.", a2, a3, a4, a5, a6, a7, a8, *a1);
LABEL_17:
        int v33 = (uint64_t (*)(void *, uint64_t, uint64_t, void))a1[2];
        if (v33) {
          return (void *)v33(a1, a2, a3, 0LL);
        }
        else {
          return (void *)sub_10006221C("can't store options in %s space.", a2, a3, a4, 0LL, a6, a7, a8, *a1);
        }
      }

      int v13 = a4;
      uint64_t v14 = v12(a1, a2, *(unsigned int *)(*(void *)(a3 + 24) + 24LL));
      if (!v14) {
        goto LABEL_17;
      }
      uint64_t v16 = v14;
      uint64_t v17 = (_DWORD **)(v14 + 16);
      if (*(void *)(v14 + 16) || !*(_DWORD *)(v14 + 48))
      {
LABEL_6:
        uint64_t v48 = 0LL;
        uint64_t result = sub_100034540( &v48,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  2127LL,  a4,  v15,  a6,  a7,  a8);
        if (!(_DWORD)result) {
          return result;
        }
        int v24 = v48 + 4;
        if (v13 == 7)
        {
          if (!sub_10005470C(v24, *v17, *(_DWORD **)(a3 + 16), v19, v20, v21, v22, v23))
          {
            uint64_t v30 = 2133LL;
            return (void *)sub_100040E08( &v48,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  v30,  v25,  v26,  v27,  v28,  v29);
          }
        }

        else if (!sub_10005470C(v24, *(_DWORD **)(a3 + 16), *v17, v19, v20, v21, v22, v23))
        {
          uint64_t v30 = 2140LL;
          return (void *)sub_100040E08( &v48,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  v30,  v25,  v26,  v27,  v28,  v29);
        }

        sub_100052CB0((void *)v48 + 3, *(void *)(v16 + 24));
        uint64_t v47 = (void (*)(void *, uint64_t, int *, void))a1[2];
        if (v47) {
          v47(a1, a2, v48, 0LL);
        }
        else {
          sub_10006221C("can't store options in %s space.", v40, v41, v42, v43, v44, v45, v46, *a1);
        }
        uint64_t v30 = 2146LL;
        return (void *)sub_100040E08( &v48,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  v30,  v25,  v26,  v27,  v28,  v29);
      }

      if (sub_1000343B4( (void *)(v14 + 16),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  2116LL,  a4,  v15,  a6,  a7,  a8))
      {
        uint64_t v34 = (uint64_t)*v17;
        *(_DWORD *)(v34 + 4) = 14;
        sub_100034E60( v34 + 8,  v16 + 32,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  2123LL,  a5,  a6,  a7,  a8);
        sub_100034EA8( (_DWORD **)(v16 + 32),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  2124LL,  v35,  v36,  v37,  v38,  v39);
        goto LABEL_6;
      }

      unsigned int v31 = "Can't allocate const expression.";
      return (void *)sub_10006221C(v31, a2, a3, a4, a5, a6, a7, a8, a9);
    default:
      unsigned int v31 = "bogus statement type in set_option.";
      return (void *)sub_10006221C(v31, a2, a3, a4, a5, a6, a7, a8, a9);
  }

uint64_t sub_100043E20( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = (uint64_t (*)(void))a1[2];
  if (v8) {
    return v8();
  }
  else {
    return sub_10006221C("can't store options in %s space.", a2, a3, a4, 0LL, a6, a7, a8, *a1);
  }
}

uint64_t sub_100043E64(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = *(int *)(a1 + 136);
  uint64_t v4 = *(void *)(a2 + 8 * v3 + 16);
  if (!v4) {
    return 0LL;
  }
  uint64_t v5 = *(void **)(v4
                  + 8LL
                  * (((a3 >> 5) & 0x1F)
                                    + (a3 & 0x1F)
                                    - (((61 * (((a3 >> 5) & 0x1F) + (a3 & 0x1F))) >> 10) | (16
                                                                                          * ((61
                                                                                            * (((a3 >> 5) & 0x1F)
                                                                                             + (a3 & 0x1F))) >> 10)))));
  if (!v5) {
    return 0LL;
  }
  while (1)
  {
    uint64_t result = *v5;
    if (*(_DWORD *)(*(void *)(*v5 + 24LL) + 24LL) == a3) {
      break;
    }
    uint64_t v5 = (void *)v5[1];
    if (!v5) {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_100043ED0( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8)
{
  int v9 = a6;
  unsigned int v10 = a4;
  unint64_t v11 = (const void *)a3;
  uint64_t v12 = (_DWORD *)a2;
  int v55 = a5;
  uint64_t v53 = 0LL;
  uint64_t v54 = 0LL;
  int v14 = *((_DWORD *)a1 + 24);
  if (v14 == 4) {
    goto LABEL_9;
  }
  if (v14 == 2)
  {
    if (!WORD1(a5)) {
      goto LABEL_9;
    }
    return 0LL;
  }

  if (v14 != 1) {
    sub_100061FB4( "Inconsistent universe tag size at %s:%d.",  a2,  a3,  a4,  a5,  a6,  (uint64_t)a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c");
  }
LABEL_9:
  sub_100029804(&v53, a1[15], &v55, 0LL, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c", 2269LL);
  if (!v53)
  {
    __sprintf_chk(v56, 0, 0x13uLL, "unknown-%u", v55);
    uint64_t result = (uint64_t)sub_1000342D8(v56);
    uint64_t v53 = result;
    if (!result) {
      return result;
    }
    *(char **)(result + 8) = off_10008A658[0];
    *(void *)(result + 16) = a1;
    *(_DWORD *)(result + 24) = v55;
    *(_DWORD *)(result + 28) = 1;
  }

  if (sub_100034540( a7,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  2296LL,  v16,  v17,  v18,  v19,  v20))
  {
    uint64_t v28 = *a7;
    sub_100052CB0((void *)(*a7 + 24LL), v53);
    if (v12) {
      goto LABEL_16;
    }
    if (sub_1000345C4( &v54,  v9 + v10,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  2311LL))
    {
      memcpy(v54 + 1, v11, v9 + v10);
      uint64_t v12 = v54;
      unint64_t v11 = v54 + 1;
LABEL_16:
      *(void *)(v28 + 32) = 0LL;
      sub_100033F18( (void *)(v28 + 32),  v12,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  2324LL,  v29,  v30,  v31,  v32);
      *(void *)(v28 + 4__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = v11;
      *(_DWORD *)(v28 + 48) = v10;
      if (v9)
      {
        *((_BYTE *)v11 + v1__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = 0;
        int v40 = 1;
      }

      else
      {
        int v40 = 0;
      }

      *(_DWORD *)(v28 + 52) = v40;
      if (sub_100042DBC(*(char **)(v53 + 8), v33, v34, v35, v36, v37, v38, v39))
      {
        unsigned int v49 = sub_100042EAC(*(char **)(v53 + 8), v47, v48, v42, v43, v44, v45, v46);
        unsigned int v50 = *(_DWORD *)(v28 + 48);
        if (v50 > v49)
        {
          uint64_t v51 = *(void *)(v28 + 40);
          do
          {
            if (*(_BYTE *)(v51 + v50 - 1)) {
              break;
            }
            *(_DWORD *)(v28 + 48) = --v50;
            *(_DWORD *)(v28 + 56) |= 1u;
          }

          while (v49 < v50);
        }
      }

      goto LABEL_26;
    }

    uint64_t v41 = "no memory for option buffer.";
  }

  else
  {
    uint64_t v52 = *a1;
    uint64_t v41 = "No memory for option code %s.%s.";
  }

  sub_10006221C(v41, v21, v22, v23, v24, v25, v26, v27, v52);
LABEL_26:
  sub_100052CE4( &v53,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  2358LL,  v42,  v43,  v44,  v45,  v46);
  return 1LL;
}

uint64_t sub_10004416C( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v20 = 0LL;
  uint64_t v17 = sub_100043ED0(a1, a3, a4, a5, a6, a7, &v20, a8);
  if ((_DWORD)v17)
  {
    uint64_t v18 = (void (*)(uint64_t *, uint64_t, int *, uint64_t))a1[2];
    if (v18) {
      v18(a1, a2, v20, 1LL);
    }
    else {
      sub_10006221C("can't store options in %s space.", v10, v11, v12, v13, v14, v15, v16, *a1);
    }
  }

  if (v20) {
    sub_100040E08( &v20,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  2234LL,  v12,  v13,  v14,  v15,  v16);
  }
  return v17;
}

uint64_t sub_10004421C( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = (uint64_t (*)(void))a1[2];
  if (v8) {
    return v8();
  }
  else {
    return sub_10006221C("can't store options in %s space.", a2, a3, a4, 0LL, a6, a7, a8, *a1);
  }
}

void *sub_100044260(void *a1, uint64_t a2)
{
  int v22 = 0;
  int v4 = (int)off_10008C210;
  if (off_10008C210)
  {
    uint64_t v21 = sub_100044420;
    off_10008C210(0LL, 0LL, 0LL, 0LL, a2, 0LL, &qword_10008C1F8, &v22);
    int v4 = v22;
  }

  uint64_t v5 = *(unsigned int *)(a2 + 4);
  if ((int)v5 >= 1)
  {
    for (uint64_t i = 0LL; i != v5; ++i)
    {
      if (*(void *)(a2 + 8 * i + 16))
      {
        uint64_t v7 = *(uint64_t **)(qword_10008C570 + 8 * i);
        while (1)
        {
          uint64_t v8 = v7[16];
          if (!v8) {
            break;
          }
          uint64_t v7 = *(uint64_t **)(v8 + 16);
          if (v7 == &qword_10008C1F8)
          {
            int v22 = ++v4;
            break;
          }
        }
      }
    }
  }

  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  uint64_t result = sub_1000345C4(a1, 2 * v4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c", 2431LL);
  if (!(_DWORD)result) {
    sub_100061FB4("no memory to build server ORO", v10, v11, v12, v13, v14, v15, v16, (char)v21);
  }
  a1[1] = *a1 + 4LL;
  *((_DWORD *)a1 + 4) = 0;
  if (off_10008C210) {
    uint64_t result = (void *)((uint64_t (*)(void, void, void, void, uint64_t, void, uint64_t *, void *, void))off_10008C210)( 0LL,  0LL,  0LL,  0LL,  a2,  0LL,  &qword_10008C1F8,  a1,  sub_100044434);
  }
  int v17 = *(_DWORD *)(a2 + 4);
  if (v17 >= 1)
  {
    for (uint64_t j = 0LL; j < v17; ++j)
    {
      if (*(void *)(a2 + 8 * j + 16))
      {
        uint64_t v19 = *(uint64_t **)(qword_10008C570 + 8 * j);
        while (1)
        {
          uint64_t v20 = v19[16];
          if (!v20) {
            break;
          }
          uint64_t v19 = *(uint64_t **)(v20 + 16);
          if (v19 == &qword_10008C1F8)
          {
            uint64_t result = sub_100060B78((_WORD *)(*a1 + *((unsigned int *)a1 + 4) + 4LL), *(_DWORD *)(v20 + 24));
            *((_DWORD *)a1 + 4) += 2;
            int v17 = *(_DWORD *)(a2 + 4);
            break;
          }
        }
      }
    }
  }

  return result;
}

void sub_100044420( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, _DWORD *a9)
{
}

_WORD *sub_100044434( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t result = sub_100060B78( (_WORD *)(*(void *)a9 + *(unsigned int *)(a9 + 16) + 4LL),  *(_DWORD *)(*(void *)(a1 + 24) + 24LL));
  *(_DWORD *)(a9 + 16) += 2;
  return result;
}

uint64_t sub_10004447C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (!*(_DWORD *)a3) {
    abort();
  }
  uint64_t v12 = *(void **)(a2 + 8LL * *(int *)(a1 + 136) + 16);
  unsigned int v13 = *(_DWORD *)(*(void *)(a3 + 24) + 24LL);
  unsigned int v14 = ((v13 >> 5) & 0x1F)
      + (v13 & 0x1F)
      - (((61 * (((v13 >> 5) & 0x1F) + (v13 & 0x1F))) >> 10) | (16 * ((61 * (((v13 >> 5) & 0x1F) + (v13 & 0x1F))) >> 10)));
  if (!v12)
  {
    int v17 = sub_10005CDE4(0x88uLL);
    if (!v17) {
      return sub_10006221C("no memory to store %s.%s", v18, v19, v20, v21, v22, v23, v24, *(void *)a1);
    }
    uint64_t v12 = v17;
    v17[16] = 0LL;
    *((_OWORD *)v17 + 6) = 0u;
    *((_OWORD *)v17 + 7) = 0u;
    *((_OWORD *)v17 + 4) = 0u;
    *((_OWORD *)v17 + 5) = 0u;
    *((_OWORD *)v17 + 2) = 0u;
    *((_OWORD *)v17 + 3) = 0u;
    *(_OWORD *)int v17 = 0u;
    *((_OWORD *)v17 + 1) = 0u;
    *(void *)(a2 + 8LL * *(int *)(a1 + 136) + 16) = v17;
    goto LABEL_9;
  }

  uint64_t v15 = (int **)v12[(((v13 >> 5) & 0x1F)
                                    + (v13 & 0x1F)
                                    - (((61 * (((v13 >> 5) & 0x1F) + (v13 & 0x1F))) >> 10) | (16
                                                                                            * ((61
                                                                                              * (((v13 >> 5) & 0x1F)
                                                                                               + (v13 & 0x1F))) >> 10))))];
  if (!v15)
  {
LABEL_9:
    uint64_t v25 = sub_100034360();
    if (!v25) {
      return sub_10006221C("No memory for option_cache reference.", v26, v27, v28, v29, v30, v31, v32, a9);
    }
    uint64_t v33 = v25;
    uint64_t v34 = v12[v14];
    *uint64_t v25 = 0LL;
    v25[1] = v34;
    uint64_t result = sub_100033F18( v25,  (_DWORD *)a3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  2548LL,  v29,  v30,  v31,  v32);
    v12[v14] = v33;
    return result;
  }

  while (1)
  {
    uint64_t v16 = *v15;
    if (*(_DWORD *)(*((void *)*v15 + 3) + 24LL) == v13) {
      break;
    }
    uint64_t v15 = (int **)v15[1];
    if (!v15) {
      goto LABEL_9;
    }
  }

  if ((_DWORD)a4)
  {
    do
    {
      uint64_t v36 = v16;
      uint64_t v16 = (int *)*((void *)v16 + 1);
    }

    while (v16);
    uint64_t v15 = (int **)(v36 + 2);
  }

  else
  {
    sub_100040E08( v15,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  2532LL,  a4,  a5,  a6,  a7,  a8);
  }

  return sub_100033F18( v15,  (_DWORD *)a3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  2535LL,  a5,  a6,  a7,  a8);
}

uint64_t sub_10004463C( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = (uint64_t (*)(void))a1[4];
  if (v8) {
    return v8();
  }
  else {
    return sub_10006221C("can't delete options from %s space.", a2, a3, 0LL, a5, a6, a7, a8, *a1);
  }
}

uint64_t sub_10004467C( uint64_t result, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a2 + 8LL * *(int *)(result + 136) + 16);
  if (v8)
  {
    int v9 = (uint64_t *)(v8
                   + 8LL
                   * (((a3 >> 5) & 0x1F)
                                     + (a3 & 0x1F)
                                     - (((61 * (((a3 >> 5) & 0x1F) + (a3 & 0x1F))) >> 10) | (16
                                                                                           * ((61
                                                                                             * (((a3 >> 5) & 0x1F)
                                                                                              + (a3 & 0x1F))) >> 10)))));
    uint64_t v10 = *v9;
    if (*v9)
    {
      if (*(_DWORD *)(*(void *)(*(void *)v10 + 24LL) + 24LL) == a3)
      {
        uint64_t v11 = 0LL;
LABEL_7:
        if (v11) {
          int v9 = (uint64_t *)(v11 + 8);
        }
        *int v9 = *(void *)(v10 + 8);
        sub_100040E08( (int **)v10,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  2592LL,  a4,  a5,  a6,  a7,  a8);
        return sub_1000343A0(v10);
      }

      else
      {
        while (1)
        {
          uint64_t v11 = v10;
          uint64_t v10 = *(void *)(v10 + 8);
          if (!v10) {
            break;
          }
          if (*(_DWORD *)(*(void *)(*(void *)v10 + 24LL) + 24LL) == a3) {
            goto LABEL_7;
          }
        }
      }
    }
  }

  return result;
}

uint64_t sub_100044750( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void **)(a2 + 8LL * *(int *)(a1 + 136) + 16);
  if (!v8) {
    return 0LL;
  }
  for (uint64_t i = 0LL; i != 17; ++i)
  {
    uint64_t v14 = v8[i];
    if (v14)
    {
      do
      {
        uint64_t v15 = *(void *)(v14 + 8);
        sub_100040E08((int **)v14, a3, a4, a4, a5, a6, a7, a8);
        sub_1000343A0(v14);
        uint64_t v14 = v15;
      }

      while (v15);
    }
  }

  sub_10005CE20(v8, a3, a4, a4, a5, a6, a7, a8);
  *(void *)(a2 + 8LL * *(int *)(a1 + 136) + 16) = 0LL;
  return 1LL;
}

uint64_t sub_10004480C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v8 = *(_DWORD *)(a4 + 16);
  if (!v8 && **(_BYTE **)(a3 + 8) != 90) {
    return 0LL;
  }
  uint64_t v32 = 0LL;
  uint64_t v33 = 0LL;
  uint64_t v34 = 0LL;
  if (!sub_1000345C4( &v32,  *(_DWORD *)(a1 + 16) + v8 + *(_DWORD *)(a2 + 100) + *(_DWORD *)(a2 + 96),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  2702LL))
  {
    sub_100034EA8( (_DWORD **)a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  2709LL,  v9,  v10,  v11,  v12,  v13);
    return 0LL;
  }

  uint64_t v14 = v32;
  uint64_t v33 = v32 + 1;
  size_t v15 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v15)
  {
    memcpy(v32 + 1, *(const void **)(a1 + 8), v15);
    unsigned int v16 = *(_DWORD *)(a1 + 16);
    uint64_t v14 = v32;
  }

  else
  {
    unsigned int v16 = 0;
  }

  LODWORD(v34) = v16;
  (*(void (**)(uint64_t, void))(a2 + 72))((uint64_t)v14 + v16 + 4, *(unsigned int *)(a3 + 24));
  LODWORD(v34) = v34 + *(_DWORD *)(a2 + 96);
  (*(void (**)(char *, void))(a2 + 88))((char *)v32 + v34 + 4, *(unsigned int *)(a4 + 16));
  LODWORD(v34) = v34 + *(_DWORD *)(a2 + 100);
  memcpy((char *)v32 + v34 + 4, *(const void **)(a4 + 8), *(unsigned int *)(a4 + 16));
  LODWORD(v34) = v34 + *(_DWORD *)(a4 + 16);
  sub_100034EA8( (_DWORD **)a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  2730LL,  v18,  v19,  v20,  v21,  v22);
  sub_100034E60( a1,  (uint64_t)&v32,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  2731LL,  v23,  v24,  v25,  v26);
  sub_100034EA8( &v32,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  2732LL,  v27,  v28,  v29,  v30,  v31);
  return 1LL;
}

uint64_t sub_100044990( uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t *a8, uint64_t a9)
{
  uint64_t v35 = 0LL;
  memset(v36, 0, sizeof(v36));
  if (!sub_100057AA4( v36,  a3,  a4,  a5,  a6,  a7,  a8,  a9,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  0xABFu)) {
    return 0LL;
  }
  int v17 = *(const char **)(*(void *)(a9 + 24) + 8LL);
  if (v17)
  {
    if (*v17 == 101)
    {
      uint64_t v18 = strchr(v17, 69);
      if (v18)
      {
        uint64_t v19 = v18 + 1;
        uint64_t v20 = strchr(v18 + 1, 46);
        if (v20) {
          BOOL v21 = v19 == v20;
        }
        else {
          BOOL v21 = 1;
        }
        if (!v21)
        {
          sub_100029804( &v35,  qword_10008C560,  v19,  ((_DWORD)v20 - (_DWORD)v19),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  2774LL);
          if (v35)
          {
            (*(void (**)(_DWORD **, unsigned int *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *))(v35 + 56))( v36,  a3,  a4,  a5,  a6,  a7,  a8);
            uint64_t v35 = 0LL;
          }

          else
          {
            sub_10006221C( "store_option: option %d refers to unknown option space '%.*s'.",  v22,  v23,  v24,  v25,  v26,  v27,  0LL,  *(_DWORD *)(*(void *)(a9 + 24) + 24LL));
          }
        }
      }
    }
  }

  uint64_t v28 = sub_10004480C(a1, a2, *(void *)(a9 + 24), (uint64_t)v36);
  sub_100034EA8( v36,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  2799LL,  v29,  v30,  v31,  v32,  v33);
  return v28;
}

uint64_t sub_100044B30( uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8)
{
  uint64_t v8 = *(int *)(a8 + 136);
  uint64_t v21 = *(void *)(a6 + 8 * v8 + 16);
  if (!v21) {
    return 0LL;
  }
  uint64_t v17 = 0LL;
  unsigned int v18 = 0;
  do
  {
    uint64_t v19 = *(uint64_t **)(v21 + 8 * v17);
    for (i = v17; v19; uint64_t v19 = (uint64_t *)v19[1])
    {
    }

    uint64_t v17 = i + 1;
  }

  while (i != 16);
  else {
    return v18;
  }
}

uint64_t sub_100044C48( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  if (*(int *)(a6 + 4) >= 1)
  {
    uint64_t v11 = 0LL;
    uint64_t v12 = 0LL;
    while (1)
    {
      uint64_t v13 = *(void *)(qword_10008C570 + 8 * v11);
      if (!v13) {
        sub_100061FB4( "Impossible condition at %s:%d.",  a2,  a3,  a4,  a5,  a6,  a7,  (uint64_t)a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c");
      }
      uint64_t v14 = *(void *)(v13 + 128);
      if (!v14) {
        goto LABEL_7;
      }
      if (*(void **)(v14 + 16) != a8) {
        goto LABEL_7;
      }
      size_t v15 = *(_BYTE **)(v14 + 8);
      if (!v15 || *v15 != 69) {
        goto LABEL_7;
      }
      unsigned int v16 = (uint64_t (*)(void *, uint64_t, void))a8[1];
      if (!v16) {
        break;
      }
LABEL_7:
    }

    sub_10006221C("can't look up options in %s space.", a2, a3, a4, a5, a6, a7, (uint64_t)a8, *a8);
LABEL_15:
    if ((*(unsigned int (**)(_DWORD **, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v13 + 56))( v28,  a2,  a3,  a4,  a5,  a6,  a7,  v13))
    {
      else {
        uint64_t v12 = v12;
      }
      sub_100034EA8( v28,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  2888LL,  v17,  v18,  v19,  v20,  v21);
    }

    goto LABEL_7;
  }

  return 0LL;
}

uint64_t sub_100044DBC( uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8)
{
  if (*(_DWORD *)(a8 + 136) < *(_DWORD *)(a6 + 4))
  {
    uint64_t v9 = *(void *)(a6 + 8LL * dword_10008C550 + 16);
    if (v9)
    {
      uint64_t v17 = *(uint64_t **)(v9 + 8);
      if (!v17) {
        goto LABEL_11;
      }
      int v18 = 0;
      do
      {
        uint64_t v17 = (uint64_t *)v17[1];
      }

      while (v17);
      if (v18)
      {
        uint64_t v52 = 0LL;
        uint64_t v53 = 0LL;
        uint64_t v54 = 0LL;
        if (sub_1000345C4( &v52,  *(_DWORD *)(a1 + 16) + 2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  3000LL))
        {
          uint64_t v53 = v52 + 1;
          *((_BYTE *)v52 + 4) = 2;
          *((_BYTE *)v52 + 5) = 0;
          memcpy((char *)v52 + 6, *(const void **)(a1 + 8), *(unsigned int *)(a1 + 16));
          sub_100034EA8( (_DWORD **)a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  3008LL,  v24,  v25,  v26,  v27,  v28);
          sub_100034E60( a1,  (uint64_t)&v52,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  3009LL,  v29,  v30,  v31,  v32);
          sub_100034EA8( &v52,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  3010LL,  v33,  v34,  v35,  v36,  v37);
          return 1LL;
        }

        sub_100034EA8( (_DWORD **)a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  3001LL,  v19,  v20,  v21,  v22,  v23);
      }

      else
      {
LABEL_11:
        uint64_t v39 = qword_1000C53A0;
        if (qword_1000C53A0) {
          return sub_100044990(a1, a8, a2, a3, a4, a5, a6, a7, v39);
        }
        int v51 = 1;
        uint64_t v52 = 0LL;
        uint64_t v53 = &unk_100089B10;
        uint64_t v54 = 2LL;
        if (sub_100034540( &qword_1000C53A0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  2981LL,  a4,  a5,  a6,  (uint64_t)a7,  a8)) {
          sub_100034E60( qword_1000C53A0 + 32,  (uint64_t)&v52,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  2982LL,  v40,  v41,  v42,  v43);
        }
        if (!sub_100029804( qword_1000C53A0 + 24,  qword_10008C540,  &v51,  0LL,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  2985LL)) {
          sub_100061FB4( "Nwip option hash does not contain 1 (%s:%d).",  v44,  v45,  v46,  v47,  v48,  v49,  v50,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c");
        }
        uint64_t v39 = qword_1000C53A0;
        if (qword_1000C53A0) {
          return sub_100044990(a1, a8, a2, a3, a4, a5, a6, a7, v39);
        }
      }
    }
  }

  return 0LL;
}

uint64_t sub_100045024( uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  uint64_t v44 = 0LL;
  if (dword_10008C3A0 >= *(_DWORD *)(a6 + 4)) {
    return 0LL;
  }
  uint64_t v8 = *(void *)(a6 + 8LL * dword_10008C3A0 + 16);
  if (!v8) {
    return 0LL;
  }
  uint64_t v9 = a1;
  size_t __n = 0LL;
  __int128 v55 = 0u;
  __int128 v56 = 0u;
  __int128 v53 = 0u;
  __int128 v54 = 0u;
  __int128 v52 = 0u;
  __int128 v50 = 0u;
  __int128 v51 = 0u;
  __int128 v48 = 0u;
  __int128 v49 = 0u;
  __int128 v46 = 0u;
  __int128 v47 = 0u;
  memset(v45, 0, sizeof(v45));
  uint64_t v10 = *(uint64_t **)(v8 + 8);
  if (v10)
  {
    do
    {
      unsigned int v16 = *(_DWORD *)(*(void *)(*v10 + 24) + 24LL);
      if (v16 <= 8) {
        sub_100057AA4( (void *)v45 + 3 * v16,  a2,  a3,  a4,  a5,  a6,  a7,  *v10,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  0xC1Au);
      }
      uint64_t v10 = (uint64_t *)v10[1];
    }

    while (v10);
    int v17 = __n;
    uint64_t v9 = a1;
  }

  else
  {
    int v17 = 0;
  }

  if (!sub_1000345C4( &v44,  v17 + 5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  3108LL))
  {
    sub_10006221C("no memory for option buffer.", v20, v21, v22, v23, v24, v25, v26, v42);
    goto LABEL_31;
  }

  sub_100033F18( (void *)v9,  v44,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  3113LL,  v23,  v24,  v25,  v26);
  *(_DWORD *)(v9 + 16) = 3;
  uint64_t v27 = v44 + 1;
  *(void *)(v9 + 8) = v44 + 1;
  bzero(v27, (v17 + 5));
  if (DWORD2(v46) && *(_BYTE *)v46) {
    *((_BYTE *)v44 + 4) |= 2u;
  }
  if ((_DWORD)v48 && **((_BYTE **)&v47 + 1)) {
    *((_BYTE *)v44 + 4) |= 1u;
  }
  if ((_DWORD)v51) {
    *((_BYTE *)v44 + 5) = **((_BYTE **)&v50 + 1);
  }
  if (DWORD2(v52)) {
    *((_BYTE *)v44 + 6) = *(_BYTE *)v52;
  }
  if (!DWORD2(v49) || !*(_BYTE *)v49)
  {
    if ((_DWORD)__n)
    {
      memcpy((char *)v44 + 7, *((const void **)&v56 + 1), __n);
      int v34 = 0;
      int v35 = *(_DWORD *)(v9 + 16) + __n;
      goto LABEL_29;
    }

uint64_t sub_100045350(_BYTE *a1, int a2, uint64_t a3, int a4)
{
  if (a4 >= 1)
  {
    int v7 = 0;
    int v8 = 0;
    uint64_t v9 = a4;
    while (1)
    {
      uint64_t v10 = 0LL;
      int v11 = v8;
      uint64_t v12 = v8;
      int v13 = a4 <= v8 + 1 ? v8 + 1 : a4;
      uint64_t v14 = a3 + v8;
      while (*(_BYTE *)(v14 + v10) && *(_BYTE *)(v14 + v10) != 46)
      {
        ++v10;
        if (v12 + v10 >= v9) {
          goto LABEL_12;
        }
      }

      int v13 = v11 + v10;
LABEL_12:
      int v15 = v13 - v12;
      uint64_t v16 = (v7 + 1);
      int v7 = v13 - v12 + v16;
      if (v7 > a2) {
        return 0xFFFFFFFFLL;
      }
      *a1 = v15;
      if (v13 == v11) {
        return v16;
      }
      int v17 = a1 + 1;
      memcpy(a1 + 1, (const void *)(a3 + v12), v15);
      a1 = &v17[v15];
      int v8 = v13 + 1;
      if (v13 + 1 >= a4) {
        goto LABEL_17;
      }
    }
  }

  int v7 = 0;
LABEL_17:
  if (v7 >= a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v16 = (v7 + 1);
  *a1 = 0;
  return v16;
}

void sub_10004544C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

uint64_t sub_100045474()
{
  return 0LL;
}

void sub_100045484( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

  ;
}

void sub_1000454B8( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

  ;
}

uint64_t sub_1000454F0( uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8)
{
  if (dword_10008C3A0 >= *(_DWORD *)(a6 + 4)) {
    return 0LL;
  }
  uint64_t v9 = *(void *)(a6 + 8LL * dword_10008C3A0 + 16);
  if (!v9) {
    return 0LL;
  }
  uint64_t v10 = a1;
  uint64_t v49 = 0LL;
  __int128 v47 = 0u;
  __int128 v48 = 0u;
  __int128 v45 = 0u;
  __int128 v46 = 0u;
  __int128 v43 = 0u;
  __int128 v44 = 0u;
  __int128 v41 = 0u;
  __int128 v42 = 0u;
  __int128 v39 = 0u;
  __int128 v40 = 0u;
  __int128 v37 = 0u;
  __int128 v38 = 0u;
  __int128 v36 = 0u;
  int v11 = *(uint64_t **)(v9 + 8);
  if (v11)
  {
    do
    {
      unsigned int v17 = *(_DWORD *)(*(void *)(*v11 + 24) + 24LL);
      if (v17 >= 9) {
        sub_100061FB4( "Impossible condition at %s:%d.",  (uint64_t)a2,  a3,  a4,  a5,  a6,  (uint64_t)a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c");
      }
      sub_100057AA4( (void *)&v36 + 3 * v17,  a2,  a3,  a4,  a5,  a6,  a7,  *v11,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  0xCC2u);
      int v11 = (uint64_t *)v11[1];
    }

    while (v11);
    int v18 = v49;
    uint64_t v10 = a1;
  }

  else
  {
    int v18 = 0;
  }

  if (sub_1000345C4( (void *)v10,  v18 + 3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  3275LL))
  {
    uint64_t v27 = *(_DWORD **)v10;
    uint64_t v28 = (char *)(v27 + 1);
    *(void *)(v10 + 8) = *(void *)v10 + 4LL;
    char v29 = 1;
    *(_DWORD *)(v10 + 16) = 1;
    *((_BYTE *)v27 + 4) = 0;
    if (DWORD2(v38))
    {
      if (*(_BYTE *)v38)
      {
        *uint64_t v28 = 2;
        char v29 = 3;
      }

      else
      {
        char v29 = 1;
      }
    }

    if ((_DWORD)v40 && **((_BYTE **)&v39 + 1)) {
      *uint64_t v28 = v29;
    }
    uint64_t v30 = v49;
    if (!(_DWORD)v49) {
      goto LABEL_22;
    }
    int v31 = sub_100045350((_BYTE *)v27 + 5, v18 + 2, *((uint64_t *)&v48 + 1), v49);
    if ((v31 & 0x80000000) == 0)
    {
      *(void *)(v10 + 16) = (*(_DWORD *)(v10 + 16) + v31);
LABEL_22:
      uint64_t v19 = 1LL;
      goto LABEL_25;
    }

    sub_100034EA8( (_DWORD **)v10,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  3314LL,  v30,  v23,  v24,  v25,  v26);
  }

  else
  {
    sub_10006221C("No memory for virtual option buffer.", v20, v21, v22, v23, v24, v25, v26, v34);
  }

  uint64_t v19 = 0LL;
LABEL_25:
  for (uint64_t i = 0LL; i != 192; i += 24LL)
  {
    if (*(_DWORD *)(v10 + 40 + i)) {
      sub_100034EA8( (_DWORD **)((char *)&v37 + i + 8),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  3327LL,  v30,  v23,  v24,  v25,  v26);
    }
  }

  return v19;
}

uint64_t sub_100045768(uint64_t a1, _BYTE *a2, int a3)
{
  uint64_t v30 = 0LL;
  if (a3)
  {
    if (sub_1000345C4( &v30,  a3 + 2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  3354LL))
    {
      *((_BYTE *)v30 + 4) = 1;
      if (sub_100040F30(&qword_10008C318, a1, (uint64_t)v30, (uint64_t)(v30 + 1), 1LL, 3LL, 0LL, v12))
      {
        *((_BYTE *)v30 + 6) = *a2 & 1;
        if (sub_100040F30(&qword_10008C318, a1, (uint64_t)v30, (uint64_t)v30 + 6, 1LL, 2LL, 0LL, v17))
        {
          *((_BYTE *)v30 + 5) = (*a2 & 2) != 0;
          if (sub_100040F30(&qword_10008C318, a1, (uint64_t)v30, (uint64_t)v30 + 5, 1LL, 1LL, 0LL, v17))
          {
            uint64_t v18 = sub_100069DB8(a2 + 1, (_BYTE *)v30 + 7, (a3 - 1));
            if ((_DWORD)v18 == -1)
            {
              sub_10006221C( "Unable to convert dhcp6.fqdn domain name to printable form.",  v19,  v20,  v13,  v14,  v15,  v16,  v17,  v29);
            }

            else
            {
              uint64_t v21 = v18;
              if ((int)v18 < 1
                || (uint64_t v22 = (char *)v30 + 7,
                    sub_100040F30( &qword_10008C318,  a1,  (uint64_t)v30,  (uint64_t)v30 + 7,  v18,  8LL,  1LL,  v17))
                && ((uint64_t v23 = strchr(v22, 46), (v25 = (uint64_t)v23) != 0)
                  ? (uint64_t v26 = ((_DWORD)v23 - (_DWORD)v22))
                  : (uint64_t v26 = v21),
                    v23 ? (uint64_t v27 = (v21 - ((_DWORD)v23 - (_DWORD)v22))) : (uint64_t v27 = 0LL),
                    sub_100040F30(&qword_10008C318, a1, (uint64_t)v30, (uint64_t)v22, v21, 8LL, 1LL, v24)
                 && ((int)v26 < 1
                  || sub_100040F30(&qword_10008C318, a1, (uint64_t)v30, (uint64_t)v22, v26, 6LL, 0LL, v17))
                 && ((int)v27 < 1
                  || sub_100040F30(&qword_10008C318, a1, (uint64_t)v30, v25, v27, 7LL, 0LL, v17))))
              {
                sub_10003462C( &v30,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  3423LL,  v13,  v14,  v15,  v16,  v17);
                return 1LL;
              }
            }
          }
        }
      }

      sub_10003462C( &v30,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  3427LL,  v13,  v14,  v15,  v16,  v17);
    }

    else
    {
      sub_10006221C("No memory for dhcp6.fqdn option buffer.", v6, v7, v8, v9, v10, v11, v12, v29);
    }
  }

  return 0LL;
}

const char **sub_1000459BC( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, const char *a11)
{
  uint64_t result = sub_100040FE0(*(void *)(a10 + 24), a11);
  uint64_t v19 = result[3];
  if (v19) {
    return (const char **)((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, const char **, uint64_t, uint64_t))v19)( a1,  a2,  a3,  a4,  a5,  a6,  result,  a8,  a9);
  }
  return result;
}

uint64_t sub_100045A5C( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t (*a9)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))
{
  uint64_t v9 = *(int *)(a7 + 136);
  if (*(_DWORD *)(a5 + 4) > (int)v9)
  {
    uint64_t v20 = *(void *)(a5 + 8 * v9 + 16);
    if (v20)
    {
      uint64_t v17 = result;
      uint64_t v18 = 0LL;
      do
      {
        uint64_t v21 = v18;
        for (uint64_t i = *(void **)(v20 + 8 * v18); i; uint64_t i = (void *)i[1])
          uint64_t result = a9(*i, v17, a2, a3, a4, a5, a6, a7, a8);
        uint64_t v18 = v21 + 1;
      }

      while (v21 != 16);
    }
  }

  return result;
}

uint64_t sub_100045B34( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(int *)(result + 136);
  if ((int)v8 < *(_DWORD *)(a2 + 4))
  {
    int v9 = a4;
    uint64_t v12 = result;
    uint64_t v13 = a2 + 8 * v8;
    uint64_t v16 = *(void *)(v13 + 16);
    uint64_t v14 = (void *)(v13 + 16);
    uint64_t v15 = v16;
    if (!v16)
    {
      uint64_t result = sub_100033E60( v14,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  3525LL,  a4,  a5,  a6,  a7,  a8);
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v15 = *(void *)(a2 + 8LL * *(int *)(v12 + 136) + 16);
    }

    uint64_t v19 = *(void **)(v15 + 8);
    uint64_t v18 = (uint64_t *)(v15 + 8);
    uint64_t v17 = v19;
    if (v19)
    {
      while (1)
      {
        uint64_t v20 = v17;
        uint64_t v21 = *v17;
        if (*(_DWORD *)(*(void *)(a3 + 24) + 24LL) == *(_DWORD *)(*(void *)(v21 + 24) + 24LL)) {
          break;
        }
        uint64_t v17 = (void *)v20[1];
        if (!v17)
        {
          uint64_t v18 = v20 + 1;
          goto LABEL_9;
        }
      }

      if (v9)
      {
        do
        {
          uint64_t v24 = v21;
          uint64_t v21 = *(void *)(v21 + 8);
        }

        while (v21);
        uint64_t v20 = (void *)(v24 + 8);
      }

      else
      {
        sub_100040E08( (int **)v20,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  3541LL,  a4,  a5,  a6,  a7,  a8);
      }

      uint64_t result = (uint64_t)v20;
      uint64_t v22 = (_DWORD *)a3;
      uint64_t v23 = 3543LL;
      return sub_100033F18( (void *)result,  v22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  v23,  a5,  a6,  a7,  a8);
    }

uint64_t sub_100045C58( uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8)
{
  uint64_t v8 = *(int *)(a8 + 136);
  uint64_t v10 = *(void *)(a6 + 8 * v8 + 16);
  if (!v10) {
    return 0LL;
  }
  uint64_t v18 = *(uint64_t **)(v10 + 8);
  if (v18)
  {
    unsigned int v19 = 0;
    do
    {
      uint64_t v18 = (uint64_t *)v18[1];
    }

    while (v18);
  }

  else
  {
    unsigned int v19 = 0;
  }

  else {
    return v19;
  }
}

void sub_100045D58( uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(int *)(a1 + 136);
  if ((int)v8 < *(_DWORD *)(a2 + 4))
  {
    uint64_t v9 = *(void *)(a2 + 8 * v8 + 16);
    if (v9)
    {
      uint64_t v12 = *(void *)(v9 + 8);
      uint64_t v11 = (void **)(v9 + 8);
      uint64_t v10 = v12;
      if (v12)
      {
        if (*(_DWORD *)(*(void *)(*(void *)v10 + 24LL) + 24LL) == a3)
        {
LABEL_8:
          uint64_t v14 = *(void **)(v10 + 8);
          sub_100040E08( (int **)v10,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  3612LL,  a4,  a5,  a6,  a7,  a8);
          sub_10005CE20( *v11,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  3613LL,  v15,  v16,  v17,  v18,  v19);
          *uint64_t v11 = v14;
        }

        else
        {
          while (1)
          {
            uint64_t v13 = v10;
            uint64_t v10 = *(void *)(v10 + 8);
            if (!v10) {
              break;
            }
            if (*(_DWORD *)(*(void *)(*(void *)v10 + 24LL) + 24LL) == a3)
            {
              uint64_t v11 = (void **)(v13 + 8);
              goto LABEL_8;
            }
          }
        }
      }
    }
  }

uint64_t sub_100045E00(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3 = *(int *)(a1 + 136);
  if ((int)v3 < *(_DWORD *)(a2 + 4))
  {
    int v4 = *(void **)(a2 + 8 * v3 + 16);
    if (v4)
    {
      while (1)
      {
        int v4 = (void *)v4[1];
        if (!v4) {
          break;
        }
        uint64_t result = *v4;
        if (*(_DWORD *)(*(void *)(*v4 + 24LL) + 24LL) == a3) {
          return result;
        }
      }
    }
  }

  return 0LL;
}

uint64_t sub_100045E44( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_100033F88( (void *)(a2 + 8LL * *(int *)(a1 + 136) + 16),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  3653LL,  a4,  a5,  a6,  a7,  a8);
}

uint64_t sub_100045E60( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t (*a9)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))
{
  uint64_t v9 = *(int *)(a7 + 136);
  if ((int)v9 < *(_DWORD *)(a5 + 4))
  {
    uint64_t v11 = *(void *)(a5 + 8 * v9 + 16);
    if (v11)
    {
      uint64_t v12 = *(void **)(v11 + 8);
      if (v12)
      {
        uint64_t v19 = result;
        do
        {
          uint64_t result = a9(*v12, v19, a2, a3, a4, a5, a6, a7, a8);
          uint64_t v12 = (void *)v12[1];
        }

        while (v12);
      }
    }
  }

  return result;
}

uint64_t sub_100045F18(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, __int128 *a6)
{
  __int128 v52 = *(_OWORD *)a5;
  LODWORD(v53) = *(_DWORD *)(a5 + 16);
  sub_100039CCC(a1, a2, a3, a4, &v52, a6);
  __int128 v51 = 0LL;
  if (!sub_1000349E8( (uint64_t *)&v51,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  3706LL,  v12,  v13,  v14,  v15,  v16)) {
    return sub_10006221C("do_packet: no memory for incoming packet!", v17, v18, v19, v20, v21, v22, v23, v50);
  }
  *__int128 v51 = a2;
  uint64_t v24 = v51;
  *((_DWORD *)v51 + 3) = a3;
  *((_DWORD *)v24 + 19) = a4;
  int v25 = *(_DWORD *)(a5 + 16);
  *((_OWORD *)v24 + 5) = *(_OWORD *)a5;
  *((_DWORD *)v24 + 24) = v25;
  sub_1000235CC(v24 + 13, a1, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c", 3714LL);
  int v33 = v51;
  v51[14] = (uint64_t)a6;
  if (*(unsigned __int8 *)(a2 + 2) >= 0x11u)
  {
    sub_100034B48( (uint64_t *)&v51,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  3718LL,  v28,  v29,  v30,  v31,  v32);
    return sub_1000622D4("Discarding packet with bogus hlen.", v34, v35, v36, v37, v38, v39, v40, v50);
  }

  if (*((_DWORD *)v33 + 3) >= 0xF0u)
  {
    if (!sub_10004077C(v33, v26, v27, v28, v29, v30, v31, v32))
    {
      if (v51[20]) {
        sub_100034894( v51 + 20,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  3728LL,  v28,  v29,  v30,  v31,  v32);
      }
      uint64_t v49 = 3729LL;
      return sub_100034B48( (uint64_t *)&v51,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  v49,  v28,  v29,  v30,  v31,  v32);
    }

    if (*((_DWORD *)v51 + 18))
    {
      uint64_t v26 = v51[20];
      if (v26)
      {
        if (off_10008C170)
        {
          uint64_t v42 = off_10008C170(&qword_10008C168);
          if (v42)
          {
            __int128 v52 = 0uLL;
            uint64_t v53 = 0LL;
            sub_100057AA4( &v52,  (unsigned int *)v51,  0LL,  0LL,  v51[20],  0LL,  0LL,  v42,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  0xEA1u);
            int v48 = v53;
            if ((_DWORD)v53) {
              int v48 = **((_BYTE **)&v52 + 1);
            }
            *((_DWORD *)v51 + 4) = v48;
            sub_100034EA8( (_DWORD **)&v52,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  3750LL,  v43,  v44,  v45,  v46,  v47);
          }
        }

        else
        {
          sub_10006221C("can't look up options in %s space.", v26, v27, v28, v29, v30, v31, v32, qword_10008C168);
        }
      }
    }
  }

  if (*((_DWORD *)v51 + 4)) {
    sub_10000F81C(v51, v26, v27, v28, v29, v30, v31, v32);
  }
  else {
    sub_100002898((uint64_t)v51);
  }
  uint64_t v49 = 3760LL;
  return sub_100034B48( (uint64_t *)&v51,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  v49,  v28,  v29,  v30,  v31,  v32);
}

BOOL sub_10004616C(_BYTE *a1, int a2)
{
  if (a2 < 1) {
    return 0LL;
  }
  if ((*a1 & 0xFE) == 0xC) {
    return a2 > 0x21;
  }
  return a2 > 3;
}

uint64_t sub_1000461A0( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = a4;
  int v10 = a3;
  if ((int)a3 < 1 || ((*(_BYTE *)a2 & 0xFE) != 0xC ? (unsigned int v12 = 3) : (unsigned int v12 = 33), v12 >= a3))
  {
    __int128 v52 = *(_OWORD *)a5;
    int v53 = *(_DWORD *)(a5 + 16);
    char v41 = sub_100040144((int *)&v52, a2, a3, a4, a5, a6, a7, a8);
    return sub_1000622D4( "do_packet6: short packet from %s port %d, len %d, dropped",  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v41);
  }

  int v13 = a6;
  *(void *)&__int128 v52 = 0LL;
  if (!sub_1000349E8( (uint64_t *)&v52,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  3815LL,  a4,  a5,  a6,  a7,  a8)) {
    return sub_10006221C("do_packet6: no memory for incoming packet.", v15, v16, v17, v18, v19, v20, v21, v51);
  }
  if (!sub_1000347D8( (uint64_t *)(v52 + 160),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  3820LL,  v17,  v18,  v19,  v20,  v21))
  {
    sub_10006221C("do_packet6: no memory for options.", v22, v23, v24, v25, v26, v27, v28, v51);
    uint64_t v40 = 3822LL;
    return sub_100034B48( (uint64_t *)&v52,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  v40,  v35,  v36,  v37,  v38,  v39);
  }

  *(void *)__int128 v52 = a2;
  uint64_t v29 = v52;
  *(_DWORD *)(v52 + 12) = v10;
  *(_DWORD *)(v29 + 76) = v9;
  int v30 = *(_DWORD *)(a5 + 16);
  *(_OWORD *)(v29 + 8__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = *(_OWORD *)a5;
  *(_DWORD *)(v29 + 96) = v30;
  sub_1000235CC(v29 + 104, a1, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c", 3837LL);
  uint64_t v31 = v52;
  *(_DWORD *)(v52 + 228) = v13;
  int v32 = *(_BYTE *)a2 & 0xFE;
  *(_BYTE *)(v31 + 2__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = *(_BYTE *)a2;
  if (v32 != 12)
  {
    __int16 v50 = *(_WORD *)(a2 + 1);
    *(_BYTE *)(v31 + 23) = *(_BYTE *)(a2 + 3);
    *(_WORD *)(v31 + 21) = v50;
    if (!sub_100040920(*(void *)(v31 + 160), (char *)(a2 + 4), v10 - 4, (uint64_t)&qword_10008C1F8))
    {
      uint64_t v40 = 3876LL;
      return sub_100034B48( (uint64_t *)&v52,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  v40,  v35,  v36,  v37,  v38,  v39);
    }

    goto LABEL_15;
  }

  *(_BYTE *)(v31 + 24) = *(_BYTE *)(a2 + 1);
  *(_OWORD *)(v31 + 28) = *(_OWORD *)(a2 + 2);
  *(_OWORD *)(v31 + 44) = *(_OWORD *)(a2 + 18);
  if (sub_100040920(*(void *)(v31 + 160), (char *)(a2 + 34), v10 - 34, (uint64_t)&qword_10008C1F8))
  {
LABEL_15:
    sub_10001AD00(v52, v33, v34, v35, v36, v37, v38, v39);
    uint64_t v40 = 3883LL;
    return sub_100034B48( (uint64_t *)&v52,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  v40,  v35,  v36,  v37,  v38,  v39);
  }

  uint64_t v40 = 3859LL;
  return sub_100034B48( (uint64_t *)&v52,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  v40,  v35,  v36,  v37,  v38,  v39);
}

uint64_t sub_1000463D0(char **a1, unint64_t a2, char **a3, char *a4)
{
  uint64_t v4 = 0xFFFFFFFFLL;
  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        if (a4)
        {
          int v9 = *a1;
          if (*a1)
          {
            int v10 = *a3;
            if (*a3 <= a4 && (unint64_t)v9 < a2 && v10 && a4 - v10 <= (uint64_t)(a2 - (void)v9))
            {
              if (v10 < a4)
              {
                uint64_t v4 = 0LL;
                while (1)
                {
                  int v11 = *v10;
                  if ((*v10 & 0x80000000) == 0 && (_DefaultRuneLocale.__runetype[*v10] & 0x40000) != 0)
                  {
                    if ((v11 - 34) > 0x3E
                      || ((1LL << (v11 - 34)) & 0x4400000000000025LL) == 0)
                    {
                      **a1 = v11;
                      uint64_t v12 = 1LL;
                      int v13 = 1;
                    }

                    else
                    {
                      **a1 = 92;
                      uint64_t v15 = (*a1)++;
                      v15[1] = **a3;
                      int v13 = 2;
                      uint64_t v12 = 1LL;
                    }
                  }

                  else
                  {
                    if (v10 + 1 == a4 && !*v10) {
                      goto LABEL_25;
                    }
                    sprintf(*a1, "\\%03o", v11);
                    uint64_t v12 = 4LL;
                    int v13 = 4;
                  }

                  *a1 += v12;
                  uint64_t v4 = (v4 + v13);
LABEL_25:
                  int v10 = *a3 + 1;
                  *a3 = v10;
                  if (v10 >= a4) {
                    return v4;
                  }
                }
              }

              return 0LL;
            }
          }
        }
      }
    }
  }

  return v4;
}

uint64_t sub_100046588(uint64_t a1, int a2, const void *a3, int a4)
{
  int v48 = a2;
  uint64_t v46 = 0LL;
  if (!sub_100029804( &v46,  qword_10008C1E0,  &v48,  0LL,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  4043LL))
  {
    sub_10006221C("Attempting to add unknown option %d.", v7, v8, v9, v10, v11, v12, v13, v48);
    return 0LL;
  }

  uint64_t v47 = 0LL;
  if (!sub_100034540( &v47,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  4049LL,  v9,  v10,  v11,  v12,  v13))
  {
    sub_10006221C("No memory for option cache adding %s (option %d).", v14, v15, v16, v17, v18, v19, v20, *v46);
    return 0LL;
  }

  if (!sub_1000545BC( v47 + 2,  a3,  a4,  0LL,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  4060LL,  v20))
  {
    sub_10006221C("No memory for constant data adding %s (option %d).", v21, v22, v23, v24, v25, v26, v27, *v46);
    sub_100040E08( (int **)&v47,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  4063LL,  v41,  v42,  v43,  v44,  v45);
    return 0LL;
  }

  sub_100052CB0(v47 + 3, (uint64_t)v46);
  if (off_10008C178) {
    ((void (*)(uint64_t *, uint64_t, uint64_t *, void))off_10008C178)(&qword_10008C168, a1, v47, 0LL);
  }
  else {
    sub_10006221C("can't store options in %s space.", v28, v29, v30, v31, v32, v33, v34, qword_10008C168);
  }
  sub_100040E08( (int **)&v47,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/options.c",  4069LL,  v35,  v36,  v37,  v38,  v39);
  return 1LL;
}

uint64_t sub_10004670C(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if ((a2 & 0xFFFFFFFE) != 0)
  {
    unint64_t v3 = 0LL;
    do
    {
      unsigned int v4 = a3 + (bswap32(*(unsigned __int16 *)(a1 + v3)) >> 16);
      if (HIWORD(v4)) {
        a3 = v4 - 0xFFFF;
      }
      else {
        a3 = v4;
      }
      v3 += 2LL;
    }

    while (v3 < (a2 & 0xFFFFFFFE));
  }

  else
  {
    LODWORD(v3) = 0;
  }

  if (v3 < a2)
  {
    unsigned int v5 = a3 + (*(unsigned __int8 *)(a1 + v3) << 8);
    if (HIWORD(v5)) {
      return v5 - 0xFFFF;
    }
    else {
      return v5;
    }
  }

  return a3;
}

uint64_t sub_100046778(int a1)
{
  return bswap32(~a1) >> 16;
}

uint64_t sub_10004678C( uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, __int16 a6, uint64_t a7, unsigned int a8)
{
  uint64_t v8 = (_DWORD *)a3;
  unint64_t v10 = 0LL;
  unsigned int v11 = 0;
  LOWORD(v22) = 4165;
  WORD1(v22) = bswap32(a8 + 28) >> 16;
  *(void *)((char *)&v22 + 4) = 0x118000000000LL;
  HIDWORD(v22) = a4;
  int v23 = a5;
  do
  {
    v11 += bswap32(*(unsigned __int16 *)((char *)&v22 + v10)) >> 16;
    if (HIWORD(v11)) {
      v11 -= 0xFFFF;
    }
    BOOL v12 = v10 >= 0x12;
    v10 += 2LL;
  }

  while (!v12);
  WORD5(v22) = bswap32(~v11) >> 16;
  uint64_t v13 = a2 + *(unsigned int *)a3;
  *(_DWORD *)(v13 + 16) = v23;
  *(_OWORD *)uint64_t v13 = v22;
  unsigned int v14 = *(_DWORD *)a3 + 20;
  *(_DWORD *)a3 = v14;
  LOWORD(v21) = word_10008C0F4;
  WORD1(v21) = a6;
  HIDWORD(v21) = bswap32(a8 + 8) >> 16;
  LODWORD(a3) = (unsigned __int16)(a8 + 8) + 17;
  uint64_t v15 = 12LL;
  do
  {
    unsigned int v16 = a3 + (bswap32(*(unsigned __int16 *)((char *)&v22 + v15)) >> 16);
    if (HIWORD(v16)) {
      a3 = v16 - 0xFFFF;
    }
    else {
      a3 = v16;
    }
    unint64_t v17 = v15 - 12;
    v15 += 2LL;
  }

  while (v17 < 6);
  LODWORD(result) = sub_10004670C(a7, a8, a3);
  unint64_t v19 = 0LL;
  do
  {
    unsigned int v20 = result + (bswap32(*(unsigned __int16 *)((char *)&v21 + v19)) >> 16);
    if (HIWORD(v20)) {
      uint64_t result = v20 - 0xFFFF;
    }
    else {
      uint64_t result = v20;
    }
    BOOL v12 = v19 >= 6;
    v19 += 2LL;
  }

  while (!v12);
  HIWORD(v21) = bswap32(~(_DWORD)result) >> 16;
  *(void *)(a2 + v14) = v21;
  *v8 += 8;
  return result;
}

uint64_t sub_100046924( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v49 = v8;
  uint64_t v50 = v9;
  uint64_t v11 = a2 + a3;
  __int128 v47 = *(_OWORD *)v11;
  int v48 = *(_DWORD *)(v11 + 16);
  unint64_t v12 = v11 + a5;
  uint64_t v13 = 4LL * (*(_BYTE *)v11 & 0xF);
  unsigned int v14 = (unint64_t *)(v11 + v13);
  unint64_t v15 = v11 + v13 + 8;
  if (v15 > v12) {
    return -1LL;
  }
  unint64_t v16 = *v14;
  unint64_t v46 = v16;
  unsigned int v17 = bswap32(HIDWORD(v16)) >> 16;
  if (v17 < 8) {
    return -1LL;
  }
  int v18 = dword_1000C53B8;
  int v19 = ++dword_1000C53B8;
  if ((unint64_t)v14 + v17 > v12)
  {
    int v20 = ++dword_1000C53BC;
    if (v18 >= 4 && v19 / v20 <= 1)
    {
      sub_1000622D4("%d udp packets in %d too long - dropped", a2, a3, a4, a5, (uint64_t)a6, a7, a8, v20);
      dword_1000C53BC = 0;
      dword_1000C53B8 = 0;
    }

    return -1LL;
  }

  int v23 = dword_1000C53A8;
  int v24 = ++dword_1000C53A8;
  if ((unsigned __int16)sub_10004670C(v11, v13, 0LL) != 0xFFFF)
  {
    int v45 = ++dword_1000C53AC;
    if (v23 >= 4 && v24 / v45 <= 1)
    {
      sub_1000622D4("%d bad IP checksums seen in %d packets", v25, v26, v27, v28, v29, v30, v31, v45);
      dword_1000C53AC = 0;
      dword_1000C53A8 = 0;
    }

    return -1LL;
  }

  *(_DWORD *)(a4 + 4) = HIDWORD(v47);
  HIWORD(v46) = 0;
  uint64_t v32 = sub_10004670C((unint64_t)&v47 | 0xC, 8u, v17 + 17);
  uint64_t v33 = sub_10004670C(v15, v17 - 8, v32);
  int v34 = sub_10004670C((uint64_t)&v46, 8u, v33);
  int v42 = dword_1000C53B0;
  int v43 = ++dword_1000C53B0;
  if (HIWORD(v16) && bswap32(~v34) >> 16 != HIWORD(v16))
  {
    int v44 = ++dword_1000C53B4;
    if (v42 >= 4 && v43 / v44 <= 1)
    {
      sub_1000622D4("%d bad udp checksums in %d packets", v35, v36, v37, v38, v39, v40, v41, v44);
      dword_1000C53B4 = 0;
      dword_1000C53B0 = 0;
    }

    return -1LL;
  }

  *(_WORD *)(a4 + 2) = v46;
  if (a6) {
    *a6 = v17 - 8;
  }
  return v13 + 8;
}

void *sub_100046B60(void *result)
{
  _WORD *result = qword_10008C150;
  qword_10008C150 = (uint64_t)result;
  return result;
}

uint64_t sub_100046B74(const void *a1, unsigned int a2)
{
  uint64_t v2 = qword_10008C150;
  if (qword_10008C150)
  {
    uint64_t v4 = (int)a2;
    size_t v5 = a2;
    do
    {
      uint64_t v2 = *(void *)v2;
    }

    while (v2);
  }

  return v2;
}

const char **sub_100046BE8(const void *a1, unsigned int a2, _DWORD *a3, const char *a4)
{
  uint64_t v6 = sub_100046B74(a1, a2);
  if (!v6) {
    return 0LL;
  }
  if (a3) {
    *a3 = *(_DWORD *)(v6 + 16);
  }
  uint64_t v7 = *(const char ***)(v6 + 24);
  uint64_t v8 = *v7;
  if (!*v7) {
    return 0LL;
  }
  while (strcmp(a4, v8))
  {
    uint64_t v9 = v7[2];
    v7 += 2;
    uint64_t v8 = v9;
    if (!v9) {
      return 0LL;
    }
  }

  return v7;
}

uint64_t sub_100046C44(int32x2_t *a1)
{
  return sub_100046C4C(a1, 0);
}

uint64_t sub_100046C4C(int32x2_t *a1, unsigned int a2)
{
  while (1)
  {
    int v4 = sub_1000374AC(&v7, 0LL, a1);
    if (v4 == 123)
    {
      ++a2;
      goto LABEL_11;
    }

    if (v4 == 125)
    {
      uint64_t result = sub_100036D00(&v7, 0LL, (uint64_t)a1);
      if (a2 < 2) {
        return result;
      }
      --a2;
      goto LABEL_11;
    }

    BOOL v6 = !a2 && v4 == 59;
    if (v6 || v4 == 10) {
      return sub_100036D00(&v7, 0LL, (uint64_t)a1);
    }
LABEL_11:
    uint64_t result = sub_100036D00(&v7, 0LL, (uint64_t)a1);
    if ((_DWORD)result == 607) {
      return result;
    }
  }

uint64_t sub_100046D08(int32x2_t *a1)
{
  return 0LL;
}

uint64_t sub_100046D6C( uint64_t a1, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v10 = *(_BYTE **)(a1 + 8);
  int v11 = *v10;
  if (*v10)
  {
    uint64_t v12 = 0LL;
    unsigned int v13 = 0;
    uint64_t v14 = (*(_DWORD *)(a1 + 4) - 1);
    do
    {
      if (v12 == v14) {
        break;
      }
      if (v13 <= 0xFE) {
        __buf[v13++] = 32;
      }
      if (v11 == 9 && v13 <= 0xFE && (v13 & 7) != 0)
      {
        unsigned int v15 = v13 & 7 ^ 7;
        if (254 - v13 < v15) {
          unsigned int v15 = 254 - v13;
        }
        memset(&__buf[v13], 32, v15 + 1);
        uint64_t v16 = 0LL;
        do
          unint64_t v17 = v13 + v16++;
        while (v17 <= 0xFD && (((_BYTE)v17 + 1) & 7) != 0);
        v13 += v16;
      }

      int v11 = v10[++v12];
    }

    while (v10[v12]);
  }

  else
  {
    unsigned int v13 = 0;
  }

  __buf[v13] = 0;
  syslog(dword_10008CEA0 | 3, "%s", __s);
  syslog(dword_10008CEA0 | 3, "%s", *(const char **)(a1 + 8));
  if (dword_10008BBA0)
  {
    size_t v18 = strlen(__s);
    write(2, __s, v18);
    write(2, "\n", 1uLL);
    size_t v19 = strlen(*(const char **)(a1 + 8));
    write(2, *(const void **)(a1 + 8), v19);
    write(2, "\n", 1uLL);
    write(2, "^\n", 2uLL);
  }

  *(_DWORD *)(a1 + 1744) = 1;
  return 0LL;
}

uint64_t sub_100046FEC(int32x2_t *a1, void *a2, _DWORD *a3)
{
  if (sub_100036D00(&__src, &v28, (uint64_t)a1) == 262)
  {
    uint64_t v12 = sub_10005CDE4((v28 + 1));
    int v20 = v12;
    if (!v12) {
      sub_100061FB4("no memory for string %s.", v13, v14, v15, v16, v17, v18, v19, (char)__src);
    }
    memcpy(v12, __src, (v28 + 1));
    if (sub_100046D08(a1))
    {
      if (a2)
      {
        *a2 = v20;
        if (!a3) {
          return 1LL;
        }
      }

      else
      {
        sub_10005CE20( v20,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  180LL,  v21,  v22,  v23,  v24,  v25);
        if (!a3) {
          return 1LL;
        }
      }

      *a3 = v28;
      return 1LL;
    }

    sub_10005CE20( v20,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  174LL,  v21,  v22,  v23,  v24,  v25);
  }

  else
  {
    sub_100046D6C((uint64_t)a1, "expecting a string", v6, v7, v8, v9, v10, v11, v27);
    sub_100046C4C(a1, 0);
  }

  return 0LL;
}

char *sub_1000470FC(int32x2_t *a1)
{
  unsigned int v2 = sub_1000374AC(&__s, 0LL, a1);
  BOOL v5 = v2 > 0xFF && v2 - 264 < 0xFFFFFFFE && v2 != 607;
  if (v2 == 263 || (uint64_t v6 = 0LL, v5))
  {
    uint64_t v7 = 0LL;
    int v8 = 0;
    while (1)
    {
      sub_100036D00(&__s, 0LL, (uint64_t)a1);
      int v9 = strlen(__s);
      uint64_t v10 = (char *)sub_10005CDE4((v9 + 1));
      uint64_t v18 = v10;
      if (!v10) {
        sub_100061FB4("can't allocate temp space for hostname.", v11, v12, v13, v14, v15, v16, v17, v50);
      }
      uint64_t v19 = strcpy(v10, __s);
      uint64_t v7 = (const char **)sub_10005415C((uint64_t)v19, (uint64_t)v7);
      v8 += strlen(v18) + 1;
      int v20 = sub_1000374AC(&__s, 0LL, a1);
      if (v20 != 46) {
        break;
      }
      if (sub_100036D00(&__s, 0LL, (uint64_t)a1) == 46)
      {
        unsigned int v21 = sub_1000374AC(&__s, 0LL, a1);
        BOOL v22 = v21 <= 0xFF || v21 - 264 >= 0xFFFFFFFE;
        BOOL v23 = v22 || v21 == 607;
        BOOL v24 = !v23;
        if (v21 == 263 || v24) {
          continue;
        }
      }

      unsigned int v25 = 1;
      if (v8) {
        goto LABEL_29;
      }
      return 0LL;
    }

    unsigned int v25 = 0;
    if (!v8) {
      return 0LL;
    }
LABEL_29:
    uint64_t v26 = (char *)sub_10005CDE4(v25 + v8);
    uint64_t v6 = v26;
    if (!v26) {
      sub_100061FB4("can't allocate space for hostname.", v27, v28, v29, v30, v31, v32, v33, v50);
    }
    int v34 = &v26[v8 + v25];
    *(v34 - 1) = 0;
    uint64_t v35 = v34 - 1;
    if (v20 == 46)
    {
      *(v34 - 2) = 46;
      uint64_t v35 = v34 - 2;
    }

    while (v7)
    {
      uint64_t v36 = v7;
      uint64_t v7 = (const char **)v7[1];
      unsigned int v37 = strlen(*v36);
      uint64_t v38 = &v35[-v37];
      memcpy(v38, *v36, v37);
      sub_10005CE20( (void *)*v36,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  244LL,  v39,  v40,  v41,  v42,  v43);
      sub_10005CE20( v36,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  245LL,  v44,  v45,  v46,  v47,  v48);
      uint64_t v35 = v6;
      if (v38 != v6)
      {
        *(v38 - 1) = 46;
        uint64_t v35 = v38 - 1;
      }
    }
  }

  return v6;
}

uint64_t sub_100047324(uint64_t *a1, int32x2_t *a2, int a3)
{
  int v49 = 4;
  uint64_t v48 = 0LL;
  unsigned int v13 = sub_1000374AC(&v51, 0LL, a2);
  if (v13 == 263)
  {
    sub_100036C58(a2, v6, v7, v8, v9, v10, v11, v12);
    sub_100036D00(0LL, 0LL, (uint64_t)a2);
    if (sub_100036D00(0LL, 0LL, (uint64_t)a2) == 46)
    {
      int v14 = sub_100036D00(0LL, 0LL, (uint64_t)a2);
      sub_100036CC0((const void **)a2);
      if (v14 == 263 && sub_100047540(a2, &v50, (unsigned int *)&v49, 46, 10LL, 8LL)) {
        return sub_1000545BC( a1,  &v50,  v49,  0LL,  1LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  296LL,  v12);
      }
    }

    else
    {
      sub_100036CC0((const void **)a2);
    }
  }

  BOOL v18 = v13 > 0xFF && v13 - 264 < 0xFFFFFFFE && v13 != 607;
  if (v13 != 263 && !v18)
  {
    if (v13 == 125 || v13 == 123)
    {
      sub_100046D6C((uint64_t)a2, "%s (%d): expecting IP address or hostname", v7, v8, v9, v10, v11, v12, v51);
    }

    else
    {
      int v41 = sub_100036D00(&v51, 0LL, (uint64_t)a2);
      sub_100046D6C((uint64_t)a2, "%s (%d): expecting IP address or hostname", v42, v43, v44, v45, v46, v47, v51);
      if (v41 == 59) {
        return 0LL;
      }
    }

    sub_100046C4C(a2, 0);
    return 0LL;
  }

  uint64_t result = (uint64_t)sub_1000470FC(a2);
  if (!result) {
    return result;
  }
  unsigned int v25 = (void *)result;
  if (!sub_1000542D4(a1, (char *)result, v19, v20, v21, v22, v23, v24))
  {
    sub_10005CE20( v25,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  305LL,  v26,  v27,  v28,  v29,  v30);
    return 0LL;
  }

  sub_10005CE20( v25,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  308LL,  v26,  v27,  v28,  v29,  v30);
  if (!a3)
  {
    uint64_t result = sub_100054910(&v48, (_DWORD *)*a1, 4, v31, v32, v33, v34, v35);
    if (!(_DWORD)result) {
      return result;
    }
    sub_100054390( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  312LL,  v36,  v37,  v38,  v39,  v40);
    *a1 = v48;
  }

  return 1LL;
}

char *sub_100047540(int32x2_t *a1, _DWORD *a2, unsigned int *a3, int a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10 = a2;
  uint64_t v12 = (char *)a2;
  if (!a2)
  {
    if (*a3)
    {
      uint64_t v12 = (char *)sub_10005CDE4((*a3 * a6) >> 3);
      if (!v12) {
        sub_100061FB4("no space for numeric aggregate", v13, v14, v15, v16, v17, v18, v19, v71);
      }
    }

    else
    {
      uint64_t v12 = 0LL;
    }
  }

  unsigned int v20 = 0;
  uint64_t v21 = 0LL;
  uint64_t v22 = a6 >> 3;
  uint64_t v72 = "expecting numeric value.";
  uint64_t v73 = v12;
  while (1)
  {
    if (!v20) {
      goto LABEL_10;
    }
    int v23 = sub_1000374AC(&__s, 0LL, a1);
    if (v23 != a4) {
      break;
    }
    sub_100036D00(&__s, 0LL, (uint64_t)a1);
LABEL_10:
    int v30 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
    if (v30 != 263)
    {
      if (v30 == 607)
      {
        sub_100046D6C((uint64_t)a1, "unexpected end of file", v24, v25, v26, v27, v28, v29, v71);
        goto LABEL_27;
      }

      if ((_DWORD)a5 != 16 || v30 != 264) {
        goto LABEL_24;
      }
    }

    if (v10)
    {
      sub_100047FD0(a1, v10, (unsigned __int8 *)__s, a5, a6, v27, v28, v29);
      uint64_t v10 = (_DWORD *)((char *)v10 + v22);
    }

    else
    {
      int v31 = strlen(__s);
      uint64_t v32 = (char *)sub_10005CDE4((v31 + 1));
      if (!v32) {
        sub_100061FB4("no temp space for number.", v33, v34, v35, v36, v37, v38, v39, v71);
      }
      uint64_t v40 = strcpy(v32, __s);
      uint64_t v21 = (unsigned __int8 **)sub_10005415C((uint64_t)v40, (uint64_t)v21);
      uint64_t v10 = 0LL;
    }

    if (++v20 == *a3) {
      goto LABEL_27;
    }
  }

  if (*a3)
  {
    uint64_t v72 = "too few numbers.";
    if (v23 == 123 || v23 == 125)
    {
LABEL_24:
      sub_100046D6C((uint64_t)a1, v72, v24, v25, v26, v27, v28, v29, v71);
LABEL_25:
      sub_100046C4C(a1, 0);
      return 0LL;
    }

    int v64 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
    sub_100046D6C((uint64_t)a1, "too few numbers.", v65, v66, v67, v68, v69, v70, v71);
    int v41 = 0LL;
    if (v64 != 59) {
      goto LABEL_25;
    }
  }

  else
  {
LABEL_27:
    int v41 = v73;
    if (v21)
    {
      uint64_t v42 = (char *)sub_10005CDE4((v20 * a6) >> 3);
      int v41 = v42;
      if (!v42) {
        sub_100061FB4("no space for numeric aggregate.", v43, v44, v45, v46, v47, v48, v49, v71);
      }
      uint64_t v50 = -v22;
      *a3 = v20;
      uint64_t v51 = &v42[v20 - v22];
      do
      {
        __int128 v52 = (unsigned __int8 **)v21[1];
        sub_100047FD0(a1, v51, *v21, a5, a6, v47, v48, v49);
        sub_10005CE20( *v21,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  764LL,  v53,  v54,  v55,  v56,  v57);
        sub_10005CE20( v21,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  765LL,  v58,  v59,  v60,  v61,  v62);
        v51 += v50;
        uint64_t v21 = v52;
      }

      while (v52);
    }
  }

  return v41;
}

BOOL sub_1000477EC(int32x2_t *a1, unsigned int *a2)
{
  *a2 = 4;
  return sub_100047540(a1, a2 + 1, a2, 46, 10LL, 8LL) != 0LL;
}

uint64_t sub_100047820( int32x2_t *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (dword_100089B0C != 30)
  {
    uint64_t v17 = "IPv6 addresses are only available in DHCPv6 mode.";
    goto LABEL_23;
  }

  int v10 = sub_1000374AC(&__s, 0LL, a1);
  int v11 = 0;
  while ((v10 & 0xFFFFFFFE) != 0x108)
  {
    if (v10 != 46 && v10 != 263 && v10 != 58) {
      goto LABEL_20;
    }
LABEL_17:
    sub_100036DB0(&__s, 0LL, (uint64_t)a1);
    int v15 = strlen(__s);
    int v16 = v11 + v15;
    memcpy(&v20[v11], __s, v15);
    int v10 = sub_1000374B4(&__s, 0LL, a1);
    int v11 = v16;
  }

  int v12 = *__s;
  if (!*__s) {
    goto LABEL_17;
  }
  uint64_t v13 = __s + 1;
  while ((v12 & 0x80) == 0 && (_DefaultRuneLocale.__runetype[v12] & 0x10000) != 0)
  {
    int v14 = *v13++;
    int v12 = v14;
    if (!v14) {
      goto LABEL_17;
    }
  }

  if (v10 == 46 || v10 == 58 || v10 == 263) {
    goto LABEL_17;
  }
LABEL_20:
  v20[v11] = 0;
  if (inet_pton(30, v20, a2 + 1) > 0)
  {
    *a2 = 16;
    return 1LL;
  }

uint64_t sub_1000479D8( uint64_t *a1, int32x2_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = sub_100047820(a2, &v11, a3, a4, a5, a6, a7, a8);
  if ((_DWORD)result) {
    return sub_1000545BC( a1,  &v12,  v11,  0LL,  1LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  441LL,  v10);
  }
  return result;
}

uint64_t sub_100047A64( int32x2_t *a1, _DWORD *a2, _BYTE *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = sub_100047820(a1, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  if ((_DWORD)result)
  {
    int v12 = sub_100036D00(&v32, 0LL, (uint64_t)a1);
    if (v12 == 47)
    {
      int v19 = sub_100036D00(&v32, 0LL, (uint64_t)a1);
      if (v19 == 263)
      {
        unsigned int v20 = atoi(v32);
        if (v20 < 0x81)
        {
          char v30 = v20;
          if (sub_10003FD5C(a2, v20))
          {
            *a3 = v30;
            return 1LL;
          }

          uint64_t v27 = "network mask too short.";
        }

        else
        {
          uint64_t v27 = "Invalid IPv6 prefix length.";
        }

        sub_100046D6C((uint64_t)a1, v27, v21, v22, v23, v24, v25, v26, v31);
LABEL_14:
        sub_100046C4C(a1, 0);
        return 0LL;
      }

      int v28 = v19;
      uint64_t v29 = "Number expected.";
    }

    else
    {
      int v28 = v12;
      uint64_t v29 = "Slash expected.";
    }

    sub_100046D6C((uint64_t)a1, v29, v13, v14, v15, v16, v17, v18, v31);
    if (v28 == 59) {
      return 0LL;
    }
    goto LABEL_14;
  }

  return result;
}

uint64_t sub_100047B5C(int32x2_t *a1, unsigned int *a2)
{
  *a2 = 4;
  if (!sub_100047540(a1, a2 + 1, a2, 46, 10LL, 8LL))
  {
    uint64_t v21 = "expecting ip-address or ip-address/prefixlen";
LABEL_21:
    sub_100046D6C((uint64_t)a1, v21, v4, v5, v6, v7, v8, v9, v60);
    return 0LL;
  }

  unsigned int v10 = *a2;
  if (sub_1000374AC(&v61, 0LL, a1) != 47)
  {
    int v20 = 8 * v10;
    unsigned int v19 = *a2;
    goto LABEL_9;
  }

  sub_100036D00(&v61, 0LL, (uint64_t)a1);
  if (sub_100036D00(&v61, 0LL, (uint64_t)a1) != 263)
  {
    uint64_t v21 = "Invalid CIDR prefix length: expecting a number.";
    goto LABEL_21;
  }

  unsigned int v12 = atoi(v61);
  unsigned int v19 = *a2;
  int v11 = 8 * *a2;
  if ((v12 & 0x80000000) != 0 || (int v20 = v12, v12 > v11))
  {
    sub_100046D6C((uint64_t)a1, "subnet prefix is out of range [0..%d].", v13, v14, v15, v16, v17, v18, 8 * v19);
    return 0LL;
  }

void *sub_100047D90(int32x2_t *a1, _BYTE *a2)
{
  int v4 = sub_100036D00(&__n[1], 0LL, (uint64_t)a1);
  switch(v4)
  {
    case 261:
      char v5 = 1;
      break;
    case 379:
      char v5 = 8;
      break;
    case 292:
      char v5 = 6;
      break;
    default:
      uint64_t v6 = *(void *)&__n[1];
      if (strncmp(*(const char **)&__n[1], "unknown-", 8uLL))
      {
        uint64_t v13 = "expecting a network hardware type";
LABEL_21:
        sub_100046D6C((uint64_t)a1, v13, v7, v8, v9, v10, v11, v12, v34);
        return (void *)sub_100046C4C(a1, 0);
      }

      char v5 = atoi((const char *)(v6 + 8));
      break;
  }

  a2[1] = v5;
  __n[0] = 0;
  if (sub_1000374AC(&__n[1], 0LL, a1) == 59)
  {
    *a2 = 1;
  }

  else
  {
    uint64_t result = sub_100047540(a1, 0LL, __n, 58, 16LL, 8LL);
    if (!result)
    {
      *a2 = 1;
      return result;
    }

    int v20 = result;
    size_t v21 = __n[0];
    unsigned int v22 = __n[0] + 1;
    if (__n[0] + 1 < 0x12)
    {
      *a2 = v22;
      memcpy(a2 + 2, result, v21);
      if (v22 != 17) {
        bzero(&a2[v22 + 1], 16 - v21);
      }
      sub_10005CE20( v20,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  642LL,  v29,  v30,  v31,  v32,  v33);
    }

    else
    {
      sub_10005CE20( result,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  634LL,  v15,  v16,  v17,  v18,  v19);
      sub_100046D6C((uint64_t)a1, "hardware address too long", v23, v24, v25, v26, v27, v28, v34);
    }
  }

  uint64_t result = (void *)sub_100036D00(&__n[1], 0LL, (uint64_t)a1);
  if ((_DWORD)result != 59)
  {
    uint64_t v13 = "expecting semicolon.";
    goto LABEL_21;
  }

  return result;
}

uint64_t sub_100047F44(int32x2_t *a1, void *a2)
{
  if (sub_100036D00(&v13, 0LL, (uint64_t)a1) == 263)
  {
    sub_100047FD0(a1, &v12, v13, 10LL, 32LL, v7, v8, v9);
    *a2 = bswap32(v12);
    return sub_100046D08(a1);
  }

  else
  {
    sub_100046D6C((uint64_t)a1, "Expecting numeric lease time", v4, v5, v6, v7, v8, v9, v11);
    return sub_100046C4C(a1, 0);
  }

_WORD *sub_100047FD0( _WORD *result, _DWORD *a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a5;
  uint64_t v10 = (uint64_t)result;
  int v11 = *a3;
  if (v11 == 45) {
    unsigned int v12 = a3 + 1;
  }
  else {
    unsigned int v12 = a3;
  }
  uint64_t v13 = v12;
  if ((_DWORD)a4)
  {
    int v14 = a4;
  }

  else if (*v12 == 48)
  {
    uint64_t v13 = v12 + 1;
    int v15 = v12[1];
    if (v15 == 120)
    {
      uint64_t v13 = v12 + 2;
      int v14 = 16;
    }

    else
    {
      BOOL v16 = (v15 & 0x80u) == 0;
      BOOL v17 = (v15 - 48) < 0xA;
      if (v16 && v17) {
        int v14 = 8;
      }
      else {
        int v14 = 10;
      }
      if (!v16 || !v17) {
        uint64_t v13 = v12;
      }
    }
  }

  else
  {
    int v14 = 10;
  }

  unsigned int v18 = 0;
  unsigned int v21 = *v13;
  uint64_t v19 = v13 + 1;
  unsigned int v20 = v21;
  while (1)
  {
    if (v20 > 0x60)
    {
      int v22 = -87;
      goto LABEL_22;
    }

    if (v20 > 0x40)
    {
      int v22 = -55;
      goto LABEL_22;
    }

    if (v20 <= 0x2F) {
      break;
    }
    int v22 = -48;
LABEL_22:
    int v23 = v22 + v20;
    if (v23 >= v14)
    {
      uint64_t result = (_WORD *)sub_100046D6C( (uint64_t)result,  "Bogus number %s: digit %d not in base %d",  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  (char)a3);
      goto LABEL_27;
    }

    unsigned int v18 = v23 + v18 * v14;
    unsigned int v24 = *v19++;
    unsigned int v20 = v24;
    if (!v24) {
      goto LABEL_27;
    }
  }

  uint64_t result = (_WORD *)sub_100046D6C((uint64_t)result, "Bogus number: %s.", (uint64_t)a3, a4, a5, a6, a7, a8, (char)a3);
LABEL_27:
  unsigned int v25 = (2 << (v8 - 1)) - 1;
  if (v11 == 45) {
    unsigned int v25 = 1 << (v8 - 1);
  }
  if (v18 > v25)
  {
    uint64_t v26 = "%s%lu exceeds max (%d) for precision.";
    if (v14 == 16) {
      uint64_t v26 = "%s%lx exceeds max (%d) for precision.";
    }
    if (v14 == 8) {
      uint64_t v27 = "%s%lo exceeds max (%d) for precision.";
    }
    else {
      uint64_t v27 = (char *)v26;
    }
    uint64_t v28 = "-";
    if (v11 != 45) {
      uint64_t v28 = &byte_1000728D2;
    }
    uint64_t result = (_WORD *)sub_100046D6C(v10, v27, (uint64_t)a3, a4, a5, a6, a7, a8, (char)v28);
  }

  if (v11 == 45)
  {
    switch(v8)
    {
      case 32:
        return sub_10005ACE8(a2, -v18);
      case 16:
        return sub_100060B88(a2, -v18);
      case 8:
        *(_BYTE *)a2 = -(char)v18;
        return result;
      default:
        return (_WORD *)sub_100046D6C(v10, "Unexpected integer size: %d\n", (uint64_t)a3, a4, a5, a6, a7, a8, v8);
    }
  }

  else
  {
    switch(v8)
    {
      case 32:
        return sub_100060B6C(a2, v18);
      case 16:
        return sub_100060B78(a2, (unsigned __int16)v18);
      case 8:
        *(_BYTE *)a2 = v18;
        break;
      default:
        return (_WORD *)sub_100046D6C(v10, "Unexpected integer size: %d\n", (uint64_t)a3, a4, a5, a6, a7, a8, v8);
    }
  }

  return result;
}

uint64_t sub_100048258(int32x2_t *a1)
{
  int v2 = sub_1000374AC(&v36, 0LL, a1);
  if (v2 > 414)
  {
    if (v2 == 623)
    {
      sub_100036D00(&v36, 0LL, (uint64_t)a1);
      int v15 = sub_1000374AC(&v36, 0LL, a1);
      if (v15 != 59)
      {
        if (v15 == 263)
        {
          sub_100036D00(&v36, 0LL, (uint64_t)a1);
          return atoi(v36);
        }

        sub_100036D00(&v36, 0LL, (uint64_t)a1);
      }

      uint64_t v13 = "Seconds since epoch expected.";
      goto LABEL_25;
    }

    if (v2 == 415)
    {
      sub_100036D00(&v36, 0LL, (uint64_t)a1);
      return 0x7FFFFFFFLL;
    }

    goto LABEL_19;
  }

  if (v2 == 59)
  {
LABEL_20:
    uint64_t v13 = "numeric day of week expected.";
LABEL_25:
    sub_100046D6C((uint64_t)a1, v13, v3, v4, v5, v6, v7, v8, v35);
    return 0LL;
  }

  if (v2 != 263)
  {
LABEL_19:
    sub_100036D00(&v36, 0LL, (uint64_t)a1);
    goto LABEL_20;
  }

  sub_100036D00(&v36, 0LL, (uint64_t)a1);
  int v9 = sub_1000374AC(&v36, 0LL, a1);
  if (v9 == 59)
  {
LABEL_22:
    uint64_t v13 = "numeric year expected.";
    goto LABEL_25;
  }

  if (v9 != 263)
  {
    sub_100036D00(&v36, 0LL, (uint64_t)a1);
    goto LABEL_22;
  }

  sub_100036D00(&v36, 0LL, (uint64_t)a1);
  int v10 = atoi(v36);
  if (v10 <= 1900) {
    int v11 = v10;
  }
  else {
    int v11 = v10 - 1900;
  }
  int v12 = sub_1000374AC(&v36, 0LL, a1);
  if (v12 != 47)
  {
    if (v12 != 59) {
      sub_100036D00(&v36, 0LL, (uint64_t)a1);
    }
    uint64_t v13 = "expected slash separating year from month.";
    goto LABEL_25;
  }

  sub_100036D00(&v36, 0LL, (uint64_t)a1);
  int v16 = sub_1000374AC(&v36, 0LL, a1);
  if (v16 == 59) {
    goto LABEL_33;
  }
  if (v16 != 263)
  {
    sub_100036D00(&v36, 0LL, (uint64_t)a1);
LABEL_33:
    uint64_t v13 = "numeric month expected.";
    goto LABEL_25;
  }

  sub_100036D00(&v36, 0LL, (uint64_t)a1);
  int v17 = atoi(v36);
  int v18 = sub_1000374AC(&v36, 0LL, a1);
  if (v18 != 47)
  {
    if (v18 != 59) {
      sub_100036D00(&v36, 0LL, (uint64_t)a1);
    }
    uint64_t v13 = "expected slash separating month from day.";
    goto LABEL_25;
  }

  sub_100036D00(&v36, 0LL, (uint64_t)a1);
  int v19 = sub_1000374AC(&v36, 0LL, a1);
  if (v19 == 59) {
    goto LABEL_43;
  }
  if (v19 != 263)
  {
    sub_100036D00(&v36, 0LL, (uint64_t)a1);
LABEL_43:
    uint64_t v13 = "numeric day of month expected.";
    goto LABEL_25;
  }

  sub_100036D00(&v36, 0LL, (uint64_t)a1);
  int v20 = atoi(v36);
  int v21 = sub_1000374AC(&v36, 0LL, a1);
  if (v21 == 59)
  {
LABEL_45:
    uint64_t v13 = "numeric hour expected.";
    goto LABEL_25;
  }

  if (v21 != 263)
  {
    sub_100036D00(&v36, 0LL, (uint64_t)a1);
    goto LABEL_45;
  }

  sub_100036D00(&v36, 0LL, (uint64_t)a1);
  int v22 = atoi(v36);
  int v23 = sub_1000374AC(&v36, 0LL, a1);
  if (v23 != 58)
  {
    if (v23 != 59) {
      sub_100036D00(&v36, 0LL, (uint64_t)a1);
    }
    uint64_t v13 = "expected colon separating hour from minute.";
    goto LABEL_25;
  }

  sub_100036D00(&v36, 0LL, (uint64_t)a1);
  int v24 = sub_1000374AC(&v36, 0LL, a1);
  if (v24 == 59) {
    goto LABEL_53;
  }
  if (v24 != 263)
  {
    sub_100036D00(&v36, 0LL, (uint64_t)a1);
LABEL_53:
    uint64_t v13 = "numeric minute expected.";
    goto LABEL_25;
  }

  sub_100036D00(&v36, 0LL, (uint64_t)a1);
  int v25 = atoi(v36);
  int v26 = sub_1000374AC(&v36, 0LL, a1);
  if (v26 != 58)
  {
    if (v26 != 59) {
      sub_100036D00(&v36, 0LL, (uint64_t)a1);
    }
    uint64_t v13 = "expected colon separating minute from second.";
    goto LABEL_25;
  }

  sub_100036D00(&v36, 0LL, (uint64_t)a1);
  int v27 = sub_1000374AC(&v36, 0LL, a1);
  if (v27 == 59) {
    goto LABEL_60;
  }
  if (v27 != 263)
  {
    sub_100036D00(&v36, 0LL, (uint64_t)a1);
LABEL_60:
    uint64_t v13 = "numeric second expected.";
    goto LABEL_25;
  }

  sub_100036D00(&v36, 0LL, (uint64_t)a1);
  int v28 = atoi(v36);
  int v29 = sub_1000374AC(&v36, 0LL, a1);
  if (v29 == 59)
  {
    int v30 = 0;
    goto LABEL_62;
  }

  if (v29 != 263)
  {
    sub_100036D00(&v36, 0LL, (uint64_t)a1);
    uint64_t v13 = "Time zone offset or semicolon expected.";
    goto LABEL_25;
  }

  sub_100036D00(&v36, 0LL, (uint64_t)a1);
  int v30 = atoi(v36);
LABEL_62:
  int v31 = v11 - 66;
  if (v11 >= 69) {
    int v31 = v11 - 69;
  }
  int v32 = 365 * v11 + (v31 >> 2) - 25550;
  if (v17 == 1) {
    int v33 = 0;
  }
  else {
    int v33 = dword_100082AA8[v17 - 2];
  }
  if ((v11 & 3) == 0 && v17 > 2) {
    ++v32;
  }
  return v30 + v28 + 60 * (v25 + 60 * (v22 + 24 * (v32 + v20 + v33)) - 1440);
}

uint64_t sub_1000487A0(int32x2_t *a1)
{
  uint64_t v2 = sub_100048258(a1);
  else {
    return 0LL;
  }
}

uint64_t sub_1000487D4(int32x2_t *a1, int a2, _DWORD *a3, void *a4)
{
  if (!a4) {
    return 39LL;
  }
  unsigned int v8 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
  unsigned int v15 = v8;
  if (v8 < 0x100)
  {
    sub_100046D6C((uint64_t)a1, "expecting identifier after option keyword.", v9, v10, v11, v12, v13, v14, v78);
    if (v15 == 59) {
      return 45LL;
    }
LABEL_9:
    sub_100046C4C(a1, 0);
    return 45LL;
  }

  if (v8 - 262 < 2 || v8 == 607)
  {
    int v16 = "expecting identifier after option keyword.";
LABEL_6:
    sub_100046D6C((uint64_t)a1, v16, v9, v10, v11, v12, v13, v14, v78);
    goto LABEL_9;
  }

  int v18 = strlen(__s);
  int v19 = (char *)sub_10005CDE4((v18 + 1));
  int v27 = v19;
  if (!v19) {
    sub_100061FB4("no memory for uname information.", v20, v21, v22, v23, v24, v25, v26, v78);
  }
  strcpy(v19, __s);
  if (sub_1000374AC(&__s, 0LL, a1) == 46)
  {
    sub_100036D00(&__s, 0LL, (uint64_t)a1);
    unsigned int v28 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
    unsigned int v29 = v28;
    if (v28 < 0x100)
    {
      sub_100046D6C((uint64_t)a1, "expecting identifier after '.'", v9, v10, v11, v12, v13, v14, v78);
      if (v29 == 59) {
        return 45LL;
      }
      goto LABEL_9;
    }

    if (v28 - 262 < 2 || v28 == 607)
    {
      int v16 = "expecting identifier after '.'";
      goto LABEL_6;
    }

    uint64_t v80 = 0LL;
    if (!sub_100029804( &v80,  qword_10008C560,  v27,  0LL,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  1178LL))
    {
      sub_100046D6C((uint64_t)a1, "no option space named %s.", v61, v62, v63, v64, v65, v66, (char)v27);
      sub_100046C4C(a1, 0);
      return 23LL;
    }

    int v30 = v80;
    int v31 = __s;
  }

  else
  {
    __s = v27;
    int v30 = &qword_10008C168;
    uint64_t v80 = &qword_10008C168;
    int v31 = v27;
  }

  sub_100029804(a4, v30[14], v31, 0LL, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c", 1191LL);
  if (*a4)
  {
    if (a3) {
      *a3 = 1;
    }
    goto LABEL_28;
  }

  uint64_t v37 = __s;
  if (strncasecmp(__s, "unknown-", 8uLL))
  {
    if (a2)
    {
      uint64_t v44 = sub_1000342D8(v37);
      v44[2] = v80;
      uint64_t v45 = a4;
      goto LABEL_27;
    }

    sub_100046D6C((uint64_t)a1, "no option named %s in space %s", v38, v39, v40, v41, v42, v43, (char)v37);
    sub_100046C4C(a1, 0);
    sub_10005CE20( v27,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  1259LL,  v67,  v68,  v69,  v70,  v71);
    return 23LL;
  }

  int v46 = atoi(v37 + 8);
  int v79 = v46;
  uint64_t v53 = v80;
  if (v46)
  {
    if (v46 != *((_DWORD *)v80 + 27))
    {
      if (a3) {
        *a3 = 1;
      }
      sub_100029804(a4, v53[15], &v79, 0LL, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c", 1227LL);
      if (*a4)
      {
        sub_1000622D4( "option %s has been redefined as option %s.  Please update your configs if neccessary.",  v54,  v55,  v56,  v57,  v58,  v59,  v60,  (char)__s);
        goto LABEL_28;
      }

      uint64_t v44 = sub_1000342D8(__s);
      uint64_t v77 = v80;
      *((_DWORD *)v44 + 6) = v79;
      v44[1] = off_10008A658[0];
      v44[2] = v77;
      uint64_t v45 = a4;
LABEL_27:
      sub_100052CB0(v45, (uint64_t)v44);
LABEL_28:
      sub_10005CE20( v27,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  1264LL,  v32,  v33,  v34,  v35,  v36);
      return 0LL;
    }
  }

  else
  {
    LOBYTE(v46) = *((_DWORD *)v80 + 27);
  }

  sub_100046D6C((uint64_t)a1, "Option codes 0 and %u are illegal in the %s space.", v47, v48, v49, v50, v51, v52, v46);
  sub_100046C4C(a1, 0);
  sub_10005CE20( v27,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  1215LL,  v72,  v73,  v74,  v75,  v76);
  return 25LL;
}

void sub_100048B98(int32x2_t *a1)
{
  int v2 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
  if (v2 < 256 || (v2 - 262) < 2 || v2 == 607)
  {
    sub_100046D6C((uint64_t)a1, "expecting identifier.", v3, v4, v5, v6, v7, v8, v80);
    sub_100046C4C(a1, 0);
    return;
  }

  int v16 = (const char **)sub_100034340();
  if (!v16) {
    sub_100061FB4("No memory for new option space.", v9, v10, v11, v12, v13, v14, v15, v80);
  }
  int v17 = strlen(__s);
  int v18 = (char *)sub_10005CDE4((v17 + 1));
  uint64_t v26 = v18;
  if (!v18) {
    sub_100061FB4("No memory for new option space name.", v19, v20, v21, v22, v23, v24, v25, v80);
  }
  strcpy(v18, __s);
  int v27 = 0;
  *int v16 = v26;
  int v28 = 1;
  int v29 = 1;
  do
  {
    int v30 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
    int v38 = v30;
    if (v30 <= 619)
    {
      if (v30 != 388)
      {
        if (v30 == 59) {
          break;
        }
LABEL_31:
        sub_100046D6C((uint64_t)a1, "Unexpected token.", v32, v33, v34, v35, v36, v37, v80);
        continue;
      }

      if (sub_100036D00(&__s, 0LL, (uint64_t)a1) != 263)
      {
        uint64_t v45 = "expecting number 1, 2, 4.";
LABEL_71:
        sub_100046D6C((uint64_t)a1, v45, v32, v33, v34, v35, v36, v37, v80);
        goto LABEL_72;
      }

      int v40 = atoi(__s);
      switch(v40)
      {
        case 4:
          if (!v27) {
            int v27 = 20479;
          }
          int v28 = 4;
          break;
        case 2:
          if (!v27) {
            int v27 = 20479;
          }
          int v28 = 2;
          break;
        case 1:
          if (!v27) {
            int v27 = 401;
          }
          int v28 = 1;
          break;
        default:
          char v80 = v40;
          uint64_t v45 = "invalid code width (%d), expecting a 1, 2 or 4.";
          goto LABEL_71;
      }
    }

    else if (v30 == 620)
    {
      if (sub_100036D00(&__s, 0LL, (uint64_t)a1) != 619)
      {
LABEL_46:
        uint64_t v45 = "expecting width token.";
        goto LABEL_71;
      }

      if (sub_100036D00(&__s, 0LL, (uint64_t)a1) != 263)
      {
        uint64_t v45 = "expecting number 1 or 2.";
        goto LABEL_71;
      }

      int v41 = atoi(__s);
      int v29 = v41;
      if ((v41 - 3) <= 0xFFFFFFFD)
      {
        sub_100046D6C((uint64_t)a1, "invalid length width (%d) expecting 1 or 2.", v32, v33, v34, v35, v36, v37, v41);
        goto LABEL_72;
      }
    }

    else
    {
      if (v30 != 621) {
        goto LABEL_31;
      }
      if (sub_100036D00(&__s, 0LL, (uint64_t)a1) != 622)
      {
        uint64_t v45 = "expecting size token.";
        goto LABEL_71;
      }

      if (sub_100036D00(&__s, 0LL, (uint64_t)a1) != 263)
      {
        uint64_t v45 = "expecting a 10base number";
        goto LABEL_71;
      }

      int v39 = atoi(__s);
      int v27 = v39;
      if (v39 < 0)
      {
        sub_100046D6C((uint64_t)a1, "invalid hash length: %d", v32, v33, v34, v35, v36, v37, v39);
LABEL_72:
        sub_10005CE20( v26,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  1459LL,  v70,  v71,  v72,  v73,  v74);
        sub_10005CE20( v16,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  1460LL,  v75,  v76,  v77,  v78,  v79);
        return;
      }
    }

    int v38 = 263;
  }

  while (v38 != 59);
  if (v27) {
    unsigned int v42 = v27;
  }
  else {
    unsigned int v42 = 11;
  }
  v16[1] = (const char *)sub_100043E64;
  v16[2] = (const char *)sub_10004447C;
  v16[3] = (const char *)sub_100045A5C;
  v16[4] = (const char *)sub_10004467C;
  void v16[6] = (const char *)sub_100040920;
  v16[7] = (const char *)sub_100044B30;
  v16[5] = (const char *)sub_100044750;
  *((_DWORD *)v16 + 24) = v28;
  *((_DWORD *)v16 + 25) = v29;
  if (v28 == 4)
  {
    uint64_t v43 = (const char *)sub_100060B50;
    uint64_t v44 = (const char *)sub_100060B6C;
  }

  else if (v28 == 2)
  {
    uint64_t v43 = (const char *)sub_100060B5C;
    uint64_t v44 = (const char *)sub_100060B78;
  }

  else
  {
    uint64_t v43 = (const char *)sub_100060BA0;
    uint64_t v44 = (const char *)sub_100060B98;
  }

  v16[8] = v43;
  v16[9] = v44;
  if (v29 == 2)
  {
    int v46 = (const char *)sub_100060B5C;
    uint64_t v47 = (const char *)sub_100060B78;
LABEL_55:
    v16[10] = v46;
    v16[11] = v47;
    goto LABEL_57;
  }

  if (v29 == 1)
  {
    int v46 = (const char *)sub_100060BA0;
    uint64_t v47 = (const char *)sub_100060B98;
    goto LABEL_55;
  }

  if (v29) {
    sub_100061FB4( "Impossible condition at %s:%d.",  v31,  v32,  v33,  v34,  v35,  v36,  v37,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c");
  }
  v16[10] = 0LL;
  v16[11] = 0LL;
LABEL_57:
  int v48 = dword_10008C558++;
  *((_DWORD *)v16 + 34) = v48;
  if (v48 >= dword_10008C568)
  {
    uint64_t v50 = sub_10005CDE4((16 * dword_10008C568));
    uint64_t v49 = (uint64_t)v50;
    if (!v50) {
      sub_100061FB4("No memory to expand option space array.", v51, v52, v53, v54, v55, v56, v57, v80);
    }
    memcpy(v50, (const void *)qword_10008C570, 8LL * dword_10008C568);
    dword_10008C568 *= 2;
    sub_10005CE20( (void *)qword_10008C570,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  1448LL,  v58,  v59,  v60,  v61,  v62);
    qword_10008C570 = v49;
    int v48 = *((_DWORD *)v16 + 34);
  }

  else
  {
    uint64_t v49 = qword_10008C570;
  }

  *(void *)(v49 + 8LL * v48) = v16;
  if (!sub_100052C88( (uint64_t *)v16 + 14,  v42,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  1452LL,  v34,  v35,  v36,  v37)
    || !sub_100052DA4( (uint64_t *)v16 + 15,  v42,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  1453LL,  v66,  v67,  v68,  v69))
  {
    sub_100061FB4("Can't allocate %s option hash table.", v63, v64, v65, v66, v67, v68, v69, (char)*v16);
  }

  sub_100029214( qword_10008C560,  *v16,  0LL,  (uint64_t)v16,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  1455LL,  v68,  v69,  v80);
}

uint64_t sub_100049110(int32x2_t *a1, uint64_t a2)
{
  if (sub_100036D00(&__s, 0LL, (uint64_t)a1) != 263)
  {
    uint64_t v14 = "expecting option code number.";
    goto LABEL_73;
  }

  *(_DWORD *)(a2 + 24) = atoi(__s);
  uint64_t v10 = (const char *)(a2 + 24);
  if (sub_100036D00(&__s, 0LL, (uint64_t)a1) != 61)
  {
    uint64_t v14 = "expecting =";
    goto LABEL_73;
  }

  int v11 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
  if (v11 == 389)
  {
    if (sub_100036D00(&__s, 0LL, (uint64_t)a1) != 360)
    {
LABEL_71:
      uint64_t v14 = "expecting of.";
      goto LABEL_73;
    }

    int v12 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
    unsigned int v13 = 1;
  }

  else
  {
    int v12 = v11;
    unsigned int v13 = 0;
  }

  uint64_t v92 = a2;
  if (v12 == 123)
  {
    int v15 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
    int v16 = 1;
  }

  else
  {
    int v16 = 0;
    int v15 = v12;
  }

  unsigned int v17 = 0;
  int v18 = 0;
  unsigned int v93 = v16;
  unsigned int v19 = v16 + 1;
  while (1)
  {
    while (1)
    {
      if (v18)
      {
        uint64_t v14 = "encapsulate must always be the last item.";
        goto LABEL_73;
      }

      if (v15 != 389) {
        break;
      }
      if (v13)
      {
        uint64_t v49 = "no nested arrays.";
        goto LABEL_119;
      }

      int v15 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
      int v18 = 0;
      unsigned int v13 = v19;
      if (v12 == 123)
      {
        unsigned int v13 = v19;
        if (v15 == 123)
        {
          sub_100046D6C((uint64_t)a1, "only uniform array inside record.", v4, v5, v6, v7, v8, v9, v90);
          uint64_t v50 = a1;
          unsigned int v51 = v19;
          goto LABEL_112;
        }
      }
    }

    if (v15 <= 590)
    {
      switch(v15)
      {
        case 390:
          int v18 = 0;
          int v20 = 102;
          goto LABEL_58;
        case 391:
          int v22 = 1;
          goto LABEL_36;
        case 392:
          int v22 = 1;
          goto LABEL_35;
        case 393:
          int v22 = 0;
LABEL_35:
          if (sub_100036D00(&__s, 0LL, (uint64_t)a1) == 391)
          {
LABEL_36:
            if (sub_100036D00(&__s, 0LL, (uint64_t)a1) == 263)
            {
              char v23 = (char)__s;
              int v24 = atoi(__s);
              switch(v24)
              {
                case 32:
                  int v18 = 0;
                  BOOL v25 = v22 == 0;
                  int v26 = 108;
                  int v27 = 76;
                  break;
                case 16:
                  int v18 = 0;
                  BOOL v25 = v22 == 0;
                  int v26 = 115;
                  int v27 = 83;
                  break;
                case 8:
                  int v18 = 0;
                  BOOL v25 = v22 == 0;
                  int v26 = 98;
                  int v27 = 66;
                  break;
                default:
                  char v90 = v23;
                  uint64_t v49 = "%s bit precision is not supported.";
                  goto LABEL_119;
              }

              if (v25) {
                int v20 = v27;
              }
              else {
                int v20 = v26;
              }
              goto LABEL_58;
            }

            uint64_t v49 = "expecting number.";
          }

          else
          {
            uint64_t v49 = "expecting integer keyword.";
          }

          break;
        case 394:
          int v18 = 0;
          int v20 = 73;
          goto LABEL_58;
        case 395:
          int v20 = 116;
          goto LABEL_60;
        case 396:
          int v20 = 88;
          goto LABEL_60;
        default:
          goto LABEL_76;
      }

LABEL_119:
      sub_100046D6C((uint64_t)a1, v49, v4, v5, v6, v7, v8, v9, v90);
LABEL_120:
      sub_100046C4C(a1, v93);
      if (v12 != 123) {
        return 0LL;
      }
      goto LABEL_74;
    }

    if (v15 > 629)
    {
      if (v15 != 630)
      {
        if (v15 == 633)
        {
          int v18 = 0;
          int v20 = 54;
LABEL_58:
          char v21 = 1;
          goto LABEL_62;
        }

        if (v15 != 655) {
          goto LABEL_76;
        }
        if (!v13)
        {
          char v21 = 0;
          int v18 = 0;
          int v20 = 90;
          goto LABEL_62;
        }

        uint64_t v49 = "array incompatible with zerolen.";
        goto LABEL_119;
      }

      if (sub_1000374AC(&__s, 0LL, a1) == 635)
      {
        sub_100036D00(&__s, 0LL, (uint64_t)a1);
        __src[v17++] = 68;
        int v20 = 99;
      }

      else
      {
        int v20 = 68;
      }

      goto LABEL_60;
    }

    if (v15 == 591)
    {
      unsigned int v28 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
      if (v28 >= 0x100 && v28 - 262 >= 2 && v28 != 607)
      {
        uint64_t v94 = 0LL;
        size_t v29 = strlen(__s);
        int v30 = sub_100029804( &v94,  qword_10008C560,  __s,  v29,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  1677LL);
        uint64_t v37 = __s;
        if (!v30)
        {
          sub_100046D6C((uint64_t)a1, "unknown option space %s", v31, v32, v33, v34, v35, v36, (char)__s);
          goto LABEL_74;
        }

        if (strlen(__s) + v17 - 127 < 0xFFFFFFFFFFFFFF7FLL) {
          goto LABEL_80;
        }
        uint64_t v38 = v17;
        uint64_t v39 = v17 + 1;
        __src[v38] = 69;
        strcpy(&__src[v39], v37);
        unsigned int v17 = v39 + strlen(__s);
        char v21 = 1;
        int v20 = 46;
        int v18 = 1;
        goto LABEL_62;
      }

      uint64_t v14 = "expecting option space identifier";
LABEL_73:
      sub_100046D6C((uint64_t)a1, v14, v4, v5, v6, v7, v8, v9, v90);
      goto LABEL_74;
    }

    if (v15 != 613)
    {
LABEL_76:
      sub_100046D6C((uint64_t)a1, "unknown data type %s", v4, v5, v6, v7, v8, v9, (char)__s);
      goto LABEL_120;
    }

    int v20 = 100;
LABEL_60:
    if (v13)
    {
      sub_100046D6C((uint64_t)a1, "arrays of text strings not %s", v4, v5, v6, v7, v8, v9, (char)"yet supported.");
      goto LABEL_120;
    }

    char v21 = 0;
    int v18 = 0;
LABEL_62:
    if (v17 == 128)
    {
LABEL_80:
      uint64_t v49 = "too many types in record.";
      goto LABEL_119;
    }

    unsigned int v40 = v17 + 1;
    __src[v17] = v20;
    if (v12 != 123) {
      break;
    }
    int v41 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
    if (v13 < 2)
    {
      ++v17;
    }

    else
    {
      if (v17 == 127)
      {
        uint64_t v52 = "too many types in record.";
LABEL_110:
        sub_100046D6C((uint64_t)a1, v52, v42, v43, v44, v45, v46, v47, v90);
        goto LABEL_111;
      }

      unsigned int v13 = 0;
      v17 += 2;
      __src[v40] = 97;
    }

    if (v41 != 44)
    {
      if (v41 == 125) {
        goto LABEL_82;
      }
      uint64_t v52 = "expecting right brace.";
      goto LABEL_110;
    }

    if ((v21 & 1) == 0)
    {
      uint64_t v60 = "string";
      if (v20 == 116) {
        uint64_t v60 = "text";
      }
      sub_100046D6C((uint64_t)a1, "%s must be at end of record.", v42, v43, v44, v45, v46, v47, (char)v60);
LABEL_111:
      uint64_t v50 = a1;
      unsigned int v51 = 1;
LABEL_112:
      sub_100046C4C(v50, v51);
      goto LABEL_74;
    }

    int v15 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
  }

  ++v17;
LABEL_82:
  if (!sub_100046D08(a1))
  {
    sub_100046D6C((uint64_t)a1, "semicolon expected.", v53, v54, v55, v56, v57, v58, v90);
    sub_100046C4C(a1, 0);
    uint64_t result = 0LL;
    if (v12 != 123) {
      return result;
    }
LABEL_74:
    sub_100046C4C(a1, 0);
    return 0LL;
  }

  if (v13) {
    int v59 = v18;
  }
  else {
    int v59 = 0;
  }
  if (v59 == 1)
  {
    sub_100046D6C((uint64_t)a1, "Arrays of encapsulations don't make sense.", v53, v54, v55, v56, v57, v58, v90);
    return 0LL;
  }

  if (v13) {
    size_t v61 = v17 + 2;
  }
  else {
    size_t v61 = v17 + 1;
  }
  uint64_t v62 = sub_10005CDE4(v61);
  uint64_t v70 = v62;
  if (!v62) {
    sub_100061FB4("no memory for option format.", v63, v64, v65, v66, v67, v68, v69, v90);
  }
  uint64_t v71 = v17;
  memcpy(v62, __src, v17);
  if (v13)
  {
    if (v13 <= v93) {
      char v72 = 65;
    }
    else {
      char v72 = 97;
    }
    v70[v17] = v72;
    uint64_t v71 = v17 + 1;
  }

  v70[v71] = 0;
  *(void *)(v92 + 8) = v70;
  uint64_t v95 = 0LL;
  sub_100029804( &v95,  *(void *)(*(void *)(v92 + 16) + 120LL),  v10,  0LL,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  1781LL);
  if (v95)
  {
    sub_100029210( *(void *)(*(void *)(v92 + 16) + 120LL),  (const char *)(v95 + 24),  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  1795LL,  v73,  v74,  v75);
    sub_100052CE4( &v95,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  1797LL,  v76,  v77,  v78,  v79,  v80);
  }

  sub_100029214( *(void *)(*(void *)(v92 + 16) + 120LL),  v10,  0LL,  v92,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  1800LL,  v74,  v75,  v90);
  sub_100029214( *(void *)(*(void *)(v92 + 16) + 112LL),  *(const char **)v92,  0LL,  v92,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  1802LL,  v81,  v82,  v91);
  if (v18
    && !sub_100029804( v94 + 128,  *(void *)(*(void *)(v92 + 16) + 120LL),  v10,  0LL,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  1808LL))
  {
    sub_100061FB4( "error finding encapsulated option (%s:%d)",  v83,  v84,  v85,  v86,  v87,  v88,  v89,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c");
  }

  return 1LL;
}

BOOL sub_1000498C0(uint64_t a1, int32x2_t *a2)
{
  uint64_t v3 = 0LL;
  uint64_t v4 = 0LL;
  int v5 = 0;
  while (1)
  {
    sub_100036D00(&__src, &v47, (uint64_t)a2);
    uint64_t v6 = sub_10005CDE4((v47 + 16));
    uint64_t v14 = v6;
    if (!v6) {
      sub_100061FB4("no memory for base64 buffer.", v7, v8, v9, v10, v11, v12, v13, v45);
    }
    *uint64_t v6 = 0LL;
    *(void *)((char *)v6 + 7) = 0LL;
    int v15 = v47;
    memcpy(v6 + 1, __src, (v47 + 1));
    int v16 = v14;
    if (v4)
    {
      *uint64_t v4 = v14;
      int v16 = v3;
    }

    v5 += v15;
    unsigned int v17 = sub_1000374AC(&__src, 0LL, a2);
    uint64_t v3 = v16;
    uint64_t v4 = v14;
    if (v17 - 262 >= 4)
    {
      if (v17 > 0x3D) {
        break;
      }
      uint64_t v3 = v16;
      uint64_t v4 = v14;
      if (((1LL << v17) & 0x2000880000000000LL) == 0) {
        break;
      }
    }
  }

  unsigned int v18 = (3 * v5) >> 2;
  *(_DWORD *)(a1 + 16) = v18;
  if (!sub_1000345C4( (void *)a1,  v18,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  1872LL))
  {
    sub_100046D6C((uint64_t)a2, "can't allocate buffer for base64 data.", v19, v20, v21, v22, v23, v24, v45);
    BOOL result = 0LL;
    *(_DWORD *)(a1 + 16) = 0;
    *(void *)(a1 + 8) = 0LL;
    return result;
  }

  if (v16)
  {
    int v25 = 0;
    unsigned int v26 = 0;
    int v27 = 0;
    int v28 = 0;
    size_t v29 = v16;
    while (1)
    {
      int v30 = *((unsigned __int8 *)v29 + 8);
      if (*((_BYTE *)v29 + 8)) {
        break;
      }
LABEL_34:
      size_t v29 = (void *)*v29;
      if (!v29)
      {
        if ((v27 & 3) != 0 && v26) {
          sub_100046D6C((uint64_t)a2, "partial base64 value left over: %d.", v19, v20, v21, v22, v23, v24, v26);
        }
        goto LABEL_40;
      }
    }

    if (v25 && v30 != 61)
    {
      LOBYTE(sub_1000622D4("All rights reserved.", v16, v17, v18, v19, v20, v21, v22, v31) = (_BYTE)v29 + 8;
LABEL_44:
      sub_100046D6C((uint64_t)a2, "stuff after base64 '=' terminator: %s.", v19, v20, v21, v22, v23, v24, (char)v31);
    }

    else
    {
      uint64_t v31 = v29 + 1;
      while (1)
      {
        char v32 = v30;
        if ((char)v30 == 61)
        {
          int v25 = 1;
        }

        else
        {
          int v33 = a456789[(char)v30 - 32];
          if (v33 == 64) {
            break;
          }
          unsigned int v26 = v33 + (v26 << 6);
          if (v27 <= 0) {
            int v34 = -(-v27 & 3);
          }
          else {
            int v34 = v27 & 3;
          }
          switch(v34)
          {
            case 3:
              uint64_t v36 = *(void *)a1 + v28++;
              *(_BYTE *)(v36 + 4) = v26;
              unsigned int v26 = 0;
              break;
            case 2:
              uint64_t v37 = *(void *)a1 + v28++;
              *(_BYTE *)(v37 + 4) = v26 >> 2;
              unsigned int v26 = v33 & 3;
              break;
            case 1:
              uint64_t v35 = *(void *)a1 + v28++;
              *(_BYTE *)(v35 + 4) = v26 >> 4;
              unsigned int v26 = v33 & 0xF;
              break;
          }
        }

        int v30 = *((unsigned __int8 *)v31 + 1);
        if (!*((_BYTE *)v31 + 1))
        {
          ++v27;
          goto LABEL_34;
        }

        uint64_t v31 = (void *)((char *)v31 + 1);
        ++v27;
        if (v25 && v30 != 61) {
          goto LABEL_44;
        }
      }

      sub_100046D6C((uint64_t)a2, "invalid base64 character %d.", v19, v20, v21, v22, v23, v24, v32);
    }

    sub_100034EA8( (_DWORD **)a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  1895LL,  v39,  v40,  v41,  v42,  v43);
  }

  else
  {
    int v28 = 0;
LABEL_40:
    *(_DWORD *)(a1 + 16) = v28;
    *(void *)(a1 + 8) = *(void *)a1 + 4LL;
    if (!v16) {
      return *(_DWORD *)(a1 + 16) != 0;
    }
  }

  do
  {
    uint64_t v44 = (void *)*v16;
    sub_10005CE20( v16,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  1938LL,  v20,  v21,  v22,  v23,  v24);
    int v16 = v44;
  }

  while (v44);
  return *(_DWORD *)(a1 + 16) != 0;
}

uint64_t sub_100049BDC(uint64_t a1, int32x2_t *a2)
{
  uint64_t v52 = 0LL;
  uint64_t v10 = 0LL;
  if (sub_100036D00(&v51, 0LL, (uint64_t)a2) - 265 < 0xFFFFFFFE)
  {
LABEL_10:
    sub_100046D6C((uint64_t)a2, "expecting hexadecimal number.", v4, v5, v6, v7, v8, v9, v50);
    sub_100046C4C(a2, 0);
    if (v10)
    {
      do
      {
        char v32 = (void *)*v10;
        sub_10005CE20( v10,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  1972LL,  v27,  v28,  v29,  v30,  v31);
        uint64_t v10 = v32;
      }

      while (v32);
    }

    return 0LL;
  }

  else
  {
    int v11 = 0;
    unsigned int v12 = 0;
    uint64_t v13 = &v52;
    while (1)
    {
      if (v12 == 128)
      {
        uint64_t v14 = (char *)sub_10005CDE4(0x8FuLL);
        if (!v14) {
          sub_100061FB4("no memory for string list.", v15, v16, v17, v18, v7, v8, v9, v50);
        }
        unsigned int v12 = 0;
        __int128 v19 = __src[0];
        __int128 v20 = __src[1];
        __int128 v21 = __src[2];
        *(_OWORD *)(v14 + 56) = __src[3];
        *(_OWORD *)(v14 + 4__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = v21;
        *(_OWORD *)(v14 + 24) = v20;
        *(_OWORD *)(v14 + 8) = v19;
        __int128 v22 = __src[4];
        __int128 v23 = __src[5];
        __int128 v24 = __src[6];
        *(_OWORD *)(v14 + 12__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = __src[7];
        *(_OWORD *)(v14 + 104) = v24;
        *(_OWORD *)(v14 + 88) = v23;
        *(_OWORD *)(v14 + 72) = v22;
        *uint64_t v13 = v14;
        v11 += 128;
        uint64_t v13 = v14;
      }

      size_t v25 = v12 + 1;
      sub_100047FD0(a2, (_OWORD *)((char *)__src + v12), v51, 16LL, 8LL, v7, v8, v9);
      sub_100036D00(&v51, 0LL, (uint64_t)a2);
      int v26 = sub_100036D00(&v51, 0LL, (uint64_t)a2);
      unsigned int v12 = v25;
      if ((v26 - 265) < 0xFFFFFFFE)
      {
        uint64_t v10 = v52;
        goto LABEL_10;
      }
    }

    if (!sub_1000345C4( (void *)a1,  v11 + (int)v25,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  1996LL)) {
      sub_100061FB4("no memory to store octet data.", v34, v35, v36, v37, v38, v39, v40, v50);
    }
    uint64_t v41 = (_OWORD *)(*(void *)a1 + 4LL);
    *(void *)(a1 + 8) = v41;
    *(_DWORD *)(a1 + 16) = v11 + v25;
    *(_DWORD *)(a1 + 2__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = 0;
    uint64_t v42 = (char *)v52;
    if (v52)
    {
      do
      {
        uint64_t v43 = *(char **)v42;
        __int128 v44 = *(_OWORD *)(v42 + 8);
        __int128 v45 = *(_OWORD *)(v42 + 24);
        __int128 v46 = *(_OWORD *)(v42 + 56);
        v41[2] = *(_OWORD *)(v42 + 40);
        v41[3] = v46;
        *uint64_t v41 = v44;
        v41[1] = v45;
        __int128 v47 = *(_OWORD *)(v42 + 72);
        __int128 v48 = *(_OWORD *)(v42 + 88);
        __int128 v49 = *(_OWORD *)(v42 + 120);
        v41[6] = *(_OWORD *)(v42 + 104);
        v41[7] = v49;
        v41[4] = v47;
        v41[5] = v48;
        v41 += 8;
        sub_10005CE20( v42,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  2007LL,  v36,  v37,  v38,  v39,  v40);
        uint64_t v42 = v43;
      }

      while (v43);
    }

    memcpy(v41, __src, v25);
    return 1LL;
  }

BOOL sub_100049E64(void **a1, int32x2_t *a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v5 = a3;
  uint64_t v6 = a2;
  uint64_t v7 = a1;
  while (sub_100049EC4(a1, a2, a3, a4))
  {
    uint64_t v7 = (void **)((char *)*v7 + 8);
    a1 = v7;
    a2 = v6;
    a3 = v5;
    a4 = v4;
  }

  return *v5 == 0;
}

uint64_t sub_100049EC4(void **a1, int32x2_t *a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v320 = 0LL;
  int v8 = sub_1000374AC(&__s, 0LL, a2);
  int v15 = v8;
  if (v8 <= 434)
  {
    if (v8 > 325)
    {
      if (v8 <= 341)
      {
        switch(v8)
        {
          case 326:
            sub_100036D00(&__s, 0LL, (uint64_t)a2);
            LODWORD(v321) = 0;
            if (!sub_1000487D4(a2, 0, &v321, &v320) && v320)
            {
              a4 = sub_10004B414(a1, a2, 1LL, v320, 7);
              uint64_t v107 = 2223LL;
              goto LABEL_144;
            }

            goto LABEL_190;
          case 327:
            sub_100036D00(&__s, 0LL, (uint64_t)a2);
            LODWORD(v321) = 0;
            if (!sub_1000487D4(a2, 0, &v321, &v320) && v320)
            {
              a4 = sub_10004B414(a1, a2, 1LL, v320, 8);
              uint64_t v107 = 2210LL;
              goto LABEL_144;
            }

            goto LABEL_190;
          case 341:
            sub_100036D00(&__s, 0LL, (uint64_t)a2);
            return sub_10004AFE4(a1, a2, a3);
        }

LABEL_190:
          a4 = 0LL;
          goto LABEL_191;
        }

        uint64_t v216 = "expecting class name.";
LABEL_188:
        sub_100046D6C((uint64_t)a2, v216, v9, v10, v11, v12, v13, v14, v319);
        goto LABEL_189;
      }

      if (v8 != 384)
      {
        if (v8 == 408)
        {
          sub_100036D00(&__s, 0LL, (uint64_t)a2);
          return sub_10004B594(a1, a2, a3);
        }

        goto LABEL_68;
      }

      char v79 = 2;
      goto LABEL_119;
    }

    if (v8 > 311)
    {
      if (v8 == 312)
      {
        char v79 = 0;
LABEL_119:
        sub_100036D00(&__s, 0LL, (uint64_t)a2);
        uint64_t v321 = 0LL;
        if (sub_10000C3A8(&v321, a2, v79, v230, v231, v232, v233, v234))
        {
          if (!sub_100034984( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  2178LL)) {
            sub_100061FB4("no memory for new statement.", v235, v236, v237, v238, v239, v240, v241, v319);
          }
          uint64_t v242 = *a1;
          int v243 = 6;
          goto LABEL_123;
        }

        return 0LL;
      }

      if (v8 == 314)
      {
        sub_100036D00(&__s, 0LL, (uint64_t)a2);
        if (sub_1000374AC(&__s, 0LL, a2) == 58)
        {
          sub_100036D00(&__s, 0LL, (uint64_t)a2);
          if ((_DWORD)a4)
          {
            if (!sub_100034984( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  2255LL)) {
              sub_100061FB4("no memory for default statement.", v223, v224, v225, v226, v227, v228, v229, v319);
            }
            __int128 v23 = *a1;
            int v24 = 14;
            goto LABEL_116;
          }

          sub_100046D6C( (uint64_t)a2,  "switch default statement in %s",  v217,  v218,  v219,  v220,  v221,  v222,  (char)"inappropriate scope.");
LABEL_191:
          *a3 = 1;
          return a4;
        }

        LODWORD(v321) = 0;
        if (!sub_1000487D4(a2, 0, &v321, &v320) && v320)
        {
          a4 = sub_10004B414(a1, a2, 1LL, v320, 5);
          uint64_t v107 = 2197LL;
          goto LABEL_144;
        }

        goto LABEL_190;
      }

      if (v8 != 325) {
        goto LABEL_68;
      }
    }

    else if (v8 != 260)
    {
      if (v8 == 297)
      {
        sub_100036D00(&__s, 0LL, (uint64_t)a2);
        LODWORD(v321) = 0;
        if (!sub_1000487D4(a2, 0, &v321, &v320) && v320)
        {
          a4 = sub_10004B414(a1, a2, 1LL, v320, 9);
          uint64_t v107 = 2148LL;
          goto LABEL_144;
        }

        goto LABEL_190;
      }

      if (v8 != 310) {
        goto LABEL_68;
      }
      char v79 = 1;
      goto LABEL_119;
    }

    sub_100036D00(&__s, 0LL, (uint64_t)a2);
    LODWORD(v321) = 0;
    if (!sub_1000487D4(a2, 0, &v321, &v320) && v320)
    {
      a4 = sub_10004B414(a1, a2, 1LL, v320, 6);
      uint64_t v107 = 2162LL;
LABEL_144:
      sub_100052CE4( &v320,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  v107,  v102,  v103,  v104,  v105,  v106);
      return a4;
    }

    goto LABEL_190;
  }

  if (v8 > 580)
  {
    if (v8 > 623)
    {
      if (v8 == 632)
      {
        uint64_t v216 = "define ENABLE_EXECUTE in site.h to enable execute(); expressions.";
        goto LABEL_188;
      }

      if (v8 != 624) {
        goto LABEL_68;
      }
      sub_100036D00(&__s, 0LL, (uint64_t)a2);
      int v114 = sub_100036D00(&__s, 0LL, (uint64_t)a2);
      if (v114 == 314)
      {
        int v122 = 0;
      }

      else
      {
        int v121 = v114;
        if (v114 != 625)
        {
          sub_100046D6C((uint64_t)a2, "Expecting 'local' or 'default'.", v115, v116, v117, v118, v119, v120, v319);
          if (v121 == 59) {
            goto LABEL_190;
          }
          goto LABEL_189;
        }

        int v122 = 1;
      }

      dword_10008C158 = v122;
      a4 = 1LL;
      sub_100046D6C((uint64_t)a2, "Expecting a semicolon.", v282, v283, v284, v285, v286, v287, v319);
    }

    else
    {
      if (v8 != 581)
      {
        if (v8 != 586) {
          goto LABEL_68;
        }
        sub_100036D00(&__s, 0LL, (uint64_t)a2);
        if (!sub_100034984( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  2513LL)) {
          sub_100061FB4("no memory for return statement.", v80, v81, v82, v83, v84, v85, v86, v319);
        }
        uint64_t v87 = *a1;
        v87[4] = 20;
        if (sub_10004BA40((void *)v87 + 3, a2, a3, 2LL, 0LL, 0LL, v85, v86))
        {
          a4 = 1LL;
          *a3 = 1;
          uint64_t v99 = a1;
          uint64_t v100 = 2531LL;
        }

        else
        {
          if (*a3) {
            *a3 = 1;
          }
          else {
            sub_100046D6C((uint64_t)a2, "expecting data expression.", v88, v89, v90, v91, v92, v93, v319);
          }
          sub_100046C4C(a2, 0);
          uint64_t v99 = a1;
          uint64_t v100 = 2526LL;
        }

LABEL_211:
        sub_10003DC78( v99,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  v100,  v94,  v95,  v96,  v97,  v98);
        return 0LL;
      }

      sub_100036D00(&__s, 0LL, (uint64_t)a2);
      if (!sub_100034984( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  2539LL)) {
        sub_100061FB4("no memory for log statement.", v207, v208, v209, v210, v211, v212, v213, v319);
      }
      *((_DWORD *)*a1 + 4) = 19;
      if (sub_100036D00(&__s, 0LL, (uint64_t)a2) != 40)
      {
        uint64_t v216 = "left parenthesis expected.";
        goto LABEL_188;
      }

      unsigned int v214 = sub_1000374AC(&__s, 0LL, a2) - 582;
      uint64_t v215 = *a1;
      if (v214 >= 4)
      {
        v215[6] = 2;
      }

      else
      {
        v215[6] = v214;
        sub_100036D00(&__s, 0LL, (uint64_t)a2);
        if (sub_100036D00(&__s, 0LL, (uint64_t)a2) != 44)
        {
          uint64_t v216 = "comma expected.";
          goto LABEL_188;
        }
      }

      if (sub_100036D00(&__s, 0LL, (uint64_t)a2) != 41)
      {
        uint64_t v216 = "right parenthesis expected.";
        goto LABEL_188;
      }

      a4 = 1LL;
      sub_100046D6C((uint64_t)a2, "semicolon expected.", v288, v289, v290, v291, v292, v293, v319);
      sub_100046C4C(a2, 0);
    }

LABEL_161:
    *a3 = 1;
    return 0LL;
  }

  switch(v8)
  {
    case 449:
    case 455:
      int v25 = sub_100036D00(&__s, 0LL, (uint64_t)a2);
      if (!sub_100034984( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  2279LL)) {
        sub_100061FB4("no memory for set statement.", v32, v33, v34, v35, v36, v37, v38, v319);
      }
      if (v25 == 455) {
        int v39 = 18;
      }
      else {
        int v39 = 15;
      }
      *((_DWORD *)*a1 + 4) = v39;
      int v40 = strlen(__s);
      *((void *)*a1 + 3) = sub_10005CDE4((v40 + 1));
      __int128 v48 = (char *)*((void *)*a1 + 3);
      if (!v48) {
        sub_100061FB4("can't allocate variable name", v41, v42, v43, v44, v45, v46, v47, v319);
      }
      strcpy(v48, __s);
      int v49 = sub_100036D00(&__s, 0LL, (uint64_t)a2);
      if (v49 == 61)
      {
        if (sub_10004BA40((void *)*a1 + 4, a2, a3, 0LL, 0LL, 0LL, v54, v55))
        {
          a4 = 1LL;
          *a3 = 1;
          uint64_t v99 = a1;
          uint64_t v100 = 2382LL;
        }

        else
        {
          if (*a3) {
            *a3 = 1;
          }
          else {
            sub_100046D6C((uint64_t)a2, "expecting expression.", v275, v276, v277, v278, v279, v280, v319);
          }
          sub_100046C4C(a2, 0);
          uint64_t v99 = a1;
          uint64_t v100 = 2377LL;
        }

        goto LABEL_211;
      }

      if (v49 != 40)
      {
        uint64_t v281 = "set";
        if (v25 == 455) {
          uint64_t v281 = "define";
        }
        sub_100046D6C((uint64_t)a2, "expecting '=' in %s statement.", v50, v51, v52, v53, v54, v55, (char)v281);
        goto LABEL_189;
      }

      uint64_t v56 = 0LL;
      uint64_t v57 = 0LL;
      do
      {
        int v58 = sub_100036D00(&__s, 0LL, (uint64_t)a2);
        if (v58 == 41)
        {
          uint64_t v75 = v56;
          goto LABEL_193;
        }

        if ((v58 - 266) < 0xFFFFFFFE)
        {
          uint64_t v77 = 2303LL;
          uint64_t v78 = "expecting argument name";
LABEL_203:
          sub_100046D6C((uint64_t)a2, v78, v59, v60, v61, v62, v63, v64, v319);
LABEL_204:
          sub_100046C4C(a2, 0);
          *a3 = 1;
          uint64_t v99 = a1;
          uint64_t v100 = v77;
          goto LABEL_211;
        }

        int v65 = strlen(__s);
        uint64_t v66 = sub_10005CDE4((v65 + 16));
        uint64_t v74 = v66;
        if (!v66) {
          sub_100061FB4("can't allocate string.", v67, v68, v69, v70, v71, v72, v73, v319);
        }
        *(void *)uint64_t v66 = 0LL;
        *((void *)v66 + 1) = 0LL;
        strcpy((char *)v66 + 8, __s);
        uint64_t v75 = v74;
        if (v57)
        {
          *uint64_t v57 = v74;
          uint64_t v75 = v56;
        }

        int v76 = sub_100036D00(&__s, 0LL, (uint64_t)a2);
        uint64_t v56 = v75;
        uint64_t v57 = v74;
      }

      while (v76 == 44);
      if (v76 != 41)
      {
        uint64_t v77 = 2328LL;
        uint64_t v78 = "expecting right paren.";
        goto LABEL_203;
      }

LABEL_193:
      if (sub_100036D00(&__s, 0LL, (uint64_t)a2) != 123)
      {
        uint64_t v77 = 2328LL;
        uint64_t v78 = "expecting left brace.";
        goto LABEL_203;
      }

      uint64_t v321 = 0LL;
      if (!sub_1000343B4( &v321,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  2339LL,  v60,  v61,  v62,  v63,  v64)) {
        sub_100061FB4("can't allocate expression.", v301, v302, v303, v304, v305, v306, v307, v319);
      }
      uint64_t v308 = v321;
      *((_DWORD *)v321 + 1) = 46;
      if (!sub_1000344E0( (void *)v308 + 1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  2342LL)) {
        sub_100061FB4("can't allocate fundef.", v309, v310, v311, v312, v313, v314, v315, v319);
      }
      uint64_t v316 = v321;
      *(void *)(*((void *)v321 + 1) + 8LL) = v75;
      *((void *)*a1 + 4) = v316;
      for (uint64_t i = (void *)(*((void *)v316 + 1) + 16LL);
            sub_100049EC4(i, a2, a3, a4);
        ;
      }

      if (*a3)
      {
        uint64_t v77 = 2328LL;
        goto LABEL_204;
      }

      if (sub_100036D00(&__s, 0LL, (uint64_t)a2) != 125)
      {
        uint64_t v77 = 2328LL;
        uint64_t v78 = "expecting rigt brace.";
        goto LABEL_203;
      }

      return 1LL;
    case 450:
    case 453:
    case 454:
      goto LABEL_68;
    case 451:
      sub_100036D00(&__s, 0LL, (uint64_t)a2);
      if (sub_100036D00(&__s, 0LL, (uint64_t)a2) - 266 <= 0xFFFFFFFD)
      {
LABEL_75:
        sub_100046D6C((uint64_t)a2, "%s can't be a variable name", v26, v27, v28, v29, v30, v31, (char)__s);
        goto LABEL_189;
      }

      if (!sub_100034984( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  2400LL)) {
        sub_100061FB4("no memory for set statement.", v258, v259, v260, v261, v262, v263, v264, v319);
      }
      *((_DWORD *)*a1 + 4) = 16;
      int v265 = strlen(__s);
      *((void *)*a1 + 3) = sub_10005CDE4((v265 + 1));
      uint64_t v273 = (char *)*((void *)*a1 + 3);
      if (!v273) {
        sub_100061FB4("can't allocate variable name", v266, v267, v268, v269, v270, v271, v272, v319);
      }
      strcpy(v273, __s);
      a4 = 1LL;
      *a3 = 1;
      uint64_t v99 = a1;
      uint64_t v100 = 2409LL;
      goto LABEL_211;
    case 452:
      sub_100036D00(&__s, 0LL, (uint64_t)a2);
      if (!sub_100034984( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  2417LL)) {
        sub_100061FB4("no memory for eval statement.", v123, v124, v125, v126, v127, v128, v129, v319);
      }
      size_t v130 = *a1;
      v130[4] = 3;
      if (!sub_10004BA40((void *)v130 + 3, a2, a3, 2LL, 0LL, 0LL, v128, v129))
      {
        if (*a3) {
          *a3 = 1;
        }
        else {
          sub_100046D6C((uint64_t)a2, "expecting data expression.", v131, v132, v133, v134, v135, v136, v319);
        }
        sub_100046C4C(a2, 0);
        uint64_t v99 = a1;
        uint64_t v100 = 2430LL;
        goto LABEL_211;
      }

      a4 = 1LL;
      if (!sub_100046D08(a2))
      {
        *a3 = 1;
        sub_10003DC78( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  2435LL,  v137,  v138,  v139,  v140,  v141);
      }

      return a4;
    case 456:
      sub_100036D00(&__s, 0LL, (uint64_t)a2);
      uint64_t v321 = 0LL;
      if (!sub_100034C7C( &v321,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  2606LL,  v142,  v143,  v144,  v145,  v146)) {
        sub_100061FB4("no memory for new zone.", v147, v148, v149, v150, v151, v152, v153, v319);
      }
      uint64_t v154 = sub_1000470FC(a2);
      uint64_t v161 = (uint64_t *)v321;
      *((void *)v321 + 2) = v154;
      if (v154)
      {
        uint64_t v162 = v154;
        size_t v163 = strlen(v154);
        size_t v164 = v163;
        uint64_t v165 = (char *)sub_10005CDE4((v163 + 2));
        if (v165)
        {
          uint64_t v166 = v165;
          uint64_t v167 = strcpy(v165, *((const char **)v321 + 2));
          v167[(int)v164] = 46;
          v167[(uint64_t)((uint64_t)&_mh_execute_header + (v164 << 32)) >> 32] = 0;
          sub_10005CE20( *((void **)v321 + 2),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  2627LL,  v168,  v169,  v170,  v171,  v172);
          uint64_t v161 = (uint64_t *)v321;
          *((void *)v321 + 2) = v166;
LABEL_87:
          if (sub_10004C0C8(v161, a2))
          {
            unsigned int v180 = sub_10003C2E0((uint64_t)v321, v173, v174, v175, v176, v177, v178, v179);
            if (!v180)
            {
              sub_10003C3F8( &v321,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  2639LL,  v181,  v182,  v183,  v184,  v185);
              return 1LL;
            }

            uint64_t v186 = *((void *)v321 + 2);
            sub_100067900(v180);
            sub_100046D6C((uint64_t)a2, "dns zone key %s: %s", v187, v188, v189, v190, v191, v192, v186);
            uint64_t v198 = 2636LL;
LABEL_186:
            sub_10003C3F8( &v321,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  v198,  v193,  v194,  v195,  v196,  v197);
            return 0LL;
          }

LABEL_185:
          *a3 = 1;
          sub_100046C4C(a2, 0);
          uint64_t v198 = 2614LL;
          goto LABEL_186;
        }

        uint64_t v274 = "no trailing '.' on zone";
      }

      else
      {
        uint64_t v274 = "expecting hostname.";
      }

      sub_100046D6C((uint64_t)a2, v274, v155, v156, v157, v158, v159, v160, v319);
      goto LABEL_185;
    case 457:
      sub_100036D00(&__s, 0LL, (uint64_t)a2);
      a4 = 1LL;
      return a4;
    default:
      if (v8 == 435)
      {
        sub_100036D00(&__s, 0LL, (uint64_t)a2);
        return sub_10004B768(a1, a2, a3);
      }

      if (v8 != 436) {
        goto LABEL_68;
      }
      sub_100036D00(&__s, 0LL, (uint64_t)a2);
      if ((_DWORD)a4) {
        return sub_10004B930(a1, a2, a3, a4);
      }
      sub_100046D6C((uint64_t)a2, "case statement in inappropriate scope.", v108, v109, v110, v111, v112, v113, v319);
      *a3 = 1;
      sub_100046C4C(a2, 0);
      return a4;
  }

uint64_t sub_10004AFE4(void **a1, int32x2_t *a2, _DWORD *a3)
{
  *((_DWORD *)*a1 + 4) = 1;
  if (sub_1000374AC(&v78, 0LL, a2) != 40)
  {
LABEL_12:
    if (!*a3) {
      sub_100046D6C((uint64_t)a2, "BOOLean expression expected.", v23, v24, v25, v26, v27, v28, v77);
    }
    int v49 = a1;
    uint64_t v50 = 3203LL;
    goto LABEL_15;
  }

  sub_100036D00(&v78, 0LL, (uint64_t)a2);
  if (sub_100036D00(&v78, 0LL, (uint64_t)a2) != 41)
  {
    sub_100046D6C((uint64_t)a2, "expecting right paren.", v29, v30, v31, v32, v33, v34, v77);
    *a3 = 1;
    int v40 = a1;
    uint64_t v41 = 3215LL;
LABEL_31:
    sub_10003DC78( v40,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  v41,  v35,  v36,  v37,  v38,  v39);
    return 0LL;
  }

uint64_t sub_10004B414(void *a1, int32x2_t *a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v39 = 0LL;
  int v10 = sub_1000374AC(&v40, 0LL, a2);
  if (v10 != 61)
  {
    if (v10 == 59 && **(_BYTE **)(a4 + 8) != 90)
    {
      sub_100036D00(&v40, 0LL, (uint64_t)a2);
    }

    else
    {
      uint64_t result = sub_10004E968(&v39, a2, a3, a4, v11, v12, v13, v14);
      if (!(_DWORD)result) {
        return result;
      }
    }

    goto LABEL_11;
  }

  sub_100036D00(&v40, 0LL, (uint64_t)a2);
  if (sub_10004C02C((uint64_t *)&v39, (uint64_t)a2, &v38))
  {
LABEL_11:
    uint64_t result = sub_100046D08(a2);
    if ((_DWORD)result)
    {
      if (!sub_100034984( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  5054LL)) {
        sub_100061FB4("no memory for option statement.", v22, v23, v24, v25, v26, v27, v28, v37);
      }
      uint64_t v29 = *a1;
      *(_DWORD *)(*a1 + 16LL) = a5;
      if (v39)
      {
        if (!sub_100054A34( (void *)(v29 + 24),  0LL,  v39,  a4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  5059LL,  v27,  v28)) {
          sub_100061FB4("no memory for option cache", v30, v31, v32, v33, v34, v35, v36, v37);
        }
        if (v39) {
          sub_100054390( (uint64_t *)&v39,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  5063LL,  v32,  v33,  v34,  v35,  v36);
        }
      }

      return 1LL;
    }

    return result;
  }

  if (!v38)
  {
    sub_100046D6C((uint64_t)a2, "expecting a data expression.", v16, v17, v18, v19, v20, v21, v37);
    sub_100046C4C(a2, 0);
  }

  return 0LL;
}

uint64_t sub_10004B594(void **a1, int32x2_t *a2, _DWORD *a3)
{
  *((_DWORD *)*a1 + 4) = 11;
  uint64_t v13 = "expecting a lease event type";
  uint64_t v14 = 3017LL;
  do
  {
    int v15 = sub_100036D00(&v33, 0LL, (uint64_t)a2);
    if (v15 > 410)
    {
      if (v15 == 602)
      {
        int v22 = 8;
      }

      else
      {
        if (v15 != 411) {
          goto LABEL_20;
        }
        int v22 = 1;
      }
    }

    else if (v15 == 409)
    {
      int v22 = 2;
    }

    else
    {
      if (v15 != 410) {
        goto LABEL_20;
      }
      int v22 = 4;
    }

    *((_DWORD *)*a1 + 6) |= v22;
    int v23 = sub_100036D00(&v33, 0LL, (uint64_t)a2);
  }

  while (v23 == 335);
  if (v23 == 59) {
    return 1LL;
  }
  if (v23 != 123)
  {
    uint64_t v14 = 3031LL;
    uint64_t v13 = "left brace expected.";
LABEL_20:
    sub_100046D6C((uint64_t)a2, v13, v16, v17, v18, v19, v20, v21, v32);
    sub_100046C4C(a2, 0);
    *a3 = 1;
LABEL_25:
    sub_10003DC78( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  v14,  v25,  v26,  v27,  v28,  v29);
    return 0LL;
  }

  if (*a3)
  {
    do
      int v30 = sub_100036D00(&v33, 0LL, (uint64_t)a2);
    while (v30 != 125 && v30 != 607);
    uint64_t v14 = 3042LL;
    goto LABEL_25;
  }

  if (sub_100036D00(&v33, 0LL, (uint64_t)a2) != 125)
  {
    uint64_t v14 = 3051LL;
    uint64_t v13 = "right brace expected.";
    goto LABEL_20;
  }

  return 1LL;
}

uint64_t sub_10004B768(void **a1, int32x2_t *a2, _DWORD *a3)
{
  *((_DWORD *)*a1 + 4) = 12;
  if (sub_100036D00(&v26, 0LL, (uint64_t)a2) != 40)
  {
    uint64_t v21 = "expecting left brace.";
    goto LABEL_20;
  }

  if (sub_10004BA40((void *)*a1 + 3, a2, a3, 5LL, 0LL, 0LL, v17, v18))
  {
    if (sub_100036D00(&v26, 0LL, (uint64_t)a2) == 41)
    {
      if (sub_100036D00(&v26, 0LL, (uint64_t)a2) == 123)
      {
        uint64_t v19 = (char *)*a1 + 32;
        if (sub_100056150(*((void *)*a1 + 3))) {
          uint64_t v20 = 2LL;
        }
        else {
          uint64_t v20 = 3LL;
        }
        if (*a3)
        {
          uint64_t v22 = 3113LL;
          unsigned int v23 = 1;
LABEL_21:
          sub_100046C4C(a2, v23);
          goto LABEL_22;
        }

        uint64_t v21 = "right brace expected.";
      }

      else
      {
        uint64_t v21 = "left brace expected.";
      }
    }

    else
    {
      uint64_t v21 = "right paren expected.";
    }

uint64_t sub_10004B930(void **a1, int32x2_t *a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v15 = *a1;
  v15[4] = 13;
  if (sub_10004BA40((void *)v15 + 3, a2, a3, a4, 0LL, 0LL, v13, v14))
  {
    sub_100046D6C((uint64_t)a2, "colon expected.", v22, v23, v24, v25, v26, v27, v35);
  }

  else if (!*a3)
  {
    uint64_t v29 = "numeric";
    if ((_DWORD)a4 == 2) {
      uint64_t v29 = "data";
    }
    sub_100046D6C((uint64_t)a2, "expecting %s expression.", v16, v17, v18, v19, v20, v21, (char)v29);
  }

  *a3 = 1;
  sub_100046C4C(a2, 0);
  sub_10003DC78( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3155LL,  v30,  v31,  v32,  v33,  v34);
  return 0LL;
}

uint64_t sub_10004BA40( void *a1, int32x2_t *a2, _DWORD *a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  signed int v8 = a6;
  uint64_t v94 = 0LL;
  uint64_t v92 = 0LL;
  if (a5)
  {
    sub_100033F18( &v92,  (_DWORD *)*a5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  4621LL,  (uint64_t)a5,  a6,  a7,  a8);
    sub_100054390( a5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  4622LL,  v14,  v15,  v16,  v17,  v18);
  }

  if (!sub_10004C964(&v94, a2, a3, a4))
  {
LABEL_62:
    if (!v92) {
      return 0LL;
    }
    if (!*a3)
    {
      sub_100046D6C((uint64_t)a2, "expecting right-hand side.", v19, v20, v21, v22, v23, v24, v92);
      *a3 = 1;
      sub_100046C4C(a2, 0);
    }

    uint64_t v70 = 4637LL;
    goto LABEL_66;
  }

  while (1)
  {
    int v25 = sub_1000374AC(&v95, 0LL, a2);
    if (v25 <= 60)
    {
      switch(v25)
      {
        case '!':
          sub_100036D00(&v95, 0LL, (uint64_t)a2);
          if (sub_1000374AC(&v95, 0LL, a2) == 61)
          {
            uint64_t v37 = 38LL;
            goto LABEL_33;
          }

          sub_100046D6C((uint64_t)a2, "! in BOOLean context without =", v31, v32, v33, v34, v35, v36, v92);
          *a3 = 1;
          sub_100046C4C(a2, 0);
          if (!v92) {
            return 0LL;
          }
          uint64_t v70 = 4656LL;
          break;
        case '%':
          uint64_t v37 = 51LL;
          goto LABEL_33;
        case '&':
          uint64_t v37 = 52LL;
          goto LABEL_33;
        case '*':
          uint64_t v37 = 49LL;
          goto LABEL_33;
        case '+':
          uint64_t v37 = 47LL;
          goto LABEL_33;
        case '-':
          uint64_t v37 = 48LL;
          goto LABEL_33;
        case '/':
          uint64_t v37 = 50LL;
          goto LABEL_33;
        default:
          goto LABEL_29;
      }

LABEL_66:
      sub_100054390( &v92,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  v70,  v20,  v21,  v22,  v23,  v24);
      return 0LL;
    }

    if (v25 > 125)
    {
      switch(v25)
      {
        case 126:
          sub_100036D00(&v95, 0LL, (uint64_t)a2);
          int v38 = sub_1000374AC(&v95, 0LL, a2);
          if (v38 == 126)
          {
            uint64_t v37 = 59LL;
          }

          else
          {
            if (v38 != 61)
            {
              sub_100046D6C((uint64_t)a2, "expecting ~= or ~~ operator", v39, v40, v41, v42, v43, v44, v92);
              *a3 = 1;
              sub_100046C4C(a2, 0);
              if (!v92) {
                return 0LL;
              }
              uint64_t v70 = 4682LL;
              goto LABEL_66;
            }

            uint64_t v37 = 58LL;
          }

          break;
        case 334:
          uint64_t v37 = 8LL;
          break;
        case 335:
          uint64_t v37 = 9LL;
          break;
        default:
LABEL_29:
          if (v92)
          {
            if (!v8) {
              goto LABEL_68;
            }
LABEL_37:
            LODWORD(v37) = 0;
            goto LABEL_38;
          }

          *a1 = v94;
          return 1LL;
      }
    }

    else
    {
      switch(v25)
      {
        case '=':
          uint64_t v37 = 3LL;
          break;
        case '^':
          uint64_t v37 = 54LL;
          break;
        case '|':
          uint64_t v37 = 53LL;
          break;
        default:
          goto LABEL_29;
      }
    }

LABEL_57:
    if ((_DWORD)v37)
    {
LABEL_58:
      sub_100036D00(&v95, 0LL, (uint64_t)a2);
      uint64_t v93 = 0LL;
      if (!sub_1000343B4( &v93,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  4896LL,  v56,  v57,  v58,  v59,  v60)) {
        sub_100061FB4("No memory for equal precedence combination.", v61, v62, v63, v64, v65, v66, v67, v92);
      }
      uint64_t v68 = v93;
      uint64_t v69 = v94;
      *(void *)(v93 + 8) = v92;
      *(void *)(v68 + 16) = v69;
      *(_DWORD *)(v68 + 4) = v8;
      uint64_t v92 = v68;
      uint64_t v93 = 0LL;
      uint64_t v94 = 0LL;
      goto LABEL_61;
    }

uint64_t sub_10004C02C(uint64_t *a1, uint64_t a2, _DWORD *a3)
{
  if (!sub_100056150(*a1))
  {
    uint64_t v11 = 1LL;
    if ((*(_DWORD *)(*a1 + 4) | 4) == 0x2D) {
      return v11;
    }
    sub_100054390( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3365LL,  v6,  v7,  v8,  v9,  v10);
    sub_100046D6C(a2, "Expecting a data expression.", v12, v13, v14, v15, v16, v17, v19);
    *a3 = 1;
    return 0LL;
  }

  return 1LL;
}

uint64_t sub_10004C0C8(uint64_t *a1, int32x2_t *a2)
{
  if (sub_100036D00(&v72, 0LL, (uint64_t)a2) != 123)
  {
    uint64_t v67 = "expecting left brace";
    goto LABEL_34;
  }

  uint64_t v10 = a1 + 5;
  uint64_t v11 = a1 + 4;
  uint64_t v12 = a1 + 3;
  while (1)
  {
    while (1)
    {
      int v13 = sub_1000374AC(&v72, 0LL, a2);
      if (v13 != 457) {
        break;
      }
      sub_100036D00(&v72, 0LL, (uint64_t)a2);
      if (sub_1000374AC(&v72, 0LL, a2) == 262)
      {
        sub_100036D00(&v72, 0LL, (uint64_t)a2);
        uint64_t v29 = 0LL;
        uint64_t v30 = v72;
      }

      else
      {
        uint64_t v59 = sub_1000470FC(a2);
        if (!v59)
        {
          uint64_t v68 = "expecting key name.";
          goto LABEL_36;
        }

        uint64_t v30 = v59;
        uint64_t v72 = v59;
        uint64_t v29 = v59;
      }

      if (v29) {
        sub_10005CE20( v29,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  2808LL,  v61,  v62,  v63,  v64,  v65);
      }
      uint64_t result = sub_100046D08(a2);
      if (!(_DWORD)result) {
        return result;
      }
    }

    if (v13 != 369) {
      break;
    }
    if (*v11)
    {
      uint64_t v68 = "more than one secondary.";
LABEL_36:
      sub_100046D6C((uint64_t)a2, v68, v14, v15, v16, v17, v18, v19, v69);
      sub_100046C4C(a2, 0);
      return 0LL;
    }

    uint64_t v27 = v11;
    if (!sub_100034540( v11,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  2749LL,  v15,  v16,  v17,  v18,  v19))
    {
      uint64_t v28 = "can't allocate secondary.";
LABEL_14:
      sub_100061FB4(v28, v20, v21, v22, v23, v24, v25, v26, v69);
    }

LABEL_15:
    uint64_t v31 = *v27;
    sub_100036D00(&v72, 0LL, (uint64_t)a2);
    uint64_t v32 = (uint64_t *)(v31 + 16);
    do
    {
      uint64_t v71 = 0LL;
      if (!sub_100047324((uint64_t *)&v71, a2, 0))
      {
        uint64_t v68 = "expecting IP addr or hostname.";
        goto LABEL_36;
      }

      uint64_t v33 = (_DWORD *)*v32;
      if (*v32)
      {
        uint64_t v70 = 0LL;
        sub_100033F18( &v70,  v33,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  2767LL,  v16,  v17,  v18,  v19);
        sub_100054390( v32,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  2769LL,  v34,  v35,  v36,  v37,  v38);
        sub_100054390( (uint64_t *)&v71,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  2773LL,  v46,  v47,  v48,  v49,  v50);
        uint64_t v56 = (uint64_t *)&v70;
        uint64_t v57 = 2774LL;
      }

      else
      {
        sub_100033F18( v32,  v71,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  2777LL,  v16,  v17,  v18,  v19);
        uint64_t v56 = (uint64_t *)&v71;
        uint64_t v57 = 2778LL;
      }

      sub_100054390( v56,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  v57,  v51,  v52,  v53,  v54,  v55);
      int v58 = sub_100036D00(&v72, 0LL, (uint64_t)a2);
    }

    while (v58 == 44);
    if (v58 != 59)
    {
      uint64_t v68 = "expecting semicolon.";
      goto LABEL_36;
    }
  }

  if (v13 == 368)
  {
    if (*v12)
    {
      uint64_t v68 = "more than one primary.";
      goto LABEL_36;
    }

    uint64_t v27 = v12;
    if (!sub_100034540( v12,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  2738LL,  v15,  v16,  v17,  v18,  v19))
    {
      uint64_t v28 = "can't allocate primary option cache.";
      goto LABEL_14;
    }

    goto LABEL_15;
  }

  uint64_t v67 = "expecting right brace.";
LABEL_34:
  sub_100046D6C((uint64_t)a2, v67, v4, v5, v6, v7, v8, v9, v69);
  return 0LL;
}

uint64_t sub_10004C3E8(int32x2_t *a1)
{
  uint64_t v97 = 0LL;
  if (sub_10005DB84( (void **)&v97,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  2846LL)) {
    sub_100061FB4("no memory for key", v2, v3, v4, v5, v6, v7, v8, v94);
  }
  if (sub_1000374AC(&__s, 0LL, a1) == 262)
  {
    sub_100036D00(&__s, 0LL, (uint64_t)a1);
    int v9 = strlen(__s);
    uint64_t v10 = (char *)sub_10005CDE4((v9 + 1));
    *(void *)(v97 + 32) = v10;
    if (!v10) {
      sub_100061FB4("no memory for key name.", v11, v12, v13, v14, v15, v16, v17, v94);
    }
    strcpy(v10, __s);
  }

  else
  {
    uint64_t v18 = sub_1000470FC(a1);
    *(void *)(v97 + 32) = v18;
    if (!v18)
    {
      sub_100046D6C((uint64_t)a1, "expecting key name.", v19, v20, v21, v22, v23, v24, v94);
      uint64_t v73 = a1;
      unsigned int v74 = 0;
LABEL_39:
      sub_100046C4C(v73, v74);
      goto LABEL_40;
    }
  }

  if (sub_100036D00(&__s, 0LL, (uint64_t)a1) != 123)
  {
    sub_100046D6C((uint64_t)a1, "expecting left brace", v25, v26, v27, v28, v29, v30, v94);
LABEL_40:
    uint64_t v91 = 0LL;
    uint64_t v92 = 2971LL;
    goto LABEL_41;
  }

  while (1)
  {
    while (1)
    {
      int v31 = sub_100036D00(&__s, 0LL, (uint64_t)a1);
      if (v31 != 458) {
        break;
      }
      if (*(void *)(v97 + 48))
      {
        sub_100046D6C((uint64_t)a1, "key %s: too many secrets", v32, v33, v34, v35, v36, v37, *(void *)(v97 + 32));
        goto LABEL_38;
      }

      v95[0] = 0LL;
      v95[1] = 0LL;
      size_t __n = 0LL;
      if (sub_1000498C0((uint64_t)v95, a1) && !sub_10005D5E0((void *)(v97 + 48), __n))
      {
        memcpy((void *)(*(void *)(v97 + 48) + 8LL), v95[0] + 1, __n);
        sub_100034EA8( v95,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  2937LL,  v58,  v59,  v60,  v61,  v62);
      }

      goto LABEL_38;
    }

    if (v31 != 459) {
      break;
    }
    if (*(void *)(v97 + 40))
    {
      sub_100046D6C((uint64_t)a1, "key %s: too many algorithms", v32, v33, v34, v35, v36, v37, *(void *)(v97 + 32));
LABEL_38:
      uint64_t v73 = a1;
      unsigned int v74 = 1;
      goto LABEL_39;
    }

    uint64_t v38 = sub_1000470FC(a1);
    *(void *)(v97 + 4__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = v38;
    if (!v38)
    {
      uint64_t v90 = "expecting key algorithm name.";
      goto LABEL_37;
    }

    uint64_t v39 = *(const char **)(v97 + 40);
    uint64_t v40 = strrchr(v39, 46);
    if (!v40)
    {
      int v63 = strlen(v39);
      uint64_t v64 = (char *)sub_10005CDE4((v63 + 18));
      if (!v64)
      {
        sub_10006221C("no memory for key %s.", v65, v66, v67, v68, v69, v70, v71, (char)"algorithm");
        goto LABEL_38;
      }

      uint64_t v50 = v64;
      uint64_t v72 = strcpy(v64, *(const char **)(v97 + 40));
      strcat(v72, aSigAlgRegInt);
      uint64_t v57 = 2904LL;
      goto LABEL_25;
    }

    if (v40[1])
    {
      int v41 = strlen(v39);
      uint64_t v42 = (char *)sub_10005CDE4((v41 + 2));
      uint64_t v49 = *(const char **)(v97 + 40);
      if (!v42)
      {
        sub_10006221C("no memory for key %s.", (uint64_t)v49, v43, v44, v45, v46, v47, v48, *(void *)(v97 + 40));
        goto LABEL_38;
      }

      uint64_t v50 = v42;
      uint64_t v51 = strcpy(v42, v49);
      *(_WORD *)&v50[strlen(v51)] = 46;
      uint64_t v57 = 2916LL;
LABEL_25:
      sub_10005CE20( *(void **)(v97 + 40),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  v57,  v52,  v53,  v54,  v55,  v56);
      *(void *)(v97 + 4__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = v50;
    }
  }

  if (v31 != 125)
  {
    uint64_t v90 = "expecting right brace.";
LABEL_37:
    sub_100046D6C((uint64_t)a1, v90, v32, v33, v34, v35, v36, v37, v94);
    goto LABEL_38;
  }

  unsigned int v82 = sub_10005DC80(v97, v75, v76, v77, v78, v79, v80, v81);
  if (v82)
  {
    uint64_t v83 = *(void *)(v97 + 32);
    sub_100067900(v82);
    sub_100046D6C((uint64_t)a1, "tsig key %s: %s", v84, v85, v86, v87, v88, v89, v83);
    goto LABEL_40;
  }

  uint64_t v91 = 1LL;
  uint64_t v92 = 2965LL;
LABEL_41:
  sub_10005DBA4(&v97, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c", v92);
  return v91;
}

uint64_t sub_10004C790( uint64_t *a1, int32x2_t *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!sub_10005521C(*a1))
  {
    uint64_t v17 = 1LL;
    if ((*(_DWORD *)(*a1 + 4) | 4) == 0x2D) {
      return v17;
    }
    sub_100046D6C((uint64_t)a2, "Expecting a BOOLean expression.", v11, v12, v13, v14, v15, v16, v24);
    *a3 = 1;
    sub_100054390( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3328LL,  v18,  v19,  v20,  v21,  v22);
    return 0LL;
  }

  return 1LL;
}

uint64_t sub_10004C82C(uint64_t *a1, uint64_t a2, _DWORD *a3)
{
  if (!sub_1000558E0(*a1))
  {
    uint64_t v11 = 1LL;
    if ((*(_DWORD *)(*a1 + 4) | 4) == 0x2D) {
      return v11;
    }
    sub_100054390( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3392LL,  v6,  v7,  v8,  v9,  v10);
    sub_100046D6C(a2, "Expecting a numeric expression.", v12, v13, v14, v15, v16, v17, v19);
    *a3 = 1;
    return 0LL;
  }

  return 1LL;
}

uint64_t sub_10004C8C8(uint64_t *a1, uint64_t a2, _DWORD *a3)
{
  if (!sub_1000573AC(*a1))
  {
    uint64_t v11 = 1LL;
    if ((*(_DWORD *)(*a1 + 4) | 4) == 0x2D) {
      return v11;
    }
    sub_100054390( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3427LL,  v6,  v7,  v8,  v9,  v10);
    sub_100046D6C(a2, "Expecting a dns update subexpression.", v12, v13, v14, v15, v16, v17, v19);
    *a3 = 1;
    return 0LL;
  }

  return 1LL;
}

uint64_t sub_10004C964(uint64_t *a1, int32x2_t *a2, _DWORD *a3, uint64_t a4)
{
  int v8 = sub_1000374AC(&__s2, 0LL, a2);
  int v14 = v8;
  if (v8 > 380)
  {
    if (v8 <= 592)
    {
      switch(v8)
      {
        case 381:
          sub_100036D00(&__s2, 0LL, (uint64_t)a2);
          if ((_DWORD)a4 == 4)
          {
            sub_1000374AC(&__s2, 0LL, a2);
            if (sub_1000374AC(&__s2, 0LL, a2) == 350)
            {
              int v49 = 0;
              int v48 = 37;
              goto LABEL_177;
            }

            uint64_t v511 = "expecting DNS prerequisite.";
            goto LABEL_231;
          }

          if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3488LL,  v226,  v227,  v228,  v229,  v230)) {
            sub_100061FB4("can't allocate expression", v610, v611, v612, v613, v614, v615, v616, v759);
          }
          uint64_t v617 = *a1;
          *(_DWORD *)(v617 + 4) = 10;
          if (sub_10004C964(v617 + 8, a2, a3, 1LL))
          {
            uint64_t v110 = 1LL;
            if (sub_10005521C(*(void *)(*a1 + 8))) {
              return v110;
            }
            *a3 = 1;
            sub_100046D6C((uint64_t)a2, "BOOLean expression expected", v619, v620, v621, v622, v623, v624, v759);
            sub_100046C4C(a2, 0);
            uint64_t v102 = a1;
            uint64_t v103 = 3505LL;
          }

          else
          {
            if (!*a3)
            {
              sub_100046D6C((uint64_t)a2, "expression expected", v618, v73, v74, v75, v76, v77, v759);
              sub_100046C4C(a2, 0);
            }

            *a3 = 1;
            uint64_t v102 = a1;
            uint64_t v103 = 3498LL;
          }

          goto LABEL_295;
        case 398:
          sub_100036D00(&__s2, 0LL, (uint64_t)a2);
          if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3698LL,  v231,  v232,  v233,  v234,  v235)) {
            sub_100061FB4("can't allocate expression", v236, v237, v238, v239, v240, v241, v242, v759);
          }
          *(_DWORD *)(*a1 + 4) = 6;
          while (1)
          {
            int v243 = sub_100036D00(&__s2, 0LL, (uint64_t)a2);
            if (v243 != 44) {
              goto LABEL_293;
            }
            v761 = 0LL;
            if (!sub_1000343B4( &v761,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3723LL,  v245,  v246,  v247,  v248,  v249)) {
              sub_100061FB4("can't allocate at CONCAT2", v250, v251, v252, v253, v254, v255, v256, v759);
            }
            uint64_t v257 = v761;
            v761[1] = 6;
            sub_100033F18( (void *)v257 + 1,  (_DWORD *)*a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3727LL,  v253,  v254,  v255,  v256);
            sub_100054390( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3728LL,  v258,  v259,  v260,  v261,  v262);
            sub_100033F18( a1,  v761,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3729LL,  v263,  v264,  v265,  v266);
            sub_100054390( (uint64_t *)&v761,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3730LL,  v267,  v268,  v269,  v270,  v271);
          }

        case 399:
          sub_100036D00(&__s2, 0LL, (uint64_t)a2);
          if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  4350LL,  v22,  v23,  v24,  v25,  v26)) {
            sub_100061FB4("can't allocate expression", v272, v273, v274, v275, v276, v277, v278, v759);
          }
          if (!sub_10004C82C((uint64_t *)(*a1 + 8), (uint64_t)a2, a3))
          {
            sub_100046D6C((uint64_t)a2, "expecting numeric expression.", v279, v280, v281, v282, v283, v284, v759);
            sub_100046C4C(a2, 0);
            *a3 = 1;
            uint64_t v102 = a1;
            uint64_t v103 = 4358LL;
            goto LABEL_295;
          }

          if (sub_100036D00(&__s2, 0LL, (uint64_t)a2) != 44)
          {
            sub_100046D6C((uint64_t)a2, "comma expected.", v285, v286, v287, v288, v289, v290, v759);
            *a3 = 1;
            uint64_t v102 = a1;
            uint64_t v103 = 4366LL;
            goto LABEL_295;
          }

          if (sub_100036D00(&__s2, 0LL, (uint64_t)a2) != 263)
          {
            sub_100046D6C((uint64_t)a2, "number expected.", v291, v292, v293, v294, v295, v296, v759);
            *a3 = 1;
            uint64_t v102 = a1;
            uint64_t v103 = 4374LL;
            goto LABEL_295;
          }

          int v297 = atoi(__s2);
          switch(v297)
          {
            case 8:
              int v304 = 18;
              break;
            case 32:
              int v304 = 20;
              break;
            case 16:
              int v304 = 19;
              break;
            default:
              sub_100046D6C((uint64_t)a2, "unsupported integer size %d", v298, v299, v300, v301, v302, v303, v297);
              *a3 = 1;
              sub_100046C4C(a2, 0);
              uint64_t v102 = a1;
              uint64_t v103 = 4395LL;
              goto LABEL_295;
          }

          *(_DWORD *)(*a1 + 4) = v304;
          uint64_t v110 = 1LL;
          sub_100046D6C((uint64_t)a2, "right parenthesis expected.", v692, v693, v694, v695, v696, v697, v759);
          *a3 = 1;
          uint64_t v102 = a1;
          uint64_t v103 = 4403LL;
          goto LABEL_295;
        case 402:
          sub_100036D00(&__s2, 0LL, (uint64_t)a2);
          if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3783LL,  v305,  v306,  v307,  v308,  v309)) {
            sub_100061FB4("can't allocate expression", v310, v311, v312, v313, v314, v315, v316, v759);
          }
          *(_DWORD *)(*a1 + 4) = 25;
          uint64_t v317 = (uint64_t *)(*a1 + 16);
          goto LABEL_226;
        case 403:
          sub_100036D00(&__s2, 0LL, (uint64_t)a2);
          if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  4153LL,  v318,  v319,  v320,  v321,  v322)) {
            sub_100061FB4("can't allocate expression", v323, v324, v325, v326, v327, v328, v329, v759);
          }
          uint64_t v46 = *a1;
          int v47 = 26;
          goto LABEL_245;
        case 404:
          sub_100036D00(&__s2, 0LL, (uint64_t)a2);
          if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3740LL,  v330,  v331,  v332,  v333,  v334)) {
            sub_100061FB4("can't allocate expression", v335, v336, v337, v338, v339, v340, v341, v759);
          }
          *(_DWORD *)(*a1 + 4) = 27;
          uint64_t v317 = (uint64_t *)(*a1 + 32);
          goto LABEL_226;
        case 405:
          sub_100036D00(&__s2, 0LL, (uint64_t)a2);
          if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3812LL,  v342,  v343,  v344,  v345,  v346)) {
            sub_100061FB4("can't allocate expression", v347, v348, v349, v350, v351, v352, v353, v759);
          }
          v761 = 0LL;
          sub_100033F18( &v761,  (_DWORD *)*a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3820LL,  v17,  v18,  v19,  v20);
          uint64_t v354 = (uint64_t *)v761;
          v761[1] = 30;
          while (1)
          {
            int v355 = sub_100036D00(&__s2, 0LL, (uint64_t)a2);
            if (v355 != 44) {
              break;
            }
            v760 = 0LL;
            if (!sub_1000343B4( &v760,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3831LL,  v356,  v357,  v358,  v359,  v360)) {
              sub_100061FB4("can't allocate expr", v361, v362, v363, v364, v365, v366, v367, v759);
            }
            sub_100033F18( (void *)v761 + 2,  v760,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3834LL,  v364,  v365,  v366,  v367);
            sub_100054390( (uint64_t *)&v761,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3835LL,  v368,  v369,  v370,  v371,  v372);
            sub_100033F18( &v761,  v760,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3836LL,  v373,  v374,  v375,  v376);
            sub_100054390( (uint64_t *)&v760,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3837LL,  v377,  v378,  v379,  v380,  v381);
            uint64_t v382 = (uint64_t *)v761;
            v761[1] = 30;
          }

          int v657 = v355;
          sub_100054390( (uint64_t *)&v761,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3840LL,  v356,  v357,  v358,  v359,  v360);
          if (v657 != 41) {
            goto LABEL_294;
          }
          return 1LL;
        case 406:
          goto LABEL_47;
        case 407:
          sub_100036D00(&__s2, 0LL, (uint64_t)a2);
          if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  4195LL,  v383,  v384,  v385,  v386,  v387)) {
            sub_100061FB4("can't allocate expression", v388, v389, v390, v391, v392, v393, v394, v759);
          }
          uint64_t v46 = *a1;
          int v47 = 29;
          goto LABEL_245;
        case 412:
        case 419:
          int v15 = sub_100036D00(&__s2, 0LL, (uint64_t)a2);
          if (sub_100036D00(&__s2, 0LL, (uint64_t)a2) != 262)
          {
            uint64_t v510 = "parse_expression: expecting string.";
            goto LABEL_277;
          }

          uint64_t v27 = __s2;
          if (!strcasecmp(__s2, "a"))
          {
            uint64_t v656 = 1LL;
          }

          else if (!strcasecmp(v27, "aaaa"))
          {
            uint64_t v656 = 28LL;
          }

          else if (!strcasecmp(v27, "ptr"))
          {
            uint64_t v656 = 12LL;
          }

          else if (!strcasecmp(v27, "mx"))
          {
            uint64_t v656 = 15LL;
          }

          else if (!strcasecmp(v27, "cname"))
          {
            uint64_t v656 = 5LL;
          }

          else
          {
            if (strcasecmp(v27, "TXT"))
            {
              sub_100046D6C((uint64_t)a2, "unexpected rrtype: %s", v28, v29, v30, v31, v32, v33, (char)v27);
              goto LABEL_278;
            }

            uint64_t v656 = 16LL;
          }

          if (v15 == 412) {
            v698 = "old-dns-update";
          }
          else {
            v698 = "old-dns-delete";
          }
          v699 = sub_10005CDE4(0xFuLL);
          v707 = v699;
          if (!v699) {
            sub_100061FB4("can't allocate name for %s", v700, v701, v702, v703, v704, v705, v706, (char)v698);
          }
          void *v699 = *(void *)v698;
          *(void *)((char *)v699 + 7) = *(void *)(v698 + 7);
          if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3900LL,  v702,  v703,  v704,  v705,  v706)) {
            sub_100061FB4("can't allocate expression", v708, v709, v710, v711, v712, v713, v714, v759);
          }
          uint64_t v715 = *a1;
          *(_DWORD *)(v715 + 4) = 45;
          *(void *)(v715 + 8) = v707;
          v716 = (void *)(*a1 + 16);
          if (!sub_1000343B4( v716,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3907LL,  v710,  v711,  v712,  v713,  v714)) {
            sub_100061FB4("can't allocate expression", v717, v718, v719, v720, v721, v722, v723, v759);
          }
          uint64_t v724 = *v716;
          *(_DWORD *)(v724 + 4) = 44;
          v732 = (void *)(*v716 + 16LL);
          if (!sub_1000343B4( v732,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3917LL,  v67,  v68,  v69,  v70,  v71)) {
            sub_100061FB4("can't allocate expression", v733, v734, v735, v736, v737, v738, v739, v759);
          }
          uint64_t v740 = *v732;
          *(_DWORD *)(v740 + 4) = 44;
          v741 = (void *)(*v732 + 16LL);
          if (!sub_1000343B4( v741,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3929LL,  v67,  v68,  v69,  v70,  v71)) {
            sub_100061FB4("can't allocate expression", v742, v743, v744, v745, v746, v747, v748, v759);
          }
          uint64_t v749 = *v741;
          *(_DWORD *)(v749 + 4) = 44;
          if (v15 != 412) {
            goto LABEL_292;
          }
          v750 = (uint64_t *)(*v741 + 16LL);
          if (!sub_1000343B4( v750,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3942LL,  v67,  v68,  v69,  v70,  v71)) {
            sub_100061FB4("can't allocate expression", v751, v752, v753, v754, v755, v756, v757, v759);
          }
          uint64_t v758 = *v750;
          *(_DWORD *)(v758 + 4) = 44;
          goto LABEL_292;
        case 413:
          sub_100036D00(&__s2, 0LL, (uint64_t)a2);
          if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  4181LL,  v395,  v396,  v397,  v398,  v399)) {
            sub_100061FB4("can't allocate expression", v400, v401, v402, v403, v404, v405, v406, v759);
          }
          uint64_t v46 = *a1;
          int v47 = 31;
          goto LABEL_245;
        case 414:
          sub_100036D00(&__s2, 0LL, (uint64_t)a2);
          if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3551LL,  v407,  v408,  v409,  v410,  v411)) {
            sub_100061FB4("can't allocate expression", v412, v413, v414, v415, v416, v417, v418, v759);
          }
          uint64_t v46 = *a1;
          int v47 = 33;
          goto LABEL_245;
        case 418:
          sub_100036D00(&__s2, 0LL, (uint64_t)a2);
          if (sub_100036D00(&__s2, 0LL, (uint64_t)a2) != 262)
          {
            uint64_t v511 = "expecting string.";
            goto LABEL_231;
          }

          uint64_t v419 = __s2;
          if (!strcasecmp(__s2, "a"))
          {
            v658 = "ddns-fwd-name";
          }

          else
          {
            if (strcasecmp(v419, "ptr"))
            {
              sub_100046D6C((uint64_t)a2, "invalid DNS rrtype: %s", v420, v421, v422, v423, v424, v425, (char)v419);
              goto LABEL_279;
            }

            v658 = "ddns-rev-name";
          }

          if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  4227LL,  v245,  v246,  v247,  v248,  v249)) {
            sub_100061FB4("can't allocate expression", v659, v660, v661, v662, v663, v664, v665, v759);
          }
          *(_DWORD *)(*a1 + 4) = 41;
          *(void *)(*a1 + 8) = sub_10005CDE4(0xEuLL);
          v673 = *(void **)(*a1 + 8);
          if (!v673) {
            sub_100061FB4("can't allocate variable name.", v666, v667, v668, v669, v670, v671, v672, v759);
          }
          void *v673 = *(void *)v658;
          *(void *)((char *)v673 + 6) = *(void *)(v658 + 6);
          return 1LL;
        case 432:
          int v49 = 0;
          int v48 = 35;
          goto LABEL_177;
        case 433:
          sub_100036D00(&__s2, 0LL, (uint64_t)a2);
          if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3964LL,  v453,  v454,  v455,  v456,  v457)) {
            sub_100061FB4("can't allocate expression", v458, v459, v460, v461, v462, v463, v464, v759);
          }
          uint64_t v465 = *a1;
          v761 = (_DWORD *)v465;
          *(_DWORD *)(v465 + 4) = 32;
          break;
        case 437:
          goto LABEL_43;
        case 438:
          LODWORD(v761) = 0;
          goto LABEL_239;
        case 439:
          int v93 = 58;
          goto LABEL_238;
        case 440:
          int v93 = 27;
          goto LABEL_238;
        case 441:
          int v93 = 59;
          goto LABEL_238;
        case 442:
          int v93 = 52;
          goto LABEL_238;
        case 443:
          int v93 = 57;
          goto LABEL_238;
        case 444:
          int v93 = 54;
          goto LABEL_238;
        case 445:
          int v93 = 51;
          goto LABEL_238;
        case 446:
          int v93 = 55;
          goto LABEL_238;
        case 447:
          int v93 = 56;
          goto LABEL_238;
        case 448:
          sub_100036D00(&__s2, 0LL, (uint64_t)a2);
          if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  4188LL,  v480,  v481,  v482,  v483,  v484)) {
            sub_100061FB4("can't allocate expression", v485, v486, v487, v488, v489, v490, v491, v759);
          }
          uint64_t v46 = *a1;
          int v47 = 39;
          goto LABEL_245;
        case 450:
          sub_100036D00(&__s2, 0LL, (uint64_t)a2);
          if (sub_100036D00(&__s2, 0LL, (uint64_t)a2) - 266 <= 0xFFFFFFFD)
          {
            sub_100046D6C((uint64_t)a2, "%s can't be a variable name", v492, v493, v494, v495, v496, v497, (char)__s2);
            goto LABEL_278;
          }

          if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  4525LL,  v493,  v494,  v495,  v496,  v497)) {
            sub_100061FB4("can't allocate expression", v631, v632, v633, v634, v635, v636, v637, v759);
          }
          *(_DWORD *)(*a1 + 4) = 40;
          int v638 = strlen(__s2);
          *(void *)(*a1 + 8) = sub_10005CDE4((v638 + 1));
          v646 = *(char **)(*a1 + 8);
          if (!v646) {
            sub_100061FB4("can't allocate variable name", v639, v640, v641, v642, v643, v644, v645, v759);
          }
          strcpy(v646, __s2);
          goto LABEL_292;
        default:
          goto LABEL_247;
      }

      while (1)
      {
        int v243 = sub_100036D00(&__s2, 0LL, (uint64_t)a2);
        if (v243 != 44) {
          break;
        }
        if (!sub_1000343B4( (void *)v761 + 2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3992LL,  v245,  v246,  v247,  v248,  v249)) {
          sub_100061FB4("can't allocate expression", v472, v473, v474, v475, v476, v477, v478, v759);
        }
        uint64_t v479 = *((void *)v761 + 2);
        v761 = (_DWORD *)v479;
        *(_DWORD *)(v479 + 4) = 32;
        if (!sub_10004C8C8((uint64_t *)(v479 + 8), (uint64_t)a2, a3))
        {
LABEL_201:
          if (!*a3) {
            sub_100046D6C((uint64_t)a2, "expecting dns expression.", v466, v467, v468, v469, v470, v471, v759);
          }
          sub_100054390( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3982LL,  v467,  v468,  v469,  v470,  v471);
          goto LABEL_279;
        }
      }

LABEL_293:
      if (v243 != 41)
      {
LABEL_294:
        sub_100046D6C((uint64_t)a2, "right parenthesis expected.", v244, v245, v246, v247, v248, v249, v759);
        *a3 = 1;
        uint64_t v102 = a1;
        uint64_t v103 = 3627LL;
        goto LABEL_295;
      }

      return 1LL;
    }

    if (v8 > 596)
    {
      if (v8 != 597)
      {
        if (v8 == 617)
        {
          sub_100036D00(&__s2, 0LL, (uint64_t)a2);
          if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3661LL,  v498,  v499,  v500,  v501,  v502)) {
            sub_100061FB4("can't allocate expression", v503, v504, v505, v506, v507, v508, v509, v759);
          }
          uint64_t v91 = *a1;
          int v92 = 57;
          goto LABEL_224;
        }

        if (v8 == 618)
        {
          sub_100036D00(&__s2, 0LL, (uint64_t)a2);
          if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3679LL,  v79,  v80,  v81,  v82,  v83)) {
            sub_100061FB4("can't allocate expression", v84, v85, v86, v87, v88, v89, v90, v759);
          }
          uint64_t v91 = *a1;
          int v92 = 56;
LABEL_224:
          *(_DWORD *)(v91 + 4) = v92;
          if (sub_100036D00(&__s2, 0LL, (uint64_t)a2) == 40)
          {
            uint64_t v317 = (uint64_t *)(*a1 + 8);
LABEL_226:
            if (!sub_10004C02C(v317, (uint64_t)a2, a3))
            {
LABEL_227:
              sub_100054390( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3581LL,  v62,  v63,  v64,  v65,  v66);
              if (!*a3)
              {
                uint64_t v510 = "expecting data expression.";
                goto LABEL_277;
              }

              return 0LL;
            }

            goto LABEL_292;
          }

LABEL_229:
          sub_100054390( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3572LL,  v16,  v17,  v18,  v19,  v20);
LABEL_230:
          uint64_t v511 = "left parenthesis expected.";
LABEL_231:
          sub_100046D6C((uint64_t)a2, v511, v21, v22, v23, v24, v25, v26, v759);
LABEL_279:
          uint64_t v110 = 0LL;
          *a3 = 1;
          return v110;
        }

        goto LABEL_247;
      }

      int v93 = 5;
LABEL_238:
      LODWORD(v761) = v93;
LABEL_239:
      sub_100036D00(&__s2, 0LL, (uint64_t)a2);
      if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  4437LL,  v524,  v525,  v526,  v527,  v528)) {
        sub_100061FB4("can't allocate expression", v529, v530, v531, v532, v533, v534, v535, v759);
      }
      uint64_t v536 = *a1;
      *(_DWORD *)(v536 + 4) = 21;
      *(void *)(v536 + 8) = (int)v761;
      return 1LL;
    }

    if (v8 != 593)
    {
      if (v8 == 596)
      {
        int v93 = 3;
        goto LABEL_238;
      }

      goto LABEL_247;
    }

    sub_100036D00(&__s2, 0LL, (uint64_t)a2);
    if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  4160LL,  v537,  v538,  v539,  v540,  v541)) {
      sub_100061FB4("can't allocate expression", v542, v543, v544, v545, v546, v547, v548, v759);
    }
    uint64_t v46 = *a1;
    int v47 = 55;
LABEL_245:
    *(_DWORD *)(v46 + 4) = v47;
    return 1LL;
  }

  if (v8 > 306)
  {
    if (v8 <= 336)
    {
      switch(v8)
      {
        case 307:
          int v93 = 7;
          goto LABEL_238;
        case 313:
          int v93 = 2;
          goto LABEL_238;
        case 318:
LABEL_43:
          int v93 = 1;
          goto LABEL_238;
      }

      goto LABEL_247;
    }

    int v48 = 34;
    int v49 = 1;
    switch(v8)
    {
      case 337:
        sub_100036D00(&__s2, 0LL, (uint64_t)a2);
        if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3565LL,  v50,  v51,  v52,  v53,  v54)) {
          sub_100061FB4("can't allocate expression", v55, v56, v57, v58, v59, v60, v61, v759);
        }
        *(_DWORD *)(*a1 + 4) = 4;
        uint64_t v78 = (uint64_t *)(*a1 + 24);
LABEL_106:
LABEL_107:
        if (!*a3)
        {
          sub_100046D6C((uint64_t)a2, "expecting numeric expression.", v72, v73, v74, v75, v76, v77, v759);
          sub_100046C4C(a2, 0);
          *a3 = 1;
        }

        uint64_t v102 = a1;
        uint64_t v103 = 3610LL;
        goto LABEL_295;
      case 338:
        sub_100036D00(&__s2, 0LL, (uint64_t)a2);
        if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3634LL,  v123,  v124,  v125,  v126,  v127)) {
          sub_100061FB4("can't allocate expression", v128, v129, v130, v131, v132, v133, v134, v759);
        }
        *(_DWORD *)(*a1 + 4) = 5;
LABEL_104:
        uint64_t v78 = (uint64_t *)(*a1 + 16);
        goto LABEL_106;
      case 339:
        sub_100036D00(&__s2, 0LL, (uint64_t)a2);
        if (sub_100036D00(&__s2, 0LL, (uint64_t)a2) != 262)
        {
          uint64_t v510 = "string expected.";
          goto LABEL_277;
        }

        uint64_t v135 = &off_100088018;
        uint64_t v136 = __s2;
        do
        {
          uint64_t v135 = (uint64_t **)*v135;
          if (!v135)
          {
            uint64_t v511 = "unknown collection.";
            goto LABEL_231;
          }
        }

        while (strcmp((const char *)v135[1], v136));
        if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3476LL,  v22,  v23,  v24,  v25,  v26)) {
          sub_100061FB4("can't allocate expression", v137, v138, v139, v140, v141, v142, v143, v759);
        }
        uint64_t v144 = *a1;
        *(_DWORD *)(v144 + 4) = 2;
        *(void *)(v144 + 8) = v135;
        return 1LL;
      case 340:
        sub_100036D00(&__s2, 0LL, (uint64_t)a2);
        if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  4280LL,  v22,  v23,  v24,  v25,  v26)) {
          sub_100061FB4("can't allocate expression", v145, v146, v147, v148, v149, v150, v151, v759);
        }
        if (sub_10004C02C((uint64_t *)(*a1 + 8), (uint64_t)a2, a3))
        {
          if (sub_100036D00(&__s2, 0LL, (uint64_t)a2) != 44)
          {
            sub_100046D6C((uint64_t)a2, "comma expected.", v153, v154, v155, v156, v157, v158, v759);
            *a3 = 1;
            uint64_t v102 = a1;
            uint64_t v103 = 4299LL;
            goto LABEL_295;
          }

          if (sub_100036D00(&__s2, 0LL, (uint64_t)a2) != 263)
          {
            sub_100046D6C((uint64_t)a2, "number expected.", v159, v160, v161, v162, v163, v164, v759);
            *a3 = 1;
            uint64_t v102 = a1;
            uint64_t v103 = 4307LL;
            goto LABEL_295;
          }

          int v165 = atoi(__s2);
          switch(v165)
          {
            case 8:
              int v172 = 15;
              break;
            case 32:
              int v172 = 17;
              break;
            case 16:
              int v172 = 16;
              break;
            default:
              sub_100046D6C((uint64_t)a2, "unsupported integer size %d", v166, v167, v168, v169, v170, v171, v165);
              *a3 = 1;
              sub_100046C4C(a2, 0);
              uint64_t v102 = a1;
              uint64_t v103 = 4328LL;
              goto LABEL_295;
          }

          *(_DWORD *)(*a1 + 4) = v172;
          uint64_t v110 = 1LL;
          sub_100046D6C((uint64_t)a2, "right parenthesis expected.", v686, v687, v688, v689, v690, v691, v759);
          *a3 = 1;
          uint64_t v102 = a1;
          uint64_t v103 = 4336LL;
        }

        else
        {
          if (!*a3)
          {
            sub_100046D6C((uint64_t)a2, "expecting data expression.", v152, v73, v74, v75, v76, v77, v759);
            sub_100046C4C(a2, 0);
            *a3 = 1;
          }

          uint64_t v102 = a1;
          uint64_t v103 = 4291LL;
        }

        goto LABEL_295;
      case 341:
      case 343:
      case 344:
      case 345:
      case 346:
      case 347:
      case 348:
      case 349:
        goto LABEL_247;
      case 342:
        goto LABEL_177;
      case 350:
        if ((_DWORD)a4 != 4)
        {
          sub_100036D00(&__s2, 0LL, (uint64_t)a2);
          if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3534LL,  v597,  v598,  v599,  v600,  v601)) {
            sub_100061FB4("can't allocate expression", v602, v603, v604, v605, v606, v607, v608, v759);
          }
          uint64_t v609 = *a1;
          *(_DWORD *)(v609 + 4) = 22;
          LODWORD(v761) = 0;
          if (sub_1000487D4(a2, 0, &v761, (void *)(v609 + 8)) || !*(void *)(*a1 + 8))
          {
            *a3 = 1;
            uint64_t v102 = a1;
            uint64_t v103 = 3544LL;
LABEL_295:
            sub_100054390( v102,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  v103,  v73,  v74,  v75,  v76,  v77);
            return 0LL;
          }

          return 1LL;
        }

        int v49 = 0;
        int v48 = 36;
LABEL_177:
        sub_100036D00(&__s2, 0LL, (uint64_t)a2);
        if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  4028LL,  v426,  v427,  v428,  v429,  v430)) {
          sub_100061FB4("can't allocate expression", v431, v432, v433, v434, v435, v436, v437, v759);
        }
        *(_DWORD *)(*a1 + 4) = v48;
        unsigned int v438 = sub_100036D00(&__s2, 0LL, (uint64_t)a2);
        BOOL v447 = v438 > 0xFF && v438 - 264 < 0xFFFFFFFE && v438 != 607;
        if (v438 != 263 && !v447) {
          goto LABEL_191;
        }
        uint64_t v595 = __s2;
        if (v438 == 263)
        {
          int v596 = atoi(__s2);
        }

        else if (!strcasecmp(__s2, "in"))
        {
          int v596 = 1;
        }

        else if (!strcasecmp(v595, "chaos"))
        {
          int v596 = 3;
        }

        else
        {
          if (strcasecmp(v595, "hs"))
          {
            sub_100046D6C((uint64_t)a2, "unexpected rrclass: %s", v625, v626, v627, v628, v629, v630, (char)v595);
            goto LABEL_192;
          }

          int v596 = 4;
        }

        *(_DWORD *)(*a1 + 8) = v596;
        if (sub_100036D00(&__s2, 0LL, (uint64_t)a2) != 44)
        {
LABEL_407:
          sub_100054390( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3594LL,  v67,  v68,  v69,  v70,  v71);
          uint64_t v511 = "comma expected.";
          goto LABEL_231;
        }

        unsigned int v674 = sub_100036D00(&__s2, 0LL, (uint64_t)a2);
        BOOL v677 = v674 > 0xFF && v674 - 264 < 0xFFFFFFFE && v674 != 607;
        if (v674 == 263 || v677)
        {
          v678 = __s2;
          if (v674 == 263)
          {
            int v679 = atoi(__s2);
LABEL_398:
            *(_DWORD *)(*a1 + 12) = v679;
            if (sub_100036D00(&__s2, 0LL, (uint64_t)a2) == 44)
            {
              if (sub_100036D00(&__s2, 0LL, (uint64_t)a2) == 44)
              {
                if (!v49)
                {
LABEL_292:
                  int v243 = sub_100036D00(&__s2, 0LL, (uint64_t)a2);
                  goto LABEL_293;
                }

                if (sub_100036D00(&__s2, 0LL, (uint64_t)a2) == 44)
                {
                  if (!sub_10004C82C((uint64_t *)(*a1 + 32), (uint64_t)a2, a3))
                  {
                    if (*a3) {
                      goto LABEL_278;
                    }
LABEL_392:
                    uint64_t v510 = "expecting numeric expression.";
LABEL_277:
                    sub_100046D6C((uint64_t)a2, v510, v21, v22, v23, v24, v25, v26, v759);
LABEL_278:
                    sub_100046C4C(a2, 0);
                    goto LABEL_279;
                  }

                  goto LABEL_292;
                }
              }
            }

            goto LABEL_407;
          }

          if (!strcasecmp(__s2, "a"))
          {
            int v679 = 1;
            goto LABEL_398;
          }

          if (!strcasecmp(v678, "aaaa"))
          {
            int v679 = 28;
            goto LABEL_398;
          }

          if (!strcasecmp(v678, "ptr"))
          {
            int v679 = 12;
            goto LABEL_398;
          }

          if (!strcasecmp(v678, "mx"))
          {
            int v679 = 15;
            goto LABEL_398;
          }

          if (!strcasecmp(v678, "cname"))
          {
            int v679 = 5;
            goto LABEL_398;
          }

          if (!strcasecmp(v678, "TXT"))
          {
            int v679 = 16;
            goto LABEL_398;
          }

          sub_100046D6C((uint64_t)a2, "unexpected rrtype: %s", v680, v681, v682, v683, v684, v685, (char)v678);
        }

        else
        {
LABEL_191:
          sub_100046D6C((uint64_t)a2, "expecting identifier or number.", v439, v440, v441, v442, v443, v444, v759);
        }

LABEL_192:
        sub_100054390( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  4040LL,  v448,  v449,  v450,  v451,  v452);
        goto LABEL_278;
      default:
        if (v8 != 354) {
          goto LABEL_247;
        }
        sub_100036D00(&__s2, 0LL, (uint64_t)a2);
        if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  3558LL,  v111,  v112,  v113,  v114,  v115)) {
          sub_100061FB4("can't allocate expression", v116, v117, v118, v119, v120, v121, v122, v759);
        }
        uint64_t v46 = *a1;
        int v47 = 24;
        goto LABEL_245;
    }
  }

  if (v8 <= 284)
  {
    switch(v8)
    {
      case 257:
        sub_100036D00(&__s2, 0LL, (uint64_t)a2);
        if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  4146LL,  v34,  v35,  v36,  v37,  v38)) {
          sub_100061FB4("can't allocate expression", v39, v40, v41, v42, v43, v44, v45, v759);
        }
        uint64_t v46 = *a1;
        int v47 = 12;
        goto LABEL_245;
      case 258:
        sub_100036D00(&__s2, 0LL, (uint64_t)a2);
        if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  4167LL,  v173,  v174,  v175,  v176,  v177)) {
          sub_100061FB4("can't allocate expression", v178, v179, v180, v181, v182, v183, v184, v759);
        }
        uint64_t v46 = *a1;
        int v47 = 42;
        goto LABEL_245;
      case 259:
      case 261:
      case 265:
      case 266:
      case 267:
      case 268:
      case 269:
      case 270:
      case 271:
      case 272:
        goto LABEL_247;
      case 260:
LABEL_47:
        if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  4126LL,  v9,  v10,  v11,  v12,  v13)) {
          sub_100061FB4("can't allocate expression", v94, v95, v96, v97, v98, v99, v100, v759);
        }
        if (v14 == 260) {
          int v101 = 11;
        }
        else {
          int v101 = 28;
        }
        *(_DWORD *)(*a1 + 4) = v101;
        sub_100036D00(&__s2, 0LL, (uint64_t)a2);
        LODWORD(v761) = 0;
        *a3 = 1;
        uint64_t v102 = a1;
        uint64_t v103 = 4139LL;
        goto LABEL_295;
      case 262:
        sub_100036D00(&__s2, &v761, (uint64_t)a2);
        uint64_t v110 = 1LL;
        if (!sub_1000545BC( a1,  __s2,  (int)v761,  1LL,  1LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  4267LL,  v185)) {
          sub_100061FB4("can't make constant string expression.", v186, v187, v188, v189, v190, v191, v192, v759);
        }
        return v110;
      case 263:
        if ((_DWORD)a4 != 5 && (_DWORD)a4 != 3) {
          goto LABEL_96;
        }
        sub_100036D00(&__s2, 0LL, (uint64_t)a2);
        if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  4414LL,  v193,  v194,  v195,  v196,  v197)) {
          sub_100061FB4("can't allocate expression", v198, v199, v200, v201, v202, v203, v204, v759);
        }
        uint64_t v205 = *a1;
        *(_DWORD *)(v205 + 4) = 21;
        *(void *)(v205 + 8) = atoi(__s2);
        return 1LL;
      case 264:
LABEL_96:
        if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  4422LL,  v9,  v10,  v11,  v12,  v13)) {
          sub_100061FB4("can't allocate expression", v206, v207, v208, v209, v210, v211, v212, v759);
        }
        uint64_t v213 = *a1;
        *(_DWORD *)(v213 + 4) = 14;
        uint64_t v102 = a1;
        uint64_t v103 = 4427LL;
        goto LABEL_295;
      case 273:
        sub_100036D00(&__s2, 0LL, (uint64_t)a2);
        if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  4239LL,  v214,  v215,  v216,  v217,  v218)) {
          sub_100061FB4("can't allocate expression", v219, v220, v221, v222, v223, v224, v225, v759);
        }
        *(_DWORD *)(*a1 + 4) = 13;
        goto LABEL_107;
      default:
        if (v8 != 40) {
          goto LABEL_247;
        }
        sub_100036D00(&__s2, 0LL, (uint64_t)a2);
        if (sub_10004BA40(a1, a2, a3, a4, 0LL, 0LL))
        {
          uint64_t v110 = 1LL;
          *a3 = 1;
          sub_100046D6C((uint64_t)a2, "right paren expected", v104, v105, v106, v107, v108, v109, v759);
          sub_100046C4C(a2, 0);
          return 0LL;
        }

        if (*a3) {
          goto LABEL_279;
        }
        uint64_t v510 = "expression expected";
        break;
    }

    goto LABEL_277;
  }

  switch(v8)
  {
    case 285:
      sub_100036D00(&__s2, 0LL, (uint64_t)a2);
      if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  4174LL,  v512,  v513,  v514,  v515,  v516)) {
        sub_100061FB4("can't allocate expression", v517, v518, v519, v520, v521, v522, v523, v759);
      }
      uint64_t v46 = *a1;
      int v47 = 43;
      goto LABEL_245;
    case 299:
      int v93 = 4;
      goto LABEL_238;
    case 306:
      int v93 = 6;
      goto LABEL_238;
  }

LABEL_247:
  sub_100036D00(&__s2, 0LL, (uint64_t)a2);
  int v549 = strlen(__s2);
  uint64_t v550 = (char *)sub_10005CDE4((v549 + 1));
  uint64_t v558 = v550;
  if (!v550) {
    sub_100061FB4("can't allocate variable name", v551, v552, v553, v554, v555, v556, v557, v759);
  }
  strcpy(v550, __s2);
  if (sub_1000374AC(&__s2, 0LL, a2) == 40)
  {
    sub_100036D00(&__s2, 0LL, (uint64_t)a2);
    if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  4561LL,  v564,  v565,  v566,  v567,  v568)) {
      sub_100061FB4("can't allocate expression", v569, v570, v571, v572, v573, v574, v575, v759);
    }
    uint64_t v576 = *a1;
    *(_DWORD *)(v576 + 4) = 45;
    *(void *)(v576 + 8) = v558;
    uint64_t v577 = *a1;
    do
    {
      uint64_t v578 = (uint64_t *)(v577 + 16);
      if (!sub_1000343B4( v578,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  4569LL,  v571,  v572,  v573,  v574,  v575)) {
        sub_100061FB4("can't allocate expression", v579, v580, v581, v582, v583, v584, v585, v759);
      }
      uint64_t v586 = *v578;
      *(_DWORD *)(v586 + 4) = 44;
      if (!sub_10004BA40(v586 + 8, a2, a3, 0LL, 0LL, 0LL))
      {
        if (!*a3)
        {
          sub_100046D6C((uint64_t)a2, "expecting expression.", v587, v588, v589, v590, v591, v592, v759);
          *a3 = 1;
        }

        sub_100046C4C(a2, 0);
        uint64_t v102 = a1;
        uint64_t v103 = 4582LL;
        goto LABEL_295;
      }

      uint64_t v577 = *v578;
      int v593 = sub_100036D00(&__s2, 0LL, (uint64_t)a2);
    }

    while (v593 == 44);
    if (v593 == 41) {
      return 1LL;
    }
    sub_100046D6C((uint64_t)a2, "Right parenthesis expected.", v594, v571, v572, v573, v574, v575, v759);
    sub_100046C4C(a2, 0);
    *a3 = 1;
    uint64_t v102 = a1;
    uint64_t v103 = 4592LL;
    goto LABEL_295;
  }

  if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  4553LL,  v559,  v560,  v561,  v562,  v563)) {
    sub_100061FB4("can't allocate expression", v648, v649, v650, v651, v652, v653, v654, v759);
  }
  uint64_t v655 = *a1;
  *(_DWORD *)(v655 + 4) = 41;
  *(void *)(v655 + 8) = v558;
  return 1LL;
}

uint64_t sub_10004E968( void *a1, int32x2_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12 = 0LL;
  uint64_t v13 = 0LL;
  uint64_t v24 = 0LL;
  while (2)
  {
    int v14 = *(const char **)(a4 + 8);
    if (!v12) {
      goto LABEL_7;
    }
    int v15 = *(unsigned __int8 *)v12;
    if (v12 != v14 && v15 == 97)
    {
      uint64_t v24 = --v12;
      goto LABEL_8;
    }

    if (v15 == 65)
    {
LABEL_7:
      uint64_t v24 = *(const char **)(a4 + 8);
      uint64_t v12 = v14;
    }

uint64_t sub_10004EB38( void *a1, int32x2_t *a2, const char **a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v81 = 0LL;
  uint64_t v12 = *a3;
  int v13 = **a3;
  if (v13 > 107)
  {
    switch(v13)
    {
      case 'l':
LABEL_17:
        int v29 = sub_100036D00(v82, 0LL, (uint64_t)a2);
LABEL_18:
        if ((v29 - 265) > 0xFFFFFFFD)
        {
          sub_100047FD0(a2, &v80, (unsigned __int8 *)v82[0], 0LL, 32LL, v18, v19, v20);
          uint64_t v30 = &v80;
          int v31 = 4;
          uint64_t v32 = 5261LL;
LABEL_22:
          uint64_t result = sub_1000545BC( (uint64_t *)&v81,  v30,  v31,  0LL,  1LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  v32,  a8);
          if (!(_DWORD)result) {
            return result;
          }
          goto LABEL_23;
        }

        break;
      case 's':
LABEL_12:
        int v29 = sub_100036D00(v82, 0LL, (uint64_t)a2);
        if ((v29 - 265) >= 0xFFFFFFFE)
        {
          sub_100047FD0(a2, &v80, (unsigned __int8 *)v82[0], 0LL, 16LL, v18, v19, v20);
          uint64_t v30 = &v80;
          int v31 = 2;
          uint64_t v32 = 5271LL;
          goto LABEL_22;
        }

        break;
      case 't':
        unsigned int v14 = sub_100036D00(v82, &v80, (uint64_t)a2);
        if (v14 != 262)
        {
          int v29 = v14;
          if (v14 < 0x100 || v14 == 607 || v14 == 263)
          {
            if ((*a3)[1] == 111) {
              return 0LL;
            }
            uint64_t v33 = "expecting string.";
            goto LABEL_45;
          }
        }

        int v21 = 0;
LABEL_7:
        if (!sub_1000545BC( (uint64_t *)&v81,  v82[0],  v80,  1LL,  1LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  5182LL,  v20)) {
          sub_100061FB4("No memory for concatenation", v22, v23, v24, v25, v26, v27, v28, v79);
        }
        if (v21) {
          sub_10005CE20( v82[0],  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  5185LL,  v24,  v25,  v26,  v27,  v28);
        }
LABEL_23:
        if (a4)
        {
          uint64_t result = sub_10005470C(a1, a4, v81, v24, v25, v26, v27, v28);
          if (!(_DWORD)result) {
            return result;
          }
        }

        else
        {
          sub_100033F18( a1,  v81,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  5340LL,  v25,  v26,  v27,  v28);
        }

        sub_100054390( (uint64_t *)&v81,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  5341LL,  v35,  v36,  v37,  v38,  v39);
        return 1LL;
      default:
LABEL_36:
        char v79 = **a3;
        uint64_t v40 = "Bad format '%c' in parse_option_token.";
LABEL_37:
        sub_100046D6C((uint64_t)a2, v40, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, v79);
        goto LABEL_46;
    }

uint64_t sub_10004F3A8()
{
  uint64_t v0 = __chkstk_darwin();
  int v2 = v1;
  uint64_t v3 = (int32x2_t *)v0;
  uint64_t v30 = 0LL;
  bzero(v35, 0xFF00uLL);
  bzero(&v33, 0x7F8uLL);
  char v4 = 0;
  unsigned int v5 = 0;
  uint64_t v32 = v35;
  do
  {
    if ((v4 & 1) != 0) {
      sub_100036D00(&v31, 0LL, (uint64_t)v3);
    }
    if (sub_100036D00(&v31, &v29, (uint64_t)v3) != 262)
    {
      uint64_t v27 = "Expecting a domain string.";
      goto LABEL_21;
    }

    uint64_t v12 = &v35[v5];
    uint64_t v13 = 65280LL - v5;
    if (v2)
    {
      int v14 = sub_10006A62C(v31, &v35[v5], v13, &v32, (uint64_t)&v34);
      if ((v14 & 0x80000000) == 0)
      {
        v5 += v14;
        goto LABEL_12;
      }

      uint64_t v27 = "Error compressing domain list: %m";
LABEL_21:
      sub_100046D6C((uint64_t)v3, v27, v6, v7, v8, v9, v10, v11, v28);
      return 0LL;
    }

    if ((sub_100069F44(v31, &v35[v5], v13) & 0x80000000) != 0)
    {
      uint64_t v27 = "Error assembling domain list: %m";
      goto LABEL_21;
    }

    int v16 = *v12;
    if (*v12)
    {
      do
      {
        v5 += v16 + 1;
        int v16 = v35[v5];
      }

      while (v35[v5]);
    }

    ++v5;
LABEL_12:
    if (v5 >= 0xFF01) {
      sub_100061FB4( "Impossible error at %s:%d",  v15,  v6,  v7,  v8,  v9,  v10,  v11,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c");
    }
    int v17 = sub_1000374AC(&v31, 0LL, v3);
    char v4 = 1;
  }

  while (v17 == 44);
  if (!sub_1000545BC( &v30,  v35,  v5,  1LL,  1LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  5804LL,  v18)) {
    sub_100061FB4("No memory for domain list object.", v19, v20, v21, v22, v23, v24, v25, v28);
  }
  return v30;
}

uint64_t sub_10004F5A0(void *a1, int32x2_t *a2)
{
  uint64_t v72 = 0LL;
  int v69 = 0;
  uint64_t v68 = 0LL;
  uint64_t v11 = 0LL;
  int v12 = 0;
  int v67 = 0;
  do
  {
    for (uint64_t i = *(char **)(v72 + 8); ; ++i)
    {
      int v14 = *i;
      if (v14 == 111)
      {
        LOBYTE(v14) = 111;
LABEL_79:
        sub_10006221C("parse_option_param: Bad format %c", v4, v5, v6, v7, v8, v9, v10, v14);
        goto LABEL_97;
      }

      if (!*i || v14 == 65) {
        break;
      }
      if ((char)v14 <= 87)
      {
        switch((char)v14)
        {
          case 'B':
            goto LABEL_27;
          case 'C':
          case 'F':
          case 'G':
          case 'H':
          case 'J':
          case 'K':
          case 'M':
            goto LABEL_79;
          case 'D':
            if (i[1] == 99) {
              ++i;
            }
            uint64_t v15 = sub_10004F3A8();
            uint64_t v68 = v15;
            if (!v15) {
              goto LABEL_100;
            }
            if (*(_DWORD *)(v15 + 4) != 14)
            {
              uint64_t v63 = "unexpected expression";
              goto LABEL_96;
            }

            size_t v5 = *(unsigned int *)(v15 + 24);
            unsigned int v71 = v5;
            int v16 = v5 + v12;
            if ((v5 + v12) >= 0x401)
            {
              uint64_t v63 = "option data buffer overflow";
              goto LABEL_96;
            }

            memcpy(&__src[v12], *(const void **)(v15 + 16), v5);
            sub_100054390( &v68,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  5448LL,  v17,  v18,  v19,  v20,  v21);
            goto LABEL_65;
          case 'E':
            uint64_t i = strchr(i, 46);
            if (i) {
              goto LABEL_41;
            }
            uint64_t v64 = "encapsulation format";
            goto LABEL_89;
          case 'I':
            unsigned int v75 = 4;
            if (!sub_100047540(a2, v76, &v75, 46, 10LL, 8LL)) {
              goto LABEL_100;
            }
            goto LABEL_61;
          case 'L':
            goto LABEL_22;
          case 'N':
            int v31 = strchr(i, 46);
            if (v31)
            {
              uint64_t v32 = v31;
              int v33 = sub_100036D00(&v74, 0LL, (uint64_t)a2);
              if (v33 < 256 || (v33 - 262) < 2 || v33 == 607)
              {
                uint64_t v63 = "identifier expected";
                goto LABEL_96;
              }

              uint64_t v34 = sub_100046BE8(i + 1, (int)v32 - ((int)i + 1), &v71, v74);
              if (!v34)
              {
                uint64_t v63 = "unknown value";
                goto LABEL_96;
              }

              uint64_t v23 = (int *)(v34 + 1);
              unsigned int v24 = v71;
              uint64_t i = v32;
              goto LABEL_68;
            }

            uint64_t v64 = "enumeration format";
LABEL_89:
            sub_100046D6C((uint64_t)a2, "malformed %s (bug!)", v25, v26, v27, v28, v29, v30, (char)v64);
            break;
          default:
            if ((char)v14 != 54)
            {
              goto LABEL_37;
            }

LABEL_61:
            unsigned int v24 = v75;
            unsigned int v71 = v75;
            uint64_t v23 = v76;
            goto LABEL_68;
        }

  while (v40[0])
    sub_10006C368(v40, v40[0]);
LABEL_62:
  *(void *)(a1 + 384) = v18;
  if (a9) {
    *a9 = v39;
  }
  return v19;
}

LABEL_97:
        if (v68) {
          sub_100054390( &v68,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/parse.c",  5616LL,  v6,  v7,  v8,  v9,  v10);
        }
        sub_100046C4C(a2, 0);
LABEL_100:
        uint64_t v11 = 0LL;
        uint64_t v61 = 5619LL;
        goto LABEL_101;
      }

      if ((char)v14 <= 101)
      {
        if ((char)v14 == 88)
        {
LABEL_41:
          unsigned int v71 = sub_10004FC98(a2, &__src[v12], 1024 - v12);
          v12 += v71;
          continue;
        }

        if ((char)v14 != 90)
        {
LABEL_27:
          int v22 = sub_100036D00(&v74, 0LL, (uint64_t)a2);
          if ((v22 - 265) < 0xFFFFFFFE)
          {
LABEL_81:
            int v36 = v22;
            uint64_t v62 = "expecting number.";
            goto LABEL_82;
          }

          uint64_t v23 = &v73;
          sub_100047FD0(a2, &v73, (unsigned __int8 *)v74, 0LL, 8LL, v8, v9, v10);
          unsigned int v24 = 1;
LABEL_39:
          unsigned int v71 = v24;
LABEL_68:
          if (v24 + v12 < 0x401)
          {
            memcpy(&__src[v12], v23, v24);
            v12 += v24;
            continue;
          }

uint64_t sub_10004FC98(int32x2_t *a1, char *a2, unsigned int a3)
{
  int v6 = sub_1000374AC(&__src, 0LL, a1);
  if ((v6 - 263) > 1)
  {
    if (v6 == 262)
    {
      sub_100036D00(&__src, &v19, (uint64_t)a1);
      uint64_t v14 = v19;
      size_t v7 = v19 + 1;
      if (v7 <= a3)
      {
        memcpy(a2, __src, v7);
        return v14;
      }

      int v16 = "string constant too long.";
    }

    else
    {
      int v16 = "expecting string or hexadecimal data";
    }
  }

  else
  {
    uint64_t v13 = 1LL;
    while (1)
    {
      uint64_t v14 = v13;
      if (sub_100036D00(&__src, 0LL, (uint64_t)a1) - 265 <= 0xFFFFFFFD)
      {
        int v16 = "expecting hexadecimal constant.";
        goto LABEL_14;
      }

      sub_100047FD0(a1, &a2[(v14 - 1)], (unsigned __int8 *)__src, 16LL, 8LL, v10, v11, v12);
      if (sub_1000374AC(&__src, 0LL, a1) == 58)
      {
        int v15 = sub_100036D00(&__src, 0LL, (uint64_t)a1);
        uint64_t v13 = (v14 + 1);
        if (v15 == 58) {
          continue;
        }
      }

      return v14;
    }

    int v16 = "hexadecimal constant too long.";
  }

char *sub_10004FDF0(unsigned __int8 *a1)
{
  if (a1)
  {
    int v1 = a1;
    int v2 = 0;
    for (uint64_t i = a1; ; ++i)
    {
      uint64_t v4 = *i;
      if ((_DWORD)v4 == 32)
      {
        int v5 = 1;
      }

      else
      {
        if (!*i)
        {
          size_t v7 = (char *)sub_10005CDE4((v2 + 1));
          uint64_t v8 = v7;
          if (v7)
          {
            uint64_t v9 = v7;
            while (1)
            {
              uint64_t v10 = *v1;
              if ((_DWORD)v10 == 32)
              {
                *v9++ = 32;
              }

              else
              {
                if (!*v1) {
                  goto LABEL_30;
                }
                if (((char)v10 & 0x80000000) == 0 && (_DefaultRuneLocale.__runetype[v10] & 0x40000) != 0)
                {
                  if ((_DWORD)v10 == 92 || (_DWORD)v10 == 34)
                  {
                    *uint64_t v9 = 92;
                    v9[1] = *v1;
                    v9 += 2;
                  }

                  else
                  {
                    *v9++ = v10;
                  }
                }

                else
                {
                  sprintf(v9, "\\%03o", *v1);
                  v9 += 4;
                }
              }

              ++v1;
            }
          }

          return v8;
        }

        if ((v4 & 0x80) == 0 && (_DefaultRuneLocale.__runetype[v4] & 0x40000) != 0)
        {
          if ((_DWORD)v4 == 92 || (_DWORD)v4 == 34) {
            int v5 = 2;
          }
          else {
            int v5 = 1;
          }
        }

        else
        {
          int v5 = 4;
        }
      }

      v2 += v5;
    }
  }

  uint64_t v8 = (char *)sub_10005CDE4(1uLL);
  uint64_t v9 = v8;
  if (v8) {
LABEL_30:
  }
    *uint64_t v9 = 0;
  return v8;
}

char *sub_10004FF50(unsigned __int8 *a1, unsigned int a2)
{
  if (a2)
  {
    int v2 = a1;
    int v3 = 0;
    uint64_t v4 = a2;
    uint64_t v5 = a2;
    int v6 = a1;
    do
    {
      unsigned int v8 = *v6++;
      uint64_t v7 = v8;
      if (v8 == 32)
      {
        int v9 = 1;
      }

      else if ((v7 & 0x80) == 0 && (_DefaultRuneLocale.__runetype[v7] & 0x40000) != 0)
      {
        if ((_DWORD)v7 == 92 || (_DWORD)v7 == 34) {
          int v9 = 2;
        }
        else {
          int v9 = 1;
        }
      }

      else
      {
        int v9 = 4;
      }

      v3 += v9;
      --v5;
    }

    while (v5);
    uint64_t v11 = (char *)sub_10005CDE4((v3 + 1));
    uint64_t v12 = v11;
    if (v11)
    {
      uint64_t v13 = v11;
      do
      {
        uint64_t v14 = *v2;
        if ((_DWORD)v14 == 32)
        {
          *v13++ = 32;
        }

        else if ((v14 & 0x80) == 0 && (_DefaultRuneLocale.__runetype[v14] & 0x40000) != 0)
        {
          if ((_DWORD)v14 == 92 || (_DWORD)v14 == 34)
          {
            *uint64_t v13 = 92;
            v13[1] = *v2;
            v13 += 2;
          }

          else
          {
            *v13++ = v14;
          }
        }

        else
        {
          sprintf(v13, "\\%03o", *v2);
          v13 += 4;
        }

        ++v2;
        --v4;
      }

      while (v4);
      goto LABEL_29;
    }
  }

  else
  {
    uint64_t v12 = (char *)sub_10005CDE4(1uLL);
    uint64_t v13 = v12;
    if (v12) {
LABEL_29:
    }
      *uint64_t v13 = 0;
  }

  return v12;
}

char *sub_1000500C0(uint64_t a1, unsigned int a2)
{
  unsigned int v4 = ((4 * a2) | 2) / 3;
  uint64_t result = (char *)sub_10005CDE4(v4 + 2);
  if (result)
  {
    if (a2)
    {
      uint64_t v6 = a2;
      uint64_t v7 = (unsigned __int8 *)(a1 + 2);
      unsigned int v8 = result;
      while (1)
      {
        unint64_t v9 = *(v7 - 2);
        int v10 = v9 & 3;
        *unsigned int v8 = aAbcdefghijklmn[v9 >> 2];
        if (v6 == 1)
        {
          int v17 = 16 * v10;
          char v18 = v8 + 1;
          uint64_t v19 = 3LL;
          uint64_t v20 = 2LL;
          goto LABEL_11;
        }

        int v11 = *(v7 - 1);
        unint64_t v12 = v11 | (v10 << 8);
        int v13 = v11 & 0xF;
        v8[1] = aAbcdefghijklmn[v12 >> 4];
        if (v6 == 2) {
          break;
        }
        int v14 = *v7;
        v7 += 3;
        v8[2] = aAbcdefghijklmn[(unint64_t)(v14 | (v13 << 8)) >> 6];
        int v15 = v8 + 4;
        _OWORD v8[3] = aAbcdefghijklmn[v14 & 0x3F];
        v8 += 4;
        v6 -= 3LL;
        if (!v6) {
          goto LABEL_13;
        }
      }

      int v17 = 4 * v13;
      char v18 = v8 + 2;
      uint64_t v19 = 4LL;
      uint64_t v20 = 3LL;
LABEL_11:
      int v16 = &v8[v20];
      *char v18 = aAbcdefghijklmn[v17];
      int v15 = &v8[v19];
    }

    else
    {
      int v15 = result + 1;
      int v16 = result;
    }

    *int v16 = 61;
LABEL_13:
    *int v15 = 0;
    if (v15 > &result[v4 + 1]) {
      abort();
    }
  }

  return result;
}

char *sub_1000501FC(uint64_t a1, int a2, unsigned __int8 *a3)
{
  if (a2 < 1)
  {
    uint64_t v7 = &byte_1000C53C0;
  }

  else
  {
    uint64_t v4 = a2;
    uint64_t v5 = &byte_1000C53C0;
    do
    {
      int v6 = *a3++;
      sprintf(v5, "%02x", v6);
      uint64_t v7 = &v5[strlen(v5)];
      *uint64_t v7 = 58;
      uint64_t v5 = v7 + 1;
      --v4;
    }

    while (v4);
  }

  *uint64_t v7 = 0;
  return &byte_1000C53C0;
}

uint64_t sub_100050298( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(_OWORD *)uint64_t v51 = *(_OWORD *)(a1 + 56);
  int v52 = *(_DWORD *)(a1 + 72);
  char v9 = sub_100040144((int *)v51, a2, a3, a4, a5, a6, a7, a8);
  sub_10006238C("  Lease %s", v10, v11, v12, v13, v14, v15, v16, v9);
  int v17 = gmtime((const time_t *)(a1 + 80));
  strftime(v51, 0x20uLL, "%Y/%m/%d %H:%M:%S", v17);
  sub_10006238C("  start %s", v18, v19, v20, v21, v22, v23, v24, (char)v51);
  uint64_t v25 = gmtime((const time_t *)(a1 + 88));
  strftime(v51, 0x20uLL, "%Y/%m/%d %H:%M:%S", v25);
  uint64_t v33 = sub_10006238C("  end %s", v26, v27, v28, v29, v30, v31, v32, (char)v51);
  if (*(_BYTE *)(a1 + 203))
  {
    sub_1000501FC(v33, *(unsigned __int8 *)(a1 + 203) - 1, (unsigned __int8 *)(a1 + 205));
    sub_10006238C("    hardware addr = %s", v41, v42, v43, v44, v45, v46, v47, (char)&byte_1000C53C0);
  }

  uint64_t v48 = *(void *)(a1 + 120);
  if (v48) {
    uint64_t v49 = *(const char **)(v48 + 48);
  }
  else {
    uint64_t v49 = "<none>";
  }
  return sub_10006238C("  host %s  ", v34, v35, v36, v37, v38, v39, v40, (char)v49);
}

uint64_t sub_1000503D0( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)&__int128 v8 = 0x2020202020202020LL;
  *((void *)&v8 + 1) = 0x2020202020202020LL;
  *(_OWORD *)&v22[15] = v8;
  __int128 v21 = v8;
  *(_OWORD *)uint64_t v22 = v8;
  *(_OWORD *)uint64_t v19 = v8;
  __int128 v20 = v8;
  char v23 = 0;
  if ((_DWORD)a2)
  {
    uint64_t v10 = 0LL;
    int v11 = 0;
    uint64_t v12 = a2;
    do
    {
      if ((v10 & 0xF) != 0)
      {
        if ((v10 & 7) == 0) {
          v19[v11++] = 32;
        }
      }

      else
      {
        if (v11)
        {
          memset(&v22[5], 32, 3);
          v22[25] = 0;
          sub_1000622D4("%s", a2, a3, a4, a5, a6, a7, a8, (char)v19);
        }

        *(void *)&__int128 v13 = 0x2020202020202020LL;
        *((void *)&v13 + 1) = 0x2020202020202020LL;
        *(_OWORD *)&v22[15] = v13;
        __int128 v21 = v13;
        *(_OWORD *)uint64_t v22 = v13;
        *(_OWORD *)uint64_t v19 = v13;
        __int128 v20 = v13;
        char v23 = 0;
        __sprintf_chk(v19, 0, 0x50uLL, "%03x:", v10);
        int v11 = 4;
      }

      uint64_t v14 = *(unsigned __int8 *)(a1 + v10);
      else {
        __uint32_t v15 = _DefaultRuneLocale.__runetype[v14] & 0x40000;
      }
      if (v15) {
        char v16 = v14;
      }
      else {
        char v16 = 46;
      }
      *(_BYTE *)((v10 & 0xF | (unint64_t)v19) + 0x38) = v16;
      uint64_t v17 = v11;
      sprintf(&v19[v11], " %02x", *(unsigned __int8 *)(a1 + v10));
      v11 += 3;
      v19[v17 + 3] = 32;
      ++v10;
    }

    while (v12 != v10);
  }

  memset(&v22[5], 32, 3);
  v22[25] = 0;
  return sub_1000622D4("%s", a2, a3, a4, a5, a6, a7, a8, (char)v19);
}

unsigned int *sub_100050584( unsigned int *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    __int128 v8 = result;
    if (*result)
    {
      unint64_t v9 = 0LL;
      do
      {
        uint64_t v10 = &v8[2 * v9];
        uint64_t v12 = *((void *)v10 + 5);
        int v11 = v10 + 10;
        if (v12)
        {
          uint64_t result = (unsigned int *)sub_1000622D4("hash bucket %d:", a2, a3, a4, a5, a6, a7, a8, v9);
          while (1)
          {
            int v11 = *(unsigned int **)v11;
            if (!v11) {
              break;
            }
            uint64_t v13 = v11[4];
            if ((_DWORD)v13) {
              uint64_t result = (unsigned int *)sub_1000503D0(*((void *)v11 + 1), v13, a3, a4, a5, a6, a7, a8);
            }
            else {
              uint64_t result = (unsigned int *)sub_1000622D4("%s", v13, a3, a4, a5, a6, a7, a8, *((void *)v11 + 1));
            }
          }
        }

        ++v9;
      }

      while (v9 < *v8);
    }
  }

  return result;
}

uint64_t sub_100050628(uint64_t result, unsigned __int8 *a2, unsigned int a3, char *a4)
{
  if (a3 >= 3 && a4)
  {
    else {
      uint64_t v5 = a3 / 3;
    }
    if ((_DWORD)v5)
    {
      uint64_t v7 = v5;
      __int128 v8 = a4;
      do
      {
        int v9 = *a2++;
        uint64_t result = sprintf(v8, "%02x:", v9);
        v8 += 3;
        --v7;
      }

      while (v7);
      uint64_t v10 = (3 * v5 - 1);
    }

    else
    {
      uint64_t v10 = 0xFFFFFFFFLL;
    }

    a4[v10] = 0;
  }

  return result;
}

void *sub_1000506CC(void *result, unsigned __int8 *a2, unsigned int a3, char *a4)
{
  unsigned int v4 = a3 - 3;
  if (a3 >= 3 && a4)
  {
    else {
      size_t v6 = v4;
    }
    if ((_DWORD)v6)
    {
      uint64_t v7 = 0LL;
      while (((char)a2[v7] & 0x80000000) == 0 && (_DefaultRuneLocale.__runetype[a2[v7]] & 0x40000) != 0)
      {
        if (v6 == ++v7)
        {
          size_t v8 = v6;
          goto LABEL_14;
        }
      }

      return (void *)sub_100050628((uint64_t)result, a2, a3, a4);
    }

    else
    {
      size_t v8 = 0LL;
LABEL_14:
      *a4 = 34;
      uint64_t result = memcpy(a4 + 1, a2, v8);
      *(_WORD *)&a4[v6 + 1] = 34;
    }
  }

  return result;
}

uint64_t sub_100050770(void *a1, unsigned __int8 *a2, unsigned int a3, signed int a4)
{
  uint64_t v4 = (uint64_t)*(&off_100084710 + a4);
  if (a3 >= 0x3D) {
    a3 = 61;
  }
  sub_1000506CC(a1, a2, a3, (char *)*(&off_100084710 + a4));
  return v4;
}

void *sub_1000507BC(unsigned int a1, uint64_t a2)
{
  uint64_t v3 = 0LL;
  unint64_t v4 = a1;
  uint64_t v5 = (char *)&unk_1000C54A8;
  do
  {
    sprintf( v5,  "%u.%u.%u.%u, ",  *(unsigned __int8 *)(a2 + v3),  *(unsigned __int8 *)(a2 + v3 + 1),  *(unsigned __int8 *)(a2 + v3 + 2),  *(unsigned __int8 *)(a2 + v3 + 3));
    v5 += strlen(v5);
    int v6 = v3 + 4;
    unint64_t v7 = v3 + 7;
    v3 += 4LL;
  }

  while (v7 < v4);
  if ((_DWORD)v4 == v6) {
    *(v5 - 2) = 0;
  }
  else {
    *(_DWORD *)uint64_t v5 = 3026478;
  }
  return &unk_1000C54A8;
}

char *sub_100050884(uint64_t a1)
{
  return byte_1000C54F9;
}

char *sub_1000508CC(uint64_t a1)
{
  return byte_1000C5519;
}

uint64_t sub_100050914( char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1000622D4("%s: %s", v9, v10, v11, v12, v13, v14, v15, a1);
}

uint64_t sub_100050994( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *(_DWORD *)(a1 + 4);
  uint64_t v9 = a3;
  uint64_t v11 = a1;
  uint64_t v12 = "delete";
  uint64_t v13 = "known";
  uint64_t v14 = "cfg-option";
  unsigned int v15 = 4;
  char v16 = "and";
  switch(v8)
  {
    case 0:
      *(_DWORD *)a2 = 7104878;
      return 3LL;
    case 1:
      *(void *)a2 = 0x29686374616D28LL;
      return 7LL;
    case 2:
      size_t v17 = strlen(*(const char **)(*(void *)(v11 + 8) + 8LL)) + 10;
      sprintf((char *)a2, "(check %s)");
      return v17;
    case 3:
      uint64_t v18 = (a3 - 6);
      strcpy((char *)a2, "(eq ");
      uint64_t v19 = a2 + 4;
      uint64_t v20 = *(void *)(v11 + 8);
      goto LABEL_133;
    case 4:
      strcpy((char *)a2, "(substr ");
      int v21 = sub_100050994(*(void *)(v11 + 8), a2 + 8, (a3 - 11));
      *(_BYTE *)(a2 + (v21 + 8)) = 32;
      unsigned int v22 = sub_100050994(*(void *)(v11 + 16), a2 + (v21 + 9), (v9 - v21 - 11)) + v21 + 9;
      uint64_t v23 = v22 + 1;
      *(_BYTE *)(a2 + v22) = 32;
      uint64_t v24 = *(void *)(v11 + 24);
      goto LABEL_119;
    case 5:
      strcpy((char *)a2, "(suffix ");
      int v25 = sub_100050994(*(void *)(v11 + 8), a2 + 8, (a3 - 10));
      unsigned int v26 = v25 + 8;
      if (v25 + 8 < v9)
      {
        *(_BYTE *)(a2 + v26) = 32;
        unsigned int v26 = v25 + 9;
      }

      size_t v17 = sub_100050994(*(void *)(v11 + 16), a2 + v26, ~v26 + v9) + v26;
      if (v17 < v9)
      {
        *(_BYTE *)(a2 + v17) = 41;
        size_t v17 = (v17 + 1);
      }

      goto LABEL_138;
    case 6:
      uint64_t v27 = "(concat ";
      goto LABEL_31;
    case 7:
      size_t v17 = strlen((const char *)(*(void *)(v11 + 8) + 40LL)) + 15;
      sprintf((char *)a2, "(dns-lookup %s)");
      return v17;
    case 8:
      goto LABEL_117;
    case 9:
      char v16 = "or";
      goto LABEL_117;
    case 10:
      strcpy((char *)a2, "(not ");
      int v28 = sub_100050994(*(void *)(v11 + 8), a2 + 5, (a3 - 6));
      unsigned int v29 = v28 + 5;
      size_t v17 = (v28 + 6);
      goto LABEL_137;
    case 11:
      uint64_t v14 = "option";
      goto LABEL_25;
    case 12:
      strcpy((char *)a2, "(hardware)");
      return 10LL;
    case 13:
      uint64_t v27 = "(substr ";
LABEL_31:
      *(void *)a2 = *(void *)v27;
      *(_BYTE *)(a2 + 8) = 0;
      LODWORD(v18) = a3 - 10;
      int v33 = sub_100050994(*(void *)(v11 + 8), a2 + 8, (a3 - 10));
      unsigned int v34 = v33 + 8;
      uint64_t v23 = (v33 + 9);
      goto LABEL_134;
    case 14:
      sub_1000506CC((void *)*(unsigned int *)(v11 + 24), *(unsigned __int8 **)(v11 + 16), a3, byte_1000C53F1);
      unsigned int v35 = strlen(byte_1000C53F1);
      else {
        size_t v17 = v35;
      }
      strncpy((char *)a2, byte_1000C53F1, v17);
      *(_BYTE *)(a2 + v17) = 0;
      return v17;
    case 15:
      strcpy((char *)a2, "(int8 ");
      goto LABEL_46;
    case 16:
      uint64_t v36 = 0x3631746E6928LL;
      goto LABEL_128;
    case 17:
      uint64_t v36 = 0x3233746E6928LL;
      goto LABEL_128;
    case 18:
      strcpy((char *)a2, "(to-int8 ");
LABEL_46:
      int v37 = sub_100050994(*(void *)(v11 + 8), a2 + 6, (a3 - 7));
      unsigned int v29 = v37 + 6;
      size_t v17 = (v37 + 7);
      goto LABEL_137;
    case 19:
      *(void *)a2 = *(void *)"(to-int16 ";
      unsigned __int16 v38 = 13873;
      goto LABEL_51;
    case 20:
      *(void *)a2 = *(void *)"(to-int32 ";
      unsigned __int16 v38 = 12851;
LABEL_51:
      *(_DWORD *)(a2 + 7) = v38 | 0x200000;
      uint64_t v39 = a2 + 7;
      uint64_t v40 = *(void *)(v11 + 8);
      goto LABEL_130;
    case 21:
      __sprintf_chk(byte_1000C54F9, 0, 0x20uLL, "%lu", *(void *)(v11 + 8));
      size_t v41 = strlen(byte_1000C54F9);
      size_t v17 = 0LL;
      if (v41 < v9)
      {
        strcpy((char *)a2, byte_1000C54F9);
        return v41;
      }

      return v17;
    case 22:
      uint64_t v42 = *(void *)(v11 + 8);
      int v43 = strlen(*(const char **)v42);
      size_t v17 = strlen(**(const char ***)(v42 + 16)) + v43 + 10;
      sprintf((char *)a2, "(exists %s.%s)");
      return v17;
    case 23:
      strcpy((char *)a2, "(encapsulate ");
      int v44 = *(_DWORD *)(v11 + 24);
      else {
        unsigned int v45 = a3 - 2;
      }
      strncpy((char *)a2, *(const char **)(v11 + 16), v45 - 13);
      size_t v17 = 0LL;
      *(_BYTE *)(a2 + v45) = 41;
      *(_BYTE *)(a2 + v45 + 1) = 0;
      return v17;
    case 24:
      goto LABEL_121;
    case 25:
      strcpy((char *)a2, "(reverse ");
      int v46 = a3 - 15;
      int v47 = sub_100050994(*(void *)(v11 + 8), a2 + 13, (a3 - 15));
      unsigned int v48 = v47 + 13;
      uint64_t v49 = (v47 + 14);
      goto LABEL_85;
    case 26:
      uint64_t v13 = "leased-address";
      goto LABEL_121;
    case 27:
      strcpy((char *)a2, "(b2a ");
      int v50 = sub_100050994(*(void *)(v11 + 8), a2 + 9, (a3 - 13));
      *(_BYTE *)(a2 + (v50 + 9)) = 32;
      unsigned int v51 = sub_100050994(*(void *)(v11 + 16), a2 + (v50 + 10), (v9 - v50 - 13))
          + v50
          + 10;
      *(_BYTE *)(a2 + v51) = 32;
      int v52 = v9 - 2;
      unsigned int v53 = sub_100050994(*(void *)(v11 + 24), a2 + v51 + 1, v52 + ~v51) + v51 + 1;
      uint64_t v49 = v53 + 1;
      *(_BYTE *)(a2 + v53) = 32;
      uint64_t v54 = *(void *)(v11 + 32);
      uint64_t v55 = a2 + v49;
      uint64_t v56 = v52 - v53;
      goto LABEL_86;
    case 28:
LABEL_25:
      int v30 = strlen(v14);
      uint64_t v31 = *(void *)(v11 + 8);
      int v32 = strlen(*(const char **)v31);
      size_t v17 = v30 + v32 + strlen(**(const char ***)(v31 + 16)) + 2;
      sprintf((char *)a2, "(option %s.%s)");
      return v17;
    case 29:
      uint64_t v13 = "host-decl-name";
      goto LABEL_121;
    case 30:
      strcpy((char *)a2, "(pick1st ");
      int v46 = a3 - 8;
      int v47 = sub_100050994(*(void *)(v11 + 8), a2 + 6, (a3 - 8));
      unsigned int v48 = v47 + 6;
      uint64_t v49 = (v47 + 7);
      goto LABEL_85;
    case 31:
      uint64_t v13 = "lease-time";
      goto LABEL_121;
    case 32:
      strcpy((char *)a2, "(ns-update ");
      int v57 = a3 - 2;
      LODWORD(v17) = 10;
      do
      {
        size_t v17 = (v58 + 1);
        *(_BYTE *)(a2 + v58) = 32;
        uint64_t v11 = *(void *)(v11 + 16);
      }

      while ((int)v58 + 3 > v9);
      *(_BYTE *)(a2 + v58) = 41;
      goto LABEL_138;
    case 33:
      uint64_t v13 = "static";
      goto LABEL_121;
    case 34:
      uint64_t v12 = "update";
      unsigned int v15 = 5;
      goto LABEL_77;
    case 35:
      goto LABEL_77;
    case 36:
      uint64_t v12 = "exists";
      goto LABEL_77;
    case 37:
      uint64_t v12 = "not_exists";
LABEL_77:
      size_t v59 = strlen(v12);
      unsigned int v60 = v59 + 1;
      int v61 = v59;
      *(_BYTE *)a2 = 40;
      strcpy((char *)(a2 + 1), v12);
      uint64_t v62 = (v61 + 2);
      *(_BYTE *)(a2 + v6__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = 32;
      __sprintf_chk(byte_1000C54F9, 0, 0x20uLL, "%lu", *(unsigned int *)(v11 + 8));
      if (v62 + v15 + strlen(byte_1000C54F9) < v9)
      {
        uint64_t v63 = strcpy((char *)(a2 + v62), byte_1000C54F9);
        uint64_t v62 = v62 + strlen(v63);
      }

      uint64_t v64 = (v62 + 1);
      *(_BYTE *)(a2 + v62) = 32;
      __sprintf_chk(byte_1000C54F9, 0, 0x20uLL, "%lu", *(unsigned int *)(v11 + 12));
      if (v64 + v15 - 1 + strlen(byte_1000C54F9) < v9)
      {
        uint64_t v65 = strcpy((char *)(a2 + v64), byte_1000C54F9);
        uint64_t v64 = v64 + strlen(v65);
      }

      *(_BYTE *)(a2 + v64) = 32;
      int v66 = v9 - v15;
      unsigned int v67 = sub_100050994(*(void *)(v11 + 16), a2 + (v64 + 1), (v66 + ~(_DWORD)v64 + 2))
          + v64
          + 1;
      *(_BYTE *)(a2 + v67) = 32;
      unsigned int v68 = sub_100050994(*(void *)(v11 + 24), a2 + v67 + 1, v66 + ~v67 + 3) + v67 + 1;
      *(_BYTE *)(a2 + v68) = 32;
      uint64_t v23 = v68 + 1;
      uint64_t v24 = *(void *)(v11 + 32);
      uint64_t v69 = a2 + v23;
      uint64_t v70 = v66 + ~v68 + 4;
      goto LABEL_135;
    case 38:
      strcpy((char *)a2, "(neq ");
      int v46 = a3 - 7;
      int v47 = sub_100050994(*(void *)(v11 + 8), a2 + 5, (a3 - 7));
      unsigned int v48 = v47 + 5;
      uint64_t v49 = (v47 + 6);
LABEL_85:
      *(_BYTE *)(a2 + v48) = 32;
      uint64_t v55 = a2 + v49;
      uint64_t v56 = (v46 - v47);
      uint64_t v54 = *(void *)(v11 + 16);
LABEL_86:
      unsigned int v29 = sub_100050994(v54, v55, v56) + v49;
      goto LABEL_136;
    case 39:
      strcpy((char *)a2, "(null)");
      return 6LL;
    case 40:
      size_t v17 = strlen(*(const char **)(v11 + 8)) + 10;
      sprintf((char *)a2, "(defined %s)");
      return v17;
    case 41:
      unsigned int v71 = *(const char **)(v11 + 8);
      size_t v72 = strlen(v71);
      size_t v17 = v72;
      int v73 = (char *)a2;
      uint64_t v74 = v71;
      goto LABEL_123;
    case 42:
      uint64_t v13 = "filename";
      goto LABEL_121;
    case 43:
      uint64_t v13 = "server-name";
      goto LABEL_121;
    case 44:
      unsigned int v75 = sub_100050994(*(void *)(v11 + 8), a2, a3);
      size_t v17 = 0LL;
      if (*(void *)(v11 + 16))
      {
        unsigned int v76 = v75;
        if (v75 + 2 < v9)
        {
          *(_BYTE *)(a2 + v75) = 32;
          int v77 = sub_100050994(*(void *)(v11 + 16), a2, v9);
          size_t v17 = v76 + v77 + 1;
          if (v76 + v77 + 2 < v9)
          {
            *(_BYTE *)(a2 + v17) = 0;
            return v76 + v77 + 2;
          }
        }
      }

      return v17;
    case 45:
      int v78 = strlen(*(const char **)(v11 + 8));
      int v79 = v78;
      unsigned int v80 = v78 + 13;
      unsigned int v81 = v78 + 12;
      strcpy((char *)a2, "(funcall  ");
      strcpy((char *)(a2 + 9), *(const char **)(v11 + 8));
      *(_BYTE *)(a2 + v81) = 32;
      unsigned int v29 = sub_100050994(*(void *)(v11 + 16), a2 + v80, (v9 - v79 - 14)) + v80;
      goto LABEL_136;
    case 46:
      strcpy((char *)a2, "(function");
      uint64_t v82 = *(const char **)(*(void *)(v11 + 8) + 8LL);
      if (v82)
      {
        size_t v83 = a3;
        unsigned int v84 = 9;
        do
        {
          if (strlen(v82 + 8) + v84 + 2 < v83)
          {
            *(_BYTE *)(a2 + v84 - 1) = 32;
            strcpy((char *)(a2 + v84), v82 + 8);
            v84 += strlen(v82 + 8);
          }

          uint64_t v82 = *(const char **)v82;
        }

        while (v82);
      }

      else
      {
        unsigned int v84 = 9;
      }

      size_t v17 = v84 + 1;
      *(_BYTE *)(a2 + v84) = 41;
      goto LABEL_138;
    case 47:
      char v16 = "+";
      goto LABEL_117;
    case 48:
      char v16 = "-";
      goto LABEL_117;
    case 49:
      char v16 = "*";
      goto LABEL_117;
    case 50:
      char v16 = "/";
      goto LABEL_117;
    case 51:
      char v16 = "%";
      goto LABEL_117;
    case 52:
      char v16 = "&";
      goto LABEL_117;
    case 53:
      char v16 = "|";
      goto LABEL_117;
    case 54:
      char v16 = "^";
LABEL_117:
      int v85 = strlen(v16);
      *(_BYTE *)a2 = 40;
      strcpy((char *)(a2 + 1), v16);
      *(_BYTE *)(a2 + (v85 + 1)) = 32;
      unsigned int v22 = sub_100050994(*(void *)(v11 + 8), a2 + (v85 + 2), (v9 - v85 - 4)) + v85 + 2;
      uint64_t v23 = v22 + 1;
      *(_BYTE *)(a2 + v22) = 32;
      uint64_t v24 = *(void *)(v11 + 16);
LABEL_119:
      uint64_t v69 = a2 + v23;
      uint64_t v70 = v9 - v22 - 2;
      goto LABEL_135;
    case 55:
      uint64_t v13 = "client-state";
LABEL_121:
      size_t v17 = strlen(v13);
      int v73 = (char *)a2;
      uint64_t v74 = v13;
LABEL_123:
      strcpy(v73, v74);
      return v17;
    case 56:
      uint64_t v86 = 0x20657361637528LL;
      goto LABEL_129;
    case 57:
      uint64_t v36 = 0x657361636C28LL;
LABEL_128:
      uint64_t v86 = v36 & 0xFFFFFFFFFFFFLL | 0x20000000000000LL;
LABEL_129:
      *(void *)a2 = v86;
      uint64_t v40 = *(void *)(v11 + 8);
      uint64_t v39 = a2 + 7;
LABEL_130:
      int v87 = sub_100050994(v40, v39, (a3 - 8));
      unsigned int v29 = v87 + 7;
      size_t v17 = (v87 + 8);
      goto LABEL_137;
    case 58:
      *(void *)a2 = 0x20786567657228LL;
      uint64_t v20 = *(void *)(v11 + 8);
      uint64_t v19 = a2 + 4;
      uint64_t v18 = (a3 - 6);
LABEL_133:
      int v33 = sub_100050994(v20, v19, v18);
      unsigned int v34 = v33 + 4;
      uint64_t v23 = (v33 + 5);
LABEL_134:
      *(_BYTE *)(a2 + v34) = 32;
      uint64_t v69 = a2 + v23;
      uint64_t v70 = (v18 - v33);
      uint64_t v24 = *(void *)(v11 + 16);
LABEL_135:
      unsigned int v29 = sub_100050994(v24, v69, v70) + v23;
LABEL_136:
      size_t v17 = v29 + 1;
LABEL_137:
      *(_BYTE *)(a2 + v29) = 41;
LABEL_138:
      *(_BYTE *)(a2 + v17) = 0;
      return v17;
    default:
LABEL_108:
      sub_100061FB4( "Impossible case at %s:%d (undefined expression %d).",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/print.c");
  }

uint64_t sub_100051668( FILE *a1, uint64_t a2, uint64_t a3, const char *a4, const char *a5, int a6, int a7, int a8, char *__s, uint64_t a10)
{
  uint64_t v39 = (const char **)&a10;
  unsigned int v15 = __s;
  if (__s)
  {
    int v16 = 0;
    size_t v17 = __s;
    do
    {
      v16 += strlen(v17);
      uint64_t v18 = v39++;
      size_t v17 = *v18;
    }

    while (*v18);
    size_t v19 = (v16 + 1);
  }

  else
  {
    size_t v19 = 1LL;
  }

  uint64_t v20 = (char *)sub_10005CDE4(v19);
  int v28 = v20;
  if (!v20) {
    sub_100061FB4("token_print_indent: no memory for copy buffer", v21, v22, v23, v24, v25, v26, v27, v38);
  }
  uint64_t v40 = (const char **)&a10;
  if (__s)
  {
    unsigned int v29 = v20;
    do
    {
      unsigned int v30 = strlen(v15);
      strcpy(v29, v15);
      v29 += v30;
      uint64_t v31 = v40++;
      unsigned int v15 = *v31;
    }

    while (*v31);
  }

  sub_10005179C(a1, a2, a3, a4, a5, v28);
  sub_10005CE20( v28,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/print.c",  1192LL,  v32,  v33,  v34,  v35,  v36);
  return a2;
}

uint64_t sub_10005179C(FILE *a1, int a2, uint64_t a3, const char *a4, const char *a5, char *__s)
{
  int v12 = strlen(__s);
  int v13 = strlen(a4) + v12;
  if (v13 + a2 < 80)
  {
    if (a4 && *a4)
    {
      fputs(a4, a1);
      a2 += strlen(a4);
    }
  }

  else if (v13 + (int)a3 > 78)
  {
    sub_100051AA0(a1, a2);
    if (v13 <= 79) {
      a2 = 78 - v13;
    }
    else {
      a2 = 0;
    }
  }

  else
  {
    sub_100051AA0(a1, a3);
    a2 = a3;
  }

  fputs(__s, a1);
  uint64_t v14 = (a2 + v13);
  if (a5 && *a5)
  {
    if (strlen(a5) + (int)v14 < 0x50)
    {
      fputs(a5, a1);
      return v14 + strlen(a5);
    }

    else
    {
      sub_100051AA0(a1, a3);
      return a3;
    }
  }

  return v14;
}

uint64_t sub_1000518C8(FILE *a1, uint64_t a2, uint64_t a3, const char *a4, const char *a5, uint64_t a6)
{
  uint64_t v12 = *(unsigned int *)(a6 + 16);
  if ((_DWORD)v12)
  {
    uint64_t v13 = 0LL;
    while ((*(char *)(*(void *)(a6 + 8) + v13) & 0x80000000) == 0
         && (_DefaultRuneLocale.__runetype[*(unsigned __int8 *)(*(void *)(a6 + 8) + v13)] & 0x40000) != 0)
    {
      if (v12 == ++v13) {
        goto LABEL_9;
      }
    }
  }

  else
  {
    LODWORD(v13) = 0;
  }

  if ((_DWORD)v13 == (_DWORD)v12)
  {
LABEL_9:
    uint64_t v14 = (char *)sub_10005CDE4((v12 + 3));
    if (v14)
    {
      unsigned int v15 = v14;
      *uint64_t v14 = 34;
      memcpy(v14 + 1, *(const void **)(a6 + 8), *(unsigned int *)(a6 + 16));
      v15[*(_DWORD *)(a6 + 16) + 1] = 34;
      v15[*(_DWORD *)(a6 + 16) + 2] = 0;
      uint64_t v16 = sub_10005179C(a1, a2, a3, a4, a5, v15);
      sub_10005CE20( v15,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/print.c",  1220LL,  v17,  v18,  v19,  v20,  v21);
      return v16;
    }

    LODWORD(v12) = *(_DWORD *)(a6 + 16);
  }

  if ((_DWORD)v12)
  {
    unint64_t v23 = 0LL;
    do
    {
      __sprintf_chk(__s, 0, 3uLL, "%2.2x", *(unsigned __int8 *)(*(void *)(a6 + 8) + v23));
      if (v23) {
        uint64_t v24 = &byte_1000728D2;
      }
      else {
        uint64_t v24 = a4;
      }
      if (++v23 == *(_DWORD *)(a6 + 16)) {
        uint64_t v25 = a5;
      }
      else {
        uint64_t v25 = &byte_1000728D2;
      }
      a2 = sub_10005179C(a1, a2, a3, v24, v25, __s);
      unint64_t v26 = *(unsigned int *)(a6 + 16);
      if (v23 != v26)
      {
        a2 = sub_10005179C(a1, a2, a3, a4, a5, ":");
        unint64_t v26 = *(unsigned int *)(a6 + 16);
      }
    }

    while (v23 < v26);
  }

  return a2;
}

uint64_t sub_100051AA0(FILE *a1, int a2)
{
  uint64_t result = fputc(10, a1);
  if (a2 >= 1)
  {
    do
    {
      uint64_t result = fputc(32, a1);
      --a2;
    }

    while (a2);
  }

  return result;
}

uint64_t sub_100051AE8(unsigned int a1, uint64_t *a2)
{
  unsigned int v2 = a1;
  uint64_t v3 = *a2;
  if (!*a2)
  {
LABEL_79:
    strcpy(__s, "empty update");
    int v6 = &__s[strlen(__s)];
    goto LABEL_80;
  }

  uint64_t v5 = "if";
  int v6 = __s;
  do
  {
    char v7 = 0;
    int v8 = "add";
    uint64_t v9 = "rrset doesn't exist";
    switch(*(_DWORD *)(v3 + 84))
    {
      case 0:
        char v7 = 1;
        int v8 = "delete";
        goto LABEL_6;
      case 1:
        goto LABEL_6;
      case 3:
        uint64_t v9 = "domain doesn't exist";
        goto LABEL_15;
      case 6:
        uint64_t v9 = "domain exists";
        goto LABEL_15;
      case 7:
        uint64_t v9 = "rrset exists";
        goto LABEL_15;
      case 8:
LABEL_15:
        if (v6 != __s && v6 + 1 < v32) {
          *v6++ = 32;
        }
        if (&v6[strlen(v5)] < v32)
        {
          strcpy(v6, v5);
          char v10 = 0;
          char v7 = 1;
          int v8 = v9;
          uint64_t v5 = "and";
          goto LABEL_20;
        }

        char v10 = 0;
        char v7 = 1;
        int v8 = v9;
        uint64_t v5 = "and";
        break;
      default:
        char v7 = 1;
        int v8 = "unknown";
LABEL_6:
        if (v6 != __s && v6 + 1 < v32) {
          *v6++ = 32;
        }
        if (&v6[strlen(v8)] >= v32)
        {
          char v10 = 1;
        }

        else
        {
          strcpy(v6, v8);
          char v10 = 1;
LABEL_20:
          v6 += strlen(v6);
        }

        break;
    }

    uint64_t v11 = *(const char **)(v3 + 40);
    if (v11)
    {
      if (v6 + 1 < v32)
      {
        *int v6 = 32;
        uint64_t v11 = *(const char **)(v3 + 40);
        ++v6;
      }

      if (&v6[strlen(v11)] < v32)
      {
        uint64_t v12 = strcpy(v6, v11);
        v6 += strlen(v12);
      }
    }

    if ((v7 & 1) == 0)
    {
      if (v6 + 1 < v32) {
        *v6++ = 32;
      }
      if (v6 + 27 < v32)
      {
        sprintf(v6, "%lu", *(unsigned int *)(v3 + 56));
        v6 += strlen(v6);
      }
    }

    unsigned int v13 = *(_DWORD *)(v3 + 48) - 1;
    uint64_t v14 = "UNKNOWN";
    if (v13 <= 3) {
      uint64_t v14 = off_100084728[v13];
    }
    if (&v6[strlen(v14)] < v32)
    {
      if (v6 + 1 < v32) {
        *v6++ = 32;
      }
      strcpy(v6, v14);
      v6 += strlen(v14);
    }

    int v15 = *(_DWORD *)(v3 + 52);
    if (v15 <= 14)
    {
      switch(v15)
      {
        case 1:
          uint64_t v16 = "A";
          goto LABEL_55;
        case 5:
          uint64_t v16 = "CNAME";
          goto LABEL_55;
        case 12:
          uint64_t v16 = "PTR";
          goto LABEL_55;
      }
    }

    else if (v15 > 24)
    {
      if (v15 == 25)
      {
        uint64_t v16 = "KEY";
        goto LABEL_55;
      }

      if (v15 == 28)
      {
        uint64_t v16 = "AAAA";
        goto LABEL_55;
      }
    }

    else
    {
      if (v15 == 15)
      {
        uint64_t v16 = "MX";
        goto LABEL_55;
      }

      if (v15 == 16)
      {
        uint64_t v16 = "TXT";
        goto LABEL_55;
      }
    }

    uint64_t v16 = "UNKNOWN";
LABEL_55:
    if (&v6[strlen(v16)] < v32)
    {
      if (v6 + 1 < v32) {
        *v6++ = 32;
      }
      strcpy(v6, v16);
      v6 += strlen(v16);
    }

    if (*(void *)(v3 + 64))
    {
      if (v6 + 1 < v32) {
        *v6++ = 32;
      }
      int v17 = *(_DWORD *)(v3 + 52);
      if (v17 == 16 && v6 + 1 < v32)
      {
        *int v6 = 34;
        int v17 = *(_DWORD *)(v3 + 52);
        ++v6;
      }

      if (v17 == 25)
      {
        strcat(v6, "<keydata>");
        v6 += 9;
      }

      else
      {
        size_t v18 = *(unsigned int *)(v3 + 80);
        if (&v6[v18] < v32)
        {
          memcpy(v6, *(const void **)(v3 + 64), v18);
          v6 += *(unsigned int *)(v3 + 80);
          if (*(_DWORD *)(v3 + 52) == 16 && v6 + 1 < v32) {
            *v6++ = 34;
          }
        }
      }
    }

    if ((v10 & 1) == 0)
    {
      if (v6 + 1 < v32) {
        *v6++ = 32;
      }
      if (&v6[strlen(v8)] < v32)
      {
        uint64_t v19 = strcpy(v6, v8);
        v6 += strlen(v19);
      }
    }

    if (v3 == a2[1]) {
      break;
    }
    uint64_t v3 = *(void *)(v3 + 8);
  }

  while (v3);
  unsigned int v2 = a1;
  if (v6 == __s) {
    goto LABEL_79;
  }
LABEL_80:
  uint64_t v20 = sub_100067900(v2);
  uint64_t v21 = v20;
  if (v6 + 2 < v32)
  {
    *(_WORD *)int v6 = 8250;
    v6 += 2;
  }

  if (&v6[strlen(v20)] < v32)
  {
    strcpy(v6, v21);
    v6 += strlen(v21);
  }

  if (v6 + 1 < v32) {
    *v6++ = 46;
  }
  *int v6 = 0;
  if (v2) {
    return sub_10006221C("%s", v22, v23, v24, v25, v26, v27, v28, (char)__s);
  }
  else {
    return sub_1000622D4("%s", v22, v23, v24, v25, v26, v27, v28, (char)__s);
  }
}

const char *sub_10005207C(time_t a1)
{
  time_t v6 = a1;
  if (a1 == 0x7FFFFFFF) {
    return "never;";
  }
  if (a1 < 0) {
    return 0LL;
  }
  if (dword_10008C158 == 1)
  {
    unsigned int v2 = localtime(&v6);
    time_t v3 = mktime(v2);
    unint64_t v4 = localtime(&v6);
    uint64_t result = (const char *)strftime(byte_1000C5575, 0x21uLL, "# %a %b %d %H:%M:%S %Y", v4);
    if (!result) {
      return result;
    }
  }

  else
  {
    uint64_t v5 = gmtime(&v6);
    uint64_t result = (const char *)strftime(byte_1000C5539, 0x3CuLL, "%w %Y/%m/%d %H:%M:%S;", v5);
    if (!result) {
      return result;
    }
  }

  return byte_1000C5539;
}

uint64_t sub_100052160(uint64_t a1, int a2, _DWORD *a3)
{
  if (a2 == 30)
  {
    *(_WORD *)v110[0].sa_data = word_10008C0F4;
    *(_OWORD *)&v110[0].sa_data[6] = xmmword_10008C0E4;
    *(_WORD *)&v110[0].sa_len = 7708;
    if ((*(_DWORD *)(a1 + 204) & 0x18) == 0x10) {
      *a3 = 0;
    }
    socklen_t v5 = 28;
    int v6 = 30;
  }

  else
  {
    *(_WORD *)v110[0].sa_data = word_10008C0F4;
    *(_DWORD *)&v110[0].sa_data[2] = dword_10008C0E0;
    *(_WORD *)&v110[0].sa_len = 528;
    socklen_t v5 = 16;
    int v6 = 2;
  }

  uint64_t v7 = socket(v6, 2, 17);
  uint64_t v15 = v7;
  if ((v7 & 0x80000000) != 0) {
    sub_100061FB4("Can't create dhcp socket: %m", v8, v9, v10, v11, v12, v13, v14, v102);
  }
  int v109 = 1;
  if (setsockopt(v7, 0xFFFF, 4, &v109, 4u) < 0) {
    sub_100061FB4("Can't set SO_REUSEADDR option on dhcp socket: %m", v16, v17, v18, v19, v20, v21, v22, v102);
  }
  if (*(void *)(a1 + 192) && setsockopt(v15, 0xFFFF, 32, &v109, 4u) < 0) {
    sub_100061FB4("Can't set SO_BROADCAST option on dhcp socket: %m", v23, v24, v25, v26, v27, v28, v29, v102);
  }
  if (dword_100089B0C == 30)
  {
    int v109 = 1;
    if (setsockopt(v15, 0xFFFF, 512, &v109, 4u) < 0) {
      sub_100061FB4("Can't set SO_REUSEPORT option on dhcp socket: %m", v30, v31, v32, v33, v34, v35, v36, v102);
    }
  }

  if (bind(v15, v110, v5) < 0)
  {
    sub_10006221C("Can't bind to dhcp address: %m", v37, v38, v39, v40, v41, v42, v43, v102);
    sub_10006221C("Please make sure there is no other dhcp server", v44, v45, v46, v47, v48, v49, v50, v103);
    sub_10006221C("running and that there's no entry for dhcp or", v51, v52, v53, v54, v55, v56, v57, v104);
    sub_10006221C("bootp in /etc/inetd.conf.   Also make sure you", v58, v59, v60, v61, v62, v63, v64, v105);
    sub_10006221C("are not running HP JetAdmin software, which", v65, v66, v67, v68, v69, v70, v71, v106);
    sub_100061FB4("includes a bootp server.", v72, v73, v74, v75, v76, v77, v78, v107);
  }

  if (dword_100089B0C != 30)
  {
    int v79 = *(const void **)(a1 + 192);
    if (v79)
    {
      if (setsockopt(v15, 0xFFFF, 4404, v79, 0x20u) < 0) {
        sub_100061FB4("setsockopt: SO_BINDTODEVICE: %m", v80, v81, v82, v83, v84, v85, v86, v102);
      }
    }
  }

  if (a2 == 30)
  {
    int v108 = 1;
    if (setsockopt(v15, 41, 61, &v108, 4u)) {
      sub_100061FB4("setsockopt: IPV6_RECVPKTINFO: %m", v87, v88, v89, v90, v91, v92, v93, v102);
    }
    if ((*(_BYTE *)(a1 + 204) & 0x10) != 0)
    {
      int v108 = 32;
      if (setsockopt(v15, 41, 10, &v108, 4u) < 0) {
        sub_100061FB4("setsockopt: IPV6_MULTICAST_HOPS: %m", v94, v95, v96, v97, v98, v99, v100, v102);
      }
    }
  }

  return v15;
}

uint64_t sub_10005244C(uint64_t a1)
{
  uint64_t result = sub_100052160(a1, 2, 0LL);
  *(_DWORD *)(a1 + 152) = result;
  *(_DWORD *)(a1 + 156) = result;
  if (!dword_10008C100) {
    return sub_1000622D4("Sending on   Socket/%s%s%s", v3, v4, v5, v6, v7, v8, v9, a1 - 124);
  }
  return result;
}

void sub_1000524CC(uint64_t a1, int a2)
{
  int v61 = a2;
  if (!dword_1000C5598)
  {
    dword_100089B24 = sub_100052160(a1, 30, &v61);
    if (dword_100089B24 < 0) {
      sub_100061FB4( "Impossible condition at %s:%d",  v3,  v4,  v5,  v6,  v7,  v8,  v9,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/socket.c");
    }
    sub_1000622D4("Bound to *:%d", v3, v4, v5, v6, v7, v8, v9, bswap32((unsigned __int16)word_10008C0F4) >> 16);
  }

  int v10 = dword_100089B24;
  *(_DWORD *)(a1 + 152) = dword_100089B24;
  *(_DWORD *)(a1 + 156) = v10;
  ++dword_1000C5598;
  if (v61)
  {
    if (inet_pton(30, "FF02::1:2", v62) <= 0) {
      sub_100061FB4("inet_pton: unable to convert '%s'", v11, v12, v13, v14, v15, v16, v17, (char)"FF02::1:2");
    }
    unsigned int v63 = if_nametoindex((const char *)(a1 + 132));
    if (setsockopt(v10, 41, 12, v62, 0x14u) < 0) {
      sub_100061FB4("setsockopt: IPV6_JOIN_GROUP: %m", v18, v19, v20, v21, v22, v23, v24, v60);
    }
    if ((*(_BYTE *)(a1 + 204) & 0x18) == 0)
    {
      if (inet_pton(30, "FF05::1:3", v62) <= 0) {
        sub_100061FB4("inet_pton: unable to convert '%s'", v25, v26, v27, v28, v29, v30, v31, (char)"FF05::1:3");
      }
      unsigned int v63 = if_nametoindex((const char *)(a1 + 132));
      if (setsockopt(v10, 41, 12, v62, 0x14u) < 0) {
        sub_100061FB4("setsockopt: IPV6_JOIN_GROUP: %m", v32, v33, v34, v35, v36, v37, v38, v60);
      }
    }
  }

  sub_100035074((const char *)(a1 + 132), (_BYTE *)(a1 + 48));
  if (!dword_10008C100)
  {
    if (*(void *)(a1 + 40))
    {
      sub_1000622D4("Listening on Socket/%d/%s/%s", v39, v40, v41, v42, v43, v44, v45, dword_100089B24);
      sub_1000622D4("Sending on   Socket/%d/%s/%s", v46, v47, v48, v49, v50, v51, v52, dword_100089B24);
    }

    else
    {
      sub_1000622D4("Listening on Socket/%s", v39, v40, v41, v42, v43, v44, v45, a1 - 124);
      sub_1000622D4("Sending on   Socket/%s", v53, v54, v55, v56, v57, v58, v59, a1 - 124);
    }
  }

uint64_t sub_1000526E8( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = result;
  int v9 = *(_DWORD *)(result + 152);
  if (v9 != dword_100089B24 || (*(_DWORD *)(result + 156) == v9 ? (BOOL v10 = dword_1000C5598 == 0) : (BOOL v10 = 1), v10)) {
    sub_100061FB4( "Impossible condition at %s:%d",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/socket.c");
  }
  --dword_1000C5598;
  *(void *)(result + 152) = -1LL;
  if (!dword_10008C100)
  {
    if (*(void *)(result + 40))
    {
      sub_1000622D4("Disabling input on  Socket/%s/%s", a2, a3, a4, a5, a6, a7, a8, result - 124);
      uint64_t result = sub_1000622D4("Disabling output on Socket/%s/%s", v11, v12, v13, v14, v15, v16, v17, v8 - 124);
    }

    else
    {
      sub_1000622D4("Disabling input on  Socket/%s", a2, a3, a4, a5, a6, a7, a8, result - 124);
      uint64_t result = sub_1000622D4("Disabling output on Socket/%s", v18, v19, v20, v21, v22, v23, v24, v8 - 124);
    }
  }

  if (!dword_1000C5598)
  {
    close(dword_100089B24);
    dword_100089B24 = -1;
    return sub_1000622D4( "Unbound from *:%d",  v25,  v26,  v27,  v28,  v29,  v30,  v31,  bswap32((unsigned __int16)word_10008C0F4) >> 16);
  }

  return result;
}

uint64_t sub_100052814(uint64_t a1, int a2, void *a3, size_t a4, int a5, sockaddr *a6)
{
  int v13 = sendto(*(_DWORD *)(a1 + 156), a3, a4, 0, a6, 0x10u);
  if (v13 < 0)
  {
    sub_10006221C("send_packet: %m", v6, v7, v8, v9, v10, v11, v12, v22);
    if (*__error() == 51) {
      sub_10006221C( "send_packet: please consult README file%s",  v14,  v15,  v16,  v17,  v18,  v19,  v20,  (char)" regarding broadcast address.");
    }
  }

  return v13;
}

uint64_t sub_100052890(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v8 = (char *)qword_1000C55A0;
  if (qword_1000C55A0
    || (byte_1000C55A8 = 1, uint64_t v8 = (char *)sub_10005CDE4(0x20uLL), (qword_1000C55A0 = (uint64_t)v8) != 0))
  {
    if (byte_1000C55A8) {
      size_t v16 = 32LL;
    }
    else {
      size_t v16 = 0LL;
    }
    if (byte_1000C55A8) {
      uint64_t v17 = v8;
    }
    else {
      uint64_t v17 = 0LL;
    }
    bzero(v8, v16);
    *(&v28.msg_namelen + 1) = 0;
    *(&v28.msg_iovlen + 1) = 0;
    v27[1] = a3;
    v28.msg_name = a4;
    v28.msg_namelen = 28;
    v27[0] = a2;
    v28.msg_iov = (iovec *)v27;
    v28.msg_iovlen = 1;
    v28.msg_control = v8;
    *(void *)&v28.msg_controllen = 0LL;
    *((_DWORD *)v17 + 2) = 46;
    *(void *)uint64_t v17 = 0x2900000020LL;
    *(void *)(v17 + 12) = 0LL;
    *(void *)(v17 + 2__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = 0LL;
    *((_DWORD *)v17 + 7) = 0;
    *((_DWORD *)v17 + 7) = if_nametoindex((const char *)(a1 + 132));
    v28.msg_controllen = *(_DWORD *)v17;
    int v25 = sendmsg(*(_DWORD *)(a1 + 156), &v28, 0);
    if (v25 < 0) {
      sub_10006221C("send_packet6: %m", v18, v19, v20, v21, v22, v23, v24, v27[0]);
    }
    return v25;
  }

  else
  {
    sub_10006221C("send_packet6: unable to allocate cmsg header", v9, v10, v11, v12, v13, v14, v15, v27[0]);
    return 12LL;
  }

uint64_t sub_1000529CC(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, _OWORD *a5, _DWORD *a6)
{
  uint64_t v12 = (void *)qword_1000C55A0;
  if (qword_1000C55A0 || (byte_1000C55A8 = 1, uint64_t v12 = sub_10005CDE4(0x20uLL), (qword_1000C55A0 = (uint64_t)v12) != 0))
  {
    if (byte_1000C55A8) {
      size_t v20 = 32LL;
    }
    else {
      size_t v20 = 0LL;
    }
    if (byte_1000C55A8) {
      socklen_t v21 = 32;
    }
    else {
      socklen_t v21 = 0;
    }
    bzero(v12, v20);
    *(&v27.msg_namelen + 1) = 0;
    *(&v27.msg_iovlen + 1) = 0;
    v26[1] = a3;
    v27.msg_name = a4;
    v27.msg_namelen = 28;
    v26[0] = a2;
    v27.msg_iov = (iovec *)v26;
    v27.msg_iovlen = 1;
    v27.msg_control = v12;
    v27.msg_flags = 0;
    v27.msg_controllen = v21;
    LODWORD(result) = recvmsg(*(_DWORD *)(a1 + 152), &v27, 0);
    if ((result & 0x80000000) == 0)
    {
      if (v27.msg_controllen < 0xC) {
        goto LABEL_18;
      }
      msg_control = (unsigned int *)v27.msg_control;
      if (!v27.msg_control) {
        goto LABEL_18;
      }
      int v24 = 0;
      int v25 = (unsigned int *)((char *)v27.msg_control + v27.msg_controllen);
      do
      {
        if (msg_control[1] == 41 && msg_control[2] == 46)
        {
          *a5 = *(_OWORD *)(msg_control + 3);
          *a6 = msg_control[7];
          int v24 = 1;
        }

        msg_control = (unsigned int *)((char *)msg_control + ((*msg_control + 3LL) & 0x1FFFFFFFCLL));
      }

      while (msg_control + 3 <= v25);
      if (!v24)
      {
LABEL_18:
        *__error() = 5;
        LODWORD(result) = -1;
      }
    }

    return (int)result;
  }

  else
  {
    sub_10006221C("receive_packet6: unable to allocate cmsg header", v13, v14, v15, v16, v17, v18, v19, v26[0]);
    return 12LL;
  }

uint64_t sub_100052B50(uint64_t a1)
{
  socklen_t v2 = 16;
  if (*(void *)a1 != qword_10008C058) {
    return 39LL;
  }
  recvfrom(*(_DWORD *)(a1 + 156), v4, 0x604uLL, 0, &v3, &v2);
  return 0LL;
}

uint64_t sub_100052BE4(int a1, __sigaction_u a2)
{
  char v2 = a1;
  v11.__sigaction_u = a2;
  v11.sa_flags = 0;
  v11.sa_masuint64_t k = -1;
  if ((sigaction(a1, &v11, 0LL) & 0x80000000) == 0) {
    return 0LL;
  }
  sub_10006221C("Unable to set up signal handler for %d, %m", v3, v4, v5, v6, v7, v8, v9, v2);
  return 34LL;
}

uint64_t sub_100052C40( uint64_t *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_100063100( a1,  (uint64_t)sub_100034128,  (uint64_t)sub_100034198,  a2,  (uint64_t (*)(char *, int, unsigned int))sub_1000632A8,  a3,  a4,  a8);
}

uint64_t sub_100052C68( uint64_t *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_100063100(a1, 0LL, 0LL, a2, sub_1000631AC, a3, a4, a8);
}

uint64_t sub_100052C88( uint64_t *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_100063100(a1, (uint64_t)sub_100052CB0, (uint64_t)sub_100052CE4, a2, sub_1000631AC, a3, a4, a8);
}

uint64_t sub_100052CB0(void *a1, uint64_t a2)
{
  uint64_t result = 39LL;
  if (a1 && a2 && !*a1)
  {
    uint64_t result = 0LL;
    *a1 = a2;
    ++*(_DWORD *)(a2 + 28);
  }

  return result;
}

uint64_t sub_100052CE4( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 39LL;
  }
  uint64_t v9 = *a1;
  if (!v9) {
    return 39LL;
  }
  int v10 = *(_DWORD *)(v9 + 28);
  BOOL v11 = __OFSUB__(v10, 1);
  int v12 = v10 - 1;
  if (v12 < 0 != v11) {
    return 39LL;
  }
  *(_DWORD *)(v9 + 28) = v12;
  if (!v12)
  {
    if (*(void *)v9 != v9 + 32)
    {
      sub_10005CE20(*(void **)v9, a2, a3, a4, a5, a6, a7, a8);
      uint64_t v9 = *a1;
    }

    uint64_t v15 = *(char **)(v9 + 8);
    if (v15) {
      BOOL v16 = v15 == off_10008A658[0];
    }
    else {
      BOOL v16 = 1;
    }
    if (!v16)
    {
      sub_10005CE20(*(void **)(v9 + 8), a2, a3, a4, a5, a6, a7, a8);
      uint64_t v9 = *a1;
    }

    sub_10005CE20((void *)v9, a2, a3, a4, a5, a6, a7, a8);
  }

  uint64_t result = 0LL;
  *a1 = 0LL;
  return result;
}

uint64_t sub_100052DA4( uint64_t *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_100063100( a1,  (uint64_t)sub_100052CB0,  (uint64_t)sub_100052CE4,  a2,  (uint64_t (*)(char *, int, unsigned int))sub_100063370,  a3,  a4,  a8);
}

uint64_t sub_100052DCC()
{
  dword_10008C568 = 16;
  uint64_t v0 = sub_10005CDE4(0x80uLL);
  qword_10008C570 = (uint64_t)v0;
  if (!v0) {
    sub_100061FB4("Can't allocate option space table.", v1, v2, v3, v4, v5, v6, v7, v194);
  }
  v0[6] = 0u;
  v0[7] = 0u;
  v0[4] = 0u;
  v0[5] = 0u;
  v0[2] = 0u;
  v0[3] = 0u;
  *uint64_t v0 = 0u;
  v0[1] = 0u;
  qword_10008C168 = (uint64_t)"dhcp";
  off_10008C170 = (uint64_t (*)(void))sub_100043E64;
  qword_10008C188 = (uint64_t)sub_10004467C;
  unk_10008C190 = sub_100044750;
  off_10008C178 = sub_10004447C;
  unk_10008C180 = sub_100045A5C;
  qword_10008C198 = (uint64_t)sub_100040920;
  unk_10008C1A0 = sub_100044B30;
  uint64_t v8 = dword_10008C558++;
  qword_10008C1A8 = (uint64_t)sub_100060BA0;
  unk_10008C1B0 = sub_100060B98;
  qword_10008C1B8 = (uint64_t)sub_100060BA0;
  unk_10008C1C0 = sub_100060B98;
  xmmword_10008C1C8 = xmmword_100082BC0;
  dword_10008C1F0 = v8;
  unk_10008C1F4 = 1;
  *(void *)(qword_10008C570 + 8 * v8) = &qword_10008C168;
  if (!sub_100063100( &qword_10008C1D8,  (uint64_t)sub_100052CB0,  (uint64_t)sub_100052CE4,  0x191u,  sub_1000631AC,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  970LL,  v7)
    || !sub_100063100( &qword_10008C1E0,  (uint64_t)sub_100052CB0,  (uint64_t)sub_100052CE4,  0xFEu,  (uint64_t (*)(char *, int, unsigned int))sub_100063370,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  972LL,  v15))
  {
    sub_100061FB4("Can't allocate dhcp option hash table.", v9, v10, v11, v12, v13, v14, v15, v194);
  }

  if (off_10008A660[0])
  {
    BOOL v16 = off_10008A660;
    do
    {
      sub_1000634B8( qword_10008C1E0,  (const char *)v16 + 24,  0LL,  (uint64_t)v16,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  977LL,  v14,  v15,  v194);
      sub_1000634B8( qword_10008C1D8,  *v16,  0LL,  (uint64_t)v16,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  980LL,  v17,  v18,  v195);
      uint64_t v19 = v16[4];
      v16 += 4;
    }

    while (v19);
  }

  dword_10008C554 = 0;
  qword_10008C4C8 = (uint64_t)"nwip";
  unk_10008C4D0 = sub_100045E00;
  qword_10008C4E8 = (uint64_t)sub_100045D58;
  unk_10008C4F0 = sub_100045E44;
  qword_10008C4D8 = (uint64_t)sub_100045B34;
  unk_10008C4E0 = sub_100045E60;
  qword_10008C500 = (uint64_t)sub_100044DBC;
  qword_10008C4F8 = (uint64_t)sub_100040920;
  qword_10008C508 = (uint64_t)sub_100060BA0;
  unk_10008C510 = sub_100060B98;
  qword_10008C518 = (uint64_t)sub_100060BA0;
  unk_10008C520 = sub_100060B98;
  xmmword_10008C528 = xmmword_1000827A0;
  int v212 = 63;
  qword_10008C548 = 0LL;
  if (!sub_100063738( &qword_10008C548,  (uint64_t (**)(unsigned __int8 *, int, unsigned int))qword_10008C1E0,  (const char *)&v212,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1011LL,  v14,  v15)) {
    sub_100061FB4( "Unable to find NWIP parent option (%s:%d).",  v20,  v21,  v22,  v23,  v24,  v25,  v26,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c");
  }
  uint64_t v27 = dword_10008C558++;
  dword_10008C550 = v27;
  *(void *)(qword_10008C570 + 8 * v27) = &qword_10008C4C8;
  if (!sub_100063100( &qword_10008C538,  (uint64_t)sub_100052CB0,  (uint64_t)sub_100052CE4,  0x11u,  sub_1000631AC,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1016LL,  v26)
    || !sub_100063100( &qword_10008C540,  (uint64_t)sub_100052CB0,  (uint64_t)sub_100052CE4,  0x11u,  (uint64_t (*)(char *, int, unsigned int))sub_100063370,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1018LL,  v34))
  {
    sub_100061FB4("Can't allocate nwip option hash table.", v28, v29, v30, v31, v32, v33, v34, v194);
  }

  if (off_10008B280)
  {
    uint64_t v35 = &off_10008B280;
    do
    {
      sub_1000634B8( qword_10008C540,  (const char *)v35 + 24,  0LL,  (uint64_t)v35,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1023LL,  v33,  v34,  v194);
      sub_1000634B8( qword_10008C538,  *v35,  0LL,  (uint64_t)v35,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1026LL,  v36,  v37,  v196);
      uint64_t v38 = v35[4];
      v35 += 4;
    }

    while (v38);
  }

  qword_10008C318 = (uint64_t)"fqdn";
  off_10008C320 = (uint64_t (*)(void))sub_100045E00;
  qword_10008C340 = (uint64_t)sub_100045E44;
  qword_10008C338 = (uint64_t)sub_100045D58;
  qword_10008C328 = (uint64_t)sub_100045B34;
  qword_10008C330 = (uint64_t)sub_100045E60;
  qword_10008C348 = (uint64_t)sub_100041120;
  unk_10008C350 = sub_100045024;
  qword_10008C358 = (uint64_t)sub_100060BA0;
  unk_10008C360 = sub_100060B98;
  qword_10008C368 = (uint64_t)sub_100060BA0;
  unk_10008C370 = sub_100060B98;
  xmmword_10008C378 = xmmword_1000827A0;
  int v39 = dword_10008C558++;
  dword_10008C3A0 = v39;
  unk_10008C3A4 = 0;
  int v212 = 81;
  qword_10008C398 = 0LL;
  if (!sub_100063738( &qword_10008C398,  (uint64_t (**)(unsigned __int8 *, int, unsigned int))qword_10008C1E0,  (const char *)&v212,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1058LL,  v33,  v34)) {
    sub_100061FB4( "Unable to find FQDN parent option (%s:%d).",  v40,  v41,  v42,  v43,  v44,  v45,  v46,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c");
  }
  *(void *)(qword_10008C570 + 8LL * dword_10008C3A__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = &qword_10008C318;
  if (!sub_100063100( &qword_10008C388,  (uint64_t)sub_100052CB0,  (uint64_t)sub_100052CE4,  0xDu,  sub_1000631AC,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1062LL,  v46)
    || !sub_100063100( &qword_10008C390,  (uint64_t)sub_100052CB0,  (uint64_t)sub_100052CE4,  0xDu,  (uint64_t (*)(char *, int, unsigned int))sub_100063370,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1064LL,  v53))
  {
    sub_100061FB4("Can't allocate fqdn option hash table.", v47, v48, v49, v50, v51, v52, v53, v194);
  }

  if (off_10008B400[0])
  {
    uint64_t v54 = off_10008B400;
    do
    {
      sub_1000634B8( qword_10008C390,  (const char *)v54 + 24,  0LL,  (uint64_t)v54,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1069LL,  v52,  v53,  v194);
      sub_1000634B8( qword_10008C388,  *v54,  0LL,  (uint64_t)v54,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1072LL,  v55,  v56,  v197);
      uint64_t v57 = v54[4];
      v54 += 4;
    }

    while (v57);
  }

  dword_10008C604 = 0;
  qword_10008C578 = (uint64_t)"vendor-class";
  qword_10008C580 = (uint64_t)sub_100043E64;
  qword_10008C5A0 = (uint64_t)sub_100044750;
  qword_10008C598 = (uint64_t)sub_10004467C;
  qword_10008C588 = (uint64_t)sub_10004447C;
  qword_10008C590 = (uint64_t)sub_100045A5C;
  qword_10008C5B0 = (uint64_t)sub_100044B30;
  qword_10008C5A8 = (uint64_t)sub_100040920;
  qword_10008C5B8 = (uint64_t)sub_100060B50;
  unk_10008C5C0 = sub_100060B6C;
  qword_10008C5C8 = (uint64_t)sub_100060BA0;
  unk_10008C5D0 = sub_100060B98;
  xmmword_10008C5D8 = xmmword_1000827B0;
  int v212 = 124;
  qword_10008C5F8 = 0LL;
  if (!sub_100063738( &qword_10008C5F8,  (uint64_t (**)(unsigned __int8 *, int, unsigned int))qword_10008C1E0,  (const char *)&v212,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1105LL,  v52,  v53)) {
    sub_100061FB4( "Unable to find VIVCO parent option (%s:%d).",  v58,  v59,  v60,  v61,  v62,  v63,  v64,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c");
  }
  uint64_t v65 = dword_10008C558++;
  dword_10008C600 = v65;
  *(void *)(qword_10008C570 + 8 * v65) = &qword_10008C578;
  if (!sub_100063100( &qword_10008C5E8,  (uint64_t)sub_100052CB0,  (uint64_t)sub_100052CE4,  0x7Fu,  sub_1000631AC,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1110LL,  v64)
    || !sub_100063100( &qword_10008C5F0,  (uint64_t)sub_100052CB0,  (uint64_t)sub_100052CE4,  0x7Fu,  (uint64_t (*)(char *, int, unsigned int))sub_100063370,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1112LL,  v72))
  {
    sub_100061FB4( "Can't allocate Vendor Identified Vendor Class option hash table.",  v66,  v67,  v68,  v69,  v70,  v71,  v72,  v194);
  }

  if (off_10008B520[0])
  {
    uint64_t v73 = off_10008B520;
    do
    {
      sub_1000634B8( qword_10008C5F0,  (const char *)v73 + 24,  0LL,  (uint64_t)v73,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1118LL,  v71,  v72,  v194);
      sub_1000634B8( qword_10008C5E8,  *v73,  0LL,  (uint64_t)v73,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1121LL,  v74,  v75,  v198);
      uint64_t v76 = v73[4];
      v73 += 4;
    }

    while (v76);
  }

  dword_10008C694 = 0;
  qword_10008C608 = (uint64_t)"vendor";
  qword_10008C610 = (uint64_t)sub_100043E64;
  qword_10008C630 = (uint64_t)sub_100044750;
  qword_10008C628 = (uint64_t)sub_10004467C;
  qword_10008C618 = (uint64_t)sub_10004447C;
  qword_10008C620 = (uint64_t)sub_100045A5C;
  qword_10008C640 = (uint64_t)sub_100044B30;
  qword_10008C638 = (uint64_t)sub_100040920;
  qword_10008C648 = (uint64_t)sub_100060B50;
  qword_10008C650 = (uint64_t)sub_100060B6C;
  unk_10008C658 = sub_100060BA0;
  qword_10008C660 = (uint64_t)sub_100060B98;
  xmmword_10008C668 = xmmword_1000827B0;
  int v212 = 125;
  qword_10008C688 = 0LL;
  if (!sub_100063738( &qword_10008C688,  (uint64_t (**)(unsigned __int8 *, int, unsigned int))qword_10008C1E0,  (const char *)&v212,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1152LL,  v71,  v72)) {
    sub_100061FB4( "Unable to find VIVSO parent option (%s:%d).",  v77,  v78,  v79,  v80,  v81,  v82,  v83,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c");
  }
  uint64_t v84 = dword_10008C558++;
  dword_10008C690 = v84;
  *(void *)(qword_10008C570 + 8 * v84) = &qword_10008C608;
  if (!sub_100063100( &qword_10008C678,  (uint64_t)sub_100052CB0,  (uint64_t)sub_100052CE4,  0x7Fu,  sub_1000631AC,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1157LL,  v83)
    || !sub_100063100( &qword_10008C680,  (uint64_t)sub_100052CB0,  (uint64_t)sub_100052CE4,  0x7Fu,  (uint64_t (*)(char *, int, unsigned int))sub_100063370,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1159LL,  v91))
  {
    sub_100061FB4( "Can't allocate Vendor Identified Vendor Sub-options hash table.",  v85,  v86,  v87,  v88,  v89,  v90,  v91,  v194);
  }

  if (off_10008B560[0])
  {
    uint64_t v92 = off_10008B560;
    do
    {
      sub_1000634B8( qword_10008C680,  (const char *)v92 + 24,  0LL,  (uint64_t)v92,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1165LL,  v90,  v91,  v194);
      sub_1000634B8( qword_10008C678,  *v92,  0LL,  (uint64_t)v92,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1168LL,  v93,  v94,  v199);
      uint64_t v95 = v92[4];
      v92 += 4;
    }

    while (v95);
  }

  dword_10008C4C4 = 0;
  qword_10008C438 = (uint64_t)"isc";
  unk_10008C440 = sub_100045E00;
  qword_10008C460 = (uint64_t)sub_100045E44;
  qword_10008C458 = (uint64_t)sub_100045D58;
  qword_10008C448 = (uint64_t)sub_100045B34;
  qword_10008C450 = (uint64_t)sub_100045E60;
  qword_10008C470 = (uint64_t)sub_100045C58;
  qword_10008C468 = (uint64_t)sub_100040920;
  qword_10008C478 = (uint64_t)sub_100060B5C;
  unk_10008C480 = sub_100060B78;
  qword_10008C488 = (uint64_t)sub_100060B5C;
  unk_10008C490 = sub_100060B78;
  xmmword_10008C498 = xmmword_100082BD0;
  int v212 = 2495;
  qword_10008C4B8 = 0LL;
  if (!sub_100063738( &qword_10008C4B8,  (uint64_t (**)(unsigned __int8 *, int, unsigned int))qword_10008C680,  (const char *)&v212,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1199LL,  v90,  v91)) {
    sub_100061FB4( "Unable to find ISC parent option (%s:%d).",  v96,  v97,  v98,  v99,  v100,  v101,  v102,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c");
  }
  uint64_t v103 = dword_10008C558++;
  dword_10008C4C0 = v103;
  *(void *)(qword_10008C570 + 8 * v103) = &qword_10008C438;
  if (!sub_100063100( &qword_10008C4A8,  (uint64_t)sub_100052CB0,  (uint64_t)sub_100052CE4,  3u,  sub_1000631AC,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1204LL,  v102)
    || !sub_100063100( &qword_10008C4B0,  (uint64_t)sub_100052CB0,  (uint64_t)sub_100052CE4,  3u,  (uint64_t (*)(char *, int, unsigned int))sub_100063370,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1206LL,  v110))
  {
    sub_100061FB4("Can't allocate ISC Vendor options hash table.", v104, v105, v106, v107, v108, v109, v110, v194);
  }

  if (off_10008B5A0[0])
  {
    uint64_t v111 = off_10008B5A0;
    do
    {
      sub_1000634B8( qword_10008C4B0,  (const char *)v111 + 24,  0LL,  (uint64_t)v111,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1211LL,  v109,  v110,  v194);
      sub_1000634B8( qword_10008C4A8,  *v111,  0LL,  (uint64_t)v111,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1214LL,  v112,  v113,  v200);
      uint64_t v114 = v111[4];
      v111 += 4;
    }

    while (v114);
  }

  qword_10008C1F8 = (uint64_t)"dhcp6";
  off_10008C200 = (uint64_t (*)(void))sub_100043E64;
  qword_10008C220 = (uint64_t)sub_100044750;
  qword_10008C218 = (uint64_t)sub_10004467C;
  qword_10008C208 = (uint64_t)sub_10004447C;
  off_10008C210 = sub_100045A5C;
  qword_10008C230 = (uint64_t)sub_100044B30;
  qword_10008C228 = (uint64_t)sub_100040920;
  qword_10008C238 = (uint64_t)sub_100060B5C;
  unk_10008C240 = sub_100060B78;
  qword_10008C248 = (uint64_t)sub_100060B5C;
  unk_10008C250 = sub_100060B78;
  xmmword_10008C258 = xmmword_100082BD0;
  uint64_t v115 = dword_10008C558++;
  dword_10008C280 = v115;
  unk_10008C284 = 0;
  *(void *)(qword_10008C570 + 8 * v115) = &qword_10008C1F8;
  if (!sub_100063100( &qword_10008C268,  (uint64_t)sub_100052CB0,  (uint64_t)sub_100052CE4,  0x4FFFu,  sub_1000631AC,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1246LL,  v110)
    || !sub_100063100( &qword_10008C270,  (uint64_t)sub_100052CB0,  (uint64_t)sub_100052CE4,  0x4000u,  (uint64_t (*)(char *, int, unsigned int))sub_100063370,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1248LL,  v122))
  {
    sub_100061FB4("Can't allocate dhcpv6 option hash tables.", v116, v117, v118, v119, v120, v121, v122, v194);
  }

  if (off_10008B600[0])
  {
    uint64_t v123 = off_10008B600;
    do
    {
      sub_1000634B8( qword_10008C270,  (const char *)v123 + 24,  0LL,  (uint64_t)v123,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1253LL,  v121,  v122,  v194);
      sub_1000634B8( qword_10008C268,  *v123,  0LL,  (uint64_t)v123,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1256LL,  v124,  v125,  v201);
      uint64_t v126 = v123[4];
      v123 += 4;
    }

    while (v126);
  }

  sub_100046B60(&qword_100089B68);
  sub_100046B60(&qword_100089C48);
  sub_100046B60(&qword_100089E38);
  dword_10008C724 = 0;
  qword_10008C698 = (uint64_t)"vsio";
  qword_10008C6A0 = (uint64_t)sub_100043E64;
  qword_10008C6C0 = (uint64_t)sub_100044750;
  qword_10008C6B8 = (uint64_t)sub_10004467C;
  qword_10008C6A8 = (uint64_t)sub_10004447C;
  qword_10008C6B0 = (uint64_t)sub_100045A5C;
  qword_10008C6D0 = (uint64_t)sub_100044B30;
  qword_10008C6C8 = (uint64_t)sub_100040920;
  qword_10008C6D8 = (uint64_t)sub_100060B50;
  qword_10008C6E0 = (uint64_t)sub_100060B6C;
  unk_10008C6E8 = 0LL;
  xmmword_10008C6F8 = xmmword_100082BE0;
  qword_10008C6F0 = 0LL;
  int v212 = 17;
  if (!sub_100063738( &qword_10008C718,  (uint64_t (**)(unsigned __int8 *, int, unsigned int))qword_10008C270,  (const char *)&v212,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1286LL,  v127,  v128)) {
    sub_100061FB4( "Unable to find VSIO parent option (%s:%d).",  v129,  v130,  v131,  v132,  v133,  v134,  v135,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c");
  }
  uint64_t v136 = dword_10008C558++;
  dword_10008C720 = v136;
  *(void *)(qword_10008C570 + 8 * v136) = &qword_10008C698;
  if (!sub_100063100( &qword_10008C708,  (uint64_t)sub_100052CB0,  (uint64_t)sub_100052CE4,  0x7Fu,  sub_1000631AC,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1291LL,  v135)
    || !sub_100063100( &qword_10008C710,  (uint64_t)sub_100052CB0,  (uint64_t)sub_100052CE4,  0x7Fu,  (uint64_t (*)(char *, int, unsigned int))sub_100063370,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1293LL,  v143))
  {
    sub_100061FB4( "Can't allocate Vendor Specific Information Options space.",  v137,  v138,  v139,  v140,  v141,  v142,  v143,  v194);
  }

  if (off_10008BAE0[0])
  {
    uint64_t v144 = off_10008BAE0;
    do
    {
      sub_1000634B8( qword_10008C710,  (const char *)v144 + 24,  0LL,  (uint64_t)v144,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1299LL,  v142,  v143,  v194);
      sub_1000634B8( qword_10008C708,  *v144,  0LL,  (uint64_t)v144,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1302LL,  v145,  v146,  v202);
      uint64_t v147 = v144[4];
      v144 += 4;
    }

    while (v147);
  }

  dword_10008C434 = 0;
  qword_10008C3A8 = (uint64_t)"isc6";
  qword_10008C3B0 = (uint64_t)sub_100043E64;
  qword_10008C3D0 = (uint64_t)sub_100044750;
  qword_10008C3C8 = (uint64_t)sub_10004467C;
  qword_10008C3B8 = (uint64_t)sub_10004447C;
  qword_10008C3C0 = (uint64_t)sub_100045A5C;
  qword_10008C3E0 = (uint64_t)sub_100044B30;
  qword_10008C3D8 = (uint64_t)sub_100040920;
  qword_10008C3E8 = (uint64_t)sub_100060B50;
  qword_10008C3F0 = (uint64_t)sub_100060B6C;
  unk_10008C3F8 = 0LL;
  xmmword_10008C408 = xmmword_100082BE0;
  qword_10008C400 = 0LL;
  int v212 = 2495;
  if (!sub_100063738( algn_10008C428,  (uint64_t (**)(unsigned __int8 *, int, unsigned int))qword_10008C710,  (const char *)&v212,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1327LL,  v142,  v143)) {
    sub_100061FB4( "Unable to find ISC parent option (%s:%d).",  v148,  v149,  v150,  v151,  v152,  v153,  v154,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c");
  }
  uint64_t v155 = dword_10008C558++;
  dword_10008C430 = v155;
  *(void *)(qword_10008C570 + 8 * v155) = &qword_10008C3A8;
  if (!sub_100063100( &qword_10008C418,  (uint64_t)sub_100052CB0,  (uint64_t)sub_100052CE4,  3u,  sub_1000631AC,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1332LL,  v154)
    || !sub_100063100( &qword_10008C420,  (uint64_t)sub_100052CB0,  (uint64_t)sub_100052CE4,  3u,  (uint64_t (*)(char *, int, unsigned int))sub_100063370,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1334LL,  v162))
  {
    sub_100061FB4( "Can't allocate Vendor Specific Information Options space.",  v156,  v157,  v158,  v159,  v160,  v161,  v162,  v194);
  }

  if (off_10008BB20[0])
  {
    uint64_t v163 = off_10008BB20;
    do
    {
      sub_1000634B8( qword_10008C420,  (const char *)v163 + 24,  0LL,  (uint64_t)v163,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1340LL,  v161,  v162,  v194);
      sub_1000634B8( qword_10008C418,  *v163,  0LL,  (uint64_t)v163,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1343LL,  v164,  v165,  v203);
      uint64_t v166 = v163[4];
      v163 += 4;
    }

    while (v166);
  }

  qword_10008C288 = (uint64_t)"fqdn6-if-you-see-me-its-a-bug-bug-bug";
  unk_10008C290 = sub_10004544C;
  qword_10008C2A8 = (uint64_t)sub_1000454B8;
  unk_10008C2B0 = 0LL;
  qword_10008C298 = (uint64_t)sub_100045484;
  unk_10008C2A0 = nullsub_10;
  qword_10008C2B8 = (uint64_t)sub_100045768;
  unk_10008C2C0 = sub_1000454F0;
  xmmword_10008C2C8 = 0u;
  unk_10008C2D8 = 0u;
  xmmword_10008C2E8 = 0u;
  int v167 = dword_10008C558++;
  dword_10008C310 = v167;
  int v212 = 39;
  qword_10008C308 = 0LL;
  if (!sub_100063738( &qword_10008C308,  (uint64_t (**)(unsigned __int8 *, int, unsigned int))qword_10008C270,  (const char *)&v212,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1372LL,  v161,  v162)) {
    sub_100061FB4( "Unable to find FQDN v6 parent option. (%s:%d).",  v168,  v169,  v170,  v171,  v172,  v173,  v174,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c");
  }
  *(void *)(qword_10008C570 + 8LL * dword_10008C31__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = &qword_10008C288;
  qword_10008C2F8 = 0LL;
  unk_10008C300 = 0LL;
  sub_100063100( &qword_10008C560,  0LL,  0LL,  0xDu,  sub_1000631AC,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1384LL,  v174);
  sub_1000634B8( qword_10008C560,  (const char *)qword_10008C168,  0LL,  (uint64_t)&qword_10008C168,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1386LL,  v175,  v176,  v194);
  sub_1000634B8( qword_10008C560,  (const char *)qword_10008C4C8,  0LL,  (uint64_t)&qword_10008C4C8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1388LL,  v177,  v178,  v204);
  sub_1000634B8( qword_10008C560,  (const char *)qword_10008C318,  0LL,  (uint64_t)&qword_10008C318,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1390LL,  v179,  v180,  v205);
  sub_1000634B8( qword_10008C560,  (const char *)qword_10008C578,  0LL,  (uint64_t)&qword_10008C578,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1392LL,  v181,  v182,  v206);
  sub_1000634B8( qword_10008C560,  (const char *)qword_10008C608,  0LL,  (uint64_t)&qword_10008C608,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1394LL,  v183,  v184,  v207);
  sub_1000634B8( qword_10008C560,  (const char *)qword_10008C438,  0LL,  (uint64_t)&qword_10008C438,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1396LL,  v185,  v186,  v208);
  sub_1000634B8( qword_10008C560,  (const char *)qword_10008C1F8,  0LL,  (uint64_t)&qword_10008C1F8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1400LL,  v187,  v188,  v209);
  sub_1000634B8( qword_10008C560,  (const char *)qword_10008C698,  0LL,  (uint64_t)&qword_10008C698,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1402LL,  v189,  v190,  v210);
  return sub_1000634B8( qword_10008C560,  (const char *)qword_10008C3A8,  0LL,  (uint64_t)&qword_10008C3A8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tables.c",  1404LL,  v191,  v192,  v211);
}

uint64_t sub_100053FE4( uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11 = *(const char **)(a1 + 8);
  if (!v11)
  {
    uint64_t result = (uint64_t)sub_1000345C4( (void *)a1,  128,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  81LL);
    if (!(_DWORD)result) {
      return result;
    }
    uint64_t v13 = (_BYTE *)(*(void *)a1 + 4LL);
    *(void *)(a1 + 8) = v13;
    *(_DWORD *)(a1 + 16) = 128;
    *uint64_t v13 = 0;
    uint64_t v11 = *(const char **)(a1 + 8);
  }

  int v14 = strlen(v11);
  int v15 = *(_DWORD *)(a1 + 16) - v14;
  uint64_t v33 = &a9;
  int v16 = vsnprintf((char *)(*(void *)(a1 + 8) + v14), v15, a2, &a9);
  if (v16 < v15) {
    return 1LL;
  }
  int v17 = *(_DWORD *)(a1 + 16);
  do
    v17 *= 2;
  while (v17 <= v16 + v14);
  uint64_t v32 = 0LL;
  uint64_t result = (uint64_t)sub_1000345C4( &v32,  v17,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  121LL);
  if ((_DWORD)result)
  {
    memcpy(v32 + 4, *(const void **)(a1 + 8), v14);
    uint64_t v33 = &a9;
    vsprintf(&v32[v14 + 4], a2, &a9);
    sub_10003462C( (_DWORD **)a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  140LL,  v18,  v19,  v20,  v21,  v22);
    sub_100033F18( (void *)a1,  v32,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  141LL,  v23,  v24,  v25,  v26);
    sub_10003462C( (_DWORD **)&v32,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  142LL,  v27,  v28,  v29,  v30,  v31);
    *(void *)(a1 + 8) = *(void *)a1 + 4LL;
    *(_DWORD *)(a1 + 16) = v17;
    return 1LL;
  }

  *(_BYTE *)(*(void *)(a1 + 8) + v14) = 0;
  return result;
}

void *sub_10005415C(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_10005CDE4(0x10uLL);
  if (!result) {
    sub_100061FB4("no memory for cons.", v5, v6, v7, v8, v9, v10, v11, v12);
  }
  void *result = a1;
  result[1] = a2;
  return result;
}

uint64_t sub_1000541B4( void *a1, _DWORD **a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v11 = a4;
  if (a2)
  {
    uint64_t v32 = *a2;
    *a2 = 0LL;
  }

  else
  {
    uint64_t v32 = 0LL;
    if (!sub_1000345C4(&v32, a4, a6, a7))
    {
      sub_10006221C("%s(%d): can't allocate buffer.", v14, v15, a4, a5, a6, a7, a8, a6);
      return 0LL;
    }
  }

  if (!sub_100034540(a1, a6, a7, a4, a5, a6, a7, a8))
  {
    sub_10006221C("%s(%d): can't allocate option cache.", v16, v17, v18, v19, v20, v21, v22, a6);
    sub_10003462C(&v32, a6, a7, v27, v28, v29, v30, v31);
    return 0LL;
  }

  uint64_t v23 = *a1;
  *(_DWORD *)(v23 + 48) = v11;
  uint64_t v24 = v32;
  *(void *)(v23 + 32) = v32;
  *(void *)(*a1 + 40LL) = v24 + 1;
  uint64_t v25 = *a1;
  *(_DWORD *)(*a1 + 52LL) = 0;
  if (a3)
  {
    memcpy(v24 + 1, a3, v11);
    uint64_t v25 = *a1;
  }

  sub_100052CB0((void *)(v25 + 24), a5);
  return 1LL;
}

uint64_t sub_1000542D4( uint64_t *a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  204LL,  a4,  a5,  a6,  a7,  a8))
  {
    uint64_t v17 = *a1;
    *(_DWORD *)(v17 + 4) = 7;
    sub_100054390( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  210LL,  v18,  v19,  v20,  v21,  v22);
  }

  else
  {
    sub_10006221C("No memory for host lookup tree node.", v10, v11, v12, v13, v14, v15, v16, v24);
  }

  return 0LL;
}

uint64_t sub_100054354(void *a1, char *a2)
{
  if (sub_1000346A8( a1,  a2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  224LL)) {
    return 1LL;
  }
  sub_10006221C("Can't allocate space for new host.", v2, v3, v4, v5, v6, v7, v8, vars0);
  return 0LL;
}

uint64_t *sub_100054390( uint64_t *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *result;
  void *result = 0LL;
  BOOL v9 = *(_DWORD *)v8 == 1;
  if ((*(_DWORD *)v8)-- <= 1)
  {
    if (v9)
    {
      switch(*(_DWORD *)(v8 + 4))
      {
        case 3:
        case 5:
        case 6:
        case 8:
        case 9:
        case 0xD:
        case 0x19:
        case 0x1E:
        case 0x20:
        case 0x26:
        case 0x2C:
        case 0x2F:
        case 0x30:
        case 0x31:
        case 0x32:
        case 0x33:
        case 0x34:
        case 0x35:
        case 0x36:
        case 0x37:
        case 0x3A:
        case 0x3B:
          if (*(void *)(v8 + 8)) {
            sub_100054390(v8 + 8, a2, a3);
          }
          goto LABEL_8;
        case 4:
          if (*(void *)(v8 + 8)) {
            sub_100054390(v8 + 8, a2, a3);
          }
          goto LABEL_17;
        case 7:
          if (*(void *)(v8 + 8)) {
            sub_10003473C((int **)(v8 + 8), a2, a3, a4, a5, a6, a7, a8);
          }
          return (uint64_t *)sub_100034438(v8);
        case 0xA:
        case 0xF:
        case 0x10:
        case 0x11:
        case 0x12:
        case 0x13:
        case 0x14:
          uint64_t v13 = v8 + 8;
          if (!*(void *)(v8 + 8)) {
            return (uint64_t *)sub_100034438(v8);
          }
          goto LABEL_30;
        case 0xE:
        case 0x17:
          sub_100034EA8((_DWORD **)(v8 + 8), a2, a3, a4, a5, a6, a7, a8);
          return (uint64_t *)sub_100034438(v8);
        case 0x1B:
          if (*(void *)(v8 + 8)) {
            sub_100054390(v8 + 8, a2, a3);
          }
          goto LABEL_25;
        case 0x22:
LABEL_25:
          if (*(void *)(v8 + 16)) {
            sub_100054390(v8 + 16, a2, a3);
          }
          if (*(void *)(v8 + 24)) {
            sub_100054390(v8 + 24, a2, a3);
          }
          uint64_t v13 = v8 + 32;
          if (*(void *)(v8 + 32)) {
            goto LABEL_30;
          }
          return (uint64_t *)sub_100034438(v8);
        case 0x23:
        case 0x24:
        case 0x25:
LABEL_17:
          if (*(void *)(v8 + 16)) {
            sub_100054390(v8 + 16, a2, a3);
          }
          uint64_t v13 = v8 + 24;
          if (!*(void *)(v8 + 24)) {
            return (uint64_t *)sub_100034438(v8);
          }
          goto LABEL_30;
        case 0x28:
        case 0x29:
          uint64_t v14 = *(void **)(v8 + 8);
          if (v14) {
            sub_10005CE20(v14, a2, a3, a4, a5, a6, a7, a8);
          }
          return (uint64_t *)sub_100034438(v8);
        case 0x2D:
          uint64_t v17 = *(void **)(v8 + 8);
          if (v17) {
            sub_10005CE20(v17, a2, a3, a4, a5, a6, a7, a8);
          }
LABEL_8:
          uint64_t v13 = v8 + 16;
          if (!*(void *)(v8 + 16)) {
            return (uint64_t *)sub_100034438(v8);
          }
LABEL_30:
          uint64_t v15 = (const char *)a2;
          uint64_t v16 = a3;
          break;
        case 0x2E:
          sub_100057BEC((void **)(v8 + 8), a2, a3, a4, a5, a6, a7, a8);
          return (uint64_t *)sub_100034438(v8);
        case 0x38:
          uint64_t v13 = v8 + 8;
          if (!*(void *)(v8 + 8)) {
            return (uint64_t *)sub_100034438(v8);
          }
          uint64_t v15 = "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c";
          uint64_t v16 = 3057LL;
          break;
        case 0x39:
          uint64_t v13 = v8 + 8;
          if (!*(void *)(v8 + 8)) {
            return (uint64_t *)sub_100034438(v8);
          }
          uint64_t v15 = "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c";
          uint64_t v16 = 3052LL;
          break;
        default:
          return (uint64_t *)sub_100034438(v8);
      }

      sub_100054390(v13, v15, v16);
      return (uint64_t *)sub_100034438(v8);
    }

    else
    {
      return (uint64_t *)sub_10006221C("%s(%d): negative refcnt!", a2, a3, a4, a5, a6, a7, a8, a2);
    }
  }

  return result;
}

uint64_t sub_1000545BC( uint64_t *a1, const void *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = a5;
  int v11 = a4;
  if (sub_1000343B4(a1, a6, a7, a4, a5, a6, a7, a8))
  {
    uint64_t v22 = *a1;
    if (!a3)
    {
      *(void *)(v22 + 16) = 0LL;
LABEL_10:
      *(_DWORD *)(v22 + 4) = 14;
      *(_DWORD *)(v22 + 24) = a3;
      return 1LL;
    }

    if (!v10)
    {
      *(void *)(v22 + 16) = a2;
      goto LABEL_9;
    }

    if (sub_1000345C4((void *)(v22 + 8), v11 + a3, a6, a7))
    {
      uint64_t v30 = (void *)(*(void *)(v22 + 8) + 4LL);
      *(void *)(v22 + 16) = v30;
      memcpy(v30, a2, (v11 + a3));
LABEL_9:
      *(_DWORD *)(v22 + 28) = v11;
      goto LABEL_10;
    }

    sub_10006221C("Can't allocate const_data buffer", v23, v24, v25, v26, v27, v28, v29, v37);
    sub_100054390(a1, a6, a7, v32, v33, v34, v35, v36);
  }

  else
  {
    sub_10006221C("No memory for make_const_data tree node.", v15, v16, v17, v18, v19, v20, v21, v37);
  }

  return 0LL;
}

uint64_t sub_1000546B0( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  270LL,  a4,  a5,  a6,  a7,  a8))
  {
    uint64_t v17 = *a1;
    *(_DWORD *)(v17 + 4) = 21;
    *(void *)(v17 + 8) = a2;
    return 1LL;
  }

  else
  {
    sub_10006221C("No memory for make_const_int tree node.", v10, v11, v12, v13, v14, v15, v16, v19);
    return 0LL;
  }

uint64_t sub_10005470C( void *a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v9 = a1;
  if (a2)
  {
    uint64_t v10 = a2;
    if (!a3)
    {
      uint64_t v19 = 294LL;
      goto LABEL_8;
    }

    if (sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  299LL,  a4,  a5,  a6,  a7,  a8))
    {
      uint64_t v18 = *v9;
      *(_DWORD *)(v18 + 4) = 6;
      sub_100033F18( (void *)(v18 + 8),  v10,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  305LL,  v14,  v15,  v16,  v17);
      a1 = (void *)(*v9 + 16LL);
      a2 = a3;
      uint64_t v19 = 306LL;
LABEL_8:
      sub_100033F18(a1, a2, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c", v19, a5, a6, a7, a8);
      return 1LL;
    }

    sub_10006221C("No memory for concatenation expression node.", v11, v12, v13, v14, v15, v16, v17, v21);
  }

  else if (a3)
  {
    a2 = a3;
    uint64_t v19 = 290LL;
    goto LABEL_8;
  }

  return 0LL;
}

uint64_t sub_1000547E4( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  315LL,  a4,  a5,  a6,  a7,  a8))
  {
    uint64_t v17 = *a1;
    *(_DWORD *)(v17 + 4) = 23;
    sub_100034E60( v17 + 8,  a2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  321LL,  v13,  v14,  v15,  v16);
    return 1LL;
  }

  else
  {
    sub_10006221C("No memory for encapsulation expression node.", v10, v11, v12, v13, v14, v15, v16, v19);
    return 0LL;
  }

uint64_t sub_100054854( void *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  332LL,  (uint64_t)a4,  a5,  a6,  a7,  a8))
  {
    uint64_t v19 = *a1;
    *(_DWORD *)(v19 + 4) = 4;
    sub_100033F18( (void *)(v19 + 8),  a2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  337LL,  v15,  v16,  v17,  v18);
    sub_100033F18( (void *)(*a1 + 16LL),  a3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  338LL,  v20,  v21,  v22,  v23);
    sub_100033F18( (void *)(*a1 + 24LL),  a4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  339LL,  v24,  v25,  v26,  v27);
    return 1LL;
  }

  else
  {
    sub_10006221C("no memory for substring expression.", v12, v13, v14, v15, v16, v17, v18, v29);
    return 0LL;
  }

uint64_t sub_100054910( uint64_t *a1, _DWORD *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!sub_1000343B4( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  349LL,  a4,  a5,  a6,  a7,  a8)) {
    sub_10006221C("no memory for limit expression", v11, v12, v13, v14, v15, v16, v17, v48);
  }
  uint64_t v18 = *a1;
  *(_DWORD *)(v18 + 4) = 4;
  sub_100033F18( (void *)(v18 + 8),  a2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  352LL,  v14,  v15,  v16,  v17);
  if (sub_1000343B4( (void *)(*a1 + 16),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  355LL,  v19,  v20,  v21,  v22,  v23))
  {
    uint64_t v31 = *a1;
    *(_DWORD *)(*(void *)(*a1 + 16) + 4LL) = 21;
    *(void *)(*(void *)(v31 + 16) + 8LL) = 0LL;
    if (sub_1000343B4( (void *)(*a1 + 24),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  364LL,  v26,  v27,  v28,  v29,  v30))
    {
      uint64_t v39 = *a1;
      *(_DWORD *)(*(void *)(*a1 + 24) + 4LL) = 21;
      *(void *)(*(void *)(v39 + 24) + 8LL) = a3;
      return 1LL;
    }

    sub_10006221C("no memory for limit length expression", v32, v33, v34, v35, v36, v37, v38, v48);
    uint64_t v46 = a1;
    uint64_t v47 = 366LL;
  }

  else
  {
    sub_10006221C("no memory for limit offset expression", v24, v25, v26, v27, v28, v29, v30, v48);
    uint64_t v46 = a1;
    uint64_t v47 = 357LL;
  }

  sub_100054390( v46,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  v47,  v41,  v42,  v43,  v44,  v45);
  return 0LL;
}

uint64_t sub_100054A34( void *a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = (uint64_t)sub_100034540(a1, a5, a6, a4, a5, a6, a7, a8);
  if ((_DWORD)result)
  {
    if (a2) {
      sub_100034E60(*a1 + 32LL, a2, a5, a6, v15, v16, v17, v18);
    }
    if (a3) {
      sub_100033F18((void *)(*a1 + 16LL), a3, a5, a6, v15, v16, v17, v18);
    }
    sub_100052CB0((void *)(*a1 + 24LL), a4);
    return 1LL;
  }

  return result;
}

uint64_t sub_100054ADC(void **a1, const char *a2)
{
  uint64_t result = (uint64_t)sub_100034984(a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c", 393LL);
  if ((_DWORD)result)
  {
    *((_DWORD *)*a1 + 4) = 17;
    int v5 = strlen(a2);
    *((void *)*a1 + 3) = sub_10005CDE4((v5 + 1));
    uint64_t v11 = (char *)*((void *)*a1 + 3);
    if (v11)
    {
      strcpy(v11, a2);
      return 1LL;
    }

    else
    {
      sub_10003DC78( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  399LL,  v6,  v7,  v8,  v9,  v10);
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_100054B74( void *a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8, uint64_t a9, unsigned int a10)
{
  uint64_t v17 = a1;
  uint64_t v18 = a10;
  uint64_t v19 = a9;
  uint64_t v83 = 0LL;
  int v20 = *(_DWORD *)(a8 + 4);
  switch(v20)
  {
    case 2:
    case 3:
    case 8:
    case 9:
    case 10:
    case 22:
    case 24:
    case 33:
    case 38:
    case 40:
    case 58:
    case 59:
      if (!sub_10003444C( &v83,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  633LL,  a4,  a5,  a6,  (uint64_t)a7,  a8)) {
        return 0LL;
      }
      uint64_t v31 = v83;
      v83[1] = 0;
      uint64_t v30 = sub_10005525C(v31 + 2, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
      goto LABEL_10;
    case 4:
    case 5:
    case 6:
    case 7:
    case 11:
    case 12:
    case 13:
    case 14:
    case 18:
    case 19:
    case 20:
    case 23:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 39:
    case 42:
    case 43:
    case 56:
    case 57:
      unsigned int v81 = a10;
      if (!sub_10003444C( &v83,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  647LL,  a4,  a5,  a6,  (uint64_t)a7,  a8)) {
        return 0LL;
      }
      uint64_t v22 = v83;
      v83[1] = 1;
      uint64_t v28 = sub_10005618C( v22 + 2,  a2,  a3,  a4,  a5,  a6,  a7,  a8,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  652);
      uint64_t v19 = a9;
      uint64_t v17 = a1;
      goto LABEL_4;
    case 15:
    case 16:
    case 17:
    case 21:
    case 31:
    case 32:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
      if (!sub_10003444C( &v83,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  640LL,  a4,  a5,  a6,  (uint64_t)a7,  a8)) {
        return 0LL;
      }
      uint64_t v29 = (unint64_t *)v83;
      v83[1] = 2;
      uint64_t v30 = sub_10005591C(v29 + 1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
      goto LABEL_10;
    case 41:
      if (!a7) {
        return 0LL;
      }
      uint64_t v32 = *a7;
      if (!*a7) {
        return 0LL;
      }
      uint64_t v33 = *(const char **)(a8 + 8);
LABEL_19:
      uint64_t v28 = v32 + 16;
      do
      {
        uint64_t v28 = *(void *)v28;
        if (!v28)
        {
          uint64_t v32 = *(void *)(v32 + 8);
          if (v32) {
            goto LABEL_19;
          }
          return v28;
        }
      }

      while (strcasecmp(v33, *(const char **)(v28 + 8)));
      uint64_t v42 = *(_DWORD **)(v28 + 16);
      if (!v42) {
        return 0LL;
      }
      if (v17) {
        sub_100033F18(v17, v42, a9, a10, v34, v35, v36, v37);
      }
      return 1LL;
    case 45:
      if (!a7 || (uint64_t v38 = *a7) == 0)
      {
        uint64_t v76 = *(void *)(a8 + 8);
LABEL_52:
        sub_10006221C("%s: no such function.", (uint64_t)a2, a3, a4, a5, a6, (uint64_t)a7, a8, v76);
        return 0LL;
      }

      unsigned int v81 = a10;
      uint64_t v39 = *(const char **)(a8 + 8);
LABEL_28:
      uint64_t v79 = v38;
      uint64_t v40 = v38 + 16;
      do
      {
        uint64_t v40 = *(void *)v40;
        if (!v40)
        {
          uint64_t v38 = *(void *)(v79 + 8);
          if (!v38) {
            goto LABEL_51;
          }
          goto LABEL_28;
        }
      }

      while (strcasecmp(v39, *(const char **)(v40 + 8)));
      uint64_t v43 = *(void *)(v40 + 16);
      if (!v43)
      {
LABEL_51:
        LOBYTE(v76) = (_BYTE)v39;
        goto LABEL_52;
      }

      if (*(_DWORD *)(v43 + 4) != 4)
      {
        sub_10006221C("%s: not a function.", (uint64_t)a2, a3, a4, a5, a6, (uint64_t)a7, a8, (char)v39);
        return 0LL;
      }

      uint64_t v82 = 0LL;
      if (!sub_100034DAC( &v82,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  573LL,  a4,  a5,  a6,  (uint64_t)a7,  a8))
      {
        sub_10006221C("%s: can't allocate argument scope.", v44, v45, v46, v47, v48, v49, v50, *(void *)(a8 + 8));
        return 0LL;
      }

      uint64_t v51 = *(void *)(a8 + 16);
      uint64_t v52 = *(const char **)(*(void *)(*(void *)(v40 + 16) + 8LL) + 8LL);
      BOOL v53 = v51 != 0;
      BOOL v54 = v52 != 0LL;
      if (!v51)
      {
        uint64_t v19 = a9;
        goto LABEL_58;
      }

      uint64_t v80 = *(void *)(a8 + 16);
      uint64_t v19 = a9;
      if (!v52)
      {
LABEL_58:
        if (v53)
        {
          sub_10006221C("%s: too many arguments.", v44, v45, v46, v47, v48, v49, v50, *(void *)(a8 + 8));
          uint64_t v70 = 611LL;
          goto LABEL_64;
        }

        if (v54)
        {
          sub_10006221C("%s: too few arguments.", v44, v45, v46, v47, v48, v49, v50, *(void *)(a8 + 8));
          uint64_t v70 = 617LL;
          goto LABEL_64;
        }

        if (*a7) {
          sub_100033F18( (void *)(v82 + 8),  (_DWORD *)*a7,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  622LL,  v47,  v48,  v49,  v50);
        }
        uint64_t v28 = sub_10003D510( &v83,  a2,  a3,  a4,  a5,  a6,  &v82,  *(_DWORD **)(*(void *)(*(void *)(v40 + 16) + 8LL) + 16LL));
        sub_10005515C( &v82,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  628LL,  v71,  v72,  v73,  v74,  v75);
        if (!v83) {
          return 1LL;
        }
LABEL_4:
        uint64_t v18 = v81;
        if (v17) {
          goto LABEL_11;
        }
LABEL_13:
        sub_1000577E8( (uint64_t *)&v83,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  669LL,  v23,  v24,  v25,  v26,  v27);
        return v28;
      }

      while (1)
      {
        uint64_t v78 = v52;
        uint64_t v55 = sub_10005CDE4(0x18uLL);
        if (!v55) {
          break;
        }
        void *v55 = 0LL;
        v55[1] = 0LL;
        v55[2] = 0LL;
        uint64_t v77 = v55;
        int v61 = strlen(v78 + 8);
        uint64_t v62 = (char *)sub_10005CDE4((v61 + 1));
        v77[1] = v62;
        if (!v62)
        {
          sub_10005CE20( v77,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  594LL,  v63,  v64,  v65,  v66,  v67);
          break;
        }

        strcpy(v62, v78 + 8);
        uint64_t v19 = a9;
        sub_100054B74(v77 + 2, a2, a3, a4, a5, a6, a7, *(void *)(v80 + 8), a9, a10);
        *uint64_t v77 = *(void *)(v82 + 16);
        *(void *)(v82 + 16) = v77;
        uint64_t v68 = *(void *)(v80 + 16);
        uint64_t v52 = *(const char **)v78;
        BOOL v53 = v68 != 0;
        BOOL v54 = *(void *)v78 != 0LL;
        uint64_t v80 = v68;
        if (!v68 || !v52) {
          goto LABEL_58;
        }
      }

      uint64_t v70 = 585LL;
LABEL_64:
      sub_10005515C( &v82,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  v70,  v56,  v57,  v58,  v59,  v60);
      return 0LL;
    default:
      if ((v20 - 38) < 0xFFFFFFFC)
      {
        sub_10006221C( "%s: invalid expression type: %d",  (uint64_t)a2,  a3,  a4,  a5,  a6,  (uint64_t)a7,  a8,  (char)"evaluate_expression");
        return 0LL;
      }

      if (!sub_10003444C( &v83,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  655LL,  a4,  a5,  a6,  (uint64_t)a7,  a8)) {
        return 0LL;
      }
      uint64_t v41 = (uint64_t *)v83;
      v83[1] = 3;
      uint64_t v30 = sub_1000573C0(v41 + 1, (uint64_t)a2, a3, a4, a5, a6, (uint64_t)a7, a8);
LABEL_10:
      uint64_t v28 = v30;
      if (v17)
      {
LABEL_11:
        if ((_DWORD)v28) {
          sub_100033F18(v17, v83, v19, v18, v24, v25, v26, v27);
        }
      }

      goto LABEL_13;
  }

uint64_t **sub_100055100(uint64_t a1, char *a2)
{
  if (a1)
  {
    uint64_t v3 = a1;
    do
    {
      uint64_t v4 = (uint64_t **)(v3 + 16);
      while (1)
      {
        uint64_t v4 = (uint64_t **)*v4;
        if (!v4) {
          break;
        }
      }

      uint64_t v3 = *(void *)(v3 + 8);
    }

    while (v3);
  }

  return 0LL;
}

uint64_t sub_10005515C( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && (uint64_t v10 = (void *)*a1) != 0LL)
  {
    *a1 = 0LL;
    int v11 = (*(_DWORD *)v10)--;
    if (v11 > 1) {
      return 1LL;
    }
    if (v11 == 1)
    {
      sub_1000591B0((uint64_t)v10, a2, a3, a4, a5, a6, a7, a8);
      if (v10[1]) {
        sub_10005515C(v10 + 1, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c", 4067LL);
      }
      sub_10005CE20(v10, a2, a3, v12, v13, v14, v15, v16);
      return 1LL;
    }

    sub_10006221C("%s(%d): negative refcnt!", a2, a3, a4, a5, a6, a7, a8, a2);
  }

  else
  {
    sub_10006221C("%s(%d): null pointer", a2, a3, a4, a5, a6, a7, a8, a2);
  }

  return 0LL;
}

BOOL sub_10005521C(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 4);
  return v1 <= 0x3B && ((1LL << v1) & 0xC0001400140070CLL) != 0 || v1 == 33;
}

uint64_t sub_10005525C( int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8)
{
  int v16 = 5;
  switch(*(_DWORD *)(a8 + 4))
  {
    case 0:
    case 1:
    case 4:
    case 5:
    case 6:
    case 7:
    case 0xB:
    case 0xC:
    case 0xD:
    case 0xE:
    case 0x12:
    case 0x13:
    case 0x14:
    case 0x17:
    case 0x19:
    case 0x1A:
    case 0x1B:
    case 0x1C:
    case 0x1D:
    case 0x1E:
    case 0x27:
    case 0x2A:
    case 0x2B:
    case 0x38:
    case 0x39:
      sub_10006221C( "Data opcode in evaluate_BOOLean_expression: %d",  a2,  a3,  a4,  a5,  a6,  (uint64_t)a7,  a8,  *(_DWORD *)(a8 + 4));
      return 0LL;
    case 2:
      *a1 = sub_100003454(a2, a3, *(void *)(a8 + 8));
      return 1LL;
    case 3:
    case 0x26:
      uint64_t v75 = 0LL;
      *(void *)&v71.int re_magic = 0LL;
      int v17 = sub_100054B74( &v71,  a2,  a3,  a4,  a5,  a6,  a7,  *(void *)(a8 + 8),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  1029);
      int v18 = sub_100054B74( &v75,  a2,  a3,  a4,  a5,  a6,  a7,  *(void *)(a8 + 16),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  1033);
      int v24 = v18;
      if (v17) {
        BOOL v25 = v18 == 0;
      }
      else {
        BOOL v25 = 1;
      }
      if (!v25)
      {
        int v60 = *(_DWORD *)(*(void *)&v71.re_magic + 4LL);
        if (v60 == *((_DWORD *)v75 + 1))
        {
          switch(v60)
          {
            case 0:
              int v66 = *(_DWORD *)(a8 + 4);
              BOOL v62 = v66 == 38;
              BOOL v63 = v66 == 3;
              BOOL v64 = *(_DWORD *)(*(void *)&v71.re_magic + 8LL) == *((_DWORD *)v75 + 2);
              goto LABEL_86;
            case 1:
              size_t v68 = *(unsigned int *)(*(void *)&v71.re_magic + 24LL);
              if ((_DWORD)v68 != *((_DWORD *)v75 + 6)
                || memcmp(*(const void **)(*(void *)&v71.re_magic + 16LL), v75[2], v68))
              {
                goto LABEL_91;
              }

              BOOL v69 = *(_DWORD *)(a8 + 4) == 3;
              goto LABEL_92;
            case 2:
            case 3:
            case 4:
              int v61 = *(_DWORD *)(a8 + 4);
              BOOL v62 = v61 == 38;
              BOOL v63 = v61 == 3;
              BOOL v64 = *(void *)(*(void *)&v71.re_magic + 8LL) == (void)v75[1];
LABEL_86:
              if (v64) {
                int v67 = v63;
              }
              else {
                int v67 = v62;
              }
              break;
            default:
              goto LABEL_91;
          }
        }

        else
        {
LABEL_91:
          BOOL v69 = *(_DWORD *)(a8 + 4) == 38;
LABEL_92:
          int v67 = v69;
        }

        *a1 = v67;
        goto LABEL_96;
      }

      int v26 = *(_DWORD *)(a8 + 4);
      if (v17 | v18)
      {
        *a1 = v26 == 38;
        if (!v17)
        {
LABEL_97:
          if (v24) {
            sub_1000577E8( (uint64_t *)&v75,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  1101LL,  v19,  v20,  v21,  v22,  v23);
          }
          return 1LL;
        }

LABEL_96:
        sub_1000577E8( (uint64_t *)&v71.re_magic,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  1099LL,  v19,  v20,  v21,  v22,  v23);
        goto LABEL_97;
      }

      BOOL v32 = v26 == 3;
LABEL_75:
      int v28 = v32;
LABEL_78:
      *a1 = v28;
      return 1LL;
    case 8:
      else {
        BOOL v27 = 1;
      }
      int v28 = (_DWORD)v75 != 0;
      goto LABEL_78;
    case 9:
      LODWORD(v75) = 0;
      v71.int re_magic = 0;
      int v29 = sub_10005525C(&v71);
      int v28 = 0;
      int re_magic = v71.re_magic;
      if (v29) {
        BOOL v31 = v71.re_magic == 0;
      }
      else {
        BOOL v31 = 1;
      }
      if (!v31) {
        goto LABEL_26;
      }
      int v28 = (_DWORD)v75 != 0;
LABEL_26:
      if (re_magic) {
        int v28 = 1;
      }
      goto LABEL_78;
    case 0xA:
      BOOL v32 = v71.re_magic == 0;
      goto LABEL_75;
    case 0xF:
    case 0x10:
    case 0x11:
    case 0x15:
    case 0x1F:
    case 0x20:
    case 0x2F:
    case 0x30:
    case 0x31:
    case 0x32:
    case 0x33:
    case 0x34:
    case 0x35:
    case 0x36:
    case 0x37:
      sub_10006221C( "Numeric opcode in evaluate_BOOLean_expression: %d",  a2,  a3,  a4,  a5,  a6,  (uint64_t)a7,  a8,  *(_DWORD *)(a8 + 4));
      return 0LL;
    case 0x16:
      uint64_t v75 = 0LL;
      uint64_t v76 = 0LL;
      uint64_t v77 = 0LL;
      if (!a5
        || !sub_100043AE8( (uint64_t)&v75,  *(void *)(*(void *)(a8 + 8) + 16LL),  a2,  a3,  a4,  a5,  a6,  a5,  (uint64_t)a7,  *(_DWORD *)(*(void *)(a8 + 8) + 24LL),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  1242))
      {
        goto LABEL_41;
      }

      uint64_t v38 = 1LL;
      *a1 = 1;
      sub_100034EA8( (_DWORD **)&v75,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  1246LL,  v33,  v34,  v35,  v36,  v37);
      return v38;
    case 0x18:
      if (!a2) {
        return 0LL;
      }
      int v28 = *(_DWORD *)(a2 + 216);
      goto LABEL_78;
    case 0x21:
      if (!a3 || (*(_BYTE *)(a3 + 221) & 1) == 0) {
        goto LABEL_41;
      }
      goto LABEL_40;
    case 0x22:
    case 0x23:
    case 0x24:
    case 0x25:
      sub_10006221C( "dns opcode in evaluate_BOOLean_expression: %d",  a2,  a3,  a4,  a5,  a6,  (uint64_t)a7,  a8,  *(_DWORD *)(a8 + 4));
      return 0LL;
    case 0x28:
      if (a7)
      {
        if (*a7)
        {
          uint64_t v39 = sub_100055100(*a7, *(char **)(a8 + 8));
          if (v39)
          {
            if (v39[2])
            {
LABEL_40:
              uint64_t v38 = 1LL;
              *a1 = 1;
              return v38;
            }
          }
        }
      }

LABEL_41:
      *a1 = 0;
      return 1LL;
    case 0x29:
      if (!a7) {
        return 0LL;
      }
      if (!*a7) {
        return 0LL;
      }
      uint64_t v40 = sub_100055100(*a7, *(char **)(a8 + 8));
      if (!v40) {
        return 0LL;
      }
      uint64_t v48 = v40[2];
      if (!v48) {
        return 0LL;
      }
      int v49 = *((_DWORD *)v48 + 1);
      if (!v49)
      {
        int v28 = *((_DWORD *)v48 + 2);
        goto LABEL_78;
      }

      sub_10006221C("binding type %d in %s.", v41, v42, v43, v44, v45, v46, v47, v49);
      return 0LL;
    case 0x2D:
      *(void *)&v71.int re_magic = 0LL;
      if (sub_100054B74( &v71,  a2,  a3,  a4,  a5,  a6,  a7,  a8,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  1337))
      {
        if (*(_DWORD *)(*(void *)&v71.re_magic + 4LL)) {
          sub_10006221C("%s() returned type %d in %s.", a2, a3, a4, a5, a6, (uint64_t)a7, a8, *(void *)(a8 + 8));
        }
        else {
          *a1 = *(_DWORD *)(*(void *)&v71.re_magic + 8LL);
        }
        sub_1000577E8( (uint64_t *)&v71.re_magic,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  1346LL,  a4,  a5,  a6,  (uint64_t)a7,  a8);
      }

      goto LABEL_81;
    case 0x2E:
      uint64_t v50 = "function definition in evaluate_BOOLean_expr";
      goto LABEL_82;
    case 0x3A:
      goto LABEL_53;
    case 0x3B:
      int v16 = 7;
LABEL_53:
      uint64_t v75 = 0LL;
      uint64_t v76 = 0LL;
      uint64_t v77 = 0LL;
      int v51 = sub_10005618C( &v75,  a2,  a3,  a4,  a5,  a6,  a7,  *(void *)(a8 + 8),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  1116);
      uint64_t v73 = 0LL;
      uint64_t v74 = 0LL;
      uint64_t v72 = 0LL;
      int v52 = sub_10005618C( &v72,  a2,  a3,  a4,  a5,  a6,  a7,  *(void *)(a8 + 16),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  1122);
      int v58 = v52;
      *a1 = 0;
      memset(&v71, 0, sizeof(v71));
      if (v51) {
        BOOL v59 = v52 == 0;
      }
      else {
        BOOL v59 = 1;
      }
      uint64_t v38 = !v59;
      if (v59)
      {
        if (!v51) {
          goto LABEL_68;
        }
      }

      else if (!regcomp(&v71, v73, v16) && !regexec(&v71, v76, 0LL, 0LL, 0))
      {
        *a1 = 1;
      }

      sub_100034EA8( (_DWORD **)&v75,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  1141LL,  v53,  v54,  v55,  v56,  v57);
LABEL_68:
      if (v58) {
        sub_100034EA8( &v72,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  1143LL,  v53,  v54,  v55,  v56,  v57);
      }
      regfree(&v71);
      return v38;
    default:
LABEL_81:
      int v70 = *(_DWORD *)(a8 + 4);
      uint64_t v50 = "Bogus opcode in evaluate_BOOLean_expression: %d";
LABEL_82:
      sub_10006221C(v50, a2, a3, a4, a5, a6, (uint64_t)a7, a8, v70);
      return 0LL;
  }

BOOL sub_1000558E0(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 4);
  return v1 <= 0x36 && ((1LL << v1) & 0x7F800180238000LL) != 0 || v1 == 55;
}

BOOL sub_10005591C( unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8)
{
  uint64_t v8 = a8;
  uint64_t v9 = (uint64_t)a7;
  switch(*(_DWORD *)(a8 + 4))
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 8:
    case 9:
    case 0xA:
    case 0x16:
    case 0x18:
    case 0x21:
    case 0x26:
    case 0x28:
    case 0x3A:
    case 0x3B:
      sub_10006221C( "Boolean opcode in evaluate_numeric_expression: %d",  a2,  a3,  a4,  a5,  a6,  (uint64_t)a7,  a8,  *(_DWORD *)(a8 + 4));
      return 0LL;
    case 4:
    case 5:
    case 6:
    case 7:
    case 0xB:
    case 0xC:
    case 0xD:
    case 0xE:
    case 0x12:
    case 0x13:
    case 0x14:
    case 0x17:
    case 0x19:
    case 0x1A:
    case 0x1B:
    case 0x1C:
    case 0x1D:
    case 0x1E:
    case 0x27:
    case 0x2A:
    case 0x2B:
    case 0x38:
    case 0x39:
      sub_10006221C( "Data opcode in evaluate_numeric_expression: %d",  a2,  a3,  a4,  a5,  a6,  (uint64_t)a7,  a8,  *(_DWORD *)(a8 + 4));
      return 0LL;
    case 0xF:
      uint64_t v95 = 0LL;
      uint64_t v96 = 0LL;
      uint64_t v97 = 0LL;
      uint64_t v9 = sub_10005618C( &v95,  a2,  a3,  a4,  a5,  a6,  a7,  *(void *)(a8 + 8),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  2431);
      if ((_DWORD)v9)
      {
        *a1 = *(unsigned __int8 *)v96;
        sub_100034EA8( (_DWORD **)&v95,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  2439LL,  v16,  v17,  v18,  v19,  v20);
      }

      return v9;
    case 0x10:
      uint64_t v95 = 0LL;
      uint64_t v96 = 0LL;
      uint64_t v97 = 0LL;
      int v21 = sub_10005618C( &v95,  a2,  a3,  a4,  a5,  a6,  a7,  *(void *)(a8 + 8),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  2446);
      int v27 = v21;
      unsigned int v28 = v97;
      if (v21) {
        BOOL v29 = v97 >= 2;
      }
      else {
        BOOL v29 = 0;
      }
      if (v29)
      {
        *a1 = sub_100060B5C(v96);
      }

      else if (!v21)
      {
        return v27 && v28 > 1;
      }

      sub_100034EA8( (_DWORD **)&v95,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  2455LL,  v22,  v23,  v24,  v25,  v26);
      unsigned int v28 = v97;
      return v27 && v28 > 1;
    case 0x11:
      uint64_t v95 = 0LL;
      uint64_t v96 = 0LL;
      uint64_t v97 = 0LL;
      int v30 = sub_10005618C( &v95,  a2,  a3,  a4,  a5,  a6,  a7,  *(void *)(a8 + 8),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  2462);
      int v36 = v30;
      unsigned int v37 = v97;
      if (v30) {
        BOOL v38 = v97 >= 4;
      }
      else {
        BOOL v38 = 0;
      }
      if (v38)
      {
        *a1 = sub_100060B50((unsigned int *)v96);
      }

      else if (!v30)
      {
        return v36 && v37 > 3;
      }

      sub_100034EA8( (_DWORD **)&v95,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  2471LL,  v31,  v32,  v33,  v34,  v35);
      unsigned int v37 = v97;
      return v36 && v37 > 3;
    case 0x15:
      unint64_t v39 = *(void *)(a8 + 8);
      goto LABEL_91;
    case 0x1F:
      if (!a3)
      {
        int v61 = "data: leased_lease: not available";
LABEL_123:
        sub_10006221C(v61, a2, a3, a4, a5, a6, (uint64_t)a7, a8, v93);
        return 0LL;
      }

      uint64_t v40 = *(void *)(a3 + 88);
      if (v40 < qword_10008CE80)
      {
        sub_10006221C( "%s %lu when it is now %lu",  a2,  a3,  a4,  a5,  a6,  (uint64_t)a7,  a8,  (char)"data: lease_time: lease ends at");
        return 0LL;
      }

      *a1 = v40 - qword_10008CE80;
      return 1LL;
    case 0x20:
      if (!dword_10008C728)
      {
        sub_10006C408((uint64_t)qword_10008C738);
        dword_10008C728 = 1;
        qword_10008C738[0] = 0x100000001LL;
      }

      uint64_t v41 = 0LL;
      unint64_t v42 = 0LL;
      uint64_t v95 = 0LL;
      uint64_t v96 = 0LL;
      break;
    case 0x22:
    case 0x23:
    case 0x24:
    case 0x25:
      sub_10006221C( "dns opcode in evaluate_numeric_expression: %d",  a2,  a3,  a4,  a5,  a6,  (uint64_t)a7,  a8,  *(_DWORD *)(a8 + 4));
      return 0LL;
    case 0x29:
      if (!a7) {
        return v9;
      }
      if (!*a7) {
        return 0LL;
      }
      int v51 = sub_100055100(*a7, *(char **)(a8 + 8));
      if (!v51) {
        return 0LL;
      }
      BOOL v59 = v51[2];
      if (!v59) {
        return 0LL;
      }
      int v60 = *((_DWORD *)v59 + 1);
      if (v60 == 2)
      {
        unint64_t v39 = v59[1];
LABEL_91:
        *a1 = v39;
        return 1LL;
      }

      else
      {
        sub_10006221C("binding type %d in %s.", v52, v53, v54, v55, v56, v57, v58, v60);
        return 0LL;
      }

    case 0x2C:
      goto LABEL_122;
    case 0x2D:
      uint64_t v95 = 0LL;
      if (sub_100054B74( &v95,  a2,  a3,  a4,  a5,  a6,  a7,  a8,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  2580))
      {
        if (*((_DWORD *)v95 + 1) == 2) {
          *a1 = *((void *)v95 + 1);
        }
        else {
          sub_10006221C("%s() returned type %d in %s.", a2, a3, a4, a5, a6, (uint64_t)a7, a8, *(void *)(v8 + 8));
        }
        sub_1000577E8( (uint64_t *)&v95,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  2589LL,  a4,  a5,  a6,  (uint64_t)a7,  a8);
      }

LABEL_122:
      int v93 = *(_DWORD *)(v8 + 4);
      int v61 = "evaluate_numeric_expression: bogus opcode %d";
      goto LABEL_123;
    case 0x2E:
      int v61 = "function definition in evaluate_numeric_expr";
      goto LABEL_123;
    case 0x2F:
      int v62 = sub_10005591C(&v95, a2, a3, a4, a5, a6, a7, *(void *)(a8 + 8));
      int v63 = sub_10005591C(&v94, a2, a3, a4, a5, a6, v9, *(void *)(v8 + 16));
      if (v62) {
        BOOL v64 = v63 == 0;
      }
      else {
        BOOL v64 = 1;
      }
      if (v64) {
        return 0LL;
      }
      unint64_t v39 = (unint64_t)v95 + (void)v94;
      goto LABEL_91;
    case 0x30:
      int v65 = sub_10005591C(&v95, a2, a3, a4, a5, a6, a7, *(void *)(a8 + 8));
      int v66 = sub_10005591C(&v94, a2, a3, a4, a5, a6, v9, *(void *)(v8 + 16));
      if (v65) {
        BOOL v67 = v66 == 0;
      }
      else {
        BOOL v67 = 1;
      }
      if (v67) {
        return 0LL;
      }
      unint64_t v39 = (_BYTE *)v95 - (_BYTE *)v94;
      goto LABEL_91;
    case 0x31:
      int v68 = sub_10005591C(&v95, a2, a3, a4, a5, a6, a7, *(void *)(a8 + 8));
      int v69 = sub_10005591C(&v94, a2, a3, a4, a5, a6, v9, *(void *)(v8 + 16));
      if (v68) {
        BOOL v70 = v69 == 0;
      }
      else {
        BOOL v70 = 1;
      }
      if (v70) {
        return 0LL;
      }
      unint64_t v39 = (void)v94 * (void)v95;
      goto LABEL_91;
    case 0x32:
      int v71 = sub_10005591C(&v95, a2, a3, a4, a5, a6, a7, *(void *)(a8 + 8));
      int v72 = sub_10005591C(&v94, a2, a3, a4, a5, a6, v9, *(void *)(v8 + 16));
      if (v71) {
        BOOL v73 = v72 == 0;
      }
      else {
        BOOL v73 = 1;
      }
      if (v73 || v94 == 0LL) {
        return 0LL;
      }
      unint64_t v39 = (unint64_t)v95 / (unint64_t)v94;
      goto LABEL_91;
    case 0x33:
      int v75 = sub_10005591C(&v95, a2, a3, a4, a5, a6, a7, *(void *)(a8 + 8));
      int v76 = sub_10005591C(&v94, a2, a3, a4, a5, a6, v9, *(void *)(v8 + 16));
      if (v75) {
        BOOL v77 = v76 == 0;
      }
      else {
        BOOL v77 = 1;
      }
      if (v77 || v94 == 0LL) {
        return 0LL;
      }
      unint64_t v39 = (unint64_t)v95 % (unint64_t)v94;
      goto LABEL_91;
    case 0x34:
      int v79 = sub_10005591C(&v95, a2, a3, a4, a5, a6, a7, *(void *)(a8 + 8));
      int v80 = sub_10005591C(&v94, a2, a3, a4, a5, a6, v9, *(void *)(v8 + 16));
      if (v79) {
        BOOL v81 = v80 == 0;
      }
      else {
        BOOL v81 = 1;
      }
      if (v81) {
        return 0LL;
      }
      unint64_t v39 = (unint64_t)v94 & (unint64_t)v95;
      goto LABEL_91;
    case 0x35:
      int v82 = sub_10005591C(&v95, a2, a3, a4, a5, a6, a7, *(void *)(a8 + 8));
      int v83 = sub_10005591C(&v94, a2, a3, a4, a5, a6, v9, *(void *)(v8 + 16));
      if (v82) {
        BOOL v84 = v83 == 0;
      }
      else {
        BOOL v84 = 1;
      }
      if (v84) {
        return 0LL;
      }
      unint64_t v39 = (unint64_t)v94 | (unint64_t)v95;
      goto LABEL_91;
    case 0x36:
      int v85 = sub_10005591C(&v95, a2, a3, a4, a5, a6, a7, *(void *)(a8 + 8));
      int v86 = sub_10005591C(&v94, a2, a3, a4, a5, a6, v9, *(void *)(v8 + 16));
      if (v85) {
        BOOL v87 = v86 == 0;
      }
      else {
        BOOL v87 = 1;
      }
      if (v87) {
        return 0LL;
      }
      unint64_t v39 = (unint64_t)v94 ^ (unint64_t)v95;
      goto LABEL_91;
    case 0x37:
      if (!a4) {
        return 0LL;
      }
      unint64_t v39 = *(unsigned int *)(a4 + 56);
      goto LABEL_91;
    default:
      sub_100061FB4( "Impossible case at %s:%d.  Undefined operator %d.",  a2,  a3,  a4,  a5,  a6,  (uint64_t)a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c");
  }

  while (1)
  {
    uint64_t v43 = *(void *)(v8 + 8);
    uint64_t v8 = *(void *)(v8 + 16);
    uint64_t v94 = 0LL;
    int v49 = v94;
    if (v42)
    {
      *(void *)(v42 + 8) = v94;
    }

    else
    {
      uint64_t v95 = v94;
      uint64_t v41 = (unsigned __int16 **)v94;
    }

    *int v49 = v42;
    unint64_t v42 = (unint64_t)v94;
    v94[1] = 0LL;
    uint64_t v96 = (unsigned __int16 *)v42;
    if (!v8)
    {
      unsigned int v50 = sub_10006F8C0((unsigned int *)qword_10008C738, (uint64_t)v41);
      *a1 = v50;
      sub_100051AE8(v50, (uint64_t *)&v95);
      uint64_t v9 = 1LL;
      uint64_t v41 = (unsigned __int16 **)v95;
      goto LABEL_94;
    }
  }

  uint64_t v9 = 0LL;
LABEL_94:
  if (v41)
  {
    do
    {
      uint64_t v88 = *v41;
      uint64_t v89 = (unsigned __int16 **)v41[1];
      if (v89)
      {
        *uint64_t v89 = v88;
        uint64_t v88 = *v41;
      }

      else
      {
        uint64_t v96 = *v41;
      }

      if (v88) {
        *((void *)v88 + 1) = v41[1];
      }
      else {
        uint64_t v95 = v41[1];
      }
      *uint64_t v41 = (unsigned __int16 *)-1LL;
      v41[1] = (unsigned __int16 *)-1LL;
      uint64_t v90 = v41[9];
      if (v90)
      {
        sub_10005CE20( v90,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  2538LL,  v44,  v45,  v46,  v47,  v48);
        v41[8] = 0LL;
        v41[9] = 0LL;
      }

      sub_10006E3A4(v41);
      uint64_t v41 = (unsigned __int16 **)v95;
    }

    while (v95);
  }

  return v9;
}

BOOL sub_100056150(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 4);
  return (v1 - 4) < 0x36 && ((0x3000C007E9C78FuLL >> (v1 - 4)) & 1) != 0 || v1 == 39;
}

uint64_t sub_10005618C( void *a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8, uint64_t a9, unsigned int a10)
{
  uint64_t v17 = (uint64_t)a1;
  BOOL v18 = 0LL;
  uint64_t v19 = a10;
  switch(*(_DWORD *)(a8 + 4))
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 8:
    case 9:
    case 0xA:
    case 0x16:
    case 0x18:
    case 0x21:
    case 0x26:
    case 0x28:
    case 0x3A:
    case 0x3B:
      sub_10006221C( "Boolean opcode in evaluate_data_expression: %d",  (uint64_t)a2,  a3,  a10,  a5,  a6,  (uint64_t)a7,  a8,  *(_DWORD *)(a8 + 4));
      return 0LL;
    case 4:
      char v199 = 0LL;
      char __src = 0LL;
      size_t __n = 0LL;
      int v191 = sub_10005618C( &v199,  a2,  a3,  a4,  a5,  a6,  a7,  *(void *)(a8 + 8),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  1452);
      BOOL v20 = sub_10005591C(&v195, (uint64_t)a2, a3, a4, a5, a6, a7, *(void *)(a8 + 16));
      BOOL v21 = sub_10005591C(&v194, (uint64_t)a2, a3, a4, a5, a6, a7, *(void *)(a8 + 24));
      if (v191) {
        BOOL v27 = !v20;
      }
      else {
        BOOL v27 = 1;
      }
      BOOL v28 = v27 || !v21;
      BOOL v18 = !v28;
      if (v28)
      {
        if (!v191) {
          return v18;
        }
      }

      else
      {
        unint64_t v29 = v195;
        if (v195 < __n)
        {
          sub_100034E60(v17, (uint64_t)&v199, a9, a10, v23, v24, v25, v26);
          unint64_t v30 = (*(_DWORD *)(v17 + 16) - v29);
          *(_DWORD *)(v17 + 16) = v30;
          if (v194 < v30) {
            *(void *)(v17 + 16) = v194;
          }
          *(void *)(v17 + 8) += v29;
        }
      }

      unint64_t v39 = &v199;
      uint64_t v40 = 1490LL;
      goto LABEL_225;
    case 5:
      char v199 = 0LL;
      char __src = 0LL;
      size_t __n = 0LL;
      int v31 = sub_10005618C( &v199,  a2,  a3,  a4,  a5,  a6,  a7,  *(void *)(a8 + 8),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  1501);
      BOOL v32 = sub_10005591C(&v194, (uint64_t)a2, a3, a4, a5, a6, a7, *(void *)(a8 + 16));
      if (v31) {
        BOOL v37 = !v32;
      }
      else {
        BOOL v37 = 1;
      }
      BOOL v18 = !v37;
      if (v37) {
        return v18;
      }
      sub_100034E60(v17, (uint64_t)&v199, a9, a10, v33, v34, v35, v36);
      int v38 = v194;
      if (__n > v194)
      {
        *(void *)(v17 + 8) += __n - v194;
        *(_DWORD *)(v17 + 16) = v38;
      }

      unint64_t v39 = &v199;
      uint64_t v40 = 1520LL;
      goto LABEL_225;
    case 6:
      char v199 = 0LL;
      char __src = 0LL;
      size_t __n = 0LL;
      int v41 = sub_10005618C( &v199,  a2,  a3,  a4,  a5,  a6,  a7,  *(void *)(a8 + 8),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  1787);
      char v197 = 0LL;
      uint64_t v198 = 0LL;
      char v196 = 0LL;
      int v42 = sub_10005618C( &v196,  a2,  a3,  a4,  a5,  a6,  a7,  *(void *)(a8 + 16),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  1792);
      int v43 = v42;
      int v44 = v41;
      if (v41) {
        BOOL v45 = v42 == 0;
      }
      else {
        BOOL v45 = 1;
      }
      BOOL v18 = !v45;
      if (v45)
      {
        if (!v44) {
          goto LABEL_135;
        }
      }

      else
      {
        int v46 = HIDWORD(v198);
        int v47 = v198 + __n;
        *(_DWORD *)(v17 + 16) = v198 + __n;
        if (!sub_1000345C4((void *)v17, v46 + v47, a9, a10))
        {
          sub_10006221C("data: concat: no memory", v48, v49, v50, v51, v52, v53, v54, v184);
          *(_DWORD *)(v17 + 16) = 0;
          sub_100034EA8( &v199,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  1801LL,  v145,  v146,  v147,  v148,  v149);
          sub_100034EA8( &v196,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  1802LL,  v150,  v151,  v152,  v153,  v154);
          return 0LL;
        }

        uint64_t v55 = (void *)(*(void *)v17 + 4LL);
        *(void *)(v17 + 8) = v55;
        memcpy(v55, __src, __n);
        memcpy((void *)(*(void *)v17 + __n + 4LL), v197, (HIDWORD(v198) + v198));
      }

      sub_100034EA8( &v199,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  1812LL,  v22,  v23,  v24,  v25,  v26);
LABEL_135:
      if (!v43) {
        return v18;
      }
      unint64_t v39 = &v196;
      uint64_t v40 = 1814LL;
      goto LABEL_225;
    case 7:
      return sub_1000578F4((uint64_t)a1, *(void *)(a8 + 8), a3, a10, a5, a6, (uint64_t)a7, a8);
    case 0xB:
      if (!a5) {
        return 0LL;
      }
      return sub_100043AE8( (uint64_t)a1,  *(void *)(*(void *)(a8 + 8) + 16LL),  (uint64_t)a2,  a3,  a4,  a5,  a6,  a5,  (uint64_t)a7,  *(_DWORD *)(*(void *)(a8 + 8) + 24LL),  a9,  a10);
    case 0xC:
      if (a4)
      {
        a1[1] = 0LL;
        a1[2] = 0LL;
        *a1 = 0LL;
        uint64_t v57 = *(void *)(a4 + 8);
        a1[1] = v57 + 49;
        *((_DWORD *)a1 + 4) = *(unsigned __int8 *)(v57 + 48);
        return 1LL;
      }

      if (!a2 || !*(void *)a2)
      {
        uint64_t v116 = "data: hardware: raw packet not available";
        goto LABEL_152;
      }

      unsigned int v142 = *(unsigned __int8 *)(*(void *)a2 + 2LL);
      if (v142 >= 0x11)
      {
        sub_10006221C("data: hardware: invalid hlen (%d)\n", (uint64_t)a2, a3, a10, a5, a6, (uint64_t)a7, a8, v142);
        return 0LL;
      }

      *((_DWORD *)a1 + 4) = v142 + 1;
      if (sub_1000345C4(a1, v142 + 1, a9, a10))
      {
        uint64_t v175 = *(void *)v17;
        *(void *)(v17 + 8) = *(void *)v17 + 4LL;
        *(_BYTE *)(v175 + 4) = *(_BYTE *)(*(void *)a2 + 1LL);
        int v62 = (void *)(*(void *)v17 + 5LL);
        int v63 = (const void *)(*(void *)a2 + 28LL);
        size_t v64 = *(unsigned __int8 *)(*(void *)a2 + 2LL);
        goto LABEL_76;
      }

      uint64_t v116 = "data: hardware: no memory for buffer.";
      goto LABEL_152;
    case 0xD:
      if (!a2 || !*(void *)a2)
      {
        uint64_t v116 = "data: packet: raw packet not available";
        goto LABEL_152;
      }

      BOOL v192 = sub_10005591C(&v195, (uint64_t)a2, a3, a4, a5, a6, a7, *(void *)(a8 + 8));
      BOOL v58 = sub_10005591C(&v194, (uint64_t)a2, a3, a4, a5, a6, a7, *(void *)(a8 + 16));
      BOOL v18 = 0LL;
      if (!v192 || !v58) {
        return v18;
      }
      unint64_t v59 = v195;
      unint64_t v60 = a2[3];
      if (v195 >= v60) {
        return 0LL;
      }
      if (v194 + v195 <= v60) {
        int v61 = v194;
      }
      else {
        int v61 = v60 - v195;
      }
      *(_DWORD *)(v17 + 16) = v61;
      if (sub_1000345C4((void *)v17, v61, a9, a10))
      {
        int v62 = (void *)(*(void *)v17 + 4LL);
        *(void *)(v17 + 8) = v62;
        int v63 = (const void *)(*(void *)a2 + v59);
        size_t v64 = *(unsigned int *)(v17 + 16);
        goto LABEL_76;
      }

      uint64_t v116 = "data: packet: no buffer memory.";
      goto LABEL_152;
    case 0xE:
      uint64_t v65 = a8 + 8;
      uint64_t v66 = a9;
      goto LABEL_54;
    case 0xF:
    case 0x10:
    case 0x11:
    case 0x15:
    case 0x1F:
    case 0x20:
    case 0x2F:
    case 0x30:
    case 0x31:
    case 0x32:
    case 0x33:
    case 0x34:
    case 0x35:
    case 0x36:
    case 0x37:
      sub_10006221C( "Numeric opcode in evaluate_data_expression: %d",  (uint64_t)a2,  a3,  a10,  a5,  a6,  (uint64_t)a7,  a8,  *(_DWORD *)(a8 + 4));
      return 0LL;
    case 0x12:
      BOOL v18 = sub_10005591C(&v194, (uint64_t)a2, a3, a4, a5, a6, a7, *(void *)(a8 + 8));
      if (!v18) {
        goto LABEL_159;
      }
      *(_DWORD *)(v17 + 16) = 1;
      if (sub_1000345C4((void *)v17, 1, a9, a10))
      {
        uint64_t v74 = *(void *)v17;
        *(void *)(v17 + 8) = *(void *)v17 + 4LL;
        *(_BYTE *)(v74 + 4) = v194;
        return v18;
      }

      uint64_t v144 = "data: encode_int8: no memory";
      goto LABEL_158;
    case 0x13:
      BOOL v18 = sub_10005591C(&v194, (uint64_t)a2, a3, a4, a5, a6, a7, *(void *)(a8 + 8));
      if (!v18) {
        goto LABEL_159;
      }
      *(_DWORD *)(v17 + 16) = 2;
      if (sub_1000345C4((void *)v17, 2, a9, a10))
      {
        int v75 = (_WORD *)(*(void *)v17 + 4LL);
        *(void *)(v17 + 8) = v75;
        sub_100060B78(v75, v194);
        return v18;
      }

      uint64_t v144 = "data: encode_int16: no memory";
      goto LABEL_158;
    case 0x14:
      BOOL v18 = sub_10005591C(&v194, (uint64_t)a2, a3, a4, a5, a6, a7, *(void *)(a8 + 8));
      if (!v18) {
        goto LABEL_159;
      }
      *(_DWORD *)(v17 + 16) = 4;
      if (sub_1000345C4((void *)v17, 4, a9, a10))
      {
        int v76 = (_DWORD *)(*(void *)v17 + 4LL);
        *(void *)(v17 + 8) = v76;
        sub_100060B6C(v76, v194);
      }

      else
      {
        uint64_t v144 = "data: encode_int32: no memory";
LABEL_158:
        sub_10006221C(v144, v67, v68, v69, v70, v71, v72, v73, v183);
        BOOL v18 = 0LL;
LABEL_159:
        *(_DWORD *)(v17 + 16) = 0;
      }

      return v18;
    case 0x17:
      if (!a6) {
        return 0LL;
      }
      return sub_100042CCC((uint64_t)a1, (uint64_t)a2, a3, a4, a5, a6, (uint64_t)a7, a8 + 8);
    case 0x19:
      BOOL v77 = sub_10005591C(&v194, (uint64_t)a2, a3, a4, a5, a6, a7, *(void *)(a8 + 8));
      char __src = 0LL;
      size_t __n = 0LL;
      char v199 = 0LL;
      uint64_t v78 = a2;
      BOOL v79 = v77;
      int v80 = sub_10005618C( &v199,  v78,  a3,  a4,  a5,  a6,  a7,  *(void *)(a8 + 16),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  2056);
      if (!v79 || v80 == 0)
      {
        BOOL v18 = 0LL;
        if (!v79) {
          return v18;
        }
        goto LABEL_140;
      }

      size_t v141 = v194;
      if (__n % v194)
      {
        sub_1000622D4( "reverse: %s %d %s %ld!",  __n,  v81,  v22,  v23,  v24,  v25,  v26,  (char)"length of buffer");
LABEL_139:
        BOOL v18 = 0LL;
LABEL_140:
        unint64_t v39 = &v199;
        uint64_t v40 = 2099LL;
        goto LABEL_225;
      }

      if (!sub_1000345C4((void *)v17, __n, a9, a10))
      {
        sub_10006221C("data: reverse: no memory", v155, v156, v22, v23, v24, v25, v26, v185);
        goto LABEL_139;
      }

      *(void *)(v17 + 8) = *(void *)v17 + 4LL;
      int v157 = __n;
      *(void *)(v17 + 16) = __n;
      if (!v157)
      {
        BOOL v18 = 1LL;
        goto LABEL_140;
      }

      int v158 = 0;
      unsigned int v159 = 0;
      do
      {
        memcpy((void *)(*(void *)v17 + (int)v159 + 4LL), (char *)__src + (v157 + v158) - v141, v141);
        v159 += v141;
        int v157 = __n;
        v158 -= v141;
      }

      while (v159 < __n);
      BOOL v18 = 1LL;
      if (v79) {
        goto LABEL_140;
      }
      return v18;
    case 0x1A:
      if (!a3)
      {
        sub_10006238C( "data: leased-address configuration directive: there is no lease associated with this client.",  (uint64_t)a2,  0LL,  a10,  a5,  a6,  (uint64_t)a7,  a8,  v183);
        return 0LL;
      }

      int v83 = *(_DWORD *)(a3 + 56);
      *((_DWORD *)a1 + 4) = v83;
      if (!sub_1000345C4(a1, v83, a9, a10))
      {
        uint64_t v116 = "data: leased-address: no memory.";
        goto LABEL_152;
      }

      int v62 = (void *)(*(void *)v17 + 4LL);
      *(void *)(v17 + 8) = v62;
      int v63 = (const void *)(a3 + 60);
      size_t v64 = *(unsigned int *)(a3 + 56);
LABEL_76:
      memcpy(v62, v63, v64);
      *(_DWORD *)(v17 + 2__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = 0;
      return 1LL;
    case 0x1B:
      BOOL v193 = sub_10005591C(&v195, (uint64_t)a2, a3, a4, a5, a6, a7, *(void *)(a8 + 8));
      BOOL v189 = sub_10005591C(&v194, (uint64_t)a2, a3, a4, a5, a6, a7, *(void *)(a8 + 16));
      char __src = 0LL;
      size_t __n = 0LL;
      char v199 = 0LL;
      int v190 = sub_10005618C( &v199,  a2,  a3,  a4,  a5,  a6,  a7,  *(void *)(a8 + 24),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  1933);
      char v197 = 0LL;
      uint64_t v198 = 0LL;
      char v196 = 0LL;
      int v84 = sub_10005618C( &v196,  a2,  a3,  a4,  a5,  a6,  a7,  *(void *)(a8 + 32),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  1940);
      int v87 = v84;
      BOOL v18 = 0LL;
      if (v193 && v189)
      {
        int v88 = v190;
        if (v190 && v84)
        {
          if (v194 > 0x20 || ((1LL << v194) & 0x100010100LL) == 0)
          {
            sub_1000622D4("binary_to_ascii: %s %ld!", v85, v86, v22, v23, v24, v25, v26, (char)"invalid width");
            goto LABEL_203;
          }

          unint64_t v89 = v194 >> 3;
          if (v198 % (v194 >> 3))
          {
            sub_1000622D4("binary-to-ascii: %s %d %s %ld!", v85, v86, v22, v23, v24, v25, v26, (char)"length of buffer");
LABEL_203:
            BOOL v18 = 0LL;
            goto LABEL_222;
          }

          if ((_DWORD)v198)
          {
            unsigned int v160 = 0;
            int v161 = 0;
            unint64_t v162 = v195;
            uint64_t v163 = a10;
            while (v89 == 1)
            {
              switch(v162)
              {
                case 0x10uLL:
                  uint64_t v164 = v160;
                  int v171 = v161 + 2;
                  goto LABEL_196;
                case 0xAuLL:
                  uint64_t v164 = v160;
                  unsigned int v172 = *((unsigned __int8 *)v197 + v160);
                  int v166 = v161 + 3;
                  if (v172 <= 0x63) {
                    int v166 = v161 + 2;
                  }
                  BOOL v167 = v172 > 9;
                  break;
                case 8uLL:
                  uint64_t v164 = v160;
                  unsigned int v165 = *((unsigned __int8 *)v197 + v160);
                  int v166 = v161 + 3;
                  if (v165 <= 0x3F) {
                    int v166 = v161 + 2;
                  }
                  BOOL v167 = v165 > 7;
                  break;
                default:
                  uint64_t v164 = v160;
                  uint64_t v168 = (unsigned int *)((char *)v197 + v160);
                  unsigned int v169 = v162;
                  int v170 = 1;
                  goto LABEL_195;
              }

              if (v167) {
                int v171 = v166;
              }
              else {
                int v171 = v161 + 1;
              }
LABEL_196:
              else {
                int v174 = __n;
              }
              int v161 = v174 + v171;
              v160 += v89;
            }

            uint64_t v164 = v160;
            uint64_t v168 = (unsigned int *)((char *)v197 + v160);
            unsigned int v169 = v162;
            int v170 = v89;
LABEL_195:
            int v173 = sub_100060BA8(v168, v169, v170);
            uint64_t v163 = a10;
            int v171 = v173 + v161;
            goto LABEL_196;
          }

          int v161 = 0;
          uint64_t v163 = a10;
LABEL_209:
          if (sub_1000345C4((void *)v17, v161 + 1, a9, v163))
          {
            uint64_t v178 = *(void *)v17;
            *(void *)(v17 + 8) = *(void *)v17 + 4LL;
            *(_DWORD *)(v17 + 16) = v161;
            *(_DWORD *)(v17 + 2__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = 1;
            if ((_DWORD)v198)
            {
              unsigned int v179 = 0;
              unsigned int v180 = 0;
              unsigned int v181 = v195;
              do
              {
                v180 += sub_100060C18(*(void *)v17 + v180 + 4LL, (unsigned int *)((char *)v197 + v179), v181, v89);
                unsigned int v182 = v198;
                if (v89 + v179 != v198)
                {
                  memcpy((void *)(*(void *)v17 + v180 + 4LL), __src, __n);
                  v180 += __n;
                  unsigned int v182 = v198;
                }

                v179 += v89;
              }

              while (v179 < v182);
              uint64_t v178 = *(void *)v17;
            }

            else
            {
              unsigned int v180 = 0;
            }

            *(_BYTE *)(v178 + v180 + 4) = 0;
            BOOL v18 = 1LL;
          }

          else
          {
            sub_10006221C("data: binary-to-ascii: no memory", v176, v177, v22, v23, v24, v25, v26, v186);
            BOOL v18 = 0LL;
          }
        }
      }

      else
      {
        int v88 = v190;
      }

      if (!v88) {
        goto LABEL_223;
      }
LABEL_222:
      sub_100034EA8( &v199,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  2037LL,  v22,  v23,  v24,  v25,  v26);
LABEL_223:
      if (v87)
      {
        unint64_t v39 = &v196;
        uint64_t v40 = 2039LL;
LABEL_225:
        sub_100034EA8( v39,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  v40,  v22,  v23,  v24,  v25,  v26);
      }

      return v18;
    case 0x1C:
      if (!a6) {
        return 0LL;
      }
      return sub_100043AE8( (uint64_t)a1,  *(void *)(*(void *)(a8 + 8) + 16LL),  (uint64_t)a2,  a3,  a4,  a5,  a6,  a6,  (uint64_t)a7,  *(_DWORD *)(*(void *)(a8 + 8) + 24LL),  a9,  a10);
    case 0x1D:
      if (a3 && (uint64_t v90 = *(void *)(a3 + 120)) != 0)
      {
        int v91 = strlen(*(const char **)(v90 + 48));
        *(_DWORD *)(v17 + 16) = v91;
        if (sub_1000345C4((void *)v17, v91 + 1, a9, a10))
        {
          uint64_t v92 = (char *)(*(void *)v17 + 4LL);
          *(void *)(v17 + 8) = v92;
          strcpy(v92, *(const char **)(*(void *)(a3 + 120) + 48LL));
          goto LABEL_112;
        }

        uint64_t v116 = "data: host-decl-name: no memory.";
      }

      else
      {
        uint64_t v116 = "data: host_decl_name: not available";
      }

      goto LABEL_152;
    case 0x1E:
      if (!sub_10005618C( a1,  a2,  a3,  a4,  a5,  a6,  a7,  *(void *)(a8 + 8),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  2133))
      {
        uint64_t v143 = *(void *)(a8 + 16);
        if (!v143
          || !sub_10005618C( v17,  a2,  a3,  a4,  a5,  a6,  a7,  v143,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  2146))
        {
          return 0LL;
        }
      }

      return 1LL;
    case 0x22:
    case 0x23:
    case 0x24:
    case 0x25:
      sub_10006221C( "dns update opcode in evaluate_data_expression: %d",  (uint64_t)a2,  a3,  a10,  a5,  a6,  (uint64_t)a7,  a8,  *(_DWORD *)(a8 + 4));
      return 0LL;
    case 0x27:
      return v18;
    case 0x29:
      if (!a7) {
        return 0LL;
      }
      if (!*a7) {
        return 0LL;
      }
      int v93 = sub_100055100(*a7, *(char **)(a8 + 8));
      if (!v93) {
        return 0LL;
      }
      uint64_t v97 = v93[2];
      if (!v97) {
        return 0LL;
      }
      int v98 = *((_DWORD *)v97 + 1);
      if (v98 != 1)
      {
        sub_10006221C("binding type %d in %s.", v94, v95, v96, a5, a6, (uint64_t)a7, a8, v98);
        return 0LL;
      }

      uint64_t v65 = (uint64_t)(v97 + 1);
      a1 = (void *)v17;
      uint64_t v66 = a9;
      uint64_t v19 = a10;
LABEL_54:
      sub_100034E60((uint64_t)a1, v65, v66, v19, a5, a6, (uint64_t)a7, a8);
      return 1LL;
    case 0x2A:
      if (!a2) {
        return 0LL;
      }
      uint64_t v99 = *(void *)a2;
      uint64_t v100 = (_BYTE *)(*(void *)a2 + 108LL);
      if (!*v100) {
        return 0LL;
      }
      uint64_t v101 = memchr((const void *)(*(void *)a2 + 108LL), 0, 0x80uLL);
      int v102 = v99 + 236;
      if (v101) {
        int v102 = (int)v101;
      }
      int v103 = v102 - (_DWORD)v100;
      *(_DWORD *)(v17 + 16) = v103;
      if (sub_1000345C4((void *)v17, v103 + 1, a9, a10))
      {
        uint64_t v104 = (void *)(*(void *)v17 + 4LL);
        *(void *)(v17 + 8) = v104;
        uint64_t v105 = (const void *)(*(void *)a2 + 108LL);
        goto LABEL_111;
      }

      uint64_t v116 = "data: filename: no memory.";
      goto LABEL_152;
    case 0x2B:
      if (!a2) {
        return 0LL;
      }
      uint64_t v106 = *(void *)a2;
      uint64_t v107 = (_BYTE *)(*(void *)a2 + 44LL);
      if (!*v107) {
        return 0LL;
      }
      uint64_t v108 = memchr((const void *)(*(void *)a2 + 44LL), 0, 0x40uLL);
      int v109 = v106 + 108;
      if (v108) {
        int v109 = (int)v108;
      }
      int v110 = v109 - (_DWORD)v107;
      *(_DWORD *)(v17 + 16) = v110;
      if (sub_1000345C4((void *)v17, v110 + 1, a9, a10))
      {
        uint64_t v104 = (void *)(*(void *)v17 + 4LL);
        *(void *)(v17 + 8) = v104;
        uint64_t v105 = (const void *)(*(void *)a2 + 44LL);
LABEL_111:
        memcpy(v104, v105, *(unsigned int *)(v17 + 16));
        *(_BYTE *)(*(void *)v17 + *(unsigned int *)(v17 + 16) + 4LL) = 0;
LABEL_112:
        BOOL v18 = 1LL;
        *(_DWORD *)(v17 + 2__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = 1;
      }

      else
      {
        uint64_t v116 = "data: sname: no memory.";
LABEL_152:
        sub_10006221C(v116, (uint64_t)a2, a3, v19, a5, a6, (uint64_t)a7, a8, v183);
        return 0LL;
      }

      return v18;
    case 0x2D:
      char v199 = 0LL;
      if (sub_100054B74( &v199,  (int *)a2,  a3,  a4,  a5,  a6,  a7,  a8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  0x8ABu))
      {
        if (v199[1] == 1) {
          sub_100034E60(v17, (uint64_t)(v199 + 2), a9, a10, a5, a6, (uint64_t)a7, a8);
        }
        else {
          sub_10006221C( "%s() returned type %d in %s.",  (uint64_t)a2,  a3,  v19,  a5,  a6,  (uint64_t)a7,  a8,  *(void *)(a8 + 8));
        }
        sub_1000577E8( (uint64_t *)&v199,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  2229LL,  v111,  v112,  v113,  v114,  v115);
      }

      goto LABEL_151;
    case 0x2E:
      uint64_t v116 = "function definition in evaluate_data_expression";
      goto LABEL_152;
    case 0x38:
      char v199 = 0LL;
      char __src = 0LL;
      size_t __n = 0LL;
      if (!sub_10005618C( &v199,  a2,  a3,  a4,  a5,  a6,  a7,  *(void *)(a8 + 8),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  1575)) {
        return 0LL;
      }
      int v117 = __n;
      int v118 = HIDWORD(__n);
      *(_DWORD *)(v17 + 16) = __n;
      if (sub_1000345C4((void *)v17, v118 + v117, a9, a10))
      {
        uint64_t v126 = (void *)(*(void *)v17 + 4LL);
        *(void *)(v17 + 8) = v126;
        memcpy(v126, __src, (HIDWORD(__n) + __n));
        *(_DWORD *)(v17 + 2__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = HIDWORD(__n);
        if (*(_DWORD *)(v17 + 16))
        {
          unint64_t v127 = 0LL;
          uint64_t v128 = *(void *)(v17 + 8);
          do
          {
            *(_BYTE *)(v128 + v127) = __toupper(*(unsigned __int8 *)(v128 + v127));
            ++v127;
          }

          while (v127 < *(unsigned int *)(v17 + 16));
        }

        BOOL v18 = 1LL;
      }

      else
      {
        sub_10006221C("data: lcase: no buffer memory.", v119, v120, v121, v122, v123, v124, v125, v187);
        BOOL v18 = 0LL;
      }

      unint64_t v39 = &v199;
      uint64_t v40 = 1602LL;
      goto LABEL_225;
    case 0x39:
      char v199 = 0LL;
      char __src = 0LL;
      size_t __n = 0LL;
      if (!sub_10005618C( &v199,  a2,  a3,  a4,  a5,  a6,  a7,  *(void *)(a8 + 8),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  1539)) {
        return 0LL;
      }
      int v129 = __n;
      int v130 = HIDWORD(__n);
      *(_DWORD *)(v17 + 16) = __n;
      if (sub_1000345C4( (void *)v17,  v130 + v129,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  1545LL))
      {
        uint64_t v138 = (void *)(*(void *)v17 + 4LL);
        *(void *)(v17 + 8) = v138;
        memcpy(v138, __src, (HIDWORD(__n) + __n));
        *(_DWORD *)(v17 + 2__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = HIDWORD(__n);
        if (*(_DWORD *)(v17 + 16))
        {
          unint64_t v139 = 0LL;
          uint64_t v140 = *(void *)(v17 + 8);
          do
          {
            *(_BYTE *)(v140 + v139) = __tolower(*(unsigned __int8 *)(v140 + v139));
            ++v139;
          }

          while (v139 < *(unsigned int *)(v17 + 16));
        }

        BOOL v18 = 1LL;
      }

      else
      {
        sub_10006221C("data: lcase: no buffer memory.", v131, v132, v133, v134, v135, v136, v137, v188);
        BOOL v18 = 0LL;
      }

      unint64_t v39 = &v199;
      uint64_t v40 = 1566LL;
      goto LABEL_225;
    default:
LABEL_151:
      int v183 = *(_DWORD *)(a8 + 4);
      uint64_t v116 = "Bogus opcode in evaluate_data_expression: %d";
      goto LABEL_152;
  }

BOOL sub_1000573AC(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 4) - 34) < 4;
}

uint64_t sub_1000573C0( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v58 = 0LL;
  if (a1 && !*a1)
  {
    uint64_t v17 = "%s: dns values for functions not supported.";
    int v18 = 1;
    switch(*(_DWORD *)(a8 + 4))
    {
      case 0:
      case 4:
      case 5:
      case 6:
      case 7:
      case 0xB:
      case 0xC:
      case 0xD:
      case 0xE:
      case 0x12:
      case 0x13:
      case 0x14:
      case 0x17:
      case 0x19:
      case 0x1A:
      case 0x1B:
      case 0x1C:
      case 0x1D:
      case 0x1E:
      case 0x27:
      case 0x2A:
      case 0x2B:
      case 0x38:
      case 0x39:
        sub_10006221C("Data opcode in evaluate_dns_expression: %d", a2, a3, a4, a5, a6, a7, a8, *(_DWORD *)(a8 + 4));
        return 0LL;
      case 1:
      case 2:
      case 3:
      case 8:
      case 9:
      case 0xA:
      case 0x16:
      case 0x18:
      case 0x21:
      case 0x26:
      case 0x28:
      case 0x3A:
      case 0x3B:
        sub_10006221C("Boolean opcode in evaluate_dns_expression: %d", a2, a3, a4, a5, a6, a7, a8, *(_DWORD *)(a8 + 4));
        return 0LL;
      case 0xF:
      case 0x10:
      case 0x11:
      case 0x15:
      case 0x1F:
      case 0x20:
      case 0x2F:
      case 0x30:
      case 0x31:
      case 0x32:
      case 0x33:
      case 0x34:
      case 0x35:
      case 0x36:
      case 0x37:
        sub_10006221C("Numeric opcode in evaluate_dns_expression: %d", a2, a3, a4, a5, a6, a7, a8, *(_DWORD *)(a8 + 4));
        return 0LL;
      case 0x22:
        int v18 = sub_10005591C(&v58, a2, a3, a4, a5, a6, a7, *(void *)(a8 + 32));
        goto LABEL_12;
      case 0x23:
      case 0x25:
        goto LABEL_12;
      case 0x24:
        int v18 = 1;
        uint64_t v58 = 1LL;
LABEL_12:
        uint64_t v55 = 0LL;
        char __src = 0LL;
        size_t __n = 0LL;
        uint64_t result = sub_10005618C( &v55,  a2,  a3,  a4,  a5,  a6,  a7,  *(void *)(a8 + 16),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  778);
        if (!(_DWORD)result) {
          return result;
        }
        uint64_t v19 = (char *)sub_10005CDE4((__n + 1));
        if (!v19)
        {
          sub_100034EA8( &v55,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  788LL,  v20,  v21,  v22,  v23,  v24);
          return 0LL;
        }

        uint64_t v25 = v19;
        memcpy(v19, __src, __n);
        v25[__n] = 0;
        uint64_t v53 = 0LL;
        size_t __size = 0LL;
        uint64_t v52 = 0LL;
        int v26 = sub_10005618C( &v52,  a2,  a3,  a4,  a5,  a6,  a7,  *(void *)(a8 + 24),  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  796);
        int v32 = v26;
        if (!v18) {
          goto LABEL_39;
        }
        int v33 = *(_DWORD *)(a8 + 4);
        if (!v26 && v33 == 34) {
          goto LABEL_38;
        }
        if ((v33 & 0xFFFFFFFE) == 0x22) {
          int v34 = 2;
        }
        else {
          int v34 = 1;
        }
        uint64_t v35 = sub_10006E324(v34, v25, *(_DWORD *)(a8 + 8), *(_DWORD *)(a8 + 12), v58);
        *a1 = (uint64_t)v35;
        if (!v35) {
          goto LABEL_36;
        }
        size_t v36 = __size;
        if ((_DWORD)__size)
        {
          if ((_DWORD)__size == 4)
          {
            *(void *)(*a1 + 72) = sub_10005CDE4(0x10uLL);
            BOOL v37 = (void *)*a1;
            uint64_t v38 = *(void *)(*a1 + 72);
            if (v38)
            {
              v37[8] = v38;
              sprintf( *(char **)(*a1 + 72),  "%u.%u.%u.%u",  *(unsigned __int8 *)v53,  *((unsigned __int8 *)v53 + 1),  *((unsigned __int8 *)v53 + 2),  *((unsigned __int8 *)v53 + 3));
              *(_DWORD *)(*a1 + 8__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = strlen(*(const char **)(*a1 + 64));
              goto LABEL_33;
            }

LABEL_35:
            sub_10006E3A4(v37);
            *a1 = 0LL;
LABEL_36:
            if (v32)
            {
              sub_100034EA8( &v52,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  813LL,  v27,  v28,  v29,  v30,  v31);
LABEL_38:
              int v32 = 0;
            }

LABEL_39:
            sub_100034EA8( &v55,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  883LL,  v27,  v28,  v29,  v30,  v31);
            sub_10005CE20( v25,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  884LL,  v42,  v43,  v44,  v45,  v46);
            if (v32)
            {
              sub_100034EA8( &v52,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  887LL,  v47,  v48,  v49,  v50,  v51);
              if (!v18) {
                return 0LL;
              }
            }

            else if (!v18 || *(_DWORD *)(a8 + 4) == 34)
            {
              return 0LL;
            }

            return *a1 != 0;
          }

          *((_DWORD *)v35 + 2__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = __size;
          *(void *)(*a1 + 72) = sub_10005CDE4(v36);
          BOOL v37 = (void *)*a1;
          uint64_t v39 = *(void *)(*a1 + 72);
          if (!v39) {
            goto LABEL_35;
          }
          v37[8] = v39;
          memcpy(*(void **)(*a1 + 72), v53, __size);
        }

        else
        {
          v35[8] = 0LL;
          *(_DWORD *)(*a1 + 8__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = 0;
        }

                      uint64_t v35 = dword_1000C5698++;
                      size_t v36 = off_100084900[v35];
                      if ((_DWORD)v35 == 13)
                      {
                        dword_1000C5698 = 0;
                        qword_1000C56A0 = v34 + ((unint64_t)(v59.tv_sec - v34) >> 1);
                        int v26 = sub_10005A1A4(*((void *)v10 + 7));
                        *((void *)v10 + 7) = v26;
                      }

                      else
                      {
                        int v26 = *((void *)v10 + 7);
                      }

                      if (!v26)
                      {
                        int v26 = sub_10005A68C(&byte_1000728D2, 157, 0, 0, (uint64_t)&v59, 16LL);
                        *((void *)v10 + 7) = v26;
                        if (!v26) {
                          goto LABEL_57;
                        }
                      }

                      if (access(v36, 4)
                        || stat(v36, &v60)
                        || strncmp(v36, "/proc/", 6uLL) && v60.st_mtimespec.tv_sec < (unint64_t)qword_1000C56A0)
                      {
                        goto LABEL_56;
                      }

                      if (sub_1000599B4(1, v26, (uint64_t)v61, 0LL, 0LL, 0LL))
                      {
                        BOOL v37 = sub_10005A1A4(v26);
                        LODWORD(v26) = 0;
                        *((void *)v10 + 7) = v37;
                        goto LABEL_57;
                      }

                      uint64_t v44 = fopen(v36, "r");
                      if (v44)
                      {
                        uint64_t v45 = v44;
                        uint64_t v46 = fread(__ptr, 1uLL, 0x400uLL, v44);
                        if ((int)v46 < 1)
                        {
                          fclose(v45);
                          uint64_t v48 = 0;
                        }

                        else
                        {
                          uint64_t v47 = v46;
                          uint64_t v48 = 0;
                          do
                          {
                            sub_1000599B4(2, v26, (uint64_t)v61, (uint64_t)__ptr, v47, 0LL);
                            v48 += v47;
                            uint64_t v47 = fread(__ptr, 1uLL, 0x400uLL, v45);
                          }

                          while ((int)v47 > 0);
                          fclose(v45);
                          if (v48 >= 64)
                          {
                            uint64_t v49 = v10[1];
                            uint64_t v50 = sub_1000599B4(4, v26, (uint64_t)v61, 0LL, 0LL, *((void *)v10 + 2) + v49);
                            uint64_t v16 = off_10008B000;
                            if (v50 >= 1) {
                              v10[1] = v50 + v49;
                            }
                            goto LABEL_80;
                          }
                        }

                        uint64_t v16 = off_10008B000;
LABEL_80:
                        uint64_t v51 = strlen(v36);
                        sub_10005CAEC(v10, v36, v51);
                        LODWORD(v26) = v48 + strlen(v36);
                        int v5 = (_DWORD *)&unk_1000C5000;
                        goto LABEL_57;
                      }

                      LODWORD(v26) = 0;
LABEL_69:
                      uint64_t v16 = off_10008B000;
LABEL_57:
                      if ((int)v26 >= 1) {
LABEL_58:
                      }
                        v14 += v26;
LABEL_59:
                      LODWORD(v8) = *v10;
                      uint64_t v15 = v10[1];
                      if (v15 >= *v10) {
                        goto LABEL_82;
                      }
                      break;
                    default:
                      HIDWORD(sub_1000622D4("Copyright 2004-2011 Internet Systems Consortium.", v9, v10, v11, v12, v13, v14, v15, v30) = v21;
                      LODWORD(sub_1000622D4("Copyright 2004-2011 Internet Systems Consortium.", v9, v10, v11, v12, v13, v14, v15, v30) = v21;
                      uint64_t v31 = v20 + v18;
                      dword_10008BB9C = v31 + 1;
                      int v32 = ((v30 >> 13) ^ __ROR4__(v21, 7)) + v31;
                      *((_DWORD *)v16 + 742) = v32;
                      int v33 = *((void *)v10 + 2);
                      v10[1] = v15 + 1;
                      *(_BYTE *)(v33 + v15) = v32;
                      LODWORD(v26) = 1;
                      goto LABEL_58;
                  }
                }
              }

              uint64_t v15 = 0;
LABEL_82:
              uint64_t v52 = &a1[v2];
              uint64_t v53 = (_BYTE *)*((void *)v10 + 2);
              memcpy(v52, v53, v8);
              uint64_t v54 = v15 - v8;
              v5[384] = v54;
              __memcpy_chk(&unk_1000C55B0, &v53[v8], v54, 80LL);
              for (uint64_t i = 6LL; i != 14; i += 2LL)
              {
                uint64_t v56 = *(void *)&v10[i];
                sub_10005A1A4(*(void *)v56);
                *(_OWORD *)uint64_t v56 = 0u;
                *(_OWORD *)(v56 + 16) = 0u;
                free((void *)v56);
                *(void *)&v10[i] = 0LL;
              }

              uint64_t v2 = (v8 + v2);
              if (v53)
              {
                *uint64_t v53 = 0;
                free(v53);
              }

              free(v10);
            }
          }
        }
      }
    }

    else
    {
      return 0xFFFFFFFFLL;
    }
  }

  return v2;
}

uint64_t sub_1000577E8( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *a1;
  *a1 = 0LL;
  int v9 = (*(_DWORD *)v8)--;
  if (v9 > 1) {
    return 1LL;
  }
  if (v9 == 1)
  {
    switch(*(_DWORD *)(v8 + 4))
    {
      case 0:
      case 2:
        break;
      case 1:
        if (*(void *)(v8 + 8)) {
          sub_100034EA8((_DWORD **)(v8 + 8), a2, a3, a4, a5, a6, a7, a8);
        }
        break;
      case 3:
        uint64_t v11 = *(void *)(v8 + 8);
        if (v11)
        {
          if (*(void *)(v11 + 64))
          {
            sub_10005CE20( *(void **)(v11 + 72),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  711LL,  a4,  a5,  a6,  a7,  a8);
            *(void *)(*(void *)(v8 + 8) + 64LL) = 0LL;
            *(void *)(*(void *)(v8 + 8) + 72LL) = 0LL;
            uint64_t v11 = *(void *)(v8 + 8);
          }

          sub_10006E3A4((void *)v11);
        }

        break;
      default:
        sub_10006221C("%s(%d): invalid binding type: %d", a2, a3, a4, a5, a6, a7, a8, a2);
        return 0LL;
    }

    sub_1000344CC(v8);
    return 1LL;
  }

  sub_10006221C("%s(%d): negative refcnt!", a2, a3, a4, a5, a6, a7, a8, a2);
  return 0LL;
}

uint64_t sub_1000578F4( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a1;
  if (qword_10008CE80 <= *(void *)(a2 + 8))
  {
    uint64_t v25 = a2 + 16;
    uint64_t v26 = 428LL;
LABEL_11:
    sub_100034E60(a1, v25, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c", v26, a5, a6, a7, a8);
    return 1LL;
  }

  uint64_t v10 = gethostbyname((const char *)(a2 + 40));
  if (v10)
  {
    int v18 = v10;
    LODWORD(v19) = -1;
    do
      uint64_t v19 = (v19 + 1);
    while (v10->h_addr_list[v19]);
    sub_100034EA8( (_DWORD **)(a2 + 16),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  474LL,  v13,  v14,  v15,  v16,  v17);
    int v20 = v18->h_length * v19;
    if (sub_1000345C4( (void *)(a2 + 16),  v20,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  478LL))
    {
      *(void *)(a2 + 24) = *(void *)(a2 + 16) + 4LL;
      *(_DWORD *)(a2 + 32) = v20;
      *(_DWORD *)(a2 + 36) = 0;
      if ((_DWORD)v19)
      {
        for (uint64_t i = 0LL; i != v19; ++i)
          memcpy( (void *)(*(void *)(a2 + 16) + (v18->h_length * i) + 4LL),  v18->h_addr_list[i],  v18->h_length);
      }

      *(void *)(a2 + 8) = qword_10008CE80 + 3600;
      a1 = v9;
      uint64_t v25 = a2 + 16;
      uint64_t v26 = 508LL;
      goto LABEL_11;
    }

    sub_10006221C("No memory for %s.", v21, v22, v23, a5, a6, a7, a8, a2 + 40);
  }

  else
  {
    *(void *)(a2 + 8) = qword_10008CE80 + 60;
    sub_100034EA8( (_DWORD **)(a2 + 16),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  460LL,  v13,  v14,  v15,  v16,  v17);
  }

  return 0LL;
}

uint64_t sub_100057AA4( void *a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8, uint64_t a9, unsigned int a10)
{
  if (*(void *)(a8 + 40))
  {
    sub_100034E60((uint64_t)a1, a8 + 32, a9, a10, a5, a6, (uint64_t)a7, a8);
    return 1LL;
  }

  else
  {
    uint64_t v11 = *(void *)(a8 + 16);
    if (v11) {
      return sub_10005618C(a1, a2, a3, a4, a5, a6, a7, v11, a9, a10);
    }
    else {
      return 0LL;
    }
  }

uint64_t sub_100057AF8( _DWORD *a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8, uint64_t a9, unsigned int a10)
{
  uint64_t v10 = 0LL;
  if (a5 && a8)
  {
    uint64_t v19 = 0LL;
    int v20 = 0LL;
    uint64_t v21 = 0LL;
    if (sub_100057AA4(&v19, a2, a3, a4, a5, a6, a7, a8, a9, a10))
    {
      if ((_DWORD)v21)
      {
        int v17 = *v20;
        if (v17 == 2) {
          uint64_t v10 = 0LL;
        }
        else {
          uint64_t v10 = *v20;
        }
        if (a1) {
          *a1 = v17 == 2;
        }
      }

      else
      {
        uint64_t v10 = 0LL;
      }

      sub_100034EA8( &v19,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  2933LL,  v12,  v13,  v14,  v15,  v16);
    }

    else
    {
      return 0LL;
    }
  }

  return v10;
}

uint64_t sub_100057B9C( _DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a8) {
    return 0LL;
  }
  uint64_t result = sub_10005525C(&v10);
  if ((_DWORD)result)
  {
    if (v10 == 2) {
      uint64_t result = 0LL;
    }
    else {
      uint64_t result = v10;
    }
    *a1 = v10 == 2;
  }

  return result;
}

uint64_t sub_100057BEC( void **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10 = (int *)*a1;
  if (!*a1)
  {
    sub_10006221C("%s(%d): null pointer", a2, a3, a4, a5, a6, a7, a8, a2);
    return 0LL;
  }

  int v11 = *v10;
  int v12 = *v10 - 1;
  *unsigned int v10 = v12;
  if (v11 <= 0)
  {
    sub_10006221C("%s(%d): negative refcnt!", a2, a3, a4, a5, a6, a7, a8, a2);
    return 0LL;
  }

  if (!v12)
  {
    uint64_t v14 = (void *)*((void *)v10 + 1);
    if (v14)
    {
      do
      {
        uint64_t v15 = (void *)*v14;
        sub_10005CE20(v14, a2, a3, a4, a5, a6, a7, a8);
        uint64_t v14 = v15;
      }

      while (v15);
    }

    if (*((void *)v10 + 2)) {
      sub_10003DC78(v10 + 4, a2, a3);
    }
    sub_10005CE20(v10, a2, a3, a4, a5, a6, a7, a8);
  }

  *a1 = 0LL;
  return 1LL;
}

BOOL sub_100057CC0(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 4);
  return (v1 - 4) < 0x22 && ((0x3C5A1F887uLL >> (v1 - 4)) & 1) != 0 || v1 == 32;
}

uint64_t sub_100057CF8(unsigned int a1, unsigned int a2)
{
  int v3 = sub_100057D28(a1);
  return v3 - sub_100057D28(a2);
}

uint64_t sub_100057D28(unsigned int a1)
{
  if (a1 <= 0x3B)
  {
    if (((1LL << a1) & 0xE000000000000LL) != 0) {
      return 1LL;
    }
    if (((1LL << a1) & 0xC00004000000000LL) != 0) {
      return 4LL;
    }
    if (((1LL << a1) & 0x1800000000000LL) != 0) {
      return 2LL;
    }
  }

  if (a1 - 8 < 2) {
    return 3LL;
  }
  if (a1 == 3) {
    return 4LL;
  }
  return 100LL;
}

uint64_t sub_100057DA8(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 4);
  int v2 = v1 - 2;
  else {
    return 4 * ((v1 - 38) > 0xFFFFFFFB);
  }
}

uint64_t sub_100057DEC(unsigned int a1)
{
  if (a1 <= 0x3B)
  {
    if (((1LL << a1) & 0xFF800000000000LL) != 0) {
      return 3LL;
    }
    if (((1LL << a1) & 0xC00004000000000LL) != 0) {
      return 2LL;
    }
    if (a1 == 9LL) {
      return 1LL;
    }
  }

  if (a1 == 8) {
    return 1LL;
  }
  if (a1 == 3) {
    return 2LL;
  }
  return 0LL;
}

uint64_t sub_100057E58( FILE *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  while (2)
  {
    uint64_t v8 = a4;
    uint64_t v9 = a3;
    uint64_t v10 = a2;
    int v11 = a1;
    if (!(_DWORD)a5)
    {
      unsigned int v12 = *(_DWORD *)(a2 + 4);
      BOOL v13 = v12 > 0x25;
      uint64_t v14 = (1LL << v12) & 0x3D5A1F8870LL;
      if (!v13 && v14 != 0)
      {
        sub_100051AA0(a1, a4);
        uint64_t v9 = v8;
      }
    }

    uint64_t v16 = "exists";
    int v17 = "option";
    int v18 = 8;
    uint64_t v19 = "~=";
    switch(*(_DWORD *)(v10 + 4))
    {
      case 0:
      case 0x27:
        int v20 = &byte_1000728D2;
        uint64_t v21 = "null";
        goto LABEL_84;
      case 2:
        uint64_t v22 = sub_10005179C(v11, v9, v8, &byte_1000728D2, &byte_1000728D2, "check");
        return sub_100051668( v11,  v22,  v8,  " ",  &byte_1000728D2,  v23,  v24,  v25,  "",  *(void *)(*(void *)(v10 + 8) + 8LL));
      case 3:
        uint64_t v19 = "=";
        goto LABEL_92;
      case 4:
        int v27 = sub_10005179C(v11, v9, v8, &byte_1000728D2, &byte_1000728D2, "substring");
        uint64_t v28 = sub_10005179C(v11, v27, v8, " ", &byte_1000728D2, "(");
        int v29 = sub_100057E58(v11, *(void *)(v10 + 8), v28, v28, 1LL);
        uint64_t v30 = sub_10005179C(v11, v29, v8, &byte_1000728D2, " ", ",");
        int v31 = sub_100057E58(v11, *(void *)(v10 + 16), v30, v8, 0LL);
        uint64_t v32 = sub_10005179C(v11, v31, v28, &byte_1000728D2, " ", ",");
        uint64_t v33 = *(void *)(v10 + 24);
        goto LABEL_42;
      case 5:
        int v34 = sub_10005179C(v11, v9, v8, &byte_1000728D2, &byte_1000728D2, "suffix");
        uint64_t v35 = sub_10005179C(v11, v34, v8, " ", &byte_1000728D2, "(");
        int v36 = sub_100057E58(v11, *(void *)(v10 + 8), v35, v35, 1LL);
        uint64_t v37 = sub_10005179C(v11, v36, v35, &byte_1000728D2, " ", ",");
        int v38 = sub_100057E58(v11, *(void *)(v10 + 16), v37, v35, 0LL);
        LODWORD(v9) = sub_10005179C(v11, v38, v8, &byte_1000728D2, &byte_1000728D2, ")");
        goto LABEL_14;
      case 6:
        int v40 = sub_10005179C(v11, v9, v8, &byte_1000728D2, &byte_1000728D2, "concat");
        uint64_t v41 = sub_10005179C(v11, v40, v8, " ", &byte_1000728D2, "(");
        uint64_t v42 = 1LL;
        uint64_t v43 = v41;
        while (1)
        {
          int v44 = sub_100057E58(v11, *(void *)(v10 + 8), v43, v41, v42);
          if (!*(void *)(v10 + 16)) {
            goto LABEL_52;
          }
          uint64_t v43 = sub_10005179C(v11, v44, v41, &byte_1000728D2, " ", ",");
          uint64_t v42 = 0LL;
          uint64_t v10 = *(void *)(v10 + 16);
          if (*(_DWORD *)(v10 + 4) != 6) {
            goto LABEL_51;
          }
        }

      case 7:
        int v45 = sub_10005179C(v11, v9, v8, &byte_1000728D2, &byte_1000728D2, "gethostbyname");
        uint64_t v46 = sub_10005179C(v11, v45, v8, " ", &byte_1000728D2, "(");
        int v50 = sub_100051668( v11,  v46,  v8,  &byte_1000728D2,  &byte_1000728D2,  v47,  v48,  v49,  "",  *(void *)(v10 + 8) + 40LL);
        goto LABEL_89;
      case 8:
        uint64_t v19 = "and";
        goto LABEL_92;
      case 9:
        uint64_t v19 = "or";
        goto LABEL_92;
      case 0xA:
        uint64_t v51 = sub_10005179C(v11, v9, v8, &byte_1000728D2, " ", "not");
        a2 = *(void *)(v10 + 8);
        a3 = v51;
        a4 = (v8 + 2);
        a1 = v11;
        a5 = 1LL;
        continue;
      case 0xB:
        goto LABEL_44;
      case 0xC:
        int v20 = &byte_1000728D2;
        uint64_t v21 = "hardware";
        goto LABEL_84;
      case 0xD:
        int v52 = sub_10005179C(v11, v9, v8, &byte_1000728D2, &byte_1000728D2, "packet");
        uint64_t v28 = sub_10005179C(v11, v52, v8, " ", &byte_1000728D2, "(");
        uint64_t v53 = *(void *)(v10 + 8);
        uint64_t v54 = v11;
        uint64_t v55 = v28;
        uint64_t v56 = v8;
        goto LABEL_39;
      case 0xE:
        return sub_1000518C8(v11, v9, v8, &byte_1000728D2, &byte_1000728D2, v10 + 8);
      case 0xF:
        goto LABEL_28;
      case 0x10:
        int v18 = 16;
        goto LABEL_28;
      case 0x11:
        int v18 = 32;
LABEL_28:
        int v57 = sub_10005179C(v11, v9, v8, &byte_1000728D2, &byte_1000728D2, "extract-int");
        uint64_t v58 = sub_10005179C(v11, v57, v8, " ", &byte_1000728D2, "(");
        int v59 = sub_100057E58(v11, *(void *)(v10 + 8), v58, v8, 1LL);
        int v60 = sub_10005179C(v11, v59, v58, &byte_1000728D2, " ", ",");
        goto LABEL_32;
      case 0x12:
        goto LABEL_31;
      case 0x13:
        int v18 = 16;
        goto LABEL_31;
      case 0x14:
        int v18 = 32;
LABEL_31:
        int v61 = sub_10005179C(v11, v9, v8, &byte_1000728D2, &byte_1000728D2, "encode-int");
        uint64_t v58 = sub_10005179C(v11, v61, v8, " ", &byte_1000728D2, "(");
        int v62 = sub_100057E58(v11, *(void *)(v10 + 8), v58, v8, 1LL);
        int v60 = sub_10005179C(v11, v62, v58, &byte_1000728D2, " ", ",");
LABEL_32:
        __sprintf_chk(__s, 0, 0x41uLL, "%d", v18);
        int v63 = sub_10005179C(v11, v60, v58, " ", &byte_1000728D2, __s);
        goto LABEL_68;
      case 0x15:
        __sprintf_chk(__s, 0, 0x41uLL, "%lu", *(void *)(v10 + 8));
        size_t v64 = __s;
        uint64_t v65 = v11;
        int v66 = v9;
        uint64_t v67 = v8;
        return sub_10005179C(v65, v66, v67, &byte_1000728D2, &byte_1000728D2, v64);
      case 0x16:
        int v17 = "exists";
        goto LABEL_44;
      case 0x17:
        uint64_t v68 = sub_10005179C(v11, v9, v8, &byte_1000728D2, &byte_1000728D2, "encapsulate");
        return sub_1000518C8(v11, v68, v8, " ", &byte_1000728D2, v10 + 8);
      case 0x18:
        int v20 = &byte_1000728D2;
        uint64_t v21 = "known";
        goto LABEL_84;
      case 0x19:
        int v69 = sub_10005179C(v11, v9, v8, &byte_1000728D2, &byte_1000728D2, "reverse");
        uint64_t v28 = sub_10005179C(v11, v69, v8, " ", &byte_1000728D2, "(");
        uint64_t v53 = *(void *)(v10 + 8);
        uint64_t v54 = v11;
        uint64_t v55 = v28;
        uint64_t v56 = v28;
LABEL_39:
        int v70 = sub_100057E58(v54, v53, v55, v56, 1LL);
        uint64_t v32 = sub_10005179C(v11, v70, v28, &byte_1000728D2, " ", ",");
        uint64_t v33 = *(void *)(v10 + 16);
        goto LABEL_42;
      case 0x1A:
        int v20 = &byte_1000728D2;
        uint64_t v21 = "leased-address";
        goto LABEL_84;
      case 0x1B:
        int v71 = sub_10005179C(v11, v9, v8, &byte_1000728D2, &byte_1000728D2, "binary-to-ascii");
        uint64_t v28 = sub_10005179C(v11, v71, v8, " ", &byte_1000728D2, "(");
        int v72 = sub_100057E58(v11, *(void *)(v10 + 8), v28, v28, 1LL);
        uint64_t v73 = sub_10005179C(v11, v72, v28, &byte_1000728D2, " ", ",");
        int v74 = sub_100057E58(v11, *(void *)(v10 + 16), v73, v28, 0LL);
        uint64_t v75 = sub_10005179C(v11, v74, v28, &byte_1000728D2, " ", ",");
        int v76 = sub_100057E58(v11, *(void *)(v10 + 24), v75, v28, 0LL);
        uint64_t v32 = sub_10005179C(v11, v76, v28, &byte_1000728D2, " ", ",");
        uint64_t v33 = *(void *)(v10 + 32);
LABEL_42:
        BOOL v77 = v11;
        uint64_t v78 = v28;
        uint64_t v79 = 0LL;
        goto LABEL_88;
      case 0x1C:
        int v17 = "config-option";
LABEL_44:
        int v44 = sub_10005179C(v11, v9, v8, &byte_1000728D2, &byte_1000728D2, v17);
        uint64_t v80 = *(void *)(v10 + 8);
        uint64_t v81 = *(char ***)(v80 + 16);
        if (v81 == (char **)&qword_10008C168)
        {
          uint64_t v21 = *(char **)v80;
          int v20 = " ";
          int v84 = v11;
          uint64_t v85 = v8;
        }

        else
        {
          int v82 = sub_10005179C(v11, v44, v8, " ", &byte_1000728D2, *v81);
          int v83 = sub_10005179C(v11, v82, v8, &byte_1000728D2, &byte_1000728D2, ".");
          uint64_t v21 = **(char ***)(v10 + 8);
          int v44 = v83;
LABEL_73:
          int v84 = v11;
          uint64_t v85 = v8;
          int v20 = &byte_1000728D2;
        }

        return sub_10005179C(v84, v44, v85, v20, &byte_1000728D2, v21);
      case 0x1D:
        int v20 = &byte_1000728D2;
        uint64_t v21 = "host-decl-name";
        goto LABEL_84;
      case 0x1E:
        int v86 = sub_10005179C(v11, v9, v8, &byte_1000728D2, &byte_1000728D2, "concat");
        uint64_t v41 = sub_10005179C(v11, v86, v8, " ", &byte_1000728D2, "(");
        uint64_t v87 = 1LL;
        uint64_t v43 = v41;
        while (1)
        {
          int v44 = sub_100057E58(v11, *(void *)(v10 + 8), v43, v41, v87);
          if (!*(void *)(v10 + 16)) {
            break;
          }
          uint64_t v43 = sub_10005179C(v11, v44, v41, &byte_1000728D2, " ", ",");
          uint64_t v87 = 0LL;
          uint64_t v10 = *(void *)(v10 + 16);
          if (*(_DWORD *)(v10 + 4) != 30)
          {
LABEL_51:
            int v44 = sub_100057E58(v11, v10, v43, v41, 0LL);
            break;
          }
        }

uint64_t sub_1000591B0( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void **)(a1 + 16);
  if (v9)
  {
    do
    {
      BOOL v13 = (void *)*v9;
      unsigned int v12 = (void *)v9[1];
      if (v12) {
        sub_10005CE20(v12, a2, a3, a4, a5, a6, a7, a8);
      }
      if (v9[2]) {
        sub_1000577E8(v9 + 2, a2, a3, a4, a5, a6, a7, a8);
      }
      sub_10005CE20(v9, a2, a3, a4, a5, a6, a7, a8);
      uint64_t v9 = v13;
    }

    while (v13);
  }

  *(void *)(a1 + 16) = 0LL;
  return 1LL;
}

uint64_t **sub_100059238( uint64_t *a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *a1;
  if (!v10)
  {
    if (!sub_100034DAC( a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  4304LL,  a4,  a5,  a6,  a7,  a8)) {
      return 0LL;
    }
    uint64_t v10 = *a1;
  }

  int v11 = sub_100055100(v10, a2);
  if (!v11)
  {
    unsigned int v12 = (uint64_t **)sub_10005CDE4(0x18uLL);
    int v11 = v12;
    if (v12)
    {
      *unsigned int v12 = 0LL;
      v12[1] = 0LL;
      _BYTE v12[2] = 0LL;
      int v13 = strlen(a2);
      uint64_t v14 = (char *)sub_10005CDE4((v13 + 1));
      v11[1] = (uint64_t *)v14;
      if (v14)
      {
        strcpy(v14, a2);
        *int v11 = *(uint64_t **)(*a1 + 16);
        *(void *)(*a1 + 16) = v11;
        return v11;
      }

      sub_10005CE20( v11,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  4317LL,  v15,  v16,  v17,  v18,  v19);
      return 0LL;
    }
  }

  return v11;
}

uint64_t sub_100059318( uint64_t *a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = (uint64_t)sub_100059238(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    uint64_t v15 = (void *)(result + 16);
    if (*(void *)(result + 16)) {
      sub_1000577E8( (uint64_t *)(result + 16),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  4341LL,  v10,  v11,  v12,  v13,  v14);
    }
    uint64_t result = (uint64_t)sub_10003444C( v15,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  4343LL,  v10,  v11,  v12,  v13,  v14);
    if ((_DWORD)result)
    {
      sub_100034E60( *v15 + 8LL,  a3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  4346LL,  v16,  v17,  v18,  v19);
      uint64_t result = 1LL;
      *(_DWORD *)(*v15 + 4LL) = 1;
    }
  }

  return result;
}

uint64_t sub_10005939C(uint64_t a1, uint64_t a2, char *a3)
{
  uint64_t result = (uint64_t)sub_100055100(a2, a3);
  if (result)
  {
    uint64_t v9 = result;
    uint64_t v10 = *(_DWORD **)(result + 16);
    if (v10 && v10[1] == 1)
    {
      if (v10[7])
      {
        sub_100034E60( a1,  (uint64_t)(v10 + 2),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  4366LL,  v5,  v6,  v7,  v8);
        return 1LL;
      }

      sub_1000345C4( (void *)a1,  v10[6],  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  4370LL);
      if (*(void *)a1)
      {
        memcpy( (void *)(*(void *)a1 + 4LL),  *(const void **)(*(void *)(v9 + 16) + 16LL),  *(unsigned int *)(*(void *)(v9 + 16) + 24LL));
        *(void *)(a1 + 8) = *(void *)a1 + 4LL;
        *(_DWORD *)(a1 + 16) = *(_DWORD *)(*(void *)(v9 + 16) + 24LL);
        return 1LL;
      }
    }

    return 0LL;
  }

  return result;
}

uint64_t **sub_10005945C(uint64_t a1, char *a2)
{
  uint64_t result = sub_100055100(a1, a2);
  if (result)
  {
    uint64_t v9 = result[2];
    uint64_t v8 = (uint64_t *)(result + 2);
    if (v9) {
      sub_1000577E8( v8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/common/tree.c",  4392LL,  v3,  v4,  v5,  v6,  v7);
    }
    return (uint64_t **)1;
  }

  return result;
}

unint64_t sub_100059490(unsigned __int8 *a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a2 >= 3)
  {
    unint64_t v5 = 0LL;
    while (1)
    {
      unint64_t result = v5 + 4;
      if (v5 + 4 > a4) {
        return 0xFFFFFFFFLL;
      }
      unint64_t v7 = a1[2];
      unint64_t v8 = a1[1];
      unsigned int v9 = *a1;
      a1 += 3;
      a2 -= 3LL;
      uint64_t v10 = (_BYTE *)(a3 + 1 + v5);
      *(v10 - 1) = aAbcdefghijklmn_0[(unint64_t)v9 >> 2];
      *uint64_t v10 = aAbcdefghijklmn_0[(v8 >> 4) & 0xFFFFFFFFFFFFFFCFLL | (16LL * (v9 & 3))];
      v10[1] = aAbcdefghijklmn_0[(v7 >> 6) & 0xFFFFFFFFFFFFFFC3LL | (4 * (v8 & 0xF))];
      v10[2] = aAbcdefghijklmn_0[v7 & 0x3F];
      unint64_t v5 = result;
      if (a2 <= 2)
      {
        if (a2) {
          goto LABEL_8;
        }
        goto LABEL_14;
      }
    }
  }

  unint64_t result = 0LL;
  if (a2)
  {
LABEL_8:
    uint64_t v11 = 0LL;
    unsigned __int8 v17 = 0;
    __int16 v16 = 0;
    do
    {
      *((_BYTE *)&v16 + v11) = a1[v11];
      ++v11;
    }

    while (a2 != v11);
    if (result + 4 > a4) {
      return 0xFFFFFFFFLL;
    }
    char v12 = HIBYTE(v16);
    unint64_t v13 = ((unint64_t)HIBYTE(v16) >> 4) & 0xFFFFFFFFFFFFFFCFLL | (16LL * (v16 & 3));
    *(_BYTE *)(a3 + result) = aAbcdefghijklmn_0[(unint64_t)v16 >> 2];
    unint64_t v14 = v17;
    *(_BYTE *)(a3 + (result | 1)) = aAbcdefghijklmn_0[v13];
    char v15 = 61;
    if (a2 != 1) {
      char v15 = aAbcdefghijklmn_0[(v14 >> 6) & 0xFFFFFFFFFFFFFFC3LL | (4LL * (v12 & 0xF))];
    }
    *(_BYTE *)(a3 + (result | 2)) = v15;
    *(_BYTE *)(a3 + (result | 3)) = 61;
    result += 4LL;
  }

uint64_t sub_1000595D4(_BYTE *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v6 = 0LL;
  unsigned int v7 = 0;
  char v8 = 1;
LABEL_2:
  uint64_t v9 = (int)v6;
  while (1)
  {
    do
    {
      while (1)
      {
        __darwin_ct_rune_t v11 = (char)*a1++;
        __darwin_ct_rune_t v10 = v11;
        if (!v11)
        {
          if ((v8 & 1) != 0) {
            return v6;
          }
          return 0xFFFFFFFFLL;
        }

        if ((v10 & 0x80000000) == 0) {
          break;
        }
        if (!__maskrune(v10, 0x4000uLL)) {
          goto LABEL_8;
        }
      }
    }

    while ((_DefaultRuneLocale.__runetype[v10] & 0x4000) != 0);
LABEL_8:
    if (v10 == 61) {
      break;
    }
    char v12 = memchr("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", v10, 0x41uLL);
    if (!v12) {
      return 0xFFFFFFFFLL;
    }
    if (v7)
    {
      if (v7 == 1)
      {
        if (!a2)
        {
          char v8 = 0;
          uint64_t v6 = (v6 + 1);
          unsigned int v7 = 2;
          goto LABEL_2;
        }

        uint64_t v6 = (int)v6 + 1LL;
        if (v9 + 1 < a3)
        {
          char v8 = 0;
          *(_BYTE *)(a2 + v9) |= (v12
                                - "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/") >> 4;
          *(_BYTE *)(a2 + v6) = 16
                              * ((_BYTE)v12
                               - "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
          unsigned int v7 = 2;
          goto LABEL_2;
        }
      }

      else
      {
        if (v7 != 2)
        {
          if (a2)
          {
            *(_BYTE *)(a2 + (int)v6) |= (_BYTE)v12
                                      - "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
          }

          unsigned int v7 = 0;
          uint64_t v6 = (v6 + 1);
          char v8 = 1;
          goto LABEL_2;
        }

        if (!a2)
        {
          char v8 = 0;
          uint64_t v6 = (v6 + 1);
          unsigned int v7 = 3;
          goto LABEL_2;
        }

        uint64_t v6 = (int)v6 + 1LL;
        if (v9 + 1 < a3)
        {
          char v8 = 0;
          *(_BYTE *)(a2 + v9) |= (v12
                                - "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/") >> 2;
          *(_BYTE *)(a2 + v6) = ((_BYTE)v12
                               - "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/") << 6;
          unsigned int v7 = 3;
          goto LABEL_2;
        }
      }

      return 0xFFFFFFFFLL;
    }

    char v8 = 0;
    unsigned int v7 = 1;
    if (a2)
    {
      char v8 = 0;
      *(_BYTE *)(a2 + (int)v6) = 4
                               * ((_BYTE)v12
                                - "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
    }
  }

  if (v7 >= 2)
  {
    char v15 = a1 + 2;
    unsigned int v14 = (char)*a1;
    if (v7 == 2)
    {
      if (!*a1) {
        return 0xFFFFFFFFLL;
      }
      while (v14 > 0x7F ? __maskrune(v14, 0x4000uLL) : _DefaultRuneLocale.__runetype[v14] & 0x4000)
      {
        unsigned int v14 = *(v15++ - 1);
        uint64_t result = 0xFFFFFFFFLL;
        if (!v14) {
          return result;
        }
      }

      if (v14 != 61) {
        return 0xFFFFFFFFLL;
      }
      unsigned int v14 = *(v15 - 1);
      if (*(v15 - 1))
      {
LABEL_41:
        while (v14 > 0x7F ? __maskrune(v14, 0x4000uLL) : _DefaultRuneLocale.__runetype[v14] & 0x4000)
        {
          unsigned int v18 = *v15++;
          unsigned int v14 = v18;
          if (!v18) {
            goto LABEL_46;
          }
        }

        return 0xFFFFFFFFLL;
      }
    }

    else
    {
      char v15 = a1 + 1;
      if (*a1) {
        goto LABEL_41;
      }
    }

void sub_100059834()
{
  if ((byte_1000C55AC & 1) == 0)
  {
    byte_1000C55AC = 1;
    uint64_t v0 = getenv("DSTKEYPATH");
    if (v0)
    {
      int v1 = v0;
      unsigned int v2 = strlen(v0);
      if (v2 <= 0x400 && !stat(v1, &v5) && (v5.st_mode & 0xF000) == 0x4000)
      {
        uint64_t v3 = malloc(v2 + 2);
        memcpy(v3, v1, v2 + 1);
        size_t v4 = strlen((const char *)v3);
        if (*((_BYTE *)v3 + ((uint64_t)((v4 << 32) - 0x100000000LL) >> 32)) != 47)
        {
          *((_BYTE *)v3 + ((uint64_t)((uint64_t)&_mh_execute_header + (v4 << 32)) >> 32)) = 0;
          *((_BYTE *)v3 + (int)v4) = 47;
        }

        off_10008BB88 = v3;
      }
    }

    bzero(qword_10008C968, 0x4F0uLL);
    sub_10005AF88();
  }

BOOL sub_100059928(int a1)
{
  return qword_10008C968[a1] != 0LL;
}

uint64_t sub_100059940(uint64_t a1, _DWORD *a2)
{
  if ((_DWORD *)a1 == a2) {
    return 0LL;
  }
  uint64_t v2 = 4LL;
  if (a1 && a2)
  {
    if (*(_DWORD *)(a1 + 16) == a2[4])
    {
      if (*(_DWORD *)(a1 + 8) == a2[2])
      {
        if (*(_DWORD *)(a1 + 24) == a2[6]) {
          return (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16LL))();
        }
        return 3LL;
      }

      else
      {
        return 2LL;
      }
    }

    else
    {
      return 1LL;
    }
  }

  return v2;
}

uint64_t sub_1000599B4(char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((a1 & 4) == 0 || (uint64_t v6 = 4294967266LL, a6) && *(void *)(a2 + 32))
  {
    uint64_t v6 = *(void *)(a2 + 40);
    if (v6)
    {
      if (*(void *)v6) {
        return (*(uint64_t (**)(void))v6)();
      }
      return 0LL;
    }
  }

  return v6;
}

uint64_t sub_1000599E8(char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((a1 & 4) == 0 || (uint64_t v6 = 4294967266LL, a6) && *(void *)(a2 + 32))
  {
    uint64_t v7 = *(void *)(a2 + 40);
    if (v7)
    {
      char v8 = *(uint64_t (**)(void))(v7 + 8);
      if (v8) {
        return v8();
      }
    }

    return 4294967265LL;
  }

  return v6;
}

uint64_t sub_100059A1C(uint64_t a1, int a2, int a3, int a4)
{
  uint64_t v4 = 0LL;
  if (a1 && a4 && qword_10008C968[a3])
  {
    __strcpy_chk(__s2);
    char v8 = sub_10005AE8C((const char *)v53, "r", 0);
    if (!v8) {
      return 0LL;
    }
    uint64_t v9 = v8;
    do
    {
      while (1)
      {
        unsigned int v10 = getc(v9);
        if (v10 == -1) {
          goto LABEL_17;
        }
        if (v10 > 0x7F) {
          break;
        }
        if ((_DefaultRuneLocale.__runetype[v10] & 0x4000) != 0) {
          goto LABEL_17;
        }
      }
    }

    while (!__maskrune(v10, 0x4000uLL));
    do
    {
      while (1)
      {
LABEL_17:
        unsigned int v12 = getc(v9);
        if (v12 == -1) {
          return 0LL;
        }
        unsigned int v11 = v12;
        if (v12 > 0x7F) {
          break;
        }
        if ((_DefaultRuneLocale.__runetype[v12] & 0x4000) == 0) {
          goto LABEL_19;
        }
      }
    }

    while (__maskrune(v12, 0x4000uLL));
LABEL_19:
    if (v11 - 48 <= 9)
    {
      do
      {
        while (1)
        {
          unsigned int v13 = getc(v9);
          if (v13 == -1) {
            goto LABEL_30;
          }
          if (v13 > 0x7F) {
            break;
          }
          if ((_DefaultRuneLocale.__runetype[v13] & 0x4000) != 0) {
            goto LABEL_30;
          }
        }
      }

      while (!__maskrune(v13, 0x4000uLL));
LABEL_30:
      while (1)
      {
        unsigned int v14 = getc(v9);
        if (v14 == -1) {
          return 0LL;
        }
        unsigned int v11 = v14;
        if (v14 > 0x7F)
        {
          if (!__maskrune(v14, 0x4000uLL)) {
            break;
          }
        }

        else if ((_DefaultRuneLocale.__runetype[v14] & 0x4000) == 0)
        {
          break;
        }
      }
    }

    if ((v11 & 0xFFFFFFDF) == 0x49)
    {
      do
      {
        while (1)
        {
          unsigned int v15 = getc(v9);
          if (v15 == -1) {
            goto LABEL_43;
          }
          if (v15 > 0x7F) {
            break;
          }
          if ((_DefaultRuneLocale.__runetype[v15] & 0x4000) != 0) {
            goto LABEL_43;
          }
        }
      }

      while (!__maskrune(v15, 0x4000uLL));
LABEL_43:
      while (1)
      {
        unsigned int v16 = getc(v9);
        if (v16 == -1) {
          return 0LL;
        }
        unsigned int v11 = v16;
        if (v16 > 0x7F)
        {
          if (!__maskrune(v16, 0x4000uLL)) {
            break;
          }
        }

        else if ((_DefaultRuneLocale.__runetype[v16] & 0x4000) == 0)
        {
          break;
        }
      }
    }

    if ((v11 & 0xFFFFFFDF) != 0x4B) {
      return 0LL;
    }
    do
    {
      while (1)
      {
        unsigned int v17 = getc(v9);
        if (v17 == -1) {
          goto LABEL_56;
        }
        if (v17 > 0x7F) {
          break;
        }
        if ((_DefaultRuneLocale.__runetype[v17] & 0x4000) != 0) {
          goto LABEL_56;
        }
      }
    }

    while (!__maskrune(v17, 0x4000uLL));
LABEL_56:
    while (1)
    {
      unsigned int v18 = getc(v9);
      int v19 = v18;
      if (v18 == -1) {
        break;
      }
      if (v18 > 0x7F)
      {
        if (!__maskrune(v18, 0x4000uLL)) {
          break;
        }
      }

      else if ((_DefaultRuneLocale.__runetype[v18] & 0x4000) == 0)
      {
        break;
      }
    }

    ungetc(v19, v9);
    while (1)
    {
      unsigned int v20 = getc(v9);
      if (v20 == -1) {
        break;
      }
      if (v20 > 0x7F)
      {
        if (!__maskrune(v20, 0x4000uLL)) {
          break;
        }
      }

      else if ((_DefaultRuneLocale.__runetype[v20] & 0x4000) == 0)
      {
        break;
      }
    }

    if (!feof(v9)) {
      return 0LL;
    }
    fclose(v9);
    int v21 = strlen((const char *)v55);
    if (!v21) {
      return 0LL;
    }
    *((_BYTE *)v55 + (v21 - 1)) = 0;
    uint64_t v22 = &v54;
    do
    {
      uint64_t v23 = v22[1];
      if (v22[1] < 0) {
        __uint32_t v24 = __maskrune(v23, 0x4000uLL);
      }
      else {
        __uint32_t v24 = _DefaultRuneLocale.__runetype[v23] & 0x4000;
      }
      ++v22;
    }

    while (v24);
    uint64_t v25 = sub_1000595D4(v22, (uint64_t)v51, 0x2000uLL);
    if ((v25 & 0x80000000) != 0) {
      return 0LL;
    }
    uint64_t v26 = (int *)sub_10005A68C(__s2, v47, v49, v48, (uint64_t)v51, v25);
    uint64_t v4 = (uint64_t)v26;
    if (v26)
    {
      if (a4 != 0x4000000)
      {
        int v27 = sub_10005A118(__s2, v26[4], v26[5], v26[3], 0);
        if (!v27) {
          return 0LL;
        }
        uint64_t v28 = (uint64_t)v27;
        int v29 = *(_DWORD *)(v4 + 24);
        if (sub_10005ADA4(v51, __s2, v29, *(_DWORD *)(v4 + 16), "private", 0x400uLL) != -1)
        {
          uint64_t v30 = sub_10005AE8C(v51, "r", 0);
          if (v30)
          {
            int v31 = v30;
            int v32 = fread(v55, 1uLL, 0x2000uLL, v30);
            fclose(v31);
            if (v32 >= 5)
            {
              if (v55[0] == 0x2D65746176697250LL && v55[1] == 0x6D726F662D79656BLL && v56 == 540701793)
              {
                v53[0] = (const char *)v55;
                if (sub_10005A9F0(v53, "Private-key-format: v"))
                {
                  sscanf(v53[0], "%d.%d", &v46, &v45);
                  sscanf("1.2", "%d.%d", &v48, &v47);
                  if (v46 >= 1)
                  {
                    int v36 = v53[0] + 1;
                    do
                    {
                      v53[0] = v36;
                      int v37 = *((unsigned __int8 *)v36++ - 1);
                    }

                    while (v37 != 10);
                    if (sub_10005A9F0(v53, "Algorithm: ") && sscanf(v53[0], "%d", &v49) == 1)
                    {
                      int v38 = v53[0] + 1;
                      do
                      {
                        v53[0] = v38;
                        int v39 = *((unsigned __int8 *)v38++ - 1);
                      }

                      while (v39 != 10);
                      int v40 = *(char **)v28;
                      if (*(void *)v28)
                      {
                        if (!strcmp(*(const char **)v28, __s2))
                        {
                          size_t v41 = strlen(v40);
                          if (v41)
                          {
                            bzero(v40, v41);
                            free(*(void **)v28);
                          }
                        }
                      }

                      *(void *)uint64_t v28 = strdup(__s2);
                      uint64_t v42 = *(void *)(v28 + 40);
                      if (v42)
                      {
                        uint64_t v43 = *(uint64_t (**)(uint64_t, const char *, void))(v42 + 64);
                        if (v43)
                        {
                          int v44 = v43(v28, v53[0], &v52 + 2104 + v32 - LODWORD(v53[0]));
                          if ((v44 & 0x80000000) == 0 && v44 == v29)
                          {
                            *(_DWORD *)(v28 + 24) = (unsigned __int16)v29;
                            *(_DWORD *)(v28 + 16) = v49;
                            __memset_chk(v55, 0LL, v32, 0x2000LL);
                            goto LABEL_87;
                          }
                        }
                      }
                    }
                  }
                }
              }

              __memset_chk(v55, 0LL, v32, 0x2000LL);
            }
          }
        }

        sub_10005A1A4(v28);
        uint64_t v28 = 0LL;
LABEL_87:
        sub_10005A1A4(v4);
        return v28;
      }
    }
  }

  return v4;
}

void *sub_10005A118(const char *a1, int a2, int a3, int a4, int a5)
{
  uint64_t v5 = qword_10008C968[a2];
  if (!v5) {
    return 0LL;
  }
  unsigned int v11 = malloc(0x30uLL);
  unsigned int v12 = v11;
  if (v11)
  {
    v11[3] = 0LL;
    *unsigned int v11 = strdup(a1);
    *((_DWORD *)v12 + 4) = a2;
    *((_DWORD *)v12 + 5) = a3;
    *((_DWORD *)v12 + 2) = a5;
    *((_DWORD *)v12 + 3) = a4;
    v12[4] = 0LL;
    v12[5] = v5;
  }

  return v12;
}

uint64_t sub_10005A1A4(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = *(uint64_t (**)(void))(v2 + 32);
    if (v3)
    {
      uint64_t v4 = (void *)v3(*(void *)(a1 + 32));
      *(void *)(a1 + 32) = v4;
      if (!v4) {
        goto LABEL_8;
      }
      goto LABEL_7;
    }
  }

  free(*(void **)(a1 + 32));
  uint64_t v4 = *(void **)(a1 + 32);
  if (v4)
  {
LABEL_7:
    free(v4);
    *(void *)(a1 + 32) = 0LL;
  }

uint64_t sub_10005A22C(uint64_t a1, int a2)
{
  if (a1)
  {
    if ((a2 & 0x6000000) != 0)
    {
      if ((a2 & 0x4000000) == 0
        || (bzero(v18, 0x2000uLL), int v4 = sub_10005A5AC(a1, v18, 0x2000u), v4 < 0)
        || (int v5 = v4,
            sub_10005ADA4( v17,  *(const char **)a1,  *(_DWORD *)(a1 + 24),  *(_DWORD *)(a1 + 16),  "key",  0x400uLL) == -1))
      {
        LODWORD(v6) = 0;
        if ((a2 & 0x2000000) == 0) {
          goto LABEL_25;
        }
      }

      else
      {
        uint64_t v6 = sub_10005AE8C(v17, "w+", 420);
        if (v6)
        {
          uint64_t v7 = 6LL;
          if ((*(_DWORD *)(a1 + 20) & 0x1000) != 0)
          {
            int v8 = -6;
          }

          else
          {
            uint64_t v7 = 4LL;
            int v8 = -4;
          }

          sub_100059490((unsigned __int8 *)&v18[v7], (v8 + v5), (uint64_t)v16, 0x2000uLL);
          fprintf( v6,  "%s IN KEY %d %d %d %s\n",  *(const char **)a1,  *(_DWORD *)(a1 + 20),  *(_DWORD *)(a1 + 12),  *(_DWORD *)(a1 + 16),  v16);
          fclose(v6);
          LODWORD(v6) = 1;
        }

        if ((a2 & 0x2000000) == 0) {
          goto LABEL_25;
        }
      }

      if (*(void *)(a1 + 32))
      {
        uint64_t v10 = *(void *)(a1 + 40);
        if (!v10) {
          return 4294967291LL;
        }
        unsigned int v11 = *(uint64_t (**)(uint64_t, char *, uint64_t))(v10 + 56);
        if (!v11) {
          return 4294967291LL;
        }
        uint64_t v12 = v11(a1, v18, 0x2000LL);
        if (!(_DWORD)v12) {
          return 4294967288LL;
        }
        uint64_t v9 = v12;
        sub_10005ADA4(v16, *(const char **)a1, *(_DWORD *)(a1 + 24), *(_DWORD *)(a1 + 16), "private", 0x400uLL);
        unsigned int v13 = sub_10005AE8C(v16, "w", 384);
        if (!v13) {
          return 4294967290LL;
        }
        unsigned int v14 = v13;
        fclose(v14);
        __memset_chk(v18, 0LL, v9, 0x2000LL);
        if ((v9 & 0x80000000) != 0) {
          return v9;
        }
        return (v9 + (_DWORD)v6);
      }

LABEL_25:
      LODWORD(v9) = 0;
      return (v9 + (_DWORD)v6);
    }
  }

  return 0LL;
}

void *sub_10005A4B8(const char *a1, uint64_t a2, unsigned int a3)
{
  uint64_t result = 0LL;
  if (a2 && a3 >= 4)
  {
    uint64_t v7 = *(unsigned __int8 *)(a2 + 3);
    if (!qword_10008C968[v7]) {
      return 0LL;
    }
    int v8 = sub_10005A118(a1, v7, 0, 0, 0);
    uint64_t result = 0LL;
    if (a1 && v8)
    {
      int v9 = sub_10005ACC0((unsigned __int16 *)a2);
      *((_DWORD *)v8 + 5) = v9;
      *((_DWORD *)v8 + 3) = *(unsigned __int8 *)(a2 + 2);
      if ((v9 & 0x1000) != 0)
      {
        *((_DWORD *)v8 + 5) = v9 | (sub_10005ACC0((unsigned __int16 *)(a2 + 4)) << 16);
        unsigned int v10 = 6;
      }

      else
      {
        unsigned int v10 = 4;
      }

      uint64_t v11 = v8[5];
      if (v11)
      {
        uint64_t v12 = *(int (**)(void *, uint64_t, void))(v11 + 48);
        if (v12)
        {
          if (v12(v8, a2 + v10, a3 - v10) > 0) {
            return v8;
          }
        }
      }

      *((_OWORD *)v8 + 1) = 0u;
      *((_OWORD *)v8 + 2) = 0u;
      *(_OWORD *)int v8 = 0u;
      free(v8);
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_10005A5AC(uint64_t a1, char *a2, unsigned int a3)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  bzero(a2, a3);
  *(_WORD *)a2 = bswap32(*(unsigned __int16 *)(a1 + 20)) >> 16;
  a2[2] = *(_DWORD *)(a1 + 12);
  a2[3] = *(_DWORD *)(a1 + 16);
  unsigned int v6 = *(_DWORD *)(a1 + 20);
  if (v6 < 0x10000)
  {
    uint64_t v7 = 4LL;
  }

  else
  {
    a2[4] = HIBYTE(v6);
    a2[5] = BYTE2(v6);
    uint64_t v7 = 6LL;
  }

  if (*(void *)(a1 + 32))
  {
    uint64_t v8 = *(void *)(a1 + 40);
    if (v8)
    {
      int v9 = *(uint64_t (**)(uint64_t, char *, void))(v8 + 40);
      if (v9)
      {
        int v10 = v9(a1, &a2[v7], a3 - v7);
        if (v10 <= 0) {
          return 0xFFFFFFFFLL;
        }
        else {
          return (v10 + v7);
        }
      }
    }

    return 0xFFFFFFFFLL;
  }

  return v7;
}

uint64_t sub_10005A68C(const char *a1, int a2, int a3, int a4, uint64_t a5, uint64_t a6)
{
  if (!qword_10008C968[a2]) {
    return 0LL;
  }
  uint64_t v8 = sub_10005A118(a1, a2, a3, a4, -1);
  uint64_t v9 = (uint64_t)v8;
  if (v8)
  {
    uint64_t v10 = v8[5];
    if (!v10) {
      return 0LL;
    }
    uint64_t v11 = *(uint64_t (**)(void *, uint64_t, uint64_t))(v10 + 48);
    if (!v11) {
      return 0LL;
    }
    if ((v11(v8, a5, a6) & 0x80000000) != 0)
    {
      sub_10005A1A4(v9);
      return 0LL;
    }
  }

  return v9;
}

uint64_t sub_10005A708(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v1 = *(void *)(a1 + 40);
  if (!v1) {
    return 0LL;
  }
  int v2 = (*(uint64_t (**)(void))(v1 + 40))();
  return v2 & ~(v2 >> 31);
}

uint64_t sub_10005A738(const char *a1, int a2, uint64_t a3, int a4, int a5, int a6)
{
  if (!a1 || !qword_10008C968[a6]) {
    return 0LL;
  }
  uint64_t v8 = sub_10005A118(a1, a6, a4, a5, a2);
  uint64_t v9 = (uint64_t)v8;
  if (v8)
  {
    if (a2)
    {
      uint64_t v10 = v8[5];
      if (!v10 || (uint64_t v11 = *(int (**)(void *, uint64_t))(v10 + 24)) == 0LL || v11(v8, a3) <= 0)
      {
        sub_10005A1A4(v9);
        return 0LL;
      }
    }
  }

  return v9;
}

uint64_t sub_10005A7C8(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 16);
  if (v1 > 156)
  {
    if (v1 != 157)
    {
      if (v1 == 158) {
        return 20LL;
      }
      return 0xFFFFFFFFLL;
    }

    return 16LL;
  }

  else
  {
    if (v1 != 1)
    {
      if (v1 == 3) {
        return 40LL;
      }
      return 0xFFFFFFFFLL;
    }

    int v3 = *(_DWORD *)(a1 + 8);
    int v5 = v3 + 7;
    BOOL v4 = v3 < -7;
    int v6 = v3 + 14;
    if (!v4) {
      int v6 = v5;
    }
    return (v6 >> 3);
  }

size_t sub_10005A82C(int a1, size_t __n, char *__dst)
{
  uint64_t v4 = 0LL;
  if ((_DWORD)__n && __dst)
  {
    switch(a1)
    {
      case 3:
        return sub_10005BF08(__dst, __n);
      case 2:
        return sub_10005C908(__dst, __n);
      case 1:
        int v6 = malloc(__n + 4LL);
        uint64_t v7 = 0LL;
        do
        {
          v6[v7] = sub_10005BED4(v7 * 4);
          ++v7;
        }

        while ((v7 * 4) < __n);
        memcpy(__dst, v6, __n);
        if (v6)
        {
          *int v6 = 0;
          free(v6);
        }

        return __n;
      default:
        return 0LL;
    }
  }

  return v4;
}

uint64_t sub_10005A914(char *a1, unsigned int a2, char *__s, unsigned __int8 *a4, unsigned int a5)
{
  if (!a4) {
    return 0LL;
  }
  uint64_t result = 0xFFFFFFFFLL;
  if (a1)
  {
    unsigned int v7 = a2;
    if (a2)
    {
      uint64_t v8 = a4;
      if (*a4 || !a5)
      {
        unsigned int v11 = a5;
        if (__s)
        {
LABEL_12:
          unsigned int v13 = strlen(__s);
          unsigned int v14 = v13;
          BOOL v15 = v7 >= v13;
          v7 -= v13;
          if (v7 == 0 || !v15) {
            return 0xFFFFFFFFLL;
          }
          memcpy(a1, __s, v13);
          a1 += v14;
          int v16 = v14 + 1;
          goto LABEL_18;
        }
      }

      else
      {
        do
        {
          int v10 = *++v8;
          unsigned int v11 = a5 - 1;
          if (v10) {
            BOOL v12 = 1;
          }
          else {
            BOOL v12 = a5 == 1;
          }
          --a5;
        }

        while (!v12);
        if (__s) {
          goto LABEL_12;
        }
      }

      int v16 = 1;
LABEL_18:
      int v17 = sub_100059490(v8, v11, (uint64_t)a1, v7 - 2);
      *(_WORD *)&a1[v17] = 10;
      return (v16 + v17);
    }
  }

  return result;
}

uint64_t sub_10005A9F0(const char **a1, const char *a2)
{
  int v2 = *a1;
  if (!*a1) {
    return 0LL;
  }
  if (a2 && *a2)
  {
    unsigned int v5 = strlen(*a1);
    unsigned int v6 = strlen(a2);
    if (v6 > v5) {
      return 0LL;
    }
    uint64_t v7 = v6;
    if (strncmp(v2, a2, v6)) {
      return 0LL;
    }
    *a1 = &v2[v7];
  }

  return 1LL;
}

_BYTE *sub_10005AA74(const char **a1, char *a2, unsigned int a3)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v4 = *a1;
  if (!*a1) {
    return v4;
  }
  uint64_t v7 = strchr(*a1, 10);
  if (!v7)
  {
    uint64_t v4 = (_BYTE *)sub_1000595D4(v4, (uint64_t)__src, 0x2000uLL);
    return 0LL;
  }

  uint64_t v8 = v7;
  *uint64_t v7 = 0;
  uint64_t v9 = sub_1000595D4(*a1, (uint64_t)__src, 0x2000uLL);
  uint64_t v4 = 0LL;
  if ((int)v9 - 1 < a3)
  {
    *a1 = v8;
    uint64_t v4 = (_BYTE *)v9;
LABEL_7:
    bzero(a2, a3 - v4);
    memcpy(&a2[a3 - v4], __src, v4);
  }

  return v4;
}

uint64_t sub_10005AB90(_BYTE *a1, uint64_t a2)
{
  int v2 = *a1;
  if (*a1) {
    BOOL v3 = 1;
  }
  else {
    BOOL v3 = (int)a2 < 1;
  }
  if (!v3)
  {
    uint64_t v4 = a1 + 1;
    do
    {
      int v5 = *v4++;
      int v2 = v5;
      if (v5) {
        BOOL v6 = 0;
      }
      else {
        BOOL v6 = a2 > 8;
      }
      a2 = (a2 - 8);
    }

    while (v6);
  }

  if ((v2 & 0x80) == 0)
  {
    unsigned int v7 = 128;
    do
    {
      a2 = (a2 - 1);
      v7 >>= 1;
    }

    while ((v7 & ~v2) != 0);
  }

  return a2;
}

uint64_t sub_10005ABD8(unsigned __int16 *a1, unsigned int a2)
{
  if (!a1)
  {
    LOWORD(v4) = 0;
    return (unsigned __int16)v4;
  }

  if (a2 < 2)
  {
    unsigned int v2 = 0;
    if (!a2) {
      return (unsigned __int16)(v2 + HIWORD(v2));
    }
  }

  else
  {
    unsigned int v2 = 0;
    do
    {
      unsigned int v3 = *a1++;
      v2 += bswap32(v3) >> 16;
      a2 -= 2;
    }

    while (a2 > 1);
    if (!a2) {
      return (unsigned __int16)(v2 + HIWORD(v2));
    }
  }

  v2 += *(unsigned __int8 *)a1 << 8;
  return (unsigned __int16)(v2 + HIWORD(v2));
}

uint64_t sub_10005AC2C(_BYTE *a1, unsigned int a2)
{
  LOWORD(v2) = 0;
  if (a1 && a2 >= 4)
  {
    if (a1[3] == 1) {
      return bswap32(*(unsigned __int16 *)&a1[a2 - 3]) >> 16;
    }
    if ((*a1 & 0x10) != 0) {
      uint64_t v3 = 6LL;
    }
    else {
      uint64_t v3 = 4LL;
    }
    int v4 = (unsigned __int16 *)&a1[v3];
    unsigned int v5 = a2 - v3;
    if (v5 < 2)
    {
      unsigned int v6 = 0;
      if (!v5) {
        return (unsigned __int16)(v6 + HIWORD(v6));
      }
    }

    else
    {
      unsigned int v6 = 0;
      do
      {
        unsigned int v7 = *v4++;
        v6 += bswap32(v7) >> 16;
        v5 -= 2;
      }

      while (v5 > 1);
      if (!v5) {
        return (unsigned __int16)(v6 + HIWORD(v6));
      }
    }

    v6 += *(unsigned __int8 *)v4 << 8;
    return (unsigned __int16)(v6 + HIWORD(v6));
  }

  return (unsigned __int16)v2;
}

uint64_t sub_10005ACC0(unsigned __int16 *a1)
{
  return bswap32(*a1) >> 16;
}

uint64_t sub_10005ACD0(unsigned int *a1)
{
  return bswap32(*a1);
}

_WORD *sub_10005ACDC(_WORD *result, unsigned int a2)
{
  void *result = __rev16(a2);
  return result;
}

_DWORD *sub_10005ACE8(_DWORD *result, unsigned int a2)
{
  void *result = bswap32(a2);
  return result;
}

const char *sub_10005ACF4(const char *result, const char *a2)
{
  if (result)
  {
    uint64_t v3 = result;
    if (strrchr(result, 92) || strrchr(v3, 47)) {
      return 0LL;
    }
    int v4 = strrchr(v3, 58);
    uint64_t result = 0LL;
    if (a2 && !v4)
    {
      if (!strrchr(a2, 92) && !strrchr(a2, 47) && !strrchr(a2, 58))
      {
        size_t v5 = strlen(v3);
        return (const char *)(v5 + strlen(a2) + 7);
      }

      return 0LL;
    }
  }

  return result;
}

uint64_t sub_10005ADA4(void *a1, const char *a2, int a3, int a4, const char *a5, size_t a6)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  bzero(a1, a6);
  uint64_t result = 0xFFFFFFFFLL;
  if (a2 && a5)
  {
    size_t v13 = strlen(a2);
    if (v13 + strlen(a5) + 12 > a6) {
      return 0xFFFFFFFFLL;
    }
    sprintf((char *)a1, "K%s+%03d+%05d.%s", a2, a4, a3, a5);
    if (strrchr((const char *)a1, 47) || strrchr((const char *)a1, 92))
    {
      return 0xFFFFFFFFLL;
    }

    else if (strrchr((const char *)a1, 58))
    {
      return 0xFFFFFFFFLL;
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

FILE *sub_10005AE8C(const char *a1, const char *a2, int a3)
{
  if (*off_10008BB88)
  {
    __strcpy_chk(__s);
    unsigned int v6 = 1024 - strlen(__s);
  }

  else
  {
    __s[0] = 0;
    unsigned int v6 = 1024;
  }

  if (strlen(a1) >= v6) {
    return 0LL;
  }
  strncpy(&__s[1024 - v6], a1, v6 - 1);
  unsigned int v7 = fopen(__s, a2);
  if (a3) {
    chmod(__s, a3);
  }
  return v7;
}

uint64_t sub_10005AF88()
{
  return 0LL;
}

double sub_10005AF90(uint64_t a1)
{
  *(void *)&double result = 1732584193LL;
  *(_OWORD *)a1 = xmmword_100082FC0;
  *(_OWORD *)(a1 + 16) = xmmword_100082FD0;
  *(_DWORD *)(a1 + 176) = 0;
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + 4__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = 0LL;
  return result;
}

void *sub_10005AFB0(void *result, unsigned int *a2, unint64_t a3)
{
  if (!a3) {
    return result;
  }
  unint64_t v3 = a3;
  size_t v5 = result;
  unint64_t v6 = result[4];
  unint64_t v7 = (v6 + 8 * a3);
  if (v7 >= v6) {
    uint64_t v8 = result[5];
  }
  else {
    uint64_t v8 = result[5] + 1LL;
  }
  result[4] = v7;
  result[5] = v8 + (a3 >> 29);
  uint64_t v9 = *((int *)result + 44);
  if ((_DWORD)v9)
  {
    int v10 = result + 6;
    int v11 = (int)v9 >> 2;
    uint64_t v12 = v9 & 3;
    if (v9 + a3 >= 0x40) {
      __asm { BR              X14 }
    }

    *((_DWORD *)result + 44) += a3;
    if (v12 + a3 > 3) {
      __asm { BR              X15 }
    }

    uint64_t v24 = v11;
    uint64_t v25 = v10[v11];
    if ((_DWORD)v12 == 2
      || ((_DWORD)v12 == 1
       || !(_DWORD)v12
       && (v26 = *(unsigned __int8 *)a2, a2 = (unsigned int *)((char *)a2 + 1), v25 = v26, unint64_t v3 = a3 - 1, a3 != 1))
      && (unsigned int v27 = *(unsigned __int8 *)a2, a2 = (unsigned int *)((char *)a2 + 1),
                                        v25 |= (unint64_t)v27 << 8,
                                        v3 != 1))
    {
      v25 |= (unint64_t)*(unsigned __int8 *)a2 << 16;
    }

    v10[v24] = v25;
    return result;
  }

  size_t v13 = result + 6;
  if (a3 >= 0x40)
  {
    do
    {
      uint64_t v14 = 6LL;
      do
      {
        BOOL v15 = &v5[v14];
        *BOOL v15 = *a2;
        v15[1] = a2[1];
        char v15[2] = a2[2];
        uint64_t v16 = a2[3];
        a2 += 4;
        v15[3] = v16;
        v14 += 4LL;
      }

      while ((_DWORD)(v14 * 8) != 176);
      double result = sub_10005B288(v5, v5 + 6);
      v3 -= 64LL;
    }

    while (v3 > 0x3F);
  }

  *((_DWORD *)v5 + 44) = v3;
  if ((_DWORD)v3)
  {
    int v17 = v3 & 3;
    if (v3 >= 4)
    {
      unsigned int v18 = v3 >> 2;
      do
      {
        unsigned int v19 = *a2++;
        *v13++ = v19;
        --v18;
      }

      while (v18);
    }

    unint64_t v20 = 0LL;
    int v21 = (char *)a2 + (v3 & 3);
    if (v17 != 1)
    {
      if (v17 != 2)
      {
        if (v17 != 3)
        {
LABEL_22:
          *size_t v13 = v20;
          return result;
        }

        unsigned int v22 = *--v21;
        unint64_t v20 = (unint64_t)v22 << 16;
      }

      unsigned int v23 = *--v21;
      v20 |= (unint64_t)v23 << 8;
    }

    v20 |= *(v21 - 1);
    goto LABEL_22;
  }

  return result;
}

void *sub_10005B288(void *result, uint64_t *a2)
{
  uint64_t v2 = result[1];
  uint64_t v4 = result[2];
  uint64_t v3 = result[3];
  uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  uint64_t v7 = v2
     + ((*result + *a2 + 3614090360LL + (v4 & v2 | v3 & ~v2)) << 7)
     + ((*(_DWORD *)result
       + *(_DWORD *)a2
       - 680876936
       + (v4 & v2 | v3 & ~(_DWORD)v2)) >> 25);
  int v8 = v7
  uint64_t v9 = a2[2];
  uint64_t v10 = a2[3];
  unsigned int v11 = v4
      + v9
      + 606105819
      + ((v2
        + ((*(_DWORD *)result
          + *(_DWORD *)a2
          - 680876936
          + (v4 & v2 | v3 & ~(_DWORD)v2)) << 7)
        + ((*(_DWORD *)result
          + *(_DWORD *)a2
          - 680876936
          + (v4 & v2 | v3 & ~(_DWORD)v2)) >> 25)) & v8 | v2 & ~v8);
  int v12 = v8 + (v11 << 17) + (v11 >> 15);
  unsigned int v13 = v12
  uint64_t v15 = a2[4];
  uint64_t v14 = a2[5];
  LODWORD(v7) = v15
              + v2
              + ((*(_DWORD *)result
                + *(_DWORD *)a2
                - 680876936
                + (v4 & v2 | v3 & ~(_DWORD)v2)) << 7)
              + ((*(_DWORD *)result
                + *(_DWORD *)a2
                - 680876936
                + (v4 & v2 | v3 & ~(_DWORD)v2)) >> 25)
              - 176418897
              + (v12 & v13 | v8 & ~v13);
  unsigned int v16 = v13 + ((_DWORD)v7 << 7) + (v7 >> 25);
  LODWORD(v7) = v14 + v8 + 1200080426 + (v13 & v16 | v12 & ~v16);
  unsigned int v17 = v16 + ((_DWORD)v7 << 12) + (v7 >> 20);
  uint64_t v18 = a2[6];
  uint64_t v19 = a2[7];
  unsigned int v20 = v17
      + (((_DWORD)v18 + v12 - 1473231341 + (v16 & v17 | v13 & ~v17)) << 17)
      + (((_DWORD)v18 + v12 - 1473231341 + (v16 & v17 | v13 & ~v17)) >> 15);
  unsigned int v21 = v20
      + (((_DWORD)v19 + v13 - 45705983 + (v17 & v20 | v16 & ~v20)) << 22)
      + (((_DWORD)v19 + v13 - 45705983 + (v17 & v20 | v16 & ~v20)) >> 10);
  uint64_t v22 = a2[8];
  uint64_t v23 = a2[9];
  unsigned int v24 = v22 + v16 + 1770035416 + (v20 & v21 | v17 & ~v21);
  int v25 = v21 + (v24 << 7) + (v24 >> 25);
  unsigned int v26 = v25
      + (((_DWORD)v23 + v17 - 1958414417 + (v21 & v25 | v20 & ~v25)) << 12)
      + (((_DWORD)v23 + v17 - 1958414417 + (v21 & v25 | v20 & ~v25)) >> 20);
  uint64_t v28 = a2[10];
  uint64_t v27 = a2[11];
  unsigned int v29 = v26
      + (((_DWORD)v28 + v20 - 42063 + (v25 & v26 | v21 & ~v26)) << 17)
      + (((_DWORD)v28 + v20 - 42063 + (v25 & v26 | v21 & ~v26)) >> 15);
  unsigned int v30 = v29
      + (((_DWORD)v27 + v21 - 1990404162 + (v26 & v29 | v25 & ~v29)) << 22)
      + (((_DWORD)v27 + v21 - 1990404162 + (v26 & v29 | v25 & ~v29)) >> 10);
  uint64_t v32 = a2[12];
  uint64_t v31 = a2[13];
  unsigned int v33 = v32 + v25 + 1804603682 + (v29 & v30 | v26 & ~v30);
  int v34 = v30 + (v33 << 7) + (v33 >> 25);
  unsigned int v35 = v34
      + (((_DWORD)v31 + v26 - 40341101 + (v30 & v34 | v29 & ~v34)) << 12)
      + (((_DWORD)v31 + v26 - 40341101 + (v30 & v34 | v29 & ~v34)) >> 20);
  uint64_t v37 = a2[14];
  uint64_t v36 = a2[15];
  unsigned int v38 = v37 + v29 - 1502002290 + (v34 & v35 | v30 & ~v35);
  int v39 = v35 + (v38 << 17) + (v38 >> 15);
  unsigned int v40 = v36 + v30 + 1236535329 + (v35 & v39 | v34 & ~v39);
  int v41 = v39 + (v40 << 22) + (v40 >> 10);
  unsigned int v42 = v6 + v34 - 165796510 + (v41 & v35 | v39 & ~v35);
  int v43 = v41 + 32 * v42 + (v42 >> 27);
  unsigned int v44 = v18 + v35 - 1069501632 + (v43 & v39 | v41 & ~v39);
  int v45 = v43 + (v44 << 9) + (v44 >> 23);
  unsigned int v46 = v27 + v39 + 643717713 + (v45 & v41 | v43 & ~v41);
  int v47 = v45 + (v46 << 14) + (v46 >> 18);
  unsigned int v48 = v5 + v41 - 373897302 + (v47 & v43 | v45 & ~v43);
  int v49 = v47 + (v48 << 20) + (v48 >> 12);
  unsigned int v50 = v14 + v43 - 701558691 + (v49 & v45 | v47 & ~v45);
  int v51 = v49 + 32 * v50 + (v50 >> 27);
  unsigned int v52 = v28 + v45 + 38016083 + (v51 & v47 | v49 & ~v47);
  int v53 = v51 + (v52 << 9) + (v52 >> 23);
  unsigned int v54 = v36 + v47 - 660478335 + (v53 & v49 | v51 & ~v49);
  int v55 = v53 + (v54 << 14) + (v54 >> 18);
  unsigned int v56 = v15 + v49 - 405537848 + (v55 & v51 | v53 & ~v51);
  int v57 = v55 + (v56 << 20) + (v56 >> 12);
  unsigned int v58 = v23 + v51 + 568446438 + (v57 & v53 | v55 & ~v53);
  int v59 = v57 + 32 * v58 + (v58 >> 27);
  unsigned int v60 = v37 + v53 - 1019803690 + (v59 & v55 | v57 & ~v55);
  int v61 = v59 + (v60 << 9) + (v60 >> 23);
  unsigned int v62 = v10 + v55 - 187363961 + (v61 & v57 | v59 & ~v57);
  int v63 = v61 + (v62 << 14) + (v62 >> 18);
  unsigned int v64 = v22 + v57 + 1163531501 + (v63 & v59 | v61 & ~v59);
  int v65 = v63 + (v64 << 20) + (v64 >> 12);
  unsigned int v66 = v31 + v59 - 1444681467 + (v65 & v61 | v63 & ~v61);
  int v67 = v65 + 32 * v66 + (v66 >> 27);
  unsigned int v68 = v9 + v61 - 51403784 + (v67 & v63 | v65 & ~v63);
  int v69 = v67 + (v68 << 9) + (v68 >> 23);
  unsigned int v70 = v19 + v63 + 1735328473 + (v69 & v65 | v67 & ~v65);
  int v71 = v69 + (v70 << 14) + (v70 >> 18);
  unsigned int v72 = v32 + v65 - 1926607734 + ((v71 ^ v69) & v67 ^ v69);
  int v73 = v71 + (v72 << 20) + (v72 >> 12);
  unsigned int v74 = v14 + v67 - 378558 + (v71 ^ v69 ^ v73);
  int v75 = v73 + 16 * v74 + (v74 >> 28);
  unsigned int v76 = v22 + v69 - 2022574463 + (v73 ^ v71 ^ v75);
  int v77 = v75 + (v76 << 11) + (v76 >> 21);
  int v78 = v27 + v71 + 1839030562 + (v75 ^ v73 ^ v77);
  int v79 = v77 + (v78 << 16) + HIWORD(v78);
  unsigned int v80 = v37 + v73 - 35309556 + (v77 ^ v75 ^ v79);
  int v81 = v79 + (v80 << 23) + (v80 >> 9);
  unsigned int v82 = v6 + v75 - 1530992060 + (v79 ^ v77 ^ v81);
  int v83 = v81 + 16 * v82 + (v82 >> 28);
  unsigned int v84 = v15 + v77 + 1272893353 + (v81 ^ v79 ^ v83);
  int v85 = v83 + (v84 << 11) + (v84 >> 21);
  int v86 = v19 + v79 - 155497632 + (v83 ^ v81 ^ v85);
  int v87 = v85 + (v86 << 16) + HIWORD(v86);
  unsigned int v88 = v28 + v81 - 1094730640 + (v85 ^ v83 ^ v87);
  int v89 = v87 + (v88 << 23) + (v88 >> 9);
  unsigned int v90 = v31 + v83 + 681279174 + (v87 ^ v85 ^ v89);
  int v91 = v89 + 16 * v90 + (v90 >> 28);
  unsigned int v92 = v5 + v85 - 358537222 + (v89 ^ v87 ^ v91);
  int v93 = v91 + (v92 << 11) + (v92 >> 21);
  int v94 = v10 + v87 - 722521979 + (v91 ^ v89 ^ v93);
  int v95 = v93 + (v94 << 16) + HIWORD(v94);
  unsigned int v96 = v18 + v89 + 76029189 + (v93 ^ v91 ^ v95);
  int v97 = v95 + (v96 << 23) + (v96 >> 9);
  unsigned int v98 = v23 + v91 - 640364487 + (v95 ^ v93 ^ v97);
  int v99 = v97 + 16 * v98 + (v98 >> 28);
  unsigned int v100 = v32 + v93 - 421815835 + (v97 ^ v95 ^ v99);
  int v101 = v99 + (v100 << 11) + (v100 >> 21);
  int v102 = v36 + v95 + 530742520 + (v99 ^ v97 ^ v101);
  int v103 = v101 + (v102 << 16) + HIWORD(v102);
  unsigned int v104 = v9 + v97 - 995338651 + (v101 ^ v99 ^ v103);
  int v105 = v103 + (v104 << 23) + (v104 >> 9);
  LODWORD(v5) = v5 + v99 - 198630844 + ((v105 | ~v101) ^ v103);
  LODWORD(v5) = v105 + ((_DWORD)v5 << 6) + (v5 >> 26);
  LODWORD(v19) = v19 + v101 + 1126891415 + ((v5 | ~v103) ^ v105);
  LODWORD(v19) = v5 + ((_DWORD)v19 << 10) + (v19 >> 22);
  LODWORD(v37) = v37 + v103 - 1416354905 + ((v19 | ~v105) ^ v5);
  LODWORD(v37) = v19 + ((_DWORD)v37 << 15) + (v37 >> 17);
  LODWORD(v14) = v14 + v105 - 57434055 + ((v37 | ~(_DWORD)v5) ^ v19);
  LODWORD(v14) = v37 + ((_DWORD)v14 << 21) + (v14 >> 11);
  LODWORD(v5) = v32 + v5 + 1700485571 + ((v14 | ~(_DWORD)v19) ^ v37);
  LODWORD(v5) = v14 + ((_DWORD)v5 << 6) + (v5 >> 26);
  LODWORD(v1__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = v10 + v19 - 1894986606 + ((v5 | ~(_DWORD)v37) ^ v14);
  LODWORD(v1__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = v5 + ((_DWORD)v10 << 10) + (v10 >> 22);
  LODWORD(v28) = v28 + v37 - 1051523 + ((v10 | ~(_DWORD)v14) ^ v5);
  LODWORD(v28) = v10 + ((_DWORD)v28 << 15) + (v28 >> 17);
  LODWORD(v6) = v6 + v14 - 2054922799 + ((v28 | ~(_DWORD)v5) ^ v10);
  LODWORD(v6) = v28 + ((_DWORD)v6 << 21) + (v6 >> 11);
  LODWORD(v5) = v22 + v5 + 1873313359 + ((v6 | ~(_DWORD)v10) ^ v28);
  LODWORD(v5) = v6 + ((_DWORD)v5 << 6) + (v5 >> 26);
  LODWORD(v1__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = v36 + v10 - 30611744 + ((v5 | ~(_DWORD)v28) ^ v6);
  LODWORD(v1__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = v5 + ((_DWORD)v10 << 10) + (v10 >> 22);
  LODWORD(v18) = v18 + v28 - 1560198380 + ((v10 | ~(_DWORD)v6) ^ v5);
  LODWORD(v18) = v10 + ((_DWORD)v18 << 15) + (v18 >> 17);
  LODWORD(v6) = v31 + v6 + 1309151649 + ((v18 | ~(_DWORD)v5) ^ v10);
  LODWORD(v6) = v18 + ((_DWORD)v6 << 21) + (v6 >> 11);
  LODWORD(v15) = v15 + v5 - 145523070 + ((v6 | ~(_DWORD)v10) ^ v18);
  LODWORD(v15) = v6 + ((_DWORD)v15 << 6) + (v15 >> 26);
  LODWORD(v1__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = v27 + v10 - 1120210379 + ((v15 | ~(_DWORD)v18) ^ v6);
  LODWORD(v1__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = v15 + ((_DWORD)v10 << 10) + (v10 >> 22);
  LODWORD(v9) = v9 + v18 + 718787259 + ((v10 | ~(_DWORD)v6) ^ v15);
  LODWORD(v9) = v10 + ((_DWORD)v9 << 15) + (v9 >> 17);
  LODWORD(v6) = v23 + v6 - 343485551 + ((v9 | ~(_DWORD)v15) ^ v10);
  *result += v15;
  result[1] = (_DWORD)v9 + ((_DWORD)v6 << 21) + (v6 >> 11) + v2;
  result[2] = v4 + v9;
  result[3] = v3 + v10;
  return result;
}

void sub_10005BD68(uint64_t a1, uint64_t a2)
{
  __asm { BR              X14 }

void *sub_10005BDBC@<X0>(uint64_t a1@<X8>)
{
  v4[a1] = 128LL;
  int v5 = a1 + 1;
  if (v1 >= 56)
  {
    if (v1 <= 0x3B)
    {
      if (v5 <= 15) {
        int v6 = 15;
      }
      else {
        int v6 = a1 + 1;
      }
      bzero((void *)(v2 + 8 * a1 + 56), 8LL * (v6 + ~(_DWORD)a1) + 8);
    }

    sub_10005B288((void *)v2, v4);
    int v5 = 0;
    goto LABEL_9;
  }

  if (v1 <= 51) {
LABEL_9:
  }
    bzero((void *)(v2 + 8LL * v5 + 48), 8LL * (13 - v5) + 8);
  *(_OWORD *)(v2 + 16__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = *(_OWORD *)(v2 + 32);
  double result = sub_10005B288((void *)v2, v4);
  *uint64_t v3 = *(void *)v2;
  v3[1] = *(void *)(v2 + 8);
  v3[2] = *(void *)(v2 + 16);
  v3[3] = *(void *)(v2 + 24);
  *(_DWORD *)(v2 + 176) = 0;
  return result;
}

uint64_t sub_10005BEA0(uint64_t result, int a2)
{
  if ((_DWORD)result) {
    int v2 = result;
  }
  else {
    int v2 = -2023372141;
  }
  dword_10008BB98 = v2;
  if (a2) {
    int v3 = a2;
  }
  else {
    int v3 = 2218354;
  }
  dword_10008BB9C = v3;
  return result;
}

uint64_t sub_10005BED4(int a1)
{
  HIDWORD(v1) = dword_10008BB98;
  LODWORD(v1) = dword_10008BB98;
  int v2 = (v1 >> 13) ^ __ROR4__(dword_10008BB98, 7);
  int v3 = dword_10008BB9C + (a1 & ~(a1 >> 31));
  dword_10008BB9C = v3 + 1;
  uint64_t result = (v3 + v2);
  dword_10008BB98 = v3 + v2;
  return result;
}

uint64_t sub_10005BF08(char *a1, uint64_t a2)
{
  uint64_t v2 = 0LL;
  if (a1 && (_DWORD)a2)
  {
    if (a2 <= 0x7FF)
    {
      uint64_t v2 = sub_10005C744(a1, a2);
      int v5 = &unk_1000C5000;
      size_t v6 = (a2 - v2);
      if (a2 > v2)
      {
        int v7 = dword_1000C5600;
        if (dword_1000C5600)
        {
          if (dword_1000C5600 > v6)
          {
            memcpy(a1, &unk_1000C55B0, v6);
            dword_1000C5600 = v7 - v6;
            __memcpy_chk(&unk_1000C55B0, (char *)&unk_1000C55B0 + v6, (v7 - v6), 80LL);
            return a2;
          }

          memcpy(a1, &unk_1000C55B0, dword_1000C5600);
          uint64_t v2 = (v7 + v2);
          dword_1000C5600 = 0;
        }
      }

      size_t v8 = (a2 - v2);
      if (a2 > v2)
      {
        uint64_t v9 = (unsigned int *)malloc(0x40uLL);
        if (v9)
        {
          uint64_t v10 = v9;
          *uint64_t v9 = v8;
          v9[1] = 0;
          unsigned int v11 = malloc((v8 + 80));
          *((void *)v10 + 2) = v11;
          *((void *)v10 + 7) = 0LL;
          if (v11)
          {
            bzero(v11, v8);
            *((void *)v10 + 5) = sub_10005C7D8(3, 1439);
            *((void *)v10 + 4) = sub_10005C7D8(7, 479);
            *((void *)v10 + 6) = sub_10005C7D8(5, 719);
            int v12 = sub_10005C7D8(1, 2879);
            *((void *)v10 + 3) = v12;
            if (v12)
            {
              pid_t v13 = getpid();
              if ((_DWORD)v8)
              {
                int v14 = v13;
                unsigned int v15 = 0;
                unsigned int v16 = off_10008B000;
                while (1)
                {
                  HIDWORD(v17) = *((_DWORD *)v16 + 742);
                  LODWORD(v17) = HIDWORD(v17);
                  int v18 = v14 & ~(v14 >> 31);
                  int v19 = dword_10008BB9C + v18;
                  int v20 = dword_10008BB9C + v18 + 1;
                  dword_10008BB9C = v20;
                  unsigned int v21 = v19 + ((v17 >> 13) ^ __ROR4__(HIDWORD(v17), 7));
                  *((_DWORD *)v16 + 742) = v21;
                  switch((v21 >> 9) & 7)
                  {
                    case 0u:
                    case 3u:
                      int v22 = dword_1000C5640;
                      if (dword_1000C5640 == 38) {
                        int v22 = 0;
                      }
                      dword_1000C5640 = v22 + 1;
                      uint64_t v23 = popen(off_100084768[v22], "r");
                      int v24 = fread(__ptr, 1uLL, 0x1000uLL, v23);
                      if (v24 < 1)
                      {
                        LODWORD(v26) = 0;
                      }

                      else
                      {
                        signed int v25 = v24;
                        LODWORD(v26) = 0;
                        do
                        {
                          LODWORD(v26) = v26 + v25;
                          qword_10008CE58 = (uint64_t)&byte_1000C5648[8];
                          gettimeofday((timeval *)&byte_1000C5648[8], byte_1000C5648);
                          sub_10005CAEC(v10, byte_1000C5648, 0x18u);
                          LODWORD(v26) = v26 + 24;
                          signed int v25 = fread(__ptr, 1uLL, 0x1000uLL, v23);
                        }

                        while (v25 > 0);
                      }

                      pclose(v23);
                      goto LABEL_57;
                    case 1u:
                    case 7u:
                      int v27 = dword_1000C5688;
                      if (dword_1000C5688 == 11) {
                        int v27 = 0;
                      }
                      dword_1000C5688 = v27 + 1;
                      LODWORD(v26) = 0;
                      if (stat(off_1000848A0[v27], &v60)) {
                        goto LABEL_57;
                      }
                      gettimeofday(&v59, 0LL);
                      unint64_t v28 = qword_1000C5690;
                      if (qword_1000C5690)
                      {
                        if (dword_1000C5688 != 1) {
                          goto LABEL_55;
                        }
                        unint64_t v28 = qword_1000C5690 + ((unint64_t)(v59.tv_sec - qword_1000C5690) >> 1);
                      }

                      else
                      {
                        unint64_t v28 = v59.tv_sec - 3600;
                      }

                      qword_1000C5690 = v28;
LABEL_55:
                      if (v60.st_atimespec.tv_sec < v28)
                      {
LABEL_56:
                        LODWORD(v26) = 0;
                        goto LABEL_57;
                      }

                      uint64_t v26 = (uint64_t)opendir(off_1000848A0[dword_1000C5688 - 1]);
                      if (!v26) {
                        goto LABEL_57;
                      }
                      __strcpy_chk(__ptr);
                      int v38 = strlen(__ptr);
                      __ptr[v38] = 47;
                      int v39 = readdir((DIR *)v26);
                      int v40 = 0;
                      if (v39)
                      {
                        int v41 = v38 + 1;
                        __int128 __dst = &__ptr[v38 + 1];
                        do
                        {
                          d_name = v39->d_name;
                          unsigned int v43 = strlen(v39->d_name);
                          v40 += v43;
                          memcpy(__dst, d_name, v43);
                          __ptr[v41 + v43] = 0;
                          if (!stat(__ptr, &v60))
                          {
                            qword_1000C5668 += v60.st_size;
                            unk_1000C5670 += v60.st_atimespec.tv_sec;
                            qword_1000C5660 = (uint64_t)vadd_s32((int32x2_t)qword_1000C5660, *(int32x2_t *)&v60.st_uid);
                            v40 += 40;
                            qword_1000C5678 += v60.st_mtimespec.tv_sec;
                            unk_1000C5680 += v60.st_ctimespec.tv_sec;
                          }

                          int v39 = readdir((DIR *)v26);
                        }

                        while (v39);
                      }

                      closedir((DIR *)v26);
                      qword_10008CE58 = (uint64_t)&byte_1000C5648[8];
                      gettimeofday((timeval *)&byte_1000C5648[8], byte_1000C5648);
                      sub_10005CAEC(v10, byte_1000C5648, 0x18u);
                      LODWORD(v26) = v40 + 24;
                      int v5 = (_DWORD *)&unk_1000C5000;
                      goto LABEL_69;
                    case 4u:
                    case 5u:
                      int v29 = sub_10005C744((void *)(*((void *)v10 + 2) + v15), v8 - v15);
                      if (v29 < 1) {
                        goto LABEL_59;
                      }
                      LODWORD(v26) = v29;
                      v10[1] = v15 + v29;
                      goto LABEL_58;
                    case 6u:
                      __darwin_time_t v34 = qword_1000C56A0;
                      if (qword_1000C56A0 && dword_1000C5698 != 14 && *((void *)v10 + 7)) {
                        goto LABEL_39;
                      }
                      if (gettimeofday(&v59, 0LL)) {
                        goto LABEL_56;
                      }
                      __darwin_time_t v34 = qword_1000C56A0;
                      if (!qword_1000C56A0)
                      {
                        __darwin_time_t v34 = v59.tv_sec - 3600;
                        qword_1000C56A0 = v59.tv_sec - 3600;
                      }

uint64_t sub_10005C744(void *a1, unsigned int a2)
{
  if (stat("/dev/random", &v9)) {
    return 0LL;
  }
  if ((v9.st_mode & 0xF000) != 0x2000) {
    return 0LL;
  }
  int v4 = open("/dev/random", 4);
  if (v4 == -1) {
    return 0LL;
  }
  int v5 = v4;
  int v6 = read(v4, a1, a2);
  uint64_t v7 = v6 & ~(v6 >> 31);
  close(v5);
  return v7;
}

timeval *sub_10005C7D8(__darwin_suseconds_t a1, int a2)
{
  uint64_t result = (timeval *)malloc(0x46uLL);
  if (result)
  {
    uint64_t v5 = (uint64_t)result;
    gettimeofday(result, 0LL);
    HIDWORD(v6) = dword_10008BB98;
    LODWORD(v6) = dword_10008BB98;
    int v7 = dword_10008BB9C + *(unsigned __int8 *)(v5 + 15);
    dword_10008BB9C = v7 + 1;
    dword_10008BB98 = v7 + ((v6 >> 13) ^ __ROR4__(dword_10008BB98, 7));
    *(_DWORD *)(v5 + 16) = dword_10008BB98;
    *(_DWORD *)(v5 + 2__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = getpid();
    *(_DWORD *)(v5 + 24) = getppid();
    *(_DWORD *)(v5 + 28) = getuid();
    unsigned int v8 = gethostid();
    HIDWORD(v6) = dword_10008BB98;
    LODWORD(v6) = dword_10008BB98;
    int v9 = dword_10008BB9C + HIBYTE(v8);
    dword_10008BB9C = v9 + 1;
    int v10 = v9 + ((v6 >> 13) ^ __ROR4__(dword_10008BB98, 7));
    dword_10008BB98 = v10;
    *(_DWORD *)(v5 + 32) = v8;
    *(_DWORD *)(v5 + 36) = v10;
    uint64_t v11 = sub_10005A68C(&byte_1000728D2, 157, 0, 0, v5, 70LL);
    free((void *)v5);
    uint64_t result = (timeval *)malloc(0x20uLL);
    if (result)
    {
      int v12 = result;
      result[1].tv_usec = a1;
      *(&result[1].tv_usec + 1) = 0;
      LODWORD(result[1].tv_sec) = 0;
      HIDWORD(result[1].tv_sec) = a2;
      result->tv_sec = v11;
      else {
        return v12;
      }
    }
  }

  return result;
}

size_t sub_10005C908(char *__dst, size_t __n)
{
  uint64_t v2 = 4294967294LL;
  if (__dst && (_DWORD)__n)
  {
    if (qword_1000C5638) {
      BOOL v5 = dword_1000C5630 < 33554433;
    }
    else {
      BOOL v5 = 0;
    }
    if (!v5)
    {
      if (qword_1000C5638) {
        (*(void (**)(void))(*(void *)(qword_1000C5638 + 40) + 32LL))();
      }
      unint64_t v6 = sub_10005C7D8(1, 2879);
      if (!v6) {
        return 0LL;
      }
      qword_1000C5638 = v6->tv_sec;
      dword_1000C5634 = sub_1000599B4(7, qword_1000C5638, 0LL, (uint64_t)dword_1000C5604, 20LL, (uint64_t)&unk_1000C5618);
      if (!dword_1000C5634) {
        return 0xFFFFFFFFLL;
      }
      sub_10005BF08((char *)dword_1000C5604, 20LL);
      dword_1000C5630 = 0;
    }

    int v7 = dword_1000C562C;
    int v8 = dword_1000C5634;
    if (dword_1000C5634 <= dword_1000C562C)
    {
      uint64_t v2 = 0LL;
    }

    else
    {
      uint64_t v2 = (dword_1000C5634 - dword_1000C562C);
      int v9 = (char *)&unk_1000C5618 + dword_1000C562C;
      if (v2 >= __n)
      {
        memcpy(__dst, v9, __n);
        dword_1000C562C = v7 + __n;
        return __n;
      }

      memcpy(__dst, v9, (dword_1000C5634 - dword_1000C562C));
      dword_1000C562C = v8;
    }

    for (; v2 < __n; uint64_t v2 = v11 + v2)
    {
      for (uint64_t i = 0LL; i != 5; ++i)
        ++dword_1000C5604[i];
      unsigned int v11 = sub_1000599B4( 7,  qword_1000C5638,  0LL,  (uint64_t)dword_1000C5604,  dword_1000C5634,  (uint64_t)&unk_1000C5618);
      ++dword_1000C5630;
      if ((int)__n - (int)v2 < v11)
      {
        dword_1000C562C = __n - v2;
        unsigned int v11 = __n - v2;
      }

      memcpy(&__dst[v2], &unk_1000C5618, v11);
    }
  }

  return v2;
}

uint64_t sub_10005CAEC(_DWORD *a1, _BYTE *a2, unsigned int a3)
{
  unint64_t v6 = 0LL;
  dword_1000C5644 += a3;
  do
  {
    int v7 = &a1[2 * v6];
    int v8 = sub_10005CBB0(a1, *((void *)v7 + 3), a2, a3);
    uint64_t v9 = sub_10005CBB0(a1, *((void *)v7 + 3), &dword_1000C5644, 4u) + v8;
    if (v6 > 2) {
      break;
    }
    ++v6;
  }

  while (!(_DWORD)v9);
  if ((_DWORD)v9)
  {
    uint64_t v10 = 3LL;
    do
    {
      sub_10005CD48((uint64_t)a1, *(void *)&a1[2 * v10]);
      unint64_t v11 = v10 - 3;
      ++v10;
    }

    while (v11 < 3);
  }

  return v9;
}

uint64_t sub_10005CBB0(_DWORD *a1, uint64_t a2, _BYTE *a3, unsigned int a4)
{
  uint64_t v4 = 0LL;
  if (!a3) {
    return v4;
  }
  unsigned int v5 = a4;
  if (!a4) {
    return v4;
  }
  unint64_t v6 = a3;
  uint64_t v9 = *(unsigned int *)(a2 + 24);
  if ((int)v9 < 2)
  {
    unsigned int v10 = 0;
    int v12 = 0LL;
    goto LABEL_10;
  }

  unsigned int v10 = a4 / v9 + 2;
  unint64_t v11 = malloc(v10);
  int v12 = v11;
  uint64_t v13 = *(int *)(a2 + 28);
  if (v13 >= v5)
  {
    *(_DWORD *)(a2 + 28) = (v9 + v5 - v13) % v9;
    goto LABEL_22;
  }

  uint64_t v14 = 0LL;
  uint64_t v15 = 0LL;
  uint64_t v16 = *(int *)(a2 + 28);
  do
  {
    *((_BYTE *)v11 + v14) = v6[v13 + v15];
    v16 += v9;
    v15 += v9;
    ++v14;
  }

  while (v16 < v5);
  *(_DWORD *)(a2 + 28) = (v9 + v5 - v13 - v15) % v9;
  if (!(_DWORD)v14)
  {
LABEL_22:
    uint64_t v4 = 0LL;
    if (!v12) {
      return v4;
    }
    goto LABEL_23;
  }

  unsigned int v5 = v14;
  unint64_t v6 = v11;
LABEL_10:
  unsigned int v17 = 0;
  while (1)
  {
    unsigned int v18 = *(_DWORD *)(a2 + 20) - *(_DWORD *)(a2 + 16);
    if (v5 - v17 >= v18) {
      uint64_t v19 = v18;
    }
    else {
      uint64_t v19 = v5 - v17;
    }
    sub_1000599B4(2, *(void *)a2, a2 + 8, (uint64_t)&v6[v17], v19, 0LL);
    int v20 = *(_DWORD *)(a2 + 20);
    int v21 = *(_DWORD *)(a2 + 16) + v19;
    *(_DWORD *)(a2 + 16) = v21;
    if (v21 >= v20) {
      sub_10005CD48((uint64_t)a1, a2);
    }
    if (*a1 < a1[1]) {
      break;
    }
    v17 += v18;
    if (v17 >= v5) {
      goto LABEL_22;
    }
  }

  uint64_t v4 = 1LL;
  if (v12)
  {
LABEL_23:
    if (v10)
    {
      bzero(v12, v10);
      free(v12);
    }
  }

  return v4;
}

uint64_t sub_10005CD48(uint64_t result, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 20) < 2 * *(_DWORD *)(a2 + 16))
  {
    uint64_t v3 = result;
    int v4 = sub_1000599B4(4, *(void *)a2, a2 + 8, 0LL, 0LL, *(void *)(result + 16) + *(unsigned int *)(result + 4));
    *(_DWORD *)(a2 + 16) = 0;
    uint64_t result = sub_1000599B4(1, *(void *)a2, a2 + 8, 0LL, 0LL, 0LL);
    if (v4 >= 1) {
      *(_DWORD *)(v3 + 4) += v4;
    }
  }

  return result;
}

void *sub_10005CDE4(size_t __size)
{
  size_t v1 = __size;
  uint64_t v2 = malloc(__size);
  uint64_t v3 = v2;
  if (v2) {
    bzero(v2, v1);
  }
  return v3;
}

void sub_10005CE20( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1) {
    free(a1);
  }
  else {
    sub_10006221C("dfree %s(%d): free on null pointer.", a2, a3, a4, a5, a6, a7, a8, a2);
  }
}

uint64_t sub_10005CE50(void **a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unsigned int v10 = (unsigned int (*)(void **, uint64_t, uint64_t))a2[11];
  if (v10 && (unsigned int v17 = 0LL, v10(&v17, a4, a5) != 1))
  {
    size_t v12 = a2[13];
    uint64_t v13 = v17;
  }

  else
  {
    unint64_t v11 = (unsigned int (*)(uint64_t))a2[12];
    if (v11) {
      size_t v12 = v11(a3);
    }
    else {
      size_t v12 = a2[13];
    }
    if (v12 < 0x20) {
      return 39LL;
    }
    uint64_t v13 = sub_10005CDE4(v12);
    unsigned int v17 = v13;
    if (!v13) {
      return 1LL;
    }
  }

  bzero(v13, v12);
  *uint64_t v13 = a2;
  uint64_t v15 = (void (*)(void *, uint64_t, uint64_t))a2[15];
  if (v15) {
    v15(v13, a4, a5);
  }
  uint64_t result = 39LL;
  if (a1)
  {
    uint64_t v16 = v17;
    if (v17)
    {
      if (!*a1)
      {
        uint64_t result = 0LL;
        *a1 = v17;
        ++v16[2];
      }
    }
  }

  return result;
}

uint64_t sub_10005CF60(void *a1, uint64_t a2, int a3, size_t a4, uint64_t a5, uint64_t a6)
{
  *a1 = a2;
  unsigned int v10 = *(void (**)(void *, uint64_t, uint64_t))(a2 + 120);
  if (v10) {
    v10(a1, a5, a6);
  }
  return 0LL;
}

uint64_t sub_10005CFB8(void *a1, uint64_t a2)
{
  uint64_t result = 39LL;
  if (a1 && a2 && !*a1)
  {
    uint64_t result = 0LL;
    *a1 = a2;
    ++*(_DWORD *)(a2 + 8);
  }

  return result;
}

uint64_t sub_10005CFEC(_DWORD **a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    return 39LL;
  }
  int v4 = *a1;
  if (!*a1) {
    return 39LL;
  }
  int v5 = v4[2];
  int v6 = v5 - 1;
  if (v5 >= 1)
  {
    uint64_t v9 = *((void *)v4 + 3);
    int v10 = 1;
    if (v9)
    {
      BOOL v11 = v9 + 16 != (void)a1 && *(void *)(v9 + 16) != 0LL;
      if (v9 + 16 != (void)a1 && *(void *)(v9 + 16) != 0LL) {
        int v10 = 2;
      }
      else {
        int v10 = 1;
      }
    }

    else
    {
      BOOL v11 = 0;
    }

    uint64_t v13 = *((void *)v4 + 2);
    if (v13) {
      BOOL v15 = (_DWORD **)(v13 + 24) != a1 && *(void *)(v13 + 24) != 0LL;
    }
    else {
      BOOL v15 = 0;
    }
    int v16 = v4[3];
    int v17 = v10 + v15;
    if (v16) {
      ++v17;
    }
    if (v5 != v17) {
      goto LABEL_43;
    }
    if (!v11 && !v15 && !v16)
    {
LABEL_44:
      *a1 = 0LL;
      v4[2] = v6;
      if (v11)
      {
        sub_10005CFEC(v4 + 6, a2, a3);
        if (!v15) {
          goto LABEL_46;
        }
      }

      else if (!v15)
      {
LABEL_46:
        if (!v16) {
          goto LABEL_52;
        }
        goto LABEL_50;
      }

      sub_10005CFEC(v4 + 4, a2, a3);
      if (!v16)
      {
LABEL_52:
        uint64_t v32 = *(void *)v4;
        uint64_t v33 = *(void (**)(_DWORD *, uint64_t, uint64_t))(*(void *)v4 + 32LL);
        if (v33)
        {
          v33(v4, a2, a3);
          uint64_t v32 = *(void *)v4;
        }

        __darwin_time_t v34 = *(void (**)(_DWORD *, uint64_t, uint64_t))(v32 + 80);
        if (v34) {
          v34(v4, a2, a3);
        }
        else {
          free(v4);
        }
        uint64_t result = 0LL;
        goto LABEL_58;
      }

LABEL_50:
      goto LABEL_52;
    }

    if (v9)
    {
      do
      {
        int v18 = *(_DWORD *)(v9 + 8);
        uint64_t v19 = *(void *)(v9 + 24);
        if (v19) {
          v18 -= *(void *)(v19 + 16) == v9;
        }
        int v20 = v18 - (*(void *)(v9 + 16) != 0LL) - (*(_DWORD *)(v9 + 12) != 0);
        if (v19) {
          BOOL v21 = v20 == 0;
        }
        else {
          BOOL v21 = 0;
        }
        uint64_t v9 = *(void *)(v9 + 24);
      }

      while (v21);
      if (!v13)
      {
LABEL_42:
        if (v20)
        {
LABEL_43:
          uint64_t result = 0LL;
          v4[2] = v6;
          goto LABEL_58;
        }

        goto LABEL_44;
      }
    }

    else
    {
      int v20 = 0;
      if (!v13) {
        goto LABEL_42;
      }
    }

    if (!v20)
    {
      do
      {
        int v22 = *(_DWORD *)(v13 + 8);
        uint64_t v23 = *(void *)(v13 + 16);
        if (v23) {
          v22 -= *(void *)(v23 + 24) == v13;
        }
        int v20 = v22 - (*(void *)(v13 + 24) != 0LL) - (*(_DWORD *)(v13 + 12) != 0);
        if (v23) {
          BOOL v24 = v20 == 0;
        }
        else {
          BOOL v24 = 0;
        }
        uint64_t v13 = *(void *)(v13 + 16);
      }

      while (v24);
    }

    goto LABEL_42;
  }

  uint64_t result = 39LL;
LABEL_58:
  *a1 = 0LL;
  return result;
}

uint64_t sub_10005D23C(void **a1)
{
  uint64_t v2 = sub_10005CDE4(0xFE0uLL);
  if (!v2) {
    return 1LL;
  }
  uint64_t v3 = v2;
  bzero(v2, 0xFE0uLL);
  if (a1 && !*a1)
  {
    uint64_t result = 0LL;
    *a1 = v3;
    ++*((_DWORD *)v3 + 2);
  }

  else
  {
    free(v3);
    uint64_t v3 = *a1;
    uint64_t result = 39LL;
  }

  *((_WORD *)v3 + 6) = 4047;
  return result;
}

uint64_t sub_10005D2B4(void *a1, uint64_t a2)
{
  uint64_t result = 39LL;
  if (a1 && a2 && !*a1)
  {
    uint64_t result = 0LL;
    *a1 = a2;
    ++*(_DWORD *)(a2 + 8);
  }

  return result;
}

uint64_t sub_10005D2E8(_DWORD **a1)
{
  if (!a1) {
    return 39LL;
  }
  uint64_t v2 = *a1;
  if (!v2) {
    return 39LL;
  }
  int v3 = v2[2];
  if (v3)
  {
    int v4 = v3 - 1;
    v2[2] = v4;
    if (!v4) {
      free(v2);
    }
    uint64_t result = 0LL;
  }

  else
  {
    uint64_t result = 39LL;
  }

  *a1 = 0LL;
  return result;
}

uint64_t sub_10005D348( uint64_t a1, uint64_t a2, void *a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const char *a9)
{
  switch(a4)
  {
    case 0:
      BOOL v11 = 0LL;
      size_t v12 = 0LL;
      unsigned int v13 = 0;
      int v14 = (int)a9;
      size_t v15 = 12LL;
      goto LABEL_9;
    case 1:
      BOOL v11 = a9;
      unsigned int v13 = strlen(a9);
      if (v13 >= 0xFFFFFFF4) {
        return 39LL;
      }
      goto LABEL_7;
    case 2:
      unsigned int v13 = a9;
      BOOL v11 = 0LL;
LABEL_7:
      size_t v12 = 0LL;
      int v14 = 0;
      size_t v15 = v13 + 12;
LABEL_9:
      int v16 = sub_10005CDE4(v15);
      if (!v16) {
        return 1LL;
      }
      int v17 = v16;
      bzero(v16, v15);
      switch(a4)
      {
        case 0:
          v17[2] = v14;
          goto LABEL_15;
        case 1:
          memcpy(v17 + 3, v11, v13);
          goto LABEL_14;
        case 2:
LABEL_14:
          v17[2] = v13;
          goto LABEL_15;
        case 3:
          if (v12 && !*((void *)v17 + 1))
          {
            *((void *)v17 + 1) = v12;
            ++*((_DWORD *)v12 + 2);
LABEL_15:
            v17[1] = a4;
            if (a3 && !*a3)
            {
              uint64_t result = 0LL;
              *a3 = v17;
              ++*v17;
              return result;
            }
          }

          else
          {
            free(v17);
          }

          break;
        default:
          goto LABEL_15;
      }

      return 39LL;
    case 3:
      BOOL v11 = 0LL;
      int v14 = 0;
      unsigned int v13 = 0;
      size_t v12 = a9;
      size_t v15 = 16LL;
      goto LABEL_9;
    default:
      return 39LL;
  }

uint64_t sub_10005D504(void *a1, _DWORD *a2)
{
  uint64_t result = 39LL;
  if (a1 && a2 && !*a1)
  {
    uint64_t result = 0LL;
    *a1 = a2;
    ++*a2;
  }

  return result;
}

uint64_t sub_10005D538(int **a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    return 39LL;
  }
  int v4 = *a1;
  if (!v4) {
    return 39LL;
  }
  BOOL v5 = *v4 == 1;
  if (*v4 < 1)
  {
    uint64_t result = 39LL;
  }

  else
  {
    --*v4;
    if (v5)
    {
      if (v4[1] == 3 && (v6 = a2, sub_10005CFEC((_DWORD **)v4 + 1, a2, a3), (int v4 = *a1) == 0LL)) {
        sub_10006221C("dfree %s(%d): free on null pointer.", v7, v8, v9, v10, v11, v12, v13, v6);
      }
      else {
        free(v4);
      }
    }

    uint64_t result = 0LL;
  }

  *a1 = 0LL;
  return result;
}

uint64_t sub_10005D5E0(void *a1, unsigned int a2)
{
  if (a2 > 0xFFFFFFF7) {
    return 39LL;
  }
  BOOL v5 = sub_10005CDE4(a2 + 8);
  if (!v5) {
    return 1LL;
  }
  char v6 = v5;
  *(void *)BOOL v5 = 0LL;
  v5[1] = a2;
  if (!a1 || *a1) {
    return 39LL;
  }
  uint64_t result = 0LL;
  *a1 = v6;
  ++*v6;
  return result;
}

uint64_t sub_10005D658(int **a1)
{
  if (!a1) {
    return 39LL;
  }
  uint64_t v2 = *a1;
  if (!v2) {
    return 39LL;
  }
  BOOL v3 = *v2 == 1;
  if (*v2 < 1)
  {
    uint64_t result = 39LL;
  }

  else
  {
    --*v2;
    if (v3) {
      free(v2);
    }
    uint64_t result = 0LL;
  }

  *a1 = 0LL;
  return result;
}

uint64_t sub_10005D6B8(void *a1)
{
  uint64_t v2 = sub_10005CDE4(0x18uLL);
  if (!v2) {
    return 1LL;
  }
  BOOL v3 = v2;
  *uint64_t v2 = 0LL;
  v2[1] = 0LL;
  v2[2] = 0LL;
  if (!a1 || *a1) {
    return 39LL;
  }
  uint64_t result = 0LL;
  *a1 = v3;
  ++*v3;
  return result;
}

uint64_t sub_10005D71C(int ***a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    return 39LL;
  }
  int v4 = *a1;
  if (!*a1) {
    return 39LL;
  }
  BOOL v5 = *(_DWORD *)v4 == 1;
  if (*(int *)v4 < 1)
  {
    uint64_t result = 39LL;
  }

  else
  {
    --*(_DWORD *)v4;
    if (v5)
    {
      uint64_t v8 = v4[1];
      if (v8)
      {
        BOOL v9 = *v8 == 1;
        if (*v8 >= 1)
        {
          --*v8;
          if (v9) {
            free(v8);
          }
        }

        v4[1] = 0LL;
        int v4 = *a1;
      }

      if (v4[2] && (sub_10005D538(v4 + 2, a2, a3), (int v4 = *a1) == 0LL)) {
        sub_10006221C("dfree %s(%d): free on null pointer.", v10, v11, v12, v13, v14, v15, v16, a2);
      }
      else {
        free(v4);
      }
    }

    uint64_t result = 0LL;
  }

  *a1 = 0LL;
  return result;
}

uint64_t sub_10005D7F4(void *a1, unsigned int a2)
{
  size_t v4 = 28LL * a2 + 16;
  BOOL v5 = sub_10005CDE4(v4);
  if (!v5) {
    return 1LL;
  }
  char v6 = v5;
  bzero(v5, v4);
  v6[1] = a2;
  *((void *)v6 + 1) = v6 + 4;
  if (!a1 || *a1) {
    return 39LL;
  }
  uint64_t result = 0LL;
  *a1 = v6;
  ++*v6;
  return result;
}

uint64_t sub_10005D87C(void *a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    return 39LL;
  }
  if (*a1) {
    return 39LL;
  }
  uint64_t v7 = sub_10005CDE4(0x20uLL);
  if (!v7) {
    return 1LL;
  }
  uint64_t v8 = v7;
  uint64_t result = 0LL;
  *a1 = v8;
  v8[1] = a2;
  v8[2] = a3;
  return result;
}

uint64_t sub_10005D8F0( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 39LL;
  }
  uint64_t v9 = *a1;
  if (!*a1) {
    return 39LL;
  }
  int v10 = *(_DWORD *)(v9 + 24);
  if (v10 >= 1)
  {
    uint64_t v11 = 0LL;
    for (uint64_t i = 0LL; i < v10; ++i)
    {
      if (*(void *)(*(void *)v9 + v11))
      {
        uint64_t v13 = *(void (**)(void))(v9 + 16);
        if (v13)
        {
          v13();
          int v10 = *(_DWORD *)(v9 + 24);
        }
      }

      v11 += 8LL;
    }
  }

  sub_10005CE20( *(void **)v9,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/array.c",  71LL,  a4,  a5,  a6,  a7,  a8);
  sub_10005CE20( (void *)v9,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/array.c",  72LL,  v14,  v15,  v16,  v17,  v18);
  uint64_t result = 0LL;
  *a1 = 0LL;
  return result;
}

uint64_t sub_10005D9BC(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5)
{
  unsigned int v6 = *(_DWORD *)(a1 + 24);
  uint64_t result = sub_10005D9F0(a1, a2, v6, a4, a5);
  if (a3)
  {
    if (!(_DWORD)result) {
      *a3 = v6;
    }
  }

  return result;
}

uint64_t sub_10005D9F0(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  uint64_t result = 39LL;
  if (a1 && a2 && (a3 & 0x80000000) == 0)
  {
    int v11 = *(_DWORD *)(a1 + 28);
    int v12 = a3 - v11;
    if ((int)a3 >= v11)
    {
      uint64_t v15 = (char *)sub_10005CDE4(8 * a3 + 80);
      if (!v15) {
        return 1LL;
      }
      uint64_t v13 = v15;
      int v16 = v12 + 10;
      bzero(&v15[8 * *(int *)(a1 + 28)], 8LL * v16);
      *(_DWORD *)(a1 + 28) += v16;
      if (*(void *)a1)
      {
        memcpy(v13, *(const void **)a1, 8LL * *(int *)(a1 + 24));
        sub_10005CE20(*(void **)a1, a4, a5, v17, v18, v19, v20, v21);
      }

      *(void *)a1 = v13;
      uint64_t v14 = a3;
    }

    else
    {
      uint64_t v13 = *(void **)a1;
      uint64_t v14 = a3;
      if (*(void *)(*(void *)a1 + 8LL * a3))
      {
        uint64_t result = (*(uint64_t (**)(void))(a1 + 16))();
        if ((_DWORD)result) {
          return result;
        }
        uint64_t v13 = *(void **)a1;
      }
    }

    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 8))( (uint64_t)v13 + 8 * v14,  a2,  a4,  a5);
    if (!(_DWORD)result)
    {
      uint64_t result = 0LL;
    }
  }

  return result;
}

uint64_t sub_10005DB30(void *a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  uint64_t result = 39LL;
  if (a1 && a2 && (a3 & 0x80000000) == 0 && !*a1 && *(_DWORD *)(a2 + 24) > (signed int)a3)
  {
    if (*(void *)(*(void *)a2 + 8LL * a3)) {
      return (*(uint64_t (**)(void *, void, uint64_t, uint64_t))(a2 + 8))( a1,  *(void *)(*(void *)a2 + 8LL * a3),  a4,  a5);
    }
    else {
      return 23LL;
    }
  }

  return result;
}

uint64_t sub_10005DB84(void **a1, uint64_t a2, uint64_t a3)
{
  return sub_10005CE50(a1, (void *)qword_10008CF00, 0LL, a2, a3);
}

uint64_t sub_10005DBA8( uint64_t *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_100063100(a1, (uint64_t)sub_10005DBA0, (uint64_t)sub_10005DBA4, a2, sub_1000631AC, a3, a4, a8);
}

uint64_t sub_10005DBD0( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)a1 != qword_10008CF00) {
    return 39LL;
  }
  if (qword_10008CE60) {
    sub_100063620( qword_10008CE60,  *(const char **)(a1 + 32),  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/auth.c",  65LL,  a6,  a7,  a8);
  }
  int v10 = *(void **)(a1 + 32);
  if (v10) {
    sub_10005CE20(v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/auth.c", 68LL, a4, a5, a6, a7, a8);
  }
  int v11 = *(void **)(a1 + 40);
  if (v11) {
    sub_10005CE20(v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/auth.c", 70LL, a4, a5, a6, a7, a8);
  }
  uint64_t v13 = *(void *)(a1 + 48);
  int v12 = (int **)(a1 + 48);
  if (v13) {
    sub_10005D658(v12);
  }
  return 0LL;
}

uint64_t sub_10005DC80( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)a1 != qword_10008CF00) {
    return 39LL;
  }
  uint64_t v14 = 0LL;
  if (qword_10008CE60)
  {
    sub_100063738( &v14,  (uint64_t (**)(unsigned __int8 *, int, unsigned int))qword_10008CE60,  *(const char **)(a1 + 32),  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/auth.c",  87LL,  a7,  a8);
    if (v14 == (const char **)a1)
    {
      sub_10005CFEC((_DWORD **)&v14, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/auth.c", 89LL);
      return 0LL;
    }

    if (v14)
    {
      sub_100063620( qword_10008CE60,  v14[4],  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/auth.c",  94LL,  v10,  v11,  v12);
      sub_10005CFEC((_DWORD **)&v14, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/auth.c", 95LL);
    }
  }

  else if (!sub_100063100( &qword_10008CE60,  (uint64_t)sub_10005DBA0,  (uint64_t)sub_10005DBA4,  0x3F1u,  sub_1000631AC,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/auth.c",  99LL,  a8))
  {
    return 1LL;
  }

  sub_1000634B8( qword_10008CE60,  *(const char **)(a1 + 32),  0LL,  a1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/auth.c",  102LL,  v11,  v12,  v13);
  return 0LL;
}

uint64_t sub_10005DDB8( void *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = 23LL;
  if (qword_10008CE60)
  {
    if (sub_100063738( a1,  (uint64_t (**)(unsigned __int8 *, int, unsigned int))qword_10008CE60,  a2,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/auth.c",  112LL,  a7,  a8)) {
      return 0LL;
    }
    else {
      return 23LL;
    }
  }

  return v8;
}

uint64_t sub_10005DE04(_DWORD **a1, int a2, uint64_t a3)
{
  char v13 = 0LL;
  uint64_t v14 = 0LL;
  if (!qword_10008CE60) {
    return 23LL;
  }
  if (!a3) {
    return 46LL;
  }
  uint64_t v6 = sub_1000683F8(a3, a2, "name");
  if (!(_DWORD)v6)
  {
    if ((v14[2][1] - 1) >= 2)
    {
      uint64_t v10 = &v14;
      uint64_t v11 = 137LL;
    }

    else
    {
      uint64_t v7 = sub_1000683F8(a3, a2, "algorithm");
      if ((_DWORD)v7)
      {
        uint64_t v6 = v7;
        sub_10005D71C(&v14, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/auth.c", 143LL);
        return v6;
      }

      if ((v13[2][1] - 1) >= 2)
      {
        sub_10005D71C(&v14, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/auth.c", 149LL);
        uint64_t v10 = &v13;
        uint64_t v11 = 150LL;
      }

      else
      {
        if (sub_100063738( a1,  (uint64_t (**)(unsigned __int8 *, int, unsigned int))qword_10008CE60,  (const char *)v14[2] + 12,  v14[2][2],  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/auth.c",  158LL,  v8,  v9))
        {
          if (!sub_10006870C((uint64_t)v13[2], *((char **)*a1 + 5)))
          {
            sub_10005D71C(&v14, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/auth.c", 172LL);
            sub_10005D71C(&v13, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/auth.c", 173LL);
            return 0LL;
          }

          sub_10005D71C(&v14, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/auth.c", 166LL);
          sub_10005D71C(&v13, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/auth.c", 167LL);
          sub_10005CFEC(a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/auth.c", 168LL);
          return 23LL;
        }

        sub_10005D71C(&v14, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/auth.c", 159LL);
        uint64_t v10 = &v13;
        uint64_t v11 = 160LL;
      }
    }

    sub_10005D71C(v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/auth.c", v11);
    return 23LL;
  }

  return v6;
}

uint64_t sub_10005DFFC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)a3 != qword_10008CF00) {
    return 39LL;
  }
  if (!*(void *)(a3 + 32)
    || (uint64_t result = sub_10005F114(a1, "name"), !(_DWORD)result)
    && (uint64_t result = sub_10005F180(a1, *(char **)(a3 + 32)), !(_DWORD)result))
  {
    if (!*(void *)(a3 + 40)) {
      return 0LL;
    }
    uint64_t result = sub_10005F114(a1, "algorithm");
    if (!(_DWORD)result)
    {
      uint64_t result = sub_10005F180(a1, *(char **)(a3 + 40));
      if (!(_DWORD)result) {
        return 0LL;
      }
    }
  }

  return result;
}

uint64_t sub_10005E098(void *a1, int a2, _DWORD *a3, int ***a4)
{
  if (*a1 != qword_10008CF00) {
    return 34LL;
  }
  if (sub_100068648((uint64_t)a3, "name"))
  {
    if (sub_100068648((uint64_t)a3, "key"))
    {
      uint64_t v9 = (const char *)a1[5];
      if (v9)
      {
        uint64_t v10 = a4;
        uint64_t v11 = a3;
        uint64_t v12 = 257LL;
        return sub_100068B64(v10, v11, v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/auth.c", v12);
      }
    }

    else if (a1[6])
    {
      uint64_t v4 = sub_10005D6B8(a4);
      if (!(_DWORD)v4)
      {
        uint64_t v13 = sub_10005D504(*a4 + 1, a3);
        if ((_DWORD)v13)
        {
          uint64_t v4 = v13;
          uint64_t v18 = a4;
          uint64_t v19 = 237LL;
        }

        else
        {
          uint64_t v4 = sub_10005D348( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/auth.c",  241LL,  *a4 + 2,  2,  v14,  v15,  v16,  v17,  (const char *)*(unsigned int *)(a1[6] + 4LL));
          if (!(_DWORD)v4)
          {
            memcpy((*a4)[2] + 3, (const void *)(a1[6] + 8LL), *(unsigned int *)(a1[6] + 4LL));
            return v4;
          }

          uint64_t v18 = a4;
          uint64_t v19 = 245LL;
        }

        sub_10005D71C(v18, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/auth.c", v19);
      }

      return v4;
    }

    return 23LL;
  }

  uint64_t v9 = (const char *)a1[4];
  if (!v9) {
    return 23LL;
  }
  uint64_t v10 = a4;
  uint64_t v11 = a3;
  uint64_t v12 = 225LL;
  return sub_100068B64(v10, v11, v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/auth.c", v12);
}

void *sub_10005E24C()
{
  qword_1000C56A8 = (uint64_t)sub_100068E0C( "connection-input",  0LL,  (uint64_t)sub_10005E2CC,  (uint64_t)nullsub_11,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/buffer.c",  59LL);
  uint64_t result = sub_100068E0C( "connection-output",  0LL,  (uint64_t)nullsub_12,  (uint64_t)nullsub_13,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/buffer.c",  64LL);
  qword_1000C56B0 = (uint64_t)result;
  return result;
}

uint64_t sub_10005E2CC( uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = a2;
  uint64_t v33 = 0LL;
  __darwin_time_t v34 = 0LL;
  unsigned int v10 = *a3;
  uint64_t v11 = qword_10008CE68;
  if (qword_10008CE68)
  {
    uint64_t v12 = 0LL;
    while (v12 < *(int *)(v11 + 24))
    {
      a2 = *(void *)(*(void *)v11 + 8 * v12);
      if (a2)
      {
        (*(void (**)(_DWORD **, uint64_t, const char *, uint64_t))(v11 + 8))( &v33,  a2,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/buffer.c",  80LL);
        if (v33[9] == v10)
        {
          sub_10005F290(&v34, (uint64_t)v33);
          sub_10005F294(&v33, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/buffer.c", 83LL);
          break;
        }

        (*(void (**)(_DWORD **, const char *, uint64_t))(qword_10008CE68 + 16))( &v33,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/buffer.c",  87LL);
        uint64_t v11 = qword_10008CE68;
      }

      ++v12;
      if (!v11) {
        break;
      }
    }
  }

  if (!v34) {
    return sub_10006221C( "trace connection input: no connection index %ld",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  bswap32(v10));
  }
  unsigned int v13 = v9 - 4;
  if (v13)
  {
    int v14 = 0;
    uint64_t v15 = (char *)(a3 + 1);
    while (1)
    {
      while (1)
      {
        LODWORD(v33) = 0;
        unsigned int v16 = sub_10005E488((uint64_t)v34, v13, v15, &v33);
        if (v16)
        {
          char v32 = sub_100067900(v16);
          sub_10006221C("trace connection input: %s", v25, v26, v27, v28, v29, v30, v31, v32);
          return sub_10005F294(&v34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/buffer.c", 119LL);
        }

        if (!(_DWORD)v33) {
          break;
        }
        int v14 = 0;
        v13 -= v33;
        if (!v13) {
          return sub_10005F294(&v34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/buffer.c", 119LL);
        }
      }

      if (v14) {
        break;
      }
      int v14 = 1;
    }

    sub_10006221C("trace connection_input: %s", v17, v18, v19, v20, v21, v22, v23, (char)"input is not being consumed.");
  }

  return sub_10005F294(&v34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/buffer.c", 119LL);
}

uint64_t sub_10005E478(uint64_t a1)
{
  return sub_10005E488(a1, 0, 0LL, 0LL);
}

uint64_t sub_10005E488(uint64_t a1, unsigned int a2, char *a3, _DWORD *a4)
{
  if (!a1 || *(void *)a1 != qword_10008CF08) {
    return 39LL;
  }
  unsigned int v9 = *(_DWORD *)(a1 + 96);
  if (v9 >= 0xFCF && v9 > *(_DWORD *)(a1 + 92)) {
    return 0LL;
  }
  uint64_t v11 = (void **)(a1 + 104);
  unsigned int v10 = *(void ***)(a1 + 104);
  if (v10)
  {
    do
    {
      uint64_t v11 = v10;
      unsigned int v10 = (void **)*v10;
    }

    while (v10);
    uint64_t v12 = *((unsigned __int16 *)v11 + 7);
    uint64_t v13 = *((unsigned __int16 *)v11 + 6);
    if (v12 <= v13)
    {
      if ((_DWORD)v13 != (_DWORD)v12) {
        goto LABEL_17;
      }
    }

    else if (v13 - v12 != -4048)
    {
      goto LABEL_17;
    }

    int v14 = v11;
  }

  else
  {
    int v14 = (void **)(a1 + 104);
  }

  uint64_t result = sub_10005D23C(v14);
  if ((_DWORD)result) {
    return result;
  }
  uint64_t v11 = (void **)*v11;
LABEL_17:
  unsigned int v15 = *((unsigned __int16 *)v11 + 7);
  unsigned int v16 = *((unsigned __int16 *)v11 + 6);
  BOOL v17 = v16 >= v15;
  unsigned int v18 = v16 - v15;
  if (v17) {
    unsigned int v19 = v18;
  }
  else {
    unsigned int v19 = v18 + 4048;
  }
  if (!v19)
  {
LABEL_46:
    if (*(_DWORD *)(a1 + 92) <= *(_DWORD *)(a1 + 96)) {
      sub_100067DAC(a1);
    }
    return 0LL;
  }

  while (1)
  {
    unsigned int v20 = *((unsigned __int16 *)v11 + 6);
    size_t v21 = v20 - (unsigned __int16)v15;
    unsigned int v22 = read(*(_DWORD *)(a1 + 32), (char *)v11 + *((unsigned __int16 *)v11 + 7) + 16, v21);
    if ((v22 & 0x80000000) != 0) {
      goto LABEL_45;
    }
LABEL_33:
    if (!v22)
    {
      uint64_t v37 = a1;
      int v38 = 0;
LABEL_50:
      sub_100060130(v37, v38);
      return 22LL;
    }

    if (sub_100068D58())
    {
      unsigned int v39 = bswap32(*(_DWORD *)(a1 + 36));
      int v40 = &v39;
      int v41 = 4;
      uint64_t v42 = (uint64_t)v11 + *((unsigned __int16 *)v11 + 7) + 16;
      unsigned int v43 = v22;
      unsigned int v26 = sub_1000693DC( qword_1000C56A8,  2LL,  (uint64_t)&v40,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/buffer.c",  247LL,  v23,  v24,  v25);
      if (v26)
      {
        unsigned int v27 = v26;
        sub_100069268();
        char v28 = sub_100067900(v27);
        sub_10006221C("trace connection input: %s", v29, v30, v31, v32, v33, v34, v35, v28);
      }
    }

    LOWORD(v15) = *((_WORD *)v11 + 7) + v22;
    *((_WORD *)v11 + 7) = v15;
    *(_DWORD *)(a1 + 96) += v22;
    if ((unsigned __int16)v15 == 4048)
    {
      LOWORD(v15) = 0;
      *((_WORD *)v11 + 7) = 0;
    }

    v19 -= v22;
  }

  if (!a2) {
    goto LABEL_46;
  }
  else {
    size_t v21 = v21;
  }
  if (a4) {
    *a4 += v21;
  }
  memcpy((char *)v11 + *((unsigned __int16 *)v11 + 7) + 16, a3, v21);
  a2 -= v21;
  a3 += v21;
  unsigned int v22 = v21;
  if ((v21 & 0x80000000) == 0) {
    goto LABEL_33;
  }
LABEL_45:
  if (*__error() == 35) {
    goto LABEL_46;
  }
  if (*__error() == 5) {
    return 26LL;
  }
  if (*__error() == 22) {
    return 39LL;
  }
  if (*__error() == 54)
  {
    uint64_t v37 = a1;
    int v38 = 1;
    goto LABEL_50;
  }

  return 34LL;
}

uint64_t sub_10005E7A4(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (!a1) {
    return 39LL;
  }
  if (*(void *)a1 != qword_10008CF08) {
    return 39LL;
  }
  uint64_t v8 = (void **)(a1 + 120);
  uint64_t v7 = *(void ***)(a1 + 120);
  if (v7)
  {
    do
    {
      unsigned int v9 = v7;
      uint64_t v7 = (void **)*v7;
    }

    while (v7);
    if (a3) {
      goto LABEL_10;
    }
  }

  else
  {
    uint64_t result = sub_10005D23C((void **)(a1 + 120));
    if ((_DWORD)result) {
      return result;
    }
    unsigned int v9 = (void **)*v8;
    if (a3)
    {
LABEL_10:
      unsigned int v10 = 0;
      unsigned __int16 v11 = *((_WORD *)v9 + 7);
      char v12 = 2;
      while (1)
      {
        uint64_t v13 = *((unsigned __int16 *)v9 + 6);
        BOOL v14 = (_DWORD)v13 == v11;
        if (v14)
        {
          uint64_t result = sub_10005D23C(v9);
          if ((_DWORD)result) {
            return result;
          }
          unsigned int v9 = (void **)*v9;
          unsigned __int16 v11 = *((_WORD *)v9 + 7);
          LODWORD(v13) = *((unsigned __int16 *)v9 + 6);
        }

        unsigned int v15 = v13 - v11;
        if (v15 >= a3 - v10) {
          size_t v16 = a3 - v10;
        }
        else {
          size_t v16 = v15;
        }
        uint64_t v17 = *(void *)(a1 + 152);
        if (v17)
        {
          if (!*(void *)(a1 + 160)) {
            char v12 = 3;
          }
          uint64_t result = sub_10006037C(v12, v17, (void *)(a1 + 160), a2 + (int)v10, v16, 0LL);
          if ((_DWORD)result) {
            return result;
          }
          uint64_t v18 = (int)v10;
          unsigned __int16 v11 = *((_WORD *)v9 + 7);
        }

        else
        {
          uint64_t v18 = (int)v10;
        }

        memcpy((char *)v9 + v11 + 16, (const void *)(a2 + v18), v16);
        unsigned __int16 v11 = *((_WORD *)v9 + 7) + v16;
        *((_WORD *)v9 + 7) = v11;
        *(_DWORD *)(a1 + 112) += v16;
        if (v11 == 4048)
        {
          unsigned __int16 v11 = 0;
          *((_WORD *)v9 + 7) = 0;
        }

        uint64_t result = 0LL;
        v10 += v16;
        if (v10 >= a3) {
          return result;
        }
      }
    }
  }

  return 0LL;
}

uint64_t sub_10005E974(char *__dst, uint64_t a2, unsigned int a3)
{
  if (!a2) {
    return 39LL;
  }
  if (*(void *)a2 != qword_10008CF08) {
    return 39LL;
  }
  unsigned int v5 = a3;
  unsigned int v6 = *(_DWORD *)(a2 + 96);
  if (v6 < a3) {
    return 29LL;
  }
  uint64_t v7 = (_DWORD ***)(a2 + 104);
  uint64_t v8 = *(uint64_t **)(a2 + 104);
  uint64_t v25 = v8;
  if (a3)
  {
    unsigned int v10 = (void *)(a2 + 144);
    char v11 = 2;
    while (1)
    {
      if (!v8) {
        return 34LL;
      }
      unsigned int v12 = *((unsigned __int16 *)v8 + 7);
      unsigned int v13 = *((unsigned __int16 *)v8 + 6);
      if (v12 <= v13)
      {
        if (v12 - v13 == -4047)
        {
LABEL_29:
          unsigned __int16 v19 = *((_WORD *)v8 + 6);
          goto LABEL_30;
        }
      }

      else if (!(~v13 + v12))
      {
        goto LABEL_29;
      }

      if (v13 == 4047) {
        uint64_t v14 = 0LL;
      }
      else {
        uint64_t v14 = v13 + 1;
      }
      else {
        int v15 = 4048;
      }
      unsigned int v16 = v15 - v14;
      if (v16 >= v5) {
        size_t v17 = v5;
      }
      else {
        size_t v17 = v16;
      }
      if (__dst)
      {
        uint64_t v18 = *(void *)(a2 + 136);
        if (v18)
        {
          if (!*v10) {
            char v11 = 3;
          }
          uint64_t result = sub_10006037C(v11, v18, (void *)(a2 + 144), (uint64_t)v8 + v14 + 16, v17, 0LL);
          if ((_DWORD)result) {
            return result;
          }
        }

        memcpy(__dst, (char *)v8 + v14 + 16, v17);
        __dst += v17;
        unsigned int v6 = *(_DWORD *)(a2 + 96);
        unsigned int v12 = *((unsigned __int16 *)v8 + 7);
      }

      v5 -= v17;
      unsigned __int16 v19 = v17 + v14 - 1;
      *((_WORD *)v8 + 6) = v19;
      v6 -= v17;
      *(_DWORD *)(a2 + 96) = v6;
      unsigned int v13 = v19;
LABEL_30:
      if (v12 > v19)
      {
        if (~v13 + v12) {
          goto LABEL_35;
        }
LABEL_34:
        uint64_t v8 = (uint64_t *)*v8;
        uint64_t v25 = v8;
        goto LABEL_35;
      }

      if (v12 - v13 == -4047) {
        goto LABEL_34;
      }
LABEL_35:
      if (!v5)
      {
        uint64_t v8 = (uint64_t *)*v7;
        break;
      }
    }
  }

  uint64_t v25 = 0LL;
  if (v8)
  {
    while (1)
    {
      unsigned int v20 = *((unsigned __int16 *)v8 + 7);
      unsigned int v21 = *((unsigned __int16 *)v8 + 6);
      int v22 = ~v21 + v20;
      BOOL v23 = v20 > v21;
      int v24 = v20 - v21 + 4047;
      if (v23) {
        int v24 = v22;
      }
      if (v24) {
        break;
      }
      if (*v8)
      {
        sub_10005D2B4(&v25, *v8);
        sub_10005D2E8(*v7);
      }

      sub_10005D2E8((_DWORD **)(a2 + 104));
      if (v25)
      {
        sub_10005D2B4((void *)(a2 + 104), (uint64_t)v25);
        sub_10005D2E8(&v25);
      }

      uint64_t result = 0LL;
      uint64_t v8 = (uint64_t *)*v7;
      if (!*v7) {
        return result;
      }
    }
  }

  return 0LL;
}

uint64_t sub_10005EBC0(uint64_t a1)
{
  if (!a1 || *(void *)a1 != qword_10008CF08) {
    return 39LL;
  }
  int v3 = *(_DWORD *)(a1 + 112);
  if (!v3) {
    return 0LL;
  }
  uint64_t v4 = (_DWORD ***)(a1 + 120);
  unsigned int v5 = *(_DWORD **)(a1 + 120);
  uint64_t v34 = v5;
  while (1)
  {
    if (!v5) {
      return 34LL;
    }
    unsigned int v6 = *((unsigned __int16 *)v5 + 7);
    unsigned int v7 = *((unsigned __int16 *)v5 + 6);
    if (v6 <= v7)
    {
      if (v6 - v7 == -4047)
      {
LABEL_23:
        unsigned __int16 v26 = *((_WORD *)v5 + 6);
        goto LABEL_24;
      }
    }

    else if (!(~v7 + v6))
    {
      goto LABEL_23;
    }

    uint64_t v8 = v7 == 4047 ? 0LL : v7 + 1;
    int v9 = v8 <= v6 ? *((unsigned __int16 *)v5 + 7) : 4048;
    int v10 = v9 - v8;
    int v11 = write(*(_DWORD *)(a1 + 32), (char *)v5 + v8 + 16, (v9 - v8));
    int v12 = v11;
    if (v11 < 0) {
      break;
    }
    if (!v11) {
      return 0LL;
    }
    int v13 = sub_100068D58();
    unsigned int v5 = v34;
    if (v13)
    {
      unsigned int v33 = bswap32(*(_DWORD *)(a1 + 36));
      uint64_t v35 = &v33;
      int v36 = 4;
      uint64_t v37 = (char *)v34 + *((unsigned __int16 *)v34 + 7) + 16;
      int v38 = v12;
      unsigned int v17 = sub_1000693DC( qword_1000C56A8,  2LL,  (uint64_t)&v35,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/buffer.c",  520LL,  v14,  v15,  v16);
      if (v17)
      {
        unsigned int v18 = v17;
        sub_100069268();
        sub_100067900(v18);
        sub_10006221C("trace %s output: %s", v19, v20, v21, v22, v23, v24, v25, (char)"connection");
      }
    }

    unsigned __int16 v26 = v8 + v12 - 1;
    *((_WORD *)v5 + 6) = v26;
    int v3 = *(_DWORD *)(a1 + 112) - v12;
    *(_DWORD *)(a1 + 112) = v3;
    if (v10 != v12) {
      return 0LL;
    }
    unsigned int v6 = *((unsigned __int16 *)v5 + 7);
    unsigned int v7 = (unsigned __int16)(v8 + v12 - 1);
LABEL_24:
    if (v6 > v26)
    {
      if (~v7 + v6) {
        goto LABEL_29;
      }
LABEL_28:
      unsigned int v5 = *(_DWORD **)v5;
      uint64_t v34 = v5;
      goto LABEL_29;
    }

    if (v6 - v7 == -4047) {
      goto LABEL_28;
    }
LABEL_29:
    if (!v3)
    {
      unsigned int v27 = *v4;
      uint64_t v34 = 0LL;
      if (v27)
      {
        while (1)
        {
          unsigned int v28 = *((unsigned __int16 *)v27 + 7);
          unsigned int v29 = *((unsigned __int16 *)v27 + 6);
          int v30 = ~v29 + v28;
          BOOL v31 = v28 > v29;
          int v32 = v28 - v29 + 4047;
          if (v31) {
            int v32 = v30;
          }
          if (v32) {
            break;
          }
          if (*(void *)v27)
          {
            sub_10005D2B4(&v34, *(void *)v27);
            sub_10005D2E8(*v4);
          }

          sub_10005D2E8((_DWORD **)v4);
          if (v34)
          {
            sub_10005D2B4(v4, (uint64_t)v34);
            sub_10005D2E8(&v34);
          }

          uint64_t result = 0LL;
          unsigned int v27 = *v4;
          if (!*v4) {
            return result;
          }
        }
      }

      return 0LL;
    }
  }

  if (*__error() == 35 || *__error() == 35) {
    return 0LL;
  }
  if (*__error() == 32) {
    return 7LL;
  }
  if (*__error() == 27 || *__error() == 69) {
    return 13LL;
  }
  if (*__error() == 28) {
    return 19LL;
  }
  if (*__error() == 5) {
    return 26LL;
  }
  if (*__error() != 22)
  {
    if (*__error() == 54) {
      return 22LL;
    }
    else {
      return 34LL;
    }
  }

  return 39LL;
}

uint64_t sub_10005EF20(uint64_t a1, _DWORD *a2)
{
  uint64_t result = sub_10005E974((char *)&__dst, a1, 4u);
  if (!(_DWORD)result) {
    *a2 = bswap32(__dst);
  }
  return result;
}

uint64_t sub_10005EF64(uint64_t a1, unsigned int a2)
{
  unsigned int v3 = bswap32(a2);
  return sub_10005E7A4(a1, (uint64_t)&v3, 4u);
}

uint64_t sub_10005EF90(uint64_t a1, _WORD *a2)
{
  uint64_t result = sub_10005E974((char *)&__dst, a1, 2u);
  if (!(_DWORD)result) {
    *a2 = bswap32(__dst) >> 16;
  }
  return result;
}

uint64_t sub_10005EFD8(uint64_t a1, unsigned int a2)
{
  __int16 v3 = bswap32(a2) >> 16;
  return sub_10005E7A4(a1, (uint64_t)&v3, 2u);
}

uint64_t sub_10005F008(uint64_t a1, _DWORD *a2)
{
  if (!a2)
  {
    unsigned int v12 = 0;
LABEL_8:
    unsigned int v7 = &v12;
    uint64_t v8 = a1;
    unsigned int v9 = 4;
    return sub_10005E7A4(v8, (uint64_t)v7, v9);
  }

  int v4 = a2[1];
  if ((v4 - 1) < 2)
  {
    unsigned int v12 = bswap32(a2[2]);
    uint64_t result = sub_10005E7A4(a1, (uint64_t)&v12, 4u);
    if (!(_DWORD)result)
    {
      unsigned int v9 = a2[2];
      if (v9)
      {
        unsigned int v7 = a2 + 3;
        uint64_t v8 = a1;
        return sub_10005E7A4(v8, (uint64_t)v7, v9);
      }

      return 0LL;
    }
  }

  else if (v4 == 3)
  {
    uint64_t v10 = *((void *)a2 + 1);
    if (v10)
    {
      uint64_t result = sub_100062B58(&v11, v10);
      if ((_DWORD)result) {
        return result;
      }
    }

    else
    {
      unsigned int v11 = 0;
    }

    unsigned int v12 = 0x4000000;
    uint64_t result = sub_10005E7A4(a1, (uint64_t)&v12, 4u);
    if (!(_DWORD)result)
    {
      unsigned int v6 = v11;
LABEL_20:
      unsigned int v12 = bswap32(v6);
      goto LABEL_8;
    }
  }

  else
  {
    if (!v4)
    {
      unsigned int v12 = 0x4000000;
      uint64_t result = sub_10005E7A4(a1, (uint64_t)&v12, 4u);
      if ((_DWORD)result) {
        return result;
      }
      unsigned int v6 = a2[2];
      goto LABEL_20;
    }

    return 39LL;
  }

  return result;
}

uint64_t sub_10005F114(uint64_t a1, char *__s)
{
  unsigned int v4 = strlen(__s);
  __int16 v6 = bswap32(v4) >> 16;
  uint64_t result = sub_10005E7A4(a1, (uint64_t)&v6, 2u);
  if (!(_DWORD)result) {
    return sub_10005E7A4(a1, (uint64_t)__s, v4);
  }
  return result;
}

uint64_t sub_10005F180(uint64_t a1, char *__s)
{
  if (__s) {
    unsigned int v4 = strlen(__s);
  }
  else {
    unsigned int v4 = 0;
  }
  unsigned int v6 = bswap32(v4);
  uint64_t result = sub_10005E7A4(a1, (uint64_t)&v6, 4u);
  if (!(_DWORD)result)
  {
    if (v4) {
      return sub_10005E7A4(a1, (uint64_t)__s, v4);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_10005F200(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t result = sub_100062B58(&v4, a2);
    if ((_DWORD)result) {
      return result;
    }
  }

  else
  {
    unsigned int v4 = 0;
  }

  int v5 = 0x4000000;
  uint64_t result = sub_10005E7A4(a1, (uint64_t)&v5, 4u);
  if (!(_DWORD)result)
  {
    unsigned int v6 = bswap32(v4);
    return sub_10005E7A4(a1, (uint64_t)&v6, 4u);
  }

  return result;
}

uint64_t sub_10005F274(void **a1, uint64_t a2, uint64_t a3)
{
  return sub_10005CE50(a1, (void *)qword_10008CF08, 0LL, a2, a3);
}

uint64_t sub_10005F298(uint64_t a1, char *a2, int a3)
{
  uint64_t v20 = 0LL;
  if (inet_aton(a2, &v19))
  {
    uint64_t v6 = sub_10005D7F4(&v20, 1u);
    if (!(_DWORD)v6)
    {
      unsigned int v7 = v20;
      uint64_t v8 = *((void *)v20 + 1);
      *(void *)uint64_t v8 = 0x400000002LL;
      *(in_addr *)(v8 + 8) = v19;
      *(_DWORD *)(*((void *)v7 + 1) + 24LL) = a3;
LABEL_4:
      uint64_t v6 = sub_10005F3F4(a1, v7, 0LL);
      sub_10005D658(&v20);
    }
  }

  else
  {
    unsigned int v9 = gethostbyname(a2);
    if (!v9) {
      return 36LL;
    }
    uint64_t v10 = v9;
    unsigned int v11 = -1;
    do
      ++v11;
    while (v9->h_addr_list[v11]);
    if (!v11) {
      return 36LL;
    }
    uint64_t v6 = sub_10005D7F4(&v20, v11);
    if (!(_DWORD)v6)
    {
      unint64_t v12 = 0LL;
      uint64_t v13 = *((void *)v20 + 1);
      uint64_t v14 = 8LL * v11;
      uint64_t v15 = 24LL;
      do
      {
        uint64_t v16 = v13 + v15;
        size_t h_length = v10->h_length;
        *(_DWORD *)(v16 - 24) = v10->h_addrtype;
        *(_DWORD *)(v16 - 2__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = h_length;
        memcpy((void *)(v16 - 16), v10->h_addr_list[v12 / 8], h_length);
        unsigned int v7 = v20;
        uint64_t v13 = *((void *)v20 + 1);
        *(_DWORD *)(v13 + v15) = a3;
        v15 += 28LL;
        v12 += 8LL;
      }

      while (v14 != v12);
      goto LABEL_4;
    }
  }

  return v6;
}

uint64_t sub_10005F3F4(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  uint64_t v16 = 0LL;
  uint64_t v6 = sub_10005CE50( (void **)&v16,  (void *)qword_10008CF08,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c",  120LL);
  if (!(_DWORD)v6)
  {
    uint64_t v7 = sub_10005CFB8((void *)(a1 + 16), (uint64_t)v16);
    if ((_DWORD)v7)
    {
      uint64_t v6 = v7;
      uint64_t v8 = 127LL;
LABEL_9:
      sub_10005CFEC((_DWORD **)&v16, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c", v8);
      return v6;
    }

    uint64_t v6 = sub_10005CFB8((void *)v16 + 3, a1);
    if ((_DWORD)v6)
    {
      uint64_t v8 = 132LL;
      goto LABEL_9;
    }

    sub_10005D504((void *)v16 + 10, a2);
    unsigned int v9 = v16;
    *((_DWORD *)v16 + 22) = 0;
    *((_DWORD *)v9 + 1__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = 0;
    int v11 = socket(2, 1, 6);
    *((_DWORD *)v16 + 8) = v11;
    if (v11 < 0)
    {
      sub_10005CFEC( (_DWORD **)&v16,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c",  150LL);
      if (*__error() == 24)
      {
        return 13LL;
      }

      else
      {
        uint64_t v6 = 13LL;
        if (*__error() != 23)
        {
          if (*__error() == 55) {
            return 13LL;
          }
          else {
            return 34LL;
          }
        }
      }
    }

    else
    {
      int v12 = v11;
      if (!a3) {
        goto LABEL_16;
      }
      if (*(_DWORD *)a3 != 2)
      {
        sub_10005CFEC( (_DWORD **)&v16,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c",  161LL);
        return 39LL;
      }

      *(_WORD *)v17.sa_data = bswap32(*(unsigned __int16 *)(a3 + 24)) >> 16;
      __memcpy_chk(&v17.sa_data[2], a3 + 8, *(unsigned int *)(a3 + 4), 12LL);
      *(_WORD *)&v17.sa_len = 520;
      *(void *)&v17.sa_data[6] = 0LL;
      if ((bind(v12, &v17, 0x10u) & 0x80000000) == 0)
      {
        uint64_t v13 = v16;
        *(sockaddr *)(v16 + 6__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = v17;
        int v12 = *((_DWORD *)v13 + 8);
LABEL_16:
        if (fcntl(v12, 2, 1LL) < 0)
        {
          close(*((_DWORD *)v16 + 8));
          uint64_t v14 = 194LL;
        }

        else
        {
          int v15 = 1;
          if (setsockopt(*((_DWORD *)v16 + 8), 0xFFFF, 4, &v15, 4u) < 0)
          {
            uint64_t v14 = 203LL;
          }

          else if (fcntl(*((_DWORD *)v16 + 8), 4, 4LL) < 0)
          {
            uint64_t v14 = 209LL;
          }

          else
          {
            int v15 = 1;
            if ((setsockopt(*((_DWORD *)v16 + 8), 0xFFFF, 4130, &v15, 4u) & 0x80000000) == 0)
            {
              uint64_t v6 = sub_100060E24( (uint64_t)v16,  0LL,  (uint64_t)sub_10005F7CC,  0LL,  (uint64_t)sub_10005F808,  (uint64_t)sub_10005F84C);
              if ((_DWORD)v6) {
                goto LABEL_8;
              }
              uint64_t v6 = sub_10005F8C0((uint64_t)v16);
LABEL_7:
              sub_10005FB10( (uint64_t)v16,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c",  237LL);
LABEL_8:
              uint64_t v8 = 241LL;
              goto LABEL_9;
            }

            uint64_t v14 = 221LL;
          }
        }

        sub_10005CFEC( (_DWORD **)&v16,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c",  v14);
        return 34LL;
      }

      sub_10005CFEC( (_DWORD **)&v16,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c",  179LL);
      if (*__error() == 48)
      {
        return 5LL;
      }

      else if (*__error() == 49)
      {
        return 4LL;
      }

      else if (*__error() == 13)
      {
        return 6LL;
      }

      else
      {
        return 34LL;
      }
    }
  }

  return v6;
}

uint64_t sub_10005F7CC(uint64_t a1)
{
  if (*(void *)a1 == qword_10008CF08 && (*(_DWORD *)(a1 + 40) == 1 || *(_DWORD *)(a1 + 112))) {
    return *(unsigned int *)(a1 + 32);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_10005F808(uint64_t a1)
{
  return 0LL;
}

uint64_t sub_10005F84C(uint64_t a1)
{
  if (*(void *)a1 != qword_10008CF08) {
    return 39LL;
  }
  int v3 = *(_DWORD *)(a1 + 40);
  if (v3 == 3)
  {
    if (*(_DWORD *)(a1 + 112)) {
      return 0LL;
    }
    sub_100060130(a1, 1);
    int v3 = *(_DWORD *)(a1 + 40);
  }

  if (v3 == 4) {
    return 40LL;
  }
  else {
    return 0LL;
  }
}

uint64_t sub_10005F8C0(uint64_t a1)
{
  if (*(void *)a1 != qword_10008CF08) {
    return 39LL;
  }
  uint64_t v2 = a1;
  unsigned int v3 = *(_DWORD *)(a1 + 40);
  if (v3 == 1)
  {
    socklen_t v9 = 4;
    if (getsockopt(*(_DWORD *)(a1 + 32), 0xFFFF, 4103, &v10, &v9) < 0)
    {
      sub_100060130(v2, 1);
      return 0LL;
    }

    LODWORD(a1) = v10;
    if (!v10) {
      goto LABEL_11;
    }
    unsigned int v3 = *(_DWORD *)(v2 + 40);
  }

  if (v3 > 1) {
    goto LABEL_12;
  }
  uint64_t v4 = *(int *)(v2 + 88);
  uint64_t v5 = *(void *)(v2 + 80);
  if (v4 >= *(_DWORD *)(v5 + 4))
  {
    if ((_DWORD)a1 == 61)
    {
      uint64_t v1 = 12LL;
    }

    else if ((_DWORD)a1 == 51)
    {
      uint64_t v1 = 8LL;
    }

    else
    {
      uint64_t v1 = sub_100068C8C(a1);
    }

uint64_t sub_10005FB10(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = qword_10008CE68;
  if (!qword_10008CE68)
  {
    uint64_t result = sub_10005D87C(&qword_10008CE68, (uint64_t)sub_10005F290, (uint64_t)sub_10005F294);
    if ((_DWORD)result) {
      return result;
    }
    uint64_t v6 = qword_10008CE68;
  }

  uint64_t result = sub_10005D9BC(v6, a1, 0LL, a2, a3);
  if ((_DWORD)result)
  {
    *(_DWORD *)(a1 + 36) = -1;
  }

  else
  {
    uint64_t result = sub_100068D58();
    if ((_DWORD)result)
    {
      unsigned int v14 = bswap32(dword_1000C56B8++);
      uint64_t v11 = *(void *)(a1 + 128);
      if (v11) {
        unsigned int v12 = bswap32(*(_DWORD *)(v11 + 36));
      }
      else {
        unsigned int v12 = -1;
      }
      unsigned int v13 = v12;
      int v15 = &v14;
      int v16 = 4;
      sockaddr v17 = &v13;
      int v18 = 4;
      uint64_t v19 = a1 + 46;
      int v20 = 2;
      uint64_t v21 = a1 + 62;
      int v22 = 2;
      uint64_t v23 = a1 + 48;
      int v24 = 4;
      uint64_t v25 = a1 + 64;
      int v26 = 4;
      return sub_1000693DC(qword_10008CE70, 6LL, (uint64_t)&v15, a2, a3, v8, v9, v10);
    }
  }

  return result;
}

uint64_t sub_10005FC78(void *a1)
{
  return sub_10005D87C(a1, (uint64_t)sub_10005F290, (uint64_t)sub_10005F294);
}

void *sub_10005FCA4()
{
  qword_10008CE70 = (uint64_t)sub_100068E0C( "connect",  0LL,  (uint64_t)sub_10005FD24,  (uint64_t)nullsub_14,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c",  253LL);
  uint64_t result = sub_100068E0C( "disconnect",  0LL,  (uint64_t)sub_10006002C,  (uint64_t)nullsub_15,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c",  256LL);
  qword_10008CE78 = (uint64_t)result;
  return result;
}

uint64_t sub_10005FD24( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((_DWORD)a2 != 20) {
    return sub_10006221C("Trace connect: invalid length %d", a2, a3, a4, a5, a6, a7, a8, a2);
  }
  __int128 v54 = 0uLL;
  unsigned int v8 = *(_DWORD *)a3;
  int v9 = *(_DWORD *)(a3 + 4);
  unsigned int v10 = *(unsigned __int16 *)(a3 + 8);
  WORD1(v54) = *(_WORD *)(a3 + 8);
  int v11 = *(unsigned __int16 *)(a3 + 10);
  in_addr_t v12 = *(_DWORD *)(a3 + 12);
  DWORD1(v54) = v12;
  if (v9 == -1)
  {
    unsigned int v18 = bswap32(v8);
    int v53 = 0LL;
    uint64_t v19 = qword_10008CE68;
    if (qword_10008CE68)
    {
      uint64_t v20 = 0LL;
      while (v20 < *(int *)(v19 + 24))
      {
        uint64_t v21 = *(void *)(*(void *)v19 + 8 * v20);
        if (v21)
        {
          (*(void (**)(void **, uint64_t, const char *, uint64_t))(v19 + 8))( &v53,  v21,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c",  389LL);
          int v22 = v53;
          uint64_t v23 = v53[10];
          if (v23 && *(_DWORD *)(v23 + 4))
          {
            uint64_t v49 = (int **)(v53 + 10);
            uint64_t v50 = *(void *)(v23 + 8);
            if (DWORD1(v54) == *(_DWORD *)(v50 + 8) && *(_DWORD *)(v50 + 24) == bswap32(v10) >> 16) {
              *((_DWORD *)v53 + 1__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = 2;
            }
            *(_OWORD *)((char *)v22 + 44) = v54;
            *((_BYTE *)v22 + 45) = 2;
            sub_10005D658(v49);
            uint64_t v51 = (uint64_t)v53;
            *((_DWORD *)v53 + 9) = v18;
            sub_100067DF8(v51);
            return sub_10005CFEC( (_DWORD **)&v53,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c",  404LL);
          }

          (*(void (**)(void **, const char *, uint64_t))(qword_10008CE68 + 16))( &v53,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c",  408LL);
          uint64_t v19 = qword_10008CE68;
        }

        ++v20;
        if (!v19) {
          break;
        }
      }
    }

    v24.in_addr_t s_addr = v12;
    inet_ntoa(v24);
    return sub_10006221C( "Spurious traced connect - index %ld, addr %s, port %d",  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v18);
  }

  else
  {
    in_addr_t v13 = *(_DWORD *)(a3 + 16);
    unsigned int v52 = 0LL;
    int v53 = 0LL;
    uint64_t v14 = qword_10008CEC0;
    if (!qword_10008CEC0) {
      goto LABEL_28;
    }
    uint64_t v15 = 0LL;
    while (v15 < *(int *)(v14 + 24))
    {
      uint64_t v16 = *(void *)(*(void *)v14 + 8 * v15);
      if (v16)
      {
        (*(void (**)(void **, uint64_t, const char *, uint64_t))(v14 + 8))( &v53,  v16,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c",  359LL);
        if (*((unsigned __int16 *)v53 + 21) == v11)
        {
          sub_1000638E4(&v52, (uint64_t)v53);
          sub_1000638E8( (_DWORD **)&v53,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c",  362LL);
          break;
        }

        (*(void (**)(void **, const char *, uint64_t))(qword_10008CEC0 + 16))( &v53,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c",  366LL);
        uint64_t v14 = qword_10008CEC0;
      }

      ++v15;
      if (!v14) {
        break;
      }
    }

    if (v52)
    {
      int v53 = 0LL;
      unsigned int v32 = sub_100063E90((void **)&v53, (uint64_t)v52, -1, (uint64_t)&v54);
      if (v32)
      {
        char v33 = sub_100067900(v32);
        sub_10006221C("traced listener connect: %s", v34, v35, v36, v37, v38, v39, v40, v33);
      }

      if (v53) {
        sub_10005CFEC( (_DWORD **)&v53,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c",  382LL);
      }
      return sub_1000638E8(&v52, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c", 383LL);
    }

    else
    {
LABEL_28:
      v41.in_addr_t s_addr = v13;
      inet_ntoa(v41);
      return sub_10006221C( "%s%ld, addr %s, port %d",  v42,  v43,  v44,  v45,  v46,  v47,  v48,  (char)"Spurious traced listener connect - index ");
    }
  }

uint64_t sub_10006002C( uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((_DWORD)a2 != 4) {
    return sub_10006221C("trace disconnect: wrong length %d", a2, (uint64_t)a3, a4, a5, a6, a7, a8, a2);
  }
  in_addr_t v12 = 0LL;
  uint64_t v9 = qword_10008CE68;
  if (qword_10008CE68)
  {
    for (uint64_t i = 0LL; i < *(int *)(v9 + 24); ++i)
    {
      a2 = *(void *)(*(void *)v9 + 8 * i);
      if (a2)
      {
        (*(void (**)(_DWORD **, uint64_t, const char *, uint64_t))(v9 + 8))( &v12,  a2,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c",  430LL);
        if (v12[9] == bswap32(*a3))
        {
          sub_100060130((uint64_t)v12, 1);
          return sub_10005CFEC( &v12,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c",  433LL);
        }

        (*(void (**)(_DWORD **, const char *, uint64_t))(qword_10008CE68 + 16))( &v12,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c",  437LL);
        uint64_t v9 = qword_10008CE68;
      }

      if (!v9) {
        return sub_10006221C( "trace disconnect: no connection matching index %ld",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  bswap32(*a3));
      }
    }
  }

  return sub_10006221C( "trace disconnect: no connection matching index %ld",  a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  bswap32(*a3));
}

uint64_t sub_100060130(uint64_t a1, int a2)
{
  if (*(void *)a1 != qword_10008CF08) {
    return 39LL;
  }
  if (sub_100068D58())
  {
    unsigned int v25 = bswap32(*(_DWORD *)(a1 + 36));
    unsigned int v8 = sub_1000693B0( qword_10008CE78,  4,  (uint64_t)&v25,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c",  471LL,  v5,  v6,  v7);
    if (v8)
    {
      unsigned int v9 = v8;
      sub_100069268();
      char v10 = sub_100067900(v9);
      sub_10006221C("trace_write_packet: %s", v11, v12, v13, v14, v15, v16, v17, v10);
    }
  }

  if (!sub_100068D4C())
  {
    if (!a2)
    {
      if (*(_DWORD *)(a1 + 40) == 3) {
        return 0LL;
      }
      if (!shutdown(*(_DWORD *)(a1 + 32), 0) && *(_DWORD *)(a1 + 112))
      {
        uint64_t result = 0LL;
        *(_DWORD *)(a1 + 4__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = 3;
        return result;
      }
    }

    close(*(_DWORD *)(a1 + 32));
  }

  uint64_t v18 = *(void *)(a1 + 16);
  *(_DWORD *)(a1 + 4__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = 4;
  if (v18)
  {
    uint64_t v20 = *(void *)(v18 + 24);
    uint64_t v19 = (_DWORD **)(v18 + 24);
    if (v20) {
      sub_10005CFEC(v19, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c", 508LL);
    }
    sub_10005CFEC( (_DWORD **)(a1 + 16),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c",  509LL);
  }

  sub_100067DAC(a1);
  uint64_t v21 = *(void *)(a1 + 24);
  if (v21)
  {
    uint64_t v23 = *(void *)(v21 + 16);
    int v22 = (_DWORD **)(v21 + 16);
    if (v23) {
      sub_10005CFEC(v22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c", 519LL);
    }
    sub_10005CFEC( (_DWORD **)(a1 + 24),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c",  521LL);
  }

  if (*(void *)(a1 + 104)) {
    sub_10005D2E8((_DWORD **)(a1 + 104));
  }
  uint64_t v24 = *(void *)(a1 + 120);
  *(_DWORD *)(a1 + 96) = 0;
  if (v24) {
    sub_10005D2E8((_DWORD **)(a1 + 120));
  }
  uint64_t result = 0LL;
  *(_DWORD *)(a1 + 112) = 0;
  return result;
}

uint64_t sub_1000602F8(uint64_t a1, unsigned int a2)
{
  if (*(void *)a1 != qword_10008CF08) {
    return 39LL;
  }
  *(_DWORD *)(a1 + 92) = a2;
  if (*(_DWORD *)(a1 + 96) >= a2) {
    return 0LL;
  }
  else {
    return 41LL;
  }
}

uint64_t sub_100060330(uint64_t a1)
{
  if (*(void *)a1 == qword_10008CF08
    && *(_DWORD *)(a1 + 40) == 2
    && ((unsigned int v1 = *(_DWORD *)(a1 + 96), v1 < 0xFCF) || v1 <= *(_DWORD *)(a1 + 92)))
  {
    return *(unsigned int *)(a1 + 32);
  }

  else
  {
    return 0xFFFFFFFFLL;
  }

uint64_t sub_10006037C(char a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, void *a6)
{
  uint64_t v23 = 0LL;
  if ((a1 & 4) != 0)
  {
    uint64_t v15 = (const char *)sub_10005A7C8(a2);
    uint64_t v13 = sub_10005D348( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c",  815LL,  &v23,  2,  v16,  v17,  v18,  v19,  v15);
    if ((_DWORD)v13) {
      return v13;
    }
    if (v23) {
      uint64_t v20 = v23 + 3;
    }
    else {
      uint64_t v20 = 0LL;
    }
    int v21 = sub_1000599B4(a1, a2, (uint64_t)a3, a4, a5, (uint64_t)v20);
    *a3 = 0LL;
    if ((v21 & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }

  else if ((sub_1000599B4(a1, a2, (uint64_t)a3, a4, a5, 0LL) & 0x80000000) == 0)
  {
LABEL_3:
    uint64_t v12 = v23;
    if (a6 && v23)
    {
      sub_10005D504(a6, v23);
      uint64_t v12 = v23;
    }

    uint64_t v13 = 0LL;
    if (v12)
    {
      uint64_t v14 = 841LL;
LABEL_15:
      sub_10005D538(&v23, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c", v14);
      return v13;
    }

    return v13;
  }

  uint64_t v13 = 48LL;
  if (v23)
  {
    uint64_t v14 = 832LL;
    goto LABEL_15;
  }

  return v13;
}

uint64_t sub_1000604BC(void *a1, _DWORD *a2)
{
  if (*a1 != qword_10008CF08) {
    return 39LL;
  }
  uint64_t v3 = a1[19];
  if (!v3) {
    return 23LL;
  }
  int v5 = sub_10005A7C8(v3);
  uint64_t result = 0LL;
  *a2 = v5;
  return result;
}

uint64_t sub_100060518(void *a1, int a2, uint64_t a3, uint64_t a4)
{
  if (*a1 != qword_10008CF08) {
    return 39LL;
  }
  if (sub_100068648(a3, "input-authenticator"))
  {
    if (sub_100068648(a3, "output-authenticator"))
    {
      uint64_t v8 = a1[3];
      else {
        return 23LL;
      }
    }

    if (!a4 || *(_DWORD *)(a4 + 4) == 3)
    {
      if (a1[20]) {
        sub_10006037C(4, a1[19], a1 + 20, 0LL, 0LL, 0LL);
      }
      uint64_t v13 = a1[19];
      uint64_t v11 = a1 + 19;
      uint64_t v10 = v13;
      if (!v13) {
        goto LABEL_15;
      }
      goto LABEL_14;
    }

    return 39LL;
  }

  if (a4 && *(_DWORD *)(a4 + 4) != 3) {
    return 39LL;
  }
  if (a1[18]) {
    sub_10006037C(4, a1[17], a1 + 18, 0LL, 0LL, 0LL);
  }
  uint64_t v12 = a1[17];
  uint64_t v11 = a1 + 17;
  uint64_t v10 = v12;
  if (!v12) {
    goto LABEL_15;
  }
LABEL_14:
  sub_10005A1A4(v10);
  *uint64_t v11 = 0LL;
LABEL_15:
  if (!a4) {
    return 0LL;
  }
  uint64_t result = sub_100060664(v11, *(void *)(a4 + 8));
  if (!(_DWORD)result) {
    return 0LL;
  }
  return result;
}

uint64_t sub_100060664(uint64_t *a1, uint64_t a2)
{
  uint64_t v16 = 0LL;
  uint64_t v17 = 0LL;
  uint64_t v15 = 0LL;
  uint64_t v4 = sub_1000683F8(a2, 0, "name");
  if (!(_DWORD)v4)
  {
    uint64_t v4 = sub_1000683F8(a2, 0, "algorithm");
    if (!(_DWORD)v4)
    {
      uint64_t v4 = sub_1000683F8(a2, 0, "key");
      if (!(_DWORD)v4)
      {
        int v5 = v16[2];
        if ((v5[1] - 1) <= 1
          && !strncasecmp((const char *)v5 + 12, "HMAC-MD5.SIG-ALG.REG.INT.", v5[2]))
        {
          uint64_t v7 = (char *)sub_10005CDE4((v17[2][2] + 1));
          if (v7)
          {
            uint64_t v8 = v7;
            memcpy(v7, v17[2] + 3, v17[2][2]);
            v8[v17[2][2]] = 0;
            uint64_t v9 = sub_10005A68C(v8, 157, 0, 0, (uint64_t)(v15[2] + 3), v15[2][2]);
            *a1 = v9;
            uint64_t v4 = v9 == 0;
            sub_10005CE20( v8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c",  792LL,  v10,  v11,  v12,  v13,  v14);
          }

          else
          {
            uint64_t v4 = 1LL;
          }
        }

        else
        {
          uint64_t v4 = 39LL;
        }
      }
    }
  }

  if (v15) {
    sub_10005D71C(&v15, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c", 794LL);
  }
  if (v16) {
    sub_10005D71C(&v16, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c", 796LL);
  }
  if (v17) {
    sub_10005D71C(&v17, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c", 798LL);
  }
  return v4;
}

uint64_t sub_100060824(void *a1, int a2, _DWORD *a3, int ***a4)
{
  int v22 = 0LL;
  if (*a1 != qword_10008CF08) {
    return 39LL;
  }
  if (!sub_100068648((uint64_t)a3, "input-signature"))
  {
    uint64_t v11 = a1[17];
    if (!v11) {
      return 23LL;
    }
    uint64_t v13 = a1[18];
    uint64_t v12 = a1 + 18;
    if (!v13) {
      return 23LL;
    }
    uint64_t v4 = sub_10006037C(4, v11, v12, 0LL, 0LL, &v22);
    if ((_DWORD)v4) {
      return v4;
    }
    uint64_t v4 = sub_100068788(a4, a3, v22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c", 957LL);
    uint64_t v14 = 958LL;
    goto LABEL_20;
  }

  if (!sub_100068648((uint64_t)a3, "input-signature-size"))
  {
    uint64_t v15 = a1[17];
    if (v15)
    {
      uint64_t v16 = (const char *)sub_10005A7C8(v15);
      return sub_100068920( a4,  a3,  v16,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c",  966LL);
    }

    return 23LL;
  }

  if (!sub_100068648((uint64_t)a3, "output-signature"))
  {
    uint64_t v17 = a1[19];
    if (!v17) {
      return 23LL;
    }
    uint64_t v19 = a1[20];
    uint64_t v18 = a1 + 20;
    if (!v19) {
      return 23LL;
    }
    uint64_t v4 = sub_10006037C(4, v17, v18, 0LL, 0LL, &v22);
    if ((_DWORD)v4) {
      return v4;
    }
    uint64_t v4 = sub_100068788(a4, a3, v22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c", 979LL);
    uint64_t v14 = 980LL;
LABEL_20:
    sub_10005D538(&v22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c", v14);
    return v4;
  }

  if (sub_100068648((uint64_t)a3, "output-signature-size"))
  {
    uint64_t v8 = a1[3];
    if (v8)
    {
      uint64_t v9 = *(uint64_t (**)(void))(*(void *)v8 + 24LL);
      if (v9) {
        return v9();
      }
    }

    return 23LL;
  }

  uint64_t v20 = a1[19];
  if (!v20) {
    return 23LL;
  }
  int v21 = (const char *)sub_10005A7C8(v20);
  return sub_100068920(a4, a3, v21, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/connection.c", 988LL);
}

uint64_t sub_100060A38(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)a1 != qword_10008CF08) {
    return 34LL;
  }
  if (*(_DWORD *)(a1 + 40) == 2) {
    sub_100060130(a1, 1);
  }
  if (*(void *)(a1 + 128)) {
    sub_1000638E8((_DWORD **)(a1 + 128), a2, a3);
  }
  uint64_t v8 = *(void *)(a1 + 80);
  uint64_t v7 = (int **)(a1 + 80);
  if (v8) {
    sub_10005D658(v7);
  }
  return 0LL;
}

uint64_t sub_100060AD0(void *a1)
{
  if (*a1 != qword_10008CF08) {
    return 39LL;
  }
  uint64_t v2 = a1[3];
  else {
    return 23LL;
  }
}

uint64_t sub_100060B10(uint64_t a1, uint64_t a2, void *a3)
{
  if (*a3 != qword_10008CF08) {
    return 39LL;
  }
  uint64_t v4 = a3[3];
  else {
    return 0LL;
  }
}

uint64_t sub_100060B50(unsigned int *a1)
{
  return bswap32(*a1);
}

uint64_t sub_100060B5C(unsigned __int16 *a1)
{
  return bswap32(*a1) >> 16;
}

_DWORD *sub_100060B6C(_DWORD *result, unsigned int a2)
{
  void *result = bswap32(a2);
  return result;
}

_WORD *sub_100060B78(_WORD *result, unsigned int a2)
{
  void *result = bswap32(a2) >> 16;
  return result;
}

_WORD *sub_100060B88(_WORD *result, unsigned int a2)
{
  void *result = bswap32(a2) >> 16;
  return result;
}

_BYTE *sub_100060B98(_BYTE *result, char a2)
{
  void *result = a2;
  return result;
}

uint64_t sub_100060BA0(unsigned __int8 *a1)
{
  return *a1;
}

uint64_t sub_100060BA8(unsigned int *a1, unsigned int a2, int a3)
{
  if (a2 > 0x10) {
    return 0LL;
  }
  switch(a3)
  {
    case 4:
      unsigned int v3 = bswap32(*a1);
      break;
    case 2:
      unsigned int v3 = bswap32(*(unsigned __int16 *)a1) >> 16;
      break;
    case 1:
      unsigned int v3 = *(unsigned __int8 *)a1;
      break;
    default:
      return 0LL;
  }

  uint64_t result = 1LL;
  unsigned int v5 = a2;
  do
  {
    if (v3 < v5) {
      break;
    }
    uint64_t result = (result + 1);
    BOOL v6 = v5 * a2 > v5;
    v5 *= a2;
  }

  while (v6);
  return result;
}

uint64_t sub_100060C18(uint64_t a1, unsigned int *a2, unsigned int a3, int a4)
{
  uint64_t result = sub_100060BA8(a2, a3, a4);
  if (a3 > 0x10) {
    return 0LL;
  }
  switch(a4)
  {
    case 4:
      unsigned int v9 = bswap32(*a2);
      break;
    case 2:
      unsigned int v9 = bswap32(*(unsigned __int16 *)a2) >> 16;
      break;
    case 1:
      unsigned int v9 = *(unsigned __int8 *)a2;
      break;
    default:
      return 0LL;
  }

  if ((int)result >= 1)
  {
    unint64_t v10 = result + 1LL;
    do
    {
      *(_BYTE *)(a1 + (v10-- - 2)) = a0123456789abcd_0[v9 % a3];
      v9 /= a3;
    }

    while (v10 > 1);
  }

  return result;
}

uint64_t sub_100060CDC(void **a1, uint64_t a2, uint64_t a3)
{
  return sub_10005CE50(a1, (void *)qword_10008CF20, 0LL, a2, a3);
}

uint64_t sub_100060CF8(void **a1, uint64_t a2, uint64_t a3)
{
  return sub_10005CE50(a1, (void *)qword_10008CF50, 0LL, a2, a3);
}

void *sub_100060D14(void *result, uint64_t a2)
{
  unsigned int v3 = result;
  uint64_t v4 = (void *)*result;
  if (*result)
  {
    while (1)
    {
      unsigned int v5 = v4;
      if (v4[1] == a2) {
        break;
      }
      uint64_t v4 = (void *)*v4;
      if (!*v5) {
        goto LABEL_6;
      }
    }
  }

  else
  {
    unsigned int v5 = 0LL;
LABEL_6:
    uint64_t result = sub_10005CDE4(0x10uLL);
    if (!result) {
      sub_100061FB4("register_eventhandler: no memory!", v6, v7, v8, v9, v10, v11, v12, v14);
    }
    void *result = 0LL;
    result[1] = 0LL;
    if (v5) {
      uint64_t v13 = v5;
    }
    else {
      uint64_t v13 = v3;
    }
    *uint64_t v13 = result;
    result[1] = a2;
  }

  return result;
}

void sub_100060DA0( void **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = 0LL;
  uint64_t v9 = a1;
  while (1)
  {
    uint64_t v10 = v8;
    uint64_t v8 = *v9;
    if (!*v9) {
      break;
    }
    uint64_t v9 = (void **)*v9;
    if (v8[1] == a2)
    {
      if (!v10) {
        uint64_t v10 = a1;
      }
      *uint64_t v10 = *v8;
      sub_10005CE20( v8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/dispatch.c",  88LL,  a4,  a5,  a6,  a7,  a8);
      return;
    }
  }

void *sub_100060DEC(void *result)
{
  unsigned int v1 = (void *)*result;
  if (*result)
  {
    do
    {
      uint64_t v2 = (uint64_t (*)(void))v1[1];
      if (v2) {
        uint64_t result = (void *)v2(0LL);
      }
      unsigned int v1 = (void *)*v1;
    }

    while (v1);
  }

  return result;
}

uint64_t sub_100060E24(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (!dword_1000C56C8)
  {
    dword_1000C56C8 = 1;
    qword_1000C56C0 = qword_10008CF20;
  }

  int v22 = 0LL;
  uint64_t v12 = sub_10005CE50( (void **)&v22,  (void *)qword_10008CF20,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/dispatch.c",  134LL);
  if (!(_DWORD)v12)
  {
    uint64_t v13 = sub_10005CFB8(v22 + 3, a1);
    if ((_DWORD)v13)
    {
      uint64_t v12 = v13;
      uint64_t v14 = 140LL;
    }

    else
    {
      uint64_t v15 = sub_10005CFB8((void *)(a1 + 16), (uint64_t)v22);
      if ((_DWORD)v15)
      {
        uint64_t v12 = v15;
        uint64_t v14 = 147LL;
      }

      else
      {
        uint64_t v16 = qword_1000C56E0;
        while (v16)
        {
          uint64_t v17 = v16;
          uint64_t v16 = *(void *)(v16 + 32);
          if (!v16)
          {
            uint64_t v18 = (uint64_t *)(v17 + 32);
            uint64_t v19 = (uint64_t)v22;
            goto LABEL_13;
          }
        }

        uint64_t v19 = (uint64_t)v22;
        uint64_t v18 = &qword_1000C56E0;
LABEL_13:
        sub_10005CFB8(v18, v19);
        uint64_t v12 = 0LL;
        uint64_t v20 = v22;
        v22[5] = a2;
        v20[6] = a3;
        v20[7] = a4;
        v20[8] = a5;
        v20[9] = a6;
        uint64_t v14 = 166LL;
      }
    }

    sub_10005CFEC((_DWORD **)&v22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/dispatch.c", v14);
  }

  return v12;
}

uint64_t sub_100060F90(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6 = *(void **)(a1 + 16);
  if (!v6 || *v6 != qword_10008CF20) {
    return sub_100060E24(a1, a2, a3, a4, a5, a6);
  }
  v6[5] = a2;
  v6[6] = a3;
  v6[7] = a4;
  v6[8] = a5;
  v6[9] = a6;
  return 0LL;
}

uint64_t sub_100060FC8(uint64_t a1)
{
  unsigned int v1 = (_DWORD **)(a1 + 16);
  uint64_t v2 = *(void *)(a1 + 16);
  if (!v2 || *(void *)v2 != qword_10008CF20) {
    return 39LL;
  }
  uint64_t v11 = 0LL;
  sub_10005CFB8(&v11, v2);
  uint64_t v4 = qword_1000C56E0;
  if (qword_1000C56E0)
  {
    if (qword_1000C56E0 == v2)
    {
      uint64_t v6 = &qword_1000C56C0;
LABEL_10:
      uint64_t v7 = v6 + 4;
      sub_10005CFEC( (_DWORD **)v6 + 4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/dispatch.c",  228LL);
      sub_10005CFB8(v7, *(void *)(v2 + 32));
    }

    else
    {
      while (1)
      {
        uint64_t v5 = *(void *)(v4 + 32);
        if (!v5) {
          break;
        }
        uint64_t v6 = (uint64_t *)v4;
        uint64_t v4 = *(void *)(v4 + 32);
        if (v5 == v2) {
          goto LABEL_10;
        }
      }
    }
  }

  if (*(void *)(v2 + 32)) {
    sub_10005CFEC( (_DWORD **)(v2 + 32),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/dispatch.c",  235LL);
  }
  uint64_t v8 = *(void *)(v2 + 16);
  if (v8)
  {
    uint64_t v10 = *(void *)(v8 + 24);
    uint64_t v9 = (_DWORD **)(v8 + 24);
    if (v10 == v2) {
      sub_10005CFEC(v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/dispatch.c", 240LL);
    }
    sub_10005CFEC( (_DWORD **)(v2 + 16),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/dispatch.c",  241LL);
  }

  sub_10005CFEC((_DWORD **)(v2 + 24), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/dispatch.c", 243LL);
  sub_10005CFEC(v1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/dispatch.c", 244LL);
  sub_10005CFEC(&v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/dispatch.c", 245LL);
  return 0LL;
}

uint64_t sub_10006113C(__darwin_time_t *a1)
{
  return sub_10006114C(&qword_1000C56C0, a1);
}

uint64_t sub_10006114C(void *a1, __darwin_time_t *a2)
{
  uint64_t v16 = 0LL;
  if (a1)
  {
    unsigned int v3 = a1;
    uint64_t v4 = sub_10005CE50( (void **)&v16,  (void *)qword_10008CF50,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/dispatch.c",  264LL);
    if ((_DWORD)v4) {
      return v4;
    }
    do
    {
      uint64_t v5 = (uint64_t)v3;
      unsigned int v3 = (void *)v3[3];
    }

    while (v3);
    uint64_t v6 = sub_10005CFB8(v16 + 2, v5);
    if ((_DWORD)v6)
    {
      uint64_t v4 = v6;
      uint64_t v7 = 275LL;
LABEL_22:
      sub_10005CFEC((_DWORD **)&v16, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/dispatch.c", v7);
      return v4;
    }

    uint64_t v8 = sub_10005CFB8((void *)(v5 + 24), (uint64_t)v16);
    if ((_DWORD)v8)
    {
      uint64_t v4 = v8;
      uint64_t v7 = 283LL;
      goto LABEL_22;
    }

    a1 = v16;
  }

  uint64_t v4 = sub_1000612EC(a1, a2);
  if (!(_DWORD)v4)
  {
    while (1)
    {
      uint64_t v9 = v16;
      if (v16)
      {
        if (*((_DWORD *)v16 + 8)) {
          break;
        }
      }

      uint64_t v10 = sub_1000612EC(v16, a2);
      if ((_DWORD)v10) {
        return v10;
      }
    }

    uint64_t v11 = v16[2];
    if (v11)
    {
      uint64_t v13 = *(void *)(v11 + 24);
      uint64_t v12 = (_DWORD **)(v11 + 24);
      if (v13)
      {
        sub_10005CFEC(v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/dispatch.c", 298LL);
        uint64_t v9 = v16;
        uint64_t v14 = v16[3];
        if (v14)
        {
          sub_10005CFB8((void *)(v16[2] + 24LL), v14);
          uint64_t v9 = v16;
        }
      }

      sub_10005CFEC( (_DWORD **)v9 + 2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/dispatch.c",  304LL);
      uint64_t v9 = v16;
    }

    if (v9[3])
    {
      sub_10005CFEC( (_DWORD **)v9 + 3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/dispatch.c",  307LL);
      uint64_t v9 = v16;
    }

    uint64_t v4 = *((unsigned int *)v9 + 9);
    uint64_t v7 = 310LL;
    goto LABEL_22;
  }

  return v4;
}

uint64_t sub_1000612EC(void *a1, __darwin_time_t *a2)
{
  unsigned int v64 = 0LL;
  if (a1)
  {
    if (*a1 == qword_10008CF50) {
      unsigned int v3 = a1;
    }
    else {
      unsigned int v3 = 0LL;
    }
  }

  else
  {
    unsigned int v3 = 0LL;
  }

  memset(&v70, 0, sizeof(v70));
  if (a2)
  {
    gettimeofday(&v69, 0LL);
    xmmword_10008CE80 = (__int128)v69;
    __darwin_time_t v4 = *a2;
    if (*a2 < v69.tv_sec) {
      return 2LL;
    }
    __darwin_suseconds_t v5 = *((_DWORD *)a2 + 2);
    uint64_t v6 = v4 - v69.tv_sec;
    if (v4 == v69.tv_sec && v5 <= v69.tv_usec) {
      return 2LL;
    }
    uint64_t v67 = v4 - v69.tv_sec;
    int v68 = v5 - v69.tv_usec;
    if (v5 - v69.tv_usec < 0)
    {
      int v68 = v5 - v69.tv_usec + 1000000;
      uint64_t v67 = --v6;
    }

    if (v6 > 86400) {
      uint64_t v67 = 86400LL;
    }
  }

  if (v3 && *((_DWORD *)v3 + 8)) {
    return 0LL;
  }
  uint64_t v8 = qword_1000C56E0;
  *(void *)unsigned int v66 = qword_1000C56E0;
  if (!qword_1000C56E0) {
    return 29LL;
  }
  int v9 = 0;
  uint64_t v10 = &v67;
  if (!a2) {
    uint64_t v10 = 0LL;
  }
  int v61 = (timeval *)v10;
  __int128 v11 = 0uLL;
  do
  {
    *(_OWORD *)&v72.fds_bits[24] = v11;
    *(_OWORD *)&v72.fds_bits[28] = v11;
    *(_OWORD *)&v72.fds_bits[16] = v11;
    *(_OWORD *)&v72.fds_bits[20] = v11;
    *(_OWORD *)&v72.fds_bits[8] = v11;
    *(_OWORD *)&v72.fds_bits[12] = v11;
    *(_OWORD *)v72.fds_bits = v11;
    *(_OWORD *)&v72.fds_bits[4] = v11;
    *(_OWORD *)v71.fds_bits = v11;
    *(_OWORD *)&v71.fds_bits[4] = v11;
    *(_OWORD *)&v71.fds_bits[8] = v11;
    *(_OWORD *)&v71.fds_bits[12] = v11;
    *(_OWORD *)&v71.fds_bits[16] = v11;
    *(_OWORD *)&v71.fds_bits[20] = v11;
    *(_OWORD *)&v71.fds_bits[24] = v11;
    *(_OWORD *)&v71.fds_bits[28] = v11;
    do
    {
      uint64_t v12 = *(uint64_t (**)(void))(v8 + 40);
      if (v12)
      {
        if (*(void *)(v8 + 24))
        {
          int v13 = v12();
          if ((v13 & 0x80000000) == 0)
          {
            int v14 = v13;
            if (__darwin_check_fd_set_overflow(v13, &v72, 0)) {
              v72.fds_bits[v14 >> 5] |= 1 << v14;
            }
            if (v14 > v9) {
              int v9 = v14;
            }
          }
        }
      }

      uint64_t v15 = *(uint64_t (**)(void))(*(void *)v66 + 48LL);
      if (v15)
      {
        if (*(void *)(*(void *)v66 + 24LL))
        {
          int v16 = v15();
          if ((v16 & 0x80000000) == 0)
          {
            int v17 = v16;
            if (__darwin_check_fd_set_overflow(v16, &v71, 0)) {
              v71.fds_bits[v17 >> 5] |= 1 << v17;
            }
            if (v17 > v9) {
              int v9 = v17;
            }
          }
        }
      }

      uint64_t v8 = *(void *)(*(void *)v66 + 32LL);
      *(void *)unsigned int v66 = v8;
    }

    while (v8);
    v69.tv_sec = 0LL;
    v69.tv_usec = 0;
    fd_set v75 = v72;
    fd_set v74 = v71;
    fd_set v73 = v70;
    int v18 = select(v9 + 1, &v72, &v71, &v70, &v69);
    if (!v18)
    {
      uint64_t v19 = (void *)qword_10008CE90;
      if (qword_10008CE90)
      {
        do
        {
          uint64_t v20 = (void (*)(void))v19[1];
          if (v20) {
            v20(0LL);
          }
          uint64_t v19 = (void *)*v19;
        }

        while (v19);
      }

      fd_set v72 = v75;
      fd_set v71 = v74;
      fd_set v70 = v73;
      int v18 = select(v9 + 1, &v72, &v71, &v70, v61);
    }

    gettimeofday((timeval *)&xmmword_10008CE80, 0LL);
    if ((v18 & 0x80000000) == 0) {
      goto LABEL_83;
    }
    int v65 = 0LL;
    *(void *)unsigned int v66 = 0LL;
    uint64_t v21 = qword_1000C56E0;
    if (!qword_1000C56E0) {
      goto LABEL_83;
    }
LABEL_45:
    sub_10005CFB8(v66, v21);
    while (1)
    {
      if (!*(void *)v66)
      {
        if (v65) {
          sub_10005CFEC(&v65, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/dispatch.c", 507LL);
        }
LABEL_83:
        uint64_t v47 = qword_1000C56E0;
        *(void *)unsigned int v66 = qword_1000C56E0;
        if (!qword_1000C56E0) {
          return 0LL;
        }
        do
        {
          uint64_t v48 = *(void *)(v47 + 24);
          if (v48)
          {
            sub_10005CFB8(&v64, v48);
            uint64_t v49 = *(uint64_t (**)(_DWORD *))(*(void *)v66 + 40LL);
            if (v49)
            {
              int v50 = v49(v64);
              if ((v50 & 0x80000000) == 0)
              {
                unsigned int v51 = v50;
                if (__darwin_check_fd_set_overflow(v50, &v72, 0))
                {
                }
              }
            }

            unsigned int v52 = *(uint64_t (**)(_DWORD *))(*(void *)v66 + 48LL);
            if (v52)
            {
              int v53 = v52(v64);
              if ((v53 & 0x80000000) == 0)
              {
                unsigned int v54 = v53;
                if (__darwin_check_fd_set_overflow(v53, &v71, 0))
                {
                }
              }
            }

            sub_10005CFEC(&v64, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/dispatch.c", 530LL);
            uint64_t v47 = *(void *)v66;
          }

          uint64_t v47 = *(void *)(v47 + 32);
          *(void *)unsigned int v66 = v47;
        }

        while (v47);
        v63.tv_sec = 0LL;
        *(void *)unsigned int v66 = 0LL;
        if (!qword_1000C56E0) {
          return 0LL;
        }
        sub_10005CFB8(v66, qword_1000C56E0);
        int v55 = *(void **)v66;
        if (!*(void *)v66) {
          return 0LL;
        }
        while (1)
        {
          if (v55[3])
          {
            uint64_t v56 = (unsigned int (*)(void))v55[9];
            if (!v56 || !v56())
            {
              if (v63.tv_sec) {
                sub_10005CFEC(&v63, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/dispatch.c", 577LL);
              }
              sub_10005CFB8(&v63, *(uint64_t *)v66);
              goto LABEL_116;
            }

            int v55 = *(void **)v66;
          }

          unsigned int v62 = 0LL;
          uint64_t v57 = v55[4];
          if (v57)
          {
            sub_10005CFB8(&v62, v57);
            sub_10005CFEC( (_DWORD **)(*(void *)v66 + 32LL),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/dispatch.c",  551LL);
          }

          if (!v63.tv_sec) {
            break;
          }
          sub_10005CFEC( (_DWORD **)(v63.tv_sec + 32),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/dispatch.c",  554LL);
          unsigned int v58 = v62;
          if (v62)
          {
            timeval v59 = (uint64_t *)(v63.tv_sec + 32);
            goto LABEL_113;
          }

LABEL_116:
          int v65 = 0LL;
          uint64_t v60 = *(void *)(*(void *)v66 + 32LL);
          if (v60) {
            sub_10005CFB8(&v65, v60);
          }
          sub_10005CFEC( (_DWORD **)v66,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/dispatch.c",  592LL);
          if (v65)
          {
            sub_10005CFB8(v66, (uint64_t)v65);
            sub_10005CFEC(&v65, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/dispatch.c", 595LL);
          }

          int v55 = *(void **)v66;
          if (!*(void *)v66)
          {
            if (v63.tv_sec) {
              sub_10005CFEC(&v63, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/dispatch.c", 599LL);
            }
            return 0LL;
          }
        }

        sub_10005CFEC( (_DWORD **)&qword_1000C56E0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/dispatch.c",  560LL);
        unsigned int v58 = v62;
        if (v62)
        {
          timeval v59 = &qword_1000C56E0;
LABEL_113:
          sub_10005CFB8(v59, (uint64_t)v58);
        }

        else
        {
          sub_100067DF8((uint64_t)&qword_1000C56C0);
        }

        if (v62) {
          sub_10005CFEC(&v62, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/dispatch.c", 572LL);
        }
        goto LABEL_116;
      }

      memset(&v72, 0, sizeof(v72));
      memset(&v71, 0, sizeof(v71));
      v63.tv_usec = 0;
      v63.tv_sec = 0LL;
      int v22 = *(uint64_t (**)(void))(*(void *)v66 + 40LL);
      if (v22)
      {
        if (*(void *)(*(void *)v66 + 24LL))
        {
          int v23 = v22();
          if ((v23 & 0x80000000) == 0)
          {
            unsigned int v24 = v23;
            if (__darwin_check_fd_set_overflow(v23, &v72, 0)) {
              v72.fds_bits[v24 >> 5] |= 1 << v24;
            }
            if (select(v24 + 1, &v72, &v71, &v70, &v63) < 0) {
              break;
            }
          }
        }
      }

      memset(&v72, 0, sizeof(v72));
      memset(&v71, 0, sizeof(v71));
      v63.tv_usec = 0;
      v63.tv_sec = 0LL;
      unsigned int v32 = *(uint64_t (**)(void))(*(void *)v66 + 48LL);
      if (v32)
      {
        if (*(void *)(*(void *)v66 + 24LL))
        {
          int v33 = v32();
          if ((v33 & 0x80000000) == 0)
          {
            unsigned int v24 = v33;
            if (__darwin_check_fd_set_overflow(v33, &v71, 0)) {
              v71.fds_bits[v24 >> 5] |= 1 << v24;
            }
            if (select(v24 + 1, &v72, &v71, &v70, &v63) < 0) {
              break;
            }
          }
        }
      }

      if (v65) {
        sub_10005CFEC(&v65, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/dispatch.c", 500LL);
      }
      sub_10005CFB8(&v65, *(uint64_t *)v66);
      sub_10005CFEC((_DWORD **)v66, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/dispatch.c", 502LL);
      uint64_t v21 = *((void *)v65 + 4);
      if (v21) {
        goto LABEL_45;
      }
    }

    sub_10006221C("Bad descriptor %d.", v25, v26, v27, v28, v29, v30, v31, v24);
    uint64_t v34 = *(void *)v66;
    do
    {
      uint64_t v35 = v34;
      uint64_t v34 = *(void *)(v34 + 16);
    }

    while (v34);
    do
    {
      unsigned int v62 = 0LL;
      sub_1000683F8(v35, 0, "name");
      if (v62 && (uint64_t v43 = *((void *)v62 + 2)) != 0 && *(_DWORD *)(v43 + 4) == 1) {
        int v44 = *(_DWORD *)(v43 + 8);
      }
      else {
        int v44 = 0;
      }
      sub_10006221C("Object %lx %s%s%.*s", v36, v37, v38, v39, v40, v41, v42, v35);
      if (v44) {
        sub_10005D71C((int ***)&v62, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/dispatch.c", 466LL);
      }
      uint64_t v35 = *(void *)(v35 + 24);
    }

    while (v35);
    (*(void (**)(void))(*(void *)v66 + 72LL))(*(void *)(*(void *)v66 + 24LL));
    if (v65)
    {
      sub_10005CFEC( (_DWORD **)v65 + 4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/dispatch.c",  470LL);
      uint64_t v45 = *(void *)(*(void *)v66 + 32LL);
      if (v45)
      {
        uint64_t v46 = (uint64_t *)(v65 + 8);
        goto LABEL_78;
      }
    }

    else
    {
      sub_10005CFEC( (_DWORD **)&qword_1000C56E0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/dispatch.c",  476LL);
      uint64_t v45 = *(void *)(*(void *)v66 + 32LL);
      if (v45)
      {
        uint64_t v46 = &qword_1000C56E0;
LABEL_78:
        sub_10005CFB8(v46, v45);
      }
    }

    sub_10005CFEC((_DWORD **)v66, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/dispatch.c", 482LL);
    uint64_t v8 = qword_1000C56E0;
    *(void *)unsigned int v66 = qword_1000C56E0;
    uint64_t result = 29LL;
    __int128 v11 = 0uLL;
  }

  while (qword_1000C56E0);
  return result;
}

uint64_t sub_100061C58(void *a1)
{
  if (*a1 != qword_10008CF20) {
    return 39LL;
  }
  uint64_t v2 = a1[3];
  else {
    return 23LL;
  }
}

uint64_t sub_100061C98(void *a1)
{
  if (*a1 != qword_10008CF20) {
    return 39LL;
  }
  uint64_t v2 = a1[3];
  else {
    return 23LL;
  }
}

uint64_t sub_100061CD8(void *a1)
{
  uint64_t v7 = 0LL;
  if (*a1 != qword_10008CF20) {
    return 39LL;
  }
  uint64_t v2 = qword_1000C56E0;
  if (!qword_1000C56E0) {
    return 23LL;
  }
  if ((void *)qword_1000C56E0 != a1)
  {
    while (1)
    {
      unsigned int v3 = *(void **)(v2 + 32);
      if (!v3) {
        return 23LL;
      }
      uint64_t v4 = v2;
      uint64_t v2 = *(void *)(v2 + 32);
      if (v3 == a1) {
        goto LABEL_10;
      }
    }
  }

  uint64_t v4 = 0LL;
LABEL_10:
  sub_10005CFB8(&v7, (uint64_t)a1);
  if (v4) {
    __darwin_suseconds_t v5 = (uint64_t *)(v4 + 32);
  }
  else {
    __darwin_suseconds_t v5 = &qword_1000C56E0;
  }
  sub_10005CFEC((_DWORD **)v5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/dispatch.c", 658LL);
  uint64_t v6 = *((void *)v7 + 4);
  if (v6)
  {
    sub_10005CFB8(v5, v6);
    sub_10005CFEC((_DWORD **)v7 + 4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/dispatch.c", 662LL);
  }

  return sub_10005CFEC(&v7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/dispatch.c", 665LL);
}

uint64_t sub_100061DDC(void *a1)
{
  if (*a1 != qword_10008CF20) {
    return 39LL;
  }
  uint64_t v2 = a1[3];
  else {
    return 23LL;
  }
}

uint64_t sub_100061E1C(uint64_t a1, uint64_t a2, void *a3)
{
  if (*a3 != qword_10008CF20) {
    return 39LL;
  }
  uint64_t v4 = a3[3];
  else {
    return 0LL;
  }
}

uint64_t sub_100061E5C(uint64_t a1, char *__s1, _DWORD *a3)
{
  if (*(void *)a1 != qword_10008CF50) {
    return 39LL;
  }
  uint64_t result = strcmp(__s1, "ready");
  if (!(_DWORD)result)
  {
    uint64_t v8 = 1LL;
LABEL_12:
    *(void *)(a1 + 32) = v8;
    return result;
  }

  uint64_t result = strcmp(__s1, "status");
  if (!(_DWORD)result)
  {
    *(_DWORD *)(a1 + 32) = 1;
    *(_DWORD *)(a1 + 36) = *a3;
    return result;
  }

  uint64_t result = strcmp(__s1, "disconnect");
  if (!(_DWORD)result)
  {
    uint64_t v8 = 0x4400000001LL;
    goto LABEL_12;
  }

  uint64_t v6 = *(void *)(a1 + 24);
  else {
    return 23LL;
  }
}

uint64_t sub_100061F60(uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2)
{
  uint64_t v2 = qword_1000C56E0;
  if (!qword_1000C56E0) {
    return 0LL;
  }
  while (1)
  {
    uint64_t v5 = *(void *)(v2 + 24);
    if (v5)
    {
      uint64_t result = a1(v5, a2);
      if ((_DWORD)result) {
        break;
      }
    }

    uint64_t v2 = *(void *)(v2 + 32);
    if (!v2) {
      return 0LL;
    }
  }

  return result;
}

void sub_100061FB4( _BYTE *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (dword_10008BBA0)
  {
    size_t v16 = strlen(byte_1000C5B10);
    write(2, byte_1000C5B10, v16);
    write(2, "\n", 1uLL);
  }

  sub_10006221C("%s", v9, v10, v11, v12, v13, v14, v15, (char)&byte_1000728D2);
  sub_10006221C("If you did not get this software from ftp.isc.org, please", v17, v18, v19, v20, v21, v22, v23, v130);
  sub_10006221C("get the latest from ftp.isc.org and install that before", v24, v25, v26, v27, v28, v29, v30, v131);
  sub_10006221C("requesting help.", v31, v32, v33, v34, v35, v36, v37, v132);
  sub_10006221C("%s", v38, v39, v40, v41, v42, v43, v44, (char)&byte_1000728D2);
  sub_10006221C("If you did get this software from ftp.isc.org and have not", v45, v46, v47, v48, v49, v50, v51, v133);
  sub_10006221C("yet read the README, please read it before requesting help.", v52, v53, v54, v55, v56, v57, v58, v134);
  sub_10006221C("If you intend to request help from the dhcp-server@isc.org", v59, v60, v61, v62, v63, v64, v65, v135);
  sub_10006221C("mailing list, please read the section on the README about", v66, v67, v68, v69, v70, v71, v72, v136);
  sub_10006221C("submitting bug reports and requests for help.", v73, v74, v75, v76, v77, v78, v79, v137);
  sub_10006221C("%s", v80, v81, v82, v83, v84, v85, v86, (char)&byte_1000728D2);
  sub_10006221C("Please do not under any circumstances send requests for", v87, v88, v89, v90, v91, v92, v93, v138);
  sub_10006221C("help directly to the authors of this software - please", v94, v95, v96, v97, v98, v99, v100, v139);
  sub_10006221C( "send them to the appropriate mailing list as described in",  v101,  v102,  v103,  v104,  v105,  v106,  v107,  v140);
  sub_10006221C("the README file.", v108, v109, v110, v111, v112, v113, v114, v141);
  sub_10006221C("%s", v115, v116, v117, v118, v119, v120, v121, (char)&byte_1000728D2);
  uint64_t v129 = sub_10006221C("exiting.", v122, v123, v124, v125, v126, v127, v128, v142);
  if (off_10008CE98) {
    off_10008CE98(v129);
  }
  exit(1);
}

size_t sub_10006214C(size_t result, _BYTE *a2)
{
  uint64_t v2 = (char *)result;
  int v3 = *a2;
  if (*a2)
  {
    int v4 = 0;
    BOOL v5 = 0;
    uint64_t v6 = a2 + 1;
    while (v5)
    {
      if (v3 != 109)
      {
        if (v4 > 1022) {
          goto LABEL_16;
        }
        BOOL v5 = 0;
        goto LABEL_14;
      }

      uint64_t v7 = __error();
      uint64_t v8 = strerror(*v7);
      if (v8) {
        uint64_t v9 = v8;
      }
      else {
        uint64_t v9 = "<unknown error>";
      }
      uint64_t result = strlen(v9);
      v4 += result;
      if (v4 > 1023) {
        goto LABEL_16;
      }
      strcpy(v2 - 1, v9);
      uint64_t result = strlen(v2);
      BOOL v5 = 0;
      v2 += result;
LABEL_15:
      int v10 = *v6++;
      int v3 = v10;
      if (!v10) {
        goto LABEL_16;
      }
    }

    if (v4 > 1022) {
      goto LABEL_16;
    }
    BOOL v5 = v3 == 37;
LABEL_14:
    ++v4;
    *v2++ = v3;
    goto LABEL_15;
  }

uint64_t sub_10006221C( _BYTE *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (dword_10008BBA0)
  {
    size_t v9 = strlen(byte_1000C5B10);
    write(2, byte_1000C5B10, v9);
    write(2, "\n", 1uLL);
  }

  return 0LL;
}

uint64_t sub_1000622D4( _BYTE *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (dword_10008BBA0)
  {
    size_t v9 = strlen(byte_1000C5B10);
    write(2, byte_1000C5B10, v9);
    write(2, "\n", 1uLL);
  }

  return 0LL;
}

uint64_t sub_10006238C( _BYTE *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (dword_10008BBA0)
  {
    size_t v9 = strlen(byte_1000C5B10);
    write(2, byte_1000C5B10, v9);
    write(2, "\n", 1uLL);
  }

  return 0LL;
}

uint64_t sub_100062444(void **a1, uint64_t a2, uint64_t a3)
{
  return sub_10005CE50(a1, (void *)qword_10008CF18, 0LL, a2, a3);
}

uint64_t sub_100062460(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4)
{
  if (*(void *)a1 != qword_10008CF18) {
    return 39LL;
  }
  if (*(int *)(a1 + 48) >= 1)
  {
    uint64_t v9 = 0LL;
    int v10 = -1;
    while (sub_100068604((uint64_t)a3, *(void *)(*(void *)(*(void *)(a1 + 32) + 8 * v9) + 8LL)))
    {
      if (v10 == -1)
      {
        if (*(void *)(*(void *)(a1 + 32) + 8 * v9)) {
          int v10 = -1;
        }
        else {
          int v10 = v9;
        }
      }
    }

    uint64_t v31 = 0LL;
    uint64_t v4 = sub_10005D6B8(&v31);
    if (!(_DWORD)v4)
    {
      sub_10005D504(v31 + 1, a3);
      if (a4) {
        sub_10005D504(v31 + 2, a4);
      }
      sub_10005D71C( (int ***)(*(void *)(a1 + 32) + 8 * v9),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/generic.c",  94LL);
      uint64_t v4 = sub_10005D504((void *)(*(void *)(a1 + 32) + 8 * v9), v31);
      sub_10005D71C(&v31, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/generic.c", 97LL);
      *(_BYTE *)(*(void *)(a1 + 40) + v9) = 1;
    }

    return v4;
  }

  int v10 = -1;
LABEL_14:
  uint64_t v11 = *(void *)(a1 + 24);
  if (!v11 || (v12 = *(uint64_t (**)(void))(*(void *)v11 + 16LL)) == 0LL || (uint64_t v4 = v12(), (_DWORD)v4 == 23))
  {
    if (v10 == -1)
    {
      int v10 = *(_DWORD *)(a1 + 48);
      if (v10 == *(_DWORD *)(a1 + 52))
      {
        if (v10) {
          size_t v13 = (2 * v10);
        }
        else {
          size_t v13 = 10LL;
        }
        uint64_t v14 = (char *)sub_10005CDE4((8 * v13));
        if (v14)
        {
          uint64_t v15 = v14;
          size_t v16 = (char *)sub_10005CDE4(v13);
          if (v16)
          {
            uint64_t v22 = v16;
            uint64_t v23 = *(int *)(a1 + 52);
            if ((_DWORD)v23)
            {
              memcpy(v15, *(const void **)(a1 + 32), 8 * v23);
              memcpy(v22, *(const void **)(a1 + 40), *(int *)(a1 + 52));
              LODWORD(v23) = *(_DWORD *)(a1 + 52);
            }

            bzero(&v15[8 * (int)v23], 8LL * ((int)v13 - (int)v23));
            bzero(&v22[*(int *)(a1 + 52)], (int)v13 - (uint64_t)*(int *)(a1 + 52));
            uint64_t v29 = *(void **)(a1 + 32);
            if (v29) {
              sub_10005CE20( v29,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/generic.c",  149LL,  v24,  v25,  v26,  v27,  v28);
            }
            uint64_t v30 = *(void **)(a1 + 40);
            if (v30) {
              sub_10005CE20( v30,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/generic.c",  151LL,  v24,  v25,  v26,  v27,  v28);
            }
            *(void *)(a1 + 32) = v15;
            *(void *)(a1 + 4__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = v22;
            *(_DWORD *)(a1 + 52) = v13;
            goto LABEL_31;
          }

          sub_10005CE20( v15,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/generic.c",  135LL,  v17,  v18,  v19,  v20,  v21);
        }

        return 1LL;
      }
    }

LABEL_31:
    uint64_t v4 = sub_10005D6B8((void *)(*(void *)(a1 + 32) + 8LL * v10));
    if (!(_DWORD)v4)
    {
      sub_10005D504((void *)(*(void *)(*(void *)(a1 + 32) + 8LL * v10) + 8LL), a3);
      if (a4) {
        sub_10005D504((void *)(*(void *)(*(void *)(a1 + 32) + 8LL * v10) + 16LL), a4);
      }
      *(_BYTE *)(*(void *)(a1 + 40) + v1__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = 1;
      uint64_t v4 = 0LL;
      if (v10 == *(_DWORD *)(a1 + 48)) {
        *(_DWORD *)(a1 + 48) = v10 + 1;
      }
    }
  }

  return v4;
}

              if (++v18 < v6) {
                continue;
              }
              break;
            }
          }

          uint64_t v31 = 2;
LABEL_34:
          *__error() = v31;
LABEL_35:
          if (a5 && (unint64_t)v16 < v36 && (uint64_t)&v15[-v9] < 0x4000)
          {
            *size_t v16 = v15;
            v16[1] = 0LL;
            ++v16;
          }
        }

        memcpy(v15, v7, v17 + 1);
        v7 += v17 + 1;
        v15 += v17 + 1;
        if (!(_DWORD)v17) {
          return ((_DWORD)v15 - v35);
        }
      }

uint64_t sub_1000627A0(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (*(void *)a1 != qword_10008CF18) {
    return 39LL;
  }
  int v8 = *(_DWORD *)(a1 + 48);
  if (v8 < 1)
  {
LABEL_9:
    uint64_t v11 = *(void *)(a1 + 24);
    if (v11)
    {
      uint64_t v12 = *(uint64_t (**)(void))(*(void *)v11 + 24LL);
      if (v12) {
        return v12();
      }
    }

    return 23LL;
  }

  uint64_t v9 = 0LL;
  while (1)
  {
    uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 8 * v9);
    if (v10) {
      break;
    }
LABEL_8:
    if (++v9 >= v8) {
      goto LABEL_9;
    }
  }

  if (sub_100068604(a3, *(void *)(v10 + 8)))
  {
    int v8 = *(_DWORD *)(a1 + 48);
    goto LABEL_8;
  }

  uint64_t v13 = *(void *)(*(void *)(a1 + 32) + 8 * v9);
  if (*(void *)(v13 + 16)) {
    return sub_10005D504(a4, (_DWORD *)v13);
  }
  return 23LL;
}

uint64_t sub_1000628A0( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)a1 != qword_10008CF18) {
    return 34LL;
  }
  uint64_t v10 = (uint64_t *)(a1 + 32);
  uint64_t result = *(void *)(a1 + 32);
  if (result)
  {
    int v13 = *(_DWORD *)(a1 + 48);
    if (v13 >= 1)
    {
      uint64_t v14 = 0LL;
      for (uint64_t i = 0LL; i < v13; ++i)
      {
        size_t v16 = (int ***)(*v10 + v14);
        if (*v16)
        {
          sub_10005D71C(v16, a2, a3);
          int v13 = *(_DWORD *)(a1 + 48);
        }

        v14 += 8LL;
      }

      uint64_t result = *v10;
    }

    sub_10005CE20((void *)result, a2, a3, a4, a5, a6, a7, a8);
    sub_10005CE20(*(void **)(a1 + 40), a2, a3, v17, v18, v19, v20, v21);
    uint64_t result = 0LL;
    *(_DWORD *)(a1 + 52) = 0;
    *uint64_t v10 = 0LL;
    v10[1] = 0LL;
  }

  return result;
}

uint64_t sub_100062970(void *a1)
{
  if (*a1 != qword_10008CF18) {
    return 39LL;
  }
  uint64_t v2 = a1[3];
  else {
    return 23LL;
  }
}

uint64_t sub_1000629B0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)a3 != qword_10008CF18) {
    return 39LL;
  }
  int v7 = *(_DWORD *)(a3 + 48);
  if (v7 >= 1)
  {
    for (uint64_t i = 0LL; i < v7; ++i)
    {
      uint64_t v9 = *(void *)(*(void *)(a3 + 32) + 8 * i);
      if (v9)
      {
        unsigned int v10 = *(_DWORD *)(*(void *)(v9 + 8) + 4LL);
        if (v10)
        {
          if (*(_BYTE *)(*(void *)(a3 + 40) + i))
          {
            uint64_t result = sub_10005EFD8(a1, v10);
            if ((_DWORD)result) {
              return result;
            }
            uint64_t v11 = *(void *)(*(void *)(*(void *)(a3 + 32) + 8 * i) + 8LL);
            uint64_t result = sub_10005E7A4(a1, v11 + 8, *(_DWORD *)(v11 + 4));
            if ((_DWORD)result) {
              return result;
            }
            uint64_t result = sub_10005F008(a1, *(_DWORD **)(*(void *)(*(void *)(a3 + 32) + 8 * i) + 16LL));
            if ((_DWORD)result) {
              return result;
            }
            int v7 = *(_DWORD *)(a3 + 48);
          }
        }
      }
    }
  }

  uint64_t v12 = *(void *)(a3 + 24);
  else {
    return 0LL;
  }
}

uint64_t sub_100062AB4(uint64_t a1)
{
  if (*(void *)a1 != qword_10008CF18) {
    return 39LL;
  }
  if (*(int *)(a1 + 48) >= 1)
  {
    uint64_t v3 = 0LL;
    uint64_t v4 = 0LL;
    do
    {
      *(_BYTE *)(*(void *)(a1 + 40) + v4) = 0;
      BOOL v5 = (int ***)(*(void *)(a1 + 32) + v3);
      if (*v5)
      {
        if (!(*v5)[2]) {
          sub_10005D71C(v5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/generic.c", 302LL);
        }
      }

      ++v4;
      v3 += 8LL;
    }

    while (v4 < *(int *)(a1 + 48));
  }

  return 0LL;
}

uint64_t sub_100062B58(_DWORD *a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a2 + 12);
  if (v3)
  {
    uint64_t v4 = 0LL;
    *a1 = v3;
    return v4;
  }

  uint64_t v7 = qword_10008CEA8;
  if (qword_10008CEA8)
  {
    unsigned int v8 = *(_DWORD *)(qword_10008CEA8 + 4);
  }

  else
  {
    uint64_t v9 = sub_10005CDE4(0x3D0uLL);
    qword_10008CEA8 = (uint64_t)v9;
    uint64_t v4 = 1LL;
    if (!v9) {
      return v4;
    }
    bzero(v9, 0x3D0uLL);
    uint64_t v7 = qword_10008CEA8;
    *(void *)qword_10008CEA8 = 0x7800000000LL;
    *(_DWORD *)(v7 + 12) = 1;
    unsigned int v8 = 120;
  }

  uint64_t v10 = dword_10008BBA4;
  if (dword_10008BBA4 >= v8)
  {
    do
    {
      uint64_t v11 = sub_10005CDE4(0x3D0uLL);
      if (!v11) {
        return 1LL;
      }
      uint64_t v7 = (uint64_t)v11;
      bzero(v11, 0x3D0uLL);
      uint64_t v12 = qword_10008CEA8;
      unsigned int v13 = 120 * *(_DWORD *)(qword_10008CEA8 + 4);
      *(_DWORD *)uint64_t v7 = 0;
      *(_DWORD *)(v7 + 4) = v13;
      *(_DWORD *)(v7 + 12) = 0;
      *(void *)(v7 + 16) = v12;
      qword_10008CEA8 = v7;
      uint64_t v10 = dword_10008BBA4;
    }

    while (dword_10008BBA4 >= v13);
  }

  uint64_t v14 = sub_100062CB4(v10, (unsigned int *)v7, a2);
  if ((_DWORD)v14 == 19)
  {
    uint64_t v14 = sub_100062CB4(dword_10008BBA4, (unsigned int *)qword_10008CEA8, a2);
  }

  uint64_t v4 = v14;
  if (!(_DWORD)v14) {
    *a1 = dword_10008BBA4++;
  }
  return v4;
}

uint64_t sub_100062CB4(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  unsigned int v3 = *a2;
  if (*a2 <= a1)
  {
    uint64_t v6 = a2;
    do
    {
      unsigned int v8 = v6[1];
      if (v6[3])
      {
        uint64_t result = sub_10005CFB8(&v6[2 * (a1 - v3) + 4], a3);
        if (!(_DWORD)result) {
          *(_DWORD *)(a3 + 12) = a1;
        }
        return result;
      }

      unsigned int v9 = v8 - v3;
      unsigned int v10 = (v8 - v3) / 0x78;
      unsigned int v11 = (a1 - v3) / v10;
      uint64_t v12 = &v6[2 * v11];
      uint64_t v15 = (int *)*((void *)v12 + 2);
      unsigned int v13 = (unsigned int **)(v12 + 4);
      uint64_t v14 = v15;
      if (!v15)
      {
        size_t v16 = (int *)sub_10005CDE4(0x3D0uLL);
        if (!v16) {
          return 1LL;
        }
        uint64_t v14 = v16;
        bzero(v16, 0x3D0uLL);
        int v17 = *v6 + v11 * v10;
        *uint64_t v14 = v17;
        v14[1] = v17 + v10;
        if (v9 - 14400 <= 0x77) {
          v14[3] = 1;
        }
        *unsigned int v13 = (unsigned int *)v14;
      }

      uint64_t result = sub_100062CB4(a1, v14, a3);
      if ((_DWORD)result != 19) {
        return result;
      }
      uint64_t v6 = *v13;
      unsigned int v3 = **v13;
    }

    while (v3 <= a1);
  }

  return 19LL;
}

uint64_t sub_100062E04(unsigned int **a1)
{
  uint64_t v2 = *a1;
  unsigned int v3 = **a1;
  unsigned int v4 = (*a1)[1];
  BOOL v5 = (unsigned int *)sub_10005CDE4(0x3D0uLL);
  if (!v5) {
    return 1LL;
  }
  uint64_t v6 = v5;
  unsigned int v7 = 120 * (v3 - v4);
  unsigned int v8 = -(v3 % v7) / 0x78;
  unsigned int v9 = v3 - v3 % v7;
  bzero(v5, 0x3D0uLL);
  *uint64_t v6 = v9;
  v6[1] = v9 + v7;
  if (v7 == 120) {
    v6[3] = 0;
  }
  uint64_t result = 0LL;
  *(void *)&v6[2 * v8 + 4] = v2;
  *a1 = v6;
  return result;
}

uint64_t sub_100062EB4(void *a1, unsigned int a2)
{
  return sub_100062EC4(a1, a2, (_DWORD *)qword_10008CEA8, 0);
}

uint64_t sub_100062EC4(void *a1, unsigned int a2, _DWORD *a3, int a4)
{
  for (; a3; a3 = *(_DWORD **)&a3[2 * (v4 / ((v5 - *a3) / 0x78)) + 4])
  {
    unsigned int v4 = a2 - *a3;
    if (a2 < *a3) {
      break;
    }
    unsigned int v5 = a3[1];
    if (v5 <= a2) {
      break;
    }
    if (a3[3])
    {
      uint64_t v6 = &a3[2 * v4];
      uint64_t v9 = *((void *)v6 + 2);
      unsigned int v8 = v6 + 4;
      uint64_t v7 = v9;
      if (!v9) {
        return 23LL;
      }
      if (a4 != 1) {
        return sub_10005CFB8(a1, v7);
      }
      uint64_t result = 0LL;
      *unsigned int v8 = 0LL;
      return result;
    }
  }

  return 23LL;
}

uint64_t sub_100062F48(void *a1, _DWORD *a2)
{
  int v2 = a2[1];
  if (v2 == 2)
  {
    if (a2[2] == 4)
    {
      unsigned int v3 = bswap32(a2[3]);
      return sub_100062EC4(a1, v3, (_DWORD *)qword_10008CEA8, 0);
    }
  }

  else if (!v2)
  {
    unsigned int v3 = a2[2];
    return sub_100062EC4(a1, v3, (_DWORD *)qword_10008CEA8, 0);
  }

  return 39LL;
}

uint64_t sub_100062F8C(unsigned int a1)
{
  return sub_100062EC4(0LL, a1, (_DWORD *)qword_10008CEA8, 1);
}

uint64_t sub_100062FA4( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    unsigned int v8 = a2;
    if (*a1) {
      sub_10006221C("%s(%d): non-null target for new_hash_table.", a2, a3, a4, a5, a6, a7, a8, a3);
    }
    if (v8 >= 2) {
      size_t v10 = 8 * v8 + 40;
    }
    else {
      size_t v10 = 48LL;
    }
    uint64_t result = (uint64_t)sub_10005CDE4(v10);
    if (result)
    {
      *(_DWORD *)uint64_t result = v8;
      *a1 = result;
      return 1LL;
    }
  }

  else
  {
    sub_10006221C("%s(%d): new_hash_table called with null pointer.", a2, a3, a4, a5, a6, a7, a8, a3);
    return 0LL;
  }

  return result;
}

void sub_100063044( void **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *a1 = 0LL;
}

uint64_t *sub_100063078()
{
  uint64_t result = (uint64_t *)qword_10008CEB0;
  if (!qword_10008CEB0)
  {
    uint64_t result = (uint64_t *)sub_10005CDE4(0xFE0uLL);
    if (!result) {
      return result;
    }
    uint64_t v1 = 0LL;
    uint64_t v2 = qword_10008CEB0;
    unsigned int v3 = result;
    do
    {
      result[v1] = v2;
      qword_10008CEB0 = (uint64_t)&result[v1];
      uint64_t v2 = (uint64_t)v3;
      v3 += 4;
      v1 += 4LL;
    }

    while ((_DWORD)(v1 * 8) != 4064);
    uint64_t result = &result[v1 - 4];
  }

  qword_10008CEB0 = *result;
  return result;
}

void *sub_1000630EC(void *result)
{
  uint64_t *result = qword_10008CEB0;
  qword_10008CEB0 = (uint64_t)result;
  return result;
}

uint64_t sub_100063100( uint64_t *a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t (*a5)(char *a1, int a2, unsigned int a3), uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a4) {
    uint64_t v12 = a4;
  }
  else {
    uint64_t v12 = 9973LL;
  }
  uint64_t result = sub_100062FA4(a1, v12, a6, a7, (uint64_t)a5, a6, a7, a8);
  if ((_DWORD)result)
  {
    bzero((void *)(*a1 + 40), 8LL * v12);
    *(void *)(*a1 + 8) = a2;
    *(void *)(*a1 + 16) = a3;
    *(void *)(*a1 + 32) = a5;
    if (a5 == sub_1000631AC) {
      uint64_t v14 = sub_100063224;
    }
    else {
      uint64_t v14 = &_memcmp;
    }
    *(void *)(*a1 + 24) = v14;
    return 1LL;
  }

  return result;
}

uint64_t sub_1000631AC(char *a1, int a2, unsigned int a3)
{
  if (a2)
  {
    int v4 = a2;
    unsigned int v6 = 0;
    do
    {
      int v7 = *a1++;
      __darwin_ct_rune_t v8 = v7;
      if ((v7 & 0x80000000) == 0) {
        __darwin_ct_rune_t v8 = __tolower(v8);
      }
      unsigned int v6 = v8 + 2 * v6;
      if (v6 >= 0x10000)
      {
        do
          unsigned int v6 = HIWORD(v6) + (unsigned __int16)v6;
        while (HIWORD(v6));
      }

      --v4;
    }

    while (v4);
  }

  else
  {
    unsigned int v6 = 0;
  }

  return v6 % a3;
}

uint64_t sub_100063224(char *a1, char *a2, uint64_t a3)
{
  if (!a3) {
    return 0LL;
  }
  uint64_t v4 = a3;
  while (1)
  {
    int v7 = *a1++;
    __darwin_ct_rune_t v8 = v7;
    if ((v7 & 0x80000000) == 0) {
      __darwin_ct_rune_t v8 = __tolower(v8);
    }
    __darwin_ct_rune_t v9 = *a2;
    if ((*a2 & 0x80000000) == 0) {
      __darwin_ct_rune_t v9 = __tolower(v9);
    }
    unsigned int v10 = v8 > v9 ? 1 : v3;
    uint64_t v3 = v8 < v9 ? 0xFFFFFFFFLL : v10;
    if (v8 != v9) {
      break;
    }
    ++a2;
    if (!--v4) {
      return 0LL;
    }
  }

  return v3;
}

uint64_t sub_1000632A8(unsigned __int8 *a1, int a2, unsigned int a3)
{
  for (unsigned int i = 0; a2; --a2)
  {
    int v4 = *a1++;
    unsigned int i = v4 + 2 * i;
    if (i >= 0x10000)
    {
      do
        unsigned int i = HIWORD(i) + (unsigned __int16)i;
      while (HIWORD(i));
    }
  }

  return i % a3;
}

uint64_t sub_1000632E4(unsigned __int8 *a1, unsigned int a2, unsigned int a3)
{
  if (!a2) {
    return 0LL;
  }
  unsigned int v3 = 0;
  int v4 = &a1[a2];
  if (a2 % 3 == 1) {
    goto LABEL_5;
  }
  if (a2 % 3 == 2)
  {
    int v5 = *a1++;
    unsigned int v3 = v5 << 8;
LABEL_5:
    int v6 = *a1++;
    v3 |= v6;
  }

  for (; a1 < v4; a1 += 3)
    v3 ^= (*a1 << 16) | (a1[1] << 8) | a1[2];
  return v3 % a3;
}

uint64_t sub_100063370(_DWORD *a1, uint64_t a2, unsigned int a3)
{
  return *a1 % a3;
}

uint64_t sub_100063380(unsigned int *a1, uint64_t a2, unsigned int a3)
{
  return bswap32(*a1) % a3;
}

const char *sub_100063394(unsigned int *a1)
{
  if (!a1) {
    return "No table.";
  }
  uint64_t v1 = *a1;
  if (!(_DWORD)v1) {
    return "Invalid hash table.";
  }
  uint64_t v2 = 0LL;
  unsigned int v3 = 0;
  unsigned int v4 = 0;
  unsigned int v5 = -1;
  do
  {
    int v6 = &a1[2 * v2 + 10];
    unsigned int v7 = 100 * v4 - 100;
    unsigned int v8 = -1;
    do
    {
      int v6 = *(unsigned int **)v6;
      ++v8;
      v7 += 100;
    }

    while (v6);
    if (v8 < v5) {
      unsigned int v5 = v8;
    }
    if (v8 > v3) {
      unsigned int v3 = v8;
    }
    v4 += v8;
    ++v2;
  }

  while (v2 != v1);
  if (v4 <= 0x28F5C27)
  {
    unsigned int v9 = v7 / v1;
  }

  else
  {
    if ((v4 & 0x80000000) != 0) {
      return "Report out of range for display.";
    }
    unsigned int v9 = v4 / (v1 / 0x64 + 1);
  }

  unsigned int v10 = "Report out of range for display.";
  if ((v1 & 0x80000000) == 0 && (v9 & 0x80000000) == 0 && (v5 & 0x80000000) == 0 && (v3 & 0x80000000) == 0)
  {
    unsigned int v10 = byte_1000C5F10;
    __sprintf_chk(byte_1000C5F10, 0, 0x57uLL, "Contents/Size (%%): %u/%u (%u%%). Min/max: %u/%u", v4, v1, v9, v5, v3);
  }

  return v10;
}

uint64_t sub_1000634B8( uint64_t result, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (result)
  {
    size_t v12 = a3;
    uint64_t v14 = (unsigned int *)result;
    if (!(_DWORD)a3) {
      size_t v12 = sub_1000635A0( a2,  *(uint64_t (**)(unsigned __int8 *, int, unsigned int))(result + 32),  a3,  a4,  a5,  a6,  a7,  a8);
    }
    int v15 = (*((uint64_t (**)(const char *, size_t, void))v14 + 4))(a2, v12, *v14);
    size_t v16 = sub_100063078();
    if (v16)
    {
      uint64_t v24 = v16;
      v16[1] = (uint64_t)a2;
      uint64_t v25 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))*((void *)v14 + 1);
      uint64_t result = (uint64_t)(v16 + 3);
      if (v25) {
        uint64_t result = v25(result, a4, a5, a6);
      }
      else {
        *(void *)uint64_t result = a4;
      }
      uint64_t v26 = &v14[2 * v15];
      *uint64_t v24 = *((void *)v26 + 5);
      *((_DWORD *)v24 + 4) = v12;
      *((void *)v26 + 5) = v24;
    }

    else
    {
      return sub_10006221C("Can't add entry to hash table: no memory.", v17, v18, v19, v20, v21, v22, v23, a9);
    }
  }

  return result;
}

size_t sub_1000635A0( const char *a1, uint64_t (*a2)(unsigned __int8 *a1, int a2, unsigned int a3), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t result = 4LL;
  if ((char *)a2 != (char *)sub_100063370 && (char *)a2 != (char *)sub_100063380)
  {
    sub_10006238C( "Unexpected hash function at %s:%d.",  (uint64_t)a2,  a3,  a4,  a5,  a6,  a7,  a8,  (char)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/hash.c");
    return 0LL;
  }

  return result;
}

uint64_t sub_100063620( uint64_t result, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    size_t v10 = a3;
    size_t v12 = (unsigned int *)result;
    if (!(_DWORD)a3) {
      size_t v10 = sub_1000635A0( a2,  *(uint64_t (**)(unsigned __int8 *, int, unsigned int))(result + 32),  a3,  a4,  a5,  a6,  a7,  a8);
    }
    size_t result = (*((uint64_t (**)(const char *, size_t, void))v12 + 4))(a2, v10, *v12);
    unsigned int v13 = &v12[2 * (int)result];
    uint64_t v16 = *((void *)v13 + 5);
    int v15 = v13 + 10;
    uint64_t v14 = v16;
    if (v16)
    {
      uint64_t v17 = 0LL;
      while (1)
      {
        uint64_t v18 = (void *)v14;
        int v19 = *(_DWORD *)(v14 + 16);
        if (!v19)
        {
          size_t result = strcmp(*(const char **)(v14 + 8), a2);
          if (!(_DWORD)result) {
            break;
          }
        }

        if (v19 == (_DWORD)v10)
        {
          size_t result = (*((uint64_t (**)(void, const char *, void))v12 + 3))(v18[1], a2, v10);
          if (!(_DWORD)result) {
            break;
          }
        }

        uint64_t v14 = *v18;
        uint64_t v17 = v18;
        if (!*v18) {
          return result;
        }
      }

      if (v17) {
        uint64_t v20 = v17;
      }
      else {
        uint64_t v20 = v15;
      }
      *uint64_t v20 = *v18;
      size_t result = (uint64_t)(v18 + 3);
      if (v18[3])
      {
        uint64_t v21 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))*((void *)v12 + 2);
        if (v21) {
          size_t result = v21(result, a4, a5);
        }
      }

      *uint64_t v18 = qword_10008CEB0;
      qword_10008CEB0 = (uint64_t)v18;
    }
  }

  return result;
}

uint64_t sub_100063738( void *a1, uint64_t (**a2)(unsigned __int8 *a1, int a2, unsigned int a3), const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2) {
    return 0LL;
  }
  size_t v10 = a4;
  if (!(_DWORD)a4) {
    size_t v10 = sub_1000635A0(a3, a2[4], (uint64_t)a3, a4, a5, a6, a7, a8);
  }
  if (*a1) {
    sub_100061FB4( "Internal inconsistency: storage value has not been initialized to zero (from %s:%d).",  (uint64_t)a2,  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  a5);
  }
  uint64_t v14 = a2[(int)a2[4]((unsigned __int8 *)a3, v10, *(_DWORD *)a2) + 5];
  if (!v14) {
    return 0LL;
  }
  while ((_DWORD)v10 != *((_DWORD *)v14 + 4) || a2[3](*((unsigned __int8 **)v14 + 1), (int)a3, v10))
  {
    uint64_t v14 = *(uint64_t (**)(unsigned __int8 *, int, unsigned int))v14;
    if (!v14) {
      return 0LL;
    }
  }

  uint64_t v16 = a2[1];
  uint64_t v17 = *((void *)v14 + 3);
  if (v16) {
    ((void (*)(void *, uint64_t, uint64_t, uint64_t))v16)(a1, v17, a5, a6);
  }
  else {
    *a1 = v17;
  }
  return 1LL;
}

uint64_t sub_100063840(unsigned int *a1, unsigned int (*a2)(uint64_t, uint64_t, uint64_t))
{
  if (!a1) {
    return 0LL;
  }
  unint64_t v3 = *a1;
  if (!(_DWORD)v3) {
    return 0LL;
  }
  uint64_t v5 = 0LL;
  uint64_t v6 = 0LL;
  while (1)
  {
    unsigned int v7 = *(uint64_t **)&a1[2 * v5 + 10];
    if (v7) {
      break;
    }
LABEL_8:
    if (++v5 >= v3) {
      return v6;
    }
  }

  while (1)
  {
    uint64_t v8 = *((unsigned int *)v7 + 4);
    uint64_t v9 = v7[3];
    size_t v10 = v7;
    unsigned int v7 = (uint64_t *)*v7;
    if (a2(v10[1], v8, v9)) {
      return v6;
    }
    uint64_t v6 = (v6 + 1);
    if (!v7)
    {
      unint64_t v3 = *a1;
      goto LABEL_8;
    }
  }

uint64_t sub_1000638C8(void **a1, uint64_t a2, uint64_t a3)
{
  return sub_10005CE50(a1, (void *)qword_10008CF28, 0LL, a2, a3);
}

uint64_t sub_1000638EC(uint64_t a1, int a2, int a3)
{
  v4[0] = 0x400000002LL;
  v4[1] = 0LL;
  v4[2] = 0LL;
  int v5 = a2;
  return sub_10006394C(a1, (uint64_t)v4, a3);
}

uint64_t sub_10006394C(uint64_t a1, uint64_t a2, int a3)
{
  if (*(_DWORD *)a2 != 2) {
    return 39LL;
  }
  uint64_t v16 = 0LL;
  uint64_t v6 = sub_10005CE50( (void **)&v16,  (void *)qword_10008CF28,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/listener.c",  84LL);
  if ((_DWORD)v6) {
    return v6;
  }
  uint64_t v7 = (uint64_t)v16;
  *((_DWORD *)v16 + 8) = -1;
  uint64_t v6 = sub_10005CFB8((void *)(a1 + 16), v7);
  if ((_DWORD)v6) {
    goto LABEL_5;
  }
  uint64_t v6 = sub_10005CFB8((void *)v16 + 3, a1);
  if ((_DWORD)v6) {
    goto LABEL_5;
  }
  size_t v12 = v16;
  *((_WORD *)v16 + 21) = bswap32(*(unsigned __int16 *)(a2 + 24)) >> 16;
  *((_DWORD *)v12 + 11) = *(_DWORD *)(a2 + 8);
  *((_WORD *)v12 + 2__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = 528;
  *((void *)v12 + 6) = 0LL;
  if (sub_100068D4C())
  {
    sub_100063C1C((uint64_t)v16);
    uint64_t v6 = 0LL;
LABEL_18:
    uint64_t v10 = 177LL;
LABEL_13:
    sub_10005CFEC((_DWORD **)&v16, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/listener.c", v10);
    return v6;
  }

  int v13 = socket(2, 1, 6);
  *((_DWORD *)v16 + 8) = v13;
  if (v13 != -1)
  {
    if (fcntl(v13, 2, 1LL) < 0) {
      goto LABEL_24;
    }
    int v15 = 1;
    if (setsockopt(*((_DWORD *)v16 + 8), 0xFFFF, 4, &v15, 4u) < 0) {
      goto LABEL_24;
    }
    int v15 = bind(*((_DWORD *)v16 + 8), (const sockaddr *)(v16 + 40), 0x10u);
    if ((v15 & 0x80000000) == 0)
    {
      if (!listen(*((_DWORD *)v16 + 8), a3) && (fcntl(*((_DWORD *)v16 + 8), 4, 4LL) & 0x80000000) == 0)
      {
        uint64_t v6 = sub_100060E24((uint64_t)v16, (uint64_t)sub_100063CB4, 0LL, (uint64_t)sub_100063CDC, 0LL, 0LL);
        goto LABEL_18;
      }

LABEL_24:
      uint64_t v6 = 34LL;
      goto LABEL_5;
    }

    if (*__error() == 48)
    {
      uint64_t v6 = 4LL;
      goto LABEL_5;
    }

    LODWORD(v6) = 6;
    int v14 = 1;
LABEL_34:
    if (*__error() == v14) {
      uint64_t v6 = v6;
    }
    else {
      uint64_t v6 = 34LL;
    }
    goto LABEL_5;
  }

  if (*__error() == 24)
  {
    uint64_t v6 = 13LL;
    goto LABEL_5;
  }

  uint64_t v6 = 13LL;
  if (*__error() != 23)
  {
    int v14 = 55;
    goto LABEL_34;
  }

uint64_t sub_100063C1C(uint64_t a1)
{
  uint64_t v2 = qword_10008CEC0;
  if (!qword_10008CEC0)
  {
    LODWORD(result) = sub_10005D87C(&qword_10008CEC0, (uint64_t)sub_1000638E4, (uint64_t)sub_1000638E8);
    if ((_DWORD)result) {
      goto LABEL_5;
    }
    uint64_t v2 = qword_10008CEC0;
  }

  uint64_t result = sub_10005D9BC( v2,  a1,  (unsigned int *)(a1 + 36),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/listener.c",  343LL);
  if ((_DWORD)result)
  {
LABEL_5:
    char v4 = sub_100067900(result);
    return sub_10006221C("trace_listener_remember: %s", v5, v6, v7, v8, v9, v10, v11, v4);
  }

  return result;
}

uint64_t sub_100063CB4(uint64_t a1)
{
  if (*(void *)a1 == qword_10008CF28) {
    return *(unsigned int *)(a1 + 32);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_100063CDC(uint64_t a1)
{
  if (*(void *)a1 != qword_10008CF28) {
    return 39LL;
  }
  socklen_t v10 = 16;
  int v4 = accept(*(_DWORD *)(a1 + 32), &v17, &v10);
  if (v4 < 0)
  {
    if (*__error() == 24)
    {
      return 13LL;
    }

    else
    {
      uint64_t v1 = 13LL;
      if (*__error() != 23)
      {
        if (*__error() == 55) {
          return 13LL;
        }
        else {
          return 34LL;
        }
      }
    }
  }

  else
  {
    int v5 = v4;
    if (sub_100068D58())
    {
      sa_data = v17.sa_data;
      int v12 = 2;
      int v13 = &v17.sa_data[2];
      int v14 = 4;
      uint64_t v15 = a1 + 42;
      int v16 = 2;
      sub_1000693DC( qword_10008CEB8,  3LL,  (uint64_t)&sa_data,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/listener.c",  246LL,  v6,  v7,  v8);
    }

    sa_data = 0LL;
    uint64_t v9 = sub_100063E90((void **)&sa_data, a1, v5, (uint64_t)&v17);
    if ((_DWORD)v9)
    {
      uint64_t v1 = v9;
      close(v5);
    }

    else
    {
      uint64_t v1 = sub_100060E24( (uint64_t)sa_data,  (uint64_t)sub_100060330,  (uint64_t)sub_10005F7CC,  (uint64_t)sub_10005E478,  (uint64_t)sub_10005EBC0,  (uint64_t)sub_10005F84C);
      sub_10005F294( (_DWORD **)&sa_data,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/listener.c",  266LL);
      if ((_DWORD)v1) {
        sub_100060130((uint64_t)sa_data, 1);
      }
    }
  }

  return v1;
}

uint64_t sub_100063E90(void **a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8 = sub_10005F274(a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/listener.c", 286LL);
  if (!(_DWORD)v8)
  {
    uint64_t v9 = (char *)*a1;
    *((_DWORD *)v9 + 1__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = 2;
    *(_OWORD *)(v9 + 44) = *(_OWORD *)a4;
    socklen_t v10 = *a1;
    *((_DWORD *)*a1 + 8) = a3;
    uint64_t v11 = *(uint64_t (**)(uint64_t, uint64_t *))(a2 + 56);
    if (v11
      && (uint64_t v14 = 0x400000002LL,
          unsigned int v12 = bswap32(*(unsigned __int16 *)(a4 + 2)),
          int v15 = *(_DWORD *)(a4 + 4),
          unsigned int v16 = HIWORD(v12),
          uint64_t v8 = v11(a2, &v14),
          socklen_t v10 = *a1,
          (_DWORD)v8))
    {
      sub_100060130((uint64_t)v10, 1);
      sub_10005F294((_DWORD **)a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/listener.c", 305LL);
    }

    else
    {
      sub_10005CFB8(v10 + 16, a2);
      sub_10005FB10((uint64_t)*a1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/listener.c", 312LL);
      return sub_100067DAC(a2);
    }
  }

  return v8;
}

uint64_t sub_100063FE0(void *a1)
{
  return sub_10005D87C(a1, (uint64_t)sub_1000638E4, (uint64_t)sub_1000638E8);
}

void *sub_100063FFC()
{
  uint64_t result = sub_100068E0C( "listener-accept",  0LL,  (uint64_t)sub_100064040,  (uint64_t)nullsub_16,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/listener.c",  325LL);
  qword_10008CEB8 = (uint64_t)result;
  return result;
}

uint64_t sub_100064040(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v19[0] = 0LL;
  v19[1] = 0LL;
  in_addr_t v4 = *(_DWORD *)a3;
  HIDWORD(v19[0]) = *(_DWORD *)a3;
  WORD1(v19[0]) = *(_WORD *)(a3 + 4);
  sockaddr v17 = 0LL;
  uint64_t v5 = qword_10008CEC0;
  if (qword_10008CEC0)
  {
    uint64_t v6 = 0LL;
    while (1)
    {
      if (v6 >= *(int *)(v5 + 24))
      {
LABEL_8:
        in_addr_t v4 = *(_DWORD *)a3;
        break;
      }

      uint64_t v7 = *(void *)(*(void *)v5 + 8 * v6);
      if (v7)
      {
        (*(void (**)(_DWORD **, uint64_t, const char *, uint64_t))(v5 + 8))( &v17,  v7,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/listener.c",  367LL);
        if (*((unsigned __int16 *)v17 + 21) == *(unsigned __int16 *)(a3 + 6))
        {
          uint64_t v18 = 0LL;
          sub_100063E90(&v18, (uint64_t)v17, 0, (uint64_t)v19);
          return sub_10005CFEC(&v17, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/listener.c", 372LL);
        }

        (*(void (**)(_DWORD **, const char *, uint64_t))(qword_10008CEC0 + 16))( &v17,  "/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/listener.c",  376LL);
        uint64_t v5 = qword_10008CEC0;
      }

      ++v6;
      if (!v5) {
        goto LABEL_8;
      }
    }
  }

  v8.in_addr_t s_addr = v4;
  inet_ntoa(v8);
  return sub_10006221C( "trace_listener_accept: %s from %s/%d to port %d",  v9,  v10,  v11,  v12,  v13,  v14,  v15,  (char)"unexpected connect");
}

uint64_t sub_10006418C(void *a1, uint64_t a2)
{
  if (*a1 != qword_10008CF28) {
    return 39LL;
  }
  uint64_t result = 0LL;
  a1[7] = a2;
  return result;
}

uint64_t sub_1000641BC(void *a1)
{
  if (*a1 != qword_10008CF28) {
    return 39LL;
  }
  uint64_t v2 = a1[3];
  else {
    return 23LL;
  }
}

uint64_t sub_1000641FC(void *a1)
{
  if (*a1 != qword_10008CF28) {
    return 39LL;
  }
  uint64_t v2 = a1[3];
  else {
    return 23LL;
  }
}

uint64_t sub_10006423C(uint64_t a1)
{
  if (*(void *)a1 != qword_10008CF28) {
    return 39LL;
  }
  int v3 = *(_DWORD *)(a1 + 32);
  if (v3 == -1) {
    return 0LL;
  }
  close(v3);
  uint64_t result = 0LL;
  *(_DWORD *)(a1 + 32) = -1;
  return result;
}

uint64_t sub_10006429C(void *a1)
{
  if (*a1 != qword_10008CF28) {
    return 39LL;
  }
  uint64_t v2 = a1[3];
  else {
    return 23LL;
  }
}

uint64_t sub_1000642DC(uint64_t a1, uint64_t a2, void *a3)
{
  if (*a3 != qword_10008CF28) {
    return 39LL;
  }
  uint64_t v4 = a3[3];
  else {
    return 0LL;
  }
}

uint64_t sub_10006431C(void **a1, uint64_t a2, uint64_t a3)
{
  return sub_10005CE50(a1, (void *)qword_10008CF30, 0LL, a2, a3);
}

uint64_t sub_100064338(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v15 = 0LL;
  uint64_t v6 = sub_10005CE50(&v15, (void *)qword_10008CF30, 0LL, a2, a3);
  if (!(_DWORD)v6)
  {
    uint64_t v14 = 0LL;
    uint64_t v6 = sub_100062444((void **)&v14, a2, a3);
    if ((_DWORD)v6)
    {
      sub_10005CE20(v15, a2, a3, v7, v8, v9, v10, v11);
    }

    else
    {
      uint64_t v12 = sub_10005CFB8((void *)v15 + 3, (uint64_t)v14);
      if (!(_DWORD)v12)
      {
        uint64_t v12 = sub_10005CFB8(v14 + 2, (uint64_t)v15);
        if (!(_DWORD)v12) {
          uint64_t v12 = sub_10005CFB8(a1, (uint64_t)v15);
        }
      }

      uint64_t v6 = v12;
      sub_10005CFEC((_DWORD **)&v15, a2, a3);
      sub_10005CFEC((_DWORD **)&v14, a2, a3);
    }
  }

  return v6;
}

uint64_t sub_100064434(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  if (*(void *)a1 != qword_10008CF30) {
    return 39LL;
  }
  if (!sub_100068648(a3, "authenticator"))
  {
    uint64_t v11 = *(void *)(a1 + 80);
    uint64_t v10 = (int **)(a1 + 80);
    if (v11) {
      sub_10005D538(v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/message.c", 103LL);
    }
    sub_10005D504(v10, (_DWORD *)a4);
    return 0LL;
  }

  if (!sub_100068648(a3, "object"))
  {
    if (*(_DWORD *)(a4 + 4) != 3) {
      return 39LL;
    }
    uint64_t v13 = *(void *)(a1 + 48);
    uint64_t v12 = (_DWORD **)(a1 + 48);
    if (v13) {
      sub_10005CFEC(v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/message.c", 111LL);
    }
    uint64_t v14 = *(void *)(a4 + 8);
    uint64_t v15 = v12;
    goto LABEL_26;
  }

  if (!sub_100068648(a3, "notify-object"))
  {
    if (*(_DWORD *)(a4 + 4) != 3) {
      return 39LL;
    }
    uint64_t v17 = *(void *)(a1 + 56);
    unsigned int v16 = (_DWORD **)(a1 + 56);
    if (v17) {
      sub_10005CFEC(v16, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/message.c", 119LL);
    }
    uint64_t v14 = *(void *)(a4 + 8);
    uint64_t v15 = v16;
LABEL_26:
    sub_10005CFB8(v15, v14);
    return 0LL;
  }

  if (!sub_100068648(a3, "authid"))
  {
    if (!*(_DWORD *)(a4 + 4))
    {
      uint64_t result = 0LL;
      *(_DWORD *)(a1 + 88) = *(_DWORD *)(a4 + 8);
      return result;
    }

    return 39LL;
  }

  if (!sub_100068648(a3, "op"))
  {
    if (!*(_DWORD *)(a4 + 4))
    {
      uint64_t result = 0LL;
      *(_DWORD *)(a1 + 104) = *(_DWORD *)(a4 + 8);
      return result;
    }

    return 39LL;
  }

  if (!sub_100068648(a3, "handle"))
  {
    if (!*(_DWORD *)(a4 + 4))
    {
      uint64_t result = 0LL;
      *(_DWORD *)(a1 + 108) = *(_DWORD *)(a4 + 8);
      return result;
    }

    return 39LL;
  }

  if (!sub_100068648(a3, "id"))
  {
    if (!*(_DWORD *)(a4 + 4))
    {
      uint64_t result = 0LL;
      *(_DWORD *)(a1 + 112) = *(_DWORD *)(a4 + 8);
      return result;
    }

    return 39LL;
  }

  if (!sub_100068648(a3, "rid"))
  {
    if (!*(_DWORD *)(a4 + 4))
    {
      uint64_t result = 0LL;
      *(_DWORD *)(a1 + 116) = *(_DWORD *)(a4 + 8);
      return result;
    }

    return 39LL;
  }

  uint64_t v8 = *(void *)(a1 + 24);
  if (!v8) {
    return 23LL;
  }
  uint64_t v9 = *(uint64_t (**)(void))(*(void *)v8 + 16LL);
  if (!v9) {
    return 23LL;
  }
  uint64_t result = v9();
  if ((_DWORD)result) {
    return 23LL;
  }
  return result;
}

uint64_t sub_100064688(uint64_t a1, int a2, _DWORD *a3, int ***a4)
{
  if (*(void *)a1 != qword_10008CF30) {
    return 39LL;
  }
  if (sub_100068648((uint64_t)a3, "authlen"))
  {
    if (!sub_100068648((uint64_t)a3, "authenticator"))
    {
      uint64_t v14 = *(_DWORD **)(a1 + 80);
      if (v14) {
        return sub_100068788( a4,  a3,  v14,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/message.c",  188LL);
      }
      return 23LL;
    }

    if (sub_100068648((uint64_t)a3, "authid"))
    {
      if (sub_100068648((uint64_t)a3, "op"))
      {
        if (sub_100068648((uint64_t)a3, "handle"))
        {
          if (sub_100068648((uint64_t)a3, "id"))
          {
            if (sub_100068648((uint64_t)a3, "rid"))
            {
              uint64_t v8 = *(void *)(a1 + 24);
              if (v8)
              {
                uint64_t v9 = *(uint64_t (**)(void))(*(void *)v8 + 24LL);
                if (v9) {
                  return v9();
                }
              }

              return 23LL;
            }

            uint64_t v10 = (const char *)*(unsigned int *)(a1 + 116);
            uint64_t v11 = a4;
            uint64_t v12 = a3;
            uint64_t v13 = 201LL;
          }

          else
          {
            uint64_t v10 = (const char *)*(unsigned int *)(a1 + 112);
            uint64_t v11 = a4;
            uint64_t v12 = a3;
            uint64_t v13 = 199LL;
          }
        }

        else
        {
          uint64_t v10 = (const char *)*(unsigned int *)(a1 + 108);
          uint64_t v11 = a4;
          uint64_t v12 = a3;
          uint64_t v13 = 197LL;
        }
      }

      else
      {
        uint64_t v10 = (const char *)*(unsigned int *)(a1 + 104);
        uint64_t v11 = a4;
        uint64_t v12 = a3;
        uint64_t v13 = 195LL;
      }
    }

    else
    {
      uint64_t v10 = (const char *)*(unsigned int *)(a1 + 88);
      uint64_t v11 = a4;
      uint64_t v12 = a3;
      uint64_t v13 = 193LL;
    }
  }

  else
  {
    uint64_t v10 = (const char *)*(unsigned int *)(a1 + 72);
    uint64_t v11 = a4;
    uint64_t v12 = a3;
    uint64_t v13 = 184LL;
  }

  return sub_100068920(v11, v12, v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/message.c", v13);
}

uint64_t sub_100064878(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)a1 != qword_10008CF30) {
    return 39LL;
  }
  uint64_t v8 = *(void *)(a1 + 80);
  uint64_t v7 = (int **)(a1 + 80);
  if (v8) {
    sub_10005D538(v7, a2, a3);
  }
  if (*(void *)(a1 + 40)) {
    BOOL v9 = 1;
  }
  else {
    BOOL v9 = qword_10008CEC8 == a1;
  }
  if (!v9) {
    sub_10006495C((void *)a1);
  }
  if (*(void *)(a1 + 96)) {
    sub_10005CFEC((_DWORD **)(a1 + 96), a2, a3);
  }
  if (*(void *)(a1 + 48)) {
    sub_10005CFEC((_DWORD **)(a1 + 48), a2, a3);
  }
  if (*(void *)(a1 + 56)) {
    sub_10005CFEC((_DWORD **)(a1 + 56), a2, a3);
  }
  uint64_t v11 = *(void *)(a1 + 64);
  uint64_t v10 = a1 + 64;
  if (v11) {
    sub_1000235C8(v10, a2, a3);
  }
  return 0LL;
}

uint64_t sub_10006495C(void *a1)
{
  if (*a1 == qword_10008CF30)
  {
    uint64_t v2 = (_DWORD **)(a1 + 5);
    uint64_t v1 = (_DWORD *)a1[5];
    if (v1 || qword_10008CEC8 == (void)a1)
    {
      uint64_t v8 = 0LL;
      uint64_t v5 = (_DWORD **)(a1 + 4);
      uint64_t v4 = a1[4];
      if (v4)
      {
        sub_10005CFB8(&v8, v4);
        sub_10005CFEC(v5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/message.c", 318LL);
        sub_10005CFEC( (_DWORD **)v8 + 5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/message.c",  319LL);
        uint64_t v1 = *v2;
      }

      if (v1)
      {
        uint64_t v7 = 0LL;
        sub_10005CFB8(&v7, (uint64_t)v1);
        sub_10005CFEC(v2, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/message.c", 325LL);
        if (*((void *)v7 + 4)) {
          sub_10005CFEC( (_DWORD **)v7 + 4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/message.c",  328LL);
        }
        if (v8) {
          sub_10005CFB8((void *)v7 + 4, (uint64_t)v8);
        }
        sub_10005CFEC(&v7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/message.c", 333LL);
      }

      else
      {
        sub_10005CFEC( (_DWORD **)&qword_10008CEC8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/message.c",  336LL);
        if (!v8) {
          return 0LL;
        }
        sub_10005CFB8(&qword_10008CEC8, (uint64_t)v8);
      }

      if (v8) {
        sub_10005CFEC(&v8, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/message.c", 343LL);
      }
      return 0LL;
    }
  }

  return 39LL;
}

uint64_t sub_100064AF0(void *a1, char *__s1)
{
  if (*a1 != qword_10008CF30) {
    return 39LL;
  }
  if (!strcmp(__s1, "status"))
  {
    uint64_t v6 = a1[7];
    if (v6)
    {
      uint64_t v5 = *(uint64_t (**)(void))(*(void *)v6 + 40LL);
      if (v5) {
        return v5();
      }
    }

    uint64_t v7 = a1[6];
    if (v7)
    {
      uint64_t v5 = *(uint64_t (**)(void))(*(void *)v7 + 40LL);
      if (v5) {
        return v5();
      }
    }
  }

  uint64_t v4 = a1[3];
  if (v4)
  {
    uint64_t v5 = *(uint64_t (**)(void))(*(void *)v4 + 40LL);
    if (v5) {
      return v5();
    }
  }

  return 23LL;
}

uint64_t sub_100064BA8(uint64_t a1, uint64_t a2, void *a3)
{
  if (*a3 != qword_10008CF30) {
    return 39LL;
  }
  uint64_t v4 = a3[3];
  else {
    return 0LL;
  }
}

uint64_t sub_100064BE8(void *a1)
{
  if (*a1 != qword_10008CF30) {
    return 39LL;
  }
  if (a1[5]) {
    return 39LL;
  }
  uint64_t v2 = a1 + 4;
  if (a1[4] || (void *)qword_10008CEC8 == a1) {
    return 39LL;
  }
  if (qword_10008CEC8)
  {
    sub_10005CFB8(v2, qword_10008CEC8);
    sub_10005CFB8((void *)(qword_10008CEC8 + 40), (uint64_t)a1);
    sub_10005CFEC( (_DWORD **)&qword_10008CEC8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/message.c",  293LL);
  }

  sub_10005CFB8(&qword_10008CEC8, (uint64_t)a1);
  return 0LL;
}

uint64_t sub_100064CB8(uint64_t a1, void *a2)
{
  uint64_t v46 = 0LL;
  *(void *)uint64_t v47 = 0LL;
  if (*(void *)a1 != qword_10008CF30) {
    return 39LL;
  }
  int v5 = *(_DWORD *)(a1 + 116);
  if (v5)
  {
    uint64_t v6 = qword_10008CEC8;
    if (!qword_10008CEC8) {
      return 23LL;
    }
    while (*(_DWORD *)(v6 + 112) != v5)
    {
      uint64_t v6 = *(void *)(v6 + 32);
      if (!v6) {
        return 23LL;
      }
    }

    if (*(_DWORD *)(a1 + 88) != *(_DWORD *)(v6 + 88)) {
      return 23LL;
    }
    goto LABEL_13;
  }

  if (!sub_10006737C((uint64_t)a2) || *(void *)(a1 + 96) || *(_DWORD *)(a1 + 104) == 1)
  {
    uint64_t v6 = 0LL;
LABEL_13:
    switch(*(_DWORD *)(a1 + 104))
    {
      case 1:
        uint64_t v7 = *(void *)(a1 + 96);
        if (v6)
        {
          uint64_t v8 = "OPEN can't be a response";
          BOOL v9 = (const char *)*(unsigned int *)(a1 + 112);
          uint64_t v10 = a2;
          uint64_t v11 = 39LL;
          return sub_100066E1C(v10, v7, (const char *)v11, v9, v8);
        }

        if (sub_1000683F8(a1, v7, "type"))
        {
          uint64_t v26 = 0LL;
        }

        else
        {
          uint64_t v26 = qword_10008CEF8;
          if ((v46[2][1] - 3) < 0xFFFFFFFE || qword_10008CEF8 == 0)
          {
            uint64_t v26 = 0LL;
            sub_10005D71C(&v46, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/message.c", 461LL);
          }

          else
          {
            do
            {
              uint64_t v26 = *(void *)(v26 + 8);
            }

            while (v26);
          }
        }

        BOOL v29 = sub_10006737C((uint64_t)a2);
        uint64_t v30 = *(void *)(a1 + 96);
        if (v29 && !v30 && v26 != qword_10008CF00)
        {
          uint64_t v20 = (const char *)*(unsigned int *)(a1 + 112);
          uint64_t v23 = "No authenticator on message";
          uint64_t v21 = a2;
          uint64_t v18 = 0LL;
          uint64_t v22 = 46LL;
          return sub_100066E1C(v21, v18, (const char *)v22, v20, v23);
        }

        if (sub_1000683F8(a1, v30, "create"))
        {
          uint64_t v45 = 0LL;
        }

        else
        {
          uint64_t v13 = sub_100068C24(&v45, v46[2]);
          sub_10005D71C(&v46, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/message.c", 478LL);
          if ((_DWORD)v13)
          {
            uint64_t v18 = *(void *)(a1 + 96);
            uint64_t v20 = (const char *)*(unsigned int *)(a1 + 112);
            uint64_t v23 = "invalid create flag value";
            goto LABEL_91;
          }
        }

        if (sub_1000683F8(a1, *(void *)(a1 + 96), "update"))
        {
          uint64_t v44 = 0LL;
        }

        else
        {
          uint64_t v13 = sub_100068C24(&v44, v46[2]);
          sub_10005D71C(&v46, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/message.c", 493LL);
          if ((_DWORD)v13)
          {
            uint64_t v18 = *(void *)(a1 + 96);
            uint64_t v20 = (const char *)*(unsigned int *)(a1 + 112);
            uint64_t v23 = "invalid update flag value";
            goto LABEL_91;
          }
        }

        if (sub_1000683F8(a1, *(void *)(a1 + 96), "exclusive"))
        {
          uint64_t v43 = 0LL;
        }

        else
        {
          uint64_t v13 = sub_100068C24(&v43, v46[2]);
          sub_10005D71C(&v46, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/message.c", 508LL);
          if ((_DWORD)v13)
          {
            uint64_t v18 = *(void *)(a1 + 96);
            uint64_t v20 = (const char *)*(unsigned int *)(a1 + 112);
            uint64_t v23 = "invalid exclusive flag value";
            goto LABEL_91;
          }
        }

        if (v26)
        {
          uint64_t v31 = *(uint64_t (**)(int *, uint64_t, void))(v26 + 56);
          uint64_t v18 = *(void *)(a1 + 96);
          if (!v31)
          {
            uint64_t v20 = (const char *)*(unsigned int *)(a1 + 112);
            uint64_t v23 = "unsearchable object type";
            goto LABEL_53;
          }

          uint64_t v32 = v31(v47, v18, *(void *)(a1 + 48));
          uint64_t v22 = v32;
          if (v32 > 0x2E || ((1LL << v32) & 0x400000800001LL) == 0)
          {
            uint64_t v18 = *(void *)(a1 + 96);
            uint64_t v20 = (const char *)*(unsigned int *)(a1 + 112);
            uint64_t v23 = "object lookup failed";
            goto LABEL_96;
          }

          uint64_t v33 = v45;
          if ((_DWORD)v32 == 23 && !v45)
          {
            uint64_t v18 = *(void *)(a1 + 96);
            uint64_t v20 = (const char *)*(unsigned int *)(a1 + 112);
            uint64_t v23 = "no object matches specification";
            uint64_t v21 = a2;
            uint64_t v22 = 23LL;
            return sub_100066E1C(v21, v18, (const char *)v22, v20, v23);
          }

          if (!(_DWORD)v32 && v45 && v43)
          {
            sub_10005CFEC( (_DWORD **)v47,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/message.c",  565LL);
            uint64_t v18 = *(void *)(a1 + 96);
            uint64_t v20 = (const char *)*(unsigned int *)(a1 + 112);
            uint64_t v23 = "specified object already exists";
            uint64_t v21 = a2;
            uint64_t v22 = 18LL;
            return sub_100066E1C(v21, v18, (const char *)v22, v20, v23);
          }

          uint64_t v35 = *(void **)v47;
          if (!*(void *)v47)
          {
            uint64_t v22 = sub_1000684F8((uint64_t)v47, *(void *)(a1 + 96), v26);
            if ((_DWORD)v22)
            {
              uint64_t v18 = *(void *)(a1 + 96);
              uint64_t v20 = (const char *)*(unsigned int *)(a1 + 112);
              uint64_t v23 = "can't create new object";
              goto LABEL_96;
            }

            uint64_t v33 = v45;
            uint64_t v35 = *(void **)v47;
          }

          if (v33 | v44)
          {
            if (*v35 == qword_10008CF00)
            {
              uint64_t v37 = v22;
              uint64_t v38 = 589LL;
              goto LABEL_113;
            }

            uint64_t v36 = sub_10006850C( (uint64_t)v35,  *(void *)(a1 + 96),  *(void *)(a1 + 48),  (const char *)*(unsigned int *)(a1 + 108));
            if ((_DWORD)v36)
            {
              uint64_t v37 = v36;
              uint64_t v38 = 601LL;
LABEL_113:
              sub_10005CFEC( (_DWORD **)v47,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/message.c",  v38);
              uint64_t v18 = *(void *)(a1 + 96);
              uint64_t v20 = (const char *)*(unsigned int *)(a1 + 112);
              uint64_t v23 = "can't update object";
LABEL_124:
              uint64_t v21 = a2;
              uint64_t v22 = v37;
              return sub_100066E1C(v21, v18, (const char *)v22, v20, v23);
            }

            uint64_t v35 = *(void **)v47;
          }

          if (*v35 == qword_10008CF00)
          {
            uint64_t v39 = sub_100062B58(&v42, (uint64_t)v35);
            if ((_DWORD)v39)
            {
              uint64_t v37 = v39;
              uint64_t v40 = 615LL;
            }

            else
            {
              uint64_t v41 = sub_100066F80(a2, *(void **)v47, v42);
              if (!(_DWORD)v41) {
                goto LABEL_117;
              }
              uint64_t v37 = v41;
              uint64_t v40 = 624LL;
            }

            sub_10005CFEC( (_DWORD **)v47,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/message.c",  v40);
            uint64_t v18 = *(void *)(a1 + 96);
            uint64_t v20 = (const char *)*(unsigned int *)(a1 + 112);
            uint64_t v23 = "can't select authenticator";
            goto LABEL_124;
          }
        }

        else
        {
          if (v45)
          {
            uint64_t v18 = *(void *)(a1 + 96);
            uint64_t v20 = (const char *)*(unsigned int *)(a1 + 112);
            uint64_t v23 = "type required on create";
            uint64_t v21 = a2;
            uint64_t v22 = 39LL;
            return sub_100066E1C(v21, v18, (const char *)v22, v20, v23);
          }

LABEL_94:
          uint64_t v16 = sub_100062EB4(v47, *(_DWORD *)(a1 + 108));
          if ((_DWORD)v16)
          {
LABEL_95:
            uint64_t v22 = v16;
            uint64_t v18 = *(void *)(a1 + 96);
            uint64_t v20 = (const char *)*(unsigned int *)(a1 + 112);
            uint64_t v23 = "no matching handle";
LABEL_96:
            uint64_t v21 = a2;
            return sub_100066E1C(v21, v18, (const char *)v22, v20, v23);
          }
        }

LABEL_117:
        uint64_t v2 = sub_100067768(a2, *(void *)(a1 + 96), (const char *)*(unsigned int *)(a1 + 112), *(const char **)v47);
        uint64_t v34 = 648LL;
        goto LABEL_118;
      case 2:
        goto LABEL_94;
      case 3:
        if (v6 && (uint64_t v12 = *(void *)(v6 + 48)) != 0)
        {
          uint64_t v13 = sub_10005CFB8(v47, v12);
        }

        else
        {
          uint64_t v16 = sub_100062EB4(v47, *(_DWORD *)(a1 + 108));
          if ((_DWORD)v16) {
            goto LABEL_95;
          }
          uint64_t v13 = 0LL;
        }

        if (**(void **)v47 == qword_10008CF00
          || (uint64_t v24 = *(void **)(*(void *)v47 + 24LL)) != 0LL && *v24 == qword_10008CF00)
        {
          if (!v6)
          {
            sub_10005CFEC( (_DWORD **)v47,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/message.c",  669LL);
            uint64_t v18 = *(void *)(a1 + 96);
            uint64_t v20 = (const char *)*(unsigned int *)(a1 + 112);
            uint64_t v23 = "cannot update authenticator";
LABEL_91:
            uint64_t v21 = a2;
            uint64_t v22 = v13;
            return sub_100066E1C(v21, v18, (const char *)v22, v20, v23);
          }

          uint64_t v25 = sub_100066F80(a2, *(void **)v47, *(_DWORD *)(a1 + 108));
        }

        else
        {
          uint64_t v25 = sub_10006850C( *(uint64_t *)v47,  *(void *)(a1 + 96),  *(void *)(a1 + 48),  (const char *)*(unsigned int *)(a1 + 108));
        }

        uint64_t v27 = v25;
        if (!(_DWORD)v25)
        {
          if (*(_DWORD *)(a1 + 116)) {
            uint64_t v2 = 0LL;
          }
          else {
            uint64_t v2 = sub_100066E1C(a2, *(void *)(a1 + 96), 0LL, (const char *)*(unsigned int *)(a1 + 112), 0LL);
          }
          if (v6)
          {
            sub_100067DAC(v6);
            sub_10006495C((void *)v6);
          }

          uint64_t v34 = 708LL;
LABEL_118:
          sub_10005CFEC((_DWORD **)v47, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/message.c", v34);
          return v2;
        }

        sub_10005CFEC((_DWORD **)v47, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/message.c", 685LL);
        if (!*(_DWORD *)(a1 + 116))
        {
          uint64_t v18 = *(void *)(a1 + 96);
          uint64_t v20 = (const char *)*(unsigned int *)(a1 + 112);
          uint64_t v23 = "can't update object";
          uint64_t v21 = a2;
          uint64_t v22 = v27;
          return sub_100066E1C(v21, v18, (const char *)v22, v20, v23);
        }

        if (v6) {
          sub_100067DAC(v6);
        }
        return 0LL;
      case 4:
        return sub_100066E1C( a2,  *(void *)(a1 + 96),  (const char *)0x1B,  (const char *)*(unsigned int *)(a1 + 112),  "notify not implemented yet");
      case 5:
        if (!v6) {
          return 34LL;
        }
        if (!sub_1000683F8(a1, *(void *)(a1 + 96), "result"))
        {
          sub_100068C24(&v45, v46[2]);
          sub_10005D71C(&v46, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/message.c", 728LL);
        }

        int v15 = sub_1000683F8(a1, *(void *)(a1 + 96), "message");
        sub_100067DAC(v6);
        if (!v15) {
          sub_10005D71C(&v46, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/message.c", 738LL);
        }
        sub_10006495C((void *)v6);
        return 0LL;
      case 6:
        uint64_t v16 = sub_100062EB4(v47, *(_DWORD *)(a1 + 108));
        if ((_DWORD)v16) {
          goto LABEL_95;
        }
        uint64_t v17 = *(uint64_t (**)(void))(**(void **)v47 + 72LL);
        uint64_t v18 = *(void *)(a1 + 96);
        if (v17)
        {
          uint64_t v19 = v17();
          sub_10005CFEC( (_DWORD **)v47,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/message.c",  761LL);
          uint64_t v18 = *(void *)(a1 + 96);
          uint64_t v20 = (const char *)*(unsigned int *)(a1 + 112);
          uint64_t v21 = a2;
          uint64_t v22 = v19;
          uint64_t v23 = 0LL;
        }

        else
        {
          uint64_t v20 = (const char *)*(unsigned int *)(a1 + 112);
          uint64_t v23 = "no remove method for object";
LABEL_53:
          uint64_t v21 = a2;
          uint64_t v22 = 27LL;
        }

        return sub_100066E1C(v21, v18, (const char *)v22, v20, v23);
      default:
        return 27LL;
    }
  }

  uint64_t v8 = "No authenticator on message";
  BOOL v9 = (const char *)*(unsigned int *)(a1 + 112);
  uint64_t v10 = a2;
  uint64_t v7 = 0LL;
  uint64_t v11 = 46LL;
  return sub_100066E1C(v10, v7, (const char *)v11, v9, v8);
}

void *sub_100065554()
{
  qword_10008CED8 = (uint64_t)sub_100068E0C( "mr-output",  0LL,  (uint64_t)nullsub_17,  (uint64_t)nullsub_18,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/mrtrace.c",  74LL);
  qword_10008CED0 = (uint64_t)sub_100068E0C( "mr-input",  0LL,  (uint64_t)sub_10006563C,  (uint64_t)nullsub_19,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/mrtrace.c",  77LL);
  qword_10008CEE8 = (uint64_t)sub_100068E0C( "mr-statp",  0LL,  (uint64_t)sub_10006564C,  (uint64_t)nullsub_20,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/mrtrace.c",  80LL);
  uint64_t result = sub_100068E0C( "mr-randomid",  0LL,  (uint64_t)sub_10006565C,  (uint64_t)nullsub_21,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/mrtrace.c",  83LL);
  qword_10008CEE0 = (uint64_t)result;
  return result;
}

uint64_t sub_10006563C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  return sub_10006221C("unaccounted-for minires input.", a2, a3, a4, a5, a6, a7, a8, a9);
}

uint64_t sub_10006564C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  return sub_10006221C("unaccounted-for minires statp input.", a2, a3, a4, a5, a6, a7, a8, a9);
}

uint64_t sub_10006565C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  return sub_10006221C("unaccounted-for minires randomid input.", a2, a3, a4, a5, a6, a7, a8, a9);
}

void sub_10006566C(uint64_t a1)
{
  unsigned int v31 = 0;
  uint64_t v30 = 0LL;
  if (sub_100068D4C())
  {
    if (sub_100069AC8((void **)&qword_10008CEE8, &v31, (void **)&v30))
    {
      BOOL v9 = "trace_mr_statp: no statp packet found.";
LABEL_21:
      sub_10006221C(v9, v2, v3, v4, v5, v6, v7, v8, v29);
      return;
    }

    if (v31 < 4 || (v31 & 3) != 0)
    {
      sub_10006221C("trace_mr_statp: bogus length: %d", v2, v3, v4, v5, v6, v7, v8, v31);
      return;
    }

    uint64_t v11 = 0LL;
    unsigned int v12 = v31 >> 2;
    if (v31 >> 2 >= 3) {
      unsigned int v12 = 3;
    }
    uint64_t v13 = v30;
    uint64_t v14 = a1 + 20;
    do
    {
      *(_DWORD *)uint64_t v14 = 889192976;
      *(void *)(v14 + 8) = 0LL;
      *(_DWORD *)(v14 + 4) = *(_DWORD *)&v13[v11];
      v14 += 16LL;
      v11 += 4LL;
    }

    while (4LL * v12 != v11);
    *(_DWORD *)(a1 + 16) = v12;
    sub_10005CE20( v13,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/mrtrace.c",  123LL,  v4,  v5,  v6,  v7,  v8);
    uint64_t v30 = 0LL;
  }

  int v15 = sub_10005CDE4((16 * *(_DWORD *)(a1 + 16)));
  if (!v15)
  {
    sub_100069268();
    BOOL v9 = "No memory for statp iov.";
    goto LABEL_21;
  }

  uint64_t v19 = v15;
  uint64_t v20 = *(unsigned int *)(a1 + 16);
  if ((int)v20 < 1)
  {
    uint64_t v20 = 0LL;
  }

  else
  {
    uint64_t v21 = v15 + 2;
    uint64_t v22 = a1 + 24;
    uint64_t v23 = *(unsigned int *)(a1 + 16);
    do
    {
      *((void *)v21 - 1) = v22;
      *uint64_t v21 = 4;
      v21 += 4;
      v22 += 16LL;
      --v23;
    }

    while (v23);
  }

  sub_1000693DC( qword_10008CEE8,  v20,  (uint64_t)v15,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/mrtrace.c",  140LL,  v16,  v17,  v18);
  sub_10005CE20( v19,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/mrtrace.c",  141LL,  v24,  v25,  v26,  v27,  v28);
}

uint64_t sub_1000657EC(int a1, const void *a2, size_t a3, int a4)
{
  unsigned int v28 = 0;
  int v29 = a4;
  uint64_t v27 = 0LL;
  if (sub_100068D4C())
  {
    if (sub_100069AC8((void **)&qword_10008CED8, &v28, (void **)&v27))
    {
      sub_10006221C("trace_mr_recvfrom: no input found.", v8, v9, v10, v11, v12, v13, v14, v25);
      *__error() = 61;
      return -1LL;
    }

    if (v28 <= 3)
    {
      sub_10006221C("trace_mr_recvfrom: data too short.", v8, v9, v10, v11, v12, v13, v14, v25);
      *__error() = 61;
      sub_10005CE20( v27,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/mrtrace.c",  166LL,  v16,  v17,  v18,  v19,  v20);
      return -1LL;
    }

    ssize_t v15 = bswap32(*v27);
    sub_10005CE20( v27,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/mrtrace.c",  171LL,  v10,  v11,  v12,  v13,  v14);
  }

  else
  {
    ssize_t v15 = send(a1, a2, a3, a4);
  }

  if (sub_100068D58())
  {
    unsigned int v26 = bswap32(v15);
    int v31 = 4;
    uint64_t v30 = &v26;
    int v33 = 4;
    uint64_t v32 = &v29;
    int v35 = a3;
    uint64_t v34 = a2;
    sub_1000693DC( qword_10008CED8,  3LL,  (uint64_t)&v30,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/mrtrace.c",  186LL,  v21,  v22,  v23);
  }

  return v15;
}

uint64_t sub_100065964(uint64_t a1, void *a2, unint64_t a3)
{
  unsigned int v31 = 0;
  uint64_t v30 = 0LL;
  if (!sub_100069AC8((void **)&qword_10008CED0, &v31, (void **)&v30))
  {
    unsigned int v13 = v31;
    if (v31 > 3)
    {
      uint64_t v23 = v30;
      if (*v30) {
        goto LABEL_3;
      }
      if (v31 - 4 > 5)
      {
        if (a1)
        {
          *(_DWORD *)(a1 + 4) = v30[1];
          *(_WORD *)(a1 + 2) = v23[4];
          *(_WORD *)a1 = 528;
          *(void *)(a1 + 8) = 0LL;
        }

        unint64_t v21 = v13 - 10;
        if (v21 <= a3)
        {
          memcpy(a2, v23 + 5, v13 - 10);
          sub_10005CE20( v23,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/mrtrace.c",  253LL,  v24,  v25,  v26,  v27,  v28);
          return v21;
        }

        sub_10006221C("trace_mr_recvfrom: too much%s", v6, v7, v8, v9, v10, v11, v12, (char)" data.");
        *__error() = 61;
        uint64_t v19 = v30;
        uint64_t v20 = 249LL;
      }

      else
      {
        sub_10006221C("trace_mr_recvfrom: data too short.", v6, v7, v8, v9, v10, v11, v12, v29);
        *__error() = 61;
        uint64_t v19 = v30;
        uint64_t v20 = 225LL;
      }
    }

    else
    {
      sub_10006221C("trace_mr_recvfrom: data too short.", v6, v7, v8, v9, v10, v11, v12, v29);
      *__error() = 61;
      uint64_t v19 = v30;
      uint64_t v20 = 211LL;
    }

    sub_10005CE20( v19,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/mrtrace.c",  v20,  v14,  v15,  v16,  v17,  v18);
    return -1LL;
  }

  sub_10006221C("trace_mr_recvfrom: no input found.", v6, v7, v8, v9, v10, v11, v12, v29);
LABEL_3:
  *__error() = 61;
  return -1LL;
}

uint64_t sub_100065AE4( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 < 0)
  {
    unsigned int v13 = bswap32(*__error());
    uint64_t v14 = &v13;
    int v15 = 4;
    goto LABEL_9;
  }

  unsigned int v13 = 0;
  uint64_t v14 = &v13;
  uint64_t v9 = 4LL;
  int v15 = 4;
  if (!a3)
  {
LABEL_9:
    uint64_t v9 = 1LL;
    return sub_1000693DC( qword_10008CED0,  v9,  (uint64_t)&v14,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/mrtrace.c",  289LL,  a6,  a7,  a8);
  }

  uint64_t v10 = &unk_1000C5F67;
  uint64_t v11 = (void *)(a1 + 4);
  if (!a1) {
    uint64_t v11 = &unk_1000C5F67;
  }
  uint64_t v16 = v11;
  int v17 = 4;
  if (a1) {
    uint64_t v10 = (void *)(a1 + 2);
  }
  uint64_t v18 = v10;
  int v19 = 2;
  uint64_t v20 = a2;
  int v21 = a3;
  return sub_1000693DC( qword_10008CED0,  v9,  (uint64_t)&v14,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/mrtrace.c",  289LL,  a6,  a7,  a8);
}

uint64_t sub_100065BC4(int a1, void *a2, unint64_t a3, int a4, sockaddr *a5, socklen_t *a6)
{
  else {
    uint64_t v12 = recvfrom(a1, a2, a3, a4, a5, a6);
  }
  uint64_t v13 = v12;
  return v13;
}

uint64_t sub_100065C5C(int a1, void *a2, unint64_t a3)
{
  else {
    uint64_t v6 = read(a1, a2, a3);
  }
  uint64_t v7 = v6;
  return v7;
}

uint64_t sub_100065CD4(int a1, const sockaddr *a2, socklen_t a3)
{
  else {
    return connect(a1, a2, a3);
  }
}

uint64_t sub_100065D28(int a1, int a2, int a3)
{
  else {
    return socket(a1, a2, a3);
  }
}

uint64_t sub_100065D7C(int a1, const sockaddr *a2, socklen_t a3)
{
  else {
    return bind(a1, a2, a3);
  }
}

uint64_t sub_100065DD0(int a1)
{
  else {
    return close(a1);
  }
}

time_t sub_100065E08(time_t *a1)
{
  if (a1) {
    *a1 = qword_10008CE80;
  }
  return qword_10008CE80;
}

uint64_t sub_100065E54(int a1, fd_set *a2, fd_set *a3, fd_set *a4, timeval *a5)
{
  uint64_t v15 = 0LL;
  uint64_t v10 = sub_100069B7C(&v15);
  __darwin_time_t tv_sec = a5->tv_sec;
  uint64_t v12 = v10 - qword_10008CE80;
  a5->__darwin_time_t tv_sec = v10 - qword_10008CE80;
  return v12 <= tv_sec && v15 == (void *)qword_10008CED0;
}

uint64_t sub_100065F08(uint64_t a1)
{
  int v17 = 0;
  uint64_t v16 = 0LL;
  if (sub_100068D4C())
  {
    if (sub_100069AC8((void **)&qword_10008CEE0, &v17, (void **)&v16))
    {
      uint64_t v9 = "trace_mr_statp: no statp packet found.";
LABEL_9:
      sub_10006221C(v9, v2, v3, v4, v5, v6, v7, v8, v15);
      return a1;
    }

    if (v17 != 4)
    {
      char v15 = v17;
      uint64_t v9 = "trace_mr_randomid: bogus length: %d";
      goto LABEL_9;
    }

    unsigned int v10 = *v16;
    sub_10005CE20( v16,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/mrtrace.c",  428LL,  v4,  v5,  v6,  v7,  v8);
    uint64_t v16 = 0LL;
    a1 = bswap32(v10);
  }

  if (sub_100068D58())
  {
    unsigned int v18 = bswap32(a1);
    sub_1000693B0( qword_10008CEE0,  4,  (uint64_t)&v18,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/mrtrace.c",  435LL,  v11,  v12,  v13);
  }

  return a1;
}

uint64_t sub_100065FD4(void **a1, uint64_t a2, uint64_t a3)
{
  return sub_10005CE50(a1, (void *)qword_10008CF38, 0LL, a2, a3);
}

uint64_t sub_100065FF0(void **a1, uint64_t a2, uint64_t a3)
{
  return sub_10005CE50(a1, (void *)qword_10008CF40, 0LL, a2, a3);
}

uint64_t sub_10006600C(uint64_t a1, char *a2, int a3, uint64_t a4)
{
  *(void *)uint64_t v23 = 0LL;
  uint64_t v8 = sub_10005CE50( (void **)v23,  (void *)qword_10008CF38,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/protocol.c",  57LL);
  if (!(_DWORD)v8)
  {
    uint64_t v9 = sub_10005F298(*(uint64_t *)v23, a2, a3);
    uint64_t v8 = v9;
    if ((_DWORD)v9 == 49 || (_DWORD)v9 == 0)
    {
      uint64_t v11 = sub_10005CFB8((void *)(a1 + 16), *(uint64_t *)v23);
      if ((_DWORD)v11)
      {
        uint64_t v12 = 69LL;
      }

      else
      {
        uint64_t v11 = sub_10005CFB8((void *)(*(void *)v23 + 24LL), a1);
        if (!(_DWORD)v11)
        {
          if (a4)
          {
            uint64_t v14 = sub_10005CDE4(0x18uLL);
            *(void *)(*(void *)v23 + 88LL) = v14;
            if (!v14)
            {
              uint64_t v8 = 1LL;
              uint64_t v12 = 84LL;
              goto LABEL_12;
            }

            *uint64_t v14 = 0LL;
            uint64_t v15 = sub_10005CFB8((void *)(*(void *)(*(void *)v23 + 88LL) + 16LL), a4);
            uint64_t v21 = *(void *)v23;
            if ((_DWORD)v15)
            {
              uint64_t v8 = v15;
              sub_10005CE20( *(void **)(*(void *)v23 + 88LL),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/protocol.c",  92LL,  v16,  v17,  v18,  v19,  v20);
              uint64_t v12 = 93LL;
              goto LABEL_12;
            }

            int v22 = 0;
            uint64_t v8 = 49LL;
          }

          else
          {
            int v22 = 1;
            uint64_t v21 = *(void *)v23;
          }

          *(_DWORD *)(v21 + 104) = v22;
          uint64_t v12 = 106LL;
          goto LABEL_12;
        }

        uint64_t v12 = 74LL;
      }

      uint64_t v8 = v11;
    }

    else
    {
      uint64_t v12 = 63LL;
    }

uint64_t sub_1000661A0(uint64_t a1, unsigned int a2, unsigned int a3)
{
  if (*(void *)a1 != qword_10008CF38) {
    return 39LL;
  }
  uint64_t v5 = *(void **)(a1 + 16);
  if (!v5 || *v5 != qword_10008CF08) {
    return 40LL;
  }
  uint64_t result = sub_10005EF64((uint64_t)v5, a2);
  if (!(_DWORD)result)
  {
    uint64_t result = sub_10005EF64(*(void *)(a1 + 16), a3);
    if (!(_DWORD)result)
    {
      *(_DWORD *)(a1 + 44) = 0;
      uint64_t result = sub_1000602F8(*(void *)(a1 + 16), 8u);
      if ((_DWORD)result == 41 || !(_DWORD)result)
      {
        int v7 = random();
        uint64_t result = 0LL;
        *(_DWORD *)(a1 + 4__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = v7;
      }
    }
  }

  return result;
}

uint64_t sub_10006624C(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (*(void *)a1 != qword_10008CF38) {
    return 39LL;
  }
  int v7 = *(void **)(a1 + 16);
  if (!v7) {
    return 39LL;
  }
  if (*v7 != qword_10008CF08) {
    return 39LL;
  }
  if (*(void *)a3 != qword_10008CF30) {
    return 39LL;
  }
  uint64_t v10 = a2;
  if (a4)
  {
    if (*a4 != *(void *)a3) {
      return 39LL;
    }
  }

  uint64_t v11 = a1 + 96;
  if (!a2)
  {
    if (*(void *)v11 && (uint64_t v11 = *(void *)(a1 + 88)) != 0)
    {
      a2 = *(void *)(v11 + 16);
LABEL_16:
      *(_DWORD *)(a3 + 88) = *(_DWORD *)(v11 + 8);
      uint64_t v4 = sub_10005CFB8((void *)(a3 + 96), a2);
      if ((_DWORD)v4) {
        return v4;
      }
      uint64_t v4 = sub_10005EF64((uint64_t)v7, *(_DWORD *)(v11 + 8));
      if (!(_DWORD)v4)
      {
        unsigned int v20 = 0;
        uint64_t v12 = sub_100068188((uint64_t)v7, 0, "output-authenticator", *(const char **)(v11 + 16));
        if ((_DWORD)v12 || (uint64_t v12 = sub_1000604BC(v7, &v20), (_DWORD)v12))
        {
LABEL_37:
          uint64_t v4 = v12;
          goto LABEL_38;
        }

        char v13 = 0;
        unsigned int v14 = v20;
LABEL_24:
        uint64_t v12 = sub_10005EF64((uint64_t)v7, v14);
        if (!(_DWORD)v12)
        {
          uint64_t v12 = sub_10005EF64((uint64_t)v7, *(_DWORD *)(a3 + 104));
          if (!(_DWORD)v12)
          {
            unsigned int v15 = *(_DWORD *)(a3 + 108);
            if (!v15)
            {
              uint64_t v16 = *(void *)(a3 + 48);
              if (v16) {
                unsigned int v15 = *(_DWORD *)(v16 + 12);
              }
              else {
                unsigned int v15 = 0;
              }
            }

            uint64_t v12 = sub_10005EF64((uint64_t)v7, v15);
            if (!(_DWORD)v12)
            {
              unsigned int v17 = *(_DWORD *)(a1 + 40);
              *(_DWORD *)(a1 + 4__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = v17 + 1;
              *(_DWORD *)(a3 + 112) = v17;
              uint64_t v12 = sub_10005EF64((uint64_t)v7, v17);
              if (!(_DWORD)v12)
              {
                uint64_t v18 = (unsigned int *)(a4 + 14);
                if (!a4) {
                  uint64_t v18 = (unsigned int *)(a3 + 116);
                }
                uint64_t v12 = sub_10005EF64((uint64_t)v7, *v18);
                if (!(_DWORD)v12)
                {
                  uint64_t v12 = sub_1000684D0((uint64_t)v7, v10, a3);
                  if (!(_DWORD)v12)
                  {
                    uint64_t v12 = sub_10005EFD8((uint64_t)v7, 0);
                    if (!(_DWORD)v12)
                    {
                      uint64_t v19 = *(void *)(a3 + 48);
                      if (!v19 || (uint64_t v12 = sub_1000684D0((uint64_t)v7, v10, v19), !(_DWORD)v12))
                      {
                        uint64_t v12 = sub_10005EFD8((uint64_t)v7, 0);
                        if (!(_DWORD)v12)
                        {
                          if ((v13 & 1) != 0)
                          {
LABEL_43:
                            if (!a4) {
                              sub_10005CFB8((void *)(a3 + 64), a1);
                            }
                            return 0LL;
                          }

                          uint64_t v21 = 0LL;
                          uint64_t v12 = sub_1000683F8((uint64_t)v7, 0, "output-signature");
                          if (!(_DWORD)v12)
                          {
                            uint64_t v4 = sub_10005E7A4((uint64_t)v7, (uint64_t)(v21[2] + 3), v21[2][2]);
                            sub_10005D71C( &v21,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/protocol.c",  326LL);
                            if ((_DWORD)v4) {
                              goto LABEL_38;
                            }
                            uint64_t v12 = sub_100067E68((uint64_t)v7, 0, "output-authenticator");
                            if (!(_DWORD)v12) {
                              goto LABEL_43;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

        goto LABEL_37;
      }
    }

    else
    {
      uint64_t v4 = sub_10005EF64(*(void *)(a1 + 16), 0);
      if (!(_DWORD)v4)
      {
        unsigned int v14 = 0;
        unsigned int v20 = 0;
        char v13 = 1;
        goto LABEL_24;
      }
    }

uint64_t sub_10006654C(uint64_t a1, char *__s1, unsigned int *a3)
{
  uint64_t v46 = a3;
  if (*(void *)a1 != qword_10008CF38) {
    return 34LL;
  }
  if (!strcmp(__s1, "connect"))
  {
    uint64_t i = sub_1000661A0(a1, 0x64u, 0x18u);
    if (!(_DWORD)i) {
      return i;
    }
LABEL_15:
    uint64_t v16 = *(void *)(a1 + 16);
LABEL_16:
    sub_100060130(v16, 1);
    return i;
  }

  if (!strcmp(__s1, "status"))
  {
    unsigned int v14 = v46;
    v46 += 2;
    uint64_t i = *v14;
    uint64_t v15 = *(void *)(a1 + 24);
    if (!(_DWORD)i) {
      return sub_100067DF8(v15);
    }
    sub_100067DF8(v15);
    goto LABEL_15;
  }

  if (!strcmp(__s1, "disconnect"))
  {
    for (uint64_t i = qword_10008CEC8; i; uint64_t i = *(void *)(i + 32))
    {
      if (*(void *)(i + 64) == a1)
      {
        uint64_t v17 = *(void *)(i + 48);
        if (v17) {
          sub_100067DAC(v17);
        }
      }
    }

    return i;
  }

  if (!strcmp(__s1, "ready"))
  {
    uint64_t v18 = *(void **)(a1 + 16);
    if (!v18 || *v18 != qword_10008CF08) {
      return 39LL;
    }
    switch(*(_DWORD *)(a1 + 44))
    {
      case 0:
        sub_10005EF20(*(void *)(a1 + 16), (_DWORD *)(a1 + 36));
        sub_10005EF20((uint64_t)v18, (_DWORD *)(a1 + 32));
        if (*(_DWORD *)(a1 + 36) == 100)
        {
          if (*(_DWORD *)(a1 + 32) > 0x17u)
          {
            uint64_t v19 = *(void *)(a1 + 88);
            if (v19)
            {
              uint64_t v20 = sub_100066BE8((const char *)a1, 0LL, "authenticator", *(const char **)(v19 + 16), 8);
              if ((_DWORD)v20) {
                goto LABEL_38;
              }
            }

            else
            {
              sub_100067DF8(*(void *)(a1 + 24));
            }

            goto LABEL_40;
          }

          sub_100060130((uint64_t)v18, 1);
          return 38LL;
        }

        else
        {
          sub_100060130((uint64_t)v18, 1);
          return 37LL;
        }

      case 1:
        goto LABEL_41;
      case 2:
        goto LABEL_71;
      case 3:
        goto LABEL_54;
      case 4:
        goto LABEL_51;
      case 5:
        goto LABEL_58;
      case 6:
        break;
      default:
        return 0LL;
    }

uint64_t sub_100066BE8(const char *a1, uint64_t a2, const char *a3, const char *a4, char a5)
{
  *(void *)uint64_t v15 = 0LL;
  if (*(void *)a1 != qword_10008CF38) {
    return 39LL;
  }
  uint64_t v11 = sub_100064338(v15, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/protocol.c", 1211LL);
  uint64_t v12 = *(void **)v15;
  if ((_DWORD)v11)
  {
    uint64_t v5 = v11;
    if (!*(void *)v15) {
      return v5;
    }
LABEL_5:
    sub_1000235C8(v15, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/protocol.c", 1253LL);
    return v5;
  }

  uint64_t v5 = sub_100068064(*(uint64_t *)v15, 0, "op", (const char *)1);
  if (!(_DWORD)v5)
  {
    uint64_t v14 = sub_100068188((uint64_t)v12, 0, "object", a4);
    uint64_t v5 = v14;
    if ((a5 & 1) != 0 && !(_DWORD)v14) {
      uint64_t v5 = sub_100067F40((uint64_t)v12, 0, "create", (const char *)1);
    }
    if ((a5 & 2) != 0 && !(_DWORD)v5) {
      uint64_t v5 = sub_100067F40((uint64_t)v12, 0, "update", (const char *)1);
    }
    if ((a5 & 4) != 0 && !(_DWORD)v5) {
      uint64_t v5 = sub_100067F40((uint64_t)v12, 0, "exclusive", (const char *)1);
    }
    if ((a5 & 8) != 0 && !(_DWORD)v5) {
      uint64_t v5 = sub_100068188((uint64_t)v12, 0, "notify-object", a1);
    }
    if (a3 && !(_DWORD)v5) {
      uint64_t v5 = sub_1000682AC((uint64_t)v12, 0, "type", a3);
    }
    if (!(_DWORD)v5)
    {
      uint64_t v5 = sub_100064BE8(v12);
      if (!(_DWORD)v5)
      {
        uint64_t v5 = sub_10006624C((uint64_t)a1, a2, (uint64_t)v12, 0LL);
        if ((_DWORD)v5) {
          sub_10006495C(v12);
        }
      }
    }
  }

  if (*(void *)v15) {
    goto LABEL_5;
  }
  return v5;
}

uint64_t sub_100066DC8(void *a1, void *a2, int a3)
{
  if (*a2 != qword_10008CF38) {
    return 39LL;
  }
  uint64_t v4 = a2 + 12;
  while (1)
  {
    uint64_t v4 = (void *)*v4;
    if (!v4) {
      break;
    }
    if (*((_DWORD *)v4 + 2) == a3) {
      return sub_10005CFB8(a1, v4[2]);
    }
  }

  return 47LL;
}

uint64_t sub_100066E1C(void *a1, uint64_t a2, const char *a3, const char *a4, const char *a5)
{
  *(void *)uint64_t v18 = 0LL;
  if (*a1 != qword_10008CF38) {
    return 39LL;
  }
  uint64_t v5 = sub_100064338(v18, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/protocol.c", 1153LL);
  if (!(_DWORD)v5)
  {
    uint64_t v11 = *(void *)v18;
    uint64_t v12 = sub_100068064(*(uint64_t *)v18, 0, "op", (const char *)5);
    if ((_DWORD)v12)
    {
      uint64_t v5 = v12;
      uint64_t v13 = 1161LL;
    }

    else
    {
      uint64_t v14 = sub_100068064(v11, 0, "rid", a4);
      if ((_DWORD)v14)
      {
        uint64_t v5 = v14;
        uint64_t v13 = 1168LL;
      }

      else
      {
        uint64_t v15 = sub_100068064(v11, 0, "result", a3);
        if ((_DWORD)v15)
        {
          uint64_t v5 = v15;
          uint64_t v13 = 1175LL;
        }

        else if (a5 && (uint64_t v16 = sub_1000682AC(v11, 0, "message", a5), (_DWORD)v16))
        {
          uint64_t v5 = v16;
          uint64_t v13 = 1184LL;
        }

        else
        {
          uint64_t v5 = sub_10006624C((uint64_t)a1, a2, v11, 0LL);
          uint64_t v13 = 1190LL;
        }
      }
    }

    sub_1000235C8(v18, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/protocol.c", v13);
  }

  return v5;
}

uint64_t sub_100066F80(void *a1, void *a2, int a3)
{
  if (*a2 != qword_10008CF00)
  {
    uint64_t v6 = (void *)a2[3];
    if (!v6 || *v6 != qword_10008CF00) {
      return 39LL;
    }
  }

  if (*a1 != qword_10008CF38) {
    return 39LL;
  }
  uint64_t v9 = (uint64_t (*)(void *, void *))a1[14];
  if (v9)
  {
    uint64_t v7 = v9(a1, a2);
    if ((_DWORD)v7) {
      return v7;
    }
  }

  uint64_t v10 = a1[11];
  if (!v10 || a1[12])
  {
    uint64_t v11 = sub_10005CDE4(0x18uLL);
    if (!v11) {
      return 1LL;
    }
    uint64_t v12 = v11;
    uint64_t v7 = sub_10005CFB8((void *)v11 + 2, (uint64_t)a2);
    if ((_DWORD)v7)
    {
      sub_10005CE20( v12,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/protocol.c",  820LL,  v13,  v14,  v15,  v16,  v17);
    }

    else
    {
      _BYTE v12[2] = a3;
      *(void *)uint64_t v12 = a1[12];
      a1[12] = v12;
    }

    return v7;
  }

  if (*(void **)(v10 + 16) != a2)
  {
    sub_100060130(a1[2], 1);
    return 34LL;
  }

  a1[12] = v10;
  *(_DWORD *)(v10 + 8) = a3;
  return sub_100067DF8(a1[3]);
}

uint64_t sub_1000670E4(void *a1, int a2, uint64_t a3, uint64_t a4)
{
  if (*a1 != qword_10008CF38) {
    return 39LL;
  }
  if (sub_100068648(a3, "default-authenticator"))
  {
    uint64_t v7 = a1[3];
    else {
      return 23LL;
    }
  }

  else
  {
    if (*(_DWORD *)(a4 + 4) != 3) {
      return 39LL;
    }
    uint64_t v9 = *(void *)(a4 + 8);
    if (v9)
    {
      uint64_t v10 = a1 + 12;
      while (1)
      {
        uint64_t v10 = (void *)*v10;
        if (!v10) {
          break;
        }
        if (v10[2] == v9)
        {
          uint64_t result = 0LL;
          a1[11] = v10;
          return result;
        }
      }

      return 47LL;
    }

    else
    {
      uint64_t result = 0LL;
      a1[11] = 0LL;
    }
  }

  return result;
}

uint64_t sub_1000671C8(void *a1, int a2, _DWORD *a3, int ***a4)
{
  if (*a1 != qword_10008CF38) {
    return 39LL;
  }
  if (sub_100068648((uint64_t)a3, "default-authenticator"))
  {
    uint64_t v8 = a1[3];
    if (v8)
    {
      uint64_t v9 = *(uint64_t (**)(void))(*(void *)v8 + 24LL);
      if (v9) {
        return v9();
      }
    }
  }

  else
  {
    uint64_t v10 = a1[11];
    if (v10) {
      return sub_1000689D4( a4,  a3,  *(const char **)(v10 + 16),  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/protocol.c",  903LL);
    }
  }

  return 23LL;
}

uint64_t sub_100067290( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a1 != qword_10008CF38) {
    return 39LL;
  }
  uint64_t v13 = a1[7];
  uint64_t v12 = a1 + 7;
  if (v13) {
    sub_1000235C8(v12, a2, a3);
  }
  uint64_t v14 = (void *)a1[11];
  if (!v14 || a1[12]) {
    goto LABEL_8;
  }
  while (1)
  {
    sub_10005CE20(v14, a2, a3, a4, a5, a6, a7, a8);
LABEL_8:
    uint64_t v15 = (void *)a1[12];
    if (!v15) {
      break;
    }
    uint64_t v16 = (_DWORD **)*v15;
    a1[12] = *v15;
    if (!v16) {
      break;
    }
    sub_10005CFEC(v16 + 2, a2, a3);
    uint64_t v14 = v16;
  }

  return 0LL;
}

uint64_t sub_10006733C(uint64_t a1, uint64_t a2, void *a3)
{
  if (*a3 != qword_10008CF38) {
    return 39LL;
  }
  uint64_t v4 = a3[3];
  else {
    return 0LL;
  }
}

BOOL sub_10006737C(uint64_t a1)
{
  return *(void *)a1 == qword_10008CF38 && *(_DWORD *)(a1 + 104) == 0;
}

uint64_t sub_1000673AC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void **)(a1 + 16);
  if (v3 && *v3 == qword_10008CF40) {
    a1 = *(void *)(a1 + 16);
  }
  if (*(void *)a1 != qword_10008CF40) {
    return 39LL;
  }
  *(void *)(a1 + 4__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = a3;
  *(_DWORD *)(a1 + 32) = 0;
  return sub_10006418C(*(void **)(a1 + 16), a2);
}

uint64_t sub_1000673F0(uint64_t a1, int a2, int a3)
{
  uint64_t v12 = 0LL;
  uint64_t v6 = sub_10005CE50( (void **)&v12,  (void *)qword_10008CF40,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/protocol.c",  1006LL);
  if (!(_DWORD)v6)
  {
    uint64_t v7 = sub_10005CFB8((void *)(a1 + 16), (uint64_t)v12);
    if ((_DWORD)v7)
    {
      uint64_t v6 = v7;
      uint64_t v8 = 1013LL;
    }

    else
    {
      uint64_t v9 = sub_10005CFB8(v12 + 3, a1);
      if ((_DWORD)v9)
      {
        uint64_t v6 = v9;
        uint64_t v8 = 1018LL;
      }

      else
      {
        uint64_t v10 = (uint64_t)v12;
        *((_DWORD *)v12 + 8) = 1;
        uint64_t v6 = sub_1000638EC(v10, a2, a3);
        uint64_t v8 = 1026LL;
      }
    }

    sub_10005CFEC((_DWORD **)&v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/protocol.c", v8);
  }

  return v6;
}

uint64_t sub_1000674DC(uint64_t a1, char *__s1, void **a3)
{
  uint64_t v12 = a3;
  if (!a1 || *(void *)a1 != qword_10008CF40) {
    return 39LL;
  }
  if (!strcmp(__s1, "connect"))
  {
    uint64_t v8 = v12++;
    uint64_t v9 = *v8;
    if (*v8 && *v9 == qword_10008CF08)
    {
      uint64_t v11 = 0LL;
      uint64_t v4 = sub_10005CE50( (void **)&v11,  (void *)qword_10008CF38,  0LL,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/protocol.c",  1058LL);
      if (!(_DWORD)v4)
      {
        uint64_t v10 = v11;
        v11[14] = *(void *)(a1 + 40);
        *((_DWORD *)v10 + 26) = *(_DWORD *)(a1 + 32);
        uint64_t v4 = sub_10005CFB8(v10 + 2, (uint64_t)v9);
        if ((_DWORD)v4
          || (uint64_t v4 = sub_10005CFB8(v9 + 3, (uint64_t)v11), (_DWORD)v4)
          || (uint64_t v4 = sub_1000661A0((uint64_t)v11, 0x64u, 0x18u), (_DWORD)v4))
        {
          sub_10005CFEC( (_DWORD **)&v11,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/protocol.c",  1068LL);
          sub_100060130((uint64_t)v9, 1);
        }

        else
        {
          sub_10005CFEC( (_DWORD **)&v11,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/protocol.c",  1085LL);
        }
      }

      return v4;
    }

    return 39LL;
  }

  uint64_t v6 = *(void *)(a1 + 24);
  if (!v6) {
    return 23LL;
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 40LL);
  if (!v7) {
    return 23LL;
  }
  return v7();
}

uint64_t sub_100067688(void *a1)
{
  if (*a1 != qword_10008CF40) {
    return 39LL;
  }
  uint64_t v2 = a1[3];
  else {
    return 23LL;
  }
}

uint64_t sub_1000676C8(void *a1)
{
  if (*a1 != qword_10008CF40) {
    return 39LL;
  }
  uint64_t v2 = a1[3];
  else {
    return 23LL;
  }
}

uint64_t sub_100067708(void *a1)
{
  if (*a1 == qword_10008CF40) {
    return 0LL;
  }
  else {
    return 39LL;
  }
}

uint64_t sub_100067728(uint64_t a1, uint64_t a2, void *a3)
{
  if (*a3 != qword_10008CF40) {
    return 39LL;
  }
  uint64_t v4 = a3[3];
  else {
    return 0LL;
  }
}

uint64_t sub_100067768(void *a1, uint64_t a2, const char *a3, const char *a4)
{
  *(void *)uint64_t v18 = 0LL;
  if (*a1 == qword_10008CF38)
  {
    uint64_t v4 = sub_100064338(v18, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/protocol.c", 1270LL);
    if ((_DWORD)v4) {
      return v4;
    }
    uint64_t v9 = *(void *)v18;
    uint64_t v10 = sub_100068064(*(uint64_t *)v18, 0, "op", (const char *)3);
    if ((_DWORD)v10)
    {
      uint64_t v4 = v10;
      uint64_t v11 = 1278LL;
LABEL_16:
      sub_1000235C8(v18, "/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/protocol.c", v11);
      return v4;
    }

    if ((_DWORD)a3)
    {
      uint64_t v12 = sub_100068064(v9, 0, "rid", a3);
      if ((_DWORD)v12)
      {
        uint64_t v4 = v12;
        uint64_t v11 = 1287LL;
        goto LABEL_16;
      }

      uint64_t v13 = sub_100062B58(&v17, (uint64_t)a4);
      if ((_DWORD)v13)
      {
        uint64_t v4 = v13;
        uint64_t v11 = 1293LL;
        goto LABEL_16;
      }

      uint64_t v14 = sub_100068064(v9, 0, "handle", (const char *)v17);
      if ((_DWORD)v14)
      {
        uint64_t v4 = v14;
        uint64_t v11 = 1299LL;
        goto LABEL_16;
      }
    }

    uint64_t v15 = sub_100068188(v9, 0, "object", a4);
    if ((_DWORD)v15)
    {
      uint64_t v4 = v15;
      uint64_t v11 = 1307LL;
    }

    else
    {
      uint64_t v4 = sub_10006624C((uint64_t)a1, a2, v9, 0LL);
      uint64_t v11 = 1312LL;
    }

    goto LABEL_16;
  }

  return 39LL;
}

char *sub_100067900(unsigned int a1)
{
  if (a1 <= 0x45) {
    return off_100084978[a1];
  }
  uint64_t v1 = byte_1000C5F6B;
  __sprintf_chk(byte_1000C5F6B, 0, 0x28uLL, "unknown error: %d", a1);
  return v1;
}

uint64_t sub_100067960()
{
  if (sub_100067CD0( &qword_10008CF08,  (uint64_t)"connection",  (uint64_t)sub_100060518,  (uint64_t)sub_100060824,  (uint64_t)sub_100060A38,  (uint64_t)sub_100060AD0,  (uint64_t)sub_100060B10,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  168LL,  0LL,  2)
    || sub_100067CD0( &qword_10008CF28,  (uint64_t)"listener",  (uint64_t)sub_1000641BC,  (uint64_t)sub_1000641FC,  (uint64_t)sub_10006423C,  (uint64_t)sub_10006429C,  (uint64_t)sub_1000642DC,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  64LL,  0LL,  2)
    || sub_100067CD0( &qword_10008CF20,  (uint64_t)"io",  (uint64_t)sub_100061C58,  (uint64_t)sub_100061C98,  (uint64_t)sub_100061CD8,  (uint64_t)sub_100061DDC,  (uint64_t)sub_100061E1C,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  80LL,  0LL,  2)
    || sub_100067CD0( &qword_10008CF18,  (uint64_t)"generic",  (uint64_t)sub_100062460,  (uint64_t)sub_1000627A0,  (uint64_t)sub_1000628A0,  (uint64_t)sub_100062970,  (uint64_t)sub_1000629B0,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  56LL,  0LL,  2)
    || sub_100067CD0( &qword_10008CF38,  (uint64_t)"protocol",  (uint64_t)sub_1000670E4,  (uint64_t)sub_1000671C8,  (uint64_t)sub_100067290,  (uint64_t)sub_10006654C,  (uint64_t)sub_10006733C,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  120LL,  0LL,  2)
    || sub_100067CD0( &qword_10008CF40,  (uint64_t)"protocol-listener",  (uint64_t)sub_100067688,  (uint64_t)sub_1000676C8,  (uint64_t)sub_100067708,  (uint64_t)sub_1000674DC,  (uint64_t)sub_100067728,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  48LL,  0LL,  2)
    || sub_100067CD0( &qword_10008CF30,  (uint64_t)"message",  (uint64_t)sub_100064434,  (uint64_t)sub_100064688,  (uint64_t)sub_100064878,  (uint64_t)sub_100064AF0,  (uint64_t)sub_100064BA8,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  120LL,  0LL,  2)
    || sub_100067CD0( &qword_10008CF50,  (uint64_t)"waiter",  0LL,  0LL,  0LL,  (uint64_t)sub_100061E5C,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  0LL,  48LL,  0LL,  2)
    || sub_100067CD0( &qword_10008CF00,  (uint64_t)"authenticator",  0LL,  (uint64_t)sub_10005E098,  (uint64_t)sub_10005DBD0,  0LL,  (uint64_t)sub_10005DFFC,  (uint64_t)sub_10005DE04,  0LL,  0LL,  0LL,  0LL,  0LL,  56LL,  0LL,  2))
  {
    return 1LL;
  }

  sub_100063FFC();
  sub_10005FCA4();
  sub_10005E24C();
  sub_100065554();
  return 0LL;
}

uint64_t sub_100067CD0( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16)
{
  int v24 = sub_10005CDE4(0x80uLL);
  if (!v24) {
    return 1LL;
  }
  *int v24 = 0u;
  v24[1] = 0u;
  v24[2] = 0u;
  v24[3] = 0u;
  v24[6] = 0u;
  v24[7] = 0u;
  v24[4] = 0u;
  unsigned int v24[5] = 0u;
  *(void *)int v24 = a2;
  *((void *)v24 + 3) = a4;
  *((void *)v24 + 4) = a5;
  *((void *)v24 + 5) = a6;
  *((void *)v24 + 6) = a7;
  *((void *)v24 + 7) = a8;
  *((void *)v24 + 8) = a9;
  *((void *)v24 + 9) = a10;
  *((void *)v24 + 1__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = a11;
  *((void *)v24 + 1) = qword_10008CEF8;
  *((void *)v24 + 2) = a3;
  *((void *)v24 + 12) = a13;
  *((void *)v24 + 13) = a14;
  *((void *)v24 + 11) = a12;
  *((void *)v24 + 15) = a15;
  *((_DWORD *)v24 + 28) = a16;
  qword_10008CEF8 = (uint64_t)v24;
  uint64_t v25 = 0LL;
  if (a1) {
    *a1 = v24;
  }
  return v25;
}

uint64_t sub_100067DAC(uint64_t a1)
{
  do
  {
    uint64_t v2 = a1;
    a1 = *(void *)(a1 + 16);
  }

  while (a1);
  uint64_t v3 = *(uint64_t (**)(void))(*(void *)v2 + 40LL);
  if (v3) {
    return v3();
  }
  else {
    return 23LL;
  }
}

uint64_t sub_100067DF8(uint64_t a1)
{
  if (!a1) {
    return 23LL;
  }
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)a1 + 40LL);
  if (v1) {
    return v1();
  }
  else {
    return 23LL;
  }
}

uint64_t sub_100067E40(uint64_t a1)
{
  do
  {
    uint64_t v2 = a1;
    a1 = *(void *)(a1 + 16);
  }

  while (a1);
  uint64_t v3 = *(uint64_t (**)(void))(*(void *)v2 + 16LL);
  if (v3) {
    return v3();
  }
  else {
    return 23LL;
  }
}

uint64_t sub_100067E68(uint64_t a1, int a2, char *__s)
{
  uint64_t v11 = 0LL;
  unsigned int v5 = strlen(__s);
  uint64_t v6 = sub_10005D5E0(&v11, v5);
  if (!(_DWORD)v6)
  {
    size_t v7 = strlen(__s);
    memcpy(v11 + 2, __s, v7);
    do
    {
      uint64_t v8 = a1;
      a1 = *(void *)(a1 + 16);
    }

    while (a1);
    uint64_t v9 = *(uint64_t (**)(void))(*(void *)v8 + 16LL);
    if (v9) {
      uint64_t v6 = v9();
    }
    else {
      uint64_t v6 = 23LL;
    }
    sub_10005D658(&v11);
  }

  return v6;
}

uint64_t sub_100067F40(uint64_t a1, int a2, char *__s, const char *a4)
{
  uint64_t v18 = 0LL;
  uint64_t v19 = 0LL;
  unsigned int v7 = strlen(__s);
  uint64_t v8 = sub_10005D5E0(&v18, v7);
  if (!(_DWORD)v8)
  {
    size_t v9 = strlen(__s);
    memcpy(v18 + 2, __s, v9);
    uint64_t v14 = sub_10005D348( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/support.c",  392LL,  &v19,  0,  v10,  v11,  v12,  v13,  a4);
    if ((_DWORD)v14)
    {
      uint64_t v8 = v14;
      sub_10005D658(&v18);
    }

    else
    {
      do
      {
        uint64_t v15 = a1;
        a1 = *(void *)(a1 + 16);
      }

      while (a1);
      uint64_t v16 = *(uint64_t (**)(void))(*(void *)v15 + 16LL);
      if (v16) {
        uint64_t v8 = v16();
      }
      else {
        uint64_t v8 = 23LL;
      }
      sub_10005D658(&v18);
      sub_10005D538(&v19, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/support.c", 400LL);
    }
  }

  return v8;
}

uint64_t sub_100068064(uint64_t a1, int a2, char *__s, const char *a4)
{
  uint64_t v18 = 0LL;
  uint64_t v19 = 0LL;
  unsigned int v7 = strlen(__s);
  uint64_t v8 = sub_10005D5E0(&v18, v7);
  if (!(_DWORD)v8)
  {
    size_t v9 = strlen(__s);
    memcpy(v18 + 2, __s, v9);
    uint64_t v14 = sub_10005D348( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/support.c",  416LL,  &v19,  0,  v10,  v11,  v12,  v13,  a4);
    if ((_DWORD)v14)
    {
      uint64_t v8 = v14;
      sub_10005D658(&v18);
    }

    else
    {
      do
      {
        uint64_t v15 = a1;
        a1 = *(void *)(a1 + 16);
      }

      while (a1);
      uint64_t v16 = *(uint64_t (**)(void))(*(void *)v15 + 16LL);
      if (v16) {
        uint64_t v8 = v16();
      }
      else {
        uint64_t v8 = 23LL;
      }
      sub_10005D658(&v18);
      sub_10005D538(&v19, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/support.c", 424LL);
    }
  }

  return v8;
}

uint64_t sub_100068188(uint64_t a1, int a2, char *__s, const char *a4)
{
  uint64_t v18 = 0LL;
  uint64_t v19 = 0LL;
  unsigned int v7 = strlen(__s);
  uint64_t v8 = sub_10005D5E0(&v18, v7);
  if (!(_DWORD)v8)
  {
    size_t v9 = strlen(__s);
    memcpy(v18 + 2, __s, v9);
    uint64_t v14 = sub_10005D348( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/support.c",  440LL,  &v19,  3,  v10,  v11,  v12,  v13,  a4);
    if ((_DWORD)v14)
    {
      uint64_t v8 = v14;
      sub_10005D658(&v18);
    }

    else
    {
      do
      {
        uint64_t v15 = a1;
        a1 = *(void *)(a1 + 16);
      }

      while (a1);
      uint64_t v16 = *(uint64_t (**)(void))(*(void *)v15 + 16LL);
      if (v16) {
        uint64_t v8 = v16();
      }
      else {
        uint64_t v8 = 23LL;
      }
      sub_10005D658(&v18);
      sub_10005D538(&v19, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/support.c", 448LL);
    }
  }

  return v8;
}

uint64_t sub_1000682AC(uint64_t a1, int a2, char *__s, const char *a4)
{
  uint64_t v18 = 0LL;
  uint64_t v19 = 0LL;
  unsigned int v7 = strlen(__s);
  uint64_t v8 = sub_10005D5E0(&v18, v7);
  if (!(_DWORD)v8)
  {
    size_t v9 = strlen(__s);
    memcpy(v18 + 2, __s, v9);
    uint64_t v14 = sub_10005D348( (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/support.c",  464LL,  &v19,  1,  v10,  v11,  v12,  v13,  a4);
    if ((_DWORD)v14)
    {
      uint64_t v8 = v14;
      sub_10005D658(&v18);
    }

    else
    {
      do
      {
        uint64_t v15 = a1;
        a1 = *(void *)(a1 + 16);
      }

      while (a1);
      uint64_t v16 = *(uint64_t (**)(void))(*(void *)v15 + 16LL);
      if (v16) {
        uint64_t v8 = v16();
      }
      else {
        uint64_t v8 = 23LL;
      }
      sub_10005D658(&v18);
      sub_10005D538(&v19, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/support.c", 472LL);
    }
  }

  return v8;
}

uint64_t sub_1000683D0(uint64_t a1)
{
  do
  {
    uint64_t v2 = a1;
    a1 = *(void *)(a1 + 16);
  }

  while (a1);
  uint64_t v3 = *(uint64_t (**)(void))(*(void *)v2 + 24LL);
  if (v3) {
    return v3();
  }
  else {
    return 23LL;
  }
}

uint64_t sub_1000683F8(uint64_t a1, int a2, char *__s)
{
  uint64_t v11 = 0LL;
  unsigned int v5 = strlen(__s);
  uint64_t v6 = sub_10005D5E0(&v11, v5);
  if (!(_DWORD)v6)
  {
    size_t v7 = strlen(__s);
    memcpy(v11 + 2, __s, v7);
    do
    {
      uint64_t v8 = a1;
      a1 = *(void *)(a1 + 16);
    }

    while (a1);
    size_t v9 = *(uint64_t (**)(void))(*(void *)v8 + 24LL);
    if (v9) {
      uint64_t v6 = v9();
    }
    else {
      uint64_t v6 = 23LL;
    }
    sub_10005D658(&v11);
  }

  return v6;
}

uint64_t sub_1000684D0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  do
  {
    uint64_t v4 = a3;
    a3 = *(void *)(a3 + 16);
  }

  while (a3);
  unsigned int v5 = *(uint64_t (**)(void))(*(void *)v4 + 48LL);
  if (v5) {
    return v5();
  }
  else {
    return 23LL;
  }
}

uint64_t sub_1000684F8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(uint64_t (**)(void))(a3 + 64);
  if (v3) {
    return v3();
  }
  else {
    return 27LL;
  }
}

uint64_t sub_10006850C(uint64_t a1, int a2, uint64_t a3, const char *a4)
{
  if (!a3) {
    return 39LL;
  }
  if (*(void *)a3 != qword_10008CF18) {
    return 27LL;
  }
  if (*(int *)(a3 + 48) < 1)
  {
LABEL_16:
    if ((_DWORD)a4) {
      sub_100068064(a1, a2, "remote-handle", a4);
    }
    LODWORD(result) = sub_100067DAC(a1);
    if ((_DWORD)result == 23) {
      return 0LL;
    }
    else {
      return result;
    }
  }

  else
  {
    uint64_t v9 = 0LL;
    while (1)
    {
      uint64_t v10 = a1;
      do
      {
        uint64_t v11 = v10;
        uint64_t v10 = *(void *)(v10 + 16);
      }

      while (v10);
      uint64_t v12 = *(uint64_t (**)(void))(*(void *)v11 + 16LL);
      if (!v12) {
        return 23LL;
      }
      uint64_t result = v12();
      if ((_DWORD)result != 42 && (_DWORD)result != 0) {
        return result;
      }
    }
  }

uint64_t sub_100068604(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 4);
  unsigned int v3 = *(_DWORD *)(a2 + 4);
  BOOL v4 = v2 > v3;
  if (v2 >= v3) {
    size_t v5 = v3;
  }
  else {
    size_t v5 = v2;
  }
  uint64_t v6 = (const void *)(a1 + 8);
  size_t v7 = (const void *)(a2 + 8);
  if (v2 >= v3) {
    int v8 = 0;
  }
  else {
    int v8 = -1;
  }
  if (v4) {
    unsigned int v9 = 1;
  }
  else {
    unsigned int v9 = v8;
  }
  LODWORD(result) = memcmp(v6, v7, v5);
  if ((_DWORD)result) {
    return result;
  }
  else {
    return v9;
  }
}

uint64_t sub_100068648(uint64_t a1, char *__s)
{
  unsigned int v4 = strlen(__s);
  unsigned int v5 = *(_DWORD *)(a1 + 4);
  BOOL v6 = v5 >= v4;
  BOOL v7 = v5 > v4;
  if (v5 >= v4) {
    size_t v8 = v4;
  }
  else {
    size_t v8 = v5;
  }
  unsigned int v9 = (const void *)(a1 + 8);
  if (v6) {
    int v10 = 0;
  }
  else {
    int v10 = -1;
  }
  if (v7) {
    unsigned int v11 = 1;
  }
  else {
    unsigned int v11 = v10;
  }
  LODWORD(result) = memcmp(v9, __s, v8);
  if ((_DWORD)result) {
    return result;
  }
  else {
    return v11;
  }
}

uint64_t sub_100068698(_DWORD *a1, char *__s)
{
  unsigned int v4 = strlen(__s);
  unsigned int v5 = v4;
  unsigned int v6 = a1[2];
  if (v6 >= v4) {
    size_t v7 = v4;
  }
  else {
    size_t v7 = v6;
  }
  uint64_t result = memcmp(a1 + 3, __s, v7);
  if (!(_DWORD)result)
  {
    if (v6 >= v5) {
      unsigned int v9 = 0;
    }
    else {
      unsigned int v9 = -1;
    }
    if (v6 > v5) {
      return 1LL;
    }
    else {
      return v9;
    }
  }

  return result;
}

uint64_t sub_10006870C(uint64_t a1, char *__s)
{
  unsigned int v4 = strlen(__s);
  unsigned int v5 = v4;
  unsigned int v6 = *(_DWORD *)(a1 + 8);
  if (v6 >= v4) {
    uint64_t v7 = v4;
  }
  else {
    uint64_t v7 = v6;
  }
  uint64_t result = sub_100063224((char *)(a1 + 12), __s, v7);
  if (!(_DWORD)result)
  {
    unsigned int v9 = *(_DWORD *)(a1 + 8);
    BOOL v10 = v9 > v5;
    if (v9 >= v5) {
      unsigned int v11 = 0;
    }
    else {
      unsigned int v11 = -1;
    }
    if (v10) {
      return 1LL;
    }
    else {
      return v11;
    }
  }

  return result;
}

uint64_t sub_100068788(int ***a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = sub_10005D6B8(a1);
  if (!(_DWORD)v10)
  {
    uint64_t v10 = sub_10005D504(*a1 + 1, a2);
    if (!(_DWORD)v10)
    {
      if (!a3) {
        return 0LL;
      }
      uint64_t v10 = sub_10005D504(*a1 + 2, a3);
      if (!(_DWORD)v10) {
        return v10;
      }
    }

    sub_10005D71C(a1, a4, a5);
  }

  return v10;
}

uint64_t sub_10006883C(int ***a1, _DWORD *a2, const void *a3, const char *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12 = sub_10005D6B8(a1);
  if (!(_DWORD)v12)
  {
    uint64_t v13 = sub_10005D504(*a1 + 1, a2);
    if ((_DWORD)v13)
    {
      uint64_t v12 = v13;
    }

    else
    {
      if (!a3) {
        return 0LL;
      }
      uint64_t v12 = sub_10005D348(a5, a6, *a1 + 2, 2, v14, v15, v16, v17, a4);
      if (!(_DWORD)v12)
      {
        memcpy((*a1)[2] + 3, a3, a4);
        return v12;
      }
    }

    sub_10005D71C(a1, a5, a6);
  }

  return v12;
}

uint64_t sub_100068920(int ***a1, _DWORD *a2, const char *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = sub_10005D6B8(a1);
  if (!(_DWORD)v10)
  {
    uint64_t v10 = sub_10005D504(*a1 + 1, a2);
    if ((_DWORD)v10 || (uint64_t v10 = sub_10005D348(a4, a5, *a1 + 2, 0, v11, v12, v13, v14, a3), (_DWORD)v10)) {
      sub_10005D71C(a1, a4, a5);
    }
  }

  return v10;
}

uint64_t sub_1000689D4(int ***a1, _DWORD *a2, const char *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = sub_10005D6B8(a1);
  if (!(_DWORD)v10)
  {
    uint64_t v10 = sub_10005D504(*a1 + 1, a2);
    if (!(_DWORD)v10)
    {
      if (!a3) {
        return 0LL;
      }
      uint64_t v10 = sub_10005D348(a4, a5, *a1 + 2, 3, v11, v12, v13, v14, a3);
      if (!(_DWORD)v10) {
        return v10;
      }
    }

    sub_10005D71C(a1, a4, a5);
  }

  return v10;
}

uint64_t sub_100068A94(int ***a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = sub_10005D6B8(a1);
  if (!(_DWORD)v10)
  {
    uint64_t v10 = sub_10005D504(*a1 + 1, a2);
    if ((_DWORD)v10) {
      goto LABEL_3;
    }
    if (!a3) {
      return 0LL;
    }
    uint64_t v10 = sub_10005D348(a4, a5, *a1 + 2, 0, v11, v12, v13, v14, v16);
    if ((_DWORD)v10 || (uint64_t v10 = sub_100062B58((*a1)[2] + 2, a3), (_DWORD)v10)) {
LABEL_3:
    }
      sub_10005D71C(a1, a4, a5);
  }

  return v10;
}

uint64_t sub_100068B64(int ***a1, _DWORD *a2, const char *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = sub_10005D6B8(a1);
  if (!(_DWORD)v10)
  {
    uint64_t v10 = sub_10005D504(*a1 + 1, a2);
    if (!(_DWORD)v10)
    {
      if (!a3) {
        return 0LL;
      }
      uint64_t v10 = sub_10005D348(a4, a5, *a1 + 2, 1, v11, v12, v13, v14, a3);
      if (!(_DWORD)v10) {
        return v10;
      }
    }

    sub_10005D71C(a1, a4, a5);
  }

  return v10;
}

uint64_t sub_100068C24(void *a1, _DWORD *a2)
{
  int v2 = a2[1];
  if ((v2 - 1) >= 2)
  {
    if (!v2)
    {
      uint64_t v3 = (int)a2[2];
      goto LABEL_6;
    }

    return 39LL;
  }

  if (a2[2] != 4) {
    return 39LL;
  }
  uint64_t v3 = bswap32(a2[3]);
LABEL_6:
  uint64_t v4 = 0LL;
  *a1 = v3;
  return v4;
}

uint64_t sub_100068C6C(unsigned int a1)
{
  if (a1 > 0x12) {
    return 34LL;
  }
  else {
    return dword_10008303C[a1];
  }
}

uint64_t sub_100068C8C(int a1)
{
  else {
    return dword_100083088[a1 - 1];
  }
}

uint64_t sub_100068CB0(int a1)
{
  switch(a1)
  {
    case '2':
      uint64_t result = 1LL;
      break;
    case '3':
      uint64_t result = 2LL;
      break;
    case '4':
      uint64_t result = 3LL;
      break;
    case '5':
      uint64_t result = 4LL;
      break;
    case '6':
      uint64_t result = 5LL;
      break;
    case '7':
      uint64_t result = 6LL;
      break;
    case '8':
      uint64_t result = 7LL;
      break;
    case '9':
      uint64_t result = 8LL;
      break;
    case ':':
      uint64_t result = 9LL;
      break;
    case ';':
      uint64_t result = 10LL;
      break;
    case '<':
      uint64_t result = 16LL;
      break;
    case '=':
      uint64_t result = 17LL;
      break;
    case '>':
      uint64_t result = 18LL;
      break;
    default:
      if (a1) {
        uint64_t result = 2LL;
      }
      else {
        uint64_t result = 0LL;
      }
      break;
  }

  return result;
}

uint64_t sub_100068D4C()
{
  return byte_1000C5F98;
}

uint64_t sub_100068D58()
{
  return (dword_1000C5F9C != 0) & (byte_1000C5FA0 ^ 1u);
}

uint64_t sub_100068D7C(uint64_t (*a1)(void), uint64_t a2, uint64_t a3)
{
  if ((byte_1000C5FA4 & 1) != 0) {
    return 0LL;
  }
  off_10008CF58 = a1;
  uint64_t v4 = sub_100068E0C("trace-index-mapping", a2, (uint64_t)sub_100068EFC, (uint64_t)nullsub_22, a2, a3);
  if (!v4) {
    return 34LL;
  }
  if ((void *)qword_1000C5FA8 == v4) {
    qword_1000C5FA8 = *v4;
  }
  *((_DWORD *)v4 + 2) = 0;
  sub_100068FE0((uint64_t)v4);
  uint64_t result = 0LL;
  byte_1000C5FA4 = 1;
  return result;
}

void *sub_100068E0C(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unsigned int v11 = strlen(a1);
  uint64_t v12 = sub_10005CDE4(0x30uLL);
  uint64_t v13 = v12;
  if (v12)
  {
    *((_DWORD *)v12 + 2) = -1;
    uint64_t v14 = (char *)sub_10005CDE4(v11 + 1);
    v13[2] = v14;
    if (!v14)
    {
LABEL_6:
      sub_10005CE20(v13, a5, a6, v15, v16, v17, v18, v19);
      return 0LL;
    }

    strcpy(v14, a1);
    v13[4] = a3;
    v13[5] = a4;
    if (!dword_1000C5F9C)
    {
      *uint64_t v13 = qword_1000C5FA8;
      qword_1000C5FA8 = (uint64_t)v13;
      return v13;
    }

    if (sub_1000692D4((uint64_t)v13, v11, a5, a6))
    {
      sub_10005CE20((void *)v13[2], a5, a6, v20, v21, v22, v23, v24);
      goto LABEL_6;
    }
  }

  return v13;
}

void sub_100068EFC( uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  int v9 = a2 - 4;
  if (a2 >= 4)
  {
    uint64_t v11 = qword_1000C5FA8;
    if (qword_1000C5FA8)
    {
      uint64_t v12 = &qword_1000C5FA8;
      while (1)
      {
        uint64_t v13 = v11;
        uint64_t v14 = *(const char **)(v11 + 16);
        unsigned int v15 = strlen(v14);
        if (v9 == v15 && !memcmp(v14, a3 + 1, v15)) {
          break;
        }
        uint64_t v11 = *(void *)v13;
        uint64_t v12 = (uint64_t *)v13;
        if (!*(void *)v13) {
          goto LABEL_8;
        }
      }

      *(_DWORD *)(v13 + 8) = bswap32(*a3);
      sub_100068FE0(v13);
      *uint64_t v12 = *(void *)v13;
    }

    else
    {
LABEL_8:
      sub_10006221C("No registered trace type for type name %.*s", a2, (uint64_t)a3, a4, a5, a6, a7, a8, v9);
    }
  }

  else
  {
    sub_10006221C("short trace index mapping", a2, (uint64_t)a3, a4, a5, a6, a7, a8, a9);
  }

void sub_100068FE0(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 8);
  int v3 = v2 - dword_1000C5FB8;
  if (v2 >= dword_1000C5FB8)
  {
    unsigned int v5 = (char *)sub_10005CDE4((8 * v2 + 80));
    if (!v5) {
      return;
    }
    uint64_t v4 = v5;
    int v6 = v3 + 10;
    int v7 = dword_1000C5FB8;
    bzero(&v5[8 * dword_1000C5FB8], 8LL * v6);
    dword_1000C5FB8 = v7 + v6;
    size_t v8 = (void *)qword_1000C5FC0;
    if (qword_1000C5FC0)
    {
      memcpy(v4, (const void *)qword_1000C5FC0, 8LL * dword_1000C5FC8);
      sub_10005CE20( v8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/trace.c",  303LL,  v9,  v10,  v11,  v12,  v13);
    }

    qword_1000C5FC0 = (uint64_t)v4;
    int v2 = *(_DWORD *)(a1 + 8);
  }

  else
  {
    uint64_t v4 = (void *)qword_1000C5FC0;
  }

  *((void *)v4 + v2) = a1;
  if (v2 >= dword_1000C5FC8) {
    dword_1000C5FC8 = v2 + 1;
  }
}

uint64_t sub_1000690C0( const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (dword_1000C5F9C)
  {
    sub_10006221C("%s(%d): trace_begin called twice", a2, a3, a4, a5, a6, a7, a8, a2);
    return 39LL;
  }

  int v12 = open(a1, 2561, 384LL);
  dword_1000C5F9C = v12;
  if (v12 < 0)
  {
    if (*__error() == 17)
    {
      sub_10006221C("WARNING: Overwriting trace file %s", v31, v32, v33, v34, v35, v36, v37, (char)a1);
      int v12 = open(a1, 2049, 384LL);
      dword_1000C5F9C = v12;
      if ((v12 & 0x80000000) == 0) {
        goto LABEL_4;
      }
    }

    else
    {
      int v12 = dword_1000C5F9C;
      if ((dword_1000C5F9C & 0x80000000) == 0) {
        goto LABEL_4;
      }
    }

    sub_10006221C("%s(%d): trace_begin: %s: %m", v31, v32, v33, v34, v35, v36, v37, a2);
    return 34LL;
  }

uint64_t sub_100069268()
{
  int v0 = dword_1000C5FC8;
  if (dword_1000C5FC8 >= 1)
  {
    uint64_t v1 = 0LL;
    uint64_t v2 = qword_1000C5FC0;
    do
    {
      uint64_t result = *(void *)(v2 + 8 * v1);
      uint64_t v4 = *(uint64_t (**)(void))(result + 40);
      if (v4)
      {
        uint64_t result = v4();
        uint64_t v2 = qword_1000C5FC0;
        int v0 = dword_1000C5FC8;
      }

      ++v1;
    }

    while (v1 < v0);
  }

  byte_1000C5FA0 = 1;
  return result;
}

uint64_t sub_1000692D4(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  unsigned int v8 = a2 + 4;
  uint64_t v9 = sub_10005CDE4(a2 + 4);
  if (!v9) {
    return 1LL;
  }
  ssize_t v10 = v9;
  *(_DWORD *)(a1 + 8) = ++dword_1000C5FE8;
  sub_100068FE0(a1);
  *ssize_t v10 = bswap32(*(_DWORD *)(a1 + 8));
  memcpy(v10 + 1, *(const void **)(a1 + 16), a2);
  uint64_t v11 = *(void *)qword_1000C5FC0;
  uint64_t v22 = v10;
  unsigned int v23 = v8;
  uint64_t v15 = sub_1000693DC(v11, 1LL, (uint64_t)&v22, a3, a4, v12, v13, v14);
  sub_10005CE20(v10, a3, a4, v16, v17, v18, v19, v20);
  return v15;
}

uint64_t sub_1000693B0( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a3;
  int v10 = a2;
  return sub_1000693DC(a1, 1LL, (uint64_t)&v9, a4, a5, a6, a7, a8);
}

uint64_t sub_1000693DC( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((byte_1000C5FA0 & 1) != 0) {
    return 0LL;
  }
  char v9 = a4;
  if (!a1)
  {
    uint64_t v17 = "<unknown file>";
    if (a4) {
      LOBYTE(v17) = a4;
    }
    sub_10006221C("%s(%d): trace_write_packet with null trace type", a2, a3, a4, a5, a6, a7, a8, (char)v17);
    return 39LL;
  }

  if (!dword_1000C5F9C)
  {
    uint64_t v18 = "<unknown file>";
    if (a4) {
      LOBYTE(v18) = a4;
    }
    sub_10006221C("%s(%d): trace_write_packet with no tracefile.", a2, a3, a4, a5, a6, a7, a8, (char)v18);
    return 39LL;
  }

  int v11 = a2;
  uint64_t v12 = a2;
  if ((int)a2 < 1)
  {
    signed int v13 = 0;
  }

  else
  {
    signed int v13 = 0;
    uint64_t v14 = (int *)(a3 + 8);
    uint64_t v15 = a2;
    do
    {
      int v16 = *v14;
      v14 += 4;
      v13 += v16;
      --v15;
    }

    while (v15);
  }

  __buf[0] = bswap32(*(_DWORD *)(a1 + 8));
  __buf[1] = bswap32(v13);
  __buf[2] = bswap32(time(0LL));
  int v19 = write(dword_1000C5F9C, __buf, 0x10uLL);
  if ((v19 & 0x80000000) == 0)
  {
    if (v19 != 16)
    {
      sub_10006221C("%s(%d): trace_write_packet: short write (%d:%ld)", v20, v21, v22, v23, v24, v25, v26, v9);
      sub_100069268();
    }

    if (v11 >= 1)
    {
      uint64_t v27 = (const void **)(a3 + 8);
      while (1)
      {
        int v28 = write(dword_1000C5F9C, *(v27 - 1), *(unsigned int *)v27);
        if (v28 < 0) {
          break;
        }
        if (*(_DWORD *)v27 != v28)
        {
          sub_10006221C("%s(%d): %s: short write (%d:%d)", v29, v30, v31, v32, v33, v34, v35, v9);
          sub_100069268();
        }

        v27 += 2;
        if (!--v12) {
          goto LABEL_26;
        }
      }

      sub_10006221C("%s(%d): %s write failed: %m", v29, v30, v31, v32, v33, v34, v35, v9);
      return 34LL;
    }

void sub_1000695FC()
{
  byte_1000C5F98 = 1;
}

void sub_10006960C(const char *a1)
{
  char v1 = (char)a1;
  uint64_t v58 = 0LL;
  int v56 = 0;
  uint64_t v55 = 0LL;
  uint64_t v2 = fopen(a1, "r");
  qword_1000C5FD0 = (uint64_t)v2;
  if (!v2)
  {
    sub_10006221C("Can't open tracefile %s: %m", v3, v4, v5, v6, v7, v8, v9, v1);
    return;
  }

  int v10 = fileno(v2);
  char v54 = 1;
  if (fcntl(v10, 2) < 0) {
    sub_10006221C("Can't set close-on-exec on %s: %m", v11, v12, v13, v14, v15, v16, v17, v1);
  }
  int v18 = fread(&dword_1000C5FD8, 1uLL, 0x10uLL, (FILE *)qword_1000C5FD0);
  if ((v18 & 0xFFFFFFF0) == 0)
  {
    char v31 = v18;
    if (ferror((FILE *)qword_1000C5FD0))
    {
      uint64_t v39 = "Error reading trace file header: %m";
    }

    else
    {
      char v54 = v31;
      uint64_t v39 = "Short read on trace file header: %d %ld.";
    }

    goto LABEL_15;
  }

  int v26 = dword_1000C5FD8;
  unsigned int v27 = bswap32(*(unsigned int *)algn_1000C5FDC);
  dword_1000C5FD8 = bswap32(dword_1000C5FD8);
  *(_DWORD *)algn_1000C5FDC = v27;
  int v28 = dword_1000C5FE0;
  unsigned int v29 = bswap32(dword_1000C5FE0);
  size_t v30 = bswap32(dword_1000C5FE4);
  dword_1000C5FE0 = v29;
  dword_1000C5FE4 = v30;
  if (v26 != 1883457636)
  {
    sub_10006221C("%s: not a dhcp trace file.", v19, v20, v21, v22, v23, v24, v25, v1);
    goto LABEL_16;
  }

  if (v27 < 2)
  {
    if (v30 <= 0xF)
    {
      sub_10006221C("tracefile packet size too small - %ld < %ld", v19, v20, v21, v22, v23, v24, v25, v30);
      goto LABEL_16;
    }

    uint64_t v46 = 16 - v29;
    if ((int)(16 - v29) < 0)
    {
      sub_10006221C("tracefile header size too small - %ld < %ld", v46, v20, v21, v22, v23, v24, v25, v29);
      goto LABEL_16;
    }

    if (v28 == 0x10000000)
    {
LABEL_26:
      uint64_t v40 = (unsigned int *)sub_10005CDE4(v30);
      if (v40)
      {
        while (!sub_100069854((void **)&v55, v40, &v58, &v57, &v56))
        {
          ((void (**)(void, void, void *))v55)[4](v55, v40[1], v58);
          uint64_t v55 = 0LL;
        }
      }

      else
      {
        sub_10006221C("can't allocate trace packet header.", v47, v48, v49, v50, v51, v52, v53, v54);
      }

      goto LABEL_17;
    }

    if ((fseek((FILE *)qword_1000C5FD0, v46, 1) & 0x80000000) == 0)
    {
      size_t v30 = dword_1000C5FE4;
      goto LABEL_26;
    }

    uint64_t v39 = "can't seek past header: %m";
LABEL_15:
    sub_10006221C(v39, v32, v33, v34, v35, v36, v37, v38, v54);
    goto LABEL_16;
  }

  sub_10006221C("tracefile version %ld > current %ld.", v19, v20, v21, v22, v23, v24, v25, v27);
LABEL_16:
  uint64_t v40 = 0LL;
LABEL_17:
  fclose((FILE *)qword_1000C5FD0);
  if (v58) {
    sub_10005CE20( v58,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/trace.c",  501LL,  v41,  v42,  v43,  v44,  v45);
  }
  if (v40) {
    sub_10005CE20( v40,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/trace.c",  503LL,  v41,  v42,  v43,  v44,  v45);
  }
}

uint64_t sub_100069854(void **a1, unsigned int *a2, void **a3, _DWORD *a4, _DWORD *a5)
{
  if (fgetpos((FILE *)qword_1000C5FD0, &v50) < 0) {
    sub_10006221C("Can't save tracefile position: %m", v10, v11, v12, v13, v14, v15, v16, v49);
  }
  int v24 = fread(a2, 1uLL, dword_1000C5FE4, (FILE *)qword_1000C5FD0);
  if (dword_1000C5FE4 > v24)
  {
    if (ferror((FILE *)qword_1000C5FD0))
    {
      uint64_t v32 = "Error reading trace packet header: %m";
    }

    else
    {
      if (!v24) {
        return 14LL;
      }
      char v49 = v24;
      uint64_t v32 = "Short read on trace packet header: %ld %ld.";
    }

    goto LABEL_17;
  }

  unsigned int v33 = bswap32(*a2);
  *a2 = v33;
  int8x8_t v34 = vrev32_s8(*(int8x8_t *)(a2 + 1));
  *(int8x8_t *)(a2 + 1) = v34;
  if (v33 >= dword_1000C5FC8 || (uint64_t v35 = *(void **)(qword_1000C5FC0 + 8LL * v33)) == 0LL)
  {
    sub_10006221C("Trace packet with unknown index %ld", v17, v18, v19, v20, v21, v22, v23, v33);
    return 38LL;
  }

  if (a1)
  {
    uint64_t v36 = *a1;
    if (*a1 == &unk_10008CF60)
    {
      *a1 = v35;
      if ((fsetpos((FILE *)qword_1000C5FD0, &v50) & 0x80000000) == 0) {
        return 18LL;
      }
      goto LABEL_34;
    }

    if (v36 && v35 != v36)
    {
      sub_10006221C("Read packet type %s when expecting %s", v17, v18, v19, v20, v21, v22, v23, v35[2]);
      if ((fsetpos((FILE *)qword_1000C5FD0, &v50) & 0x80000000) == 0) {
        return 32LL;
      }
LABEL_34:
      uint64_t v32 = "fsetpos in tracefile failed: %m";
LABEL_17:
      sub_10006221C(v32, v25, v26, v27, v28, v29, v30, v31, v49);
      return 38LL;
    }
  }

  size_t v38 = (v34.i32[0] + 7) & 0xFFFFFFF8;
  uint64_t v39 = *a3;
  if (v38 > *a5)
  {
    if (v39) {
      sub_10005CE20( v39,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/trace.c",  584LL,  v19,  v20,  v21,  v22,  v23);
    }
    size_t v40 = ((_DWORD)v38 + 1023) & 0xFFFFFC00;
    *a5 = v40;
    uint64_t v39 = sub_10005CDE4(v40);
    *a3 = v39;
    if (!v39)
    {
      sub_10006221C("Can't allocate input buffer sized %d", v41, v42, v43, v44, v45, v46, v47, *a5);
      return 1LL;
    }
  }

  unsigned int v48 = fread(v39, 1uLL, v38, (FILE *)qword_1000C5FD0);
  if (v38 > v48)
  {
    if (!ferror((FILE *)qword_1000C5FD0))
    {
      sub_10006221C("Short read on trace payload: %d %d.", v25, v26, v27, v28, v29, v30, v31, v48);
      return 38LL;
    }

    uint64_t v32 = "Error reading trace payload: %m";
    goto LABEL_17;
  }

  *a4 = a2[1];
  if (off_10008CF58) {
    off_10008CF58(a2[2]);
  }
  uint64_t result = 0LL;
  if (a1) {
    *a1 = v35;
  }
  return result;
}

uint64_t sub_100069AC8(void **a1, _DWORD *a2, void **a3)
{
  int v23 = 0;
  if (!a3 || *a3) {
    return 39LL;
  }
  uint64_t v8 = (unsigned int *)sub_10005CDE4(dword_1000C5FE4);
  if (v8)
  {
    uint64_t v16 = v8;
    uint64_t v4 = sub_100069854(a1, v8, a3, a2, &v23);
    sub_10005CE20( v16,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/trace.c",  633LL,  v17,  v18,  v19,  v20,  v21);
  }

  else
  {
    sub_10006221C("can't allocate trace packet header.", v9, v10, v11, v12, v13, v14, v15, v22);
    return 1LL;
  }

  return v4;
}

uint64_t sub_100069B7C(void **a1)
{
  int v23 = 0;
  uint64_t v21 = 0LL;
  uint64_t v2 = (unsigned int *)sub_10005CDE4(dword_1000C5FE4);
  if (v2)
  {
    uint64_t v10 = v2;
    if (a1) {
      uint64_t v11 = a1;
    }
    else {
      uint64_t v11 = (void **)&v20;
    }
    *uint64_t v11 = &unk_10008CF60;
    sub_100069854(v11, v10, &v21, &v22, &v23);
    uint64_t v12 = v10[2];
    sub_10005CE20( v10,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/trace.c",  659LL,  v13,  v14,  v15,  v16,  v17);
  }

  else
  {
    sub_10006221C("can't allocate trace packet header.", v3, v4, v5, v6, v7, v8, v9, v19);
    return 1LL;
  }

  return v12;
}

uint64_t sub_100069C24(void *a1, const char *a2, _DWORD *a3, void **a4)
{
  uint64_t v65 = a1;
  int v63 = 0;
  uint64_t v4 = 39LL;
  if (a3 && a4 && !*a4)
  {
    if (fgetpos((FILE *)qword_1000C5FD0, &v64) < 0) {
      sub_10006221C("Can't save tracefile position: %m", v9, v10, v11, v12, v13, v14, v15, v61);
    }
    uint64_t v16 = (unsigned int *)sub_10005CDE4(dword_1000C5FE4);
    if (v16)
    {
      int v24 = v16;
      uint64_t v25 = sub_100069854(&v65, v16, a4, a3, &v63);
      if ((_DWORD)v25)
      {
        uint64_t v4 = v25;
        sub_10005CE20( v24,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/trace.c",  694LL,  v26,  v27,  v28,  v29,  v30);
        if (*a4) {
          sub_10005CE20( *a4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/trace.c",  696LL,  v31,  v32,  v33,  v34,  v35);
        }
      }

      else
      {
        uint64_t v36 = *a4;
        if (!strcmp(a2, (const char *)*a4))
        {
          sub_10005CE20( v24,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/trace.c",  713LL,  v39,  v40,  v41,  v42,  v43);
          return 0LL;
        }

        else
        {
          sub_10006221C("Read file %s when expecting %s", v37, v38, v39, v40, v41, v42, v43, (char)v36);
          if (fsetpos((FILE *)qword_1000C5FD0, &v64) < 0)
          {
            sub_10006221C("fsetpos in tracefile failed: %m", v44, v45, v46, v47, v48, v49, v50, v62);
            sub_10005CE20( v24,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/trace.c",  706LL,  v51,  v52,  v53,  v54,  v55);
            sub_10005CE20( *a4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/iscDHCP/omapip/trace.c",  707LL,  v56,  v57,  v58,  v59,  v60);
            return 38LL;
          }

          else
          {
            return 32LL;
          }
        }
      }
    }

    else
    {
      sub_10006221C("can't allocate trace packet header.", v17, v18, v19, v20, v21, v22, v23, v61);
      return 1LL;
    }
  }

  return v4;
}

uint64_t sub_100069DB8(_BYTE *a1, _BYTE *a2, uint64_t a3)
{
  if (a3 >= 1)
  {
    unint64_t v3 = (unint64_t)&a2[a3];
    unsigned int v4 = *a1;
    if (*a1)
    {
      uint64_t v5 = a2;
      while (v4 < 0x40)
      {
        uint64_t v6 = a2;
        if (v5 != a2)
        {
          *uint64_t v5 = 46;
          uint64_t v6 = v5 + 1;
        }

        ++a1;
        uint64_t v5 = v6;
        do
        {
          int v7 = *a1;
          if ((v7 - 34) > 0x3A || ((1LL << (v7 - 34)) & 0x400000042001005LL) == 0)
          {
            if ((v7 - 127) > 0xFFFFFFA1)
            {
              *v5++ = v7;
            }

            else
            {
              *uint64_t v5 = 92;
              unsigned int v9 = (41 * v7) >> 12;
              v5[1] = a0123456789[v9];
              v5[2] = a0123456789[(v7 - 100 * v9) / 0xAu];
              v5[3] = a0123456789[(v7 - 10 * ((205 * v7) >> 11))];
              v5 += 4;
            }
          }

          else
          {
            *uint64_t v5 = 92;
            v5[1] = v7;
            v5 += 2;
          }

          ++a1;
          --v4;
        }

        while (v4);
        unsigned int v4 = *a1;
        if (!*a1)
        {
          if (v5 != a2) {
            goto LABEL_26;
          }
          goto LABEL_25;
        }
      }
    }

    else
    {
LABEL_25:
      *a2 = 46;
      uint64_t v5 = a2 + 1;
LABEL_26:
      if ((unint64_t)v5 < v3)
      {
        *uint64_t v5 = 0;
        return ((_DWORD)v5 - (_DWORD)a2 + 1);
      }
    }
  }

uint64_t sub_100069F44(_BYTE *a1, _BYTE *a2, uint64_t a3)
{
  unint64_t v4 = (unint64_t)&a2[a3];
  uint64_t v5 = a2;
  while (2)
  {
    uint64_t v6 = a1;
    int v7 = v5;
    while (2)
    {
      uint64_t v8 = v7 + 1;
      unsigned int v9 = v6 + 2;
      char v10 = 1;
      do
      {
        int v12 = (char)*a1++;
        int v11 = v12;
        if (!v12)
        {
          int v19 = (_DWORD)v8 + ~(_DWORD)v5;
          *uint64_t v5 = v19;
          if (v19)
          {
            uint64_t v8 = v7 + 2;
            v7[1] = 0;
          }

          if (v8 - a2 >= 256) {
            goto LABEL_32;
          }
          return 0LL;
        }

        if ((v10 & 1) == 0)
        {
          uint64_t v13 = (char *)memchr("0123456789", v11, 0xBuLL);
          if (!v13) {
            goto LABEL_16;
          }
          if (v6[2])
          {
            uint64_t v14 = v13;
            uint64_t v15 = memchr("0123456789", (char)v6[2], 0xBuLL);
            if (v15)
            {
              if (v6[3])
              {
                uint64_t v16 = v15;
                uint64_t v17 = memchr("0123456789", (char)v6[3], 0xBuLL);
                if (v17)
                {
                  int v11 = ((unint64_t)(0x6400000000LL * (void)&v14[-(int)"0123456789"]
                                          + 0xA00000000LL * (v16 - "0123456789")) >> 32)
                      - "0123456789"
                      + (_DWORD)v17;
                  if (v11 <= 255)
                  {
                    unsigned int v9 = v6 + 4;
                    goto LABEL_16;
                  }
                }
              }
            }
          }

uint64_t sub_10006A120(_BYTE *a1, _BYTE *a2, uint64_t a3)
{
  if (a3 >= 1)
  {
    int v3 = (int)a2;
    unint64_t v4 = a1;
    unsigned int v5 = *a1;
    uint64_t v6 = a2;
    if (!*a1) {
      goto LABEL_15;
    }
    int v7 = &a2[a3];
    uint64_t v6 = a2;
    while (v5 < 0x40)
    {
      *v6++ = v5;
      if (&v6[v5] >= v7) {
        break;
      }
      ++v4;
      do
      {
        int v8 = (char)*v4;
        __darwin_ct_rune_t v9 = *v4;
        if ((v8 & 0x80000000) == 0)
        {
LABEL_9:
          LOBYTE(v8) = __tolower(v9);
          goto LABEL_10;
        }

uint64_t sub_10006A214(unint64_t a1, unint64_t a2, _BYTE *a3, char *a4, uint64_t a5)
{
  if ((unint64_t)a3 < a1 || (int v5 = (int)a3, (unint64_t)a3 >= a2))
  {
LABEL_20:
    *__error() = 40;
    return 0xFFFFFFFFLL;
  }

  else
  {
    int v7 = a4;
    unsigned int v8 = *a3;
    if (*a3)
    {
      int v10 = 0;
      unint64_t v11 = (unint64_t)&a4[a5];
      int v12 = a3 + 1;
      int64_t v13 = a2 - a1;
      uint64_t v14 = 0xFFFFFFFFLL;
      do
      {
        if ((v8 & 0xC0) == 0xC0)
        {
          int v19 = (unsigned __int8 *)(a1 + (*v12 | ((v8 & 0x3F) << 8)));
          uint64_t v14 = (int)v14 < 0 ? ((_DWORD)v12 - v5 + 1) : v14;
          v10 += 2;
          if (v13 <= v10) {
            goto LABEL_20;
          }
          int v18 = v19;
        }

        else
        {
          if ((v8 & 0xC0) != 0) {
            goto LABEL_20;
          }
          uint64_t v15 = v8;
          uint64_t v16 = &v12[v8];
          v10 += v8 + 1;
          *int v7 = v8;
          uint64_t v17 = v7 + 1;
          memcpy(v17, v12, v8);
          int v7 = &v17[v15];
          int v18 = v16;
        }

        unsigned int v20 = *v18;
        int v12 = v18 + 1;
        unsigned int v8 = v20;
      }

      while (v20);
      *int v7 = 0;
      if ((v14 & 0x80000000) != 0) {
        return ((_DWORD)v12 - v5);
      }
    }

    else
    {
      *a4 = 0;
      return 1LL;
    }
  }

  return v14;
}

uint64_t sub_10006A34C(unsigned __int8 *__src, char *__dst, int a3, void *a4, uint64_t a5)
{
  uint64_t v6 = a4;
  int v7 = __src;
  if (a4)
  {
    unsigned int v8 = a4 + 1;
    uint64_t v9 = *a4;
    if (*a4)
    {
      do
      {
        uint64_t v10 = v6[1];
        ++v6;
      }

      while (v10);
    }

    else
    {
      uint64_t v6 = 0LL;
    }
  }

  else
  {
    unsigned int v8 = 0LL;
    uint64_t v9 = 0LL;
  }

  unsigned int v11 = 0;
  int v12 = &__dst[a3];
  int64_t v13 = __src;
  while (1)
  {
    unsigned int v14 = *v13;
    if (v14 >= 0x40) {
      break;
    }
    v11 += v14 + 1;
    if (v11 >= 0x100) {
      break;
    }
    v13 += v14 + 1;
    if (!v14)
    {
      int v35 = (int)__dst;
      unint64_t v36 = a5 - 8;
      uint64_t v15 = __dst;
      uint64_t v16 = v6;
      while (1)
      {
        uint64_t v17 = *v7;
        if (v9 && *v7)
        {
          if (v8 < v6)
          {
            int v18 = v8;
            while (2)
            {
              int v19 = (_BYTE *)*v18;
              unsigned int v20 = v7;
              uint64_t v21 = (_BYTE *)*v18;
LABEL_17:
              while (1)
              {
                int v22 = *v21;
                if (!*v21) {
                  break;
                }
                uint64_t v23 = v21 + 1;
                if ((v22 & 0xC0) != 0xC0)
                {
                  if ((v22 & 0xC0) != 0)
                  {
                    int v31 = 40;
                    goto LABEL_34;
                  }

                  if (v22 == *v20)
                  {
                    uint64_t v24 = (v22 - 1);
                    v21 += v24 + 2;
                    uint64_t v25 = &v20[v24 + 2];
                    uint64_t v26 = v20 + 1;
                    while (1)
                    {
                      int v28 = *v26++;
                      int v27 = v28;
                      int v29 = v28 + 32;
                      int v30 = *v23;
                      if (v27 != v30) {
                        break;
                      }
                      ++v23;
                      if (!--v22)
                      {
                        unsigned int v20 = v25;
                        if (*v25) {
                          goto LABEL_17;
                        }
                        if (*v21) {
                          goto LABEL_31;
                        }
                        __int16 v33 = (_WORD)v19 - v9;
                        if ((_DWORD)v19 - (_DWORD)v9 < 0) {
                          goto LABEL_35;
                        }
                        if (v15 + 1 < v12)
                        {
                          *uint64_t v15 = HIBYTE(v33) | 0xC0;
                          v15[1] = v33;
                          return ((_DWORD)v15 - v35 + 2);
                        }

                        goto LABEL_48;
                      }
                    }
                  }

                  break;
                }

                uint64_t v21 = (_BYTE *)(v9 + (((v22 & 0x3F) << 8) | (unint64_t)*v23));
              }

uint64_t sub_10006A5A0(unint64_t a1, unint64_t a2, _BYTE *a3, _BYTE *a4, uint64_t a5)
{
  uint64_t result = sub_10006A214(a1, a2, a3, v9, 255LL);
  if ((_DWORD)result != -1)
  {
    unsigned int v8 = result;
    else {
      return v8;
    }
  }

  return result;
}

uint64_t sub_10006A62C(_BYTE *a1, char *a2, int a3, void *a4, uint64_t a5)
{
  uint64_t result = sub_100069F44(a1, __src, 255LL);
  if ((_DWORD)result != -1) {
    return sub_10006A34C(__src, a2, a3, a4, a5);
  }
  return result;
}

uint64_t sub_10006A6C4(_BYTE **a1, unint64_t a2)
{
  for (uint64_t i = *a1; ; i += v3 + 1)
  {
    uint64_t v3 = *i;
    if (!*i) {
      break;
    }
    if ((v3 & 0xC0) != 0)
    {
      if ((v3 & 0xC0) == 0xC0)
      {
        i += 2;
        goto LABEL_9;
      }

      goto LABEL_10;
    }
  }

  ++i;
LABEL_9:
  if ((unint64_t)i > a2)
  {
LABEL_10:
    *__error() = 40;
    return 0xFFFFFFFFLL;
  }

  uint64_t v4 = 0LL;
  *a1 = i;
  return v4;
}

uint64_t sub_10006A738(unint64_t a1, unint64_t a2, int a3, int a4, _DWORD *a5)
{
  int v7 = a1;
  unint64_t v8 = a1;
  if (a4 >= 1)
  {
    int v10 = a4 + 1;
    unint64_t v8 = a1;
    do
    {
      int v11 = sub_10006B97C((_BYTE *)v8, a2);
      if (v11 < 0) {
        return 49LL;
      }
      v8 += (v11 + 4);
      if (a3)
      {
        if (v8 + 6 > a2) {
          return 49LL;
        }
        v8 += 6LL + (int)sub_100060B5C((unsigned __int16 *)(v8 + 4));
      }
    }

    while (--v10 > 1);
  }

  if (v8 > a2) {
    return 49LL;
  }
  uint64_t result = 0LL;
  if (a5) {
    *a5 = v8 - v7;
  }
  return result;
}

double sub_10006A7EC(unsigned __int16 *a1, unsigned int a2, uint64_t a3)
{
  *(void *)&__int128 v3 = 0x5E5E5E5E5E5E5E5ELL;
  *((void *)&v3 + 1) = 0x5E5E5E5E5E5E5E5ELL;
  *(_OWORD *)(a3 + 48) = v3;
  *(_OWORD *)(a3 + 64) = v3;
  unint64_t v4 = (unint64_t)a1 + a2;
  *(_OWORD *)(a3 + 16) = v3;
  *(_OWORD *)(a3 + 32) = v3;
  *(_OWORD *)a3 = v3;
  *(void *)a3 = a1;
  *(void *)(a3 + 8) = v4;
  if (a2 >= 2)
  {
    *(_WORD *)(a3 + 16) = sub_100060B5C(a1);
    if (a2 >= 4)
    {
      uint64_t v8 = 0LL;
      *(_WORD *)(a3 + 18) = sub_100060B5C(a1 + 1);
      while ((unint64_t)&a1[v8 + 3] <= v4)
      {
        *(_WORD *)(a3 + 20 + v8 * 2) = sub_100060B5C(&a1[v8 + 2]);
        if (++v8 == 4)
        {
          uint64_t v9 = 0LL;
          uint64_t v10 = a3 + 20;
          unint64_t v11 = (unint64_t)(a1 + 6);
          do
          {
            if (*(_WORD *)(v10 + 2 * v9))
            {
              *(void *)(v10 + 8 * v9 + 12) = v11;
              v11 += v13;
            }

            else
            {
              *(void *)(v10 + 8 * v9 + 12) = 0LL;
            }

            ++v9;
          }

          while (v9 != 4);
          if (v11 == v4)
          {
            *(void *)&__int128 v3 = 0xFFFFFFFF00000004LL;
            *(void *)(a3 + 64) = 0xFFFFFFFF00000004LL;
            *(void *)(a3 + 72) = 0LL;
          }

          return *(double *)&v3;
        }
      }
    }
  }

  return *(double *)&v3;
}

uint64_t sub_10006A910(uint64_t a1, unsigned int a2, int a3, uint64_t a4)
{
  if (a2 > 3) {
    return 27LL;
  }
  uint64_t v30 = v4;
  uint64_t v31 = v5;
  signed int v8 = a3;
  if (*(_DWORD *)(a1 + 64) != a2)
  {
    uint64_t v11 = *(void *)(a1 + 8LL * a2 + 32);
    *(_DWORD *)(a1 + 64) = a2;
    *(_DWORD *)(a1 + 68) = 0;
    *(void *)(a1 + 72) = v11;
  }

  if (a3 == -1)
  {
    signed int v8 = *(_DWORD *)(a1 + 68);
    if (v8 < 0) {
      return 69LL;
    }
  }

  else if (a3 < 0)
  {
    return 69LL;
  }

  uint64_t v12 = a1 + 2LL * a2;
  unsigned int v14 = *(unsigned __int16 *)(v12 + 20);
  int v13 = (unsigned __int16 *)(v12 + 20);
  if (v8 >= v14) {
    return 69LL;
  }
  int v15 = *(_DWORD *)(a1 + 68);
  if (v8 < v15)
  {
    int v15 = 0;
    uint64_t v16 = *(void *)(a1 + 8LL * a2 + 32);
    *(_DWORD *)(a1 + 64) = a2;
    *(_DWORD *)(a1 + 68) = 0;
    *(void *)(a1 + 72) = v16;
  }

  uint64_t v17 = *(_BYTE **)(a1 + 72);
  if (v8 > v15)
  {
    uint64_t result = sub_10006A738(*(void *)(a1 + 72), *(void *)(a1 + 8), a2, v8 - v15, &v29);
    if ((_DWORD)result) {
      return result;
    }
    uint64_t v17 = (_BYTE *)(*(void *)(a1 + 72) + (int)v29);
    *(void *)(a1 + 72) = v17;
    *(_DWORD *)(a1 + 68) = v8;
  }

  unsigned int v18 = sub_10006B938(*(void *)a1, *(void *)(a1 + 8), v17, (_BYTE *)a4, 0x401u);
  unsigned int v29 = v18;
  if ((v18 & 0x80000000) != 0) {
    return 50LL;
  }
  int v19 = (unsigned __int16 *)(*(void *)(a1 + 72) + v18);
  *(void *)(a1 + 72) = v19;
  *(_WORD *)(a4 + 1026) = sub_100060B5C(v19);
  unsigned int v20 = (unsigned __int16 *)(*(void *)(a1 + 72) + 2LL);
  *(void *)(a1 + 72) = v20;
  *(_WORD *)(a4 + 1028) = sub_100060B5C(v20);
  uint64_t v21 = *(void *)(a1 + 72);
  *(void *)(a1 + 72) = v21 + 2;
  if (a2)
  {
    *(_DWORD *)(a4 + 1032) = sub_100060B50((unsigned int *)(v21 + 2));
    int v22 = (unsigned __int16 *)(*(void *)(a1 + 72) + 4LL);
    *(void *)(a1 + 72) = v22;
    unsigned __int16 v23 = sub_100060B5C(v22);
    *(_WORD *)(a4 + 1036) = v23;
    uint64_t v24 = *(void *)(a1 + 72) + 2LL;
    *(void *)(a1 + 72) = v24;
    unint64_t v25 = v24 + v23;
    if (v25 > *(void *)(a1 + 8)) {
      return 49LL;
    }
    *(void *)(a4 + 104__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = v24;
    *(void *)(a1 + 72) = v25;
  }

  else
  {
    *(_DWORD *)(a4 + 1032) = 0;
    *(_WORD *)(a4 + 1036) = 0;
    *(void *)(a4 + 104__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = 0LL;
  }

  int v26 = *(_DWORD *)(a1 + 68);
  *(_DWORD *)(a1 + 68) = v26 + 1;
  if (v26 < *v13) {
    return 0LL;
  }
  *(_DWORD *)(a1 + 64) = a2 + 1;
  if (a2 == 3)
  {
    uint64_t v27 = 0LL;
    int v28 = -1;
  }

  else
  {
    int v28 = 0;
    uint64_t v27 = *(void *)(a1 + 8LL * (a2 + 1) + 32);
  }

  uint64_t result = 0LL;
  *(_DWORD *)(a1 + 68) = v28;
  *(void *)(a1 + 72) = v27;
  return result;
}

BOOL sub_10006AB30(const char *a1, const char *a2)
{
  size_t v4 = strlen(a1);
  size_t v5 = strlen(a2);
  size_t v6 = v5;
  if (v4 && a1[v4 - 1] == 46)
  {
    int v7 = 0;
    int v8 = v4 - 1;
    do
    {
      if (a1[--v8] != 92) {
        break;
      }
      v7 ^= 1u;
    }

    while (v8 > 0);
    if (!v7) {
LABEL_8:
    }
      --v4;
  }

  if (!v5) {
    return 1LL;
  }
  if (a2[v5 - 1] != 46) {
    goto LABEL_18;
  }
  int v9 = 0;
  int v10 = v5 - 1;
  do
  {
    if (a2[--v10] != 92) {
      break;
    }
    v9 ^= 1u;
  }

  while (v10 > 0);
  if (!v9) {
LABEL_16:
  }
    size_t v6 = v5 - 1;
  if (!v6) {
    return 1LL;
  }
LABEL_18:
  int v11 = v4 - v6;
  if (v4 < v6) {
    return 0LL;
  }
  if (v4 == v6)
  {
    int v13 = a1;
    unsigned int v14 = a2;
    size_t v6 = v4;
  }

  else
  {
    if (v11 < 2 || a1[v11 - 1] != 46) {
      return 0LL;
    }
    int v15 = 0;
    int v16 = ~(_DWORD)v6 + v4;
    do
    {
      if (a1[--v16] != 92) {
        break;
      }
      v15 ^= 1u;
    }

    while (v16 > 0);
    if (v15) {
      return 0LL;
    }
    int v13 = &a1[v11];
    unsigned int v14 = a2;
  }

  return strncasecmp(v13, v14, v6) == 0;
}

BOOL sub_10006AC84(const char *a1, const char *a2)
{
  return sub_10006ACC8(a1, a2) != 1 && sub_10006AB30(a1, a2);
}

uint64_t sub_10006ACC8(const char *a1, const char *a2)
{
  uint64_t result = sub_10006AD58(a1, v5, 0x401uLL);
  if (!(_DWORD)result)
  {
    else {
      return strcasecmp(v5, v4) == 0;
    }
  }

  return result;
}

uint64_t sub_10006AD58(const char *a1, char *a2, unint64_t a3)
{
  size_t v6 = strlen(a1);
  if (v6 + 2 > a3) {
    return 19LL;
  }
  size_t v8 = v6;
  strcpy(a2, a1);
  if (v8)
  {
    size_t v9 = v8 - 1;
    while (a2[v9] == 46)
    {
      if (v9 + 1 >= 2 && a2[v9 - 1] == 92 && a2[v9 - 2] != 92) {
        goto LABEL_12;
      }
      a2[v9--] = 0;
      --v8;
      if (v9 == -1LL)
      {
        size_t v8 = 0LL;
        goto LABEL_12;
      }
    }

    size_t v8 = v9 + 1;
  }

uint64_t sub_10006AE14( unsigned __int16 *a1, unsigned int *a2, unsigned int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, const void *a8, unsigned int *a9, unint64_t a10)
{
  uint64_t v18 = *a2;
  sub_100059834();
  uint64_t result = 39LL;
  if (a1 && a8 && a9)
  {
    unsigned int v20 = (char *)a1 + v18;
    unint64_t v21 = (unint64_t)a1 + a3;
    if (a5) {
      BOOL v22 = (a4 - 18) >= 0xFFFFFFFE;
    }
    else {
      BOOL v22 = 1;
    }
    int v23 = !v22;
    int v56 = a4;
    if (v23 == 1)
    {
      uint64_t v24 = *(char **)a5;
      int v25 = v21 - (_DWORD)v20;
    }

    else
    {
      int v25 = v21 - (_DWORD)v20;
      uint64_t v24 = &byte_1000728D2;
    }

    int v26 = sub_10006B974(v24, v20, v25, 0LL, 0LL);
    uint64_t v27 = &v20[v26];
    int v28 = v27 + 10;
    *(void *)uint64_t v27 = 4278254080LL;
    if (v23)
    {
      if (*(_DWORD *)(a5 + 16) != 157) {
        return 61LL;
      }
      uint64_t v54 = &v20[v26];
      unsigned int v29 = "HMAC-MD5.SIG-ALG.REG.INT";
    }

    else
    {
      uint64_t v54 = &v20[v26];
      unsigned int v29 = &byte_1000728D2;
    }

    uint64_t v30 = &v28[sub_10006B974(v29, v27 + 10, (int)v21 - (int)v28, 0LL, 0LL)];
    uint64_t v52 = a2;
    uint64_t v53 = v30 + 4;
    *uint64_t v30 = 0;
    uint64_t v55 = v30;
    time_t v31 = time(0LL);
    uint64_t v32 = v55;
    int v51 = v31;
    if (v56 != 18) {
      a10 = v31;
    }
    *((_BYTE *)v55 + 2) = BYTE3(a10);
    unint64_t v34 = a10 >> 8;
    *((_BYTE *)v55 + 3) = BYTE2(a10);
    *((_BYTE *)v55 + 4) = BYTE1(a10);
    *((_BYTE *)v55 + 5) = a10;
    v55[3] = 11265;
    if (v23)
    {
      unint64_t v48 = a10 >> 16;
      unint64_t v49 = a10 >> 24;
      char v50 = a10;
      sub_1000599B4(1, a5, (uint64_t)v57, 0LL, 0LL, 0LL);
      if (a6 && (_DWORD)a7)
      {
        __int16 v58 = bswap32(a7) >> 16;
        sub_1000599B4(2, a5, (uint64_t)v57, (uint64_t)&v58, 2LL, 0LL);
        sub_1000599B4(2, a5, (uint64_t)v57, a6, a7, 0LL);
      }

      int v35 = v52;
      sub_1000599B4(2, a5, (uint64_t)v57, (uint64_t)a1, *v52, 0LL);
      uint64_t v36 = sub_10006A120(v20, &v58, 1025LL);
      sub_1000599B4(2, a5, (uint64_t)v57, (uint64_t)&v58, v36, 0LL);
      __int16 v58 = -256;
      int v59 = 0;
      sub_1000599B4(2, a5, (uint64_t)v57, (uint64_t)&v58, 6LL, 0LL);
      uint64_t v37 = sub_10006A120(v28, &v58, 1025LL);
      sub_1000599B4(2, a5, (uint64_t)v57, (uint64_t)&v58, v37, 0LL);
      __int16 v58 = 0;
      LOBYTE(v59) = v49;
      BYTE1(v59) = v48;
      BYTE2(v59) = v34;
      HIBYTE(v59) = v50;
      __int16 v60 = 11265;
      int v38 = v56;
      char v61 = BYTE1(v56);
      char v62 = v56;
      if (v56 == 18)
      {
        __int16 v65 = 0;
        char v66 = HIBYTE(v51);
        char v67 = BYTE2(v51);
        char v68 = BYTE1(v51);
        uint64_t v39 = (__int16 *)&v70;
        char v40 = 6;
        char v69 = v51;
      }

      else
      {
        char v40 = 0;
        uint64_t v39 = &v65;
      }

      char v63 = 0;
      char v64 = v40;
      sub_1000599B4(2, a5, (uint64_t)v57, (uint64_t)&v58, v39 - &v58, 0LL);
      unsigned int v41 = sub_1000599B4(4, a5, (uint64_t)v57, 0LL, 0LL, (uint64_t)a8);
      uint64_t v42 = a9;
      *a9 = v41;
      uint64_t v32 = v55;
    }

    else
    {
      unsigned int v41 = 0;
      uint64_t v42 = a9;
      *a9 = 0;
      int v35 = v52;
      int v38 = v56;
    }

    v32[4] = bswap32(v41) >> 16;
    uint64_t v43 = v32 + 5;
    uint64_t v44 = v42;
    memcpy(v32 + 5, a8, *v42);
    uint64_t v45 = (uint64_t)v43 + *v44;
    if (v45 + 4 > v21) {
      return 19LL;
    }
    unsigned int v46 = bswap32(*a1);
    *(_BYTE *)uint64_t v45 = HIBYTE(v46);
    *(_BYTE *)(v45 + 1) = BYTE2(v46);
    *(_BYTE *)(v45 + 2) = BYTE1(v38);
    *(_BYTE *)(v45 + 3) = v38;
    int v47 = v45 + 6;
    if (v45 + 6 > v21) {
      return 19LL;
    }
    *(_BYTE *)(v45 + 4) = 0;
    if (v38 == 18)
    {
      *(_BYTE *)(v45 + 5) = 6;
      int v47 = v45 + 12;
      if (v45 + 12 > v21) {
        return 19LL;
      }
      *(_WORD *)(v45 + 6) = 0;
      *(_BYTE *)(v45 + 8) = HIBYTE(v51);
      *(_BYTE *)(v45 + 9) = BYTE2(v51);
      *(_BYTE *)(v45 + 1__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = BYTE1(v51);
      *(_BYTE *)(v45 + 11) = v51;
    }

    else
    {
      *(_BYTE *)(v45 + 5) = 0;
    }

    uint64_t result = 0LL;
    *((_WORD *)v54 + 4) = bswap32(v47 - ((_DWORD)v54 + 8) - 2) >> 16;
    a1[5] = bswap32(bswap32(*((_DWORD *)a1 + 2)) + 1) >> 16;
    _DWORD *v35 = v47 - (_DWORD)a1;
  }

  return result;
}

_BYTE *sub_10006B308(unint64_t a1, unint64_t a2)
{
  uint64_t result = 0LL;
  if (a1 <= a2 && a1 && a2)
  {
    if (a1 + 12 >= a2) {
      return 0LL;
    }
    unint64_t v5 = a1 + 12 + v11;
    unint64_t v6 = v5 + v11;
    unint64_t v7 = v6 + v11;
    size_t v8 = (_BYTE *)(v7 + v11);
    int v9 = sub_10006B97C(v8, a2);
    if (v9 < 0) {
      return 0LL;
    }
    int v10 = (unsigned __int16 *)&v8[v9];
    if ((unint64_t)(v10 + 1) >= a2)
    {
      return 0LL;
    }

    else if (__rev16(*v10) == 250)
    {
      return v8;
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_10006B454( unint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, _DWORD *a7, void *a8, int a9)
{
  uint64_t result = 39LL;
  if (!a1 || !a2) {
    return result;
  }
  unint64_t v18 = a1 + *a2;
  int v19 = sub_10006B308(a1, v18);
  if (!v19) {
    return 66LL;
  }
  unsigned int v20 = v19;
  __int16 v58 = a8;
  unint64_t v21 = (unsigned __int16 *)&v19[sub_10006B938(a1, v18, v19, v63, 0x401u)];
  BOOL v22 = v21 + 5;
  if (__rev16(*v21) != 250) {
    return 66LL;
  }
  if (v18 - (void)v22 != __rev16(v21[4])) {
    return 50LL;
  }
  int v56 = sub_10006B938(a1, v18, v22, v62, 0x401u);
  int v23 = &v22[v56];
  void *v58 = bswap32(*(_DWORD *)(v23 + 2));
  uint64_t v24 = v23 + 10;
  size_t v25 = __rev16(*((unsigned __int16 *)v23 + 4));
  int v26 = &v24[v25];
  uint64_t v29 = (uint64_t)(v26 + 2);
  unsigned int v28 = *((unsigned __int16 *)v26 + 1);
  uint64_t v30 = v26 + 6;
  uint64_t v31 = __rev16(*((unsigned __int16 *)v26 + 2));
  unint64_t v55 = v18;
  uint64_t v57 = v22;
  unsigned int v32 = *((unsigned __int16 *)v23 + 3);
  unsigned int v33 = __rev16(v28);
  if (a3)
  {
    if (*(_DWORD *)(a3 + 16) != 157) {
      return 48LL;
    }
    if (v33 - 18 <= 0xFFFFFFFD)
    {
      unsigned int v49 = v33;
      unsigned int v53 = *((unsigned __int16 *)v23 + 3);
      size_t v47 = v25;
      unint64_t v34 = v23 + 10;
      uint64_t v51 = v29;
      int v35 = v31;
      int v36 = sub_10006ACC8(*(const char **)a3, v63);
      LODWORD(sub_1000622D4("All rights reserved.", v16, v17, v18, v19, v20, v21, v22, v31) = v35;
      uint64_t v29 = v51;
      uint64_t v24 = v34;
      size_t v25 = v47;
      unsigned int v32 = v53;
      unsigned int v33 = v49;
      if (v36 != 1) {
        return 48LL;
      }
    }
  }

  uint64_t v52 = v29;
  unsigned int v46 = v24;
  *(_WORD *)(a1 + 1__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = bswap32(bswap32(*(_DWORD *)(a1 + 8)) - 1) >> 16;
  unsigned int v50 = v33;
  unsigned int v54 = v32;
  if (a3)
  {
    if (v33 != 16 && v33 != 17)
    {
      int v38 = v31;
      size_t v48 = v25;
      sub_1000599E8(1, a3, (uint64_t)v60, 0LL, 0LL, 0LL);
      if (a4 && (_DWORD)a5)
      {
        __int16 v59 = bswap32(a5) >> 16;
        sub_1000599E8(2, a3, (uint64_t)v60, (uint64_t)&v59, 2LL, 0LL);
        sub_1000599E8(2, a3, (uint64_t)v60, a4, a5, 0LL);
      }

      sub_1000599E8(2, a3, (uint64_t)v60, a1, ((_DWORD)v20 - a1), 0LL);
      uint64_t v39 = sub_10006A120(v20, v61, 1025LL);
      sub_1000599E8(2, a3, (uint64_t)v60, (uint64_t)v61, v39, 0LL);
      int v40 = sub_10006B97C(v20, v55);
      sub_1000599E8(2, a3, (uint64_t)v60, (uint64_t)&v20[v40 + 2], 6LL, 0LL);
      uint64_t v41 = sub_10006A120(v57, v61, 1025LL);
      sub_1000599E8(2, a3, (uint64_t)v60, (uint64_t)v61, v41, 0LL);
      int v42 = sub_10006B97C(v57, v55);
      sub_1000599E8(2, a3, (uint64_t)v60, (uint64_t)&v57[v42], 8LL, 0LL);
      sub_1000599E8(2, a3, (uint64_t)v60, v52, (v38 + 4), 0LL);
      sub_1000599E8(4, a3, (uint64_t)v60, 0LL, 0LL, (uint64_t)v46);
      if (a6 && a7)
      {
        memcpy(a6, v46, v48);
        *a7 = v48;
      }

      goto LABEL_43;
    }
  }

  if ((_DWORD)v25) {
    return 50LL;
  }
  if (a6 && a7) {
    *a7 = 0;
  }
LABEL_43:
  unsigned int v43 = __rev16(v54);
  *(_WORD *)(a1 + 1__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = bswap32(bswap32(*(_DWORD *)(a1 + 8)) + 1) >> 16;
  int v44 = *(_DWORD *)v58;
  int v45 = v44 - sub_100065E08(0LL);
  if (v45 < 0) {
    int v45 = -v45;
  }
  if (v45 > v43) {
    return 62LL;
  }
  if (!a9)
  {
    *a2 = (_DWORD)v20 - a1;
    *(_WORD *)(a1 + 1__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = bswap32(bswap32(*(_DWORD *)(a1 + 8)) - 1) >> 16;
  }

  if (v50) {
    return sub_100068C6C(v50);
  }
  else {
    return 0LL;
  }
}

uint64_t sub_10006B938(unint64_t a1, unint64_t a2, _BYTE *a3, _BYTE *a4, unsigned int a5)
{
  uint64_t result = sub_10006A5A0(a1, a2, a3, a4, a5);
  return result;
}

uint64_t sub_10006B974(_BYTE *a1, char *a2, int a3, void *a4, uint64_t a5)
{
  return sub_10006A62C(a1, a2, a3, a4, a5);
}

uint64_t sub_10006B97C(_BYTE *a1, unint64_t a2)
{
  int v2 = (int)a1;
  size_t v4 = a1;
  else {
    return ((_DWORD)v4 - v2);
  }
}

uint64_t sub_10006B9BC( uint64_t a1, char *__s, uint64_t a3, char a4, char *a5, size_t a6, const void *a7, int a8, int *a9, void *a10)
{
  unsigned int v15 = a3;
  int v39 = 0;
  uint64_t v18 = *(void *)(a1 + 384);
  *(void *)(a1 + 384) = v18 | 0xBF0;
  v40[0] = 0LL;
  v40[1] = 0LL;
  if (!sub_10003C61C(__s, a3, a5, a6, (uint64_t)a7, a8, &v39, a10))
  {
    uint64_t v19 = 0LL;
    goto LABEL_62;
  }

  uint64_t v19 = sub_10006AD58(__s, (char *)v51, 0x401uLL);
  if ((_DWORD)v19) {
    goto LABEL_61;
  }
  char v38 = a4;
  uint64_t i = v51;
  do
  {
LABEL_4:
    unint64_t v21 = i;
    int v22 = *(unsigned __int8 *)i;
    uint64_t i = (unint64_t *)((char *)i + 1);
  }

  while (v22 == 46);
  uint64_t v23 = sub_10006BF08(a1, v21, v15, 6u, (unsigned __int16 *)v50, (uint64_t)v41, (unsigned int *)&v44);
  if ((_DWORD)v23) {
    goto LABEL_45;
  }
  if (v44 >= 1)
  {
LABEL_7:
    signed int v44 = 0;
LABEL_8:
    int v24 = *(unsigned __int8 *)v21;
    if (*(_BYTE *)v21)
    {
      for (uint64_t i = v21; ; uint64_t i = (unint64_t *)((char *)i + 1))
      {
        if (v24 == 92)
        {
          int v25 = *((unsigned __int8 *)i + 1);
          uint64_t i = (unint64_t *)((char *)i + 1);
          if (!v25) {
            goto LABEL_35;
          }
        }

        else if (v24 == 46)
        {
          goto LABEL_4;
        }

        int v26 = *((unsigned __int8 *)i + 1);
        int v24 = v26;
      }
    }

    uint64_t v19 = 64LL;
    goto LABEL_61;
  }

  int v27 = v42;
  if (v42)
  {
    unsigned int v28 = 1;
  }

  else
  {
    int v27 = v43;
    if (!v43) {
      goto LABEL_7;
    }
    unsigned int v28 = 2;
  }

  int v29 = 0;
  signed int v44 = v27;
  while (1)
  {
    sub_10006A910((uint64_t)v41, v28, v29, (uint64_t)v46);
    if (v47 == 6) {
      break;
    }
    if (v47 == 5 || v47 == 39) {
      goto LABEL_8;
    }
LABEL_25:
    if (++v29 >= v44) {
      goto LABEL_8;
    }
  }

  if (v48 != v15) {
    goto LABEL_25;
  }
  if (LOBYTE(v46[0])) {
    uint64_t v30 = (const char *)v46;
  }
  else {
    uint64_t v30 = ".";
  }
  if (v28 == 2 && sub_10006ACC8((const char *)v21, v30) == 1 || !sub_10006AB30((const char *)v21, v30))
  {
    uint64_t v19 = 59LL;
    goto LABEL_61;
  }

  if (strlen(v30) + 1 > a6)
  {
LABEL_35:
    uint64_t v19 = 19LL;
    goto LABEL_61;
  }

  strcpy(a5, v30);
  if ((sub_10006A5A0((unint64_t)v50, v41[1], v49, v45, 1025LL) & 0x80000000) != 0)
  {
    uint64_t v19 = 1LL;
    goto LABEL_61;
  }

  uint64_t v19 = sub_10006C06C(v41, 2u, a5, v15, (uint64_t)v40);
  if (!(_DWORD)v19)
  {
    if ((v38 & 1) == 0)
    {
      int v39 = sub_10006BDF4(v45, (uint64_t *)v40, (uint64_t)a7, a8);
      if (v39 > 0)
      {
LABEL_42:
        uint64_t v19 = 0LL;
        goto LABEL_61;
      }
    }

    uint64_t v23 = sub_10006BF08(a1, a5, v15, 2u, v46, (uint64_t)v51, v50);
    if ((_DWORD)v23)
    {
LABEL_45:
      uint64_t v19 = v23;
      goto LABEL_61;
    }

    uint64_t v19 = sub_10006C06C(v51, 1u, a5, v15, (uint64_t)v40);
    if ((_DWORD)v19) {
      goto LABEL_61;
    }
    if ((v38 & 1) == 0)
    {
      int v39 = sub_10006BDF4(v45, (uint64_t *)v40, (uint64_t)a7, a8);
      if (v39 > 0) {
        goto LABEL_42;
      }
    }

    uint64_t v31 = v40[0];
    while (v31)
    {
      unsigned int v32 = v31;
      unint64_t v34 = v31 + 24;
      uint64_t v33 = *((void *)v31 + 3);
      uint64_t v31 = (char *)*((void *)v31 + 1);
      if (!v33)
      {
        uint64_t v35 = sub_10006BF08(a1, *((_BYTE **)v32 + 2), v15, 1u, v46, (uint64_t)v51, v50);
        if ((_DWORD)v35 || (uint64_t v35 = sub_10006C228((uint64_t)v51, 1u, *((const char **)v32 + 2), v15, v34), (_DWORD)v35))
        {
          uint64_t v19 = v35;
          int v36 = v39;
          goto LABEL_58;
        }

        if (!*v34) {
          sub_10006C368(v40, v32);
        }
      }
    }

    int v36 = sub_10006BDF4(v45, (uint64_t *)v40, (uint64_t)a7, a8);
    uint64_t v19 = 0LL;
    int v39 = v36;
LABEL_58:
    if (v36 >= 1) {
      sub_10003C904(v15, a5, a7, v36);
    }
  }

uint64_t sub_10006BDF4(const char *a1, uint64_t *a2, uint64_t a3, int a4)
{
  uint64_t v8 = *a2;
  if (*a2)
  {
    while (sub_10006ACC8(*(const char **)(v8 + 16), a1) != 1)
    {
      uint64_t v8 = *(void *)(v8 + 8);
      if (!v8) {
        goto LABEL_12;
      }
    }

    uint64_t v9 = *(void *)(v8 + 24);
    if (v9)
    {
      uint64_t v8 = 0LL;
      while ((a4 & ~(a4 >> 31)) != (_DWORD)v8)
      {
        *(_DWORD *)(a3 + 4 * v8) = *(_DWORD *)(v9 + 16);
        uint64_t v9 = *(void *)(v9 + 8);
        ++v8;
        if (!v9) {
          goto LABEL_11;
        }
      }
    }

    uint64_t v8 = 0LL;
LABEL_11:
    a3 += 4LL * (int)v8;
    a4 -= v8;
  }

uint64_t sub_10006BF08( uint64_t a1, _BYTE *a2, unsigned int a3, unsigned int a4, unsigned __int16 *a5, uint64_t a6, unsigned int *a7)
{
  uint64_t result = sub_10006CEDC(a1, 0, a2, a3, a4, 0LL, 0, 0LL, (uint64_t)v21, 0x200u, &v17);
  if (!(_DWORD)result)
  {
    uint64_t result = sub_10006EB04(a1, v21, v17, a5, 512LL, &v17);
    if (!(_DWORD)result)
    {
      if (v17)
      {
        sub_10006A7EC(a5, v17, a6);
        unsigned int v17 = 0;
        unsigned int v13 = *(unsigned __int16 *)(a6 + 22);
        if (*(_WORD *)(a6 + 22))
        {
          int v14 = 0;
          while (1)
          {
            uint64_t result = sub_10006A910(a6, 1u, v14, (uint64_t)v18);
            if ((_DWORD)result) {
              break;
            }
            BOOL v16 = v20 == a3 && (v19 == 5 || v19 == 39);
            unsigned int v13 = v17 + v16;
            unsigned int v17 = v13;
          }
        }

        else
        {
LABEL_17:
          uint64_t result = 0LL;
          if (a7) {
            *a7 = v13;
          }
        }
      }

      else
      {
        return 23LL;
      }
    }
  }

  return result;
}

uint64_t sub_10006C06C(unint64_t *a1, unsigned int a2, const char *a3, int a4, uint64_t a5)
{
  unint64_t v5 = (char *)a1 + 2 * a2;
  int v7 = *((unsigned __int16 *)v5 + 10);
  unint64_t v6 = (unsigned __int16 *)(v5 + 20);
  if (!v7) {
    return 0LL;
  }
  int v13 = 0;
  while (1)
  {
    uint64_t result = sub_10006A910((uint64_t)a1, a2, v13, (uint64_t)v23);
    if ((_DWORD)result) {
      return result;
    }
    if (v24 == 2 && v25 == a4)
    {
      BOOL v16 = v23[0] ? v23 : ".";
      if (sub_10006ACC8(v16, a3) == 1)
      {
        if (v23[0]) {
          unsigned int v17 = v23;
        }
        else {
          unsigned int v17 = ".";
        }
        uint64_t v18 = *(void **)a5;
        if (*(void *)a5)
        {
          while (sub_10006ACC8((const char *)v18[2], v17) != 1)
          {
            uint64_t v18 = (void *)v18[1];
            if (!v18) {
              goto LABEL_19;
            }
          }

          unint64_t v21 = (const char *)v18[2];
        }

        else
        {
LABEL_19:
          __int16 v19 = malloc(0x28uLL);
          if (!v19) {
            return 1LL;
          }
          uint64_t v18 = v19;
          if ((sub_10006A5A0(*a1, a1[1], v26, __s1, 1025LL) & 0x80000000) != 0
            || (unsigned __int16 v20 = strdup(__s1), (v18[2] = v20) == 0LL))
          {
            free(v18);
            return 1LL;
          }

          unint64_t v21 = v20;
          v18[3] = 0LL;
          v18[4] = 0LL;
          uint64_t v22 = *(void *)(a5 + 8);
          if (v22)
          {
            *(void *)(v22 + 8) = v18;
            uint64_t v22 = *(void *)(a5 + 8);
          }

          else
          {
            *(void *)a5 = v18;
          }

          *uint64_t v18 = v22;
          v18[1] = 0LL;
          *(void *)(a5 + 8) = v18;
        }

        uint64_t result = sub_10006C228((uint64_t)a1, 3u, v21, a4, v18 + 3);
        if ((_DWORD)result) {
          return result;
        }
      }
    }
  }

uint64_t sub_10006C228(uint64_t a1, unsigned int a2, const char *a3, int a4, void *a5)
{
  uint64_t v5 = a1 + 2LL * a2;
  int v7 = *(unsigned __int16 *)(v5 + 20);
  unint64_t v6 = (unsigned __int16 *)(v5 + 20);
  if (!v7) {
    return 0LL;
  }
  int v13 = 0;
  while (1)
  {
    uint64_t result = sub_10006A910(a1, a2, v13, (uint64_t)v20);
    if ((_DWORD)result) {
      break;
    }
    if (v21 == 1 && v22 == a4)
    {
      BOOL v16 = v20[0] ? v20 : ".";
      if (sub_10006ACC8(v16, a3) == 1 && v23 == 4)
      {
        uint64_t v18 = malloc(0x18uLL);
        if (!v18) {
          return 1LL;
        }
        v18[4] = *v24;
        uint64_t v19 = a5[1];
        if (v19)
        {
          *(void *)(v19 + 8) = v18;
          uint64_t v19 = a5[1];
        }

        else
        {
          *a5 = v18;
        }

        *(void *)uint64_t v18 = v19;
        *((void *)v18 + 1) = 0LL;
        a5[1] = v18;
      }
    }
  }

  return result;
}

void sub_10006C368(void *a1, char *a2)
{
  uint64_t v5 = (void **)(a2 + 24);
  size_t v4 = (uint64_t *)*((void *)a2 + 3);
  if (v4)
  {
    do
    {
      uint64_t v7 = *v4;
      unint64_t v6 = (void *)v4[1];
      if (v6)
      {
        *unint64_t v6 = v7;
        uint64_t v7 = *v4;
      }

      else
      {
        *((void *)a2 + 4) = v7;
      }

      if (v7) {
        uint64_t v8 = (void *)(v7 + 8);
      }
      else {
        uint64_t v8 = v5;
      }
      *uint64_t v8 = v6;
      free(v4);
      size_t v4 = *v5;
    }

    while (*v5);
  }

  free(*((void **)a2 + 2));
  uint64_t v9 = *(void *)a2;
  uint64_t v10 = (void *)*((void *)a2 + 1);
  if (v10)
  {
    *uint64_t v10 = v9;
    uint64_t v9 = *(void *)a2;
  }

  else
  {
    a1[1] = v9;
  }

  if (v9) {
    BOOL v11 = (void *)(v9 + 8);
  }
  else {
    BOOL v11 = a1;
  }
  *BOOL v11 = *((void *)a2 + 1);
  free(a2);
}

uint64_t sub_10006C408(uint64_t a1)
{
  return 0LL;
}

uint64_t sub_10006C424(uint64_t a1, int a2)
{
  if (!a2)
  {
    *(void *)a1 = 0x200000005LL;
    *(void *)(a1 + 8) = 704LL;
    gettimeofday(&v75, 0LL);
    __int16 tv_sec = v75.tv_sec;
    __int16 tv_usec = v75.tv_usec;
    __int16 v5 = getpid();
    *(_WORD *)(a1 + 68) = tv_usec ^ tv_sec ^ v5;
    *(_WORD *)(a1 + 68) = sub_100065F08((unsigned __int16)(tv_usec ^ tv_sec ^ v5));
  }

  *(_DWORD *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 21) = 2;
  *(_WORD *)(a1 + 22) = 13568;
  *(_DWORD *)(a1 + 16) = 1;
  *(_BYTE *)(a1 + 392) = *(_BYTE *)(a1 + 392) & 0xF0 | 1;
  *(void *)(a1 + 384) = 0LL;
  *(void *)(a1 + 50__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = 0xFFFFFFFFLL;
  *(void *)(a1 + 48__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = 0LL;
  *(void *)(a1 + 488) = 0LL;
  unint64_t v6 = getenv("LOCALDOMAIN");
  if (!v6)
  {
    uint64_t v8 = 0LL;
    goto LABEL_22;
  }

  uint64_t v7 = strncpy((char *)(a1 + 128), v6, 0xFFuLL);
  uint64_t v8 = 0LL;
  int v9 = 0;
  *(_BYTE *)(a1 + 383) = 0;
  uint64_t v10 = (char **)(a1 + 80);
  *(void *)(a1 + 72) = v7;
  do
  {
    unsigned int v11 = *v7;
    if (v11 > 9)
    {
      if (v11 == 32)
      {
LABEL_10:
        *uint64_t v7 = 0;
        int v9 = 1;
        goto LABEL_14;
      }

      if (v11 == 10) {
        break;
      }
    }

    else
    {
      if (v11 == 9) {
        goto LABEL_10;
      }
      if (!*v7) {
        break;
      }
    }

    if (v9)
    {
      int v9 = 0;
      *v10++ = v7;
      uint64_t v8 = 1LL;
    }

LABEL_163:
  *(_BYTE *)(a1 + 392) = *(_BYTE *)(a1 + 392) & 0xF | (16 * v18);
  fclose(v17);
LABEL_164:
  if (!(_DWORD)v8)
  {
    *(void *)(a1 + 72) = a1 + 128;
    *(void *)(a1 + 8__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = 0LL;
  }

  uint64_t v70 = getenv("RES_OPTIONS");
  if (v70) {
    sub_10006CC88(a1, v70, "env");
  }
  *(void *)(a1 + 8) |= 1uLL;
  return 0LL;
}

uint64_t sub_10006CC44()
{
  int tv_sec_low = LOWORD(v3.tv_sec);
  int tv_usec_low = LOWORD(v3.tv_usec);
  return tv_usec_low ^ tv_sec_low ^ (unsigned __int16)getpid();
}

uint64_t sub_10006CC88(uint64_t result, char *__s1, const char *a3)
{
  uint64_t v5 = result;
  if ((*(_BYTE *)(result + 8) & 2) != 0) {
    uint64_t result = printf(";; res_setoptions(%s, %s)...\n", __s1, a3);
  }
  int v6 = *__s1;
  if (*__s1)
  {
    uint64_t v7 = __s1;
LABEL_5:
    while (v6 == 32 || v6 == 9)
    {
      int v8 = *++v7;
      int v6 = v8;
    }

    if (!strncmp(v7, "ndots:", 6uLL))
    {
      uint64_t result = atoi(v7 + 6);
      else {
        char v10 = *(_BYTE *)(v5 + 392) & 0xF0 | result & 0xF;
      }
      *(_BYTE *)(v5 + 392) = v10;
      if ((*(_BYTE *)(v5 + 8) & 2) != 0) {
        uint64_t result = printf(";;\tndots=%d\n", v10 & 0xF);
      }
    }

    else if (!strncmp(v7, "timeout:", 8uLL))
    {
      uint64_t result = atoi(v7 + 8);
      else {
        *(_DWORD *)uint64_t v5 = result;
      }
    }

    else if (!strncmp(v7, "attempts:", 9uLL))
    {
      uint64_t result = atoi(v7 + 9);
      else {
        *(_DWORD *)(v5 + 4) = result;
      }
    }

    else if (!strncmp(v7, "debug", 5uLL))
    {
      if ((*(_BYTE *)(v5 + 8) & 2) == 0)
      {
        printf(";; res_setoptions(%s, %s)..\n", __s1, a3);
        *(void *)(v5 + 8) |= 2uLL;
      }

      uint64_t result = puts(";;\tdebug");
    }

    else
    {
      uint64_t result = strncmp(v7, "inet6", 5uLL);
      if ((_DWORD)result)
      {
        uint64_t result = strncmp(v7, "rotate", 6uLL);
        if ((_DWORD)result)
        {
          uint64_t result = strncmp(v7, "no-check-names", 0xEuLL);
          if ((_DWORD)result) {
            goto LABEL_34;
          }
          uint64_t v9 = *(void *)(v5 + 8) | 0x8000LL;
        }

        else
        {
          uint64_t v9 = *(void *)(v5 + 8) | 0x4000LL;
        }
      }

      else
      {
        uint64_t v9 = *(void *)(v5 + 8) | 0x2000LL;
      }

      *(void *)(v5 + 8) = v9;
    }

uint64_t sub_10006CEDC( uint64_t a1, int a2, _BYTE *a3, unsigned int a4, unsigned int a5, _BYTE *a6, unsigned int a7, uint64_t a8, uint64_t a9, unsigned int a10, _DWORD *a11)
{
  if (a9) {
    BOOL v11 = a10 >= 0xC;
  }
  else {
    BOOL v11 = 0;
  }
  if (!v11) {
    return 39LL;
  }
  *(_DWORD *)(a9 + 8) = 0;
  *(void *)a9 = 0LL;
  unsigned int v17 = *(unsigned __int16 *)(a1 + 68) + 1;
  *(_WORD *)(a1 + 68) = v17;
  unint64_t v18 = *(void *)a9 & 0xFFFFFFFFFF870000LL | (bswap32(v17) >> 16) & 0xFF87FFFF | ((a2 & 0xF) << 19);
  *(void *)a9 = v18;
  *(void *)a9 = v18 & 0xFFFFFFFFF0FEFFFFLL | (*(_DWORD *)(a1 + 8) << 10) & 0x10000;
  v31[0] = a9;
  v31[1] = 0LL;
  if (a2 != 4)
  {
    if (a2 == 1)
    {
      if (a10 - 12 >= a7 + 11)
      {
        *(_BYTE *)(a9 + 12) = 0;
        sub_100060B78((_WORD *)(a9 + 13), a5);
        sub_100060B78((_WORD *)(a9 + 15), a4);
        sub_100060B6C((_DWORD *)(a9 + 17), 0);
        sub_100060B78((_WORD *)(a9 + 21), a7);
        LODWORD(v22) = a9 + 23;
        if (a7)
        {
          memcpy((void *)(a9 + 23), a6, a7);
          int v27 = 0;
          uint64_t v25 = 0x100000000000000LL;
          uint64_t v26 = 0xFFFFFFFFFFFFLL;
          int v28 = -1;
          LODWORD(v22) = v22 + a7;
        }

        else
        {
          int v27 = 0;
          uint64_t v25 = 0x100000000000000LL;
          uint64_t v26 = 0xFFFFFFFFFFFFLL;
          int v28 = -1;
        }

        goto LABEL_20;
      }

      return 19LL;
    }

    if (a2) {
      return 27LL;
    }
  }

  unsigned int v19 = sub_10006B974(a3, (char *)(a9 + 12), a10 - 16, v31, (uint64_t)&v32);
  if ((v19 & 0x80000000) != 0) {
    return 19LL;
  }
  unsigned int v20 = v19;
  uint64_t v21 = a9 + 12 + v19;
  sub_100060B78((_WORD *)v21, a5);
  sub_100060B78((_WORD *)(v21 + 2), a4);
  uint64_t v22 = v21 + 4;
  *(_WORD *)(a9 + 4) = 256;
  if (!a2 || !a6) {
    goto LABEL_21;
  }
  unsigned int v23 = sub_10006B974(a6, (char *)(v21 + 4), a10 - v20 - 26, v31, (uint64_t)&v32);
  if ((v23 & 0x80000000) != 0) {
    return 19LL;
  }
  uint64_t v24 = v22 + v23;
  sub_100060B78((_WORD *)v24, 0xAu);
  sub_100060B78((_WORD *)(v24 + 2), a4);
  sub_100060B6C((_DWORD *)(v24 + 4), 0);
  sub_100060B78((_WORD *)(v24 + 8), 0);
  uint64_t v25 = 0LL;
  LODWORD(v22) = v24 + 10;
  uint64_t v26 = -1LL;
  int v27 = 0x1000000;
  int v28 = 0xFFFF;
LABEL_20:
  int v30 = *(_DWORD *)(a9 + 8) & v28 | v27;
  *(void *)a9 = *(void *)a9 & v26 | v25;
  *(_DWORD *)(a9 + 8) = v30;
LABEL_21:
  uint64_t result = 0LL;
  *a11 = v22 - a9;
  return result;
}

uint64_t sub_10006D170(uint64_t a1, uint64_t a2, unsigned int *a3, _DWORD *a4)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a3)
  {
    int v7 = *a4 - 12;
    if (*a4 >= 0xCu)
    {
      uint64_t v9 = a2;
      a3[2] = 0;
      *(void *)a3 = 0LL;
      unsigned int v10 = *(unsigned __int16 *)(a1 + 68) + 1;
      *(_WORD *)(a1 + 68) = v10;
      *(void *)a3 = *(void *)a3 & 0xFFFFFFFFF0870000LL | 0x280000 | (bswap32(v10) >> 16);
      v101[0] = a3;
      v101[1] = 0LL;
      if (a2)
      {
        if (*(_DWORD *)(a2 + 32))
        {
          return 4294967293LL;
        }

        else
        {
          int v11 = 0;
          unsigned int v12 = (char *)(a3 + 3);
          int32x4_t v102 = 0uLL;
          BOOL v13 = &v102.i8[4];
          while (1)
          {
            uint64_t v14 = *(unsigned int *)(v9 + 32);
            int v15 = v11;
            uint64_t v16 = 0LL;
            ++v102.i32[v14];
            while ((int)v14 + (int)v16 <= 2)
            {
              if (*(_DWORD *)&v13[4 * v14 + 4 * v16++]) {
                return 4294967293LL;
              }
            }

            int v19 = *(_DWORD *)(v9 + 48);
            unsigned int v18 = *(_DWORD *)(v9 + 52);
            int v96 = v11 + 1;
            uint64_t v95 = v13;
            if ((_DWORD)v14 == 1)
            {
              int v20 = *(_DWORD *)(v9 + 84);
              switch(v20)
              {
                case 3:
                  unsigned int v93 = 0;
                  LOBYTE(v21) = 0;
                  *(_DWORD *)(v9 + 8__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = 0;
                  LOBYTE(v18) = -1;
                  goto LABEL_28;
                case 6:
                  unsigned int v93 = 0;
                  LOBYTE(v21) = 0;
                  *(_DWORD *)(v9 + 8__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = 0;
                  LOWORD(v19) = 255;
                  LOBYTE(v18) = -1;
                  goto LABEL_29;
                case 7:
                  unsigned int v93 = 0;
                  unsigned int v21 = v18 >> 8;
                  if (!*(_DWORD *)(v9 + 80)) {
                    LOWORD(v19) = 255;
                  }
                  goto LABEL_29;
                case 8:
                  unsigned int v93 = 0;
                  *(_DWORD *)(v9 + 8__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = 0;
                  unsigned int v21 = v18 >> 8;
LABEL_28:
                  LOWORD(v19) = 254;
                  goto LABEL_29;
                default:
                  goto LABEL_134;
              }
            }

            unsigned int v21 = v18 >> 8;
            unsigned int v93 = *(_DWORD *)(v9 + 56);
            if ((_DWORD)v14 == 2)
            {
              int v20 = *(_DWORD *)(v9 + 84);
              if (v20 != 1)
              {
                if (v20)
                {
LABEL_134:
                  fprintf(__stderrp, "res_mkupdate: incorrect opcode: %d\n", v20);
                  fflush(__stderrp);
                  return 0xFFFFFFFFLL;
                }

                if (*(_DWORD *)(v9 + 80)) {
                  LOWORD(v19) = 254;
                }
                else {
                  LOWORD(v19) = 255;
                }
              }
            }

BOOL sub_10006DC34(uint64_t a1, unint64_t *a2, unint64_t a3)
{
  size_t v4 = (unsigned __int8 *)*a2;
  if (*a2 <= a3)
  {
    uint64_t v5 = 0LL;
    do
    {
      int v8 = (char)*v4;
      if (v8 < 0) {
        __uint32_t v9 = __maskrune(*v4, 0x4000uLL);
      }
      else {
        __uint32_t v9 = _DefaultRuneLocale.__runetype[*v4] & 0x4000;
      }
      if (v8) {
        BOOL v10 = v9 == 0;
      }
      else {
        BOOL v10 = 0;
      }
      if (v10)
      {
        *a2 = (unint64_t)(v4 + 1);
        if (v5 > 1023) {
          break;
        }
        *(_BYTE *)(a1 + v5++) = v8;
        size_t v4 = (unsigned __int8 *)*a2;
      }

      else
      {
        if (v5) {
          break;
        }
        *a2 = (unint64_t)++v4;
      }
    }

    while ((unint64_t)v4 <= a3);
  }

  else
  {
    uint64_t v5 = 0LL;
  }

  *(_BYTE *)(a1 + v5) = 0;
  return v5 != 0;
}

BOOL sub_10006DD04(uint64_t a1, unint64_t *a2, unint64_t a3)
{
  size_t v4 = (unsigned __int8 *)*a2;
  if (*a2 <= a3)
  {
    uint64_t v5 = 0LL;
    while (1)
    {
      int v8 = (char)*v4;
      if (v8 < 0) {
        __uint32_t v9 = __maskrune(*v4, 0x4000uLL);
      }
      else {
        __uint32_t v9 = _DefaultRuneLocale.__runetype[*v4] & 0x4000;
      }
      if (v9) {
        BOOL v10 = v5 == 0;
      }
      else {
        BOOL v10 = 0;
      }
      if (v10)
      {
        uint64_t v5 = 0LL;
        *a2 = (unint64_t)++v4;
      }

      else
      {
        if (!v8) {
          goto LABEL_16;
        }
        ++*a2;
        if (v5 > 1023) {
          goto LABEL_16;
        }
        *(_BYTE *)(a1 + v5++) = v8;
        size_t v4 = (unsigned __int8 *)*a2;
      }
    }
  }

  uint64_t v5 = 0LL;
LABEL_16:
  *(_BYTE *)(a1 + v5) = 0;
  return v5 != 0;
}

uint64_t sub_10006DDDC(_BYTE **a1, unint64_t a2)
{
  uint64_t i = *a1;
  char v7 = 0;
  uint64_t v3 = 0LL;
  char v8 = 1;
  while (1)
  {
    int v9 = *i;
    __uint32_t v10 = (char)*i < 0
    if (v9 && v10 == 0) {
      break;
    }
    if ((v8 & 1) == 0) {
      return v3;
    }
    *a1 = ++i;
LABEL_20:
    char v7 = 0;
    char v8 = 1;
LABEL_21:
  }

  if (v9 == 59)
  {
    if ((v8 & 1) == 0) {
      return v3;
    }
    goto LABEL_20;
  }

  if ((v9 - 48) < 0xA)
  {
    char v8 = 0;
    *a1 = ++i;
    uint64_t v3 = (v9 - 48 + 10 * v3);
    char v7 = 1;
    goto LABEL_21;
  }

  if (v9 != 41 || (v7 & 1) == 0) {
    return 0xFFFFFFFFLL;
  }
  *a1 = i - 1;
  return v3;
}

uint64_t sub_10006DF1C(char *a1)
{
  if (!qword_1000C5FF8) {
    sub_10006E4F4();
  }
  return sub_10006E5CC(a1, &qword_1000C5FF8);
}

uint64_t sub_10006DF54(char *a1)
{
  if (!qword_1000C5FF0) {
    sub_10006E3D0();
  }
  return sub_10006E5CC(a1, &qword_1000C5FF0);
}

uint64_t sub_10006DF8C(uint64_t a1, _BYTE **a2, unint64_t a3)
{
  size_t v4 = *a2;
  if ((unint64_t)*a2 <= a3)
  {
    int v11 = 0;
    int v12 = 0;
    int v6 = 0;
    int v13 = 0;
    unsigned int v16 = 0;
    uint64_t v5 = 0LL;
    while (1)
    {
      uint64_t v14 = *v4;
      if (!*v4) {
        goto LABEL_3;
      }
      if (!v5 && !v6)
      {
        if ((v14 & 0x80) != 0)
        {
          if (__maskrune(*v4, 0x4000uLL))
          {
LABEL_19:
            uint64_t v5 = 0LL;
            int v6 = 0;
            goto LABEL_30;
          }
        }

        else if ((_DefaultRuneLocale.__runetype[v14] & 0x4000) != 0)
        {
          goto LABEL_19;
        }
      }

      if ((_DWORD)v14 == 34)
      {
        if (v12)
        {
          char v7 = (_BYTE *)(a1 + v5);
          LOBYTE(v14) = 34;
          goto LABEL_28;
        }

        v13 ^= 1u;
        size_t v4 = *a2 + 1;
        *a2 = v4;
        int v6 = 1;
      }

      else
      {
        if ((_DWORD)v14 == 92)
        {
          if (v12)
          {
            char v7 = (_BYTE *)(a1 + v5);
            LOBYTE(v14) = 92;
            goto LABEL_28;
          }

          unsigned int v16 = 0;
          int v11 = 0;
        }

        else
        {
          if (!v12)
          {
            char v7 = (_BYTE *)(a1 + v5);
            if (!v13)
            {
              if ((v14 & 0x80) != 0) {
                __uint32_t v15 = __maskrune(v14, 0x4000uLL);
              }
              else {
                __uint32_t v15 = _DefaultRuneLocale.__runetype[v14] & 0x4000;
              }
              if (v15) {
                goto LABEL_4;
              }
              int v13 = 0;
            }

uint64_t sub_10006E188(const char **a1, unint64_t a2)
{
  size_t v4 = *a1;
  uint64_t i = v4 + 2;
  char v7 = 0;
  uint64_t v8 = 0LL;
  *a1 = i;
  char v9 = 1;
  while (1)
  {
    uint64_t v10 = *(unsigned __int8 *)i;
    __darwin_ct_rune_t v11 = *(unsigned __int8 *)i;
    __uint32_t v12 = *i < 0 ? __maskrune(*(unsigned __int8 *)i, 0x4000uLL) : _DefaultRuneLocale.__runetype[v10] & 0x4000;
    if (v11 && v12 == 0) {
      break;
    }
    if ((v9 & 1) == 0) {
      return v8;
    }
    *a1 = ++i;
LABEL_20:
    char v7 = 0;
    char v9 = 1;
LABEL_21:
  }

  if (v11 == 59)
  {
    if ((v9 & 1) == 0) {
      return v8;
    }
    goto LABEL_20;
  }

  if ((_DefaultRuneLocale.__runetype[v10] & 0x10000) != 0)
  {
    *a1 = ++i;
    int v14 = 16 * v8;
    if ((v11 - 48) > 9)
    {
      uint64_t v8 = (v14 + __tolower(v11) - 87);
      uint64_t i = *a1;
    }

    else
    {
      uint64_t v8 = (v11 - 48 + v14);
    }

    char v9 = 0;
    char v7 = 1;
    goto LABEL_21;
  }

  if (v11 != 41 || (v7 & 1) == 0) {
    return 0xFFFFFFFFLL;
  }
  *a1 = i - 1;
  return v8;
}

void *sub_10006E324(int a1, const char *a2, int a3, int a4, int a5)
{
  uint64_t v10 = calloc(1uLL, 0x70uLL);
  if (v10)
  {
    __darwin_ct_rune_t v11 = strdup(a2);
    v10[5] = v11;
    if (v11)
    {
      *((_DWORD *)v10 + 12) = a3;
      *((_DWORD *)v10 + 13) = a4;
      *((_DWORD *)v10 + 14) = a5;
      *((_DWORD *)v10 + 8) = a1;
    }

    else
    {
      free(v10);
      return 0LL;
    }
  }

  return v10;
}

void sub_10006E3A4(void *a1)
{
  int v2 = (void *)a1[5];
  if (v2) {
    free(v2);
  }
  free(a1);
}

void sub_10006E3D0()
{
  int v0 = getservent();
  if (v0)
  {
    char v1 = v0;
    do
    {
      int v2 = malloc(0x28uLL);
      if (!v2) {
        break;
      }
      uint64_t v3 = v2;
      size_t v4 = strdup(v1->s_name);
      v3[2] = v4;
      uint64_t v5 = strdup(v1->s_proto);
      v3[3] = v5;
      if (v4) {
        BOOL v6 = v5 == 0LL;
      }
      else {
        BOOL v6 = 1;
      }
      if (v6)
      {
        uint64_t v8 = v5;
        if (v4) {
          free(v4);
        }
        if (v8) {
          free(v8);
        }
        free(v3);
        break;
      }

      *((_DWORD *)v3 + 8) = bswap32(LOWORD(v1->s_port)) >> 16;
      uint64_t v7 = qword_1000C5FF0;
      *uint64_t v3 = qword_1000C5FF0;
      v3[1] = 0LL;
      if (v7) {
        *(void *)(v7 + 8) = v3;
      }
      qword_1000C5FF0 = (uint64_t)v3;
      char v1 = getservent();
    }

    while (v1);
  }

  endservent();
}

void sub_10006E4A0()
{
  int v0 = (void **)qword_1000C5FF0;
  if (qword_1000C5FF0)
  {
    do
    {
      char v1 = (void **)*v0;
      free(v0[2]);
      free(v0[3]);
      free(v0);
      int v0 = v1;
    }

    while (v1);
  }

  qword_1000C5FF0 = 0LL;
}

void sub_10006E4F4()
{
  int v0 = getprotoent();
  if (v0)
  {
    char v1 = v0;
    do
    {
      int v2 = malloc(0x28uLL);
      if (!v2) {
        break;
      }
      uint64_t v3 = v2;
      size_t v4 = strdup(v1->p_name);
      v3[2] = v4;
      if (!v4)
      {
        free(v3);
        break;
      }

      *((_DWORD *)v3 + 8) = v1->p_proto;
      uint64_t v5 = qword_1000C5FF8;
      *uint64_t v3 = qword_1000C5FF8;
      v3[1] = 0LL;
      if (v5) {
        *(void *)(v5 + 8) = v3;
      }
      qword_1000C5FF8 = (uint64_t)v3;
      char v1 = getprotoent();
    }

    while (v1);
  }

  endprotoent();
}

void sub_10006E580()
{
  int v0 = (void **)qword_1000C5FF8;
  if (qword_1000C5FF8)
  {
    do
    {
      char v1 = (void **)*v0;
      free(v0[2]);
      free(v0);
      int v0 = v1;
    }

    while (v1);
  }

  qword_1000C5FF8 = 0LL;
}

uint64_t sub_10006E5CC(char *a1, uint64_t *a2)
{
  uint64_t v3 = (uint64_t *)*a2;
  if (*a2)
  {
    uint64_t v5 = (uint64_t *)*a2;
    while (strcasecmp((const char *)v5[2], a1))
    {
      uint64_t v5 = (uint64_t *)*v5;
      if (!v5) {
        goto LABEL_5;
      }
    }

    if (v5 != v3)
    {
      char v9 = (void *)v5[1];
      *char v9 = *v5;
      if (*v5) {
        *(void *)(*v5 + 8) = v9;
      }
      *(void *)(*a2 + 8) = v5;
      *uint64_t v5 = *a2;
      *a2 = (uint64_t)v5;
    }

    return *((unsigned int *)v5 + 8);
  }

  else
  {
LABEL_5:
    int v6 = sscanf(a1, "%d", &v10);
    if (v10 >= 1 && v6 == 1) {
      return v10;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }

char *sub_10006E680(int a1)
{
  if (!qword_1000C5FF8) {
    sub_10006E4F4();
  }
  int v2 = &qword_1000C5FF8;
  do
  {
    int v2 = (uint64_t *)*v2;
    if (!v2)
    {
      uint64_t v5 = byte_1000C6000;
      __sprintf_chk(byte_1000C6000, 0, 8uLL, "%d", a1);
      return v5;
    }
  }

  while (*((_DWORD *)v2 + 8) != a1);
  if (v2 != (uint64_t *)qword_1000C5FF8)
  {
    uint64_t v3 = (uint64_t *)v2[1];
    *uint64_t v3 = *v2;
    if (*v2) {
      *(void *)(*v2 + 8) = v3;
    }
    uint64_t v4 = qword_1000C5FF8;
    *(void *)(qword_1000C5FF8 + 8) = v2;
    *int v2 = v4;
    qword_1000C5FF8 = (uint64_t)v2;
  }

  uint64_t v5 = (char *)v2[2];
  qword_1000C6010 = (uint64_t)v5;
  dword_1000C6020 = a1;
  return v5;
}

char *sub_10006E740(unsigned int a1, char *a2)
{
  uint64_t v4 = qword_1000C5FF0;
  if (qword_1000C5FF0 || (sub_10006E3D0(), (uint64_t v4 = qword_1000C5FF0) != 0))
  {
    unsigned int v5 = __rev16(a1);
    uint64_t v6 = v4;
    while (1)
    {
      if (*(unsigned __int16 *)(v6 + 32) == a1)
      {
        uint64_t v7 = *(const char **)(v6 + 24);
        if (!strcasecmp(v7, a2)) {
          break;
        }
      }

      uint64_t v6 = *(void *)v6;
      if (!v6) {
        goto LABEL_7;
      }
    }

    if (v6 != v4)
    {
      char v9 = *(void **)(v6 + 8);
      *char v9 = *(void *)v6;
      if (*(void *)v6) {
        *(void *)(*(void *)v6 + 8LL) = v9;
      }
      uint64_t v10 = qword_1000C5FF0;
      *(void *)(qword_1000C5FF0 + 8) = v6;
      *(void *)uint64_t v6 = v10;
      qword_1000C5FF0 = v6;
    }

    uint64_t v8 = *(char **)(v6 + 16);
    qword_1000C6028 = (uint64_t)v8;
    dword_1000C6038 = v5;
    qword_1000C6040 = (uint64_t)v7;
  }

  else
  {
LABEL_7:
    unsigned int v12 = a1;
    uint64_t v8 = byte_1000C6008;
    __sprintf_chk(byte_1000C6008, 0, 8uLL, "%d", v12);
  }

  return v8;
}

uint64_t sub_10006E83C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 16);
  uint64_t v3 = (unsigned __int8 *)(a1 + 21);
  uint64_t v4 = (unsigned __int8 *)(a1 + 21);
  while (1)
  {
    int v5 = *v4;
    v4 += 16;
    if (v5 == *(unsigned __int8 *)(a2 + 1) && *(unsigned __int16 *)(v3 + 1) == *(unsigned __int16 *)(a2 + 2))
    {
      int v6 = *(_DWORD *)(v3 + 3);
      if (!v6 || v6 == *(_DWORD *)(a2 + 4)) {
        break;
      }
    }

    uint64_t v3 = v4;
    if (!--v2) {
      return 0LL;
    }
  }

  return 1LL;
}

uint64_t sub_10006E8A0(const char *a1, int a2, int a3, unint64_t a4, unint64_t a5)
{
  if (!*(_WORD *)(a4 + 4)) {
    return 0LL;
  }
  uint64_t v10 = (_BYTE *)(a4 + 12);
  unsigned int v11 = __rev16(*(unsigned __int16 *)(a4 + 4)) + 1;
  while (1)
  {
    int v12 = sub_10006B938(a4, a5, v10, v18, 0x402u);
    if (v12 < 0) {
      break;
    }
    int v13 = (unsigned __int16 *)&v10[v12];
    uint64_t v10 = v13 + 2;
    int v14 = sub_100060B5C(v13);
    int v15 = sub_100060B5C(v13 + 1);
    if (v14 == a2 && v15 == a3)
    {
      uint64_t result = sub_10006ACC8(v18, a1);
      if ((_DWORD)result == 1) {
        return result;
      }
    }

    if (--v11 <= 1) {
      return 0LL;
    }
  }

  return 0xFFFFFFFFLL;
}

uint64_t sub_10006E9AC(void *a1, unint64_t a2, uint64_t *a3, unint64_t a4)
{
  int v5 = (char *)a1 + 12;
  uint64_t result = 0xFFFFFFFFLL;
  if ((unint64_t)v5 <= a2 && (unint64_t)a3 + 12 <= a4)
  {
    uint64_t v10 = *a3;
    if ((*a1 & 0x780000LL) == 0x280000 && (v10 & 0x780000) == 0x280000) {
      return 1LL;
    }
    if ((unsigned __int16)WORD2(*a1) == WORD2(v10))
    {
      unsigned int v11 = (bswap32(HIDWORD(*a1)) >> 16) + 1;
      while ((int)--v11 >= 1)
      {
        int v12 = sub_10006B938((unint64_t)a1, a2, v5, v16, 0x402u);
        if (v12 < 0) {
          return 0xFFFFFFFFLL;
        }
        int v13 = (unsigned __int16 *)&v5[v12];
        int v5 = v13 + 2;
        int v14 = sub_100060B5C(v13);
        int v15 = sub_100060B5C(v13 + 1);
        uint64_t result = sub_10006E8A0(v16, v14, v15, (unint64_t)a3, a4);
        if (!(_DWORD)result) {
          return result;
        }
      }

      return 1LL;
    }

    return 0LL;
  }

  return result;
}

uint64_t sub_10006EB04( uint64_t a1, _WORD *a2, unsigned int a3, unsigned __int16 *a4, uint64_t a5, unsigned int *a6)
{
  *(void *)&v96[1] = a2;
  v96[0] = a3;
  uint64_t v12 = (*(void *)(a1 + 8) >> 3) & 1LL;
  if (a3 > 0x200) {
    LODWORD(v12) = 1;
  }
  int v89 = v12;
  int v13 = *(_DWORD *)(a1 + 16);
  unsigned int v14 = v13 - 1;
  if (v13 >= 1 && (*(void *)(a1 + 8) & 0x4000LL) != 0)
  {
    *(_OWORD *)v98[0].fds_bits = *(_OWORD *)(a1 + 20);
    *(_OWORD *)(a1 + 16LL * v14 + 2__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = *(_OWORD *)v98[0].fds_bits;
  }

  sub_10006566C(a1);
  int v16 = *(_DWORD *)(a1 + 4);
  if (v16 < 1)
  {
    int v17 = 0;
    uint64_t v6 = 2LL;
    goto LABEL_178;
  }

  unsigned int v85 = a2;
  unsigned int v83 = a6;
  int v17 = 0;
  int v88 = 0;
  int v18 = 0;
  int v19 = 0;
  LODWORD(v2__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = *(_DWORD *)(a1 + 16);
  uint64_t v6 = 2LL;
  do
  {
    int v84 = v17;
    uint64_t v21 = 0LL;
    do
    {
      uint64_t v94 = (sockaddr *)(a1 + 16 * v21 + 20);
      int v22 = 1 << v21;
      if ((v19 & (1 << v21)) != 0)
      {
        int v23 = *(_DWORD *)(a1 + 500);
        if ((v23 & 0x80000000) == 0)
        {
          sub_100065DD0(v23);
          *(_DWORD *)(a1 + 50__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = -1;
          *(_DWORD *)(a1 + 504) &= 0xFFFFFFFC;
        }

        goto LABEL_19;
      }

      int v87 = v19;
      while (1)
      {
        int v24 = v88;
        unsigned int v86 = v6;
        int v90 = v18;
LABEL_23:
        if (*(void *)(a1 + 480))
        {
          int v25 = 42;
          while (1)
          {
            int v26 = (*(uint64_t (**)(sockaddr **, unsigned int *, unsigned int *, unsigned __int16 *, uint64_t, unsigned int *))(a1 + 480))( &v94,  &v96[1],  v96,  a4,  a5,  &v95);
            if (v26 != 2) {
              break;
            }
            if (!--v25) {
              return 34LL;
            }
          }

          if (v26)
          {
            if (v26 == 3) {
              return v95;
            }
            goto LABEL_133;
          }
        }

        if (v89) {
          break;
        }
        unsigned int v51 = *(_DWORD *)(a1 + 500);
        int v19 = v87;
        if ((v51 & 0x80000000) == 0)
        {
          unsigned int v52 = *(_DWORD *)(a1 + 504);
          if ((v52 & 1) == 0) {
            goto LABEL_85;
          }
          sub_100065DD0(v51);
          *(_DWORD *)(a1 + 50__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = -1;
          *(_DWORD *)(a1 + 504) &= 0xFFFFFFFC;
        }

        unsigned int v51 = sub_100065D28(2, 2, 0);
        *(_DWORD *)(a1 + 50__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = v51;
        if (v51 >= 0x400) {
          goto LABEL_188;
        }
        unsigned int v52 = *(_DWORD *)(a1 + 504) & 0xFFFFFFFD;
        *(_DWORD *)(a1 + 504) = v52;
LABEL_85:
        if (*(_DWORD *)(a1 + 16) == 1 || !(v18 | v21))
        {
          if ((v52 & 2) == 0)
          {
            if ((sub_100065CD4(v51, v94, 0x10u) & 0x80000000) != 0) {
              goto LABEL_169;
            }
            *(_DWORD *)(a1 + 504) |= 2u;
            unsigned int v51 = *(_DWORD *)(a1 + 500);
          }

          uint64_t v56 = sub_1000657EC(v51, *(const void **)&v96[1], v96[0], 0);
        }

        else
        {
          if ((v52 & 2) != 0)
          {
            socklen_t v92 = 16;
            int v53 = sub_100065D28(2, 2, 0);
            int v54 = getsockname(*(_DWORD *)(a1 + 500), &v97, &v92);
            if (v53 < 0)
            {
LABEL_188:
              unsigned int v82 = __error();
              return sub_100068C8C(*v82);
            }

            int v55 = v54;
            dup2(v53, *(_DWORD *)(a1 + 500));
            sub_100065DD0(v53);
            if (!v55)
            {
              *(_DWORD *)&v97.sa_data[2] = 0;
              sub_100065D7C(*(_DWORD *)(a1 + 500), &v97, v92);
            }

            *(_DWORD *)(a1 + 504) &= ~2u;
            *__error() = 0;
            unsigned int v51 = *(_DWORD *)(a1 + 500);
          }

          uint64_t v56 = sendto(v51, *(const void **)&v96[1], v96[0], 0, v94, 0x10u);
        }

        if (v56 != v96[0])
        {
LABEL_169:
          int v19 = v87 | v22;
          unsigned int v57 = *(_DWORD *)(a1 + 500);
          if ((v57 & 0x80000000) != 0) {
            goto LABEL_156;
          }
LABEL_155:
          sub_100065DD0(v57);
          *(_DWORD *)(a1 + 50__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = -1;
          *(_DWORD *)(a1 + 504) &= 0xFFFFFFFC;
LABEL_156:
          int v89 = 0;
          goto LABEL_19;
        }

        unsigned int v57 = *(_DWORD *)(a1 + 500);
        if (v57 >= 0x400)
        {
LABEL_154:
          if ((v57 & 0x80000000) == 0) {
            goto LABEL_155;
          }
          goto LABEL_156;
        }

        int v58 = *(_DWORD *)a1 << v18;
        if (v18 >= 1) {
          v58 /= *(int *)(a1 + 16);
        }
        if (v58 <= 1) {
          int v58 = 1;
        }
        uint64_t v91 = v58 + (int)qword_10008CE80;
LABEL_104:
        uint64_t v59 = v58;
        while (1)
        {
          memset(v98, 0, 128);
          int v60 = *(_DWORD *)(a1 + 500);
          if (__darwin_check_fd_set_overflow(v60, v98, 0)) {
            *(__int32_t *)((char *)v98[0].fds_bits + (((unint64_t)v60 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v60;
          }
          *(void *)&v97.sa_len = v59;
          *(_DWORD *)&v97.sa_data[6] = 0;
          int v61 = sub_100065E54(*(_DWORD *)(a1 + 500) + 1, v98, 0LL, 0LL, (timeval *)&v97);
          int v19 = v87;
          if (!v61)
          {
            int v84 = 1;
            goto LABEL_156;
          }

          int v62 = v61;
          int v63 = __error();
          if (v62 < 0)
          {
            if (*v63 != 4 || (int v58 = v91 - qword_10008CE80, qword_10008CE80 > v91))
            {
LABEL_152:
              unsigned int v57 = *(_DWORD *)(a1 + 500);
              goto LABEL_154;
            }

            goto LABEL_104;
          }

          *int v63 = 0;
          socklen_t v93 = 16;
          int v64 = sub_100065BC4(*(_DWORD *)(a1 + 500), a4, a5, 0, (sockaddr *)&v99, &v93);
          unsigned int v95 = v64;
          if (v64 <= 0) {
            goto LABEL_152;
          }
          if (v64 <= 0xB)
          {
            int v19 = v87 | v22;
            unsigned int v57 = *(_DWORD *)(a1 + 500);
            int v84 = 1;
            uint64_t v6 = 19LL;
            goto LABEL_154;
          }

          uint64_t v65 = *(void *)a4;
          int v84 = 1;
          if ((unsigned __int16)*(void *)a4 == *v85)
          {
            uint64_t v66 = *(void *)(a1 + 8);
            if ((v66 & 0x400) != 0 || (int v84 = 1, sub_10006E83C(a1, (uint64_t)&v99)))
            {
              if ((v66 & 0x800) != 0) {
                goto LABEL_120;
              }
              int v84 = 1;
              if (sub_10006E9AC( *(void **)&v96[1],  *(void *)&v96[1] + v96[0],  (uint64_t *)a4,  (unint64_t)a4 + a5)) {
                break;
              }
            }
          }
        }

        uint64_t v65 = *(void *)a4;
LABEL_120:
        unsigned int v67 = BYTE3(v65) & 0xF;
        if (v67 > 5)
        {
          int v19 = v87;
        }

        else
        {
          int v19 = v87;
          if (((1 << v67) & 0x34) != 0)
          {
            int v68 = *(_DWORD *)(a1 + 500);
            if ((v68 & 0x80000000) == 0)
            {
              sub_100065DD0(v68);
              *(_DWORD *)(a1 + 50__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = -1;
              *(_DWORD *)(a1 + 504) &= 0xFFFFFFFC;
            }

            int v19 = v87 | v22;
            if (!*(void *)(a1 + 384))
            {
              int v84 = 1;
              goto LABEL_156;
            }
          }
        }

        uint64_t v69 = *(void *)(a1 + 8);
        int v87 = v19;
        if ((v69 & 0x20) != 0 || (*(void *)a4 & 0x20000) == 0)
        {
          int v89 = 0;
          int v90 = v18;
          int v84 = 1;
          int v24 = v88;
          unsigned int v86 = v6;
          if ((v69 & 0x100) == 0)
          {
LABEL_157:
            int v77 = *(_DWORD *)(a1 + 500);
            if ((v77 & 0x80000000) == 0)
            {
              sub_100065DD0(v77);
              *(_DWORD *)(a1 + 50__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = -1;
              *(_DWORD *)(a1 + 504) &= 0xFFFFFFFC;
            }
          }

          goto LABEL_159;
        }

        int v70 = *(_DWORD *)(a1 + 500);
        if ((v70 & 0x80000000) == 0)
        {
          sub_100065DD0(v70);
          *(_DWORD *)(a1 + 50__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = -1;
          *(_DWORD *)(a1 + 504) &= 0xFFFFFFFC;
        }

        int v84 = 1;
        int v89 = 1;
        if ((v19 & v22) != 0)
        {
          int v89 = 1;
          goto LABEL_142;
        }
      }

      int v90 = *(_DWORD *)(a1 + 4);
      int v27 = *(_DWORD *)(a1 + 500);
      if (v27 < 0) {
        goto LABEL_45;
      }
      if ((*(_BYTE *)(a1 + 504) & 1) == 0) {
        goto LABEL_32;
      }
      *(_DWORD *)&v97.sa_len = 16;
      if (getpeername(v27, (sockaddr *)v98, (socklen_t *)&v97.sa_len) < 0
        || BYTE1(v98[0].fds_bits[0]) != v94->sa_family
        || HIWORD(v98[0].fds_bits[0]) != *(unsigned __int16 *)v94->sa_data
        || v98[0].fds_bits[1] != *(_DWORD *)&v94->sa_data[2])
      {
        int v29 = *(_DWORD *)(a1 + 500);
        if (v29 < 0)
        {
          unsigned int v30 = *(_DWORD *)(a1 + 504);
        }

        else
        {
          sub_100065DD0(v29);
          *(_DWORD *)(a1 + 50__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = -1;
          unsigned int v30 = *(_DWORD *)(a1 + 504) & 0xFFFFFFFC;
        }

        unsigned int v28 = v30 & 0xFFFFFFFE;
        goto LABEL_44;
      }

      int v27 = *(_DWORD *)(a1 + 500);
      if ((v27 & 0x80000000) == 0)
      {
LABEL_32:
        if ((*(_BYTE *)(a1 + 504) & 1) != 0) {
          goto LABEL_48;
        }
        sub_100065DD0(v27);
        *(_DWORD *)(a1 + 50__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = -1;
        unsigned int v28 = *(_DWORD *)(a1 + 504) & 0xFFFFFFFC;
LABEL_44:
        *(_DWORD *)(a1 + 504) = v28;
      }

LABEL_140:
        sub_100065DD0(v73);
        *(_DWORD *)(a1 + 50__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = -1;
        *(_DWORD *)(a1 + 504) &= 0xFFFFFFFC;
        goto LABEL_141;
      }

      *(_DWORD *)(a1 + 504) |= 1u;
LABEL_48:
      sub_100060B78(&v93, v96[0]);
      v99.iov_base = &v93;
      v99.iov_len = 2LL;
      uint64_t v100 = *(void *)&v96[1];
      uint64_t v101 = v96[0];
      ssize_t v33 = writev(*(_DWORD *)(a1 + 500), &v99, 2);
      if (v33 != v96[0] + 2)
      {
        unsigned int v74 = __error();
        uint64_t v6 = sub_100068C8C(*v74);
        v87 |= v22;
        int v73 = *(_DWORD *)(a1 + 500);
        if (v73 < 0) {
          goto LABEL_141;
        }
        goto LABEL_140;
      }

      int v34 = 0;
      while (2)
      {
        unsigned __int16 v35 = 2;
        LOWORD(v93) = 2;
        uint64_t v36 = a4;
        do
        {
          int v37 = sub_100065C5C(*(_DWORD *)(a1 + 500), v36, v35);
          if (v37 < 1)
          {
            int v47 = __error();
            uint64_t v48 = sub_100068C8C(*v47);
            int v49 = *(_DWORD *)(a1 + 500);
            if ((v49 & 0x80000000) == 0)
            {
              sub_100065DD0(v49);
              *(_DWORD *)(a1 + 50__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = -1;
              *(_DWORD *)(a1 + 504) &= 0xFFFFFFFC;
            }

            if ((_DWORD)v48 != 12 || v24 != 0)
            {
              uint64_t v6 = v48;
              goto LABEL_141;
            }

            unsigned int v86 = 12;
            int v24 = 1;
            goto LABEL_23;
          }

          uint64_t v36 = (unsigned __int16 *)((char *)v36 + v37);
          int v38 = (unsigned __int16)v93;
          unsigned __int16 v35 = v93 - v37;
          LOWORD(v93) = v93 - v37;
        }

        while (v38 != (unsigned __int16)v37);
        unsigned int v39 = sub_100060B5C(a4);
        unsigned int v95 = v39;
        else {
          unsigned __int16 v40 = v39;
        }
        LOWORD(v93) = v40;
        if ((v40 & 0xFFFCu) < 0xC)
        {
          v87 |= v22;
          int v73 = *(_DWORD *)(a1 + 500);
          uint64_t v6 = 19LL;
          goto LABEL_139;
        }

        if (v40)
        {
          __uint32_t v41 = a4;
          while (1)
          {
            int v42 = sub_100065C5C(*(_DWORD *)(a1 + 500), v41, v40);
            if (v42 < 1) {
              break;
            }
            __uint32_t v41 = (unsigned __int16 *)((char *)v41 + v42);
            LOWORD(v93) = v93 - v42;
            unsigned __int16 v40 = v93;
            if (!(_WORD)v93) {
              goto LABEL_63;
            }
          }

          int v72 = __error();
          uint64_t v6 = sub_100068C8C(*v72);
          goto LABEL_138;
        }

LABEL_63:
        if (v34)
        {
          *(void *)a4 |= 0x20000uLL;
          unsigned __int16 v43 = v95 - a5;
          LOWORD(v93) = v95 - a5;
          if ((_WORD)v95 != (_WORD)a5)
          {
            do
            {
              if ((v43 & 0xFE00) != 0) {
                unint64_t v44 = 512LL;
              }
              else {
                unint64_t v44 = v43;
              }
              int v45 = sub_100065C5C(*(_DWORD *)(a1 + 500), v98, v44);
              if (v45 <= 0) {
                break;
              }
              int v46 = (unsigned __int16)v93;
              unsigned __int16 v43 = v93 - v45;
              LOWORD(v93) = v93 - v45;
            }

            while (v46 != (unsigned __int16)v45);
          }
        }

        break;
      }

      if (v21) {
        goto LABEL_157;
      }
      uint64_t v76 = *(void *)(a1 + 8);
      if ((v76 & 8) == 0 || (v76 & 0x100) == 0) {
        goto LABEL_157;
      }
LABEL_159:
      if (!*(void *)(a1 + 488)) {
        goto LABEL_187;
      }
      int v78 = 42;
      while (1)
      {
        int v26 = (*(uint64_t (**)(sockaddr *, void, void, unsigned __int16 *, uint64_t, unsigned int *))(a1 + 488))( v94,  *(void *)&v96[1],  v96[0],  a4,  a5,  &v95);
        if (v26 != 2) {
          break;
        }
        uint64_t v6 = 34LL;
        if (!--v78) {
          return v6;
        }
      }

      if (!v26 || v26 == 3)
      {
LABEL_187:
        uint64_t v6 = 0LL;
        *unsigned int v83 = v95;
        return v6;
      }

LABEL_133:
      if (v26 != 1) {
        return 34LL;
      }
      int v71 = *(_DWORD *)(a1 + 500);
      if ((v71 & 0x80000000) == 0)
      {
        sub_100065DD0(v71);
        *(_DWORD *)(a1 + 50__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = -1;
        *(_DWORD *)(a1 + 504) &= 0xFFFFFFFC;
      }

      int v88 = v24;
      int v18 = v90;
      uint64_t v6 = v86;
      int v19 = v87;
LABEL_19:
      ++v21;
      uint64_t v20 = *(int *)(a1 + 16);
    }

    while (v21 < v20);
    int v16 = *(_DWORD *)(a1 + 4);
    int v17 = v84;
LABEL_174:
    ++v18;
  }

  while (v18 < v16);
LABEL_178:
  int v80 = *(_DWORD *)(a1 + 500);
  if ((v80 & 0x80000000) == 0)
  {
    sub_100065DD0(v80);
    *(_DWORD *)(a1 + 50__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = -1;
    *(_DWORD *)(a1 + 504) &= 0xFFFFFFFC;
  }

  if (!v89)
  {
    if (v17) {
      *__error() = 2;
    }
    else {
      return 12LL;
    }
  }

  return v6;
}

uint64_t sub_10006F600(uint64_t a1)
{
  uint64_t result = *(unsigned int *)(a1 + 500);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = sub_100065DD0(result);
    *(_DWORD *)(a1 + 50__sprintf_chk(v20, 0, 0x32uLL, "/dev/bpf%d", 0) = -1;
    *(_DWORD *)(a1 + 504) &= 0xFFFFFFFC;
  }

  return result;
}

uint64_t sub_10006F63C( const void *a1, const void *a2, unsigned int a3, uint64_t a4, unsigned __int16 *a5, uint64_t a6, unsigned int *a7)
{
  unsigned int v31 = a6;
  sub_100059834();
  unsigned int v14 = malloc(0x230uLL);
  if (!v14) {
    return 1LL;
  }
  uint64_t v15 = (uint64_t)v14;
  memcpy(v14, a1, 0x230uLL);
  int v16 = (unsigned __int16 *)malloc(a3 + 1024);
  if (!v16)
  {
    free((void *)v15);
    return 1LL;
  }

  int v17 = v16;
  memcpy(v16, a2, a3);
  unsigned int v30 = a3;
  if (sub_10006ACC8((const char *)(a4 + 1025), "HMAC-MD5.SIG-ALG.REG.INT") == 1)
  {
    uint64_t v18 = sub_10005A68C((const char *)a4, 157, 0x4000, 255, *(void *)(a4 + 2056), *(unsigned int *)(a4 + 2064));
    if (v18)
    {
      uint64_t v19 = v18;
      *(_DWORD *)(v15 + 16) = 1;
      unsigned int v29 = 64;
      uint64_t v20 = sub_10006AE14(v17, &v30, a3 + 1024, 0, v18, 0LL, 0LL, v32, &v29, 0LL);
      if (!(_DWORD)v20)
      {
        unsigned int v23 = v30;
        unint64_t v24 = *(void *)(v15 + 8);
        if (v30 > 0x200) {
          int v25 = 1;
        }
        else {
          int v25 = (v24 >> 5) & 1;
        }
        uint64_t v26 = 32LL;
        if (v25) {
          uint64_t v26 = 8LL;
        }
        *(void *)(v15 + 8) = v24 | v26;
        uint64_t v21 = sub_10006EB04(v15, v17, v23, a5, a6, &v27);
        if ((_DWORD)v21) {
          goto LABEL_17;
        }
        do
        {
          unsigned int v31 = v27;
          uint64_t v20 = sub_10006B454( (unint64_t)a5,  &v31,  v19,  (uint64_t)v32,  v29,  0LL,  0LL,  &v28,  HIWORD(*(_DWORD *)(v15 + 8)) & 1);
          if ((_DWORD)v20) {
            break;
          }
          if (v25 || (*(void *)a5 & 0x20000) == 0)
          {
            sub_10005A1A4(v19);
            free((void *)v15);
            free(v17);
            uint64_t v21 = 0LL;
            *a7 = v31;
            return v21;
          }

          *(void *)(v15 + 8) &= ~0x20uLL;
          uint64_t v20 = sub_10006EB04(v15, v17, v30, a5, v31, &v27);
          int v25 = 1;
        }

        while (!(_DWORD)v20);
      }

      uint64_t v21 = v20;
LABEL_17:
      sub_10005A1A4(v19);
      free((void *)v15);
      free(v17);
      return v21;
    }
  }

  free((void *)v15);
  free(v17);
  return 61LL;
}

uint64_t sub_10006F8C0(unsigned int *a1, uint64_t a2)
{
  int v49 = a1 + 5;
  char v50 = 0LL;
  uint64_t v48 = a1 + 6;
  uint64_t v4 = &v50;
  while (2)
  {
    uint64_t v5 = 0LL;
    uint64_t v6 = a2;
    while (1)
    {
      __src[257] = *(_DWORD *)(v6 + 48);
      uint64_t v7 = sub_10006B9BC( (uint64_t)a1,  *(char **)(v6 + 40),  __src[257],  1,  (char *)__src,  0x401uLL,  &__src[258],  3,  &__src[261],  v4);
      if ((_DWORD)v7)
      {
        uint64_t v23 = v7;
        goto LABEL_22;
      }

      if (__src[261] < 1) {
        break;
      }
      if (!v5)
      {
        uint64_t v18 = malloc(0x440uLL);
        if (!v18)
        {
          uint64_t v23 = 1LL;
          goto LABEL_52;
        }

        uint64_t v5 = (uint64_t)v18;
        memcpy(v18, __src, 0x440uLL);
        *(_DWORD *)(v5 + 1048) = 0;
        uint64_t v15 = (void *)(v5 + 1064);
        *(_OWORD *)(v5 + 1056) = 0u;
LABEL_12:
        uint64_t v16 = 0LL;
        int v17 = (void *)(v5 + 1056);
        goto LABEL_13;
      }

      if (!sub_10006ACC8((const char *)__src, (const char *)v5) || __src[257] != *(_DWORD *)(v5 + 1028))
      {
        uint64_t v23 = 65LL;
        goto LABEL_46;
      }

      uint64_t v15 = (void *)(v5 + 1064);
      uint64_t v16 = *(void *)(v5 + 1064);
      if (!v16) {
        goto LABEL_12;
      }
      int v17 = (void *)(v16 + 24);
LABEL_13:
      *int v17 = v6;
      *(void *)(v6 + 16) = v16;
      *(void *)(v6 + 24) = 0LL;
      *(void *)(v5 + 1064) = v6;
      uint64_t v6 = *(void *)(v6 + 8);
      if (!v6)
      {
        uint64_t v19 = sub_10006E324(0, (const char *)v5, *(_DWORD *)(v5 + 1028), 6, 0);
        if (v19)
        {
          uint64_t v20 = *(void *)(v5 + 1056);
          uint64_t v21 = (void *)(v20 + 16);
          if (!v20) {
            uint64_t v21 = v15;
          }
          *uint64_t v21 = v19;
          void v19[2] = 0LL;
          v19[3] = v20;
          *(void *)(v5 + 1056) = v19;
          *(_DWORD *)(v5 + 1048) |= 1u;
          unsigned int v53 = 1024;
          uint64_t v22 = sub_10006D170((uint64_t)a1, (uint64_t)v19, v56, &v53);
          if ((_DWORD)v22)
          {
            uint64_t v23 = v22;
          }

          else
          {
            uint64_t v24 = a1[4];
            int v25 = *(_DWORD *)(v5 + 1044);
            if (v25 >= 1)
            {
              uint64_t v26 = (unsigned int *)(v5 + 1032);
              unsigned int v27 = v48;
              uint64_t v28 = *(unsigned int *)(v5 + 1044);
              do
              {
                *(void *)(v27 - 1) = 0LL;
                *(void *)(v27 + 1) = 0LL;
                *((_BYTE *)v27 - 3) = 2;
                *((_WORD *)v27 - 1) = 13568;
                unsigned int v29 = *v26++;
                unsigned int *v27 = v29;
                v27 += 4;
                --v28;
              }

              while (v28);
            }

            a1[4] = v25;
            unsigned int v51 = 0LL;
            uint64_t v30 = sub_10003C14C(&v51, v5, (uint64_t)v50);
            if ((_DWORD)v30 == 47 || (_DWORD)v30 == 23)
            {
              uint64_t v23 = sub_10006EB04((uint64_t)a1, v56, v53, &v57, 512LL, &v52);
            }

            else
            {
              uint64_t v23 = v30;
              if (!(_DWORD)v30)
              {
                uint64_t v23 = sub_10006F63C(a1, v56, v53, (uint64_t)v51, &v57, 512LL, &v52);
                sub_10003C28C(&v51, v32, v33, v34, v35, v36, v37, v38);
              }
            }

            if (!(_DWORD)v23)
            {
              uint64_t v39 = sub_100068C6C(v58 & 0xF);
              uint64_t v23 = v39;
              if (v50)
              {
                if ((_DWORD)v39 == 60) {
                  sub_10003C8DC(&v50, v40, v41, v42, v43, v44, v45, v46);
                }
              }
            }

            a1[4] = v24;
          }
        }

        else
        {
          uint64_t v23 = 34LL;
        }

        goto LABEL_46;
      }
    }

    uint64_t v23 = 59LL;
LABEL_22:
    if (!v5)
    {
      if (!v4) {
        break;
      }
      goto LABEL_49;
    }

void sub_10006FC14( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_10006FC2C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}