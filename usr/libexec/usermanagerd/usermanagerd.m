id sub_10000510C(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  v1 = objc_opt_new(*(void *)(a1 + 32));
  v2 = (void *)qword_1000DB9C8;
  qword_1000DB9C8 = v1;

  return [(id)qword_1000DB9C8 setSwitchState:0];
}

void sub_100005184(id a1)
{
  uint64_t v1 = objc_claimAutoreleasedReturnValue( +[NSXPCInterface interfaceWithProtocol:]( &OBJC_CLASS___NSXPCInterface,  "interfaceWithProtocol:",  &OBJC_PROTOCOL___RDServer));
  v2 = (void *)qword_1000DB9D8;
  qword_1000DB9D8 = v1;
}

void sub_1000051F8(id a1)
{
  uint64_t v1 = objc_claimAutoreleasedReturnValue( +[NSXPCInterface interfaceWithProtocol:]( &OBJC_CLASS___NSXPCInterface,  "interfaceWithProtocol:",  &OBJC_PROTOCOL___BDKeybagd));
  v2 = (void *)qword_1000DB9E8;
  qword_1000DB9E8 = v1;
}

void sub_1000053A0(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) pid];
  id v7 = (id)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v2));
  v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) pidsToClients]);
  v4 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v7]);

  if (v4)
  {
    NSLog(@"We already have a client for pid: %d", v2);
  }

  else
  {
    uint64_t v5 = *(void *)(a1 + 32);
    v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) pidsToClients]);
    [v6 setObject:v5 forKeyedSubscript:v7];
  }
}

void sub_1000054D8(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) pid];
  v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) _clientForPID:v2]);

  if (v3)
  {
    if ([*(id *)(a1 + 32) hasUserSwitchTasks])
    {
      if (qword_1000DBA10 != -1) {
        dispatch_once(&qword_1000DBA10, &stru_1000CD208);
      }
      v4 = (os_log_s *)(id)qword_1000DBA08;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = 0LL;
        LODWORD(v5) = sub_100053B4C(1);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v5 = v5;
        }
        else {
          uint64_t v5 = v5 & 0xFFFFFFFE;
        }
        if ((_DWORD)v5)
        {
          v6 = *(void **)(a1 + 32);
          id v7 = v4;
          v8 = (void *)objc_claimAutoreleasedReturnValue([v6 userSwitchTasks]);
          int v13 = 138412546;
          v14 = v8;
          __int16 v15 = 1024;
          int v16 = (int)v2;
          v9 = (char *)_os_log_send_and_compose_impl( v5,  &v12,  0LL,  0LL,  &_mh_execute_header,  v7,  0LL,  "Removing removeUserSwitch Tasks:%@ as Client Pid:%d is exiting",  &v13,  18);

          if (v9) {
            sub_100053B7C(v9);
          }
        }

        else
        {
          v9 = 0LL;
        }

        free(v9);
      }
    }

    v10 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) pidsToClients]);
    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v2));
    [v10 setObject:0 forKeyedSubscript:v11];
  }
}

void sub_10000576C(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) pid];
  id v7 = (id)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v2));
  v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) pidsToClients]);
  v4 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v7]);

  if (v4)
  {
    NSLog(@"We already have a client for pid: %d", v2);
  }

  else
  {
    uint64_t v5 = *(void *)(a1 + 32);
    v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) pidsToClients]);
    [v6 setObject:v5 forKeyedSubscript:v7];
  }
}

void sub_1000058A4(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) pid];
  v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) _clientForPID:v2]);

  if (v3)
  {
    id v5 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) pidsToClients]);
    v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v2));
    [v5 setObject:0 forKeyedSubscript:v4];
  }

LABEL_11:
  return v3;
}

  return v3;
}

  return v8;
}

  return v15;
}

  return v11;
}

void sub_100005E10(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _clientForPID:*(unsigned int *)(a1 + 48)]);
  uint64_t v3 = sub_100018F4C(qword_1000DBD40);
  v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  id v5 = (void *)objc_claimAutoreleasedReturnValue([v4 pathForPID:*(unsigned int *)(a1 + 48) error:0]);

  if (qword_1000DBA20 != -1) {
    dispatch_once(&qword_1000DBA20, &stru_1000CD228);
  }
  v6 = (os_log_s *)(id)qword_1000DBA18;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v22 = 0LL;
    unsigned int v7 = sub_100053B4C(0);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = v7 & 0xFFFFFFFE;
    }
    if ((_DWORD)v8)
    {
      int v9 = *(_DWORD *)(a1 + 48);
      LODWORD(v19) = 67109378;
      HIDWORD(v19) = v9;
      __int16 v20 = 2114;
      v21 = v5;
      v10 = (const char *)_os_log_send_and_compose_impl( v8,  &v22,  0LL,  0LL,  &_mh_execute_header,  v6,  0LL,  "UserSwitch Stake Holder Registration for pid:(%d,%{public}@)",  &v19,  18);
      v11 = (char *)v10;
      if (v10) {
        sub_100053B7C(v10);
      }
    }

    else
    {
      v11 = 0LL;
    }

    free(v11);
  }

  if (!v2) {
    goto LABEL_29;
  }
  if ([*(id *)(a1 + 32) switchState]) {
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  16LL,  0LL));
  }
  else {
    uint64_t v12 = 0LL;
  }
  (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
  if (!v12)
  {
    [v2 setStakeholderIsRegistered:1];
    [v2 setSwitchStakeHolderKind:0];
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    int v13 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = 0LL;
      unsigned int v14 = sub_100053B4C(1);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v15 = v14;
      }
      else {
        uint64_t v15 = v14 & 0xFFFFFFFE;
      }
      if ((_DWORD)v15)
      {
        int v16 = *(_DWORD *)(a1 + 48);
        LODWORD(v22) = 67109120;
        HIDWORD(v22) = v16;
        v17 = (const char *)_os_log_send_and_compose_impl( v15,  &v19,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "UserSwitch Stake Holder registration(pid:%d) - DONE",  &v22);
        v18 = (char *)v17;
        if (v17) {
          sub_100053B7C(v17);
        }
      }

      else
      {
        v18 = 0LL;
      }

      free(v18);
    }

LABEL_29:
    uint64_t v12 = 0LL;
  }
}

void sub_100006190(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _clientForPID:*(unsigned int *)(a1 + 48)]);
  if (v2)
  {
    uint64_t v3 = sub_100018F4C(qword_1000DBD40);
    v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
    id v5 = (void *)objc_claimAutoreleasedReturnValue([v4 pathForPID:*(unsigned int *)(a1 + 48) error:0]);

    if (qword_1000DBA20 != -1) {
      dispatch_once(&qword_1000DBA20, &stru_1000CD228);
    }
    v6 = (os_log_s *)(id)qword_1000DBA18;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v28 = 0LL;
      unsigned int v7 = sub_100053B4C(0);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v8 = v7;
      }
      else {
        uint64_t v8 = v7 & 0xFFFFFFFE;
      }
      if ((_DWORD)v8)
      {
        int v9 = *(_DWORD *)(a1 + 48);
        LODWORD(v25) = 67109378;
        HIDWORD(v25) = v9;
        __int16 v26 = 2114;
        v27 = v5;
        v10 = (const char *)_os_log_send_and_compose_impl( v8,  &v28,  0LL,  0LL,  &_mh_execute_header,  v6,  0LL,  "Critical User Switch Stake Holder registration for pid:(%d,%{public}@)",  &v25,  18);
        v11 = (char *)v10;
        if (v10) {
          sub_100053B7C(v10);
        }
      }

      else
      {
        v11 = 0LL;
      }

      free(v11);
    }

    if (![*(id *)(a1 + 32) switchState] || dword_1000DBCF0 == 3)
    {
      [v2 setCriticalStakeHolder:1];
      [v2 setSwitchStakeHolderKind:1];
      v18 = 0LL;
    }

    else
    {
      if (qword_1000DBA10 != -1) {
        dispatch_once(&qword_1000DBA10, &stru_1000CD208);
      }
      uint64_t v12 = (os_log_s *)(id)qword_1000DBA08;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v25 = 0LL;
        LODWORD(v13) = sub_100053B4C(1);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v13 = v13;
        }
        else {
          uint64_t v13 = v13 & 0xFFFFFFFE;
        }
        if ((_DWORD)v13)
        {
          unsigned int v14 = *(void **)(a1 + 32);
          uint64_t v15 = v12;
          unsigned int v16 = [v14 switchState];
          LODWORD(v28) = 67109120;
          HIDWORD(v28) = v16;
          v17 = (char *)_os_log_send_and_compose_impl( v13,  &v25,  0LL,  0LL,  &_mh_execute_header,  v15,  0LL,  "FAILED TO register Critical User Switch Stake Holder: Switchstate:%d",  &v28);

          if (v17) {
            sub_100053B7C(v17);
          }
        }

        else
        {
          v17 = 0LL;
        }

        free(v17);
      }

      v18 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  16LL,  0LL));
    }

    (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
    if (!v18)
    {
      [v2 setStakeholderIsRegistered:1];
      if (qword_1000DBA10 != -1) {
        dispatch_once(&qword_1000DBA10, &stru_1000CD208);
      }
      uint64_t v19 = (os_log_s *)(id)qword_1000DBA08;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v25 = 0LL;
        unsigned int v20 = sub_100053B4C(1);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v21 = v20;
        }
        else {
          uint64_t v21 = v20 & 0xFFFFFFFE;
        }
        if ((_DWORD)v21)
        {
          int v22 = *(_DWORD *)(a1 + 48);
          LODWORD(v28) = 67109120;
          HIDWORD(v28) = v22;
          v23 = (const char *)_os_log_send_and_compose_impl( v21,  &v25,  0LL,  0LL,  &_mh_execute_header,  v19,  0LL,  "Critical UserSwitch Stake Holder registration(pid:%d)-DONE",  &v28);
          v24 = (char *)v23;
          if (v23) {
            sub_100053B7C(v23);
          }
        }

        else
        {
          v24 = 0LL;
        }

        free(v24);
      }
    }
  }
}

void sub_10000662C(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _clientForPID:*(unsigned int *)(a1 + 48)]);
  if (!v2) {
    goto LABEL_35;
  }
  uint64_t v3 = sub_100018F4C(qword_1000DBD40);
  v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  id v5 = (void *)objc_claimAutoreleasedReturnValue([v4 pathForPID:*(unsigned int *)(a1 + 48) error:0]);

  if (qword_1000DBA20 != -1) {
    dispatch_once(&qword_1000DBA20, &stru_1000CD228);
  }
  v6 = (os_log_s *)(id)qword_1000DBA18;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v26 = 0LL;
    unsigned int v7 = sub_100053B4C(0);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = v7 & 0xFFFFFFFE;
    }
    if ((_DWORD)v8)
    {
      int v9 = *(_DWORD *)(a1 + 48);
      LODWORD(v23) = 67109378;
      HIDWORD(v23) = v9;
      __int16 v24 = 2114;
      uint64_t v25 = v5;
      v10 = (const char *)_os_log_send_and_compose_impl( v8,  &v26,  0LL,  0LL,  &_mh_execute_header,  v6,  0LL,  "BubblePop Stake Holder registration started for pid:(%d,%{public}@)",  &v23,  18);
      v11 = (char *)v10;
      if (v10) {
        sub_100053B7C(v10);
      }
    }

    else
    {
      v11 = 0LL;
    }

    free(v11);
  }

  if ([v2 hasEntitlement:@"com.apple.mobile.keybagd.UserManager.bubblepop"])
  {
    if (![*(id *)(a1 + 32) switchState])
    {
      uint64_t v13 = 0LL;
      goto LABEL_18;
    }

    uint64_t v12 = 16LL;
  }

  else
  {
    uint64_t v12 = 1LL;
  }

  uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  v12,  0LL));
LABEL_18:
  (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
  if (!v13)
  {
    [v2 setStakeholderIsRegistered:1];
    [v2 setBubblePopstakeholderIsRegistered:1];
    [v2 setSwitchStakeHolderKind:3];
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    unsigned int v14 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v23 = 0LL;
      unsigned int v15 = sub_100053B4C(1);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v16 = v15;
      }
      else {
        uint64_t v16 = v15 & 0xFFFFFFFE;
      }
      if ((_DWORD)v16)
      {
        int v17 = *(_DWORD *)(a1 + 48);
        LODWORD(v26) = 67109120;
        HIDWORD(v26) = v17;
        v18 = (const char *)_os_log_send_and_compose_impl( v16,  &v23,  0LL,  0LL,  &_mh_execute_header,  v14,  0LL,  "BubblePop Stake Holder registration(pid:%d)",  &v26);
        uint64_t v19 = (char *)v18;
        if (v18) {
          sub_100053B7C(v18);
        }
      }

      else
      {
        uint64_t v19 = 0LL;
      }

      free(v19);
    }

    unsigned int v20 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) bubbleStakeHolder]);
    uint64_t v21 = *(void **)(a1 + 32);
    if (v20)
    {
      int v22 = (void *)objc_claimAutoreleasedReturnValue([v21 bubbleStakeHolder]);
      [v22 bubbleShouldPop];
    }

    else
    {
      [v21 _broadcastBubbleDidPop];
    }
  }

LABEL_35:
}

void sub_100006CBC(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _clientForPID:*(unsigned int *)(a1 + 56)]);
  if (v2)
  {
    uint64_t v3 = sub_100018F4C(qword_1000DBD40);
    v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
    id v5 = (void *)objc_claimAutoreleasedReturnValue([v4 pathForPID:*(unsigned int *)(a1 + 56) error:0]);

    if (qword_1000DBA20 != -1) {
      dispatch_once(&qword_1000DBA20, &stru_1000CD228);
    }
    v6 = (os_log_s *)(id)qword_1000DBA18;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v39 = 0LL;
      unsigned int v7 = sub_100053B4C(0);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v8 = v7;
      }
      else {
        uint64_t v8 = v7 & 0xFFFFFFFE;
      }
      if ((_DWORD)v8)
      {
        int v9 = *(_DWORD *)(a1 + 56);
        uint64_t v10 = *(void *)(a1 + 40);
        LODWORD(v34) = 67109634;
        HIDWORD(v34) = v9;
        __int16 v35 = 2114;
        v36 = v5;
        __int16 v37 = 2114;
        uint64_t v38 = v10;
        v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v39,  0LL,  0LL,  &_mh_execute_header,  v6,  0LL,  "Registering Sync Stake Holder:(%d, %{public}@) machservice is %{public}@",  &v34,  28);
        uint64_t v12 = (char *)v11;
        if (v11) {
          sub_100053B7C(v11);
        }
      }

      else
      {
        uint64_t v12 = 0LL;
      }

      free(v12);
    }

    if (([v2 hasEntitlement:@"com.apple.mobile.keybagd.UserManager.sync"] & 1) == 0)
    {
      NSErrorDomain v13 = NSPOSIXErrorDomain;
      uint64_t v14 = 1LL;
      goto LABEL_17;
    }

    if ([*(id *)(a1 + 32) switchState])
    {
LABEL_15:
      NSErrorDomain v13 = NSPOSIXErrorDomain;
      uint64_t v14 = 16LL;
LABEL_17:
      unsigned int v15 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  v13,  v14,  0LL));
LABEL_18:
      (*(void (**)(void))(*(void *)(a1 + 48) + 16LL))();

      goto LABEL_19;
    }

    uint64_t v16 = sub_100018E80(qword_1000DBD40);
    int v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
    if (sub_100019ADC((uint64_t)v17))
    {
      uint64_t v18 = sub_100018E80(qword_1000DBD40);
      uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(v18);
      if (sub_100019B60((uint64_t)v19) == 502)
      {

LABEL_34:
        [v2 setMachServiceName:*(void *)(a1 + 40)];
        sub_100034290(*(const __CFString **)(a1 + 40));
        [v2 setStakeholderIsRegistered:1];
        [v2 setSwitchStakeHolderKind:2];
        if (qword_1000DBA10 != -1) {
          dispatch_once(&qword_1000DBA10, &stru_1000CD208);
        }
        v27 = (os_log_s *)(id)qword_1000DBA08;
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v34 = 0LL;
          unsigned int v28 = sub_100053B4C(1);
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v29 = v28;
          }
          else {
            uint64_t v29 = v28 & 0xFFFFFFFE;
          }
          if ((_DWORD)v29)
          {
            int v30 = *(_DWORD *)(a1 + 56);
            LODWORD(v39) = 67109120;
            HIDWORD(v39) = v30;
            v31 = (const char *)_os_log_send_and_compose_impl( v29,  &v34,  0LL,  0LL,  &_mh_execute_header,  v27,  0LL,  "Sync Stake Holder registration done(pid:%d)",  &v39);
            v32 = (char *)v31;
            if (v31) {
              sub_100053B7C(v31);
            }
          }

          else
          {
            v32 = 0LL;
          }

          free(v32);
        }

        unsigned int v15 = 0LL;
        goto LABEL_18;
      }

      unsigned __int8 v26 = [*(id *)(a1 + 32) inLoginSession];

      if ((v26 & 1) == 0) {
        goto LABEL_34;
      }
    }

    else
    {
      unsigned int v20 = [*(id *)(a1 + 32) inLoginSession];

      if (!v20) {
        goto LABEL_34;
      }
    }

    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    uint64_t v21 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v34 = 0LL;
      unsigned int v22 = sub_100053B4C(1);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v23 = v22;
      }
      else {
        uint64_t v23 = v22 & 0xFFFFFFFE;
      }
      if ((_DWORD)v23)
      {
        LOWORD(v39) = 0;
        LODWORD(v33) = 2;
        __int16 v24 = (const char *)_os_log_send_and_compose_impl( v23,  &v34,  0LL,  0LL,  &_mh_execute_header,  v21,  0LL,  "Denying registration since user is in Login Session",  &v39,  v33);
        uint64_t v25 = (char *)v24;
        if (v24) {
          sub_100053B7C(v24);
        }
      }

      else
      {
        uint64_t v25 = 0LL;
      }

      free(v25);
    }

    goto LABEL_15;
  }

LABEL_19:
}

        sub_100053B7C((const char *)v9);
        goto LABEL_21;
      }

  NSErrorDomain v13 = 70;
LABEL_13:
  return v12;
}

  if ((_DWORD)v6) {
    int v17 = 70;
  }
  else {
    int v17 = 10;
  }
  if (v17 >= byte_1000DB179 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315650;
    unsigned int v22 = "ACMLib";
    uint64_t v23 = 2080;
    __int16 v24 = "ACMParseAclAndCopyConstraintCharacteristics";
    uint64_t v25 = 2048;
    unsigned __int8 v26 = (int)v6;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning, err = %ld.\n",  buf,  0x20u);
  }

  return v6;
}

void sub_100007194(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _clientForPID:*(unsigned int *)(a1 + 48)]);
  uint64_t v3 = sub_100018F4C(qword_1000DBD40);
  v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  id v5 = (void *)objc_claimAutoreleasedReturnValue([v4 pathForPID:*(unsigned int *)(a1 + 48) error:0]);

  if (qword_1000DBA20 != -1) {
    dispatch_once(&qword_1000DBA20, &stru_1000CD228);
  }
  v6 = (os_log_s *)(id)qword_1000DBA18;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v40 = 0LL;
    unsigned int v7 = sub_100053B4C(0);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = v7 & 0xFFFFFFFE;
    }
    if ((_DWORD)v8)
    {
      int v9 = *(_DWORD *)(a1 + 48);
      LODWORD(v37) = 67109378;
      HIDWORD(v37) = v9;
      __int16 v38 = 2114;
      uint64_t v39 = v5;
      uint64_t v10 = (const char *)_os_log_send_and_compose_impl( v8,  &v40,  0LL,  0LL,  &_mh_execute_header,  v6,  0LL,  "Unregister Stakeholder (Pid:%d,%{public}@)",  &v37,  18);
      v11 = (char *)v10;
      if (v10) {
        sub_100053B7C(v10);
      }
    }

    else
    {
      v11 = 0LL;
    }

    free(v11);
  }

  if (v2)
  {
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v2 machServiceName]);

    if (v12)
    {
      if (qword_1000DBA10 != -1) {
        dispatch_once(&qword_1000DBA10, &stru_1000CD208);
      }
      NSErrorDomain v13 = (os_log_s *)(id)qword_1000DBA08;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v37 = 0LL;
        unsigned int v14 = sub_100053B4C(1);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v15 = v14;
        }
        else {
          uint64_t v15 = v14 & 0xFFFFFFFE;
        }
        if ((_DWORD)v15)
        {
          LOWORD(v40) = 0;
          LODWORD(v36) = 2;
          uint64_t v16 = (const char *)_os_log_send_and_compose_impl( v15,  &v37,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "Unregister Sync Stake holder",  &v40,  v36);
          int v17 = (char *)v16;
          if (v16) {
            sub_100053B7C(v16);
          }
        }

        else
        {
          int v17 = 0LL;
        }

        free(v17);
      }

      if ((*(void *)(a1 + 40) | 2LL) == 2)
      {
        uint64_t v18 = (__CFString *)objc_claimAutoreleasedReturnValue([v2 machServiceName]);
        sub_100034D1C(v18);

        uint64_t v12 = 0LL;
      }

      else
      {
        if (qword_1000DBA10 != -1) {
          dispatch_once(&qword_1000DBA10, &stru_1000CD208);
        }
        uint64_t v19 = (os_log_s *)(id)qword_1000DBA08;
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v37 = 0LL;
          unsigned int v20 = sub_100053B4C(1);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v21 = v20;
          }
          else {
            uint64_t v21 = v20 & 0xFFFFFFFE;
          }
          if ((_DWORD)v21)
          {
            LOWORD(v40) = 0;
            LODWORD(v36) = 2;
            unsigned int v22 = (const char *)_os_log_send_and_compose_impl( v21,  &v37,  0LL,  0LL,  &_mh_execute_header,  v19,  0LL,  "Unregister  Switch Stake holder",  &v40,  v36);
            uint64_t v23 = (char *)v22;
            if (v22) {
              sub_100053B7C(v22);
            }
          }

          else
          {
            uint64_t v23 = 0LL;
          }

          free(v23);
        }

        __int16 v24 = (__CFString *)objc_claimAutoreleasedReturnValue([v2 machServiceName]);
        sub_100034290(v24);

        uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) fetchUserSyncTaskList]);
        if ([v12 count]) {
          sub_100035328(v12);
        }
      }
    }

    [v2 setStakeholderIsRegistered:0];
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    uint64_t v25 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v37 = 0LL;
      unsigned int v26 = sub_100053B4C(1);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v27 = v26;
      }
      else {
        uint64_t v27 = v26 & 0xFFFFFFFE;
      }
      if ((_DWORD)v27)
      {
        LOWORD(v40) = 0;
        LODWORD(v36) = 2;
        unsigned int v28 = (const char *)_os_log_send_and_compose_impl( v27,  &v37,  0LL,  0LL,  &_mh_execute_header,  v25,  0LL,  "checking if we need to switch(unregister)-> _checkIfWeShouldSwitchUser..",  &v40,  v36);
        uint64_t v29 = (char *)v28;
        if (v28) {
          sub_100053B7C(v28);
        }
      }

      else
      {
        uint64_t v29 = 0LL;
      }

      free(v29);
    }

    [*(id *)(a1 + 32) _checkIfWeShouldSwitchUser:0];
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    int v30 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v37 = 0LL;
      unsigned int v31 = sub_100053B4C(1);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v32 = v31;
      }
      else {
        uint64_t v32 = v31 & 0xFFFFFFFE;
      }
      if ((_DWORD)v32)
      {
        int v33 = *(_DWORD *)(a1 + 48);
        LODWORD(v40) = 67109120;
        HIDWORD(v40) = v33;
        uint64_t v34 = (const char *)_os_log_send_and_compose_impl( v32,  &v37,  0LL,  0LL,  &_mh_execute_header,  v30,  0LL,  "Unregister Stakeholder(pid:%d)-DONE",  &v40);
        __int16 v35 = (char *)v34;
        if (v34) {
          sub_100053B7C(v34);
        }
      }

      else
      {
        __int16 v35 = 0LL;
      }

      free(v35);
    }
  }
}

void sub_10000775C(id a1)
{
  uint64_t v1 = (void *)qword_1000DB9F8;
  qword_1000DB9F8 = (uint64_t)&off_1000D10D8;
}

void sub_1000078AC(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _clientForPID:*(unsigned int *)(a1 + 80)]);
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  p_name = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
  v4 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v67 = 0LL;
    unsigned int v5 = sub_100053B4C(1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = v5 & 0xFFFFFFFE;
    }
    if ((_DWORD)v6)
    {
      LOWORD(v65[0]) = 0;
      unsigned int v7 = (const char *)_os_log_send_and_compose_impl( v6,  &v67,  0LL,  0LL,  &_mh_execute_header,  v4,  0LL,  "in SwitchtoUser",  v65,  2);
      uint64_t v8 = (char *)v7;
      if (v7) {
        sub_100053B7C(v7);
      }
    }

    else
    {
      uint64_t v8 = 0LL;
    }

    free(v8);
  }

  if (([v2 hasEntitlement:@"com.apple.mkb.usersession.switch"] & 1) != 0
    || (_os_feature_enabled_impl("UserManagement", "LocalUserEnrollment") & 1) != 0)
  {
    int v9 = 0LL;
  }

  else
  {
    int v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  1LL,  0LL));
  }

  if ([*(id *)(a1 + 32) inLogoutProcess])
  {
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    uint64_t v10 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v67 = 0LL;
      unsigned int v11 = sub_100053B4C(1);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v12 = v11;
      }
      else {
        uint64_t v12 = v11 & 0xFFFFFFFE;
      }
      if ((_DWORD)v12)
      {
        LOWORD(v65[0]) = 0;
        LODWORD(v60) = 2;
        NSErrorDomain v13 = (const char *)_os_log_send_and_compose_impl( v12,  &v67,  0LL,  0LL,  &_mh_execute_header,  v10,  0LL,  "Already in SwitchtoUser, ignore current one",  v65,  v60);
        unsigned int v14 = (char *)v13;
        if (v13) {
          sub_100053B7C(v13);
        }
      }

      else
      {
        unsigned int v14 = 0LL;
      }

      free(v14);
    }

    uint64_t v20 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  16LL,  0LL));
    int v9 = (void *)v20;
    goto LABEL_39;
  }

  if (!sub_10001C3D4())
  {
LABEL_39:
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    uint64_t v21 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      v65[0] = 0LL;
      LODWORD(v22) = sub_100053B4C(1);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v22 = v22;
      }
      else {
        uint64_t v22 = v22 & 0xFFFFFFFE;
      }
      if ((_DWORD)v22)
      {
        uint64_t v23 = v21;
        int v24 = sub_10001D0C0();
        LODWORD(v67) = 67109376;
        HIDWORD(v67) = v24;
        __int16 v68 = 1024;
        int v69 = dword_1000DBCF0;
        uint64_t v25 = (char *)_os_log_send_and_compose_impl( v22,  v65,  0LL,  0LL,  &_mh_execute_header,  v23,  0LL,  "SwitchUser: foregorundID:%d, sessionType:%d",  &v67,  14);

        if (v25) {
          sub_100053B7C(v25);
        }
      }

      else
      {
        uint64_t v25 = 0LL;
      }

      free(v25);
    }

    int v26 = sub_10001D0C0();
    int v27 = sub_100083C6C(*(const __CFDictionary **)(a1 + 40), kUMUserSessionIDKey);
    unsigned int v28 = *(void (**)(void))(*(void *)(a1 + 72) + 16LL);
    if (v26 != v27 || dword_1000DBCF0 == 1)
    {
      v28();
      if (!v9)
      {
        if (*(void *)(a1 + 48))
        {
          if (qword_1000DBA10 != -1) {
            dispatch_once(&qword_1000DBA10, &stru_1000CD208);
          }
          uint64_t v29 = (os_log_s *)(id)qword_1000DBA08;
          if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v67 = 0LL;
            unsigned int v30 = sub_100053B4C(1);
            if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v31 = v30;
            }
            else {
              uint64_t v31 = v30 & 0xFFFFFFFE;
            }
            if ((_DWORD)v31)
            {
              LOWORD(v65[0]) = 0;
              LODWORD(v60) = 2;
              uint64_t v32 = (const char *)_os_log_send_and_compose_impl( v31,  &v67,  0LL,  0LL,  &_mh_execute_header,  v29,  0LL,  "Need to set user preferences",  v65,  v60);
              int v33 = (char *)v32;
              if (v32) {
                sub_100053B7C(v32);
              }
            }

            else
            {
              int v33 = 0LL;
            }

            free(v33);
          }

          __int16 v35 = objc_opt_new(&OBJC_CLASS___NSMutableDictionary);
          uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _allowlistedPreferencesKeys]);
          __int128 v61 = 0u;
          __int128 v62 = 0u;
          __int128 v63 = 0u;
          __int128 v64 = 0u;
          id v37 = *(id *)(a1 + 48);
          id v38 = [v37 countByEnumeratingWithState:&v61 objects:v66 count:16];
          if (v38)
          {
            id v39 = v38;
            uint64_t v40 = *(void *)v62;
            do
            {
              for (i = 0LL; i != v39; i = (char *)i + 1)
              {
                if (*(void *)v62 != v40) {
                  objc_enumerationMutation(v37);
                }
                uint64_t v42 = *(void *)(*((void *)&v61 + 1) + 8LL * (void)i);
                if ([v36 containsObject:v42])
                {
                  v43 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) objectForKeyedSubscript:v42]);
                  -[NSMutableDictionary setObject:forKeyedSubscript:](v35, "setObject:forKeyedSubscript:", v43, v42);
                }
              }

              id v39 = [v37 countByEnumeratingWithState:&v61 objects:v66 count:16];
            }

            while (v39);
          }

          if (-[NSMutableDictionary count](v35, "count"))
          {
            v44 = sub_100021990(*(const __CFDictionary **)(a1 + 40));
            v45 = (__CFString *)objc_claimAutoreleasedReturnValue(v44);
            if (v45)
            {
              _CFPreferencesWriteUserPreferencesWithCorrectOwner();
              CFPreferencesSetMultiple( (CFDictionaryRef)v35,  0LL,  kCFPreferencesAnyApplication,  v45,  kCFPreferencesAnyHost);
              p_name = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
            }

            else
            {
              p_name = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
              if (qword_1000DBA10 != -1) {
                dispatch_once(&qword_1000DBA10, &stru_1000CD208);
              }
              v50 = (os_log_s *)(id)qword_1000DBA08;
              if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v67 = 0LL;
                unsigned int v51 = sub_100053B4C(1);
                if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT)) {
                  uint64_t v52 = v51;
                }
                else {
                  uint64_t v52 = v51 & 0xFFFFFFFE;
                }
                if ((_DWORD)v52)
                {
                  LOWORD(v65[0]) = 0;
                  LODWORD(v60) = 2;
                  v53 = (const char *)_os_log_send_and_compose_impl( v52,  &v67,  0LL,  0LL,  &_mh_execute_header,  v50,  0LL,  "Could not get name for user. Not setting preferences.",  v65,  v60,  (void)v61);
                  v54 = (char *)v53;
                  if (v53) {
                    sub_100053B7C(v53);
                  }
                }

                else
                {
                  v54 = 0LL;
                }

                free(v54);
              }
            }
          }

          else
          {
            p_name = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
            if (qword_1000DBA10 != -1) {
              dispatch_once(&qword_1000DBA10, &stru_1000CD208);
            }
            v45 = (__CFString *)(id)qword_1000DBA08;
            if (os_log_type_enabled((os_log_t)v45, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v67 = 0LL;
              unsigned int v46 = sub_100053B4C(1);
              if (os_log_type_enabled((os_log_t)v45, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v47 = v46;
              }
              else {
                uint64_t v47 = v46 & 0xFFFFFFFE;
              }
              if ((_DWORD)v47)
              {
                LOWORD(v65[0]) = 0;
                LODWORD(v60) = 2;
                v48 = (const char *)_os_log_send_and_compose_impl( v47,  &v67,  0LL,  0LL,  &_mh_execute_header,  v45,  0LL,  "None of the preferences were allowed. Not setting preferences.",  v65,  v60,  (void)v61);
                v49 = (char *)v48;
                if (v48) {
                  sub_100053B7C(v48);
                }
              }

              else
              {
                v49 = 0LL;
              }

              free(v49);
            }
          }
        }

        if (qword_1000DBA10 != -1) {
          dispatch_once(&qword_1000DBA10, &stru_1000CD208);
        }
        v55 = p_name[321];
        if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v67 = 0LL;
          unsigned int v56 = sub_100053B4C(1);
          if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v57 = v56;
          }
          else {
            uint64_t v57 = v56 & 0xFFFFFFFE;
          }
          if ((_DWORD)v57)
          {
            LOWORD(v65[0]) = 0;
            LODWORD(v60) = 2;
            v58 = (const char *)_os_log_send_and_compose_impl( v57,  &v67,  0LL,  0LL,  &_mh_execute_header,  v55,  0LL,  "Moving Along with SwitchtoUser",  v65,  v60);
            v59 = (char *)v58;
            if (v58) {
              sub_100053B7C(v58);
            }
          }

          else
          {
            v59 = 0LL;
          }

          free(v59);
        }

        sub_10002E334(*(const __CFDictionary **)(a1 + 40), *(void *)(a1 + 56), *(const __CFData **)(a1 + 64));
        int v9 = 0LL;
      }
    }

    else
    {
      v28();
    }

    goto LABEL_117;
  }

  if (qword_1000DBA20 != -1) {
    dispatch_once(&qword_1000DBA20, &stru_1000CD228);
  }
  uint64_t v15 = (os_log_s *)(id)qword_1000DBA18;
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    uint64_t v67 = 0LL;
    unsigned int v16 = sub_100053B4C(0);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      uint64_t v17 = v16;
    }
    else {
      uint64_t v17 = v16 & 0xFFFFFFFE;
    }
    if ((_DWORD)v17)
    {
      LOWORD(v65[0]) = 0;
      LODWORD(v60) = 2;
      uint64_t v18 = (const char *)_os_log_send_and_compose_impl( v17,  &v67,  0LL,  0LL,  &_mh_execute_header,  v15,  16LL,  "Failed to switch user: user switch already in progress",  v65,  v60);
      uint64_t v19 = (char *)v18;
      if (v18) {
        sub_100053B7C(v18);
      }
    }

    else
    {
      uint64_t v19 = 0LL;
    }

    free(v19);
  }

  uint64_t v34 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  37LL,  0LL));
  int v9 = (void *)v34;
LABEL_117:
}

void sub_1000082F4(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _clientForPID:*(unsigned int *)(a1 + 48)]);
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  uint64_t v3 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v29 = 0LL;
    unsigned int v4 = sub_100053B4C(1);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = v4 & 0xFFFFFFFE;
    }
    if ((_DWORD)v5)
    {
      LOWORD(v30[0]) = 0;
      uint64_t v6 = (const char *)_os_log_send_and_compose_impl( v5,  &v29,  0LL,  0LL,  &_mh_execute_header,  v3,  0LL,  "in SwitchtoLoginUser",  v30,  2);
      unsigned int v7 = (char *)v6;
      if (v6) {
        sub_100053B7C(v6);
      }
    }

    else
    {
      unsigned int v7 = 0LL;
    }

    free(v7);
  }

  else {
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  1LL,  0LL));
  }
  if ([*(id *)(a1 + 32) inLogoutProcess] && dword_1000DBCF0 != 1)
  {
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    int v9 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v29 = 0LL;
      unsigned int v10 = sub_100053B4C(1);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = v10 & 0xFFFFFFFE;
      }
      if ((_DWORD)v11)
      {
        v30[0] = 67109120;
        v30[1] = dword_1000DBCF0;
        uint64_t v12 = (const char *)_os_log_send_and_compose_impl( v11,  &v29,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "Already in SwitchtoUser, ignore current one: session type is:%d",  v30);
        NSErrorDomain v13 = (char *)v12;
        if (v12) {
          sub_100053B7C(v12);
        }
      }

      else
      {
        NSErrorDomain v13 = 0LL;
      }

      free(v13);
    }

    uint64_t v19 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  16LL,  0LL));
    uint64_t v8 = (void *)v19;
    goto LABEL_39;
  }

  if (!sub_10001C3D4())
  {
LABEL_39:
    int v20 = sub_10001D0C0();
    uint64_t v21 = *(void (**)(void))(*(void *)(a1 + 40) + 16LL);
    if (v20 == 502)
    {
      v21();
    }

    else
    {
      v21();
      if (!v8)
      {
        if (qword_1000DBA10 != -1) {
          dispatch_once(&qword_1000DBA10, &stru_1000CD208);
        }
        uint64_t v22 = (os_log_s *)(id)qword_1000DBA08;
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v29 = 0LL;
          unsigned int v23 = sub_100053B4C(1);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = v23 & 0xFFFFFFFE;
          }
          if ((_DWORD)v24)
          {
            LOWORD(v30[0]) = 0;
            LODWORD(v28) = 2;
            uint64_t v25 = (const char *)_os_log_send_and_compose_impl( v24,  &v29,  0LL,  0LL,  &_mh_execute_header,  v22,  0LL,  "Moving Along with SwitchtoUser",  v30,  v28);
            int v26 = (char *)v25;
            if (v25) {
              sub_100053B7C(v25);
            }
          }

          else
          {
            int v26 = 0LL;
          }

          free(v26);
        }

        sub_10002E9D0();
        uint64_t v8 = 0LL;
      }
    }

    goto LABEL_57;
  }

  if (qword_1000DBA20 != -1) {
    dispatch_once(&qword_1000DBA20, &stru_1000CD228);
  }
  unsigned int v14 = (os_log_s *)(id)qword_1000DBA18;
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    uint64_t v29 = 0LL;
    unsigned int v15 = sub_100053B4C(0);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v15 & 0xFFFFFFFE;
    }
    if ((_DWORD)v16)
    {
      LOWORD(v30[0]) = 0;
      LODWORD(v28) = 2;
      uint64_t v17 = (const char *)_os_log_send_and_compose_impl( v16,  &v29,  0LL,  0LL,  &_mh_execute_header,  v14,  16LL,  "Failed to switch user: user switch already in progress",  v30,  v28);
      uint64_t v18 = (char *)v17;
      if (v17) {
        sub_100053B7C(v17);
      }
    }

    else
    {
      uint64_t v18 = 0LL;
    }

    free(v18);
  }

  uint64_t v27 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  37LL,  0LL));
  uint64_t v8 = (void *)v27;
LABEL_57:
}

void sub_100008854(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _clientForPID:*(unsigned int *)(a1 + 48)]);
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  uint64_t v3 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v38 = 0LL;
    unsigned int v4 = sub_100053B4C(1);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = v4 & 0xFFFFFFFE;
    }
    if ((_DWORD)v5)
    {
      LOWORD(v39) = 0;
      uint64_t v6 = (const char *)_os_log_send_and_compose_impl( v5,  &v38,  0LL,  0LL,  &_mh_execute_header,  v3,  0LL,  "in logoutToLoginSessionWithPID",  &v39,  2);
      unsigned int v7 = (char *)v6;
      if (v6) {
        sub_100053B7C(v6);
      }
    }

    else
    {
      unsigned int v7 = 0LL;
    }

    free(v7);
  }

  if (![v2 hasEntitlement:@"com.apple.mkb.usersession.loginwindow"])
  {
    uint64_t v14 = 1LL;
    goto LABEL_38;
  }

  if (([*(id *)(a1 + 32) inLogoutProcess] & 1) != 0
    || sub_10001D0C0() == 502)
  {
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    uint64_t v8 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v38 = 0LL;
      LODWORD(v9) = sub_100053B4C(1);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v9 = v9;
      }
      else {
        uint64_t v9 = v9 & 0xFFFFFFFE;
      }
      if ((_DWORD)v9)
      {
        unsigned int v10 = *(void **)(a1 + 32);
        uint64_t v11 = v8;
        unsigned int v12 = [v10 inLogoutProcess];
        int v39 = 67109120;
        int v40 = v12;
        NSErrorDomain v13 = (char *)_os_log_send_and_compose_impl( v9,  &v38,  0LL,  0LL,  &_mh_execute_header,  v11,  0LL,  "Already in LoginUser or in process of logout/switch, ignore :%d",  &v39);

        if (v13) {
          sub_100053B7C(v13);
        }
      }

      else
      {
        NSErrorDomain v13 = 0LL;
      }

      free(v13);
    }

    uint64_t v14 = 16LL;
LABEL_38:
    int v20 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  v14,  0LL));
    if (v20) {
      goto LABEL_41;
    }
    goto LABEL_39;
  }

  if (!sub_10001C3D4())
  {
LABEL_39:
    if (sub_10001D0C0() != 502)
    {
      if (qword_1000DBA10 != -1) {
        dispatch_once(&qword_1000DBA10, &stru_1000CD208);
      }
      uint64_t v22 = (os_log_s *)(id)qword_1000DBA08;
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v38 = 0LL;
        unsigned int v23 = sub_100053B4C(1);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v24 = v23;
        }
        else {
          uint64_t v24 = v23 & 0xFFFFFFFE;
        }
        if ((_DWORD)v24)
        {
          LOWORD(v39) = 0;
          LODWORD(v37) = 2;
          uint64_t v25 = (const char *)_os_log_send_and_compose_impl( v24,  &v38,  0LL,  0LL,  &_mh_execute_header,  v22,  0LL,  "Logging Out to LogoutSession",  &v39,  v37);
          int v26 = (char *)v25;
          if (v25) {
            sub_100053B7C(v25);
          }
        }

        else
        {
          int v26 = 0LL;
        }

        free(v26);
      }

      if (sub_10002EA1C())
      {
        if (qword_1000DBA10 != -1) {
          dispatch_once(&qword_1000DBA10, &stru_1000CD208);
        }
        uint64_t v27 = (os_log_s *)(id)qword_1000DBA08;
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v38 = 0LL;
          unsigned int v28 = sub_100053B4C(1);
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v29 = v28;
          }
          else {
            uint64_t v29 = v28 & 0xFFFFFFFE;
          }
          if ((_DWORD)v29)
          {
            int v39 = 67109120;
            int v40 = dword_1000DBCF0;
            unsigned int v30 = (const char *)_os_log_send_and_compose_impl( v29,  &v38,  0LL,  0LL,  &_mh_execute_header,  v27,  0LL,  "LOGOUT SUCCESSFUL and sessionytype is:%d",  &v39);
            uint64_t v31 = (char *)v30;
            if (v30) {
              sub_100053B7C(v30);
            }
          }

          else
          {
            uint64_t v31 = 0LL;
          }

          free(v31);
        }

        int v20 = 0LL;
      }

      else
      {
        if (qword_1000DBA10 != -1) {
          dispatch_once(&qword_1000DBA10, &stru_1000CD208);
        }
        uint64_t v32 = (os_log_s *)(id)qword_1000DBA08;
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v38 = 0LL;
          unsigned int v33 = sub_100053B4C(1);
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v34 = v33;
          }
          else {
            uint64_t v34 = v33 & 0xFFFFFFFE;
          }
          if ((_DWORD)v34)
          {
            int v39 = 67109120;
            int v40 = dword_1000DBCF0;
            __int16 v35 = (const char *)_os_log_send_and_compose_impl( v34,  &v38,  0LL,  0LL,  &_mh_execute_header,  v32,  0LL,  "LOGOUT FAILED and sessionytype is:%d",  &v39);
            uint64_t v36 = (char *)v35;
            if (v35) {
              sub_100053B7C(v35);
            }
          }

          else
          {
            uint64_t v36 = 0LL;
          }

          free(v36);
        }

        int v20 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  22LL,  0LL));
      }

      uint64_t v21 = *(void (**)(void))(*(void *)(a1 + 40) + 16LL);
      goto LABEL_79;
    }

    int v20 = 0LL;
LABEL_41:
    uint64_t v21 = *(void (**)(void))(*(void *)(a1 + 40) + 16LL);
LABEL_79:
    v21();
    goto LABEL_80;
  }

  if (qword_1000DBA20 != -1) {
    dispatch_once(&qword_1000DBA20, &stru_1000CD228);
  }
  unsigned int v15 = (os_log_s *)(id)qword_1000DBA18;
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    uint64_t v38 = 0LL;
    unsigned int v16 = sub_100053B4C(0);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      uint64_t v17 = v16;
    }
    else {
      uint64_t v17 = v16 & 0xFFFFFFFE;
    }
    if ((_DWORD)v17)
    {
      LOWORD(v39) = 0;
      LODWORD(v37) = 2;
      uint64_t v18 = (const char *)_os_log_send_and_compose_impl( v17,  &v38,  0LL,  0LL,  &_mh_execute_header,  v15,  16LL,  "Failed to switch user: user switch already in progress",  &v39,  v37);
      uint64_t v19 = (char *)v18;
      if (v18) {
        sub_100053B7C(v18);
      }
    }

    else
    {
      uint64_t v19 = 0LL;
    }

    free(v19);
  }

  int v20 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  37LL,  0LL));
LABEL_80:
}

LABEL_31:
      uint64_t v14 = 0LL;
LABEL_32:
      free(v14);
    }
  }

  return v2 == 1;
}

    if (CFArrayGetCount((CFArrayRef)qword_1000DBCD8) <= ++v5) {
      return 0LL;
    }
  }

  uint64_t v14 = CFRetain(v7);
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  unsigned int v16 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v22 = 0LL;
    uint64_t v17 = sub_100053B4C(1);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v18 = v17;
    }
    else {
      uint64_t v18 = v17 & 0xFFFFFFFE;
    }
    if ((_DWORD)v18)
    {
      LOWORD(v23[0]) = 0;
      LODWORD(v21) = 2;
      uint64_t v19 = (const char *)_os_log_send_and_compose_impl( v18,  &v22,  0LL,  0LL,  &_mh_execute_header,  v16,  0LL,  "FOUND Primary session",  v23,  v21);
      int v20 = (char *)v19;
      if (v19) {
        sub_100053B7C(v19);
      }
    }

    else
    {
      int v20 = 0LL;
    }

    free(v20);
  }

  return v14;
}

      uint64_t v14 = 0LL;
LABEL_32:
      free(v14);
    }
  }

  return v7 == 0;
}

      uint64_t v14 = 0LL;
LABEL_32:
      free(v14);
    }
  }

  return v7 != 0;
}

      uint64_t v18 = 0LL;
LABEL_32:
      free(v18);
    }
  }

  return v11;
}

    goto LABEL_32;
  }

      goto LABEL_32;
    }

    return 0LL;
  }

  return result;
}

      uint64_t v14 = 0LL;
      goto LABEL_32;
    }
  }

      unsigned int v16 = 0LL;
LABEL_32:
      free(v16);
    }
  }
}

      unsigned int v16 = 0LL;
LABEL_32:
      free(v16);
    }
  }
}

      unsigned int v16 = 0LL;
LABEL_32:
      free(v16);
    }
  }
}

      uint64_t v24 = 0LL;
LABEL_32:
      free(v24);
    }
  }

  uint64_t v25 = *(void *)(a1 + 40);
  if (v25) {
    (*(void (**)(uint64_t, void *, void))(v25 + 16))( v25,  v13,  *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL));
  }
}

      uint64_t v24 = 0LL;
LABEL_32:
      free(v24);
    }
  }

  uint64_t v25 = *(void *)(a1 + 40);
  if (v25) {
    (*(void (**)(uint64_t, void *, void))(v25 + 16))( v25,  v13,  *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL));
  }
}

      uint64_t v24 = 0LL;
LABEL_32:
      free(v24);
    }
  }

  uint64_t v25 = *(void *)(a1 + 48);
  if (v25) {
    (*(void (**)(uint64_t, void))(v25 + 16))( v25,  *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 40LL));
  }
}

  return v12;
}

void sub_100009390(uint64_t a1)
{
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  id v2 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = 0LL;
    unsigned int v3 = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      __int16 v13 = 0;
      uint64_t v5 = (const char *)_os_log_send_and_compose_impl( v4,  &v14,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "in loginComplete",  &v13,  2);
      uint64_t v6 = (char *)v5;
      if (v5) {
        sub_100053B7C(v5);
      }
    }

    else
    {
      uint64_t v6 = 0LL;
    }

    free(v6);
  }

  if ([*(id *)(a1 + 32) inLogoutProcess])
  {
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    unsigned int v7 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = 0LL;
      unsigned int v8 = sub_100053B4C(1);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v9 = v8;
      }
      else {
        uint64_t v9 = v8 & 0xFFFFFFFE;
      }
      if ((_DWORD)v9)
      {
        __int16 v13 = 0;
        LODWORD(v12) = 2;
        unsigned int v10 = (const char *)_os_log_send_and_compose_impl( v9,  &v14,  0LL,  0LL,  &_mh_execute_header,  v7,  0LL,  "Already in SwitchtoUser, ignore current one",  &v13,  v12);
        uint64_t v11 = (char *)v10;
        if (v10) {
          sub_100053B7C(v10);
        }
      }

      else
      {
        uint64_t v11 = 0LL;
      }

      free(v11);
    }
  }

  else
  {
    sub_100029F14();
  }

void sub_10000962C(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _clientForPID:*(unsigned int *)(a1 + 48)]);
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  unsigned int v3 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v47 = 0LL;
    unsigned int v4 = sub_100053B4C(1);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = v4 & 0xFFFFFFFE;
    }
    if ((_DWORD)v5)
    {
      LOWORD(v46[0]) = 0;
      uint64_t v6 = (const char *)_os_log_send_and_compose_impl( v5,  &v47,  0LL,  0LL,  &_mh_execute_header,  v3,  0LL,  "in loginUICheckinForPID",  v46,  2);
      unsigned int v7 = (char *)v6;
      if (v6) {
        sub_100053B7C(v6);
      }
    }

    else
    {
      unsigned int v7 = 0LL;
    }

    free(v7);
  }

  if ([v2 hasEntitlement:@"com.apple.mkb.usersession.loginwindow"])
  {
    uint64_t v8 = sub_100018E80(qword_1000DBD40);
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
    if ((sub_100019ADC((uint64_t)v9) & 1) != 0)
    {
      uint64_t v10 = sub_100018E80(qword_1000DBD40);
      uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
      int v12 = sub_100019B60((uint64_t)v11);

      if (v12 == 502)
      {
        if (qword_1000DBA10 != -1) {
          dispatch_once(&qword_1000DBA10, &stru_1000CD208);
        }
        __int16 v13 = (os_log_s *)(id)qword_1000DBA08;
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_78;
        }
        uint64_t v47 = 0LL;
        unsigned int v14 = sub_100053B4C(1);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v15 = v14;
        }
        else {
          uint64_t v15 = v14 & 0xFFFFFFFE;
        }
        if ((_DWORD)v15)
        {
          LOWORD(v46[0]) = 0;
          LODWORD(v45) = 2;
          unsigned int v16 = (const char *)_os_log_send_and_compose_impl( v15,  &v47,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "Booted in LoginUser  ignore, return SUCCESS",  v46,  v45,  v46[0]);
          goto LABEL_74;
        }

LABEL_76:
        uint64_t v38 = 0LL;
LABEL_77:
        free(v38);
        goto LABEL_78;
      }
    }

    else
    {
    }

    if ([*(id *)(a1 + 32) inLoginSession])
    {
      int v22 = dword_1000DBCF4;
      dword_1000DBCF4 = 1;
      if (qword_1000DBA10 != -1) {
        dispatch_once(&qword_1000DBA10, &stru_1000CD208);
      }
      unsigned int v23 = (os_log_s *)(id)qword_1000DBA08;
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        v46[0] = 0LL;
        unsigned int v24 = sub_100053B4C(1);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v25 = v24;
        }
        else {
          uint64_t v25 = v24 & 0xFFFFFFFE;
        }
        if ((_DWORD)v25)
        {
          LODWORD(v47) = 67109376;
          HIDWORD(v47) = v22;
          __int16 v48 = 1024;
          int v49 = dword_1000DBCF4;
          int v26 = (const char *)_os_log_send_and_compose_impl( v25,  v46,  0LL,  0LL,  &_mh_execute_header,  v23,  0LL,  "In LOGINSESSION CHECKIN PrevState:%d, newState:%d",  &v47,  14);
          uint64_t v27 = (char *)v26;
          if (v26) {
            sub_100053B7C(v26);
          }
        }

        else
        {
          uint64_t v27 = 0LL;
        }

        free(v27);
      }

      sub_10001AED4();
      if (v22 == dword_1000DBCF4)
      {
        if (qword_1000DBA10 != -1) {
          dispatch_once(&qword_1000DBA10, &stru_1000CD208);
        }
        uint64_t v31 = (os_log_s *)(id)qword_1000DBA08;
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v47 = 0LL;
          unsigned int v32 = sub_100053B4C(1);
          if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v33 = v32;
          }
          else {
            uint64_t v33 = v32 & 0xFFFFFFFE;
          }
          if ((_DWORD)v33)
          {
            LOWORD(v46[0]) = 0;
            LODWORD(v45) = 2;
            uint64_t v34 = (const char *)_os_log_send_and_compose_impl( v33,  &v47,  0LL,  0LL,  &_mh_execute_header,  v31,  0LL,  "Already checked IN, switch to LoginUser as a recovery from LoginUI crash in DirectSwitch scenario",  v46,  v45);
            __int16 v35 = (char *)v34;
            if (v34) {
              sub_100053B7C(v34);
            }
          }

          else
          {
            __int16 v35 = 0LL;
          }

          free(v35);
        }

        int v39 = (const __CFDictionary *)sub_10001A2A4(502);
        if (qword_1000DBA10 != -1) {
          dispatch_once(&qword_1000DBA10, &stru_1000CD208);
        }
        int v40 = (os_log_s *)(id)qword_1000DBA08;
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v47 = 0LL;
          unsigned int v41 = sub_100053B4C(1);
          if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v42 = v41;
          }
          else {
            uint64_t v42 = v41 & 0xFFFFFFFE;
          }
          if ((_DWORD)v42)
          {
            LOWORD(v46[0]) = 0;
            LODWORD(v45) = 2;
            v43 = (const char *)_os_log_send_and_compose_impl( v42,  &v47,  0LL,  0LL,  &_mh_execute_header,  v40,  0LL,  "calling USR DIRECTLY",  v46,  v45);
            v44 = (char *)v43;
            if (v43) {
              sub_100053B7C(v43);
            }
          }

          else
          {
            v44 = 0LL;
          }

          free(v44);
        }

        sub_10002EAB0(v39, 0LL);
        goto LABEL_79;
      }

      if (qword_1000DBA10 != -1) {
        dispatch_once(&qword_1000DBA10, &stru_1000CD208);
      }
      __int16 v13 = (os_log_s *)(id)qword_1000DBA08;
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
LABEL_78:

LABEL_79:
        unsigned int v30 = 0LL;
        goto LABEL_80;
      }

      uint64_t v47 = 0LL;
      unsigned int v36 = sub_100053B4C(1);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v37 = v36;
      }
      else {
        uint64_t v37 = v36 & 0xFFFFFFFE;
      }
      if (!(_DWORD)v37) {
        goto LABEL_76;
      }
      LOWORD(v46[0]) = 0;
      LODWORD(v45) = 2;
      unsigned int v16 = (const char *)_os_log_send_and_compose_impl( v37,  &v47,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "First Time CHECKIN, so NO USR",  v46,  v45,  v46[0]);
    }

    else
    {
      if (qword_1000DBA10 != -1) {
        dispatch_once(&qword_1000DBA10, &stru_1000CD208);
      }
      __int16 v13 = (os_log_s *)(id)qword_1000DBA08;
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_78;
      }
      uint64_t v47 = 0LL;
      unsigned int v28 = sub_100053B4C(1);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v29 = v28;
      }
      else {
        uint64_t v29 = v28 & 0xFFFFFFFE;
      }
      if (!(_DWORD)v29) {
        goto LABEL_76;
      }
      LOWORD(v46[0]) = 0;
      LODWORD(v45) = 2;
      unsigned int v16 = (const char *)_os_log_send_and_compose_impl( v29,  &v47,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "Not in LoginUISession as well so ignore, return SUCCESS",  v46,  v45,  v46[0]);
    }

        unsigned int v36 = 0LL;
LABEL_77:
        free(v36);
      }
    }
  }

  else
  {
    uint64_t v15 = 0LL;
    while (1)
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, v15);
      if (ValueAtIndex)
      {
        uint64_t v17 = ValueAtIndex;
        unsigned int v18 = CFGetTypeID(ValueAtIndex);
        if (v18 == CFStringGetTypeID() && CFStringCompare(v17, a2, 0LL) == kCFCompareEqualTo) {
          break;
        }
      }

      if (CFArrayGetCount(MutableCopy) <= ++v15) {
        goto LABEL_22;
      }
    }

    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v30 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      v40[0] = 0LL;
      uint64_t v37 = sub_100053B4C(1);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v38 = v37;
      }
      else {
        uint64_t v38 = v37 & 0xFFFFFFFE;
      }
      if ((_DWORD)v38)
      {
        *(_DWORD *)unsigned int v41 = 138412290;
        *(void *)&v41[4] = a2;
        LODWORD(v39) = 12;
        uint64_t v33 = (const char *)_os_log_send_and_compose_impl( v38,  v40,  0LL,  0LL,  &_mh_execute_header,  v30,  0LL,  "RegisterSyncService: machservice already present: %@",  v41,  v39,  v40[0]);
LABEL_66:
        unsigned int v36 = (char *)v33;
        if (v33) {
          sub_100053B7C(v33);
        }
        goto LABEL_77;
      }

      goto LABEL_76;
    }
  }

  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
}

  unsigned int v30 = sub_100055178(qword_1000DBA70);
  if (CFArrayGetCount((CFArrayRef)qword_1000DBCF8) >= 1)
  {
    for (i = 0LL; CFArrayGetCount((CFArrayRef)qword_1000DBCF8) > i; ++i)
    {
      ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)qword_1000DBCF8, i);
      if (ValueAtIndex)
      {
        uint64_t v33 = ValueAtIndex;
        uint64_t v34 = CFGetTypeID(ValueAtIndex);
        if (v34 == CFNumberGetTypeID())
        {
          if (CFNumberGetValue(v33, kCFNumberIntType, &valuePtr))
          {
            if (valuePtr == v30)
            {
              if (qword_1000DBAA0 != -1) {
                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
              }
              __int16 v35 = (os_log_s *)(id)qword_1000DBA98;
              if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
              {
                v53 = 0LL;
                unsigned int v36 = sub_100053B4C(1);
                if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT)) {
                  uint64_t v37 = v36;
                }
                else {
                  uint64_t v37 = v36 & 0xFFFFFFFE;
                }
                if ((_DWORD)v37)
                {
                  LOWORD(v51[0]) = 0;
                  LODWORD(v50) = 2;
                  uint64_t v38 = (const char *)_os_log_send_and_compose_impl( v37,  &v53,  0LL,  0LL,  &_mh_execute_header,  v35,  0LL,  "Current FGID is the bubble UID, postpone load..",  v51,  v50);
                  int v39 = (char *)v38;
                  if (v38) {
                    sub_100053B7C(v38);
                  }
                }

                else
                {
                  int v39 = 0LL;
                }

                free(v39);
              }
            }

            else
            {
              if (qword_1000DBAA0 != -1) {
                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
              }
              int v40 = (os_log_s *)(id)qword_1000DBA98;
              if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
              {
                v53 = 0LL;
                unsigned int v41 = sub_100053B4C(1);
                if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT)) {
                  uint64_t v42 = v41;
                }
                else {
                  uint64_t v42 = v41 & 0xFFFFFFFE;
                }
                if ((_DWORD)v42)
                {
                  LOWORD(v51[0]) = 0;
                  LODWORD(v50) = 2;
                  v43 = (const char *)_os_log_send_and_compose_impl( v42,  &v53,  0LL,  0LL,  &_mh_execute_header,  v40,  0LL,  "Current FGID is not the bubble UID, load",  v51,  v50);
                  v44 = (char *)v43;
                  if (v43) {
                    sub_100053B7C(v43);
                  }
                }

                else
                {
                  v44 = 0LL;
                }

                free(v44);
              }

              if (qword_1000DBAA0 != -1) {
                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
              }
              uint64_t v45 = (os_log_s *)(id)qword_1000DBA98;
              if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
              {
                v53 = 0LL;
                unsigned int v46 = sub_100053B4C(1);
                if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT)) {
                  uint64_t v47 = v46;
                }
                else {
                  uint64_t v47 = v46 & 0xFFFFFFFE;
                }
                if ((_DWORD)v47)
                {
                  LOWORD(v51[0]) = 0;
                  LODWORD(v50) = 2;
                  __int16 v48 = (const char *)_os_log_send_and_compose_impl( v47,  &v53,  0LL,  0LL,  &_mh_execute_header,  v45,  0LL,  "Load Syncbubble failed, Append this bubble session to the end, Try Later",  v51,  v50);
                  int v49 = (char *)v48;
                  if (v48) {
                    sub_100053B7C(v48);
                  }
                }

                else
                {
                  int v49 = 0LL;
                }

                free(v49);
              }

              sub_10001D70C(valuePtr);
              sub_10001D55C(valuePtr);
              if (qword_1000DBCF8)
              {
                if (CFArrayGetCount((CFArrayRef)qword_1000DBCF8) == 1) {
                  return;
                }
              }
            }
          }
        }
      }
    }
  }

      uint64_t v38 = 0LL;
LABEL_77:
      free(v38);
    }
  }

  int v39 = sub_100033870(a1);
  int v40 = v3[340];
  if (v39)
  {
    unsigned int v41 = v2[339];
    if (os_log_type_enabled((os_log_t)v41, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)&v139.st_dev = 0LL;
      uint64_t v42 = sub_100053B4C(1);
      unsigned int v41 = v41;
      if (os_log_type_enabled((os_log_t)v41, OS_LOG_TYPE_DEFAULT)) {
        v43 = v42;
      }
      else {
        v43 = v42 & 0xFFFFFFFE;
      }
      if ((_DWORD)v43)
      {
        *(_DWORD *)v138 = 67109120;
        *(_DWORD *)&v138[4] = a1;
        v44 = _os_log_send_and_compose_impl( v43,  &v139,  0LL,  0LL,  &_mh_execute_header,  v41,  0LL,  "removed Sandbox for uid:%d",  v138);
        goto LABEL_95;
      }

      goto LABEL_97;
    }
  }

  else
  {
    unsigned int v41 = v2[339];
    if (os_log_type_enabled((os_log_t)v41, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)&v139.st_dev = 0LL;
      uint64_t v45 = sub_100053B4C(1);
      unsigned int v41 = v41;
      if (os_log_type_enabled((os_log_t)v41, OS_LOG_TYPE_DEFAULT)) {
        unsigned int v46 = v45;
      }
      else {
        unsigned int v46 = v45 & 0xFFFFFFFE;
      }
      if ((_DWORD)v46)
      {
        *(_DWORD *)v138 = 67109120;
        *(_DWORD *)&v138[4] = a1;
        v44 = _os_log_send_and_compose_impl( v46,  &v139,  0LL,  0LL,  &_mh_execute_header,  v41,  0LL,  "Failed to remove homepath to Sandbox for uid:%d",  v138);
LABEL_95:
        uint64_t v47 = (char *)v44;

        if (v47) {
          sub_100053B7C(v47);
        }
        goto LABEL_98;
      }

LABEL_74:
    uint64_t v38 = (char *)v16;
    if (v16) {
      sub_100053B7C(v16);
    }
    goto LABEL_77;
  }

  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  uint64_t v17 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v47 = 0LL;
    unsigned int v18 = sub_100053B4C(1);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v19 = v18;
    }
    else {
      uint64_t v19 = v18 & 0xFFFFFFFE;
    }
    if ((_DWORD)v19)
    {
      LOWORD(v46[0]) = 0;
      LODWORD(v45) = 2;
      int v20 = (const char *)_os_log_send_and_compose_impl( v19,  &v47,  0LL,  0LL,  &_mh_execute_header,  v17,  0LL,  "No entitlement for caller of loginUICheckinForPID",  v46,  v45);
      uint64_t v21 = (char *)v20;
      if (v20) {
        sub_100053B7C(v20);
      }
    }

    else
    {
      uint64_t v21 = 0LL;
    }

    free(v21);
  }

  unsigned int v30 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  1LL,  0LL));
LABEL_80:
  (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
}

        goto LABEL_76;
      }

      if (v33 >= 0xC)
      {
        uint64_t v34 = v31[2];
        if ((_DWORD)v34)
        {
          if (v33 >= v34 + 12)
          {
            __int16 v35 = acm_mem_alloc_data(v31[2]);
            acm_mem_alloc_info( "<data>",  v35,  v34,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  1805,  "processAclInternal");
            if (v35)
            {
              memcpy(v35, v31 + 3, v34);
              uint64_t v25 = 0LL;
              *a14 = v35;
              *a15 = v34;
            }

            else
            {
              uint64_t v25 = 4294967292LL;
            }

            goto LABEL_67;
          }

          goto LABEL_84;
        }

        uint64_t v34 = 0LL;
        __int16 v35 = 0LL;
        uint64_t v25 = 0LL;
        goto LABEL_67;
      }
    }

    uint64_t v34 = 0LL;
LABEL_84:
    __int16 v35 = 0LL;
    uint64_t v25 = 4294967291LL;
    goto LABEL_67;
  }

  if (a4)
  {
    unsigned int v24 = 70;
    uint64_t v25 = 4294967293LL;
    goto LABEL_79;
  }

  unsigned int v24 = 70;
  uint64_t v25 = 4294967293LL;
  if (a5 && a13 && a6)
  {
    uint64_t v25 = sub_100095584(a1, a2, a5, a6, a13);
LABEL_76:
    if ((_DWORD)v25) {
      unsigned int v24 = 70;
    }
    else {
      unsigned int v24 = 10;
    }
  }

void sub_100009E20(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _clientForPID:*(unsigned int *)(a1 + 48)]);
  if (!v2) {
    goto LABEL_35;
  }
  uint64_t v3 = sub_100018F4C(qword_1000DBD40);
  unsigned int v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v4 pathForPID:*(unsigned int *)(a1 + 48) error:0]);

  if (qword_1000DBA20 != -1) {
    dispatch_once(&qword_1000DBA20, &stru_1000CD228);
  }
  uint64_t v6 = (os_log_s *)(id)qword_1000DBA18;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v26 = 0LL;
    unsigned int v7 = sub_100053B4C(0);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = v7 & 0xFFFFFFFE;
    }
    if ((_DWORD)v8)
    {
      int v9 = *(_DWORD *)(a1 + 48);
      LODWORD(v23) = 67109378;
      HIDWORD(v23) = v9;
      __int16 v24 = 2114;
      uint64_t v25 = v5;
      uint64_t v10 = (const char *)_os_log_send_and_compose_impl( v8,  &v26,  0LL,  0LL,  &_mh_execute_header,  v6,  0LL,  "Terminate sync bubble started for pid:(%d,%{public}@)",  &v23,  18);
      uint64_t v11 = (char *)v10;
      if (v10) {
        sub_100053B7C(v10);
      }
    }

    else
    {
      uint64_t v11 = 0LL;
    }

    free(v11);
  }

  if ([v2 hasEntitlement:@"com.apple.mobile.keybagd.UserManager.bubblepop"])
  {
    if (![*(id *)(a1 + 32) switchState])
    {
      __int16 v13 = 0LL;
      goto LABEL_18;
    }

    uint64_t v12 = 16LL;
  }

  else
  {
    uint64_t v12 = 1LL;
  }

  __int16 v13 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  v12,  0LL));
LABEL_18:
  (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
  if (!v13)
  {
    [v2 setBubblePopstakeholderIsRegistered:1];
    [v2 setSwitchStakeHolderKind:3];
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    unsigned int v14 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v23 = 0LL;
      unsigned int v15 = sub_100053B4C(1);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v16 = v15;
      }
      else {
        uint64_t v16 = v15 & 0xFFFFFFFE;
      }
      if ((_DWORD)v16)
      {
        int v17 = *(_DWORD *)(a1 + 48);
        LODWORD(v26) = 67109120;
        HIDWORD(v26) = v17;
        unsigned int v18 = (const char *)_os_log_send_and_compose_impl( v16,  &v23,  0LL,  0LL,  &_mh_execute_header,  v14,  0LL,  "Terminate sync bubble(pid:%d)",  &v26);
        uint64_t v19 = (char *)v18;
        if (v18) {
          sub_100053B7C(v18);
        }
      }

      else
      {
        uint64_t v19 = 0LL;
      }

      free(v19);
    }

    int v20 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) bubbleStakeHolder]);
    uint64_t v21 = *(void **)(a1 + 32);
    if (v20)
    {
      int v22 = (void *)objc_claimAutoreleasedReturnValue([v21 bubbleStakeHolder]);
      [v22 bubbleShouldPop];
    }

    else
    {
      [v21 _broadcastBubbleDidPop];
    }
  }

LABEL_35:
}

void sub_10000A1F0(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _clientForPID:*(unsigned int *)(a1 + 48)]);
  uint64_t v3 = sub_100018F4C(qword_1000DBD40);
  unsigned int v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v4 pathForPID:*(unsigned int *)(a1 + 48) error:0]);

  if (qword_1000DBA20 != -1) {
    dispatch_once(&qword_1000DBA20, &stru_1000CD228);
  }
  uint64_t v6 = (os_log_s *)(id)qword_1000DBA18;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = 0LL;
    unsigned int v7 = sub_100053B4C(0);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = v7 & 0xFFFFFFFE;
    }
    if ((_DWORD)v8)
    {
      int v9 = *(_DWORD *)(a1 + 48);
      v13[0] = 67109378;
      v13[1] = v9;
      __int16 v14 = 2114;
      unsigned int v15 = v5;
      uint64_t v10 = (const char *)_os_log_send_and_compose_impl( v8,  &v12,  0LL,  0LL,  &_mh_execute_header,  v6,  0LL,  "Resume sync (Pid:%d,%{public}@)",  v13,  18);
      uint64_t v11 = (char *)v10;
      if (v10) {
        sub_100053B7C(v10);
      }
    }

    else
    {
      uint64_t v11 = 0LL;
    }

    free(v11);
  }

  if (v2)
  {
    [v2 setBubblePopstakeholderIsRegistered:0];
    sub_100035404();
  }

  (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
}

void sub_10000A444(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _clientForPID:*(unsigned int *)(a1 + 48)]);
  [v2 setBubbleStakeHolder:1];
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  uint64_t v3 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t v16 = 0LL;
    unsigned int v4 = sub_100053B4C(1);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = v4 & 0xFFFFFFFE;
    }
    if ((_DWORD)v5)
    {
      int v6 = *(_DWORD *)(a1 + 52);
      LODWORD(v17) = 67109120;
      HIDWORD(v17) = v6;
      unsigned int v7 = (const char *)_os_log_send_and_compose_impl( v5,  v16,  0LL,  0LL,  &_mh_execute_header,  v3,  0LL,  "BUBBLE REQ machservice for uid:%d",  &v17);
      uint64_t v8 = (char *)v7;
      if (v7) {
        sub_100053B7C(v7);
      }
    }

    else
    {
      uint64_t v8 = 0LL;
    }

    free(v8);
  }

  CFArrayRef v9 = sub_100030DA8(*(_DWORD *)(a1 + 52));
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  uint64_t v11 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = 0LL;
    unsigned int v12 = sub_100053B4C(1);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v13 = v12;
    }
    else {
      uint64_t v13 = v12 & 0xFFFFFFFE;
    }
    if ((_DWORD)v13)
    {
      *(_DWORD *)uint64_t v16 = 138412290;
      *(void *)&v16[4] = v10;
      __int16 v14 = (const char *)_os_log_send_and_compose_impl( v13,  &v17,  0LL,  0LL,  &_mh_execute_header,  v11,  0LL,  "MachServiceList %@",  v16,  12);
      unsigned int v15 = (char *)v14;
      if (v14) {
        sub_100053B7C(v14);
      }
    }

    else
    {
      unsigned int v15 = 0LL;
    }

    free(v15);
  }

  (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
}

void sub_10000A734(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _clientForPID:*(unsigned int *)(a1 + 48)]);
  [v2 setBubbleStakeHolder:1];
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  uint64_t v3 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = 0LL;
    unsigned int v4 = sub_100053B4C(1);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = v4 & 0xFFFFFFFE;
    }
    if ((_DWORD)v5)
    {
      __int16 v8 = 0;
      int v6 = (const char *)_os_log_send_and_compose_impl( v5,  &v9,  0LL,  0LL,  &_mh_execute_header,  v3,  0LL,  "Removing machservice from bubble",  &v8,  2);
      unsigned int v7 = (char *)v6;
      if (v6) {
        sub_100053B7C(v6);
      }
    }

    else
    {
      unsigned int v7 = 0LL;
    }

    free(v7);
  }

  sub_1000352D8(*(_DWORD *)(a1 + 52), *(const __CFString **)(a1 + 40));
}

void sub_10000A8C0(uint64_t a1)
{
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  id v2 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = 0LL;
    unsigned int v3 = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      int v5 = *(_DWORD *)(a1 + 48);
      v9[0] = 67109120;
      v9[1] = v5;
      int v6 = (const char *)_os_log_send_and_compose_impl( v4,  &v8,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "UNLOADING SYNC BUBBLE (BUBBLE StopBubble)FOR uid %d:",  v9);
      unsigned int v7 = (char *)v6;
      if (v6) {
        sub_100053B7C(v6);
      }
    }

    else
    {
      unsigned int v7 = 0LL;
    }

    free(v7);
  }

  sub_10002C7F8(*(unsigned int *)(a1 + 48), 1);
  if (*(void *)(a1 + 40) == 1LL) {
    sub_10001D55C(*(_DWORD *)(a1 + 48));
  }
  [*(id *)(a1 + 32) _broadcastBubbleDidPop];
  sub_100035404();
}

void sub_10000AA30(id a1, RDClient *a2, BOOL *a3)
{
  unsigned int v3 = a2;
  if (-[RDClient bubblePopstakeholderIsRegistered](v3, "bubblePopstakeholderIsRegistered")) {
    -[RDClient bubbleDidPop](v3, "bubbleDidPop");
  }
}

void sub_10000B674(uint64_t a1)
{
  if (qword_1000DBA20 != -1) {
    dispatch_once(&qword_1000DBA20, &stru_1000CD228);
  }
  id v2 = (os_log_s *)(id)qword_1000DBA18;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v21 = 0LL;
    LODWORD(v3) = sub_100053B4C(0);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v3 = v3;
    }
    else {
      uint64_t v3 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v3)
    {
      uint64_t v4 = *(void **)(a1 + 32);
      int v5 = v2;
      int v6 = (void *)objc_claimAutoreleasedReturnValue([v4 logoutTimer]);
      *(_DWORD *)int v20 = 134217984;
      *(void *)&v20[4] = v6;
      unsigned int v7 = (char *)_os_log_send_and_compose_impl( v3,  &v21,  0LL,  0LL,  &_mh_execute_header,  v5,  0LL,  "Logout timer [switchToUser] (%p) fired",  v20);

      if (v7) {
        sub_100053B7C(v7);
      }
    }

    else
    {
      unsigned int v7 = 0LL;
    }

    free(v7);
  }

  uint64_t v8 = (dispatch_source_s *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) logoutTimer]);
  dispatch_source_cancel(v8);

  [*(id *)(a1 + 32) setLogoutTimer:0];
  if ([*(id *)(a1 + 32) switchState] == 1
    && [*(id *)(a1 + 32) switchState] != 2)
  {
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    unsigned int v15 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)int v20 = 0LL;
      unsigned int v16 = sub_100053B4C(1);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v17 = v16;
      }
      else {
        uint64_t v17 = v16 & 0xFFFFFFFE;
      }
      if ((_DWORD)v17)
      {
        LOWORD(v21) = 0;
        unsigned int v18 = (const char *)_os_log_send_and_compose_impl( v17,  v20,  0LL,  0LL,  &_mh_execute_header,  v15,  0LL,  "LOGOUT TIMEOUT, forcing _reallySwitchUser",  &v21,  2);
        uint64_t v19 = (char *)v18;
        if (v18) {
          sub_100053B7C(v18);
        }
      }

      else
      {
        uint64_t v19 = 0LL;
      }

      free(v19);
    }

    [*(id *)(a1 + 32) _reallySwitchUser:0];
  }

  else
  {
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    uint64_t v9 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)int v20 = 0LL;
      LODWORD(v10) = sub_100053B4C(1);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v10 = v10;
      }
      else {
        uint64_t v10 = v10 & 0xFFFFFFFE;
      }
      if ((_DWORD)v10)
      {
        uint64_t v11 = *(void **)(a1 + 32);
        unsigned int v12 = v9;
        unsigned int v13 = [v11 switchState];
        LODWORD(v21) = 67109120;
        HIDWORD(v21) = v13;
        __int16 v14 = (char *)_os_log_send_and_compose_impl( v10,  v20,  0LL,  0LL,  &_mh_execute_header,  v12,  0LL,  "LOGOUT TIMEOUT; Ignoring as already in _reallySwitchUser or not in willSwitchUser to force switch:%d",
                        &v21);

        if (v14) {
          sub_100053B7C(v14);
        }
      }

      else
      {
        __int16 v14 = 0LL;
      }

      free(v14);
    }
  }

void sub_10000B9F4(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([v3 stakeholderIsRegistered])
  {
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472LL;
    v5[2] = sub_10000BA6C;
    v5[3] = &unk_1000CCF28;
    uint64_t v4 = *(void *)(a1 + 32);
    v5[4] = *(void *)(a1 + 40);
    [v3 willSwitchToUser:v4 completionHandler:v5];
  }
}

void sub_10000BA6C(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_10000BAD0;
  block[3] = &unk_1000CCF28;
  block[4] = *(void *)(a1 + 32);
  dispatch_async((dispatch_queue_t)qword_1000DBD48, block);
}

id sub_10000BAD0(uint64_t a1)
{
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  id v2 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = 0LL;
    unsigned int v3 = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      __int16 v8 = 0;
      int v5 = (const char *)_os_log_send_and_compose_impl( v4,  &v9,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "switchToUser: willswitch completion handler -> _checkIfWeShouldSwitchUser",  &v8,  2);
      int v6 = (char *)v5;
      if (v5) {
        sub_100053B7C(v5);
      }
    }

    else
    {
      int v6 = 0LL;
    }

    free(v6);
  }

  return [*(id *)(a1 + 32) _checkIfWeShouldSwitchUser:0];
}

void sub_10000C374(uint64_t a1)
{
  if (qword_1000DBA20 != -1) {
    dispatch_once(&qword_1000DBA20, &stru_1000CD228);
  }
  id v2 = (os_log_s *)(id)qword_1000DBA18;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v19[0] = 0LL;
    LODWORD(v3) = sub_100053B4C(0);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v3 = v3;
    }
    else {
      uint64_t v3 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v3)
    {
      uint64_t v4 = *(void **)(a1 + 32);
      int v5 = v2;
      int v6 = (void *)objc_claimAutoreleasedReturnValue([v4 logoutTimer]);
      *(_DWORD *)int v20 = 134217984;
      *(void *)&v20[4] = v6;
      unsigned int v7 = (char *)_os_log_send_and_compose_impl( v3,  v19,  0LL,  0LL,  &_mh_execute_header,  v5,  0LL,  "Logout timer [LogoutToUser] (%p) fired",  v20);

      if (v7) {
        sub_100053B7C(v7);
      }
    }

    else
    {
      unsigned int v7 = 0LL;
    }

    free(v7);
  }

  __int16 v8 = (dispatch_source_s *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) logoutTimer]);
  dispatch_source_cancel(v8);

  [*(id *)(a1 + 32) setLogoutTimer:0];
  if ([*(id *)(a1 + 32) switchState] == 1)
  {
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    uint64_t v9 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)int v20 = 0LL;
      unsigned int v10 = sub_100053B4C(1);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = v10 & 0xFFFFFFFE;
      }
      if ((_DWORD)v11)
      {
        LOWORD(v19[0]) = 0;
        unsigned int v12 = (const char *)_os_log_send_and_compose_impl( v11,  v20,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "LOGOUT TIMEOUT, forcing _reallySwitchUser",  v19,  2);
        unsigned int v13 = (char *)v12;
        if (v12) {
          sub_100053B7C(v12);
        }
      }

      else
      {
        unsigned int v13 = 0LL;
      }

      free(v13);
    }

    [*(id *)(a1 + 32) _reallySwitchUser:1];
  }

  else
  {
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    __int16 v14 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)int v20 = 0LL;
      unsigned int v15 = sub_100053B4C(1);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v16 = v15;
      }
      else {
        uint64_t v16 = v15 & 0xFFFFFFFE;
      }
      if ((_DWORD)v16)
      {
        LOWORD(v19[0]) = 0;
        uint64_t v17 = (const char *)_os_log_send_and_compose_impl( v16,  v20,  0LL,  0LL,  &_mh_execute_header,  v14,  0LL,  "LOGOUT TIMEOUT, ignore already in _reallySwitchUser",  v19,  2);
        unsigned int v18 = (char *)v17;
        if (v17) {
          sub_100053B7C(v17);
        }
      }

      else
      {
        unsigned int v18 = 0LL;
      }

      free(v18);
    }
  }

void sub_10000C6B4(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([v3 stakeholderIsRegistered])
  {
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472LL;
    v5[2] = sub_10000C72C;
    v5[3] = &unk_1000CCF28;
    uint64_t v4 = *(void *)(a1 + 32);
    v5[4] = *(void *)(a1 + 40);
    [v3 willSwitchToUser:v4 completionHandler:v5];
  }
}

void sub_10000C72C(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_10000C790;
  block[3] = &unk_1000CCF28;
  block[4] = *(void *)(a1 + 32);
  dispatch_async((dispatch_queue_t)qword_1000DBD48, block);
}

id sub_10000C790(uint64_t a1)
{
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  id v2 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = 0LL;
    unsigned int v3 = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      __int16 v8 = 0;
      int v5 = (const char *)_os_log_send_and_compose_impl( v4,  &v9,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "switchToUser: willswitch completion handler -> _checkIfWeShouldSwitchUser",  &v8,  2);
      int v6 = (char *)v5;
      if (v5) {
        sub_100053B7C(v5);
      }
    }

    else
    {
      int v6 = 0LL;
    }

    free(v6);
  }

  return [*(id *)(a1 + 32) _checkIfWeShouldSwitchUser:1];
}

void sub_10000CC14( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_10000CC4C(uint64_t a1, void *a2, _BYTE *a3)
{
  id v5 = a2;
  uint64_t v6 = sub_100018F4C(qword_1000DBD40);
  unsigned int v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
  __int16 v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "pathForPID:error:", objc_msgSend(v5, "pid"), 0));

  if ([v5 stakeholderIsRegistered]
    && (([v5 hasUserSwitchTasks] & 1) != 0
     || ([v5 wasToldWillSwitchUser] & 1) == 0))
  {
    if (qword_1000DBA20 != -1) {
      dispatch_once(&qword_1000DBA20, &stru_1000CD228);
    }
    __int16 v14 = (os_log_s *)(id)qword_1000DBA18;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = 0LL;
      unsigned int v15 = sub_100053B4C(0);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v16 = v15;
      }
      else {
        uint64_t v16 = v15 & 0xFFFFFFFE;
      }
      if ((_DWORD)v16)
      {
        uint64_t v17 = v14;
        int v20 = 67110146;
        unsigned int v21 = [v5 stakeholderIsRegistered];
        __int16 v22 = 1024;
        unsigned int v23 = [v5 wasToldWillSwitchUser];
        __int16 v24 = 1024;
        unsigned int v25 = [v5 hasUserSwitchTasks];
        __int16 v26 = 1024;
        unsigned int v27 = [v5 pid];
        __int16 v28 = 2114;
        uint64_t v29 = v8;
        unsigned int v18 = (char *)_os_log_send_and_compose_impl( v16,  &v19,  0LL,  0LL,  &_mh_execute_header,  v17,  0LL,  "Client(stakeholderIsRegistered:%d) was told will switch:%d, has tasks: %d with pid(%d,%{public}@)",  &v20,  36);

        if (v18) {
          sub_100053B7C(v18);
        }
      }

      else
      {
        unsigned int v18 = 0LL;
      }

      free(v18);
    }

    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
    *a3 = 1;
  }

  else
  {
    if (qword_1000DBA20 != -1) {
      dispatch_once(&qword_1000DBA20, &stru_1000CD228);
    }
    uint64_t v9 = (os_log_s *)(id)qword_1000DBA18;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = 0LL;
      unsigned int v10 = sub_100053B4C(0);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = v10 & 0xFFFFFFFE;
      }
      if ((_DWORD)v11)
      {
        unsigned int v12 = v9;
        int v20 = 67110146;
        unsigned int v21 = [v5 stakeholderIsRegistered];
        __int16 v22 = 1024;
        unsigned int v23 = [v5 wasToldWillSwitchUser];
        __int16 v24 = 1024;
        unsigned int v25 = [v5 hasUserSwitchTasks];
        __int16 v26 = 1024;
        unsigned int v27 = [v5 pid];
        __int16 v28 = 2114;
        uint64_t v29 = v8;
        unsigned int v13 = (char *)_os_log_send_and_compose_impl( v11,  &v19,  0LL,  0LL,  &_mh_execute_header,  v12,  0LL,  "!!Client(stakeholderIsRegistered:%d) was told will switch:%d, has tasks: %d with pid(%d,%{public}@)",  &v20,  36);

        if (v13) {
          sub_100053B7C(v13);
        }
      }

      else
      {
        unsigned int v13 = 0LL;
      }

      free(v13);
    }
  }
}

LABEL_67:
  int v39 = (void *)objc_claimAutoreleasedReturnValue(-[RDServer criticalStakeHolder](self, "criticalStakeHolder"));
  if (!v39)
  {
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    uint64_t v45 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)v91 = 0LL;
      unsigned int v46 = sub_100053B4C(1);
      if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v47 = v46;
      }
      else {
        uint64_t v47 = v46 & 0xFFFFFFFE;
      }
      if ((_DWORD)v47)
      {
        LOWORD(v92) = 0;
        LODWORD(v87) = 2;
        __int16 v48 = (const char *)_os_log_send_and_compose_impl( v47,  v91,  0LL,  0LL,  &_mh_execute_header,  v45,  0LL,  "No critical Client, wait for 10 secs and retry",  &v92,  v87);
        int v49 = (char *)v48;
        if (v48) {
          sub_100053B7C(v48);
        }
      }

      else
      {
        int v49 = 0LL;
      }

      free(v49);
    }

    goto LABEL_111;
  }

  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  int v40 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)v91 = 0LL;
    LODWORD(v41) = sub_100053B4C(1);
    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT)) {
      unsigned int v41 = v41;
    }
    else {
      unsigned int v41 = v41 & 0xFFFFFFFE;
    }
    if ((_DWORD)v41)
    {
      uint64_t v42 = v40;
      v43 = [v39 stakeholderIsRegistered];
      LODWORD(v92) = 67109120;
      HIDWORD(v92) = v43;
      v44 = (char *)_os_log_send_and_compose_impl( v41,  v91,  0LL,  0LL,  &_mh_execute_header,  v42,  0LL,  "Have A critical Client, and %d",  &v92);

      if (v44) {
        sub_100053B7C(v44);
      }
    }

    else
    {
      v44 = 0LL;
    }

    free(v44);
  }

  if (![v39 stakeholderIsRegistered])
  {
LABEL_111:
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    __int128 v61 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)v91 = 0LL;
      __int128 v62 = sub_100053B4C(1);
      if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT)) {
        __int128 v63 = v62;
      }
      else {
        __int128 v63 = v62 & 0xFFFFFFFE;
      }
      if ((_DWORD)v63)
      {
        LOWORD(v92) = 0;
        LODWORD(v87) = 2;
        __int128 v64 = (const char *)_os_log_send_and_compose_impl( v63,  v91,  0LL,  0LL,  &_mh_execute_header,  v61,  0LL,  "NO Critical Stake holder, USR anyway",  &v92,  v87);
        v65 = (char *)v64;
        if (v64) {
          sub_100053B7C(v64);
        }
      }

      else
      {
        v65 = 0LL;
      }

      free(v65);
    }

    v66 = v5;
    if (v3)
    {
      v66 = (const __CFDictionary *)sub_10001A2A4(502);
      if (qword_1000DBA10 != -1) {
        dispatch_once(&qword_1000DBA10, &stru_1000CD208);
      }
      uint64_t v67 = (os_log_s *)(id)qword_1000DBA08;
      if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)v91 = 0LL;
        __int16 v68 = sub_100053B4C(1);
        if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT)) {
          int v69 = v68;
        }
        else {
          int v69 = v68 & 0xFFFFFFFE;
        }
        if ((_DWORD)v69)
        {
          LOWORD(v92) = 0;
          LODWORD(v87) = 2;
          v70 = (const char *)_os_log_send_and_compose_impl( v69,  v91,  0LL,  0LL,  &_mh_execute_header,  v67,  0LL,  "in LogoutPath, SWITCHING TO LOGINUSER as there is no Critical Stake Holder..",  &v92,  v87);
          v71 = (char *)v70;
          if (v70) {
            sub_100053B7C(v70);
          }
        }

        else
        {
          v71 = 0LL;
        }

        free(v71);
      }
    }

    if (v66 && CFDictionaryContainsKey(v66, @"UserSwitchTaskOpqueData"))
    {
      Value = CFDictionaryGetValue(v66, @"UserSwitchTaskOpqueData");
      v73 = (const __CFData *)CFRetain(Value);
      CFDictionaryRemoveValue(v66, @"UserSwitchTaskOpqueData");
    }

    else
    {
      v73 = 0LL;
    }

    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    v74 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)v91 = 0LL;
      v75 = sub_100053B4C(1);
      if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT)) {
        v76 = v75;
      }
      else {
        v76 = v75 & 0xFFFFFFFE;
      }
      if ((_DWORD)v76)
      {
        LOWORD(v92) = 0;
        LODWORD(v87) = 2;
        v77 = (const char *)_os_log_send_and_compose_impl( v76,  v91,  0LL,  0LL,  &_mh_execute_header,  v74,  0LL,  "calling USR",  &v92,  v87);
        v78 = (char *)v77;
        if (v77) {
          sub_100053B7C(v77);
        }
      }

      else
      {
        v78 = 0LL;
      }

      free(v78);
    }

    sub_10002EAB0(v66, v73);
    goto LABEL_151;
  }

  if (v3)
  {
    v50 = MKBLockDeviceNow(0LL);
    if (v50)
    {
      unsigned int v51 = v50;
      if (qword_1000DBA10 != -1) {
        dispatch_once(&qword_1000DBA10, &stru_1000CD208);
      }
      uint64_t v52 = (os_log_s *)(id)qword_1000DBA08;
      if (!os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_167;
      }
      *(void *)v91 = 0LL;
      v53 = sub_100053B4C(1);
      if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT)) {
        v54 = v53;
      }
      else {
        v54 = v53 & 0xFFFFFFFE;
      }
      if ((_DWORD)v54)
      {
        LODWORD(v92) = 67109120;
        HIDWORD(v92) = v51;
        v55 = (const char *)_os_log_send_and_compose_impl( v54,  v91,  0LL,  0LL,  &_mh_execute_header,  v52,  0LL,  "LOCKDEVICENOW failed with error 0x%x",  &v92);
        goto LABEL_160;
      }
    }

    else
    {
      if (qword_1000DBA10 != -1) {
        dispatch_once(&qword_1000DBA10, &stru_1000CD208);
      }
      uint64_t v52 = (os_log_s *)(id)qword_1000DBA08;
      if (!os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_167;
      }
      *(void *)v91 = 0LL;
      v79 = sub_100053B4C(1);
      if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT)) {
        v80 = v79;
      }
      else {
        v80 = v79 & 0xFFFFFFFE;
      }
      if ((_DWORD)v80)
      {
        LOWORD(v92) = 0;
        v55 = (const char *)_os_log_send_and_compose_impl( v80,  v91,  0LL,  0LL,  &_mh_execute_header,  v52,  0LL,  "AKS LOCKDEVICENOW COMPLETED");
LABEL_160:
        v81 = (char *)v55;
        if (v55) {
          sub_100053B7C(v55);
        }
        goto LABEL_166;
      }
    }

    v81 = 0LL;
LABEL_166:
    free(v81);
LABEL_167:

    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    v82 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)v91 = 0LL;
      v83 = sub_100053B4C(1);
      if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT)) {
        v84 = v83;
      }
      else {
        v84 = v83 & 0xFFFFFFFE;
      }
      if ((_DWORD)v84)
      {
        LOWORD(v92) = 0;
        LODWORD(v87) = 2;
        v85 = (const char *)_os_log_send_and_compose_impl( v84,  v91,  0LL,  0LL,  &_mh_execute_header,  v82,  0LL,  "INLogout Path, calling readyToSwitchToLoginSession",  &v92,  v87);
        v86 = (char *)v85;
        if (v85) {
          sub_100053B7C(v85);
        }
      }

      else
      {
        v86 = 0LL;
      }

      free(v86);
    }

    v90[0] = _NSConcreteStackBlock;
    v90[1] = 3221225472LL;
    v90[2] = sub_10000E1F8;
    v90[3] = &unk_1000CCF28;
    v90[4] = self;
    [v39 readyToSwitchToLoginSession:0 completionHandler:v90];
    goto LABEL_151;
  }

  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  unsigned int v56 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)v91 = 0LL;
    uint64_t v57 = sub_100053B4C(1);
    if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT)) {
      v58 = v57;
    }
    else {
      v58 = v57 & 0xFFFFFFFE;
    }
    if ((_DWORD)v58)
    {
      LOWORD(v92) = 0;
      LODWORD(v87) = 2;
      v59 = (const char *)_os_log_send_and_compose_impl( v58,  v91,  0LL,  0LL,  &_mh_execute_header,  v56,  0LL,  "Calling readyToSwitchToUser",  &v92,  v87);
      uint64_t v60 = (char *)v59;
      if (v59) {
        sub_100053B7C(v59);
      }
    }

    else
    {
      uint64_t v60 = 0LL;
    }

    free(v60);
  }

  v88[0] = _NSConcreteStackBlock;
  v88[1] = 3221225472LL;
  v88[2] = sub_10000EC74;
  v88[3] = &unk_1000CCF28;
  v89 = v5;
  [v39 readyToSwitchToUser:v89 completionHandler:v88];

LABEL_151:
}

    unsigned int v36 = 0;
    goto LABEL_83;
  }

  if (v8)
  {
    if ((objc_msgSend(v8, "getCString:maxLength:encoding:", &v53, 1024, 4, v9) & 1) == 0)
    {
      if (qword_1000DBBF8 != -1) {
        dispatch_once(&qword_1000DBBF8, &stru_1000CDB88);
      }
      unsigned int v23 = (os_log_s *)(id)qword_1000DBBF0;
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        v50 = 0LL;
        __int16 v24 = sub_100053B4C(0);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
          unsigned int v25 = v24;
        }
        else {
          unsigned int v25 = v24 & 0xFFFFFFFE;
        }
        if ((_DWORD)v25)
        {
          *(_DWORD *)uint64_t v52 = 138543362;
          *(void *)&v52[4] = v8;
          __int16 v26 = (const char *)_os_log_send_and_compose_impl( v25,  &v50,  0LL,  0LL,  &_mh_execute_header,  v23,  16LL,  "Failed to allocate kernel persona: Failed to convert path to C string: %{public}@",  v52,  12);
          unsigned int v27 = (char *)v26;
          if (v26) {
            sub_100053B7C(v26);
          }
        }

        else
        {
          unsigned int v27 = 0LL;
        }

        free(v27);
      }

      if (a5) {
        *a5 = (id)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  22LL,  0LL));
      }
      goto LABEL_67;
    }

    if (kpersona_palloc(&v64, &v51, &v53))
    {
      unsigned int v10 = *__error();
      if (qword_1000DBBF8 != -1) {
        dispatch_once(&qword_1000DBBF8, &stru_1000CDB88);
      }
      uint64_t v11 = (os_log_s *)(id)qword_1000DBBF0;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(void *)uint64_t v52 = 0LL;
        unsigned int v12 = sub_100053B4C(0);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
          unsigned int v13 = v12;
        }
        else {
          unsigned int v13 = v12 & 0xFFFFFFFE;
        }
        if ((_DWORD)v13)
        {
          LODWORD(v53) = 67110402;
          HIDWORD(v53) = v65;
          v54 = 1024;
          v55 = v66;
          unsigned int v56 = 2082;
          uint64_t v57 = v67;
          v58 = 1024;
          v59 = v68;
          uint64_t v60 = 2114;
          __int128 v61 = v8;
          __int128 v62 = 1024;
          __int128 v63 = v10;
          __int16 v14 = (const char *)_os_log_send_and_compose_impl( v13,  v52,  0LL,  0LL,  &_mh_execute_header,  v11,  16LL,  "Failed to allocate kernel persona: kpersona_palloc(ID: %U, Type: %u, Name: %{public}s, U ID %u, Path: %{public}@) failed: %{darwin.errno}d",  &v53,  46);
          goto LABEL_33;
        }

        goto LABEL_58;
      }

      goto LABEL_60;
    }
  }

  else if (kpersona_alloc(&v64, &v51, v9))
  {
    unsigned int v10 = *__error();
    if (qword_1000DBBF8 != -1) {
      dispatch_once(&qword_1000DBBF8, &stru_1000CDB88);
    }
    uint64_t v11 = (os_log_s *)(id)qword_1000DBBF0;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(void *)uint64_t v52 = 0LL;
      int v20 = sub_100053B4C(0);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        unsigned int v21 = v20;
      }
      else {
        unsigned int v21 = v20 & 0xFFFFFFFE;
      }
      if ((_DWORD)v21)
      {
        LODWORD(v53) = 67110146;
        HIDWORD(v53) = v65;
        v54 = 1024;
        v55 = v66;
        unsigned int v56 = 2082;
        uint64_t v57 = v67;
        v58 = 1024;
        v59 = v68;
        uint64_t v60 = 1024;
        LODWORD(v61) = v10;
        __int16 v14 = (const char *)_os_log_send_and_compose_impl( v21,  v52,  0LL,  0LL,  &_mh_execute_header,  v11,  16LL,  "Failed to allocate kernel persona: kpersona_alloc(ID: %U, Type: %u, Name: %{public}s, UID %u) failed: %{darwin.errno}d",  &v53,  36);
LABEL_33:
        __int16 v22 = (char *)v14;
        if (v14) {
          sub_100053B7C(v14);
        }
        goto LABEL_59;
      }

void sub_10000DDA0(id a1, RDClient *a2, BOOL *a3)
{
  uint64_t v4 = a2;
  id v5 = (void *)objc_claimAutoreleasedReturnValue(-[RDClient machServiceName](v4, "machServiceName"));

  if (v5)
  {
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(-[RDClient userSyncTasks](v4, "userSyncTasks"));
    id v7 = [v6 count];

    if (v7)
    {
      if (qword_1000DBA10 != -1) {
        dispatch_once(&qword_1000DBA10, &stru_1000CD208);
      }
      __int16 v8 = (os_log_s *)(id)qword_1000DBA08;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v29 = 0LL;
        LODWORD(v9) = sub_100053B4C(1);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v9 = v9;
        }
        else {
          uint64_t v9 = v9 & 0xFFFFFFFE;
        }
        if ((_DWORD)v9)
        {
          unsigned int v10 = v8;
          uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(-[RDClient machServiceName](v4, "machServiceName"));
          unsigned int v12 = (void *)objc_claimAutoreleasedReturnValue(-[RDClient userSyncTasks](v4, "userSyncTasks"));
          int v30 = 138412546;
          *(void *)uint64_t v31 = v11;
          *(_WORD *)&v31[8] = 2112;
          *(void *)&v31[10] = v12;
          unsigned int v13 = (char *)_os_log_send_and_compose_impl( v9,  &v29,  0LL,  0LL,  &_mh_execute_header,  v10,  0LL,  "Registering Bubble mach service %@, with tasks %@",  &v30,  22);

          if (v13) {
            sub_100053B7C(v13);
          }
        }

        else
        {
          unsigned int v13 = 0LL;
        }

        free(v13);
      }

      uint64_t v19 = (__CFString *)objc_claimAutoreleasedReturnValue(-[RDClient machServiceName](v4, "machServiceName"));
      sub_100034290(v19);
    }

    else
    {
      if (qword_1000DBA10 != -1) {
        dispatch_once(&qword_1000DBA10, &stru_1000CD208);
      }
      __int16 v14 = (os_log_s *)(id)qword_1000DBA08;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v29 = 0LL;
        LODWORD(v15) = sub_100053B4C(1);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v15 = v15;
        }
        else {
          uint64_t v15 = v15 & 0xFFFFFFFE;
        }
        if ((_DWORD)v15)
        {
          uint64_t v16 = v14;
          uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(-[RDClient machServiceName](v4, "machServiceName"));
          int v30 = 138412290;
          *(void *)uint64_t v31 = v17;
          unsigned int v18 = (char *)_os_log_send_and_compose_impl( v15,  &v29,  0LL,  0LL,  &_mh_execute_header,  v16,  0LL,  "Unregistering from Bubble mach service %@",  &v30,  12);

          if (v18) {
            sub_100053B7C(v18);
          }
        }

        else
        {
          unsigned int v18 = 0LL;
        }

        free(v18);
      }

      uint64_t v19 = (__CFString *)objc_claimAutoreleasedReturnValue(-[RDClient machServiceName](v4, "machServiceName"));
      sub_100034D1C(v19);
    }

    sub_10002A0C4();
  }

  if (-[RDClient stakeholderIsRegistered](v4, "stakeholderIsRegistered")
    && -[RDClient hasUserSwitchTasks](v4, "hasUserSwitchTasks")
    && -[RDClient wasToldWillSwitchUser](v4, "wasToldWillSwitchUser"))
  {
    uint64_t v20 = sub_100018F4C(qword_1000DBD40);
    unsigned int v21 = (void *)objc_claimAutoreleasedReturnValue(v20);
    __int16 v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "pathForPID:error:", -[RDClient pid](v4, "pid"), 0));

    if (qword_1000DBA20 != -1) {
      dispatch_once(&qword_1000DBA20, &stru_1000CD228);
    }
    unsigned int v23 = (os_log_s *)(id)qword_1000DBA18;
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v29 = 0LL;
      LODWORD(v24) = sub_100053B4C(0);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v24 = v24;
      }
      else {
        uint64_t v24 = v24 & 0xFFFFFFFE;
      }
      if ((_DWORD)v24)
      {
        unsigned int v25 = v23;
        unsigned int v26 = -[RDClient pid](v4, "pid");
        int v30 = 67109378;
        *(_DWORD *)uint64_t v31 = v26;
        *(_WORD *)&v31[4] = 2114;
        *(void *)&v31[6] = v22;
        LODWORD(v2_Block_object_dispose(va, 8) = 18;
        unsigned int v27 = (char *)_os_log_send_and_compose_impl( v24,  &v29,  0LL,  0LL,  &_mh_execute_header,  v25,  0LL,  "PENDING BLOCKING SWITCH TASK AT SWITCH(Pid:%d):%{public}@",  &v30,  v28);

        if (v27) {
          sub_100053B7C(v27);
        }
      }

      else
      {
        unsigned int v27 = 0LL;
      }

      free(v27);
    }

    *a3 = 0;
  }
}

void sub_10000E1F8(uint64_t a1)
{
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  id v2 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t v38 = 0LL;
    unsigned int v3 = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      LOWORD(v37[0]) = 0;
      id v5 = (const char *)_os_log_send_and_compose_impl( v4,  v38,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "In readyToSwitchToLoginSession-CompletionHandler",  v37,  2);
      uint64_t v6 = (char *)v5;
      if (v5) {
        sub_100053B7C(v5);
      }
    }

    else
    {
      uint64_t v6 = 0LL;
    }

    free(v6);
  }

  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  id v7 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t v38 = 0LL;
    unsigned int v8 = sub_100053B4C(1);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v9 = v8;
    }
    else {
      uint64_t v9 = v8 & 0xFFFFFFFE;
    }
    if ((_DWORD)v9)
    {
      LOWORD(v37[0]) = 0;
      LODWORD(v35) = 2;
      unsigned int v10 = (const char *)_os_log_send_and_compose_impl( v9,  v38,  0LL,  0LL,  &_mh_execute_header,  v7,  0LL,  "XXXX: Moving the session type from :LOGINSESSION TYPE",  v37,  v35);
      uint64_t v11 = (char *)v10;
      if (v10) {
        sub_100053B7C(v10);
      }
    }

    else
    {
      uint64_t v11 = 0LL;
    }

    free(v11);
  }

  [*(id *)(a1 + 32) setSwitchState:0];
  dword_1000DBCF0 = 1;
  sub_10001AED4();
  [*(id *)(a1 + 32) _broadcastDeviceLoginSessionStateDidUpdate];
  unsigned int v12 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) fastLogoutTimer]);

  if (v12)
  {
    if (qword_1000DBA20 != -1) {
      dispatch_once(&qword_1000DBA20, &stru_1000CD228);
    }
    unsigned int v13 = (os_log_s *)(id)qword_1000DBA18;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      v37[0] = 0LL;
      LODWORD(v14) = sub_100053B4C(0);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v14 = v14;
      }
      else {
        uint64_t v14 = v14 & 0xFFFFFFFE;
      }
      if ((_DWORD)v14)
      {
        uint64_t v15 = *(void **)(a1 + 32);
        uint64_t v16 = v13;
        uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([v15 fastLogoutTimer]);
        *(_DWORD *)uint64_t v38 = 134217984;
        *(void *)&v38[4] = v17;
        unsigned int v18 = (char *)_os_log_send_and_compose_impl( v14,  v37,  0LL,  0LL,  &_mh_execute_header,  v16,  0LL,  "Fast logout timer (%p) already running, not starting another one",  v38);

        if (v18) {
          sub_100053B7C(v18);
        }
      }

      else
      {
        unsigned int v18 = 0LL;
      }

      free(v18);
    }
  }

  else
  {
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    uint64_t v19 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)uint64_t v38 = 0LL;
      unsigned int v20 = sub_100053B4C(1);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v21 = v20;
      }
      else {
        uint64_t v21 = v20 & 0xFFFFFFFE;
      }
      if ((_DWORD)v21)
      {
        LOWORD(v37[0]) = 0;
        LODWORD(v35) = 2;
        __int16 v22 = (const char *)_os_log_send_and_compose_impl( v21,  v38,  0LL,  0LL,  &_mh_execute_header,  v19,  0LL,  "Returning back without USR, setting 5min Max Duration of LoginSession",  v37,  v35);
        unsigned int v23 = (char *)v22;
        if (v22) {
          sub_100053B7C(v22);
        }
      }

      else
      {
        unsigned int v23 = 0LL;
      }

      free(v23);
    }

    dispatch_source_t v24 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0LL,  0LL,  (dispatch_queue_t)qword_1000DBD48);
    [*(id *)(a1 + 32) setFastLogoutTimer:v24];

    if (qword_1000DBA20 != -1) {
      dispatch_once(&qword_1000DBA20, &stru_1000CD228);
    }
    unsigned int v25 = (os_log_s *)(id)qword_1000DBA18;
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      v37[0] = 0LL;
      LODWORD(v26) = sub_100053B4C(0);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v26 = v26;
      }
      else {
        uint64_t v26 = v26 & 0xFFFFFFFE;
      }
      if ((_DWORD)v26)
      {
        unsigned int v27 = *(void **)(a1 + 32);
        uint64_t v28 = v25;
        uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([v27 fastLogoutTimer]);
        *(_DWORD *)uint64_t v38 = 134217984;
        *(void *)&v38[4] = v29;
        int v30 = (char *)_os_log_send_and_compose_impl( v26,  v37,  0LL,  0LL,  &_mh_execute_header,  v28,  0LL,  "Returning back without USR, starting 5 minute fast logout timer (%p)",  v38);

        if (v30) {
          sub_100053B7C(v30);
        }
      }

      else
      {
        int v30 = 0LL;
      }

      free(v30);
    }

    uint64_t v31 = (dispatch_source_s *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) fastLogoutTimer]);
    dispatch_time_t v32 = dispatch_time(0LL, 300000000000LL);
    dispatch_source_set_timer(v31, v32, 0xFFFFFFFFFFFFFFFFLL, 0LL);

    uint64_t v33 = (dispatch_source_s *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) fastLogoutTimer]);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472LL;
    handler[2] = sub_10000E7DC;
    handler[3] = &unk_1000CCF28;
    handler[4] = *(void *)(a1 + 32);
    dispatch_source_set_event_handler(v33, handler);

    uint64_t v34 = (dispatch_object_s *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) fastLogoutTimer]);
    dispatch_activate(v34);
  }

void sub_10000E7DC(uint64_t a1)
{
  if (qword_1000DBA20 != -1) {
    dispatch_once(&qword_1000DBA20, &stru_1000CD228);
  }
  id v2 = (os_log_s *)(id)qword_1000DBA18;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v27 = 0LL;
    LODWORD(v3) = sub_100053B4C(0);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v3 = v3;
    }
    else {
      uint64_t v3 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v3)
    {
      uint64_t v4 = *(void **)(a1 + 32);
      id v5 = v2;
      uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v4 fastLogoutTimer]);
      *(_DWORD *)uint64_t v26 = 134217984;
      *(void *)&v26[4] = v6;
      id v7 = (char *)_os_log_send_and_compose_impl( v3,  &v27,  0LL,  0LL,  &_mh_execute_header,  v5,  0LL,  "Fast logout timer (%p) fired",  v26);

      if (v7) {
        sub_100053B7C(v7);
      }
    }

    else
    {
      id v7 = 0LL;
    }

    free(v7);
  }

  unsigned int v8 = (dispatch_source_s *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) fastLogoutTimer]);
  dispatch_source_cancel(v8);

  [*(id *)(a1 + 32) setFastLogoutTimer:0];
  if (![*(id *)(a1 + 32) switchState])
  {
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    uint64_t v15 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)uint64_t v26 = 0LL;
      unsigned int v16 = sub_100053B4C(1);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v17 = v16;
      }
      else {
        uint64_t v17 = v16 & 0xFFFFFFFE;
      }
      if ((_DWORD)v17)
      {
        LOWORD(v27) = 0;
        unsigned int v18 = (const char *)_os_log_send_and_compose_impl( v17,  v26,  0LL,  0LL,  &_mh_execute_header,  v15,  0LL,  "CALLING SWITCH TO LOGINUSER as Logout Session MAX Time Duration expire",  &v27,  2);
        uint64_t v19 = (char *)v18;
        if (v18) {
          sub_100053B7C(v18);
        }
      }

      else
      {
        uint64_t v19 = 0LL;
      }

      free(v19);
    }

    if (sub_10002E9D0() == 1)
    {
      if (qword_1000DBA10 != -1) {
        dispatch_once(&qword_1000DBA10, &stru_1000CD208);
      }
      uint64_t v9 = (os_log_s *)(id)qword_1000DBA08;
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_54;
      }
      *(void *)uint64_t v26 = 0LL;
      unsigned int v20 = sub_100053B4C(1);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v21 = v20;
      }
      else {
        uint64_t v21 = v20 & 0xFFFFFFFE;
      }
      if (!(_DWORD)v21) {
        goto LABEL_52;
      }
      LOWORD(v27) = 0;
      LODWORD(v25) = 2;
      uint64_t v22 = _os_log_send_and_compose_impl( v21,  v26,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "Call to switchToUserSessionLoginwindow returns Success",  &v27,  v25);
    }

    else
    {
      if (qword_1000DBA10 != -1) {
        dispatch_once(&qword_1000DBA10, &stru_1000CD208);
      }
      uint64_t v9 = (os_log_s *)(id)qword_1000DBA08;
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_54;
      }
      *(void *)uint64_t v26 = 0LL;
      unsigned int v23 = sub_100053B4C(1);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v24 = v23;
      }
      else {
        uint64_t v24 = v23 & 0xFFFFFFFE;
      }
      if (!(_DWORD)v24) {
        goto LABEL_52;
      }
      LOWORD(v27) = 0;
      LODWORD(v25) = 2;
      uint64_t v22 = _os_log_send_and_compose_impl( v24,  v26,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "Call to switchToUserSessionLoginwindow returns Failure",  &v27,  v25);
    }

    uint64_t v14 = (void *)v22;
    if (!v22)
    {
LABEL_53:
      free(v14);
      goto LABEL_54;
    }

LABEL_51:
    sub_100053B7C((const char *)v14);
    goto LABEL_53;
  }

  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  uint64_t v9 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t v26 = 0LL;
    LODWORD(v10) = sub_100053B4C(1);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v10 = v10;
    }
    else {
      uint64_t v10 = v10 & 0xFFFFFFFE;
    }
    if ((_DWORD)v10)
    {
      uint64_t v11 = *(void **)(a1 + 32);
      unsigned int v12 = v9;
      unsigned int v13 = [v11 switchState];
      LODWORD(v27) = 67109120;
      HIDWORD(v27) = v13;
      uint64_t v14 = (void *)_os_log_send_and_compose_impl( v10,  v26,  0LL,  0LL,  &_mh_execute_header,  v12,  0LL,  "SwitchState in Log Session is set to %d, so no loginUser switch",  &v27);

      if (!v14) {
        goto LABEL_53;
      }
      goto LABEL_51;
    }

LABEL_52:
    uint64_t v14 = 0LL;
    goto LABEL_53;
  }

    uint64_t v27 = 0LL;
LABEL_53:
    free(v27);
    goto LABEL_54;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v2 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    dispatch_time_t v32 = 0LL;
    uint64_t v3 = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      id v5 = *(_DWORD *)(a1 + 40);
      LODWORD(v29) = 67109376;
      HIDWORD(v29) = v5;
      int v30 = 1024;
      uint64_t v31 = dword_1000DACB4;
      uint64_t v6 = (const char *)_os_log_send_and_compose_impl( v4,  &v32,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "Request config is %d, at the moment it is %d",  &v29,  14);
      id v7 = (char *)v6;
      if (v6) {
        sub_100053B7C(v6);
      }
    }

    else
    {
      id v7 = 0LL;
    }

    free(v7);
  }

  unsigned int v12 = *(_DWORD *)(a1 + 40);
  if (v12 != -1)
  {
    if (v12 >= 1 && v12 <= dword_1000DACB4)
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      unsigned int v13 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v29 = 0LL;
        uint64_t v14 = sub_100053B4C(1);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v15 = v14;
        }
        else {
          uint64_t v15 = v14 & 0xFFFFFFFE;
        }
        if ((_DWORD)v15)
        {
          unsigned int v16 = *(_DWORD *)(a1 + 40);
          LODWORD(v32) = 67109120;
          HIDWORD(v32) = v16;
          uint64_t v17 = (const char *)_os_log_send_and_compose_impl( v15,  &v29,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "NumUser config set to is %d",  &v32);
          unsigned int v18 = (char *)v17;
          if (v17) {
            sub_100053B7C(v17);
          }
        }

        else
        {
          unsigned int v18 = 0LL;
        }

        free(v18);
      }

      dword_1000DACB4 = *(_DWORD *)(a1 + 40);
      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = dword_1000DACB4;
      sub_10001AED4();
      return;
    }

    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = -1;
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v8 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
LABEL_54:

      return;
    }

    uint64_t v29 = 0LL;
    uint64_t v25 = sub_100053B4C(1);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v26 = v25;
    }
    else {
      uint64_t v26 = v25 & 0xFFFFFFFE;
    }
    if ((_DWORD)v26)
    {
      LOWORD(v32) = 0;
      LODWORD(v2_Block_object_dispose(va, 8) = 2;
      uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v26,  &v29,  0LL,  0LL,  &_mh_execute_header,  v8,  0LL,  "FAILED TO SET NumUser config",  &v32,  v28);
LABEL_50:
      uint64_t v27 = (char *)v11;
      if (v11) {
        sub_100053B7C(v11);
      }
      goto LABEL_53;
    }

    goto LABEL_52;
  }

  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = dword_1000DACB4;
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v19 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v29 = 0LL;
    unsigned int v20 = sub_100053B4C(1);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v21 = v20;
    }
    else {
      uint64_t v21 = v20 & 0xFFFFFFFE;
    }
    if ((_DWORD)v21)
    {
      uint64_t v22 = *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
      LODWORD(v32) = 67109120;
      HIDWORD(v32) = v22;
      unsigned int v23 = (const char *)_os_log_send_and_compose_impl( v21,  &v29,  0LL,  0LL,  &_mh_execute_header,  v19,  0LL,  "NumUser Query  returning %d",  &v32);
      uint64_t v24 = (char *)v23;
      if (v23) {
        sub_100053B7C(v23);
      }
    }

    else
    {
      uint64_t v24 = 0LL;
    }

    free(v24);
  }
}

    unsigned int v23 = 0LL;
LABEL_53:
    free(v23);
LABEL_54:

    goto LABEL_24;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v27 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v37 = 0LL;
    uint64_t v28 = sub_100053B4C(1);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v29 = v28;
    }
    else {
      uint64_t v29 = v28 & 0xFFFFFFFE;
    }
    if ((_DWORD)v29)
    {
      *(_DWORD *)int v39 = 136315138;
      *(void *)&v39[4] = a2;
      int v30 = (const char *)_os_log_send_and_compose_impl( v29,  &v37,  0LL,  0LL,  &_mh_execute_header,  v27,  0LL,  "Unset UF_IMMUTABLE on %s",  v39);
      uint64_t v31 = (char *)v30;
      if (v30) {
        sub_100053B7C(v30);
      }
    }

    else
    {
      uint64_t v31 = 0LL;
    }

    free(v31);
  }

  dispatch_time_t v32 = sub_100019434(qword_1000DBD40);
  uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue(v32);
  uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a2));
  uint64_t v35 = [v33 removeFileAtPath:v34 error:0];

  if ((v35 & 1) == 0) {
    goto LABEL_24;
  }
  return 0LL;
}

LABEL_54:
}

        uint64_t v26 = 0LL;
LABEL_55:
        free(v26);
      }
    }

    if (sub_100083DA4(v19, kUMUserSessionHasSyncBagKey) != 1)
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v34 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_160;
      }
      *(void *)v81 = 0LL;
      uint64_t v35 = sub_100053B4C(1);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT)) {
        unsigned int v36 = v35;
      }
      else {
        unsigned int v36 = v35 & 0xFFFFFFFE;
      }
      if ((_DWORD)v36)
      {
        LODWORD(v82) = 67109120;
        HIDWORD(v82) = a1;
        uint64_t v37 = (const char *)_os_log_send_and_compose_impl( v36,  v81,  0LL,  0LL,  &_mh_execute_header,  v34,  0LL,  "SyncBag does not exist for User:%d",  &v82);
        goto LABEL_156;
      }

      goto LABEL_158;
    }

    uint64_t v27 = sub_100083DF4(v19, kUMUserSessionVolumeDeviceNodeKey);
    if (!v27)
    {
LABEL_99:
      if (CFDictionaryContainsKey(v19, kUMUserSessionSyncMachServicesKey))
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        int v49 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)v81 = 0LL;
          v50 = sub_100053B4C(1);
          if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT)) {
            unsigned int v51 = v50;
          }
          else {
            unsigned int v51 = v50 & 0xFFFFFFFE;
          }
          if ((_DWORD)v51)
          {
            LODWORD(v82) = 67109120;
            HIDWORD(v82) = a1;
            uint64_t v52 = (const char *)_os_log_send_and_compose_impl( v51,  v81,  0LL,  0LL,  &_mh_execute_header,  v49,  0LL,  "Pending Sync services, so unload syncbag, but retain for user %d",  &v82);
            v53 = (char *)v52;
            if (v52) {
              sub_100053B7C(v52);
            }
          }

          else
          {
            v53 = 0LL;
          }

          free(v53);
        }

        if (sub_100033524(v19, a1))
        {
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          uint64_t v34 = (os_log_s *)(id)qword_1000DBA98;
          if (!os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_160;
          }
          *(void *)v81 = 0LL;
          v59 = sub_100053B4C(1);
          if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v60 = v59;
          }
          else {
            uint64_t v60 = v59 & 0xFFFFFFFE;
          }
          if ((_DWORD)v60)
          {
            LODWORD(v82) = 67109120;
            HIDWORD(v82) = a1;
            uint64_t v37 = (const char *)_os_log_send_and_compose_impl( v60,  v81,  0LL,  0LL,  &_mh_execute_header,  v34,  0LL,  "Failed to unload SyncBag for user:%d",  &v82);
            goto LABEL_156;
          }

void sub_10000EC74(uint64_t a1)
{
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  id v2 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = 0LL;
    unsigned int v3 = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      __int16 v16 = 0;
      id v5 = (const char *)_os_log_send_and_compose_impl( v4,  &v17,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "In readyToSwitchToUser-CompletionHandler",  &v16,  2);
      uint64_t v6 = (char *)v5;
      if (v5) {
        sub_100053B7C(v5);
      }
    }

    else
    {
      uint64_t v6 = 0LL;
    }

    free(v6);
  }

  id v7 = *(const __CFDictionary **)(a1 + 32);
  if (CFDictionaryContainsKey(v7, @"UserSwitchTaskOpqueData"))
  {
    Value = CFDictionaryGetValue(v7, @"UserSwitchTaskOpqueData");
    uint64_t v9 = (const __CFData *)CFRetain(Value);
    CFDictionaryRemoveValue(v7, @"UserSwitchTaskOpqueData");
  }

  else
  {
    uint64_t v9 = 0LL;
  }

  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  uint64_t v10 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = 0LL;
    unsigned int v11 = sub_100053B4C(1);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v12 = v11;
    }
    else {
      uint64_t v12 = v11 & 0xFFFFFFFE;
    }
    if ((_DWORD)v12)
    {
      __int16 v16 = 0;
      LODWORD(v15) = 2;
      unsigned int v13 = (const char *)_os_log_send_and_compose_impl( v12,  &v17,  0LL,  0LL,  &_mh_execute_header,  v10,  0LL,  "calling USR",  &v16,  v15);
      uint64_t v14 = (char *)v13;
      if (v13) {
        sub_100053B7C(v13);
      }
    }

    else
    {
      uint64_t v14 = 0LL;
    }

    free(v14);
  }

  sub_10002EAB0(v7, v9);
}

void sub_10000EF5C(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _clientForPID:*(unsigned int *)(a1 + 56)]);
  if (v2)
  {
    uint64_t v3 = sub_100018F4C(qword_1000DBD40);
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
    id v5 = (void *)objc_claimAutoreleasedReturnValue([v4 pathForPID:*(unsigned int *)(a1 + 56) error:0]);

    if (qword_1000DBA20 != -1) {
      dispatch_once(&qword_1000DBA20, &stru_1000CD228);
    }
    uint64_t v6 = (os_log_s *)(id)qword_1000DBA18;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = 0LL;
      unsigned int v7 = sub_100053B4C(0);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v8 = v7;
      }
      else {
        uint64_t v8 = v7 & 0xFFFFFFFE;
      }
      if ((_DWORD)v8)
      {
        int v9 = *(_DWORD *)(a1 + 56);
        uint64_t v10 = *(void *)(a1 + 40);
        int v22 = 67109634;
        int v23 = v9;
        __int16 v24 = 2114;
        uint64_t v25 = v5;
        __int16 v26 = 2114;
        uint64_t v27 = v10;
        unsigned int v11 = (const char *)_os_log_send_and_compose_impl( v8,  &v21,  0LL,  0LL,  &_mh_execute_header,  v6,  0LL,  "Adding BlockSwitchTask(pid:%d,%{public}@) %{public}@",  &v22,  28);
        uint64_t v12 = (char *)v11;
        if (v11) {
          sub_100053B7C(v11);
        }
      }

      else
      {
        uint64_t v12 = 0LL;
      }

      free(v12);
    }

    [v2 addUserSwitchTask:*(void *)(a1 + 40)];
    [*(id *)(a1 + 32) _broadcastUserSwitchTaskListDidUpdate];
    if (qword_1000DBA20 != -1) {
      dispatch_once(&qword_1000DBA20, &stru_1000CD228);
    }
    unsigned int v13 = (os_log_s *)(id)qword_1000DBA18;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = 0LL;
      unsigned int v14 = sub_100053B4C(0);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v15 = v14;
      }
      else {
        uint64_t v15 = v14 & 0xFFFFFFFE;
      }
      if ((_DWORD)v15)
      {
        int v16 = *(_DWORD *)(a1 + 56);
        int v22 = 67109378;
        int v23 = v16;
        __int16 v24 = 2114;
        uint64_t v25 = v5;
        LODWORD(v20) = 18;
        uint64_t v17 = (const char *)_os_log_send_and_compose_impl( v15,  &v21,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "Adding BlockSwitchTask(pid:%d,%{public}@) DONE",  &v22,  v20);
        unsigned int v18 = (char *)v17;
        if (v17) {
          sub_100053B7C(v17);
        }
      }

      else
      {
        unsigned int v18 = 0LL;
      }

      free(v18);
    }
  }

  uint64_t v19 = *(void *)(a1 + 48);
  if (v19) {
    (*(void (**)(uint64_t, void))(v19 + 16))(v19, 0LL);
  }
}

void sub_10000F2D0(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _clientForPID:*(unsigned int *)(a1 + 56)]);
  if (v2)
  {
    uint64_t v3 = sub_100018F4C(qword_1000DBD40);
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
    id v5 = (void *)objc_claimAutoreleasedReturnValue([v4 pathForPID:*(unsigned int *)(a1 + 56) error:0]);

    if (qword_1000DBA20 != -1) {
      dispatch_once(&qword_1000DBA20, &stru_1000CD228);
    }
    uint64_t v6 = (os_log_s *)(id)qword_1000DBA18;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v26[0] = 0LL;
      unsigned int v7 = sub_100053B4C(0);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v8 = v7;
      }
      else {
        uint64_t v8 = v7 & 0xFFFFFFFE;
      }
      if ((_DWORD)v8)
      {
        int v9 = *(_DWORD *)(a1 + 56);
        uint64_t v10 = *(void *)(a1 + 40);
        LODWORD(v27) = 67109634;
        HIDWORD(v27) = v9;
        __int16 v28 = 2114;
        uint64_t v29 = v5;
        __int16 v30 = 2112;
        uint64_t v31 = v10;
        unsigned int v11 = (const char *)_os_log_send_and_compose_impl( v8,  v26,  0LL,  0LL,  &_mh_execute_header,  v6,  0LL,  "Removing BlockSwitchTask(pid:%d,%{public}@) %@",  &v27,  28);
        uint64_t v12 = (char *)v11;
        if (v11) {
          sub_100053B7C(v11);
        }
      }

      else
      {
        uint64_t v12 = 0LL;
      }

      free(v12);
    }

    if ([v2 removeUserSwitchTask:*(void *)(a1 + 40)])
    {
      [*(id *)(a1 + 32) _broadcastUserSwitchTaskListDidUpdate];
      if (qword_1000DBA10 != -1) {
        dispatch_once(&qword_1000DBA10, &stru_1000CD208);
      }
      unsigned int v13 = (os_log_s *)(id)qword_1000DBA08;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v27 = 0LL;
        unsigned int v14 = sub_100053B4C(1);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v15 = v14;
        }
        else {
          uint64_t v15 = v14 & 0xFFFFFFFE;
        }
        if ((_DWORD)v15)
        {
          LOWORD(v26[0]) = 0;
          LODWORD(v25) = 2;
          int v16 = (const char *)_os_log_send_and_compose_impl( v15,  &v27,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "remove BlockSwitch Task checking -> _checkIfWeShouldSwitchUser",  v26,  v25);
          uint64_t v17 = (char *)v16;
          if (v16) {
            sub_100053B7C(v16);
          }
        }

        else
        {
          uint64_t v17 = 0LL;
        }

        free(v17);
      }

      [*(id *)(a1 + 32) _checkIfWeShouldSwitchUser:dword_1000DBCF0 == 3];
      if (qword_1000DBA20 != -1) {
        dispatch_once(&qword_1000DBA20, &stru_1000CD228);
      }
      unsigned int v18 = (os_log_s *)(id)qword_1000DBA18;
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        v26[0] = 0LL;
        unsigned int v19 = sub_100053B4C(0);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v20 = v19;
        }
        else {
          uint64_t v20 = v19 & 0xFFFFFFFE;
        }
        if ((_DWORD)v20)
        {
          int v21 = *(_DWORD *)(a1 + 56);
          LODWORD(v27) = 67109378;
          HIDWORD(v27) = v21;
          __int16 v28 = 2114;
          uint64_t v29 = v5;
          LODWORD(v25) = 18;
          int v22 = (const char *)_os_log_send_and_compose_impl( v20,  v26,  0LL,  0LL,  &_mh_execute_header,  v18,  0LL,  "Removed switch task(pid:%d, %{public}@)",  &v27,  v25);
          int v23 = (char *)v22;
          if (v22) {
            sub_100053B7C(v22);
          }
        }

        else
        {
          int v23 = 0LL;
        }

        free(v23);
      }
    }
  }

  uint64_t v24 = *(void *)(a1 + 48);
  if (v24) {
    (*(void (**)(uint64_t, void))(v24 + 16))(v24, 0LL);
  }
}

void sub_10000F68C(id a1, RDClient *a2, BOOL *a3)
{
  uint64_t v3 = a2;
  if (-[RDClient stakeholderIsRegistered](v3, "stakeholderIsRegistered")
    && -[RDClient criticalStakeHolder](v3, "criticalStakeHolder"))
  {
    -[RDClient userSwitchTaskListDidUpdate](v3, "userSwitchTaskListDidUpdate");
  }
}

void sub_10000F6D8(id a1, RDClient *a2, BOOL *a3)
{
  uint64_t v3 = a2;
  if (-[RDClient stakeholderIsRegistered](v3, "stakeholderIsRegistered")
    && -[RDClient criticalStakeHolder](v3, "criticalStakeHolder"))
  {
    -[RDClient deviceLoginSessionStateDidUpdate](v3, "deviceLoginSessionStateDidUpdate");
  }
}

void sub_10000F79C(uint64_t a1)
{
  id v2 = objc_opt_new(&OBJC_CLASS___NSMutableArray);
  uint64_t v3 = *(void **)(a1 + 32);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_10000F838;
  v5[3] = &unk_1000CD090;
  uint64_t v6 = v2;
  uint64_t v4 = v2;
  [v3 _enumerateClientsWithBlock:v5];
  (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
}

void sub_10000F838(uint64_t a1, void *a2)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = (id)objc_claimAutoreleasedReturnValue([a2 userSwitchTasks]);
  [v2 addObjectsFromArray:v3];
}

void sub_10000F8FC(uint64_t a1, void *a2)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = (id)objc_claimAutoreleasedReturnValue([a2 userSyncTasks]);
  [v2 addObjectsFromArray:v3];
}

void sub_10000F9C0(uint64_t a1, void *a2)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = (id)objc_claimAutoreleasedReturnValue([a2 userSwitchTasks]);
  [v2 addObjectsFromArray:v3];
}

void sub_10000FACC(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _clientForPID:*(unsigned int *)(a1 + 56)]);
  id v3 = v2;
  if (v2)
  {
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v2 machServiceName]);

    if (v4)
    {
      uint64_t v5 = sub_100018F4C(qword_1000DBD40);
      uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
      unsigned int v7 = (void *)objc_claimAutoreleasedReturnValue([v6 pathForPID:*(unsigned int *)(a1 + 56) error:0]);

      if (qword_1000DBA20 != -1) {
        dispatch_once(&qword_1000DBA20, &stru_1000CD228);
      }
      uint64_t v8 = (os_log_s *)(id)qword_1000DBA18;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        v25[0] = 0LL;
        unsigned int v9 = sub_100053B4C(0);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v10 = v9;
        }
        else {
          uint64_t v10 = v9 & 0xFFFFFFFE;
        }
        if ((_DWORD)v10)
        {
          int v11 = *(_DWORD *)(a1 + 56);
          uint64_t v12 = *(void *)(a1 + 40);
          LODWORD(v26) = 67109634;
          HIDWORD(v26) = v11;
          __int16 v27 = 2114;
          __int16 v28 = v7;
          __int16 v29 = 2114;
          uint64_t v30 = v12;
          unsigned int v13 = (const char *)_os_log_send_and_compose_impl( v10,  v25,  0LL,  0LL,  &_mh_execute_header,  v8,  0LL,  "Adding Sync Task(pid:%d,%{public}@) %{public}@",  &v26,  28);
          unsigned int v14 = (char *)v13;
          if (v13) {
            sub_100053B7C(v13);
          }
        }

        else
        {
          unsigned int v14 = 0LL;
        }

        free(v14);
      }

      [v3 addUserSyncTask:*(void *)(a1 + 40)];
      uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v3 userSyncTasks]);
      id v16 = [v15 count];

      if (v16 == (id)1)
      {
        if (qword_1000DBA10 != -1) {
          dispatch_once(&qword_1000DBA10, &stru_1000CD208);
        }
        uint64_t v17 = (os_log_s *)(id)qword_1000DBA08;
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v26 = 0LL;
          unsigned int v18 = sub_100053B4C(1);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v19 = v18;
          }
          else {
            uint64_t v19 = v18 & 0xFFFFFFFE;
          }
          if ((_DWORD)v19)
          {
            LOWORD(v25[0]) = 0;
            LODWORD(v24) = 2;
            uint64_t v20 = (const char *)_os_log_send_and_compose_impl( v19,  &v26,  0LL,  0LL,  &_mh_execute_header,  v17,  0LL,  "Adding mach service for bubble due to arrival of first sync tasks",  v25,  v24);
            int v21 = (char *)v20;
            if (v20) {
              sub_100053B7C(v20);
            }
          }

          else
          {
            int v21 = 0LL;
          }

          free(v21);
        }

        int v22 = (__CFString *)objc_claimAutoreleasedReturnValue([v3 machServiceName]);
        sub_100034290(v22);
      }
    }
  }

  uint64_t v23 = *(void *)(a1 + 48);
  if (v23) {
    (*(void (**)(uint64_t, void))(v23 + 16))(v23, 0LL);
  }
}

void sub_10000FE70(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _clientForPID:*(unsigned int *)(a1 + 56)]);
  if (v2)
  {
    uint64_t v3 = sub_100018F4C(qword_1000DBD40);
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v4 pathForPID:*(unsigned int *)(a1 + 56) error:0]);

    if (qword_1000DBA20 != -1) {
      dispatch_once(&qword_1000DBA20, &stru_1000CD228);
    }
    uint64_t v6 = (os_log_s *)(id)qword_1000DBA18;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v23[0] = 0LL;
      unsigned int v7 = sub_100053B4C(0);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v8 = v7;
      }
      else {
        uint64_t v8 = v7 & 0xFFFFFFFE;
      }
      if ((_DWORD)v8)
      {
        int v9 = *(_DWORD *)(a1 + 56);
        uint64_t v10 = *(void *)(a1 + 40);
        LODWORD(v24) = 67109634;
        HIDWORD(v24) = v9;
        __int16 v25 = 2114;
        uint64_t v26 = v5;
        __int16 v27 = 2114;
        uint64_t v28 = v10;
        int v11 = (const char *)_os_log_send_and_compose_impl( v8,  v23,  0LL,  0LL,  &_mh_execute_header,  v6,  0LL,  "Removing Sync Task(pid:%d,%{public}@) %{public}@",  &v24,  28);
        uint64_t v12 = (char *)v11;
        if (v11) {
          sub_100053B7C(v11);
        }
      }

      else
      {
        uint64_t v12 = 0LL;
      }

      free(v12);
    }

    [v2 removeUserSyncTask:*(void *)(a1 + 40)];
    unsigned int v13 = (void *)objc_claimAutoreleasedReturnValue([v2 userSyncTasks]);
    id v14 = [v13 count];

    if (!v14)
    {
      if (qword_1000DBA10 != -1) {
        dispatch_once(&qword_1000DBA10, &stru_1000CD208);
      }
      uint64_t v15 = (os_log_s *)(id)qword_1000DBA08;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v24 = 0LL;
        unsigned int v16 = sub_100053B4C(1);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v17 = v16;
        }
        else {
          uint64_t v17 = v16 & 0xFFFFFFFE;
        }
        if ((_DWORD)v17)
        {
          LOWORD(v23[0]) = 0;
          LODWORD(v22) = 2;
          unsigned int v18 = (const char *)_os_log_send_and_compose_impl( v17,  &v24,  0LL,  0LL,  &_mh_execute_header,  v15,  0LL,  "Removing mach service for bubble as no pending sync tasks",  v23,  v22);
          uint64_t v19 = (char *)v18;
          if (v18) {
            sub_100053B7C(v18);
          }
        }

        else
        {
          uint64_t v19 = 0LL;
        }

        free(v19);
      }

      uint64_t v20 = (__CFString *)objc_claimAutoreleasedReturnValue([v2 machServiceName]);
      sub_100034D1C(v20);
    }
  }

  uint64_t v21 = *(void *)(a1 + 48);
  if (v21) {
    (*(void (**)(uint64_t, void))(v21 + 16))(v21, 0LL);
  }
}

void sub_1000101C0(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  45LL,  0LL));
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3)
  {
    uint64_t v4 = v2;
    (*(void (**)(void))(v3 + 16))();
    id v2 = v4;
  }
}

void sub_1000102A4(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  45LL,  0LL));
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3)
  {
    uint64_t v4 = v2;
    (*(void (**)(void))(v3 + 16))();
    id v2 = v4;
  }
}

void sub_100010570(uint64_t a1)
{
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  id v2 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)v85 = 0LL;
    unsigned int v3 = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      int v5 = *(_DWORD *)(a1 + 72);
      LODWORD(v81) = 67109120;
      HIDWORD(v81) = v5;
      uint64_t v6 = (const char *)_os_log_send_and_compose_impl( v4,  v85,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "In RDServer: createPersona from pid:%d",  &v81);
      unsigned int v7 = (char *)v6;
      if (v6) {
        sub_100053B7C(v6);
      }
    }

    else
    {
      unsigned int v7 = 0LL;
    }

    free(v7);
  }

  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _clientForPID:*(unsigned int *)(a1 + 72)]);
  int v9 = v8;
  if (v8) {
    unsigned __int8 v10 = [v8 hasEntitlement:@"com.apple.usermanagerd.persona.create"];
  }
  else {
    unsigned __int8 v10 = [*(id *)(a1 + 32) remoteProcessHasBooleanEntitlement:@"com.apple.usermanagerd.persona.create"];
  }
  if ((v10 & 1) != 0)
  {
    if (*(void *)(a1 + 40))
    {
      if (*(void *)(a1 + 64) < 2uLL)
      {
        id v11 = *(id *)(a1 + 48);
        if (*(void *)(a1 + 64) != 1LL)
        {
LABEL_103:
          LODWORD(v7_Block_object_dispose(va, 8) = 0;
          unsigned int v79 = -1;
          id v51 = [*(id *)(a1 + 32) asidForClient:v9 withAuid:&v79 withPid:*(unsigned int *)(a1 + 72)];
          if (qword_1000DBA10 != -1) {
            dispatch_once(&qword_1000DBA10, &stru_1000CD208);
          }
          uint64_t v52 = (os_log_s *)(id)qword_1000DBA08;
          if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v81 = 0LL;
            unsigned int v53 = sub_100053B4C(1);
            if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v54 = v53;
            }
            else {
              uint64_t v54 = v53 & 0xFFFFFFFE;
            }
            if ((_DWORD)v54)
            {
              uint64_t v55 = *(void *)(a1 + 40);
              int v56 = *(_DWORD *)(a1 + 72);
              *(_DWORD *)v85 = 138412802;
              *(void *)&v85[4] = v55;
              *(_WORD *)&v85[12] = 1024;
              *(_DWORD *)&v85[14] = v56;
              *(_WORD *)&v85[18] = 1024;
              *(_DWORD *)&v85[20] = (_DWORD)v51;
              LODWORD(v76) = 24;
              uint64_t v57 = (const char *)_os_log_send_and_compose_impl( v54,  &v81,  0LL,  0LL,  &_mh_execute_header,  v52,  0LL,  "In RDServer: entitlement OK, calling createpersonasession with profileInfo:%@ for pi d:%d for asid:%d",  v85,  v76);
              v58 = (char *)v57;
              if (v57) {
                sub_100053B7C(v57);
              }
            }

            else
            {
              v58 = 0LL;
            }

            free(v58);
          }

          v59 = sub_100046664((uint64_t)v51, v79, *(unsigned int *)(a1 + 76));
          uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue(v59);
          uint64_t v61 = sub_100046868(*(void *)(a1 + 40), v11, v60, 1, (unsigned int *)&v78);
          __int128 v62 = (void *)v61;
          if (v61 || !(_DWORD)v78)
          {
            if (v61)
            {
              if (qword_1000DBA10 != -1) {
                dispatch_once(&qword_1000DBA10, &stru_1000CD208);
              }
              __int16 v68 = (os_log_s *)(id)qword_1000DBA08;
              if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v81 = 0LL;
                unsigned int v69 = sub_100053B4C(1);
                if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT)) {
                  uint64_t v70 = v69;
                }
                else {
                  uint64_t v70 = v69 & 0xFFFFFFFE;
                }
                if ((_DWORD)v70)
                {
                  *(_DWORD *)v85 = 138412290;
                  *(void *)&v85[4] = v62;
                  LODWORD(v76) = 12;
                  v71 = (const char *)_os_log_send_and_compose_impl( v70,  &v81,  0LL,  0LL,  &_mh_execute_header,  v68,  0LL,  "Persona Created Successfully:%@",  v85,  v76);
                  v72 = (char *)v71;
                  if (v71) {
                    sub_100053B7C(v71);
                  }
                }

                else
                {
                  v72 = 0LL;
                }

                free(v72);
              }

              [*(id *)(a1 + 32) _broadcastPersonaUpdates:v60 withAuid:v79];
            }

            uint64_t v75 = *(void *)(a1 + 56);
            if (v75) {
              (*(void (**)(uint64_t, void *, void))(v75 + 16))(v75, v62, 0LL);
            }
          }

          else
          {
            if (qword_1000DBA10 != -1) {
              dispatch_once(&qword_1000DBA10, &stru_1000CD208);
            }
            __int128 v63 = (os_log_s *)(id)qword_1000DBA08;
            if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
            {
              *(void *)v85 = 0LL;
              unsigned int v64 = sub_100053B4C(1);
              if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v65 = v64;
              }
              else {
                uint64_t v65 = v64 & 0xFFFFFFFE;
              }
              if ((_DWORD)v65)
              {
                LOWORD(v81) = 0;
                LODWORD(v76) = 2;
                v66 = (const char *)_os_log_send_and_compose_impl( v65,  v85,  0LL,  0LL,  &_mh_execute_header,  v63,  0LL,  "FAILEd to create persona session",  &v81,  v76);
                uint64_t v67 = (char *)v66;
                if (v66) {
                  sub_100053B7C(v66);
                }
              }

              else
              {
                uint64_t v67 = 0LL;
              }

              free(v67);
            }

            uint64_t v73 = *(void *)(a1 + 56);
            if (v73)
            {
              v74 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  (int)v78,  0LL));
              (*(void (**)(uint64_t, void, void *))(v73 + 16))(v73, 0LL, v74);
            }
          }

          goto LABEL_145;
        }

        *(void *)v85 = 0LL;
        *(void *)&v85[8] = v85;
        *(void *)&v85[16] = 0x3032000000LL;
        v86 = sub_100011264;
        v87 = sub_100011274;
        id v88 = 0LL;
        uint64_t v81 = 0LL;
        v82 = &v81;
        uint64_t v83 = 0x2020000000LL;
        int v84 = 0;
        uint64_t v12 = (__n128 *)ACMContextCreateWithExternalForm( [*(id *)(a1 + 48) bytes], (uint64_t)objc_msgSend(*(id *)(a1 + 48), "length"));
        unsigned int v13 = v12;
        if (v12)
        {
          v77[0] = _NSConcreteStackBlock;
          v77[1] = 3221225472LL;
          v77[2] = sub_10001127C;
          v77[3] = &unk_1000CD108;
          v77[4] = &v81;
          v77[5] = v85;
          ACMContextCredentialGetProperty(v12, 0xDu, 0x2BDu, (uint64_t)v77);
          int v14 = ACMContextDelete(v13, 0);
          if (v14)
          {
            if (qword_1000DBA10 != -1) {
              dispatch_once(&qword_1000DBA10, &stru_1000CD208);
            }
            uint64_t v15 = (os_log_s *)(id)qword_1000DBA08;
            if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v78 = 0LL;
              unsigned int v16 = sub_100053B4C(1);
              if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v17 = v16;
              }
              else {
                uint64_t v17 = v16 & 0xFFFFFFFE;
              }
              if ((_DWORD)v17)
              {
                unsigned int v79 = 67109120;
                int v80 = v14;
                unsigned int v18 = (const char *)_os_log_send_and_compose_impl( v17,  &v78,  0LL,  0LL,  &_mh_execute_header,  v15,  0LL,  "In RDServer: Failed to delete ACM context: %d",  &v79);
                uint64_t v19 = (char *)v18;
                if (v18) {
                  sub_100053B7C(v18);
                }
              }

              else
              {
                uint64_t v19 = 0LL;
              }

              free(v19);
            }
          }

          if (!*((_DWORD *)v82 + 6))
          {
            int v49 = v11;
            LOBYTE(v50) = 1;
            id v11 = *(id *)(*(void *)&v85[8] + 40LL);
LABEL_101:

            goto LABEL_102;
          }

          if (qword_1000DBA10 != -1) {
            dispatch_once(&qword_1000DBA10, &stru_1000CD208);
          }
          v43 = (os_log_s *)(id)qword_1000DBA08;
          if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v78 = 0LL;
            unsigned int v44 = sub_100053B4C(1);
            if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v45 = v44;
            }
            else {
              uint64_t v45 = v44 & 0xFFFFFFFE;
            }
            if ((_DWORD)v45)
            {
              int v46 = *((_DWORD *)v82 + 6);
              unsigned int v79 = 67109120;
              int v80 = v46;
              uint64_t v47 = (const char *)_os_log_send_and_compose_impl( v45,  &v78,  0LL,  0LL,  &_mh_execute_header,  v43,  0LL,  "In RDServer: entitlement OK, but failed to extract plaintext password from context: %d",  &v79);
              __int16 v48 = (char *)v47;
              if (v47) {
                sub_100053B7C(v47);
              }
            }

            else
            {
              __int16 v48 = 0LL;
            }

            free(v48);
          }

          uint64_t v50 = *(void *)(a1 + 56);
          if (v50)
          {
            int v49 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  22LL,  0LL));
            (*(void (**)(uint64_t, void, void *))(v50 + 16))(v50, 0LL, v49);
LABEL_100:
            LOBYTE(v50) = 0;
            goto LABEL_101;
          }
        }

        else
        {
          if (qword_1000DBA10 != -1) {
            dispatch_once(&qword_1000DBA10, &stru_1000CD208);
          }
          uint64_t v38 = (os_log_s *)(id)qword_1000DBA08;
          if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v78 = 0LL;
            unsigned int v39 = sub_100053B4C(1);
            if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v40 = v39;
            }
            else {
              uint64_t v40 = v39 & 0xFFFFFFFE;
            }
            if ((_DWORD)v40)
            {
              LOWORD(v79) = 0;
              unsigned int v41 = (const char *)_os_log_send_and_compose_impl( v40,  &v78,  0LL,  0LL,  &_mh_execute_header,  v38,  0LL,  "In RDServer: entitlement OK, but failed to import externalized context data",  &v79,  2);
              uint64_t v42 = (char *)v41;
              if (v41) {
                sub_100053B7C(v41);
              }
            }

            else
            {
              uint64_t v42 = 0LL;
            }

            free(v42);
          }

          uint64_t v50 = *(void *)(a1 + 56);
          if (v50)
          {
            int v49 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  22LL,  0LL));
            (*(void (**)(uint64_t, void, void *))(v50 + 16))(v50, 0LL, v49);
            goto LABEL_100;
          }
        }

LABEL_102:
        _Block_object_dispose(&v81, 8);
        _Block_object_dispose(v85, 8);

        if ((v50 & 1) != 0) {
          goto LABEL_103;
        }
LABEL_145:

        goto LABEL_146;
      }

      if (qword_1000DBA10 != -1) {
        dispatch_once(&qword_1000DBA10, &stru_1000CD208);
      }
      uint64_t v31 = (os_log_s *)(id)qword_1000DBA08;
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)v85 = 0LL;
        unsigned int v32 = sub_100053B4C(1);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v33 = v32;
        }
        else {
          uint64_t v33 = v32 & 0xFFFFFFFE;
        }
        if ((_DWORD)v33)
        {
          LOWORD(v81) = 0;
          uint64_t v34 = (const char *)_os_log_send_and_compose_impl( v33,  v85,  0LL,  0LL,  &_mh_execute_header,  v31,  0LL,  "In RDServer: entitlement OK, but invalid passcode data type",  &v81,  2);
          uint64_t v35 = (char *)v34;
          if (v34) {
            sub_100053B7C(v34);
          }
        }

        else
        {
          uint64_t v35 = 0LL;
        }

        free(v35);
      }

      uint64_t v37 = *(void *)(a1 + 56);
      if (v37)
      {
LABEL_64:
        id v11 = (id)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  22LL,  0LL));
        (*(void (**)(uint64_t, void, id))(v37 + 16))(v37, 0LL, v11);
        goto LABEL_145;
      }
    }

    else
    {
      if (qword_1000DBA10 != -1) {
        dispatch_once(&qword_1000DBA10, &stru_1000CD208);
      }
      uint64_t v26 = (os_log_s *)(id)qword_1000DBA08;
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)v85 = 0LL;
        unsigned int v27 = sub_100053B4C(1);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v28 = v27;
        }
        else {
          uint64_t v28 = v27 & 0xFFFFFFFE;
        }
        if ((_DWORD)v28)
        {
          LOWORD(v81) = 0;
          __int16 v29 = (const char *)_os_log_send_and_compose_impl( v28,  v85,  0LL,  0LL,  &_mh_execute_header,  v26,  0LL,  "In RDServer: entitlement OK, but invalid profileInfo",  &v81,  2);
          uint64_t v30 = (char *)v29;
          if (v29) {
            sub_100053B7C(v29);
          }
        }

        else
        {
          uint64_t v30 = 0LL;
        }

        free(v30);
      }

      uint64_t v37 = *(void *)(a1 + 56);
      if (v37) {
        goto LABEL_64;
      }
    }
  }

  else
  {
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    uint64_t v20 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)v85 = 0LL;
      unsigned int v21 = sub_100053B4C(1);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v22 = v21;
      }
      else {
        uint64_t v22 = v21 & 0xFFFFFFFE;
      }
      if ((_DWORD)v22)
      {
        int v23 = *(_DWORD *)(a1 + 72);
        LODWORD(v81) = 67109120;
        HIDWORD(v81) = v23;
        uint64_t v24 = (const char *)_os_log_send_and_compose_impl( v22,  v85,  0LL,  0LL,  &_mh_execute_header,  v20,  0LL,  "In RDServer: createPersona No entitlement pid:%d",  &v81);
        __int16 v25 = (char *)v24;
        if (v24) {
          sub_100053B7C(v24);
        }
      }

      else
      {
        __int16 v25 = 0LL;
      }

      free(v25);
    }

    uint64_t v36 = *(void *)(a1 + 56);
    if (v36)
    {
      id v11 = (id)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  1LL,  0LL));
      (*(void (**)(uint64_t, void, id))(v36 + 16))(v36, 0LL, v11);
      goto LABEL_145;
    }
  }

LABEL_146:
}

void sub_10001121C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  uint64_t v14 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100011264(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_100011274(uint64_t a1)
{
}

void sub_10001127C(uint64_t a1, int a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = a2;
  if (!*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
  {
    uint64_t v3 = objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:"));
    uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8LL);
    int v5 = *(void **)(v4 + 40);
    *(void *)(v4 + 40) = v3;
  }

void sub_100011508(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _clientForPID:*(unsigned int *)(a1 + 56)]);
  unsigned int v40 = -1;
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  uint64_t v3 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v39 = 0LL;
    unsigned int v4 = sub_100053B4C(1);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = v4 & 0xFFFFFFFE;
    }
    if ((_DWORD)v5)
    {
      int v6 = *(_DWORD *)(a1 + 56);
      int v41 = 67109120;
      int v42 = v6;
      unsigned int v7 = (const char *)_os_log_send_and_compose_impl( v5,  &v39,  0LL,  0LL,  &_mh_execute_header,  v3,  0LL,  "In RDServer: deletePersona from pid:%d",  &v41);
      uint64_t v8 = (char *)v7;
      if (v7) {
        sub_100053B7C(v7);
      }
    }

    else
    {
      uint64_t v8 = 0LL;
    }

    free(v8);
  }

  if (v2)
  {
LABEL_26:
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    uint64_t v19 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v39 = 0LL;
      unsigned int v20 = sub_100053B4C(1);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v21 = v20;
      }
      else {
        uint64_t v21 = v20 & 0xFFFFFFFE;
      }
      if ((_DWORD)v21)
      {
        int v22 = *(_DWORD *)(a1 + 56);
        int v41 = 67109120;
        int v42 = v22;
        int v23 = (const char *)_os_log_send_and_compose_impl( v21,  &v39,  0LL,  0LL,  &_mh_execute_header,  v19,  0LL,  "In RDServer: deletePersona No entitlement pid:%d",  &v41);
        uint64_t v24 = (char *)v23;
        if (v23) {
          sub_100053B7C(v23);
        }
      }

      else
      {
        uint64_t v24 = 0LL;
      }

      free(v24);
    }

    NSErrorDomain v35 = NSPOSIXErrorDomain;
    uint64_t v36 = 1LL;
    goto LABEL_62;
  }

  if (([*(id *)(a1 + 32) remoteProcessHasBooleanEntitlement:@"com.apple.usermanagerd.persona.delete"] & 1) == 0) {
    goto LABEL_26;
  }
LABEL_14:
  if (!*(void *)(a1 + 40))
  {
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    __int16 v25 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v39 = 0LL;
      unsigned int v26 = sub_100053B4C(1);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v27 = v26;
      }
      else {
        uint64_t v27 = v26 & 0xFFFFFFFE;
      }
      if ((_DWORD)v27)
      {
        LOWORD(v41) = 0;
        uint64_t v28 = (const char *)_os_log_send_and_compose_impl( v27,  &v39,  0LL,  0LL,  &_mh_execute_header,  v25,  0LL,  "In RDServer: entitlement OK, but invalid profileInfo",  &v41,  2);
        __int16 v29 = (char *)v28;
        if (v28) {
          sub_100053B7C(v28);
        }
      }

      else
      {
        __int16 v29 = 0LL;
      }

      free(v29);
    }

    NSErrorDomain v35 = NSPOSIXErrorDomain;
    uint64_t v36 = 22LL;
LABEL_62:
    uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  v35,  v36,  0LL));
    goto LABEL_67;
  }

  id v9 = [*(id *)(a1 + 32) asidForClient:v2 withAuid:&v40 withPid:*(unsigned int *)(a1 + 56)];
  unsigned __int8 v10 = sub_100046664((uint64_t)v9, v40, *(unsigned int *)(a1 + 60));
  id v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
  int v12 = sub_100046A1C(*(const __CFDictionary **)(a1 + 40), v11);
  if (v12)
  {
    int v13 = v12;
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    uint64_t v14 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v39 = 0LL;
      unsigned int v15 = sub_100053B4C(1);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v16 = v15;
      }
      else {
        uint64_t v16 = v15 & 0xFFFFFFFE;
      }
      if ((_DWORD)v16)
      {
        int v41 = 67109120;
        int v42 = v13;
        uint64_t v17 = (const char *)_os_log_send_and_compose_impl( v16,  &v39,  0LL,  0LL,  &_mh_execute_header,  v14,  0LL,  "FAILEd to delete persona session with error:%d",  &v41);
        uint64_t v18 = (char *)v17;
        if (v17) {
          sub_100053B7C(v17);
        }
      }

      else
      {
        uint64_t v18 = 0LL;
      }

      free(v18);
    }

    uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  v13,  0LL));
  }

  else
  {
    [*(id *)(a1 + 32) _broadcastPersonaUpdates:v11 withAuid:v40];
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    uint64_t v30 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v39 = 0LL;
      unsigned int v31 = sub_100053B4C(1);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v32 = v31;
      }
      else {
        uint64_t v32 = v31 & 0xFFFFFFFE;
      }
      if ((_DWORD)v32)
      {
        LOWORD(v41) = 0;
        uint64_t v33 = (const char *)_os_log_send_and_compose_impl( v32,  &v39,  0LL,  0LL,  &_mh_execute_header,  v30,  0LL,  "Delete Persona SUCCESS",  &v41,  2);
        uint64_t v34 = (char *)v33;
        if (v33) {
          sub_100053B7C(v33);
        }
      }

      else
      {
        uint64_t v34 = 0LL;
      }

      free(v34);
    }

    uint64_t v37 = 0LL;
  }

LABEL_67:
  uint64_t v38 = *(void *)(a1 + 48);
  if (v38) {
    (*(void (**)(uint64_t, void *))(v38 + 16))(v38, v37);
  }
}

void sub_100011CE0(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _clientForPID:*(unsigned int *)(a1 + 56)]);
  unsigned int v40 = -1;
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  uint64_t v3 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v39 = 0LL;
    unsigned int v4 = sub_100053B4C(1);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = v4 & 0xFFFFFFFE;
    }
    if ((_DWORD)v5)
    {
      int v6 = *(_DWORD *)(a1 + 56);
      int v41 = 67109120;
      int v42 = v6;
      unsigned int v7 = (const char *)_os_log_send_and_compose_impl( v5,  &v39,  0LL,  0LL,  &_mh_execute_header,  v3,  0LL,  "In RDServer: disablePersona from pid:%d",  &v41);
      uint64_t v8 = (char *)v7;
      if (v7) {
        sub_100053B7C(v7);
      }
    }

    else
    {
      uint64_t v8 = 0LL;
    }

    free(v8);
  }

  if (v2)
  {
LABEL_26:
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    uint64_t v19 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v39 = 0LL;
      unsigned int v20 = sub_100053B4C(1);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v21 = v20;
      }
      else {
        uint64_t v21 = v20 & 0xFFFFFFFE;
      }
      if ((_DWORD)v21)
      {
        int v22 = *(_DWORD *)(a1 + 56);
        int v41 = 67109120;
        int v42 = v22;
        int v23 = (const char *)_os_log_send_and_compose_impl( v21,  &v39,  0LL,  0LL,  &_mh_execute_header,  v19,  0LL,  "In RDServer: disablePersona No entitlement pid:%d",  &v41);
        uint64_t v24 = (char *)v23;
        if (v23) {
          sub_100053B7C(v23);
        }
      }

      else
      {
        uint64_t v24 = 0LL;
      }

      free(v24);
    }

    NSErrorDomain v35 = NSPOSIXErrorDomain;
    uint64_t v36 = 1LL;
    goto LABEL_62;
  }

  if (([*(id *)(a1 + 32) remoteProcessHasBooleanEntitlement:@"com.apple.usermanagerd.persona.delete"] & 1) == 0) {
    goto LABEL_26;
  }
LABEL_14:
  if (!*(void *)(a1 + 40))
  {
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    __int16 v25 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v39 = 0LL;
      unsigned int v26 = sub_100053B4C(1);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v27 = v26;
      }
      else {
        uint64_t v27 = v26 & 0xFFFFFFFE;
      }
      if ((_DWORD)v27)
      {
        LOWORD(v41) = 0;
        uint64_t v28 = (const char *)_os_log_send_and_compose_impl( v27,  &v39,  0LL,  0LL,  &_mh_execute_header,  v25,  0LL,  "In RDServer: entitlement OK, but invalid profileInfo",  &v41,  2);
        __int16 v29 = (char *)v28;
        if (v28) {
          sub_100053B7C(v28);
        }
      }

      else
      {
        __int16 v29 = 0LL;
      }

      free(v29);
    }

    NSErrorDomain v35 = NSPOSIXErrorDomain;
    uint64_t v36 = 22LL;
LABEL_62:
    uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  v35,  v36,  0LL));
    goto LABEL_67;
  }

  id v9 = [*(id *)(a1 + 32) asidForClient:v2 withAuid:&v40 withPid:*(unsigned int *)(a1 + 56)];
  unsigned __int8 v10 = sub_100046664((uint64_t)v9, v40, *(unsigned int *)(a1 + 60));
  id v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
  int v12 = sub_100048F6C(*(const __CFDictionary **)(a1 + 40), v11);
  if (v12)
  {
    int v13 = v12;
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    uint64_t v14 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v39 = 0LL;
      unsigned int v15 = sub_100053B4C(1);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v16 = v15;
      }
      else {
        uint64_t v16 = v15 & 0xFFFFFFFE;
      }
      if ((_DWORD)v16)
      {
        int v41 = 67109120;
        int v42 = v13;
        uint64_t v17 = (const char *)_os_log_send_and_compose_impl( v16,  &v39,  0LL,  0LL,  &_mh_execute_header,  v14,  0LL,  "FAILEd to disable persona session with error:%d",  &v41);
        uint64_t v18 = (char *)v17;
        if (v17) {
          sub_100053B7C(v17);
        }
      }

      else
      {
        uint64_t v18 = 0LL;
      }

      free(v18);
    }

    uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  v13,  0LL));
  }

  else
  {
    [*(id *)(a1 + 32) _broadcastPersonaUpdates:v11 withAuid:v40];
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    uint64_t v30 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v39 = 0LL;
      unsigned int v31 = sub_100053B4C(1);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v32 = v31;
      }
      else {
        uint64_t v32 = v31 & 0xFFFFFFFE;
      }
      if ((_DWORD)v32)
      {
        LOWORD(v41) = 0;
        uint64_t v33 = (const char *)_os_log_send_and_compose_impl( v32,  &v39,  0LL,  0LL,  &_mh_execute_header,  v30,  0LL,  "Disable Persona SUCCESS",  &v41,  2);
        uint64_t v34 = (char *)v33;
        if (v33) {
          sub_100053B7C(v33);
        }
      }

      else
      {
        uint64_t v34 = 0LL;
      }

      free(v34);
    }

    uint64_t v37 = 0LL;
  }

LABEL_67:
  uint64_t v38 = *(void *)(a1 + 48);
  if (v38) {
    (*(void (**)(uint64_t, void *))(v38 + 16))(v38, v37);
  }
}

void sub_100012354(uint64_t a1)
{
  unsigned int v35 = -1;
  int v36 = 0;
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _clientForPID:*(unsigned int *)(a1 + 48)]);
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  uint64_t v3 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v37 = 0LL;
    unsigned int v4 = sub_100053B4C(1);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG)) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = v4 & 0xFFFFFFFE;
    }
    if ((_DWORD)v5)
    {
      int v6 = *(_DWORD *)(a1 + 48);
      LODWORD(v42) = 67109120;
      HIDWORD(v42) = v6;
      unsigned int v7 = (const char *)_os_log_send_and_compose_impl( v5,  &v37,  0LL,  0LL,  &_mh_execute_header,  v3,  2LL,  "In RDServer: fetchPersonaListforPid from pid:%d",  &v42);
      uint64_t v8 = (char *)v7;
      if (v7) {
        sub_100053B7C(v7);
      }
    }

    else
    {
      uint64_t v8 = 0LL;
    }

    free(v8);
  }

  if (v2)
  {
    if ([v2 hasEntitlement:@"com.apple.usermanagerd.persona.fetch"])
    {
LABEL_14:
      id v9 = [*(id *)(a1 + 32) asidForClient:v2 withAuid:&v35 withPid:*(unsigned int *)(a1 + 48)];
      if (qword_1000DBA10 != -1) {
        dispatch_once(&qword_1000DBA10, &stru_1000CD208);
      }
      unsigned __int8 v10 = (os_log_s *)(id)qword_1000DBA08;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v42 = 0LL;
        unsigned int v11 = sub_100053B4C(1);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
          uint64_t v12 = v11;
        }
        else {
          uint64_t v12 = v11 & 0xFFFFFFFE;
        }
        if ((_DWORD)v12)
        {
          int v13 = *(_DWORD *)(a1 + 48);
          LODWORD(v37) = 67109376;
          HIDWORD(v37) = v13;
          __int16 v38 = 1024;
          int v39 = (int)v9;
          uint64_t v14 = (const char *)_os_log_send_and_compose_impl( v12,  &v42,  0LL,  0LL,  &_mh_execute_header,  v10,  2LL,  "In RDServer: fetchPersonaListforPid entitlement OK:%d with asid:%d",  &v37,  14);
          unsigned int v15 = (char *)v14;
          if (v14) {
            sub_100053B7C(v14);
          }
        }

        else
        {
          unsigned int v15 = 0LL;
        }

        free(v15);
      }

      int v22 = sub_100046664((uint64_t)v9, v35, *(unsigned int *)(a1 + 52));
      int v23 = (void *)objc_claimAutoreleasedReturnValue(v22);
      id v24 = sub_1000494E0(v23, &v36);
      __int16 v25 = (void *)objc_claimAutoreleasedReturnValue(v24);
      if (v25)
      {
        unsigned int v26 = 0LL;
      }

      else
      {
        unsigned int v26 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  v36,  0LL));
        if (qword_1000DBA10 != -1) {
          dispatch_once(&qword_1000DBA10, &stru_1000CD208);
        }
        uint64_t v27 = (os_log_s *)(id)qword_1000DBA08;
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v42 = 0LL;
          unsigned int v28 = sub_100053B4C(1);
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v29 = v28;
          }
          else {
            uint64_t v29 = v28 & 0xFFFFFFFE;
          }
          if ((_DWORD)v29)
          {
            int v30 = *(_DWORD *)(a1 + 48);
            LODWORD(v37) = 67109632;
            HIDWORD(v37) = v30;
            __int16 v38 = 1024;
            int v39 = (int)v9;
            __int16 v40 = 1024;
            int v41 = v36;
            unsigned int v31 = (const char *)_os_log_send_and_compose_impl( v29,  &v42,  0LL,  0LL,  &_mh_execute_header,  v27,  0LL,  "In RDServer: No persona array pid:%d, asid:%d error:%d",  &v37,  20,  v34);
            uint64_t v32 = (char *)v31;
            if (v31) {
              sub_100053B7C(v31);
            }
          }

          else
          {
            uint64_t v32 = 0LL;
          }

          free(v32);
        }
      }

      goto LABEL_53;
    }
  }

  else if ([*(id *)(a1 + 32) remoteProcessHasBooleanEntitlement:@"com.apple.usermanagerd.persona.fetch"])
  {
    goto LABEL_14;
  }

  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  uint64_t v16 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v37 = 0LL;
    unsigned int v17 = sub_100053B4C(1);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v18 = v17;
    }
    else {
      uint64_t v18 = v17 & 0xFFFFFFFE;
    }
    if ((_DWORD)v18)
    {
      int v19 = *(_DWORD *)(a1 + 48);
      LODWORD(v42) = 67109120;
      HIDWORD(v42) = v19;
      unsigned int v20 = (const char *)_os_log_send_and_compose_impl( v18,  &v37,  0LL,  0LL,  &_mh_execute_header,  v16,  0LL,  "In RDServer: fetchPersonaListforPid entitlement failure:%d",  &v42);
      uint64_t v21 = (char *)v20;
      if (v20) {
        sub_100053B7C(v20);
      }
    }

    else
    {
      uint64_t v21 = 0LL;
    }

    free(v21);
  }

  unsigned int v26 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  1LL,  0LL));
  __int16 v25 = 0LL;
LABEL_53:
  uint64_t v33 = *(void *)(a1 + 40);
  if (v33) {
    (*(void (**)(uint64_t, void *, void *))(v33 + 16))(v33, v25, v26);
  }
}

void sub_1000128F0(uint64_t a1)
{
  int v32 = 0;
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _clientForPID:*(unsigned int *)(a1 + 48)]);
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  uint64_t v3 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v33 = 0LL;
    unsigned int v4 = sub_100053B4C(1);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG)) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = v4 & 0xFFFFFFFE;
    }
    if ((_DWORD)v5)
    {
      int v6 = *(_DWORD *)(a1 + 48);
      LODWORD(v36) = 67109120;
      HIDWORD(v36) = v6;
      unsigned int v7 = (const char *)_os_log_send_and_compose_impl( v5,  &v33,  0LL,  0LL,  &_mh_execute_header,  v3,  2LL,  "In RDServer: fetchAllUsersPersonaListforPid from pid:%d",  &v36);
      uint64_t v8 = (char *)v7;
      if (v7) {
        sub_100053B7C(v7);
      }
    }

    else
    {
      uint64_t v8 = 0LL;
    }

    free(v8);
  }

  if (!v2)
  {
    if ([*(id *)(a1 + 32) remoteProcessHasBooleanEntitlement:@"com.apple.usermanagerd.persona.fetch"]) {
      goto LABEL_14;
    }
LABEL_24:
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    unsigned int v15 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v33 = 0LL;
      unsigned int v16 = sub_100053B4C(1);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v17 = v16;
      }
      else {
        uint64_t v17 = v16 & 0xFFFFFFFE;
      }
      if ((_DWORD)v17)
      {
        int v18 = *(_DWORD *)(a1 + 48);
        LODWORD(v36) = 67109120;
        HIDWORD(v36) = v18;
        int v19 = (const char *)_os_log_send_and_compose_impl( v17,  &v33,  0LL,  0LL,  &_mh_execute_header,  v15,  0LL,  "In RDServer: fetchAllUsersPersonaListforPid entitlement failure:%d",  &v36);
        unsigned int v20 = (char *)v19;
        if (v19) {
          sub_100053B7C(v19);
        }
      }

      else
      {
        unsigned int v20 = 0LL;
      }

      free(v20);
    }

    id v24 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  1LL,  0LL));
    goto LABEL_52;
  }

LABEL_14:
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  id v9 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v33 = 0LL;
    unsigned int v10 = sub_100053B4C(1);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG)) {
      uint64_t v11 = v10;
    }
    else {
      uint64_t v11 = v10 & 0xFFFFFFFE;
    }
    if ((_DWORD)v11)
    {
      int v12 = *(_DWORD *)(a1 + 48);
      LODWORD(v36) = 67109120;
      HIDWORD(v36) = v12;
      int v13 = (const char *)_os_log_send_and_compose_impl( v11,  &v33,  0LL,  0LL,  &_mh_execute_header,  v9,  2LL,  "In RDServer: fetchAllUsersPersonaListforPid entitlement OK:%d",  &v36);
      uint64_t v14 = (char *)v13;
      if (v13) {
        sub_100053B7C(v13);
      }
    }

    else
    {
      uint64_t v14 = 0LL;
    }

    free(v14);
  }

  uint64_t v21 = sub_1000494F4(&v32);
  uint64_t v22 = objc_claimAutoreleasedReturnValue(v21);
  if (v22)
  {
    int v23 = (void *)v22;
    id v24 = 0LL;
    goto LABEL_53;
  }

  id v24 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  v32,  0LL));
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  __int16 v25 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v36 = 0LL;
    unsigned int v26 = sub_100053B4C(1);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v27 = v26;
    }
    else {
      uint64_t v27 = v26 & 0xFFFFFFFE;
    }
    if ((_DWORD)v27)
    {
      int v28 = *(_DWORD *)(a1 + 48);
      LODWORD(v33) = 67109376;
      HIDWORD(v33) = v28;
      __int16 v34 = 1024;
      int v35 = v32;
      uint64_t v29 = (const char *)_os_log_send_and_compose_impl( v27,  &v36,  0LL,  0LL,  &_mh_execute_header,  v25,  0LL,  "In RDServer: No all users persona array pid:%d, error:%d",  &v33,  14);
      int v30 = (char *)v29;
      if (v29) {
        sub_100053B7C(v29);
      }
    }

    else
    {
      int v30 = 0LL;
    }

    free(v30);
  }

LABEL_52:
  int v23 = 0LL;
LABEL_53:
  uint64_t v31 = *(void *)(a1 + 40);
  if (v31) {
    (*(void (**)(uint64_t, void *, void *))(v31 + 16))(v31, v23, v24);
  }
}
  }

  else
  {
    uint64_t v5 = 0LL;
  }

  return v5;
}
  }

  else
  {
    uint64_t v5 = 0LL;
  }

  return v5;
}

  return v11;
}

  memset_s(__s, 0x1000uLL, 0, 0x1000uLL);
  return v13;
}

  memset_s(__s, 0x1000uLL, 0, 0x1000uLL);
  return v9;
}

void sub_100012E38(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _clientForPID:*(unsigned int *)(a1 + 48)]);
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  uint64_t v3 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v22 = 0LL;
    unsigned int v4 = sub_100053B4C(1);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG)) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = v4 & 0xFFFFFFFE;
    }
    if ((_DWORD)v5)
    {
      int v6 = *(_DWORD *)(a1 + 48);
      int v23 = 67109120;
      int v24 = v6;
      unsigned int v7 = (const char *)_os_log_send_and_compose_impl( v5,  &v22,  0LL,  0LL,  &_mh_execute_header,  v3,  2LL,  "In RDServer: fetchAsidMapforPid from pid:%d",  &v23);
      uint64_t v8 = (char *)v7;
      if (v7) {
        sub_100053B7C(v7);
      }
    }

    else
    {
      uint64_t v8 = 0LL;
    }

    free(v8);
  }

  if (v2)
  {
    if ([v2 hasEntitlement:@"com.apple.usermanagerd.persona.fetch"])
    {
LABEL_14:
      if (qword_1000DBA10 != -1) {
        dispatch_once(&qword_1000DBA10, &stru_1000CD208);
      }
      id v9 = (os_log_s *)(id)qword_1000DBA08;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v22 = 0LL;
        unsigned int v10 = sub_100053B4C(1);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG)) {
          uint64_t v11 = v10;
        }
        else {
          uint64_t v11 = v10 & 0xFFFFFFFE;
        }
        if ((_DWORD)v11)
        {
          LOWORD(v23) = 0;
          int v12 = (const char *)_os_log_send_and_compose_impl( v11,  &v22,  0LL,  0LL,  &_mh_execute_header,  v9,  2LL,  "In RDServer: ASID Map not supported on this platform",  &v23,  2);
          int v13 = (char *)v12;
          if (v12) {
            sub_100053B7C(v12);
          }
        }

        else
        {
          int v13 = 0LL;
        }

        free(v13);
      }

      uint64_t v19 = 45LL;
      goto LABEL_39;
    }
  }

  else if ([*(id *)(a1 + 32) remoteProcessHasBooleanEntitlement:@"com.apple.usermanagerd.persona.fetch"])
  {
    goto LABEL_14;
  }

  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  id v9 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v22 = 0LL;
    unsigned int v14 = sub_100053B4C(1);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v15 = v14;
    }
    else {
      uint64_t v15 = v14 & 0xFFFFFFFE;
    }
    if ((_DWORD)v15)
    {
      int v16 = *(_DWORD *)(a1 + 48);
      int v23 = 67109120;
      int v24 = v16;
      uint64_t v17 = (const char *)_os_log_send_and_compose_impl( v15,  &v22,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "In RDServer: fetchAsidMapforPid entitlement failure:%d",  &v23);
      int v18 = (char *)v17;
      if (v17) {
        sub_100053B7C(v17);
      }
    }

    else
    {
      int v18 = 0LL;
    }

    free(v18);
  }

  uint64_t v19 = 1LL;
LABEL_39:

  unsigned int v20 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  v19,  0LL));
  uint64_t v21 = *(void *)(a1 + 40);
  if (v21) {
    (*(void (**)(uint64_t, void, void *))(v21 + 16))(v21, 0LL, v20);
  }
}

void sub_100013290(uint64_t a1)
{
  int v48 = 0;
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _clientForPID:*(unsigned int *)(a1 + 56)]);
  unsigned int v47 = -1;
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  uint64_t v3 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    *(void *)int v49 = 0LL;
    unsigned int v4 = sub_100053B4C(1);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG)) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = v4 & 0xFFFFFFFE;
    }
    if ((_DWORD)v5)
    {
      int v6 = *(_DWORD *)(a1 + 56);
      LODWORD(v54) = 67109120;
      HIDWORD(v54) = v6;
      unsigned int v7 = (const char *)_os_log_send_and_compose_impl( v5,  v49,  0LL,  0LL,  &_mh_execute_header,  v3,  2LL,  "In RDServer: fetchPersona from pid:%d",  &v54);
      uint64_t v8 = (char *)v7;
      if (v7) {
        sub_100053B7C(v7);
      }
    }

    else
    {
      uint64_t v8 = 0LL;
    }

    free(v8);
  }

  if (v2)
  {
LABEL_25:
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    uint64_t v17 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)int v49 = 0LL;
      unsigned int v18 = sub_100053B4C(1);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v19 = v18;
      }
      else {
        uint64_t v19 = v18 & 0xFFFFFFFE;
      }
      if ((_DWORD)v19)
      {
        int v20 = *(_DWORD *)(a1 + 56);
        LODWORD(v54) = 67109120;
        HIDWORD(v54) = v20;
        uint64_t v21 = (const char *)_os_log_send_and_compose_impl( v19,  v49,  0LL,  0LL,  &_mh_execute_header,  v17,  0LL,  "In RDServer: fetchPersona entitlement failure:%d",  &v54);
        uint64_t v22 = (char *)v21;
        if (v21) {
          sub_100053B7C(v21);
        }
      }

      else
      {
        uint64_t v22 = 0LL;
      }

      free(v22);
    }

    NSErrorDomain v28 = NSPOSIXErrorDomain;
    uint64_t v29 = 1LL;
    goto LABEL_73;
  }

  if (([*(id *)(a1 + 32) remoteProcessHasBooleanEntitlement:@"com.apple.usermanagerd.persona.fetch"] & 1) == 0) {
    goto LABEL_25;
  }
LABEL_14:
  if (!*(void *)(a1 + 40))
  {
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    int v23 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
    {
      *(void *)int v49 = 0LL;
      unsigned int v24 = sub_100053B4C(1);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG)) {
        uint64_t v25 = v24;
      }
      else {
        uint64_t v25 = v24 & 0xFFFFFFFE;
      }
      if ((_DWORD)v25)
      {
        LOWORD(v54) = 0;
        unsigned int v26 = (const char *)_os_log_send_and_compose_impl( v25,  v49,  0LL,  0LL,  &_mh_execute_header,  v23,  2LL,  "In RDServer: entitlement OK, but invalid profileInfo",  &v54,  2);
        uint64_t v27 = (char *)v26;
        if (v26) {
          sub_100053B7C(v26);
        }
      }

      else
      {
        uint64_t v27 = 0LL;
      }

      free(v27);
    }

    NSErrorDomain v28 = NSPOSIXErrorDomain;
    uint64_t v29 = 22LL;
LABEL_73:
    int v39 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  v28,  v29,  0LL));
    uint64_t v33 = 0LL;
    goto LABEL_77;
  }

  id v9 = [*(id *)(a1 + 32) asidForClient:v2 withAuid:&v47 withPid:*(unsigned int *)(a1 + 56)];
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  unsigned int v10 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v54 = 0LL;
    unsigned int v11 = sub_100053B4C(1);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
      uint64_t v12 = v11;
    }
    else {
      uint64_t v12 = v11 & 0xFFFFFFFE;
    }
    if ((_DWORD)v12)
    {
      uint64_t v13 = *(void *)(a1 + 40);
      int v14 = *(_DWORD *)(a1 + 56);
      *(_DWORD *)int v49 = 138412802;
      *(void *)&v49[4] = v13;
      __int16 v50 = 1024;
      int v51 = v14;
      __int16 v52 = 1024;
      int v53 = (int)v9;
      uint64_t v15 = (const char *)_os_log_send_and_compose_impl( v12,  &v54,  0LL,  0LL,  &_mh_execute_header,  v10,  2LL,  "In RDServer: entitlement OK, calling fetchPersonaSession with profileInfo:%@ for pid:%d with asid:%d",  v49,  24);
      int v16 = (char *)v15;
      if (v15) {
        sub_100053B7C(v15);
      }
    }

    else
    {
      int v16 = 0LL;
    }

    free(v16);
  }

  int v30 = sub_100046664((uint64_t)v9, v47, *(unsigned int *)(a1 + 60));
  uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue(v30);
  id v32 = sub_100049504(*(void **)(a1 + 40), v31, &v48);
  uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue(v32);
  if (v33)
  {
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    __int16 v34 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v54 = 0LL;
      unsigned int v35 = sub_100053B4C(1);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG)) {
        uint64_t v36 = v35;
      }
      else {
        uint64_t v36 = v35 & 0xFFFFFFFE;
      }
      if ((_DWORD)v36)
      {
        *(_DWORD *)int v49 = 138412290;
        *(void *)&v49[4] = v33;
        LODWORD(v46) = 12;
        uint64_t v37 = (const char *)_os_log_send_and_compose_impl( v36,  &v54,  0LL,  0LL,  &_mh_execute_header,  v34,  2LL,  "fetchpersona:%@",  v49,  v46);
        __int16 v38 = (char *)v37;
        if (v37) {
          sub_100053B7C(v37);
        }
      }

      else
      {
        __int16 v38 = 0LL;
      }

      free(v38);
    }

    int v39 = 0LL;
  }

  else
  {
    int v39 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  v48,  0LL));
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    __int16 v34 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v54 = 0LL;
      unsigned int v40 = sub_100053B4C(1);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG)) {
        uint64_t v41 = v40;
      }
      else {
        uint64_t v41 = v40 & 0xFFFFFFFE;
      }
      if ((_DWORD)v41)
      {
        int v42 = *(_DWORD *)(a1 + 56);
        *(_DWORD *)int v49 = 138412802;
        *(void *)&v49[4] = v39;
        __int16 v50 = 1024;
        int v51 = v42;
        __int16 v52 = 1024;
        int v53 = (int)v9;
        LODWORD(v46) = 24;
        v43 = (const char *)_os_log_send_and_compose_impl( v41,  &v54,  0LL,  0LL,  &_mh_execute_header,  v34,  2LL,  "Fetch persona failed with error:%@, pid:%d, asid:%d",  v49,  v46);
        unsigned int v44 = (char *)v43;
        if (v43) {
          sub_100053B7C(v43);
        }
      }

      else
      {
        unsigned int v44 = 0LL;
      }

      free(v44);
    }
  }

LABEL_77:
  uint64_t v45 = *(void *)(a1 + 48);
  if (v45) {
    (*(void (**)(uint64_t, void *, void *))(v45 + 16))(v45, v33, v39);
  }
}

void sub_100013BB8(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _clientForPID:*(unsigned int *)(a1 + 64)]);
  HIDWORD(v44) = -1;
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  uint64_t v3 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    *(void *)uint64_t v45 = 0LL;
    unsigned int v4 = sub_100053B4C(1);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG)) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = v4 & 0xFFFFFFFE;
    }
    if ((_DWORD)v5)
    {
      int v6 = *(_DWORD *)(a1 + 64);
      LODWORD(v4_Block_object_dispose(va, 8) = 67109120;
      HIDWORD(v4_Block_object_dispose(va, 8) = v6;
      unsigned int v7 = (const char *)_os_log_send_and_compose_impl( v5,  v45,  0LL,  0LL,  &_mh_execute_header,  v3,  2LL,  "In RDServer: setSinglePersonaBundlesIdentifiers from pid:%d",  &v48);
      uint64_t v8 = (char *)v7;
      if (v7) {
        sub_100053B7C(v7);
      }
    }

    else
    {
      uint64_t v8 = 0LL;
    }

    free(v8);
  }

  if (v2)
  {
LABEL_25:
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    uint64_t v17 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)uint64_t v45 = 0LL;
      unsigned int v18 = sub_100053B4C(1);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v19 = v18;
      }
      else {
        uint64_t v19 = v18 & 0xFFFFFFFE;
      }
      if ((_DWORD)v19)
      {
        int v20 = *(_DWORD *)(a1 + 64);
        LODWORD(v4_Block_object_dispose(va, 8) = 67109120;
        HIDWORD(v4_Block_object_dispose(va, 8) = v20;
        uint64_t v21 = (const char *)_os_log_send_and_compose_impl( v19,  v45,  0LL,  0LL,  &_mh_execute_header,  v17,  0LL,  "Entitlement Failure for pid:%d",  &v48);
        uint64_t v22 = (char *)v21;
        if (v21) {
          sub_100053B7C(v21);
        }
      }

      else
      {
        uint64_t v22 = 0LL;
      }

      free(v22);
    }

    NSErrorDomain v28 = NSPOSIXErrorDomain;
    uint64_t v29 = 1LL;
    goto LABEL_72;
  }

  if (([*(id *)(a1 + 32) remoteProcessHasBooleanEntitlement:@"com.apple.usermanagerd.persona.setbundle"] & 1) == 0) {
    goto LABEL_25;
  }
LABEL_14:
  if (!*(void *)(a1 + 40))
  {
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    int v23 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)uint64_t v45 = 0LL;
      unsigned int v24 = sub_100053B4C(1);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v25 = v24;
      }
      else {
        uint64_t v25 = v24 & 0xFFFFFFFE;
      }
      if ((_DWORD)v25)
      {
        LOWORD(v4_Block_object_dispose(va, 8) = 0;
        LODWORD(v44) = 2;
        unsigned int v26 = (const char *)_os_log_send_and_compose_impl( v25,  v45,  0LL,  0LL,  &_mh_execute_header,  v23,  0LL,  "Entitlement Okay, but invalid profileInfo",  &v48,  v44);
        uint64_t v27 = (char *)v26;
        if (v26) {
          sub_100053B7C(v26);
        }
      }

      else
      {
        uint64_t v27 = 0LL;
      }

      free(v27);
    }

    NSErrorDomain v28 = NSPOSIXErrorDomain;
    uint64_t v29 = 22LL;
LABEL_72:
    uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  v28,  v29,  0LL));
    goto LABEL_77;
  }

  id v9 = [*(id *)(a1 + 32) asidForClient:v2 withAuid:(char *)&v44 + 4 withPid:*(unsigned int *)(a1 + 64)];
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  unsigned int v10 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v48 = 0LL;
    unsigned int v11 = sub_100053B4C(1);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
      uint64_t v12 = v11;
    }
    else {
      uint64_t v12 = v11 & 0xFFFFFFFE;
    }
    if ((_DWORD)v12)
    {
      int v13 = *(_DWORD *)(a1 + 64);
      uint64_t v14 = *(void *)(a1 + 48);
      *(_DWORD *)uint64_t v45 = 67109634;
      *(_DWORD *)&v45[4] = v13;
      *(_WORD *)&v45[8] = 2112;
      *(void *)&v45[10] = v14;
      __int16 v46 = 1024;
      int v47 = (int)v9;
      LODWORD(v44) = 24;
      uint64_t v15 = (const char *)_os_log_send_and_compose_impl( v12,  &v48,  0LL,  0LL,  &_mh_execute_header,  v10,  2LL,  "Entitlement Okay for pid:%d, setSinglePersonaBundlesIdentifiers bundleIDS list:%@ with asid:%d",  v45,  v44);
      int v16 = (char *)v15;
      if (v15) {
        sub_100053B7C(v15);
      }
    }

    else
    {
      int v16 = 0LL;
    }

    free(v16);
  }

  int v30 = sub_100046664((uint64_t)v9, HIDWORD(v44), *(unsigned int *)(a1 + 68));
  uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue(v30);
  int v32 = sub_100049570(*(const __CFDictionary **)(a1 + 40), *(const __CFArray **)(a1 + 48), v31);
  if (v32)
  {
    uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  v32,  0LL));
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    __int16 v34 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v48 = 0LL;
      unsigned int v35 = sub_100053B4C(1);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v36 = v35;
      }
      else {
        uint64_t v36 = v35 & 0xFFFFFFFE;
      }
      if ((_DWORD)v36)
      {
        *(_DWORD *)uint64_t v45 = 138412290;
        *(void *)&v45[4] = v33;
        LODWORD(v44) = 12;
        uint64_t v37 = (const char *)_os_log_send_and_compose_impl( v36,  &v48,  0LL,  0LL,  &_mh_execute_header,  v34,  0LL,  "Update bundle failed with error:%@",  v45,  v44);
        __int16 v38 = (char *)v37;
        if (v37) {
          sub_100053B7C(v37);
        }
      }

      else
      {
        __int16 v38 = 0LL;
      }

      free(v38);
    }
  }

  else
  {
    [*(id *)(a1 + 32) _broadcastPersonaUpdates:v31 withAuid:HIDWORD(v44)];
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    __int16 v34 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
    {
      *(void *)uint64_t v45 = 0LL;
      unsigned int v39 = sub_100053B4C(1);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG)) {
        uint64_t v40 = v39;
      }
      else {
        uint64_t v40 = v39 & 0xFFFFFFFE;
      }
      if ((_DWORD)v40)
      {
        LOWORD(v4_Block_object_dispose(va, 8) = 0;
        LODWORD(v44) = 2;
        uint64_t v41 = (const char *)_os_log_send_and_compose_impl( v40,  v45,  0LL,  0LL,  &_mh_execute_header,  v34,  2LL,  "Update BundleIDS success",  &v48,  v44);
        int v42 = (char *)v41;
        if (v41) {
          sub_100053B7C(v41);
        }
      }

      else
      {
        int v42 = 0LL;
      }

      free(v42);
    }

    uint64_t v33 = 0LL;
  }

LABEL_77:
  uint64_t v43 = *(void *)(a1 + 56);
  if (v43) {
    (*(void (**)(uint64_t, void *))(v43 + 16))(v43, v33);
  }
}

void sub_100014350(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _clientForPID:*(unsigned int *)(a1 + 56)]);
  unsigned int v46 = -1;
  int v47 = 2;
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  uint64_t v3 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    *(void *)uint64_t v48 = 0LL;
    unsigned int v4 = sub_100053B4C(1);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG)) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = v4 & 0xFFFFFFFE;
    }
    if ((_DWORD)v5)
    {
      int v6 = *(_DWORD *)(a1 + 56);
      LODWORD(v53) = 67109120;
      HIDWORD(v53) = v6;
      unsigned int v7 = (const char *)_os_log_send_and_compose_impl( v5,  v48,  0LL,  0LL,  &_mh_execute_header,  v3,  2LL,  "In RDServer: fetchBundleIdentifiersForPersona from pid:%d",  &v53);
      uint64_t v8 = (char *)v7;
      if (v7) {
        sub_100053B7C(v7);
      }
    }

    else
    {
      uint64_t v8 = 0LL;
    }

    free(v8);
  }

  if (v2)
  {
LABEL_25:
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    uint64_t v17 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)uint64_t v48 = 0LL;
      unsigned int v18 = sub_100053B4C(1);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v19 = v18;
      }
      else {
        uint64_t v19 = v18 & 0xFFFFFFFE;
      }
      if ((_DWORD)v19)
      {
        int v20 = *(_DWORD *)(a1 + 56);
        LODWORD(v53) = 67109120;
        HIDWORD(v53) = v20;
        uint64_t v21 = (const char *)_os_log_send_and_compose_impl( v19,  v48,  0LL,  0LL,  &_mh_execute_header,  v17,  0LL,  "Entitlement Failure for pid:%d",  &v53);
        uint64_t v22 = (char *)v21;
        if (v21) {
          sub_100053B7C(v21);
        }
      }

      else
      {
        uint64_t v22 = 0LL;
      }

      free(v22);
    }

    NSErrorDomain v28 = NSPOSIXErrorDomain;
    uint64_t v29 = 1LL;
    goto LABEL_73;
  }

  if (([*(id *)(a1 + 32) remoteProcessHasBooleanEntitlement:@"com.apple.usermanagerd.persona.fetchbundle"] & 1) == 0) {
    goto LABEL_25;
  }
LABEL_14:
  if (!*(void *)(a1 + 40))
  {
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    int v23 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)uint64_t v48 = 0LL;
      unsigned int v24 = sub_100053B4C(1);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v25 = v24;
      }
      else {
        uint64_t v25 = v24 & 0xFFFFFFFE;
      }
      if ((_DWORD)v25)
      {
        LOWORD(v53) = 0;
        unsigned int v26 = (const char *)_os_log_send_and_compose_impl( v25,  v48,  0LL,  0LL,  &_mh_execute_header,  v23,  0LL,  "In RDServer: entitlement OK, but invalid profileInfo",  &v53,  2);
        uint64_t v27 = (char *)v26;
        if (v26) {
          sub_100053B7C(v26);
        }
      }

      else
      {
        uint64_t v27 = 0LL;
      }

      free(v27);
    }

    NSErrorDomain v28 = NSPOSIXErrorDomain;
    uint64_t v29 = 22LL;
LABEL_73:
    unsigned int v39 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  v28,  v29,  0LL));
    uint64_t v33 = 0LL;
    goto LABEL_77;
  }

  id v9 = [*(id *)(a1 + 32) asidForClient:v2 withAuid:&v46 withPid:*(unsigned int *)(a1 + 56)];
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  unsigned int v10 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v53 = 0LL;
    unsigned int v11 = sub_100053B4C(1);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
      uint64_t v12 = v11;
    }
    else {
      uint64_t v12 = v11 & 0xFFFFFFFE;
    }
    if ((_DWORD)v12)
    {
      uint64_t v13 = *(void *)(a1 + 40);
      int v14 = *(_DWORD *)(a1 + 56);
      *(_DWORD *)uint64_t v48 = 138412802;
      *(void *)&v48[4] = v13;
      __int16 v49 = 1024;
      int v50 = v14;
      __int16 v51 = 1024;
      int v52 = (int)v9;
      uint64_t v15 = (const char *)_os_log_send_and_compose_impl( v12,  &v53,  0LL,  0LL,  &_mh_execute_header,  v10,  2LL,  "In RDServer: entitlement OK, calling fetchBundleIdentifiersForPersona for profileInfo:%@ for pid:%d with asid:%d",  v48,  24);
      int v16 = (char *)v15;
      if (v15) {
        sub_100053B7C(v15);
      }
    }

    else
    {
      int v16 = 0LL;
    }

    free(v16);
  }

  int v30 = sub_100046664((uint64_t)v9, v46, *(unsigned int *)(a1 + 60));
  uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue(v30);
  id v32 = sub_100049BF0(*(void **)(a1 + 40), v31, &v47);
  uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue(v32);
  if (v33)
  {
    int v47 = 0;
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    __int16 v34 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v53 = 0LL;
      unsigned int v35 = sub_100053B4C(1);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG)) {
        uint64_t v36 = v35;
      }
      else {
        uint64_t v36 = v35 & 0xFFFFFFFE;
      }
      if ((_DWORD)v36)
      {
        *(_DWORD *)uint64_t v48 = 138412290;
        *(void *)&v48[4] = v33;
        LODWORD(v45) = 12;
        uint64_t v37 = (const char *)_os_log_send_and_compose_impl( v36,  &v53,  0LL,  0LL,  &_mh_execute_header,  v34,  2LL,  "fetchBundleIdentifiersForPersona Success with array %@",  v48,  v45);
        __int16 v38 = (char *)v37;
        if (v37) {
          sub_100053B7C(v37);
        }
      }

      else
      {
        __int16 v38 = 0LL;
      }

      free(v38);
    }

    unsigned int v39 = 0LL;
  }

  else
  {
    unsigned int v39 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  v47,  0LL));
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    __int16 v34 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v53 = 0LL;
      unsigned int v40 = sub_100053B4C(1);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v41 = v40;
      }
      else {
        uint64_t v41 = v40 & 0xFFFFFFFE;
      }
      if ((_DWORD)v41)
      {
        *(_DWORD *)uint64_t v48 = 138412290;
        *(void *)&v48[4] = v39;
        LODWORD(v45) = 12;
        int v42 = (const char *)_os_log_send_and_compose_impl( v41,  &v53,  0LL,  0LL,  &_mh_execute_header,  v34,  0LL,  "fetchBundleIdentifiersForPersona failed with %@",  v48,  v45);
        uint64_t v43 = (char *)v42;
        if (v42) {
          sub_100053B7C(v42);
        }
      }

      else
      {
        uint64_t v43 = 0LL;
      }

      free(v43);
    }
  }

LABEL_77:
  uint64_t v44 = *(void *)(a1 + 48);
  if (v44) {
    (*(void (**)(uint64_t, void *, void *))(v44 + 16))(v44, v33, v39);
  }
}

void sub_100014C3C(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _clientForPID:*(unsigned int *)(a1 + 56)]);
  HIDWORD(v37) = -1;
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  uint64_t v3 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    *(void *)__int16 v38 = 0LL;
    unsigned int v4 = sub_100053B4C(1);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG)) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = v4 & 0xFFFFFFFE;
    }
    if ((_DWORD)v5)
    {
      int v6 = *(_DWORD *)(a1 + 56);
      LODWORD(v41) = 67109120;
      HIDWORD(v41) = v6;
      unsigned int v7 = (const char *)_os_log_send_and_compose_impl( v5,  v38,  0LL,  0LL,  &_mh_execute_header,  v3,  2LL,  "In RDServer: setMultiPersonaBundlesIdentifiers from pid:%d",  &v41);
      uint64_t v8 = (char *)v7;
      if (v7) {
        sub_100053B7C(v7);
      }
    }

    else
    {
      uint64_t v8 = 0LL;
    }

    free(v8);
  }

  if (v2)
  {
    if ([v2 hasEntitlement:@"com.apple.usermanagerd.persona.setbundle"])
    {
LABEL_14:
      id v9 = [*(id *)(a1 + 32) asidForClient:v2 withAuid:(char *)&v37 + 4 withPid:*(unsigned int *)(a1 + 56)];
      if (qword_1000DBA10 != -1) {
        dispatch_once(&qword_1000DBA10, &stru_1000CD208);
      }
      unsigned int v10 = (os_log_s *)(id)qword_1000DBA08;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v41 = 0LL;
        unsigned int v11 = sub_100053B4C(1);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
          uint64_t v12 = v11;
        }
        else {
          uint64_t v12 = v11 & 0xFFFFFFFE;
        }
        if ((_DWORD)v12)
        {
          int v13 = *(_DWORD *)(a1 + 56);
          uint64_t v14 = *(void *)(a1 + 40);
          *(_DWORD *)__int16 v38 = 67109634;
          *(_DWORD *)&v38[4] = v13;
          *(_WORD *)&v38[8] = 2112;
          *(void *)&v38[10] = v14;
          __int16 v39 = 1024;
          int v40 = (int)v9;
          LODWORD(v37) = 24;
          uint64_t v15 = (const char *)_os_log_send_and_compose_impl( v12,  &v41,  0LL,  0LL,  &_mh_execute_header,  v10,  2LL,  "Entitlement Okay for pid:%d, set bundleIDS list:%@ with asid:%d",  v38,  v37);
          int v16 = (char *)v15;
          if (v15) {
            sub_100053B7C(v15);
          }
        }

        else
        {
          int v16 = 0LL;
        }

        free(v16);
      }

      int v23 = sub_100046664((uint64_t)v9, HIDWORD(v37), *(unsigned int *)(a1 + 60));
      unsigned int v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
      int v25 = sub_100049C08(*(const __CFArray **)(a1 + 40), v24);
      if (v25)
      {
        unsigned int v26 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  v25,  0LL));
        if (qword_1000DBA10 != -1) {
          dispatch_once(&qword_1000DBA10, &stru_1000CD208);
        }
        uint64_t v27 = (os_log_s *)(id)qword_1000DBA08;
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v41 = 0LL;
          unsigned int v28 = sub_100053B4C(1);
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v29 = v28;
          }
          else {
            uint64_t v29 = v28 & 0xFFFFFFFE;
          }
          if ((_DWORD)v29)
          {
            *(_DWORD *)__int16 v38 = 138412290;
            *(void *)&v38[4] = v26;
            LODWORD(v37) = 12;
            int v30 = (const char *)_os_log_send_and_compose_impl( v29,  &v41,  0LL,  0LL,  &_mh_execute_header,  v27,  0LL,  "Update bundle failed with error:%@",  v38,  v37);
            uint64_t v31 = (char *)v30;
            if (v30) {
              sub_100053B7C(v30);
            }
          }

          else
          {
            uint64_t v31 = 0LL;
          }

          free(v31);
        }
      }

      else
      {
        [*(id *)(a1 + 32) _broadcastPersonaUpdates:v24 withAuid:HIDWORD(v37)];
        if (qword_1000DBA10 != -1) {
          dispatch_once(&qword_1000DBA10, &stru_1000CD208);
        }
        uint64_t v27 = (os_log_s *)(id)qword_1000DBA08;
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
        {
          *(void *)__int16 v38 = 0LL;
          unsigned int v32 = sub_100053B4C(1);
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG)) {
            uint64_t v33 = v32;
          }
          else {
            uint64_t v33 = v32 & 0xFFFFFFFE;
          }
          if ((_DWORD)v33)
          {
            LOWORD(v41) = 0;
            LODWORD(v37) = 2;
            __int16 v34 = (const char *)_os_log_send_and_compose_impl( v33,  v38,  0LL,  0LL,  &_mh_execute_header,  v27,  2LL,  "Update BundleIDS success",  &v41,  v37);
            unsigned int v35 = (char *)v34;
            if (v34) {
              sub_100053B7C(v34);
            }
          }

          else
          {
            unsigned int v35 = 0LL;
          }

          free(v35);
        }

        unsigned int v26 = 0LL;
      }

      goto LABEL_63;
    }
  }

  else if ([*(id *)(a1 + 32) remoteProcessHasBooleanEntitlement:@"com.apple.usermanagerd.persona.setbundle"])
  {
    goto LABEL_14;
  }

  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  uint64_t v17 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)__int16 v38 = 0LL;
    unsigned int v18 = sub_100053B4C(1);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v19 = v18;
    }
    else {
      uint64_t v19 = v18 & 0xFFFFFFFE;
    }
    if ((_DWORD)v19)
    {
      int v20 = *(_DWORD *)(a1 + 56);
      LODWORD(v41) = 67109120;
      HIDWORD(v41) = v20;
      uint64_t v21 = (const char *)_os_log_send_and_compose_impl( v19,  v38,  0LL,  0LL,  &_mh_execute_header,  v17,  0LL,  "Entitlement Failure for pid:%d",  &v41);
      uint64_t v22 = (char *)v21;
      if (v21) {
        sub_100053B7C(v21);
      }
    }

    else
    {
      uint64_t v22 = 0LL;
    }

    free(v22);
  }

  unsigned int v26 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  1LL,  0LL));
LABEL_63:
  uint64_t v36 = *(void *)(a1 + 48);
  if (v36) {
    (*(void (**)(uint64_t, void *))(v36 + 16))(v36, v26);
  }
}

void sub_1000152C4(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _clientForPID:*(unsigned int *)(a1 + 48)]);
  int v39 = 2;
  unsigned int v40 = -1;
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  uint64_t v3 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    *(void *)uint64_t v41 = 0LL;
    unsigned int v4 = sub_100053B4C(1);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG)) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = v4 & 0xFFFFFFFE;
    }
    if ((_DWORD)v5)
    {
      int v6 = *(_DWORD *)(a1 + 48);
      LODWORD(v42) = 67109120;
      HIDWORD(v42) = v6;
      unsigned int v7 = (const char *)_os_log_send_and_compose_impl( v5,  v41,  0LL,  0LL,  &_mh_execute_header,  v3,  2LL,  "In RDServer: fetchMultiPersonaBundleIdentifiersforPid from pid:%d",  &v42);
      uint64_t v8 = (char *)v7;
      if (v7) {
        sub_100053B7C(v7);
      }
    }

    else
    {
      uint64_t v8 = 0LL;
    }

    free(v8);
  }

  if (v2)
  {
    if ([v2 hasEntitlement:@"com.apple.usermanagerd.persona.fetchbundle"])
    {
LABEL_14:
      id v9 = [*(id *)(a1 + 32) asidForClient:v2 withAuid:&v40 withPid:*(unsigned int *)(a1 + 48)];
      if (qword_1000DBA10 != -1) {
        dispatch_once(&qword_1000DBA10, &stru_1000CD208);
      }
      unsigned int v10 = (os_log_s *)(id)qword_1000DBA08;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v42 = 0LL;
        unsigned int v11 = sub_100053B4C(1);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
          uint64_t v12 = v11;
        }
        else {
          uint64_t v12 = v11 & 0xFFFFFFFE;
        }
        if ((_DWORD)v12)
        {
          int v13 = *(_DWORD *)(a1 + 48);
          *(_DWORD *)uint64_t v41 = 67109376;
          *(_DWORD *)&v41[4] = v13;
          *(_WORD *)&v41[8] = 1024;
          *(_DWORD *)&v41[10] = (_DWORD)v9;
          uint64_t v14 = (const char *)_os_log_send_and_compose_impl( v12,  &v42,  0LL,  0LL,  &_mh_execute_header,  v10,  2LL,  "In RDServer: entitlement OK, calling fetchMultiPersonaBundleIDsList for pid:%d with asid:%d",  v41,  14);
          uint64_t v15 = (char *)v14;
          if (v14) {
            sub_100053B7C(v14);
          }
        }

        else
        {
          uint64_t v15 = 0LL;
        }

        free(v15);
      }

      uint64_t v22 = sub_100046664((uint64_t)v9, v40, *(unsigned int *)(a1 + 52));
      int v23 = (void *)objc_claimAutoreleasedReturnValue(v22);
      id v24 = sub_10004A254(v23, &v39);
      int v25 = (void *)objc_claimAutoreleasedReturnValue(v24);
      if (v25)
      {
        if (qword_1000DBA10 != -1) {
          dispatch_once(&qword_1000DBA10, &stru_1000CD208);
        }
        unsigned int v26 = (os_log_s *)(id)qword_1000DBA08;
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v42 = 0LL;
          unsigned int v27 = sub_100053B4C(1);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG)) {
            uint64_t v28 = v27;
          }
          else {
            uint64_t v28 = v27 & 0xFFFFFFFE;
          }
          if ((_DWORD)v28)
          {
            *(_DWORD *)uint64_t v41 = 138412290;
            *(void *)&v41[4] = v25;
            LODWORD(v3_Block_object_dispose(va, 8) = 12;
            uint64_t v29 = (const char *)_os_log_send_and_compose_impl( v28,  &v42,  0LL,  0LL,  &_mh_execute_header,  v26,  2LL,  "fetchMultiPersonaBundleIDsList Success with array %@",  v41,  v38);
            int v30 = (char *)v29;
            if (v29) {
              sub_100053B7C(v29);
            }
          }

          else
          {
            int v30 = 0LL;
          }

          free(v30);
        }

        uint64_t v31 = 0LL;
        int v39 = 0;
      }

      else
      {
        uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  v39,  0LL));
        if (qword_1000DBA10 != -1) {
          dispatch_once(&qword_1000DBA10, &stru_1000CD208);
        }
        unsigned int v32 = (os_log_s *)(id)qword_1000DBA08;
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v42 = 0LL;
          unsigned int v33 = sub_100053B4C(1);
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v34 = v33;
          }
          else {
            uint64_t v34 = v33 & 0xFFFFFFFE;
          }
          if ((_DWORD)v34)
          {
            *(_DWORD *)uint64_t v41 = 138412290;
            *(void *)&v41[4] = v31;
            LODWORD(v3_Block_object_dispose(va, 8) = 12;
            unsigned int v35 = (const char *)_os_log_send_and_compose_impl( v34,  &v42,  0LL,  0LL,  &_mh_execute_header,  v32,  0LL,  "fetchMultiPersonaBundleIDsList failed with %@",  v41,  v38);
            uint64_t v36 = (char *)v35;
            if (v35) {
              sub_100053B7C(v35);
            }
          }

          else
          {
            uint64_t v36 = 0LL;
          }

          free(v36);
        }
      }

      goto LABEL_64;
    }
  }

  else if ([*(id *)(a1 + 32) remoteProcessHasBooleanEntitlement:@"com.apple.usermanagerd.persona.fetchbundle"])
  {
    goto LABEL_14;
  }

  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  int v16 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t v41 = 0LL;
    unsigned int v17 = sub_100053B4C(1);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v18 = v17;
    }
    else {
      uint64_t v18 = v17 & 0xFFFFFFFE;
    }
    if ((_DWORD)v18)
    {
      int v19 = *(_DWORD *)(a1 + 48);
      LODWORD(v42) = 67109120;
      HIDWORD(v42) = v19;
      int v20 = (const char *)_os_log_send_and_compose_impl( v18,  v41,  0LL,  0LL,  &_mh_execute_header,  v16,  0LL,  "Entitlement Failure for pid:%d",  &v42);
      uint64_t v21 = (char *)v20;
      if (v20) {
        sub_100053B7C(v20);
      }
    }

    else
    {
      uint64_t v21 = 0LL;
    }

    free(v21);
  }

  uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  1LL,  0LL));
  int v25 = 0LL;
LABEL_64:
  uint64_t v37 = *(void *)(a1 + 40);
  if (v37) {
    (*(void (**)(uint64_t, void *, void *))(v37 + 16))(v37, v25, v31);
  }
}

void sub_100015AFC(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([*(id *)(a1 + 32) notifyNextPersonaObserver:v3 withUser:*(unsigned int *)(a1 + 40)])
  {
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    unsigned int v4 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = 0LL;
      unsigned int v5 = sub_100053B4C(1);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v6 = v5;
      }
      else {
        uint64_t v6 = v5 & 0xFFFFFFFE;
      }
      if ((_DWORD)v6)
      {
        int v12 = 138412290;
        id v13 = v3;
        unsigned int v7 = (const char *)_os_log_send_and_compose_impl( v6,  &v11,  0LL,  0LL,  &_mh_execute_header,  v4,  0LL,  "Successfully notified personaObserver:%@",  &v12,  12);
        goto LABEL_18;
      }

      goto LABEL_20;
    }
  }

  else
  {
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    unsigned int v4 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = 0LL;
      unsigned int v8 = sub_100053B4C(1);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v9 = v8;
      }
      else {
        uint64_t v9 = v8 & 0xFFFFFFFE;
      }
      if ((_DWORD)v9)
      {
        int v12 = 138412290;
        id v13 = v3;
        unsigned int v7 = (const char *)_os_log_send_and_compose_impl( v9,  &v11,  0LL,  0LL,  &_mh_execute_header,  v4,  0LL,  "Failed to notify persona personaObserver:%@",  &v12,  12);
LABEL_18:
        unsigned int v10 = (char *)v7;
        if (v7) {
          sub_100053B7C(v7);
        }
        goto LABEL_21;
      }

LABEL_20:
      unsigned int v10 = 0LL;
LABEL_21:
      free(v10);
    }
  }
}

      uint64_t v11 = 0LL;
LABEL_21:
      free(v11);
    }
  }

  return v4 == 0;
}

      uint64_t v11 = 0LL;
LABEL_21:
      free(v11);
    }
  }

  return v4 == 0;
}

      id v13 = 0LL;
LABEL_21:
      free(v13);
    }
  }

  return v6 == 0;
}

      uint64_t v9 = 0LL;
LABEL_21:
      free(v9);
    }
  }

  return v2;
}

      uint64_t v9 = 0LL;
LABEL_21:
      free(v9);
    }
  }

  return v2;
}

      uint64_t v11 = 0LL;
LABEL_21:
      free(v11);
    }
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  int v12 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t v81 = 0LL;
    id v13 = sub_100053B4C(1);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v14 = v13;
    }
    else {
      uint64_t v14 = v13 & 0xFFFFFFFE;
    }
    if ((_DWORD)v14)
    {
      LODWORD(v82) = 67109120;
      HIDWORD(v82) = a1;
      uint64_t v15 = (const char *)_os_log_send_and_compose_impl( v14,  v81,  0LL,  0LL,  &_mh_execute_header,  v12,  0LL,  "Removing Sandbox kext path upload for bubble with uid %ds",  &v82);
      int v16 = (char *)v15;
      if (v15) {
        sub_100053B7C(v15);
      }
    }

    else
    {
      int v16 = 0LL;
    }

    free(v16);
  }

  sub_100033870(a1);
  unsigned int v17 = sub_100054ED0(qword_1000DBA70, a1);
  uint64_t v18 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue(v17);
  if (v18)
  {
    int v19 = v18;
    if (!CFDictionaryContainsKey(v18, kUMUserSessionVolumeDeviceNodeKey)) {
      goto LABEL_161;
    }
    sub_10002FA4C(v19);
    if ([(id)qword_1000DBA68 unmountVolumeWithSession:v19 mountPath:0 error:0])
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      int v20 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)uint64_t v81 = 0LL;
        uint64_t v21 = sub_100053B4C(1);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v22 = v21;
        }
        else {
          uint64_t v22 = v21 & 0xFFFFFFFE;
        }
        if ((_DWORD)v22)
        {
          LOWORD(v82) = 0;
          LODWORD(v79) = 2;
          int v23 = (const char *)_os_log_send_and_compose_impl( v22,  v81,  0LL,  0LL,  &_mh_execute_header,  v20,  0LL,  "APFSUser Volume unmounted after Sync bubble",  &v82,  v79);
          goto LABEL_52;
        }

        goto LABEL_54;
      }
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      int v20 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)uint64_t v81 = 0LL;
        id v24 = sub_100053B4C(1);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
          int v25 = v24;
        }
        else {
          int v25 = v24 & 0xFFFFFFFE;
        }
        if ((_DWORD)v25)
        {
          LOWORD(v82) = 0;
          LODWORD(v79) = 2;
          int v23 = (const char *)_os_log_send_and_compose_impl( v25,  v81,  0LL,  0LL,  &_mh_execute_header,  v20,  0LL,  "APFSUser Volume failed to unmount after sync bubble",  &v82,  v79);
LABEL_52:
          unsigned int v26 = (char *)v23;
          if (v23) {
            sub_100053B7C(v23);
          }
          goto LABEL_55;
        }

      uint64_t v9 = 0LL;
      goto LABEL_21;
    }
  }

      unsigned int v8 = 0LL;
LABEL_21:
      free(v8);
    }
  }

  return v1;
}

      unsigned int v10 = 0LL;
LABEL_21:
      free(v10);
    }
  }

  return v3;
}

      unsigned int v8 = 0LL;
LABEL_21:
      free(v8);
    }
  }

  if (!sub_100033A14(*(unsigned __int8 *)(a1 + 40)))
  {
    if (*(_BYTE *)(a1 + 40))
    {
      if (qword_1000DBB98 != -1) {
        dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
      }
      uint64_t v9 = (os_log_s *)(id)qword_1000DBB90;
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_61;
      }
      uint64_t v22 = 0LL;
      id v13 = sub_100053B4C(1);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v14 = v13;
      }
      else {
        uint64_t v14 = v13 & 0xFFFFFFFE;
      }
      if (!(_DWORD)v14) {
        goto LABEL_59;
      }
      LOWORD(v21) = 0;
      LODWORD(v20) = 2;
      int v12 = (const char *)_os_log_send_and_compose_impl( v14,  &v22,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "FAILED Internal test setup",  &v21,  v20,  v21);
    }

    else
    {
      if (qword_1000DBB98 != -1) {
        dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
      }
      uint64_t v9 = (os_log_s *)(id)qword_1000DBB90;
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_61;
      }
      uint64_t v22 = 0LL;
      unsigned int v17 = sub_100053B4C(1);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v18 = v17;
      }
      else {
        uint64_t v18 = v17 & 0xFFFFFFFE;
      }
      if (!(_DWORD)v18) {
        goto LABEL_59;
      }
      LOWORD(v21) = 0;
      LODWORD(v20) = 2;
      int v12 = (const char *)_os_log_send_and_compose_impl( v18,  &v22,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "FAILED Internal test Cleared",  &v21,  v20,  v21);
    }

      unsigned int v8 = 0LL;
LABEL_21:
      free(v8);
    }
  }

  if (sub_10001E1D0(*(_DWORD *)(a1 + 40)))
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v9 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = 0LL;
      unsigned int v10 = sub_100053B4C(1);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = v10 & 0xFFFFFFFE;
      }
      if ((_DWORD)v11)
      {
        int v12 = *(_DWORD *)(a1 + 40);
        uint64_t v22 = 67109120;
        int v23 = v12;
        id v13 = (const char *)_os_log_send_and_compose_impl( v11,  &v21,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "Network BK_SYS value set to %d",  &v22);
        uint64_t v14 = (char *)v13;
        if (v13) {
          sub_100053B7C(v13);
        }
      }

      else
      {
        uint64_t v14 = 0LL;
      }

      free(v14);
    }

    dword_1000DBD18 = *(_DWORD *)(a1 + 40);
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
    sub_10001AED4();
  }

  else
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v15 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = 0LL;
      int v16 = sub_100053B4C(1);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
        unsigned int v17 = v16;
      }
      else {
        unsigned int v17 = v16 & 0xFFFFFFFE;
      }
      if ((_DWORD)v17)
      {
        uint64_t v18 = *(_DWORD *)(a1 + 40);
        uint64_t v22 = 67109120;
        int v23 = v18;
        int v19 = (const char *)_os_log_send_and_compose_impl( v17,  &v21,  0LL,  0LL,  &_mh_execute_header,  v15,  0LL,  "Failed to set Network BK_SYS value %d",  &v22);
        int v20 = (char *)v19;
        if (v19) {
          sub_100053B7C(v19);
        }
      }

      else
      {
        int v20 = 0LL;
      }

      free(v20);
    }
  }

      unsigned int v8 = 0LL;
LABEL_21:
      free(v8);
    }
  }

  return 1LL;
}

      uint64_t v18 = 0LL;
LABEL_21:
      free(v18);
    }
  }

  return PersonaKeyForUser;
}

      uint64_t v14 = 0LL;
LABEL_21:
      free(v14);
    }
  }

  return v7;
}

      id v13 = 0LL;
LABEL_21:
      free(v13);
    }
  }
}

            memset_s(v13, v11, 0, v11);
            free(v13);
            if (v18)
            {
              memset_s(v18, v16, 0, v16);
              free(v18);
            }
          }

          else
          {
            return 0xFFFFFFFFLL;
          }
        }
      }
    }
  }

  return v3;
}

void sub_1000160E4(id a1)
{
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  uint64_t v1 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = 0LL;
    unsigned int v2 = sub_100053B4C(1);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v3 = v2;
    }
    else {
      uint64_t v3 = v2 & 0xFFFFFFFE;
    }
    if ((_DWORD)v3)
    {
      __int16 v6 = 0;
      unsigned int v4 = (const char *)_os_log_send_and_compose_impl( v3,  &v7,  0LL,  0LL,  &_mh_execute_header,  v1,  0LL,  "interruptionHandler  notifyNextPersonaObserver",  &v6,  2);
      unsigned int v5 = (char *)v4;
      if (v4) {
        sub_100053B7C(v4);
      }
    }

    else
    {
      unsigned int v5 = 0LL;
    }

    free(v5);
  }
}

void sub_1000161D4(id a1)
{
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  uint64_t v1 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = 0LL;
    unsigned int v2 = sub_100053B4C(1);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v3 = v2;
    }
    else {
      uint64_t v3 = v2 & 0xFFFFFFFE;
    }
    if ((_DWORD)v3)
    {
      __int16 v6 = 0;
      unsigned int v4 = (const char *)_os_log_send_and_compose_impl( v3,  &v7,  0LL,  0LL,  &_mh_execute_header,  v1,  0LL,  "Invalidation notifyNextPersonaObserver",  &v6,  2);
      unsigned int v5 = (char *)v4;
      if (v4) {
        sub_100053B7C(v4);
      }
    }

    else
    {
      unsigned int v5 = 0LL;
    }

    free(v5);
  }
}

id sub_1000162C4(uint64_t a1)
{
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  unsigned int v2 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = 0LL;
    unsigned int v3 = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      uint64_t v5 = *(void *)(a1 + 32);
      int v10 = 138412290;
      uint64_t v11 = v5;
      __int16 v6 = (const char *)_os_log_send_and_compose_impl( v4,  &v9,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "personaListDidUpdateCompletionHandler completion handler from machService:%@",  &v10,  12);
      uint64_t v7 = (char *)v6;
      if (v6) {
        sub_100053B7C(v6);
      }
    }

    else
    {
      uint64_t v7 = 0LL;
    }

    free(v7);
  }

  return [*(id *)(a1 + 40) invalidate];
}

void sub_100016498(uint64_t a1)
{
  unsigned int v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _clientForPID:*(unsigned int *)(a1 + 48)]);
  int v29 = -1;
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  unsigned int v3 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v28 = 0LL;
    unsigned int v4 = sub_100053B4C(1);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = v4 & 0xFFFFFFFE;
    }
    if ((_DWORD)v5)
    {
      unsigned int v6 = *(_DWORD *)(a1 + 48);
      int v30 = 67109120;
      unsigned int v31 = v6;
      uint64_t v7 = (const char *)_os_log_send_and_compose_impl( v5,  &v28,  0LL,  0LL,  &_mh_execute_header,  v3,  0LL,  "In RDServer: registerUserPersonaStakeholderForPID from pid:%d",  &v30);
      unsigned int v8 = (char *)v7;
      if (v7) {
        sub_100053B7C(v7);
      }
    }

    else
    {
      unsigned int v8 = 0LL;
    }

    free(v8);
  }

  if ([v2 hasEntitlement:@"com.apple.usermanagerd.persona.observer"])
  {
    unsigned int v9 = [*(id *)(a1 + 32) asidForClient:v2 withAuid:&v29 withPid:*(unsigned int *)(a1 + 48)];
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    int v10 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v28 = 0LL;
      unsigned int v11 = sub_100053B4C(1);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v12 = v11;
      }
      else {
        uint64_t v12 = v11 & 0xFFFFFFFE;
      }
      if ((_DWORD)v12)
      {
        int v30 = 67109120;
        unsigned int v31 = v9;
        id v13 = (const char *)_os_log_send_and_compose_impl( v12,  &v28,  0LL,  0LL,  &_mh_execute_header,  v10,  0LL,  "Registering PersonaStakeholder for asid:%d",  &v30);
        uint64_t v14 = (char *)v13;
        if (v13) {
          sub_100053B7C(v13);
        }
      }

      else
      {
        uint64_t v14 = 0LL;
      }

      free(v14);
    }

    [v2 setPersonaStakeHolderIsRegistered:1];
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    uint64_t v21 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v28 = 0LL;
      unsigned int v22 = sub_100053B4C(1);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v23 = v22;
      }
      else {
        uint64_t v23 = v22 & 0xFFFFFFFE;
      }
      if ((_DWORD)v23)
      {
        LOWORD(v30) = 0;
        id v24 = (const char *)_os_log_send_and_compose_impl( v23,  &v28,  0LL,  0LL,  &_mh_execute_header,  v21,  0LL,  "registerUserPersonaStakeholderForPID Success",  &v30,  2);
        int v25 = (char *)v24;
        if (v24) {
          sub_100053B7C(v24);
        }
      }

      else
      {
        int v25 = 0LL;
      }

      free(v25);
    }

    unsigned int v26 = 0LL;
  }

  else
  {
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    uint64_t v15 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v28 = 0LL;
      unsigned int v16 = sub_100053B4C(1);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v17 = v16;
      }
      else {
        uint64_t v17 = v16 & 0xFFFFFFFE;
      }
      if ((_DWORD)v17)
      {
        unsigned int v18 = *(_DWORD *)(a1 + 48);
        int v30 = 67109120;
        unsigned int v31 = v18;
        int v19 = (const char *)_os_log_send_and_compose_impl( v17,  &v28,  0LL,  0LL,  &_mh_execute_header,  v15,  0LL,  "Entitlement Failure for pid:%d",  &v30);
        int v20 = (char *)v19;
        if (v19) {
          sub_100053B7C(v19);
        }
      }

      else
      {
        int v20 = 0LL;
      }

      free(v20);
    }

    unsigned int v26 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  1LL,  0LL));
  }

  uint64_t v27 = *(void *)(a1 + 40);
  if (v27) {
    (*(void (**)(uint64_t, void *))(v27 + 16))(v27, v26);
  }
}

void sub_1000169DC(uint64_t a1)
{
  unsigned int v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _clientForPID:*(unsigned int *)(a1 + 56)]);
  HIDWORD(v3_Block_object_dispose(va, 8) = -1;
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  unsigned int v3 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v40 = 0LL;
    unsigned int v4 = sub_100053B4C(1);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG)) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = v4 & 0xFFFFFFFE;
    }
    if ((_DWORD)v5)
    {
      int v6 = *(_DWORD *)(a1 + 56);
      uint64_t v7 = *(void *)(a1 + 40);
      *(_DWORD *)int v39 = 67109378;
      *(_DWORD *)&v39[4] = v6;
      *(_WORD *)&v39[8] = 2112;
      *(void *)&v39[10] = v7;
      LODWORD(v3_Block_object_dispose(va, 8) = 18;
      unsigned int v8 = (const char *)_os_log_send_and_compose_impl( v5,  &v40,  0LL,  0LL,  &_mh_execute_header,  v3,  2LL,  "In RDServer: registerUserPersonaObserverForPID from pid:%d; machservice:%@",
                           v39,
                           v38);
      unsigned int v9 = (char *)v8;
      if (v8) {
        sub_100053B7C(v8);
      }
    }

    else
    {
      unsigned int v9 = 0LL;
    }

    free(v9);
  }

  if ([v2 hasEntitlement:@"com.apple.usermanagerd.persona.observer"])
  {
    id v10 = [*(id *)(a1 + 32) asidForClient:v2 withAuid:(char *)&v38 + 4 withPid:*(unsigned int *)(a1 + 56)];
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    unsigned int v11 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v40 = 0LL;
      unsigned int v12 = sub_100053B4C(1);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v13 = v12;
      }
      else {
        uint64_t v13 = v12 & 0xFFFFFFFE;
      }
      if ((_DWORD)v13)
      {
        uint64_t v14 = *(void *)(a1 + 40);
        *(_DWORD *)int v39 = 138412546;
        *(void *)&v39[4] = v14;
        *(_WORD *)&v39[12] = 1024;
        *(_DWORD *)&v39[14] = (_DWORD)v10;
        LODWORD(v3_Block_object_dispose(va, 8) = 18;
        uint64_t v15 = (const char *)_os_log_send_and_compose_impl( v13,  &v40,  0LL,  0LL,  &_mh_execute_header,  v11,  0LL,  "Registering PersonaObserver with machService:%@ with asid:%d",  v39,  v38);
        unsigned int v16 = (char *)v15;
        if (v15) {
          sub_100053B7C(v15);
        }
      }

      else
      {
        unsigned int v16 = 0LL;
      }

      free(v16);
    }

    uint64_t v23 = sub_100046664((uint64_t)v10, HIDWORD(v38), *(unsigned int *)(a1 + 60));
    id v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
    if (sub_10004AFA4(*(const __CFString **)(a1 + 40), v24))
    {
      if (qword_1000DBA10 != -1) {
        dispatch_once(&qword_1000DBA10, &stru_1000CD208);
      }
      int v25 = (os_log_s *)(id)qword_1000DBA08;
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)int v39 = 0LL;
        unsigned int v26 = sub_100053B4C(1);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v27 = v26;
        }
        else {
          uint64_t v27 = v26 & 0xFFFFFFFE;
        }
        if ((_DWORD)v27)
        {
          LOWORD(v40) = 0;
          LODWORD(v3_Block_object_dispose(va, 8) = 2;
          uint64_t v28 = (const char *)_os_log_send_and_compose_impl( v27,  v39,  0LL,  0LL,  &_mh_execute_header,  v25,  0LL,  "Successful Persona Observer registration of machServiceName",  &v40,  v38);
          int v29 = (char *)v28;
          if (v28) {
            sub_100053B7C(v28);
          }
        }

        else
        {
          int v29 = 0LL;
        }

        free(v29);
      }

      uint64_t v36 = 0LL;
    }

    else
    {
      if (qword_1000DBA10 != -1) {
        dispatch_once(&qword_1000DBA10, &stru_1000CD208);
      }
      int v30 = (os_log_s *)(id)qword_1000DBA08;
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v40 = 0LL;
        unsigned int v31 = sub_100053B4C(1);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v32 = v31;
        }
        else {
          uint64_t v32 = v31 & 0xFFFFFFFE;
        }
        if ((_DWORD)v32)
        {
          uint64_t v33 = *(void *)(a1 + 40);
          *(_DWORD *)int v39 = 138412290;
          *(void *)&v39[4] = v33;
          LODWORD(v3_Block_object_dispose(va, 8) = 12;
          uint64_t v34 = (const char *)_os_log_send_and_compose_impl( v32,  &v40,  0LL,  0LL,  &_mh_execute_header,  v30,  0LL,  "Failed to register Persona Observer:%@",  v39,  v38);
          unsigned int v35 = (char *)v34;
          if (v34) {
            sub_100053B7C(v34);
          }
        }

        else
        {
          unsigned int v35 = 0LL;
        }

        free(v35);
      }

      uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  22LL,  0LL));
    }
  }

  else
  {
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    uint64_t v17 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)int v39 = 0LL;
      unsigned int v18 = sub_100053B4C(1);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v19 = v18;
      }
      else {
        uint64_t v19 = v18 & 0xFFFFFFFE;
      }
      if ((_DWORD)v19)
      {
        int v20 = *(_DWORD *)(a1 + 56);
        LODWORD(v40) = 67109120;
        HIDWORD(v40) = v20;
        uint64_t v21 = (const char *)_os_log_send_and_compose_impl( v19,  v39,  0LL,  0LL,  &_mh_execute_header,  v17,  0LL,  "Entitlement Failure for pid:%d",  &v40);
        unsigned int v22 = (char *)v21;
        if (v21) {
          sub_100053B7C(v21);
        }
      }

      else
      {
        unsigned int v22 = 0LL;
      }

      free(v22);
    }

    uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  1LL,  0LL));
  }

  uint64_t v37 = *(void *)(a1 + 48);
  if (v37) {
    (*(void (**)(uint64_t, void *))(v37 + 16))(v37, v36);
  }
}

void sub_100017040(uint64_t a1)
{
  unsigned int v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _clientForPID:*(unsigned int *)(a1 + 56)]);
  if (qword_1000DBA10 != -1) {
    dispatch_once(&qword_1000DBA10, &stru_1000CD208);
  }
  unsigned int v3 = (os_log_s *)(id)qword_1000DBA08;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v26 = 0LL;
    unsigned int v4 = sub_100053B4C(1);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG)) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = v4 & 0xFFFFFFFE;
    }
    if ((_DWORD)v5)
    {
      int v6 = *(_DWORD *)(a1 + 56);
      uint64_t v7 = *(void *)(a1 + 40);
      *(_DWORD *)int v25 = 67109378;
      *(_DWORD *)&v25[4] = v6;
      *(_WORD *)&v25[8] = 2112;
      *(void *)&v25[10] = v7;
      unsigned int v8 = (const char *)_os_log_send_and_compose_impl( v5,  &v26,  0LL,  0LL,  &_mh_execute_header,  v3,  2LL,  "In RDServer: provisionDevice from pid:%d; with: %@",
                           v25,
                           18);
      unsigned int v9 = (char *)v8;
      if (v8) {
        sub_100053B7C(v8);
      }
    }

    else
    {
      unsigned int v9 = 0LL;
    }

    free(v9);
  }

  if ([v2 hasEntitlement:@"com.apple.mkb.usersession.loginwindow"])
  {
    uint64_t v10 = sub_10004AF9C();
    unsigned int v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    unsigned int v18 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v26 = 0LL;
      unsigned int v19 = sub_100053B4C(1);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v20 = v19;
      }
      else {
        uint64_t v20 = v19 & 0xFFFFFFFE;
      }
      if ((_DWORD)v20)
      {
        *(_DWORD *)int v25 = 138412290;
        *(void *)&v25[4] = v11;
        uint64_t v21 = (const char *)_os_log_send_and_compose_impl( v20,  &v26,  0LL,  0LL,  &_mh_execute_header,  v18,  0LL,  "Successful Provisioning with return dict:%@",  v25,  12LL);
        unsigned int v22 = (char *)v21;
        if (v21) {
          sub_100053B7C(v21);
        }
      }

      else
      {
        unsigned int v22 = 0LL;
      }

      free(v22);
    }

    uint64_t v23 = 0LL;
  }

  else
  {
    if (qword_1000DBA10 != -1) {
      dispatch_once(&qword_1000DBA10, &stru_1000CD208);
    }
    unsigned int v12 = (os_log_s *)(id)qword_1000DBA08;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)int v25 = 0LL;
      unsigned int v13 = sub_100053B4C(1);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v14 = v13;
      }
      else {
        uint64_t v14 = v13 & 0xFFFFFFFE;
      }
      if ((_DWORD)v14)
      {
        int v15 = *(_DWORD *)(a1 + 56);
        LODWORD(v26) = 67109120;
        HIDWORD(v26) = v15;
        unsigned int v16 = (const char *)_os_log_send_and_compose_impl( v14,  v25,  0LL,  0LL,  &_mh_execute_header,  v12,  0LL,  "Entitlement Failure for pid:%d",  &v26);
        uint64_t v17 = (char *)v16;
        if (v16) {
          sub_100053B7C(v16);
        }
      }

      else
      {
        uint64_t v17 = 0LL;
      }

      free(v17);
    }

    uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  1LL,  0LL));
    unsigned int v11 = 0LL;
  }

  uint64_t v24 = *(void *)(a1 + 48);
  if (v24) {
    (*(void (**)(uint64_t, void *, void *))(v24 + 16))(v24, v11, v23);
  }
}

void sub_100017880(id a1)
{
  os_log_t v1 = os_log_create(off_1000DAE70, "legacy");
  unsigned int v2 = (void *)qword_1000DBA08;
  qword_1000DBA08 = (uint64_t)v1;
}

void sub_1000178B4(id a1)
{
  os_log_t v1 = os_log_create(off_1000DAE70, "user");
  unsigned int v2 = (void *)qword_1000DBA18;
  qword_1000DBA18 = (uint64_t)v1;
}

BOOL sub_100017958(id a1, unsigned int *a2)
{
  kern_return_t multiuser_config_flags;
  os_log_s *v5;
  unsigned int v6;
  uint64_t v7;
  const char *v8;
  char *v9;
  uint64_t v11;
  _DWORD v12[2];
  if (!a2) {
    _os_assumes_log(0LL);
  }
  *a2 = 0;
  mach_port_t v3 = mach_host_self();
  multiuser_config_flags = host_get_multiuser_config_flags(v3, a2);
  if (multiuser_config_flags)
  {
    if (qword_1000DBA30 != -1) {
      dispatch_once(&qword_1000DBA30, &stru_1000CD2C8);
    }
    uint64_t v5 = (os_log_s *)(id)qword_1000DBA28;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      unsigned int v11 = 0LL;
      int v6 = sub_100053B4C(0);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        uint64_t v7 = v6;
      }
      else {
        uint64_t v7 = v6 & 0xFFFFFFFE;
      }
      if ((_DWORD)v7)
      {
        v12[0] = 67109120;
        v12[1] = multiuser_config_flags;
        unsigned int v8 = (const char *)_os_log_send_and_compose_impl( v7,  &v11,  0LL,  0LL,  &_mh_execute_header,  v5,  16LL,  "host_get_multiuser_config_flags() failed: %{mach.errno}d",  v12,  8);
        unsigned int v9 = (char *)v8;
        if (v8) {
          sub_100053B7C(v8);
        }
      }

      else
      {
        unsigned int v9 = 0LL;
      }

      free(v9);
    }
  }

  return multiuser_config_flags == 0;
}

BOOL sub_100017ABC(id a1, unsigned int a2)
{
  kern_return_t v4;
  os_log_s *v5;
  unsigned int v6;
  uint64_t v7;
  const char *v8;
  unsigned int v9;
  uint64_t v10;
  char *v11;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  mach_port_t v3 = mach_host_self();
  unsigned int v4 = host_set_multiuser_config_flags(v3, a2);
  if (v4)
  {
    if (qword_1000DBA30 != -1) {
      dispatch_once(&qword_1000DBA30, &stru_1000CD2C8);
    }
    uint64_t v5 = (os_log_s *)(id)qword_1000DBA28;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      int v15 = 0LL;
      int v6 = sub_100053B4C(0);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        uint64_t v7 = v6;
      }
      else {
        uint64_t v7 = v6 & 0xFFFFFFFE;
      }
      if ((_DWORD)v7)
      {
        LODWORD(v13) = 67109376;
        HIDWORD(v13) = a2;
        LOWORD(v14) = 1024;
        *(_DWORD *)((char *)&v14 + 2) = v4;
        unsigned int v8 = (const char *)_os_log_send_and_compose_impl( v7,  &v15,  0LL,  0LL,  &_mh_execute_header,  v5,  16LL,  "host_set_multiuser_config_flags(%u) failed: %{mach.errno}d",  &v13,  14,  v13,  v14,  v15);
        goto LABEL_18;
      }

      goto LABEL_20;
    }
  }

  else
  {
    if (qword_1000DBA30 != -1) {
      dispatch_once(&qword_1000DBA30, &stru_1000CD2C8);
    }
    uint64_t v5 = (os_log_s *)(id)qword_1000DBA28;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      unsigned int v13 = 0LL;
      unsigned int v9 = sub_100053B4C(0);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG)) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = v9 & 0xFFFFFFFE;
      }
      if ((_DWORD)v10)
      {
        unsigned int v8 = (const char *)_os_log_send_and_compose_impl( v10,  &v13,  0LL,  0LL,  &_mh_execute_header,  v5,  2LL,  "host_set_multiuser_config_flags(%u)",  &v15);
LABEL_18:
        unsigned int v11 = (char *)v8;
        if (v8) {
          sub_100053B7C(v8);
        }
        goto LABEL_21;
      }

void sub_100017CC8(id a1)
{
  os_log_t v1 = os_log_create(off_1000DAE70, "sideeffect");
  unsigned int v2 = (void *)qword_1000DBA28;
  qword_1000DBA28 = (uint64_t)v1;
}

NSUUID *sub_100017CFC(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_self(a1);
  unsigned int v4 = -[NSUUID initWithUUIDString:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDString:", v3);

  return v4;
}

id sub_100017D48(uint64_t a1, const __CFUUID *a2)
{
  if (a2)
  {
    id v3 = (__CFString *)CFUUIDCreateString(kCFAllocatorDefault, a2);
    if (!v3) {
      sub_1000A9AD0();
    }
    unsigned int v4 = v3;
    uint64_t v5 = sub_100017CFC((uint64_t)&OBJC_CLASS___NSUUID, v3);
    int v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
    CFRelease(v4);
  }

  else
  {
    int v6 = 0LL;
  }

  return v6;
}

CFUUIDRef sub_100017DB8(void *a1)
{
  if (!a1) {
    return 0LL;
  }
  os_log_t v1 = (__CFString *)objc_claimAutoreleasedReturnValue([a1 UUIDString]);
  CFUUIDRef v2 = CFUUIDCreateFromString(kCFAllocatorDefault, v1);

  if (!v2) {
    sub_1000A9AD0();
  }
  return v2;
}

void sub_100018BEC(id a1)
{
  os_log_t v1 = os_log_create(off_1000DAE70, "sideeffect");
  CFUUIDRef v2 = (void *)qword_1000DBA38;
  qword_1000DBA38 = (uint64_t)v1;
}

id sub_100018C20(uint64_t a1)
{
  if (a1)
  {
    CFUUIDRef v2 = (void *)objc_claimAutoreleasedReturnValue([@"encrypt" dataUsingEncoding:4]);
    id v3 = [v2 mutableCopy];

    [v3 appendData:a1];
  }

  else
  {
    id v3 = 0LL;
  }

  return v3;
}

id sub_100018C84(void *a1)
{
  if (a1)
  {
    os_log_t v1 = a1;
    CFUUIDRef v2 = [@"encrypt" length];
    id v3 = v1;
    a1 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableData dataWithBytes:length:]( NSMutableData,  "dataWithBytes:length:",  &v2[(void)[v3 bytes]],  (_BYTE *)objc_msgSend(v3, "length") - v2));
  }

  return a1;
}

LABEL_13:
  return v10;
}

  return v8;
}

  if (v12)
  {
    memset_s(v12, __n, 0, __n);
    free(__s);
  }

  if (v17)
  {
    memset_s(v17, __smax, 0, __smax);
    free(v17);
  }

  return v4;
}

uint64_t sub_100018E74(uint64_t result)
{
  if (result) {
    return *(void *)(result + 48);
  }
  return result;
}

uint64_t sub_100018E80(uint64_t result)
{
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

uint64_t sub_100018F4C(uint64_t result)
{
  if (result) {
    return *(void *)(result + 56);
  }
  return result;
}

uint64_t sub_100018F58(uint64_t result)
{
  if (result) {
    return *(void *)(result + 64);
  }
  return result;
}

uint64_t sub_100019024(uint64_t result)
{
  if (result) {
    return *(void *)(result + 72);
  }
  return result;
}

uint64_t sub_100019030(uint64_t result)
{
  if (result) {
    return *(void *)(result + 80);
  }
  return result;
}

uint64_t sub_100019098(uint64_t result)
{
  if (result) {
    return *(void *)(result + 88);
  }
  return result;
}

uint64_t sub_100019100(uint64_t result)
{
  if (result) {
    return *(void *)(result + 96);
  }
  return result;
}

BOOL sub_100019120(BOOL result)
{
  if (result) {
    return *(_BYTE *)(result + 9) != 0;
  }
  return result;
}

uint64_t sub_100019190(uint64_t result)
{
  if (result) {
    return *(void *)(result + 104);
  }
  return result;
}

uint64_t sub_1000191F8(uint64_t result)
{
  if (result) {
    return *(void *)(result + 112);
  }
  return result;
}

uint64_t sub_100019260(uint64_t result)
{
  if (result) {
    return *(void *)(result + 120);
  }
  return result;
}

uint64_t sub_1000192C8(uint64_t result)
{
  if (result) {
    return *(void *)(result + 128);
  }
  return result;
}

uint64_t sub_100019428(uint64_t result)
{
  if (result) {
    return *(void *)(result + 136);
  }
  return result;
}

uint64_t sub_100019434(uint64_t result)
{
  if (result) {
    return *(void *)(result + 24);
  }
  return result;
}

uint64_t sub_100019594(uint64_t result)
{
  if (result) {
    return *(void *)(result + 144);
  }
  return result;
}

LABEL_22:
    unsigned int v12 = 0;
    goto LABEL_23;
  }

  if (v11)
  {
    if (self) {
      personas = self->_personas;
    }
    else {
      personas = 0LL;
    }
    int v15 = personas;
    unsigned int v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v8));
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKeyedSubscript:](v15, "objectForKeyedSubscript:", v16));

    if (([v17 containsObject:v11] & 1) == 0)
    {
      if (a6) {
        *a6 = (id)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  2LL,  0LL));
      }

      goto LABEL_22;
    }

    unsigned int v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v8));
    if (self)
    {
      -[NSMutableDictionary setObject:forKeyedSubscript:]( self->_mappedVolumes,  "setObject:forKeyedSubscript:",  v18,  v10);

      mappedVolumePersonas = self->_mappedVolumePersonas;
    }

    else
    {
      [0 setObject:v18 forKeyedSubscript:v10];

      mappedVolumePersonas = 0LL;
    }

    -[NSMutableDictionary setObject:forKeyedSubscript:](mappedVolumePersonas, "setObject:forKeyedSubscript:", v11, v10);
  }

  else
  {
    uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v8));
    if (self) {
      mappedVolumes = self->_mappedVolumes;
    }
    else {
      mappedVolumes = 0LL;
    }
    -[NSMutableDictionary setObject:forKeyedSubscript:](mappedVolumes, "setObject:forKeyedSubscript:", v20, v10);
  }

  sub_10002E554(a1, a2, a3);
  return 0LL;
}

      unsigned int v16 = 0LL;
LABEL_23:
      free(v16);
    }
  }
}

      unsigned int v11 = 0LL;
LABEL_23:
      free(v11);
    }
  }

  return v3;
}

      uint64_t v10 = 0LL;
LABEL_23:
      free(v10);
    }
  }

  return v2;
}

    uint64_t v17 = 0LL;
LABEL_23:
    free(v17);
LABEL_24:

    unsigned int v8 = 0LL;
    goto LABEL_25;
  }

  sub_100056838((uint64_t)v4, a2[1]);
  int v6 = sub_100080778((uint64_t)v3, a2[2]);
  sub_100064174((uint64_t)v5, v6);
  if (sub_100064168((uint64_t)v5) == -1)
  {
    if (qword_1000DBBF8 != -1) {
      dispatch_once(&qword_1000DBBF8, &stru_1000CDB88);
    }
    unsigned int v9 = (os_log_s *)(id)qword_1000DBBF0;
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      goto LABEL_24;
    }
    unsigned int v19 = 0LL;
    uint64_t v14 = sub_100053B4C(0);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      int v15 = v14;
    }
    else {
      int v15 = v14 & 0xFFFFFFFE;
    }
    if ((_DWORD)v15)
    {
      unsigned int v16 = a2[2];
      uint64_t v20 = 67109120;
      uint64_t v21 = v16;
      unsigned int v13 = (const char *)_os_log_send_and_compose_impl( v15,  &v19,  0LL,  0LL,  &_mh_execute_header,  v9,  16LL,  "Failed to parse kpersona_info struct: Unknown type: %d",  &v20);
LABEL_20:
      uint64_t v17 = (char *)v13;
      if (v13) {
        sub_100053B7C(v13);
      }
      goto LABEL_23;
    }

    goto LABEL_22;
  }

  uint64_t v7 = (char *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a2 + 22));
  sub_10007420C(v5, v7);

  sub_1000642F8((uint64_t)v5, a2[86]);
  unsigned int v8 = v5;
LABEL_25:

  return v8;
}

LABEL_4:
  unsigned int v12 = 1;
LABEL_23:

  return v12;
}

  uint64_t v7 = os_log_set_client_type(1LL, 0LL);
  nscf_formatter = _os_log_get_nscf_formatter(v7);
  _os_log_set_nscf_formatter(0LL);
  unsigned int v9 = sub_100063D18( (uint64_t)&OBJC_CLASS___UMDRotatingLog,  (void *)qword_1000DBD40,  "/var/logs/usermanagerd.log",  (void *)0x100000,  3);
  uint64_t v10 = objc_claimAutoreleasedReturnValue(v9);
  unsigned int v11 = (void *)qword_1000DBAF8;
  qword_1000DBAF8 = v10;

  if (qword_1000DBB28 != -1) {
    dispatch_once(&qword_1000DBB28, &stru_1000CD650);
  }
  unsigned int v12 = (os_log_s *)(id)qword_1000DBB20;
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v35 = 0LL;
    if (byte_1000DBD39) {
      unsigned int v13 = byte_1000DBD38 == 0;
    }
    else {
      unsigned int v13 = 0;
    }
    if (v13) {
      uint64_t v14 = 1;
    }
    else {
      uint64_t v14 = 2;
    }
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
      int v15 = v14;
    }
    else {
      int v15 = v14 & 2;
    }
    if ((_DWORD)v15)
    {
      uint64_t v34 = 0;
      unsigned int v16 = (const char *)_os_log_send_and_compose_impl( v15,  &v35,  0LL,  0LL,  &_mh_execute_header,  v12,  0LL,  "Starting usermanagerd...",  &v34,  2);
      uint64_t v17 = (char *)v16;
      if (v16) {
        sub_100053B7C(v16);
      }
    }

    else
    {
      uint64_t v17 = 0LL;
    }

    free(v17);
  }

  unsigned int v18 = dispatch_queue_create("com.apple.mobile.keybagd.usermanagerd", 0LL);
  unsigned int v19 = (void *)qword_1000DBD48;
  qword_1000DBD48 = (uint64_t)v18;

  uint64_t v20 = dispatch_queue_create("com.apple.system.libinfo.muser", 0LL);
  uint64_t v21 = (void *)qword_1000DBD50;
  qword_1000DBD50 = (uint64_t)v20;

  unsigned int v22 = dispatch_queue_create("com.apple.usermanagerd.userswitch", 0LL);
  uint64_t v23 = (void *)qword_1000DBD58;
  qword_1000DBD58 = (uint64_t)v22;

  uint64_t v24 = dispatch_queue_create("com.apple.usermanagerd.volumemigrator", 0LL);
  int v25 = (void *)qword_1000DBD60;
  qword_1000DBD60 = (uint64_t)v24;

  if (sub_1000548AC())
  {
    if (qword_1000DBB18 != -1) {
      dispatch_once(&qword_1000DBB18, &stru_1000CD630);
    }
    uint64_t v26 = (os_log_s *)qword_1000DBB10;
    if (os_log_type_enabled((os_log_t)qword_1000DBB10, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v35 = 0LL;
      if (byte_1000DBD39) {
        uint64_t v27 = byte_1000DBD38 == 0;
      }
      else {
        uint64_t v27 = 0;
      }
      if (v27) {
        uint64_t v28 = 3;
      }
      else {
        uint64_t v28 = 2;
      }
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT)) {
        int v29 = v28;
      }
      else {
        int v29 = 2LL;
      }
      uint64_t v34 = 0;
      LODWORD(v33) = 2;
      int v30 = (const char *)_os_log_send_and_compose_impl( v29,  &v35,  0LL,  0LL,  &_mh_execute_header,  v26,  0LL,  "Enhanced APFS Mode Set",  &v34,  v33);
      unsigned int v31 = (char *)v30;
      if (v30) {
        sub_100053B7C(v30);
      }
      free(v31);
    }

    byte_1000DBD3A = 1;
  }

  if (!sub_1000547DC() && (os_variant_uses_ephemeral_storage("com.apple.mobile.keybagd") & 1) == 0) {
    sub_10001BD84();
  }
  fwrite("****** USERMANAGERD SESSION SETUP DONE  ****\n", 0x2DuLL, 1uLL, __stdoutp);
  sub_1000832FC();
  sub_100074054();
  sub_1000833D0();
  sub_10003754C();
  byte_1000DBD39 = 1;
  _os_log_set_nscf_formatter(nscf_formatter);
  openlog("usermanagerd", 1, 24);
  CFRunLoopRun();
  return 0LL;
}

uint64_t sub_100019794(uint64_t result)
{
  if (result) {
    return *(void *)(result + 152);
  }
  return result;
}

uint64_t sub_1000197A0(uint64_t result)
{
  if (result) {
    return *(void *)(result + 32);
  }
  return result;
}

uint64_t sub_1000197AC(uint64_t result)
{
  if (result) {
    return *(void *)(result + 40);
  }
  return result;
}

uint64_t sub_100019888(uint64_t result)
{
  if (result) {
    return *(void *)(result + 160);
  }
  return result;
}

void sub_1000198A4(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 16), a2);
  }
}

void sub_1000198B4(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 24), a2);
  }
}

void sub_1000198C4(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 32), a2);
  }
}

void sub_1000198D4(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 40), a2);
  }
}

void sub_1000198E4(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 48), a2);
  }
}

void sub_1000198F4(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 56), a2);
  }
}

void sub_100019904(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 64), a2);
  }
}

void sub_100019914(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 72), a2);
  }
}

void sub_100019924(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 80), a2);
  }
}

void sub_100019934(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 88), a2);
  }
}

void sub_100019944(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 96), a2);
  }
}

uint64_t sub_100019954(uint64_t result, char a2)
{
  if (result) {
    *(_BYTE *)(result + 9) = a2;
  }
  return result;
}

void sub_100019960(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 104), a2);
  }
}

void sub_100019970(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 112), a2);
  }
}

void sub_100019980(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 120), a2);
  }
}

void sub_100019990(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 128), a2);
  }
}

void sub_1000199A0(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 136), a2);
  }
}

void sub_1000199B0(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 144), a2);
  }
}

void sub_1000199C0(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 152), a2);
  }
}

void sub_1000199D0(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 160), a2);
  }
}

uint64_t sub_100019ADC(uint64_t result)
{
  if (result)
  {
    (*(void (**)(void))(*(void *)(result + 8) + 16LL))();
    return 0LL;
  }

  return result;
}

uint64_t sub_100019B18(uint64_t result)
{
  if (result) {
    return *(void *)(result + 8);
  }
  return result;
}

uint64_t sub_100019B24(uint64_t result)
{
  if (result)
  {
    (*(uint64_t (**)(void))(*(void *)(result + 8) + 16LL))();
    return 0LL;
  }

  return result;
}

uint64_t sub_100019B60(uint64_t result)
{
  if (result)
  {
    int v1 = 0;
    else {
      return 0xFFFFFFFFLL;
    }
  }

  return result;
}

uint64_t sub_100019BA0(uint64_t a1, unsigned int a2, int a3, int a4)
{
  if (!a1) {
    return 0LL;
  }
  if (a2 >> 30)
  {
    if (qword_1000DBA50 != -1) {
      dispatch_once(&qword_1000DBA50, &stru_1000CD318);
    }
    uint64_t v5 = (os_log_s *)(id)qword_1000DBA48;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v13 = 0LL;
      unsigned int v6 = sub_100053B4C(0);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
        uint64_t v7 = v6;
      }
      else {
        uint64_t v7 = v6 & 0xFFFFFFFE;
      }
      if ((_DWORD)v7)
      {
        v14[0] = 67109120;
        v14[1] = a2;
        unsigned int v8 = (const char *)_os_log_send_and_compose_impl( v7,  &v13,  0LL,  0LL,  &_mh_execute_header,  v5,  16LL,  "Failed to set comm page MultiUser Config: UID %u exceeds maximum allowable value",  v14);
        unsigned int v9 = (char *)v8;
        if (v8) {
          sub_100053B7C(v8);
        }
      }

      else
      {
        unsigned int v9 = 0LL;
      }

      free(v9);
    }

    return 0LL;
  }

  if (a3) {
    unsigned int v10 = 0x80000000;
  }
  else {
    unsigned int v10 = 0;
  }
  if (a4) {
    int v11 = 0x40000000;
  }
  else {
    int v11 = 0;
  }
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 16) + 16LL))(*(void *)(a1 + 16), v10 | v11 | a2);
}

void sub_100019D38(void *a1, char *newValue)
{
  if (a1) {
    objc_setProperty_nonatomic_copy(a1, newValue, newValue, 8LL);
  }
}

void sub_100019D4C(void *a1, char *newValue)
{
  if (a1) {
    objc_setProperty_nonatomic_copy(a1, newValue, newValue, 16LL);
  }
}

void sub_100019D90(id a1)
{
  os_log_t v1 = os_log_create(off_1000DAE70, "sideeffect");
  CFUUIDRef v2 = (void *)qword_1000DBA48;
  qword_1000DBA48 = (uint64_t)v1;
}

void sub_100019E04(id a1)
{
  os_log_t v1 = objc_alloc_init(&OBJC_CLASS___UMDProviderSideEffects);
  CFUUIDRef v2 = (void *)qword_1000DBA58;
  qword_1000DBA58 = (uint64_t)v1;
}

uint64_t sub_100019F7C(char *a1, ...)
{
  message[0] = 0LL;
  va_copy((va_list)&message[1], va);
  vasprintf(message, a1, va);
  if (!message[0]) {
    message[0] = a1;
  }
  reboot_np(3072, message[0]);
  uint64_t v2 = abort_with_reason(2LL, 6LL, message[0], 0LL);
  return sub_100019FD4(v2);
}

uint64_t sub_100019FD4(const char *a1, int a2)
{
  int v21 = a2;
  *(void *)unsigned int v22 = 0LL;
  unsigned int v3 = getmntinfo((statfs **)v22, 2);
  if (v3)
  {
    unsigned int v4 = v3;
    uint64_t v5 = (const char *)(*(void *)v22 + 2168LL * v3 - 2080);
    unsigned int v6 = v4 + 1;
    while ((int)--v6 >= 1)
    {
      uint64_t v7 = v5 - 2168;
      int v8 = strcmp(v5, a1);
      uint64_t v5 = v7;
      if (!v8)
      {
        uint64_t v9 = *((void *)v7 + 266);
        size_t v29 = 14LL;
        if (sysctlnametomib("vfs.generic.ctlbyfsid", &v30, &v29) != -1)
        {
          int v10 = v29;
          *(&v30 + v29) = 65538;
          int v23 = 0;
          __int128 v26 = 0u;
          __int128 v27 = 0u;
          uint64_t v28 = 0LL;
          *(_DWORD *)unsigned int v22 = 1;
          *(void *)&v22[4] = v9;
          uint64_t v24 = &v21;
          __int128 v25 = 4uLL;
          if ((sysctl(&v30, v10 + 1, 0LL, 0LL, v22, 0x50uLL) & 0x80000000) == 0) {
            return 0LL;
          }
        }

        int v17 = *__error();
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        uint64_t v13 = (os_log_s *)(id)qword_1000DBA98;
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_28;
        }
        *(void *)unsigned int v22 = 0LL;
        unsigned int v18 = sub_100053B4C(1);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v19 = v18;
        }
        else {
          uint64_t v19 = v18 & 0xFFFFFFFE;
        }
        if ((_DWORD)v19)
        {
          int v30 = 67109120;
          int v31 = v17;
          unsigned int v16 = (const char *)_os_log_send_and_compose_impl( v19,  v22,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "sysctl_fsid failed with error:%d",  &v30);
          goto LABEL_24;
        }

        goto LABEL_26;
      }
    }
  }

  int v12 = *__error();
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v13 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)unsigned int v22 = 0LL;
    unsigned int v14 = sub_100053B4C(1);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v15 = v14;
    }
    else {
      uint64_t v15 = v14 & 0xFFFFFFFE;
    }
    if ((_DWORD)v15)
    {
      int v30 = 67109120;
      int v31 = v12;
      unsigned int v16 = (const char *)_os_log_send_and_compose_impl( v15,  v22,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "getmntfsid failed with error:%d",  &v30);
LABEL_24:
      uint64_t v20 = (char *)v16;
      if (v16) {
        sub_100053B7C(v16);
      }
    }

    else
    {
LABEL_26:
      uint64_t v20 = 0LL;
    }

    free(v20);
  }

LABEL_28:
  return 0xFFFFFFFFLL;
}

            unsigned int v16 = 0LL;
            goto LABEL_29;
          }

          goto LABEL_30;
        }

        if (CFStringCompare(v8, a1, 0LL) == kCFCompareEqualTo) {
          return CFRetain(v5);
        }
LABEL_31:
        if (CFArrayGetCount((CFArrayRef)qword_1000DBCD8) <= ++v3) {
          return 0LL;
        }
      }

      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      int v10 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        int v17 = 0LL;
        int v11 = sub_100053B4C(1);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
          int v12 = v11;
        }
        else {
          int v12 = v11 & 0xFFFFFFFE;
        }
        if (!(_DWORD)v12) {
          goto LABEL_28;
        }
        LOWORD(v18[0]) = 0;
        uint64_t v13 = (const char *)_os_log_send_and_compose_impl( v12,  &v17,  0LL,  0LL,  &_mh_execute_header,  v10,  0LL,  "got NULL dictionary");
LABEL_26:
        unsigned int v16 = (char *)v13;
        if (v13) {
          sub_100053B7C(v13);
        }
LABEL_29:
        free(v16);
      }

        return;
      }

      if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        goto LABEL_28;
      }
      *(void *)int v23 = 0LL;
      int v17 = sub_100053B4C(0);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        unsigned int v18 = v17;
      }
      else {
        unsigned int v18 = v17 & 0xFFFFFFFE;
      }
      if (!(_DWORD)v18) {
        goto LABEL_26;
      }
      LOWORD(v22[0]) = 0;
      uint64_t v19 = "Failed to publish generation: Failed to set darwin notification state";
    }

    unsigned int v16 = (const char *)_os_log_send_and_compose_impl( v18,  v23,  0LL,  0LL,  &_mh_execute_header,  v12,  16LL,  v19,  v22,  2,  v22[0]);
LABEL_24:
    int v21 = (char *)v16;
    if (v16) {
      sub_100053B7C(v16);
    }
    goto LABEL_27;
  }

  return v7;
}

    int v12 = 0LL;
    if (v14) {
      goto LABEL_29;
    }
LABEL_30:
    unsigned int v14 = 0;
    uint64_t v13 = 10;
  }

uint64_t sub_10001A2A4(int a1)
{
  id v1 = sub_100054ED0(qword_1000DBA70, a1);
  return objc_claimAutoreleasedReturnValue(v1);
}

uint64_t sub_10001A2C8(void *a1)
{
  id v1 = sub_100054D5C(qword_1000DBA70, a1);
  return objc_claimAutoreleasedReturnValue(v1);
}

CFTypeRef sub_10001A2EC(const __CFString *a1)
{
  CFTypeRef result = (CFTypeRef)qword_1000DBCD8;
  if (qword_1000DBCD8)
  {
    if (CFArrayGetCount((CFArrayRef)qword_1000DBCD8) >= 1)
    {
      CFIndex v3 = 0LL;
      while (1)
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)qword_1000DBCD8, v3);
        if (!ValueAtIndex) {
          break;
        }
        uint64_t v5 = ValueAtIndex;
        CFTypeID v6 = CFGetTypeID(ValueAtIndex);
        if (v6 != CFDictionaryGetTypeID()) {
          break;
        }
        Value = (const __CFString *)CFDictionaryGetValue(v5, kUMUserSessionVolumeUUIDKey);
        if (!Value || (int v8 = Value, v9 = CFGetTypeID(Value), v9 != CFStringGetTypeID()))
        {
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          int v10 = (os_log_s *)(id)qword_1000DBA98;
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v17 = 0LL;
            unsigned int v14 = sub_100053B4C(1);
            if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v15 = v14;
            }
            else {
              uint64_t v15 = v14 & 0xFFFFFFFE;
            }
            if ((_DWORD)v15)
            {
              v18[0] = 67109120;
              v18[1] = v3;
              uint64_t v13 = (const char *)_os_log_send_and_compose_impl( v15,  &v17,  0LL,  0LL,  &_mh_execute_header,  v10,  0LL,  "Found problem with conversion at index:%d",  v18);
              goto LABEL_26;
            }

LABEL_30:
      goto LABEL_31;
    }

    return 0LL;
  }

  return result;
}

    unsigned int v14 = 0LL;
LABEL_31:
    free(v14);
LABEL_32:

    return 0LL;
  }

  if (([(id)qword_1000DBA68 mountVolumeWithSession:a1 mountPath:@"/private/var/mobile" error:&v17 forPersona:0] & 1) == 0)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    int v8 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_32;
    }
    unsigned int v16 = 0LL;
    uint64_t v12 = sub_100053B4C(1);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v13 = v12;
    }
    else {
      uint64_t v13 = v12 & 0xFFFFFFFE;
    }
    if ((_DWORD)v13)
    {
      v18[0] = 67109120;
      v18[1] = v17;
      unsigned int v11 = (const char *)_os_log_send_and_compose_impl( v13,  &v16,  0LL,  0LL,  &_mh_execute_header,  v8,  0LL,  "FAIL TO MOUNT DEFAULT SESSION with ERROR: %d",  v18);
LABEL_28:
      unsigned int v14 = (char *)v11;
      if (v11) {
        sub_100053B7C(v11);
      }
      goto LABEL_31;
    }

    goto LABEL_30;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  CFIndex v3 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v16 = 0LL;
    unsigned int v4 = sub_100053B4C(1);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = v4 & 0xFFFFFFFE;
    }
    if ((_DWORD)v5)
    {
      LOWORD(v18[0]) = 0;
      CFTypeID v6 = (const char *)_os_log_send_and_compose_impl( v5,  &v16,  0LL,  0LL,  &_mh_execute_header,  v3,  0LL,  "MOUNTED DEFAULT SESSION, ensure tmpdir exists...",  v18,  2);
      uint64_t v7 = (char *)v6;
      if (v6) {
        sub_100053B7C(v6);
      }
    }

    else
    {
      uint64_t v7 = 0LL;
    }

    free(v7);
  }

  sub_10001C6DC((uint64_t)"/private/var/mobile", a2, a2);
  return 1LL;
}

    int v8 = 0LL;
LABEL_31:
    free(v8);
LABEL_32:
    uint64_t v17 = 0LL;
    goto LABEL_36;
  }

  int v10 = SyncBagForUser;
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  unsigned int v4 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v19[0] = 0LL;
    unsigned int v11 = sub_100053B4C(1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v12 = v11;
    }
    else {
      uint64_t v12 = v11 & 0xFFFFFFFE;
    }
    if ((_DWORD)v12)
    {
      LODWORD(v20) = 67109376;
      HIDWORD(v20) = a2;
      int v21 = 1024;
      unsigned int v22 = v10;
      uint64_t v13 = (const char *)_os_log_send_and_compose_impl( v12,  v19,  0LL,  0LL,  &_mh_execute_header,  v4,  0LL,  "failed to retrieve SyncBag content from keybag for uid %d: with error: 0x%x",  &v20,  14);
      unsigned int v14 = (char *)v13;
      if (v13) {
        sub_100053B7C(v13);
      }
    }

    else
    {
      unsigned int v14 = 0LL;
    }

    free(v14);
  }

  uint64_t v17 = 0xFFFFFFFFLL;
LABEL_36:

  return v17;
}

        sub_100053B7C((const char *)v14);
        goto LABEL_32;
      }

    unsigned int v16 = 0LL;
LABEL_31:
    free(v16);
LABEL_32:

    uint64_t v17 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  22LL,  0LL));
    unsigned int v18 = *(void *)(*(void *)(a1 + 48) + 8LL);
    uint64_t v19 = *(void **)(v18 + 40);
    *(void *)(v18 + 40) = v17;
    goto LABEL_80;
  }

  if (!*(void *)(a1 + 40))
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    int v8 = (os_log_s *)(id)qword_1000DBB90;
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_32;
    }
    int v52 = 0LL;
    uint64_t v13 = sub_100053B4C(1);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
      unsigned int v14 = v13;
    }
    else {
      unsigned int v14 = v13 & 0xFFFFFFFE;
    }
    if ((_DWORD)v14)
    {
      uint64_t v15 = *(_DWORD *)(a1 + 88);
      uint64_t v53 = 67109120;
      uint64_t v54 = v15;
      uint64_t v12 = (const char *)_os_log_send_and_compose_impl( v14,  &v52,  0LL,  0LL,  &_mh_execute_header,  v8,  2LL,  "replacePersonaVoucher with no Account ID from pid:%d",  &v53);
LABEL_28:
      unsigned int v16 = (char *)v12;
      if (v12) {
        sub_100053B7C(v12);
      }
      goto LABEL_31;
    }

    goto LABEL_30;
  }

  *(_DWORD *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = [v2 machPort];
  if (qword_1000DBB98 != -1) {
    dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
  }
  CFIndex v3 = (os_log_s *)(id)qword_1000DBB90;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    int v52 = 0LL;
    LODWORD(v4) = sub_100053B4C(1);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG)) {
      unsigned int v4 = v4;
    }
    else {
      unsigned int v4 = v4 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      uint64_t v5 = *(void **)(a1 + 32);
      CFTypeID v6 = v3;
      uint64_t v53 = 67109120;
      uint64_t v54 = [v5 machPort];
      uint64_t v7 = (char *)_os_log_send_and_compose_impl( v4,  &v52,  0LL,  0LL,  &_mh_execute_header,  v6,  2LL,  "have SourcePort:%d",  &v53);

      if (v7) {
        sub_100053B7C(v7);
      }
    }

    else
    {
      uint64_t v7 = 0LL;
    }

    free(v7);
  }

  uint64_t v20 = sub_100046664(0xFFFFFFFFLL, 0xFFFFFFFFLL, *(unsigned int *)(a1 + 92));
  uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(v20);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = sub_10004A4EC( *(void **)(a1 + 40),  *(unsigned int *)(a1 + 88),  (uint64_t)[*(id *)(a1 + 32) machPort],  v19,  *(void *)(*(void *)(a1 + 72) + 8) + 24);
  int v21 = mach_port_deallocate(mach_task_self_, (mach_port_name_t)[*(id *)(a1 + 32) machPort]);
  if (v21)
  {
    unsigned int v22 = v21;
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    int v23 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      int v52 = 0LL;
      uint64_t v24 = sub_100053B4C(1);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
        __int128 v25 = v24;
      }
      else {
        __int128 v25 = v24 & 0xFFFFFFFE;
      }
      if ((_DWORD)v25)
      {
        uint64_t v53 = 67109120;
        uint64_t v54 = v22;
        __int128 v26 = (const char *)_os_log_send_and_compose_impl( v25,  &v52,  0LL,  0LL,  &_mh_execute_header,  v23,  0LL,  "mach_port_deallocate failed with error:%d",  &v53);
        __int128 v27 = (char *)v26;
        if (v26) {
          sub_100053B7C(v26);
        }
      }

      else
      {
        __int128 v27 = 0LL;
      }

      free(v27);
    }
  }

  if (*(_DWORD *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL))
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v28 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
    {
      int v52 = 0LL;
      size_t v29 = sub_100053B4C(1);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG)) {
        int v30 = v29;
      }
      else {
        int v30 = v29 & 0xFFFFFFFE;
      }
      if ((_DWORD)v30)
      {
        int v31 = *(_DWORD *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL);
        uint64_t v53 = 67109120;
        uint64_t v54 = v31;
        uint64_t v32 = (const char *)_os_log_send_and_compose_impl( v30,  &v52,  0LL,  0LL,  &_mh_execute_header,  v28,  2LL,  "setupVoucherwithPersonaID failed with %d",  &v53);
        uint64_t v33 = (char *)v32;
        if (v32) {
          sub_100053B7C(v32);
        }
      }

      else
      {
        uint64_t v33 = 0LL;
      }

      free(v33);
    }

    uint64_t v44 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  *(int *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL),  0LL));
    uint64_t v45 = *(void *)(*(void *)(a1 + 48) + 8LL);
    uint64_t v40 = *(os_log_s **)(v45 + 40);
    *(void *)(v45 + 40) = v44;
    goto LABEL_79;
  }

  if (!*(_DWORD *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL))
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v40 = (os_log_s *)(id)qword_1000DBB90;
    if (!os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_79;
    }
    int v52 = 0LL;
    uint64_t v41 = sub_100053B4C(1);
    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v42 = v41;
    }
    else {
      uint64_t v42 = v41 & 0xFFFFFFFE;
    }
    if ((_DWORD)v42)
    {
      LOWORD(v53) = 0;
      uint64_t v43 = (const char *)_os_log_send_and_compose_impl( v42,  &v52,  0LL,  0LL,  &_mh_execute_header,  v40,  0LL,  "no replacement voucher port received from kernel",  &v53,  2);
      goto LABEL_92;
    }

  if (v33) {
    Util_SafeDeallocParameters(v33, v32);
  }
  return v12;
}

uint64_t sub_10001A594()
{
  if (!qword_1000DBCD8) {
    return 0LL;
  }
  int v0 = sub_100055178(qword_1000DBA70);
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v1 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = 0LL;
    unsigned int v2 = sub_100053B4C(1);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v3 = v2;
    }
    else {
      uint64_t v3 = v2 & 0xFFFFFFFE;
    }
    if ((_DWORD)v3)
    {
      v9[0] = 67109120;
      v9[1] = v0;
      unsigned int v4 = (const char *)_os_log_send_and_compose_impl( v3,  &v8,  0LL,  0LL,  &_mh_execute_header,  v1,  0LL,  "Finding ForeGround session :%d",  v9);
      uint64_t v5 = (char *)v4;
      if (v4) {
        sub_100053B7C(v4);
      }
    }

    else
    {
      uint64_t v5 = 0LL;
    }

    free(v5);
  }

  id v7 = sub_100054ED0(qword_1000DBA70, v0);
  return objc_claimAutoreleasedReturnValue(v7);
}

CFTypeRef sub_10001A6F8()
{
  if (!qword_1000DBCD8) {
    return 0LL;
  }
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  int v0 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v22 = 0LL;
    unsigned int v1 = sub_100053B4C(1);
    if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v2 = v1;
    }
    else {
      uint64_t v2 = v1 & 0xFFFFFFFE;
    }
    if ((_DWORD)v2)
    {
      LOWORD(v23[0]) = 0;
      uint64_t v3 = (const char *)_os_log_send_and_compose_impl( v2,  &v22,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "Finding Primary session",  v23,  2);
      unsigned int v4 = (char *)v3;
      if (v3) {
        sub_100053B7C(v3);
      }
    }

    else
    {
      unsigned int v4 = 0LL;
    }

    free(v4);
  }

  if (CFArrayGetCount((CFArrayRef)qword_1000DBCD8) < 1) {
    return 0LL;
  }
  CFIndex v5 = 0LL;
  while (1)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)qword_1000DBCD8, v5);
    if (!ValueAtIndex || (id v7 = ValueAtIndex, v8 = CFGetTypeID(ValueAtIndex), v8 != CFDictionaryGetTypeID()))
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      CFTypeID v9 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v22 = 0LL;
        unsigned int v10 = sub_100053B4C(1);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v11 = v10;
        }
        else {
          uint64_t v11 = v10 & 0xFFFFFFFE;
        }
        if ((_DWORD)v11)
        {
          v23[0] = 67109120;
          v23[1] = v5;
          uint64_t v12 = (const char *)_os_log_send_and_compose_impl( v11,  &v22,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "Found problem with conversion with index %d",  v23);
          uint64_t v13 = (char *)v12;
          if (v12) {
            sub_100053B7C(v12);
          }
        }

        else
        {
          uint64_t v13 = 0LL;
        }

        free(v13);
      }

      goto LABEL_31;
    }

CFTypeRef sub_10001AA74(const __CFString *a1)
{
  if (!qword_1000DBCD8 || CFArrayGetCount((CFArrayRef)qword_1000DBCD8) < 1) {
    return 0LL;
  }
  CFIndex v2 = 0LL;
  while (1)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)qword_1000DBCD8, v2);
    if (ValueAtIndex)
    {
      unsigned int v4 = ValueAtIndex;
      CFTypeID v5 = CFGetTypeID(ValueAtIndex);
      if (v5 == CFDictionaryGetTypeID())
      {
        Value = (const __CFString *)CFDictionaryGetValue(v4, kUMUserSessionNameKey);
        if (Value)
        {
          id v7 = Value;
          CFTypeID v8 = CFGetTypeID(Value);
          if (v8 == CFStringGetTypeID() && CFStringCompare(v7, a1, 0LL) == kCFCompareEqualTo) {
            break;
          }
        }
      }
    }

    if (CFArrayGetCount((CFArrayRef)qword_1000DBCD8) <= ++v2) {
      return 0LL;
    }
  }

  return CFRetain(v4);
}

uint64_t sub_10001AB64()
{
  uint64_t v4 = 0LL;
  CFTypeID v5 = &v4;
  uint64_t v6 = 0x2020000000LL;
  uint64_t v7 = 0LL;
  v3[0] = 0LL;
  v3[1] = v3;
  v3[2] = 0x2020000000LL;
  v3[3] = 0LL;
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472LL;
  v2[2] = sub_10001AC14;
  v2[3] = &unk_1000CD360;
  v2[4] = v3;
  v2[5] = &v4;
  dispatch_sync((dispatch_queue_t)qword_1000DBD48, v2);
  uint64_t v0 = v5[3];
  _Block_object_dispose(v3, 8);
  _Block_object_dispose(&v4, 8);
  return v0;
}

void sub_10001AC14(uint64_t a1)
{
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  CFIndex v2 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t valuePtr = 0LL;
    unsigned int v3 = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      __int16 v20 = 0;
      CFTypeID v5 = (const char *)_os_log_send_and_compose_impl( v4,  &valuePtr,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "In findAllUserSessionIDs",  &v20,  2);
      uint64_t v6 = (char *)v5;
      if (v5) {
        sub_100053B7C(v5);
      }
    }

    else
    {
      uint64_t v6 = 0LL;
    }

    free(v6);
  }

  if (qword_1000DBCD8 && (int Count = CFArrayGetCount((CFArrayRef)qword_1000DBCD8), Count >= 1))
  {
    CFTypeID v8 = sub_100084320();
    CFIndex v9 = 0LL;
    uint64_t v10 = Count;
    do
    {
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = CFArrayGetValueAtIndex( (CFArrayRef)qword_1000DBCD8,  v9);
      LODWORD(valuePtr) = -1;
      uint64_t v11 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
      if (v11)
      {
        CFTypeID v12 = CFGetTypeID(v11);
        if (v12 == CFDictionaryGetTypeID()) {
          LODWORD(valuePtr) = sub_100083C6C( *(const __CFDictionary **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL),  kUMUserSessionIDKey);
        }
      }

      CFNumberRef v13 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
      CFArrayAppendValue(v8, v13);
      if (v13) {
        CFRelease(v13);
      }
      ++v9;
    }

    while (v10 != v9);
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = v8;
  }

  else
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    CFTypeRef v14 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t valuePtr = 0LL;
      unsigned int v15 = sub_100053B4C(1);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v16 = v15;
      }
      else {
        uint64_t v16 = v15 & 0xFFFFFFFE;
      }
      if ((_DWORD)v16)
      {
        __int16 v20 = 0;
        LODWORD(v19) = 2;
        unsigned int v17 = (const char *)_os_log_send_and_compose_impl( v16,  &valuePtr,  0LL,  0LL,  &_mh_execute_header,  v14,  0LL,  "Did not find any session in handle_UserSessionListIDs",  &v20,  v19);
        uint64_t v18 = (char *)v17;
        if (v17) {
          sub_100053B7C(v17);
        }
      }

      else
      {
        uint64_t v18 = 0LL;
      }

      free(v18);
    }
  }

uint64_t sub_10001AED4()
{
  uint64_t result = qword_1000DBCD8;
  if (qword_1000DBCD8)
  {
    int Count = 0;
    uint64_t valuePtr = CFArrayGetCount((CFArrayRef)qword_1000DBCD8);
    if ((_DWORD)valuePtr)
    {
      unsigned int v1 = sub_10008428C();
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      CFIndex v2 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v84 = 0LL;
        unsigned int v3 = sub_100053B4C(1);
        if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v4 = v3;
        }
        else {
          uint64_t v4 = v3 & 0xFFFFFFFE;
        }
        if ((_DWORD)v4)
        {
          LOWORD(v87) = 0;
          CFTypeID v5 = (const char *)_os_log_send_and_compose_impl( v4,  &v84,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "SAVING SESSION TODISK",  &v87,  2);
          uint64_t v6 = (char *)v5;
          if (v5) {
            sub_100053B7C(v5);
          }
        }

        else
        {
          uint64_t v6 = 0LL;
        }

        free(v6);
      }

      CFNumberRef v12 = CFNumberCreate(0LL, kCFNumberIntType, &valuePtr);
      CFDictionaryAddValue(v1, @"NUMENT", v12);
      CFRelease(v12);
      CFTypeRef v13 = sub_100083ECC((const void *)qword_1000DBCD8);
      if (v13)
      {
        CFTypeRef v14 = v13;
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        unsigned int v15 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v84 = 0LL;
          unsigned int v16 = sub_100053B4C(1);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v17 = v16;
          }
          else {
            uint64_t v17 = v16 & 0xFFFFFFFE;
          }
          if ((_DWORD)v17)
          {
            LOWORD(v87) = 0;
            LODWORD(v83) = 2;
            uint64_t v18 = (const char *)_os_log_send_and_compose_impl( v17,  &v84,  0LL,  0LL,  &_mh_execute_header,  v15,  0LL,  "SESSION TABLE TO BLOB",  &v87,  v83);
            uint64_t v19 = (char *)v18;
            if (v18) {
              sub_100053B7C(v18);
            }
          }

          else
          {
            uint64_t v19 = 0LL;
          }

          free(v19);
        }

        CFDictionaryAddValue(v1, @"BLOB", v14);
        CFRelease(v14);
      }

      else
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        __int16 v20 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v84 = 0LL;
          unsigned int v21 = sub_100053B4C(1);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v22 = v21;
          }
          else {
            uint64_t v22 = v21 & 0xFFFFFFFE;
          }
          if ((_DWORD)v22)
          {
            LOWORD(v87) = 0;
            LODWORD(v83) = 2;
            int v23 = (const char *)_os_log_send_and_compose_impl( v22,  &v84,  0LL,  0LL,  &_mh_execute_header,  v20,  0LL,  "SESSION TABLE TO BLOB FAILED",  &v87,  v83);
            uint64_t v24 = (char *)v23;
            if (v23) {
              sub_100053B7C(v23);
            }
          }

          else
          {
            uint64_t v24 = 0LL;
          }

          free(v24);
        }

        CFDictionaryAddValue(v1, @"BLOB", 0LL);
      }

      CFNumberRef v30 = CFNumberCreate(0LL, kCFNumberIntType, &dword_1000DBCE8);
      CFDictionaryAddValue(v1, @"DEVICECONFIG", v30);
      CFRelease(v30);
      CFNumberRef v31 = CFNumberCreate(0LL, kCFNumberIntType, &dword_1000DACB0);
      CFDictionaryAddValue(v1, @"BOOTEDUSER", v31);
      CFRelease(v31);
      if (dword_1000DACB4 != -1 || qword_1000DBD10)
      {
        CFNumberRef v32 = CFNumberCreate(0LL, kCFNumberLongLongType, &qword_1000DACC0);
        CFDictionaryAddValue(v1, @"APNSID", v32);
        CFRelease(v32);
        if (qword_1000DBA88)
        {
          CFDictionaryAddValue(v1, @"VOLUMETYPE", (const void *)qword_1000DBA88);
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          uint64_t v33 = (os_log_s *)(id)qword_1000DBA98;
          if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v84 = 0LL;
            unsigned int v34 = sub_100053B4C(1);
            if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v35 = v34;
            }
            else {
              uint64_t v35 = v34 & 0xFFFFFFFE;
            }
            if ((_DWORD)v35)
            {
              LOWORD(v87) = 0;
              LODWORD(v83) = 2;
              uint64_t v36 = (const char *)_os_log_send_and_compose_impl( v35,  &v84,  0LL,  0LL,  &_mh_execute_header,  v33,  0LL,  "SAVED VOLTYPE to DISk",  &v87,  v83);
              uint64_t v37 = (char *)v36;
              if (v36) {
                sub_100053B7C(v36);
              }
            }

            else
            {
              uint64_t v37 = 0LL;
            }

            free(v37);
          }
        }

        CFNumberRef v38 = CFNumberCreate(0LL, kCFNumberIntType, &dword_1000DACB4);
        CFDictionaryAddValue(v1, @"MAXUSER", v38);
        CFRelease(v38);
        CFNumberRef v39 = CFNumberCreate(0LL, kCFNumberLongLongType, &qword_1000DBD10);
        CFDictionaryAddValue(v1, @"MAXUSERSIZE", v39);
        CFRelease(v39);
      }

      if (dword_1000DBCE8 != 1)
      {
LABEL_104:
        if (qword_1000DBD00
          && (HIDWORD(valuePtr) = CFArrayGetCount((CFArrayRef)qword_1000DBD00), SHIDWORD(valuePtr) >= 1))
        {
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          int v52 = (os_log_s *)(id)qword_1000DBA98;
          if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v84 = 0LL;
            unsigned int v53 = sub_100053B4C(1);
            if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v54 = v53;
            }
            else {
              uint64_t v54 = v53 & 0xFFFFFFFE;
            }
            if ((_DWORD)v54)
            {
              int v87 = 67109120;
              int v88 = HIDWORD(valuePtr);
              uint64_t v55 = (const char *)_os_log_send_and_compose_impl( v54,  &v84,  0LL,  0LL,  &_mh_execute_header,  v52,  0LL,  "Setting LRU list array length:%d",  &v87);
              int v56 = (char *)v55;
              if (v55) {
                sub_100053B7C(v55);
              }
            }

            else
            {
              int v56 = 0LL;
            }

            free(v56);
          }

          CFNumberRef v61 = CFNumberCreate(0LL, kCFNumberIntType, (char *)&valuePtr + 4);
          CFDictionaryAddValue(v1, @"LRUENT", v61);
          CFRelease(v61);
          CFTypeRef v62 = sub_100083ECC((const void *)qword_1000DBD00);
          CFDictionaryAddValue(v1, @"LRUBLOB", v62);
          CFRelease(v62);
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          uint64_t v57 = (os_log_s *)(id)qword_1000DBA98;
          if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v84 = 0LL;
            unsigned int v63 = sub_100053B4C(1);
            if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v64 = v63;
            }
            else {
              uint64_t v64 = v63 & 0xFFFFFFFE;
            }
            if ((_DWORD)v64)
            {
              int v87 = 67109120;
              int v88 = HIDWORD(valuePtr);
              uint64_t v60 = (const char *)_os_log_send_and_compose_impl( v64,  &v84,  0LL,  0LL,  &_mh_execute_header,  v57,  0LL,  "SAVED LRU entries %d",  &v87);
LABEL_133:
              uint64_t v65 = (char *)v60;
              if (v60) {
                sub_100053B7C(v60);
              }
              goto LABEL_136;
            }

            goto LABEL_135;
          }
        }

        else
        {
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          uint64_t v57 = (os_log_s *)(id)qword_1000DBA98;
          if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v84 = 0LL;
            unsigned int v58 = sub_100053B4C(1);
            if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v59 = v58;
            }
            else {
              uint64_t v59 = v58 & 0xFFFFFFFE;
            }
            if ((_DWORD)v59)
            {
              LOWORD(v87) = 0;
              uint64_t v60 = (const char *)_os_log_send_and_compose_impl( v59,  &v84,  0LL,  0LL,  &_mh_execute_header,  v57,  0LL,  "NOTHING TO SAVE IN LRU UID LIST");
              goto LABEL_133;
            }

LABEL_135:
            uint64_t v65 = 0LL;
LABEL_136:
            free(v65);
          }
        }

        CFTypeRef v66 = sub_100083ECC(v1);
        if (!v66)
        {
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          uint64_t v75 = (os_log_s *)(id)qword_1000DBA98;
          if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v84 = 0LL;
            unsigned int v76 = sub_100053B4C(1);
            if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v77 = v76;
            }
            else {
              uint64_t v77 = v76 & 0xFFFFFFFE;
            }
            if ((_DWORD)v77)
            {
              LOWORD(v87) = 0;
              LODWORD(v83) = 2;
              uint64_t v78 = (const char *)_os_log_send_and_compose_impl( v77,  &v84,  0LL,  0LL,  &_mh_execute_header,  v75,  0LL,  "Can't serialize dictionary",  &v87,  v83);
              unsigned int v79 = (char *)v78;
              if (v78) {
                sub_100053B7C(v78);
              }
            }

            else
            {
              unsigned int v79 = 0LL;
            }

            free(v79);
          }

          goto LABEL_172;
        }

        uint64_t v67 = v66;
        uint64_t v68 = sub_100019434(qword_1000DBD40);
        unsigned int v69 = (void *)objc_claimAutoreleasedReturnValue(v68);
        unsigned int v70 = [v69 atomicallyWriteData:v67 toPath:@"/private/var//keybags/usersession.kb" error:0];

        if (v70)
        {
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          v71 = (os_log_s *)(id)qword_1000DBA98;
          if (!os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_168;
          }
          uint64_t v84 = 0LL;
          unsigned int v72 = sub_100053B4C(1);
          if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v73 = v72;
          }
          else {
            uint64_t v73 = v72 & 0xFFFFFFFE;
          }
          if ((_DWORD)v73)
          {
            LOWORD(v87) = 0;
            LODWORD(v83) = 2;
            v74 = (const char *)_os_log_send_and_compose_impl( v73,  &v84,  0LL,  0LL,  &_mh_execute_header,  v71,  0LL,  "diskSaveUserSessions Success",  &v87,  v83);
            goto LABEL_164;
          }
        }

        else
        {
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          v71 = (os_log_s *)(id)qword_1000DBA98;
          if (!os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_168;
          }
          uint64_t v84 = 0LL;
          unsigned int v80 = sub_100053B4C(1);
          if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v81 = v80;
          }
          else {
            uint64_t v81 = v80 & 0xFFFFFFFE;
          }
          if ((_DWORD)v81)
          {
            LOWORD(v87) = 0;
            LODWORD(v83) = 2;
            v74 = (const char *)_os_log_send_and_compose_impl( v81,  &v84,  0LL,  0LL,  &_mh_execute_header,  v71,  0LL,  "failed to write diskSaveUserSessions dict",  &v87,  v83);
LABEL_164:
            v82 = (char *)v74;
            if (v74) {
              sub_100053B7C(v74);
            }
            goto LABEL_167;
          }
        }

        v82 = 0LL;
LABEL_167:
        free(v82);
LABEL_168:

        CFRelease(v67);
LABEL_172:
        CFRelease(v1);
        return 1LL;
      }

      CFNumberRef v40 = CFNumberCreate(0LL, kCFNumberIntType, &dword_1000DBCF0);
      CFDictionaryAddValue(v1, @"USESSTYPE", v40);
      CFRelease(v40);
      CFNumberRef v41 = CFNumberCreate(0LL, kCFNumberIntType, &dword_1000DBCF4);
      CFDictionaryAddValue(v1, @"LOGINCHECKIN", v41);
      CFRelease(v41);
      if (dword_1000DBD18 >= 1)
      {
        CFNumberRef v42 = CFNumberCreate(0LL, kCFNumberIntType, &dword_1000DBD18);
        CFDictionaryAddValue(v1, @"DEVICENETWORKBG", v42);
        CFRelease(v42);
      }

      if (qword_1000DBCF8 && (int Count = CFArrayGetCount((CFArrayRef)qword_1000DBCF8), Count >= 1))
      {
        CFNumberRef v43 = CFNumberCreate(0LL, kCFNumberIntType, &Count);
        CFDictionaryAddValue(v1, @"SYNCENT", v43);
        CFRelease(v43);
        CFTypeRef v44 = sub_100083ECC((const void *)qword_1000DBCF8);
        CFDictionaryAddValue(v1, @"SYNCBLOB", v44);
        CFRelease(v44);
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        uint64_t v45 = (os_log_s *)(id)qword_1000DBA98;
        if (!os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_103;
        }
        uint64_t v84 = 0LL;
        unsigned int v46 = sub_100053B4C(1);
        if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v47 = v46;
        }
        else {
          uint64_t v47 = v46 & 0xFFFFFFFE;
        }
        if ((_DWORD)v47)
        {
          int v87 = 67109120;
          int v88 = Count;
          uint64_t v48 = (const char *)_os_log_send_and_compose_impl( v47,  &v84,  0LL,  0LL,  &_mh_execute_header,  v45,  0LL,  "SAVED bubble UID with entries %d",  &v87);
          goto LABEL_99;
        }
      }

      else
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        uint64_t v45 = (os_log_s *)(id)qword_1000DBA98;
        if (!os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_103;
        }
        uint64_t v84 = 0LL;
        unsigned int v49 = sub_100053B4C(1);
        if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v50 = v49;
        }
        else {
          uint64_t v50 = v49 & 0xFFFFFFFE;
        }
        if ((_DWORD)v50)
        {
          LOWORD(v87) = 0;
          uint64_t v48 = (const char *)_os_log_send_and_compose_impl( v50,  &v84,  0LL,  0LL,  &_mh_execute_header,  v45,  0LL,  "NOTHING TO SAVE FOR SYNC BUBBLE UID LIST");
LABEL_99:
          __int16 v51 = (char *)v48;
          if (v48) {
            sub_100053B7C(v48);
          }
          goto LABEL_102;
        }
      }

      __int16 v51 = 0LL;
LABEL_102:
      free(v51);
LABEL_103:

      goto LABEL_104;
    }

    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v7 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v84 = 0LL;
      unsigned int v8 = sub_100053B4C(1);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v9 = v8;
      }
      else {
        uint64_t v9 = v8 & 0xFFFFFFFE;
      }
      if ((_DWORD)v9)
      {
        LOWORD(v87) = 0;
        uint64_t v10 = (const char *)_os_log_send_and_compose_impl( v9,  &v84,  0LL,  0LL,  &_mh_execute_header,  v7,  0LL,  "No UserSessions",  &v87,  2);
        uint64_t v11 = (char *)v10;
        if (v10) {
          sub_100053B7C(v10);
        }
      }

      else
      {
        uint64_t v11 = 0LL;
      }

      free(v11);
    }

    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    __int128 v25 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v84 = 0LL;
      unsigned int v26 = sub_100053B4C(1);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v27 = v26;
      }
      else {
        uint64_t v27 = v26 & 0xFFFFFFFE;
      }
      if ((_DWORD)v27)
      {
        LOWORD(v87) = 0;
        LODWORD(v83) = 2;
        uint64_t v28 = (const char *)_os_log_send_and_compose_impl( v27,  &v84,  0LL,  0LL,  &_mh_execute_header,  v25,  0LL,  "SaveAllUserSessions failed",  &v87,  v83);
        size_t v29 = (char *)v28;
        if (v28) {
          sub_100053B7C(v28);
        }
      }

      else
      {
        size_t v29 = 0LL;
      }

      free(v29);
    }

    return 0LL;
  }

  return result;
}
    }

    CFNumberRef v43 = [&off_1000D10F0 countByEnumeratingWithState:v231 objects:in count:16];
  }

  while (v43);
LABEL_137:
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  CFTypeRef v13 = v206;
  LODWORD(v11) = v205;
  v74 = (id)qword_1000DBA98;
  a1 = v208;
  LODWORD(v12) = v207;
  if (os_log_type_enabled((os_log_t)v74, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)in = 0LL;
    uint64_t v75 = sub_100053B4C(1);
    unsigned int v76 = (os_log_s *)v74;
    if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v77 = v75;
    }
    else {
      uint64_t v77 = v75 & 0xFFFFFFFE;
    }
    if ((_DWORD)v77)
    {
      LOWORD(v231[0]) = 0;
      LODWORD(v204) = 2;
      uint64_t v78 = (char *)_os_log_send_and_compose_impl( v77,  in,  0LL,  0LL,  &_mh_execute_header,  v76,  0LL,  "Terminated Preset Daemons",  v231,  v204);

      if (v78) {
        sub_100053B7C(v78);
      }
    }

    else
    {

      uint64_t v78 = 0LL;
    }

    free(v78);
  }

LABEL_149:
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  unsigned int v79 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v79, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)in = 0LL;
    unsigned int v80 = sub_100053B4C(1);
    uint64_t v81 = (os_log_s *)v79;
    if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT)) {
      v82 = v80;
    }
    else {
      v82 = v80 & 0xFFFFFFFE;
    }
    if ((_DWORD)v82)
    {
      LOWORD(v231[0]) = 0;
      LODWORD(v204) = 2;
      uint64_t v83 = (char *)_os_log_send_and_compose_impl( v82,  in,  0LL,  0LL,  &_mh_execute_header,  v81,  0LL,  "Checking if the volume mounted...",  v231,  v204);

      if (v83) {
        sub_100053B7C(v83);
      }
    }

    else
    {

      uint64_t v83 = 0LL;
    }

    free(v83);
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v84 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v84, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)in = 0LL;
    v85 = sub_100053B4C(1);
    v86 = (os_log_s *)v84;
    if (os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT)) {
      int v87 = v85;
    }
    else {
      int v87 = v85 & 0xFFFFFFFE;
    }
    if ((_DWORD)v87)
    {
      LOWORD(v231[0]) = 0;
      LODWORD(v204) = 2;
      int v88 = (char *)_os_log_send_and_compose_impl( v87,  in,  0LL,  0LL,  &_mh_execute_header,  v86,  0LL,  "Persona volume mounted",  v231,  v204);

      if (v88) {
        sub_100053B7C(v88);
      }
    }

    else
    {

      int v88 = 0LL;
    }

    free(v88);
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  v89 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v89, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)in = 0LL;
    v90 = sub_100053B4C(1);
    v91 = (os_log_s *)v89;
    if (os_log_type_enabled(v91, OS_LOG_TYPE_DEFAULT)) {
      v92 = v90;
    }
    else {
      v92 = v90 & 0xFFFFFFFE;
    }
    if ((_DWORD)v92)
    {
      LOWORD(v231[0]) = 0;
      LODWORD(v204) = 2;
      v93 = (char *)_os_log_send_and_compose_impl( v92,  in,  0LL,  0LL,  &_mh_execute_header,  v91,  0LL,  "Terminating all processes with files open on persona volume...",  v231,  v204);

      if (v93) {
        sub_100053B7C(v93);
      }
    }

    else
    {

      v93 = 0LL;
    }

    free(v93);
  }

  sub_100063758(qword_1000DBA78, theDict);
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  v94 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v94, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)in = 0LL;
    v95 = sub_100053B4C(1);
    v96 = (os_log_s *)v94;
    if (os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT)) {
      v97 = v95;
    }
    else {
      v97 = v95 & 0xFFFFFFFE;
    }
    if ((_DWORD)v97)
    {
      LOWORD(v231[0]) = 0;
      LODWORD(v204) = 2;
      v98 = (char *)_os_log_send_and_compose_impl( v97,  in,  0LL,  0LL,  &_mh_execute_header,  v96,  0LL,  "Unmounting persona volume...",  v231,  v204);

      if (v98) {
        sub_100053B7C(v98);
      }
    }

    else
    {

      v98 = 0LL;
    }

    free(v98);
  }

  if (![(id)qword_1000DBA68 unmountVolumeWithSession:theDict mountPath:0 error:0])
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    v99 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v99, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_216;
    }
    *(void *)in = 0LL;
    v103 = sub_100053B4C(1);
    v99 = v99;
    if (os_log_type_enabled(v99, OS_LOG_TYPE_DEFAULT)) {
      v104 = v103;
    }
    else {
      v104 = v103 & 0xFFFFFFFE;
    }
    if ((_DWORD)v104)
    {
      LOWORD(v231[0]) = 0;
      LODWORD(v204) = 2;
      v102 = _os_log_send_and_compose_impl( v104,  in,  0LL,  0LL,  &_mh_execute_header,  v99,  0LL,  "Persona Volume failed to unmount",  v231,  v204);
      goto LABEL_212;
    }

void sub_10001BD84()
{
  uint64_t v0 = sub_100057614((uint64_t)&OBJC_CLASS___UMDAPFSSupportVolumeHelper, (void *)qword_1000DBD40, byte_1000DBD3A);
  uint64_t v1 = objc_claimAutoreleasedReturnValue(v0);
  CFIndex v2 = (void *)qword_1000DBA68;
  qword_1000DBA68 = v1;

  unsigned int v3 = sub_100054B0C((uint64_t)&OBJC_CLASS___UMDUserManager, (void *)qword_1000DBA68);
  uint64_t v4 = objc_claimAutoreleasedReturnValue(v3);
  CFTypeID v5 = (void *)qword_1000DBA70;
  qword_1000DBA70 = v4;

  if (MGGetBoolAnswer(@"InternalBuild"))
  {
    HIBYTE(v45) = 1;
    v46[0] = 0;
    if (sub_10007D3E0(v46, (_BYTE *)&v45 + 7))
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v6 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)uint64_t v48 = 0LL;
        unsigned int v7 = sub_100053B4C(1);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v8 = v7;
        }
        else {
          uint64_t v8 = v7 & 0xFFFFFFFE;
        }
        if ((_DWORD)v8)
        {
          *(_WORD *)uint64_t v47 = 0;
          LODWORD(v45) = 2;
          uint64_t v9 = (const char *)_os_log_send_and_compose_impl( v8,  v48,  0LL,  0LL,  &_mh_execute_header,  v6,  0LL,  "SDV needs Migration",  v47,  v45);
          uint64_t v10 = (char *)v9;
          if (v9) {
            sub_100053B7C(v9);
          }
        }

        else
        {
          uint64_t v10 = 0LL;
        }

        free(v10);
      }
    }

    if (!HIBYTE(v45))
    {
      byte_1000DBD3B = 1;
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v11 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)uint64_t v48 = 0LL;
        unsigned int v12 = sub_100053B4C(1);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v13 = v12;
        }
        else {
          uint64_t v13 = v12 & 0xFFFFFFFE;
        }
        if ((_DWORD)v13)
        {
          *(_WORD *)uint64_t v47 = 0;
          LODWORD(v45) = 2;
          CFTypeRef v14 = (const char *)_os_log_send_and_compose_impl( v13,  v48,  0LL,  0LL,  &_mh_execute_header,  v11,  0LL,  "SDV UnEncrypted",  v47,  v45);
          unsigned int v15 = (char *)v14;
          if (v14) {
            sub_100053B7C(v14);
          }
        }

        else
        {
          unsigned int v15 = 0LL;
        }

        free(v15);
      }

      uint64_t v16 = sub_100019B18(qword_1000DBD40);
      uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
      [v17 setIgnoreIdentityMethods:byte_1000DBD3B];
    }
  }

  uint64_t Count = sub_10003FC5C(1);
  if (!(_DWORD)Count) {
    goto LABEL_49;
  }
  sub_1000198B4(qword_1000DBA70, (void *)qword_1000DBCD8);
  uint64_t Count = qword_1000DBCD8;
  if (qword_1000DBCD8)
  {
    uint64_t Count = CFArrayGetCount((CFArrayRef)qword_1000DBCD8);
    if (Count >= 1)
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      __int16 v20 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)unsigned int v46 = 0LL;
        LODWORD(v21) = sub_100053B4C(1);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v21 = v21;
        }
        else {
          uint64_t v21 = v21 & 0xFFFFFFFE;
        }
        if ((_DWORD)v21)
        {
          uint64_t v22 = (const __CFArray *)qword_1000DBCD8;
          int v23 = v20;
          CFIndex v24 = CFArrayGetCount(v22);
          *(_DWORD *)uint64_t v48 = 134217984;
          *(void *)&v48[4] = v24;
          __int128 v25 = (char *)_os_log_send_and_compose_impl( v21,  v46,  0LL,  0LL,  &_mh_execute_header,  v23,  0LL,  "Loaded %zu user sessions",  (size_t)v48);

          if (v25) {
            sub_100053B7C(v25);
          }
        }

        else
        {
          __int128 v25 = 0LL;
        }

        free(v25);
      }
    }
  }

  int v26 = dword_1000DBCE8;
  if (dword_1000DBCE8 == 1 && !dword_1000DBCF0)
  {
    uint64_t Count = sub_100055178(qword_1000DBA70);
    if ((_DWORD)Count == 502) {
      int v27 = 1;
    }
    else {
      int v27 = 2;
    }
    dword_1000DBCF0 = v27;
LABEL_49:
    int v26 = dword_1000DBCE8;
  }

  if (v26 != 1)
  {
    if (qword_1000DBA78) {
      sub_1000A9BF0(Count, v19);
    }
    uint64_t v28 = sub_10005780C((uint64_t)&OBJC_CLASS___UMDPersonaManager, (void *)qword_1000DBA70);
    uint64_t v29 = objc_claimAutoreleasedReturnValue(v28);
    CFNumberRef v30 = (void *)qword_1000DBA78;
    qword_1000DBA78 = v29;

    *(_DWORD *)uint64_t v47 = 0;
    if (qword_1000DBAC0 != -1) {
      dispatch_once(&qword_1000DBAC0, &stru_1000CD568);
    }
    CFNumberRef v31 = (os_log_s *)(id)qword_1000DBAB8;
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)uint64_t v48 = 0LL;
      unsigned int v32 = sub_100053B4C(0);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v33 = v32;
      }
      else {
        uint64_t v33 = v32 & 0xFFFFFFFE;
      }
      if ((_DWORD)v33)
      {
        LOWORD(v46[0]) = 0;
        LODWORD(v45) = 2;
        unsigned int v34 = (const char *)_os_log_send_and_compose_impl( v33,  v48,  0LL,  0LL,  &_mh_execute_header,  v31,  0LL,  "Loaded persona manifest",  v46,  v45);
        uint64_t v35 = (char *)v34;
        if (v34) {
          sub_100053B7C(v34);
        }
      }

      else
      {
        uint64_t v35 = 0LL;
      }

      free(v35);
    }

    if (qword_1000DBAC0 != -1) {
      dispatch_once(&qword_1000DBAC0, &stru_1000CD568);
    }
    uint64_t v36 = (os_log_s *)(id)qword_1000DBAB8;
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
    {
      *(void *)unsigned int v46 = 0LL;
      LODWORD(v37) = sub_100053B4C(0);
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG)) {
        uint64_t v37 = v37;
      }
      else {
        uint64_t v37 = v37 & 0xFFFFFFFE;
      }
      if ((_DWORD)v37)
      {
        uint64_t v38 = qword_1000DBA78;
        CFNumberRef v39 = v36;
        uint64_t v40 = sub_1000197A0(v38);
        CFNumberRef v41 = (void *)objc_claimAutoreleasedReturnValue(v40);
        *(_DWORD *)uint64_t v48 = 138412290;
        *(void *)&v48[4] = v41;
        LODWORD(v45) = 12;
        CFNumberRef v42 = (char *)_os_log_send_and_compose_impl( v37,  v46,  0LL,  0LL,  &_mh_execute_header,  v39,  2LL,  "Persona state: %@",  v48,  v45);

        if (v42) {
          sub_100053B7C(v42);
        }
      }

      else
      {
        CFNumberRef v42 = 0LL;
      }

      free(v42);
    }

    uint64_t v43 = sub_1000197AC(qword_1000DBA78);
    CFTypeRef v44 = (void *)objc_claimAutoreleasedReturnValue(v43);
    sub_1000563F0((uint64_t)v44);
  }

uint64_t sub_10001C3D4()
{
  return byte_1000DBA80;
}

uint64_t sub_10001C3FC(uint64_t a1, uid_t a2)
{
  int v17 = 0;
  if (!a1)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v8 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_32;
    }
    uint64_t v16 = 0LL;
    unsigned int v9 = sub_100053B4C(1);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = v9 & 0xFFFFFFFE;
    }
    if ((_DWORD)v10)
    {
      LOWORD(v18[0]) = 0;
      uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v10,  &v16,  0LL,  0LL,  &_mh_execute_header,  v8,  0LL,  "NULL Session sent, mountDefaultSession FAILED");
      goto LABEL_28;
    }

uint64_t sub_10001C6DC(uint64_t a1, uid_t a2, gid_t a3)
{
  if (!stat(path, &v54))
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v11 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v55 = 0LL;
      unsigned int v12 = sub_100053B4C(1);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v13 = v12;
      }
      else {
        uint64_t v13 = v12 & 0xFFFFFFFE;
      }
      if ((_DWORD)v13)
      {
        int v56 = 136315138;
        *(void *)uint64_t v57 = path;
        CFTypeRef v14 = (const char *)_os_log_send_and_compose_impl( v13,  &v55,  0LL,  0LL,  &_mh_execute_header,  v11,  0LL,  "Path: %s already exits, skipping",  (const char *)&v56);
        unsigned int v15 = (char *)v14;
        if (v14) {
          sub_100053B7C(v14);
        }
      }

      else
      {
        unsigned int v15 = 0LL;
      }

      free(v15);
    }

    uint64_t v16 = 0LL;
    goto LABEL_114;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v6 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v55 = 0LL;
    unsigned int v7 = sub_100053B4C(1);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = v7 & 0xFFFFFFFE;
    }
    if ((_DWORD)v8)
    {
      int v56 = 136315138;
      *(void *)uint64_t v57 = path;
      unsigned int v9 = (const char *)_os_log_send_and_compose_impl( v8,  &v55,  0LL,  0LL,  &_mh_execute_header,  v6,  0LL,  "Creating path: %s",  (const char *)&v56);
      uint64_t v10 = (char *)v9;
      if (v9) {
        sub_100053B7C(v9);
      }
    }

    else
    {
      uint64_t v10 = 0LL;
    }

    free(v10);
  }

  if (mkpath_np(path, 0x3FFu))
  {
    uint64_t v16 = *__error();
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v11 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_114;
    }
    uint64_t v55 = 0LL;
    LODWORD(v17) = sub_100053B4C(1);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v17 = v17;
    }
    else {
      uint64_t v17 = v17 & 0xFFFFFFFE;
    }
    if ((_DWORD)v17)
    {
      uint64_t v18 = v11;
      uint64_t v19 = strerror(v16);
      int v56 = 136315394;
      *(void *)uint64_t v57 = path;
      *(_WORD *)&v57[8] = 2080;
      *(void *)unsigned int v58 = v19;
      __int16 v20 = (void *)_os_log_send_and_compose_impl( v17,  &v55,  0LL,  0LL,  &_mh_execute_header,  v18,  0LL,  "failed to create: %s (%s)\n",  (const char *)&v56,  22);

      if (!v20) {
        goto LABEL_113;
      }
      goto LABEL_111;
    }

    goto LABEL_112;
  }

  if (chmod(path, 0x3FFu))
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v21 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v55 = 0LL;
      LODWORD(v22) = sub_100053B4C(1);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v22 = v22;
      }
      else {
        uint64_t v22 = v22 & 0xFFFFFFFE;
      }
      if ((_DWORD)v22)
      {
        int v23 = v21;
        CFIndex v24 = __error();
        __int128 v25 = strerror(*v24);
        int v56 = 136315394;
        *(void *)uint64_t v57 = path;
        *(_WORD *)&v57[8] = 2080;
        *(void *)unsigned int v58 = v25;
        int v26 = (char *)_os_log_send_and_compose_impl( v22,  &v55,  0LL,  0LL,  &_mh_execute_header,  v23,  0LL,  "failed to change permissions on: %s (%s)\n",  (const char *)&v56,  22);

        if (v26) {
          sub_100053B7C(v26);
        }
      }

      else
      {
        int v26 = 0LL;
      }

      free(v26);
    }
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  int v27 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v55 = 0LL;
    unsigned int v28 = sub_100053B4C(1);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v29 = v28;
    }
    else {
      uint64_t v29 = v28 & 0xFFFFFFFE;
    }
    if ((_DWORD)v29)
    {
      int v56 = 67109376;
      *(_DWORD *)uint64_t v57 = a2;
      *(_WORD *)&v57[4] = 1024;
      *(_DWORD *)&v57[6] = a3;
      CFNumberRef v30 = (const char *)_os_log_send_and_compose_impl( v29,  &v55,  0LL,  0LL,  &_mh_execute_header,  v27,  0LL,  "setting uid:%d, gid:%d",  &v56,  14);
      CFNumberRef v31 = (char *)v30;
      if (v30) {
        sub_100053B7C(v30);
      }
    }

    else
    {
      CFNumberRef v31 = 0LL;
    }

    free(v31);
  }

  if (chown(path, a2, a3))
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v32 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v55 = 0LL;
      LODWORD(v33) = sub_100053B4C(1);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v33 = v33;
      }
      else {
        uint64_t v33 = v33 & 0xFFFFFFFE;
      }
      if ((_DWORD)v33)
      {
        unsigned int v34 = v32;
        uint64_t v35 = __error();
        uint64_t v36 = strerror(*v35);
        int v56 = 136315394;
        *(void *)uint64_t v57 = path;
        *(_WORD *)&v57[8] = 2080;
        *(void *)unsigned int v58 = v36;
        LODWORD(v53) = 22;
        uint64_t v37 = (char *)_os_log_send_and_compose_impl( v33,  &v55,  0LL,  0LL,  &_mh_execute_header,  v34,  0LL,  "failed to change ownership on: %s (%s)\n",  (const char *)&v56,  v53);

        if (v37) {
          sub_100053B7C(v37);
        }
      }

      else
      {
        uint64_t v37 = 0LL;
      }

      free(v37);
    }
  }

  int v38 = open_dprotected_np(path, 0, 0, 1);
  if (v38 != -1)
  {
    int v39 = v38;
    if (fcntl(v38, 64, 4LL))
    {
      uint64_t v16 = *__error();
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v40 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v55 = 0LL;
        LODWORD(v41) = sub_100053B4C(1);
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v41 = v41;
        }
        else {
          uint64_t v41 = v41 & 0xFFFFFFFE;
        }
        if ((_DWORD)v41)
        {
          CFNumberRef v42 = v40;
          uint64_t v43 = strerror(v16);
          int v56 = 136315394;
          *(void *)uint64_t v57 = v43;
          *(_WORD *)&v57[8] = 2080;
          *(void *)unsigned int v58 = path;
          LODWORD(v53) = 22;
          CFTypeRef v44 = (char *)_os_log_send_and_compose_impl( v41,  &v55,  0LL,  0LL,  &_mh_execute_header,  v42,  0LL,  "failed (%s) to update class for %s\n",  (const char *)&v56,  v53);

          if (v44) {
            sub_100053B7C(v44);
          }
        }

        else
        {
          CFTypeRef v44 = 0LL;
        }

        free(v44);
      }

      if ((v39 & 0x80000000) == 0) {
        goto LABEL_97;
      }
    }

    else
    {
      uint64_t v16 = 0LL;
      if ((v39 & 0x80000000) == 0) {
LABEL_97:
      }
        close(v39);
    }

    if (!(_DWORD)v16) {
      return v16;
    }
LABEL_103:
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v11 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_114;
    }
    uint64_t v55 = 0LL;
    unsigned int v50 = sub_100053B4C(1);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v51 = v50;
    }
    else {
      uint64_t v51 = v50 & 0xFFFFFFFE;
    }
    if ((_DWORD)v51)
    {
      int v56 = 136315650;
      *(void *)uint64_t v57 = path;
      *(_WORD *)&v57[8] = 1024;
      *(_DWORD *)unsigned int v58 = 4;
      *(_WORD *)&v58[4] = 1024;
      *(_DWORD *)&v58[6] = v16;
      __int16 v20 = (void *)_os_log_send_and_compose_impl( v51,  &v55,  0LL,  0LL,  &_mh_execute_header,  v11,  0LL,  "Setting PATH:%s to class:%d returned with err:%d",  (const char *)&v56,  24,  v54.st_dev);
      if (!v20)
      {
LABEL_113:
        free(v20);
LABEL_114:

        return v16;
      }

LABEL_111:
      sub_100053B7C((const char *)v20);
      goto LABEL_113;
    }

LABEL_112:
    __int16 v20 = 0LL;
    goto LABEL_113;
  }

  uint64_t v16 = *__error();
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v45 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v55 = 0LL;
    LODWORD(v46) = sub_100053B4C(1);
    if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v46 = v46;
    }
    else {
      uint64_t v46 = v46 & 0xFFFFFFFE;
    }
    if ((_DWORD)v46)
    {
      uint64_t v47 = v45;
      uint64_t v48 = strerror(v16);
      int v56 = 136315394;
      *(void *)uint64_t v57 = v48;
      *(_WORD *)&v57[8] = 2080;
      *(void *)unsigned int v58 = path;
      LODWORD(v53) = 22;
      unsigned int v49 = (char *)_os_log_send_and_compose_impl( v46,  &v55,  0LL,  0LL,  &_mh_execute_header,  v47,  0LL,  "failed (%s) to open path %s\n",  (const char *)&v56,  v53);

      if (v49) {
        sub_100053B7C(v49);
      }
    }

    else
    {
      unsigned int v49 = 0LL;
    }

    free(v49);
  }

  if ((_DWORD)v16) {
    goto LABEL_103;
  }
  return v16;
}

uint64_t sub_10001D0C0()
{
  return sub_100055178(qword_1000DBA70);
}

uint64_t sub_10001D0CC(const char **__argv)
{
  if (posix_spawn(&v17, *__argv, 0LL, 0LL, (char *const *)__argv, 0LL))
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    CFIndex v2 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = 0LL;
      unsigned int v3 = sub_100053B4C(1);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v4 = v3;
      }
      else {
        uint64_t v4 = v3 & 0xFFFFFFFE;
      }
      if ((_DWORD)v4)
      {
        uint64_t v5 = *__argv;
        int v18 = 136315138;
        uint64_t v19 = (void *)v5;
        uint64_t v6 = (const char *)_os_log_send_and_compose_impl( v4,  &v15,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "Unable to spawn %s",  (const char *)&v18);
        unsigned int v7 = (char *)v6;
        if (v6) {
          sub_100053B7C(v6);
        }
      }

      else
      {
        unsigned int v7 = 0LL;
      }

      free(v7);
    }
  }

  if (waitpid(v17, &v16, 0) == -1)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v8 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = 0LL;
      LODWORD(v9) = sub_100053B4C(1);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v9 = v9;
      }
      else {
        uint64_t v9 = v9 & 0xFFFFFFFE;
      }
      if ((_DWORD)v9)
      {
        uint64_t v10 = v8;
        uint64_t v11 = __error();
        unsigned int v12 = strerror(*v11);
        int v18 = 136315138;
        uint64_t v19 = v12;
        uint64_t v13 = (char *)_os_log_send_and_compose_impl( v9,  &v15,  0LL,  0LL,  &_mh_execute_header,  v10,  0LL,  "Cannot wait for pid: %s",  (const char *)&v18);

        if (v13) {
          sub_100053B7C(v13);
        }
      }

      else
      {
        uint64_t v13 = 0LL;
      }

      free(v13);
    }
  }

  if ((v16 & 0x7F) != 0) {
    return 0xFFFFFFFFLL;
  }
  else {
    return BYTE1(v16);
  }
}

BOOL sub_10001D344()
{
  size_t __len = 1023LL;
  bzero(__big, 0x400uLL);
  return !sysctlbyname("kern.bootargs", __big, &__len, 0LL, 0LL) && strnstr(__big, "usersession_enable", __len) != 0LL;
}

BOOL sub_10001D3E8()
{
  size_t __len = 1023LL;
  bzero(__big, 0x400uLL);
  return !sysctlbyname("kern.bootargs", __big, &__len, 0LL, 0LL)
      && strnstr(__big, "stop_auto_bubblelaunch", __len) != 0LL;
}

uint64_t sub_10001D48C()
{
  size_t __len = 1023LL;
  bzero(__big, 0x400uLL);
  if (sysctlbyname("kern.bootargs", __big, &__len, 0LL, 0LL)) {
    return 120LL;
  }
  unsigned int v3 = 0;
  __big[1023] = 0;
  uint64_t v1 = strnstr(__big, "bubblelaunch_delay=", __len);
  uint64_t v0 = 120LL;
  if (v1)
  {
    if (sscanf(v1, "bubblelaunch_delay=%d", &v3) == 1) {
      return v3;
    }
    else {
      return 120LL;
    }
  }

  return v0;
}

CFNumberRef sub_10001D55C(int a1)
{
  int valuePtr = a1;
  if (qword_1000DBCF8) {
    sub_10001D70C(a1);
  }
  else {
    qword_1000DBCF8 = (uint64_t)sub_100084320();
  }
  CFNumberRef result = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  if (result)
  {
    unsigned int v3 = result;
    CFArrayAppendValue((CFMutableArrayRef)qword_1000DBCF8, result);
    qword_1000DBD20 = CFArrayGetCount((CFArrayRef)qword_1000DBCF8);
    CFRelease(v3);
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v4 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = 0LL;
      unsigned int v5 = sub_100053B4C(1);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v6 = v5;
      }
      else {
        uint64_t v6 = v5 & 0xFFFFFFFE;
      }
      if ((_DWORD)v6)
      {
        v11[0] = 67109378;
        v11[1] = a1;
        __int16 v12 = 2112;
        uint64_t v13 = qword_1000DBCF8;
        unsigned int v7 = (const char *)_os_log_send_and_compose_impl( v6,  &v9,  0LL,  0LL,  &_mh_execute_header,  v4,  0LL,  "ADDING UID:%d to BUBBLE TABLE: table %@",  v11,  18);
        uint64_t v8 = (char *)v7;
        if (v7) {
          sub_100053B7C(v7);
        }
      }

      else
      {
        uint64_t v8 = 0LL;
      }

      free(v8);
    }

    return (CFNumberRef)1;
  }

  return result;
}

uint64_t sub_10001D70C(int a1)
{
  uint64_t result = qword_1000DBCF8;
  if (qword_1000DBCF8)
  {
    if (CFArrayGetCount((CFArrayRef)qword_1000DBCF8) < 1)
    {
      return 0LL;
    }

    else
    {
      CFIndex v3 = 0LL;
      while (1)
      {
        ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)qword_1000DBCF8, v3);
        if (ValueAtIndex)
        {
          unsigned int v5 = ValueAtIndex;
          CFTypeID v6 = CFGetTypeID(ValueAtIndex);
          if (v6 == CFNumberGetTypeID() && CFNumberGetValue(v5, kCFNumberIntType, &valuePtr) && valuePtr == a1) {
            break;
          }
        }

        if (CFArrayGetCount((CFArrayRef)qword_1000DBCF8) <= ++v3) {
          return 0LL;
        }
      }

      CFArrayRemoveValueAtIndex((CFMutableArrayRef)qword_1000DBCF8, v3);
      qword_1000DBD20 = CFArrayGetCount((CFArrayRef)qword_1000DBCF8);
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v8 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v13 = 0LL;
        unsigned int v9 = sub_100053B4C(1);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v10 = v9;
        }
        else {
          uint64_t v10 = v9 & 0xFFFFFFFE;
        }
        if ((_DWORD)v10)
        {
          v15[0] = 67109120;
          v15[1] = a1;
          uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v10,  &v13,  0LL,  0LL,  &_mh_execute_header,  v8,  0LL,  "REMOVING UID:%d to BUBBLE TABLE",  v15);
          __int16 v12 = (char *)v11;
          if (v11) {
            sub_100053B7C(v11);
          }
        }

        else
        {
          __int16 v12 = 0LL;
        }

        free(v12);
      }

      return 1LL;
    }
  }

  return result;
}

uint64_t sub_10001D8E8(CFDictionaryRef theDict, int a2)
{
  CFIndex v3 = theDict;
  if (theDict
    || (id v4 = sub_100054ED0(qword_1000DBA70, a2),
        uint64_t result = objc_claimAutoreleasedReturnValue(v4),
        (CFIndex v3 = (__CFDictionary *)result) != 0LL))
  {
    if (CFDictionaryContainsKey(v3, kUMUserSessionSyncMachServicesKey)) {
      CFDictionaryRemoveValue(v3, kUMUserSessionSyncMachServicesKey);
    }
    if (CFDictionaryContainsKey(v3, kUMUserSessionSyncTasksKey)) {
      CFDictionaryRemoveValue(v3, kUMUserSessionSyncTasksKey);
    }
    if (CFDictionaryContainsKey(v3, kUMUserSessionDirtyKey)) {
      CFDictionarySetValue(v3, kUMUserSessionDirtyKey, kCFBooleanFalse);
    }
    int v6 = sub_100083C6C(v3, kUMUserSessionIDKey);
    sub_10001D70C(v6);
    if (!theDict) {
      CFRelease(v3);
    }
    return 1LL;
  }

  return result;
}

CFNumberRef sub_10001D9CC(int a1)
{
  int valuePtr = a1;
  if (qword_1000DBD00) {
    sub_10001DA54(a1);
  }
  else {
    qword_1000DBD00 = (uint64_t)sub_100084320();
  }
  CFNumberRef result = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  if (result)
  {
    CFIndex v2 = result;
    CFArrayAppendValue((CFMutableArrayRef)qword_1000DBD00, result);
    qword_1000DBD28 = CFArrayGetCount((CFArrayRef)qword_1000DBD00);
    CFRelease(v2);
    return (CFNumberRef)1;
  }

  return result;
}

uint64_t sub_10001DA54(int a1)
{
  uint64_t result = qword_1000DBD00;
  if (qword_1000DBD00)
  {
    if (CFArrayGetCount((CFArrayRef)qword_1000DBD00) < 1)
    {
      return 0LL;
    }

    else
    {
      CFIndex v3 = 0LL;
      while (1)
      {
        ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)qword_1000DBD00, v3);
        if (ValueAtIndex)
        {
          unsigned int v5 = ValueAtIndex;
          CFTypeID v6 = CFGetTypeID(ValueAtIndex);
          if (v6 == CFNumberGetTypeID() && CFNumberGetValue(v5, kCFNumberIntType, &valuePtr) && valuePtr == a1) {
            break;
          }
        }

        if (CFArrayGetCount((CFArrayRef)qword_1000DBD00) <= ++v3) {
          return 0LL;
        }
      }

      CFArrayRemoveValueAtIndex((CFMutableArrayRef)qword_1000DBD00, v3);
      qword_1000DBD28 = CFArrayGetCount((CFArrayRef)qword_1000DBD00);
      return 1LL;
    }
  }

  return result;
}

uint64_t sub_10001DB28()
{
  if (!qword_1000DBD00) {
    return 0xFFFFFFFFLL;
  }
  ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)qword_1000DBD00, 0LL);
  if (!ValueAtIndex) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v1 = ValueAtIndex;
  CFTypeID v2 = CFGetTypeID(ValueAtIndex);
  if (v2 != CFNumberGetTypeID()) {
    return 0xFFFFFFFFLL;
  }
  if (CFNumberGetValue(v1, kCFNumberIntType, &valuePtr)) {
    return valuePtr;
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_10001DB9C(uint64_t a1, char *a2, gid_t a3)
{
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  CFTypeID v6 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)int v39 = 0LL;
    unsigned int v7 = sub_100053B4C(1);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = v7 & 0xFFFFFFFE;
    }
    if ((_DWORD)v8)
    {
      LOWORD(v42) = 0;
      unsigned int v9 = (const char *)_os_log_send_and_compose_impl( v8,  v39,  0LL,  0LL,  &_mh_execute_header,  v6,  0LL,  "LocalUserEnrollment file Layout Set",  &v42,  2);
      uint64_t v10 = (char *)v9;
      if (v9) {
        sub_100053B7C(v9);
      }
    }

    else
    {
      uint64_t v10 = 0LL;
    }

    free(v10);
  }

  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(+[UMLManager sharedManager](&OBJC_CLASS___UMLManager, "sharedManager"));
  __int16 v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithCString:encoding:]( &OBJC_CLASS___NSString,  "stringWithCString:encoding:",  a1,  4LL));
  uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v12 stringByAppendingString:@"/"]);
  uint64_t v37 = a1;
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  CFTypeRef v14 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = a2;
    uint64_t v42 = 0LL;
    unsigned int v16 = sub_100053B4C(1);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v17 = v16;
    }
    else {
      uint64_t v17 = v16 & 0xFFFFFFFE;
    }
    if ((_DWORD)v17)
    {
      *(_DWORD *)int v39 = 138412546;
      *(void *)&v39[4] = @"/";
      __int16 v40 = 2112;
      uint64_t v41 = v13;
      LODWORD(v36) = 22;
      int v18 = (const char *)_os_log_send_and_compose_impl( v17,  &v42,  0LL,  0LL,  &_mh_execute_header,  v14,  0LL,  "Updating the User template:%@  to homePathString:%@",  v39,  v36,  v37);
      uint64_t v19 = (char *)v18;
      if (v18) {
        sub_100053B7C(v18);
      }
    }

    else
    {
      uint64_t v19 = 0LL;
    }

    a2 = v15;
    free(v19);
  }

  id v38 = 0LL;
  unsigned __int8 v20 = [v11 createUserLayoutForUserwithUserID:a2 withAKSSetup:1 onUserVolumePath:v13 fromSystemVolumePath:@"/" withError:&v38];
  id v21 = v38;
  uint64_t v22 = v21;
  if ((v20 & 1) != 0)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    int v23 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      int v24 = (int)a2;
      *(void *)int v39 = 0LL;
      unsigned int v25 = sub_100053B4C(1);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v26 = v25;
      }
      else {
        uint64_t v26 = v25 & 0xFFFFFFFE;
      }
      if ((_DWORD)v26)
      {
        LOWORD(v42) = 0;
        LODWORD(v36) = 2;
        int v27 = (const char *)_os_log_send_and_compose_impl( v26,  v39,  0LL,  0LL,  &_mh_execute_header,  v23,  0LL,  "UMLLayout successful",  &v42,  v36);
        a2 = (char *)v27;
        if (v27) {
          sub_100053B7C(v27);
        }
      }

      else
      {
        a2 = 0LL;
      }

      free(a2);
      LODWORD(a2) = v24;
    }
  }

  else
  {
    int v28 = (int)a2;
    unsigned int v29 = [v21 code];
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    int v23 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)int v39 = 0LL;
      unsigned int v30 = sub_100053B4C(1);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v31 = v30;
      }
      else {
        uint64_t v31 = v30 & 0xFFFFFFFE;
      }
      if ((_DWORD)v31)
      {
        LODWORD(v42) = 67109120;
        HIDWORD(v42) = v29;
        unsigned int v32 = (const char *)_os_log_send_and_compose_impl( v31,  v39,  0LL,  0LL,  &_mh_execute_header,  v23,  0LL,  "UMLLayout failed with error:%d",  &v42);
        uint64_t v33 = (char *)v32;
        if (v32) {
          sub_100053B7C(v32);
        }
      }

      else
      {
        uint64_t v33 = 0LL;
      }

      free(v33);
    }

    LODWORD(a2) = v28;
  }

  uint64_t v34 = sub_10001C6DC(v37, (uid_t)a2, a3);
  return v34;
}

uint64_t sub_10001E030(char *a1, int a2)
{
  if (!a1) {
    return 22LL;
  }
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472LL;
  unsigned int v16 = sub_10001E194;
  uint64_t v17 = &unk_1000CD410;
  int v18 = a2;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472LL;
  __int16 v12 = sub_10001E1BC;
  uint64_t v13 = &unk_1000CD430;
  int v14 = a2;
  CFIndex v3 = v15;
  id v4 = v11;
  v19[0] = a1;
  v19[1] = 0LL;
  unsigned int v5 = fts_open(v19, 84, 0LL);
  if (v5)
  {
    CFTypeID v6 = v5;
    unsigned int v7 = fts_read(v5);
    if (v7)
    {
      uint64_t v8 = v7;
      do
      {
        int fts_info = v8->fts_info;
        if (fts_info == 8)
        {
          v12((uint64_t)v4, (uint64_t)v8);
        }

        else if (fts_info == 1 && (v16((uint64_t)v3, (uint64_t)v8) & 1) == 0)
        {
          fts_set(v6, v8, 4);
        }

        uint64_t v8 = fts_read(v6);
      }

      while (v8);
    }

    fts_close(v6);
  }

  return 0LL;
}

uint64_t sub_10001E194(uint64_t a1, uint64_t a2)
{
  return 1LL;
}

uint64_t sub_10001E1BC(uint64_t a1, uint64_t a2)
{
  return lchown(*(const char **)(a2 + 48), *(_DWORD *)(a1 + 32), *(_DWORD *)(a1 + 32));
}

BOOL sub_10001E1D0(int a1)
{
  int v17 = a1;
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  CFTypeID v2 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = 0LL;
    unsigned int v3 = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      int v18 = 67109120;
      int v19 = a1;
      unsigned int v5 = (const char *)_os_log_send_and_compose_impl( v4,  &v16,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "Trying to set net.inet.tcp.recvbg with value:%d",  &v18);
      CFTypeID v6 = (char *)v5;
      if (v5) {
        sub_100053B7C(v5);
      }
    }

    else
    {
      CFTypeID v6 = 0LL;
    }

    free(v6);
  }

  int v7 = sysctlbyname("net.inet.tcp.recvbg", 0LL, 0LL, &v17, 4uLL);
  if (v7)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v8 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = 0LL;
      unsigned int v9 = sub_100053B4C(1);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = v9 & 0xFFFFFFFE;
      }
      if ((_DWORD)v10)
      {
        int v18 = 67109120;
        int v19 = v7;
        uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v10,  &v16,  0LL,  0LL,  &_mh_execute_header,  v8,  0LL,  "FAILED to set net.inet.tcp.recvbg with error:%d",  &v18);
        goto LABEL_29;
      }

      goto LABEL_31;
    }
  }

  else
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v8 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = 0LL;
      unsigned int v12 = sub_100053B4C(1);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v13 = v12;
      }
      else {
        uint64_t v13 = v12 & 0xFFFFFFFE;
      }
      if ((_DWORD)v13)
      {
        int v18 = 67109120;
        int v19 = v17;
        uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v13,  &v16,  0LL,  0LL,  &_mh_execute_header,  v8,  0LL,  "SUCCESS: set net.inet.tcp.recvbg with value: %d",  &v18);
LABEL_29:
        int v14 = (char *)v11;
        if (v11) {
          sub_100053B7C(v11);
        }
        goto LABEL_32;
      }

CFDictionaryRef sub_10001E4AC()
{
  uint64_t v0 = (const __CFDictionary *)MGCopyAnswer(@"DiskUsage", 0LL);
  uint64_t v1 = v0;
  if (v0)
  {
    uint64_t v2 = sub_100083D3C(v0, kMGQDiskUsageTotalDiskCapacity);
    uint64_t v3 = sub_100083D3C(v1, kMGQDiskUsageTotalSystemCapacity);
    uint64_t v1 = (const __CFDictionary *)sub_100083D3C(v1, kMGQDiskUsageTotalDataCapacity);
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v4 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = 0LL;
      unsigned int v5 = sub_100053B4C(1);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v6 = v5;
      }
      else {
        uint64_t v6 = v5 & 0xFFFFFFFE;
      }
      if ((_DWORD)v6)
      {
        int v12 = 134218496;
        uint64_t v13 = v2;
        __int16 v14 = 2048;
        uint64_t v15 = v3;
        __int16 v16 = 2048;
        int v17 = v1;
        int v7 = (const char *)_os_log_send_and_compose_impl( v6,  &v11,  0LL,  0LL,  &_mh_execute_header,  v4,  0LL,  "TOTAL:%lld Bytes, SYSTEM:%lld Bytes, DATA:%lld Bytes",  &v12,  32,  v10);
        uint64_t v8 = (char *)v7;
        if (v7) {
          sub_100053B7C(v7);
        }
      }

      else
      {
        uint64_t v8 = 0LL;
      }

      free(v8);
    }
  }

  return v1;
}

uint64_t sub_10001E65C()
{
  if (statfs(v1, &v2)) {
    return 0LL;
  }
  else {
    return v2.f_bfree * v2.f_bsize;
  }
}

unint64_t sub_10001E6E0(unint64_t a1, unint64_t *a2, unint64_t *a3, uint64_t *a4)
{
  unint64_t v7 = (uint64_t)sub_10001E4AC() / 0x100000;
  if (!(v7 >> 14))
  {
    unint64_t v8 = v7 - 4096;
    unint64_t v9 = (v7 - 4096) >> 10;
    uint64_t v10 = 4096LL;
LABEL_5:
    uint64_t v47 = v10;
    unint64_t v11 = 1024LL;
    goto LABEL_7;
  }

  if (!(v7 >> 15))
  {
    unint64_t v8 = v7 - 0x2000;
    unint64_t v9 = (v7 - 0x2000) >> 10;
    uint64_t v10 = 0x2000LL;
    goto LABEL_5;
  }

  unint64_t v8 = v7 - 0x4000;
  unint64_t v9 = (v7 - 0x4000) >> 11;
  uint64_t v47 = 0x4000LL;
  unint64_t v11 = 2048LL;
LABEL_7:
  if ((int)v9 >= 16)
  {
    if (v8 / 0xF >= v11)
    {
      unint64_t v9 = 15LL;
      unint64_t v11 = v8 / 0xF;
    }

    else
    {
      unint64_t v9 = v8 / v11;
    }
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  int v12 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v52 = 0LL;
    unsigned int v13 = sub_100053B4C(1);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v14 = v13;
    }
    else {
      uint64_t v14 = v13 & 0xFFFFFFFE;
    }
    if ((_DWORD)v14)
    {
      *(_DWORD *)unsigned int v49 = 67109376;
      *(_DWORD *)&v49[4] = a1;
      *(_WORD *)&v49[8] = 1024;
      *(_DWORD *)&v49[10] = v9;
      uint64_t v15 = (const char *)_os_log_send_and_compose_impl( v14,  &v52,  0LL,  0LL,  &_mh_execute_header,  v12,  0LL,  "Requested Number of Users:%d, Maximum configurable:%d",  v49,  14);
      __int16 v16 = (char *)v15;
      if (v15) {
        sub_100053B7C(v15);
      }
    }

    else
    {
      __int16 v16 = 0LL;
    }

    free(v16);
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  int v17 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v52 = 0LL;
    unsigned int v18 = sub_100053B4C(1);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v19 = v18;
    }
    else {
      uint64_t v19 = v18 & 0xFFFFFFFE;
    }
    if ((_DWORD)v19)
    {
      *(_DWORD *)unsigned int v49 = 134218496;
      *(void *)&v49[4] = v7;
      *(_WORD *)&_BYTE v49[12] = 2048;
      *(void *)&v49[14] = v47;
      __int16 v50 = 2048;
      unint64_t v51 = v8;
      LODWORD(v45) = 32;
      unsigned __int8 v20 = (const char *)_os_log_send_and_compose_impl( v19,  &v52,  0LL,  0LL,  &_mh_execute_header,  v17,  0LL,  "TOTAL DISK SPACE:%lld MBytes, System Space OFFSET:%lld MBytes, Space for Users:%lld MBytes",  v49,  v45,  v46);
      id v21 = (char *)v20;
      if (v20) {
        sub_100053B7C(v20);
      }
    }

    else
    {
      id v21 = 0LL;
    }

    free(v21);
  }

  if ((_DWORD)a1 == -1)
  {
    unint64_t v27 = v8 / 0x3E8;
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unint64_t v11 = 100 * v27;
    int v28 = (os_log_s *)(id)qword_1000DBA98;
    unsigned int v29 = a2;
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)unsigned int v49 = 0LL;
      unsigned int v30 = sub_100053B4C(1);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v31 = v30;
      }
      else {
        uint64_t v31 = v30 & 0xFFFFFFFE;
      }
      if ((_DWORD)v31)
      {
        uint64_t v52 = 0xA04000100LL;
        unsigned int v32 = (const char *)_os_log_send_and_compose_impl( v31,  v49,  0LL,  0LL,  &_mh_execute_header,  v28,  0LL,  "Allocating default number of users(%d) as none specified",  &v52);
        uint64_t v33 = (char *)v32;
        if (v32) {
          sub_100053B7C(v32);
        }
      }

      else
      {
        uint64_t v33 = 0LL;
      }

      free(v33);
    }

    unint64_t v9 = 10LL;
  }

  else if ((int)v9 <= (int)a1)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v29 = a2;
    uint64_t v34 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)unsigned int v49 = 0LL;
      unsigned int v35 = sub_100053B4C(1);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v36 = v35;
      }
      else {
        uint64_t v36 = v35 & 0xFFFFFFFE;
      }
      if ((_DWORD)v36)
      {
        LOWORD(v52) = 0;
        LODWORD(v45) = 2;
        uint64_t v37 = (const char *)_os_log_send_and_compose_impl( v36,  v49,  0LL,  0LL,  &_mh_execute_header,  v34,  0LL,  "Allocating Default User Size as specified users exceed the device limits",  &v52,  v45);
        id v38 = (char *)v37;
        if (v37) {
          sub_100053B7C(v37);
        }
      }

      else
      {
        id v38 = 0LL;
      }

      free(v38);
    }
  }

  else
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v22 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)unsigned int v49 = 0LL;
      unsigned int v23 = sub_100053B4C(1);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v24 = v23;
      }
      else {
        uint64_t v24 = v23 & 0xFFFFFFFE;
      }
      if ((_DWORD)v24)
      {
        LOWORD(v52) = 0;
        LODWORD(v45) = 2;
        unsigned int v25 = (const char *)_os_log_send_and_compose_impl( v24,  v49,  0LL,  0LL,  &_mh_execute_header,  v22,  0LL,  "Allocating Custom User Size",  &v52,  v45);
        uint64_t v26 = (char *)v25;
        if (v25) {
          sub_100053B7C(v25);
        }
      }

      else
      {
        uint64_t v26 = 0LL;
      }

      free(v26);
    }

    unint64_t v9 = a1;
    unint64_t v11 = v8 / (int)a1;
    unsigned int v29 = a2;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  int v39 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v52 = 0LL;
    unsigned int v40 = sub_100053B4C(1);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v41 = v40;
    }
    else {
      uint64_t v41 = v40 & 0xFFFFFFFE;
    }
    if ((_DWORD)v41)
    {
      *(_DWORD *)unsigned int v49 = 67109376;
      *(_DWORD *)&v49[4] = v9;
      *(_WORD *)&v49[8] = 2048;
      *(void *)&v49[10] = v11;
      LODWORD(v45) = 18;
      uint64_t v42 = (const char *)_os_log_send_and_compose_impl( v41,  &v52,  0LL,  0LL,  &_mh_execute_header,  v39,  0LL,  "Configured for %d Users, Each with size :%lld MBytes",  v49,  v45);
      uint64_t v43 = (char *)v42;
      if (v42) {
        sub_100053B7C(v42);
      }
    }

    else
    {
      uint64_t v43 = 0LL;
    }

    free(v43);
  }

  if (v29) {
    *unsigned int v29 = v11;
  }
  if (a3) {
    *a3 = v7;
  }
  if (a4) {
    *a4 = v47;
  }
  return v9;
}

__CFDictionary *sub_10001ED88(int a1, uint64_t a2)
{
  int valuePtr = 502;
  unsigned int v187 = a1;
  int v184 = a1;
  gid_t v185 = 502;
  if (!a2)
  {
    int v3 = MKBGetDeviceLockState(0LL);
    if (v3 != 3)
    {
      int v9 = v3;
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v10 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)v194 = 0LL;
        unsigned int v11 = sub_100053B4C(1);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v12 = v11;
        }
        else {
          uint64_t v12 = v11 & 0xFFFFFFFE;
        }
        if ((_DWORD)v12)
        {
          *(_DWORD *)__str = 67109120;
          int v192 = v9;
          unsigned int v13 = (const char *)_os_log_send_and_compose_impl( v12,  v194,  0LL,  0LL,  &_mh_execute_header,  v10,  0LL,  "MKB: CANNOT CONFIGURE LOGINWINDOW;  DEVICE SEEMS TO HAVE PASSCODE SET(lockstate:0x%x)",
                                __str);
          uint64_t v14 = (char *)v13;
          if (v13) {
            sub_100053B7C(v13);
          }
        }

        else
        {
          uint64_t v14 = 0LL;
        }

        free(v14);
      }

      goto LABEL_283;
    }

    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v4 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v4, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)v194 = 0LL;
      unsigned int v5 = sub_100053B4C(1);
      uint64_t v6 = (os_log_s *)v4;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v7 = v5;
      }
      else {
        uint64_t v7 = v5 & 0xFFFFFFFE;
      }
      if ((_DWORD)v7)
      {
        *(_DWORD *)__str = 67109120;
        int v192 = 3;
        unint64_t v8 = (char *)_os_log_send_and_compose_impl( v7,  v194,  0LL,  0LL,  &_mh_execute_header,  v6,  0LL,  "MKB: DEVICE HAS NO PASSCODE SET(lockstate:0x%x)",  __str);

        if (v8) {
          sub_100053B7C(v8);
        }
      }

      else
      {

        unint64_t v8 = 0LL;
      }

      free(v8);
    }
  }

  byte_1000DACB8 = 1;
  qword_1000DBA88 = (uint64_t)kUMUserSessionAPFSNativeVolume;
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v15 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)v194 = 0LL;
    unsigned int v16 = sub_100053B4C(1);
    int v17 = (os_log_s *)v15;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v18 = v16;
    }
    else {
      uint64_t v18 = v16 & 0xFFFFFFFE;
    }
    if ((_DWORD)v18)
    {
      *(_WORD *)__str = 0;
      uint64_t v19 = (char *)_os_log_send_and_compose_impl( v18,  v194,  0LL,  0LL,  &_mh_execute_header,  v17,  0LL,  "DEVICE CONFIGURED FOR NATIVE APFS DEVICE",  __str,  2);

      if (v19) {
        sub_100053B7C(v19);
      }
    }

    else
    {

      uint64_t v19 = 0LL;
    }

    free(v19);
  }

  unsigned __int8 v20 = sub_10008428C();
  if (v20)
  {
    CFNumberRef v21 = CFNumberCreate(0LL, kCFNumberIntType, &valuePtr);
    CFDictionarySetValue(v20, kUMUserSessionIDKey, v21);
    if (v21) {
      CFRelease(v21);
    }
    CFNumberRef v22 = CFNumberCreate(0LL, kCFNumberIntType, &v185);
    CFDictionarySetValue(v20, kUMUserSessionGroupIDKey, v22);
    if (v22) {
      CFRelease(v22);
    }
    CFDictionarySetValue(v20, kUMUserSessionNeedsMountKey, kCFBooleanFalse);
    CFDictionarySetValue(v20, kUMUserSessionTypeKey, kUMUserSessionManagedDevice);
    CFDictionarySetValue(v20, kUMUserSessionForegroundKey, kCFBooleanFalse);
    CFDictionarySetValue(v20, kUMUserSessionDirtyKey, kCFBooleanFalse);
    CFDictionarySetValue(v20, kUMUserSessionDisabledKey, kCFBooleanFalse);
    CFBooleanRef v23 = kCFBooleanTrue;
    CFDictionarySetValue(v20, kUMUserSessionLoginUserKey, kCFBooleanTrue);
    CFDictionarySetValue(v20, kUMUserSessionUserVolumeTypeKey, (const void *)qword_1000DBA88);
    CFDictionarySetValue(v20, kUMUserSessionisPrimaryKey, kCFBooleanTrue);
    CFDictionarySetValue(v20, kUMUserSessionisAdminKey, kCFBooleanTrue);
    bzero(__str, 0x400uLL);
    if (valuePtr <= 501) {
      int v24 = valuePtr;
    }
    else {
      int v24 = valuePtr - 501;
    }
    snprintf(__str, 0x400uLL, "euser%d", v24);
    CFStringRef v25 = CFStringCreateWithCString(0LL, __str, 0x8000100u);
    CFDictionarySetValue(v20, kUMUserSessionShortNameKey, v25);
    if (v25) {
      CFRelease(v25);
    }
    uint64_t v182 = a2;
    CFStringRef v26 = CFStringCreateWithCString(0LL, "Loginwindow", 0x8000100u);
    CFDictionarySetValue(v20, kUMUserSessionNameKey, v26);
    CFDictionarySetValue(v20, kUMUserSessionFirstNameKey, v26);
    CFDictionarySetValue(v20, kUMUserSessionLastNameKey, v26);
    CFDictionarySetValue(v20, kUMUserSessionDisplayNameKey, v26);
    if (v26) {
      CFRelease(v26);
    }
    [(id)qword_1000DBA68 splitUserVolumeEnabled];
    unint64_t v27 = CFUUIDCreate(0LL);
    id v28 = sub_100017D48((uint64_t)&OBJC_CLASS___NSUUID, v27);
    uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v28);
    CFStringRef v29 = CFUUIDCreateString(0LL, v27);
    CFDictionarySetValue(v20, kUMUserSessionUUIDKey, v29);
    if (v27) {
      CFRelease(v27);
    }
    if (v29) {
      CFRelease(v29);
    }
    unsigned int v30 = CFUUIDCreate(0LL);
    CFStringRef v31 = CFUUIDCreateString(0LL, v30);
    CFDictionarySetValue(v20, kUMUserSessionAlternateDSIDKey, v31);
    if (v30) {
      CFRelease(v30);
    }
    if (v31) {
      CFRelease(v31);
    }
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    CFDateRef v33 = CFDateCreate(kCFAllocatorDefault, Current);
    CFDictionarySetValue(v20, kUMUserSessionCreateTimeStampKey, v33);
    CFDictionarySetValue(v20, kUMUserSessionLoginTimeStampKey, v33);
    if (v33) {
      CFRelease(v33);
    }
    qword_1000DACC0 = 1001LL;
    CFNumberRef v34 = CFNumberCreate(0LL, kCFNumberLongLongType, &qword_1000DACC0);
    CFDictionarySetValue(v20, kUMUserSessionAPNSIDKey, v34);
    CFRelease(v34);
    unsigned int v35 = CFUUIDCreate(0LL);
    uint64_t v36 = CFUUIDCreateString(0LL, v35);
    if (v35) {
      CFRelease(v35);
    }
    bzero(buffer, 0x400uLL);
    CFStringGetCString(v36, buffer, 1024LL, 0x8000100u);
    if (v36) {
      CFRelease(v36);
    }
    bzero(__str, 0x400uLL);
    snprintf(__str, 0x400uLL, "/var/%s", buffer);
    CFStringRef v37 = CFStringCreateWithCString(0LL, __str, 0x8000100u);
    CFDictionarySetValue(v20, kUMUserSessionLibinfoHomeDirKey, v37);
    if (v37) {
      CFRelease(v37);
    }
    bzero(__str, 0x400uLL);
    snprintf(__str, 0x400uLL, "/private/var/%s", buffer);
    CFStringRef v38 = CFStringCreateWithCString(0LL, __str, 0x8000100u);
    CFDictionarySetValue(v20, kUMUserSessionHomeDirKey, v38);
    if (v38) {
      CFRelease(v38);
    }
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v39 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v39, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)v194 = 0LL;
      unsigned int v40 = sub_100053B4C(1);
      uint64_t v41 = (os_log_s *)v39;
      if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v42 = v40;
      }
      else {
        uint64_t v42 = v40 & 0xFFFFFFFE;
      }
      if ((_DWORD)v42)
      {
        LOWORD(v193[0]) = 0;
        LODWORD(v17_Block_object_dispose(va, 8) = 2;
        uint64_t v43 = (char *)_os_log_send_and_compose_impl( v42,  v194,  0LL,  0LL,  &_mh_execute_header,  v41,  0LL,  "Create Users mount dir if not already set",  v193,  v178);

        if (v43) {
          sub_100053B7C(v43);
        }
      }

      else
      {

        uint64_t v43 = 0LL;
      }

      free(v43);
    }

    [(id)qword_1000DBA68 createVolumeMountsDir:@"/var/Users"];
    if (sub_100020F1C(__str, (char *)valuePtr, v185))
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      id v44 = (id)qword_1000DBA98;
      if (os_log_type_enabled((os_log_t)v44, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)v194 = 0LL;
        unsigned int v45 = sub_100053B4C(1);
        id v44 = v44;
        if (os_log_type_enabled((os_log_t)v44, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v46 = v45;
        }
        else {
          uint64_t v46 = v45 & 0xFFFFFFFE;
        }
        if ((_DWORD)v46)
        {
          LOWORD(v193[0]) = 0;
          LODWORD(v17_Block_object_dispose(va, 8) = 2;
          uint64_t v47 = _os_log_send_and_compose_impl( v46,  v194,  0LL,  0LL,  &_mh_execute_header,  v44,  0LL,  "Created Loginwindow layout",  v193,  v178);
          goto LABEL_93;
        }

        goto LABEL_95;
      }
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      id v44 = (id)qword_1000DBA98;
      if (os_log_type_enabled((os_log_t)v44, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)v194 = 0LL;
        unsigned int v48 = sub_100053B4C(1);
        id v44 = v44;
        if (os_log_type_enabled((os_log_t)v44, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v49 = v48;
        }
        else {
          uint64_t v49 = v48 & 0xFFFFFFFE;
        }
        if ((_DWORD)v49)
        {
          LOWORD(v193[0]) = 0;
          LODWORD(v17_Block_object_dispose(va, 8) = 2;
          uint64_t v47 = _os_log_send_and_compose_impl( v49,  v194,  0LL,  0LL,  &_mh_execute_header,  v44,  0LL,  "Failed to create Loginwindow layout",  v193,  v178);
LABEL_93:
          __int16 v50 = (char *)v47;

          if (v50) {
            sub_100053B7C(v50);
          }
          goto LABEL_96;
        }

LABEL_95:
        __int16 v50 = 0LL;
LABEL_96:
        free(v50);
      }
    }

    bzero(__str, 0x400uLL);
    snprintf(__str, 0x400uLL, "/private/var/%s/Library/Preferences", buffer);
    uid_t v51 = valuePtr;
    gid_t v180 = v185;
    uint64_t v52 = objc_autoreleasePoolPush();
    strcpy((char *)v193, "/private/var/mobile/Library/Preferences/.GlobalPreferences.plist");
    bzero(v194, 0x400uLL);
    snprintf(v194, 0x400uLL, "%s/.GlobalPreferences.plist", __str);
    int v53 = open((const char *)v193, 0);
    if (v53 == -1)
    {
      int v64 = *__error();
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v65 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
      {
        v188[0] = 0LL;
        LODWORD(v66) = sub_100053B4C(1);
        if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v66 = v66;
        }
        else {
          uint64_t v66 = v66 & 0xFFFFFFFE;
        }
        if ((_DWORD)v66)
        {
          uint64_t v67 = v52;
          uint64_t v68 = v65;
          unsigned int v69 = strerror(v64);
          *(_DWORD *)v195 = 136315394;
          *(void *)&v195[4] = v193;
          *(_WORD *)&v195[12] = 2080;
          v196 = v69;
          LODWORD(v17_Block_object_dispose(va, 8) = 22;
          unsigned int v70 = (char *)_os_log_send_and_compose_impl( v66,  v188,  0LL,  0LL,  &_mh_execute_header,  v68,  0LL,  "Failed to open Source Language  Pref file %s with error %s",  v195,  v178);

          if (v70) {
            sub_100053B7C(v70);
          }
          uint64_t v52 = v67;
        }

        else
        {
          unsigned int v70 = 0LL;
        }

        free(v70);
      }
    }

    else
    {
      int v54 = v53;
      bzero(v194, 0x400uLL);
      snprintf(v194, 0x400uLL, "%s/.GlobalPreferences.plist", __str);
      int v55 = open(v194, 514, 384LL);
      if (v55 != -1)
      {
        int v56 = v55;
        v179 = v52;
        vm_size_t v57 = vm_page_size;
        unsigned int v58 = malloc(vm_page_size);
        if (!v58)
        {
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          uint64_t v59 = (os_log_s *)(id)qword_1000DBA98;
          if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
          {
            *(void *)v195 = 0LL;
            unsigned int v60 = sub_100053B4C(1);
            if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v61 = v60;
            }
            else {
              uint64_t v61 = v60 & 0xFFFFFFFE;
            }
            if ((_DWORD)v61)
            {
              LOWORD(v188[0]) = 0;
              LODWORD(v17_Block_object_dispose(va, 8) = 2;
              CFTypeRef v62 = (const char *)_os_log_send_and_compose_impl( v61,  v195,  0LL,  0LL,  &_mh_execute_header,  v59,  0LL,  "Failed to get Buffer",  v188,  v178);
              unsigned int v63 = (char *)v62;
              if (v62) {
                sub_100053B7C(v62);
              }
            }

            else
            {
              unsigned int v63 = 0LL;
            }

            free(v63);
          }
        }

        for (off_t i = 0LL; ; i += v84)
        {
          ssize_t v83 = pread(v54, v58, v57, i);
          if (!v83) {
            break;
          }
          ssize_t v84 = v83;
          if (v83 == -1)
          {
            __error();
            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            int v87 = v179;
            v93 = (os_log_s *)(id)qword_1000DBA98;
            if (!os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_209;
            }
            v188[0] = 0LL;
            LODWORD(v94) = sub_100053B4C(1);
            if (os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v94 = v94;
            }
            else {
              uint64_t v94 = v94 & 0xFFFFFFFE;
            }
            if ((_DWORD)v94)
            {
              v95 = v93;
              v96 = __error();
              v97 = strerror(*v96);
              *(_DWORD *)v195 = 136315138;
              *(void *)&v195[4] = v97;
              uint64_t v98 = _os_log_send_and_compose_impl( v94,  v188,  0LL,  0LL,  &_mh_execute_header,  v95,  0LL,  "failed to read from source file with error %s",  v195);
LABEL_180:
              v102 = (char *)v98;

              if (v102) {
                sub_100053B7C(v102);
              }
LABEL_208:
              free(v102);
              goto LABEL_209;
            }

        sub_100053B7C((const char *)v45);
        goto LABEL_97;
      }
    }

    unsigned int v45 = 0LL;
    goto LABEL_97;
  }

  return v4;
}

  if (byte_1000DBD3B) {
    id v44 = 0;
  }
  else {
    id v44 = v16;
  }
  if (byte_1000DBD3B) {
    int v17 = 0;
  }
  v587 = v17;
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  unsigned int v45 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v45, OS_LOG_TYPE_DEFAULT))
  {
    value[0] = 0LL;
    uint64_t v46 = sub_100053B4C(1);
    uint64_t v0 = (uint64_t)v45;
    if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v47 = v46;
    }
    else {
      uint64_t v47 = v46 & 0xFFFFFFFE;
    }
    if ((_DWORD)v47)
    {
      *(_WORD *)err = 0;
      LODWORD(v580) = 2;
      p_vtable = _os_log_send_and_compose_impl( v47,  value,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "LOADING USER SESSIONS",  err,  v580);

      if (p_vtable) {
        sub_100053B7C((const char *)p_vtable);
      }
    }

    else
    {

      p_vtable = 0LL;
    }

    free((void *)p_vtable);
  }

  v586 = v44;

  unsigned int v48 = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
  statfs v2 = (uint64_t)&OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
  if (sub_10003FC5C(0))
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v49 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v49, OS_LOG_TYPE_DEFAULT))
    {
      value[0] = 0LL;
      __int16 v50 = sub_100053B4C(1);
      uint64_t v0 = (uint64_t)v49;
      if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
        uid_t v51 = v50;
      }
      else {
        uid_t v51 = v50 & 0xFFFFFFFE;
      }
      if ((_DWORD)v51)
      {
        *(_WORD *)err = 0;
        LODWORD(v580) = 2;
        p_vtable = _os_log_send_and_compose_impl( v51,  value,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "LOADED USER SESSIONS",  err,  v580);

        if (p_vtable) {
          sub_100053B7C((const char *)p_vtable);
        }
      }

      else
      {

        p_vtable = 0LL;
      }

      free((void *)p_vtable);
    }

    goto LABEL_141;
  }

  uint64_t v52 = [(id)qword_1000DBA68 splitUserVolumeEnabled];
  if ((v16 | v587 ^ 1) == 1 && v52 != 0)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    v503 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v503, OS_LOG_TYPE_DEFAULT))
    {
      value[0] = 0LL;
      uint64_t v0 = sub_100053B4C(1);
      v504 = os_log_type_enabled(v503, OS_LOG_TYPE_DEFAULT);
      v505 = 0LL;
      if (v504) {
        v506 = v0;
      }
      else {
        v506 = v0 & 0xFFFFFFFE;
      }
      if ((_DWORD)v506)
      {
        *(_WORD *)err = 0;
        LODWORD(v580) = 2;
        v507 = (const char *)_os_log_send_and_compose_impl( v506,  value,  0LL,  0LL,  &_mh_execute_header,  v503,  0LL,  "Erase Install or normal boot, no UserSessions to Load...",  err,  v580);
        v505 = 0LL;
        if (v507)
        {
          uint64_t v0 = (uint64_t)v507;
          sub_100053B7C(v507);
          v505 = (void *)v0;
        }
      }

      free(v505);
    }

    sleep(2u);
    sub_100019F7C("UserManagement early boot task Erase Install or normal boot, no UserSessions to Load...");
LABEL_1277:
    if (!v41) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    v493 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v493, OS_LOG_TYPE_DEFAULT))
    {
      value[0] = 0LL;
      uint64_t v0 = sub_100053B4C(1);
      v508 = os_log_type_enabled(v493, OS_LOG_TYPE_DEFAULT);
      v509 = 0LL;
      if (v508) {
        v510 = v0;
      }
      else {
        v510 = v0 & 0xFFFFFFFE;
      }
      if ((_DWORD)v510)
      {
        LOWORD(uuid[0]) = 0;
        LODWORD(v580) = 2;
        v511 = (const char *)_os_log_send_and_compose_impl( v510,  value,  0LL,  0LL,  &_mh_execute_header,  v493,  0LL,  "FAILED TO CREATE MARKER FILE TO INDICATE VOLUME MIGRATION IS NEEDED",  uuid,  v580);
        v509 = 0LL;
        if (v511)
        {
          uint64_t v0 = (uint64_t)v511;
          sub_100053B7C(v511);
          v509 = (void *)v0;
        }
      }

      free(v509);
    }

    v494 = sub_100019F7C("Creating classD marker file in /var/keybags in early boot task failed");
    goto LABEL_1288;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  int v54 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v54, OS_LOG_TYPE_DEFAULT))
  {
    value[0] = 0LL;
    int v55 = sub_100053B4C(1);
    uint64_t v0 = (uint64_t)v54;
    if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
      int v56 = v55;
    }
    else {
      int v56 = v55 & 0xFFFFFFFE;
    }
    if ((_DWORD)v56)
    {
      *(_WORD *)err = 0;
      LODWORD(v580) = 2;
      p_vtable = _os_log_send_and_compose_impl( v56,  value,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "NO USER SESSIONS",  err,  v580);

      if (p_vtable) {
        sub_100053B7C((const char *)p_vtable);
      }
    }

    else
    {

      p_vtable = 0LL;
    }

    free((void *)p_vtable);
  }

  dword_1000DBCE8 = 0;
  dword_1000DACB0 = 501;
  qword_1000DBCD8 = (uint64_t)sub_100084320();
  sub_10001AED4();
LABEL_141:
  if ([(id)qword_1000DBA68 splitUserVolumeEnabled]
    && dword_1000DBCE8 != 1
    && ((v15 ^ 1) & 1) == 0)
  {
    if (qword_1000DBAA0 == -1)
    {
LABEL_1232:
      v488 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v488, OS_LOG_TYPE_DEFAULT))
      {
        value[0] = 0LL;
        uint64_t v0 = sub_100053B4C(1);
        v489 = os_log_type_enabled(v488, OS_LOG_TYPE_DEFAULT);
        v490 = 0LL;
        if (v489) {
          v491 = v0;
        }
        else {
          v491 = v0 & 0xFFFFFFFE;
        }
        if ((_DWORD)v491)
        {
          *(_WORD *)err = 0;
          LODWORD(v580) = 2;
          v492 = (const char *)_os_log_send_and_compose_impl( v491,  value,  0LL,  0LL,  &_mh_execute_header,  v488,  0LL,  "Not shared iPad, missing User Volume cannot be located...",  err,  v580);
          v490 = 0LL;
          if (v492)
          {
            uint64_t v0 = (uint64_t)v492;
            sub_100053B7C(v492);
            v490 = (void *)v0;
          }
        }

        free(v490);
      }

      sleep(2u);
      sub_100019F7C("Not shared iPad, missing User Volume cannot be located...");
      goto LABEL_1241;
    }

LABEL_192:
            v102 = 0LL;
            goto LABEL_208;
          }

          ssize_t v85 = pwrite(v56, v58, v83, i);
          if (v85 == -1)
          {
            __error();
            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            int v87 = v179;
            v93 = (os_log_s *)(id)qword_1000DBA98;
            if (!os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_209;
            }
            v188[0] = 0LL;
            LODWORD(v99) = sub_100053B4C(1);
            if (os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v99 = v99;
            }
            else {
              uint64_t v99 = v99 & 0xFFFFFFFE;
            }
            if ((_DWORD)v99)
            {
              v95 = v93;
              v100 = __error();
              v101 = strerror(*v100);
              *(_DWORD *)v195 = 136315138;
              *(void *)&v195[4] = v101;
              uint64_t v98 = _os_log_send_and_compose_impl( v99,  v188,  0LL,  0LL,  &_mh_execute_header,  v95,  0LL,  "failed to write to dest file with error %s",  v195);
              goto LABEL_180;
            }

            goto LABEL_192;
          }

          v86 = (char *)v85;
          if (v84 != v85)
          {
            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            v93 = (os_log_s *)(id)qword_1000DBA98;
            if (os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT))
            {
              v188[0] = 0LL;
              unsigned int v103 = sub_100053B4C(1);
              if (os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v104 = v103;
              }
              else {
                uint64_t v104 = v103 & 0xFFFFFFFE;
              }
              if ((_DWORD)v104)
              {
                *(_DWORD *)v195 = 134218240;
                *(void *)&v195[4] = v84;
                *(_WORD *)&v195[12] = 2048;
                v196 = v86;
                LODWORD(v17_Block_object_dispose(va, 8) = 22;
                v105 = (const char *)_os_log_send_and_compose_impl( v104,  v188,  0LL,  0LL,  &_mh_execute_header,  v93,  0LL,  "failed to write %zu bytes to dest file,instead wrote only %zu bytes",  (size_t)v195,  (size_t)v178);
                v102 = (char *)v105;
                if (v105) {
                  sub_100053B7C(v105);
                }
              }

              else
              {
                v102 = 0LL;
              }

              int v87 = v179;
              goto LABEL_208;
            }

            int v87 = v179;
LABEL_209:

            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            v106 = (os_log_s *)(id)qword_1000DBA98;
            if (os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT))
            {
              v188[0] = 0LL;
              unsigned int v113 = sub_100053B4C(1);
              if (os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v114 = v113;
              }
              else {
                uint64_t v114 = v113 & 0xFFFFFFFE;
              }
              if ((_DWORD)v114)
              {
                *(_DWORD *)v195 = 136315394;
                *(void *)&v195[4] = v193;
                *(_WORD *)&v195[12] = 2080;
                v196 = v194;
                LODWORD(v17_Block_object_dispose(va, 8) = 22;
                v115 = (const char *)_os_log_send_and_compose_impl( v114,  v188,  0LL,  0LL,  &_mh_execute_header,  v106,  0LL,  "Failed to write complete file %s to %s",  v195,  v178);
                v116 = (char *)v115;
                if (v115) {
                  sub_100053B7C(v115);
                }
              }

              else
              {
                v116 = 0LL;
              }

              free(v116);
            }

            int v112 = 0;
            goto LABEL_221;
          }
        }

        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        int v87 = v179;
        int v88 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
        {
          v188[0] = 0LL;
          unsigned int v89 = sub_100053B4C(1);
          if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v90 = v89;
          }
          else {
            uint64_t v90 = v89 & 0xFFFFFFFE;
          }
          if ((_DWORD)v90)
          {
            *(_DWORD *)v195 = 67109376;
            *(_DWORD *)&v195[4] = v51;
            *(_WORD *)&v195[8] = 1024;
            *(_DWORD *)&v195[10] = v180;
            v91 = (const char *)_os_log_send_and_compose_impl( v90,  v188,  0LL,  0LL,  &_mh_execute_header,  v88,  0LL,  "setting uid:%d, gid:%d",  v195,  14);
            v92 = (char *)v91;
            if (v91) {
              sub_100053B7C(v91);
            }
          }

          else
          {
            v92 = 0LL;
          }

          free(v92);
        }

        if (!chown(v194, v51, v180))
        {
          int v112 = 1;
          goto LABEL_222;
        }

        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        v106 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT))
        {
          v188[0] = 0LL;
          LODWORD(v107) = sub_100053B4C(1);
          if (os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v107 = v107;
          }
          else {
            uint64_t v107 = v107 & 0xFFFFFFFE;
          }
          if ((_DWORD)v107)
          {
            v108 = v106;
            v109 = __error();
            v110 = strerror(*v109);
            *(_DWORD *)v195 = 136315394;
            *(void *)&v195[4] = v194;
            *(_WORD *)&v195[12] = 2080;
            v196 = v110;
            LODWORD(v17_Block_object_dispose(va, 8) = 22;
            v111 = (char *)_os_log_send_and_compose_impl( v107,  v188,  0LL,  0LL,  &_mh_execute_header,  v108,  0LL,  "failed to change ownership/group on: %s (%s)\n",  v195,  v178);

            if (v111) {
              sub_100053B7C(v111);
            }
          }

          else
          {
            v111 = 0LL;
          }

          free(v111);
        }

        int v112 = 1;
LABEL_221:

LABEL_222:
        close(v54);
        close(v56);
        objc_autoreleasePoolPop(v87);
        CFBooleanRef v23 = kCFBooleanTrue;
        if (v112)
        {
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          id v78 = (id)qword_1000DBA98;
          if (os_log_type_enabled((os_log_t)v78, OS_LOG_TYPE_DEFAULT))
          {
            *(void *)v194 = 0LL;
            unsigned int v117 = sub_100053B4C(1);
            id v78 = v78;
            if (os_log_type_enabled((os_log_t)v78, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v118 = v117;
            }
            else {
              uint64_t v118 = v117 & 0xFFFFFFFE;
            }
            if ((_DWORD)v118)
            {
              LOWORD(v193[0]) = 0;
              LODWORD(v17_Block_object_dispose(va, 8) = 2;
              uint64_t v81 = _os_log_send_and_compose_impl( v118,  v194,  0LL,  0LL,  &_mh_execute_header,  v78,  0LL,  "Successfully Copied Language Preferences to LoginUI",  v193,  v178);
LABEL_231:
              v119 = (char *)v81;

              if (v119) {
                sub_100053B7C(v119);
              }
              goto LABEL_234;
            }

            goto LABEL_233;
          }

          goto LABEL_235;
        }

LABEL_138:
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        id v78 = (id)qword_1000DBA98;
        if (os_log_type_enabled((os_log_t)v78, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)v194 = 0LL;
          unsigned int v79 = sub_100053B4C(1);
          id v78 = v78;
          if (os_log_type_enabled((os_log_t)v78, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v80 = v79;
          }
          else {
            uint64_t v80 = v79 & 0xFFFFFFFE;
          }
          if ((_DWORD)v80)
          {
            LOWORD(v193[0]) = 0;
            LODWORD(v17_Block_object_dispose(va, 8) = 2;
            uint64_t v81 = _os_log_send_and_compose_impl( v80,  v194,  0LL,  0LL,  &_mh_execute_header,  v78,  0LL,  "Failed to copy Language Preferences to LoginUI",  v193,  v178);
            goto LABEL_231;
          }

LABEL_233:
          v119 = 0LL;
LABEL_234:
          free(v119);
        }

LABEL_235:
        if ([(id)qword_1000DBA68 splitUserVolumeEnabled])
        {
          uint64_t v120 = sub_100019B18(qword_1000DBD40);
          v121 = (void *)objc_claimAutoreleasedReturnValue(v120);
          id v183 = 0LL;
          unsigned __int8 v122 = [v121 createIdentityWithUUID:v10 passcode:0 existingSession:501 existingSessionPasscode:0 error:&v183];
          id v123 = v183;

          if ((v122 & 1) != 0)
          {
            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            id v124 = (id)qword_1000DBA98;
            if (os_log_type_enabled((os_log_t)v124, OS_LOG_TYPE_DEFAULT))
            {
              *(void *)v194 = 0LL;
              unsigned int v125 = sub_100053B4C(1);
              v126 = (os_log_s *)v124;
              if (os_log_type_enabled(v126, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v127 = v125;
              }
              else {
                uint64_t v127 = v125 & 0xFFFFFFFE;
              }
              if ((_DWORD)v127)
              {
                LOWORD(v193[0]) = 0;
                LODWORD(v17_Block_object_dispose(va, 8) = 2;
                v128 = (char *)_os_log_send_and_compose_impl( v127,  v194,  0LL,  0LL,  &_mh_execute_header,  v126,  0LL,  "Created AKSIdentity for login window",  v193,  v178);

                if (v128) {
                  sub_100053B7C(v128);
                }
              }

              else
              {

                v128 = 0LL;
              }

              free(v128);
            }

            CFDictionarySetValue(v20, kUMUserSessionNeedsCryptoSetupKey, v23);
            goto LABEL_286;
          }

          CFRelease(v20);
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          id v136 = (id)qword_1000DBA98;
          if (os_log_type_enabled((os_log_t)v136, OS_LOG_TYPE_DEFAULT))
          {
            v193[0] = 0LL;
            LODWORD(v137) = sub_100053B4C(1);
            v138 = (os_log_s *)v136;
            if (os_log_type_enabled(v138, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v137 = v137;
            }
            else {
              uint64_t v137 = v137 & 0xFFFFFFFE;
            }
            if ((_DWORD)v137)
            {
              id v139 = [v123 code];
              *(_DWORD *)v194 = 134217984;
              *(void *)&v194[4] = v139;
              v140 = (char *)_os_log_send_and_compose_impl( v137,  v193,  0LL,  0LL,  &_mh_execute_header,  v138,  0LL,  "AKS Identity create failed:%ld",  v194);

              if (v140) {
                sub_100053B7C(v140);
              }
            }

            else
            {

              v140 = 0LL;
            }

            free(v140);
          }
        }

        else
        {
          int KeybagForUser = MKBUserSessionCreateKeybagForUser(0LL, valuePtr, 0LL, 0LL, 0LL);
          if (!KeybagForUser)
          {
            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            id v123 = (id)qword_1000DBA98;
            if (os_log_type_enabled((os_log_t)v123, OS_LOG_TYPE_DEFAULT))
            {
              *(void *)v194 = 0LL;
              unsigned int v141 = sub_100053B4C(1);
              id v123 = v123;
              if (os_log_type_enabled((os_log_t)v123, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v142 = v141;
              }
              else {
                uint64_t v142 = v141 & 0xFFFFFFFE;
              }
              if ((_DWORD)v142)
              {
                LOWORD(v193[0]) = 0;
                LODWORD(v17_Block_object_dispose(va, 8) = 2;
                v143 = (char *)_os_log_send_and_compose_impl( v142,  v194,  0LL,  0LL,  &_mh_execute_header,  v123,  0LL,  "Created keybag for login window",  v193,  v178);

                if (v143) {
                  sub_100053B7C(v143);
                }
              }

              else
              {

                v143 = 0LL;
              }

              free(v143);
            }

LABEL_286:
            CFDictionarySetValue(v20, @"MKBUserSessionFileSystemSet", v23);
            if (v182)
            {
              dword_1000DACB4 = -1;
              qword_1000DBD10 = v182;
              if (qword_1000DBAA0 != -1) {
                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
              }
              id v144 = (id)qword_1000DBA98;
              if (os_log_type_enabled((os_log_t)v144, OS_LOG_TYPE_DEFAULT))
              {
                v193[0] = 0LL;
                unsigned int v145 = sub_100053B4C(1);
                v146 = (os_log_s *)v144;
                if (os_log_type_enabled(v146, OS_LOG_TYPE_DEFAULT)) {
                  uint64_t v147 = v145;
                }
                else {
                  uint64_t v147 = v145 & 0xFFFFFFFE;
                }
                if ((_DWORD)v147)
                {
                  *(_DWORD *)v194 = 67109376;
                  *(_DWORD *)&v194[4] = v184;
                  *(_WORD *)&v194[8] = 2048;
                  *(void *)&v194[10] = v182;
                  LODWORD(v17_Block_object_dispose(va, 8) = 18;
                  v148 = (char *)_os_log_send_and_compose_impl( v147,  v193,  0LL,  0LL,  &_mh_execute_header,  v146,  0LL,  "Configured Number of Users:%d each with Size:%lld",  v194,  v178);

                  if (v148) {
                    sub_100053B7C(v148);
                  }
                }

                else
                {

                  v148 = 0LL;
                }

                free(v148);
              }

              *(void *)v194 = v182 << 20;
              CFNumberRef v154 = CFNumberCreate(0LL, kCFNumberLongLongType, v194);
              CFDictionarySetValue(v20, kUMUserSessionQuotaLimitKey, v154);
              if (v154) {
                CFRelease(v154);
              }
              CFNumberRef v155 = CFNumberCreate(0LL, kCFNumberLongLongType, v194);
              CFDictionarySetValue(v20, kUMUserSessionEachUserSize, v155);
              if (v155) {
                CFRelease(v155);
              }
              CFNumberRef v156 = CFNumberCreate(0LL, kCFNumberIntType, &v184);
              v157 = kUMUserSessionTotalUsers;
            }

            else
            {
              int v184 = sub_10001E6E0(v187, v193, (unint64_t *)v195, v188);
              dword_1000DACB4 = v184;
              qword_1000DBD10 = v193[0];
              if (qword_1000DBAA0 != -1) {
                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
              }
              id v149 = (id)qword_1000DBA98;
              if (os_log_type_enabled((os_log_t)v149, OS_LOG_TYPE_DEFAULT))
              {
                v189[0] = 0LL;
                unsigned int v150 = sub_100053B4C(1);
                v151 = (os_log_s *)v149;
                if (os_log_type_enabled(v151, OS_LOG_TYPE_DEFAULT)) {
                  uint64_t v152 = v150;
                }
                else {
                  uint64_t v152 = v150 & 0xFFFFFFFE;
                }
                if ((_DWORD)v152)
                {
                  *(_DWORD *)v194 = 67109376;
                  *(_DWORD *)&v194[4] = v184;
                  *(_WORD *)&v194[8] = 2048;
                  *(void *)&v194[10] = v193[0];
                  LODWORD(v17_Block_object_dispose(va, 8) = 18;
                  v153 = (char *)_os_log_send_and_compose_impl( v152,  v189,  0LL,  0LL,  &_mh_execute_header,  v151,  0LL,  "Configured Number of Users:%d each with Size:%lld",  v194,  v178);

                  if (v153) {
                    sub_100053B7C(v153);
                  }
                }

                else
                {

                  v153 = 0LL;
                }

                free(v153);
              }

              *(void *)v194 = 0LL;
              CFNumberRef v158 = CFNumberCreate(0LL, kCFNumberLongLongType, v194);
              CFDictionarySetValue(v20, kUMUserSessionQuotaLimitKey, v158);
              if (v158) {
                CFRelease(v158);
              }
              *(void *)v194 = 0LL;
              CFNumberRef v159 = CFNumberCreate(0LL, kCFNumberLongLongType, v194);
              CFDictionarySetValue(v20, kUMUserSessionQuotaSoftLimitKey, v159);
              if (v159) {
                CFRelease(v159);
              }
              *(void *)v194 = 0LL;
              CFNumberRef v160 = CFNumberCreate(0LL, kCFNumberLongLongType, v194);
              CFDictionarySetValue(v20, kUMUserSessionQuotaUsedKey, v160);
              if (v160) {
                CFRelease(v160);
              }
              CFNumberRef v161 = CFNumberCreate(0LL, kCFNumberIntType, &v187);
              CFDictionarySetValue(v20, kUMUserSessionReqTotalUsers, v161);
              if (v161) {
                CFRelease(v161);
              }
              CFNumberRef v162 = CFNumberCreate(0LL, kCFNumberIntType, &v184);
              CFDictionarySetValue(v20, kUMUserSessionTotalUsers, v162);
              if (v162) {
                CFRelease(v162);
              }
              CFNumberRef v163 = CFNumberCreate(0LL, kCFNumberLongLongType, v193);
              CFDictionarySetValue(v20, kUMUserSessionEachUserSize, v163);
              if (v163) {
                CFRelease(v163);
              }
              CFNumberRef v164 = CFNumberCreate(0LL, kCFNumberLongLongType, v195);
              CFDictionarySetValue(v20, kUMUserSessionTotalDataSize, v164);
              if (v164) {
                CFRelease(v164);
              }
              CFNumberRef v156 = CFNumberCreate(0LL, kCFNumberLongLongType, v188);
              v157 = kUMUserSessionSystemLoginSize;
            }

            CFDictionarySetValue(v20, v157, v156);
            if (v156) {
              CFRelease(v156);
            }
            sub_100021680(v20, 1);
            sub_100021704();
            sub_10001AED4();
            if (qword_1000DBAB0 != -1) {
              dispatch_once(&qword_1000DBAB0, &stru_1000CD548);
            }
            id v165 = (id)qword_1000DBAA8;
            if (os_log_type_enabled((os_log_t)v165, OS_LOG_TYPE_DEFAULT))
            {
              *(void *)v194 = 0LL;
              unsigned int v166 = sub_100053B4C(1);
              v167 = (os_log_s *)v165;
              if (os_log_type_enabled(v167, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v168 = v166;
              }
              else {
                uint64_t v168 = v166 & 0xFFFFFFFE;
              }
              if ((_DWORD)v168)
              {
                LODWORD(v189[0]) = 67109120;
                HIDWORD(v189[0]) = valuePtr;
                v169 = (char *)_os_log_send_and_compose_impl( v168,  v194,  0LL,  0LL,  &_mh_execute_header,  v167,  0LL,  "Created user %u",  v189);

                if (v169) {
                  sub_100053B7C(v169);
                }
              }

              else
              {

                v169 = 0LL;
              }

              free(v169);
            }

            if (_SecSystemKeychainTransfer(0LL))
            {
              if (qword_1000DBAA0 != -1) {
                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
              }
              v170 = (os_log_s *)(id)qword_1000DBA98;
              if (!os_log_type_enabled(v170, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_363;
              }
              *(void *)v194 = 0LL;
              unsigned int v171 = sub_100053B4C(1);
              if (os_log_type_enabled(v170, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v172 = v171;
              }
              else {
                uint64_t v172 = v171 & 0xFFFFFFFE;
              }
              if ((_DWORD)v172)
              {
                LOWORD(v189[0]) = 0;
                LODWORD(v17_Block_object_dispose(va, 8) = 2;
                v173 = (const char *)_os_log_send_and_compose_impl( v172,  v194,  0LL,  0LL,  &_mh_execute_header,  v170,  0LL,  "_SecSystemKeychainTransfer succeeded",  v189,  v178);
                goto LABEL_359;
              }
            }

            else
            {
              if (qword_1000DBAA0 != -1) {
                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
              }
              v170 = (os_log_s *)(id)qword_1000DBA98;
              if (!os_log_type_enabled(v170, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_363;
              }
              *(void *)v194 = 0LL;
              unsigned int v174 = sub_100053B4C(1);
              if (os_log_type_enabled(v170, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v175 = v174;
              }
              else {
                uint64_t v175 = v174 & 0xFFFFFFFE;
              }
              if ((_DWORD)v175)
              {
                LOWORD(v189[0]) = 0;
                LODWORD(v17_Block_object_dispose(va, 8) = 2;
                v173 = (const char *)_os_log_send_and_compose_impl( v175,  v194,  0LL,  0LL,  &_mh_execute_header,  v170,  0LL,  "_SecSystemKeychainTransfer failed",  v189,  v178);
LABEL_359:
                v176 = (char *)v173;
                if (v173) {
                  sub_100053B7C(v173);
                }
                goto LABEL_362;
              }
            }

            v176 = 0LL;
LABEL_362:
            free(v176);
LABEL_363:

            goto LABEL_364;
          }

          int v130 = KeybagForUser;
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          id v131 = (id)qword_1000DBA98;
          if (os_log_type_enabled((os_log_t)v131, OS_LOG_TYPE_DEFAULT))
          {
            *(void *)v194 = 0LL;
            unsigned int v132 = sub_100053B4C(1);
            v133 = (os_log_s *)v131;
            if (os_log_type_enabled(v133, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v134 = v132;
            }
            else {
              uint64_t v134 = v132 & 0xFFFFFFFE;
            }
            if ((_DWORD)v134)
            {
              LODWORD(v193[0]) = 67109120;
              HIDWORD(v193[0]) = v130;
              v135 = (char *)_os_log_send_and_compose_impl( v134,  v194,  0LL,  0LL,  &_mh_execute_header,  v133,  0LL,  "failed to create keybag for login window: %d",  v193);

              if (v135) {
                sub_100053B7C(v135);
              }
            }

            else
            {

              v135 = 0LL;
            }

            free(v135);
          }

          CFRelease(v20);
        }

LABEL_283:
        unsigned __int8 v20 = 0LL;
LABEL_364:

        return v20;
      }

      int v71 = *__error();
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      CFBooleanRef v23 = kCFBooleanTrue;
      unsigned int v72 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
      {
        v188[0] = 0LL;
        LODWORD(v73) = sub_100053B4C(1);
        if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v73 = v73;
        }
        else {
          uint64_t v73 = v73 & 0xFFFFFFFE;
        }
        if ((_DWORD)v73)
        {
          v181 = v10;
          v74 = v52;
          uint64_t v75 = v72;
          unsigned int v76 = strerror(v71);
          *(_DWORD *)v195 = 136315394;
          *(void *)&v195[4] = v194;
          *(_WORD *)&v195[12] = 2080;
          v196 = v76;
          LODWORD(v17_Block_object_dispose(va, 8) = 22;
          uint64_t v77 = (char *)_os_log_send_and_compose_impl( v73,  v188,  0LL,  0LL,  &_mh_execute_header,  v75,  0LL,  "Failed to create Destination Language Pref file %s with error %s",  v195,  v178);

          if (v77) {
            sub_100053B7C(v77);
          }
          uint64_t v52 = v74;
          uint64_t v10 = v181;
        }

        else
        {
          uint64_t v77 = 0LL;
        }

        free(v77);
      }

      close(v54);
    }

    objc_autoreleasePoolPop(v52);
    goto LABEL_138;
  }

  return v20;
}

uint64_t sub_100020F1C(const char *a1, char *a2, gid_t a3)
{
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v6 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t v47 = 0LL;
    unsigned int v7 = sub_100053B4C(1);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = v7 & 0xFFFFFFFE;
    }
    if ((_DWORD)v8)
    {
      v53.st_dev = 136315138;
      *(void *)&v53.st_mode = a1;
      int v9 = (const char *)_os_log_send_and_compose_impl( v8,  v47,  0LL,  0LL,  &_mh_execute_header,  v6,  0LL,  "CreateFileLayout: pathname:%s",  (const char *)&v53);
      uint64_t v10 = (char *)v9;
      if (v9) {
        sub_100053B7C(v9);
      }
    }

    else
    {
      uint64_t v10 = 0LL;
    }

    free(v10);
  }

  if (!stat(a1, &v53)) {
    goto LABEL_47;
  }
  int v11 = *__error();
  if (v11 != 2)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    int v17 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_77;
    }
    v52[0] = 0LL;
    LODWORD(v1_Block_object_dispose(va, 8) = sub_100053B4C(1);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v18 = v18;
    }
    else {
      uint64_t v18 = v18 & 0xFFFFFFFE;
    }
    if ((_DWORD)v18)
    {
      uint64_t v19 = v17;
      unsigned __int8 v20 = strerror(v11);
      *(_DWORD *)uint64_t v47 = 136315394;
      *(void *)&v47[4] = a1;
      __int16 v48 = 2080;
      *(void *)uint64_t v49 = v20;
      uint64_t v21 = _os_log_send_and_compose_impl( v18,  v52,  0LL,  0LL,  &_mh_execute_header,  v19,  0LL,  "Failed to stat file path %s, with error %s ",  v47,  22);
      goto LABEL_31;
    }

LABEL_75:
    CFNumberRef v22 = 0LL;
LABEL_76:
    free(v22);
    goto LABEL_77;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v12 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    v52[0] = 0LL;
    unsigned int v13 = sub_100053B4C(1);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v14 = v13;
    }
    else {
      uint64_t v14 = v13 & 0xFFFFFFFE;
    }
    if ((_DWORD)v14)
    {
      *(_DWORD *)uint64_t v47 = 136315138;
      *(void *)&v47[4] = a1;
      id v15 = (const char *)_os_log_send_and_compose_impl( v14,  v52,  0LL,  0LL,  &_mh_execute_header,  v12,  0LL,  "pathname %s does not exist, creating",  v47);
      unsigned int v16 = (char *)v15;
      if (v15) {
        sub_100053B7C(v15);
      }
    }

    else
    {
      unsigned int v16 = 0LL;
    }

    free(v16);
  }

  if ((mkdir(a1, 0x1C0u) & 0x80000000) == 0 || (int v23 = *__error(), v23 == 17))
  {
    if (chown(a1, (uid_t)a2, a3))
    {
      int v24 = *__error();
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      CFStringRef v25 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        v52[0] = 0LL;
        LODWORD(v26) = sub_100053B4C(1);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v26 = v26;
        }
        else {
          uint64_t v26 = v26 & 0xFFFFFFFE;
        }
        if ((_DWORD)v26)
        {
          unint64_t v27 = v25;
          id v28 = strerror(v24);
          *(_DWORD *)uint64_t v47 = 136315906;
          *(void *)&v47[4] = a1;
          __int16 v48 = 1024;
          *(_DWORD *)uint64_t v49 = (_DWORD)a2;
          *(_WORD *)&v49[4] = 1024;
          *(_DWORD *)&v49[6] = a3;
          __int16 v50 = 2080;
          uid_t v51 = v28;
          CFStringRef v29 = (char *)_os_log_send_and_compose_impl( v26,  v52,  0LL,  0LL,  &_mh_execute_header,  v27,  0LL,  "Failed to chown path %s for uid=%d, gid=%d with error %s ",  v47,  34,  v45,  v46);

          if (v29) {
            sub_100053B7C(v29);
          }
        }

        else
        {
          CFStringRef v29 = 0LL;
        }

        free(v29);
      }

      rmdir(a1);
      return 0LL;
    }

          unsigned int v36 = 0LL;
LABEL_76:
          free(v36);
          goto LABEL_77;
        }
      }

      else
      {
        uint64_t v26 = 0LL;
        if (CFArrayGetCount(a1) < 1) {
          goto LABEL_78;
        }
      }

      CFDictionarySetValue(v13, kUMUserPersonaBundleIDsKey, a1);
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      unsigned int v32 = (id)qword_1000DBA98;
      if (!os_log_type_enabled((os_log_t)v32, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_77;
      }
      v43[0] = 0LL;
      unsigned int v33 = sub_100053B4C(1);
      if (os_log_type_enabled((os_log_t)v32, OS_LOG_TYPE_DEFAULT)) {
        CFNumberRef v34 = v33;
      }
      else {
        CFNumberRef v34 = v33 & 0xFFFFFFFE;
      }
      if ((_DWORD)v34)
      {
        *(_DWORD *)id v44 = 138412290;
        *(void *)&v44[4] = a1;
        LODWORD(v42) = 12;
        unsigned int v35 = (const char *)_os_log_send_and_compose_impl( v34,  v43,  0LL,  0LL,  &_mh_execute_header,  v32,  0LL,  "Universal BundleIDs Set with %@, saving to disk",  v44,  v42,  v43[0]);
        goto LABEL_64;
      }

      goto LABEL_75;
    }
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v19 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)id v44 = 0LL;
    unsigned __int8 v20 = sub_100053B4C(1);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v21 = v20;
    }
    else {
      uint64_t v21 = v20 & 0xFFFFFFFE;
    }
    if ((_DWORD)v21)
    {
      LOWORD(v43[0]) = 0;
      LODWORD(v42) = 2;
      CFNumberRef v22 = (const char *)_os_log_send_and_compose_impl( v21,  v44,  0LL,  0LL,  &_mh_execute_header,  v19,  0LL,  "FOUND NO Universal PERSONA",  v43,  v42);
      int v23 = (char *)v22;
      if (v22) {
        sub_100053B7C(v22);
      }
    }

    else
    {
      int v23 = 0LL;
    }

    free(v23);
  }

  int v24 = 2LL;
LABEL_84:

  return v24;
}

LABEL_47:
    sub_10001DB9C((uint64_t)a1, a2, a3);
    unsigned int v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a1));
    uint64_t v31 = sub_100019B18(qword_1000DBD40);
    unsigned int v32 = (void *)objc_claimAutoreleasedReturnValue(v31);
    uint64_t v46 = 0LL;
    unsigned int v33 = [v32 bootstrapVolumeWithMountPoint:v30 user:a2 error:&v46];
    CFNumberRef v34 = v46;

    if (v33)
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      unsigned int v35 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_80;
      }
      *(void *)uint64_t v47 = 0LL;
      unsigned int v36 = sub_100053B4C(1);
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v37 = v36;
      }
      else {
        uint64_t v37 = v36 & 0xFFFFFFFE;
      }
      if ((_DWORD)v37)
      {
        LOWORD(v52[0]) = 0;
        CFStringRef v38 = (void *)_os_log_send_and_compose_impl( v37,  v47,  0LL,  0LL,  &_mh_execute_header,  v35,  0LL,  "AKS Bootstrap fs succeeded",  v52,  2);
        if (!v38) {
          goto LABEL_79;
        }
        goto LABEL_66;
      }
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      unsigned int v35 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_80;
      }
      *(void *)uint64_t v47 = 0LL;
      LODWORD(v39) = sub_100053B4C(1);
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v39 = v39;
      }
      else {
        uint64_t v39 = v39 & 0xFFFFFFFE;
      }
      if ((_DWORD)v39)
      {
        unsigned int v40 = v35;
        unsigned int v41 = [v34 code];
        LODWORD(v52[0]) = 67109120;
        HIDWORD(v52[0]) = v41;
        CFStringRef v38 = (void *)_os_log_send_and_compose_impl( v39,  v47,  0LL,  0LL,  &_mh_execute_header,  v40,  0LL,  "AKS Bootstrap fs failed with error %d, ignoring error",  v52);

        if (!v38)
        {
LABEL_79:
          free(v38);
LABEL_80:

          return 1LL;
        }

    uint64_t v19 = 0LL;
LABEL_48:
    free(v19);
LABEL_49:

    return 0LL;
  }

  if (CFDictionaryContainsKey(a1, kUMUserSessionAlternateDSIDKey))
  {
    unsigned int v5 = (void *)sub_100083DF4(a1, kUMUserSessionAlternateDSIDKey);
    if (v5)
    {
      uint64_t v6 = sub_100054BE8(qword_1000DBA70, v5);
      return (CFTypeRef)objc_claimAutoreleasedReturnValue(v6);
    }

    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v7 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_49;
    }
    uint64_t v21 = 0LL;
    unsigned int v13 = sub_100053B4C(1);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v14 = v13;
    }
    else {
      uint64_t v14 = v13 & 0xFFFFFFFE;
    }
    if (!(_DWORD)v14) {
      goto LABEL_47;
    }
LABEL_25:
    LOWORD(v20) = 0;
    uint64_t v10 = (const char *)_os_log_send_and_compose_impl( v14,  &v21,  0LL,  0LL,  &_mh_execute_header,  v7,  0LL,  "Error: USESESSION_SET_UUID was set but no UserSessionUUID was given!",  &v20,  2,  v20);
    goto LABEL_45;
  }

  if (CFDictionaryContainsKey(a1, kUMUserSessionUUIDKey))
  {
    int v11 = (void *)sub_100083DF4(a1, kUMUserSessionUUIDKey);
    if (v11)
    {
      uint64_t v12 = sub_100054D5C(qword_1000DBA70, v11);
      return (CFTypeRef)objc_claimAutoreleasedReturnValue(v12);
    }

    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v7 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_49;
    }
    uint64_t v21 = 0LL;
    unsigned int v16 = sub_100053B4C(1);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v14 = v16;
    }
    else {
      uint64_t v14 = v16 & 0xFFFFFFFE;
    }
    if (!(_DWORD)v14) {
      goto LABEL_47;
    }
    goto LABEL_25;
  }

  if (CFDictionaryContainsKey(a1, kUMUserSessionNameKey))
  {
    id v15 = (const __CFString *)sub_100083DF4(a1, kUMUserSessionNameKey);
    if (v15) {
      return sub_10001AA74(v15);
    }
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v7 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_49;
    }
    uint64_t v21 = 0LL;
    int v17 = sub_100053B4C(1);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v18 = v17;
    }
    else {
      uint64_t v18 = v17 & 0xFFFFFFFE;
    }
    if (!(_DWORD)v18) {
      goto LABEL_47;
    }
    LOWORD(v20) = 0;
    uint64_t v10 = (const char *)_os_log_send_and_compose_impl( v18,  &v21,  0LL,  0LL,  &_mh_execute_header,  v7,  0LL,  "Error: USESSION_SET_NAME was set but no UserSessionName was given!",  &v20,  2,  v20);
LABEL_45:
    uint64_t v19 = (char *)v10;
    if (v10) {
      sub_100053B7C(v10);
    }
    goto LABEL_48;
  }

  return 0LL;
}

LABEL_66:
        sub_100053B7C((const char *)v38);
        goto LABEL_79;
      }
    }

    CFStringRef v38 = 0LL;
    goto LABEL_79;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  int v17 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    v52[0] = 0LL;
    LODWORD(v42) = sub_100053B4C(1);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v42 = v42;
    }
    else {
      uint64_t v42 = v42 & 0xFFFFFFFE;
    }
    if ((_DWORD)v42)
    {
      uint64_t v19 = v17;
      uint64_t v43 = strerror(v23);
      *(_DWORD *)uint64_t v47 = 136315394;
      *(void *)&v47[4] = a1;
      __int16 v48 = 2080;
      *(void *)uint64_t v49 = v43;
      uint64_t v21 = _os_log_send_and_compose_impl( v42,  v52,  0LL,  0LL,  &_mh_execute_header,  v19,  0LL,  "Failed to created file path %s, with error %s ",  v47,  22);
LABEL_31:
      CFNumberRef v22 = (void *)v21;

      if (v22) {
        sub_100053B7C((const char *)v22);
      }
      goto LABEL_76;
    }

    goto LABEL_75;
  }

LABEL_77:
  return 0LL;
}

      uint64_t result = 0LL;
      int v17 = a1 + 8;
LABEL_97:
      *a3 = v17;
LABEL_98:
      uint64_t v10 = 4LL;
      goto LABEL_99;
    }

    uint64_t v18 = *a1;
    if (*a1 <= 8)
    {
      if (v18 == 1)
      {
        int v9 = a1 + 11;
      }

      else
      {
        if (v18 != 3) {
          return result;
        }
        int v9 = a1 + 26;
      }

      goto LABEL_68;
    }

    if (v18 == 9)
    {
      int v9 = a1 + 10;
      goto LABEL_68;
    }

    if (v18 != 18) {
      return result;
    }
    goto LABEL_15;
  }

  switch(a2)
  {
    case 1:
      uint64_t result = 0LL;
      *a3 = a1 + 4;
      uint64_t v10 = 8LL;
      goto LABEL_99;
    case 2:
      uint64_t result = 0LL;
      int v17 = a1 + 6;
      goto LABEL_97;
    case 3:
      uint64_t result = 0LL;
      *a3 = a1;
      goto LABEL_98;
    case 4:
      uint64_t result = 0LL;
      int v17 = a1 + 1;
      goto LABEL_97;
    case 5:
      uint64_t result = 0LL;
      int v17 = a1 + 3;
      goto LABEL_97;
    default:
      return result;
  }

  return result;
}

void sub_100021680(void *value, int a2)
{
  id v4 = (__CFArray *)qword_1000DBCD8;
  if (!qword_1000DBCD8)
  {
    id v4 = sub_100084320();
    qword_1000DBCD8 = (uint64_t)v4;
  }

  CFArrayAppendValue(v4, value);
  qword_1000DBCE0 = CFArrayGetCount((CFArrayRef)qword_1000DBCD8);
  if (a2 == 1)
  {
    unsigned int v5 = sub_100036430((const __CFDictionary *)value);
    if (v5)
    {
      uint64_t v6 = v5;
      sub_100036874((uint64_t)v5);
      CFRelease(v6);
    }
  }

void sub_100021704()
{
  if (qword_1000DBCD8)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v0 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = 0LL;
      unsigned int v1 = sub_100053B4C(1);
      if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v2 = v1;
      }
      else {
        uint64_t v2 = v1 & 0xFFFFFFFE;
      }
      if ((_DWORD)v2)
      {
        LOWORD(v15[0]) = 0;
        int v3 = (const char *)_os_log_send_and_compose_impl( v2,  &v16,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "PRINTING ALL USERSESSION",  v15,  2);
        id v4 = (char *)v3;
        if (v3) {
          sub_100053B7C(v3);
        }
      }

      else
      {
        id v4 = 0LL;
      }

      free(v4);
    }

    if (CFArrayGetCount((CFArrayRef)qword_1000DBCD8) >= 1)
    {
      CFIndex v5 = 0LL;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)qword_1000DBCD8, v5);
        if (ValueAtIndex)
        {
          unsigned int v7 = ValueAtIndex;
          CFTypeID v8 = CFGetTypeID(ValueAtIndex);
          if (v8 == CFDictionaryGetTypeID())
          {
            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            int v9 = (os_log_s *)(id)qword_1000DBA98;
            if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
            {
              v15[0] = 0LL;
              unsigned int v10 = sub_100053B4C(1);
              if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v11 = v10;
              }
              else {
                uint64_t v11 = v10 & 0xFFFFFFFE;
              }
              if ((_DWORD)v11)
              {
                LODWORD(v16) = 67109378;
                HIDWORD(v16) = v5;
                __int16 v17 = 2112;
                uint64_t v18 = v7;
                LODWORD(v14) = 18;
                uint64_t v12 = (const char *)_os_log_send_and_compose_impl( v11,  v15,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "%d UserSession is %@",  &v16,  v14);
                unsigned int v13 = (char *)v12;
                if (v12) {
                  sub_100053B7C(v12);
                }
              }

              else
              {
                unsigned int v13 = 0LL;
              }

              free(v13);
            }
          }
        }

        ++v5;
      }

      while (CFArrayGetCount((CFArrayRef)qword_1000DBCD8) > v5);
    }
  }

os_log_s *sub_100021990(const __CFDictionary *a1)
{
  unsigned int v1 = (void *)sub_100021AC4(a1);
  uint64_t v2 = v1;
  if (v1)
  {
    int v3 = (os_log_s *)objc_claimAutoreleasedReturnValue([v1 objectForKeyedSubscript:kUMUserSessionShortNameKey]);
    id v4 = v3;
  }

  else
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    int v3 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = 0LL;
      unsigned int v5 = sub_100053B4C(1);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v6 = v5;
      }
      else {
        uint64_t v6 = v5 & 0xFFFFFFFE;
      }
      if ((_DWORD)v6)
      {
        __int16 v10 = 0;
        unsigned int v7 = (const char *)_os_log_send_and_compose_impl( v6,  &v11,  0LL,  0LL,  &_mh_execute_header,  v3,  0LL,  "Could not find session dictionary for user",  &v10,  2);
        CFTypeID v8 = (char *)v7;
        if (v7) {
          sub_100053B7C(v7);
        }
      }

      else
      {
        CFTypeID v8 = 0LL;
      }

      free(v8);
    }

    id v4 = 0LL;
  }

  return v4;
}

CFTypeRef sub_100021AC4(const __CFDictionary *a1)
{
  if (CFDictionaryContainsKey(a1, kUMUserSessionIDKey))
  {
    int v2 = sub_100083C6C(a1, kUMUserSessionIDKey);
    if (v2 != -1)
    {
      id v3 = sub_100054ED0(qword_1000DBA70, v2);
      return (CFTypeRef)objc_claimAutoreleasedReturnValue(v3);
    }

    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v7 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_49;
    }
    uint64_t v21 = 0LL;
    unsigned int v8 = sub_100053B4C(1);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v9 = v8;
    }
    else {
      uint64_t v9 = v8 & 0xFFFFFFFE;
    }
    if ((_DWORD)v9)
    {
      LOWORD(v20) = 0;
      __int16 v10 = (const char *)_os_log_send_and_compose_impl( v9,  &v21,  0LL,  0LL,  &_mh_execute_header,  v7,  0LL,  "Error: USESSION_SET_UID was set but no UserSessionID was given!",  &v20,  2,  v20);
      goto LABEL_45;
    }

uint64_t sub_100021E7C(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  if (a4) {
    *a4 = 45;
  }
  return 0LL;
}

uint64_t sub_100021E90(const __CFString *a1, _DWORD *a2)
{
  int v141 = 0;
  if (![(id)qword_1000DBA68 splitUserVolumeEnabled])
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v9 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v139 = 0LL;
      unsigned int v10 = sub_100053B4C(1);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = v10 & 0xFFFFFFFE;
      }
      if ((_DWORD)v11)
      {
        LOWORD(v142) = 0;
        id v12 = (const char *)_os_log_send_and_compose_impl( v11,  &v139,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "Not in Restore mode, returning success",  &v142,  2);
        goto LABEL_19;
      }

LABEL_149:
      unsigned int v13 = 0LL;
LABEL_150:
      free(v13);
    }

LABEL_151:
    int v141 = 0;
    if (!a2) {
      return 1LL;
    }
LABEL_152:
    *a2 = v141;
    return 1LL;
  }

  char v140 = 1;
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v4 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v139 = 0LL;
    unsigned int v5 = sub_100053B4C(1);
    id v6 = (os_log_s *)v4;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v7 = v5;
    }
    else {
      uint64_t v7 = v5 & 0xFFFFFFFE;
    }
    if ((_DWORD)v7)
    {
      LOWORD(v142) = 0;
      unsigned int v8 = (char *)_os_log_send_and_compose_impl( v7,  &v139,  0LL,  0LL,  &_mh_execute_header,  v6,  0LL,  "In Restore Mode, checking SDV or marker file for migration",  &v142,  2);

      if (v8) {
        sub_100053B7C(v8);
      }
    }

    else
    {

      unsigned int v8 = 0LL;
    }

    free(v8);
  }

  int v14 = sub_10007D3E0(&v141, &v140);
  if (v14)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v15 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v139 = 0LL;
      unsigned int v16 = sub_100053B4C(1);
      id v15 = v15;
      if (os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v17 = v16;
      }
      else {
        uint64_t v17 = v16 & 0xFFFFFFFE;
      }
      if ((_DWORD)v17)
      {
        LOWORD(v142) = 0;
        LODWORD(v136) = 2;
        uint64_t v18 = _os_log_send_and_compose_impl( v17,  &v139,  0LL,  0LL,  &_mh_execute_header,  v15,  0LL,  "SDV needs Migration, Starting volume Migration steps",  &v142,  v136);
        goto LABEL_41;
      }

      goto LABEL_43;
    }

    goto LABEL_45;
  }

  if (!sub_100023714())
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v9 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v139 = 0LL;
      unsigned int v65 = sub_100053B4C(1);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v66 = v65;
      }
      else {
        uint64_t v66 = v65 & 0xFFFFFFFE;
      }
      if ((_DWORD)v66)
      {
        LOWORD(v142) = 0;
        LODWORD(v136) = 2;
        id v12 = (const char *)_os_log_send_and_compose_impl( v66,  &v139,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "System Data Volume does not need migration, returning success.",  &v142,  v136);
LABEL_19:
        unsigned int v13 = (char *)v12;
        if (v12) {
          sub_100053B7C(v12);
        }
        goto LABEL_150;
      }

      goto LABEL_149;
    }

    goto LABEL_151;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v15 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v139 = 0LL;
    unsigned int v19 = sub_100053B4C(1);
    id v15 = v15;
    if (os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v20 = v19;
    }
    else {
      uint64_t v20 = v19 & 0xFFFFFFFE;
    }
    if ((_DWORD)v20)
    {
      LOWORD(v142) = 0;
      LODWORD(v136) = 2;
      uint64_t v18 = _os_log_send_and_compose_impl( v20,  &v139,  0LL,  0LL,  &_mh_execute_header,  v15,  0LL,  "Marker File set for Migration progress, Starting volume Migration steps",  &v142,  v136);
LABEL_41:
      uint64_t v21 = (char *)v18;

      if (v21) {
        sub_100053B7C(v21);
      }
      goto LABEL_44;
    }

LABEL_43:
    uint64_t v21 = 0LL;
LABEL_44:
    free(v21);
  }

    unsigned int v10 = 0LL;
    goto LABEL_44;
  }

  if (qword_1000DBBD8 != -1) {
    dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
  }
  int v2 = (os_log_s *)(id)qword_1000DBBD0;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v22[0] = 0LL;
    id v3 = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      id v4 = v3;
    }
    else {
      id v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      *(_DWORD *)id v23 = 136315138;
      *(void *)&v23[4] = v24;
      unsigned int v5 = (const char *)_os_log_send_and_compose_impl( v4,  v22,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "Transcribing SDV with disknode:%s",  v23);
      id v6 = (char *)v5;
      if (v5) {
        sub_100053B7C(v5);
      }
    }

    else
    {
      id v6 = 0LL;
    }

    free(v6);
  }

  uint64_t v11 = APFSVolumeTranscribePFK(v24);
  if (v11)
  {
    id v12 = v11;
    if (a1) {
      *a1 = v11;
    }
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    uint64_t v7 = (os_log_s *)(id)qword_1000DBBD0;
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_45;
    }
    v22[0] = 0LL;
    LODWORD(v13) = sub_100053B4C(1);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      unsigned int v13 = v13;
    }
    else {
      unsigned int v13 = v13 & 0xFFFFFFFE;
    }
    if ((_DWORD)v13)
    {
      int v14 = v7;
      id v15 = strerror(v12);
      *(_DWORD *)id v23 = 136315138;
      *(void *)&v23[4] = v15;
      unsigned int v10 = (void *)_os_log_send_and_compose_impl( v13,  v22,  0LL,  0LL,  &_mh_execute_header,  v14,  0LL,  "APFSVolumeTranscribePFK failed with error:%s",  v23);

      if (!v10)
      {
LABEL_44:
        free(v10);
LABEL_45:
        uint64_t v20 = 0LL;
        goto LABEL_46;
      }

LABEL_45:
  CFNumberRef v22 = (os_log_s *)sub_10008450C();
  if (((_DWORD)v22 - 1) > 4)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v23 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v23, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v139 = 0LL;
      unsigned int v27 = sub_100053B4C(1);
      id v23 = v23;
      if (os_log_type_enabled((os_log_t)v23, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v28 = v27;
      }
      else {
        uint64_t v28 = v27 & 0xFFFFFFFE;
      }
      if ((_DWORD)v28)
      {
        LOWORD(v142) = 0;
        uint64_t v26 = _os_log_send_and_compose_impl( v28,  &v139,  0LL,  0LL,  &_mh_execute_header,  v23,  0LL,  "Volume Migration Debug Not set");
LABEL_62:
        CFStringRef v29 = (char *)v26;

        if (v29) {
          sub_100053B7C(v29);
        }
        goto LABEL_65;
      }

    id v30 = 0LL;
LABEL_46:
    free(v30);
LABEL_47:

    unsigned int v31 = 0LL;
    if (a3) {
      *a3 = (id)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  22LL,  0LL));
    }
    goto LABEL_105;
  }

  uint64_t v11 = sub_100084F14(v5, (uint64_t)@"UserPersonaID", 0LL);
  sub_100056838((uint64_t)v6, v11);
  id v12 = sub_1000850A0(v5, (uint64_t)@"UserPersonaUniqueString");
  unsigned int v13 = (char *)objc_claimAutoreleasedReturnValue(v12);
  sub_10007420C(v6, v13);

  id v15 = sub_1000741F8(v6, v14);
  unsigned int v16 = (void *)objc_claimAutoreleasedReturnValue(v15);

  if (!v16)
  {
    if (qword_1000DBB68 != -1) {
      dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
    }
    uint64_t v20 = (os_log_s *)(id)qword_1000DBB60;
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_47;
    }
    uint64_t v63 = 0LL;
    uint64_t v28 = sub_100053B4C(1);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
      CFStringRef v29 = v28;
    }
    else {
      CFStringRef v29 = v28 & 0xFFFFFFFE;
    }
    if ((_DWORD)v29)
    {
      LOWORD(v66) = 0;
      id v23 = (const char *)_os_log_send_and_compose_impl( v29,  &v63,  0LL,  0LL,  &_mh_execute_header,  v20,  0LL,  "Failed to load persona into kernel: Missing kernel name",  &v66,  2);
LABEL_43:
      id v30 = (char *)v23;
      if (v23) {
        sub_100053B7C(v23);
      }
      goto LABEL_46;
    }

    goto LABEL_45;
  }

  uint64_t v17 = sub_1000850A0(v5, (uint64_t)@"UserPersonaUserODUUID");
  uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
  unsigned int v19 = v18;
  if (v18)
  {
    if ([v18 isEqualToString:@"FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF"])
    {
      sub_1000642F8((uint64_t)v6, -1);
    }

    else
    {
      WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
      uint64_t v33 = sub_10005503C((uint64_t)WeakRetained, v19);
      sub_1000642F8((uint64_t)v6, v33);
    }
  }

  if ((v8 & 0xFFFFFFFB) == 2)
  {
    CFNumberRef v34 = sub_1000850A0(v5, (uint64_t)@"MKBUserSessionHomeDir");
    id v35 = objc_claimAutoreleasedReturnValue(v34);
    if (!v35)
    {
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      uint64_t v44 = (os_log_s *)(id)qword_1000DBB60;
      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v63 = 0LL;
        uint64_t v45 = sub_100053B4C(1);
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT)) {
          unsigned int v46 = v45;
        }
        else {
          unsigned int v46 = v45 & 0xFFFFFFFE;
        }
        if ((_DWORD)v46)
        {
          LOWORD(v66) = 0;
          uint64_t v47 = (const char *)_os_log_send_and_compose_impl( v46,  &v63,  0LL,  0LL,  &_mh_execute_header,  v44,  0LL,  "Failed to load persona into kernel: Missing path for data-separated persona",  &v66,  2);
          __int16 v48 = (char *)v47;
          if (v47) {
            sub_100053B7C(v47);
          }
        }

        else
        {
          __int16 v48 = 0LL;
        }

        free(v48);
      }

      stat v53 = 0;
      unsigned int v36 = 0LL;
      if (a3) {
        *a3 = (id)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  22LL,  0LL));
      }
      goto LABEL_104;
    }

    unsigned int v36 = (void *)v35;
    if (qword_1000DBB68 != -1) {
      dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
    }
    uint64_t v37 = (os_log_s *)(id)qword_1000DBB60;
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v66 = 0LL;
      LODWORD(v3_Block_object_dispose(va, 8) = sub_100053B4C(1);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG)) {
        uint64_t v38 = v38;
      }
      else {
        uint64_t v38 = v38 & 0xFFFFFFFE;
      }
      if ((_DWORD)v38)
      {
        uint64_t v39 = v37;
        LODWORD(v63) = 67109378;
        HIDWORD(v63) = sub_10005682C((uint64_t)v6);
        uint64_t v64 = 2112;
        unsigned int v65 = v36;
        int v40 = (char *)_os_log_send_and_compose_impl( v38,  &v66,  0LL,  0LL,  &_mh_execute_header,  v39,  2LL,  "Allocating kernel persona for PersonaID:%d with path:%@...",  &v63,  18);

        if (v40) {
          sub_100053B7C(v40);
        }
      }

      else
      {
        int v40 = 0LL;
      }

      free(v40);
    }
  }

  else
  {
    if (qword_1000DBB68 != -1) {
      dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
    }
    uint64_t v37 = (os_log_s *)(id)qword_1000DBB60;
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v63 = 0LL;
      LODWORD(v41) = sub_100053B4C(1);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG)) {
        BOOL v41 = v41;
      }
      else {
        BOOL v41 = v41 & 0xFFFFFFFE;
      }
      if ((_DWORD)v41)
      {
        id v42 = v37;
        LODWORD(v66) = 67109120;
        HIDWORD(v66) = sub_10005682C((uint64_t)v6);
        unsigned int v43 = (char *)_os_log_send_and_compose_impl( v41,  &v63,  0LL,  0LL,  &_mh_execute_header,  v42,  2LL,  "Allocating kernel persona for PersonaID:%u...",  &v66);

        if (v43) {
          sub_100053B7C(v43);
        }
      }

      else
      {
        unsigned int v43 = 0LL;
      }

      free(v43);
    }

    unsigned int v36 = 0LL;
  }

  id v49 = sub_10005682C((uint64_t)v6);
  unsigned int v50 = *(id *)(a1 + 16);
  uid_t v51 = sub_1000197AC((uint64_t)v50);
  uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue(v51);
  stat v53 = [v52 allocatePersonaWithInfo:v6 andPath:v36 error:a3];

  if ((v53 & 1) == 0)
  {
    if (qword_1000DBB68 != -1) {
      dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
    }
    CFDataRef v54 = (os_log_s *)(id)qword_1000DBB60;
    if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v63 = 0LL;
      id v55 = sub_100053B4C(1);
      if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT)) {
        unsigned int v56 = v55;
      }
      else {
        unsigned int v56 = v55 & 0xFFFFFFFE;
      }
      if ((_DWORD)v56)
      {
        LOWORD(v66) = 0;
        LODWORD(v62) = 2;
        vm_size_t v57 = (const char *)_os_log_send_and_compose_impl( v56,  &v63,  0LL,  0LL,  &_mh_execute_header,  v54,  0LL,  "Failed to load persona into kernel: Error allocating kernel persona",  &v66,  v62);
        uint64_t v58 = (char *)v57;
        if (v57) {
          sub_100053B7C(v57);
        }
      }

      else
      {
        uint64_t v58 = 0LL;
      }

      free(v58);
    }
  }

  if (sub_10005682C((uint64_t)v6) != v49)
  {
    uint64_t v59 = +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  sub_10005682C((uint64_t)v6));
    id v60 = (void *)objc_claimAutoreleasedReturnValue(v59);
    [v5 setObject:v60 forKeyedSubscript:@"UserPersonaID"];
  }

LABEL_64:
      CFStringRef v29 = 0LL;
LABEL_65:
      free(v29);
    }
  }

  else
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v23 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v23, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v139 = 0LL;
      unsigned int v24 = sub_100053B4C(1);
      id v23 = v23;
      if (os_log_type_enabled((os_log_t)v23, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v25 = v24;
      }
      else {
        uint64_t v25 = v24 & 0xFFFFFFFE;
      }
      if ((_DWORD)v25)
      {
        int v142 = 67109120;
        int v143 = (int)v22;
        uint64_t v26 = _os_log_send_and_compose_impl( v25,  &v139,  0LL,  0LL,  &_mh_execute_header,  v23,  0LL,  "Volume Migration Debug set and value=%d",  &v142);
        goto LABEL_62;
      }

      goto LABEL_64;
    }
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v30 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v30, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v139 = 0LL;
    unsigned int v31 = sub_100053B4C(1);
    unsigned int v32 = (os_log_s *)v30;
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v33 = v31;
    }
    else {
      uint64_t v33 = v31 & 0xFFFFFFFE;
    }
    if ((_DWORD)v33)
    {
      LOWORD(v142) = 0;
      LODWORD(v136) = 2;
      CFNumberRef v34 = (char *)_os_log_send_and_compose_impl( v33,  &v139,  0LL,  0LL,  &_mh_execute_header,  v32,  0LL,  "Starting SystemData & User Volume Migration",  &v142,  v136);

      if (v34) {
        sub_100053B7C(v34);
      }
    }

    else
    {

      CFNumberRef v34 = 0LL;
    }

    free(v34);
  }

  if ((_DWORD)v22 == 1)
  {
    sub_100019F7C("debug panic boot arg umd-migration-debug=1 (before calling transcribe)");
    goto LABEL_285;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v35 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v35, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v139 = 0LL;
    unsigned int v36 = sub_100053B4C(1);
    uint64_t v37 = (os_log_s *)v35;
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v38 = v36;
    }
    else {
      uint64_t v38 = v36 & 0xFFFFFFFE;
    }
    if ((_DWORD)v38)
    {
      LOWORD(v142) = 0;
      LODWORD(v136) = 2;
      uint64_t v39 = (char *)_os_log_send_and_compose_impl( v38,  &v139,  0LL,  0LL,  &_mh_execute_header,  v37,  0LL,  " Step1: Calling transcribe SDV...",  &v142,  v136);

      if (v39) {
        sub_100053B7C(v39);
      }
    }

    else
    {

      uint64_t v39 = 0LL;
    }

    free(v39);
  }

  if (v14)
  {
    int v141 = 0;
    int v40 = sub_10007D458(&v141);
    BOOL v41 = qword_1000DBAA0 == -1;
    if (!v40) {
      goto LABEL_288;
    }
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v42 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v42, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v139 = 0LL;
      unsigned int v43 = sub_100053B4C(1);
      id v42 = v42;
      if (os_log_type_enabled((os_log_t)v42, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v44 = v43;
      }
      else {
        uint64_t v44 = v43 & 0xFFFFFFFE;
      }
      if ((_DWORD)v44)
      {
        LOWORD(v142) = 0;
        LODWORD(v136) = 2;
        uint64_t v45 = _os_log_send_and_compose_impl( v44,  &v139,  0LL,  0LL,  &_mh_execute_header,  v42,  0LL,  "Step1: TRANSCRIBE SDV Successful",  &v142,  v136);
        goto LABEL_107;
      }

      goto LABEL_109;
    }
  }

  else
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v42 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v42, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v139 = 0LL;
      unsigned int v46 = sub_100053B4C(1);
      id v42 = v42;
      if (os_log_type_enabled((os_log_t)v42, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v47 = v46;
      }
      else {
        uint64_t v47 = v46 & 0xFFFFFFFE;
      }
      if ((_DWORD)v47)
      {
        LOWORD(v142) = 0;
        LODWORD(v136) = 2;
        uint64_t v45 = _os_log_send_and_compose_impl( v47,  &v139,  0LL,  0LL,  &_mh_execute_header,  v42,  0LL,  "Step1: Skipping TRANSCRIBE SDV as its already transcribed",  &v142,  v136);
LABEL_107:
        __int16 v48 = (char *)v45;

        if (v48) {
          sub_100053B7C(v48);
        }
        goto LABEL_110;
      }

      CFRelease(v30);
      goto LABEL_65;
    }

    HIDWORD(v90) = v4;
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v11 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v11, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)&cf = 0LL;
      id v12 = sub_100053B4C(1);
      unsigned int v13 = (os_log_s *)v11;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
        int v14 = v12;
      }
      else {
        int v14 = v12 & 0xFFFFFFFE;
      }
      if ((_DWORD)v14)
      {
        LODWORD(v92[0]) = 67109120;
        HIDWORD(v92[0]) = v5;
        id v15 = (char *)_os_log_send_and_compose_impl( v14,  &cf,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "MOUNTING APFS User Volume for uid:%d",  v92);

        if (v15) {
          sub_100053B7C(v15);
        }
      }

      else
      {

        id v15 = 0LL;
      }

      free(v15);
    }

    if ([(id)qword_1000DBA68 mountVolumeWithSession:a1 mountPath:0 error:0 forPersona:0])
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v21 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_54;
      }
      *(void *)&cf = 0LL;
      CFNumberRef v22 = sub_100053B4C(1);
      uint64_t v21 = v21;
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
        id v23 = v22;
      }
      else {
        id v23 = v22 & 0xFFFFFFFE;
      }
      if ((_DWORD)v23)
      {
        LODWORD(v92[0]) = 67109120;
        HIDWORD(v92[0]) = v5;
        unsigned int v24 = _os_log_send_and_compose_impl( v23,  &cf,  0LL,  0LL,  &_mh_execute_header,  v21,  0LL,  "Mounted new User Volume for uid %d",  v92);
        goto LABEL_46;
      }
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v21 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_54;
      }
      *(void *)&cf = 0LL;
      uint64_t v25 = sub_100053B4C(1);
      uint64_t v21 = v21;
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v26 = v25;
      }
      else {
        uint64_t v26 = v25 & 0xFFFFFFFE;
      }
      if ((_DWORD)v26)
      {
        LODWORD(v92[0]) = 67109120;
        HIDWORD(v92[0]) = v5;
        unsigned int v24 = _os_log_send_and_compose_impl( v26,  &cf,  0LL,  0LL,  &_mh_execute_header,  v21,  0LL,  "Failed to Mount new User Volume for uid %d",  v92);
LABEL_46:
        unsigned int v27 = (char *)v24;

        id v4 = HIDWORD(v90);
        if (v27) {
          sub_100053B7C(v27);
        }
        goto LABEL_53;
      }
    }

    unsigned int v27 = 0LL;
LABEL_53:
    free(v27);
LABEL_54:

    goto LABEL_55;
  }

  if (_os_feature_enabled_impl("UserManagement", "LocalUserEnrollment"))
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v16 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)&cf = 0LL;
      uint64_t v17 = sub_100053B4C(1);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v18 = v17;
      }
      else {
        uint64_t v18 = v17 & 0xFFFFFFFE;
      }
      if ((_DWORD)v18)
      {
        LODWORD(v92[0]) = 67109120;
        HIDWORD(v92[0]) = v5;
        unsigned int v19 = (const char *)_os_log_send_and_compose_impl( v18,  &cf,  0LL,  0LL,  &_mh_execute_header,  v16,  0LL,  "Local User switching, switching to %d",  v92);
        uint64_t v20 = (char *)v19;
        if (v19) {
          sub_100053B7C(v19);
        }
      }

      else
      {
        uint64_t v20 = 0LL;
      }

      free(v20);
    }
  }

  CFNumberRef v34 = 0LL;
LABEL_68:

LABEL_69:
  return v34;
}

LABEL_109:
      __int16 v48 = 0LL;
LABEL_110:
      free(v48);
    }
  }

  if ((_DWORD)v22 == 2)
  {
LABEL_285:
    sub_100019F7C("debug panic boot arg umd-migration-debug=2 (after calling transcribe)");
    goto LABEL_286;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v49 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v49, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v139 = 0LL;
    unsigned int v50 = sub_100053B4C(1);
    uid_t v51 = (os_log_s *)v49;
    if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v52 = v50;
    }
    else {
      uint64_t v52 = v50 & 0xFFFFFFFE;
    }
    if ((_DWORD)v52)
    {
      LOWORD(v142) = 0;
      LODWORD(v136) = 2;
      stat v53 = (char *)_os_log_send_and_compose_impl( v52,  &v139,  0LL,  0LL,  &_mh_execute_header,  v51,  0LL,  "Step2: Binding Shared Data Volume",  &v142,  v136);

      if (v53) {
        sub_100053B7C(v53);
      }
    }

    else
    {

      stat v53 = 0LL;
    }

    free(v53);
  }

  if (sub_10007BC44())
  {
    bytes[0] = 0;
    CFDataRef v54 = CFDataCreate(kCFAllocatorDefault, bytes, 1LL);
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v55 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v55, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v139 = 0LL;
      unsigned int v56 = sub_100053B4C(1);
      vm_size_t v57 = (os_log_s *)v55;
      if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v58 = v56;
      }
      else {
        uint64_t v58 = v56 & 0xFFFFFFFE;
      }
      if ((_DWORD)v58)
      {
        LOWORD(v142) = 0;
        LODWORD(v136) = 2;
        uint64_t v59 = (char *)_os_log_send_and_compose_impl( v58,  &v139,  0LL,  0LL,  &_mh_execute_header,  v57,  0LL,  "Binding SDV to primary User",  &v142,  v136);

        if (v59) {
          sub_100053B7C(v59);
        }
      }

      else
      {

        uint64_t v59 = 0LL;
      }

      free(v59);
    }

    int v141 = 0;
    int v68 = sub_10007C1D0(a1, (uint64_t)v54, 1, &v141);
    if (v54) {
      CFRelease(v54);
    }
    BOOL v69 = qword_1000DBAA0 == -1;
    if (!v68) {
      goto LABEL_299;
    }
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v60 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v60, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v139 = 0LL;
      unsigned int v70 = sub_100053B4C(1);
      CFTypeRef v62 = (os_log_s *)v60;
      if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v71 = v70;
      }
      else {
        uint64_t v71 = v70 & 0xFFFFFFFE;
      }
      if ((_DWORD)v71)
      {
        LOWORD(v142) = 0;
        LODWORD(v136) = 2;
        uint64_t v64 = _os_log_send_and_compose_impl( v71,  &v139,  0LL,  0LL,  &_mh_execute_header,  v62,  0LL,  "Step2: Binding SDV to primary User is Successful",  &v142,  v136);
LABEL_167:
        unsigned int v72 = (char *)v64;

        if (v72) {
          sub_100053B7C(v72);
        }
        goto LABEL_170;
      }

      goto LABEL_169;
    }
  }

  else
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v60 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v60, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v139 = 0LL;
      unsigned int v61 = sub_100053B4C(1);
      CFTypeRef v62 = (os_log_s *)v60;
      if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v63 = v61;
      }
      else {
        uint64_t v63 = v61 & 0xFFFFFFFE;
      }
      if ((_DWORD)v63)
      {
        LOWORD(v142) = 0;
        LODWORD(v136) = 2;
        uint64_t v64 = _os_log_send_and_compose_impl( v63,  &v139,  0LL,  0LL,  &_mh_execute_header,  v62,  0LL,  "Step2: Skipping Binding SDV as its already bound",  &v142,  v136);
        goto LABEL_167;
      }

    int v40 = 0LL;
    goto LABEL_110;
  }

  if (qword_1000DBBD8 != -1) {
    dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
  }
  uid_t v51 = (os_log_s *)(id)qword_1000DBBD0;
  if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t v58 = 0LL;
    uint64_t v52 = sub_100053B4C(1);
    if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT)) {
      stat v53 = v52;
    }
    else {
      stat v53 = v52 & 0xFFFFFFFE;
    }
    if ((_DWORD)v53)
    {
      LOWORD(v57[0]) = 0;
      LODWORD(v56) = 2;
      CFDataRef v54 = (const char *)_os_log_send_and_compose_impl( v53,  v58,  0LL,  0LL,  &_mh_execute_header,  v51,  0LL,  "System Data Volume, bound to AKS with primary",  v57,  v56);
      id v55 = (char *)v54;
      if (v54) {
        sub_100053B7C(v54);
      }
    }

    else
    {
      id v55 = 0LL;
    }

    free(v55);
  }

  return 1LL;
}

LABEL_169:
      unsigned int v72 = 0LL;
LABEL_170:
      free(v72);
    }
  }

  if ((_DWORD)v22 == 3)
  {
LABEL_286:
    sub_100019F7C("debug panic boot arg umd-migration-debug=3 (after calling bind of SDV)");
    goto LABEL_287;
  }

  if (dword_1000DBCE8 != 1)
  {
    *(_DWORD *)bytes = 0;
    char v137 = 1;
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v78 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v78, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v139 = 0LL;
      unsigned int v79 = sub_100053B4C(1);
      uint64_t v80 = (os_log_s *)v78;
      if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v81 = v79;
      }
      else {
        uint64_t v81 = v79 & 0xFFFFFFFE;
      }
      if ((_DWORD)v81)
      {
        LOWORD(v142) = 0;
        LODWORD(v136) = 2;
        v82 = (char *)_os_log_send_and_compose_impl( v81,  &v139,  0LL,  0LL,  &_mh_execute_header,  v80,  0LL,  "Step3: Migrating Media Key of the User Volume",  &v142,  v136);

        if (v82) {
          sub_100053B7C(v82);
        }
      }

      else
      {

        v82 = 0LL;
      }

      free(v82);
    }

    if (sub_10007D41C((int *)bytes, &v137))
    {
      int v141 = 0;
      if (!sub_10007D838(0, &v141))
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        uint64_t v127 = (os_log_s *)(id)qword_1000DBA98;
        if (!os_log_type_enabled(v127, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_334;
        }
        uint64_t v139 = 0LL;
        unsigned int v131 = sub_100053B4C(1);
        CFNumberRef v22 = v127;
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v132 = v131;
        }
        else {
          uint64_t v132 = v131 & 0xFFFFFFFE;
        }
        if ((_DWORD)v132) {
          goto LABEL_331;
        }

        v133 = 0LL;
        goto LABEL_333;
      }

      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v90 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_234;
      }
      uint64_t v139 = 0LL;
      unsigned int v91 = sub_100053B4C(1);
      uint64_t v90 = v90;
      if (os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v92 = v91;
      }
      else {
        uint64_t v92 = v91 & 0xFFFFFFFE;
      }
      if ((_DWORD)v92)
      {
        LOWORD(v142) = 0;
        LODWORD(v136) = 2;
        uint64_t v93 = _os_log_send_and_compose_impl( v92,  &v139,  0LL,  0LL,  &_mh_execute_header,  v90,  0LL,  "Step3: Migration of UserVolume Media Key Successful",  &v142,  v136);
        goto LABEL_230;
      }
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v90 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_234;
      }
      uint64_t v139 = 0LL;
      unsigned int v94 = sub_100053B4C(1);
      uint64_t v90 = v90;
      if (os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v95 = v94;
      }
      else {
        uint64_t v95 = v94 & 0xFFFFFFFE;
      }
      if ((_DWORD)v95)
      {
        LOWORD(v142) = 0;
        LODWORD(v136) = 2;
        uint64_t v93 = _os_log_send_and_compose_impl( v95,  &v139,  0LL,  0LL,  &_mh_execute_header,  v90,  0LL,  "Step3: Skipping migrating UserVolume",  &v142,  v136);
LABEL_230:
        v96 = (char *)v93;

        if (v96) {
          sub_100053B7C(v96);
        }
        goto LABEL_233;
      }
    }

    v96 = 0LL;
LABEL_233:
    free(v96);
LABEL_234:

    if ((_DWORD)v22 == 4) {
      goto LABEL_310;
    }
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v97 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v97, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v139 = 0LL;
      unsigned int v98 = sub_100053B4C(1);
      uint64_t v99 = (os_log_s *)v97;
      if (os_log_type_enabled(v99, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v100 = v98;
      }
      else {
        uint64_t v100 = v98 & 0xFFFFFFFE;
      }
      if ((_DWORD)v100)
      {
        LOWORD(v142) = 0;
        LODWORD(v136) = 2;
        v101 = (char *)_os_log_send_and_compose_impl( v100,  &v139,  0LL,  0LL,  &_mh_execute_header,  v99,  0LL,  "Step4: Setting Primary User as Last booted User..",  &v142,  v136);

        if (v101) {
          sub_100053B7C(v101);
        }
      }

      else
      {

        v101 = 0LL;
      }

      free(v101);
    }

    int v141 = 0;
    int v102 = sub_10007E13C("/var/mobile", &v141);
    BOOL v103 = qword_1000DBAA0 == -1;
    if (!v102) {
      goto LABEL_311;
    }
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    ssize_t v83 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_259;
    }
    uint64_t v139 = 0LL;
    unsigned int v104 = sub_100053B4C(1);
    ssize_t v85 = v83;
    if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v105 = v104;
    }
    else {
      uint64_t v105 = v104 & 0xFFFFFFFE;
    }
    if (!(_DWORD)v105) {
      goto LABEL_257;
    }
    LOWORD(v142) = 0;
    uint64_t v87 = _os_log_send_and_compose_impl( v105,  &v139,  0LL,  0LL,  &_mh_execute_header,  v85,  0LL,  "Step4: Setting the last user successful..");
LABEL_255:
    v106 = (char *)v87;

    if (v106) {
      sub_100053B7C(v106);
    }
    goto LABEL_258;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v73 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v73, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v139 = 0LL;
    unsigned int v74 = sub_100053B4C(1);
    uint64_t v75 = (os_log_s *)v73;
    if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v76 = v74;
    }
    else {
      uint64_t v76 = v74 & 0xFFFFFFFE;
    }
    if ((_DWORD)v76)
    {
      LOWORD(v142) = 0;
      LODWORD(v136) = 2;
      uint64_t v77 = (char *)_os_log_send_and_compose_impl( v76,  &v139,  0LL,  0LL,  &_mh_execute_header,  v75,  0LL,  "Shared ipad, need to skip step3-4 of migration",  &v142,  v136);

      if (v77) {
        sub_100053B7C(v77);
      }
    }

    else
    {

      uint64_t v77 = 0LL;
    }

    free(v77);
  }

  if (!sub_10007E80C(1LL, &v141))
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    ssize_t v83 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_259;
    }
    uint64_t v139 = 0LL;
    unsigned int v88 = sub_100053B4C(1);
    ssize_t v85 = v83;
    if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v89 = v88;
    }
    else {
      uint64_t v89 = v88 & 0xFFFFFFFE;
    }
    if (!(_DWORD)v89) {
      goto LABEL_257;
    }
    int v142 = 67109120;
    int v143 = v141;
    uint64_t v87 = _os_log_send_and_compose_impl( v89,  &v139,  0LL,  0LL,  &_mh_execute_header,  v85,  0LL,  "Failed to Delete Primary User volume from splitter on sharedIPad with error:%d, ignoring error",  &v142);
    goto LABEL_255;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  ssize_t v83 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v139 = 0LL;
    unsigned int v84 = sub_100053B4C(1);
    ssize_t v85 = v83;
    if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v86 = v84;
    }
    else {
      uint64_t v86 = v84 & 0xFFFFFFFE;
    }
    if ((_DWORD)v86)
    {
      LOWORD(v142) = 0;
      LODWORD(v136) = 2;
      uint64_t v87 = _os_log_send_and_compose_impl( v86,  &v139,  0LL,  0LL,  &_mh_execute_header,  v85,  0LL,  "Deleted Primary User Volume after Shared Data Volume Transcribe",  &v142,  v136);
      goto LABEL_255;
    }

        uint64_t v64 = 0LL;
LABEL_170:
        free(v64);
      }
    }

    unsigned int v65 = (id)sub_100083DF4(v1, kUMUserSessionUUIDKey);
    uint64_t v66 = sub_1000197A0(qword_1000DBA78);
    uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue(v66);
    int v68 = (void *)objc_claimAutoreleasedReturnValue([v67 userPersonas]);
    BOOL v69 = (void *)objc_claimAutoreleasedReturnValue([v68 objectForKeyedSubscript:v65]);

    if (!v69)
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      unsigned int v70 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)__str = 0LL;
        uint64_t v71 = sub_100053B4C(1);
        if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT)) {
          unsigned int v72 = v71;
        }
        else {
          unsigned int v72 = v71 & 0xFFFFFFFE;
        }
        if ((_DWORD)v72)
        {
          *(_DWORD *)__old = 138412290;
          *(void *)&__old[4] = v65;
          LODWORD(v16_Block_object_dispose(va, 8) = 12;
          id v73 = (const char *)_os_log_send_and_compose_impl( v72,  __str,  0LL,  0LL,  &_mh_execute_header,  v70,  0LL,  "No personas found to delete for user %@",  __old,  v168);
          unsigned int v74 = (char *)v73;
          if (v73) {
            sub_100053B7C(v73);
          }
        }

        else
        {
          unsigned int v74 = 0LL;
        }

        free(v74);
      }
    }

    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    v133 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v133, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)__str = 0LL;
      uint64_t v134 = sub_100053B4C(1);
      if (os_log_type_enabled(v133, OS_LOG_TYPE_DEFAULT)) {
        v135 = v134;
      }
      else {
        v135 = v134 & 0xFFFFFFFE;
      }
      if ((_DWORD)v135)
      {
        *(_DWORD *)__old = 138412290;
        *(void *)&__old[4] = v65;
        LODWORD(v16_Block_object_dispose(va, 8) = 12;
        uint64_t v136 = (const char *)_os_log_send_and_compose_impl( v135,  __str,  0LL,  0LL,  &_mh_execute_header,  v133,  0LL,  "Deleting all personas for user %@...",  __old,  v168);
        char v137 = (char *)v136;
        if (v136) {
          sub_100053B7C(v136);
        }
      }

      else
      {
        char v137 = 0LL;
      }

      free(v137);
    }

    do
    {

      if (![v69 count])
      {
        v146 = sub_1000197A0(qword_1000DBA78);
        uint64_t v147 = (void *)objc_claimAutoreleasedReturnValue(v146);
        v148 = (void *)objc_claimAutoreleasedReturnValue([v147 userPersonas]);
        [v148 setObject:0 forKeyedSubscript:v65];

        sub_10005B2D0(qword_1000DBA78);
        goto LABEL_359;
      }

      v133 = (os_log_s *)objc_claimAutoreleasedReturnValue([v69 objectAtIndexedSubscript:0]);
      v138 = sub_100046BE8(v69, v133, 1);
    }

    while (!v138);
    uint64_t v139 = v138;
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    char v140 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v140, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)__str = 0LL;
      int v141 = sub_100053B4C(1);
      if (os_log_type_enabled(v140, OS_LOG_TYPE_DEFAULT)) {
        int v142 = v141;
      }
      else {
        int v142 = v141 & 0xFFFFFFFE;
      }
      if ((_DWORD)v142)
      {
        int v143 = v140;
        id v144 = strerror(v139);
        *(_DWORD *)__old = 138412546;
        *(void *)&__old[4] = v65;
        unsigned int v174 = 2080;
        uint64_t v175 = v144;
        LODWORD(v16_Block_object_dispose(va, 8) = 22;
        unsigned int v145 = (char *)_os_log_send_and_compose_impl( v142,  __str,  0LL,  0LL,  &_mh_execute_header,  v143,  0LL,  "Failed to delete all personas for user %@: %s",  __old,  v168);

        if (v145) {
          sub_100053B7C(v145);
        }
      }

      else
      {
        unsigned int v145 = 0LL;
      }

      free(v145);
    }

    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v127 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v127, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_332;
    }
    *(void *)__old = 0LL;
    CFNumberRef v163 = sub_100053B4C(1);
    if (os_log_type_enabled(v127, OS_LOG_TYPE_DEFAULT)) {
      CFNumberRef v164 = v163;
    }
    else {
      CFNumberRef v164 = v163 & 0xFFFFFFFE;
    }
    if ((_DWORD)v164)
    {
      *(_DWORD *)__str = 67109120;
      *(_DWORD *)&char __str[4] = v9;
      id v165 = (const char *)_os_log_send_and_compose_impl( v164,  __old,  0LL,  0LL,  &_mh_execute_header,  v127,  0LL,  "Failed to delete personas for user %u",  __str);
      unsigned int v166 = v165;
      if (v165) {
        sub_100053B7C(v165);
      }
    }

    else
    {
      unsigned int v166 = 0LL;
    }

    uint64_t v132 = (char *)v166;
    goto LABEL_331;
  }

  if (dword_1000DBCE8 == 1) {
    goto LABEL_44;
  }
LABEL_359:
  id v149 = sub_100083DF4(v1, kUMUserSessionShortNameKey);
  nullsub_1(qword_1000DBA70, v149);
  sub_10002E0A4(v9, 1);
  sub_10001AED4();
  if (qword_1000DBAB0 != -1) {
    dispatch_once(&qword_1000DBAB0, &stru_1000CD548);
  }
  unsigned int v150 = (id)qword_1000DBAA8;
  if (os_log_type_enabled((os_log_t)v150, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)__str = 0LL;
    v151 = sub_100053B4C(1);
    uint64_t v152 = (os_log_s *)v150;
    if (os_log_type_enabled(v152, OS_LOG_TYPE_DEFAULT)) {
      v153 = v151;
    }
    else {
      v153 = v151 & 0xFFFFFFFE;
    }
    if ((_DWORD)v153)
    {
      *(_DWORD *)v169 = 67109120;
      *(_DWORD *)&v169[4] = v9;
      CFNumberRef v154 = (char *)_os_log_send_and_compose_impl( v153,  __str,  0LL,  0LL,  &_mh_execute_header,  v152,  0LL,  "Deleted user %u",  v169);

      if (v154) {
        sub_100053B7C(v154);
      }
    }

    else
    {

      CFNumberRef v154 = 0LL;
    }

    free(v154);
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  CFNumberRef v155 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v155, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)v169 = 0LL;
    CFNumberRef v156 = sub_100053B4C(1);
    v157 = (os_log_s *)v155;
    if (os_log_type_enabled(v157, OS_LOG_TYPE_DEFAULT)) {
      CFNumberRef v158 = v156;
    }
    else {
      CFNumberRef v158 = v156 & 0xFFFFFFFE;
    }
    if ((_DWORD)v158)
    {
      *(_DWORD *)__str = 136315394;
      *(void *)&char __str[4] = "removeUserSessionInternal";
      *(_WORD *)&__str[12] = 2080;
      uint64_t v172 = kMobileKeyBagUserChangedNotificationToken;
      LODWORD(v16_Block_object_dispose(va, 8) = 22;
      CFNumberRef v159 = (char *)_os_log_send_and_compose_impl( v158,  v169,  0LL,  0LL,  &_mh_execute_header,  v157,  0LL,  "usermanagerd %s posting notification: %s\n",  __str,  v168);

      if (v159) {
        sub_100053B7C(v159);
      }
    }

    else
    {

      CFNumberRef v159 = 0LL;
    }

    free(v159);
  }

  CFNumberRef v160 = sub_100018E74(qword_1000DBD40);
  CFNumberRef v161 = (void *)objc_claimAutoreleasedReturnValue(v160);
  CFNumberRef v162 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  kMobileKeyBagUserChangedNotificationToken));
  [v161 post:v162];

  return 1LL;
}

LABEL_257:
    v106 = 0LL;
LABEL_258:
    free(v106);
  }

LABEL_259:
  int v141 = 0;
  if ((_DWORD)v22 == 5)
  {
LABEL_287:
    sub_100019F7C("debug panic boot arg umd-migration-debug=5 (after calling setLastUserOnVolume)");
LABEL_288:
    if (v41) {
      goto LABEL_290;
    }
    while (1)
    {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
LABEL_290:
      unsigned int v117 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v139 = 0LL;
        CFNumberRef v22 = (os_log_s *)sub_100053B4C(1);
        BOOL v118 = os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT);
        v119 = 0LL;
        if (v118) {
          uint64_t v120 = v22;
        }
        else {
          uint64_t v120 = v22 & 0xFFFFFFFE;
        }
        if ((_DWORD)v120)
        {
          int v142 = 67109120;
          int v143 = v141;
          v121 = (const char *)_os_log_send_and_compose_impl( v120,  &v139,  0LL,  0LL,  &_mh_execute_header,  v117,  0LL,  "Step1: Transcribing SDV failed with error:%d, bailing",  &v142);
          v119 = 0LL;
          if (v121)
          {
            CFNumberRef v22 = (os_log_s *)v121;
            sub_100053B7C(v121);
            v119 = v22;
          }
        }

        free(v119);
      }

      sub_100019F7C("VolumeMigration-Step1: APFSVolumeTranscribePFK failed with error:%d, bailing", v141);
LABEL_299:
      if (!v69) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      unsigned __int8 v122 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v139 = 0LL;
        CFNumberRef v22 = (os_log_s *)sub_100053B4C(1);
        BOOL v123 = os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT);
        id v124 = 0LL;
        if (v123) {
          uint64_t v125 = v22;
        }
        else {
          uint64_t v125 = v22 & 0xFFFFFFFE;
        }
        if ((_DWORD)v125)
        {
          int v142 = 67109120;
          int v143 = v141;
          v126 = (const char *)_os_log_send_and_compose_impl( v125,  &v139,  0LL,  0LL,  &_mh_execute_header,  v122,  0LL,  "Step2: Binding SDV to primary User failed with %d, bailing",  &v142);
          id v124 = 0LL;
          if (v126)
          {
            CFNumberRef v22 = (os_log_s *)v126;
            sub_100053B7C(v126);
            id v124 = v22;
          }
        }

        free(v124);
      }

      sub_100019F7C("VolumeMigration-Step2: APFSVolumeEnableUserProtectionWithOptions failed with %d, bailing", v141);
LABEL_310:
      sub_100019F7C("debug panic boot arg umd-migration-debug=4 (after calling UserVolume MigrateMediaKey)");
LABEL_311:
      if (!v103) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v127 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v127, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v139 = 0LL;
        unsigned int v128 = sub_100053B4C(1);
        CFNumberRef v22 = v127;
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v129 = v128;
        }
        else {
          uint64_t v129 = v128 & 0xFFFFFFFE;
        }
        if ((_DWORD)v129)
        {
          int v142 = 67109120;
          int v143 = v141;
          uint64_t v134 = (const char *)_os_log_send_and_compose_impl( v129,  &v139,  0LL,  0LL,  &_mh_execute_header,  v22,  0LL,  "Step4: Setting Last booted User as Primary User failed with error:%d",  &v142);

          int v130 = 0LL;
          if (v134)
          {
            sub_100053B7C(v134);
            int v130 = (char *)v134;
          }
        }

        else
        {

          int v130 = 0LL;
        }

        free(v130);
      }

      uint64_t v132 = sub_100019F7C("VolumeMigration-Step4: Setting Last booted User as Primary User failed with error:%d", v141);
LABEL_331:
      int v142 = 67109120;
      int v143 = v141;
      v135 = (const char *)_os_log_send_and_compose_impl( v132,  &v139,  0LL,  0LL,  &_mh_execute_header,  v22,  0LL,  "Step3: Migrating UserVolume Media Key failed with error:%d, bailing",  &v142);

      v133 = 0LL;
      if (v135)
      {
        sub_100053B7C(v135);
        v133 = (char *)v135;
      }

LABEL_333:
      free(v133);
LABEL_334:

      sub_100019F7C("VolumeMigration-Step3: Migrating UserVolume Media Key failed with error:%d, bailing", v141);
    }
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v107 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v107, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v139 = 0LL;
    unsigned int v108 = sub_100053B4C(1);
    v109 = (os_log_s *)v107;
    if (os_log_type_enabled(v109, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v110 = v108;
    }
    else {
      uint64_t v110 = v108 & 0xFFFFFFFE;
    }
    if ((_DWORD)v110)
    {
      LOWORD(v142) = 0;
      LODWORD(v136) = 2;
      v111 = (char *)_os_log_send_and_compose_impl( v110,  &v139,  0LL,  0LL,  &_mh_execute_header,  v109,  0LL,  "Removing Migration Progress Marker File",  &v142,  v136);

      if (v111) {
        sub_100053B7C(v111);
      }
    }

    else
    {

      v111 = 0LL;
    }

    free(v111);
  }

  sub_1000238D0();
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v112 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v112, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v139 = 0LL;
    unsigned int v113 = sub_100053B4C(1);
    uint64_t v114 = (os_log_s *)v112;
    if (os_log_type_enabled(v114, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v115 = v113;
    }
    else {
      uint64_t v115 = v113 & 0xFFFFFFFE;
    }
    if ((_DWORD)v115)
    {
      LOWORD(v142) = 0;
      LODWORD(v136) = 2;
      v116 = (char *)_os_log_send_and_compose_impl( v115,  &v139,  0LL,  0LL,  &_mh_execute_header,  v114,  0LL,  "All phases of migration completed, returning success",  &v142,  v136);

      if (v116) {
        sub_100053B7C(v116);
      }
    }

    else
    {

      v116 = 0LL;
    }

    free(v116);
  }

  if (a2) {
    goto LABEL_152;
  }
  return 1LL;
}

id sub_100023714()
{
  uint64_t v0 = sub_100019434(qword_1000DBD40);
  unsigned int v1 = (void *)objc_claimAutoreleasedReturnValue(v0);
  id v2 = [v1 fileExistsAtPath:@"/private/var//keybags/umVolumeMigration-inprogress.kb" isDirectory:0];

  if ((_DWORD)v2)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v3 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = 0LL;
      unsigned int v4 = sub_100053B4C(1);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v5 = v4;
      }
      else {
        uint64_t v5 = v4 & 0xFFFFFFFE;
      }
      if ((_DWORD)v5)
      {
        LOWORD(v11) = 0;
        id v6 = (const char *)_os_log_send_and_compose_impl( v5,  &v12,  0LL,  0LL,  &_mh_execute_header,  v3,  0LL,  "USER_VOLUME_MIGRATION_MARKER_PATH exits",  &v11,  2,  v11);
        goto LABEL_18;
      }

      goto LABEL_20;
    }
  }

  else
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v3 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = 0LL;
      unsigned int v7 = sub_100053B4C(1);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v8 = v7;
      }
      else {
        uint64_t v8 = v7 & 0xFFFFFFFE;
      }
      if ((_DWORD)v8)
      {
        LOWORD(v11) = 0;
        id v6 = (const char *)_os_log_send_and_compose_impl( v8,  &v12,  0LL,  0LL,  &_mh_execute_header,  v3,  0LL,  "USER_VOLUME_MIGRATION_MARKER_PATH does not exist",  &v11,  2,  v11);
LABEL_18:
        uint64_t v9 = (char *)v6;
        if (v6) {
          sub_100053B7C(v6);
        }
        goto LABEL_21;
      }

id sub_1000238D0()
{
  uint64_t v0 = sub_100019434(qword_1000DBD40);
  unsigned int v1 = (void *)objc_claimAutoreleasedReturnValue(v0);
  id v2 = [v1 removeFileAtPath:@"/private/var//keybags/umVolumeMigration-inprogress.kb" error:0];

  if ((_DWORD)v2)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v3 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = 0LL;
      unsigned int v4 = sub_100053B4C(1);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v5 = v4;
      }
      else {
        uint64_t v5 = v4 & 0xFFFFFFFE;
      }
      if ((_DWORD)v5)
      {
        LOWORD(v11) = 0;
        id v6 = (const char *)_os_log_send_and_compose_impl( v5,  &v12,  0LL,  0LL,  &_mh_execute_header,  v3,  0LL,  "USER_VOLUME_MIGRATION_MARKER_PATH file removed",  &v11,  2,  v11);
        goto LABEL_18;
      }

      goto LABEL_20;
    }
  }

  else
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v3 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = 0LL;
      unsigned int v7 = sub_100053B4C(1);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v8 = v7;
      }
      else {
        uint64_t v8 = v7 & 0xFFFFFFFE;
      }
      if ((_DWORD)v8)
      {
        LOWORD(v11) = 0;
        id v6 = (const char *)_os_log_send_and_compose_impl( v8,  &v12,  0LL,  0LL,  &_mh_execute_header,  v3,  0LL,  "USER_VOLUME_MIGRATION_MARKER_PATH failed to remove",  &v11,  2,  v11);
LABEL_18:
        uint64_t v9 = (char *)v6;
        if (v6) {
          sub_100053B7C(v6);
        }
        goto LABEL_21;
      }

BOOL sub_100023A8C(uint64_t a1)
{
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v2 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = 0LL;
    unsigned int v3 = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      int v18 = 136315138;
      uint64_t v19 = a1;
      uint64_t v5 = (const char *)_os_log_send_and_compose_impl( v4,  &v16,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "Volume: %s  Crypto Migration Start",  (const char *)&v18);
      id v6 = (char *)v5;
      if (v5) {
        sub_100053B7C(v5);
      }
    }

    else
    {
      id v6 = 0LL;
    }

    free(v6);
  }

  int v17 = 0;
  int v7 = sub_10007D19C(a1, &v17);
  if (v7)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v8 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = 0LL;
      unsigned int v9 = sub_100053B4C(1);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = v9 & 0xFFFFFFFE;
      }
      if ((_DWORD)v10)
      {
        int v18 = 136315138;
        uint64_t v19 = a1;
        uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v10,  &v16,  0LL,  0LL,  &_mh_execute_header,  v8,  0LL,  "Volume: %s  Crypto Migration SUCCESS",  &v18);
        goto LABEL_29;
      }

      goto LABEL_31;
    }
  }

  else
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v8 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = 0LL;
      unsigned int v12 = sub_100053B4C(1);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v13 = v12;
      }
      else {
        uint64_t v13 = v12 & 0xFFFFFFFE;
      }
      if ((_DWORD)v13)
      {
        int v18 = 136315394;
        uint64_t v19 = a1;
        __int16 v20 = 1024;
        int v21 = v17;
        uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v13,  &v16,  0LL,  0LL,  &_mh_execute_header,  v8,  0LL,  "Volume: %s  Crypto Migration FAILED with error: %d",  &v18,  18);
LABEL_29:
        int v14 = (char *)v11;
        if (v11) {
          sub_100053B7C(v11);
        }
        goto LABEL_32;
      }

__CFDictionary *sub_100023D64(const __CFDictionary *a1, UInt8 *a2, CFIndex a3, int *a4)
{
  int v345 = 0;
  if (dword_1000DBCE8 != 1 && !_os_feature_enabled_impl("UserManagement", "LocalUserEnrollment"))
  {
    int v26 = 45;
LABEL_572:
    CFDataRef v54 = 0LL;
    if (a4 && v26)
    {
      CFDataRef v54 = 0LL;
      *a4 = v26;
    }

    return v54;
  }

  uint64_t v8 = (const __CFDictionary *)sub_100021AC4(a1);
  unint64_t v9 = (unint64_t)v8;
  bytes = a2;
  CFIndex v343 = a3;
  if (!v8)
  {
    if (dword_1000DBCE8 == 1)
    {
      v341 = a1;
      if (dword_1000DACB4 != -1)
      {
        if (!dword_1000DACB4 || !qword_1000DBCE0 || qword_1000DBCE0 != dword_1000DACB4 + 1LL) {
          goto LABEL_227;
        }
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        id v21 = (id)qword_1000DBA98;
        if (os_log_type_enabled((os_log_t)v21, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)buffer = 0LL;
          unsigned int v22 = sub_100053B4C(1);
          id v23 = (os_log_s *)v21;
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v24 = v22;
          }
          else {
            uint64_t v24 = v22 & 0xFFFFFFFE;
          }
          if ((_DWORD)v24)
          {
            v352.f_bsize = 67109376;
            v352.f_iosize = dword_1000DACB4;
            LOWORD(v352.f_blocks) = 2048;
            *(uint64_t *)((char *)&v352.f_blocks + 2) = qword_1000DBCE0;
            LODWORD(v33_Block_object_dispose(va, 8) = 18;
            uint64_t v25 = (char *)_os_log_send_and_compose_impl( v24,  buffer,  0LL,  0LL,  &_mh_execute_header,  v23,  0LL,  "MAX USERS(%d) ALREADY CONFIGURED, CurUsers:%ld, may have to DELETE existing user session",  &v352,  v338);

            if (v25) {
              sub_100053B7C(v25);
            }
          }

          else
          {

            uint64_t v25 = 0LL;
          }

          free(v25);
        }

        if (sub_100027A48() == 1)
        {
          if (qword_1000DBCE0 == dword_1000DACB4 + 1LL)
          {
            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            unsigned int v32 = (os_log_s *)(id)qword_1000DBA98;
            if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_188;
            }
            *(void *)&v352.f_bsize = 0LL;
            unsigned int v81 = sub_100053B4C(1);
            if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v82 = v81;
            }
            else {
              uint64_t v82 = v81 & 0xFFFFFFFE;
            }
            if (!(_DWORD)v82) {
              goto LABEL_186;
            }
            *(_WORD *)buffer = 0;
            LODWORD(v33_Block_object_dispose(va, 8) = 2;
            id v35 = (const char *)_os_log_send_and_compose_impl( v82,  &v352,  0LL,  0LL,  &_mh_execute_header,  v32,  0LL,  "FAILED to delete an user,  cannot add a new user",  buffer,  v338);
            goto LABEL_50;
          }

          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          unint64_t v9 = 0LL;
          uint64_t v64 = (os_log_s *)(id)qword_1000DBA98;
          if (!os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_201;
          }
          *(void *)&v352.f_bsize = 0LL;
          unsigned int v85 = sub_100053B4C(1);
          uint64_t v66 = v64;
          if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v86 = v85;
          }
          else {
            uint64_t v86 = v85 & 0xFFFFFFFE;
          }
          if ((_DWORD)v86)
          {
            *(_WORD *)buffer = 0;
            LODWORD(v33_Block_object_dispose(va, 8) = 2;
            uint64_t v68 = _os_log_send_and_compose_impl( v86,  &v352,  0LL,  0LL,  &_mh_execute_header,  v66,  0LL,  "Created a slot for new user by replacing",  buffer,  v338);
LABEL_197:
            uint64_t v87 = (char *)v68;

            if (v87) {
              sub_100053B7C(v87);
            }
            goto LABEL_200;
          }

          goto LABEL_199;
        }

        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        unsigned int v32 = (os_log_s *)(id)qword_1000DBA98;
        if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_188;
        }
        *(void *)&v352.f_bsize = 0LL;
        unsigned int v83 = sub_100053B4C(1);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v84 = v83;
        }
        else {
          uint64_t v84 = v83 & 0xFFFFFFFE;
        }
        if (!(_DWORD)v84) {
          goto LABEL_186;
        }
        *(_WORD *)buffer = 0;
        id v35 = (const char *)_os_log_send_and_compose_impl( v84,  &v352,  0LL,  0LL,  &_mh_execute_header,  v32,  0LL,  "FAILED to delete an user to create a new one,  cannot add a new user");
        goto LABEL_50;
      }

      if (!qword_1000DBD10) {
        goto LABEL_227;
      }
      strcpy(buffer, "/private/var");
      int v44 = statfs(buffer, &v352);
      if (qword_1000DBCE0 == 16)
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        uint64_t v45 = (os_log_s *)(id)qword_1000DBA98;
        if (!os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_149;
        }
        *(void *)&v352.f_bsize = 0LL;
        unsigned int v46 = sub_100053B4C(1);
        uint64_t v45 = v45;
        if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v47 = v46;
        }
        else {
          uint64_t v47 = v46 & 0xFFFFFFFE;
        }
        if ((_DWORD)v47)
        {
          *(_WORD *)buffer = 0;
          uint64_t v48 = _os_log_send_and_compose_impl( v47,  &v352,  0LL,  0LL,  &_mh_execute_header,  v45,  0LL,  "Exceeds allowed user Sessions, try removing an existing user if possible",  buffer,  2);
          goto LABEL_106;
        }
      }

      else
      {
        if (v44) {
          unint64_t v60 = 0LL;
        }
        else {
          unint64_t v60 = (int64_t)(v352.f_bfree * v352.f_bsize) / 0x100000;
        }
        if (qword_1000DBD10 <= v60)
        {
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          uint64_t v64 = (os_log_s *)(id)qword_1000DBA98;
          if (!os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_201;
          }
          *(void *)&v352.f_bsize = 0LL;
          unsigned int v65 = sub_100053B4C(1);
          uint64_t v66 = v64;
          if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v67 = v65;
          }
          else {
            uint64_t v67 = v65 & 0xFFFFFFFE;
          }
          if ((_DWORD)v67)
          {
            *(_WORD *)buffer = 0;
            uint64_t v68 = _os_log_send_and_compose_impl( v67,  &v352,  0LL,  0LL,  &_mh_execute_header,  v66,  0LL,  "Enough space to create a new one, continuing ...",  buffer,  2);
            goto LABEL_197;
          }

          goto LABEL_199;
        }

        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        uint64_t v45 = (os_log_s *)(id)qword_1000DBA98;
        if (!os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_149;
        }
        *(void *)&v352.f_bsize = 0LL;
        unsigned int v61 = sub_100053B4C(1);
        uint64_t v45 = v45;
        if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v62 = v61;
        }
        else {
          uint64_t v62 = v61 & 0xFFFFFFFE;
        }
        if ((_DWORD)v62)
        {
          *(_WORD *)buffer = 0;
          uint64_t v48 = _os_log_send_and_compose_impl( v62,  &v352,  0LL,  0LL,  &_mh_execute_header,  v45,  0LL,  "Not enough space to accommodate another user, try removing an existing user if possible",  buffer,  2);
LABEL_106:
          uint64_t v63 = (char *)v48;

          if (v63) {
            sub_100053B7C(v63);
          }
          goto LABEL_148;
        }
      }

      uint64_t v63 = 0LL;
LABEL_148:
      free(v63);
LABEL_149:

      if (sub_100027A48())
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        uint64_t v64 = (os_log_s *)(id)qword_1000DBA98;
        if (!os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_201;
        }
        *(void *)&v352.f_bsize = 0LL;
        unsigned int v77 = sub_100053B4C(1);
        uint64_t v66 = v64;
        if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v78 = v77;
        }
        else {
          uint64_t v78 = v77 & 0xFFFFFFFE;
        }
        if ((_DWORD)v78)
        {
          *(_WORD *)buffer = 0;
          LODWORD(v33_Block_object_dispose(va, 8) = 2;
          uint64_t v68 = _os_log_send_and_compose_impl( v78,  &v352,  0LL,  0LL,  &_mh_execute_header,  v66,  0LL,  "Deleted an user to create a new one, continuing ...",  buffer,  v338);
          goto LABEL_197;
        }

LABEL_199:
        uint64_t v87 = 0LL;
LABEL_200:
        free(v87);
LABEL_201:

        goto LABEL_227;
      }

      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      unsigned int v32 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_188;
      }
      *(void *)&v352.f_bsize = 0LL;
      unsigned int v79 = sub_100053B4C(1);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v80 = v79;
      }
      else {
        uint64_t v80 = v79 & 0xFFFFFFFE;
      }
      if (!(_DWORD)v80) {
        goto LABEL_186;
      }
      *(_WORD *)buffer = 0;
      LODWORD(v33_Block_object_dispose(va, 8) = 2;
      id v35 = (const char *)_os_log_send_and_compose_impl( v80,  &v352,  0LL,  0LL,  &_mh_execute_header,  v32,  0LL,  "FAILED to delete an user to create a new one,  cannot add a new user",  buffer,  v338);
LABEL_50:
      unsigned int v36 = (char *)v35;
      if (v35) {
        sub_100053B7C(v35);
      }
      goto LABEL_187;
    }

    if (_os_feature_enabled_impl("UserManagement", "LocalUserEnrollment"))
    {
      if (qword_1000DBCE0 < 15)
      {
        v341 = a1;
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        id v49 = (id)qword_1000DBA98;
        if (os_log_type_enabled((os_log_t)v49, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)&v352.f_bsize = 0LL;
          unsigned int v50 = sub_100053B4C(1);
          uid_t v51 = (os_log_s *)v49;
          if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v52 = v50;
          }
          else {
            uint64_t v52 = v50 & 0xFFFFFFFE;
          }
          if ((_DWORD)v52)
          {
            *(_DWORD *)buffer = 67109120;
            *(_DWORD *)&buffer[4] = qword_1000DBCE0 + 1;
            stat v53 = (char *)_os_log_send_and_compose_impl( v52,  &v352,  0LL,  0LL,  &_mh_execute_header,  v51,  0LL,  "LocalUser Enrollment, creating new user adding %d user",  buffer);

            if (v53) {
              sub_100053B7C(v53);
            }
          }

          else
          {

            stat v53 = 0LL;
          }

          free(v53);
        }

        if (!dword_1000DBCE8)
        {
          dword_1000DBCE8 = 2;
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          id v72 = (id)qword_1000DBA98;
          if (os_log_type_enabled((os_log_t)v72, OS_LOG_TYPE_DEFAULT))
          {
            *(void *)&v352.f_bsize = 0LL;
            unsigned int v73 = sub_100053B4C(1);
            unsigned int v74 = (os_log_s *)v72;
            if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v75 = v73;
            }
            else {
              uint64_t v75 = v73 & 0xFFFFFFFE;
            }
            if ((_DWORD)v75)
            {
              *(_WORD *)buffer = 0;
              uint64_t v76 = (char *)_os_log_send_and_compose_impl( v75,  &v352,  0LL,  0LL,  &_mh_execute_header,  v74,  0LL,  "CHANGED DEVICE CONFIG from 0 --> 2!!",  buffer,  2);

              if (v76) {
                sub_100053B7C(v76);
              }
            }

            else
            {

              uint64_t v76 = 0LL;
            }

            free(v76);
          }

          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          id v88 = (id)qword_1000DBA98;
          if (os_log_type_enabled((os_log_t)v88, OS_LOG_TYPE_DEFAULT))
          {
            *(void *)&v352.f_bsize = 0LL;
            unsigned int v89 = sub_100053B4C(1);
            uint64_t v90 = (os_log_s *)v88;
            if (os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v91 = v89;
            }
            else {
              uint64_t v91 = v89 & 0xFFFFFFFE;
            }
            if ((_DWORD)v91)
            {
              *(_WORD *)buffer = 0;
              LODWORD(v33_Block_object_dispose(va, 8) = 2;
              uint64_t v92 = (char *)_os_log_send_and_compose_impl( v91,  &v352,  0LL,  0LL,  &_mh_execute_header,  v90,  0LL,  "Create Users mount dir if not already set",  buffer,  v338);

              if (v92) {
                sub_100053B7C(v92);
              }
            }

            else
            {

              uint64_t v92 = 0LL;
            }

            free(v92);
          }

          [(id)qword_1000DBA68 createVolumeMountsDir:@"/var/Users"];
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          id v93 = (id)qword_1000DBA98;
          if (os_log_type_enabled((os_log_t)v93, OS_LOG_TYPE_DEFAULT))
          {
            *(void *)&v352.f_bsize = 0LL;
            unsigned int v94 = sub_100053B4C(1);
            uint64_t v95 = (os_log_s *)v93;
            if (os_log_type_enabled(v95, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v96 = v94;
            }
            else {
              uint64_t v96 = v94 & 0xFFFFFFFE;
            }
            if ((_DWORD)v96)
            {
              *(_WORD *)buffer = 0;
              LODWORD(v33_Block_object_dispose(va, 8) = 2;
              id v97 = (char *)_os_log_send_and_compose_impl( v96,  &v352,  0LL,  0LL,  &_mh_execute_header,  v95,  0LL,  "Setting UMLayout Handlers",  buffer,  v338);

              if (v97) {
                sub_100053B7C(v97);
              }
            }

            else
            {

              id v97 = 0LL;
            }

            free(v97);
          }

          UMLSetInternalLogHandlers(sub_100053B4C, sub_100053B7C);
        }

LABEL_227:
        v340 = a4;
        if (dword_1000DBCE8 == 2) {
          int v98 = 503;
        }
        else {
          int v98 = 502;
        }
        if (qword_1000DBCD8)
        {
          do
          {
            uid_t v99 = v98;
            if (CFArrayGetCount((CFArrayRef)qword_1000DBCD8) < 1) {
              break;
            }
            CFIndex v100 = 0LL;
            char v101 = 0;
            do
            {
              ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)qword_1000DBCD8, v100);
              CFTypeID v103 = CFGetTypeID(ValueAtIndex);
              if (v103 == CFDictionaryGetTypeID())
              {
                Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)ValueAtIndex, kUMUserSessionIDKey);
                if (Value
                  && (uint64_t v105 = Value, v106 = CFGetTypeID(Value), v106 == CFNumberGetTypeID())
                  && CFNumberGetValue(v105, kCFNumberIntType, valuePtr))
                {
                  if (*(_DWORD *)valuePtr == v99) {
                    char v101 = 1;
                  }
                }

                else
                {
                  if (qword_1000DBAA0 != -1) {
                    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                  }
                  id v107 = (os_log_s *)(id)qword_1000DBA98;
                  if (os_log_type_enabled(v107, OS_LOG_TYPE_DEFAULT))
                  {
                    *(void *)&v352.f_bsize = 0LL;
                    unsigned int v108 = sub_100053B4C(1);
                    if (os_log_type_enabled(v107, OS_LOG_TYPE_DEFAULT)) {
                      uint64_t v109 = v108;
                    }
                    else {
                      uint64_t v109 = v108 & 0xFFFFFFFE;
                    }
                    if ((_DWORD)v109)
                    {
                      *(_DWORD *)buffer = 67109120;
                      *(_DWORD *)&buffer[4] = v99;
                      uint64_t v110 = (const char *)_os_log_send_and_compose_impl( v109,  &v352,  0LL,  0LL,  &_mh_execute_header,  v107,  0LL,  "Failed to translate session ID %u in dictionary",  buffer);
                      v111 = (char *)v110;
                      if (v110) {
                        sub_100053B7C(v110);
                      }
                    }

                    else
                    {
                      v111 = 0LL;
                    }

                    free(v111);
                  }
                }
              }

              ++v100;
            }

            while (CFArrayGetCount((CFArrayRef)qword_1000DBCD8) > v100);
            int v98 = v99 + 1;
          }

          while (v101);
        }

        else
        {
          uid_t v99 = v98;
        }

        uid_t v347 = v99;
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        a4 = v340;
        a1 = v341;
        id v112 = (id)qword_1000DBA98;
        if (os_log_type_enabled((os_log_t)v112, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)&v352.f_bsize = 0LL;
          unsigned int v113 = sub_100053B4C(1);
          uint64_t v114 = (os_log_s *)v112;
          if (os_log_type_enabled(v114, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v115 = v113;
          }
          else {
            uint64_t v115 = v113 & 0xFFFFFFFE;
          }
          if ((_DWORD)v115)
          {
            *(_DWORD *)buffer = 67109120;
            *(_DWORD *)&buffer[4] = v347;
            v116 = (char *)_os_log_send_and_compose_impl( v115,  &v352,  0LL,  0LL,  &_mh_execute_header,  v114,  0LL,  "Creating New UserSession with uid %d",  buffer);

            if (v116) {
              sub_100053B7C(v116);
            }
          }

          else
          {

            v116 = 0LL;
          }

          free(v116);
        }

        CFDataRef v54 = sub_10008428C();
        CFNumberRef v117 = CFNumberCreate(0LL, kCFNumberIntType, &v347);
        CFDictionarySetValue(v54, kUMUserSessionIDKey, v117);
        CFRelease(v117);
        gid_t v346 = v347;
        CFNumberRef v118 = CFNumberCreate(0LL, kCFNumberIntType, &v346);
        CFDictionarySetValue(v54, kUMUserSessionGroupIDKey, v118);
        CFRelease(v118);
        CFDictionarySetValue(v54, kUMUserSessionTypeKey, kUMUserSessionManagedDevice);
        ++qword_1000DACC0;
        CFNumberRef v119 = CFNumberCreate(0LL, kCFNumberLongLongType, &qword_1000DACC0);
        CFDictionarySetValue(v54, kUMUserSessionAPNSIDKey, v119);
        CFRelease(v119);
        if (dword_1000DBCE8 == 1) {
          snprintf((char *)&v352, 0x400uLL, "euser%d");
        }
        else {
          snprintf((char *)&v352, 0x400uLL, "user%d");
        }
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        id v120 = (id)qword_1000DBA98;
        if (os_log_type_enabled((os_log_t)v120, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)int valuePtr = 0LL;
          unsigned int v121 = sub_100053B4C(1);
          unsigned __int8 v122 = (os_log_s *)v120;
          if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v123 = v121;
          }
          else {
            uint64_t v123 = v121 & 0xFFFFFFFE;
          }
          if ((_DWORD)v123)
          {
            *(_DWORD *)buffer = 136315138;
            *(void *)&buffer[4] = &v352;
            id v124 = (char *)_os_log_send_and_compose_impl( v123,  valuePtr,  0LL,  0LL,  &_mh_execute_header,  v122,  0LL,  "creating with shortname %s",  buffer);

            if (v124) {
              sub_100053B7C(v124);
            }
          }

          else
          {

            id v124 = 0LL;
          }

          free(v124);
          a1 = v341;
        }

        CFStringRef v125 = CFStringCreateWithCString(0LL, (const char *)&v352, 0x8000100u);
        CFDictionarySetValue(v54, kUMUserSessionShortNameKey, v125);
        v126 = kUMUserSessionNameKey;
        CFTypeID TypeID = CFStringGetTypeID();
        unsigned int v128 = kUMUserSessionFirstNameKey;
        CFTypeID v129 = CFStringGetTypeID();
        sub_10002789C(v54, a1, v128, v129);
        int v130 = kUMUserSessionLastNameKey;
        CFTypeID v131 = CFStringGetTypeID();
        sub_10002789C(v54, a1, v130, v131);
        uint64_t v132 = kUMUserSessionDisplayNameKey;
        CFTypeID v133 = CFStringGetTypeID();
        sub_10002789C(v54, a1, v132, v133);
        if (_os_feature_enabled_impl("UserManagement", "LocalUserEnrollment"))
        {
          if (!CFDictionaryContainsKey(v54, kUMUserSessionNameKey)) {
            CFDictionarySetValue(v54, kUMUserSessionNameKey, v125);
          }
          if (!CFDictionaryContainsKey(v54, kUMUserSessionDisplayNameKey)) {
            CFDictionarySetValue(v54, kUMUserSessionDisplayNameKey, v125);
          }
        }

        int v134 = CFDictionaryContainsKey(a1, kUMUserSessionLanguageKey);
        v135 = kUMUserSessionLanguageKey;
        if (v134)
        {
          CFTypeID v136 = CFStringGetTypeID();
          sub_10002789C(v54, a1, v135, v136);
          if (!v125) {
            goto LABEL_290;
          }
        }

        else
        {
          CFDictionarySetValue(v54, kUMUserSessionLanguageKey, @"en_US");
          if (!v125)
          {
LABEL_290:
            if ((_os_feature_enabled_impl("UserManagement", "LocalUserEnrollment") & 1) != 0
              || (char v137 = kUMUserSessionUUIDKey,
                  CFTypeID v138 = CFStringGetTypeID(),
                  !sub_10002789C(v54, a1, v137, v138)))
            {
              if (qword_1000DBAA0 != -1) {
                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
              }
              id v139 = (id)qword_1000DBA98;
              if (os_log_type_enabled((os_log_t)v139, OS_LOG_TYPE_DEFAULT))
              {
                char v140 = a1;
                *(void *)buffer = 0LL;
                unsigned int v141 = sub_100053B4C(1);
                int v142 = (os_log_s *)v139;
                if (os_log_type_enabled(v142, OS_LOG_TYPE_DEFAULT)) {
                  uint64_t v143 = v141;
                }
                else {
                  uint64_t v143 = v141 & 0xFFFFFFFE;
                }
                if ((_DWORD)v143)
                {
                  *(_WORD *)int valuePtr = 0;
                  LODWORD(v33_Block_object_dispose(va, 8) = 2;
                  id v144 = (char *)_os_log_send_and_compose_impl( v143,  buffer,  0LL,  0LL,  &_mh_execute_header,  v142,  0LL,  "Generating a new UUID for the User",  valuePtr,  v338);

                  if (v144) {
                    sub_100053B7C(v144);
                  }
                }

                else
                {

                  id v144 = 0LL;
                }

                free(v144);
                a1 = v140;
              }

              unsigned int v145 = CFUUIDCreate(0LL);
              CFStringRef v146 = CFUUIDCreateString(0LL, v145);
              CFDictionarySetValue(v54, kUMUserSessionUUIDKey, v146);
            }

            if (!CFDictionaryContainsKey(a1, kUMUserSessionAlternateDSIDKey)
              || (uint64_t v147 = kUMUserSessionAlternateDSIDKey,
                  CFTypeID v148 = CFStringGetTypeID(),
                  !sub_10002789C(v54, a1, v147, v148)))
            {
              if (qword_1000DBAA0 != -1) {
                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
              }
              id v149 = (id)qword_1000DBA98;
              if (os_log_type_enabled((os_log_t)v149, OS_LOG_TYPE_DEFAULT))
              {
                unsigned int v150 = a1;
                *(void *)buffer = 0LL;
                unsigned int v151 = sub_100053B4C(1);
                uint64_t v152 = (os_log_s *)v149;
                if (os_log_type_enabled(v152, OS_LOG_TYPE_DEFAULT)) {
                  uint64_t v153 = v151;
                }
                else {
                  uint64_t v153 = v151 & 0xFFFFFFFE;
                }
                if ((_DWORD)v153)
                {
                  *(_WORD *)int valuePtr = 0;
                  LODWORD(v33_Block_object_dispose(va, 8) = 2;
                  CFNumberRef v154 = (char *)_os_log_send_and_compose_impl( v153,  buffer,  0LL,  0LL,  &_mh_execute_header,  v152,  0LL,  "Generating a new Alternate UUID for the User",  valuePtr,  v338);

                  if (v154) {
                    sub_100053B7C(v154);
                  }
                }

                else
                {

                  CFNumberRef v154 = 0LL;
                }

                free(v154);
                a1 = v150;
              }

              CFNumberRef v155 = CFUUIDCreate(0LL);
              CFStringRef v156 = CFUUIDCreateString(0LL, v155);
              CFDictionarySetValue(v54, kUMUserSessionAlternateDSIDKey, v156);
              if (v155) {
                CFRelease(v155);
              }
              if (v156) {
                CFRelease(v156);
              }
            }

            if (CFDictionaryContainsKey(a1, kUMUserSessionFileInfoKey))
            {
              v157 = kUMUserSessionFileInfoKey;
              CFTypeID v158 = CFStringGetTypeID();
              sub_10002789C(v54, a1, v157, v158);
            }

            if (CFDictionaryContainsKey(a1, kUMUserSessionOpaqueDataKey))
            {
              CFNumberRef v159 = kUMUserSessionOpaqueDataKey;
              CFTypeID v160 = CFDataGetTypeID();
              sub_10002789C(v54, a1, v159, v160);
            }

            CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
            CFDateRef v162 = CFDateCreate(kCFAllocatorDefault, Current);
            CFDictionarySetValue(v54, kUMUserSessionCreateTimeStampKey, v162);
            CFDictionarySetValue(v54, kUMUserSessionLoginTimeStampKey, v162);
            if (v162) {
              CFRelease(v162);
            }
            CFDictionarySetValue(v54, kUMUserSessionForegroundKey, kCFBooleanFalse);
            if (v347 == 502) {
              CFBooleanRef v163 = kCFBooleanTrue;
            }
            else {
              CFBooleanRef v163 = kCFBooleanFalse;
            }
            CFDictionarySetValue(v54, kUMUserSessionLoginUserKey, v163);
            CFDictionarySetValue(v54, kUMUserSessionDirtyKey, kCFBooleanFalse);
            CFDictionarySetValue(v54, kUMUserSessionDisabledKey, kCFBooleanFalse);
            BOOL v11 = 0;
            goto LABEL_333;
          }
        }

        CFRelease(v125);
        goto LABEL_290;
      }

      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      unsigned int v27 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)&v352.f_bsize = 0LL;
        unsigned int v28 = sub_100053B4C(1);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v29 = v28;
        }
        else {
          uint64_t v29 = v28 & 0xFFFFFFFE;
        }
        if ((_DWORD)v29)
        {
          *(_WORD *)buffer = 0;
          id v30 = (const char *)_os_log_send_and_compose_impl( v29,  &v352,  0LL,  0LL,  &_mh_execute_header,  v27,  0LL,  "Device already has 15 users, the maximum allowed with LocalUser Enrollment.",  buffer,  2);
          unsigned int v31 = (char *)v30;
          if (v30) {
            sub_100053B7C(v30);
          }
        }

        else
        {
          unsigned int v31 = 0LL;
        }

        free(v31);
      }

      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      int v40 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_134;
      }
      *(void *)&v352.f_bsize = 0LL;
      unsigned int v69 = sub_100053B4C(1);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v70 = v69;
      }
      else {
        uint64_t v70 = v69 & 0xFFFFFFFE;
      }
      if ((_DWORD)v70)
      {
        *(_WORD *)buffer = 0;
        LODWORD(v33_Block_object_dispose(va, 8) = 2;
        unsigned int v43 = (const char *)_os_log_send_and_compose_impl( v70,  &v352,  0LL,  0LL,  &_mh_execute_header,  v40,  0LL,  "Cannot support more users, Delete some to make room for new ones. Bailing...",  buffer,  v338);
LABEL_130:
        uint64_t v71 = (char *)v43;
        if (v43) {
          sub_100053B7C(v43);
        }
        goto LABEL_133;
      }
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      int v40 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_134;
      }
      *(void *)&v352.f_bsize = 0LL;
      unsigned int v41 = sub_100053B4C(1);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v42 = v41;
      }
      else {
        uint64_t v42 = v41 & 0xFFFFFFFE;
      }
      if ((_DWORD)v42)
      {
        *(_WORD *)buffer = 0;
        unsigned int v43 = (const char *)_os_log_send_and_compose_impl( v42,  &v352,  0LL,  0LL,  &_mh_execute_header,  v40,  0LL,  "Not in Shared iPad, user creation not allowed",  buffer,  2);
        goto LABEL_130;
      }
    }

    uint64_t v71 = 0LL;
LABEL_133:
    free(v71);
LABEL_134:

    int v26 = -12;
    goto LABEL_572;
  }

  unsigned int v10 = sub_100083DA4(v8, @"MKBUserSessionFileSystemSet");
  BOOL v11 = v10 != 0;
  uid_t v12 = sub_100083C6C((const __CFDictionary *)v9, kUMUserSessionIDKey);
  uid_t v347 = v12;
  gid_t v346 = sub_100083C6C((const __CFDictionary *)v9, kUMUserSessionGroupIDKey);
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v13 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v13, OS_LOG_TYPE_DEFAULT))
  {
    int v14 = (const __CFDictionary *)v9;
    id v15 = a4;
    uint64_t v16 = a1;
    *(void *)&v352.f_bsize = 0LL;
    unsigned int v17 = sub_100053B4C(1);
    int v18 = (os_log_s *)v13;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v19 = v17;
    }
    else {
      uint64_t v19 = v17 & 0xFFFFFFFE;
    }
    if ((_DWORD)v19)
    {
      *(_DWORD *)buffer = 67109120;
      *(_DWORD *)&buffer[4] = v12;
      __int16 v20 = (char *)_os_log_send_and_compose_impl( v19,  &v352,  0LL,  0LL,  &_mh_execute_header,  v18,  0LL,  "loadUserSession: Found existing Session with uid:%d",  buffer);

      if (v20) {
        sub_100053B7C(v20);
      }
    }

    else
    {

      __int16 v20 = 0LL;
    }

    a1 = v16;
    free(v20);
    a4 = v15;
    unint64_t v9 = (unint64_t)v14;
  }

  if (sub_100083DA4((const __CFDictionary *)v9, kUMUserSessionDisabledKey))
  {
    CFRelease((CFTypeRef)v9);
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v32 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_188;
    }
    *(void *)&v352.f_bsize = 0LL;
    unsigned int v33 = sub_100053B4C(1);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v34 = v33;
    }
    else {
      uint64_t v34 = v33 & 0xFFFFFFFE;
    }
    if ((_DWORD)v34)
    {
      *(_DWORD *)buffer = 67109120;
      *(_DWORD *)&buffer[4] = v347;
      id v35 = (const char *)_os_log_send_and_compose_impl( v34,  &v352,  0LL,  0LL,  &_mh_execute_header,  v32,  0LL,  "FAILED to Load usersession with uid %u as it is DISABLED USER",  buffer);
      goto LABEL_50;
    }

        unsigned int v104 = 0LL;
LABEL_228:
        free(v104);
      }
    }

    unsigned int v10 = 1LL;
    if (a2) {
      goto LABEL_163;
    }
    goto LABEL_230;
  }

  if (qword_1000DBBD8 != -1) {
    dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
  }
  uint64_t v52 = (os_log_s *)(id)qword_1000DBBD0;
  if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)__argv = 0LL;
    stat v53 = sub_100053B4C(1);
    if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT)) {
      CFDataRef v54 = v53;
    }
    else {
      CFDataRef v54 = v53 & 0xFFFFFFFE;
    }
    if ((_DWORD)v54)
    {
      *(_WORD *)uint64_t v110 = 0;
      LODWORD(v107) = 2;
      id v55 = (const char *)_os_log_send_and_compose_impl( v54,  __argv,  0LL,  0LL,  &_mh_execute_header,  v52,  0LL,  "Volume already mounted",  v110,  v107);
      unsigned int v56 = (char *)v55;
      if (v55) {
        sub_100053B7C(v55);
      }
    }

    else
    {
      unsigned int v56 = 0LL;
    }

    free(v56);
  }

  if (!a3)
  {
LABEL_162:
    unsigned int v10 = 0LL;
    if (a2) {
      goto LABEL_163;
    }
LABEL_230:
    uint64_t v105 = (const __CFString *)sub_100083DF4(a1, kUMUserSessionHomeDirKey);
    sub_10007B4DC(v105, v11, v12);
    return v10;
  }

  unsigned int v10 = 0LL;
  *a3 = 17;
  if (!a2) {
    goto LABEL_230;
  }
LABEL_163:
  if (qword_1000DBBD8 != -1) {
    dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
  }
  unsigned int v83 = (id)qword_1000DBBD0;
  if (os_log_type_enabled((os_log_t)v83, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t v110 = 0LL;
    uint64_t v84 = sub_100053B4C(1);
    unsigned int v85 = (os_log_s *)v83;
    if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v86 = v84;
    }
    else {
      uint64_t v86 = v84 & 0xFFFFFFFE;
    }
    if ((_DWORD)v86)
    {
      LOWORD(v111[0]) = 0;
      LODWORD(v107) = 2;
      uint64_t v87 = (char *)_os_log_send_and_compose_impl( v86,  v110,  0LL,  0LL,  &_mh_execute_header,  v85,  0LL,  "Skipping tmp setup...",  v111,  v107);

      if (v87) {
        sub_100053B7C(v87);
      }
    }

    else
    {

      uint64_t v87 = 0LL;
    }

    free(v87);
  }

  return v10;
}

LABEL_186:
    unsigned int v36 = 0LL;
LABEL_187:
    free(v36);
LABEL_188:

    int v26 = -4;
    goto LABEL_572;
  }

  if (!CFDictionaryContainsKey((CFDictionaryRef)v9, kUMUserSessionLanguageKey))
  {
    int v37 = CFDictionaryContainsKey(a1, kUMUserSessionLanguageKey);
    uint64_t v38 = kUMUserSessionLanguageKey;
    if (v37)
    {
      CFTypeID v39 = CFStringGetTypeID();
      sub_10002789C((__CFDictionary *)v9, a1, v38, v39);
    }

    else
    {
      CFDictionarySetValue((CFMutableDictionaryRef)v9, kUMUserSessionLanguageKey, @"en_US");
    }
  }

  if (v347 == 501)
  {
    CFDataRef v54 = (__CFDictionary *)v9;
    if (v10) {
      goto LABEL_333;
    }
    CFDictionarySetValue((CFMutableDictionaryRef)v9, @"MKBUserSessionFileSystemSet", kCFBooleanTrue);
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v55 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v55, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)&v352.f_bsize = 0LL;
      unsigned int v56 = sub_100053B4C(1);
      vm_size_t v57 = (os_log_s *)v55;
      if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v58 = v56;
      }
      else {
        uint64_t v58 = v56 & 0xFFFFFFFE;
      }
      if ((_DWORD)v58)
      {
        *(_WORD *)buffer = 0;
        uint64_t v59 = (char *)_os_log_send_and_compose_impl( v58,  &v352,  0LL,  0LL,  &_mh_execute_header,  v57,  0LL,  "Set Primary User 501 with FileSystem..",  buffer,  2);

        if (v59) {
          sub_100053B7C(v59);
        }
      }

      else
      {

        uint64_t v59 = 0LL;
      }

      free(v59);
    }

    BOOL v11 = 1;
  }

  CFDataRef v54 = (__CFDictionary *)v9;
LABEL_333:
  uint64_t v164 = sub_100018E80(qword_1000DBD40);
  id v165 = (void *)objc_claimAutoreleasedReturnValue(v164);
  int v166 = sub_100019B60((uint64_t)v165);
  uid_t v167 = v347;

  if (v166 != v167) {
    CFDictionarySetValue(v54, kUMUserSessionForegroundKey, kCFBooleanFalse);
  }
  if (CFDictionaryContainsKey(a1, kUMUserSessionRequiresPasscodeKey)) {
    int v168 = sub_100083C6C(a1, kUMUserSessionRequiresPasscodeKey);
  }
  else {
    int v168 = 60;
  }
  v169 = a4;
  int v345 = v168;
  if (!v11)
  {
    uint64_t v172 = CFUUIDCreate(0LL);
    v173 = CFUUIDCreateString(0LL, v172);
    if (v172) {
      CFRelease(v172);
    }
    bzero(buffer, 0x400uLL);
    CFStringGetCString(v173, buffer, 1024LL, 0x8000100u);
    if ((_os_feature_enabled_impl("UserManagement", "LocalUserEnrollment") & 1) != 0
      || dword_1000DBCE8 == 1 && v347 != 502)
    {
      LODWORD(v344[0]) = 0;
      if (![(id)qword_1000DBA68 createVolumeWithSession:v54 size:qword_1000DBD10 << 20 userName:v173 error:v344 forPersona:0 userDataVolume:1])
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        id v179 = (id)qword_1000DBA98;
        if (os_log_type_enabled((os_log_t)v179, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)int valuePtr = 0LL;
          unsigned int v180 = sub_100053B4C(1);
          v181 = (os_log_s *)v179;
          if (os_log_type_enabled(v181, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v182 = v180;
          }
          else {
            uint64_t v182 = v180 & 0xFFFFFFFE;
          }
          if ((_DWORD)v182)
          {
            LODWORD(v350[0]) = 67109120;
            HIDWORD(v350[0]) = v344[0];
            id v183 = (char *)_os_log_send_and_compose_impl( v182,  valuePtr,  0LL,  0LL,  &_mh_execute_header,  v181,  0LL,  "FAILED TO CREATE APFS VOLUME with error:%d, failing the creation of usersession",  v350);

            if (v183) {
              sub_100053B7C(v183);
            }
          }

          else
          {

            id v183 = 0LL;
          }

          free(v183);
        }

        int v26 = v344[0];
        if (v54) {
          CFRelease(v54);
        }
        if (v173) {
          CFRelease(v173);
        }
        a4 = v169;
        goto LABEL_572;
      }

      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      id v174 = (id)qword_1000DBA98;
      if (os_log_type_enabled((os_log_t)v174, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)int valuePtr = 0LL;
        unsigned int v175 = sub_100053B4C(1);
        v176 = (os_log_s *)v174;
        if (os_log_type_enabled(v176, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v177 = v175;
        }
        else {
          uint64_t v177 = v175 & 0xFFFFFFFE;
        }
        if ((_DWORD)v177)
        {
          LOWORD(v350[0]) = 0;
          LODWORD(v33_Block_object_dispose(va, 8) = 2;
          v178 = (char *)_os_log_send_and_compose_impl( v177,  valuePtr,  0LL,  0LL,  &_mh_execute_header,  v176,  0LL,  "Created new APFS volume",  v350,  v338);

          if (v178) {
            sub_100053B7C(v178);
          }
        }

        else
        {

          v178 = 0LL;
        }

        free(v178);
      }

      bzero(&v352, 0x400uLL);
      if ((_os_feature_enabled_impl("UserManagement", "LocalUserEnrollment") & 1) != 0) {
        strcpy((char *)&v352, "/var/mobile");
      }
      else {
        snprintf((char *)&v352, 0x400uLL, "/var/Users/%s", buffer);
      }
      CFStringRef v222 = CFStringCreateWithCString(0LL, (const char *)&v352, 0x8000100u);
      CFDictionarySetValue(v54, kUMUserSessionLibinfoHomeDirKey, v222);
      if (v222) {
        CFRelease(v222);
      }
      bzero(&v352, 0x400uLL);
      snprintf((char *)&v352, 0x400uLL, "/private/var/Users/%s", buffer);
      CFStringRef v223 = CFStringCreateWithCString(0LL, (const char *)&v352, 0x8000100u);
      CFDictionarySetValue(v54, kUMUserSessionHomeDirKey, v223);
      if (v223) {
        CFRelease(v223);
      }
    }

    if (!CFDictionaryContainsKey(v54, kUMUserSessionUserVolumeTypeKey)) {
      CFDictionarySetValue(v54, kUMUserSessionUserVolumeTypeKey, (const void *)qword_1000DBA88);
    }
    if (v173) {
      CFRelease(v173);
    }
    CFDataRef v224 = CFDataCreate(kCFAllocatorDefault, bytes, v343);
    BOOL v225 = sub_100028074(v54, (uint64_t)v224);
    if (v224) {
      CFRelease(v224);
    }
    if (v225)
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      id v226 = (id)qword_1000DBA98;
      if (os_log_type_enabled((os_log_t)v226, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)int valuePtr = 0LL;
        unsigned int v227 = sub_100053B4C(1);
        v228 = (os_log_s *)v226;
        if (os_log_type_enabled(v228, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v229 = v227;
        }
        else {
          uint64_t v229 = v227 & 0xFFFFFFFE;
        }
        if ((_DWORD)v229)
        {
          LOWORD(v350[0]) = 0;
          LODWORD(v33_Block_object_dispose(va, 8) = 2;
          v230 = (char *)_os_log_send_and_compose_impl( v229,  valuePtr,  0LL,  0LL,  &_mh_execute_header,  v228,  0LL,  "Successfully created Identity, loaded and logged",  v350,  v338);

          if (v230) {
            sub_100053B7C(v230);
          }
        }

        else
        {

          v230 = 0LL;
        }

        free(v230);
      }

      if (!CFDictionaryContainsKey(v54, kUMUserSessionVolumeDeviceNodeKey))
      {
LABEL_517:
        p_name = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
        if (dword_1000DBCE8 != 1)
        {
LABEL_580:
          sub_100020F1C((const char *)&v352, (char *)v347, v346);
          CFDictionarySetValue(v54, @"MKBUserSessionFileSystemSet", kCFBooleanTrue);
          goto LABEL_584;
        }

        if (v345 >= 1 && (CFNumberRef v247 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v345)) != 0LL)
        {
          CFNumberRef v248 = v247;
          CFDictionarySetValue(v54, kUMUserSessionRequiresPasscodeKey, v247);
          CFRelease(v248);
        }

        else
        {
          int v345 = 0;
        }

        v249 = sub_10008428C();
        v350[0] = v345;
        CFNumberRef v250 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt64Type, v350);
        if (v250)
        {
          CFNumberRef v251 = v250;
          CFDictionarySetValue(v249, @"GracePeriod", v250);
          CFRelease(v251);
        }

        int v252 = sub_10009D178(-v347, (uint64_t)bytes, v343, v249);
        if (v249) {
          CFRelease(v249);
        }
        if (v252)
        {
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          v253 = (os_log_s *)(id)qword_1000DBA98;
          if (!os_log_type_enabled(v253, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_579;
          }
          v254 = (const __CFDictionary *)v9;
          v344[0] = 0LL;
          unsigned int v255 = sub_100053B4C(1);
          v253 = v253;
          if (os_log_type_enabled(v253, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v256 = v255;
          }
          else {
            uint64_t v256 = v255 & 0xFFFFFFFE;
          }
          if ((_DWORD)v256)
          {
            *(_DWORD *)int valuePtr = 67109632;
            *(_DWORD *)&valuePtr[4] = v345;
            *(_WORD *)&valuePtr[8] = 1024;
            *(_DWORD *)&valuePtr[10] = v347;
            LOWORD(v349) = 1024;
            *(_DWORD *)((char *)&v349 + 2) = v252;
            v257 = (char *)_os_log_send_and_compose_impl( v256,  v344,  0LL,  0LL,  &_mh_execute_header,  v253,  0LL,  "FAILED TO SET AKS update Graceperiod of %d secs FOR USER:%d with error:%d",  valuePtr,  20,  v339);

            if (v257) {
              sub_100053B7C(v257);
            }
          }

          else
          {

            v257 = 0LL;
          }

          unint64_t v9 = (unint64_t)v254;
        }

        else
        {
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          v253 = (os_log_s *)(id)qword_1000DBA98;
          if (!os_log_type_enabled(v253, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_579;
          }
          v344[0] = 0LL;
          unsigned int v258 = sub_100053B4C(1);
          v253 = v253;
          if (os_log_type_enabled(v253, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v259 = v258;
          }
          else {
            uint64_t v259 = v258 & 0xFFFFFFFE;
          }
          if ((_DWORD)v259)
          {
            *(_DWORD *)int valuePtr = 67109376;
            *(_DWORD *)&valuePtr[4] = v347;
            *(_WORD *)&valuePtr[8] = 1024;
            *(_DWORD *)&valuePtr[10] = v345;
            v257 = (char *)_os_log_send_and_compose_impl( v259,  v344,  0LL,  0LL,  &_mh_execute_header,  v253,  0LL,  "SUCCESSFUL AKS update of Graceperiod FOR USER:%d with %d secs",  valuePtr,  14);

            if (v257) {
              sub_100053B7C(v257);
            }
          }

          else
          {

            v257 = 0LL;
          }
        }

        free(v257);
LABEL_579:

        p_name = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
        goto LABEL_580;
      }

      if ([(id)qword_1000DBA68 mountVolumeWithSession:v54 mountPath:0 error:0 forPersona:0])
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        v236 = (os_log_s *)(id)qword_1000DBA98;
        if (!os_log_type_enabled(v236, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_516;
        }
        *(void *)int valuePtr = 0LL;
        unsigned int v237 = sub_100053B4C(1);
        v236 = v236;
        if (os_log_type_enabled(v236, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v238 = v237;
        }
        else {
          uint64_t v238 = v237 & 0xFFFFFFFE;
        }
        if ((_DWORD)v238)
        {
          LOWORD(v350[0]) = 0;
          LODWORD(v33_Block_object_dispose(va, 8) = 2;
          uint64_t v239 = _os_log_send_and_compose_impl( v238,  valuePtr,  0LL,  0LL,  &_mh_execute_header,  v236,  0LL,  "APFSUser Volume mounted at home directory",  v350,  v338);
          goto LABEL_493;
        }
      }

      else
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        v236 = (os_log_s *)(id)qword_1000DBA98;
        if (!os_log_type_enabled(v236, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_516;
        }
        *(void *)int valuePtr = 0LL;
        unsigned int v240 = sub_100053B4C(1);
        v236 = v236;
        if (os_log_type_enabled(v236, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v241 = v240;
        }
        else {
          uint64_t v241 = v240 & 0xFFFFFFFE;
        }
        if ((_DWORD)v241)
        {
          LOWORD(v350[0]) = 0;
          LODWORD(v33_Block_object_dispose(va, 8) = 2;
          uint64_t v239 = _os_log_send_and_compose_impl( v241,  valuePtr,  0LL,  0LL,  &_mh_execute_header,  v236,  0LL,  "APFSUser Volume failed to mount",  v350,  v338);
LABEL_493:
          v242 = (char *)v239;

          if (v242) {
            sub_100053B7C(v242);
          }
          goto LABEL_515;
        }
      }

      v242 = 0LL;
LABEL_515:
      free(v242);
LABEL_516:

      goto LABEL_517;
    }

    LODWORD(v344[0]) = 0;
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v231 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v231, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)int valuePtr = 0LL;
      unsigned int v232 = sub_100053B4C(1);
      v233 = (os_log_s *)v231;
      if (os_log_type_enabled(v233, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v234 = v232;
      }
      else {
        uint64_t v234 = v232 & 0xFFFFFFFE;
      }
      if ((_DWORD)v234)
      {
        LOWORD(v350[0]) = 0;
        LODWORD(v33_Block_object_dispose(va, 8) = 2;
        v235 = (char *)_os_log_send_and_compose_impl( v234,  valuePtr,  0LL,  0LL,  &_mh_execute_header,  v233,  0LL,  "Failed to load & login Identity, deleting volume",  v350,  v338);

        if (v235) {
          sub_100053B7C(v235);
        }
      }

      else
      {

        v235 = 0LL;
      }

      free(v235);
    }

    a4 = v169;
    if ([(id)qword_1000DBA68 deleteVolumeWithSession:v54 error:v344])
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      v199 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v199, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_569;
      }
      *(void *)int valuePtr = 0LL;
      unsigned int v260 = sub_100053B4C(1);
      v199 = v199;
      if (os_log_type_enabled(v199, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v261 = v260;
      }
      else {
        uint64_t v261 = v260 & 0xFFFFFFFE;
      }
      if ((_DWORD)v261)
      {
        LOWORD(v350[0]) = 0;
        uint64_t v262 = _os_log_send_and_compose_impl( v261,  valuePtr,  0LL,  0LL,  &_mh_execute_header,  v199,  0LL,  "Volume Deleted!");
        goto LABEL_564;
      }
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      v199 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v199, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_569;
      }
      *(void *)int valuePtr = 0LL;
      unsigned int v263 = sub_100053B4C(1);
      v199 = v199;
      if (os_log_type_enabled(v199, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v264 = v263;
      }
      else {
        uint64_t v264 = v263 & 0xFFFFFFFE;
      }
      if ((_DWORD)v264)
      {
        LODWORD(v350[0]) = 67109120;
        HIDWORD(v350[0]) = v344[0];
        uint64_t v262 = _os_log_send_and_compose_impl( v264,  valuePtr,  0LL,  0LL,  &_mh_execute_header,  v199,  0LL,  "Volume delete failed with error:%d",  v350);
LABEL_564:
        v265 = (const char *)v262;

        if (v265) {
          sub_100053B7C(v265);
        }
        goto LABEL_567;
      }
    }

    v265 = 0LL;
LABEL_567:
    v243 = (char *)v265;
    goto LABEL_568;
  }

  if (bytes)
  {
    CFNumberRef v170 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v345);
    if (CFDictionaryContainsKey(v54, kUMUserSessionRequiresPasscodeKey))
    {
      int v171 = sub_100083C6C(v54, kUMUserSessionRequiresPasscodeKey);
      if (v171 != v345)
      {
        if (v345) {
          CFDictionaryReplaceValue(v54, kUMUserSessionRequiresPasscodeKey, v170);
        }
        else {
          CFDictionaryRemoveValue(v54, kUMUserSessionRequiresPasscodeKey);
        }
      }
    }

    else if (v345 >= 1)
    {
      CFDictionarySetValue(v54, kUMUserSessionRequiresPasscodeKey, v170);
    }

    if (v170) {
      CFRelease(v170);
    }
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v184 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v184, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)int valuePtr = 0LL;
    unsigned int v185 = sub_100053B4C(1);
    v186 = (os_log_s *)v184;
    if (os_log_type_enabled(v186, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v187 = v185;
    }
    else {
      uint64_t v187 = v185 & 0xFFFFFFFE;
    }
    if ((_DWORD)v187)
    {
      v188 = "NULL";
      if (v343) {
        BOOL v189 = bytes == 0LL;
      }
      else {
        BOOL v189 = 1;
      }
      if (!v189) {
        v188 = "SECRET";
      }
      *(_DWORD *)buffer = 136315138;
      *(void *)&buffer[4] = v188;
      v190 = (char *)_os_log_send_and_compose_impl( v187,  valuePtr,  0LL,  0LL,  &_mh_execute_header,  v186,  0LL,  "load existing user OTI and unlock with passcode %s",  buffer);

      if (v190) {
        sub_100053B7C(v190);
      }
    }

    else
    {

      v190 = 0LL;
    }

    free(v190);
  }

  v191 = (const __CFDictionary *)v9;

  CFDataRef v192 = CFDataCreate(kCFAllocatorDefault, bytes, v343);
  int v193 = sub_1000288F0(v54, (uint64_t)v192);
  if (v192) {
    CFRelease(v192);
  }
  if (!v193)
  {
    a4 = v169;
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    v199 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v199, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_569;
    }
    *(void *)buffer = 0LL;
    unsigned int v200 = sub_100053B4C(1);
    v201 = v199;
    if (os_log_type_enabled(v201, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v202 = v200;
    }
    else {
      uint64_t v202 = v200 & 0xFFFFFFFE;
    }
    if ((_DWORD)v202)
    {
      *(_WORD *)int valuePtr = 0;
      LODWORD(v33_Block_object_dispose(va, 8) = 2;
      v203 = (const char *)_os_log_send_and_compose_impl( v202,  buffer,  0LL,  0LL,  &_mh_execute_header,  v201,  0LL,  "Failed to login Identity, bailing",  valuePtr,  v338);

      if (v203) {
        sub_100053B7C(v203);
      }
    }

    else
    {

      v203 = 0LL;
    }

    v243 = (char *)v203;
LABEL_568:
    free(v243);
LABEL_569:

    if (v54) {
      CFRelease(v54);
    }
    int v26 = 22;
    goto LABEL_572;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v194 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v194, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)buffer = 0LL;
    unsigned int v195 = sub_100053B4C(1);
    v196 = (os_log_s *)v194;
    if (os_log_type_enabled(v196, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v197 = v195;
    }
    else {
      uint64_t v197 = v195 & 0xFFFFFFFE;
    }
    if ((_DWORD)v197)
    {
      *(_WORD *)int valuePtr = 0;
      LODWORD(v33_Block_object_dispose(va, 8) = 2;
      v198 = (char *)_os_log_send_and_compose_impl( v197,  buffer,  0LL,  0LL,  &_mh_execute_header,  v196,  0LL,  "Successful Identity setup completed",  valuePtr,  v338);

      if (v198) {
        sub_100053B7C(v198);
      }
    }

    else
    {

      v198 = 0LL;
    }

    free(v198);
  }

  uint64_t v204 = sub_100018E80(qword_1000DBD40);
  v205 = (void *)objc_claimAutoreleasedReturnValue(v204);
  if ((sub_100019ADC((uint64_t)v205) & 1) != 0 || v347 != -1)
  {
    uint64_t v206 = sub_100018E80(qword_1000DBD40);
    v207 = (void *)objc_claimAutoreleasedReturnValue(v206);
    int v208 = sub_100019B60((uint64_t)v207);
    uid_t v209 = v347;

    BOOL v189 = v208 == v209;
    unint64_t v9 = (unint64_t)v191;
    if (v189) {
      goto LABEL_417;
    }
    int v215 = CFDictionaryContainsKey(v54, kUMUserSessionVolumeDeviceNodeKey);
    p_name = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
    if (!v215) {
      goto LABEL_584;
    }
    if ([(id)qword_1000DBA68 mountVolumeWithSession:v54 mountPath:0 error:0 forPersona:0])
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      v217 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v217, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_583;
      }
      *(void *)buffer = 0LL;
      unsigned int v218 = sub_100053B4C(1);
      v219 = v217;
      if (os_log_type_enabled(v219, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v220 = v218;
      }
      else {
        uint64_t v220 = v218 & 0xFFFFFFFE;
      }
      if ((_DWORD)v220)
      {
        *(_WORD *)int valuePtr = 0;
        LODWORD(v33_Block_object_dispose(va, 8) = 2;
        uint64_t v221 = _os_log_send_and_compose_impl( v220,  buffer,  0LL,  0LL,  &_mh_execute_header,  v219,  0LL,  "APFSUser Volume mounted at home directory",  valuePtr,  v338);
        goto LABEL_512;
      }
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      v217 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v217, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_583;
      }
      *(void *)buffer = 0LL;
      unsigned int v244 = sub_100053B4C(1);
      v219 = v217;
      if (os_log_type_enabled(v219, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v245 = v244;
      }
      else {
        uint64_t v245 = v244 & 0xFFFFFFFE;
      }
      if ((_DWORD)v245)
      {
        *(_WORD *)int valuePtr = 0;
        LODWORD(v33_Block_object_dispose(va, 8) = 2;
        uint64_t v221 = _os_log_send_and_compose_impl( v245,  buffer,  0LL,  0LL,  &_mh_execute_header,  v219,  0LL,  "APFSUser Volume failed to mount",  valuePtr,  v338);
LABEL_512:
        v246 = (char *)v221;

        if (v246) {
          sub_100053B7C(v246);
        }
        goto LABEL_582;
      }
    }

    v246 = 0LL;
LABEL_582:
    free(v246);
    unint64_t v9 = (unint64_t)v191;
LABEL_583:

    goto LABEL_584;
  }

  unint64_t v9 = (unint64_t)v191;
LABEL_417:
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v210 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v210, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)buffer = 0LL;
    unsigned int v211 = sub_100053B4C(1);
    v212 = (os_log_s *)v210;
    if (os_log_type_enabled(v212, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v213 = v211;
    }
    else {
      uint64_t v213 = v211 & 0xFFFFFFFE;
    }
    if ((_DWORD)v213)
    {
      *(_WORD *)int valuePtr = 0;
      LODWORD(v33_Block_object_dispose(va, 8) = 2;
      v214 = (char *)_os_log_send_and_compose_impl( v213,  buffer,  0LL,  0LL,  &_mh_execute_header,  v212,  0LL,  "CurrentUser is also the loading Session, skip mounting volume",  valuePtr,  v338);

      if (v214) {
        sub_100053B7C(v214);
      }
    }

    else
    {

      v214 = 0LL;
    }

    free(v214);
    unint64_t v9 = (unint64_t)v191;
  }

  p_name = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
LABEL_584:
  v267 = (const __CFString *)sub_100083DF4(v54, kUMUserSessionHomeDirKey);
  sub_10007B4DC(v267, v347, v346);
  if (*((_DWORD *)p_name + 826) != 1)
  {
    if (!_os_feature_enabled_impl("UserManagement", "LocalUserEnrollment")
      || (uint64_t v274 = sub_100018E80(qword_1000DBD40),
          v275 = (void *)objc_claimAutoreleasedReturnValue(v274),
          int v276 = sub_100019B60((uint64_t)v275),
          uid_t v277 = v347,
          v275,
          v276 == v277))
    {
LABEL_674:
      if (v9) {
        return v54;
      }
      goto LABEL_675;
    }

    LODWORD(v350[0]) = 0;
    if ([(id)qword_1000DBA68 unmountVolumeWithSession:v54 mountPath:0 error:v350 force:1])
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      v278 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v278, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_673;
      }
      *(void *)int valuePtr = 0LL;
      unsigned int v279 = sub_100053B4C(1);
      v278 = v278;
      if (os_log_type_enabled(v278, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v280 = v279;
      }
      else {
        uint64_t v280 = v279 & 0xFFFFFFFE;
      }
      if ((_DWORD)v280)
      {
        LOWORD(v344[0]) = 0;
        LODWORD(v33_Block_object_dispose(va, 8) = 2;
        uint64_t v281 = _os_log_send_and_compose_impl( v280,  valuePtr,  0LL,  0LL,  &_mh_execute_header,  v278,  0LL,  "APFSUser Volume Unmounted at home directory",  v344,  v338);
        goto LABEL_615;
      }
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      v278 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v278, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_673;
      }
      *(void *)int valuePtr = 0LL;
      unsigned int v282 = sub_100053B4C(1);
      v278 = v278;
      if (os_log_type_enabled(v278, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v283 = v282;
      }
      else {
        uint64_t v283 = v282 & 0xFFFFFFFE;
      }
      if ((_DWORD)v283)
      {
        LOWORD(v344[0]) = 0;
        LODWORD(v33_Block_object_dispose(va, 8) = 2;
        uint64_t v281 = _os_log_send_and_compose_impl( v283,  valuePtr,  0LL,  0LL,  &_mh_execute_header,  v278,  0LL,  "APFSUser Volume Unmount failed to mount",  v344,  v338);
LABEL_615:
        v284 = (char *)v281;

        if (v284) {
          sub_100053B7C(v284);
        }
        goto LABEL_640;
      }
    }

    v284 = 0LL;
LABEL_640:
    free(v284);
LABEL_673:

    goto LABEL_674;
  }

  if (!byte_1000DACB8)
  {
LABEL_662:
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    v278 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v278, OS_LOG_TYPE_DEFAULT))
    {
      v303 = (const __CFDictionary *)v9;
      v350[0] = 0LL;
      LODWORD(v9) = sub_100053B4C(1);
      v304 = v278;
      if (os_log_type_enabled(v304, OS_LOG_TYPE_DEFAULT)) {
        unint64_t v9 = v9;
      }
      else {
        unint64_t v9 = v9 & 0xFFFFFFFE;
      }
      if ((_DWORD)v9)
      {
        int v305 = byte_1000DACB8;
        unsigned int v306 = sub_100083DA4(v54, kUMUserSessionHasSyncBagKey);
        *(_DWORD *)int valuePtr = 67109376;
        *(_DWORD *)&valuePtr[4] = v305;
        *(_WORD *)&valuePtr[8] = 1024;
        *(_DWORD *)&valuePtr[10] = v306;
        v307 = (char *)_os_log_send_and_compose_impl( v9,  v350,  0LL,  0LL,  &_mh_execute_header,  v304,  0LL,  "ALREADY HAS SYNC BAG or not APFS NATIVE VOLUME:%d,%d",  valuePtr,  14);

        if (v307) {
          sub_100053B7C(v307);
        }
      }

      else
      {

        v307 = 0LL;
      }

      free(v307);
      unint64_t v9 = (unint64_t)v303;
    }

    goto LABEL_673;
  }

  if (sub_100083DA4(v54, kUMUserSessionHasSyncBagKey) == 1)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v268 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v268, OS_LOG_TYPE_DEFAULT))
    {
      v269 = (const __CFDictionary *)v9;
      *(void *)int valuePtr = 0LL;
      unsigned int v270 = sub_100053B4C(1);
      v271 = (os_log_s *)v268;
      if (os_log_type_enabled(v271, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v272 = v270;
      }
      else {
        uint64_t v272 = v270 & 0xFFFFFFFE;
      }
      if ((_DWORD)v272)
      {
        LOWORD(v350[0]) = 0;
        LODWORD(v33_Block_object_dispose(va, 8) = 2;
        v273 = (char *)_os_log_send_and_compose_impl( v272,  valuePtr,  0LL,  0LL,  &_mh_execute_header,  v271,  0LL,  "The user has Syncbag, verifying its existence",  v350,  v338);

        if (v273) {
          sub_100053B7C(v273);
        }
      }

      else
      {

        v273 = 0LL;
      }

      free(v273);
      unint64_t v9 = (unint64_t)v269;
    }

    uint64_t v285 = v347;
    if (sub_100083DA4(v54, kUMUserSessionHasSyncBagKey))
    {
      if (MKBUserSessionVerifySyncBagForUser(v54, v285))
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        id v286 = (id)qword_1000DBA98;
        if (os_log_type_enabled((os_log_t)v286, OS_LOG_TYPE_DEFAULT))
        {
          v287 = (const __CFDictionary *)v9;
          *(void *)int valuePtr = 0LL;
          unsigned int v288 = sub_100053B4C(1);
          v289 = (os_log_s *)v286;
          if (os_log_type_enabled(v289, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v290 = v288;
          }
          else {
            uint64_t v290 = v288 & 0xFFFFFFFE;
          }
          if ((_DWORD)v290)
          {
            LODWORD(v350[0]) = 67109120;
            HIDWORD(v350[0]) = v347;
            v291 = (char *)_os_log_send_and_compose_impl( v290,  valuePtr,  0LL,  0LL,  &_mh_execute_header,  v289,  0LL,  "User %d has no valid Syncbag will need to create a new syncbag entry",  v350);

            if (v291) {
              sub_100053B7C(v291);
            }
          }

          else
          {

            v291 = 0LL;
          }

          free(v291);
          unint64_t v9 = (unint64_t)v287;
        }

        CFDictionarySetValue(v54, kUMUserSessionHasSyncBagKey, kCFBooleanFalse);
        goto LABEL_660;
      }
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      v292 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v292, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)int valuePtr = 0LL;
        unsigned int v293 = sub_100053B4C(1);
        if (os_log_type_enabled(v292, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v294 = v293;
        }
        else {
          uint64_t v294 = v293 & 0xFFFFFFFE;
        }
        if ((_DWORD)v294)
        {
          LOWORD(v350[0]) = 0;
          LODWORD(v33_Block_object_dispose(va, 8) = 2;
          v295 = (const char *)_os_log_send_and_compose_impl( v294,  valuePtr,  0LL,  0LL,  &_mh_execute_header,  v292,  0LL,  "Session has no SyncBag (kUMUserSessionHasSyncBagKey=false), nothing to verify",  v350,  v338);
          v296 = (char *)v295;
          if (v295) {
            sub_100053B7C(v295);
          }
        }

        else
        {
          v296 = 0LL;
        }

        free(v296);
      }
    }

    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v297 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v297, OS_LOG_TYPE_DEFAULT))
    {
      v298 = (const __CFDictionary *)v9;
      *(void *)int valuePtr = 0LL;
      unsigned int v299 = sub_100053B4C(1);
      v300 = (os_log_s *)v297;
      if (os_log_type_enabled(v300, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v301 = v299;
      }
      else {
        uint64_t v301 = v299 & 0xFFFFFFFE;
      }
      if ((_DWORD)v301)
      {
        LODWORD(v350[0]) = 67109120;
        HIDWORD(v350[0]) = v347;
        v302 = (char *)_os_log_send_and_compose_impl( v301,  valuePtr,  0LL,  0LL,  &_mh_execute_header,  v300,  0LL,  "User %d has valid Syncbag will skip creation of syncbag",  v350);

        if (v302) {
          sub_100053B7C(v302);
        }
      }

      else
      {

        v302 = 0LL;
      }

      free(v302);
      unint64_t v9 = (unint64_t)v298;
    }
  }

LABEL_660:
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v313 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v313, OS_LOG_TYPE_DEFAULT))
  {
    v314 = (const __CFDictionary *)v9;
    *(void *)int valuePtr = 0LL;
    unsigned int v315 = sub_100053B4C(1);
    v316 = (os_log_s *)v313;
    if (os_log_type_enabled(v316, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v317 = v315;
    }
    else {
      uint64_t v317 = v315 & 0xFFFFFFFE;
    }
    if ((_DWORD)v317)
    {
      LODWORD(v350[0]) = 67109120;
      HIDWORD(v350[0]) = v347;
      v318 = (char *)_os_log_send_and_compose_impl( v317,  valuePtr,  0LL,  0LL,  &_mh_execute_header,  v316,  0LL,  "Need to create SyncBag for User:%d",  v350);

      if (v318) {
        sub_100053B7C(v318);
      }
    }

    else
    {

      v318 = 0LL;
    }

    free(v318);
    unint64_t v9 = (unint64_t)v314;
  }

  if (sub_100029634(v54, v347))
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    v278 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v278, OS_LOG_TYPE_DEFAULT))
    {
      v327 = (const __CFDictionary *)v9;
      *(void *)int valuePtr = 0LL;
      unsigned int v328 = sub_100053B4C(1);
      v329 = v278;
      if (os_log_type_enabled(v329, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v330 = v328;
      }
      else {
        uint64_t v330 = v328 & 0xFFFFFFFE;
      }
      if ((_DWORD)v330)
      {
        LODWORD(v350[0]) = 67109120;
        HIDWORD(v350[0]) = v347;
        v331 = (char *)_os_log_send_and_compose_impl( v330,  valuePtr,  0LL,  0LL,  &_mh_execute_header,  v329,  0LL,  "Failed to create SyncBag for user:%d",  v350);

        if (v331) {
          sub_100053B7C(v331);
        }
      }

      else
      {

        v331 = 0LL;
      }

      free(v331);
      unint64_t v9 = (unint64_t)v327;
    }

    goto LABEL_673;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v332 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v332, OS_LOG_TYPE_DEFAULT))
  {
    v333 = (const __CFDictionary *)v9;
    *(void *)int valuePtr = 0LL;
    unsigned int v334 = sub_100053B4C(1);
    v335 = (os_log_s *)v332;
    if (os_log_type_enabled(v335, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v336 = v334;
    }
    else {
      uint64_t v336 = v334 & 0xFFFFFFFE;
    }
    if ((_DWORD)v336)
    {
      LODWORD(v350[0]) = 67109120;
      HIDWORD(v350[0]) = v347;
      v337 = (char *)_os_log_send_and_compose_impl( v336,  valuePtr,  0LL,  0LL,  &_mh_execute_header,  v335,  0LL,  "Created SyncBag successfully for user:%d",  v350);

      if (v337) {
        sub_100053B7C(v337);
      }
    }

    else
    {

      v337 = 0LL;
    }

    free(v337);
    unint64_t v9 = (unint64_t)v333;
  }

  CFDictionarySetValue(v54, kUMUserSessionHasSyncBagKey, kCFBooleanTrue);
  if (!v9)
  {
LABEL_675:
    sub_100021680(v54, 1);
    nullsub_1(qword_1000DBA70, v54);
    sub_100021704();
    sub_10001AED4();
    if (qword_1000DBAB0 != -1) {
      dispatch_once(&qword_1000DBAB0, &stru_1000CD548);
    }
    id v308 = (id)qword_1000DBAA8;
    if (os_log_type_enabled((os_log_t)v308, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)int valuePtr = 0LL;
      unsigned int v309 = sub_100053B4C(1);
      v310 = (os_log_s *)v308;
      if (os_log_type_enabled(v310, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v311 = v309;
      }
      else {
        uint64_t v311 = v309 & 0xFFFFFFFE;
      }
      if ((_DWORD)v311)
      {
        LODWORD(v350[0]) = 67109120;
        HIDWORD(v350[0]) = v347;
        v312 = (char *)_os_log_send_and_compose_impl( v311,  valuePtr,  0LL,  0LL,  &_mh_execute_header,  v310,  0LL,  "Created user %u",  v350);

        if (v312) {
          sub_100053B7C(v312);
        }
      }

      else
      {

        v312 = 0LL;
      }

      free(v312);
    }

    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v319 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v319, OS_LOG_TYPE_DEFAULT))
    {
      v350[0] = 0LL;
      unsigned int v320 = sub_100053B4C(1);
      v321 = (os_log_s *)v319;
      if (os_log_type_enabled(v321, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v322 = v320;
      }
      else {
        uint64_t v322 = v320 & 0xFFFFFFFE;
      }
      if ((_DWORD)v322)
      {
        *(_DWORD *)int valuePtr = 136315394;
        *(void *)&valuePtr[4] = "loadUserSession";
        *(_WORD *)&valuePtr[12] = 2080;
        uint64_t v349 = kMobileKeyBagUserChangedNotificationToken;
        LODWORD(v33_Block_object_dispose(va, 8) = 22;
        v323 = (char *)_os_log_send_and_compose_impl( v322,  v350,  0LL,  0LL,  &_mh_execute_header,  v321,  0LL,  "usermanagerd %s posting notification: %s\n",  valuePtr,  v338);

        if (v323) {
          sub_100053B7C(v323);
        }
      }

      else
      {

        v323 = 0LL;
      }

      free(v323);
    }

    uint64_t v324 = sub_100018E74(qword_1000DBD40);
    v325 = (void *)objc_claimAutoreleasedReturnValue(v324);
    v326 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  kMobileKeyBagUserChangedNotificationToken));
    [v325 post:v326];
  }

  return v54;
}

uint64_t sub_10002789C(__CFDictionary *a1, CFDictionaryRef theDict, void *key, uint64_t a4)
{
  uint64_t result = CFDictionaryContainsKey(theDict, key);
  if ((_DWORD)result)
  {
    Value = CFDictionaryGetValue(theDict, key);
    if (CFGetTypeID(Value) == a4)
    {
      if (CFDictionaryContainsKey(a1, key)) {
        CFDictionaryReplaceValue(a1, key, Value);
      }
      else {
        CFDictionarySetValue(a1, key, Value);
      }
      return 1LL;
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      unsigned int v10 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v15 = 0LL;
        unsigned int v11 = sub_100053B4C(1);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v12 = v11;
        }
        else {
          uint64_t v12 = v11 & 0xFFFFFFFE;
        }
        if ((_DWORD)v12)
        {
          int v16 = 138412290;
          unsigned int v17 = key;
          id v13 = (const char *)_os_log_send_and_compose_impl( v12,  &v15,  0LL,  0LL,  &_mh_execute_header,  v10,  0LL,  "Error: _setAttributeOfType:Incorrect Type for the key %@",  &v16,  12);
          int v14 = (char *)v13;
          if (v13) {
            sub_100053B7C(v13);
          }
        }

        else
        {
          int v14 = 0LL;
        }

        free(v14);
      }

      return 0LL;
    }
  }

  return result;
}

uint64_t sub_100027A48()
{
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v0 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v39 = 0LL;
    unsigned int v1 = sub_100053B4C(1);
    if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v2 = v1;
    }
    else {
      uint64_t v2 = v1 & 0xFFFFFFFE;
    }
    if ((_DWORD)v2)
    {
      LOWORD(v41) = 0;
      unsigned int v3 = (const char *)_os_log_send_and_compose_impl( v2,  &v39,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "Trying to MAKE SPACE FOR NEWUSER",  &v41,  2);
      uint64_t v4 = (char *)v3;
      if (v3) {
        sub_100053B7C(v3);
      }
    }

    else
    {
      uint64_t v4 = 0LL;
    }

    free(v4);
  }

  if (!qword_1000DBD00)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v12 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v39 = 0LL;
      unsigned int v13 = sub_100053B4C(1);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v14 = v13;
      }
      else {
        uint64_t v14 = v13 & 0xFFFFFFFE;
      }
      if ((_DWORD)v14)
      {
        LOWORD(v41) = 0;
        LODWORD(v3_Block_object_dispose(va, 8) = 2;
        uint64_t v15 = (const char *)_os_log_send_and_compose_impl( v14,  &v39,  0LL,  0LL,  &_mh_execute_header,  v12,  0LL,  "No USERs in LRU TABLE, returning",  &v41,  v38);
        int v16 = (char *)v15;
        if (v15) {
          sub_100053B7C(v15);
        }
      }

      else
      {
        int v16 = 0LL;
      }

      free(v16);
    }

    return 0LL;
  }

  if (CFArrayGetCount((CFArrayRef)qword_1000DBD00) < 1) {
    return 0LL;
  }
  CFIndex v5 = 0LL;
  while (1)
  {
    ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)qword_1000DBD00, v5);
    if (!ValueAtIndex) {
      goto LABEL_21;
    }
    int v7 = ValueAtIndex;
    CFTypeID v8 = CFGetTypeID(ValueAtIndex);
    if (v8 != CFNumberGetTypeID()) {
      goto LABEL_21;
    }
    if (!CFNumberGetValue(v7, kCFNumberIntType, &valuePtr)) {
      goto LABEL_21;
    }
    id v9 = sub_100054ED0(qword_1000DBA70, valuePtr);
    unsigned int v10 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue(v9);
    if (!v10) {
      goto LABEL_21;
    }
    unsigned int v11 = v10;
    CFRelease(v11);
LABEL_21:
    if (CFArrayGetCount((CFArrayRef)qword_1000DBD00) <= ++v5) {
      return 0LL;
    }
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v19 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v39 = 0LL;
    unsigned int v20 = sub_100053B4C(1);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v21 = v20;
    }
    else {
      uint64_t v21 = v20 & 0xFFFFFFFE;
    }
    if ((_DWORD)v21)
    {
      int v41 = 67109120;
      int v42 = valuePtr;
      unsigned int v22 = (const char *)_os_log_send_and_compose_impl( v21,  &v39,  0LL,  0LL,  &_mh_execute_header,  v19,  0LL,  "found a clean Usersession with uid=%d for deletion",  &v41);
      id v23 = (char *)v22;
      if (v22) {
        sub_100053B7C(v22);
      }
    }

    else
    {
      id v23 = 0LL;
    }

    free(v23);
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v24 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v39 = 0LL;
    unsigned int v25 = sub_100053B4C(1);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v26 = v25;
    }
    else {
      uint64_t v26 = v25 & 0xFFFFFFFE;
    }
    if ((_DWORD)v26)
    {
      int v41 = 67109120;
      int v42 = valuePtr;
      unsigned int v27 = (const char *)_os_log_send_and_compose_impl( v26,  &v39,  0LL,  0LL,  &_mh_execute_header,  v24,  0LL,  "FOUND user:%d to delete, trying deletion",  &v41);
      unsigned int v28 = (char *)v27;
      if (v27) {
        sub_100053B7C(v27);
      }
    }

    else
    {
      unsigned int v28 = 0LL;
    }

    free(v28);
  }

  if (sub_10002A878((uint64_t)v11) == 1)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v29 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v39 = 0LL;
      unsigned int v30 = sub_100053B4C(1);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v31 = v30;
      }
      else {
        uint64_t v31 = v30 & 0xFFFFFFFE;
      }
      if ((_DWORD)v31)
      {
        int v41 = 67109120;
        int v42 = valuePtr;
        unsigned int v32 = (const char *)_os_log_send_and_compose_impl( v31,  &v39,  0LL,  0LL,  &_mh_execute_header,  v29,  0LL,  "User:%d Deletion successful",  &v41);
        unsigned int v33 = (char *)v32;
        if (v32) {
          sub_100053B7C(v32);
        }
      }

      else
      {
        unsigned int v33 = 0LL;
      }

      free(v33);
    }

    uint64_t v17 = 1LL;
  }

  else
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v29 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v39 = 0LL;
      unsigned int v34 = sub_100053B4C(1);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v35 = v34;
      }
      else {
        uint64_t v35 = v34 & 0xFFFFFFFE;
      }
      if ((_DWORD)v35)
      {
        int v41 = 67109120;
        int v42 = valuePtr;
        unsigned int v36 = (const char *)_os_log_send_and_compose_impl( v35,  &v39,  0LL,  0LL,  &_mh_execute_header,  v29,  0LL,  "User:%d Deletion FAILED",  &v41);
        int v37 = (char *)v36;
        if (v36) {
          sub_100053B7C(v36);
        }
      }

      else
      {
        int v37 = 0LL;
      }

      free(v37);
    }

    uint64_t v17 = 0LL;
  }

  CFRelease(v11);
  return v17;
}

BOOL sub_100028074(const __CFDictionary *a1, uint64_t a2)
{
  uint64_t v4 = (void *)sub_100083DF4(a1, kUMUserSessionUUIDKey);
  int v5 = sub_100083C6C(a1, kMKBUserSessionIDKey);
  if (v4)
  {
    int v6 = v5;
    int v7 = sub_100017CFC((uint64_t)&OBJC_CLASS___NSUUID, v4);
    CFTypeID v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
    if (v8)
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      id v9 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)uint64_t v66 = 0LL;
        unsigned int v10 = sub_100053B4C(1);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v11 = v10;
        }
        else {
          uint64_t v11 = v10 & 0xFFFFFFFE;
        }
        if ((_DWORD)v11)
        {
          LOWORD(v65[0]) = 0;
          uint64_t v12 = (const char *)_os_log_send_and_compose_impl( v11,  v66,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "GOT UUID from uuidstring",  v65,  2);
          unsigned int v13 = (char *)v12;
          if (v12) {
            sub_100053B7C(v12);
          }
        }

        else
        {
          unsigned int v13 = 0LL;
        }

        free(v13);
      }

      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v24 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        v65[0] = 0LL;
        unsigned int v25 = sub_100053B4C(1);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v26 = v25;
        }
        else {
          uint64_t v26 = v25 & 0xFFFFFFFE;
        }
        if ((_DWORD)v26)
        {
          *(_DWORD *)uint64_t v66 = 138412546;
          *(void *)&v66[4] = v8;
          __int16 v67 = 1024;
          int v68 = v6;
          LODWORD(v61) = 18;
          unsigned int v27 = (const char *)_os_log_send_and_compose_impl( v26,  v65,  0LL,  0LL,  &_mh_execute_header,  v24,  0LL,  "AKS Identity setup in progress, creating Identity for user:%@ (%d)",  v66,  v61);
          unsigned int v28 = (char *)v27;
          if (v27) {
            sub_100053B7C(v27);
          }
        }

        else
        {
          unsigned int v28 = 0LL;
        }

        free(v28);
      }

      int v29 = _os_feature_enabled_impl("UserManagement", "LocalUserEnrollment");
      uint64_t v30 = sub_100019B18(qword_1000DBD40);
      uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue(v30);
      unsigned int v32 = v31;
      if (v29)
      {
        uint64_t v64 = 0LL;
        unsigned __int8 v33 = [v31 createIdentityWithUUID:v8 passcode:0 existingSession:sub_100055178(qword_1000DBA70) existingSessionPasscode:a2 error:&v64];
        unsigned int v34 = v64;
      }

      else
      {
        uint64_t v63 = 0LL;
        unsigned __int8 v33 = [v31 createIdentityWithUUID:v8 passcode:a2 existingSession:502 existingSessionPasscode:0 error:&v63];
        unsigned int v34 = v63;
      }

      id v14 = v34;

      if ((v33 & 1) != 0)
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        uint64_t v35 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)uint64_t v66 = 0LL;
          unsigned int v36 = sub_100053B4C(1);
          if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v37 = v36;
          }
          else {
            uint64_t v37 = v36 & 0xFFFFFFFE;
          }
          if ((_DWORD)v37)
          {
            LOWORD(v65[0]) = 0;
            LODWORD(v61) = 2;
            uint64_t v38 = (const char *)_os_log_send_and_compose_impl( v37,  v66,  0LL,  0LL,  &_mh_execute_header,  v35,  0LL,  "Successfully created Identity, login..",  v65,  v61);
            uint64_t v39 = (char *)v38;
            if (v38) {
              sub_100053B7C(v38);
            }
          }

          else
          {
            uint64_t v39 = 0LL;
          }

          free(v39);
        }

        else {
          uint64_t v46 = a2;
        }
        int v47 = sub_1000288F0(a1, v46);
        if (v47)
        {
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          uint64_t v48 = (os_log_s *)(id)qword_1000DBA98;
          if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
          {
            *(void *)uint64_t v66 = 0LL;
            unsigned int v49 = sub_100053B4C(1);
            if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v50 = v49;
            }
            else {
              uint64_t v50 = v49 & 0xFFFFFFFE;
            }
            if ((_DWORD)v50)
            {
              LOWORD(v65[0]) = 0;
              LODWORD(v61) = 2;
              uid_t v51 = (const char *)_os_log_send_and_compose_impl( v50,  v66,  0LL,  0LL,  &_mh_execute_header,  v48,  0LL,  "Identity login success!",  v65,  v61);
              uint64_t v52 = (char *)v51;
              if (v51) {
                sub_100053B7C(v51);
              }
            }

            else
            {
              uint64_t v52 = 0LL;
            }

            free(v52);
          }
        }

        else
        {
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          stat v53 = (os_log_s *)(id)qword_1000DBA98;
          if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
          {
            *(void *)uint64_t v66 = 0LL;
            unsigned int v54 = sub_100053B4C(1);
            if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v55 = v54;
            }
            else {
              uint64_t v55 = v54 & 0xFFFFFFFE;
            }
            if ((_DWORD)v55)
            {
              LOWORD(v65[0]) = 0;
              LODWORD(v61) = 2;
              unsigned int v56 = (const char *)_os_log_send_and_compose_impl( v55,  v66,  0LL,  0LL,  &_mh_execute_header,  v53,  0LL,  "Identity login failed, delete and bail",  v65,  v61);
              vm_size_t v57 = (char *)v56;
              if (v56) {
                sub_100053B7C(v56);
              }
            }

            else
            {
              vm_size_t v57 = 0LL;
            }

            free(v57);
          }

          uint64_t v58 = sub_100019B18(qword_1000DBD40);
          uint64_t v48 = (os_log_s *)objc_claimAutoreleasedReturnValue(v58);
          id v62 = v14;
          -[os_log_s deleteIdentity:error:](v48, "deleteIdentity:error:", v8, &v62);
          id v59 = v62;

          id v14 = v59;
        }

        BOOL v45 = v47 != 0;

        goto LABEL_105;
      }

      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      int v40 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
      {
        v65[0] = 0LL;
        LODWORD(v41) = sub_100053B4C(1);
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v41 = v41;
        }
        else {
          uint64_t v41 = v41 & 0xFFFFFFFE;
        }
        if ((_DWORD)v41)
        {
          int v42 = v40;
          id v43 = [v14 code];
          *(_DWORD *)uint64_t v66 = 138412802;
          *(void *)&v66[4] = v8;
          __int16 v67 = 1024;
          int v68 = v6;
          __int16 v69 = 2048;
          id v70 = v43;
          LODWORD(v61) = 28;
          int v44 = (char *)_os_log_send_and_compose_impl( v41,  v65,  0LL,  0LL,  &_mh_execute_header,  v42,  0LL,  "AKS Identity create for user:%@ (%d) failed:%ld, bailing",  v66,  v61);

          if (v44) {
            sub_100053B7C(v44);
          }
        }

        else
        {
          int v44 = 0LL;
        }

        free(v44);
      }
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v19 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)uint64_t v66 = 0LL;
        unsigned int v20 = sub_100053B4C(1);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v21 = v20;
        }
        else {
          uint64_t v21 = v20 & 0xFFFFFFFE;
        }
        if ((_DWORD)v21)
        {
          LOWORD(v65[0]) = 0;
          unsigned int v22 = (const char *)_os_log_send_and_compose_impl( v21,  v66,  0LL,  0LL,  &_mh_execute_header,  v19,  0LL,  "NULL UUID, failure, bailing",  v65,  2);
          id v23 = (char *)v22;
          if (v22) {
            sub_100053B7C(v22);
          }
        }

        else
        {
          id v23 = 0LL;
        }

        free(v23);
      }

      id v14 = 0LL;
    }

    BOOL v45 = 0LL;
LABEL_105:

    goto LABEL_106;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v14 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v14, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t v66 = 0LL;
    unsigned int v15 = sub_100053B4C(1);
    if (os_log_type_enabled((os_log_t)v14, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v15 & 0xFFFFFFFE;
    }
    if ((_DWORD)v16)
    {
      LOWORD(v65[0]) = 0;
      uint64_t v17 = (const char *)_os_log_send_and_compose_impl( v16,  v66,  0LL,  0LL,  &_mh_execute_header,  v14,  0LL,  "No UUID for the primary, bail",  v65,  2);
      int v18 = (char *)v17;
      if (v17) {
        sub_100053B7C(v17);
      }
    }

    else
    {
      int v18 = 0LL;
    }

    free(v18);
  }

  BOOL v45 = 0LL;
LABEL_106:

  return v45;
}

uint64_t sub_1000288F0(const __CFDictionary *a1, uint64_t a2)
{
  uint64_t v4 = (void *)sub_100083DF4(a1, kUMUserSessionUUIDKey);
  uint64_t v5 = sub_100083C6C(a1, kMKBUserSessionIDKey);
  if ((_DWORD)v5 != sub_100055178(qword_1000DBA70))
  {
    if (v4)
    {
      uint64_t v11 = sub_100083DF4(a1, kUMUserSessionVolumeDeviceNodeKey);
      if (v11)
      {
        uint64_t v12 = v11;
        unsigned int v13 = sub_100017CFC((uint64_t)&OBJC_CLASS___NSUUID, v4);
        uint64_t v14 = objc_claimAutoreleasedReturnValue(v13);
        if (v14)
        {
          id v15 = (id)v14;
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          uint64_t v16 = (os_log_s *)(id)qword_1000DBA98;
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            *(void *)uint64_t v91 = 0LL;
            unsigned int v17 = sub_100053B4C(1);
            if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v18 = v17;
            }
            else {
              uint64_t v18 = v17 & 0xFFFFFFFE;
            }
            if ((_DWORD)v18)
            {
              LOWORD(v92) = 0;
              uint64_t v19 = (const char *)_os_log_send_and_compose_impl( v18,  v91,  0LL,  0LL,  &_mh_execute_header,  v16,  0LL,  "GOT UUID from uuidstring",  &v92,  2);
              unsigned int v20 = (char *)v19;
              if (v19) {
                sub_100053B7C(v19);
              }
            }

            else
            {
              unsigned int v20 = 0LL;
            }

            free(v20);
          }

          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          uint64_t v39 = (os_log_s *)(id)qword_1000DBA98;
          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
          {
            *(void *)uint64_t v91 = 0LL;
            unsigned int v40 = sub_100053B4C(1);
            if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v41 = v40;
            }
            else {
              uint64_t v41 = v40 & 0xFFFFFFFE;
            }
            if ((_DWORD)v41)
            {
              LODWORD(v92) = 67109120;
              HIDWORD(v92) = v5;
              int v42 = (const char *)_os_log_send_and_compose_impl( v41,  v91,  0LL,  0LL,  &_mh_execute_header,  v39,  0LL,  "Calling AKSIdentity Login for uid:%d",  &v92);
              id v43 = (char *)v42;
              if (v42) {
                sub_100053B7C(v42);
              }
            }

            else
            {
              id v43 = 0LL;
            }

            free(v43);
          }

          uint64_t v44 = sub_100019B18(qword_1000DBD40);
          BOOL v45 = (void *)objc_claimAutoreleasedReturnValue(v44);
          id v89 = 0LL;
          unsigned int v46 = [v45 loginIdentity:v15 intoSession:v5 passcode:a2 error:&v89];
          id v47 = v89;

          if (!v46)
          {
            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            stat v53 = (os_log_s *)(id)qword_1000DBA98;
            if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v92 = 0LL;
              LODWORD(v54) = sub_100053B4C(1);
              if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v54 = v54;
              }
              else {
                uint64_t v54 = v54 & 0xFFFFFFFE;
              }
              if ((_DWORD)v54)
              {
                uint64_t v55 = v53;
                id v56 = [v47 code];
                *(_DWORD *)uint64_t v91 = 134217984;
                *(void *)&v91[4] = v56;
                vm_size_t v57 = (char *)_os_log_send_and_compose_impl( v54,  &v92,  0LL,  0LL,  &_mh_execute_header,  v55,  0LL,  "AKS Identity Login failed:%ld",  v91);

                if (v57) {
                  sub_100053B7C(v57);
                }
              }

              else
              {
                vm_size_t v57 = 0LL;
              }

              free(v57);
            }

            uint64_t v30 = 0LL;
            id v29 = v47;
            goto LABEL_68;
          }

          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          uint64_t v48 = (os_log_s *)(id)qword_1000DBA98;
          if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
          {
            *(void *)uint64_t v91 = 0LL;
            unsigned int v49 = sub_100053B4C(1);
            if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v50 = v49;
            }
            else {
              uint64_t v50 = v49 & 0xFFFFFFFE;
            }
            if ((_DWORD)v50)
            {
              LOWORD(v92) = 0;
              LODWORD(v86) = 2;
              uid_t v51 = (const char *)_os_log_send_and_compose_impl( v50,  v91,  0LL,  0LL,  &_mh_execute_header,  v48,  0LL,  "IdentityLogin Succeeded and onto volumeMap..",  &v92,  v86);
              uint64_t v52 = (char *)v51;
              if (v51) {
                sub_100053B7C(v51);
              }
            }

            else
            {
              uint64_t v52 = 0LL;
            }

            free(v52);
          }

          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          uint64_t v58 = (os_log_s *)(id)qword_1000DBA98;
          if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v92 = 0LL;
            unsigned int v59 = sub_100053B4C(1);
            if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v60 = v59;
            }
            else {
              uint64_t v60 = v59 & 0xFFFFFFFE;
            }
            if ((_DWORD)v60)
            {
              *(_DWORD *)uint64_t v91 = 138412546;
              *(void *)&v91[4] = v12;
              *(_WORD *)&v91[12] = 1024;
              *(_DWORD *)&v91[14] = v5;
              LODWORD(v86) = 18;
              uint64_t v61 = (const char *)_os_log_send_and_compose_impl( v60,  &v92,  0LL,  0LL,  &_mh_execute_header,  v58,  0LL,  "Calling AKSVolumeMap with disk:%@, uid:%d",  v91,  v86);
              id v62 = (char *)v61;
              if (v61) {
                sub_100053B7C(v61);
              }
            }

            else
            {
              id v62 = 0LL;
            }

            free(v62);
          }

          uint64_t v63 = sub_100019B18(qword_1000DBD40);
          uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue(v63);
          id v88 = v47;
          unsigned int v65 = [v64 mapVolume:v12 toSession:v5 withPersona:0 error:&v88];
          id v29 = v88;

          if (v65)
          {
            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            uint64_t v66 = (os_log_s *)(id)qword_1000DBA98;
            if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
            {
              *(void *)uint64_t v91 = 0LL;
              unsigned int v67 = sub_100053B4C(1);
              if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v68 = v67;
              }
              else {
                uint64_t v68 = v67 & 0xFFFFFFFE;
              }
              if ((_DWORD)v68)
              {
                LOWORD(v92) = 0;
                LODWORD(v86) = 2;
                __int16 v69 = (const char *)_os_log_send_and_compose_impl( v68,  v91,  0LL,  0LL,  &_mh_execute_header,  v66,  0LL,  "AKS VolumeMapPath Success, IdentityLogin success",  &v92,  v86);
                id v70 = (char *)v69;
                if (v69) {
                  sub_100053B7C(v69);
                }
              }

              else
              {
                id v70 = 0LL;
              }

              free(v70);
            }

            uint64_t v30 = 1LL;
            goto LABEL_68;
          }

          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          uint64_t v71 = (os_log_s *)(id)qword_1000DBA98;
          if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v92 = 0LL;
            LODWORD(v72) = sub_100053B4C(1);
            if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v72 = v72;
            }
            else {
              uint64_t v72 = v72 & 0xFFFFFFFE;
            }
            if ((_DWORD)v72)
            {
              unsigned int v73 = v71;
              id v74 = [v29 code];
              *(_DWORD *)uint64_t v91 = 134217984;
              *(void *)&v91[4] = v74;
              uint64_t v75 = (char *)_os_log_send_and_compose_impl( v72,  &v92,  0LL,  0LL,  &_mh_execute_header,  v73,  0LL,  "AKS VolumeMap failed with %ld, error out IdentityLogin",  v91);

              if (v75) {
                sub_100053B7C(v75);
              }
            }

            else
            {
              uint64_t v75 = 0LL;
            }

            free(v75);
          }

          uint64_t v76 = sub_100019B18(qword_1000DBD40);
          unsigned int v77 = (void *)objc_claimAutoreleasedReturnValue(v76);
          id v87 = 0LL;
          unsigned int v78 = [v77 unloadIdentityFromSession:v5 error:&v87];
          id v29 = v87;

          if (v78)
          {
            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            unsigned int v79 = (os_log_s *)(id)qword_1000DBA98;
            if (!os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_163;
            }
            *(void *)uint64_t v91 = 0LL;
            unsigned int v80 = sub_100053B4C(1);
            if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v81 = v80;
            }
            else {
              uint64_t v81 = v80 & 0xFFFFFFFE;
            }
            if ((_DWORD)v81)
            {
              LOWORD(v92) = 0;
              LODWORD(v86) = 2;
              uint64_t v82 = (void *)_os_log_send_and_compose_impl( v81,  v91,  0LL,  0LL,  &_mh_execute_header,  v79,  0LL,  "Unloaded identity success after volume map error",  &v92,  v86);
              if (!v82) {
                goto LABEL_162;
              }
              goto LABEL_160;
            }
          }

          else
          {
            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            unsigned int v79 = (os_log_s *)(id)qword_1000DBA98;
            if (!os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_163;
            }
            uint64_t v92 = 0LL;
            LODWORD(v83) = sub_100053B4C(1);
            if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v83 = v83;
            }
            else {
              uint64_t v83 = v83 & 0xFFFFFFFE;
            }
            if ((_DWORD)v83)
            {
              uint64_t v84 = v79;
              id v85 = [v29 code];
              *(_DWORD *)uint64_t v91 = 134217984;
              *(void *)&v91[4] = v85;
              uint64_t v82 = (void *)_os_log_send_and_compose_impl( v83,  &v92,  0LL,  0LL,  &_mh_execute_header,  v84,  0LL,  "Unload of identity failed with error:%ld after volume map error",  v91);

              if (!v82)
              {
LABEL_162:
                free(v82);
LABEL_163:

                goto LABEL_67;
              }

LABEL_160:
              sub_100053B7C((const char *)v82);
              goto LABEL_162;
            }
          }

          uint64_t v82 = 0LL;
          goto LABEL_162;
        }

        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        id v15 = (id)qword_1000DBA98;
        if (!os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_DEFAULT))
        {
LABEL_64:
          id v29 = 0LL;
LABEL_67:
          uint64_t v30 = 0LL;
LABEL_68:

          goto LABEL_69;
        }

        *(void *)uint64_t v91 = 0LL;
        unsigned int v35 = sub_100053B4C(1);
        if (os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v36 = v35;
        }
        else {
          uint64_t v36 = v35 & 0xFFFFFFFE;
        }
        if ((_DWORD)v36)
        {
          LOWORD(v92) = 0;
          id v23 = (const char *)_os_log_send_and_compose_impl( v36,  v91,  0LL,  0LL,  &_mh_execute_header,  v15,  0LL,  "NULL UUID, failure, bailing",  &v92,  2);
LABEL_60:
          uint64_t v37 = (char *)v23;
          if (v23) {
            sub_100053B7C(v23);
          }
          goto LABEL_63;
        }
      }

      else
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        id v15 = (id)qword_1000DBA98;
        if (!os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_64;
        }
        *(void *)uint64_t v91 = 0LL;
        unsigned int v24 = sub_100053B4C(1);
        if (os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v25 = v24;
        }
        else {
          uint64_t v25 = v24 & 0xFFFFFFFE;
        }
        if ((_DWORD)v25)
        {
          LOWORD(v92) = 0;
          id v23 = (const char *)_os_log_send_and_compose_impl( v25,  v91,  0LL,  0LL,  &_mh_execute_header,  v15,  0LL,  "not able to find the diskNode,  error out IdentityLogin",  &v92,  2);
          goto LABEL_60;
        }
      }
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      id v15 = (id)qword_1000DBA98;
      if (!os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_64;
      }
      *(void *)uint64_t v91 = 0LL;
      unsigned int v21 = sub_100053B4C(1);
      if (os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v22 = v21;
      }
      else {
        uint64_t v22 = v21 & 0xFFFFFFFE;
      }
      if ((_DWORD)v22)
      {
        LOWORD(v92) = 0;
        id v23 = (const char *)_os_log_send_and_compose_impl( v22,  v91,  0LL,  0LL,  &_mh_execute_header,  v15,  0LL,  "No UUID for the primary, bail",  &v92,  2);
        goto LABEL_60;
      }
    }

    uint64_t v37 = 0LL;
LABEL_63:
    free(v37);
    goto LABEL_64;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  int v6 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t v91 = 0LL;
    unsigned int v7 = sub_100053B4C(1);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = v7 & 0xFFFFFFFE;
    }
    if ((_DWORD)v8)
    {
      LOWORD(v92) = 0;
      id v9 = (const char *)_os_log_send_and_compose_impl( v8,  v91,  0LL,  0LL,  &_mh_execute_header,  v6,  0LL,  "Loading the current foreGroundUser again, skipping AKSIdentityLoad and volumemap. Unlocking it",  &v92,  2);
      unsigned int v10 = (char *)v9;
      if (v9) {
        sub_100053B7C(v9);
      }
    }

    else
    {
      unsigned int v10 = 0LL;
    }

    free(v10);
  }

  uint64_t v26 = sub_100019B18(qword_1000DBD40);
  unsigned int v27 = (void *)objc_claimAutoreleasedReturnValue(v26);
  id v90 = 0LL;
  unsigned __int8 v28 = [v27 unlockIdentityInSession:v5 passcode:a2 error:&v90];
  id v29 = v90;

  if ((v28 & 1) == 0)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v15 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v92 = 0LL;
      LODWORD(v31) = sub_100053B4C(1);
      if (os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v31 = v31;
      }
      else {
        uint64_t v31 = v31 & 0xFFFFFFFE;
      }
      if ((_DWORD)v31)
      {
        id v32 = v15;
        id v33 = [v29 code];
        *(_DWORD *)uint64_t v91 = 67109376;
        *(_DWORD *)&v91[4] = -(int)v5;
        *(_WORD *)&v91[8] = 2048;
        *(void *)&v91[10] = v33;
        LODWORD(v86) = 18;
        unsigned int v34 = (char *)_os_log_send_and_compose_impl( v31,  &v92,  0LL,  0LL,  &_mh_execute_header,  v32,  0LL,  "failed to unlock session bag:%d handle with error:0x%lx",  v91,  v86);

        if (v34) {
          sub_100053B7C(v34);
        }
      }

      else
      {
        unsigned int v34 = 0LL;
      }

      free(v34);
    }

    goto LABEL_67;
  }

  uint64_t v30 = 1LL;
LABEL_69:

  return v30;
}

uint64_t sub_100029634(const __CFDictionary *a1, uint64_t a2)
{
  if (sub_100083DA4(a1, kUMUserSessionHasSyncBagKey))
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v4 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_32;
    }
    uint64_t v20 = 0LL;
    unsigned int v5 = sub_100053B4C(1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = v5 & 0xFFFFFFFE;
    }
    if ((_DWORD)v6)
    {
      LOWORD(v19[0]) = 0;
      unsigned int v7 = (const char *)_os_log_send_and_compose_impl( v6,  &v20,  0LL,  0LL,  &_mh_execute_header,  v4,  0LL,  "SyncBag exists, skipping...",  v19,  2,  v19[0]);
      goto LABEL_10;
    }

    goto LABEL_30;
  }

  int SyncBagForUser = MKBUserSessionCreateSyncBagForUser(a1, a2);
  if (!SyncBagForUser)
  {
    CFDictionarySetValue(a1, kUMUserSessionHasSyncBagKey, kCFBooleanTrue);
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v4 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_32;
    }
    uint64_t v20 = 0LL;
    unsigned int v15 = sub_100053B4C(1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v15 & 0xFFFFFFFE;
    }
    if ((_DWORD)v16)
    {
      LOWORD(v19[0]) = 0;
      unsigned int v7 = (const char *)_os_log_send_and_compose_impl( v16,  &v20,  0LL,  0LL,  &_mh_execute_header,  v4,  0LL,  "SyncBag Creation completed",  v19,  2,  v19[0]);
LABEL_10:
      uint64_t v8 = (char *)v7;
      if (v7) {
        sub_100053B7C(v7);
      }
      goto LABEL_31;
    }

uint64_t sub_10002992C()
{
  uint64_t v4 = 0LL;
  unsigned int v5 = &v4;
  uint64_t v6 = 0x2020000000LL;
  int v7 = -1;
  v3[0] = 0LL;
  v3[1] = v3;
  v3[2] = 0x2020000000LL;
  v3[3] = 0LL;
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472LL;
  v2[2] = sub_1000299E0;
  v2[3] = &unk_1000CD360;
  v2[4] = v3;
  v2[5] = &v4;
  dispatch_sync((dispatch_queue_t)qword_1000DBD48, v2);
  uint64_t v0 = *((unsigned int *)v5 + 6);
  _Block_object_dispose(v3, 8);
  _Block_object_dispose(&v4, 8);
  return v0;
}

void sub_1000299E0(uint64_t a1)
{
  if (byte_1000DBA80 == 1)
  {
    if (qword_1000DBAB0 != -1) {
      dispatch_once(&qword_1000DBAB0, &stru_1000CD548);
    }
    uint64_t v2 = (os_log_s *)(id)qword_1000DBAA8;
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      goto LABEL_57;
    }
    *(void *)id v33 = 0LL;
    unsigned int v3 = sub_100053B4C(0);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      LOWORD(v32[0]) = 0;
      unsigned int v5 = (const char *)_os_log_send_and_compose_impl( v4,  v33,  0LL,  0LL,  &_mh_execute_header,  v2,  16LL,  "Failed to switch user: user switch already in progress",  v32,  2,  v32[0]);
      goto LABEL_53;
    }

    goto LABEL_55;
  }

  id v6 = sub_100054ED0(qword_1000DBA70, 502);
  uint64_t v7 = objc_claimAutoreleasedReturnValue(v6);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v7;
  uint64_t v9 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (dword_1000DBCE8 == 1)
  {
    if (!v9) {
      sub_1000A9C04(v7, v8);
    }
    goto LABEL_14;
  }

  if (v9)
  {
LABEL_14:
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    int v10 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)id v33 = 0LL;
      unsigned int v11 = sub_100053B4C(1);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v12 = v11;
      }
      else {
        uint64_t v12 = v11 & 0xFFFFFFFE;
      }
      if ((_DWORD)v12)
      {
        LOWORD(v32[0]) = 0;
        unsigned int v13 = (const char *)_os_log_send_and_compose_impl( v12,  v33,  0LL,  0LL,  &_mh_execute_header,  v10,  0LL,  "LOGINWINDOW User EXISTS ALREADY, setting up for switch",  v32,  2);
        uint64_t v14 = (char *)v13;
        if (v13) {
          sub_100053B7C(v13);
        }
      }

      else
      {
        uint64_t v14 = 0LL;
      }

      free(v14);
    }

    goto LABEL_35;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  unsigned int v15 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)id v33 = 0LL;
    unsigned int v16 = sub_100053B4C(1);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v17 = v16;
    }
    else {
      uint64_t v17 = v16 & 0xFFFFFFFE;
    }
    if ((_DWORD)v17)
    {
      LOWORD(v32[0]) = 0;
      uint64_t v18 = (const char *)_os_log_send_and_compose_impl( v17,  v33,  0LL,  0LL,  &_mh_execute_header,  v15,  0LL,  "LoginWindow does not exist, creating a static session",  v32,  2);
      uint64_t v19 = (char *)v18;
      if (v18) {
        sub_100053B7C(v18);
      }
    }

    else
    {
      uint64_t v19 = 0LL;
    }

    free(v19);
  }

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = sub_10001ED88(-1, 0LL);
LABEL_35:
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v2 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_57;
    }
    *(void *)id v33 = 0LL;
    unsigned int v26 = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v27 = v26;
    }
    else {
      uint64_t v27 = v26 & 0xFFFFFFFE;
    }
    if ((_DWORD)v27)
    {
      LOWORD(v32[0]) = 0;
      LODWORD(v31) = 2;
      unsigned int v5 = (const char *)_os_log_send_and_compose_impl( v27,  v33,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  " Failed to create new LOGIN WINDOW User and it does not exist, loginwindow switch failed",  v32,  v31,  v32[0]);
LABEL_53:
      unsigned __int8 v28 = (char *)v5;
      if (v5) {
        sub_100053B7C(v5);
      }
      goto LABEL_56;
    }

LABEL_55:
    unsigned __int8 v28 = 0LL;
LABEL_56:
    free(v28);
LABEL_57:

    return;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v20 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    v32[0] = 0LL;
    unsigned int v21 = sub_100053B4C(1);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v22 = v21;
    }
    else {
      uint64_t v22 = v21 & 0xFFFFFFFE;
    }
    if ((_DWORD)v22)
    {
      uint64_t v23 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
      *(_DWORD *)id v33 = 138412290;
      *(void *)&v33[4] = v23;
      LODWORD(v31) = 12;
      unsigned int v24 = (const char *)_os_log_send_and_compose_impl( v22,  v32,  0LL,  0LL,  &_mh_execute_header,  v20,  0LL,  "Found Loginwindow user session %@",  v33,  v31);
      uint64_t v25 = (char *)v24;
      if (v24) {
        sub_100053B7C(v24);
      }
    }

    else
    {
      uint64_t v25 = 0LL;
    }

    free(v25);
  }

  id v29 = (void *)objc_claimAutoreleasedReturnValue(+[RDServer sharedServer](&OBJC_CLASS___RDServer, "sharedServer"));
  [v29 switchToUser:*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)];

  *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0;
  uint64_t v30 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (v30)
  {
    CFRelease(v30);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0LL;
  }

    unsigned int v24 = 0LL;
LABEL_56:
    free(v24);
LABEL_57:

    return 0LL;
  }

  uint64_t v17 = sub_100018E80(qword_1000DBD40);
  uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
  uint64_t v19 = sub_100019B60((uint64_t)v18);

  if (v19 == (_DWORD)v9)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v12 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_57;
    }
    *(void *)__old = 0LL;
    uint64_t v20 = sub_100053B4C(1);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v14 = v20;
    }
    else {
      uint64_t v14 = v20 & 0xFFFFFFFE;
    }
    if ((_DWORD)v14)
    {
      *(_WORD *)__str = 0;
      LODWORD(v16_Block_object_dispose(va, 8) = 2;
      uid_t v167 = __str;
      unsigned int v15 = "CANNOT Delete Currently running session";
      goto LABEL_41;
    }

    goto LABEL_55;
  }

  if (dword_1000DBCE8 == 2)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v32 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)__old = 0LL;
      id v33 = sub_100053B4C(1);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
        unsigned int v34 = v33;
      }
      else {
        unsigned int v34 = v33 & 0xFFFFFFFE;
      }
      if ((_DWORD)v34)
      {
        *(_WORD *)__str = 0;
        LODWORD(v16_Block_object_dispose(va, 8) = 2;
        unsigned int v35 = (const char *)_os_log_send_and_compose_impl( v34,  __old,  0LL,  0LL,  &_mh_execute_header,  v32,  0LL,  "Removing a local enrolled user, deleting the APFS Volume..",  __str,  v168);
        uint64_t v36 = (char *)v35;
        if (v35) {
          sub_100053B7C(v35);
        }
      }

      else
      {
        uint64_t v36 = 0LL;
      }

      free(v36);
    }

    if ([(id)qword_1000DBA68 deleteVolumeWithSession:v1 error:0])
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v58 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)__old = 0LL;
        unsigned int v59 = sub_100053B4C(1);
        if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v60 = v59;
        }
        else {
          uint64_t v60 = v59 & 0xFFFFFFFE;
        }
        if ((_DWORD)v60)
        {
          *(_DWORD *)__str = 67109120;
          *(_DWORD *)&char __str[4] = v9;
          uint64_t v61 = (const char *)_os_log_send_and_compose_impl( v60,  __old,  0LL,  0LL,  &_mh_execute_header,  v58,  0LL,  "Removed APFS User volume for user %d",  __str);
          goto LABEL_167;
        }

        goto LABEL_169;
      }
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v58 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)__old = 0LL;
        id v62 = sub_100053B4C(1);
        if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v63 = v62;
        }
        else {
          uint64_t v63 = v62 & 0xFFFFFFFE;
        }
        if ((_DWORD)v63)
        {
          *(_DWORD *)__str = 67109120;
          *(_DWORD *)&char __str[4] = v9;
          uint64_t v61 = (const char *)_os_log_send_and_compose_impl( v63,  __old,  0LL,  0LL,  &_mh_execute_header,  v58,  0LL,  "Failed to remove APFS User volume for user %d",  __str);
LABEL_167:
          uint64_t v64 = (char *)v61;
          if (v61) {
            sub_100053B7C(v61);
          }
          goto LABEL_170;
        }

        CFArrayAppendValue(MutableCopy, a1);
        CFDictionaryReplaceValue(v7, off_1000DAD90, MutableCopy);
        unsigned int v35 = 0;
      }

      else
      {
LABEL_56:
        MutableCopy = sub_100084320();
        CFArrayAppendValue(MutableCopy, a1);
        CFDictionarySetValue(v7, off_1000DAD90, MutableCopy);
        unsigned int v24 = 0LL;
        unsigned int v35 = 1;
      }

      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v36 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
      {
        v53[0] = 0LL;
        uint64_t v37 = sub_100053B4C(1);
        if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v38 = v37;
        }
        else {
          uint64_t v38 = v37 & 0xFFFFFFFE;
        }
        if ((_DWORD)v38)
        {
          *(_DWORD *)uint64_t v54 = 138412290;
          *(void *)&v54[4] = MutableCopy;
          LODWORD(v52) = 12;
          uint64_t v39 = (const char *)_os_log_send_and_compose_impl( v38,  v53,  0LL,  0LL,  &_mh_execute_header,  v36,  0LL,  "Updated Registered machService list is %@",  v54,  v52);
          unsigned int v40 = (char *)v39;
          if (v39) {
            sub_100053B7C(v39);
          }
        }

        else
        {
          unsigned int v40 = 0LL;
        }

        free(v40);
      }

      if ((sub_10005B2D0(qword_1000DBA78) & 1) != 0)
      {
        uint64_t v41 = 1;
        if ((v35 & 1) != 0)
        {
LABEL_89:
          if (MutableCopy) {
            CFRelease(MutableCopy);
          }
LABEL_91:
          CFRelease(v7);
          return v41 != 0;
        }
      }

      else
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        int v42 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)uint64_t v54 = 0LL;
          id v43 = sub_100053B4C(1);
          if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v44 = v43;
          }
          else {
            uint64_t v44 = v43 & 0xFFFFFFFE;
          }
          if ((_DWORD)v44)
          {
            LOWORD(v53[0]) = 0;
            LODWORD(v52) = 2;
            BOOL v45 = (const char *)_os_log_send_and_compose_impl( v44,  v54,  0LL,  0LL,  &_mh_execute_header,  v42,  0LL,  "FAILED to save persona manifest, returning error",  v53,  v52);
            unsigned int v46 = (char *)v45;
            if (v45) {
              sub_100053B7C(v45);
            }
          }

          else
          {
            unsigned int v46 = 0LL;
          }

          free(v46);
        }

        if (v35)
        {
          CFDictionaryRemoveValue(v7, off_1000DAD90);
          uint64_t v41 = 0;
          goto LABEL_89;
        }

        CFDictionaryReplaceValue(v7, off_1000DAD90, v24);
        uint64_t v41 = 0;
      }

void sub_100029F14()
{
  uint64_t v0 = (const __CFDictionary *)sub_10001A594();
  if (v0)
  {
    unsigned int v1 = v0;
    int v2 = sub_100083C6C(v0, kUMUserSessionIDKey);
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    CFDateRef v4 = CFDateCreate(kCFAllocatorDefault, Current);
    if (v4)
    {
      CFDateRef v5 = v4;
      if (v2 == 502)
      {
        int v6 = sub_100083C6C(v1, kUMUserSessionPreviousLoggedinIDKey);
        if (v6 != -1)
        {
          id v7 = sub_100054ED0(qword_1000DBA70, v6);
          uint64_t v8 = (__CFDictionary *)objc_claimAutoreleasedReturnValue(v7);
          if (v8)
          {
            uint64_t v9 = v8;
            CFDictionarySetValue(v8, kUMUserSessionLogoutEndTimeKey, v5);
            CFRelease(v9);
          }
        }
      }

      else
      {
        if (CFDictionaryContainsKey(v1, kUMUserSessionFirstLoginEndTimeKey)) {
          int v10 = kUMUserSessionCachedLoginEndTimeKey;
        }
        else {
          int v10 = kUMUserSessionFirstLoginEndTimeKey;
        }
        CFDictionarySetValue(v1, v10, v5);
      }

      CFRelease(v5);
    }

    CFRelease(v1);
  }

void sub_10002A024()
{
  uint64_t v0 = sub_10001A594();
  if (v0)
  {
    unsigned int v1 = (__CFDictionary *)v0;
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    CFDateRef v3 = CFDateCreate(kCFAllocatorDefault, Current);
    if (v3)
    {
      CFDateRef v4 = v3;
      CFDictionarySetValue(v1, kUMUserSessionLogoutStartTimeKey, v3);
      if (CFDictionaryContainsKey(v1, kUMUserSessionLogoutEndTimeKey)) {
        CFDictionaryRemoveValue(v1, kUMUserSessionLogoutEndTimeKey);
      }
      CFRelease(v4);
    }

    CFRelease(v1);
  }

void sub_10002A0C4()
{
  uint64_t v0 = sub_100055178(qword_1000DBA70);
  if ((_DWORD)v0 == 502)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v1 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = 0LL;
      unsigned int v2 = sub_100053B4C(1);
      if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v3 = v2;
      }
      else {
        uint64_t v3 = v2 & 0xFFFFFFFE;
      }
      if ((_DWORD)v3)
      {
        LOWORD(v22) = 0;
        CFDateRef v4 = (const char *)_os_log_send_and_compose_impl( v3,  &v21,  0LL,  0LL,  &_mh_execute_header,  v1,  0LL,  "NO SYNCBAG TO REMOVE FOR LOGINWINDOW",  &v22,  2);
        CFDateRef v5 = (char *)v4;
        if (v4) {
          sub_100053B7C(v4);
        }
      }

      else
      {
        CFDateRef v5 = 0LL;
      }

      free(v5);
    }

    return;
  }

  uint64_t v6 = v0;
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v7 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v21 = 0LL;
    unsigned int v8 = sub_100053B4C(1);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v9 = v8;
    }
    else {
      uint64_t v9 = v8 & 0xFFFFFFFE;
    }
    if ((_DWORD)v9)
    {
      LODWORD(v22) = 67109120;
      HIDWORD(v22) = v6;
      int v10 = (const char *)_os_log_send_and_compose_impl( v9,  &v21,  0LL,  0LL,  &_mh_execute_header,  v7,  0LL,  "Clearing SyncBag if not needed for current FG ID:%d",  &v22);
      unsigned int v11 = (char *)v10;
      if (v10) {
        sub_100053B7C(v10);
      }
    }

    else
    {
      unsigned int v11 = 0LL;
    }

    free(v11);
  }

  uint64_t v12 = (const __CFDictionary *)sub_10001A594();
  if (v12)
  {
    unsigned int v13 = v12;
    if (CFDictionaryContainsKey(v12, kUMUserSessionSyncMachServicesKey)
      || CFDictionaryContainsKey(v13, kUMUserSessionHasSyncBagKey) != 1)
    {
      goto LABEL_50;
    }

    if (sub_10002A4AC(v13, v6, 0))
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v14 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_49;
      }
      uint64_t v22 = 0LL;
      unsigned int v15 = sub_100053B4C(1);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v16 = v15;
      }
      else {
        uint64_t v16 = v15 & 0xFFFFFFFE;
      }
      if ((_DWORD)v16)
      {
        uint64_t v17 = (const char *)_os_log_send_and_compose_impl( v16,  &v22,  0LL,  0LL,  &_mh_execute_header,  v14,  0LL,  "Failed to remove SyncBag for the user:%d with error:%d",  &v21);
        goto LABEL_45;
      }
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v14 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_49;
      }
      uint64_t v21 = 0LL;
      unsigned int v18 = sub_100053B4C(1);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v19 = v18;
      }
      else {
        uint64_t v19 = v18 & 0xFFFFFFFE;
      }
      if ((_DWORD)v19)
      {
        uint64_t v17 = (const char *)_os_log_send_and_compose_impl( v19,  &v21,  0LL,  0LL,  &_mh_execute_header,  v14,  0LL,  "Removed Syncbag for User successfully");
LABEL_45:
        uint64_t v20 = (char *)v17;
        if (v17) {
          sub_100053B7C(v17);
        }
        goto LABEL_48;
      }
    }

    uint64_t v20 = 0LL;
LABEL_48:
    free(v20);
LABEL_49:

LABEL_50:
    CFRelease(v13);
  }

uint64_t sub_10002A4AC(const __CFDictionary *a1, uint64_t a2, int a3)
{
  if (sub_100083DA4(a1, kUMUserSessionHasSyncBagKey))
  {
    if (a3)
    {
      int v6 = sub_100033524(a1, a2);
      if (!v6)
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        id v7 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v26 = 0LL;
          unsigned int v8 = sub_100053B4C(1);
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v9 = v8;
          }
          else {
            uint64_t v9 = v8 & 0xFFFFFFFE;
          }
          if ((_DWORD)v9)
          {
            LOWORD(v27[0]) = 0;
            int v10 = (const char *)_os_log_send_and_compose_impl( v9,  &v26,  0LL,  0LL,  &_mh_execute_header,  v7,  0LL,  "Unload of SyncBag successful");
            goto LABEL_30;
          }

          goto LABEL_32;
        }

        goto LABEL_34;
      }
    }

    else
    {
      int v6 = 5;
    }

    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v7 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v26 = 0LL;
      unsigned int v16 = sub_100053B4C(1);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v17 = v16;
      }
      else {
        uint64_t v17 = v16 & 0xFFFFFFFE;
      }
      if ((_DWORD)v17)
      {
        v27[0] = 67109120;
        v27[1] = v6;
        int v10 = (const char *)_os_log_send_and_compose_impl( v17,  &v26,  0LL,  0LL,  &_mh_execute_header,  v7,  0LL,  "Unload of SyncBag failed with error:%d",  v27);
LABEL_30:
        unsigned int v18 = (char *)v10;
        if (v10) {
          sub_100053B7C(v10);
        }
        goto LABEL_33;
      }

LABEL_32:
      unsigned int v18 = 0LL;
LABEL_33:
      free(v18);
    }

      if (CFArrayGetCount((CFArrayRef)qword_1000DBD08) <= ++v2) {
        return;
      }
    }

    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v9 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v16 = 0LL;
      int v10 = sub_100053B4C(1);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        unsigned int v11 = v10;
      }
      else {
        unsigned int v11 = v10 & 0xFFFFFFFE;
      }
      if (!(_DWORD)v11) {
        goto LABEL_29;
      }
      LOWORD(v18[0]) = 0;
      unsigned int v12 = (const char *)_os_log_send_and_compose_impl( v11,  &v16,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "got NULL dictionary");
LABEL_27:
      unsigned int v15 = (char *)v12;
      if (v12) {
        sub_100053B7C(v12);
      }
LABEL_30:
      free(v15);
    }

                      acm_mem_free_info( "<data>",  v19,  v18,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibSerialization.c",  763,  "DeserializeProcessAcl");
                      acm_mem_free_data(v19, v18);
                      if (v32)
                      {
                        acm_mem_free_info( "<data>",  v32,  v37,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibSerialization.c",  766,  "DeserializeProcessAcl");
                        acm_mem_free_data(v32, v37);
                      }

                      goto LABEL_34;
                    }

                    int v10 = 4294967292LL;
                  }
                }
              }
            }
          }
        }
      }
    }
  }

LABEL_34:
    uint64_t result = MKBUserSessionRemoveSyncBagForUser(a1, a2);
    if ((_DWORD)result) {
      return result;
    }
    goto LABEL_39;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  unsigned int v11 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v26 = 0LL;
    unsigned int v12 = sub_100053B4C(1);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v13 = v12;
    }
    else {
      uint64_t v13 = v12 & 0xFFFFFFFE;
    }
    if ((_DWORD)v13)
    {
      LOWORD(v27[0]) = 0;
      uint64_t v14 = (const char *)_os_log_send_and_compose_impl( v13,  &v26,  0LL,  0LL,  &_mh_execute_header,  v11,  0LL,  "Session has no SyncBag (kUMUserSessionHasSyncBagKey=false), nothing to remove",  v27,  2);
      unsigned int v15 = (char *)v14;
      if (v14) {
        sub_100053B7C(v14);
      }
    }

    else
    {
      unsigned int v15 = 0LL;
    }

    free(v15);
  }

LABEL_39:
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v20 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v26 = 0LL;
    unsigned int v21 = sub_100053B4C(1);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v22 = v21;
    }
    else {
      uint64_t v22 = v21 & 0xFFFFFFFE;
    }
    if ((_DWORD)v22)
    {
      LOWORD(v27[0]) = 0;
      LODWORD(v25) = 2;
      uint64_t v23 = (const char *)_os_log_send_and_compose_impl( v22,  &v26,  0LL,  0LL,  &_mh_execute_header,  v20,  0LL,  "RESET kUMUserSessionHasSyncBagKey",  v27,  v25);
      unsigned int v24 = (char *)v23;
      if (v23) {
        sub_100053B7C(v23);
      }
    }

    else
    {
      unsigned int v24 = 0LL;
    }

    free(v24);
  }

  CFDictionarySetValue(a1, kUMUserSessionHasSyncBagKey, kCFBooleanFalse);
  return 0LL;
}

    unsigned int v21 = (char *)v18;
    if (v18) {
      sub_100053B7C(v18);
    }
    goto LABEL_50;
  }

  id v7 = 1LL;
LABEL_54:

  return v7;
}

        unsigned int v18 = 0LL;
LABEL_35:
        free(v18);
      }
    }

    uint64_t v19 = sub_10005AE10(a1, v8, 5LL, @"FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF");
    uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue(v19);

    if (v20)
    {
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      unsigned int v21 = (os_log_s *)(id)qword_1000DBB60;
      if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_57;
      }
      uint64_t v30 = 0LL;
      uint64_t v22 = sub_100053B4C(1);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v23 = v22;
      }
      else {
        uint64_t v23 = v22 & 0xFFFFFFFE;
      }
      if ((_DWORD)v23)
      {
        LOWORD(v29) = 0;
        LODWORD(v2_Block_object_dispose(va, 8) = 2;
        unsigned int v24 = (const char *)_os_log_send_and_compose_impl( v23,  &v30,  0LL,  0LL,  &_mh_execute_header,  v21,  0LL,  "Created system session Default persona",  &v29,  v28,  v29);
        goto LABEL_53;
      }
    }

    else
    {
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      unsigned int v21 = (os_log_s *)(id)qword_1000DBB60;
      if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_57;
      }
      uint64_t v30 = 0LL;
      uint64_t v25 = sub_100053B4C(1);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v26 = v25;
      }
      else {
        uint64_t v26 = v25 & 0xFFFFFFFE;
      }
      if ((_DWORD)v26)
      {
        LOWORD(v29) = 0;
        LODWORD(v2_Block_object_dispose(va, 8) = 2;
        unsigned int v24 = (const char *)_os_log_send_and_compose_impl( v26,  &v30,  0LL,  0LL,  &_mh_execute_header,  v21,  0LL,  "Failed to create system session Default persona",  &v29,  v28,  v29);
LABEL_53:
        uint64_t v27 = (char *)v24;
        if (v24) {
          sub_100053B7C(v24);
        }
        goto LABEL_56;
      }
    }

    uint64_t v27 = 0LL;
LABEL_56:
    free(v27);
LABEL_57:

    sub_10005B2D0((uint64_t)a1);
  }

  if (v39) {
    Util_SafeDeallocParameters(v39, v38);
  }
  return v10;
}

uint64_t sub_10002A878(uint64_t result)
{
  if (!result) {
    return result;
  }
  unsigned int v1 = (const __CFDictionary *)result;
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v2 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v2, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)__str = 0LL;
    unsigned int v3 = sub_100053B4C(1);
    CFDateRef v4 = (os_log_s *)v2;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v5 = v3;
    }
    else {
      uint64_t v5 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v5)
    {
      *(_DWORD *)__old = 138412290;
      *(void *)&__old[4] = v1;
      int v6 = (char *)_os_log_send_and_compose_impl( v5,  __str,  0LL,  0LL,  &_mh_execute_header,  v4,  0LL,  "removeUserSession: found an existing session %@",  __old,  12);

      if (v6) {
        sub_100053B7C(v6);
      }
    }

    else
    {

      int v6 = 0LL;
    }

    free(v6);
  }

  unsigned int v7 = sub_100083DA4(v1, kUMUserSessionForegroundKey);
  unsigned int v8 = sub_100083DA4(v1, @"MKBUserSessionFileSystemSet");
  uint64_t v9 = sub_100083C6C(v1, kUMUserSessionIDKey);
  unsigned int v10 = sub_100083DA4(v1, kUMUserSessionDirtyKey);
  unsigned int v11 = sub_100083DA4(v1, kUMUserSessionisPrimaryKey);
  if (dword_1000DBCE8 == 1)
  {
    if ((_DWORD)v9 == 502)
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      unsigned int v12 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_57;
      }
      *(void *)__old = 0LL;
      unsigned int v13 = sub_100053B4C(1);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v14 = v13;
      }
      else {
        uint64_t v14 = v13 & 0xFFFFFFFE;
      }
      if ((_DWORD)v14)
      {
        *(_WORD *)__str = 0;
        LODWORD(v16_Block_object_dispose(va, 8) = 2;
        uid_t v167 = __str;
        unsigned int v15 = "CANNOT UNLOAD A LOGINWINDOW USER SESSION, REMOVE USER FAILED";
LABEL_41:
        unsigned int v21 = __old;
        goto LABEL_53;
      }

      goto LABEL_55;
    }

LABEL_44:
    bzero(__old, 0x400uLL);
    sub_100083E34(v1, kUMUserSessionHomeDirKey, __old, 1024);
    if (v7)
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      unsigned int v12 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_57;
      }
      *(void *)__str = 0LL;
      unsigned int v22 = sub_100053B4C(1);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v14 = v22;
      }
      else {
        uint64_t v14 = v22 & 0xFFFFFFFE;
      }
      if ((_DWORD)v14)
      {
        *(_WORD *)v169 = 0;
        LODWORD(v16_Block_object_dispose(va, 8) = 2;
        uid_t v167 = v169;
        unsigned int v15 = "CANNOT UNLOAD A FOREGROUND SESSION, REMOVE USER FAILED";
        unsigned int v21 = __str;
LABEL_53:
        uint64_t v23 = (const char *)_os_log_send_and_compose_impl( v14,  v21,  0LL,  0LL,  &_mh_execute_header,  v12,  0LL,  v15,  v167,  v168,  *(void *)v169);
        unsigned int v24 = (char *)v23;
        if (v23) {
          sub_100053B7C(v23);
        }
        goto LABEL_56;
      }

      goto LABEL_55;
    }

    if (v10)
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      id v25 = (id)qword_1000DBA98;
      if (os_log_type_enabled((os_log_t)v25, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)__str = 0LL;
        unsigned int v26 = sub_100053B4C(1);
        id v25 = v25;
        if (os_log_type_enabled((os_log_t)v25, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v27 = v26;
        }
        else {
          uint64_t v27 = v26 & 0xFFFFFFFE;
        }
        if ((_DWORD)v27)
        {
          uint64_t v28 = _os_log_send_and_compose_impl( v27,  __str,  0LL,  0LL,  &_mh_execute_header,  v25,  0LL,  "REMOVING A DIRTY USERSESSION with uid %d",  v169);
          goto LABEL_77;
        }

        goto LABEL_88;
      }
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      id v25 = (id)qword_1000DBA98;
      if (os_log_type_enabled((os_log_t)v25, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)__str = 0LL;
        unsigned int v29 = sub_100053B4C(1);
        id v25 = v25;
        if (os_log_type_enabled((os_log_t)v25, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v30 = v29;
        }
        else {
          uint64_t v30 = v29 & 0xFFFFFFFE;
        }
        if ((_DWORD)v30)
        {
          uint64_t v28 = _os_log_send_and_compose_impl( v30,  __str,  0LL,  0LL,  &_mh_execute_header,  v25,  0LL,  "REMOVING A CLEAN USERSESSION with uid %d",  v169);
LABEL_77:
          uint64_t v31 = (char *)v28;

          if (v31) {
            sub_100053B7C(v31);
          }
          goto LABEL_89;
        }

      unsigned int v8 = 4294967285LL;
      goto LABEL_41;
    }

    if (*(_DWORD *)a1 != 1)
    {
      if (!*(_DWORD *)a1) {
        goto LABEL_12;
      }
LABEL_28:
      unsigned int v8 = 0xFFFFFFFFLL;
      goto LABEL_41;
    }

    HIDWORD(v30) = 32;
    if (*a7 < 0x20) {
      goto LABEL_44;
    }
    __s = 0uLL;
    id v32 = 0uLL;
    if ((a3 & 4) != 0)
    {
      if (a5 != 64) {
        goto LABEL_44;
      }
      id v25 = sub_1000A55F8(a4, a1 + 4, (_OWORD *)(a1 + 36), (uint64_t)&__s);
      unsigned int v26 = ccaes_cbc_decrypt_mode(v25);
      sub_1000A5B08(v26, 32LL, (uint64_t)&__s, (uint64_t)&unk_1000DBD80, 0x20uLL);
    }

    else
    {
      if (a5 != 72) {
        goto LABEL_44;
      }
      unsigned int v21 = sub_1000A55F8(a4, a1 + 4, (_OWORD *)(a1 + 36), (uint64_t)&__s);
      if (a3 < 0) {
        goto LABEL_28;
      }
      LODWORD(v30) = 32;
      if ((a3 & 8) != 0)
      {
        uint64_t v28 = ccsha256_di(v21);
        ((void (*)(uint64_t, uint64_t, __int128 *, void, void, uint64_t, const char *, uint64_t, _OWORD *, uint64_t))cchkdf)( v28,  32LL,  &__s,  0LL,  0LL,  v16,  v15,  32LL,  v33,  v30);
        unsigned int v22 = a4 + 4;
        p_s = v33;
      }

      else
      {
        unsigned int v22 = a4 + 4;
        p_s = &__s;
      }

      if (sub_100095EF4((uint64_t)p_s, 0x20u, 0xA6A6A6A6A6A6A6A6LL, 0LL, v22, 0x28u, a6, &v30))
      {
        memset_s(&__s, 0x20uLL, 0, 0x20uLL);
LABEL_46:
        unsigned int v8 = 4294967277LL;
        goto LABEL_41;
      }
    }

    memset_s(&__s, 0x20uLL, 0, 0x20uLL);
    unsigned int v8 = 0LL;
    *a7 = 32;
  }

LABEL_88:
        uint64_t v31 = 0LL;
LABEL_89:
        free(v31);
      }
    }

    sub_10001D70C(v9);
    sub_10001DA54(v9);
    sub_10002C7F8(v9, 0);
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v37 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v37, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)__str = 0LL;
      unsigned int v38 = sub_100053B4C(1);
      uint64_t v39 = (os_log_s *)v37;
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v40 = v38;
      }
      else {
        uint64_t v40 = v38 & 0xFFFFFFFE;
      }
      if ((_DWORD)v40)
      {
        *(_WORD *)v169 = 0;
        LODWORD(v16_Block_object_dispose(va, 8) = 2;
        uint64_t v41 = (char *)_os_log_send_and_compose_impl( v40,  __str,  0LL,  0LL,  &_mh_execute_header,  v39,  0LL,  "Unloaded the syncbubble, wait for a sec",  v169,  v168);

        if (v41) {
          sub_100053B7C(v41);
        }
      }

      else
      {

        uint64_t v41 = 0LL;
      }

      free(v41);
    }

    sleep(1u);
    CFDictionarySetValue(v1, kUMUserSessionForegroundKey, kCFBooleanFalse);
    if (!byte_1000DACB8 || (_DWORD)v9 == 502)
    {
LABEL_184:
      if (!v8) {
        goto LABEL_241;
      }
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      id v75 = (id)qword_1000DBA98;
      if (os_log_type_enabled((os_log_t)v75, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)v169 = 0LL;
        unsigned int v76 = sub_100053B4C(1);
        unsigned int v77 = (os_log_s *)v75;
        if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v78 = v76;
        }
        else {
          uint64_t v78 = v76 & 0xFFFFFFFE;
        }
        if ((_DWORD)v78)
        {
          *(_DWORD *)__str = 136315394;
          *(void *)&char __str[4] = __old;
          *(_WORD *)&__str[12] = 1024;
          LODWORD(v172) = v9;
          unsigned int v79 = (char *)_os_log_send_and_compose_impl( v78,  v169,  0LL,  0LL,  &_mh_execute_header,  v77,  0LL,  "Removing HomeDirectory:%s for the uid %d",  __str,  18);

          if (v79) {
            sub_100053B7C(v79);
          }
        }

        else
        {

          unsigned int v79 = 0LL;
        }

        free(v79);
      }

      if (sub_10002D61C(__old))
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        id v80 = (id)qword_1000DBA98;
        if (os_log_type_enabled((os_log_t)v80, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)__str = 0LL;
          unsigned int v81 = sub_100053B4C(1);
          uint64_t v82 = (os_log_s *)v80;
          if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v83 = v81;
          }
          else {
            uint64_t v83 = v81 & 0xFFFFFFFE;
          }
          if ((_DWORD)v83)
          {
            *(_WORD *)v169 = 0;
            LODWORD(v16_Block_object_dispose(va, 8) = 2;
            uint64_t v84 = (char *)_os_log_send_and_compose_impl( v83,  __str,  0LL,  0LL,  &_mh_execute_header,  v82,  0LL,  "User HomeDirectory successfully removed",  v169,  v168);

            if (v84) {
              sub_100053B7C(v84);
            }
          }

          else
          {

            uint64_t v84 = 0LL;
          }

          free(v84);
        }

        goto LABEL_240;
      }

      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      id v85 = (id)qword_1000DBA98;
      if (os_log_type_enabled((os_log_t)v85, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)__str = 0LL;
        unsigned int v86 = sub_100053B4C(1);
        id v87 = (os_log_s *)v85;
        if (os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v88 = v86;
        }
        else {
          uint64_t v88 = v86 & 0xFFFFFFFE;
        }
        if ((_DWORD)v88)
        {
          *(_WORD *)v169 = 0;
          LODWORD(v16_Block_object_dispose(va, 8) = 2;
          id v89 = (char *)_os_log_send_and_compose_impl( v88,  __str,  0LL,  0LL,  &_mh_execute_header,  v87,  0LL,  "User HomeDirectory could not be completely removed, moving it to delete on reboot",  v169,  v168);

          if (v89) {
            sub_100053B7C(v89);
          }
        }

        else
        {

          id v89 = 0LL;
        }

        free(v89);
      }

      mkpath_np("/private/var/DELETED", 0x1C0u);
      snprintf(__str, 0x400uLL, "/private/var/DELETED/euser_%d", v9);
      if (rename(__old, __str))
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        id v80 = (id)qword_1000DBA98;
        if (!os_log_type_enabled((os_log_t)v80, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_240;
        }
        v170[0] = 0LL;
        LODWORD(v90) = sub_100053B4C(1);
        id v80 = v80;
        if (os_log_type_enabled((os_log_t)v80, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v90 = v90;
        }
        else {
          uint64_t v90 = v90 & 0xFFFFFFFE;
        }
        if ((_DWORD)v90)
        {
          uint64_t v91 = __error();
          strerror(*v91);
          *(_DWORD *)v169 = 136315650;
          *(void *)&v169[4] = __old;
          LODWORD(v16_Block_object_dispose(va, 8) = 32;
          uint64_t v92 = _os_log_send_and_compose_impl( v90,  v170,  0LL,  0LL,  &_mh_execute_header,  v80,  0LL,  "Failed Move %s to %s with error:%s",  v169,  v168,  *(void *)v169);
          goto LABEL_236;
        }
      }

      else
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        id v80 = (id)qword_1000DBA98;
        if (!os_log_type_enabled((os_log_t)v80, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_240;
        }
        v170[0] = 0LL;
        unsigned int v93 = sub_100053B4C(1);
        id v80 = v80;
        if (os_log_type_enabled((os_log_t)v80, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v94 = v93;
        }
        else {
          uint64_t v94 = v93 & 0xFFFFFFFE;
        }
        if ((_DWORD)v94)
        {
          LODWORD(v16_Block_object_dispose(va, 8) = 22;
          uint64_t v92 = _os_log_send_and_compose_impl( v94,  v170,  0LL,  0LL,  &_mh_execute_header,  v80,  0LL,  "Moved %s to %s",  v169,  v168);
LABEL_236:
          uint64_t v95 = (char *)v92;

          if (v95) {
            sub_100053B7C(v95);
          }
          goto LABEL_239;
        }
      }

      uint64_t v95 = 0LL;
LABEL_239:
      free(v95);
LABEL_240:

      CFDictionarySetValue(v1, @"MKBUserSessionFileSystemSet", kCFBooleanFalse);
LABEL_241:
      if (_SecSyncDeleteUserViews(v9, 0LL))
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        uint64_t v96 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)__str = 0LL;
          unsigned int v97 = sub_100053B4C(1);
          if (os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v98 = v97;
          }
          else {
            uint64_t v98 = v97 & 0xFFFFFFFE;
          }
          if ((_DWORD)v98)
          {
            *(_WORD *)v169 = 0;
            LODWORD(v16_Block_object_dispose(va, 8) = 2;
            uid_t v99 = (const char *)_os_log_send_and_compose_impl( v98,  __str,  0LL,  0LL,  &_mh_execute_header,  v96,  0LL,  "_SecSyncDeleteUserViews succeeded",  v169,  v168);
            CFIndex v100 = (char *)v99;
            if (v99) {
              sub_100053B7C(v99);
            }
          }

          else
          {
            CFIndex v100 = 0LL;
          }

          free(v100);
        }

        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        id v106 = (id)qword_1000DBA98;
        if (os_log_type_enabled((os_log_t)v106, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)__str = 0LL;
          unsigned int v107 = sub_100053B4C(1);
          id v106 = v106;
          if (os_log_type_enabled((os_log_t)v106, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v108 = v107;
          }
          else {
            uint64_t v108 = v107 & 0xFFFFFFFE;
          }
          if ((_DWORD)v108)
          {
            *(_WORD *)v169 = 0;
            LODWORD(v16_Block_object_dispose(va, 8) = 2;
            uint64_t v109 = _os_log_send_and_compose_impl( v108,  __str,  0LL,  0LL,  &_mh_execute_header,  v106,  0LL,  "_SecSyncDeleteUserViews Success",  v169,  v168,  *(void *)v169);
            goto LABEL_280;
          }

          goto LABEL_282;
        }
      }

      else
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        char v101 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)__str = 0LL;
          unsigned int v102 = sub_100053B4C(1);
          if (os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v103 = v102;
          }
          else {
            uint64_t v103 = v102 & 0xFFFFFFFE;
          }
          if ((_DWORD)v103)
          {
            *(_WORD *)v169 = 0;
            LODWORD(v16_Block_object_dispose(va, 8) = 2;
            unsigned int v104 = (const char *)_os_log_send_and_compose_impl( v103,  __str,  0LL,  0LL,  &_mh_execute_header,  v101,  0LL,  "_SecSyncDeleteUserViews failed",  v169,  v168);
            uint64_t v105 = (char *)v104;
            if (v104) {
              sub_100053B7C(v104);
            }
          }

          else
          {
            uint64_t v105 = 0LL;
          }

          free(v105);
        }

        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        id v106 = (id)qword_1000DBA98;
        if (os_log_type_enabled((os_log_t)v106, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)__str = 0LL;
          unsigned int v110 = sub_100053B4C(1);
          id v106 = v106;
          if (os_log_type_enabled((os_log_t)v106, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v111 = v110;
          }
          else {
            uint64_t v111 = v110 & 0xFFFFFFFE;
          }
          if ((_DWORD)v111)
          {
            *(_WORD *)v169 = 0;
            LODWORD(v16_Block_object_dispose(va, 8) = 2;
            uint64_t v109 = _os_log_send_and_compose_impl( v111,  __str,  0LL,  0LL,  &_mh_execute_header,  v106,  0LL,  "_SecSyncDeleteUserViews FAILED",  v169,  v168,  *(void *)v169);
LABEL_280:
            id v112 = (char *)v109;

            if (v112) {
              sub_100053B7C(v112);
            }
            goto LABEL_283;
          }

      CFRelease(v24);
      goto LABEL_89;
    }
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  unsigned int v13 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t v54 = 0LL;
    uint64_t v14 = sub_100053B4C(1);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
      unsigned int v15 = v14;
    }
    else {
      unsigned int v15 = v14 & 0xFFFFFFFE;
    }
    if ((_DWORD)v15)
    {
      LOWORD(v53[0]) = 0;
      unsigned int v16 = (const char *)_os_log_send_and_compose_impl( v15,  v54,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  " NO PERSONAL PERSONA found",  v53,  2);
      uint64_t v17 = (char *)v16;
      if (v16) {
        sub_100053B7C(v16);
      }
    }

    else
    {
      uint64_t v17 = 0LL;
    }

    free(v17);
  }

  return 0LL;
}

LABEL_282:
          id v112 = 0LL;
LABEL_283:
          free(v112);
        }
      }

      if ([(id)qword_1000DBA68 splitUserVolumeEnabled])
      {
        if ((sub_10002DAA4(v1) & 1) != 0)
        {
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          id v113 = (id)qword_1000DBA98;
          if (os_log_type_enabled((os_log_t)v113, OS_LOG_TYPE_DEFAULT))
          {
            *(void *)__str = 0LL;
            unsigned int v114 = sub_100053B4C(1);
            uint64_t v115 = (os_log_s *)v113;
            if (os_log_type_enabled(v115, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v116 = v114;
            }
            else {
              uint64_t v116 = v114 & 0xFFFFFFFE;
            }
            if ((_DWORD)v116)
            {
              LODWORD(v170[0]) = 67109120;
              HIDWORD(v170[0]) = v9;
              CFNumberRef v117 = (char *)_os_log_send_and_compose_impl( v116,  __str,  0LL,  0LL,  &_mh_execute_header,  v115,  0LL,  "Removed user:%d AKS Identity",  v170);

              if (v117) {
                sub_100053B7C(v117);
              }
            }

            else
            {

              CFNumberRef v117 = 0LL;
            }

            free(v117);
          }

          goto LABEL_320;
        }

        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        id v120 = (id)qword_1000DBA98;
        if (os_log_type_enabled((os_log_t)v120, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)__str = 0LL;
          unsigned int v124 = sub_100053B4C(1);
          id v120 = v120;
          if (os_log_type_enabled((os_log_t)v120, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v125 = v124;
          }
          else {
            uint64_t v125 = v124 & 0xFFFFFFFE;
          }
          if ((_DWORD)v125)
          {
            LODWORD(v170[0]) = 67109120;
            HIDWORD(v170[0]) = v9;
            uint64_t v123 = _os_log_send_and_compose_impl( v125,  __str,  0LL,  0LL,  &_mh_execute_header,  v120,  0LL,  "Failed to remove user bag for session %d",  v170);
LABEL_312:
            v126 = (char *)v123;

            if (v126) {
              sub_100053B7C(v126);
            }
            goto LABEL_315;
          }

          goto LABEL_314;
        }
      }

      else
      {
        int v118 = MKBUserSessionDeleteKeybagForUser(v9, v169);
        if (!v118)
        {
LABEL_320:
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          uint64_t v127 = (os_log_s *)(id)qword_1000DBA98;
          if (!os_log_type_enabled(v127, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_332;
          }
          *(void *)__str = 0LL;
          unsigned int v128 = sub_100053B4C(1);
          CFTypeID v129 = v127;
          if (os_log_type_enabled(v129, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v130 = v128;
          }
          else {
            uint64_t v130 = v128 & 0xFFFFFFFE;
          }
          if ((_DWORD)v130)
          {
            LOWORD(v170[0]) = 0;
            LODWORD(v16_Block_object_dispose(va, 8) = 2;
            CFTypeID v131 = (const char *)_os_log_send_and_compose_impl( v130,  __str,  0LL,  0LL,  &_mh_execute_header,  v129,  0LL,  "layoutDeleteOnly as its already background",  v170,  v168);

            if (v131) {
              sub_100053B7C(v131);
            }
          }

          else
          {

            CFTypeID v131 = 0LL;
          }

          uint64_t v132 = (char *)v131;
LABEL_331:
          free(v132);
LABEL_332:

          goto LABEL_359;
        }

        int v119 = v118;
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        id v120 = (id)qword_1000DBA98;
        if (os_log_type_enabled((os_log_t)v120, OS_LOG_TYPE_DEFAULT))
        {
          v170[0] = 0LL;
          unsigned int v121 = sub_100053B4C(1);
          id v120 = v120;
          if (os_log_type_enabled((os_log_t)v120, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v122 = v121;
          }
          else {
            uint64_t v122 = v121 & 0xFFFFFFFE;
          }
          if ((_DWORD)v122)
          {
            *(_DWORD *)__str = 67109376;
            *(_DWORD *)&char __str[4] = v9;
            *(_WORD *)&__str[8] = 1024;
            *(_DWORD *)&__str[10] = v119;
            uint64_t v123 = _os_log_send_and_compose_impl( v122,  v170,  0LL,  0LL,  &_mh_execute_header,  v120,  0LL,  "Failed to remove user bag for session %d: %d",  __str);
            goto LABEL_312;
          }

LABEL_314:
          v126 = 0LL;
LABEL_315:
          free(v126);
        }
      }

      return 0LL;
    }

    if ([(id)qword_1000DBA68 deleteVolumeWithSession:v1 error:0])
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      int v42 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_126;
      }
      *(void *)__str = 0LL;
      unsigned int v43 = sub_100053B4C(1);
      int v42 = v42;
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v44 = v43;
      }
      else {
        uint64_t v44 = v43 & 0xFFFFFFFE;
      }
      if ((_DWORD)v44)
      {
        uint64_t v45 = _os_log_send_and_compose_impl( v44,  __str,  0LL,  0LL,  &_mh_execute_header,  v42,  0LL,  "Removed APFS User volume for user %d",  v169);
        goto LABEL_122;
      }
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      int v42 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_126;
      }
      *(void *)__str = 0LL;
      unsigned int v46 = sub_100053B4C(1);
      int v42 = v42;
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v47 = v46;
      }
      else {
        uint64_t v47 = v46 & 0xFFFFFFFE;
      }
      if ((_DWORD)v47)
      {
        uint64_t v45 = _os_log_send_and_compose_impl( v47,  __str,  0LL,  0LL,  &_mh_execute_header,  v42,  0LL,  "Failed to remove APFS User volume for user %d",  v169);
LABEL_122:
        uint64_t v48 = (char *)v45;

        if (v48) {
          sub_100053B7C(v48);
        }
        goto LABEL_125;
      }
    }

    uint64_t v48 = 0LL;
LABEL_125:
    free(v48);
LABEL_126:

    int v49 = sub_10002A4AC(v1, v9, 1);
    if (v49)
    {
      int v50 = v49;
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      id v51 = (id)qword_1000DBA98;
      if (os_log_type_enabled((os_log_t)v51, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)v169 = 0LL;
        unsigned int v52 = sub_100053B4C(1);
        id v51 = v51;
        if (os_log_type_enabled((os_log_t)v51, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v53 = v52;
        }
        else {
          uint64_t v53 = v52 & 0xFFFFFFFE;
        }
        if ((_DWORD)v53)
        {
          *(_DWORD *)__str = 67109376;
          *(_DWORD *)&char __str[4] = v9;
          *(_WORD *)&__str[8] = 1024;
          *(_DWORD *)&__str[10] = v50;
          uint64_t v54 = (char *)_os_log_send_and_compose_impl( v53,  v169,  0LL,  0LL,  &_mh_execute_header,  v51,  0LL,  "Failed to remove SyncBag for the user:%d with error:%d",  __str,  14);

          if (v54) {
            sub_100053B7C(v54);
          }
        }

        else
        {

          uint64_t v54 = 0LL;
        }

        free(v54);
      }
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      id v51 = (id)qword_1000DBA98;
      if (os_log_type_enabled((os_log_t)v51, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)__str = 0LL;
        unsigned int v55 = sub_100053B4C(1);
        id v51 = v51;
        if (os_log_type_enabled((os_log_t)v51, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v56 = v55;
        }
        else {
          uint64_t v56 = v55 & 0xFFFFFFFE;
        }
        if ((_DWORD)v56)
        {
          *(_WORD *)v169 = 0;
          LODWORD(v16_Block_object_dispose(va, 8) = 2;
          vm_size_t v57 = (char *)_os_log_send_and_compose_impl( v56,  __str,  0LL,  0LL,  &_mh_execute_header,  v51,  0LL,  "Removed Syncbag for User successfully",  v169,  v168);

          if (v57) {
            sub_100053B7C(v57);
          }
        }

        else
        {

          vm_size_t v57 = 0LL;
        }

        free(v57);
      }
    }

    goto LABEL_184;
  }

  if (v11)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v12 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_57;
    }
    *(void *)__old = 0LL;
    unsigned int v16 = sub_100053B4C(1);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v14 = v16;
    }
    else {
      uint64_t v14 = v16 & 0xFFFFFFFE;
    }
    if ((_DWORD)v14)
    {
      *(_WORD *)__str = 0;
      LODWORD(v16_Block_object_dispose(va, 8) = 2;
      uid_t v167 = __str;
      unsigned int v15 = "CANNOT Delete a PRIMARY USER SESSION, REMOVE USER FAILED";
      goto LABEL_41;
    }

uint64_t sub_10002C7F8(uint64_t a1, int a2)
{
  uint64_t v4 = launch_destroy_persona(a1, 0LL);
  if ((_DWORD)v4)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v5 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v82 = 0LL;
      unsigned int v6 = sub_100053B4C(1);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v7 = v6;
      }
      else {
        uint64_t v7 = v6 & 0xFFFFFFFE;
      }
      if ((_DWORD)v7)
      {
        *(_DWORD *)unsigned int v81 = 67109376;
        *(_DWORD *)&v81[4] = a1;
        *(_WORD *)&v81[8] = 1024;
        *(_DWORD *)&v81[10] = v4;
        unsigned int v8 = (const char *)_os_log_send_and_compose_impl( v7,  &v82,  0LL,  0LL,  &_mh_execute_header,  v5,  0LL,  "Failed to destroy persona domain for uid:%d with error:%d",  v81);
        goto LABEL_18;
      }

      goto LABEL_20;
    }
  }

  else
  {
    dword_1000DACBC = -1;
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v5 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)unsigned int v81 = 0LL;
      unsigned int v9 = sub_100053B4C(1);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = v9 & 0xFFFFFFFE;
      }
      if ((_DWORD)v10)
      {
        LODWORD(v82) = 67109120;
        HIDWORD(v82) = a1;
        unsigned int v8 = (const char *)_os_log_send_and_compose_impl( v10,  v81,  0LL,  0LL,  &_mh_execute_header,  v5,  0LL,  "Destroyed persona domain for uid:%d ",  &v82);
LABEL_18:
        unsigned int v11 = (char *)v8;
        if (v8) {
          sub_100053B7C(v8);
        }
        goto LABEL_21;
      }

LABEL_158:
          unsigned int v67 = 0LL;
LABEL_159:
          free(v67);
LABEL_160:

LABEL_161:
          if (a2)
          {
            unsigned int v68 = sub_100083DA4(v19, kUMUserSessionDisabledKey);
            unsigned int v69 = sub_100083DA4(v19, kUMUserSessionDirtyKey);
            if (v68)
            {
              if (!v69)
              {
                if (qword_1000DBAA0 != -1) {
                  dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                }
                id v70 = (os_log_s *)(id)qword_1000DBA98;
                if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v82 = 0LL;
                  unsigned int v71 = sub_100053B4C(1);
                  if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT)) {
                    uint64_t v72 = v71;
                  }
                  else {
                    uint64_t v72 = v71 & 0xFFFFFFFE;
                  }
                  if ((_DWORD)v72)
                  {
                    *(_DWORD *)unsigned int v81 = 136315394;
                    *(void *)&v81[4] = "unload_syncdomain";
                    *(_WORD *)&v81[12] = 2080;
                    *(void *)&v81[14] = kMobileKeyBagUserChangedNotificationToken;
                    LODWORD(v79) = 22;
                    unsigned int v73 = (const char *)_os_log_send_and_compose_impl( v72,  &v82,  0LL,  0LL,  &_mh_execute_header,  v70,  0LL,  "usermanagerd %s posting notification: %s\n",  v81,  v79);
                    id v74 = (char *)v73;
                    if (v73) {
                      sub_100053B7C(v73);
                    }
                  }

                  else
                  {
                    id v74 = 0LL;
                  }

                  free(v74);
                }

                uint64_t v75 = sub_100018E74(qword_1000DBD40);
                unsigned int v76 = (void *)objc_claimAutoreleasedReturnValue(v75);
                unsigned int v77 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  kMobileKeyBagUserChangedNotificationToken));
                [v76 post:v77];
              }
            }
          }

          CFRelease(v19);
          return v4;
        }

        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        uint64_t v34 = (os_log_s *)(id)qword_1000DBA98;
        if (!os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_160;
        }
        *(void *)unsigned int v81 = 0LL;
        unsigned int v61 = sub_100053B4C(1);
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v62 = v61;
        }
        else {
          uint64_t v62 = v61 & 0xFFFFFFFE;
        }
        if (!(_DWORD)v62) {
          goto LABEL_158;
        }
        LODWORD(v82) = 67109120;
        HIDWORD(v82) = a1;
        id v37 = (const char *)_os_log_send_and_compose_impl( v62,  v81,  0LL,  0LL,  &_mh_execute_header,  v34,  0LL,  "Successfully unloaded the SyncBag for user:%d",  &v82);
      }

      else
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        uint64_t v54 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)unsigned int v81 = 0LL;
          unsigned int v55 = sub_100053B4C(1);
          if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v56 = v55;
          }
          else {
            uint64_t v56 = v55 & 0xFFFFFFFE;
          }
          if ((_DWORD)v56)
          {
            LODWORD(v82) = 67109120;
            HIDWORD(v82) = a1;
            vm_size_t v57 = (const char *)_os_log_send_and_compose_impl( v56,  v81,  0LL,  0LL,  &_mh_execute_header,  v54,  0LL,  "No pending sync services, trying to remove syncbag for user:%d",  &v82);
            uint64_t v58 = (char *)v57;
            if (v57) {
              sub_100053B7C(v57);
            }
          }

          else
          {
            uint64_t v58 = 0LL;
          }

          free(v58);
        }

        if (sub_10002A4AC(v19, a1, 1))
        {
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          uint64_t v34 = (os_log_s *)(id)qword_1000DBA98;
          if (!os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_160;
          }
          *(void *)unsigned int v81 = 0LL;
          unsigned int v63 = sub_100053B4C(1);
          if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v64 = v63;
          }
          else {
            uint64_t v64 = v63 & 0xFFFFFFFE;
          }
          if (!(_DWORD)v64) {
            goto LABEL_158;
          }
          LODWORD(v82) = 67109120;
          HIDWORD(v82) = a1;
          id v37 = (const char *)_os_log_send_and_compose_impl( v64,  v81,  0LL,  0LL,  &_mh_execute_header,  v34,  0LL,  "Failed to remove SyncBag for user:%d",  &v82);
        }

        else
        {
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          uint64_t v34 = (os_log_s *)(id)qword_1000DBA98;
          if (!os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_160;
          }
          *(void *)unsigned int v81 = 0LL;
          unsigned int v65 = sub_100053B4C(1);
          if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v66 = v65;
          }
          else {
            uint64_t v66 = v65 & 0xFFFFFFFE;
          }
          if (!(_DWORD)v66) {
            goto LABEL_158;
          }
          LODWORD(v82) = 67109120;
          HIDWORD(v82) = a1;
          id v37 = (const char *)_os_log_send_and_compose_impl( v66,  v81,  0LL,  0LL,  &_mh_execute_header,  v34,  0LL,  "Successfully removed the SyncBag for user:%d",  &v82);
        }
      }

LABEL_156:
      unsigned int v67 = (char *)v37;
      if (v37) {
        sub_100053B7C(v37);
      }
      goto LABEL_159;
    }

    uint64_t v28 = v27;
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v29 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v82 = 0LL;
      unsigned int v30 = sub_100053B4C(1);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v31 = v30;
      }
      else {
        uint64_t v31 = v30 & 0xFFFFFFFE;
      }
      if ((_DWORD)v31)
      {
        *(_DWORD *)unsigned int v81 = 138412546;
        *(void *)&v81[4] = v28;
        *(_WORD *)&v81[12] = 1024;
        *(_DWORD *)&v81[14] = a1;
        LODWORD(v79) = 18;
        id v32 = (const char *)_os_log_send_and_compose_impl( v31,  &v82,  0LL,  0LL,  &_mh_execute_header,  v29,  0LL,  "VolumeUnMap for disk%@ for uid :%d",  v81,  v79);
        unsigned int v33 = (char *)v32;
        if (v32) {
          sub_100053B7C(v32);
        }
      }

      else
      {
        unsigned int v33 = 0LL;
      }

      free(v33);
    }

    uint64_t v38 = sub_100019B18(qword_1000DBD40);
    uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue(v38);
    id v80 = 0LL;
    unsigned int v40 = [v39 unmapVolume:v28 error:&v80];
    id v41 = v80;

    if (v40)
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      int v42 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_98;
      }
      *(void *)unsigned int v81 = 0LL;
      unsigned int v43 = sub_100053B4C(1);
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v44 = v43;
      }
      else {
        uint64_t v44 = v43 & 0xFFFFFFFE;
      }
      if ((_DWORD)v44)
      {
        LODWORD(v82) = 67109120;
        HIDWORD(v82) = a1;
        uint64_t v45 = (void *)_os_log_send_and_compose_impl( v44,  v81,  0LL,  0LL,  &_mh_execute_header,  v42,  0LL,  "VolumeUnMap for uid%d succeeded",  &v82);
        if (!v45) {
          goto LABEL_97;
        }
        goto LABEL_95;
      }
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      int v42 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_98;
      }
      uint64_t v82 = 0LL;
      LODWORD(v46) = sub_100053B4C(1);
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v46 = v46;
      }
      else {
        uint64_t v46 = v46 & 0xFFFFFFFE;
      }
      if ((_DWORD)v46)
      {
        uint64_t v47 = v42;
        id v48 = [v41 code];
        *(_DWORD *)unsigned int v81 = 67109376;
        *(_DWORD *)&v81[4] = a1;
        *(_WORD *)&v81[8] = 2048;
        *(void *)&v81[10] = v48;
        LODWORD(v79) = 18;
        uint64_t v45 = (void *)_os_log_send_and_compose_impl( v46,  &v82,  0LL,  0LL,  &_mh_execute_header,  v47,  0LL,  "VolumeUnMap for uid:%d failed with error:%ld",  v81,  v79);

        if (!v45)
        {
LABEL_97:
          free(v45);
LABEL_98:

          goto LABEL_99;
        }

uint64_t sub_10002D61C(const char *a1)
{
  id v2 = removefile_state_alloc();
  int value = 0;
  if (removefile_state_set(v2, 3u, sub_1000454D8))
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v3 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v27 = 0LL;
      LODWORD(v4) = sub_100053B4C(1);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v4 = v4;
      }
      else {
        uint64_t v4 = v4 & 0xFFFFFFFE;
      }
      if ((_DWORD)v4)
      {
        uint64_t v5 = v3;
        unsigned int v6 = __error();
        uint64_t v7 = strerror(*v6);
        int v29 = 136315138;
        unsigned int v30 = v7;
        unsigned int v8 = (char *)_os_log_send_and_compose_impl( v4,  &v27,  0LL,  0LL,  &_mh_execute_header,  v5,  0LL,  "removefile_state_set REMOVEFILE_STATE_ERROR_CALLBACK failed: %s",  (const char *)&v29);

        if (v8) {
          sub_100053B7C(v8);
        }
      }

      else
      {
        unsigned int v8 = 0LL;
      }

      free(v8);
    }
  }

  if (removefile_state_set(v2, 4u, &value))
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v9 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v27 = 0LL;
      LODWORD(v10) = sub_100053B4C(1);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v10 = v10;
      }
      else {
        uint64_t v10 = v10 & 0xFFFFFFFE;
      }
      if ((_DWORD)v10)
      {
        unsigned int v11 = v9;
        unsigned int v12 = __error();
        unsigned int v13 = strerror(*v12);
        int v29 = 136315138;
        unsigned int v30 = v13;
        uint64_t v14 = (char *)_os_log_send_and_compose_impl( v10,  &v27,  0LL,  0LL,  &_mh_execute_header,  v11,  0LL,  "removefile_state_set REMOVEFILE_STATE_ERROR_CONTEXT failed: %s",  (const char *)&v29);

        if (v14) {
          sub_100053B7C(v14);
        }
      }

      else
      {
        uint64_t v14 = 0LL;
      }

      free(v14);
    }
  }

  if (removefile(a1, v2, 1u))
  {
    int v15 = *__error();
    if (v15 != 2)
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      unsigned int v16 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_51;
      }
      uint64_t v27 = 0LL;
      LODWORD(v22) = sub_100053B4C(1);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v22 = v22;
      }
      else {
        uint64_t v22 = v22 & 0xFFFFFFFE;
      }
      if ((_DWORD)v22)
      {
        int v19 = v16;
        uint64_t v23 = strerror(v15);
        int v29 = 136315394;
        unsigned int v30 = (void *)a1;
        __int16 v31 = 2080;
        id v32 = v23;
        uint64_t v21 = _os_log_send_and_compose_impl( v22,  &v27,  0LL,  0LL,  &_mh_execute_header,  v19,  0LL,  "removefile for %s failed with error:%s",  &v29,  22);
LABEL_46:
        unsigned int v24 = (char *)v21;

        if (v24) {
          sub_100053B7C(v24);
        }
        goto LABEL_50;
      }

LABEL_49:
      unsigned int v24 = 0LL;
LABEL_50:
      free(v24);
LABEL_51:

      uint64_t v25 = 0LL;
      goto LABEL_52;
    }
  }

  if ((value & 0xFFFFFFFD) != 0)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v16 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_51;
    }
    uint64_t v27 = 0LL;
    LODWORD(v17) = sub_100053B4C(1);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v17 = v17;
    }
    else {
      uint64_t v17 = v17 & 0xFFFFFFFE;
    }
    if ((_DWORD)v17)
    {
      int v18 = value;
      int v19 = v16;
      unsigned int v20 = strerror(v18);
      int v29 = 136315394;
      unsigned int v30 = (void *)a1;
      __int16 v31 = 2080;
      id v32 = v20;
      uint64_t v21 = _os_log_send_and_compose_impl( v17,  &v27,  0LL,  0LL,  &_mh_execute_header,  v19,  0LL,  "removefile for %s failed with error:%s",  &v29,  22);
      goto LABEL_46;
    }

    goto LABEL_49;
  }

  uint64_t v25 = 1LL;
LABEL_52:
  removefile_state_free(v2);
  return v25;
}

        uint64_t v28 = 0LL;
LABEL_50:
        free(v28);
LABEL_51:

        int v29 = v4;
LABEL_55:

        return v4;
      default:
        if (qword_1000DBB68 != -1) {
          dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
        }
        unsigned int v13 = (os_log_s *)(id)qword_1000DBB60;
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_51;
        }
        __int16 v31 = 0LL;
        unsigned int v26 = sub_100053B4C(1);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v27 = v26;
        }
        else {
          uint64_t v27 = v26 & 0xFFFFFFFE;
        }
        if (!(_DWORD)v27) {
          goto LABEL_49;
        }
        LOWORD(v33[0]) = 0;
        unsigned int v16 = (const char *)_os_log_send_and_compose_impl( v27,  &v31,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "Created Personal Persona Successfully",  v33,  2);
        break;
    }

    uint64_t v28 = (char *)v16;
    if (v16) {
      sub_100053B7C(v16);
    }
    goto LABEL_50;
  }

  return v4;
}

        uint64_t v21 = 0LL;
LABEL_50:
        free(v21);
        goto LABEL_51;
      }

      uint64_t v7 = 0LL;
      if (v13 == 5 || v14 == 5) {
        goto LABEL_52;
      }
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      int v15 = (os_log_s *)(id)qword_1000DBB60;
      if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
LABEL_51:

        uint64_t v7 = 1LL;
LABEL_52:

LABEL_53:
        goto LABEL_54;
      }

      uint64_t v25 = 0LL;
      uint64_t v22 = sub_100053B4C(1);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v23 = v22;
      }
      else {
        uint64_t v23 = v22 & 0xFFFFFFFE;
      }
      if (!(_DWORD)v23) {
        goto LABEL_49;
      }
      LOWORD(v26[0]) = 0;
      int v18 = (const char *)_os_log_send_and_compose_impl( v23,  &v25,  0LL,  0LL,  &_mh_execute_header,  v15,  0LL,  "Warning: System Session personas exist, but neither of them is a Default type",  v26,  2);
    }

    else
    {
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      int v15 = (os_log_s *)(id)qword_1000DBB60;
      if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_51;
      }
      uint64_t v25 = 0LL;
      int v19 = sub_100053B4C(1);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
        unsigned int v20 = v19;
      }
      else {
        unsigned int v20 = v19 & 0xFFFFFFFE;
      }
      if (!(_DWORD)v20) {
        goto LABEL_49;
      }
      LOWORD(v26[0]) = 0;
      int v18 = (const char *)_os_log_send_and_compose_impl( v20,  &v25,  0LL,  0LL,  &_mh_execute_header,  v15,  0LL,  "Warning: System Session personas exist, but are corrupted",  v26,  2);
    }

uint64_t sub_10002DAA4(const __CFDictionary *a1)
{
  id v2 = (void *)sub_100083DF4(a1, kUMUserSessionUUIDKey);
  int v3 = sub_100083C6C(a1, kMKBUserSessionIDKey);
  if (v2)
  {
    int v4 = v3;
    uint64_t v5 = sub_100017CFC((uint64_t)&OBJC_CLASS___NSUUID, v2);
    unsigned int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
    if (v6)
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v7 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v43 = 0LL;
        unsigned int v8 = sub_100053B4C(1);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v9 = v8;
        }
        else {
          uint64_t v9 = v8 & 0xFFFFFFFE;
        }
        if ((_DWORD)v9)
        {
          LOWORD(v46) = 0;
          uint64_t v10 = (const char *)_os_log_send_and_compose_impl( v9,  &v43,  0LL,  0LL,  &_mh_execute_header,  v7,  0LL,  "GOT UUID from uuidstring",  &v46,  2);
          unsigned int v11 = (char *)v10;
          if (v10) {
            sub_100053B7C(v10);
          }
        }

        else
        {
          unsigned int v11 = 0LL;
        }

        free(v11);
      }

      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v21 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v43 = 0LL;
        unsigned int v22 = sub_100053B4C(1);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v23 = v22;
        }
        else {
          uint64_t v23 = v22 & 0xFFFFFFFE;
        }
        if ((_DWORD)v23)
        {
          LODWORD(v46) = 67109120;
          HIDWORD(v46) = v4;
          unsigned int v24 = (const char *)_os_log_send_and_compose_impl( v23,  &v43,  0LL,  0LL,  &_mh_execute_header,  v21,  0LL,  "DELETING the identity for user:%d",  &v46);
          uint64_t v25 = (char *)v24;
          if (v24) {
            sub_100053B7C(v24);
          }
        }

        else
        {
          uint64_t v25 = 0LL;
        }

        free(v25);
      }

      uint64_t v26 = sub_100019B18(qword_1000DBD40);
      uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue(v26);
      id v42 = 0LL;
      unsigned __int8 v28 = [v27 deleteIdentity:v6 error:&v42];
      id v16 = v42;

      if ((v28 & 1) != 0)
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        int v29 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v43 = 0LL;
          unsigned int v30 = sub_100053B4C(1);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v31 = v30;
          }
          else {
            uint64_t v31 = v30 & 0xFFFFFFFE;
          }
          if ((_DWORD)v31)
          {
            LODWORD(v46) = 67109120;
            HIDWORD(v46) = v4;
            id v32 = (const char *)_os_log_send_and_compose_impl( v31,  &v43,  0LL,  0LL,  &_mh_execute_header,  v29,  0LL,  "AKS Identity for user:%d Successfully Deleted",  &v46);
            unsigned int v33 = (char *)v32;
            if (v32) {
              sub_100053B7C(v32);
            }
          }

          else
          {
            unsigned int v33 = 0LL;
          }

          free(v33);
        }

        uint64_t v39 = 1LL;
        goto LABEL_74;
      }

      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v34 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v46 = 0LL;
        LODWORD(v35) = sub_100053B4C(1);
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v35 = v35;
        }
        else {
          uint64_t v35 = v35 & 0xFFFFFFFE;
        }
        if ((_DWORD)v35)
        {
          uint64_t v36 = v34;
          id v37 = [v16 code];
          LODWORD(v43) = 67109376;
          HIDWORD(v43) = v4;
          __int16 v44 = 2048;
          id v45 = v37;
          LODWORD(v41) = 18;
          uint64_t v38 = (char *)_os_log_send_and_compose_impl( v35,  &v46,  0LL,  0LL,  &_mh_execute_header,  v36,  0LL,  "Deleting AKS Identity for user:%d failed with %ld",  &v43,  v41);

          if (v38) {
            sub_100053B7C(v38);
          }
        }

        else
        {
          uint64_t v38 = 0LL;
        }

        free(v38);
      }
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      id v16 = (id)qword_1000DBA98;
      if (os_log_type_enabled((os_log_t)v16, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v43 = 0LL;
        unsigned int v17 = sub_100053B4C(1);
        if (os_log_type_enabled((os_log_t)v16, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v18 = v17;
        }
        else {
          uint64_t v18 = v17 & 0xFFFFFFFE;
        }
        if ((_DWORD)v18)
        {
          LOWORD(v46) = 0;
          int v19 = (const char *)_os_log_send_and_compose_impl( v18,  &v43,  0LL,  0LL,  &_mh_execute_header,  v16,  0LL,  "NULL UUID, failure, bailing",  &v46,  2);
          unsigned int v20 = (char *)v19;
          if (v19) {
            sub_100053B7C(v19);
          }
        }

        else
        {
          unsigned int v20 = 0LL;
        }

        free(v20);
      }
    }

    uint64_t v39 = 0LL;
LABEL_74:

    goto LABEL_75;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  unsigned int v6 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v43 = 0LL;
    unsigned int v12 = sub_100053B4C(1);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v13 = v12;
    }
    else {
      uint64_t v13 = v12 & 0xFFFFFFFE;
    }
    if ((_DWORD)v13)
    {
      LOWORD(v46) = 0;
      uint64_t v14 = (const char *)_os_log_send_and_compose_impl( v13,  &v43,  0LL,  0LL,  &_mh_execute_header,  v6,  0LL,  "No UUID for the primary, bail",  &v46,  2);
      int v15 = (char *)v14;
      if (v14) {
        sub_100053B7C(v14);
      }
    }

    else
    {
      int v15 = 0LL;
    }

    free(v15);
  }

  uint64_t v39 = 0LL;
LABEL_75:

  return v39;
}

uint64_t sub_10002E0A4(int a1, int a2)
{
  uint64_t result = qword_1000DBCD8;
  if (qword_1000DBCD8)
  {
    if (CFArrayGetCount((CFArrayRef)qword_1000DBCD8) < 1)
    {
      return 0LL;
    }

    else
    {
      CFIndex v5 = 0LL;
      while (1)
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)qword_1000DBCD8, v5);
        if (ValueAtIndex)
        {
          uint64_t v7 = ValueAtIndex;
          CFTypeID v8 = CFGetTypeID(ValueAtIndex);
          if (v8 == CFDictionaryGetTypeID())
          {
            Value = (const __CFNumber *)CFDictionaryGetValue(v7, kUMUserSessionIDKey);
            if (Value)
            {
              uint64_t v10 = Value;
              CFTypeID v11 = CFGetTypeID(Value);
              if (v11 == CFNumberGetTypeID() && CFNumberGetValue(v10, kCFNumberIntType, &valuePtr) && valuePtr == a1) {
                break;
              }
            }
          }
        }

        if (CFArrayGetCount((CFArrayRef)qword_1000DBCD8) <= ++v5) {
          return 0LL;
        }
      }

      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v13 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v19 = 0LL;
        unsigned int v14 = sub_100053B4C(1);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v15 = v14;
        }
        else {
          uint64_t v15 = v14 & 0xFFFFFFFE;
        }
        if ((_DWORD)v15)
        {
          v21[0] = 67109120;
          v21[1] = a1;
          id v16 = (const char *)_os_log_send_and_compose_impl( v15,  &v19,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "found the Usersession with uid=%d, removing",  v21);
          unsigned int v17 = (char *)v16;
          if (v16) {
            sub_100053B7C(v16);
          }
        }

        else
        {
          unsigned int v17 = 0LL;
        }

        free(v17);
      }

      CFArrayRemoveValueAtIndex((CFMutableArrayRef)qword_1000DBCD8, v5);
      CFIndex Count = CFArrayGetCount((CFArrayRef)qword_1000DBCD8);
      qword_1000DBCE0 = Count;
      if (!byte_1000DACB8 && Count == 1)
      {
        qword_1000DBA88 = (uint64_t)kUMUserSessionAPFSNativeVolume;
        byte_1000DACB8 = 1;
      }

      if (a2) {
        sub_100036954(a1);
      }
      return 1LL;
    }
  }

  return result;
}

BOOL sub_10002E2F8(const __CFDictionary *a1)
{
  CFTypeRef v1 = sub_100021AC4(a1);
  int v2 = sub_10002A878((uint64_t)v1);
  if (v1) {
    CFRelease(v1);
  }
  return v2 != 0;
}

uint64_t sub_10002E334(const __CFDictionary *a1, uint64_t a2, const __CFData *a3)
{
  if (a3)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v6 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v13[0] = 0LL;
      LODWORD(v7) = sub_100053B4C(1);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v7 = v7;
      }
      else {
        uint64_t v7 = v7 & 0xFFFFFFFE;
      }
      if ((_DWORD)v7)
      {
        CFTypeID v8 = v6;
        *(_DWORD *)unsigned int v14 = 134217984;
        *(void *)&v14[4] = CFDataGetLength(a3);
        uint64_t v9 = (void *)_os_log_send_and_compose_impl( v7,  v13,  0LL,  0LL,  &_mh_execute_header,  v8,  0LL,  "switchToUserSessionNoUID with BLOB of size %ld",  v14);

        if (!v9) {
          goto LABEL_21;
        }
        goto LABEL_19;
      }

      goto LABEL_20;
    }
  }

  else
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v6 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)unsigned int v14 = 0LL;
      unsigned int v10 = sub_100053B4C(1);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = v10 & 0xFFFFFFFE;
      }
      if ((_DWORD)v11)
      {
        LOWORD(v13[0]) = 0;
        uint64_t v9 = (void *)_os_log_send_and_compose_impl( v11,  v14,  0LL,  0LL,  &_mh_execute_header,  v6,  0LL,  "switchToUserSessionNoUID, NO BLOB",  v13,  2);
        if (!v9)
        {
LABEL_21:
          free(v9);
          goto LABEL_22;
        }

uint64_t sub_10002E554(const __CFDictionary *a1, uint64_t a2, const __CFData *a3)
{
  unsigned int v6 = (const __CFDictionary *)sub_100021AC4(a1);
  if (v6) {
    goto LABEL_14;
  }
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v7 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t v31 = 0LL;
    unsigned int v8 = sub_100053B4C(1);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v9 = v8;
    }
    else {
      uint64_t v9 = v8 & 0xFFFFFFFE;
    }
    if ((_DWORD)v9)
    {
      LOWORD(v30[0]) = 0;
      unsigned int v10 = (const char *)_os_log_send_and_compose_impl( v9,  v31,  0LL,  0LL,  &_mh_execute_header,  v7,  0LL,  "switchUserSession: Trying to create a newsession(with null passcode) as nothing existing for it",  v30,  2);
      uint64_t v11 = (char *)v10;
      if (v10) {
        sub_100053B7C(v10);
      }
    }

    else
    {
      uint64_t v11 = 0LL;
    }

    free(v11);
  }

  unsigned int v6 = sub_100023D64(a1, 0LL, 0LL, 0LL);
  if (v6)
  {
LABEL_14:
    int v12 = sub_100083C6C(v6, kUMUserSessionIDKey);
    if (dword_1000DBCE8 == 1 && v12 == 502) {
      sub_10002A024();
    }
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v13 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)uint64_t v31 = 0LL;
      unsigned int v14 = sub_100053B4C(1);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v15 = v14;
      }
      else {
        uint64_t v15 = v14 & 0xFFFFFFFE;
      }
      if ((_DWORD)v15)
      {
        LOWORD(v30[0]) = 0;
        LODWORD(v29) = 2;
        id v16 = (const char *)_os_log_send_and_compose_impl( v15,  v31,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "switchUserSession: found an existing session",  v30,  v29);
        unsigned int v17 = (char *)v16;
        if (v16) {
          sub_100053B7C(v16);
        }
      }

      else
      {
        unsigned int v17 = 0LL;
      }

      free(v17);
    }

    if (a3)
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v18 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        v30[0] = 0LL;
        LODWORD(v19) = sub_100053B4C(1);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v19 = v19;
        }
        else {
          uint64_t v19 = v19 & 0xFFFFFFFE;
        }
        if ((_DWORD)v19)
        {
          unsigned int v20 = v18;
          CFIndex Length = CFDataGetLength(a3);
          *(_DWORD *)uint64_t v31 = 134217984;
          *(void *)&v31[4] = Length;
          unsigned int v22 = (char *)_os_log_send_and_compose_impl( v19,  v30,  0LL,  0LL,  &_mh_execute_header,  v20,  0LL,  "switchUserSession setting BLOB with size %ld",  v31);

          if (v22) {
            sub_100053B7C(v22);
          }
        }

        else
        {
          unsigned int v22 = 0LL;
        }

        free(v22);
      }

      CFDictionarySetValue(v6, @"UserSwitchTaskOpqueData", a3);
    }

    else if (CFDictionaryContainsKey(v6, @"UserSwitchTaskOpqueData"))
    {
      CFDictionaryRemoveValue(v6, @"UserSwitchTaskOpqueData");
    }

    id v23 = (id)objc_claimAutoreleasedReturnValue(+[RDServer sharedServer](&OBJC_CLASS___RDServer, "sharedServer"));
    [v23 switchToUser:v6 passcodeData:a2];
  }

  else
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v23 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v23, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)uint64_t v31 = 0LL;
      unsigned int v24 = sub_100053B4C(1);
      if (os_log_type_enabled((os_log_t)v23, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v25 = v24;
      }
      else {
        uint64_t v25 = v24 & 0xFFFFFFFE;
      }
      if ((_DWORD)v25)
      {
        LOWORD(v30[0]) = 0;
        LODWORD(v29) = 2;
        uint64_t v26 = (const char *)_os_log_send_and_compose_impl( v25,  v31,  0LL,  0LL,  &_mh_execute_header,  v23,  0LL,  "Could not setup new session, switchsession failed",  v30,  v29);
        uint64_t v27 = (char *)v26;
        if (v26) {
          sub_100053B7C(v26);
        }
      }

      else
      {
        uint64_t v27 = 0LL;
      }

      free(v27);
    }
  }

  return 0LL;
}

uint64_t sub_10002E9D0()
{
  id v0 = sub_100054ED0(qword_1000DBA70, 502);
  CFTypeRef v1 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue(v0);
  sub_10002E554(v1, 0LL, 0LL);
  if (v1) {
    CFRelease(v1);
  }
  return 0LL;
}

id sub_10002EA1C()
{
  id v0 = sub_100054ED0(qword_1000DBA70, 502);
  uint64_t v1 = objc_claimAutoreleasedReturnValue(v0);
  int v2 = (void *)objc_claimAutoreleasedReturnValue(+[RDServer sharedServer](&OBJC_CLASS___RDServer, "sharedServer"));
  id v3 = [v2 LogoutToUser:v1];

  return v3;
}

id sub_10002EA74()
{
  id v0 = (void *)objc_claimAutoreleasedReturnValue(+[RDServer sharedServer](&OBJC_CLASS___RDServer, "sharedServer"));
  id v1 = [v0 inLoginSession];

  return v1;
}

void sub_10002EAB0(const __CFDictionary *a1, const __CFData *a2)
{
  int v4 = sub_100055178(qword_1000DBA70);
  int v5 = sub_100083C6C(a1, kUMUserSessionIDKey);
  unsigned int v6 = sub_100083DA4(a1, kUMUserSessionNeedsMountKey);
  uint64_t v7 = sub_100018E74(qword_1000DBD40);
  unsigned int v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  "com.apple.mobile.usermanagerd.foregrounduser_willchange"));
  [v8 post:v9];

  if (dword_1000DBCE8 == 1 && v4 != 502 && byte_1000DACB8 == 1)
  {
    unsigned int v10 = (const __CFDictionary *)sub_10001A594();
    if (v10) {
      sub_10002FA4C(v10);
    }
    if (!v6 || v5 == 502)
    {
LABEL_55:
      CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
      CFDateRef v29 = CFDateCreate(kCFAllocatorDefault, Current);
      if (!v29) {
        goto LABEL_65;
      }
      CFDateRef v30 = v29;
      if (CFDictionaryContainsKey(a1, kUMUserSessionFirstLoginStartTimeKey))
      {
        if (!CFDictionaryContainsKey(a1, kUMUserSessionFirstLoginEndTimeKey))
        {
          CFDictionarySetValue(a1, kUMUserSessionFirstLoginStartTimeKey, v30);
          goto LABEL_64;
        }

        CFDictionarySetValue(a1, kUMUserSessionCachedLoginStartTimeKey, v30);
        if (CFDictionaryContainsKey(a1, kUMUserSessionCachedLoginEndTimeKey))
        {
          uint64_t v31 = kUMUserSessionCachedLoginEndTimeKey;
LABEL_62:
          CFDictionaryRemoveValue(a1, v31);
        }
      }

      else
      {
        CFDictionarySetValue(a1, kUMUserSessionFirstLoginStartTimeKey, v30);
        if (CFDictionaryContainsKey(a1, kUMUserSessionFirstLoginEndTimeKey))
        {
          uint64_t v31 = kUMUserSessionFirstLoginEndTimeKey;
          goto LABEL_62;
        }
      }

LABEL_65:
  sub_10001AED4();
  if (a2)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v32 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v32, OS_LOG_TYPE_DEFAULT))
    {
      v92[0] = 0LL;
      LODWORD(v33) = sub_100053B4C(1);
      id v32 = v32;
      if (os_log_type_enabled((os_log_t)v32, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v33 = v33;
      }
      else {
        uint64_t v33 = v33 & 0xFFFFFFFE;
      }
      if ((_DWORD)v33)
      {
        CFIndex Length = CFDataGetLength(a2);
        LODWORD(cf) = 134217984;
        *(void *)((char *)&cf + 4) = Length;
        uint64_t v35 = _os_log_send_and_compose_impl( v33,  v92,  0LL,  0LL,  &_mh_execute_header,  v32,  0LL,  "USRSwitchNow with BLOB of size %ld",  &cf);
        goto LABEL_82;
      }

      goto LABEL_84;
    }
  }

  else
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v32 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v32, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)&__int128 cf = 0LL;
      unsigned int v36 = sub_100053B4C(1);
      id v32 = v32;
      if (os_log_type_enabled((os_log_t)v32, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v37 = v36;
      }
      else {
        uint64_t v37 = v36 & 0xFFFFFFFE;
      }
      if ((_DWORD)v37)
      {
        LOWORD(v92[0]) = 0;
        uint64_t v35 = _os_log_send_and_compose_impl( v37,  &cf,  0LL,  0LL,  &_mh_execute_header,  v32,  0LL,  "USRSwitchNow with NO BLOB");
LABEL_82:
        uint64_t v38 = (char *)v35;

        if (v38) {
          sub_100053B7C(v38);
        }
        goto LABEL_85;
      }

LABEL_84:
      uint64_t v38 = 0LL;
LABEL_85:
      free(v38);
    }
  }

  uint64_t v39 = qword_1000DBA70;
  int v40 = sub_100055178(qword_1000DBA70);
  char v41 = sub_100055894(v39, v40, v5);
  if (a2)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v42 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v42, OS_LOG_TYPE_DEFAULT))
    {
      v92[0] = 0LL;
      LODWORD(v43) = sub_100053B4C(1);
      __int16 v44 = (os_log_s *)v42;
      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v43 = v43;
      }
      else {
        uint64_t v43 = v43 & 0xFFFFFFFE;
      }
      if ((_DWORD)v43)
      {
        CFIndex v45 = CFDataGetLength(a2);
        LODWORD(cf) = 134217984;
        *(void *)((char *)&cf + 4) = v45;
        uint64_t v46 = (char *)_os_log_send_and_compose_impl( v43,  v92,  0LL,  0LL,  &_mh_execute_header,  v44,  0LL,  "SaveNextSession, BLOB with length %ld",  &cf);

        if (v46) {
          sub_100053B7C(v46);
        }
      }

      else
      {

        uint64_t v46 = 0LL;
      }

      free(v46);
    }

    if (sub_10002FCA4(a2, (uint64_t)"/private/var//keybags/nextsession_opaque.kb"))
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      id v47 = (id)qword_1000DBA98;
      if (os_log_type_enabled((os_log_t)v47, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)&__int128 cf = 0LL;
        unsigned int v48 = sub_100053B4C(1);
        int v49 = (os_log_s *)v47;
        if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v50 = v48;
        }
        else {
          uint64_t v50 = v48 & 0xFFFFFFFE;
        }
        if ((_DWORD)v50)
        {
          LOWORD(v92[0]) = 0;
          LODWORD(v90) = 2;
          uint64_t v51 = (char *)_os_log_send_and_compose_impl( v50,  &cf,  0LL,  0LL,  &_mh_execute_header,  v49,  0LL,  "Encrypted Opaquestuff for next boot",  v92,  v90);

          if (v51) {
            sub_100053B7C(v51);
          }
        }

        else
        {

          uint64_t v51 = 0LL;
        }

        free(v51);
      }
    }
  }

  if ((v41 & 1) != 0)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v52 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v52, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)&__int128 cf = 0LL;
      unsigned int v53 = sub_100053B4C(1);
      uint64_t v54 = (os_log_s *)v52;
      if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v55 = v53;
      }
      else {
        uint64_t v55 = v53 & 0xFFFFFFFE;
      }
      if ((_DWORD)v55)
      {
        LOWORD(v92[0]) = 0;
        LODWORD(v90) = 2;
        uint64_t v56 = (char *)_os_log_send_and_compose_impl( v55,  &cf,  0LL,  0LL,  &_mh_execute_header,  v54,  0LL,  "Saved nextuser session for reboot",  v92,  v90);

        if (v56) {
          sub_100053B7C(v56);
        }
      }

      else
      {

        uint64_t v56 = 0LL;
      }

      free(v56);
    }

    if ((_os_feature_enabled_impl("UserManagement", "USBSurvivesUserSwitch") & 1) == 0)
    {
      *(void *)&__int128 cf = 0LL;
      int v62 = IOUSBDeviceControllerCreate(0LL, &cf);
      if (!v62 && (void)cf) {
        int v62 = IOUSBDeviceControllerForceOffBus(cf, 1LL);
      }
      if (v62)
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        id v63 = (id)qword_1000DBA98;
        if (os_log_type_enabled((os_log_t)v63, OS_LOG_TYPE_DEFAULT))
        {
          v92[0] = 0LL;
          unsigned int v64 = sub_100053B4C(1);
          unsigned int v65 = (os_log_s *)v63;
          if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v66 = v64;
          }
          else {
            uint64_t v66 = v64 & 0xFFFFFFFE;
          }
          if ((_DWORD)v66)
          {
            v91[0] = 67109120;
            v91[1] = v62;
            unsigned int v67 = (char *)_os_log_send_and_compose_impl( v66,  v92,  0LL,  0LL,  &_mh_execute_header,  v65,  0LL,  "USB ForceOffBus failed: %d",  v91);

            if (v67) {
              sub_100053B7C(v67);
            }
          }

          else
          {

            unsigned int v67 = 0LL;
          }

          free(v67);
        }
      }

      if ((void)cf) {
        CFRelease((CFTypeRef)cf);
      }
    }

    if (qword_1000DBD30)
    {
      if (qword_1000DBAB0 != -1) {
        dispatch_once(&qword_1000DBAB0, &stru_1000CD548);
      }
      id v68 = (id)qword_1000DBAA8;
      if (os_log_type_enabled((os_log_t)v68, OS_LOG_TYPE_DEFAULT))
      {
        v92[0] = 0LL;
        unsigned int v69 = sub_100053B4C(0);
        id v70 = (os_log_s *)v68;
        if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v71 = v69;
        }
        else {
          uint64_t v71 = v69 & 0xFFFFFFFE;
        }
        if ((_DWORD)v71)
        {
          LODWORD(cf) = 134217984;
          *(void *)((char *)&cf + 4) = qword_1000DBD30;
          uint64_t v72 = (char *)_os_log_send_and_compose_impl( v71,  v92,  0LL,  0LL,  &_mh_execute_header,  v70,  0LL,  "Canceling sync bubble timer (%p)",  &cf);

          if (v72) {
            sub_100053B7C(v72);
          }
        }

        else
        {

          uint64_t v72 = 0LL;
        }

        free(v72);
      }

      dispatch_source_cancel((dispatch_source_t)qword_1000DBD30);
      unsigned int v73 = (void *)qword_1000DBD30;
      qword_1000DBD30 = 0LL;
    }

    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v74 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v74, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)&__int128 cf = 0LL;
      unsigned int v75 = sub_100053B4C(1);
      unsigned int v76 = (os_log_s *)v74;
      if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v77 = v75;
      }
      else {
        uint64_t v77 = v75 & 0xFFFFFFFE;
      }
      if ((_DWORD)v77)
      {
        LOWORD(v92[0]) = 0;
        LODWORD(v90) = 2;
        uint64_t v78 = (char *)_os_log_send_and_compose_impl( v77,  &cf,  0LL,  0LL,  &_mh_execute_header,  v76,  0LL,  "Starting USER SWITCH",  v92,  v90);

        if (v78) {
          sub_100053B7C(v78);
        }
      }

      else
      {

        uint64_t v78 = 0LL;
      }

      free(v78);
    }

    uint64_t v79 = sub_100018E80(qword_1000DBD40);
    id v80 = (void *)objc_claimAutoreleasedReturnValue(v79);
    char v81 = sub_100019ADC((uint64_t)v80);
    int v82 = dword_1000DBCE8;

    if ((v81 & 1) != 0 || v82 == 2)
    {
      if (!xpc_user_sessions_enabled() || xpc_user_sessions_get_session_uid())
      {
        sub_100019F7C("UserManagement user switch failed: usermanagerd is not running in the system session");
      }

      else if (byte_1000DBA80 != 1)
      {
        byte_1000DBA80 = 1;
        *(void *)&__int128 cf = _NSConcreteStackBlock;
        *((void *)&cf + 1) = 3221225472LL;
        uint64_t v94 = sub_10004CDF8;
        uint64_t v95 = &unk_1000CCDB8;
        int v96 = v4;
        int v97 = v5;
        dispatch_async((dispatch_queue_t)qword_1000DBD58, &cf);
        return;
      }

      id v89 = (const __CFDictionary *)sub_100019F7C( "UserManagement user switch failed: attempt to perform a user switch while already performing a user switch");
      sub_10002FA4C(v89);
    }

    else
    {
      int v83 = reboot3(0x2100000000000000LL);
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      id v84 = (id)qword_1000DBA98;
      if (os_log_type_enabled((os_log_t)v84, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)&__int128 cf = 0LL;
        unsigned int v85 = sub_100053B4C(1);
        unsigned int v86 = (os_log_s *)v84;
        if (os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v87 = v85;
        }
        else {
          uint64_t v87 = v85 & 0xFFFFFFFE;
        }
        if ((_DWORD)v87)
        {
          LODWORD(v92[0]) = 67109120;
          HIDWORD(v92[0]) = v83;
          uint64_t v88 = (char *)_os_log_send_and_compose_impl( v87,  &cf,  0LL,  0LL,  &_mh_execute_header,  v86,  0LL,  "reboot3 returned %d",  v92);

          if (v88) {
            sub_100053B7C(v88);
          }
        }

        else
        {

          uint64_t v88 = 0LL;
        }

        free(v88);
      }
    }
  }

  else
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    vm_size_t v57 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)&__int128 cf = 0LL;
      unsigned int v58 = sub_100053B4C(1);
      if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v59 = v58;
      }
      else {
        uint64_t v59 = v58 & 0xFFFFFFFE;
      }
      if ((_DWORD)v59)
      {
        LOWORD(v92[0]) = 0;
        LODWORD(v90) = 2;
        uint64_t v60 = (const char *)_os_log_send_and_compose_impl( v59,  &cf,  0LL,  0LL,  &_mh_execute_header,  v57,  0LL,  "Save next switch session failed",  v92,  v90);
        unsigned int v61 = (char *)v60;
        if (v60) {
          sub_100053B7C(v60);
        }
      }

      else
      {
        unsigned int v61 = 0LL;
      }

      free(v61);
    }
  }

void sub_10002FA4C(const __CFDictionary *a1)
{
  uint64_t v18 = 0LL;
  uint64_t valuePtr = 0LL;
  uint64_t v17 = 0LL;
  int v2 = sub_100083C6C(a1, kUMUserSessionIDKey);
  sub_100083E34(a1, kUMUserSessionHomeDirKey, v21, 1024);
  if (statfs(v21, &v22))
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v3 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = 0LL;
      unsigned int v4 = sub_100053B4C(1);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v5 = v4;
      }
      else {
        uint64_t v5 = v4 & 0xFFFFFFFE;
      }
      if ((_DWORD)v5)
      {
        v20[0] = 67109120;
        v20[1] = v2;
        unsigned int v6 = (const char *)_os_log_send_and_compose_impl( v5,  &v16,  0LL,  0LL,  &_mh_execute_header,  v3,  0LL,  "STATFS failed for session %d",  v20);
        uint64_t v7 = (char *)v6;
        if (v6) {
          sub_100053B7C(v6);
        }
      }

      else
      {
        uint64_t v7 = 0LL;
      }

      free(v7);
    }
  }

  else
  {
    uint64_t v8 = v22.f_blocks * v22.f_bsize;
    uint64_t v9 = v22.f_bfree * v22.f_bsize;
    uint64_t v18 = v8;
    uint64_t valuePtr = v8;
    if (v8 <= v9) {
      uint64_t v9 = 0LL;
    }
    uint64_t v17 = v8 - v9;
  }

  CFNumberRef v10 = CFNumberCreate(0LL, kCFNumberLongLongType, &valuePtr);
  if (v10)
  {
    CFNumberRef v11 = v10;
    CFDictionarySetValue(a1, kUMUserSessionQuotaLimitKey, v10);
    CFRelease(v11);
  }

  CFNumberRef v12 = CFNumberCreate(0LL, kCFNumberLongLongType, &v18);
  if (v12)
  {
    CFNumberRef v13 = v12;
    CFDictionarySetValue(a1, kUMUserSessionQuotaSoftLimitKey, v12);
    CFRelease(v13);
  }

  CFNumberRef v14 = CFNumberCreate(0LL, kCFNumberLongLongType, &v17);
  if (v14)
  {
    CFNumberRef v15 = v14;
    CFDictionarySetValue(a1, kUMUserSessionQuotaUsedKey, v14);
    CFRelease(v15);
  }

uint64_t sub_10002FCA4(const __CFData *a1, uint64_t a2)
{
  if (!a1) {
    return 0LL;
  }
  int Length = CFDataGetLength(a1);
  int valuePtr = Length;
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v5 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v34 = 0LL;
    unsigned int v6 = sub_100053B4C(1);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v7 = v6;
    }
    else {
      uint64_t v7 = v6 & 0xFFFFFFFE;
    }
    if ((_DWORD)v7)
    {
      v36[0] = 67109120;
      v36[1] = Length;
      uint64_t v8 = (const char *)_os_log_send_and_compose_impl( v7,  &v34,  0LL,  0LL,  &_mh_execute_header,  v5,  0LL,  "AKS wrapping Opaquedata of length %d",  v36);
      uint64_t v9 = (char *)v8;
      if (v8) {
        sub_100053B7C(v8);
      }
    }

    else
    {
      uint64_t v9 = 0LL;
    }

    free(v9);
  }

  CFNumberRef v11 = sub_10008428C();
  CFNumberRef v12 = CFNumberCreate(0LL, kCFNumberIntType, &valuePtr);
  CFDictionaryAddValue(v11, @"BLOBLEN", v12);
  CFRelease(v12);
  CFDictionaryAddValue(v11, @"BLOB", a1);
  CFTypeRef v13 = sub_100083ECC(v11);
  if (v13)
  {
    CFNumberRef v14 = v13;
    uint64_t v15 = sub_100019434(qword_1000DBD40);
    uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(v15);
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a2));
    unsigned int v18 = [v16 atomicallyWriteData:v14 toPath:v17 error:0];

    if (v18)
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v19 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v34 = 0LL;
        unsigned int v20 = sub_100053B4C(1);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v21 = v20;
        }
        else {
          uint64_t v21 = v20 & 0xFFFFFFFE;
        }
        if ((_DWORD)v21)
        {
          LOWORD(v36[0]) = 0;
          statfs v22 = (const char *)_os_log_send_and_compose_impl( v21,  &v34,  0LL,  0LL,  &_mh_execute_header,  v19,  0LL,  "enCryptOpaqueStuff(BLOB) Success",  v36,  2);
          uint64_t v23 = (char *)v22;
          if (v22) {
            sub_100053B7C(v22);
          }
        }

        else
        {
          uint64_t v23 = 0LL;
        }

        free(v23);
      }

      uint64_t v10 = 1LL;
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v19 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v34 = 0LL;
        unsigned int v29 = sub_100053B4C(1);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v30 = v29;
        }
        else {
          uint64_t v30 = v29 & 0xFFFFFFFE;
        }
        if ((_DWORD)v30)
        {
          LOWORD(v36[0]) = 0;
          uint64_t v31 = (const char *)_os_log_send_and_compose_impl( v30,  &v34,  0LL,  0LL,  &_mh_execute_header,  v19,  0LL,  "failed to write nextsession_opaque.kb (BLOB) ",  v36,  2);
          id v32 = (char *)v31;
          if (v31) {
            sub_100053B7C(v31);
          }
        }

        else
        {
          id v32 = 0LL;
        }

        free(v32);
      }

      uint64_t v10 = 0LL;
    }

    CFRelease(v14);
  }

  else
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v24 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v34 = 0LL;
      unsigned int v25 = sub_100053B4C(1);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v26 = v25;
      }
      else {
        uint64_t v26 = v25 & 0xFFFFFFFE;
      }
      if ((_DWORD)v26)
      {
        LOWORD(v36[0]) = 0;
        uint64_t v27 = (const char *)_os_log_send_and_compose_impl( v26,  &v34,  0LL,  0LL,  &_mh_execute_header,  v24,  0LL,  "Can't serialize dictionary",  v36,  2);
        unsigned __int8 v28 = (char *)v27;
        if (v27) {
          sub_100053B7C(v27);
        }
      }

      else
      {
        unsigned __int8 v28 = 0LL;
      }

      free(v28);
    }

    uint64_t v10 = 0LL;
  }

  CFRelease(v11);
  return v10;
}

CFDictionaryRef sub_100030128(const __CFDictionary *a1)
{
  id v1 = (const __CFDictionary *)sub_100021AC4(a1);
  int v2 = v1;
  if (v1)
  {
    if (sub_100083C6C(v1, kUMUserSessionIDKey) != 502)
    {
      uint64_t v34 = 0LL;
      uint64_t valuePtr = 0LL;
      uint64_t v33 = 0LL;
      int v3 = sub_100083C6C(v2, kUMUserSessionIDKey);
      sub_100083E34(v2, kUMUserSessionHomeDirKey, v39, 1024);
      if (byte_1000DACB8)
      {
      }

      else
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        uint64_t v10 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          v32[0] = 0LL;
          unsigned int v11 = sub_100053B4C(1);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v12 = v11;
          }
          else {
            uint64_t v12 = v11 & 0xFFFFFFFE;
          }
          if ((_DWORD)v12)
          {
            LODWORD(v3_Block_object_dispose(va, 8) = 67109120;
            HIDWORD(v3_Block_object_dispose(va, 8) = v3;
            CFTypeRef v13 = (const char *)_os_log_send_and_compose_impl( v12,  v32,  0LL,  0LL,  &_mh_execute_header,  v10,  0LL,  "Calling APFSIOC_GET_DIR_STATS for uid:%d",  &v38);
            CFNumberRef v14 = (char *)v13;
            if (v13) {
              sub_100053B7C(v13);
            }
          }

          else
          {
            CFNumberRef v14 = 0LL;
          }

          free(v14);
        }

        if (fsctl(v39, 0x40184A03uLL, v32, 0))
        {
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          uint64_t v16 = (os_log_s *)(id)qword_1000DBA98;
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v38 = 0LL;
            unsigned int v17 = sub_100053B4C(1);
            if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v18 = v17;
            }
            else {
              uint64_t v18 = v17 & 0xFFFFFFFE;
            }
            if ((_DWORD)v18)
            {
              int v36 = 67109120;
              int v37 = v3;
              uint64_t v19 = (const char *)_os_log_send_and_compose_impl( v18,  &v38,  0LL,  0LL,  &_mh_execute_header,  v16,  0LL,  "APFSIOC_GET_DIR_STATS failed or uid:%d",  &v36);
              unsigned int v20 = (char *)v19;
              if (v19) {
                sub_100053B7C(v19);
              }
            }

            else
            {
              unsigned int v20 = 0LL;
            }

            free(v20);
          }
        }

        else
        {
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          uint64_t v21 = (os_log_s *)(id)qword_1000DBA98;
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v38 = 0LL;
            unsigned int v22 = sub_100053B4C(1);
            if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v23 = v22;
            }
            else {
              uint64_t v23 = v22 & 0xFFFFFFFE;
            }
            if ((_DWORD)v23)
            {
              int v36 = 67109120;
              int v37 = v3;
              uint64_t v24 = (const char *)_os_log_send_and_compose_impl( v23,  &v38,  0LL,  0LL,  &_mh_execute_header,  v21,  0LL,  "APFSIOC_GET_DIR_STATS SUCCESS for uid:%d",  &v36);
              unsigned int v25 = (char *)v24;
              if (v24) {
                sub_100053B7C(v24);
              }
            }

            else
            {
              unsigned int v25 = 0LL;
            }

            free(v25);
          }

          uint64_t v34 = 0LL;
          uint64_t valuePtr = 0LL;
          uint64_t v33 = v32[1];
        }

        CFNumberRef v26 = CFNumberCreate(0LL, kCFNumberLongLongType, &valuePtr);
        if (v26)
        {
          CFNumberRef v27 = v26;
          CFDictionarySetValue(v2, kUMUserSessionQuotaLimitKey, v26);
          CFRelease(v27);
        }

        CFNumberRef v28 = CFNumberCreate(0LL, kCFNumberLongLongType, &v34);
        if (v28)
        {
          CFNumberRef v29 = v28;
          CFDictionarySetValue(v2, kUMUserSessionQuotaSoftLimitKey, v28);
          CFRelease(v29);
        }

        CFNumberRef v30 = CFNumberCreate(0LL, kCFNumberLongLongType, &v33);
        if (v30)
        {
          CFNumberRef v31 = v30;
          CFDictionarySetValue(v2, kUMUserSessionQuotaUsedKey, v30);
          CFRelease(v31);
        }
      }
    }
  }

  else
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v5 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)uint64_t v39 = 0LL;
      unsigned int v6 = sub_100053B4C(1);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v7 = v6;
      }
      else {
        uint64_t v7 = v6 & 0xFFFFFFFE;
      }
      if ((_DWORD)v7)
      {
        LOWORD(v32[0]) = 0;
        uint64_t v8 = (const char *)_os_log_send_and_compose_impl( v7,  v39,  0LL,  0LL,  &_mh_execute_header,  v5,  0LL,  "getUserSessionAttributes: could not find the requested session",  v32,  2);
        uint64_t v9 = (char *)v8;
        if (v8) {
          sub_100053B7C(v8);
        }
      }

      else
      {
        uint64_t v9 = 0LL;
      }

      free(v9);
    }
  }

  return v2;
}

const void *sub_100030648(const __CFDictionary *a1, _DWORD *a2)
{
  int v3 = (const __CFDictionary *)sub_100021AC4(a1);
  if (!v3)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v10 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)uint64_t v19 = 0LL;
      unsigned int v11 = sub_100053B4C(1);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v12 = v11;
      }
      else {
        uint64_t v12 = v11 & 0xFFFFFFFE;
      }
      if ((_DWORD)v12)
      {
        LOWORD(v18[0]) = 0;
        CFTypeRef v13 = (const char *)_os_log_send_and_compose_impl( v12,  v19,  0LL,  0LL,  &_mh_execute_header,  v10,  0LL,  "getUserSessionKeybagData: could not find the requested session",  v18,  2);
        CFNumberRef v14 = (char *)v13;
        if (v13) {
          sub_100053B7C(v13);
        }
      }

      else
      {
        CFNumberRef v14 = 0LL;
      }

      free(v14);
    }

    if (a2)
    {
      uint64_t v16 = 0LL;
      *a2 = 2;
      return v16;
    }

    return 0LL;
  }

  unsigned int v4 = v3;
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v5 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v18[0] = 0LL;
    unsigned int v6 = sub_100053B4C(1);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v7 = v6;
    }
    else {
      uint64_t v7 = v6 & 0xFFFFFFFE;
    }
    if ((_DWORD)v7)
    {
      *(_DWORD *)uint64_t v19 = 138412290;
      *(void *)&v19[4] = v4;
      uint64_t v8 = (const char *)_os_log_send_and_compose_impl( v7,  v18,  0LL,  0LL,  &_mh_execute_header,  v5,  0LL,  "getUserSessionKeybagData: found session %@",  v19,  12);
      uint64_t v9 = (char *)v8;
      if (v8) {
        sub_100053B7C(v8);
      }
    }

    else
    {
      uint64_t v9 = 0LL;
    }

    free(v9);
  }

  if (!CFDictionaryContainsKey(v4, kUMUserSessionKeybagOpaqueDataKey)) {
    return 0LL;
  }
  Value = CFDictionaryGetValue(v4, kUMUserSessionKeybagOpaqueDataKey);
  uint64_t v16 = Value;
  if (Value) {
    CFRetain(Value);
  }
  return v16;
}

uint64_t sub_1000308A4(const __CFDictionary *a1, const void *a2, _DWORD *a3)
{
  uint64_t v5 = (const __CFDictionary *)sub_100021AC4(a1);
  if (v5)
  {
    unsigned int v6 = v5;
    int v7 = sub_100083C6C(v5, kUMUserSessionIDKey);
    if (a2)
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v8 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v34 = 0LL;
        unsigned int v9 = sub_100053B4C(1);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v10 = v9;
        }
        else {
          uint64_t v10 = v9 & 0xFFFFFFFE;
        }
        if ((_DWORD)v10)
        {
          int v35 = 67109120;
          int v36 = v7;
          unsigned int v11 = (const char *)_os_log_send_and_compose_impl( v10,  &v34,  0LL,  0LL,  &_mh_execute_header,  v8,  0LL,  "setUserSessionKeybagData for user %d",  &v35);
          uint64_t v12 = (char *)v11;
          if (v11) {
            sub_100053B7C(v11);
          }
        }

        else
        {
          uint64_t v12 = 0LL;
        }

        free(v12);
      }

      CFDictionarySetValue(v6, kUMUserSessionKeybagOpaqueDataKey, a2);
LABEL_50:
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      CFNumberRef v28 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v34 = 0LL;
        unsigned int v29 = sub_100053B4C(1);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v30 = v29;
        }
        else {
          uint64_t v30 = v29 & 0xFFFFFFFE;
        }
        if ((_DWORD)v30)
        {
          int v35 = 67109120;
          int v36 = v7;
          CFNumberRef v31 = (const char *)_os_log_send_and_compose_impl( v30,  &v34,  0LL,  0LL,  &_mh_execute_header,  v28,  0LL,  "Saved keybag Data for the user:%d, saving session",  &v35);
          id v32 = (char *)v31;
          if (v31) {
            sub_100053B7C(v31);
          }
        }

        else
        {
          id v32 = 0LL;
        }

        free(v32);
      }

      sub_10001AED4();
      return 1LL;
    }

    if (CFDictionaryContainsKey(v6, kUMUserSessionKeybagOpaqueDataKey))
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v18 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v34 = 0LL;
        unsigned int v19 = sub_100053B4C(1);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v20 = v19;
        }
        else {
          uint64_t v20 = v19 & 0xFFFFFFFE;
        }
        if ((_DWORD)v20)
        {
          int v35 = 67109120;
          int v36 = v7;
          uint64_t v21 = (const char *)_os_log_send_and_compose_impl( v20,  &v34,  0LL,  0LL,  &_mh_execute_header,  v18,  0LL,  "clearing KeybagData for user %d",  &v35);
          unsigned int v22 = (char *)v21;
          if (v21) {
            sub_100053B7C(v21);
          }
        }

        else
        {
          unsigned int v22 = 0LL;
        }

        free(v22);
      }

      CFDictionaryRemoveValue(v6, kUMUserSessionKeybagOpaqueDataKey);
      goto LABEL_50;
    }

    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v23 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v34 = 0LL;
      unsigned int v24 = sub_100053B4C(1);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v25 = v24;
      }
      else {
        uint64_t v25 = v24 & 0xFFFFFFFE;
      }
      if ((_DWORD)v25)
      {
        int v35 = 67109120;
        int v36 = v7;
        CFNumberRef v26 = (const char *)_os_log_send_and_compose_impl( v25,  &v34,  0LL,  0LL,  &_mh_execute_header,  v23,  0LL,  "No KeybagData to clear for user %d",  &v35);
        CFNumberRef v27 = (char *)v26;
        if (v26) {
          sub_100053B7C(v26);
        }
      }

      else
      {
        CFNumberRef v27 = 0LL;
      }

      free(v27);
    }
  }

  else
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    CFTypeRef v13 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v34 = 0LL;
      unsigned int v14 = sub_100053B4C(1);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v15 = v14;
      }
      else {
        uint64_t v15 = v14 & 0xFFFFFFFE;
      }
      if ((_DWORD)v15)
      {
        LOWORD(v35) = 0;
        uint64_t v16 = (const char *)_os_log_send_and_compose_impl( v15,  &v34,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "setUserSessionKeybagData: could not find the requested session",  &v35,  2);
        unsigned int v17 = (char *)v16;
        if (v16) {
          sub_100053B7C(v16);
        }
      }

      else
      {
        unsigned int v17 = 0LL;
      }

      free(v17);
    }

    if (a3) {
      *a3 = 2;
    }
  }

  return 1LL;
}

CFArrayRef sub_100030DA8(int a1)
{
  id v1 = sub_100054ED0(qword_1000DBA70, a1);
  int v2 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue(v1);
  if (!v2) {
    return 0LL;
  }
  int v3 = v2;
  if (CFDictionaryContainsKey(v2, kUMUserSessionSyncMachServicesKey)
    && (v4 = CFDictionaryGetValue(v3, kUMUserSessionSyncMachServicesKey), CFTypeID v5 = CFGetTypeID(v4), v5 == CFArrayGetTypeID()))
  {
    Value = (const __CFArray *)CFDictionaryGetValue(v3, kUMUserSessionSyncMachServicesKey);
    CFArrayRef Copy = CFArrayCreateCopy(kCFAllocatorDefault, Value);
  }

  else
  {
    CFArrayRef Copy = 0LL;
  }

  CFRelease(v3);
  return Copy;
}

__CFDictionary *sub_100030E5C(const __CFDictionary *a1)
{
  v27[0] = kUMUserSessionNameKey;
  v27[1] = CFStringGetTypeID();
  _DWORD v27[2] = kUMUserSessionFirstNameKey;
  v27[3] = CFStringGetTypeID();
  v27[4] = kUMUserSessionLastNameKey;
  v27[5] = CFStringGetTypeID();
  v27[6] = kUMUserSessionDisplayNameKey;
  v27[7] = CFStringGetTypeID();
  v27[8] = kUMUserSessionOpaqueDataKey;
  v27[9] = CFDataGetTypeID();
  v27[10] = kUMUserSessionFileInfoKey;
  v27[11] = CFStringGetTypeID();
  v27[12] = kUMUserSessionAuditorKey;
  v27[13] = CFBooleanGetTypeID();
  v27[14] = kUMUserSessionisTransientKey;
  v27[15] = CFBooleanGetTypeID();
  v27[16] = kUMUserSessionCloudLoginTimeStampKey;
  v27[17] = CFDateGetTypeID();
  v27[18] = kUMUserSessionDisabledKey;
  v27[19] = CFBooleanGetTypeID();
  v27[20] = kUMUserSessionLanguageKey;
  v27[21] = CFStringGetTypeID();
  int v2 = (__CFDictionary *)sub_100021AC4(a1);
  if (v2)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    int v3 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v23[0] = 0LL;
      unsigned int v4 = sub_100053B4C(1);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v5 = v4;
      }
      else {
        uint64_t v5 = v4 & 0xFFFFFFFE;
      }
      if ((_DWORD)v5)
      {
        *(_DWORD *)unsigned int v24 = 138412290;
        *(void *)&v24[4] = v2;
        unsigned int v6 = (const char *)_os_log_send_and_compose_impl( v5,  v23,  0LL,  0LL,  &_mh_execute_header,  v3,  0LL,  "setUserSessionAttributes: found session %@",  v24,  12);
        int v7 = (char *)v6;
        if (v6) {
          sub_100053B7C(v6);
        }
      }

      else
      {
        int v7 = 0LL;
      }

      free(v7);
    }

    for (uint64_t i = 0LL; i != 22; i += 2LL)
      sub_10002789C(v2, a1, (void *)v27[i], v27[i + 1]);
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v14 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      v23[0] = 0LL;
      unsigned int v15 = sub_100053B4C(1);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v16 = v15;
      }
      else {
        uint64_t v16 = v15 & 0xFFFFFFFE;
      }
      if ((_DWORD)v16)
      {
        *(_DWORD *)unsigned int v24 = 136315394;
        *(void *)&v24[4] = "setUserSessionAttributes";
        __int16 v25 = 2080;
        uint64_t v26 = kMobileKeyBagUserChangedNotificationToken;
        LODWORD(v22) = 22;
        unsigned int v17 = (const char *)_os_log_send_and_compose_impl( v16,  v23,  0LL,  0LL,  &_mh_execute_header,  v14,  0LL,  "usermanagerd %s posting notification: %s\n",  v24,  v22);
        uint64_t v18 = (char *)v17;
        if (v17) {
          sub_100053B7C(v17);
        }
      }

      else
      {
        uint64_t v18 = 0LL;
      }

      free(v18);
    }

    uint64_t v19 = sub_100018E74(qword_1000DBD40);
    id v8 = (id)objc_claimAutoreleasedReturnValue(v19);
    uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  kMobileKeyBagUserChangedNotificationToken));
    [v8 post:v20];
  }

  else
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v8 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v8, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)unsigned int v24 = 0LL;
      unsigned int v9 = sub_100053B4C(1);
      if (os_log_type_enabled((os_log_t)v8, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = v9 & 0xFFFFFFFE;
      }
      if ((_DWORD)v10)
      {
        LOWORD(v23[0]) = 0;
        unsigned int v11 = (const char *)_os_log_send_and_compose_impl( v10,  v24,  0LL,  0LL,  &_mh_execute_header,  v8,  0LL,  "setUserSessionAttributes: could not find the requested session",  v23,  2);
        uint64_t v12 = (char *)v11;
        if (v11) {
          sub_100053B7C(v11);
        }
      }

      else
      {
        uint64_t v12 = 0LL;
      }

      free(v12);
    }
  }

  return v2;
}

const void *sub_1000312B8(const char *a1)
{
  id v1 = (const __CFDictionary *)sub_100084160(a1);
  if (!v1) {
    return 0LL;
  }
  int v2 = v1;
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  int v3 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v22 = 0LL;
    unsigned int v4 = sub_100053B4C(1);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = v4 & 0xFFFFFFFE;
    }
    if ((_DWORD)v5)
    {
      LOWORD(v23[0]) = 0;
      unsigned int v6 = (const char *)_os_log_send_and_compose_impl( v5,  &v22,  0LL,  0LL,  &_mh_execute_header,  v3,  0LL,  "RETRIEVING BLOB",  v23,  2);
      int v7 = (char *)v6;
      if (v6) {
        sub_100053B7C(v6);
      }
    }

    else
    {
      int v7 = 0LL;
    }

    free(v7);
  }

  id v8 = sub_100083BFC(v2, @"BLOB");
  int v9 = sub_100083C6C(v2, @"BLOBLEN");
  if (v8)
  {
    int v10 = v9;
    CFRetain(v8);
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v11 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v22 = 0LL;
      unsigned int v12 = sub_100053B4C(1);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v13 = v12;
      }
      else {
        uint64_t v13 = v12 & 0xFFFFFFFE;
      }
      if ((_DWORD)v13)
      {
        v23[0] = 67109120;
        v23[1] = v10;
        unsigned int v14 = (const char *)_os_log_send_and_compose_impl( v13,  &v22,  0LL,  0LL,  &_mh_execute_header,  v11,  0LL,  "OPAQUE BLOB LEN = %d",  v23);
        unsigned int v15 = (char *)v14;
        if (v14) {
          sub_100053B7C(v14);
        }
      }

      else
      {
        unsigned int v15 = 0LL;
      }

      free(v15);
    }
  }

  else
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v11 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v22 = 0LL;
      unsigned int v16 = sub_100053B4C(1);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v17 = v16;
      }
      else {
        uint64_t v17 = v16 & 0xFFFFFFFE;
      }
      if ((_DWORD)v17)
      {
        LOWORD(v23[0]) = 0;
        LODWORD(v21) = 2;
        uint64_t v18 = (const char *)_os_log_send_and_compose_impl( v17,  &v22,  0LL,  0LL,  &_mh_execute_header,  v11,  0LL,  "failed to RETRIEVE BLOB out of read nextsession_opaque.kb",  v23,  v21);
        uint64_t v19 = (char *)v18;
        if (v18) {
          sub_100053B7C(v18);
        }
      }

      else
      {
        uint64_t v19 = 0LL;
      }

      free(v19);
    }

    id v8 = 0LL;
  }

  CFRelease(v2);
  return v8;
}

uint64_t sub_1000315D8(int a1)
{
  uint64_t v5 = 0LL;
  unsigned int v6 = &v5;
  uint64_t v7 = 0x2020000000LL;
  int v8 = -1;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  v3[2] = sub_100031678;
  v3[3] = &unk_1000CD458;
  int v4 = a1;
  void v3[4] = &v5;
  dispatch_sync((dispatch_queue_t)qword_1000DBD48, v3);
  uint64_t v1 = *((unsigned int *)v6 + 6);
  _Block_object_dispose(&v5, 8);
  return v1;
}

void sub_100031678(uint64_t a1)
{
  if (dword_1000DACB4 == -1)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    int v8 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_54;
    }
    uint64_t v29 = 0LL;
    unsigned int v9 = sub_100053B4C(1);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = v9 & 0xFFFFFFFE;
    }
    if ((_DWORD)v10)
    {
      LOWORD(v32) = 0;
      unsigned int v11 = (const char *)_os_log_send_and_compose_impl( v10,  &v29,  0LL,  0LL,  &_mh_execute_header,  v8,  0LL,  "In UserQuota size mode, returning error to limit users",  &v32,  2);
      goto LABEL_50;
    }

uint64_t sub_100031B40()
{
  return MGGetBoolAnswer(@"InternalBuild");
}

uint64_t sub_100031B4C(uint64_t a1)
{
  id v2 = sub_100054ED0(qword_1000DBA70, a1);
  uint64_t v3 = objc_claimAutoreleasedReturnValue(v2);
  if (v3)
  {
    uint64_t v4 = (const __CFDictionary *)v3;
    bzero(&v136, 0x400uLL);
    sub_100083E34(v4, kUMUserSessionHomeDirKey, (char *)&v136, 1024);
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v5 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v5, OS_LOG_TYPE_DEFAULT))
    {
      v135[0] = 0LL;
      unsigned int v6 = sub_100053B4C(1);
      uint64_t v7 = (os_log_s *)v5;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v8 = v6;
      }
      else {
        uint64_t v8 = v6 & 0xFFFFFFFE;
      }
      if ((_DWORD)v8)
      {
        *(_DWORD *)unsigned int v134 = 67109378;
        *(_DWORD *)&v134[4] = a1;
        *(_WORD *)&v134[8] = 2080;
        *(void *)&v134[10] = &v136;
        LODWORD(v130) = 18;
        unsigned int v9 = (char *)_os_log_send_and_compose_impl( v8,  v135,  0LL,  0LL,  &_mh_execute_header,  v7,  0LL,  "Adding Sandbox-kext path upload for bubble with uid %d, path:%s",  v134,  v130);

        if (v9) {
          sub_100053B7C(v9);
        }
      }

      else
      {

        unsigned int v9 = 0LL;
      }

      free(v9);
    }

    if (sub_10003323C(a1, (const char *)&v136, 0))
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      id v15 = (id)qword_1000DBA98;
      if (os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)unsigned int v134 = 0LL;
        unsigned int v16 = sub_100053B4C(1);
        id v15 = v15;
        if (os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v17 = v16;
        }
        else {
          uint64_t v17 = v16 & 0xFFFFFFFE;
        }
        if ((_DWORD)v17)
        {
          LODWORD(v135[0]) = 67109120;
          HIDWORD(v135[0]) = a1;
          uint64_t v18 = _os_log_send_and_compose_impl( v17,  v134,  0LL,  0LL,  &_mh_execute_header,  v15,  0LL,  "Set homepath to Sandbox for uid:%d",  v135);
          goto LABEL_39;
        }

        goto LABEL_41;
      }
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      id v15 = (id)qword_1000DBA98;
      if (os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)unsigned int v134 = 0LL;
        unsigned int v19 = sub_100053B4C(1);
        id v15 = v15;
        if (os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v20 = v19;
        }
        else {
          uint64_t v20 = v19 & 0xFFFFFFFE;
        }
        if ((_DWORD)v20)
        {
          LODWORD(v135[0]) = 67109120;
          HIDWORD(v135[0]) = a1;
          uint64_t v18 = _os_log_send_and_compose_impl( v20,  v134,  0LL,  0LL,  &_mh_execute_header,  v15,  0LL,  "Failed to add homepath to Sandbox for uid:%d",  v135);
LABEL_39:
          uint64_t v21 = (char *)v18;

          if (v21) {
            sub_100053B7C(v21);
          }
          goto LABEL_42;
        }

LABEL_41:
        uint64_t v21 = 0LL;
LABEL_42:
        free(v21);
      }
    }

    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v22 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v22, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)unsigned int v134 = 0LL;
      unsigned int v23 = sub_100053B4C(1);
      unsigned int v24 = (os_log_s *)v22;
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v25 = v23;
      }
      else {
        uint64_t v25 = v23 & 0xFFFFFFFE;
      }
      if ((_DWORD)v25)
      {
        LODWORD(v135[0]) = 67109120;
        HIDWORD(v135[0]) = a1;
        uint64_t v26 = (char *)_os_log_send_and_compose_impl( v25,  v134,  0LL,  0LL,  &_mh_execute_header,  v24,  0LL,  "Sandbox home directory is set for uid:%d",  v135);

        if (v26) {
          sub_100053B7C(v26);
        }
      }

      else
      {

        uint64_t v26 = 0LL;
      }

      free(v26);
    }

    int v27 = CFDictionaryContainsKey(v4, kUMUserSessionVolumeDeviceNodeKey);
    p_name = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
    if (!v27)
    {
      BOOL v131 = 0;
      id v10 = 0LL;
      uint64_t v34 = 0LL;
      goto LABEL_66;
    }

    if (![(id)qword_1000DBA68 mountVolumeWithSession:v4 mountPath:0 error:0 forPersona:0])
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v43 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)unsigned int v134 = 0LL;
        unsigned int v44 = sub_100053B4C(1);
        if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v45 = v44;
        }
        else {
          uint64_t v45 = v44 & 0xFFFFFFFE;
        }
        if ((_DWORD)v45)
        {
          LOWORD(v135[0]) = 0;
          LODWORD(v130) = 2;
          uint64_t v46 = (const char *)_os_log_send_and_compose_impl( v45,  v134,  0LL,  0LL,  &_mh_execute_header,  v43,  0LL,  "APFSUser Volume failed to mount for sync bubble, bailing on starting the bubble",  v135,  v130);
          id v47 = (char *)v46;
          if (v46) {
            sub_100053B7C(v46);
          }
        }

        else
        {
          id v47 = 0LL;
        }

        free(v47);
      }

      id v10 = 0LL;
      uint64_t v37 = 0xFFFFFFFFLL;
      goto LABEL_239;
    }

    BOOL v131 = v27 != 0;
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v29 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v29, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)unsigned int v134 = 0LL;
      unsigned int v30 = sub_100053B4C(1);
      int v31 = (os_log_s *)v29;
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v32 = v30;
      }
      else {
        uint64_t v32 = v30 & 0xFFFFFFFE;
      }
      if ((_DWORD)v32)
      {
        LOWORD(v135[0]) = 0;
        LODWORD(v130) = 2;
        uint64_t v33 = (char *)_os_log_send_and_compose_impl( v32,  v134,  0LL,  0LL,  &_mh_execute_header,  v31,  0LL,  "APFSUser Volume mounted at home directory for Sync bubble",  v135,  v130);

        if (v33) {
          sub_100053B7C(v33);
        }
      }

      else
      {

        uint64_t v33 = 0LL;
      }

      free(v33);
    }

    if (sub_100083DA4(v4, kUMUserSessionHasSyncBagKey) != 1)
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      unsigned int v58 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_216;
      }
      *(void *)unsigned int v134 = 0LL;
      unsigned int v59 = sub_100053B4C(1);
      if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v60 = v59;
      }
      else {
        uint64_t v60 = v59 & 0xFFFFFFFE;
      }
      if ((_DWORD)v60)
      {
        LODWORD(v135[0]) = 67109120;
        HIDWORD(v135[0]) = a1;
        unsigned int v61 = (const char *)_os_log_send_and_compose_impl( v60,  v134,  0LL,  0LL,  &_mh_execute_header,  v58,  0LL,  "SyncBag does not exist for the User:%d, bailing on starting the bubble",  v135);
        goto LABEL_212;
      }

  if ((a3 & 8) != 0) {
    memset_s(v33, 0x20uLL, 0, 0x20uLL);
  }
  return v8;
}

LABEL_214:
      uint64_t v92 = 0LL;
LABEL_215:
      free(v92);
LABEL_216:

      id v10 = 0LL;
      uint64_t v37 = 0xFFFFFFFFLL;
      goto LABEL_217;
    }

    if (sub_100083DA4(v4, kUMUserSessionHasSyncBagKey))
    {
      if (![(id)qword_1000DBA68 splitUserVolumeEnabled])
      {
LABEL_203:
        int SyncBagForUser = MKBUserSessionLoadSyncBagForUser(v4, a1);
        if (SyncBagForUser)
        {
LABEL_204:
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          unsigned int v58 = (os_log_s *)(id)qword_1000DBA98;
          if (!os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_216;
          }
          v135[0] = 0LL;
          unsigned int v90 = sub_100053B4C(1);
          if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v91 = v90;
          }
          else {
            uint64_t v91 = v90 & 0xFFFFFFFE;
          }
          if ((_DWORD)v91)
          {
            *(_DWORD *)unsigned int v134 = 67109376;
            *(_DWORD *)&v134[4] = a1;
            *(_WORD *)&v134[8] = 1024;
            *(_DWORD *)&v134[10] = SyncBagForUser;
            unsigned int v61 = (const char *)_os_log_send_and_compose_impl( v91,  v135,  0LL,  0LL,  &_mh_execute_header,  v58,  0LL,  " Failed to load the SyncBag for User:%d with Error:%d, bailing on starting the bubble",  v134);
LABEL_212:
            uint64_t v92 = (char *)v61;
            if (v61) {
              sub_100053B7C(v61);
            }
            goto LABEL_215;
          }

          goto LABEL_214;
        }

        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        id v107 = (id)qword_1000DBA98;
        if (os_log_type_enabled((os_log_t)v107, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)unsigned int v134 = 0LL;
          unsigned int v108 = sub_100053B4C(1);
          uint64_t v109 = (os_log_s *)v107;
          if (os_log_type_enabled(v109, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v110 = v108;
          }
          else {
            uint64_t v110 = v108 & 0xFFFFFFFE;
          }
          if ((_DWORD)v110)
          {
            LODWORD(v135[0]) = 67109120;
            HIDWORD(v135[0]) = a1;
            uint64_t v111 = (char *)_os_log_send_and_compose_impl( v110,  v134,  0LL,  0LL,  &_mh_execute_header,  v109,  0LL,  "Loaded the SyncBag for User:%d",  v135);

            if (v111) {
              sub_100053B7C(v111);
            }
          }

          else
          {

            uint64_t v111 = 0LL;
          }

          free(v111);
        }

        uint64_t v34 = sub_100083DF4(v4, kUMUserSessionVolumeDeviceNodeKey);
        if (v34)
        {
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          id v112 = (id)qword_1000DBA98;
          if (os_log_type_enabled((os_log_t)v112, OS_LOG_TYPE_DEFAULT))
          {
            v135[0] = 0LL;
            unsigned int v113 = sub_100053B4C(1);
            unsigned int v114 = (os_log_s *)v112;
            if (os_log_type_enabled(v114, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v115 = v113;
            }
            else {
              uint64_t v115 = v113 & 0xFFFFFFFE;
            }
            if ((_DWORD)v115)
            {
              *(_DWORD *)unsigned int v134 = 138412546;
              *(void *)&v134[4] = v34;
              *(_WORD *)&v134[12] = 1024;
              *(_DWORD *)&v134[14] = a1;
              LODWORD(v130) = 18;
              uint64_t v116 = (char *)_os_log_send_and_compose_impl( v115,  v135,  0LL,  0LL,  &_mh_execute_header,  v114,  0LL,  "Calling VolumeMap with disk:%@ for uid:%d",  v134,  v130);

              if (v116) {
                sub_100053B7C(v116);
              }
            }

            else
            {

              uint64_t v116 = 0LL;
            }

            free(v116);
          }

          uint64_t v117 = sub_100019B18(qword_1000DBD40);
          int v118 = (void *)objc_claimAutoreleasedReturnValue(v117);
          id v133 = 0LL;
          unsigned int v119 = [v118 mapVolume:v34 toSession:a1 withPersona:0 error:&v133];
          id v10 = v133;

          if (!v119)
          {
            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            id v125 = (id)qword_1000DBA98;
            if (os_log_type_enabled((os_log_t)v125, OS_LOG_TYPE_DEFAULT))
            {
              v135[0] = 0LL;
              LODWORD(v126) = sub_100053B4C(1);
              uint64_t v127 = (os_log_s *)v125;
              if (os_log_type_enabled(v127, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v126 = v126;
              }
              else {
                uint64_t v126 = v126 & 0xFFFFFFFE;
              }
              if ((_DWORD)v126)
              {
                id v128 = [v10 code];
                *(_DWORD *)unsigned int v134 = 134217984;
                *(void *)&v134[4] = v128;
                CFTypeID v129 = (char *)_os_log_send_and_compose_impl( v126,  v135,  0LL,  0LL,  &_mh_execute_header,  v127,  0LL,  "VolumeMap failed with error:%ld, bailing on starting the bubble",  v134);

                if (v129) {
                  sub_100053B7C(v129);
                }
              }

              else
              {

                CFTypeID v129 = 0LL;
              }

              free(v129);
            }

            BOOL v131 = 1;
            uint64_t v37 = 0xFFFFFFFFLL;
            goto LABEL_173;
          }

          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          id v120 = (id)qword_1000DBA98;
          if (os_log_type_enabled((os_log_t)v120, OS_LOG_TYPE_DEFAULT))
          {
            *(void *)unsigned int v134 = 0LL;
            unsigned int v121 = sub_100053B4C(1);
            uint64_t v122 = (os_log_s *)v120;
            if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v123 = v121;
            }
            else {
              uint64_t v123 = v121 & 0xFFFFFFFE;
            }
            if ((_DWORD)v123)
            {
              LOWORD(v135[0]) = 0;
              LODWORD(v130) = 2;
              unsigned int v124 = (char *)_os_log_send_and_compose_impl( v123,  v134,  0LL,  0LL,  &_mh_execute_header,  v122,  0LL,  "VolumeMap of bubble succeeded",  v135,  v130);

              if (v124) {
                sub_100053B7C(v124);
              }
            }

            else
            {

              unsigned int v124 = 0LL;
            }

            free(v124);
          }

          char v35 = 1;
LABEL_67:
          uint64_t persona = launch_create_persona(a1, 0LL);
          if (!(_DWORD)persona)
          {
            dword_1000DACBC = a1;
            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            unsigned int v48 = (os_log_s *)(id)qword_1000DBA98;
            if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v136 = 0LL;
              unsigned int v49 = sub_100053B4C(1);
              if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v50 = v49;
              }
              else {
                uint64_t v50 = v49 & 0xFFFFFFFE;
              }
              if ((_DWORD)v50)
              {
                *(_DWORD *)unsigned int v134 = 67109120;
                *(_DWORD *)&v134[4] = a1;
                uint64_t v51 = (const char *)_os_log_send_and_compose_impl( v50,  &v136,  0LL,  0LL,  &_mh_execute_header,  v48,  0LL,  "Created persona domain for uid:%d ",  v134);
                id v52 = (char *)v51;
                if (v51) {
                  sub_100053B7C(v51);
                }
              }

              else
              {
                id v52 = 0LL;
              }

              free(v52);
            }

            uint64_t v37 = 0LL;
            goto LABEL_251;
          }

          uint64_t v37 = persona;
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          id v38 = (id)qword_1000DBA98;
          if (os_log_type_enabled((os_log_t)v38, OS_LOG_TYPE_DEFAULT))
          {
            *(void *)unsigned int v134 = 0LL;
            unsigned int v39 = sub_100053B4C(1);
            int v40 = (os_log_s *)v38;
            if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v41 = v39;
            }
            else {
              uint64_t v41 = v39 & 0xFFFFFFFE;
            }
            if ((_DWORD)v41)
            {
              LODWORD(v136) = 67109376;
              HIDWORD(v136) = a1;
              __int16 v137 = 1024;
              LODWORD(v13_Block_object_dispose(va, 8) = v37;
              id v42 = (char *)_os_log_send_and_compose_impl( v41,  v134,  0LL,  0LL,  &_mh_execute_header,  v40,  0LL,  "Failed to create persona domain for uid:%d with error:%d, bailing on starting the bubble",  &v136,  14);

              if (v42) {
                sub_100053B7C(v42);
              }
            }

            else
            {

              id v42 = 0LL;
            }

            free(v42);
          }

          char v66 = v35 ^ 1;
          if (!v34) {
            char v66 = 1;
          }
          if ((v66 & 1) != 0)
          {
LABEL_172:
            p_name = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
            if (!v27) {
              goto LABEL_239;
            }
LABEL_173:
            if (sub_100033524(v4, a1))
            {
              if (qword_1000DBAA0 != -1) {
                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
              }
              id v81 = (id)qword_1000DBA98;
              if (os_log_type_enabled((os_log_t)v81, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v136 = 0LL;
                unsigned int v82 = sub_100053B4C(1);
                int v83 = (os_log_s *)v81;
                if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT)) {
                  uint64_t v84 = v82;
                }
                else {
                  uint64_t v84 = v82 & 0xFFFFFFFE;
                }
                if ((_DWORD)v84)
                {
                  *(_DWORD *)unsigned int v134 = 67109120;
                  *(_DWORD *)&v134[4] = a1;
                  uint64_t v85 = _os_log_send_and_compose_impl( v84,  &v136,  0LL,  0LL,  &_mh_execute_header,  v83,  0LL,  "Failed to unload SyncBag for user:%d",  v134);
                  goto LABEL_191;
                }

                goto LABEL_193;
              }
            }

            else
            {
              if (qword_1000DBAA0 != -1) {
                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
              }
              id v81 = (id)qword_1000DBA98;
              if (os_log_type_enabled((os_log_t)v81, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v136 = 0LL;
                unsigned int v86 = sub_100053B4C(1);
                int v83 = (os_log_s *)v81;
                if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT)) {
                  uint64_t v87 = v86;
                }
                else {
                  uint64_t v87 = v86 & 0xFFFFFFFE;
                }
                if ((_DWORD)v87)
                {
                  *(_DWORD *)unsigned int v134 = 67109120;
                  *(_DWORD *)&v134[4] = a1;
                  uint64_t v85 = _os_log_send_and_compose_impl( v87,  &v136,  0LL,  0LL,  &_mh_execute_header,  v83,  0LL,  "Successfully unloaded the SyncBag for user:%d",  v134);
LABEL_191:
                  uint64_t v88 = (char *)v85;

                  if (v88) {
                    sub_100053B7C(v88);
                  }
                  goto LABEL_194;
                }

    uint64_t v105 = 0LL;
    goto LABEL_215;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v99 = (os_log_s *)(id)qword_1000DBA98;
  if (!os_log_type_enabled(v99, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_216;
  }
  *(void *)in = 0LL;
  CFIndex v100 = sub_100053B4C(1);
  uint64_t v99 = v99;
  if (os_log_type_enabled(v99, OS_LOG_TYPE_DEFAULT)) {
    id v101 = v100;
  }
  else {
    id v101 = v100 & 0xFFFFFFFE;
  }
  if (!(_DWORD)v101) {
    goto LABEL_214;
  }
  LOWORD(v231[0]) = 0;
  LODWORD(v204) = 2;
  unsigned int v102 = _os_log_send_and_compose_impl( v101,  in,  0LL,  0LL,  &_mh_execute_header,  v99,  0LL,  "Persona Volume unmounted",  v231,  v204);
LABEL_212:
  uint64_t v105 = (char *)v102;

  if (v105) {
    sub_100053B7C(v105);
  }
LABEL_215:
  free(v105);
LABEL_216:

LABEL_217:
  uint64_t v229 = 0u;
  v230 = 0u;
  unsigned int v227 = 0u;
  v228 = 0u;
  BOOL v225 = 0u;
  id v226 = 0u;
  CFStringRef v223 = 0u;
  CFDataRef v224 = 0u;
  uint64_t v221 = 0u;
  CFStringRef v222 = 0u;
  v219 = 0u;
  uint64_t v220 = 0u;
  v217 = 0u;
  unsigned int v218 = 0u;
  memset(in, 0, sizeof(in));
  if (!sub_100083E34(theDict, kUMUserPersonaUniqueStringKey, in, 256))
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v106 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v106, OS_LOG_TYPE_DEFAULT))
    {
      v231[0] = 0LL;
      id v107 = sub_100053B4C(1);
      unsigned int v108 = (os_log_s *)v106;
      if (os_log_type_enabled(v108, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v109 = v107;
      }
      else {
        uint64_t v109 = v107 & 0xFFFFFFFE;
      }
      if ((_DWORD)v109)
      {
        LOWORD(uu) = 0;
        LODWORD(v204) = 2;
        uint64_t v110 = (char *)_os_log_send_and_compose_impl( v109,  v231,  0LL,  0LL,  &_mh_execute_header,  v108,  0LL,  "FAILED TO SET PERSONA UNIQUE STRING",  &uu,  v204);

        if (v110) {
          sub_100053B7C(v110);
        }
      }

      else
      {

        uint64_t v110 = 0LL;
      }

      free(v110);
    }
  }

  if (uuid_parse(in, (unsigned __int8 *)&uu))
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v111 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v111, OS_LOG_TYPE_DEFAULT))
    {
      v231[0] = 0LL;
      id v112 = sub_100053B4C(1);
      unsigned int v113 = (os_log_s *)v111;
      if (os_log_type_enabled(v113, OS_LOG_TYPE_DEFAULT)) {
        unsigned int v114 = v112;
      }
      else {
        unsigned int v114 = v112 & 0xFFFFFFFE;
      }
      if ((_DWORD)v114)
      {
        LOWORD(v23_Block_object_dispose(va, 8) = 0;
        LODWORD(v204) = 2;
        uint64_t v115 = (char *)_os_log_send_and_compose_impl( v114,  v231,  0LL,  0LL,  &_mh_execute_header,  v113,  0LL,  "failed to parse unique string to uuid_t",  &v238,  v204);

        if (v115) {
          sub_100053B7C(v115);
        }
      }

      else
      {

        uint64_t v115 = 0LL;
      }

      free(v115);
    }
  }

  if (![(id)qword_1000DBA68 splitUserVolumeEnabled])
  {
    unsigned int v121 = sub_1000197A0(qword_1000DBD40);
    uint64_t v122 = (void *)objc_claimAutoreleasedReturnValue(v121);
    uint64_t v123 = sub_100083DF4(theDict, kUMUserPersonaUniqueStringKey);
    unsigned int v124 = objc_msgSend( v122,  "removePersonaKeyForUser:personaUUID:volumeUUID:",  0,  v123,  CFDictionaryGetValue(theDict, @"MKBUserSessionVolumeUUID"));
    goto LABEL_304;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v116 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v116, OS_LOG_TYPE_DEFAULT))
  {
    v231[0] = 0LL;
    uint64_t v117 = sub_100053B4C(1);
    int v118 = (os_log_s *)v116;
    if (os_log_type_enabled(v118, OS_LOG_TYPE_DEFAULT)) {
      unsigned int v119 = v117;
    }
    else {
      unsigned int v119 = v117 & 0xFFFFFFFE;
    }
    if ((_DWORD)v119)
    {
      LOWORD(v23_Block_object_dispose(va, 8) = 0;
      LODWORD(v204) = 2;
      id v120 = (char *)_os_log_send_and_compose_impl( v119,  v231,  0LL,  0LL,  &_mh_execute_header,  v118,  0LL,  "Unmapping the persona volume..",  &v238,  v204);

      if (v120) {
        sub_100053B7C(v120);
      }
    }

    else
    {

      id v120 = 0LL;
    }

    free(v120);
  }

  uid_t v209 = a1;
  id v125 = (int)v11;
  unsigned int v11 = v13;

  uint64_t v126 = sub_100083DF4(theDict, kUMUserSessionVolumeDeviceNodeKey);
  uint64_t v122 = (void *)objc_claimAutoreleasedReturnValue(v126);
  uint64_t v127 = sub_100019B18(qword_1000DBD40);
  id v128 = (void *)objc_claimAutoreleasedReturnValue(v127);
  v212 = v14;
  CFTypeID v129 = [v128 unmapVolume:v122 error:&v212];
  uint64_t v130 = v212;

  if (!v129)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    BOOL v131 = theDict;
    id v132 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v132, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_277;
    }
    uint64_t v238 = 0LL;
    uint64_t v136 = sub_100053B4C(1);
    id v132 = v132;
    if (os_log_type_enabled(v132, OS_LOG_TYPE_DEFAULT)) {
      __int16 v137 = v136;
    }
    else {
      __int16 v137 = v136 & 0xFFFFFFFE;
    }
    if ((_DWORD)v137)
    {
      LODWORD(v231[0]) = 138412290;
      *(void *)((char *)v231 + 4) = v130;
      LODWORD(v204) = 12;
      uint64_t v135 = _os_log_send_and_compose_impl( v137,  &v238,  0LL,  0LL,  &_mh_execute_header,  v132,  0LL,  "Failed to unmap persona volume error:%@, going ahead TO delete persona key..",  v231,  v204);
      goto LABEL_273;
    }

LABEL_193:
                uint64_t v88 = 0LL;
LABEL_194:
                free(v88);
              }
            }

            if (!v131) {
              goto LABEL_239;
            }
LABEL_217:
            if ([p_name[333] unmountVolumeWithSession:v4 mountPath:0 error:0])
            {
              if (qword_1000DBAA0 != -1) {
                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
              }
              unsigned int v93 = (os_log_s *)(id)qword_1000DBA98;
              if (!os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_238;
              }
              uint64_t v136 = 0LL;
              unsigned int v94 = sub_100053B4C(1);
              uint64_t v95 = v93;
              if (os_log_type_enabled(v95, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v96 = v94;
              }
              else {
                uint64_t v96 = v94 & 0xFFFFFFFE;
              }
              if ((_DWORD)v96)
              {
                *(_WORD *)unsigned int v134 = 0;
                LODWORD(v130) = 2;
                uint64_t v97 = _os_log_send_and_compose_impl( v96,  &v136,  0LL,  0LL,  &_mh_execute_header,  v95,  0LL,  "APFSUser Volume unmounted after bubble load failure",  v134,  v130);
                goto LABEL_234;
              }
            }

            else
            {
              if (qword_1000DBAA0 != -1) {
                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
              }
              unsigned int v93 = (os_log_s *)(id)qword_1000DBA98;
              if (!os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_238;
              }
              uint64_t v136 = 0LL;
              unsigned int v98 = sub_100053B4C(1);
              uint64_t v95 = v93;
              if (os_log_type_enabled(v95, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v99 = v98;
              }
              else {
                uint64_t v99 = v98 & 0xFFFFFFFE;
              }
              if ((_DWORD)v99)
              {
                *(_WORD *)unsigned int v134 = 0;
                LODWORD(v130) = 2;
                uint64_t v97 = _os_log_send_and_compose_impl( v99,  &v136,  0LL,  0LL,  &_mh_execute_header,  v95,  0LL,  "APFSUser Volume failed to unmount after bubble load failure",  v134,  v130);
LABEL_234:
                CFIndex v100 = (char *)v97;

                if (v100) {
                  sub_100053B7C(v100);
                }
                goto LABEL_237;
              }
            }

            CFIndex v100 = 0LL;
LABEL_237:
            free(v100);
LABEL_238:

LABEL_239:
            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            id v101 = (id)qword_1000DBA98;
            if (os_log_type_enabled((os_log_t)v101, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v136 = 0LL;
              unsigned int v102 = sub_100053B4C(1);
              uint64_t v103 = (os_log_s *)v101;
              if (os_log_type_enabled(v103, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v104 = v102;
              }
              else {
                uint64_t v104 = v102 & 0xFFFFFFFE;
              }
              if ((_DWORD)v104)
              {
                *(_DWORD *)unsigned int v134 = 67109120;
                *(_DWORD *)&v134[4] = a1;
                uint64_t v105 = (char *)_os_log_send_and_compose_impl( v104,  &v136,  0LL,  0LL,  &_mh_execute_header,  v103,  0LL,  "Removing Sandbox kext path upload for bubble with uid %ds",  v134);

                if (v105) {
                  sub_100053B7C(v105);
                }
              }

              else
              {

                uint64_t v105 = 0LL;
              }

              free(v105);
            }

            sub_100033870(a1);
LABEL_251:
            CFRelease(v4);
            goto LABEL_252;
          }

          uint64_t v67 = sub_100019B18(qword_1000DBD40);
          id v68 = (void *)objc_claimAutoreleasedReturnValue(v67);
          id v132 = 0LL;
          unsigned int v69 = [v68 unmapVolume:v34 error:&v132];
          id v10 = v132;

          if (v69)
          {
            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            id v70 = (os_log_s *)(id)qword_1000DBA98;
            if (!os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_171;
            }
            uint64_t v136 = 0LL;
            unsigned int v71 = sub_100053B4C(1);
            uint64_t v72 = v70;
            if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v73 = v71;
            }
            else {
              uint64_t v73 = v71 & 0xFFFFFFFE;
            }
            if ((_DWORD)v73)
            {
              *(_DWORD *)unsigned int v134 = 67109120;
              *(_DWORD *)&v134[4] = a1;
              uint64_t v74 = _os_log_send_and_compose_impl( v73,  &v136,  0LL,  0LL,  &_mh_execute_header,  v72,  0LL,  "VolumeUnMap for uid%d succeeded",  v134);
              goto LABEL_154;
            }
          }

          else
          {
            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            id v70 = (os_log_s *)(id)qword_1000DBA98;
            if (!os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_171;
            }
            *(void *)unsigned int v134 = 0LL;
            LODWORD(v75) = sub_100053B4C(1);
            uint64_t v72 = v70;
            if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v75 = v75;
            }
            else {
              uint64_t v75 = v75 & 0xFFFFFFFE;
            }
            if ((_DWORD)v75)
            {
              id v76 = [v10 code];
              LODWORD(v136) = 67109376;
              HIDWORD(v136) = a1;
              __int16 v137 = 2048;
              id v138 = v76;
              LODWORD(v130) = 18;
              uint64_t v74 = _os_log_send_and_compose_impl( v75,  v134,  0LL,  0LL,  &_mh_execute_header,  v72,  0LL,  "VolumeUnMap for uid:%d failed with error:%ld",  &v136,  v130);
LABEL_154:
              uint64_t v77 = (char *)v74;

              if (v77) {
                sub_100053B7C(v77);
              }
              goto LABEL_170;
            }
          }

          uint64_t v77 = 0LL;
LABEL_170:
          free(v77);
LABEL_171:

          goto LABEL_172;
        }

        id v10 = 0LL;
LABEL_66:
        char v35 = 0;
        goto LABEL_67;
      }

      if ((sub_100045A94(v4) & 1) != 0)
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        unsigned int v53 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)unsigned int v134 = 0LL;
          unsigned int v54 = sub_100053B4C(1);
          if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v55 = v54;
          }
          else {
            uint64_t v55 = v54 & 0xFFFFFFFE;
          }
          if ((_DWORD)v55)
          {
            LOWORD(v135[0]) = 0;
            LODWORD(v130) = 2;
            uint64_t v56 = (const char *)_os_log_send_and_compose_impl( v55,  v134,  0LL,  0LL,  &_mh_execute_header,  v53,  0LL,  "Loaded AKS Identity",  v135,  v130);
            vm_size_t v57 = (char *)v56;
            if (v56) {
              sub_100053B7C(v56);
            }
          }

          else
          {
            vm_size_t v57 = 0LL;
          }

          free(v57);
        }

        goto LABEL_203;
      }

      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      id v62 = (id)qword_1000DBA98;
      if (!os_log_type_enabled((os_log_t)v62, OS_LOG_TYPE_DEFAULT))
      {
LABEL_199:

        int SyncBagForUser = -1;
        goto LABEL_204;
      }

      *(void *)unsigned int v134 = 0LL;
      unsigned int v78 = sub_100053B4C(1);
      if (os_log_type_enabled((os_log_t)v62, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v79 = v78;
      }
      else {
        uint64_t v79 = v78 & 0xFFFFFFFE;
      }
      if ((_DWORD)v79)
      {
        LOWORD(v135[0]) = 0;
        LODWORD(v130) = 2;
        unsigned int v65 = (const char *)_os_log_send_and_compose_impl( v79,  v134,  0LL,  0LL,  &_mh_execute_header,  v62,  0LL,  "failed to Load AKS Identity, bailing",  v135,  v130);
LABEL_167:
        id v80 = (char *)v65;
        if (v65) {
          sub_100053B7C(v65);
        }
        goto LABEL_198;
      }
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      id v62 = (id)qword_1000DBA98;
      if (!os_log_type_enabled((os_log_t)v62, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_199;
      }
      *(void *)unsigned int v134 = 0LL;
      unsigned int v63 = sub_100053B4C(1);
      if (os_log_type_enabled((os_log_t)v62, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v64 = v63;
      }
      else {
        uint64_t v64 = v63 & 0xFFFFFFFE;
      }
      if ((_DWORD)v64)
      {
        LOWORD(v135[0]) = 0;
        LODWORD(v130) = 2;
        unsigned int v65 = (const char *)_os_log_send_and_compose_impl( v64,  v134,  0LL,  0LL,  &_mh_execute_header,  v62,  0LL,  "Session has no SyncBag (kUMUserSessionHasSyncBagKey=false), nothing to load",  v135,  v130);
        goto LABEL_167;
      }
    }

    id v80 = 0LL;
LABEL_198:
    free(v80);
    goto LABEL_199;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v10 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v136 = 0LL;
    unsigned int v11 = sub_100053B4C(1);
    if (os_log_type_enabled((os_log_t)v10, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v12 = v11;
    }
    else {
      uint64_t v12 = v11 & 0xFFFFFFFE;
    }
    if ((_DWORD)v12)
    {
      *(_DWORD *)unsigned int v134 = 67109120;
      *(_DWORD *)&v134[4] = a1;
      uint64_t v13 = (const char *)_os_log_send_and_compose_impl( v12,  &v136,  0LL,  0LL,  &_mh_execute_header,  v10,  0LL,  "No UserSession present for uid %d,bailing on starting the bubble",  v134);
      unsigned int v14 = (char *)v13;
      if (v13) {
        sub_100053B7C(v13);
      }
    }

    else
    {
      unsigned int v14 = 0LL;
    }

    free(v14);
  }

  uint64_t v37 = 0xFFFFFFFFLL;
LABEL_252:

  return v37;
}

uint64_t sub_10003323C(uint64_t a1, const char *a2, int a3)
{
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  unsigned int v6 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v21[0] = 0LL;
    unsigned int v7 = sub_100053B4C(1);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = v7 & 0xFFFFFFFE;
    }
    if ((_DWORD)v8)
    {
      *(_DWORD *)id v22 = 136315394;
      *(void *)&v22[4] = a2;
      __int16 v23 = 2080;
      unsigned int v24 = __str;
      unsigned int v9 = (const char *)_os_log_send_and_compose_impl( v8,  v21,  0LL,  0LL,  &_mh_execute_header,  v6,  0LL,  "HomeDir:%s, TMPDir:%s",  v22,  22);
      id v10 = (char *)v9;
      if (v9) {
        sub_100053B7C(v9);
      }
    }

    else
    {
      id v10 = 0LL;
    }

    free(v10);
  }

  uint64_t v11 = sub_10004C858(a1, a3, (uint64_t)a2, (uint64_t)__str, 0);
  if ((_DWORD)v11)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v12 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)id v22 = 0LL;
      unsigned int v13 = sub_100053B4C(1);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v14 = v13;
      }
      else {
        uint64_t v14 = v13 & 0xFFFFFFFE;
      }
      if ((_DWORD)v14)
      {
        LOWORD(v21[0]) = 0;
        LODWORD(v20) = 2;
        id v15 = (const char *)_os_log_send_and_compose_impl( v14,  v22,  0LL,  0LL,  &_mh_execute_header,  v12,  0LL,  "Sandbox_set_homedir success",  v21,  v20,  v21[0]);
        goto LABEL_29;
      }

      goto LABEL_31;
    }
  }

  else
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v12 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)id v22 = 0LL;
      unsigned int v16 = sub_100053B4C(1);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v17 = v16;
      }
      else {
        uint64_t v17 = v16 & 0xFFFFFFFE;
      }
      if ((_DWORD)v17)
      {
        LOWORD(v21[0]) = 0;
        LODWORD(v20) = 2;
        id v15 = (const char *)_os_log_send_and_compose_impl( v17,  v22,  0LL,  0LL,  &_mh_execute_header,  v12,  0LL,  "Sandbox_set_homedir failed",  v21,  v20,  v21[0]);
LABEL_29:
        uint64_t v18 = (char *)v15;
        if (v15) {
          sub_100053B7C(v15);
        }
        goto LABEL_32;
      }

uint64_t sub_100033524(const __CFDictionary *a1, uint64_t a2)
{
  if (!sub_100083DA4(a1, kUMUserSessionHasSyncBagKey))
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v9 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v20 = 0LL;
      unsigned int v10 = sub_100053B4C(1);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = v10 & 0xFFFFFFFE;
      }
      if ((_DWORD)v11)
      {
        LOWORD(v21) = 0;
        uint64_t v12 = (const char *)_os_log_send_and_compose_impl( v11,  &v20,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "Session has no SyncBag (kUMUserSessionHasSyncBagKey=false), nothing to unload",  &v21,  2);
        unsigned int v13 = (char *)v12;
        if (v12) {
          sub_100053B7C(v12);
        }
      }

      else
      {
        unsigned int v13 = 0LL;
      }

      free(v13);
    }

    return 0LL;
  }

  if (sub_100046098(a1))
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v4 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v20 = 0LL;
      unsigned int v5 = sub_100053B4C(1);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v6 = v5;
      }
      else {
        uint64_t v6 = v5 & 0xFFFFFFFE;
      }
      if ((_DWORD)v6)
      {
        int v21 = 67109120;
        int v22 = a2;
        unsigned int v7 = (const char *)_os_log_send_and_compose_impl( v6,  &v20,  0LL,  0LL,  &_mh_execute_header,  v4,  0LL,  "Unloaded the AKS Identity for user:%d",  &v21);
        uint64_t v8 = (char *)v7;
        if (v7) {
          sub_100053B7C(v7);
        }
      }

      else
      {
        uint64_t v8 = 0LL;
      }

      free(v8);
    }

    return 0LL;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v15 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v20 = 0LL;
    unsigned int v16 = sub_100053B4C(1);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v17 = v16;
    }
    else {
      uint64_t v17 = v16 & 0xFFFFFFFE;
    }
    if ((_DWORD)v17)
    {
      int v21 = 67109120;
      int v22 = a2;
      uint64_t v18 = (const char *)_os_log_send_and_compose_impl( v17,  &v20,  0LL,  0LL,  &_mh_execute_header,  v15,  0LL,  "Failed to Unload the AKS Identity for user:%d",  &v21);
      unsigned int v19 = (char *)v18;
      if (v18) {
        sub_100053B7C(v18);
      }
    }

    else
    {
      unsigned int v19 = 0LL;
    }

    free(v19);
  }

  return 0xFFFFFFFFLL;
}

uint64_t sub_100033870(uint64_t a1)
{
  uint64_t v1 = sub_10004C858(a1, 0, 0LL, 0LL, 1);
  if ((_DWORD)v1)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v2 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = 0LL;
      unsigned int v3 = sub_100053B4C(1);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v4 = v3;
      }
      else {
        uint64_t v4 = v3 & 0xFFFFFFFE;
      }
      if ((_DWORD)v4)
      {
        LOWORD(v10) = 0;
        unsigned int v5 = (const char *)_os_log_send_and_compose_impl( v4,  &v11,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "Sandbox_remove_homedir success",  &v10,  2,  v10);
        goto LABEL_18;
      }

      goto LABEL_20;
    }
  }

  else
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v2 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = 0LL;
      unsigned int v6 = sub_100053B4C(1);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v7 = v6;
      }
      else {
        uint64_t v7 = v6 & 0xFFFFFFFE;
      }
      if ((_DWORD)v7)
      {
        LOWORD(v10) = 0;
        unsigned int v5 = (const char *)_os_log_send_and_compose_impl( v7,  &v11,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "Sandbox_remove_homedir failed",  &v10,  2,  v10);
LABEL_18:
        uint64_t v8 = (char *)v5;
        if (v5) {
          sub_100053B7C(v5);
        }
        goto LABEL_21;
      }

uint64_t sub_100033A14(int a1)
{
  uint64_t v2 = MGGetBoolAnswer(@"InternalBuild");
  if ((_DWORD)v2)
  {
    if (a1)
    {
      byte_1000DACB8 = 1;
      qword_1000DBA88 = (uint64_t)kUMUserSessionAPFSNativeVolume;
      valuePtr[0] = 502;
      CFNumberRef v3 = CFNumberCreate(0LL, kCFNumberIntType, valuePtr);
      uint64_t v4 = sub_10008428C();
      CFDictionarySetValue(v4, kUMUserSessionIDKey, v3);
      sub_100021680(v4, 0);
      if (v3) {
        CFRelease(v3);
      }
      if (mkpath_np("/var/Users", 0x1FFu))
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        unsigned int v5 = (os_log_s *)(id)qword_1000DBA98;
        if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_102;
        }
        v54[0] = 0LL;
        LODWORD(v6) = sub_100053B4C(1);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v6 = v6;
        }
        else {
          uint64_t v6 = v6 & 0xFFFFFFFE;
        }
        if ((_DWORD)v6)
        {
          uint64_t v7 = v5;
          uint64_t v8 = __error();
          unsigned int v9 = strerror(*v8);
          *(_DWORD *)__str = 136315138;
          *(void *)&char __str[4] = v9;
          uint64_t v10 = (void *)_os_log_send_and_compose_impl( v6,  v54,  0LL,  0LL,  &_mh_execute_header,  v7,  0LL,  "failed to create:/var/Users (%s)\n",  __str);

          if (!v10) {
            goto LABEL_101;
          }
          goto LABEL_99;
        }

LABEL_100:
        uint64_t v10 = 0LL;
        goto LABEL_101;
      }

      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      unsigned int v5 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_102;
      }
      *(void *)__str = 0LL;
      unsigned int v19 = sub_100053B4C(1);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v20 = v19;
      }
      else {
        uint64_t v20 = v19 & 0xFFFFFFFE;
      }
      if (!(_DWORD)v20) {
        goto LABEL_100;
      }
      LOWORD(v54[0]) = 0;
      uint64_t v21 = _os_log_send_and_compose_impl( v20,  __str,  0LL,  0LL,  &_mh_execute_header,  v5,  0LL,  "Created path /var/Users",  v54,  2);
    }

    else
    {
      byte_1000DACB8 = 0;
      qword_1000DBA88 = 0LL;
      if (qword_1000DBCD8) {
        CFArrayRemoveAllValues((CFMutableArrayRef)qword_1000DBCD8);
      }
      if (qword_1000DBCF8) {
        CFArrayRemoveAllValues((CFMutableArrayRef)qword_1000DBCF8);
      }
      if (qword_1000DBD00) {
        CFArrayRemoveAllValues((CFMutableArrayRef)qword_1000DBD00);
      }
      uint64_t v11 = sub_100019434(qword_1000DBD40);
      uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
      unsigned __int8 v13 = [v12 removeFileAtPath:@"/private/var//keybags/usersession.kb" error:0];

      if ((v13 & 1) != 0)
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        uint64_t v14 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)__str = 0LL;
          unsigned int v15 = sub_100053B4C(1);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v16 = v15;
          }
          else {
            uint64_t v16 = v15 & 0xFFFFFFFE;
          }
          if ((_DWORD)v16)
          {
            LOWORD(v54[0]) = 0;
            uint64_t v17 = (const char *)_os_log_send_and_compose_impl( v16,  __str,  0LL,  0LL,  &_mh_execute_header,  v14,  0LL,  "removed USER_SESSION_BAG_PATH",  v54,  2);
            uint64_t v18 = (char *)v17;
            if (v17) {
              sub_100053B7C(v17);
            }
          }

          else
          {
            uint64_t v18 = 0LL;
          }

          free(v18);
        }
      }

      else
      {
        perror("unlink of USER_SESSION_BAG_PATH failed with error");
      }

      uint64_t v22 = sub_100019434(qword_1000DBD40);
      __int16 v23 = (void *)objc_claimAutoreleasedReturnValue(v22);
      unsigned __int8 v24 = [v23 removeFileAtPath:@"/private/var//keybags/usersyncbag.kb" error:0];

      if ((v24 & 1) != 0)
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        uint64_t v25 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)__str = 0LL;
          unsigned int v26 = sub_100053B4C(1);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v27 = v26;
          }
          else {
            uint64_t v27 = v26 & 0xFFFFFFFE;
          }
          if ((_DWORD)v27)
          {
            LOWORD(v54[0]) = 0;
            LODWORD(v52) = 2;
            uint64_t v28 = (const char *)_os_log_send_and_compose_impl( v27,  __str,  0LL,  0LL,  &_mh_execute_header,  v25,  0LL,  "removed USER_SYNC_BAG_PATH",  v54,  v52);
            id v29 = (char *)v28;
            if (v28) {
              sub_100053B7C(v28);
            }
          }

          else
          {
            id v29 = 0LL;
          }

          free(v29);
        }
      }

      else
      {
        perror("unlink of USER_SYNC_BAG_PATH failed with error");
      }

      uint64_t v30 = sub_100019434(qword_1000DBD40);
      int v31 = (void *)objc_claimAutoreleasedReturnValue(v30);
      unsigned __int8 v32 = [v31 removeFileAtPath:@"/private/var/keybags/LockoutState.plist" error:0];

      if ((v32 & 1) != 0)
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        uint64_t v33 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)__str = 0LL;
          unsigned int v34 = sub_100053B4C(1);
          if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v35 = v34;
          }
          else {
            uint64_t v35 = v34 & 0xFFFFFFFE;
          }
          if ((_DWORD)v35)
          {
            LOWORD(v54[0]) = 0;
            LODWORD(v52) = 2;
            int v36 = (const char *)_os_log_send_and_compose_impl( v35,  __str,  0LL,  0LL,  &_mh_execute_header,  v33,  0LL,  "removed /private/var/keybags/LockoutState.plist",  v54,  v52);
            uint64_t v37 = (char *)v36;
            if (v36) {
              sub_100053B7C(v36);
            }
          }

          else
          {
            uint64_t v37 = 0LL;
          }

          free(v37);
        }
      }

      else
      {
        perror("unlink of /private/var/keybags/LockoutState.plist failed with error");
      }

      snprintf(__str, 0x400uLL, "%s%s/%s.kb", "/private/var/", "keybags", "userbag");
      uint64_t v38 = sub_100019434(qword_1000DBD40);
      unsigned int v39 = (void *)objc_claimAutoreleasedReturnValue(v38);
      int v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", __str));
      unsigned __int8 v41 = [v39 removeFileAtPath:v40 error:0];

      if ((v41 & 1) != 0)
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        id v42 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
        {
          v54[0] = 0LL;
          unsigned int v43 = sub_100053B4C(1);
          if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v44 = v43;
          }
          else {
            uint64_t v44 = v43 & 0xFFFFFFFE;
          }
          if ((_DWORD)v44)
          {
            LOWORD(valuePtr[0]) = 0;
            LODWORD(v53) = 2;
            uint64_t v45 = (const char *)_os_log_send_and_compose_impl( v44,  v54,  0LL,  0LL,  &_mh_execute_header,  v42,  0LL,  "removed userBagPath",  valuePtr,  v53);
            uint64_t v46 = (char *)v45;
            if (v45) {
              sub_100053B7C(v45);
            }
          }

          else
          {
            uint64_t v46 = 0LL;
          }

          free(v46);
        }
      }

      else
      {
        perror("unlink of userBagPath failed with error");
      }

      if (sub_10002D61C("/var/Users"))
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        unsigned int v5 = (os_log_s *)(id)qword_1000DBA98;
        if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_102;
        }
        v54[0] = 0LL;
        unsigned int v47 = sub_100053B4C(1);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v48 = v47;
        }
        else {
          uint64_t v48 = v47 & 0xFFFFFFFE;
        }
        if (!(_DWORD)v48) {
          goto LABEL_100;
        }
        LOWORD(valuePtr[0]) = 0;
        LODWORD(v53) = 2;
        uint64_t v21 = _os_log_send_and_compose_impl( v48,  v54,  0LL,  0LL,  &_mh_execute_header,  v5,  0LL,  "removed /var/Users path",  valuePtr,  v53);
      }

      else
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        unsigned int v5 = (os_log_s *)(id)qword_1000DBA98;
        if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_102;
        }
        v54[0] = 0LL;
        unsigned int v49 = sub_100053B4C(1);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v50 = v49;
        }
        else {
          uint64_t v50 = v49 & 0xFFFFFFFE;
        }
        if (!(_DWORD)v50) {
          goto LABEL_100;
        }
        LOWORD(valuePtr[0]) = 0;
        LODWORD(v53) = 2;
        uint64_t v21 = _os_log_send_and_compose_impl( v50,  v54,  0LL,  0LL,  &_mh_execute_header,  v5,  0LL,  "Failed to remove /var/Users hierarchy, please remove it",  valuePtr,  v53);
      }
    }

    uint64_t v10 = (void *)v21;
    if (!v21)
    {
LABEL_101:
      free(v10);
LABEL_102:

      return v2;
    }

LABEL_99:
    sub_100053B7C((const char *)v10);
    goto LABEL_101;
  }

  return v2;
}

void sub_100034290(const __CFString *a1)
{
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v2 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = 0LL;
    unsigned int v3 = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      int v10 = 138412290;
      uint64_t v11 = a1;
      unsigned int v5 = (const char *)_os_log_send_and_compose_impl( v4,  &v9,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "RegisterSyncService: machservice %@",  &v10,  12);
      uint64_t v6 = (char *)v5;
      if (v5) {
        sub_100053B7C(v5);
      }
    }

    else
    {
      uint64_t v6 = 0LL;
    }

    free(v6);
  }

  uint64_t v7 = (const __CFDictionary *)sub_10001A594();
  if (v7)
  {
    uint64_t v8 = v7;
    sub_1000343E0(v7, a1);
    CFRelease(v8);
  }

void sub_1000343E0(const __CFDictionary *a1, const __CFString *a2)
{
  uint64_t v4 = sub_100083C6C(a1, kUMUserSessionIDKey);
  if (CFDictionaryContainsKey(a1, kUMUserSessionSyncMachServicesKey)
    && (unsigned int v5 = CFDictionaryGetValue(a1, kUMUserSessionSyncMachServicesKey), v6 = CFGetTypeID(v5), v6 == CFArrayGetTypeID()))
  {
    Value = (const __CFArray *)CFDictionaryGetValue(a1, kUMUserSessionSyncMachServicesKey);
    MutableCFArrayRef Copy = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0LL, Value);
    char v9 = 1;
  }

  else
  {
    MutableCFArrayRef Copy = sub_100084320();
    char v9 = 0;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  int v10 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    v40[0] = 0LL;
    unsigned int v11 = sub_100053B4C(1);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v12 = v11;
    }
    else {
      uint64_t v12 = v11 & 0xFFFFFFFE;
    }
    if ((_DWORD)v12)
    {
      *(_DWORD *)unsigned __int8 v41 = 138412290;
      *(void *)&v41[4] = a2;
      unsigned __int8 v13 = (const char *)_os_log_send_and_compose_impl( v12,  v40,  0LL,  0LL,  &_mh_execute_header,  v10,  0LL,  "RegisterSyncService: machservice %@",  v41,  12);
      uint64_t v14 = (char *)v13;
      if (v13) {
        sub_100053B7C(v13);
      }
    }

    else
    {
      uint64_t v14 = 0LL;
    }

    free(v14);
  }

  if (CFArrayGetCount(MutableCopy) < 1)
  {
LABEL_22:
    CFArrayAppendValue(MutableCopy, a2);
    if ((v9 & 1) != 0) {
      CFDictionaryReplaceValue(a1, kUMUserSessionSyncMachServicesKey, MutableCopy);
    }
    else {
      CFDictionarySetValue(a1, kUMUserSessionSyncMachServicesKey, MutableCopy);
    }
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v19 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      v40[0] = 0LL;
      unsigned int v20 = sub_100053B4C(1);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v21 = v20;
      }
      else {
        uint64_t v21 = v20 & 0xFFFFFFFE;
      }
      if ((_DWORD)v21)
      {
        *(_DWORD *)unsigned __int8 v41 = 138412290;
        *(void *)&v41[4] = MutableCopy;
        LODWORD(v39) = 12;
        uint64_t v22 = (const char *)_os_log_send_and_compose_impl( v21,  v40,  0LL,  0LL,  &_mh_execute_header,  v19,  0LL,  "RegisterSyncService: machservices list array: %@",  v41,  v39);
        __int16 v23 = (char *)v22;
        if (v22) {
          sub_100053B7C(v22);
        }
      }

      else
      {
        __int16 v23 = 0LL;
      }

      free(v23);
    }

    if (CFArrayGetCount(MutableCopy) >= 1)
    {
      CFDictionarySetValue(a1, kUMUserSessionDirtyKey, kCFBooleanTrue);
      int v24 = sub_100083C6C(a1, kUMUserSessionIDKey);
      sub_10001D55C(v24);
    }

    sub_10001AED4();
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v25 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      v40[0] = 0LL;
      unsigned int v26 = sub_100053B4C(1);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v27 = v26;
      }
      else {
        uint64_t v27 = v26 & 0xFFFFFFFE;
      }
      if ((_DWORD)v27)
      {
        *(_DWORD *)unsigned __int8 v41 = 67109378;
        *(_DWORD *)&v41[4] = v4;
        *(_WORD *)&v41[8] = 2112;
        *(void *)&v41[10] = MutableCopy;
        LODWORD(v39) = 18;
        uint64_t v28 = (const char *)_os_log_send_and_compose_impl( v27,  v40,  0LL,  0LL,  &_mh_execute_header,  v25,  0LL,  "Calling _SecSyncBubbleTransfer(Register) for uid %d with array %@",  v41,  v39);
        id v29 = (char *)v28;
        if (v28) {
          sub_100053B7C(v28);
        }
      }

      else
      {
        id v29 = 0LL;
      }

      free(v29);
    }

    if (_SecSyncBubbleTransfer(MutableCopy, v4, 0LL))
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v30 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)unsigned __int8 v41 = 0LL;
        unsigned int v31 = sub_100053B4C(1);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v32 = v31;
        }
        else {
          uint64_t v32 = v31 & 0xFFFFFFFE;
        }
        if ((_DWORD)v32)
        {
          LOWORD(v40[0]) = 0;
          LODWORD(v39) = 2;
          uint64_t v33 = (const char *)_os_log_send_and_compose_impl( v32,  v41,  0LL,  0LL,  &_mh_execute_header,  v30,  0LL,  "_SecSyncBubbleTransfer success",  v40,  v39,  v40[0]);
          goto LABEL_66;
        }

        goto LABEL_76;
      }
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v30 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)unsigned __int8 v41 = 0LL;
        unsigned int v34 = sub_100053B4C(1);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v35 = v34;
        }
        else {
          uint64_t v35 = v34 & 0xFFFFFFFE;
        }
        if ((_DWORD)v35)
        {
          LOWORD(v40[0]) = 0;
          LODWORD(v39) = 2;
          uint64_t v33 = (const char *)_os_log_send_and_compose_impl( v35,  v41,  0LL,  0LL,  &_mh_execute_header,  v30,  0LL,  "_SecSyncBubbleTransfer failed",  v40,  v39,  v40[0]);
          goto LABEL_66;
        }

void sub_100034A5C()
{
  id v0 = (const __CFDictionary *)sub_10001A594();
  if (v0)
  {
    uint64_t v1 = v0;
    if (!CFDictionaryContainsKey(v0, kUMUserSessionSyncMachServicesKey)) {
      goto LABEL_37;
    }
    uint64_t v2 = sub_100083C6C(v1, kUMUserSessionIDKey);
    Value = CFDictionaryGetValue(v1, kUMUserSessionSyncMachServicesKey);
    if (!Value) {
      goto LABEL_37;
    }
    uint64_t v4 = Value;
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v5 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = 0LL;
      unsigned int v6 = sub_100053B4C(1);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v7 = v6;
      }
      else {
        uint64_t v7 = v6 & 0xFFFFFFFE;
      }
      if ((_DWORD)v7)
      {
        LOWORD(v1_Block_object_dispose(va, 8) = 0;
        uint64_t v8 = (const char *)_os_log_send_and_compose_impl( v7,  &v19,  0LL,  0LL,  &_mh_execute_header,  v5,  0LL,  "Notifying Bubble machservice list for keychain update",  &v18,  2);
        char v9 = (char *)v8;
        if (v8) {
          sub_100053B7C(v8);
        }
      }

      else
      {
        char v9 = 0LL;
      }

      free(v9);
    }

    if (_SecSyncBubbleTransfer(v4, v2, 0LL))
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      int v10 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_36;
      }
      uint64_t v19 = 0LL;
      unsigned int v11 = sub_100053B4C(1);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v12 = v11;
      }
      else {
        uint64_t v12 = v11 & 0xFFFFFFFE;
      }
      if ((_DWORD)v12)
      {
        LOWORD(v1_Block_object_dispose(va, 8) = 0;
        LODWORD(v17) = 2;
        unsigned __int8 v13 = (const char *)_os_log_send_and_compose_impl( v12,  &v19,  0LL,  0LL,  &_mh_execute_header,  v10,  0LL,  "_SecSyncBubbleTransfer success",  &v18,  v17,  v18);
        goto LABEL_32;
      }
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      int v10 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_36;
      }
      uint64_t v19 = 0LL;
      unsigned int v14 = sub_100053B4C(1);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v15 = v14;
      }
      else {
        uint64_t v15 = v14 & 0xFFFFFFFE;
      }
      if ((_DWORD)v15)
      {
        LOWORD(v1_Block_object_dispose(va, 8) = 0;
        LODWORD(v17) = 2;
        unsigned __int8 v13 = (const char *)_os_log_send_and_compose_impl( v15,  &v19,  0LL,  0LL,  &_mh_execute_header,  v10,  0LL,  "_SecSyncBubbleTransfer failed",  &v18,  v17,  v18);
LABEL_32:
        uint64_t v16 = (char *)v13;
        if (v13) {
          sub_100053B7C(v13);
        }
        goto LABEL_35;
      }
    }

    uint64_t v16 = 0LL;
LABEL_35:
    free(v16);
LABEL_36:

LABEL_37:
    CFRelease(v1);
  }

void sub_100034D1C(const __CFString *a1)
{
  uint64_t v2 = (const __CFDictionary *)sub_10001A594();
  if (v2)
  {
    unsigned int v3 = v2;
    sub_100034D5C(v2, a1);
    CFRelease(v3);
  }

void sub_100034D5C(const __CFDictionary *a1, const __CFString *a2)
{
  uint64_t v4 = sub_100083C6C(a1, kUMUserSessionIDKey);
  if (CFDictionaryContainsKey(a1, kUMUserSessionSyncMachServicesKey))
  {
    Value = (void *)CFDictionaryGetValue(a1, kUMUserSessionSyncMachServicesKey);
    CFTypeID v6 = CFGetTypeID(Value);
    if (v6 == CFArrayGetTypeID() && CFArrayGetCount((CFArrayRef)Value))
    {
      if (CFArrayGetCount((CFArrayRef)Value) < 1)
      {
LABEL_10:
        if (CFArrayGetCount((CFArrayRef)Value)) {
          return;
        }
        char v11 = 0;
      }

      else
      {
        CFIndex v7 = 0LL;
        while (1)
        {
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)Value, v7);
          if (ValueAtIndex)
          {
            char v9 = ValueAtIndex;
            CFTypeID v10 = CFGetTypeID(ValueAtIndex);
            if (v10 == CFStringGetTypeID() && CFStringCompare(v9, a2, 0LL) == kCFCompareEqualTo) {
              break;
            }
          }

          if (CFArrayGetCount((CFArrayRef)Value) <= ++v7) {
            goto LABEL_10;
          }
        }

        CFArrayRemoveValueAtIndex((CFMutableArrayRef)Value, v7);
        CFRetain(Value);
        if (CFArrayGetCount((CFArrayRef)Value))
        {
LABEL_41:
          sub_10001AED4();
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          uint64_t v22 = (os_log_s *)(id)qword_1000DBA98;
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
          {
            v35[0] = 0LL;
            unsigned int v23 = sub_100053B4C(1);
            if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v24 = v23;
            }
            else {
              uint64_t v24 = v23 & 0xFFFFFFFE;
            }
            if ((_DWORD)v24)
            {
              LODWORD(v36) = 67109378;
              HIDWORD(v36) = v4;
              __int16 v37 = 2112;
              uint64_t v38 = Value;
              LODWORD(v34) = 18;
              uint64_t v25 = (const char *)_os_log_send_and_compose_impl( v24,  v35,  0LL,  0LL,  &_mh_execute_header,  v22,  0LL,  "Calling _SecSyncBubbleTransfer(Unregister) for uid %d with array %@",  &v36,  v34);
              unsigned int v26 = (char *)v25;
              if (v25) {
                sub_100053B7C(v25);
              }
            }

            else
            {
              unsigned int v26 = 0LL;
            }

            free(v26);
          }

          if (_SecSyncBubbleTransfer(Value, v4, 0LL))
          {
            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            uint64_t v27 = (os_log_s *)(id)qword_1000DBA98;
            if (!os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_73;
            }
            uint64_t v36 = 0LL;
            unsigned int v28 = sub_100053B4C(1);
            if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v29 = v28;
            }
            else {
              uint64_t v29 = v28 & 0xFFFFFFFE;
            }
            if ((_DWORD)v29)
            {
              LOWORD(v35[0]) = 0;
              LODWORD(v34) = 2;
              uint64_t v30 = (const char *)_os_log_send_and_compose_impl( v29,  &v36,  0LL,  0LL,  &_mh_execute_header,  v27,  0LL,  "_SecSyncBubbleTransfer success",  v35,  v34,  v35[0]);
              goto LABEL_69;
            }
          }

          else
          {
            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            uint64_t v27 = (os_log_s *)(id)qword_1000DBA98;
            if (!os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_73;
            }
            uint64_t v36 = 0LL;
            unsigned int v31 = sub_100053B4C(1);
            if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v32 = v31;
            }
            else {
              uint64_t v32 = v31 & 0xFFFFFFFE;
            }
            if ((_DWORD)v32)
            {
              LOWORD(v35[0]) = 0;
              LODWORD(v34) = 2;
              uint64_t v30 = (const char *)_os_log_send_and_compose_impl( v32,  &v36,  0LL,  0LL,  &_mh_execute_header,  v27,  0LL,  "_SecSyncBubbleTransfer failed",  v35,  v34,  v35[0]);
LABEL_69:
              uint64_t v33 = (char *)v30;
              if (v30) {
                sub_100053B7C(v30);
              }
              goto LABEL_72;
            }
          }

          uint64_t v33 = 0LL;
LABEL_72:
          free(v33);
LABEL_73:

          if (Value) {
            CFRelease(Value);
          }
          return;
        }

        char v11 = 1;
      }

      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v12 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v36 = 0LL;
        unsigned int v13 = sub_100053B4C(1);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v14 = v13;
        }
        else {
          uint64_t v14 = v13 & 0xFFFFFFFE;
        }
        if ((_DWORD)v14)
        {
          LOWORD(v35[0]) = 0;
          uint64_t v15 = (const char *)_os_log_send_and_compose_impl( v14,  &v36,  0LL,  0LL,  &_mh_execute_header,  v12,  0LL,  "NO More MachServices, remove key",  v35,  2);
          uint64_t v16 = (char *)v15;
          if (v15) {
            sub_100053B7C(v15);
          }
        }

        else
        {
          uint64_t v16 = 0LL;
        }

        free(v16);
      }

      if ((v11 & 1) == 0) {
        CFRetain(Value);
      }
      sub_10001D8E8(a1, v4);
      goto LABEL_41;
    }
  }

  else
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v17 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v36 = 0LL;
      unsigned int v18 = sub_100053B4C(1);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v19 = v18;
      }
      else {
        uint64_t v19 = v18 & 0xFFFFFFFE;
      }
      if ((_DWORD)v19)
      {
        LOWORD(v35[0]) = 0;
        unsigned int v20 = (const char *)_os_log_send_and_compose_impl( v19,  &v36,  0LL,  0LL,  &_mh_execute_header,  v17,  0LL,  "NO MachServices Key in Current session",  v35,  2);
        uint64_t v21 = (char *)v20;
        if (v20) {
          sub_100053B7C(v20);
        }
      }

      else
      {
        uint64_t v21 = 0LL;
      }

      free(v21);
    }
  }

void sub_1000352D8(int a1, const __CFString *a2)
{
  id v3 = sub_100054ED0(qword_1000DBA70, a1);
  uint64_t v4 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue(v3);
  if (v4)
  {
    unsigned int v5 = v4;
    sub_100034D5C(v4, a2);
    CFRelease(v5);
  }

void sub_100035328(const void *a1)
{
  uint64_t v2 = (__CFDictionary *)sub_10001A594();
  if (CFDictionaryContainsKey(v2, kUMUserSessionSyncTasksKey))
  {
    CFDictionaryReplaceValue(v2, kUMUserSessionSyncTasksKey, a1);
    if (!v2) {
      return;
    }
    goto LABEL_3;
  }

  CFDictionarySetValue(v2, kUMUserSessionSyncTasksKey, a1);
  if (v2) {
LABEL_3:
  }
    CFRelease(v2);
}

const void *sub_1000353A0()
{
  id v0 = (const __CFDictionary *)sub_10001A594();
  if (!v0) {
    return 0LL;
  }
  uint64_t v1 = v0;
  if (CFDictionaryContainsKey(v0, @"UserSwitchTaskOpqueData")) {
    Value = CFDictionaryGetValue(v1, @"UserSwitchTaskOpqueData");
  }
  else {
    Value = 0LL;
  }
  CFRelease(v1);
  return Value;
}

void sub_100035404()
{
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v0 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)&__int128 v36 = 0LL;
    unsigned int v1 = sub_100053B4C(1);
    if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v2 = v1;
    }
    else {
      uint64_t v2 = v1 & 0xFFFFFFFE;
    }
    if ((_DWORD)v2)
    {
      LOWORD(v37) = 0;
      id v3 = (const char *)_os_log_send_and_compose_impl( v2,  &v36,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "IN startAutoLoadSyncBubbleSessions",  &v37,  2);
      uint64_t v4 = (char *)v3;
      if (v3) {
        sub_100053B7C(v3);
      }
    }

    else
    {
      uint64_t v4 = 0LL;
    }

    free(v4);
  }

  if (sub_10001D3E8())
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v5 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_65;
    }
    *(void *)&__int128 v36 = 0LL;
    unsigned int v6 = sub_100053B4C(1);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v7 = v6;
    }
    else {
      uint64_t v7 = v6 & 0xFFFFFFFE;
    }
    if ((_DWORD)v7)
    {
      LOWORD(v37) = 0;
      LODWORD(v35) = 2;
      uint64_t v34 = &v37;
      uint64_t v8 = " XXXXXXXXXXXXXX BOOTARGS SET TO STOP AUTO BUBBLE LOADS XXXXXXXXXXXXXX";
LABEL_21:
      char v9 = (uint64_t *)&v36;
      goto LABEL_42;
    }

    goto LABEL_63;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  CFTypeID v10 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)&__int128 v36 = 0LL;
    unsigned int v11 = sub_100053B4C(1);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v12 = v11;
    }
    else {
      uint64_t v12 = v11 & 0xFFFFFFFE;
    }
    if ((_DWORD)v12)
    {
      LOWORD(v37) = 0;
      LODWORD(v35) = 2;
      unsigned int v13 = (const char *)_os_log_send_and_compose_impl( v12,  &v36,  0LL,  0LL,  &_mh_execute_header,  v10,  0LL,  "XXXXXXXXXXXXXX SYNC BUBBLE AUTOLOAD ENABLED BY BOOTARGS XXXXXXXXXXXXXX",  &v37,  v35);
      uint64_t v14 = (char *)v13;
      if (v13) {
        sub_100053B7C(v13);
      }
    }

    else
    {
      uint64_t v14 = 0LL;
    }

    free(v14);
  }

  if (qword_1000DBD30)
  {
    if (qword_1000DBAB0 != -1) {
      dispatch_once(&qword_1000DBAB0, &stru_1000CD548);
    }
    unsigned int v5 = (os_log_s *)(id)qword_1000DBAA8;
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_65;
    }
    uint64_t v37 = 0LL;
    unsigned int v15 = sub_100053B4C(0);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v7 = v15;
    }
    else {
      uint64_t v7 = v15 & 0xFFFFFFFE;
    }
    if ((_DWORD)v7)
    {
      LODWORD(v36) = 134217984;
      *(void *)((char *)&v36 + 4) = qword_1000DBD30;
      LODWORD(v35) = 12;
      uint64_t v34 = (uint64_t *)&v36;
      uint64_t v8 = "Sync bubble timer (%p) already running, not starting another";
      char v9 = &v37;
LABEL_42:
      uint64_t v16 = (const char *)_os_log_send_and_compose_impl( v7,  v9,  0LL,  0LL,  &_mh_execute_header,  v5,  0LL,  v8,  v34,  v35,  (void)v36,  *((void *)&v36 + 1),  v37);
      uint64_t v17 = (char *)v16;
      if (v16) {
        sub_100053B7C(v16);
      }
      goto LABEL_64;
    }

    goto LABEL_63;
  }

  if (!qword_1000DBCF8) {
    return;
  }
  if (CFArrayGetCount((CFArrayRef)qword_1000DBCF8) < 1)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v5 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_65;
    }
    *(void *)&__int128 v36 = 0LL;
    unsigned int v24 = sub_100053B4C(1);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v7 = v24;
    }
    else {
      uint64_t v7 = v24 & 0xFFFFFFFE;
    }
    if ((_DWORD)v7)
    {
      LOWORD(v37) = 0;
      LODWORD(v35) = 2;
      uint64_t v34 = &v37;
      uint64_t v8 = "No uids in the bubble to kickstart, returning";
      goto LABEL_21;
    }

LABEL_63:
    uint64_t v17 = 0LL;
LABEL_64:
    free(v17);
LABEL_65:

    return;
  }

  int v18 = sub_10001D48C();
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v19 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)&__int128 v36 = 0LL;
    unsigned int v20 = sub_100053B4C(1);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v21 = v20;
    }
    else {
      uint64_t v21 = v20 & 0xFFFFFFFE;
    }
    if ((_DWORD)v21)
    {
      LODWORD(v37) = 67109120;
      HIDWORD(v37) = v18;
      uint64_t v22 = (const char *)_os_log_send_and_compose_impl( v21,  &v36,  0LL,  0LL,  &_mh_execute_header,  v19,  0LL,  "XXXXXXXXXXXXXX Kickstart after %d seconds XXXXXXXXXXXXXX",  &v37);
      unsigned int v23 = (char *)v22;
      if (v22) {
        sub_100053B7C(v22);
      }
    }

    else
    {
      unsigned int v23 = 0LL;
    }

    free(v23);
  }

  dispatch_source_t v25 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0LL,  0LL,  (dispatch_queue_t)qword_1000DBD48);
  unsigned int v26 = (void *)qword_1000DBD30;
  qword_1000DBD30 = (uint64_t)v25;

  if (qword_1000DBAB0 != -1) {
    dispatch_once(&qword_1000DBAB0, &stru_1000CD548);
  }
  uint64_t v27 = (os_log_s *)(id)qword_1000DBAA8;
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v37 = 0LL;
    unsigned int v28 = sub_100053B4C(0);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v29 = v28;
    }
    else {
      uint64_t v29 = v28 & 0xFFFFFFFE;
    }
    if ((_DWORD)v29)
    {
      LODWORD(v36) = 134217984;
      *(void *)((char *)&v36 + 4) = qword_1000DBD30;
      uint64_t v30 = (const char *)_os_log_send_and_compose_impl( v29,  &v37,  0LL,  0LL,  &_mh_execute_header,  v27,  0LL,  "Starting sync bubble timer (%p)",  &v36);
      unsigned int v31 = (char *)v30;
      if (v30) {
        sub_100053B7C(v30);
      }
    }

    else
    {
      unsigned int v31 = 0LL;
    }

    free(v31);
  }

  uint64_t v32 = (dispatch_source_s *)qword_1000DBD30;
  dispatch_time_t v33 = dispatch_time(0LL, 1000000000LL * v18);
  dispatch_source_set_timer(v32, v33, 0xFFFFFFFFFFFFFFFFLL, 0LL);
  dispatch_source_set_event_handler((dispatch_source_t)qword_1000DBD30, &stru_1000CD478);
  dispatch_activate((dispatch_object_t)qword_1000DBD30);
}
}

void sub_100035A50(id a1)
{
  if (qword_1000DBAB0 != -1) {
    dispatch_once(&qword_1000DBAB0, &stru_1000CD548);
  }
  unsigned int v1 = (os_log_s *)(id)qword_1000DBAA8;
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = 0LL;
    unsigned int v2 = sub_100053B4C(0);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v3 = v2;
    }
    else {
      uint64_t v3 = v2 & 0xFFFFFFFE;
    }
    if ((_DWORD)v3)
    {
      int v8 = 134217984;
      uint64_t v9 = qword_1000DBD30;
      uint64_t v4 = (const char *)_os_log_send_and_compose_impl( v3,  &v7,  0LL,  0LL,  &_mh_execute_header,  v1,  0LL,  "Sync bubble timer (%p) fired",  &v8);
      unsigned int v5 = (char *)v4;
      if (v4) {
        sub_100053B7C(v4);
      }
    }

    else
    {
      unsigned int v5 = 0LL;
    }

    free(v5);
  }

  dispatch_source_cancel((dispatch_source_t)qword_1000DBD30);
  unsigned int v6 = (void *)qword_1000DBD30;
  qword_1000DBD30 = 0LL;

  sub_100035BA0();
}

void sub_100035BA0()
{
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v0 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v53 = 0LL;
    unsigned int v1 = sub_100053B4C(1);
    if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v2 = v1;
    }
    else {
      uint64_t v2 = v1 & 0xFFFFFFFE;
    }
    if ((_DWORD)v2)
    {
      LOWORD(valuePtr) = 0;
      uint64_t v3 = (const char *)_os_log_send_and_compose_impl( v2,  &v53,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "XXXXXXXXXXXXXX Kickstarting the bubble session  XXXXXXXXXXXXXX",  &valuePtr,  2);
      uint64_t v4 = (char *)v3;
      if (v3) {
        sub_100053B7C(v3);
      }
    }

    else
    {
      uint64_t v4 = 0LL;
    }

    free(v4);
  }

  unsigned int valuePtr = -1;
  if (sub_10001D3E8())
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v5 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_73;
    }
    uint64_t v53 = 0LL;
    unsigned int v6 = sub_100053B4C(1);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v7 = v6;
    }
    else {
      uint64_t v7 = v6 & 0xFFFFFFFE;
    }
    if ((_DWORD)v7)
    {
      LOWORD(v51[0]) = 0;
      LODWORD(v50) = 2;
      int v8 = (const char *)_os_log_send_and_compose_impl( v7,  &v53,  0LL,  0LL,  &_mh_execute_header,  v5,  0LL,  " XXXXXXXXXXXXXX BOOTARGS SET TO STOP AUTO BUBBLE LOAD XXXXXXXXXXXXXX",  v51,  v50,  v51[0]);
      goto LABEL_21;
    }

LABEL_71:
    uint64_t v9 = 0LL;
LABEL_72:
    free(v9);
LABEL_73:

    return;
  }

  if (!qword_1000DBCF8)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v5 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_73;
    }
    uint64_t v53 = 0LL;
    unsigned int v14 = sub_100053B4C(1);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v15 = v14;
    }
    else {
      uint64_t v15 = v14 & 0xFFFFFFFE;
    }
    if (!(_DWORD)v15) {
      goto LABEL_71;
    }
    LOWORD(v51[0]) = 0;
    LODWORD(v50) = 2;
    int v8 = (const char *)_os_log_send_and_compose_impl( v15,  &v53,  0LL,  0LL,  &_mh_execute_header,  v5,  0LL,  "Returning, no Users list for bubble empty",  v51,  v50,  v51[0]);
LABEL_21:
    uint64_t v9 = (char *)v8;
    if (v8) {
      sub_100053B7C(v8);
    }
    goto LABEL_72;
  }

  if (!CFArrayGetCount((CFArrayRef)qword_1000DBCF8))
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v5 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_73;
    }
    uint64_t v53 = 0LL;
    unsigned int v16 = sub_100053B4C(1);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v17 = v16;
    }
    else {
      uint64_t v17 = v16 & 0xFFFFFFFE;
    }
    if (!(_DWORD)v17) {
      goto LABEL_71;
    }
    LOWORD(v51[0]) = 0;
    LODWORD(v50) = 2;
    int v8 = (const char *)_os_log_send_and_compose_impl( v17,  &v53,  0LL,  0LL,  &_mh_execute_header,  v5,  0LL,  "Returning, no Users listed for sync bubble",  v51,  v50,  v51[0]);
    goto LABEL_21;
  }

  CFTypeID v10 = (void *)objc_claimAutoreleasedReturnValue(+[RDServer sharedServer](&OBJC_CLASS___RDServer, "sharedServer"));
  unsigned int v11 = [v10 anyBubblePopClients];

  if (v11)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v5 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_73;
    }
    uint64_t v53 = 0LL;
    unsigned int v12 = sub_100053B4C(1);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v13 = v12;
    }
    else {
      uint64_t v13 = v12 & 0xFFFFFFFE;
    }
    if (!(_DWORD)v13) {
      goto LABEL_71;
    }
    LOWORD(v51[0]) = 0;
    LODWORD(v50) = 2;
    int v8 = (const char *)_os_log_send_and_compose_impl( v13,  &v53,  0LL,  0LL,  &_mh_execute_header,  v5,  0LL,  "Returning, sync bubble blocked by bubblepop holders",  v51,  v50,  v51[0]);
    goto LABEL_21;
  }

  int v18 = (void *)objc_claimAutoreleasedReturnValue(+[RDServer sharedServer](&OBJC_CLASS___RDServer, "sharedServer"));
  unsigned int v19 = [v18 inLogoutProcess];

  if (v19)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v5 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_73;
    }
    uint64_t v53 = 0LL;
    unsigned int v20 = sub_100053B4C(1);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v21 = v20;
    }
    else {
      uint64_t v21 = v20 & 0xFFFFFFFE;
    }
    if (!(_DWORD)v21) {
      goto LABEL_71;
    }
    LOWORD(v51[0]) = 0;
    LODWORD(v50) = 2;
    int v8 = (const char *)_os_log_send_and_compose_impl( v21,  &v53,  0LL,  0LL,  &_mh_execute_header,  v5,  0LL,  "Returning, sync bubble blocked by logout process",  v51,  v50,  v51[0]);
    goto LABEL_21;
  }

  uint64_t v22 = sub_100018E80(qword_1000DBD40);
  unsigned int v23 = (void *)objc_claimAutoreleasedReturnValue(v22);
  if (!sub_100019ADC((uint64_t)v23))
  {
    int v26 = dword_1000DBCF0;

    if (v26 != 1) {
      goto LABEL_76;
    }
    goto LABEL_63;
  }

  uint64_t v24 = sub_100018E80(qword_1000DBD40);
  dispatch_source_t v25 = (void *)objc_claimAutoreleasedReturnValue(v24);
  if (sub_100019B60((uint64_t)v25) == 502)
  {

    goto LABEL_76;
  }

  int v29 = dword_1000DBCF0;

  if (v29 == 1)
  {
LABEL_63:
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v5 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_73;
    }
    uint64_t v53 = 0LL;
    unsigned int v27 = sub_100053B4C(1);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v28 = v27;
    }
    else {
      uint64_t v28 = v27 & 0xFFFFFFFE;
    }
    if (!(_DWORD)v28) {
      goto LABEL_71;
    }
    LOWORD(v51[0]) = 0;
    LODWORD(v50) = 2;
    int v8 = (const char *)_os_log_send_and_compose_impl( v28,  &v53,  0LL,  0LL,  &_mh_execute_header,  v5,  0LL,  "Returning, sync bubble blocked by isLoginSession in User Context",  v51,  v50,  v51[0]);
    goto LABEL_21;
  }

      sub_100053B7C((const char *)v40);
      goto LABEL_73;
    }

    goto LABEL_72;
  }

  unsigned int v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
  uint64_t v52 = 0u;
  uint64_t v53 = 0u;
  unsigned int v54 = 0u;
  uint64_t v55 = 0u;
  obj = v12;
  uint64_t v15 = -[os_log_s countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v52,  v57,  16LL);
  if (!v15) {
    goto LABEL_17;
  }
  unsigned int v16 = v15;
  uint64_t v17 = *(void *)v53;
  while (2)
  {
    for (CFIndex i = 0LL; i != v16; CFIndex i = (char *)i + 1)
    {
      if (*(void *)v53 != v17) {
        objc_enumerationMutation(obj);
      }
      unsigned int v19 = *(void **)(*((void *)&v52 + 1) + 8LL * (void)i);
      unsigned int v20 = objc_opt_class(&OBJC_CLASS___NSDictionary);
      if ((objc_opt_isKindOfClass(v19, v20) & 1) == 0)
      {
        if (qword_1000DBBC8 != -1) {
          dispatch_once(&qword_1000DBBC8, &stru_1000CDB00);
        }
        uint64_t v24 = v14;
        unsigned int v43 = (os_log_s *)(id)qword_1000DBBC0;
        if (!os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
          goto LABEL_94;
        }
        *(void *)unsigned int v58 = 0LL;
        uint64_t v44 = sub_100053B4C(0);
        if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
          uint64_t v45 = v44;
        }
        else {
          uint64_t v45 = v44 & 0xFFFFFFFE;
        }
        if ((_DWORD)v45)
        {
          LOWORD(v56[0]) = 0;
          unsigned int v46 = (const char *)_os_log_send_and_compose_impl( v45,  v58,  0LL,  0LL,  &_mh_execute_header,  v43,  16LL,  "Failed to parse persona manifest persona list: persona is invalid",  v56,  2);
          goto LABEL_90;
        }

        uint64_t v22 = 0LL;
        goto LABEL_72;
      }

      if (v46)
      {
        if (qword_1000DBBD8 != -1) {
          dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
        }
        int v18 = (os_log_s *)(id)qword_1000DBBD0;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)uint64_t v47 = 0LL;
          int v29 = sub_100053B4C(1);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
            int v30 = v29;
          }
          else {
            int v30 = v29 & 0xFFFFFFFE;
          }
          if ((_DWORD)v30)
          {
            LOWORD(v44) = 0;
            LODWORD(v43) = 2;
            unsigned int v31 = (const char *)_os_log_send_and_compose_impl( v30,  v47,  0LL,  0LL,  &_mh_execute_header,  v18,  0LL,  "System Data Volume needs Migration",  &v44,  v43);
            uint64_t v32 = (char *)v31;
            if (v31) {
              sub_100053B7C(v31);
            }
          }

          else
          {
            uint64_t v32 = 0LL;
          }

          free(v32);
        }

        unsigned int v23 = 1LL;
        goto LABEL_74;
      }

      if (a4) {
        *a4 = 0;
      }
      if (qword_1000DBBD8 != -1) {
        dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
      }
      int v18 = (os_log_s *)(id)qword_1000DBBD0;
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
LABEL_73:
        unsigned int v23 = 0LL;
LABEL_74:

        if (a3) {
          *a3 = v45;
        }
        return v23;
      }

      uint64_t v44 = 0LL;
      dispatch_time_t v33 = sub_100053B4C(1);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
        CFTypeID v34 = v33;
      }
      else {
        CFTypeID v34 = v33 & 0xFFFFFFFE;
      }
      if (!(_DWORD)v34) {
        goto LABEL_71;
      }
      *(_DWORD *)uint64_t v47 = 136315138;
      *(void *)&v47[4] = a1;
      uint64_t v21 = _os_log_send_and_compose_impl( v34,  &v44,  0LL,  0LL,  &_mh_execute_header,  v18,  0LL,  "%s Volume does not need Migration",  v47);
    }

    else
    {
      if (qword_1000DBBD8 != -1) {
        dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
      }
      int v18 = (os_log_s *)(id)qword_1000DBBD0;
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_73;
      }
      *(void *)uint64_t v47 = 0LL;
      unsigned int v19 = sub_100053B4C(1);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
        unsigned int v20 = v19;
      }
      else {
        unsigned int v20 = v19 & 0xFFFFFFFE;
      }
      if (!(_DWORD)v20) {
        goto LABEL_71;
      }
      uint64_t v21 = _os_log_send_and_compose_impl( v20,  v47,  0LL,  0LL,  &_mh_execute_header,  v18,  0LL,  "UnEncrypted Disk, does not need migration");
    }

    uint64_t v22 = (void *)v21;
    if (!v21) {
      goto LABEL_72;
    }
    goto LABEL_50;
  }

  if (a4) {
    *a4 = 2;
  }
  if (a2 != 2)
  {
    if (qword_1000DBBD8 != -1) {
      goto LABEL_90;
    }
    while (1)
    {
      unsigned int v36 = (os_log_s *)(id)qword_1000DBBD0;
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)uint64_t v47 = 0LL;
        uint64_t v37 = sub_100053B4C(1);
        uint64_t v38 = os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT);
        uint64_t v39 = 0LL;
        if (v38) {
          int v40 = v37;
        }
        else {
          int v40 = v37 & 0xFFFFFFFE;
        }
        if ((_DWORD)v40)
        {
          LOWORD(v44) = 0;
          LODWORD(v43) = 2;
          unsigned int v41 = (const char *)_os_log_send_and_compose_impl( v40,  v47,  0LL,  0LL,  &_mh_execute_header,  v36,  0LL,  "FAILED TO FIND DISKNODE",  &v44,  v43);
          uint64_t v39 = 0LL;
          if (v41)
          {
            uint64_t v42 = v41;
            sub_100053B7C(v41);
            uint64_t v39 = (char *)v42;
          }
        }

        free(v39);
      }

      sub_100019F7C("FAILED TO FIND DISKNODE");
LABEL_90:
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
  }

  if (qword_1000DBBD8 != -1) {
    dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
  }
  uint64_t v13 = (os_log_s *)(id)qword_1000DBBD0;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t v47 = 0LL;
    unsigned int v14 = sub_100053B4C(1);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v15 = v14;
    }
    else {
      uint64_t v15 = v14 & 0xFFFFFFFE;
    }
    if ((_DWORD)v15)
    {
      LOWORD(v44) = 0;
      unsigned int v16 = (const char *)_os_log_send_and_compose_impl( v15,  v47,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "FAILED TO FIND DISKNODE for USER VOLUME, may be shared iPad, skipping..",  &v44,  2);
      uint64_t v17 = (char *)v16;
      if (v16) {
        sub_100053B7C(v16);
      }
    }

    else
    {
      uint64_t v17 = 0LL;
    }

    free(v17);
  }

  return 0LL;
}

void sub_10003641C()
{
  dword_1000DACBC = -1;
}

__CFDictionary *sub_100036430(const __CFDictionary *a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v2 = sub_10008428C();
  Value = CFDictionaryGetValue(a1, kUMUserSessionIDKey);
  CFDictionarySetValue(v2, kUMUserSessionIDKey, Value);
  uint64_t v4 = CFDictionaryGetValue(a1, kUMUserSessionGroupIDKey);
  CFDictionarySetValue(v2, kUMUserSessionGroupIDKey, v4);
  if (!CFDictionaryContainsKey(a1, kUMUserSessionLibinfoHomeDirKey))
  {
    sub_100083C6C(a1, kUMUserSessionIDKey);
    bzero(__str, 0x400uLL);
    if (dword_1000DBCE8 == 1) {
      snprintf(__str, 0x400uLL, "/var/euser%d");
    }
    else {
      snprintf(__str, 0x400uLL, "/var/user%d");
    }
    CFStringRef v5 = CFStringCreateWithCString(0LL, __str, 0x8000100u);
    CFDictionarySetValue(a1, kUMUserSessionLibinfoHomeDirKey, v5);
    if (v5) {
      CFRelease(v5);
    }
  }

  unsigned int v6 = CFDictionaryGetValue(a1, kUMUserSessionLibinfoHomeDirKey);
  CFDictionarySetValue(v2, kUMUserSessionLibinfoHomeDirKey, v6);
  uint64_t v7 = CFDictionaryGetValue(a1, kUMUserSessionShortNameKey);
  CFDictionarySetValue(v2, kUMUserSessionShortNameKey, v7);
  return v2;
}

uint64_t sub_1000365D8(const __CFDictionary *a1, void *a2, int a3)
{
  id v5 = a2;
  if (a1)
  {
    int v6 = sub_100083C6C(a1, kUMUserSessionIDKey);
    int v7 = sub_100083C6C(a1, kUMUserSessionGroupIDKey);
    xpc_dictionary_set_int64(v5, "pw_uid", v6);
    xpc_dictionary_set_int64(v5, "pw_gid", v7);
    bzero(string, 0x400uLL);
    sub_100083E34(a1, kUMUserSessionLibinfoHomeDirKey, string, 1024);
    xpc_dictionary_set_string(v5, "pw_dir", string);
    bzero(string, 0x400uLL);
    sub_100083E34(a1, kUMUserSessionShortNameKey, string, 255);
    xpc_dictionary_set_string(v5, "pw_name", string);
    xpc_dictionary_set_string(v5, "pw_shell", "/bin/bash");
    if (a3) {
      int v8 = "/smx7MYTQIi2M";
    }
    else {
      int v8 = "*";
    }
    xpc_dictionary_set_string(v5, "pw_passwd", v8);
    uint64_t v9 = 1LL;
  }

  else
  {
    uint64_t v9 = 0LL;
  }

  return v9;
}

uint64_t sub_10003676C(uint64_t result, void *a2)
{
  if (result)
  {
    uint64_t v2 = (const __CFDictionary *)result;
    uint64_t v3 = kUMUserSessionGroupIDKey;
    id v4 = a2;
    int v5 = sub_100083C6C(v2, v3);
    xpc_dictionary_set_int64(v4, "gr_gid", v5);
    bzero(string, 0x400uLL);
    sub_100083E34(v2, kUMUserSessionShortNameKey, string, 255);
    xpc_dictionary_set_string(v4, "gr_name", string);
    xpc_object_t v6 = xpc_array_create(0LL, 0LL);
    xpc_array_set_string(v6, 0xFFFFFFFFFFFFFFFFLL, string);
    xpc_dictionary_set_value(v4, "gr_members", v6);

    return 1LL;
  }

  return result;
}

uint64_t sub_100036874(uint64_t a1)
{
  uint64_t v4 = 0LL;
  int v5 = &v4;
  uint64_t v6 = 0x2020000000LL;
  char v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  v3[2] = sub_10003690C;
  v3[3] = &unk_1000CD4A0;
  void v3[4] = &v4;
  void v3[5] = a1;
  dispatch_sync((dispatch_queue_t)qword_1000DBD50, v3);
  uint64_t v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_10003690C(uint64_t a1)
{
  uint64_t v2 = (__CFArray *)qword_1000DBD08;
  if (!qword_1000DBD08)
  {
    uint64_t v2 = sub_100084320();
    qword_1000DBD08 = (uint64_t)v2;
  }

  CFArrayAppendValue(v2, *(const void **)(a1 + 40));
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
}

uint64_t sub_100036954(int a1)
{
  uint64_t v5 = 0LL;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2020000000LL;
  char v8 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  v3[2] = sub_1000369F0;
  v3[3] = &unk_1000CD458;
  int v4 = a1;
  void v3[4] = &v5;
  dispatch_sync((dispatch_queue_t)qword_1000DBD50, v3);
  uint64_t v1 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v1;
}

void sub_1000369F0(uint64_t a1)
{
  int valuePtr = 0;
  if (qword_1000DBD08 && CFArrayGetCount((CFArrayRef)qword_1000DBD08) >= 1)
  {
    CFIndex v2 = 0LL;
    while (1)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)qword_1000DBD08, v2);
      if (!ValueAtIndex) {
        break;
      }
      int v4 = ValueAtIndex;
      CFTypeID v5 = CFGetTypeID(ValueAtIndex);
      if (v5 != CFDictionaryGetTypeID()) {
        break;
      }
      Value = (const __CFNumber *)CFDictionaryGetValue(v4, kUMUserSessionIDKey);
      if (!Value
        || (uint64_t v7 = Value, v8 = CFGetTypeID(Value), v8 != CFNumberGetTypeID())
        || !CFNumberGetValue(v7, kCFNumberIntType, &valuePtr))
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        uint64_t v9 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v16 = 0LL;
          unsigned int v13 = sub_100053B4C(1);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v14 = v13;
          }
          else {
            uint64_t v14 = v13 & 0xFFFFFFFE;
          }
          if ((_DWORD)v14)
          {
            v18[0] = 67109120;
            v18[1] = v2;
            unsigned int v12 = (const char *)_os_log_send_and_compose_impl( v14,  &v16,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "Found problem with conversion with index %d",  v18);
            goto LABEL_27;
          }

LABEL_29:
          uint64_t v15 = 0LL;
          goto LABEL_30;
        }

        goto LABEL_31;
      }

      if (valuePtr == *(_DWORD *)(a1 + 40))
      {
        CFArrayRemoveValueAtIndex((CFMutableArrayRef)qword_1000DBD08, v2);
        *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
        return;
      }

            uint64_t v15 = 0LL;
            goto LABEL_30;
          }

          goto LABEL_31;
        }

        if (valuePtr == a1) {
          return CFRetain(v4);
        }
LABEL_32:
        if (CFArrayGetCount((CFArrayRef)qword_1000DBD08) <= ++v2) {
          return 0LL;
        }
      }

      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v9 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v17 = 0LL;
        unsigned int v10 = sub_100053B4C(1);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v11 = v10;
        }
        else {
          uint64_t v11 = v10 & 0xFFFFFFFE;
        }
        if (!(_DWORD)v11) {
          goto LABEL_29;
        }
        LOWORD(v19[0]) = 0;
        unsigned int v12 = (const char *)_os_log_send_and_compose_impl( v11,  &v17,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "got NULL dictionary");
LABEL_27:
        uint64_t v15 = (char *)v12;
        if (v12) {
          sub_100053B7C(v12);
        }
LABEL_30:
        free(v15);
      }
}

CFTypeRef sub_100036CB8(int a1)
{
  CFTypeRef result = (CFTypeRef)qword_1000DBD08;
  if (qword_1000DBD08)
  {
    if (CFArrayGetCount((CFArrayRef)qword_1000DBD08) >= 1)
    {
      CFIndex v2 = 0LL;
      while (1)
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)qword_1000DBD08, v2);
        if (!ValueAtIndex) {
          break;
        }
        int v4 = ValueAtIndex;
        CFTypeID v5 = CFGetTypeID(ValueAtIndex);
        if (v5 != CFDictionaryGetTypeID()) {
          break;
        }
        Value = (const __CFNumber *)CFDictionaryGetValue(v4, kUMUserSessionIDKey);
        if (!Value
          || (uint64_t v7 = Value, v8 = CFGetTypeID(Value), v8 != CFNumberGetTypeID())
          || !CFNumberGetValue(v7, kCFNumberIntType, &valuePtr))
        {
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          uint64_t v9 = (os_log_s *)(id)qword_1000DBA98;
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v17 = 0LL;
            unsigned int v13 = sub_100053B4C(1);
            if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v14 = v13;
            }
            else {
              uint64_t v14 = v13 & 0xFFFFFFFE;
            }
            if ((_DWORD)v14)
            {
              v19[0] = 67109120;
              v19[1] = v2;
              unsigned int v12 = (const char *)_os_log_send_and_compose_impl( v14,  &v17,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "Found problem with conversion with index %d",  v19);
              goto LABEL_27;
            }

CFTypeRef sub_100036F70(const __CFString *a1)
{
  if (!qword_1000DBD08 || CFArrayGetCount((CFArrayRef)qword_1000DBD08) < 1) {
    return 0LL;
  }
  CFIndex v2 = 0LL;
  while (1)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)qword_1000DBD08, v2);
    if (ValueAtIndex)
    {
      int v4 = ValueAtIndex;
      CFTypeID v5 = CFGetTypeID(ValueAtIndex);
      if (v5 == CFDictionaryGetTypeID())
      {
        Value = (const __CFString *)CFDictionaryGetValue(v4, kUMUserSessionShortNameKey);
        if (Value)
        {
          uint64_t v7 = Value;
          CFTypeID v8 = CFGetTypeID(Value);
          if (v8 == CFStringGetTypeID() && CFStringCompare(v7, a1, 0LL) == kCFCompareEqualTo) {
            break;
          }
        }
      }
    }

    if (CFArrayGetCount((CFArrayRef)qword_1000DBD08) <= ++v2) {
      return 0LL;
    }
  }

  return CFRetain(v4);
}

void sub_100037060(void *a1)
{
  xpc_object_t xarray = a1;
  if (qword_1000DBD08 && CFArrayGetCount((CFArrayRef)qword_1000DBD08) >= 1)
  {
    CFIndex v1 = 0LL;
    do
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)qword_1000DBD08, v1);
      if (ValueAtIndex)
      {
        uint64_t v3 = ValueAtIndex;
        CFTypeID v4 = CFGetTypeID(ValueAtIndex);
        if (v4 == CFDictionaryGetTypeID())
        {
          int v5 = sub_100083C6C(v3, kUMUserSessionGroupIDKey);
          if (v5 != -1) {
            xpc_array_set_int64(xarray, 0xFFFFFFFFFFFFFFFFLL, v5);
          }
        }
      }

      ++v1;
    }

    while (CFArrayGetCount((CFArrayRef)qword_1000DBD08) > v1);
  }
}

uint64_t sub_100037120(void *a1)
{
  id v1 = a1;
  strcpy(string, "systemusers");
  xpc_dictionary_set_int64(v1, "gr_gid", 299LL);
  xpc_dictionary_set_string(v1, "gr_name", string);
  xpc_object_t v2 = xpc_array_create(0LL, 0LL);
  xpc_array_set_string(v2, 0xFFFFFFFFFFFFFFFFLL, aMobile_1);
  xpc_array_set_string(v2, 0xFFFFFFFFFFFFFFFFLL, aIfccd);
  xpc_array_set_string(v2, 0xFFFFFFFFFFFFFFFFLL, aNetworkd_1);
  xpc_array_set_string(v2, 0xFFFFFFFFFFFFFFFFLL, aWireless_1);
  xpc_array_set_string(v2, 0xFFFFFFFFFFFFFFFFLL, aInstalld_0);
  xpc_array_set_string(v2, 0xFFFFFFFFFFFFFFFFLL, aSecurityd_0);
  xpc_array_set_string(v2, 0xFFFFFFFFFFFFFFFFLL, aReportmemoryex);
  xpc_array_set_string(v2, 0xFFFFFFFFFFFFFFFFLL, aAnalyticsd);
  xpc_array_set_string(v2, 0xFFFFFFFFFFFFFFFFLL, aTimed);
  if (qword_1000DBD08 && CFArrayGetCount((CFArrayRef)qword_1000DBD08) >= 1)
  {
    CFIndex v3 = 0LL;
    do
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)qword_1000DBD08, v3);
      if (ValueAtIndex)
      {
        int v5 = ValueAtIndex;
        CFTypeID v6 = CFGetTypeID(ValueAtIndex);
        if (v6 == CFDictionaryGetTypeID())
        {
          bzero(v8, 0x400uLL);
          sub_100083E34(v5, kUMUserSessionShortNameKey, v8, 1024);
          xpc_array_set_string(v2, 0xFFFFFFFFFFFFFFFFLL, v8);
        }
      }

      ++v3;
    }

    while (CFArrayGetCount((CFArrayRef)qword_1000DBD08) > v3);
  }

  xpc_dictionary_set_value(v1, "gr_members", v2);

  return 1LL;
}

uint64_t sub_10003733C(void *a1)
{
  id v1 = a1;
  strcpy(string, "_analyticsusers");
  xpc_dictionary_set_int64(v1, "gr_gid", 250LL);
  xpc_dictionary_set_string(v1, "gr_name", string);
  xpc_object_t v2 = xpc_array_create(0LL, 0LL);
  xpc_array_set_string(v2, 0xFFFFFFFFFFFFFFFFLL, aMobile_1);
  xpc_array_set_string(v2, 0xFFFFFFFFFFFFFFFFLL, aAnalyticsd);
  xpc_array_set_string(v2, 0xFFFFFFFFFFFFFFFFLL, aWireless_1);
  xpc_array_set_string(v2, 0xFFFFFFFFFFFFFFFFLL, aNetworkd_1);
  xpc_array_set_string(v2, 0xFFFFFFFFFFFFFFFFLL, aTimed);
  xpc_array_set_string(v2, 0xFFFFFFFFFFFFFFFFLL, aGpsd);
  xpc_array_set_string(v2, 0xFFFFFFFFFFFFFFFFLL, aReportmemoryex);
  xpc_array_set_string(v2, 0xFFFFFFFFFFFFFFFFLL, aSecurityd_0);
  xpc_array_set_string(v2, 0xFFFFFFFFFFFFFFFFLL, aNearbyd);
  if (qword_1000DBD08 && CFArrayGetCount((CFArrayRef)qword_1000DBD08) >= 1)
  {
    CFIndex v3 = 0LL;
    do
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)qword_1000DBD08, v3);
      if (ValueAtIndex)
      {
        int v5 = ValueAtIndex;
        CFTypeID v6 = CFGetTypeID(ValueAtIndex);
        if (v6 == CFDictionaryGetTypeID())
        {
          bzero(v8, 0x400uLL);
          sub_100083E34(v5, kUMUserSessionShortNameKey, v8, 1024);
          xpc_array_set_string(v2, 0xFFFFFFFFFFFFFFFFLL, v8);
        }
      }

      ++v3;
    }

    while (CFArrayGetCount((CFArrayRef)qword_1000DBD08) > v3);
  }

  xpc_dictionary_set_value(v1, "gr_members", v2);

  return 1LL;
}

void sub_10003754C()
{
  xpc_connection_t mach_service = xpc_connection_create_mach_service( "com.apple.system.libinfo.muser",  (dispatch_queue_t)qword_1000DBD50,  1uLL);
  id v1 = (void *)qword_1000DBA90;
  qword_1000DBA90 = (uint64_t)mach_service;

  __xpc_connection_set_logging(qword_1000DBA90, 0LL);
  xpc_connection_set_event_handler((xpc_connection_t)qword_1000DBA90, &stru_1000CD4E0);
  xpc_connection_resume((xpc_connection_t)qword_1000DBA90);
}

void sub_1000375B0(id a1, OS_xpc_object *a2)
{
  xpc_object_t v2 = a2;
  __xpc_connection_set_logging(v2, 0LL);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472LL;
  handler[2] = sub_100037634;
  handler[3] = &unk_1000CD508;
  int v5 = v2;
  CFIndex v3 = v2;
  xpc_connection_set_event_handler(v3, handler);
  xpc_connection_resume(v3);
}

void sub_100037634(uint64_t a1, void *a2)
{
  xpc_object_t object = a2;
  CFIndex v3 = xpc_copy_description(object);
  free(v3);
  if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_error)
  {
    xpc_object_t reply = xpc_dictionary_create_reply(object);
    string = xpc_dictionary_get_string(object, "reqtype");
    if (!strcmp(string, "username"))
    {
      CFTypeID v8 = xpc_dictionary_get_string(object, "query");
      if (!strcmp(v8, "mobile"))
      {
        int v22 = dword_1000DBCE8;
        uint64_t v23 = sub_100018E80(qword_1000DBD40);
        uint64_t v24 = objc_claimAutoreleasedReturnValue(v23);
        dispatch_source_t v25 = (void *)v24;
        if (v22 == 2)
        {
          int v26 = sub_100019B60(v24);
        }

        else if (sub_100019ADC(v24))
        {
          uint64_t v29 = sub_100018E80(qword_1000DBD40);
          int v30 = (void *)objc_claimAutoreleasedReturnValue(v29);
          int v26 = sub_100019B60((uint64_t)v30);
        }

        else
        {
          int v26 = -1;
        }

        if (v26 == -1) {
          goto LABEL_52;
        }
        unsigned int v10 = (const __CFDictionary *)sub_100036CB8(v26);
        if (!v10) {
          goto LABEL_52;
        }
      }

      else
      {
        uint64_t v9 = CFStringCreateWithCString(kCFAllocatorDefault, v8, 0x8000100u);
        unsigned int v10 = (const __CFDictionary *)sub_100036F70(v9);
        if (v9) {
          CFRelease(v9);
        }
        if (!v10) {
          goto LABEL_52;
        }
      }
    }

    else
    {
      if (strcmp(string, "uid"))
      {
        if (!strcmp(string, "gid"))
        {
          int int64 = xpc_dictionary_get_int64(object, "query");
          int v17 = int64;
          if (int64 == 250)
          {
            sub_10003733C(reply);
            goto LABEL_52;
          }

          if (int64 != 299)
          {
            if (int64 == 501)
            {
              int v18 = dword_1000DBCE8;
              uint64_t v19 = sub_100018E80(qword_1000DBD40);
              uint64_t v20 = objc_claimAutoreleasedReturnValue(v19);
              uint64_t v21 = (void *)v20;
              if (v18 == 2)
              {
                int v17 = sub_100019B60(v20);
              }

              else if (sub_100019ADC(v20))
              {
                uint64_t v45 = sub_100018E80(qword_1000DBD40);
                unsigned int v46 = (void *)objc_claimAutoreleasedReturnValue(v45);
                int v17 = sub_100019B60((uint64_t)v46);
              }

              else
              {
                int v17 = -1;
              }
            }

            if (v17 == -1) {
              goto LABEL_52;
            }
            unsigned int v49 = (const __CFDictionary *)sub_100036CB8(v17);
            if (!v49) {
              goto LABEL_52;
            }
            unsigned int v10 = v49;
LABEL_67:
            sub_10003676C((uint64_t)v10, reply);
            goto LABEL_51;
          }
        }

        else
        {
          if (strcmp(string, "groupname"))
          {
            if (!strcmp(string, "grouplist"))
            {
              dispatch_time_t v33 = xpc_dictionary_get_string(object, "query");
              if (v33)
              {
                CFTypeID v34 = CFStringCreateWithCString(kCFAllocatorDefault, v33, 0x8000100u);
                uint64_t v35 = (const __CFDictionary *)sub_100036F70(v34);
                if (v34) {
                  CFRelease(v34);
                }
                if (v35)
                {
                  int v36 = sub_100083C6C(v35, kUMUserSessionGroupIDKey);
                  xpc_object_t v37 = xpc_array_create(0LL, 0LL);
                  xpc_array_set_int64(v37, 0xFFFFFFFFFFFFFFFFLL, v36);
                  xpc_array_set_int64(v37, 0xFFFFFFFFFFFFFFFFLL, 250LL);
                  xpc_array_set_int64(v37, 0xFFFFFFFFFFFFFFFFLL, 299LL);
                  xpc_dictionary_set_value(reply, "grouplist", v37);
                  CFRelease(v35);
                }
              }
            }

            else if (!strcmp(string, "available"))
            {
              uint64_t v6 = sub_100018E80(qword_1000DBD40);
              uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
              sub_100019ADC((uint64_t)v7);

              xpc_dictionary_set_BOOL(reply, "available", 1);
            }

            goto LABEL_52;
          }

          unsigned int v27 = xpc_dictionary_get_string(object, "query");
          if (!strcmp(v27, "mobile"))
          {
            int v38 = dword_1000DBCE8;
            uint64_t v39 = sub_100018E80(qword_1000DBD40);
            uint64_t v40 = objc_claimAutoreleasedReturnValue(v39);
            unsigned int v41 = (void *)v40;
            if (v38 == 2)
            {
              int v42 = sub_100019B60(v40);
            }

            else if (sub_100019ADC(v40))
            {
              uint64_t v47 = sub_100018E80(qword_1000DBD40);
              uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue(v47);
              int v42 = sub_100019B60((uint64_t)v48);
            }

            else
            {
              int v42 = -1;
            }

            if (v42 == -1) {
              goto LABEL_52;
            }
            unsigned int v10 = (const __CFDictionary *)sub_100036CB8(v42);
LABEL_66:
            if (!v10) {
              goto LABEL_52;
            }
            goto LABEL_67;
          }

          if (strcmp(v27, "systemusers"))
          {
            uint64_t v28 = CFStringCreateWithCString(kCFAllocatorDefault, v27, 0x8000100u);
            unsigned int v10 = (const __CFDictionary *)sub_100036F70(v28);
            if (v28) {
              CFRelease(v28);
            }
            goto LABEL_66;
          }
        }

        sub_100037120(reply);
LABEL_52:
        uint64_t v44 = xpc_copy_description(reply);
        free(v44);
        xpc_connection_send_message(*(xpc_connection_t *)(a1 + 32), reply);

        goto LABEL_53;
      }

      int v11 = xpc_dictionary_get_int64(object, "query");
      if (v11 == 501)
      {
        int v12 = dword_1000DBCE8;
        uint64_t v13 = sub_100018E80(qword_1000DBD40);
        uint64_t v14 = objc_claimAutoreleasedReturnValue(v13);
        uint64_t v15 = (void *)v14;
        if (v12 == 2)
        {
          int v11 = sub_100019B60(v14);
        }

        else if (sub_100019ADC(v14))
        {
          uint64_t v31 = sub_100018E80(qword_1000DBD40);
          uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue(v31);
          int v11 = sub_100019B60((uint64_t)v32);
        }

        else
        {
          int v11 = -1;
        }
      }

      if (v11 == -1) {
        goto LABEL_52;
      }
      unsigned int v43 = (const __CFDictionary *)sub_100036CB8(v11);
      if (!v43) {
        goto LABEL_52;
      }
      unsigned int v10 = v43;
    }

    sub_1000365D8(v10, reply, 1);
LABEL_51:
    CFRelease(v10);
    goto LABEL_52;
  }

LABEL_53:
}

void sub_100037B90(char *__format, ...)
{
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  *(_OWORD *)__str = 0u;
  __int128 v18 = 0u;
  vsnprintf(__str, 0x80uLL, __format, va);
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v1 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    v15[0] = 0LL;
    unsigned int v2 = sub_100053B4C(1);
    BOOL v3 = os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT);
    CFTypeID v4 = 0LL;
    if (v3) {
      uint64_t v5 = v2;
    }
    else {
      uint64_t v5 = v2 & 0xFFFFFFFE;
    }
    if ((_DWORD)v5)
    {
      *(_DWORD *)uint64_t v16 = 136315138;
      *(void *)&v16[4] = __str;
      uint64_t v6 = (const char *)_os_log_send_and_compose_impl( v5,  v15,  0LL,  0LL,  &_mh_execute_header,  v1,  0LL,  "FATAL:Entering RECOVERYMODE due to: %s",  v16);
      CFTypeID v4 = 0LL;
      if (v6)
      {
        uint64_t v7 = v6;
        sub_100053B7C(v6);
        CFTypeID v4 = (char *)v7;
      }
    }

    free(v4);
  }

  sub_100037DF8("usermanagerd", __str);
  sub_100037DF8("auto-boot", "false");
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  CFTypeID v8 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t v16 = 0LL;
    unsigned int v9 = sub_100053B4C(1);
    BOOL v10 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    int v11 = 0LL;
    if (v10) {
      uint64_t v12 = v9;
    }
    else {
      uint64_t v12 = v9 & 0xFFFFFFFE;
    }
    if ((_DWORD)v12)
    {
      LOWORD(v15[0]) = 0;
      uint64_t v13 = (const char *)_os_log_send_and_compose_impl( v12,  v16,  0LL,  0LL,  &_mh_execute_header,  v8,  0LL,  "Rebooting...",  v15,  2);
      int v11 = 0LL;
      if (v13)
      {
        uint64_t v14 = v13;
        sub_100053B7C(v13);
        int v11 = (char *)v14;
      }
    }

    free(v11);
  }

  fprintf(__stdoutp, "UMD:FATAL OTI LOAD ERROR: %s\n", __str);
  fwrite("UMD:REBOOTING INTO RECOVERY MODE.\n", 0x22uLL, 1uLL, __stdoutp);
  reboot(0);
  exit(71);
}

uint64_t sub_100037DF8(char *cStr, const char *a2)
{
  kern_return_t v8;
  kern_return_t v9;
  os_log_s *v10;
  unsigned int v11;
  uint64_t v12;
  const char *v13;
  char *v14;
  os_log_s *v15;
  unsigned int v16;
  uint64_t v17;
  const char *v18;
  char *v19;
  os_log_s *v20;
  unsigned int v21;
  uint64_t v22;
  const char *v23;
  char *v24;
  uint64_t v25;
  uint64_t v27;
  _DWORD v28[2];
  BOOL v3 = CFStringCreateWithCString(0LL, cStr, 0x8000100u);
  io_registry_entry_t v4 = IORegistryEntryFromPath(kIOMainPortDefault, "IODeviceTree:/options");
  if (v4)
  {
    io_registry_entry_t v5 = v4;
    CFStringRef v6 = CFStringCreateWithCString(0LL, a2, 0x8000100u);
    if (v6)
    {
      CFStringRef v7 = v6;
      CFTypeID v8 = IORegistryEntrySetCFProperty(v5, v3, v6);
      if (v8)
      {
        unsigned int v9 = v8;
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        BOOL v10 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v27 = 0LL;
          int v11 = sub_100053B4C(1);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v12 = v11;
          }
          else {
            uint64_t v12 = v11 & 0xFFFFFFFE;
          }
          if ((_DWORD)v12)
          {
            v28[0] = 67109120;
            v28[1] = v9;
            uint64_t v13 = (const char *)_os_log_send_and_compose_impl( v12,  &v27,  0LL,  0LL,  &_mh_execute_header,  v10,  0LL,  "Could not save value:%08x",  v28);
            uint64_t v14 = (char *)v13;
            if (v13) {
              sub_100053B7C(v13);
            }
          }

          else
          {
            uint64_t v14 = 0LL;
          }

          free(v14);
        }

        dispatch_source_t v25 = 0xFFFFFFFFLL;
      }

      else
      {
        dispatch_source_t v25 = 0LL;
      }

      CFRelease(v7);
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      __int128 v20 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v27 = 0LL;
        __int128 v21 = sub_100053B4C(1);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
          __int128 v22 = v21;
        }
        else {
          __int128 v22 = v21 & 0xFFFFFFFE;
        }
        if ((_DWORD)v22)
        {
          LOWORD(v28[0]) = 0;
          __int128 v23 = (const char *)_os_log_send_and_compose_impl( v22,  &v27,  0LL,  0LL,  &_mh_execute_header,  v20,  0LL,  "Could not create string for value",  v28,  2);
          __int128 v24 = (char *)v23;
          if (v23) {
            sub_100053B7C(v23);
          }
        }

        else
        {
          __int128 v24 = 0LL;
        }

        free(v24);
      }

      dispatch_source_t v25 = 0xFFFFFFFFLL;
    }

    IOObjectRelease(v5);
  }

  else
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v15 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v27 = 0LL;
      uint64_t v16 = sub_100053B4C(1);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
        int v17 = v16;
      }
      else {
        int v17 = v16 & 0xFFFFFFFE;
      }
      if ((_DWORD)v17)
      {
        LOWORD(v28[0]) = 0;
        __int128 v18 = (const char *)_os_log_send_and_compose_impl( v17,  &v27,  0LL,  0LL,  &_mh_execute_header,  v15,  0LL,  "Could not get options entry from the device tree",  v28,  2);
        __int128 v19 = (char *)v18;
        if (v18) {
          sub_100053B7C(v18);
        }
      }

      else
      {
        __int128 v19 = 0LL;
      }

      free(v19);
    }

    dispatch_source_t v25 = 0xFFFFFFFFLL;
  }

  CFRelease(v3);
  return v25;
}

uint64_t sub_100038178()
{
  return sub_100037DF8("IONVRAM-DELETE-PROPERTY", "usermanagerd");
}

const void *sub_10003818C(int a1, int a2)
{
  LODWORD(v3) = a1;
  id v4 = sub_100054ED0(qword_1000DBA70, a1);
  io_registry_entry_t v5 = (__CFDictionary *)objc_claimAutoreleasedReturnValue(v4);
  if (!v5)
  {
    if (qword_1000DBAA0 == -1)
    {
LABEL_20:
      BOOL v3 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v41 = 0LL;
        unsigned int v14 = sub_100053B4C(1);
        BOOL v15 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
        uint64_t v16 = 0LL;
        if (v15) {
          uint64_t v17 = v14;
        }
        else {
          uint64_t v17 = v14 & 0xFFFFFFFE;
        }
        if ((_DWORD)v17)
        {
          LOWORD(v42) = 0;
          LODWORD(v40) = 2;
          __int128 v18 = (const char *)_os_log_send_and_compose_impl( v17,  &v41,  0LL,  0LL,  &_mh_execute_header,  v3,  0LL,  "Could not Locate primary user session of Update install user",  &v42,  v40);
          uint64_t v16 = 0LL;
          if (v18)
          {
            __int128 v19 = v18;
            sub_100053B7C(v18);
            uint64_t v16 = (char *)v19;
          }
        }

        free(v16);
      }

      sleep(2u);
      sub_100019F7C("UserManagement early boot task could not Locate primary user session of Update install user");
      goto LABEL_29;
    }

LABEL_62:
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    goto LABEL_20;
  }

  CFStringRef v6 = v5;
  if (!a2) {
    goto LABEL_16;
  }
  if (!sub_100077EEC(v5))
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    dispatch_time_t v33 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v41 = 0LL;
      unsigned int v34 = sub_100053B4C(1);
      BOOL v35 = os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT);
      int v36 = 0LL;
      if (v35) {
        uint64_t v37 = v34;
      }
      else {
        uint64_t v37 = v34 & 0xFFFFFFFE;
      }
      if ((_DWORD)v37)
      {
        LOWORD(v42) = 0;
        int v38 = (const char *)_os_log_send_and_compose_impl( v37,  &v41,  0LL,  0LL,  &_mh_execute_header,  v33,  0LL,  "Unable to find User Volume properties...",  &v42,  2);
        int v36 = 0LL;
        if (v38)
        {
          uint64_t v39 = v38;
          sub_100053B7C(v38);
          int v36 = (char *)v39;
        }
      }

      free(v36);
    }

    sleep(2u);
    sub_100019F7C("UserManagement early boot task failed to find device Node or volume uuid of UserVolume during update install");
    goto LABEL_62;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  CFStringRef v7 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v41 = 0LL;
    unsigned int v8 = sub_100053B4C(1);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v9 = v8;
    }
    else {
      uint64_t v9 = v8 & 0xFFFFFFFE;
    }
    if ((_DWORD)v9)
    {
      LOWORD(v42) = 0;
      BOOL v10 = (const char *)_os_log_send_and_compose_impl( v9,  &v41,  0LL,  0LL,  &_mh_execute_header,  v7,  0LL,  "Updated the manifest with User Disk/Volume Information, saving the manifest",  &v42,  2);
      int v11 = (char *)v10;
      if (v10) {
        sub_100053B7C(v10);
      }
    }

    else
    {
      int v11 = 0LL;
    }

    free(v11);
  }

  sub_10001AED4();
LABEL_16:
  uint64_t v12 = sub_100083DF4(v6, kUMUserSessionVolumeDeviceNodeKey);
  CFTypeRef result = sub_100083DF4(v6, kUMUserSessionVolumeUUIDKey);
  if (!v12)
  {
LABEL_29:
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    __int128 v20 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v41 = 0LL;
      unsigned int v21 = sub_100053B4C(1);
      BOOL v22 = os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT);
      __int128 v23 = 0LL;
      if (v22) {
        uint64_t v24 = v21;
      }
      else {
        uint64_t v24 = v21 & 0xFFFFFFFE;
      }
      if ((_DWORD)v24)
      {
        int v42 = 67109120;
        int v43 = (int)v3;
        dispatch_source_t v25 = (const char *)_os_log_send_and_compose_impl( v24,  &v41,  0LL,  0LL,  &_mh_execute_header,  v20,  0LL,  "Missing disknode for the booted user:%d",  &v42);
        __int128 v23 = 0LL;
        if (v25)
        {
          BOOL v3 = (os_log_s *)v25;
          sub_100053B7C(v25);
          __int128 v23 = v3;
        }
      }

      free(v23);
    }

    sleep(2u);
    sub_100019F7C("UserManagement early boot task missing disknode for the booted user..");
LABEL_40:
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    int v26 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v41 = 0LL;
      unsigned int v27 = sub_100053B4C(1);
      BOOL v28 = os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT);
      uint64_t v29 = 0LL;
      if (v28) {
        uint64_t v30 = v27;
      }
      else {
        uint64_t v30 = v27 & 0xFFFFFFFE;
      }
      if ((_DWORD)v30)
      {
        int v42 = 67109120;
        int v43 = (int)v3;
        uint64_t v31 = (const char *)_os_log_send_and_compose_impl( v30,  &v41,  0LL,  0LL,  &_mh_execute_header,  v26,  0LL,  "Missing volumeUUID for the booted user:%d",  &v42);
        uint64_t v29 = 0LL;
        if (v31)
        {
          uint64_t v32 = v31;
          sub_100053B7C(v31);
          uint64_t v29 = (char *)v32;
        }
      }

      free(v29);
    }

    sleep(2u);
    sub_100019F7C("UserManagement early boot task missing volumeUUID for the booted user..");
  }

  if (!result) {
    goto LABEL_40;
  }
  return result;
}

    dispatch_time_t v33 = 0LL;
LABEL_63:
    free(v33);
    goto LABEL_64;
  }

  uint64_t v39 = 0u;
  uint64_t v40 = 0u;
  uint64_t v37 = 0u;
  int v38 = 0u;
  uint64_t v12 = v11;
  uint64_t v13 = [v12 countByEnumeratingWithState:&v37 objects:v42 count:16];
  if (v13)
  {
    unsigned int v14 = v13;
    BOOL v15 = *(void *)v38;
    uint64_t v16 = 1;
    do
    {
      for (CFIndex i = 0LL; i != v14; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v38 != v15) {
          objc_enumerationMutation(v12);
        }
        v16 &= sub_100061C18(a1, *(void **)(*((void *)&v37 + 1) + 8LL * (void)i));
      }

      unsigned int v14 = [v12 countByEnumeratingWithState:&v37 objects:v42 count:16];
    }

    while (v14);
  }

  else
  {
    uint64_t v16 = 1;
  }

  if (qword_1000DBB68 != -1) {
    dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
  }
  BOOL v22 = (os_log_s *)(id)qword_1000DBB60;
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)int v43 = 0LL;
    __int128 v23 = sub_100053B4C(1);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v24 = v23;
    }
    else {
      uint64_t v24 = v23 & 0xFFFFFFFE;
    }
    if ((_DWORD)v24)
    {
      LOWORD(v41[0]) = 0;
      LODWORD(v36) = 2;
      dispatch_source_t v25 = (const char *)_os_log_send_and_compose_impl( v24,  v43,  0LL,  0LL,  &_mh_execute_header,  v22,  0LL,  "Saving Persona Manifest during unload",  v41,  v36,  (void)v37);
      int v26 = (char *)v25;
      if (v25) {
        sub_100053B7C(v25);
      }
    }

    else
    {
      int v26 = 0LL;
    }

    free(v26);
  }

  sub_10005B2D0(a1);
  if (v16)
  {
    if (qword_1000DBB68 != -1) {
      dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
    }
    __int128 v18 = (os_log_s *)(id)qword_1000DBB60;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)int v43 = 0LL;
      unsigned int v27 = sub_100053B4C(1);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
        BOOL v28 = v27;
      }
      else {
        BOOL v28 = v27 & 0xFFFFFFFE;
      }
      if ((_DWORD)v28)
      {
        LOWORD(v41[0]) = 0;
        LODWORD(v36) = 2;
        uint64_t v29 = (const char *)_os_log_send_and_compose_impl( v28,  v43,  0LL,  0LL,  &_mh_execute_header,  v18,  0LL,  "All Persona Unload success",  v41,  v36);
        uint64_t v30 = (char *)v29;
        if (v29) {
          sub_100053B7C(v29);
        }
      }

      else
      {
        uint64_t v30 = 0LL;
      }

      free(v30);
    }

    unsigned int v34 = 1LL;
    goto LABEL_68;
  }

  if (qword_1000DBB68 != -1) {
    dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
  }
  __int128 v18 = (os_log_s *)(id)qword_1000DBB60;
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)int v43 = 0LL;
    uint64_t v31 = sub_100053B4C(1);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v32 = v31;
    }
    else {
      uint64_t v32 = v31 & 0xFFFFFFFE;
    }
    if ((_DWORD)v32)
    {
      LOWORD(v41[0]) = 0;
      LODWORD(v36) = 2;
      unsigned int v21 = (const char *)_os_log_send_and_compose_impl( v32,  v43,  0LL,  0LL,  &_mh_execute_header,  v18,  0LL,  "All Persona Unload Failed",  v41,  v36);
LABEL_60:
      dispatch_time_t v33 = (char *)v21;
      if (v21) {
        sub_100053B7C(v21);
      }
      goto LABEL_63;
    }

    goto LABEL_62;
  }

id sub_1000386B8()
{
  id v0 = (void *)objc_claimAutoreleasedReturnValue([@"VolumeMigrationInProgress" dataUsingEncoding:4]);
  uint64_t v1 = sub_100019434(qword_1000DBD40);
  unsigned int v2 = (void *)objc_claimAutoreleasedReturnValue(v1);
  id v3 = [v2 atomicallyWriteData:v0 toPath:@"/private/var//keybags/umVolumeMigration-inprogress.kb" error:0];

  if ((_DWORD)v3)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v4 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = 0LL;
      unsigned int v5 = sub_100053B4C(1);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v6 = v5;
      }
      else {
        uint64_t v6 = v5 & 0xFFFFFFFE;
      }
      if ((_DWORD)v6)
      {
        LOWORD(v12) = 0;
        CFStringRef v7 = (const char *)_os_log_send_and_compose_impl( v6,  &v13,  0LL,  0LL,  &_mh_execute_header,  v4,  0LL,  "volumeMigratinMarkerCreate Successful",  &v12,  2,  v12);
        goto LABEL_18;
      }

      goto LABEL_20;
    }
  }

  else
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v4 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = 0LL;
      unsigned int v8 = sub_100053B4C(1);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v9 = v8;
      }
      else {
        uint64_t v9 = v8 & 0xFFFFFFFE;
      }
      if ((_DWORD)v9)
      {
        LOWORD(v12) = 0;
        CFStringRef v7 = (const char *)_os_log_send_and_compose_impl( v9,  &v13,  0LL,  0LL,  &_mh_execute_header,  v4,  0LL,  "failed to write diskSaveUserSessions dict",  &v12,  2,  v12);
LABEL_18:
        BOOL v10 = (char *)v7;
        if (v7) {
          sub_100053B7C(v7);
        }
        goto LABEL_21;
      }

void sub_100038894()
{
  char v597 = 1;
  id v3 = sub_100057614((uint64_t)&OBJC_CLASS___UMDAPFSSupportVolumeHelper, (void *)qword_1000DBD40, byte_1000DBD3A);
  uint64_t v4 = objc_claimAutoreleasedReturnValue(v3);
  p_name = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
  uint64_t v6 = (void *)qword_1000DBA68;
  qword_1000DBA68 = v4;

  CFStringRef v7 = sub_100054B0C((uint64_t)&OBJC_CLASS___UMDUserManager, (void *)qword_1000DBA68);
  uint64_t v8 = objc_claimAutoreleasedReturnValue(v7);
  uint64_t v9 = (void *)qword_1000DBA70;
  qword_1000DBA70 = v8;

  BOOL v10 = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
  unint64_t v11 = (unint64_t)&byte_1000DBD3B;
  if (![(id)qword_1000DBA68 splitUserVolumeEnabled])
  {
    uint64_t v15 = 0LL;
    int v16 = 0;
    int v17 = 0;
    goto LABEL_95;
  }

  *(_DWORD *)err = 0;
  if (sub_10008450C() == 100)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v12 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v12, OS_LOG_TYPE_DEFAULT))
    {
      value[0] = 0LL;
      unsigned int v13 = sub_100053B4C(1);
      uint64_t v0 = (uint64_t)v12;
      if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v14 = v13;
      }
      else {
        uint64_t v14 = v13 & 0xFFFFFFFE;
      }
      if ((_DWORD)v14)
      {
        LOWORD(uuid[0]) = 0;
        uint64_t p_vtable = _os_log_send_and_compose_impl( v14,  value,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "UM debug panic boot arg umd-migration-debug=100, Trying to redo Volume Migration, setting marker file here..",  uuid,  2);

        if (p_vtable) {
          sub_100053B7C((const char *)p_vtable);
        }
      }

      else
      {

        uint64_t p_vtable = 0LL;
      }

      free((void *)p_vtable);
    }

    sub_1000386B8();
  }

  if (sub_10008450C() == 101)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v18 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v18, OS_LOG_TYPE_DEFAULT))
    {
      value[0] = 0LL;
      unsigned int v19 = sub_100053B4C(1);
      __int128 v20 = (os_log_s *)v18;
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v21 = v19;
      }
      else {
        uint64_t v21 = v19 & 0xFFFFFFFE;
      }
      if ((_DWORD)v21)
      {
        LOWORD(uuid[0]) = 0;
        LODWORD(v580) = 2;
        uint64_t p_vtable = _os_log_send_and_compose_impl( v21,  value,  0LL,  0LL,  &_mh_execute_header,  v20,  0LL,  "UM debug panic boot arg umd-migration-debug=101, removing usersessionbag  continuing to avoid Prima ry Migrate Panic",  uuid,  v580);

        if (p_vtable) {
          sub_100053B7C((const char *)p_vtable);
        }
      }

      else
      {

        uint64_t p_vtable = 0LL;
      }

      free((void *)p_vtable);
    }

    uint64_t v22 = sub_100019434(qword_1000DBD40);
    __int128 v23 = (void *)objc_claimAutoreleasedReturnValue(v22);
    uint64_t v0 = (uint64_t)[v23 removeFileAtPath:@"/private/var//keybags/usersession.kb" error:0];

    if ((v0 & 1) != 0)
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v24 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_49;
      }
      value[0] = 0LL;
      unsigned int v25 = sub_100053B4C(1);
      uint64_t v24 = v24;
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v26 = v25;
      }
      else {
        uint64_t v26 = v25 & 0xFFFFFFFE;
      }
      if ((_DWORD)v26)
      {
        LOWORD(uuid[0]) = 0;
        LODWORD(v580) = 2;
        uint64_t v27 = _os_log_send_and_compose_impl( v26,  value,  0LL,  0LL,  &_mh_execute_header,  v24,  0LL,  "Removed USER_SESSION_BAG_PATH, continuing to boot.. ",  uuid,  v580);
        goto LABEL_45;
      }
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v24 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_49;
      }
      value[0] = 0LL;
      unsigned int v28 = sub_100053B4C(1);
      uint64_t v24 = v24;
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v29 = v28;
      }
      else {
        uint64_t v29 = v28 & 0xFFFFFFFE;
      }
      if ((_DWORD)v29)
      {
        LOWORD(uuid[0]) = 0;
        LODWORD(v580) = 2;
        uint64_t v27 = _os_log_send_and_compose_impl( v29,  value,  0LL,  0LL,  &_mh_execute_header,  v24,  0LL,  "Unlink of USER_SESSION_BAG_PATH failed, unfortunately can't recover..",  uuid,  v580);
LABEL_45:
        uint64_t v0 = v27;

        if (v0) {
          sub_100053B7C((const char *)v0);
        }
        goto LABEL_48;
      }
    }

    uint64_t v0 = 0LL;
LABEL_48:
    free((void *)v0);
LABEL_49:
  }

  if (sub_10007D3E0((int *)err, &v597))
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v30 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v30, OS_LOG_TYPE_DEFAULT))
    {
      value[0] = 0LL;
      unsigned int v31 = sub_100053B4C(1);
      uint64_t v0 = (uint64_t)v30;
      if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v32 = v31;
      }
      else {
        uint64_t v32 = v31 & 0xFFFFFFFE;
      }
      if ((_DWORD)v32)
      {
        LOWORD(uuid[0]) = 0;
        LODWORD(v580) = 2;
        uint64_t p_vtable = _os_log_send_and_compose_impl( v32,  value,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "Boot after Update Install, needs User & System volume migration",  uuid,  v580);

        if (p_vtable) {
          sub_100053B7C((const char *)p_vtable);
        }
      }

      else
      {

        uint64_t p_vtable = 0LL;
      }

      free((void *)p_vtable);
    }

    unsigned int v40 = sub_1000386B8();
    BOOL v41 = qword_1000DBAA0 == -1;
    if (!v40) {
      goto LABEL_1277;
    }
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    dispatch_time_t v33 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_94;
    }
    value[0] = 0LL;
    unsigned int v42 = sub_100053B4C(1);
    uint64_t v0 = v33;
    if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v43 = v42;
    }
    else {
      uint64_t v43 = v42 & 0xFFFFFFFE;
    }
    if ((_DWORD)v43)
    {
      LOWORD(uuid[0]) = 0;
      LODWORD(v580) = 2;
      uint64_t v36 = _os_log_send_and_compose_impl( v43,  value,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "Successfully marker file to indicate volume migration needed, in progress",  uuid,  v580);
LABEL_90:
      uint64_t p_vtable = v36;

      if (p_vtable) {
        sub_100053B7C((const char *)p_vtable);
      }
      goto LABEL_93;
    }

    goto LABEL_92;
  }

  if (sub_100023714())
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    dispatch_time_t v33 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_94;
    }
    value[0] = 0LL;
    unsigned int v34 = sub_100053B4C(1);
    uint64_t v0 = v33;
    if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v35 = v34;
    }
    else {
      uint64_t v35 = v34 & 0xFFFFFFFE;
    }
    if ((_DWORD)v35)
    {
      LOWORD(uuid[0]) = 0;
      LODWORD(v580) = 2;
      uint64_t v36 = _os_log_send_and_compose_impl( v35,  value,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "UM-MARKER-FILE - Boot without completing Migration, needs User & System volume migration",  uuid,  v580);
      goto LABEL_90;
    }

LABEL_92:
    uint64_t p_vtable = 0LL;
LABEL_93:
    free((void *)p_vtable);
LABEL_94:

    uint64_t v15 = 0LL;
    int v16 = 0;
    int v17 = 1;
    goto LABEL_95;
  }

  if (!v597)
  {
    byte_1000DBD3B = 1;
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v37 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v37, OS_LOG_TYPE_DEFAULT))
    {
      value[0] = 0LL;
      unsigned int v38 = sub_100053B4C(1);
      uint64_t v0 = (uint64_t)v37;
      if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v39 = v38;
      }
      else {
        uint64_t v39 = v38 & 0xFFFFFFFE;
      }
      if ((_DWORD)v39)
      {
        LOWORD(uuid[0]) = 0;
        LODWORD(v580) = 2;
        uint64_t p_vtable = _os_log_send_and_compose_impl( v39,  value,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "IS Encrypted FALSE",  uuid,  v580);

        if (p_vtable) {
          sub_100053B7C((const char *)p_vtable);
        }
      }

      else
      {

        uint64_t p_vtable = 0LL;
      }

      free((void *)p_vtable);
    }

    uint64_t v172 = sub_100019B18(qword_1000DBD40);
    v173 = (void *)objc_claimAutoreleasedReturnValue(v172);
    [v173 setIgnoreIdentityMethods:byte_1000DBD3B];
  }

  char v597 = 1;
  if (sub_10007D41C((int *)err, &v597))
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v174 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v174, OS_LOG_TYPE_DEFAULT))
    {
      value[0] = 0LL;
      unsigned int v175 = sub_100053B4C(1);
      uint64_t v0 = (uint64_t)v174;
      if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v176 = v175;
      }
      else {
        uint64_t v176 = v175 & 0xFFFFFFFE;
      }
      if ((_DWORD)v176)
      {
        LOWORD(uuid[0]) = 0;
        LODWORD(v580) = 2;
        uint64_t p_vtable = _os_log_send_and_compose_impl( v176,  value,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "Boot after Erase Install, needs User volume migration",  uuid,  v580);

        if (p_vtable) {
          sub_100053B7C((const char *)p_vtable);
        }
      }

      else
      {

        uint64_t p_vtable = 0LL;
      }

      free((void *)p_vtable);
    }

    uint64_t v15 = 0LL;
    int v17 = 0;
    int v16 = 1;
  }

  else
  {
    int v16 = 0;
    int v17 = 0;
    uint64_t v15 = *(_DWORD *)err == 2;
  }

        id v49 = 0LL;
LABEL_93:
        free(v49);
LABEL_94:

        goto LABEL_95;
      }

      uint64_t v21 = sub_100075BA0((uint64_t)&OBJC_CLASS___UMDPersonaManifestPersona, v19);
      uint64_t v22 = objc_claimAutoreleasedReturnValue(v21);
      if (!v22)
      {
        if (qword_1000DBBC8 != -1) {
          dispatch_once(&qword_1000DBBC8, &stru_1000CDB00);
        }
        uint64_t v24 = v14;
        uint64_t v43 = (os_log_s *)(id)qword_1000DBBC0;
        if (!os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
          goto LABEL_94;
        }
        *(void *)uint64_t v58 = 0LL;
        uint64_t v47 = sub_100053B4C(0);
        if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
          uint64_t v48 = v47;
        }
        else {
          uint64_t v48 = v47 & 0xFFFFFFFE;
        }
        if ((_DWORD)v48)
        {
          LOWORD(v56[0]) = 0;
          unsigned int v46 = (const char *)_os_log_send_and_compose_impl( v48,  v58,  0LL,  0LL,  &_mh_execute_header,  v43,  16LL,  "Failed to parse persona manifest persona list: failed to parse persona",  v56,  2);
LABEL_90:
          id v49 = (char *)v46;
          if (v46) {
            sub_100053B7C(v46);
          }
          goto LABEL_93;
        }

        goto LABEL_92;
      }

      __int128 v23 = (void *)v22;
      -[os_log_s addObject:](v14, "addObject:", v22);
    }

    int v16 = -[os_log_s countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v52,  v57,  16LL);
    if (v16) {
      continue;
    }
    break;
  }

LABEL_1496:
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    goto LABEL_1232;
  }

  sub_1000198B4(qword_1000DBA70, (void *)qword_1000DBCD8);
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v57 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v57, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)err = 0LL;
    LODWORD(v5_Block_object_dispose(va, 8) = sub_100053B4C(1);
    uint64_t v0 = (uint64_t)v57;
    if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v58 = v58;
    }
    else {
      uint64_t v58 = v58 & 0xFFFFFFFE;
    }
    if ((_DWORD)v58)
    {
      uint64_t v59 = sub_100019434(qword_1000DBA70);
      uint64_t v15 = objc_claimAutoreleasedReturnValue(v59);
      LODWORD(value[0]) = 138412290;
      *(void **)((char *)value + 4) = (void *)v15;
      LODWORD(v580) = 12;
      uint64_t p_vtable = _os_log_send_and_compose_impl( v58,  err,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "ALL Users List is %@",  value,  v580);

      if (p_vtable) {
        sub_100053B7C((const char *)p_vtable);
      }
    }

    else
    {

      uint64_t p_vtable = 0LL;
    }

    free((void *)p_vtable);
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v60 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v60, OS_LOG_TYPE_DEFAULT))
  {
    value[0] = 0LL;
    unsigned int v61 = sub_100053B4C(1);
    uint64_t v0 = (uint64_t)v60;
    if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v62 = v61;
    }
    else {
      uint64_t v62 = v61 & 0xFFFFFFFE;
    }
    if ((_DWORD)v62)
    {
      *(_WORD *)err = 0;
      LODWORD(v580) = 2;
      uint64_t p_vtable = _os_log_send_and_compose_impl( v62,  value,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "Determining the user to boot",  err,  v580);

      if (p_vtable) {
        sub_100053B7C((const char *)p_vtable);
      }
    }

    else
    {

      uint64_t p_vtable = 0LL;
    }

    free((void *)p_vtable);
  }

  if (dword_1000DBCE8 == 1)
  {
    id v63 = sub_100054ED0(qword_1000DBA70, 502);
    uint64_t v64 = (__CFDictionary *)objc_claimAutoreleasedReturnValue(v63);
    if (v64) {
      goto LABEL_251;
    }
    uint64_t p_vtable = (uint64_t)&OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
    if (qword_1000DBAB0 != -1) {
      dispatch_once(&qword_1000DBAB0, &stru_1000CD548);
    }
    uint64_t v15 = (uint64_t)&OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
    uint64_t v64 = (__CFDictionary *)(id)qword_1000DBAA8;
    if (os_log_type_enabled(v64, OS_LOG_TYPE_INFO))
    {
      value[0] = 0LL;
      unsigned int v65 = sub_100053B4C(0);
      if (os_log_type_enabled(v64, OS_LOG_TYPE_INFO)) {
        uint64_t v66 = v65;
      }
      else {
        uint64_t v66 = v65 & 0xFFFFFFFE;
      }
      if ((_DWORD)v66)
      {
        *(_WORD *)err = 0;
        LODWORD(v580) = 2;
        uint64_t v67 = (const char *)_os_log_send_and_compose_impl( v66,  value,  0LL,  0LL,  &_mh_execute_header,  v64,  1LL,  "Loginwindow user not found",  err,  v580);
        id v68 = (char *)v67;
        if (v67) {
          sub_100053B7C(v67);
        }
      }

      else
      {
        id v68 = 0LL;
      }

      free(v68);
    }

    id v80 = sub_10001ED88(-1, 0LL);
    if (v80)
    {
      uint64_t v64 = v80;
      if (qword_1000DBAB0 == -1) {
        goto LABEL_204;
      }
    }

    else
    {
      sub_100019F7C("UserManagement early boot task failed assertion: loginwindowSession != ((void *)0)");
    }

    dispatch_once(&qword_1000DBAB0, &stru_1000CD548);
LABEL_204:
    uint64_t v0 = (uint64_t)(id)qword_1000DBAA8;
    if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT))
    {
      value[0] = 0LL;
      unsigned int v81 = sub_100053B4C(0);
      if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v82 = v81;
      }
      else {
        uint64_t v82 = v81 & 0xFFFFFFFE;
      }
      if ((_DWORD)v82)
      {
        *(_WORD *)err = 0;
        LODWORD(v580) = 2;
        int v83 = (const char *)_os_log_send_and_compose_impl( v82,  value,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "Created loginwindow user",  err,  v580);
        goto LABEL_246;
      }

      goto LABEL_248;
    }

    goto LABEL_250;
  }

  id v69 = sub_100054ED0(qword_1000DBA70, 501);
  uint64_t v64 = (__CFDictionary *)objc_claimAutoreleasedReturnValue(v69);
  if (![(id)qword_1000DBA68 splitUserVolumeEnabled])
  {
    if (v64) {
      goto LABEL_251;
    }
    uint64_t p_vtable = (uint64_t)&OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
    if (qword_1000DBAB0 != -1) {
      dispatch_once(&qword_1000DBAB0, &stru_1000CD548);
    }
    uint64_t v15 = (uint64_t)&OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
    uint64_t v64 = (__CFDictionary *)(id)qword_1000DBAA8;
    if (!os_log_type_enabled(v64, OS_LOG_TYPE_INFO))
    {
LABEL_238:

      unsigned int v93 = sub_10004FCB0(0);
      if (v93)
      {
        uint64_t v64 = v93;
        if (*(void *)(p_vtable + 2736) == -1LL) {
          goto LABEL_240;
        }
      }

      else
      {
        sub_100019F7C("UserManagement early boot task failed assertion: mobileSession != ((void *)0)");
      }

      dispatch_once(&qword_1000DBAB0, &stru_1000CD548);
LABEL_240:
      uint64_t v0 = (uint64_t)*(id *)(v15 + 2728);
      if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT))
      {
        value[0] = 0LL;
        unsigned int v94 = sub_100053B4C(0);
        if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v95 = v94;
        }
        else {
          uint64_t v95 = v94 & 0xFFFFFFFE;
        }
        if ((_DWORD)v95)
        {
          *(_WORD *)err = 0;
          LODWORD(v580) = 2;
          int v83 = (const char *)_os_log_send_and_compose_impl( v95,  value,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "Created mobile user",  err,  v580);
LABEL_246:
          uint64_t p_vtable = (uint64_t)v83;
          if (v83) {
            sub_100053B7C(v83);
          }
          goto LABEL_249;
        }

LABEL_248:
        uint64_t p_vtable = 0LL;
LABEL_249:
        free((void *)p_vtable);
      }

LABEL_250:
      goto LABEL_251;
    }

    value[0] = 0LL;
    unsigned int v76 = sub_100053B4C(0);
    if (os_log_type_enabled(v64, OS_LOG_TYPE_INFO)) {
      uint64_t v77 = v76;
    }
    else {
      uint64_t v77 = v76 & 0xFFFFFFFE;
    }
    if ((_DWORD)v77)
    {
      *(_WORD *)err = 0;
      LODWORD(v580) = 2;
      unsigned int v78 = (const char *)_os_log_send_and_compose_impl( v77,  value,  0LL,  0LL,  &_mh_execute_header,  v64,  1LL,  "Mobile user not found",  err,  v580);
      uint64_t v79 = (char *)v78;
      if (v78) {
        sub_100053B7C(v78);
      }
      goto LABEL_237;
    }

LABEL_236:
    uint64_t v79 = 0LL;
LABEL_237:
    free(v79);
    goto LABEL_238;
  }

  char v70 = v587 ^ 1;
  if (v64) {
    char v70 = 1;
  }
  if ((v70 & 1) == 0)
  {
    uint64_t p_vtable = (uint64_t)&OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
    if (qword_1000DBAB0 != -1) {
      dispatch_once(&qword_1000DBAB0, &stru_1000CD548);
    }
    uint64_t v15 = (uint64_t)&OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
    unsigned int v71 = (os_log_s *)(id)qword_1000DBAA8;
    if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
    {
      value[0] = 0LL;
      unsigned int v72 = sub_100053B4C(0);
      if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v73 = v72;
      }
      else {
        uint64_t v73 = v72 & 0xFFFFFFFE;
      }
      if ((_DWORD)v73)
      {
        *(_WORD *)err = 0;
        LODWORD(v580) = 2;
        uint64_t v74 = (const char *)_os_log_send_and_compose_impl( v73,  value,  0LL,  0LL,  &_mh_execute_header,  v71,  0LL,  "Boot after update install, Mobile user not found, creating",  err,  v580);
        uint64_t v75 = (char *)v74;
        if (v74) {
          sub_100053B7C(v74);
        }
      }

      else
      {
        uint64_t v75 = 0LL;
      }

      free(v75);
    }

    uint64_t v64 = sub_10004FCB0(1);
    if (qword_1000DBAB0 != -1) {
      dispatch_once(&qword_1000DBAB0, &stru_1000CD548);
    }
    uint64_t v0 = (uint64_t)(id)qword_1000DBAA8;
    if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT))
    {
      value[0] = 0LL;
      unsigned int v84 = sub_100053B4C(0);
      if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v85 = v84;
      }
      else {
        uint64_t v85 = v84 & 0xFFFFFFFE;
      }
      if ((_DWORD)v85)
      {
        *(_WORD *)err = 0;
        LODWORD(v580) = 2;
        unsigned int v86 = (const char *)_os_log_send_and_compose_impl( v85,  value,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "Created mobile user",  err,  v580);
        uint64_t p_vtable = (uint64_t)v86;
        if (v86) {
          sub_100053B7C(v86);
        }
      }

      else
      {
        uint64_t p_vtable = 0LL;
      }

      free((void *)p_vtable);
    }
  }

  if (!v64)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v64 = (__CFDictionary *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
    {
      value[0] = 0LL;
      unsigned int v87 = sub_100053B4C(1);
      BOOL v88 = os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT);
      id v89 = 0LL;
      if (v88) {
        uint64_t v90 = v87;
      }
      else {
        uint64_t v90 = v87 & 0xFFFFFFFE;
      }
      if ((_DWORD)v90)
      {
        *(_WORD *)err = 0;
        LODWORD(v580) = 2;
        uint64_t v91 = (const char *)_os_log_send_and_compose_impl( v90,  value,  0LL,  0LL,  &_mh_execute_header,  v64,  0LL,  "Boot after update install, Mobile MISSING, PANIC. ",  err,  v580);
        id v89 = 0LL;
        if (v91)
        {
          uint64_t v92 = v91;
          sub_100053B7C(v91);
          id v89 = (char *)v92;
        }
      }

      free(v89);
    }

    sleep(2u);
    sub_100019F7C("UserManagement early boot task unable to locate Primary user..");
    goto LABEL_236;
  }

LABEL_251:
  CFRelease(v64);
  if ((sub_100055F08(qword_1000DBA70) & 1) == 0)
  {
LABEL_1241:
    sub_100019F7C("UserManagement early boot task failed to remove nextSession file");
    goto LABEL_1242;
  }

  if (dword_1000DBCE8 != 1) {
    goto LABEL_274;
  }
  if (byte_1000DACB8 && qword_1000DBCD8)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v96 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT))
    {
      value[0] = 0LL;
      unsigned int v97 = sub_100053B4C(1);
      if (os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v98 = v97;
      }
      else {
        uint64_t v98 = v97 & 0xFFFFFFFE;
      }
      if ((_DWORD)v98)
      {
        *(_WORD *)err = 0;
        LODWORD(v580) = 2;
        uint64_t v99 = (const char *)_os_log_send_and_compose_impl( v98,  value,  0LL,  0LL,  &_mh_execute_header,  v96,  0LL,  "RESET ALL USER VOLUME MOUNTED",  err,  v580);
        uint64_t v0 = (uint64_t)v99;
        if (v99) {
          sub_100053B7C(v99);
        }
      }

      else
      {
        uint64_t v0 = 0LL;
      }

      free((void *)v0);
    }

    if (CFArrayGetCount((CFArrayRef)qword_1000DBCD8) >= 1)
    {
      CFIndex v100 = 0LL;
      uint64_t v0 = (uint64_t)kCFBooleanFalse;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)qword_1000DBCD8, v100);
        if (ValueAtIndex)
        {
          uint64_t p_vtable = (uint64_t)ValueAtIndex;
          uint64_t v15 = CFGetTypeID(ValueAtIndex);
          if (v15 == CFDictionaryGetTypeID())
          {
            if (CFDictionaryContainsKey((CFDictionaryRef)p_vtable, kUMUserSessionVolumeMountedKey)) {
              CFDictionarySetValue((CFMutableDictionaryRef)p_vtable, kUMUserSessionVolumeMountedKey, kCFBooleanFalse);
            }
          }
        }

        ++v100;
      }

      while (CFArrayGetCount((CFArrayRef)qword_1000DBCD8) > v100);
    }
  }

  sub_10003FE64();
  if (dword_1000DBCE8 != 1)
  {
LABEL_274:
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v102 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v102, OS_LOG_TYPE_DEFAULT))
    {
      value[0] = 0LL;
      unsigned int v103 = sub_100053B4C(1);
      uint64_t v0 = (uint64_t)v102;
      if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v104 = v103;
      }
      else {
        uint64_t v104 = v103 & 0xFFFFFFFE;
      }
      if ((_DWORD)v104)
      {
        *(_WORD *)err = 0;
        LODWORD(v580) = 2;
        uint64_t p_vtable = _os_log_send_and_compose_impl( v104,  value,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "LOADING PERSONA..",  err,  v580);

        if (p_vtable) {
          sub_100053B7C((const char *)p_vtable);
        }
      }

      else
      {

        uint64_t p_vtable = 0LL;
      }

      free((void *)p_vtable);
    }

    if (qword_1000DBA78)
    {
      sub_100019F7C("UserManagement early boot task failed assertion: _gPersonaManager == ((void *)0)");
    }

    else
    {
      BOOL v10 = (char **)&byte_1000DBD3B;
      unint64_t v11 = (unint64_t)&OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
      uint64_t v105 = sub_10005780C((uint64_t)&OBJC_CLASS___UMDPersonaManager, (void *)qword_1000DBA70);
      uint64_t v106 = objc_claimAutoreleasedReturnValue(v105);
      id v107 = (void *)qword_1000DBA78;
      qword_1000DBA78 = v106;

      LODWORD(uuid[0]) = 0;
      uint64_t v15 = (uint64_t)&OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
      if (!sub_10003FFE4(uuid))
      {
        if (qword_1000DBAC0 != -1) {
          dispatch_once(&qword_1000DBAC0, &stru_1000CD568);
        }
        id v108 = (id)qword_1000DBAB8;
        if (os_log_type_enabled((os_log_t)v108, OS_LOG_TYPE_DEFAULT))
        {
          value[0] = 0LL;
          unsigned int v109 = sub_100053B4C(0);
          uint64_t v0 = (uint64_t)v108;
          if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v110 = v109;
          }
          else {
            uint64_t v110 = v109 & 0xFFFFFFFE;
          }
          if ((_DWORD)v110)
          {
            *(_DWORD *)err = 67109120;
            *(_DWORD *)&err[4] = uuid[0];
            LODWORD(v580) = 8;
            uint64_t p_vtable = _os_log_send_and_compose_impl( v110,  value,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "Failed to load persona manifest: %{darwin.errno}d",  err,  v580);

            if (p_vtable) {
              sub_100053B7C((const char *)p_vtable);
            }
          }

          else
          {

            uint64_t p_vtable = 0LL;
          }

          free((void *)p_vtable);
        }

        uint64_t v111 = sub_1000197AC(qword_1000DBA78);
        id v112 = (void *)objc_claimAutoreleasedReturnValue(v111);
        sub_100056294((uint64_t)v112, 1LL);
      }

      if (qword_1000DBAC0 == -1) {
        goto LABEL_300;
      }
    }

    dispatch_once(&qword_1000DBAC0, &stru_1000CD568);
LABEL_300:
    id v113 = *(id *)(v15 + 2744);
    if (os_log_type_enabled((os_log_t)v113, OS_LOG_TYPE_DEFAULT))
    {
      value[0] = 0LL;
      unsigned int v114 = sub_100053B4C(0);
      uint64_t v0 = (uint64_t)v113;
      if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v115 = v114;
      }
      else {
        uint64_t v115 = v114 & 0xFFFFFFFE;
      }
      if ((_DWORD)v115)
      {
        *(_WORD *)err = 0;
        LODWORD(v580) = 2;
        uint64_t p_vtable = _os_log_send_and_compose_impl( v115,  value,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "Loaded persona manifest",  err,  v580);

        if (p_vtable) {
          sub_100053B7C((const char *)p_vtable);
        }
      }

      else
      {

        uint64_t p_vtable = 0LL;
      }

      free((void *)p_vtable);
    }

    if (qword_1000DBAC0 != -1) {
      dispatch_once(&qword_1000DBAC0, &stru_1000CD568);
    }
    p_name = (char **)v11;
    id v116 = *(id *)(v15 + 2744);
    unint64_t v11 = (unint64_t)v10;
    uint64_t v48 = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
    if (os_log_type_enabled((os_log_t)v116, OS_LOG_TYPE_DEBUG))
    {
      *(void *)err = 0LL;
      LODWORD(v117) = sub_100053B4C(0);
      uint64_t v0 = (uint64_t)v116;
      if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEBUG)) {
        uint64_t v117 = v117;
      }
      else {
        uint64_t v117 = v117 & 0xFFFFFFFE;
      }
      if ((_DWORD)v117)
      {
        uint64_t v118 = sub_1000197A0(qword_1000DBA78);
        unsigned int v119 = (void *)objc_claimAutoreleasedReturnValue(v118);
        LODWORD(value[0]) = 138412290;
        *(void **)((char *)value + 4) = v119;
        LODWORD(v580) = 12;
        uint64_t p_vtable = _os_log_send_and_compose_impl( v117,  err,  0LL,  0LL,  &_mh_execute_header,  v0,  2LL,  "Persona state: %@",  value,  v580);

        if (p_vtable) {
          sub_100053B7C((const char *)p_vtable);
        }
      }

      else
      {

        uint64_t p_vtable = 0LL;
      }

      free((void *)p_vtable);
    }

    if (sub_1000577F4())
    {
      sub_10006357C(qword_1000DBA78);
    }
  }

  uint64_t v2 = v586;
  LODWORD(v120) = v587 | v586;
  BOOL v121 = ((v587 | v586) & 1) != 0 || *(_BYTE *)v11 != 0;
  if (![p_name[333] splitUserVolumeEnabled])
  {
    if (dword_1000DBCE8 != 1)
    {
      uint64_t p_vtable = (uint64_t)&OBJC_METACLASS___UMLibNotifyProvider.vtable;
      if ((dword_1000DACB0 - 501) <= 0x36
        && (id v128 = sub_100054ED0(qword_1000DBA70, dword_1000DACB0),
            CFTypeID v129 = (void *)objc_claimAutoreleasedReturnValue(v128),
            v129,
            v129))
      {
        uint64_t v127 = dword_1000DACB0;
      }

      else
      {
        if (qword_1000DBAB0 != -1) {
          dispatch_once(&qword_1000DBAB0, &stru_1000CD548);
        }
        uint64_t v130 = (os_log_s *)(id)qword_1000DBAA8;
        if (os_log_type_enabled(v130, OS_LOG_TYPE_ERROR))
        {
          value[0] = 0LL;
          unsigned int v131 = sub_100053B4C(0);
          if (os_log_type_enabled(v130, OS_LOG_TYPE_ERROR)) {
            uint64_t v132 = v131;
          }
          else {
            uint64_t v132 = v131 & 0xFFFFFFFE;
          }
          if ((_DWORD)v132)
          {
            *(_DWORD *)err = 67109120;
            *(_DWORD *)&err[4] = dword_1000DACB0;
            id v133 = (const char *)_os_log_send_and_compose_impl( v132,  value,  0LL,  0LL,  &_mh_execute_header,  v130,  16LL,  "BootedUser %d is invalid, reverting to mobile",  err);
            unsigned int v134 = (char *)v133;
            if (v133) {
              sub_100053B7C(v133);
            }
          }

          else
          {
            unsigned int v134 = 0LL;
          }

          free(v134);
        }

        uint64_t v127 = 501LL;
        dword_1000DACB0 = 501;
      }

      goto LABEL_497;
    }

LABEL_340:
    uint64_t v127 = 502LL;
    goto LABEL_497;
  }

  if (dword_1000DBCE8 == 1) {
    goto LABEL_340;
  }
  if (v121)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v122 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT))
    {
      value[0] = 0LL;
      unsigned int v123 = sub_100053B4C(1);
      if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v124 = v123;
      }
      else {
        uint64_t v124 = v123 & 0xFFFFFFFE;
      }
      if ((_DWORD)v124)
      {
        *(_WORD *)err = 0;
        LODWORD(v580) = 2;
        id v125 = (const char *)_os_log_send_and_compose_impl( v124,  value,  0LL,  0LL,  &_mh_execute_header,  v122,  0LL,  "Boot after Update/Erase install/Unencrypted FS, using last user as Mobile User",  err,  v580);
        uint64_t v126 = (char *)v125;
        if (v125) {
          sub_100053B7C(v125);
        }
      }

      else
      {
        uint64_t v126 = 0LL;
      }

      free(v126);
    }

    uint64_t v127 = 501LL;
    goto LABEL_497;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v135 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v135, OS_LOG_TYPE_DEFAULT))
  {
    value[0] = 0LL;
    unsigned int v136 = sub_100053B4C(1);
    if (os_log_type_enabled(v135, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v137 = v136;
    }
    else {
      uint64_t v137 = v136 & 0xFFFFFFFE;
    }
    if ((_DWORD)v137)
    {
      *(_WORD *)err = 0;
      LODWORD(v580) = 2;
      id v138 = (const char *)_os_log_send_and_compose_impl( v137,  value,  0LL,  0LL,  &_mh_execute_header,  v135,  0LL,  "Reading Last Booted User from AKS, normal boot flow",  err,  v580);
      uint64_t v0 = (uint64_t)v138;
      if (v138) {
        sub_100053B7C(v138);
      }
    }

    else
    {
      uint64_t v0 = 0LL;
    }

    free((void *)v0);
  }

  *(void *)err = 0LL;
  uuid[0] = 0LL;
  if (!AKSGetLastUser(uuid))
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v144 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v144, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v617 = 0LL;
      LODWORD(v145) = sub_100053B4C(1);
      if (os_log_type_enabled(v144, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v145 = v145;
      }
      else {
        uint64_t v145 = v145 & 0xFFFFFFFE;
      }
      if ((_DWORD)v145)
      {
        uint64_t v146 = *(__CFError **)err;
        uint64_t v147 = v144;
        int Code = CFErrorGetCode(v146);
        LODWORD(value[0]) = 67109378;
        HIDWORD(value[0]) = Code;
        LOWORD(value[1]) = 2112;
        *(void **)((char *)&value[1] + 2) = *(void **)err;
        LODWORD(v580) = 18;
        uint64_t v0 = _os_log_send_and_compose_impl( v145,  &v617,  0LL,  0LL,  &_mh_execute_header,  v147,  0LL,  "AKSGetLastUser failed with errorcode: %d, CFError:%@",  value,  v580);

        if (v0) {
          sub_100053B7C((const char *)v0);
        }
        LODWORD(v120) = v587 | v586;
      }

      else
      {
        uint64_t v0 = 0LL;
      }

      free((void *)v0);
    }

    uint64_t p_vtable = CFErrorGetCode(*(CFErrorRef *)err);
    uint64_t v127 = 0xFFFFFFFFLL;
    goto LABEL_482;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  int v139 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v139, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v617 = 0LL;
    unsigned int v140 = sub_100053B4C(1);
    if (os_log_type_enabled(v139, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v141 = v140;
    }
    else {
      uint64_t v141 = v140 & 0xFFFFFFFE;
    }
    if ((_DWORD)v141)
    {
      LODWORD(value[0]) = 138412290;
      *(CFUUIDRef *)((char *)value + 4) = uuid[0];
      LODWORD(v580) = 12;
      uint64_t v142 = (const char *)_os_log_send_and_compose_impl( v141,  &v617,  0LL,  0LL,  &_mh_execute_header,  v139,  0LL,  "AKSGetLastUser: Success, lastuser vol uuid is %@",  value,  v580);
      uint64_t v143 = (char *)v142;
      if (v142) {
        sub_100053B7C(v142);
      }
    }

    else
    {
      uint64_t v143 = 0LL;
    }

    free(v143);
  }

  uint64_t v0 = (uint64_t)CFUUIDCreateString(kCFAllocatorDefault, uuid[0]);
  if (!v0)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    CFNumberRef v154 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v154, OS_LOG_TYPE_DEFAULT))
    {
      value[0] = 0LL;
      unsigned int v155 = sub_100053B4C(1);
      if (os_log_type_enabled(v154, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v156 = v155;
      }
      else {
        uint64_t v156 = v155 & 0xFFFFFFFE;
      }
      if ((_DWORD)v156)
      {
        LOWORD(v617) = 0;
        LODWORD(v580) = 2;
        v157 = (const char *)_os_log_send_and_compose_impl( v156,  value,  0LL,  0LL,  &_mh_execute_header,  v154,  0LL,  "Not able to get volume uuid string..",  &v617,  v580);
        goto LABEL_433;
      }

LABEL_435:
      int v166 = 0LL;
LABEL_436:
      free(v166);
    }

LABEL_437:
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uid_t v167 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v167, OS_LOG_TYPE_DEFAULT))
    {
      value[0] = 0LL;
      unsigned int v168 = sub_100053B4C(1);
      if (os_log_type_enabled(v167, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v169 = v168;
      }
      else {
        uint64_t v169 = v168 & 0xFFFFFFFE;
      }
      if ((_DWORD)v169)
      {
        LOWORD(v617) = 0;
        LODWORD(v580) = 2;
        CFNumberRef v170 = (const char *)_os_log_send_and_compose_impl( v169,  value,  0LL,  0LL,  &_mh_execute_header,  v167,  0LL,  "Unable to find Usersession of the last booted user, returning error ENOENT",  &v617,  v580);
        int v171 = (char *)v170;
        if (v170) {
          sub_100053B7C(v170);
        }
      }

      else
      {
        int v171 = 0LL;
      }

      free(v171);
    }

    uint64_t v127 = 0xFFFFFFFFLL;
    uint64_t p_vtable = 2LL;
    if (!v0) {
      goto LABEL_482;
    }
    goto LABEL_481;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v149 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v149, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v617 = 0LL;
    unsigned int v150 = sub_100053B4C(1);
    if (os_log_type_enabled(v149, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v151 = v150;
    }
    else {
      uint64_t v151 = v150 & 0xFFFFFFFE;
    }
    if ((_DWORD)v151)
    {
      LODWORD(value[0]) = 138412290;
      *(void **)((char *)value + 4) = (void *)v0;
      LODWORD(v580) = 12;
      uint64_t v152 = (const char *)_os_log_send_and_compose_impl( v151,  &v617,  0LL,  0LL,  &_mh_execute_header,  v149,  0LL,  "Volume UUID String is %@",  value,  v580);
      uint64_t v153 = (char *)v152;
      if (v152) {
        sub_100053B7C(v152);
      }
    }

    else
    {
      uint64_t v153 = 0LL;
    }

    free(v153);
  }

  CFTypeRef v158 = sub_10001A2EC((const __CFString *)v0);
  if (!v158)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    CFNumberRef v154 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v154, OS_LOG_TYPE_DEFAULT))
    {
      value[0] = 0LL;
      unsigned int v164 = sub_100053B4C(1);
      if (os_log_type_enabled(v154, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v165 = v164;
      }
      else {
        uint64_t v165 = v164 & 0xFFFFFFFE;
      }
      if ((_DWORD)v165)
      {
        LOWORD(v617) = 0;
        LODWORD(v580) = 2;
        v157 = (const char *)_os_log_send_and_compose_impl( v165,  value,  0LL,  0LL,  &_mh_execute_header,  v154,  0LL,  "UNABLE to find user session for volume uuid..",  &v617,  v580);
LABEL_433:
        int v166 = (char *)v157;
        if (v157) {
          sub_100053B7C(v157);
        }
        goto LABEL_436;
      }

      goto LABEL_435;
    }

    goto LABEL_437;
  }

  CFNumberRef v159 = (void *)v158;
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v160 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v160, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v617 = 0LL;
    unsigned int v161 = sub_100053B4C(1);
    if (os_log_type_enabled(v160, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v162 = v161;
    }
    else {
      uint64_t v162 = v161 & 0xFFFFFFFE;
    }
    if ((_DWORD)v162)
    {
      LODWORD(value[0]) = 138412290;
      *(void **)((char *)value + 4) = v159;
      LODWORD(v580) = 12;
      unsigned int v163 = (const char *)_os_log_send_and_compose_impl( v162,  &v617,  0LL,  0LL,  &_mh_execute_header,  v160,  0LL,  "Found user session %@",  value,  v580);
      uint64_t v120 = (uint64_t)v163;
      if (v163) {
        sub_100053B7C(v163);
      }
    }

    else
    {
      uint64_t v120 = 0LL;
    }

    free((void *)v120);
    LODWORD(v120) = v587 | v586;
  }

  uint64_t v127 = sub_100083C6C((const __CFDictionary *)v159, kUMUserSessionIDKey);
  int v177 = v120;
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v120 = (uint64_t)(id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v120, OS_LOG_TYPE_DEFAULT))
  {
    value[0] = 0LL;
    unsigned int v178 = sub_100053B4C(1);
    if (os_log_type_enabled((os_log_t)v120, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v179 = v178;
    }
    else {
      uint64_t v179 = v178 & 0xFFFFFFFE;
    }
    if ((_DWORD)v179)
    {
      LODWORD(v617) = 67109120;
      HIDWORD(v617) = v127;
      unsigned int v180 = (const char *)_os_log_send_and_compose_impl( v179,  value,  0LL,  0LL,  &_mh_execute_header,  v120,  0LL,  "returning last booted user as %d",  &v617);
      v181 = (char *)v180;
      if (v180) {
        sub_100053B7C(v180);
      }
    }

    else
    {
      v181 = 0LL;
    }

    free(v181);
    uint64_t v2 = v586;
  }

  CFRelease(v159);
  uint64_t p_vtable = 0LL;
  LODWORD(v120) = v177;
LABEL_481:
  CFRelease((CFTypeRef)v0);
LABEL_482:
  if (uuid[0]) {
    CFRelease(uuid[0]);
  }
  if ((_DWORD)v127 == -1)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    v496 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v496, OS_LOG_TYPE_DEFAULT))
    {
      value[0] = 0LL;
      uint64_t v0 = sub_100053B4C(1);
      BOOL v514 = os_log_type_enabled(v496, OS_LOG_TYPE_DEFAULT);
      v515 = 0LL;
      if (v514) {
        uint64_t v516 = v0;
      }
      else {
        uint64_t v516 = v0 & 0xFFFFFFFE;
      }
      if ((_DWORD)v516)
      {
        *(_DWORD *)err = 67109120;
        *(_DWORD *)&err[4] = p_vtable;
        v517 = (const char *)_os_log_send_and_compose_impl( v516,  value,  0LL,  0LL,  &_mh_execute_header,  v496,  0LL,  "failed to find last booted user with error:%d",  err);
        v515 = 0LL;
        if (v517)
        {
          uint64_t v0 = (uint64_t)v517;
          sub_100053B7C(v517);
          v515 = (void *)v0;
        }
      }

      free(v515);
    }

    sleep(2u);
    uint64_t v498 = sub_100019F7C("UserManagement early boot taskfailed to find last booted user with error");
    goto LABEL_1319;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v182 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v182, OS_LOG_TYPE_DEFAULT))
  {
    value[0] = 0LL;
    unsigned int v183 = sub_100053B4C(1);
    if (os_log_type_enabled(v182, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v184 = v183;
    }
    else {
      uint64_t v184 = v183 & 0xFFFFFFFE;
    }
    if ((_DWORD)v184)
    {
      *(_DWORD *)err = 67109120;
      *(_DWORD *)&err[4] = v127;
      unsigned int v185 = (const char *)_os_log_send_and_compose_impl( v184,  value,  0LL,  0LL,  &_mh_execute_header,  v182,  0LL,  "LastBooted User is %d",  err);
      uint64_t p_vtable = (uint64_t)v185;
      if (v185) {
        sub_100053B7C(v185);
      }
    }

    else
    {
      uint64_t p_vtable = 0LL;
    }

    free((void *)p_vtable);
  }

LABEL_497:
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v0 = (uint64_t)(id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT))
  {
    int v186 = v120;
    value[0] = 0LL;
    unsigned int v187 = sub_100053B4C(1);
    uint64_t p_vtable = (uint64_t)(id)v0;
    if (os_log_type_enabled((os_log_t)p_vtable, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v188 = v187;
    }
    else {
      uint64_t v188 = v187 & 0xFFFFFFFE;
    }
    if ((_DWORD)v188)
    {
      *(_DWORD *)err = 67109120;
      *(_DWORD *)&err[4] = v127;
      uint64_t v120 = _os_log_send_and_compose_impl( v188,  value,  0LL,  0LL,  &_mh_execute_header,  p_vtable,  0LL,  "userToBoot is %d",  err);

      if (v120) {
        sub_100053B7C((const char *)v120);
      }
    }

    else
    {

      uint64_t v120 = 0LL;
    }

    free((void *)v120);
    LODWORD(v120) = v186;
  }

  if ([p_name[333] splitUserVolumeEnabled])
  {
    uuid[0] = 0LL;
    if ((_DWORD)v120)
    {
      if (v587)
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        uint64_t v0 = (uint64_t)(id)qword_1000DBA98;
        if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT))
        {
          char v189 = v120;
          value[0] = 0LL;
          unsigned int v190 = sub_100053B4C(1);
          v191 = (os_log_s *)(id)v0;
          if (os_log_type_enabled(v191, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v192 = v190;
          }
          else {
            uint64_t v192 = v190 & 0xFFFFFFFE;
          }
          if ((_DWORD)v192)
          {
            *(_WORD *)err = 0;
            LODWORD(v580) = 2;
            uint64_t v120 = _os_log_send_and_compose_impl( v192,  value,  0LL,  0LL,  &_mh_execute_header,  v191,  0LL,  "Update Install, getting user UUID to setup AKS",  err,  v580);

            if (v120) {
              sub_100053B7C((const char *)v120);
            }
          }

          else
          {

            uint64_t v120 = 0LL;
          }

          free((void *)v120);
          LOBYTE(v120) = v189;
        }
      }

      if (!(_DWORD)v2)
      {
LABEL_556:
        id v201 = sub_100054ED0(qword_1000DBA70, v127);
        uint64_t v202 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue(v201);
        if (v202)
        {
          uint64_t p_vtable = (uint64_t)v202;
          v203 = (const __CFString *)sub_100083DF4(v202, kUMUserSessionUUIDKey);
          if (!v203
            || (uint64_t v204 = v203,
                v205 = CFUUIDCreateFromString(kCFAllocatorDefault, v203),
                id v206 = sub_100017D48((uint64_t)&OBJC_CLASS___NSUUID, v205),
                uint64_t v207 = objc_claimAutoreleasedReturnValue(v206),
                (__int128 cf = v205) == 0LL))
          {
LABEL_1242:
            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            v493 = (os_log_s *)(id)qword_1000DBA98;
            if (!os_log_type_enabled(v493, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_1291;
            }
            value[0] = 0LL;
            uint64_t p_vtable = sub_100053B4C(1);
            uint64_t v0 = v493;
            if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v494 = p_vtable;
            }
            else {
              uint64_t v494 = p_vtable & 0xFFFFFFFE;
            }
            if (!(_DWORD)v494)
            {

              v495 = 0LL;
LABEL_1290:
              free(v495);
LABEL_1291:

              sleep(2u);
              sub_100019F7C("UserManagement early boot task unable to find uuid or create CFUUID of Update install user");
              goto LABEL_1292;
            }

LABEL_1288:
            *(_WORD *)err = 0;
            LODWORD(v580) = 2;
            uint64_t p_vtable = _os_log_send_and_compose_impl( v494,  value,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "Unable to find uuid or create CFUUID of Update install user",  err,  v580);

            v495 = 0LL;
            if (p_vtable)
            {
              sub_100053B7C((const char *)p_vtable);
              v495 = (void *)p_vtable;
            }

            goto LABEL_1290;
          }

          uint64_t v0 = v207;
          unsigned int v585 = v127;
          if (v587)
          {
            CFTypeRef v582 = (CFTypeRef)p_vtable;
            uint64_t p_vtable = (uint64_t)&OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            uint64_t v2 = (uint64_t)(id)qword_1000DBA98;
            if (os_log_type_enabled((os_log_t)v2, OS_LOG_TYPE_DEFAULT))
            {
              *(void *)err = 0LL;
              unsigned int v208 = sub_100053B4C(1);
              uid_t v209 = (os_log_s *)(id)v2;
              if (os_log_type_enabled(v209, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v210 = v208;
              }
              else {
                uint64_t v210 = v208 & 0xFFFFFFFE;
              }
              if ((_DWORD)v210)
              {
                LODWORD(value[0]) = 138412290;
                *(void **)((char *)value + 4) = v205;
                LODWORD(v580) = 12;
                unsigned int v211 = (char *)_os_log_send_and_compose_impl( v210,  err,  0LL,  0LL,  &_mh_execute_header,  v209,  0LL,  "Update Install: Migrating Primary User Identity to uuid:%@",  value,  v580);

                if (v211) {
                  sub_100053B7C(v211);
                }
              }

              else
              {

                unsigned int v211 = 0LL;
              }

              uint64_t v127 = v585;
              free(v211);
            }

            char v223 = AKSIdentityMigrateFirst(v205, uuid);
            BOOL v224 = qword_1000DBAA0 == -1;
            if ((v223 & 1) != 0)
            {
              if (qword_1000DBAA0 != -1) {
                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
              }
              id v225 = (id)qword_1000DBA98;
              if (os_log_type_enabled((os_log_t)v225, OS_LOG_TYPE_DEFAULT))
              {
                *(void *)err = 0LL;
                unsigned int v226 = sub_100053B4C(1);
                unsigned int v227 = (os_log_s *)v225;
                if (os_log_type_enabled(v227, OS_LOG_TYPE_DEFAULT)) {
                  uint64_t v228 = v226;
                }
                else {
                  uint64_t v228 = v226 & 0xFFFFFFFE;
                }
                if ((_DWORD)v228)
                {
                  LODWORD(value[0]) = 67109378;
                  HIDWORD(value[0]) = v585;
                  LOWORD(value[1]) = 2112;
                  *(void **)((char *)&value[1] + 2) = v205;
                  LODWORD(v580) = 18;
                  uint64_t v229 = (char *)_os_log_send_and_compose_impl( v228,  err,  0LL,  0LL,  &_mh_execute_header,  v227,  0LL,  "Update Install: Loading post migrateFirst, AKS Identity for User:%d, uuid:%@",  value,  v580);

                  if (v229) {
                    sub_100053B7C(v229);
                  }
                }

                else
                {

                  uint64_t v229 = 0LL;
                }

                free(v229);
                uint64_t v127 = v585;
              }

              id v596 = 0LL;
              int v230 = sub_100041468((void *)v0, v127, &v596);
              uint64_t v2 = (uint64_t)v596;
              if (!v230)
              {
                if (qword_1000DBAA0 != -1) {
                  dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                }
                id v500 = (id)qword_1000DBA98;
                if (!os_log_type_enabled((os_log_t)v500, OS_LOG_TYPE_DEFAULT))
                {
LABEL_1358:

                  int v533 = MGGetBoolAnswer(@"InternalBuild");
                  id v534 = [(id)v2 code];
                  if (v533) {
                    id v534 = (id)sub_100019F7C("UpdateInstall-FATAL OTI LOAD ERROR:%ld", v534);
                  }
                  sub_100037B90("UpdateInstall-FATAL OTI LOAD ERROR:%ld", v534);
                }

                *(void *)err = 0LL;
                LODWORD(p_vtable) = sub_100053B4C(1);
                uint64_t v0 = (uint64_t)v500;
                if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
                  uint64_t p_vtable = p_vtable;
                }
                else {
                  uint64_t p_vtable = p_vtable & 0xFFFFFFFE;
                }
                if (!(_DWORD)p_vtable)
                {

                  v513 = 0LL;
LABEL_1357:
                  free(v513);
                  goto LABEL_1358;
                }

LABEL_1355:
                id v531 = [(id)v2 code];
                LODWORD(value[0]) = 134217984;
                *(void **)((char *)value + 4) = v531;
                v532 = (const char *)_os_log_send_and_compose_impl( p_vtable,  err,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "AKSLoadIdentity failed with Error:%ld",  value);

                v513 = 0LL;
                if (v532)
                {
                  sub_100053B7C(v532);
                  v513 = (char *)v532;
                }

                goto LABEL_1357;
              }

              uint64_t p_vtable = (uint64_t)v582;
              if (qword_1000DBAA0 != -1) {
                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
              }
              uint64_t v127 = (uint64_t)(id)qword_1000DBA98;
              if (os_log_type_enabled((os_log_t)v127, OS_LOG_TYPE_DEFAULT))
              {
                value[0] = 0LL;
                unsigned int v231 = sub_100053B4C(1);
                unsigned int v232 = (os_log_s *)(id)v127;
                if (os_log_type_enabled(v232, OS_LOG_TYPE_DEFAULT)) {
                  uint64_t v233 = v231;
                }
                else {
                  uint64_t v233 = v231 & 0xFFFFFFFE;
                }
                if ((_DWORD)v233)
                {
                  *(_WORD *)err = 0;
                  LODWORD(v580) = 2;
                  uint64_t v234 = (char *)_os_log_send_and_compose_impl( v233,  value,  0LL,  0LL,  &_mh_execute_header,  v232,  0LL,  "AKSLoadIdentity Succeeded",  err,  v580);

                  if (v234) {
                    sub_100053B7C(v234);
                  }
                }

                else
                {

                  uint64_t v234 = 0LL;
                }

                free(v234);
              }

              sub_100037DF8("IONVRAM-DELETE-PROPERTY", "usermanagerd");
              LODWORD(v127) = v585;
              uint64_t v2 = v586;
              if (dword_1000DBCE8 != 1) {
                goto LABEL_846;
              }
              __int128 v615 = 0u;
              __int128 v616 = 0u;
              __int128 v613 = 0u;
              __int128 v614 = 0u;
              __int128 v611 = 0u;
              __int128 v612 = 0u;
              __int128 v609 = 0u;
              __int128 v610 = 0u;
              __int128 v607 = 0u;
              __int128 v608 = 0u;
              __int128 v605 = 0u;
              __int128 v606 = 0u;
              __int128 v603 = 0u;
              __int128 v604 = 0u;
              memset(value, 0, sizeof(value));
              if (qword_1000DBAA0 != -1) {
                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
              }
              id v235 = (id)qword_1000DBA98;
              if (os_log_type_enabled((os_log_t)v235, OS_LOG_TYPE_DEFAULT))
              {
                *(void *)err = 0LL;
                unsigned int v236 = sub_100053B4C(1);
                unsigned int v237 = (os_log_s *)v235;
                if (os_log_type_enabled(v237, OS_LOG_TYPE_DEFAULT)) {
                  uint64_t v238 = v236;
                }
                else {
                  uint64_t v238 = v236 & 0xFFFFFFFE;
                }
                if ((_DWORD)v238)
                {
                  LOWORD(v617) = 0;
                  LODWORD(v580) = 2;
                  uint64_t v239 = (char *)_os_log_send_and_compose_impl( v238,  err,  0LL,  0LL,  &_mh_execute_header,  v237,  0LL,  "Trying to find User volume on shared iPad",  &v617,  v580);

                  if (v239) {
                    sub_100053B7C(v239);
                  }
                }

                else
                {

                  uint64_t v239 = 0LL;
                }

                LODWORD(v127) = v585;
                free(v239);
              }

              if (!sub_100077C4C((char *)value, 256LL))
              {
                if (qword_1000DBAA0 != -1) {
                  dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                }
                uint64_t p_vtable = (uint64_t)v582;
                id v278 = (id)qword_1000DBA98;
                if (!os_log_type_enabled((os_log_t)v278, OS_LOG_TYPE_DEFAULT))
                {
LABEL_845:

                  uint64_t v2 = v586;
                  if (dword_1000DBCE8 == 1)
                  {
LABEL_891:
                    CFRelease(v205);
                    CFRelease((CFTypeRef)p_vtable);
                    if (uuid[0])
                    {
                      CFRelease(uuid[0]);
                      id v272 = 0LL;
LABEL_1146:
                      uuid[0] = 0LL;
                      goto LABEL_1147;
                    }

                    id v272 = 0LL;
                    goto LABEL_1147;
                  }

LABEL_846:
                  if (!CFDictionaryContainsValue((CFDictionaryRef)p_vtable, kUMUserSessionKeybagOpaqueDataKey))
                  {
                    value[0] = 0LL;
                    if (qword_1000DBAA0 != -1) {
                      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                    }
                    id v339 = (id)qword_1000DBA98;
                    if (os_log_type_enabled((os_log_t)v339, OS_LOG_TYPE_DEFAULT))
                    {
                      *(void *)err = 0LL;
                      unsigned int v340 = sub_100053B4C(1);
                      v341 = (os_log_s *)v339;
                      if (os_log_type_enabled(v341, OS_LOG_TYPE_DEFAULT)) {
                        uint64_t v342 = v340;
                      }
                      else {
                        uint64_t v342 = v340 & 0xFFFFFFFE;
                      }
                      if ((_DWORD)v342)
                      {
                        LOWORD(v617) = 0;
                        LODWORD(v580) = 2;
                        CFIndex v343 = (char *)_os_log_send_and_compose_impl( v342,  err,  0LL,  0LL,  &_mh_execute_header,  v341,  0LL,  "No keybag data on the user session, trying to migrate from Keybag if it exists",  &v617,  v580);

                        if (v343) {
                          sub_100053B7C(v343);
                        }
                      }

                      else
                      {

                        CFIndex v343 = 0LL;
                      }

                      free(v343);
                    }

                    int v344 = MKBKeyBagCopySystemOpaqueBlob(value);
                    if (v344)
                    {
                      int v345 = v344;
                      if (qword_1000DBAA0 != -1) {
                        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                      }
                      id v346 = (id)qword_1000DBA98;
                      if (os_log_type_enabled((os_log_t)v346, OS_LOG_TYPE_DEFAULT))
                      {
                        *(void *)err = 0LL;
                        unsigned int v347 = sub_100053B4C(1);
                        v348 = (os_log_s *)v346;
                        if (os_log_type_enabled(v348, OS_LOG_TYPE_DEFAULT)) {
                          uint64_t v349 = v347;
                        }
                        else {
                          uint64_t v349 = v347 & 0xFFFFFFFE;
                        }
                        if ((_DWORD)v349)
                        {
                          LODWORD(v617) = 67109120;
                          HIDWORD(v617) = v345;
                          v350 = (char *)_os_log_send_and_compose_impl( v349,  err,  0LL,  0LL,  &_mh_execute_header,  v348,  0LL,  "Failed to retrieve KeybagData from MKB with error:%d",  &v617);

                          if (v350) {
                            sub_100053B7C(v350);
                          }
                        }

                        else
                        {

                          v350 = 0LL;
                        }

                        free(v350);
                      }

                      LODWORD(v127) = v585;
                    }

                    else if (value[0])
                    {
                      CFDictionarySetValue( (CFMutableDictionaryRef)p_vtable,  kUMUserSessionKeybagOpaqueDataKey,  value[0]);
                      LODWORD(v127) = v585;
                      if (qword_1000DBAA0 != -1) {
                        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                      }
                      id v351 = (id)qword_1000DBA98;
                      if (os_log_type_enabled((os_log_t)v351, OS_LOG_TYPE_DEFAULT))
                      {
                        *(void *)err = 0LL;
                        unsigned int v352 = sub_100053B4C(1);
                        v353 = (os_log_s *)v351;
                        if (os_log_type_enabled(v353, OS_LOG_TYPE_DEFAULT)) {
                          uint64_t v354 = v352;
                        }
                        else {
                          uint64_t v354 = v352 & 0xFFFFFFFE;
                        }
                        if ((_DWORD)v354)
                        {
                          LODWORD(v617) = 67109120;
                          HIDWORD(v617) = v585;
                          v355 = (char *)_os_log_send_and_compose_impl( v354,  err,  0LL,  0LL,  &_mh_execute_header,  v353,  0LL,  "Saved keybag Data for the user:%d",  &v617);

                          if (v355) {
                            sub_100053B7C(v355);
                          }
                        }

                        else
                        {

                          v355 = 0LL;
                        }

                        free(v355);
                        LODWORD(v127) = v585;
                      }

                      sub_10001AED4();
                      if (value[0]) {
                        CFRelease(value[0]);
                      }
                    }

                    else
                    {
                      LODWORD(v127) = v585;
                      if (qword_1000DBAA0 != -1) {
                        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                      }
                      id v356 = (id)qword_1000DBA98;
                      if (os_log_type_enabled((os_log_t)v356, OS_LOG_TYPE_DEFAULT))
                      {
                        *(void *)err = 0LL;
                        unsigned int v357 = sub_100053B4C(1);
                        v358 = (os_log_s *)v356;
                        if (os_log_type_enabled(v358, OS_LOG_TYPE_DEFAULT)) {
                          uint64_t v359 = v357;
                        }
                        else {
                          uint64_t v359 = v357 & 0xFFFFFFFE;
                        }
                        if ((_DWORD)v359)
                        {
                          LOWORD(v617) = 0;
                          LODWORD(v580) = 2;
                          v360 = (char *)_os_log_send_and_compose_impl( v359,  err,  0LL,  0LL,  &_mh_execute_header,  v358,  0LL,  "NO keybag Data on the system",  &v617,  v580);

                          if (v360) {
                            sub_100053B7C(v360);
                          }
                        }

                        else
                        {

                          v360 = 0LL;
                        }

                        LODWORD(v127) = v585;
                        free(v360);
                      }
                    }

                    uint64_t v2 = v586;
                  }

                  goto LABEL_891;
                }

                *(void *)err = 0LL;
                unsigned int v279 = sub_100053B4C(1);
                id v278 = v278;
                if (os_log_type_enabled((os_log_t)v278, OS_LOG_TYPE_DEFAULT)) {
                  uint64_t v280 = v279;
                }
                else {
                  uint64_t v280 = v279 & 0xFFFFFFFE;
                }
                if ((_DWORD)v280)
                {
                  LOWORD(v617) = 0;
                  LODWORD(v580) = 2;
                  uint64_t v281 = (char *)_os_log_send_and_compose_impl( v280,  err,  0LL,  0LL,  &_mh_execute_header,  v278,  0LL,  "Could not find Primary User Volume..",  &v617,  v580);

                  if (v281) {
                    sub_100053B7C(v281);
                  }
                }

                else
                {

                  uint64_t v281 = 0LL;
                }

                free(v281);
LABEL_844:
                LODWORD(v127) = v585;
                goto LABEL_845;
              }

              if (qword_1000DBAA0 != -1) {
                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
              }
              id v273 = (id)qword_1000DBA98;
              if (os_log_type_enabled((os_log_t)v273, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v617 = 0LL;
                unsigned int v274 = sub_100053B4C(1);
                v275 = (os_log_s *)v273;
                if (os_log_type_enabled(v275, OS_LOG_TYPE_DEFAULT)) {
                  uint64_t v276 = v274;
                }
                else {
                  uint64_t v276 = v274 & 0xFFFFFFFE;
                }
                if ((_DWORD)v276)
                {
                  *(_DWORD *)err = 136315138;
                  *(void *)&err[4] = value;
                  uid_t v277 = (char *)_os_log_send_and_compose_impl( v276,  &v617,  0LL,  0LL,  &_mh_execute_header,  v275,  0LL,  "Found Primary UserVolume disknode:%s",  err);

                  if (v277) {
                    sub_100053B7C(v277);
                  }
                }

                else
                {

                  uid_t v277 = 0LL;
                }

                free(v277);
              }

              id v278 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", value));
              if (!v278)
              {
                uint64_t p_vtable = (uint64_t)v582;
                if (qword_1000DBAA0 != -1) {
                  dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                }
                id v287 = (id)qword_1000DBA98;
                if (os_log_type_enabled((os_log_t)v287, OS_LOG_TYPE_DEFAULT))
                {
                  *(void *)err = 0LL;
                  unsigned int v288 = sub_100053B4C(1);
                  id v287 = v287;
                  if (os_log_type_enabled((os_log_t)v287, OS_LOG_TYPE_DEFAULT)) {
                    uint64_t v289 = v288;
                  }
                  else {
                    uint64_t v289 = v288 & 0xFFFFFFFE;
                  }
                  if ((_DWORD)v289)
                  {
                    LOWORD(v617) = 0;
                    LODWORD(v580) = 2;
                    uint64_t v290 = (char *)_os_log_send_and_compose_impl( v289,  err,  0LL,  0LL,  &_mh_execute_header,  v287,  0LL,  "Failed to created diskstring",  &v617,  v580);

                    if (v290) {
                      sub_100053B7C(v290);
                    }
                  }

                  else
                  {

                    uint64_t v290 = 0LL;
                  }

                  free(v290);
                }

                goto LABEL_843;
              }

              if (qword_1000DBAA0 != -1) {
                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
              }
              id v282 = (id)qword_1000DBA98;
              if (os_log_type_enabled((os_log_t)v282, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v617 = 0LL;
                unsigned int v283 = sub_100053B4C(1);
                v284 = (os_log_s *)v282;
                if (os_log_type_enabled(v284, OS_LOG_TYPE_DEFAULT)) {
                  uint64_t v285 = v283;
                }
                else {
                  uint64_t v285 = v283 & 0xFFFFFFFE;
                }
                if ((_DWORD)v285)
                {
                  *(_DWORD *)err = 138412546;
                  *(void *)&err[4] = v278;
                  __int16 v600 = 1024;
                  unsigned int v601 = v585;
                  LODWORD(v580) = 18;
                  id v286 = (char *)_os_log_send_and_compose_impl( v285,  &v617,  0LL,  0LL,  &_mh_execute_header,  v284,  0LL,  "Calling AKSVolumeMap with disk:%@ for useruid:%d",  err,  v580);

                  if (v286) {
                    sub_100053B7C(v286);
                  }
                }

                else
                {

                  id v286 = 0LL;
                }

                free(v286);
              }

              uint64_t v291 = sub_100019B18(qword_1000DBD40);
              v292 = (void *)objc_claimAutoreleasedReturnValue(v291);
              id v595 = 0LL;
              unsigned int v293 = [v292 mapVolume:v278 toSession:v585 withPersona:0 error:&v595];
              id v287 = v595;

              if (v293)
              {
                if (qword_1000DBAA0 != -1) {
                  dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                }
                uint64_t v294 = (os_log_s *)(id)qword_1000DBA98;
                if (!os_log_type_enabled(v294, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_749;
                }
                char v295 = v120;
                uint64_t v120 = v11;
                *(void *)err = 0LL;
                unsigned int v296 = sub_100053B4C(1);
                id v297 = v294;
                if (os_log_type_enabled(v297, OS_LOG_TYPE_DEFAULT)) {
                  uint64_t v298 = v296;
                }
                else {
                  uint64_t v298 = v296 & 0xFFFFFFFE;
                }
                if ((_DWORD)v298)
                {
                  LOWORD(v617) = 0;
                  uint64_t v299 = _os_log_send_and_compose_impl( v298,  err,  0LL,  0LL,  &_mh_execute_header,  v297,  0LL,  "AKS VolumeMapPath Success");
                  goto LABEL_745;
                }
              }

              else
              {
                if (qword_1000DBAA0 != -1) {
                  dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                }
                uint64_t v294 = (os_log_s *)(id)qword_1000DBA98;
                if (!os_log_type_enabled(v294, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_749;
                }
                char v295 = v120;
                uint64_t v120 = v11;
                uint64_t v617 = 0LL;
                LODWORD(v11) = sub_100053B4C(1);
                id v297 = v294;
                if (os_log_type_enabled(v297, OS_LOG_TYPE_DEFAULT)) {
                  unint64_t v11 = v11;
                }
                else {
                  unint64_t v11 = v11 & 0xFFFFFFFE;
                }
                if ((_DWORD)v11)
                {
                  id v300 = [v287 code];
                  *(_DWORD *)err = 134217984;
                  *(void *)&err[4] = v300;
                  uint64_t v299 = _os_log_send_and_compose_impl( v11,  &v617,  0LL,  0LL,  &_mh_execute_header,  v297,  0LL,  "AKS VolumeMap failed with %ld",  err);
LABEL_745:
                  uint64_t v301 = (char *)v299;

                  if (v301) {
                    sub_100053B7C(v301);
                  }
                  goto LABEL_748;
                }
              }

              uint64_t v301 = 0LL;
LABEL_748:
              free(v301);
              unint64_t v11 = v120;
              LOBYTE(v120) = v295;
LABEL_749:

              uint64_t p_vtable = (uint64_t)v582;
LABEL_843:

              goto LABEL_844;
            }

LABEL_1292:
            if (!v224) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            id v500 = (id)qword_1000DBA98;
            if (!os_log_type_enabled((os_log_t)v500, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_1354;
            }
            value[0] = 0LL;
            LODWORD(p_vtable) = sub_100053B4C(1);
            uint64_t v0 = (uint64_t)v500;
            if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
              uint64_t p_vtable = p_vtable;
            }
            else {
              uint64_t p_vtable = p_vtable & 0xFFFFFFFE;
            }
            if (!(_DWORD)p_vtable)
            {

              v512 = 0LL;
LABEL_1353:
              free(v512);
LABEL_1354:

              sleep(2u);
              sub_100019F7C("UserManagement early boot task failed to migrate Primary User AKSIdentity during update install");
              goto LABEL_1355;
            }

LABEL_1351:
            int v530 = CFErrorGetCode(uuid[0]);
            *(_DWORD *)err = 67109120;
            *(_DWORD *)&err[4] = v530;
            uint64_t p_vtable = _os_log_send_and_compose_impl( p_vtable,  value,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "AKSIdentityMigrateFirst failed with error:%d",  err);

            v512 = 0LL;
            if (p_vtable)
            {
              sub_100053B7C((const char *)p_vtable);
              v512 = (void *)p_vtable;
            }

            goto LABEL_1353;
          }

          if ((_DWORD)v2)
          {
            LODWORD(v617) = 0;
            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            id v212 = (id)qword_1000DBA98;
            if (os_log_type_enabled((os_log_t)v212, OS_LOG_TYPE_DEFAULT))
            {
              *(void *)err = 0LL;
              unsigned int v213 = sub_100053B4C(1);
              v214 = (os_log_s *)v212;
              if (os_log_type_enabled(v214, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v215 = v213;
              }
              else {
                uint64_t v215 = v213 & 0xFFFFFFFE;
              }
              if ((_DWORD)v215)
              {
                LODWORD(value[0]) = 67109378;
                HIDWORD(value[0]) = v585;
                LOWORD(value[1]) = 2112;
                *(void **)((char *)&value[1] + 2) = v205;
                LODWORD(v580) = 18;
                v216 = (char *)_os_log_send_and_compose_impl( v215,  err,  0LL,  0LL,  &_mh_execute_header,  v214,  0LL,  "Erase Install: Setting up AKS Identity for User:%d, uuid:%@",  value,  v580);

                if (v216) {
                  sub_100053B7C(v216);
                }
              }

              else
              {

                v216 = 0LL;
              }

              free(v216);
              uint64_t v127 = v585;
            }

            id v594 = 0LL;
            int v240 = sub_100041468((void *)v0, v127, &v594);
            uint64_t v2 = (uint64_t)v594;
            BOOL v241 = qword_1000DBAA0 == -1;
            if (v240)
            {
              if (qword_1000DBAA0 != -1) {
                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
              }
              id v242 = (id)qword_1000DBA98;
              if (os_log_type_enabled((os_log_t)v242, OS_LOG_TYPE_DEFAULT))
              {
                value[0] = 0LL;
                unsigned int v243 = sub_100053B4C(1);
                unsigned int v244 = (os_log_s *)v242;
                if (os_log_type_enabled(v244, OS_LOG_TYPE_DEFAULT)) {
                  uint64_t v245 = v243;
                }
                else {
                  uint64_t v245 = v243 & 0xFFFFFFFE;
                }
                if ((_DWORD)v245)
                {
                  *(_WORD *)err = 0;
                  LODWORD(v580) = 2;
                  v246 = (char *)_os_log_send_and_compose_impl( v245,  value,  0LL,  0LL,  &_mh_execute_header,  v244,  0LL,  "AKSLoadIdentity Succeeded",  err,  v580);

                  if (v246) {
                    sub_100053B7C(v246);
                  }
                }

                else
                {

                  v246 = 0LL;
                }

                free(v246);
              }

              sub_100037DF8("IONVRAM-DELETE-PROPERTY", "usermanagerd");
              CFRelease((CFTypeRef)p_vtable);
              CFRelease(v205);

              uint64_t v48 = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
              if (qword_1000DBAA0 != -1) {
                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
              }
              LODWORD(v127) = v585;
              uint64_t p_vtable = (uint64_t)(id)qword_1000DBA98;
              if (os_log_type_enabled((os_log_t)p_vtable, OS_LOG_TYPE_DEFAULT))
              {
                char v255 = v120;
                value[0] = 0LL;
                unsigned int v256 = sub_100053B4C(1);
                v257 = (os_log_s *)(id)p_vtable;
                if (os_log_type_enabled(v257, OS_LOG_TYPE_DEFAULT)) {
                  uint64_t v258 = v256;
                }
                else {
                  uint64_t v258 = v256 & 0xFFFFFFFE;
                }
                if ((_DWORD)v258)
                {
                  *(_WORD *)err = 0;
                  LODWORD(v580) = 2;
                  uint64_t v259 = (char *)_os_log_send_and_compose_impl( v258,  value,  0LL,  0LL,  &_mh_execute_header,  v257,  0LL,  "Migrating UserVolume Media Key to Class C after Volume Map",  err,  v580);

                  if (v259) {
                    sub_100053B7C(v259);
                  }
                }

                else
                {

                  uint64_t v259 = 0LL;
                }

                LOBYTE(v120) = v255;
                free(v259);
              }

              uint64_t v2 = v586;
              if (sub_10007D838(1, &v617))
              {
                id v272 = 0LL;
LABEL_1148:
                if (*((_DWORD *)v48 + 826) != 1)
                {
                  int v463 = (v120 & 1) != 0 || *(_BYTE *)v11 != 0;
                  sub_10003818C(v127, v463);
                }

                p_name = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
                goto LABEL_1154;
              }

              if (qword_1000DBAA0 != -1) {
                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
              }
              id v527 = (id)qword_1000DBA98;
              if (os_log_type_enabled((os_log_t)v527, OS_LOG_TYPE_DEFAULT))
              {
                value[0] = 0LL;
                uint64_t p_vtable = sub_100053B4C(1);
                uint64_t v0 = (uint64_t)v527;
                if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
                  uint64_t v528 = p_vtable;
                }
                else {
                  uint64_t v528 = p_vtable & 0xFFFFFFFE;
                }
                if ((_DWORD)v528)
                {
                  *(_DWORD *)err = 67109120;
                  *(_DWORD *)&err[4] = v617;
                  uint64_t p_vtable = _os_log_send_and_compose_impl( v528,  value,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "APFSVolumeMigrateMediaKey Failed with Error:%d, PANIC!!",  err);

                  v529 = 0LL;
                  if (p_vtable)
                  {
                    sub_100053B7C((const char *)p_vtable);
                    v529 = (void *)p_vtable;
                  }
                }

                else
                {

                  v529 = 0LL;
                }

                free(v529);
              }

              sleep(2u);
              if (qword_1000DBAA0 != -1) {
                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
              }
              id v565 = (id)qword_1000DBA98;
              if (os_log_type_enabled((os_log_t)v565, OS_LOG_TYPE_DEFAULT))
              {
                value[0] = 0LL;
                uint64_t p_vtable = sub_100053B4C(1);
                uint64_t v0 = (uint64_t)v565;
                if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
                  uint64_t v566 = p_vtable;
                }
                else {
                  uint64_t v566 = p_vtable & 0xFFFFFFFE;
                }
                if ((_DWORD)v566)
                {
                  *(_WORD *)err = 0;
                  LODWORD(v580) = 2;
                  uint64_t p_vtable = _os_log_send_and_compose_impl( v566,  value,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "CALLING PANIC!!",  err,  v580);

                  v567 = 0LL;
                  if (p_vtable)
                  {
                    sub_100053B7C((const char *)p_vtable);
                    v567 = (void *)p_vtable;
                  }
                }

                else
                {

                  v567 = 0LL;
                }

                free(v567);
              }

              sub_100019F7C("UserManagement early boot task APFSVolumeMigrateMediaKey Failed with Error:%d", v617);
LABEL_1452:
              if (!v370) {
                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
              }
              v535 = (os_log_s *)(id)qword_1000DBA98;
              if (!os_log_type_enabled(v535, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_1495;
              }
              value[0] = 0LL;
              uint64_t p_vtable = sub_100053B4C(1);
              uint64_t v0 = v535;
              if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v568 = p_vtable;
              }
              else {
                uint64_t v568 = p_vtable & 0xFFFFFFFE;
              }
              if (!(_DWORD)v568)
              {

                v569 = 0LL;
LABEL_1494:
                free(v569);
LABEL_1495:

                sleep(2u);
                sub_100019F7C("Failed to unmount 501 User Volume error:%d", v617);
                goto LABEL_1496;
              }

LABEL_1492:
              *(_DWORD *)err = 67109120;
              *(_DWORD *)&err[4] = v617;
              uint64_t p_vtable = _os_log_send_and_compose_impl( v568,  value,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "Failed unmount of 501 User Volume,error:%d",  err);

              v569 = 0LL;
              if (p_vtable)
              {
                sub_100053B7C((const char *)p_vtable);
                v569 = (void *)p_vtable;
              }

              goto LABEL_1494;
            }

LABEL_1323:
            if (!v241) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            id v519 = (id)qword_1000DBA98;
            if (os_log_type_enabled((os_log_t)v519, OS_LOG_TYPE_DEFAULT))
            {
              *(void *)err = 0LL;
              LODWORD(v520) = sub_100053B4C(1);
              v521 = (os_log_s *)v519;
              if (os_log_type_enabled(v521, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v520 = v520;
              }
              else {
                uint64_t v520 = v520 & 0xFFFFFFFE;
              }
              if ((_DWORD)v520)
              {
                id v557 = [(id)v2 code];
                LODWORD(value[0]) = 134217984;
                *(void **)((char *)value + 4) = v557;
                v558 = (const char *)_os_log_send_and_compose_impl( v520,  err,  0LL,  0LL,  &_mh_execute_header,  v521,  0LL,  "AKSLoadIdentity failed with Error:%ld",  value);

                v522 = 0LL;
                if (v558)
                {
                  sub_100053B7C(v558);
                  v522 = (char *)v558;
                }
              }

              else
              {

                v522 = 0LL;
              }

              free(v522);
            }

            int v559 = MGGetBoolAnswer(@"InternalBuild");
            id v560 = [(id)v2 code];
            if (v559) {
              id v560 = (id)sub_100019F7C("EraseInstall-FATAL OTI LOAD ERROR:%ld", v560);
            }
            sub_100037B90("EraseInstall-FATAL OTI LOAD ERROR:%ld", v560);
          }

          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          id v217 = (id)qword_1000DBA98;
          if (os_log_type_enabled((os_log_t)v217, OS_LOG_TYPE_DEFAULT))
          {
            char v218 = v120;
            uint64_t v120 = v11;
            *(void *)err = 0LL;
            unsigned int v219 = sub_100053B4C(1);
            uint64_t v220 = (os_log_s *)v217;
            if (os_log_type_enabled(v220, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v221 = v219;
            }
            else {
              uint64_t v221 = v219 & 0xFFFFFFFE;
            }
            if ((_DWORD)v221)
            {
              LODWORD(value[0]) = 67109378;
              HIDWORD(value[0]) = v585;
              LOWORD(value[1]) = 2112;
              *(void **)((char *)&value[1] + 2) = cf;
              LODWORD(v580) = 18;
              CFStringRef v222 = (char *)_os_log_send_and_compose_impl( v221,  err,  0LL,  0LL,  &_mh_execute_header,  v220,  0LL,  "Normal Boot: Setting up AKS Identity for User:%d, uuid:%@",  value,  v580);

              if (v222) {
                sub_100053B7C(v222);
              }
            }

            else
            {

              CFStringRef v222 = 0LL;
            }

            free(v222);
            unint64_t v11 = v120;
            LOBYTE(v120) = v218;
            uint64_t v127 = v585;
          }

          id v593 = 0LL;
          int v247 = sub_100041468((void *)v0, v127, &v593);
          id v248 = v593;
          if (!v247)
          {
            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            id v523 = (id)qword_1000DBA98;
            if (os_log_type_enabled((os_log_t)v523, OS_LOG_TYPE_DEFAULT))
            {
              *(void *)err = 0LL;
              LODWORD(v524) = sub_100053B4C(1);
              v525 = (os_log_s *)v523;
              if (os_log_type_enabled(v525, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v524 = v524;
              }
              else {
                uint64_t v524 = v524 & 0xFFFFFFFE;
              }
              if ((_DWORD)v524)
              {
                id v561 = [v248 code];
                LODWORD(value[0]) = 134217984;
                *(void **)((char *)value + 4) = v561;
                v562 = (const char *)_os_log_send_and_compose_impl( v524,  err,  0LL,  0LL,  &_mh_execute_header,  v525,  0LL,  "AKSLoadIdentity failed with Error:%ld",  value);

                v526 = 0LL;
                if (v562)
                {
                  sub_100053B7C(v562);
                  v526 = (char *)v562;
                }
              }

              else
              {

                v526 = 0LL;
              }

              free(v526);
            }

            int v563 = MGGetBoolAnswer(@"InternalBuild");
            id v564 = [v248 code];
            if (v563) {
              id v564 = (id)sub_100019F7C("RegularBoot-FATAL OTI LOAD ERROR:%ld", v564);
            }
            sub_100037B90("RegularBoot-FATAL OTI LOAD ERROR:%ld", v564);
          }

          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          id v249 = (id)qword_1000DBA98;
          if (os_log_type_enabled((os_log_t)v249, OS_LOG_TYPE_DEFAULT))
          {
            CFNumberRef v250 = (char **)v11;
            value[0] = 0LL;
            unsigned int v251 = sub_100053B4C(1);
            int v252 = (os_log_s *)v249;
            if (os_log_type_enabled(v252, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v253 = v251;
            }
            else {
              uint64_t v253 = v251 & 0xFFFFFFFE;
            }
            if ((_DWORD)v253)
            {
              *(_WORD *)err = 0;
              LODWORD(v580) = 2;
              v254 = (char *)_os_log_send_and_compose_impl( v253,  value,  0LL,  0LL,  &_mh_execute_header,  v252,  0LL,  "AKSLoadIdentity Succeeded",  err,  v580);

              if (v254) {
                sub_100053B7C(v254);
              }
            }

            else
            {

              v254 = 0LL;
            }

            unint64_t v11 = (unint64_t)v250;
            free(v254);
          }

          sub_100037DF8("IONVRAM-DELETE-PROPERTY", "usermanagerd");
          if (dword_1000DBCE8 != 1)
          {
            id v272 = 0LL;
            uint64_t v2 = v586;
LABEL_1143:
            LODWORD(v127) = v585;
LABEL_1144:
            CFRelease((CFTypeRef)p_vtable);
            CFRelease(cf);
            if (uuid[0])
            {
              CFRelease(uuid[0]);
              goto LABEL_1146;
            }

LABEL_1147:
            uint64_t v48 = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
            goto LABEL_1148;
          }

          uint64_t v127 = v585;
          uint64_t v2 = v586;
          if (!sub_100083DA4((const __CFDictionary *)p_vtable, kUMUserSessionNeedsCryptoSetupKey))
          {
            id v272 = 0LL;
            goto LABEL_1144;
          }

          id v260 = sub_100054ED0(qword_1000DBA70, 501);
          uint64_t v261 = objc_claimAutoreleasedReturnValue(v260);
          if (v261)
          {
            uint64_t v262 = (const __CFDictionary *)v261;
            UInt8 bytes = 0;
            LODWORD(v617) = 0;
            CFDataRef v581 = CFDataCreate(kCFAllocatorDefault, &bytes, 1LL);
            unsigned int v263 = (const __CFString *)sub_100083DF4(v262, kUMUserSessionUUIDKey);
            if (v263)
            {
              uint64_t v264 = CFUUIDCreateFromString(kCFAllocatorDefault, v263);
              if (v264)
              {
                uint64_t v2 = (uint64_t)v264;
                id v265 = sub_100017D48((uint64_t)&OBJC_CLASS___NSUUID, v264);
                v266 = (void *)objc_claimAutoreleasedReturnValue(v265);
                CFRelease((CFTypeRef)v2);
                if (v266)
                {
                  v583 = v262;
                  if (qword_1000DBAA0 != -1) {
                    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                  }
                  id v267 = (id)qword_1000DBA98;
                  if (os_log_type_enabled((os_log_t)v267, OS_LOG_TYPE_DEFAULT))
                  {
                    value[0] = 0LL;
                    unsigned int v268 = sub_100053B4C(1);
                    v269 = (os_log_s *)v267;
                    if (os_log_type_enabled(v269, OS_LOG_TYPE_DEFAULT)) {
                      uint64_t v270 = v268;
                    }
                    else {
                      uint64_t v270 = v268 & 0xFFFFFFFE;
                    }
                    if ((_DWORD)v270)
                    {
                      *(_WORD *)err = 0;
                      LODWORD(v580) = 2;
                      v271 = (char *)_os_log_send_and_compose_impl( v270,  value,  0LL,  0LL,  &_mh_execute_header,  v269,  0LL,  "Verifying 501 OTI is loaded",  err,  v580);

                      if (v271) {
                        sub_100053B7C(v271);
                      }
                    }

                    else
                    {

                      v271 = 0LL;
                    }

                    free(v271);
                  }

                  id v591 = 0LL;
                  uint64_t v2 = sub_100041468(v266, 501LL, &v591);
                  id v302 = v591;
                  if ((_DWORD)v2)
                  {
                    v303 = v302;
                    if (qword_1000DBAA0 != -1) {
                      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                    }
                    id v304 = (id)qword_1000DBA98;
                    if (os_log_type_enabled((os_log_t)v304, OS_LOG_TYPE_DEFAULT))
                    {
                      value[0] = 0LL;
                      unsigned int v305 = sub_100053B4C(1);
                      uint64_t v2 = (uint64_t)v304;
                      if (os_log_type_enabled((os_log_t)v2, OS_LOG_TYPE_DEFAULT)) {
                        uint64_t v306 = v305;
                      }
                      else {
                        uint64_t v306 = v305 & 0xFFFFFFFE;
                      }
                      if ((_DWORD)v306)
                      {
                        *(_WORD *)err = 0;
                        LODWORD(v580) = 2;
                        v307 = (char *)_os_log_send_and_compose_impl( v306,  value,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "501 user Identity is loaded",  err,  v580);

                        if (v307) {
                          sub_100053B7C(v307);
                        }
                      }

                      else
                      {

                        v307 = 0LL;
                      }

                      free(v307);
                      uint64_t v127 = v585;
                    }

                    if (qword_1000DBAA0 != -1) {
                      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                    }
                    id v308 = v583;
                    id v309 = (id)qword_1000DBA98;
                    if (os_log_type_enabled((os_log_t)v309, OS_LOG_TYPE_DEFAULT))
                    {
                      value[0] = 0LL;
                      unsigned int v310 = sub_100053B4C(1);
                      uint64_t v311 = (os_log_s *)v309;
                      if (os_log_type_enabled(v311, OS_LOG_TYPE_DEFAULT)) {
                        uint64_t v312 = v310;
                      }
                      else {
                        uint64_t v312 = v310 & 0xFFFFFFFE;
                      }
                      if ((_DWORD)v312)
                      {
                        *(_DWORD *)err = 67109120;
                        *(_DWORD *)&err[4] = v127;
                        uint64_t v2 = _os_log_send_and_compose_impl( v312,  value,  0LL,  0LL,  &_mh_execute_header,  v311,  0LL,  "Transfer OTI from 501 to uid:%d",  err);

                        if (v2) {
                          sub_100053B7C((const char *)v2);
                        }
                      }

                      else
                      {

                        uint64_t v2 = 0LL;
                      }

                      id v308 = v583;
                      free((void *)v2);
                    }

                    if ((AKSIdentityTransferPrimary(501LL, v581, v127, v581, uuid) & 1) != 0)
                    {
                      if (qword_1000DBAA0 != -1) {
                        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                      }
                      id v313 = (id)qword_1000DBA98;
                      if (os_log_type_enabled((os_log_t)v313, OS_LOG_TYPE_DEFAULT))
                      {
                        value[0] = 0LL;
                        unsigned int v314 = sub_100053B4C(1);
                        uint64_t v2 = (uint64_t)v313;
                        if (os_log_type_enabled((os_log_t)v2, OS_LOG_TYPE_DEFAULT)) {
                          uint64_t v315 = v314;
                        }
                        else {
                          uint64_t v315 = v314 & 0xFFFFFFFE;
                        }
                        if ((_DWORD)v315)
                        {
                          *(_WORD *)err = 0;
                          LODWORD(v580) = 2;
                          v316 = (char *)_os_log_send_and_compose_impl( v315,  value,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "SUCCESSFUL migration of Primary from 501 to 502",  err,  v580);

                          if (v316) {
                            sub_100053B7C(v316);
                          }
                        }

                        else
                        {

                          v316 = 0LL;
                        }

                        free(v316);
                      }

                      if (qword_1000DBAA0 != -1) {
                        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                      }
                      id v317 = (id)qword_1000DBA98;
                      if (os_log_type_enabled((os_log_t)v317, OS_LOG_TYPE_DEFAULT))
                      {
                        value[0] = 0LL;
                        unsigned int v318 = sub_100053B4C(1);
                        uint64_t v2 = (uint64_t)v317;
                        if (os_log_type_enabled((os_log_t)v2, OS_LOG_TYPE_DEFAULT)) {
                          uint64_t v319 = v318;
                        }
                        else {
                          uint64_t v319 = v318 & 0xFFFFFFFE;
                        }
                        if ((_DWORD)v319)
                        {
                          *(_WORD *)err = 0;
                          LODWORD(v580) = 2;
                          unsigned int v320 = (char *)_os_log_send_and_compose_impl( v319,  value,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "Deleting 501 homedir - User volume, checking if its mounted",  err,  v580);

                          if (v320) {
                            sub_100053B7C(v320);
                          }
                        }

                        else
                        {

                          unsigned int v320 = 0LL;
                        }

                        free(v320);
                      }

                      v321 = (void *)sub_100083DF4(v308, kUMUserSessionVolumeDeviceNodeKey);
                      if (!v321)
                      {
                        if (qword_1000DBAA0 != -1) {
                          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                        }
                        id v328 = (id)qword_1000DBA98;
                        if (os_log_type_enabled((os_log_t)v328, OS_LOG_TYPE_DEFAULT))
                        {
                          value[0] = 0LL;
                          unsigned int v329 = sub_100053B4C(1);
                          id v328 = v328;
                          if (os_log_type_enabled((os_log_t)v328, OS_LOG_TYPE_DEFAULT)) {
                            uint64_t v330 = v329;
                          }
                          else {
                            uint64_t v330 = v329 & 0xFFFFFFFE;
                          }
                          if ((_DWORD)v330)
                          {
                            *(_WORD *)err = 0;
                            LODWORD(v580) = 2;
                            uint64_t v2 = _os_log_send_and_compose_impl( v330,  value,  0LL,  0LL,  &_mh_execute_header,  v328,  0LL,  "could not find disknode for 501 user to identity unmap",  err,  v580);

                            if (v2) {
                              sub_100053B7C((const char *)v2);
                            }
                          }

                          else
                          {

                            uint64_t v2 = 0LL;
                          }

                          free((void *)v2);
                        }

LABEL_900:
                        if ([(id)qword_1000DBA68 isVolumeMountedWithSession:v308 fsid:0])
                        {
                          if (qword_1000DBAA0 != -1) {
                            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                          }
                          id v361 = (id)qword_1000DBA98;
                          if (os_log_type_enabled((os_log_t)v361, OS_LOG_TYPE_DEFAULT))
                          {
                            value[0] = 0LL;
                            unsigned int v362 = sub_100053B4C(1);
                            uint64_t v2 = (uint64_t)v361;
                            if (os_log_type_enabled((os_log_t)v2, OS_LOG_TYPE_DEFAULT)) {
                              uint64_t v363 = v362;
                            }
                            else {
                              uint64_t v363 = v362 & 0xFFFFFFFE;
                            }
                            if ((_DWORD)v363)
                            {
                              *(_WORD *)err = 0;
                              LODWORD(v580) = 2;
                              v364 = (char *)_os_log_send_and_compose_impl( v363,  value,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "501 user session mounted, unmount prior to deletion",  err,  v580);

                              if (v364) {
                                sub_100053B7C(v364);
                              }
                            }

                            else
                            {

                              v364 = 0LL;
                            }

                            free(v364);
                          }

                          unsigned int v369 = [(id)qword_1000DBA68 unmountVolumeWithSession:v308 mountPath:@"/private/var/mobile" error:&v617];
                          BOOL v370 = qword_1000DBAA0 == -1;
                          if (!v369) {
                            goto LABEL_1452;
                          }
                          if (qword_1000DBAA0 != -1) {
                            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                          }
                          id v365 = (id)qword_1000DBA98;
                          if (os_log_type_enabled((os_log_t)v365, OS_LOG_TYPE_DEFAULT))
                          {
                            value[0] = 0LL;
                            unsigned int v371 = sub_100053B4C(1);
                            id v365 = v365;
                            if (os_log_type_enabled((os_log_t)v365, OS_LOG_TYPE_DEFAULT)) {
                              uint64_t v372 = v371;
                            }
                            else {
                              uint64_t v372 = v371 & 0xFFFFFFFE;
                            }
                            if ((_DWORD)v372)
                            {
                              *(_WORD *)err = 0;
                              LODWORD(v580) = 2;
                              uint64_t v368 = _os_log_send_and_compose_impl( v372,  value,  0LL,  0LL,  &_mh_execute_header,  v365,  0LL,  "501 unmounted, set for volume 501 volume deletion",  err,  v580);
LABEL_929:
                              uint64_t v2 = v368;

                              if (v2) {
                                sub_100053B7C((const char *)v2);
                              }
                              goto LABEL_932;
                            }

                            goto LABEL_931;
                          }
                        }

                        else
                        {
                          if (qword_1000DBAA0 != -1) {
                            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                          }
                          id v365 = (id)qword_1000DBA98;
                          if (os_log_type_enabled((os_log_t)v365, OS_LOG_TYPE_DEFAULT))
                          {
                            value[0] = 0LL;
                            unsigned int v366 = sub_100053B4C(1);
                            id v365 = v365;
                            if (os_log_type_enabled((os_log_t)v365, OS_LOG_TYPE_DEFAULT)) {
                              uint64_t v367 = v366;
                            }
                            else {
                              uint64_t v367 = v366 & 0xFFFFFFFE;
                            }
                            if ((_DWORD)v367)
                            {
                              *(_WORD *)err = 0;
                              LODWORD(v580) = 2;
                              uint64_t v368 = _os_log_send_and_compose_impl( v367,  value,  0LL,  0LL,  &_mh_execute_header,  v365,  0LL,  "501 session not mounted, deleting volume",  err,  v580);
                              goto LABEL_929;
                            }

LABEL_931:
                            uint64_t v2 = 0LL;
LABEL_932:
                            free((void *)v2);
                          }
                        }

                        if (qword_1000DBAA0 != -1) {
                          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                        }
                        id v373 = (id)qword_1000DBA98;
                        if (os_log_type_enabled((os_log_t)v373, OS_LOG_TYPE_DEFAULT))
                        {
                          value[0] = 0LL;
                          unsigned int v374 = sub_100053B4C(1);
                          uint64_t v2 = (uint64_t)v373;
                          if (os_log_type_enabled((os_log_t)v2, OS_LOG_TYPE_DEFAULT)) {
                            uint64_t v375 = v374;
                          }
                          else {
                            uint64_t v375 = v374 & 0xFFFFFFFE;
                          }
                          if ((_DWORD)v375)
                          {
                            *(_WORD *)err = 0;
                            LODWORD(v580) = 2;
                            v376 = (char *)_os_log_send_and_compose_impl( v375,  value,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "Deleting 501 session volume",  err,  v580);

                            if (v376) {
                              sub_100053B7C(v376);
                            }
                          }

                          else
                          {

                            v376 = 0LL;
                          }

                          free(v376);
                        }

                        if ([(id)qword_1000DBA68 deleteVolumeWithSession:v308 error:&v617])
                        {
                          if (qword_1000DBAA0 != -1) {
                            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                          }
                          id v377 = (id)qword_1000DBA98;
                          if (os_log_type_enabled((os_log_t)v377, OS_LOG_TYPE_DEFAULT))
                          {
                            value[0] = 0LL;
                            unsigned int v378 = sub_100053B4C(1);
                            v379 = (os_log_s *)v377;
                            if (os_log_type_enabled(v379, OS_LOG_TYPE_DEFAULT)) {
                              uint64_t v380 = v378;
                            }
                            else {
                              uint64_t v380 = v378 & 0xFFFFFFFE;
                            }
                            if ((_DWORD)v380)
                            {
                              *(_WORD *)err = 0;
                              LODWORD(v580) = 2;
                              v381 = (char *)_os_log_send_and_compose_impl( v380,  value,  0LL,  0LL,  &_mh_execute_header,  v379,  0LL,  "Successful deletion of 501 User Volume",  err,  v580);

                              if (v381) {
                                sub_100053B7C(v381);
                              }
                            }

                            else
                            {

                              v381 = 0LL;
                            }

                            free(v381);
                          }

                          if (qword_1000DBAA0 != -1) {
                            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                          }
                          id v382 = (id)qword_1000DBA98;
                          if (os_log_type_enabled((os_log_t)v382, OS_LOG_TYPE_DEFAULT))
                          {
                            value[0] = 0LL;
                            unsigned int v383 = sub_100053B4C(1);
                            v384 = (os_log_s *)v382;
                            if (os_log_type_enabled(v384, OS_LOG_TYPE_DEFAULT)) {
                              uint64_t v385 = v383;
                            }
                            else {
                              uint64_t v385 = v383 & 0xFFFFFFFE;
                            }
                            if ((_DWORD)v385)
                            {
                              *(_WORD *)err = 0;
                              LODWORD(v580) = 2;
                              v386 = (char *)_os_log_send_and_compose_impl( v385,  value,  0LL,  0LL,  &_mh_execute_header,  v384,  0LL,  "unbind/Deleting 501 Identity",  err,  v580);

                              if (v386) {
                                sub_100053B7C(v386);
                              }
                            }

                            else
                            {

                              v386 = 0LL;
                            }

                            free(v386);
                          }

                          if (qword_1000DBAA0 != -1) {
                            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                          }
                          id v387 = (id)qword_1000DBA98;
                          if (os_log_type_enabled((os_log_t)v387, OS_LOG_TYPE_DEFAULT))
                          {
                            *(void *)err = 0LL;
                            unsigned int v388 = sub_100053B4C(1);
                            v389 = (os_log_s *)v387;
                            if (os_log_type_enabled(v389, OS_LOG_TYPE_DEFAULT)) {
                              uint64_t v390 = v388;
                            }
                            else {
                              uint64_t v390 = v388 & 0xFFFFFFFE;
                            }
                            if ((_DWORD)v390)
                            {
                              LODWORD(value[0]) = 138412290;
                              *(void **)((char *)value + 4) = (void *)v204;
                              LODWORD(v580) = 12;
                              v391 = (char *)_os_log_send_and_compose_impl( v390,  err,  0LL,  0LL,  &_mh_execute_header,  v389,  0LL,  "binding the data volume  to 502 user uuid %@",  value,  v580);

                              if (v391) {
                                sub_100053B7C(v391);
                              }
                            }

                            else
                            {

                              v391 = 0LL;
                            }

                            free(v391);
                          }

                          if (sub_10007C1D0(v204, (uint64_t)v581, 0, (int *)&v617))
                          {
                            if (qword_1000DBAA0 != -1) {
                              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                            }
                            id v392 = (id)qword_1000DBA98;
                            if (os_log_type_enabled((os_log_t)v392, OS_LOG_TYPE_DEFAULT))
                            {
                              value[0] = 0LL;
                              unsigned int v393 = sub_100053B4C(1);
                              id v392 = v392;
                              if (os_log_type_enabled((os_log_t)v392, OS_LOG_TYPE_DEFAULT)) {
                                uint64_t v394 = v393;
                              }
                              else {
                                uint64_t v394 = v393 & 0xFFFFFFFE;
                              }
                              if ((_DWORD)v394)
                              {
                                *(_WORD *)err = 0;
                                uint64_t v395 = _os_log_send_and_compose_impl( v394,  value,  0LL,  0LL,  &_mh_execute_header,  v392,  0LL,  "Successful binding the system data partition to the loginUI");
                                goto LABEL_995;
                              }

                              goto LABEL_997;
                            }
                          }

                          else
                          {
                            if (qword_1000DBAA0 != -1) {
                              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                            }
                            id v392 = (id)qword_1000DBA98;
                            if (os_log_type_enabled((os_log_t)v392, OS_LOG_TYPE_DEFAULT))
                            {
                              value[0] = 0LL;
                              unsigned int v396 = sub_100053B4C(1);
                              id v392 = v392;
                              if (os_log_type_enabled((os_log_t)v392, OS_LOG_TYPE_DEFAULT)) {
                                uint64_t v397 = v396;
                              }
                              else {
                                uint64_t v397 = v396 & 0xFFFFFFFE;
                              }
                              if ((_DWORD)v397)
                              {
                                *(_DWORD *)err = 67109120;
                                *(_DWORD *)&err[4] = v617;
                                uint64_t v395 = _os_log_send_and_compose_impl( v397,  value,  0LL,  0LL,  &_mh_execute_header,  v392,  0LL,  "Failed to bind the system data partition to loginUI with error %d",  err);
LABEL_995:
                                v398 = (char *)v395;

                                if (v398) {
                                  sub_100053B7C(v398);
                                }
                                goto LABEL_998;
                              }

LABEL_997:
                              v398 = 0LL;
LABEL_998:
                              free(v398);
                            }
                          }

                          if (qword_1000DBAA0 != -1) {
                            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                          }
                          id v399 = (id)qword_1000DBA98;
                          if (os_log_type_enabled((os_log_t)v399, OS_LOG_TYPE_DEFAULT))
                          {
                            value[0] = 0LL;
                            unsigned int v400 = sub_100053B4C(1);
                            v401 = (os_log_s *)v399;
                            if (os_log_type_enabled(v401, OS_LOG_TYPE_DEFAULT)) {
                              uint64_t v402 = v400;
                            }
                            else {
                              uint64_t v402 = v400 & 0xFFFFFFFE;
                            }
                            if ((_DWORD)v402)
                            {
                              *(_WORD *)err = 0;
                              LODWORD(v580) = 2;
                              v403 = (char *)_os_log_send_and_compose_impl( v402,  value,  0LL,  0LL,  &_mh_execute_header,  v401,  0LL,  "AKS Unloading the Identity of uid 501",  err,  v580);

                              if (v403) {
                                sub_100053B7C(v403);
                              }
                            }

                            else
                            {

                              v403 = 0LL;
                            }

                            free(v403);
                          }

                          uint64_t v404 = sub_100019B18(qword_1000DBD40);
                          uint64_t v2 = objc_claimAutoreleasedReturnValue(v404);
                          id v589 = 0LL;
                          unsigned int v405 = [(id)v2 unloadIdentityFromSession:501 error:&v589];
                          id v406 = v589;

                          if (v405)
                          {
                            if (qword_1000DBAA0 != -1) {
                              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                            }
                            id v407 = (id)qword_1000DBA98;
                            if (os_log_type_enabled((os_log_t)v407, OS_LOG_TYPE_DEFAULT))
                            {
                              value[0] = 0LL;
                              unsigned int v408 = sub_100053B4C(1);
                              id v407 = v407;
                              if (os_log_type_enabled((os_log_t)v407, OS_LOG_TYPE_DEFAULT)) {
                                uint64_t v409 = v408;
                              }
                              else {
                                uint64_t v409 = v408 & 0xFFFFFFFE;
                              }
                              if ((_DWORD)v409)
                              {
                                *(_WORD *)err = 0;
                                uint64_t v410 = _os_log_send_and_compose_impl( v409,  value,  0LL,  0LL,  &_mh_execute_header,  v407,  0LL,  "AKS Unloading the Identity of uid:501 SUCCESS ");
                                goto LABEL_1027;
                              }

                              goto LABEL_1029;
                            }
                          }

                          else
                          {
                            if (qword_1000DBAA0 != -1) {
                              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                            }
                            id v407 = (id)qword_1000DBA98;
                            if (os_log_type_enabled((os_log_t)v407, OS_LOG_TYPE_DEFAULT))
                            {
                              *(void *)err = 0LL;
                              LODWORD(v411) = sub_100053B4C(1);
                              id v407 = v407;
                              if (os_log_type_enabled((os_log_t)v407, OS_LOG_TYPE_DEFAULT)) {
                                uint64_t v411 = v411;
                              }
                              else {
                                uint64_t v411 = v411 & 0xFFFFFFFE;
                              }
                              if ((_DWORD)v411)
                              {
                                id v412 = [v406 code];
                                LODWORD(value[0]) = 134217984;
                                *(void **)((char *)value + 4) = v412;
                                uint64_t v410 = _os_log_send_and_compose_impl( v411,  err,  0LL,  0LL,  &_mh_execute_header,  v407,  0LL,  "AKS Unloading the Identity of uid:501 FAILED with error:%ld",  value);
LABEL_1027:
                                uint64_t v2 = v410;

                                if (v2) {
                                  sub_100053B7C((const char *)v2);
                                }
                                goto LABEL_1030;
                              }

LABEL_1029:
                              uint64_t v2 = 0LL;
LABEL_1030:
                              free((void *)v2);
                            }
                          }

                          if (qword_1000DBAA0 != -1) {
                            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                          }
                          id v413 = (id)qword_1000DBA98;
                          if (os_log_type_enabled((os_log_t)v413, OS_LOG_TYPE_DEFAULT))
                          {
                            value[0] = 0LL;
                            unsigned int v414 = sub_100053B4C(1);
                            uint64_t v2 = (uint64_t)v413;
                            if (os_log_type_enabled((os_log_t)v2, OS_LOG_TYPE_DEFAULT)) {
                              uint64_t v415 = v414;
                            }
                            else {
                              uint64_t v415 = v414 & 0xFFFFFFFE;
                            }
                            if ((_DWORD)v415)
                            {
                              *(_WORD *)err = 0;
                              LODWORD(v580) = 2;
                              v416 = (char *)_os_log_send_and_compose_impl( v415,  value,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "Deleting 501 identity",  err,  v580);

                              if (v416) {
                                sub_100053B7C(v416);
                              }
                            }

                            else
                            {

                              v416 = 0LL;
                            }

                            free(v416);
                          }

                          v417 = (void *)sub_100083DF4(v583, kUMUserSessionUUIDKey);
                          if (v417)
                          {
                            v418 = v417;
                            if (qword_1000DBAA0 != -1) {
                              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                            }
                            id v419 = (id)qword_1000DBA98;
                            if (os_log_type_enabled((os_log_t)v419, OS_LOG_TYPE_DEFAULT))
                            {
                              *(void *)err = 0LL;
                              unsigned int v420 = sub_100053B4C(1);
                              v421 = (os_log_s *)v419;
                              if (os_log_type_enabled(v421, OS_LOG_TYPE_DEFAULT)) {
                                uint64_t v422 = v420;
                              }
                              else {
                                uint64_t v422 = v420 & 0xFFFFFFFE;
                              }
                              if ((_DWORD)v422)
                              {
                                LODWORD(value[0]) = 138412290;
                                *(void **)((char *)value + 4) = v418;
                                LODWORD(v580) = 12;
                                v423 = (char *)_os_log_send_and_compose_impl( v422,  err,  0LL,  0LL,  &_mh_execute_header,  v421,  0LL,  "Deleting 501 identity with uuid:%@",  value,  v580);

                                if (v423) {
                                  sub_100053B7C(v423);
                                }
                              }

                              else
                              {

                                v423 = 0LL;
                              }

                              free(v423);
                            }

                            v424 = sub_100017CFC((uint64_t)&OBJC_CLASS___NSUUID, v418);
                            v425 = (void *)objc_claimAutoreleasedReturnValue(v424);
                            uint64_t v426 = sub_100019B18(qword_1000DBD40);
                            v427 = (void *)objc_claimAutoreleasedReturnValue(v426);
                            id v588 = 0LL;
                            unsigned int v428 = [v427 deleteIdentity:v425 error:&v588];
                            id v272 = v588;

                            if (v428)
                            {
                              uint64_t v2 = v586;
                              if (qword_1000DBAA0 != -1) {
                                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                              }
                              id v429 = (id)qword_1000DBA98;
                              if (os_log_type_enabled((os_log_t)v429, OS_LOG_TYPE_DEFAULT))
                              {
                                value[0] = 0LL;
                                unsigned int v430 = sub_100053B4C(1);
                                id v429 = v429;
                                if (os_log_type_enabled((os_log_t)v429, OS_LOG_TYPE_DEFAULT)) {
                                  uint64_t v431 = v430;
                                }
                                else {
                                  uint64_t v431 = v430 & 0xFFFFFFFE;
                                }
                                if ((_DWORD)v431)
                                {
                                  *(_WORD *)err = 0;
                                  LODWORD(v580) = 2;
                                  uint64_t v432 = _os_log_send_and_compose_impl( v431,  value,  0LL,  0LL,  &_mh_execute_header,  v429,  0LL,  "501 identity removed",  err,  v580);
                                  goto LABEL_1082;
                                }

                                goto LABEL_1084;
                              }
                            }

                            else
                            {
                              uint64_t v2 = v586;
                              if (qword_1000DBAA0 != -1) {
                                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                              }
                              id v433 = (id)qword_1000DBA98;
                              if (os_log_type_enabled((os_log_t)v433, OS_LOG_TYPE_DEFAULT))
                              {
                                *(void *)err = 0LL;
                                LODWORD(v434) = sub_100053B4C(1);
                                v435 = (os_log_s *)v433;
                                if (os_log_type_enabled(v435, OS_LOG_TYPE_DEFAULT)) {
                                  uint64_t v434 = v434;
                                }
                                else {
                                  uint64_t v434 = v434 & 0xFFFFFFFE;
                                }
                                if ((_DWORD)v434)
                                {
                                  id v436 = [v272 code];
                                  LODWORD(value[0]) = 134217984;
                                  *(void **)((char *)value + 4) = v436;
                                  v437 = (char *)_os_log_send_and_compose_impl( v434,  err,  0LL,  0LL,  &_mh_execute_header,  v435,  0LL,  "Failed to delete 501 Identity with error %ld",  value);

                                  if (v437) {
                                    sub_100053B7C(v437);
                                  }
                                }

                                else
                                {

                                  v437 = 0LL;
                                }

                                free(v437);
                                uint64_t v2 = v586;
                              }

                              sleep(2u);
                              if (qword_1000DBAA0 != -1) {
                                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                              }
                              id v429 = (id)qword_1000DBA98;
                              if (os_log_type_enabled((os_log_t)v429, OS_LOG_TYPE_DEFAULT))
                              {
                                value[0] = 0LL;
                                unsigned int v438 = sub_100053B4C(1);
                                id v429 = v429;
                                if (os_log_type_enabled((os_log_t)v429, OS_LOG_TYPE_DEFAULT)) {
                                  uint64_t v439 = v438;
                                }
                                else {
                                  uint64_t v439 = v438 & 0xFFFFFFFE;
                                }
                                if ((_DWORD)v439)
                                {
                                  *(_WORD *)err = 0;
                                  LODWORD(v580) = 2;
                                  uint64_t v432 = _os_log_send_and_compose_impl( v439,  value,  0LL,  0LL,  &_mh_execute_header,  v429,  0LL,  "Skipping panic to make further progress, pending check with AKS",  err,  v580);
LABEL_1082:
                                  v440 = (char *)v432;

                                  if (v440) {
                                    sub_100053B7C(v440);
                                  }
                                  goto LABEL_1085;
                                }

LABEL_1084:
                                v440 = 0LL;
LABEL_1085:
                                free(v440);
                                uint64_t v2 = v586;
                              }
                            }

                            if (qword_1000DBAA0 != -1) {
                              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                            }
                            id v441 = (id)qword_1000DBA98;
                            if (os_log_type_enabled((os_log_t)v441, OS_LOG_TYPE_DEFAULT))
                            {
                              value[0] = 0LL;
                              unsigned int v442 = sub_100053B4C(1);
                              v443 = (os_log_s *)v441;
                              if (os_log_type_enabled(v443, OS_LOG_TYPE_DEFAULT)) {
                                uint64_t v444 = v442;
                              }
                              else {
                                uint64_t v444 = v442 & 0xFFFFFFFE;
                              }
                              if ((_DWORD)v444)
                              {
                                *(_WORD *)err = 0;
                                LODWORD(v580) = 2;
                                v445 = (char *)_os_log_send_and_compose_impl( v444,  value,  0LL,  0LL,  &_mh_execute_header,  v443,  0LL,  "removing 501 session from the list",  err,  v580);

                                if (v445) {
                                  sub_100053B7C(v445);
                                }
                              }

                              else
                              {

                                v445 = 0LL;
                              }

                              uint64_t v2 = v586;
                              free(v445);
                            }

                            CFRelease(v583);
                            sub_10002E0A4(501, 0);
                            sub_10001AED4();
                            if (qword_1000DBAA0 != -1) {
                              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                            }
                            id v446 = (id)qword_1000DBA98;
                            if (os_log_type_enabled((os_log_t)v446, OS_LOG_TYPE_DEFAULT))
                            {
                              value[0] = 0LL;
                              unsigned int v447 = sub_100053B4C(1);
                              v448 = (os_log_s *)v446;
                              if (os_log_type_enabled(v448, OS_LOG_TYPE_DEFAULT)) {
                                uint64_t v449 = v447;
                              }
                              else {
                                uint64_t v449 = v447 & 0xFFFFFFFE;
                              }
                              if ((_DWORD)v449)
                              {
                                *(_WORD *)err = 0;
                                LODWORD(v580) = 2;
                                v450 = (char *)_os_log_send_and_compose_impl( v449,  value,  0LL,  0LL,  &_mh_execute_header,  v448,  0LL,  "Setting lastUsers to 502 User",  err,  v580);

                                if (v450) {
                                  sub_100053B7C(v450);
                                }
                              }

                              else
                              {

                                v450 = 0LL;
                              }

                              uint64_t v2 = v586;
                              free(v450);
                            }

                            unint64_t v11 = (unint64_t)&byte_1000DBD3B;
                            if (sub_10007E13C("/var/Users", (int *)&v617))
                            {
                              if (qword_1000DBAA0 != -1) {
                                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                              }
                              v451 = (os_log_s *)(id)qword_1000DBA98;
                              if (!os_log_type_enabled(v451, OS_LOG_TYPE_DEFAULT)) {
                                goto LABEL_1140;
                              }
                              value[0] = 0LL;
                              unsigned int v452 = sub_100053B4C(1);
                              v451 = v451;
                              if (os_log_type_enabled(v451, OS_LOG_TYPE_DEFAULT)) {
                                uint64_t v453 = v452;
                              }
                              else {
                                uint64_t v453 = v452 & 0xFFFFFFFE;
                              }
                              if ((_DWORD)v453)
                              {
                                *(_WORD *)err = 0;
                                LODWORD(v580) = 2;
                                uint64_t v454 = _os_log_send_and_compose_impl( v453,  value,  0LL,  0LL,  &_mh_execute_header,  v451,  0LL,  "Successful setting of Last Booted User",  err,  v580);
                                goto LABEL_1136;
                              }
                            }

                            else
                            {
                              if (qword_1000DBAA0 != -1) {
                                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                              }
                              id v455 = (id)qword_1000DBA98;
                              if (os_log_type_enabled((os_log_t)v455, OS_LOG_TYPE_DEFAULT))
                              {
                                value[0] = 0LL;
                                unsigned int v456 = sub_100053B4C(1);
                                v457 = (os_log_s *)v455;
                                if (os_log_type_enabled(v457, OS_LOG_TYPE_DEFAULT)) {
                                  uint64_t v458 = v456;
                                }
                                else {
                                  uint64_t v458 = v456 & 0xFFFFFFFE;
                                }
                                if ((_DWORD)v458)
                                {
                                  *(_WORD *)err = 0;
                                  LODWORD(v580) = 2;
                                  v459 = (char *)_os_log_send_and_compose_impl( v458,  value,  0LL,  0LL,  &_mh_execute_header,  v457,  0LL,  "Failed to set Last Booted User",  err,  v580);

                                  if (v459) {
                                    sub_100053B7C(v459);
                                  }
                                }

                                else
                                {

                                  v459 = 0LL;
                                }

                                uint64_t v2 = v586;
                                free(v459);
                                unint64_t v11 = (unint64_t)&byte_1000DBD3B;
                              }

                              if (qword_1000DBAA0 != -1) {
                                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                              }
                              v451 = (os_log_s *)(id)qword_1000DBA98;
                              if (!os_log_type_enabled(v451, OS_LOG_TYPE_DEFAULT)) {
                                goto LABEL_1140;
                              }
                              value[0] = 0LL;
                              unsigned int v460 = sub_100053B4C(1);
                              v451 = v451;
                              if (os_log_type_enabled(v451, OS_LOG_TYPE_DEFAULT)) {
                                uint64_t v461 = v460;
                              }
                              else {
                                uint64_t v461 = v460 & 0xFFFFFFFE;
                              }
                              if ((_DWORD)v461)
                              {
                                *(_WORD *)err = 0;
                                LODWORD(v580) = 2;
                                uint64_t v454 = _os_log_send_and_compose_impl( v461,  value,  0LL,  0LL,  &_mh_execute_header,  v451,  0LL,  "Ignoring the failure as this is mere cleanup",  err,  v580);
LABEL_1136:
                                v462 = (char *)v454;

                                if (v462) {
                                  sub_100053B7C(v462);
                                }
                                goto LABEL_1139;
                              }
                            }

                            v462 = 0LL;
LABEL_1139:
                            free(v462);
                            uint64_t v2 = v586;
LABEL_1140:

                            if (v581) {
                              CFRelease(v581);
                            }

                            CFDictionarySetValue( (CFMutableDictionaryRef)p_vtable,  kUMUserSessionNeedsCryptoSetupKey,  kCFBooleanFalse);
                            goto LABEL_1143;
                          }

                          if (qword_1000DBAA0 != -1) {
                            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                          }
                          v535 = (os_log_s *)(id)qword_1000DBA98;
                          if (!os_log_type_enabled(v535, OS_LOG_TYPE_DEFAULT))
                          {
LABEL_1491:

                            sleep(2u);
                            uint64_t v568 = sub_100019F7C("UserManagement early boot task Unable to find 501 uuid");
                            goto LABEL_1492;
                          }

                          value[0] = 0LL;
                          unsigned int v554 = sub_100053B4C(1);
                          uint64_t v0 = v535;
                          if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
                            uint64_t v555 = v554;
                          }
                          else {
                            uint64_t v555 = v554 & 0xFFFFFFFE;
                          }
                          if (!(_DWORD)v555)
                          {

                            v556 = 0LL;
LABEL_1490:
                            free(v556);
                            goto LABEL_1491;
                          }

LABEL_1488:
                          *(_WORD *)err = 0;
                          LODWORD(v580) = 2;
                          v579 = (const char *)_os_log_send_and_compose_impl( v555,  value,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "Unable to find 501 uuid string ",  err,  v580);

                          v556 = 0LL;
                          if (v579)
                          {
                            sub_100053B7C(v579);
                            v556 = (char *)v579;
                          }

                          goto LABEL_1490;
                        }

                        if (qword_1000DBAA0 != -1) {
                          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                        }
                        v535 = (os_log_s *)(id)qword_1000DBA98;
                        if (!os_log_type_enabled(v535, OS_LOG_TYPE_DEFAULT))
                        {
LABEL_1487:

                          sleep(2u);
                          uint64_t v555 = sub_100019F7C("Failed deletion of 501 User Volume error:%d", v617);
                          goto LABEL_1488;
                        }

                        value[0] = 0LL;
                        unsigned int v551 = sub_100053B4C(1);
                        uint64_t v0 = v535;
                        if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
                          uint64_t v552 = v551;
                        }
                        else {
                          uint64_t v552 = v551 & 0xFFFFFFFE;
                        }
                        if (!(_DWORD)v552)
                        {

                          v553 = 0LL;
LABEL_1486:
                          free(v553);
                          goto LABEL_1487;
                        }

LABEL_1484:
                        *(_DWORD *)err = 67109120;
                        *(_DWORD *)&err[4] = v617;
                        v578 = (const char *)_os_log_send_and_compose_impl( v552,  value,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "Failed deletion of 501 User Volume,error:%d",  err);

                        v553 = 0LL;
                        if (v578)
                        {
                          sub_100053B7C(v578);
                          v553 = (char *)v578;
                        }

                        goto LABEL_1486;
                      }

                      uint64_t v322 = v321;
                      if (qword_1000DBAA0 != -1) {
                        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                      }
                      id v323 = (id)qword_1000DBA98;
                      if (os_log_type_enabled((os_log_t)v323, OS_LOG_TYPE_DEFAULT))
                      {
                        *(void *)err = 0LL;
                        unsigned int v324 = sub_100053B4C(1);
                        v325 = (os_log_s *)v323;
                        if (os_log_type_enabled(v325, OS_LOG_TYPE_DEFAULT)) {
                          uint64_t v326 = v324;
                        }
                        else {
                          uint64_t v326 = v324 & 0xFFFFFFFE;
                        }
                        if ((_DWORD)v326)
                        {
                          LODWORD(value[0]) = 138412290;
                          *(void **)((char *)value + 4) = v322;
                          LODWORD(v580) = 12;
                          v327 = (char *)_os_log_send_and_compose_impl( v326,  err,  0LL,  0LL,  &_mh_execute_header,  v325,  0LL,  "Calling AKSVolumeUnmap with disk:%@ if 501 User",  value,  v580);

                          if (v327) {
                            sub_100053B7C(v327);
                          }
                        }

                        else
                        {

                          v327 = 0LL;
                        }

                        free(v327);
                      }

                      uint64_t v331 = sub_100019B18(qword_1000DBD40);
                      uint64_t v2 = objc_claimAutoreleasedReturnValue(v331);
                      id v590 = 0LL;
                      unsigned int v332 = [(id)v2 unmapVolume:v322 error:&v590];
                      id v328 = v590;

                      if (v332)
                      {
                        if (qword_1000DBAA0 != -1) {
                          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                        }
                        v333 = (os_log_s *)(id)qword_1000DBA98;
                        if (!os_log_type_enabled(v333, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_840;
                        }
                        value[0] = 0LL;
                        unsigned int v334 = sub_100053B4C(1);
                        v333 = v333;
                        if (os_log_type_enabled(v333, OS_LOG_TYPE_DEFAULT)) {
                          uint64_t v335 = v334;
                        }
                        else {
                          uint64_t v335 = v334 & 0xFFFFFFFE;
                        }
                        if ((_DWORD)v335)
                        {
                          *(_WORD *)err = 0;
                          uint64_t v336 = _os_log_send_and_compose_impl( v335,  value,  0LL,  0LL,  &_mh_execute_header,  v333,  0LL,  "Volume Unmap of 501 session succeeded");
                          goto LABEL_836;
                        }
                      }

                      else
                      {
                        if (qword_1000DBAA0 != -1) {
                          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                        }
                        v333 = (os_log_s *)(id)qword_1000DBA98;
                        if (!os_log_type_enabled(v333, OS_LOG_TYPE_DEFAULT)) {
                          goto LABEL_840;
                        }
                        *(void *)err = 0LL;
                        LODWORD(v337) = sub_100053B4C(1);
                        v333 = v333;
                        if (os_log_type_enabled(v333, OS_LOG_TYPE_DEFAULT)) {
                          uint64_t v337 = v337;
                        }
                        else {
                          uint64_t v337 = v337 & 0xFFFFFFFE;
                        }
                        if ((_DWORD)v337)
                        {
                          id v338 = [v328 code];
                          LODWORD(value[0]) = 134217984;
                          *(void **)((char *)value + 4) = v338;
                          uint64_t v336 = _os_log_send_and_compose_impl( v337,  err,  0LL,  0LL,  &_mh_execute_header,  v333,  0LL,  "AKS volumeUnmap failed for 501 with error:%ld",  value);
LABEL_836:
                          uint64_t v2 = v336;

                          if (v2) {
                            sub_100053B7C((const char *)v2);
                          }
                          goto LABEL_839;
                        }
                      }

                      uint64_t v2 = 0LL;
LABEL_839:
                      free((void *)v2);
LABEL_840:

                      id v308 = v583;
                      goto LABEL_900;
                    }

                    if (qword_1000DBAA0 != -1) {
                      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                    }
                    v535 = (os_log_s *)(id)qword_1000DBA98;
                    if (!os_log_type_enabled(v535, OS_LOG_TYPE_DEFAULT))
                    {
LABEL_1483:

                      sleep(2u);
                      CFIndex v577 = CFErrorGetCode(uuid[0]);
                      uint64_t v552 = sub_100019F7C("FAILED to transfer Primary from 501 -> 502:with error:%ld", v577);
                      goto LABEL_1484;
                    }

                    value[0] = 0LL;
                    unsigned int v548 = sub_100053B4C(1);
                    uint64_t v0 = v535;
                    if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
                      uint64_t v549 = v548;
                    }
                    else {
                      uint64_t v549 = v548 & 0xFFFFFFFE;
                    }
                    if (!(_DWORD)v549)
                    {

                      v550 = 0LL;
LABEL_1482:
                      free(v550);
                      goto LABEL_1483;
                    }

LABEL_1480:
                    *(_WORD *)err = 0;
                    LODWORD(v580) = 2;
                    v576 = (const char *)_os_log_send_and_compose_impl( v549,  value,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "FAILED to transfer Primary from 501 -> 502",  err,  v580);

                    v550 = 0LL;
                    if (v576)
                    {
                      sub_100053B7C(v576);
                      v550 = (char *)v576;
                    }

                    goto LABEL_1482;
                  }

                  if (qword_1000DBAA0 != -1) {
                    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                  }
                  v535 = (os_log_s *)(id)qword_1000DBA98;
                  if (!os_log_type_enabled(v535, OS_LOG_TYPE_DEFAULT))
                  {
LABEL_1479:

                    sleep(2u);
                    CFIndex v575 = CFErrorGetCode(uuid[0]);
                    uint64_t v549 = sub_100019F7C("FAILED to ensure 501 user Identity is loaded with error:%ld", v575);
                    goto LABEL_1480;
                  }

                  *(void *)err = 0LL;
                  LODWORD(p_vtable) = sub_100053B4C(1);
                  uint64_t v0 = v535;
                  if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
                    uint64_t p_vtable = p_vtable;
                  }
                  else {
                    uint64_t p_vtable = p_vtable & 0xFFFFFFFE;
                  }
                  if (!(_DWORD)p_vtable)
                  {

                    v547 = 0LL;
LABEL_1478:
                    free(v547);
                    goto LABEL_1479;
                  }

LABEL_1476:
                  v573 = (void *)CFErrorGetCode(uuid[0]);
                  LODWORD(value[0]) = 134217984;
                  *(void **)((char *)value + 4) = v573;
                  v574 = (const char *)_os_log_send_and_compose_impl( p_vtable,  err,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "FAILED to ensure 501 user Identity is loaded with error:%ld",  value);

                  v547 = 0LL;
                  if (v574)
                  {
                    sub_100053B7C(v574);
                    v547 = (char *)v574;
                  }

                  goto LABEL_1478;
                }

                if (qword_1000DBAA0 != -1) {
                  dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                }
                v535 = (os_log_s *)(id)qword_1000DBA98;
                if (!os_log_type_enabled(v535, OS_LOG_TYPE_DEFAULT))
                {
LABEL_1475:

                  sleep(2u);
                  sub_100019F7C("FAILED to build 501 NSUUID to migrate to 502");
                  goto LABEL_1476;
                }

                value[0] = 0LL;
                uint64_t p_vtable = sub_100053B4C(1);
                uint64_t v0 = v535;
                if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
                  uint64_t v545 = p_vtable;
                }
                else {
                  uint64_t v545 = p_vtable & 0xFFFFFFFE;
                }
                if (!(_DWORD)v545)
                {

                  v546 = 0LL;
LABEL_1474:
                  free(v546);
                  goto LABEL_1475;
                }

LABEL_1472:
                *(_WORD *)err = 0;
                LODWORD(v580) = 2;
                uint64_t p_vtable = _os_log_send_and_compose_impl( v545,  value,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "FAILED to build 501 NSUUID to migrate to 502",  err,  v580);

                v546 = 0LL;
                if (p_vtable)
                {
                  sub_100053B7C((const char *)p_vtable);
                  v546 = (void *)p_vtable;
                }

                goto LABEL_1474;
              }

              if (qword_1000DBAA0 != -1) {
                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
              }
              v535 = (os_log_s *)(id)qword_1000DBA98;
              if (!os_log_type_enabled(v535, OS_LOG_TYPE_DEFAULT))
              {
LABEL_1471:

                sleep(2u);
                uint64_t v545 = sub_100019F7C("FAILED to construct CF501 uuid to migrate to 502");
                goto LABEL_1472;
              }

              value[0] = 0LL;
              unsigned int v542 = sub_100053B4C(1);
              uint64_t v0 = v535;
              if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v543 = v542;
              }
              else {
                uint64_t v543 = v542 & 0xFFFFFFFE;
              }
              if (!(_DWORD)v543)
              {

                v544 = 0LL;
LABEL_1470:
                free(v544);
                goto LABEL_1471;
              }

LABEL_1468:
              *(_WORD *)err = 0;
              LODWORD(v580) = 2;
              v572 = (const char *)_os_log_send_and_compose_impl( v543,  value,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "FAILED to construct CF501 uuid to migrate to 502",  err,  v580);

              v544 = 0LL;
              if (v572)
              {
                sub_100053B7C(v572);
                v544 = (char *)v572;
              }

              goto LABEL_1470;
            }

            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            v535 = (os_log_s *)(id)qword_1000DBA98;
            if (!os_log_type_enabled(v535, OS_LOG_TYPE_DEFAULT))
            {
LABEL_1467:

              sleep(2u);
              uint64_t v543 = sub_100019F7C("FAILED to locate 501 uuid string to migrate OTI to 502");
              goto LABEL_1468;
            }

            value[0] = 0LL;
            unsigned int v539 = sub_100053B4C(1);
            uint64_t v0 = v535;
            if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v540 = v539;
            }
            else {
              uint64_t v540 = v539 & 0xFFFFFFFE;
            }
            if (!(_DWORD)v540)
            {

              v541 = 0LL;
LABEL_1466:
              free(v541);
              goto LABEL_1467;
            }
          }

          else
          {
            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            v535 = (os_log_s *)(id)qword_1000DBA98;
            if (os_log_type_enabled(v535, OS_LOG_TYPE_DEFAULT))
            {
              value[0] = 0LL;
              unsigned int v536 = sub_100053B4C(1);
              uint64_t v0 = v535;
              if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v537 = v536;
              }
              else {
                uint64_t v537 = v536 & 0xFFFFFFFE;
              }
              if ((_DWORD)v537)
              {
                *(_WORD *)err = 0;
                LODWORD(v580) = 2;
                v570 = (const char *)_os_log_send_and_compose_impl( v537,  value,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "Unable to find 501 session",  err,  v580);

                v538 = 0LL;
                if (v570)
                {
                  sub_100053B7C(v570);
                  v538 = (char *)v570;
                }
              }

              else
              {

                v538 = 0LL;
              }

              free(v538);
            }

            sleep(2u);
            uint64_t v540 = sub_100019F7C("UserManagement early boot task Unable to find 501 session");
          }

          *(_WORD *)err = 0;
          LODWORD(v580) = 2;
          v571 = (const char *)_os_log_send_and_compose_impl( v540,  value,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "FAILED to locate 501 uuid string to migrate OTI to 502",  err,  v580);

          v541 = 0LL;
          if (v571)
          {
            sub_100053B7C(v571);
            v541 = (char *)v571;
          }

          goto LABEL_1466;
        }

        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        v496 = (os_log_s *)(id)qword_1000DBA98;
        if (!os_log_type_enabled(v496, OS_LOG_TYPE_DEFAULT))
        {
LABEL_1322:

          sleep(2u);
          sub_100019F7C("UserManagement early boot task could not Locate primary user session of Update install user");
          goto LABEL_1323;
        }

        value[0] = 0LL;
        unsigned int v497 = sub_100053B4C(1);
        uint64_t v0 = v496;
        if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v498 = v497;
        }
        else {
          uint64_t v498 = v497 & 0xFFFFFFFE;
        }
        if (!(_DWORD)v498)
        {

          v499 = 0LL;
LABEL_1321:
          free(v499);
          goto LABEL_1322;
        }

LABEL_1319:
        *(_WORD *)err = 0;
        LODWORD(v580) = 2;
        v518 = (const char *)_os_log_send_and_compose_impl( v498,  value,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "Could not Locate primary user session of Update install user",  err,  v580);

        v499 = 0LL;
        if (v518)
        {
          sub_100053B7C(v518);
          v499 = (char *)v518;
        }

        goto LABEL_1321;
      }

      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v0 = (uint64_t)(id)qword_1000DBA98;
      if (!os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT))
      {
LABEL_555:

        goto LABEL_556;
      }

      value[0] = 0LL;
      unsigned int v198 = sub_100053B4C(1);
      uint64_t v0 = (uint64_t)(id)v0;
      if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v199 = v198;
      }
      else {
        uint64_t v199 = v198 & 0xFFFFFFFE;
      }
      if ((_DWORD)v199)
      {
        *(_WORD *)err = 0;
        LODWORD(v580) = 2;
        uint64_t v197 = _os_log_send_and_compose_impl( v199,  value,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "Erase Install, getting user UUID to setup AKS",  err,  v580);
LABEL_551:
        unsigned int v200 = (char *)v197;

        if (v200) {
          sub_100053B7C(v200);
        }
        goto LABEL_554;
      }
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v0 = (uint64_t)(id)qword_1000DBA98;
      if (!os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_555;
      }
      value[0] = 0LL;
      unsigned int v195 = sub_100053B4C(1);
      uint64_t v0 = (uint64_t)(id)v0;
      if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v196 = v195;
      }
      else {
        uint64_t v196 = v195 & 0xFFFFFFFE;
      }
      if ((_DWORD)v196)
      {
        *(_WORD *)err = 0;
        LODWORD(v580) = 2;
        uint64_t v197 = _os_log_send_and_compose_impl( v196,  value,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "Regular Boot",  err,  v580);
        goto LABEL_551;
      }
    }

    unsigned int v200 = 0LL;
LABEL_554:
    free(v200);
    goto LABEL_555;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v0 = (uint64_t)(id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT))
  {
    value[0] = 0LL;
    unsigned int v193 = sub_100053B4C(1);
    uint64_t v0 = (uint64_t)(id)v0;
    if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v194 = v193;
    }
    else {
      uint64_t v194 = v193 & 0xFFFFFFFE;
    }
    if ((_DWORD)v194)
    {
      *(_WORD *)err = 0;
      LODWORD(v580) = 2;
      uint64_t p_vtable = _os_log_send_and_compose_impl( v194,  value,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "Not in Enhanced APFS Mode..",  err,  v580);

      if (p_vtable) {
        sub_100053B7C((const char *)p_vtable);
      }
    }

    else
    {

      uint64_t p_vtable = 0LL;
    }

    free((void *)p_vtable);
  }

LABEL_1154:
  if (*(_BYTE *)v11) {
    int v464 = 1;
  }
  else {
    int v464 = v2;
  }
  sub_1000418D8(v127, -1, v464, 0);
  if ([p_name[333] splitUserVolumeEnabled] && sub_10008450C() == 100)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v465 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v465, OS_LOG_TYPE_DEFAULT))
    {
      value[0] = 0LL;
      unsigned int v466 = sub_100053B4C(1);
      v467 = (os_log_s *)v465;
      if (os_log_type_enabled(v467, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v468 = v466;
      }
      else {
        uint64_t v468 = v466 & 0xFFFFFFFE;
      }
      if ((_DWORD)v468)
      {
        *(_WORD *)err = 0;
        LODWORD(v580) = 2;
        uint64_t p_vtable = _os_log_send_and_compose_impl( v468,  value,  0LL,  0LL,  &_mh_execute_header,  v467,  0LL,  "UM debug panic boot arg umd-migration-debug=100, Trying to redo Volume Migration, clearing DM plsit file ..",  err,  v580);

        if (p_vtable) {
          sub_100053B7C((const char *)p_vtable);
        }
      }

      else
      {

        uint64_t p_vtable = 0LL;
      }

      free((void *)p_vtable);
    }

    uint64_t v469 = sub_100019434(qword_1000DBD40);
    v470 = (void *)objc_claimAutoreleasedReturnValue(v469);
    uint64_t v0 = (uint64_t)[v470 removeFileAtPath:@"/private/var/mobile/Library/Preferences/com.apple.migration.plist" error:0];

    if ((v0 & 1) != 0)
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      v471 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v471, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_1191;
      }
      value[0] = 0LL;
      unsigned int v472 = sub_100053B4C(1);
      v471 = v471;
      if (os_log_type_enabled(v471, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v473 = v472;
      }
      else {
        uint64_t v473 = v472 & 0xFFFFFFFE;
      }
      if ((_DWORD)v473)
      {
        *(_WORD *)err = 0;
        LODWORD(v580) = 2;
        uint64_t v474 = _os_log_send_and_compose_impl( v473,  value,  0LL,  0LL,  &_mh_execute_header,  v471,  0LL,  "Removed DM PLIST, continuing to boot.. ",  err,  v580);
        goto LABEL_1187;
      }
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      v471 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v471, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_1191;
      }
      value[0] = 0LL;
      unsigned int v475 = sub_100053B4C(1);
      v471 = v471;
      if (os_log_type_enabled(v471, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v476 = v475;
      }
      else {
        uint64_t v476 = v475 & 0xFFFFFFFE;
      }
      if ((_DWORD)v476)
      {
        *(_WORD *)err = 0;
        LODWORD(v580) = 2;
        uint64_t v474 = _os_log_send_and_compose_impl( v476,  value,  0LL,  0LL,  &_mh_execute_header,  v471,  0LL,  "Unlink of DM Plist failed, unfortunately can't recover..",  err,  v580);
LABEL_1187:
        uint64_t v0 = v474;

        if (v0) {
          sub_100053B7C((const char *)v0);
        }
        goto LABEL_1190;
      }
    }

    uint64_t v0 = 0LL;
LABEL_1190:
    free((void *)v0);
LABEL_1191:
  }

  LODWORD(uuid[0]) = 0;
  if (!sub_10007E13C("/var/mobile/", (int *)uuid))
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v500 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v500, OS_LOG_TYPE_DEFAULT))
    {
      value[0] = 0LL;
      uint64_t p_vtable = sub_100053B4C(1);
      uint64_t v0 = (uint64_t)v500;
      if (os_log_type_enabled((os_log_t)v0, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v501 = p_vtable;
      }
      else {
        uint64_t v501 = p_vtable & 0xFFFFFFFE;
      }
      if ((_DWORD)v501)
      {
        *(_DWORD *)err = 67109120;
        *(_DWORD *)&err[4] = uuid[0];
        uint64_t p_vtable = _os_log_send_and_compose_impl( v501,  value,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "FAILED to Set LAST BOOTED USER after Erase Install with error:%d",  err);

        v502 = 0LL;
        if (p_vtable)
        {
          sub_100053B7C((const char *)p_vtable);
          v502 = (void *)p_vtable;
        }
      }

      else
      {

        v502 = 0LL;
      }

      free(v502);
    }

    sleep(2u);
    sub_100019F7C( "UserManagement early boot task failed to Set LAST BOOTED USER after Erase Install with error:%d",  LODWORD(uuid[0]));
    goto LABEL_1351;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v477 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v477, OS_LOG_TYPE_DEFAULT))
  {
    value[0] = 0LL;
    unsigned int v478 = sub_100053B4C(1);
    v479 = (os_log_s *)v477;
    if (os_log_type_enabled(v479, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v480 = v478;
    }
    else {
      uint64_t v480 = v478 & 0xFFFFFFFE;
    }
    if ((_DWORD)v480)
    {
      *(_WORD *)err = 0;
      LODWORD(v580) = 2;
      v481 = (char *)_os_log_send_and_compose_impl( v480,  value,  0LL,  0LL,  &_mh_execute_header,  v479,  0LL,  "Set Last Booted User for Primary User on erase install",  err,  v580);

      if (v481) {
        sub_100053B7C(v481);
      }
    }

    else
    {

      v481 = 0LL;
    }

    free(v481);
  }

LABEL_1206:
  if ((v587 & [p_name[333] splitUserVolumeEnabled]) == 1)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v483 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v483, OS_LOG_TYPE_DEFAULT))
    {
      value[0] = 0LL;
      unsigned int v484 = sub_100053B4C(1);
      v485 = (os_log_s *)v483;
      if (os_log_type_enabled(v485, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v486 = v484;
      }
      else {
        uint64_t v486 = v484 & 0xFFFFFFFE;
      }
      if ((_DWORD)v486)
      {
        *(_WORD *)err = 0;
        LODWORD(v580) = 2;
        v487 = (char *)_os_log_send_and_compose_impl( v486,  value,  0LL,  0LL,  &_mh_execute_header,  v485,  0LL,  "Migrating Persona Volumes if Any",  err,  v580);

        if (v487) {
          sub_100053B7C(v487);
        }
      }

      else
      {

        v487 = 0LL;
      }

      free(v487);
    }

    sub_100044C28();
  }

  if (*((_DWORD *)v48 + 826) == 1) {
    nullsub_1(qword_1000DBA70, v482);
  }
}

uint64_t sub_10003FC5C(int a1)
{
  if (v1)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v2 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      v13[0] = 0LL;
      unsigned int v3 = sub_100053B4C(1);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v4 = v3;
      }
      else {
        uint64_t v4 = v3 & 0xFFFFFFFE;
      }
      if ((_DWORD)v4)
      {
        *(_DWORD *)uint64_t v14 = 138412290;
        *(void *)&v14[4] = qword_1000DBCD8;
        unsigned int v5 = (const char *)_os_log_send_and_compose_impl( v4,  v13,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "Read user sessions in _gUserSessionTable %@",  v14,  12);
        uint64_t v6 = (char *)v5;
        if (v5) {
          sub_100053B7C(v5);
        }
      }

      else
      {
        uint64_t v6 = 0LL;
      }

      free(v6);
    }

    uint64_t v11 = 1LL;
  }

  else
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v2 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)uint64_t v14 = 0LL;
      unsigned int v7 = sub_100053B4C(1);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v8 = v7;
      }
      else {
        uint64_t v8 = v7 & 0xFFFFFFFE;
      }
      if ((_DWORD)v8)
      {
        LOWORD(v13[0]) = 0;
        uint64_t v9 = (const char *)_os_log_send_and_compose_impl( v8,  v14,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "LoadAllUserSessions: diskLoadUserSessions failed",  v13,  2);
        BOOL v10 = (char *)v9;
        if (v9) {
          sub_100053B7C(v9);
        }
      }

      else
      {
        BOOL v10 = 0LL;
      }

      free(v10);
    }

    uint64_t v11 = 0LL;
  }

  return v11;
}

void sub_10003FE64()
{
  if (qword_1000DBCD8)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v0 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = 0LL;
      unsigned int v1 = sub_100053B4C(1);
      if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v2 = v1;
      }
      else {
        uint64_t v2 = v1 & 0xFFFFFFFE;
      }
      if ((_DWORD)v2)
      {
        __int16 v9 = 0;
        unsigned int v3 = (const char *)_os_log_send_and_compose_impl( v2,  &v10,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "RESET FOREGROUND",  &v9,  2);
        uint64_t v4 = (char *)v3;
        if (v3) {
          sub_100053B7C(v3);
        }
      }

      else
      {
        uint64_t v4 = 0LL;
      }

      free(v4);
    }

    if (CFArrayGetCount((CFArrayRef)qword_1000DBCD8) >= 1)
    {
      CFIndex v5 = 0LL;
      do
      {
        ValueAtIndex = (__CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)qword_1000DBCD8, v5);
        if (ValueAtIndex)
        {
          unsigned int v7 = ValueAtIndex;
          CFTypeID v8 = CFGetTypeID(ValueAtIndex);
          if (v8 == CFDictionaryGetTypeID()) {
            CFDictionarySetValue(v7, kUMUserSessionForegroundKey, kCFBooleanFalse);
          }
        }

        ++v5;
      }

      while (CFArrayGetCount((CFArrayRef)qword_1000DBCD8) > v5);
    }
  }

uint64_t sub_10003FFE4(_DWORD *a1)
{
  if (a1) {
    *a1 = 0;
  }
  p_name = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
  id v5 = sub_10005F9A8(qword_1000DBA78, 0LL);
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
  if (v6)
  {
    unsigned int v7 = v6;
    unsigned int v8 = [v6 version];
    if (v8 >= +[UMDPersonaManifest currentVersion](&OBJC_CLASS___UMDPersonaManifest, "currentVersion"))
    {
      int v17 = v7;
      id v9 = [v7 version];
      sub_100019F7C( "usermanagerd: persona manifest version %u is from the future! Downgrading is not supported.",  [v7 version]);
    }

    else
    {
      unsigned int v1 = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v2 = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
      id v9 = (id)qword_1000DBA98;
      if (!os_log_type_enabled((os_log_t)v9, OS_LOG_TYPE_DEFAULT))
      {
LABEL_26:

        id v18 = v7;
        unsigned int v19 = (void *)objc_claimAutoreleasedReturnValue(+[UMDPersonaManifest manifest](&OBJC_CLASS___UMDPersonaManifest, "manifest"));
        if ([v18 generation]) {
          uint64_t v20 = (uint64_t)[v18 generation];
        }
        else {
          uint64_t v20 = 1LL;
        }
        [v19 setGeneration:v20];
        uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v18 users]);
        id v22 = [v21 count];

        if (v22 == (id)1)
        {
          __int128 v23 = (void *)objc_claimAutoreleasedReturnValue([v18 users]);
          uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue([v23 anyObject]);

          unsigned int v25 = objc_alloc_init(&OBJC_CLASS___UMDPersonaManifestUser);
          uint64_t v26 = sub_100019434(qword_1000DBA70);
          uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue(v26);
          id v28 = [v27 count];

          if (v28 == (id)1)
          {
            uint64_t v29 = sub_100019434(qword_1000DBA70);
            id v30 = (void *)objc_claimAutoreleasedReturnValue(v29);
            unsigned int v31 = (void *)objc_claimAutoreleasedReturnValue([v30 objectAtIndexedSubscript:0]);
            id v32 = sub_1000852B4(v31, (uint64_t)kUMUserSessionUUIDKey);
            id v33 = (id)objc_claimAutoreleasedReturnValue(v32);

            if (v33)
            {
              sub_1000198B4((uint64_t)v25, v33);
              uint64_t v34 = sub_100018E80((uint64_t)v24);
              uint64_t v35 = (char *)objc_claimAutoreleasedReturnValue(v34);
              sub_100019D4C(v25, v35);

              uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSSet setWithObject:](&OBJC_CLASS___NSSet, "setWithObject:", v25));
              [v19 setUsers:v36];

              id v37 = v19;
              p_name = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
            }

            else
            {
              if (qword_1000DBAC0 != -1) {
                dispatch_once(&qword_1000DBAC0, &stru_1000CD568);
              }
              p_name = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
              uint64_t v47 = (os_log_s *)(id)qword_1000DBAB8;
              if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
              {
                v180[0] = 0LL;
                unsigned int v48 = sub_100053B4C(0);
                if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
                  uint64_t v49 = v48;
                }
                else {
                  uint64_t v49 = v48 & 0xFFFFFFFE;
                }
                if ((_DWORD)v49)
                {
                  uint64_t v50 = qword_1000DBA70;
                  uint64_t v51 = v47;
                  uint64_t v52 = sub_100019434(v50);
                  uid_t v167 = (void *)objc_claimAutoreleasedReturnValue(v52);
                  uint64_t v165 = (void *)objc_claimAutoreleasedReturnValue([v167 objectAtIndexedSubscript:0]);
                  uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue([v165 objectForKeyedSubscript:kUMUserSessionUUIDKey]);
                  *(_DWORD *)v181 = 138543362;
                  *(void *)&v181[4] = v53;
                  LODWORD(v154) = 12;
                  uint64_t v54 = v49;
                  unsigned int v55 = v51;
                  uint64_t v56 = (char *)_os_log_send_and_compose_impl( v54,  v180,  0LL,  0LL,  &_mh_execute_header,  v51,  16LL,  "Failed to upgrade embedded persona manifest: Loaded user UUID is not a valid UUID: %{public}@",  v181,  v154);

                  if (v56) {
                    sub_100053B7C(v56);
                  }
                }

                else
                {
                  uint64_t v56 = 0LL;
                }

                p_name = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
                free(v56);
              }

              id v33 = 0LL;
              id v37 = 0LL;
            }

            uint64_t v2 = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
          }

          else
          {
            if (qword_1000DBAC0 != -1) {
              dispatch_once(&qword_1000DBAC0, &stru_1000CD568);
            }
            uint64_t v2 = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
            id v33 = (id)qword_1000DBAB8;
            if (os_log_type_enabled((os_log_t)v33, OS_LOG_TYPE_ERROR))
            {
              *(void *)v181 = 0LL;
              unsigned int v43 = sub_100053B4C(0);
              if (os_log_type_enabled((os_log_t)v33, OS_LOG_TYPE_ERROR)) {
                uint64_t v44 = v43;
              }
              else {
                uint64_t v44 = v43 & 0xFFFFFFFE;
              }
              if ((_DWORD)v44)
              {
                LOWORD(v180[0]) = 0;
                LODWORD(v154) = 2;
                id v45 = (const char *)_os_log_send_and_compose_impl( v44,  v181,  0LL,  0LL,  &_mh_execute_header,  v33,  16LL,  "Failed to upgrade embedded persona manifest: Multiple users are loaded, cannot gue ss which user UUID to use",  v180,  v154);
                unsigned int v46 = (char *)v45;
                if (v45) {
                  sub_100053B7C(v45);
                }
              }

              else
              {
                unsigned int v46 = 0LL;
              }

              free(v46);
            }

            id v37 = 0LL;
            p_name = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
          }
        }

        else
        {
          uint64_t v24 = v2[339];
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
          {
            v180[0] = 0LL;
            LODWORD(v3_Block_object_dispose(va, 8) = sub_100053B4C(1);
            if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v38 = v38;
            }
            else {
              uint64_t v38 = v38 & 0xFFFFFFFE;
            }
            if ((_DWORD)v38)
            {
              uint64_t v39 = v24;
              unsigned int v40 = (void *)objc_claimAutoreleasedReturnValue([v18 users]);
              id v41 = [v40 count];
              *(_DWORD *)v181 = 134217984;
              *(void *)&v181[4] = v41;
              unsigned int v42 = (char *)_os_log_send_and_compose_impl( v38,  v180,  0LL,  0LL,  &_mh_execute_header,  v39,  0LL,  "Failed to upgrade embedded persona manifest: Expected to find 1 user, found %lu",  v181);

              if (v42) {
                sub_100053B7C(v42);
              }
              p_name = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
            }

            else
            {
              unsigned int v42 = 0LL;
            }

            free(v42);
          }

          id v37 = 0LL;
        }

        if (v37)
        {
          int v17 = v37;
          if ((sub_1000601E8((uint64_t)p_name[335], v37, 0LL) & 1) != 0)
          {
LABEL_74:
            id v57 = v17;
            if (a1) {
              *a1 = 0;
            }
            unsigned int v155 = v57;
            unsigned int v58 = [v57 version];
            if (v58 != +[UMDPersonaManifest currentVersion](&OBJC_CLASS___UMDPersonaManifest, "currentVersion"))
            {
              if (qword_1000DBAA0 != -1) {
                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
              }
              id v68 = (os_log_s *)(id)qword_1000DBA98;
              if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
              {
                v180[0] = 0LL;
                LODWORD(v69) = sub_100053B4C(1);
                if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT)) {
                  uint64_t v69 = v69;
                }
                else {
                  uint64_t v69 = v69 & 0xFFFFFFFE;
                }
                if ((_DWORD)v69)
                {
                  char v70 = v68;
                  unsigned int v71 = [v155 version];
                  unsigned int v72 = +[UMDPersonaManifest currentVersion](&OBJC_CLASS___UMDPersonaManifest, "currentVersion");
                  *(_DWORD *)v181 = 67109376;
                  *(_DWORD *)&v181[4] = v71;
                  *(_WORD *)&v181[8] = 1024;
                  *(_DWORD *)&v181[10] = v72;
                  uint64_t v73 = (char *)_os_log_send_and_compose_impl( v69,  v180,  0LL,  0LL,  &_mh_execute_header,  v70,  0LL,  "NEEDS update from incorrect version:%u to %u",  v181,  14);

                  if (v73) {
                    sub_100053B7C(v73);
                  }
                }

                else
                {
                  uint64_t v73 = 0LL;
                }

                free(v73);
              }

              if (qword_1000DBAA0 != -1) {
                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
              }
              int v83 = (os_log_s *)(id)qword_1000DBA98;
              if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT))
              {
                *(void *)v181 = 0LL;
                unsigned int v84 = sub_100053B4C(1);
                if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT)) {
                  uint64_t v85 = v84;
                }
                else {
                  uint64_t v85 = v84 & 0xFFFFFFFE;
                }
                if ((_DWORD)v85)
                {
                  LOWORD(v180[0]) = 0;
                  LODWORD(v154) = 2;
                  unsigned int v86 = (const char *)_os_log_send_and_compose_impl( v85,  v181,  0LL,  0LL,  &_mh_execute_header,  v83,  0LL,  "STALE VERSION NUMBER IN MANIFEST, returning ...",  v180,  v154);
                  unsigned int v87 = (char *)v86;
                  if (v86) {
                    sub_100053B7C(v86);
                  }
                }

                else
                {
                  unsigned int v87 = 0LL;
                }

                free(v87);
              }

              uint64_t v82 = 0LL;
              if (a1) {
                *a1 = 2;
              }
              goto LABEL_220;
            }

            uint64_t v59 = sub_1000197A0((uint64_t)p_name[335]);
            id v60 = (void *)objc_claimAutoreleasedReturnValue(v59);
            unsigned int v61 = (void *)objc_claimAutoreleasedReturnValue([v60 userPersonas]);
            id v62 = [v61 count];

            if (v62)
            {
              if (qword_1000DBAA0 != -1) {
                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
              }
              id v63 = (os_log_s *)(id)qword_1000DBA98;
              if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
              {
                *(void *)v181 = 0LL;
                unsigned int v64 = sub_100053B4C(1);
                if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT)) {
                  uint64_t v65 = v64;
                }
                else {
                  uint64_t v65 = v64 & 0xFFFFFFFE;
                }
                if ((_DWORD)v65)
                {
                  LOWORD(v180[0]) = 0;
                  LODWORD(v154) = 2;
                  uint64_t v66 = (const char *)_os_log_send_and_compose_impl( v65,  v181,  0LL,  0LL,  &_mh_execute_header,  v63,  0LL,  "PREEXISTING MANIFEST, may be new user manifest being added",  v180,  v154);
                  uint64_t v67 = (char *)v66;
                  if (v66) {
                    sub_100053B7C(v66);
                  }
                }

                else
                {
                  uint64_t v67 = 0LL;
                }

                free(v67);
              }
            }

            if ([v155 generation])
            {
              id v88 = [v155 generation];
              uint64_t v89 = sub_1000197AC((uint64_t)p_name[335]);
              uint64_t v90 = (void *)objc_claimAutoreleasedReturnValue(v89);
              sub_100056294((uint64_t)v90, (uint64_t)v88);

              if (qword_1000DBAA0 != -1) {
                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
              }
              uint64_t v91 = (os_log_s *)(id)qword_1000DBA98;
              if (!os_log_type_enabled(v91, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_158;
              }
              v180[0] = 0LL;
              LODWORD(v92) = sub_100053B4C(1);
              if (os_log_type_enabled(v91, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v92 = v92;
              }
              else {
                uint64_t v92 = v92 & 0xFFFFFFFE;
              }
              if ((_DWORD)v92)
              {
                uint64_t v93 = (uint64_t)p_name[335];
                unsigned int v94 = v91;
                uint64_t v95 = sub_1000197AC(v93);
                uint64_t v96 = (void *)objc_claimAutoreleasedReturnValue(v95);
                uint64_t v97 = sub_100056274((uint64_t)v96);
                *(_DWORD *)v181 = 134217984;
                *(void *)&v181[4] = v97;
                uint64_t v98 = (void *)_os_log_send_and_compose_impl( v92,  v180,  0LL,  0LL,  &_mh_execute_header,  v94,  0LL,  "Loaded Persona Generation ID from manifest:%llu",  v181);

                if (!v98) {
                  goto LABEL_157;
                }
                goto LABEL_155;
              }
            }

            else
            {
              uint64_t v99 = sub_1000197AC((uint64_t)p_name[335]);
              CFIndex v100 = (void *)objc_claimAutoreleasedReturnValue(v99);
              sub_100056294((uint64_t)v100, 1LL);

              if (qword_1000DBAA0 != -1) {
                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
              }
              uint64_t v91 = (os_log_s *)(id)qword_1000DBA98;
              if (!os_log_type_enabled(v91, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_158;
              }
              *(void *)v181 = 0LL;
              unsigned int v101 = sub_100053B4C(1);
              if (os_log_type_enabled(v91, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v102 = v101;
              }
              else {
                uint64_t v102 = v101 & 0xFFFFFFFE;
              }
              if ((_DWORD)v102)
              {
                LOWORD(v180[0]) = 0;
                LODWORD(v154) = 2;
                uint64_t v98 = (void *)_os_log_send_and_compose_impl( v102,  v181,  0LL,  0LL,  &_mh_execute_header,  v91,  0LL,  "No Persona Generation ID from manifest setting to 1",  v180,  v154);
                if (!v98)
                {
LABEL_157:
                  free(v98);
LABEL_158:

                  unsigned int v103 = &AKSGetLastUser_ptr;
                  uint64_t v104 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
                  uint64_t v105 = v155;
                  uint64_t v106 = (void *)objc_claimAutoreleasedReturnValue([v155 users]);
                  id v107 = [v106 count];

                  if (!v107)
                  {
                    if (qword_1000DBAA0 != -1) {
                      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                    }
                    id v108 = (os_log_s *)(id)qword_1000DBA98;
                    if (os_log_type_enabled(v108, OS_LOG_TYPE_DEFAULT))
                    {
                      *(void *)v181 = 0LL;
                      unsigned int v109 = sub_100053B4C(1);
                      if (os_log_type_enabled(v108, OS_LOG_TYPE_DEFAULT)) {
                        uint64_t v110 = v109;
                      }
                      else {
                        uint64_t v110 = v109 & 0xFFFFFFFE;
                      }
                      if ((_DWORD)v110)
                      {
                        LOWORD(v180[0]) = 0;
                        LODWORD(v154) = 2;
                        uint64_t v111 = (const char *)_os_log_send_and_compose_impl( v110,  v181,  0LL,  0LL,  &_mh_execute_header,  v108,  0LL,  "No user entries on the manifest, may be first creation/erase install scenario",  v180,  v154);
                        id v112 = (char *)v111;
                        if (v111) {
                          sub_100053B7C(v111);
                        }
                      }

                      else
                      {
                        id v112 = 0LL;
                      }

                      free(v112);
                    }

                    uint64_t v105 = v155;
                  }

                  __int128 v176 = 0u;
                  __int128 v177 = 0u;
                  __int128 v174 = 0u;
                  __int128 v175 = 0u;
                  id v113 = (void *)objc_claimAutoreleasedReturnValue([v105 users]);
                  id v159 = [v113 countByEnumeratingWithState:&v174 objects:v181 count:16];
                  if (v159)
                  {
                    uint64_t v114 = 0LL;
                    uint64_t v156 = *(void *)v175;
                    uint64_t v115 = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
                    v157 = v113;
                    CFTypeRef v158 = v104;
                    do
                    {
                      uint64_t v116 = 0LL;
                      do
                      {
                        if (*(void *)v175 != v156) {
                          objc_enumerationMutation(v113);
                        }
                        uint64_t v168 = *(void *)(*((void *)&v174 + 1) + 8 * v116);
                        uint64_t v160 = v116;
                        uint64_t v117 = (os_log_s *)(id)qword_1000DBA98;
                        if (os_log_type_enabled(v117, OS_LOG_TYPE_DEBUG))
                        {
                          uint64_t v173 = 0LL;
                          LODWORD(v11_Block_object_dispose(va, 8) = sub_100053B4C(1);
                          if (os_log_type_enabled(v117, OS_LOG_TYPE_DEBUG)) {
                            uint64_t v118 = v118;
                          }
                          else {
                            uint64_t v118 = v118 & 0xFFFFFFFE;
                          }
                          if ((_DWORD)v118)
                          {
                            uint64_t v119 = v114;
                            uint64_t v120 = v117;
                            uint64_t v121 = sub_100019434(v168);
                            uint64_t v122 = (void *)objc_claimAutoreleasedReturnValue(v121);
                            unsigned int v123 = (void *)objc_claimAutoreleasedReturnValue([v122 UUIDString]);
                            int v178 = 138412290;
                            *(void *)uint64_t v179 = v123;
                            LODWORD(v154) = 12;
                            uint64_t v124 = (char *)_os_log_send_and_compose_impl( v118,  &v173,  0LL,  0LL,  &_mh_execute_header,  v120,  2LL,  "Found User Entry:%@",  &v178,  v154);

                            if (v124) {
                              sub_100053B7C(v124);
                            }
                            uint64_t v114 = v119;
                            uint64_t v115 = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
                          }

                          else
                          {
                            uint64_t v124 = 0LL;
                          }

                          free(v124);
                        }

                        unsigned int v164 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
                        __int128 v169 = 0u;
                        __int128 v170 = 0u;
                        __int128 v171 = 0u;
                        __int128 v172 = 0u;
                        uint64_t v125 = sub_100018E80(v168);
                        id obj = (id)objc_claimAutoreleasedReturnValue(v125);
                        id v166 = [obj countByEnumeratingWithState:&v169 objects:v180 count:16];
                        if (v166)
                        {
                          uint64_t v163 = *(void *)v170;
                          uint64_t v126 = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
                          do
                          {
                            for (CFIndex i = 0LL; i != v166; CFIndex i = (char *)i + 1)
                            {
                              if (*(void *)v170 != v163) {
                                objc_enumerationMutation(obj);
                              }
                              uint64_t v128 = *(void *)(*((void *)&v169 + 1) + 8LL * (void)i);
                              CFTypeID v129 = v126[339];
                              if (os_log_type_enabled(v129, OS_LOG_TYPE_DEFAULT))
                              {
                                uint64_t v173 = 0LL;
                                LODWORD(v130) = sub_100053B4C(1);
                                if (os_log_type_enabled(v129, OS_LOG_TYPE_DEFAULT)) {
                                  uint64_t v130 = v130;
                                }
                                else {
                                  uint64_t v130 = v130 & 0xFFFFFFFE;
                                }
                                if ((_DWORD)v130)
                                {
                                  unsigned int v162 = v114;
                                  unsigned int v131 = v103;
                                  uint64_t v132 = p_name;
                                  id v133 = v129;
                                  int v134 = sub_1000642D4(v128);
                                  uint64_t v135 = sub_100019434(v168);
                                  unsigned int v136 = (void *)objc_claimAutoreleasedReturnValue(v135);
                                  uint64_t v137 = (void *)objc_claimAutoreleasedReturnValue([v136 UUIDString]);
                                  int v178 = 67109378;
                                  *(_DWORD *)uint64_t v179 = v134;
                                  *(_WORD *)&v179[4] = 2112;
                                  *(void *)&v179[6] = v137;
                                  LODWORD(v154) = 18;
                                  id v138 = (char *)_os_log_send_and_compose_impl( v130,  &v173,  0LL,  0LL,  &_mh_execute_header,  v133,  0LL,  "Adding %d entry to persona Table for user:%@",  &v178,  v154);

                                  if (v138) {
                                    sub_100053B7C(v138);
                                  }
                                  p_name = v132;
                                  unsigned int v103 = v131;
                                  uint64_t v114 = v162;
                                  uint64_t v115 = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
                                  uint64_t v126 = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
                                }

                                else
                                {
                                  id v138 = 0LL;
                                }

                                free(v138);
                              }

                              int v139 = v103[120];
                              id v140 = sub_1000760E4(v128);
                              uint64_t v141 = (void *)objc_claimAutoreleasedReturnValue(v140);
                              uint64_t v142 = (void *)objc_claimAutoreleasedReturnValue([v139 dictionaryWithDictionary:v141]);

                              uint64_t v143 = sub_100019434(v168);
                              id v144 = (void *)objc_claimAutoreleasedReturnValue(v143);
                              uint64_t v145 = (void *)objc_claimAutoreleasedReturnValue([v144 UUIDString]);
                              [v142 setObject:v145 forKeyedSubscript:kUMUserPersonaUserODUUIDKey];

                              [v164 addObject:v142];
                            }

                            id v166 = [obj countByEnumeratingWithState:&v169 objects:v180 count:16];
                          }

                          while (v166);
                        }

                        uint64_t v146 = sub_100019434(v168);
                        uint64_t v147 = (void *)objc_claimAutoreleasedReturnValue(v146);
                        CFTypeID v148 = (void *)objc_claimAutoreleasedReturnValue([v147 UUIDString]);
                        uint64_t v104 = v158;
                        [v158 setObject:v164 forKeyedSubscript:v148];

                        uint64_t v116 = v160 + 1;
                        id v113 = v157;
                      }

                      while ((id)(v160 + 1) != v159);
                      id v159 = [v157 countByEnumeratingWithState:&v174 objects:v181 count:16];
                    }

                    while (v159);

                    uint64_t v149 = sub_1000197A0((uint64_t)p_name[335]);
                    unsigned int v150 = (void *)objc_claimAutoreleasedReturnValue(v149);
                    [v150 setUserPersonas:v158];

                    if ((v114 & 1) != 0) {
                      sub_10005B2D0((uint64_t)p_name[335]);
                    }
                  }

                  else
                  {

                    uint64_t v151 = sub_1000197A0((uint64_t)p_name[335]);
                    uint64_t v152 = (void *)objc_claimAutoreleasedReturnValue(v151);
                    [v152 setUserPersonas:v104];
                  }

                  uint64_t v82 = 1LL;
LABEL_220:

                  int v17 = v155;
                  goto LABEL_221;
                }

LABEL_155:
                sub_100053B7C((const char *)v98);
                goto LABEL_157;
              }
            }

            uint64_t v98 = 0LL;
            goto LABEL_157;
          }

          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          uint64_t v77 = v2[339];
          if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
          {
            *(void *)v181 = 0LL;
            unsigned int v78 = sub_100053B4C(1);
            if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v79 = v78;
            }
            else {
              uint64_t v79 = v78 & 0xFFFFFFFE;
            }
            if ((_DWORD)v79)
            {
              LOWORD(v180[0]) = 0;
              LODWORD(v154) = 2;
              id v80 = (const char *)_os_log_send_and_compose_impl( v79,  v181,  0LL,  0LL,  &_mh_execute_header,  v77,  0LL,  "Failed to write out upgraded persona manifest data",  v180,  v154);
              unsigned int v81 = (char *)v80;
              if (v80) {
                sub_100053B7C(v80);
              }
            }

            else
            {
              unsigned int v81 = 0LL;
            }

            free(v81);
          }

          if (!a1) {
            goto LABEL_171;
          }
          goto LABEL_118;
        }

        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        unsigned int v13 = v2[339];
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)v181 = 0LL;
          unsigned int v74 = sub_100053B4C(1);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v75 = v74;
          }
          else {
            uint64_t v75 = v74 & 0xFFFFFFFE;
          }
          if ((_DWORD)v75)
          {
            LOWORD(v180[0]) = 0;
            LODWORD(v154) = 2;
            int v16 = (const char *)_os_log_send_and_compose_impl( v75,  v181,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "Failed to upgrade persona manifest data",  v180,  v154);
LABEL_104:
            unsigned int v76 = (char *)v16;
            if (v16) {
              sub_100053B7C(v16);
            }
            goto LABEL_116;
          }

          goto LABEL_115;
        }

        goto LABEL_117;
      }

      v180[0] = 0LL;
      LODWORD(v10) = sub_100053B4C(1);
      if (os_log_type_enabled((os_log_t)v9, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v10 = v10;
      }
      else {
        uint64_t v10 = v10 & 0xFFFFFFFE;
      }
      if ((_DWORD)v10)
      {
        id v11 = v9;
        *(_DWORD *)v181 = 67109376;
        *(_DWORD *)&v181[4] = [v7 version];
        *(_WORD *)&v181[8] = 1024;
        *(_DWORD *)&v181[10] = +[UMDPersonaManifest currentVersion](&OBJC_CLASS___UMDPersonaManifest, "currentVersion");
        id v12 = (char *)_os_log_send_and_compose_impl( v10,  v180,  0LL,  0LL,  &_mh_execute_header,  v11,  0LL,  "Upgrading persona manifest from version %d to version %d",  v181,  14);

        if (v12) {
          sub_100053B7C(v12);
        }
        goto LABEL_25;
      }
    }

    id v12 = 0LL;
LABEL_25:
    free(v12);
    goto LABEL_26;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  unsigned int v13 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)v181 = 0LL;
    unsigned int v14 = sub_100053B4C(1);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v15 = v14;
    }
    else {
      uint64_t v15 = v14 & 0xFFFFFFFE;
    }
    if ((_DWORD)v15)
    {
      LOWORD(v180[0]) = 0;
      int v16 = (const char *)_os_log_send_and_compose_impl( v15,  v181,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "Failed to load personas: Failed to load persona manifest",  v180,  2);
      goto LABEL_104;
    }

LABEL_115:
    unsigned int v76 = 0LL;
LABEL_116:
    free(v76);
  }

LABEL_117:
  int v17 = 0LL;
  if (!a1)
  {
LABEL_171:
    uint64_t v82 = 0LL;
    goto LABEL_221;
  }

LABEL_118:
  uint64_t v82 = 0LL;
  *a1 = 2;
LABEL_221:

  return v82;
}

uint64_t sub_100041468(void *a1, uint64_t a2, void *a3)
{
  id v5 = a1;
  uint64_t v6 = sub_100019B18(qword_1000DBD40);
  unsigned int v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
  unsigned int v8 = [v7 isIdentityLoadedIntoSession:a2];

  if (v8)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v9 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)uint64_t v36 = 0LL;
      unsigned int v10 = sub_100053B4C(1);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = v10 & 0xFFFFFFFE;
      }
      if ((_DWORD)v11)
      {
        LODWORD(v37) = 67109120;
        HIDWORD(v37) = a2;
        id v12 = (const char *)_os_log_send_and_compose_impl( v11,  v36,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "AKSIdentity for user:%d already loaded, skipping load",  &v37);
        unsigned int v13 = (char *)v12;
        if (v12) {
          sub_100053B7C(v12);
        }
      }

      else
      {
        unsigned int v13 = 0LL;
      }

      free(v13);
    }

    id v19 = 0LL;
LABEL_47:
    uint64_t v33 = 1LL;
    goto LABEL_48;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  unsigned int v14 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t v36 = 0LL;
    unsigned int v15 = sub_100053B4C(1);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v15 & 0xFFFFFFFE;
    }
    if ((_DWORD)v16)
    {
      LODWORD(v37) = 67109120;
      HIDWORD(v37) = a2;
      int v17 = (const char *)_os_log_send_and_compose_impl( v16,  v36,  0LL,  0LL,  &_mh_execute_header,  v14,  0LL,  "AKSIdentity for user:%d not loaded, loading..",  &v37);
      id v18 = (char *)v17;
      if (v17) {
        sub_100053B7C(v17);
      }
    }

    else
    {
      id v18 = 0LL;
    }

    free(v18);
  }

  uint64_t v20 = sub_100019B18(qword_1000DBD40);
  uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue(v20);
  id v35 = 0LL;
  unsigned int v22 = [v21 loadIdentity:v5 intoSession:a2 error:&v35];
  id v19 = v35;

  if (v22)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    __int128 v23 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)uint64_t v36 = 0LL;
      unsigned int v24 = sub_100053B4C(1);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v25 = v24;
      }
      else {
        uint64_t v25 = v24 & 0xFFFFFFFE;
      }
      if ((_DWORD)v25)
      {
        LOWORD(v37) = 0;
        uint64_t v26 = (const char *)_os_log_send_and_compose_impl( v25,  v36,  0LL,  0LL,  &_mh_execute_header,  v23,  0LL,  "AKSLoadIdentity Succeeded",  &v37,  2);
        uint64_t v27 = (char *)v26;
        if (v26) {
          sub_100053B7C(v26);
        }
      }

      else
      {
        uint64_t v27 = 0LL;
      }

      free(v27);
    }

    goto LABEL_47;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v28 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v37 = 0LL;
    LODWORD(v29) = sub_100053B4C(1);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v29 = v29;
    }
    else {
      uint64_t v29 = v29 & 0xFFFFFFFE;
    }
    if ((_DWORD)v29)
    {
      id v30 = v28;
      id v31 = [v19 code];
      *(_DWORD *)uint64_t v36 = 134217984;
      *(void *)&v36[4] = v31;
      id v32 = (char *)_os_log_send_and_compose_impl( v29,  &v37,  0LL,  0LL,  &_mh_execute_header,  v30,  0LL,  "AKSLoadIdentity failed with Error:%ld",  v36);

      if (v32) {
        sub_100053B7C(v32);
      }
    }

    else
    {
      id v32 = 0LL;
    }

    free(v32);
  }

  if (a3)
  {
    id v19 = v19;
    uint64_t v33 = 0LL;
    *a3 = v19;
  }

  else
  {
    uint64_t v33 = 0LL;
  }

LABEL_48:
  return v33;
}

        uint64_t v25 = 0LL;
LABEL_49:
        free(v25);
        p_name = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
      }
    }

    qword_1000DACC0 = sub_100083CD4(v2, @"APNSID");
    uint64_t v26 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v26, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v190 = 0LL;
      uint64_t v27 = sub_100053B4C(1);
      id v28 = (os_log_s *)v26;
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v29 = v27;
      }
      else {
        uint64_t v29 = v27 & 0xFFFFFFFE;
      }
      if ((_DWORD)v29)
      {
        *(_DWORD *)char v189 = 134217984;
        *(void *)&v189[4] = qword_1000DACC0;
        id v30 = (char *)_os_log_send_and_compose_impl( v29,  &v190,  0LL,  0LL,  &_mh_execute_header,  v28,  0LL,  "diskLoadUserSessions, APNSID:, set to %llu",  v189);

        if (v30) {
          sub_100053B7C(v30);
        }
      }

      else
      {

        id v30 = 0LL;
      }

      p_name = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
      free(v30);
    }

    if (v3)
    {
      if (qword_1000DBCD8 && CFArrayGetCount((CFArrayRef)qword_1000DBCD8) >= 1) {
        CFArrayRemoveAllValues((CFMutableArrayRef)qword_1000DBCD8);
      }
      int v186 = v2;
      BytePtr = (UInt8 *)CFDataGetBytePtr(v4);
      int Length = CFDataGetLength(v4);
      uint64_t v33 = (const __CFArray *)sub_100083F70(BytePtr, Length);
      if (v3 < 1)
      {
        uint64_t v36 = 0;
        id v35 = 0;
      }

      else
      {
        uint64_t v34 = 0LL;
        id v35 = 0;
        uint64_t v36 = 0;
        uint64_t v37 = v3;
        uint64_t v38 = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
        do
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v33, v34);
          if (ValueAtIndex)
          {
            unsigned int v40 = ValueAtIndex;
            id v41 = CFGetTypeID(ValueAtIndex);
            if (v41 == CFDictionaryGetTypeID())
            {
              unsigned int v42 = sub_100083C6C(v40, kUMUserSessionIDKey);
              int valuePtr = v42;
              unsigned int v43 = *((_DWORD *)v38 + 826);
              if (v18 && v42 > 501)
              {
                if (v43 != 1)
                {
                  if (qword_1000DBAA0 != -1) {
                    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                  }
                  uint64_t v44 = (id)qword_1000DBA98;
                  if (os_log_type_enabled((os_log_t)v44, OS_LOG_TYPE_DEFAULT))
                  {
                    *(void *)char v189 = 0LL;
                    id v45 = sub_100053B4C(1);
                    unsigned int v46 = (os_log_s *)v44;
                    if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT)) {
                      uint64_t v47 = v45;
                    }
                    else {
                      uint64_t v47 = v45 & 0xFFFFFFFE;
                    }
                    if ((_DWORD)v47)
                    {
                      LODWORD(v190) = 67109120;
                      HIDWORD(v190) = valuePtr;
                      unsigned int v48 = (char *)_os_log_send_and_compose_impl( v47,  v189,  0LL,  0LL,  &_mh_execute_header,  v46,  0LL,  "LOG Found Non Primary with uid:%d, device may be sharediPad or provisioned, set remove primary",  &v190);

                      if (v48) {
                        sub_100053B7C(v48);
                      }
                    }

                    else
                    {

                      unsigned int v48 = 0LL;
                    }

                    uint64_t v38 = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
                    free(v48);
                  }

                  unsigned int v7 = 1;
                  unsigned int v42 = valuePtr;
                }

                id v18 = 0;
                *((_DWORD *)v38 + 826) = v7;
                uint64_t v36 = 1;
                unsigned int v43 = v7;
              }

              if (v43 == 1 && v42 == 502 && !CFDictionaryContainsKey(v40, kUMUserSessionisPrimaryKey))
              {
                if (qword_1000DBAA0 != -1) {
                  dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
                }
                uint64_t v49 = (id)qword_1000DBA98;
                if (os_log_type_enabled((os_log_t)v49, OS_LOG_TYPE_DEFAULT))
                {
                  *(void *)char v189 = 0LL;
                  uint64_t v50 = sub_100053B4C(1);
                  uint64_t v51 = (os_log_s *)v49;
                  if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT)) {
                    uint64_t v52 = v50;
                  }
                  else {
                    uint64_t v52 = v50 & 0xFFFFFFFE;
                  }
                  if ((_DWORD)v52)
                  {
                    LOWORD(v190) = 0;
                    LODWORD(v185) = 2;
                    uint64_t v53 = (char *)_os_log_send_and_compose_impl( v52,  v189,  0LL,  0LL,  &_mh_execute_header,  v51,  0LL,  "Missing isPrimaryKey on loginUI, updating...",  &v190,  v185);

                    if (v53) {
                      sub_100053B7C(v53);
                    }
                  }

                  else
                  {

                    uint64_t v53 = 0LL;
                  }

                  free(v53);
                }

                CFDictionarySetValue(v40, kUMUserSessionisPrimaryKey, kCFBooleanTrue);
                CFDictionarySetValue(v40, kUMUserSessionisAdminKey, kCFBooleanTrue);
                uint64_t v36 = 1;
                uint64_t v38 = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
              }

              if (v7 == 1 && valuePtr < 502) {
                unsigned int v7 = 1;
              }
              else {
                sub_100021680(v40, a1);
              }
            }
          }

          ++v34;
        }

        while (v37 != v34);
      }

      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v2 = v186;
      uint64_t v54 = (id)qword_1000DBA98;
      if (os_log_type_enabled((os_log_t)v54, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v190 = 0LL;
        unsigned int v55 = sub_100053B4C(1);
        uint64_t v56 = (os_log_s *)v54;
        if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT)) {
          id v57 = v55;
        }
        else {
          id v57 = v55 & 0xFFFFFFFE;
        }
        if ((_DWORD)v57)
        {
          *(_DWORD *)char v189 = 138412290;
          *(void *)&v189[4] = qword_1000DBCD8;
          LODWORD(v185) = 12;
          unsigned int v58 = (char *)_os_log_send_and_compose_impl( v57,  &v190,  0LL,  0LL,  &_mh_execute_header,  v56,  0LL,  "Reloaded _gUserSessionTable %@",  v189,  v185);

          if (v58) {
            sub_100053B7C(v58);
          }
        }

        else
        {

          unsigned int v58 = 0LL;
        }

        free(v58);
      }

      if (v33) {
        CFRelease(v33);
      }
      if (v35)
      {
        p_name = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
        if (sub_10002E0A4(501, a1))
        {
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          uint64_t v59 = (id)qword_1000DBA98;
          if (os_log_type_enabled((os_log_t)v59, OS_LOG_TYPE_DEFAULT))
          {
            *(void *)char v189 = 0LL;
            id v60 = sub_100053B4C(1);
            uint64_t v59 = v59;
            if (os_log_type_enabled((os_log_t)v59, OS_LOG_TYPE_DEFAULT)) {
              unsigned int v61 = v60;
            }
            else {
              unsigned int v61 = v60 & 0xFFFFFFFE;
            }
            if ((_DWORD)v61)
            {
              LOWORD(v190) = 0;
              LODWORD(v185) = 2;
              id v62 = (char *)_os_log_send_and_compose_impl( v61,  v189,  0LL,  0LL,  &_mh_execute_header,  v59,  0LL,  "Removing existing Primary session, device entering shared iPad",  &v190,  v185);

              if (v62) {
                sub_100053B7C(v62);
              }
            }

            else
            {

              id v62 = 0LL;
            }

            free(v62);
          }

          uint64_t v36 = 1;
        }

        else
        {
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          uint64_t v59 = (id)qword_1000DBA98;
          if (os_log_type_enabled((os_log_t)v59, OS_LOG_TYPE_DEFAULT))
          {
            *(void *)char v189 = 0LL;
            id v63 = sub_100053B4C(1);
            uint64_t v59 = v59;
            if (os_log_type_enabled((os_log_t)v59, OS_LOG_TYPE_DEFAULT)) {
              unsigned int v64 = v63;
            }
            else {
              unsigned int v64 = v63 & 0xFFFFFFFE;
            }
            if ((_DWORD)v64)
            {
              LOWORD(v190) = 0;
              LODWORD(v185) = 2;
              uint64_t v65 = (char *)_os_log_send_and_compose_impl( v64,  v189,  0LL,  0LL,  &_mh_execute_header,  v59,  0LL,  "Primary session not present, device entering shared iPad",  &v190,  v185);

              if (v65) {
                sub_100053B7C(v65);
              }
            }

            else
            {

              uint64_t v65 = 0LL;
            }

            free(v65);
          }
        }
      }

      else
      {
        p_name = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
      }
    }

    else
    {
      uint64_t v36 = 0;
    }

    if (CFDictionaryContainsKey(v2, @"MAXUSER"))
    {
      dword_1000DACB4 = sub_100083C6C(v2, @"MAXUSER");
    }

    else
    {
      uint64_t v66 = CFDictionaryContainsKey(v2, @"MAXUSERSIZE");
      dword_1000DACB4 = -1;
      if (!v66)
      {
        uint64_t v67 = 0LL;
LABEL_153:
        qword_1000DBD10 = v67;
        id v68 = CFDictionaryContainsKey(v2, @"USESSTYPE");
        if (v68) {
          id v68 = sub_100083C6C(v2, @"USESSTYPE");
        }
        dword_1000DBCF0 = v68;
        uint64_t v69 = CFDictionaryContainsKey(v2, @"LOGINCHECKIN");
        if (v69) {
          uint64_t v69 = sub_100083C6C(v2, @"LOGINCHECKIN");
        }
        dword_1000DBCF4 = v69;
        if (CFDictionaryContainsKey(v2, @"DEVICENETWORKBG"))
        {
          char v70 = sub_100083C6C(v2, @"DEVICENETWORKBG");
          unsigned int v71 = v70 & ~(v70 >> 31);
        }

        else
        {
          unsigned int v71 = 0;
        }

        dword_1000DBD18 = v71;
        if (CFDictionaryContainsKey(v2, @"SYNCENT"))
        {
          unsigned int v72 = sub_100083C6C(v2, @"SYNCENT");
          if (v72 >= 1)
          {
            uint64_t v73 = (const __CFData *)sub_100083BFC(v2, @"SYNCBLOB");
            unsigned int v74 = (id)qword_1000DBA98;
            if (os_log_type_enabled((os_log_t)v74, OS_LOG_TYPE_DEFAULT))
            {
              *(void *)char v189 = 0LL;
              uint64_t v75 = sub_100053B4C(1);
              unsigned int v76 = (os_log_s *)v74;
              if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v77 = v75;
              }
              else {
                uint64_t v77 = v75 & 0xFFFFFFFE;
              }
              if ((_DWORD)v77)
              {
                LODWORD(v190) = 67109120;
                HIDWORD(v190) = v72;
                unsigned int v78 = (char *)_os_log_send_and_compose_impl( v77,  v189,  0LL,  0LL,  &_mh_execute_header,  v76,  0LL,  "LOAD found %d BUBBLE entries",  &v190);

                if (v78) {
                  sub_100053B7C(v78);
                }
              }

              else
              {

                unsigned int v78 = 0LL;
              }

              p_name = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
              free(v78);
            }

            if (qword_1000DBCF8 && CFArrayGetCount((CFArrayRef)qword_1000DBCF8) >= 1) {
              CFArrayRemoveAllValues((CFMutableArrayRef)qword_1000DBCF8);
            }
            id v88 = (UInt8 *)CFDataGetBytePtr(v73);
            uint64_t v89 = CFDataGetLength(v73);
            uint64_t v90 = (const __CFArray *)sub_100083F70(v88, v89);
            uint64_t v91 = (id)qword_1000DBA98;
            if (os_log_type_enabled((os_log_t)v91, OS_LOG_TYPE_DEFAULT))
            {
              unsigned int v190 = 0LL;
              uint64_t v92 = sub_100053B4C(1);
              uint64_t v93 = (os_log_s *)v91;
              if (os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT)) {
                unsigned int v94 = v92;
              }
              else {
                unsigned int v94 = v92 & 0xFFFFFFFE;
              }
              if ((_DWORD)v94)
              {
                *(_DWORD *)char v189 = 138412290;
                *(void *)&v189[4] = v90;
                LODWORD(v185) = 12;
                uint64_t v95 = (char *)_os_log_send_and_compose_impl( v94,  &v190,  0LL,  0LL,  &_mh_execute_header,  v93,  0LL,  "FOUND SYNC BUBBLE ARRAY:%@",  v189,  v185);

                if (v95) {
                  sub_100053B7C(v95);
                }
              }

              else
              {

                uint64_t v95 = 0LL;
              }

              free(v95);
            }

            if (CFArrayGetCount(v90) >= 1)
            {
              uint64_t v96 = 0LL;
              do
              {
                uint64_t v97 = (const __CFNumber *)CFArrayGetValueAtIndex(v90, v96);
                if (v97)
                {
                  uint64_t v98 = v97;
                  uint64_t v99 = CFGetTypeID(v97);
                  if (v99 == CFNumberGetTypeID())
                  {
                    CFNumberGetValue(v98, kCFNumberIntType, &valuePtr);
                    if (valuePtr >= 502) {
                      sub_10001D55C(valuePtr);
                    }
                  }
                }

                ++v96;
              }

              while (CFArrayGetCount(v90) > v96);
            }

            CFIndex v100 = p_name[340];
            if (qword_1000DBCF8)
            {
              unsigned int v101 = (os_log_s *)(id)qword_1000DBA98;
              if (!os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_234;
              }
              unsigned int v190 = 0LL;
              uint64_t v102 = sub_100053B4C(1);
              unsigned int v101 = v101;
              if (os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT)) {
                unsigned int v103 = v102;
              }
              else {
                unsigned int v103 = v102 & 0xFFFFFFFE;
              }
              if ((_DWORD)v103)
              {
                *(_DWORD *)char v189 = 138412290;
                *(void *)&v189[4] = qword_1000DBCF8;
                LODWORD(v185) = 12;
                uint64_t v104 = _os_log_send_and_compose_impl( v103,  &v190,  0LL,  0LL,  &_mh_execute_header,  v101,  0LL,  "CURRENT ENTRIES for SYNC BUBBLE TABLE: %@",  v189,  v185);
                goto LABEL_230;
              }
            }

            else
            {
              unsigned int v101 = (os_log_s *)(id)qword_1000DBA98;
              if (!os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_234;
              }
              *(void *)char v189 = 0LL;
              uint64_t v105 = sub_100053B4C(1);
              unsigned int v101 = v101;
              if (os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v106 = v105;
              }
              else {
                uint64_t v106 = v105 & 0xFFFFFFFE;
              }
              if ((_DWORD)v106)
              {
                LOWORD(v190) = 0;
                LODWORD(v185) = 2;
                uint64_t v104 = _os_log_send_and_compose_impl( v106,  v189,  0LL,  0LL,  &_mh_execute_header,  v101,  0LL,  "NO ENTRIES for SYNC BUBBLE TABLE",  &v190,  v185);
LABEL_230:
                id v107 = (char *)v104;

                if (v107) {
                  sub_100053B7C(v107);
                }
                goto LABEL_233;
              }
            }

            id v107 = 0LL;
LABEL_233:
            free(v107);
LABEL_234:

            if (v90) {
              CFRelease(v90);
            }
LABEL_242:
            if (CFDictionaryContainsKey(v2, @"LRUENT"))
            {
              unsigned int v109 = sub_100083C6C(v2, @"LRUENT");
              if (v109 >= 1)
              {
                uint64_t v110 = (const __CFData *)sub_100083BFC(v2, @"LRUBLOB");
                uint64_t v111 = (id)qword_1000DBA98;
                if (os_log_type_enabled((os_log_t)v111, OS_LOG_TYPE_DEFAULT))
                {
                  *(void *)char v189 = 0LL;
                  id v112 = sub_100053B4C(1);
                  id v113 = (os_log_s *)v111;
                  if (os_log_type_enabled(v113, OS_LOG_TYPE_DEFAULT)) {
                    uint64_t v114 = v112;
                  }
                  else {
                    uint64_t v114 = v112 & 0xFFFFFFFE;
                  }
                  if ((_DWORD)v114)
                  {
                    LODWORD(v190) = 67109120;
                    HIDWORD(v190) = v109;
                    uint64_t v115 = (char *)_os_log_send_and_compose_impl( v114,  v189,  0LL,  0LL,  &_mh_execute_header,  v113,  0LL,  "LOAD found %d LRU entries",  &v190);

                    if (v115) {
                      sub_100053B7C(v115);
                    }
                  }

                  else
                  {

                    uint64_t v115 = 0LL;
                  }

                  p_name = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
                  free(v115);
                }

                if (qword_1000DBD00 && CFArrayGetCount((CFArrayRef)qword_1000DBD00) >= 1) {
                  CFArrayRemoveAllValues((CFMutableArrayRef)qword_1000DBD00);
                }
                uint64_t v125 = (UInt8 *)CFDataGetBytePtr(v110);
                uint64_t v126 = CFDataGetLength(v110);
                uint64_t v127 = (const __CFArray *)sub_100083F70(v125, v126);
                uint64_t v128 = (id)qword_1000DBA98;
                if (os_log_type_enabled((os_log_t)v128, OS_LOG_TYPE_DEFAULT))
                {
                  unsigned int v190 = 0LL;
                  CFTypeID v129 = sub_100053B4C(1);
                  uint64_t v130 = (os_log_s *)v128;
                  if (os_log_type_enabled(v130, OS_LOG_TYPE_DEFAULT)) {
                    unsigned int v131 = v129;
                  }
                  else {
                    unsigned int v131 = v129 & 0xFFFFFFFE;
                  }
                  if ((_DWORD)v131)
                  {
                    *(_DWORD *)char v189 = 138412290;
                    *(void *)&v189[4] = v127;
                    LODWORD(v185) = 12;
                    uint64_t v132 = (char *)_os_log_send_and_compose_impl( v131,  &v190,  0LL,  0LL,  &_mh_execute_header,  v130,  0LL,  "FOUND LRU ARRAY:%@",  v189,  v185);

                    if (v132) {
                      sub_100053B7C(v132);
                    }
                  }

                  else
                  {

                    uint64_t v132 = 0LL;
                  }

                  free(v132);
                }

                if (CFArrayGetCount(v127) >= 1)
                {
                  id v133 = 0LL;
                  do
                  {
                    int v134 = (const __CFNumber *)CFArrayGetValueAtIndex(v127, v133);
                    if (v134)
                    {
                      uint64_t v135 = v134;
                      unsigned int v136 = CFGetTypeID(v134);
                      if (v136 == CFNumberGetTypeID())
                      {
                        CFNumberGetValue(v135, kCFNumberIntType, &valuePtr);
                        if (valuePtr >= 502) {
                          sub_10001D9CC(valuePtr);
                        }
                      }
                    }

                    ++v133;
                  }

                  while (CFArrayGetCount(v127) > v133);
                }

                uint64_t v137 = p_name[340];
                if (qword_1000DBD00)
                {
                  id v138 = (os_log_s *)(id)qword_1000DBA98;
                  if (!os_log_type_enabled(v138, OS_LOG_TYPE_DEFAULT)) {
                    goto LABEL_315;
                  }
                  unsigned int v190 = 0LL;
                  int v139 = sub_100053B4C(1);
                  id v138 = v138;
                  if (os_log_type_enabled(v138, OS_LOG_TYPE_DEFAULT)) {
                    id v140 = v139;
                  }
                  else {
                    id v140 = v139 & 0xFFFFFFFE;
                  }
                  if ((_DWORD)v140)
                  {
                    *(_DWORD *)char v189 = 138412290;
                    *(void *)&v189[4] = qword_1000DBD00;
                    LODWORD(v185) = 12;
                    uint64_t v141 = _os_log_send_and_compose_impl( v140,  &v190,  0LL,  0LL,  &_mh_execute_header,  v138,  0LL,  "CURRENT ENTRIES for LRU TABLE: %@",  v189,  v185);
                    goto LABEL_311;
                  }
                }

                else
                {
                  id v138 = (os_log_s *)(id)qword_1000DBA98;
                  if (!os_log_type_enabled(v138, OS_LOG_TYPE_DEFAULT)) {
                    goto LABEL_315;
                  }
                  *(void *)char v189 = 0LL;
                  uint64_t v142 = sub_100053B4C(1);
                  id v138 = v138;
                  if (os_log_type_enabled(v138, OS_LOG_TYPE_DEFAULT)) {
                    uint64_t v143 = v142;
                  }
                  else {
                    uint64_t v143 = v142 & 0xFFFFFFFE;
                  }
                  if ((_DWORD)v143)
                  {
                    LOWORD(v190) = 0;
                    LODWORD(v185) = 2;
                    uint64_t v141 = _os_log_send_and_compose_impl( v143,  v189,  0LL,  0LL,  &_mh_execute_header,  v138,  0LL,  "NO ENTRIES for LRU TABLE",  &v190,  v185);
LABEL_311:
                    id v144 = (char *)v141;

                    if (v144) {
                      sub_100053B7C(v144);
                    }
                    goto LABEL_314;
                  }
                }

                id v144 = 0LL;
LABEL_314:
                free(v144);
LABEL_315:

                if (v127) {
                  CFRelease(v127);
                }
LABEL_323:
                if (CFDictionaryContainsKey(v2, @"VOLUMETYPE"))
                {
                  uint64_t v146 = (const __CFString *)sub_100083DF4(v2, @"VOLUMETYPE");
                  uint64_t v147 = p_name[340];
                  if (v146)
                  {
                    CFTypeID v148 = (id)qword_1000DBA98;
                    if (os_log_type_enabled((os_log_t)v148, OS_LOG_TYPE_DEFAULT))
                    {
                      *(void *)char v189 = 0LL;
                      uint64_t v149 = sub_100053B4C(1);
                      CFTypeID v148 = v148;
                      if (os_log_type_enabled((os_log_t)v148, OS_LOG_TYPE_DEFAULT)) {
                        unsigned int v150 = v149;
                      }
                      else {
                        unsigned int v150 = v149 & 0xFFFFFFFE;
                      }
                      if ((_DWORD)v150)
                      {
                        LOWORD(v190) = 0;
                        LODWORD(v185) = 2;
                        uint64_t v151 = _os_log_send_and_compose_impl( v150,  v189,  0LL,  0LL,  &_mh_execute_header,  v148,  0LL,  "Found VolumeType in saved dictionary",  &v190,  v185);
                        goto LABEL_350;
                      }

                      goto LABEL_352;
                    }
                  }

                  else
                  {
                    CFTypeID v148 = (id)qword_1000DBA98;
                    if (os_log_type_enabled((os_log_t)v148, OS_LOG_TYPE_DEFAULT))
                    {
                      *(void *)char v189 = 0LL;
                      v157 = sub_100053B4C(1);
                      CFTypeID v148 = v148;
                      if (os_log_type_enabled((os_log_t)v148, OS_LOG_TYPE_DEFAULT)) {
                        CFTypeRef v158 = v157;
                      }
                      else {
                        CFTypeRef v158 = v157 & 0xFFFFFFFE;
                      }
                      if ((_DWORD)v158)
                      {
                        LOWORD(v190) = 0;
                        LODWORD(v185) = 2;
                        uint64_t v151 = _os_log_send_and_compose_impl( v158,  v189,  0LL,  0LL,  &_mh_execute_header,  v148,  0LL,  "NOT FOUND VolumeType in saved dictionary",  &v190,  v185);
LABEL_350:
                        id v159 = (char *)v151;

                        if (v159) {
                          sub_100053B7C(v159);
                        }
                        goto LABEL_353;
                      }

uint64_t sub_1000418D8(unsigned int a1, int a2, int a3, int a4)
{
  int valuePtr = a2;
  if (qword_1000DBAB0 != -1) {
    dispatch_once(&qword_1000DBAB0, &stru_1000CD548);
  }
  id v10 = (id)qword_1000DBAA8;
  if (os_log_type_enabled((os_log_t)v10, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)v307 = 0LL;
    unsigned int v11 = sub_100053B4C(0);
    id v12 = (os_log_s *)v10;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v13 = v11;
    }
    else {
      uint64_t v13 = v11 & 0xFFFFFFFE;
    }
    if ((_DWORD)v13)
    {
      v315.st_dev = 67109120;
      *(_DWORD *)&v315.st_mode = a1;
      uint64_t v4 = (char **)_os_log_send_and_compose_impl( v13,  v307,  0LL,  0LL,  &_mh_execute_header,  v12,  0LL,  "Loading foreground user %d...",  &v315);

      if (v4) {
        sub_100053B7C((const char *)v4);
      }
    }

    else
    {

      uint64_t v4 = 0LL;
    }

    free(v4);
  }

  if (a1 == -1)
  {
    sub_100019F7C("UserManagement loading foreground user failed assertion: uid != -1");
  }

  else
  {
    p_name = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
    id v14 = sub_100054ED0(qword_1000DBA70, a1);
    unsigned int v15 = (void *)objc_claimAutoreleasedReturnValue(v14);

    if (v15)
    {
      unsigned int v7 = v307;
      uint64_t v4 = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
      uint64_t v6 = (const void **)&kUMUserSessionHomeDirKey;
      if (dword_1000DBCE8 == 1)
      {
        if (qword_1000DBAA0 == -1) {
          goto LABEL_16;
        }
        goto LABEL_626;
      }

      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      id v21 = (id)qword_1000DBA98;
      if (os_log_type_enabled((os_log_t)v21, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)&v315.st_dev = 0LL;
        unsigned int v22 = sub_100053B4C(1);
        __int128 v23 = (os_log_s *)v21;
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v24 = v22;
        }
        else {
          uint64_t v24 = v22 & 0xFFFFFFFE;
        }
        if ((_DWORD)v24)
        {
          *(_DWORD *)v307 = 67109632;
          *(_DWORD *)&v307[4] = a1;
          *(_WORD *)&v307[8] = 1024;
          *(_DWORD *)&v307[10] = qword_1000DBCE0;
          *(_WORD *)&v307[14] = 1024;
          *(_DWORD *)&v307[16] = valuePtr;
          uint64_t v25 = (char *)_os_log_send_and_compose_impl( v24,  &v315,  0LL,  0LL,  &_mh_execute_header,  v23,  0LL,  "Regular mode Setup for user:%d: Num Sessions:%d, CurrentsessionID:%d",  v307,  20,  (_DWORD)v297);

          if (v25) {
            sub_100053B7C(v25);
          }
        }

        else
        {

          uint64_t v25 = 0LL;
        }

        free(v25);
      }

      id v31 = sub_100054ED0(qword_1000DBA70, a1);
      id v32 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue(v31);
      if (qword_1000DBCE0 >= 2)
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        id v33 = (id)qword_1000DBA98;
        if (os_log_type_enabled((os_log_t)v33, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)v307 = 0LL;
          unsigned int v34 = sub_100053B4C(1);
          id v35 = (os_log_s *)v33;
          if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v36 = v34;
          }
          else {
            uint64_t v36 = v34 & 0xFFFFFFFE;
          }
          if ((_DWORD)v36)
          {
            LOWORD(v315.st_dev) = 0;
            LODWORD(v296) = 2;
            uint64_t v37 = (char *)_os_log_send_and_compose_impl( v36,  v307,  0LL,  0LL,  &_mh_execute_header,  v35,  0LL,  "Has Secondary Users",  &v315,  v296);

            if (v37) {
              sub_100053B7C(v37);
            }
          }

          else
          {

            uint64_t v37 = 0LL;
          }

          free(v37);
        }
      }

      uint64_t v88 = sub_100018E80(qword_1000DBD40);
      uint64_t v89 = (void *)objc_claimAutoreleasedReturnValue(v88);
      int v90 = sub_100019BA0((uint64_t)v89, a1, 0, qword_1000DBCE0 > 1);

      if (v90)
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        id v91 = (id)qword_1000DBA98;
        if (os_log_type_enabled((os_log_t)v91, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)v307 = 0LL;
          unsigned int v92 = sub_100053B4C(1);
          id v91 = v91;
          if (os_log_type_enabled((os_log_t)v91, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v93 = v92;
          }
          else {
            uint64_t v93 = v92 & 0xFFFFFFFE;
          }
          if ((_DWORD)v93)
          {
            LOWORD(v315.st_dev) = 0;
            LODWORD(v296) = 2;
            uint64_t v94 = _os_log_send_and_compose_impl( v93,  v307,  0LL,  0LL,  &_mh_execute_header,  v91,  0LL,  "Set Foreground ID + multiuser in commpage successfully",  &v315,  v296);
            goto LABEL_169;
          }

          goto LABEL_172;
        }
      }

      else
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        id v91 = (id)qword_1000DBA98;
        if (os_log_type_enabled((os_log_t)v91, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)v307 = 0LL;
          unsigned int v95 = sub_100053B4C(1);
          id v91 = v91;
          if (os_log_type_enabled((os_log_t)v91, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v96 = v95;
          }
          else {
            uint64_t v96 = v95 & 0xFFFFFFFE;
          }
          if ((_DWORD)v96)
          {
            LOWORD(v315.st_dev) = 0;
            LODWORD(v296) = 2;
            uint64_t v94 = _os_log_send_and_compose_impl( v96,  v307,  0LL,  0LL,  &_mh_execute_header,  v91,  0LL,  "FAILED to Set Foreground ID + multiuser in commpage successfully",  &v315,  v296);
LABEL_169:
            uint64_t v97 = (char *)v94;

            if (v97) {
              sub_100053B7C(v97);
            }
            goto LABEL_173;
          }

LABEL_172:
          uint64_t v97 = 0LL;
LABEL_173:
          uint64_t v98 = a1;
          free(v97);
LABEL_174:

          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          id v99 = (id)qword_1000DBA98;
          if (os_log_type_enabled((os_log_t)v99, OS_LOG_TYPE_DEFAULT))
          {
            *(void *)v307 = 0LL;
            unsigned int v100 = sub_100053B4C(1);
            unsigned int v101 = (os_log_s *)v99;
            if (os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v102 = v100;
            }
            else {
              uint64_t v102 = v100 & 0xFFFFFFFE;
            }
            if ((_DWORD)v102)
            {
              LOWORD(v315.st_dev) = 0;
              LODWORD(v296) = 2;
              unsigned int v103 = (char *)_os_log_send_and_compose_impl( v102,  v307,  0LL,  0LL,  &_mh_execute_header,  v101,  0LL,  "Local enrolled User, Mounting the home dir..",  &v315,  v296);

              if (v103) {
                sub_100053B7C(v103);
              }
            }

            else
            {

              unsigned int v103 = 0LL;
            }

            uint64_t v98 = a1;
            free(v103);
          }

          if (![(id)qword_1000DBA68 splitUserVolumeEnabled])
          {
            unsigned int v109 = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
            uint64_t v110 = v32;
            goto LABEL_618;
          }

          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          id v104 = (id)qword_1000DBA98;
          if (os_log_type_enabled((os_log_t)v104, OS_LOG_TYPE_DEFAULT))
          {
            *(void *)v307 = 0LL;
            unsigned int v105 = sub_100053B4C(1);
            uint64_t v106 = (os_log_s *)v104;
            if (os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v107 = v105;
            }
            else {
              uint64_t v107 = v105 & 0xFFFFFFFE;
            }
            if ((_DWORD)v107)
            {
              LOWORD(v315.st_dev) = 0;
              LODWORD(v296) = 2;
              id v108 = (char *)_os_log_send_and_compose_impl( v107,  v307,  0LL,  0LL,  &_mh_execute_header,  v106,  0LL,  "Mounting the volume prior to volume map",  &v315,  v296);

              if (v108) {
                sub_100053B7C(v108);
              }
            }

            else
            {

              id v108 = 0LL;
            }

            uint64_t v98 = a1;
            free(v108);
          }

          sub_10001C3FC((uint64_t)v32, v98);
          uint64_t v111 = sub_100083DF4(v32, kUMUserSessionVolumeDeviceNodeKey);
          if (!v111)
          {
            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            unsigned int v109 = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
            uint64_t v110 = v32;
            uint64_t v117 = (os_log_s *)(id)qword_1000DBA98;
            if (!os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_617;
            }
            *(void *)v307 = 0LL;
            unsigned int v118 = sub_100053B4C(1);
            if (os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v119 = v118;
            }
            else {
              uint64_t v119 = v118 & 0xFFFFFFFE;
            }
            if ((_DWORD)v119)
            {
              LOWORD(v315.st_dev) = 0;
              LODWORD(v296) = 2;
              uint64_t v120 = (const char *)_os_log_send_and_compose_impl( v119,  v307,  0LL,  0LL,  &_mh_execute_header,  v117,  0LL,  "not able to find the diskNode, skipped volume map",  &v315,  v296);
              uint64_t v121 = v120;
              if (v120) {
                sub_100053B7C(v120);
              }
            }

            else
            {
              uint64_t v121 = 0LL;
            }

            uint64_t v98 = a1;
            uint64_t v128 = (char *)v121;
            goto LABEL_616;
          }

          if (a3)
          {
            int v112 = a4;
            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            unsigned int v109 = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
            id v113 = (id)qword_1000DBA98;
            if (os_log_type_enabled((os_log_t)v113, OS_LOG_TYPE_DEFAULT))
            {
              *(void *)v307 = 0LL;
              unsigned int v114 = sub_100053B4C(1);
              id v113 = v113;
              if (os_log_type_enabled((os_log_t)v113, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v115 = v114;
              }
              else {
                uint64_t v115 = v114 & 0xFFFFFFFE;
              }
              if ((_DWORD)v115)
              {
                LOWORD(v315.st_dev) = 0;
                LODWORD(v296) = 2;
                uint64_t v116 = (char *)_os_log_send_and_compose_impl( v115,  v307,  0LL,  0LL,  &_mh_execute_header,  v113,  0LL,  "Skipping Volume Map, as its completed part of Erase Install UserVolume fixup",  &v315,  v296);

                if (v116) {
                  sub_100053B7C(v116);
                }
              }

              else
              {

                uint64_t v116 = 0LL;
              }

              uint64_t v98 = a1;
              free(v116);
            }

    uint64_t v120 = 0LL;
    HIDWORD(v144) = 1;
    unsigned int v114 = (NSSet *)p_isa[6];
    if (!v114)
    {
      uint64_t v44 = 0;
      unsigned int v114 = 0LL;
LABEL_177:
      uint64_t v116 = 0LL;
      HIDWORD(v143) = 1;
      id v113 = (NSSet *)p_isa[7];
      if (!v113)
      {
        LODWORD(v143) = 0;
        id v113 = 0LL;
        unsigned int v8 = (UMDPersonaManifestPersona *)p_isa;
LABEL_186:
        LODWORD(v144) = v44;
        LODWORD(v145) = v38;
        if (v8->_isDeleting || v8->_isDisabled) {
          goto LABEL_158;
        }
LABEL_198:
        if (v8)
        {
          unsigned int v53 = v8->_displayName;
          if (v53)
          {
            uint64_t v129 = v53;
            if (self) {
              uint64_t v51 = self->_displayName;
            }
            else {
              uint64_t v51 = 0LL;
            }
            id v52 = 0LL;
            HIDWORD(v142) = 1;
            goto LABEL_203;
          }
        }

LABEL_256:
            if (!v112 || !_os_feature_enabled_impl("UserManagement", "LocalUserEnrollment"))
            {
              if (qword_1000DBAA0 != -1) {
                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
              }
              uint64_t v110 = v32;
              uint64_t v117 = (os_log_s *)(id)qword_1000DBA98;
              if (!os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_617;
              }
              *(void *)v307 = 0LL;
              unsigned int v145 = sub_100053B4C(1);
              uint64_t v146 = v117;
              if (os_log_type_enabled(v146, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v147 = v145;
              }
              else {
                uint64_t v147 = v145 & 0xFFFFFFFE;
              }
              if ((_DWORD)v147)
              {
                LOWORD(v315.st_dev) = 0;
                LODWORD(v296) = 2;
                uint64_t v148 = _os_log_send_and_compose_impl( v147,  v307,  0LL,  0LL,  &_mh_execute_header,  v146,  0LL,  "Skipping Sandbox Update for 501 user",  &v315,  v296);
                goto LABEL_572;
              }

              goto LABEL_614;
            }

            memset(v313, 0, sizeof(v313));
            __int128 v312 = 0u;
            __int128 v311 = 0u;
            __int128 v310 = 0u;
            __int128 v309 = 0u;
            __int128 v308 = 0u;
            memset(&v307[20], 0, 128);
            strcpy(v307, "/private/var/mobile");
            uint64_t v110 = v32;
            if ((_DWORD)v98 == 501) {
              goto LABEL_606;
            }
            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            id v140 = (id)qword_1000DBA98;
            if (os_log_type_enabled((os_log_t)v140, OS_LOG_TYPE_DEFAULT))
            {
              *(void *)&v314.st_dev = 0LL;
              unsigned int v141 = sub_100053B4C(1);
              uint64_t v142 = (os_log_s *)v140;
              if (os_log_type_enabled(v142, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v143 = v141;
              }
              else {
                uint64_t v143 = v141 & 0xFFFFFFFE;
              }
              if ((_DWORD)v143)
              {
                v315.st_dev = 67109378;
                uint64_t v98 = a1;
                *(_DWORD *)&v315.st_mode = a1;
                LOWORD(v315.st_ino) = 2080;
                *(__darwin_ino64_t *)((char *)&v315.st_ino + 2) = (__darwin_ino64_t)v307;
                LODWORD(v296) = 18;
                id v144 = (char *)_os_log_send_and_compose_impl( v143,  &v314,  0LL,  0LL,  &_mh_execute_header,  v142,  0LL,  "Adding Sandbox-kext path upload for uid %d, path:%s",  &v315,  v296);

                if (v144) {
                  sub_100053B7C(v144);
                }
              }

              else
              {

                id v144 = 0LL;
                uint64_t v98 = a1;
              }

              free(v144);
            }

            if (sub_10003323C(v98, v307, 1))
            {
              if (qword_1000DBAA0 != -1) {
                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
              }
              uint64_t v280 = (os_log_s *)(id)qword_1000DBA98;
              if (!os_log_type_enabled(v280, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_605;
              }
              *(void *)&v315.st_dev = 0LL;
              unsigned int v281 = sub_100053B4C(1);
              uint64_t v280 = v280;
              if (os_log_type_enabled(v280, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v282 = v281;
              }
              else {
                uint64_t v282 = v281 & 0xFFFFFFFE;
              }
              if ((_DWORD)v282)
              {
                v314.st_dev = 67109120;
                uint64_t v98 = a1;
                *(_DWORD *)&v314.st_mode = a1;
                uint64_t v283 = _os_log_send_and_compose_impl( v282,  &v315,  0LL,  0LL,  &_mh_execute_header,  v280,  0LL,  "Set homepath to Sandbox for uid:%d",  &v314);
                goto LABEL_601;
              }
            }

            else
            {
              if (qword_1000DBAA0 != -1) {
                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
              }
              uint64_t v280 = (os_log_s *)(id)qword_1000DBA98;
              if (!os_log_type_enabled(v280, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_605;
              }
              *(void *)&v315.st_dev = 0LL;
              unsigned int v284 = sub_100053B4C(1);
              uint64_t v280 = v280;
              if (os_log_type_enabled(v280, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v285 = v284;
              }
              else {
                uint64_t v285 = v284 & 0xFFFFFFFE;
              }
              if ((_DWORD)v285)
              {
                v314.st_dev = 67109120;
                uint64_t v98 = a1;
                *(_DWORD *)&v314.st_mode = a1;
                uint64_t v283 = _os_log_send_and_compose_impl( v285,  &v315,  0LL,  0LL,  &_mh_execute_header,  v280,  0LL,  "Failed to add homepath to Sandbox for uid:%d",  &v314);
LABEL_601:
                id v286 = (char *)v283;

                if (v286) {
                  sub_100053B7C(v286);
                }
                goto LABEL_604;
              }
            }

            id v286 = 0LL;
            uint64_t v98 = a1;
LABEL_604:
            free(v286);
LABEL_605:

LABEL_606:
            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            uint64_t v117 = (os_log_s *)(id)qword_1000DBA98;
            if (!os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_617;
            }
            *(void *)&v315.st_dev = 0LL;
            unsigned int v287 = sub_100053B4C(1);
            uint64_t v146 = v117;
            if (os_log_type_enabled(v146, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v288 = v287;
            }
            else {
              uint64_t v288 = v287 & 0xFFFFFFFE;
            }
            if (!(_DWORD)v288) {
              goto LABEL_614;
            }
            LOWORD(v314.st_dev) = 0;
            LODWORD(v296) = 2;
            uint64_t v148 = _os_log_send_and_compose_impl( v288,  &v315,  0LL,  0LL,  &_mh_execute_header,  v146,  0LL,  "NOT MODIFIED THE LAST BOOTED USER, so 501 User will boot on reboot",  &v314,  v296);
            goto LABEL_572;
          }

          uint64_t v122 = v111;
          int v112 = a4;
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          id v123 = (id)qword_1000DBA98;
          if (os_log_type_enabled((os_log_t)v123, OS_LOG_TYPE_DEFAULT))
          {
            *(void *)&v315.st_dev = 0LL;
            unsigned int v124 = sub_100053B4C(1);
            uint64_t v125 = (os_log_s *)v123;
            if (os_log_type_enabled(v125, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v126 = v124;
            }
            else {
              uint64_t v126 = v124 & 0xFFFFFFFE;
            }
            if ((_DWORD)v126)
            {
              *(_DWORD *)v307 = 138412546;
              *(void *)&v307[4] = v122;
              *(_WORD *)&v307[12] = 1024;
              *(_DWORD *)&v307[14] = a1;
              LODWORD(v296) = 18;
              uint64_t v127 = (char *)_os_log_send_and_compose_impl( v126,  &v315,  0LL,  0LL,  &_mh_execute_header,  v125,  0LL,  "Calling AKSVolumeMap with disk:%@ for useruid:%d",  v307,  v296);

              if (v127) {
                sub_100053B7C(v127);
              }
            }

            else
            {

              uint64_t v127 = 0LL;
            }

            free(v127);
          }

          uint64_t v129 = sub_100019B18(qword_1000DBD40);
          uint64_t v130 = (void *)objc_claimAutoreleasedReturnValue(v129);
          id v301 = 0LL;
          unsigned int v131 = [v130 mapVolume:v122 toSession:a1 withPersona:0 error:&v301];
          id v113 = v301;

          unsigned int v109 = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
          if (v131)
          {
            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            id v132 = (id)qword_1000DBA98;
            if (os_log_type_enabled((os_log_t)v132, OS_LOG_TYPE_DEFAULT))
            {
              *(void *)v307 = 0LL;
              unsigned int v133 = sub_100053B4C(1);
              id v132 = v132;
              if (os_log_type_enabled((os_log_t)v132, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v134 = v133;
              }
              else {
                uint64_t v134 = v133 & 0xFFFFFFFE;
              }
              if ((_DWORD)v134)
              {
                LOWORD(v315.st_dev) = 0;
                uint64_t v135 = _os_log_send_and_compose_impl( v134,  v307,  0LL,  0LL,  &_mh_execute_header,  v132,  0LL,  "AKS VolumeMapPath Success");
                goto LABEL_250;
              }

              goto LABEL_253;
            }
          }

          else
          {
            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            id v132 = (id)qword_1000DBA98;
            if (os_log_type_enabled((os_log_t)v132, OS_LOG_TYPE_DEFAULT))
            {
              *(void *)&v315.st_dev = 0LL;
              unsigned int v136 = sub_100053B4C(1);
              id v132 = v132;
              if (os_log_type_enabled((os_log_t)v132, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v137 = v136;
              }
              else {
                uint64_t v137 = v136 & 0xFFFFFFFE;
              }
              if ((_DWORD)v137)
              {
                id v138 = [v113 code];
                *(_DWORD *)v307 = 134217984;
                *(void *)&v307[4] = v138;
                uint64_t v135 = _os_log_send_and_compose_impl( v137,  &v315,  0LL,  0LL,  &_mh_execute_header,  v132,  0LL,  "AKS VolumeMap failed with %ld",  v307);
LABEL_250:
                int v139 = (char *)v135;

                if (v139) {
                  sub_100053B7C(v139);
                }
                goto LABEL_254;
              }

LABEL_253:
              int v139 = 0LL;
LABEL_254:
              uint64_t v98 = a1;
              free(v139);
              goto LABEL_255;
            }
          }

          uint64_t v98 = a1;
LABEL_255:

          goto LABEL_256;
        }
      }

      uint64_t v98 = a1;
      goto LABEL_174;
    }
  }

  sub_100019F7C("UserManagement loading foreground user failed assertion: [_gUserManager userWithUID:uid] != ((void *)0)");
LABEL_626:
  dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
LABEL_16:
  id v16 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v16, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)v307 = 0LL;
    unsigned int v17 = sub_100053B4C(1);
    id v18 = (os_log_s *)v16;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v19 = v17;
    }
    else {
      uint64_t v19 = v17 & 0xFFFFFFFE;
    }
    if ((_DWORD)v19)
    {
      LOWORD(v315.st_dev) = 0;
      uint64_t v20 = (char *)_os_log_send_and_compose_impl( v19,  v307,  0LL,  0LL,  &_mh_execute_header,  v18,  0LL,  "SHARED IPAD Configuration Setup",  &v315,  2);

      if (v20) {
        sub_100053B7C(v20);
      }
    }

    else
    {

      uint64_t v20 = 0LL;
    }

    free(v20);
  }

  id v26 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v26, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)v307 = 0LL;
    unsigned int v27 = sub_100053B4C(1);
    id v28 = (os_log_s *)v26;
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v29 = v27;
    }
    else {
      uint64_t v29 = v27 & 0xFFFFFFFE;
    }
    if ((_DWORD)v29)
    {
      v315.st_dev = 67109120;
      *(_DWORD *)&v315.st_mode = a1;
      id v30 = (char *)_os_log_send_and_compose_impl( v29,  v307,  0LL,  0LL,  &_mh_execute_header,  v28,  0LL,  "NextSESSION ID is %d",  &v315);

      if (v30) {
        sub_100053B7C(v30);
      }
    }

    else
    {

      id v30 = 0LL;
    }

    free(v30);
  }

  id v38 = sub_100054ED0((uint64_t)p_name[334], a1);
  uint64_t v298 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue(v38);
  id v39 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v39, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)&v315.st_dev = 0LL;
    unsigned int v40 = sub_100053B4C(1);
    id v41 = (os_log_s *)v39;
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v42 = v40;
    }
    else {
      uint64_t v42 = v40 & 0xFFFFFFFE;
    }
    if ((_DWORD)v42)
    {
      *(_DWORD *)v307 = 67109378;
      *(_DWORD *)&v307[4] = a1;
      *(_WORD *)&v307[8] = 2112;
      *(void *)&v307[10] = v298;
      LODWORD(v296) = 18;
      unsigned int v43 = (char *)_os_log_send_and_compose_impl( v42,  &v315,  0LL,  0LL,  &_mh_execute_header,  v41,  0LL,  "Found for uid %d a session %@",  v307,  v296);

      if (v43) {
        sub_100053B7C(v43);
      }
    }

    else
    {

      unsigned int v43 = 0LL;
    }

    free(v43);
  }

  if (a1 == 502)
  {
    uint64_t v44 = sub_100019434(qword_1000DBD40);
    id v45 = (void *)objc_claimAutoreleasedReturnValue(v44);
    [v45 removeFileAtPath:@"/private/var//keybags/nextsession_opaque.kb" error:0];

    uint64_t v46 = sub_100019434(qword_1000DBD40);
    uint64_t v47 = (void *)objc_claimAutoreleasedReturnValue(v46);
    [v47 removeFileAtPath:@"/private/var//keybags/nextsession_SBD_opaque.kb" error:0];
  }

  gid_t v299 = sub_100083C6C(v298, kUMUserSessionGroupIDKey);
  uint64_t v48 = sub_100018E80(qword_1000DBD40);
  uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue(v48);
  int v50 = sub_100019BA0((uint64_t)v49, a1, 1, 0);

  uint64_t v51 = v4[340];
  if (v50)
  {
    id v52 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v52, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)v307 = 0LL;
      unsigned int v53 = sub_100053B4C(1);
      id v52 = v52;
      if (os_log_type_enabled((os_log_t)v52, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v54 = v53;
      }
      else {
        uint64_t v54 = v53 & 0xFFFFFFFE;
      }
      if ((_DWORD)v54)
      {
        LOWORD(v315.st_dev) = 0;
        LODWORD(v296) = 2;
        uint64_t v55 = _os_log_send_and_compose_impl( v54,  v307,  0LL,  0LL,  &_mh_execute_header,  v52,  0LL,  "Set Foreground ID + multiuser in commpage successfully",  &v315,  v296);
        goto LABEL_87;
      }

      goto LABEL_89;
    }
  }

  else
  {
    id v52 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v52, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)v307 = 0LL;
      unsigned int v56 = sub_100053B4C(1);
      id v52 = v52;
      if (os_log_type_enabled((os_log_t)v52, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v57 = v56;
      }
      else {
        uint64_t v57 = v56 & 0xFFFFFFFE;
      }
      if ((_DWORD)v57)
      {
        LOWORD(v315.st_dev) = 0;
        LODWORD(v296) = 2;
        uint64_t v55 = _os_log_send_and_compose_impl( v57,  v307,  0LL,  0LL,  &_mh_execute_header,  v52,  0LL,  "FAILED to Set Foreground ID + multiuser in commpage successfully",  &v315,  v296);
LABEL_87:
        unsigned int v58 = (char *)v55;

        if (v58) {
          sub_100053B7C(v58);
        }
        goto LABEL_90;
      }

LABEL_89:
      unsigned int v58 = 0LL;
LABEL_90:
      free(v58);
    }
  }

  id v59 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v59, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)v307 = 0LL;
    unsigned int v60 = sub_100053B4C(1);
    unsigned int v61 = (os_log_s *)v59;
    if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v62 = v60;
    }
    else {
      uint64_t v62 = v60 & 0xFFFFFFFE;
    }
    if ((_DWORD)v62)
    {
      v315.st_dev = 67109120;
      *(_DWORD *)&v315.st_mode = a1;
      LODWORD(v296) = 8;
      id v63 = (char *)_os_log_send_and_compose_impl( v62,  v307,  0LL,  0LL,  &_mh_execute_header,  v61,  0LL,  "SETTING SYSTEM TO BOOT FOR UID %D, FS SETUP START",  &v315,  v296);

      if (v63) {
        sub_100053B7C(v63);
      }
    }

    else
    {

      id v63 = 0LL;
    }

    free(v63);
    uint64_t v4 = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
  }

  if (a1 == 502) {
    int v64 = 1;
  }
  else {
    int v64 = 2;
  }
  dword_1000DBCF0 = v64;
  dword_1000DBCF4 = 0;
  if (lstat("/private/var/mobile", &v315))
  {
    uint64_t v65 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_301;
    }
    *(void *)&v314.st_dev = 0LL;
    LODWORD(v66) = sub_100053B4C(1);
    if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v66 = v66;
    }
    else {
      uint64_t v66 = v66 & 0xFFFFFFFE;
    }
    if ((_DWORD)v66)
    {
      uint64_t v67 = v65;
      id v68 = __error();
      uint64_t v69 = strerror(*v68);
      *(_DWORD *)v307 = 136315138;
      *(void *)&v307[4] = v69;
      LODWORD(v296) = 12;
      char v70 = "FAILED to stat of varmobile with error %s";
      unsigned int v71 = &v314;
LABEL_114:
      unsigned int v72 = (char *)_os_log_send_and_compose_impl(v66, v71, 0LL, 0LL, &_mh_execute_header, v67, 0LL, v70, v307, v296);

      if (v72) {
        sub_100053B7C(v72);
      }
      uint64_t v4 = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
      goto LABEL_300;
    }

LABEL_299:
    unsigned int v72 = 0LL;
LABEL_300:
    free(v72);
    goto LABEL_301;
  }

  int v73 = v315.st_mode & 0xF000;
  if (v73 != 0x4000)
  {
    if (v73 == 40960)
    {
      uint64_t v74 = sub_100019434(qword_1000DBD40);
      uint64_t v75 = (void *)objc_claimAutoreleasedReturnValue(v74);
      unsigned __int8 v76 = [v75 removeFileAtPath:@"/private/var/mobile" error:0];

      if ((v76 & 1) != 0) {
        goto LABEL_302;
      }
      uint64_t v65 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_301;
      }
      *(void *)v307 = 0LL;
      unsigned int v77 = sub_100053B4C(1);
      if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v78 = v77;
      }
      else {
        uint64_t v78 = v77 & 0xFFFFFFFE;
      }
      if (!(_DWORD)v78) {
        goto LABEL_299;
      }
      LOWORD(v314.st_dev) = 0;
      uint64_t v79 = (const char *)_os_log_send_and_compose_impl( v78,  v307,  0LL,  0LL,  &_mh_execute_header,  v65,  0LL,  "Failed to unlink the redirect");
    }

    else
    {
      uint64_t v65 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_301;
      }
      *(void *)v307 = 0LL;
      unsigned int v86 = sub_100053B4C(1);
      if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v87 = v86;
      }
      else {
        uint64_t v87 = v86 & 0xFFFFFFFE;
      }
      if (!(_DWORD)v87) {
        goto LABEL_299;
      }
      v314.st_dev = 67109120;
      *(_DWORD *)&v314.st_mode = v315.st_mode;
      uint64_t v79 = (const char *)_os_log_send_and_compose_impl( v87,  v307,  0LL,  0LL,  &_mh_execute_header,  v65,  0LL,  "varmobile not a dir: 0x%x",  &v314);
    }

    unsigned int v72 = (char *)v79;
    if (v79) {
      sub_100053B7C(v79);
    }
    goto LABEL_300;
  }

  if (sub_100019FD4("/private/var/mobile", 0x80000))
  {
    id v80 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)&v314.st_dev = 0LL;
      LODWORD(v81) = sub_100053B4C(1);
      if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v81 = v81;
      }
      else {
        uint64_t v81 = v81 & 0xFFFFFFFE;
      }
      if ((_DWORD)v81)
      {
        uint64_t v82 = v80;
        int v83 = __error();
        unsigned int v84 = strerror(*v83);
        *(_DWORD *)v307 = 136315138;
        *(void *)&v307[4] = v84;
        uint64_t v85 = (char *)_os_log_send_and_compose_impl( v81,  &v314,  0LL,  0LL,  &_mh_execute_header,  v82,  0LL,  "Forced unmount of VARMOBILE failed with %s",  v307);

        if (v85) {
          sub_100053B7C(v85);
        }
        uint64_t v4 = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
      }

      else
      {
        uint64_t v85 = 0LL;
      }

      free(v85);
    }
  }

  if (lstat("/private/var/OLDmobile", &v314))
  {
    if (!rename("/private/var/mobile", "/private/var/OLDmobile")) {
      goto LABEL_302;
    }
    uint64_t v65 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_301;
    }
    *(void *)id v304 = 0LL;
    LODWORD(v66) = sub_100053B4C(1);
    if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v66 = v66;
    }
    else {
      uint64_t v66 = v66 & 0xFFFFFFFE;
    }
    if (!(_DWORD)v66) {
      goto LABEL_299;
    }
    uint64_t v67 = v65;
    uint64_t v149 = __error();
    unsigned int v150 = strerror(*v149);
    *(_DWORD *)v307 = 136315138;
    *(void *)&v307[4] = v150;
    LODWORD(v296) = 12;
    char v70 = "Failed to move prev Mobile to oldMobile with error %s";
    goto LABEL_298;
  }

  if (!rmdir("/private/var/mobile")) {
    goto LABEL_302;
  }
  uint64_t v65 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)id v304 = 0LL;
    LODWORD(v66) = sub_100053B4C(1);
    if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v66 = v66;
    }
    else {
      uint64_t v66 = v66 & 0xFFFFFFFE;
    }
    if (!(_DWORD)v66) {
      goto LABEL_299;
    }
    uint64_t v67 = v65;
    uint64_t v151 = __error();
    uint64_t v152 = strerror(*v151);
    *(_DWORD *)v307 = 136315138;
    *(void *)&v307[4] = v152;
    LODWORD(v296) = 12;
    char v70 = "Failed to rmdir VARMOBILE with error %s";
LABEL_298:
    unsigned int v71 = (stat *)v304;
    goto LABEL_114;
  }

LABEL_301:
LABEL_302:
  if (mkdir("/private/var/mobile", 0x1FFu))
  {
    uint64_t v153 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v153, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)id v304 = 0LL;
      LODWORD(v154) = sub_100053B4C(1);
      if (os_log_type_enabled(v153, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v154 = v154;
      }
      else {
        uint64_t v154 = v154 & 0xFFFFFFFE;
      }
      if ((_DWORD)v154)
      {
        unsigned int v155 = v153;
        uint64_t v156 = __error();
        v157 = strerror(*v156);
        *(_DWORD *)v307 = 136315138;
        *(void *)&v307[4] = v157;
        CFTypeRef v158 = (char *)_os_log_send_and_compose_impl( v154,  v304,  0LL,  0LL,  &_mh_execute_header,  v155,  0LL,  "Failed to create new VRAMOBILE dir with error %s",  v307);

        if (v158) {
          sub_100053B7C(v158);
        }
        uint64_t v4 = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
      }

      else
      {
        CFTypeRef v158 = 0LL;
      }

      free(v158);
    }
  }

  int v159 = chown("/private/var/mobile", a1, v299);
  uint64_t v160 = v4[340];
  if (v159)
  {
    unsigned int v161 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v161, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)id v304 = 0LL;
      LODWORD(v162) = sub_100053B4C(1);
      if (os_log_type_enabled(v161, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v162 = v162;
      }
      else {
        uint64_t v162 = v162 & 0xFFFFFFFE;
      }
      if ((_DWORD)v162)
      {
        uint64_t v163 = v161;
        unsigned int v164 = __error();
        uint64_t v165 = strerror(*v164);
        *(_DWORD *)v307 = 67109634;
        *(_DWORD *)&v307[4] = a1;
        *(_WORD *)&v307[8] = 1024;
        *(_DWORD *)&v307[10] = v299;
        *(_WORD *)&v307[14] = 2080;
        *(void *)&v307[16] = v165;
        id v166 = (char *)_os_log_send_and_compose_impl( v162,  v304,  0LL,  0LL,  &_mh_execute_header,  v163,  0LL,  "failed to change ownership on VARMOBILE to %d,%d with error: %s",  v307,  24,  v297);

        if (v166) {
          sub_100053B7C(v166);
        }
        uint64_t v4 = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
        goto LABEL_337;
      }

LABEL_336:
      id v166 = 0LL;
LABEL_337:
      free(v166);
    }
  }

  else
  {
    unsigned int v161 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v161, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)id v304 = 0LL;
      unsigned int v167 = sub_100053B4C(1);
      if (os_log_type_enabled(v161, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v168 = v167;
      }
      else {
        uint64_t v168 = v167 & 0xFFFFFFFE;
      }
      if ((_DWORD)v168)
      {
        *(_DWORD *)v307 = 67109376;
        *(_DWORD *)&v307[4] = a1;
        *(_WORD *)&v307[8] = 1024;
        *(_DWORD *)&v307[10] = v299;
        __int128 v169 = (const char *)_os_log_send_and_compose_impl( v168,  v304,  0LL,  0LL,  &_mh_execute_header,  v161,  0LL,  "Changed ownership on VARMOBILE to %d,%d",  v307,  14);
        id v166 = (char *)v169;
        if (v169) {
          sub_100053B7C(v169);
        }
        goto LABEL_337;
      }

      goto LABEL_336;
    }
  }

  bzero(v307, 0x400uLL);
  sub_100083E34(v298, *v6, v307, 1024);
  __int128 v170 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v170, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v303 = 0LL;
    unsigned int v171 = sub_100053B4C(1);
    if (os_log_type_enabled(v170, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v172 = v171;
    }
    else {
      uint64_t v172 = v171 & 0xFFFFFFFE;
    }
    if ((_DWORD)v172)
    {
      *(_DWORD *)id v304 = 136315138;
      *(void *)&v304[4] = v307;
      uint64_t v173 = (const char *)_os_log_send_and_compose_impl( v172,  &v303,  0LL,  0LL,  &_mh_execute_header,  v170,  0LL,  "XXXXXX: HomeDir is %s XXXXXXXXX ",  v304);
      __int128 v174 = (char *)v173;
      if (v173) {
        sub_100053B7C(v173);
      }
    }

    else
    {
      __int128 v174 = 0LL;
    }

    free(v174);
  }

  int v175 = fsctl("/private/var/", 0x2000410FuLL, v307, 0);
  __int128 v176 = v4[340];
  if (v175)
  {
    int v177 = v175;
    int v178 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v178, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v303 = 0LL;
      LODWORD(v179) = sub_100053B4C(1);
      if (os_log_type_enabled(v178, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v179 = v179;
      }
      else {
        uint64_t v179 = v179 & 0xFFFFFFFE;
      }
      if ((_DWORD)v179)
      {
        unsigned int v180 = v178;
        v181 = strerror(v177);
        *(_DWORD *)id v304 = 67109634;
        *(_DWORD *)&v304[4] = a1;
        *(_WORD *)&v304[8] = 2080;
        *(void *)&v304[10] = v307;
        __int16 v305 = 2080;
        uint64_t v306 = v181;
        LODWORD(v296) = 28;
        uint64_t v182 = (char *)_os_log_send_and_compose_impl( v179,  &v303,  0LL,  0LL,  &_mh_execute_header,  v180,  0LL,  "Failed to set filesystemRedirect for uid %d:%s with error: %s",  v304,  v296,  v297);

        if (v182) {
          sub_100053B7C(v182);
        }
      }

      else
      {
        uint64_t v182 = 0LL;
      }

      uint64_t v4 = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
      free(v182);
    }
  }

  else
  {
    unsigned int v183 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v183, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v303 = 0LL;
      unsigned int v184 = sub_100053B4C(1);
      if (os_log_type_enabled(v183, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v185 = v184;
      }
      else {
        uint64_t v185 = v184 & 0xFFFFFFFE;
      }
      if ((_DWORD)v185)
      {
        *(_DWORD *)id v304 = 67109378;
        *(_DWORD *)&v304[4] = a1;
        *(_WORD *)&v304[8] = 2080;
        *(void *)&v304[10] = v307;
        LODWORD(v296) = 18;
        int v186 = (const char *)_os_log_send_and_compose_impl( v185,  &v303,  0LL,  0LL,  &_mh_execute_header,  v183,  0LL,  "Set filesystemRedirect to uid %d:%s",  v304,  v296);
        unsigned int v187 = (char *)v186;
        if (v186) {
          sub_100053B7C(v186);
        }
      }

      else
      {
        unsigned int v187 = 0LL;
      }

      free(v187);
    }

    sub_10003323C(a1, v307, 1);
  }

  strcpy(v307, "/private/var/DELETED");
  if (!lstat("/private/var/DELETED", &v315))
  {
    int v194 = sub_10002D61C(v307);
    unsigned int v195 = v4[340];
    if (v194)
    {
      uint64_t v188 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v188, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_406;
      }
      uint64_t v303 = 0LL;
      unsigned int v196 = sub_100053B4C(1);
      if (os_log_type_enabled(v188, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v197 = v196;
      }
      else {
        uint64_t v197 = v196 & 0xFFFFFFFE;
      }
      if (!(_DWORD)v197) {
        goto LABEL_404;
      }
      *(_DWORD *)id v304 = 136315138;
      *(void *)&v304[4] = v307;
      unsigned int v198 = (const char *)_os_log_send_and_compose_impl( v197,  &v303,  0LL,  0LL,  &_mh_execute_header,  v188,  0LL,  "REMOVED STALE ENTRIES PATH:%s",  v304);
    }

    else
    {
      uint64_t v188 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v188, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_406;
      }
      uint64_t v303 = 0LL;
      unsigned int v199 = sub_100053B4C(1);
      if (os_log_type_enabled(v188, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v200 = v199;
      }
      else {
        uint64_t v200 = v199 & 0xFFFFFFFE;
      }
      if (!(_DWORD)v200) {
        goto LABEL_404;
      }
      *(_DWORD *)id v304 = 136315138;
      *(void *)&v304[4] = v307;
      unsigned int v198 = (const char *)_os_log_send_and_compose_impl( v200,  &v303,  0LL,  0LL,  &_mh_execute_header,  v188,  0LL,  "UNABLE TO REMOVE STALE ENTRIES PATH:%s",  v304);
    }

    unsigned int v193 = (char *)v198;
    if (v198) {
      sub_100053B7C(v198);
    }
    goto LABEL_405;
  }

  uint64_t v188 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v188, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v303 = 0LL;
    LODWORD(v189) = sub_100053B4C(1);
    if (os_log_type_enabled(v188, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v189 = v189;
    }
    else {
      uint64_t v189 = v189 & 0xFFFFFFFE;
    }
    if ((_DWORD)v189)
    {
      unsigned int v190 = v188;
      v191 = __error();
      uint64_t v192 = strerror(*v191);
      *(_DWORD *)id v304 = 136315138;
      *(void *)&v304[4] = v192;
      unsigned int v193 = (char *)_os_log_send_and_compose_impl( v189,  &v303,  0LL,  0LL,  &_mh_execute_header,  v190,  0LL,  "REMOVAL STALE ENTRIES NOT REQUIRED as :%s",  v304);

      if (v193) {
        sub_100053B7C(v193);
      }
      uint64_t v4 = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
      goto LABEL_405;
    }

LABEL_404:
    unsigned int v193 = 0LL;
LABEL_405:
    free(v193);
  }

LABEL_406:
  id v201 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v201, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)v307 = 0LL;
    unsigned int v202 = sub_100053B4C(1);
    if (os_log_type_enabled(v201, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v203 = v202;
    }
    else {
      uint64_t v203 = v202 & 0xFFFFFFFE;
    }
    if ((_DWORD)v203)
    {
      v315.st_dev = 67109120;
      *(_DWORD *)&v315.st_mode = 2;
      uint64_t v204 = (const char *)_os_log_send_and_compose_impl( v203,  v307,  0LL,  0LL,  &_mh_execute_header,  v201,  0LL,  "Creating %d Default paths\n",  &v315);
      v205 = (char *)v204;
      if (v204) {
        sub_100053B7C(v204);
      }
    }

    else
    {
      v205 = 0LL;
    }

    free(v205);
  }

  uint64_t v206 = 0LL;
  char v207 = 1;
  uint64_t v98 = a1;
  do
  {
    char v208 = v207;
    v7[7] = 0u;
    v7[8] = 0u;
    v7[5] = 0u;
    v7[6] = 0u;
    memset(v307, 0, 80);
    uid_t v209 = (&off_1000CD3B0)[6 * v206];
    int v210 = stat(v209, (stat *)v307);
    unsigned int v211 = v4[340];
    if (v210)
    {
      id v212 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v212, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)&v314.st_dev = 0LL;
        unsigned int v213 = sub_100053B4C(1);
        if (os_log_type_enabled(v212, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v214 = v213;
        }
        else {
          uint64_t v214 = v213 & 0xFFFFFFFE;
        }
        if ((_DWORD)v214)
        {
          v315.st_dev = 136315138;
          *(void *)&v315.st_mode = v209;
          uint64_t v215 = (const char *)_os_log_send_and_compose_impl( v214,  &v314,  0LL,  0LL,  &_mh_execute_header,  v212,  0LL,  "Creating path: %s",  (const char *)&v315);
          v216 = (char *)v215;
          if (v215) {
            sub_100053B7C(v215);
          }
        }

        else
        {
          v216 = 0LL;
        }

        free(v216);
        uint64_t v4 = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
      }

      if (mkpath_np(v209, 0x1EDu))
      {
        CFStringRef v222 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v222, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)&v314.st_dev = 0LL;
          LODWORD(v223) = sub_100053B4C(1);
          if (os_log_type_enabled(v222, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v223 = v223;
          }
          else {
            uint64_t v223 = v223 & 0xFFFFFFFE;
          }
          if ((_DWORD)v223)
          {
            BOOL v224 = v222;
            id v225 = __error();
            unsigned int v226 = strerror(*v225);
            v315.st_dev = 136315394;
            *(void *)&v315.st_mode = v209;
            WORD2(v315.st_ino) = 2080;
            *(__darwin_ino64_t *)((char *)&v315.st_ino + 6) = (__darwin_ino64_t)v226;
            LODWORD(v296) = 22;
            unsigned int v227 = (char *)_os_log_send_and_compose_impl( v223,  &v314,  0LL,  0LL,  &_mh_execute_header,  v224,  0LL,  "failed to create: %s (%s)\n",  (const char *)&v315,  v296);

            if (v227) {
              sub_100053B7C(v227);
            }
            uint64_t v98 = a1;
          }

          else
          {
            unsigned int v227 = 0LL;
          }

          free(v227);
          uint64_t v4 = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
        }
      }
    }

    else
    {
      id v217 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v217, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)&v314.st_dev = 0LL;
        unsigned int v218 = sub_100053B4C(1);
        if (os_log_type_enabled(v217, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v219 = v218;
        }
        else {
          uint64_t v219 = v218 & 0xFFFFFFFE;
        }
        if ((_DWORD)v219)
        {
          v315.st_dev = 136315138;
          *(void *)&v315.st_mode = v209;
          uint64_t v220 = (const char *)_os_log_send_and_compose_impl( v219,  &v314,  0LL,  0LL,  &_mh_execute_header,  v217,  0LL,  "Path: %s already exits, skipping",  (const char *)&v315);
          uint64_t v221 = (char *)v220;
          if (v220) {
            sub_100053B7C(v220);
          }
        }

        else
        {
          uint64_t v221 = 0LL;
        }

        uint64_t v98 = a1;
        free(v221);
        uint64_t v4 = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
      }

      if (*(_DWORD *)&v307[16] != (_DWORD)v98 || *(_DWORD *)&v307[20] != v299)
      {
        if (!chown(v209, v98, v299))
        {
          uint64_t v228 = (os_log_s *)(id)qword_1000DBA98;
          if (os_log_type_enabled(v228, OS_LOG_TYPE_DEFAULT))
          {
            *(void *)&v314.st_dev = 0LL;
            unsigned int v229 = sub_100053B4C(1);
            if (os_log_type_enabled(v228, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v230 = v229;
            }
            else {
              uint64_t v230 = v229 & 0xFFFFFFFE;
            }
            if ((_DWORD)v230)
            {
              unsigned int v231 = v228;
              unsigned int v232 = __error();
              uint64_t v233 = strerror(*v232);
              v315.st_dev = 136315394;
              *(void *)&v315.st_mode = v209;
              WORD2(v315.st_ino) = 2080;
              *(__darwin_ino64_t *)((char *)&v315.st_ino + 6) = (__darwin_ino64_t)v233;
              LODWORD(v296) = 22;
              uint64_t v234 = (char *)_os_log_send_and_compose_impl( v230,  &v314,  0LL,  0LL,  &_mh_execute_header,  v231,  0LL,  "failed to change ownership on: %s (%s)\n",  (const char *)&v315,  v296);

              if (v234) {
                sub_100053B7C(v234);
              }
            }

            else
            {
              uint64_t v234 = 0LL;
            }

            uint64_t v98 = a1;
            free(v234);
            uint64_t v4 = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
          }
        }

        sub_10001E030(v209, v98);
      }
    }

    char v207 = 0;
    uint64_t v206 = 1LL;
  }

  while ((v208 & 1) != 0);
  unsigned int v109 = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
  uint64_t v110 = v298;
  if ((_DWORD)v98 == 502)
  {
    CFNumberRef v235 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
    if (v235)
    {
      CFNumberRef v236 = v235;
      CFDictionarySetValue(v298, kUMUserSessionPreviousLoggedinIDKey, v235);
      CFRelease(v236);
    }

    unsigned int v237 = (const __CFString *)sub_100083DF4(v298, kUMUserSessionHomeDirKey);
    sub_10007B4DC(v237, 0x1F6u, 0x1F6u);
    if (!CFDictionaryContainsKey(v298, kUMUserSessionLanguageKey)) {
      CFDictionarySetValue(v298, kUMUserSessionLanguageKey, @"en_US");
    }
  }

  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  CFDateRef v239 = CFDateCreate(kCFAllocatorDefault, Current);
  CFDictionaryReplaceValue(v298, kUMUserSessionLoginTimeStampKey, v239);
  if (v239) {
    CFRelease(v239);
  }
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v245 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v245, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)v307 = 0LL;
    unsigned int v246 = sub_100053B4C(1);
    int v247 = (os_log_s *)v245;
    if (os_log_type_enabled(v247, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v248 = v246;
    }
    else {
      uint64_t v248 = v246 & 0xFFFFFFFE;
    }
    if ((_DWORD)v248)
    {
      v315.st_dev = 67109120;
      uint64_t v98 = a1;
      *(_DWORD *)&v315.st_mode = a1;
      id v249 = (char *)_os_log_send_and_compose_impl( v248,  v307,  0LL,  0LL,  &_mh_execute_header,  v247,  0LL,  "loading keybag for session %d",  &v315);

      if (v249) {
        sub_100053B7C(v249);
      }
    }

    else
    {

      id v249 = 0LL;
      uint64_t v98 = a1;
    }

    free(v249);
  }

  if (!MKBUserSessionLoadKeybagForUser(v298, v98, 0LL, 0LL, 0LL, 1LL))
  {
    int v255 = MKBUserSessionUnloadSessionBags(v298, v98);
    if (v255)
    {
      int v256 = v255;
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      id v257 = (id)qword_1000DBA98;
      if (os_log_type_enabled((os_log_t)v257, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)v307 = 0LL;
        unsigned int v258 = sub_100053B4C(1);
        uint64_t v259 = (os_log_s *)v257;
        if (os_log_type_enabled(v259, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v260 = v258;
        }
        else {
          uint64_t v260 = v258 & 0xFFFFFFFE;
        }
        if ((_DWORD)v260)
        {
          v315.st_dev = 67109120;
          *(_DWORD *)&v315.st_mode = v256;
          uint64_t v261 = (char *)_os_log_send_and_compose_impl( v260,  v307,  0LL,  0LL,  &_mh_execute_header,  v259,  0LL,  "Failed to unload session keybags: 0x%x",  &v315);

          if (v261) {
            sub_100053B7C(v261);
          }
        }

        else
        {

          uint64_t v261 = 0LL;
        }

        uint64_t v98 = a1;
        free(v261);
      }
    }

LABEL_480:
    if ((_DWORD)v98 != 502)
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      id v240 = (id)qword_1000DBA98;
      if (os_log_type_enabled((os_log_t)v240, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)v307 = 0LL;
        unsigned int v241 = sub_100053B4C(1);
        id v242 = (os_log_s *)v240;
        if (os_log_type_enabled(v242, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v243 = v241;
        }
        else {
          uint64_t v243 = v241 & 0xFFFFFFFE;
        }
        if ((_DWORD)v243)
        {
          v315.st_dev = 67109120;
          uint64_t v98 = a1;
          *(_DWORD *)&v315.st_mode = a1;
          unsigned int v244 = (char *)_os_log_send_and_compose_impl( v243,  v307,  0LL,  0LL,  &_mh_execute_header,  v242,  0LL,  "Adding uid %d to end of LRU table",  &v315);

          if (v244) {
            sub_100053B7C(v244);
          }
        }

        else
        {

          unsigned int v244 = 0LL;
          uint64_t v98 = a1;
        }

        free(v244);
      }

      sub_10001D9CC(v98);
    }

    sub_10001D8E8(v298, v98);
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v262 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v262, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)v307 = 0LL;
      unsigned int v263 = sub_100053B4C(1);
      uint64_t v264 = (os_log_s *)v262;
      if (os_log_type_enabled(v264, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v265 = v263;
      }
      else {
        uint64_t v265 = v263 & 0xFFFFFFFE;
      }
      if ((_DWORD)v265)
      {
        v315.st_dev = 67109120;
        uint64_t v98 = a1;
        *(_DWORD *)&v315.st_mode = a1;
        v266 = (char *)_os_log_send_and_compose_impl( v265,  v307,  0LL,  0LL,  &_mh_execute_header,  v264,  0LL,  "Setting up Foreground session ID:%d",  &v315);

        if (v266) {
          sub_100053B7C(v266);
        }
      }

      else
      {

        v266 = 0LL;
        uint64_t v98 = a1;
      }

      free(v266);
    }

    CFDictionarySetValue(v298, kUMUserSessionForegroundKey, kCFBooleanTrue);
    sub_10001AED4();
    sub_10007E454();
    if (dword_1000DBD18 < 1)
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v117 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_617;
      }
      *(void *)v307 = 0LL;
      unsigned int v272 = sub_100053B4C(1);
      uint64_t v146 = v117;
      if (os_log_type_enabled(v146, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v273 = v272;
      }
      else {
        uint64_t v273 = v272 & 0xFFFFFFFE;
      }
      if ((_DWORD)v273)
      {
        LOWORD(v315.st_dev) = 0;
        LODWORD(v296) = 2;
        uint64_t v148 = _os_log_send_and_compose_impl( v273,  v307,  0LL,  0LL,  &_mh_execute_header,  v146,  0LL,  "Network BK_SYS value NOT set/disabled",  &v315,  v296);
        goto LABEL_572;
      }

      goto LABEL_614;
    }

    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v267 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v267, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)v307 = 0LL;
      unsigned int v268 = sub_100053B4C(1);
      v269 = (os_log_s *)v267;
      if (os_log_type_enabled(v269, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v270 = v268;
      }
      else {
        uint64_t v270 = v268 & 0xFFFFFFFE;
      }
      if ((_DWORD)v270)
      {
        v315.st_dev = 67109120;
        *(_DWORD *)&v315.st_mode = dword_1000DBD18;
        v271 = (char *)_os_log_send_and_compose_impl( v270,  v307,  0LL,  0LL,  &_mh_execute_header,  v269,  0LL,  "Setting Device Network with BK_SYS value of %d",  &v315);

        if (v271) {
          sub_100053B7C(v271);
        }
      }

      else
      {

        v271 = 0LL;
      }

      uint64_t v98 = a1;
      free(v271);
    }

    if (sub_10001E1D0(dword_1000DBD18))
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v117 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_617;
      }
      *(void *)v307 = 0LL;
      unsigned int v274 = sub_100053B4C(1);
      uint64_t v146 = v117;
      if (os_log_type_enabled(v146, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v275 = v274;
      }
      else {
        uint64_t v275 = v274 & 0xFFFFFFFE;
      }
      if ((_DWORD)v275)
      {
        v315.st_dev = 67109120;
        *(_DWORD *)&v315.st_mode = dword_1000DBD18;
        uint64_t v148 = _os_log_send_and_compose_impl( v275,  v307,  0LL,  0LL,  &_mh_execute_header,  v146,  0LL,  "Network BK_SYS value set to %d",  &v315);
        goto LABEL_572;
      }

LABEL_614:
      id v278 = 0LL;
LABEL_615:
      uint64_t v98 = a1;
      uint64_t v128 = (char *)v278;
LABEL_616:
      free(v128);
LABEL_617:

LABEL_618:
      uint64_t v289 = (const __CFString *)sub_100083DF4(v110, kUMUserSessionHomeDirKey);
      int v290 = sub_10007ECE8(v289, v98, v98);
      if (v290)
      {
        uint64_t v295 = sub_100019F7C("failed to register the exclaves writable storage: %d\n", v290);
        return sub_100044C28(v295);
      }

      else
      {
        if (v110) {
          CFRelease(v110);
        }
        if (dword_1000DBCE8 != 1)
        {
          id v291 = sub_1000550DC((uint64_t)v109[334], v98);
          v292 = (void *)objc_claimAutoreleasedReturnValue(v291);
          uint64_t v293 = v98;
          uint64_t v294 = v292;
          sub_1000618B8((id *)qword_1000DBA78, v292, v293);
        }

        return 1LL;
      }
    }

    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v117 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_617;
    }
    *(void *)v307 = 0LL;
    unsigned int v276 = sub_100053B4C(1);
    uint64_t v146 = v117;
    if (os_log_type_enabled(v146, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v277 = v276;
    }
    else {
      uint64_t v277 = v276 & 0xFFFFFFFE;
    }
    if (!(_DWORD)v277) {
      goto LABEL_614;
    }
    v315.st_dev = 67109120;
    *(_DWORD *)&v315.st_mode = dword_1000DBD18;
    uint64_t v148 = _os_log_send_and_compose_impl( v277,  v307,  0LL,  0LL,  &_mh_execute_header,  v146,  0LL,  "Failed to set Network BK_SYS value set to %d",  &v315);
LABEL_572:
    id v278 = (const char *)v148;

    if (v278) {
      sub_100053B7C(v278);
    }
    goto LABEL_615;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v250 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v250, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)v307 = 0LL;
    unsigned int v251 = sub_100053B4C(1);
    int v252 = (os_log_s *)v250;
    if (os_log_type_enabled(v252, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v253 = v251;
    }
    else {
      uint64_t v253 = v251 & 0xFFFFFFFE;
    }
    if ((_DWORD)v253)
    {
      LOWORD(v315.st_dev) = 0;
      LODWORD(v296) = 2;
      v254 = (char *)_os_log_send_and_compose_impl( v253,  v307,  0LL,  0LL,  &_mh_execute_header,  v252,  0LL,  "Failed to load keybag for session",  &v315,  v296);

      if (v254) {
        sub_100053B7C(v254);
      }
    }

    else
    {

      v254 = 0LL;
    }

    free(v254);
  }

  if (v298) {
    CFRelease(v298);
  }
  return 0LL;
}

void sub_100044C28()
{
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v0 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = 0LL;
    unsigned int v1 = sub_100053B4C(1);
    if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v2 = v1;
    }
    else {
      uint64_t v2 = v1 & 0xFFFFFFFE;
    }
    if ((_DWORD)v2)
    {
      __int16 v12 = 0;
      unsigned int v3 = (const char *)_os_log_send_and_compose_impl( v2,  &v13,  0LL,  0LL,  &_mh_execute_header,  v0,  0LL,  "Migrating Persona Volumes",  &v12,  2);
      uint64_t v4 = (char *)v3;
      if (v3) {
        sub_100053B7C(v3);
      }
    }

    else
    {
      uint64_t v4 = 0LL;
    }

    free(v4);
  }

  id v5 = sub_100054ED0(qword_1000DBA70, 501);
  uint64_t v6 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue(v5);
  if (v6)
  {
    unsigned int v7 = v6;
    unsigned int v8 = (void *)sub_100083DF4(v6, kUMUserSessionUUIDKey);
    id v9 = sub_1000598D8(qword_1000DBA78, v8);
    id v10 = (const __CFArray *)objc_claimAutoreleasedReturnValue(v9);
    if (v10)
    {
      unsigned int v11 = v10;
      v14.length = CFArrayGetCount(v10);
      v14.location = 0LL;
      CFArrayApplyFunction(v11, v14, (CFArrayApplierFunction)sub_10004B774, 0LL);
      CFRelease(v11);
    }

    CFRelease(v7);
  }

uint64_t sub_100044D90()
{
  uint64_t v0 = sub_100057614((uint64_t)&OBJC_CLASS___UMDAPFSSupportVolumeHelper, (void *)qword_1000DBD40, byte_1000DBD3A);
  uint64_t v1 = objc_claimAutoreleasedReturnValue(v0);
  uint64_t v2 = (void *)qword_1000DBA68;
  qword_1000DBA68 = v1;

  unsigned int v3 = sub_100054B0C((uint64_t)&OBJC_CLASS___UMDUserManager, (void *)qword_1000DBA68);
  uint64_t v4 = objc_claimAutoreleasedReturnValue(v3);
  id v5 = (void *)qword_1000DBA70;
  qword_1000DBA70 = v4;

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v6 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t v42 = 0LL;
    unsigned int v7 = sub_100053B4C(1);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = v7 & 0xFFFFFFFE;
    }
    if ((_DWORD)v8)
    {
      LOWORD(v40) = 0;
      id v9 = (const char *)_os_log_send_and_compose_impl( v8,  v42,  0LL,  0LL,  &_mh_execute_header,  v6,  0LL,  "LOADING USER SESSIONS",  &v40,  2);
      id v10 = (char *)v9;
      if (v9) {
        sub_100053B7C(v9);
      }
    }

    else
    {
      id v10 = 0LL;
    }

    free(v10);
  }

  if (!sub_10003FC5C(0))
  {
    sub_100019F7C("UserManagement user switch task failed to load user manifest");
LABEL_67:
    sub_100055F08(qword_1000DBA70);
    sub_100019F7C("UserManagement user switch task next session bag missing or corrupt");
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  unsigned int v11 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t v42 = 0LL;
    unsigned int v12 = sub_100053B4C(1);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v13 = v12;
    }
    else {
      uint64_t v13 = v12 & 0xFFFFFFFE;
    }
    if ((_DWORD)v13)
    {
      LOWORD(v40) = 0;
      LODWORD(v39) = 2;
      CFRange v14 = (const char *)_os_log_send_and_compose_impl( v13,  v42,  0LL,  0LL,  &_mh_execute_header,  v11,  0LL,  "LOADED USER SESSIONS",  &v40,  v39);
      unsigned int v15 = (char *)v14;
      if (v14) {
        sub_100053B7C(v14);
      }
    }

    else
    {
      unsigned int v15 = 0LL;
    }

    free(v15);
  }

  sub_1000198B4(qword_1000DBA70, (void *)qword_1000DBCD8);
  if (dword_1000DBCE8 != 1)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v16 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)uint64_t v42 = 0LL;
      unsigned int v17 = sub_100053B4C(1);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v18 = v17;
      }
      else {
        uint64_t v18 = v17 & 0xFFFFFFFE;
      }
      if ((_DWORD)v18)
      {
        LOWORD(v40) = 0;
        LODWORD(v39) = 2;
        uint64_t v19 = (const char *)_os_log_send_and_compose_impl( v18,  v42,  0LL,  0LL,  &_mh_execute_header,  v16,  0LL,  "LOADING PERSONA..",  &v40,  v39);
        uint64_t v20 = (char *)v19;
        if (v19) {
          sub_100053B7C(v19);
        }
      }

      else
      {
        uint64_t v20 = 0LL;
      }

      free(v20);
    }

    if (qword_1000DBA78)
    {
      sub_100019F7C("UserManagement user switch failed assertion: _gPersonaManager == ((void *)0)");
    }

    else
    {
      id v21 = sub_10005780C((uint64_t)&OBJC_CLASS___UMDPersonaManager, (void *)qword_1000DBA70);
      uint64_t v22 = objc_claimAutoreleasedReturnValue(v21);
      __int128 v23 = (void *)qword_1000DBA78;
      qword_1000DBA78 = v22;

      int v41 = 0;
      if (!sub_10003FFE4(&v41))
      {
LABEL_69:
        unsigned int v37 = sub_100019F7C("UserManagement user switch task failed to load persona manifest");
        return sub_10004535C(v37, v38);
      }

      if (qword_1000DBAC0 == -1) {
        goto LABEL_39;
      }
    }

    dispatch_once(&qword_1000DBAC0, &stru_1000CD568);
LABEL_39:
    uint64_t v24 = (os_log_s *)(id)qword_1000DBAB8;
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)uint64_t v42 = 0LL;
      unsigned int v25 = sub_100053B4C(0);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v26 = v25;
      }
      else {
        uint64_t v26 = v25 & 0xFFFFFFFE;
      }
      if ((_DWORD)v26)
      {
        LOWORD(v40) = 0;
        LODWORD(v39) = 2;
        unsigned int v27 = (const char *)_os_log_send_and_compose_impl( v26,  v42,  0LL,  0LL,  &_mh_execute_header,  v24,  0LL,  "Loaded persona manifest",  &v40,  v39);
        id v28 = (char *)v27;
        if (v27) {
          sub_100053B7C(v27);
        }
      }

      else
      {
        id v28 = 0LL;
      }

      free(v28);
    }

    if (qword_1000DBAC0 != -1) {
      dispatch_once(&qword_1000DBAC0, &stru_1000CD568);
    }
    uint64_t v29 = (os_log_s *)(id)qword_1000DBAB8;
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v40 = 0LL;
      LODWORD(v30) = sub_100053B4C(0);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG)) {
        uint64_t v30 = v30;
      }
      else {
        uint64_t v30 = v30 & 0xFFFFFFFE;
      }
      if ((_DWORD)v30)
      {
        uint64_t v31 = qword_1000DBA78;
        id v32 = v29;
        uint64_t v33 = sub_1000197A0(v31);
        unsigned int v34 = (void *)objc_claimAutoreleasedReturnValue(v33);
        v42[0] = 138412290;
        *(void *)&v42[1] = v34;
        LODWORD(v39) = 12;
        id v35 = (char *)_os_log_send_and_compose_impl( v30,  &v40,  0LL,  0LL,  &_mh_execute_header,  v32,  2LL,  "Persona state: %@",  v42,  v39);

        if (v35) {
          sub_100053B7C(v35);
        }
      }

      else
      {
        id v35 = 0LL;
      }

      free(v35);
    }
  }

  v42[0] = -1;
  LODWORD(v40) = -1;
  if ((sub_100055CE4(qword_1000DBA70, &v40, v42) & 1) == 0) {
    goto LABEL_67;
  }
  uint64_t result = sub_10004535C(v42[0], v40);
  if ((_DWORD)result)
  {
    uint64_t result = (uint64_t)sub_100055F08(qword_1000DBA70);
    if ((result & 1) == 0)
    {
      sub_100019F7C("UserManagement user switch task failed to remove nextSession file");
      goto LABEL_69;
    }
  }

  return result;
}

uint64_t sub_10004535C(unsigned int a1, uint64_t a2)
{
  if (qword_1000DBAB0 != -1) {
    dispatch_once(&qword_1000DBAB0, &stru_1000CD548);
  }
  uint64_t v4 = (os_log_s *)(id)qword_1000DBAA8;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = 0LL;
    unsigned int v5 = sub_100053B4C(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = v5 & 0xFFFFFFFE;
    }
    if ((_DWORD)v6)
    {
      v11[0] = 67109376;
      v11[1] = a1;
      __int16 v12 = 1024;
      int v13 = a2;
      unsigned int v7 = (const char *)_os_log_send_and_compose_impl( v6,  &v10,  0LL,  0LL,  &_mh_execute_header,  v4,  0LL,  "Switching foreground user: Next session UID: %d, Current session UID: %d",  v11,  14);
      uint64_t v8 = (char *)v7;
      if (v7) {
        sub_100053B7C(v7);
      }
    }

    else
    {
      uint64_t v8 = 0LL;
    }

    free(v8);
  }

  if ((_DWORD)a2 == -1) {
    sub_100019F7C("UserManagement user switch failed assertion: currentSessionID != -1");
  }
  if ((_DWORD)a2 != a1) {
    sub_100050FEC(a2);
  }
  return sub_1000418D8(a1, a2, 0, 1);
}

uint64_t sub_1000454D8(_removefile_state *a1, const char *a2, int *a3)
{
  int dst = 0;
  if (removefile_state_get(a1, 5u, &dst))
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v5 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)uint64_t v39 = 0LL;
      unsigned int v6 = sub_100053B4C(1);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v7 = v6;
      }
      else {
        uint64_t v7 = v6 & 0xFFFFFFFE;
      }
      if ((_DWORD)v7)
      {
        v42.st_dev = 136315138;
        *(void *)&v42.st_mode = a2;
        uint64_t v8 = (const char *)_os_log_send_and_compose_impl( v7,  v39,  0LL,  0LL,  &_mh_execute_header,  v5,  0LL,  "removefile hit error for %s but we failed to get the error number",  (const char *)&v42);
        id v9 = (char *)v8;
        if (v8) {
          sub_100053B7C(v8);
        }
      }

      else
      {
        id v9 = 0LL;
      }

      free(v9);
    }

    int dst = 2;
    goto LABEL_24;
  }

  if (dst == 2) {
    goto LABEL_24;
  }
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v10 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t v39 = 0LL;
    LODWORD(v11) = sub_100053B4C(1);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v11 = v11;
    }
    else {
      uint64_t v11 = v11 & 0xFFFFFFFE;
    }
    if ((_DWORD)v11)
    {
      int v12 = dst;
      int v13 = v10;
      CFRange v14 = strerror(v12);
      v42.st_dev = 136315394;
      *(void *)&v42.st_mode = a2;
      WORD2(v42.st_ino) = 2080;
      *(__darwin_ino64_t *)((char *)&v42.st_ino + 6) = (__darwin_ino64_t)v14;
      unsigned int v15 = (char *)_os_log_send_and_compose_impl( v11,  v39,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "removefile hit error for %s : %s",  (const char *)&v42,  22);

      if (v15) {
        sub_100053B7C(v15);
      }
    }

    else
    {
      unsigned int v15 = 0LL;
    }

    free(v15);
  }

  if (dst != 1) {
    goto LABEL_24;
  }
  memset(&v42, 0, sizeof(v42));
  if (lstat(a2, &v42))
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v17 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_54;
    }
    uint64_t v37 = 0LL;
    LODWORD(v1_Block_object_dispose(va, 8) = sub_100053B4C(1);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v18 = v18;
    }
    else {
      uint64_t v18 = v18 & 0xFFFFFFFE;
    }
    if ((_DWORD)v18)
    {
      uint64_t v19 = v17;
      uint64_t v20 = __error();
      id v21 = strerror(*v20);
      *(_DWORD *)uint64_t v39 = 136315394;
      *(void *)&v39[4] = a2;
      __int16 v40 = 2080;
      int v41 = v21;
      LODWORD(v36) = 22;
      uint64_t v22 = _os_log_send_and_compose_impl( v18,  &v37,  0LL,  0LL,  &_mh_execute_header,  v19,  0LL,  "Failed to stat %s before unsetting UF_IMMUTABLE: %s",  v39,  v36);
      goto LABEL_40;
    }

    goto LABEL_52;
  }

  if ((v42.st_flags & 2) == 0)
  {
LABEL_24:
    if (a3 && !*a3) {
      *a3 = dst;
    }
    return 0LL;
  }

  if (lchflags(a2, v42.st_flags & 0xFFFFFFFD))
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v17 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_54;
    }
    uint64_t v37 = 0LL;
    LODWORD(v24) = sub_100053B4C(1);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v24 = v24;
    }
    else {
      uint64_t v24 = v24 & 0xFFFFFFFE;
    }
    if ((_DWORD)v24)
    {
      uint64_t v19 = v17;
      unsigned int v25 = __error();
      uint64_t v26 = strerror(*v25);
      *(_DWORD *)uint64_t v39 = 136315394;
      *(void *)&v39[4] = a2;
      __int16 v40 = 2080;
      int v41 = v26;
      LODWORD(v36) = 22;
      uint64_t v22 = _os_log_send_and_compose_impl( v24,  &v37,  0LL,  0LL,  &_mh_execute_header,  v19,  0LL,  "Failed to lchflags %s: %s",  v39,  v36);
LABEL_40:
      __int128 v23 = (char *)v22;

      if (v23) {
        sub_100053B7C(v23);
      }
      goto LABEL_53;
    }

uint64_t sub_100045A94(const __CFDictionary *a1)
{
  uint64_t v2 = (void *)sub_100083DF4(a1, kUMUserSessionUUIDKey);
  uint64_t v3 = sub_100083C6C(a1, kMKBUserSessionIDKey);
  if (v2)
  {
    uint64_t v4 = v3;
    unsigned int v5 = sub_100017CFC((uint64_t)&OBJC_CLASS___NSUUID, v2);
    unsigned int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
    if (v6)
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v7 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v43 = 0LL;
        unsigned int v8 = sub_100053B4C(1);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v9 = v8;
        }
        else {
          uint64_t v9 = v8 & 0xFFFFFFFE;
        }
        if ((_DWORD)v9)
        {
          LOWORD(v46) = 0;
          uint64_t v10 = (const char *)_os_log_send_and_compose_impl( v9,  &v43,  0LL,  0LL,  &_mh_execute_header,  v7,  0LL,  "GOT UUID from uuidstring",  &v46,  2);
          uint64_t v11 = (char *)v10;
          if (v10) {
            sub_100053B7C(v10);
          }
        }

        else
        {
          uint64_t v11 = 0LL;
        }

        free(v11);
      }

      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      id v21 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v43 = 0LL;
        unsigned int v22 = sub_100053B4C(1);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v23 = v22;
        }
        else {
          uint64_t v23 = v22 & 0xFFFFFFFE;
        }
        if ((_DWORD)v23)
        {
          LODWORD(v46) = 67109120;
          HIDWORD(v46) = v4;
          uint64_t v24 = (const char *)_os_log_send_and_compose_impl( v23,  &v43,  0LL,  0LL,  &_mh_execute_header,  v21,  0LL,  "Loading the identity for user:%d",  &v46);
          unsigned int v25 = (char *)v24;
          if (v24) {
            sub_100053B7C(v24);
          }
        }

        else
        {
          unsigned int v25 = 0LL;
        }

        free(v25);
      }

      uint64_t v26 = sub_100019B18(qword_1000DBD40);
      unsigned int v27 = (void *)objc_claimAutoreleasedReturnValue(v26);
      id v42 = 0LL;
      unsigned __int8 v28 = [v27 loadIdentity:v6 intoSession:v4 error:&v42];
      id v16 = v42;

      if ((v28 & 1) != 0)
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        uint64_t v29 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v43 = 0LL;
          unsigned int v30 = sub_100053B4C(1);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v31 = v30;
          }
          else {
            uint64_t v31 = v30 & 0xFFFFFFFE;
          }
          if ((_DWORD)v31)
          {
            LODWORD(v46) = 67109120;
            HIDWORD(v46) = v4;
            uint64_t v32 = (const char *)_os_log_send_and_compose_impl( v31,  &v43,  0LL,  0LL,  &_mh_execute_header,  v29,  0LL,  "AKS Identity for user:%d Successfully Loaded",  &v46);
            uint64_t v33 = (char *)v32;
            if (v32) {
              sub_100053B7C(v32);
            }
          }

          else
          {
            uint64_t v33 = 0LL;
          }

          free(v33);
        }

        uint64_t v39 = 1LL;
        goto LABEL_74;
      }

      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      unsigned int v34 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v46 = 0LL;
        LODWORD(v35) = sub_100053B4C(1);
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v35 = v35;
        }
        else {
          uint64_t v35 = v35 & 0xFFFFFFFE;
        }
        if ((_DWORD)v35)
        {
          uint64_t v36 = v34;
          id v37 = [v16 code];
          LODWORD(v43) = 67109376;
          HIDWORD(v43) = v4;
          __int16 v44 = 2048;
          id v45 = v37;
          LODWORD(v41) = 18;
          uint64_t v38 = (char *)_os_log_send_and_compose_impl( v35,  &v46,  0LL,  0LL,  &_mh_execute_header,  v36,  0LL,  "Loading of AKS Identity for user:%d failed with %ld",  &v43,  v41);

          if (v38) {
            sub_100053B7C(v38);
          }
        }

        else
        {
          uint64_t v38 = 0LL;
        }

        free(v38);
      }
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      id v16 = (id)qword_1000DBA98;
      if (os_log_type_enabled((os_log_t)v16, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v43 = 0LL;
        unsigned int v17 = sub_100053B4C(1);
        if (os_log_type_enabled((os_log_t)v16, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v18 = v17;
        }
        else {
          uint64_t v18 = v17 & 0xFFFFFFFE;
        }
        if ((_DWORD)v18)
        {
          LOWORD(v46) = 0;
          uint64_t v19 = (const char *)_os_log_send_and_compose_impl( v18,  &v43,  0LL,  0LL,  &_mh_execute_header,  v16,  0LL,  "NULL UUID, failure, bailing",  &v46,  2);
          uint64_t v20 = (char *)v19;
          if (v19) {
            sub_100053B7C(v19);
          }
        }

        else
        {
          uint64_t v20 = 0LL;
        }

        free(v20);
      }
    }

    uint64_t v39 = 0LL;
LABEL_74:

    goto LABEL_75;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  unsigned int v6 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v43 = 0LL;
    unsigned int v12 = sub_100053B4C(1);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v13 = v12;
    }
    else {
      uint64_t v13 = v12 & 0xFFFFFFFE;
    }
    if ((_DWORD)v13)
    {
      LOWORD(v46) = 0;
      CFRange v14 = (const char *)_os_log_send_and_compose_impl( v13,  &v43,  0LL,  0LL,  &_mh_execute_header,  v6,  0LL,  "No UUID for the primary, bail",  &v46,  2);
      unsigned int v15 = (char *)v14;
      if (v14) {
        sub_100053B7C(v14);
      }
    }

    else
    {
      unsigned int v15 = 0LL;
    }

    free(v15);
  }

  uint64_t v39 = 0LL;
LABEL_75:

  return v39;
}

id sub_100046098(const __CFDictionary *a1)
{
  uint64_t v1 = sub_100083C6C(a1, kMKBUserSessionIDKey);
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v2 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v21 = 0LL;
    unsigned int v3 = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      LODWORD(v24) = 67109120;
      HIDWORD(v24) = v1;
      unsigned int v5 = (const char *)_os_log_send_and_compose_impl( v4,  &v21,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "Unloading the identity for user:%d",  &v24);
      unsigned int v6 = (char *)v5;
      if (v5) {
        sub_100053B7C(v5);
      }
    }

    else
    {
      unsigned int v6 = 0LL;
    }

    free(v6);
  }

  uint64_t v7 = sub_100019B18(qword_1000DBD40);
  unsigned int v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
  id v20 = 0LL;
  id v9 = [v8 unloadIdentityFromSession:v1 error:&v20];
  id v10 = v20;

  if ((v9 & 1) != 0)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v11 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = 0LL;
      unsigned int v12 = sub_100053B4C(1);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v13 = v12;
      }
      else {
        uint64_t v13 = v12 & 0xFFFFFFFE;
      }
      if ((_DWORD)v13)
      {
        LODWORD(v24) = 67109120;
        HIDWORD(v24) = v1;
        CFRange v14 = (void *)_os_log_send_and_compose_impl( v13,  &v21,  0LL,  0LL,  &_mh_execute_header,  v11,  0LL,  "AKS Identity for user:%d Successfully Unloaded",  &v24);
        if (!v14) {
          goto LABEL_32;
        }
        goto LABEL_30;
      }

      goto LABEL_31;
    }
  }

  else
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v11 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v24 = 0LL;
      LODWORD(v15) = sub_100053B4C(1);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v15 = v15;
      }
      else {
        uint64_t v15 = v15 & 0xFFFFFFFE;
      }
      if ((_DWORD)v15)
      {
        id v16 = v11;
        id v17 = [v10 code];
        LODWORD(v21) = 67109376;
        HIDWORD(v21) = v1;
        __int16 v22 = 2048;
        id v23 = v17;
        LODWORD(v19) = 18;
        CFRange v14 = (void *)_os_log_send_and_compose_impl( v15,  &v24,  0LL,  0LL,  &_mh_execute_header,  v16,  0LL,  "Unloading AKS Identity for user:%d failed with %ld",  &v21,  v19);

        if (!v14)
        {
LABEL_32:
          free(v14);
          goto LABEL_33;
        }

LABEL_33:
  return v9;
}

  return a1;
}

      sub_100053B7C((const char *)v10);
      goto LABEL_44;
    }

    goto LABEL_43;
  }

  if (qword_1000DBBD8 != -1) {
    dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
  }
  uint64_t v7 = (os_log_s *)(id)qword_1000DBBD0;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    v22[0] = 0LL;
    id v16 = sub_100053B4C(1);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      id v17 = v16;
    }
    else {
      id v17 = v16 & 0xFFFFFFFE;
    }
    if ((_DWORD)v17)
    {
      *(_DWORD *)id v23 = 136315138;
      *(void *)&v23[4] = v24;
      uint64_t v18 = (const char *)_os_log_send_and_compose_impl( v17,  v22,  0LL,  0LL,  &_mh_execute_header,  v7,  0LL,  "Successful Transcribe of System Data Volume:%s",  v23);
      uint64_t v19 = (char *)v18;
      if (v18) {
        sub_100053B7C(v18);
      }
    }

    else
    {
      uint64_t v19 = 0LL;
    }

    free(v19);
  }

  id v20 = 1LL;
LABEL_46:

  return v20;
}

    memset_s(__s, 0x40uLL, 0, 0x40uLL);
    if (a4) {
      return v19;
    }
LABEL_34:
    cc_clear(*v14, v47);
    return v19;
  }

CFArrayRef sub_1000463D8(void *a1)
{
  id v1 = sub_1000598D8(qword_1000DBA78, a1);
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(v1);
  if (!v2) {
    return 0LL;
  }
  unsigned int v3 = v2;
  id v4 = sub_100058BD8((id)qword_1000DBA78, 0, v2);
  unsigned int v5 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue(v4);
  if (v5)
  {
    unsigned int v6 = v5;
    if (CFDictionaryContainsKey(v5, off_1000DAD90) && (uint64_t v7 = (const __CFArray *)sub_100083C34(v6, off_1000DAD90)) != 0LL) {
      CFArrayRef Copy = CFArrayCreateCopy(kCFAllocatorDefault, v7);
    }
    else {
      CFArrayRef Copy = 0LL;
    }
    CFRelease(v6);
  }

  else
  {
    CFArrayRef Copy = 0LL;
  }

  CFRelease(v3);
  return Copy;
}

uint64_t sub_100046494(uint64_t a1)
{
  uint64_t v2 = sub_1000197A0(qword_1000DBA78);
  unsigned int v3 = (void *)objc_claimAutoreleasedReturnValue(v2);

  if (!v3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = sub_1000197AC(qword_1000DBD40);
  unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  id v16 = 0LL;
  unsigned int v6 = (void *)objc_claimAutoreleasedReturnValue([v5 infoForProcessWithPID:a1 error:&v16]);
  id v7 = v16;

  if (v6)
  {
    uint64_t v8 = sub_10005682C((uint64_t)v6);
  }

  else
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v9 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = 0LL;
      unsigned int v10 = sub_100053B4C(1);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = v10 & 0xFFFFFFFE;
      }
      if ((_DWORD)v11)
      {
        v17[0] = 67109378;
        v17[1] = a1;
        __int16 v18 = 2112;
        id v19 = v7;
        unsigned int v12 = (const char *)_os_log_send_and_compose_impl( v11,  &v15,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "Failed to look up persona for pid %u: %@",  v17,  18);
        uint64_t v13 = (char *)v12;
        if (v12) {
          sub_100053B7C(v12);
        }
      }

      else
      {
        uint64_t v13 = 0LL;
      }

      free(v13);
    }

    uint64_t v8 = 0xFFFFFFFFLL;
  }

  return v8;
}

__CFString *sub_100046664(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = sub_1000197A0(qword_1000DBA78);
  unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue(v4);

  if (!v5) {
    return (__CFString *)0LL;
  }
  uint64_t v6 = sub_1000197AC(qword_1000DBD40);
  id v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
  id v21 = 0LL;
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v7 infoForPersonaWithID:a3 error:&v21]);
  id v9 = v21;

  if (v8)
  {
    if (sub_1000642D4((uint64_t)v8) == -1)
    {
      uint64_t v13 = @"FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF";
    }

    else
    {
      uint64_t v10 = qword_1000DBA70;
      int v11 = sub_1000642D4((uint64_t)v8);
      id v12 = sub_1000550DC(v10, v11);
      uint64_t v13 = (__CFString *)objc_claimAutoreleasedReturnValue(v12);
    }
  }

  else
  {
    if (qword_1000DBAC0 != -1) {
      dispatch_once(&qword_1000DBAC0, &stru_1000CD568);
    }
    uint64_t v15 = (os_log_s *)(id)qword_1000DBAB8;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      uint64_t v20 = 0LL;
      unsigned int v16 = sub_100053B4C(0);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
        uint64_t v17 = v16;
      }
      else {
        uint64_t v17 = v16 & 0xFFFFFFFE;
      }
      if ((_DWORD)v17)
      {
        v22[0] = 67109378;
        v22[1] = a3;
        __int16 v23 = 2112;
        id v24 = v9;
        __int16 v18 = (const char *)_os_log_send_and_compose_impl( v17,  &v20,  0LL,  0LL,  &_mh_execute_header,  v15,  16LL,  "Failed to look up user UID for current persona %u: failed to retrieve kernel persona: %@",  v22,  18);
        id v19 = (char *)v18;
        if (v18) {
          sub_100053B7C(v18);
        }
      }

      else
      {
        id v19 = 0LL;
      }

      free(v19);
    }

    uint64_t v13 = 0LL;
  }

  return v13;
}

uint64_t sub_100046868(uint64_t a1, void *a2, void *a3, int a4, unsigned int *a5)
{
  id v9 = a3;
  id v10 = sub_1000598D8(qword_1000DBA78, v9);
  uint64_t v11 = objc_claimAutoreleasedReturnValue(v10);
  if (v11)
  {
    id v12 = (void *)v11;
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithDictionary:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithDictionary:",  a1));
    [v13 setObject:v9 forKeyedSubscript:kUMUserPersonaUserODUUIDKey];
    CFRange v14 = sub_10005B318((id *)qword_1000DBA78, v12, v13, a2, a4, 0, a5);
    uint64_t v15 = objc_claimAutoreleasedReturnValue(v14);

    CFRelease(v12);
  }

  else
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v16 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v23 = 0LL;
      unsigned int v17 = sub_100053B4C(1);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v18 = v17;
      }
      else {
        uint64_t v18 = v17 & 0xFFFFFFFE;
      }
      if ((_DWORD)v18)
      {
        __int16 v22 = 0;
        id v19 = (const char *)_os_log_send_and_compose_impl( v18,  &v23,  0LL,  0LL,  &_mh_execute_header,  v16,  0LL,  "Cannot match user session to persona manifest",  &v22,  2);
        uint64_t v20 = (char *)v19;
        if (v19) {
          sub_100053B7C(v19);
        }
      }

      else
      {
        uint64_t v20 = 0LL;
      }

      free(v20);
    }

    uint64_t v15 = 0LL;
    if (a5) {
      *a5 = 2;
    }
  }

  return v15;
}

uint64_t sub_100046A1C(const __CFDictionary *a1, void *a2)
{
  id v3 = sub_1000598D8(qword_1000DBA78, a2);
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  if (!v4) {
    goto LABEL_8;
  }
  if (CFDictionaryContainsKey(a1, kUMUserPersonaUniqueStringKey))
  {
    uint64_t v5 = qword_1000DBA78;
    uint64_t v6 = (void *)sub_100083DF4(a1, kUMUserPersonaUniqueStringKey);
    id v7 = sub_1000590FC(v5, v6, v4);
    uint64_t v8 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue(v7);
  }

  else
  {
    if (!CFDictionaryContainsKey(a1, kUMUserPersonaTypeKey)) {
      goto LABEL_8;
    }
    id v9 = (void *)qword_1000DBA78;
    unsigned int v10 = sub_100083C6C(a1, kUMUserPersonaTypeKey);
    id v11 = sub_100058BD8(v9, v10, v4);
    uint64_t v8 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue(v11);
  }

  id v12 = v8;
  if (v8)
  {
    uint64_t v13 = sub_100046BE8(v4, v8, 0);
    CFRelease(v4);
    CFRelease(v12);
    return v13;
  }

LABEL_8:
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v15 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v21 = 0LL;
    unsigned int v16 = sub_100053B4C(1);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v17 = v16;
    }
    else {
      uint64_t v17 = v16 & 0xFFFFFFFE;
    }
    if ((_DWORD)v17)
    {
      __int16 v20 = 0;
      uint64_t v18 = (const char *)_os_log_send_and_compose_impl( v17,  &v21,  0LL,  0LL,  &_mh_execute_header,  v15,  0LL,  "FOUND No requested persona entry in the Manifest or user does not exist",  &v20,  2);
      id v19 = (char *)v18;
      if (v18) {
        sub_100053B7C(v18);
      }
    }

    else
    {
      id v19 = 0LL;
    }

    free(v19);
  }

  if (v4) {
    CFRelease(v4);
  }
  return 22LL;
}

  return a1;
}

  if (a5)
  {
    if (v14) {
      id v11 = v16;
    }
    else {
      id v11 = 0LL;
    }
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *))(a5 + 16))(a5, v10, v11);
  }

  if ((_DWORD)v10) {
    id v12 = 70;
  }
  else {
    id v12 = 10;
  }
  if (v12 >= gACMLoggingLevel) {
    return printf( "%s: %s: returning, err = %ld.\n",  "ACM",  "LibCall_ACMGlobalContextCredentialGetProperty_Block",  (int)v10);
  }
  return result;
}

  memset_s(__s, 0x20uLL, 0, 0x20uLL);
  return v10;
}

uint64_t sub_100046BE8(void *a1, const __CFDictionary *a2, int a3)
{
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v6 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v6, OS_LOG_TYPE_DEFAULT))
  {
    v231[0] = 0LL;
    unsigned int v7 = sub_100053B4C(1);
    uint64_t v8 = (os_log_s *)v6;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v9 = v7;
    }
    else {
      uint64_t v9 = v7 & 0xFFFFFFFE;
    }
    if ((_DWORD)v9)
    {
      *(_DWORD *)in = 138412290;
      *(void *)&in[4] = a2;
      unsigned int v10 = (char *)_os_log_send_and_compose_impl( v9,  v231,  0LL,  0LL,  &_mh_execute_header,  v8,  0LL,  "Found Persona Dict, deleting:%@",  in,  12);

      if (v10) {
        sub_100053B7C(v10);
      }
    }

    else
    {

      unsigned int v10 = 0LL;
    }

    free(v10);
  }

  id v11 = (const void *)(int)sub_100083C6C(a2, kUMUserPersonaTypeKey);
  uint64_t v12 = sub_100083C6C(a2, kUMUserPersonaIDKey);
  uint64_t v13 = sub_100083DF4(a2, kUMUserPersonaUniqueStringKey);
  if ((a3 & 1) == 0 && (v11 | 4) != 6)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    CFRange v14 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      v231[0] = 0LL;
      unsigned int v27 = sub_100053B4C(1);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v28 = v27;
      }
      else {
        uint64_t v28 = v27 & 0xFFFFFFFE;
      }
      if ((_DWORD)v28)
      {
        *(_DWORD *)in = 134217984;
        *(void *)&in[4] = v11;
        uint64_t v29 = (const char *)_os_log_send_and_compose_impl( v28,  v231,  0LL,  0LL,  &_mh_execute_header,  v14,  0LL,  "Persona Deletion of Non Enterprise or Guest persona is not allowed:%lu",  in);
        unsigned int v30 = (char *)v29;
        if (v29) {
          sub_100053B7C(v29);
        }
      }

      else
      {
        unsigned int v30 = 0LL;
      }

      free(v30);
    }

    uint64_t v34 = 1LL;
    goto LABEL_427;
  }

  if ((_DWORD)v12 == -1 && (_DWORD)v11 != 4)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    CFRange v14 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      v231[0] = 0LL;
      unsigned int v15 = sub_100053B4C(1);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v16 = v15;
      }
      else {
        uint64_t v16 = v15 & 0xFFFFFFFE;
      }
      if ((_DWORD)v16)
      {
        *(_DWORD *)in = 138412290;
        *(void *)&in[4] = v13;
        LODWORD(v204) = 12;
        uint64_t v17 = (const char *)_os_log_send_and_compose_impl( v16,  v231,  0LL,  0LL,  &_mh_execute_header,  v14,  0LL,  "Failed to delete persona: persona with unique string %@ does not have a valid kernel persona ID",  in,  v204);
        uint64_t v18 = (char *)v17;
        if (v17) {
          sub_100053B7C(v17);
        }
      }

      else
      {
        uint64_t v18 = 0LL;
      }

      free(v18);
    }

    uint64_t v34 = 22LL;
    goto LABEL_427;
  }

  CFDictionarySetValue(a2, off_1000DAD98, kCFBooleanTrue);
  uint64_t v19 = sub_1000197AC(qword_1000DBA78);
  __int16 v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
  sub_1000562B8((uint64_t)v20);

  sub_10005B2D0(qword_1000DBA78);
  CFDictionaryRef theDict = a2;
  if ((_DWORD)v11 != 4)
  {
    if (sub_100060454(qword_1000DBA78, v12))
    {
      id v213 = 0LL;
      char v21 = sub_10005EDF4(qword_1000DBA78, a2, &v213);
      __int16 v22 = (os_log_s *)v213;
      CFRange v14 = v22;
      if ((v21 & 1) == 0)
      {
        uint64_t v34 = (uint64_t)-[os_log_s code](v22, "code");
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        uint64_t v35 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
        {
          v231[0] = 0LL;
          LODWORD(v36) = sub_100053B4C(1);
          if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v36 = v36;
          }
          else {
            uint64_t v36 = v36 & 0xFFFFFFFE;
          }
          if ((_DWORD)v36)
          {
            id v37 = v35;
            uint64_t v38 = strerror(v34);
            *(_DWORD *)in = 67109378;
            *(_DWORD *)&in[4] = v12;
            *(_WORD *)&in[8] = 2080;
            *(void *)&in[10] = v38;
            LODWORD(v204) = 18;
            uint64_t v39 = (char *)_os_log_send_and_compose_impl( v36,  v231,  0LL,  0LL,  &_mh_execute_header,  v37,  0LL,  "Failed to delete persona: Kernel persona deallocation for ID:%d failed with Error:%s",  in,  v204);

            if (v39) {
              sub_100053B7C(v39);
            }
          }

          else
          {
            uint64_t v39 = 0LL;
          }

          free(v39);
        }

        goto LABEL_427;
      }

      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      id v23 = (id)qword_1000DBA98;
      if (os_log_type_enabled((os_log_t)v23, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)in = 0LL;
        unsigned int v24 = sub_100053B4C(1);
        id v23 = v23;
        if (os_log_type_enabled((os_log_t)v23, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v25 = v24;
        }
        else {
          uint64_t v25 = v24 & 0xFFFFFFFE;
        }
        if ((_DWORD)v25)
        {
          LODWORD(v231[0]) = 67109120;
          HIDWORD(v231[0]) = v12;
          uint64_t v26 = (char *)_os_log_send_and_compose_impl( v25,  in,  0LL,  0LL,  &_mh_execute_header,  v23,  0LL,  "PersonaID:%d deleted from  Kernel",  v231);

          if (v26) {
            sub_100053B7C(v26);
          }
        }

        else
        {

          uint64_t v26 = 0LL;
        }

        free(v26);
      }
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      id v23 = (id)qword_1000DBA98;
      if (os_log_type_enabled((os_log_t)v23, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)in = 0LL;
        unsigned int v31 = sub_100053B4C(1);
        id v23 = v23;
        if (os_log_type_enabled((os_log_t)v23, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v32 = v31;
        }
        else {
          uint64_t v32 = v31 & 0xFFFFFFFE;
        }
        if ((_DWORD)v32)
        {
          LODWORD(v231[0]) = 67109120;
          HIDWORD(v231[0]) = v12;
          uint64_t v33 = (char *)_os_log_send_and_compose_impl( v32,  in,  0LL,  0LL,  &_mh_execute_header,  v23,  0LL,  "PersonaID:%d Not loaded in Kernel",  v231);

          if (v33) {
            sub_100053B7C(v33);
          }
        }

        else
        {

          uint64_t v33 = 0LL;
        }

        free(v33);
      }

      CFRange v14 = 0LL;
    }

    if ((a3 & 1) != 0) {
      goto LABEL_82;
    }
    goto LABEL_80;
  }

  CFRange v14 = 0LL;
  if ((a3 & 1) == 0)
  {
LABEL_80:
    if (v13)
    {
      uint64_t v40 = sub_100018F58(qword_1000DBD40);
      uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue(v40);
      [v41 deleteKeychainItemsForPersonaWithUUID:v13 error:0];
    }
  }

LABEL_82:
  if (!a3) {
    goto LABEL_149;
  }
  int v205 = (int)v11;
  uint64_t v206 = v13;
  int v207 = v12;
  char v208 = a1;
  memset(v231, 0, sizeof(v231));
  __int128 v232 = 0u;
  __int128 v233 = 0u;
  id v42 = [&off_1000D10F0 countByEnumeratingWithState:v231 objects:in count:16];
  if (!v42) {
    goto LABEL_137;
  }
  id v43 = v42;
  uint64_t v44 = *(void *)v231[2];
  do
  {
    for (CFIndex i = 0LL; i != v43; CFIndex i = (char *)i + 1)
    {
      if (*(void *)v231[2] != v44) {
        objc_enumerationMutation(&off_1000D10F0);
      }
      id v46 = *(id *)(v231[1] + 8LL * (void)i);
      uint64_t v47 = sub_100018F4C(qword_1000DBD40);
      uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue(v47);
      uint64_t v49 = sub_100018E80(qword_1000DBD40);
      int v50 = (void *)objc_claimAutoreleasedReturnValue(v49);
      uint64_t v51 = sub_100019B60((uint64_t)v50);
      uint64_t v238 = 0LL;
      id v52 = [v48 pidForLaunchdJobWithLabel:v46 forUser:v51 error:&v238];
      id v53 = (id)v238;

      if ((_DWORD)v52)
      {
        uint64_t v54 = sub_100018F4C(qword_1000DBD40);
        uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue(v54);
        id v215 = v53;
        unsigned int v56 = [v55 terminatePID:v52 withReasonNamespace:2 reasonCode:0 reasonString:@"PersonaTermination" error:&v215];
        id v57 = v215;

        if (v56)
        {
          if (qword_1000DBAC0 != -1) {
            dispatch_once(&qword_1000DBAC0, &stru_1000CD568);
          }
          unsigned int v58 = (os_log_s *)(id)qword_1000DBAB8;
          if (!os_log_type_enabled(v58, OS_LOG_TYPE_INFO)) {
            goto LABEL_129;
          }
          uint64_t v214 = 0LL;
          unsigned int v59 = sub_100053B4C(0);
          if (os_log_type_enabled(v58, OS_LOG_TYPE_INFO)) {
            uint64_t v60 = v59;
          }
          else {
            uint64_t v60 = v59 & 0xFFFFFFFE;
          }
          if ((_DWORD)v60)
          {
            int uu = 138543618;
            id uu_4 = v46;
            __int16 uu_12 = 1024;
            *(_DWORD *)uu_14 = (_DWORD)v52;
            LODWORD(v204) = 18;
            unsigned int v61 = (const char *)_os_log_send_and_compose_impl( v60,  &v214,  0LL,  0LL,  &_mh_execute_header,  v58,  1LL,  "Terminated %{public}@ with pid %d",  &uu,  v204);
LABEL_116:
            uint64_t v69 = (char *)v61;
            if (v61) {
              sub_100053B7C(v61);
            }
LABEL_128:
            free(v69);
LABEL_129:

            id v53 = v57;
            goto LABEL_135;
          }
        }

        else
        {
          if (qword_1000DBAC0 != -1) {
            dispatch_once(&qword_1000DBAC0, &stru_1000CD568);
          }
          unsigned int v58 = (os_log_s *)(id)qword_1000DBAB8;
          if (!os_log_type_enabled(v58, OS_LOG_TYPE_ERROR)) {
            goto LABEL_129;
          }
          uint64_t v214 = 0LL;
          unsigned int v67 = sub_100053B4C(0);
          if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR)) {
            uint64_t v68 = v67;
          }
          else {
            uint64_t v68 = v67 & 0xFFFFFFFE;
          }
          if ((_DWORD)v68)
          {
            int uu = 138543874;
            id uu_4 = v46;
            __int16 uu_12 = 1024;
            *(_DWORD *)uu_14 = (_DWORD)v52;
            *(_WORD *)&uu_14[4] = 2114;
            *(void *)&uu_14[6] = v57;
            LODWORD(v204) = 28;
            unsigned int v61 = (const char *)_os_log_send_and_compose_impl( v68,  &v214,  0LL,  0LL,  &_mh_execute_header,  v58,  16LL,  "Termination of %{public}@ with pid %d failed with error: %{public}@",  &uu,  v204);
            goto LABEL_116;
          }
        }

        uint64_t v69 = 0LL;
        goto LABEL_128;
      }

      if (v53)
      {
        if (qword_1000DBAC0 != -1) {
          dispatch_once(&qword_1000DBAC0, &stru_1000CD568);
        }
        uint64_t v62 = (os_log_s *)(id)qword_1000DBAB8;
        if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
        {
          id v215 = 0LL;
          unsigned int v63 = sub_100053B4C(0);
          if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR)) {
            uint64_t v64 = v63;
          }
          else {
            uint64_t v64 = v63 & 0xFFFFFFFE;
          }
          if ((_DWORD)v64)
          {
            int uu = 138543618;
            id uu_4 = v46;
            __int16 uu_12 = 2114;
            *(void *)uu_14 = v53;
            LODWORD(v204) = 22;
            uint64_t v65 = (const char *)_os_log_send_and_compose_impl( v64,  &v215,  0LL,  0LL,  &_mh_execute_header,  v62,  16LL,  "Unable to find valid pid for the launchd job %{public}@: %{public}@",  &uu,  v204);
            uint64_t v66 = (char *)v65;
            if (v65) {
              sub_100053B7C(v65);
            }
          }

          else
          {
            uint64_t v66 = 0LL;
          }

          free(v66);
        }
      }

      else
      {
        if (qword_1000DBAC0 != -1) {
          dispatch_once(&qword_1000DBAC0, &stru_1000CD568);
        }
        id v53 = (id)qword_1000DBAB8;
        if (os_log_type_enabled((os_log_t)v53, OS_LOG_TYPE_INFO))
        {
          id v215 = 0LL;
          unsigned int v70 = sub_100053B4C(0);
          if (os_log_type_enabled((os_log_t)v53, OS_LOG_TYPE_INFO)) {
            uint64_t v71 = v70;
          }
          else {
            uint64_t v71 = v70 & 0xFFFFFFFE;
          }
          if ((_DWORD)v71)
          {
            int uu = 138543362;
            id uu_4 = v46;
            LODWORD(v204) = 12;
            unsigned int v72 = (const char *)_os_log_send_and_compose_impl( v71,  &v215,  0LL,  0LL,  &_mh_execute_header,  v53,  1LL,  "Launchd job %{public}@ is not running",  &uu,  v204);
            int v73 = (char *)v72;
            if (v72) {
              sub_100053B7C(v72);
            }
          }

          else
          {
            int v73 = 0LL;
          }

          free(v73);
        }
      }

LABEL_275:
    id v138 = 0LL;
    goto LABEL_276;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  unsigned int v131 = theDict;
  id v132 = (os_log_s *)(id)qword_1000DBA98;
  if (!os_log_type_enabled(v132, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_277;
  }
  v231[0] = 0LL;
  unsigned int v133 = sub_100053B4C(1);
  id v132 = v132;
  if (os_log_type_enabled(v132, OS_LOG_TYPE_DEFAULT)) {
    uint64_t v134 = v133;
  }
  else {
    uint64_t v134 = v133 & 0xFFFFFFFE;
  }
  if (!(_DWORD)v134) {
    goto LABEL_275;
  }
  uint64_t v238 = 67109120LL;
  uint64_t v135 = _os_log_send_and_compose_impl( v134,  v231,  0LL,  0LL,  &_mh_execute_header,  v132,  0LL,  "Successfully unmap, Removing Persona Key for user:%d",  &v238);
LABEL_273:
  id v138 = (char *)v135;

  if (v138) {
    sub_100053B7C(v138);
  }
LABEL_276:
  free(v138);
LABEL_277:

  int v139 = (void *)sub_100083DF4(v131, kUMUserPersonaUniqueStringKey);
  id v140 = sub_100017CFC((uint64_t)&OBJC_CLASS___NSUUID, v139);
  unsigned int v141 = (void *)objc_claimAutoreleasedReturnValue(v140);
  uint64_t v142 = sub_100019B18(qword_1000DBD40);
  uint64_t v143 = (void *)objc_claimAutoreleasedReturnValue(v142);
  unsigned int v211 = v130;
  unsigned int v144 = [v143 deletePersonaWithUUID:v141 fromSession:0 error:&v211];
  CFRange v14 = v211;

  if (v144)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v13 = v11;
    id v145 = (id)qword_1000DBA98;
    LODWORD(v11) = v125;
    if (os_log_type_enabled((os_log_t)v145, OS_LOG_TYPE_DEFAULT))
    {
      v231[0] = 0LL;
      unsigned int v146 = sub_100053B4C(1);
      id v145 = v145;
      if (os_log_type_enabled((os_log_t)v145, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v147 = v146;
      }
      else {
        uint64_t v147 = v146 & 0xFFFFFFFE;
      }
      a1 = v209;
      if ((_DWORD)v147)
      {
        LOWORD(v23_Block_object_dispose(va, 8) = 0;
        LODWORD(v204) = 2;
        uint64_t v148 = (char *)_os_log_send_and_compose_impl( v147,  v231,  0LL,  0LL,  &_mh_execute_header,  v145,  0LL,  "Successfully Deleted the persona key",  &v238,  v204);

        if (v148) {
          sub_100053B7C(v148);
        }
      }

      else
      {

        uint64_t v148 = 0LL;
      }

      free(v148);
      unsigned int v124 = 0;
      goto LABEL_303;
    }

    unsigned int v124 = 0;
LABEL_298:
    a1 = v209;
    goto LABEL_303;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v13 = v11;
  id v145 = (id)qword_1000DBA98;
  LODWORD(v11) = v125;
  if (!os_log_type_enabled((os_log_t)v145, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v124 = 5;
    goto LABEL_298;
  }

  uint64_t v238 = 0LL;
  unsigned int v149 = sub_100053B4C(1);
  id v145 = v145;
  if (os_log_type_enabled((os_log_t)v145, OS_LOG_TYPE_DEFAULT)) {
    uint64_t v150 = v149;
  }
  else {
    uint64_t v150 = v149 & 0xFFFFFFFE;
  }
  if ((_DWORD)v150)
  {
    v231[0] = 67109378LL;
    LOWORD(v231[1]) = 2112;
    *(void *)((char *)&v231[1] + 2) = v14;
    LODWORD(v204) = 18;
    uint64_t v151 = (char *)_os_log_send_and_compose_impl( v150,  &v238,  0LL,  0LL,  &_mh_execute_header,  v145,  0LL,  "Failed to delete persona Key for user:%d with error:%@",  v231,  v204);

    if (v151) {
      sub_100053B7C(v151);
    }
  }

  else
  {

    uint64_t v151 = 0LL;
  }

  a1 = v209;
  free(v151);
  unsigned int v124 = 5;
LABEL_303:

LABEL_304:
  if (!v124)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    uint64_t v152 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v152, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_325;
    }
    v231[0] = 0LL;
    unsigned int v156 = sub_100053B4C(1);
    uint64_t v152 = v152;
    if (os_log_type_enabled(v152, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v157 = v156;
    }
    else {
      uint64_t v157 = v156 & 0xFFFFFFFE;
    }
    if ((_DWORD)v157)
    {
      LOWORD(v23_Block_object_dispose(va, 8) = 0;
      uint64_t v155 = _os_log_send_and_compose_impl( v157,  v231,  0LL,  0LL,  &_mh_execute_header,  v152,  0LL,  "deleted persona key from keybag");
      goto LABEL_321;
    }

LABEL_323:
    CFTypeRef v158 = 0LL;
    goto LABEL_324;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v152 = (os_log_s *)(id)qword_1000DBA98;
  if (!os_log_type_enabled(v152, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_325;
  }
  v231[0] = 0LL;
  unsigned int v153 = sub_100053B4C(1);
  uint64_t v152 = v152;
  if (os_log_type_enabled(v152, OS_LOG_TYPE_DEFAULT)) {
    uint64_t v154 = v153;
  }
  else {
    uint64_t v154 = v153 & 0xFFFFFFFE;
  }
  if (!(_DWORD)v154) {
    goto LABEL_323;
  }
  LODWORD(v23_Block_object_dispose(va, 8) = 67109120;
  HIDWORD(v23_Block_object_dispose(va, 8) = v124;
  uint64_t v155 = _os_log_send_and_compose_impl( v154,  v231,  0LL,  0LL,  &_mh_execute_header,  v152,  0LL,  "Failed to delete persona key from keybag:0x%x",  &v238);
LABEL_321:
  CFTypeRef v158 = (char *)v155;

  if (v158) {
    sub_100053B7C(v158);
  }
LABEL_324:
  free(v158);
LABEL_325:

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v159 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v159, OS_LOG_TYPE_DEFAULT))
  {
    v231[0] = 0LL;
    unsigned int v160 = sub_100053B4C(1);
    unsigned int v161 = (os_log_s *)v159;
    if (os_log_type_enabled(v161, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v162 = v160;
    }
    else {
      uint64_t v162 = v160 & 0xFFFFFFFE;
    }
    if ((_DWORD)v162)
    {
      LOWORD(v23_Block_object_dispose(va, 8) = 0;
      LODWORD(v204) = 2;
      uint64_t v163 = (char *)_os_log_send_and_compose_impl( v162,  v231,  0LL,  0LL,  &_mh_execute_header,  v161,  0LL,  "Deleting the Persona volume",  &v238,  v204);

      if (v163) {
        sub_100053B7C(v163);
      }
    }

    else
    {

      uint64_t v163 = 0LL;
    }

    free(v163);
  }

  if (!CFDictionaryContainsKey(theDict, kUMUserSessionVolumeDeviceNodeKey))
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v168 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v168, OS_LOG_TYPE_DEFAULT))
    {
      v231[0] = 0LL;
      unsigned int v169 = sub_100053B4C(1);
      __int128 v170 = (os_log_s *)v168;
      if (os_log_type_enabled(v170, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v171 = v169;
      }
      else {
        uint64_t v171 = v169 & 0xFFFFFFFE;
      }
      if ((_DWORD)v171)
      {
        LOWORD(v23_Block_object_dispose(va, 8) = 0;
        LODWORD(v204) = 2;
        uint64_t v172 = (char *)_os_log_send_and_compose_impl( v171,  v231,  0LL,  0LL,  &_mh_execute_header,  v170,  0LL,  "No Device Volume attached to the Persona",  &v238,  v204);

        if (v172) {
          sub_100053B7C(v172);
        }
      }

      else
      {

        uint64_t v172 = 0LL;
      }

      free(v172);
    }

    goto LABEL_405;
  }

  if (![(id)qword_1000DBA68 deleteVolumeWithSession:theDict error:0])
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v164 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v164, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_367;
    }
    v231[0] = 0LL;
    unsigned int v173 = sub_100053B4C(1);
    unsigned int v164 = v164;
    if (os_log_type_enabled(v164, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v174 = v173;
    }
    else {
      uint64_t v174 = v173 & 0xFFFFFFFE;
    }
    if ((_DWORD)v174)
    {
      LOWORD(v23_Block_object_dispose(va, 8) = 0;
      LODWORD(v204) = 2;
      uint64_t v167 = _os_log_send_and_compose_impl( v174,  v231,  0LL,  0LL,  &_mh_execute_header,  v164,  0LL,  "Failed to remove APFS User volume for Persona",  &v238,  v204);
      goto LABEL_363;
    }

LABEL_365:
    int v175 = 0LL;
    goto LABEL_366;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  unsigned int v164 = (os_log_s *)(id)qword_1000DBA98;
  if (!os_log_type_enabled(v164, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_367;
  }
  v231[0] = 0LL;
  unsigned int v165 = sub_100053B4C(1);
  unsigned int v164 = v164;
  if (os_log_type_enabled(v164, OS_LOG_TYPE_DEFAULT)) {
    uint64_t v166 = v165;
  }
  else {
    uint64_t v166 = v165 & 0xFFFFFFFE;
  }
  if (!(_DWORD)v166) {
    goto LABEL_365;
  }
  LOWORD(v23_Block_object_dispose(va, 8) = 0;
  LODWORD(v204) = 2;
  uint64_t v167 = _os_log_send_and_compose_impl( v166,  v231,  0LL,  0LL,  &_mh_execute_header,  v164,  0LL,  "Removed APFS User volume for Persona",  &v238,  v204);
LABEL_363:
  int v175 = (char *)v167;

  if (v175) {
    sub_100053B7C(v175);
  }
LABEL_366:
  free(v175);
LABEL_367:

  __int128 v176 = theDict;
  if (!CFDictionaryContainsKey(theDict, kUMUserSessionHomeDirKey)) {
    goto LABEL_401;
  }
  Value = CFDictionaryGetValue(theDict, kUMUserSessionHomeDirKey);
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v178 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v178, OS_LOG_TYPE_DEFAULT))
  {
    int v179 = (int)v11;
    id v11 = v13;
    uint64_t v238 = 0LL;
    unsigned int v180 = sub_100053B4C(1);
    v181 = (os_log_s *)v178;
    if (os_log_type_enabled(v181, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v182 = v180;
    }
    else {
      uint64_t v182 = v180 & 0xFFFFFFFE;
    }
    if ((_DWORD)v182)
    {
      LODWORD(v231[0]) = 138412290;
      *(void *)((char *)v231 + 4) = Value;
      LODWORD(v204) = 12;
      unsigned int v183 = (char *)_os_log_send_and_compose_impl( v182,  &v238,  0LL,  0LL,  &_mh_execute_header,  v181,  0LL,  "Clearing path underneath mount point:%@",  v231,  v204);

      if (v183) {
        sub_100053B7C(v183);
      }
    }

    else
    {

      unsigned int v183 = 0LL;
    }

    free(v183);
    uint64_t v13 = v11;
    LODWORD(v11) = v179;
  }

  uint64_t v184 = sub_100019434(qword_1000DBD40);
  uint64_t v185 = (void *)objc_claimAutoreleasedReturnValue(v184);
  unsigned int v186 = [v185 removePath:Value error:0];

  if (!v186)
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v187 = (os_log_s *)(id)qword_1000DBA98;
    if (!os_log_type_enabled(v187, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_400;
    }
    v231[0] = 0LL;
    unsigned int v191 = sub_100053B4C(1);
    unsigned int v187 = v187;
    if (os_log_type_enabled(v187, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v192 = v191;
    }
    else {
      uint64_t v192 = v191 & 0xFFFFFFFE;
    }
    if ((_DWORD)v192)
    {
      LOWORD(v23_Block_object_dispose(va, 8) = 0;
      LODWORD(v204) = 2;
      uint64_t v190 = _os_log_send_and_compose_impl( v192,  v231,  0LL,  0LL,  &_mh_execute_header,  v187,  0LL,  "Failed to delete mount path",  &v238,  v204);
      goto LABEL_396;
    }

LABEL_398:
    unsigned int v193 = 0LL;
    goto LABEL_399;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  unsigned int v187 = (os_log_s *)(id)qword_1000DBA98;
  if (!os_log_type_enabled(v187, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_400;
  }
  v231[0] = 0LL;
  unsigned int v188 = sub_100053B4C(1);
  unsigned int v187 = v187;
  if (os_log_type_enabled(v187, OS_LOG_TYPE_DEFAULT)) {
    uint64_t v189 = v188;
  }
  else {
    uint64_t v189 = v188 & 0xFFFFFFFE;
  }
  if (!(_DWORD)v189) {
    goto LABEL_398;
  }
  LOWORD(v23_Block_object_dispose(va, 8) = 0;
  LODWORD(v204) = 2;
  uint64_t v190 = _os_log_send_and_compose_impl( v189,  v231,  0LL,  0LL,  &_mh_execute_header,  v187,  0LL,  "Successful deletion of mount path",  &v238,  v204);
LABEL_396:
  unsigned int v193 = (char *)v190;

  if (v193) {
    sub_100053B7C(v193);
  }
LABEL_399:
  free(v193);
LABEL_400:

  __int128 v176 = theDict;
LABEL_401:
  CFDictionaryRemoveValue(v176, kUMUserSessionVolumeDeviceNodeKey);
  sub_10005B2D0(qword_1000DBA78);
LABEL_405:
  if ((_DWORD)v11 == 4)
  {
    sub_10005962C(qword_1000DBA78, 4, a1);
    if (qword_1000DBAC0 != -1) {
      dispatch_once(&qword_1000DBAC0, &stru_1000CD568);
    }
    int v194 = (os_log_s *)(id)qword_1000DBAB8;
    if (!os_log_type_enabled(v194, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_426;
    }
    v231[0] = 0LL;
    unsigned int v198 = sub_100053B4C(1);
    int v194 = v194;
    if (os_log_type_enabled(v194, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v199 = v198;
    }
    else {
      uint64_t v199 = v198 & 0xFFFFFFFE;
    }
    if ((_DWORD)v199)
    {
      LOWORD(v23_Block_object_dispose(va, 8) = 0;
      LODWORD(v204) = 2;
      uint64_t v197 = _os_log_send_and_compose_impl( v199,  v231,  0LL,  0LL,  &_mh_execute_header,  v194,  0LL,  "Deleted universal persona",  &v238,  v204);
      goto LABEL_422;
    }

LABEL_424:
    uint64_t v200 = 0LL;
    goto LABEL_425;
  }

  sub_100059488(qword_1000DBA78, v12, a1);
  if (qword_1000DBAC0 != -1) {
    dispatch_once(&qword_1000DBAC0, &stru_1000CD568);
  }
  int v194 = (os_log_s *)(id)qword_1000DBAB8;
  if (!os_log_type_enabled(v194, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_426;
  }
  uint64_t v238 = 0LL;
  unsigned int v195 = sub_100053B4C(1);
  int v194 = v194;
  if (os_log_type_enabled(v194, OS_LOG_TYPE_DEFAULT)) {
    uint64_t v196 = v195;
  }
  else {
    uint64_t v196 = v195 & 0xFFFFFFFE;
  }
  if (!(_DWORD)v196) {
    goto LABEL_424;
  }
  LODWORD(v231[0]) = 138412546;
  *(void *)((char *)v231 + 4) = v13;
  WORD2(v231[1]) = 1024;
  *(_DWORD *)((char *)&v231[1] + 6) = v12;
  LODWORD(v204) = 18;
  uint64_t v197 = _os_log_send_and_compose_impl( v196,  &v238,  0LL,  0LL,  &_mh_execute_header,  v194,  0LL,  "Deleted persona %@ (%u)",  v231,  v204);
LABEL_422:
  uint64_t v200 = (char *)v197;

  if (v200) {
    sub_100053B7C(v200);
  }
LABEL_425:
  free(v200);
LABEL_426:

  uint64_t v201 = sub_1000197AC(qword_1000DBA78);
  unsigned int v202 = (void *)objc_claimAutoreleasedReturnValue(v201);
  sub_1000562B8((uint64_t)v202);

  sub_10005B2D0(qword_1000DBA78);
  uint64_t v34 = 0LL;
LABEL_427:

  return v34;
}

uint64_t sub_100048F6C(const __CFDictionary *a1, void *a2)
{
  id v3 = sub_1000598D8(qword_1000DBA78, a2);
  uint64_t v4 = (__CFDictionary *)objc_claimAutoreleasedReturnValue(v3);
  if (v4)
  {
    if (CFDictionaryContainsKey(a1, kUMUserPersonaUniqueStringKey))
    {
      uint64_t v5 = qword_1000DBA78;
      id v6 = (void *)sub_100083DF4(a1, kUMUserPersonaUniqueStringKey);
      id v7 = sub_1000590FC(v5, v6, v4);
      uint64_t v8 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue(v7);
    }

    else
    {
      if (!CFDictionaryContainsKey(a1, kUMUserPersonaTypeKey)) {
        goto LABEL_17;
      }
      uint64_t v9 = (void *)qword_1000DBA78;
      unsigned int v10 = sub_100083C6C(a1, kUMUserPersonaTypeKey);
      id v11 = sub_100058BD8(v9, v10, v4);
      uint64_t v8 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue(v11);
    }

    uint64_t v12 = v8;
    if (v8)
    {
      int v13 = sub_100083C6C(v8, kUMUserPersonaTypeKey);
      if ((v13 & 0xFFFFFFFB) == 2)
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        CFRange v14 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v43 = 0LL;
          unsigned int v15 = sub_100053B4C(1);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v16 = v15;
          }
          else {
            uint64_t v16 = v15 & 0xFFFFFFFE;
          }
          if ((_DWORD)v16)
          {
            LOWORD(v44[0]) = 0;
            uint64_t v17 = (const char *)_os_log_send_and_compose_impl( v16,  &v43,  0LL,  0LL,  &_mh_execute_header,  v14,  0LL,  "setting Disable on persona",  v44,  2);
            uint64_t v18 = (char *)v17;
            if (v17) {
              sub_100053B7C(v17);
            }
          }

          else
          {
            uint64_t v18 = 0LL;
          }

          free(v18);
        }

        if (sub_100083DA4(v12, kUMUserPersonaDisabledKey))
        {
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          unsigned int v31 = (os_log_s *)(id)qword_1000DBA98;
          if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v43 = 0LL;
            unsigned int v32 = sub_100053B4C(1);
            if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v33 = v32;
            }
            else {
              uint64_t v33 = v32 & 0xFFFFFFFE;
            }
            if ((_DWORD)v33)
            {
              LOWORD(v44[0]) = 0;
              LODWORD(v42) = 2;
              uint64_t v34 = (const char *)_os_log_send_and_compose_impl( v33,  &v43,  0LL,  0LL,  &_mh_execute_header,  v31,  0LL,  "Persona already set to be Disabled",  v44,  v42);
              uint64_t v35 = (char *)v34;
              if (v34) {
                sub_100053B7C(v34);
              }
            }

            else
            {
              uint64_t v35 = 0LL;
            }

            free(v35);
          }
        }

        else
        {
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          uint64_t v36 = (os_log_s *)(id)qword_1000DBA98;
          if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v43 = 0LL;
            unsigned int v37 = sub_100053B4C(1);
            if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v38 = v37;
            }
            else {
              uint64_t v38 = v37 & 0xFFFFFFFE;
            }
            if ((_DWORD)v38)
            {
              LOWORD(v44[0]) = 0;
              LODWORD(v42) = 2;
              uint64_t v39 = (const char *)_os_log_send_and_compose_impl( v38,  &v43,  0LL,  0LL,  &_mh_execute_header,  v36,  0LL,  "Setting Persona Disabled",  v44,  v42);
              uint64_t v40 = (char *)v39;
              if (v39) {
                sub_100053B7C(v39);
              }
            }

            else
            {
              uint64_t v40 = 0LL;
            }

            free(v40);
          }

          CFDictionarySetValue(v12, kUMUserPersonaDisabledKey, kCFBooleanTrue);
        }

        uint64_t v30 = 0LL;
      }

      else
      {
        int v24 = v13;
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        uint64_t v25 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v43 = 0LL;
          unsigned int v26 = sub_100053B4C(1);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v27 = v26;
          }
          else {
            uint64_t v27 = v26 & 0xFFFFFFFE;
          }
          if ((_DWORD)v27)
          {
            v44[0] = 67109120;
            v44[1] = v24;
            uint64_t v28 = (const char *)_os_log_send_and_compose_impl( v27,  &v43,  0LL,  0LL,  &_mh_execute_header,  v25,  0LL,  "Persona Disable called on Non Enterprise or guest PersonaType:%d, bailing as not supported",  v44);
            uint64_t v29 = (char *)v28;
            if (v28) {
              sub_100053B7C(v28);
            }
          }

          else
          {
            uint64_t v29 = 0LL;
          }

          free(v29);
        }

        uint64_t v30 = 45LL;
      }

      CFRelease(v4);
      uint64_t v4 = v12;
LABEL_71:
      CFRelease(v4);
      return v30;
    }
  }

LABEL_17:
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v19 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v43 = 0LL;
    unsigned int v20 = sub_100053B4C(1);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v21 = v20;
    }
    else {
      uint64_t v21 = v20 & 0xFFFFFFFE;
    }
    if ((_DWORD)v21)
    {
      LOWORD(v44[0]) = 0;
      __int16 v22 = (const char *)_os_log_send_and_compose_impl( v21,  &v43,  0LL,  0LL,  &_mh_execute_header,  v19,  0LL,  "FOUND No requested persona entry in the Manifest or user does not exist",  v44,  2);
      id v23 = (char *)v22;
      if (v22) {
        sub_100053B7C(v22);
      }
    }

    else
    {
      id v23 = 0LL;
    }

    free(v23);
  }

  uint64_t v30 = 2LL;
  if (v4) {
    goto LABEL_71;
  }
  return v30;
}

      int v13 = 0LL;
LABEL_18:
      free(v13);
    }
  }

  int v24 = v14;
  uint64_t v25 = v24;
LABEL_96:

LABEL_97:
LABEL_98:

LABEL_99:
  return v25;
}

  return v6;
}

id sub_1000494E0(void *a1, _DWORD *a2)
{
  return sub_10005993C(qword_1000DBA78, a1, a2);
}

id *sub_1000494F4(_DWORD *a1)
{
  return sub_100059B88((id *)qword_1000DBA78, a1);
}

id sub_100049504(void *a1, void *a2, _DWORD *a3)
{
  return sub_10005A03C((void *)qword_1000DBA78, a1, a2, a3);
}

uint64_t sub_10004951C()
{
  uint64_t v0 = sub_1000197AC(qword_1000DBA78);
  id v1 = (void *)objc_claimAutoreleasedReturnValue(v0);
  sub_10005641C((uint64_t)v1);

  uint64_t v2 = sub_1000197AC(qword_1000DBA78);
  id v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  uint64_t v4 = sub_100056274((uint64_t)v3);

  return v4;
}

uint64_t sub_100049570(const __CFDictionary *a1, const __CFArray *a2, void *a3)
{
  id v5 = a3;
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v6 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v48 = 0LL;
    unsigned int v7 = sub_100053B4C(1);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG)) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = v7 & 0xFFFFFFFE;
    }
    if ((_DWORD)v8)
    {
      *(_DWORD *)uint64_t v47 = 138412290;
      *(void *)&v47[4] = a1;
      uint64_t v9 = (const char *)_os_log_send_and_compose_impl( v8,  &v48,  0LL,  0LL,  &_mh_execute_header,  v6,  2LL,  "Updating BundleIDs for %@",  v47,  12);
      unsigned int v10 = (char *)v9;
      if (v9) {
        sub_100053B7C(v9);
      }
    }

    else
    {
      unsigned int v10 = 0LL;
    }

    free(v10);
  }

  id v11 = sub_1000598D8(qword_1000DBA78, v5);
  uint64_t v12 = objc_claimAutoreleasedReturnValue(v11);
  if (v12)
  {
    int v13 = (void *)v12;
    if (CFDictionaryContainsKey(a1, kUMUserPersonaUniqueStringKey))
    {
      uint64_t v14 = qword_1000DBA78;
      unsigned int v15 = (void *)sub_100083DF4(a1, kUMUserPersonaUniqueStringKey);
      id v16 = sub_1000590FC(v14, v15, v13);
      uint64_t v17 = objc_claimAutoreleasedReturnValue(v16);
    }

    else
    {
      if (!CFDictionaryContainsKey(a1, kUMUserPersonaTypeKey))
      {
        uint64_t v27 = 2LL;
        uint64_t v21 = (const __CFDictionary *)v13;
        goto LABEL_80;
      }

      uint64_t v18 = (void *)qword_1000DBA78;
      unsigned int v19 = sub_100083C6C(a1, kUMUserPersonaTypeKey);
      id v20 = sub_100058BD8(v18, v19, v13);
      uint64_t v17 = objc_claimAutoreleasedReturnValue(v20);
    }

    uint64_t v21 = (const __CFDictionary *)v17;
    CFRelease(v13);
    if (v21)
    {
      if (a2)
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        __int16 v22 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v48 = 0LL;
          unsigned int v23 = sub_100053B4C(1);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG)) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = v23 & 0xFFFFFFFE;
          }
          if ((_DWORD)v24)
          {
            *(_DWORD *)uint64_t v47 = 138412546;
            *(void *)&v47[4] = a2;
            *(_WORD *)&_BYTE v47[12] = 2112;
            *(void *)&v47[14] = v21;
            LODWORD(v46) = 22;
            uint64_t v25 = (const char *)_os_log_send_and_compose_impl( v24,  &v48,  0LL,  0LL,  &_mh_execute_header,  v22,  2LL,  "Updating bundle IDS:%@ for persona %@",  v47,  v46);
            unsigned int v26 = (char *)v25;
            if (v25) {
              sub_100053B7C(v25);
            }
          }

          else
          {
            unsigned int v26 = 0LL;
          }

          free(v26);
        }

        int v28 = sub_100083C6C(v21, kUMUserPersonaIDKey);
        if (CFDictionaryContainsKey(v21, kUMUserPersonaBundleIDsKey))
        {
          uint64_t v29 = sub_100083C34(v21, kUMUserPersonaBundleIDsKey);
          uint64_t v30 = v29;
          if (v29) {
            CFRetain(v29);
          }
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          unsigned int v31 = (os_log_s *)(id)qword_1000DBA98;
          if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v48 = 0LL;
            unsigned int v32 = sub_100053B4C(1);
            if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG)) {
              uint64_t v33 = v32;
            }
            else {
              uint64_t v33 = v32 & 0xFFFFFFFE;
            }
            if ((_DWORD)v33)
            {
              *(_DWORD *)uint64_t v47 = 67109378;
              *(_DWORD *)&v47[4] = v28;
              *(_WORD *)&v47[8] = 2112;
              *(void *)&v47[10] = v30;
              LODWORD(v46) = 18;
              uint64_t v34 = (const char *)_os_log_send_and_compose_impl( v33,  &v48,  0LL,  0LL,  &_mh_execute_header,  v31,  2LL,  "BundleID for %d was %@",  v47,  v46);
              uint64_t v35 = (char *)v34;
              if (v34) {
                sub_100053B7C(v34);
              }
            }

            else
            {
              uint64_t v35 = 0LL;
            }

            free(v35);
          }

          if (CFArrayGetCount(a2) <= 0)
          {
            if (!v30) {
              goto LABEL_72;
            }
            CFDictionaryRemoveValue(v21, kUMUserPersonaBundleIDsKey);
            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            uint64_t v36 = (os_log_s *)(id)qword_1000DBA98;
            if (!os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_71;
            }
            *(void *)uint64_t v47 = 0LL;
            unsigned int v41 = sub_100053B4C(1);
            if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v42 = v41;
            }
            else {
              uint64_t v42 = v41 & 0xFFFFFFFE;
            }
            if (!(_DWORD)v42)
            {
              uint64_t v40 = 0LL;
              goto LABEL_70;
            }

            LODWORD(v4_Block_object_dispose(va, 8) = 67109120;
            HIDWORD(v4_Block_object_dispose(va, 8) = v28;
            uint64_t v39 = (const char *)_os_log_send_and_compose_impl( v42,  v47,  0LL,  0LL,  &_mh_execute_header,  v36,  0LL,  "BundleIDs for Persona %d removed, saving to disk",  &v48);
            uint64_t v40 = (char *)v39;
            if (v39) {
LABEL_68:
            }
              sub_100053B7C(v39);
LABEL_70:
            free(v40);
LABEL_71:

            goto LABEL_72;
          }
        }

        else
        {
          uint64_t v30 = 0LL;
          if (CFArrayGetCount(a2) < 1)
          {
LABEL_72:
            uint64_t v43 = sub_1000197AC(qword_1000DBA78);
            uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue(v43);
            sub_1000562B8((uint64_t)v44);

            if ((sub_10005B2D0(qword_1000DBA78) & 1) != 0)
            {
              if (!v30) {
                goto LABEL_79;
              }
            }

            else
            {
              if (!v30)
              {
                CFDictionaryRemoveValue(v21, kUMUserPersonaBundleIDsKey);
                goto LABEL_79;
              }

              CFDictionarySetValue(v21, kUMUserPersonaBundleIDsKey, v30);
            }

            CFRelease(v30);
LABEL_79:
            uint64_t v27 = 0LL;
            goto LABEL_80;
          }
        }

        CFDictionarySetValue(v21, kUMUserPersonaBundleIDsKey, a2);
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        uint64_t v36 = (os_log_s *)(id)qword_1000DBA98;
        if (!os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_71;
        }
        uint64_t v48 = 0LL;
        unsigned int v37 = sub_100053B4C(1);
        if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v38 = v37;
        }
        else {
          uint64_t v38 = v37 & 0xFFFFFFFE;
        }
        if (!(_DWORD)v38)
        {
          uint64_t v40 = 0LL;
          goto LABEL_70;
        }

        *(_DWORD *)uint64_t v47 = 67109378;
        *(_DWORD *)&v47[4] = v28;
        *(_WORD *)&v47[8] = 2112;
        *(void *)&v47[10] = a2;
        LODWORD(v46) = 18;
        uint64_t v39 = (const char *)_os_log_send_and_compose_impl( v38,  &v48,  0LL,  0LL,  &_mh_execute_header,  v36,  0LL,  "BundleIDs for Persona %d Set with %@, saving to disk",  v47,  v46);
        uint64_t v40 = (char *)v39;
        if (v39) {
          goto LABEL_68;
        }
        goto LABEL_70;
      }

      uint64_t v27 = 22LL;
LABEL_80:
      CFRelease(v21);
      goto LABEL_81;
    }
  }

  uint64_t v27 = 2LL;
LABEL_81:

  return v27;
}

id sub_100049BF0(void *a1, void *a2, _DWORD *a3)
{
  return sub_10005A2A8((void *)qword_1000DBA78, a1, a2, a3);
}

uint64_t sub_100049C08(const __CFArray *a1, void *a2)
{
  id v3 = a2;
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v4 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    *(void *)uint64_t v44 = 0LL;
    unsigned int v5 = sub_100053B4C(1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG)) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = v5 & 0xFFFFFFFE;
    }
    if ((_DWORD)v6)
    {
      LOWORD(v43[0]) = 0;
      unsigned int v7 = (const char *)_os_log_send_and_compose_impl( v6,  v44,  0LL,  0LL,  &_mh_execute_header,  v4,  2LL,  "Updating Universal BundleIDs",  v43,  2);
      uint64_t v8 = (char *)v7;
      if (v7) {
        sub_100053B7C(v7);
      }
    }

    else
    {
      uint64_t v8 = 0LL;
    }

    free(v8);
  }

  id v9 = sub_1000598D8(qword_1000DBA78, v3);
  unsigned int v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
  if (v10)
  {
    id v11 = v10;
    id v12 = sub_100058BD8((id)qword_1000DBA78, 4u, v10);
    int v13 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue(v12);
    CFRelease(v11);
    if (v13)
    {
      if (!a1)
      {
        uint64_t v24 = 22LL;
        goto LABEL_83;
      }

      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v14 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        v43[0] = 0LL;
        unsigned int v15 = sub_100053B4C(1);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG)) {
          uint64_t v16 = v15;
        }
        else {
          uint64_t v16 = v15 & 0xFFFFFFFE;
        }
        if ((_DWORD)v16)
        {
          *(_DWORD *)uint64_t v44 = 138412290;
          *(void *)&v44[4] = a1;
          LODWORD(v42) = 12;
          uint64_t v17 = (const char *)_os_log_send_and_compose_impl( v16,  v43,  0LL,  0LL,  &_mh_execute_header,  v14,  2LL,  "Updating Universal bundle IDS:%@ ",  v44,  v42);
          uint64_t v18 = (char *)v17;
          if (v17) {
            sub_100053B7C(v17);
          }
        }

        else
        {
          uint64_t v18 = 0LL;
        }

        free(v18);
      }

      if (CFDictionaryContainsKey(v13, kUMUserPersonaBundleIDsKey))
      {
        uint64_t v25 = sub_100083C34(v13, kUMUserPersonaBundleIDsKey);
        unsigned int v26 = v25;
        if (v25) {
          CFRetain(v25);
        }
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        uint64_t v27 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
        {
          v43[0] = 0LL;
          unsigned int v28 = sub_100053B4C(1);
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG)) {
            uint64_t v29 = v28;
          }
          else {
            uint64_t v29 = v28 & 0xFFFFFFFE;
          }
          if ((_DWORD)v29)
          {
            *(_DWORD *)uint64_t v44 = 138412290;
            *(void *)&v44[4] = v26;
            LODWORD(v42) = 12;
            uint64_t v30 = (const char *)_os_log_send_and_compose_impl( v29,  v43,  0LL,  0LL,  &_mh_execute_header,  v27,  2LL,  "Universal BundleID used to be %@",  v44,  v42);
            unsigned int v31 = (char *)v30;
            if (v30) {
              sub_100053B7C(v30);
            }
          }

          else
          {
            unsigned int v31 = 0LL;
          }

          free(v31);
        }

        if (CFArrayGetCount(a1) <= 0)
        {
          if (!v26)
          {
LABEL_78:
            uint64_t v39 = sub_1000197AC(qword_1000DBA78);
            uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(v39);
            sub_1000562B8((uint64_t)v40);

            if ((sub_10005B2D0(qword_1000DBA78) & 1) != 0)
            {
              uint64_t v24 = 0LL;
              if (!v26) {
                goto LABEL_83;
              }
              goto LABEL_82;
            }

            CFDictionarySetValue(v13, kUMUserPersonaBundleIDsKey, v26);
            uint64_t v24 = 12LL;
            if (v26) {
LABEL_82:
            }
              CFRelease(v26);
LABEL_83:
            CFRelease(v13);
            goto LABEL_84;
          }

          CFDictionaryRemoveValue(v13, kUMUserPersonaBundleIDsKey);
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          id v32 = (id)qword_1000DBA98;
          if (!os_log_type_enabled((os_log_t)v32, OS_LOG_TYPE_DEFAULT))
          {
LABEL_77:

            goto LABEL_78;
          }

          *(void *)uint64_t v44 = 0LL;
          unsigned int v37 = sub_100053B4C(1);
          if (os_log_type_enabled((os_log_t)v32, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v38 = v37;
          }
          else {
            uint64_t v38 = v37 & 0xFFFFFFFE;
          }
          if ((_DWORD)v38)
          {
            LOWORD(v43[0]) = 0;
            LODWORD(v42) = 2;
            uint64_t v35 = (const char *)_os_log_send_and_compose_impl( v38,  v44,  0LL,  0LL,  &_mh_execute_header,  v32,  0LL,  "Universal BundleIDs removed, saving to disk",  v43,  v42,  v43[0]);
LABEL_64:
            uint64_t v36 = (char *)v35;
            if (v35) {
              sub_100053B7C(v35);
            }
            goto LABEL_76;
          }

id sub_10004A254(void *a1, _DWORD *a2)
{
  id v3 = a1;
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v4 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v15 = 0LL;
    unsigned int v5 = sub_100053B4C(1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG)) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = v5 & 0xFFFFFFFE;
    }
    if ((_DWORD)v6)
    {
      v14[0] = 0;
      unsigned int v7 = (const char *)_os_log_send_and_compose_impl( v6,  &v15,  0LL,  0LL,  &_mh_execute_header,  v4,  2LL,  "Fetching BundleIDs for Universal Persona",  v14,  2);
      uint64_t v8 = (char *)v7;
      if (v7) {
        sub_100053B7C(v7);
      }
    }

    else
    {
      uint64_t v8 = 0LL;
    }

    free(v8);
  }

  id v9 = (void *)qword_1000DBA78;
  uint64_t v16 = kUMUserPersonaTypeKey;
  uint64_t v17 = &off_1000D1180;
  unsigned int v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v17,  &v16,  1LL));
  id v11 = sub_10005A2A8(v9, v10, v3, a2);
  id v12 = (void *)objc_claimAutoreleasedReturnValue(v11);

  return v12;
}

void *sub_10004A3F0(void *a1, void *a2, int *a3)
{
  id v5 = a1;
  id v6 = sub_1000598D8(qword_1000DBA78, a2);
  unsigned int v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
  if (!v7)
  {
LABEL_7:
    int v11 = 2;
    if (!a3) {
      goto LABEL_15;
    }
    goto LABEL_12;
  }

  id v8 = sub_1000590FC(qword_1000DBA78, v5, v7);
  id v9 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue(v8);
  CFRelease(v7);
  if (!v9)
  {
    unsigned int v7 = 0LL;
    goto LABEL_7;
  }

  if (sub_100083C6C(v9, kUMUserPersonaTypeKey) == 6)
  {
    unsigned int v10 = (void *)sub_100083DF4(v9, kUMUserSessionVolumeDeviceNodeKey);
    unsigned int v7 = v10;
    if (v10)
    {
      CFRetain(v10);
      int v11 = 0;
    }

    else
    {
      int v11 = 3;
    }
  }

  else
  {
    unsigned int v7 = 0LL;
    int v11 = 22;
  }

  CFRelease(v9);
  if (a3)
  {
LABEL_12:
    if (!v7 && v11) {
      *a3 = v11;
    }
  }

LABEL_15:
  return v7;
}

  memset_s(__s, 0x1000uLL, 0, 0x1000uLL);
  return v10;
}

uint64_t sub_10004A4EC(void *a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5)
{
  int v58 = 0;
  id v9 = sub_1000598D8(qword_1000DBA78, a4);
  unsigned int v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
  if (v10
    && (int v11 = v10,
        id v12 = sub_1000590FC(qword_1000DBA78, a1, v10),
        int v13 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue(v12),
        CFRelease(v11),
        v13))
  {
    uint64_t v14 = sub_100083C6C(v13, kUMUserPersonaIDKey);
    if (CFDictionaryContainsKey(v13, kUMUserPersonaDisabledKey)
      && sub_100083DA4(v13, kUMUserPersonaDisabledKey))
    {
      id v15 = 0LL;
      a5 = 36LL;
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      unsigned int v20 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v60 = 0LL;
        unsigned int v21 = sub_100053B4C(1);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG)) {
          uint64_t v22 = v21;
        }
        else {
          uint64_t v22 = v21 & 0xFFFFFFFE;
        }
        if ((_DWORD)v22)
        {
          *(_DWORD *)unsigned int v59 = 67109634;
          *(_DWORD *)&v59[4] = v14;
          *(_WORD *)&v59[8] = 1024;
          *(_DWORD *)&v59[10] = a2;
          *(_WORD *)&v59[14] = 2112;
          *(void *)&v59[16] = a1;
          unsigned int v23 = (const char *)_os_log_send_and_compose_impl( v22,  &v60,  0LL,  0LL,  &_mh_execute_header,  v20,  2LL,  "PersonaId:%d requested from PID:%d with personaString:%@",  v59,  24);
          uint64_t v24 = (char *)v23;
          if (v23) {
            sub_100053B7C(v23);
          }
        }

        else
        {
          uint64_t v24 = 0LL;
        }

        free(v24);
      }

      uint64_t v25 = sub_100018F4C(qword_1000DBD40);
      unsigned int v26 = (void *)objc_claimAutoreleasedReturnValue(v25);
      id v57 = 0LL;
      id v27 = [v26 uniquePIDForPID:a2 error:&v57];
      id v15 = v57;

      if (v27)
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        unsigned int v28 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v60 = 0LL;
          unsigned int v29 = sub_100053B4C(1);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG)) {
            uint64_t v30 = v29;
          }
          else {
            uint64_t v30 = v29 & 0xFFFFFFFE;
          }
          if ((_DWORD)v30)
          {
            *(_DWORD *)unsigned int v59 = 67109632;
            *(_DWORD *)&v59[4] = v14;
            *(_WORD *)&v59[8] = 1024;
            *(_DWORD *)&v59[10] = a3;
            *(_WORD *)&v59[14] = 2048;
            *(void *)&v59[16] = v27;
            unsigned int v31 = (const char *)_os_log_send_and_compose_impl( v30,  &v60,  0LL,  0LL,  &_mh_execute_header,  v28,  2LL,  "Calling mach_voucher_persona_for_originator with personaID:%d sourcePort:%d with uniqpid:%lld",  v59,  24,  v57);
            id v32 = (char *)v31;
            if (v31) {
              sub_100053B7C(v31);
            }
          }

          else
          {
            id v32 = 0LL;
          }

          free(v32);
        }

        int v38 = mach_voucher_persona_for_originator(v14, a3, v27, &v58);
        if (v38)
        {
          int v39 = v38;
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          uint64_t v40 = (os_log_s *)(id)qword_1000DBA98;
          if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
          {
            *(void *)unsigned int v59 = 0LL;
            unsigned int v41 = sub_100053B4C(1);
            if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG)) {
              uint64_t v42 = v41;
            }
            else {
              uint64_t v42 = v41 & 0xFFFFFFFE;
            }
            if ((_DWORD)v42)
            {
              LODWORD(v60) = 67109120;
              HIDWORD(v60) = v39;
              uint64_t v43 = (const char *)_os_log_send_and_compose_impl( v42,  v59,  0LL,  0LL,  &_mh_execute_header,  v40,  2LL,  "mach_voucher_persona_for_originator failed with %d",  &v60);
              uint64_t v44 = (char *)v43;
              if (v43) {
                sub_100053B7C(v43);
              }
            }

            else
            {
              uint64_t v44 = 0LL;
            }

            free(v44);
          }

          a5 = 22LL;
        }

        else
        {
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          id v45 = (os_log_s *)(id)qword_1000DBA98;
          if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
          {
            *(void *)unsigned int v59 = 0LL;
            unsigned int v46 = sub_100053B4C(1);
            if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG)) {
              uint64_t v47 = v46;
            }
            else {
              uint64_t v47 = v46 & 0xFFFFFFFE;
            }
            if ((_DWORD)v47)
            {
              LODWORD(v60) = 67109120;
              HIDWORD(v60) = v58;
              uint64_t v48 = (const char *)_os_log_send_and_compose_impl( v47,  v59,  0LL,  0LL,  &_mh_execute_header,  v45,  2LL,  "mach_voucher_persona_for_originator successful and returnPort:%d",  &v60);
              uint64_t v49 = (char *)v48;
              if (v48) {
                sub_100053B7C(v48);
              }
            }

            else
            {
              uint64_t v49 = 0LL;
            }

            free(v49);
          }

          if (a5)
          {
            *(_DWORD *)a5 = v58;
            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            int v50 = (os_log_s *)(id)qword_1000DBA98;
            if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
            {
              *(void *)unsigned int v59 = 0LL;
              unsigned int v51 = sub_100053B4C(1);
              if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG)) {
                uint64_t v52 = v51;
              }
              else {
                uint64_t v52 = v51 & 0xFFFFFFFE;
              }
              if ((_DWORD)v52)
              {
                LODWORD(v60) = 67109120;
                HIDWORD(v60) = v58;
                id v53 = (const char *)_os_log_send_and_compose_impl( v52,  v59,  0LL,  0LL,  &_mh_execute_header,  v50,  2LL,  "Replacement port is %d",  &v60);
                uint64_t v54 = (char *)v53;
                if (v53) {
                  sub_100053B7C(v53);
                }
              }

              else
              {
                uint64_t v54 = 0LL;
              }

              free(v54);
            }

            a5 = 0LL;
          }
        }
      }

      else
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        unsigned int v33 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v60 = 0LL;
          unsigned int v34 = sub_100053B4C(1);
          if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG)) {
            uint64_t v35 = v34;
          }
          else {
            uint64_t v35 = v34 & 0xFFFFFFFE;
          }
          if ((_DWORD)v35)
          {
            *(_DWORD *)unsigned int v59 = 67109378;
            *(_DWORD *)&v59[4] = a2;
            *(_WORD *)&v59[8] = 2114;
            *(void *)&v59[10] = v15;
            LODWORD(v56) = 18;
            uint64_t v36 = (const char *)_os_log_send_and_compose_impl( v35,  &v60,  0LL,  0LL,  &_mh_execute_header,  v33,  2LL,  "Failed to get unique pid for pid %d: %{public}@",  v59,  v56);
            unsigned int v37 = (char *)v36;
            if (v36) {
              sub_100053B7C(v36);
            }
          }

          else
          {
            unsigned int v37 = 0LL;
          }

          free(v37);
        }

        a5 = (uint64_t)[v15 code];
      }
    }

    CFRelease(v13);
  }

  else
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v15 = (id)qword_1000DBA98;
    a5 = 2LL;
    if (os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v60 = 0LL;
      unsigned int v16 = sub_100053B4C(1);
      if (os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_DEBUG)) {
        uint64_t v17 = v16;
      }
      else {
        uint64_t v17 = v16 & 0xFFFFFFFE;
      }
      if ((_DWORD)v17)
      {
        *(_DWORD *)unsigned int v59 = 138412290;
        *(void *)&v59[4] = a1;
        uint64_t v18 = (const char *)_os_log_send_and_compose_impl( v17,  &v60,  0LL,  0LL,  &_mh_execute_header,  v15,  2LL,  "Cannot find Persona Dict for accountID:%@",  v59,  12);
        unsigned int v19 = (char *)v18;
        if (v18) {
          sub_100053B7C(v18);
        }
      }

      else
      {
        unsigned int v19 = 0LL;
      }

      free(v19);
      a5 = 2LL;
    }
  }

  return a5;
}

uint64_t sub_10004ACA0()
{
  return 45LL;
}

uint64_t sub_10004ACA8(void *a1, int a2)
{
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v4 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v21[0] = 0LL;
    unsigned int v5 = sub_100053B4C(1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = v5 & 0xFFFFFFFE;
    }
    if ((_DWORD)v6)
    {
      *(_DWORD *)uint64_t v22 = 138412546;
      *(void *)&v22[4] = a1;
      __int16 v23 = 1024;
      int v24 = a2;
      unsigned int v7 = (const char *)_os_log_send_and_compose_impl( v6,  v21,  0LL,  0LL,  &_mh_execute_header,  v4,  0LL,  "PERSONA LOGOUT for USER:%@, UID:%d",  v22,  18);
      id v8 = (char *)v7;
      if (v7) {
        sub_100053B7C(v7);
      }
    }

    else
    {
      id v8 = 0LL;
    }

    free(v8);
  }

  if (sub_10006238C(qword_1000DBA78, a1))
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v9 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)uint64_t v22 = 0LL;
      unsigned int v10 = sub_100053B4C(1);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = v10 & 0xFFFFFFFE;
      }
      if ((_DWORD)v11)
      {
        LOWORD(v21[0]) = 0;
        LODWORD(v20) = 2;
        id v12 = (const char *)_os_log_send_and_compose_impl( v11,  v22,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "unLoading All persona Success",  v21,  v20);
        int v13 = (char *)v12;
        if (v12) {
          sub_100053B7C(v12);
        }
      }

      else
      {
        int v13 = 0LL;
      }

      free(v13);
    }

    uint64_t v18 = 0LL;
  }

  else
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v9 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)uint64_t v22 = 0LL;
      unsigned int v14 = sub_100053B4C(1);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v15 = v14;
      }
      else {
        uint64_t v15 = v14 & 0xFFFFFFFE;
      }
      if ((_DWORD)v15)
      {
        LOWORD(v21[0]) = 0;
        LODWORD(v20) = 2;
        unsigned int v16 = (const char *)_os_log_send_and_compose_impl( v15,  v22,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "unLoading All persona failed",  v21,  v20);
        uint64_t v17 = (char *)v16;
        if (v16) {
          sub_100053B7C(v16);
        }
      }

      else
      {
        uint64_t v17 = 0LL;
      }

      free(v17);
    }

    uint64_t v18 = 22LL;
  }

  return v18;
}

uint64_t sub_10004AF9C()
{
  return 0LL;
}

BOOL sub_10004AFA4(const __CFString *a1, void *a2)
{
  id v3 = sub_1000598D8(qword_1000DBA78, a2);
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  if (v4)
  {
    unsigned int v5 = v4;
    id v6 = sub_100058BD8((id)qword_1000DBA78, 0, v4);
    unsigned int v7 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue(v6);
    CFRelease(v5);
    if (v7)
    {
      if (!a1)
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        uint64_t v18 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)uint64_t v54 = 0LL;
          unsigned int v19 = sub_100053B4C(1);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v20 = v19;
          }
          else {
            uint64_t v20 = v19 & 0xFFFFFFFE;
          }
          if ((_DWORD)v20)
          {
            LOWORD(v53[0]) = 0;
            unsigned int v21 = (const char *)_os_log_send_and_compose_impl( v20,  v54,  0LL,  0LL,  &_mh_execute_header,  v18,  0LL,  "null machservice is being registered as observer",  v53,  2);
            uint64_t v22 = (char *)v21;
            if (v21) {
              sub_100053B7C(v21);
            }
          }

          else
          {
            uint64_t v22 = 0LL;
          }

          free(v22);
        }

        int v41 = 0;
        goto LABEL_91;
      }

      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      id v8 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        v53[0] = 0LL;
        unsigned int v9 = sub_100053B4C(1);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
          uint64_t v10 = v9;
        }
        else {
          uint64_t v10 = v9 & 0xFFFFFFFE;
        }
        if ((_DWORD)v10)
        {
          *(_DWORD *)uint64_t v54 = 138412290;
          *(void *)&v54[4] = 0LL;
          uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v10,  v53,  0LL,  0LL,  &_mh_execute_header,  v8,  2LL,  "Updating peronaObserver:%@ ",  v54,  12);
          id v12 = (char *)v11;
          if (v11) {
            sub_100053B7C(v11);
          }
        }

        else
        {
          id v12 = 0LL;
        }

        free(v12);
      }

      if (!CFDictionaryContainsKey(v7, off_1000DAD90)) {
        goto LABEL_56;
      }
      int v24 = sub_100083C34(v7, off_1000DAD90);
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v25 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
      {
        v53[0] = 0LL;
        unsigned int v26 = sub_100053B4C(1);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG)) {
          uint64_t v27 = v26;
        }
        else {
          uint64_t v27 = v26 & 0xFFFFFFFE;
        }
        if ((_DWORD)v27)
        {
          *(_DWORD *)uint64_t v54 = 138412290;
          *(void *)&v54[4] = v24;
          LODWORD(v52) = 12;
          unsigned int v28 = (const char *)_os_log_send_and_compose_impl( v27,  v53,  0LL,  0LL,  &_mh_execute_header,  v25,  2LL,  "Existing Registered machService are %@",  v54,  v52);
          unsigned int v29 = (char *)v28;
          if (v28) {
            sub_100053B7C(v28);
          }
        }

        else
        {
          unsigned int v29 = 0LL;
        }

        free(v29);
      }

      if (v24)
      {
        CFRetain(v24);
        MutableCFArrayRef Copy = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0LL, (CFArrayRef)v24);
        if (CFArrayGetCount(MutableCopy) >= 1)
        {
          CFIndex v31 = 0LL;
          while (1)
          {
            ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, v31);
            if (ValueAtIndex)
            {
              unsigned int v33 = ValueAtIndex;
              CFTypeID v34 = CFGetTypeID(ValueAtIndex);
              if (v34 == CFStringGetTypeID() && CFStringCompare(v33, a1, 0LL) == kCFCompareEqualTo) {
                break;
              }
            }

            if (CFArrayGetCount(MutableCopy) <= ++v31) {
              goto LABEL_55;
            }
          }

          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          uint64_t v47 = (os_log_s *)(id)qword_1000DBA98;
          if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
          {
            v53[0] = 0LL;
            unsigned int v48 = sub_100053B4C(1);
            if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v49 = v48;
            }
            else {
              uint64_t v49 = v48 & 0xFFFFFFFE;
            }
            if ((_DWORD)v49)
            {
              *(_DWORD *)uint64_t v54 = 138412290;
              *(void *)&v54[4] = a1;
              LODWORD(v52) = 12;
              int v50 = (const char *)_os_log_send_and_compose_impl( v49,  v53,  0LL,  0LL,  &_mh_execute_header,  v47,  0LL,  "registerPersonaObserverService: machservice already present: %@",  v54,  v52);
              unsigned int v51 = (char *)v50;
              if (v50) {
                sub_100053B7C(v50);
              }
            }

            else
            {
              unsigned int v51 = 0LL;
            }

            free(v51);
          }

          int v41 = 1;
          goto LABEL_88;
        }

void sub_10004B774(const __CFDictionary *a1)
{
  if (sub_100083C6C(a1, kUMUserPersonaTypeKey) == 6)
  {
    uint64_t v2 = (const __CFString *)sub_100083DF4(a1, kUMUserSessionVolumeDeviceNodeKey);
    if (v2)
    {
      id v3 = v2;
      unsigned int v39 = 0;
      __int128 v56 = 0u;
      __int128 v57 = 0u;
      __int128 v54 = 0u;
      __int128 v55 = 0u;
      __int128 v52 = 0u;
      __int128 v53 = 0u;
      __int128 v50 = 0u;
      __int128 v51 = 0u;
      __int128 v48 = 0u;
      __int128 v49 = 0u;
      __int128 v46 = 0u;
      __int128 v47 = 0u;
      __int128 v44 = 0u;
      __int128 v45 = 0u;
      *(_OWORD *)buffer = 0u;
      __int128 v43 = 0u;
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      uint64_t v4 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v38 = 0LL;
        unsigned int v5 = sub_100053B4C(1);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v6 = v5;
        }
        else {
          uint64_t v6 = v5 & 0xFFFFFFFE;
        }
        if ((_DWORD)v6)
        {
          int v40 = 138412290;
          int v41 = (char *)v3;
          unsigned int v7 = (const char *)_os_log_send_and_compose_impl( v6,  &v38,  0LL,  0LL,  &_mh_execute_header,  v4,  0LL,  "found Guest disk Volume:%@",  &v40,  12);
          id v8 = (char *)v7;
          if (v7) {
            sub_100053B7C(v7);
          }
        }

        else
        {
          id v8 = 0LL;
        }

        free(v8);
      }

      if (!CFStringGetCString(v3, buffer, 256LL, 0x8000100u))
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        unsigned int v19 = (os_log_s *)(id)qword_1000DBA98;
        if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_80;
        }
        uint64_t v38 = 0LL;
        unsigned int v20 = sub_100053B4C(1);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v21 = v20;
        }
        else {
          uint64_t v21 = v20 & 0xFFFFFFFE;
        }
        if ((_DWORD)v21)
        {
          int v40 = 138412290;
          int v41 = (char *)v3;
          LODWORD(v37) = 12;
          uint64_t v22 = (const char *)_os_log_send_and_compose_impl( v21,  &v38,  0LL,  0LL,  &_mh_execute_header,  v19,  0LL,  "Could not convert diskString:%@ to ascii, erroring out",  &v40,  v37);
          goto LABEL_76;
        }

LABEL_78:
        int v35 = 0LL;
LABEL_79:
        free(v35);
LABEL_80:

        return;
      }

      if ([(id)qword_1000DBA68 unmountVolumeWithSession:a1 mountPath:0 error:&v39])
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        unsigned int v14 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v38 = 0LL;
          unsigned int v15 = sub_100053B4C(1);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v16 = v15;
          }
          else {
            uint64_t v16 = v15 & 0xFFFFFFFE;
          }
          if ((_DWORD)v16)
          {
            int v40 = 138412290;
            int v41 = (char *)v3;
            LODWORD(v37) = 12;
            uint64_t v17 = (const char *)_os_log_send_and_compose_impl( v16,  &v38,  0LL,  0LL,  &_mh_execute_header,  v14,  0LL,  "Unmounted the guest volume with disk: %@",  &v40,  v37);
            uint64_t v18 = (char *)v17;
            if (v17) {
              sub_100053B7C(v17);
            }
          }

          else
          {
            uint64_t v18 = 0LL;
          }

          free(v18);
        }

        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        __int16 v23 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v38 = 0LL;
          unsigned int v24 = sub_100053B4C(1);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v25 = v24;
          }
          else {
            uint64_t v25 = v24 & 0xFFFFFFFE;
          }
          if ((_DWORD)v25)
          {
            int v40 = 136315138;
            int v41 = buffer;
            unsigned int v26 = (const char *)_os_log_send_and_compose_impl( v25,  &v38,  0LL,  0LL,  &_mh_execute_header,  v23,  0LL,  "Calling Volume Migration for diskNode %s",  (const char *)&v40);
            uint64_t v27 = (char *)v26;
            if (v26) {
              sub_100053B7C(v26);
            }
          }

          else
          {
            uint64_t v27 = 0LL;
          }

          free(v27);
        }

        unsigned int v39 = 0;
        if (sub_100023A8C((uint64_t)buffer))
        {
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          unsigned int v28 = (os_log_s *)(id)qword_1000DBA98;
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v38 = 0LL;
            unsigned int v29 = sub_100053B4C(1);
            if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v30 = v29;
            }
            else {
              uint64_t v30 = v29 & 0xFFFFFFFE;
            }
            if ((_DWORD)v30)
            {
              int v40 = 138412290;
              int v41 = (char *)v3;
              LODWORD(v37) = 12;
              CFIndex v31 = (const char *)_os_log_send_and_compose_impl( v30,  &v38,  0LL,  0LL,  &_mh_execute_header,  v28,  0LL,  "Volume Migration for disk:%@ Successful",  &v40,  v37);
              id v32 = (char *)v31;
              if (v31) {
                sub_100053B7C(v31);
              }
            }

            else
            {
              id v32 = 0LL;
            }

            free(v32);
          }

          unsigned int v39 = 0;
          if ([(id)qword_1000DBA68 mountVolumeWithSession:a1 mountPath:0 error:&v39 forPersona:1])
          {
            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            unsigned int v19 = (os_log_s *)(id)qword_1000DBA98;
            if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_80;
            }
            uint64_t v38 = 0LL;
            unsigned int v33 = sub_100053B4C(1);
            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v34 = v33;
            }
            else {
              uint64_t v34 = v33 & 0xFFFFFFFE;
            }
            if ((_DWORD)v34)
            {
              int v40 = 138412290;
              int v41 = (char *)v3;
              LODWORD(v37) = 12;
              uint64_t v22 = (const char *)_os_log_send_and_compose_impl( v34,  &v38,  0LL,  0LL,  &_mh_execute_header,  v19,  0LL,  "Mounted the guest volume after volume migration with disk: %@",  &v40,  v37);
LABEL_76:
              int v35 = (char *)v22;
              if (v22) {
                sub_100053B7C(v22);
              }
              goto LABEL_79;
            }

            goto LABEL_78;
          }

          goto LABEL_87;
        }
      }

      else
      {
        sub_100019F7C("FAILED to unmount tvOS Guest volume for volume migration with error:%d", v39);
      }

      sub_100019F7C("Volume Migration for disk:%@ failed with %d", v3, v39, v38);
LABEL_87:
      uint64_t v36 = sub_100019F7C("FAILED to MOUNT tvOS Guest volume after volume migration with error:%d", v39);
      sub_10004BE70(v36);
      return;
    }

    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    unsigned int v9 = (os_log_s *)(id)qword_1000DBA98;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)buffer = 0LL;
      unsigned int v10 = sub_100053B4C(1);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = v10 & 0xFFFFFFFE;
      }
      if ((_DWORD)v11)
      {
        LOWORD(v40) = 0;
        id v12 = (const char *)_os_log_send_and_compose_impl( v11,  buffer,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "Failed to find disknode on Guest persona!!",  &v40,  2);
        int v13 = (char *)v12;
        if (v12) {
          sub_100053B7C(v12);
        }
      }

      else
      {
        int v13 = 0LL;
      }

      free(v13);
    }
  }

CFStringRef sub_10004BE70(void *a1, _OWORD *a2, int a3, void *a4)
{
  id v7 = a4;
  id v8 = objc_autoreleasePoolPush();
  id v9 = a1;
  if (v9)
  {
    uint64_t v10 = objc_opt_class(&OBJC_CLASS___NSString);
    if ((objc_opt_isKindOfClass(v9, v10) & 1) != 0)
    {
      id v11 = sub_1000598D8(qword_1000DBA78, v7);
      id v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
      if (!v12)
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        unsigned int v29 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v70 = 0LL;
          unsigned int v30 = sub_100053B4C(1);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v31 = v30;
          }
          else {
            uint64_t v31 = v30 & 0xFFFFFFFE;
          }
          if ((_DWORD)v31)
          {
            *(_DWORD *)uint64_t v69 = 138412546;
            *(void *)&v69[4] = v9;
            *(_WORD *)&v69[12] = 1024;
            *(_DWORD *)&v69[14] = a3;
            id v32 = (const char *)_os_log_send_and_compose_impl( v31,  &v70,  0LL,  0LL,  &_mh_execute_header,  v29,  0LL,  "Error granting sandbox extension for %@ to pid %d: Unable to look up get array for user session",  v69,  18);
            unsigned int v33 = (char *)v32;
            if (v32) {
              sub_100053B7C(v32);
            }
          }

          else
          {
            unsigned int v33 = 0LL;
          }

          free(v33);
        }

        CFStringRef v44 = 0LL;
        *__error() = 2;
        int v45 = 1;
        goto LABEL_79;
      }

      id v13 = sub_1000590FC(qword_1000DBA78, v9, v12);
      unsigned int v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
      unsigned int v15 = v14;
      if (!v14)
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        unsigned int v39 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v70 = 0LL;
          unsigned int v40 = sub_100053B4C(1);
          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v41 = v40;
          }
          else {
            uint64_t v41 = v40 & 0xFFFFFFFE;
          }
          if ((_DWORD)v41)
          {
            *(_DWORD *)uint64_t v69 = 138412546;
            *(void *)&v69[4] = v9;
            *(_WORD *)&v69[12] = 1024;
            *(_DWORD *)&v69[14] = a3;
            uint64_t v42 = (const char *)_os_log_send_and_compose_impl( v41,  &v70,  0LL,  0LL,  &_mh_execute_header,  v39,  0LL,  "Error granting sandbox extension for %@ to pid %d: No persona session found",  v69,  18);
            __int128 v43 = (char *)v42;
            if (v42) {
              sub_100053B7C(v42);
            }
          }

          else
          {
            __int128 v43 = 0LL;
          }

          free(v43);
        }

        CFStringRef v44 = 0LL;
        *__error() = 2;
        int v45 = 1;
        goto LABEL_78;
      }

      uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v14 objectForKeyedSubscript:kUMUserSessionHomeDirKey]);
      if (v16 && (uint64_t v17 = objc_opt_class(&OBJC_CLASS___NSString), (objc_opt_isKindOfClass(v16, v17) & 1) != 0))
      {
        if (&_sandbox_extension_issue_file_to_process)
        {
          id v46 = [v16 UTF8String];
          __int128 v47 = a2[1];
          *(_OWORD *)uint64_t v69 = *a2;
          *(_OWORD *)&v69[16] = v47;
          __int128 v48 = (const char *)sandbox_extension_issue_file_to_process( "com.apple.usermanagement.persona-volume",  v46,  0LL,  v69);
          if (v48)
          {
            __int128 v49 = (char *)v48;
            CFStringRef v50 = CFStringCreateWithCStringNoCopy(kCFAllocatorDefault, v48, 0x8000100u, kCFAllocatorDefault);
            if (v50)
            {
              CFStringRef v44 = v50;
              if (qword_1000DBAA0 != -1) {
                dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
              }
              __int128 v51 = (os_log_s *)(id)qword_1000DBA98;
              if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v70 = 0LL;
                unsigned int v52 = sub_100053B4C(1);
                if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT)) {
                  uint64_t v53 = v52;
                }
                else {
                  uint64_t v53 = v52 & 0xFFFFFFFE;
                }
                if ((_DWORD)v53)
                {
                  *(_DWORD *)uint64_t v69 = 138412546;
                  *(void *)&v69[4] = v9;
                  *(_WORD *)&v69[12] = 1024;
                  *(_DWORD *)&v69[14] = a3;
                  __int128 v54 = (const char *)_os_log_send_and_compose_impl( v53,  &v70,  0LL,  0LL,  &_mh_execute_header,  v51,  0LL,  "Granted sandbox extension for %@ to pid %d",  v69,  18);
                  __int128 v55 = (char *)v54;
                  if (v54) {
                    sub_100053B7C(v54);
                  }
                }

                else
                {
                  __int128 v55 = 0LL;
                }

                free(v55);
              }

              int v45 = 0;
              goto LABEL_74;
            }

            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            uint64_t v64 = (os_log_s *)(id)qword_1000DBA98;
            if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v70 = 0LL;
              unsigned int v65 = sub_100053B4C(1);
              if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v66 = v65;
              }
              else {
                uint64_t v66 = v65 & 0xFFFFFFFE;
              }
              if ((_DWORD)v66)
              {
                *(_DWORD *)uint64_t v69 = 138412546;
                *(void *)&v69[4] = v9;
                *(_WORD *)&v69[12] = 1024;
                *(_DWORD *)&v69[14] = a3;
                unsigned int v67 = (const char *)_os_log_send_and_compose_impl( v66,  &v70,  0LL,  0LL,  &_mh_execute_header,  v64,  0LL,  "Error granting sandbox extension for %@ to pid %d: Failed to create CFString wrapper around token",  v69,  18);
                uint64_t v68 = (char *)v67;
                if (v67) {
                  sub_100053B7C(v67);
                }
              }

              else
              {
                uint64_t v68 = 0LL;
              }

              free(v68);
            }

            free(v49);
            __int128 v56 = __error();
            CFStringRef v44 = 0LL;
            int v57 = 12;
          }

          else
          {
            if (qword_1000DBAA0 != -1) {
              dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
            }
            unsigned int v59 = (os_log_s *)(id)qword_1000DBA98;
            if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v70 = 0LL;
              unsigned int v60 = sub_100053B4C(1);
              if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v61 = v60;
              }
              else {
                uint64_t v61 = v60 & 0xFFFFFFFE;
              }
              if ((_DWORD)v61)
              {
                *(_DWORD *)uint64_t v69 = 138412546;
                *(void *)&v69[4] = v9;
                *(_WORD *)&v69[12] = 1024;
                *(_DWORD *)&v69[14] = a3;
                uint64_t v62 = (const char *)_os_log_send_and_compose_impl( v61,  &v70,  0LL,  0LL,  &_mh_execute_header,  v59,  0LL,  "Error granting sandbox extension for %@ to pid %d: Failed to grant sandbox extension to process",  v69,  18);
                unsigned int v63 = (char *)v62;
                if (v62) {
                  sub_100053B7C(v62);
                }
              }

              else
              {
                unsigned int v63 = 0LL;
              }

              free(v63);
            }

            __int128 v56 = __error();
            CFStringRef v44 = 0LL;
            int v57 = 9;
          }
        }

        else
        {
          if (qword_1000DBAA0 != -1) {
            dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
          }
          uint64_t v18 = (os_log_s *)(id)qword_1000DBA98;
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v70 = 0LL;
            unsigned int v19 = sub_100053B4C(1);
            if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v20 = v19;
            }
            else {
              uint64_t v20 = v19 & 0xFFFFFFFE;
            }
            if ((_DWORD)v20)
            {
              *(_DWORD *)uint64_t v69 = 138412546;
              *(void *)&v69[4] = v9;
              *(_WORD *)&v69[12] = 1024;
              *(_DWORD *)&v69[14] = a3;
              uint64_t v21 = (const char *)_os_log_send_and_compose_impl( v20,  &v70,  0LL,  0LL,  &_mh_execute_header,  v18,  0LL,  "Error granting sandbox extension for %@ to pid %d: Failed to dlsym sandbox extension function",  v69,  18);
              uint64_t v22 = (char *)v21;
              if (v21) {
                sub_100053B7C(v21);
              }
            }

            else
            {
              uint64_t v22 = 0LL;
            }

            free(v22);
          }

          __int128 v56 = __error();
          CFStringRef v44 = 0LL;
          int v57 = 5;
        }
      }

      else
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        uint64_t v34 = (os_log_s *)(id)qword_1000DBA98;
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v70 = 0LL;
          unsigned int v35 = sub_100053B4C(1);
          if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v36 = v35;
          }
          else {
            uint64_t v36 = v35 & 0xFFFFFFFE;
          }
          if ((_DWORD)v36)
          {
            *(_DWORD *)uint64_t v69 = 138412546;
            *(void *)&v69[4] = v9;
            *(_WORD *)&v69[12] = 1024;
            *(_DWORD *)&v69[14] = a3;
            uint64_t v37 = (const char *)_os_log_send_and_compose_impl( v36,  &v70,  0LL,  0LL,  &_mh_execute_header,  v34,  0LL,  "Error granting sandbox extension for %@ to pid %d: No volume path found for persona",  v69,  18);
            uint64_t v38 = (char *)v37;
            if (v37) {
              sub_100053B7C(v37);
            }
          }

          else
          {
            uint64_t v38 = 0LL;
          }

          free(v38);
        }

        __int128 v56 = __error();
        CFStringRef v44 = 0LL;
        int v57 = 2;
      }

      *__int128 v56 = v57;
      int v45 = 1;
LABEL_74:

LABEL_78:
LABEL_79:

      objc_autoreleasePoolPop(v8);
      if (v45) {
        CFStringRef v28 = 0LL;
      }
      else {
        CFStringRef v28 = v44;
      }
      goto LABEL_82;
    }
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  __int16 v23 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t v69 = 0LL;
    unsigned int v24 = sub_100053B4C(1);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v25 = v24;
    }
    else {
      uint64_t v25 = v24 & 0xFFFFFFFE;
    }
    if ((_DWORD)v25)
    {
      LODWORD(v70) = 67109120;
      HIDWORD(v70) = a3;
      unsigned int v26 = (const char *)_os_log_send_and_compose_impl( v25,  v69,  0LL,  0LL,  &_mh_execute_header,  v23,  0LL,  "Error granting sandbox extension to pid %d: Persona Unique String not provided",  &v70);
      uint64_t v27 = (char *)v26;
      if (v26) {
        sub_100053B7C(v26);
      }
    }

    else
    {
      uint64_t v27 = 0LL;
    }

    free(v27);
  }

  *__error() = 22;
  objc_autoreleasePoolPop(v8);
  CFStringRef v28 = 0LL;
LABEL_82:

  return v28;
}

void sub_10004C7F0(id a1)
{
  os_log_t v1 = os_log_create(off_1000DAE70, "legacy");
  uint64_t v2 = (void *)qword_1000DBA98;
  qword_1000DBA98 = (uint64_t)v1;
}

void sub_10004C824(id a1)
{
  os_log_t v1 = os_log_create(off_1000DAE70, "user");
  uint64_t v2 = (void *)qword_1000DBAA8;
  qword_1000DBAA8 = (uint64_t)v1;
}

uint64_t sub_10004C858(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int a5)
{
  if (&_sandbox_user_state_item_buffer_destroy) {
    BOOL v5 = &_sandbox_user_state_item_buffer_send == 0LL;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5 && &_sandbox_set_user_state_item != 0LL && &_sandbox_user_state_item_buffer_create != 0LL)
  {
    uint64_t v18 = sandbox_user_state_item_buffer_create();
    if (a5)
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      unsigned int v19 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v44 = 0LL;
        unsigned int v20 = sub_100053B4C(1);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v21 = v20;
        }
        else {
          uint64_t v21 = v20 & 0xFFFFFFFE;
        }
        if ((_DWORD)v21)
        {
          LODWORD(v47) = 67109120;
          HIDWORD(v47) = a1;
          uint64_t v22 = (const char *)_os_log_send_and_compose_impl( v21,  &v44,  0LL,  0LL,  &_mh_execute_header,  v19,  0LL,  "removing User:%d home, tmpdir SandBox state update",  &v47);
          __int16 v23 = (char *)v22;
          if (v22) {
            sub_100053B7C(v22);
          }
        }

        else
        {
          __int16 v23 = 0LL;
        }

        free(v23);
      }

      sandbox_set_user_state_item(a1, 16LL, 0LL, v18);
      int v30 = sandbox_user_state_item_buffer_send(v18);
      if (v30)
      {
        int v31 = v30;
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        id v32 = (os_log_s *)(id)qword_1000DBA98;
        if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_70;
        }
        uint64_t v47 = 0LL;
        LODWORD(v33) = sub_100053B4C(1);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v33 = v33;
        }
        else {
          uint64_t v33 = v33 & 0xFFFFFFFE;
        }
        if ((_DWORD)v33)
        {
          uint64_t v34 = v32;
          int v35 = *__error();
          LODWORD(v44) = 67109376;
          HIDWORD(v44) = v31;
          __int16 v45 = 1024;
          int v46 = v35;
          uint64_t v36 = _os_log_send_and_compose_impl( v33,  &v47,  0LL,  0LL,  &_mh_execute_header,  v34,  0LL,  "sandbox_user_state_item_buffer_send() fails: %d (errno: %d)",  &v44);
          goto LABEL_65;
        }

        goto LABEL_68;
      }
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      unsigned int v24 = (os_log_s *)(id)qword_1000DBA98;
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v44 = 0LL;
        unsigned int v25 = sub_100053B4C(1);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v26 = v25;
        }
        else {
          uint64_t v26 = v25 & 0xFFFFFFFE;
        }
        if ((_DWORD)v26)
        {
          LODWORD(v47) = 67109120;
          HIDWORD(v47) = a1;
          uint64_t v27 = (const char *)_os_log_send_and_compose_impl( v26,  &v44,  0LL,  0LL,  &_mh_execute_header,  v24,  0LL,  "Adding User:%d home, tmpdir SandBox state update",  &v47);
          CFStringRef v28 = (char *)v27;
          if (v27) {
            sub_100053B7C(v27);
          }
        }

        else
        {
          CFStringRef v28 = 0LL;
        }

        free(v28);
      }

      LODWORD(v43[0]) = a2;
      sandbox_set_user_state_item(a1, 17LL, v43, v18);
      v43[0] = a3;
      sandbox_set_user_state_item(a1, 18LL, v43, v18);
      v43[0] = a4;
      sandbox_set_user_state_item(a1, 19LL, v43, v18);
      sandbox_set_user_state_item(a1, 20LL, 0LL, v18);
      int v37 = sandbox_user_state_item_buffer_send(v18);
      if (v37)
      {
        int v38 = v37;
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        id v32 = (os_log_s *)(id)qword_1000DBA98;
        if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_70;
        }
        uint64_t v47 = 0LL;
        LODWORD(v39) = sub_100053B4C(1);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v39 = v39;
        }
        else {
          uint64_t v39 = v39 & 0xFFFFFFFE;
        }
        if ((_DWORD)v39)
        {
          uint64_t v34 = v32;
          int v40 = *__error();
          LODWORD(v44) = 67109376;
          HIDWORD(v44) = v38;
          __int16 v45 = 1024;
          int v46 = v40;
          uint64_t v36 = _os_log_send_and_compose_impl( v39,  &v47,  0LL,  0LL,  &_mh_execute_header,  v34,  0LL,  "sandbox_user_state_item_buffer_send() fails: %d (errno: %d)\n",  &v44);
LABEL_65:
          uint64_t v41 = (char *)v36;

          if (v41) {
            sub_100053B7C(v41);
          }
          goto LABEL_69;
        }

LABEL_68:
        uint64_t v41 = 0LL;
LABEL_69:
        free(v41);
LABEL_70:

        uint64_t v29 = 0LL;
        goto LABEL_71;
      }
    }

    uint64_t v29 = 1LL;
LABEL_71:
    sandbox_user_state_item_buffer_destroy(v18);
    return v29;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v8 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v44 = 0LL;
    unsigned int v9 = sub_100053B4C(1);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = v9 & 0xFFFFFFFE;
    }
    if ((_DWORD)v10)
    {
      LOWORD(v47) = 0;
      id v11 = (const char *)_os_log_send_and_compose_impl( v10,  &v44,  0LL,  0LL,  &_mh_execute_header,  v8,  0LL,  "UNABLE to resolve Sandbox symbols",  &v47,  2);
      id v12 = (char *)v11;
      if (v11) {
        sub_100053B7C(v11);
      }
    }

    else
    {
      id v12 = 0LL;
    }

    free(v12);
  }

  return 0LL;
}

      *a3 = v9;
      uint64_t result = Util_isNullOrZeroMemory(v9, 16LL);
      if ((_DWORD)result)
      {
        uint64_t result = 0LL;
        *a4 = 0LL;
        *a3 = 0LL;
        return result;
      }

void sub_10004CDF8(int32x2_t *a1)
{
  if (qword_1000DBAB0 != -1) {
    dispatch_once(&qword_1000DBAB0, &stru_1000CD548);
  }
  uint64_t v2 = (os_log_s *)(id)qword_1000DBAA8;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v37 = 0LL;
    unsigned int v3 = sub_100053B4C(0);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      __int32 v5 = a1[4].i32[0];
      __int32 v6 = a1[4].i32[1];
      LODWORD(v34) = 67109376;
      HIDWORD(v34) = v5;
      __int16 v35 = 1024;
      __int32 v36 = v6;
      id v7 = (const char *)_os_log_send_and_compose_impl( v4,  &v37,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "Performing foreground user switch %d -> %d...",  &v34,  14);
      id v8 = (char *)v7;
      if (v7) {
        sub_100053B7C(v7);
      }
    }

    else
    {
      id v8 = 0LL;
    }

    free(v8);
  }

  unsigned int v9 = (void *)os_transaction_create("usermanagerd user switch");
  if (qword_1000DBAB0 != -1) {
    dispatch_once(&qword_1000DBAB0, &stru_1000CD548);
  }
  uint64_t v10 = (os_log_s *)(id)qword_1000DBAA8;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v34 = 0LL;
    unsigned int v11 = sub_100053B4C(0);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v12 = v11;
    }
    else {
      uint64_t v12 = v11 & 0xFFFFFFFE;
    }
    if ((_DWORD)v12)
    {
      __int32 v13 = a1[4].i32[0];
      LODWORD(v37) = 67109120;
      HIDWORD(v37) = v13;
      unsigned int v14 = (const char *)_os_log_send_and_compose_impl( v12,  &v34,  0LL,  0LL,  &_mh_execute_header,  v10,  0LL,  "Stopping user session for %d...",  &v37);
      unsigned int v15 = (char *)v14;
      if (v14) {
        sub_100053B7C(v14);
      }
    }

    else
    {
      unsigned int v15 = 0LL;
    }

    free(v15);
  }

  int active = launch_active_user_logout(a1[4].u32[0]);
  if (active)
  {
    __int32 v23 = active;
    if (qword_1000DBAB0 != -1) {
      dispatch_once(&qword_1000DBAB0, &stru_1000CD548);
    }
    unsigned int v24 = (os_log_s *)(id)qword_1000DBAA8;
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      uint64_t v37 = 0LL;
      unsigned int v25 = sub_100053B4C(0);
      BOOL v26 = os_log_type_enabled(v24, OS_LOG_TYPE_ERROR);
      uint64_t v27 = 0LL;
      if (v26) {
        uint64_t v28 = v25;
      }
      else {
        uint64_t v28 = v25 & 0xFFFFFFFE;
      }
      if ((_DWORD)v28)
      {
        __int32 v29 = a1[4].i32[0];
        LODWORD(v34) = 67109376;
        HIDWORD(v34) = v29;
        __int16 v35 = 1024;
        __int32 v36 = v23;
        LODWORD(v32) = 14;
        int v30 = (const char *)_os_log_send_and_compose_impl( v28,  &v37,  0LL,  0LL,  &_mh_execute_header,  v24,  16LL,  "launch_active_user_logout(%d) failed: %{darwin.errno}d",  &v34,  v32);
        uint64_t v27 = 0LL;
        if (v30)
        {
          int v31 = v30;
          sub_100053B7C(v30);
          uint64_t v27 = (char *)v31;
        }
      }

      free(v27);
    }

    sub_100019F7C("UserManagement user switch failed: launch_active_user_logout(%d) failed: %d", a1[4].i32[0], v23);
  }

  if (qword_1000DBAB0 != -1) {
    dispatch_once(&qword_1000DBAB0, &stru_1000CD548);
  }
  uint64_t v17 = (os_log_s *)(id)qword_1000DBAA8;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v34 = 0LL;
    unsigned int v18 = sub_100053B4C(0);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v19 = v18;
    }
    else {
      uint64_t v19 = v18 & 0xFFFFFFFE;
    }
    if ((_DWORD)v19)
    {
      __int32 v20 = a1[4].i32[0];
      LODWORD(v37) = 67109120;
      HIDWORD(v37) = v20;
      uint64_t v21 = (const char *)_os_log_send_and_compose_impl( v19,  &v34,  0LL,  0LL,  &_mh_execute_header,  v17,  0LL,  "Stopped user session for %d.",  &v37);
      uint64_t v22 = (char *)v21;
      if (v21) {
        sub_100053B7C(v21);
      }
    }

    else
    {
      uint64_t v22 = 0LL;
    }

    free(v22);
  }

  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_10004D258;
  block[3] = &unk_1000CCDB8;
  block[4] = vrev64_s32(a1[4]);
  dispatch_sync((dispatch_queue_t)qword_1000DBD48, block);
}

void sub_10004D258(unsigned int *a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(+[RDServer sharedServer](&OBJC_CLASS___RDServer, "sharedServer"));
  [v2 resetStateForUserSwitch];

  if (qword_1000DBD30)
  {
    if (qword_1000DBAB0 != -1) {
      dispatch_once(&qword_1000DBAB0, &stru_1000CD548);
    }
    unsigned int v3 = (os_log_s *)(id)qword_1000DBAA8;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v50 = 0LL;
      unsigned int v4 = sub_100053B4C(0);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v5 = v4;
      }
      else {
        uint64_t v5 = v4 & 0xFFFFFFFE;
      }
      if ((_DWORD)v5)
      {
        *(_DWORD *)__int128 v49 = 134217984;
        *(void *)&v49[4] = qword_1000DBD30;
        __int32 v6 = (const char *)_os_log_send_and_compose_impl( v5,  &v50,  0LL,  0LL,  &_mh_execute_header,  v3,  0LL,  "Canceling sync bubble timer (%p)",  v49);
        id v7 = (char *)v6;
        if (v6) {
          sub_100053B7C(v6);
        }
      }

      else
      {
        id v7 = 0LL;
      }

      free(v7);
    }

    dispatch_source_cancel((dispatch_source_t)qword_1000DBD30);
    id v8 = (void *)qword_1000DBD30;
    qword_1000DBD30 = 0LL;
  }

  if (!sub_10004535C(a1[8], a1[9]))
  {
    if (qword_1000DBAB0 != -1) {
      dispatch_once(&qword_1000DBAB0, &stru_1000CD548);
    }
    a1 = (unsigned int *)(id)qword_1000DBAA8;
    if (os_log_type_enabled((os_log_t)a1, OS_LOG_TYPE_ERROR))
    {
      *(void *)__int128 v49 = 0LL;
      unsigned int v33 = sub_100053B4C(0);
      BOOL v34 = os_log_type_enabled((os_log_t)a1, OS_LOG_TYPE_ERROR);
      __int16 v35 = 0LL;
      if (v34) {
        uint64_t v36 = v33;
      }
      else {
        uint64_t v36 = v33 & 0xFFFFFFFE;
      }
      if ((_DWORD)v36)
      {
        LOWORD(v50) = 0;
        uint64_t v37 = (const char *)_os_log_send_and_compose_impl( v36,  v49,  0LL,  0LL,  &_mh_execute_header,  a1,  16LL,  "Failed to switch foreground user!",  &v50,  2);
        __int16 v35 = 0LL;
        if (v37)
        {
          int v38 = v37;
          sub_100053B7C(v37);
          __int16 v35 = (char *)v38;
        }
      }

      free(v35);
    }

    int active = sub_100019F7C("UserManagement user switch failed: failed to switch foreground user");
LABEL_63:
    int v39 = active;
    if (v16 != -1) {
      dispatch_once(&qword_1000DBAB0, &stru_1000CD548);
    }
    int v40 = (os_log_s *)(id)qword_1000DBAA8;
    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
    {
      uint64_t v50 = 0LL;
      unsigned int v41 = sub_100053B4C(0);
      BOOL v42 = os_log_type_enabled(v40, OS_LOG_TYPE_ERROR);
      __int128 v43 = 0LL;
      if (v42) {
        uint64_t v44 = v41;
      }
      else {
        uint64_t v44 = v41 & 0xFFFFFFFE;
      }
      if ((_DWORD)v44)
      {
        unsigned int v45 = a1[8];
        *(_DWORD *)__int128 v49 = 67109376;
        *(_DWORD *)&v49[4] = v45;
        *(_WORD *)&v49[8] = 1024;
        *(_DWORD *)&_BYTE v49[10] = v39;
        LODWORD(v4_Block_object_dispose(va, 8) = 14;
        int v46 = (const char *)_os_log_send_and_compose_impl( v44,  &v50,  0LL,  0LL,  &_mh_execute_header,  v40,  16LL,  "launch_active_user_login(%d) failed: %{darwin.errno}d",  v49,  v48);
        __int128 v43 = 0LL;
        if (v46)
        {
          uint64_t v47 = v46;
          sub_100053B7C(v46);
          __int128 v43 = (char *)v47;
        }
      }

      free(v43);
    }

    sub_100019F7C("UserManagement user switch failed: launch_active_user_login(%d) failed: %d", a1[8], v39);
  }

  if (qword_1000DBAB0 != -1) {
    dispatch_once(&qword_1000DBAB0, &stru_1000CD548);
  }
  unsigned int v9 = (os_log_s *)(id)qword_1000DBAA8;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)__int128 v49 = 0LL;
    unsigned int v10 = sub_100053B4C(0);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v11 = v10;
    }
    else {
      uint64_t v11 = v10 & 0xFFFFFFFE;
    }
    if ((_DWORD)v11)
    {
      unsigned int v12 = a1[8];
      LODWORD(v50) = 67109120;
      HIDWORD(v50) = v12;
      __int32 v13 = (const char *)_os_log_send_and_compose_impl( v11,  v49,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "Starting user session for %d...",  &v50);
      unsigned int v14 = (char *)v13;
      if (v13) {
        sub_100053B7C(v13);
      }
    }

    else
    {
      unsigned int v14 = 0LL;
    }

    free(v14);
  }

  int active = launch_active_user_login(a1[8]);
  uint64_t v16 = qword_1000DBAB0;
  if (active) {
    goto LABEL_63;
  }
  if (qword_1000DBAB0 != -1) {
    dispatch_once(&qword_1000DBAB0, &stru_1000CD548);
  }
  uint64_t v17 = (os_log_s *)(id)qword_1000DBAA8;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)__int128 v49 = 0LL;
    unsigned int v18 = sub_100053B4C(0);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v19 = v18;
    }
    else {
      uint64_t v19 = v18 & 0xFFFFFFFE;
    }
    if ((_DWORD)v19)
    {
      unsigned int v20 = a1[8];
      LODWORD(v50) = 67109120;
      HIDWORD(v50) = v20;
      uint64_t v21 = (const char *)_os_log_send_and_compose_impl( v19,  v49,  0LL,  0LL,  &_mh_execute_header,  v17,  0LL,  "Started user session for %d.",  &v50);
      uint64_t v22 = (char *)v21;
      if (v21) {
        sub_100053B7C(v21);
      }
    }

    else
    {
      uint64_t v22 = 0LL;
    }

    free(v22);
  }

  if (qword_1000DBAB0 != -1) {
    dispatch_once(&qword_1000DBAB0, &stru_1000CD548);
  }
  __int32 v23 = (os_log_s *)(id)qword_1000DBAA8;
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v50 = 0LL;
    unsigned int v24 = sub_100053B4C(0);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v25 = v24;
    }
    else {
      uint64_t v25 = v24 & 0xFFFFFFFE;
    }
    if ((_DWORD)v25)
    {
      unsigned int v27 = a1[8];
      unsigned int v26 = a1[9];
      *(_DWORD *)__int128 v49 = 67109376;
      *(_DWORD *)&v49[4] = v26;
      *(_WORD *)&v49[8] = 1024;
      *(_DWORD *)&_BYTE v49[10] = v27;
      uint64_t v28 = (const char *)_os_log_send_and_compose_impl( v25,  &v50,  0LL,  0LL,  &_mh_execute_header,  v23,  0LL,  "Completed foreground user switch %d -> %d",  v49,  14);
      __int32 v29 = (char *)v28;
      if (v28) {
        sub_100053B7C(v28);
      }
    }

    else
    {
      __int32 v29 = 0LL;
    }

    free(v29);
  }

  sub_100055F08(qword_1000DBA70);
  byte_1000DBA80 = 0;
  uint64_t v30 = sub_100018E74(qword_1000DBD40);
  int v31 = (void *)objc_claimAutoreleasedReturnValue(v30);
  uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  "com.apple.mobile.usermanagerd.foregrounduser_changed"));
  [v31 post:v32];

  if (dword_1000DBCE8 == 1) {
    sub_100035404();
  }
}

void sub_10004D8B8(int a1)
{
  os_log_t v1 = (const __CFDictionary *)sub_100084160("/private/var//keybags/usersession.kb");
  if (v1)
  {
    uint64_t v2 = v1;
    int v3 = sub_100083C6C(v1, @"NUMENT");
    unsigned int v4 = (const __CFData *)sub_100083BFC(v2, @"BLOB");
    p_name = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
    if (CFDictionaryContainsKey(v2, @"DEVICECONFIG"))
    {
      int v6 = sub_100083C6C(v2, @"DEVICECONFIG");
      int v7 = v6;
      if (v6 >= 3)
      {
        uint64_t v183 = sub_100019F7C( "usermanagerd: device configuration %d is from the future! Downgrading is not supported.",  v6);
        sub_10004F8C4(v183, v184);
        return;
      }

      dword_1000DBCE8 = v6;
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      id v8 = (id)qword_1000DBA98;
      if (os_log_type_enabled((os_log_t)v8, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)uint64_t v189 = 0LL;
        unsigned int v9 = sub_100053B4C(1);
        unsigned int v10 = (os_log_s *)v8;
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v11 = v9;
        }
        else {
          uint64_t v11 = v9 & 0xFFFFFFFE;
        }
        if ((_DWORD)v11)
        {
          LODWORD(v190) = 67109120;
          HIDWORD(v190) = dword_1000DBCE8;
          unsigned int v12 = (char *)_os_log_send_and_compose_impl( v11,  v189,  0LL,  0LL,  &_mh_execute_header,  v10,  0LL,  "Device Configuration Type:%d",  &v190);

          if (v12) {
            sub_100053B7C(v12);
          }
        }

        else
        {

          unsigned int v12 = 0LL;
        }

        p_name = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
        free(v12);
      }

      BOOL v18 = dword_1000DBCE8 == 0;
    }

    else
    {
      dword_1000DBCE8 = 0;
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      id v13 = (id)qword_1000DBA98;
      if (os_log_type_enabled((os_log_t)v13, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)uint64_t v189 = 0LL;
        unsigned int v14 = sub_100053B4C(1);
        unsigned int v15 = (os_log_s *)v13;
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v16 = v14;
        }
        else {
          uint64_t v16 = v14 & 0xFFFFFFFE;
        }
        if ((_DWORD)v16)
        {
          LODWORD(v190) = 67109120;
          HIDWORD(v190) = dword_1000DBCE8;
          uint64_t v17 = (char *)_os_log_send_and_compose_impl( v16,  v189,  0LL,  0LL,  &_mh_execute_header,  v15,  0LL,  "Device Configuration Set to Type:%d",  &v190);

          if (v17) {
            sub_100053B7C(v17);
          }
        }

        else
        {

          uint64_t v17 = 0LL;
        }

        free(v17);
        p_name = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
      }

      int v7 = 0;
      BOOL v18 = 1;
    }

    if (CFDictionaryContainsKey(v2, @"BOOTEDUSER"))
    {
      dword_1000DACB0 = sub_100083C6C(v2, @"BOOTEDUSER");
      id v19 = (id)qword_1000DBA98;
      if (os_log_type_enabled((os_log_t)v19, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)uint64_t v189 = 0LL;
        unsigned int v20 = sub_100053B4C(1);
        id v19 = v19;
        if (os_log_type_enabled((os_log_t)v19, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v21 = v20;
        }
        else {
          uint64_t v21 = v20 & 0xFFFFFFFE;
        }
        if ((_DWORD)v21)
        {
          LODWORD(v190) = 67109120;
          HIDWORD(v190) = dword_1000DACB0;
          uint64_t v22 = _os_log_send_and_compose_impl( v21,  v189,  0LL,  0LL,  &_mh_execute_header,  v19,  0LL,  "BOOTEDUSER is:%d",  &v190);
          goto LABEL_46;
        }

        goto LABEL_48;
      }
    }

    else
    {
      dword_1000DACB0 = 501;
      id v19 = (id)qword_1000DBA98;
      if (os_log_type_enabled((os_log_t)v19, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)uint64_t v189 = 0LL;
        unsigned int v23 = sub_100053B4C(1);
        id v19 = v19;
        if (os_log_type_enabled((os_log_t)v19, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v24 = v23;
        }
        else {
          uint64_t v24 = v23 & 0xFFFFFFFE;
        }
        if ((_DWORD)v24)
        {
          LODWORD(v190) = 67109120;
          HIDWORD(v190) = dword_1000DACB0;
          uint64_t v22 = _os_log_send_and_compose_impl( v24,  v189,  0LL,  0LL,  &_mh_execute_header,  v19,  0LL,  "BOOTEDUSER Set to:%d",  &v190);
LABEL_46:
          uint64_t v25 = (char *)v22;

          if (v25) {
            sub_100053B7C(v25);
          }
          goto LABEL_49;
        }

LABEL_352:
                      id v159 = 0LL;
LABEL_353:
                      free(v159);
                    }
                  }

                  if (CFStringCompare(v146, kUMUserSessionAPFSNativeVolume, 0LL))
                  {
                    CFComparisonResult v160 = CFStringCompare(v146, kUMUserSessionAPFSConvertedVolume, 0LL);
                    byte_1000DACB8 = 0;
                    if (v160)
                    {
                      qword_1000DBA88 = (uint64_t)kUMUserSessionHFSPlusVolume;
                      id v161 = (id)qword_1000DBA98;
                      if (os_log_type_enabled((os_log_t)v161, OS_LOG_TYPE_DEFAULT))
                      {
                        *(void *)uint64_t v189 = 0LL;
                        unsigned int v162 = sub_100053B4C(1);
                        id v161 = v161;
                        if (os_log_type_enabled((os_log_t)v161, OS_LOG_TYPE_DEFAULT)) {
                          uint64_t v163 = v162;
                        }
                        else {
                          uint64_t v163 = v162 & 0xFFFFFFFE;
                        }
                        if ((_DWORD)v163)
                        {
                          LOWORD(v190) = 0;
                          LODWORD(v185) = 2;
                          uint64_t v164 = _os_log_send_and_compose_impl( v163,  v189,  0LL,  0LL,  &_mh_execute_header,  v161,  0LL,  "VOL:HFS",  &v190,  v185);
                          goto LABEL_380;
                        }

LABEL_382:
                        unsigned int v169 = 0LL;
LABEL_383:
                        free(v169);
                      }

LABEL_384:
                      CFRelease(v2);
                      if (!v36) {
                        return;
                      }
LABEL_415:
                      sub_10001AED4();
                      return;
                    }

                    qword_1000DBA88 = (uint64_t)kUMUserSessionAPFSConvertedVolume;
                    id v161 = (id)qword_1000DBA98;
                    if (!os_log_type_enabled((os_log_t)v161, OS_LOG_TYPE_DEFAULT)) {
                      goto LABEL_384;
                    }
                    *(void *)uint64_t v189 = 0LL;
                    unsigned int v167 = sub_100053B4C(1);
                    id v161 = v161;
                    if (os_log_type_enabled((os_log_t)v161, OS_LOG_TYPE_DEFAULT)) {
                      uint64_t v168 = v167;
                    }
                    else {
                      uint64_t v168 = v167 & 0xFFFFFFFE;
                    }
                    if (!(_DWORD)v168) {
                      goto LABEL_382;
                    }
                    LOWORD(v190) = 0;
                    LODWORD(v185) = 2;
                    uint64_t v164 = _os_log_send_and_compose_impl( v168,  v189,  0LL,  0LL,  &_mh_execute_header,  v161,  0LL,  "VOL:CONV",  &v190,  v185);
                  }

                  else
                  {
                    byte_1000DACB8 = 1;
                    qword_1000DBA88 = (uint64_t)kUMUserSessionAPFSNativeVolume;
                    id v161 = (id)qword_1000DBA98;
                    if (!os_log_type_enabled((os_log_t)v161, OS_LOG_TYPE_DEFAULT)) {
                      goto LABEL_384;
                    }
                    *(void *)uint64_t v189 = 0LL;
                    unsigned int v165 = sub_100053B4C(1);
                    id v161 = v161;
                    if (os_log_type_enabled((os_log_t)v161, OS_LOG_TYPE_DEFAULT)) {
                      uint64_t v166 = v165;
                    }
                    else {
                      uint64_t v166 = v165 & 0xFFFFFFFE;
                    }
                    if (!(_DWORD)v166) {
                      goto LABEL_382;
                    }
                    LOWORD(v190) = 0;
                    LODWORD(v185) = 2;
                    uint64_t v164 = _os_log_send_and_compose_impl( v166,  v189,  0LL,  0LL,  &_mh_execute_header,  v161,  0LL,  "VOL:Native",  &v190,  v185);
                  }

LABEL_380:
                  unsigned int v169 = (void *)v164;
                  if (v169) {
                    sub_100053B7C((const char *)v169);
                  }
                  goto LABEL_383;
                }

                id v152 = (id)qword_1000DBA98;
                if (os_log_type_enabled((os_log_t)v152, OS_LOG_TYPE_DEFAULT))
                {
                  *(void *)uint64_t v189 = 0LL;
                  unsigned int v153 = sub_100053B4C(1);
                  uint64_t v154 = (os_log_s *)v152;
                  if (os_log_type_enabled(v154, OS_LOG_TYPE_DEFAULT)) {
                    uint64_t v155 = v153;
                  }
                  else {
                    uint64_t v155 = v153 & 0xFFFFFFFE;
                  }
                  if ((_DWORD)v155)
                  {
                    LOWORD(v190) = 0;
                    LODWORD(v185) = 2;
                    unsigned int v156 = (char *)_os_log_send_and_compose_impl( v155,  v189,  0LL,  0LL,  &_mh_execute_header,  v154,  0LL,  "FOUND NO VOLUMETYPE, setting up volume type",  &v190,  v185);

                    if (v156) {
                      sub_100053B7C(v156);
                    }
                  }

                  else
                  {

                    unsigned int v156 = 0LL;
                  }

                  free(v156);
                }

                if (byte_1000DACB8 == 1)
                {
                  qword_1000DBA88 = (uint64_t)kUMUserSessionAPFSNativeVolume;
                  __int128 v170 = (os_log_s *)(id)qword_1000DBA98;
                  if (!os_log_type_enabled(v170, OS_LOG_TYPE_DEFAULT)) {
                    goto LABEL_409;
                  }
                  *(void *)uint64_t v189 = 0LL;
                  unsigned int v171 = sub_100053B4C(1);
                  __int128 v170 = v170;
                  if (os_log_type_enabled(v170, OS_LOG_TYPE_DEFAULT)) {
                    uint64_t v172 = v171;
                  }
                  else {
                    uint64_t v172 = v171 & 0xFFFFFFFE;
                  }
                  if ((_DWORD)v172)
                  {
                    LOWORD(v190) = 0;
                    LODWORD(v185) = 2;
                    uint64_t v173 = _os_log_send_and_compose_impl( v172,  v189,  0LL,  0LL,  &_mh_execute_header,  v170,  0LL,  "Set the new volume type to APFSNativeDevice",  &v190,  v185);
                    goto LABEL_405;
                  }
                }

                else
                {
                  qword_1000DBA88 = (uint64_t)kUMUserSessionAPFSConvertedVolume;
                  __int128 v170 = (os_log_s *)(id)qword_1000DBA98;
                  if (!os_log_type_enabled(v170, OS_LOG_TYPE_DEFAULT)) {
                    goto LABEL_409;
                  }
                  *(void *)uint64_t v189 = 0LL;
                  unsigned int v174 = sub_100053B4C(1);
                  __int128 v170 = v170;
                  if (os_log_type_enabled(v170, OS_LOG_TYPE_DEFAULT)) {
                    uint64_t v175 = v174;
                  }
                  else {
                    uint64_t v175 = v174 & 0xFFFFFFFE;
                  }
                  if ((_DWORD)v175)
                  {
                    LOWORD(v190) = 0;
                    LODWORD(v185) = 2;
                    uint64_t v173 = _os_log_send_and_compose_impl( v175,  v189,  0LL,  0LL,  &_mh_execute_header,  v170,  0LL,  "Set the new volume type to APFSConvertedDevice",  &v190,  v185);
LABEL_405:
                    __int128 v176 = (char *)v173;

                    if (v176) {
                      sub_100053B7C(v176);
                    }
                    goto LABEL_408;
                  }
                }

                __int128 v176 = 0LL;
LABEL_408:
                free(v176);
LABEL_409:

                if (qword_1000DBCD8)
                {
                  CFIndex Count = CFArrayGetCount((CFArrayRef)qword_1000DBCD8);
                  if (Count >= 1)
                  {
                    CFIndex v178 = Count;
                    for (CFIndex i = 0LL; i != v178; ++i)
                    {
                      unsigned int v180 = CFArrayGetValueAtIndex((CFArrayRef)qword_1000DBCD8, i);
                      CFTypeID v181 = CFGetTypeID(v180);
                      CFTypeID TypeID = CFDictionaryGetTypeID();
                      if (v181 != TypeID) {
                        break;
                      }
                      sub_10004F8C4(TypeID, (const __CFDictionary *)v180);
                    }
                  }
                }

                CFRelease(v2);
                goto LABEL_415;
              }

              id v116 = (id)qword_1000DBA98;
              if (!os_log_type_enabled((os_log_t)v116, OS_LOG_TYPE_DEFAULT))
              {
LABEL_322:

                goto LABEL_323;
              }

              *(void *)uint64_t v189 = 0LL;
              unsigned int v121 = sub_100053B4C(1);
              uint64_t v122 = (os_log_s *)v116;
              if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v123 = v121;
              }
              else {
                uint64_t v123 = v121 & 0xFFFFFFFE;
              }
              if ((_DWORD)v123)
              {
                LODWORD(v190) = 67109120;
                HIDWORD(v190) = v109;
                unsigned int v124 = (const char *)_os_log_send_and_compose_impl( v123,  v189,  0LL,  0LL,  &_mh_execute_header,  v122,  0LL,  "INVSALID numLRU:%d",  &v190);

                if (v124) {
                  sub_100053B7C(v124);
                }
              }

              else
              {

                unsigned int v124 = 0LL;
              }

              id v145 = (char *)v124;
            }

            else
            {
              id v116 = (id)qword_1000DBA98;
              if (!os_log_type_enabled((os_log_t)v116, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_322;
              }
              *(void *)uint64_t v189 = 0LL;
              unsigned int v117 = sub_100053B4C(1);
              unsigned int v118 = (os_log_s *)v116;
              if (os_log_type_enabled(v118, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v119 = v117;
              }
              else {
                uint64_t v119 = v117 & 0xFFFFFFFE;
              }
              if ((_DWORD)v119)
              {
                uint64_t v190 = 67109120LL;
                uint64_t v120 = (const char *)_os_log_send_and_compose_impl( v119,  v189,  0LL,  0LL,  &_mh_execute_header,  v118,  0LL,  "FOUND NO LRU TABLE UIDS:%d",  &v190);

                if (v120) {
                  sub_100053B7C(v120);
                }
              }

              else
              {

                uint64_t v120 = 0LL;
              }

              id v145 = (char *)v120;
            }

            free(v145);
            goto LABEL_322;
          }

          id v79 = (id)qword_1000DBA98;
          if (!os_log_type_enabled((os_log_t)v79, OS_LOG_TYPE_DEFAULT))
          {
LABEL_241:

            goto LABEL_242;
          }

          *(void *)uint64_t v189 = 0LL;
          unsigned int v84 = sub_100053B4C(1);
          unsigned int v85 = (os_log_s *)v79;
          if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v86 = v84;
          }
          else {
            uint64_t v86 = v84 & 0xFFFFFFFE;
          }
          if ((_DWORD)v86)
          {
            LODWORD(v190) = 67109120;
            HIDWORD(v190) = v72;
            uint64_t v87 = (const char *)_os_log_send_and_compose_impl( v86,  v189,  0LL,  0LL,  &_mh_execute_header,  v85,  0LL,  "INVSALID NUMSYNC:%d",  &v190);

            if (v87) {
              sub_100053B7C(v87);
            }
          }

          else
          {

            uint64_t v87 = 0LL;
          }

          id v108 = (char *)v87;
        }

        else
        {
          id v79 = (id)qword_1000DBA98;
          if (!os_log_type_enabled((os_log_t)v79, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_241;
          }
          *(void *)uint64_t v189 = 0LL;
          unsigned int v80 = sub_100053B4C(1);
          uint64_t v81 = (os_log_s *)v79;
          if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v82 = v80;
          }
          else {
            uint64_t v82 = v80 & 0xFFFFFFFE;
          }
          if ((_DWORD)v82)
          {
            uint64_t v190 = 67109120LL;
            int v83 = (const char *)_os_log_send_and_compose_impl( v82,  v189,  0LL,  0LL,  &_mh_execute_header,  v81,  0LL,  "FOUND NO SYNC BUBBLE UIDS:%d",  &v190);

            if (v83) {
              sub_100053B7C(v83);
            }
          }

          else
          {

            int v83 = 0LL;
          }

          id v108 = (char *)v83;
        }

        free(v108);
        goto LABEL_241;
      }
    }

    uint64_t v67 = sub_100083CD4(v2, @"MAXUSERSIZE");
    goto LABEL_153;
  }

void sub_10004F8C4(uint64_t a1, const __CFDictionary *a2)
{
  int v3 = sub_100083C6C(a2, kUMUserSessionIDKey);
  if (!CFDictionaryContainsKey(a2, kUMUserSessionUserVolumeTypeKey)) {
    CFDictionarySetValue(a2, kUMUserSessionUserVolumeTypeKey, (const void *)qword_1000DBA88);
  }
  if (byte_1000DACB8)
  {
    if (!CFDictionaryContainsKey(a2, kUMUserSessionNeedsMountKey))
    {
      if (v3 == 502) {
        unsigned int v4 = (const void **)&kCFBooleanFalse;
      }
      else {
        unsigned int v4 = (const void **)&kCFBooleanTrue;
      }
      CFDictionarySetValue(a2, kUMUserSessionNeedsMountKey, *v4);
    }

    return;
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  uint64_t v5 = (os_log_s *)(id)qword_1000DBA98;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t v21 = 0LL;
    unsigned int v6 = sub_100053B4C(1);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v7 = v6;
    }
    else {
      uint64_t v7 = v6 & 0xFFFFFFFE;
    }
    if ((_DWORD)v7)
    {
      LOWORD(v19) = 0;
      id v8 = (const char *)_os_log_send_and_compose_impl( v7,  v21,  0LL,  0LL,  &_mh_execute_header,  v5,  0LL,  "Setting APFSIOC_MAINTAIN_DIR_STATS",  &v19,  2);
      unsigned int v9 = (char *)v8;
      if (v8) {
        sub_100053B7C(v8);
      }
    }

    else
    {
      unsigned int v9 = 0LL;
    }

    free(v9);
  }

  if (sub_100083E34(a2, kUMUserSessionHomeDirKey, v21, 1024))
  {
    uint64_t v18 = 1LL;
    if (fsctl(v21, 0x80084A02uLL, &v18, 0))
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      unsigned int v10 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_42;
      }
      uint64_t v17 = 0LL;
      unsigned int v11 = sub_100053B4C(1);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v12 = v11;
      }
      else {
        uint64_t v12 = v11 & 0xFFFFFFFE;
      }
      if ((_DWORD)v12)
      {
        int v19 = 136315138;
        unsigned int v20 = v21;
        id v13 = (const char *)_os_log_send_and_compose_impl( v12,  &v17,  0LL,  0LL,  &_mh_execute_header,  v10,  0LL,  "Failed to set APFSIOC_MAINTAIN_DIR_STATS on %s",  &v19);
        goto LABEL_38;
      }
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      unsigned int v10 = (os_log_s *)(id)qword_1000DBA98;
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_42;
      }
      uint64_t v17 = 0LL;
      unsigned int v14 = sub_100053B4C(1);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v15 = v14;
      }
      else {
        uint64_t v15 = v14 & 0xFFFFFFFE;
      }
      if ((_DWORD)v15)
      {
        int v19 = 136315138;
        unsigned int v20 = v21;
        id v13 = (const char *)_os_log_send_and_compose_impl( v15,  &v17,  0LL,  0LL,  &_mh_execute_header,  v10,  0LL,  "APFSIOC_MAINTAIN_DIR_STATS set on %s",  &v19);
LABEL_38:
        uint64_t v16 = (char *)v13;
        if (v13) {
          sub_100053B7C(v13);
        }
        goto LABEL_41;
      }
    }

    uint64_t v16 = 0LL;
LABEL_41:
    free(v16);
LABEL_42:
  }

  if (!CFDictionaryContainsKey(a2, kUMUserSessionNeedsMountKey)) {
    CFDictionarySetValue(a2, kUMUserSessionNeedsMountKey, kCFBooleanFalse);
  }
}

__CFDictionary *sub_10004FCB0(int a1)
{
  CFUUIDRef uuid = 0LL;
  int valuePtr = 501;
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v2 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v2, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)cStr = 0LL;
    unsigned int v3 = sub_100053B4C(1);
    unsigned int v4 = (os_log_s *)v2;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v5 = v3;
    }
    else {
      uint64_t v5 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v5)
    {
      *(void *)uint64_t v106 = 0x1F504000100LL;
      unsigned int v6 = (char *)_os_log_send_and_compose_impl( v5,  cStr,  0LL,  0LL,  &_mh_execute_header,  v4,  0LL,  "Creating New Primary Session with uid %d",  v106);

      if (v6) {
        sub_100053B7C(v6);
      }
    }

    else
    {

      unsigned int v6 = 0LL;
    }

    free(v6);
  }

  uint64_t v7 = sub_10008428C();
  CFNumberRef v8 = CFNumberCreate(0LL, kCFNumberIntType, &valuePtr);
  CFDictionarySetValue(v7, kUMUserSessionIDKey, v8);
  CFRelease(v8);
  int v104 = valuePtr;
  CFNumberRef v9 = CFNumberCreate(0LL, kCFNumberIntType, &v104);
  CFDictionarySetValue(v7, kUMUserSessionGroupIDKey, v9);
  CFRelease(v9);
  CFDictionarySetValue(v7, kUMUserSessionTypeKey, kUMUserSessionOther);
  bzero(&cStr[7], 0x3F9uLL);
  strcpy(cStr, "mobile");
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v10 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v10, OS_LOG_TYPE_DEFAULT))
  {
    CFTypeRef cf = 0LL;
    unsigned int v11 = sub_100053B4C(1);
    uint64_t v12 = (os_log_s *)v10;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v13 = v11;
    }
    else {
      uint64_t v13 = v11 & 0xFFFFFFFE;
    }
    if ((_DWORD)v13)
    {
      *(_DWORD *)uint64_t v106 = 136315138;
      *(void *)&v106[4] = cStr;
      unsigned int v14 = (char *)_os_log_send_and_compose_impl( v13,  &cf,  0LL,  0LL,  &_mh_execute_header,  v12,  0LL,  "creating with shortname %s",  v106);

      if (v14) {
        sub_100053B7C(v14);
      }
    }

    else
    {

      unsigned int v14 = 0LL;
    }

    free(v14);
  }

  CFStringRef v15 = CFStringCreateWithCString(0LL, cStr, 0x8000100u);
  if (v15)
  {
    CFStringRef v16 = v15;
    CFDictionarySetValue(v7, kUMUserSessionShortNameKey, v15);
    CFDictionarySetValue(v7, kUMUserSessionFirstNameKey, v16);
    CFDictionarySetValue(v7, kUMUserSessionLastNameKey, v16);
    CFDictionarySetValue(v7, kUMUserSessionNameKey, v16);
    CFDictionarySetValue(v7, kUMUserSessionDisplayNameKey, v16);
    CFRelease(v16);
  }

  else
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v17 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v17, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)uint64_t v106 = 0LL;
      unsigned int v18 = sub_100053B4C(1);
      int v19 = (os_log_s *)v17;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v20 = v18;
      }
      else {
        uint64_t v20 = v18 & 0xFFFFFFFE;
      }
      if ((_DWORD)v20)
      {
        LOWORD(cf) = 0;
        uint64_t v21 = (char *)_os_log_send_and_compose_impl( v20,  v106,  0LL,  0LL,  &_mh_execute_header,  v19,  0LL,  "failed to create userSessionShortName",  &cf,  2);

        if (v21) {
          sub_100053B7C(v21);
        }
      }

      else
      {

        uint64_t v21 = 0LL;
      }

      free(v21);
    }
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v22 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v22, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t v106 = 0LL;
    unsigned int v23 = sub_100053B4C(1);
    uint64_t v24 = (os_log_s *)v22;
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v25 = v23;
    }
    else {
      uint64_t v25 = v23 & 0xFFFFFFFE;
    }
    if ((_DWORD)v25)
    {
      LOWORD(cf) = 0;
      LODWORD(v100) = 2;
      id v26 = (char *)_os_log_send_and_compose_impl( v25,  v106,  0LL,  0LL,  &_mh_execute_header,  v24,  0LL,  "Setting Default Language",  &cf,  v100);

      if (v26) {
        sub_100053B7C(v26);
      }
    }

    else
    {

      id v26 = 0LL;
    }

    free(v26);
  }

  CFDictionarySetValue(v7, kUMUserSessionLanguageKey, @"en_US");
  if (a1)
  {
    CFTypeRef cf = 0LL;
    CFErrorRef err = 0LL;
    if (AKSIdentityGetPrimary(&uuid, &cf, &err))
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      id v27 = (id)qword_1000DBA98;
      if (os_log_type_enabled((os_log_t)v27, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)uint64_t v106 = 0LL;
        unsigned int v28 = sub_100053B4C(1);
        uint64_t v29 = (os_log_s *)v27;
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v30 = v28;
        }
        else {
          uint64_t v30 = v28 & 0xFFFFFFFE;
        }
        if ((_DWORD)v30)
        {
          LOWORD(v101) = 0;
          LODWORD(v100) = 2;
          int v31 = (char *)_os_log_send_and_compose_impl( v30,  v106,  0LL,  0LL,  &_mh_execute_header,  v29,  0LL,  "***************** FOUND Primary User on AKS, BUT NO UM USER PROFILE *****************",  &v101,  v100);

          if (v31) {
            sub_100053B7C(v31);
          }
        }

        else
        {

          int v31 = 0LL;
        }

        free(v31);
      }

      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      id v37 = (id)qword_1000DBA98;
      if (os_log_type_enabled((os_log_t)v37, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)uint64_t v106 = 0LL;
        unsigned int v38 = sub_100053B4C(1);
        int v39 = (os_log_s *)v37;
        if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v40 = v38;
        }
        else {
          uint64_t v40 = v38 & 0xFFFFFFFE;
        }
        if ((_DWORD)v40)
        {
          LOWORD(v101) = 0;
          LODWORD(v100) = 2;
          CFTypeID v41 = (char *)_os_log_send_and_compose_impl( v40,  v106,  0LL,  0LL,  &_mh_execute_header,  v39,  0LL,  "***************** USING Primary User UUID for 501 user*****************",  &v101,  v100);

          if (v41) {
            sub_100053B7C(v41);
          }
        }

        else
        {

          CFTypeID v41 = 0LL;
        }

        free(v41);
      }

      if (uuid)
      {
        CFStringRef v42 = CFUUIDCreateString(kCFAllocatorDefault, uuid);
        CFDictionarySetValue(v7, kUMUserSessionUUIDKey, v42);
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        id v43 = (id)qword_1000DBA98;
        if (os_log_type_enabled((os_log_t)v43, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v101 = 0LL;
          unsigned int v44 = sub_100053B4C(1);
          unsigned int v45 = (os_log_s *)v43;
          if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v46 = v44;
          }
          else {
            uint64_t v46 = v44 & 0xFFFFFFFE;
          }
          if ((_DWORD)v46)
          {
            *(_DWORD *)uint64_t v106 = 138412290;
            *(void *)&v106[4] = v42;
            LODWORD(v100) = 12;
            uint64_t v47 = (char *)_os_log_send_and_compose_impl( v46,  &v101,  0LL,  0LL,  &_mh_execute_header,  v45,  0LL,  "Setting UserUUID from AKS Primary UserUUID:%@",  v106,  v100);

            if (v47) {
              sub_100053B7C(v47);
            }
          }

          else
          {

            uint64_t v47 = 0LL;
          }

          free(v47);
        }

        if (uuid) {
          CFRelease(uuid);
        }
        CFUUIDRef uuid = 0LL;
        if (cf)
        {
          CFRelease(cf);
          CFTypeRef cf = 0LL;
        }

        if (v42) {
          CFRelease(v42);
        }
        goto LABEL_131;
      }

      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      id v48 = (id)qword_1000DBA98;
      if (os_log_type_enabled((os_log_t)v48, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)uint64_t v106 = 0LL;
        unsigned int v49 = sub_100053B4C(1);
        unsigned int v50 = (os_log_s *)v48;
        if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v51 = v49;
        }
        else {
          uint64_t v51 = v49 & 0xFFFFFFFE;
        }
        if ((_DWORD)v51)
        {
          LOWORD(v101) = 0;
          LODWORD(v100) = 2;
          uint64_t v52 = (char *)_os_log_send_and_compose_impl( v51,  v106,  0LL,  0LL,  &_mh_execute_header,  v50,  0LL,  "*****************  Primary User UUID NULL, ignoring *****************",  &v101,  v100);

          if (v52) {
            sub_100053B7C(v52);
          }
        }

        else
        {

          uint64_t v52 = 0LL;
        }

        free(v52);
      }
    }

    else
    {
      if (qword_1000DBAA0 != -1) {
        dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
      }
      id v32 = (id)qword_1000DBA98;
      if (os_log_type_enabled((os_log_t)v32, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v101 = 0LL;
        LODWORD(v33) = sub_100053B4C(1);
        CFIndex v34 = (os_log_s *)v32;
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v33 = v33;
        }
        else {
          uint64_t v33 = v33 & 0xFFFFFFFE;
        }
        if ((_DWORD)v33)
        {
          CFIndex Code = CFErrorGetCode(err);
          *(_DWORD *)uint64_t v106 = 134217984;
          *(void *)&v106[4] = Code;
          int v36 = (char *)_os_log_send_and_compose_impl( v33,  &v101,  0LL,  0LL,  &_mh_execute_header,  v34,  0LL,  "No Primary User Set in AKS: error:: %ld",  v106);

          if (v36) {
            sub_100053B7C(v36);
          }
        }

        else
        {

          int v36 = 0LL;
        }

        free(v36);
      }

      if (err) {
        CFRelease(err);
      }
    }
  }

  CFUUIDRef uuid = CFUUIDCreate(0LL);
  CFStringRef v53 = CFUUIDCreateString(0LL, uuid);
  CFDictionarySetValue(v7, kUMUserSessionUUIDKey, v53);
  if (uuid)
  {
    CFRelease(uuid);
    CFUUIDRef uuid = 0LL;
  }

  if (v53) {
    CFRelease(v53);
  }
  CFUUIDRef uuid = 0LL;
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v54 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v54, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t v106 = 0LL;
    unsigned int v55 = sub_100053B4C(1);
    __int128 v56 = (os_log_s *)v54;
    if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v57 = v55;
    }
    else {
      uint64_t v57 = v55 & 0xFFFFFFFE;
    }
    if ((_DWORD)v57)
    {
      LOWORD(cf) = 0;
      LODWORD(v100) = 2;
      int v58 = (char *)_os_log_send_and_compose_impl( v57,  v106,  0LL,  0LL,  &_mh_execute_header,  v56,  0LL,  "Session default uuid created",  &cf,  v100);

      if (v58) {
        sub_100053B7C(v58);
      }
    }

    else
    {

      int v58 = 0LL;
    }

    free(v58);
  }

LABEL_131:
  CFUUIDRef uuid = CFUUIDCreate(0LL);
  CFStringRef v59 = CFUUIDCreateString(0LL, uuid);
  CFDictionarySetValue(v7, kUMUserSessionAlternateDSIDKey, v59);
  if (uuid)
  {
    CFRelease(uuid);
    CFUUIDRef uuid = 0LL;
  }

  if (v59) {
    CFRelease(v59);
  }
  CFUUIDRef uuid = 0LL;
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  CFDateRef v61 = CFDateCreate(kCFAllocatorDefault, Current);
  CFDictionarySetValue(v7, kUMUserSessionCreateTimeStampKey, v61);
  CFDictionarySetValue(v7, kUMUserSessionLoginTimeStampKey, v61);
  if (v61) {
    CFRelease(v61);
  }
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v62 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v62, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t v106 = 0LL;
    unsigned int v63 = sub_100053B4C(1);
    uint64_t v64 = (os_log_s *)v62;
    if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v65 = v63;
    }
    else {
      uint64_t v65 = v63 & 0xFFFFFFFE;
    }
    if ((_DWORD)v65)
    {
      LOWORD(cf) = 0;
      LODWORD(v100) = 2;
      int v66 = (char *)_os_log_send_and_compose_impl( v65,  v106,  0LL,  0LL,  &_mh_execute_header,  v64,  0LL,  "Session  creation date set",  &cf,  v100);

      if (v66) {
        sub_100053B7C(v66);
      }
    }

    else
    {

      int v66 = 0LL;
    }

    free(v66);
  }

  CFDictionarySetValue(v7, kUMUserSessionLoginUserKey, kCFBooleanFalse);
  CFDictionarySetValue(v7, kUMUserSessionDirtyKey, kCFBooleanFalse);
  CFDictionarySetValue(v7, kUMUserSessionForegroundKey, kCFBooleanTrue);
  CFDictionarySetValue(v7, kUMUserSessionisPrimaryKey, kCFBooleanTrue);
  CFDictionarySetValue(v7, kUMUserSessionisAdminKey, kCFBooleanTrue);
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v67 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v67, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t v106 = 0LL;
    unsigned int v68 = sub_100053B4C(1);
    int v69 = (os_log_s *)v67;
    if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v70 = v68;
    }
    else {
      uint64_t v70 = v68 & 0xFFFFFFFE;
    }
    if ((_DWORD)v70)
    {
      LOWORD(cf) = 0;
      LODWORD(v100) = 2;
      int v71 = (char *)_os_log_send_and_compose_impl( v70,  v106,  0LL,  0LL,  &_mh_execute_header,  v69,  0LL,  "Set Primary true",  &cf,  v100);

      if (v71) {
        sub_100053B7C(v71);
      }
    }

    else
    {

      int v71 = 0LL;
    }

    free(v71);
  }

  bzero(&v109, 0x3F4uLL);
  strcpy(cStr, "/var/mobile");
  CFStringRef v72 = CFStringCreateWithCString(0LL, cStr, 0x8000100u);
  if (v72)
  {
    CFStringRef v73 = v72;
    CFDictionarySetValue(v7, kUMUserSessionLibinfoHomeDirKey, v72);
    CFRelease(v73);
  }

  else
  {
    if (qword_1000DBAA0 != -1) {
      dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    }
    id v74 = (id)qword_1000DBA98;
    if (os_log_type_enabled((os_log_t)v74, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)uint64_t v106 = 0LL;
      unsigned int v75 = sub_100053B4C(1);
      unsigned __int8 v76 = (os_log_s *)v74;
      if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v77 = v75;
      }
      else {
        uint64_t v77 = v75 & 0xFFFFFFFE;
      }
      if ((_DWORD)v77)
      {
        LOWORD(cf) = 0;
        LODWORD(v100) = 2;
        uint64_t v78 = (char *)_os_log_send_and_compose_impl( v77,  v106,  0LL,  0LL,  &_mh_execute_header,  v76,  0LL,  "FAILEd to create LibinfoPath",  &cf,  v100);

        if (v78) {
          sub_100053B7C(v78);
        }
      }

      else
      {

        uint64_t v78 = 0LL;
      }

      free(v78);
    }
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v79 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v79, OS_LOG_TYPE_DEFAULT))
  {
    CFTypeRef cf = 0LL;
    unsigned int v80 = sub_100053B4C(1);
    uint64_t v81 = (os_log_s *)v79;
    if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v82 = v80;
    }
    else {
      uint64_t v82 = v80 & 0xFFFFFFFE;
    }
    if ((_DWORD)v82)
    {
      *(_DWORD *)uint64_t v106 = 136315138;
      *(void *)&v106[4] = cStr;
      int v83 = (char *)_os_log_send_and_compose_impl( v82,  &cf,  0LL,  0LL,  &_mh_execute_header,  v81,  0LL,  "Libinfo Path set to %s",  v106);

      if (v83) {
        sub_100053B7C(v83);
      }
    }

    else
    {

      int v83 = 0LL;
    }

    free(v83);
  }

  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v84 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v84, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t v106 = 0LL;
    unsigned int v85 = sub_100053B4C(1);
    uint64_t v86 = (os_log_s *)v84;
    if (os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v87 = v85;
    }
    else {
      uint64_t v87 = v85 & 0xFFFFFFFE;
    }
    if ((_DWORD)v87)
    {
      LOWORD(cf) = 0;
      LODWORD(v100) = 2;
      uint64_t v88 = (char *)_os_log_send_and_compose_impl( v87,  v106,  0LL,  0LL,  &_mh_execute_header,  v86,  0LL,  "Adding to session dictionary",  &cf,  v100);

      if (v88) {
        sub_100053B7C(v88);
      }
    }

    else
    {

      uint64_t v88 = 0LL;
    }

    free(v88);
  }

  sub_100021680(v7, 0);
  if (qword_1000DBAA0 != -1) {
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
  }
  id v89 = (id)qword_1000DBA98;
  if (os_log_type_enabled((os_log_t)v89, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t v106 = 0LL;
    unsigned int v90 = sub_100053B4C(1);
    id v91 = (os_log_s *)v89;
    if (os_log_type_enabled(v91, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v92 = v90;
    }
    else {
      uint64_t v92 = v90 & 0xFFFFFFFE;
    }
    if ((_DWORD)v92)
    {
      LOWORD(cf) = 0;
      LODWORD(v100) = 2;
      uint64_t v93 = (char *)_os_log_send_and_compose_impl( v92,  v106,  0LL,  0LL,  &_mh_execute_header,  v91,  0LL,  "Saving sessions",  &cf,  v100);

      if (v93) {
        sub_100053B7C(v93);
      }
    }

    else
    {

      uint64_t v93 = 0LL;
    }

    free(v93);
  }

  sub_10001AED4();
  if (qword_1000DBAB0 != -1) {
    dispatch_once(&qword_1000DBAB0, &stru_1000CD548);
  }
  id v94 = (id)qword_1000DBAA8;
  if (os_log_type_enabled((os_log_t)v94, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t v106 = 0LL;
    unsigned int v95 = sub_100053B4C(1);
    CFIndex v96 = (os_log_s *)v94;
    if (os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v97 = v95;
    }
    else {
      uint64_t v97 = v95 & 0xFFFFFFFE;
    }
    if ((_DWORD)v97)
    {
      LODWORD(cf) = 67109120;
      HIDWORD(cf) = valuePtr;
      uint64_t v98 = (char *)_os_log_send_and_compose_impl( v97,  v106,  0LL,  0LL,  &_mh_execute_header,  v96,  0LL,  "Created default user %u",  &cf);

      if (v98) {
        sub_100053B7C(v98);
      }
    }

    else
    {

      uint64_t v98 = 0LL;
    }

    free(v98);
  }

  return v7;
}

void sub_100050FB8(id a1)
{
  os_log_t v1 = os_log_create(off_1000DAE70, "persona");
  id v2 = (void *)qword_1000DBAB8;
  qword_1000DBAB8 = (uint64_t)v1;
}

void sub_100050FEC(uint64_t a1)
{
  if (qword_1000DBAB0 != -1) {
    dispatch_once(&qword_1000DBAB0, &stru_1000CD548);
  }
  id v6 = (id)qword_1000DBAA8;
  if (os_log_type_enabled((os_log_t)v6, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)&v139.st_dev = 0LL;
    unsigned int v7 = sub_100053B4C(0);
    os_log_t v1 = (os_log_s *)v6;
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = v7 & 0xFFFFFFFE;
    }
    if ((_DWORD)v8)
    {
      *(_DWORD *)id v138 = 67109120;
      *(_DWORD *)&v138[4] = a1;
      CFNumberRef v9 = (char *)_os_log_send_and_compose_impl( v8,  &v139,  0LL,  0LL,  &_mh_execute_header,  v1,  0LL,  "Unloading previous user %d...",  v138);

      if (v9) {
        sub_100053B7C(v9);
      }
    }

    else
    {

      CFNumberRef v9 = 0LL;
    }

    free(v9);
  }

  if ((_DWORD)a1 == -1)
  {
    sub_100019F7C("UserManagement user switch failed assertion: uid != -1");
    goto LABEL_263;
  }

  id v10 = sub_100054ED0(qword_1000DBA70, a1);
  uint64_t v11 = objc_claimAutoreleasedReturnValue(v10);
  if (!v11)
  {
LABEL_263:
    sub_100019F7C("UserManagement user switch failed assertion: oldSession != ((void *)0)");
LABEL_264:
    dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
    goto LABEL_48;
  }

  id v6 = (id)v11;
  p_name = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
  int v12 = dword_1000DBCE8;
  unsigned int v3 = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
  id v2 = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
  if (dword_1000DBCE8 == 1)
  {
    sub_10003FE64();
    if (!lstat("/private/var/mobile", &v139) && (v139.st_mode & 0xF000) == 0x4000)
    {
      if (sub_100019FD4("/private/var/mobile", 0x80000))
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        id v13 = (id)qword_1000DBA98;
        if (os_log_type_enabled((os_log_t)v13, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v137 = 0LL;
          LODWORD(v14) = sub_100053B4C(1);
          CFStringRef v15 = (os_log_s *)v13;
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v14 = v14;
          }
          else {
            uint64_t v14 = v14 & 0xFFFFFFFE;
          }
          if ((_DWORD)v14)
          {
            CFStringRef v16 = __error();
            id v17 = strerror(*v16);
            *(_DWORD *)id v138 = 136315138;
            *(void *)&v138[4] = v17;
            unsigned int v18 = (char *)_os_log_send_and_compose_impl( v14,  &v137,  0LL,  0LL,  &_mh_execute_header,  v15,  0LL,  "Forced unmount of VARMOBILE failed with %s",  v138);

            if (v18) {
              sub_100053B7C(v18);
            }
          }

          else
          {

            unsigned int v18 = 0LL;
          }

          free(v18);
        }
      }

      if (rmdir("/private/var/mobile"))
      {
        if (qword_1000DBAA0 != -1) {
          dispatch_once(&qword_1000DBAA0, &stru_1000CD528);
        }
        id v19 = (id)qword_1000DBA98;
        if (os_log_type_enabled((os_log_t)v19, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v137 = 0LL;
          LODWORD(v20) = sub_100053B4C(1);
          uint64_t v21 = (os_log_s *)v19;
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v20 = v20;
          }
          else {
            uint64_t v20 = v20 & 0xFFFFFFFE;
          }
          if ((_DWORD)v20)
          {
            id v22 = __error();
            unsigned int v23 = strerror(*v22);
            *(_DWORD *)id v138 = 136315138;
            *(void *)&v138[4] = v23;
            uint64_t v24 = (char *)_os_log_send_and_compose_impl( v20,  &v137,  0LL,  0LL,  &_mh_execute_header,  v21,  0LL,  "Failed to rmdir VARMOBILE with error %s",  v138);

            if (v24) {
              sub_100053B7C(v24);
            }
          }

          else
          {

            uint64_t v24 = 0LL;
          }

          free(v24);
        }
      }
    }

    int v12 = dword_1000DBCE8;
  }

  if (v12 == 2) {
    os_log_t v1 = (os_log_s *)@"/private/var/mobile";
  }
  else {
    os_log_t v1 = 0LL;
  }
  if (qword_1000DBAA0 != -1) {
    goto LABEL_264;
  }
LABEL_48:
  uint64_t v25 = v2[339];
  if (os_log_type_enabled((os_log_t)v25, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)&v139.st_dev = 0LL;
    unsigned int v26 = sub_100053B4C(1);
    id v27 = v25;
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v28 = v26;
    }
    else {
      uint64_t v28 = v26 & 0xFFFFFFFE;
    }
    if ((_DWORD)v28)
    {
      *(_WORD *)id v138 = 0;
      uint64_t v29 = (char *)_os_log_send_and_compose_impl( v28,  &v139,  0LL,  0LL,  &_mh_execute_header,  v27,  0LL,  "Unmounting previous Volume",  v138,  2);

      if (v29) {
        sub_100053B7C(v29);
      }
    }

    else
    {

      uint64_t v29 = 0LL;
    }

    free(v29);
  }

  unsigned int v30 = [(id)qword_1000DBA68 unmountVolumeWithSession:v6 mountPath:v1 error:0];
  int v31 = v3[340];
  if (v30)
  {
    id v32 = v2[339];
    if (os_log_type_enabled((os_log_t)v32, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)&v139.st_dev = 0LL;
      unsigned int v33 = sub_100053B4C(1);
      id v32 = v32;
      if (os_log_type_enabled((os_log_t)v32, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v34 = v33;
      }
      else {
        uint64_t v34 = v33 & 0xFFFFFFFE;
      }
      if ((_DWORD)v34)
      {
        *(_WORD *)id v138 = 0;
        LODWORD(v132) = 2;
        uint64_t v35 = _os_log_send_and_compose_impl( v34,  &v139,  0LL,  0LL,  &_mh_execute_header,  v32,  0LL,  "Previous session APFSUser Volume unmounted!!",  v138,  v132);
        goto LABEL_74;
      }

      goto LABEL_76;
    }
  }

  else
  {
    id v32 = v2[339];
    if (os_log_type_enabled((os_log_t)v32, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)&v139.st_dev = 0LL;
      unsigned int v36 = sub_100053B4C(1);
      id v32 = v32;
      if (os_log_type_enabled((os_log_t)v32, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v37 = v36;
      }
      else {
        uint64_t v37 = v36 & 0xFFFFFFFE;
      }
      if ((_DWORD)v37)
      {
        *(_WORD *)id v138 = 0;
        LODWORD(v132) = 2;
        uint64_t v35 = _os_log_send_and_compose_impl( v37,  &v139,  0LL,  0LL,  &_mh_execute_header,  v32,  0LL,  "Previous session APFSUser Volume failed to unmount",  v138,  v132);
LABEL_74:
        unsigned int v38 = (char *)v35;

        if (v38) {
          sub_100053B7C(v38);
        }
        goto LABEL_77;
      }

LABEL_97:
      uint64_t v47 = 0LL;
LABEL_98:
      free(v47);
    }
  }

  unsigned int v48 = [(id)qword_1000DBA68 splitUserVolumeEnabled];
  int v49 = *((_DWORD *)p_name + 826);
  if ((_DWORD)a1 != 502 && v48 && v49 == 1)
  {
    unsigned int v50 = sub_100083DF4((const __CFDictionary *)v6, kUMUserSessionVolumeDeviceNodeKey);
    uint64_t v51 = v3[340];
    if (v50)
    {
      uint64_t v52 = v50;
      CFStringRef v53 = v2[339];
      if (os_log_type_enabled((os_log_t)v53, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)id v138 = 0LL;
        unsigned int v54 = sub_100053B4C(1);
        unsigned int v55 = v53;
        if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v56 = v54;
        }
        else {
          uint64_t v56 = v54 & 0xFFFFFFFE;
        }
        if ((_DWORD)v56)
        {
          v139.st_dev = 138412546;
          *(void *)&v139.st_mode = v52;
          WORD2(v139.st_ino) = 1024;
          *(_DWORD *)((char *)&v139.st_ino + 6) = a1;
          LODWORD(v132) = 18;
          uint64_t v57 = (char *)_os_log_send_and_compose_impl( v56,  v138,  0LL,  0LL,  &_mh_execute_header,  v55,  0LL,  "Calling AKSVolumeUnmap with disk:%@, uid:%d",  &v139,  v132);

          if (v57) {
            sub_100053B7C(v57);
          }
        }

        else
        {

          uint64_t v57 = 0LL;
        }

        free(v57);
      }

      uint64_t v62 = sub_100019B18(qword_1000DBD40);
      unsigned int v63 = (void *)objc_claimAutoreleasedReturnValue(v62);
      id v136 = 0LL;
      unsigned int v64 = [v63 unmapVolume:v52 error:&v136];
      id v65 = v136;

      int v66 = v3[340];
      if (v64)
      {
        int v58 = v2[339];
        if (os_log_type_enabled((os_log_t)v58, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)&v139.st_dev = 0LL;
          unsigned int v67 = sub_100053B4C(1);
          int v58 = v58;
          if (os_log_type_enabled((os_log_t)v58, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v68 = v67;
          }
          else {
            uint64_t v68 = v67 & 0xFFFFFFFE;
          }
          if ((_DWORD)v68)
          {
            *(_WORD *)id v138 = 0;
            uint64_t v69 = _os_log_send_and_compose_impl( v68,  &v139,  0LL,  0LL,  &_mh_execute_header,  v58,  0LL,  "Volume Unmap of old session succeeded");
            goto LABEL_140;
          }

          goto LABEL_142;
        }
      }

      else
      {
        int v58 = v2[339];
        if (os_log_type_enabled((os_log_t)v58, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)id v138 = 0LL;
          LODWORD(v70) = sub_100053B4C(1);
          int v58 = v58;
          if (os_log_type_enabled((os_log_t)v58, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v70 = v70;
          }
          else {
            uint64_t v70 = v70 & 0xFFFFFFFE;
          }
          if ((_DWORD)v70)
          {
            id v71 = [v65 code];
            v139.st_dev = 134217984;
            *(void *)&v139.st_mode = v71;
            uint64_t v69 = _os_log_send_and_compose_impl( v70,  v138,  0LL,  0LL,  &_mh_execute_header,  v58,  0LL,  "AKS volumeUnmap failed with error:%ld",  &v139);
LABEL_140:
            CFStringRef v72 = (char *)v69;

            if (v72) {
              sub_100053B7C(v72);
            }
            goto LABEL_143;
          }

      id v17 = 0LL;
LABEL_98:
      free(v17);
LABEL_99:

      return 0LL;
    }

    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    id v6 = (os_log_s *)(id)qword_1000DBBD0;
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_88;
    }
    CFTypeID v41 = 0LL;
    LODWORD(v7) = sub_100053B4C(1);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      unsigned int v7 = v7;
    }
    else {
      unsigned int v7 = v7 & 0xFFFFFFFE;
    }
    if (!(_DWORD)v7) {
      goto LABEL_86;
    }
    uint64_t v8 = v6;
    uint64_t v35 = __error();
    unsigned int v36 = strerror(*v35);
    unsigned int v45 = 136315394;
    uint64_t v46 = buffer;
    uint64_t v47 = 2080;
    unsigned int v48 = v36;
    uint64_t v40 = 22;
    int v39 = (stat *)&v45;
    id v10 = "failed to register the exclaves writable storage path %s (%s)\n";
LABEL_85:
    uint64_t v11 = (char *)&v41;
LABEL_10:
    int v12 = (void *)_os_log_send_and_compose_impl(v7, v11, 0LL, 0LL, &_mh_execute_header, v8, 0LL, v10, v39, v40, v41);

    if (v12) {
      sub_100053B7C((const char *)v12);
    }
    goto LABEL_87;
  }

  if (v44 == 255)
  {
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    id v13 = (os_log_s *)(id)qword_1000DBBD0;
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_99;
    }
    *(void *)buffer = 0LL;
    uint64_t v14 = sub_100053B4C(1);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
      CFStringRef v15 = v14;
    }
    else {
      CFStringRef v15 = v14 & 0xFFFFFFFE;
    }
    if ((_DWORD)v15)
    {
      LOWORD(v49.st_dev) = 0;
      CFStringRef v16 = (const char *)_os_log_send_and_compose_impl( v15,  buffer,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "Skipping the registration of the exclaves writable storage\n");
      goto LABEL_22;
    }

    goto LABEL_97;
  }

  if (qword_1000DBBD8 != -1) {
    dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
  }
  unsigned int v23 = (os_log_s *)(id)qword_1000DBBD0;
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)buffer = 0LL;
    uint64_t v24 = sub_100053B4C(1);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v25 = v24;
    }
    else {
      uint64_t v25 = v24 & 0xFFFFFFFE;
    }
    if ((_DWORD)v25)
    {
      v49.st_dev = 67109120;
      *(_DWORD *)&v49.st_mode = v44;
      unsigned int v26 = (const char *)_os_log_send_and_compose_impl( v25,  buffer,  0LL,  0LL,  &_mh_execute_header,  v23,  0LL,  "invalid exclaves status: %d\n",  &v49);
      id v27 = (char *)v26;
      if (v26) {
        sub_100053B7C(v26);
      }
    }

    else
    {
      id v27 = 0LL;
    }

    free(v27);
  }

  return 6LL;
}

LABEL_142:
          CFStringRef v72 = 0LL;
LABEL_143:
          free(v72);
        }
      }
    }

    else
    {
      int v58 = v2[339];
      if (os_log_type_enabled((os_log_t)v58, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)&v139.st_dev = 0LL;
        unsigned int v59 = sub_100053B4C(1);
        int v58 = v58;
        if (os_log_type_enabled((os_log_t)v58, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v60 = v59;
        }
        else {
          uint64_t v60 = v59 & 0xFFFFFFFE;
        }
        if ((_DWORD)v60)
        {
          *(_WORD *)id v138 = 0;
          LODWORD(v132) = 2;
          CFDateRef v61 = (char *)_os_log_send_and_compose_impl( v60,  &v139,  0LL,  0LL,  &_mh_execute_header,  v58,  0LL,  "not able to find the diskNode, skipped volume map",  v138,  v132);

          if (v61) {
            sub_100053B7C(v61);
          }
        }

        else
        {

          CFDateRef v61 = 0LL;
        }

        free(v61);
      }

      id v65 = 0LL;
    }

    CFStringRef v73 = v2[339];
    if (os_log_type_enabled((os_log_t)v73, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)&v139.st_dev = 0LL;
      unsigned int v74 = sub_100053B4C(1);
      unsigned int v75 = v73;
      if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v76 = v74;
      }
      else {
        uint64_t v76 = v74 & 0xFFFFFFFE;
      }
      if ((_DWORD)v76)
      {
        *(_DWORD *)id v138 = 67109120;
        *(_DWORD *)&v138[4] = a1;
        uint64_t v77 = (char *)_os_log_send_and_compose_impl( v76,  &v139,  0LL,  0LL,  &_mh_execute_header,  v75,  0LL,  "AKS Unloading the Identity of uid %d ",  v138);

        if (v77) {
          sub_100053B7C(v77);
        }
      }

      else
      {

        uint64_t v77 = 0LL;
      }

      free(v77);
    }

    uint64_t v78 = sub_100019B18(qword_1000DBD40);
    id v79 = (void *)objc_claimAutoreleasedReturnValue(v78);
    id v135 = v65;
    unsigned int v80 = [v79 unloadIdentityFromSession:a1 error:&v135];
    id v81 = v135;

    uint64_t v82 = v3[340];
    if (v80)
    {
      int v83 = v2[339];
      if (!os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_179;
      }
      *(void *)&v139.st_dev = 0LL;
      unsigned int v84 = sub_100053B4C(1);
      int v83 = v83;
      if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v85 = v84;
      }
      else {
        uint64_t v85 = v84 & 0xFFFFFFFE;
      }
      if ((_DWORD)v85)
      {
        *(_DWORD *)id v138 = 67109120;
        *(_DWORD *)&v138[4] = a1;
        uint64_t v86 = _os_log_send_and_compose_impl( v85,  &v139,  0LL,  0LL,  &_mh_execute_header,  v83,  0LL,  "AKS Unloading the Identity of uid %d SUCCESS ",  v138);
        goto LABEL_175;
      }
    }

    else
    {
      int v83 = v2[339];
      if (!os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_179;
      }
      *(void *)id v138 = 0LL;
      LODWORD(v87) = sub_100053B4C(1);
      int v83 = v83;
      if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v87 = v87;
      }
      else {
        uint64_t v87 = v87 & 0xFFFFFFFE;
      }
      if ((_DWORD)v87)
      {
        id v88 = [v81 code];
        v139.st_dev = 67109376;
        *(_DWORD *)&v139.st_mode = a1;
        LOWORD(v139.st_ino) = 2048;
        *(__darwin_ino64_t *)((char *)&v139.st_ino + 2) = (__darwin_ino64_t)v88;
        LODWORD(v132) = 18;
        uint64_t v86 = _os_log_send_and_compose_impl( v87,  v138,  0LL,  0LL,  &_mh_execute_header,  v83,  0LL,  "AKS Unloading the Identity of uid %d  FAILED with error:%ld",  &v139,  v132);
LABEL_175:
        id v89 = (char *)v86;

        if (v89) {
          sub_100053B7C(v89);
        }
        goto LABEL_178;
      }
    }

    id v89 = 0LL;
LABEL_178:
    free(v89);
LABEL_179:

    int v49 = *((_DWORD *)p_name + 826);
  }

  if (v49 != 1)
  {
    if (![(id)qword_1000DBA68 splitUserVolumeEnabled])
    {
LABEL_260:
      id v130 = sub_1000550DC(qword_1000DBA70, a1);
      uint64_t v131 = (void *)objc_claimAutoreleasedReturnValue(v130);
      sub_10006238C(qword_1000DBA78, v131);

      goto LABEL_261;
    }

    unsigned int v90 = sub_100083DF4((const __CFDictionary *)v6, kUMUserSessionVolumeDeviceNodeKey);
    id v91 = v3[340];
    if (v90)
    {
      uint64_t v92 = v90;
      uint64_t v93 = v2[339];
      if (os_log_type_enabled((os_log_t)v93, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)id v138 = 0LL;
        unsigned int v94 = sub_100053B4C(1);
        unsigned int v95 = v93;
        if (os_log_type_enabled(v95, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v96 = v94;
        }
        else {
          uint64_t v96 = v94 & 0xFFFFFFFE;
        }
        if ((_DWORD)v96)
        {
          v139.st_dev = 138412546;
          *(void *)&v139.st_mode = v92;
          WORD2(v139.st_ino) = 1024;
          *(_DWORD *)((char *)&v139.st_ino + 6) = a1;
          LODWORD(v132) = 18;
          uint64_t v97 = (char *)_os_log_send_and_compose_impl( v96,  v138,  0LL,  0LL,  &_mh_execute_header,  v95,  0LL,  "Calling AKSVolumeUnmap with disk:%@, uid:%d",  &v139,  v132);

          if (v97) {
            sub_100053B7C(v97);
          }
        }

        else
        {

          uint64_t v97 = 0LL;
        }

        free(v97);
      }

      uint64_t v102 = sub_100019B18(qword_1000DBD40);
      uint64_t v103 = (void *)objc_claimAutoreleasedReturnValue(v102);
      id v134 = 0LL;
      unsigned int v104 = [v103 unmapVolume:v92 error:&v134];
      id v105 = v134;

      uint64_t v106 = v3[340];
      if (v104)
      {
        uint64_t v98 = v2[339];
        if (os_log_type_enabled((os_log_t)v98, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)&v139.st_dev = 0LL;
          unsigned int v107 = sub_100053B4C(1);
          uint64_t v98 = v98;
          if (os_log_type_enabled((os_log_t)v98, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v108 = v107;
          }
          else {
            uint64_t v108 = v107 & 0xFFFFFFFE;
          }
          if ((_DWORD)v108)
          {
            *(_WORD *)id v138 = 0;
            uint64_t v109 = _os_log_send_and_compose_impl( v108,  &v139,  0LL,  0LL,  &_mh_execute_header,  v98,  0LL,  "Volume Unmap of old session succeeded");
            goto LABEL_220;
          }

          goto LABEL_222;
        }
      }

      else
      {
        uint64_t v98 = v2[339];
        if (os_log_type_enabled((os_log_t)v98, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)id v138 = 0LL;
          LODWORD(v110) = sub_100053B4C(1);
          uint64_t v98 = v98;
          if (os_log_type_enabled((os_log_t)v98, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v110 = v110;
          }
          else {
            uint64_t v110 = v110 & 0xFFFFFFFE;
          }
          if ((_DWORD)v110)
          {
            id v111 = [v105 code];
            v139.st_dev = 134217984;
            *(void *)&v139.st_mode = v111;
            uint64_t v109 = _os_log_send_and_compose_impl( v110,  v138,  0LL,  0LL,  &_mh_execute_header,  v98,  0LL,  "AKS volumeUnmap failed with error:%ld",  &v139);
LABEL_220:
            unsigned int v112 = (char *)v109;

            if (v112) {
              sub_100053B7C(v112);
            }
            goto LABEL_223;
          }

LABEL_222:
          unsigned int v112 = 0LL;
LABEL_223:
          free(v112);
        }
      }
    }

    else
    {
      uint64_t v98 = v2[339];
      if (os_log_type_enabled((os_log_t)v98, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)&v139.st_dev = 0LL;
        unsigned int v99 = sub_100053B4C(1);
        uint64_t v98 = v98;
        if (os_log_type_enabled((os_log_t)v98, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v100 = v99;
        }
        else {
          uint64_t v100 = v99 & 0xFFFFFFFE;
        }
        if ((_DWORD)v100)
        {
          *(_WORD *)id v138 = 0;
          LODWORD(v132) = 2;
          uint64_t v101 = (char *)_os_log_send_and_compose_impl( v100,  &v139,  0LL,  0LL,  &_mh_execute_header,  v98,  0LL,  "not able to find the diskNode, skipped volume map",  v138,  v132);

          if (v101) {
            sub_100053B7C(v101);
          }
        }

        else
        {

          uint64_t v101 = 0LL;
        }

        free(v101);
      }

      id v105 = 0LL;
    }

    id v113 = v2[339];
    if (os_log_type_enabled((os_log_t)v113, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)&v139.st_dev = 0LL;
      unsigned int v114 = sub_100053B4C(1);
      uint64_t v115 = v113;
      if (os_log_type_enabled(v115, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v116 = v114;
      }
      else {
        uint64_t v116 = v114 & 0xFFFFFFFE;
      }
      if ((_DWORD)v116)
      {
        *(_DWORD *)id v138 = 67109120;
        *(_DWORD *)&v138[4] = a1;
        unsigned int v117 = (char *)_os_log_send_and_compose_impl( v116,  &v139,  0LL,  0LL,  &_mh_execute_header,  v115,  0LL,  "AKS Unloading the Identity of uid %d ",  v138);

        if (v117) {
          sub_100053B7C(v117);
        }
      }

      else
      {

        unsigned int v117 = 0LL;
      }

      free(v117);
    }

    uint64_t v118 = sub_100019B18(qword_1000DBD40);
    uint64_t v119 = (void *)objc_claimAutoreleasedReturnValue(v118);
    id v133 = v105;
    unsigned int v120 = [v119 unloadIdentityFromSession:a1 error:&v133];
    id v121 = v133;

    uint64_t v122 = v3[340];
    if (v120)
    {
      uint64_t v123 = v2[339];
      if (!os_log_type_enabled(v123, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_259;
      }
      *(void *)&v139.st_dev = 0LL;
      unsigned int v124 = sub_100053B4C(1);
      uint64_t v123 = v123;
      if (os_log_type_enabled(v123, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v125 = v124;
      }
      else {
        uint64_t v125 = v124 & 0xFFFFFFFE;
      }
      if ((_DWORD)v125)
      {
        *(_DWORD *)id v138 = 67109120;
        *(_DWORD *)&v138[4] = a1;
        uint64_t v126 = _os_log_send_and_compose_impl( v125,  &v139,  0LL,  0LL,  &_mh_execute_header,  v123,  0LL,  "AKS Unloading the Identity of uid %d SUCCESS ",  v138);
        goto LABEL_255;
      }
    }

    else
    {
      uint64_t v123 = v2[339];
      if (!os_log_type_enabled(v123, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_259;
      }
      *(void *)id v138 = 0LL;
      LODWORD(v127) = sub_100053B4C(1);
      uint64_t v123 = v123;
      if (os_log_type_enabled(v123, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v127 = v127;
      }
      else {
        uint64_t v127 = v127 & 0xFFFFFFFE;
      }
      if ((_DWORD)v127)
      {
        id v128 = [v121 code];
        v139.st_dev = 67109376;
        *(_DWORD *)&v139.st_mode = a1;
        LOWORD(v139.st_ino) = 2048;
        *(__darwin_ino64_t *)((char *)&v139.st_ino + 2) = (__darwin_ino64_t)v128;
        LODWORD(v132) = 18;
        uint64_t v126 = _os_log_send_and_compose_impl( v127,  v138,  0LL,  0LL,  &_mh_execute_header,  v123,  0LL,  "AKS Unloading the Identity of uid %d  FAILED with error:%ld",  &v139,  v132);
LABEL_255:
        unsigned int v129 = (char *)v126;

        if (v129) {
          sub_100053B7C(v129);
        }
        goto LABEL_258;
      }
    }

    unsigned int v129 = 0LL;
LABEL_258:
    free(v129);
LABEL_259:

    goto LABEL_260;
  }

LABEL_261:
  CFRelease(v6);
}

uint64_t sub_1000524B8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return abort_with_reason(2LL, 6LL, a3, 0LL);
}

void sub_100052550(id a1)
{
  uint64_t v1 = objc_claimAutoreleasedReturnValue( +[NSXPCInterface interfaceWithProtocol:]( &OBJC_CLASS___NSXPCInterface,  "interfaceWithProtocol:",  &OBJC_PROTOCOL___RDClient));
  id v2 = (void *)qword_1000DBAC8;
  qword_1000DBAC8 = v1;
}

void sub_1000525C4(id a1)
{
  uint64_t v1 = objc_claimAutoreleasedReturnValue( +[NSXPCInterface interfaceWithProtocol:]( &OBJC_CLASS___NSXPCInterface,  "interfaceWithProtocol:",  &OBJC_PROTOCOL___BDBubbled));
  id v2 = (void *)qword_1000DBAD8;
  qword_1000DBAD8 = v1;
}

void sub_100052804(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    id v2 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) xpcConnection]);
    NSLog(@"Could not get proxy object for client connection: %@", v2);
  }

void sub_1000528BC(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    id v2 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) xpcConnection]);
    NSLog(@"Could not get proxy object for client connection: %@", v2);
  }

uint64_t sub_100052DB4(uint64_t a1)
{
  if (qword_1000DBAF0 != -1) {
    dispatch_once(&qword_1000DBAF0, &stru_1000CD5F0);
  }
  id v2 = (os_log_s *)(id)qword_1000DBAE8;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = 0LL;
    LODWORD(v3) = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v3 = v3;
    }
    else {
      uint64_t v3 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v3)
    {
      unsigned int v4 = *(void **)(a1 + 32);
      uint64_t v5 = v2;
      v9[0] = 67109120;
      v9[1] = [v4 pid];
      id v6 = (char *)_os_log_send_and_compose_impl( v3,  &v8,  0LL,  0LL,  &_mh_execute_header,  v5,  0LL,  "willSwitchToUser:client: Set wasToldWillSwitchUser: Pid:%d",  v9);

      if (v6) {
        sub_100053B7C(v6);
      }
    }

    else
    {
      id v6 = 0LL;
    }

    free(v6);
  }

  return (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16LL))();
}

uint64_t sub_100052FD4(uint64_t a1)
{
  if (qword_1000DBAF0 != -1) {
    dispatch_once(&qword_1000DBAF0, &stru_1000CD5F0);
  }
  id v2 = (os_log_s *)(id)qword_1000DBAE8;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = 0LL;
    LODWORD(v3) = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v3 = v3;
    }
    else {
      uint64_t v3 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v3)
    {
      unsigned int v4 = *(void **)(a1 + 32);
      uint64_t v5 = v2;
      v9[0] = 67109120;
      v9[1] = [v4 pid];
      id v6 = (char *)_os_log_send_and_compose_impl( v3,  &v8,  0LL,  0LL,  &_mh_execute_header,  v5,  0LL,  "personaListDidUpdateCompletionHandler was told to Pid:%d",  v9);

      if (v6) {
        sub_100053B7C(v6);
      }
    }

    else
    {
      id v6 = 0LL;
    }

    free(v6);
  }

  return (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16LL))();
}

uint64_t sub_100053314(uint64_t a1)
{
  if (qword_1000DBAF0 != -1) {
    dispatch_once(&qword_1000DBAF0, &stru_1000CD5F0);
  }
  id v2 = (os_log_s *)(id)qword_1000DBAE8;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = 0LL;
    LODWORD(v3) = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v3 = v3;
    }
    else {
      uint64_t v3 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v3)
    {
      unsigned int v4 = *(void **)(a1 + 32);
      uint64_t v5 = v2;
      v9[0] = 67109120;
      v9[1] = [v4 pid];
      id v6 = (char *)_os_log_send_and_compose_impl( v3,  &v8,  0LL,  0LL,  &_mh_execute_header,  v5,  0LL,  "personaUpdateCallbackForMachServiceCompletionHandler was told to Pid:%d",  v9);

      if (v6) {
        sub_100053B7C(v6);
      }
    }

    else
    {
      id v6 = 0LL;
    }

    free(v6);
  }

  return (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16LL))();
}

void sub_100053B18(id a1)
{
  os_log_t v1 = os_log_create(off_1000DAE70, "legacy");
  id v2 = (void *)qword_1000DBAE8;
  qword_1000DBAE8 = (uint64_t)v1;
}

uint64_t sub_100053B4C(int a1)
{
  if (a1) {
    unsigned int v1 = 3;
  }
  else {
    unsigned int v1 = 1;
  }
  if (byte_1000DBD39) {
    BOOL v2 = byte_1000DBD38 == 0;
  }
  else {
    BOOL v2 = 0;
  }
  if (v2) {
    return v1;
  }
  else {
    return 2LL;
  }
}

void sub_100053B7C(const char *a1)
{
  if (byte_1000DBD38) {
    fprintf(__stdoutp, "UMD_INIT: %s\n", a1);
  }
  sub_100063F0C(qword_1000DBAF8, (uint64_t)a1);
}

uint64_t sub_100053BD4()
{
  if (qword_1000DBB08 != -1) {
    dispatch_once(&qword_1000DBB08, &stru_1000CD610);
  }
  return byte_1000DBB00;
}

void sub_100053C14(id a1)
{
  size_t __len = 1023LL;
  bzero(__big, 0x400uLL);
  if (!sysctlbyname("kern.bootargs", __big, &__len, 0LL, 0LL))
  {
    if (strnstr(__big, "keybag_initlog", __len)) {
      byte_1000DBB00 = 1;
    }
  }

uint64_t start(int a1, uint64_t a2)
{
  uint64_t v4 = objc_claimAutoreleasedReturnValue(+[UMDProviderSideEffects sideEffects](&OBJC_CLASS___UMDProviderSideEffects, "sideEffects"));
  uint64_t v5 = (void *)qword_1000DBD40;
  qword_1000DBD40 = v4;

  UMLSetInternalLogHandlers(sub_100053B4C, sub_100053B7C);
  if (a1 == 2)
  {
    id v6 = *(const char **)(a2 + 8);
    if (!strcmp(v6, "--init"))
    {
      sub_100054070();
    }

    else
    {
      if (strcmp(v6, "--switch")) {
        goto LABEL_4;
      }
      sub_1000544AC();
    }

    exit(0);
  }

size_t sub_100054070()
{
  byte_1000DBD38 = 1;
  if (sub_1000547DC())
  {
    uint64_t v0 = __stdoutp;
    unsigned int v1 = "****** DIAGNOSTICS MODE ENABLED, SKIP INIT ****\n";
    size_t v2 = 48LL;
    return fwrite(v1, v2, 1uLL, v0);
  }

  if (os_variant_uses_ephemeral_storage("com.apple.mobile.keybagd"))
  {
    uint64_t v0 = __stdoutp;
    unsigned int v1 = "****** DEVICE HAS EPHEMERAL DATA VOLUME, SKIP INIT ****\n";
    size_t v2 = 56LL;
    return fwrite(v1, v2, 1uLL, v0);
  }

  if (qword_1000DBB08 != -1) {
    dispatch_once(&qword_1000DBB08, &stru_1000CD610);
  }
  if (byte_1000DBB00) {
    uint64_t v4 = "/var/logs/usermanagerd_init.log";
  }
  else {
    uint64_t v4 = "/var/logs/usermanagerd.log";
  }
  uint64_t v5 = sub_100063D18((uint64_t)&OBJC_CLASS___UMDRotatingLog, (void *)qword_1000DBD40, v4, (void *)0x100000, 3);
  uint64_t v6 = objc_claimAutoreleasedReturnValue(v5);
  uint64_t v7 = (void *)qword_1000DBAF8;
  qword_1000DBAF8 = v6;

  fwrite("****** IN UMD_INIT ****\n", 0x18uLL, 1uLL, __stdoutp);
  dispatch_queue_t v8 = dispatch_queue_create("com.apple.system.libinfo.muser", 0LL);
  CFNumberRef v9 = (void *)qword_1000DBD50;
  qword_1000DBD50 = (uint64_t)v8;

  fwrite("****** STARTING EARLYBOOT SETUP ****\n", 0x25uLL, 1uLL, __stdoutp);
  if (qword_1000DBB18 != -1) {
    dispatch_once(&qword_1000DBB18, &stru_1000CD630);
  }
  uint64_t v10 = (os_log_s *)(id)qword_1000DBB10;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v32 = 0LL;
    if (byte_1000DBD39) {
      BOOL v11 = byte_1000DBD38 == 0;
    }
    else {
      BOOL v11 = 0;
    }
    if (v11) {
      unsigned int v12 = 3;
    }
    else {
      unsigned int v12 = 2;
    }
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v13 = v12;
    }
    else {
      uint64_t v13 = 2LL;
    }
    __int16 v31 = 0;
    unsigned int v14 = (const char *)_os_log_send_and_compose_impl( v13,  &v32,  0LL,  0LL,  &_mh_execute_header,  v10,  0LL,  "STARTING EARLYBOOT SETUP",  &v31,  2);
    uint64_t v15 = (char *)v14;
    if (v14) {
      sub_100053B7C(v14);
    }
    free(v15);
  }

  dispatch_queue_t v16 = dispatch_queue_create("com.apple.system.libinfo.muser", 0LL);
  id v17 = (void *)qword_1000DBD50;
  qword_1000DBD50 = (uint64_t)v16;

  if (sub_1000548AC())
  {
    if (qword_1000DBB18 != -1) {
      dispatch_once(&qword_1000DBB18, &stru_1000CD630);
    }
    dispatch_queue_t v18 = (os_log_s *)(id)qword_1000DBB10;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v32 = 0LL;
      if (byte_1000DBD39) {
        BOOL v19 = byte_1000DBD38 == 0;
      }
      else {
        BOOL v19 = 0;
      }
      if (v19) {
        unsigned int v20 = 3;
      }
      else {
        unsigned int v20 = 2;
      }
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v21 = v20;
      }
      else {
        uint64_t v21 = 2LL;
      }
      __int16 v31 = 0;
      LODWORD(v30) = 2;
      dispatch_queue_t v22 = (const char *)_os_log_send_and_compose_impl( v21,  &v32,  0LL,  0LL,  &_mh_execute_header,  v18,  0LL,  "Enhanced APFS Mode Set",  &v31,  v30);
      unsigned int v23 = (char *)v22;
      if (v22) {
        sub_100053B7C(v22);
      }
      free(v23);
    }

    byte_1000DBD3A = 1;
  }

  sub_100038894();
  if (qword_1000DBB18 != -1) {
    dispatch_once(&qword_1000DBB18, &stru_1000CD630);
  }
  dispatch_queue_t v24 = (os_log_s *)(id)qword_1000DBB10;
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v32 = 0LL;
    if (byte_1000DBD39) {
      BOOL v25 = byte_1000DBD38 == 0;
    }
    else {
      BOOL v25 = 0;
    }
    if (v25) {
      unsigned int v26 = 3;
    }
    else {
      unsigned int v26 = 2;
    }
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v27 = v26;
    }
    else {
      uint64_t v27 = 2LL;
    }
    __int16 v31 = 0;
    LODWORD(v30) = 2;
    unsigned int v28 = (const char *)_os_log_send_and_compose_impl( v27,  &v32,  0LL,  0LL,  &_mh_execute_header,  v24,  0LL,  "DONE EARLYBOOT SETUP",  &v31,  v30);
    uint64_t v29 = (char *)v28;
    if (v28) {
      sub_100053B7C(v28);
    }
    free(v29);
  }

  fwrite("****** DONE EARLYBOOT SETUP ****\n", 0x21uLL, 1uLL, __stdoutp);
  return fwrite("****** DONE UMD_INIT ****\n", 0x1AuLL, 1uLL, __stdoutp);
}

void sub_1000544AC()
{
  byte_1000DBD39 = 1;
  uint64_t v0 = sub_100063D18( (uint64_t)&OBJC_CLASS___UMDRotatingLog,  (void *)qword_1000DBD40,  "/var/logs/usermanagerd.log",  (void *)0x100000,  3);
  uint64_t v1 = objc_claimAutoreleasedReturnValue(v0);
  size_t v2 = (void *)qword_1000DBAF8;
  qword_1000DBAF8 = v1;

  dispatch_queue_t v3 = dispatch_queue_create("com.apple.system.libinfo.muser", 0LL);
  uint64_t v4 = (void *)qword_1000DBD50;
  qword_1000DBD50 = (uint64_t)v3;

  if (qword_1000DBB28 != -1) {
    dispatch_once(&qword_1000DBB28, &stru_1000CD650);
  }
  uint64_t v5 = (os_log_s *)(id)qword_1000DBB20;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v25 = 0LL;
    if (byte_1000DBD39) {
      BOOL v6 = byte_1000DBD38 == 0;
    }
    else {
      BOOL v6 = 0;
    }
    if (v6) {
      unsigned int v7 = 1;
    }
    else {
      unsigned int v7 = 2;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = v7 & 2;
    }
    if ((_DWORD)v8)
    {
      __int16 v24 = 0;
      CFNumberRef v9 = (const char *)_os_log_send_and_compose_impl( v8,  &v25,  0LL,  0LL,  &_mh_execute_header,  v5,  0LL,  "Starting User Switch Task...",  &v24,  2);
      uint64_t v10 = (char *)v9;
      if (v9) {
        sub_100053B7C(v9);
      }
    }

    else
    {
      uint64_t v10 = 0LL;
    }

    free(v10);
  }

  if (sub_1000548AC())
  {
    if (qword_1000DBB18 != -1) {
      dispatch_once(&qword_1000DBB18, &stru_1000CD630);
    }
    BOOL v11 = (os_log_s *)(id)qword_1000DBB10;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v25 = 0LL;
      if (byte_1000DBD39) {
        BOOL v12 = byte_1000DBD38 == 0;
      }
      else {
        BOOL v12 = 0;
      }
      if (v12) {
        unsigned int v13 = 3;
      }
      else {
        unsigned int v13 = 2;
      }
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v14 = v13;
      }
      else {
        uint64_t v14 = 2LL;
      }
      __int16 v24 = 0;
      LODWORD(v23) = 2;
      uint64_t v15 = (const char *)_os_log_send_and_compose_impl( v14,  &v25,  0LL,  0LL,  &_mh_execute_header,  v11,  0LL,  "Enhanced APFS Mode Set",  &v24,  v23);
      dispatch_queue_t v16 = (char *)v15;
      if (v15) {
        sub_100053B7C(v15);
      }
      free(v16);
    }

    byte_1000DBD3A = 1;
  }

  sub_100044D90();
  if (qword_1000DBB28 != -1) {
    dispatch_once(&qword_1000DBB28, &stru_1000CD650);
  }
  id v17 = (os_log_s *)(id)qword_1000DBB20;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v25 = 0LL;
    if (byte_1000DBD39) {
      BOOL v18 = byte_1000DBD38 == 0;
    }
    else {
      BOOL v18 = 0;
    }
    if (v18) {
      unsigned int v19 = 1;
    }
    else {
      unsigned int v19 = 2;
    }
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v20 = v19;
    }
    else {
      uint64_t v20 = v19 & 2;
    }
    if ((_DWORD)v20)
    {
      __int16 v24 = 0;
      LODWORD(v23) = 2;
      uint64_t v21 = (const char *)_os_log_send_and_compose_impl( v20,  &v25,  0LL,  0LL,  &_mh_execute_header,  v17,  0LL,  "User Switch Task complete",  &v24,  v23);
      dispatch_queue_t v22 = (char *)v21;
      if (v21) {
        sub_100053B7C(v21);
      }
    }

    else
    {
      dispatch_queue_t v22 = 0LL;
    }

    free(v22);
  }
}

BOOL sub_1000547DC()
{
  uint64_t v0 = (char *)malloc(0x16uLL);
  if (v0)
  {
    uint64_t v1 = v0;
    snprintf(v0, 0x16uLL, "%s%s", "IODeviceTree", ":/product");
    io_registry_entry_t v2 = IORegistryEntryFromPath(kIOMainPortDefault, v1);
    if (v2)
    {
      io_object_t v3 = v2;
      CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(v2, @"boot-ios-diagnostics", kCFAllocatorDefault, 0);
      if (CFProperty)
      {
        CFRelease(CFProperty);
        int v5 = 1;
      }

      else
      {
        int v5 = 0;
      }

      IOObjectRelease(v3);
    }

    else
    {
      int v5 = -8;
    }

    free(v1);
  }

  else
  {
    int v5 = -5;
  }

  return v5 == 1;
}

BOOL sub_1000548AC()
{
  io_registry_entry_t v0 = IORegistryEntryFromPath(kIOMainPortDefault, "IODeviceTree:/filesystems");
  if (v0)
  {
    io_object_t v1 = v0;
    CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(v0, @"e-apfs", kCFAllocatorDefault, 0);
    BOOL v3 = CFProperty != 0LL;
    if (CFProperty)
    {
      CFRelease(CFProperty);
      if (qword_1000DBB18 != -1) {
        dispatch_once(&qword_1000DBB18, &stru_1000CD630);
      }
      uint64_t v4 = (os_log_s *)(id)qword_1000DBB10;
      if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_33;
      }
      uint64_t v15 = 0LL;
      if (byte_1000DBD39) {
        BOOL v5 = byte_1000DBD38 == 0;
      }
      else {
        BOOL v5 = 0;
      }
      if (v5) {
        unsigned int v6 = 3;
      }
      else {
        unsigned int v6 = 2;
      }
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v7 = v6;
      }
      else {
        uint64_t v7 = 2LL;
      }
      LOWORD(v14) = 0;
      uint64_t v8 = (const char *)_os_log_send_and_compose_impl( v7,  &v15,  0LL,  0LL,  &_mh_execute_header,  v4,  0LL,  "Found EAPFS property in IODT",  &v14,  2,  v14);
    }

    else
    {
      if (qword_1000DBB18 != -1) {
        dispatch_once(&qword_1000DBB18, &stru_1000CD630);
      }
      uint64_t v4 = (os_log_s *)(id)qword_1000DBB10;
      if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_33;
      }
      uint64_t v15 = 0LL;
      if (byte_1000DBD39) {
        BOOL v9 = byte_1000DBD38 == 0;
      }
      else {
        BOOL v9 = 0;
      }
      if (v9) {
        unsigned int v10 = 3;
      }
      else {
        unsigned int v10 = 2;
      }
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = 2LL;
      }
      LOWORD(v14) = 0;
      uint64_t v8 = (const char *)_os_log_send_and_compose_impl( v11,  &v15,  0LL,  0LL,  &_mh_execute_header,  v4,  0LL,  "Could not Find EAPFS property in IODT",  &v14,  2,  v14);
    }

    BOOL v12 = (char *)v8;
    if (v8) {
      sub_100053B7C(v8);
    }
    free(v12);
LABEL_33:

    IOObjectRelease(v1);
    return v3;
  }

  return 0LL;
}

void sub_100054AAC(id a1)
{
  os_log_t v1 = os_log_create(off_1000DAE70, "legacy");
  io_registry_entry_t v2 = (void *)qword_1000DBB10;
  qword_1000DBB10 = (uint64_t)v1;
}

void sub_100054ADC(id a1)
{
  os_log_t v1 = os_log_create(off_1000DAE70, "default");
  io_registry_entry_t v2 = (void *)qword_1000DBB20;
  qword_1000DBB20 = (uint64_t)v1;
}

id *sub_100054B0C(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_self(a1);
  uint64_t v4 = sub_100054B58((id *)objc_alloc(&OBJC_CLASS___UMDUserManager), v3);

  return v4;
}

id *sub_100054B58(id *a1, void *a2)
{
  id v4 = a2;
  if (a1)
  {
    v9.receiver = a1;
    v9.super_class = (Class)&OBJC_CLASS___UMDUserManager;
    BOOL v5 = (id *)objc_msgSendSuper2(&v9, "init");
    if (!v5) {
      sub_1000A9AD0();
    }
    a1 = v5;
    uint64_t v6 = objc_claimAutoreleasedReturnValue([v4 se]);
    id v7 = a1[1];
    a1[1] = (id)v6;

    objc_storeStrong(a1 + 2, a2);
  }

  return a1;
}

id sub_100054BE8(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    __int128 v14 = 0u;
    __int128 v15 = 0u;
    __int128 v12 = 0u;
    __int128 v13 = 0u;
    id v4 = *(id *)(a1 + 24);
    id v5 = [v4 countByEnumeratingWithState:&v12 objects:v16 count:16];
    if (v5)
    {
      uint64_t v6 = *(void *)v13;
      while (2)
      {
        for (CFIndex i = 0LL; i != v5; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v13 != v6) {
            objc_enumerationMutation(v4);
          }
          uint64_t v8 = *(void **)(*((void *)&v12 + 1) + 8LL * (void)i);
          objc_super v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "objectForKeyedSubscript:", kUMUserSessionAlternateDSIDKey, (void)v12));
          if (v9)
          {
            uint64_t v10 = objc_opt_class(&OBJC_CLASS___NSString);
            if ((objc_opt_isKindOfClass(v9, v10) & 1) != 0
              && ([v9 isEqualToString:v3] & 1) != 0)
            {
              id v5 = v8;

              goto LABEL_14;
            }
          }
        }

        id v5 = [v4 countByEnumeratingWithState:&v12 objects:v16 count:16];
        if (v5) {
          continue;
        }
        break;
      }
    }

id sub_100054D5C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    __int128 v14 = 0u;
    __int128 v15 = 0u;
    __int128 v12 = 0u;
    __int128 v13 = 0u;
    id v4 = *(id *)(a1 + 24);
    id v5 = [v4 countByEnumeratingWithState:&v12 objects:v16 count:16];
    if (v5)
    {
      uint64_t v6 = *(void *)v13;
      while (2)
      {
        for (CFIndex i = 0LL; i != v5; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v13 != v6) {
            objc_enumerationMutation(v4);
          }
          uint64_t v8 = *(void **)(*((void *)&v12 + 1) + 8LL * (void)i);
          objc_super v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "objectForKeyedSubscript:", kUMUserSessionUUIDKey, (void)v12));
          if (v9)
          {
            uint64_t v10 = objc_opt_class(&OBJC_CLASS___NSString);
            if ((objc_opt_isKindOfClass(v9, v10) & 1) != 0
              && ([v9 isEqualToString:v3] & 1) != 0)
            {
              id v5 = v8;

              goto LABEL_14;
            }
          }
        }

        id v5 = [v4 countByEnumeratingWithState:&v12 objects:v16 count:16];
        if (v5) {
          continue;
        }
        break;
      }
    }

id sub_100054ED0(uint64_t a1, int a2)
{
  if (!a1) {
    return 0LL;
  }
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  id v3 = *(id *)(a1 + 24);
  id v4 = [v3 countByEnumeratingWithState:&v13 objects:v17 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v14;
    while (2)
    {
      for (CFIndex i = 0LL; i != v5; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v14 != v6) {
          objc_enumerationMutation(v3);
        }
        uint64_t v8 = *(void **)(*((void *)&v13 + 1) + 8LL * (void)i);
        objc_super v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "objectForKeyedSubscript:", kUMUserSessionIDKey, (void)v13));
        if (v9)
        {
          uint64_t v10 = objc_opt_class(&OBJC_CLASS___NSNumber);
          if ((objc_opt_isKindOfClass(v9, v10) & 1) != 0 && [v9 unsignedIntValue] == a2)
          {
            id v11 = v8;

            goto LABEL_14;
          }
        }
      }

      id v5 = [v3 countByEnumeratingWithState:&v13 objects:v17 count:16];
      if (v5) {
        continue;
      }
      break;
    }
  }

  id v11 = 0LL;
LABEL_14:

  return v11;
}

uint64_t sub_10005503C(uint64_t a1, void *a2)
{
  if (!a1) {
    return 0LL;
  }
  id v2 = sub_100054D5C(a1, a2);
  id v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  id v4 = v3;
  if (v3)
  {
    id v5 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:kUMUserSessionIDKey]);
    if (v5 && (uint64_t v6 = objc_opt_class(&OBJC_CLASS___NSNumber), (objc_opt_isKindOfClass(v5, v6) & 1) != 0)) {
      uint64_t v7 = (uint64_t)[v5 unsignedIntValue];
    }
    else {
      uint64_t v7 = 0xFFFFFFFFLL;
    }
  }

  else
  {
    uint64_t v7 = 0xFFFFFFFFLL;
  }

  return v7;
}

id sub_1000550DC(uint64_t a1, int a2)
{
  if (a1)
  {
    id v2 = sub_100054ED0(a1, a2);
    id v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
    id v4 = v3;
    if (v3)
    {
      id v5 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:kUMUserSessionUUIDKey]);
      if (v5 && (uint64_t v6 = objc_opt_class(&OBJC_CLASS___NSString), (objc_opt_isKindOfClass(v5, v6) & 1) != 0)) {
        id v7 = v5;
      }
      else {
        id v7 = 0LL;
      }
    }

    else
    {
      id v7 = 0LL;
    }
  }

  else
  {
    id v7 = 0LL;
  }

  return v7;
}

uint64_t sub_100055178(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = sub_100018E80(*(void *)(result + 8));
    id v2 = (void *)objc_claimAutoreleasedReturnValue(v1);
    uint64_t v3 = sub_100019B60((uint64_t)v2);

    return v3;
  }

  return result;
}

void *sub_1000551B4(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    v12[0] = @"BLOB";
    v12[1] = @"BLOBLEN";
    v13[0] = v3;
    id v5 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v3 length]));
    v13[1] = v5;
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v13,  v12,  2LL));
    id v7 = sub_100085444((uint64_t)v6);
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(v7);

    if (!v8) {
      sub_1000A9AD0();
    }
    uint64_t v9 = sub_100019434(a1[1]);
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
    a1 = [v10 atomicallyWriteData:v8 toPath:@"/private/var/keybags/nextsession.kb" error:0];
  }

  return a1;
}

os_log_s *sub_1000552D4(uint64_t a1)
{
  if (a1)
  {
    id v1 = *(id *)(a1 + 8);
    uint64_t v2 = sub_100019434((uint64_t)v1);
    id v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
    id v34 = 0LL;
    id v4 = (void *)objc_claimAutoreleasedReturnValue([v3 dataWithContentsOfFile:@"/private/var/keybags/nextsession.kb" error:&v34]);
    id v5 = v34;

    if (v4)
    {
      id v6 = sub_10008573C((uint64_t)v4);
      id v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
      id v8 = v7;
      if (!v7)
      {
        if (qword_1000DBB38 != -1) {
          dispatch_once(&qword_1000DBB38, &stru_1000CD670);
        }
        uint64_t v10 = (os_log_s *)(id)qword_1000DBB30;
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          uint64_t v33 = 0LL;
          unsigned int v16 = sub_100053B4C(0);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
            uint64_t v17 = v16;
          }
          else {
            uint64_t v17 = v16 & 0xFFFFFFFE;
          }
          if ((_DWORD)v17)
          {
            LOWORD(v35[0]) = 0;
            BOOL v18 = (const char *)_os_log_send_and_compose_impl( v17,  &v33,  0LL,  0LL,  &_mh_execute_header,  v10,  16LL,  "Failed to load next session data: data was not properly formatted",  v35,  2);
            unsigned int v19 = (char *)v18;
            if (v18) {
              sub_100053B7C(v18);
            }
          }

          else
          {
            unsigned int v19 = 0LL;
          }

          free(v19);
        }

        goto LABEL_70;
      }

      id v9 = sub_1000853C8(v7, (uint64_t)@"BLOB");
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
      if (v10)
      {
        unsigned int v11 = sub_100084F14(v8, (uint64_t)@"BLOBLEN", 0LL);
        if (v11)
        {
          if (-[os_log_s length](v10, "length") == (id)v11)
          {
            uint64_t v10 = v10;
            __int128 v12 = v10;
LABEL_71:

            goto LABEL_72;
          }

          if (qword_1000DBB38 != -1) {
            dispatch_once(&qword_1000DBB38, &stru_1000CD670);
          }
          uint64_t v23 = (os_log_s *)(id)qword_1000DBB30;
          if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
            goto LABEL_67;
          }
          uint64_t v33 = 0LL;
          unsigned int v29 = sub_100053B4C(0);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
            uint64_t v30 = v29;
          }
          else {
            uint64_t v30 = v29 & 0xFFFFFFFE;
          }
          if ((_DWORD)v30)
          {
            LOWORD(v35[0]) = 0;
            unsigned int v26 = (const char *)_os_log_send_and_compose_impl( v30,  &v33,  0LL,  0LL,  &_mh_execute_header,  v23,  16LL,  "Failed to load next session data: data length does not match",  v35,  2);
LABEL_60:
            __int16 v31 = (char *)v26;
            if (v26) {
              sub_100053B7C(v26);
            }
            goto LABEL_66;
          }
        }

        else
        {
          if (qword_1000DBB38 != -1) {
            dispatch_once(&qword_1000DBB38, &stru_1000CD670);
          }
          uint64_t v23 = (os_log_s *)(id)qword_1000DBB30;
          if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
            goto LABEL_67;
          }
          uint64_t v33 = 0LL;
          unsigned int v27 = sub_100053B4C(0);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
            uint64_t v28 = v27;
          }
          else {
            uint64_t v28 = v27 & 0xFFFFFFFE;
          }
          if ((_DWORD)v28)
          {
            LOWORD(v35[0]) = 0;
            unsigned int v26 = (const char *)_os_log_send_and_compose_impl( v28,  &v33,  0LL,  0LL,  &_mh_execute_header,  v23,  16LL,  "Failed to load next session data: illegal data length",  v35,  2);
            goto LABEL_60;
          }
        }
      }

      else
      {
        if (qword_1000DBB38 != -1) {
          dispatch_once(&qword_1000DBB38, &stru_1000CD670);
        }
        uint64_t v23 = (os_log_s *)(id)qword_1000DBB30;
        if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
          goto LABEL_67;
        }
        uint64_t v33 = 0LL;
        unsigned int v24 = sub_100053B4C(0);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
          uint64_t v25 = v24;
        }
        else {
          uint64_t v25 = v24 & 0xFFFFFFFE;
        }
        if ((_DWORD)v25)
        {
          LOWORD(v35[0]) = 0;
          unsigned int v26 = (const char *)_os_log_send_and_compose_impl( v25,  &v33,  0LL,  0LL,  &_mh_execute_header,  v23,  16LL,  "Failed to load next session data: illegal data value",  v35,  2);
          goto LABEL_60;
        }
      }

      __int16 v31 = 0LL;
LABEL_66:
      free(v31);
LABEL_67:

LABEL_70:
      __int128 v12 = 0LL;
      goto LABEL_71;
    }

    if ([v5 code] == (id)2)
    {
      if (qword_1000DBB38 != -1) {
        dispatch_once(&qword_1000DBB38, &stru_1000CD670);
      }
      id v8 = (id)qword_1000DBB30;
      if (!os_log_type_enabled((os_log_t)v8, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_64;
      }
      uint64_t v33 = 0LL;
      unsigned int v13 = sub_100053B4C(0);
      if (os_log_type_enabled((os_log_t)v8, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v14 = v13;
      }
      else {
        uint64_t v14 = v13 & 0xFFFFFFFE;
      }
      if ((_DWORD)v14)
      {
        LOWORD(v35[0]) = 0;
        __int128 v15 = (void *)_os_log_send_and_compose_impl( v14,  &v33,  0LL,  0LL,  &_mh_execute_header,  v8,  0LL,  "Failed to load next session data: file does not exist",  v35,  2);
        if (!v15) {
          goto LABEL_63;
        }
        goto LABEL_35;
      }
    }

    else
    {
      if (qword_1000DBB38 != -1) {
        dispatch_once(&qword_1000DBB38, &stru_1000CD670);
      }
      id v8 = (id)qword_1000DBB30;
      if (!os_log_type_enabled((os_log_t)v8, OS_LOG_TYPE_ERROR)) {
        goto LABEL_64;
      }
      uint64_t v33 = 0LL;
      LODWORD(v20) = sub_100053B4C(0);
      if (os_log_type_enabled((os_log_t)v8, OS_LOG_TYPE_ERROR)) {
        uint64_t v20 = v20;
      }
      else {
        uint64_t v20 = v20 & 0xFFFFFFFE;
      }
      if ((_DWORD)v20)
      {
        id v21 = v8;
        unsigned int v22 = [v5 code];
        v35[0] = 67109120;
        v35[1] = v22;
        __int128 v15 = (void *)_os_log_send_and_compose_impl( v20,  &v33,  0LL,  0LL,  &_mh_execute_header,  v21,  16LL,  "Failed to load next session data: %{darwin.errno}d",  v35,  8);

        if (!v15)
        {
LABEL_63:
          free(v15);
LABEL_64:
          __int128 v12 = 0LL;
LABEL_72:

          return v12;
        }

LABEL_35:
        sub_100053B7C((const char *)v15);
        goto LABEL_63;
      }
    }

    __int128 v15 = 0LL;
    goto LABEL_63;
  }

  return (os_log_s *)0LL;
}

      sub_100053B7C((const char *)v20);
      goto LABEL_39;
    }

    goto LABEL_38;
  }

  unsigned int v11 = sub_100056C1C((uint64_t)a1, v4);
  __int128 v12 = objc_claimAutoreleasedReturnValue(v11);
LABEL_26:
  unsigned int v22 = (void *)v12;
LABEL_42:

  return v22;
}

          uint64_t v23 = 0LL;
          goto LABEL_36;
        }

        uint64_t v43 = 0u;
        uint64_t v44 = 0u;
        CFTypeID v41 = 0u;
        unsigned int v42 = 0u;
        uint64_t v10 = (os_log_s *)*(id *)(v9 + 16);
        unsigned int v11 = -[os_log_s countByEnumeratingWithState:objects:count:]( v10,  "countByEnumeratingWithState:objects:count:",  &v41,  v52,  16LL);
        if (v11)
        {
          __int128 v12 = v11;
          unsigned int v13 = *(void *)v42;
          while (2)
          {
            for (j = 0LL; j != v12; j = (char *)j + 1)
            {
              if (*(void *)v42 != v13) {
                objc_enumerationMutation(v10);
              }
              __int128 v15 = *(void *)(*((void *)&v41 + 1) + 8LL * (void)j);
              if (v15)
              {
                unsigned int v16 = *(id *)(v15 + 120);
                if (v16)
                {
                  uint64_t v17 = v16;
                  BOOL v18 = *(void *)(v9 + 24);
                  unsigned int v19 = *(id *)(v15 + 120);
                  LOBYTE(v1_Block_object_dispose(va, 8) = [v19 isEqual:v18];

                  if ((v18 & 1) == 0)
                  {
                    if (qword_1000DBBC8 != -1) {
                      dispatch_once(&qword_1000DBBC8, &stru_1000CDB00);
                    }
                    id v5 = v38;
                    unsigned int v24 = (os_log_s *)(id)qword_1000DBBC0;
                    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
                    {
                      v40[0] = 0LL;
                      LODWORD(v25) = sub_100053B4C(0);
                      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
                        uint64_t v25 = v25;
                      }
                      else {
                        uint64_t v25 = v25 & 0xFFFFFFFE;
                      }
                      if ((_DWORD)v25)
                      {
                        unsigned int v26 = *(void **)(v15 + 120);
                        unsigned int v27 = *(void *)(v9 + 24);
                        *(_DWORD *)int v49 = 138543618;
                        *(void *)&v49[4] = v26;
                        unsigned int v50 = 2114;
                        uint64_t v51 = v27;
                        uint64_t v28 = v26;
                        unsigned int v29 = v24;
                        uint64_t v30 = (char *)_os_log_send_and_compose_impl( v25,  v40,  0LL,  0LL,  &_mh_execute_header,  v29,  16LL,  "Failed to generate dict for persona manifest user: persona user UUID mismatch: % {public}@ != %{public}@",  v49,  22);

                        if (v30) {
                          sub_100053B7C(v30);
                        }
                      }

                      else
                      {
                        uint64_t v30 = 0LL;
                      }

                      free(v30);
                    }

                    id v4 = v39;
                    goto LABEL_35;
                  }
                }
              }
            }

            __int128 v12 = -[os_log_s countByEnumeratingWithState:objects:count:]( v10,  "countByEnumeratingWithState:objects:count:",  &v41,  v52,  16LL);
            if (v12) {
              continue;
            }
            break;
          }
        }

        id v5 = v38;
        id v4 = v39;
        id v7 = v36;
        uint64_t v20 = *(id *)(v9 + 16);
        id v21 = (void *)objc_claimAutoreleasedReturnValue( +[UMDPersonaManifest dataForPersonaSet:]( &OBJC_CLASS___UMDPersonaManifest,  "dataForPersonaSet:",  v20));
        unsigned int v22 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v9 + 24) UUIDString]);
        [v39 setObject:v21 forKeyedSubscript:v22];
      }

      id v6 = [v38 countByEnumeratingWithState:&v45 objects:v53 count:16];
      if (v6) {
        continue;
      }
      break;
    }
  }

  uint64_t v23 = v4;
LABEL_36:

  return v23;
}

                id v4 = v11;
              }
            }
          }
        }
      }
    }
  }

uint64_t sub_100055894(uint64_t a1, int a2, int a3)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v36 = 0LL;
  uint64_t v37 = 0LL;
  uint64_t v38 = 0LL;
  v35[0] = a3;
  v35[1] = a2;
  id v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", v35, 32LL));
  id v7 = *(id *)(a1 + 8);
  uint64_t v8 = sub_100019B18((uint64_t)v7);
  id v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
  id v28 = 0LL;
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v9 dataWrappingDataWithDeviceClassF:v6 error:&v28]);
  id v11 = v28;

  if (!v10)
  {
    if (qword_1000DBB38 != -1) {
      dispatch_once(&qword_1000DBB38, &stru_1000CD670);
    }
    __int128 v12 = (os_log_s *)(id)qword_1000DBB30;
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      goto LABEL_42;
    }
    uint64_t v27 = 0LL;
    unsigned int v17 = sub_100053B4C(0);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      uint64_t v18 = v17;
    }
    else {
      uint64_t v18 = v17 & 0xFFFFFFFE;
    }
    if ((_DWORD)v18)
    {
      int v29 = 67109634;
      int v30 = a2;
      __int16 v31 = 1024;
      int v32 = a3;
      __int16 v33 = 2114;
      id v34 = v11;
      unsigned int v19 = (const char *)_os_log_send_and_compose_impl( v18,  &v27,  0LL,  0LL,  &_mh_execute_header,  v12,  16LL,  "Failed to save next session (previous: %u, next: %u): Failed to wrap data with device class F key: %{public}@",  &v29,  24);
      goto LABEL_38;
    }

    goto LABEL_40;
  }

  if (![v10 length])
  {
    if (qword_1000DBB38 != -1) {
      dispatch_once(&qword_1000DBB38, &stru_1000CD670);
    }
    __int128 v12 = (os_log_s *)(id)qword_1000DBB30;
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      goto LABEL_42;
    }
    uint64_t v27 = 0LL;
    unsigned int v20 = sub_100053B4C(0);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      uint64_t v21 = v20;
    }
    else {
      uint64_t v21 = v20 & 0xFFFFFFFE;
    }
    if ((_DWORD)v21)
    {
      int v29 = 67109376;
      int v30 = a2;
      __int16 v31 = 1024;
      int v32 = a3;
      unsigned int v19 = (const char *)_os_log_send_and_compose_impl( v21,  &v27,  0LL,  0LL,  &_mh_execute_header,  v12,  16LL,  "Failed to save next session (previous: %u, next: %u): Wrapped data is empty",  &v29);
      goto LABEL_38;
    }

LABEL_40:
    unsigned int v24 = 0LL;
LABEL_41:
    free(v24);
    goto LABEL_42;
  }

  if ((sub_1000551B4((void *)a1, v10) & 1) != 0)
  {
    if (qword_1000DBB38 != -1) {
      dispatch_once(&qword_1000DBB38, &stru_1000CD670);
    }
    __int128 v12 = (os_log_s *)(id)qword_1000DBB30;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v27 = 0LL;
      unsigned int v13 = sub_100053B4C(0);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v14 = v13;
      }
      else {
        uint64_t v14 = v13 & 0xFFFFFFFE;
      }
      if ((_DWORD)v14)
      {
        int v29 = 67109376;
        int v30 = a2;
        __int16 v31 = 1024;
        int v32 = a3;
        __int128 v15 = (const char *)_os_log_send_and_compose_impl( v14,  &v27,  0LL,  0LL,  &_mh_execute_header,  v12,  0LL,  "Saved next session: (previous: %u, next: %u)",  &v29,  14);
        unsigned int v16 = (char *)v15;
        if (v15) {
          sub_100053B7C(v15);
        }
      }

      else
      {
        unsigned int v16 = 0LL;
      }

      free(v16);
    }

    uint64_t v25 = 1LL;
    goto LABEL_43;
  }

  if (qword_1000DBB38 != -1) {
    dispatch_once(&qword_1000DBB38, &stru_1000CD670);
  }
  __int128 v12 = (os_log_s *)(id)qword_1000DBB30;
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    uint64_t v27 = 0LL;
    unsigned int v22 = sub_100053B4C(0);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      uint64_t v23 = v22;
    }
    else {
      uint64_t v23 = v22 & 0xFFFFFFFE;
    }
    if ((_DWORD)v23)
    {
      int v29 = 67109376;
      int v30 = a2;
      __int16 v31 = 1024;
      int v32 = a3;
      unsigned int v19 = (const char *)_os_log_send_and_compose_impl( v23,  &v27,  0LL,  0LL,  &_mh_execute_header,  v12,  16LL,  "Failed to save next session (previous: %u, next: %u): Failed to write data to disk",  &v29);
LABEL_38:
      unsigned int v24 = (char *)v19;
      if (v19) {
        sub_100053B7C(v19);
      }
      goto LABEL_41;
    }

    goto LABEL_40;
  }
}

LABEL_42:
  uint64_t v25 = 0LL;
LABEL_43:

  return v25;
}

      id v9 = 0LL;
LABEL_43:
      free(v9);
LABEL_44:
      id v6 = 0LL;
LABEL_48:

      return v6;
    }

    id v1 = VEKState;
    if (VEKState)
    {
      if (qword_1000DBBD8 != -1) {
        dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
      }
      uint64_t v2 = (os_log_s *)(id)qword_1000DBBD0;
      if (!os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_47;
      }
      unsigned int v17 = 0LL;
      uint64_t v10 = sub_100053B4C(1);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
        id v11 = v10;
      }
      else {
        id v11 = v10 & 0xFFFFFFFE;
      }
      if ((_DWORD)v11)
      {
        v19[0] = 67109120;
        v19[1] = v1;
        __int128 v12 = (const char *)_os_log_send_and_compose_impl( v11,  &v17,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "APFSVolumeGetVEKState returned error:%d, try user binding..",  v19);
        goto LABEL_40;
      }
    }

    else
    {
      if (HIBYTE(v18))
      {
        if (qword_1000DBBD8 != -1) {
          dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
        }
        uint64_t v2 = (os_log_s *)(id)qword_1000DBBD0;
        if (!os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_44;
        }
        unsigned int v17 = 0LL;
        id v3 = sub_100053B4C(1);
        if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
          id v4 = v3;
        }
        else {
          id v4 = v3 & 0xFFFFFFFE;
        }
        if ((_DWORD)v4)
        {
          LOWORD(v19[0]) = 0;
          id v5 = (const char *)_os_log_send_and_compose_impl( v4,  &v17,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "Volume already userbound, no user binding needed",  v19,  2);
          goto LABEL_22;
        }

        goto LABEL_42;
      }

      if (qword_1000DBBD8 != -1) {
        dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
      }
      uint64_t v2 = (os_log_s *)(id)qword_1000DBBD0;
      if (!os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
LABEL_47:
        id v6 = 1LL;
        goto LABEL_48;
      }

      unsigned int v17 = 0LL;
      unsigned int v13 = sub_100053B4C(1);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v14 = v13;
      }
      else {
        uint64_t v14 = v13 & 0xFFFFFFFE;
      }
      if ((_DWORD)v14)
      {
        LOWORD(v19[0]) = 0;
        __int128 v12 = (const char *)_os_log_send_and_compose_impl( v14,  &v17,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "Volume is not user bound, needs binding");
LABEL_40:
        __int128 v15 = (char *)v12;
        if (v12) {
          sub_100053B7C(v12);
        }
        goto LABEL_46;
      }
    }

    __int128 v15 = 0LL;
LABEL_46:
    free(v15);
    goto LABEL_47;
  }

  return 0LL;
}

uint64_t sub_100055CE4(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  if (!a1) {
    return 0LL;
  }
  *a2 = -1;
  *a3 = -1;
  id v6 = sub_1000552D4(a1);
  id v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
  if (v7)
  {
    id v8 = *(id *)(a1 + 8);
    uint64_t v9 = sub_100019B18((uint64_t)v8);
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
    id v22 = 0LL;
    id v11 = (void *)objc_claimAutoreleasedReturnValue([v10 dataUnwrappingDataWithDeviceClassF:v7 error:&v22]);
    id v12 = v22;

    if (v11)
    {
      if ([v11 length] == (id)32)
      {
        unsigned int v13 = [v11 bytes];
        *a2 = v13[1];
        *a3 = *v13;
        uint64_t v14 = 1LL;
LABEL_20:

        goto LABEL_21;
      }

      if (qword_1000DBB38 != -1) {
        dispatch_once(&qword_1000DBB38, &stru_1000CD670);
      }
      __int128 v15 = (os_log_s *)(id)qword_1000DBB30;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        uint64_t v21 = 0LL;
        LODWORD(v16) = sub_100053B4C(0);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
          uint64_t v16 = v16;
        }
        else {
          uint64_t v16 = v16 & 0xFFFFFFFE;
        }
        if ((_DWORD)v16)
        {
          unsigned int v17 = v15;
          id v18 = [v11 length];
          int v23 = 134217984;
          id v24 = v18;
          unsigned int v19 = (char *)_os_log_send_and_compose_impl( v16,  &v21,  0LL,  0LL,  &_mh_execute_header,  v17,  16LL,  "Failed to load next session: Decrypted data is not the correct size: %lu",  &v23);

          if (v19) {
            sub_100053B7C(v19);
          }
        }

        else
        {
          unsigned int v19 = 0LL;
        }

        free(v19);
      }
    }

    uint64_t v14 = 0LL;
    goto LABEL_20;
  }

  uint64_t v14 = 0LL;
LABEL_21:

  return v14;
}

id sub_100055F08(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v1 = sub_100019434(*(void *)(a1 + 8));
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(v1);
  id v3 = [v2 removeFileAtPath:@"/private/var/keybags/nextsession.kb" error:0];

  if ((v3 & 1) != 0)
  {
    if (qword_1000DBB38 != -1) {
      dispatch_once(&qword_1000DBB38, &stru_1000CD670);
    }
    id v4 = (os_log_s *)(id)qword_1000DBB30;
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_23;
    }
    uint64_t v13 = 0LL;
    unsigned int v5 = sub_100053B4C(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = v5 & 0xFFFFFFFE;
    }
    if ((_DWORD)v6)
    {
      LOWORD(v12) = 0;
      id v7 = (const char *)_os_log_send_and_compose_impl( v6,  &v13,  0LL,  0LL,  &_mh_execute_header,  v4,  0LL,  "Removed next session file",  &v12,  2,  v12,  v13);
      goto LABEL_19;
    }
  }

  else
  {
    if (qword_1000DBB38 != -1) {
      dispatch_once(&qword_1000DBB38, &stru_1000CD670);
    }
    id v4 = (os_log_s *)(id)qword_1000DBB30;
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    uint64_t v13 = 0LL;
    unsigned int v8 = sub_100053B4C(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      uint64_t v9 = v8;
    }
    else {
      uint64_t v9 = v8 & 0xFFFFFFFE;
    }
    if ((_DWORD)v9)
    {
      LOWORD(v12) = 0;
      id v7 = (const char *)_os_log_send_and_compose_impl( v9,  &v13,  0LL,  0LL,  &_mh_execute_header,  v4,  16LL,  "Failed to remove next session: unable to remove file",  &v12,  2,  v12,  v13);
LABEL_19:
      uint64_t v10 = (char *)v7;
      if (v7) {
        sub_100053B7C(v7);
      }
      goto LABEL_22;
    }
  }

  uint64_t v10 = 0LL;
LABEL_22:
  free(v10);
LABEL_23:

  return v3;
}

void sub_100056118(id a1)
{
  os_log_t v1 = os_log_create(off_1000DAE70, "user");
  uint64_t v2 = (void *)qword_1000DBB30;
  qword_1000DBB30 = (uint64_t)v1;
}

id *sub_10005614C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a4;
  id v8 = a3;
  id v9 = a2;
  objc_opt_self(a1);
  uint64_t v10 = sub_1000561C8((id *)objc_alloc(&OBJC_CLASS___UMDGeneration), v9, v8, v7);

  return v10;
}

id *sub_1000561C8(id *a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (a1)
  {
    v12.receiver = a1;
    v12.super_class = (Class)&OBJC_CLASS___UMDGeneration;
    uint64_t v10 = (id *)objc_msgSendSuper2(&v12, "init");
    if (!v10) {
      sub_1000A9C18();
    }
    a1 = v10;
    objc_storeStrong(v10 + 3, a4);
    a1[4] = v7;
    a1[5] = v8;
    *((_DWORD *)a1 + 2) = -1;
    a1[2] = 0LL;
  }

  return a1;
}

uint64_t sub_100056274(uint64_t result)
{
  if (result)
  {
    uint64_t result = *(void *)(result + 16);
    if (!result) {
      sub_1000A9C18();
    }
  }

  return result;
}

uint64_t sub_100056294(uint64_t result, uint64_t a2)
{
  if (result)
  {
    if (*(void *)(result + 16)) {
      sub_1000A9C18();
    }
    *(void *)(result + 16) = a2;
  }

  return result;
}

void sub_1000562B8(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 16);
    else {
      uint64_t v3 = 1LL;
    }
    *(void *)(a1 + 16) = v3;
    id v4 = (os_log_s *)*(id *)(a1 + 40);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = 0LL;
      unsigned int v5 = sub_100053B4C(0);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v6 = v5;
      }
      else {
        uint64_t v6 = v5 & 0xFFFFFFFE;
      }
      if ((_DWORD)v6)
      {
        uint64_t v7 = *(void *)(a1 + 16);
        int v11 = 134217984;
        uint64_t v12 = v7;
        id v8 = (const char *)_os_log_send_and_compose_impl( v6,  &v10,  0LL,  0LL,  &_mh_execute_header,  v4,  0LL,  "Generation incremented to %llu",  &v11);
        id v9 = (char *)v8;
        if (v8) {
          sub_100053B7C(v8);
        }
      }

      else
      {
        id v9 = 0LL;
      }

      free(v9);
    }

    sub_10005641C(a1);
    sub_1000566B4(a1);
  }

void sub_1000563F0(uint64_t a1)
{
  if (a1)
  {
    sub_10005641C(a1);
    sub_1000566B4(a1);
  }

void sub_10005641C(uint64_t a1)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 8) != -1) {
      goto LABEL_4;
    }
    id v2 = *(id *)(a1 + 24);
    uint64_t v3 = sub_100018E74((uint64_t)v2);
    id v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
    id v5 = *(id *)(a1 + 32);
    *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = [v4 registerPlain:v5];

    if (*(_DWORD *)(a1 + 8) == -1)
    {
      uint64_t v12 = (os_log_s *)*(id *)(a1 + 40);
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        goto LABEL_28;
      }
      *(void *)int v23 = 0LL;
      unsigned int v20 = sub_100053B4C(0);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        uint64_t v18 = v20;
      }
      else {
        uint64_t v18 = v20 & 0xFFFFFFFE;
      }
      if (!(_DWORD)v18) {
        goto LABEL_26;
      }
      LOWORD(v22[0]) = 0;
      unsigned int v19 = "Failed to publish generation: Failed to register for darwin notification token";
    }

    else
    {
LABEL_4:
      id v6 = *(id *)(a1 + 24);
      uint64_t v7 = sub_100018E74((uint64_t)v6);
      id v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
      uint64_t v9 = sub_100056274(a1);
      uint64_t v10 = *(unsigned int *)(a1 + 8);

      LOBYTE(v9) = [v8 setState:v9 forToken:v10];
      int v11 = (os_log_s *)*(id *)(a1 + 40);
      uint64_t v12 = v11;
      if ((v9 & 1) != 0)
      {
        if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
        {
          v22[0] = 0LL;
          unsigned int v13 = sub_100053B4C(0);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO)) {
            uint64_t v14 = v13;
          }
          else {
            uint64_t v14 = v13 & 0xFFFFFFFE;
          }
          if ((_DWORD)v14)
          {
            uint64_t v15 = *(void *)(a1 + 16);
            *(_DWORD *)int v23 = 134217984;
            *(void *)&v23[4] = v15;
            uint64_t v16 = (const char *)_os_log_send_and_compose_impl( v14,  v22,  0LL,  0LL,  &_mh_execute_header,  v12,  1LL,  "Published generation value: %llu",  v23);
            goto LABEL_24;
          }

LABEL_26:
          uint64_t v21 = 0LL;
LABEL_27:
          free(v21);
        }

void sub_1000566B4(uint64_t a1)
{
  if (a1)
  {
    id v2 = *(id *)(a1 + 24);
    uint64_t v3 = sub_100018E74((uint64_t)v2);
    id v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
    unsigned __int8 v5 = [v4 post:*(void *)(a1 + 32)];

    id v6 = (os_log_s *)*(id *)(a1 + 40);
    uint64_t v7 = v6;
    if ((v5 & 1) != 0)
    {
      if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
      {
        uint64_t v15 = 0LL;
        unsigned int v8 = sub_100053B4C(0);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO)) {
          uint64_t v9 = v8;
        }
        else {
          uint64_t v9 = v8 & 0xFFFFFFFE;
        }
        if ((_DWORD)v9)
        {
          LOWORD(v14) = 0;
          uint64_t v10 = (const char *)_os_log_send_and_compose_impl( v9,  &v15,  0LL,  0LL,  &_mh_execute_header,  v7,  1LL,  "Generation changed notification posted",  &v14,  2,  v14,  v15);
          goto LABEL_15;
        }

        goto LABEL_17;
      }
    }

    else if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      uint64_t v15 = 0LL;
      unsigned int v11 = sub_100053B4C(0);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
        uint64_t v12 = v11;
      }
      else {
        uint64_t v12 = v11 & 0xFFFFFFFE;
      }
      if ((_DWORD)v12)
      {
        LOWORD(v14) = 0;
        uint64_t v10 = (const char *)_os_log_send_and_compose_impl( v12,  &v15,  0LL,  0LL,  &_mh_execute_header,  v7,  16LL,  "Failed to post generation changed notification: Failed to post darwin notification",  &v14,  2,  v14,  v15);
LABEL_15:
        unsigned int v13 = (char *)v10;
        if (v10) {
          sub_100053B7C(v10);
        }
        goto LABEL_18;
      }

uint64_t sub_10005682C(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 8);
  }
  return result;
}

uint64_t sub_100056838(uint64_t result, int a2)
{
  if (result) {
    *(_DWORD *)(result + _Block_object_dispose(va, 8) = a2;
  }
  return result;
}

uint64_t sub_100056850()
{
  return _os_assert_log(0LL);
}

LABEL_38:
      unsigned int v20 = 0LL;
      goto LABEL_39;
    }
  }

  uint64_t v10 = -[os_log_s unsignedIntValue](v8, "unsignedIntValue");
  if (v10 == 1)
  {
    uint64_t v21 = sub_100056F6C((uint64_t)a1, v7);
    uint64_t v12 = objc_claimAutoreleasedReturnValue(v21);
    goto LABEL_26;
  }

  if (v10)
  {
    if (qword_1000DBB48 != -1) {
      dispatch_once(&qword_1000DBB48, &stru_1000CD690);
    }
    unsigned int v17 = (os_log_s *)(id)qword_1000DBB40;
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      goto LABEL_40;
    }
    unsigned int v26 = 0LL;
    LODWORD(v23) = sub_100053B4C(0);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      int v23 = v23;
    }
    else {
      int v23 = v23 & 0xFFFFFFFE;
    }
    if ((_DWORD)v23)
    {
      id v24 = v17;
      v27[0] = 67109120;
      v27[1] = -[os_log_s unsignedIntValue](v8, "unsignedIntValue");
      unsigned int v20 = (void *)_os_log_send_and_compose_impl( v23,  &v26,  0LL,  0LL,  &_mh_execute_header,  v24,  16LL,  "Failed to parse persona manifest: unknown manifest version: %u",  v27);

      if (!v20)
      {
LABEL_39:
        free(v20);
LABEL_40:

LABEL_41:
        id v22 = 0LL;
        goto LABEL_42;
      }

    uint64_t v27 = 0LL;
LABEL_39:
    free(v27);
  }

UMDPersonaManifestEmbedded *sub_100056C1C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = (void *)objc_opt_self(a1);
  if (qword_1000DBB48 != -1) {
    dispatch_once(&qword_1000DBB48, &stru_1000CD690);
  }
  unsigned __int8 v5 = (os_log_s *)(id)qword_1000DBB40;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    uint64_t v30 = 0LL;
    unsigned int v6 = sub_100053B4C(0);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO)) {
      uint64_t v7 = v6;
    }
    else {
      uint64_t v7 = v6 & 0xFFFFFFFE;
    }
    if ((_DWORD)v7)
    {
      v29[0] = 0;
      unsigned int v8 = (const char *)_os_log_send_and_compose_impl( v7,  &v30,  0LL,  0LL,  &_mh_execute_header,  v5,  1LL,  "Parsing persona manifest version: 0",  v29,  2);
      uint64_t v9 = (char *)v8;
      if (v8) {
        sub_100053B7C(v8);
      }
    }

    else
    {
      uint64_t v9 = 0LL;
    }

    free(v9);
  }

  uint64_t v10 = (char *)objc_claimAutoreleasedReturnValue([v4 personaSetFromData:v3]);
  if (v10)
  {
    unsigned int v11 = objc_alloc_init(&OBJC_CLASS___UMDPersonaManifestUser);
    sub_100019D4C(v11, v10);
    __int128 v27 = 0u;
    __int128 v28 = 0u;
    __int128 v25 = 0u;
    __int128 v26 = 0u;
    uint64_t v12 = v10;
    id v13 = [v12 countByEnumeratingWithState:&v25 objects:v31 count:16];
    if (v13)
    {
      uint64_t v14 = *(void *)v26;
      while (2)
      {
        for (CFIndex i = 0LL; i != v13; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v26 != v14) {
            objc_enumerationMutation(v12);
          }
          uint64_t v16 = *(void *)(*((void *)&v25 + 1) + 8LL * (void)i);
          if (sub_100064168(v16) == 3)
          {
            id v13 = (id)sub_100019428(v16);
            goto LABEL_23;
          }
        }

        id v13 = [v12 countByEnumeratingWithState:&v25 objects:v31 count:16];
        if (v13) {
          continue;
        }
        break;
      }
    }

LABEL_23:
    unsigned int v17 = objc_alloc_init(&OBJC_CLASS___UMDPersonaManifestEmbedded);
    -[UMDPersonaManifest setVersion:](v17, "setVersion:", 0LL);
    -[UMDPersonaManifest setGeneration:](v17, "setGeneration:", v13);
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSSet setWithObject:](&OBJC_CLASS___NSSet, "setWithObject:", v11));
    -[UMDPersonaManifest setUsers:](v17, "setUsers:", v18);
  }

  else
  {
    if (qword_1000DBB48 != -1) {
      dispatch_once(&qword_1000DBB48, &stru_1000CD690);
    }
    unsigned int v11 = (UMDPersonaManifestUser *)(id)qword_1000DBB40;
    if (os_log_type_enabled((os_log_t)v11, OS_LOG_TYPE_ERROR))
    {
      uint64_t v30 = 0LL;
      unsigned int v19 = sub_100053B4C(0);
      if (os_log_type_enabled((os_log_t)v11, OS_LOG_TYPE_ERROR)) {
        uint64_t v20 = v19;
      }
      else {
        uint64_t v20 = v19 & 0xFFFFFFFE;
      }
      if ((_DWORD)v20)
      {
        v29[0] = 0;
        LODWORD(v24) = 2;
        uint64_t v21 = (const char *)_os_log_send_and_compose_impl( v20,  &v30,  0LL,  0LL,  &_mh_execute_header,  v11,  16LL,  "Failed to parse persona manifest user: failed to parse personas",  v29,  v24);
        id v22 = (char *)v21;
        if (v21) {
          sub_100053B7C(v21);
        }
      }

      else
      {
        id v22 = 0LL;
      }

      free(v22);
    }

    unsigned int v17 = 0LL;
  }

  return v17;
}

  int v32 = v5;
LABEL_39:

  return v32;
}

      uint64_t v18 = 0LL;
LABEL_24:
      free(v18);
    }
  }

  return v11;
}

id sub_100056F6C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = (objc_class *)objc_opt_self(a1);
  id v5 = objc_alloc_init(v4);
  if (qword_1000DBB48 != -1) {
    dispatch_once(&qword_1000DBB48, &stru_1000CD690);
  }
  unsigned int v6 = (os_log_s *)(id)qword_1000DBB40;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    uint64_t v33 = 0LL;
    unsigned int v7 = sub_100053B4C(0);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO)) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = v7 & 0xFFFFFFFE;
    }
    if ((_DWORD)v8)
    {
      __int16 v32 = 0;
      uint64_t v9 = (const char *)_os_log_send_and_compose_impl( v8,  &v33,  0LL,  0LL,  &_mh_execute_header,  v6,  1LL,  "Parsing persona manifest version: 1",  &v32,  2);
      uint64_t v10 = (char *)v9;
      if (v9) {
        sub_100053B7C(v9);
      }
    }

    else
    {
      uint64_t v10 = 0LL;
    }

    free(v10);
  }

  [v5 setVersion:1];
  unsigned int v11 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:@"UsePersonaGenerationID"]);
  if (!v11 || (uint64_t v12 = objc_opt_class(&OBJC_CLASS___NSNumber), (objc_opt_isKindOfClass(v11, v12) & 1) != 0))
  {
    objc_msgSend(v5, "setGeneration:", objc_msgSend(v11, "unsignedLongValue"));
    id v13 = (os_log_s *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:@"UserPersonaDictionary"]);
    if (v13 && (uint64_t v14 = objc_opt_class(&OBJC_CLASS___NSDictionary), (objc_opt_isKindOfClass(v13, v14) & 1) != 0))
    {
      id v15 = (id)objc_claimAutoreleasedReturnValue(-[objc_class userSetFromDict:](v4, "userSetFromDict:", v13));
      if (v15)
      {
        [v5 setUsers:v15];
        id v16 = v5;
LABEL_54:

        goto LABEL_55;
      }

      if (qword_1000DBB48 != -1) {
        dispatch_once(&qword_1000DBB48, &stru_1000CD690);
      }
      __int128 v25 = (os_log_s *)(id)qword_1000DBB40;
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        uint64_t v33 = 0LL;
        unsigned int v26 = sub_100053B4C(0);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
          uint64_t v27 = v26;
        }
        else {
          uint64_t v27 = v26 & 0xFFFFFFFE;
        }
        if ((_DWORD)v27)
        {
          __int16 v32 = 0;
          LODWORD(v31) = 2;
          __int128 v28 = (const char *)_os_log_send_and_compose_impl( v27,  &v33,  0LL,  0LL,  &_mh_execute_header,  v25,  16LL,  "Failed to parse persona manifest: failed to parse user dictionary",  &v32,  v31);
          int v29 = (char *)v28;
          if (v28) {
            sub_100053B7C(v28);
          }
        }

        else
        {
          int v29 = 0LL;
        }

        free(v29);
      }
    }

    else
    {
      if (qword_1000DBB48 != -1) {
        dispatch_once(&qword_1000DBB48, &stru_1000CD690);
      }
      id v15 = (id)qword_1000DBB40;
      if (os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_ERROR))
      {
        uint64_t v33 = 0LL;
        unsigned int v17 = sub_100053B4C(0);
        if (os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_ERROR)) {
          uint64_t v18 = v17;
        }
        else {
          uint64_t v18 = v17 & 0xFFFFFFFE;
        }
        if ((_DWORD)v18)
        {
          __int16 v32 = 0;
          LODWORD(v31) = 2;
          unsigned int v19 = (const char *)_os_log_send_and_compose_impl( v18,  &v33,  0LL,  0LL,  &_mh_execute_header,  v15,  16LL,  "Failed to parse persona manifest: user dictionary is invalid",  &v32,  v31);
          uint64_t v20 = (char *)v19;
          if (v19) {
            sub_100053B7C(v19);
          }
        }

        else
        {
          uint64_t v20 = 0LL;
        }

        free(v20);
      }
    }

    id v16 = 0LL;
    goto LABEL_54;
  }

  if (qword_1000DBB48 != -1) {
    dispatch_once(&qword_1000DBB48, &stru_1000CD690);
  }
  id v13 = (os_log_s *)(id)qword_1000DBB40;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    uint64_t v33 = 0LL;
    unsigned int v21 = sub_100053B4C(0);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      uint64_t v22 = v21;
    }
    else {
      uint64_t v22 = v21 & 0xFFFFFFFE;
    }
    if ((_DWORD)v22)
    {
      __int16 v32 = 0;
      LODWORD(v31) = 2;
      int v23 = (const char *)_os_log_send_and_compose_impl( v22,  &v33,  0LL,  0LL,  &_mh_execute_header,  v13,  16LL,  "Failed to parse persona manifest: generation id is invalid",  &v32,  v31);
      uint64_t v24 = (char *)v23;
      if (v23) {
        sub_100053B7C(v23);
      }
    }

    else
    {
      uint64_t v24 = 0LL;
    }

    free(v24);
  }

  id v16 = 0LL;
LABEL_55:

  return v16;
}

void sub_100057598(id a1)
{
  os_log_t v1 = os_log_create(off_1000DAE70, "persona");
  id v2 = (void *)qword_1000DBB40;
  qword_1000DBB40 = (uint64_t)v1;
}

id sub_1000575CC(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_opt_self(a1);
  id v5 = sub_100057614(v4, v3, 0);
  unsigned int v6 = (void *)objc_claimAutoreleasedReturnValue(v5);

  return v6;
}

id *sub_100057614(uint64_t a1, void *a2, char a3)
{
  id v5 = a2;
  objc_opt_self(a1);
  unsigned int v6 = sub_100057670((id *)objc_alloc(&OBJC_CLASS___UMDAPFSSupportVolumeHelper), v5, a3);

  return v6;
}

id *sub_100057670(id *a1, void *a2, char a3)
{
  id v5 = a2;
  if (a1)
  {
    unsigned int v6 = sub_1000822E0(a1, v5);
    if (!v6) {
      sub_1000A9AD0();
    }
    a1 = v6;

    sub_100076078((uint64_t)a1, a3);
  }

  return a1;
}

id sub_1000577B4(uint64_t a1)
{
  return [&off_1000D1108 mutableCopy];
}

id sub_1000577D4(uint64_t a1)
{
  return [&off_1000D1120 mutableCopy];
}

uint64_t sub_1000577F4()
{
  return 0LL;
}

void *sub_10005780C(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_self(a1);
  uint64_t v4 = sub_100057858(objc_alloc(&OBJC_CLASS___UMDPersonaManager), v3);

  return v4;
}

void *sub_100057858(void *a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    v19.receiver = a1;
    v19.super_class = (Class)&OBJC_CLASS___UMDPersonaManager;
    id v4 = objc_msgSendSuper2(&v19, "init");
    if (!v4) {
      sub_1000A9AD0();
    }
    a1 = v4;
    objc_storeWeak((id *)v4 + 6, v3);
    uint64_t v5 = sub_100019B18((uint64_t)v3);
    uint64_t v6 = objc_claimAutoreleasedReturnValue(v5);
    unsigned int v7 = (void *)a1[2];
    a1[2] = v6;

    uint64_t v8 = sub_100018E80((uint64_t)v3);
    uint64_t v9 = objc_claimAutoreleasedReturnValue(v8);
    uint64_t v10 = (void *)a1[3];
    a1[3] = v9;

    unsigned int v11 = objc_alloc_init(&OBJC_CLASS___UMDPersonaState);
    uint64_t v12 = (void *)a1[4];
    a1[4] = v11;

    if (qword_1000DBB58 != -1) {
      dispatch_once(&qword_1000DBB58, &stru_1000CD6B0);
    }
    id v13 = (void *)a1[2];
    id v14 = (id)qword_1000DBB50;
    id v15 = sub_10005614C( (uint64_t)&OBJC_CLASS___UMDGeneration,  @"com.apple.mobile.usermanagerd.personageneration_changed",  v14,  v13);
    uint64_t v16 = objc_claimAutoreleasedReturnValue(v15);
    unsigned int v17 = (void *)a1[5];
    a1[5] = v16;
  }

  return a1;
}

void sub_10005798C(uint64_t a1, void *a2)
{
  if (a1)
  {
    id v2 = a2;
    objc_opt_self(&OBJC_CLASS___UMDPersonaManager);
    id v3 = [&off_1000D1108 mutableCopy];
    [v2 setObject:v3 forKeyedSubscript:@"UserPersonaBundleIDS"];
  }

void sub_1000579F8(uint64_t a1, void *a2)
{
  if (a1)
  {
    id v2 = a2;
    objc_opt_self(&OBJC_CLASS___UMDPersonaManager);
    id v3 = [&off_1000D1120 mutableCopy];
    [v2 setObject:v3 forKeyedSubscript:@"UserPersonaBundleIDS"];
  }

uint64_t sub_100057A64(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  unsigned int v7 = v6;
  uint64_t v8 = 0LL;
  if (a1 && v6)
  {
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKey:@"UserPersonaBundleIDS"]);
    uint64_t v10 = objc_opt_class(&OBJC_CLASS___NSMutableArray);
    if ((objc_opt_isKindOfClass(v9, v10) & 1) != 0)
    {
      if (v9)
      {
        __int128 v27 = 0u;
        __int128 v28 = 0u;
        __int128 v25 = 0u;
        __int128 v26 = 0u;
        id v11 = v5;
        id v12 = [v11 countByEnumeratingWithState:&v25 objects:v30 count:16];
        if (v12)
        {
          id v13 = v12;
          char v14 = 0;
          uint64_t v15 = *(void *)v26;
          do
          {
            for (CFIndex i = 0LL; i != v13; CFIndex i = (char *)i + 1)
            {
              if (*(void *)v26 != v15) {
                objc_enumerationMutation(v11);
              }
              uint64_t v17 = *(void *)(*((void *)&v25 + 1) + 8LL * (void)i);
              if (([v9 containsObject:v17] & 1) == 0)
              {
                [v9 addObject:v17];
                char v14 = 1;
              }
            }

            id v13 = [v11 countByEnumeratingWithState:&v25 objects:v30 count:16];
          }

          while (v13);

          if ((v14 & 1) != 0)
          {
            if (qword_1000DBB68 != -1) {
              dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
            }
            uint64_t v18 = (os_log_s *)(id)qword_1000DBB60;
            if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v24 = 0LL;
              LODWORD(v19) = sub_100053B4C(1);
              if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v19 = v19;
              }
              else {
                uint64_t v19 = v19 & 0xFFFFFFFE;
              }
              if ((_DWORD)v19)
              {
                uint64_t v20 = v18;
                unsigned int v21 = sub_100084F14(v7, (uint64_t)@"UserPersonaType", (id)0xFFFFFFFFLL);
                v29[0] = 67109120;
                v29[1] = v21;
                uint64_t v22 = (char *)_os_log_send_and_compose_impl( v19,  &v24,  0LL,  0LL,  &_mh_execute_header,  v20,  0LL,  "Updating Persona:%u BundleIDs",  v29);

                if (v22) {
                  sub_100053B7C(v22);
                }
              }

              else
              {
                uint64_t v22 = 0LL;
              }

              free(v22);
            }

            goto LABEL_26;
          }
        }

        else
        {
        }

        uint64_t v8 = 0LL;
        goto LABEL_29;
      }
    }

    else
    {
    }

    [v7 setObject:v5 forKeyedSubscript:@"UserPersonaBundleIDS"];
    uint64_t v9 = 0LL;
LABEL_26:
    uint64_t v8 = 1LL;
LABEL_29:
  }

  return v8;
}

uint64_t sub_100057D18(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    unsigned int v5 = sub_100084F14(v3, (uint64_t)@"UserPersonaType", (id)0xFFFFFFFFLL);
    if (v5 == 4)
    {
      id v6 = &off_1000D1108;
    }

    else
    {
      if (v5 != 3)
      {
        a1 = 0LL;
        goto LABEL_8;
      }

      id v6 = &off_1000D1120;
    }

    objc_opt_self(&OBJC_CLASS___UMDPersonaManager);
    id v7 = [v6 mutableCopy];
    a1 = sub_100057A64(a1, v7, v4);
  }

uint64_t sub_100057DC0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = v6;
  if (a1)
  {
    __int128 v16 = 0u;
    __int128 v17 = 0u;
    __int128 v14 = 0u;
    __int128 v15 = 0u;
    id v8 = v6;
    uint64_t v9 = (uint64_t)[v8 countByEnumeratingWithState:&v14 objects:v18 count:16];
    if (v9)
    {
      uint64_t v10 = *(void *)v15;
      while (2)
      {
        for (uint64_t i = 0LL; i != v9; ++i)
        {
          if (*(void *)v15 != v10) {
            objc_enumerationMutation(v8);
          }
          id v12 = (void *)objc_claimAutoreleasedReturnValue( objc_msgSend( v5,  "objectForKeyedSubscript:",  *(void *)(*((void *)&v14 + 1) + 8 * i),  (void)v14));

          if (!v12)
          {
            uint64_t v9 = 1LL;
            goto LABEL_12;
          }
        }

        uint64_t v9 = (uint64_t)[v8 countByEnumeratingWithState:&v14 objects:v18 count:16];
        if (v9) {
          continue;
        }
        break;
      }
    }

LABEL_12:
  }

  else
  {
    uint64_t v9 = 0LL;
  }

  return v9;
}

    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
    uint64_t v30 = 0u;
    uint64_t v31 = 0u;
    __int16 v32 = 0u;
    uint64_t v33 = 0u;
    uint64_t v19 = v29;
    uint64_t v20 = [v19 countByEnumeratingWithState:&v30 objects:v38 count:16];
    if (v20)
    {
      unsigned int v21 = v20;
      uint64_t v22 = *(void *)v31;
      do
      {
        for (j = 0LL; j != v21; j = (char *)j + 1)
        {
          if (*(void *)v31 != v22) {
            objc_enumerationMutation(v19);
          }
          uint64_t v24 = sub_100075BA0( (uint64_t)&OBJC_CLASS___UMDPersonaManifestPersona,  *(void **)(*((void *)&v30 + 1) + 8LL * (void)j));
          __int128 v25 = (void *)objc_claimAutoreleasedReturnValue(v24);
          sub_100019980((uint64_t)v25, 0LL);
          [v18 addObject:v25];
        }

        unsigned int v21 = [v19 countByEnumeratingWithState:&v30 objects:v38 count:16];
      }

      while (v21);
    }

    __int128 v26 = v28;
    sub_100019D4C(v28, (char *)v18);
  }

  else
  {
    __int128 v26 = 0LL;
  }

  return v26;
}

  return v10;
}

  memset_s(__s, 0x1000uLL, 0, 0x1000uLL);
  return v10;
}

  free(*(void **)&inputStructCnt[1]);
  return v17;
}

uint64_t sub_100057EF8(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  if (a1)
  {
    else {
      a1 = sub_100057DC0(a1, v5, off_1000CD6F0[a3 - 3]);
    }
  }

  return a1;
}

uint64_t sub_100057F64(uint64_t result, signed int a2)
{
  if (result)
  {
    if (a2 < 7 && ((0x6Du >> a2) & 1) != 0)
    {
      return sub_1000580F8(result, dword_1000ADF50[a2], qword_1000ADF18[a2]);
    }

    else
    {
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      id v3 = (os_log_s *)(id)qword_1000DBB60;
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v8 = 0LL;
        unsigned int v4 = sub_100053B4C(1);
        if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v5 = v4;
        }
        else {
          uint64_t v5 = v4 & 0xFFFFFFFE;
        }
        if ((_DWORD)v5)
        {
          v9[0] = 67109120;
          v9[1] = a2;
          id v6 = (const char *)_os_log_send_and_compose_impl( v5,  &v8,  0LL,  0LL,  &_mh_execute_header,  v3,  0LL,  "next available persona id queried for invalid type: %u",  v9);
          id v7 = (char *)v6;
          if (v6) {
            sub_100053B7C(v6);
          }
        }

        else
        {
          id v7 = 0LL;
        }

        free(v7);
      }

      return 0xFFFFFFFFLL;
    }
  }

  return result;
}

uint64_t sub_1000580F8(uint64_t a1, uint64_t a2, int a3)
{
  if (!a1) {
    return 0LL;
  }
  if (qword_1000DBB68 != -1) {
    dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
  }
  p_name = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
  id v7 = (os_log_s *)(id)qword_1000DBB60;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v24 = 0LL;
    LODWORD(v_Block_object_dispose(va, 8) = sub_100053B4C(1);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG)) {
      uint64_t v8 = v8;
    }
    else {
      uint64_t v8 = v8 & 0xFFFFFFFE;
    }
    if ((_DWORD)v8)
    {
      id v9 = *(id *)(a1 + 32);
      uint64_t v10 = v7;
      id v11 = (void *)objc_claimAutoreleasedReturnValue([v9 userPersonas]);
      *(_DWORD *)int v23 = 134217984;
      *(void *)&v23[4] = [v11 count];
      id v12 = (char *)_os_log_send_and_compose_impl( v8,  &v24,  0LL,  0LL,  &_mh_execute_header,  v10,  2LL,  "dictionary user entries:%lu",  v23);

      if (v12) {
        sub_100053B7C(v12);
      }
      p_name = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
    }

    else
    {
      id v12 = 0LL;
    }

    free(v12);
  }

  if (a3 + (int)a2 <= a2)
  {
LABEL_17:
    if (qword_1000DBB68 != -1) {
      dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
    }
    id v13 = p_name[364];
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      *(void *)int v23 = 0LL;
      unsigned int v14 = sub_100053B4C(1);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG)) {
        uint64_t v15 = v14;
      }
      else {
        uint64_t v15 = v14 & 0xFFFFFFFE;
      }
      if ((_DWORD)v15)
      {
        uint64_t v24 = -4227858176LL;
        __int128 v16 = (const char *)_os_log_send_and_compose_impl( v15,  v23,  0LL,  0LL,  &_mh_execute_header,  v13,  2LL,  "Unable to find Next Available persona ID, returning %d",  &v24);
        __int128 v17 = (char *)v16;
        if (v16) {
          sub_100053B7C(v16);
        }
      }

      else
      {
        __int128 v17 = 0LL;
      }

      free(v17);
    }

    a2 = 0xFFFFFFFFLL;
  }

  else
  {
    while (sub_100058470(a1, a2))
    {
      a2 = (a2 + 1);
      if (!--a3) {
        goto LABEL_17;
      }
    }

    if (qword_1000DBB68 != -1) {
      dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
    }
    id v13 = p_name[364];
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      *(void *)int v23 = 0LL;
      unsigned int v18 = sub_100053B4C(1);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG)) {
        uint64_t v19 = v18;
      }
      else {
        uint64_t v19 = v18 & 0xFFFFFFFE;
      }
      if ((_DWORD)v19)
      {
        LODWORD(v24) = 67109120;
        HIDWORD(v24) = a2;
        uint64_t v20 = (const char *)_os_log_send_and_compose_impl( v19,  v23,  0LL,  0LL,  &_mh_execute_header,  v13,  2LL,  "Next Available persona ID is %d",  &v24);
        unsigned int v21 = (char *)v20;
        if (v20) {
          sub_100053B7C(v20);
        }
      }

      else
      {
        unsigned int v21 = 0LL;
      }

      free(v21);
    }
  }

  return a2;
}

uint64_t sub_100058470(uint64_t a1, int a2)
{
  if (!a1) {
    return 0LL;
  }
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  unsigned int v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "userPersonas", 0));
  id v5 = [v4 countByEnumeratingWithState:&v15 objects:v19 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v16;
    while (2)
    {
      uint64_t v8 = 0LL;
      do
      {
        if (*(void *)v16 != v7) {
          objc_enumerationMutation(v4);
        }
        uint64_t v9 = *(void *)(*((void *)&v15 + 1) + 8LL * (void)v8);
        id v10 = *(id *)(a1 + 32);
        id v11 = (void *)objc_claimAutoreleasedReturnValue([v10 userPersonas]);
        id v12 = (void *)objc_claimAutoreleasedReturnValue([v11 objectForKeyedSubscript:v9]);

        LOBYTE(v10) = sub_1000585D8(a1, a2, v12);
        if ((v10 & 1) != 0)
        {
          uint64_t v13 = 1LL;
          goto LABEL_12;
        }

        uint64_t v8 = (char *)v8 + 1;
      }

      while (v6 != v8);
      id v6 = [v4 countByEnumeratingWithState:&v15 objects:v19 count:16];
      if (v6) {
        continue;
      }
      break;
    }
  }

  uint64_t v13 = 0LL;
LABEL_12:

  return v13;
}

uint64_t sub_1000585D8(uint64_t a1, int a2, void *a3)
{
  id v4 = a3;
  if (a1)
  {
    if (qword_1000DBB68 != -1) {
      dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
    }
    p_name = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
    id v6 = (os_log_s *)(id)qword_1000DBB60;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v51 = 0LL;
      unsigned int v7 = sub_100053B4C(1);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG)) {
        uint64_t v8 = v7;
      }
      else {
        uint64_t v8 = v7 & 0xFFFFFFFE;
      }
      if ((_DWORD)v8)
      {
        uint64_t v9 = v6;
        *(_DWORD *)unsigned int v48 = 134218240;
        *(void *)&v48[4] = [v4 count];
        __int16 v49 = 1024;
        int v50 = a2;
        id v10 = (char *)_os_log_send_and_compose_impl( v8,  &v51,  0LL,  0LL,  &_mh_execute_header,  v9,  2LL,  "Iterating over numentries:%lu looking for personaID:%u",  v48,  18);

        if (v10) {
          sub_100053B7C(v10);
        }
      }

      else
      {
        id v10 = 0LL;
      }

      p_name = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
      free(v10);
    }

    __int128 v45 = 0u;
    __int128 v46 = 0u;
    __int128 v43 = 0u;
    __int128 v44 = 0u;
    id v41 = v4;
    id v11 = (char *)v4;
    id v12 = [v11 countByEnumeratingWithState:&v43 objects:v47 count:16];
    if (v12)
    {
      id v13 = v12;
      uint64_t v14 = *(void *)v44;
      while (2)
      {
        __int128 v15 = 0LL;
        do
        {
          if (*(void *)v44 != v14) {
            objc_enumerationMutation(v11);
          }
          __int128 v16 = *(void **)(*((void *)&v43 + 1) + 8LL * (void)v15);
          uint64_t v17 = objc_opt_class(&OBJC_CLASS___NSDictionary);
          if ((objc_opt_isKindOfClass(v16, v17) & 1) != 0)
          {
            __int128 v18 = (char *)objc_claimAutoreleasedReturnValue([v16 objectForKeyedSubscript:@"UserPersonaID"]);
            uint64_t v19 = objc_opt_class(&OBJC_CLASS___NSNumber);
            if ((objc_opt_isKindOfClass(v18, v19) & 1) != 0)
            {
              if ([v18 unsignedIntValue] == a2)
              {
                if (qword_1000DBB68 != -1) {
                  dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
                }
                uint64_t v33 = p_name[364];
                if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
                {
                  *(void *)unsigned int v48 = 0LL;
                  unsigned int v34 = sub_100053B4C(1);
                  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG)) {
                    uint64_t v35 = v34;
                  }
                  else {
                    uint64_t v35 = v34 & 0xFFFFFFFE;
                  }
                  if ((_DWORD)v35)
                  {
                    LODWORD(v51) = 67109120;
                    HIDWORD(v51) = a2;
                    uint64_t v36 = (const char *)_os_log_send_and_compose_impl( v35,  v48,  0LL,  0LL,  &_mh_execute_header,  v33,  2LL,  "personaID:%u EXISTS, returning True",  &v51);
                    uint64_t v37 = (char *)v36;
                    if (v36) {
                      sub_100053B7C(v36);
                    }
                  }

                  else
                  {
                    uint64_t v37 = 0LL;
                  }

                  free(v37);
                }

                uint64_t v38 = 1LL;
                goto LABEL_69;
              }
            }

            else
            {
              if (qword_1000DBB68 != -1) {
                dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
              }
              uint64_t v24 = p_name[364];
              if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
              {
                *(void *)unsigned int v48 = 0LL;
                unsigned int v25 = sub_100053B4C(1);
                if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG)) {
                  uint64_t v26 = v25;
                }
                else {
                  uint64_t v26 = v25 & 0xFFFFFFFE;
                }
                if ((_DWORD)v26)
                {
                  LOWORD(v51) = 0;
                  LODWORD(v40) = 2;
                  __int128 v27 = (const char *)_os_log_send_and_compose_impl( v26,  v48,  0LL,  0LL,  &_mh_execute_header,  v24,  2LL,  "Ignoring persona with missing or invalid kernelID in array",  &v51,  v40);
                  __int128 v28 = (char *)v27;
                  if (v27) {
                    sub_100053B7C(v27);
                  }
                }

                else
                {
                  __int128 v28 = 0LL;
                }

                free(v28);
                p_name = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
              }
            }
          }

          else
          {
            if (qword_1000DBB68 != -1) {
              dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
            }
            __int128 v18 = p_name[364];
            if (os_log_type_enabled((os_log_t)v18, OS_LOG_TYPE_DEBUG))
            {
              *(void *)unsigned int v48 = 0LL;
              unsigned int v20 = sub_100053B4C(1);
              if (os_log_type_enabled((os_log_t)v18, OS_LOG_TYPE_DEBUG)) {
                uint64_t v21 = v20;
              }
              else {
                uint64_t v21 = v20 & 0xFFFFFFFE;
              }
              if ((_DWORD)v21)
              {
                LOWORD(v51) = 0;
                LODWORD(v40) = 2;
                uint64_t v22 = (const char *)_os_log_send_and_compose_impl( v21,  v48,  0LL,  0LL,  &_mh_execute_header,  v18,  2LL,  "Ignoring invalid persona in array",  &v51,  v40);
                int v23 = (char *)v22;
                if (v22) {
                  sub_100053B7C(v22);
                }
              }

              else
              {
                int v23 = 0LL;
              }

              p_name = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
              free(v23);
            }
          }

          __int128 v15 = (char *)v15 + 1;
        }

        while (v13 != v15);
        id v13 = [v11 countByEnumeratingWithState:&v43 objects:v47 count:16];
        if (v13) {
          continue;
        }
        break;
      }
    }

    if (qword_1000DBB68 != -1) {
      dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
    }
    id v11 = p_name[364];
    if (os_log_type_enabled((os_log_t)v11, OS_LOG_TYPE_DEBUG))
    {
      *(void *)unsigned int v48 = 0LL;
      unsigned int v29 = sub_100053B4C(1);
      if (os_log_type_enabled((os_log_t)v11, OS_LOG_TYPE_DEBUG)) {
        uint64_t v30 = v29;
      }
      else {
        uint64_t v30 = v29 & 0xFFFFFFFE;
      }
      if ((_DWORD)v30)
      {
        LODWORD(v51) = 67109120;
        HIDWORD(v51) = a2;
        uint64_t v31 = (const char *)_os_log_send_and_compose_impl( v30,  v48,  0LL,  0LL,  &_mh_execute_header,  v11,  2LL,  "personaID:%u DOES NOT EXIST, returning false",  &v51);
        __int16 v32 = (char *)v31;
        if (v31) {
          sub_100053B7C(v31);
        }
      }

      else
      {
        __int16 v32 = 0LL;
      }

      free(v32);
      uint64_t v38 = 0LL;
    }

    else
    {
      uint64_t v38 = 0LL;
LABEL_69:
      id v4 = v41;
    }
  }

  else
  {
    uint64_t v38 = 0LL;
  }

  return v38;
}

id sub_100058BD8(id a1, unsigned int a2, void *a3)
{
  id v4 = a3;
  if (a1)
  {
    p_name = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
    if (qword_1000DBB68 != -1) {
      dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
    }
    id v6 = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
    unsigned int v7 = (os_log_s *)(id)qword_1000DBB60;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v49 = 0LL;
      unsigned int v8 = sub_100053B4C(1);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG)) {
        uint64_t v9 = v8;
      }
      else {
        uint64_t v9 = v8 & 0xFFFFFFFE;
      }
      if ((_DWORD)v9)
      {
        int v51 = 67109120;
        unsigned int v52 = a2;
        id v10 = (const char *)_os_log_send_and_compose_impl( v9,  &v49,  0LL,  0LL,  &_mh_execute_header,  v7,  2LL,  "personaWithType:inArray: by type:%u",  &v51);
        id v11 = (char *)v10;
        if (v10) {
          sub_100053B7C(v10);
        }
      }

      else
      {
        id v11 = 0LL;
      }

      free(v11);
      id v6 = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
    }

    __int128 v47 = 0u;
    __int128 v48 = 0u;
    __int128 v45 = 0u;
    __int128 v46 = 0u;
    unint64_t v12 = (unint64_t)v4;
    id v13 = [(id)v12 countByEnumeratingWithState:&v45 objects:v50 count:16];
    if (v13)
    {
      id v14 = v13;
      id v42 = v4;
      uint64_t v15 = *(void *)v46;
      __int128 v16 = &AKSGetLastUser_ptr;
      uint64_t v43 = *(void *)v46;
      do
      {
        for (uint64_t i = 0LL; i != v14; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v46 != v15) {
            objc_enumerationMutation((id)v12);
          }
          __int128 v18 = *(void **)(*((void *)&v45 + 1) + 8LL * (void)i);
          uint64_t v19 = objc_opt_class(v16[116]);
          if ((objc_opt_isKindOfClass(v18, v19) & 1) != 0)
          {
            unsigned int v20 = (char *)objc_claimAutoreleasedReturnValue([v18 objectForKeyedSubscript:@"UserPersonaType"]);
            uint64_t v21 = objc_opt_class(&OBJC_CLASS___NSNumber);
            char isKindOfClass = objc_opt_isKindOfClass(v20, v21);
            int v23 = p_name[365];
            if ((isKindOfClass & 1) != 0)
            {
              uint64_t v24 = v6[364];
              if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
              {
                unsigned int v25 = v16;
                unint64_t v26 = v12;
                uint64_t v49 = 0LL;
                LODWORD(v12) = sub_100053B4C(1);
                if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG)) {
                  unint64_t v12 = v12;
                }
                else {
                  unint64_t v12 = v12 & 0xFFFFFFFE;
                }
                if ((_DWORD)v12)
                {
                  __int128 v27 = p_name;
                  __int128 v28 = v24;
                  unsigned int v29 = [v20 unsignedIntValue];
                  int v51 = 67109120;
                  unsigned int v52 = v29;
                  uint64_t v30 = (char *)_os_log_send_and_compose_impl( v12,  &v49,  0LL,  0LL,  &_mh_execute_header,  v28,  2LL,  "personaWithType:inArray: by type:%u EXISTS, returning",  &v51);

                  if (v30) {
                    sub_100053B7C(v30);
                  }
                  p_name = v27;
                  id v6 = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
                }

                else
                {
                  uint64_t v30 = 0LL;
                }

                free(v30);
                unint64_t v12 = v26;
                __int128 v16 = v25;
                uint64_t v15 = v43;
              }

              if ([v20 unsignedIntValue] == a2)
              {
                a1 = v18;

                goto LABEL_60;
              }
            }

            else
            {
              uint64_t v35 = v6[364];
              if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v49 = 0LL;
                unsigned int v36 = sub_100053B4C(1);
                if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG)) {
                  uint64_t v37 = v36;
                }
                else {
                  uint64_t v37 = v36 & 0xFFFFFFFE;
                }
                if ((_DWORD)v37)
                {
                  LOWORD(v51) = 0;
                  LODWORD(v41) = 2;
                  uint64_t v38 = (const char *)_os_log_send_and_compose_impl( v37,  &v49,  0LL,  0LL,  &_mh_execute_header,  v35,  2LL,  "Ignoring persona with missing or invalid type in array",  &v51,  v41);
                  int v39 = (char *)v38;
                  if (v38) {
                    sub_100053B7C(v38);
                  }
                }

                else
                {
                  int v39 = 0LL;
                }

                free(v39);
              }
            }
          }

          else
          {
            unsigned int v20 = v6[364];
            if (os_log_type_enabled((os_log_t)v20, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v49 = 0LL;
              unsigned int v31 = sub_100053B4C(1);
              if (os_log_type_enabled((os_log_t)v20, OS_LOG_TYPE_DEBUG)) {
                uint64_t v32 = v31;
              }
              else {
                uint64_t v32 = v31 & 0xFFFFFFFE;
              }
              if ((_DWORD)v32)
              {
                LOWORD(v51) = 0;
                LODWORD(v41) = 2;
                uint64_t v33 = (const char *)_os_log_send_and_compose_impl( v32,  &v49,  0LL,  0LL,  &_mh_execute_header,  v20,  2LL,  "Ignoring invalid persona in array",  &v51,  v41);
                unsigned int v34 = (char *)v33;
                if (v33) {
                  sub_100053B7C(v33);
                }
              }

              else
              {
                unsigned int v34 = 0LL;
              }

              free(v34);
            }
          }
        }

        id v14 = [(id)v12 countByEnumeratingWithState:&v45 objects:v50 count:16];
      }

      while (v14);
      a1 = 0LL;
LABEL_60:
      id v4 = v42;
    }

    else
    {
      a1 = 0LL;
    }
  }

  return a1;
}

id sub_1000590FC(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  unsigned int v7 = v6;
  id v8 = 0LL;
  if (a1 && v5)
  {
    __int128 v38 = 0u;
    __int128 v39 = 0u;
    __int128 v36 = 0u;
    __int128 v37 = 0u;
    id v9 = v6;
    id v8 = [v9 countByEnumeratingWithState:&v36 objects:v40 count:16];
    if (v8)
    {
      id v31 = v5;
      uint64_t v10 = *(void *)v37;
      do
      {
        id v11 = 0LL;
        do
        {
          if (*(void *)v37 != v10) {
            objc_enumerationMutation(v9);
          }
          unint64_t v12 = *(void **)(*((void *)&v36 + 1) + 8LL * (void)v11);
          uint64_t v13 = objc_opt_class(&OBJC_CLASS___NSMutableDictionary);
          if ((objc_opt_isKindOfClass(v12, v13) & 1) != 0)
          {
            uint64_t v14 = objc_claimAutoreleasedReturnValue([v12 objectForKeyedSubscript:@"UserPersonaUniqueString"]);
            uint64_t v15 = objc_opt_class(&OBJC_CLASS___NSString);
            uint64_t v33 = (void *)v14;
            if ((objc_opt_isKindOfClass(v14, v15) & 1) != 0)
            {
              id v16 = sub_1000850A0(v12, (uint64_t)@"UserPersonaUniqueString");
              uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
              unsigned __int8 v32 = [v17 isEqualToString:v31];

              if ((v32 & 1) != 0)
              {
                id v8 = v12;

                goto LABEL_38;
              }
            }

            else
            {
              if (qword_1000DBB68 != -1) {
                dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
              }
              uint64_t v24 = (os_log_s *)(id)qword_1000DBB60;
              if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v35 = 0LL;
                unsigned int v25 = sub_100053B4C(1);
                if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG)) {
                  uint64_t v26 = v25;
                }
                else {
                  uint64_t v26 = v25 & 0xFFFFFFFE;
                }
                if ((_DWORD)v26)
                {
                  __int16 v34 = 0;
                  LODWORD(v30) = 2;
                  __int128 v27 = (const char *)_os_log_send_and_compose_impl( v26,  &v35,  0LL,  0LL,  &_mh_execute_header,  v24,  2LL,  "Persona does not have a valid unique string",  &v34,  v30);
                  __int128 v28 = (char *)v27;
                  if (v27) {
                    sub_100053B7C(v27);
                  }
                }

                else
                {
                  __int128 v28 = 0LL;
                }

                free(v28);
              }
            }

            __int128 v18 = (os_log_s *)v33;
          }

          else
          {
            if (qword_1000DBB68 != -1) {
              dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
            }
            __int128 v18 = (os_log_s *)(id)qword_1000DBB60;
            if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v35 = 0LL;
              unsigned int v19 = sub_100053B4C(1);
              if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG)) {
                uint64_t v20 = v19;
              }
              else {
                uint64_t v20 = v19 & 0xFFFFFFFE;
              }
              if ((_DWORD)v20)
              {
                __int16 v34 = 0;
                LODWORD(v30) = 2;
                uint64_t v21 = v18;
                uint64_t v22 = (const char *)_os_log_send_and_compose_impl( v20,  &v35,  0LL,  0LL,  &_mh_execute_header,  v18,  2LL,  "got NULL dictionary",  &v34,  v30);
                int v23 = (char *)v22;
                if (v22) {
                  sub_100053B7C(v22);
                }
              }

              else
              {
                uint64_t v21 = v18;
                int v23 = 0LL;
              }

              free(v23);
              __int128 v18 = v21;
            }
          }

          id v11 = (char *)v11 + 1;
        }

        while (v8 != v11);
        id v8 = [v9 countByEnumeratingWithState:&v36 objects:v40 count:16];
      }

      while (v8);
LABEL_38:
      id v5 = v31;
    }
  }

  return v8;
}

id sub_100059470(id result, uint64_t a2, void *a3)
{
  if (result)
  {
    if (a2) {
      return [a3 addObject:a2];
    }
  }

  return result;
}

void sub_100059488(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  id v6 = v5;
  if (!a1) {
    goto LABEL_17;
  }
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  id v7 = v5;
  id v8 = [v7 countByEnumeratingWithState:&v18 objects:v22 count:16];
  if (!v8) {
    goto LABEL_16;
  }
  id v9 = v8;
  uint64_t v17 = v6;
  uint64_t v10 = *(void *)v19;
LABEL_4:
  uint64_t v11 = 0LL;
  while (1)
  {
    if (*(void *)v19 != v10) {
      objc_enumerationMutation(v7);
    }
    unint64_t v12 = *(void **)(*((void *)&v18 + 1) + 8 * v11);
    uint64_t v13 = objc_opt_class(&OBJC_CLASS___NSMutableDictionary);
    if ((objc_opt_isKindOfClass(v12, v13) & 1) == 0) {
      goto LABEL_11;
    }
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v12 objectForKeyedSubscript:@"UserPersonaID"]);
    uint64_t v15 = objc_opt_class(&OBJC_CLASS___NSNumber);

LABEL_11:
    if (v9 == (id)++v11)
    {
      id v9 = [v7 countByEnumeratingWithState:&v18 objects:v22 count:16];
      if (v9) {
        goto LABEL_4;
      }
      id v6 = v17;
      goto LABEL_16;
    }
  }

  id v16 = v12;

  id v6 = v17;
  if (!v16) {
    goto LABEL_17;
  }
  [v7 removeObjectIdenticalTo:v16];
  id v7 = v16;
LABEL_16:

LABEL_17:
}

uint64_t sub_10005962C(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  id v6 = v5;
  if (!a1)
  {
    uint64_t v16 = 0LL;
    goto LABEL_30;
  }

  __int128 v28 = 0u;
  __int128 v29 = 0u;
  __int128 v26 = 0u;
  __int128 v27 = 0u;
  id v7 = v5;
  id v8 = [v7 countByEnumeratingWithState:&v26 objects:v31 count:16];
  if (!v8)
  {
    uint64_t v16 = 0LL;
    id v17 = v7;
    goto LABEL_29;
  }

  id v9 = v8;
  uint64_t v24 = v6;
  uint64_t v10 = *(void *)v27;
LABEL_4:
  uint64_t v11 = 0LL;
  while (1)
  {
    if (*(void *)v27 != v10) {
      objc_enumerationMutation(v7);
    }
    unint64_t v12 = *(void **)(*((void *)&v26 + 1) + 8 * v11);
    uint64_t v13 = objc_opt_class(&OBJC_CLASS___NSMutableDictionary);
    if ((objc_opt_isKindOfClass(v12, v13) & 1) == 0) {
      goto LABEL_11;
    }
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v12 objectForKeyedSubscript:@"UserPersonaType"]);
    uint64_t v15 = objc_opt_class(&OBJC_CLASS___NSNumber);

LABEL_11:
    if (v9 == (id)++v11)
    {
      id v9 = [v7 countByEnumeratingWithState:&v26 objects:v31 count:16];
      if (v9) {
        goto LABEL_4;
      }
      uint64_t v16 = 0LL;
      id v17 = v7;
      id v6 = v24;
      goto LABEL_29;
    }
  }

  id v17 = v12;

  if (!v17)
  {
    uint64_t v16 = 0LL;
    id v6 = v24;
    goto LABEL_30;
  }

  id v6 = v24;
  if (qword_1000DBB68 != -1) {
    dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
  }
  __int128 v18 = (os_log_s *)(id)qword_1000DBB60;
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v25 = 0LL;
    unsigned int v19 = sub_100053B4C(1);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG)) {
      uint64_t v20 = v19;
    }
    else {
      uint64_t v20 = v19 & 0xFFFFFFFE;
    }
    if ((_DWORD)v20)
    {
      v30[0] = 67109120;
      v30[1] = a2;
      __int128 v21 = (const char *)_os_log_send_and_compose_impl( v20,  &v25,  0LL,  0LL,  &_mh_execute_header,  v18,  2LL,  "found the PersonaSession with type=%u, removing",  v30);
      uint64_t v22 = (char *)v21;
      if (v21) {
        sub_100053B7C(v21);
      }
    }

    else
    {
      uint64_t v22 = 0LL;
    }

    free(v22);
  }

  [v7 removeObjectIdenticalTo:v17];
  uint64_t v16 = 1LL;
LABEL_29:

LABEL_30:
  return v16;
}

id sub_1000598D8(uint64_t a1, void *a2)
{
  id v2 = 0LL;
  if (a1 && a2)
  {
    id v3 = *(void **)(a1 + 32);
    id v4 = a2;
    id v5 = (void *)objc_claimAutoreleasedReturnValue([v3 userPersonas]);
    id v2 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:v4]);
  }

  return v2;
}

id sub_10005993C(uint64_t a1, void *a2, _DWORD *a3)
{
  if (!a1) {
    return 0LL;
  }
  if (a3) {
    *a3 = 0;
  }
  id v4 = sub_1000598D8(a1, a2);
  id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  if ([v5 count])
  {
    if (qword_1000DBB68 != -1) {
      dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
    }
    id v6 = (os_log_s *)(id)qword_1000DBB60;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      v18[0] = 0LL;
      unsigned int v7 = sub_100053B4C(1);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG)) {
        uint64_t v8 = v7;
      }
      else {
        uint64_t v8 = v7 & 0xFFFFFFFE;
      }
      if ((_DWORD)v8)
      {
        *(_DWORD *)unsigned int v19 = 138412290;
        *(void *)&v19[4] = v5;
        id v9 = (const char *)_os_log_send_and_compose_impl( v8,  v18,  0LL,  0LL,  &_mh_execute_header,  v6,  2LL,  "Returning All Persona List: %@",  v19,  12);
        uint64_t v10 = (char *)v9;
        if (v9) {
          sub_100053B7C(v9);
        }
      }

      else
      {
        uint64_t v10 = 0LL;
      }

      free(v10);
    }

    id v16 = v5;
  }

  else
  {
    if (qword_1000DBB68 != -1) {
      dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
    }
    uint64_t v11 = (os_log_s *)(id)qword_1000DBB60;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      *(void *)unsigned int v19 = 0LL;
      unsigned int v12 = sub_100053B4C(1);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG)) {
        uint64_t v13 = v12;
      }
      else {
        uint64_t v13 = v12 & 0xFFFFFFFE;
      }
      if ((_DWORD)v13)
      {
        LOWORD(v18[0]) = 0;
        uint64_t v14 = (const char *)_os_log_send_and_compose_impl( v13,  v19,  0LL,  0LL,  &_mh_execute_header,  v11,  2LL,  "No persona Entries to return",  v18,  2);
        uint64_t v15 = (char *)v14;
        if (v14) {
          sub_100053B7C(v14);
        }
      }

      else
      {
        uint64_t v15 = 0LL;
      }

      free(v15);
    }

    id v16 = 0LL;
    if (a3) {
      *a3 = 2;
    }
  }

  return v16;
}

id *sub_100059B88(id *a1, _DWORD *a2)
{
  id v2 = a1;
  if (a1)
  {
    if (a2) {
      *a2 = 0;
    }
    id v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
    __int128 v26 = 0u;
    __int128 v27 = 0u;
    __int128 v28 = 0u;
    __int128 v29 = 0u;
    id v5 = (void *)objc_claimAutoreleasedReturnValue([v2[4] userPersonas]);
    id v6 = [v5 countByEnumeratingWithState:&v26 objects:v31 count:16];
    if (v6)
    {
      id v7 = v6;
      uint64_t v8 = *(void *)v27;
      do
      {
        for (uint64_t i = 0LL; i != v7; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v27 != v8) {
            objc_enumerationMutation(v5);
          }
          uint64_t v10 = *(void *)(*((void *)&v26 + 1) + 8LL * (void)i);
          id v11 = v2[4];
          unsigned int v12 = (void *)objc_claimAutoreleasedReturnValue([v11 userPersonas]);
          uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v12 objectForKeyedSubscript:v10]);
          [v4 addObjectsFromArray:v13];
        }

        id v7 = [v5 countByEnumeratingWithState:&v26 objects:v31 count:16];
      }

      while (v7);
    }

    if ([v4 count])
    {
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      uint64_t v14 = (os_log_s *)(id)qword_1000DBB60;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        v25[0] = 0LL;
        unsigned int v15 = sub_100053B4C(1);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG)) {
          uint64_t v16 = v15;
        }
        else {
          uint64_t v16 = v15 & 0xFFFFFFFE;
        }
        if ((_DWORD)v16)
        {
          *(_DWORD *)uint64_t v30 = 138412290;
          *(void *)&_DWORD v30[4] = v4;
          id v17 = (const char *)_os_log_send_and_compose_impl( v16,  v25,  0LL,  0LL,  &_mh_execute_header,  v14,  2LL,  "Returning All Persona List: %@",  v30,  12);
          __int128 v18 = (char *)v17;
          if (v17) {
            sub_100053B7C(v17);
          }
        }

        else
        {
          __int128 v18 = 0LL;
        }

        free(v18);
      }

      id v2 = v4;
    }

    else
    {
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      unsigned int v19 = (os_log_s *)(id)qword_1000DBB60;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
      {
        *(void *)uint64_t v30 = 0LL;
        unsigned int v20 = sub_100053B4C(1);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG)) {
          uint64_t v21 = v20;
        }
        else {
          uint64_t v21 = v20 & 0xFFFFFFFE;
        }
        if ((_DWORD)v21)
        {
          LOWORD(v25[0]) = 0;
          uint64_t v22 = (const char *)_os_log_send_and_compose_impl( v21,  v30,  0LL,  0LL,  &_mh_execute_header,  v19,  2LL,  "No persona Entries to return",  v25,  2);
          int v23 = (char *)v22;
          if (v22) {
            sub_100053B7C(v22);
          }
        }

        else
        {
          int v23 = 0LL;
        }

        free(v23);
      }

      id v2 = 0LL;
      if (a2) {
        *a2 = 2;
      }
    }
  }

  return v2;
}

id sub_100059EB8(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  if (a1)
  {
    id v6 = sub_1000598D8((uint64_t)a1, a3);
    id v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
    uint64_t v8 = objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:@"UserPersonaUniqueString"]);
    if (v8
      && (id v9 = (void *)v8,
          uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:@"UserPersonaUniqueString"]),
          uint64_t v11 = objc_opt_class(&OBJC_CLASS___NSString),
          char v12 = objc_opt_isKindOfClass(v10, v11),
          v10,
          v9,
          (v12 & 1) != 0))
    {
      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:@"UserPersonaUniqueString"]);
      id v14 = sub_1000590FC((uint64_t)a1, v13, v7);
      uint64_t v15 = objc_claimAutoreleasedReturnValue(v14);
    }

    else
    {
      uint64_t v16 = objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:@"UserPersonaType"]);
      if (!v16
        || (id v17 = (void *)v16,
            __int128 v18 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:@"UserPersonaType"]),
            uint64_t v19 = objc_opt_class(&OBJC_CLASS___NSNumber),
            char isKindOfClass = objc_opt_isKindOfClass(v18, v19),
            v18,
            v17,
            (isKindOfClass & 1) == 0))
      {
        a1 = 0LL;
        goto LABEL_10;
      }

      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:@"UserPersonaType"]);
      id v21 = sub_100058BD8(a1, [v13 unsignedLongValue], v7);
      uint64_t v15 = objc_claimAutoreleasedReturnValue(v21);
    }

    a1 = (void *)v15;

LABEL_10:
  }

  return a1;
}

id sub_10005A03C(void *a1, void *a2, void *a3, _DWORD *a4)
{
  id v7 = a2;
  if (a1)
  {
    if (a4) {
      *a4 = 0;
    }
    id v8 = sub_100059EB8(a1, v7, a3);
    id v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
    if (v9)
    {
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      uint64_t v10 = (os_log_s *)(id)qword_1000DBB60;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v22 = 0LL;
        unsigned int v11 = sub_100053B4C(1);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
          uint64_t v12 = v11;
        }
        else {
          uint64_t v12 = v11 & 0xFFFFFFFE;
        }
        if ((_DWORD)v12)
        {
          int v23 = 138412290;
          id v24 = v9;
          uint64_t v13 = (const char *)_os_log_send_and_compose_impl( v12,  &v22,  0LL,  0LL,  &_mh_execute_header,  v10,  2LL,  "Found persona and returning: %@",  &v23,  12);
          id v14 = (char *)v13;
          if (v13) {
            sub_100053B7C(v13);
          }
        }

        else
        {
          id v14 = 0LL;
        }

        free(v14);
      }

      id v20 = v9;
    }

    else
    {
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      uint64_t v15 = (os_log_s *)(id)qword_1000DBB60;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v22 = 0LL;
        unsigned int v16 = sub_100053B4C(1);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG)) {
          uint64_t v17 = v16;
        }
        else {
          uint64_t v17 = v16 & 0xFFFFFFFE;
        }
        if ((_DWORD)v17)
        {
          int v23 = 138412290;
          id v24 = v7;
          __int128 v18 = (const char *)_os_log_send_and_compose_impl( v17,  &v22,  0LL,  0LL,  &_mh_execute_header,  v15,  2LL,  "NO Persona Session found for %@",  &v23,  12);
          uint64_t v19 = (char *)v18;
          if (v18) {
            sub_100053B7C(v18);
          }
        }

        else
        {
          uint64_t v19 = 0LL;
        }

        free(v19);
      }

      if (a4) {
        *a4 = 2;
      }
    }
  }

  else
  {
    id v9 = 0LL;
  }

  return v9;
}

id sub_10005A2A8(void *a1, void *a2, void *a3, _DWORD *a4)
{
  id v7 = a2;
  id v8 = a3;
  if (!a1)
  {
    uint64_t v43 = 0LL;
    goto LABEL_82;
  }

  if (a4) {
    *a4 = 0;
  }
  if (qword_1000DBB68 != -1) {
    dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
  }
  id v9 = (os_log_s *)(id)qword_1000DBB60;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    v47[0] = 0LL;
    unsigned int v10 = sub_100053B4C(1);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG)) {
      uint64_t v11 = v10;
    }
    else {
      uint64_t v11 = v10 & 0xFFFFFFFE;
    }
    if ((_DWORD)v11)
    {
      *(_DWORD *)__int128 v48 = 138412290;
      *(void *)&v48[4] = v7;
      uint64_t v12 = (const char *)_os_log_send_and_compose_impl( v11,  v47,  0LL,  0LL,  &_mh_execute_header,  v9,  2LL,  "Fetching BundleIDs for Persona %@",  v48,  12);
      uint64_t v13 = (char *)v12;
      if (v12) {
        sub_100053B7C(v12);
      }
    }

    else
    {
      uint64_t v13 = 0LL;
    }

    free(v13);
  }

  id v14 = sub_100059EB8(a1, v7, v8);
  uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
  if (!v15)
  {
    if (qword_1000DBB68 != -1) {
      dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
    }
    id v21 = (os_log_s *)(id)qword_1000DBB60;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      v47[0] = 0LL;
      unsigned int v22 = sub_100053B4C(1);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG)) {
        uint64_t v23 = v22;
      }
      else {
        uint64_t v23 = v22 & 0xFFFFFFFE;
      }
      if ((_DWORD)v23)
      {
        *(_DWORD *)__int128 v48 = 138412290;
        *(void *)&v48[4] = v7;
        LODWORD(v46) = 12;
        id v24 = (const char *)_os_log_send_and_compose_impl( v23,  v47,  0LL,  0LL,  &_mh_execute_header,  v21,  2LL,  "FOUND NO PERSONA DICT for %@",  v48,  v46);
        uint64_t v25 = (char *)v24;
        if (v24) {
          sub_100053B7C(v24);
        }
      }

      else
      {
        uint64_t v25 = 0LL;
      }

      free(v25);
    }

    uint64_t v43 = 0LL;
    if (a4) {
      *a4 = 2;
    }
    goto LABEL_81;
  }

  if (qword_1000DBB68 != -1) {
    dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
  }
  unsigned int v16 = (os_log_s *)(id)qword_1000DBB60;
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
  {
    v47[0] = 0LL;
    unsigned int v17 = sub_100053B4C(1);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG)) {
      uint64_t v18 = v17;
    }
    else {
      uint64_t v18 = v17 & 0xFFFFFFFE;
    }
    if ((_DWORD)v18)
    {
      *(_DWORD *)__int128 v48 = 138412290;
      *(void *)&v48[4] = v15;
      LODWORD(v46) = 12;
      uint64_t v19 = (const char *)_os_log_send_and_compose_impl( v18,  v47,  0LL,  0LL,  &_mh_execute_header,  v16,  2LL,  "Found Persona:%@ and fetching bundleIDs",  v48,  v46);
      id v20 = (char *)v19;
      if (v19) {
        sub_100053B7C(v19);
      }
    }

    else
    {
      id v20 = 0LL;
    }

    free(v20);
  }

  __int128 v26 = (void *)objc_claimAutoreleasedReturnValue([v15 objectForKeyedSubscript:@"UserPersonaBundleIDS"]);
  if (v26)
  {
    uint64_t v27 = objc_opt_class(&OBJC_CLASS___NSArray);
    if ((objc_opt_isKindOfClass(v26, v27) & 1) == 0)
    {
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      __int128 v38 = (os_log_s *)(id)qword_1000DBB60;
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)__int128 v48 = 0LL;
        unsigned int v39 = sub_100053B4C(1);
        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v40 = v39;
        }
        else {
          uint64_t v40 = v39 & 0xFFFFFFFE;
        }
        if ((_DWORD)v40)
        {
          LOWORD(v47[0]) = 0;
          LODWORD(v46) = 2;
          uint64_t v41 = (const char *)_os_log_send_and_compose_impl( v40,  v48,  0LL,  0LL,  &_mh_execute_header,  v38,  0LL,  "Found non-array bundle IDs in persona",  v47,  v46);
          id v42 = (char *)v41;
          if (v41) {
            sub_100053B7C(v41);
          }
        }

        else
        {
          id v42 = 0LL;
        }

        free(v42);
      }

      uint64_t v43 = 0LL;
      if (a4) {
        *a4 = 22;
      }
      goto LABEL_80;
    }

    if (qword_1000DBB68 != -1) {
      dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
    }
    __int128 v28 = (os_log_s *)(id)qword_1000DBB60;
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
    {
      v47[0] = 0LL;
      unsigned int v29 = sub_100053B4C(1);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG)) {
        uint64_t v30 = v29;
      }
      else {
        uint64_t v30 = v29 & 0xFFFFFFFE;
      }
      if ((_DWORD)v30)
      {
        *(_DWORD *)__int128 v48 = 138412290;
        *(void *)&v48[4] = v26;
        LODWORD(v46) = 12;
        id v31 = (const char *)_os_log_send_and_compose_impl( v30,  v47,  0LL,  0LL,  &_mh_execute_header,  v28,  2LL,  "Returning bundleID List: %@",  v48,  v46);
        unsigned __int8 v32 = (char *)v31;
        if (v31) {
          sub_100053B7C(v31);
        }
      }

      else
      {
        unsigned __int8 v32 = 0LL;
      }

      free(v32);
    }

    id v44 = v26;
  }

  else
  {
    if (qword_1000DBB68 != -1) {
      dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
    }
    uint64_t v33 = (os_log_s *)(id)qword_1000DBB60;
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
    {
      *(void *)__int128 v48 = 0LL;
      unsigned int v34 = sub_100053B4C(1);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG)) {
        uint64_t v35 = v34;
      }
      else {
        uint64_t v35 = v34 & 0xFFFFFFFE;
      }
      if ((_DWORD)v35)
      {
        LOWORD(v47[0]) = 0;
        LODWORD(v46) = 2;
        __int128 v36 = (const char *)_os_log_send_and_compose_impl( v35,  v48,  0LL,  0LL,  &_mh_execute_header,  v33,  2LL,  "No bundleIDs list found",  v47,  v46);
        __int128 v37 = (char *)v36;
        if (v36) {
          sub_100053B7C(v36);
        }
      }

      else
      {
        __int128 v37 = 0LL;
      }

      free(v37);
    }

    id v44 = (id)objc_claimAutoreleasedReturnValue(+[NSArray array](&OBJC_CLASS___NSArray, "array"));
  }

  uint64_t v43 = v44;
LABEL_80:

LABEL_81:
LABEL_82:

  return v43;
}

void sub_10005A8C0(id *a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    if (v3)
    {
      id v5 = (void *)objc_claimAutoreleasedReturnValue([a1[4] userPersonas]);
      id v6 = (id)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:v4]);

      if (!v6)
      {
        id v6 = (id)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
        id v7 = (void *)objc_claimAutoreleasedReturnValue([a1[4] userPersonas]);
        [v7 setObject:v6 forKeyedSubscript:v4];
      }

      id v8 = sub_10005AE10(a1, v6, 0LL, v4);
      id v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
      if (!v9)
      {
        if (qword_1000DBB68 != -1) {
          dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
        }
        unsigned int v10 = (os_log_s *)(id)qword_1000DBB60;
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v42 = 0LL;
          unsigned int v11 = sub_100053B4C(1);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v12 = v11;
          }
          else {
            uint64_t v12 = v11 & 0xFFFFFFFE;
          }
          if ((_DWORD)v12)
          {
            __int16 v41 = 0;
            uint64_t v13 = (const char *)_os_log_send_and_compose_impl( v12,  &v42,  0LL,  0LL,  &_mh_execute_header,  v10,  0LL,  "Failed to create Personal persona",  &v41,  2);
            id v14 = (char *)v13;
            if (v13) {
              sub_100053B7C(v13);
            }
          }

          else
          {
            id v14 = 0LL;
          }

          free(v14);
        }
      }

      uint64_t v19 = sub_10005AE10(a1, v6, 3LL, v4);
      id v20 = (void *)objc_claimAutoreleasedReturnValue(v19);

      if (!v20)
      {
        if (qword_1000DBB68 != -1) {
          dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
        }
        id v21 = (os_log_s *)(id)qword_1000DBB60;
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v42 = 0LL;
          unsigned int v22 = sub_100053B4C(1);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v23 = v22;
          }
          else {
            uint64_t v23 = v22 & 0xFFFFFFFE;
          }
          if ((_DWORD)v23)
          {
            __int16 v41 = 0;
            LODWORD(v40) = 2;
            id v24 = (const char *)_os_log_send_and_compose_impl( v23,  &v42,  0LL,  0LL,  &_mh_execute_header,  v21,  0LL,  "Failed to create System persona",  &v41,  v40);
            uint64_t v25 = (char *)v24;
            if (v24) {
              sub_100053B7C(v24);
            }
          }

          else
          {
            uint64_t v25 = 0LL;
          }

          free(v25);
        }
      }

      __int128 v26 = sub_10005AE10(a1, v6, 5LL, v4);
      uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue(v26);

      if (!v27)
      {
        if (qword_1000DBB68 != -1) {
          dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
        }
        __int128 v28 = (os_log_s *)(id)qword_1000DBB60;
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v42 = 0LL;
          unsigned int v29 = sub_100053B4C(1);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v30 = v29;
          }
          else {
            uint64_t v30 = v29 & 0xFFFFFFFE;
          }
          if ((_DWORD)v30)
          {
            __int16 v41 = 0;
            LODWORD(v40) = 2;
            id v31 = (const char *)_os_log_send_and_compose_impl( v30,  &v42,  0LL,  0LL,  &_mh_execute_header,  v28,  0LL,  "Failed to create Default persona",  &v41,  v40);
            unsigned __int8 v32 = (char *)v31;
            if (v31) {
              sub_100053B7C(v31);
            }
          }

          else
          {
            unsigned __int8 v32 = 0LL;
          }

          free(v32);
        }
      }

      uint64_t v33 = sub_10005AE10(a1, v6, 4LL, v4);
      unsigned int v34 = (void *)objc_claimAutoreleasedReturnValue(v33);

      if (!v34)
      {
        if (qword_1000DBB68 != -1) {
          dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
        }
        uint64_t v35 = (os_log_s *)(id)qword_1000DBB60;
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v42 = 0LL;
          unsigned int v36 = sub_100053B4C(1);
          if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v37 = v36;
          }
          else {
            uint64_t v37 = v36 & 0xFFFFFFFE;
          }
          if ((_DWORD)v37)
          {
            __int16 v41 = 0;
            LODWORD(v40) = 2;
            __int128 v38 = (const char *)_os_log_send_and_compose_impl( v37,  &v42,  0LL,  0LL,  &_mh_execute_header,  v35,  0LL,  "Failed to create Universal persona",  &v41,  v40);
            unsigned int v39 = (char *)v38;
            if (v38) {
              sub_100053B7C(v38);
            }
          }

          else
          {
            unsigned int v39 = 0LL;
          }

          free(v39);
        }
      }

      sub_10005B2D0((uint64_t)a1);
    }

    else
    {
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      id v6 = (id)qword_1000DBB60;
      if (os_log_type_enabled((os_log_t)v6, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v42 = 0LL;
        unsigned int v15 = sub_100053B4C(1);
        if (os_log_type_enabled((os_log_t)v6, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v16 = v15;
        }
        else {
          uint64_t v16 = v15 & 0xFFFFFFFE;
        }
        if ((_DWORD)v16)
        {
          __int16 v41 = 0;
          unsigned int v17 = (const char *)_os_log_send_and_compose_impl( v16,  &v42,  0LL,  0LL,  &_mh_execute_header,  v6,  0LL,  "User UUID NULL when Creating default persona",  &v41,  2);
          uint64_t v18 = (char *)v17;
          if (v17) {
            sub_100053B7C(v17);
          }
        }

        else
        {
          uint64_t v18 = 0LL;
        }

        free(v18);
      }
    }
  }
}

id *sub_10005AE10(id *a1, void *a2, uint64_t a3, void *a4)
{
  id v4 = a1;
  if (a1)
  {
    unsigned int v34 = @"UserPersonaType";
    id v7 = a4;
    id v8 = a2;
    id v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", a3));
    uint64_t v35 = v9;
    unsigned int v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v35,  &v34,  1LL));
    id v11 = [v10 mutableCopy];

    [v11 setObject:v7 forKeyedSubscript:@"UserPersonaUserODUUID"];
    unsigned int v32 = 0;
    uint64_t v12 = sub_10005B318(v4, v8, v11, 0LL, 0, 1, &v32);
    id v4 = (id *)objc_claimAutoreleasedReturnValue(v12);

    if (!v4)
    {
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      unsigned int v17 = (os_log_s *)(id)qword_1000DBB60;
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v31 = 0LL;
        unsigned int v18 = sub_100053B4C(1);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v19 = v18;
        }
        else {
          uint64_t v19 = v18 & 0xFFFFFFFE;
        }
        if ((_DWORD)v19)
        {
          v33[0] = 67109120;
          v33[1] = v32;
          id v20 = (const char *)_os_log_send_and_compose_impl( v19,  &v31,  0LL,  0LL,  &_mh_execute_header,  v17,  0LL,  "Failed to create persona with error:%d",  v33);
          id v21 = (char *)v20;
          if (v20) {
            sub_100053B7C(v20);
          }
        }

        else
        {
          id v21 = 0LL;
        }

        free(v21);
      }

      goto LABEL_55;
    }

    switch((_DWORD)a3)
    {
      case 3:
        if (qword_1000DBB68 != -1) {
          dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
        }
        uint64_t v13 = (os_log_s *)(id)qword_1000DBB60;
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_51;
        }
        uint64_t v31 = 0LL;
        unsigned int v22 = sub_100053B4C(1);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v23 = v22;
        }
        else {
          uint64_t v23 = v22 & 0xFFFFFFFE;
        }
        if (!(_DWORD)v23) {
          goto LABEL_49;
        }
        LOWORD(v33[0]) = 0;
        uint64_t v16 = (const char *)_os_log_send_and_compose_impl( v23,  &v31,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "Created System Persona Successfully",  v33,  2);
        break;
      case 5:
        if (qword_1000DBB68 != -1) {
          dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
        }
        uint64_t v13 = (os_log_s *)(id)qword_1000DBB60;
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_51;
        }
        uint64_t v31 = 0LL;
        unsigned int v24 = sub_100053B4C(1);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v25 = v24;
        }
        else {
          uint64_t v25 = v24 & 0xFFFFFFFE;
        }
        if (!(_DWORD)v25) {
          goto LABEL_49;
        }
        LOWORD(v33[0]) = 0;
        uint64_t v16 = (const char *)_os_log_send_and_compose_impl( v25,  &v31,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "Created Default Persona Successfully",  v33,  2);
        break;
      case 4:
        if (qword_1000DBB68 != -1) {
          dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
        }
        uint64_t v13 = (os_log_s *)(id)qword_1000DBB60;
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_51;
        }
        uint64_t v31 = 0LL;
        unsigned int v14 = sub_100053B4C(1);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v15 = v14;
        }
        else {
          uint64_t v15 = v14 & 0xFFFFFFFE;
        }
        if ((_DWORD)v15)
        {
          LOWORD(v33[0]) = 0;
          uint64_t v16 = (const char *)_os_log_send_and_compose_impl( v15,  &v31,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "Created Universal Persona Successfully",  v33,  2);
          break;
        }

uint64_t sub_10005B2D0(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    id v2 = sub_10006002C(result);
    id v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
    uint64_t v4 = sub_1000601E8(v1, v3, 0LL);

    return v4;
  }

  return result;
}

os_log_s *sub_10005B318(id *a1, void *a2, void *a3, void *a4, int a5, char a6, unsigned int *a7)
{
  id v13 = a2;
  id v14 = a3;
  id v15 = a4;
  v316 = v13;
  if (!a1)
  {
    id v262 = 0LL;
    goto LABEL_473;
  }

  uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v14 objectForKeyedSubscript:@"UserPersonaUserODUUID"]);

  if (!v16)
  {
    if (qword_1000DBB68 != -1) {
      dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
    }
    unsigned int v24 = (os_log_s *)(id)qword_1000DBB60;
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)unsigned int v324 = 0LL;
      unsigned int v25 = sub_100053B4C(1);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v26 = v25;
      }
      else {
        uint64_t v26 = v25 & 0xFFFFFFFE;
      }
      if ((_DWORD)v26)
      {
        LOWORD(v327[0]) = 0;
        uint64_t v27 = (const char *)_os_log_send_and_compose_impl( v26,  v324,  0LL,  0LL,  &_mh_execute_header,  v24,  0LL,  "The user UUID of the current user was not passed in for Persona Creation",  v327,  2);
        __int128 v28 = (char *)v27;
        if (v27) {
          sub_100053B7C(v27);
        }
      }

      else
      {
        __int128 v28 = 0LL;
      }

      free(v28);
    }

    unsigned int v17 = 0LL;
    uint64_t v33 = 0LL;
    unsigned int v34 = 0LL;
    unsigned int v35 = 22;
    goto LABEL_458;
  }

  unsigned int v17 = (void *)objc_claimAutoreleasedReturnValue([v14 objectForKeyedSubscript:@"UserPersonaUserODUUID"]);
  unsigned int v18 = (void *)objc_claimAutoreleasedReturnValue([v14 objectForKeyedSubscript:@"UserPersonaType"]);

  char v311 = a6;
  if (v18)
  {
    switch(sub_100084E90(v14, (uint64_t)@"UserPersonaType", (id)0xFFFFFFFFLL))
    {
      case 2u:
        if (qword_1000DBB68 != -1) {
          dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
        }
        id v19 = (id)qword_1000DBB60;
        if (os_log_type_enabled((os_log_t)v19, OS_LOG_TYPE_DEFAULT))
        {
          int v303 = a5;
          *(void *)unsigned int v324 = 0LL;
          unsigned int v20 = sub_100053B4C(1);
          id v21 = (os_log_s *)v19;
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v22 = v20;
          }
          else {
            uint64_t v22 = v20 & 0xFFFFFFFE;
          }
          if ((_DWORD)v22)
          {
            LOWORD(v327[0]) = 0;
            uint64_t v23 = (char *)_os_log_send_and_compose_impl( v22,  v324,  0LL,  0LL,  &_mh_execute_header,  v21,  0LL,  "Creating Enterprise Persona",  v327,  2);

            if (v23) {
              sub_100053B7C(v23);
            }
          }

          else
          {

            uint64_t v23 = 0LL;
          }

          id v13 = v316;
          free(v23);
          a5 = v303;
        }

        id v29 = v15;
        uint64_t v30 = a7;

        unsigned int v315 = sub_1000580F8((uint64_t)a1, 2000LL, 1000);
        unsigned int v32 = 2;
        LODWORD(v1_Block_object_dispose(va, 8) = 1;
        uint64_t v31 = @"Enterprise";
        goto LABEL_76;
      case 3u:
        if (qword_1000DBB68 != -1) {
          dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
        }
        id v36 = (id)qword_1000DBB60;
        if (os_log_type_enabled((os_log_t)v36, OS_LOG_TYPE_DEFAULT))
        {
          int v304 = a5;
          *(void *)unsigned int v324 = 0LL;
          unsigned int v37 = sub_100053B4C(1);
          __int128 v38 = (os_log_s *)v36;
          if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v39 = v37;
          }
          else {
            uint64_t v39 = v37 & 0xFFFFFFFE;
          }
          if ((_DWORD)v39)
          {
            LOWORD(v327[0]) = 0;
            uint64_t v40 = (char *)_os_log_send_and_compose_impl( v39,  v324,  0LL,  0LL,  &_mh_execute_header,  v38,  0LL,  "Creating System Persona",  v327,  2);

            if (v40) {
              sub_100053B7C(v40);
            }
          }

          else
          {

            uint64_t v40 = 0LL;
          }

          id v13 = v316;
          free(v40);
          a5 = v304;
        }

        id v29 = v15;
        uint64_t v30 = a7;

        unsigned int v315 = sub_1000580F8((uint64_t)a1, 99LL, 100);
        LODWORD(v1_Block_object_dispose(va, 8) = 0;
        unsigned int v32 = 3;
        uint64_t v31 = @"System";
        goto LABEL_76;
      case 4u:
        if (qword_1000DBB68 != -1) {
          dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
        }
        id v41 = (id)qword_1000DBB60;
        if (os_log_type_enabled((os_log_t)v41, OS_LOG_TYPE_DEFAULT))
        {
          int v305 = a5;
          *(void *)unsigned int v324 = 0LL;
          unsigned int v42 = sub_100053B4C(1);
          uint64_t v43 = (os_log_s *)v41;
          if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v44 = v42;
          }
          else {
            uint64_t v44 = v42 & 0xFFFFFFFE;
          }
          if ((_DWORD)v44)
          {
            LOWORD(v327[0]) = 0;
            __int128 v45 = (char *)_os_log_send_and_compose_impl( v44,  v324,  0LL,  0LL,  &_mh_execute_header,  v43,  0LL,  "Creating Universal Persona",  v327,  2);

            if (v45) {
              sub_100053B7C(v45);
            }
          }

          else
          {

            __int128 v45 = 0LL;
          }

          id v13 = v316;
          free(v45);
          a5 = v305;
        }

        id v29 = v15;
        uint64_t v30 = a7;

        LODWORD(v1_Block_object_dispose(va, 8) = 0;
        unsigned int v32 = 4;
        unsigned int v315 = 1000;
        uint64_t v31 = @"Universal";
        goto LABEL_76;
      case 5u:
        if (qword_1000DBB68 != -1) {
          dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
        }
        id v46 = (id)qword_1000DBB60;
        if (os_log_type_enabled((os_log_t)v46, OS_LOG_TYPE_DEFAULT))
        {
          int v306 = a5;
          *(void *)unsigned int v324 = 0LL;
          unsigned int v47 = sub_100053B4C(1);
          __int128 v48 = (os_log_s *)v46;
          if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v49 = v47;
          }
          else {
            uint64_t v49 = v47 & 0xFFFFFFFE;
          }
          if ((_DWORD)v49)
          {
            LOWORD(v327[0]) = 0;
            int v50 = (char *)_os_log_send_and_compose_impl( v49,  v324,  0LL,  0LL,  &_mh_execute_header,  v48,  0LL,  "Creating Default Persona",  v327,  2);

            if (v50) {
              sub_100053B7C(v50);
            }
          }

          else
          {

            int v50 = 0LL;
          }

          id v13 = v316;
          free(v50);
          a5 = v306;
        }

        id v29 = v15;
        uint64_t v30 = a7;

        unsigned int v315 = sub_1000580F8((uint64_t)a1, 199LL, 100);
        LODWORD(v1_Block_object_dispose(va, 8) = 0;
        unsigned int v32 = 5;
        uint64_t v31 = @"Default";
        goto LABEL_76;
      case 6u:
        id v312 = v15;
        if (qword_1000DBB68 != -1) {
          dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
        }
        id v51 = (id)qword_1000DBB60;
        if (os_log_type_enabled((os_log_t)v51, OS_LOG_TYPE_DEFAULT))
        {
          int v52 = a5;
          *(void *)unsigned int v324 = 0LL;
          unsigned int v53 = sub_100053B4C(1);
          unsigned int v54 = (os_log_s *)v51;
          if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v55 = v53;
          }
          else {
            uint64_t v55 = v53 & 0xFFFFFFFE;
          }
          if ((_DWORD)v55)
          {
            LOWORD(v327[0]) = 0;
            uint64_t v56 = (char *)_os_log_send_and_compose_impl( v55,  v324,  0LL,  0LL,  &_mh_execute_header,  v54,  0LL,  "Creating Guest Persona",  v327,  2);

            if (v56) {
              sub_100053B7C(v56);
            }
          }

          else
          {

            uint64_t v56 = 0LL;
          }

          free(v56);
          a5 = v52;
        }

        uint64_t v30 = a7;

        unsigned int v315 = sub_1000580F8((uint64_t)a1, 3000LL, 1000);
        unsigned int v313 = 6;
        uint64_t v31 = @"Guest";
        goto LABEL_106;
      default:
        id v29 = v15;
        uint64_t v30 = a7;
        unsigned int v315 = sub_1000580F8((uint64_t)a1, 1000LL, 1000);
        LODWORD(v1_Block_object_dispose(va, 8) = 0;
        unsigned int v32 = 0;
        uint64_t v31 = @"Personal";
        goto LABEL_76;
    }
  }

  id v29 = v15;
  uint64_t v30 = a7;
  uint64_t v31 = 0LL;
  unsigned int v32 = 0;
  unsigned int v315 = 1000;
LABEL_76:
  id v57 = sub_100058BD8(a1, v32, v13);
  uint64_t v58 = objc_claimAutoreleasedReturnValue(v57);
  if (v58)
  {
    unsigned int v24 = (os_log_s *)v58;
    stat v314 = v17;
    a7 = v30;
    if ((_DWORD)v18)
    {
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      id v15 = v29;
      unsigned int v59 = (os_log_s *)(id)qword_1000DBB60;
      if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)unsigned int v324 = 0LL;
        unsigned int v60 = sub_100053B4C(1);
        if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v61 = v60;
        }
        else {
          uint64_t v61 = v60 & 0xFFFFFFFE;
        }
        if ((_DWORD)v61)
        {
          LODWORD(v327[0]) = 67109120;
          HIDWORD(v327[0]) = v315;
          uint64_t v62 = (const char *)_os_log_send_and_compose_impl( v61,  v324,  0LL,  0LL,  &_mh_execute_header,  v59,  0LL,  "ENTERPRISE PERSONA:%d already exists, returning EEXIST",  v327);
          unsigned int v63 = (char *)v62;
          if (v62) {
            sub_100053B7C(v62);
          }
        }

        else
        {
          unsigned int v63 = 0LL;
        }

        free(v63);
      }

      unsigned int v34 = 0LL;
      uint64_t v33 = 0LL;
      unsigned int v35 = 17;
    }

    else
    {
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      id v15 = v29;
      unsigned int v59 = (os_log_s *)(id)qword_1000DBB60;
      if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)unsigned int v324 = 0LL;
        unsigned int v64 = sub_100053B4C(1);
        if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v65 = v64;
        }
        else {
          uint64_t v65 = v64 & 0xFFFFFFFE;
        }
        if ((_DWORD)v65)
        {
          LODWORD(v327[0]) = 67109120;
          HIDWORD(v327[0]) = v315;
          int v66 = (const char *)_os_log_send_and_compose_impl( v65,  v324,  0LL,  0LL,  &_mh_execute_header,  v59,  0LL,  "PERSONA:%d already exists, returning EBUSY",  v327);
          unsigned int v67 = (char *)v66;
          if (v66) {
            sub_100053B7C(v66);
          }
        }

        else
        {
          unsigned int v67 = 0LL;
        }

        free(v67);
      }

      unsigned int v34 = 0LL;
      uint64_t v33 = 0LL;
      unsigned int v35 = 16;
    }

    goto LABEL_456;
  }

  unsigned int v313 = v32;
  id v312 = v29;
LABEL_106:
  unsigned int v24 = (os_log_s *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
  uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v313));
  -[os_log_s setObject:forKeyedSubscript:](v24, "setObject:forKeyedSubscript:", v68, @"UserPersonaType");

  -[os_log_s setObject:forKeyedSubscript:](v24, "setObject:forKeyedSubscript:", v31, @"UserPersonaNickName");
  -[os_log_s setObject:forKeyedSubscript:](v24, "setObject:forKeyedSubscript:", v17, @"UserPersonaUserODUUID");
  if (((1 << v313) & 0x45) != 0)
  {
    if (qword_1000DBB68 != -1) {
      dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
    }
    id v74 = (id)qword_1000DBB60;
    if (os_log_type_enabled((os_log_t)v74, OS_LOG_TYPE_DEFAULT))
    {
      int v307 = a5;
      unsigned int v75 = a1;
      id v76 = v14;
      uint64_t v77 = v17;
      *(void *)unsigned int v324 = 0LL;
      unsigned int v78 = sub_100053B4C(1);
      id v79 = (os_log_s *)v74;
      if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v80 = v78;
      }
      else {
        uint64_t v80 = v78 & 0xFFFFFFFE;
      }
      if ((_DWORD)v80)
      {
        LODWORD(v327[0]) = 67109120;
        HIDWORD(v327[0]) = v315;
        id v81 = (char *)_os_log_send_and_compose_impl( v80,  v324,  0LL,  0LL,  &_mh_execute_header,  v79,  0LL,  "Creating new persona with ID:%d",  v327);

        if (v81) {
          sub_100053B7C(v81);
        }
      }

      else
      {

        id v81 = 0LL;
      }

      unsigned int v17 = v77;
      free(v81);
      id v14 = v76;
      a1 = v75;
      a5 = v307;
    }

    id v300 = v30;

    unsigned int v90 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v315));
    -[os_log_s setObject:forKeyedSubscript:](v24, "setObject:forKeyedSubscript:", v90, @"UserPersonaID");

    unsigned int v296 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"));
    uint64_t v295 = (void *)objc_claimAutoreleasedReturnValue([v296 UUIDString]);
    -[os_log_s setObject:forKeyedSubscript:](v24, "setObject:forKeyedSubscript:");
    stat v314 = v17;
    if ((v313 | 4) == 6)
    {
      id v91 = (os_log_s *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"));
      int v83 = v91;
      uint64_t v82 = v316;
      if (v91)
      {
        uint64_t v92 = objc_claimAutoreleasedReturnValue(-[os_log_s UUIDString](v91, "UUIDString"));
        id v15 = v312;
        if (v92)
        {
          -[os_log_s setObject:forKeyedSubscript:]( v24,  "setObject:forKeyedSubscript:",  v92,  @"MKBUserSessionUUID");
          if (qword_1000DBB68 != -1) {
            dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
          }
          id v93 = (id)qword_1000DBB60;
          if (os_log_type_enabled((os_log_t)v93, OS_LOG_TYPE_DEFAULT))
          {
            int v308 = a5;
            uint64_t v94 = v92;
            v327[0] = 0LL;
            unsigned int v95 = sub_100053B4C(1);
            uint64_t v96 = (os_log_s *)v93;
            if (os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v97 = v95;
            }
            else {
              uint64_t v97 = v95 & 0xFFFFFFFE;
            }
            if ((_DWORD)v97)
            {
              *(_DWORD *)unsigned int v324 = 138412290;
              uint64_t v92 = v94;
              *(void *)&v324[4] = v94;
              LODWORD(v289) = 12;
              uint64_t v98 = (char *)_os_log_send_and_compose_impl( v97,  v327,  0LL,  0LL,  &_mh_execute_header,  v96,  0LL,  "HomeUUID is %@",  v324,  v289);

              if (v98) {
                sub_100053B7C(v98);
              }
            }

            else
            {

              uint64_t v98 = 0LL;
              uint64_t v92 = v94;
            }

            id v15 = v312;
            free(v98);
            a5 = v308;
            uint64_t v82 = v316;
          }
        }

        unsigned int v124 = (void *)v92;
        uint64_t v125 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@/%@",  @"/private/var/PersonaVolumes",  v92));
        -[os_log_s setObject:forKeyedSubscript:]( v24,  "setObject:forKeyedSubscript:",  v125,  @"MKBUserSessionHomeDir");

        unsigned int v34 = v124;
LABEL_220:
        id v322 = 0LL;
        int v126 = sub_10005E240((uint64_t)a1, v24, &v322);
        uint64_t v127 = (os_log_s *)v322;
        unsigned int v59 = v127;
        id v302 = v83;
        uint64_t v298 = v34;
        if ((v126 & 1) != 0)
        {
          unsigned int v315 = sub_100084F14(v24, (uint64_t)@"UserPersonaID", 0LL);
          if ((v313 | 4) != 6)
          {
            if (qword_1000DBB68 != -1) {
              dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
            }
            uint64_t v143 = (os_log_s *)(id)qword_1000DBB60;
            uint64_t v294 = v143;
            if (os_log_type_enabled(v143, OS_LOG_TYPE_DEFAULT))
            {
              *(void *)unsigned int v324 = 0LL;
              unsigned int v144 = sub_100053B4C(1);
              if (os_log_type_enabled(v143, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v145 = v144;
              }
              else {
                uint64_t v145 = v144 & 0xFFFFFFFE;
              }
              if ((_DWORD)v145)
              {
                LOWORD(v327[0]) = 0;
                LODWORD(v289) = 2;
                unsigned int v146 = (const char *)_os_log_send_and_compose_impl( v145,  v324,  0LL,  0LL,  &_mh_execute_header,  v143,  0LL,  "Not an Enterprise Persona so skipping creating APFS volume",  v327,  v289);
                uint64_t v147 = (char *)v146;
                if (v146) {
                  sub_100053B7C(v146);
                }
              }

              else
              {
                uint64_t v147 = 0LL;
              }

              free(v147);
              unsigned int v34 = v298;
            }

            goto LABEL_327;
          }

          int v293 = v126;
          id v128 = (void *)objc_claimAutoreleasedReturnValue([v14 objectForKeyedSubscript:@"UserPersonaDisplayName"]);
          -[os_log_s setObject:forKeyedSubscript:]( v24,  "setObject:forKeyedSubscript:",  v128,  @"UserPersonaDisplayName");

          uint64_t v129 = objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
          -[os_log_s setObject:forKeyedSubscript:]( v24,  "setObject:forKeyedSubscript:",  v129,  @"MKBUserSessionCreateTimeStamp");
          uint64_t v294 = (void *)v129;
          -[os_log_s setObject:forKeyedSubscript:]( v24,  "setObject:forKeyedSubscript:",  v129,  @"MKBUserSessionLoginTimeStamp");
          if (qword_1000DBB68 != -1) {
            dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
          }
          id v130 = (id)qword_1000DBB60;
          if (os_log_type_enabled((os_log_t)v130, OS_LOG_TYPE_DEFAULT))
          {
            int v131 = a5;
            *(void *)unsigned int v324 = 0LL;
            unsigned int v132 = sub_100053B4C(1);
            id v133 = (os_log_s *)v130;
            if (os_log_type_enabled(v133, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v134 = v132;
            }
            else {
              uint64_t v134 = v132 & 0xFFFFFFFE;
            }
            if ((_DWORD)v134)
            {
              LOWORD(v327[0]) = 0;
              LODWORD(v289) = 2;
              id v135 = (char *)_os_log_send_and_compose_impl( v134,  v324,  0LL,  0LL,  &_mh_execute_header,  v133,  0LL,  "Create Undermount directory if not existing",  v327,  v289);

              if (v135) {
                sub_100053B7C(v135);
              }
            }

            else
            {

              id v135 = 0LL;
            }

            a5 = v131;
            free(v135);
            int v83 = v302;
            uint64_t v82 = v316;
          }

          id v149 = a1[3];
          [v149 createVolumeMountsDir:@"/private/var/PersonaVolumes"];

          if (qword_1000DBB68 != -1) {
            dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
          }
          id v150 = (id)qword_1000DBB60;
          if (os_log_type_enabled((os_log_t)v150, OS_LOG_TYPE_DEFAULT))
          {
            int v151 = a5;
            *(void *)unsigned int v324 = 0LL;
            unsigned int v152 = sub_100053B4C(1);
            unsigned int v153 = (os_log_s *)v150;
            if (os_log_type_enabled(v153, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v154 = v152;
            }
            else {
              uint64_t v154 = v152 & 0xFFFFFFFE;
            }
            if ((_DWORD)v154)
            {
              LOWORD(v327[0]) = 0;
              LODWORD(v289) = 2;
              uint64_t v155 = (char *)_os_log_send_and_compose_impl( v154,  v324,  0LL,  0LL,  &_mh_execute_header,  v153,  0LL,  "Enterprise Persona creating APFS volume",  v327,  v289);

              if (v155) {
                sub_100053B7C(v155);
              }
            }

            else
            {

              uint64_t v155 = 0LL;
            }

            a5 = v151;
            free(v155);
            int v83 = v302;
            uint64_t v82 = v316;
          }

          unsigned int v321 = 0;
          id v156 = a1[3];
          unsigned int v157 = [v156 createVolumeWithSession:v24 size:0 userName:v298 error:&v321 forPersona:1 userDataVolume:0];

          uint64_t v297 = (uint64_t)a1;
          if (v157)
          {
            if (qword_1000DBB68 != -1) {
              dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
            }
            id v158 = (id)qword_1000DBB60;
            if (os_log_type_enabled((os_log_t)v158, OS_LOG_TYPE_DEFAULT))
            {
              int v159 = a5;
              *(void *)unsigned int v324 = 0LL;
              unsigned int v160 = sub_100053B4C(1);
              id v161 = (os_log_s *)v158;
              if (os_log_type_enabled(v161, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v162 = v160;
              }
              else {
                uint64_t v162 = v160 & 0xFFFFFFFE;
              }
              if ((_DWORD)v162)
              {
                LOWORD(v327[0]) = 0;
                LODWORD(v289) = 2;
                uint64_t v163 = (char *)_os_log_send_and_compose_impl( v162,  v324,  0LL,  0LL,  &_mh_execute_header,  v161,  0LL,  "Created new APFS volume",  v327,  v289);

                if (v163) {
                  sub_100053B7C(v163);
                }
              }

              else
              {

                uint64_t v163 = 0LL;
              }

              a5 = v159;
              free(v163);
              int v83 = v302;
              uint64_t v82 = v316;
            }

            id v169 = a1[3];
            unsigned __int8 v170 = [v169 mountVolumeWithSession:v24 mountPath:0 error:0 forPersona:1];

            if ((v170 & 1) == 0)
            {
              if (qword_1000DBB68 != -1) {
                dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
              }
              id v177 = (id)qword_1000DBB60;
              if (os_log_type_enabled((os_log_t)v177, OS_LOG_TYPE_DEFAULT))
              {
                *(void *)unsigned int v324 = 0LL;
                unsigned int v178 = sub_100053B4C(1);
                int v179 = (os_log_s *)v177;
                if (os_log_type_enabled(v179, OS_LOG_TYPE_DEFAULT)) {
                  uint64_t v180 = v178;
                }
                else {
                  uint64_t v180 = v178 & 0xFFFFFFFE;
                }
                if ((_DWORD)v180)
                {
                  LOWORD(v327[0]) = 0;
                  LODWORD(v289) = 2;
                  CFTypeID v181 = (char *)_os_log_send_and_compose_impl( v180,  v324,  0LL,  0LL,  &_mh_execute_header,  v179,  0LL,  "APFSUser Volume failed to mount",  v327,  v289);

                  if (v181) {
                    sub_100053B7C(v181);
                  }
                }

                else
                {

                  CFTypeID v181 = 0LL;
                }

                free(v181);
              }

              id v138 = v15;

              int v142 = 0;
              unsigned int v35 = 22;
              goto LABEL_406;
            }

            if (qword_1000DBB68 != -1) {
              dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
            }
            id v171 = (id)qword_1000DBB60;
            if (os_log_type_enabled((os_log_t)v171, OS_LOG_TYPE_DEFAULT))
            {
              int v172 = a5;
              *(void *)unsigned int v324 = 0LL;
              unsigned int v173 = sub_100053B4C(1);
              unsigned int v174 = (os_log_s *)v171;
              if (os_log_type_enabled(v174, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v175 = v173;
              }
              else {
                uint64_t v175 = v173 & 0xFFFFFFFE;
              }
              if ((_DWORD)v175)
              {
                LOWORD(v327[0]) = 0;
                LODWORD(v289) = 2;
                __int128 v176 = (char *)_os_log_send_and_compose_impl( v175,  v324,  0LL,  0LL,  &_mh_execute_header,  v174,  0LL,  "APFSUser Volume mounted at home directory",  v327,  v289);

                if (v176) {
                  sub_100053B7C(v176);
                }
              }

              else
              {

                __int128 v176 = 0LL;
              }

              a5 = v172;
              free(v176);
              int v83 = v302;
              uint64_t v82 = v316;
            }

            -[os_log_s setObject:forKeyedSubscript:]( v24,  "setObject:forKeyedSubscript:",  0LL,  @"UserPersonaUserKey");
            id v182 = a1[3];
            unsigned __int8 v183 = [v182 splitUserVolumeEnabled];

            if ((v183 & 1) != 0)
            {
              uint64_t v184 = sub_10005EBB0(a1);
              uint64_t v185 = (void *)objc_claimAutoreleasedReturnValue(v184);
              unsigned int v292 = sub_100055178((uint64_t)v185);

              if (qword_1000DBB68 != -1) {
                dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
              }
              id v186 = (id)qword_1000DBB60;
              if (os_log_type_enabled((os_log_t)v186, OS_LOG_TYPE_DEFAULT))
              {
                v327[0] = 0LL;
                unsigned int v187 = sub_100053B4C(1);
                unsigned int v188 = (os_log_s *)v186;
                if (os_log_type_enabled(v188, OS_LOG_TYPE_DEFAULT)) {
                  uint64_t v189 = v187;
                }
                else {
                  uint64_t v189 = v187 & 0xFFFFFFFE;
                }
                if ((_DWORD)v189)
                {
                  *(_DWORD *)unsigned int v324 = 138412546;
                  *(void *)&v324[4] = v296;
                  *(_WORD *)&v324[12] = 1024;
                  *(_DWORD *)&v324[14] = v292;
                  LODWORD(v289) = 18;
                  uint64_t v190 = (char *)_os_log_send_and_compose_impl( v189,  v327,  0LL,  0LL,  &_mh_execute_header,  v188,  0LL,  "Adding Persona Key for persona:%@ for user:%d",  v324,  v289);

                  if (v190) {
                    sub_100053B7C(v190);
                  }
                }

                else
                {

                  uint64_t v190 = 0LL;
                }

                free(v190);
              }

              int v310 = a5;

              id v207 = a1[2];
              uint64_t v208 = sub_100019B18((uint64_t)v207);
              uid_t v209 = (void *)objc_claimAutoreleasedReturnValue(v208);
              unsigned int v320 = v59;
              unsigned int v210 = [v209 addPersonaWithUUID:v296 toSession:v292 passcode:v15 error:&v320];
              uint64_t v196 = v320;

              if (!v210)
              {
                if (qword_1000DBB68 != -1) {
                  dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
                }
                id v216 = (id)qword_1000DBB60;
                if (os_log_type_enabled((os_log_t)v216, OS_LOG_TYPE_DEFAULT))
                {
                  v327[0] = 0LL;
                  unsigned int v217 = sub_100053B4C(1);
                  __int128 v218 = (os_log_s *)v216;
                  if (os_log_type_enabled(v218, OS_LOG_TYPE_DEFAULT)) {
                    uint64_t v219 = v217;
                  }
                  else {
                    uint64_t v219 = v217 & 0xFFFFFFFE;
                  }
                  if ((_DWORD)v219)
                  {
                    *(_DWORD *)unsigned int v324 = 138412546;
                    *(void *)&v324[4] = v296;
                    *(_WORD *)&v324[12] = 2112;
                    *(void *)&v324[14] = v196;
                    LODWORD(v289) = 22;
                    __int128 v220 = (char *)_os_log_send_and_compose_impl( v219,  v327,  0LL,  0LL,  &_mh_execute_header,  v218,  0LL,  "Failed to create persona key for persona:%@ with error:%@",  v324,  v289);

                    if (v220) {
                      sub_100053B7C(v220);
                    }
                  }

                  else
                  {

                    __int128 v220 = 0LL;
                  }

                  free(v220);
                }

                int v195 = 5;
                goto LABEL_394;
              }

              if (qword_1000DBB68 != -1) {
                dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
              }
              id v211 = (id)qword_1000DBB60;
              if (os_log_type_enabled((os_log_t)v211, OS_LOG_TYPE_DEFAULT))
              {
                *(void *)unsigned int v324 = 0LL;
                unsigned int v212 = sub_100053B4C(1);
                id v213 = (os_log_s *)v211;
                if (os_log_type_enabled(v213, OS_LOG_TYPE_DEFAULT)) {
                  uint64_t v214 = v212;
                }
                else {
                  uint64_t v214 = v212 & 0xFFFFFFFE;
                }
                if ((_DWORD)v214)
                {
                  LOWORD(v327[0]) = 0;
                  LODWORD(v289) = 2;
                  id v215 = (char *)_os_log_send_and_compose_impl( v214,  v324,  0LL,  0LL,  &_mh_execute_header,  v213,  0LL,  "Persona Key Added to Identity, mapping the path",  v327,  v289);

                  if (v215) {
                    sub_100053B7C(v215);
                  }
                }

                else
                {

                  id v215 = 0LL;
                }

                free(v215);
              }

              id v221 = sub_1000850A0(v24, (uint64_t)@"MKBUserSessionVolumeDeviceNode");
              uint64_t v222 = objc_claimAutoreleasedReturnValue(v221);
              if (qword_1000DBB68 != -1) {
                dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
              }
              id v223 = (id)qword_1000DBB60;
              if (os_log_type_enabled((os_log_t)v223, OS_LOG_TYPE_DEFAULT))
              {
                v327[0] = 0LL;
                unsigned int v224 = sub_100053B4C(1);
                __int128 v225 = (os_log_s *)v223;
                if (os_log_type_enabled(v225, OS_LOG_TYPE_DEFAULT)) {
                  uint64_t v226 = v224;
                }
                else {
                  uint64_t v226 = v224 & 0xFFFFFFFE;
                }
                if ((_DWORD)v226)
                {
                  *(_DWORD *)unsigned int v324 = 138412802;
                  *(void *)&v324[4] = v222;
                  *(_WORD *)&v324[12] = 1024;
                  *(_DWORD *)&v324[14] = v292;
                  *(_WORD *)&v324[18] = 2112;
                  *(void *)&v324[20] = v296;
                  LODWORD(v289) = 28;
                  __int128 v227 = (char *)_os_log_send_and_compose_impl( v226,  v327,  0LL,  0LL,  &_mh_execute_header,  v225,  0LL,  "Setting up Volume Map for diskNode:%@, uid:%d, persona UUID %@",  v324,  v289);

                  if (v227) {
                    sub_100053B7C(v227);
                  }
                }

                else
                {

                  __int128 v227 = 0LL;
                }

                free(v227);
              }

              id v264 = a1[2];
              uint64_t v265 = sub_100019B18((uint64_t)v264);
              v266 = (void *)objc_claimAutoreleasedReturnValue(v265);
              uint64_t v319 = v196;
              id v291 = (id)v222;
              unsigned int v267 = [v266 mapVolume:v222 toSession:v292 withPersona:v296 error:&v319];
              unsigned int v59 = v319;

              if (v267)
              {
                if (qword_1000DBB68 != -1) {
                  dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
                }
                a5 = v310;
                uint64_t v192 = (os_log_s *)(id)qword_1000DBB60;
                int v83 = v302;
                uint64_t v82 = v316;
                if (!os_log_type_enabled(v192, OS_LOG_TYPE_DEFAULT))
                {
                  unsigned int v34 = v298;
                  unsigned int v309 = 0;
                  goto LABEL_325;
                }

                *(void *)unsigned int v324 = 0LL;
                unsigned int v268 = sub_100053B4C(1);
                v269 = v192;
                if (os_log_type_enabled(v269, OS_LOG_TYPE_DEFAULT)) {
                  uint64_t v270 = v268;
                }
                else {
                  uint64_t v270 = v268 & 0xFFFFFFFE;
                }
                int v290 = v269;
                if ((_DWORD)v270)
                {
                  LOWORD(v327[0]) = 0;
                  LODWORD(v289) = 2;
                  v271 = (char *)_os_log_send_and_compose_impl( v270,  v324,  0LL,  0LL,  &_mh_execute_header,  v269,  0LL,  "Successfully mapped the persona volume to persona key",  v327,  v289);

                  if (v271) {
                    sub_100053B7C(v271);
                  }
                }

                else
                {

                  v271 = 0LL;
                }

                free(v271);
                unsigned int v309 = 0;
LABEL_522:
                unsigned int v34 = v298;
                uint64_t v192 = v290;
LABEL_325:

                int v195 = v309;
                if (v309)
                {
                  uint64_t v196 = v59;
LABEL_394:
                  if (qword_1000DBB68 != -1) {
                    dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
                  }
                  id v228 = (id)qword_1000DBB60;
                  if (os_log_type_enabled((os_log_t)v228, OS_LOG_TYPE_DEFAULT))
                  {
                    *(void *)unsigned int v324 = 0LL;
                    unsigned int v229 = sub_100053B4C(1);
                    __int128 v230 = (os_log_s *)v228;
                    if (os_log_type_enabled(v230, OS_LOG_TYPE_DEFAULT)) {
                      uint64_t v231 = v229;
                    }
                    else {
                      uint64_t v231 = v229 & 0xFFFFFFFE;
                    }
                    if ((_DWORD)v231)
                    {
                      LODWORD(v327[0]) = 67109120;
                      HIDWORD(v327[0]) = v195;
                      __int128 v232 = (char *)_os_log_send_and_compose_impl( v231,  v324,  0LL,  0LL,  &_mh_execute_header,  v230,  0LL,  "Failed to create persona key with error:0x%x",  v327);

                      if (v232) {
                        sub_100053B7C(v232);
                      }
                    }

                    else
                    {

                      __int128 v232 = 0LL;
                    }

                    free(v232);
                  }

                  id v138 = v15;

                  unsigned int v35 = 22;
                  int v142 = 1;
                  unsigned int v59 = v196;
LABEL_406:
                  int v148 = 1;
                  goto LABEL_407;
                }

LABEL_327:
                uint64_t v33 = v59;
                unsigned int v17 = v314;
                goto LABEL_328;
              }

              if (qword_1000DBB68 != -1) {
                dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
              }
              id v272 = (id)qword_1000DBB60;
              if (os_log_type_enabled((os_log_t)v272, OS_LOG_TYPE_DEFAULT))
              {
                v327[0] = 0LL;
                unsigned int v273 = sub_100053B4C(1);
                unsigned int v274 = (os_log_s *)v272;
                if (os_log_type_enabled(v274, OS_LOG_TYPE_DEFAULT)) {
                  uint64_t v275 = v273;
                }
                else {
                  uint64_t v275 = v273 & 0xFFFFFFFE;
                }
                if ((_DWORD)v275)
                {
                  *(_DWORD *)unsigned int v324 = 138413058;
                  *(void *)&v324[4] = v291;
                  *(_WORD *)&v324[12] = 1024;
                  *(_DWORD *)&v324[14] = v292;
                  *(_WORD *)&v324[18] = 2112;
                  *(void *)&v324[20] = v296;
                  __int16 v325 = 2112;
                  uint64_t v326 = v59;
                  LODWORD(v289) = 38;
                  unsigned int v276 = (char *)_os_log_send_and_compose_impl( v275,  v327,  0LL,  0LL,  &_mh_execute_header,  v274,  0LL,  "Volume Map Failed for diskNode:%@, uid:%d, persona UUID %@ to persona key with error:%@",  v324,  v289);

                  if (v276) {
                    sub_100053B7C(v276);
                  }
                }

                else
                {

                  unsigned int v276 = 0LL;
                }

                free(v276);
              }

              id v277 = a1[2];
              uint64_t v278 = sub_100019B18((uint64_t)v277);
              unsigned int v279 = (void *)objc_claimAutoreleasedReturnValue(v278);
              unsigned int v318 = v59;
              unsigned int v280 = [v279 deletePersonaWithUUID:v296 fromSession:v292 error:&v318];
              unsigned int v281 = v318;

              if (v280)
              {
                if (qword_1000DBB68 != -1) {
                  dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
                }
                a5 = v310;
                unsigned int v59 = v281;
                uint64_t v192 = (os_log_s *)(id)qword_1000DBB60;
                int v83 = v302;
                uint64_t v82 = v316;
                if (os_log_type_enabled(v192, OS_LOG_TYPE_DEFAULT))
                {
                  *(void *)unsigned int v324 = 0LL;
                  unsigned int v282 = sub_100053B4C(1);
                  uint64_t v283 = v192;
                  if (os_log_type_enabled(v283, OS_LOG_TYPE_DEFAULT)) {
                    uint64_t v284 = v282;
                  }
                  else {
                    uint64_t v284 = v282 & 0xFFFFFFFE;
                  }
                  int v290 = v283;
                  if ((_DWORD)v284)
                  {
                    LOWORD(v327[0]) = 0;
                    LODWORD(v289) = 2;
                    uint64_t v285 = _os_log_send_and_compose_impl( v284,  v324,  0LL,  0LL,  &_mh_execute_header,  v283,  0LL,  "Successfully Deleted the persona key on volume map failure",  v327,  v289);
                    goto LABEL_517;
                  }

                  goto LABEL_520;
                }
              }

              else
              {
                if (qword_1000DBB68 != -1) {
                  dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
                }
                a5 = v310;
                unsigned int v59 = v281;
                uint64_t v192 = (os_log_s *)(id)qword_1000DBB60;
                int v83 = v302;
                uint64_t v82 = v316;
                if (os_log_type_enabled(v192, OS_LOG_TYPE_DEFAULT))
                {
                  v327[0] = 0LL;
                  unsigned int v286 = sub_100053B4C(1);
                  uint64_t v283 = v192;
                  if (os_log_type_enabled(v283, OS_LOG_TYPE_DEFAULT)) {
                    uint64_t v287 = v286;
                  }
                  else {
                    uint64_t v287 = v286 & 0xFFFFFFFE;
                  }
                  int v290 = v283;
                  if ((_DWORD)v287)
                  {
                    *(_DWORD *)unsigned int v324 = 67109378;
                    *(_DWORD *)&v324[4] = v292;
                    *(_WORD *)&v324[8] = 2112;
                    *(void *)&v324[10] = v59;
                    LODWORD(v289) = 18;
                    uint64_t v285 = _os_log_send_and_compose_impl( v287,  v327,  0LL,  0LL,  &_mh_execute_header,  v283,  0LL,  "Failed to delete persona Key for user:%d with error:%@ after vol map failed, moving on..",  v324,  v289);
LABEL_517:
                    uint64_t v288 = (char *)v285;

                    if (v288) {
                      sub_100053B7C(v288);
                    }
                    goto LABEL_521;
                  }

LABEL_520:
                  uint64_t v288 = 0LL;
LABEL_521:
                  free(v288);
                  unsigned int v309 = 5;
                  goto LABEL_522;
                }
              }

              unsigned int v309 = 5;
            }

            else
            {
              id v291 = a1[2];
              uint64_t v191 = sub_1000197A0((uint64_t)v291);
              uint64_t v192 = (os_log_s *)objc_claimAutoreleasedReturnValue(v191);
              id v193 = sub_1000850A0(v24, (uint64_t)@"MKBUserSessionHomeDir");
              int v194 = (void *)objc_claimAutoreleasedReturnValue(v193);
              unsigned int v309 = -[os_log_s createPersonaKeyForUser:personaUUID:passcode:homeDir:]( v192,  "createPersonaKeyForUser:personaUUID:passcode:homeDir:",  0LL,  v295,  v15,  v194);
            }

            unsigned int v34 = v298;
            goto LABEL_325;
          }

          if (qword_1000DBB68 != -1) {
            dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
          }
          id v164 = (id)qword_1000DBB60;
          if (os_log_type_enabled((os_log_t)v164, OS_LOG_TYPE_DEFAULT))
          {
            *(void *)unsigned int v324 = 0LL;
            unsigned int v165 = sub_100053B4C(1);
            uint64_t v166 = (os_log_s *)v164;
            if (os_log_type_enabled(v166, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v167 = v165;
            }
            else {
              uint64_t v167 = v165 & 0xFFFFFFFE;
            }
            if ((_DWORD)v167)
            {
              v327[0] = 0x1604000100LL;
              uint64_t v168 = (char *)_os_log_send_and_compose_impl( v167,  v324,  0LL,  0LL,  &_mh_execute_header,  v166,  0LL,  "FAILED TO CREATE APFS VOLUME due to error:%d, bailing",  v327);

              if (v168) {
                sub_100053B7C(v168);
              }
            }

            else
            {

              uint64_t v168 = 0LL;
            }

            free(v168);
          }

          id v138 = v15;

          int v142 = 0;
          int v148 = 0;
          unsigned int v35 = v321;
        }

        else
        {
          uint64_t v297 = (uint64_t)a1;
          unsigned int v35 = -[os_log_s code](v127, "code");
          if (qword_1000DBB68 != -1) {
            dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
          }
          id v136 = (os_log_s *)(id)qword_1000DBB60;
          int v293 = v126;
          uint64_t v294 = v136;
          if (os_log_type_enabled(v136, OS_LOG_TYPE_DEFAULT))
          {
            v327[0] = 0LL;
            unsigned int v137 = sub_100053B4C(1);
            id v138 = v15;
            if (os_log_type_enabled(v136, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v139 = v137;
            }
            else {
              uint64_t v139 = v137 & 0xFFFFFFFE;
            }
            if ((_DWORD)v139)
            {
              *(_DWORD *)unsigned int v324 = 67109376;
              *(_DWORD *)&v324[4] = v315;
              *(_WORD *)&v324[8] = 1024;
              *(_DWORD *)&v324[10] = v35;
              uint64_t v140 = (const char *)_os_log_send_and_compose_impl( v139,  v327,  0LL,  0LL,  &_mh_execute_header,  v136,  0LL,  "Kernel persona allocation for:%d failed with Error:%d",  v324,  14);
              uint64_t v141 = (char *)v140;
              if (v140) {
                sub_100053B7C(v140);
              }
            }

            else
            {
              uint64_t v141 = 0LL;
            }

            free(v141);
            int v142 = 0;
          }

          else
          {
            int v142 = 0;
            id v138 = v15;
          }

          int v148 = 0;
        }

LABEL_407:
        if (!v142) {
          goto LABEL_430;
        }
        id v233 = *(id *)(v297 + 24);
        unsigned int v234 = [v233 unmountVolumeWithSession:v24 mountPath:0 error:0];

        if (v234)
        {
          if (qword_1000DBB68 != -1) {
            dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
          }
          CFNumberRef v235 = (os_log_s *)(id)qword_1000DBB60;
          if (!os_log_type_enabled(v235, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_429;
          }
          *(void *)unsigned int v324 = 0LL;
          unsigned int v236 = sub_100053B4C(1);
          unsigned int v237 = v235;
          if (os_log_type_enabled(v237, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v238 = v236;
          }
          else {
            uint64_t v238 = v236 & 0xFFFFFFFE;
          }
          if ((_DWORD)v238)
          {
            LOWORD(v327[0]) = 0;
            LODWORD(v289) = 2;
            uint64_t v239 = _os_log_send_and_compose_impl( v238,  v324,  0LL,  0LL,  &_mh_execute_header,  v237,  0LL,  "Persona Volume unmounted after failure",  v327,  v289);
            goto LABEL_425;
          }
        }

        else
        {
          if (qword_1000DBB68 != -1) {
            dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
          }
          CFNumberRef v235 = (os_log_s *)(id)qword_1000DBB60;
          if (!os_log_type_enabled(v235, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_429;
          }
          *(void *)unsigned int v324 = 0LL;
          unsigned int v240 = sub_100053B4C(1);
          unsigned int v237 = v235;
          if (os_log_type_enabled(v237, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v241 = v240;
          }
          else {
            uint64_t v241 = v240 & 0xFFFFFFFE;
          }
          if ((_DWORD)v241)
          {
            LOWORD(v327[0]) = 0;
            LODWORD(v289) = 2;
            uint64_t v239 = _os_log_send_and_compose_impl( v241,  v324,  0LL,  0LL,  &_mh_execute_header,  v237,  0LL,  "Persona Volume failed to unmount after failure",  v327,  v289);
LABEL_425:
            id v242 = (char *)v239;

            if (v242) {
              sub_100053B7C(v242);
            }
            goto LABEL_428;
          }
        }

        id v242 = 0LL;
LABEL_428:
        free(v242);
LABEL_429:

LABEL_430:
        if (!v148)
        {
          id v15 = v138;
          unsigned int v34 = v298;
          a7 = v300;
          if (v293)
          {
LABEL_455:
            id v317 = v59;
            sub_10005EDF4(v297, v24, &v317);
            uint64_t v33 = v317;
LABEL_456:

            goto LABEL_457;
          }

LABEL_441:
          uint64_t v33 = v59;
LABEL_457:
          unsigned int v17 = v314;
LABEL_458:

          unsigned int v24 = 0LL;
          if (a7 && v35)
          {
            uint64_t v253 = a7;
            if (qword_1000DBB68 != -1) {
              dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
            }
            id v254 = (id)qword_1000DBB60;
            if (os_log_type_enabled((os_log_t)v254, OS_LOG_TYPE_DEFAULT))
            {
              id v255 = v14;
              id v256 = v15;
              id v257 = v34;
              *(void *)unsigned int v324 = 0LL;
              unsigned int v258 = sub_100053B4C(1);
              uint64_t v259 = (os_log_s *)v254;
              if (os_log_type_enabled(v259, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v260 = v258;
              }
              else {
                uint64_t v260 = v258 & 0xFFFFFFFE;
              }
              if ((_DWORD)v260)
              {
                LODWORD(v327[0]) = 67109120;
                HIDWORD(v327[0]) = v35;
                uint64_t v261 = (char *)_os_log_send_and_compose_impl( v260,  v324,  0LL,  0LL,  &_mh_execute_header,  v259,  0LL,  "createPersonaSession failed with error:%d",  v327);

                if (v261) {
                  sub_100053B7C(v261);
                }
              }

              else
              {

                uint64_t v261 = 0LL;
              }

              free(v261);
              unsigned int v34 = v257;
              id v15 = v256;
              id v14 = v255;
            }

            unsigned int v24 = 0LL;
            unsigned int *v253 = v35;
          }

          goto LABEL_472;
        }

        id v243 = *(id *)(v297 + 24);
        unsigned int v244 = [v243 deleteVolumeWithSession:v24 error:0];

        if (v244)
        {
          if (qword_1000DBB68 != -1) {
            dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
          }
          id v245 = (id)qword_1000DBB60;
          id v15 = v138;
          a7 = v300;
          if (os_log_type_enabled((os_log_t)v245, OS_LOG_TYPE_DEFAULT))
          {
            *(void *)unsigned int v324 = 0LL;
            unsigned int v246 = sub_100053B4C(1);
            int v247 = (os_log_s *)v245;
            if (os_log_type_enabled(v247, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v248 = v246;
            }
            else {
              uint64_t v248 = v246 & 0xFFFFFFFE;
            }
            if ((_DWORD)v248)
            {
              LOWORD(v327[0]) = 0;
              LODWORD(v289) = 2;
              uint64_t v249 = _os_log_send_and_compose_impl( v248,  v324,  0LL,  0LL,  &_mh_execute_header,  v247,  0LL,  "Removed APFS User volume",  v327,  v289);
              goto LABEL_450;
            }

            goto LABEL_452;
          }
        }

        else
        {
          if (qword_1000DBB68 != -1) {
            dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
          }
          id v245 = (id)qword_1000DBB60;
          id v15 = v138;
          a7 = v300;
          if (os_log_type_enabled((os_log_t)v245, OS_LOG_TYPE_DEFAULT))
          {
            *(void *)unsigned int v324 = 0LL;
            unsigned int v250 = sub_100053B4C(1);
            int v247 = (os_log_s *)v245;
            if (os_log_type_enabled(v247, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v251 = v250;
            }
            else {
              uint64_t v251 = v250 & 0xFFFFFFFE;
            }
            if ((_DWORD)v251)
            {
              LOWORD(v327[0]) = 0;
              LODWORD(v289) = 2;
              uint64_t v249 = _os_log_send_and_compose_impl( v251,  v324,  0LL,  0LL,  &_mh_execute_header,  v247,  0LL,  "Failed to remove APFS volume",  v327,  v289);
LABEL_450:
              int v252 = (char *)v249;

              if (v252) {
                sub_100053B7C(v252);
              }
              goto LABEL_453;
            }

LABEL_452:
            int v252 = 0LL;
LABEL_453:
            free(v252);
          }
        }

        unsigned int v34 = v298;
        if ((v293 & 1) != 0) {
          goto LABEL_455;
        }
        goto LABEL_441;
      }

      unsigned int v34 = 0LL;
    }

    else
    {
      int v83 = 0LL;
      unsigned int v34 = 0LL;
      uint64_t v82 = v316;
    }

    id v15 = v312;
    goto LABEL_220;
  }

  if (((1 << v313) & 0x28) == 0)
  {
    if (v313 == 4)
    {
      sub_10005798C((uint64_t)a1, v24);
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      uint64_t v82 = v316;
      int v83 = (os_log_s *)(id)qword_1000DBB60;
      id v15 = v312;
      if (!os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_176;
      }
      *(void *)unsigned int v324 = 0LL;
      unsigned int v84 = sub_100053B4C(1);
      if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v85 = v84;
      }
      else {
        uint64_t v85 = v84 & 0xFFFFFFFE;
      }
      if ((_DWORD)v85)
      {
        LOWORD(v327[0]) = 0;
        uint64_t v86 = (const char *)_os_log_send_and_compose_impl( v85,  v324,  0LL,  0LL,  &_mh_execute_header,  v83,  0LL,  "Setup Default Bundles for Universal");
        goto LABEL_143;
      }
    }

    else
    {
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      uint64_t v82 = v316;
      int v83 = (os_log_s *)(id)qword_1000DBB60;
      id v15 = v312;
      if (!os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_176;
      }
      *(void *)unsigned int v324 = 0LL;
      unsigned int v87 = sub_100053B4C(1);
      if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v88 = v87;
      }
      else {
        uint64_t v88 = v87 & 0xFFFFFFFE;
      }
      if ((_DWORD)v88)
      {
        LODWORD(v327[0]) = 67109120;
        HIDWORD(v327[0]) = v313;
        uint64_t v86 = (const char *)_os_log_send_and_compose_impl( v88,  v324,  0LL,  0LL,  &_mh_execute_header,  v83,  0LL,  "Unknown persona type creation:%d:",  v327);
LABEL_143:
        id v89 = (char *)v86;
        if (v86) {
          sub_100053B7C(v86);
        }
        goto LABEL_175;
      }
    }

    id v89 = 0LL;
LABEL_175:
    free(v89);
LABEL_176:
    uint64_t v33 = 0LL;
    unsigned int v34 = 0LL;
    goto LABEL_328;
  }

  gid_t v299 = v30;
  if (qword_1000DBB68 != -1) {
    dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
  }
  uint64_t v69 = (os_log_s *)(id)qword_1000DBB60;
  if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)unsigned int v324 = 0LL;
    unsigned int v70 = sub_100053B4C(1);
    if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v71 = v70;
    }
    else {
      uint64_t v71 = v70 & 0xFFFFFFFE;
    }
    if ((_DWORD)v71)
    {
      LODWORD(v327[0]) = 67109120;
      HIDWORD(v327[0]) = v315;
      CFStringRef v72 = (const char *)_os_log_send_and_compose_impl( v71,  v324,  0LL,  0LL,  &_mh_execute_header,  v69,  0LL,  "Creating new persona with ID:%d",  v327);
      CFStringRef v73 = (char *)v72;
      if (v72) {
        sub_100053B7C(v72);
      }
    }

    else
    {
      CFStringRef v73 = 0LL;
    }

    free(v73);
  }

  stat v314 = v17;

  unsigned int v99 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v315));
  -[os_log_s setObject:forKeyedSubscript:](v24, "setObject:forKeyedSubscript:", v99, @"UserPersonaID");

  id v301 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"));
  uint64_t v100 = (void *)objc_claimAutoreleasedReturnValue([v301 UUIDString]);
  -[os_log_s setObject:forKeyedSubscript:](v24, "setObject:forKeyedSubscript:", v100, @"UserPersonaUniqueString");
  id v15 = v312;
  if (v313 == 3)
  {
    sub_1000579F8((uint64_t)a1, v24);
    if (qword_1000DBB68 != -1) {
      dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
    }
    uint64_t v101 = (os_log_s *)(id)qword_1000DBB60;
    if (os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)unsigned int v324 = 0LL;
      unsigned int v102 = sub_100053B4C(1);
      if (os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v103 = v102;
      }
      else {
        uint64_t v103 = v102 & 0xFFFFFFFE;
      }
      if ((_DWORD)v103)
      {
        LOWORD(v327[0]) = 0;
        LODWORD(v289) = 2;
        unsigned int v104 = (const char *)_os_log_send_and_compose_impl( v103,  v324,  0LL,  0LL,  &_mh_execute_header,  v101,  0LL,  "Setup Default Bundles for System",  v327,  v289);
        id v105 = (char *)v104;
        if (v104) {
          sub_100053B7C(v104);
        }
      }

      else
      {
        id v105 = 0LL;
      }

      free(v105);
    }
  }

  if (qword_1000DBB68 != -1) {
    dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
  }
  uint64_t v106 = (os_log_s *)(id)qword_1000DBB60;
  if (os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)unsigned int v324 = 0LL;
    unsigned int v107 = sub_100053B4C(1);
    if (os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v108 = v107;
    }
    else {
      uint64_t v108 = v107 & 0xFFFFFFFE;
    }
    if ((_DWORD)v108)
    {
      LODWORD(v327[0]) = 67109120;
      HIDWORD(v327[0]) = v315;
      uint64_t v109 = (const char *)_os_log_send_and_compose_impl( v108,  v324,  0LL,  0LL,  &_mh_execute_header,  v106,  0LL,  "Allocating kernel persona for System/Default PersonaID:%d",  v327);
      uint64_t v110 = (char *)v109;
      if (v109) {
        sub_100053B7C(v109);
      }
    }

    else
    {
      uint64_t v110 = 0LL;
    }

    free(v110);
  }

  id v323 = 0LL;
  char v111 = sub_10005E240((uint64_t)a1, v24, &v323);
  unsigned int v112 = (os_log_s *)v323;
  uint64_t v33 = v112;
  if ((v111 & 1) == 0)
  {
    unsigned int v35 = -[os_log_s code](v112, "code");
    if (qword_1000DBB68 != -1) {
      dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
    }
    uint64_t v118 = (os_log_s *)(id)qword_1000DBB60;
    if (os_log_type_enabled(v118, OS_LOG_TYPE_DEFAULT))
    {
      v327[0] = 0LL;
      unsigned int v119 = sub_100053B4C(1);
      if (os_log_type_enabled(v118, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v120 = v119;
      }
      else {
        uint64_t v120 = v119 & 0xFFFFFFFE;
      }
      if ((_DWORD)v120)
      {
        id v121 = v118;
        unsigned int v122 = -[os_log_s code](v33, "code");
        *(_DWORD *)unsigned int v324 = 67109376;
        *(_DWORD *)&v324[4] = v315;
        *(_WORD *)&v324[8] = 1024;
        *(_DWORD *)&v324[10] = v122;
        uint64_t v123 = (char *)_os_log_send_and_compose_impl( v120,  v327,  0LL,  0LL,  &_mh_execute_header,  v121,  0LL,  "Allocating kernel persona for:%d failed with Error:%d",  v324,  14);

        if (v123) {
          sub_100053B7C(v123);
        }
      }

      else
      {
        uint64_t v123 = 0LL;
      }

      free(v123);
    }

    unsigned int v34 = 0LL;
    a7 = v299;
    unsigned int v59 = (os_log_s *)v301;
    goto LABEL_456;
  }

  unsigned int v315 = sub_100084F14(v24, (uint64_t)@"UserPersonaID", 0LL);
  if (qword_1000DBB68 != -1) {
    dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
  }
  id v113 = (os_log_s *)(id)qword_1000DBB60;
  if (os_log_type_enabled(v113, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)unsigned int v324 = 0LL;
    unsigned int v114 = sub_100053B4C(1);
    if (os_log_type_enabled(v113, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v115 = v114;
    }
    else {
      uint64_t v115 = v114 & 0xFFFFFFFE;
    }
    if ((_DWORD)v115)
    {
      LODWORD(v327[0]) = 67109120;
      HIDWORD(v327[0]) = v315;
      uint64_t v116 = (const char *)_os_log_send_and_compose_impl( v115,  v324,  0LL,  0LL,  &_mh_execute_header,  v113,  0LL,  "PersonaID:%d registered with Kernel",  v327);
      unsigned int v117 = (char *)v116;
      if (v116) {
        sub_100053B7C(v116);
      }
    }

    else
    {
      unsigned int v117 = 0LL;
    }

    free(v117);
  }

  unsigned int v34 = 0LL;
  uint64_t v82 = v316;
  unsigned int v17 = v314;
  int v83 = (os_log_s *)v301;
LABEL_328:

  if (v24) {
    [v82 addObject:v24];
  }
  if (a5)
  {
    if ((v311 & 1) == 0)
    {
      uint64_t v197 = v34;
      id v198 = a1[5];
      sub_1000562B8((uint64_t)v198);

      unsigned int v34 = v197;
    }

    sub_10005B2D0((uint64_t)a1);
  }

  if (v313 == 4)
  {
    if (qword_1000DBB58 != -1) {
      dispatch_once(&qword_1000DBB58, &stru_1000CD6B0);
    }
    uint64_t v199 = (os_log_s *)(id)qword_1000DBB50;
    if (!os_log_type_enabled(v199, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_355;
    }
    uint64_t v200 = v34;
    v327[0] = 0LL;
    unsigned int v201 = sub_100053B4C(1);
    uint64_t v199 = v199;
    if (os_log_type_enabled(v199, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v202 = v201;
    }
    else {
      uint64_t v202 = v201 & 0xFFFFFFFE;
    }
    if ((_DWORD)v202)
    {
      *(_DWORD *)unsigned int v324 = 138412290;
      *(void *)&v324[4] = v17;
      LODWORD(v289) = 12;
      uint64_t v203 = _os_log_send_and_compose_impl( v202,  v327,  0LL,  0LL,  &_mh_execute_header,  v199,  0LL,  "Created universal persona for user %@",  v324,  v289);
      goto LABEL_351;
    }
  }

  else
  {
    if (qword_1000DBB58 != -1) {
      dispatch_once(&qword_1000DBB58, &stru_1000CD6B0);
    }
    uint64_t v199 = (os_log_s *)(id)qword_1000DBB50;
    if (!os_log_type_enabled(v199, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_355;
    }
    uint64_t v200 = v34;
    v327[0] = 0LL;
    unsigned int v204 = sub_100053B4C(1);
    uint64_t v199 = v199;
    if (os_log_type_enabled(v199, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v205 = v204;
    }
    else {
      uint64_t v205 = v204 & 0xFFFFFFFE;
    }
    if ((_DWORD)v205)
    {
      *(_DWORD *)unsigned int v324 = 67109378;
      *(_DWORD *)&v324[4] = v315;
      *(_WORD *)&v324[8] = 2112;
      *(void *)&v324[10] = v17;
      LODWORD(v289) = 18;
      uint64_t v203 = _os_log_send_and_compose_impl( v205,  v327,  0LL,  0LL,  &_mh_execute_header,  v199,  0LL,  "Created persona %u for user %@",  v324,  v289);
LABEL_351:
      uint64_t v206 = (char *)v203;

      if (v206) {
        sub_100053B7C(v206);
      }
      goto LABEL_354;
    }
  }

  uint64_t v206 = 0LL;
LABEL_354:
  free(v206);
  unsigned int v34 = v200;
LABEL_355:

  sub_10005EBCC((uint64_t)a1);
LABEL_472:
  id v262 = v24;

LABEL_473:
  return v262;
}

uint64_t sub_10005E240(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  if (!a1)
  {
    uint64_t v31 = 0LL;
    goto LABEL_106;
  }

  if (a3) {
    *a3 = 0LL;
  }
  id v6 = objc_alloc_init(&OBJC_CLASS___UMKPersonaInfo);
  id v7 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:@"UserPersonaType"]);

  if (!v7)
  {
    if (qword_1000DBB68 != -1) {
      dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
    }
    unsigned int v20 = (os_log_s *)(id)qword_1000DBB60;
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_47;
    }
    uint64_t v63 = 0LL;
    unsigned int v21 = sub_100053B4C(1);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v22 = v21;
    }
    else {
      uint64_t v22 = v21 & 0xFFFFFFFE;
    }
    if ((_DWORD)v22)
    {
      LOWORD(v66) = 0;
      uint64_t v23 = (const char *)_os_log_send_and_compose_impl( v22,  &v63,  0LL,  0LL,  &_mh_execute_header,  v20,  0LL,  "Failed to load persona into kernel: Missing persona type",  &v66,  2);
      goto LABEL_43;
    }

    goto LABEL_45;
  }

  int v8 = sub_100084F14(v5, (uint64_t)@"UserPersonaType", (id)0xFFFFFFFFLL);
  int v9 = sub_1000604E8((uint64_t)&OBJC_CLASS___UMDPersonaManager, v8);
  sub_100064174((uint64_t)v6, v9);
  if (sub_100064168((uint64_t)v6) == -1)
  {
    if (qword_1000DBB68 != -1) {
      dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
    }
    unsigned int v20 = (os_log_s *)(id)qword_1000DBB60;
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_47;
    }
    uint64_t v63 = 0LL;
    unsigned int v24 = sub_100053B4C(1);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v25 = v24;
    }
    else {
      uint64_t v25 = v24 & 0xFFFFFFFE;
    }
    if ((_DWORD)v25)
    {
      LODWORD(v66) = 67109120;
      HIDWORD(v66) = v8;
      uint64_t v23 = (const char *)_os_log_send_and_compose_impl( v25,  &v63,  0LL,  0LL,  &_mh_execute_header,  v20,  0LL,  "Failed to load persona into kernel: Unexpected persona type: %d",  &v66);
      goto LABEL_43;
    }

    goto LABEL_45;
  }

  unsigned int v10 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:@"UserPersonaID"]);

  if (!v10)
  {
    if (qword_1000DBB68 != -1) {
      dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
    }
    unsigned int v20 = (os_log_s *)(id)qword_1000DBB60;
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_47;
    }
    uint64_t v63 = 0LL;
    unsigned int v26 = sub_100053B4C(1);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v27 = v26;
    }
    else {
      uint64_t v27 = v26 & 0xFFFFFFFE;
    }
    if ((_DWORD)v27)
    {
      LOWORD(v66) = 0;
      uint64_t v23 = (const char *)_os_log_send_and_compose_impl( v27,  &v63,  0LL,  0LL,  &_mh_execute_header,  v20,  0LL,  "Failed to load persona into kernel: Missing kernel id",  &v66,  2);
      goto LABEL_43;
    }

LABEL_104:
  uint64_t v31 = v53;
LABEL_105:

LABEL_106:
  return v31;
}

        sub_100053B7C((const char *)v41);
        goto LABEL_106;
      }
    }

    else
    {
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      unsigned int v37 = (os_log_s *)(id)qword_1000DBB60;
      if (!os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_107;
      }
      uint64_t v66 = 0LL;
      LODWORD(v3_Block_object_dispose(va, 8) = sub_100053B4C(1);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v38 = v38;
      }
      else {
        uint64_t v38 = v38 & 0xFFFFFFFE;
      }
      if ((_DWORD)v38)
      {
        uint64_t v39 = v37;
        uint64_t v40 = -[os_log_s code](v16, "code");
        LODWORD(v63) = 67109376;
        HIDWORD(v63) = (_DWORD)v7;
        __int16 v64 = 1024;
        uint64_t v65 = v40;
        LODWORD(v61) = 14;
        uint64_t v41 = (void *)_os_log_send_and_compose_impl( v38,  &v66,  0LL,  0LL,  &_mh_execute_header,  v39,  0LL,  "FAILED TO LOAD PERSONA to KERNEL %u with error: %{darwin.errno}d",  &v63,  v61);

        if (!v41) {
          goto LABEL_106;
        }
        goto LABEL_104;
      }
    }

    uint64_t v41 = 0LL;
    goto LABEL_106;
  }

  int v9 = 1LL;
LABEL_109:

  return v9;
}

id *sub_10005EBB0(id *WeakRetained)
{
  if (WeakRetained) {
    id WeakRetained = (id *)objc_loadWeakRetained(WeakRetained + 6);
  }
  return WeakRetained;
}

void sub_10005EBCC(uint64_t a1)
{
  if (a1)
  {
    __int128 v20 = 0u;
    __int128 v21 = 0u;
    __int128 v18 = 0u;
    __int128 v19 = 0u;
    id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) userPersonas]);
    id v3 = [v2 countByEnumeratingWithState:&v18 objects:v24 count:16];
    if (v3)
    {
      id v4 = v3;
      uint64_t v5 = *(void *)v19;
      do
      {
        id v6 = 0LL;
        do
        {
          if (*(void *)v19 != v5) {
            objc_enumerationMutation(v2);
          }
          uint64_t v7 = *(void *)(*((void *)&v18 + 1) + 8LL * (void)v6);
          if (qword_1000DBB68 != -1) {
            dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
          }
          int v8 = (os_log_s *)(id)qword_1000DBB60;
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v17 = 0LL;
            unsigned int v9 = sub_100053B4C(1);
            if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
              uint64_t v10 = v9;
            }
            else {
              uint64_t v10 = v9 & 0xFFFFFFFE;
            }
            if ((_DWORD)v10)
            {
              int v22 = 138412290;
              uint64_t v23 = v7;
              LODWORD(v16) = 12;
              int v11 = (const char *)_os_log_send_and_compose_impl( v10,  &v17,  0LL,  0LL,  &_mh_execute_header,  v8,  2LL,  "User with UUID:%@",  &v22,  v16);
              id v12 = (char *)v11;
              if (v11) {
                sub_100053B7C(v11);
              }
            }

            else
            {
              id v12 = 0LL;
            }

            free(v12);
          }

          id v13 = *(id *)(a1 + 32);
          id v14 = (void *)objc_claimAutoreleasedReturnValue([v13 userPersonas]);
          id v15 = (void *)objc_claimAutoreleasedReturnValue([v14 objectForKeyedSubscript:v7]);

          sub_1000628D0(a1, v15);
          id v6 = (char *)v6 + 1;
        }

        while (v4 != v6);
        id v4 = [v2 countByEnumeratingWithState:&v18 objects:v24 count:16];
      }

      while (v4);
    }
  }

uint64_t sub_10005EDF4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = v5;
  if (a1)
  {
    if (a3) {
      *a3 = 0LL;
    }
    id v7 = sub_100084F14(v5, (uint64_t)@"UserPersonaID", 0LL);
    if ((_DWORD)v7)
    {
      id v8 = v7;
      uint64_t v9 = sub_1000197AC(*(void *)(a1 + 16));
      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
      unsigned __int8 v11 = [v10 deallocatePersonaWithID:v8 error:a3];

      if ((v11 & 1) != 0)
      {
        a1 = 1LL;
        goto LABEL_33;
      }

      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      uint64_t v17 = (os_log_s *)(id)qword_1000DBB60;
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v24 = 0LL;
        unsigned int v18 = sub_100053B4C(1);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v19 = v18;
        }
        else {
          uint64_t v19 = v18 & 0xFFFFFFFE;
        }
        if ((_DWORD)v19)
        {
          __int16 v23 = 0;
          __int128 v20 = (const char *)_os_log_send_and_compose_impl( v19,  &v24,  0LL,  0LL,  &_mh_execute_header,  v17,  0LL,  "Failed to unload persona from kernel: Error deallocating kernel persona",  &v23,  2);
          __int128 v21 = (char *)v20;
          if (v20) {
            sub_100053B7C(v20);
          }
        }

        else
        {
          __int128 v21 = 0LL;
        }

        free(v21);
      }
    }

    else
    {
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      id v12 = (os_log_s *)(id)qword_1000DBB60;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v24 = 0LL;
        unsigned int v13 = sub_100053B4C(1);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v14 = v13;
        }
        else {
          uint64_t v14 = v13 & 0xFFFFFFFE;
        }
        if ((_DWORD)v14)
        {
          __int16 v23 = 0;
          id v15 = (const char *)_os_log_send_and_compose_impl( v14,  &v24,  0LL,  0LL,  &_mh_execute_header,  v12,  0LL,  "Failed to unload persona from kernel: Missing kernel id",  &v23,  2);
          uint64_t v16 = (char *)v15;
          if (v15) {
            sub_100053B7C(v15);
          }
        }

        else
        {
          uint64_t v16 = 0LL;
        }

        free(v16);
      }

      if (a3)
      {
        a1 = 0LL;
        *a3 = (id)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  22LL,  0LL));
        goto LABEL_33;
      }
    }

    a1 = 0LL;
  }

void sub_10005F068(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    id v7 = sub_100058BD8(a1, 4u, v5);
    uint64_t v8 = objc_claimAutoreleasedReturnValue(v7);
    if (v8)
    {
      uint64_t v9 = (void *)v8;
      BOOL v10 = 0;
    }

    else
    {
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      unsigned __int8 v11 = (os_log_s *)(id)qword_1000DBB60;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v71 = 0LL;
        unsigned int v12 = sub_100053B4C(1);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v13 = v12;
        }
        else {
          uint64_t v13 = v12 & 0xFFFFFFFE;
        }
        if ((_DWORD)v13)
        {
          __int16 v70 = 0;
          uint64_t v14 = (const char *)_os_log_send_and_compose_impl( v13,  &v71,  0LL,  0LL,  &_mh_execute_header,  v11,  0LL,  "Did not find Universal Persona, creating...",  &v70,  2);
          id v15 = (char *)v14;
          if (v14) {
            sub_100053B7C(v14);
          }
        }

        else
        {
          id v15 = 0LL;
        }

        free(v15);
      }

      uint64_t v16 = sub_10005AE10((id *)a1, v5, 4LL, v6);
      uint64_t v17 = objc_claimAutoreleasedReturnValue(v16);
      BOOL v10 = v17 != 0;
      if (v17)
      {
        uint64_t v9 = (void *)v17;
        if (qword_1000DBB68 != -1) {
          dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
        }
        unsigned int v18 = (os_log_s *)(id)qword_1000DBB60;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v71 = 0LL;
          unsigned int v19 = sub_100053B4C(1);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v20 = v19;
          }
          else {
            uint64_t v20 = v19 & 0xFFFFFFFE;
          }
          if ((_DWORD)v20)
          {
            __int16 v70 = 0;
            LODWORD(v69) = 2;
            __int128 v21 = (const char *)_os_log_send_and_compose_impl( v20,  &v71,  0LL,  0LL,  &_mh_execute_header,  v18,  0LL,  "Created Universal  Successfully",  &v70,  v69);
            int v22 = (char *)v21;
            if (v21) {
              sub_100053B7C(v21);
            }
          }

          else
          {
            int v22 = 0LL;
          }

          free(v22);
        }
      }

      else
      {
        if (qword_1000DBB68 != -1) {
          dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
        }
        unsigned int v18 = (os_log_s *)(id)qword_1000DBB60;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v71 = 0LL;
          unsigned int v23 = sub_100053B4C(1);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = v23 & 0xFFFFFFFE;
          }
          if ((_DWORD)v24)
          {
            __int16 v70 = 0;
            LODWORD(v69) = 2;
            uint64_t v25 = (const char *)_os_log_send_and_compose_impl( v24,  &v71,  0LL,  0LL,  &_mh_execute_header,  v18,  0LL,  "Failed to create Universal Persona",  &v70,  v69);
            unsigned int v26 = (char *)v25;
            if (v25) {
              sub_100053B7C(v25);
            }
          }

          else
          {
            unsigned int v26 = 0LL;
          }

          free(v26);
        }

        uint64_t v9 = 0LL;
      }
    }

    id v27 = sub_100058BD8(a1, 3u, v5);
    unsigned int v28 = (void *)objc_claimAutoreleasedReturnValue(v27);

    if (!v28)
    {
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      uint64_t v29 = (os_log_s *)(id)qword_1000DBB60;
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v71 = 0LL;
        unsigned int v30 = sub_100053B4C(1);
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v31 = v30;
        }
        else {
          uint64_t v31 = v30 & 0xFFFFFFFE;
        }
        if ((_DWORD)v31)
        {
          __int16 v70 = 0;
          LODWORD(v69) = 2;
          unsigned int v32 = (const char *)_os_log_send_and_compose_impl( v31,  &v71,  0LL,  0LL,  &_mh_execute_header,  v29,  0LL,  "Did not find System Persona, creating...",  &v70,  v69);
          int v33 = (char *)v32;
          if (v32) {
            sub_100053B7C(v32);
          }
        }

        else
        {
          int v33 = 0LL;
        }

        free(v33);
      }

      id v34 = sub_10005AE10((id *)a1, v5, 3LL, v6);
      uint64_t v35 = objc_claimAutoreleasedReturnValue(v34);
      if (v35)
      {
        unsigned int v28 = (void *)v35;
        if (qword_1000DBB68 != -1) {
          dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
        }
        id v36 = (os_log_s *)(id)qword_1000DBB60;
        if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v71 = 0LL;
          unsigned int v37 = sub_100053B4C(1);
          if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v38 = v37;
          }
          else {
            uint64_t v38 = v37 & 0xFFFFFFFE;
          }
          if ((_DWORD)v38)
          {
            __int16 v70 = 0;
            LODWORD(v69) = 2;
            uint64_t v39 = (const char *)_os_log_send_and_compose_impl( v38,  &v71,  0LL,  0LL,  &_mh_execute_header,  v36,  0LL,  "Created System Persona Successfully",  &v70,  v69);
            uint64_t v40 = (char *)v39;
            if (v39) {
              sub_100053B7C(v39);
            }
          }

          else
          {
            uint64_t v40 = 0LL;
          }

          free(v40);
        }

        BOOL v10 = 1;
      }

      else
      {
        if (qword_1000DBB68 != -1) {
          dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
        }
        id v36 = (os_log_s *)(id)qword_1000DBB60;
        if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v71 = 0LL;
          unsigned int v41 = sub_100053B4C(1);
          if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v42 = v41;
          }
          else {
            uint64_t v42 = v41 & 0xFFFFFFFE;
          }
          if ((_DWORD)v42)
          {
            __int16 v70 = 0;
            LODWORD(v69) = 2;
            uint64_t v43 = (const char *)_os_log_send_and_compose_impl( v42,  &v71,  0LL,  0LL,  &_mh_execute_header,  v36,  0LL,  "Failed to create System persona",  &v70,  v69);
            uint64_t v44 = (char *)v43;
            if (v43) {
              sub_100053B7C(v43);
            }
          }

          else
          {
            uint64_t v44 = 0LL;
          }

          free(v44);
        }

        unsigned int v28 = 0LL;
      }
    }

    id v45 = sub_100058BD8(a1, 5u, v5);
    uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue(v45);

    if (v46)
    {
      if (!v10)
      {
LABEL_129:

        goto LABEL_130;
      }
    }

    else
    {
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      unsigned int v47 = (os_log_s *)(id)qword_1000DBB60;
      if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v71 = 0LL;
        unsigned int v48 = sub_100053B4C(1);
        if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v49 = v48;
        }
        else {
          uint64_t v49 = v48 & 0xFFFFFFFE;
        }
        if ((_DWORD)v49)
        {
          __int16 v70 = 0;
          LODWORD(v69) = 2;
          id v50 = (const char *)_os_log_send_and_compose_impl( v49,  &v71,  0LL,  0LL,  &_mh_execute_header,  v47,  0LL,  "Not found Default Persona, updating",  &v70,  v69);
          uint64_t v51 = (char *)v50;
          if (v50) {
            sub_100053B7C(v50);
          }
        }

        else
        {
          uint64_t v51 = 0LL;
        }

        free(v51);
      }

      int v52 = sub_10005AE10((id *)a1, v5, 5LL, v6);
      uint64_t v53 = objc_claimAutoreleasedReturnValue(v52);
      if (v53)
      {
        uint64_t v46 = (void *)v53;
        if (qword_1000DBB68 != -1) {
          dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
        }
        unsigned int v54 = (os_log_s *)(id)qword_1000DBB60;
        if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v71 = 0LL;
          unsigned int v55 = sub_100053B4C(1);
          if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v56 = v55;
          }
          else {
            uint64_t v56 = v55 & 0xFFFFFFFE;
          }
          if ((_DWORD)v56)
          {
            __int16 v70 = 0;
            LODWORD(v69) = 2;
            id v57 = (const char *)_os_log_send_and_compose_impl( v56,  &v71,  0LL,  0LL,  &_mh_execute_header,  v54,  0LL,  "Created Default Persona Successfully",  &v70,  v69);
            uint64_t v58 = (char *)v57;
            if (v57) {
              sub_100053B7C(v57);
            }
          }

          else
          {
            uint64_t v58 = 0LL;
          }

          free(v58);
        }
      }

      else
      {
        if (qword_1000DBB68 != -1) {
          dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
        }
        unsigned int v59 = (os_log_s *)(id)qword_1000DBB60;
        if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v71 = 0LL;
          unsigned int v60 = sub_100053B4C(1);
          if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v61 = v60;
          }
          else {
            uint64_t v61 = v60 & 0xFFFFFFFE;
          }
          if ((_DWORD)v61)
          {
            __int16 v70 = 0;
            LODWORD(v69) = 2;
            uint64_t v62 = (const char *)_os_log_send_and_compose_impl( v61,  &v71,  0LL,  0LL,  &_mh_execute_header,  v59,  0LL,  "Failed to Default persona",  &v70,  v69);
            uint64_t v63 = (char *)v62;
            if (v62) {
              sub_100053B7C(v62);
            }
          }

          else
          {
            uint64_t v63 = 0LL;
          }

          free(v63);
        }

        uint64_t v46 = 0LL;
        if (!v10) {
          goto LABEL_129;
        }
      }
    }

    if (qword_1000DBB68 != -1) {
      dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
    }
    __int16 v64 = (os_log_s *)(id)qword_1000DBB60;
    if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v71 = 0LL;
      unsigned int v65 = sub_100053B4C(1);
      if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v66 = v65;
      }
      else {
        uint64_t v66 = v65 & 0xFFFFFFFE;
      }
      if ((_DWORD)v66)
      {
        __int16 v70 = 0;
        LODWORD(v69) = 2;
        unsigned int v67 = (const char *)_os_log_send_and_compose_impl( v66,  &v71,  0LL,  0LL,  &_mh_execute_header,  v64,  0LL,  "Update needed, saving all persona",  &v70,  v69);
        uint64_t v68 = (char *)v67;
        if (v67) {
          sub_100053B7C(v67);
        }
      }

      else
      {
        uint64_t v68 = 0LL;
      }

      free(v68);
    }

    sub_10005B2D0((uint64_t)a1);
    goto LABEL_129;
  }

LABEL_130:
}

id sub_10005F9A8(uint64_t a1, void *a2)
{
  if (!a1) {
    return 0LL;
  }
  if (a2) {
    *a2 = 0LL;
  }
  uint64_t v3 = sub_100019434(*(void *)(a1 + 16));
  id v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  id v5 = (void *)objc_claimAutoreleasedReturnValue([v4 dataWithContentsOfFile:@"/private/var/keybags/persona.kb" error:a2]);

  if (v5)
  {
    id v6 = (id)objc_claimAutoreleasedReturnValue(+[UMDPersonaManifest manifestFromData:](&OBJC_CLASS___UMDPersonaManifest, "manifestFromData:", v5));
    if (v6)
    {
      if (qword_1000DBB58 != -1) {
        dispatch_once(&qword_1000DBB58, &stru_1000CD6B0);
      }
      id v7 = (os_log_s *)(id)qword_1000DBB50;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        v27[0] = 0LL;
        unsigned int v8 = sub_100053B4C(0);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v9 = v8;
        }
        else {
          uint64_t v9 = v8 & 0xFFFFFFFE;
        }
        if ((_DWORD)v9)
        {
          BOOL v10 = v7;
          unsigned int v11 = [v6 version];
          id v12 = [v6 generation];
          uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v6 users]);
          LODWORD(v2_Block_object_dispose(va, 8) = 67109632;
          HIDWORD(v2_Block_object_dispose(va, 8) = v11;
          __int16 v29 = 2048;
          id v30 = v12;
          __int16 v31 = 2048;
          id v32 = [v13 count];
          LODWORD(v26) = 28;
          uint64_t v14 = (char *)_os_log_send_and_compose_impl( v9,  v27,  0LL,  0LL,  &_mh_execute_header,  v10,  0LL,  "Loaded persona manifest version: %u, generation: %llu, %lu user(s)",  &v28,  v26);

          if (v14) {
            sub_100053B7C(v14);
          }
        }

        else
        {
          uint64_t v14 = 0LL;
        }

        free(v14);
      }

      id v6 = v6;
      uint64_t v24 = v6;
    }

    else
    {
      if (qword_1000DBB58 != -1) {
        dispatch_once(&qword_1000DBB58, &stru_1000CD6B0);
      }
      unsigned int v19 = (os_log_s *)(id)qword_1000DBB50;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        uint64_t v28 = 0LL;
        unsigned int v20 = sub_100053B4C(0);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
          uint64_t v21 = v20;
        }
        else {
          uint64_t v21 = v20 & 0xFFFFFFFE;
        }
        if ((_DWORD)v21)
        {
          LOWORD(v27[0]) = 0;
          int v22 = (const char *)_os_log_send_and_compose_impl( v21,  &v28,  0LL,  0LL,  &_mh_execute_header,  v19,  16LL,  "Failed to load persona manifest: Failed to parse persona manifest data",  v27,  2);
          unsigned int v23 = (char *)v22;
          if (v22) {
            sub_100053B7C(v22);
          }
        }

        else
        {
          unsigned int v23 = 0LL;
        }

        free(v23);
      }

      if (a2) {
        *a2 = (id)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  22LL,  0LL));
      }
      uint64_t v24 = 0LL;
    }
  }

  else
  {
    if (qword_1000DBB58 != -1) {
      dispatch_once(&qword_1000DBB58, &stru_1000CD6B0);
    }
    id v6 = (id)qword_1000DBB50;
    if (os_log_type_enabled((os_log_t)v6, OS_LOG_TYPE_ERROR))
    {
      uint64_t v28 = 0LL;
      unsigned int v15 = sub_100053B4C(0);
      if (os_log_type_enabled((os_log_t)v6, OS_LOG_TYPE_ERROR)) {
        uint64_t v16 = v15;
      }
      else {
        uint64_t v16 = v15 & 0xFFFFFFFE;
      }
      if ((_DWORD)v16)
      {
        LOWORD(v27[0]) = 0;
        uint64_t v17 = (const char *)_os_log_send_and_compose_impl( v16,  &v28,  0LL,  0LL,  &_mh_execute_header,  v6,  16LL,  "Failed to load persona manifest: Failed to read persona manifest file from disk",  v27,  2);
        unsigned int v18 = (char *)v17;
        if (v17) {
          sub_100053B7C(v17);
        }
      }

      else
      {
        unsigned int v18 = 0LL;
      }

      free(v18);
    }

    uint64_t v24 = 0LL;
  }

  return v24;
}

UMDPersonaManifestUser *sub_10005FD88(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v29 = a3;
  if (a1)
  {
    id v6 = objc_alloc_init(&OBJC_CLASS___UMDPersonaManifestUser);
    id v7 = sub_100017CFC((uint64_t)&OBJC_CLASS___NSUUID, v5);
    unsigned int v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
    uint64_t v28 = v6;
    sub_1000198B4((uint64_t)v6, v8);

    __int128 v36 = 0u;
    __int128 v37 = 0u;
    __int128 v34 = 0u;
    __int128 v35 = 0u;
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) asidMap]);
    id v10 = [v9 countByEnumeratingWithState:&v34 objects:v39 count:16];
    if (v10)
    {
      id v11 = v10;
      uint64_t v12 = *(void *)v35;
      while (2)
      {
        for (uint64_t i = 0LL; i != v11; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v35 != v12) {
            objc_enumerationMutation(v9);
          }
          uint64_t v14 = *(void **)(*((void *)&v34 + 1) + 8LL * (void)i);
          id v15 = *(id *)(a1 + 32);
          uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v15 asidMap]);
          uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([v16 objectForKeyedSubscript:v14]);

          LODWORD(v15) = [v5 isEqualToString:v17];
          if ((_DWORD)v15)
          {
            sub_100056838((uint64_t)v28, (int)[v14 intValue]);
            goto LABEL_12;
          }
        }

        id v11 = [v9 countByEnumeratingWithState:&v34 objects:v39 count:16];
        if (v11) {
          continue;
        }
        break;
      }
    }

id sub_10006002C(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  id v15 = (void *)objc_claimAutoreleasedReturnValue(+[UMDPersonaManifest manifest](&OBJC_CLASS___UMDPersonaManifest, "manifest"));
  [v15 setGeneration:sub_100056274(*(void *)(a1 + 40))];
  id v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) userPersonas]);
  id v4 = [v3 countByEnumeratingWithState:&v16 objects:v20 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v17;
    do
    {
      id v7 = 0LL;
      do
      {
        if (*(void *)v17 != v6) {
          objc_enumerationMutation(v3);
        }
        unsigned int v8 = *(void **)(*((void *)&v16 + 1) + 8LL * (void)v7);
        id v9 = *(id *)(a1 + 32);
        id v10 = (void *)objc_claimAutoreleasedReturnValue([v9 userPersonas]);
        id v11 = (void *)objc_claimAutoreleasedReturnValue([v10 objectForKeyedSubscript:v8]);
        uint64_t v12 = sub_10005FD88(a1, v8, v11);
        uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(v12);

        [v2 addObject:v13];
        id v7 = (char *)v7 + 1;
      }

      while (v5 != v7);
      id v5 = [v3 countByEnumeratingWithState:&v16 objects:v20 count:16];
    }

    while (v5);
  }

  [v15 setUsers:v2];
  return v15;
}

uint64_t sub_1000601E8(uint64_t a1, void *a2, void *a3)
{
  uint64_t v3 = a1;
  if (a1)
  {
    if (a3) {
      *a3 = 0LL;
    }
    id v5 = (void *)objc_claimAutoreleasedReturnValue([a2 dataValue]);
    if (v5)
    {
      uint64_t v6 = sub_100019434(*(void *)(v3 + 16));
      id v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
      unsigned __int8 v8 = [v7 atomicallyWriteData:v5 toPath:@"/private/var/keybags/persona.kb" error:a3];

      if ((v8 & 1) != 0)
      {
        uint64_t v3 = 1LL;
LABEL_33:

        return v3;
      }

      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      uint64_t v14 = (os_log_s *)(id)qword_1000DBB60;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v21 = 0LL;
        unsigned int v15 = sub_100053B4C(1);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v16 = v15;
        }
        else {
          uint64_t v16 = v15 & 0xFFFFFFFE;
        }
        if ((_DWORD)v16)
        {
          __int16 v20 = 0;
          __int128 v17 = (const char *)_os_log_send_and_compose_impl( v16,  &v21,  0LL,  0LL,  &_mh_execute_header,  v14,  0LL,  "Failed to save persona manifest: Failed to write data to disk atomically",  &v20,  2);
          __int128 v18 = (char *)v17;
          if (v17) {
            sub_100053B7C(v17);
          }
        }

        else
        {
          __int128 v18 = 0LL;
        }

        free(v18);
      }
    }

    else
    {
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      id v9 = (os_log_s *)(id)qword_1000DBB60;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v21 = 0LL;
        unsigned int v10 = sub_100053B4C(1);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v11 = v10;
        }
        else {
          uint64_t v11 = v10 & 0xFFFFFFFE;
        }
        if ((_DWORD)v11)
        {
          __int16 v20 = 0;
          uint64_t v12 = (const char *)_os_log_send_and_compose_impl( v11,  &v21,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "Failed to save persona manifest: Failed to generate persona manifest data",  &v20,  2);
          uint64_t v13 = (char *)v12;
          if (v12) {
            sub_100053B7C(v12);
          }
        }

        else
        {
          uint64_t v13 = 0LL;
        }

        free(v13);
      }

      if (a3)
      {
        uint64_t v3 = 0LL;
        *a3 = (id)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  22LL,  0LL));
        goto LABEL_33;
      }
    }

    uint64_t v3 = 0LL;
    goto LABEL_33;
  }

  return v3;
}

BOOL sub_100060454(uint64_t a1, uint64_t a2)
{
  BOOL v2 = 0LL;
  if (a1 && (_DWORD)a2 != -1)
  {
    id v4 = *(id *)(a1 + 16);
    uint64_t v5 = sub_1000197AC((uint64_t)v4);
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
    id v10 = 0LL;
    id v7 = (void *)objc_claimAutoreleasedReturnValue([v6 infoForPersonaWithID:a2 error:&v10]);
    id v8 = v10;

    BOOL v2 = v7 != 0LL;
  }

  return v2;
}

uint64_t sub_1000604E8(uint64_t a1, int a2)
{
  uint64_t result = 5LL;
  switch(a2)
  {
    case 0:
      return result;
    case 1:
    case 4:
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      id v4 = (os_log_s *)(id)qword_1000DBB60;
      if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_27;
      }
      uint64_t v11 = 0LL;
      unsigned int v5 = sub_100053B4C(1);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v6 = v5;
      }
      else {
        uint64_t v6 = v5 & 0xFFFFFFFE;
      }
      if (!(_DWORD)v6) {
        goto LABEL_25;
      }
      int v12 = 67109120;
      int v13 = a2;
      id v7 = (const char *)_os_log_send_and_compose_impl( v6,  &v11,  0LL,  0LL,  &_mh_execute_header,  v4,  0LL,  "No matching kernel persona type for persona type: %d",  &v12);
      goto LABEL_23;
    case 2:
    case 6:
      uint64_t result = 2LL;
      break;
    case 3:
      uint64_t result = 4LL;
      break;
    case 5:
      uint64_t result = 6LL;
      break;
    default:
      if (a2 == 1000)
      {
        uint64_t result = 0LL;
      }

      else
      {
        if (qword_1000DBB68 != -1) {
          dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
        }
        id v4 = (os_log_s *)(id)qword_1000DBB60;
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v11 = 0LL;
          unsigned int v8 = sub_100053B4C(1);
          if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v9 = v8;
          }
          else {
            uint64_t v9 = v8 & 0xFFFFFFFE;
          }
          if ((_DWORD)v9)
          {
            int v12 = 67109120;
            int v13 = a2;
            id v7 = (const char *)_os_log_send_and_compose_impl( v9,  &v11,  0LL,  0LL,  &_mh_execute_header,  v4,  0LL,  "Unexpected persona type: %d",  &v12);
LABEL_23:
            id v10 = (char *)v7;
            if (v7) {
              sub_100053B7C(v7);
            }
          }

          else
          {
LABEL_25:
            id v10 = 0LL;
          }

          free(v10);
        }

LABEL_27:
        uint64_t result = 0xFFFFFFFFLL;
      }

      break;
  }

  return result;
}

BOOL sub_100060734(uint64_t a1, void *a2)
{
  if (!a1) {
    return 0LL;
  }
  BOOL v2 = (void *)objc_claimAutoreleasedReturnValue([a2 objectForKeyedSubscript:@"MKBUserSessionVolumeDeviceNode"]);
  BOOL v3 = v2 != 0LL;

  return v3;
}

void sub_10006077C(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  uint64_t v6 = v5;
  if (a1)
  {
    id v7 = sub_1000850A0(v5, (uint64_t)@"MKBUserSessionHomeDir");
    unsigned int v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
    if (!v8)
    {
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      id v10 = (os_log_s *)(id)qword_1000DBB60;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)id v45 = 0LL;
        unsigned int v20 = sub_100053B4C(1);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v21 = v20;
        }
        else {
          uint64_t v21 = v20 & 0xFFFFFFFE;
        }
        if ((_DWORD)v21)
        {
          LOWORD(v46) = 0;
          uint64_t v22 = (const char *)_os_log_send_and_compose_impl( v21,  v45,  0LL,  0LL,  &_mh_execute_header,  v10,  0LL,  "DEVICE node with no home directory path",  &v46,  2);
          unsigned int v23 = (char *)v22;
          if (v22) {
            sub_100053B7C(v22);
          }
        }

        else
        {
          unsigned int v23 = 0LL;
        }

        free(v23);
      }

      goto LABEL_62;
    }

    id v9 = sub_1000850A0(v6, (uint64_t)@"UserPersonaUniqueString");
    id v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
    if ([*(id *)(a1 + 24) splitUserVolumeEnabled])
    {
      uint64_t v11 = sub_100017CFC((uint64_t)&OBJC_CLASS___NSUUID, v10);
      int v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
      id v13 = sub_1000850A0(v6, (uint64_t)@"MKBUserSessionVolumeDeviceNode");
      uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      unsigned int v15 = (os_log_s *)(id)qword_1000DBB60;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)id v45 = 0LL;
        unsigned int v16 = sub_100053B4C(1);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v17 = v16;
        }
        else {
          uint64_t v17 = v16 & 0xFFFFFFFE;
        }
        if ((_DWORD)v17)
        {
          LOWORD(v46) = 0;
          __int128 v18 = (const char *)_os_log_send_and_compose_impl( v17,  v45,  0LL,  0LL,  &_mh_execute_header,  v15,  0LL,  "Mapping volume mapping the path",  &v46,  2);
          __int128 v19 = (char *)v18;
          if (v18) {
            sub_100053B7C(v18);
          }
        }

        else
        {
          __int128 v19 = 0LL;
        }

        free(v19);
      }

      id v31 = *(id *)(a1 + 16);
      uint64_t v32 = sub_100019B18((uint64_t)v31);
      __int128 v33 = (void *)objc_claimAutoreleasedReturnValue(v32);
      id v44 = 0LL;
      unsigned __int8 v34 = [v33 mapVolume:v14 toSession:a3 withPersona:v12 error:&v44];
      id v27 = v44;

      if ((v34 & 1) == 0)
      {
        if (qword_1000DBB68 != -1) {
          dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
        }
        uint64_t v38 = (os_log_s *)(id)qword_1000DBB60;
        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v46 = 0LL;
          unsigned int v39 = sub_100053B4C(1);
          if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v40 = v39;
          }
          else {
            uint64_t v40 = v39 & 0xFFFFFFFE;
          }
          if ((_DWORD)v40)
          {
            *(_DWORD *)id v45 = 138412290;
            *(void *)&v45[4] = v27;
            LODWORD(v43) = 12;
            unsigned int v41 = (const char *)_os_log_send_and_compose_impl( v40,  &v46,  0LL,  0LL,  &_mh_execute_header,  v38,  0LL,  "VolumeMap of persona volume failed with Error: %@",  v45,  v43);
            uint64_t v42 = (char *)v41;
            if (v41) {
              sub_100053B7C(v41);
            }
          }

          else
          {
            uint64_t v42 = 0LL;
          }

          free(v42);
        }

        goto LABEL_61;
      }
    }

    else
    {
      uint64_t v24 = sub_1000197A0(*(void *)(a1 + 16));
      uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(v24);
      unsigned int v26 = [v25 setVolumePath:v8 forPersona:v10];

      if (v26)
      {
        if (qword_1000DBB68 != -1) {
          dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
        }
        id v27 = (id)qword_1000DBB60;
        if (!os_log_type_enabled((os_log_t)v27, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_61;
        }
        *(void *)id v45 = 0LL;
        unsigned int v28 = sub_100053B4C(1);
        if (os_log_type_enabled((os_log_t)v27, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v29 = v28;
        }
        else {
          uint64_t v29 = v28 & 0xFFFFFFFE;
        }
        if ((_DWORD)v29)
        {
          LODWORD(v46) = 67109120;
          HIDWORD(v46) = v26;
          __int128 v30 = (const char *)_os_log_send_and_compose_impl( v29,  v45,  0LL,  0LL,  &_mh_execute_header,  v27,  0LL,  "failed to Setup keybag for Persona w: %d",  &v46);
          goto LABEL_45;
        }

LABEL_56:
        __int128 v37 = 0LL;
LABEL_57:
        free(v37);
LABEL_61:

LABEL_62:
        goto LABEL_63;
      }
    }

    if (qword_1000DBB68 != -1) {
      dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
    }
    id v27 = (id)qword_1000DBB60;
    if (!os_log_type_enabled((os_log_t)v27, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_61;
    }
    *(void *)id v45 = 0LL;
    unsigned int v35 = sub_100053B4C(1);
    if (os_log_type_enabled((os_log_t)v27, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v36 = v35;
    }
    else {
      uint64_t v36 = v35 & 0xFFFFFFFE;
    }
    if ((_DWORD)v36)
    {
      LOWORD(v46) = 0;
      __int128 v30 = (const char *)_os_log_send_and_compose_impl( v36,  v45,  0LL,  0LL,  &_mh_execute_header,  v27,  0LL,  "Setup a keybag for the user");
LABEL_45:
      __int128 v37 = (char *)v30;
      if (v30) {
        sub_100053B7C(v30);
      }
      goto LABEL_57;
    }

    goto LABEL_56;
  }

uint64_t sub_100060CF0(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  uint64_t v6 = v5;
  if (!a1)
  {
    uint64_t v9 = 0LL;
    goto LABEL_109;
  }

  id v7 = sub_100084F14(v5, (uint64_t)@"UserPersonaID", (id)0xFFFFFFFFLL);
  unsigned int v8 = sub_100084F14(v6, (uint64_t)@"UserPersonaType", (id)0x3E8);
  if (v8 != 4)
  {
    unsigned int v10 = v8;
    if (qword_1000DBB68 != -1) {
      dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
    }
    uint64_t v11 = (os_log_s *)(id)qword_1000DBB60;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v66 = 0LL;
      unsigned int v12 = sub_100053B4C(1);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG)) {
        uint64_t v13 = v12;
      }
      else {
        uint64_t v13 = v12 & 0xFFFFFFFE;
      }
      if ((_DWORD)v13)
      {
        LODWORD(v63) = 67109376;
        HIDWORD(v63) = (_DWORD)v7;
        __int16 v64 = 1024;
        unsigned int v65 = v10;
        uint64_t v14 = (const char *)_os_log_send_and_compose_impl( v13,  &v66,  0LL,  0LL,  &_mh_execute_header,  v11,  2LL,  "FOUND Persona with id:%u and type:%u, loading to kernel",  &v63,  14);
        unsigned int v15 = (char *)v14;
        if (v14) {
          sub_100053B7C(v14);
        }
      }

      else
      {
        unsigned int v15 = 0LL;
      }

      free(v15);
    }

    if (sub_100060454(a1, (uint64_t)v7))
    {
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      unsigned int v16 = (os_log_s *)(id)qword_1000DBB60;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v63 = 0LL;
        unsigned int v17 = sub_100053B4C(1);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v18 = v17;
        }
        else {
          uint64_t v18 = v17 & 0xFFFFFFFE;
        }
        if ((_DWORD)v18)
        {
          LODWORD(v66) = 67109120;
          HIDWORD(v66) = (_DWORD)v7;
          __int128 v19 = (const char *)_os_log_send_and_compose_impl( v18,  &v63,  0LL,  0LL,  &_mh_execute_header,  v16,  0LL,  "PersonaID:%u is already loaded to kernel, skipping..",  &v66);
          unsigned int v20 = (char *)v19;
          if (v19) {
            sub_100053B7C(v19);
          }
        }

        else
        {
          unsigned int v20 = 0LL;
        }

        free(v20);
      }

      uint64_t v9 = 1LL;
      goto LABEL_108;
    }

    if (qword_1000DBB68 != -1) {
      dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
    }
    uint64_t v21 = (os_log_s *)(id)qword_1000DBB60;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v63 = 0LL;
      unsigned int v22 = sub_100053B4C(1);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v23 = v22;
      }
      else {
        uint64_t v23 = v22 & 0xFFFFFFFE;
      }
      if ((_DWORD)v23)
      {
        LODWORD(v66) = 67109120;
        HIDWORD(v66) = (_DWORD)v7;
        uint64_t v24 = (const char *)_os_log_send_and_compose_impl( v23,  &v63,  0LL,  0LL,  &_mh_execute_header,  v21,  0LL,  "PersonaID:%u not loaded, loading..",  &v66);
        uint64_t v25 = (char *)v24;
        if (v24) {
          sub_100053B7C(v24);
        }
      }

      else
      {
        uint64_t v25 = 0LL;
      }

      free(v25);
    }

    if (!v10)
    {
      unsigned int v26 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:@"UserPersonaObserverService"]);

      if (v26)
      {
        [v6 setObject:0 forKeyedSubscript:@"UserPersonaObserverService"];
        if (qword_1000DBB68 != -1) {
          dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
        }
        id v27 = (os_log_s *)(id)qword_1000DBB60;
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v63 = 0LL;
          unsigned int v28 = sub_100053B4C(1);
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG)) {
            uint64_t v29 = v28;
          }
          else {
            uint64_t v29 = v28 & 0xFFFFFFFE;
          }
          if ((_DWORD)v29)
          {
            LOWORD(v66) = 0;
            LODWORD(v61) = 2;
            __int128 v30 = (const char *)_os_log_send_and_compose_impl( v29,  &v63,  0LL,  0LL,  &_mh_execute_header,  v27,  2LL,  "removed personaObservers",  &v66,  v61);
            id v31 = (char *)v30;
            if (v30) {
              sub_100053B7C(v30);
            }
          }

          else
          {
            id v31 = 0LL;
          }

          free(v31);
        }

        sub_10005B2D0(a1);
      }
    }

    id v62 = 0LL;
    uint64_t v9 = sub_10005E240(a1, v6, &v62);
    unsigned int v16 = (os_log_s *)v62;
    if ((v9 & 1) != 0)
    {
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      uint64_t v32 = (os_log_s *)(id)qword_1000DBB60;
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v63 = 0LL;
        unsigned int v33 = sub_100053B4C(1);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG)) {
          uint64_t v34 = v33;
        }
        else {
          uint64_t v34 = v33 & 0xFFFFFFFE;
        }
        if ((_DWORD)v34)
        {
          LODWORD(v66) = 67109120;
          HIDWORD(v66) = (_DWORD)v7;
          unsigned int v35 = (const char *)_os_log_send_and_compose_impl( v34,  &v63,  0LL,  0LL,  &_mh_execute_header,  v32,  2LL,  "Loaded PersonaID:%u to Kernel",  &v66);
          uint64_t v36 = (char *)v35;
          if (v35) {
            sub_100053B7C(v35);
          }
        }

        else
        {
          uint64_t v36 = 0LL;
        }

        free(v36);
      }

      uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:@"MKBUserSessionVolumeDeviceNode"]);
      if (!v42) {
        goto LABEL_108;
      }
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      uint64_t v43 = (os_log_s *)(id)qword_1000DBB60;
      if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v63 = 0LL;
        unsigned int v44 = sub_100053B4C(1);
        if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v45 = v44;
        }
        else {
          uint64_t v45 = v44 & 0xFFFFFFFE;
        }
        if ((_DWORD)v45)
        {
          LOWORD(v66) = 0;
          LODWORD(v61) = 2;
          uint64_t v46 = (const char *)_os_log_send_and_compose_impl( v45,  &v63,  0LL,  0LL,  &_mh_execute_header,  v43,  0LL,  "Mounting persona volume...",  &v66,  v61);
          unsigned int v47 = (char *)v46;
          if (v46) {
            sub_100053B7C(v46);
          }
        }

        else
        {
          unsigned int v47 = 0LL;
        }

        free(v47);
      }

      if ([*(id *)(a1 + 24) mountVolumeWithSession:v6 mountPath:0 error:0 forPersona:1])
      {
        if (qword_1000DBB68 != -1) {
          dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
        }
        unsigned int v48 = (os_log_s *)(id)qword_1000DBB60;
        if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v63 = 0LL;
          unsigned int v49 = sub_100053B4C(1);
          if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v50 = v49;
          }
          else {
            uint64_t v50 = v49 & 0xFFFFFFFE;
          }
          if ((_DWORD)v50)
          {
            LOWORD(v66) = 0;
            LODWORD(v61) = 2;
            uint64_t v51 = (const char *)_os_log_send_and_compose_impl( v50,  &v63,  0LL,  0LL,  &_mh_execute_header,  v48,  0LL,  "APFSUser Volume mounted at home directory",  &v66,  v61);
            int v52 = (char *)v51;
            if (v51) {
              sub_100053B7C(v51);
            }
          }

          else
          {
            int v52 = 0LL;
          }

          free(v52);
        }

        if (qword_1000DBB68 != -1) {
          dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
        }
        uint64_t v56 = (os_log_s *)(id)qword_1000DBB60;
        if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v63 = 0LL;
          unsigned int v57 = sub_100053B4C(1);
          if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v58 = v57;
          }
          else {
            uint64_t v58 = v57 & 0xFFFFFFFE;
          }
          if ((_DWORD)v58)
          {
            LOWORD(v66) = 0;
            LODWORD(v61) = 2;
            unsigned int v59 = (const char *)_os_log_send_and_compose_impl( v58,  &v63,  0LL,  0LL,  &_mh_execute_header,  v56,  0LL,  "Setting up persona keybag...",  &v66,  v61);
            unsigned int v60 = (char *)v59;
            if (v59) {
              sub_100053B7C(v59);
            }
          }

          else
          {
            unsigned int v60 = 0LL;
          }

          free(v60);
        }

        sub_10006077C(a1, v6, a3);
        goto LABEL_108;
      }

      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      __int128 v37 = (os_log_s *)(id)qword_1000DBB60;
      if (!os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_107;
      }
      uint64_t v63 = 0LL;
      unsigned int v53 = sub_100053B4C(1);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v54 = v53;
      }
      else {
        uint64_t v54 = v53 & 0xFFFFFFFE;
      }
      if ((_DWORD)v54)
      {
        LOWORD(v66) = 0;
        LODWORD(v61) = 2;
        unsigned int v41 = (void *)_os_log_send_and_compose_impl( v54,  &v63,  0LL,  0LL,  &_mh_execute_header,  v37,  0LL,  "APFSUser Volume failed to mount",  &v66,  v61);
        if (!v41)
        {
LABEL_106:
          free(v41);
LABEL_107:

LABEL_108:
          goto LABEL_109;
        }

uint64_t sub_1000616A4(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  uint64_t v6 = v5;
  if (a1)
  {
    if ([v5 count])
    {
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      id v7 = (os_log_s *)(id)qword_1000DBB60;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v24 = 0LL;
        unsigned int v8 = sub_100053B4C(1);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG)) {
          uint64_t v9 = v8;
        }
        else {
          uint64_t v9 = v8 & 0xFFFFFFFE;
        }
        if ((_DWORD)v9)
        {
          v23[0] = 0;
          unsigned int v10 = (const char *)_os_log_send_and_compose_impl( v9,  &v24,  0LL,  0LL,  &_mh_execute_header,  v7,  2LL,  "Setting up persona info to Kernel",  v23,  2);
          uint64_t v11 = (char *)v10;
          if (v10) {
            sub_100053B7C(v10);
          }
        }

        else
        {
          uint64_t v11 = 0LL;
        }

        free(v11);
      }

      __int128 v21 = 0u;
      __int128 v22 = 0u;
      __int128 v19 = 0u;
      __int128 v20 = 0u;
      id v13 = v6;
      id v14 = [v13 countByEnumeratingWithState:&v19 objects:v25 count:16];
      if (v14)
      {
        id v15 = v14;
        uint64_t v16 = *(void *)v20;
        LODWORD(v12) = 1;
        do
        {
          for (uint64_t i = 0LL; i != v15; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v20 != v16) {
              objc_enumerationMutation(v13);
            }
            uint64_t v12 = sub_100060CF0(a1, *(void **)(*((void *)&v19 + 1) + 8LL * (void)i), a3) & v12;
          }

          id v15 = [v13 countByEnumeratingWithState:&v19 objects:v25 count:16];
        }

        while (v15);
      }

      else
      {
        uint64_t v12 = 1LL;
      }
    }

    else
    {
      uint64_t v12 = 1LL;
    }
  }

  else
  {
    uint64_t v12 = 0LL;
  }

  return v12;
}

void sub_1000618B8(id *a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  if (a1)
  {
    id v6 = a1[4];
    id v7 = (void *)objc_claimAutoreleasedReturnValue([v6 userPersonas]);
    unsigned int v8 = (void *)objc_claimAutoreleasedReturnValue([v7 objectForKeyedSubscript:v5]);

    if (!v8)
    {
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      uint64_t v9 = (os_log_s *)(id)qword_1000DBB60;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        v25[0] = 0LL;
        unsigned int v10 = sub_100053B4C(1);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v11 = v10;
        }
        else {
          uint64_t v11 = v10 & 0xFFFFFFFE;
        }
        if ((_DWORD)v11)
        {
          *(_DWORD *)unsigned int v26 = 138412290;
          *(void *)&v26[4] = v5;
          uint64_t v12 = (const char *)_os_log_send_and_compose_impl( v11,  v25,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "No personas for user %@ found, creating new set of default personas",  v26,  12);
          id v13 = (char *)v12;
          if (v12) {
            sub_100053B7C(v12);
          }
        }

        else
        {
          id v13 = 0LL;
        }

        free(v13);
      }

      sub_10005A8C0(a1, v5);
    }

    id v14 = a1[4];
    id v15 = (void *)objc_claimAutoreleasedReturnValue([v14 userPersonas]);
    uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v15 objectForKeyedSubscript:v5]);

    if (sub_1000616A4((uint64_t)a1, v16, a3))
    {
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      unsigned int v17 = (os_log_s *)(id)qword_1000DBB60;
      if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_36;
      }
      *(void *)unsigned int v26 = 0LL;
      unsigned int v18 = sub_100053B4C(1);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v19 = v18;
      }
      else {
        uint64_t v19 = v18 & 0xFFFFFFFE;
      }
      if ((_DWORD)v19)
      {
        LOWORD(v25[0]) = 0;
        LODWORD(v24) = 2;
        __int128 v20 = (const char *)_os_log_send_and_compose_impl( v19,  v26,  0LL,  0LL,  &_mh_execute_header,  v17,  0LL,  "setup kernel personas",  v25,  v24,  v25[0]);
        goto LABEL_32;
      }
    }

    else
    {
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      unsigned int v17 = (os_log_s *)(id)qword_1000DBB60;
      if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_36;
      }
      *(void *)unsigned int v26 = 0LL;
      unsigned int v21 = sub_100053B4C(1);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v22 = v21;
      }
      else {
        uint64_t v22 = v21 & 0xFFFFFFFE;
      }
      if ((_DWORD)v22)
      {
        LOWORD(v25[0]) = 0;
        LODWORD(v24) = 2;
        __int128 v20 = (const char *)_os_log_send_and_compose_impl( v22,  v26,  0LL,  0LL,  &_mh_execute_header,  v17,  0LL,  "Failed to Upload and setup persona to Kernel",  v25,  v24,  v25[0]);
LABEL_32:
        uint64_t v23 = (char *)v20;
        if (v20) {
          sub_100053B7C(v20);
        }
        goto LABEL_35;
      }
    }

    uint64_t v23 = 0LL;
LABEL_35:
    free(v23);
LABEL_36:

    sub_10005F068(a1, v16, v5);
  }
}

BOOL sub_100061C08(uint64_t a1, int a2)
{
  return a1 && a2 == 4;
}

uint64_t sub_100061C18(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (!a1)
  {
    uint64_t v19 = 0LL;
    goto LABEL_95;
  }

  unsigned int v5 = sub_100084F14(v3, (uint64_t)@"UserPersonaType", (id)0x3E8);
  p_name = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
  if (v5 == 4)
  {
    if (qword_1000DBB68 != -1) {
      dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
    }
    id v7 = (os_log_s *)(id)qword_1000DBB60;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v48 = 0LL;
      unsigned int v8 = sub_100053B4C(1);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v9 = v8;
      }
      else {
        uint64_t v9 = v8 & 0xFFFFFFFE;
      }
      if ((_DWORD)v9)
      {
        LOWORD(v51) = 0;
        unsigned int v10 = (const char *)_os_log_send_and_compose_impl( v9,  &v48,  0LL,  0LL,  &_mh_execute_header,  v7,  0LL,  "Skipping unloading of Universal persona",  &v51,  2);
        uint64_t v11 = (char *)v10;
        if (v10) {
          sub_100053B7C(v10);
        }
      }

      else
      {
        uint64_t v11 = 0LL;
      }

      free(v11);
    }

    uint64_t v19 = 1LL;
    goto LABEL_94;
  }

  unsigned int v12 = v5;
  unsigned int v13 = sub_100084F14(v4, (uint64_t)@"UserPersonaID", (id)0xFFFFFFFFLL);
  if (qword_1000DBB68 != -1) {
    dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
  }
  id v14 = (os_log_s *)(id)qword_1000DBB60;
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v51 = 0LL;
    unsigned int v15 = sub_100053B4C(1);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v15 & 0xFFFFFFFE;
    }
    if ((_DWORD)v16)
    {
      LODWORD(v4_Block_object_dispose(va, 8) = 67109376;
      HIDWORD(v4_Block_object_dispose(va, 8) = v13;
      __int16 v49 = 1024;
      unsigned int v50 = v12;
      unsigned int v17 = (const char *)_os_log_send_and_compose_impl( v16,  &v51,  0LL,  0LL,  &_mh_execute_header,  v14,  0LL,  "Removing Persona with id:%u and type:%u, deallocating from kernel",  &v48,  14);
      unsigned int v18 = (char *)v17;
      if (v17) {
        sub_100053B7C(v17);
      }
    }

    else
    {
      unsigned int v18 = 0LL;
    }

    free(v18);
  }

  id v47 = 0LL;
  uint64_t v19 = sub_10005EDF4(a1, v4, &v47);
  id v7 = (os_log_s *)v47;
  if ((v19 & 1) != 0)
  {
    if (qword_1000DBB68 != -1) {
      dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
    }
    __int128 v20 = (os_log_s *)(id)qword_1000DBB60;
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v48 = 0LL;
      unsigned int v21 = sub_100053B4C(1);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v22 = v21;
      }
      else {
        uint64_t v22 = v21 & 0xFFFFFFFE;
      }
      if ((_DWORD)v22)
      {
        LODWORD(v51) = 67109120;
        HIDWORD(v51) = v13;
        uint64_t v23 = (const char *)_os_log_send_and_compose_impl( v22,  &v48,  0LL,  0LL,  &_mh_execute_header,  v20,  0LL,  "Unloaded PersonaID:%u from Kernel",  &v51);
        uint64_t v24 = (char *)v23;
        if (v23) {
          sub_100053B7C(v23);
        }
        goto LABEL_47;
      }

LABEL_46:
      uint64_t v24 = 0LL;
LABEL_47:
      free(v24);
    }
  }

  else
  {
    if (qword_1000DBB68 != -1) {
      dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
    }
    __int128 v20 = (os_log_s *)(id)qword_1000DBB60;
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v51 = 0LL;
      LODWORD(v25) = sub_100053B4C(1);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v25 = v25;
      }
      else {
        uint64_t v25 = v25 & 0xFFFFFFFE;
      }
      if ((_DWORD)v25)
      {
        unsigned int v26 = v20;
        unsigned int v27 = -[os_log_s code](v7, "code");
        LODWORD(v4_Block_object_dispose(va, 8) = 67109376;
        HIDWORD(v4_Block_object_dispose(va, 8) = v13;
        __int16 v49 = 1024;
        unsigned int v50 = v27;
        LODWORD(v46) = 14;
        uint64_t v24 = (char *)_os_log_send_and_compose_impl( v25,  &v51,  0LL,  0LL,  &_mh_execute_header,  v26,  0LL,  "FAILED TO UNLOAD PERSONA from KERNEL %u with error %{darwin.errno}d",  &v48,  v46);

        if (v24) {
          sub_100053B7C(v24);
        }
        p_name = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
        goto LABEL_47;
      }

      goto LABEL_46;
    }
  }

  if ((v12 & 0xFFFFFFFB) != 2) {
    goto LABEL_94;
  }
  if (qword_1000DBB68 != -1) {
    dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
  }
  unsigned int v28 = p_name[364];
  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v48 = 0LL;
    unsigned int v29 = sub_100053B4C(1);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v30 = v29;
    }
    else {
      uint64_t v30 = v29 & 0xFFFFFFFE;
    }
    if ((_DWORD)v30)
    {
      LOWORD(v51) = 0;
      LODWORD(v46) = 2;
      id v31 = (const char *)_os_log_send_and_compose_impl( v30,  &v48,  0LL,  0LL,  &_mh_execute_header,  v28,  0LL,  "Checking if the volume mounted and unmount",  &v51,  v46);
      uint64_t v32 = (char *)v31;
      if (v31) {
        sub_100053B7C(v31);
      }
    }

    else
    {
      uint64_t v32 = 0LL;
    }

    free(v32);
  }

  if (qword_1000DBB68 != -1) {
    dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
  }
  unsigned int v33 = p_name[364];
  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v48 = 0LL;
    unsigned int v34 = sub_100053B4C(1);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v35 = v34;
    }
    else {
      uint64_t v35 = v34 & 0xFFFFFFFE;
    }
    if ((_DWORD)v35)
    {
      LOWORD(v51) = 0;
      LODWORD(v46) = 2;
      uint64_t v36 = (const char *)_os_log_send_and_compose_impl( v35,  &v48,  0LL,  0LL,  &_mh_execute_header,  v33,  0LL,  "Persona volume mounted, unmounting",  &v51,  v46);
      __int128 v37 = (char *)v36;
      if (v36) {
        sub_100053B7C(v36);
      }
    }

    else
    {
      __int128 v37 = 0LL;
    }

    free(v37);
  }

  if ([*(id *)(a1 + 24) unmountVolumeWithSession:v4 mountPath:0 error:0])
  {
    if (qword_1000DBB68 != -1) {
      dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
    }
    uint64_t v38 = p_name[364];
    if (!os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_93;
    }
    uint64_t v48 = 0LL;
    unsigned int v39 = sub_100053B4C(1);
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v40 = v39;
    }
    else {
      uint64_t v40 = v39 & 0xFFFFFFFE;
    }
    if ((_DWORD)v40)
    {
      LOWORD(v51) = 0;
      LODWORD(v46) = 2;
      unsigned int v41 = (const char *)_os_log_send_and_compose_impl( v40,  &v48,  0LL,  0LL,  &_mh_execute_header,  v38,  0LL,  "Persona volume unmounted",  &v51,  v46);
      goto LABEL_89;
    }
  }

  else
  {
    if (qword_1000DBB68 != -1) {
      dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
    }
    uint64_t v38 = p_name[364];
    if (!os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_93;
    }
    uint64_t v48 = 0LL;
    unsigned int v42 = sub_100053B4C(1);
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v43 = v42;
    }
    else {
      uint64_t v43 = v42 & 0xFFFFFFFE;
    }
    if ((_DWORD)v43)
    {
      LOWORD(v51) = 0;
      LODWORD(v46) = 2;
      unsigned int v41 = (const char *)_os_log_send_and_compose_impl( v43,  &v48,  0LL,  0LL,  &_mh_execute_header,  v38,  0LL,  "Persona volume failed to unmount",  &v51,  v46);
LABEL_89:
      unsigned int v44 = (char *)v41;
      if (v41) {
        sub_100053B7C(v41);
      }
      goto LABEL_92;
    }
  }

  unsigned int v44 = 0LL;
LABEL_92:
  free(v44);
LABEL_93:

LABEL_94:
LABEL_95:

  return v19;
}

  if ((a3 & 8) != 0) {
LABEL_47:
  }
    memset_s(__s, 0x20uLL, 0, 0x20uLL);
LABEL_48:
  memset_s(&v40, 0x40uLL, 0, 0x40uLL);
  return v8;
}

uint64_t sub_10006238C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (!a1)
  {
    uint64_t v34 = 0LL;
    goto LABEL_69;
  }

  if (qword_1000DBB68 != -1) {
    dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
  }
  id v4 = (os_log_s *)(id)qword_1000DBB60;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v41[0] = 0LL;
    unsigned int v5 = sub_100053B4C(1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = v5 & 0xFFFFFFFE;
    }
    if ((_DWORD)v6)
    {
      *(_DWORD *)uint64_t v43 = 138412290;
      *(void *)&v43[4] = v3;
      id v7 = (const char *)_os_log_send_and_compose_impl( v6,  v41,  0LL,  0LL,  &_mh_execute_header,  v4,  0LL,  "Unloading kernel personas for user:%@",  v43,  12);
      unsigned int v8 = (char *)v7;
      if (v7) {
        sub_100053B7C(v7);
      }
    }

    else
    {
      unsigned int v8 = 0LL;
    }

    free(v8);
  }

  id v9 = *(id *)(a1 + 32);
  unsigned int v10 = (void *)objc_claimAutoreleasedReturnValue([v9 userPersonas]);
  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v10 objectForKeyedSubscript:v3]);

  if (!v11)
  {
    if (qword_1000DBB68 != -1) {
      dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
    }
    unsigned int v18 = (os_log_s *)(id)qword_1000DBB60;
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_64;
    }
    v41[0] = 0LL;
    unsigned int v19 = sub_100053B4C(1);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v20 = v19;
    }
    else {
      uint64_t v20 = v19 & 0xFFFFFFFE;
    }
    if ((_DWORD)v20)
    {
      *(_DWORD *)uint64_t v43 = 138412290;
      *(void *)&v43[4] = v3;
      LODWORD(v36) = 12;
      unsigned int v21 = (const char *)_os_log_send_and_compose_impl( v20,  v41,  0LL,  0LL,  &_mh_execute_header,  v18,  0LL,  "No personas found for user %@",  v43,  v36);
      goto LABEL_60;
    }

void sub_1000628D0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    if (v3)
    {
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      unsigned int v5 = (os_log_s *)(id)qword_1000DBB60;
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        v31[0] = 0LL;
        LODWORD(v6) = sub_100053B4C(1);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v6 = v6;
        }
        else {
          uint64_t v6 = v6 & 0xFFFFFFFE;
        }
        if ((_DWORD)v6)
        {
          id v7 = v5;
          *(_DWORD *)uint64_t v32 = 134217984;
          *(void *)&v32[4] = [v4 count];
          unsigned int v8 = (char *)_os_log_send_and_compose_impl( v6,  v31,  0LL,  0LL,  &_mh_execute_header,  v7,  0LL,  "PRINTING ALL %lu Entries of PERSONASESSION",  v32);

          if (v8) {
            sub_100053B7C(v8);
          }
        }

        else
        {
          unsigned int v8 = 0LL;
        }

        free(v8);
      }

      __int128 v29 = 0u;
      __int128 v30 = 0u;
      __int128 v27 = 0u;
      __int128 v28 = 0u;
      id v9 = v4;
      id v14 = [v9 countByEnumeratingWithState:&v27 objects:v33 count:16];
      if (v14)
      {
        id v15 = v14;
        unsigned int v26 = v4;
        int v16 = 0;
        uint64_t v17 = *(void *)v28;
        do
        {
          unsigned int v18 = 0LL;
          do
          {
            if (*(void *)v28 != v17) {
              objc_enumerationMutation(v9);
            }
            uint64_t v19 = *(void *)(*((void *)&v27 + 1) + 8LL * (void)v18);
            if (qword_1000DBB68 != -1) {
              dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
            }
            uint64_t v20 = (os_log_s *)(id)qword_1000DBB60;
            if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
            {
              v31[0] = 0LL;
              unsigned int v21 = sub_100053B4C(1);
              if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v22 = v21;
              }
              else {
                uint64_t v22 = v21 & 0xFFFFFFFE;
              }
              if ((_DWORD)v22)
              {
                *(_DWORD *)uint64_t v32 = 67109378;
                *(_DWORD *)&v32[4] = v16 + (_DWORD)v18;
                *(_WORD *)&v32[8] = 2112;
                *(void *)&v32[10] = v19;
                LODWORD(v25) = 18;
                unsigned int v23 = (const char *)_os_log_send_and_compose_impl( v22,  v31,  0LL,  0LL,  &_mh_execute_header,  v20,  0LL,  "%d PersonaSession is %@",  v32,  v25);
                uint64_t v24 = (char *)v23;
                if (v23) {
                  sub_100053B7C(v23);
                }
              }

              else
              {
                uint64_t v24 = 0LL;
              }

              free(v24);
            }

            unsigned int v18 = (char *)v18 + 1;
          }

          while (v15 != v18);
          id v15 = [v9 countByEnumeratingWithState:&v27 objects:v33 count:16];
          v16 += (int)v18;
        }

        while (v15);
        id v4 = v26;
      }
    }

    else
    {
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      id v9 = (id)qword_1000DBB60;
      if (os_log_type_enabled((os_log_t)v9, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)uint64_t v32 = 0LL;
        unsigned int v10 = sub_100053B4C(1);
        if (os_log_type_enabled((os_log_t)v9, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v11 = v10;
        }
        else {
          uint64_t v11 = v10 & 0xFFFFFFFE;
        }
        if ((_DWORD)v11)
        {
          LOWORD(v31[0]) = 0;
          id v12 = (const char *)_os_log_send_and_compose_impl( v11,  v32,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "No persona sessions on disk",  v31,  2);
          id v13 = (char *)v12;
          if (v12) {
            sub_100053B7C(v12);
          }
        }

        else
        {
          id v13 = 0LL;
        }

        free(v13);
      }
    }
  }
}

uint64_t sub_100062C90(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) userPersonas]);
  BOOL v2 = (void *)objc_claimAutoreleasedReturnValue([v1 objectForKeyedSubscript:@"FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF"]);

  if (v2)
  {
    if ((unint64_t)[v2 count] <= 1)
    {
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      id v3 = (os_log_s *)(id)qword_1000DBB60;
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v25 = 0LL;
        LODWORD(v4) = sub_100053B4C(1);
        if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v4 = v4;
        }
        else {
          uint64_t v4 = v4 & 0xFFFFFFFE;
        }
        if ((_DWORD)v4)
        {
          unsigned int v5 = v3;
          v26[0] = 67109120;
          v26[1] = [v2 count];
          uint64_t v6 = (char *)_os_log_send_and_compose_impl( v4,  &v25,  0LL,  0LL,  &_mh_execute_header,  v5,  0LL,  "Warning: System Session personas exist, but there are only %d of them",  v26);

          if (v6) {
            sub_100053B7C(v6);
          }
        }

        else
        {
          uint64_t v6 = 0LL;
        }

        free(v6);
      }

      uint64_t v7 = 1LL;
      goto LABEL_53;
    }

    unsigned int v8 = (void *)objc_claimAutoreleasedReturnValue([v2 objectAtIndexedSubscript:0]);
    id v3 = (os_log_s *)objc_claimAutoreleasedReturnValue([v8 objectForKeyedSubscript:@"UserPersonaType"]);

    id v9 = (void *)objc_claimAutoreleasedReturnValue([v2 objectAtIndexedSubscript:1]);
    unsigned int v10 = (void *)objc_claimAutoreleasedReturnValue([v9 objectForKeyedSubscript:@"UserPersonaType"]);

    uint64_t v11 = objc_opt_class(&OBJC_CLASS___NSNumber);
    if ((objc_opt_isKindOfClass(v3, v11) & 1) != 0
      && (uint64_t v12 = objc_opt_class(&OBJC_CLASS___NSNumber), (objc_opt_isKindOfClass(v10, v12) & 1) != 0))
    {
      unsigned int v13 = -[os_log_s unsignedIntValue](v3, "unsignedIntValue");
      unsigned int v14 = [v10 unsignedIntValue];
      if (v13 != 3 && v14 != 3)
      {
        if (qword_1000DBB68 != -1) {
          dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
        }
        id v15 = (os_log_s *)(id)qword_1000DBB60;
        if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_51;
        }
        uint64_t v25 = 0LL;
        unsigned int v16 = sub_100053B4C(1);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v17 = v16;
        }
        else {
          uint64_t v17 = v16 & 0xFFFFFFFE;
        }
        if ((_DWORD)v17)
        {
          LOWORD(v26[0]) = 0;
          unsigned int v18 = (const char *)_os_log_send_and_compose_impl( v17,  &v25,  0LL,  0LL,  &_mh_execute_header,  v15,  0LL,  "Warning: System Session personas exist, but neither of them is a System type",  v26,  2);
          goto LABEL_34;
        }

void sub_10006310C(id *a1)
{
  if (a1)
  {
    if (qword_1000DBB68 != -1) {
      dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
    }
    BOOL v2 = (os_log_s *)(id)qword_1000DBB60;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v30 = 0LL;
      unsigned int v3 = sub_100053B4C(1);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v4 = v3;
      }
      else {
        uint64_t v4 = v3 & 0xFFFFFFFE;
      }
      if ((_DWORD)v4)
      {
        LOWORD(v29) = 0;
        unsigned int v5 = (const char *)_os_log_send_and_compose_impl( v4,  &v30,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "Creating system session personas...",  &v29,  2);
        uint64_t v6 = (char *)v5;
        if (v5) {
          sub_100053B7C(v5);
        }
      }

      else
      {
        uint64_t v6 = 0LL;
      }

      free(v6);
    }

    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([a1[4] userPersonas]);
    unsigned int v8 = (void *)objc_claimAutoreleasedReturnValue([v7 objectForKeyedSubscript:@"FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF"]);

    if (!v8)
    {
      unsigned int v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
      id v9 = (void *)objc_claimAutoreleasedReturnValue([a1[4] userPersonas]);
      [v9 setObject:v8 forKeyedSubscript:@"FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF"];
    }

    unsigned int v10 = sub_10005AE10(a1, v8, 3LL, @"FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF");
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
    if (v11)
    {
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      uint64_t v12 = (os_log_s *)(id)qword_1000DBB60;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v30 = 0LL;
        unsigned int v13 = sub_100053B4C(1);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v14 = v13;
        }
        else {
          uint64_t v14 = v13 & 0xFFFFFFFE;
        }
        if ((_DWORD)v14)
        {
          LOWORD(v29) = 0;
          LODWORD(v2_Block_object_dispose(va, 8) = 2;
          id v15 = (const char *)_os_log_send_and_compose_impl( v14,  &v30,  0LL,  0LL,  &_mh_execute_header,  v12,  0LL,  "Created system session System persona",  &v29,  v28,  v29);
          goto LABEL_32;
        }

        goto LABEL_34;
      }
    }

    else
    {
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      uint64_t v12 = (os_log_s *)(id)qword_1000DBB60;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v30 = 0LL;
        unsigned int v16 = sub_100053B4C(1);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v17 = v16;
        }
        else {
          uint64_t v17 = v16 & 0xFFFFFFFE;
        }
        if ((_DWORD)v17)
        {
          LOWORD(v29) = 0;
          LODWORD(v2_Block_object_dispose(va, 8) = 2;
          id v15 = (const char *)_os_log_send_and_compose_impl( v17,  &v30,  0LL,  0LL,  &_mh_execute_header,  v12,  0LL,  "Failed to create system session System persona",  &v29,  v28,  v29);
LABEL_32:
          unsigned int v18 = (char *)v15;
          if (v15) {
            sub_100053B7C(v15);
          }
          goto LABEL_35;
        }

void sub_10006357C(uint64_t a1)
{
  if (a1)
  {
    BOOL v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) userPersonas]);
    unsigned int v3 = (void *)objc_claimAutoreleasedReturnValue([v2 objectForKeyedSubscript:@"FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF"]);

    if (v3)
    {
      if ((sub_1000616A4(a1, v3, 0LL) & 1) != 0)
      {
LABEL_25:

        return;
      }

      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      id v4 = (id)qword_1000DBB60;
      if (!os_log_type_enabled((os_log_t)v4, OS_LOG_TYPE_DEFAULT))
      {
LABEL_24:

        goto LABEL_25;
      }

      uint64_t v12 = 0LL;
      unsigned int v5 = sub_100053B4C(1);
      if (os_log_type_enabled((os_log_t)v4, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v6 = v5;
      }
      else {
        uint64_t v6 = v5 & 0xFFFFFFFE;
      }
      if ((_DWORD)v6)
      {
        LOWORD(v11) = 0;
        uint64_t v7 = (const char *)_os_log_send_and_compose_impl( v6,  &v12,  0LL,  0LL,  &_mh_execute_header,  v4,  0LL,  "Failed to load system session personas into kernel",  &v11,  2,  v11);
        goto LABEL_20;
      }
    }

    else
    {
      if (qword_1000DBB68 != -1) {
        dispatch_once(&qword_1000DBB68, &stru_1000CD6D0);
      }
      id v4 = (id)qword_1000DBB60;
      if (!os_log_type_enabled((os_log_t)v4, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_24;
      }
      uint64_t v12 = 0LL;
      unsigned int v8 = sub_100053B4C(1);
      if (os_log_type_enabled((os_log_t)v4, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v9 = v8;
      }
      else {
        uint64_t v9 = v8 & 0xFFFFFFFE;
      }
      if ((_DWORD)v9)
      {
        LOWORD(v11) = 0;
        uint64_t v7 = (const char *)_os_log_send_and_compose_impl( v9,  &v12,  0LL,  0LL,  &_mh_execute_header,  v4,  0LL,  "Failed to load system session personas into kernel: system session personas could not be found",  &v11,  2,  v11);
LABEL_20:
        unsigned int v10 = (char *)v7;
        if (v7) {
          sub_100053B7C(v7);
        }
        goto LABEL_23;
      }
    }

    unsigned int v10 = 0LL;
LABEL_23:
    free(v10);
    goto LABEL_24;
  }

void sub_100063758(uint64_t a1, void *a2)
{
  if (a1)
  {
    unsigned int v3 = (void *)objc_claimAutoreleasedReturnValue([a2 objectForKeyedSubscript:@"MKBUserSessionHomeDir"]);
    if (v3)
    {
      if (qword_1000DBB58 != -1) {
        dispatch_once(&qword_1000DBB58, &stru_1000CD6B0);
      }
      id v4 = (os_log_s *)(id)qword_1000DBB50;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
      {
        v43[0] = 0LL;
        unsigned int v5 = sub_100053B4C(0);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO)) {
          uint64_t v6 = v5;
        }
        else {
          uint64_t v6 = v5 & 0xFFFFFFFE;
        }
        if ((_DWORD)v6)
        {
          *(_DWORD *)uint64_t v45 = 138543362;
          *(void *)&v45[4] = v3;
          uint64_t v7 = (const char *)_os_log_send_and_compose_impl( v6,  v43,  0LL,  0LL,  &_mh_execute_header,  v4,  1LL,  "Finding processes using persona volume: %{public}@...",  v45,  12);
          unsigned int v8 = (char *)v7;
          if (v7) {
            sub_100053B7C(v7);
          }
        }

        else
        {
          unsigned int v8 = 0LL;
        }

        free(v8);
      }

      id v14 = *(id *)(a1 + 16);
      uint64_t v15 = sub_100018F4C((uint64_t)v14);
      unsigned int v16 = (void *)objc_claimAutoreleasedReturnValue(v15);
      id v9 = (id)objc_claimAutoreleasedReturnValue([v16 pidsUsingVolumeAtPath:v3 error:0]);

      if (v9)
      {
        if (qword_1000DBB58 != -1) {
          dispatch_once(&qword_1000DBB58, &stru_1000CD6B0);
        }
        uint64_t v17 = (os_log_s *)(id)qword_1000DBB50;
        if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
        {
          v43[0] = 0LL;
          LODWORD(v1_Block_object_dispose(va, 8) = sub_100053B4C(0);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO)) {
            uint64_t v18 = v18;
          }
          else {
            uint64_t v18 = v18 & 0xFFFFFFFE;
          }
          if ((_DWORD)v18)
          {
            unsigned int v19 = v17;
            id v20 = [v9 count];
            *(_DWORD *)uint64_t v45 = 134217984;
            *(void *)&v45[4] = v20;
            unsigned int v21 = (char *)_os_log_send_and_compose_impl( v18,  v43,  0LL,  0LL,  &_mh_execute_header,  v19,  1LL,  "... found %lu processes.",  v45);

            if (v21) {
              sub_100053B7C(v21);
            }
          }

          else
          {
            unsigned int v21 = 0LL;
          }

          free(v21);
        }

        uint64_t v27 = sub_100018F4C(*(void *)(a1 + 16));
        uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(v27);
        unsigned int v29 = [v28 currentPID];

        __int128 v41 = 0u;
        __int128 v42 = 0u;
        __int128 v39 = 0u;
        __int128 v40 = 0u;
        id v9 = v9;
        id v30 = [v9 countByEnumeratingWithState:&v39 objects:v44 count:16];
        if (v30)
        {
          id v31 = v30;
          uint64_t v32 = *(void *)v40;
          do
          {
            for (uint64_t i = 0LL; i != v31; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v40 != v32) {
                objc_enumerationMutation(v9);
              }
              id v34 = [*(id *)(*((void *)&v39 + 1) + 8 * (void)i) intValue];
              if ((v34 & 0x80000000) == 0)
              {
                id v35 = v34;
                if ((_DWORD)v34 != v29)
                {
                  uint64_t v36 = sub_100018F4C(*(void *)(a1 + 16));
                  __int128 v37 = (void *)objc_claimAutoreleasedReturnValue(v36);
                  [v37 terminatePID:v35 withReasonNamespace:26 reasonCode:4008636142 reasonString:@"This process has files open on a profile volume that is being uninstalled" error:0];
                }
              }
            }

            id v31 = [v9 countByEnumeratingWithState:&v39 objects:v44 count:16];
          }

          while (v31);
        }
      }

      else
      {
        if (qword_1000DBB58 != -1) {
          dispatch_once(&qword_1000DBB58, &stru_1000CD6B0);
        }
        unsigned int v22 = (os_log_s *)(id)qword_1000DBB50;
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          *(void *)uint64_t v45 = 0LL;
          unsigned int v23 = sub_100053B4C(0);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = v23 & 0xFFFFFFFE;
          }
          if ((_DWORD)v24)
          {
            LOWORD(v43[0]) = 0;
            LODWORD(v3_Block_object_dispose(va, 8) = 2;
            unsigned int v25 = (const char *)_os_log_send_and_compose_impl( v24,  v45,  0LL,  0LL,  &_mh_execute_header,  v22,  16LL,  "Failed to terminate persona volume processes: Failed to get list of pids using persona volume",  v43,  v38);
            uint64_t v26 = (char *)v25;
            if (v25) {
              sub_100053B7C(v25);
            }
          }

          else
          {
            uint64_t v26 = 0LL;
          }

          free(v26);
        }
      }
    }

    else
    {
      if (qword_1000DBB58 != -1) {
        dispatch_once(&qword_1000DBB58, &stru_1000CD6B0);
      }
      id v9 = (id)qword_1000DBB50;
      if (os_log_type_enabled((os_log_t)v9, OS_LOG_TYPE_ERROR))
      {
        *(void *)uint64_t v45 = 0LL;
        unsigned int v10 = sub_100053B4C(0);
        if (os_log_type_enabled((os_log_t)v9, OS_LOG_TYPE_ERROR)) {
          uint64_t v11 = v10;
        }
        else {
          uint64_t v11 = v10 & 0xFFFFFFFE;
        }
        if ((_DWORD)v11)
        {
          LOWORD(v43[0]) = 0;
          uint64_t v12 = (const char *)_os_log_send_and_compose_impl( v11,  v45,  0LL,  0LL,  &_mh_execute_header,  v9,  16LL,  "Failed to terminate persona volume processes: Failed to get persona volume mount path",  v43,  2);
          unsigned int v13 = (char *)v12;
          if (v12) {
            sub_100053B7C(v12);
          }
        }

        else
        {
          unsigned int v13 = 0LL;
        }

        free(v13);
      }
    }
  }

void sub_100063CB0(id a1)
{
  os_log_t v1 = os_log_create(off_1000DAE70, "persona");
  BOOL v2 = (void *)qword_1000DBB50;
  qword_1000DBB50 = (uint64_t)v1;
}

void sub_100063CE4(id a1)
{
  os_log_t v1 = os_log_create(off_1000DAE70, "legacy");
  BOOL v2 = (void *)qword_1000DBB60;
  qword_1000DBB60 = (uint64_t)v1;
}

id *sub_100063D18(uint64_t a1, void *a2, void *a3, void *a4, int a5)
{
  id v9 = a2;
  objc_opt_self(a1);
  unsigned int v10 = sub_100063D8C((id *)objc_alloc(&OBJC_CLASS___UMDRotatingLog), v9, a3, a4, a5);

  return v10;
}

id *sub_100063D8C(id *a1, void *a2, void *a3, void *a4, int a5)
{
  id v10 = a2;
  if (a1)
  {
    v19.receiver = a1;
    v19.super_class = (Class)&OBJC_CLASS___UMDRotatingLog;
    uint64_t v11 = (id *)objc_msgSendSuper2(&v19, "init");
    if (!v11) {
      sub_1000A9AD0();
    }
    a1 = v11;

    objc_storeStrong(a1 + 3, a2);
    uint64_t v12 = sub_100018F4C((uint64_t)v10);
    unsigned int v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
    *((_DWORD *)a1 + 2) = [v13 currentPID];

    dispatch_queue_attr_t v14 = dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    uint64_t v15 = (dispatch_queue_attr_s *)objc_claimAutoreleasedReturnValue(v14);
    dispatch_queue_t v16 = dispatch_queue_create("com.apple.usermanagerd.RotatingLog", v15);
    id v17 = a1[4];
    a1[4] = v16;

    a1[5] = a3;
    a1[6] = a4;
    *((_DWORD *)a1 + 3) = -1;
    *((_DWORD *)a1 + 4) = a5;
  }

  return a1;
}

void sub_100063F0C(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    BOOL v2 = *(dispatch_queue_s **)(a1 + 32);
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472LL;
    v3[2] = sub_100063F68;
    v3[3] = &unk_1000CD710;
    void v3[4] = a1;
    void v3[5] = a2;
    dispatch_sync(v2, v3);
  }

void sub_100063F68(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2) {
    goto LABEL_9;
  }
  if (*(_DWORD *)(v2 + 12) == -1)
  {
    unsigned int v3 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s.0",  *(void *)(v2 + 40)));
    id v4 = *(void **)(a1 + 32);
    if (v4) {
      id v4 = (void *)v4[3];
    }
    unsigned int v5 = v4;
    uint64_t v6 = sub_100019434((uint64_t)v5);
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
    unsigned int v8 = [v7 openFileForAppendingAtPath:v3 error:0];
    uint64_t v9 = *(void *)(a1 + 32);
    if (v9) {
      *(_DWORD *)(v9 + 12) = v8;
    }

    uint64_t v2 = *(void *)(a1 + 32);
    if (!v2) {
      goto LABEL_9;
    }
  }

  if (*(_DWORD *)(v2 + 12) != -1)
  {
LABEL_9:
    ts.tv_sec = 0LL;
    ts.tv_nsec = 0LL;
    timespec_get(&ts, 1);
    memset(&v21, 0, sizeof(v21));
    gmtime_r(&ts.tv_sec, &v21);
    strftime(v23, 0x64uLL, "%F %T", &v21);
    uint64_t v10 = *(void *)(a1 + 32);
    if (v10) {
      uint64_t v11 = *(unsigned int *)(v10 + 8);
    }
    else {
      uint64_t v11 = 0LL;
    }
    uint64_t v12 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s.%06ldZ [%d] (%p) %s\n",  v23,  ts.tv_nsec / 1000,  v11,  pthread_self(),  *(void *)(a1 + 40));
    unsigned int v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
    dispatch_queue_attr_t v14 = *(void **)(a1 + 32);
    if (v14) {
      dispatch_queue_attr_t v14 = (void *)v14[3];
    }
    uint64_t v15 = v14;
    uint64_t v16 = sub_100019434((uint64_t)v15);
    id v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
    uint64_t v18 = v17;
    uint64_t v19 = *(void *)(a1 + 32);
    if (v19) {
      uint64_t v20 = *(unsigned int *)(v19 + 12);
    }
    else {
      uint64_t v20 = 0LL;
    }
    [v17 writeToFileWithDescriptor:v20 string:v13 error:0];

    if (sub_100064180(*(void *)(a1 + 32))) {
      sub_1000641E4(*(void *)(a1 + 32));
    }
  }

uint64_t sub_100064168(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 12);
  }
  return result;
}

uint64_t sub_100064174(uint64_t result, int a2)
{
  if (result) {
    *(_DWORD *)(result + 12) = a2;
  }
  return result;
}

BOOL sub_100064180(BOOL result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = sub_100019434(*(void *)(result + 24));
    unsigned int v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
    uint64_t v4 = (uint64_t)[v3 sizeOfFileWithDescriptor:*(unsigned int *)(v1 + 12) error:0];

    return (v4 & 0x8000000000000000LL) == 0 && v4 >= *(void *)(v1 + 48);
  }

  return result;
}

void sub_1000641E4(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = sub_100019434(*(void *)(a1 + 24));
    unsigned int v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
    [v3 closeFileWithDescriptor:*(unsigned int *)(a1 + 12)];

    *(_DWORD *)(a1 + 12) = -1;
    uint64_t v4 = (*(_DWORD *)(a1 + 16) - 1);
    if ((int)v4 >= 0)
    {
      do
      {
        int v5 = v4;
        uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s.%d",  *(void *)(a1 + 40),  v4));
        uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s.%d",  *(void *)(a1 + 40),  (v5 + 1)));
        uint64_t v8 = sub_100019434(*(void *)(a1 + 24));
        uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
        [v9 renameFileFromPath:v6 toPath:v7 error:0];

        uint64_t v4 = (v5 - 1);
      }

      while (v5);
    }
  }

uint64_t sub_1000642D4(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 16);
  }
  return result;
}

uint64_t sub_1000642E0(uint64_t result, uint64_t a2)
{
  if (result) {
    *(void *)(result + 40) = a2;
  }
  return result;
}

uint64_t sub_1000642EC(uint64_t result, uint64_t a2)
{
  if (result) {
    *(void *)(result + 4_Block_object_dispose(va, 8) = a2;
  }
  return result;
}

uint64_t sub_1000642F8(uint64_t result, int a2)
{
  if (result) {
    *(_DWORD *)(result + 16) = a2;
  }
  return result;
}

void sub_100064440(uint64_t a1)
{
  uint64_t v1 = objc_opt_class(*(void *)(a1 + 32));
  uint64_t v2 = objc_opt_new(v1);
  unsigned int v3 = (void *)qword_1000DBB70;
  qword_1000DBB70 = v2;
}

void sub_100064ED8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
}

uint64_t sub_100064F30(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_100064F40(uint64_t a1)
{
}

void sub_100064F48(uint64_t a1)
{
  int v22 = 0;
  uint64_t v2 = sub_100023D64(*(const __CFDictionary **)(a1 + 32), *(UInt8 **)(a1 + 64), *(void *)(a1 + 72), &v22);
  if (v2)
  {
    uint64_t v3 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) externalizeUserDictionary:v2]);
    uint64_t v4 = *(void *)(*(void *)(a1 + 48) + 8LL);
    int v5 = *(void **)(v4 + 40);
    *(void *)(v4 + 40) = v3;
  }

  uint64_t v6 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL);
  if (v6)
  {
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKey:kUMUserSessionIDKey]);
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v8 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = 0LL;
      LODWORD(v9) = sub_100053B4C(1);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v9 = v9;
      }
      else {
        uint64_t v9 = v9 & 0xFFFFFFFE;
      }
      if ((_DWORD)v9)
      {
        uint64_t v10 = v8;
        unsigned int v11 = [v7 intValue];
        int v23 = 67109120;
        int v24 = v11;
        uint64_t v12 = (char *)_os_log_send_and_compose_impl( v9,  &v21,  0LL,  0LL,  &_mh_execute_header,  v10,  0LL,  "Loaded User Session with ID %d",  &v23);

        if (v12) {
          sub_100053B7C(v12);
        }
      }

      else
      {
        uint64_t v12 = 0LL;
      }

      free(v12);
    }
  }

  if (v22)
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    unsigned int v13 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = 0LL;
      unsigned int v14 = sub_100053B4C(1);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v15 = v14;
      }
      else {
        uint64_t v15 = v14 & 0xFFFFFFFE;
      }
      if ((_DWORD)v15)
      {
        int v23 = 67109120;
        int v24 = v22;
        uint64_t v16 = (const char *)_os_log_send_and_compose_impl( v15,  &v21,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "Failed to load with error:%d",  &v23);
        id v17 = (char *)v16;
        if (v16) {
          sub_100053B7C(v16);
        }
      }

      else
      {
        id v17 = 0LL;
      }

      free(v17);
    }

    uint64_t v18 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  v22,  0LL));
    uint64_t v19 = *(void *)(*(void *)(a1 + 56) + 8LL);
    uint64_t v20 = *(void **)(v19 + 40);
    *(void *)(v19 + 40) = v18;
  }
}

void sub_1000655E4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_100065614(uint64_t a1)
{
  if (qword_1000DBB98 != -1) {
    dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
  }
  uint64_t v2 = (os_log_s *)(id)qword_1000DBB90;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = 0LL;
    unsigned int v3 = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      __int16 v10 = 0;
      int v5 = (const char *)_os_log_send_and_compose_impl( v4,  &v11,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "unloadUserSession UnSupported",  &v10,  2);
      uint64_t v6 = (char *)v5;
      if (v5) {
        sub_100053B7C(v5);
      }
    }

    else
    {
      uint64_t v6 = 0LL;
    }

    free(v6);
  }

  uint64_t v7 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  45LL,  0LL));
  uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v9 = *(void **)(v8 + 40);
  *(void *)(v8 + 40) = v7;
}

void sub_100066108( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
}

void sub_100066170(uint64_t a1)
{
  uint64_t v2 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
  if (v2)
  {
    unsigned int v3 = (void *)objc_claimAutoreleasedReturnValue([v2 objectForKey:kUMUserSessionIDKey]);
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v4 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = 0LL;
      LODWORD(v5) = sub_100053B4C(1);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v5 = v5;
      }
      else {
        uint64_t v5 = v5 & 0xFFFFFFFE;
      }
      if ((_DWORD)v5)
      {
        uint64_t v6 = v4;
        int v17 = 67109120;
        unsigned int v18 = [v3 intValue];
        uint64_t v7 = (char *)_os_log_send_and_compose_impl( v5,  &v16,  0LL,  0LL,  &_mh_execute_header,  v6,  0LL,  "Loaded User Session with ID %d",  &v17);

        if (v7) {
          sub_100053B7C(v7);
        }
      }

      else
      {
        uint64_t v7 = 0LL;
      }

      free(v7);
    }
  }

  if (qword_1000DBB98 != -1) {
    dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
  }
  uint64_t v8 = (os_log_s *)(id)qword_1000DBB90;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = 0LL;
    unsigned int v9 = sub_100053B4C(1);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = v9 & 0xFFFFFFFE;
    }
    if ((_DWORD)v10)
    {
      int v17 = 67109120;
      unsigned int v18 = 45;
      uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v10,  &v16,  0LL,  0LL,  &_mh_execute_header,  v8,  0LL,  "createUserSession failed with error:%d",  &v17);
      uint64_t v12 = (char *)v11;
      if (v11) {
        sub_100053B7C(v11);
      }
    }

    else
    {
      uint64_t v12 = 0LL;
    }

    free(v12);
  }

  uint64_t v13 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  45LL,  0LL));
  uint64_t v14 = *(void *)(*(void *)(a1 + 40) + 8LL);
  uint64_t v15 = *(void **)(v14 + 40);
  *(void *)(v14 + 40) = v13;
}

void sub_100066D08( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

void sub_100066D64(uint64_t a1)
{
  uint64_t v2 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  45LL,  0LL));
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void sub_1000672D8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27)
{
}

void sub_100067330(void *a1)
{
  uint64_t v2 = (const __CFDictionary *)sub_10001A6F8();
  if (v2)
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v3 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v33 = 0LL;
      unsigned int v4 = sub_100053B4C(1);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v5 = v4;
      }
      else {
        uint64_t v5 = v4 & 0xFFFFFFFE;
      }
      if ((_DWORD)v5)
      {
        __int16 v32 = 0;
        uint64_t v6 = (const char *)_os_log_send_and_compose_impl( v5,  &v33,  0LL,  0LL,  &_mh_execute_header,  v3,  0LL,  "Found Primary",  &v32,  2);
        uint64_t v7 = (char *)v6;
        if (v6) {
          sub_100053B7C(v6);
        }
      }

      else
      {
        uint64_t v7 = 0LL;
      }

      free(v7);
    }

    *(void *)(*(void *)(a1[4] + 8LL) + 24LL) = sub_100083DF4(v2, kUMUserSessionUUIDKey);
    if (*(void *)(*(void *)(a1[4] + 8LL) + 24LL))
    {
      if (qword_1000DBB98 != -1) {
        dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
      }
      uint64_t v13 = (os_log_s *)(id)qword_1000DBB90;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v33 = 0LL;
        unsigned int v14 = sub_100053B4C(1);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v15 = v14;
        }
        else {
          uint64_t v15 = v14 & 0xFFFFFFFE;
        }
        if ((_DWORD)v15)
        {
          __int16 v32 = 0;
          LODWORD(v31) = 2;
          uint64_t v16 = (const char *)_os_log_send_and_compose_impl( v15,  &v33,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "primaryUUIDStr is not NULL",  &v32,  v31);
          int v17 = (char *)v16;
          if (v16) {
            sub_100053B7C(v16);
          }
        }

        else
        {
          int v17 = 0LL;
        }

        free(v17);
      }

      CFRetain(*(CFTypeRef *)(*(void *)(a1[4] + 8LL) + 24LL));
      *(_BYTE *)(*(void *)(a1[5] + 8LL) + 24LL) = 1;
    }

    else
    {
      if (qword_1000DBB98 != -1) {
        dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
      }
      unsigned int v18 = (os_log_s *)(id)qword_1000DBB90;
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v33 = 0LL;
        unsigned int v19 = sub_100053B4C(1);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v20 = v19;
        }
        else {
          uint64_t v20 = v19 & 0xFFFFFFFE;
        }
        if ((_DWORD)v20)
        {
          __int16 v32 = 0;
          LODWORD(v31) = 2;
          uint64_t v21 = (const char *)_os_log_send_and_compose_impl( v20,  &v33,  0LL,  0LL,  &_mh_execute_header,  v18,  0LL,  "primaryUUIDStr is NULL",  &v32,  v31);
          int v22 = (char *)v21;
          if (v21) {
            sub_100053B7C(v21);
          }
        }

        else
        {
          int v22 = 0LL;
        }

        free(v22);
      }
    }

    if (*(void *)(*(void *)(a1[4] + 8LL) + 24LL)) {
      goto LABEL_63;
    }
  }

  else
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v8 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v33 = 0LL;
      unsigned int v9 = sub_100053B4C(1);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = v9 & 0xFFFFFFFE;
      }
      if ((_DWORD)v10)
      {
        __int16 v32 = 0;
        uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v10,  &v33,  0LL,  0LL,  &_mh_execute_header,  v8,  0LL,  "Primary Dict is NULL",  &v32,  2);
        uint64_t v12 = (char *)v11;
        if (v11) {
          sub_100053B7C(v11);
        }
      }

      else
      {
        uint64_t v12 = 0LL;
      }

      free(v12);
    }
  }

  if (qword_1000DBB98 != -1) {
    dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
  }
  int v23 = (os_log_s *)(id)qword_1000DBB90;
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v33 = 0LL;
    unsigned int v24 = sub_100053B4C(1);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v25 = v24;
    }
    else {
      uint64_t v25 = v24 & 0xFFFFFFFE;
    }
    if ((_DWORD)v25)
    {
      __int16 v32 = 0;
      LODWORD(v31) = 2;
      uint64_t v26 = (const char *)_os_log_send_and_compose_impl( v25,  &v33,  0LL,  0LL,  &_mh_execute_header,  v23,  0LL,  "unable to locate primary session or user uuid...",  &v32,  v31);
      uint64_t v27 = (char *)v26;
      if (v26) {
        sub_100053B7C(v26);
      }
    }

    else
    {
      uint64_t v27 = 0LL;
    }

    free(v27);
  }

  uint64_t v28 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  2LL,  0LL));
  uint64_t v29 = *(void *)(a1[6] + 8LL);
  id v30 = *(void **)(v29 + 40);
  *(void *)(v29 + 40) = v28;

  if (v2) {
LABEL_63:
  }
    CFRelease(v2);
}

void sub_100067800(uint64_t a1)
{
  int v21 = 0;
  if (qword_1000DBB98 != -1) {
    dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
  }
  uint64_t v2 = (os_log_s *)(id)qword_1000DBB90;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v20 = 0LL;
    unsigned int v3 = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      LOWORD(v22[0]) = 0;
      uint64_t v5 = (const char *)_os_log_send_and_compose_impl( v4,  &v20,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "Calling Volume Migration",  v22,  2);
      uint64_t v6 = (char *)v5;
      if (v5) {
        sub_100053B7C(v5);
      }
    }

    else
    {
      uint64_t v6 = 0LL;
    }

    free(v6);
  }

  if ((sub_100021E90(*(const __CFString **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL), &v21) & 1) != 0)
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v7 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v20 = 0LL;
      unsigned int v8 = sub_100053B4C(1);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v9 = v8;
      }
      else {
        uint64_t v9 = v8 & 0xFFFFFFFE;
      }
      if ((_DWORD)v9)
      {
        LOWORD(v22[0]) = 0;
        LODWORD(v19) = 2;
        uint64_t v10 = (const char *)_os_log_send_and_compose_impl( v9,  &v20,  0LL,  0LL,  &_mh_execute_header,  v7,  0LL,  "Volume Migration Successful",  v22,  v19);
        uint64_t v11 = (char *)v10;
        if (v10) {
          sub_100053B7C(v10);
        }
      }

      else
      {
        uint64_t v11 = 0LL;
      }

      free(v11);
    }
  }

  else
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v12 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v20 = 0LL;
      unsigned int v13 = sub_100053B4C(1);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v14 = v13;
      }
      else {
        uint64_t v14 = v13 & 0xFFFFFFFE;
      }
      if ((_DWORD)v14)
      {
        v22[0] = 67109120;
        v22[1] = v21;
        uint64_t v15 = (const char *)_os_log_send_and_compose_impl( v14,  &v20,  0LL,  0LL,  &_mh_execute_header,  v12,  0LL,  "Volume Migration failed with %d",  v22);
        uint64_t v16 = (char *)v15;
        if (v15) {
          sub_100053B7C(v15);
        }
      }

      else
      {
        uint64_t v16 = 0LL;
      }

      free(v16);
    }

    uint64_t v17 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  v21,  0LL));
    uint64_t v18 = *(void *)(*(void *)(a1 + 40) + 8LL);
    uint64_t v7 = *(os_log_s **)(v18 + 40);
    *(void *)(v18 + 40) = v17;
  }
}

void sub_1000680F8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31)
{
}

void sub_100068154(uint64_t a1)
{
  uint64_t v2 = sub_100046664(*(unsigned int *)(a1 + 64), *(unsigned int *)(a1 + 68), *(unsigned int *)(a1 + 72));
  unsigned int v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = sub_10004A3F0(*(void **)(a1 + 32), v3, &v7);
  if (*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL))
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = 1;
  }

  else
  {
    uint64_t v4 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  v7,  0LL));
    uint64_t v5 = *(void *)(*(void *)(a1 + 48) + 8LL);
    uint64_t v6 = *(void **)(v5 + 40);
    *(void *)(v5 + 40) = v4;
  }
}

void sub_100068208(void *a1)
{
  HIDWORD(v35) = 0;
  __int128 v54 = 0u;
  __int128 v55 = 0u;
  __int128 v52 = 0u;
  __int128 v53 = 0u;
  __int128 v50 = 0u;
  __int128 v51 = 0u;
  __int128 v48 = 0u;
  __int128 v49 = 0u;
  __int128 v46 = 0u;
  __int128 v47 = 0u;
  __int128 v45 = 0u;
  __int128 v43 = 0u;
  __int128 v44 = 0u;
  __int128 v41 = 0u;
  __int128 v42 = 0u;
  *(_OWORD *)buffer = 0u;
  if (qword_1000DBB98 != -1) {
    dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
  }
  uint64_t v2 = (os_log_s *)(id)qword_1000DBB90;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v39[0] = 0LL;
    unsigned int v3 = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      uint64_t v5 = a1[4];
      uint64_t v6 = *(char **)(*(void *)(a1[5] + 8LL) + 24LL);
      *(_DWORD *)uint64_t v36 = 138412546;
      *(void *)&v36[4] = v5;
      __int16 v37 = 2112;
      uint64_t v38 = v6;
      int v7 = (const char *)_os_log_send_and_compose_impl( v4,  v39,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "Persona String:%@ found diskString:%@",  v36,  22LL);
      unsigned int v8 = (char *)v7;
      if (v7) {
        sub_100053B7C(v7);
      }
    }

    else
    {
      unsigned int v8 = 0LL;
    }

    free(v8);
  }

  if (!CFStringGetCString(*(CFStringRef *)(*(void *)(a1[5] + 8LL) + 24LL), buffer, 256LL, 0x8000100u))
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v15 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      v39[0] = 0LL;
      unsigned int v16 = sub_100053B4C(1);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v17 = v16;
      }
      else {
        uint64_t v17 = v16 & 0xFFFFFFFE;
      }
      if ((_DWORD)v17)
      {
        uint64_t v18 = *(void *)(*(void *)(a1[5] + 8LL) + 24LL);
        *(_DWORD *)uint64_t v36 = 138412290;
        *(void *)&v36[4] = v18;
        LODWORD(v35) = 12;
        uint64_t v19 = (const char *)_os_log_send_and_compose_impl( v17,  v39,  0LL,  0LL,  &_mh_execute_header,  v15,  0LL,  "Could not convert diskString:%@ to ascii, erroring out",  v36,  v35);
        uint64_t v20 = (char *)v19;
        if (v19) {
          sub_100053B7C(v19);
        }
      }

      else
      {
        uint64_t v20 = 0LL;
      }

      free(v20);
    }

    NSErrorDomain v31 = NSPOSIXErrorDomain;
    uint64_t v32 = 22LL;
    goto LABEL_60;
  }

  if (qword_1000DBB98 != -1) {
    dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
  }
  uint64_t v9 = (os_log_s *)(id)qword_1000DBB90;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    v39[0] = 0LL;
    unsigned int v10 = sub_100053B4C(1);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v11 = v10;
    }
    else {
      uint64_t v11 = v10 & 0xFFFFFFFE;
    }
    if ((_DWORD)v11)
    {
      uint64_t v12 = a1[4];
      *(_DWORD *)uint64_t v36 = 138412546;
      *(void *)&v36[4] = v12;
      __int16 v37 = 2080;
      uint64_t v38 = buffer;
      LODWORD(v35) = 22;
      unsigned int v13 = (const char *)_os_log_send_and_compose_impl( v11,  v39,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "Calling Volume Migration for Persona:%@ with diskNode %s",  v36,  v35);
      uint64_t v14 = (char *)v13;
      if (v13) {
        sub_100053B7C(v13);
      }
    }

    else
    {
      uint64_t v14 = 0LL;
    }

    free(v14);
  }

  if (!sub_100023A8C((uint64_t)buffer))
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v26 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)uint64_t v36 = 0LL;
      unsigned int v27 = sub_100053B4C(1);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v28 = v27;
      }
      else {
        uint64_t v28 = v27 & 0xFFFFFFFE;
      }
      if ((_DWORD)v28)
      {
        LODWORD(v39[0]) = 67109120;
        HIDWORD(v39[0]) = HIDWORD(v35);
        uint64_t v29 = (const char *)_os_log_send_and_compose_impl( v28,  v36,  0LL,  0LL,  &_mh_execute_header,  v26,  0LL,  "Volume Migration failed with %d",  v39);
        id v30 = (char *)v29;
        if (v29) {
          sub_100053B7C(v29);
        }
      }

      else
      {
        id v30 = 0LL;
      }

      free(v30);
    }

    NSErrorDomain v31 = NSPOSIXErrorDomain;
    uint64_t v32 = SHIDWORD(v35);
LABEL_60:
    uint64_t v33 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  v31,  v32,  0LL));
    uint64_t v34 = *(void *)(a1[6] + 8LL);
    int v21 = *(os_log_s **)(v34 + 40);
    *(void *)(v34 + 40) = v33;
    goto LABEL_61;
  }

  if (qword_1000DBB98 != -1) {
    dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
  }
  int v21 = (os_log_s *)(id)qword_1000DBB90;
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t v36 = 0LL;
    unsigned int v22 = sub_100053B4C(1);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v23 = v22;
    }
    else {
      uint64_t v23 = v22 & 0xFFFFFFFE;
    }
    if ((_DWORD)v23)
    {
      LOWORD(v39[0]) = 0;
      LODWORD(v35) = 2;
      unsigned int v24 = (const char *)_os_log_send_and_compose_impl( v23,  v36,  0LL,  0LL,  &_mh_execute_header,  v21,  0LL,  "Volume Migration Successful",  v39,  v35);
      uint64_t v25 = (char *)v24;
      if (v24) {
        sub_100053B7C(v24);
      }
    }

    else
    {
      uint64_t v25 = 0LL;
    }

    free(v25);
  }

LABEL_61:
}
}

void sub_100068B34( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_100068B64(uint64_t a1)
{
  if (!sub_10002E2F8(*(const __CFDictionary **)(a1 + 32)))
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v2 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = 0LL;
      unsigned int v3 = sub_100053B4C(1);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v4 = v3;
      }
      else {
        uint64_t v4 = v3 & 0xFFFFFFFE;
      }
      if ((_DWORD)v4)
      {
        __int16 v10 = 0;
        uint64_t v5 = (const char *)_os_log_send_and_compose_impl( v4,  &v11,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "removeUserSession failed",  &v10,  2);
        uint64_t v6 = (char *)v5;
        if (v5) {
          sub_100053B7C(v5);
        }
      }

      else
      {
        uint64_t v6 = 0LL;
      }

      free(v6);
    }

    uint64_t v7 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  22LL,  0LL));
    uint64_t v8 = *(void *)(*(void *)(a1 + 40) + 8LL);
    uint64_t v9 = *(void **)(v8 + 40);
    *(void *)(v8 + 40) = v7;
  }

LABEL_6:
  _Block_object_dispose(&v9, 8);
  _Block_object_dispose(&v15, 8);
}

  _Block_object_dispose(&v9, 8);

  _Block_object_dispose(&v15, 8);
}

        char *v8 = a1;
        *(void *)(v8 + 1) = 0x100000001LL;
        v8[3] = v9;
        if ((a1 & 0xFFFFFFFE) == 4)
        {
          v8[4] = a2;
        }

        else if (a1 == 1000)
        {
          v8[13] = a2;
        }

        else if (a1 == 7)
        {
          v8[5] = a2;
        }

        uint64_t v6 = 0LL;
        *a3 = v8;
        uint64_t v7 = 10;
        break;
      default:
        switch(a1)
        {
          case 1000:
            uint64_t v8 = acm_mem_alloc(0x88uLL);
            acm_mem_alloc_info( "ACMRequirement - ACMRequirementDataKofNWithAttributes",  v8,  136LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/CommonUtil.c",  414,  "Util_AllocRequirement");
            uint64_t v9 = 120;
            if (!v8) {
              goto LABEL_50;
            }
            goto LABEL_6;
          case 1001:
            uint64_t v8 = acm_mem_alloc(0xB8uLL);
            acm_mem_alloc_info( "ACMRequirement - ACMRequirementDataBiometryMatchedWithAttributes",  v8,  184LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/CommonUtil.c",  419,  "Util_AllocRequirement");
            uint64_t v9 = 168;
            if (!v8) {
              goto LABEL_50;
            }
            goto LABEL_6;
          case 1002:
            uint64_t v8 = acm_mem_alloc(0x14uLL);
            uint64_t v11 = "ACMRequirement - ACMRequirementDataPushButtonWithAttributes";
            uint64_t v12 = v8;
            unsigned int v13 = 424;
            goto LABEL_49;
          case 1003:
            uint64_t v8 = acm_mem_alloc(0x14uLL);
            uint64_t v11 = "ACMRequirement - ACMRequirementDataSecureStateWithAttributes";
            uint64_t v12 = v8;
            unsigned int v13 = 429;
            goto LABEL_49;
          case 1004:
            uint64_t v8 = acm_mem_alloc(0x20uLL);
            acm_mem_alloc_info( "ACMRequirement - ACMRequirementDataPasscodeValidatedWithAttributes",  v8,  32LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/CommonUtil.c",  434,  "Util_AllocRequirement");
            uint64_t v9 = 16;
            if (!v8) {
              goto LABEL_50;
            }
            goto LABEL_6;
          default:
            goto LABEL_17;
        }
    }
  }

  else
  {
LABEL_53:
    uint64_t v6 = 4294967293LL;
LABEL_54:
    uint64_t v7 = 70;
  }

  memset_s(__s, 0x40uLL, 0, 0x40uLL);
  return 0xFFFFFFFFLL;
}

  memset_s(__s, 0x40uLL, 0, 0x40uLL);
  return 0xFFFFFFFFLL;
}

  memset_s(v11, __n[0], 0, __n[0]);
  free(v11);
  return v15;
}

void sub_100069148( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10006916C(uint64_t a1)
{
  uint64_t v2 = sub_1000312B8("/private/var//keybags/nextsession_opaque.kb");
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  if (v2)
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v5 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = 0LL;
      LODWORD(v6) = sub_100053B4C(1);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v6 = v6;
      }
      else {
        uint64_t v6 = v6 & 0xFFFFFFFE;
      }
      if ((_DWORD)v6)
      {
        uint64_t v7 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
        uint64_t v8 = v5;
        v18[0] = 67109120;
        v18[1] = [v7 length];
        uint64_t v9 = (char *)_os_log_send_and_compose_impl( v6,  &v17,  0LL,  0LL,  &_mh_execute_header,  v8,  0LL,  "RetrieveBlob SUCCESS with BLOB with size %d",  v18);

        if (v9) {
          sub_100053B7C(v9);
        }
      }

      else
      {
        uint64_t v9 = 0LL;
      }

      free(v9);
    }
  }

  else
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    __int16 v10 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = 0LL;
      unsigned int v11 = sub_100053B4C(1);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v12 = v11;
      }
      else {
        uint64_t v12 = v11 & 0xFFFFFFFE;
      }
      if ((_DWORD)v12)
      {
        LOWORD(v18[0]) = 0;
        unsigned int v13 = (const char *)_os_log_send_and_compose_impl( v12,  &v17,  0LL,  0LL,  &_mh_execute_header,  v10,  0LL,  "RetrieveBlob FAILED to read BLOB",  v18,  2);
        uint64_t v14 = (char *)v13;
        if (v13) {
          sub_100053B7C(v13);
        }
      }

      else
      {
        uint64_t v14 = 0LL;
      }

      free(v14);
    }

    uint64_t v15 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  5LL,  0LL));
    uint64_t v16 = *(void *)(*(void *)(a1 + 40) + 8LL);
    uint64_t v5 = *(os_log_s **)(v16 + 40);
    *(void *)(v16 + 40) = v15;
  }
}

void sub_100069528( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10006954C(uint64_t a1)
{
  if (qword_1000DBB98 != -1) {
    dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
  }
  uint64_t v2 = (os_log_s *)(id)qword_1000DBB90;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v21 = 0LL;
    unsigned int v3 = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      LOWORD(v22[0]) = 0;
      uint64_t v5 = (const char *)_os_log_send_and_compose_impl( v4,  &v21,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "In SetDeleteBlob",  v22,  2);
      uint64_t v6 = (char *)v5;
      if (v5) {
        sub_100053B7C(v5);
      }
    }

    else
    {
      uint64_t v6 = 0LL;
    }

    free(v6);
  }

  if (unlink("/private/var//keybags/nextsession_opaque.kb"))
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *__error();
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v7 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = 0LL;
      unsigned int v8 = sub_100053B4C(1);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v9 = v8;
      }
      else {
        uint64_t v9 = v8 & 0xFFFFFFFE;
      }
      if ((_DWORD)v9)
      {
        int v10 = *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
        v22[0] = 67109120;
        v22[1] = v10;
        unsigned int v11 = (const char *)_os_log_send_and_compose_impl( v9,  &v21,  0LL,  0LL,  &_mh_execute_header,  v7,  0LL,  "Removing User Session OpaqueBlob failed with error :%d",  v22);
        uint64_t v12 = (char *)v11;
        if (v11) {
          sub_100053B7C(v11);
        }
      }

      else
      {
        uint64_t v12 = 0LL;
      }

      free(v12);
    }

    uint64_t v18 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  *(int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL),  0LL));
    uint64_t v19 = *(void *)(*(void *)(a1 + 40) + 8LL);
    unsigned int v13 = *(os_log_s **)(v19 + 40);
    *(void *)(v19 + 40) = v18;
  }

  else
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    unsigned int v13 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = 0LL;
      unsigned int v14 = sub_100053B4C(1);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v15 = v14;
      }
      else {
        uint64_t v15 = v14 & 0xFFFFFFFE;
      }
      if ((_DWORD)v15)
      {
        LOWORD(v22[0]) = 0;
        LODWORD(v20) = 2;
        uint64_t v16 = (const char *)_os_log_send_and_compose_impl( v15,  &v21,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "Removed User Session OpaqueBlob",  v22,  v20);
        uint64_t v17 = (char *)v16;
        if (v16) {
          sub_100053B7C(v16);
        }
      }

      else
      {
        uint64_t v17 = 0LL;
      }

      free(v17);
    }
  }
}

void sub_100069A10( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_100069A28(uint64_t a1)
{
  if (sub_10001C3D4())
  {
    if (qword_1000DBBA8 != -1) {
      dispatch_once(&qword_1000DBBA8, &stru_1000CDAC0);
    }
    uint64_t v2 = (os_log_s *)(id)qword_1000DBBA0;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      uint64_t v20 = 0LL;
      unsigned int v3 = sub_100053B4C(0);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
        uint64_t v4 = v3;
      }
      else {
        uint64_t v4 = v3 & 0xFFFFFFFE;
      }
      if ((_DWORD)v4)
      {
        LOWORD(v21) = 0;
        uint64_t v5 = (const char *)_os_log_send_and_compose_impl( v4,  &v20,  0LL,  0LL,  &_mh_execute_header,  v2,  16LL,  "Failed to switch user: user switch already in progress",  &v21,  2);
        uint64_t v6 = (char *)v5;
        if (v5) {
          sub_100053B7C(v5);
        }
      }

      else
      {
        uint64_t v6 = 0LL;
      }

      free(v6);
    }

    uint64_t v16 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  37LL,  0LL));
    uint64_t v17 = *(void *)(*(void *)(a1 + 48) + 8LL);
    uint64_t v7 = *(void **)(v17 + 40);
    *(void *)(v17 + 40) = v16;
  }

  else
  {
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) objectForKey:kUMUserSessionIDKey]);
    if (sub_10002E554(*(const __CFDictionary **)(a1 + 32), 0LL, *(const __CFData **)(a1 + 40)) == 1)
    {
      if (qword_1000DBB98 != -1) {
        dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
      }
      unsigned int v8 = (os_log_s *)(id)qword_1000DBB90;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v20 = 0LL;
        LODWORD(v9) = sub_100053B4C(1);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v9 = v9;
        }
        else {
          uint64_t v9 = v9 & 0xFFFFFFFE;
        }
        if ((_DWORD)v9)
        {
          int v10 = v8;
          int v21 = 67109120;
          unsigned int v22 = [v7 intValue];
          unsigned int v11 = (char *)_os_log_send_and_compose_impl( v9,  &v20,  0LL,  0LL,  &_mh_execute_header,  v10,  0LL,  "Successful switch Session with next boot foreground ID %d",  &v21);

          if (v11) {
            sub_100053B7C(v11);
          }
        }

        else
        {
          unsigned int v11 = 0LL;
        }

        free(v11);
      }
    }

    else
    {
      if (qword_1000DBB98 != -1) {
        dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
      }
      uint64_t v12 = (os_log_s *)(id)qword_1000DBB90;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v20 = 0LL;
        LODWORD(v13) = sub_100053B4C(1);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v13 = v13;
        }
        else {
          uint64_t v13 = v13 & 0xFFFFFFFE;
        }
        if ((_DWORD)v13)
        {
          unsigned int v14 = v12;
          int v21 = 67109120;
          unsigned int v22 = [v7 intValue];
          uint64_t v15 = (char *)_os_log_send_and_compose_impl( v13,  &v20,  0LL,  0LL,  &_mh_execute_header,  v14,  0LL,  "Failed to switch Session with next boot foreground ID %d",  &v21);

          if (v15) {
            sub_100053B7C(v15);
          }
        }

        else
        {
          uint64_t v15 = 0LL;
        }

        free(v15);
      }

      uint64_t v18 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  22LL,  0LL));
      uint64_t v19 = *(void *)(*(void *)(a1 + 48) + 8LL);
      unsigned int v8 = *(os_log_s **)(v19 + 40);
      *(void *)(v19 + 40) = v18;
    }
  }
}

void sub_10006A00C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_10006A02C(uint64_t a1)
{
  if (qword_1000DBB98 != -1) {
    dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
  }
  uint64_t v2 = (os_log_s *)(id)qword_1000DBB90;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v19 = 0LL;
    unsigned int v3 = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      LOWORD(v1_Block_object_dispose(va, 8) = 0;
      uint64_t v5 = (const char *)_os_log_send_and_compose_impl( v4,  &v19,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "In SetSBDBlob",  &v18,  2);
      uint64_t v6 = (char *)v5;
      if (v5) {
        sub_100053B7C(v5);
      }
    }

    else
    {
      uint64_t v6 = 0LL;
    }

    free(v6);
  }

  if (sub_10002FCA4( *(const __CFData **)(a1 + 32),  (uint64_t)"/private/var//keybags/nextsession_SBD_opaque.kb") == 1)
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v7 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = 0LL;
      unsigned int v8 = sub_100053B4C(1);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v9 = v8;
      }
      else {
        uint64_t v9 = v8 & 0xFFFFFFFE;
      }
      if ((_DWORD)v9)
      {
        LOWORD(v1_Block_object_dispose(va, 8) = 0;
        LODWORD(v17) = 2;
        int v10 = (const char *)_os_log_send_and_compose_impl( v9,  &v19,  0LL,  0LL,  &_mh_execute_header,  v7,  0LL,  "Successful Setting of SBD Opaque Bag",  &v18,  v17,  v18);
        goto LABEL_29;
      }

      goto LABEL_31;
    }
  }

  else
  {
    uint64_t v11 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  5LL,  0LL));
    uint64_t v12 = *(void *)(*(void *)(a1 + 40) + 8LL);
    uint64_t v13 = *(void **)(v12 + 40);
    *(void *)(v12 + 40) = v11;

    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v7 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = 0LL;
      unsigned int v14 = sub_100053B4C(1);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v15 = v14;
      }
      else {
        uint64_t v15 = v14 & 0xFFFFFFFE;
      }
      if ((_DWORD)v15)
      {
        LOWORD(v1_Block_object_dispose(va, 8) = 0;
        LODWORD(v17) = 2;
        int v10 = (const char *)_os_log_send_and_compose_impl( v15,  &v19,  0LL,  0LL,  &_mh_execute_header,  v7,  0LL,  "Failed Setting of SBD Opaque Bag",  &v18,  v17,  v18);
LABEL_29:
        uint64_t v16 = (char *)v10;
        if (v10) {
          sub_100053B7C(v10);
        }
        goto LABEL_32;
      }

void sub_10006A480( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_10006A4A4(uint64_t a1)
{
  int v15 = 0;
  *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = sub_1000308A4( *(const __CFDictionary **)(a1 + 32),  *(const void **)(a1 + 40),  &v15);
  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL))
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v2 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = 0LL;
      unsigned int v3 = sub_100053B4C(1);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v4 = v3;
      }
      else {
        uint64_t v4 = v3 & 0xFFFFFFFE;
      }
      if ((_DWORD)v4)
      {
        LOWORD(v16[0]) = 0;
        uint64_t v5 = (const char *)_os_log_send_and_compose_impl( v4,  &v14,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "setUserSessionKeybagData successful",  v16,  2);
        uint64_t v6 = (char *)v5;
        if (v5) {
          sub_100053B7C(v5);
        }
      }

      else
      {
        uint64_t v6 = 0LL;
      }

      free(v6);
    }
  }

  else
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v7 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = 0LL;
      unsigned int v8 = sub_100053B4C(1);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v9 = v8;
      }
      else {
        uint64_t v9 = v8 & 0xFFFFFFFE;
      }
      if ((_DWORD)v9)
      {
        v16[0] = 67109120;
        v16[1] = v15;
        int v10 = (const char *)_os_log_send_and_compose_impl( v9,  &v14,  0LL,  0LL,  &_mh_execute_header,  v7,  0LL,  "FAILED to setUserSessionKeybagData with error :%d",  v16);
        uint64_t v11 = (char *)v10;
        if (v10) {
          sub_100053B7C(v10);
        }
      }

      else
      {
        uint64_t v11 = 0LL;
      }

      free(v11);
    }

    uint64_t v12 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  v15,  0LL));
    uint64_t v13 = *(void *)(*(void *)(a1 + 56) + 8LL);
    uint64_t v2 = *(os_log_s **)(v13 + 40);
    *(void *)(v13 + 40) = v12;
  }
}

void sub_10006A8B8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_10006A8DC(uint64_t a1)
{
  int v19 = 0;
  uint64_t v2 = sub_100030648(*(const __CFDictionary **)(a1 + 32), &v19);
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8LL);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  if (*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL)) {
    BOOL v5 = 1;
  }
  else {
    BOOL v5 = v19 == 0;
  }
  if (v5)
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v6 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v18 = 0LL;
      unsigned int v7 = sub_100053B4C(1);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v8 = v7;
      }
      else {
        uint64_t v8 = v7 & 0xFFFFFFFE;
      }
      if ((_DWORD)v8)
      {
        LOWORD(v20[0]) = 0;
        uint64_t v9 = (const char *)_os_log_send_and_compose_impl( v8,  &v18,  0LL,  0LL,  &_mh_execute_header,  v6,  0LL,  "userKeybagOpaqueData retrieval successful",  v20,  2);
        int v10 = (char *)v9;
        if (v9) {
          sub_100053B7C(v9);
        }
      }

      else
      {
        int v10 = 0LL;
      }

      free(v10);
    }
  }

  else
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v11 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v18 = 0LL;
      unsigned int v12 = sub_100053B4C(1);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v13 = v12;
      }
      else {
        uint64_t v13 = v12 & 0xFFFFFFFE;
      }
      if ((_DWORD)v13)
      {
        v20[0] = 67109120;
        v20[1] = v19;
        uint64_t v14 = (const char *)_os_log_send_and_compose_impl( v13,  &v18,  0LL,  0LL,  &_mh_execute_header,  v11,  0LL,  "FAILED to get userKeybagOpaqueData with error :%d",  v20);
        int v15 = (char *)v14;
        if (v14) {
          sub_100053B7C(v14);
        }
      }

      else
      {
        int v15 = 0LL;
      }

      free(v15);
    }

    uint64_t v16 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  v19,  0LL));
    uint64_t v17 = *(void *)(*(void *)(a1 + 48) + 8LL);
    uint64_t v6 = *(os_log_s **)(v17 + 40);
    *(void *)(v17 + 40) = v16;
  }
}

void sub_10006ACA8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10006ACCC(uint64_t a1)
{
  uint64_t v2 = sub_1000312B8("/private/var//keybags/nextsession_SBD_opaque.kb");
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  if (v2)
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    BOOL v5 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = 0LL;
      LODWORD(v6) = sub_100053B4C(1);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v6 = v6;
      }
      else {
        uint64_t v6 = v6 & 0xFFFFFFFE;
      }
      if ((_DWORD)v6)
      {
        uint64_t v7 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
        uint64_t v8 = v5;
        v18[0] = 67109120;
        v18[1] = [v7 length];
        uint64_t v9 = (char *)_os_log_send_and_compose_impl( v6,  &v17,  0LL,  0LL,  &_mh_execute_header,  v8,  0LL,  "RetrieveSBDBlob SUCCESS with BLOB with size %d",  v18);

        if (v9) {
          sub_100053B7C(v9);
        }
      }

      else
      {
        uint64_t v9 = 0LL;
      }

      free(v9);
    }
  }

  else
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    int v10 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = 0LL;
      unsigned int v11 = sub_100053B4C(1);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v12 = v11;
      }
      else {
        uint64_t v12 = v11 & 0xFFFFFFFE;
      }
      if ((_DWORD)v12)
      {
        LOWORD(v18[0]) = 0;
        uint64_t v13 = (const char *)_os_log_send_and_compose_impl( v12,  &v17,  0LL,  0LL,  &_mh_execute_header,  v10,  0LL,  "RetrieveSBDBlob FAILED to read BLOB",  v18,  2);
        uint64_t v14 = (char *)v13;
        if (v13) {
          sub_100053B7C(v13);
        }
      }

      else
      {
        uint64_t v14 = 0LL;
      }

      free(v14);
    }

    uint64_t v15 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  5LL,  0LL));
    uint64_t v16 = *(void *)(*(void *)(a1 + 40) + 8LL);
    BOOL v5 = *(os_log_s **)(v16 + 40);
    *(void *)(v16 + 40) = v15;
  }
}

void sub_10006B088( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10006B0AC(uint64_t a1)
{
  if (qword_1000DBB98 != -1) {
    dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
  }
  uint64_t v2 = (os_log_s *)(id)qword_1000DBB90;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v21 = 0LL;
    unsigned int v3 = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      LOWORD(v22[0]) = 0;
      BOOL v5 = (const char *)_os_log_send_and_compose_impl( v4,  &v21,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "In DeleteSBDBlob",  v22,  2);
      uint64_t v6 = (char *)v5;
      if (v5) {
        sub_100053B7C(v5);
      }
    }

    else
    {
      uint64_t v6 = 0LL;
    }

    free(v6);
  }

  if (unlink("/private/var//keybags/nextsession_SBD_opaque.kb"))
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *__error();
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v7 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = 0LL;
      unsigned int v8 = sub_100053B4C(1);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v9 = v8;
      }
      else {
        uint64_t v9 = v8 & 0xFFFFFFFE;
      }
      if ((_DWORD)v9)
      {
        int v10 = *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
        v22[0] = 67109120;
        v22[1] = v10;
        unsigned int v11 = (const char *)_os_log_send_and_compose_impl( v9,  &v21,  0LL,  0LL,  &_mh_execute_header,  v7,  0LL,  "Removing User Session SBD OpaqueBlob failed with error :%d",  v22);
        uint64_t v12 = (char *)v11;
        if (v11) {
          sub_100053B7C(v11);
        }
      }

      else
      {
        uint64_t v12 = 0LL;
      }

      free(v12);
    }

    uint64_t v18 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  *(int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL),  0LL));
    uint64_t v19 = *(void *)(*(void *)(a1 + 40) + 8LL);
    uint64_t v13 = *(os_log_s **)(v19 + 40);
    *(void *)(v19 + 40) = v18;
  }

  else
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v13 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = 0LL;
      unsigned int v14 = sub_100053B4C(1);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v15 = v14;
      }
      else {
        uint64_t v15 = v14 & 0xFFFFFFFE;
      }
      if ((_DWORD)v15)
      {
        LOWORD(v22[0]) = 0;
        LODWORD(v20) = 2;
        uint64_t v16 = (const char *)_os_log_send_and_compose_impl( v15,  &v21,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "Removed User Session SBD OpaqueBlob",  v22,  v20);
        uint64_t v17 = (char *)v16;
        if (v16) {
          sub_100053B7C(v16);
        }
      }

      else
      {
        uint64_t v17 = 0LL;
      }

      free(v17);
    }
  }
}

void sub_10006B588( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_10006B5AC(uint64_t a1)
{
  if (qword_1000DBB98 != -1) {
    dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
  }
  uint64_t v2 = (os_log_s *)(id)qword_1000DBB90;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = 0LL;
    unsigned int v3 = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      __int16 v14 = 0;
      BOOL v5 = (const char *)_os_log_send_and_compose_impl( v4,  &v15,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "In getUserSessionAttributes:reply:",  &v14,  2);
      uint64_t v6 = (char *)v5;
      if (v5) {
        sub_100053B7C(v5);
      }
    }

    else
    {
      uint64_t v6 = 0LL;
    }

    free(v6);
  }

  uint64_t v7 = sub_100030128(*(const __CFDictionary **)(a1 + 32));
  if (v7)
  {
    uint64_t v8 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) externalizeUserDictionary:v7]);
    uint64_t v9 = *(void *)(*(void *)(a1 + 48) + 8LL);
    int v10 = *(void **)(v9 + 40);
    *(void *)(v9 + 40) = v8;
  }

  if (!*(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL))
  {
    uint64_t v11 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  22LL,  0LL));
    uint64_t v12 = *(void *)(*(void *)(a1 + 56) + 8LL);
    uint64_t v13 = *(void **)(v12 + 40);
    *(void *)(v12 + 40) = v11;
  }
}

void sub_10006B920( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v13 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  uint64_t v19 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose((const void *)(v11 - 96), 8);
  _Unwind_Resume(a1);
}

void sub_10006B950(uint64_t a1)
{
  uint64_t v2 = sub_100030E5C(*(const __CFDictionary **)(a1 + 32));
  if (v2)
  {
    uint64_t v3 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) externalizeUserDictionary:v2]);
    uint64_t v4 = *(void *)(*(void *)(a1 + 48) + 8LL);
    BOOL v5 = *(void **)(v4 + 40);
    *(void *)(v4 + 40) = v3;
  }

  if (*(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL))
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v6 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = 0LL;
      LODWORD(v7) = sub_100053B4C(1);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v7 = v7;
      }
      else {
        uint64_t v7 = v7 & 0xFFFFFFFE;
      }
      if ((_DWORD)v7)
      {
        uint64_t v8 = *(void **)(*(void *)(*(void *)(a1 + 64) + 8LL) + 40LL);
        uint64_t v9 = v6;
        int v18 = 67109120;
        unsigned int v19 = [v8 intValue];
        uint64_t v10 = _os_log_send_and_compose_impl( v7,  &v17,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "In Set User Session with ID %d completed",  &v18);
        goto LABEL_20;
      }

      goto LABEL_22;
    }
  }

  else
  {
    uint64_t v11 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  22LL,  0LL));
    uint64_t v12 = *(void *)(*(void *)(a1 + 56) + 8LL);
    uint64_t v13 = *(void **)(v12 + 40);
    *(void *)(v12 + 40) = v11;

    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v6 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = 0LL;
      LODWORD(v14) = sub_100053B4C(1);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v14 = v14;
      }
      else {
        uint64_t v14 = v14 & 0xFFFFFFFE;
      }
      if ((_DWORD)v14)
      {
        uint64_t v15 = *(void **)(*(void *)(*(void *)(a1 + 64) + 8LL) + 40LL);
        uint64_t v9 = v6;
        int v18 = 67109120;
        unsigned int v19 = [v15 intValue];
        uint64_t v10 = _os_log_send_and_compose_impl( v14,  &v17,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "Failed to Set User Session with ID %d completed",  &v18);
LABEL_20:
        uint64_t v16 = (char *)v10;

        if (v16) {
          sub_100053B7C(v16);
        }
        goto LABEL_23;
      }

void sub_10006BCEC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_10006BD10(uint64_t a1)
{
  if (qword_1000DBB98 != -1) {
    dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
  }
  uint64_t v2 = (os_log_s *)(id)qword_1000DBB90;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v21 = 0LL;
    unsigned int v3 = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      __int16 v20 = 0;
      BOOL v5 = (const char *)_os_log_send_and_compose_impl( v4,  &v21,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "In UserSessionConfigured",  &v20,  2);
      uint64_t v6 = (char *)v5;
      if (v5) {
        sub_100053B7C(v5);
      }
    }

    else
    {
      uint64_t v6 = 0LL;
    }

    free(v6);
  }

  uint64_t v7 = sub_10001A594();
  if (v7)
  {
    uint64_t v8 = (void *)v7;
    uint64_t v9 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) externalizeUserDictionary:v7]);
    uint64_t v10 = *(void *)(*(void *)(a1 + 40) + 8LL);
    uint64_t v11 = *(void **)(v10 + 40);
    *(void *)(v10 + 40) = v9;
  }

  else
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v12 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = 0LL;
      unsigned int v13 = sub_100053B4C(1);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v14 = v13;
      }
      else {
        uint64_t v14 = v13 & 0xFFFFFFFE;
      }
      if ((_DWORD)v14)
      {
        __int16 v20 = 0;
        LODWORD(v19) = 2;
        uint64_t v15 = (const char *)_os_log_send_and_compose_impl( v14,  &v21,  0LL,  0LL,  &_mh_execute_header,  v12,  0LL,  "Did not find any session in UserSessionConfigured",  &v20,  v19);
        uint64_t v16 = (char *)v15;
        if (v15) {
          sub_100053B7C(v15);
        }
      }

      else
      {
        uint64_t v16 = 0LL;
      }

      free(v16);
    }

    uint64_t v17 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  22LL,  0LL));
    uint64_t v18 = *(void *)(*(void *)(a1 + 48) + 8LL);
    uint64_t v8 = *(void **)(v18 + 40);
    *(void *)(v18 + 40) = v17;
  }
}

void sub_10006C2A4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

void sub_10006C2D8(uint64_t a1)
{
  if (sub_10001C3D4())
  {
    if (qword_1000DBBA8 != -1) {
      dispatch_once(&qword_1000DBBA8, &stru_1000CDAC0);
    }
    uint64_t v2 = (os_log_s *)(id)qword_1000DBBA0;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      uint64_t v36 = 0LL;
      unsigned int v3 = sub_100053B4C(0);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
        uint64_t v4 = v3;
      }
      else {
        uint64_t v4 = v3 & 0xFFFFFFFE;
      }
      if ((_DWORD)v4)
      {
        __int16 v35 = 0;
        BOOL v5 = (const char *)_os_log_send_and_compose_impl( v4,  &v36,  0LL,  0LL,  &_mh_execute_header,  v2,  16LL,  "Failed to switch user: user switch already in progress",  &v35,  2);
        uint64_t v6 = (char *)v5;
        if (v5) {
          sub_100053B7C(v5);
        }
      }

      else
      {
        uint64_t v6 = 0LL;
      }

      free(v6);
    }

    uint64_t v20 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  37LL,  0LL));
    uint64_t v21 = *(void *)(*(void *)(a1 + 40) + 8LL);
    unsigned int v22 = *(void **)(v21 + 40);
    *(void *)(v21 + 40) = v20;
  }

  else
  {
    uint64_t v7 = sub_10001A2A4(502);
    if (v7)
    {
      uint64_t v8 = (void *)v7;
      if (qword_1000DBB98 != -1) {
        dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
      }
      uint64_t v9 = (os_log_s *)(id)qword_1000DBB90;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v36 = 0LL;
        unsigned int v10 = sub_100053B4C(1);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v11 = v10;
        }
        else {
          uint64_t v11 = v10 & 0xFFFFFFFE;
        }
        if ((_DWORD)v11)
        {
          __int16 v35 = 0;
          uint64_t v12 = (const char *)_os_log_send_and_compose_impl( v11,  &v36,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "LOGINWINDOW User EXISTS ALREADY, returning loginwindow setup",  &v35,  2);
          uint64_t v13 = (char *)v12;
          if (v12) {
            sub_100053B7C(v12);
          }
        }

        else
        {
          uint64_t v13 = 0LL;
        }

        free(v13);
      }
    }

    else
    {
      uint64_t v14 = sub_10001ED88(*(_DWORD *)(a1 + 56), 0LL);
      if (!v14)
      {
        uint64_t v23 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  22LL,  0LL));
        uint64_t v24 = *(void *)(*(void *)(a1 + 40) + 8LL);
        uint64_t v25 = *(void **)(v24 + 40);
        *(void *)(v24 + 40) = v23;

        return;
      }

      uint64_t v8 = v14;
      if (qword_1000DBB98 != -1) {
        dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
      }
      uint64_t v15 = (os_log_s *)(id)qword_1000DBB90;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v36 = 0LL;
        unsigned int v16 = sub_100053B4C(1);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v17 = v16;
        }
        else {
          uint64_t v17 = v16 & 0xFFFFFFFE;
        }
        if ((_DWORD)v17)
        {
          __int16 v35 = 0;
          uint64_t v18 = (const char *)_os_log_send_and_compose_impl( v17,  &v36,  0LL,  0LL,  &_mh_execute_header,  v15,  0LL,  "DONE Creating LOGINWINDOW User",  &v35,  2);
          uint64_t v19 = (char *)v18;
          if (v18) {
            sub_100053B7C(v18);
          }
        }

        else
        {
          uint64_t v19 = 0LL;
        }

        free(v19);
      }

      if (qword_1000DBB98 != -1) {
        dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
      }
      uint64_t v26 = (os_log_s *)(id)qword_1000DBB90;
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v36 = 0LL;
        unsigned int v27 = sub_100053B4C(1);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v28 = v27;
        }
        else {
          uint64_t v28 = v27 & 0xFFFFFFFE;
        }
        if ((_DWORD)v28)
        {
          __int16 v35 = 0;
          LODWORD(v34) = 2;
          uint64_t v29 = (const char *)_os_log_send_and_compose_impl( v28,  &v36,  0LL,  0LL,  &_mh_execute_header,  v26,  0LL,  "Forcing USR as configuration is successful",  &v35,  v34);
          id v30 = (char *)v29;
          if (v29) {
            sub_100053B7C(v29);
          }
        }

        else
        {
          id v30 = 0LL;
        }

        free(v30);
      }

      sub_10002EAB0(*(const __CFDictionary **)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL), 0LL);
    }

    uint64_t v31 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) externalizeUserDictionary:v8]);
    uint64_t v32 = *(void *)(*(void *)(a1 + 48) + 8LL);
    uint64_t v33 = *(void **)(v32 + 40);
    *(void *)(v32 + 40) = v31;
  }

void sub_10006C970( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_10006C988(uint64_t a1)
{
  uint64_t v2 = (const __CFDictionary *)sub_10001A2A4(*(_DWORD *)(a1 + 48));
  unsigned int v3 = v2;
  if (v2)
  {
    uint64_t v4 = *(const __CFString **)(a1 + 32);
    if (v4)
    {
      sub_1000343E0(v2, v4);
      *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0;
      if (qword_1000DBB98 != -1) {
        dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
      }
      BOOL v5 = (os_log_s *)(id)qword_1000DBB90;
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v17 = 0LL;
        unsigned int v6 = sub_100053B4C(1);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v7 = v6;
        }
        else {
          uint64_t v7 = v6 & 0xFFFFFFFE;
        }
        if ((_DWORD)v7)
        {
          *(_DWORD *)unsigned int v16 = 138412290;
          *(void *)&v16[4] = v3;
          uint64_t v8 = (const char *)_os_log_send_and_compose_impl( v7,  &v17,  0LL,  0LL,  &_mh_execute_header,  v5,  0LL,  "AddSyncservice: to the session %@",  v16,  12);
          uint64_t v9 = (char *)v8;
          if (v8) {
            sub_100053B7C(v8);
          }
        }

        else
        {
          uint64_t v9 = 0LL;
        }

        free(v9);
      }
    }

    unsigned int v10 = (void *)objc_claimAutoreleasedReturnValue(-[__CFDictionary objectForKey:](v3, "objectForKey:", kUMUserSessionIDKey));
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v11 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)unsigned int v16 = 0LL;
      LODWORD(v12) = sub_100053B4C(1);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v12 = v12;
      }
      else {
        uint64_t v12 = v12 & 0xFFFFFFFE;
      }
      if ((_DWORD)v12)
      {
        uint64_t v13 = v11;
        unsigned int v14 = [v10 intValue];
        LODWORD(v17) = 67109120;
        HIDWORD(v17) = v14;
        uint64_t v15 = (char *)_os_log_send_and_compose_impl( v12,  v16,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "Added MachService to User Session with ID %d",  &v17);

        if (v15) {
          sub_100053B7C(v15);
        }
      }

      else
      {
        uint64_t v15 = 0LL;
      }

      free(v15);
    }
  }
}

void sub_10006CD70( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_10006CD88(uint64_t a1)
{
  uint64_t v2 = (const __CFDictionary *)sub_10001A2A4(*(_DWORD *)(a1 + 48));
  unsigned int v3 = v2;
  if (v2)
  {
    uint64_t v4 = *(const __CFString **)(a1 + 32);
    if (v4)
    {
      sub_100034D5C(v2, v4);
      *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0;
      if (qword_1000DBB98 != -1) {
        dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
      }
      BOOL v5 = (os_log_s *)(id)qword_1000DBB90;
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v17 = 0LL;
        unsigned int v6 = sub_100053B4C(1);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v7 = v6;
        }
        else {
          uint64_t v7 = v6 & 0xFFFFFFFE;
        }
        if ((_DWORD)v7)
        {
          *(_DWORD *)unsigned int v16 = 138412290;
          *(void *)&v16[4] = v3;
          uint64_t v8 = (const char *)_os_log_send_and_compose_impl( v7,  &v17,  0LL,  0LL,  &_mh_execute_header,  v5,  0LL,  "Removed Syncservice from the session %@",  v16,  12);
          uint64_t v9 = (char *)v8;
          if (v8) {
            sub_100053B7C(v8);
          }
        }

        else
        {
          uint64_t v9 = 0LL;
        }

        free(v9);
      }
    }

    unsigned int v10 = (void *)objc_claimAutoreleasedReturnValue(-[__CFDictionary objectForKey:](v3, "objectForKey:", kUMUserSessionIDKey));
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v11 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)unsigned int v16 = 0LL;
      LODWORD(v12) = sub_100053B4C(1);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v12 = v12;
      }
      else {
        uint64_t v12 = v12 & 0xFFFFFFFE;
      }
      if ((_DWORD)v12)
      {
        uint64_t v13 = v11;
        unsigned int v14 = [v10 intValue];
        LODWORD(v17) = 67109120;
        HIDWORD(v17) = v14;
        uint64_t v15 = (char *)_os_log_send_and_compose_impl( v12,  v16,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "Added MachService to User Session with ID %d",  &v17);

        if (v15) {
          sub_100053B7C(v15);
        }
      }

      else
      {
        uint64_t v15 = 0LL;
      }

      free(v15);
    }
  }
}

void sub_10006D150( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10006D168(uint64_t a1)
{
  if (qword_1000DBB98 != -1) {
    dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
  }
  uint64_t v2 = (os_log_s *)(id)qword_1000DBB90;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = 0LL;
    unsigned int v3 = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      int v5 = *(_DWORD *)(a1 + 40);
      int v18 = 67109120;
      int v19 = v5;
      unsigned int v6 = (const char *)_os_log_send_and_compose_impl( v4,  &v17,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  " TRYING to LOAD  SYNC BUBBLE FOR uid %d:",  &v18);
      uint64_t v7 = (char *)v6;
      if (v6) {
        sub_100053B7C(v6);
      }
    }

    else
    {
      uint64_t v7 = 0LL;
    }

    free(v7);
  }

  if (sub_100031B4C(*(unsigned int *)(a1 + 40)))
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v8 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = 0LL;
      unsigned int v9 = sub_100053B4C(1);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = v9 & 0xFFFFFFFE;
      }
      if ((_DWORD)v10)
      {
        int v11 = *(_DWORD *)(a1 + 40);
        int v18 = 67109120;
        int v19 = v11;
        uint64_t v12 = (const char *)_os_log_send_and_compose_impl( v10,  &v17,  0LL,  0LL,  &_mh_execute_header,  v8,  0LL,  "FAILURE TO LOAD SYNC BUBBLE FOR uid %d:",  &v18);
        goto LABEL_29;
      }

      goto LABEL_31;
    }
  }

  else
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v8 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = 0LL;
      unsigned int v13 = sub_100053B4C(1);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v14 = v13;
      }
      else {
        uint64_t v14 = v13 & 0xFFFFFFFE;
      }
      if ((_DWORD)v14)
      {
        int v15 = *(_DWORD *)(a1 + 40);
        int v18 = 67109120;
        int v19 = v15;
        uint64_t v12 = (const char *)_os_log_send_and_compose_impl( v14,  &v17,  0LL,  0LL,  &_mh_execute_header,  v8,  0LL,  "SUCCESSFUL LOAD  OF SYNC BUBBLE FOR uid %d:",  &v18);
LABEL_29:
        unsigned int v16 = (char *)v12;
        if (v12) {
          sub_100053B7C(v12);
        }
        goto LABEL_32;
      }

void sub_10006D588( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10006D5A0(uint64_t a1)
{
  if (qword_1000DBB98 != -1) {
    dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
  }
  uint64_t v2 = (os_log_s *)(id)qword_1000DBB90;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = 0LL;
    unsigned int v3 = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      int v5 = *(_DWORD *)(a1 + 40);
      int v18 = 67109120;
      int v19 = v5;
      unsigned int v6 = (const char *)_os_log_send_and_compose_impl( v4,  &v17,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  " TRYING to LOAD  SYNC BUBBLE FOR uid %d:",  &v18);
      uint64_t v7 = (char *)v6;
      if (v6) {
        sub_100053B7C(v6);
      }
    }

    else
    {
      uint64_t v7 = 0LL;
    }

    free(v7);
  }

  if (sub_10002C7F8(*(unsigned int *)(a1 + 40), 1))
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v8 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = 0LL;
      unsigned int v9 = sub_100053B4C(1);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = v9 & 0xFFFFFFFE;
      }
      if ((_DWORD)v10)
      {
        int v11 = *(_DWORD *)(a1 + 40);
        int v18 = 67109120;
        int v19 = v11;
        uint64_t v12 = (const char *)_os_log_send_and_compose_impl( v10,  &v17,  0LL,  0LL,  &_mh_execute_header,  v8,  0LL,  "FAILURE TO LOAD SYNC BUBBLE FOR uid %d:",  &v18);
        goto LABEL_29;
      }

      goto LABEL_31;
    }
  }

  else
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v8 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = 0LL;
      unsigned int v13 = sub_100053B4C(1);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v14 = v13;
      }
      else {
        uint64_t v14 = v13 & 0xFFFFFFFE;
      }
      if ((_DWORD)v14)
      {
        int v15 = *(_DWORD *)(a1 + 40);
        int v18 = 67109120;
        int v19 = v15;
        uint64_t v12 = (const char *)_os_log_send_and_compose_impl( v14,  &v17,  0LL,  0LL,  &_mh_execute_header,  v8,  0LL,  "SUCCESSFUL LOAD  OF SYNC BUBBLE FOR uid %d:",  &v18);
LABEL_29:
        unsigned int v16 = (char *)v12;
        if (v12) {
          sub_100053B7C(v12);
        }
        goto LABEL_32;
      }

void sub_10006D9C4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10006D9DC(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 40))
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v2 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v22 = 0LL;
      unsigned int v3 = sub_100053B4C(1);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v4 = v3;
      }
      else {
        uint64_t v4 = v3 & 0xFFFFFFFE;
      }
      if ((_DWORD)v4)
      {
        LOWORD(v21) = 0;
        int v5 = (const char *)_os_log_send_and_compose_impl( v4,  &v22,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "TRYING to Setup Test for EDUMode",  &v21,  2,  v21);
        goto LABEL_18;
      }

      goto LABEL_20;
    }
  }

  else
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v2 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v22 = 0LL;
      unsigned int v6 = sub_100053B4C(1);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v7 = v6;
      }
      else {
        uint64_t v7 = v6 & 0xFFFFFFFE;
      }
      if ((_DWORD)v7)
      {
        LOWORD(v21) = 0;
        int v5 = (const char *)_os_log_send_and_compose_impl( v7,  &v22,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "TRYING to Clear TestSetup for EDUMode",  &v21,  2,  v21);
LABEL_18:
        uint64_t v8 = (char *)v5;
        if (v5) {
          sub_100053B7C(v5);
        }
        goto LABEL_21;
      }

LABEL_57:
    int v19 = (char *)v12;
    if (v12) {
      sub_100053B7C(v12);
    }
    goto LABEL_60;
  }

  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
  if (!*(_BYTE *)(a1 + 40))
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    unsigned int v9 = (os_log_s *)(id)qword_1000DBB90;
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_61;
    }
    uint64_t v22 = 0LL;
    unsigned int v15 = sub_100053B4C(1);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v15 & 0xFFFFFFFE;
    }
    if (!(_DWORD)v16) {
      goto LABEL_59;
    }
    LOWORD(v21) = 0;
    LODWORD(v20) = 2;
    uint64_t v12 = (const char *)_os_log_send_and_compose_impl( v16,  &v22,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "SUCCESSFUL Internal test Cleared",  &v21,  v20,  v21);
    goto LABEL_57;
  }

  if (qword_1000DBB98 != -1) {
    dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
  }
  unsigned int v9 = (os_log_s *)(id)qword_1000DBB90;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v22 = 0LL;
    unsigned int v10 = sub_100053B4C(1);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v11 = v10;
    }
    else {
      uint64_t v11 = v10 & 0xFFFFFFFE;
    }
    if ((_DWORD)v11)
    {
      LOWORD(v21) = 0;
      LODWORD(v20) = 2;
      uint64_t v12 = (const char *)_os_log_send_and_compose_impl( v11,  &v22,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "SUCCESSFUL Internal test setup",  &v21,  v20,  v21);
      goto LABEL_57;
    }

    uint64_t result = 0LL;
    if (a2) {
      *a2 = v19;
    }
    return result;
  }

  if (qword_1000DBBD8 != -1) {
    dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
  }
  uint64_t v24 = (os_log_s *)(id)qword_1000DBBD0;
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    v31[0] = 0LL;
    uint64_t v25 = sub_100053B4C(1);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v26 = v25;
    }
    else {
      uint64_t v26 = v25 & 0xFFFFFFFE;
    }
    if ((_DWORD)v26)
    {
      *(_DWORD *)uint64_t v32 = 136315138;
      *(void *)&v32[4] = v35;
      unsigned int v27 = (const char *)_os_log_send_and_compose_impl( v26,  v31,  0LL,  0LL,  &_mh_execute_header,  v24,  0LL,  "Deleted Volume:%s",  v32);
      uint64_t v28 = (char *)v27;
      if (v27) {
        sub_100053B7C(v27);
      }
    }

    else
    {
      uint64_t v28 = 0LL;
    }

    free(v28);
  }

  return 1LL;
}

LABEL_59:
    int v19 = 0LL;
LABEL_60:
    free(v19);
  }

void sub_10006DF58( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10006DF70(uint64_t a1)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = dword_1000DACBC;
  if (qword_1000DBB98 != -1) {
    dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
  }
  uint64_t v2 = (os_log_s *)(id)qword_1000DBB90;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = 0LL;
    unsigned int v3 = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      int v5 = *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
      v9[0] = 67109120;
      v9[1] = v5;
      unsigned int v6 = (const char *)_os_log_send_and_compose_impl( v4,  &v8,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "handle_GetSyncBubbleID:%d",  v9);
      uint64_t v7 = (char *)v6;
      if (v6) {
        sub_100053B7C(v6);
      }
    }

    else
    {
      uint64_t v7 = 0LL;
    }

    free(v7);
  }
}

void sub_10006E2B8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_10006E2DC(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) objectForKey:kUMUserSessionIDKey]);
  unsigned int v3 = (void *)sub_10001A2A4((int)[v2 intValue]);
  uint64_t v4 = v3;
  if (v3)
  {
    int v5 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKey:kUMUserSessionSyncMachServicesKey]);
    if (v5)
    {
      if (qword_1000DBB98 != -1) {
        dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
      }
      unsigned int v6 = (os_log_s *)(id)qword_1000DBB90;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        v22[0] = 0LL;
        unsigned int v7 = sub_100053B4C(1);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v8 = v7;
        }
        else {
          uint64_t v8 = v7 & 0xFFFFFFFE;
        }
        if ((_DWORD)v8)
        {
          *(_DWORD *)uint64_t v23 = 138412290;
          *(void *)&v23[4] = v5;
          uint64_t v9 = (const char *)_os_log_send_and_compose_impl( v8,  v22,  0LL,  0LL,  &_mh_execute_header,  v6,  0LL,  "Sending machservice list %@",  v23,  12);
          unsigned int v10 = (char *)v9;
          if (v9) {
            sub_100053B7C(v9);
          }
        }

        else
        {
          unsigned int v10 = 0LL;
        }

        free(v10);
      }

      uint64_t v15 = objc_claimAutoreleasedReturnValue(+[NSArray arrayWithArray:](&OBJC_CLASS___NSArray, "arrayWithArray:", v5));
      uint64_t v16 = *(void *)(*(void *)(a1 + 40) + 8LL);
      unsigned int v17 = *(void **)(v16 + 40);
      *(void *)(v16 + 40) = v15;

      *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 0;
      if (qword_1000DBB98 != -1) {
        dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
      }
      uint64_t v11 = (os_log_s *)(id)qword_1000DBB90;
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_34;
      }
      v22[0] = 0LL;
      unsigned int v18 = sub_100053B4C(1);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v19 = v18;
      }
      else {
        uint64_t v19 = v18 & 0xFFFFFFFE;
      }
      if ((_DWORD)v19)
      {
        *(_DWORD *)uint64_t v23 = 138412290;
        *(void *)&v23[4] = v4;
        LODWORD(v21) = 12;
        uint64_t v14 = (const char *)_os_log_send_and_compose_impl( v19,  v22,  0LL,  0LL,  &_mh_execute_header,  v11,  0LL,  "AddSyncservice: to the session %@",  v23,  v21,  v22[0]);
LABEL_30:
        uint64_t v20 = (char *)v14;
        if (v14) {
          sub_100053B7C(v14);
        }
        goto LABEL_33;
      }
    }

    else
    {
      if (qword_1000DBB98 != -1) {
        dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
      }
      uint64_t v11 = (os_log_s *)(id)qword_1000DBB90;
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_34;
      }
      *(void *)uint64_t v23 = 0LL;
      unsigned int v12 = sub_100053B4C(1);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v13 = v12;
      }
      else {
        uint64_t v13 = v12 & 0xFFFFFFFE;
      }
      if ((_DWORD)v13)
      {
        LOWORD(v22[0]) = 0;
        uint64_t v14 = (const char *)_os_log_send_and_compose_impl( v13,  v23,  0LL,  0LL,  &_mh_execute_header,  v11,  0LL,  "Empty content in machservice list",  v22,  2,  v22[0]);
        goto LABEL_30;
      }
    }

    uint64_t v20 = 0LL;
LABEL_33:
    free(v20);
LABEL_34:
  }
}

void sub_10006E778( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10006E790(uint64_t a1)
{
  if (qword_1000DBCF8)
  {
    uint64_t v2 = objc_claimAutoreleasedReturnValue(+[NSArray arrayWithArray:](&OBJC_CLASS___NSArray, "arrayWithArray:"));
    uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8LL);
    uint64_t v4 = *(void **)(v3 + 40);
    *(void *)(v3 + 40) = v2;
  }

void sub_10006E928( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10006E940(uint64_t a1)
{
  if (qword_1000DBCF8)
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v2 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = 0LL;
      unsigned int v3 = sub_100053B4C(1);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v4 = v3;
      }
      else {
        uint64_t v4 = v3 & 0xFFFFFFFE;
      }
      if ((_DWORD)v4)
      {
        __int16 v13 = 0;
        int v5 = (const char *)_os_log_send_and_compose_impl( v4,  &v14,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "Trying to Clear SYNC BUBBLE TABLE",  &v13,  2);
        unsigned int v6 = (char *)v5;
        if (v5) {
          sub_100053B7C(v5);
        }
      }

      else
      {
        unsigned int v6 = 0LL;
      }

      free(v6);
    }

    if (CFArrayGetCount((CFArrayRef)qword_1000DBCF8) >= 1)
    {
      CFArrayRemoveAllValues((CFMutableArrayRef)qword_1000DBCF8);
      if (qword_1000DBCF8) {
        CFRelease((CFTypeRef)qword_1000DBCF8);
      }
      qword_1000DBCF8 = 0LL;
      if (qword_1000DBB98 != -1) {
        dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
      }
      unsigned int v7 = (os_log_s *)(id)qword_1000DBB90;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v14 = 0LL;
        unsigned int v8 = sub_100053B4C(1);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v9 = v8;
        }
        else {
          uint64_t v9 = v8 & 0xFFFFFFFE;
        }
        if ((_DWORD)v9)
        {
          __int16 v13 = 0;
          LODWORD(v12) = 2;
          unsigned int v10 = (const char *)_os_log_send_and_compose_impl( v9,  &v14,  0LL,  0LL,  &_mh_execute_header,  v7,  0LL,  "CLEARED THE SYNC BUBBLE LIST",  &v13,  v12);
          uint64_t v11 = (char *)v10;
          if (v10) {
            sub_100053B7C(v10);
          }
        }

        else
        {
          uint64_t v11 = 0LL;
        }

        free(v11);
      }
    }

    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
  }

void sub_10006EDC0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10006EDE4(uint64_t a1)
{
  if (qword_1000DBB98 != -1) {
    dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
  }
  uint64_t v2 = (os_log_s *)(id)qword_1000DBB90;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = 0LL;
    unsigned int v3 = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      __int16 v11 = 0;
      int v5 = (const char *)_os_log_send_and_compose_impl( v4,  &v12,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "Listing swichblock",  &v11,  2);
      unsigned int v6 = (char *)v5;
      if (v5) {
        sub_100053B7C(v5);
      }
    }

    else
    {
      unsigned int v6 = 0LL;
    }

    free(v6);
  }

  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(+[RDServer sharedServer](&OBJC_CLASS___RDServer, "sharedServer"));
  uint64_t v8 = objc_claimAutoreleasedReturnValue([v7 fetchUserBlockTaskList]);
  uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8LL);
  unsigned int v10 = *(void **)(v9 + 40);
  *(void *)(v9 + 40) = v8;

  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL)) {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0;
  }
}

void sub_10006F098( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10006F0B0(uint64_t a1)
{
  if (qword_1000DBD00)
  {
    uint64_t v2 = objc_claimAutoreleasedReturnValue(+[NSArray arrayWithArray:](&OBJC_CLASS___NSArray, "arrayWithArray:"));
    uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8LL);
    uint64_t v4 = *(void **)(v3 + 40);
    *(void *)(v3 + 40) = v2;
  }

void sub_10006F258( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10006F270(uint64_t a1)
{
  uint64_t v2 = (const __CFDictionary *)sub_10001A2A4(*(_DWORD *)(a1 + 40));
  uint64_t v3 = v2;
  if (v2) {
    BOOL v4 = byte_1000DACB8 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4 && sub_100079FB8(v2, 0LL, 0LL, 0) == 1)
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    int v5 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = 0LL;
      unsigned int v6 = sub_100053B4C(1);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v7 = v6;
      }
      else {
        uint64_t v7 = v6 & 0xFFFFFFFE;
      }
      if ((_DWORD)v7)
      {
        int v8 = *(_DWORD *)(a1 + 40);
        v12[0] = 67109120;
        v12[1] = v8;
        uint64_t v9 = (const char *)_os_log_send_and_compose_impl( v7,  &v11,  0LL,  0LL,  &_mh_execute_header,  v5,  0LL,  "User Volume for uid %d mounted",  v12);
        unsigned int v10 = (char *)v9;
        if (v9) {
          sub_100053B7C(v9);
        }
      }

      else
      {
        unsigned int v10 = 0LL;
      }

      free(v10);
    }
  }
}

void sub_10006F548( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10006F560(uint64_t a1)
{
  uint64_t v2 = (const __CFDictionary *)sub_10001A2A4(*(_DWORD *)(a1 + 40));
  uint64_t v3 = v2;
  if (v2) {
    BOOL v4 = byte_1000DACB8 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4 && sub_10007B85C(v2, 0LL, 0LL, 0x80000) == 1)
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    int v5 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = 0LL;
      unsigned int v6 = sub_100053B4C(1);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v7 = v6;
      }
      else {
        uint64_t v7 = v6 & 0xFFFFFFFE;
      }
      if ((_DWORD)v7)
      {
        int v8 = *(_DWORD *)(a1 + 40);
        v12[0] = 67109120;
        v12[1] = v8;
        uint64_t v9 = (const char *)_os_log_send_and_compose_impl( v7,  &v11,  0LL,  0LL,  &_mh_execute_header,  v5,  0LL,  "User Volume for uid %d mounted",  v12);
        unsigned int v10 = (char *)v9;
        if (v9) {
          sub_100053B7C(v9);
        }
      }

      else
      {
        unsigned int v10 = 0LL;
      }

      free(v10);
    }
  }
}

void sub_10006F8A0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t (**sub_10006F8C4(void *a1))(id, void)
{
  uint64_t result = (uint64_t (**)(id, void))sub_10002EA74();
  if ((_DWORD)result)
  {
    *(_DWORD *)(*(void *)(a1[5] + 8LL) + 24LL) = 0;
  }

  else
  {
    uint64_t v3 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  22LL,  0LL));
    uint64_t v4 = *(void *)(a1[6] + 8LL);
    int v5 = *(void **)(v4 + 40);
    *(void *)(v4 + 40) = v3;

    uint64_t result = (uint64_t (**)(id, void))a1[4];
    if (result) {
      return (uint64_t (**)(id, void))result[2](result, *(void *)(*(void *)(a1[6] + 8LL) + 40LL));
    }
  }

  return result;
}

void sub_10006FAA4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10006FABC(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 40))
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v2 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = 0LL;
      unsigned int v3 = sub_100053B4C(1);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v4 = v3;
      }
      else {
        uint64_t v4 = v3 & 0xFFFFFFFE;
      }
      if ((_DWORD)v4)
      {
        LOWORD(v22) = 0;
        int v5 = (const char *)_os_log_send_and_compose_impl( v4,  &v21,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "Called to set Network BK_SYS to true",  &v22,  2);
        goto LABEL_18;
      }

      goto LABEL_20;
    }
  }

  else
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v2 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = 0LL;
      unsigned int v6 = sub_100053B4C(1);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v7 = v6;
      }
      else {
        uint64_t v7 = v6 & 0xFFFFFFFE;
      }
      if ((_DWORD)v7)
      {
        LOWORD(v22) = 0;
        int v5 = (const char *)_os_log_send_and_compose_impl( v7,  &v21,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "Called to set Network BK_SYS to false",  &v22,  2);
LABEL_18:
        int v8 = (char *)v5;
        if (v5) {
          sub_100053B7C(v5);
        }
        goto LABEL_21;
      }

void sub_1000702E4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31, uint64_t a32, uint64_t a33, uint64_t a34, char a35)
{
}

void sub_10007034C(uint64_t a1)
{
  kern_return_t v21;
  kern_return_t v22;
  os_log_s *v23;
  unsigned int v24;
  uint64_t v25;
  const char *v26;
  char *v27;
  os_log_s *v28;
  unsigned int v29;
  uint64_t v30;
  unsigned int v31;
  const char *v32;
  char *v33;
  os_log_s *v34;
  unsigned int v35;
  uint64_t v36;
  unsigned int v37;
  const char *v38;
  char *v39;
  os_log_s *v40;
  unsigned int v41;
  uint64_t v42;
  const char *v43;
  uint64_t v44;
  uint64_t v45;
  UMPersonaMachPort *v46;
  uint64_t v47;
  void *v48;
  unsigned int v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  int v53;
  unsigned int v54;
  uint64_t v2 = *(void **)(a1 + 32);
  if (!v2)
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    int v8 = (os_log_s *)(id)qword_1000DBB90;
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_32;
    }
    __int128 v52 = 0LL;
    unsigned int v9 = sub_100053B4C(1);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = v9 & 0xFFFFFFFE;
    }
    if ((_DWORD)v10)
    {
      unsigned int v11 = *(_DWORD *)(a1 + 88);
      __int128 v53 = 67109120;
      __int128 v54 = v11;
      int v12 = (const char *)_os_log_send_and_compose_impl( v10,  &v52,  0LL,  0LL,  &_mh_execute_header,  v8,  2LL,  "replacePersonaVoucher with no Source Voucher Port from pid:%d",  &v53);
      goto LABEL_28;
    }

LABEL_94:
    __int128 v51 = 0LL;
LABEL_95:
    free(v51);
LABEL_79:

    goto LABEL_80;
  }

  if (qword_1000DBB98 != -1) {
    dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
  }
  uint64_t v34 = (os_log_s *)(id)qword_1000DBB90;
  if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
  {
    __int128 v52 = 0LL;
    uint64_t v35 = sub_100053B4C(1);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG)) {
      uint64_t v36 = v35;
    }
    else {
      uint64_t v36 = v35 & 0xFFFFFFFE;
    }
    if ((_DWORD)v36)
    {
      __int16 v37 = *(_DWORD *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL);
      __int128 v53 = 67109120;
      __int128 v54 = v37;
      uint64_t v38 = (const char *)_os_log_send_and_compose_impl( v36,  &v52,  0LL,  0LL,  &_mh_execute_header,  v34,  2LL,  "kernel replacement voucher port:%d",  &v53);
      __int128 v39 = (char *)v38;
      if (v38) {
        sub_100053B7C(v38);
      }
    }

    else
    {
      __int128 v39 = 0LL;
    }

    free(v39);
  }

  __int128 v46 = -[UMPersonaMachPort initWithMachPort:options:]( objc_alloc(&OBJC_CLASS___UMPersonaMachPort),  "initWithMachPort:options:",  *(unsigned int *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL),  1LL);
  __int128 v47 = *(void *)(*(void *)(a1 + 80) + 8LL);
  __int128 v48 = *(void **)(v47 + 40);
  *(void *)(v47 + 40) = v46;

  if (!*(void *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL))
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    __int128 v40 = (os_log_s *)(id)qword_1000DBB90;
    if (!os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_79;
    }
    __int128 v52 = 0LL;
    __int128 v49 = sub_100053B4C(1);
    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT)) {
      __int128 v50 = v49;
    }
    else {
      __int128 v50 = v49 & 0xFFFFFFFE;
    }
    if ((_DWORD)v50)
    {
      LOWORD(v53) = 0;
      __int128 v43 = (const char *)_os_log_send_and_compose_impl( v50,  &v52,  0LL,  0LL,  &_mh_execute_header,  v40,  0LL,  "failed to create transport for target port",  &v53,  2);
LABEL_92:
      __int128 v51 = (char *)v43;
      if (v43) {
        sub_100053B7C(v43);
      }
      goto LABEL_95;
    }

    goto LABEL_94;
  }

LABEL_80:
}

void sub_100070EAC(uint64_t a1)
{
  int v21 = 0;
  if (qword_1000DBB98 != -1) {
    dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
  }
  uint64_t v2 = (os_log_s *)(id)qword_1000DBB90;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v20 = 0LL;
    unsigned int v3 = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG)) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      int v5 = *(_DWORD *)(a1 + 40);
      int v22 = 67109120;
      int v23 = v5;
      unsigned int v6 = (const char *)_os_log_send_and_compose_impl( v4,  &v20,  0LL,  0LL,  &_mh_execute_header,  v2,  2LL,  "In UMSyncServer: fetchPersonaListforPid from pid:%d",  &v22);
      uint64_t v7 = (char *)v6;
      if (v6) {
        sub_100053B7C(v6);
      }
    }

    else
    {
      uint64_t v7 = 0LL;
    }

    free(v7);
  }

  int v8 = sub_100046664(*(unsigned int *)(a1 + 44), *(unsigned int *)(a1 + 48), *(unsigned int *)(a1 + 52));
  unsigned int v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
  id v10 = sub_1000494E0(v9, &v21);
  unsigned int v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
  if (v11)
  {
    int v12 = 0LL;
  }

  else
  {
    int v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  v21,  0LL));
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    unsigned int v13 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v20 = 0LL;
      unsigned int v14 = sub_100053B4C(1);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v15 = v14;
      }
      else {
        uint64_t v15 = v14 & 0xFFFFFFFE;
      }
      if ((_DWORD)v15)
      {
        int v16 = *(_DWORD *)(a1 + 40);
        int v22 = 67109120;
        int v23 = v16;
        uint64_t v17 = (const char *)_os_log_send_and_compose_impl( v15,  &v20,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "In UMSyncServer: No persona array OK:%d",  &v22);
        uint64_t v18 = (char *)v17;
        if (v17) {
          sub_100053B7C(v17);
        }
      }

      else
      {
        uint64_t v18 = 0LL;
      }

      free(v18);
    }
  }

  uint64_t v19 = *(void *)(a1 + 32);
  if (v19) {
    (*(void (**)(uint64_t, void *, void *))(v19 + 16))(v19, v11, v12);
  }
}

void sub_100071460( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_100071490(uint64_t a1)
{
  int v21 = 0;
  if (qword_1000DBB98 != -1) {
    dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
  }
  uint64_t v2 = (os_log_s *)(id)qword_1000DBB90;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v20 = 0LL;
    unsigned int v3 = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG)) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      int v5 = *(_DWORD *)(a1 + 48);
      int v22 = 67109120;
      int v23 = v5;
      unsigned int v6 = (const char *)_os_log_send_and_compose_impl( v4,  &v20,  0LL,  0LL,  &_mh_execute_header,  v2,  2LL,  "In UMSyncServer: fetchAllUsersPersonaListforPid entitlement OK:%d",  &v22);
      uint64_t v7 = (char *)v6;
      if (v6) {
        sub_100053B7C(v6);
      }
    }

    else
    {
      uint64_t v7 = 0LL;
    }

    free(v7);
  }

  int v8 = sub_1000494F4(&v21);
  unsigned int v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
  if (!v9)
  {
    uint64_t v10 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  v21,  0LL));
    uint64_t v11 = *(void *)(*(void *)(a1 + 40) + 8LL);
    int v12 = *(void **)(v11 + 40);
    *(void *)(v11 + 40) = v10;

    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    unsigned int v13 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v20 = 0LL;
      unsigned int v14 = sub_100053B4C(1);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v15 = v14;
      }
      else {
        uint64_t v15 = v14 & 0xFFFFFFFE;
      }
      if ((_DWORD)v15)
      {
        int v16 = *(_DWORD *)(a1 + 48);
        int v22 = 67109120;
        int v23 = v16;
        uint64_t v17 = (const char *)_os_log_send_and_compose_impl( v15,  &v20,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "In UMSyncServer: No persona array OK:%d",  &v22);
        uint64_t v18 = (char *)v17;
        if (v17) {
          sub_100053B7C(v17);
        }
      }

      else
      {
        uint64_t v18 = 0LL;
      }

      free(v18);
    }
  }

  uint64_t v19 = *(void *)(a1 + 32);
  if (v19) {
    (*(void (**)(uint64_t, void *, void))(v19 + 16))( v19,  v9,  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL));
  }
}

void sub_100071D80( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void sub_100071DB8(uint64_t a1)
{
  int v28 = 0;
  if (qword_1000DBB98 != -1) {
    dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
  }
  uint64_t v2 = (os_log_s *)(id)qword_1000DBB90;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v27 = 0LL;
    unsigned int v3 = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG)) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      int v5 = *(void **)(a1 + 32);
      int v6 = *(_DWORD *)(a1 + 56);
      int v7 = *(_DWORD *)(a1 + 60);
      int v29 = 138412802;
      id v30 = v5;
      __int16 v31 = 1024;
      int v32 = v6;
      __int16 v33 = 1024;
      int v34 = v7;
      int v8 = (const char *)_os_log_send_and_compose_impl( v4,  &v27,  0LL,  0LL,  &_mh_execute_header,  v2,  2LL,  "In UMSyncServer: entitlement OK, calling fetchPersonaSession with profileInfo:%@ for pid:%d with asid:%d",  &v29,  24);
      unsigned int v9 = (char *)v8;
      if (v8) {
        sub_100053B7C(v8);
      }
    }

    else
    {
      unsigned int v9 = 0LL;
    }

    free(v9);
  }

  uint64_t v10 = sub_100046664(*(unsigned int *)(a1 + 60), *(unsigned int *)(a1 + 64), *(unsigned int *)(a1 + 68));
  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
  id v12 = sub_100049504(*(void **)(a1 + 32), v11, &v28);
  unsigned int v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
  if (v13)
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    unsigned int v14 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v27 = 0LL;
      unsigned int v15 = sub_100053B4C(1);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG)) {
        uint64_t v16 = v15;
      }
      else {
        uint64_t v16 = v15 & 0xFFFFFFFE;
      }
      if ((_DWORD)v16)
      {
        int v29 = 138412290;
        id v30 = v13;
        LODWORD(v26) = 12;
        uint64_t v17 = (const char *)_os_log_send_and_compose_impl( v16,  &v27,  0LL,  0LL,  &_mh_execute_header,  v14,  2LL,  "fetchpersona:%@",  &v29,  v26);
        goto LABEL_29;
      }

      goto LABEL_31;
    }
  }

  else
  {
    uint64_t v18 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  v28,  0LL));
    uint64_t v19 = *(void *)(*(void *)(a1 + 48) + 8LL);
    uint64_t v20 = *(void **)(v19 + 40);
    *(void *)(v19 + 40) = v18;

    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    unsigned int v14 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v27 = 0LL;
      unsigned int v21 = sub_100053B4C(1);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG)) {
        uint64_t v22 = v21;
      }
      else {
        uint64_t v22 = v21 & 0xFFFFFFFE;
      }
      if ((_DWORD)v22)
      {
        int v23 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL);
        int v29 = 138412290;
        id v30 = v23;
        LODWORD(v26) = 12;
        uint64_t v17 = (const char *)_os_log_send_and_compose_impl( v22,  &v27,  0LL,  0LL,  &_mh_execute_header,  v14,  2LL,  "Fetch persona failed with error:%@",  &v29,  v26);
LABEL_29:
        uint64_t v24 = (char *)v17;
        if (v17) {
          sub_100053B7C(v17);
        }
        goto LABEL_32;
      }

uint64_t sub_10007232C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void sub_100072740( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void sub_100072778(uint64_t a1)
{
  int v28 = 2;
  if (qword_1000DBB98 != -1) {
    dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
  }
  uint64_t v2 = (os_log_s *)(id)qword_1000DBB90;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v27 = 0LL;
    unsigned int v3 = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      int v5 = *(void **)(a1 + 32);
      int v6 = *(_DWORD *)(a1 + 56);
      int v7 = *(_DWORD *)(a1 + 60);
      int v29 = 138412802;
      id v30 = v5;
      __int16 v31 = 1024;
      int v32 = v6;
      __int16 v33 = 1024;
      int v34 = v7;
      int v8 = (const char *)_os_log_send_and_compose_impl( v4,  &v27,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "In UMSyncServer: entitlement OK, calling bundleIdentifiersForPersona for profileInfo:%@ for p id:%d with asid:%d",  &v29,  24);
      unsigned int v9 = (char *)v8;
      if (v8) {
        sub_100053B7C(v8);
      }
    }

    else
    {
      unsigned int v9 = 0LL;
    }

    free(v9);
  }

  uint64_t v10 = sub_100046664(*(unsigned int *)(a1 + 60), *(unsigned int *)(a1 + 64), *(unsigned int *)(a1 + 68));
  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
  id v12 = sub_100049BF0(*(void **)(a1 + 32), v11, &v28);
  unsigned int v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
  if (v13)
  {
    int v28 = 0;
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    unsigned int v14 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v27 = 0LL;
      unsigned int v15 = sub_100053B4C(1);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v16 = v15;
      }
      else {
        uint64_t v16 = v15 & 0xFFFFFFFE;
      }
      if ((_DWORD)v16)
      {
        int v29 = 138412290;
        id v30 = v13;
        LODWORD(v26) = 12;
        uint64_t v17 = (const char *)_os_log_send_and_compose_impl( v16,  &v27,  0LL,  0LL,  &_mh_execute_header,  v14,  0LL,  "fetchBundleIdentifiersForPersona Success with array %@",  &v29,  v26);
        goto LABEL_29;
      }

      goto LABEL_31;
    }
  }

  else
  {
    uint64_t v18 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  v28,  0LL));
    uint64_t v19 = *(void *)(*(void *)(a1 + 48) + 8LL);
    uint64_t v20 = *(void **)(v19 + 40);
    *(void *)(v19 + 40) = v18;

    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    unsigned int v14 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v27 = 0LL;
      unsigned int v21 = sub_100053B4C(1);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v22 = v21;
      }
      else {
        uint64_t v22 = v21 & 0xFFFFFFFE;
      }
      if ((_DWORD)v22)
      {
        int v23 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL);
        int v29 = 138412290;
        id v30 = v23;
        LODWORD(v26) = 12;
        uint64_t v17 = (const char *)_os_log_send_and_compose_impl( v22,  &v27,  0LL,  0LL,  &_mh_execute_header,  v14,  0LL,  "fetchBundleIdentifiersForPersona failed with %@",  &v29,  v26);
LABEL_29:
        uint64_t v24 = (char *)v17;
        if (v17) {
          sub_100053B7C(v17);
        }
        goto LABEL_32;
      }

void sub_100073000( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void sub_100073040(uint64_t a1)
{
  if (qword_1000DBB98 != -1) {
    dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
  }
  uint64_t v2 = (os_log_s *)(id)qword_1000DBB90;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v27 = 0LL;
    unsigned int v3 = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      uint64_t v5 = *(void *)(a1 + 32);
      int v6 = *(_DWORD *)(a1 + 64);
      int v7 = *(_DWORD *)(a1 + 68);
      int v28 = 138412802;
      uint64_t v29 = v5;
      __int16 v30 = 1024;
      int v31 = v6;
      __int16 v32 = 1024;
      int v33 = v7;
      int v8 = (const char *)_os_log_send_and_compose_impl( v4,  &v27,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "In UMSyncServer: setBundlesIdentifiers for profileInfo:%@ for pid:%d with asid:%d",  &v28,  24);
      unsigned int v9 = (char *)v8;
      if (v8) {
        sub_100053B7C(v8);
      }
    }

    else
    {
      unsigned int v9 = 0LL;
    }

    free(v9);
  }

  uint64_t v10 = sub_100046664(*(unsigned int *)(a1 + 68), *(unsigned int *)(a1 + 72), *(unsigned int *)(a1 + 76));
  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
  int v12 = sub_100049570(*(const __CFDictionary **)(a1 + 32), *(const __CFArray **)(a1 + 40), v11);
  if (v12)
  {
    uint64_t v13 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  v12,  0LL));
    uint64_t v14 = *(void *)(*(void *)(a1 + 56) + 8LL);
    unsigned int v15 = *(void **)(v14 + 40);
    *(void *)(v14 + 40) = v13;

    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v16 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v27 = 0LL;
      unsigned int v17 = sub_100053B4C(1);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v18 = v17;
      }
      else {
        uint64_t v18 = v17 & 0xFFFFFFFE;
      }
      if ((_DWORD)v18)
      {
        uint64_t v19 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 40LL);
        int v28 = 138412290;
        uint64_t v29 = v19;
        LODWORD(v26) = 12;
        uint64_t v20 = (const char *)_os_log_send_and_compose_impl( v18,  &v27,  0LL,  0LL,  &_mh_execute_header,  v16,  0LL,  "Update bundle failed with error:%@",  &v28,  v26);
        goto LABEL_29;
      }

      goto LABEL_31;
    }
  }

  else
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v16 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v27 = 0LL;
      unsigned int v21 = sub_100053B4C(1);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v22 = v21;
      }
      else {
        uint64_t v22 = v21 & 0xFFFFFFFE;
      }
      if ((_DWORD)v22)
      {
        uint64_t v23 = *(void *)(a1 + 40);
        int v28 = 138412290;
        uint64_t v29 = v23;
        LODWORD(v26) = 12;
        uint64_t v20 = (const char *)_os_log_send_and_compose_impl( v22,  &v27,  0LL,  0LL,  &_mh_execute_header,  v16,  0LL,  "Update BundleIDS Succcess, new bundles:%@",  &v28,  v26);
LABEL_29:
        uint64_t v24 = (char *)v20;
        if (v20) {
          sub_100053B7C(v20);
        }
        goto LABEL_32;
      }

void sub_10007365C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void sub_10007368C(uint64_t a1)
{
  if (qword_1000DBB98 != -1) {
    dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
  }
  uint64_t v2 = (os_log_s *)(id)qword_1000DBB90;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v26[0] = 0LL;
    unsigned int v3 = sub_100053B4C(1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = v3 & 0xFFFFFFFE;
    }
    if ((_DWORD)v4)
    {
      uint64_t v5 = *(void *)(a1 + 32);
      int v6 = *(_DWORD *)(a1 + 56);
      *(_DWORD *)uint64_t v27 = 138412546;
      *(void *)&v27[4] = v5;
      __int16 v28 = 1024;
      int v29 = v6;
      int v7 = (const char *)_os_log_send_and_compose_impl( v4,  v26,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "Registering PersonaObserver with machService:%@ with asid:%d",  v27,  18);
      int v8 = (char *)v7;
      if (v7) {
        sub_100053B7C(v7);
      }
    }

    else
    {
      int v8 = 0LL;
    }

    free(v8);
  }

  unsigned int v9 = sub_100046664(*(unsigned int *)(a1 + 56), *(unsigned int *)(a1 + 60), *(unsigned int *)(a1 + 64));
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
  if (sub_10004AFA4(*(const __CFString **)(a1 + 32), v10))
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v11 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)uint64_t v27 = 0LL;
      unsigned int v12 = sub_100053B4C(1);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v13 = v12;
      }
      else {
        uint64_t v13 = v12 & 0xFFFFFFFE;
      }
      if ((_DWORD)v13)
      {
        LOWORD(v26[0]) = 0;
        LODWORD(v25) = 2;
        uint64_t v14 = (const char *)_os_log_send_and_compose_impl( v13,  v27,  0LL,  0LL,  &_mh_execute_header,  v11,  0LL,  "Successful Persona Observer registration of machServiceName",  v26,  v25);
        unsigned int v15 = (char *)v14;
        if (v14) {
          sub_100053B7C(v14);
        }
      }

      else
      {
        unsigned int v15 = 0LL;
      }

      free(v15);
    }
  }

  else
  {
    if (qword_1000DBB98 != -1) {
      dispatch_once(&qword_1000DBB98, &stru_1000CDAA0);
    }
    uint64_t v16 = (os_log_s *)(id)qword_1000DBB90;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      v26[0] = 0LL;
      unsigned int v17 = sub_100053B4C(1);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v18 = v17;
      }
      else {
        uint64_t v18 = v17 & 0xFFFFFFFE;
      }
      if ((_DWORD)v18)
      {
        uint64_t v19 = *(void *)(a1 + 32);
        *(_DWORD *)uint64_t v27 = 138412290;
        *(void *)&v27[4] = v19;
        LODWORD(v25) = 12;
        uint64_t v20 = (const char *)_os_log_send_and_compose_impl( v18,  v26,  0LL,  0LL,  &_mh_execute_header,  v16,  0LL,  "Failed to register Persona Observer:%@",  v27,  v25);
        unsigned int v21 = (char *)v20;
        if (v20) {
          sub_100053B7C(v20);
        }
      }

      else
      {
        unsigned int v21 = 0LL;
      }

      free(v21);
    }

    uint64_t v22 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  22LL,  0LL));
    uint64_t v23 = *(void *)(*(void *)(a1 + 48) + 8LL);
    uint64_t v11 = *(os_log_s **)(v23 + 40);
    *(void *)(v23 + 40) = v22;
  }

  uint64_t v24 = *(void *)(a1 + 40);
  if (v24) {
    (*(void (**)(uint64_t, void))(v24 + 16))( v24,  *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL));
  }
}

void sub_100073F30( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31)
{
}

void sub_100073F6C(uint64_t a1)
{
  uint64_t v2 = sub_100046664(*(unsigned int *)(a1 + 56), *(unsigned int *)(a1 + 60), *(unsigned int *)(a1 + 64));
  unsigned int v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  uint64_t v4 = *(void **)(a1 + 32);
  int v5 = *(_DWORD *)(a1 + 100);
  __int128 v6 = *(_OWORD *)(a1 + 84);
  v13[0] = *(_OWORD *)(a1 + 68);
  v13[1] = v6;
  CFStringRef v7 = sub_10004BE70(v4, v13, v5, v3);
  if (!v7)
  {
    int v8 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  *__error(),  0LL);
    uint64_t v9 = objc_claimAutoreleasedReturnValue(v8);
    uint64_t v10 = *(void *)(*(void *)(a1 + 48) + 8LL);
    uint64_t v11 = *(void **)(v10 + 40);
    *(void *)(v10 + 40) = v9;
  }

  uint64_t v12 = *(void *)(a1 + 40);
  if (v12) {
    (*(void (**)(uint64_t, CFStringRef, void))(v12 + 16))( v12,  v7,  *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL));
  }
  if (v7) {
    CFRelease(v7);
  }
}

id sub_100074054()
{
  io_registry_entry_t v0 = objc_opt_new(&OBJC_CLASS___UMSyncXPCListener);
  uint64_t v1 = (void *)qword_1000DBB88;
  qword_1000DBB88 = (uint64_t)v0;

  uint64_t v2 = -[NSXPCListener initWithMachServiceName:]( objc_alloc(&OBJC_CLASS___NSXPCListener),  "initWithMachServiceName:",  @"com.apple.mobile.usermanagerd.xpc");
  unsigned int v3 = (void *)qword_1000DBB80;
  qword_1000DBB80 = (uint64_t)v2;

  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([(id)qword_1000DBB80 _xpcConnection]);
  __xpc_connection_set_logging(v4, 0LL);

  [(id)qword_1000DBB80 setDelegate:qword_1000DBB88];
  return [(id)qword_1000DBB80 resume];
}

void sub_1000740E4(id a1)
{
  os_log_t v1 = os_log_create(off_1000DAE70, "legacy");
  uint64_t v2 = (void *)qword_1000DBB90;
  qword_1000DBB90 = (uint64_t)v1;
}

void sub_100074118(id a1)
{
  os_log_t v1 = os_log_create(off_1000DAE70, "user");
  uint64_t v2 = (void *)qword_1000DBBA0;
  qword_1000DBBA0 = (uint64_t)v1;
}

void sub_10007414C(id a1)
{
  os_log_t v1 = os_log_create(off_1000DAE70, "persona");
  uint64_t v2 = (void *)qword_1000DBBB0;
  qword_1000DBBB0 = (uint64_t)v1;
}

id sub_1000741F8(id result, const char *a2)
{
  if (result) {
    return objc_getProperty(result, a2, 24LL, 1);
  }
  return result;
}

void sub_10007420C(void *a1, char *newValue)
{
  if (a1) {
    objc_setProperty_atomic_copy(a1, newValue, newValue, 24LL);
  }
}

LABEL_113:
  uint64_t v24 = 0;
LABEL_24:
  if (kernelID != v24) {
    goto LABEL_29;
  }
  if (!self)
  {
    p_isa = (id *)&v8->super.isa;
    if (!v8)
    {
      uint64_t v38 = 0;
      unsigned int v117 = 0LL;
      uint64_t v123 = 0LL;
      __int128 v44 = 0;
      unsigned int v114 = 0LL;
      uint64_t v120 = 0LL;
      LODWORD(v143) = 0;
      id v113 = 0LL;
      uint64_t v116 = 0LL;
      HIDWORD(v145) = 1;
      goto LABEL_211;
    }

    uint64_t v123 = 0LL;
    HIDWORD(v145) = 1;
    unsigned int v117 = v8->_nickname;
    if (!v117)
    {
      uint64_t v38 = 0;
      unsigned int v117 = 0LL;
      goto LABEL_172;
    }

    uint64_t v26 = 0LL;
    goto LABEL_117;
  }

  uint64_t v25 = self->_nickname;
  if (!v25)
  {
    if (!v8)
    {
      uint64_t v120 = self->_bundleIDs;
      if (v120)
      {
        unsigned int v122 = self->_bundleIDs;
        uint64_t v123 = 0LL;
        uint64_t v38 = 0;
        unsigned int v117 = 0LL;
        HIDWORD(v144) = 0;
        bundleIDs = 0LL;
        HIDWORD(v145) = 1;
        goto LABEL_133;
      }

      uint64_t v38 = 0;
      unsigned int v117 = 0LL;
      uint64_t v123 = 0LL;
      HIDWORD(v145) = 1;
LABEL_183:
      uint64_t v116 = self->_observers;
      if (v116)
      {
        unsigned int v119 = self->_observers;
        uint64_t v120 = 0LL;
        __int128 v44 = 0;
        unsigned int v114 = 0LL;
        HIDWORD(v143) = 0;
        observers = 0LL;
        HIDWORD(v144) = 1;
        goto LABEL_148;
      }

      __int128 v44 = 0;
      unsigned int v114 = 0LL;
      uint64_t v120 = 0LL;
      HIDWORD(v144) = 1;
LABEL_191:
      LODWORD(v145) = v38;
      uint64_t v143 = 0x100000000LL;
      LODWORD(v144) = v44;
      uint64_t v116 = 0LL;
      id v113 = 0LL;
      if (self->_isDeleting)
      {
        id v149 = 1;
        *(_DWORD *)&v134[16] = 1;
        *(void *)uint64_t v134 = 1LL;
        id v113 = 0LL;
        uint64_t v13 = 0;
        *(void *)&v134[8] = 0LL;
        int v142 = 0LL;
        uint64_t v141 = 0LL;
        uint64_t v14 = 0;
        uint64_t v140 = 0LL;
        unsigned int v15 = 0;
        uint64_t v139 = 0LL;
        id v138 = 0LL;
        id v133 = 0;
        unsigned int v137 = 0LL;
        uint64_t v16 = 0;
        id v136 = 0LL;
        unsigned int v17 = 0;
        id v135 = 0LL;
        uint64_t v18 = 0;
        uint64_t v19 = 0;
        uint64_t v20 = 0;
        goto LABEL_30;
      }

      goto LABEL_193;
    }

    uint64_t v35 = v8->_nickname;
    if (!v35)
    {
      p_bundleIDs = &self->_bundleIDs;
      __int128 v40 = self->_bundleIDs;
      uint64_t v38 = 0;
      unsigned int v117 = 0LL;
      if (v40)
      {
        uint64_t v120 = v40;
        HIDWORD(v145) = 1;
        uint64_t v123 = 0LL;
        HIDWORD(v144) = 0;
LABEL_131:
        unsigned int v122 = *p_bundleIDs;
LABEL_132:
        bundleIDs = v8->_bundleIDs;
        goto LABEL_133;
      }

      HIDWORD(v145) = 1;
      uint64_t v123 = 0LL;
LABEL_129:
      __int128 v41 = v8->_bundleIDs;
      if (!v41)
      {
        p_observers = &self->_observers;
        __int128 v44 = 0;
        HIDWORD(v144) = 1;
        uint64_t v116 = self->_observers;
        unsigned int v114 = 0LL;
        if (v116)
        {
          uint64_t v120 = 0LL;
          HIDWORD(v143) = 0;
LABEL_146:
          unsigned int v119 = *p_observers;
LABEL_147:
          observers = v8->_observers;
          goto LABEL_148;
        }

        uint64_t v120 = 0LL;
LABEL_144:
        __int128 v46 = v8->_observers;
        if (!v46)
        {
          uint64_t v116 = 0LL;
          id v113 = 0LL;
          isDeleting = self->_isDeleting;
          uint64_t v143 = 0x100000000LL;
          goto LABEL_155;
        }

        id v113 = v46;
        uint64_t v116 = 0LL;
        p_observers = &self->_observers;
        HIDWORD(v143) = 1;
        goto LABEL_146;
      }

      unsigned int v114 = v41;
      uint64_t v120 = 0LL;
      p_bundleIDs = &self->_bundleIDs;
      HIDWORD(v144) = 1;
      goto LABEL_131;
    }

    unsigned int v117 = v35;
    uint64_t v26 = self->_nickname;
    uint64_t v123 = 0LL;
    HIDWORD(v145) = 1;
    goto LABEL_117;
  }

  uint64_t v123 = v25;
  uint64_t v26 = self->_nickname;
  HIDWORD(v145) = 0;
  if (v8)
  {
LABEL_117:
    uint64_t v125 = v26;
    nickname = v8->_nickname;
    goto LABEL_118;
  }

  uint64_t v125 = v26;
  nickname = 0LL;
LABEL_118:
  id v121 = nickname;
  if (!-[NSString isEqual:](v125, "isEqual:"))
  {
    unsigned int v144 = 0LL;
    memset(v134, 0, sizeof(v134));
    uint64_t v143 = 0LL;
    int v142 = 0LL;
    uint64_t v141 = 0LL;
    uint64_t v14 = 0;
    uint64_t v140 = 0LL;
    unsigned int v15 = 0;
    uint64_t v139 = 0LL;
    id v138 = 0LL;
    id v133 = 0;
    unsigned int v137 = 0LL;
    uint64_t v16 = 0;
    id v136 = 0LL;
    unsigned int v17 = 0;
    id v135 = 0LL;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v13 = 0;
    id v149 = 1;
    LODWORD(v145) = 1;
    goto LABEL_30;
  }

  if (!self)
  {
    uint64_t v38 = 1;
    p_isa = (id *)&v8->super.isa;
    if (!v8)
    {
      __int128 v44 = 0;
      unsigned int v114 = 0LL;
      uint64_t v120 = 0LL;
      LODWORD(v143) = 0;
      id v113 = 0LL;
      uint64_t v116 = 0LL;
LABEL_211:
      HIDWORD(v144) = 1;
      goto LABEL_212;
    }

LABEL_213:
        int v131 = 0LL;
        uint64_t v129 = 0LL;
        int v142 = 0x100000000LL;
        goto LABEL_214;
      }

      unsigned int v119 = 0LL;
      int v8 = (UMDPersonaManifestPersona *)p_isa;
      goto LABEL_147;
    }

    unsigned int v122 = 0LL;
    int v8 = (UMDPersonaManifestPersona *)p_isa;
    goto LABEL_132;
  }

  __int16 v37 = self->_bundleIDs;
  if (!v37)
  {
    uint64_t v38 = 1;
    if (!v8) {
      goto LABEL_183;
    }
    goto LABEL_129;
  }

  uint64_t v120 = v37;
  HIDWORD(v144) = 0;
  uint64_t v38 = 1;
  unsigned int v122 = self->_bundleIDs;
  if (v8) {
    goto LABEL_132;
  }
  bundleIDs = 0LL;
LABEL_133:
  uint64_t v118 = bundleIDs;
  if (!-[NSSet isEqual:](v122, "isEqual:", v118))
  {
    LODWORD(v145) = v38;
    *(void *)uint64_t v134 = 0LL;
    *(void *)&v134[8] = 0LL;
    uint64_t v143 = 0LL;
    int v142 = 0LL;
    uint64_t v141 = 0LL;
    uint64_t v14 = 0;
    uint64_t v140 = 0LL;
    unsigned int v15 = 0;
    uint64_t v139 = 0LL;
    id v138 = 0LL;
    id v133 = 0;
    unsigned int v137 = 0LL;
    uint64_t v16 = 0;
    id v136 = 0LL;
    unsigned int v17 = 0;
    id v135 = 0LL;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v13 = 0;
    id v149 = 1;
    *(_DWORD *)&v134[16] = 1;
    LODWORD(v144) = 1;
    goto LABEL_30;
  }

  if (!self)
  {
    __int128 v44 = 1;
    p_isa = (id *)&v8->super.isa;
    if (v8) {
      goto LABEL_177;
    }
    LODWORD(v143) = 0;
    id v113 = 0LL;
    uint64_t v116 = 0LL;
LABEL_212:
    HIDWORD(v143) = 1;
    int v8 = 0LL;
    goto LABEL_213;
  }

  __int128 v43 = self->_observers;
  if (!v43)
  {
    __int128 v44 = 1;
    if (!v8) {
      goto LABEL_191;
    }
    goto LABEL_144;
  }

  uint64_t v116 = v43;
  HIDWORD(v143) = 0;
  __int128 v44 = 1;
  unsigned int v119 = self->_observers;
  if (v8) {
    goto LABEL_147;
  }
  observers = 0LL;
LABEL_148:
  uint64_t v115 = observers;
  if (!-[NSSet isEqual:](v119, "isEqual:"))
  {
    LODWORD(v144) = v44;
    LODWORD(v145) = v38;
    *(void *)&v134[8] = 0LL;
    int v142 = 0LL;
    uint64_t v141 = 0LL;
    uint64_t v14 = 0;
    uint64_t v140 = 0LL;
    unsigned int v15 = 0;
    uint64_t v139 = 0LL;
    *(_DWORD *)&v134[4] = 0;
    id v138 = 0LL;
    id v133 = 0;
    unsigned int v137 = 0LL;
    uint64_t v16 = 0;
    id v136 = 0LL;
    unsigned int v17 = 0;
    id v135 = 0LL;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v13 = 0;
    id v149 = 1;
LABEL_153:
    *(_DWORD *)&v134[16] = 1;
    *(_DWORD *)uint64_t v134 = 1;
    LODWORD(v143) = 1;
    goto LABEL_30;
  }

  if (!self)
  {
    LODWORD(v143) = 1;
    if (!v8) {
      goto LABEL_198;
    }
    goto LABEL_186;
  }

  isDeleting = self->_isDeleting;
  if (!v8)
  {
    LODWORD(v144) = v44;
    LODWORD(v145) = v38;
    id v149 = 1;
    if (self->_isDeleting)
    {
      *(void *)&v134[8] = 0LL;
      int v142 = 0LL;
      uint64_t v141 = 0LL;
      uint64_t v14 = 0;
      uint64_t v140 = 0LL;
      unsigned int v15 = 0;
      uint64_t v139 = 0LL;
      *(_DWORD *)&v134[4] = 0;
      id v138 = 0LL;
      id v133 = 0;
      unsigned int v137 = 0LL;
      uint64_t v16 = 0;
      id v136 = 0LL;
      unsigned int v17 = 0;
      id v135 = 0LL;
      uint64_t v18 = 0;
      uint64_t v19 = 0;
      uint64_t v20 = 0;
      uint64_t v13 = 0;
      goto LABEL_153;
    }

    LODWORD(v143) = 1;
LABEL_193:
    if (self->_isDisabled) {
      goto LABEL_158;
    }
    uint64_t v38 = v145;
    __int128 v44 = v144;
    goto LABEL_195;
  }

  LODWORD(v143) = 1;
LABEL_155:
  if (((isDeleting ^ v8->_isDeleting) & 1) != 0 || self->_isDisabled != v8->_isDisabled)
  {
    LODWORD(v144) = v44;
    LODWORD(v145) = v38;
LABEL_158:
    *(void *)&v134[8] = 0LL;
    int v142 = 0LL;
    uint64_t v141 = 0LL;
    uint64_t v14 = 0;
    uint64_t v140 = 0LL;
    unsigned int v15 = 0;
    uint64_t v139 = 0LL;
    id v138 = 0LL;
    id v133 = 0;
    unsigned int v137 = 0LL;
    uint64_t v16 = 0;
    id v136 = 0LL;
    unsigned int v17 = 0;
    id v135 = 0LL;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v13 = 0;
    id v149 = 1;
    *(_DWORD *)&v134[16] = 1;
    *(void *)uint64_t v134 = 1LL;
    goto LABEL_30;
  }

LABEL_195:
  __int128 v50 = self->_displayName;
  if (!v50) {
    goto LABEL_198;
  }
  int v131 = v50;
  __int128 v51 = self->_displayName;
  HIDWORD(v142) = 0;
  if (!v8)
  {
    unsigned int v112 = v51;
    displayName = 0LL;
    goto LABEL_204;
  }

  __int128 v52 = v131;
LABEL_203:
  unsigned int v112 = v51;
  int v131 = v52;
  displayName = v8->_displayName;
LABEL_204:
  uint64_t v110 = displayName;
  if (!-[NSString isEqual:](v112, "isEqual:"))
  {
    id v149 = 1;
    LODWORD(v144) = v44;
    LODWORD(v145) = v38;
    *(void *)&v134[4] = 0LL;
    uint64_t v141 = 0LL;
    uint64_t v14 = 0;
    uint64_t v140 = 0LL;
    unsigned int v15 = 0;
    uint64_t v139 = 0LL;
    id v138 = 0LL;
    unsigned int v137 = 0LL;
    uint64_t v16 = 0;
    id v136 = 0LL;
    unsigned int v17 = 0;
    id v135 = 0LL;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v13 = 0;
    *(_DWORD *)&v134[12] = 1;
    *(_DWORD *)&v134[16] = 1;
    id v133 = 0;
    *(_DWORD *)uint64_t v134 = 1;
    LODWORD(v142) = 1;
    goto LABEL_30;
  }

  LODWORD(v142) = 1;
LABEL_214:
  LODWORD(v145) = v38;
  LODWORD(v144) = v44;
  if (self && (__int128 v55 = self->_createTime) != 0LL)
  {
    id v130 = v55;
    uint64_t v56 = self->_createTime;
    HIDWORD(v141) = 0;
    if (!v8)
    {
      char v111 = v56;
      createTime = 0LL;
      goto LABEL_224;
    }

    unsigned int v57 = v130;
  }

  else
  {
    if (!v8 || (uint64_t v58 = v8->_createTime) == 0LL)
    {
      id v130 = 0LL;
      id v128 = 0LL;
      uint64_t v141 = 0x100000000LL;
      goto LABEL_228;
    }

    id v128 = v58;
    if (self) {
      uint64_t v56 = self->_createTime;
    }
    else {
      uint64_t v56 = 0LL;
    }
    unsigned int v57 = 0LL;
    HIDWORD(v141) = 1;
  }

  char v111 = v56;
  id v130 = v57;
  createTime = v8->_createTime;
LABEL_224:
  uint64_t v108 = createTime;
  if (!-[NSDate isEqual:](v111, "isEqual:"))
  {
    id v149 = 1;
    uint64_t v14 = 0;
    uint64_t v140 = 0LL;
    unsigned int v15 = 0;
    uint64_t v139 = 0LL;
    id v138 = 0LL;
    id v133 = 0;
    unsigned int v137 = 0LL;
    uint64_t v16 = 0;
    id v136 = 0LL;
    unsigned int v17 = 0;
    id v135 = 0LL;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v13 = 0;
    *(_DWORD *)&v134[12] = 1;
    *(_DWORD *)&v134[16] = 1;
    *(_DWORD *)uint64_t v134 = 1;
    *(_DWORD *)&v134[4] = 0;
    *(_DWORD *)&v134[8] = 1;
    LODWORD(v141) = 1;
    goto LABEL_30;
  }

  LODWORD(v141) = 1;
LABEL_228:
  if (self && (unsigned int v60 = self->_loginTime) != 0LL)
  {
    unsigned int v107 = v60;
    uint64_t v61 = self->_loginTime;
    HIDWORD(v140) = 0;
    if (!v8)
    {
      uint64_t v109 = v61;
      loginTime = 0LL;
      goto LABEL_238;
    }
  }

  else
  {
    if (!v8 || (id v62 = v8->_loginTime) == 0LL)
    {
      unsigned int v107 = 0LL;
      uint64_t v101 = 0LL;
      uint64_t v140 = 0x100000000LL;
      goto LABEL_242;
    }

    uint64_t v101 = v62;
    if (self) {
      uint64_t v61 = self->_loginTime;
    }
    else {
      uint64_t v61 = 0LL;
    }
    unsigned int v107 = 0LL;
    HIDWORD(v140) = 1;
  }

  uint64_t v109 = v61;
  loginTime = v8->_loginTime;
LABEL_238:
  id v105 = loginTime;
  if (!-[NSDate isEqual:](v109, "isEqual:"))
  {
    id v149 = 1;
    unsigned int v15 = 0;
    uint64_t v139 = 0LL;
    id v138 = 0LL;
    id v133 = 0;
    unsigned int v137 = 0LL;
    uint64_t v16 = 0;
    id v136 = 0LL;
    unsigned int v17 = 0;
    id v135 = 0LL;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v13 = 0;
    *(_DWORD *)&v134[12] = 1;
    *(_DWORD *)&v134[16] = 1;
    *(_DWORD *)uint64_t v134 = 1;
    *(_DWORD *)&v134[4] = 0;
    *(_DWORD *)&v134[8] = 1;
    uint64_t v14 = 1;
    LODWORD(v140) = 1;
    goto LABEL_30;
  }

  LODWORD(v140) = 1;
LABEL_242:
  if (self && (__int16 v64 = self->_volumeUUID) != 0LL)
  {
    unsigned int v104 = v64;
    unsigned int v65 = self->_volumeUUID;
    HIDWORD(v139) = 0;
    if (!v8)
    {
      uint64_t v106 = v65;
      volumeUUID = 0LL;
      goto LABEL_252;
    }
  }

  else
  {
    if (!v8 || (uint64_t v66 = v8->_volumeUUID) == 0LL)
    {
      unsigned int v104 = 0LL;
      uint64_t v97 = 0LL;
      uint64_t v139 = 0x100000000LL;
      goto LABEL_256;
    }

    uint64_t v97 = v66;
    if (self) {
      unsigned int v65 = self->_volumeUUID;
    }
    else {
      unsigned int v65 = 0LL;
    }
    unsigned int v104 = 0LL;
    HIDWORD(v139) = 1;
  }

  uint64_t v106 = v65;
  volumeUUID = v8->_volumeUUID;
LABEL_252:
  unsigned int v102 = volumeUUID;
  if (!-[NSUUID isEqual:](v106, "isEqual:"))
  {
    id v149 = 1;
    id v138 = 0LL;
    id v133 = 0;
    unsigned int v137 = 0LL;
    uint64_t v16 = 0;
    id v136 = 0LL;
    unsigned int v17 = 0;
    id v135 = 0LL;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v13 = 0;
    *(_DWORD *)&v134[12] = 1;
    *(_DWORD *)&v134[16] = 1;
    *(_DWORD *)uint64_t v134 = 1;
    *(_DWORD *)&v134[4] = 0;
    *(_DWORD *)&v134[8] = 1;
    uint64_t v14 = 1;
    unsigned int v15 = 1;
    LODWORD(v139) = 1;
    goto LABEL_30;
  }

  LODWORD(v139) = 1;
LABEL_256:
  if (self && (uint64_t v68 = self->_homeUUID) != 0LL)
  {
    uint64_t v69 = v68;
    __int16 v70 = self->_homeUUID;
    HIDWORD(v13_Block_object_dispose(va, 8) = 0;
    if (!v8)
    {
      uint64_t v103 = v70;
      homeUUID = 0LL;
      goto LABEL_266;
    }
  }

  else
  {
    if (!v8)
    {
      uint64_t v69 = 0LL;
      uint64_t v94 = 0LL;
      id v138 = 0x100000000LL;
      goto LABEL_270;
    }

    uint64_t v94 = v8->_homeUUID;
    if (!v94)
    {
      uint64_t v69 = 0LL;
      uint64_t v94 = 0LL;
      id v138 = 0x100000000LL;
      goto LABEL_270;
    }

    if (self) {
      __int16 v70 = self->_homeUUID;
    }
    else {
      __int16 v70 = 0LL;
    }
    uint64_t v69 = 0LL;
    HIDWORD(v13_Block_object_dispose(va, 8) = 1;
  }

  uint64_t v103 = v70;
  homeUUID = v8->_homeUUID;
LABEL_266:
  uint64_t v98 = homeUUID;
  id v149 = 1;
  if (!-[NSUUID isEqual:](v103, "isEqual:"))
  {
    uint64_t v100 = v69;
    unsigned int v137 = 0LL;
    uint64_t v16 = 0;
    id v136 = 0LL;
    unsigned int v17 = 0;
    id v135 = 0LL;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v13 = 0;
    *(_DWORD *)&v134[12] = 1;
    *(_DWORD *)&v134[16] = 1;
    id v133 = 0;
    *(_DWORD *)uint64_t v134 = 1;
    *(_DWORD *)&v134[4] = 1;
    *(_DWORD *)&v134[8] = 1;
    uint64_t v14 = 1;
    unsigned int v15 = 1;
    LODWORD(v13_Block_object_dispose(va, 8) = 1;
    goto LABEL_30;
  }

  LODWORD(v13_Block_object_dispose(va, 8) = 1;
LABEL_270:
  uint64_t v100 = v69;
  if (self && (CFStringRef v72 = self->_homeDir) != 0LL)
  {
    uint64_t v96 = v72;
    unsigned int v99 = self->_homeDir;
    HIDWORD(v137) = 0;
    if (!v8)
    {
      homeDir = 0LL;
      goto LABEL_280;
    }
  }

  else
  {
    if (!v8 || (unsigned int v90 = v8->_homeDir) == 0LL)
    {
      uint64_t v96 = 0LL;
      unsigned int v90 = 0LL;
      unsigned int v137 = 0x100000000LL;
      goto LABEL_284;
    }

    if (self) {
      unsigned int v99 = self->_homeDir;
    }
    else {
      unsigned int v99 = 0LL;
    }
    uint64_t v96 = 0LL;
    HIDWORD(v137) = 1;
  }

  homeDir = v8->_homeDir;
LABEL_280:
  id v93 = homeDir;
  id v149 = 1;
  if (!-[NSString isEqual:](v99, "isEqual:"))
  {
    uint64_t v16 = 0;
    id v136 = 0LL;
    unsigned int v17 = 0;
    id v135 = 0LL;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v13 = 0;
    *(_DWORD *)&v134[12] = 1;
    *(_DWORD *)&v134[16] = 1;
    *(_DWORD *)uint64_t v134 = 1;
    *(_DWORD *)&v134[4] = 1;
    *(_DWORD *)&v134[8] = 1;
    uint64_t v14 = 1;
    unsigned int v15 = 1;
    id v133 = 1;
    LODWORD(v137) = 1;
    goto LABEL_30;
  }

  LODWORD(v137) = 1;
LABEL_284:
  if (self && (uint64_t v92 = self->_deviceNode) != 0LL)
  {
    unsigned int v95 = self->_deviceNode;
    HIDWORD(v136) = 0;
    deviceNode = v8;
    if (!v8) {
      goto LABEL_294;
    }
  }

  else
  {
    if (!v8 || (unsigned int v87 = v8->_deviceNode) == 0LL)
    {
      uint64_t v92 = 0LL;
      unsigned int v87 = 0LL;
      id v136 = 0x100000000LL;
      goto LABEL_298;
    }

    if (self) {
      unsigned int v95 = self->_deviceNode;
    }
    else {
      unsigned int v95 = 0LL;
    }
    uint64_t v92 = 0LL;
    HIDWORD(v136) = 1;
  }

  deviceNode = (UMDPersonaManifestPersona *)v8->_deviceNode;
LABEL_294:
  id v89 = deviceNode;
  id v149 = 1;
  if (!-[NSString isEqual:](v95, "isEqual:"))
  {
    unsigned int v17 = 0;
    id v135 = 0LL;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v13 = 0;
    *(_DWORD *)&v134[12] = 1;
    *(_DWORD *)&v134[16] = 1;
    *(_DWORD *)uint64_t v134 = 1;
    *(_DWORD *)&v134[4] = 1;
    *(_DWORD *)&v134[8] = 1;
    uint64_t v14 = 1;
    unsigned int v15 = 1;
    id v133 = 1;
    uint64_t v16 = 1;
    LODWORD(v136) = 1;
    goto LABEL_30;
  }

  LODWORD(v136) = 1;
LABEL_298:
  if (self && (uint64_t v88 = self->_userUUID) != 0LL)
  {
    id v91 = self->_userUUID;
    HIDWORD(v135) = 0;
    userUUID = v8;
    if (!v8) {
      goto LABEL_308;
    }
  }

  else
  {
    if (!v8 || (uint64_t v85 = v8->_userUUID) == 0LL)
    {
      uint64_t v88 = 0LL;
      uint64_t v85 = 0LL;
      id v135 = 0x100000000LL;
      goto LABEL_312;
    }

    if (self) {
      id v91 = self->_userUUID;
    }
    else {
      id v91 = 0LL;
    }
    uint64_t v88 = 0LL;
    HIDWORD(v135) = 1;
  }

  userUUID = v8->_userUUID;
LABEL_308:
  uint64_t v86 = userUUID;
  id v149 = 1;
  if (!-[NSUUID isEqual:](v91, "isEqual:"))
  {
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v13 = 0;
    *(_DWORD *)&v134[12] = 1;
    *(_DWORD *)&v134[16] = 1;
    *(_DWORD *)uint64_t v134 = 1;
    *(_DWORD *)&v134[4] = 1;
    *(_DWORD *)&v134[8] = 1;
    uint64_t v14 = 1;
    unsigned int v15 = 1;
    id v133 = 1;
    uint64_t v16 = 1;
    unsigned int v17 = 1;
    LODWORD(v135) = 1;
    goto LABEL_30;
  }

  LODWORD(v135) = 1;
LABEL_312:
  if (self) {
    uid = self->_uid;
  }
  else {
    uid = 0;
  }
  uint64_t v77 = v8;
  if (v8) {
    uint64_t v77 = v8->_uid;
  }
  if (uid != v77) {
    goto LABEL_326;
  }
  if (self) {
    gid = self->_gid;
  }
  else {
    gid = 0;
  }
  id v79 = v8;
  if (v8) {
    id v79 = v8->_gid;
  }
  if (gid != v79)
  {
LABEL_326:
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v13 = 0;
    id v149 = 1;
    *(_DWORD *)&v134[12] = 1;
    *(_DWORD *)&v134[16] = 1;
    *(_DWORD *)uint64_t v134 = 1;
    *(_DWORD *)&v134[4] = 1;
    *(_DWORD *)&v134[8] = 1;
    uint64_t v14 = 1;
    unsigned int v15 = 1;
    id v133 = 1;
    uint64_t v16 = 1;
    unsigned int v17 = 1;
    goto LABEL_30;
  }

  if (self)
  {
    int v83 = self->_encryptedVolumeKey;
    if (v83)
    {
      unsigned int v84 = self->_encryptedVolumeKey;
      id v81 = 0;
      encryptedVolumeKey = v8;
      if (!v8) {
        goto LABEL_333;
      }
      goto LABEL_332;
    }
  }

  uint64_t v20 = (int)v8;
  if (v8)
  {
    uint64_t v82 = v8->_encryptedVolumeKey;
    if (v82)
    {
      if (self) {
        unsigned int v84 = self->_encryptedVolumeKey;
      }
      else {
        unsigned int v84 = 0LL;
      }
      int v83 = 0LL;
      id v81 = 1;
LABEL_332:
      encryptedVolumeKey = v8->_encryptedVolumeKey;
LABEL_333:
      unsigned int v3 = encryptedVolumeKey;
      uint64_t v13 = -[NSData isEqual:](v84, "isEqual:", v3);
      uint64_t v20 = 1;
      id v149 = 1;
      *(_DWORD *)&v134[12] = 1;
      *(_DWORD *)&v134[16] = 1;
      *(_DWORD *)uint64_t v134 = 1;
      *(_DWORD *)&v134[4] = 1;
      *(_DWORD *)&v134[8] = 1;
      uint64_t v14 = 1;
      unsigned int v15 = 1;
      id v133 = 1;
      uint64_t v16 = 1;
      unsigned int v17 = 1;
      uint64_t v18 = 1;
      uint64_t v19 = v81;
      goto LABEL_30;
    }

    uint64_t v82 = 0LL;
    int v83 = 0LL;
    uint64_t v20 = 0;
  }

  else
  {
    uint64_t v82 = 0LL;
    int v83 = 0LL;
  }

  id v149 = 1;
  *(_DWORD *)&v134[12] = 1;
  *(_DWORD *)&v134[16] = 1;
  *(_DWORD *)uint64_t v134 = 1;
  *(_DWORD *)&v134[4] = 1;
  *(_DWORD *)&v134[8] = 1;
  uint64_t v14 = 1;
  unsigned int v15 = 1;
  id v133 = 1;
  uint64_t v16 = 1;
  unsigned int v17 = 1;
  uint64_t v18 = 1;
  uint64_t v19 = 1;
  uint64_t v13 = 1;
LABEL_30:
  if (v20)
  {
    uint64_t v27 = v8;
    __int16 v28 = v16;
    int v29 = v18;
    __int16 v30 = v15;
    int v31 = v14;
    __int16 v32 = v19;

    int v33 = v32;
    uint64_t v14 = v31;
    unsigned int v15 = v30;
    uint64_t v18 = v29;
    uint64_t v16 = v28;
    int v8 = v27;
    if (!v33) {
      goto LABEL_32;
    }
LABEL_109:

    if (!v18) {
      goto LABEL_34;
    }
    goto LABEL_33;
  }

  if (v19) {
    goto LABEL_109;
  }
LABEL_32:
  if (v18) {
LABEL_33:
  }

LABEL_34:
  if ((_DWORD)v135)
  {
  }

  if (HIDWORD(v135)) {

  }
  if (v17) {
  if ((_DWORD)v136)
  }
  {
  }

  if (HIDWORD(v136)) {

  }
  if (v16) {
  if ((_DWORD)v137)
  }
  {
  }

  if (HIDWORD(v137)) {

  }
  if (v133) {
  if ((_DWORD)v138)
  }
  {
  }

  if (HIDWORD(v138)) {

  }
  if (*(_DWORD *)&v134[4]) {
  if ((_DWORD)v139)
  }
  {
  }

  if (HIDWORD(v139)) {

  }
  if (v15) {
  if ((_DWORD)v140)
  }
  {
  }

  if (HIDWORD(v140)) {

  }
  if (v14) {
  if ((_DWORD)v141)
  }
  {
  }

  if (HIDWORD(v141)) {

  }
  if (*(_DWORD *)&v134[8]) {
  if ((_DWORD)v142)
  }
  {
  }

  if (HIDWORD(v142)) {

  }
  if (*(_DWORD *)&v134[12]) {
  if ((_DWORD)v143)
  }
  {
  }

  if (HIDWORD(v143)) {

  }
  if (*(_DWORD *)v134) {
  if ((_DWORD)v144)
  }
  {
  }

  if (HIDWORD(v144)) {

  }
  if (*(_DWORD *)&v134[16]) {
  if ((_DWORD)v145)
  }
  {
  }

  if (HIDWORD(v145)) {

  }
  if (v149) {
  if ((_DWORD)v146)
  }
  {
  }

  if (HIDWORD(v146)) {

  }
  if (v148 == v147) {
LABEL_107:
  }

  return v13;
}

BOOL sub_100075928(BOOL result)
{
  if (result) {
    return *(_BYTE *)(result + 8) != 0;
  }
  return result;
}

uint64_t sub_10007593C(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 20);
  }
  return result;
}

uint64_t sub_100075948(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 24);
  }
  return result;
}

UMDPersonaManifestPersona *sub_100075BA0(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_self(a1);
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___UMDPersonaManifestPersona);
  unsigned int v5 = sub_100084F14(v3, (uint64_t)@"UserPersonaType", (id)0xFFFFFFFFLL);
  if (v4) {
    v4->_type = v5;
  }
  if (*__error() == 2)
  {
    if (qword_1000DBBC8 != -1) {
      dispatch_once(&qword_1000DBBC8, &stru_1000CDB00);
    }
    __int128 v6 = (os_log_s *)(id)qword_1000DBBC0;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      uint64_t v52 = 0LL;
      unsigned int v7 = sub_100053B4C(0);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
        uint64_t v8 = v7;
      }
      else {
        uint64_t v8 = v7 & 0xFFFFFFFE;
      }
      if ((_DWORD)v8)
      {
        __int16 v51 = 0;
        uint64_t v9 = (const char *)_os_log_send_and_compose_impl( v8,  &v52,  0LL,  0LL,  &_mh_execute_header,  v6,  16LL,  "Failed to parse persona manifest persona: persona type is invalid",  &v51,  2);
        uint64_t v10 = (char *)v9;
        if (v9) {
          sub_100053B7C(v9);
        }
      }

      else
      {
        uint64_t v10 = 0LL;
      }

      free(v10);
    }

    __int128 v47 = 0LL;
  }

  else
  {
    id v11 = sub_1000852B4(v3, (uint64_t)@"UserPersonaUniqueString");
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
    sub_1000198C4((uint64_t)v4, v12);

    unsigned int v13 = sub_100084F14(v3, (uint64_t)@"UserPersonaID", 0LL);
    if (v4)
    {
      v4->_kernelID = v13;
      id v14 = sub_1000850A0(v3, (uint64_t)@"UserPersonaNickName");
      unsigned int v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
      objc_setProperty_nonatomic_copy(v4, v16, v15, 40LL);
    }

    else
    {
      id v49 = sub_1000850A0(v3, (uint64_t)@"UserPersonaNickName");
      unsigned int v15 = (void *)objc_claimAutoreleasedReturnValue(v49);
    }

    id v17 = sub_10008511C(v3, (uint64_t)@"UserPersonaBundleIDS");
    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(v17);
    if (v4) {
      objc_setProperty_nonatomic_copy(v4, v18, v19, 48LL);
    }

    id v20 = sub_10008511C(v3, (uint64_t)@"UserPersonaObserverService");
    unsigned int v21 = (void *)objc_claimAutoreleasedReturnValue(v20);
    uint64_t v23 = v21;
    if (v4)
    {
      objc_setProperty_nonatomic_copy(v4, v22, v21, 56LL);

      v4->_isDeleting = sub_100084E0C(v3, (uint64_t)@"UserPersonaOnDeletion");
      v4->_isDisabled = sub_100084E0C(v3, (uint64_t)@"UserPersonaDisabled");
      id v24 = sub_1000850A0(v3, (uint64_t)@"UserPersonaDisplayName");
      uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(v24);
      objc_setProperty_nonatomic_copy(v4, v26, v25, 64LL);
    }

    else
    {

      sub_100084E0C(v3, (uint64_t)@"UserPersonaOnDeletion");
      sub_100084E0C(v3, (uint64_t)@"UserPersonaDisabled");
      id v50 = sub_1000850A0(v3, (uint64_t)@"UserPersonaDisplayName");
      uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(v50);
    }

    id v27 = sub_10008534C(v3, (uint64_t)@"MKBUserSessionCreateTimeStamp");
    __int16 v28 = (void *)objc_claimAutoreleasedReturnValue(v27);
    sub_100019914((uint64_t)v4, v28);

    id v29 = sub_10008534C(v3, (uint64_t)@"MKBUserSessionLoginTimeStamp");
    __int16 v30 = (void *)objc_claimAutoreleasedReturnValue(v29);
    sub_100019924((uint64_t)v4, v30);

    id v31 = sub_1000852B4(v3, (uint64_t)@"MKBUserSessionVolumeUUID");
    __int16 v32 = (void *)objc_claimAutoreleasedReturnValue(v31);
    sub_100019934((uint64_t)v4, v32);

    id v33 = sub_1000852B4(v3, (uint64_t)@"MKBUserSessionUUID");
    int v34 = (void *)objc_claimAutoreleasedReturnValue(v33);
    sub_100019944((uint64_t)v4, v34);

    id v35 = sub_1000850A0(v3, (uint64_t)@"MKBUserSessionHomeDir");
    __int16 v37 = (void *)objc_claimAutoreleasedReturnValue(v35);
    if (v4) {
      objc_setProperty_nonatomic_copy(v4, v36, v37, 104LL);
    }

    id v38 = sub_1000850A0(v3, (uint64_t)@"MKBUserSessionVolumeDeviceNode");
    __int128 v40 = (void *)objc_claimAutoreleasedReturnValue(v38);
    if (v4) {
      objc_setProperty_nonatomic_copy(v4, v39, v40, 112LL);
    }

    id v41 = sub_1000852B4(v3, (uint64_t)@"UserPersonaUserODUUID");
    __int128 v42 = (void *)objc_claimAutoreleasedReturnValue(v41);
    sub_100019980((uint64_t)v4, v42);

    unsigned int v43 = sub_100084F14(v3, (uint64_t)@"UserPersonaUserUID", 0LL);
    if (v4)
    {
      v4->_uid = v43;
      v4->_gid = sub_100084F14(v3, (uint64_t)@"UserPersonaUserGID", 0LL);
    }

    else
    {
      sub_100084F14(v3, (uint64_t)@"UserPersonaUserGID", 0LL);
    }

    id v44 = sub_1000853C8(v3, (uint64_t)@"UserPersonaVolumeKey");
    __int128 v45 = (void *)objc_claimAutoreleasedReturnValue(v44);
    sub_100019990((uint64_t)v4, v45);

    id v46 = sub_10008501C(v3, (uint64_t)@"UsePersonaGenerationID", 0LL);
    if (v4) {
      v4->_generation = (unint64_t)v46;
    }
    __int128 v47 = v4;
  }

  return v47;
}

void sub_10007603C(void *a1, char *newValue)
{
  if (a1) {
    objc_setProperty_nonatomic_copy(a1, newValue, newValue, 40LL);
  }
}

void sub_100076050(void *a1, char *newValue)
{
  if (a1) {
    objc_setProperty_nonatomic_copy(a1, newValue, newValue, 48LL);
  }
}

void sub_100076064(void *a1, char *newValue)
{
  if (a1) {
    objc_setProperty_nonatomic_copy(a1, newValue, newValue, 56LL);
  }
}

uint64_t sub_100076078(uint64_t result, char a2)
{
  if (result) {
    *(_BYTE *)(result + _Block_object_dispose(va, 8) = a2;
  }
  return result;
}

void sub_100076084(void *a1, char *newValue)
{
  if (a1) {
    objc_setProperty_nonatomic_copy(a1, newValue, newValue, 64LL);
  }
}

void sub_100076098(void *a1, char *newValue)
{
  if (a1) {
    objc_setProperty_nonatomic_copy(a1, newValue, newValue, 104LL);
  }
}

void sub_1000760AC(void *a1, char *newValue)
{
  if (a1) {
    objc_setProperty_nonatomic_copy(a1, newValue, newValue, 112LL);
  }
}

uint64_t sub_1000760C0(uint64_t result, int a2)
{
  if (result) {
    *(_DWORD *)(result + 20) = a2;
  }
  return result;
}

uint64_t sub_1000760CC(uint64_t result, int a2)
{
  if (result) {
    *(_DWORD *)(result + 24) = a2;
  }
  return result;
}

uint64_t sub_1000760D8(uint64_t result, uint64_t a2)
{
  if (result) {
    *(void *)(result + 136) = a2;
  }
  return result;
}

id sub_1000760E4(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
    id v3 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(a1 + 12)));
    [v2 setObject:v3 forKeyedSubscript:@"UserPersonaType"];

    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) UUIDString]);
    [v2 setObject:v4 forKeyedSubscript:@"UserPersonaUniqueString"];

    if (*(_DWORD *)(a1 + 16))
    {
      unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:"));
      [v2 setObject:v5 forKeyedSubscript:@"UserPersonaID"];
    }

    [v2 setObject:*(void *)(a1 + 40) forKeyedSubscript:@"UserPersonaNickName"];
    id v6 = *(id *)(a1 + 48);
    unsigned int v7 = (void *)objc_claimAutoreleasedReturnValue([v6 allObjects]);
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v7 sortedArrayUsingSelector:"compare:"]);

    [v2 setObject:v8 forKeyedSubscript:@"UserPersonaBundleIDS"];
    id v9 = *(id *)(a1 + 56);
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v9 allObjects]);
    id v11 = (void *)objc_claimAutoreleasedReturnValue([v10 sortedArrayUsingSelector:"compare:"]);

    [v2 setObject:v11 forKeyedSubscript:@"UserPersonaObserverService"];
    if (*(_BYTE *)(a1 + 8))
    {
      uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 1LL));
      [v2 setObject:v12 forKeyedSubscript:@"UserPersonaOnDeletion"];
    }

    if (*(_BYTE *)(a1 + 9))
    {
      unsigned int v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 1LL));
      [v2 setObject:v13 forKeyedSubscript:@"UserPersonaDisabled"];
    }

    [v2 setObject:*(void *)(a1 + 64) forKeyedSubscript:@"UserPersonaDisplayName"];
    [v2 setObject:*(void *)(a1 + 72) forKeyedSubscript:@"MKBUserSessionCreateTimeStamp"];
    [v2 setObject:*(void *)(a1 + 80) forKeyedSubscript:@"MKBUserSessionLoginTimeStamp"];
    id v14 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 88) UUIDString]);
    [v2 setObject:v14 forKeyedSubscript:@"MKBUserSessionVolumeUUID"];

    unsigned int v15 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 96) UUIDString]);
    [v2 setObject:v15 forKeyedSubscript:@"MKBUserSessionUUID"];

    [v2 setObject:*(void *)(a1 + 104) forKeyedSubscript:@"MKBUserSessionHomeDir"];
    [v2 setObject:*(void *)(a1 + 112) forKeyedSubscript:@"MKBUserSessionVolumeDeviceNode"];
    SEL v16 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 120) UUIDString]);
    [v2 setObject:v16 forKeyedSubscript:@"UserPersonaUserODUUID"];

    if (*(_DWORD *)(a1 + 20))
    {
      id v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:"));
      [v2 setObject:v17 forKeyedSubscript:@"UserPersonaUserUID"];
    }

    if (*(_DWORD *)(a1 + 24))
    {
      uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:"));
      [v2 setObject:v18 forKeyedSubscript:@"UserPersonaUserGID"];
    }

    [v2 setObject:*(void *)(a1 + 128) forKeyedSubscript:@"UserPersonaVolumeKey"];
  }

  else
  {
    uint64_t v2 = 0LL;
  }

  return v2;
}

LABEL_72:
    __int128 v40 = 0LL;
    goto LABEL_73;
  }

  unsigned int v13 = -[os_log_s count](v11, "count");
  if (v13 != -[os_log_s unsignedLongValue](v6, "unsignedLongValue"))
  {
    if (qword_1000DBBC8 != -1) {
      dispatch_once(&qword_1000DBBC8, &stru_1000CDB00);
    }
    id v24 = (os_log_s *)(id)qword_1000DBBC0;
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
      goto LABEL_95;
    }
    v56[0] = 0LL;
    LODWORD(v41) = sub_100053B4C(0);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
      id v41 = v41;
    }
    else {
      id v41 = v41 & 0xFFFFFFFE;
    }
    if ((_DWORD)v41)
    {
      __int128 v42 = v24;
      *(_DWORD *)uint64_t v58 = 134218240;
      *(void *)&v58[4] = -[os_log_s count](v12, "count");
      unsigned int v59 = 2048;
      unsigned int v60 = -[os_log_s unsignedLongValue](v6, "unsignedLongValue");
      __int128 v40 = (void *)_os_log_send_and_compose_impl( v41,  v56,  0LL,  0LL,  &_mh_execute_header,  v42,  16LL,  "Failed to parse persona manifest persona list: entry count mismatch: %lu != %lu",  v58,  22);

      if (!v40)
      {
LABEL_73:
        free(v40);
LABEL_95:
        uint64_t v25 = 0LL;
        goto LABEL_96;
      }

    uint64_t v4 = 0LL;
    *a4 = v10;
    return v4;
  }

  if (a2 > 99)
  {
    switch(a2)
    {
      case 300:
        if (*a1 != 3) {
          return 4294967293LL;
        }
        unsigned int v7 = a1 + 5;
        goto LABEL_45;
      case 301:
        if (*a1 != 3) {
          return 4294967293LL;
        }
        id v9 = a1 + 13;
        goto LABEL_64;
      case 302:
        if (*a1 != 3) {
          return 4294967293LL;
        }
        unsigned int v7 = a1 + 9;
        goto LABEL_45;
      case 303:
        if (*a1 != 3) {
          return 4294967293LL;
        }
        uint64_t v10 = 0LL;
        id v11 = a1 + 21;
        break;
      case 304:
        if (*a1 != 3) {
          return 4294967293LL;
        }
        uint64_t v8 = a1 + 41;
        goto LABEL_58;
      case 305:
        if (*a1 != 3) {
          return 4294967293LL;
        }
        uint64_t v8 = a1 + 42;
        goto LABEL_58;
      case 306:
        if (*a1 != 24) {
          return 4294967293LL;
        }
        *a3 = a1 + 5;
        uint64_t v10 = a1[4];
        goto LABEL_72;
      case 307:
        if (*a1 != 24) {
          return 4294967293LL;
        }
        id v9 = a1 + 261;
        goto LABEL_64;
      default:
        if (a2 == 100)
        {
          unsigned int v13 = *a1;
          if (*a1 > 19)
          {
            if (v13 == 20 || v13 == 21) {
              goto LABEL_28;
            }
          }

          else if (v13 == 1 || v13 == 3)
          {
            goto LABEL_28;
          }

          return v4;
        }

        if (a2 != 200) {
          return v4;
        }
        if (*a1 != 2) {
          return 4294967293LL;
        }
        goto LABEL_28;
    }

    while (!Util_isNullOrZeroMemory((_BYTE *)v11 + v10, 16LL))
    {
      uint64_t v12 = v10 >= 0x40;
      v10 += 16LL;
      if (v12)
      {
        uint64_t v10 = 80LL;
        goto LABEL_71;
      }
    }

    if (!v10) {
      id v11 = 0LL;
    }
LABEL_71:
    *a3 = v11;
    goto LABEL_72;
  }

  switch(a2)
  {
    case 1:
      *a3 = a1;
LABEL_59:
      uint64_t v10 = 4LL;
      goto LABEL_72;
    case 2:
      uint64_t v8 = a1 + 1;
      goto LABEL_58;
    case 3:
      uint64_t v8 = a1 + 2;
      goto LABEL_58;
  }

  return v4;
}

LABEL_36:
LABEL_37:
LABEL_38:

        __int16 v32 = 0LL;
        goto LABEL_39;
      }

      unsigned int v57 = v17;
      unsigned int v60 = 0u;
      uint64_t v61 = 0u;
      uint64_t v58 = 0u;
      unsigned int v59 = 0u;
      unsigned int v21 = v19;
      uint64_t v22 = -[os_log_s countByEnumeratingWithState:objects:count:]( v21,  "countByEnumeratingWithState:objects:count:",  &v58,  v70,  16LL);
      if (v22)
      {
        uint64_t v23 = v22;
        id v24 = *(void *)v59;
        while (2)
        {
          for (uint64_t i = 0LL; i != v23; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v59 != v24) {
              objc_enumerationMutation(v21);
            }
            SEL v26 = *(void *)(*((void *)&v58 + 1) + 8LL * (void)i);
            if (v26)
            {
              id v27 = *(id *)(v26 + 120);
              if (v27)
              {
                __int16 v28 = v27;
                id v29 = [*(id *)(v26 + 120) isEqual:v16];

                if ((v29 & 1) == 0)
                {
                  if (qword_1000DBBC8 != -1) {
                    dispatch_once(&qword_1000DBBC8, &stru_1000CDB00);
                  }
                  unsigned int v5 = v56;
                  id v33 = (os_log_s *)(id)qword_1000DBBC0;
                  if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
                  {
                    v62[0] = 0LL;
                    int v34 = sub_100053B4C(0);
                    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
                      id v35 = v34;
                    }
                    else {
                      id v35 = v34 & 0xFFFFFFFE;
                    }
                    if ((_DWORD)v35)
                    {
                      uint64_t v36 = *(void *)(v26 + 120);
                      *(_DWORD *)unsigned int v67 = 138543618;
                      *(void *)&v67[4] = v36;
                      uint64_t v68 = 2114;
                      uint64_t v69 = v16;
                      __int16 v37 = v33;
                      id v38 = (char *)_os_log_send_and_compose_impl( v35,  v62,  0LL,  0LL,  &_mh_execute_header,  v37,  16LL,  "Failed to parse persona manifest user list: persona user UUID mismatch: %{public}@ != %{public}@",  v67,  22);

                      if (v38) {
                        sub_100053B7C(v38);
                      }
                    }

                    else
                    {
                      id v38 = 0LL;
                    }

                    free(v38);
                  }

                  id v6 = v55;
                  id v17 = v57;
                  goto LABEL_36;
                }
              }
            }
          }

          uint64_t v23 = -[os_log_s countByEnumeratingWithState:objects:count:]( v21,  "countByEnumeratingWithState:objects:count:",  &v58,  v70,  16LL);
          if (v23) {
            continue;
          }
          break;
        }
      }

      __int16 v30 = objc_alloc_init(&OBJC_CLASS___UMDPersonaManifestUser);
      sub_1000198B4((uint64_t)v30, v16);
      if (v30) {
        objc_setProperty_nonatomic_copy(v30, v31, v21, 16LL);
      }
      unsigned int v5 = v56;
      [v56 addObject:v30];

      uint64_t v12 = (char *)v12 + 1;
      id v6 = v55;
      id v9 = v52;
      a1 = v53;
      uint64_t v10 = &AKSGetLastUser_ptr;
      id v11 = &AKSGetLastUser_ptr;
      if (v12 == v54)
      {
        uint64_t v8 = [v55 countByEnumeratingWithState:&v63 objects:v71 count:16];
        if (v8) {
          goto LABEL_3;
        }
        goto LABEL_23;
      }
    }

    if (qword_1000DBBC8 != -1) {
      dispatch_once(&qword_1000DBBC8, &stru_1000CDB00);
    }
    SEL v16 = (id)qword_1000DBBC0;
    if (os_log_type_enabled((os_log_t)v16, OS_LOG_TYPE_ERROR))
    {
      v62[0] = 0LL;
      __int128 v40 = sub_100053B4C(0);
      if (os_log_type_enabled((os_log_t)v16, OS_LOG_TYPE_ERROR)) {
        id v41 = v40;
      }
      else {
        id v41 = v40 & 0xFFFFFFFE;
      }
      if ((_DWORD)v41)
      {
        *(_DWORD *)unsigned int v67 = 138543362;
        *(void *)&v67[4] = v13;
        __int128 v42 = (const char *)_os_log_send_and_compose_impl( v41,  v62,  0LL,  0LL,  &_mh_execute_header,  v16,  16LL,  "Failed to parse persona manifest user list: invalid UUID: %{public}@",  v67,  12);
        unsigned int v43 = (char *)v42;
        if (v42) {
          sub_100053B7C(v42);
        }
      }

      else
      {
        unsigned int v43 = 0LL;
      }

      free(v43);
    }

    goto LABEL_38;
  }

    id v27 = (char *)v12;
    if (v12) {
      sub_100053B7C(v12);
    }
    goto LABEL_39;
  }

  if (qword_1000DBC08 != -1) {
    dispatch_once(&qword_1000DBC08, &stru_1000CDBA8);
  }
  id v9 = (os_log_s *)(id)qword_1000DBC00;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    __int16 v28 = 0LL;
    uint64_t v10 = sub_100053B4C(0);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO)) {
      id v11 = v10;
    }
    else {
      id v11 = v10 & 0xFFFFFFFE;
    }
    if ((_DWORD)v11)
    {
      id v29 = 138543362;
      __int16 v30 = v4;
      uint64_t v12 = (const char *)_os_log_send_and_compose_impl( v11,  &v28,  0LL,  0LL,  &_mh_execute_header,  v9,  1LL,  "Volume mounts directory %{public}@ exists",  &v29,  12);
      goto LABEL_36;
    }

  if (__dst) {
    Util_DeallocRequirement((int *)__dst);
  }
  return v4;
}

void sub_100077C18(id a1)
{
  os_log_t v1 = os_log_create(off_1000DAE70, "persona");
  uint64_t v2 = (void *)qword_1000DBBC0;
  qword_1000DBBC0 = (uint64_t)v1;
}

BOOL sub_100077C4C(char *a1, CFIndex a2)
{
  char v14 = 1;
  BOOL v3 = sub_100077E68("User", a1, a2, 2, &v14);
  if (v3)
  {
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    uint64_t v4 = (os_log_s *)(id)qword_1000DBBD0;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = 0LL;
      unsigned int v5 = sub_100053B4C(1);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v6 = v5;
      }
      else {
        uint64_t v6 = v5 & 0xFFFFFFFE;
      }
      if ((_DWORD)v6)
      {
        unsigned int v7 = "TRUE";
        if (!v14) {
          unsigned int v7 = "FALSE";
        }
        *(_DWORD *)unsigned int v15 = 136315394;
        *(void *)&v15[4] = a1;
        __int16 v16 = 2080;
        id v17 = v7;
        uint64_t v8 = (const char *)_os_log_send_and_compose_impl( v6,  &v13,  0LL,  0LL,  &_mh_execute_header,  v4,  0LL,  "Found Primary User Volume:%s  isEncrypted:%s",  v15,  22);
        goto LABEL_20;
      }

      goto LABEL_22;
    }
  }

  else
  {
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    uint64_t v4 = (os_log_s *)(id)qword_1000DBBD0;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)unsigned int v15 = 0LL;
      unsigned int v9 = sub_100053B4C(1);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = v9 & 0xFFFFFFFE;
      }
      if ((_DWORD)v10)
      {
        uint64_t v8 = (const char *)_os_log_send_and_compose_impl( v10,  v15,  0LL,  0LL,  &_mh_execute_header,  v4,  0LL,  "Failed to find Primary USER volume");
LABEL_20:
        id v11 = (char *)v8;
        if (v8) {
          sub_100053B7C(v8);
        }
        goto LABEL_23;
      }

BOOL sub_100077E68(const char *a1, char *a2, CFIndex a3, int a4, char *a5)
{
  unsigned int v7 = sub_100077F90(a1, a4, 1, a5);
  if (!v7) {
    return 0LL;
  }
  uint64_t v8 = v7;
  Value = (const __CFString *)CFDictionaryGetValue(v7, kUMUserSessionVolumeDeviceNodeKey);
  BOOL v10 = Value != 0LL;
  if (Value) {
    CFStringGetCString(Value, a2, a3, 0x8000100u);
  }
  CFRelease(v8);
  return v10;
}

__CFDictionary *sub_100077EEC(__CFDictionary *a1)
{
  uint64_t result = sub_100077F90("User", 2, 0, 0LL);
  if (result)
  {
    BOOL v3 = result;
    Value = CFDictionaryGetValue(result, kUMUserSessionVolumeDeviceNodeKey);
    unsigned int v5 = CFDictionaryGetValue(v3, kUMUserSessionVolumeUUIDKey);
    CFDictionarySetValue(a1, kUMUserSessionVolumeDeviceNodeKey, Value);
    CFDictionarySetValue(a1, kUMUserSessionVolumeUUIDKey, v5);
    CFRelease(v3);
    return (__CFDictionary *)1;
  }

  return result;
}

__CFDictionary *sub_100077F90(const char *a1, int a2, int a3, char *a4)
{
  *(void *)existing = 0LL;
  CFStringRef prefix = 0LL;
  CFMutableDictionaryRef v87 = 0LL;
  CFMutableDictionaryRef properties = 0LL;
  CFMutableDictionaryRef theDict = 0LL;
  io_registry_entry_t parent = 0;
  unsigned __int16 valuePtr = 0;
  memset(name, 0, 128);
  p_name = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
  if (a3)
  {
    int BootDevice = APFSContainerGetBootDevice(&prefix);
    if (BootDevice)
    {
      int v8 = BootDevice;
      if (qword_1000DBBD8 != -1) {
        dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
      }
      unsigned int v9 = (os_log_s *)(id)qword_1000DBBD0;
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_142;
      }
      *(void *)id v91 = 0LL;
      unsigned int v10 = sub_100053B4C(1);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = v10 & 0xFFFFFFFE;
      }
      if ((_DWORD)v11)
      {
        LODWORD(v94[0]) = 67109120;
        HIDWORD(v94[0]) = v8;
        uint64_t v12 = (const char *)_os_log_send_and_compose_impl( v11,  v91,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "APFSContainerGetBootDevice failed with %d, bailing..",  v94);
        goto LABEL_32;
      }

      goto LABEL_140;
    }

    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    id v13 = (id)qword_1000DBBD0;
    if (os_log_type_enabled((os_log_t)v13, OS_LOG_TYPE_DEFAULT))
    {
      v94[0] = 0LL;
      unsigned int v14 = sub_100053B4C(1);
      unsigned int v15 = (os_log_s *)v13;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v16 = v14;
      }
      else {
        uint64_t v16 = v14 & 0xFFFFFFFE;
      }
      if ((_DWORD)v16)
      {
        *(_DWORD *)id v91 = 138412290;
        *(void *)&_DWORD v91[4] = prefix;
        id v17 = (char *)_os_log_send_and_compose_impl( v16,  v94,  0LL,  0LL,  &_mh_execute_header,  v15,  0LL,  "BootDevice is %@",  v91,  12);

        if (v17) {
          sub_100053B7C(v17);
        }
      }

      else
      {

        id v17 = 0LL;
      }

      free(v17);
    }
  }

  uint64_t v18 = IOServiceMatching("AppleAPFSContainer");
  if (IOServiceGetMatchingServices(kIOMainPortDefault, v18, &existing[1]))
  {
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    unsigned int v9 = (os_log_s *)(id)qword_1000DBBD0;
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_142;
    }
    *(void *)id v91 = 0LL;
    unsigned int v19 = sub_100053B4C(1);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v20 = v19;
    }
    else {
      uint64_t v20 = v19 & 0xFFFFFFFE;
    }
    if ((_DWORD)v20)
    {
      LOWORD(v94[0]) = 0;
      uint64_t v12 = (const char *)_os_log_send_and_compose_impl( v20,  v91,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "unable to scan IORegistry");
LABEL_32:
      unsigned int v21 = (char *)v12;
      if (v12) {
        sub_100053B7C(v12);
      }
      goto LABEL_141;
    }

LABEL_140:
    unsigned int v21 = 0LL;
LABEL_141:
    free(v21);
LABEL_142:
    io_object_t v28 = 0;
    io_registry_entry_t v25 = 0;
    uint64_t v22 = 0LL;
    goto LABEL_143;
  }

  int v79 = a3;
  uint64_t v22 = 0LL;
  int v23 = 0;
  int v80 = a2;
  do
  {
    io_registry_entry_t v24 = IOIteratorNext(existing[1]);
    if (!v24) {
      goto LABEL_136;
    }
    io_registry_entry_t v25 = v24;
    io_registry_entry_t parent = 0;
    existing[0] = 0;
    if (IORegistryEntryGetParentEntry(v24, "IOService", &parent)
      || IORegistryEntryGetChildIterator(v25, "IOService", existing))
    {
      unsigned int v9 = (os_log_s *)(id)qword_1000DBBD0;
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_192;
      }
      *(void *)id v91 = 0LL;
      unsigned int v69 = sub_100053B4C(1);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v70 = v69;
      }
      else {
        uint64_t v70 = v69 & 0xFFFFFFFE;
      }
      if ((_DWORD)v70)
      {
        LOWORD(v94[0]) = 0;
        LODWORD(v7_Block_object_dispose(va, 8) = 2;
        uint64_t v71 = (const char *)_os_log_send_and_compose_impl( v70,  v91,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "unable to scan IORegistry",  v94,  v78);
        goto LABEL_186;
      }

LABEL_190:
      id v74 = 0LL;
LABEL_191:
      free(v74);
LABEL_192:
      io_object_t v28 = 0;
      goto LABEL_143;
    }

    CFMutableDictionaryRef v87 = 0LL;
    CFMutableDictionaryRef properties = 0LL;
    if (IORegistryEntryCreateCFProperties(parent, &properties, kCFAllocatorDefault, 0)
      || IORegistryEntryCreateCFProperties(v25, &v87, kCFAllocatorDefault, 0))
    {
      unsigned int v9 = (os_log_s *)(id)qword_1000DBBD0;
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_192;
      }
      *(void *)id v91 = 0LL;
      unsigned int v72 = sub_100053B4C(1);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v73 = v72;
      }
      else {
        uint64_t v73 = v72 & 0xFFFFFFFE;
      }
      if ((_DWORD)v73)
      {
        LOWORD(v94[0]) = 0;
        LODWORD(v7_Block_object_dispose(va, 8) = 2;
        uint64_t v71 = (const char *)_os_log_send_and_compose_impl( v73,  v91,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "unable to fetch IORegistry properties",  v94,  v78);
LABEL_186:
        id v74 = (char *)v71;
        if (v71) {
          sub_100053B7C(v71);
        }
        goto LABEL_191;
      }

      goto LABEL_190;
    }

    if (v87)
    {
      CFRelease(v87);
      CFMutableDictionaryRef v87 = 0LL;
    }

    if (properties)
    {
      CFRelease(properties);
      CFMutableDictionaryRef properties = 0LL;
    }

    int v81 = v23;
    if (parent)
    {
      IOObjectRelease(parent);
      io_registry_entry_t parent = 0;
    }

    io_object_t v26 = IOIteratorNext(existing[0]);
    BOOL v27 = v26 == 0;
    if (v26)
    {
      io_object_t v28 = v26;
      while (!IOObjectConformsTo(v28, "AppleAPFSVolume"))
      {
        char v30 = 0;
LABEL_126:
        IOObjectRelease(v28);
        if ((v30 & 1) == 0)
        {
          io_object_t v28 = IOIteratorNext(existing[0]);
          BOOL v27 = v28 == 0;
          if (v28) {
            continue;
          }
        }

        goto LABEL_132;
      }

      if (IORegistryEntryCreateCFProperties(v28, &theDict, kCFAllocatorDefault, 0))
      {
        unsigned int v9 = (os_log_s *)(id)qword_1000DBBD0;
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)id v91 = 0LL;
          unsigned int v65 = sub_100053B4C(1);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v66 = v65;
          }
          else {
            uint64_t v66 = v65 & 0xFFFFFFFE;
          }
          if ((_DWORD)v66)
          {
            LOWORD(v94[0]) = 0;
            LODWORD(v7_Block_object_dispose(va, 8) = 2;
            unsigned int v67 = (const char *)_os_log_send_and_compose_impl( v66,  v91,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "unable to fetch IORegistry properties",  v94,  v78);
            uint64_t v68 = (char *)v67;
            if (v67) {
              sub_100053B7C(v67);
            }
          }

          else
          {
            uint64_t v68 = 0LL;
          }

          free(v68);
        }

LABEL_143:
        goto LABEL_144;
      }

      if (a2
        && (Value = (const __CFNumber *)CFDictionaryGetValue(theDict, @"RoleValue")) != 0LL
        && (CFNumberGetValue(Value, kCFNumberSInt16Type, &valuePtr), valuePtr != a2)
        || (memset(name, 0, 128), IORegistryEntryGetName(v28, name), strncmp(a1, name, 0x80uLL)))
      {
        char v30 = 0;
        goto LABEL_124;
      }

      id v31 = (const __CFString *)CFDictionaryGetValue(theDict, @"BSD Name");
      if (v31 && v79 && prefix)
      {
        id v32 = (id)qword_1000DBBD0;
        if (os_log_type_enabled((os_log_t)v32, OS_LOG_TYPE_DEFAULT))
        {
          v94[0] = 0LL;
          unsigned int v33 = sub_100053B4C(1);
          int v34 = (os_log_s *)v32;
          if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v35 = v33;
          }
          else {
            uint64_t v35 = v33 & 0xFFFFFFFE;
          }
          if ((_DWORD)v35)
          {
            *(_DWORD *)id v91 = 138412546;
            *(void *)&_DWORD v91[4] = prefix;
            __int16 v92 = 2112;
            id v93 = v31;
            LODWORD(v7_Block_object_dispose(va, 8) = 22;
            uint64_t v36 = (char *)_os_log_send_and_compose_impl( v35,  v94,  0LL,  0LL,  &_mh_execute_header,  v34,  0LL,  "Container: %@, volumeDiskNode:%@",  v91,  v78);

            if (v36) {
              sub_100053B7C(v36);
            }
          }

          else
          {

            uint64_t v36 = 0LL;
          }

          p_name = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
          free(v36);
        }

        int HasPrefix = CFStringHasPrefix(v31, prefix);
        id v38 = p_name[379];
        if (HasPrefix)
        {
          id v39 = (id)qword_1000DBBD0;
          if (os_log_type_enabled((os_log_t)v39, OS_LOG_TYPE_DEFAULT))
          {
            v94[0] = 0LL;
            unsigned int v40 = sub_100053B4C(1);
            id v41 = (os_log_s *)v39;
            if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT)) {
              uint64_t v42 = v40;
            }
            else {
              uint64_t v42 = v40 & 0xFFFFFFFE;
            }
            if ((_DWORD)v42)
            {
              *(_DWORD *)id v91 = 138412290;
              *(void *)&_DWORD v91[4] = v31;
              LODWORD(v7_Block_object_dispose(va, 8) = 12;
              unsigned int v43 = (char *)_os_log_send_and_compose_impl( v42,  v94,  0LL,  0LL,  &_mh_execute_header,  v41,  0LL,  "Found DiskNode: %@ within the Boot Container",  v91,  v78);

              if (v43) {
                sub_100053B7C(v43);
              }
            }

            else
            {

              unsigned int v43 = 0LL;
            }

            free(v43);
            p_name = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
          }

          goto LABEL_92;
        }

        id v44 = (os_log_s *)(id)qword_1000DBBD0;
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
        {
          v94[0] = 0LL;
          unsigned int v45 = sub_100053B4C(1);
          if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v46 = v45;
          }
          else {
            uint64_t v46 = v45 & 0xFFFFFFFE;
          }
          if ((_DWORD)v46)
          {
            *(_DWORD *)id v91 = 138412290;
            *(void *)&_DWORD v91[4] = v31;
            LODWORD(v7_Block_object_dispose(va, 8) = 12;
            __int128 v47 = (const char *)_os_log_send_and_compose_impl( v46,  v94,  0LL,  0LL,  &_mh_execute_header,  v44,  0LL,  " Skipping the diskNode:%@ as its not in the Boot Container",  v91,  v78);
            __int128 v48 = (char *)v47;
            if (v47) {
              sub_100053B7C(v47);
            }
          }

          else
          {
            __int128 v48 = 0LL;
          }

          free(v48);
          p_name = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
        }

        char v30 = 0;
      }

      else
      {
LABEL_92:
        uint64_t v22 = sub_10008428C();
        CFDictionarySetValue(v22, kUMUserSessionVolumeDeviceNodeKey, v31);
        id v49 = CFDictionaryGetValue(theDict, @"UUID");
        CFDictionarySetValue(v22, kUMUserSessionVolumeUUIDKey, v49);
        if (a4)
        {
          id v50 = (const __CFBoolean *)CFDictionaryGetValue(theDict, @"Encrypted");
          if (!v50
            || (__int16 v51 = v50,
                CFTypeID v52 = CFGetTypeID(v50),
                BOOL v53 = v52 == CFBooleanGetTypeID(),
                p_name = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name,
                v53)
            && v51 == kCFBooleanFalse)
          {
            __int128 v54 = (os_log_s *)(id)qword_1000DBBD0;
            if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
            {
              *(void *)id v91 = 0LL;
              unsigned int v55 = sub_100053B4C(1);
              if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v56 = v55;
              }
              else {
                uint64_t v56 = v55 & 0xFFFFFFFE;
              }
              if ((_DWORD)v56)
              {
                LOWORD(v94[0]) = 0;
                LODWORD(v7_Block_object_dispose(va, 8) = 2;
                unsigned int v57 = (const char *)_os_log_send_and_compose_impl( v56,  v91,  0LL,  0LL,  &_mh_execute_header,  v54,  0LL,  "Volume is UnEncrypted",  v94,  v78);
                uint64_t v58 = (char *)v57;
                if (v57) {
                  sub_100053B7C(v57);
                }
              }

              else
              {
                uint64_t v58 = 0LL;
              }

              free(v58);
            }

            char v63 = 0;
          }

          else
          {
            if (qword_1000DBBD8 != -1) {
              dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
            }
            __int128 v54 = (os_log_s *)(id)qword_1000DBBD0;
            if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
            {
              *(void *)id v91 = 0LL;
              unsigned int v59 = sub_100053B4C(1);
              if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT)) {
                uint64_t v60 = v59;
              }
              else {
                uint64_t v60 = v59 & 0xFFFFFFFE;
              }
              if ((_DWORD)v60)
              {
                LOWORD(v94[0]) = 0;
                LODWORD(v7_Block_object_dispose(va, 8) = 2;
                uint64_t v61 = (const char *)_os_log_send_and_compose_impl( v60,  v91,  0LL,  0LL,  &_mh_execute_header,  v54,  0LL,  "Volume is Encrypted",  v94,  v78);
                id v62 = (char *)v61;
                if (v61) {
                  sub_100053B7C(v61);
                }
              }

              else
              {
                id v62 = 0LL;
              }

              free(v62);
            }

            char v63 = 1;
          }

          *a4 = v63;
        }

        char v30 = 1;
      }

      a2 = v80;
LABEL_124:
      if (theDict)
      {
        CFRelease(theDict);
        CFMutableDictionaryRef theDict = 0LL;
      }

      goto LABEL_126;
    }

LABEL_132:
    if (existing[0])
    {
      IOObjectRelease(existing[0]);
      existing[0] = 0;
    }

    IOObjectRelease(v25);
    int v23 = v81 + 1;
  }

  while (v27);
  int v23 = 1;
LABEL_136:
  if (existing[1])
  {
    IOObjectRelease(existing[1]);
    existing[1] = 0;
  }

  if (!v23)
  {
    unsigned int v9 = (os_log_s *)(id)qword_1000DBBD0;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)id v91 = 0LL;
      unsigned int v75 = sub_100053B4C(1);
      unsigned int v9 = v9;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v76 = v75;
      }
      else {
        uint64_t v76 = v75 & 0xFFFFFFFE;
      }
      if ((_DWORD)v76)
      {
        LOWORD(v94[0]) = 0;
        LODWORD(v7_Block_object_dispose(va, 8) = 2;
        uint64_t v77 = (char *)_os_log_send_and_compose_impl( v76,  v91,  0LL,  0LL,  &_mh_execute_header,  v9,  0LL,  "no APFS containers found",  v94,  v78);

        if (v77) {
          sub_100053B7C(v77);
        }
      }

      else
      {

        uint64_t v77 = 0LL;
      }

      free(v77);
    }

    io_object_t v28 = 0;
    io_registry_entry_t v25 = 0;
    goto LABEL_143;
  }

  io_object_t v28 = 0;
  io_registry_entry_t v25 = 0;
LABEL_144:
  if (prefix)
  {
    CFRelease(prefix);
    CFStringRef prefix = 0LL;
  }

  if (v87)
  {
    CFRelease(v87);
    CFMutableDictionaryRef v87 = 0LL;
  }

  if (properties)
  {
    CFRelease(properties);
    CFMutableDictionaryRef properties = 0LL;
  }

  if (parent)
  {
    IOObjectRelease(parent);
    io_registry_entry_t parent = 0;
  }

  if (existing[0])
  {
    IOObjectRelease(existing[0]);
    existing[0] = 0;
  }

  if (v25) {
    IOObjectRelease(v25);
  }
  if (existing[1])
  {
    IOObjectRelease(existing[1]);
    existing[1] = 0;
  }

  if (v28) {
    IOObjectRelease(v28);
  }
  return v22;
}

uint64_t sub_100078D90(__CFDictionary *a1, uint64_t a2, const __CFString *a3, _DWORD *a4, char a5)
{
  CFStringRef theString = 0LL;
  int BootDevice = APFSContainerGetBootDevice(&theString);
  if (BootDevice)
  {
    int v11 = BootDevice;
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    uint64_t v12 = (os_log_s *)(id)qword_1000DBBD0;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)buffer = 0LL;
      unsigned int v13 = sub_100053B4C(1);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v14 = v13;
      }
      else {
        uint64_t v14 = v13 & 0xFFFFFFFE;
      }
      if ((_DWORD)v14)
      {
        *(_DWORD *)__str = 67109120;
        *(_DWORD *)&char __str[4] = v11;
        unsigned int v15 = (const char *)_os_log_send_and_compose_impl( v14,  buffer,  0LL,  0LL,  &_mh_execute_header,  v12,  0LL,  "APFSContainerGetBootDevice failed with %d",  __str);
        uint64_t v16 = (char *)v15;
        if (v15) {
          sub_100053B7C(v15);
        }
      }

      else
      {
        uint64_t v16 = 0LL;
      }

      free(v16);
    }

    if (a4)
    {
      uint64_t result = 0LL;
      *a4 = v11;
      return result;
    }

    return 0LL;
  }

  strcpy(v77, "/dev/");
  CFStringGetCString(theString, &v77[5], 59LL, 0x8000100u);
  CFRelease(theString);
  if (qword_1000DBBD8 != -1) {
    dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
  }
  id v17 = (os_log_s *)(id)qword_1000DBBD0;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)__str = 0LL;
    unsigned int v18 = sub_100053B4C(1);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v19 = v18;
    }
    else {
      uint64_t v19 = v18 & 0xFFFFFFFE;
    }
    if ((_DWORD)v19)
    {
      *(_DWORD *)buffer = 138412290;
      *(void *)&buffer[4] = a3;
      uint64_t v20 = (const char *)_os_log_send_and_compose_impl( v19,  __str,  0LL,  0LL,  &_mh_execute_header,  v17,  0LL,  "Creating an APFS UserVolume for username:%@",  buffer,  12);
      unsigned int v21 = (char *)v20;
      if (v20) {
        sub_100053B7C(v20);
      }
    }

    else
    {
      unsigned int v21 = 0LL;
    }

    free(v21);
  }

  CFStringGetCString(a3, buffer, 256LL, 0x8000100u);
  if ((a5 & 1) != 0)
  {
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    int v23 = (os_log_s *)(id)qword_1000DBBD0;
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)__argv = 0LL;
      unsigned int v24 = sub_100053B4C(1);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v25 = v24;
      }
      else {
        uint64_t v25 = v24 & 0xFFFFFFFE;
      }
      if ((_DWORD)v25)
      {
        *(_DWORD *)__str = 136315138;
        *(void *)&char __str[4] = buffer;
        io_object_t v26 = (const char *)_os_log_send_and_compose_impl( v25,  __argv,  0LL,  0LL,  &_mh_execute_header,  v23,  0LL,  "Creating an APFS PersonaVolume with volumename:%s",  __str);
        BOOL v27 = (char *)v26;
        if (v26) {
          sub_100053B7C(v26);
        }
      }

      else
      {
        BOOL v27 = 0LL;
      }

      free(v27);
    }

    *(void *)__argv = "/sbin/newfs_apfs";
    int v33 = 3;
    int v34 = buffer;
    uint64_t v35 = 2LL;
    uint64_t v36 = 1LL;
    __int16 v37 = "-v";
    goto LABEL_52;
  }

  snprintf(__str, 0x100uLL, "%zu", a2);
  if (qword_1000DBBD8 != -1) {
    dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
  }
  io_object_t v28 = (os_log_s *)(id)qword_1000DBBD0;
  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)int v80 = 0LL;
    unsigned int v29 = sub_100053B4C(1);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v30 = v29;
    }
    else {
      uint64_t v30 = v29 & 0xFFFFFFFE;
    }
    if ((_DWORD)v30)
    {
      *(_DWORD *)__argv = 136315394;
      *(void *)&__argv[4] = buffer;
      *(_WORD *)&__argv[12] = 2080;
      *(void *)&__argv[14] = __str;
      LODWORD(v74) = 22;
      id v31 = (const char *)_os_log_send_and_compose_impl( v30,  v80,  0LL,  0LL,  &_mh_execute_header,  v28,  0LL,  "Creating an APFS UserVolume for username:%s with size:%s",  __argv,  v74);
      id v32 = (char *)v31;
      if (v31) {
        sub_100053B7C(v31);
      }
    }

    else
    {
      id v32 = 0LL;
    }

    free(v32);
  }

  *(void *)__argv = "/sbin/newfs_apfs";
  *(void *)&__argv[8] = "-v";
  *(void *)&__argv[16] = buffer;
  int v33 = 3;
  if (a2)
  {
    int v33 = 5;
    int v34 = __str;
    uint64_t v35 = 4LL;
    uint64_t v36 = 3LL;
    __int16 v37 = "-s";
LABEL_52:
    *(void *)&__argv[8 * v36] = v37;
    *(void *)&__argv[8 * v35] = v34;
  }

  *(void *)&__argv[8 * v33] = "-P";
  *(void *)&__argv[8 * (v33 + 1)] = "-w";
  *(void *)&__argv[8 * (v33 + 2)] = "-A";
  *(void *)&__argv[8 * (v33 + 3)] = v77;
  *(void *)&__argv[8 * (v33 + 4)] = 0LL;
  int v38 = sub_10001D0CC((const char **)__argv);
  if (v38)
  {
    int v39 = v38;
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    unsigned int v40 = (os_log_s *)(id)qword_1000DBBD0;
    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)int v80 = 0LL;
      unsigned int v41 = sub_100053B4C(1);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v42 = v41;
      }
      else {
        uint64_t v42 = v41 & 0xFFFFFFFE;
      }
      if ((_DWORD)v42)
      {
        LODWORD(v83) = 67109120;
        HIDWORD(v83) = v39;
        unsigned int v43 = (const char *)_os_log_send_and_compose_impl( v42,  v80,  0LL,  0LL,  &_mh_execute_header,  v40,  0LL,  "newfs_apfs failed with %d",  &v83);
        id v44 = (char *)v43;
        if (v43) {
          sub_100053B7C(v43);
        }
      }

      else
      {
        id v44 = 0LL;
      }

      free(v44);
    }

    if (a4)
    {
      uint64_t result = 0LL;
      *a4 = v39;
      return result;
    }

    return 0LL;
  }

  if (qword_1000DBBD8 != -1) {
    dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
  }
  unsigned int v45 = (os_log_s *)(id)qword_1000DBBD0;
  if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)int v80 = 0LL;
    unsigned int v46 = sub_100053B4C(1);
    if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v47 = v46;
    }
    else {
      uint64_t v47 = v46 & 0xFFFFFFFE;
    }
    if ((_DWORD)v47)
    {
      LOWORD(v83) = 0;
      LODWORD(v74) = 2;
      __int128 v48 = (const char *)_os_log_send_and_compose_impl( v47,  v80,  0LL,  0LL,  &_mh_execute_header,  v45,  0LL,  "newfs_apfs Success",  &v83,  v74);
      id v49 = (char *)v48;
      if (v48) {
        sub_100053B7C(v48);
      }
    }

    else
    {
      id v49 = 0LL;
    }

    free(v49);
  }

  id v50 = sub_100077F90(buffer, 0, 0, 0LL);
  if (!v50)
  {
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    unsigned int v59 = (os_log_s *)(id)qword_1000DBBD0;
    if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v83 = 0LL;
      unsigned int v60 = sub_100053B4C(1);
      if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v61 = v60;
      }
      else {
        uint64_t v61 = v60 & 0xFFFFFFFE;
      }
      if ((_DWORD)v61)
      {
        *(_DWORD *)int v80 = 138412290;
        *(void *)&v80[4] = a3;
        LODWORD(v74) = 12;
        id v62 = (const char *)_os_log_send_and_compose_impl( v61,  &v83,  0LL,  0LL,  &_mh_execute_header,  v59,  0LL,  "Failed to obtain device node for the newly created volume for the User:%@",  v80,  v74);
        char v63 = (char *)v62;
        if (v62) {
          sub_100053B7C(v62);
        }
      }

      else
      {
        char v63 = 0LL;
      }

      free(v63);
    }

    return 0LL;
  }

  __int16 v51 = v50;
  Value = CFDictionaryGetValue(v50, kUMUserSessionVolumeDeviceNodeKey);
  BOOL v53 = CFDictionaryGetValue(v51, kUMUserSessionVolumeUUIDKey);
  CFDictionarySetValue(a1, kUMUserSessionVolumeDeviceNodeKey, Value);
  CFDictionarySetValue(a1, kUMUserSessionVolumeUUIDKey, v53);
  CFDictionarySetValue(a1, kUMUserSessionNeedsMountKey, kCFBooleanTrue);
  if (qword_1000DBBD8 != -1) {
    dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
  }
  __int128 v54 = (os_log_s *)(id)qword_1000DBBD0;
  if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v83 = 0LL;
    unsigned int v55 = sub_100053B4C(1);
    if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v56 = v55;
    }
    else {
      uint64_t v56 = v55 & 0xFFFFFFFE;
    }
    if ((_DWORD)v56)
    {
      *(_DWORD *)int v80 = 138412546;
      *(void *)&v80[4] = Value;
      __int16 v81 = 2112;
      uint64_t v82 = v53;
      LODWORD(v74) = 22;
      unsigned int v57 = (const char *)_os_log_send_and_compose_impl( v56,  &v83,  0LL,  0LL,  &_mh_execute_header,  v54,  0LL,  "Added Keys for disk:%@, volumeuuid:%@",  v80,  v74);
      uint64_t v58 = (char *)v57;
      if (v57) {
        sub_100053B7C(v57);
      }
    }

    else
    {
      uint64_t v58 = 0LL;
    }

    free(v58);
  }

  CFRelease(v51);
  if (qword_1000DBBD8 != -1) {
    dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
  }
  __int16 v64 = (os_log_s *)(id)qword_1000DBBD0;
  if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v83 = 0LL;
    unsigned int v65 = sub_100053B4C(1);
    if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v66 = v65;
    }
    else {
      uint64_t v66 = v65 & 0xFFFFFFFE;
    }
    if ((_DWORD)v66)
    {
      *(_DWORD *)int v80 = 138412290;
      *(void *)&v80[4] = a3;
      LODWORD(v74) = 12;
      unsigned int v67 = (const char *)_os_log_send_and_compose_impl( v66,  &v83,  0LL,  0LL,  &_mh_execute_header,  v64,  0LL,  "Successful creation of volume with  with user name %@",  v80,  v74);
      uint64_t v68 = (char *)v67;
      if (v67) {
        sub_100053B7C(v67);
      }
    }

    else
    {
      uint64_t v68 = 0LL;
    }

    free(v68);
  }

  if (qword_1000DBBD8 != -1) {
    dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
  }
  unsigned int v69 = (os_log_s *)(id)qword_1000DBBD0;
  if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v83 = 0LL;
    unsigned int v70 = sub_100053B4C(1);
    if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v71 = v70;
    }
    else {
      uint64_t v71 = v70 & 0xFFFFFFFE;
    }
    if ((_DWORD)v71)
    {
      *(_DWORD *)int v80 = 138412290;
      *(void *)&v80[4] = a1;
      LODWORD(v74) = 12;
      unsigned int v72 = (const char *)_os_log_send_and_compose_impl( v71,  &v83,  0LL,  0LL,  &_mh_execute_header,  v69,  0LL,  "Modified Session now is %@",  v80,  v74);
      uint64_t v73 = (char *)v72;
      if (v72) {
        sub_100053B7C(v72);
      }
    }

    else
    {
      uint64_t v73 = 0LL;
    }

    free(v73);
  }

  return 1LL;
}

uint64_t sub_100079878(const __CFDictionary *a1, _DWORD *a2)
{
  int v4 = sub_100079BDC(a1, (char *)v26);
  if (v4)
  {
    if (a2)
    {
      int v5 = v4;
      uint64_t result = 0LL;
      *a2 = v5;
      return result;
    }

    return 0LL;
  }

  if (qword_1000DBBD8 != -1) {
    dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
  }
  unsigned int v7 = (os_log_s *)(id)qword_1000DBBD0;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    v25[0] = 0LL;
    unsigned int v8 = sub_100053B4C(1);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v9 = v8;
    }
    else {
      uint64_t v9 = v8 & 0xFFFFFFFE;
    }
    if ((_DWORD)v9)
    {
      *(_DWORD *)unsigned int v24 = 136315138;
      *(void *)&v24[4] = v26;
      unsigned int v10 = (const char *)_os_log_send_and_compose_impl( v9,  v25,  0LL,  0LL,  &_mh_execute_header,  v7,  0LL,  "Deleting APFS User Volume for the node %s",  v24);
      int v11 = (char *)v10;
      if (v10) {
        sub_100053B7C(v10);
      }
    }

    else
    {
      int v11 = 0LL;
    }

    free(v11);
  }

  int v12 = APFSVolumeDelete(v26);
  if (v12)
  {
    int v13 = v12;
    if (a2) {
      *a2 = v12;
    }
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    uint64_t v14 = (os_log_s *)(id)qword_1000DBBD0;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)unsigned int v24 = 0LL;
      unsigned int v15 = sub_100053B4C(1);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v16 = v15;
      }
      else {
        uint64_t v16 = v15 & 0xFFFFFFFE;
      }
      if ((_DWORD)v16)
      {
        LODWORD(v25[0]) = 67109120;
        HIDWORD(v25[0]) = v13;
        id v17 = (const char *)_os_log_send_and_compose_impl( v16,  v24,  0LL,  0LL,  &_mh_execute_header,  v14,  0LL,  "deleteAPFSUserVolume failed with %d",  v25);
        unsigned int v18 = (char *)v17;
        if (v17) {
          sub_100053B7C(v17);
        }
      }

      else
      {
        unsigned int v18 = 0LL;
      }

      free(v18);
    }

    return 0LL;
  }

  if (qword_1000DBBD8 != -1) {
    dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
  }
  uint64_t v19 = (os_log_s *)(id)qword_1000DBBD0;
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)unsigned int v24 = 0LL;
    unsigned int v20 = sub_100053B4C(1);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v21 = v20;
    }
    else {
      uint64_t v21 = v20 & 0xFFFFFFFE;
    }
    if ((_DWORD)v21)
    {
      LOWORD(v25[0]) = 0;
      uint64_t v22 = (const char *)_os_log_send_and_compose_impl( v21,  v24,  0LL,  0LL,  &_mh_execute_header,  v19,  0LL,  "deleteAPFSUserVolume succeeded",  v25,  2);
      int v23 = (char *)v22;
      if (v22) {
        sub_100053B7C(v22);
      }
    }

    else
    {
      int v23 = 0LL;
    }

    free(v23);
  }

  return 1LL;
}

uint64_t sub_100079BDC(__CFDictionary *a1, char *a2)
{
  CFStringRef theString = 0LL;
  if (a2)
  {
    uint64_t BootDevice = APFSContainerGetBootDevice(&theString);
    if ((_DWORD)BootDevice)
    {
      uint64_t v5 = BootDevice;
      if (qword_1000DBBD8 != -1) {
        dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
      }
      uint64_t v6 = (os_log_s *)(id)qword_1000DBBD0;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)buffer = 0LL;
        unsigned int v7 = sub_100053B4C(1);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v8 = v7;
        }
        else {
          uint64_t v8 = v7 & 0xFFFFFFFE;
        }
        if ((_DWORD)v8)
        {
          *(_DWORD *)io_object_t v26 = 67109120;
          *(_DWORD *)&v26[4] = v5;
          uint64_t v9 = (const char *)_os_log_send_and_compose_impl( v8,  buffer,  0LL,  0LL,  &_mh_execute_header,  v6,  0LL,  "APFSContainerGetBootDevice failed with %d",  v26);
          unsigned int v10 = (char *)v9;
          if (v9) {
            sub_100053B7C(v9);
          }
        }

        else
        {
          unsigned int v10 = 0LL;
        }

        free(v10);
      }

      return v5;
    }

    CFStringGetCString(theString, buffer, 64LL, 0x8000100u);
    CFRelease(theString);
    if (strstr(a2, buffer)) {
      return 0LL;
    }
    uint64_t v16 = strrchr(a2, 115);
    if (v16)
    {
      __strcat_chk(buffer, v16, 64LL);
      strlcpy(a2, buffer, 0x100uLL);
      CFStringRef v17 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
      CFDictionarySetValue(a1, kUMUserSessionVolumeDeviceNodeKey, v17);
      CFRelease(v17);
      return 0LL;
    }

    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    uint64_t v19 = (os_log_s *)(id)qword_1000DBBD0;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v24 = 0LL;
      unsigned int v20 = sub_100053B4C(1);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v21 = v20;
      }
      else {
        uint64_t v21 = v20 & 0xFFFFFFFE;
      }
      if ((_DWORD)v21)
      {
        *(_DWORD *)io_object_t v26 = 136315394;
        *(void *)&v26[4] = a2;
        __int16 v27 = 2080;
        io_object_t v28 = buffer;
        uint64_t v22 = (const char *)_os_log_send_and_compose_impl( v21,  &v24,  0LL,  0LL,  &_mh_execute_header,  v19,  0LL,  "Failed to update userdata volume device %s (%s)\n",  v26,  22);
        int v23 = (char *)v22;
        if (v22) {
          sub_100053B7C(v22);
        }
      }

      else
      {
        int v23 = 0LL;
      }

      free(v23);
    }

    return 19LL;
  }

  else
  {
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    int v11 = (os_log_s *)(id)qword_1000DBBD0;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)io_object_t v26 = 0LL;
      unsigned int v12 = sub_100053B4C(1);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v13 = v12;
      }
      else {
        uint64_t v13 = v12 & 0xFFFFFFFE;
      }
      if ((_DWORD)v13)
      {
        *(_DWORD *)buffer = 136315138;
        *(void *)&buffer[4] = "updateAPFSDevWithCurrentBootContainer";
        uint64_t v14 = (const char *)_os_log_send_and_compose_impl( v13,  v26,  0LL,  0LL,  &_mh_execute_header,  v11,  0LL,  "%s: Invalid input parameters\n",  buffer);
        unsigned int v15 = (char *)v14;
        if (v14) {
          sub_100053B7C(v14);
        }
      }

      else
      {
        unsigned int v15 = 0LL;
      }

      free(v15);
    }

    return 22LL;
  }

uint64_t sub_100079FB8(const __CFDictionary *a1, const __CFString *a2, _DWORD *a3, int a4)
{
  if (a2 && (CFTypeID v8 = CFGetTypeID(a2), v8 == CFStringGetTypeID())) {
    CFStringGetCString(a2, buffer, 1024LL, 0x8000100u);
  }
  else {
    sub_100083E34(a1, kUMUserSessionHomeDirKey, buffer, 1024);
  }
  sub_100083E34(a1, kUMUserSessionVolumeDeviceNodeKey, (char *)v116, 256);
  int v9 = sub_100079BDC(a1, (char *)v116);
  if (v9)
  {
    uint64_t v10 = 0LL;
    if (a3) {
      *a3 = v9;
    }
    return v10;
  }

  if (a4)
  {
    if (byte_1000DBD3A) {
      dev_t v11 = sub_10001D0C0();
    }
    else {
      dev_t v11 = 501;
    }
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    id v13 = (id)qword_1000DBBD0;
    if (os_log_type_enabled((os_log_t)v13, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)__argv = 0LL;
      unsigned int v18 = sub_100053B4C(1);
      id v13 = v13;
      if (os_log_type_enabled((os_log_t)v13, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v19 = v18;
      }
      else {
        uint64_t v19 = v18 & 0xFFFFFFFE;
      }
      if ((_DWORD)v19)
      {
        v112.st_dev = 136315650;
        *(void *)&v112.st_mode = buffer;
        WORD2(v112.st_ino) = 2080;
        *(__darwin_ino64_t *)((char *)&v112.st_ino + 6) = (__darwin_ino64_t)v116;
        HIWORD(v112.st_gid) = 1024;
        v112.st_rdev = v11;
        LODWORD(v107) = 28;
        unsigned int v20 = (char *)_os_log_send_and_compose_impl( v19,  __argv,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "Mounting APFS user mount at %s from %s for user:%d",  (const char *)&v112,  v107,  v108);

        if (v20) {
          sub_100053B7C(v20);
        }
      }

      else
      {

        unsigned int v20 = 0LL;
      }

      free(v20);
    }

    gid_t v12 = v11;
  }

  else
  {
    dev_t v11 = sub_100083C6C(a1, kUMUserSessionIDKey);
    gid_t v12 = sub_100083C6C(a1, kUMUserSessionGroupIDKey);
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    id v13 = (id)qword_1000DBBD0;
    if (os_log_type_enabled((os_log_t)v13, OS_LOG_TYPE_DEFAULT))
    {
      gid_t v14 = v12;
      *(void *)&v112.st_dev = 0LL;
      unsigned int v15 = sub_100053B4C(1);
      id v13 = v13;
      if (os_log_type_enabled((os_log_t)v13, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v16 = v15;
      }
      else {
        uint64_t v16 = v15 & 0xFFFFFFFE;
      }
      if ((_DWORD)v16)
      {
        *(_DWORD *)__argv = 67109120;
        *(_DWORD *)&__argv[4] = v11;
        CFStringRef v17 = (char *)_os_log_send_and_compose_impl( v16,  &v112,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "Mounting APFS user mount for user %d",  __argv);

        if (v17) {
          sub_100053B7C(v17);
        }
      }

      else
      {

        CFStringRef v17 = 0LL;
      }

      free(v17);
      gid_t v12 = v14;
    }
  }

  if (stat(buffer, &v112))
  {
    int v21 = *__error();
    if (v21 != 2)
    {
      if (qword_1000DBBD8 != -1) {
        dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
      }
      int v34 = (os_log_s *)(id)qword_1000DBBD0;
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)uint64_t v110 = 0LL;
        LODWORD(v35) = sub_100053B4C(1);
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v35 = v35;
        }
        else {
          uint64_t v35 = v35 & 0xFFFFFFFE;
        }
        if ((_DWORD)v35)
        {
          uint64_t v36 = v34;
          __int16 v37 = strerror(v21);
          *(_DWORD *)__argv = 136315394;
          *(void *)&__argv[4] = buffer;
          *(_WORD *)&__argv[12] = 2080;
          *(void *)&__argv[14] = v37;
          LODWORD(v107) = 22;
          int v38 = (char *)_os_log_send_and_compose_impl( v35,  v110,  0LL,  0LL,  &_mh_execute_header,  v36,  0LL,  "Failed to stat file path %s, with error %s ",  __argv,  v107);

          if (v38) {
            sub_100053B7C(v38);
          }
        }

        else
        {
          int v38 = 0LL;
        }

        free(v38);
      }

      return 0LL;
    }

    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    id v22 = (id)qword_1000DBBD0;
    if (os_log_type_enabled((os_log_t)v22, OS_LOG_TYPE_DEFAULT))
    {
      gid_t v23 = v12;
      *(void *)uint64_t v110 = 0LL;
      unsigned int v24 = sub_100053B4C(1);
      uint64_t v25 = (os_log_s *)v22;
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v26 = v24;
      }
      else {
        uint64_t v26 = v24 & 0xFFFFFFFE;
      }
      if ((_DWORD)v26)
      {
        *(_DWORD *)__argv = 136315138;
        *(void *)&__argv[4] = buffer;
        __int16 v27 = (char *)_os_log_send_and_compose_impl( v26,  v110,  0LL,  0LL,  &_mh_execute_header,  v25,  0LL,  "pathname %s does not exist, creating",  __argv);

        if (v27) {
          sub_100053B7C(v27);
        }
      }

      else
      {

        __int16 v27 = 0LL;
      }

      free(v27);
      gid_t v12 = v23;
    }

    if (mkdir(buffer, 0x1C0u) < 0)
    {
      int v39 = *__error();
      if (v39 != 17)
      {
        if (qword_1000DBBD8 != -1) {
          dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
        }
        char v63 = (os_log_s *)(id)qword_1000DBBD0;
        if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)uint64_t v110 = 0LL;
          LODWORD(v64) = sub_100053B4C(1);
          if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v64 = v64;
          }
          else {
            uint64_t v64 = v64 & 0xFFFFFFFE;
          }
          if ((_DWORD)v64)
          {
            unsigned int v65 = v63;
            uint64_t v66 = strerror(v39);
            *(_DWORD *)__argv = 136315394;
            *(void *)&__argv[4] = buffer;
            *(_WORD *)&__argv[12] = 2080;
            *(void *)&__argv[14] = v66;
            LODWORD(v107) = 22;
            unsigned int v67 = (char *)_os_log_send_and_compose_impl( v64,  v110,  0LL,  0LL,  &_mh_execute_header,  v65,  0LL,  "Failed to created file path %s, with error %s ",  __argv,  v107);

            if (v67) {
              sub_100053B7C(v67);
            }
          }

          else
          {
            unsigned int v67 = 0LL;
          }

          free(v67);
        }

        if (!a3) {
          return 0LL;
        }
        goto LABEL_234;
      }
    }

    if (chown(buffer, v11, v12))
    {
      int v40 = *__error();
      if (qword_1000DBBD8 != -1) {
        dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
      }
      unsigned int v41 = (os_log_s *)(id)qword_1000DBBD0;
      if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)uint64_t v110 = 0LL;
        LODWORD(v42) = sub_100053B4C(1);
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v42 = v42;
        }
        else {
          uint64_t v42 = v42 & 0xFFFFFFFE;
        }
        if ((_DWORD)v42)
        {
          unsigned int v43 = v41;
          id v44 = strerror(v40);
          *(_DWORD *)__argv = 136315906;
          *(void *)&__argv[4] = buffer;
          *(_WORD *)&__argv[12] = 1024;
          *(_DWORD *)&__argv[14] = v11;
          *(_WORD *)&__argv[18] = 1024;
          *(_DWORD *)&__argv[20] = v12;
          LOWORD(v114) = 2080;
          *(void *)((char *)&v114 + 2) = v44;
          unsigned int v45 = (char *)_os_log_send_and_compose_impl( v42,  v110,  0LL,  0LL,  &_mh_execute_header,  v43,  0LL,  "Failed to chown path %s for uid=%d, gid=%d with error %s ",  __argv,  34,  v108,  v109);

          if (v45) {
            sub_100053B7C(v45);
          }
        }

        else
        {
          unsigned int v45 = 0LL;
        }

        free(v45);
      }

      rmdir(buffer);
      if (!a3) {
        return 0LL;
      }
LABEL_234:
      uint64_t v10 = 0LL;
      *a3 = 22;
      return v10;
    }
  }

  else
  {
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    id v28 = (id)qword_1000DBBD0;
    if (os_log_type_enabled((os_log_t)v28, OS_LOG_TYPE_DEFAULT))
    {
      gid_t v29 = v12;
      *(void *)__argv = 0LL;
      unsigned int v30 = sub_100053B4C(1);
      id v31 = (os_log_s *)v28;
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v32 = v30;
      }
      else {
        uint64_t v32 = v30 & 0xFFFFFFFE;
      }
      if ((_DWORD)v32)
      {
        *(_DWORD *)uint64_t v110 = 67109120;
        *(_DWORD *)&v110[4] = v11;
        int v33 = (char *)_os_log_send_and_compose_impl( v32,  __argv,  0LL,  0LL,  &_mh_execute_header,  v31,  0LL,  "User mount path exists already for user %d",  v110);

        if (v33) {
          sub_100053B7C(v33);
        }
      }

      else
      {

        int v33 = 0LL;
      }

      free(v33);
      gid_t v12 = v29;
    }
  }

  if (qword_1000DBBD8 != -1) {
    dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
  }
  id v46 = (id)qword_1000DBBD0;
  if (os_log_type_enabled((os_log_t)v46, OS_LOG_TYPE_DEFAULT))
  {
    gid_t v47 = v12;
    *(void *)__argv = 0LL;
    unsigned int v48 = sub_100053B4C(1);
    id v49 = (os_log_s *)v46;
    if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v50 = v48;
    }
    else {
      uint64_t v50 = v48 & 0xFFFFFFFE;
    }
    if ((_DWORD)v50)
    {
      *(_WORD *)uint64_t v110 = 0;
      LODWORD(v107) = 2;
      __int16 v51 = (char *)_os_log_send_and_compose_impl( v50,  __argv,  0LL,  0LL,  &_mh_execute_header,  v49,  0LL,  "Checking to see if already mounted",  v110,  v107);

      if (v51) {
        sub_100053B7C(v51);
      }
    }

    else
    {

      __int16 v51 = 0LL;
    }

    free(v51);
    gid_t v12 = v47;
  }

  if (sub_10007B2C4(a1, 0LL) != 1)
  {
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    id v57 = (id)qword_1000DBBD0;
    if (os_log_type_enabled((os_log_t)v57, OS_LOG_TYPE_DEFAULT))
    {
      gid_t v58 = v12;
      *(void *)uint64_t v110 = 0LL;
      unsigned int v59 = sub_100053B4C(1);
      unsigned int v60 = (os_log_s *)v57;
      if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v61 = v59;
      }
      else {
        uint64_t v61 = v59 & 0xFFFFFFFE;
      }
      if ((_DWORD)v61)
      {
        *(_DWORD *)__argv = 136315394;
        *(void *)&__argv[4] = v116;
        *(_WORD *)&__argv[12] = 2080;
        *(void *)&__argv[14] = buffer;
        LODWORD(v107) = 22;
        id v62 = (char *)_os_log_send_and_compose_impl( v61,  v110,  0LL,  0LL,  &_mh_execute_header,  v60,  0LL,  "Mounting the volume with Device:%s  mounted on %s",  __argv,  v107);

        if (v62) {
          sub_100053B7C(v62);
        }
      }

      else
      {

        id v62 = 0LL;
      }

      free(v62);
      gid_t v12 = v58;
    }

    *(void *)__argv = "/sbin/mount_apfs";
    if ((a4 & 1) != 0)
    {
      int v68 = 1;
    }

    else
    {
      *(void *)&__argv[8] = "-o";
      *(void *)&__argv[16] = "nosuid";
      *(void *)&__int128 v114 = "-o";
      *((void *)&v114 + 1) = "nodev";
      int v68 = 5;
    }

    *(void *)&__argv[8 * v68] = v116;
    *(void *)&__argv[8 * (v68 + 1)] = buffer;
    *(void *)&__argv[8 * (v68 | 2)] = 0LL;
    int v69 = sub_10001D0CC((const char **)__argv);
    if (v69)
    {
      int v70 = v69;
      if (qword_1000DBBD8 != -1) {
        dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
      }
      uint64_t v71 = (os_log_s *)(id)qword_1000DBBD0;
      if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
      {
        gid_t v72 = v12;
        *(void *)uint64_t v110 = 0LL;
        unsigned int v73 = sub_100053B4C(1);
        if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v74 = v73;
        }
        else {
          uint64_t v74 = v73 & 0xFFFFFFFE;
        }
        if ((_DWORD)v74)
        {
          LODWORD(v111[0]) = 67109120;
          HIDWORD(v111[0]) = v70;
          unsigned int v75 = (const char *)_os_log_send_and_compose_impl( v74,  v110,  0LL,  0LL,  &_mh_execute_header,  v71,  0LL,  "mountfs_apfs failed with %d",  v111);
          uint64_t v76 = (char *)v75;
          if (v75) {
            sub_100053B7C(v75);
          }
        }

        else
        {
          uint64_t v76 = 0LL;
        }

        free(v76);
        gid_t v12 = v72;
      }

      if (a3)
      {
        uint64_t v10 = 0LL;
        *a3 = v70;
        if (!a2) {
          goto LABEL_230;
        }
        goto LABEL_163;
      }

      goto LABEL_162;
    }

    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    id v77 = (id)qword_1000DBBD0;
    if (os_log_type_enabled((os_log_t)v77, OS_LOG_TYPE_DEFAULT))
    {
      gid_t v78 = v12;
      v111[0] = 0LL;
      unsigned int v79 = sub_100053B4C(1);
      int v80 = (os_log_s *)v77;
      if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v81 = v79;
      }
      else {
        uint64_t v81 = v79 & 0xFFFFFFFE;
      }
      if ((_DWORD)v81)
      {
        *(_DWORD *)uint64_t v110 = 136315394;
        *(void *)&v110[4] = v116;
        *(_WORD *)&v110[12] = 2080;
        *(void *)&v110[14] = buffer;
        LODWORD(v107) = 22;
        uint64_t v82 = (char *)_os_log_send_and_compose_impl( v81,  v111,  0LL,  0LL,  &_mh_execute_header,  v80,  0LL,  "mountfs_apfs: Device:%s  mounted on %s",  v110,  v107);

        if (v82) {
          sub_100053B7C(v82);
        }
      }

      else
      {

        uint64_t v82 = 0LL;
      }

      free(v82);
      gid_t v12 = v78;
    }

    if ((a4 & 1) == 0)
    {
      if (CFDictionaryContainsKey(a1, kUMUserSessionVolumeMountedKey)) {
        CFDictionaryReplaceValue(a1, kUMUserSessionVolumeMountedKey, kCFBooleanTrue);
      }
      else {
        CFDictionarySetValue(a1, kUMUserSessionVolumeMountedKey, kCFBooleanTrue);
      }
    }

    if (chown(buffer, v11, v12))
    {
      if (qword_1000DBBD8 != -1) {
        dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
      }
      id v88 = (id)qword_1000DBBD0;
      if (os_log_type_enabled((os_log_t)v88, OS_LOG_TYPE_DEFAULT))
      {
        v111[0] = 0LL;
        unsigned int v89 = sub_100053B4C(1);
        id v88 = v88;
        if (os_log_type_enabled((os_log_t)v88, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v90 = v89;
        }
        else {
          uint64_t v90 = v89 & 0xFFFFFFFE;
        }
        if ((_DWORD)v90)
        {
          *(_DWORD *)uint64_t v110 = 67109378;
          *(_DWORD *)&v110[4] = v11;
          *(_WORD *)&v110[8] = 2080;
          *(void *)&v110[10] = buffer;
          LODWORD(v107) = 18;
          uint64_t v91 = _os_log_send_and_compose_impl( v90,  v111,  0LL,  0LL,  &_mh_execute_header,  v88,  0LL,  "Failed to set uid/gid:%d to path:%s",  v110,  v107);
          goto LABEL_198;
        }

        goto LABEL_200;
      }
    }

    else
    {
      if (qword_1000DBBD8 != -1) {
        dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
      }
      id v88 = (id)qword_1000DBBD0;
      if (os_log_type_enabled((os_log_t)v88, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)uint64_t v110 = 0LL;
        unsigned int v92 = sub_100053B4C(1);
        id v88 = v88;
        if (os_log_type_enabled((os_log_t)v88, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v93 = v92;
        }
        else {
          uint64_t v93 = v92 & 0xFFFFFFFE;
        }
        if ((_DWORD)v93)
        {
          LOWORD(v111[0]) = 0;
          LODWORD(v107) = 2;
          uint64_t v91 = _os_log_send_and_compose_impl( v93,  v110,  0LL,  0LL,  &_mh_execute_header,  v88,  0LL,  "Set approp ownership on mounted path",  v111,  v107);
LABEL_198:
          uint64_t v94 = (char *)v91;

          if (v94) {
            sub_100053B7C(v94);
          }
          goto LABEL_201;
        }

LABEL_200:
        uint64_t v94 = 0LL;
LABEL_201:
        free(v94);
      }
    }

    if (a2) {
      int v95 = 1;
    }
    else {
      int v95 = a4;
    }
    if (v95) {
      mode_t v96 = 457;
    }
    else {
      mode_t v96 = 448;
    }
    if (chmod(buffer, v96))
    {
      if (qword_1000DBBD8 != -1) {
        dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
      }
      id v97 = (id)qword_1000DBBD0;
      if (os_log_type_enabled((os_log_t)v97, OS_LOG_TYPE_DEFAULT))
      {
        v111[0] = 0LL;
        unsigned int v98 = sub_100053B4C(1);
        unsigned int v99 = (os_log_s *)v97;
        if (os_log_type_enabled(v99, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v100 = v98;
        }
        else {
          uint64_t v100 = v98 & 0xFFFFFFFE;
        }
        if ((_DWORD)v100)
        {
          *(_DWORD *)uint64_t v110 = 136315138;
          *(void *)&v110[4] = buffer;
          uint64_t v101 = _os_log_send_and_compose_impl( v100,  v111,  0LL,  0LL,  &_mh_execute_header,  v99,  0LL,  "Failed to set 0700 on mounted path:%s",  v110);
          goto LABEL_225;
        }

        goto LABEL_227;
      }
    }

    else
    {
      if (qword_1000DBBD8 != -1) {
        dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
      }
      id v97 = (id)qword_1000DBBD0;
      if (os_log_type_enabled((os_log_t)v97, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)uint64_t v110 = 0LL;
        unsigned int v102 = sub_100053B4C(1);
        unsigned int v99 = (os_log_s *)v97;
        if (os_log_type_enabled(v99, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v103 = v102;
        }
        else {
          uint64_t v103 = v102 & 0xFFFFFFFE;
        }
        if ((_DWORD)v103)
        {
          LOWORD(v111[0]) = 0;
          uint64_t v101 = _os_log_send_and_compose_impl( v103,  v110,  0LL,  0LL,  &_mh_execute_header,  v99,  0LL,  "Set approp permission on mounted path");
LABEL_225:
          unsigned int v104 = (char *)v101;

          if (v104) {
            sub_100053B7C(v104);
          }
          goto LABEL_228;
        }

uint64_t sub_10007B2C4(const __CFDictionary *a1, void *a2)
{
  uint64_t v16 = 0LL;
  uint64_t result = CFDictionaryContainsKey(a1, kUMUserSessionVolumeDeviceNodeKey);
  if ((_DWORD)result)
  {
    __int128 v35 = 0u;
    __int128 v36 = 0u;
    __int128 v33 = 0u;
    __int128 v34 = 0u;
    __int128 v31 = 0u;
    __int128 v32 = 0u;
    __int128 v29 = 0u;
    __int128 v30 = 0u;
    __int128 v27 = 0u;
    __int128 v28 = 0u;
    __int128 v25 = 0u;
    __int128 v26 = 0u;
    __int128 v23 = 0u;
    __int128 v24 = 0u;
    *(_OWORD *)__little = 0u;
    __int128 v22 = 0u;
    sub_100083E34(a1, kUMUserSessionVolumeDeviceNodeKey, __little, 256);
    if (sub_100079BDC(a1, __little))
    {
      if (qword_1000DBBD8 != -1) {
        dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
      }
      uint64_t v5 = (os_log_s *)(id)qword_1000DBBD0;
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v15 = 0LL;
        unsigned int v6 = sub_100053B4C(1);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v7 = v6;
        }
        else {
          uint64_t v7 = v6 & 0xFFFFFFFE;
        }
        if ((_DWORD)v7)
        {
          int v17 = 136315394;
          unsigned int v18 = "checkAPFSVolumeMounted";
          __int16 v19 = 2080;
          unsigned int v20 = __little;
          CFTypeID v8 = (const char *)_os_log_send_and_compose_impl( v7,  &v15,  0LL,  0LL,  &_mh_execute_header,  v5,  0LL,  "%s: Failed to update userdata volume device path (%s)",  (const char *)&v17,  22);
          int v9 = (char *)v8;
          if (v8) {
            sub_100053B7C(v8);
          }
        }

        else
        {
          int v9 = 0LL;
        }

        free(v9);
      }
    }

    else
    {
      unsigned int v10 = getmntinfo(&v16, 2);
      if (!v10) {
        return 255LL;
      }
      unsigned int v11 = v10 + 1;
      f_mntfromname = v16[v10 - 1].f_mntfromname;
      while ((int)--v11 >= 1)
      {
        id v13 = f_mntfromname - 2168;
        gid_t v14 = strstr(f_mntfromname, __little);
        f_mntfromname = v13;
        if (v14)
        {
          if (a2) {
            *a2 = *((void *)v13 + 138);
          }
          return 1LL;
        }
      }
    }

    return 0LL;
  }

  return result;
}

uint64_t sub_10007B4DC(const __CFString *a1, uid_t a2, gid_t a3)
{
  if (qword_1000DBBD8 != -1) {
    dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
  }
  unsigned int v6 = (os_log_s *)(id)qword_1000DBBD0;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)buffer = 0LL;
    unsigned int v7 = sub_100053B4C(1);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = v7 & 0xFFFFFFFE;
    }
    if ((_DWORD)v8)
    {
      __int16 v12 = 0;
      int v9 = (const char *)_os_log_send_and_compose_impl( v8,  buffer,  0LL,  0LL,  &_mh_execute_header,  v6,  0LL,  "Ensuring tmp path set and cleared",  &v12,  2);
      unsigned int v10 = (char *)v9;
      if (v9) {
        sub_100053B7C(v9);
      }
    }

    else
    {
      unsigned int v10 = 0LL;
    }

    free(v10);
  }

  bzero(buffer, 0x400uLL);
  uint64_t result = CFStringGetCString(a1, buffer, 1024LL, 0x8000100u);
  if ((_DWORD)result)
  {
    sub_10007B658((uint64_t)buffer);
    sub_10001C6DC((uint64_t)buffer, a2, a3);
    return 1LL;
  }

  return result;
}

uint64_t sub_10007B658(uint64_t a1)
{
  if (sub_10002D61C(v12) == 1)
  {
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    uint64_t v2 = (os_log_s *)(id)qword_1000DBBD0;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = 0LL;
      unsigned int v3 = sub_100053B4C(1);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v4 = v3;
      }
      else {
        uint64_t v4 = v3 & 0xFFFFFFFE;
      }
      if ((_DWORD)v4)
      {
        LOWORD(v10[0]) = 0;
        uint64_t v5 = (const char *)_os_log_send_and_compose_impl( v4,  &v11,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "CLEARED TMP path for the Users",  v10,  2,  v10[0]);
        goto LABEL_18;
      }

      goto LABEL_20;
    }
  }

  else
  {
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    uint64_t v2 = (os_log_s *)(id)qword_1000DBBD0;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = 0LL;
      unsigned int v6 = sub_100053B4C(1);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v7 = v6;
      }
      else {
        uint64_t v7 = v6 & 0xFFFFFFFE;
      }
      if ((_DWORD)v7)
      {
        LOWORD(v10[0]) = 0;
        uint64_t v5 = (const char *)_os_log_send_and_compose_impl( v7,  &v11,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "FAILED to CLEAR TMP path for the Users",  v10,  2,  v10[0]);
LABEL_18:
        uint64_t v8 = (char *)v5;
        if (v5) {
          sub_100053B7C(v5);
        }
        goto LABEL_21;
      }

uint64_t sub_10007B85C(const __CFDictionary *a1, const __CFString *a2, _DWORD *a3, int a4)
{
  int v8 = sub_100083C6C(a1, kUMUserSessionIDKey);
  bzero(buffer, 0x400uLL);
  if (a2 && (CFTypeID v9 = CFGetTypeID(a2), v9 == CFStringGetTypeID())) {
    CFStringGetCString(a2, buffer, 1024LL, 0x8000100u);
  }
  else {
    sub_100083E34(a1, kUMUserSessionHomeDirKey, buffer, 1024);
  }
  if (qword_1000DBBD8 != -1) {
    dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
  }
  unsigned int v10 = (os_log_s *)(id)qword_1000DBBD0;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v30 = 0LL;
    unsigned int v11 = sub_100053B4C(1);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v12 = v11;
    }
    else {
      uint64_t v12 = v11 & 0xFFFFFFFE;
    }
    if ((_DWORD)v12)
    {
      *(_DWORD *)__int128 v29 = 67109378;
      *(_DWORD *)&v29[4] = v8;
      *(_WORD *)&_WORD v29[8] = 2080;
      *(void *)&v29[10] = buffer;
      LODWORD(v2_Block_object_dispose(va, 8) = 18;
      id v13 = (const char *)_os_log_send_and_compose_impl( v12,  &v30,  0LL,  0LL,  &_mh_execute_header,  v10,  0LL,  "Unmounting APFS volume with user %d: path %s",  v29,  v28);
      gid_t v14 = (char *)v13;
      if (v13) {
        sub_100053B7C(v13);
      }
    }

    else
    {
      gid_t v14 = 0LL;
    }

    free(v14);
  }

  int v15 = sub_100019FD4(buffer, a4);
  if (v15)
  {
    int v16 = v15;
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    int v17 = (os_log_s *)(id)qword_1000DBBD0;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)__int128 v29 = 0LL;
      unsigned int v18 = sub_100053B4C(1);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v19 = v18;
      }
      else {
        uint64_t v19 = v18 & 0xFFFFFFFE;
      }
      if ((_DWORD)v19)
      {
        LODWORD(v30) = 67109120;
        HIDWORD(v30) = v16;
        unsigned int v20 = (const char *)_os_log_send_and_compose_impl( v19,  v29,  0LL,  0LL,  &_mh_execute_header,  v17,  0LL,  "unMountAPFSUserVolume failed with %d",  &v30);
        int v21 = (char *)v20;
        if (v20) {
          sub_100053B7C(v20);
        }
      }

      else
      {
        int v21 = 0LL;
      }

      free(v21);
    }

    uint64_t result = 0LL;
    if (a3) {
      *a3 = v16;
    }
  }

  else
  {
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    __int128 v22 = (os_log_s *)(id)qword_1000DBBD0;
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v30 = 0LL;
      unsigned int v23 = sub_100053B4C(1);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v24 = v23;
      }
      else {
        uint64_t v24 = v23 & 0xFFFFFFFE;
      }
      if ((_DWORD)v24)
      {
        *(_DWORD *)__int128 v29 = 136315138;
        *(void *)&v29[4] = buffer;
        __int128 v25 = (const char *)_os_log_send_and_compose_impl( v24,  &v30,  0LL,  0LL,  &_mh_execute_header,  v22,  0LL,  "unMountAPFSUserVolume success: user volume %s unmounted",  v29);
        __int128 v26 = (char *)v25;
        if (v25) {
          sub_100053B7C(v25);
        }
      }

      else
      {
        __int128 v26 = 0LL;
      }

      free(v26);
    }

    if (CFDictionaryContainsKey(a1, kUMUserSessionVolumeMountedKey)) {
      CFDictionaryReplaceValue(a1, kUMUserSessionVolumeMountedKey, kCFBooleanFalse);
    }
    else {
      CFDictionarySetValue(a1, kUMUserSessionVolumeMountedKey, kCFBooleanFalse);
    }
    return 1LL;
  }

  return result;
}

uint64_t sub_10007BC44()
{
  if (sub_10007BFB4(v20))
  {
    __int16 v18 = 0;
    int VEKState = APFSVolumeGetVEKState(v20, (char *)&v18 + 1, &v18);
    if (VEKState == 22)
    {
      if (qword_1000DBBD8 != -1) {
        dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
      }
      uint64_t v2 = (os_log_s *)(id)qword_1000DBBD0;
      if (!os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_44;
      }
      uint64_t v17 = 0LL;
      unsigned int v7 = sub_100053B4C(1);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v8 = v7;
      }
      else {
        uint64_t v8 = v7 & 0xFFFFFFFE;
      }
      if ((_DWORD)v8)
      {
        LOWORD(v19[0]) = 0;
        uint64_t v5 = (const char *)_os_log_send_and_compose_impl( v8,  &v17,  0LL,  0LL,  &_mh_execute_header,  v2,  0LL,  "Unencrypted volume per APFSVolumeGetVEKState, no user binding needed",  v19,  2);
LABEL_22:
        CFTypeID v9 = (char *)v5;
        if (v5) {
          sub_100053B7C(v5);
        }
        goto LABEL_43;
      }

BOOL sub_10007BFB4(char *a1)
{
  char v13 = 1;
  BOOL v2 = sub_100077E68("Data", a1, 256LL, 64, &v13);
  if (v2)
  {
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    unsigned int v3 = (os_log_s *)(id)qword_1000DBBD0;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = 0LL;
      unsigned int v4 = sub_100053B4C(1);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v5 = v4;
      }
      else {
        uint64_t v5 = v4 & 0xFFFFFFFE;
      }
      if ((_DWORD)v5)
      {
        uint64_t v6 = "TRUE";
        if (!v13) {
          uint64_t v6 = "FALSE";
        }
        *(_DWORD *)uint64_t v14 = 136315394;
        *(void *)&v14[4] = a1;
        __int16 v15 = 2080;
        int v16 = v6;
        unsigned int v7 = (const char *)_os_log_send_and_compose_impl( v5,  &v12,  0LL,  0LL,  &_mh_execute_header,  v3,  0LL,  "Found SystemData Volume:%s isEncrypted:%s",  v14,  22);
        goto LABEL_20;
      }

      goto LABEL_22;
    }
  }

  else
  {
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    unsigned int v3 = (os_log_s *)(id)qword_1000DBBD0;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)uint64_t v14 = 0LL;
      unsigned int v8 = sub_100053B4C(1);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v9 = v8;
      }
      else {
        uint64_t v9 = v8 & 0xFFFFFFFE;
      }
      if ((_DWORD)v9)
      {
        unsigned int v7 = (const char *)_os_log_send_and_compose_impl( v9,  v14,  0LL,  0LL,  &_mh_execute_header,  v3,  0LL,  "Failed to find SDV");
LABEL_20:
        unsigned int v10 = (char *)v7;
        if (v7) {
          sub_100053B7C(v7);
        }
        goto LABEL_23;
      }

uint64_t sub_10007C1D0(const __CFString *a1, uint64_t a2, int a3, int *a4)
{
  if (qword_1000DBBD8 != -1) {
    dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
  }
  unsigned int v8 = (os_log_s *)(id)qword_1000DBBD0;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)buffer = 0LL;
    unsigned int v9 = sub_100053B4C(1);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = v9 & 0xFFFFFFFE;
    }
    if ((_DWORD)v10)
    {
      LOWORD(v59[0]) = 0;
      uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v10,  buffer,  0LL,  0LL,  &_mh_execute_header,  v8,  0LL,  "binding System Data Volume to PrimaryIdentity",  v59,  2);
      uint64_t v12 = (char *)v11;
      if (v11) {
        sub_100053B7C(v11);
      }
    }

    else
    {
      uint64_t v12 = 0LL;
    }

    free(v12);
  }

  __int128 v75 = 0u;
  __int128 v76 = 0u;
  __int128 v73 = 0u;
  __int128 v74 = 0u;
  __int128 v71 = 0u;
  __int128 v72 = 0u;
  __int128 v69 = 0u;
  __int128 v70 = 0u;
  __int128 v67 = 0u;
  __int128 v68 = 0u;
  __int128 v65 = 0u;
  __int128 v66 = 0u;
  __int128 v63 = 0u;
  __int128 v64 = 0u;
  *(_OWORD *)buffer = 0u;
  __int128 v62 = 0u;
  if (!CFStringGetCString(a1, buffer, 256LL, 0x8000100u))
  {
    if (a4) {
      *a4 = 22;
    }
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    __int16 v18 = (os_log_s *)(id)qword_1000DBBD0;
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_111;
    }
    *(void *)&v59[0] = 0LL;
    unsigned int v19 = sub_100053B4C(1);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v20 = v19;
    }
    else {
      uint64_t v20 = v19 & 0xFFFFFFFE;
    }
    if (!(_DWORD)v20) {
      goto LABEL_109;
    }
    *(_WORD *)uuid_t uu = 0;
    LODWORD(v56) = 2;
    uint64_t v21 = _os_log_send_and_compose_impl( v20,  v59,  0LL,  0LL,  &_mh_execute_header,  v18,  0LL,  "Failed to retrieve Cstring from user uuidstring",  uu,  v56,  v57[0]);
LABEL_80:
    int v40 = (void *)v21;
    if (!v21)
    {
LABEL_110:
      free(v40);
LABEL_111:

      return 0LL;
    }

LABEL_81:
    sub_100053B7C((const char *)v40);
    goto LABEL_110;
  }

  if (qword_1000DBBD8 != -1) {
    dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
  }
  char v13 = (os_log_s *)(id)qword_1000DBBD0;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uuid_t uu = 0LL;
    unsigned int v14 = sub_100053B4C(1);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v15 = v14;
    }
    else {
      uint64_t v15 = v14 & 0xFFFFFFFE;
    }
    if ((_DWORD)v15)
    {
      LODWORD(v59[0]) = 136315138;
      *(void *)((char *)v59 + 4) = buffer;
      int v16 = (const char *)_os_log_send_and_compose_impl( v15,  uu,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "primaryUUIDString is %s",  (const char *)v59);
      uint64_t v17 = (char *)v16;
      if (v16) {
        sub_100053B7C(v16);
      }
    }

    else
    {
      uint64_t v17 = 0LL;
    }

    free(v17);
  }

  if (uuid_parse(buffer, uu))
  {
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    __int128 v22 = (os_log_s *)(id)qword_1000DBBD0;
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)&v59[0] = 0LL;
      unsigned int v23 = sub_100053B4C(1);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v24 = v23;
      }
      else {
        uint64_t v24 = v23 & 0xFFFFFFFE;
      }
      if ((_DWORD)v24)
      {
        *(_WORD *)gid_t v58 = 0;
        LODWORD(v56) = 2;
        __int128 v25 = (const char *)_os_log_send_and_compose_impl( v24,  v59,  0LL,  0LL,  &_mh_execute_header,  v22,  0LL,  "failed to parse unique string to uuid_t",  v58,  v56);
        __int128 v26 = (char *)v25;
        if (v25) {
          sub_100053B7C(v25);
        }
      }

      else
      {
        __int128 v26 = 0LL;
      }

      free(v26);
    }

    if (a4)
    {
      uint64_t result = 0LL;
      *a4 = 22;
      return result;
    }

    return 0LL;
  }

  if (qword_1000DBBD8 != -1) {
    dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
  }
  __int128 v27 = (os_log_s *)(id)qword_1000DBBD0;
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)&v59[0] = 0LL;
    unsigned int v28 = sub_100053B4C(1);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v29 = v28;
    }
    else {
      uint64_t v29 = v28 & 0xFFFFFFFE;
    }
    if ((_DWORD)v29)
    {
      *(_WORD *)gid_t v58 = 0;
      LODWORD(v56) = 2;
      uint64_t v30 = (const char *)_os_log_send_and_compose_impl( v29,  v59,  0LL,  0LL,  &_mh_execute_header,  v27,  0LL,  "uuid parse successful, discovering disknode",  v58,  v56);
      __int128 v31 = (char *)v30;
      if (v30) {
        sub_100053B7C(v30);
      }
    }

    else
    {
      __int128 v31 = 0LL;
    }

    free(v31);
  }

  memset(v59, 0, sizeof(v59));
  if (!sub_10007BFB4((char *)v59))
  {
    if (a4) {
      *a4 = 2;
    }
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    __int16 v18 = (os_log_s *)(id)qword_1000DBBD0;
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_111;
    }
    *(void *)gid_t v58 = 0LL;
    unsigned int v38 = sub_100053B4C(1);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v39 = v38;
    }
    else {
      uint64_t v39 = v38 & 0xFFFFFFFE;
    }
    if (!(_DWORD)v39) {
      goto LABEL_109;
    }
    LOWORD(v57[0]) = 0;
    LODWORD(v56) = 2;
    uint64_t v21 = _os_log_send_and_compose_impl( v39,  v58,  0LL,  0LL,  &_mh_execute_header,  v18,  0LL,  "FAILED TO FIND DISKNODE",  v57,  v56,  v57[0]);
    goto LABEL_80;
  }

  if (a3)
  {
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    __int128 v33 = (os_log_s *)(id)qword_1000DBBD0;
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      v57[0] = 0LL;
      unsigned int v34 = sub_100053B4C(1);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v35 = v34;
      }
      else {
        uint64_t v35 = v34 & 0xFFFFFFFE;
      }
      if ((_DWORD)v35)
      {
        *(_DWORD *)gid_t v58 = 136315138;
        *(void *)&v58[4] = v59;
        __int128 v36 = (const char *)_os_log_send_and_compose_impl( v35,  v57,  0LL,  0LL,  &_mh_execute_header,  v33,  0LL,  "SDV disknode:%s, setting APFS UserProtections, passing cached_kek option",  v58);
        __int16 v37 = (char *)v36;
        if (v36) {
          sub_100053B7C(v36);
        }
      }

      else
      {
        __int16 v37 = 0LL;
      }

      free(v37);
    }

    uint64_t v45 = 24LL;
  }

  else
  {
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    __int128 v33 = (os_log_s *)(id)qword_1000DBBD0;
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      v57[0] = 0LL;
      unsigned int v41 = sub_100053B4C(1);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v42 = v41;
      }
      else {
        uint64_t v42 = v41 & 0xFFFFFFFE;
      }
      if ((_DWORD)v42)
      {
        *(_DWORD *)gid_t v58 = 136315138;
        *(void *)&v58[4] = v59;
        unsigned int v43 = (const char *)_os_log_send_and_compose_impl( v42,  v57,  0LL,  0LL,  &_mh_execute_header,  v33,  0LL,  "SDV disknode:%s, setting APFS UserProtections",  v58);
        id v44 = (char *)v43;
        if (v43) {
          sub_100053B7C(v43);
        }
      }

      else
      {
        id v44 = 0LL;
      }

      free(v44);
    }

    uint64_t v45 = 8LL;
  }

  int v46 = APFSVolumeEnableUserProtectionWithOptions(v59, uu, a2, v45);
  if (v46)
  {
    int v47 = v46;
    if (a4) {
      *a4 = v46;
    }
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    __int16 v18 = (os_log_s *)(id)qword_1000DBBD0;
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_111;
    }
    v57[0] = 0LL;
    LODWORD(v4_Block_object_dispose(va, 8) = sub_100053B4C(1);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v48 = v48;
    }
    else {
      uint64_t v48 = v48 & 0xFFFFFFFE;
    }
    if ((_DWORD)v48)
    {
      id v49 = v18;
      uint64_t v50 = strerror(v47);
      *(_DWORD *)gid_t v58 = 136315138;
      *(void *)&v58[4] = v50;
      int v40 = (void *)_os_log_send_and_compose_impl( v48,  v57,  0LL,  0LL,  &_mh_execute_header,  v49,  0LL,  "APFSVolumeEnableUserProtectionWithOptions failed with error:%s",  v58);

      if (!v40) {
        goto LABEL_110;
      }
      goto LABEL_81;
    }

uint64_t sub_10007CB04(const char *a1, int a2, _BYTE *a3, int *a4)
{
  char v46 = 0;
  char v45 = 1;
  if (sub_100077E68(a1, v50, 256LL, a2, &v45))
  {
    if (v45 == 1)
    {
      if (qword_1000DBBD8 != -1) {
        dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
      }
      unsigned int v8 = (os_log_s *)(id)qword_1000DBBD0;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v44 = 0LL;
        unsigned int v9 = sub_100053B4C(1);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v10 = v9;
        }
        else {
          uint64_t v10 = v9 & 0xFFFFFFFE;
        }
        if ((_DWORD)v10)
        {
          *(_DWORD *)int v47 = 136315394;
          *(void *)&v47[4] = a1;
          __int16 v48 = 2080;
          id v49 = v50;
          uint64_t v11 = (const char *)_os_log_send_and_compose_impl( v10,  &v44,  0LL,  0LL,  &_mh_execute_header,  v8,  0LL,  "checking Volume %s with disknode:%s Needs Migration..",  v47,  22);
          uint64_t v12 = (char *)v11;
          if (v11) {
            sub_100053B7C(v11);
          }
        }

        else
        {
          uint64_t v12 = 0LL;
        }

        free(v12);
      }

      int v24 = APFSVolumeNeedsCryptoMigration(v50, &v46);
      if (v24)
      {
        int v25 = v24;
        if (a4) {
          *a4 = v24;
        }
        if (qword_1000DBBD8 != -1) {
          dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
        }
        __int16 v18 = (os_log_s *)(id)qword_1000DBBD0;
        if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_73;
        }
        uint64_t v44 = 0LL;
        LODWORD(v26) = sub_100053B4C(1);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v26 = v26;
        }
        else {
          uint64_t v26 = v26 & 0xFFFFFFFE;
        }
        if ((_DWORD)v26)
        {
          __int128 v27 = v18;
          unsigned int v28 = strerror(v25);
          *(_DWORD *)int v47 = 136315138;
          *(void *)&v47[4] = v28;
          __int128 v22 = (void *)_os_log_send_and_compose_impl( v26,  &v44,  0LL,  0LL,  &_mh_execute_header,  v27,  0LL,  "APFSVolumeNeedsCryptoMigration failed with error:%s",  v47);

          if (!v22)
          {
LABEL_72:
            free(v22);
            goto LABEL_73;
          }

LABEL_50:
          sub_100053B7C((const char *)v22);
          goto LABEL_72;
        }

uint64_t sub_10007D19C(uint64_t a1, _DWORD *a2)
{
  int v4 = APFSVolumeConvertToUserCrypto(a1, 0LL);
  if (v4)
  {
    int v5 = v4;
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    uint64_t v6 = (os_log_s *)(id)qword_1000DBBD0;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = 0LL;
      unsigned int v7 = sub_100053B4C(1);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v8 = v7;
      }
      else {
        uint64_t v8 = v7 & 0xFFFFFFFE;
      }
      if ((_DWORD)v8)
      {
        int v18 = 136315394;
        uint64_t v19 = a1;
        __int16 v20 = 1024;
        int v21 = v5;
        unsigned int v9 = (const char *)_os_log_send_and_compose_impl( v8,  &v17,  0LL,  0LL,  &_mh_execute_header,  v6,  0LL,  "APFS Guest volume migration for disk:%s FAILED with error  %d",  (const char *)&v18,  18);
        uint64_t v10 = (char *)v9;
        if (v9) {
          sub_100053B7C(v9);
        }
      }

      else
      {
        uint64_t v10 = 0LL;
      }

      free(v10);
    }

    uint64_t result = 0LL;
    if (a2) {
      *a2 = v5;
    }
  }

  else
  {
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    uint64_t v11 = (os_log_s *)(id)qword_1000DBBD0;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = 0LL;
      unsigned int v12 = sub_100053B4C(1);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v13 = v12;
      }
      else {
        uint64_t v13 = v12 & 0xFFFFFFFE;
      }
      if ((_DWORD)v13)
      {
        int v18 = 136315138;
        uint64_t v19 = a1;
        unsigned int v14 = (const char *)_os_log_send_and_compose_impl( v13,  &v17,  0LL,  0LL,  &_mh_execute_header,  v11,  0LL,  "APFS Guest volume migration for disk:%s Succeeded",  (const char *)&v18);
        uint64_t v15 = (char *)v14;
        if (v14) {
          sub_100053B7C(v14);
        }
      }

      else
      {
        uint64_t v15 = 0LL;
      }

      free(v15);
    }

    return 1LL;
  }

  return result;
}

uint64_t sub_10007D3E0(int *a1, _BYTE *a2)
{
  return sub_10007CB04(v3, 64, a2, a1);
}

uint64_t sub_10007D41C(int *a1, _BYTE *a2)
{
  return sub_10007CB04(v3, 2, a2, a1);
}

uint64_t sub_10007D458(int *a1)
{
  if (!sub_10007BFB4(v24))
  {
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    unsigned int v7 = (os_log_s *)(id)qword_1000DBBD0;
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_45;
    }
    *(void *)uint64_t v23 = 0LL;
    unsigned int v8 = sub_100053B4C(1);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v9 = v8;
    }
    else {
      uint64_t v9 = v8 & 0xFFFFFFFE;
    }
    if ((_DWORD)v9)
    {
      LOWORD(v22[0]) = 0;
      uint64_t v10 = (void *)_os_log_send_and_compose_impl( v9,  v23,  0LL,  0LL,  &_mh_execute_header,  v7,  0LL,  "FAILED TO FIND DISKNODE",  v22,  2);
      if (!v10) {
        goto LABEL_44;
      }
      goto LABEL_33;
    }

uint64_t sub_10007D838(int a1, _DWORD *a2)
{
  if (!sub_100077C4C(v65, 256LL))
  {
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    int v11 = (os_log_s *)(id)qword_1000DBBD0;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)uint64_t v61 = 0LL;
      unsigned int v12 = sub_100053B4C(1);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v13 = v12;
      }
      else {
        uint64_t v13 = v12 & 0xFFFFFFFE;
      }
      if ((_DWORD)v13)
      {
        uint64_t v64 = 0x204000100LL;
        unsigned int v14 = (const char *)_os_log_send_and_compose_impl( v13,  v61,  0LL,  0LL,  &_mh_execute_header,  v11,  0LL,  "Failed to find primary User Volume Disk Node returning error:%d",  &v64);
        uint64_t v15 = (char *)v14;
        if (v14) {
          sub_100053B7C(v14);
        }
      }

      else
      {
        uint64_t v15 = 0LL;
      }

      free(v15);
    }

    if (!a2) {
      return 0LL;
    }
    uint64_t result = 0LL;
    int v26 = 2;
    goto LABEL_44;
  }

  if (!a1)
  {
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    int v5 = (os_log_s *)(id)qword_1000DBBD0;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)uint64_t v61 = 0LL;
      unsigned int v16 = sub_100053B4C(1);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v17 = v16;
      }
      else {
        uint64_t v17 = v16 & 0xFFFFFFFE;
      }
      if ((_DWORD)v17)
      {
        LOWORD(v64) = 0;
        int v18 = (const char *)_os_log_send_and_compose_impl( v17,  v61,  0LL,  0LL,  &_mh_execute_header,  v5,  0LL,  "Skipping VolumeMap",  &v64,  2);
        uint64_t v19 = (char *)v18;
        if (v18) {
          sub_100053B7C(v18);
        }
      }

      else
      {
        uint64_t v19 = 0LL;
      }

      free(v19);
    }

    goto LABEL_75;
  }

  uint64_t v4 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v65));
  if (!v4)
  {
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    uint64_t v20 = (os_log_s *)(id)qword_1000DBBD0;
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)uint64_t v61 = 0LL;
      unsigned int v21 = sub_100053B4C(1);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v22 = v21;
      }
      else {
        uint64_t v22 = v21 & 0xFFFFFFFE;
      }
      if ((_DWORD)v22)
      {
        LOWORD(v64) = 0;
        uint64_t v23 = (const char *)_os_log_send_and_compose_impl( v22,  v61,  0LL,  0LL,  &_mh_execute_header,  v20,  0LL,  "FAILED TO allocate CFRef for disk node of the Primary, bailing with ENOMEM",  &v64,  2);
        int v24 = (char *)v23;
        if (v23) {
          sub_100053B7C(v23);
        }
      }

      else
      {
        int v24 = 0LL;
      }

      free(v24);
    }

    if (!a2) {
      return 0LL;
    }
    uint64_t result = 0LL;
    int v26 = 12;
LABEL_44:
    *a2 = v26;
    return result;
  }

  int v5 = (os_log_s *)v4;
  if (qword_1000DBBD8 != -1) {
    dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
  }
  uint64_t v6 = (os_log_s *)(id)qword_1000DBBD0;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v64 = 0LL;
    unsigned int v7 = sub_100053B4C(1);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = v7 & 0xFFFFFFFE;
    }
    if ((_DWORD)v8)
    {
      *(_DWORD *)uint64_t v61 = 138412546;
      *(void *)&v61[4] = v5;
      __int16 v62 = 1024;
      int v63 = 501;
      uint64_t v9 = (const char *)_os_log_send_and_compose_impl( v8,  &v64,  0LL,  0LL,  &_mh_execute_header,  v6,  0LL,  "Calling AKSVolumeMap with disk:%@, uid:%d",  v61,  18);
      uint64_t v10 = (char *)v9;
      if (v9) {
        sub_100053B7C(v9);
      }
    }

    else
    {
      uint64_t v10 = 0LL;
    }

    free(v10);
  }

  uint64_t v27 = sub_100019B18(qword_1000DBD40);
  unsigned int v28 = (void *)objc_claimAutoreleasedReturnValue(v27);
  id v60 = 0LL;
  unsigned int v29 = [v28 mapVolume:v5 toSession:501 withPersona:0 error:&v60];
  id v30 = v60;

  if (!v29)
  {
    unsigned int v36 = [v30 code];
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    unsigned int v37 = (os_log_s *)(id)qword_1000DBBD0;
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v64 = 0LL;
      LODWORD(v3_Block_object_dispose(va, 8) = sub_100053B4C(1);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v38 = v38;
      }
      else {
        uint64_t v38 = v38 & 0xFFFFFFFE;
      }
      if ((_DWORD)v38)
      {
        uint64_t v39 = v37;
        id v40 = [v30 code];
        *(_DWORD *)uint64_t v61 = 134217984;
        *(void *)&v61[4] = v40;
        unsigned int v41 = (char *)_os_log_send_and_compose_impl( v38,  &v64,  0LL,  0LL,  &_mh_execute_header,  v39,  0LL,  "AKS VolumeMap failed with %ld, returning..",  v61);

        if (v41) {
          sub_100053B7C(v41);
        }
      }

      else
      {
        unsigned int v41 = 0LL;
      }

      free(v41);
    }

    if (a2) {
      *a2 = v36;
    }

    return 0LL;
  }

  if (qword_1000DBBD8 != -1) {
    dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
  }
  __int128 v31 = (os_log_s *)(id)qword_1000DBBD0;
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v64 = 0LL;
    unsigned int v32 = sub_100053B4C(1);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v33 = v32;
    }
    else {
      uint64_t v33 = v32 & 0xFFFFFFFE;
    }
    if ((_DWORD)v33)
    {
      *(_DWORD *)uint64_t v61 = 138412546;
      *(void *)&v61[4] = v5;
      __int16 v62 = 1024;
      int v63 = 501;
      LODWORD(v59) = 18;
      uint64_t v34 = (const char *)_os_log_send_and_compose_impl( v33,  &v64,  0LL,  0LL,  &_mh_execute_header,  v31,  0LL,  "AKS VolumeMapPath Success for disk:%@, uid:%d",  v61,  v59);
      uint64_t v35 = (char *)v34;
      if (v34) {
        sub_100053B7C(v34);
      }
    }

    else
    {
      uint64_t v35 = 0LL;
    }

    free(v35);
  }

LABEL_75:
  if (qword_1000DBBD8 != -1) {
    dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
  }
  uint64_t v42 = (os_log_s *)(id)qword_1000DBBD0;
  if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v64 = 0LL;
    unsigned int v43 = sub_100053B4C(1);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v44 = v43;
    }
    else {
      uint64_t v44 = v43 & 0xFFFFFFFE;
    }
    if ((_DWORD)v44)
    {
      *(_DWORD *)uint64_t v61 = 136315138;
      *(void *)&v61[4] = v65;
      char v45 = (const char *)_os_log_send_and_compose_impl( v44,  &v64,  0LL,  0LL,  &_mh_execute_header,  v42,  0LL,  "Calling APFSVolumeMigrateMediaKey for diskNode:%s",  v61);
      char v46 = (char *)v45;
      if (v45) {
        sub_100053B7C(v45);
      }
    }

    else
    {
      char v46 = 0LL;
    }

    free(v46);
  }

  int v47 = APFSVolumeMigrateMediaKey(v65);
  if (v47)
  {
    int v48 = v47;
    if (a2) {
      *a2 = v47;
    }
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    id v49 = (os_log_s *)(id)qword_1000DBBD0;
    if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)uint64_t v61 = 0LL;
      unsigned int v50 = sub_100053B4C(1);
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v51 = v50;
      }
      else {
        uint64_t v51 = v50 & 0xFFFFFFFE;
      }
      if ((_DWORD)v51)
      {
        LODWORD(v64) = 67109120;
        HIDWORD(v64) = v48;
        unsigned int v52 = (const char *)_os_log_send_and_compose_impl( v51,  v61,  0LL,  0LL,  &_mh_execute_header,  v49,  0LL,  "Failed to migrate Media Key with error:%d",  &v64);
        uint64_t v53 = (char *)v52;
        if (v52) {
          sub_100053B7C(v52);
        }
      }

      else
      {
        uint64_t v53 = 0LL;
      }

      free(v53);
    }

    return 0LL;
  }

  if (qword_1000DBBD8 != -1) {
    dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
  }
  uint64_t v54 = (os_log_s *)(id)qword_1000DBBD0;
  if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t v61 = 0LL;
    unsigned int v55 = sub_100053B4C(1);
    if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v56 = v55;
    }
    else {
      uint64_t v56 = v55 & 0xFFFFFFFE;
    }
    if ((_DWORD)v56)
    {
      LOWORD(v64) = 0;
      LODWORD(v59) = 2;
      id v57 = (const char *)_os_log_send_and_compose_impl( v56,  v61,  0LL,  0LL,  &_mh_execute_header,  v54,  0LL,  "Migrating Metadata of UserVolume to ClassC is Complete",  &v64,  v59);
      gid_t v58 = (char *)v57;
      if (v57) {
        sub_100053B7C(v57);
      }
    }

    else
    {
      gid_t v58 = 0LL;
    }

    free(v58);
  }

  return 1LL;
}

uint64_t sub_10007E13C(const char *a1, int *a2)
{
  HIDWORD(v22) = 2;
  if (qword_1000DBBD8 != -1) {
    dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
  }
  uint64_t v4 = (os_log_s *)(id)qword_1000DBBD0;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v24 = 0LL;
    unsigned int v5 = sub_100053B4C(1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v6 = v5;
    }
    else {
      uint64_t v6 = v5 & 0xFFFFFFFE;
    }
    if ((_DWORD)v6)
    {
      *(_DWORD *)uint64_t v23 = 136315138;
      *(void *)&v23[4] = a1;
      unsigned int v7 = (const char *)_os_log_send_and_compose_impl( v6,  &v24,  0LL,  0LL,  &_mh_execute_header,  v4,  0LL,  "Setting last booted user  for volume:%s",  v23);
      uint64_t v8 = (char *)v7;
      if (v7) {
        sub_100053B7C(v7);
      }
    }

    else
    {
      uint64_t v8 = 0LL;
    }

    free(v8);
  }

  int v9 = fsctl(a1, 0x80014A22uLL, (char *)&v22 + 4, 0);
  if (v9)
  {
    int v10 = v9;
    if (a2) {
      *a2 = v9;
    }
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    int v11 = (os_log_s *)(id)qword_1000DBBD0;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)uint64_t v23 = 0LL;
      unsigned int v12 = sub_100053B4C(1);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v13 = v12;
      }
      else {
        uint64_t v13 = v12 & 0xFFFFFFFE;
      }
      if ((_DWORD)v13)
      {
        LODWORD(v24) = 67109120;
        HIDWORD(v24) = v10;
        unsigned int v14 = (const char *)_os_log_send_and_compose_impl( v13,  v23,  0LL,  0LL,  &_mh_execute_header,  v11,  0LL,  "Failed to set last user in APFS-AKS with error:%d",  &v24);
        uint64_t v15 = (char *)v14;
        if (v14) {
          sub_100053B7C(v14);
        }
      }

      else
      {
        uint64_t v15 = 0LL;
      }

      free(v15);
    }

    uint64_t v20 = 0LL;
  }

  else
  {
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    int v11 = (os_log_s *)(id)qword_1000DBBD0;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)uint64_t v23 = 0LL;
      unsigned int v16 = sub_100053B4C(1);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v17 = v16;
      }
      else {
        uint64_t v17 = v16 & 0xFFFFFFFE;
      }
      if ((_DWORD)v17)
      {
        LOWORD(v24) = 0;
        LODWORD(v22) = 2;
        int v18 = (const char *)_os_log_send_and_compose_impl( v17,  v23,  0LL,  0LL,  &_mh_execute_header,  v11,  0LL,  "Setting last user in APFS-AKS Complete",  &v24,  v22);
        uint64_t v19 = (char *)v18;
        if (v18) {
          sub_100053B7C(v18);
        }
      }

      else
      {
        uint64_t v19 = 0LL;
      }

      free(v19);
    }

    uint64_t v20 = 1LL;
  }

  return v20;
}

uint64_t sub_10007E454()
{
  if (qword_1000DBCD8) {
    BOOL v0 = 0;
  }
  else {
    BOOL v0 = byte_1000DACB8 == 0;
  }
  if (v0) {
    return 0LL;
  }
  if (qword_1000DBBD8 != -1) {
    dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
  }
  int v1 = (os_log_s *)(id)qword_1000DBBD0;
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v21 = 0LL;
    unsigned int v2 = sub_100053B4C(1);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v3 = v2;
    }
    else {
      uint64_t v3 = v2 & 0xFFFFFFFE;
    }
    if ((_DWORD)v3)
    {
      LOWORD(v22) = 0;
      uint64_t v4 = (const char *)_os_log_send_and_compose_impl( v3,  &v21,  0LL,  0LL,  &_mh_execute_header,  v1,  0LL,  "UNMOUNT BACKGROUND APFS VOLUMES, if mounted",  &v22,  2);
      unsigned int v5 = (char *)v4;
      if (v4) {
        sub_100053B7C(v4);
      }
    }

    else
    {
      unsigned int v5 = 0LL;
    }

    free(v5);
  }

  if (CFArrayGetCount((CFArrayRef)qword_1000DBCD8) >= 1)
  {
    for (CFIndex i = 0LL; CFArrayGetCount((CFArrayRef)qword_1000DBCD8) > i; ++i)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)qword_1000DBCD8, i);
      if (!ValueAtIndex) {
        continue;
      }
      int v9 = ValueAtIndex;
      CFTypeID v10 = CFGetTypeID(ValueAtIndex);
      if (v10 != CFDictionaryGetTypeID() || !CFDictionaryContainsKey(v9, kUMUserSessionVolumeMountedKey)) {
        continue;
      }
      unsigned int v11 = sub_100083DA4(v9, kUMUserSessionVolumeMountedKey);
      int v12 = sub_100083C6C(v9, kUMUserSessionIDKey);
      if (sub_10007B85C(v9, 0LL, 0LL, 0x80000))
      {
        if (qword_1000DBBD8 != -1) {
          dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
        }
        unsigned int v14 = (os_log_s *)(id)qword_1000DBBD0;
        if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_47;
        }
        uint64_t v21 = 0LL;
        unsigned int v15 = sub_100053B4C(1);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v16 = v15;
        }
        else {
          uint64_t v16 = v15 & 0xFFFFFFFE;
        }
        if ((_DWORD)v16)
        {
          int v22 = 67109120;
          int v23 = v12;
          uint64_t v17 = (const char *)_os_log_send_and_compose_impl( v16,  &v21,  0LL,  0LL,  &_mh_execute_header,  v14,  0LL,  "Unmounted the APFS volume for user with uid:%d",  &v22);
          goto LABEL_43;
        }
      }

      else
      {
        if (qword_1000DBBD8 != -1) {
          dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
        }
        unsigned int v14 = (os_log_s *)(id)qword_1000DBBD0;
        if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_47;
        }
        uint64_t v21 = 0LL;
        unsigned int v18 = sub_100053B4C(1);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v19 = v18;
        }
        else {
          uint64_t v19 = v18 & 0xFFFFFFFE;
        }
        if ((_DWORD)v19)
        {
          int v22 = 67109120;
          int v23 = v12;
          uint64_t v17 = (const char *)_os_log_send_and_compose_impl( v19,  &v21,  0LL,  0LL,  &_mh_execute_header,  v14,  0LL,  "Unmount of APFS volume failed for user with uid:%d",  &v22);
LABEL_43:
          uint64_t v20 = (char *)v17;
          if (v17) {
            sub_100053B7C(v17);
          }
          goto LABEL_46;
        }
      }

      uint64_t v20 = 0LL;
LABEL_46:
      free(v20);
LABEL_47:
    }
  }

  return 1LL;
}

uint64_t sub_10007E80C(uint64_t a1, int *a2)
{
  if (qword_1000DBBD8 != -1) {
    dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
  }
  uint64_t v3 = (os_log_s *)(id)qword_1000DBBD0;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)unsigned int v32 = 0LL;
    unsigned int v4 = sub_100053B4C(1);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = v4 & 0xFFFFFFFE;
    }
    if ((_DWORD)v5)
    {
      LOWORD(v31[0]) = 0;
      uint64_t v6 = (const char *)_os_log_send_and_compose_impl( v5,  v32,  0LL,  0LL,  &_mh_execute_header,  v3,  0LL,  "Trying to find User volume on shared iPad",  v31,  2);
      unsigned int v7 = (char *)v6;
      if (v6) {
        sub_100053B7C(v6);
      }
    }

    else
    {
      unsigned int v7 = 0LL;
    }

    free(v7);
  }

  if (!sub_100077C4C((char *)v35, 256LL))
  {
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    uint64_t v13 = (os_log_s *)(id)qword_1000DBBD0;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)unsigned int v32 = 0LL;
      unsigned int v14 = sub_100053B4C(1);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v15 = v14;
      }
      else {
        uint64_t v15 = v14 & 0xFFFFFFFE;
      }
      if ((_DWORD)v15)
      {
        LOWORD(v31[0]) = 0;
        LODWORD(v30) = 2;
        uint64_t v16 = (const char *)_os_log_send_and_compose_impl( v15,  v32,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "could not find Primary UserVolume diskNode",  v31,  v30);
        uint64_t v17 = (char *)v16;
        if (v16) {
          sub_100053B7C(v16);
        }
      }

      else
      {
        uint64_t v17 = 0LL;
      }

      free(v17);
    }

    int v19 = 2;
    goto LABEL_57;
  }

  if (qword_1000DBBD8 != -1) {
    dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
  }
  uint64_t v8 = (os_log_s *)(id)qword_1000DBBD0;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    v31[0] = 0LL;
    unsigned int v9 = sub_100053B4C(1);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = v9 & 0xFFFFFFFE;
    }
    if ((_DWORD)v10)
    {
      *(_DWORD *)unsigned int v32 = 136315138;
      *(void *)&v32[4] = v35;
      unsigned int v11 = (const char *)_os_log_send_and_compose_impl( v10,  v31,  0LL,  0LL,  &_mh_execute_header,  v8,  0LL,  "Found Primary UserVolume disknode:%s",  v32);
      int v12 = (char *)v11;
      if (v11) {
        sub_100053B7C(v11);
      }
    }

    else
    {
      int v12 = 0LL;
    }

    free(v12);
  }

  int v18 = APFSVolumeDelete(v35);
  if (v18)
  {
    int v19 = v18;
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    uint64_t v13 = (os_log_s *)(id)qword_1000DBBD0;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      v31[0] = 0LL;
      unsigned int v20 = sub_100053B4C(1);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v21 = v20;
      }
      else {
        uint64_t v21 = v20 & 0xFFFFFFFE;
      }
      if ((_DWORD)v21)
      {
        *(_DWORD *)unsigned int v32 = 136315394;
        *(void *)&v32[4] = v35;
        __int16 v33 = 1024;
        int v34 = v19;
        int v22 = (const char *)_os_log_send_and_compose_impl( v21,  v31,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "Failed to delete Volume:%s with error:%d",  v32,  18);
        int v23 = (char *)v22;
        if (v22) {
          sub_100053B7C(v22);
        }
      }

      else
      {
        int v23 = 0LL;
      }

      free(v23);
    }

uint64_t sub_10007ECE8(const __CFString *a1, uid_t a2, gid_t a3)
{
  size_t v43 = 4LL;
  int v42 = 0;
  if (sysctlbyname("kern.exclaves_status", &v44, &v43, 0LL, 0LL))
  {
    if (qword_1000DBBD8 != -1) {
      dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
    }
    uint64_t v6 = (os_log_s *)(id)qword_1000DBBD0;
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_88;
    }
    *(void *)buffer = 0LL;
    LODWORD(v7) = sub_100053B4C(1);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v7 = v7;
    }
    else {
      uint64_t v7 = v7 & 0xFFFFFFFE;
    }
    if ((_DWORD)v7)
    {
      uint64_t v8 = v6;
      int v9 = *__error();
      v49.st_dev = 67109120;
      *(_DWORD *)&v49.st_mode = v9;
      int v40 = 8;
      uint64_t v39 = &v49;
      uint64_t v10 = "failed to get exclaves status: %d\n";
      unsigned int v11 = buffer;
      goto LABEL_10;
    }

LABEL_86:
    int v12 = 0LL;
LABEL_87:
    free(v12);
LABEL_88:

    return *__error();
  }

  if (v44 == 1)
  {
    bzero(buffer, 0x400uLL);
    if (a1)
    {
      if (!CFStringGetCString(a1, buffer, 1024LL, 0x8000100u))
      {
        if (qword_1000DBBD8 != -1) {
          dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
        }
        int v18 = (os_log_s *)(id)qword_1000DBBD0;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)&v49.st_dev = 0LL;
          unsigned int v19 = sub_100053B4C(1);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
            uint64_t v20 = v19;
          }
          else {
            uint64_t v20 = v19 & 0xFFFFFFFE;
          }
          if ((_DWORD)v20)
          {
            LOWORD(v45) = 0;
            uint64_t v21 = (const char *)_os_log_send_and_compose_impl( v20,  &v49,  0LL,  0LL,  &_mh_execute_header,  v18,  0LL,  "failed to get the homeDirPath\n",  &v45,  2);
            int v22 = (char *)v21;
            if (v21) {
              sub_100053B7C(v21);
            }
          }

          else
          {
            int v22 = 0LL;
          }

          free(v22);
        }

        return 22LL;
      }
    }

    else
    {
      strcpy(buffer, "/private/var/mobile");
    }

    __strlcat_chk(buffer, "/exclave", 1024LL, 1024LL);
    if (stat(buffer, &v49))
    {
      if (*__error() != 2)
      {
        if (qword_1000DBBD8 != -1) {
          dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
        }
        uint64_t v6 = (os_log_s *)(id)qword_1000DBBD0;
        if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_88;
        }
        uint64_t v41 = 0LL;
        LODWORD(v7) = sub_100053B4C(1);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v7 = v7;
        }
        else {
          uint64_t v7 = v7 & 0xFFFFFFFE;
        }
        if (!(_DWORD)v7) {
          goto LABEL_86;
        }
        uint64_t v8 = v6;
        uint64_t v30 = __error();
        __int128 v31 = strerror(*v30);
        int v45 = 136315394;
        char v46 = buffer;
        __int16 v47 = 2080;
        int v48 = v31;
        int v40 = 22;
        uint64_t v39 = (stat *)&v45;
        uint64_t v10 = "failed to stat path %s (%s)\n";
        goto LABEL_85;
      }

      if (mkdir(buffer, 0x1EDu))
      {
        if (qword_1000DBBD8 != -1) {
          dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
        }
        uint64_t v6 = (os_log_s *)(id)qword_1000DBBD0;
        if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_88;
        }
        uint64_t v41 = 0LL;
        LODWORD(v7) = sub_100053B4C(1);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v7 = v7;
        }
        else {
          uint64_t v7 = v7 & 0xFFFFFFFE;
        }
        if (!(_DWORD)v7) {
          goto LABEL_86;
        }
        uint64_t v8 = v6;
        unsigned int v28 = __error();
        unsigned int v29 = strerror(*v28);
        int v45 = 136315394;
        char v46 = buffer;
        __int16 v47 = 2080;
        int v48 = v29;
        int v40 = 22;
        uint64_t v39 = (stat *)&v45;
        uint64_t v10 = "failed to create path %s (%s)\n";
        goto LABEL_85;
      }

      if (chown(buffer, a2, a3))
      {
        if (qword_1000DBBD8 != -1) {
          dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
        }
        uint64_t v6 = (os_log_s *)(id)qword_1000DBBD0;
        if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_88;
        }
        uint64_t v41 = 0LL;
        LODWORD(v7) = sub_100053B4C(1);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
          uint64_t v7 = v7;
        }
        else {
          uint64_t v7 = v7 & 0xFFFFFFFE;
        }
        if (!(_DWORD)v7) {
          goto LABEL_86;
        }
        uint64_t v8 = v6;
        __int16 v33 = __error();
        int v34 = strerror(*v33);
        int v45 = 136315394;
        char v46 = buffer;
        __int16 v47 = 2080;
        int v48 = v34;
        int v40 = 22;
        uint64_t v39 = (stat *)&v45;
        uint64_t v10 = "failed to change ownership on %s (%s)\n";
        goto LABEL_85;
      }
    }

    if (!fsctl(buffer, 0x80044119uLL, &v42, 0))
    {
      if (qword_1000DBBD8 != -1) {
        dispatch_once(&qword_1000DBBD8, &stru_1000CDB20);
      }
      uint64_t v13 = (os_log_s *)(id)qword_1000DBBD0;
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_99;
      }
      uint64_t v41 = 0LL;
      unsigned int v37 = sub_100053B4C(1);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v38 = v37;
      }
      else {
        uint64_t v38 = v37 & 0xFFFFFFFE;
      }
      if ((_DWORD)v38)
      {
        int v45 = 136315138;
        char v46 = buffer;
        uint64_t v16 = (const char *)_os_log_send_and_compose_impl( v38,  &v41,  0LL,  0LL,  &_mh_execute_header,  v13,  0LL,  "successfully registered the exclaves writable storage at %s\n",  &v45);
LABEL_22:
        uint64_t v17 = (char *)v16;
        if (v16) {
          sub_100053B7C(v16);
        }
        goto LABEL_98;
      }

void sub_10007F5A0(id a1)
{
  os_log_t v1 = os_log_create(off_1000DAE70, "legacy");
  unsigned int v2 = (void *)qword_1000DBBD0;
  qword_1000DBBD0 = (uint64_t)v1;
}

void sub_10007FED8(_Unwind_Exception *a1)
{
}

void sub_100080454( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27)
{
}

uint64_t sub_100080488(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_100080498(uint64_t a1)
{
}

void sub_1000804A0(uint64_t a1, void *a2, int a3)
{
  id v6 = a2;
  *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = a3;
}

void sub_100080744(id a1)
{
  os_log_t v1 = os_log_create(off_1000DAE70, "sideeffect");
  unsigned int v2 = (void *)qword_1000DBBE0;
  qword_1000DBBE0 = (uint64_t)v1;
}

uint64_t sub_100080778(uint64_t a1, unsigned int a2)
{
  if (a2 >= 9) {
    return 0xFFFFFFFFLL;
  }
  else {
    return a2;
  }
}

uint64_t sub_1000807A0(uint64_t a1, unsigned int a2)
{
  if (a2 >= 9) {
    return 0x7FFFFFFFLL;
  }
  else {
    return a2;
  }
}

id sub_1000807CC(uint64_t a1, int *a2)
{
  uint64_t v3 = (objc_class *)objc_opt_self(a1);
  id v4 = objc_alloc_init(v3);
  uint64_t v5 = v4;
  if (*a2 != 2)
  {
    if (qword_1000DBBF8 != -1) {
      dispatch_once(&qword_1000DBBF8, &stru_1000CDB88);
    }
    int v9 = (os_log_s *)(id)qword_1000DBBF0;
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      goto LABEL_24;
    }
    uint64_t v19 = 0LL;
    unsigned int v10 = sub_100053B4C(0);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      uint64_t v11 = v10;
    }
    else {
      uint64_t v11 = v10 & 0xFFFFFFFE;
    }
    if ((_DWORD)v11)
    {
      int v12 = *a2;
      int v20 = 67109120;
      int v21 = v12;
      uint64_t v13 = (const char *)_os_log_send_and_compose_impl( v11,  &v19,  0LL,  0LL,  &_mh_execute_header,  v9,  16LL,  "Failed to parse kpersona_info struct: Unexpected version: %u",  &v20);
      goto LABEL_20;
    }

double sub_100080A48@<D0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  if (a1)
  {
    *(_OWORD *)(a2 + 244) = 0u;
    *(_OWORD *)(a2 + 22_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(a2 + 212) = 0u;
    *(_OWORD *)(a2 + 196) = 0u;
    *(_OWORD *)(a2 + 180) = 0u;
    *(_OWORD *)(a2 + 164) = 0u;
    *(_OWORD *)(a2 + 14_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(a2 + 132) = 0u;
    *(_OWORD *)(a2 + 116) = 0u;
    *(_OWORD *)(a2 + 100) = 0u;
    *(_OWORD *)(a2 + 84) = 0u;
    *(_OWORD *)(a2 + 6_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(a2 + 52) = 0u;
    *(_OWORD *)(a2 + 36) = 0u;
    *(_OWORD *)(a2 + 20) = 0u;
    *(_OWORD *)(a2 + 4) = 0u;
    *(void *)(a2 + 340) = 0LL;
    *(_OWORD *)(a2 + 30_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(a2 + 324) = 0u;
    *(_OWORD *)(a2 + 276) = 0u;
    *(_OWORD *)(a2 + 292) = 0u;
    *(_OWORD *)(a2 + 260) = 0u;
    *(_DWORD *)a2 = 2;
    *(_DWORD *)(a2 + 4) = sub_10005682C((uint64_t)a1);
    unsigned int v4 = sub_100064168((uint64_t)a1);
    unsigned int v5 = sub_1000807A0((uint64_t)&OBJC_CLASS___UMKPersonaInfo, v4);
    *(_DWORD *)(a2 + _Block_object_dispose(va, 8) = v5;
    if (v5 < 9)
    {
      id v11 = sub_1000741F8(a1, v6);
      int v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
      unsigned __int8 v13 = [v12 getCString:a2 + 88 maxLength:256 encoding:4];

      if ((v13 & 1) != 0)
      {
        *(_DWORD *)(a2 + 344) = sub_1000642D4((uint64_t)a1);
        return result;
      }

      if (qword_1000DBBF8 != -1) {
        dispatch_once(&qword_1000DBBF8, &stru_1000CDB88);
      }
      uint64_t v7 = (os_log_s *)(id)qword_1000DBBF0;
      if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
        goto LABEL_25;
      }
      uint64_t v20 = 0LL;
      LODWORD(v15) = sub_100053B4C(0);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
        uint64_t v15 = v15;
      }
      else {
        uint64_t v15 = v15 & 0xFFFFFFFE;
      }
      if ((_DWORD)v15)
      {
        int v9 = v7;
        id v17 = sub_1000741F8(a1, v16);
        int v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
        *(_DWORD *)uint64_t v19 = 138543362;
        *(void *)&v19[4] = v18;
        unsigned int v10 = (char *)_os_log_send_and_compose_impl( v15,  &v20,  0LL,  0LL,  &_mh_execute_header,  v9,  16LL,  "Failed to create kpersona_info struct: Failed to convert name to C string: %{public}@",  v19,  12);

LABEL_21:
        if (v10) {
          sub_100053B7C(v10);
        }
        goto LABEL_24;
      }
    }

    else
    {
      if (qword_1000DBBF8 != -1) {
        dispatch_once(&qword_1000DBBF8, &stru_1000CDB88);
      }
      uint64_t v7 = (os_log_s *)(id)qword_1000DBBF0;
      if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
        goto LABEL_25;
      }
      *(void *)uint64_t v19 = 0LL;
      LODWORD(v_Block_object_dispose(va, 8) = sub_100053B4C(0);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
        uint64_t v8 = v8;
      }
      else {
        uint64_t v8 = v8 & 0xFFFFFFFE;
      }
      if ((_DWORD)v8)
      {
        int v9 = v7;
        LODWORD(v20) = 67109120;
        HIDWORD(v20) = sub_100064168((uint64_t)a1);
        unsigned int v10 = (char *)_os_log_send_and_compose_impl( v8,  v19,  0LL,  0LL,  &_mh_execute_header,  v9,  16LL,  "Failed to create kpersona_info struct: Unknown type: %u",  &v20);
        goto LABEL_21;
      }
    }

    unsigned int v10 = 0LL;
LABEL_24:
    free(v10);
LABEL_25:

    double result = 0.0;
    *(_OWORD *)(a2 + 332) = 0u;
    *(_OWORD *)(a2 + 304) = 0u;
    *(_OWORD *)(a2 + 320) = 0u;
    *(_OWORD *)(a2 + 272) = 0u;
    *(_OWORD *)(a2 + 28_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(a2 + 240) = 0u;
    *(_OWORD *)(a2 + 256) = 0u;
    *(_OWORD *)(a2 + 20_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(a2 + 224) = 0u;
    *(_OWORD *)(a2 + 176) = 0u;
    *(_OWORD *)(a2 + 192) = 0u;
    *(_OWORD *)(a2 + 144) = 0u;
    *(_OWORD *)(a2 + 160) = 0u;
    *(_OWORD *)(a2 + 112) = 0u;
    *(_OWORD *)(a2 + 12_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(a2 + 80) = 0u;
    *(_OWORD *)(a2 + 96) = 0u;
    *(_OWORD *)(a2 + 4_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(a2 + 64) = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)a2 = 0u;
    return result;
  }

  double result = 0.0;
  *(_OWORD *)(a2 + 304) = 0u;
  *(_OWORD *)(a2 + 320) = 0u;
  *(_OWORD *)(a2 + 272) = 0u;
  *(_OWORD *)(a2 + 28_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a2 + 240) = 0u;
  *(_OWORD *)(a2 + 256) = 0u;
  *(_OWORD *)(a2 + 20_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a2 + 224) = 0u;
  *(_OWORD *)(a2 + 176) = 0u;
  *(_OWORD *)(a2 + 192) = 0u;
  *(_OWORD *)(a2 + 144) = 0u;
  *(_OWORD *)(a2 + 160) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 12_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 4_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 332) = 0u;
  return result;
}

LABEL_58:
      int v22 = 0LL;
LABEL_59:
      free(v22);
    }

LABEL_60:
    if (a5)
    {
      int v34 = NSPOSIXErrorDomain;
      uint64_t v35 = v10;
      goto LABEL_62;
    }

    goto LABEL_67;
  }

  unsigned int v28 = v51;
  if (v28 != sub_10005682C((uint64_t)v7))
  {
    if (qword_1000DBBF8 != -1) {
      dispatch_once(&qword_1000DBBF8, &stru_1000CDB88);
    }
    unsigned int v29 = (os_log_s *)(id)qword_1000DBBF0;
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)unsigned int v52 = 0LL;
      LODWORD(v30) = sub_100053B4C(0);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v30 = v30;
      }
      else {
        uint64_t v30 = v30 & 0xFFFFFFFE;
      }
      if ((_DWORD)v30)
      {
        __int128 v31 = v29;
        unsigned int v32 = sub_10005682C((uint64_t)v7);
        LODWORD(v53) = 67109376;
        HIDWORD(v53) = v32;
        uint64_t v54 = 1024;
        unsigned int v55 = v51;
        __int16 v33 = (char *)_os_log_send_and_compose_impl( v30,  v52,  0LL,  0LL,  &_mh_execute_header,  v31,  0LL,  "While allocating kernel persona: Persona ID changed during allocation: %u -> %u",  &v53,  14);

        if (v33) {
          sub_100053B7C(v33);
        }
      }

      else
      {
        __int16 v33 = 0LL;
      }

      free(v33);
    }

    sub_100056838((uint64_t)v7, v51);
  }

  if (qword_1000DBBF8 != -1) {
    dispatch_once(&qword_1000DBBF8, &stru_1000CDB88);
  }
  unsigned int v37 = (os_log_s *)(id)qword_1000DBBF0;
  if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)unsigned int v52 = 0LL;
    uint64_t v38 = sub_100053B4C(0);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT)) {
      uint64_t v39 = v38;
    }
    else {
      uint64_t v39 = v38 & 0xFFFFFFFE;
    }
    if ((_DWORD)v39)
    {
      int v40 = v37;
      uint64_t v41 = sub_10005682C((uint64_t)v7);
      int v42 = sub_100064168((uint64_t)v7);
      int v44 = sub_1000741F8(v7, v43);
      int v45 = (_BYTE *)objc_claimAutoreleasedReturnValue(v44);
      char v46 = sub_1000642D4((uint64_t)v7);
      LODWORD(v53) = 67109890;
      HIDWORD(v53) = v41;
      uint64_t v54 = 1024;
      unsigned int v55 = v42;
      uint64_t v56 = 2114;
      id v57 = v45;
      gid_t v58 = 1024;
      uint64_t v59 = v46;
      LODWORD(v49) = 30;
      __int16 v47 = (char *)_os_log_send_and_compose_impl( v39,  v52,  0LL,  0LL,  &_mh_execute_header,  v40,  0LL,  "Allocated kernel persona with ID: %u, Type: %d, Name: %{public}@, UID: %u",  &v53,  v49);

      if (v47) {
        sub_100053B7C(v47);
      }
    }

    else
    {
      __int16 v47 = 0LL;
    }

    free(v47);
  }

  unsigned int v36 = 1;
LABEL_83:

  return v36;
}

void sub_100082224(id a1)
{
  os_log_t v1 = os_log_create(off_1000DAE70, "sideeffect");
  unsigned int v2 = (void *)qword_1000DBBF0;
  qword_1000DBBF0 = (uint64_t)v1;
}

void sub_100082258(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 8), a2);
  }
}

id *sub_1000822E0(id *a1, void *a2)
{
  id v4 = a2;
  if (a1)
  {
    v7.receiver = a1;
    v7.super_class = (Class)&OBJC_CLASS___UMDVolumeHelper;
    unsigned int v5 = (id *)objc_msgSendSuper2(&v7, "init");
    if (!v5) {
      sub_1000A9AD0();
    }
    a1 = v5;

    objc_storeStrong(a1 + 2, a2);
  }

  return a1;
}

void sub_100082BE8(id a1)
{
  os_log_t v1 = os_log_create(off_1000DAE70, "volume");
  unsigned int v2 = (void *)qword_1000DBC00;
  qword_1000DBC00 = (uint64_t)v1;
}

void sub_100082C90(uint64_t a1)
{
  uint64_t v1 = objc_opt_new(*(void *)(a1 + 32));
  unsigned int v2 = (void *)qword_1000DBC10;
  qword_1000DBC10 = v1;

  if (qword_1000DBC10)
  {
    uint64_t v3 = -[NSXPCListener initWithMachServiceName:]( objc_alloc(&OBJC_CLASS___NSXPCListener),  "initWithMachServiceName:",  @"com.apple.mobile.keybagd.UserManager.xpc");
    [(id)qword_1000DBC10 setXpcListener:v3];

    id v4 = (void *)objc_claimAutoreleasedReturnValue([(id)qword_1000DBC10 xpcListener]);
    unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue([v4 _xpcConnection]);
    __xpc_connection_set_logging(v5, 0LL);

    uint64_t v6 = qword_1000DBC10;
    id v7 = (id)objc_claimAutoreleasedReturnValue([(id)qword_1000DBC10 xpcListener]);
    [v7 setDelegate:v6];
  }

void sub_1000831CC(uint64_t a1)
{
  id v2 = (id)objc_claimAutoreleasedReturnValue(+[RDServer sharedServer](&OBJC_CLASS___RDServer, "sharedServer"));
  [v2 removeClient:*(void *)(a1 + 32)];
}

void sub_100083210(uint64_t a1)
{
  id v2 = (id)objc_claimAutoreleasedReturnValue(+[RDServer sharedServer](&OBJC_CLASS___RDServer, "sharedServer"));
  [v2 removeClient:*(void *)(a1 + 32)];
}

void sub_100083254(uint64_t a1)
{
  id v2 = (id)objc_claimAutoreleasedReturnValue(+[RDServer sharedServer](&OBJC_CLASS___RDServer, "sharedServer"));
  [v2 removeClient:*(void *)(a1 + 32)];
}

void sub_100083298(uint64_t a1)
{
  id v2 = (id)objc_claimAutoreleasedReturnValue(+[RDServer sharedServer](&OBJC_CLASS___RDServer, "sharedServer"));
  [v2 removeClient:*(void *)(a1 + 32)];
}

void sub_1000832FC()
{
  BOOL v0 = objc_autoreleasePoolPush();
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue(+[RDXPCListener sharedListener](&OBJC_CLASS___RDXPCListener, "sharedListener"));
  [v1 startListening];

  objc_autoreleasePoolPop(v0);
}

id sub_1000833D0()
{
  BOOL v0 = objc_opt_new(&OBJC_CLASS___RXSyncXPCListener);
  uint64_t v1 = (void *)qword_1000DBC28;
  qword_1000DBC28 = (uint64_t)v0;

  id v2 = -[NSXPCListener initWithMachServiceName:]( objc_alloc(&OBJC_CLASS___NSXPCListener),  "initWithMachServiceName:",  @"com.apple.mobile.usermanagerd.xpc");
  uint64_t v3 = (void *)qword_1000DBC20;
  qword_1000DBC20 = (uint64_t)v2;

  id v4 = (void *)objc_claimAutoreleasedReturnValue([(id)qword_1000DBC20 _xpcConnection]);
  __xpc_connection_set_logging(v4, 0LL);

  [(id)qword_1000DBC20 setDelegate:qword_1000DBC28];
  return [(id)qword_1000DBC20 resume];
}

void sub_100083460(id a1)
{
  os_log_t v1 = os_log_create(off_1000DAE70, "legacy");
  id v2 = (void *)qword_1000DBC30;
  qword_1000DBC30 = (uint64_t)v1;
}

void sub_100083BC8(id a1)
{
  os_log_t v1 = os_log_create(off_1000DAE70, "sideeffect");
  id v2 = (void *)qword_1000DBC40;
  qword_1000DBC40 = (uint64_t)v1;
}

const void *sub_100083BFC(const __CFDictionary *a1, const void *a2)
{
  double result = CFDictionaryGetValue(a1, a2);
  if (result)
  {
    uint64_t v3 = result;
    CFTypeID v4 = CFGetTypeID(result);
    if (v4 == CFDataGetTypeID()) {
      return v3;
    }
    else {
      return 0LL;
    }
  }

  return result;
}

const void *sub_100083C34(const __CFDictionary *a1, const void *a2)
{
  double result = CFDictionaryGetValue(a1, a2);
  if (result)
  {
    uint64_t v3 = result;
    CFTypeID v4 = CFGetTypeID(result);
    if (v4 == CFArrayGetTypeID()) {
      return v3;
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_100083C6C(const __CFDictionary *a1, const void *a2)
{
  uint64_t v2 = 0xFFFFFFFFLL;
  unsigned int valuePtr = -1;
  Value = (const __CFNumber *)CFDictionaryGetValue(a1, a2);
  if (Value)
  {
    CFTypeID v4 = Value;
    CFTypeID v5 = CFGetTypeID(Value);
    if (v5 == CFNumberGetTypeID())
    {
      CFNumberGetValue(v4, kCFNumberIntType, &valuePtr);
      return valuePtr;
    }

    else
    {
      return 0xFFFFFFFFLL;
    }
  }

  return v2;
}

uint64_t sub_100083CD4(const __CFDictionary *a1, const void *a2)
{
  uint64_t v2 = -1LL;
  uint64_t valuePtr = -1LL;
  Value = (const __CFNumber *)CFDictionaryGetValue(a1, a2);
  if (Value)
  {
    CFTypeID v4 = Value;
    CFTypeID v5 = CFGetTypeID(Value);
    if (v5 == CFNumberGetTypeID())
    {
      CFNumberGetValue(v4, kCFNumberLongLongType, &valuePtr);
      return valuePtr;
    }

    else
    {
      return -1LL;
    }
  }

  return v2;
}

uint64_t sub_100083D3C(const __CFDictionary *a1, const void *a2)
{
  uint64_t v2 = -1LL;
  uint64_t valuePtr = -1LL;
  Value = (const __CFNumber *)CFDictionaryGetValue(a1, a2);
  if (Value)
  {
    CFTypeID v4 = Value;
    CFTypeID v5 = CFGetTypeID(Value);
    if (v5 == CFNumberGetTypeID())
    {
      CFNumberGetValue(v4, kCFNumberSInt64Type, &valuePtr);
      return valuePtr;
    }

    else
    {
      return -1LL;
    }
  }

  return v2;
}

CFBooleanRef sub_100083DA4(const __CFDictionary *a1, const void *a2)
{
  double result = (const __CFBoolean *)CFDictionaryGetValue(a1, a2);
  if (result)
  {
    uint64_t v3 = result;
    CFTypeID v4 = CFGetTypeID(result);
    if (v4 == CFBooleanGetTypeID()) {
      return (const __CFBoolean *)(CFBooleanGetValue(v3) != 0);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

const void *sub_100083DF4(const __CFDictionary *a1, const void *a2)
{
  Value = CFDictionaryGetValue(a1, a2);
  if (!Value) {
    return 0LL;
  }
  uint64_t v3 = Value;
  CFTypeID v4 = CFGetTypeID(Value);
  if (v4 != CFStringGetTypeID()) {
    return 0LL;
  }
  return v3;
}

BOOL sub_100083E34(const __CFDictionary *a1, const void *a2, char *a3, int a4)
{
  uint64_t v6 = (const __CFString *)sub_100083DF4(a1, a2);
  return v6 && CFStringGetCString(v6, a3, a4, 0x8000100u);
}

CFTypeRef sub_100083E80(const __CFDictionary *a1, const void *a2)
{
  Value = CFDictionaryGetValue(a1, a2);
  if (Value && (uint64_t v3 = Value, v4 = CFGetTypeID(Value), v4 == CFDictionaryGetTypeID())) {
    return CFRetain(v3);
  }
  else {
    return 0LL;
  }
}

CFTypeRef sub_100083ECC(const void *a1)
{
  uint64_t v2 = CFWriteStreamCreateWithAllocatedBuffers(kCFAllocatorDefault, kCFAllocatorDefault);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = v2;
  if (CFWriteStreamOpen(v2))
  {
    if (CFPropertyListWrite(a1, v3, kCFPropertyListBinaryFormat_v1_0, 0LL, 0LL) < 1) {
      CFTypeRef v4 = 0LL;
    }
    else {
      CFTypeRef v4 = CFWriteStreamCopyProperty(v3, kCFStreamPropertyDataWritten);
    }
    CFWriteStreamClose(v3);
  }

  else
  {
    CFTypeRef v4 = 0LL;
  }

  CFRelease(v3);
  return v4;
}

CFPropertyListRef sub_100083F70(UInt8 *bytes, CFIndex length)
{
  CFPropertyListFormat format = kCFPropertyListBinaryFormat_v1_0;
  uint64_t v2 = CFReadStreamCreateWithBytesNoCopy(kCFAllocatorDefault, bytes, length, kCFAllocatorNull);
  if (v2)
  {
    uint64_t v3 = v2;
    if (CFReadStreamOpen(v2))
    {
      CFPropertyListRef v4 = CFPropertyListCreateWithStream(kCFAllocatorDefault, v3, 0LL, 2uLL, &format, 0LL);
      if (!v4) {
        syslog(7, "Could not create object from stream");
      }
      CFReadStreamClose(v3);
    }

    else
    {
      syslog(7, "Could not open the stream");
      CFPropertyListRef v4 = 0LL;
    }

    CFRelease(v3);
  }

  else
  {
    syslog(7, "Could not create stream for serialized data");
    return 0LL;
  }

  return v4;
}

const void *sub_10008404C(UInt8 *bytes, CFIndex length)
{
  uint64_t v2 = 0LL;
  CFPropertyListFormat format = kCFPropertyListBinaryFormat_v1_0;
  if (bytes && length)
  {
    CFPropertyListRef v4 = CFReadStreamCreateWithBytesNoCopy(kCFAllocatorDefault, bytes, length, kCFAllocatorNull);
    if (!v4)
    {
      syslog(7, "Could not create stream from serialized data");
      return 0LL;
    }

    CFTypeID v5 = v4;
    if (CFReadStreamOpen(v4))
    {
      CFPropertyListRef v6 = CFPropertyListCreateWithStream(kCFAllocatorDefault, v5, length, 2uLL, &format, 0LL);
      uint64_t v2 = v6;
      if (!v6)
      {
        syslog(7, "Could not create dictionary from stream");
        goto LABEL_9;
      }

      CFTypeID v7 = CFGetTypeID(v6);
      if (v7 == CFDictionaryGetTypeID())
      {
LABEL_9:
        CFReadStreamClose(v5);
        CFRelease(v5);
        return v2;
      }

      CFRelease(v2);
    }

    else
    {
      syslog(7, "Could not open the stream");
    }

    uint64_t v2 = 0LL;
    goto LABEL_9;
  }

  return v2;
}

const void *sub_100084160(const char *a1)
{
  int v2 = open(a1, 0);
  if (v2 == -1)
  {
    int v9 = __error();
    unsigned int v10 = strerror(*v9);
    syslog(7, "Could not open %s: %s", a1, v10);
    CFTypeID v5 = 0LL;
    CFTypeID v7 = 0LL;
    goto LABEL_7;
  }

  int v3 = v2;
  if (fstat(v2, &v14))
  {
    id v11 = __error();
    int v12 = strerror(*v11);
    syslog(7, "Could not fstat %s: %s", a1, v12);
    CFTypeID v7 = 0LL;
    CFTypeID v5 = 0LL;
    goto LABEL_6;
  }

  off_t st_size = v14.st_size;
  CFTypeID v5 = malloc(LODWORD(v14.st_size));
  if (!v5)
  {
    syslog(7, "Could not allocate buffer");
LABEL_12:
    CFTypeID v7 = 0LL;
    goto LABEL_6;
  }

  ssize_t v6 = read(v3, v5, st_size);
  if (v6 != v14.st_size)
  {
    unsigned __int8 v13 = __error();
    strerror(*v13);
    syslog(7, "Could not read %s: %s");
    goto LABEL_12;
  }

  CFTypeID v7 = sub_10008404C((UInt8 *)v5, v6);
LABEL_6:
  close(v3);
LABEL_7:
  free(v5);
  return v7;
}

CFMutableDictionaryRef sub_10008428C()
{
  CFMutableDictionaryRef result = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (!result)
  {
    syslog(7, "Out of Memory!!! Dying!...so...cold....");
    exit(-1);
  }

  return result;
}

CFMutableDictionaryRef sub_1000842DC(CFDictionaryRef theDict)
{
  CFMutableDictionaryRef result = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, theDict);
  if (!result)
  {
    syslog(7, "Out of Memory!!! Dying!...so...cold....");
    exit(-1);
  }

  return result;
}

CFMutableArrayRef sub_100084320()
{
  CFMutableArrayRef result = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  if (!result)
  {
    syslog(7, "Out of Memory!!! Dying!...so...cold....");
    exit(-1);
  }

  return result;
}

CFStringRef sub_100084368(char *cStr)
{
  CFStringRef result = CFStringCreateWithCString(kCFAllocatorDefault, cStr, 0x8000100u);
  if (!result)
  {
    syslog(7, "Out of Memory!!! Dying!...so...cold....");
    exit(-1);
  }

  return result;
}

uint64_t sub_1000843B0(uint32_t *a1)
{
  uint32_t multiuser_flags = 0;
  mach_port_t v2 = mach_host_self();
  uint64_t result = host_get_multiuser_config_flags(v2, &multiuser_flags);
  if (a1)
  {
    if (!(_DWORD)result) {
      *a1 = multiuser_flags;
    }
  }

  return result;
}

uint64_t sub_1000843F4(mach_port_name_t name)
{
  mach_port_type_t ptype = 0;
  if (mach_port_type(mach_task_self_, name, &ptype)) {
    return 0LL;
  }
  else {
    return ptype;
  }
}

void sub_100084434(mach_port_name_t name)
{
  kern_return_t v2;
  mach_port_type_t v3;
  BOOL v4;
  mach_port_type_t ptype;
  mach_port_type_t ptype = 0;
  mach_port_t v2 = mach_port_type(mach_task_self_, name, &ptype);
  int v3 = ptype;
  if (v2) {
    CFPropertyListRef v4 = 1;
  }
  else {
    CFPropertyListRef v4 = ptype == 0;
  }
  if (v4)
  {
    syslog(7, "Port:%d has NORIGHTS");
    return;
  }

  if ((ptype & 0x10000) != 0)
  {
    syslog(7, "Port:%d has SENDRIGHT", name);
    if ((v3 & 0x20000) == 0)
    {
LABEL_9:
      if ((v3 & 0x40000) == 0) {
        goto LABEL_10;
      }
LABEL_14:
      syslog(7, "Port:%d has SENDONCERIGHT", name);
      if ((v3 & 0x100000) == 0) {
        return;
      }
      goto LABEL_15;
    }
  }

  else if ((ptype & 0x20000) == 0)
  {
    goto LABEL_9;
  }

  syslog(7, "Port:%d has RECEIVERIGHT", name);
  if ((v3 & 0x40000) != 0) {
    goto LABEL_14;
  }
LABEL_10:
  if ((v3 & 0x100000) != 0) {
LABEL_15:
  }
    syslog(7, "Port:%d has DEADNAME");
}

uint64_t sub_10008450C()
{
  size_t __len = 1023LL;
  bzero(__big, 0x400uLL);
  if (sysctlbyname("kern.bootargs", __big, &__len, 0LL, 0LL) || strnstr(__big, "um-migration-debug=0", __len)) {
    return 0LL;
  }
  if (strnstr(__big, "um-migration-debug=1", __len)) {
    return 1LL;
  }
  if (strnstr(__big, "um-migration-debug=2", __len)) {
    return 2LL;
  }
  if (strnstr(__big, "um-migration-debug=3", __len)) {
    return 3LL;
  }
  if (strnstr(__big, "um-migration-debug=4", __len)) {
    return 4LL;
  }
  if (strnstr(__big, "um-migration-debug=5", __len)) {
    return 5LL;
  }
  if (strnstr(__big, "um-migration-debug=100", __len)) {
    return 100LL;
  }
  if (strnstr(__big, "um-migration-debug=101", __len)) {
    return 101LL;
  }
  return 0LL;
}

void sub_1000848C0(uint64_t a1, char a2, void *a3)
{
  id v5 = a3;
  if ((a2 & 1) != 0)
  {
    if (qword_1000DBC58 != -1) {
      dispatch_once(&qword_1000DBC58, &stru_1000CDC30);
    }
    ssize_t v6 = (os_log_s *)(id)qword_1000DBC50;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = 0LL;
      unsigned int v7 = sub_100053B4C(0);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
        uint64_t v8 = v7;
      }
      else {
        uint64_t v8 = v7 & 0xFFFFFFFE;
      }
      if ((_DWORD)v8)
      {
        int v9 = *(void **)(a1 + 32);
        int v15 = 138543362;
        id v16 = v9;
        unsigned int v10 = (const char *)_os_log_send_and_compose_impl( v8,  &v14,  0LL,  0LL,  &_mh_execute_header,  v6,  0LL,  "_SecKeychainDeleteMultiUser Completion: Deleted keychain items for persona %{public}@",  &v15,  12);
        goto LABEL_18;
      }

      goto LABEL_20;
    }
  }

  else
  {
    if (qword_1000DBC58 != -1) {
      dispatch_once(&qword_1000DBC58, &stru_1000CDC30);
    }
    ssize_t v6 = (os_log_s *)(id)qword_1000DBC50;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      uint64_t v14 = 0LL;
      unsigned int v11 = sub_100053B4C(0);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
        uint64_t v12 = v11;
      }
      else {
        uint64_t v12 = v11 & 0xFFFFFFFE;
      }
      if ((_DWORD)v12)
      {
        int v15 = 138543362;
        id v16 = v5;
        unsigned int v10 = (const char *)_os_log_send_and_compose_impl( v12,  &v14,  0LL,  0LL,  &_mh_execute_header,  v6,  16LL,  "_SecKeychainDeleteMultiUser Completed: Failed to delete persona keychain items: %{public}@",  &v15,  12);
LABEL_18:
        unsigned __int8 v13 = (char *)v10;
        if (v10) {
          sub_100053B7C(v10);
        }
        goto LABEL_21;
      }

void sub_100084AB8(id a1)
{
  os_log_t v1 = os_log_create(off_1000DAE70, "sideeffect");
  mach_port_t v2 = (void *)qword_1000DBC50;
  qword_1000DBC50 = (uint64_t)v1;
}

id sub_100084DBC(void *a1)
{
  if (a1)
  {
    os_log_t v1 = sub_100017CFC((uint64_t)&OBJC_CLASS___NSUUID, a1);
    mach_port_t v2 = (void *)objc_claimAutoreleasedReturnValue(v1);
    int v3 = (void *)objc_claimAutoreleasedReturnValue([v2 UUIDString]);
  }

  else
  {
    int v3 = 0LL;
  }

  return v3;
}

id sub_100084E0C(void *a1, uint64_t a2)
{
  if (!a1) {
    return 0LL;
  }
  mach_port_t v2 = (void *)objc_claimAutoreleasedReturnValue([a1 objectForKey:a2]);
  uint64_t v3 = objc_opt_class(&OBJC_CLASS___NSNumber);
  if ((objc_opt_isKindOfClass(v2, v3) & 1) != 0)
  {
    id v4 = [v2 BOOLValue];
    int v5 = 0;
  }

  else
  {
    id v4 = 0LL;
    int v5 = 2;
  }

  *__error() = v5;

  return v4;
}

id sub_100084E90(void *a1, uint64_t a2, id a3)
{
  if (!a1) {
    return 0LL;
  }
  id v4 = (void *)objc_claimAutoreleasedReturnValue([a1 objectForKey:a2]);
  uint64_t v5 = objc_opt_class(&OBJC_CLASS___NSNumber);
  if ((objc_opt_isKindOfClass(v4, v5) & 1) != 0)
  {
    a3 = [v4 intValue];
    int v6 = 0;
  }

  else
  {
    int v6 = 2;
  }

  *__error() = v6;

  return a3;
}

id sub_100084F14(void *a1, uint64_t a2, id a3)
{
  if (!a1) {
    return 0LL;
  }
  id v4 = (void *)objc_claimAutoreleasedReturnValue([a1 objectForKey:a2]);
  uint64_t v5 = objc_opt_class(&OBJC_CLASS___NSNumber);
  if ((objc_opt_isKindOfClass(v4, v5) & 1) != 0)
  {
    a3 = [v4 unsignedIntValue];
    int v6 = 0;
  }

  else
  {
    int v6 = 2;
  }

  *__error() = v6;

  return a3;
}

id sub_100084F98(void *a1, uint64_t a2, id a3)
{
  if (!a1) {
    return 0LL;
  }
  id v4 = (void *)objc_claimAutoreleasedReturnValue([a1 objectForKey:a2]);
  uint64_t v5 = objc_opt_class(&OBJC_CLASS___NSNumber);
  if ((objc_opt_isKindOfClass(v4, v5) & 1) != 0)
  {
    a3 = [v4 longLongValue];
    int v6 = 0;
  }

  else
  {
    int v6 = 2;
  }

  *__error() = v6;

  return a3;
}

id sub_10008501C(void *a1, uint64_t a2, id a3)
{
  if (!a1) {
    return 0LL;
  }
  id v4 = (void *)objc_claimAutoreleasedReturnValue([a1 objectForKey:a2]);
  uint64_t v5 = objc_opt_class(&OBJC_CLASS___NSNumber);
  if ((objc_opt_isKindOfClass(v4, v5) & 1) != 0)
  {
    a3 = [v4 unsignedLongLongValue];
    int v6 = 0;
  }

  else
  {
    int v6 = 2;
  }

  *__error() = v6;

  return a3;
}

id sub_1000850A0(void *a1, uint64_t a2)
{
  if (a1)
  {
    mach_port_t v2 = (void *)objc_claimAutoreleasedReturnValue([a1 objectForKey:a2]);
    uint64_t v3 = objc_opt_class(&OBJC_CLASS___NSString);
    char isKindOfClass = objc_opt_isKindOfClass(v2, v3);
    uint64_t v5 = __error();
    if ((isKindOfClass & 1) != 0)
    {
      *uint64_t v5 = 0;
      id v6 = v2;
    }

    else
    {
      id v6 = 0LL;
      *uint64_t v5 = 2;
    }
  }

  else
  {
    id v6 = 0LL;
  }

  return v6;
}

id sub_10008511C(void *a1, uint64_t a2)
{
  if (!a1) {
    return 0LL;
  }
  mach_port_t v2 = (void *)objc_claimAutoreleasedReturnValue([a1 objectForKey:a2]);
  uint64_t v3 = objc_opt_class(&OBJC_CLASS___NSArray);
  if ((objc_opt_isKindOfClass(v2, v3) & 1) != 0)
  {
    __int128 v13 = 0u;
    __int128 v14 = 0u;
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    id v4 = v2;
    id v5 = [v4 countByEnumeratingWithState:&v13 objects:v17 count:16];
    if (v5)
    {
      id v6 = v5;
      uint64_t v7 = *(void *)v14;
      while (2)
      {
        uint64_t v8 = 0LL;
        do
        {
          if (*(void *)v14 != v7) {
            objc_enumerationMutation(v4);
          }
          uint64_t v9 = *(void *)(*((void *)&v13 + 1) + 8LL * (void)v8);
          uint64_t v10 = objc_opt_class(&OBJC_CLASS___NSString);
          if ((objc_opt_isKindOfClass(v9, v10) & 1) == 0)
          {
            *__error() = 2;

            unsigned int v11 = 0LL;
            goto LABEL_14;
          }

          uint64_t v8 = (char *)v8 + 1;
        }

        while (v6 != v8);
        id v6 = [v4 countByEnumeratingWithState:&v13 objects:v17 count:16];
        if (v6) {
          continue;
        }
        break;
      }
    }

    unsigned int v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSSet setWithArray:](&OBJC_CLASS___NSSet, "setWithArray:", v4, (void)v13));
    *__error() = 0;
LABEL_14:
  }

  else
  {
    unsigned int v11 = 0LL;
    *__error() = 2;
  }

  return v11;
}

id sub_1000852B4(void *a1, uint64_t a2)
{
  if (a1)
  {
    mach_port_t v2 = (void *)objc_claimAutoreleasedReturnValue([a1 objectForKey:a2]);
    uint64_t v3 = objc_opt_class(&OBJC_CLASS___NSString);
    if ((objc_opt_isKindOfClass(v2, v3) & 1) != 0)
    {
      id v4 = sub_100017CFC((uint64_t)&OBJC_CLASS___NSUUID, v2);
      id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      int v6 = 2 * (v5 == 0LL);
    }

    else
    {
      id v5 = 0LL;
      int v6 = 2;
    }

    *__error() = v6;
  }

  else
  {
    id v5 = 0LL;
  }

  return v5;
}

id sub_10008534C(void *a1, uint64_t a2)
{
  if (a1)
  {
    mach_port_t v2 = (void *)objc_claimAutoreleasedReturnValue([a1 objectForKey:a2]);
    uint64_t v3 = objc_opt_class(&OBJC_CLASS___NSDate);
    char isKindOfClass = objc_opt_isKindOfClass(v2, v3);
    id v5 = __error();
    if ((isKindOfClass & 1) != 0)
    {
      *id v5 = 0;
      id v6 = v2;
    }

    else
    {
      id v6 = 0LL;
      *id v5 = 2;
    }
  }

  else
  {
    id v6 = 0LL;
  }

  return v6;
}

id sub_1000853C8(void *a1, uint64_t a2)
{
  if (a1)
  {
    mach_port_t v2 = (void *)objc_claimAutoreleasedReturnValue([a1 objectForKey:a2]);
    uint64_t v3 = objc_opt_class(&OBJC_CLASS___NSData);
    char isKindOfClass = objc_opt_isKindOfClass(v2, v3);
    id v5 = __error();
    if ((isKindOfClass & 1) != 0)
    {
      *id v5 = 0;
      id v6 = v2;
    }

    else
    {
      id v6 = 0LL;
      *id v5 = 2;
    }
  }

  else
  {
    id v6 = 0LL;
  }

  return v6;
}

id sub_100085444(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  id v10 = 0LL;
  os_log_t v1 = (void *)objc_claimAutoreleasedReturnValue( +[NSPropertyListSerialization dataWithPropertyList:format:options:error:]( &OBJC_CLASS___NSPropertyListSerialization,  "dataWithPropertyList:format:options:error:",  a1,  200LL,  0LL,  &v10));
  id v2 = v10;
  if (!v1)
  {
    if (qword_1000DBC68 != -1) {
      dispatch_once(&qword_1000DBC68, &stru_1000CDC50);
    }
    uint64_t v3 = (os_log_s *)(id)qword_1000DBC60;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = 0LL;
      unsigned int v4 = sub_100053B4C(0);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
        uint64_t v5 = v4;
      }
      else {
        uint64_t v5 = v4 & 0xFFFFFFFE;
      }
      if ((_DWORD)v5)
      {
        int v11 = 138543362;
        id v12 = v2;
        id v6 = (const char *)_os_log_send_and_compose_impl( v5,  &v9,  0LL,  0LL,  &_mh_execute_header,  v3,  16LL,  "Failed to convert dictionary into binary plist: %{public}@",  &v11,  12);
        uint64_t v7 = (char *)v6;
        if (v6) {
          sub_100053B7C(v6);
        }
      }

      else
      {
        uint64_t v7 = 0LL;
      }

      free(v7);
    }
  }

  return v1;
}

id sub_1000855C0(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  id v10 = 0LL;
  os_log_t v1 = (void *)objc_claimAutoreleasedReturnValue( +[NSPropertyListSerialization dataWithPropertyList:format:options:error:]( &OBJC_CLASS___NSPropertyListSerialization,  "dataWithPropertyList:format:options:error:",  a1,  200LL,  0LL,  &v10));
  id v2 = v10;
  if (!v1)
  {
    if (qword_1000DBC68 != -1) {
      dispatch_once(&qword_1000DBC68, &stru_1000CDC50);
    }
    uint64_t v3 = (os_log_s *)(id)qword_1000DBC60;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = 0LL;
      unsigned int v4 = sub_100053B4C(0);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
        uint64_t v5 = v4;
      }
      else {
        uint64_t v5 = v4 & 0xFFFFFFFE;
      }
      if ((_DWORD)v5)
      {
        int v11 = 138412290;
        id v12 = v2;
        id v6 = (const char *)_os_log_send_and_compose_impl( v5,  &v9,  0LL,  0LL,  &_mh_execute_header,  v3,  16LL,  "Failed to convert array into binary plist: %@",  &v11,  12);
        uint64_t v7 = (char *)v6;
        if (v6) {
          sub_100053B7C(v6);
        }
      }

      else
      {
        uint64_t v7 = 0LL;
      }

      free(v7);
    }
  }

  return v1;
}

id sub_10008573C(uint64_t a1)
{
  if (a1)
  {
    id v17 = 0LL;
    os_log_t v1 = (void *)objc_claimAutoreleasedReturnValue( +[NSPropertyListSerialization propertyListWithData:options:format:error:]( &OBJC_CLASS___NSPropertyListSerialization,  "propertyListWithData:options:format:error:",  a1,  0LL,  0LL,  &v17));
    id v2 = v17;
    if (v1)
    {
      uint64_t v3 = objc_opt_class(&OBJC_CLASS___NSDictionary);
      if ((objc_opt_isKindOfClass(v1, v3) & 1) == 0)
      {
        if (qword_1000DBC68 != -1) {
          dispatch_once(&qword_1000DBC68, &stru_1000CDC50);
        }
        unsigned int v4 = (os_log_s *)(id)qword_1000DBC60;
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        {
          *(void *)int v18 = 0LL;
          unsigned int v5 = sub_100053B4C(0);
          if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
            uint64_t v6 = v5;
          }
          else {
            uint64_t v6 = v5 & 0xFFFFFFFE;
          }
          if ((_DWORD)v6)
          {
            LOWORD(v16) = 0;
            uint64_t v7 = (const char *)_os_log_send_and_compose_impl( v6,  v18,  0LL,  0LL,  &_mh_execute_header,  v4,  16LL,  "Failed to parse dictionary plist from data: plist is not a dictionary",  &v16,  2);
            uint64_t v8 = (char *)v7;
            if (v7) {
              sub_100053B7C(v7);
            }
          }

          else
          {
            uint64_t v8 = 0LL;
          }

          free(v8);
        }

        id v14 = 0LL;
        goto LABEL_29;
      }
    }

    else
    {
      if (qword_1000DBC68 != -1) {
        dispatch_once(&qword_1000DBC68, &stru_1000CDC50);
      }
      uint64_t v9 = (os_log_s *)(id)qword_1000DBC60;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        uint64_t v16 = 0LL;
        unsigned int v10 = sub_100053B4C(0);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
          uint64_t v11 = v10;
        }
        else {
          uint64_t v11 = v10 & 0xFFFFFFFE;
        }
        if ((_DWORD)v11)
        {
          *(_DWORD *)int v18 = 138543362;
          *(void *)&v18[4] = v2;
          id v12 = (const char *)_os_log_send_and_compose_impl( v11,  &v16,  0LL,  0LL,  &_mh_execute_header,  v9,  16LL,  "Failed to parse dictionary plist from data: %{public}@",  v18,  12);
          __int128 v13 = (char *)v12;
          if (v12) {
            sub_100053B7C(v12);
          }
        }

        else
        {
          __int128 v13 = 0LL;
        }

        free(v13);
      }
    }

    id v14 = v1;
LABEL_29:

    return v14;
  }

  return 0LL;
}

id sub_1000859B8(uint64_t a1)
{
  if (a1)
  {
    id v17 = 0LL;
    os_log_t v1 = (void *)objc_claimAutoreleasedReturnValue( +[NSPropertyListSerialization propertyListWithData:options:format:error:]( &OBJC_CLASS___NSPropertyListSerialization,  "propertyListWithData:options:format:error:",  a1,  0LL,  0LL,  &v17));
    id v2 = v17;
    if (v1)
    {
      uint64_t v3 = objc_opt_class(&OBJC_CLASS___NSArray);
      if ((objc_opt_isKindOfClass(v1, v3) & 1) == 0)
      {
        if (qword_1000DBC68 != -1) {
          dispatch_once(&qword_1000DBC68, &stru_1000CDC50);
        }
        unsigned int v4 = (os_log_s *)(id)qword_1000DBC60;
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        {
          *(void *)int v18 = 0LL;
          unsigned int v5 = sub_100053B4C(0);
          if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
            uint64_t v6 = v5;
          }
          else {
            uint64_t v6 = v5 & 0xFFFFFFFE;
          }
          if ((_DWORD)v6)
          {
            LOWORD(v16) = 0;
            uint64_t v7 = (const char *)_os_log_send_and_compose_impl( v6,  v18,  0LL,  0LL,  &_mh_execute_header,  v4,  16LL,  "Failed to parse dictionary plist from data: plist is not an array",  &v16,  2);
            uint64_t v8 = (char *)v7;
            if (v7) {
              sub_100053B7C(v7);
            }
          }

          else
          {
            uint64_t v8 = 0LL;
          }

          free(v8);
        }

        id v14 = 0LL;
        goto LABEL_29;
      }
    }

    else
    {
      if (qword_1000DBC68 != -1) {
        dispatch_once(&qword_1000DBC68, &stru_1000CDC50);
      }
      uint64_t v9 = (os_log_s *)(id)qword_1000DBC60;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        uint64_t v16 = 0LL;
        unsigned int v10 = sub_100053B4C(0);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
          uint64_t v11 = v10;
        }
        else {
          uint64_t v11 = v10 & 0xFFFFFFFE;
        }
        if ((_DWORD)v11)
        {
          *(_DWORD *)int v18 = 138543362;
          *(void *)&v18[4] = v2;
          id v12 = (const char *)_os_log_send_and_compose_impl( v11,  &v16,  0LL,  0LL,  &_mh_execute_header,  v9,  16LL,  "Failed to parse array plist from data: %{public}@",  v18,  12);
          __int128 v13 = (char *)v12;
          if (v12) {
            sub_100053B7C(v12);
          }
        }

        else
        {
          __int128 v13 = 0LL;
        }

        free(v13);
      }
    }

    id v14 = v1;
LABEL_29:

    return v14;
  }

  return 0LL;
}

void sub_100085C34(id a1)
{
  os_log_t v1 = os_log_create(off_1000DAE70, "default");
  id v2 = (void *)qword_1000DBC60;
  qword_1000DBC60 = (uint64_t)v1;
}

uint64_t acm_explicit_bzero(void *a1, rsize_t __n)
{
  return memset_s(a1, __n, 0, __n);
}

uint64_t acm_get_mem()
{
  return qword_1000DBC70;
}

void *acm_mem_alloc_data(size_t __size)
{
  uint64_t result = calloc(1uLL, __size);
  if (result) {
    qword_1000DBC78 += __size;
  }
  return result;
}

void acm_mem_free_data(void *a1, rsize_t __n)
{
  if (a1)
  {
    memset_s(a1, __n, 0, __n);
    free(a1);
    uint64_t v4 = qword_1000DBC78 - __n;
    if (qword_1000DBC78 < __n) {
      uint64_t v4 = 0LL;
    }
    qword_1000DBC78 = v4;
  }

void *acm_mem_alloc(size_t __size)
{
  uint64_t result = calloc(1uLL, __size);
  if (result) {
    qword_1000DBC80 += __size;
  }
  return result;
}

void acm_mem_free(void *a1, rsize_t __n)
{
  if (a1)
  {
    memset_s(a1, __n, 0, __n);
    free(a1);
    uint64_t v4 = qword_1000DBC80 - __n;
    if (qword_1000DBC80 < __n) {
      uint64_t v4 = 0LL;
    }
    qword_1000DBC80 = v4;
  }

const char *acm_mem_alloc_info( const char *result, const void *a2, uint64_t a3, const char *a4, int a5, const char *a6)
{
  if (a2) {
    qword_1000DBC70 += a3;
  }
  if (gACMLoggingLevel <= 0x1Eu)
  {
    uint64_t v6 = "NULL";
    if (result) {
      uint64_t v7 = result;
    }
    else {
      uint64_t v7 = "NULL";
    }
    if (a4) {
      uint64_t v8 = a4;
    }
    else {
      uint64_t v8 = "NULL";
    }
    if (a6) {
      uint64_t v6 = a6;
    }
    return (const char *)printf( "%s: %s: mem: type=%s ptr=%p size=%u (total=%u raw=%u data=%u types=%u) %s:%d (%s).\n",  "ACM",  "acm_mem_alloc_info",  v7,  a2,  a3,  qword_1000DBC70,  0,  qword_1000DBC78,  qword_1000DBC80,  v8,  a5,  v6);
  }

  return result;
}

const char *acm_mem_free_info( const char *result, const void *a2, unint64_t a3, const char *a4, int a5, const char *a6)
{
  if (a2)
  {
    uint64_t v6 = qword_1000DBC70 - a3;
    if (qword_1000DBC70 < a3) {
      uint64_t v6 = 0LL;
    }
    qword_1000DBC70 = v6;
  }

  if (gACMLoggingLevel <= 0x1Eu)
  {
    uint64_t v7 = "NULL";
    if (result) {
      uint64_t v8 = result;
    }
    else {
      uint64_t v8 = "NULL";
    }
    if (a4) {
      uint64_t v9 = a4;
    }
    else {
      uint64_t v9 = "NULL";
    }
    if (a6) {
      uint64_t v7 = a6;
    }
    return (const char *)printf( "%s: %s: mem: type=%s ptr=%p size=%u (total=%u raw=%u data=%u types=%u) %s:%d (%s).\n",  "ACM",  "acm_mem_free_info",  v8,  a2,  a3,  qword_1000DBC70,  0,  qword_1000DBC78,  qword_1000DBC80,  v9,  a5,  v7);
  }

  return result;
}

uint64_t GetSerializedVerifyPolicySize( uint64_t a1, char *__s1, uint64_t a3, uint64_t a4, _DWORD *a5, unsigned int a6, void *a7)
{
  unsigned int v14 = 0;
  uint64_t result = 4294967293LL;
  if (a1 && __s1 && a7)
  {
    size_t v12 = strnlen(__s1, 0x81uLL);
    if (v12 > 0x80)
    {
      return 4294967293LL;
    }

    else
    {
      size_t v13 = v12;
      uint64_t result = sub_100085F74(a5, a6, &v14);
      if (!(_DWORD)result) {
        *a7 = v13 + v14 + 26;
      }
    }
  }

  return result;
}

uint64_t sub_100085F74(_DWORD *a1, unsigned int a2, _DWORD *a3)
{
  if (a3)
  {
    *a3 = 0;
    int v6 = 0;
    if (a2)
    {
      uint64_t v7 = a2;
      while (1)
      {
        uint64_t v8 = sub_100088DC0(a1);
        if ((_DWORD)v8) {
          break;
        }
        int v9 = v6 + 8;
        int v10 = a1[4];
        v6 += v10 + 8;
        if (__CFADD__(v10, v9)) {
          goto LABEL_10;
        }
        a1 += 6;
        if (!--v7) {
          goto LABEL_9;
        }
      }

      uint64_t v11 = v8;
      unsigned int v12 = 70;
    }

    else
    {
LABEL_9:
      uint64_t v11 = 0LL;
      *a3 = v6;
      unsigned int v12 = 10;
    }
  }

  else
  {
LABEL_10:
    unsigned int v12 = 70;
    uint64_t v11 = 4294967293LL;
  }

  return v11;
}

uint64_t SerializeVerifyPolicy( _OWORD *a1, char *__s1, char a3, uint64_t a4, _DWORD *a5, unsigned int a6, _OWORD *a7, size_t *a8)
{
  unint64_t v21 = 0LL;
  uint64_t result = 4294967293LL;
  if (a1)
  {
    if (__s1)
    {
      if (a8)
      {
        if (a7)
        {
          if (a6 <= 0xA && (a5 != 0LL) == (a6 != 0))
          {
            int v15 = a4;
            uint64_t result = GetSerializedVerifyPolicySize((uint64_t)a1, __s1, 0LL, a4, a5, a6, &v21);
            if (!(_DWORD)result)
            {
              if (*a8 < v21) {
                return 4294967293LL;
              }
              *a7 = *a1;
              size_t v17 = strnlen(__s1, 0x81uLL);
              if (v17 > 0x80)
              {
                return 4294967293LL;
              }

              else
              {
                size_t v18 = v17;
                memcpy(a7 + 1, __s1, v17 + 1);
                uint64_t v19 = (char *)a7 + v18;
                v19[17] = a3;
                *(_DWORD *)(v19 + 1_Block_object_dispose(va, 8) = v15;
                size_t v20 = v18 + 22;
                uint64_t result = sub_10008619C((uint64_t)a5, a6, (uint64_t)a7, (uint64_t *)&v20);
                if (!(_DWORD)result) {
                  *a8 = v20;
                }
              }
            }
          }
        }
      }
    }
  }

  return result;
}

uint64_t sub_10008619C(uint64_t a1, int a2, uint64_t a3, uint64_t *a4)
{
  LODWORD(v6) = a2;
  unsigned int v8 = 70;
  uint64_t v9 = 4294967293LL;
  if (a3 && a4)
  {
    uint64_t v10 = *a4;
    *(_DWORD *)(a3 + v10) = v6;
    uint64_t v11 = v10 + 4;
    if ((_DWORD)v6)
    {
      uint64_t v6 = v6;
      while (1)
      {
        *(_OWORD *)__src = *(_OWORD *)a1;
        size_t __n = *(void *)(a1 + 16);
        uint64_t v12 = sub_100088DC0(__src);
        if ((_DWORD)v12) {
          break;
        }
        size_t v13 = (_DWORD *)(a3 + v11);
        size_t v14 = __n;
        *size_t v13 = __src[0];
        v13[1] = v14;
        v11 += 8LL;
        if ((_DWORD)v14)
        {
          memcpy((void *)(a3 + v11), __src[1], v14);
          v11 += v14;
        }

        a1 += 24LL;
        if (!--v6) {
          goto LABEL_11;
        }
      }

      uint64_t v9 = v12;
      unsigned int v8 = 70;
    }

    else
    {
LABEL_11:
      uint64_t v9 = 0LL;
      *a4 = v11;
      unsigned int v8 = 10;
    }
  }

  return v9;
}

uint64_t DeserializeVerifyPolicy( uint64_t a1, unint64_t a2, _OWORD *a3, void *a4, BOOL *a5, _DWORD *a6, void *a7, _DWORD *a8)
{
  unsigned int v28 = 0LL;
  unsigned int v27 = 0;
  uint64_t v8 = 4294967293LL;
  unint64_t v9 = a2 - 16;
  if (a2 >= 0x10 && a1 && a3 && a4 && a5 && a6 && a7 && a8)
  {
    *a3 = *(_OWORD *)a1;
    unint64_t v17 = strnlen((const char *)(a1 + 16), a2 - 16);
    if (v17 > 0x80 || v9 <= v17) {
      return 4294967293LL;
    }
    uint64_t v26 = a4;
    unint64_t v18 = v17 + 1;
    uint64_t v19 = acm_mem_alloc_data(v17 + 1);
    acm_mem_alloc_info( "<data>",  v19,  v17 + 1,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibSerialization.c",  349,  "DeserializeVerifyPolicy");
    if (!v19) {
      return 4294967292LL;
    }
    memcpy(v19, (const void *)(a1 + 16), v17 + 1);
    unint64_t v29 = v17 + 17;
    if (v17 + 17 == a2 || (size_t v20 = a5, v21 = *(_BYTE *)(a1 + v17 + 17) != 0, v29 = v17 + 18, a2 - (v17 + 18) < 4))
    {
      uint64_t v8 = 4294967293LL;
    }

    else
    {
      unint64_t v25 = v17 + 1;
      int v22 = a8;
      int v23 = *(_DWORD *)(a1 + v17 + 18);
      unint64_t v29 = v17 + 22;
      uint64_t v8 = sub_1000864D4(a1, a2, &v29, &v28, &v27);
      if (!(_DWORD)v8)
      {
        *uint64_t v26 = v19;
        *size_t v20 = v21;
        *a6 = v23;
        *a7 = v28;
        *int v22 = v27;
        return v8;
      }

      unint64_t v18 = v25;
    }

    acm_mem_free_info( "<data>",  v19,  v18,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibSerialization.c",  378,  "DeserializeVerifyPolicy");
    acm_mem_free_data(v19, v18);
    if (v28) {
      Util_SafeDeallocParameters(v28, v27);
    }
  }

  return v8;
}

uint64_t sub_1000864D4(uint64_t a1, unint64_t a2, unint64_t *a3, void *a4, _DWORD *a5)
{
  p_name = &OBJC_PROTOCOL___UMMobileKeyBagProviding.name;
  unsigned int v11 = 70;
  uint64_t v12 = 4294967293LL;
  if (!a1 || !a3 || !a4 || !a5) {
    goto LABEL_25;
  }
  unint64_t v13 = *a3;
  if (a2 <= *a3)
  {
    LODWORD(v14) = 0;
LABEL_23:
    uint64_t v16 = 0LL;
LABEL_24:
    uint64_t v12 = 0LL;
    *a4 = v16;
    *a5 = v14;
    unsigned int v11 = 10;
    *a3 = v13;
    goto LABEL_25;
  }

  if (a2 - *a3 < 4 || (uint64_t v14 = *(unsigned int *)(a1 + v13), v14 > 0xA))
  {
    unsigned int v11 = 70;
    uint64_t v12 = 4294967293LL;
    goto LABEL_25;
  }

  v13 += 4LL;
  if (!(_DWORD)v14) {
    goto LABEL_23;
  }
  int v27 = v14;
  uint64_t v15 = 24 * v14;
  uint64_t v16 = (char *)acm_mem_alloc(24 * v14);
  acm_mem_alloc_info( "array of ACMParameter",  v16,  v15,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibSerialization.c",  194,  "deserializeParameters");
  if (!v16)
  {
    unsigned int v11 = 70;
    uint64_t v12 = 4294967292LL;
    goto LABEL_25;
  }

  unsigned int v24 = a4;
  unint64_t v25 = a5;
  uint64_t v26 = a3;
  uint64_t v17 = 0LL;
  while (1)
  {
    unint64_t v18 = &v16[v17];
    *(void *)&v16[v17 + 8] = 0LL;
    if (a2 - v13 < 8
      || (*(_DWORD *)unint64_t v18 = *(_DWORD *)(a1 + v13), a2 - (v13 + 4) < 4)
      || (uint64_t v19 = &v16[v17],
          size_t v20 = *(unsigned int *)(a1 + v13 + 4),
          *(_DWORD *)&v16[v17 + 16] = v20,
          v13 += 8LL,
          a2 - v13 < v20))
    {
      unsigned int v11 = 70;
      uint64_t v12 = 4294967293LL;
      goto LABEL_31;
    }

    uint64_t v21 = sub_100088DC0(&v16[v17]);
    if ((_DWORD)v21)
    {
      uint64_t v12 = v21;
      unsigned int v11 = 70;
      goto LABEL_31;
    }

    if ((_DWORD)v20) {
      break;
    }
LABEL_20:
    v17 += 24LL;
    if (v15 == v17)
    {
      p_name = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
      a5 = v25;
      a3 = v26;
      a4 = v24;
      LODWORD(v14) = v27;
      goto LABEL_24;
    }
  }

  int v22 = acm_mem_alloc_data(v20);
  acm_mem_alloc_info( "<data>",  v22,  v20,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibSerialization.c",  212,  "deserializeParameters");
  *((void *)v18 + 1) = v22;
  if (v22)
  {
    memcpy(v22, (const void *)(a1 + v13), *((unsigned int *)v19 + 4));
    v13 += *((unsigned int *)v19 + 4);
    goto LABEL_20;
  }

  unsigned int v11 = 70;
  uint64_t v12 = 4294967292LL;
LABEL_31:
  p_name = (char **)(&OBJC_PROTOCOL___UMMobileKeyBagProviding + 8);
LABEL_25:
  return v12;
}

uint64_t GetSerializedVerifyAclConstraintSize( int a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, unsigned int a6, uint64_t a7, uint64_t a8, _DWORD *a9, unsigned int a10, void *a11)
{
  unsigned int v18 = 0;
  uint64_t result = 4294967293LL;
  if (a3)
  {
    if (a11)
    {
      if (a10 <= 0xA && (a9 != 0LL) == (a10 != 0))
      {
        uint64_t result = sub_100085F74(a9, a10, &v18);
        if (!(_DWORD)result)
        {
          uint64_t v15 = 29LL;
          if (a1 == 32) {
            uint64_t v15 = 33LL;
          }
          uint64_t v16 = v15 + a4;
          if (a1 == 32) {
            uint64_t v17 = a6;
          }
          else {
            uint64_t v17 = 0LL;
          }
          *a11 = v16 + v17 + v18;
        }
      }
    }
  }

  return result;
}

uint64_t SerializeVerifyAclConstraint( int a1, _OWORD *a2, const void *a3, unsigned int a4, const void *a5, unsigned int a6, char a7, int a8, _DWORD *a9, unsigned int a10, uint64_t a11, void *a12)
{
  if (!a3) {
    return 4294967293LL;
  }
  uint64_t result = 4294967293LL;
  if (a12) {
    BOOL v14 = a11 == 0;
  }
  else {
    BOOL v14 = 1;
  }
  if (!v14 && a10 <= 0xA && (a9 != 0LL) == (a10 != 0))
  {
    unsigned int v31 = 0;
    uint64_t result = sub_100085F74(a9, a10, &v31);
    if (!(_DWORD)result)
    {
      uint64_t v21 = 29LL;
      if (a1 == 32) {
        uint64_t v21 = 33LL;
      }
      uint64_t v22 = v21 + a4;
      if (a1 == 32) {
        uint64_t v23 = a6;
      }
      else {
        uint64_t v23 = 0LL;
      }
      if (*a12 < v22 + v23 + (unint64_t)v31)
      {
        return 4294967293LL;
      }

      else
      {
        int v28 = a8;
        if (a2)
        {
          *(_OWORD *)a11 = *a2;
        }

        else
        {
          *(void *)a11 = 0LL;
          *(void *)(a11 + _Block_object_dispose(va, 8) = 0LL;
        }

        *(_DWORD *)(a11 + 16) = a4;
        memcpy((void *)(a11 + 20), a3, a4);
        uint64_t v24 = a4 + 20LL;
        if (a1 == 32)
        {
          *(_DWORD *)(a11 + v24) = a6;
          uint64_t v25 = a4 + 24LL;
          memcpy((void *)(a11 + v25), a5, a6);
          uint64_t v24 = v25 + a6;
        }

        uint64_t v26 = a11 + v24;
        *(_BYTE *)uint64_t v26 = a7;
        *(_DWORD *)(v26 + 1) = v28;
        uint64_t v30 = v24 + 5;
        uint64_t result = sub_10008619C((uint64_t)a9, a10, a11, &v30);
        if (!(_DWORD)result) {
          *a12 = v30;
        }
      }
    }
  }

  return result;
}

uint64_t DeserializeVerifyAclConstraint( int a1, uint64_t a2, unsigned int a3, _OWORD *a4, void *a5, _DWORD *a6, size_t *a7, _DWORD *a8, BOOL *a9, _DWORD *a10, void *a11, _DWORD *a12)
{
  __int16 v33 = 0LL;
  unint64_t v34 = 0LL;
  unsigned int v32 = 0;
  uint64_t v12 = 4294967293LL;
  if (a2 && a4 && a5 && a6 && a9 && a10 && a11 && a12 && a3 >= 0x10)
  {
    unint64_t v16 = a3;
    *a4 = *(_OWORD *)a2;
    unint64_t v34 = 16LL;
    if ((a3 & 0xFFFFFFFC) == 0x10LL)
    {
      uint64_t v12 = 4294967293LL;
    }

    else
    {
      unint64_t v20 = *(unsigned int *)(a2 + 16);
      unint64_t v34 = 20LL;
      uint64_t v21 = acm_mem_alloc_data(v20);
      acm_mem_alloc_info( "<data>",  v21,  v20,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibSerialization.c",  532,  "DeserializeVerifyAclConstraint");
      if (v21)
      {
        if (v16 - 20 < v20) {
          goto LABEL_24;
        }
        memcpy(v21, (const void *)(a2 + 20), v20);
        unint64_t v22 = v20 + 20;
        unint64_t v34 = v20 + 20;
        unsigned int v31 = a5;
        if (a1 != 32)
        {
          uint64_t v25 = 0LL;
          LODWORD(v23) = 0;
          goto LABEL_19;
        }

        if (v16 - v22 < 4)
        {
LABEL_24:
          uint64_t v25 = 0LL;
          LODWORD(v23) = 0;
        }

        else
        {
          size_t v23 = *(unsigned int *)(a2 + v22);
          unint64_t v24 = v20 + 24;
          unint64_t v34 = v20 + 24;
          uint64_t v25 = acm_mem_alloc_data(v23);
          acm_mem_alloc_info( "<data>",  v25,  v23,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibSerialization.c",  544,  "DeserializeVerifyAclConstraint");
          if (!v25)
          {
            uint64_t v12 = 4294967292LL;
LABEL_26:
            acm_mem_free_info( "<data>",  v21,  v20,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibSerialization.c",  580,  "DeserializeVerifyAclConstraint");
            acm_mem_free_data(v21, v20);
            if (v25)
            {
              acm_mem_free_info( "<data>",  v25,  v23,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibSerialization.c",  583,  "DeserializeVerifyAclConstraint");
              acm_mem_free_data(v25, v23);
            }

            goto LABEL_30;
          }

          if (v16 - v24 >= v23)
          {
            memcpy(v25, (const void *)(a2 + v24), v23);
            unint64_t v22 = v24 + v23;
            unint64_t v34 = v24 + v23;
LABEL_19:
            if (v22 != v16)
            {
              BOOL v26 = *(_BYTE *)(a2 + v22) != 0;
              unint64_t v34 = v22 + 1;
              if (v16 - (v22 + 1) >= 4)
              {
                unint64_t v30 = v20;
                int v27 = v23;
                size_t v23 = (size_t)v25;
                int v28 = *(_DWORD *)(a2 + v22 + 1);
                unint64_t v34 = v22 + 5;
                uint64_t v12 = sub_1000864D4(a2, v16, &v34, &v33, &v32);
                if (!(_DWORD)v12)
                {
                  void *v31 = v21;
                  *a7 = v23;
                  *a8 = v27;
                  *a6 = v30;
                  *a9 = v26;
                  *a10 = v28;
                  *a11 = v33;
                  *a12 = v32;
                  return v12;
                }

                uint64_t v25 = (void *)v23;
                LODWORD(v23) = v27;
                unint64_t v20 = v30;
                goto LABEL_26;
              }
            }
          }
        }

        uint64_t v12 = 4294967293LL;
        goto LABEL_26;
      }

      uint64_t v12 = 4294967292LL;
    }
  }

uint64_t GetSerializedProcessAclSize( uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, unsigned int a5, uint64_t a6, _DWORD *a7, unsigned int a8, void *a9)
{
  unsigned int v12 = 0;
  uint64_t result = 4294967293LL;
  if (a2 && a3 && a9 && a8 <= 0xA && (a7 != 0LL) == (a8 != 0))
  {
    uint64_t result = sub_100085F74(a7, a8, &v12);
    if (!(_DWORD)result) {
      *a9 = a3 + (unint64_t)a5 + v12 + 36;
    }
  }

  return result;
}

uint64_t SerializeProcessAcl( _OWORD *a1, const void *a2, unsigned int a3, const void *a4, unsigned int a5, uint64_t a6, _DWORD *a7, unsigned int a8, uint64_t a9, unint64_t *a10)
{
  unint64_t v23 = 0LL;
  uint64_t result = 4294967293LL;
  if (a2 && a3)
  {
    BOOL v15 = !a10 || a9 == 0;
    if (!v15 && a8 <= 0xA && (a7 != 0LL) == (a8 != 0))
    {
      int v17 = a6;
      uint64_t result = GetSerializedProcessAclSize(4294967293LL, (uint64_t)a2, a3, (uint64_t)a4, a5, a6, a7, a8, &v23);
      if (!(_DWORD)result)
      {
        if (*a10 < v23)
        {
          return 4294967293LL;
        }

        else
        {
          if (a1)
          {
            *(_OWORD *)a9 = *a1;
          }

          else
          {
            *(void *)a9 = 0LL;
            *(void *)(a9 + _Block_object_dispose(va, 8) = 0LL;
          }

          *(_DWORD *)(a9 + 16) = a3;
          memcpy((void *)(a9 + 20), a2, a3);
          *(_DWORD *)(a9 + a3 + 20) = a5;
          uint64_t v21 = a3 + 24LL;
          if (a5)
          {
            memcpy((void *)(a9 + v21), a4, a5);
            v21 += a5;
          }

          *(_DWORD *)(a9 + v21) = v17;
          unint64_t v22 = v21 + 4;
          uint64_t result = sub_10008619C((uint64_t)a7, a8, a9, (uint64_t *)&v22);
          if (!(_DWORD)result) {
            *a10 = v22;
          }
        }
      }
    }
  }

  return result;
}

uint64_t DeserializeProcessAcl( uint64_t a1, unsigned int a2, _OWORD *a3, void *a4, _DWORD *a5, void *a6, unsigned int *a7, _DWORD *a8, void *a9, _DWORD *a10)
{
  uint64_t v39 = 0LL;
  unint64_t v40 = 0LL;
  unsigned int v38 = 0;
  uint64_t v10 = 4294967293LL;
  if (a1)
  {
    if (a3)
    {
      unsigned int v11 = a4;
      if (a4)
      {
        unsigned int v12 = a5;
        if (a5)
        {
          unint64_t v13 = a6;
          if (a6)
          {
            BOOL v14 = a7;
            if (a7)
            {
              BOOL v15 = a8;
              if (a8)
              {
                if (a9 && a10 && a2 >= 0x10)
                {
                  unint64_t v17 = a2;
                  *a3 = *(_OWORD *)a1;
                  unint64_t v40 = 16LL;
                  if ((a2 & 0xFFFFFFFC) == 0x10LL)
                  {
                    uint64_t v10 = 4294967293LL;
                  }

                  else
                  {
                    unint64_t v18 = *(unsigned int *)(a1 + 16);
                    unint64_t v40 = 20LL;
                    uint64_t v19 = acm_mem_alloc_data(v18);
                    acm_mem_alloc_info( "<data>",  v19,  v18,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibSerialization.c",  722,  "DeserializeProcessAcl");
                    if (v19)
                    {
                      if (v17 - 20 < v18
                        || (memcpy(v19, (const void *)(a1 + 20), v18), unint64_t v40 = v18 + 20, v17 - (v18 + 20) < 4))
                      {
                        unsigned int v32 = 0LL;
                        unsigned int v37 = 0;
                        uint64_t v10 = 4294967293LL;
                      }

                      else
                      {
                        size_t v20 = *(unsigned int *)(a1 + v18 + 20);
                        unint64_t v21 = v18 + 24;
                        unint64_t v40 = v18 + 24;
                        unsigned int v37 = v20;
                        if (!(_DWORD)v20)
                        {
                          unsigned int v36 = 0LL;
                          goto LABEL_20;
                        }

                        __int16 v33 = v12;
                        unint64_t v34 = v11;
                        unint64_t v22 = v13;
                        unint64_t v23 = v14;
                        unint64_t v24 = v15;
                        size_t v25 = v20;
                        BOOL v26 = acm_mem_alloc_data(v20);
                        acm_mem_alloc_info( "<data>",  v26,  v25,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibSerialization.c",  734,  "DeserializeProcessAcl");
                        if (v26)
                        {
                          int v27 = v26;
                          unsigned int v11 = v34;
                          if (v17 - v21 >= v25)
                          {
                            unsigned int v36 = v27;
                            memcpy(v27, (const void *)(a1 + v21), v25);
                            v21 += v25;
                            unint64_t v40 = v21;
                            BOOL v15 = v24;
                            BOOL v14 = v23;
                            unint64_t v13 = v22;
                            unsigned int v12 = v33;
LABEL_20:
                            if (v17 - v21 < 4)
                            {
                              uint64_t v10 = 4294967293LL;
                            }

                            else
                            {
                              unint64_t v35 = v18;
                              int v28 = v19;
                              unint64_t v29 = v15;
                              int v30 = *(_DWORD *)(a1 + v21);
                              unint64_t v40 = v21 + 4;
                              uint64_t v10 = sub_1000864D4(a1, v17, &v40, &v39, &v38);
                              if (!(_DWORD)v10)
                              {
                                void *v11 = v28;
                                *unsigned int v12 = v35;
                                *unint64_t v13 = v36;
                                unsigned int *v14 = v37;
                                *unint64_t v29 = v30;
                                *a9 = v39;
                                *a10 = v38;
                                return v10;
                              }

                              uint64_t v19 = v28;
                              unint64_t v18 = v35;
                            }

                            unsigned int v32 = v36;
                            goto LABEL_32;
                          }

                          uint64_t v10 = 4294967293LL;
                          unsigned int v32 = v27;
                        }

                        else
                        {
                          unsigned int v32 = 0LL;
                          uint64_t v10 = 4294967292LL;
                        }
                      }

uint64_t GetSerializedRequirementSize(_DWORD *a1, uint64_t *a2)
{
  uint64_t v12 = 0LL;
  uint64_t result = 4294967293LL;
  if (!a1) {
    return result;
  }
  if (!a2) {
    return result;
  }
  int v5 = *a1;
  if (*a1 > 0x1Cu) {
    return result;
  }
  if (((1 << v5) & 0x1FFCFF4E) != 0)
  {
    uint64_t result = 0LL;
    *a2 = a1[3] + 16LL;
    return result;
  }

  if (((1 << v5) & 0x30) == 0)
  {
    if (v5 != 7) {
      return result;
    }
    *a2 = 24LL;
    uint64_t v9 = a1[5];
    if ((_DWORD)v9)
    {
      uint64_t v10 = a1 + 6;
      uint64_t v11 = 24LL;
      do
      {
        uint64_t result = GetSerializedRequirementSize(*v10, &v12);
        if ((_DWORD)result) {
          break;
        }
        v11 += v12;
        *a2 = v11;
        ++v10;
        --v9;
      }

      while (v9);
      return result;
    }

    return 0LL;
  }

  *a2 = 20LL;
  uint64_t v6 = a1[4];
  if (!(_DWORD)v6) {
    return 0LL;
  }
  uint64_t v7 = a1 + 5;
  uint64_t v8 = 20LL;
  while (1)
  {
    uint64_t result = GetSerializedRequirementSize(*v7, &v12);
    if ((_DWORD)result) {
      break;
    }
    v8 += v12;
    *a2 = v8;
    ++v7;
    if (!--v6) {
      return 0LL;
    }
  }

  return result;
}

uint64_t SerializeRequirement(_DWORD *a1, _OWORD *a2, uint64_t *a3)
{
  unint64_t v12 = 0LL;
  uint64_t result = 4294967293LL;
  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        uint64_t result = GetSerializedRequirementSize(a1, (uint64_t *)&v12);
        if (!(_DWORD)result)
        {
          if (v12 > *a3) {
            return 4294967293LL;
          }
          *a2 = *(_OWORD *)a1;
          int v7 = *a1;
          uint64_t result = 4294967293LL;
          if (*a1 <= 0x1Cu)
          {
            if (((1 << v7) & 0x1FFCFF4E) != 0)
            {
              memcpy(a2 + 1, a1 + 4, a1[3]);
              uint64_t v8 = a1[3] + 16LL;
LABEL_9:
              uint64_t result = 0LL;
              *a3 = v8;
              return result;
            }

            if (((1 << v7) & 0x30) != 0)
            {
              *((_DWORD *)a2 + 4) = a1[4];
              if (!a1[4])
              {
                uint64_t v8 = 20LL;
                goto LABEL_9;
              }

              uint64_t v9 = 0LL;
              uint64_t v8 = 20LL;
              while (1)
              {
                uint64_t v11 = *a3 - v8;
                uint64_t result = SerializeRequirement(*(void *)&a1[2 * v9 + 5], (char *)a2 + v8, &v11);
                if ((_DWORD)result) {
                  break;
                }
                v8 += v11;
              }
            }

            else if (v7 == 7)
            {
              *((void *)a2 + 2) = *((void *)a1 + 2);
              if (!a1[5])
              {
                uint64_t v8 = 24LL;
                goto LABEL_9;
              }

              uint64_t v10 = 0LL;
              uint64_t v8 = 24LL;
              while (1)
              {
                uint64_t v11 = *a3 - v8;
                uint64_t result = SerializeRequirement(*(void *)&a1[2 * v10 + 6], (char *)a2 + v8, &v11);
                if ((_DWORD)result) {
                  break;
                }
                v8 += v11;
              }
            }
          }
        }
      }
    }
  }

  return result;
}

uint64_t DeserializeRequirement(unsigned int *a1, unint64_t a2, void **a3, size_t *a4)
{
  __int dst = 0LL;
  uint64_t v4 = 4294967293LL;
  if (a1)
  {
    if (a2 >= 0x10)
    {
      if (a3)
      {
        if (a4)
        {
          unsigned int v9 = *a1;
          if (v9 <= 0x1C)
          {
            if (((1 << v9) & 0x1FFCFF4E) != 0)
            {
              size_t v10 = a1[3] + 16LL;
              if (v10 > a2) {
                goto LABEL_36;
              }
              uint64_t v11 = Util_AllocRequirement(v9, 0LL, &__dst);
              if (!(_DWORD)v11)
              {
                if (__dst)
                {
                  memcpy(__dst, a1, v10);
LABEL_11:
                  uint64_t v4 = 0LL;
                  *a4 = v10;
                  *a3 = __dst;
                  return v4;
                }

                return 4294967292LL;
              }

              goto LABEL_35;
            }

            if (((1 << v9) & 0x30) != 0)
            {
              uint64_t v13 = a1[4];
              if (8 * v13 + 20 > a2) {
                goto LABEL_36;
              }
              uint64_t v11 = Util_AllocRequirement(v9, v13, &__dst);
              if ((_DWORD)v11) {
                goto LABEL_35;
              }
              BOOL v14 = __dst;
              if (!__dst) {
                return 4294967292LL;
              }
              if (*((_DWORD *)__dst + 3) == 84)
              {
                __int128 v15 = *(_OWORD *)a1;
                *((_DWORD *)__dst + 4) = a1[4];
                _OWORD *v14 = v15;
                *((_DWORD *)__dst + 3) = 84;
                if (!a1[4])
                {
                  size_t v10 = 20LL;
                  goto LABEL_11;
                }

                uint64_t v16 = 0LL;
                size_t v10 = 20LL;
                while (1)
                {
                  uint64_t v21 = 0LL;
                  uint64_t v22 = 0LL;
                  uint64_t v11 = DeserializeRequirement((char *)a1 + v10, a2 - v10, &v22, &v21);
                  if ((_DWORD)v11) {
                    goto LABEL_35;
                  }
                  *(void *)((char *)__dst + 8 * v16 + 20) = v22;
                  v10 += v21;
                }
              }

              goto LABEL_39;
            }

            if (v9 == 7)
            {
              uint64_t v17 = a1[5];
              if (8 * v17 + 24 <= a2)
              {
                uint64_t v11 = Util_AllocRequirement(7, v17, &__dst);
                if (!(_DWORD)v11)
                {
                  unint64_t v18 = __dst;
                  if (!__dst) {
                    return 4294967292LL;
                  }
                  if (*((_DWORD *)__dst + 3) != 88)
                  {
LABEL_39:
                    uint64_t v4 = 4294967291LL;
                    goto LABEL_36;
                  }

                  __int128 v19 = *(_OWORD *)a1;
                  *((void *)__dst + 2) = *((void *)a1 + 2);
                  _OWORD *v18 = v19;
                  *((_DWORD *)__dst + 3) = 88;
                  if (!a1[5])
                  {
                    size_t v10 = 24LL;
                    goto LABEL_11;
                  }

                  uint64_t v20 = 0LL;
                  size_t v10 = 24LL;
                  while (1)
                  {
                    uint64_t v21 = 0LL;
                    uint64_t v22 = 0LL;
                    uint64_t v11 = DeserializeRequirement((char *)a1 + v10, a2 - v10, &v22, &v21);
                    if ((_DWORD)v11) {
                      break;
                    }
                    *((void *)__dst + v20 + 3) = v22;
                    v10 += v21;
                  }
                }

uint64_t GetSerializedCredentialSize(_DWORD *a1, void *a2)
{
  uint64_t result = 4294967293LL;
  if (a1 && a2 && *a1 <= 0x17u && ((1 << *a1) & 0xFFF7FE) != 0)
  {
    uint64_t result = 0LL;
    *a2 = a1[7] + 32LL;
  }

  return result;
}

uint64_t SerializeCredential(unsigned int *__src, void *__dst, size_t *a3)
{
  uint64_t result = 4294967293LL;
  if (__src && __dst && a3)
  {
    unsigned int v6 = *__src;
    if (*__src <= 0x17 && ((1 << *__src) & 0xFFF7FE) != 0)
    {
      size_t v8 = __src[7] + 32LL;
      if (v8 <= *a3 && v6 <= 0x17 && ((1 << v6) & 0xFFF7FE) != 0)
      {
        memcpy(__dst, __src, v8);
        uint64_t result = 0LL;
        *a3 = __src[7] + 32LL;
      }
    }
  }

  return result;
}

uint64_t DeserializeCredential(unsigned int *a1, unint64_t a2, void **a3, void *a4)
{
  __int dst = 0LL;
  uint64_t v4 = 4294967293LL;
  if (a2 >= 0x20 && a1 && a3 && a4)
  {
    unsigned int v8 = *a1;
    uint64_t v10 = a1[7];
    switch(*a1)
    {
      case 1u:
        if ((_DWORD)v10 == 28) {
          goto LABEL_7;
        }
        return v4;
      case 2u:
        if ((_DWORD)v10 == 136) {
          goto LABEL_7;
        }
        return v4;
      case 3u:
        if ((_DWORD)v10 == 305) {
          goto LABEL_7;
        }
        return v4;
      case 4u:
      case 5u:
      case 6u:
      case 8u:
      case 0xEu:
      case 0x10u:
      case 0x13u:
      case 0x16u:
      case 0x17u:
        if (!(_DWORD)v10) {
          goto LABEL_7;
        }
        return v4;
      case 7u:
        if ((_DWORD)v10 == 56) {
          goto LABEL_7;
        }
        return v4;
      case 9u:
        if ((_DWORD)v10 == 24) {
          goto LABEL_7;
        }
        return v4;
      case 0xAu:
        if ((_DWORD)v10 == 52) {
          goto LABEL_7;
        }
        return v4;
      case 0xCu:
      case 0xFu:
        if ((_DWORD)v10 == 8) {
          goto LABEL_7;
        }
        return v4;
      case 0xDu:
      case 0x15u:
        if ((_DWORD)v10 == 132) {
          goto LABEL_7;
        }
        return v4;
      case 0x11u:
        if ((_DWORD)v10 == 81) {
          goto LABEL_7;
        }
        return v4;
      case 0x12u:
        if ((_DWORD)v10 == 20) {
          goto LABEL_7;
        }
        return v4;
      case 0x14u:
        if ((_DWORD)v10 != 32) {
          return v4;
        }
LABEL_7:
        uint64_t v4 = Util_AllocCredential(*a1, &__dst);
        if ((_DWORD)v4)
        {
          if (__dst)
          {
LABEL_16:
            Util_DeallocCredential(__dst);
            return v4;
          }
        }

        else
        {
          if (__dst)
          {
            if (*((_DWORD *)__dst + 1) > 3u || *((_DWORD *)__dst + 2) > 0x50u)
            {
              uint64_t v4 = 4294967293LL;
            }

            else
            {
              uint64_t v4 = 4294967293LL;
              if (v8 <= 0x17 && ((1 << v8) & 0xFFF7FE) != 0 && v10 + 32 <= a2)
              {
                memcpy(__dst, a1, v10 + 32);
                uint64_t v4 = 0LL;
                *a3 = __dst;
                *a4 = v10 + 32;
                return v4;
              }
            }

            goto LABEL_16;
          }

          uint64_t v4 = 4294967292LL;
        }

        break;
      default:
        return v4;
    }
  }

  return v4;
}

uint64_t CopyCredential(uint64_t a1, void **a2)
{
  __int dst = 0LL;
  uint64_t v2 = 4294967293LL;
  if (a1 && a2)
  {
    uint64_t v2 = Util_AllocCredential(*(_DWORD *)a1, &__dst);
    if ((_DWORD)v2)
    {
      if (__dst) {
        Util_DeallocCredential(__dst);
      }
    }

    else if (__dst)
    {
      memcpy(__dst, (const void *)a1, *(unsigned int *)(a1 + 28) + 32LL);
      uint64_t v2 = 0LL;
      *a2 = __dst;
    }

    else
    {
      return 4294967292LL;
    }
  }

  return v2;
}

uint64_t CompareCredentials(void *__s1, void *__s2, _BYTE *a3)
{
  uint64_t v3 = 4294967293LL;
  if (__s1)
  {
    uint64_t v4 = __s2;
    if (__s2)
    {
      if (a3)
      {
        unsigned int v6 = __s1;
        if (*(_DWORD *)__s1 == *(_DWORD *)__s2)
        {
          uint64_t v7 = *((unsigned int *)__s1 + 7);
          if ((_DWORD)v7 == *((_DWORD *)__s2 + 7))
          {
            uint64_t v3 = 4294967293LL;
            switch(*(_DWORD *)__s1)
            {
              case 1:
                if (*__s1 != *__s2 || __s1[1] != __s2[1] || __s1[2] != __s2[2] || __s1[3] != __s2[3]) {
                  break;
                }
                uint64_t v13 = (char *)__s1 + 44;
                BOOL v14 = (char *)__s2 + 44;
                goto LABEL_74;
              case 2:
                if (*((_DWORD *)__s1 + 8) != *((_DWORD *)__s2 + 8)) {
                  break;
                }
                size_t v8 = *((unsigned int *)__s1 + 9);
                if ((_DWORD)v8 != *((_DWORD *)__s2 + 9)) {
                  break;
                }
                __s2 += 5;
                __s1 += 5;
                goto LABEL_8;
              case 3:
                if (*__s1 != *__s2 || __s1[1] != __s2[1] || __s1[2] != __s2[2] || __s1[3] != __s2[3]) {
                  break;
                }
                uint64_t v13 = (char *)(__s1 + 13);
                BOOL v14 = (char *)(__s2 + 13);
                goto LABEL_74;
              case 4:
              case 5:
              case 6:
              case 8:
              case 0xC:
              case 0xE:
              case 0xF:
              case 0x10:
              case 0x11:
              case 0x12:
              case 0x13:
              case 0x16:
              case 0x17:
                size_t v8 = v7 + 32;
                goto LABEL_8;
              case 7:
                if (*__s1 != *__s2 || __s1[1] != __s2[1] || __s1[2] != __s2[2] || __s1[3] != __s2[3]) {
                  break;
                }
                BOOL v9 = sub_100087C64((unint64_t)(__s1 + 4), 0x20uLL, (unint64_t)(__s2 + 4), 32LL);
                if (!v9) {
                  goto LABEL_100;
                }
                uint64_t v13 = (char *)(v6 + 8);
                BOOL v14 = (char *)(v4 + 8);
                size_t v21 = 24LL;
                uint64_t v22 = 24LL;
                goto LABEL_103;
              case 9:
                if (*__s1 != *__s2 || __s1[1] != __s2[1] || __s1[2] != __s2[2] || __s1[3] != __s2[3]) {
                  break;
                }
                uint64_t v13 = (char *)(__s1 + 5);
                BOOL v14 = (char *)(__s2 + 5);
                goto LABEL_74;
              case 0xA:
                if (*__s1 != *__s2 || __s1[1] != __s2[1] || __s1[2] != __s2[2] || __s1[3] != __s2[3]) {
                  break;
                }
                BOOL v9 = sub_100087C64((unint64_t)__s1 + 36, 0x10uLL, (unint64_t)__s2 + 36, 16LL);
                if (!v9) {
                  goto LABEL_100;
                }
                uint64_t v13 = (char *)v6 + 52;
                BOOL v14 = (char *)v4 + 52;
LABEL_74:
                size_t v21 = 16LL;
                uint64_t v22 = 16LL;
                goto LABEL_103;
              case 0xD:
                size_t v8 = *((unsigned int *)__s1 + 8);
                if ((_DWORD)v8 != *((_DWORD *)__s2 + 8)) {
                  break;
                }
                __s2 = (void *)((char *)__s2 + 36);
                __s1 = (void *)((char *)__s1 + 36);
LABEL_8:
                LOBYTE(v9) = memcmp(__s1, __s2, v8) == 0;
                goto LABEL_100;
              case 0x14:
                if (*__s1 != *__s2 || __s1[1] != __s2[1] || __s1[2] != __s2[2] || __s1[3] != __s2[3]) {
                  break;
                }
                BOOL v14 = (char *)(__s2 + 4);
                uint64_t v13 = (char *)(__s1 + 4);
                size_t v21 = 32LL;
                uint64_t v22 = 32LL;
                goto LABEL_103;
              case 0x15:
                if (*__s1 != *__s2 || __s1[1] != __s2[1] || __s1[2] != __s2[2] || __s1[3] != __s2[3]) {
                  break;
                }
                uint64_t v13 = (char *)__s1 + 36;
                BOOL v14 = (char *)__s2 + 36;
                size_t v21 = 128LL;
                uint64_t v22 = 128LL;
LABEL_103:
                LOBYTE(v9) = sub_100087C64((unint64_t)v13, v21, (unint64_t)v14, v22);
                goto LABEL_100;
              default:
                return v3;
            }
          }
        }

        LOBYTE(v9) = 0;
LABEL_100:
        uint64_t v3 = 0LL;
        *a3 = v9;
      }
    }
  }

  return v3;
}

BOOL sub_100087C64(unint64_t __s1, size_t __n, unint64_t __s2, uint64_t a4)
{
  if (__n != a4) {
    return 0LL;
  }
  if (!(__s1 | __s2)) {
    return 1LL;
  }
  BOOL result = 0LL;
  BOOL v6 = __s1 == 0;
  if (__s2)
  {
    BOOL v7 = 1;
  }

  else
  {
    BOOL v6 = 0;
    BOOL v7 = __s1 == 0;
  }

  if (v7 && !v6) {
    return memcmp((const void *)__s1, (const void *)__s2, __n) == 0;
  }
  return result;
}

uint64_t GetSerializedAddCredentialSize(uint64_t a1, _DWORD *a2, int a3, void *a4)
{
  if (a1) {
    BOOL v4 = 1;
  }
  else {
    BOOL v4 = a3 == 2;
  }
  char v5 = !v4;
  uint64_t result = 4294967293LL;
  if (a4 && a2 && (v5 & 1) == 0 && *a2 <= 0x17u && ((1 << *a2) & 0xFFF7FE) != 0)
  {
    uint64_t result = 0LL;
    *a4 = a2[7] + 52LL;
  }

  return result;
}

uint64_t SerializeAddCredential(_OWORD *a1, unsigned int *__src, int a3, uint64_t a4, void *a5)
{
  if (a1) {
    BOOL v6 = 1;
  }
  else {
    BOOL v6 = a3 == 2;
  }
  char v7 = !v6;
  uint64_t result = 4294967293LL;
  if (a5)
  {
    if (a4)
    {
      if (__src)
      {
        if ((v7 & 1) == 0)
        {
          uint64_t result = 4294967293LL;
          if (*__src <= 0x17 && ((1 << *__src) & 0xFFF7FE) != 0 && *a5 >= (unint64_t)__src[7] + 52)
          {
            if (a1)
            {
              *(_OWORD *)a4 = *a1;
            }

            else
            {
              *(void *)a4 = 0LL;
              *(void *)(a4 + _Block_object_dispose(va, 8) = 0LL;
            }

            uint64_t v13 = *a5 - 16LL;
            uint64_t result = SerializeCredential(__src, (void *)(a4 + 16), (size_t *)&v13);
            if (!(_DWORD)result)
            {
              size_t v12 = v13;
              *(_DWORD *)(v13 + a4 + 16) = a3;
              *a5 = v12 + 20;
            }
          }
        }
      }
    }
  }

  return result;
}

uint64_t DeserializeAddCredential(uint64_t a1, unint64_t a2, _OWORD *a3, void *a4, _DWORD *a5)
{
  size_t v12 = 0LL;
  uint64_t v13 = 0LL;
  uint64_t v5 = 4294967293LL;
  if (a1 && a2 >= 0x34 && a3 && a4 && a5)
  {
    *a3 = *(_OWORD *)a1;
    uint64_t v10 = DeserializeCredential((unsigned int *)(a1 + 16), a2 - 16, (void **)&v12, &v13);
    if ((_DWORD)v10)
    {
      uint64_t v5 = v10;
    }

    else if (a2 - (v13 + 16) >= 4)
    {
      uint64_t v5 = 0LL;
      *a5 = *(_DWORD *)(a1 + v13 + 16);
      *a4 = v12;
      return v5;
    }
  }

  if (v12) {
    Util_DeallocCredential(v12);
  }
  return v5;
}

uint64_t DeserializeAddCredentialType(uint64_t a1, unint64_t a2, _DWORD *a3)
{
  uint64_t result = 4294967293LL;
  if (a2 >= 0x34 && a1)
  {
    if (a3)
    {
      uint64_t result = 0LL;
      *a3 = *(_DWORD *)(a1 + 16);
    }
  }

  return result;
}

uint64_t GetSerializedRemoveCredentialSize(uint64_t a1, _DWORD *a2, int a3, void *a4)
{
  if (a1) {
    BOOL v4 = 1;
  }
  else {
    BOOL v4 = a3 == 2;
  }
  char v5 = !v4;
  uint64_t result = 4294967293LL;
  if (a4 && a2 && (v5 & 1) == 0 && *a2 <= 0x17u && ((1 << *a2) & 0xFFF7FE) != 0)
  {
    uint64_t result = 0LL;
    *a4 = a2[7] + 52LL;
  }

  return result;
}

uint64_t GetSerializedReplacePassphraseCredentialSize(uint64_t a1, _DWORD *a2, int a3, void *a4)
{
  if (a1) {
    BOOL v4 = 1;
  }
  else {
    BOOL v4 = a3 == 2;
  }
  char v5 = !v4;
  uint64_t result = 4294967293LL;
  if (a4 && a2 && (v5 & 1) == 0 && *a2 <= 0x17u && ((1 << *a2) & 0xFFF7FE) != 0)
  {
    uint64_t result = 0LL;
    *a4 = a2[7] + 52LL;
  }

  return result;
}

uint64_t SerializeCredentialList(unsigned int **a1, unsigned int a2, unsigned int *a3, void *a4)
{
  if (a2) {
    BOOL v6 = a1 == 0LL;
  }
  else {
    BOOL v6 = 0;
  }
  if (v6 || a3 == 0LL || a4 == 0LL) {
    return 4294967293LL;
  }
  v16[7] = v4;
  v16[8] = v5;
  *a3 = a2;
  if (a2)
  {
    uint64_t v11 = a1;
    uint64_t v12 = a2;
    uint64_t v13 = 4LL;
    while (1)
    {
      BOOL v14 = *v11;
      if (!*v11) {
        return 4294967293LL;
      }
      v16[0] = *a4 - v13;
      uint64_t result = SerializeCredential(v14, (char *)a3 + v13, v16);
      if ((_DWORD)result) {
        return result;
      }
      v13 += v16[0];
      ++v11;
      if (!--v12) {
        goto LABEL_18;
      }
    }
  }

  else
  {
    uint64_t v13 = 4LL;
LABEL_18:
    uint64_t result = 0LL;
    *a4 = v13;
  }

  return result;
}

uint64_t DeserializeCredentialList(unsigned int *a1, uint64_t a2, void *a3, _DWORD *a4)
{
  uint64_t v15 = 0LL;
  uint64_t v4 = 4294967293LL;
  if (a1)
  {
    if (a3)
    {
      if (a4)
      {
        uint64_t v8 = *a1;
        if (v8 <= 0x3E8)
        {
          if ((_DWORD)v8)
          {
            uint64_t v10 = (char *)acm_mem_alloc(8 * v8);
            acm_mem_alloc_info( "array of ACMCredentialRef",  v10,  8 * v8,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibSerialization.c",  1778,  "DeserializeCredentialList");
            if (v10)
            {
              uint64_t v11 = 0LL;
              uint64_t v12 = 4LL;
              while (1)
              {
                uint64_t v13 = DeserializeCredential((unsigned int *)((char *)a1 + v12), a2 - v12, (void **)&v10[v11], &v15);
                if ((_DWORD)v13) {
                  break;
                }
                v12 += v15;
                v11 += 8LL;
                if (8 * v8 == v11) {
                  goto LABEL_12;
                }
              }

              uint64_t v4 = v13;
              DeallocCredentialList((_DWORD **)v10, v8);
            }

            else
            {
              return 4294967292LL;
            }
          }

          else
          {
            uint64_t v10 = 0LL;
LABEL_12:
            uint64_t v4 = 0LL;
            *a4 = v8;
            *a3 = v10;
          }
        }
      }
    }
  }

  return v4;
}

void DeallocCredentialList(_DWORD **a1, unsigned int a2)
{
  if (a1)
  {
    uint64_t v3 = a2;
    if (a2)
    {
      uint64_t v4 = a1;
      uint64_t v5 = a2;
      do
      {
        if (*v4)
        {
          Util_DeallocCredential(*v4);
          void *v4 = 0LL;
        }

        ++v4;
        --v5;
      }

      while (v5);
    }

    unint64_t v6 = 8 * v3;
    acm_mem_free_info( "array of ACMCredentialRef",  a1,  v6,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibSerialization.c",  1816,  "DeallocCredentialList");
    acm_mem_free(a1, v6);
  }

uint64_t GetSerializedGetContextPropertySize(uint64_t a1, uint64_t a2, void *a3)
{
  if (!a3) {
    return 4294967293LL;
  }
  uint64_t result = 0LL;
  *a3 = 20LL;
  return result;
}

__n128 SerializeGetContextProperty(__n128 *a1, unsigned __int32 a2, __n128 *a3, void *a4)
{
  if (a1 && a3 && a4 && *a4 >= 0x14uLL)
  {
    __n128 result = *a1;
    *a3 = *a1;
    a3[1].n128_u32[0] = a2;
    *a4 = 20LL;
  }

  return result;
}

uint64_t DeserializeGetContextProperty(uint64_t a1, unint64_t a2, _OWORD *a3, _DWORD *a4)
{
  uint64_t result = 4294967293LL;
  if (a2 >= 0x10 && a1 && a3 && a4)
  {
    *a3 = *(_OWORD *)a1;
    if ((a2 & 0xFFFFFFFFFFFFFFFCLL) != 0x10)
    {
      uint64_t result = 0LL;
      *a4 = *(_DWORD *)(a1 + 16);
    }
  }

  return result;
}

uint64_t LibSer_GetAclAuthMethod_GetSize(uint64_t a1, void *a2)
{
  if (!a2) {
    return 4294967293LL;
  }
  uint64_t result = 0LL;
  *a2 = 16LL;
  return result;
}

__n128 LibSer_GetAclAuthMethod_Serialize(__n128 *a1, __n128 *a2, void *a3)
{
  if (a1 && a2 && a3 && *a3 >= 0x10uLL)
  {
    __n128 result = *a1;
    *a2 = *a1;
    *a3 = 16LL;
  }

  return result;
}

__n128 LibSer_GetAclAuthMethod_Deserialize(__n128 *a1, unint64_t a2, __n128 *a3)
{
  if (a2 >= 0x10 && a1)
  {
    if (a3)
    {
      __n128 result = *a1;
      *a3 = *a1;
    }
  }

  return result;
}

uint64_t LibSer_ContextCredentialGetProperty_GetSize(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (!a4) {
    return 4294967293LL;
  }
  uint64_t result = 0LL;
  *a4 = 24LL;
  return result;
}

__n128 LibSer_ContextCredentialGetProperty_Serialize( __n128 *a1, unsigned __int32 a2, unsigned __int32 a3, __n128 *a4, void *a5)
{
  if (a1 && a4 && a5 && *a5 >= 0x18uLL)
  {
    __n128 result = *a1;
    *a4 = *a1;
    a4[1].n128_u32[0] = a2;
    a4[1].n128_u32[1] = a3;
    *a5 = 24LL;
  }

  return result;
}

__n128 LibSer_ContextCredentialGetProperty_Deserialize( __n128 *a1, unint64_t a2, __n128 *a3, _DWORD *a4, _DWORD *a5)
{
  if (a2 >= 0x18 && a1 && a3 && a4)
  {
    if (a5)
    {
      __n128 result = *a1;
      *a3 = *a1;
      *a4 = a1[1].n128_u32[0];
      *a5 = a1[1].n128_u32[1];
    }
  }

  return result;
}

uint64_t LibSer_GlobalContextCredentialGetProperty_GetSize(void *a1)
{
  if (!a1) {
    return 4294967293LL;
  }
  uint64_t result = 0LL;
  *a1 = 8LL;
  return result;
}

uint64_t LibSer_GlobalContextCredentialGetProperty_Serialize(int a1, int a2, _DWORD *a3, void *a4)
{
  uint64_t result = 4294967293LL;
  if (a3 && a4 && *a4 >= 8uLL)
  {
    uint64_t result = 0LL;
    *a3 = a1;
    a3[1] = a2;
    *a4 = 8LL;
  }

  return result;
}

uint64_t LibSer_GlobalContextCredentialGetProperty_Deserialize( _DWORD *a1, unint64_t a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t result = 4294967293LL;
  if (a2 >= 8 && a1 && a3)
  {
    if (a4)
    {
      uint64_t result = 0LL;
      *a3 = *a1;
      *a4 = a1[1];
    }
  }

  return result;
}

uint64_t LibSer_RemoveCredentialByType_GetSize(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (!a4) {
    return 4294967293LL;
  }
  uint64_t result = 0LL;
  *a4 = 24LL;
  return result;
}

__n128 LibSer_RemoveCredentialByType_Serialize( __n128 *a1, unsigned __int32 a2, unsigned __int32 a3, __n128 *a4, void *a5)
{
  if (a1 && a4 && a5 && *a5 >= 0x18uLL)
  {
    __n128 result = *a1;
    *a4 = *a1;
    a4[1].n128_u32[0] = a2;
    a4[1].n128_u32[1] = a3;
    *a5 = 24LL;
  }

  return result;
}

__n128 LibSer_RemoveCredentialByType_Deserialize( __n128 *a1, unint64_t a2, __n128 *a3, _DWORD *a4, _DWORD *a5)
{
  if (a2 >= 0x18 && a1 && a3 && a4)
  {
    if (a5)
    {
      __n128 result = *a1;
      *a3 = *a1;
      *a4 = a1[1].n128_u32[0];
      *a5 = a1[1].n128_u32[1];
    }
  }

  return result;
}

uint64_t LibSer_DeleteContext_GetSize(uint64_t a1, void *a2)
{
  if (!a2) {
    return 4294967293LL;
  }
  uint64_t result = 0LL;
  *a2 = 16LL;
  return result;
}

__n128 LibSer_DeleteContext_Serialize(__n128 *a1, __n128 *a2, void *a3)
{
  if (a1 && a2 && a3 && *a3 >= 0x10uLL)
  {
    __n128 result = *a1;
    *a2 = *a1;
    *a3 = 16LL;
  }

  return result;
}

__n128 LibSer_DeleteContext_Deserialize(__n128 *a1, unint64_t a2, __n128 *a3)
{
  if (a2 >= 0x10 && a1)
  {
    if (a3)
    {
      __n128 result = *a1;
      *a3 = *a1;
    }
  }

  return result;
}

uint64_t LibSer_StorageAnyCmd_DeserializeCommonFields( uint64_t a1, unint64_t a2, _OWORD *a3, _DWORD *a4)
{
  uint64_t result = 4294967293LL;
  if (a1 && a2 >= 0x14)
  {
    if (a3) {
      *a3 = *(_OWORD *)a1;
    }
    uint64_t result = 0LL;
    if (a4) {
      *a4 = *(_DWORD *)(a1 + 16);
    }
  }

  return result;
}

uint64_t LibSer_StorageSetData_GetSize(uint64_t a1, _DWORD *a2, unsigned int a3, void *a4)
{
  unsigned int v7 = 0;
  if (!a4) {
    return 4294967291LL;
  }
  uint64_t result = sub_100085F74(a2, a3, &v7);
  if (!(_DWORD)result) {
    *a4 = a1 + v7 + 28;
  }
  return result;
}

uint64_t LibSer_StorageSetData_Serialize( _OWORD *a1, int a2, const void *a3, size_t a4, _DWORD *a5, unsigned int a6, uint64_t a7, size_t *a8)
{
  uint64_t result = 4294967293LL;
  if (a1)
  {
    if (a2)
    {
      if (a7)
      {
        if (a8)
        {
          unsigned int v18 = 0;
          uint64_t result = sub_100085F74(a5, a6, &v18);
          if (!(_DWORD)result)
          {
            if (*a8 < a4 + v18 + 28)
            {
              return 4294967293LL;
            }

            else
            {
              *(_OWORD *)a7 = *a1;
              *(_DWORD *)(a7 + 16) = a2;
              *(_DWORD *)(a7 + 20) = a4;
              memcpy((void *)(a7 + 24), a3, a4);
              size_t v17 = a4 + 24;
              uint64_t result = sub_10008619C((uint64_t)a5, a6, a7, (uint64_t *)&v17);
              if (!(_DWORD)result) {
                *a8 = v17;
              }
            }
          }
        }
      }
    }
  }

  return result;
}

uint64_t LibSer_StorageSetData_Deserialize( uint64_t a1, unint64_t a2, _OWORD *a3, _DWORD *a4, void *a5, void *a6, void *a7, _DWORD *a8)
{
  uint64_t v10 = 4294967293LL;
  if (a1 && a2 >= 0x18 && a6 && a3 && a4 && a5 && a7 && a8)
  {
    v14[1] = v8;
    _DWORD v14[2] = v9;
    *a3 = *(_OWORD *)a1;
    *a4 = *(_DWORD *)(a1 + 16);
    uint64_t v11 = *(unsigned int *)(a1 + 20);
    v14[0] = 24LL;
    *a6 = v11;
    if ((_DWORD)v11)
    {
      unint64_t v12 = v11 + 24;
      if (v12 > a2) {
        return 4294967293LL;
      }
      *a5 = a1 + 24;
      v14[0] = v12;
    }

    else
    {
      *a5 = 0LL;
    }

    return sub_1000864D4(a1, a2, v14, a7, a8);
  }

  return v10;
}

uint64_t LibSer_StorageGetData_GetSize(_DWORD *a1, unsigned int a2, void *a3)
{
  unsigned int v5 = 0;
  if (!a3) {
    return 4294967291LL;
  }
  uint64_t result = sub_100085F74(a1, a2, &v5);
  if (!(_DWORD)result) {
    *a3 = v5 + 25LL;
  }
  return result;
}

uint64_t LibSer_StorageGetData_Serialize( _OWORD *a1, int a2, char a3, _DWORD *a4, unsigned int a5, uint64_t a6, void *a7)
{
  uint64_t result = 4294967293LL;
  if (a1)
  {
    if (a2)
    {
      if (a6)
      {
        if (a7)
        {
          unsigned int v16 = 0;
          uint64_t result = sub_100085F74(a4, a5, &v16);
          if (!(_DWORD)result)
          {
            if (*a7 < (unint64_t)v16 + 25)
            {
              return 4294967293LL;
            }

            else
            {
              *(_OWORD *)a6 = *a1;
              *(_DWORD *)(a6 + 16) = a2;
              *(_BYTE *)(a6 + 20) = a3;
              uint64_t v15 = 21LL;
              uint64_t result = sub_10008619C((uint64_t)a4, a5, a6, &v15);
              if (!(_DWORD)result) {
                *a7 = v15;
              }
            }
          }
        }
      }
    }
  }

  return result;
}

uint64_t LibSer_StorageGetData_Deserialize( uint64_t a1, unint64_t a2, _OWORD *a3, _DWORD *a4, BOOL *a5, void *a6, _DWORD *a7)
{
  uint64_t v9 = 4294967293LL;
  if (a1 && a2 >= 0x15 && a3 && a4 && a5)
  {
    v11[1] = v7;
    _DWORD v11[2] = v8;
    *a3 = *(_OWORD *)a1;
    *a4 = *(_DWORD *)(a1 + 16);
    *a5 = *(_BYTE *)(a1 + 20) != 0;
    v11[0] = 21LL;
    return sub_1000864D4(a1, a2, v11, a6, a7);
  }

  return v9;
}

uint64_t LibSer_GetUnlockSecret_GetSize(_DWORD *a1, unsigned int a2, void *a3)
{
  unsigned int v5 = 0;
  if (!a3) {
    return 4294967291LL;
  }
  uint64_t result = sub_100085F74(a1, a2, &v5);
  if (!(_DWORD)result) {
    *a3 = v5 + 20LL;
  }
  return result;
}

uint64_t LibSer_GetUnlockSecret_Serialize(_OWORD *a1, _DWORD *a2, unsigned int a3, _OWORD *a4, void *a5)
{
  uint64_t result = 4294967293LL;
  if (a1)
  {
    if (a4)
    {
      if (a5)
      {
        unsigned int v12 = 0;
        uint64_t result = sub_100085F74(a2, a3, &v12);
        if (!(_DWORD)result)
        {
          if (*a5 < (unint64_t)v12 + 20)
          {
            return 4294967293LL;
          }

          else
          {
            *a4 = *a1;
            uint64_t v11 = 16LL;
            uint64_t result = sub_10008619C((uint64_t)a2, a3, (uint64_t)a4, &v11);
            if (!(_DWORD)result) {
              *a5 = v11;
            }
          }
        }
      }
    }
  }

  return result;
}

uint64_t LibSer_GetUnlockSecret_Deserialize( _OWORD *a1, unint64_t a2, _OWORD *a3, void *a4, _DWORD *a5)
{
  if (!a1) {
    return 4294967293LL;
  }
  uint64_t result = 4294967293LL;
  if (a2 >= 0x10 && a3 && a4)
  {
    if (a5)
    {
      v9[1] = v5;
      _DWORD v9[2] = v6;
      *a3 = *a1;
      v9[0] = 16LL;
      return sub_1000864D4((uint64_t)a1, a2, v9, a4, a5);
    }
  }

  return result;
}

uint64_t LibSer_GetUnlockSecretResponse_GetSize(uint64_t a1, void *a2)
{
  if (!a2) {
    return 4294967291LL;
  }
  uint64_t result = 0LL;
  *a2 = a1 + 1;
  return result;
}

uint64_t LibSer_GetUnlockSecretResponse_Serialize(void *__src, size_t __n, char a3, _BYTE *a4, void *a5)
{
  uint64_t result = 4294967293LL;
  if (__src && __n && a4 && a5)
  {
    size_t v9 = __n + 1;
    if (*a5 < __n + 1)
    {
      return 4294967293LL;
    }

    else
    {
      *a4 = a3;
      memcpy(a4 + 1, __src, __n);
      uint64_t result = 0LL;
      *a5 = v9;
    }
  }

  return result;
}

uint64_t LibSer_GetUnlockSecretResponse_Deserialize(_BYTE *a1, uint64_t a2, void *a3, void *a4, _BYTE *a5)
{
  uint64_t result = 4294967293LL;
  if (a2 && a5 && a1 && a3)
  {
    if (a4)
    {
      uint64_t result = 0LL;
      *a5 = *a1;
      *a3 = a1 + 1;
      *a4 = a2 - 1;
    }
  }

  return result;
}

uint64_t LibSer_SEPControl_GetSize(uint64_t a1, _DWORD *a2, unsigned int a3, void *a4)
{
  unsigned int v7 = 0;
  if (!a4) {
    return 4294967291LL;
  }
  uint64_t result = sub_100085F74(a2, a3, &v7);
  if (!(_DWORD)result) {
    *a4 = a1 + v7 + 24;
  }
  return result;
}

uint64_t LibSer_SEPControl_Serialize( _OWORD *a1, _DWORD *a2, unsigned int a3, const void *a4, size_t a5, uint64_t a6, void *a7)
{
  uint64_t result = 4294967293LL;
  if (a6)
  {
    if (a7)
    {
      unsigned int v18 = 0;
      uint64_t result = sub_100085F74(a2, a3, &v18);
      if (!(_DWORD)result)
      {
        if (*a7 < a5 + v18 + 24)
        {
          return 4294967293LL;
        }

        else
        {
          if (a1)
          {
            *(_OWORD *)a6 = *a1;
          }

          else
          {
            *(void *)a6 = 0LL;
            *(void *)(a6 + _Block_object_dispose(va, 8) = 0LL;
          }

          uint64_t v17 = 16LL;
          uint64_t result = sub_10008619C((uint64_t)a2, a3, a6, &v17);
          if (!(_DWORD)result)
          {
            uint64_t v15 = v17;
            *(_DWORD *)(a6 + v17) = a5;
            uint64_t v16 = v15 + 4;
            memcpy((void *)(a6 + v15 + 4), a4, a5);
            uint64_t result = 0LL;
            *a7 = v16 + a5;
          }
        }
      }
    }
  }

  return result;
}

uint64_t LibSer_SEPControl_Deserialize( _OWORD *a1, unint64_t a2, _OWORD *a3, void *a4, _DWORD *a5, unint64_t *a6, void *a7)
{
  if (!a1) {
    return 4294967293LL;
  }
  uint64_t result = 4294967293LL;
  if (a2 >= 0x18 && a7 && a3 && a4 && a5 && a6)
  {
    *a3 = *a1;
    unint64_t v12 = 16LL;
    uint64_t result = sub_1000864D4((uint64_t)a1, a2, &v12, a4, a5);
    if (!(_DWORD)result)
    {
      unint64_t v11 = (unint64_t)a1 + v12 + 4;
      *a7 = *(unsigned int *)((char *)a1 + v12);
      *a6 = v11;
    }
  }

  return result;
}

uint64_t LibSer_SEPControlResponse_GetSize(uint64_t a1, void *a2)
{
  if (!a2) {
    return 4294967291LL;
  }
  uint64_t result = 0LL;
  *a2 = a1 + 4;
  return result;
}

uint64_t LibSer_SEPControlResponse_Serialize(void *__src, size_t __n, _DWORD *a3, uint64_t *a4)
{
  uint64_t result = 4294967293LL;
  if (a3 && a4)
  {
    uint64_t v8 = __n + 4;
    if (*a4 < __n + 4)
    {
      return 4294967293LL;
    }

    else
    {
      *a3 = __n;
      if (__src) {
        memcpy(a3 + 1, __src, __n);
      }
      else {
        uint64_t v8 = 4LL;
      }
      uint64_t result = 0LL;
      *a4 = v8;
    }
  }

  return result;
}

uint64_t LibSer_SEPControlResponse_Deserialize(unsigned int *a1, unint64_t a2, void *a3, void *a4)
{
  if (!a1) {
    return 4294967293LL;
  }
  uint64_t result = 4294967293LL;
  if (a2 >= 4 && a3 && a4)
  {
    uint64_t result = 0LL;
    unsigned int v7 = *a1;
    unint64_t v6 = a1 + 1;
    *a4 = v7;
    if (!v7) {
      unint64_t v6 = 0LL;
    }
    *a3 = v6;
  }

  return result;
}

uint64_t sub_100088DC0(_DWORD *a1)
{
  if (!a1) {
    return 4294967293LL;
  }
  switch(*a1)
  {
    case 0:
    case 0xC:
      if (a1[4]) {
        return 4294967293LL;
      }
      break;
    case 1:
    case 4:
    case 5:
    case 0xA:
      if (a1[4] != 4) {
        return 4294967293LL;
      }
      break;
    case 2:
    case 6:
    case 7:
      if (a1[4] != 16) {
        return 4294967293LL;
      }
      break;
    case 3:
      break;
    case 8:
    case 9:
      if (a1[4] != 1) {
        return 4294967293LL;
      }
      break;
    case 0xB:
      if (a1[4] > 0x400u) {
        return 4294967293LL;
      }
      break;
    default:
      return 4294967293LL;
  }

  return 0LL;
}

uint64_t LibCall_ACMKernelControl_Block( uint64_t (*a1)(uint64_t, uint64_t, void, char *, size_t, uint64_t, uint64_t), uint64_t a2, int a3, const void *a4, size_t a5, uint64_t a6)
{
  uint64_t v16 = 0x2000LL;
  uint64_t v12 = LibCall_ACMKernelControl(a1, a2, a3, a4, a5, (uint64_t)v17, (uint64_t)&v16);
  if (a6)
  {
    if (v16) {
      uint64_t v13 = v17;
    }
    else {
      uint64_t v13 = 0LL;
    }
    (*(void (**)(uint64_t, _BYTE *))(a6 + 16))(a6, v13);
  }

  if ((_DWORD)v12) {
    unsigned int v14 = 70;
  }
  else {
    unsigned int v14 = 10;
  }
  return v12;
}

uint64_t LibCall_ACMSEPControl_Block( uint64_t (*a1)(uint64_t, uint64_t, void, char *, uint64_t, unsigned int *, unint64_t *), uint64_t a2, const void *a3, size_t a4, uint64_t a5, _DWORD *a6, unsigned int a7, uint64_t a8)
{
  size_t v20 = 1024LL;
  uint64_t v16 = LibCall_ACMSEPControl(a1, a2, a3, a4, a5, a6, a7, v21, &v20);
  if (a8)
  {
    if (v20) {
      uint64_t v17 = v21;
    }
    else {
      uint64_t v17 = 0LL;
    }
    (*(void (**)(uint64_t, _BYTE *))(a8 + 16))(a8, v17);
  }

  if ((_DWORD)v16) {
    unsigned int v18 = 70;
  }
  else {
    unsigned int v18 = 10;
  }
  return v16;
}

uint64_t LibCall_ACMGlobalContextCredentialGetProperty_Block( uint64_t result, uint64_t a2, int a3, int a4, uint64_t a5)
{
  size_t v9 = (uint64_t (*)(uint64_t, uint64_t, void, int *, uint64_t, _BYTE *, uint64_t *))result;
  uint64_t v14 = 256LL;
  if (v9)
  {
    uint64_t v13 = 8LL;
    uint64_t result = LibSer_GlobalContextCredentialGetProperty_Serialize(a3, a4, &v15, &v13);
    if ((_DWORD)result)
    {
LABEL_7:
      uint64_t v10 = result;
      goto LABEL_8;
    }

    if (v13 == 8)
    {
      uint64_t result = v9(a2, 27LL, 0LL, &v15, 8LL, v16, &v14);
      goto LABEL_7;
    }

    uint64_t v10 = 4294967291LL;
  }

  else
  {
    uint64_t v10 = 4294967293LL;
  }

uint64_t LibCall_ACMContextVerifyPolicy_Block( uint64_t (*a1)(uint64_t, uint64_t, void, _OWORD *, size_t, unsigned int *, unint64_t *), uint64_t a2, _OWORD *a3, char *a4, uint64_t a5)
{
  return LibCall_ACMContextVerifyPolicyWithPreflight_Block(a1, a2, a3, a4, 0LL, a5);
}

uint64_t LibCall_ACMContextVerifyPolicyWithPreflight_Block( uint64_t (*a1)(uint64_t, uint64_t, void, _OWORD *, size_t, unsigned int *, unint64_t *), uint64_t a2, _OWORD *a3, char *__s1, uint64_t a5, uint64_t a6)
{
  uint64_t v17 = 0LL;
  BOOL v16 = 0;
  unsigned int v12 = 70;
  uint64_t v13 = 4294967293LL;
  if (a3 && __s1 && a6)
  {
    uint64_t v13 = LibCall_ACMContextVerifyPolicyEx(a1, a2, a3, __s1, a5, 0LL, 0, 0LL, &v16, &v17);
    uint64_t v14 = v17;
    if (!(_DWORD)v13)
    {
      (*(void (**)(uint64_t, BOOL, int *))(a6 + 16))(a6, v16, v17);
      uint64_t v14 = v17;
    }

    if (v14) {
      Util_DeallocRequirement(v14);
    }
    if ((_DWORD)v13) {
      unsigned int v12 = 70;
    }
    else {
      unsigned int v12 = 10;
    }
  }

  return v13;
}

int *LibCall_ACMContextVerifyPolicyEx_Block( uint64_t (*a1)(uint64_t, uint64_t, void, _OWORD *, size_t, unsigned int *, unint64_t *), uint64_t a2, _OWORD *a3, char *__s1, uint64_t a5, _DWORD *a6, unsigned int a7, uint64_t a8, uint64_t a9)
{
  BOOL v17 = 0LL;
  unsigned int v18 = 0LL;
  uint64_t v22 = 0LL;
  BOOL v21 = 0;
  uint64_t v19 = 4294967293LL;
  if (a3 && __s1 && a9)
  {
    uint64_t v19 = LibCall_ACMContextVerifyPolicyEx(a1, a2, a3, __s1, a5, a6, a7, a8, &v21, &v22);
    unsigned int v18 = v22;
    BOOL v17 = v21;
  }

  (*(void (**)(uint64_t, uint64_t, BOOL, int *))(a9 + 16))(a9, v19, v17, v18);
  uint64_t result = v22;
  if (v22) {
    uint64_t result = (int *)Util_DeallocRequirement(v22);
  }
  return result;
}

uint64_t LibCall_ACMGlobalContextVerifyPolicy_Block( uint64_t (*a1)(uint64_t, uint64_t, void, _OWORD *, size_t, unsigned int *, unint64_t *), uint64_t a2, char *a3, uint64_t a4, _DWORD *a5, unsigned int a6, uint64_t a7)
{
  *(void *)int v15 = 0LL;
  uint64_t result = LibCall_ACMContextCreate( (uint64_t (*)(uint64_t, uint64_t, void, void, void, _BYTE *, uint64_t *))a1,  a2,  v15,  0LL,  1);
  if ((_DWORD)result)
  {
    if (a7) {
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, void))(a7 + 16))(a7, result, 0LL, 0LL);
    }
  }

  else
  {
    uint64_t result = (uint64_t)LibCall_ACMContextVerifyPolicyEx_Block(a1, a2, *(_OWORD **)v15, a3, a4, a5, a6, 0xFFFFFFFFLL, a7);
  }

  if (*(void *)v15) {
    uint64_t result = LibCall_ACMContextDelete( (void (*)(uint64_t, uint64_t, void, void *, uint64_t, void, void))a1,  a2,  *(void **)v15,  1);
  }
  return result;
}

uint64_t LibCall_ACMGetEnvironmentVariable_Block( uint64_t (*a1)(uint64_t, uint64_t, void, int *, uint64_t, uint64_t, uint64_t), uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v14 = 128LL;
  if (!a4)
  {
    unsigned int v12 = 70;
    uint64_t v9 = 4294967293LL;
    goto LABEL_17;
  }

  if (a3 == 36)
  {
    uint64_t v8 = acm_mem_alloc_data(0x800uLL);
    acm_mem_alloc_info( "<data>",  v8,  2048LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCallBlock.c",  162,  "LibCall_ACMGetEnvironmentVariable_Block");
    if (!v8)
    {
      unsigned int v12 = 70;
      uint64_t v9 = 4294967292LL;
      goto LABEL_17;
    }

    uint64_t v14 = 2048LL;
    uint64_t v9 = LibCall_ACMGetEnvironmentVariable(a1, a2, 36, (uint64_t)v8, (uint64_t)&v14);
    if (!(_DWORD)v9)
    {
      if (v14) {
        uint64_t v10 = v8;
      }
      else {
        uint64_t v10 = 0LL;
      }
      (*(void (**)(uint64_t, void *))(a4 + 16))(a4, v10);
      acm_mem_free_info( "<data>",  v8,  0x800uLL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCallBlock.c",  176,  "LibCall_ACMGetEnvironmentVariable_Block");
      acm_mem_free_data(v8, 0x800uLL);
LABEL_16:
      unsigned int v12 = 10;
      goto LABEL_17;
    }

    acm_mem_free_info( "<data>",  v8,  0x800uLL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCallBlock.c",  176,  "LibCall_ACMGetEnvironmentVariable_Block");
    acm_mem_free_data(v8, 0x800uLL);
  }

  else
  {
    uint64_t v9 = LibCall_ACMGetEnvironmentVariable(a1, a2, a3, (uint64_t)v15, (uint64_t)&v14);
    if (!(_DWORD)v9)
    {
      if (v14) {
        unint64_t v11 = v15;
      }
      else {
        unint64_t v11 = 0LL;
      }
      (*(void (**)(uint64_t, _BYTE *))(a4 + 16))(a4, v11);
      goto LABEL_16;
    }
  }

  unsigned int v12 = 70;
LABEL_17:
  return v9;
}

uint64_t LibCall_ACMTRMLoadState_Block( uint64_t (*a1)(uint64_t, uint64_t, void, void, void, uint64_t, uint64_t), uint64_t a2, uint64_t a3)
{
  uint64_t v10 = 0x2000LL;
  if (a3)
  {
    uint64_t v6 = LibCall_ACMTRMLoadState(a1, a2, (uint64_t)v11, (uint64_t)&v10);
    if ((_DWORD)v6)
    {
      unsigned int v8 = 70;
    }

    else
    {
      if (v10) {
        unsigned int v7 = v11;
      }
      else {
        unsigned int v7 = 0LL;
      }
      (*(void (**)(uint64_t, _BYTE *))(a3 + 16))(a3, v7);
      unsigned int v8 = 10;
    }
  }

  else
  {
    unsigned int v8 = 70;
    uint64_t v6 = 4294967293LL;
  }

  return v6;
}

uint64_t LibCall_ACMContextUnloadToImage_Block( uint64_t (*a1)(uint64_t, uint64_t, void, int *, uint64_t, _BYTE *, int *), uint64_t a2, __int128 *a3, uint64_t a4)
{
  uint64_t v12 = 4096LL;
  if (a4)
  {
    uint64_t v8 = LibCall_ACMContextUnloadToImage(a1, a2, a3, v13, &v12);
    if ((_DWORD)v8)
    {
      unsigned int v10 = 70;
    }

    else
    {
      if (v12) {
        uint64_t v9 = v13;
      }
      else {
        uint64_t v9 = 0LL;
      }
      (*(void (**)(uint64_t, _BYTE *))(a4 + 16))(a4, v9);
      unsigned int v10 = 10;
    }
  }

  else
  {
    unsigned int v10 = 70;
    uint64_t v8 = 4294967293LL;
  }

  return v8;
}

uint64_t LibCall_ACMGetAclAuthMethod_Block(uint64_t result, uint64_t a2, __n128 *a3, uint64_t a4)
{
  unsigned int v7 = (void (*)(uint64_t, uint64_t, void, __n128 *, uint64_t, _BYTE *, uint64_t *, __n128))result;
  uint64_t v11 = 256LL;
  if (v7 && a3 && a4)
  {
    uint64_t v10 = 16LL;
    __n128 AclAuthMethod_Serialize = LibSer_GetAclAuthMethod_Serialize(a3, &v12, &v10);
    if (!v9 && v10 == 16) {
      v7(a2, 31LL, 0LL, &v12, 16LL, v13, &v11, AclAuthMethod_Serialize);
    }
    goto LABEL_9;
  }

  if (a4) {
LABEL_9:
  }
    uint64_t result = (*(uint64_t (**)(uint64_t))(a4 + 16))(a4);
  return result;
}

uint64_t LibCall_ACMContextVerifyAclConstraint( uint64_t a1, uint64_t a2, _OWORD *a3, const void *a4, uint64_t a5, unsigned __int8 a6, _DWORD *a7, unsigned int a8, unsigned int a9, uint64_t a10)
{
  return sub_100089CBC(a1, a2, 0xBu, a3, a4, a5, 0LL, 0, a6, a7, a8, a9, a10);
}

uint64_t sub_100089CBC( uint64_t result, uint64_t a2, unsigned __int8 a3, _OWORD *a4, const void *a5, uint64_t a6, const void *a7, unsigned int a8, unsigned __int8 a9, _DWORD *a10, unsigned int a11, unsigned int a12, uint64_t a13)
{
  size_t v20 = (uint64_t (*)(uint64_t, uint64_t, void, void *, size_t, unsigned int *, unint64_t *))result;
  size_t v25 = 0LL;
  BOOL v24 = 0;
  if (a4 && a5 && a6 && a13)
  {
    uint64_t v21 = verifyAclConstraintInternal(v20, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, &v24, &v25);
    uint64_t v22 = v25;
    BOOL v23 = v24;
  }

  else
  {
    if (!a13) {
      goto LABEL_10;
    }
    uint64_t v22 = 0LL;
    BOOL v23 = 0LL;
    uint64_t v21 = 4294967293LL;
  }

  (*(void (**)(uint64_t, uint64_t, BOOL, int *))(a13 + 16))(a13, v21, v23, v22);
  uint64_t result = (uint64_t)v25;
  if (v25) {
    uint64_t result = Util_DeallocRequirement(v25);
  }
LABEL_10:
  return result;
}

uint64_t LibCall_ACMContextVerifyAclConstraintForOperation( uint64_t a1, uint64_t a2, _OWORD *a3, const void *a4, uint64_t a5, const void *a6, unsigned int a7, unsigned __int8 a8, _DWORD *a9, unsigned int a10, unsigned int a11, uint64_t a12)
{
  return sub_100089CBC(a1, a2, 0x20u, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
}

uint64_t Util_GetBitCount(uint64_t a1)
{
  uint8x8_t v1 = (uint8x8_t)vcnt_s8((int8x8_t)a1);
  v1.i16[0] = vaddlv_u8(v1);
  return v1.u32[0];
}

BOOL Util_isNullOrZeroMemory(_BYTE *a1, uint64_t a2)
{
  if (!a1) {
    return 1LL;
  }
  if (*a1) {
    return 0LL;
  }
  return memcmp(a1, a1 + 1, a2 - 1) == 0;
}

BOOL Util_isNonNullEqualMemory(void *__s1, size_t __n, void *__s2, uint64_t a4)
{
  if (__n != a4) {
    return 0LL;
  }
  BOOL result = 0LL;
  if (__s1)
  {
    if (__s2) {
      return memcmp(__s1, __s2, __n) == 0;
    }
  }

  return result;
}

char *Util_hexDumpToStrHelper(char *result, unint64_t a2, uint64_t a3, unint64_t a4)
{
  if (!result && a2) {
    sub_10008B51C();
  }
  if (!a3 && a4) {
    sub_10008B544();
  }
  if (a2 >= a4) {
    unint64_t v4 = a4;
  }
  else {
    unint64_t v4 = a2;
  }
  if (v4)
  {
    unint64_t v5 = (_BYTE *)(a3 + 1);
    do
    {
      *(v5 - 1) = a0123456789abcd[(unint64_t)*result >> 4];
      char v6 = *result++;
      *unint64_t v5 = a0123456789abcd[v6 & 0xF];
      v5 += 2;
      --v4;
    }

    while (v4);
  }

  return result;
}

uint64_t Util_WriteToBuffer(uint64_t a1, size_t a2, void *a3, void *__src, size_t __n)
{
  if (a3)
  {
    uint64_t v10 = *a3;
    size_t v11 = *a3 + __n;
    if (!__CFADD__(*a3, __n))
    {
      if (a1 && v11 > a2)
      {
        uint64_t v12 = 4294967276LL;
        goto LABEL_19;
      }

      if (!a1 || !__src || !__n) {
        goto LABEL_12;
      }
      if (!__CFADD__(a1, v10))
      {
        memcpy((void *)(a1 + v10), __src, __n);
LABEL_12:
        uint64_t v12 = 0LL;
        *a3 = v11;
        unsigned int v13 = 10;
        goto LABEL_13;
      }
    }

    uint64_t v12 = 4294967291LL;
  }

  else
  {
    uint64_t v12 = 4294967293LL;
  }

uint64_t Util_ReadFromBuffer(uint64_t a1, size_t a2, void *a3, void *__dst, size_t __n)
{
  uint64_t v10 = 4294967293LL;
  unsigned int v11 = 70;
  if (a1 && a3)
  {
    uint64_t v12 = *a3;
    size_t v13 = *a3 + __n;
    if (!__CFADD__(*a3, __n))
    {
      if (v13 > a2)
      {
        uint64_t v10 = 4294967276LL;
        goto LABEL_17;
      }

      if (!__dst || !__n) {
        goto LABEL_11;
      }
      if (!__CFADD__(a1, v12))
      {
        memcpy(__dst, (const void *)(a1 + v12), __n);
LABEL_11:
        uint64_t v10 = 0LL;
        *a3 = v13;
        unsigned int v11 = 10;
        goto LABEL_12;
      }
    }

    uint64_t v10 = 4294967291LL;
LABEL_17:
    unsigned int v11 = 70;
  }

unint64_t Util_KeybagLockStateToEnvVar(unsigned int a1)
{
  unint64_t v1 = 0x2010103020201uLL >> (8 * a1);
  if (a1 >= 7) {
    LOBYTE(v1) = 1;
  }
  return v1 & 3;
}

void Util_SafeDeallocParameters(unsigned int *a1, unsigned int a2)
{
  if (a1)
  {
    uint64_t v3 = a2;
    if (a2)
    {
      unint64_t v4 = a1 + 4;
      uint64_t v5 = a2;
      do
      {
        char v6 = (void *)*((void *)v4 - 1);
        if (v6)
        {
          unint64_t v7 = *v4;
          acm_mem_free_info( "<data>",  *((const void **)v4 - 1),  v7,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/CommonUtil.c",  118,  "Util_SafeDeallocParameters");
          acm_mem_free_data(v6, v7);
        }

        v4 += 6;
        --v5;
      }

      while (v5);
    }

    acm_mem_free_info( "array of ACMParameter",  a1,  24 * v3,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/CommonUtil.c",  121,  "Util_SafeDeallocParameters");
    acm_mem_free(a1, 24 * v3);
  }

uint64_t Util_DeallocCredential(_DWORD *a1)
{
  if (a1)
  {
    uint64_t v2 = 4294967293LL;
    unsigned int v3 = 70;
    switch(*a1)
    {
      case 1:
        unint64_t v4 = "ACMCredential - ACMCredentialDataPasscodeValidated";
        rsize_t v5 = 60LL;
        char v6 = a1;
        unint64_t v7 = 60LL;
        int v8 = 144;
        goto LABEL_6;
      case 2:
        unint64_t v4 = "ACMCredential - ACMCredentialDataPassphraseEntered";
        rsize_t v5 = 168LL;
        char v6 = a1;
        unint64_t v7 = 168LL;
        int v8 = 136;
        goto LABEL_6;
      case 3:
        unint64_t v4 = "ACMCredential - ACMCredentialDataBiometryMatched";
        rsize_t v5 = 337LL;
        char v6 = a1;
        unint64_t v7 = 337LL;
        int v8 = 140;
        goto LABEL_6;
      case 4:
      case 5:
      case 6:
      case 8:
      case 0xE:
      case 0x10:
      case 0x13:
      case 0x16:
      case 0x17:
        unint64_t v4 = "ACMCredential";
        rsize_t v5 = 32LL;
        char v6 = a1;
        unint64_t v7 = 32LL;
        int v8 = 189;
        goto LABEL_6;
      case 7:
        unint64_t v4 = "ACMCredential - ACMCredentialDataUserOutputDisplayed";
        rsize_t v5 = 88LL;
        char v6 = a1;
        unint64_t v7 = 88LL;
        int v8 = 152;
        goto LABEL_6;
      case 9:
        unint64_t v4 = "ACMCredential - ACMCredentialDataContinuityUnlock";
        rsize_t v5 = 56LL;
        char v6 = a1;
        unint64_t v7 = 56LL;
        int v8 = 156;
        goto LABEL_6;
      case 0xA:
        unint64_t v4 = "ACMCredential - ACMCredentialDataPasscodeValidated2";
        rsize_t v5 = 84LL;
        char v6 = a1;
        unint64_t v7 = 84LL;
        int v8 = 148;
        goto LABEL_6;
      case 0xC:
      case 0xF:
        unint64_t v4 = "ACMCredential - ACMCredentialDataKextDenyList";
        rsize_t v5 = 40LL;
        char v6 = a1;
        unint64_t v7 = 40LL;
        int v8 = 161;
        goto LABEL_6;
      case 0xD:
        unint64_t v4 = "ACMCredential - ACMCredentialDataPassphraseExtractable";
        rsize_t v5 = 164LL;
        char v6 = a1;
        unint64_t v7 = 164LL;
        int v8 = 132;
        goto LABEL_6;
      case 0x11:
        unint64_t v4 = "ACMCredential - ACMCredentialDataSecureIntent";
        rsize_t v5 = 113LL;
        char v6 = a1;
        unint64_t v7 = 113LL;
        int v8 = 165;
        goto LABEL_6;
      case 0x12:
        unint64_t v4 = "ACMCredential - ACMCredentialDataBiometryMatchAttempted";
        rsize_t v5 = 52LL;
        char v6 = a1;
        unint64_t v7 = 52LL;
        int v8 = 169;
        goto LABEL_6;
      case 0x14:
        unint64_t v4 = "ACMCredential - ACMCredentialDataAP";
        rsize_t v5 = 64LL;
        char v6 = a1;
        unint64_t v7 = 64LL;
        int v8 = 173;
        goto LABEL_6;
      case 0x15:
        unint64_t v4 = "ACMCredential - ACMCredentialDataSignature";
        rsize_t v5 = 164LL;
        char v6 = a1;
        unint64_t v7 = 164LL;
        int v8 = 177;
LABEL_6:
        acm_mem_free_info( v4,  v6,  v7,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/CommonUtil.c",  v8,  "Util_DeallocCredential");
        acm_mem_free(a1, v5);
        uint64_t v2 = 0LL;
        unsigned int v3 = 10;
        break;
      default:
        break;
    }
  }

  else
  {
    uint64_t v2 = 4294967293LL;
    unsigned int v3 = 70;
  }

  return v2;
}

uint64_t Util_AllocCredential(int a1, void *a2)
{
  if (!a2) {
    return 4294967293LL;
  }
  uint64_t result = 4294967293LL;
  switch(a1)
  {
    case 1:
      rsize_t v5 = acm_mem_alloc(0x3CuLL);
      acm_mem_alloc_info( "ACMCredential - ACMCredentialDataPasscodeValidated",  v5,  60LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/CommonUtil.c",  226,  "Util_AllocCredential");
      int v6 = 28;
      goto LABEL_4;
    case 2:
      rsize_t v5 = acm_mem_alloc(0xA8uLL);
      acm_mem_alloc_info( "ACMCredential - ACMCredentialDataPassphraseEntered",  v5,  168LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/CommonUtil.c",  216,  "Util_AllocCredential");
      int v6 = 136;
      goto LABEL_4;
    case 3:
      rsize_t v5 = acm_mem_alloc(0x151uLL);
      acm_mem_alloc_info( "ACMCredential - ACMCredentialDataBiometryMatched",  v5,  337LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/CommonUtil.c",  221,  "Util_AllocCredential");
      int v6 = 305;
      goto LABEL_4;
    case 4:
    case 5:
    case 6:
    case 8:
    case 14:
    case 16:
    case 19:
    case 22:
    case 23:
      rsize_t v5 = acm_mem_alloc(0x20uLL);
      acm_mem_alloc_info( "ACMCredential",  v5,  32LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/CommonUtil.c",  280,  "Util_AllocCredential");
      int v6 = 0;
      goto LABEL_4;
    case 7:
      rsize_t v5 = acm_mem_alloc(0x58uLL);
      acm_mem_alloc_info( "ACMCredential - ACMCredentialDataUserOutputDisplayed",  v5,  88LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/CommonUtil.c",  236,  "Util_AllocCredential");
      int v6 = 56;
      goto LABEL_4;
    case 9:
      rsize_t v5 = acm_mem_alloc(0x38uLL);
      acm_mem_alloc_info( "ACMCredential - ACMCredentialDataContinuityUnlock",  v5,  56LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/CommonUtil.c",  241,  "Util_AllocCredential");
      int v6 = 24;
      goto LABEL_4;
    case 10:
      rsize_t v5 = acm_mem_alloc(0x54uLL);
      acm_mem_alloc_info( "ACMCredential - ACMCredentialDataPasscodeValidated2",  v5,  84LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/CommonUtil.c",  231,  "Util_AllocCredential");
      int v6 = 52;
      goto LABEL_4;
    case 12:
    case 15:
      rsize_t v5 = acm_mem_alloc(0x28uLL);
      acm_mem_alloc_info( "ACMCredential - ACMCredentialDataKextDenyList",  v5,  40LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/CommonUtil.c",  247,  "Util_AllocCredential");
      int v6 = 8;
      goto LABEL_4;
    case 13:
      rsize_t v5 = acm_mem_alloc(0xA4uLL);
      unint64_t v7 = "ACMCredential - ACMCredentialDataPassphraseExtractable";
      int v8 = v5;
      int v9 = 211;
      goto LABEL_18;
    case 17:
      rsize_t v5 = acm_mem_alloc(0x71uLL);
      acm_mem_alloc_info( "ACMCredential - ACMCredentialDataSecureIntent",  v5,  113LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/CommonUtil.c",  252,  "Util_AllocCredential");
      int v6 = 81;
      goto LABEL_4;
    case 18:
      rsize_t v5 = acm_mem_alloc(0x34uLL);
      acm_mem_alloc_info( "ACMCredential - ACMCredentialDataBiometryMatchAttempted",  v5,  52LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/CommonUtil.c",  257,  "Util_AllocCredential");
      int v6 = 20;
      goto LABEL_4;
    case 20:
      rsize_t v5 = acm_mem_alloc(0x40uLL);
      acm_mem_alloc_info( "ACMCredential - ACMCredentialDataAP",  v5,  64LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/CommonUtil.c",  262,  "Util_AllocCredential");
      int v6 = 32;
      goto LABEL_4;
    case 21:
      rsize_t v5 = acm_mem_alloc(0xA4uLL);
      unint64_t v7 = "ACMCredential - ACMCredentialDataSignature";
      int v8 = v5;
      int v9 = 267;
LABEL_18:
      acm_mem_alloc_info( v7,  v8,  164LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/CommonUtil.c",  v9,  "Util_AllocCredential");
      int v6 = 132;
LABEL_4:
      if (v5)
      {
        uint64_t result = 0LL;
        *rsize_t v5 = a1;
        v5[1] = 1;
        v5[7] = v6;
        v5[3] = -1;
        *a2 = v5;
      }

      else
      {
        uint64_t result = 4294967292LL;
      }

      break;
    default:
      return result;
  }

  return result;
}

uint64_t Util_AllocRequirement(int a1, uint64_t a2, void *a3)
{
  if (a3)
  {
    uint64_t v6 = 4294967293LL;
    unsigned int v7 = 70;
    switch(a1)
    {
      case 1:
        int v8 = acm_mem_alloc(0x14uLL);
        unsigned int v11 = "ACMRequirement - ACMRequirementDataPasscodeValidated";
        uint64_t v12 = v8;
        int v13 = 338;
        goto LABEL_49;
      case 2:
        int v8 = acm_mem_alloc(0x14uLL);
        unsigned int v11 = "ACMRequirement - ACMRequirementDataPassphraseEntered";
        uint64_t v12 = v8;
        int v13 = 343;
        goto LABEL_49;
      case 3:
        int v8 = acm_mem_alloc(0xACuLL);
        acm_mem_alloc_info( "ACMRequirement - ACMRequirementDataBiometryMatched",  v8,  172LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/CommonUtil.c",  348,  "Util_AllocRequirement");
        int v9 = 156;
        if (!v8) {
          goto LABEL_50;
        }
        goto LABEL_6;
      case 4:
        int v8 = acm_mem_alloc(0x64uLL);
        uint64_t v14 = "ACMRequirement - ACMRequirementDataOr";
        int v15 = v8;
        int v16 = 406;
        goto LABEL_28;
      case 5:
        int v8 = acm_mem_alloc(0x64uLL);
        uint64_t v14 = "ACMRequirement - ACMRequirementDataAnd";
        int v15 = v8;
        int v16 = 398;
LABEL_28:
        acm_mem_alloc_info( v14,  v15,  100LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/CommonUtil.c",  v16,  "Util_AllocRequirement");
        int v9 = 84;
        if (!v8) {
          goto LABEL_50;
        }
        goto LABEL_6;
      case 6:
      case 9:
      case 10:
      case 11:
      case 12:
      case 14:
      case 15:
      case 18:
      case 19:
      case 22:
      case 23:
      case 27:
      case 28:
        int v8 = acm_mem_alloc(0x10uLL);
        acm_mem_alloc_info( "ACMRequirement",  v8,  16LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/CommonUtil.c",  333,  "Util_AllocRequirement");
        int v9 = 0;
        if (v8) {
          goto LABEL_6;
        }
        goto LABEL_50;
      case 7:
        int v8 = acm_mem_alloc(0x68uLL);
        acm_mem_alloc_info( "ACMRequirement - ACMRequirementDataKofN",  v8,  104LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/CommonUtil.c",  391,  "Util_AllocRequirement");
        int v9 = 88;
        if (!v8) {
          goto LABEL_50;
        }
        goto LABEL_6;
      case 8:
        int v8 = acm_mem_alloc(0x410uLL);
        acm_mem_alloc_info( "ACMRequirement - ACMRequirementDataAccessGroups",  v8,  1040LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/CommonUtil.c",  378,  "Util_AllocRequirement");
        int v9 = 1024;
        if (!v8) {
          goto LABEL_50;
        }
        goto LABEL_6;
      case 13:
        int v8 = acm_mem_alloc(0x30uLL);
        acm_mem_alloc_info( "ACMRequirement - ACMRequirementDataUserOutputDisplayed",  v8,  48LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/CommonUtil.c",  363,  "Util_AllocRequirement");
        int v9 = 32;
        if (!v8) {
          goto LABEL_50;
        }
        goto LABEL_6;
      case 16:
      case 17:
        break;
      case 20:
        int v8 = acm_mem_alloc(0x14uLL);
        unsigned int v11 = "ACMRequirement - ACMRequirementDataSecureIntent";
        uint64_t v12 = v8;
        int v13 = 353;
        goto LABEL_49;
      case 21:
        int v8 = acm_mem_alloc(0x14uLL);
        unsigned int v11 = "ACMRequirement - ACMRequirementDataBiometryMatchAttempted";
        uint64_t v12 = v8;
        int v13 = 358;
LABEL_49:
        acm_mem_alloc_info( v11,  v12,  20LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/CommonUtil.c",  v13,  "Util_AllocRequirement");
        int v9 = 4;
        if (!v8) {
          goto LABEL_50;
        }
        goto LABEL_6;
      case 24:
        int v8 = acm_mem_alloc(0x434uLL);
        acm_mem_alloc_info( "ACMRequirement - ACMRequirementDataAP",  v8,  1076LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/CommonUtil.c",  368,  "Util_AllocRequirement");
        int v9 = 1060;
        if (!v8) {
          goto LABEL_50;
        }
        goto LABEL_6;
      case 25:
        int v8 = acm_mem_alloc(0x3BuLL);
        acm_mem_alloc_info( "ACMRequirement - ACMRequirementDataKeyRef",  v8,  59LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/CommonUtil.c",  373,  "Util_AllocRequirement");
        int v9 = 43;
        if (!v8) {
          goto LABEL_50;
        }
        goto LABEL_6;
      case 26:
        int v8 = acm_mem_alloc(0x2CuLL);
        acm_mem_alloc_info( "ACMRequirement - ACMRequirementDataRatchet",  v8,  44LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/CommonUtil.c",  384,  "Util_AllocRequirement");
        int v9 = 28;
        if (!v8)
        {
LABEL_50:
          uint64_t v6 = 4294967292LL;
          goto LABEL_54;
        }

uint64_t Util_CreateRequirement(int a1, uint64_t a2)
{
  uint64_t v5 = 0LL;
  Util_AllocRequirement(a1, a2, &v5);
  return v5;
}

uint64_t Util_DeallocRequirement(int *a1)
{
  if (!a1)
  {
    uint64_t v7 = 4294967293LL;
    unsigned int v8 = 70;
    goto LABEL_28;
  }

  int v2 = *a1;
  if (*a1 > 6)
  {
    if (v2 == 7)
    {
      if (a1[5])
      {
        unint64_t v6 = 0LL;
        do
          Util_DeallocRequirement(*(void *)&a1[2 * v6++ + 6]);
        while (v6 < a1[5]);
      }
    }

    else
    {
      if (v2 != 1000) {
        goto LABEL_25;
      }
      if (a1[13])
      {
        unint64_t v4 = 0LL;
        do
          Util_DeallocRequirement(*(void *)&a1[2 * v4++ + 14]);
        while (v4 < a1[13]);
      }
    }
  }

  else if (v2 == 4)
  {
    if (a1[4])
    {
      unint64_t v5 = 0LL;
      do
        Util_DeallocRequirement(*(void *)&a1[2 * v5++ + 5]);
      while (v5 < a1[4]);
    }
  }

  else
  {
    if (v2 != 5) {
      goto LABEL_25;
    }
    if (a1[4])
    {
      unint64_t v3 = 0LL;
      do
        Util_DeallocRequirement(*(void *)&a1[2 * v3++ + 5]);
      while (v3 < a1[4]);
    }
  }

  int v2 = *a1;
LABEL_25:
  uint64_t v7 = 4294967293LL;
  unsigned int v8 = 70;
  switch(v2)
  {
    case 1:
      int v9 = "ACMRequirement - ACMRequirementDataPasscodeValidated";
      rsize_t v10 = 20LL;
      unsigned int v11 = a1;
      unint64_t v12 = 20LL;
      int v13 = 542;
      goto LABEL_27;
    case 2:
      int v9 = "ACMRequirement - ACMRequirementDataPassphraseEntered";
      rsize_t v10 = 20LL;
      unsigned int v11 = a1;
      unint64_t v12 = 20LL;
      int v13 = 546;
      goto LABEL_27;
    case 3:
      int v9 = "ACMRequirement - ACMRequirementDataBiometryMatched";
      rsize_t v10 = 172LL;
      unsigned int v11 = a1;
      unint64_t v12 = 172LL;
      int v13 = 550;
      goto LABEL_27;
    case 4:
      int v9 = "ACMRequirement - ACMRequirementDataOr";
      rsize_t v10 = 100LL;
      unsigned int v11 = a1;
      unint64_t v12 = 100LL;
      int v13 = 595;
      goto LABEL_27;
    case 5:
      int v9 = "ACMRequirement - ACMRequirementDataAnd";
      rsize_t v10 = 100LL;
      unsigned int v11 = a1;
      unint64_t v12 = 100LL;
      int v13 = 589;
      goto LABEL_27;
    case 6:
    case 9:
    case 10:
    case 11:
    case 12:
    case 14:
    case 15:
    case 18:
    case 19:
    case 22:
    case 23:
    case 27:
    case 28:
      int v9 = "ACMRequirement";
      rsize_t v10 = 16LL;
      unsigned int v11 = a1;
      unint64_t v12 = 16LL;
      int v13 = 538;
      goto LABEL_27;
    case 7:
      int v9 = "ACMRequirement - ACMRequirementDataKofN";
      rsize_t v10 = 104LL;
      unsigned int v11 = a1;
      unint64_t v12 = 104LL;
      int v13 = 584;
      goto LABEL_27;
    case 8:
      int v9 = "ACMRequirement - ACMRequirementDataAccessGroups";
      rsize_t v10 = 1040LL;
      unsigned int v11 = a1;
      unint64_t v12 = 1040LL;
      int v13 = 574;
      goto LABEL_27;
    case 13:
      int v9 = "ACMRequirement - ACMRequirementDataUserOutputDisplayed";
      rsize_t v10 = 48LL;
      unsigned int v11 = a1;
      unint64_t v12 = 48LL;
      int v13 = 562;
      goto LABEL_27;
    case 16:
    case 17:
      break;
    case 20:
      int v9 = "ACMRequirement - ACMRequirementDataSecureIntent";
      rsize_t v10 = 20LL;
      unsigned int v11 = a1;
      unint64_t v12 = 20LL;
      int v13 = 554;
      goto LABEL_27;
    case 21:
      int v9 = "ACMRequirement - ACMRequirementDataBiometryMatchAttempted";
      rsize_t v10 = 20LL;
      unsigned int v11 = a1;
      unint64_t v12 = 20LL;
      int v13 = 558;
      goto LABEL_27;
    case 24:
      int v9 = "ACMRequirement - ACMRequirementDataAP";
      rsize_t v10 = 1076LL;
      unsigned int v11 = a1;
      unint64_t v12 = 1076LL;
      int v13 = 566;
      goto LABEL_27;
    case 25:
      int v9 = "ACMRequirement - ACMRequirementDataKeyRef";
      rsize_t v10 = 59LL;
      unsigned int v11 = a1;
      unint64_t v12 = 59LL;
      int v13 = 570;
      goto LABEL_27;
    case 26:
      int v9 = "ACMRequirement - ACMRequirementDataRatchet";
      rsize_t v10 = 44LL;
      unsigned int v11 = a1;
      unint64_t v12 = 44LL;
      int v13 = 579;
LABEL_27:
      acm_mem_free_info( v9,  v11,  v12,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/CommonUtil.c",  v13,  "Util_DeallocRequirement");
      acm_mem_free(a1, v10);
      uint64_t v7 = 0LL;
      unsigned int v8 = 10;
      break;
    default:
      switch(v2)
      {
        case 1000:
          int v9 = "ACMRequirement - ACMRequirementDataKofNWithAttributes";
          rsize_t v10 = 136LL;
          unsigned int v11 = a1;
          unint64_t v12 = 136LL;
          int v13 = 601;
          goto LABEL_27;
        case 1001:
          int v9 = "ACMRequirement - ACMRequirementDataBiometryMatchedWithAttributes";
          rsize_t v10 = 184LL;
          unsigned int v11 = a1;
          unint64_t v12 = 184LL;
          int v13 = 605;
          goto LABEL_27;
        case 1002:
          int v9 = "ACMRequirement - ACMRequirementDataPushButtonWithAttributes";
          rsize_t v10 = 20LL;
          unsigned int v11 = a1;
          unint64_t v12 = 20LL;
          int v13 = 609;
          goto LABEL_27;
        case 1003:
          int v9 = "ACMRequirement - ACMRequirementDataSecureStateWithAttributes";
          rsize_t v10 = 20LL;
          unsigned int v11 = a1;
          unint64_t v12 = 20LL;
          int v13 = 613;
          goto LABEL_27;
        case 1004:
          int v9 = "ACMRequirement - ACMRequirementDataPasscodeValidatedWithAttributes";
          rsize_t v10 = 32LL;
          unsigned int v11 = a1;
          unint64_t v12 = 32LL;
          int v13 = 617;
          goto LABEL_27;
        default:
          goto LABEL_28;
      }
  }

void sub_10008B51C()
{
}

void sub_10008B544()
{
}

uint64_t ACMContextCreate(uint64_t *a1)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    unsigned int v8 = "ACMLib";
    __int16 v9 = 2080;
    rsize_t v10 = "ACMContextCreate";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  buf,  0x16u);
  }

  uint64_t v6 = 0LL;
  uint64_t v2 = LibCall_ACMContextCreate( (uint64_t (*)(uint64_t, uint64_t, void, void, void, _BYTE *, uint64_t *))sub_10008B794,  (uint64_t)&v6,  a1,  &byte_1000DB179,  1);
  if ((_DWORD)v2)
  {
    sub_1000906CC();
    unsigned int v3 = 70;
  }

  else
  {
    unsigned int v3 = 10;
    if (a1 && byte_1000DB179 <= 0x28u)
    {
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
      {
        uint64_t v4 = *a1;
        if (*a1) {
          LODWORD(v4) = *(_DWORD *)(v4 + 16);
        }
        *(_DWORD *)buf = 136315650;
        unsigned int v8 = "ACMLib";
        __int16 v9 = 2080;
        rsize_t v10 = "ACMContextCreate";
        __int16 v11 = 1024;
        LODWORD(v12) = v4;
        _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: CS[%u] created.\n",  buf,  0x1Cu);
      }

      unsigned int v3 = 10;
    }
  }

  if (v3 >= byte_1000DB179 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315650;
    unsigned int v8 = "ACMLib";
    __int16 v9 = 2080;
    rsize_t v10 = "ACMContextCreate";
    __int16 v11 = 2048;
    uint64_t v12 = (int)v2;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning, CFErrorRef err = %ld.\n",  buf,  0x20u);
  }

  return v2;
}

uint64_t sub_10008B794(uint64_t *a1, int a2, char a3, const void *a4, size_t a5, void *a6, size_t *a7)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    int v18 = 136315394;
    uint64_t v19 = "ACMLib";
    __int16 v20 = 2080;
    uint64_t v21 = "ioKitTransport";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  (uint8_t *)&v18,  0x16u);
  }

  if (a1)
  {
    uint64_t v14 = sub_10008BF64();
    unsigned int v15 = 70;
    if ((_DWORD)v14)
    {
      uint64_t v16 = v14;
    }

    else
    {
      uint64_t v16 = sub_10008C144(*a1, a2, a3, a4, a5, a6, a7);
      if ((_DWORD)v16) {
        unsigned int v15 = 70;
      }
      else {
        unsigned int v15 = 10;
      }
    }
  }

  else
  {
    unsigned int v15 = 70;
    uint64_t v16 = 4294967293LL;
  }

  if (v15 >= byte_1000DB179 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    int v18 = 136315650;
    uint64_t v19 = "ACMLib";
    __int16 v20 = 2080;
    uint64_t v21 = "ioKitTransport";
    __int16 v22 = 2048;
    uint64_t v23 = (int)v16;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning, CFErrorRef err = %ld.\n",  (uint8_t *)&v18,  0x20u);
  }

  return v16;
}

_DWORD *ACMContextCreateWithExternalForm(_OWORD *a1, uint64_t a2)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    rsize_t v10 = "ACMLib";
    __int16 v11 = 2080;
    uint64_t v12 = "ACMContextCreateWithExternalForm";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  buf,  0x16u);
  }

  uint64_t v8 = 0LL;
  uint64_t v4 = LibCall_ACMContextCreateWithExternalForm( (uint64_t (*)(uint64_t, uint64_t, void, _OWORD *, uint64_t, void *, uint64_t *))sub_10008B794,  (uint64_t)&v8,  a1,  a2,  &byte_1000DB179,  1);
  if (v4)
  {
    if (byte_1000DB179 <= 0x28u && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
    {
      int v5 = v4[4];
      *(_DWORD *)buf = 136315650;
      rsize_t v10 = "ACMLib";
      __int16 v11 = 2080;
      uint64_t v12 = "ACMContextCreateWithExternalForm";
      __int16 v13 = 1024;
      LODWORD(v14) = v5;
      _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: CS[%u] acquired.\n",  buf,  0x1Cu);
    }

    unsigned int v6 = 30;
  }

  else
  {
    sub_1000906CC();
    unsigned int v6 = 70;
  }

  if (v6 >= byte_1000DB179 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315650;
    rsize_t v10 = "ACMLib";
    __int16 v11 = 2080;
    uint64_t v12 = "ACMContextCreateWithExternalForm";
    __int16 v13 = 2048;
    uint64_t v14 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning, -> ctx = %p.\n",  buf,  0x20u);
  }

  return v4;
}

uint64_t ACMContextDelete(_DWORD *a1, int a2)
{
  unsigned int v4 = byte_1000DB179;
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    uint64_t v12 = "ACMLib";
    __int16 v13 = 2080;
    uint64_t v14 = "ACMContextDelete";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  buf,  0x16u);
    unsigned int v4 = byte_1000DB179;
  }

  if (a1 && v4 <= 0x28 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    int v5 = a1[4];
    unsigned int v6 = "deleted";
    *(_DWORD *)buf = 136315906;
    uint64_t v12 = "ACMLib";
    uint64_t v14 = "ACMContextDelete";
    __int16 v13 = 2080;
    if (a2) {
      unsigned int v6 = "destroyed";
    }
    __int16 v15 = 1024;
    LODWORD(v16[0]) = v5;
    WORD2(v16[0]) = 2080;
    *(void *)((char *)v16 + 6) = v6;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: CS[%u] %s.\n",  buf,  0x26u);
  }

  rsize_t v10 = a1;
  uint64_t v7 = LibCall_ACMContextDelete( (void (*)(uint64_t, uint64_t, void, void *, uint64_t, void, void))sub_10008B794,  (uint64_t)&v10,  a1,  a2);
  if ((_DWORD)v7) {
    unsigned int v8 = 70;
  }
  else {
    unsigned int v8 = 10;
  }
  if (v8 >= byte_1000DB179 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315650;
    uint64_t v12 = "ACMLib";
    __int16 v13 = 2080;
    uint64_t v14 = "ACMContextDelete";
    __int16 v15 = 2048;
    v16[0] = (int)v7;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning, CFErrorRef err = %ld.\n",  buf,  0x20u);
  }

  return v7;
}

void ACMContextGetExternalForm(const void *a1, uint64_t a2)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    int v4 = 136315394;
    int v5 = "ACMLib";
    __int16 v6 = 2080;
    uint64_t v7 = "ACMContextGetExternalForm";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  (uint8_t *)&v4,  0x16u);
  }

  if (!a1
    || !a2
    || sub_10008BF64()
    || sub_10008C144((uint64_t)a1, 19, 0, a1, 0x10uLL, 0LL, 0LL))
  {
    (*(void (**)(uint64_t, void, void))(a2 + 16))(a2, 0LL, 0LL);
  }

  else
  {
    (*(void (**)(uint64_t, const void *, uint64_t))(a2 + 16))(a2, a1, 16LL);
  }

  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    int v4 = 136315394;
    int v5 = "ACMLib";
    __int16 v6 = 2080;
    uint64_t v7 = "ACMContextGetExternalForm";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning.\n",  (uint8_t *)&v4,  0x16u);
  }

uint64_t sub_10008BF64()
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    int v6 = 136315394;
    uint64_t v7 = "ACMLib";
    __int16 v8 = 2080;
    __int16 v9 = "init";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  (uint8_t *)&v6,  0x16u);
  }

  if ((byte_1000DBC8C & 1) != 0)
  {
    uint64_t v0 = 0LL;
  }

  else
  {
    unint64_t v1 = IOServiceMatching("AppleCredentialManager");
    io_service_t MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v1);
    if (!MatchingService)
    {
      unsigned int v4 = 70;
      uint64_t v0 = 4294967291LL;
      goto LABEL_10;
    }

    io_object_t v3 = MatchingService;
    uint64_t v0 = IOServiceOpen(MatchingService, mach_task_self_, 0, (io_connect_t *)&dword_1000DBC88);
    if ((_DWORD)v0)
    {
      unsigned int v4 = 70;
      goto LABEL_10;
    }

    IOObjectRelease(v3);
    byte_1000DBC8C = 1;
  }

  unsigned int v4 = 10;
LABEL_10:
  if (v4 >= byte_1000DB179 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    int v6 = 136315650;
    uint64_t v7 = "ACMLib";
    __int16 v8 = 2080;
    __int16 v9 = "init";
    __int16 v10 = 2048;
    uint64_t v11 = (int)v0;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning, CFErrorRef err = %ld.\n",  (uint8_t *)&v6,  0x20u);
  }

  return v0;
}

uint64_t sub_10008C144(uint64_t a1, int a2, char a3, const void *a4, size_t a5, void *a6, size_t *a7)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    size_t v25 = "ACMLib";
    __int16 v26 = 2080;
    int v27 = "performCommand";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  buf,  0x16u);
  }

  size_t inputStructCnt = 0LL;
  uint64_t v14 = LibCall_BuildCommand(a2, 0, a3, a4, a5, &inputStructCnt);
  if (v14)
  {
    __int16 v15 = v14;
    if (!a6 && a7)
    {
      uint64_t v18 = 4294967293LL;
    }

    else
    {
      if (a7) {
        size_t v16 = *a7;
      }
      else {
        size_t v16 = 0LL;
      }
      size_t v22 = v16;
      uint64_t v17 = IOConnectCallStructMethod(dword_1000DBC88, 0, v14, inputStructCnt, a6, &v22);
      uint64_t v18 = v17;
      if (a1) {
        LODWORD(a1) = *(_DWORD *)(a1 + 16);
      }
      if ((_DWORD)v17)
      {
        if (byte_1000DB179 <= 0x46u
          && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136316418;
          size_t v25 = "ACMLib";
          __int16 v26 = 2080;
          int v27 = "performCommand";
          __int16 v28 = 1024;
          *(_DWORD *)unint64_t v29 = a2;
          *(_WORD *)&v29[4] = 1024;
          *(_DWORD *)&v29[6] = a1;
          __int16 v30 = 1024;
          int v31 = v18;
          __int16 v32 = 1024;
          int v33 = v18;
          _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: cmd(%u) on CS[%u] -> err 0x%x (%d).\n",  buf,  0x2Eu);
        }
      }

      else
      {
        if (byte_1000DB179 <= 0x28u
          && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136315906;
          size_t v25 = "ACMLib";
          __int16 v26 = 2080;
          int v27 = "performCommand";
          __int16 v28 = 1024;
          *(_DWORD *)unint64_t v29 = a2;
          *(_WORD *)&v29[4] = 1024;
          *(_DWORD *)&v29[6] = a1;
          _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: cmd(%u) on CS[%u] -> ok.\n",  buf,  0x22u);
        }

        uint64_t v18 = 0LL;
        if (a7) {
          *a7 = v22;
        }
      }
    }

    rsize_t v19 = inputStructCnt;
    acm_mem_free_info( "<data>",  v15,  inputStructCnt,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/ACMLib/ACMLib.c",  134,  "performCommand");
    acm_mem_free_data(v15, v19);
    if ((_DWORD)v18) {
      unsigned int v20 = 70;
    }
    else {
      unsigned int v20 = 10;
    }
  }

  else
  {
    unsigned int v20 = 70;
    uint64_t v18 = 4294967291LL;
  }

  if (v20 >= byte_1000DB179 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315650;
    size_t v25 = "ACMLib";
    __int16 v26 = 2080;
    int v27 = "performCommand";
    __int16 v28 = 2048;
    *(void *)unint64_t v29 = (int)v18;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning, CFErrorRef err = %ld.\n",  buf,  0x20u);
  }

  return v18;
}

uint64_t ACMContextAddCredential(_OWORD *a1, unsigned int *a2)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    int v5 = 136315394;
    int v6 = "ACMLib";
    __int16 v7 = 2080;
    __int16 v8 = "ACMContextAddCredential";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  (uint8_t *)&v5,  0x16u);
  }

  return ACMContextAddCredentialWithScope(a1, a2, 1);
}

uint64_t ACMContextAddCredentialWithScope(_OWORD *a1, unsigned int *a2, int a3)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    uint64_t v18 = "ACMLib";
    __int16 v19 = 2080;
    unsigned int v20 = "ACMContextAddCredentialWithScope";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  buf,  0x16u);
  }

  size_t __size = 0LL;
  if (a1) {
    BOOL v6 = 1;
  }
  else {
    BOOL v6 = a3 == 2;
  }
  char v7 = !v6;
  unsigned int v8 = 70;
  uint64_t v9 = 4294967293LL;
  if (a2 && (v7 & 1) == 0)
  {
    uint64_t SerializedAddCredentialSize = sub_10008BF64();
    if ((_DWORD)SerializedAddCredentialSize
      || (uint64_t SerializedAddCredentialSize = GetSerializedAddCredentialSize((uint64_t)a1, a2, a3, &__size),
          (_DWORD)SerializedAddCredentialSize))
    {
      uint64_t v9 = SerializedAddCredentialSize;
      unsigned int v8 = 70;
    }

    else
    {
      size_t v11 = __size;
      uint64_t v12 = acm_mem_alloc_data(__size);
      acm_mem_alloc_info( "<data>",  v12,  v11,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/ACMLib/ACMLib.c",  325,  "ACMContextAddCredentialWithScope");
      if (v12)
      {
        uint64_t v13 = SerializeAddCredential(a1, a2, a3, (uint64_t)v12, &__size);
        if (!(_DWORD)v13) {
          uint64_t v13 = sub_10008C144((uint64_t)a1, 5, 0, v12, __size, 0LL, 0LL);
        }
        uint64_t v9 = v13;
        rsize_t v14 = __size;
        acm_mem_free_info( "<data>",  v12,  __size,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/ACMLib/ACMLib.c",  338,  "ACMContextAddCredentialWithScope");
        acm_mem_free_data(v12, v14);
        if ((_DWORD)v9) {
          unsigned int v8 = 70;
        }
        else {
          unsigned int v8 = 10;
        }
      }

      else
      {
        unsigned int v8 = 70;
        uint64_t v9 = 4294967292LL;
      }
    }
  }

  if (v8 >= byte_1000DB179 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315650;
    uint64_t v18 = "ACMLib";
    __int16 v19 = 2080;
    unsigned int v20 = "ACMContextAddCredentialWithScope";
    __int16 v21 = 2048;
    uint64_t v22 = (int)v9;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning, CFErrorRef err = %ld.\n",  buf,  0x20u);
  }

  return v9;
}

uint64_t ACMContextRemoveCredentialsByType(_OWORD *a1, int a2)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    int v5 = 136315394;
    BOOL v6 = "ACMLib";
    __int16 v7 = 2080;
    unsigned int v8 = "ACMContextRemoveCredentialsByType";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  (uint8_t *)&v5,  0x16u);
  }

  return ACMContextRemoveCredentialsByTypeAndScope(a1, a2, 1);
}

uint64_t ACMContextRemoveCredentialsByTypeAndScope(_OWORD *a1, int a2, int a3)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    int v11 = 136315394;
    uint64_t v12 = "ACMLib";
    __int16 v13 = 2080;
    rsize_t v14 = "ACMContextRemoveCredentialsByTypeAndScope";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  (uint8_t *)&v11,  0x16u);
  }

  if (a1 || a3 == 2)
  {
    uint64_t v6 = sub_10008BF64();
    if ((_DWORD)v6)
    {
      uint64_t v8 = v6;
      unsigned int v9 = 70;
    }

    else
    {
      __int16 v7 = acm_mem_alloc_data(0x18uLL);
      acm_mem_alloc_info( "<data>",  v7,  24LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/ACMLib/ACMLib.c",  386,  "ACMContextRemoveCredentialsByTypeAndScope");
      if (v7)
      {
        if (a1)
        {
          *__int16 v7 = *a1;
        }

        else
        {
          *(void *)__int16 v7 = 0LL;
          *((void *)v7 + 1) = 0LL;
        }

        *((_DWORD *)v7 + 4) = a2;
        *((_DWORD *)v7 + 5) = a3;
        uint64_t v8 = sub_10008C144((uint64_t)a1, 9, 0, v7, 0x18uLL, 0LL, 0LL);
        acm_mem_free_info( "<data>",  v7,  0x18uLL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/ACMLib/ACMLib.c",  407,  "ACMContextRemoveCredentialsByTypeAndScope");
        acm_mem_free_data(v7, 0x18uLL);
        if ((_DWORD)v8) {
          unsigned int v9 = 70;
        }
        else {
          unsigned int v9 = 10;
        }
      }

      else
      {
        unsigned int v9 = 70;
        uint64_t v8 = 4294967292LL;
      }
    }
  }

  else
  {
    unsigned int v9 = 70;
    uint64_t v8 = 4294967293LL;
  }

  if (v9 >= byte_1000DB179 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    int v11 = 136315650;
    uint64_t v12 = "ACMLib";
    __int16 v13 = 2080;
    rsize_t v14 = "ACMContextRemoveCredentialsByTypeAndScope";
    __int16 v15 = 2048;
    uint64_t v16 = (int)v8;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning, CFErrorRef err = %ld.\n",  (uint8_t *)&v11,  0x20u);
  }

  return v8;
}

uint64_t ACMContextRemoveCredentialsByValue(uint64_t a1, _DWORD *a2)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    int v5 = 136315394;
    uint64_t v6 = "ACMLib";
    __int16 v7 = 2080;
    uint64_t v8 = "ACMContextRemoveCredentialsByValue";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  (uint8_t *)&v5,  0x16u);
  }

  return ACMContextRemoveCredentialsByValueAndScope(a1, a2, 1LL);
}

uint64_t ACMContextRemoveCredentialsByValueAndScope(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    uint64_t v18 = "ACMLib";
    __int16 v19 = 2080;
    unsigned int v20 = "ACMContextRemoveCredentialsByValueAndScope";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  buf,  0x16u);
  }

  size_t __size = 0LL;
  if (a1) {
    BOOL v6 = 1;
  }
  else {
    BOOL v6 = (_DWORD)a3 == 2;
  }
  char v7 = !v6;
  unsigned int v8 = 70;
  uint64_t v9 = 4294967293LL;
  if (a2 && (v7 & 1) == 0)
  {
    uint64_t v10 = sub_10008BF64();
    if ((_DWORD)v10 || (uint64_t v10 = GetSerializedRemoveCredentialSize(a1, a2, a3, &__size), (_DWORD)v10))
    {
      uint64_t v9 = v10;
      unsigned int v8 = 70;
    }

    else
    {
      size_t v11 = __size;
      uint64_t v12 = acm_mem_alloc_data(__size);
      acm_mem_alloc_info( "<data>",  v12,  v11,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/ACMLib/ACMLib.c",  457,  "ACMContextRemoveCredentialsByValueAndScope");
      if (v12)
      {
        uint64_t v13 = SerializeRemoveCredential(a1, a2, a3, v12, &__size);
        if (!(_DWORD)v13) {
          uint64_t v13 = sub_10008C144(a1, 6, 0, v12, __size, 0LL, 0LL);
        }
        uint64_t v9 = v13;
        rsize_t v14 = __size;
        acm_mem_free_info( "<data>",  v12,  __size,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/ACMLib/ACMLib.c",  470,  "ACMContextRemoveCredentialsByValueAndScope");
        acm_mem_free_data(v12, v14);
        if ((_DWORD)v9) {
          unsigned int v8 = 70;
        }
        else {
          unsigned int v8 = 10;
        }
      }

      else
      {
        unsigned int v8 = 70;
        uint64_t v9 = 4294967292LL;
      }
    }
  }

  if (v8 >= byte_1000DB179 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315650;
    uint64_t v18 = "ACMLib";
    __int16 v19 = 2080;
    unsigned int v20 = "ACMContextRemoveCredentialsByValueAndScope";
    __int16 v21 = 2048;
    uint64_t v22 = (int)v9;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning, CFErrorRef err = %ld.\n",  buf,  0x20u);
  }

  return v9;
}

uint64_t ACMContextContainsCredentialType(_OWORD *a1, int a2)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    int v5 = 136315394;
    BOOL v6 = "ACMLib";
    __int16 v7 = 2080;
    unsigned int v8 = "ACMContextContainsCredentialType";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  (uint8_t *)&v5,  0x16u);
  }

  return ACMContextContainsCredentialTypeEx(a1, a2, 0);
}

uint64_t ACMContextContainsCredentialTypeEx(_OWORD *a1, int a2, int a3)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    uint64_t v16 = "ACMLib";
    __int16 v17 = 2080;
    uint64_t v18 = "ACMContextContainsCredentialTypeEx";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  buf,  0x16u);
  }

  int v14 = 0;
  size_t v13 = 4LL;
  if (a1)
  {
    uint64_t v6 = sub_10008BF64();
    if ((_DWORD)v6)
    {
      uint64_t v11 = v6;
      unsigned int v8 = 70;
    }

    else
    {
      __int16 v7 = acm_mem_alloc_data(0x18uLL);
      acm_mem_alloc_info( "<data>",  v7,  24LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/ACMLib/ACMLib.c",  576,  "ACMContextContainsCredentialTypeEx");
      unsigned int v8 = 70;
      if (v7)
      {
        *(_OWORD *)__int16 v7 = *a1;
        v7[4] = a2;
        v7[5] = a3;
        unsigned int v9 = sub_10008C144((uint64_t)a1, 4, 0, v7, 0x18uLL, &v14, &v13);
        if (v14) {
          unsigned int v10 = 0;
        }
        else {
          unsigned int v10 = -7;
        }
        if (v9) {
          uint64_t v11 = v9;
        }
        else {
          uint64_t v11 = v10;
        }
        acm_mem_free_info( "<data>",  v7,  0x18uLL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/ACMLib/ACMLib.c",  590,  "ACMContextContainsCredentialTypeEx");
        acm_mem_free_data(v7, 0x18uLL);
        if ((_DWORD)v11) {
          unsigned int v8 = 70;
        }
        else {
          unsigned int v8 = 10;
        }
      }

      else
      {
        uint64_t v11 = 4294967292LL;
      }
    }
  }

  else
  {
    unsigned int v8 = 70;
    uint64_t v11 = 4294967293LL;
  }

  if (v8 >= byte_1000DB179 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315650;
    uint64_t v16 = "ACMLib";
    __int16 v17 = 2080;
    uint64_t v18 = "ACMContextContainsCredentialTypeEx";
    __int16 v19 = 2048;
    uint64_t v20 = (int)v11;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning, CFErrorRef err = %ld.\n",  buf,  0x20u);
  }

  return v11;
}

uint64_t ACMGlobalContextAddCredential(unsigned int *a1)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    unsigned int v8 = "ACMLib";
    __int16 v9 = 2080;
    unsigned int v10 = "ACMGlobalContextAddCredential";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  buf,  0x16u);
  }

  uint64_t v6 = 0LL;
  if (a1)
  {
    uint64_t v2 = ACMContextCreate((uint64_t *)&v6);
    if (!(_DWORD)v2) {
      uint64_t v2 = ACMContextAddCredentialWithScope(v6, a1, 2);
    }
    uint64_t v3 = v2;
    if (v6) {
      ACMContextDelete(v6, 1);
    }
    if ((_DWORD)v3) {
      unsigned int v4 = 70;
    }
    else {
      unsigned int v4 = 10;
    }
  }

  else
  {
    unsigned int v4 = 70;
    uint64_t v3 = 4294967293LL;
  }

  if (v4 >= byte_1000DB179 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315650;
    unsigned int v8 = "ACMLib";
    __int16 v9 = 2080;
    unsigned int v10 = "ACMGlobalContextAddCredential";
    __int16 v11 = 2048;
    uint64_t v12 = (int)v3;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning, CFErrorRef err = %ld.\n",  buf,  0x20u);
  }

  return v3;
}

uint64_t ACMGlobalContextRemoveCredentialsByType(int a1)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    unsigned int v8 = "ACMLib";
    __int16 v9 = 2080;
    unsigned int v10 = "ACMGlobalContextRemoveCredentialsByType";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  buf,  0x16u);
  }

  uint64_t v6 = 0LL;
  uint64_t v2 = ACMContextCreate((uint64_t *)&v6);
  if (!(_DWORD)v2) {
    uint64_t v2 = ACMContextRemoveCredentialsByTypeAndScope(v6, a1, 2);
  }
  uint64_t v3 = v2;
  if (v6) {
    ACMContextDelete(v6, 1);
  }
  if ((_DWORD)v3) {
    unsigned int v4 = 70;
  }
  else {
    unsigned int v4 = 10;
  }
  if (v4 >= byte_1000DB179 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315650;
    unsigned int v8 = "ACMLib";
    __int16 v9 = 2080;
    unsigned int v10 = "ACMGlobalContextRemoveCredentialsByType";
    __int16 v11 = 2048;
    uint64_t v12 = (int)v3;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning, CFErrorRef err = %ld.\n",  buf,  0x20u);
  }

  return v3;
}

uint64_t ACMContextRemovePassphraseCredentialsByPurposeAndScope(_OWORD *a1, int a2, int a3)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    int v11 = 136315394;
    uint64_t v12 = "ACMLib";
    __int16 v13 = 2080;
    int v14 = "ACMContextRemovePassphraseCredentialsByPurposeAndScope";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  (uint8_t *)&v11,  0x16u);
  }

  if (a1 || a3 == 2)
  {
    uint64_t v6 = sub_10008BF64();
    if ((_DWORD)v6)
    {
      uint64_t v8 = v6;
      unsigned int v9 = 70;
    }

    else
    {
      __int16 v7 = acm_mem_alloc_data(0x18uLL);
      acm_mem_alloc_info( "<data>",  v7,  24LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/ACMLib/ACMLib.c",  492,  "ACMContextRemovePassphraseCredentialsByPurposeAndScope");
      if (v7)
      {
        if (a1)
        {
          *__int16 v7 = *a1;
        }

        else
        {
          *(void *)__int16 v7 = 0LL;
          *((void *)v7 + 1) = 0LL;
        }

        *((_DWORD *)v7 + 4) = a2;
        *((_DWORD *)v7 + 5) = a3;
        uint64_t v8 = sub_10008C144((uint64_t)a1, 16, 0, v7, 0x18uLL, 0LL, 0LL);
        acm_mem_free_info( "<data>",  v7,  0x18uLL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/ACMLib/ACMLib.c",  513,  "ACMContextRemovePassphraseCredentialsByPurposeAndScope");
        acm_mem_free_data(v7, 0x18uLL);
        if ((_DWORD)v8) {
          unsigned int v9 = 70;
        }
        else {
          unsigned int v9 = 10;
        }
      }

      else
      {
        unsigned int v9 = 70;
        uint64_t v8 = 4294967292LL;
      }
    }
  }

  else
  {
    unsigned int v9 = 70;
    uint64_t v8 = 4294967293LL;
  }

  if (v9 >= byte_1000DB179 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    int v11 = 136315650;
    uint64_t v12 = "ACMLib";
    __int16 v13 = 2080;
    int v14 = "ACMContextRemovePassphraseCredentialsByPurposeAndScope";
    __int16 v15 = 2048;
    uint64_t v16 = (int)v8;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning, CFErrorRef err = %ld.\n",  (uint8_t *)&v11,  0x20u);
  }

  return v8;
}

uint64_t ACMContextReplacePassphraseCredentialsWithScope(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    uint64_t v18 = "ACMLib";
    __int16 v19 = 2080;
    uint64_t v20 = "ACMContextReplacePassphraseCredentialsWithScope";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  buf,  0x16u);
  }

  size_t __size = 0LL;
  if (a1) {
    BOOL v6 = 1;
  }
  else {
    BOOL v6 = (_DWORD)a3 == 2;
  }
  char v7 = !v6;
  unsigned int v8 = 70;
  uint64_t v9 = 4294967293LL;
  if (a2 && (v7 & 1) == 0)
  {
    uint64_t SerializedReplacePassphraseCredentialSize = sub_10008BF64();
    if ((_DWORD)SerializedReplacePassphraseCredentialSize
      || (uint64_t SerializedReplacePassphraseCredentialSize = GetSerializedReplacePassphraseCredentialSize(a1, a2, a3, &__size),
          (_DWORD)SerializedReplacePassphraseCredentialSize))
    {
      uint64_t v9 = SerializedReplacePassphraseCredentialSize;
      unsigned int v8 = 70;
    }

    else
    {
      size_t v11 = __size;
      uint64_t v12 = acm_mem_alloc_data(__size);
      acm_mem_alloc_info( "<data>",  v12,  v11,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/ACMLib/ACMLib.c",  538,  "ACMContextReplacePassphraseCredentialsWithScope");
      if (v12)
      {
        uint64_t v13 = SerializeReplacePassphraseCredential(a1, a2, a3, v12, &__size);
        if (!(_DWORD)v13) {
          uint64_t v13 = sub_10008C144(a1, 15, 0, v12, __size, 0LL, 0LL);
        }
        uint64_t v9 = v13;
        bzero(v12, __size);
        rsize_t v14 = __size;
        acm_mem_free_info( "<data>",  v12,  __size,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/ACMLib/ACMLib.c",  552,  "ACMContextReplacePassphraseCredentialsWithScope");
        acm_mem_free_data(v12, v14);
        if ((_DWORD)v9) {
          unsigned int v8 = 70;
        }
        else {
          unsigned int v8 = 10;
        }
      }

      else
      {
        unsigned int v8 = 70;
        uint64_t v9 = 4294967292LL;
      }
    }
  }

  if (v8 >= byte_1000DB179 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315650;
    uint64_t v18 = "ACMLib";
    __int16 v19 = 2080;
    uint64_t v20 = "ACMContextReplacePassphraseCredentialsWithScope";
    __int16 v21 = 2048;
    uint64_t v22 = (int)v9;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning, CFErrorRef err = %ld.\n",  buf,  0x20u);
  }

  return v9;
}

uint64_t ACMContextContainsPassphraseCredentialWithPurpose(_OWORD *a1, int a2, int a3)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    uint64_t v16 = "ACMLib";
    __int16 v17 = 2080;
    uint64_t v18 = "ACMContextContainsPassphraseCredentialWithPurpose";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  buf,  0x16u);
  }

  int v14 = 0;
  size_t v13 = 4LL;
  if (a1)
  {
    uint64_t v6 = sub_10008BF64();
    if ((_DWORD)v6)
    {
      uint64_t v11 = v6;
      unsigned int v8 = 70;
    }

    else
    {
      char v7 = acm_mem_alloc_data(0x18uLL);
      acm_mem_alloc_info( "<data>",  v7,  24LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/ACMLib/ACMLib.c",  614,  "ACMContextContainsPassphraseCredentialWithPurpose");
      unsigned int v8 = 70;
      if (v7)
      {
        *(_OWORD *)char v7 = *a1;
        v7[4] = a2;
        v7[5] = a3;
        unsigned int v9 = sub_10008C144((uint64_t)a1, 13, 0, v7, 0x18uLL, &v14, &v13);
        if (v14) {
          unsigned int v10 = 0;
        }
        else {
          unsigned int v10 = -7;
        }
        if (v9) {
          uint64_t v11 = v9;
        }
        else {
          uint64_t v11 = v10;
        }
        acm_mem_free_info( "<data>",  v7,  0x18uLL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/ACMLib/ACMLib.c",  628,  "ACMContextContainsPassphraseCredentialWithPurpose");
        acm_mem_free_data(v7, 0x18uLL);
        if ((_DWORD)v11) {
          unsigned int v8 = 70;
        }
        else {
          unsigned int v8 = 10;
        }
      }

      else
      {
        uint64_t v11 = 4294967292LL;
      }
    }
  }

  else
  {
    unsigned int v8 = 70;
    uint64_t v11 = 4294967293LL;
  }

  if (v8 >= byte_1000DB179 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315650;
    uint64_t v16 = "ACMLib";
    __int16 v17 = 2080;
    uint64_t v18 = "ACMContextContainsPassphraseCredentialWithPurpose";
    __int16 v19 = 2048;
    uint64_t v20 = (int)v11;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning, CFErrorRef err = %ld.\n",  buf,  0x20u);
  }

  return v11;
}

uint64_t ACMContextVerifyPolicy(_OWORD *a1, char *a2, uint64_t a3)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    uint64_t v11 = "ACMLib";
    __int16 v12 = 2080;
    size_t v13 = "ACMContextVerifyPolicy";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  buf,  0x16u);
  }

  unsigned int v9 = a1;
  uint64_t v6 = LibCall_ACMContextVerifyPolicy_Block( (uint64_t (*)(uint64_t, uint64_t, void, _OWORD *, size_t, unsigned int *, unint64_t *))sub_10008B794,  (uint64_t)&v9,  a1,  a2,  a3);
  if ((_DWORD)v6) {
    unsigned int v7 = 70;
  }
  else {
    unsigned int v7 = 10;
  }
  if (v7 >= byte_1000DB179 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315650;
    uint64_t v11 = "ACMLib";
    __int16 v12 = 2080;
    size_t v13 = "ACMContextVerifyPolicy";
    __int16 v14 = 2048;
    uint64_t v15 = (int)v6;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning, CFErrorRef err = %ld.\n",  buf,  0x20u);
  }

  return v6;
}

uint64_t ACMContextVerifyPolicyWithPreflight(_OWORD *a1, char *__s1, uint64_t a3, uint64_t a4)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    size_t v13 = "ACMLib";
    __int16 v14 = 2080;
    uint64_t v15 = "ACMContextVerifyPolicyWithPreflight";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  buf,  0x16u);
  }

  uint64_t v11 = a1;
  uint64_t v8 = LibCall_ACMContextVerifyPolicyWithPreflight_Block( (uint64_t (*)(uint64_t, uint64_t, void, _OWORD *, size_t, unsigned int *, unint64_t *))sub_10008B794,  (uint64_t)&v11,  a1,  __s1,  a3,  a4);
  if ((_DWORD)v8) {
    unsigned int v9 = 70;
  }
  else {
    unsigned int v9 = 10;
  }
  if (v9 >= byte_1000DB179 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315650;
    size_t v13 = "ACMLib";
    __int16 v14 = 2080;
    uint64_t v15 = "ACMContextVerifyPolicyWithPreflight";
    __int16 v16 = 2048;
    uint64_t v17 = (int)v8;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning, CFErrorRef err = %ld.\n",  buf,  0x20u);
  }

  return v8;
}

void ACMContextVerifyPolicyEx( _OWORD *a1, char *__s1, uint64_t a3, _DWORD *a4, unsigned int a5, uint64_t a6, uint64_t a7)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    __int16 v16 = "ACMLib";
    __int16 v17 = 2080;
    uint64_t v18 = "ACMContextVerifyPolicyEx";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  buf,  0x16u);
  }

  __int16 v14 = a1;
  LibCall_ACMContextVerifyPolicyEx_Block( (uint64_t (*)(uint64_t, uint64_t, void, _OWORD *, size_t, unsigned int *, unint64_t *))sub_10008B794,  (uint64_t)&v14,  a1,  __s1,  a3,  a4,  a5,  a6,  a7);
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    __int16 v16 = "ACMLib";
    __int16 v17 = 2080;
    uint64_t v18 = "ACMContextVerifyPolicyEx";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning.\n",  buf,  0x16u);
  }

void ACMGlobalContextVerifyPolicy(char *a1, uint64_t a2, _DWORD *a3, unsigned int a4, uint64_t a5)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    size_t v13 = "ACMLib";
    __int16 v14 = 2080;
    uint64_t v15 = "ACMGlobalContextVerifyPolicy";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  buf,  0x16u);
  }

  *(void *)uint64_t v11 = 0LL;
  uint64_t v10 = ACMContextCreate((uint64_t *)v11);
  if ((_DWORD)v10)
  {
    if (a5) {
      (*(void (**)(uint64_t, uint64_t, void, void))(a5 + 16))(a5, v10, 0LL, 0LL);
    }
  }

  else
  {
    ACMContextVerifyPolicyEx(*(_OWORD **)v11, a1, a2, a3, a4, 0xFFFFFFFFLL, a5);
  }

  if (*(void *)v11) {
    ACMContextDelete(*(_DWORD **)v11, 1);
  }
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    size_t v13 = "ACMLib";
    __int16 v14 = 2080;
    uint64_t v15 = "ACMGlobalContextVerifyPolicy";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning.\n",  buf,  0x16u);
  }

uint64_t ACMContextVerifyAclConstraint( _OWORD *a1, const void *a2, uint64_t a3, unsigned __int8 a4, _DWORD *a5, unsigned int a6, unsigned int a7, uint64_t a8)
{
  unsigned int v9 = a1;
  return LibCall_ACMContextVerifyAclConstraint((uint64_t)sub_10008B794, (uint64_t)&v9, a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t ACMContextVerifyAclConstraintForOperation( _OWORD *a1, const void *a2, uint64_t a3, const void *a4, unsigned int a5, unsigned __int8 a6, _DWORD *a7, unsigned int a8, unsigned int a9, uint64_t a10)
{
  uint64_t v11 = a1;
  return LibCall_ACMContextVerifyAclConstraintForOperation( (uint64_t)sub_10008B794,  (uint64_t)&v11,  a1,  a2,  a3,  a4,  a5,  a6,  a7,  a8,  a9,  a10);
}

uint64_t ACMContextGetTrackingNumber(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 16);
  }
  return result;
}

uint64_t ACMParseAclAndCopyConstraintCharacteristics(const void *a1, uint64_t a2, uint64_t a3)
{
  size_t __n = 4096LL;
  size_t __size = 0LL;
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    uint64_t v22 = "ACMLib";
    __int16 v23 = 2080;
    BOOL v24 = "ACMParseAclAndCopyConstraintCharacteristics";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  buf,  0x16u);
  }

  uint64_t v6 = 4294967293LL;
  if (!a1 || !a2 || !a3) {
    goto LABEL_28;
  }
  uint64_t SerializedProcessAclSize = sub_10008BF64();
  if ((_DWORD)SerializedProcessAclSize
    || (uint64_t SerializedProcessAclSize = GetSerializedProcessAclSize(0LL, (uint64_t)a1, a2, 0LL, 0, 0LL, 0LL, 0, &__size),
        (_DWORD)SerializedProcessAclSize))
  {
    uint64_t v6 = SerializedProcessAclSize;
LABEL_28:
    (*(void (**)(uint64_t, uint64_t, void, uint64_t))(a3 + 16))(a3, v6, 0LL, 4096LL);
    goto LABEL_19;
  }

  size_t v8 = __size;
  unsigned int v9 = acm_mem_alloc_data(__size);
  acm_mem_alloc_info( "<data>",  v9,  v8,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/ACMLib/ACMLib.c",  744,  "ACMParseAclAndCopyConstraintCharacteristics");
  if (!v9)
  {
    uint64_t v6 = 4294967292LL;
    goto LABEL_28;
  }

  uint64_t v10 = SerializeProcessAcl(0LL, a1, a2, 0LL, 0, 0LL, 0LL, 0, (uint64_t)v9, &__size);
  if ((_DWORD)v10)
  {
    uint64_t v6 = v10;
    __int16 v12 = 0LL;
    __int16 v14 = 0LL;
    size_t v11 = 4096LL;
    goto LABEL_15;
  }

  size_t v11 = 4096LL;
  __int16 v12 = acm_mem_alloc_data(0x1000uLL);
  acm_mem_alloc_info( "<data>",  v12,  4096LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/ACMLib/ACMLib.c",  750,  "ACMParseAclAndCopyConstraintCharacteristics");
  if (!v12)
  {
    __int16 v14 = 0LL;
LABEL_31:
    uint64_t v6 = 4294967292LL;
    goto LABEL_15;
  }

  uint64_t v13 = sub_10008C144(0LL, 20, 0, v9, __size, v12, &__n);
  size_t v11 = __n;
  if ((_DWORD)v13)
  {
    uint64_t v6 = v13;
    __int16 v14 = 0LL;
    goto LABEL_15;
  }

  __int16 v14 = acm_mem_alloc_data(__n);
  acm_mem_alloc_info( "<data>",  v14,  v11,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/ACMLib/ACMLib.c",  756,  "ACMParseAclAndCopyConstraintCharacteristics");
  size_t v11 = __n;
  if (!v14) {
    goto LABEL_31;
  }
  memcpy(v14, v12, __n);
  uint64_t v6 = 0LL;
  size_t v11 = __n;
LABEL_15:
  (*(void (**)(uint64_t, uint64_t, void *, size_t))(a3 + 16))(a3, v6, v14, v11);
  rsize_t v15 = __size;
  acm_mem_free_info( "<data>",  v9,  __size,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/ACMLib/ACMLib.c",  767,  "ACMParseAclAndCopyConstraintCharacteristics");
  acm_mem_free_data(v9, v15);
  if (v12)
  {
    acm_mem_free_info( "<data>",  v12,  0x1000uLL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/ACMLib/ACMLib.c",  770,  "ACMParseAclAndCopyConstraintCharacteristics");
    acm_mem_free_data(v12, 0x1000uLL);
  }

  if (v14)
  {
    rsize_t v16 = __n;
    acm_mem_free_info( "<data>",  v14,  __n,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/ACMLib/ACMLib.c",  773,  "ACMParseAclAndCopyConstraintCharacteristics");
    acm_mem_free_data(v14, v16);
  }

uint64_t ACMCredentialGetProperty(int *a1, int a2, uint64_t a3)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    __int16 v12 = "ACMLib";
    __int16 v13 = 2080;
    __int16 v14 = "ACMCredentialGetProperty";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  buf,  0x16u);
  }

  uint64_t v9 = 0LL;
  uint64_t v10 = 0LL;
  unsigned int v6 = 70;
  uint64_t v7 = 4294967293LL;
  if (a1 && a3)
  {
    uint64_t v7 = LibCall_ACMCredentialGetPropertyData(a1, a2, &v10, &v9);
    if ((_DWORD)v7)
    {
      unsigned int v6 = 70;
    }

    else
    {
      (*(void (**)(uint64_t, int *, uint64_t))(a3 + 16))(a3, v10, v9);
      unsigned int v6 = 10;
    }
  }

  if (v6 >= byte_1000DB179 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315650;
    __int16 v12 = "ACMLib";
    __int16 v13 = 2080;
    __int16 v14 = "ACMCredentialGetProperty";
    __int16 v15 = 2048;
    uint64_t v16 = (int)v7;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning, CFErrorRef err = %ld.\n",  buf,  0x20u);
  }

  return v7;
}

void ACMRequirementGetSubrequirements(int *a1, uint64_t a2)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    int v8 = 136315394;
    uint64_t v9 = "ACMLib";
    __int16 v10 = 2080;
    size_t v11 = "ACMRequirementGetSubrequirements";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  (uint8_t *)&v8,  0x16u);
  }

  if (a1 && a2)
  {
    int v4 = *a1;
    if (*a1 == 4)
    {
      if (a1[4])
      {
        unint64_t v6 = 0LL;
        do
          (*(void (**)(uint64_t, void))(a2 + 16))(a2, *(void *)&a1[2 * v6++ + 5]);
        while (v6 < a1[4]);
      }
    }

    else if (v4 == 5)
    {
      if (a1[4])
      {
        unint64_t v7 = 0LL;
        do
          (*(void (**)(uint64_t, void))(a2 + 16))(a2, *(void *)&a1[2 * v7++ + 5]);
        while (v7 < a1[4]);
      }
    }

    else if (v4 == 7 && a1[5])
    {
      unint64_t v5 = 0LL;
      do
        (*(void (**)(uint64_t, void))(a2 + 16))(a2, *(void *)&a1[2 * v5++ + 6]);
      while (v5 < a1[5]);
    }
  }

  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    int v8 = 136315394;
    uint64_t v9 = "ACMLib";
    __int16 v10 = 2080;
    size_t v11 = "ACMRequirementGetSubrequirements";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning.\n",  (uint8_t *)&v8,  0x16u);
  }

uint64_t ACMRequirementGetProperty(int *a1, int a2, uint64_t a3)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    __int16 v12 = "ACMLib";
    __int16 v13 = 2080;
    __int16 v14 = "ACMRequirementGetProperty";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  buf,  0x16u);
  }

  unint64_t v9 = 0LL;
  __int16 v10 = 0LL;
  unsigned int v6 = 70;
  uint64_t v7 = 4294967293LL;
  if (a1 && a3)
  {
    uint64_t v7 = LibCall_ACMRequirementGetPropertyData(a1, a2, &v10, &v9);
    if ((_DWORD)v7)
    {
      unsigned int v6 = 70;
    }

    else
    {
      (*(void (**)(uint64_t, int *, unint64_t))(a3 + 16))(a3, v10, v9);
      unsigned int v6 = 10;
    }
  }

  if (v6 >= byte_1000DB179 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315650;
    __int16 v12 = "ACMLib";
    __int16 v13 = 2080;
    __int16 v14 = "ACMRequirementGetProperty";
    __int16 v15 = 2048;
    uint64_t v16 = (int)v7;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning, CFErrorRef err = %ld.\n",  buf,  0x20u);
  }

  return v7;
}

uint64_t ACMRequirementGetProperties(int *a1, uint64_t a2)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    int v8 = 136315394;
    unint64_t v9 = "ACMLib";
    __int16 v10 = 2080;
    size_t v11 = "ACMRequirementGetProperties";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  (uint8_t *)&v8,  0x16u);
  }

  uint64_t v4 = 4294967293LL;
  unsigned int v5 = 70;
  if (a1 && a2)
  {
    (*(void (**)(uint64_t, uint64_t, int *, uint64_t))(a2 + 16))(a2, 1LL, a1, 4LL);
    (*(void (**)(uint64_t, uint64_t, int *, uint64_t))(a2 + 16))(a2, 2LL, a1 + 1, 4LL);
    (*(void (**)(uint64_t, uint64_t, int *, uint64_t))(a2 + 16))(a2, 3LL, a1 + 2, 4LL);
    uint64_t v4 = 0LL;
    int v6 = *a1;
    unsigned int v5 = 10;
    switch(*a1)
    {
      case 1:
        goto LABEL_10;
      case 2:
        (*(void (**)(uint64_t, uint64_t, int *, uint64_t))(a2 + 16))(a2, 200LL, a1 + 4, 4LL);
        goto LABEL_13;
      case 3:
        (*(void (**)(uint64_t, uint64_t, int *, uint64_t))(a2 + 16))(a2, 100LL, a1 + 4, 4LL);
        (*(void (**)(uint64_t, uint64_t, int *, uint64_t))(a2 + 16))(a2, 300LL, a1 + 5, 8LL);
        (*(void (**)(uint64_t, uint64_t, int *, uint64_t))(a2 + 16))(a2, 302LL, a1 + 9, 8LL);
        (*(void (**)(uint64_t, uint64_t, int *, uint64_t))(a2 + 16))(a2, 301LL, a1 + 13, 8LL);
        goto LABEL_13;
      case 4:
      case 5:
      case 6:
        break;
      case 7:
        (*(void (**)(uint64_t, uint64_t, int *, uint64_t))(a2 + 16))(a2, 700LL, a1 + 4, 4LL);
        goto LABEL_13;
      default:
        if (v6 != 20 && v6 != 21) {
          break;
        }
LABEL_10:
        (*(void (**)(uint64_t, uint64_t, int *, uint64_t))(a2 + 16))(a2, 100LL, a1 + 4, 4LL);
LABEL_13:
        uint64_t v4 = 0LL;
        unsigned int v5 = 10;
        break;
    }
  }

  if (v5 >= byte_1000DB179 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    int v8 = 136315650;
    unint64_t v9 = "ACMLib";
    __int16 v10 = 2080;
    size_t v11 = "ACMRequirementGetProperties";
    __int16 v12 = 2048;
    uint64_t v13 = (int)v4;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning, CFErrorRef err = %ld.\n",  (uint8_t *)&v8,  0x20u);
  }

  return v4;
}

void ACMGetAclAuthMethod(__n128 *a1, uint64_t a2)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    int v6 = "ACMLib";
    __int16 v7 = 2080;
    int v8 = "ACMGetAclAuthMethod";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  buf,  0x16u);
  }

  uint64_t v4 = a1;
  LibCall_ACMGetAclAuthMethod_Block((uint64_t)sub_10008B794, (uint64_t)&v4, a1, a2);
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    int v6 = "ACMLib";
    __int16 v7 = 2080;
    int v8 = "ACMGetAclAuthMethod";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning.\n",  buf,  0x16u);
  }

uint64_t ACMSetEnvironmentVariable(int a1, const void *a2, size_t a3)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    size_t v11 = "ACMLib";
    __int16 v12 = 2080;
    uint64_t v13 = "ACMSetEnvironmentVariable";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  buf,  0x16u);
  }

  uint64_t v9 = 0LL;
  uint64_t v6 = LibCall_ACMSetEnvironmentVariable( (uint64_t (*)(uint64_t, uint64_t, void, char *, size_t, void, void))sub_10008B794,  (uint64_t)&v9,  a1,  0LL,  0LL,  0LL,  a2,  a3);
  if ((_DWORD)v6) {
    unsigned int v7 = 70;
  }
  else {
    unsigned int v7 = 10;
  }
  if (v7 >= byte_1000DB179 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315906;
    size_t v11 = "ACMLib";
    __int16 v12 = 2080;
    uint64_t v13 = "ACMSetEnvironmentVariable";
    __int16 v14 = 2048;
    uint64_t v15 = (int)v6;
    __int16 v16 = 1024;
    int v17 = a1;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning, CFErrorRef err = %ld, var=%u.\n",  buf,  0x26u);
  }

  return v6;
}

uint64_t ACMSetEnvironmentVariableWithAccessPolicy( int a1, _OWORD *a2, _OWORD *a3, uint64_t a4, const void *a5, size_t a6)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    int v17 = "ACMLib";
    __int16 v18 = 2080;
    __int16 v19 = "ACMSetEnvironmentVariableWithAccessPolicy";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  buf,  0x16u);
  }

  uint64_t v15 = 0LL;
  uint64_t v12 = LibCall_ACMSetEnvironmentVariable( (uint64_t (*)(uint64_t, uint64_t, void, char *, size_t, void, void))sub_10008B794,  (uint64_t)&v15,  a1,  a2,  a3,  a4,  a5,  a6);
  if ((_DWORD)v12) {
    unsigned int v13 = 70;
  }
  else {
    unsigned int v13 = 10;
  }
  if (v13 >= byte_1000DB179 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315906;
    int v17 = "ACMLib";
    __int16 v18 = 2080;
    __int16 v19 = "ACMSetEnvironmentVariableWithAccessPolicy";
    __int16 v20 = 2048;
    uint64_t v21 = (int)v12;
    __int16 v22 = 1024;
    int v23 = a1;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning, CFErrorRef err = %ld, var=%u.\n",  buf,  0x26u);
  }

  return v12;
}

uint64_t ACMGetEnvironmentVariable(int a1, uint64_t a2)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    uint64_t v9 = "ACMLib";
    __int16 v10 = 2080;
    size_t v11 = "ACMGetEnvironmentVariable";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  buf,  0x16u);
  }

  uint64_t v7 = 0LL;
  uint64_t v4 = LibCall_ACMGetEnvironmentVariable_Block( (uint64_t (*)(uint64_t, uint64_t, void, int *, uint64_t, uint64_t, uint64_t))sub_10008B794,  (uint64_t)&v7,  a1,  a2);
  if ((_DWORD)v4) {
    unsigned int v5 = 70;
  }
  else {
    unsigned int v5 = 10;
  }
  if (v5 >= byte_1000DB179 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315906;
    uint64_t v9 = "ACMLib";
    __int16 v10 = 2080;
    size_t v11 = "ACMGetEnvironmentVariable";
    __int16 v12 = 2048;
    uint64_t v13 = (int)v4;
    __int16 v14 = 1024;
    int v15 = a1;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning, CFErrorRef err = %ld, var=%u.\n",  buf,  0x26u);
  }

  return v4;
}

uint64_t ACMKernelControl(int a1, const void *a2, size_t a3, uint64_t a4)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    uint64_t v13 = "ACMLib";
    __int16 v14 = 2080;
    int v15 = "ACMKernelControl";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  buf,  0x16u);
  }

  uint64_t v11 = 0LL;
  uint64_t v8 = LibCall_ACMKernelControl_Block( (uint64_t (*)(uint64_t, uint64_t, void, char *, size_t, uint64_t, uint64_t))sub_10008B794,  (uint64_t)&v11,  a1,  a2,  a3,  a4);
  if ((_DWORD)v8) {
    unsigned int v9 = 70;
  }
  else {
    unsigned int v9 = 10;
  }
  if (v9 >= byte_1000DB179 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315906;
    uint64_t v13 = "ACMLib";
    __int16 v14 = 2080;
    int v15 = "ACMKernelControl";
    __int16 v16 = 2048;
    uint64_t v17 = (int)v8;
    __int16 v18 = 1024;
    int v19 = a1;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning, CFErrorRef err = %ld, code=%u.\n",  buf,  0x26u);
  }

  return v8;
}

uint64_t ACMSEPControl(const void *a1, size_t a2, uint64_t a3)
{
  uint64_t v4 = 0LL;
  return LibCall_ACMSEPControl_Block( (uint64_t (*)(uint64_t, uint64_t, void, char *, uint64_t, unsigned int *, unint64_t *))sub_10008B794,  (uint64_t)&v4,  a1,  a2,  0LL,  0LL,  0,  a3);
}

uint64_t ACMSEPControlEx(uint64_t a1, _DWORD *a2, unsigned int a3, const void *a4, size_t a5, uint64_t a6)
{
  uint64_t v7 = 0LL;
  return LibCall_ACMSEPControl_Block( (uint64_t (*)(uint64_t, uint64_t, void, char *, uint64_t, unsigned int *, unint64_t *))sub_10008B794,  (uint64_t)&v7,  a4,  a5,  a1,  a2,  a3,  a6);
}

void ACMGlobalContextCredentialGetProperty(int a1, int a2, uint64_t a3)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    uint64_t v8 = "ACMLib";
    __int16 v9 = 2080;
    __int16 v10 = "ACMGlobalContextCredentialGetProperty";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  buf,  0x16u);
  }

  uint64_t v6 = 0LL;
  LibCall_ACMGlobalContextCredentialGetProperty_Block((uint64_t)sub_10008B794, (uint64_t)&v6, a1, a2, a3);
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    uint64_t v8 = "ACMLib";
    __int16 v9 = 2080;
    __int16 v10 = "ACMGlobalContextCredentialGetProperty";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning.\n",  buf,  0x16u);
  }

void ACMContextCredentialGetProperty(__n128 *a1, unsigned __int32 a2, unsigned __int32 a3, uint64_t a4)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    __int16 v16 = "ACMLib";
    __int16 v17 = 2080;
    __int16 v18 = "ACMContextCredentialGetProperty";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  buf,  0x16u);
  }

  uint64_t v10 = 256LL;
  if (a4)
  {
    __int16 v9 = a1;
    uint64_t v8 = LibCall_ACMContextCredentialGetProperty( (uint64_t (*)(uint64_t, uint64_t, void, __n128 *, uint64_t, uint64_t, uint64_t, __n128))sub_10008B794,  (uint64_t)&v9,  a1,  a2,  a3,  (uint64_t)buf,  (uint64_t)&v10);
    (*(void (**)(uint64_t, uint64_t, uint8_t *, uint64_t))(a4 + 16))(a4, v8, buf, v10);
  }

  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)uint64_t v11 = 136315394;
    __int16 v12 = "ACMLib";
    __int16 v13 = 2080;
    __int16 v14 = "ACMContextCredentialGetProperty";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning.\n",  v11,  0x16u);
  }

uint64_t ACMContextSetData(_OWORD *a1, int a2, const void *a3, size_t a4)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    int v11 = 136315394;
    __int16 v12 = "ACMLib";
    __int16 v13 = 2080;
    __int16 v14 = "ACMContextSetData";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  (uint8_t *)&v11,  0x16u);
  }

  uint64_t v8 = ACMContextSetDataEx(a1, a2, 0LL, 0, a3, a4);
  if ((_DWORD)v8) {
    unsigned int v9 = 70;
  }
  else {
    unsigned int v9 = 10;
  }
  if (v9 >= byte_1000DB179 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    int v11 = 136315650;
    __int16 v12 = "ACMLib";
    __int16 v13 = 2080;
    __int16 v14 = "ACMContextSetData";
    __int16 v15 = 2048;
    uint64_t v16 = (int)v8;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning, CFErrorRef err = %ld.\n",  (uint8_t *)&v11,  0x20u);
  }

  return v8;
}

uint64_t ACMContextSetDataEx(_OWORD *a1, int a2, _DWORD *a3, unsigned int a4, const void *a5, size_t a6)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    __int16 v17 = "ACMLib";
    __int16 v18 = 2080;
    int v19 = "ACMContextSetDataEx";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  buf,  0x16u);
  }

  __int16 v15 = a1;
  uint64_t v12 = LibCall_ACMContextSetData( (uint64_t (*)(uint64_t, uint64_t, void, void *, size_t, void, void))sub_10008B794,  (uint64_t)&v15,  a1,  a2,  a3,  a4,  a5,  a6);
  if ((_DWORD)v12) {
    unsigned int v13 = 70;
  }
  else {
    unsigned int v13 = 10;
  }
  if (v13 >= byte_1000DB179 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315650;
    __int16 v17 = "ACMLib";
    __int16 v18 = 2080;
    int v19 = "ACMContextSetDataEx";
    __int16 v20 = 2048;
    uint64_t v21 = (int)v12;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning, CFErrorRef err = %ld.\n",  buf,  0x20u);
  }

  return v12;
}

uint64_t ACMContextGetData(_OWORD *a1, int a2, uint64_t a3)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    int v9 = 136315394;
    uint64_t v10 = "ACMLib";
    __int16 v11 = 2080;
    uint64_t v12 = "ACMContextGetData";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  (uint8_t *)&v9,  0x16u);
  }

  uint64_t Data = ACMContextGetDataEx(a1, a2, 0LL, 0, a3);
  if ((_DWORD)Data) {
    unsigned int v7 = 70;
  }
  else {
    unsigned int v7 = 10;
  }
  if (v7 >= byte_1000DB179 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    int v9 = 136315650;
    uint64_t v10 = "ACMLib";
    __int16 v11 = 2080;
    uint64_t v12 = "ACMContextGetData";
    __int16 v13 = 2048;
    uint64_t v14 = (int)Data;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning, CFErrorRef err = %ld.\n",  (uint8_t *)&v9,  0x20u);
  }

  return Data;
}

uint64_t ACMContextGetDataEx(_OWORD *a1, int a2, _DWORD *a3, unsigned int a4, uint64_t a5)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    int __size_4 = 136315394;
    BOOL v24 = "ACMLib";
    __int16 v25 = 2080;
    uint64_t v26 = "ACMContextGetDataEx";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  (uint8_t *)&__size_4,  0x16u);
  }

  unsigned int __size = 0;
  uint64_t v20 = 0LL;
  uint64_t v21 = 4LL;
  int v19 = a1;
  uint64_t v10 = LibCall_ACMContextGetData( (uint64_t (*)(uint64_t, uint64_t, void, void *, size_t, uint64_t, uint64_t))sub_10008B794,  (uint64_t)&v19,  a1,  a2,  1,  a3,  a4,  (uint64_t)&__size,  (uint64_t)&v21);
  if (!(_DWORD)v10)
  {
    uint64_t v11 = __size;
    if (__size)
    {
      uint64_t v12 = acm_mem_alloc_data(__size);
      acm_mem_alloc_info( "<data>",  v12,  v11,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/ACMLib/ACMLib.c",  1199,  "ACMContextGetDataEx");
      if (!v12)
      {
        unsigned int v16 = 70;
        uint64_t v14 = 4294967292LL;
        goto LABEL_15;
      }

      uint64_t v20 = __size;
      __int16 v18 = a1;
      uint64_t v13 = LibCall_ACMContextGetData( (uint64_t (*)(uint64_t, uint64_t, void, void *, size_t, uint64_t, uint64_t))sub_10008B794,  (uint64_t)&v18,  a1,  a2,  0,  a3,  a4,  (uint64_t)v12,  (uint64_t)&v20);
      uint64_t v14 = v13;
      if (a5 && !(_DWORD)v13) {
        (*(void (**)(uint64_t, void *, uint64_t))(a5 + 16))(a5, v12, v20);
      }
      rsize_t v15 = __size;
      acm_mem_free_info( "<data>",  v12,  __size,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/ACMLib/ACMLib.c",  1213,  "ACMContextGetDataEx");
      acm_mem_free_data(v12, v15);
      if ((_DWORD)v14) {
        goto LABEL_11;
      }
    }

    else if (a5)
    {
      (*(void (**)(uint64_t, void, void))(a5 + 16))(a5, 0LL, 0LL);
    }

    uint64_t v14 = 0LL;
    unsigned int v16 = 10;
    goto LABEL_15;
  }

  uint64_t v14 = v10;
LABEL_11:
  unsigned int v16 = 70;
LABEL_15:
  if (v16 >= byte_1000DB179 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    int __size_4 = 136315650;
    BOOL v24 = "ACMLib";
    __int16 v25 = 2080;
    uint64_t v26 = "ACMContextGetDataEx";
    __int16 v27 = 2048;
    uint64_t v28 = (int)v14;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning, CFErrorRef err = %ld.\n",  (uint8_t *)&__size_4,  0x20u);
  }

  return v14;
}

uint64_t ACMContextGetDataProperty(_OWORD *a1, unsigned __int16 a2, unsigned __int16 a3, uint64_t a4)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    int v11 = 136315394;
    uint64_t v12 = "ACMLib";
    __int16 v13 = 2080;
    uint64_t v14 = "ACMContextGetDataProperty";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  (uint8_t *)&v11,  0x16u);
  }

  uint64_t Data = ACMContextGetData(a1, a2 | (a3 << 16), a4);
  if ((_DWORD)Data) {
    unsigned int v9 = 70;
  }
  else {
    unsigned int v9 = 10;
  }
  if (v9 >= byte_1000DB179 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    int v11 = 136315650;
    uint64_t v12 = "ACMLib";
    __int16 v13 = 2080;
    uint64_t v14 = "ACMContextGetDataProperty";
    __int16 v15 = 2048;
    uint64_t v16 = (int)Data;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning, CFErrorRef err = %ld.\n",  (uint8_t *)&v11,  0x20u);
  }

  return Data;
}

uint64_t ACMContextGetInfo(__int128 *a1, int a2, void *a3)
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    int v11 = "ACMLib";
    __int16 v12 = 2080;
    __int16 v13 = "ACMContextGetInfo";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  buf,  0x16u);
  }

  unsigned int v9 = a1;
  uint64_t v6 = LibCall_ACMContextGetInfo( (uint64_t (*)(uint64_t, uint64_t, void, int *, uint64_t, _OWORD *, unint64_t *))sub_10008B794,  (uint64_t)&v9,  a1,  a2,  a3);
  if ((_DWORD)v6) {
    unsigned int v7 = 70;
  }
  else {
    unsigned int v7 = 10;
  }
  if (v7 >= byte_1000DB179 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315650;
    int v11 = "ACMLib";
    __int16 v12 = 2080;
    __int16 v13 = "ACMContextGetInfo";
    __int16 v14 = 2048;
    uint64_t v15 = (int)v6;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning, CFErrorRef err = %ld.\n",  buf,  0x20u);
  }

  return v6;
}

uint64_t ACMPing()
{
  uint64_t v1 = 0LL;
  return LibCall_ACMPing( (uint64_t (*)(uint64_t, uint64_t, void, void, void, void, void))sub_10008B794,  (uint64_t)&v1,  29LL);
}

void sub_1000906CC()
{
  if (byte_1000DB179 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    unsigned int v5 = "ACMLib";
    __int16 v6 = 2080;
    unsigned int v7 = "updateLogLevelFromKext";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: called.\n",  buf,  0x16u);
  }

  uint32_t outputCnt = 1;
  if (IOConnectCallScalarMethod(dword_1000DBC88, 2u, 0LL, 0, &output, &outputCnt)) {
    goto LABEL_8;
  }
  unsigned __int8 v0 = output;
  unsigned int v1 = output;
  byte_1000DB179 = output;
  if (output <= 0x1EuLL && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315650;
    unsigned int v5 = "ACMLib";
    __int16 v6 = 2080;
    unsigned int v7 = "updateLogLevelFromKext";
    __int16 v8 = 1024;
    int v9 = v0;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: log level set to %d.\n",  buf,  0x1Cu);
LABEL_8:
    unsigned int v1 = byte_1000DB179;
  }

  if (v1 <= 0xA && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    unsigned int v5 = "ACMLib";
    __int16 v6 = 2080;
    unsigned int v7 = "updateLogLevelFromKext";
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_INFO,  "%s: %s: returning.\n",  buf,  0x16u);
  }

_BYTE *LibCall_BuildCommand(char a1, char a2, char a3, const void *a4, size_t a5, void *a6)
{
  __int16 v12 = 0LL;
  if (a5) {
    BOOL v13 = a4 == 0LL;
  }
  else {
    BOOL v13 = 0;
  }
  if (!v13 && a6)
  {
    if (a5 >= 0xFFFFFFFFFFFFFFF8LL)
    {
      __int16 v12 = 0LL;
    }

    else
    {
      __int16 v12 = acm_mem_alloc_data(a5 + 8);
      acm_mem_alloc_info( "<data>",  v12,  a5 + 8,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  22,  "LibCall_BuildCommand");
      if (v12)
      {
        *a6 = a5 + 8;
        *(_DWORD *)__int16 v12 = 1396920900;
        v12[4] = a1;
        v12[5] = a2;
        v12[6] = a3;
        if (a5) {
          memcpy(v12 + 8, a4, a5);
        }
      }
    }
  }

  return v12;
}

uint64_t LibCall_ACMContextCreate( uint64_t (*a1)(uint64_t, uint64_t, void, void, void, _BYTE *, uint64_t *), uint64_t a2, void *a3, _BYTE *a4, int a5)
{
  unsigned int v10 = 70;
  uint64_t v11 = 4294967293LL;
  if (!a1 || !a3) {
    goto LABEL_25;
  }
  __int16 v12 = acm_mem_alloc(0x14uLL);
  acm_mem_alloc_info( "ACMHandleWithPayload",  v12,  20LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  50,  "LibCall_ACMContextCreate");
  if (!v12)
  {
    unsigned int v10 = 70;
    uint64_t v11 = 4294967292LL;
    goto LABEL_25;
  }

  memset(v19, 0, sizeof(v19));
  if (a5)
  {
    uint64_t v18 = 21LL;
    uint64_t v13 = a1(a2, 36LL, 0LL, 0LL, 0LL, v19, &v18);
    if (!(_DWORD)v13)
    {
      if (v18 != 21)
      {
        uint64_t v11 = 4294967291LL;
        goto LABEL_23;
      }

      uint64_t v11 = 0LL;
      goto LABEL_20;
    }

    uint64_t v11 = v13;
    if ((_DWORD)v13 != -3)
    {
LABEL_23:
      acm_mem_free_info( "ACMHandleWithPayload",  v12,  0x14uLL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  89,  "LibCall_ACMContextCreate");
      acm_mem_free(v12, 0x14uLL);
      unsigned int v10 = 70;
      goto LABEL_25;
    }
  }

  uint64_t v18 = 17LL;
  unsigned int v14 = a1(a2, 1LL, 0LL, 0LL, 0LL, v19, &v18);
  if (v18 == 17) {
    unsigned int v15 = 0;
  }
  else {
    unsigned int v15 = -5;
  }
  if (v14) {
    uint64_t v11 = v14;
  }
  else {
    uint64_t v11 = v15;
  }
  if (!v14 && v18 == 17)
  {
LABEL_20:
    int v16 = *(_DWORD *)&v19[17];
    *(_OWORD *)__int16 v12 = *(_OWORD *)v19;
    v12[4] = v16;
    *a3 = v12;
    if (a4) {
      *a4 = v19[16];
    }
  }

  if ((_DWORD)v11) {
    goto LABEL_23;
  }
  unsigned int v10 = 10;
LABEL_25:
  return v11;
}

_DWORD *LibCall_ACMContextCreateWithExternalForm( uint64_t (*a1)(uint64_t, uint64_t, void, _OWORD *, uint64_t, void *, uint64_t *), uint64_t a2, _OWORD *a3, uint64_t a4, _BYTE *a5, int a6)
{
  __int16 v12 = 0LL;
  unsigned int v13 = 70;
  int v14 = -3;
  if (a1 && a3 && a4 == 16)
  {
    memset(v21, 0, 9);
    if (a6)
    {
      uint64_t v20 = 9LL;
      int v15 = a1(a2, 37LL, 0LL, a3, 16LL, v21, &v20);
      if (!v15)
      {
        if (v20 == 9)
        {
          int v14 = 0;
          goto LABEL_19;
        }

        int v14 = -5;
        goto LABEL_28;
      }

      int v14 = v15;
      if (v15 != -3) {
        goto LABEL_28;
      }
    }

    uint64_t v20 = 5LL;
    int v16 = a1(a2, 18LL, 0LL, a3, 16LL, v21, &v20);
    if (v20 == 5) {
      int v17 = 0;
    }
    else {
      int v17 = -5;
    }
    if (v16) {
      int v14 = v16;
    }
    else {
      int v14 = v17;
    }
    if (!v16 && v20 == 5)
    {
LABEL_19:
      if (LODWORD(v21[0]))
      {
        __int16 v12 = acm_mem_alloc(0x14uLL);
        acm_mem_alloc_info( "ACMHandleWithPayload",  v12,  20LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  128,  "LibCall_ACMContextCreateWithExternalForm");
        if (!v12)
        {
          unsigned int v13 = 70;
          int v14 = -4;
          goto LABEL_31;
        }

        int v18 = *(_DWORD *)((char *)v21 + 5);
        *(_OWORD *)__int16 v12 = *a3;
        v12[4] = v18;
        if (a5) {
          *a5 = BYTE4(v21[0]);
        }
        if (v14)
        {
          acm_mem_free_info( "ACMHandleWithPayload",  v12,  0x14uLL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  147,  "LibCall_ACMContextCreateWithExternalForm");
          acm_mem_free(v12, 0x14uLL);
LABEL_29:
          unsigned int v13 = 70;
          goto LABEL_31;
        }
      }

      else
      {
        __int16 v12 = 0LL;
      }

      goto LABEL_30;
    }

uint64_t LibCall_ACMContextDelete( void (*a1)(uint64_t, uint64_t, void, void *, uint64_t, void, void), uint64_t a2, void *a3, int a4)
{
  if (a1 && a3)
  {
    if (a4) {
      a1(a2, 2LL, 0LL, a3, 16LL, 0LL, 0LL);
    }
    goto LABEL_7;
  }

  if (a3)
  {
LABEL_7:
    acm_mem_free_info( "ACMHandleWithPayload",  a3,  0x14uLL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  172,  "LibCall_ACMContextDelete");
    acm_mem_free(a3, 0x14uLL);
    uint64_t v8 = 0LL;
    unsigned int v9 = 10;
    goto LABEL_8;
  }

  unsigned int v9 = 70;
  uint64_t v8 = 4294967293LL;
LABEL_8:
  return v8;
}

uint64_t LibCall_ACMContexAddCredentialWithScope( uint64_t (*a1)(uint64_t, uint64_t, void, void *, size_t, void, void), uint64_t a2, _OWORD *a3, unsigned int *a4, int a5)
{
  size_t __size = 0LL;
  if (a3) {
    BOOL v10 = 1;
  }
  else {
    BOOL v10 = a5 == 2;
  }
  char v11 = !v10;
  unsigned int v12 = 70;
  uint64_t v13 = 4294967293LL;
  if (a4 && (v11 & 1) == 0)
  {
    uint64_t SerializedAddCredentialSize = GetSerializedAddCredentialSize((uint64_t)a3, a4, a5, &__size);
    if ((_DWORD)SerializedAddCredentialSize)
    {
      uint64_t v13 = SerializedAddCredentialSize;
      unsigned int v12 = 70;
    }

    else
    {
      size_t v15 = __size;
      int v16 = acm_mem_alloc_data(__size);
      acm_mem_alloc_info( "<data>",  v16,  v15,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  192,  "LibCall_ACMContexAddCredentialWithScope");
      if (v16)
      {
        uint64_t v17 = SerializeAddCredential(a3, a4, a5, (uint64_t)v16, &__size);
        if (!(_DWORD)v17) {
          uint64_t v17 = a1(a2, 5LL, 0LL, v16, __size, 0LL, 0LL);
        }
        uint64_t v13 = v17;
        rsize_t v18 = __size;
        acm_mem_free_info( "<data>",  v16,  __size,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  203,  "LibCall_ACMContexAddCredentialWithScope");
        acm_mem_free_data(v16, v18);
        if ((_DWORD)v13) {
          unsigned int v12 = 70;
        }
        else {
          unsigned int v12 = 10;
        }
      }

      else
      {
        unsigned int v12 = 70;
        uint64_t v13 = 4294967292LL;
      }
    }
  }

  return v13;
}

uint64_t LibCall_ACMContexRemoveCredentialsByTypeAndScope( uint64_t (*a1)(uint64_t, uint64_t, void, _OWORD *, uint64_t, void, void), uint64_t a2, _OWORD *a3, int a4, int a5)
{
  if (a3 || a5 == 2)
  {
    BOOL v10 = acm_mem_alloc_data(0x18uLL);
    acm_mem_alloc_info( "<data>",  v10,  24LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  217,  "LibCall_ACMContexRemoveCredentialsByTypeAndScope");
    if (v10)
    {
      if (a3)
      {
        _OWORD *v10 = *a3;
      }

      else
      {
        *(void *)BOOL v10 = 0LL;
        *((void *)v10 + 1) = 0LL;
      }

      *((_DWORD *)v10 + 4) = a4;
      *((_DWORD *)v10 + 5) = a5;
      uint64_t v11 = a1(a2, 9LL, 0LL, v10, 24LL, 0LL, 0LL);
      acm_mem_free_info( "<data>",  v10,  0x18uLL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  233,  "LibCall_ACMContexRemoveCredentialsByTypeAndScope");
      acm_mem_free_data(v10, 0x18uLL);
      if ((_DWORD)v11) {
        unsigned int v12 = 70;
      }
      else {
        unsigned int v12 = 10;
      }
    }

    else
    {
      unsigned int v12 = 70;
      uint64_t v11 = 4294967292LL;
    }
  }

  else
  {
    unsigned int v12 = 70;
    uint64_t v11 = 4294967293LL;
  }

  return v11;
}

uint64_t LibCall_ACMContextRemoveCredentialsByValueAndScope( uint64_t (*a1)(uint64_t, uint64_t, void, void *, size_t, void, void), uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5)
{
  size_t __size = 0LL;
  if (a3) {
    BOOL v10 = 1;
  }
  else {
    BOOL v10 = (_DWORD)a5 == 2;
  }
  char v11 = !v10;
  unsigned int v12 = 70;
  uint64_t v13 = 4294967293LL;
  if (a4 && (v11 & 1) == 0)
  {
    uint64_t v14 = GetSerializedRemoveCredentialSize(a3, a4, a5, &__size);
    if ((_DWORD)v14)
    {
      uint64_t v13 = v14;
      unsigned int v12 = 70;
    }

    else
    {
      size_t v15 = __size;
      int v16 = acm_mem_alloc_data(__size);
      acm_mem_alloc_info( "<data>",  v16,  v15,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  251,  "LibCall_ACMContextRemoveCredentialsByValueAndScope");
      if (v16)
      {
        uint64_t v17 = SerializeRemoveCredential(a3, a4, a5, v16, &__size);
        if (!(_DWORD)v17) {
          uint64_t v17 = a1(a2, 6LL, 0LL, v16, __size, 0LL, 0LL);
        }
        uint64_t v13 = v17;
        rsize_t v18 = __size;
        acm_mem_free_info( "<data>",  v16,  __size,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  264,  "LibCall_ACMContextRemoveCredentialsByValueAndScope");
        acm_mem_free_data(v16, v18);
        if ((_DWORD)v13) {
          unsigned int v12 = 70;
        }
        else {
          unsigned int v12 = 10;
        }
      }

      else
      {
        unsigned int v12 = 70;
        uint64_t v13 = 4294967292LL;
      }
    }
  }

  return v13;
}

uint64_t LibCall_ACMContextVerifyPolicyAndCopyRequirementEx( uint64_t (*a1)(uint64_t, uint64_t, void, _OWORD *, size_t, unsigned int *, unint64_t *), uint64_t a2, _OWORD *a3, char *__s1, uint64_t a5, _DWORD *a6, unsigned int a7, uint64_t a8, BOOL *a9, void *a10)
{
  size_t v32 = 0LL;
  size_t __size = 0LL;
  __int16 v30 = 0LL;
  unint64_t v31 = 4096LL;
  unsigned int v18 = 70;
  uint64_t v19 = 4294967293LL;
  size_t v29 = 0LL;
  if (a1 && a3 && __s1 && a9)
  {
    if ((a6 != 0LL) != (a7 != 0))
    {
      unsigned int v18 = 70;
      uint64_t v19 = 4294967293LL;
    }

    else
    {
      uint64_t SerializedVerifyPolicySize = GetSerializedVerifyPolicySize((uint64_t)a3, __s1, a5, a8, a6, a7, &__size);
      if ((_DWORD)SerializedVerifyPolicySize)
      {
        uint64_t v19 = SerializedVerifyPolicySize;
        unsigned int v18 = 70;
      }

      else
      {
        size_t v21 = __size;
        __int16 v22 = acm_mem_alloc_data(__size);
        acm_mem_alloc_info( "<data>",  v22,  v21,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  293,  "LibCall_ACMContextVerifyPolicyAndCopyRequirementEx");
        if (v22)
        {
          size_t v32 = __size;
          uint64_t v23 = SerializeVerifyPolicy(a3, __s1, a5, a8, a6, a7, v22, &v32);
          if ((_DWORD)v23)
          {
            uint64_t v19 = v23;
            BOOL v24 = 0LL;
          }

          else
          {
            BOOL v24 = (unsigned int *)acm_mem_alloc_data(0x1000uLL);
            acm_mem_alloc_info( "<data>",  v24,  4096LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  300,  "LibCall_ACMContextVerifyPolicyAndCopyRequirementEx");
            if (v24)
            {
              uint64_t v25 = a1(a2, 3LL, 0LL, v22, v32, v24, &v31);
              if ((_DWORD)v25)
              {
                uint64_t v19 = v25;
              }

              else
              {
                unint64_t v26 = v31 - 4;
                if (v31 < 4)
                {
                  uint64_t v19 = 4294967291LL;
                }

                else
                {
                  *a9 = *v24 != 0;
                  if (a10)
                  {
                    uint64_t v19 = DeserializeRequirement(v24 + 1, v26, &v30, &v29);
                    if (!(_DWORD)v19) {
                      *a10 = v30;
                    }
                  }

                  else
                  {
                    uint64_t v19 = 0LL;
                  }
                }
              }
            }

            else
            {
              uint64_t v19 = 4294967292LL;
            }
          }

          rsize_t v27 = __size;
          acm_mem_free_info( "<data>",  v22,  __size,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  324,  "LibCall_ACMContextVerifyPolicyAndCopyRequirementEx");
          acm_mem_free_data(v22, v27);
          if (v24)
          {
            acm_mem_free_info( "<data>",  v24,  0x1000uLL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  327,  "LibCall_ACMContextVerifyPolicyAndCopyRequirementEx");
            acm_mem_free_data(v24, 0x1000uLL);
          }

          if ((_DWORD)v19) {
            unsigned int v18 = 70;
          }
          else {
            unsigned int v18 = 10;
          }
        }

        else
        {
          unsigned int v18 = 70;
          uint64_t v19 = 4294967292LL;
        }
      }
    }
  }

  return v19;
}

uint64_t LibCall_ACMRequirementDelete(uint64_t a1, int *a2)
{
  unsigned int v4 = 70;
  uint64_t v5 = 4294967293LL;
  if (a1 && a2)
  {
    uint64_t v5 = Util_DeallocRequirement(a2);
    if ((_DWORD)v5) {
      unsigned int v4 = 70;
    }
    else {
      unsigned int v4 = 10;
    }
  }

  return v5;
}

uint64_t LibCall_ACMKernelControl( uint64_t (*a1)(uint64_t, uint64_t, void, char *, size_t, uint64_t, uint64_t), uint64_t a2, int a3, const void *a4, size_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v13 = a1;
  if (gACMLoggingLevel <= 0xAu) {
    a1 = (uint64_t (*)(uint64_t, uint64_t, void, char *, size_t, uint64_t, uint64_t))printf( "%s: %s: called.\n",  "ACM",  "LibCall_ACMKernelControl");
  }
  if (!v13) {
    goto LABEL_16;
  }
  BOOL v14 = a5 != 0;
  if (a4) {
    BOOL v14 = a5 - 4097 < 0xFFFFFFFFFFFFF000LL;
  }
  if (v14)
  {
LABEL_16:
    unsigned int v18 = 70;
    uint64_t v17 = 4294967293LL;
  }

  else
  {
    uint64_t v20 = (uint64_t)&v20;
    __chkstk_darwin(a1);
    size_t v15 = (_DWORD *)((char *)&v20 - ((a5 + 19) & 0xFFFFFFFFFFFFFFF0LL));
    *size_t v15 = a3;
    int v16 = v15 + 1;
    if (a5)
    {
      memcpy(v15 + 1, a4, a5);
      int v16 = (_DWORD *)((char *)v16 + a5);
    }

    uint64_t v17 = v13(a2, 26LL, 0LL, (char *)&v20 - ((a5 + 19) & 0xFFFFFFFFFFFFFFF0LL), a5 + 4, a6, a7);
    if ((_DWORD)v17) {
      unsigned int v18 = 70;
    }
    else {
      unsigned int v18 = 10;
    }
  }

  return v17;
}

_DWORD *LibCall_ACMCredentialDelete(_DWORD *a1)
{
  if (a1) {
    return (_DWORD *)Util_DeallocCredential(a1);
  }
  return a1;
}

unsigned int *LibCall_ACMCredentialGetType(unsigned int *result)
{
  if (result) {
    return (unsigned int *)*result;
  }
  return result;
}

uint64_t LibCall_ACMCredentialSetProperty(int *a1, int a2, _OWORD *__src, size_t __n)
{
  if (!a1) {
    return 4294967293LL;
  }
  int v4 = __n;
  if ((__src != 0LL) != (__n != 0)) {
    return 4294967293LL;
  }
  uint64_t result = 4294967293LL;
  if (a2 > 399)
  {
    if (a2 > 601)
    {
      if (a2 <= 801)
      {
        if (a2 != 602)
        {
          if (a2 == 701)
          {
            if (__n <= 0x80 && *a1 == 13)
            {
              a1[8] = __n;
              BOOL v14 = a1 + 9;
LABEL_118:
              memcpy(v14, __src, __n);
              return 0LL;
            }
          }

          else if (a2 == 801 && __n == 16 && *a1 == 17)
          {
            uint64_t result = 0LL;
            *((_OWORD *)a1 + 2) = *__src;
          }

          return result;
        }

        BOOL v13 = *a1 == 12 || *a1 == 15;
        if (__n != 4 || !v13) {
          return result;
        }
LABEL_79:
        uint64_t result = 0LL;
        a1[9] = *(_DWORD *)__src;
        return result;
      }

      if (a2 == 802)
      {
        if (__n != 65 || *a1 != 17) {
          return result;
        }
        uint64_t result = 0LL;
        *((_OWORD *)a1 + 3) = *__src;
        __int128 v11 = __src[1];
        __int128 v16 = __src[2];
        __int128 v17 = __src[3];
        *((_BYTE *)a1 + 112) = *((_BYTE *)__src + 64);
        *((_OWORD *)a1 + 5) = v16;
        *((_OWORD *)a1 + 6) = v17;
        goto LABEL_92;
      }

      if (a2 != 901)
      {
        if (a2 == 1001 && __n <= 0x80 && *a1 == 21)
        {
          memcpy(a1 + 9, __src, __n);
          uint64_t result = 0LL;
          a1[8] = v4;
        }

        return result;
      }

      if (__n != 32 || *a1 != 20) {
        return result;
      }
    }

    else
    {
      if (a2 > 501)
      {
        switch(a2)
        {
          case 502:
            if (__n == 16 && *a1 == 10)
            {
LABEL_102:
              uint64_t result = 0LL;
              *(_OWORD *)(a1 + 13) = *__src;
            }

            break;
          case 503:
            if (__n == 16 && *a1 == 10)
            {
              uint64_t result = 0LL;
              __int128 v15 = *__src;
LABEL_99:
              *(_OWORD *)(a1 + 17) = v15;
            }

            break;
          case 601:
            BOOL v9 = *a1 == 12 || *a1 == 15;
            BOOL v10 = v9;
            if (__n == 4 && v10)
            {
LABEL_64:
              uint64_t result = 0LL;
              a1[8] = *(_DWORD *)__src;
            }

            break;
        }

        return result;
      }

      if (a2 != 400)
      {
        if (a2 != 401)
        {
          if (a2 == 501 && __n == 16 && *a1 == 10)
          {
LABEL_16:
            uint64_t result = 0LL;
            *(_OWORD *)(a1 + 9) = *__src;
          }

          return result;
        }

        if (__n != 24 || *a1 != 7) {
          return result;
        }
        uint64_t result = 0LL;
        __int128 v11 = *__src;
        *((void *)a1 + 10) = *((void *)__src + 2);
LABEL_92:
        *((_OWORD *)a1 + 4) = v11;
        return result;
      }

      if (__n != 32 || *a1 != 7) {
        return result;
      }
    }

    uint64_t result = 0LL;
    __int128 v18 = __src[1];
    *((_OWORD *)a1 + 2) = *__src;
    *((_OWORD *)a1 + 3) = v18;
    return result;
  }

  if (a2 > 199)
  {
    switch(a2)
    {
      case 300:
        if (__n == 16 && *a1 == 3) {
          goto LABEL_16;
        }
        break;
      case 301:
        if (__n == 32 && *a1 == 3)
        {
          uint64_t result = 0LL;
          __int128 v15 = *__src;
          *(_OWORD *)(a1 + 21) = __src[1];
          goto LABEL_99;
        }

        break;
      case 302:
        if (__n == 16 && *a1 == 3) {
          goto LABEL_102;
        }
        break;
      case 303:
        if (__n == 65 && *a1 == 3)
        {
          uint64_t result = 0LL;
          *(_OWORD *)(a1 + 30) = *__src;
          __int128 v19 = __src[1];
          __int128 v20 = __src[2];
          __int128 v21 = __src[3];
          *((_BYTE *)a1 + 184) = *((_BYTE *)__src + 64);
          *(_OWORD *)(a1 + 42) = v21;
          *(_OWORD *)(a1 + 3_Block_object_dispose(va, 8) = v20;
          *(_OWORD *)(a1 + 34) = v19;
        }

        break;
      case 304:
        if (__n == 16 && *a1 == 3)
        {
          uint64_t result = 0LL;
          *(_OWORD *)((char *)a1 + 185) = *__src;
        }

        break;
      case 305:
        if (__n == 4 && *a1 == 3)
        {
          uint64_t result = 0LL;
          *(int *)((char *)a1 + 201) = *(_DWORD *)__src;
        }

        break;
      case 306:
        if (__n <= 0x80 && *a1 == 3)
        {
          memcpy((char *)a1 + 209, __src, __n);
          uint64_t result = 0LL;
          *(int *)((char *)a1 + 205) = v4;
        }

        break;
      default:
        if (a2 == 200)
        {
          if (__n <= 0x80 && *a1 == 2)
          {
            a1[9] = __n;
            BOOL v14 = a1 + 10;
            goto LABEL_118;
          }
        }

        else if (a2 == 201 && __n == 4 && *a1 == 2)
        {
          goto LABEL_64;
        }

        break;
    }

    return result;
  }

  if (a2 > 100)
  {
    if (a2 == 101)
    {
      if (__n == 4)
      {
        switch(*a1)
        {
          case 1:
          case 3:
          case 9:
          case 10:
            goto LABEL_64;
          case 2:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
            return result;
          default:
            if (*a1 == 18) {
              goto LABEL_64;
            }
            break;
        }
      }

      return result;
    }

    if (a2 != 102 || __n != 4 || *a1 != 1) {
      return result;
    }
    goto LABEL_79;
  }

  if (a2 == 5)
  {
    if (__n == 4)
    {
      uint64_t result = 0LL;
      a1[3] = *(_DWORD *)__src;
    }
  }

  else if (a2 == 100 && __n == 16)
  {
    int v7 = *a1;
    if (*a1 > 8)
    {
      if (v7 == 9)
      {
        uint64_t v8 = a1 + 10;
        a1[9] = 16;
      }

      else
      {
        if (v7 != 18) {
          return result;
        }
        uint64_t v8 = a1 + 9;
      }
    }

    else if (v7 == 1)
    {
      uint64_t v8 = a1 + 11;
      a1[10] = 16;
    }

    else
    {
      if (v7 != 3) {
        return result;
      }
      uint64_t v8 = a1 + 26;
      a1[25] = 16;
    }

    uint64_t result = 0LL;
    _OWORD *v8 = *__src;
  }

  return result;
}

uint64_t LibCall_ACMCredentialGetPropertyData(int *a1, int a2, int **a3, uint64_t *a4)
{
  uint64_t result = 4294967293LL;
  if (!a1 || !a3 || !a4) {
    return result;
  }
  if (a2 > 399)
  {
    if (a2 > 601)
    {
      if (a2 > 801)
      {
        if (a2 == 802)
        {
          if (*a1 != 17) {
            return result;
          }
          __int128 v11 = a1 + 12;
LABEL_87:
          uint64_t v12 = 65LL;
          BOOL v13 = v11;
          uint64_t v14 = 65LL;
        }

        else
        {
          if (a2 != 901)
          {
            if (a2 != 1001 || *a1 != 21) {
              return result;
            }
            __int128 v15 = a1 + 9;
            if (Util_isNullOrZeroMemory((_BYTE *)a1 + 36, 128LL))
            {
              __int128 v15 = 0LL;
              uint64_t v10 = 0LL;
            }

            else
            {
              uint64_t v10 = a1[8];
            }

            uint64_t result = 0LL;
            *a3 = v15;
LABEL_99:
            *a4 = v10;
            return result;
          }

          if (*a1 != 20) {
            return result;
          }
          __int128 v11 = a1 + 8;
          uint64_t v12 = 32LL;
          BOOL v13 = v11;
          uint64_t v14 = 32LL;
        }
      }

      else
      {
        if (a2 == 602)
        {
          if (*a1 != 15 && *a1 != 12) {
            return result;
          }
          goto LABEL_61;
        }

        if (a2 == 701)
        {
          if (*a1 != 13) {
            return result;
          }
          uint64_t result = 0LL;
          *a3 = a1 + 9;
          uint64_t v10 = a1[8];
          goto LABEL_99;
        }

        if (a2 != 801 || *a1 != 17) {
          return result;
        }
        __int128 v11 = a1 + 8;
        uint64_t v12 = 16LL;
        BOOL v13 = v11;
        uint64_t v14 = 16LL;
      }

      BOOL isNullOrZeroMemory = Util_isNullOrZeroMemory(v13, v14);
      uint64_t result = 0LL;
      BOOL v20 = !isNullOrZeroMemory;
      if (isNullOrZeroMemory) {
        __int128 v21 = 0LL;
      }
      else {
        __int128 v21 = (int *)v11;
      }
      if (v20) {
        uint64_t v22 = v12;
      }
      else {
        uint64_t v22 = 0LL;
      }
      *a3 = v21;
      *a4 = v22;
      return result;
    }

    if (a2 > 501)
    {
      if (a2 == 502)
      {
        if (*a1 != 10) {
          return result;
        }
        BOOL v9 = a1 + 13;
      }

      else
      {
        if (a2 != 503)
        {
          if (a2 != 601 || *a1 != 15 && *a1 != 12) {
            return result;
          }
          goto LABEL_77;
        }

        if (*a1 != 10) {
          return result;
        }
        BOOL v9 = a1 + 17;
      }

LABEL_70:
      uint64_t v10 = 16LL;
      goto LABEL_99;
    }

    if (a2 == 400)
    {
      if (*a1 != 7) {
        return result;
      }
      uint64_t result = 0LL;
      __int128 v16 = a1 + 8;
LABEL_84:
      *a3 = v16;
      uint64_t v10 = 32LL;
      goto LABEL_99;
    }

    if (a2 == 401)
    {
      if (*a1 != 7) {
        return result;
      }
      uint64_t result = 0LL;
      *a3 = a1 + 16;
      uint64_t v10 = 24LL;
      goto LABEL_99;
    }

    if (a2 != 501 || *a1 != 10) {
      return result;
    }
LABEL_15:
    BOOL v9 = a1 + 9;
    goto LABEL_68;
  }

  if (a2 > 199)
  {
    switch(a2)
    {
      case 300:
        if (*a1 == 3)
        {
          uint64_t result = 0LL;
          uint64_t v8 = a1 + 9;
          goto LABEL_50;
        }

        break;
      case 301:
        if (*a1 == 3)
        {
          uint64_t result = 0LL;
          __int128 v16 = a1 + 17;
          goto LABEL_84;
        }

        break;
      case 302:
        if (*a1 == 3)
        {
          uint64_t result = 0LL;
          uint64_t v8 = a1 + 13;
          goto LABEL_50;
        }

        break;
      case 303:
        if (*a1 == 3)
        {
          __int128 v11 = a1 + 30;
          goto LABEL_87;
        }

        break;
      case 304:
        if (*a1 == 3)
        {
          uint64_t result = 0LL;
          uint64_t v8 = (int *)((char *)a1 + 185);
LABEL_50:
          *a3 = v8;
          goto LABEL_70;
        }

        break;
      case 305:
        if (*a1 == 3)
        {
          uint64_t result = 0LL;
          __int128 v17 = (int *)((char *)a1 + 201);
          goto LABEL_97;
        }

        break;
      case 306:
        if (*a1 == 3)
        {
          uint64_t result = 0LL;
          uint64_t v10 = *(unsigned int *)((char *)a1 + 205);
          uint64_t v23 = (int *)((char *)a1 + 209);
          *a3 = v23;
          goto LABEL_99;
        }

        break;
      default:
        if (a2 == 200)
        {
          if (*a1 == 2)
          {
            uint64_t result = 0LL;
            *a3 = a1 + 10;
            uint64_t v10 = a1[9];
            goto LABEL_99;
          }
        }

        else if (a2 == 201 && *a1 == 2)
        {
          goto LABEL_77;
        }

        break;
    }

    return result;
  }

  if (a2 > 99)
  {
    if (a2 != 100)
    {
      if (a2 != 101)
      {
        if (a2 != 102 || *a1 != 1) {
          return result;
        }
LABEL_61:
        uint64_t result = 0LL;
        __int128 v17 = a1 + 9;
        goto LABEL_97;
      }

unsigned int *LibCall_ACMRequirementGetType(unsigned int *result)
{
  if (result) {
    return (unsigned int *)*result;
  }
  return result;
}

uint64_t LibCall_ACMRequirementGetState(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 4);
  }
  return result;
}

uint64_t LibCall_ACMRequirementGetPriority(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 8);
  }
  return result;
}

uint64_t LibCall_ACMRequirementGetPropertyData(int *a1, int a2, int **a3, unint64_t *a4)
{
  uint64_t v4 = 4294967293LL;
  if (!a1 || !a3 || !a4) {
    return v4;
  }
  uint64_t v4 = 4294967293LL;
  if (a2 > 399)
  {
    if (a2 > 600)
    {
      if (a2 == 601)
      {
        if (*a1 == 26)
        {
          if (a1[3] >= 0x1C)
          {
            int v7 = a1 + 7;
LABEL_45:
            *a3 = v7;
            unint64_t v10 = 16LL;
            goto LABEL_72;
          }

          return 4294967282LL;
        }

        return 4294967293LL;
      }

      if (a2 != 602)
      {
        if (a2 != 700) {
          return v4;
        }
        if (*a1 == 7)
        {
LABEL_28:
          uint64_t v8 = a1 + 4;
          goto LABEL_58;
        }

        return 4294967293LL;
      }

      if (*a1 != 26) {
        return 4294967293LL;
      }
      *a3 = a1 + 4;
      unint64_t v10 = 8LL;
    }

    else
    {
      if (a2 == 400)
      {
        if (*a1 == 13)
        {
          BOOL v9 = a1 + 4;
LABEL_64:
          *a3 = v9;
          unint64_t v10 = 32LL;
          goto LABEL_72;
        }

        return 4294967293LL;
      }

      if (a2 != 500)
      {
        if (a2 != 600) {
          return v4;
        }
        if (*a1 == 26)
        {
          if (a1[3] >= 0x1C)
          {
            uint64_t v8 = a1 + 6;
LABEL_58:
            *a3 = v8;
            goto LABEL_59;
          }

          return 4294967282LL;
        }

        return 4294967293LL;
      }

      if (*a1 != 25) {
        return 4294967293LL;
      }
      *a3 = a1 + 4;
      unint64_t v10 = 43LL;
    }

uint64_t LibCall_ACMPing( uint64_t (*a1)(uint64_t, uint64_t, void, void, void, void, void), uint64_t a2, uint64_t a3)
{
  unsigned int v6 = 70;
  if (a1 && ((_DWORD)a3 == 47 || (_DWORD)a3 == 29))
  {
    uint64_t v7 = a1(a2, a3, 0LL, 0LL, 0LL, 0LL, 0LL);
    if ((_DWORD)v7) {
      unsigned int v6 = 70;
    }
    else {
      unsigned int v6 = 10;
    }
  }

  else
  {
    uint64_t v7 = 4294967293LL;
  }

  return v7;
}

uint64_t LibCall_ACMKernDoubleClickNotify( uint64_t (*a1)(uint64_t, uint64_t, void, void, void, void, void), uint64_t a2)
{
  unsigned int v4 = 70;
  if (a1)
  {
    uint64_t v5 = a1(a2, 28LL, 0LL, 0LL, 0LL, 0LL, 0LL);
    if ((_DWORD)v5) {
      unsigned int v4 = 70;
    }
    else {
      unsigned int v4 = 10;
    }
  }

  else
  {
    uint64_t v5 = 4294967293LL;
  }

  return v5;
}

uint64_t LibCall_ACMContextCredentialGetProperty( uint64_t (*a1)(uint64_t, uint64_t, void, __n128 *, uint64_t, uint64_t, uint64_t, __n128), uint64_t a2, __n128 *a3, unsigned __int32 a4, unsigned __int32 a5, uint64_t a6, uint64_t a7)
{
  unsigned int v14 = 70;
  uint64_t v15 = 4294967293LL;
  if (a1)
  {
    if (a3)
    {
      uint64_t v15 = 4294967293LL;
      if (a6)
      {
        if (a7)
        {
          uint64_t v19 = 24LL;
          __n128 Property_Serialize = LibSer_ContextCredentialGetProperty_Serialize(a3, a4, a5, &v20, &v19);
          if ((_DWORD)v16)
          {
            uint64_t v15 = v16;
          }

          else if (v19 == 24)
          {
            uint64_t v15 = a1(a2, 33LL, 0LL, &v20, 24LL, a6, a7, Property_Serialize);
            if (!(_DWORD)v15)
            {
              unsigned int v14 = 10;
              goto LABEL_11;
            }
          }

          else
          {
            uint64_t v15 = 4294967291LL;
          }

          unsigned int v14 = 70;
        }
      }
    }
  }

uint64_t LibCall_ACMGlobalContextCredentialGetProperty( uint64_t (*a1)(uint64_t, uint64_t, void, int *, uint64_t, uint64_t, uint64_t), uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6)
{
  unsigned int v12 = 70;
  uint64_t v13 = 4294967293LL;
  if (a1 && a5 && a6)
  {
    uint64_t v16 = 8LL;
    uint64_t Property_Serialize = LibSer_GlobalContextCredentialGetProperty_Serialize(a3, a4, &v17, &v16);
    if ((_DWORD)Property_Serialize)
    {
      uint64_t v13 = Property_Serialize;
    }

    else if (v16 == 8)
    {
      uint64_t v13 = a1(a2, 27LL, 0LL, &v17, 8LL, a5, a6);
      if (!(_DWORD)v13)
      {
        unsigned int v12 = 10;
        goto LABEL_10;
      }
    }

    else
    {
      uint64_t v13 = 4294967291LL;
    }

    unsigned int v12 = 70;
  }

LABEL_10:
  return v13;
}

  return v11;
}

  memset_s(__src, 0x2000uLL, 0, 0x2000uLL);
  return v6;
}

    unsigned int v14 = v13 | !v12;
  }

  return v14 & 1;
}

uint64_t LibCall_ACMContextVerifyPolicyEx( uint64_t (*a1)(uint64_t, uint64_t, void, _OWORD *, size_t, unsigned int *, unint64_t *), uint64_t a2, _OWORD *a3, char *__s1, uint64_t a5, _DWORD *a6, unsigned int a7, uint64_t a8, BOOL *a9, int **a10)
{
  unint64_t v31 = 4096LL;
  size_t __size = 0LL;
  size_t v29 = 0LL;
  __int16 v30 = 0LL;
  uint64_t v18 = 4294967293LL;
  if (!a3 || !__s1 || !a9)
  {
LABEL_18:
    if (!(_DWORD)v18) {
      goto LABEL_21;
    }
    goto LABEL_19;
  }

  uint64_t SerializedVerifyPolicySize = GetSerializedVerifyPolicySize((uint64_t)a3, __s1, a5, a8, a6, a7, &__size);
  if (!(_DWORD)SerializedVerifyPolicySize)
  {
    size_t v20 = __size;
    __int128 v21 = acm_mem_alloc_data(__size);
    acm_mem_alloc_info( "<data>",  v21,  v20,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  1257,  "LibCall_ACMContextVerifyPolicyEx");
    if (v21)
    {
      uint64_t v22 = SerializeVerifyPolicy(a3, __s1, a5, a8, a6, a7, v21, &__size);
      if ((_DWORD)v22)
      {
        uint64_t v18 = v22;
        uint64_t v23 = 0LL;
      }

      else
      {
        uint64_t v23 = (unsigned int *)acm_mem_alloc_data(0x1000uLL);
        acm_mem_alloc_info( "<data>",  v23,  4096LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  1263,  "LibCall_ACMContextVerifyPolicyEx");
        if (v23)
        {
          uint64_t v24 = a1(a2, 3LL, 0LL, v21, __size, v23, &v31);
          if ((_DWORD)v24)
          {
            uint64_t v18 = v24;
          }

          else
          {
            unint64_t v25 = v31 - 4;
            if (v31 < 4)
            {
              uint64_t v18 = 4294967291LL;
            }

            else
            {
              *a9 = *v23 != 0;
              if (a10)
              {
                uint64_t v18 = DeserializeRequirement(v23 + 1, v25, (void **)&v30, &v29);
                if (!(_DWORD)v18) {
                  *a10 = v30;
                }
              }

              else
              {
                uint64_t v18 = 0LL;
              }
            }
          }
        }

        else
        {
          uint64_t v18 = 4294967292LL;
        }
      }

      rsize_t v26 = __size;
      acm_mem_free_info( "<data>",  v21,  __size,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  1288,  "LibCall_ACMContextVerifyPolicyEx");
      acm_mem_free_data(v21, v26);
      if (v23)
      {
        acm_mem_free_info( "<data>",  v23,  0x1000uLL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  1291,  "LibCall_ACMContextVerifyPolicyEx");
        acm_mem_free_data(v23, 0x1000uLL);
      }
    }

    else
    {
      uint64_t v18 = 4294967292LL;
    }

    goto LABEL_18;
  }

  uint64_t v18 = SerializedVerifyPolicySize;
LABEL_19:
  if (v30) {
    Util_DeallocRequirement(v30);
  }
LABEL_21:
  if ((_DWORD)v18) {
    unsigned int v27 = 70;
  }
  else {
    unsigned int v27 = 10;
  }
  return v18;
}

uint64_t LibCall_ACMGlobalContextVerifyPolicyEx( uint64_t (*a1)(uint64_t, uint64_t, void, _OWORD *, size_t, unsigned int *, unint64_t *), uint64_t a2, char *a3, uint64_t a4, _DWORD *a5, unsigned int a6, BOOL *a7, int **a8)
{
  *(void *)size_t v20 = 0LL;
  uint64_t v16 = LibCall_ACMContextCreate( (uint64_t (*)(uint64_t, uint64_t, void, void, void, _BYTE *, uint64_t *))a1,  a2,  v20,  0LL,  1);
  if (!(_DWORD)v16) {
    uint64_t v16 = LibCall_ACMContextVerifyPolicyEx(a1, a2, *(_OWORD **)v20, a3, a4, a5, a6, 0xFFFFFFFFLL, a7, a8);
  }
  uint64_t v17 = v16;
  if (*(void *)v20) {
    LibCall_ACMContextDelete( (void (*)(uint64_t, uint64_t, void, void *, uint64_t, void, void))a1,  a2,  *(void **)v20,  1);
  }
  if ((_DWORD)v17) {
    unsigned int v18 = 70;
  }
  else {
    unsigned int v18 = 10;
  }
  return v17;
}

uint64_t LibCall_ACMGetEnvironmentVariable( uint64_t (*a1)(uint64_t, uint64_t, void, int *, uint64_t, uint64_t, uint64_t), uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  int v12 = a3;
  unsigned int v9 = 70;
  uint64_t v10 = 4294967293LL;
  if (a1 && a4 && a5)
  {
    uint64_t v10 = a1(a2, 25LL, 0LL, &v12, 4LL, a4, a5);
    if ((_DWORD)v10) {
      unsigned int v9 = 70;
    }
    else {
      unsigned int v9 = 10;
    }
  }

  return v10;
}

uint64_t LibCall_ACMSetEnvironmentVariable( uint64_t (*a1)(uint64_t, uint64_t, void, char *, size_t, void, void), uint64_t a2, int a3, _OWORD *a4, _OWORD *a5, uint64_t a6, const void *a7, size_t a8)
{
  uint64_t v15 = a1;
  if (gACMLoggingLevel <= 0xAu) {
    a1 = (uint64_t (*)(uint64_t, uint64_t, void, char *, size_t, void, void))printf( "%s: %s: called.\n",  "ACM",  "LibCall_ACMSetEnvironmentVariable");
  }
  if (v15 && a6 == 16LL * (a5 != 0LL) && (a7 ? (BOOL v16 = a8 - 129 < 0xFFFFFFFFFFFFFF80LL) : (BOOL v16 = a8 != 0), !v16))
  {
    __chkstk_darwin(a1);
    uint64_t v17 = (char *)&v21 - ((a8 + 59) & 0xFFFFFFFFFFFFFFF0LL);
    *(_DWORD *)uint64_t v17 = a3;
    *((_DWORD *)v17 + 1) = 2;
    *((_DWORD *)v17 + 2) = a8;
    *(_OWORD *)(v17 + 12) = 0u;
    *(_OWORD *)(v17 + 2_Block_object_dispose(va, 8) = 0u;
    if (a4) {
      *(_OWORD *)(v17 + 12) = *a4;
    }
    if (a5) {
      *(_OWORD *)(v17 + 2_Block_object_dispose(va, 8) = *a5;
    }
    if (a8) {
      memcpy(v17 + 44, a7, a8);
    }
    uint64_t v18 = v15(a2, 44LL, 0LL, (char *)&v21 - ((a8 + 59) & 0xFFFFFFFFFFFFFFF0LL), a8 + 44, 0LL, 0LL);
    if ((_DWORD)v18) {
      unsigned int v19 = 70;
    }
    else {
      unsigned int v19 = 10;
    }
  }

  else
  {
    unsigned int v19 = 70;
    uint64_t v18 = 4294967293LL;
  }

  return v18;
}

uint64_t LibCall_ACMTRMLoadState( uint64_t (*a1)(uint64_t, uint64_t, void, void, void, uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v8 = 70;
  uint64_t v9 = 4294967293LL;
  if (a1 && a3 && a4)
  {
    uint64_t v9 = a1(a2, 38LL, 0LL, 0LL, 0LL, a3, a4);
    if ((_DWORD)v9) {
      unsigned int v8 = 70;
    }
    else {
      unsigned int v8 = 10;
    }
  }

  return v9;
}

uint64_t LibCall_ACMTRMSaveState( uint64_t (*a1)(uint64_t, uint64_t, void, uint64_t, uint64_t, void, void), uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  if (a1)
  {
    BOOL v10 = (unint64_t)(a4 - 8193) < 0xFFFFFFFFFFFFE000LL;
    if (!a3) {
      BOOL v10 = a4 != 0;
    }
    unsigned int v11 = 70;
    if (!v10)
    {
      if (a5) {
        uint64_t v12 = 43LL;
      }
      else {
        uint64_t v12 = 39LL;
      }
      uint64_t v13 = a1(a2, v12, 0LL, a3, a4, 0LL, 0LL);
      if ((_DWORD)v13) {
        unsigned int v11 = 70;
      }
      else {
        unsigned int v11 = 10;
      }
      goto LABEL_13;
    }
  }

  else
  {
    unsigned int v11 = 70;
  }

  uint64_t v13 = 4294967293LL;
LABEL_13:
  return v13;
}

uint64_t LibCall_ACMContextLoadFromImage( uint64_t (*a1)(uint64_t, uint64_t, void, char *, uint64_t, _OWORD *, unint64_t *), uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  unsigned int v10 = 70;
  uint64_t v11 = 4294967293LL;
  if (a1 && a3 && (unint64_t)(a4 - 4097) >= 0xFFFFFFFFFFFFF000LL)
  {
    uint64_t v12 = acm_mem_alloc(0x14uLL);
    acm_mem_alloc_info( "ACMHandleWithPayload",  v12,  20LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  1447,  "LibCall_ACMContextLoadFromImage");
    if (v12)
    {
      bzero(v20, 0x1005uLL);
      char v19 = 1;
      *(_WORD *)&v20[1] = 6;
      __int16 v21 = a4;
      __memcpy_chk(&v22, a3, a4, 4096LL);
      memset(v17, 0, sizeof(v17));
      uint64_t v18 = 0LL;
      unint64_t v16 = 280LL;
      uint64_t v13 = a1(a2, 48LL, 0LL, &v19, 4102LL, v17, &v16);
      if ((_DWORD)v13)
      {
        uint64_t v11 = v13;
      }

      else if (v16 < 0x18)
      {
        uint64_t v11 = 4294967291LL;
      }

      else
      {
        if (LOBYTE(v17[0]))
        {
          uint64_t v11 = 0LL;
          int v14 = DWORD1(v17[1]);
          *(_OWORD *)uint64_t v12 = *(_OWORD *)((char *)v17 + 4);
          v12[4] = v14;
          *a5 = v12;
          unsigned int v10 = 10;
          goto LABEL_11;
        }

        uint64_t v11 = 4294967280LL;
      }

      acm_mem_free_info( "ACMHandleWithPayload",  v12,  0x14uLL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  1508,  "LibCall_ACMContextLoadFromImage");
      acm_mem_free(v12, 0x14uLL);
      unsigned int v10 = 70;
    }

    else
    {
      unsigned int v10 = 70;
      uint64_t v11 = 4294967292LL;
    }
  }

uint64_t LibCall_ACMContextUnloadToImage( uint64_t (*a1)(uint64_t, uint64_t, void, int *, uint64_t, _BYTE *, int *), uint64_t a2, __int128 *a3, void *a4, void *a5)
{
  unsigned int v10 = 70;
  uint64_t v11 = 4294967293LL;
  if (a1 && a4 && a5)
  {
    int v19 = 1310721;
    if (a3) {
      __int128 v20 = *a3;
    }
    else {
      __int128 v20 = 0uLL;
    }
    bzero(v16, 0x1106uLL);
    *(void *)uint64_t v15 = 4358LL;
    uint64_t v12 = a1(a2, 49LL, 0LL, &v19, 20LL, v16, v15);
    if ((_DWORD)v12)
    {
      uint64_t v11 = v12;
LABEL_18:
      unsigned int v10 = 70;
      goto LABEL_14;
    }

    if (*(void *)v15 < 6uLL)
    {
      unsigned int v10 = 70;
      uint64_t v11 = 4294967291LL;
    }

    else
    {
      if (v16[0])
      {
        uint64_t v14 = v17;
        uint64_t v11 = Util_ReadFromBuffer((uint64_t)v16, *(size_t *)v15, &v14, a4, (unsigned __int16)__n);
        if (!(_DWORD)v11)
        {
          *a5 = v14 - v17;
          unsigned int v10 = 10;
          goto LABEL_14;
        }

        goto LABEL_18;
      }

      unsigned int v10 = 70;
      uint64_t v11 = 4294967280LL;
    }
  }

uint64_t LibCall_ACMContextSetData( uint64_t (*a1)(uint64_t, uint64_t, void, void *, size_t, void, void), uint64_t a2, _OWORD *a3, int a4, _DWORD *a5, unsigned int a6, const void *a7, size_t a8)
{
  size_t __size = 0LL;
  unsigned int v16 = 70;
  uint64_t v17 = 4294967293LL;
  if (a1 && a3)
  {
    if ((a7 != 0LL) != (a8 != 0))
    {
      unsigned int v16 = 70;
      uint64_t v17 = 4294967293LL;
    }

    else if (a8 > 0xE00)
    {
      unsigned int v16 = 70;
      uint64_t v17 = 4294967276LL;
    }

    else
    {
      uint64_t Size = LibSer_StorageSetData_GetSize(a8, a5, a6, &__size);
      if ((_DWORD)Size)
      {
        uint64_t v17 = Size;
        unsigned int v16 = 70;
      }

      else
      {
        size_t v19 = __size;
        __int128 v20 = acm_mem_alloc_data(__size);
        acm_mem_alloc_info( "<data>",  v20,  v19,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  1593,  "LibCall_ACMContextSetData");
        if (v20)
        {
          uint64_t v21 = LibSer_StorageSetData_Serialize(a3, a4, a7, a8, a5, a6, (uint64_t)v20, &__size);
          if (!(_DWORD)v21) {
            uint64_t v21 = a1(a2, 40LL, 0LL, v20, __size, 0LL, 0LL);
          }
          uint64_t v17 = v21;
          rsize_t v22 = __size;
          acm_mem_free_info( "<data>",  v20,  __size,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  1605,  "LibCall_ACMContextSetData");
          acm_mem_free_data(v20, v22);
          if ((_DWORD)v17) {
            unsigned int v16 = 70;
          }
          else {
            unsigned int v16 = 10;
          }
        }

        else
        {
          unsigned int v16 = 70;
          uint64_t v17 = 4294967292LL;
        }
      }
    }
  }

  return v17;
}

uint64_t LibCall_ACMContextGetData( uint64_t (*a1)(uint64_t, uint64_t, void, void *, size_t, uint64_t, uint64_t), uint64_t a2, _OWORD *a3, int a4, char a5, _DWORD *a6, unsigned int a7, uint64_t a8, uint64_t a9)
{
  if (gACMLoggingLevel <= 0xAu)
  {
    uint64_t v16 = a8;
    printf("%s: %s: called.\n", "ACM", "LibCall_ACMContextGetData");
    a8 = v16;
  }

  size_t __size = 0LL;
  unsigned int v17 = 70;
  uint64_t v18 = 4294967293LL;
  if (a1)
  {
    uint64_t v26 = a2;
    if (a3)
    {
      uint64_t v18 = 4294967293LL;
      if (a8)
      {
        if (a9)
        {
          uint64_t v19 = a8;
          uint64_t Size = LibSer_StorageGetData_GetSize(a6, a7, &__size);
          if ((_DWORD)Size)
          {
            uint64_t v18 = Size;
            unsigned int v17 = 70;
          }

          else
          {
            size_t v21 = __size;
            rsize_t v22 = acm_mem_alloc_data(__size);
            acm_mem_alloc_info( "<data>",  v22,  v21,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  1628,  "LibCall_ACMContextGetData");
            if (v22)
            {
              uint64_t Data_Serialize = LibSer_StorageGetData_Serialize(a3, a4, a5, a6, a7, (uint64_t)v22, &__size);
              if (!(_DWORD)Data_Serialize) {
                uint64_t Data_Serialize = a1(v26, 41LL, 0LL, v22, __size, v19, a9);
              }
              uint64_t v18 = Data_Serialize;
              rsize_t v24 = __size;
              acm_mem_free_info( "<data>",  v22,  __size,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  1640,  "LibCall_ACMContextGetData");
              acm_mem_free_data(v22, v24);
              if ((_DWORD)v18) {
                unsigned int v17 = 70;
              }
              else {
                unsigned int v17 = 10;
              }
            }

            else
            {
              unsigned int v17 = 70;
              uint64_t v18 = 4294967292LL;
            }
          }
        }
      }
    }
  }

  return v18;
}

uint64_t LibCall_ACMPublishTrustedAccessories( uint64_t (*a1)(uint64_t, uint64_t, void, char *, size_t, void, void), uint64_t a2, const void *a3, size_t a4)
{
  uint64_t v7 = a1;
  if (gACMLoggingLevel <= 0xAu) {
    a1 = (uint64_t (*)(uint64_t, uint64_t, void, char *, size_t, void, void))printf( "%s: %s: called.\n",  "ACM",  "LibCall_ACMPublishTrustedAccessories");
  }
  if (v7)
  {
    if (a3) {
      BOOL v8 = 1;
    }
    else {
      BOOL v8 = a4 == 0;
    }
    char v9 = !v8;
    unsigned int v10 = 70;
    uint64_t v11 = 4294967293LL;
    if ((a4 & 0xF) == 0 && a4 <= 0x100 && (v9 & 1) == 0)
    {
      __chkstk_darwin(a1);
      uint64_t v12 = (_DWORD *)((char *)&v14 - ((a4 + 23) & 0xFFFFFFFFFFFFFFF0LL));
      *uint64_t v12 = 1;
      v12[1] = a4;
      if (a4) {
        memcpy(v12 + 2, a3, a4);
      }
      uint64_t v11 = v7(a2, 45LL, 0LL, (char *)&v14 - ((a4 + 23) & 0xFFFFFFFFFFFFFFF0LL), a4 + 8, 0LL, 0LL);
      if ((_DWORD)v11) {
        unsigned int v10 = 70;
      }
      else {
        unsigned int v10 = 10;
      }
    }
  }

  else
  {
    unsigned int v10 = 70;
    uint64_t v11 = 4294967293LL;
  }

  return v11;
}

uint64_t LibCall_ACMContextGetInfo( uint64_t (*a1)(uint64_t, uint64_t, void, int *, uint64_t, _OWORD *, unint64_t *), uint64_t a2, __int128 *a3, int a4, void *a5)
{
  unsigned int v10 = 70;
  uint64_t v11 = 4294967293LL;
  if (a3 && a1 && a5)
  {
    int v16 = 1;
    int v18 = a4;
    __int128 v17 = *a3;
    memset(v15, 0, 140);
    unint64_t v14 = 140LL;
    uint64_t v12 = a1(a2, 46LL, 0LL, &v16, 24LL, v15, &v14);
    if ((_DWORD)v12)
    {
      uint64_t v11 = v12;
    }

    else if (v14 < 0xC)
    {
      uint64_t v11 = 4294967291LL;
    }

    else
    {
      if (LODWORD(v15[0]))
      {
        uint64_t v11 = 0LL;
        *a5 = *(void *)((char *)v15 + 4);
        unsigned int v10 = 10;
        goto LABEL_10;
      }

      uint64_t v11 = 4294967281LL;
    }

    unsigned int v10 = 70;
  }

uint64_t verifyAclConstraintInternal( uint64_t (*a1)(uint64_t, uint64_t, void, void *, size_t, unsigned int *, unint64_t *), uint64_t a2, uint64_t a3, _OWORD *a4, const void *a5, uint64_t a6, const void *a7, unsigned int a8, unsigned __int8 a9, _DWORD *a10, unsigned int a11, unsigned int a12, BOOL *a13, int **a14)
{
  size_t v36 = 0LL;
  unint64_t v34 = 0LL;
  unint64_t v35 = 4096LL;
  size_t v33 = 0LL;
  uint64_t v20 = 4294967293LL;
  if (!a4 || !a5 || !a6 || !a13)
  {
LABEL_19:
    if (!(_DWORD)v20) {
      goto LABEL_22;
    }
    goto LABEL_20;
  }

  SerializedVerifyAclConstraintuint64_t Size = GetSerializedVerifyAclConstraintSize( a3,  (uint64_t)a4,  (uint64_t)a5,  a6,  (uint64_t)a7,  a8,  a9,  a12,  a10,  a11,  &v36);
  if (!(_DWORD)SerializedVerifyAclConstraintSize)
  {
    uint64_t v22 = v36;
    uint64_t v23 = acm_mem_alloc_data(v36);
    acm_mem_alloc_info( "<data>",  v23,  v22,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  1929,  "verifyAclConstraintInternal");
    if (v23)
    {
      uint64_t v24 = SerializeVerifyAclConstraint(a3, a4, a5, a6, a7, a8, a9, a12, a10, a11, (uint64_t)v23, &v36);
      if ((_DWORD)v24)
      {
        uint64_t v20 = v24;
        unint64_t v25 = 0LL;
      }

      else
      {
        unint64_t v25 = (unsigned int *)acm_mem_alloc_data(0x1000uLL);
        acm_mem_alloc_info( "<data>",  v25,  4096LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  1935,  "verifyAclConstraintInternal");
        if (v25)
        {
          uint64_t v26 = a1(a2, a3, 0LL, v23, v36, v25, &v35);
          if ((_DWORD)v26)
          {
            uint64_t v20 = v26;
          }

          else
          {
            unint64_t v27 = v35 - 4;
            if (v35 < 4)
            {
              uint64_t v20 = 4294967291LL;
            }

            else
            {
              *a13 = *v25 != 0;
              if (a14)
              {
                uint64_t v20 = DeserializeRequirement(v25 + 1, v27, (void **)&v34, &v33);
                if (!(_DWORD)v20) {
                  *a14 = v34;
                }
              }

              else
              {
                uint64_t v20 = 0LL;
              }
            }
          }
        }

        else
        {
          uint64_t v20 = 4294967292LL;
        }
      }

      rsize_t v28 = v36;
      acm_mem_free_info( "<data>",  v23,  v36,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  1958,  "verifyAclConstraintInternal");
      acm_mem_free_data(v23, v28);
      if (v25)
      {
        acm_mem_free_info( "<data>",  v25,  0x1000uLL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  1961,  "verifyAclConstraintInternal");
        acm_mem_free_data(v25, 0x1000uLL);
      }
    }

    else
    {
      uint64_t v20 = 4294967292LL;
    }

    goto LABEL_19;
  }

  uint64_t v20 = SerializedVerifyAclConstraintSize;
LABEL_20:
  if (v34) {
    Util_DeallocRequirement(v34);
  }
LABEL_22:
  if ((_DWORD)v20) {
    unsigned int v29 = 70;
  }
  else {
    unsigned int v29 = 10;
  }
  return v20;
}

uint64_t LibCall_ACMSecContextProcessAcl( uint64_t (*a1)(uint64_t, uint64_t, void, char *, uint64_t, int *, uint64_t *), uint64_t a2, _OWORD *a3, unsigned __int8 *a4, uint64_t a5, unsigned __int8 *a6, uint64_t a7, _DWORD *a8, unsigned int a9, unsigned int a10, _DWORD *a11, BOOL *a12)
{
  return sub_10009445C(a1, a2, 12, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, 0LL, 0LL);
}

uint64_t sub_10009445C( uint64_t (*a1)(uint64_t, uint64_t, void, char *, uint64_t, int *, uint64_t *), uint64_t a2, int a3, _OWORD *a4, unsigned __int8 *a5, uint64_t a6, unsigned __int8 *a7, uint64_t a8, _DWORD *a9, unsigned int a10, unsigned int a11, _DWORD *a12, BOOL *a13, void *a14, unint64_t *a15)
{
  unsigned int v19 = gACMLoggingLevel;
  if (gACMLoggingLevel <= 0xAu)
  {
    printf("%s: %s: called.\n", "ACM", "processAclCommandInternal");
    unsigned int v19 = gACMLoggingLevel;
  }

  if (v19 <= 0x14)
  {
    printf("%s: %s: command = %u.\n", "ACM", "processAclCommandInternal", a3);
    unsigned int v19 = gACMLoggingLevel;
    if (gACMLoggingLevel <= 0x14u)
    {
      printf("%s: %s: context = %p.\n", "ACM", "processAclCommandInternal", a4);
      unsigned int v19 = gACMLoggingLevel;
      if (gACMLoggingLevel <= 0x14u)
      {
        printf("%s: %s: acl = %p, aclCFIndex Length = %zu.\n", "ACM", "processAclCommandInternal", a5, a6);
        unsigned int v19 = gACMLoggingLevel;
        if (gACMLoggingLevel <= 0x14u)
        {
          printf("%s: %s (len=%u): acl:", "ACM", "processAclCommandInternal", a6);
          unsigned int v19 = gACMLoggingLevel;
        }
      }
    }
  }

  if (a6)
  {
    uint64_t v20 = a6;
    size_t v21 = a5;
    do
    {
      if (v19 <= 0x14)
      {
        printf("%02x ", *v21);
        unsigned int v19 = gACMLoggingLevel;
      }

      ++v21;
      --v20;
    }

    while (v20);
  }

  if (v19 < 0x15)
  {
    putchar(10);
    unsigned int v19 = gACMLoggingLevel;
    if (gACMLoggingLevel <= 0x14u)
    {
      printf("%s: %s: operation = %p, operationCFIndex Length = %zu.\n", "ACM", "processAclCommandInternal", a7, a8);
      unsigned int v19 = gACMLoggingLevel;
      if (gACMLoggingLevel <= 0x14u)
      {
        printf("%s: %s (len=%u): operation:", "ACM", "processAclCommandInternal", a8);
        unsigned int v19 = gACMLoggingLevel;
      }
    }
  }

  int v39 = a3;
  if (a8)
  {
    uint64_t v22 = a8;
    uint64_t v23 = a7;
    do
    {
      if (v19 <= 0x14)
      {
        printf("%02x ", *v23);
        unsigned int v19 = gACMLoggingLevel;
      }

      ++v23;
      --v22;
    }

    while (v22);
  }

  if (v19 < 0x15)
  {
    putchar(10);
    if (gACMLoggingLevel <= 0x14u)
    {
      printf("%s: %s: parameters = %p, parameterCFIndex Count = %u.\n", "ACM", "processAclCommandInternal", a9, a10);
      if (gACMLoggingLevel <= 0x14u)
      {
        printf("%s: %s: maxGlobalCredentialAge = %u.\n", "ACM", "processAclCommandInternal", a11);
        if (gACMLoggingLevel <= 0x14u)
        {
          printf("%s: %s: constraintState = %p.\n", "ACM", "processAclCommandInternal", a12);
        }
      }
    }
  }

  if (a7 || a9 || a12)
  {
    if (a5) {
      BOOL v26 = a6 == 0;
    }
    else {
      BOOL v26 = 1;
    }
    int v27 = v26;
    unsigned int v24 = 70;
    uint64_t v25 = 4294967293LL;
    if (!a7) {
      goto LABEL_79;
    }
    if (!a8) {
      goto LABEL_79;
    }
    if (v27) {
      goto LABEL_79;
    }
    unsigned int v24 = 70;
    uint64_t v25 = 4294967293LL;
    if ((a9 != 0LL) != (a10 != 0) || !a12) {
      goto LABEL_79;
    }
    size_t v45 = 0LL;
    unint64_t v44 = 4096LL;
    uint64_t SerializedProcessAclSize = GetSerializedProcessAclSize( (uint64_t)a4,  (uint64_t)a5,  a6,  (uint64_t)a7,  a8,  a11,  a9,  a10,  &v45);
    if ((_DWORD)SerializedProcessAclSize)
    {
      uint64_t v25 = SerializedProcessAclSize;
      unsigned int v37 = 70;
      goto LABEL_74;
    }

    uint64_t v29 = v45;
    __int16 v30 = acm_mem_alloc_data(v45);
    acm_mem_alloc_info( "<data>",  v30,  v29,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  1776,  "processAclInternal");
    if (!v30)
    {
      unsigned int v37 = 70;
      uint64_t v25 = 4294967292LL;
      goto LABEL_74;
    }

    unint64_t v44 = 4096LL;
    unint64_t v31 = acm_mem_alloc_data(0x1000uLL);
    acm_mem_alloc_info( "<data>",  v31,  4096LL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  1780,  "processAclInternal");
    if (!v31)
    {
      unint64_t v35 = 0LL;
      unint64_t v34 = 0LL;
      uint64_t v25 = 4294967292LL;
      goto LABEL_68;
    }

    uint64_t v32 = SerializeProcessAcl(a4, a5, a6, a7, a8, a11, a9, a10, (uint64_t)v30, &v45);
    if ((_DWORD)v32 || (uint64_t v32 = a1(a2, v39, 0LL, (char *)v30, v45, v31, (uint64_t *)&v44), (_DWORD)v32))
    {
      uint64_t v25 = v32;
      unint64_t v34 = 0LL;
      unint64_t v35 = 0LL;
      goto LABEL_67;
    }

    unint64_t v33 = v44;
    if (v44 >= 8)
    {
      *a12 = *v31;
      if (a13) {
        *a13 = v31[1] != 0;
      }
      uint64_t v25 = 0LL;
      unint64_t v34 = 0LL;
      if (v39 != 30 || !a14)
      {
        unint64_t v35 = 0LL;
        goto LABEL_67;
      }

      unint64_t v35 = 0LL;
      if (!a15)
      {
LABEL_67:
        acm_mem_free_info( "<data>",  v31,  0x1000uLL,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  1817,  "processAclInternal");
        acm_mem_free_data(v31, 0x1000uLL);
LABEL_68:
        rsize_t v36 = v45;
        acm_mem_free_info( "<data>",  v30,  v45,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  1821,  "processAclInternal");
        acm_mem_free_data(v30, v36);
        if ((_DWORD)v25 && v35)
        {
          acm_mem_free_info( "<data>",  v35,  v34,  "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c",  1825,  "processAclInternal");
          acm_mem_free_data(v35, v34);
          unsigned int v37 = 70;
        }

        else if ((_DWORD)v25)
        {
          unsigned int v37 = 70;
        }

        else
        {
          unsigned int v37 = 10;
        }

LABEL_79:
  return v25;
}

uint64_t LibCall_ACMSecContextProcessAclAndCopyAuthMethod( uint64_t (*a1)(uint64_t, uint64_t, void, char *, uint64_t, int *, uint64_t *), uint64_t a2, _OWORD *a3, unsigned __int8 *a4, uint64_t a5, unsigned __int8 *a6, uint64_t a7, _DWORD *a8, unsigned int a9, unsigned int a10, _DWORD *a11, BOOL *a12, void *a13, unint64_t *a14)
{
  return sub_10009445C(a1, a2, 30, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
}

uint64_t LibCall_ACMSecContextVerifyAclConstraintAndCopyRequirement( uint64_t (*a1)(uint64_t, uint64_t, void, void *, size_t, unsigned int *, unint64_t *), uint64_t a2, _OWORD *a3, const void *a4, uint64_t a5, const void *a6, unsigned int a7, unsigned __int8 a8, _DWORD *a9, unsigned int a10, unsigned int a11, BOOL *a12, int **a13)
{
  unsigned int v21 = 70;
  uint64_t v22 = 4294967293LL;
  if (a3)
  {
    if (a4)
    {
      if (a5)
      {
        unsigned int v21 = 70;
        uint64_t v22 = 4294967293LL;
        if ((a9 != 0LL) == (a10 != 0))
        {
          if (a12)
          {
            uint64_t v22 = verifyAclConstraintInternal(a1, a2, 11LL, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
            if ((_DWORD)v22) {
              unsigned int v21 = 70;
            }
            else {
              unsigned int v21 = 10;
            }
          }
        }
      }
    }
  }

  if (v21 >= gACMLoggingLevel) {
    printf( "%s: %s: returning, CFErrorRef err = %ld.\n",  "ACM",  "LibCall_ACMSecContextVerifyAclConstraintAndCopyRequirement",  (int)v22);
  }
  return v22;
}

uint64_t LibCall_ACMSecCredentialProviderEnrollmentStateChangedForUser( uint64_t (*a1)(uint64_t, uint64_t, void, char *, uint64_t, void, void), uint64_t a2, const void *a3, unsigned int a4, _OWORD *a5, uint64_t a6, int a7, _OWORD *a8, uint64_t a9)
{
  int v16 = a1;
  if (gACMLoggingLevel <= 0xAu) {
    a1 = (uint64_t (*)(uint64_t, uint64_t, void, char *, uint64_t, void, void))printf( "%s: %s: called.\n",  "ACM",  "LibCall_ACMSecCredentialPr oviderEnrollmentStateChangedForUser");
  }
  BOOL v17 = a4 - 113 < 0xFFFFFF90;
  if (!a3) {
    BOOL v17 = a4 != 0;
  }
  if (v17)
  {
    unsigned int v18 = 70;
    uint64_t v19 = 4294967293LL;
  }

  else
  {
    unsigned int v18 = 70;
    uint64_t v19 = 4294967293LL;
    if (a8)
    {
      if (a9 == 16)
      {
        uint64_t v19 = 4294967293LL;
        if (a5)
        {
          if (a6 == 16)
          {
            uint64_t v20 = a4 + 36LL;
            __chkstk_darwin(a1);
            uint64_t v22 = (char *)&v24 - ((v21 + 51) & 0x1FFFFFFF0LL);
            *(_DWORD *)uint64_t v22 = a7;
            *(_OWORD *)(v22 + 4) = *a8;
            *(_OWORD *)(v22 + 20) = *a5;
            if (a3) {
              memcpy(v22 + 36, a3, v21);
            }
            uint64_t v19 = v16(a2, 14LL, 0LL, v22, v20, 0LL, 0LL);
            if ((_DWORD)v19) {
              unsigned int v18 = 70;
            }
            else {
              unsigned int v18 = 10;
            }
          }
        }
      }
    }
  }

  if (v18 >= gACMLoggingLevel) {
    printf( "%s: %s: returning, CFErrorRef err = %ld.\n",  "ACM",  "LibCall_ACMSecCredentialProviderEnrollmentStateChangedForUser",  (int)v19);
  }
  return v19;
}

uint64_t LibCall_ACMSecSetBuiltinBiometry( uint64_t (*a1)(uint64_t, uint64_t, void, char *, size_t, void, void), uint64_t a2, char a3)
{
  char v9 = a3;
  uint64_t v5 = LibCall_ACMSetEnvironmentVariable(a1, a2, 30, 0LL, 0LL, 0LL, &v9, 1uLL);
  uint64_t v6 = v5;
  if ((_DWORD)v5) {
    unsigned int v7 = 70;
  }
  else {
    unsigned int v7 = 10;
  }
  return v6;
}

uint64_t LibCall_ACMSecSetBiometryAvailability( uint64_t (*a1)(uint64_t, uint64_t, void, int *, uint64_t, uint64_t, uint64_t), uint64_t a2, char a3, int a4)
{
  char v15 = 0;
  unint64_t v14 = 1LL;
  char v13 = 0;
  uint64_t v8 = LibCall_ACMGetEnvironmentVariable(a1, a2, 6, (uint64_t)&v15, (uint64_t)&v14);
  if ((_DWORD)v8)
  {
    uint64_t v11 = v8;
    unsigned int v9 = 70;
  }

  else
  {
    unsigned int v9 = 70;
    if (v14 > 1)
    {
      uint64_t v11 = 4294967291LL;
    }

    else
    {
      char v10 = v15 & ~a3;
      if (a4) {
        char v10 = v15 | a3;
      }
      char v13 = v10;
      uint64_t v11 = LibCall_ACMSetEnvironmentVariable( (uint64_t (*)(uint64_t, uint64_t, void, char *, size_t, void, void))a1,  a2,  6,  0LL,  0LL,  0LL,  &v13,  1uLL);
      if ((_DWORD)v11) {
        unsigned int v9 = 70;
      }
      else {
        unsigned int v9 = 10;
      }
    }
  }

  return v11;
}

uint64_t LibCall_ACMSecContextGetUnlockSecret( uint64_t (*a1)(void, void, void, void, void, void, void), uint64_t a2, _OWORD *a3, _DWORD *a4, unsigned int a5, void *a6, size_t *a7, _BYTE *a8)
{
  uint64_t v25 = 64LL;
  uint64_t v24 = 129LL;
  if (!a3) {
    goto LABEL_18;
  }
  unsigned int v16 = 70;
  uint64_t v17 = 4294967293LL;
  if (!a6 || !a7 || !a8) {
    goto LABEL_14;
  }
  if ((a4 != 0LL) != (a5 != 0))
  {
LABEL_18:
    unsigned int v16 = 70;
    uint64_t v17 = 4294967293LL;
    goto LABEL_14;
  }

  uint64_t UnlockSecret_Serialize = LibSer_GetUnlockSecret_Serialize(a3, a4, a5, v27, &v25);
  if ((_DWORD)UnlockSecret_Serialize
    || (uint64_t UnlockSecret_Serialize = a1(a2, 50LL, 0LL, v27, v25, v26, &v24), (_DWORD)UnlockSecret_Serialize)
    || (size_t __n = 0LL,
        __src = 0LL,
        char v21 = 0,
        uint64_t UnlockSecret_Serialize = LibSer_GetUnlockSecretResponse_Deserialize(v26, v24, &__src, &__n, &v21),
        (_DWORD)UnlockSecret_Serialize))
  {
    uint64_t v17 = UnlockSecret_Serialize;
  }

  else
  {
    size_t v19 = __n;
    if (*a7 < __n)
    {
      uint64_t v17 = 4294967276LL;
    }

    else
    {
      if (__src)
      {
        memcpy(a6, __src, __n);
        uint64_t v17 = 0LL;
        *a7 = v19;
        *a8 = v21;
        unsigned int v16 = 10;
        goto LABEL_14;
      }

      uint64_t v17 = 4294967291LL;
    }
  }

  unsigned int v16 = 70;
LABEL_14:
  return v17;
}

uint64_t LibCall_ACMSEPControl( uint64_t (*a1)(uint64_t, uint64_t, void, char *, uint64_t, unsigned int *, unint64_t *), uint64_t a2, const void *a3, size_t a4, uint64_t a5, _DWORD *a6, unsigned int a7, void *a8, size_t *a9)
{
  __int16 v30 = a8;
  unint64_t v33 = 1024LL;
  uint64_t v34 = 0LL;
  if (!a1) {
    goto LABEL_17;
  }
  BOOL v16 = a4 - 4097 < 0xFFFFFFFFFFFFF000LL;
  if (!a3) {
    BOOL v16 = a4 != 0;
  }
  if (v16)
  {
LABEL_17:
    unsigned int v25 = 70;
    uint64_t v24 = 4294967293LL;
    goto LABEL_21;
  }

  uint64_t Size = LibSer_SEPControl_GetSize(a4, a6, a7, &v34);
  if ((_DWORD)Size)
  {
LABEL_18:
    uint64_t v24 = Size;
LABEL_25:
    unsigned int v25 = 70;
    goto LABEL_21;
  }

  uint64_t v18 = a5;
  uint64_t v19 = a2;
  uint64_t v20 = (_OWORD *)__chkstk_darwin(v18);
  uint64_t v22 = (char *)&v29 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = LibSer_SEPControl_Serialize(v20, a6, a7, a3, a4, (uint64_t)v22, &v34);
  if ((_DWORD)v23)
  {
    uint64_t v24 = v23;
    goto LABEL_20;
  }

  uint64_t v24 = a1(v19, 51LL, 0LL, v22, v34, v35, &v33);
  if ((_DWORD)v24)
  {
LABEL_20:
    unsigned int v25 = 70;
    goto LABEL_21;
  }

  unsigned int v25 = 10;
  BOOL v26 = v30;
  if (!v30 || !a9) {
    goto LABEL_21;
  }
  size_t v31 = 0LL;
  uint64_t v32 = 0LL;
  uint64_t Size = LibSer_SEPControlResponse_Deserialize(v35, v33, &v32, &v31);
  if ((_DWORD)Size) {
    goto LABEL_18;
  }
  size_t v27 = v31;
  if (*a9 < v31)
  {
    uint64_t v24 = 4294967276LL;
    goto LABEL_25;
  }

  if (v32) {
    memcpy(v26, v32, v31);
  }
  uint64_t v24 = 0LL;
  *a9 = v27;
  unsigned int v25 = 10;
LABEL_21:
  return v24;
}

uint64_t sub_100095584( uint64_t (*a1)(uint64_t, uint64_t, void, char *, uint64_t, int *, uint64_t *), uint64_t a2, const void *a3, unsigned int a4, _BYTE *a5)
{
  int v19 = 0;
  uint64_t v18 = 4LL;
  size_t v10 = a4;
  uint64_t v11 = a4 + 4LL;
  __chkstk_darwin(a1);
  uint64_t v12 = (unsigned int *)((char *)&v17 - ((v10 + 19) & 0x1FFFFFFF0LL));
  unsigned int v13 = 70;
  uint64_t v14 = 4294967293LL;
  if (a3 && a5)
  {
    *uint64_t v12 = a4;
    memcpy(v12 + 1, a3, v10);
    uint64_t v15 = a1(a2, 17LL, 0LL, (char *)&v17 - ((v10 + 19) & 0x1FFFFFFF0LL), v11, &v19, &v18);
    if ((_DWORD)v15)
    {
      uint64_t v14 = v15;
      unsigned int v13 = 70;
    }

    else if (v18 == 4)
    {
      uint64_t v14 = 0LL;
      *a5 = 1;
      unsigned int v13 = 10;
    }

    else
    {
      unsigned int v13 = 70;
      uint64_t v14 = 4294967291LL;
    }
  }

  return v14;
}

void sub_10009573C()
{
  __assert_rtn("LibCall_ACMKernelControl", "LibCall.c", 373, "commandCursor == commandBuffer + sizeof(commandBuffer)");
}

uint64_t sub_100095764()
{
  int v2 = -1;
  uint64_t v0 = ccrng(&v2);
  sub_1000A5138(v0 != 0, 22, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform_lib.c");
  sub_1000A5138(v2 == 0, 23, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform_lib.c");
  return v0;
}

uint64_t sub_1000957D0(uint64_t a1, unsigned int a2)
{
  unsigned int v4 = *(unsigned int (**)(uint64_t, void, uint64_t))sub_1000A8F94();
  uint64_t v5 = sub_1000A8F94();
  BOOL v6 = v4(v5, a2, a1) == 0;
  return sub_1000A5138(v6, 31, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform_lib.c");
}

uint64_t sub_100095824( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(uint64_t, void *, uint64_t *, uint64_t *, uint64_t), uint64_t *a5, unint64_t a6, void *a7, unint64_t *a8)
{
  uint64_t v42 = a1;
  uint64_t v43 = a3;
  memset(__s, 0, sizeof(__s));
  uint64_t v14 = (void *)ccaes_cbc_encrypt_mode();
  __chkstk_darwin(v14);
  uint64_t v44 = (uint64_t)&v37 - v15;
  bzero((char *)&v37 - v15, v15);
  __chkstk_darwin(v16);
  uint64_t v18 = (char *)&v37 - v17;
  bzero((char *)&v37 - v17, v17);
  uint64_t v19 = 0xFFFFFFFFLL;
  unint64_t v40 = &v37;
  uint64_t v41 = a8;
  int v39 = a7;
  if (!a4)
  {
    BOOL v21 = (a2 & 0xFFFFFFFFFFFFFFF7LL) == 0x10 || a2 == 32;
    if (!v21 || !a8 || *a8 < a6 + 8)
    {
      memset_s(__s, 0x40uLL, 0, 0x40uLL);
      goto LABEL_31;
    }

    unint64_t v38 = a6 + 8;
    cccbc_init(v14, v44, a2, v42);
    goto LABEL_15;
  }

  if (a8)
  {
    unint64_t v20 = *v41;
    unint64_t v38 = a6 + 8;
    if (v20 >= a6 + 8)
    {
LABEL_15:
      uint64_t v22 = 0LL;
      unsigned int v23 = a6 >> 3;
      else {
        uint64_t v24 = v23;
      }
      do
      {
        uint64_t v25 = *a5++;
        *((void *)&__s[v22++] + 1) = v25;
      }

      while (v24 != v22);
      uint64_t v26 = 0LL;
      *(void *)&__s[0] = v43;
      uint64_t v27 = 1LL;
      uint64_t v42 = v23;
      do
      {
        uint64_t v43 = v26;
        uint64_t v28 = 0LL;
        uint64_t v29 = (uint64_t *)__s;
        do
        {
          if (a4)
          {
            if ((a4(1LL, &unk_1000DBD80, v29, v29, 16LL) & 1) == 0) {
              goto LABEL_6;
            }
          }

          else
          {
            cccbc_clear_iv(v18, v14[1]);
            sub_1000A5B18((uint64_t)v14, v44, (uint64_t)v18, 0x10uLL);
          }

          uint64_t v30 = *v29;
          v29 += 2;
          unint64_t v31 = v30 ^ bswap64(v27 + v28++);
          *(void *)&__s[v28 % v23] = v31;
        }

        while (v24 != v28);
        uint64_t v26 = v43 + 1;
        v27 += v42;
      }

      while (v43 != 5);
      uint64_t v32 = v39;
      *int v39 = *(void *)&__s[0];
      unint64_t v33 = v32 + 1;
      uint64_t v34 = (uint64_t *)__s + 1;
      do
      {
        uint64_t v35 = *v34;
        v34 += 2;
        *v33++ = v35;
        --v24;
      }

      while (v24);
      uint64_t v19 = 0LL;
      *uint64_t v41 = v38 & 0xFFFFFFF8;
LABEL_30:
      memset_s(__s, 0x40uLL, 0, 0x40uLL);
      if (a4) {
        return v19;
      }
LABEL_31:
      cc_clear(*v14, v44);
      return v19;
    }
  }

uint64_t sub_100095B30( uint64_t a1, unsigned int a2, uint64_t a3, uint64_t (*a4)(uint64_t, void *, uint64_t *, uint64_t *, uint64_t), uint64_t *a5, unsigned int a6, void *a7, _DWORD *a8)
{
  unint64_t v11 = *a8;
  uint64_t v9 = sub_100095824(a1, a2, a3, a4, a5, a6, a7, &v11);
  sub_1000A5138(HIDWORD(v11) == 0, 171, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/aeskeywrap.c");
  *a8 = v11;
  return v9;
}

uint64_t sub_100095B98( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void, void *, unint64_t *, unint64_t *, uint64_t), void *a5, unint64_t a6, void *a7, void *a8)
{
  char v46 = a5;
  uint64_t v44 = a1;
  memset(__s, 0, sizeof(__s));
  uint64_t v14 = (void *)ccaes_cbc_decrypt_mode();
  __chkstk_darwin(v14);
  uint64_t v47 = (uint64_t)&v38 - v15;
  bzero((char *)&v38 - v15, v15);
  __chkstk_darwin(v16);
  uint64_t v18 = (char *)&v38 - v17;
  bzero((char *)&v38 - v17, v17);
  uint64_t v19 = 0xFFFFFFFFLL;
  if (HIDWORD(a6)) {
    goto LABEL_33;
  }
  uint64_t v40 = a3;
  unsigned int v20 = a6 >> 3;
  uint64_t v41 = &v38;
  uint64_t v42 = a8;
  int v39 = a7;
  unint64_t v45 = a6;
  if (!a4)
  {
    BOOL v21 = (a2 & 0xFFFFFFFFFFFFFFF7LL) == 0x10 || a2 == 32;
    if (!v21 || !a8 || *a8 < a6 - 8)
    {
      memset_s(__s, 0x40uLL, 0, 0x40uLL);
      goto LABEL_34;
    }

    cccbc_init(v14, v47, a2, v44);
    goto LABEL_15;
  }

  if (a8 && *v42 >= v45 - 8)
  {
LABEL_15:
    *(void *)&__s[0] = *v46;
    uint64_t v22 = v20 - 1;
    if (v20 != 1)
    {
      unsigned int v23 = (void *)__s + 1;
      uint64_t v24 = v46 + 1;
      uint64_t v25 = v20 - 1;
      do
      {
        uint64_t v26 = *v24++;
        void *v23 = v26;
        v23 += 2;
        --v25;
      }

      while (v25);
    }

    int v27 = 6 * v20 - 6;
    LODWORD(v44) = 1 - v20;
    int v28 = 5;
    uint64_t v43 = (unint64_t *)&__s[v20 - 2];
    do
    {
      LODWORD(v46) = v28;
      if (v45 >= 0x10)
      {
        uint64_t v29 = v43;
        int v30 = v22;
        unsigned int v31 = v27;
        do
        {
          *uint64_t v29 = *(void *)&__s[v30 % v22] ^ bswap64(v31);
          if (a4)
          {
            if ((a4(0LL, &unk_1000DBD80, v29, v29, 16LL) & 1) == 0) {
              goto LABEL_6;
            }
          }

          else
          {
            cccbc_clear_iv(v18, v14[1]);
            sub_1000A5B18((uint64_t)v14, v47, (uint64_t)v18, 0x10uLL);
          }

          --v31;
          v29 -= 2;
          BOOL v32 = __OFSUB__(v30--, 1);
        }

        while (!((v30 < 0) ^ v32 | (v30 == 0)));
      }

      int v28 = (_DWORD)v46 - 1;
      v27 += v44;
    }

    while ((_DWORD)v46);
    if (*(void *)&__s[0] == v40)
    {
      unint64_t v33 = v39;
      if ((_DWORD)v22)
      {
        uint64_t v34 = (uint64_t *)__s + 1;
        uint64_t v35 = v22;
        do
        {
          uint64_t v36 = *v34;
          v34 += 2;
          *v33++ = v36;
          --v35;
        }

        while (v35);
      }

      uint64_t v19 = 0LL;
      *uint64_t v42 = (8 * v22);
    }

    else
    {
      uint64_t v19 = 0xFFFFFFFFLL;
    }

uint64_t sub_100095EF4( uint64_t a1, unsigned int a2, uint64_t a3, uint64_t (*a4)(void, void *, unint64_t *, unint64_t *, uint64_t), void *a5, unsigned int a6, void *a7, _DWORD *a8)
{
  uint64_t v11 = *a8;
  uint64_t v9 = sub_100095B98(a1, a2, a3, a4, a5, a6, a7, &v11);
  sub_1000A5138(HIDWORD(v11) == 0, 261, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/aeskeywrap.c");
  *a8 = v11;
  return v9;
}

uint64_t sub_100095F5C(unsigned int a1, _DWORD *a2)
{
  uint64_t v2 = a1 + 15LL;
  uint64_t v3 = v2 << 31 >> 31;
  BOOL v4 = v3 != v2 || v3 < 0;
  int v5 = v4;
  if (!v4) {
    *a2 = v3 & 0xFFFFFFF8;
  }
  return v5 ^ 1u;
}

uint64_t sub_100095F88(unint64_t a1, unint64_t *a2)
{
  uint64_t v2 = a1 >= 0xFFFFFFFFFFFFFFF1LL;
  BOOL v3 = v2 << 63 >> 63 != v2 || v2 << 63 >> 63 == -1;
  int v4 = v3;
  if (!v3) {
    *a2 = (a1 + 15) & 0xFFFFFFFFFFFFFFF8LL;
  }
  return v4 ^ 1u;
}

BOOL sub_100095FB8(unsigned int a1, unsigned int *a2)
{
  unsigned int v2 = a1 - 8;
  BOOL result = a1 > 7;
  *a2 = v2;
  return result;
}

BOOL sub_100095FCC(unint64_t a1, unint64_t *a2)
{
  unint64_t v2 = a1 - 8;
  BOOL result = a1 > 7;
  *a2 = v2;
  return result;
}

uint64_t sub_100095FE0(uint64_t a1, void *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  *(void *)&__int128 v18 = __s;
  *((void *)&v18 + 1) = v22;
  size_t v19 = 4096LL;
  uint64_t v12 = 3758097090LL;
  if (a4 && a5)
  {
    mach_port_t v13 = sub_100096240();
    if (!v13)
    {
      fprintf( __stdoutp,  "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n",  "aks",  "",  "",  "",  "aks_fv_new_vek",  ":",  179,  "",  0,  "",  "");
      uint64_t v12 = 3758097084LL;
      goto LABEL_16;
    }

    mach_port_t v14 = v13;
    if (!ccder_blob_encode_body_tl(&v18, 4LL, 16LL, a4)
      || !sub_1000A7840(&v18, a3)
      || !sub_1000A7840(&v18, a2)
      || !sub_1000A7958(&v18, a1)
      || !ccder_blob_encode_tl(&v18, 0x2000000000000010LL, (char *)v22 - *((void *)&v18 + 1)))
    {
      goto LABEL_14;
    }

    input[0] = *((void *)&v18 + 1);
    input[1] = (uint64_t)v22 - *((void *)&v18 + 1);
    uint64_t v15 = IOConnectCallMethod(v14, 0x4Au, input, 2u, 0LL, 0LL, 0LL, 0LL, __s, &v19);
    if ((_DWORD)v15)
    {
      uint64_t v12 = v15;
      goto LABEL_16;
    }

    *(void *)&__int128 v17 = __s;
    *((void *)&v17 + 1) = &__s[v19];
    if (!ccder_blob_decode_range(&v17, 0x2000000000000010LL, &v17)
      || !sub_1000A78AC(&v17, 0, a5))
    {
      goto LABEL_14;
    }

    if (!a6)
    {
      uint64_t v12 = 0LL;
      goto LABEL_16;
    }

    uint64_t v12 = 0LL;
    if ((sub_1000A76A4(&v17, 0, a6) & 1) == 0) {
LABEL_14:
    }
      uint64_t v12 = 3758097098LL;
  }

LABEL_16:
  memset_s(__s, 0x1000uLL, 0, 0x1000uLL);
  return v12;
}

  memset_s(__s, 0x1000uLL, 0, 0x1000uLL);
  return v12;
}

uint64_t sub_100096240()
{
  if (qword_1000DBCA0 != -1) {
    dispatch_once(&qword_1000DBCA0, &stru_1000CF268);
  }
  dispatch_sync((dispatch_queue_t)qword_1000DBCA8, &stru_1000CF1E8);
  uint64_t result = dword_1000DBC90;
  if (!dword_1000DBC90)
  {
    syslog(3, "failed to open connection to %s\n", "AppleKeyStore");
    return dword_1000DBC90;
  }

  return result;
}

unint64_t sub_1000962C8(char *a1, const void *a2, size_t a3)
{
  unint64_t v3 = (unint64_t)a1;
  if (a1)
  {
    int v6 = open_dprotected_np(a1, 1793, 4, 0, 384LL);
    if (v6 == -1)
    {
      size_t v10 = __error();
      uint64_t v11 = strerror(*v10);
      syslog(3, "could not create file: %s (%s)\n", (const char *)v3, v11);
      return 0LL;
    }

    else
    {
      int v7 = v6;
      ssize_t v8 = write(v6, a2, a3);
      unint64_t v3 = v8 != -1;
      if (v8 == -1)
      {
        uint64_t v12 = __error();
        mach_port_t v13 = strerror(*v12);
        syslog(3, "failed to write restore bag to disk %s\n", v13);
      }

      close(v7);
    }
  }

  return v3;
}

const char *sub_100096398(char *a1, void *a2, off_t *a3)
{
  unint64_t v3 = a1;
  memset(&v14, 0, sizeof(v14));
  if (a1)
  {
    if (!stat(a1, &v14))
    {
      off_t st_size = v14.st_size;
      int v7 = open(v3, 0);
      if (v7 == -1)
      {
        uint64_t v12 = __error();
        mach_port_t v13 = strerror(*v12);
        syslog(3, "could not open file: %s (%s)\n", v3, v13);
      }

      else
      {
        int v8 = v7;
        uint64_t v9 = calloc(st_size, 1uLL);
        unint64_t v3 = (const char *)(v9 != 0LL);
        if (!v9)
        {
LABEL_7:
          close(v8);
          return v3;
        }

        size_t v10 = v9;
        if (read(v8, v9, st_size) == st_size)
        {
          *a2 = v10;
          *a3 = st_size;
          goto LABEL_7;
        }

        close(v8);
        free(v10);
      }
    }

    return 0LL;
  }

  return v3;
}

uint64_t sub_1000964A0(unsigned int a1, const void *a2)
{
  uint64_t input = a1;
  mach_port_t v3 = sub_100096240();
  if (v3) {
    return IOConnectCallMethod(v3, 0x6Cu, &input, 1u, a2, 0x10uLL, 0LL, 0LL, 0LL, 0LL);
  }
  fprintf( __stdoutp,  "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n",  "aks",  "",  "",  "",  "aks_delete_xart_leak",  ":",  268,  "",  0,  "",  "");
  return 3758097084LL;
}

char *sub_100096584(char *result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    v9[0] = result;
    v9[1] = 0LL;
    uint64_t result = (char *)fts_open(v9, 84, 0LL);
    if (result)
    {
      int v5 = (FTS *)result;
      int v6 = fts_read((FTS *)result);
      if (v6)
      {
        int v7 = v6;
        do
        {
          int fts_info = v7->fts_info;
          if (fts_info != 6)
          {
            if (fts_info == 1)
            {
              if (a2)
              {
              }
            }

            else if (a3 && fts_info == 8)
            {
              (*(void (**)(uint64_t, FTSENT *))(a3 + 16))(a3, v7);
            }
          }

          int v7 = fts_read(v5);
        }

        while (v7);
      }

      return (char *)fts_close(v5);
    }
  }

  return result;
}

char *sub_100096680(char *result, int a2)
{
  if (result)
  {
    mach_port_t v3 = result;
    bzero(v8, 0x400uLL);
    uint64_t result = realpath_DARWIN_EXTSN(v3, v8);
    if (result)
    {
      v6[0] = _NSConcreteStackBlock;
      v6[1] = 0x40000000LL;
      v6[2] = sub_10009675C;
      v6[3] = &unk_1000CF128;
      int v7 = a2;
      v4[0] = _NSConcreteStackBlock;
      v4[1] = 0x40000000LL;
      v4[2] = sub_10009680C;
      v4[3] = &unk_1000CF148;
      int v5 = a2;
      return sub_100096584(v8, (uint64_t)v6, (uint64_t)v4);
    }
  }

  return result;
}

uint64_t sub_10009675C(uint64_t a1, uint64_t a2)
{
  int v4 = sub_1000967B4(*(const char **)(a2 + 48));
  int v5 = *(_DWORD *)(a1 + 32);
  if (v5 == -1 || v4 == v5) {
    printf(" dir: %s %i\n", *(const char **)(a2 + 48), v4);
  }
  return 1LL;
}

uint64_t sub_1000967B4(const char *a1)
{
  int v1 = open_dprotected_np(a1, 0, 0, 1);
  if (v1 == -1) {
    return 0xFFFFFFFFLL;
  }
  int v2 = v1;
  uint64_t v3 = fcntl(v1, 63);
  if ((v2 & 0x80000000) == 0) {
    close(v2);
  }
  return v3;
}

uint64_t sub_10009680C(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_1000967B4(*(const char **)(a2 + 48));
  int v5 = *(_DWORD *)(a1 + 32);
  if (v5 == -1 || (_DWORD)result == v5) {
    return printf("file: %s %i\n", *(const char **)(a2 + 48), result);
  }
  return result;
}

uint64_t sub_100096860()
{
  io_registry_entry_t v0 = IORegistryEntryFromPath(kIOMasterPortDefault, "IODeviceTree:/filesystems");
  if (v0)
  {
    io_object_t v1 = v0;
    CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(v0, @"e-apfs", kCFAllocatorDefault, 0);
    BOOL v3 = CFProperty != 0LL;
    if (CFProperty) {
      CFRelease(CFProperty);
    }
    IOObjectRelease(v1);
  }

  else
  {
    BOOL v3 = 0;
  }

  size_t __len = 1023LL;
  bzero(__big, 0x400uLL);
  if ((byte_1000DBC98 & 1) == 0)
  {
    if (!sysctlbyname("kern.bootargs", __big, &__len, 0LL, 0LL) && strnstr(__big, "-apfs_shared_datavolume", __len)) {
      byte_1000DBC99 = 1;
    }
    byte_1000DBC98 = 1;
  }

  unsigned int v4 = byte_1000DBC99;
  fprintf( __stdoutp,  "%s%s:%s%s%s%s%u:%s%u:%s ioreg: %d, boot_arg: %d%s\n",  "aks",  "",  "",  "",  "aks_fs_supports_enhanced_apfs",  ":",  437,  "",  0,  "",  v3,  byte_1000DBC99,  "");
  return v3 | v4;
}

uint64_t sub_1000969E0(const char *a1)
{
  if (realpath_DARWIN_EXTSN(a1, v4))
  {
    snprintf(__str, 0x400uLL, "%s/mobile", v4);
    sub_100096AB0(v4, (uint64_t)&off_1000CDD08, 35LL);
    if ((sub_100096860() & 1) == 0) {
      sub_100096AB0(__str, (uint64_t)&off_1000CE398, 72LL);
    }
  }

  return 0LL;
}

void sub_100096AB0(const char *a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v6 = a2 + 16;
    do
    {
      snprintf(__str, 0x400uLL, "%s%s", a1, *(const char **)(v6 - 16));
      if (stat(__str, &v7))
      {
        printf("stat failed: %s\n");
      }

      else
      {
        sub_1000967B4(__str);
        printf("%s: mode=%o, u/g=%i:%i class=%i%s\n");
      }

      v6 += 48LL;
      --a3;
    }

    while (a3);
  }

uint64_t sub_100096BF0(const char *a1)
{
  if (realpath_DARWIN_EXTSN(a1, v3)) {
    sub_100096AB0(v3, (uint64_t)&off_1000CE398, 72LL);
  }
  return 0LL;
}

const char *sub_100096C74()
{
  return sub_100096CC8("<user>", (uint64_t)&off_1000CE398, 72LL);
}

const char *sub_100096CC8(const char *result, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v3 = a3;
    unsigned int v4 = result;
    int v5 = (const char **)(a2 + 16);
    uint64_t v6 = (const char **)(a2 + 16);
    do
    {
      char v7 = *(_BYTE *)v6;
      v6 += 6;
      if ((v7 & 1) != 0) {
        uint64_t result = (const char *)printf("%s%s\n", v4, *(v5 - 2));
      }
      int v5 = v6;
      --v3;
    }

    while (v3);
  }

  return result;
}

uint64_t sub_100096D30(uint64_t a1, unsigned int a2, void *a3, uint64_t a4, uint64_t a5)
{
  *(void *)&__int128 v16 = __s;
  *((void *)&v16 + 1) = &v20;
  size_t v17 = 4096LL;
  uint64_t v10 = 3758097090LL;
  if (a4 && a5)
  {
    mach_port_t v11 = sub_100096240();
    if (v11)
    {
      mach_port_t v12 = v11;
      if (!ccder_blob_encode_body_tl(&v16, 4LL, 16LL, a4)
        || !sub_1000A7840(&v16, a3)
        || !sub_1000A7958(&v16, a1)
        || !ccder_blob_encode_tl(&v16, 0x2000000000000010LL, (char *)&v20 - *((void *)&v16 + 1)))
      {
        goto LABEL_10;
      }

      input[0] = a2;
      input[1] = *((void *)&v16 + 1);
      uint64_t input[2] = (uint64_t)&v20 - *((void *)&v16 + 1);
      uint64_t v13 = IOConnectCallMethod(v12, 0x4Cu, input, 3u, 0LL, 0LL, 0LL, 0LL, __s, &v17);
      if ((_DWORD)v13)
      {
        uint64_t v10 = v13;
        goto LABEL_12;
      }

      *(void *)&__int128 v15 = __s;
      *((void *)&v15 + 1) = &__s[v17];
      if (!ccder_blob_decode_range(&v15, 0x2000000000000010LL, &v15)
        || (uint64_t v10 = 0LL, (sub_1000A78AC(&v15, 0, a5) & 1) == 0))
      {
LABEL_10:
        uint64_t v10 = 3758097098LL;
      }
    }

    else
    {
      fprintf( __stdoutp,  "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n",  "aks",  "",  "",  "",  "aks_fv_new_kek",  ":",  508,  "",  0,  "",  "");
      uint64_t v10 = 3758097084LL;
    }
  }

uint64_t sub_100096F68(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)&__int128 v16 = __s;
  *((void *)&v16 + 1) = &v20;
  size_t v17 = 4096LL;
  uint64_t v10 = 3758097090LL;
  if (a3 && a4)
  {
    mach_port_t v11 = sub_100096240();
    if (!v11)
    {
      fprintf( __stdoutp,  "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n",  "aks",  "",  "",  "",  "aks_fv_new_sibling_vek",  ":",  543,  "",  0,  "",  "");
      uint64_t v10 = 3758097084LL;
      goto LABEL_15;
    }

    mach_port_t v12 = v11;
    if (!ccder_blob_encode_body_tl(&v16, 4LL, 16LL, a3)
      || !sub_1000A7840(&v16, a2)
      || !sub_1000A7958(&v16, a1)
      || !ccder_blob_encode_tl(&v16, 0x2000000000000010LL, (char *)&v20 - *((void *)&v16 + 1)))
    {
      goto LABEL_13;
    }

    input[0] = *((void *)&v16 + 1);
    input[1] = (uint64_t)&v20 - *((void *)&v16 + 1);
    uint64_t v13 = IOConnectCallMethod(v12, 0x63u, input, 2u, 0LL, 0LL, 0LL, 0LL, __s, &v17);
    if ((_DWORD)v13)
    {
      uint64_t v10 = v13;
      goto LABEL_15;
    }

    *(void *)&__int128 v15 = __s;
    *((void *)&v15 + 1) = &__s[v17];
    if (!ccder_blob_decode_range(&v15, 0x2000000000000010LL, &v15)
      || !sub_1000A78AC(&v15, 0, a4))
    {
      goto LABEL_13;
    }

    if (!a5)
    {
      uint64_t v10 = 0LL;
      goto LABEL_15;
    }

    uint64_t v10 = 0LL;
    if ((sub_1000A76A4(&v15, 0, a5) & 1) == 0) {
LABEL_13:
    }
      uint64_t v10 = 3758097098LL;
  }

uint64_t sub_1000971B4(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5, uint64_t a6)
{
  *(void *)&__int128 v18 = __s;
  *((void *)&v18 + 1) = v22;
  size_t v19 = 4096LL;
  uint64_t v12 = 3758097090LL;
  if (a3 && a4 && a5 && a6)
  {
    mach_port_t v13 = sub_100096240();
    if (v13)
    {
      mach_port_t v14 = v13;
      if (!sub_1000A7840(&v18, a5)
        || !ccder_blob_encode_body_tl(&v18, 4LL, 16LL, a4)
        || !sub_1000A7840(&v18, a3)
        || !sub_1000A7840(&v18, a2)
        || !sub_1000A7958(&v18, a1)
        || !ccder_blob_encode_tl(&v18, 0x2000000000000010LL, (char *)v22 - *((void *)&v18 + 1)))
      {
        goto LABEL_14;
      }

      input[0] = *((void *)&v18 + 1);
      input[1] = (uint64_t)v22 - *((void *)&v18 + 1);
      uint64_t v15 = IOConnectCallMethod(v14, 0x4Du, input, 2u, 0LL, 0LL, 0LL, 0LL, __s, &v19);
      if ((_DWORD)v15)
      {
        uint64_t v12 = v15;
        goto LABEL_16;
      }

      *(void *)&__int128 v17 = __s;
      *((void *)&v17 + 1) = &__s[v19];
      if (!ccder_blob_decode_range(&v17, 0x2000000000000010LL, &v17)
        || (uint64_t v12 = 0LL, (sub_1000A78AC(&v17, 0, a6) & 1) == 0))
      {
LABEL_14:
        uint64_t v12 = 3758097098LL;
      }
    }

    else
    {
      fprintf( __stdoutp,  "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n",  "aks",  "",  "",  "",  "aks_fv_rewrap_kek",  ":",  582,  "",  0,  "",  "");
      uint64_t v12 = 3758097084LL;
    }
  }

uint64_t sub_100097410( uint64_t a1, unsigned int a2, uint64_t a3, void *a4, void *a5, void *a6, uint64_t a7)
{
  uint64_t v13 = 3758097098LL;
  bzero(__s, 0x1000uLL);
  *(void *)&__int128 v20 = __s;
  *((void *)&v20 + 1) = v24;
  size_t v21 = 4096LL;
  mach_port_t v14 = sub_100096240();
  if (!v14)
  {
    fprintf( __stdoutp,  "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n",  "aks",  "",  "",  "",  "aks_fv_set_protection",  ":",  616,  "",  0,  "",  "");
    uint64_t v13 = 3758097084LL;
    goto LABEL_14;
  }

  mach_port_t v15 = v14;
  if (sub_1000A7840(&v20, a6)
    && sub_1000A7840(&v20, a5)
    && sub_1000A7840(&v20, a4)
    && sub_1000A7958(&v20, a1)
    && ccder_blob_encode_tl(&v20, 0x2000000000000010LL, (char *)v24 - *((void *)&v20 + 1)))
  {
    input[0] = a2;
    input[1] = a3;
    uint64_t input[2] = *((void *)&v20 + 1);
    uint64_t input[3] = (uint64_t)v24 - *((void *)&v20 + 1);
    uint64_t v16 = IOConnectCallMethod(v15, 0x54u, input, 4u, 0LL, 0LL, 0LL, 0LL, __s, &v21);
    if ((_DWORD)v16)
    {
      uint64_t v13 = v16;
      goto LABEL_14;
    }

    *(void *)&__int128 v19 = __s;
    *((void *)&v19 + 1) = &__s[v21];
    if (!v21) {
      goto LABEL_13;
    }
    if (!a7)
    {
LABEL_13:
      uint64_t v13 = 0LL;
      goto LABEL_14;
    }

    uint64_t v13 = 0LL;
    if ((sub_1000A78AC(&v19, 0, a7) & 1) == 0) {
      uint64_t v13 = 3758097098LL;
    }
  }

uint64_t sub_100097658( uint64_t a1, unsigned int a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7)
{
  *(void *)&__int128 v20 = __s;
  *((void *)&v20 + 1) = v24;
  size_t v21 = 4096LL;
  if (!a5)
  {
    uint64_t v17 = 3758097090LL;
    goto LABEL_15;
  }

  mach_port_t v14 = sub_100096240();
  if (!v14)
  {
    fprintf( __stdoutp,  "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n",  "aks",  "",  "",  "",  "aks_fv_unwrap_vek_with_acm",  ":",  653,  "",  0,  "",  "");
    uint64_t v17 = 3758097084LL;
    goto LABEL_15;
  }

  mach_port_t v15 = v14;
  if (!sub_1000A7840(&v20, a6)
    || !sub_1000A7840(&v20, a5)
    || !sub_1000A7840(&v20, a4)
    || !sub_1000A7840(&v20, a3)
    || !sub_1000A7958(&v20, a1)
    || !ccder_blob_encode_tl(&v20, 0x2000000000000010LL, (char *)v24 - *((void *)&v20 + 1)))
  {
    goto LABEL_13;
  }

  input[0] = *((void *)&v20 + 1);
  input[1] = (uint64_t)v24 - *((void *)&v20 + 1);
  uint64_t input[2] = a2;
  uint64_t v16 = IOConnectCallMethod(v15, 0x4Bu, input, 3u, 0LL, 0LL, 0LL, 0LL, __s, &v21);
  if ((_DWORD)v16)
  {
    uint64_t v17 = v16;
    goto LABEL_15;
  }

  *(void *)&__int128 v19 = __s;
  *((void *)&v19 + 1) = &__s[v21];
  if (!a7)
  {
    uint64_t v17 = 0LL;
    goto LABEL_15;
  }

  uint64_t v17 = 0LL;
  if ((sub_1000A76A4(&v19, 0, a7) & 1) == 0) {
LABEL_13:
  }
    uint64_t v17 = 3758097098LL;
LABEL_15:
  memset_s(__s, 0x1000uLL, 0, 0x1000uLL);
  return v17;
}

uint64_t sub_1000978C0(uint64_t a1, unsigned int a2, void *a3, void *a4, void *a5, uint64_t a6)
{
  return sub_100097658(a1, a2, a3, a4, a5, 0LL, a6);
}

void sub_1000978CC(const char *a1, char a2)
{
  if (a1)
  {
    bzero(&v13, 0x878uLL);
    bzero(v12, 0x400uLL);
    if (realpath_DARWIN_EXTSN(a1, v12))
    {
      unsigned int v4 = (char *)malloc(0x818uLL);
      memset_s(v4, 0x818uLL, 0, 0x818uLL);
      v11[0] = _NSConcreteStackBlock;
      v11[1] = 0x40000000LL;
      int v11[2] = sub_100097B38;
      unint64_t v11[3] = &unk_1000CF1A8;
      uint8_t v11[4] = v4;
      sub_100096584(v12, (uint64_t)&stru_1000CF188, (uint64_t)v11);
      if (!statfs(v12, &v13))
      {
        if ((a2 & 1) != 0) {
          printf("Free Blocks:%lld blocks of size:%d\n");
        }
        else {
          printf("%lld,%d\n");
        }
      }

      int v5 = v4 + 340;
      for (uint64_t i = 1LL; i != 5; ++i)
      {
        if ((a2 & 1) != 0)
        {
          uint64_t v9 = &v4[296 * i];
          printf( "%s:\n \tNum files:\t%u,\n \tNum hardlinks:\t%u,\n \tNum compressed:\t%u,\n \tTotal Size:\t%lld,\n \tMin File Size:\t%lld,\n \tMax File Size:\t%lld,\n",  off_1000DB180[i],  *(_DWORD *)v9,  *((_DWORD *)v9 + 2),  *((_DWORD *)v9 + 1),  *((void *)v9 + 2),  *((void *)v9 + 3),  *((void *)v9 + 4));
          printf("\tSize Distribution:");
          printf("%i", *((_DWORD *)v9 + 10));
          for (uint64_t j = 0LL; j != 252; j += 4LL)
          {
            putchar(44);
            printf("%i", *(_DWORD *)&v5[j]);
          }
        }

        else
        {
          char v7 = &v4[296 * i];
          printf( "%i,%u,%u,%u,%lld,%lld,%lld,",  i,  *(_DWORD *)v7,  *((_DWORD *)v7 + 2),  *((_DWORD *)v7 + 1),  *((void *)v7 + 2),  *((void *)v7 + 3),  *((void *)v7 + 4));
          printf("%i", *((_DWORD *)v7 + 10));
          for (uint64_t k = 0LL; k != 252; k += 4LL)
          {
            putchar(44);
            printf("%i", *(_DWORD *)&v5[k]);
          }
        }

        putchar(10);
        v5 += 296;
      }

      free(v4);
    }
  }

BOOL sub_100097B30(id a1, _ftsent *a2)
{
  return 1;
}

uint64_t sub_100097B38(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_1000967B4(*(const char **)(a2 + 48));
  if ((result - 7) >= 0xFFFFFFFA)
  {
    uint64_t v5 = *(void *)(a2 + 96);
    int64_t v6 = *(void *)(v5 + 96);
    uint64_t v7 = *(void *)(a1 + 32);
    ++*(_DWORD *)(v7 + 296LL * result);
    if ((*(_BYTE *)(v5 + 116) & 0x20) != 0) {
      ++*(_DWORD *)(v7 + 296LL * result + 4);
    }
    uint64_t v8 = v7 + 296LL * result;
    int64_t v10 = *(void *)(v8 + 32);
    uint64_t v9 = (int64_t *)(v8 + 32);
    *(v9 - 2) += v6;
    if (v6 > v10) {
      int64_t *v9 = v6;
    }
    uint64_t v11 = v7 + 296LL * result;
    int64_t v14 = *(void *)(v11 + 24);
    uint64_t v12 = (int64_t *)(v11 + 24);
    int64_t v13 = v14;
    if (v14) {
      BOOL v15 = v6 < v13;
    }
    else {
      BOOL v15 = 1;
    }
    if (v15) {
      *uint64_t v12 = v6;
    }
    if (v6) {
      unint64_t v16 = v7 + 296LL * result + 4 * (63 - __clz(v6));
    }
    else {
      unint64_t v16 = v7 + 296LL * result;
    }
    ++*(_DWORD *)(v16 + 40);
  }

  return result;
}

uint64_t sub_100097C40(unsigned int a1, uint64_t a2)
{
  input[0] = 1LL;
  input[1] = a1;
  uint64_t input[2] = a2;
  uint64_t output = 0LL;
  uint32_t outputCnt = 1;
  mach_port_t v2 = sub_100096240();
  if (v2) {
    return IOConnectCallMethod(v2, 0x56u, input, 3u, 0LL, 0LL, &output, &outputCnt, 0LL, 0LL);
  }
  fprintf( __stdoutp,  "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n",  "aks",  "",  "",  "",  "aks_kext_set_options",  ":",  820,  "",  0,  "",  "");
  return 3758097084LL;
}

uint64_t sub_100097D28(unsigned int a1, uint64_t *a2)
{
  uint64_t v2 = 3758097084LL;
  if (!a2) {
    return 3758097090LL;
  }
  input[0] = 0LL;
  input[1] = a1;
  uint64_t input[2] = 0LL;
  uint64_t output = 0LL;
  uint32_t outputCnt = 1;
  mach_port_t v4 = sub_100096240();
  if (v4)
  {
    uint64_t v2 = IOConnectCallMethod(v4, 0x56u, input, 3u, 0LL, 0LL, &output, &outputCnt, 0LL, 0LL);
    if (!(_DWORD)v2) {
      *a2 = output;
    }
  }

  else
  {
    fprintf( __stdoutp,  "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n",  "aks",  "",  "",  "",  "aks_kext_get_options",  ":",  841,  "",  0,  "",  "");
  }

  return v2;
}

uint64_t sub_100097E3C()
{
  mach_port_t v0 = sub_100096240();
  if (v0) {
    return IOConnectCallMethod(v0, 0x10u, 0LL, 0, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL);
  }
  fprintf( __stdoutp,  "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n",  "aks",  "",  "",  "",  "aks_internal_state",  ":",  857,  "",  0,  "",  "");
  return 3758097084LL;
}

uint64_t sub_100097EE0(unsigned int a1)
{
  mach_port_t v2 = sub_100096240();
  if (v2)
  {
    uint64_t input = a1;
    return IOConnectCallMethod(v2, 0x86u, &input, 1u, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL);
  }

  else
  {
    fprintf( __stdoutp,  "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n",  "aks",  "",  "",  "",  "aks_run_internal_test",  ":",  871,  "",  0,  "",  "");
    return 3758097084LL;
  }

uint64_t sub_100097FC4( int a1, unsigned int a2, uint64_t a3, int a4, const void *a5, int a6, void *a7, _DWORD *a8)
{
  size_t __count = 0x8000LL;
  mach_port_t v16 = sub_100096240();
  if (v16)
  {
    input[0] = a1;
    input[1] = a2;
    uint64_t input[2] = a3;
    uint64_t input[3] = a4;
    if (!a2 || (uint64_t v17 = 3758097090LL, a7) && a8)
    {
      uint64_t v17 = IOConnectCallMethod(v16, 0x36u, input, 4u, a5, a6, 0LL, 0LL, __src, &__count);
      if (!(_DWORD)v17 && a2)
      {
        __int128 v18 = calloc(__count, 1uLL);
        *a7 = v18;
        if (v18)
        {
          memcpy(v18, __src, __count);
          uint64_t v17 = 0LL;
          *a8 = __count;
        }

        else
        {
          uint64_t v17 = 3758097085LL;
        }
      }
    }
  }

  else
  {
    uint64_t v17 = 3758097084LL;
    fprintf( __stdoutp,  "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n",  "aks",  "",  "",  "",  "aks_stash_escrow",  ":",  890,  "",  0,  "",  "");
  }

  memset_s(__src, 0x8000uLL, 0, 0x8000uLL);
  return v17;
}

void sub_10009819C(id a1)
{
  if (!dword_1000DBC90) {
    dword_1000DBC90 = sub_100098C74("IOService:/IOResources/AppleKeyStore", "AppleKeyStore");
  }
}

uint64_t sub_1000981D8()
{
  if (qword_1000DBCA0 != -1) {
    dispatch_once(&qword_1000DBCA0, &stru_1000CF268);
  }
  dispatch_sync((dispatch_queue_t)qword_1000DBCA8, &stru_1000CF228);
  uint64_t result = dword_1000DBC94;
  if (!dword_1000DBC94)
  {
    syslog(3, "failed to open connection to %s\n", "AppleKeyStoreTest");
    return dword_1000DBC94;
  }

  return result;
}

void sub_100098260(id a1)
{
  if (!dword_1000DBC94) {
    dword_1000DBC94 = sub_100098C74("IOService:/IOResources/AppleKeyStoreTest", "AppleKeyStoreTest");
  }
}

uint64_t sub_10009829C( mach_port_t a1, const void *a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6, _DWORD *a7)
{
  input[0] = a4;
  input[1] = a3;
  uint64_t output = 0LL;
  uint32_t outputCnt = 1;
  bzero(outputStruct, 0x400uLL);
  size_t v19 = 1024LL;
  uint64_t v11 = IOConnectCallMethod(a1, 0xFu, input, 2u, a2, 0x10uLL, &output, &outputCnt, outputStruct, &v19);
  if ((_DWORD)v11) {
    return v11;
  }
  uint64_t v17 = 3758097084LL;
  if (outputCnt == 1)
  {
    *a7 = output;
    else {
      return 0LL;
    }
  }

  return v17;
}

uint64_t sub_1000983D0( mach_port_t a1, const void *a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6, _DWORD *a7, uint64_t a8, uint64_t a9, _DWORD *a10, uint64_t a11, uint64_t a12, _DWORD *a13)
{
  input[0] = a4;
  input[1] = a3;
  uint64_t output = 0LL;
  uint64_t v30 = 0LL;
  uint64_t v31 = 0LL;
  uint32_t outputCnt = 3;
  bzero(outputStruct, 0x400uLL);
  size_t v26 = 1024LL;
  uint64_t v17 = IOConnectCallMethod(a1, 0x13u, input, 2u, a2, 0x10uLL, &output, &outputCnt, outputStruct, &v26);
  if ((_DWORD)v17) {
    return v17;
  }
  uint64_t v23 = 3758097084LL;
  if (outputCnt == 3)
  {
    int v24 = v30;
    *a7 = output;
    *a10 = v24;
    *a13 = v31;
    else {
      return 0LL;
    }
  }

  return v23;
}

uint64_t sub_100098528( mach_port_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, size_t *a8)
{
  uint64_t input = a3;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  sub_1000A9930((char **)&inputStructCnt[1], inputStructCnt, 2, a4, a5, a6, (uint64_t)a7, (uint64_t)a8, a2);
  uint64_t v11 = IOConnectCallMethod( a1,  0x14u,  &input,  1u,  *(const void **)&inputStructCnt[1],  (int)inputStructCnt[0],  0LL,  0LL,  a7,  a8);
  free(*(void **)&inputStructCnt[1]);
  return v11;
}

uint64_t sub_1000985E4( mach_port_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9, uint64_t a10, uint64_t a11, unsigned int a12, void *outputStruct, size_t *a14, _DWORD *a15)
{
  input[0] = a3;
  input[1] = a6;
  uint64_t input[2] = a9;
  uint64_t input[3] = a12;
  uint64_t output = 0LL;
  uint32_t outputCnt = 1;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  sub_1000A9930((char **)&inputStructCnt[1], inputStructCnt, 4, a4, a5, a6, a7, a8, a2);
  uint64_t v16 = IOConnectCallMethod( a1,  0x15u,  input,  4u,  *(const void **)&inputStructCnt[1],  (int)inputStructCnt[0],  &output,  &outputCnt,  outputStruct,  a14);
  if ((_DWORD)v16)
  {
    uint64_t v17 = v16;
  }

  else if (outputCnt == 1)
  {
    uint64_t v17 = 0LL;
    *a15 = output;
  }

  else
  {
    uint64_t v17 = 3758097084LL;
  }

  free(*(void **)&inputStructCnt[1]);
  return v17;
}

uint64_t sub_1000986F4( mach_port_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, uint64_t a7)
{
  input[0] = a3;
  input[1] = a6;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  bzero(outputStruct, 0x400uLL);
  size_t outputStructCnt = 1024LL;
  sub_1000A9930((char **)&inputStructCnt[1], inputStructCnt, 2, v10, v11, v12, v13, v14, a2);
  uint64_t v15 = IOConnectCallMethod( a1,  0x10u,  input,  2u,  *(const void **)&inputStructCnt[1],  (int)inputStructCnt[0],  0LL,  0LL,  outputStruct,  &outputStructCnt);
  if ((_DWORD)v15)
  {
    uint64_t v21 = v15;
  }

  else if (sub_1000A9A0C(outputStruct, outputStructCnt, 2u, v16, v17, v18, v19, v20, a7))
  {
    uint64_t v21 = 3758097084LL;
  }

  else
  {
    uint64_t v21 = 0LL;
  }

  free(*(void **)&inputStructCnt[1]);
  return v21;
}

uint64_t sub_10009882C( mach_port_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, uint64_t a7, uint64_t a8, unsigned int a9, uint64_t a10)
{
  input[0] = a3;
  input[1] = a6;
  uint64_t input[2] = a9;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  bzero(outputStruct, 0x400uLL);
  size_t v25 = 1024LL;
  sub_1000A9930((char **)&inputStructCnt[1], inputStructCnt, 3, v12, v13, v14, v15, v16, a2);
  uint64_t v17 = IOConnectCallMethod( a1,  0x17u,  input,  3u,  *(const void **)&inputStructCnt[1],  (int)inputStructCnt[0],  0LL,  0LL,  outputStruct,  &v25);
  if ((_DWORD)v17)
  {
    uint64_t v23 = v17;
  }

  else if (sub_1000A9A0C(outputStruct, v25, 2u, v18, v19, v20, v21, v22, a10))
  {
    uint64_t v23 = 3758097084LL;
  }

  else
  {
    uint64_t v23 = 0LL;
  }

  free(*(void **)&inputStructCnt[1]);
  return v23;
}

uint64_t sub_100098974(mach_port_t a1, void *inputStruct, unsigned int a3)
{
  uint64_t input = a3;
  return IOConnectCallMethod(a1, 0x11u, &input, 1u, inputStruct, 0x10uLL, 0LL, 0LL, 0LL, 0LL);
}

uint64_t sub_1000989E4( mach_port_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t input = a2;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  sub_1000A9930((char **)&inputStructCnt[1], inputStructCnt, 1, a4, a5, a6, a7, a8, a3);
  uint64_t v9 = IOConnectCallMethod( a1,  0x12u,  &input,  1u,  *(const void **)&inputStructCnt[1],  (int)inputStructCnt[0],  0LL,  0LL,  0LL,  0LL);
  free(*(void **)&inputStructCnt[1]);
  return v9;
}

uint64_t sub_100098A90(int a1, const void *a2, void *a3, size_t *a4)
{
  uint64_t input = a1;
  bzero(__src, 0x8000uLL);
  size_t __count = 0x8000LL;
  mach_port_t v7 = sub_100096240();
  if (v7)
  {
    if (a2) {
      size_t v8 = 18LL;
    }
    else {
      size_t v8 = 0LL;
    }
    uint64_t v9 = IOConnectCallMethod(v7, 0x5Du, &input, 1u, a2, v8, 0LL, 0LL, __src, &__count);
    size_t v10 = __count;
    if ((_DWORD)v9)
    {
      uint64_t v12 = v9;
    }

    else if (__count - 32769 < 0xFFFFFFFFFFFF8000LL)
    {
      uint64_t v12 = 3758097090LL;
    }

    else
    {
      uint64_t v11 = calloc(__count, 1uLL);
      *a3 = v11;
      size_t v10 = __count;
      if (v11)
      {
        *a4 = __count;
        memcpy(v11, __src, v10);
        uint64_t v12 = 0LL;
        size_t v10 = __count;
      }

      else
      {
        uint64_t v12 = 3758097085LL;
      }
    }
  }

  else
  {
    uint64_t v12 = 3758097084LL;
    fprintf( __stdoutp,  "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n",  "aks",  "",  "",  "",  "aks_get_internal_info_for_key",  ":",  1246,  "",  0,  "",  "");
    size_t v10 = 0x8000LL;
  }

  memset_s(__src, v10, 0, v10);
  return v12;
}

void sub_100098C4C(id a1)
{
  qword_1000DBCA8 = (uint64_t)dispatch_queue_create("aks-client-queue", 0LL);
}

uint64_t sub_100098C74(char *path, const char *a2)
{
  kern_return_t v5;
  CFDictionaryRef v6;
  io_service_t MatchingService;
  io_object_t v8;
  uint64_t result;
  kern_return_t v10;
  io_connect_t connect;
  connect = 0;
  io_service_t v3 = IORegistryEntryFromPath(kIOMasterPortDefault, path);
  if (!v3 || (v4 = v3, uint64_t v5 = IOServiceOpen(v3, mach_task_self_, 0, &connect), IOObjectRelease(v4), v5))
  {
    int64_t v6 = IOServiceMatching(a2);
    io_service_t MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v6);
    if (MatchingService)
    {
      size_t v8 = MatchingService;
      IOServiceOpen(MatchingService, mach_task_self_, 0, &connect);
      IOObjectRelease(v8);
    }
  }

  uint64_t result = connect;
  if (connect)
  {
    size_t v10 = IOConnectCallMethod(connect, 0, 0LL, 0, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL);
    uint64_t result = connect;
    if (v10)
    {
      IOServiceClose(connect);
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_100098D68(void *a1)
{
  uint64_t v2 = ccder_sizeof_implicit_uint64(0x8000000000000004LL, a1[10]);
  uint64_t v3 = ccder_sizeof_raw_octet_string(16LL);
  uint64_t v4 = ccder_sizeof_raw_octet_string(40LL);
  uint64_t v5 = v4 + v2 + 2 * v3 + ccder_sizeof_implicit_uint64(0x8000000000000000LL, *a1);
  return ccder_sizeof(0x2000000000000010LL, v5);
}

uint64_t sub_100098DD8(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2 + a3;
  uint64_t v7 = a2;
  uint64_t v8 = a2 + a3;
  if (!ccder_blob_encode_implicit_uint64(&v7, 0x8000000000000004LL, a1[10])
    || !ccder_blob_encode_implicit_raw_octet_string(&v7, 0x8000000000000003LL, 16LL, a1 + 8)
    || !ccder_blob_encode_implicit_raw_octet_string(&v7, 0x8000000000000002LL, 40LL, a1 + 3)
    || !ccder_blob_encode_implicit_raw_octet_string(&v7, 0x8000000000000001LL, 16LL, a1 + 1)
    || !ccder_blob_encode_implicit_uint64(&v7, 0x8000000000000000LL, *a1))
  {
    return 4294967273LL;
  }

  int v5 = ccder_blob_encode_tl(&v7, 0x2000000000000010LL, v4 - v8);
  uint64_t result = 4294967273LL;
  if (v5)
  {
    if (v7 == v8) {
      return 0LL;
    }
    else {
      return 4294967273LL;
    }
  }

  return result;
}

uint64_t sub_100098EB8(uint64_t a1, uint64_t a2, void *a3)
{
  *(void *)&__int128 v6 = a1;
  *((void *)&v6 + 1) = a1 + a2;
  if (!ccder_blob_decode_range(&v6, 0x2000000000000010LL, &v6)
    || !sub_1000A8CD8(&v6, 0x8000000000000000LL, a3)
    || !sub_1000A6508(&v6, 0x8000000000000001LL, a3 + 1, 16)
    || !sub_1000A6508(&v6, 0x8000000000000002LL, a3 + 3, 40)
    || !sub_1000A6508(&v6, 0x8000000000000003LL, a3 + 8, 16))
  {
    return 4294967277LL;
  }

  int v4 = sub_1000A8CD8(&v6, 0x8000000000000004LL, a3 + 10);
  uint64_t result = 4294967277LL;
  if (v4)
  {
    if ((void)v6 == *((void *)&v6 + 1)) {
      return 0LL;
    }
    else {
      return 4294967277LL;
    }
  }

  return result;
}

uint64_t sub_100098F94(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v13 = 40;
  *(void *)a4 = 0LL;
  uuid_copy((unsigned __int8 *)(a4 + 8), (const unsigned __int8 *)(a1 + 32));
  *(void *)(a4 + 80) = 1LL;
  uint64_t v8 = sub_1000A8FF0(a4 + 64, 0x10u);
  uint64_t v9 = ccsha256_di(v8);
  if (j__ccpbkdf2_hmac(v9, a3, a2, 16LL, a4 + 64, *(void *)(a4 + 80), 32LL, __s))
  {
    uint64_t v11 = 4294967286LL;
  }

  else
  {
    uint64_t v10 = sub_100095B30((uint64_t)__s, 0x20u, 0xA6A6A6A6A6A6A6A6LL, 0LL, (uint64_t *)a1, 0x20u, (void *)(a4 + 24), &v13);
    if ((_DWORD)v10)
    {
      uint64_t v11 = v10;
    }

    else if (v13 == 40)
    {
      uint64_t v11 = 0LL;
    }

    else
    {
      uint64_t v11 = 4294967286LL;
    }
  }

  memset_s(__s, 0x20uLL, 0, 0x20uLL);
  return v11;
}