uint64_t std::shared_ptr<RNBRemote>::~shared_ptr[abi:nn180100](uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }

  return a1;
}

uint64_t RNBRunLoopGetStartModeFromRemote(RNBRemote *a1)
{
  if (!a1) {
    return 6LL;
  }
  v2 = (pthread_mutex_t *)((char *)a1 + 120);
  while (1)
  {
    if (DNBLogEnabledForAny(0x40000)) {
      _DNBLogThreaded("%s ctx.Events().WaitForSetEvents( 0x%08x) ...", "RNBRunLoopGetStartModeFromRemote", 160);
    }
    int v3 = PThreadEvent::WaitForSetEvents(v2, 0xA0u, 0LL);
    if (DNBLogEnabledForAny(0x40000)) {
      _DNBLogThreaded( "%s ctx.Events().WaitForSetEvents( 0x%08x) => 0x%08x",  "RNBRunLoopGetStartModeFromRemote",  160,  v3);
    }
    if ((v3 & 0x80) != 0)
    {
      if (g_isatty)
      {
        v15 = __stderrp;
        v16 = "error: packet read thread exited.\n";
        size_t v17 = 34LL;
        goto LABEL_28;
      }

      v18 = "error: packet read thread exited.\n";
      goto LABEL_36;
    }

    if ((v3 & 0x20) == 0)
    {
      if (DNBLogEnabledForAny(0x10000)) {
        _DNBLogThreaded("%s Connection closed before getting A packet.", "RNBRunLoopGetStartModeFromRemote");
      }
      return 6LL;
    }

    int v20 = 0;
    int v10 = RNBRemote::HandleReceivedPacket((uint64_t)a1, &v20);
    if (v10)
    {
      if (v10 == 2)
      {
        if (!g_isatty)
        {
          v18 = "error: connection lost.\n";
          goto LABEL_36;
        }

        v15 = __stderrp;
        v16 = "error: connection lost.\n";
        size_t v17 = 24LL;
LABEL_28:
        fwrite(v16, v17, 1uLL, v15);
        return 6LL;
      }

      BOOL v11 = DNBLogEnabledForAny(0x10000);
      v12 = "%s Error getting packet.";
      if (v11) {
LABEL_3:
      }
        _DNBLogThreaded(v12, "RNBRunLoopGetStartModeFromRemote");
    }

    else
    {
      if (v20 == 6) {
        return 3LL;
      }
      BOOL v13 = DNBLogEnabledForAny(0x10000);
      v12 = "#### %s";
      if (v13) {
        goto LABEL_3;
      }
    }
  }

  if (v10)
  {
    if (g_isatty)
    {
      v15 = __stderrp;
      v16 = "error: attach failed.\n";
      size_t v17 = 22LL;
      goto LABEL_28;
    }

    v18 = "error: attach failed.\n";
LABEL_36:
    _DNBLog(0LL, (uint64_t)v18, v4, v5, v6, v7, v8, v9, v19);
    return 6LL;
  }

  if (g_isatty) {
    fwrite("Attach succeeded, ready to debug.\n", 0x22uLL, 1uLL, __stdoutp);
  }
  else {
    _DNBLog(0LL, (uint64_t)"Attach succeeded, ready to debug.\n", v4, v5, v6, v7, v8, v9, v19);
  }
  return 4LL;
}

uint64_t RNBRunLoopLaunchInferior(RNBRemote *a1, char *a2, char *a3, char *a4, char a5)
{
  if (DNBLogEnabledForAny(0x10000))
  {
    int v10 = RNBContext::ArgumentAtIndex(a1, 0LL);
    _DNBLogThreaded("%s Launching '%s'...", "RNBRunLoopLaunchInferior", v10);
  }

  uint64_t v12 = *((void *)a1 + 43);
  uint64_t v11 = *((void *)a1 + 44);
  unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((v11 - v12) >> 3);
  unint64_t v14 = v13 + 1;
  if (v13 == -1LL)
  {
    v15 = 0LL;
    if (v11 == v12) {
      goto LABEL_11;
    }
  }

  else
  {
    if (v14 >> 61) {
      goto LABEL_91;
    }
    v15 = (const char **)operator new(8 * v14);
    bzero(v15, 0x5555555555555558LL * ((v11 - v12) >> 3) + 8);
    if (v11 == v12) {
      goto LABEL_11;
    }
  }

  unint64_t v16 = 0LL;
  if (v13 <= 1) {
    unint64_t v13 = 1LL;
  }
  do
  {
    v15[v16] = RNBContext::ArgumentAtIndex(a1, v16);
    ++v16;
  }

  while (v13 != v16);
LABEL_11:
  uint64_t v18 = *((void *)a1 + 46);
  uint64_t v17 = *((void *)a1 + 47);
  unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * ((v17 - v18) >> 3);
  unint64_t v20 = v19 + 1;
  if (v19 == -1LL)
  {
    v21 = 0LL;
    if (v17 == v18) {
      goto LABEL_19;
    }
    goto LABEL_16;
  }

  if (v20 >> 61) {
LABEL_91:
  }
    abort();
  v21 = operator new(8 * v20);
  bzero(v21, 0x5555555555555558LL * ((v17 - v18) >> 3) + 8);
  if (v17 == v18) {
    goto LABEL_19;
  }
LABEL_16:
  unint64_t v22 = 0LL;
  if (v19 <= 1) {
    unint64_t v19 = 1LL;
  }
  do
  {
    *((void *)v21 + v22) = RNBContext::EnvironmentAtIndex(a1, v22);
    ++v22;
  }

  while (v19 != v22);
LABEL_19:
  int v23 = g_launch_flavor;
  v24 = *v15;
  if (!g_launch_flavor)
  {
    size_t v25 = strlen(v24);
    if (v25 >= 4 && v24[v25 - 4] == 46 && v24[v25 - 3] == 97 && v24[v25 - 2] == 112 && v24[v25 - 1] == 112) {
      int v23 = 5;
    }
    else {
      int v23 = 1;
    }
  }

  *((_DWORD *)a1 + 76) = v23;
  if (!DNBResolveExecutablePath(v24, __dst, 0x400uLL)) {
    strlcpy(__dst, *v15, 0x400uLL);
  }
  v38[0] = 0;
  v26 = (const char **)((char *)a1 + 88);
  if ((*((char *)a1 + 111) & 0x80000000) == 0)
  {
    if (*((_BYTE *)a1 + 111)) {
      goto LABEL_41;
    }
    goto LABEL_34;
  }

  if (!*((void *)a1 + 12) || (v26 = (const char **)*v26) == 0LL)
  {
LABEL_34:
    if (*((char *)a1 + 415) < 0)
    {
      if (*((void *)a1 + 50)) {
        v26 = (const char **)*((void *)a1 + 49);
      }
      else {
        v26 = 0LL;
      }
    }

    else if (*((_BYTE *)a1 + 415))
    {
      v26 = (const char **)((char *)a1 + 392);
    }

    else
    {
      v26 = 0LL;
    }
  }

LABEL_41:
  v27 = (char *)a1 + 416;
  unsigned int v28 = DNBProcessLaunch( a1,  __dst,  v15,  (const char **)v21,  v26,  a2,  a3,  a4,  a5,  g_disable_aslr,  v27,  v38,  0x400uLL);
  int v29 = v28;
  g_pid = v28;
  if (v28 || !v38[0])
  {
    if (!v28)
    {
      if (DNBLogEnabled()) {
        _DNBLogThreaded("%s DNBProcessLaunch() failed to launch process, unknown failure", "RNBRunLoopLaunchInferior");
      }
      *((void *)a1 + 39) = 0xFFFFFFFFLL;
      v30 = (std::string *)((char *)a1 + 320);
      if (*((char *)a1 + 343) < 0)
      {
        **((_BYTE **)a1 + 40) = 0;
        *((void *)a1 + 41) = 0LL;
      }

      else
      {
        *((_BYTE *)a1 + 320) = 0;
        *((_BYTE *)a1 + 343) = 0;
      }

      v31 = "<unknown failure>";
      goto LABEL_62;
    }

    *((void *)a1 + 39) = 0LL;
    if ((*((char *)a1 + 343) & 0x80000000) == 0)
    {
LABEL_59:
      *((_BYTE *)a1 + 320) = 0;
      *((_BYTE *)a1 + 343) = 0;
      goto LABEL_63;
    }
  }

  else
  {
    if (DNBLogEnabled()) {
      _DNBLogThreaded("%s DNBProcessLaunch() returned error: '%s'", "RNBRunLoopLaunchInferior", v38);
    }
    *((void *)a1 + 39) = 0xFFFFFFFFLL;
    if (*((char *)a1 + 343) < 0)
    {
      **((_BYTE **)a1 + 40) = 0;
      *((void *)a1 + 41) = 0LL;
      if (v38[0]) {
        goto LABEL_49;
      }
    }

    else
    {
      *((_BYTE *)a1 + 320) = 0;
      *((_BYTE *)a1 + 343) = 0;
      if (v38[0])
      {
LABEL_49:
        v30 = (std::string *)((char *)a1 + 320);
        v31 = v38;
LABEL_62:
        std::string::assign(v30, v31);
        goto LABEL_63;
      }
    }
  }

  **((_BYTE **)a1 + 40) = 0;
  *((void *)a1 + 41) = 0LL;
LABEL_63:
  if (*((_DWORD *)a1 + 118) != -1
    && (PThreadEvent::WaitForSetEvents((pthread_mutex_t *)((char *)a1 + 120), 0x20u, 0LL) & 0x20) != 0)
  {
    int v37 = 0;
    if (RNBRemote::HandleReceivedPacket((uint64_t)a1, &v37))
    {
      if (DNBLogEnabledForAny(0x10000)) {
        _DNBLogThreaded("%s Error getting packet.", "RNBRunLoopLaunchInferior");
      }
LABEL_85:
      uint64_t v35 = 6LL;
      if (v21) {
LABEL_86:
      }
        operator delete(v21);
      goto LABEL_87;
    }

    if (v37 != 54 && DNBLogEnabledForAny(0x10000)) {
      _DNBLogThreaded("%s Didn't get the expected qLaunchSuccess packet.", "RNBRunLoopLaunchInferior");
    }
  }

  if (!v29) {
    goto LABEL_85;
  }
  while (1)
  {
    if (DNBLogEnabledForAny(0x200000)) {
      _DNBLogThreaded( "%s DNBProcessWaitForEvent (%4.4x, eEventProcessRunningStateChanged | eEventProcessStoppedStateChanged, true, INFINITE)...",  "RNBRunLoopLaunchInferior",  v29);
    }
    int v32 = DNBProcessWaitForEvents(v29, 3u, 1, 0LL);
    if (DNBLogEnabledForAny(0x200000)) {
      _DNBLogThreaded( "%s DNBProcessWaitForEvent (%4.4x, eEventProcessRunningStateChanged | eEventProcessStoppedStateChanged, true, INF INITE) => 0x%8.8x",  "RNBRunLoopLaunchInferior",  v29,  v32);
    }
    if (!v32)
    {
LABEL_81:
      g_pid = 0;
      goto LABEL_85;
    }

    if ((v32 & 3) != 0)
    {
      unsigned int State = DNBProcessGetState(v29);
      if (DNBLogEnabledForAny(0x200000))
      {
        v34 = DNBStateAsString(State);
        _DNBLogThreaded( "%s process %4.4x state changed (eEventProcessStateChanged): %s",  "RNBRunLoopLaunchInferior",  v29,  v34);
      }

      if (State - 8 < 2) {
        goto LABEL_81;
      }
      if (State == 7 || State == 4) {
        break;
      }
    }

    DNBProcessResetEvents(v29, v32);
  }

  RNBContext::SetProcessID(a1, v29);
  uint64_t v35 = 4LL;
  if (v21) {
    goto LABEL_86;
  }
LABEL_87:
  operator delete(v15);
  return v35;
}

          unint64_t v22 = "OK";
          goto LABEL_44;
        }
      }

      return RNBRemote::HandlePacket_UNIMPLEMENTED(this, v9);
    }

    if ((v10 - 50) >= 3)
    {
    }

    else if (DNBWatchpointClear(v8, v11))
    {
      goto LABEL_41;
    }

    unint64_t v22 = "E08";
    goto LABEL_44;
  }

  unint64_t v13 = this;
  unint64_t v14 = 3986;
  return RNBRemote::HandlePacket_ILLFORMED( v13,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v14,  v9,  v12);
}

        std::stringbuf::str(&__p, (const std::stringbuf *)&v33[0].__r_.__value_.__r.__words[1]);
        uint64_t v7 = RNBRemote::SendPacket((uint64_t)this, &__p);
        *(std::string::size_type *)((char *)v33[0].__r_.__value_.__r.__words
        if (SBYTE7(v35) < 0) {
          operator delete(v34[0]);
        }
        std::streambuf::~streambuf(&v33[0].__r_.__value_.__r.__words[1]);
        std::ios::~ios(&v37);
        int v29 = *((void *)&v42 + 1);
        if (*((void *)&v42 + 1))
        {
          v30 = v43;
          v31 = (void *)*((void *)&v42 + 1);
          if ((void)v43 != *((void *)&v42 + 1))
          {
            do
            {
              v30 -= 24LL;
            }

            while (v30 != v29);
            v31 = (void *)*((void *)&v42 + 1);
          }

          *(void *)&v43 = v29;
          operator delete(v31);
        }

        uint64_t v8 = (void *)v41;
        if (!(void)v41) {
          return v7;
        }
        *((void *)&v41 + 1) = v41;
        goto LABEL_55;
      }

uint64_t RNBRunLoopLaunchAttaching(RNBRemote *a1, uint64_t a2, int *a3)
{
  if (DNBLogEnabledForAny(0x10000)) {
    _DNBLogThreaded("%s Attaching to pid %i...", "RNBRunLoopLaunchAttaching", a2);
  }
  int v6 = DNBProcessAttach(a2, 0LL, (int8x16_t **)a1 + 56, __s, 0x400uLL);
  *a3 = v6;
  g_pid = v6;
  if (*a3)
  {
    RNBContext::SetProcessID(a1, *a3);
    return 4LL;
  }

  *((void *)a1 + 39) = 0xFFFFFFFFLL;
  if (*((char *)a1 + 343) < 0)
  {
    **((_BYTE **)a1 + 40) = 0;
    *((void *)a1 + 41) = 0LL;
    if (!__s[0]) {
      return 6LL;
    }
    goto LABEL_7;
  }

  *((_BYTE *)a1 + 320) = 0;
  *((_BYTE *)a1 + 343) = 0;
  if (__s[0]) {
LABEL_7:
  }
    std::string::assign((std::string *)((char *)a1 + 320), __s);
  return 6LL;
}

void signal_handler(SysSignal *a1)
{
  if (DNBLogEnabledForAny(0x10000))
  {
    v2 = SysSignal::Name(a1);
    _DNBLogThreaded("%s (%s)", "signal_handler", v2);
  }

  if ((_DWORD)a1 == 13)
  {
    g_sigpipe_received = 1;
  }

  else if ((_DWORD)a1 == 2)
  {
    int v3 = g_sigint_received++;
    DNBProcessSignal(g_pid, 17);
  }
}

uint64_t HandleProcessStateChange(RNBRemote *a1, int a2)
{
  int v2 = *((_DWORD *)a1 + 3);
  if (v2)
  {
    unsigned int State = DNBProcessGetState(*((_DWORD *)a1 + 3));
    if (DNBLogEnabledForAny(0x10000))
    {
      int v6 = DNBStateAsString(State);
      _DNBLogThreaded("%s (&remote, initialize=%i)  pid_state = %s", "HandleProcessStateChange", a2, v6);
    }

    uint64_t result = 6LL;
    switch(State)
    {
      case 2u:
      case 3u:
      case 5u:
      case 6u:
        return 4LL;
      case 4u:
      case 7u:
      case 0xAu:
        g_sigint_received = 0;
        if ((a2 & 1) != 0) {
          return 4LL;
        }
        uint64_t v8 = *((void *)a1 + 14);
        uint64_t StopCount = DNBProcessGetStopCount(v2);
        if (*((void *)a1 + 14) == StopCount)
        {
          if (DNBLogEnabledForAny(0x10000))
          {
            DNBStateAsString(State);
            _DNBLogThreaded("%s (&remote, initialize=%i)  pid_state = %s pid_stop_count %llu (old %llu)) Notify??? skipping...");
            return 4LL;
          }
        }

        else
        {
          *((void *)a1 + 14) = StopCount;
          RNBRemote::FlushSTDIO((int *)a1);
          uint64_t v10 = *((void *)a1 + 14);
          BOOL v11 = DNBLogEnabledForAny(0x10000);
          if (v10 == 1)
          {
            if (v11)
            {
              DNBStateAsString(State);
              _DNBLogThreaded( "%s (&remote, initialize=%i)  pid_state = %s pid_stop_count %llu (old %llu)) Notify??? no, first stop...");
              return 4LL;
            }
          }

          else
          {
            if (v11)
            {
              uint64_t v12 = DNBStateAsString(State);
              _DNBLogThreaded( "%s (&remote, initialize=%i)  pid_state = %s pid_stop_count %llu (old %llu)) Notify??? YES!!!",  "HandleProcessStateChange",  0,  v12,  *((void *)a1 + 14),  v8);
            }

            RNBRemote::NotifyThatProcessStopped(a1);
          }
        }

        return 4LL;
      case 9u:
        RNBRemote::HandlePacket_last_signal(a1, 0LL);
        return 6LL;
      default:
        return result;
    }
  }

  if (DNBLogEnabledForAny(0x10000)) {
    _DNBLogThreaded("#### %s error: pid invalid, exiting...", "HandleProcessStateChange");
  }
  return 6LL;
}

uint64_t RNBRunLoopInferiorExecuting(RNBRemote *a1)
{
  if (DNBLogEnabledForAny(0x10000)) {
    _DNBLogThreaded("#### %s", "RNBRunLoopInferiorExecuting");
  }
  uint64_t v2 = HandleProcessStateChange(a1, 1);
  while (*((_DWORD *)a1 + 3))
  {
    memset(&__p, 0, sizeof(__p));
    if (RNBContext::ProcessStateRunning(a1)) {
      unsigned int v3 = 189;
    }
    else {
      unsigned int v3 = 165;
    }
    if (DNBLogEnabledForAny(0x200000)) {
      _DNBLogThreaded("%s ctx.Events().WaitForSetEvents(0x%08x) ...", "RNBRunLoopInferiorExecuting", v3);
    }
    int v4 = PThreadEvent::WaitForSetEvents((pthread_mutex_t *)((char *)a1 + 120), v3, 0LL);
    if (DNBLogEnabledForAny(0x200000))
    {
      uint64_t v5 = RNBContext::EventsAsString((int)a1, v4, &__p);
      _DNBLogThreaded( "%s ctx.Events().WaitForSetEvents(0x%08x) => 0x%08x (%s)",  "RNBRunLoopInferiorExecuting",  v3,  v4,  (const char *)v5);
    }

    if (!v4)
    {
      uint64_t v6 = v2;
LABEL_24:
      goto LABEL_4;
    }

    if ((v4 & 0xC) != 0) {
      RNBRemote::FlushSTDIO((int *)a1);
    }
    if ((v4 & 0x10) != 0)
    {
      RNBRemote::SendAsyncProfileData((size_t)a1);
      if ((v4 & 0x20) == 0)
      {
LABEL_18:
        if ((v4 & 1) == 0) {
          goto LABEL_19;
        }
        goto LABEL_31;
      }
    }

    else if ((v4 & 0x20) == 0)
    {
      goto LABEL_18;
    }

    v4 ^= 0x20u;
    if (RNBContext::ProcessStateRunning(a1))
    {
      RNBRemote::HandleAsyncPacket((uint64_t)a1, 0LL);
      if ((v4 & 1) == 0) {
        goto LABEL_19;
      }
    }

    else
    {
      RNBRemote::HandleReceivedPacket((uint64_t)a1, 0LL);
      if ((v4 & 1) == 0)
      {
LABEL_19:
        uint64_t v6 = v2;
        if ((v4 & 4) == 0) {
          goto LABEL_20;
        }
        goto LABEL_32;
      }
    }

LABEL_31:
    uint64_t v7 = HandleProcessStateChange(a1, 0);
    PThreadEvent::ResetEvents((pthread_mutex_t *)((char *)a1 + 120), 1);
    v4 ^= 1u;
    uint64_t v6 = v7;
    if ((v4 & 4) == 0)
    {
LABEL_20:
      if ((v4 & 0x80) != 0) {
        goto LABEL_35;
      }
      goto LABEL_21;
    }

    uint64_t v10 = *(void **)&__s[24];
    if (!*(void *)&__s[24]) {
      goto LABEL_33;
    }
    goto LABEL_32;
  }

  if (v7 < 1)
  {
LABEL_30:
    DNBThreadResumeActions::SetDefaultThreadActionIfNeeded((char **)__s, 4, 0);
    DNBProcessResume( *((_DWORD *)this + 3),  *(char **)__s,  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&__s[8] - *(void *)__s) >> 3));
    uint64_t v9 = 0LL;
    goto LABEL_31;
  }

  uint64_t v11 = &v6[v7];
  uint64_t v12 = __s1 + 5;
  while (2)
  {
    if (*v12 != 59) {
      goto LABEL_30;
    }
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = 0uLL;
    __p.__r_.__value_.__l.__cap_ = -1LL;
    __endptr.__r_.__value_.__r.__words[0] = (std::string::size_type)(v12 + 2);
    HIDWORD(v13) = v12[1] - 67;
    LODWORD(v13) = HIDWORD(v13);
    switch((v13 >> 4))
    {
      case 0u:
        *__error() = 0;
        HIDWORD(__p.__r_.__value_.__r.__words[1]) = strtoul(v12 + 2, &__endptr.__r_.__value_.__l.__data_, 16);
        if (!*__error()) {
          goto LABEL_23;
        }
        v68 = 3714;
        goto LABEL_178;
      case 1u:
        *__error() = 0;
        HIDWORD(__p.__r_.__value_.__r.__words[1]) = strtoul(v12 + 2, &__endptr.__r_.__value_.__l.__data_, 16);
        if (!*__error()) {
          goto LABEL_26;
        }
        v68 = 3727;
        goto LABEL_178;
      case 2u:
LABEL_23:
        LODWORD(__p.__r_.__value_.__r.__words[1]) = 5;
        goto LABEL_27;
      case 3u:
LABEL_26:
        LODWORD(__p.__r_.__value_.__r.__words[1]) = 6;
        goto LABEL_27;
      default:
        RNBRemote::HandlePacket_ILLFORMED( (RNBRemote *)this,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  3736,  v6,  v8);
LABEL_27:
        uint64_t v12 = (const char *)__endptr.__r_.__value_.__r.__words[0];
        if (*__endptr.__r_.__value_.__l.__data_ != 58) {
          goto LABEL_19;
        }
        *__error() = 0;
        __endptr.__r_.__value_.__r.__words[0] = (std::string::size_type)(v12 + 1);
        __p.__r_.__value_.__r.__words[0] = strtoul(v12 + 1, &__endptr.__r_.__value_.__l.__data_, 16);
        if (!*__error())
        {
          uint64_t v12 = (const char *)__endptr.__r_.__value_.__r.__words[0];
LABEL_19:
          DNBThreadResumeActions::Append((char **)__s, (__int128 *)&__p);
          if (v12 >= v11) {
            goto LABEL_30;
          }
          continue;
        }

        v68 = 3745;
LABEL_178:
        uint64_t v9 = RNBRemote::HandlePacket_ILLFORMED( (RNBRemote *)this,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v68,  v6,  v14);
        uint64_t v10 = *(void **)&__s[24];
        if (*(void *)&__s[24]) {
          goto LABEL_32;
        }
LABEL_33:
        uint64_t v15 = *(void **)__s;
        if (*(void *)__s)
        {
          *(void *)&__s[8] = *(void *)__s;
          goto LABEL_134;
        }

        return v9;
    }
  }

        operator delete(v27.__r_.__value_.__l.__data_);
        goto LABEL_32;
      }
    }

    else
    {
      v20.__r_.__value_.__s.__size_ = 2;
      strcpy((char *)&v20, "OK");
      uint64_t v14 = RNBRemote::SendPacket((uint64_t)this, &v20);
      if ((char)v20.__r_.__value_.__s.__size_ < 0)
      {
        operator delete(v20.__r_.__value_.__l.__data_);
      }

      else if ((char)v21[0].__r_.__value_.__s.__size_ < 0)
      {
        goto LABEL_35;
      }
    }

    goto LABEL_30;
  }

  v21[0].__r_.__value_.__s.__size_ = 2;
  strcpy((char *)v21, "OK");
  uint64_t v14 = RNBRemote::SendPacket((uint64_t)this, v21);
  return v14;
}

  std::operator+<char>(__stra, "N", __str);
  *(_OWORD *)&a3->__r_.__value_.__l.__data_ = *(_OWORD *)__stra;
  a3->__r_.__value_.__l.__cap_ = v22;
  if (v8) {
    goto LABEL_34;
  }
}

LABEL_32:
    if (DNBLogEnabled()) {
      _DNBLog(0LL, (uint64_t)"debugserver's process monitoring thread has exited.", v8, v9, v10, v11, v12, v13, v37);
    }
    uint64_t v6 = 6LL;
    if ((v4 & 0x80) != 0)
    {
LABEL_35:
      if (DNBLogEnabled()) {
        _DNBLog( 0LL,  (uint64_t)"debugserver's packet communication to lldb has been shut down.",  v14,  v15,  v16,  v17,  v18,  v19,  v37);
      }
      uint64_t v20 = *((unsigned int *)a1 + 3);
      if ((_DWORD)v20)
      {
        BOOL v21 = RNBContext::ProcessStateRunning(a1);
        int v22 = *((unsigned __int8 *)a1 + 440);
        if (v21)
        {
          BOOL v23 = DNBLogEnabled();
          if (v22)
          {
            if (v23) {
              _DNBLog( 0LL,  (uint64_t)"debugserver has a valid PID %d, it is still running. detaching from the inferior process.",  v24,  v25,  v26,  v27,  v28,  v29,  v20);
            }
            goto LABEL_45;
          }

          if (v23) {
            _DNBLog( 0LL,  (uint64_t)"debugserver killing the inferior process, pid %d.",  v24,  v25,  v26,  v27,  v28,  v29,  v20);
          }
          DNBProcessKill(v20);
        }

        else if (*((_BYTE *)a1 + 440))
        {
          if (DNBLogEnabled()) {
            _DNBLog( 0LL,  (uint64_t)"debugserver has a valid PID %d but it may no longer be running, detaching from the inferior process.",  v30,  v31,  v32,  v33,  v34,  v35,  v20);
          }
LABEL_45:
          DNBProcessDetach(v20);
        }
      }

      uint64_t v6 = 6LL;
      goto LABEL_50;
    }

LABEL_21:
    if (!v4) {
      goto LABEL_24;
    }
LABEL_50:
    PThreadEvent::ResetEvents((pthread_mutex_t *)((char *)a1 + 120), v4);
    if ((char)__p.__r_.__value_.__s.__size_ < 0) {
LABEL_51:
    }
      operator delete(__p.__r_.__value_.__l.__data_);
LABEL_4:
    uint64_t v2 = 4LL;
    if ((_DWORD)v6 != 4) {
      return v6;
    }
  }

  return v2;
}

        if (v10 == v7) {
          return ((uint64_t)v5 - *(void *)a4) >> 3;
        }
      }

      BOOL v21 = v10 + 5;
      int v22 = *(void *)(a4 + 16);
      if ((unint64_t)v5 < v22)
      {
        *uint64_t v5 = v21;
        BOOL v23 = v5 + 1;
LABEL_48:
        *(void *)(a4 + 8) = v23;
        uint64_t v37 = (void *)v10[1];
        if (v37)
        {
          do
          {
            uint64_t v10 = v37;
            uint64_t v37 = (void *)*v37;
          }

          while (v37);
        }

        else
        {
          do
          {
            v38 = v10;
            uint64_t v10 = (void *)v10[2];
          }

          while ((void *)*v10 != v38);
        }

        uint64_t v5 = v23;
        goto LABEL_21;
      }

      uint64_t v24 = *(char **)a4;
      uint64_t v25 = (uint64_t)v5 - *(void *)a4;
      uint64_t v26 = v25 >> 3;
      uint64_t v27 = (v25 >> 3) + 1;
      if (v27 >> 61) {
        abort();
      }
      uint64_t v28 = v22 - (void)v24;
      if (v28 >> 2 > v27) {
        uint64_t v27 = v28 >> 2;
      }
      v58 = v27;
      v59 = v18;
      if (v27)
      {
        if (v27 >> 61) {
          goto LABEL_78;
        }
        uint64_t v29 = operator new(8 * v27);
        BOOL v21 = v10 + 5;
      }

      else
      {
        uint64_t v29 = 0LL;
      }

      uint64_t v30 = &v29[8 * v26];
      std::string *v30 = v21;
      BOOL v23 = v30 + 1;
      if (v5 == (void *)v24)
      {
        uint64_t v32 = v58;
        goto LABEL_45;
      }

      uint64_t v31 = (char *)v5 - v24 - 8;
      uint64_t v32 = v58;
      if (v31 >= 0x168)
      {
        v39 = ((char *)(v5 - 1) - v24) & 0xFFFFFFFFFFFFFFF8LL;
        if (&v29[v25 - 8 - v39] > &v29[v25 - 8])
        {
          uint64_t v33 = (char *)v5;
        }

        else if ((void *)((char *)v5 - v39 - 8) > v5 - 1)
        {
          uint64_t v33 = (char *)v5;
        }

        else if ((unint64_t)((char *)v5 - &v29[v25]) >= 0x20)
        {
          v40 = (v31 >> 3) + 1;
          v41 = 8 * (v40 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v33 = (char *)&v5[v41 / 0xFFFFFFFFFFFFFFF8LL];
          uint64_t v30 = (void *)((char *)v30 - v41);
          v42 = &v29[8 * v26 - 16];
          v43 = (__int128 *)(v5 - 2);
          v44 = v40 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            v45 = *v43;
            *(v42 - 1) = *(v43 - 1);
            *v42 = v45;
            v42 -= 2;
            v43 -= 2;
            v44 -= 4LL;
          }

          while (v44);
          if (v40 == (v40 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_43;
          }
        }

        else
        {
          uint64_t v33 = (char *)v5;
        }
      }

      else
      {
        uint64_t v33 = (char *)v5;
      }

      do
      {
        uint64_t v34 = *((void *)v33 - 1);
        v33 -= 8;
        *--uint64_t v30 = v34;
      }

      while (v33 != v24);
LABEL_43:
      uint64_t v5 = *(void **)a4;
LABEL_45:
      *(void *)a4 = v30;
      *(void *)(a4 + 8) = v23;
      *(void *)(a4 + 16) = &v29[8 * v32];
      if (v5)
      {
        uint64_t v35 = v5;
        v36 = v23;
        operator delete(v35);
        BOOL v23 = v36;
      }

      uint64_t v18 = v59;
      goto LABEL_48;
    }
  }

  return ((uint64_t)v5 - *(void *)a4) >> 3;
}

  v19[0].__r_.__value_.__s.__size_ = 3;
  LODWORD(v19[0].__r_.__value_.__l.__data_) = 3487813;
  uint64_t v6 = (std::__shared_weak_count *)RNBRemote::SendPacket((uint64_t)this, v19);
LABEL_24:
  if (SBYTE7(v29) < 0) {
    operator delete((void *)v28);
  }
  std::streambuf::~streambuf(v27);
  std::ios::~ios(&v31);
  uint64_t v32 = v14;
  *(void *)((char *)&v33[-1] + (void)*(v14 - 3)) = v15;
  if (SBYTE7(v35) < 0) {
    operator delete((void *)v34);
  }
  std::streambuf::~streambuf(v33);
  std::ios::~ios(&v37);
  return v6;
}

        if (DNBLogEnabledForAny(9437184)) {
          _DNBLogThreaded("HandleAsyncPacket (%s);");
        }
LABEL_25:
        uint64_t v14 = *((void *)&v21 + 1);
        uint64_t v13 = (uint64_t (*)(void *, std::string *))v21;
        uint64_t v15 = BYTE8(v21) & 1;
        if (*((void *)&v21 + 1)) {
          uint64_t v16 = (BYTE8(v21) & 1 | (unint64_t)v21) == 0;
        }
        else {
          uint64_t v16 = 1;
        }
        uint64_t v17 = !v16;
        if ((void)v21 || v17)
        {
          if (a2) {
            *a2 = *(_DWORD *)v20;
          }
          uint64_t v18 = (void *)(a1 + (v14 >> 1));
          if (v15) {
            uint64_t v13 = *(uint64_t (**)(void *, std::string *))(*v18 + v13);
          }
          if ((v25.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            uint64_t v19 = &v25;
          }
          else {
            uint64_t v19 = (std::string *)v25.__r_.__value_.__r.__words[0];
          }
          Packet = v13(v18, v19);
          if (SHIBYTE(v24) < 0) {
            goto LABEL_43;
          }
        }

        else
        {
          Packet = 0LL;
          if (SHIBYTE(v24) < 0) {
            goto LABEL_43;
          }
        }

  FILE *v15 = &v9[v14];
  return result;
}

uint64_t RNBRunLoopPlatform(RNBRemote *a1)
{
  uint64_t v2 = (pthread_mutex_t *)((char *)a1 + 120);
  do
  {
    memset(&__p, 0, sizeof(__p));
    if (DNBLogEnabledForAny(0x200000)) {
      _DNBLogThreaded("%s ctx.Events().WaitForSetEvents(0x%08x) ...", "RNBRunLoopPlatform", 160);
    }
    int v3 = PThreadEvent::WaitForSetEvents(v2, 0xA0u, 0LL);
    if (DNBLogEnabledForAny(0x200000))
    {
      int v4 = RNBContext::EventsAsString((int)a1, v3, &__p);
      _DNBLogThreaded( "%s ctx.Events().WaitForSetEvents(0x%08x) => 0x%08x (%s)",  "RNBRunLoopPlatform",  160,  v3,  (const char *)v4);
    }

    if (!v3)
    {
      int v6 = 5;
LABEL_19:
      operator delete(__p.__r_.__value_.__l.__data_);
      continue;
    }

    if ((v3 & 0x20) != 0)
    {
      else {
        int v5 = 5;
      }
    }

    else
    {
      int v5 = 5;
    }

    if ((v3 & 0x80) != 0) {
      int v6 = 6;
    }
    else {
      int v6 = v5;
    }
    PThreadEvent::ResetEvents(v2, v3);
  }

  while (v6 == 5);
  return 6LL;
}

void ASLLogCallback(void *a1, char a2, const char *format, va_list ap)
{
  if (format)
  {
    uint64_t v7 = (__asl_object_s *)ASLLogCallback(void *,unsigned int,char const*,char *)::g_aslmsg;
    if (!ASLLogCallback(void *,unsigned int,char const*,char *)::g_aslmsg)
    {
      ASLLogCallback(void *,unsigned int,char const*,char *)::g_aslmsg = (uint64_t)asl_new(0);
      snprintf(__str, 0x400uLL, "com.apple.%s-%s", "debugserver", "@(#)PROGRAM:LLDB  PROJECT:lldb-1600.2.8.9\n");
      asl_set((asl_object_t)ASLLogCallback(void *,unsigned int,char const*,char *)::g_aslmsg, "Sender", __str);
      uint64_t v7 = (__asl_object_s *)ASLLogCallback(void *,unsigned int,char const*,char *)::g_aslmsg;
    }

    if ((a2 & 2) != 0) {
      int v8 = 3;
    }
    else {
      int v8 = 4;
    }
    if ((a2 & 1) != 0) {
      int v9 = 2;
    }
    else {
      int v9 = v8;
    }
    asl_vlog(0LL, v7, v9, format, ap);
  }

FILE *FileLogCallback(FILE *result, unsigned int a2, const char *a3, va_list a4)
{
  if (result)
  {
    if (a3)
    {
      int v4 = result;
      vfprintf(result, a3, a4);
      fputc(10, v4);
      return (FILE *)fflush(v4);
    }
  }

  return result;
}

void show_usage_and_exit( int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (g_isatty)
  {
    fprintf(__stderrp, "Usage:\n  %s host:port [program-name program-arg1 program-arg2 ...]\n", "debugserver");
    if (g_isatty)
    {
LABEL_3:
      fprintf(__stderrp, "  %s /path/file [program-name program-arg1 program-arg2 ...]\n", "debugserver");
      if (g_isatty) {
        goto LABEL_4;
      }
      goto LABEL_10;
    }
  }

  else
  {
    _DNBLog( 0LL,  (uint64_t)"Usage:\n  %s host:port [program-name program-arg1 program-arg2 ...]\n",  a3,  a4,  a5,  a6,  a7,  a8,  (uint64_t)"debugserver");
    if (g_isatty) {
      goto LABEL_3;
    }
  }

  _DNBLog( 0LL,  (uint64_t)"  %s /path/file [program-name program-arg1 program-arg2 ...]\n",  v9,  v10,  v11,  v12,  v13,  v14,  (uint64_t)"debugserver");
  if (g_isatty)
  {
LABEL_4:
    fprintf(__stderrp, "  %s host:port --attach=<pid>\n", "debugserver");
    if (g_isatty) {
      goto LABEL_5;
    }
    goto LABEL_11;
  }

LABEL_10:
  _DNBLog(0LL, (uint64_t)"  %s host:port --attach=<pid>\n", v15, v16, v17, v18, v19, v20, (uint64_t)"debugserver");
  if (g_isatty)
  {
LABEL_5:
    fprintf(__stderrp, "  %s /path/file --attach=<pid>\n", "debugserver");
    if (g_isatty) {
      goto LABEL_6;
    }
    goto LABEL_12;
  }

        if ((SHIBYTE(__p[0]) & 0x80000000) == 0) {
          goto LABEL_11;
        }
LABEL_44:
        operator delete(v22[0]);
LABEL_45:
        operator delete(v25.__r_.__value_.__l.__data_);
        return Packet;
      }
    }

    else
    {
      if (!v25.__r_.__value_.__s.__size_) {
        goto LABEL_23;
      }
      uint64_t v12 = v25.__r_.__value_.__s.__data_[0];
      if ((v25.__r_.__value_.__s.__data_[0] & 0x80000000) == 0) {
        goto LABEL_16;
      }
    }

    if (!__maskrune(v12, 0x40000uLL)) {
      goto LABEL_23;
    }
    goto LABEL_21;
  }

  if ((SHIBYTE(v24) & 0x80000000) == 0) {
    goto LABEL_10;
  }
LABEL_43:
  operator delete(__p[1]);
  if (SHIBYTE(__p[0]) < 0) {
    goto LABEL_44;
  }
LABEL_11:
  return Packet;
}

  if ((unint64_t)v10 < *(void *)(v4 + 120))
  {
    *uint64_t v10 = v6;
    v10[1] = v7;
    do
      uint64_t v15 = __ldxr(p_shared_owners);
    while (__stxr(v15 + 1, p_shared_owners));
    *(void *)(v4 + 112) = v10 + 2;
LABEL_15:
    HIDWORD(v35) = v12 + 1;
    uint64_t v16 = v7;
LABEL_17:
    uint64_t v18 = (unint64_t *)&v16->__shared_owners_;
    do
      uint64_t v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }

    goto LABEL_21;
  }

  uint64_t v17 = std::vector<std::shared_ptr<JSONGenerator::Object>>::__push_back_slow_path<std::shared_ptr<JSONGenerator::Object> const&>( v4 + 104,  &v32);
  uint64_t v16 = (std::__shared_weak_count *)*((void *)&v32 + 1);
  *(void *)(v4 + 112) = v17;
  HIDWORD(v35) = v12 + 1;
  if (v16) {
    goto LABEL_17;
  }
  do
LABEL_21:
    uint64_t v20 = __ldaxr(p_shared_owners);
  while (__stlxr(v20 - 1, p_shared_owners));
  if (!v20)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }

  if ((unint64_t)v10 < *(void *)(v4 + 120))
  {
    *uint64_t v10 = v6;
    v10[1] = v7;
    do
      uint64_t v15 = __ldxr(p_shared_owners);
    while (__stxr(v15 + 1, p_shared_owners));
    *(void *)(v4 + 112) = v10 + 2;
LABEL_15:
    HIDWORD(v35) = v12 + 1;
    uint64_t v16 = v7;
LABEL_17:
    uint64_t v18 = (unint64_t *)&v16->__shared_owners_;
    do
      uint64_t v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }

    goto LABEL_21;
  }

  uint64_t v17 = std::vector<std::shared_ptr<JSONGenerator::Object>>::__push_back_slow_path<std::shared_ptr<JSONGenerator::Object> const&>( v4 + 104,  &v32);
  uint64_t v16 = (std::__shared_weak_count *)*((void *)&v32 + 1);
  *(void *)(v4 + 112) = v17;
  HIDWORD(v35) = v12 + 1;
  if (v16) {
    goto LABEL_17;
  }
  do
LABEL_21:
    uint64_t v20 = __ldaxr(p_shared_owners);
  while (__stlxr(v20 - 1, p_shared_owners));
  if (!v20)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }

LABEL_11:
  _DNBLog(0LL, (uint64_t)"  %s /path/file --attach=<pid>\n", v21, v22, v23, v24, v25, v26, (uint64_t)"debugserver");
  if (g_isatty)
  {
LABEL_6:
    fprintf(__stderrp, "  %s host:port --attach=<process_name>\n", "debugserver");
    if (g_isatty) {
      goto LABEL_7;
    }
    goto LABEL_13;
  }

  if ((this->__r_.__value_.__s.__size_ & 0x80u) == 0) {
    return this;
  }
  else {
    return (std::string *)this->__r_.__value_.__r.__words[0];
  }
}

  RegisterContext = DNBThreadGetRegisterContext(v7, CurrentThread, 0LL, 0LL);
  if (RegisterContext)
  {
    uint64_t v13 = RegisterContext;
    if ((RegisterContext & 0x8000000000000000LL) != 0) {
      abort();
    }
    uint64_t v14 = operator new(RegisterContext);
    bzero(v14, v13);
    if (DNBThreadGetRegisterContext(v7, CurrentThread, v14, v13))
    {
      append_hex_value((uint64_t)&v19, (unsigned __int8 *)v14, v13, 0);
      std::stringbuf::str(&__p, &v20);
      uint64_t v15 = RNBRemote::SendPacket((uint64_t)this, &__p);
      uint64_t v16 = v14;
      goto LABEL_22;
    }

    operator delete(v14);
  }

  __p.__r_.__value_.__s.__size_ = 3;
  uint64_t v11 = 3422021;
LABEL_20:
  LODWORD(__p.__r_.__value_.__l.__data_) = v11;
  uint64_t v15 = RNBRemote::SendPacket((uint64_t)this, &__p);
  uint64_t v16 = (void *)__p.__r_.__value_.__r.__words[0];
LABEL_22:
  operator delete(v16);
LABEL_23:
  std::streambuf::~streambuf(&v20);
  std::ios::~ios(&v21);
  return v15;
}

LABEL_12:
  _DNBLog( 0LL,  (uint64_t)"  %s host:port --attach=<process_name>\n",  v27,  v28,  v29,  v30,  v31,  v32,  (uint64_t)"debugserver");
  if (g_isatty)
  {
LABEL_7:
    fprintf(__stderrp, "  %s /path/file --attach=<process_name>\n", "debugserver");
    exit(a1);
  }

      uint64_t v10 = this;
      uint64_t v11 = 3511;
      return RNBRemote::HandlePacket_ILLFORMED( v10,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v11,  __big,  a5);
    }
  }

  else
  {
    CurrentThread = *((void *)this + 68);
    if (CurrentThread + 1 <= 1)
    {
      CurrentThread = DNBProcessGetCurrentThread(*((_DWORD *)this + 3));
      if (!CurrentThread) {
        goto LABEL_11;
      }
    }
  }

  StdStringExtractor::StdStringExtractor((StdStringExtractor *)v16, __big);
  v16[4] = (void *)22;
  if (!StdStringExtractor::GetU32((StdStringExtractor *)v16, 0LL, 0))
  {
    __p.__r_.__value_.__s.__size_ = 3;
    uint64_t v13 = 3553093;
LABEL_16:
    LODWORD(__p.__r_.__value_.__l.__data_) = v13;
    goto LABEL_17;
  }

  if (!DNBThreadRestoreRegisterState(v7, CurrentThread))
  {
    __p.__r_.__value_.__s.__size_ = 3;
    uint64_t v13 = 3618629;
    goto LABEL_16;
  }

  __p.__r_.__value_.__s.__size_ = 2;
  strcpy((char *)&__p, "OK");
LABEL_17:
  uint64_t v14 = RNBRemote::SendPacket((uint64_t)this, &__p);
  StdStringExtractor::~StdStringExtractor(v16);
  return v14;
}

    ++v10;
    ++v8;
    if (v9 + v10 == 792) {
      return 0xFFFFFFFFLL;
    }
  }

  if (((*a2 ^ v11) & 0x1FFFFFFFFFFF8LL) != 0) {
    goto LABEL_12;
  }
  if ((v12 & 0x20) != 0)
  {
    uint64_t v15 = 0LL;
  }

  else if ((v12 & 0x40) != 0)
  {
    uint64_t v15 = 1LL;
  }

  else if ((v12 & 0x80) != 0)
  {
    uint64_t v15 = 2LL;
  }

  else if ((v12 & 0x100) != 0)
  {
    uint64_t v15 = 3LL;
  }

  else if ((v12 & 0x200) != 0)
  {
    uint64_t v15 = 4LL;
  }

  else if ((v12 & 0x400) != 0)
  {
    uint64_t v15 = 5LL;
  }

  else if ((v12 & 0x800) != 0)
  {
    uint64_t v15 = 6LL;
  }

  else
  {
    uint64_t v15 = 7LL;
    if ((v12 & 0x1000) == 0) {
      uint64_t v15 = 0xFFFFFFFFLL;
    }
  }

  *a2 = v15 + v11;
  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded("DNBArchImplARM64::GetHardwareWatchpointHit() slot: %u matched BAS", v10 - 792);
  }
  return v10 - 792;
}

LABEL_13:
  _DNBLog( 0LL,  (uint64_t)"  %s /path/file --attach=<process_name>\n",  v33,  v34,  v35,  v36,  v37,  v38,  (uint64_t)"debugserver");
  exit(a1);
}

  if (*((char *)this + 31) < 0)
  {
    if (*((void *)this + 2)) {
      return *((void *)this + 1);
    }
    return 0LL;
  }

  if (*((_BYTE *)this + 31)) {
    return (uint64_t)this + 8;
  }
  else {
    return 0LL;
  }
}

    uint64_t v10 = 0LL;
    goto LABEL_14;
  }

  if (v4 == 16777223)
  {
    uint64_t v10 = "x86_64";
    goto LABEL_14;
  }

  if (v4 == 33554444)
  {
    uint64_t v10 = "arm64_32";
    goto LABEL_14;
  }

  if (v4 != 16777228) {
    goto LABEL_13;
  }
  uint64_t v10 = "arm64";
LABEL_14:
  uint64_t v11 = strlen(v10);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v9, (uint64_t)v10, v11);
  std::stringbuf::str(&v27, &v29);
  if ((v27.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v12 = &v27;
  }
  else {
    uint64_t v12 = (std::stringbuf::string_type *)v27.__r_.__value_.__r.__words[0];
  }
  XMLAttributeString((uint64_t)a1, "name", (char *)v12, 0LL);
  v27.__r_.__value_.__s.__data_[0] = 62;
  uint64_t v13 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)&v27, 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v13 + *(void *)(*v13 - 24LL)));
  uint64_t v14 = std::locale::use_facet((const std::locale *)&v27, &std::ctype<char>::id);
  uint64_t v15 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v14->__vftable[2].~facet_0)(v14, 10LL);
  std::locale::~locale((std::locale *)&v27);
  std::ostream::put(v13, v15);
  std::ostream::flush(v13);
  if (g_num_reg_entries)
  {
    uint64_t v18 = 0LL;
    uint64_t v19 = 0;
    do
    {
      GenerateTargetXMLRegister(a1, v19++, v16, v17, g_reg_entries + (v18 << 7));
      uint64_t v18 = v19;
    }

    while (g_num_reg_entries > (unint64_t)v19);
  }

  XMLElementEnd(a1, 0, "feature");
  if (v31)
  {
    XMLElementStart(a1, 0, "groups", 0);
    if (v31 >= 2)
    {
      uint64_t v20 = 2;
      for (i = 1LL; i < v31; i = v20++)
      {
        XMLElementStart(a1, 2, "group", 1);
        XMLAttributeUnsignedDecimal(a1, "id", i);
        XMLAttributeString((uint64_t)a1, "name", *(char **)(v2 + 24 * i), 0LL);
        v27.__r_.__value_.__s.__data_[0] = 47;
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)&v27, 1LL);
        v27.__r_.__value_.__s.__data_[0] = 62;
        uint64_t v22 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)&v27, 1LL);
        std::ios_base::getloc((const std::ios_base *)((char *)v22 + *(void *)(*v22 - 24LL)));
        uint64_t v23 = std::locale::use_facet((const std::locale *)&v27, &std::ctype<char>::id);
        uint64_t v24 = v2;
        uint64_t v25 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v23->__vftable[2].~facet_0)(v23, 10LL);
        std::locale::~locale((std::locale *)&v27);
        uint64_t v26 = v25;
        uint64_t v2 = v24;
        std::ostream::put(v22, v26);
        std::ostream::flush(v22);
      }
    }

    XMLElementEnd(a1, 0, "groups");
  }

  std::streambuf::~streambuf(&v29);
  return std::ios::~ios(&v30);
}

int main(int argc, const char **argv, const char **envp)
{
  v396 = *argv;
  pthread_setname_np("main thread");
  int v428 = 0;
  int v5 = pthread_self();
  if (!pthread_getschedparam(v5, &v428, &v429))
  {
    v429.sched_priority = 47;
    int v6 = pthread_self();
    pthread_setschedparam(v6, v428, &v429);
  }

  uint64_t v7 = getpid();
  proc_set_wakemon_params(v7, 500LL, 0LL);
  g_isatty = isatty(0);
  signal(13, (void (__cdecl *)(int))signal_handler);
  signal(1, (void (__cdecl *)(int))signal_handler);
  sigset_t v427 = 0x80000;
  int v8 = (OsLogger *)sigprocmask(1, &v427, 0LL);
  LogFunction = (void *)OsLogger::GetLogFunction(v8);
  if (LogFunction)
  {
    DNBLogSetLogCallback(LogFunction, 0LL);
    if (!DNBLogEnabled()) {
      goto LABEL_9;
    }
    uint64_t v16 = "debugserver will use os_log for internal logging.";
  }

  else
  {
    DNBLogSetLogCallback(ASLLogCallback, 0LL);
    if (!DNBLogEnabled()) {
      goto LABEL_9;
    }
    uint64_t v16 = "debugserver will use ASL for internal logging.";
  }

  _DNBLog(0LL, (uint64_t)v16, v10, v11, v12, v13, v14, v15, (uint64_t)v389);
LABEL_9:
  DNBLogSetLogMask(0);
  LODWORD(__dst[0].__r_.__value_.__l.__data_) = 0;
  v431[0] = 4LL;
  int v17 = sysctlbyname("security.mac.amfi.developer_mode_status", __dst, v431, 0LL, 0LL);
  if (v17 | LODWORD(__dst[0].__r_.__value_.__l.__data_))
  {
    uint64_t v24 = operator new(0x338uLL);
    v24[2] = 0LL;
    void *v24 = off_100060C10;
    v24[1] = 0LL;
    uint64_t v25 = (uint64_t)(v24 + 3);
    RNBRemote::RNBRemote((RNBRemote *)(v24 + 3));
    uint64_t v26 = (std::__shared_weak_count *)qword_1000716A0;
    g_remoteSP = (uint64_t)(v24 + 3);
    qword_1000716A0 = (uint64_t)v24;
    if (!v26) {
      goto LABEL_16;
    }
    p_shared_owners = (unint64_t *)&v26->__shared_owners_;
    do
      unint64_t v28 = __ldaxr(p_shared_owners);
    while (__stlxr(v28 - 1, p_shared_owners));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }

    uint64_t v25 = g_remoteSP;
    if (g_remoteSP)
    {
LABEL_16:
      int v426 = 0;
      v424[0] = 0LL;
      v424[1] = 0LL;
      uint64_t v425 = 0LL;
      v421 = 0LL;
      uint64_t v422 = 0LL;
      uint64_t v423 = 0LL;
      memset(&v420, 0, sizeof(v420));
      v417 = 0LL;
      uint64_t v418 = 0LL;
      uint64_t v419 = 0LL;
      v414 = 0LL;
      uint64_t v415 = 0LL;
      uint64_t v416 = 0LL;
      v412[0] = 0LL;
      v412[1] = 0LL;
      uint64_t v413 = 0LL;
      v410[0] = 0LL;
      v410[1] = 0LL;
      uint64_t v411 = 0LL;
      *(_WORD *)v432 = 29803;
      if (g_long_options)
      {
        int v29 = 2;
        uint64_t v30 = &dword_100068118;
        while (1)
        {
          uint64_t v33 = *v30;
          if (v33 <= 0x7F)
          {
            if ((_DefaultRuneLocale.__runetype[v33] & 0x100) == 0) {
              goto LABEL_20;
            }
          }

          else if (!__maskrune(v33, 0x100uLL))
          {
            goto LABEL_20;
          }

          int v34 = v29 + 1;
          v432[v29] = *v30;
          int v35 = *(v30 - 4);
          if (v35 == 1)
          {
            int v31 = 2;
          }

          else
          {
            if (v35 != 2)
            {
              ++v29;
              goto LABEL_20;
            }

            v432[v34] = 58;
            int v34 = v29 + 2;
            int v31 = 3;
          }

          v29 += v31;
          v432[v34] = 58;
LABEL_20:
          uint64_t v32 = *((void *)v30 + 1);
          v30 += 8;
          if (!v32) {
            goto LABEL_35;
          }
        }
      }

      int v29 = 2;
LABEL_35:
      v432[v29] = 0;
      optreset = 1;
      optind = 1;
      uint64_t v41 = getopt_long_only(argc, (char *const *)argv, v432, (const option *)&g_long_options, &v426);
      if ((_DWORD)v41 != -1)
      {
        uint64_t v42 = v41;
        int v43 = 0;
        char v394 = 0;
        int v404 = 0;
        char v393 = 0;
        unsigned int v400 = 0;
        int v401 = 0;
        v402 = 0LL;
        useconds_t v398 = 1000;
        unint64_t v399 = 0LL;
        int StartModeFromRemote = 6;
        while (2)
        {
          if (DNBLogEnabled()) {
            _DNBLogDebug((uint64_t)"option: ch == %c (0x%2.2x) --%s%c%s\n", v47, v48, v49, v50, v51, v52, v53, v42);
          }
          switch((int)v42)
          {
            case '2':
              communication_fd = atoi(optarg);
              goto LABEL_40;
            case 'A':
              v45 = optarg;
              if (!optarg || !*optarg) {
                goto LABEL_40;
              }
              v46 = (std::string *)&v417;
              goto LABEL_39;
            case 'D':
              g_disable_aslr = 1;
              goto LABEL_40;
            case 'E':
              goto LABEL_38;
            case 'F':
              int v43 = 1;
              goto LABEL_40;
            case 'I':
              v45 = optarg;
              v46 = (std::string *)(v25 + 16);
              goto LABEL_39;
            case 'K':
              g_detach_on_error = 0;
              goto LABEL_40;
            case 'O':
              v45 = optarg;
              v46 = (std::string *)(v25 + 40);
              goto LABEL_39;
            case 'P':
              v45 = optarg;
              v46 = (std::string *)v410;
              goto LABEL_39;
            case 'R':
              int v404 = 1;
              goto LABEL_40;
            case 'S':
              setsid();
              goto LABEL_40;
            case 'U':
              RNBContext::AddDefaultIgnoredExceptions((RNBContext *)v25);
              goto LABEL_40;
            case 'V':
              BOOL IsTranslated = DNBDebugserverIsTranslated();
              v350 = " (running under translation)";
              if (!IsTranslated) {
                v350 = (const char *)&unk_1000528BD;
              }
              printf("%s-%s for %s%s.\n", "debugserver", "@(#)PROGRAM:LLDB  PROJECT:lldb-1600.2.8.9\n", "arm64", v350);
              exit(0);
            case 'W':
              v45 = optarg;
              if (!optarg || !*optarg) {
                goto LABEL_40;
              }
              v46 = (std::string *)&v414;
              goto LABEL_39;
            case 'X':
              char v394 = 1;
              goto LABEL_40;
            case 'a':
              if (!optarg) {
                goto LABEL_40;
              }
              uint64_t v56 = *optarg;
              if (!*optarg) {
                goto LABEL_40;
              }
              if ((v56 & 0x80) == 0 && (_DefaultRuneLocale.__runetype[v56] & 0x400) != 0)
              {
                v431[0] = 0LL;
                unint64_t v399 = strtoul(optarg, (char **)v431, 0);
                if (!v431[0] || *(_BYTE *)v431[0])
                {
                  if (!g_isatty)
                  {
                    _DNBLog( 0LL,  (uint64_t)"error: invalid pid option '%s'\n",  v85,  v86,  v87,  v88,  v89,  v90,  (uint64_t)optarg);
                    exit(4);
                  }

                  fprintf(__stderrp, "error: invalid pid option '%s'\n", optarg);
                  exit(4);
                }

                int StartModeFromRemote = 2;
              }

              else
              {
                v55 = &v420;
                v54 = optarg;
LABEL_57:
                std::string::assign(v55, v54);
                int StartModeFromRemote = 2;
              }

              goto LABEL_40;
            case 'd':
              if (optarg)
              {
                if (*optarg)
                {
                  v431[0] = 0LL;
                  unsigned int v400 = strtoul(optarg, (char **)v431, 0);
                  if (!v431[0] || *(_BYTE *)v431[0])
                  {
                    if (!g_isatty)
                    {
                      _DNBLog( 0LL,  (uint64_t)"error: invalid waitfor-duration option value '%s'.\n",  v57,  v58,  v59,  v60,  v61,  v62,  (uint64_t)optarg);
                      exit(7);
                    }

                    fprintf(__stderrp, "error: invalid waitfor-duration option value '%s'.\n", optarg);
                    exit(7);
                  }
                }
              }

              goto LABEL_40;
            case 'e':
              RNBContext::PushEnvironment((RNBContext *)v25, optarg);
              goto LABEL_40;
            case 'f':
              if (optarg && *optarg) {
                int v401 = strtoul(optarg, 0LL, 0);
              }
              goto LABEL_40;
            case 'g':
              DNBLogSetDebug(1LL);
              goto LABEL_40;
            case 'i':
              if (optarg)
              {
                if (*optarg)
                {
                  v431[0] = 0LL;
                  useconds_t v398 = strtoul(optarg, (char **)v431, 0);
                  if (!v431[0] || *(_BYTE *)v431[0])
                  {
                    if (!g_isatty)
                    {
                      _DNBLog( 0LL,  (uint64_t)"error: invalid waitfor-interval option value '%s'.\n",  v78,  v79,  v80,  v81,  v82,  v83,  (uint64_t)optarg);
                      exit(6);
                    }

                    fprintf(__stderrp, "error: invalid waitfor-interval option value '%s'.\n", optarg);
                    exit(6);
                  }
                }
              }

              goto LABEL_40;
            case 'k':
              g_lockdown_opt = 1;
              goto LABEL_40;
            case 'l':
              v63 = optarg;
              if (!optarg || !*optarg) {
                goto LABEL_40;
              }
              if (!strcasecmp(optarg, "stdout"))
              {
                v84 = __stdoutp;
                if (__stdoutp) {
                  goto LABEL_108;
                }
              }

              else if (!strcasecmp(v63, "stderr"))
              {
                v84 = __stderrp;
                if (__stderrp)
                {
LABEL_108:
                  v402 = v84;
                  goto LABEL_40;
                }
              }

              else
              {
                v64 = fopen(v63, "w");
                if (v64)
                {
                  v402 = v64;
                  setlinebuf(v64);
                  goto LABEL_40;
                }
              }

              int v392 = v43;
              v91 = __error();
              v92 = strerror(*v91);
              if (g_isatty)
              {
                v403 = __stderrp;
                v93 = optarg;
                v94 = __error();
                v95 = "unknown error";
                if (v92) {
                  v95 = v92;
                }
                fprintf(v403, "Failed to open log file '%s' for writing: errno = %i (%s)", v93, *v94, v95);
              }

              else
              {
                v102 = optarg;
                __error();
                _DNBLog( 0LL,  (uint64_t)"Failed to open log file '%s' for writing: errno = %i (%s)",  v103,  v104,  v105,  v106,  v107,  v108,  (uint64_t)v102);
              }

              v402 = 0LL;
              int v43 = v392;
LABEL_40:
              uint64_t v42 = getopt_long_only(argc, (char *const *)argv, v432, (const option *)&g_long_options, &v426);
              if ((_DWORD)v42 != -1) {
                continue;
              }
              goto LABEL_128;
            case 'n':
              char v393 = 1;
              goto LABEL_40;
            case 'p':
              int StartModeFromRemote = 5;
              goto LABEL_40;
            case 's':
              std::string::assign((std::string *)(v25 + 16), optarg);
              std::string::assign((std::string *)(v25 + 40), optarg);
LABEL_38:
              v45 = optarg;
              v46 = (std::string *)(v25 + 64);
              goto LABEL_39;
            case 't':
              g_applist_opt = 1;
              goto LABEL_40;
            case 'u':
              v45 = optarg;
              v46 = (std::string *)v412;
LABEL_39:
              std::string::assign(v46, v45);
              goto LABEL_40;
            case 'v':
              DNBLogSetVerbose(1LL);
              goto LABEL_40;
            case 'w':
              v54 = optarg;
              if (!optarg || !*optarg) {
                goto LABEL_40;
              }
              v55 = (std::string *)&v421;
              goto LABEL_57;
            case 'x':
              v65 = optarg;
              if (optarg && *optarg)
              {
                if (!strcasecmp(optarg, "auto"))
                {
                  g_launch_flavor = 0;
                }

                else if (strcasestr(v65, "posix") == optarg)
                {
                  if (DNBLogEnabled()) {
                    _DNBLog( 0LL,  (uint64_t)"[LaunchAttach] launch flavor is posix_spawn via cmdline option",  v96,  v97,  v98,  v99,  v100,  v101,  (uint64_t)v389);
                  }
                  g_launch_flavor = 1;
                }

                else if (strcasestr(optarg, "fork") == optarg)
                {
                  g_launch_flavor = 2;
                }

                else if (strcasestr(optarg, "backboard") == optarg)
                {
                  if (DNBLogEnabled()) {
                    _DNBLog( 0LL,  (uint64_t)"[LaunchAttach] launch flavor is BKS via cmdline option",  v109,  v110,  v111,  v112,  v113,  v114,  (uint64_t)v389);
                  }
                  g_launch_flavor = 4;
                }

                else
                {
                  if (strcasestr(optarg, "frontboard") != optarg)
                  {
                    if (g_isatty) {
                      fprintf(__stderrp, "error: invalid TYPE for the --launch=TYPE (-x TYPE) option: '%s'\n", optarg);
                    }
                    else {
                      _DNBLog( 0LL,  (uint64_t)"error: invalid TYPE for the --launch=TYPE (-x TYPE) option: '%s'\n",  v66,  v67,  v68,  v69,  v70,  v71,  (uint64_t)optarg);
                    }
                    if (g_isatty) {
                      fwrite("Valid values TYPE are:\n", 0x17uLL, 1uLL, __stderrp);
                    }
                    else {
                      _DNBLog( 0LL,  (uint64_t)"Valid values TYPE are:\n",  v353,  v354,  v355,  v356,  v357,  v358,  (uint64_t)v391);
                    }
                    if (g_isatty) {
                      fwrite("  auto       Auto-detect the best launch method to use.\n", 0x38uLL, 1uLL, __stderrp);
                    }
                    else {
                      _DNBLog( 0LL,  (uint64_t)"  auto       Auto-detect the best launch method to use.\n",  v359,  v360,  v361,  v362,  v363,  v364,  (uint64_t)v391);
                    }
                    if (g_isatty) {
                      fwrite("  posix      Launch the executable using posix_spawn.\n", 0x36uLL, 1uLL, __stderrp);
                    }
                    else {
                      _DNBLog( 0LL,  (uint64_t)"  posix      Launch the executable using posix_spawn.\n",  v365,  v366,  v367,  v368,  v369,  v370,  (uint64_t)v391);
                    }
                    if (g_isatty) {
                      fwrite("  fork       Launch the executable using fork and exec.\n", 0x38uLL, 1uLL, __stderrp);
                    }
                    else {
                      _DNBLog( 0LL,  (uint64_t)"  fork       Launch the executable using fork and exec.\n",  v371,  v372,  v373,  v374,  v375,  v376,  (uint64_t)v391);
                    }
                    if (g_isatty) {
                      fwrite( "  backboard  Launch the executable through BackBoard Services.\n",  0x3FuLL,  1uLL,  __stderrp);
                    }
                    else {
                      _DNBLog( 0LL,  (uint64_t)"  backboard  Launch the executable through BackBoard Services.\n",  v377,  v378,  v379,  v380,  v381,  v382,  (uint64_t)v391);
                    }
                    if (!g_isatty)
                    {
                      _DNBLog( 0LL,  (uint64_t)"  frontboard  Launch the executable through FrontBoard Services.\n",  v383,  v384,  v385,  v386,  v387,  v388,  (uint64_t)v391);
                      exit(5);
                    }

                    fwrite( "  frontboard  Launch the executable through FrontBoard Services.\n",  0x41uLL,  1uLL,  __stderrp);
                    exit(5);
                  }

                  if (DNBLogEnabled()) {
                    _DNBLog( 0LL,  (uint64_t)"[LaunchAttach] launch flavor is FBS via cmdline option",  v72,  v73,  v74,  v75,  v76,  v77,  (uint64_t)v389);
                  }
                  g_launch_flavor = 5;
                }
              }

              goto LABEL_40;
            default:
              goto LABEL_40;
          }
        }
      }

      unint64_t v399 = 0LL;
      unsigned int v400 = 0;
      int v401 = 0;
      v402 = 0LL;
      char v393 = 0;
      int v404 = 0;
      char v394 = 0;
      int v43 = 0;
      int StartModeFromRemote = 6;
      useconds_t v398 = 1000;
LABEL_128:
      if (SHIBYTE(v419) < 0)
      {
        uint64_t v115 = (uint64_t)v402;
        if (!v418) {
          goto LABEL_134;
        }
        v116 = v417;
      }

      else
      {
        uint64_t v115 = (uint64_t)v402;
        if (!HIBYTE(v419)) {
          goto LABEL_134;
        }
        v116 = (const char *)&v417;
      }

      DNBSetArchitecture(v116);
LABEL_134:
      uint64_t v117 = optind;
      if (SHIBYTE(v416) < 0)
      {
        if (!v415) {
          goto LABEL_140;
        }
        v118 = v414;
      }

      else
      {
        if (!HIBYTE(v416)) {
          goto LABEL_140;
        }
        v118 = (const char *)&v414;
      }

      if (!RNBContext::SetWorkingDirectory((RNBContext *)v25, v118))
      {
        if (!g_isatty)
        {
          v351 = &v414;
          if (v416 < 0) {
            v351 = v414;
          }
          _DNBLog( 0LL,  (uint64_t)"error: working directory doesn't exist '%s'.\n",  v119,  v120,  v121,  v122,  v123,  v124,  (uint64_t)v351);
          exit(8);
        }

        v352 = (const char *)&v414;
        if (v416 < 0) {
          v352 = v414;
        }
        fprintf(__stderrp, "error: working directory doesn't exist '%s'.\n", v352);
        exit(8);
      }

LABEL_140:
      v125 = &argv[v117];
      *(_BYTE *)(v25 + 440) = g_detach_on_error;
      RNBRemote::Initialize((RNBRemote *)v25);
      if (v115)
      {
        if (DNBLogEnabled()) {
          _DNBLog( 0LL,  (uint64_t)"debugserver is switching to logging to a file.",  v126,  v127,  v128,  v129,  v130,  v131,  (uint64_t)v389);
        }
        DNBLogSetLogCallback(FileLogCallback, v115);
        if (v401) {
          int v132 = v401;
        }
        else {
          int v132 = -1;
        }
      }

      else
      {
        int v132 = v401;
      }

      uint64_t v133 = (argc - v117);
      DNBLogSetLogMask(v132);
      if (DNBLogEnabled() && (int)v133 >= 1)
      {
        for (uint64_t i = 0LL; i != v133; ++i)
        {
          if (DNBLogEnabled()) {
            _DNBLogDebug((uint64_t)"argv[%i] = %s", v135, v136, v137, v138, v139, v140, v141, i);
          }
        }
      }

      BOOL v142 = DNBDebugserverIsTranslated();
      v149 = " (running under translation)";
      if (!v142) {
        v149 = (const char *)&unk_1000528BD;
      }
      if (g_isatty)
      {
        v150 = v424;
        if (v425 < 0) {
          v150 = (void **)v424[0];
        }
        fprintf( __stdoutp,  "%s-%s %sfor %s%s.\n",  "debugserver",  "@(#)PROGRAM:LLDB  PROJECT:lldb-1600.2.8.9\n",  (const char *)v150,  "arm64",  v149);
      }

      else
      {
        _DNBLog(0LL, (uint64_t)"%s-%s %sfor %s%s.\n", v143, v144, v145, v146, v147, v148, (uint64_t)"debugserver");
      }

      memset(&v409, 0, sizeof(v409));
      int v408 = 0x7FFFFFFF;
      LOBYTE(v431[0]) = 0;
      if (g_lockdown_opt || g_applist_opt || communication_fd != -1) {
        goto LABEL_252;
      }
      v158 = *v125;
      size_t v159 = strlen(*v125);
      if (v159 > 0x7FFFFFFFFFFFFFF7LL) {
        goto LABEL_533;
      }
      std::string::size_type v160 = v159;
      if (v159 >= 0x17)
      {
        uint64_t v162 = (v159 & 0xFFFFFFFFFFFFFFF8LL) + 8;
        if ((v159 | 7) != 0x17) {
          uint64_t v162 = v159 | 7;
        }
        uint64_t v163 = v162 + 1;
        v161 = (std::string *)operator new(v162 + 1);
        __dst[0].__r_.__value_.__l.__size_ = v160;
        __dst[0].__r_.__value_.__l.__cap_ = v163 | 0x8000000000000000LL;
        __dst[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v161;
      }

      else
      {
        __dst[0].__r_.__value_.__s.__size_ = v159;
        v161 = __dst;
        if (!v159)
        {
LABEL_174:
          v161->__r_.__value_.__s.__data_[v160] = 0;
          std::string::size_type v164 = std::string::rfind(__dst, 58, 0xFFFFFFFFFFFFFFFFLL);
          if (v164 == -1LL)
          {
            if (sscanf(*v125, "%i", &v408) == 1)
            {
              std::string::assign(&v409, "127.0.0.1");
              if (DNBLogEnabled())
              {
                if ((v409.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                  v183 = &v409;
                }
                else {
                  v183 = (std::string *)v409.__r_.__value_.__r.__words[0];
                }
                _DNBLogDebug((uint64_t)"host = '%s'  port = %i", v176, v177, v178, v179, v180, v181, v182, (uint64_t)v183);
              }

LABEL_251:
              LODWORD(v133) = v133 - 1;
              ++v125;
              if ((char)__dst[0].__r_.__value_.__s.__size_ < 0)
              {
                operator delete(__dst[0].__r_.__value_.__l.__data_);
                if (StartModeFromRemote == 2) {
                  goto LABEL_268;
                }
LABEL_253:
                if (StartModeFromRemote == 5) {
                  goto LABEL_268;
                }
                if ((_DWORD)v133 && !g_lockdown_opt)
                {
                  if ((int)v133 >= 1)
                  {
                    uint64_t v213 = 0LL;
                    do
                    {
                      if (DNBLogEnabled()) {
                        _DNBLogDebug( (uint64_t)"inferior_argv[%i] = '%s'",  v214,  v215,  v216,  v217,  v218,  v219,  v220,  v213);
                      }
                      RNBContext::PushArgument((RNBContext *)v25, v125[v213++]);
                    }

                    while (v133 != v213);
                  }

                  int StartModeFromRemote = 3;
                  goto LABEL_271;
                }

                if (g_lockdown_opt)
                {
                  int v221 = open("/dev/null", 2);
                  dup2(v221, 1);
                  dup2(v221, 2);
LABEL_265:
                  if (DNBLogEnabled()) {
                    _DNBLogDebug( (uint64_t)"Get args from remote protocol...",  v222,  v223,  v224,  v225,  v226,  v227,  v228,  (uint64_t)v390);
                  }
                  int StartModeFromRemote = 1;
LABEL_268:
                  if (((StartModeFromRemote != 3) & ~v43) != 0)
                  {
LABEL_274:
                    bzero(__dst, 0x400uLL);
                    v397 = (std::string *)(v25 + 312);
                    int v395 = v394 & 1;
                    while (1)
                    {
                      int v239 = StartModeFromRemote - 1;
                      int StartModeFromRemote = 6;
                      switch(v239)
                      {
                        case 0:
                          if (g_lockdown_opt)
                          {
                            if (*(_DWORD *)(v25 + 472) != -1) {
                              goto LABEL_476;
                            }
                            if (RNBSocket::ConnectToService((RNBSocket *)(v25 + 472), v395))
                            {
                              if (g_isatty)
                              {
                                v246 = __stderrp;
                                v247 = "Failed to get connection from a remote gdb process.\n";
                                size_t v248 = 52LL;
                                goto LABEL_482;
                              }

                              _DNBLog( 0LL,  (uint64_t)"Failed to get connection from a remote gdb process.\n",  v240,  v241,  v242,  v243,  v244,  v245,  (uint64_t)v390);
                            }

                            else
                            {
                              if (!g_applist_opt) {
                                goto LABEL_475;
                              }
                              if (DNBLogEnabled()) {
                                _DNBLog( 0LL,  (uint64_t)"debugserver running in applist mode under lockdown",  v299,  v300,  v301,  v302,  v303,  v304,  (uint64_t)v390);
                              }
                              memset(&__p, 0, sizeof(__p));
                              if (!ListApplications(&__p, 0LL, 0LL))
                              {
                                if (DNBLogEnabled())
                                {
                                  p_p = &__p;
                                  if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                                    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
                                  }
                                  _DNBLogDebug( (uint64_t)"Task list: %s",  v305,  v306,  v307,  v308,  v309,  v310,  v311,  (uint64_t)p_p);
                                }

                                if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                                  v313 = &__p;
                                }
                                else {
                                  v313 = (std::string *)__p.__r_.__value_.__r.__words[0];
                                }
                                if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                                  size_t size = __p.__r_.__value_.__s.__size_;
                                }
                                else {
                                  size_t size = __p.__r_.__value_.__l.__size_;
                                }
                                RNBSocket::Write((RNBSocket *)(v25 + 472), v313, size);
                                memset(&v405, 0, sizeof(v405));
                                RNBSocket::Read((int *)(v25 + 472), &v405);
                              }

                              RNBSocket::Disconnect((RNBSocket *)(v25 + 472));
                            }
                          }

                          else
                          {
                            uint64_t v233 = v408;
                            if (v408 == 0x7FFFFFFF)
                            {
                              if (LOBYTE(v431[0]) == 47)
                              {
                              }

                              else
                              {
                                if (communication_fd < 0) {
                                  goto LABEL_476;
                                }
                                if (!RNBSocket::useFD((RNBSocket *)(v25 + 472), communication_fd))
                                {
LABEL_475:
                                  RNBRemote::StartReadRemoteDataThread((RNBRemote *)v25);
                                  goto LABEL_476;
                                }
                              }
                            }

                            else
                            {
                              if ((v409.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                                v272 = &v409;
                              }
                              else {
                                v272 = (std::string *)v409.__r_.__value_.__r.__words[0];
                              }
                              if (v411 >= 0) {
                                v273 = v410;
                              }
                              else {
                                v273 = (void **)v410[0];
                              }
                              if (v413 >= 0) {
                                v274 = v412;
                              }
                              else {
                                v274 = (void **)v412[0];
                              }
                              if (ConnectRemote( (RNBRemote *)v25,  (char *)v272,  v408,  v404 & 1,  (const char *)v273,  (const char *)v274,  v237,  v238))
                              {
LABEL_476:
                                if (g_isatty) {
                                  fwrite( "Got a connection, waiting for process information for launching or attaching.\n",  0x4EuLL,  1uLL,  __stdoutp);
                                }
                                else {
                                  _DNBLog( 0LL,  (uint64_t)"Got a connection, waiting for process information for launching or attaching.\n",  v233,  v234,  v235,  v236,  v237,  v238,  (uint64_t)v390);
                                }
                                int StartModeFromRemote = RNBRunLoopGetStartModeFromRemote((RNBRemote *)v25);
                              }
                            }
                          }

                          continue;
                        case 1:
                          uint64_t v254 = HIBYTE(v423);
                          if (v423 < 0) {
                            uint64_t v254 = v422;
                          }
                          if (v254)
                          {
                            if (v400)
                            {
                              gettimeofday((timeval *)&__p, 0LL);
                              v405.__r_.__value_.__r.__words[0] = __p.__r_.__value_.__r.__words[0]
                                                                + v400
                                                                + SLODWORD(__p.__r_.__value_.__r.__words[1]) / 1000000;
                              v405.__r_.__value_.__l.__size_ = 1000 * LODWORD(__p.__r_.__value_.__r.__words[1])
                                                             % 1000000000;
                              v255 = (timespec *)&v405;
                            }

                            else
                            {
                              v255 = 0LL;
                            }

                            int v259 = g_launch_flavor;
                            if (!g_launch_flavor)
                            {
                              if (v423 >= 0) {
                                v260 = (const char *)&v421;
                              }
                              else {
                                v260 = (const char *)v421;
                              }
                              size_t v261 = strlen(v260);
                              if (v261 >= 4
                                && v260[v261 - 4] == 46
                                && v260[v261 - 3] == 97
                                && v260[v261 - 2] == 112
                                && v260[v261 - 1] == 112)
                              {
                                int v259 = 5;
                              }

                              else
                              {
                                int v259 = 1;
                              }
                            }

                            *(_DWORD *)(v25 + 304) = v259;
                            if (g_isatty)
                            {
                              if (v423 >= 0) {
                                v262 = (const char *)&v421;
                              }
                              else {
                                v262 = (const char *)v421;
                              }
                              fprintf(__stdoutp, "Waiting to attach to process %s...\n", v262);
                            }

                            else
                            {
                              if (v423 >= 0) {
                                v263 = &v421;
                              }
                              else {
                                v263 = v421;
                              }
                              _DNBLog( 0LL,  (uint64_t)"Waiting to attach to process %s...\n",  v233,  v234,  v235,  v236,  v237,  v238,  (uint64_t)v263);
                            }

                            if (v423 >= 0) {
                              v264 = (char *)&v421;
                            }
                            else {
                              v264 = (char *)v421;
                            }
                            int v265 = DNBProcessAttachWait( (RNBContext *)v25,  v264,  0,  v255,  v398,  (char *)__dst,  0x400uLL,  0LL,  0LL);
                            goto LABEL_356;
                          }

                          if ((_DWORD)v399)
                          {
                            if (g_isatty) {
                              fprintf(__stdoutp, "Attaching to process %i...\n", v399);
                            }
                            else {
                              _DNBLog( 0LL,  (uint64_t)"Attaching to process %i...\n",  v233,  v234,  v235,  v236,  v237,  v238,  v399);
                            }
                            LODWORD(__p.__r_.__value_.__l.__data_) = 0;
                            if (RNBRunLoopLaunchAttaching((RNBRemote *)v25, v399, (int *)&__p) != 4)
                            {
                              DNBError::AsString((DNBError *)v397);
                              if (g_isatty) {
                                fprintf(__stderrp, "error: failed to attach process %i: %s\n");
                              }
                              else {
                                _DNBLog( 0LL,  (uint64_t)"error: failed to attach process %i: %s\n",  v316,  v317,  v318,  v319,  v320,  v321,  v399);
                              }
LABEL_450:
                              int v315 = 6;
                              goto LABEL_451;
                            }

                            goto LABEL_447;
                          }

                          std::string::size_type v289 = v420.__r_.__value_.__s.__size_;
                          if ((v420.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                            std::string::size_type v289 = v420.__r_.__value_.__l.__size_;
                          }
                          if (v289)
                          {
                            if (v400)
                            {
                              gettimeofday((timeval *)&__p, 0LL);
                              v405.__r_.__value_.__r.__words[0] = __p.__r_.__value_.__r.__words[0]
                                                                + v400
                                                                + SLODWORD(__p.__r_.__value_.__r.__words[1]) / 1000000;
                              v405.__r_.__value_.__l.__size_ = 1000 * LODWORD(__p.__r_.__value_.__r.__words[1])
                                                             % 1000000000;
                              v290 = (const timespec *)&v405;
                            }

                            else
                            {
                              v290 = 0LL;
                            }

                            if (g_isatty)
                            {
                              if ((v420.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                                v325 = &v420;
                              }
                              else {
                                v325 = (std::string *)v420.__r_.__value_.__r.__words[0];
                              }
                              fprintf(__stdoutp, "Attaching to process %s...\n", (const char *)v325);
                            }

                            else
                            {
                              if ((v420.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                                v326 = &v420;
                              }
                              else {
                                v326 = (std::string *)v420.__r_.__value_.__r.__words[0];
                              }
                              _DNBLog( 0LL,  (uint64_t)"Attaching to process %s...\n",  v233,  v234,  v235,  v236,  v237,  v238,  (uint64_t)v326);
                            }

                            if ((v420.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                              v327 = &v420;
                            }
                            else {
                              v327 = (std::string *)v420.__r_.__value_.__r.__words[0];
                            }
                            int v265 = DNBProcessAttachByName( (char *)v327,  v290,  (int8x16_t **)(v25 + 448),  (char *)__dst,  0x400uLL);
LABEL_356:
                            g_pid = v265;
                            if (!v265)
                            {
                              *(void *)(v25 + 312) = 0xFFFFFFFFLL;
                              if (*(char *)(v25 + 343) < 0)
                              {
                                **(_BYTE **)(v25 + 320) = 0;
                                *(void *)(v25 + 328) = 0LL;
                                if (__dst[0].__r_.__value_.__s.__data_[0]) {
LABEL_360:
                                }
                                  std::string::assign( (std::string *)(v25 + 320),  (const std::string::value_type *)__dst);
                              }

                              else
                              {
                                *(_BYTE *)(v25 + 320) = 0;
                                *(_BYTE *)(v25 + 343) = 0;
                                if (__dst[0].__r_.__value_.__s.__data_[0]) {
                                  goto LABEL_360;
                                }
                              }

                              if (g_isatty)
                              {
                                fprintf(__stderrp, "error: failed to attach to process named: %s %s\n");
                              }

                              else
                              {
                                if (v423 >= 0) {
                                  v298 = &v421;
                                }
                                else {
                                  v298 = v421;
                                }
                                _DNBLog( 0LL,  (uint64_t)"error: failed to attach to process named: %s %s\n",  v266,  v267,  v268,  v269,  v270,  v271,  (uint64_t)v298);
                              }

                              goto LABEL_450;
                            }

                            RNBContext::SetProcessID((RNBContext *)v25, v265);
LABEL_447:
                            int v315 = 4;
LABEL_451:
                            int StartModeFromRemote = 6;
                            if (v315 != 6)
                            {
                              uint64_t v233 = v408;
                              if (v408 == 0x7FFFFFFF)
                              {
                                if (LOBYTE(v431[0]) == 47)
                                {
                                }

                                else
                                {
                                  if (communication_fd < 0) {
                                    goto LABEL_470;
                                  }
                                  if (!RNBSocket::useFD((RNBSocket *)(v25 + 472), communication_fd))
                                  {
                                    RNBRemote::StartReadRemoteDataThread((RNBRemote *)v25);
                                    goto LABEL_470;
                                  }
                                }
                              }

                              else
                              {
                                if ((v409.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                                  v322 = &v409;
                                }
                                else {
                                  v322 = (std::string *)v409.__r_.__value_.__r.__words[0];
                                }
                                if (v411 >= 0) {
                                  v323 = v410;
                                }
                                else {
                                  v323 = (void **)v410[0];
                                }
                                if (v413 >= 0) {
                                  v324 = v412;
                                }
                                else {
                                  v324 = (void **)v412[0];
                                }
                                if (ConnectRemote( (RNBRemote *)v25,  (char *)v322,  v408,  v404 & 1,  (const char *)v323,  (const char *)v324,  v237,  v238))
                                {
LABEL_470:
                                  if (g_isatty) {
                                    fprintf(__stdoutp, "Waiting for debugger instructions for process %d.\n", v399);
                                  }
                                  else {
                                    _DNBLog( 0LL,  (uint64_t)"Waiting for debugger instructions for process %d.\n",  v233,  v234,  v235,  v236,  v237,  v238,  v399);
                                  }
                                  int StartModeFromRemote = v315;
                                }
                              }
                            }
                          }

                          else if (g_isatty)
                          {
                            v246 = __stderrp;
                            v247 = "error: asked to attach with empty name and invalid PID.\n";
                            size_t v248 = 56LL;
LABEL_482:
                            fwrite(v247, v248, 1uLL, v246);
                          }

                          else
                          {
                            _DNBLog( 0LL,  (uint64_t)"error: asked to attach with empty name and invalid PID.\n",  v233,  v234,  v235,  v236,  v237,  v238,  (uint64_t)v390);
                          }

                          continue;
                        case 2:
                          if (*(char *)(v25 + 39) < 0)
                          {
                            if (*(void *)(v25 + 24))
                            {
                              v249 = *(char **)(v25 + 16);
                              int v250 = *(char *)(v25 + 63);
                              if ((v250 & 0x80000000) == 0) {
                                goto LABEL_291;
                              }
                            }

                            else
                            {
                              v249 = 0LL;
                              int v250 = *(char *)(v25 + 63);
                              if ((v250 & 0x80000000) == 0) {
                                goto LABEL_291;
                              }
                            }
                          }

                          else
                          {
                            if (*(_BYTE *)(v25 + 39)) {
                              v249 = (char *)(v25 + 16);
                            }
                            else {
                              v249 = 0LL;
                            }
                            int v250 = *(char *)(v25 + 63);
                            if ((v250 & 0x80000000) == 0)
                            {
LABEL_291:
                              if (v250) {
                                v251 = (char *)(v25 + 40);
                              }
                              else {
                                v251 = 0LL;
                              }
                              int v252 = *(char *)(v25 + 87);
                              if (v252 < 0)
                              {
LABEL_318:
                                if (*(void *)(v25 + 72)) {
                                  v253 = *(char **)(v25 + 64);
                                }
                                else {
                                  v253 = 0LL;
                                }
                                goto LABEL_379;
                              }

                              goto LABEL_295;
                            }
                          }

                          if (*(void *)(v25 + 48))
                          {
                            v251 = *(char **)(v25 + 40);
                            int v252 = *(char *)(v25 + 87);
                            if (v252 < 0) {
                              goto LABEL_318;
                            }
                          }

                          else
                          {
                            v251 = 0LL;
                            int v252 = *(char *)(v25 + 87);
                            if (v252 < 0) {
                              goto LABEL_318;
                            }
                          }

LABEL_295:
                          if (v252) {
                            v253 = (char *)(v25 + 64);
                          }
                          else {
                            v253 = 0LL;
                          }
LABEL_379:
                          int v275 = RNBRunLoopLaunchInferior((RNBRemote *)v25, v249, v251, v253, v393 & 1);
                          if (v275 == 4)
                          {
                            if (v408 == 0x7FFFFFFF)
                            {
                              if (LOBYTE(v431[0]) == 47)
                              {
                              }

                              else
                              {
                                if (communication_fd < 0) {
                                  goto LABEL_409;
                                }
                                if (!RNBSocket::useFD((RNBSocket *)(v25 + 472), communication_fd))
                                {
                                  RNBRemote::StartReadRemoteDataThread((RNBRemote *)v25);
                                  goto LABEL_409;
                                }
                              }
                            }

                            else
                            {
                              if ((v409.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                                v286 = &v409;
                              }
                              else {
                                v286 = (std::string *)v409.__r_.__value_.__r.__words[0];
                              }
                              if (v411 >= 0) {
                                v287 = v410;
                              }
                              else {
                                v287 = (void **)v410[0];
                              }
                              if (v413 >= 0) {
                                v288 = v412;
                              }
                              else {
                                v288 = (void **)v412[0];
                              }
                              if (ConnectRemote( (RNBRemote *)v25,  (char *)v286,  v408,  v404 & 1,  (const char *)v287,  (const char *)v288,  v276,  v277))
                              {
LABEL_409:
                                if (*(void *)(v25 + 352) != *(void *)(v25 + 344))
                                {
                                  v291 = RNBContext::ArgumentAtIndex((RNBContext *)v25, 0LL);
                                  if (!DNBLogEnabled()) {
                                    goto LABEL_412;
                                  }
LABEL_411:
                                  _DNBLog( 0LL,  (uint64_t)"[LaunchAttach] Successfully launched %s (pid = %d).\n",  v292,  v293,  v294,  v295,  v296,  v297,  (uint64_t)v291);
                                  goto LABEL_412;
                                }

                                v291 = "<unknown>";
                                if (DNBLogEnabled()) {
                                  goto LABEL_411;
                                }
LABEL_412:
                                if (g_isatty) {
                                  fprintf( __stdoutp,  "Got a connection, launched process %s (pid = %d).\n",  v291,  *(_DWORD *)(v25 + 12));
                                }
                                else {
                                  _DNBLog( 0LL,  (uint64_t)"Got a connection, launched process %s (pid = %d).\n",  v292,  v293,  v294,  v295,  v296,  v297,  (uint64_t)v291);
                                }
                                int StartModeFromRemote = 4;
                              }
                            }
                          }

                          else
                          {
                            int StartModeFromRemote = v275;
                            uint64_t v278 = DNBError::AsString((DNBError *)v397);
                            if (g_isatty)
                            {
                              if (v278) {
                                v285 = (const char *)v278;
                              }
                              else {
                                v285 = "unknown error.";
                              }
                              fprintf(__stderrp, "error: failed to launch process %s: %s\n", v396, v285);
                            }

                            else
                            {
                              _DNBLog( 0LL,  (uint64_t)"error: failed to launch process %s: %s\n",  v279,  v280,  v281,  v282,  v283,  v284,  (uint64_t)v396);
                            }
                          }

                          continue;
                        case 3:
                          int StartModeFromRemote = RNBRunLoopInferiorExecuting((RNBRemote *)v25);
                          continue;
                        case 4:
                          if (v408 == 0x7FFFFFFF)
                          {
                            if (LOBYTE(v431[0]) == 47)
                            {
                            }

                            else
                            {
                              if (communication_fd < 0) {
                                goto LABEL_330;
                              }
                              if (!RNBSocket::useFD((RNBSocket *)(v25 + 472), communication_fd))
                              {
                                RNBRemote::StartReadRemoteDataThread((RNBRemote *)v25);
                                goto LABEL_330;
                              }
                            }
                          }

                          else
                          {
                            if ((v409.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                              v256 = &v409;
                            }
                            else {
                              v256 = (std::string *)v409.__r_.__value_.__r.__words[0];
                            }
                            if (v411 >= 0) {
                              v257 = v410;
                            }
                            else {
                              v257 = (void **)v410[0];
                            }
                            if (v413 >= 0) {
                              v258 = v412;
                            }
                            else {
                              v258 = (void **)v412[0];
                            }
                            if (ConnectRemote( (RNBRemote *)v25,  (char *)v256,  v408,  v404 & 1,  (const char *)v257,  (const char *)v258,  v237,  v238))
                            {
LABEL_330:
                              RNBRunLoopPlatform((RNBRemote *)v25);
                            }
                          }

                          break;
                        case 5:
                          RNBRemote::StopReadRemoteDataThread((RNBRemote *)v25);
                          RNBContext::SetProcessID((RNBContext *)v25, 0);
                          if (g_isatty) {
                            fwrite("Exiting.\n", 9uLL, 1uLL, __stdoutp);
                          }
                          else {
                            _DNBLog(0LL, (uint64_t)"Exiting.\n", v328, v329, v330, v331, v332, v333, (uint64_t)v390);
                          }
                          int v39 = 0;
                          goto LABEL_503;
                        default:
                          continue;
                      }
                    }
                  }

LABEL_271:
                  v229 = _NSGetEnviron();
                  v230 = **v229;
                  if (v230)
                  {
                    v231 = (const char **)(*v229 + 1);
                    do
                    {
                      RNBContext::PushEnvironmentIfNeeded((RNBContext *)v25, v230);
                      v232 = *v231++;
                      v230 = v232;
                    }

                    while (v232);
                  }

                  goto LABEL_274;
                }

                if (!g_applist_opt) {
                  goto LABEL_265;
                }
                if (DNBLogEnabled()) {
                  _DNBLog( 0LL,  (uint64_t)"debugserver running in --applist mode",  v335,  v336,  v337,  v338,  v339,  v340,  (uint64_t)v390);
                }
                memset(__dst, 0, 24);
                uint64_t v341 = ListApplications(__dst, 0LL, 0LL);
                int v39 = v341;
                if ((_DWORD)v341)
                {
                  if (g_isatty) {
                    fprintf(__stderrp, "error: ListApplications returned error %i\n", v341);
                  }
                  else {
                    _DNBLog( 0LL,  (uint64_t)"error: ListApplications returned error %i\n",  v342,  v343,  v344,  v345,  v346,  v347,  v341);
                  }
                }

                else
                {
                  if ((__dst[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
                    v348 = __dst;
                  }
                  else {
                    v348 = (std::string *)__dst[0].__r_.__value_.__r.__words[0];
                  }
                  fputs((const char *)v348, __stdoutp);
                }

LABEL_503:
                if ((char)v409.__r_.__value_.__s.__size_ < 0)
                {
                  operator delete(v409.__r_.__value_.__l.__data_);
                  if ((SHIBYTE(v411) & 0x80000000) == 0)
                  {
LABEL_505:
                    if ((SHIBYTE(v413) & 0x80000000) == 0) {
                      goto LABEL_506;
                    }
                    goto LABEL_514;
                  }
                }

                else if ((SHIBYTE(v411) & 0x80000000) == 0)
                {
                  goto LABEL_505;
                }

                operator delete(v410[0]);
                if ((SHIBYTE(v413) & 0x80000000) == 0)
                {
LABEL_506:
                  if ((SHIBYTE(v416) & 0x80000000) == 0) {
                    goto LABEL_507;
                  }
                  goto LABEL_515;
                }

LABEL_514:
                operator delete(v412[0]);
                if ((SHIBYTE(v416) & 0x80000000) == 0)
                {
LABEL_507:
                  if ((SHIBYTE(v419) & 0x80000000) == 0) {
                    goto LABEL_508;
                  }
                  goto LABEL_516;
                }

LABEL_515:
                operator delete(v414);
                if ((SHIBYTE(v419) & 0x80000000) == 0)
                {
LABEL_508:
                  goto LABEL_517;
                }

LABEL_516:
                operator delete(v417);
                if (((char)v420.__r_.__value_.__s.__size_ & 0x80000000) == 0)
                {
LABEL_509:
                  if ((SHIBYTE(v423) & 0x80000000) == 0) {
                    goto LABEL_510;
                  }
                  goto LABEL_518;
                }

LABEL_517:
                operator delete(v420.__r_.__value_.__l.__data_);
                if ((SHIBYTE(v423) & 0x80000000) == 0)
                {
LABEL_510:
                  if ((SHIBYTE(v425) & 0x80000000) == 0) {
                    return v39;
                  }
LABEL_519:
                  operator delete(v424[0]);
                  return v39;
                }

LABEL_518:
                operator delete(v421);
                if ((SHIBYTE(v425) & 0x80000000) == 0) {
                  return v39;
                }
                goto LABEL_519;
              }

LABEL_252:
              if (StartModeFromRemote == 2) {
                goto LABEL_268;
              }
              goto LABEL_253;
            }

            v194 = *v125;
            if (**v125 == 47)
            {
              int v408 = 0x7FFFFFFF;
              strlcpy((char *)v431, v194, 0x400uLL);
              goto LABEL_251;
            }

            goto LABEL_546;
          }

          std::string::size_type v165 = v164;
          std::string::size_type v166 = __dst[0].__r_.__value_.__s.__size_;
          if ((__dst[0].__r_.__value_.__s.__size_ & 0x80u) == 0)
          {
            v167 = __dst;
          }

          else
          {
            std::string::size_type v166 = __dst[0].__r_.__value_.__l.__size_;
            v167 = (std::string *)__dst[0].__r_.__value_.__r.__words[0];
          }

          if (v166 >= v164) {
            std::string::size_type v168 = v164;
          }
          else {
            std::string::size_type v168 = v166;
          }
          if (v168 > 0x7FFFFFFFFFFFFFF7LL) {
            goto LABEL_533;
          }
          if (v168 >= 0x17)
          {
            uint64_t v184 = (v168 & 0xFFFFFFFFFFFFFFF8LL) + 8;
            if ((v168 | 7) != 0x17) {
              uint64_t v184 = v168 | 7;
            }
            uint64_t v185 = v184 + 1;
            v169 = (std::string *)operator new(v184 + 1);
            __p.__r_.__value_.__l.__size_ = v168;
            __p.__r_.__value_.__l.__cap_ = v185 | 0x8000000000000000LL;
            __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v169;
          }

          else
          {
            __p.__r_.__value_.__s.__size_ = v168;
            v169 = &__p;
            if (!v168)
            {
LABEL_195:
              v169->__r_.__value_.__s.__data_[v168] = 0;
              std::string v409 = __p;
              if ((char)__dst[0].__r_.__value_.__s.__size_ < 0)
              {
                std::string::size_type v186 = __dst[0].__r_.__value_.__l.__size_;
                if (__dst[0].__r_.__value_.__l.__size_ <= v165) {
                  goto LABEL_533;
                }
                v187 = (std::string *)__dst[0].__r_.__value_.__r.__words[0];
              }

              else
              {
                std::string::size_type v186 = __dst[0].__r_.__value_.__s.__size_;
                if (v165 >= __dst[0].__r_.__value_.__s.__size_) {
                  goto LABEL_533;
                }
                v187 = __dst;
              }

              std::string::size_type v188 = v165 + 1;
              std::string::size_type v189 = v186 - (v165 + 1);
              if (v189 > 0x7FFFFFFFFFFFFFF7LL) {
LABEL_533:
              }
                abort();
              if (v189 >= 0x17)
              {
                uint64_t v191 = (v189 & 0xFFFFFFFFFFFFFFF8LL) + 8;
                if ((v189 | 7) != 0x17) {
                  uint64_t v191 = v189 | 7;
                }
                uint64_t v192 = v191 + 1;
                v190 = (std::string *)operator new(v191 + 1);
                __p.__r_.__value_.__l.__size_ = v189;
                __p.__r_.__value_.__l.__cap_ = v192 | 0x8000000000000000LL;
                __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v190;
              }

              else
              {
                __p.__r_.__value_.__s.__size_ = v189;
                v190 = &__p;
                if (v186 == v188)
                {
LABEL_210:
                  v190->__r_.__value_.__s.__data_[v189] = 0;
                  __endptr = 0LL;
                  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                    v193 = &__p;
                  }
                  else {
                    v193 = (std::string *)__p.__r_.__value_.__r.__words[0];
                  }
                  int v408 = strtoul((const char *)v193, &__endptr, 0);
                  std::string::size_type v195 = __p.__r_.__value_.__s.__size_;
                  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                    v196 = &__p;
                  }
                  else {
                    v196 = (std::string *)__p.__r_.__value_.__r.__words[0];
                  }
                  if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                    std::string::size_type v195 = __p.__r_.__value_.__l.__size_;
                  }
                  if (__endptr >= (char *)v196 + v195)
                  {
                    if ((char)v409.__r_.__value_.__s.__size_ < 0)
                    {
                      if (*v409.__r_.__value_.__l.__data_ == 91)
                      {
                        std::string::size_type v197 = v409.__r_.__value_.__l.__size_;
                        if (*(_BYTE *)(v409.__r_.__value_.__r.__words[0] + v409.__r_.__value_.__l.__size_ - 1) == 93)
                        {
                          if (!v409.__r_.__value_.__l.__size_) {
                            goto LABEL_533;
                          }
                          v198 = (std::string::value_type *)(v409.__r_.__value_.__r.__words[0] + 1);
                          goto LABEL_228;
                        }
                      }
                    }

                    else if (v409.__r_.__value_.__s.__data_[0] == 91)
                    {
                      std::string::size_type v197 = v409.__r_.__value_.__s.__size_;
                      if (v409.__r_.__value_.__s.__data_[v409.__r_.__value_.__s.__size_ - 1] == 93)
                      {
                        if (!v409.__r_.__value_.__s.__size_) {
                          goto LABEL_533;
                        }
                        v198 = &v409.__r_.__value_.__s.__data_[1];
LABEL_228:
                        std::string::size_type v199 = v197 - 2;
                        std::string::size_type v200 = v197 - 1;
                        if (v200 >= v199) {
                          std::string::size_type v201 = v199;
                        }
                        else {
                          std::string::size_type v201 = v200;
                        }
                        if (v201 <= 0x7FFFFFFFFFFFFFF7LL)
                        {
                          if (v201 >= 0x17)
                          {
                            uint64_t v203 = (v201 & 0xFFFFFFFFFFFFFFF8LL) + 8;
                            if ((v201 | 7) != 0x17) {
                              uint64_t v203 = v201 | 7;
                            }
                            uint64_t v204 = v203 + 1;
                            v202 = (std::string *)operator new(v203 + 1);
                            v405.__r_.__value_.__l.__size_ = v201;
                            v405.__r_.__value_.__l.__cap_ = v204 | 0x8000000000000000LL;
                            v405.__r_.__value_.__r.__words[0] = (std::string::size_type)v202;
                          }

                          else
                          {
                            v405.__r_.__value_.__s.__size_ = v201;
                            v202 = &v405;
                            if (!v201) {
                              goto LABEL_242;
                            }
                          }

                          memmove(v202, v198, v201);
LABEL_242:
                          v202->__r_.__value_.__s.__data_[v201] = 0;
                          std::string v409 = v405;
                          goto LABEL_245;
                        }

                        goto LABEL_533;
                      }
                    }

LABEL_245:
                    if (DNBLogEnabled())
                    {
                      v212 = &v409;
                      if ((v409.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                        v212 = (std::string *)v409.__r_.__value_.__r.__words[0];
                      }
                      _DNBLogDebug( (uint64_t)"host = '%s'  port = %i",  v205,  v206,  v207,  v208,  v209,  v210,  v211,  (uint64_t)v212);
                    }

                    goto LABEL_251;
                  }

LABEL_546:
                  show_usage_and_exit(2, (uint64_t)v194, v170, v171, v172, v173, v174, v175);
                }
              }

              memmove(v190, (char *)v187 + v188, v189);
              goto LABEL_210;
            }
          }

          memmove(v169, v167, v168);
          goto LABEL_195;
        }
      }

      memmove(v161, v158, v160);
      goto LABEL_174;
    }

    if (g_isatty)
    {
      uint64_t v36 = __stderrp;
      uint64_t v37 = "error: failed to create a remote connection class\n";
      size_t v38 = 50LL;
      goto LABEL_31;
    }

    v40 = "error: failed to create a remote connection class\n";
LABEL_33:
    _DNBLog(0LL, (uint64_t)v40, v18, v19, v20, v21, v22, v23, (uint64_t)v389);
    return -1;
  }

  if (!g_isatty)
  {
    v40 = "error: Developer mode must be enabled to use debugserver.\n";
    goto LABEL_33;
  }

  uint64_t v36 = __stderrp;
  uint64_t v37 = "error: Developer mode must be enabled to use debugserver.\n";
  size_t v38 = 58LL;
LABEL_31:
  fwrite(v37, v38, 1uLL, v36);
  return -1;
}

void RNBContext::PushEnvironment(RNBContext *this, const char *__s)
{
  if (__s)
  {
    size_t v4 = strlen(__s);
    if (v4 >= 0x7FFFFFFFFFFFFFF8LL) {
      abort();
    }
    size_t v5 = v4;
    if (v4 >= 0x17)
    {
      uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8LL) + 8;
      if ((v4 | 7) != 0x17) {
        uint64_t v7 = v4 | 7;
      }
      uint64_t v8 = v7 + 1;
      p_dst = (__int128 *)operator new(v7 + 1);
      *((void *)&__dst + 1) = v5;
      unint64_t v14 = v8 | 0x8000000000000000LL;
      *(void *)&__int128 __dst = p_dst;
    }

    else
    {
      HIBYTE(v14) = v4;
      p_dst = &__dst;
      if (!v4)
      {
LABEL_10:
        *((_BYTE *)p_dst + v5) = 0;
        unint64_t v9 = *((void *)this + 47);
        if (v9 >= *((void *)this + 48))
        {
          uint64_t v11 = std::vector<std::string>::__push_back_slow_path<std::string>((void **)this + 46, (uint64_t)&__dst);
          int v12 = SHIBYTE(v14);
          *((void *)this + 47) = v11;
          if (v12 < 0) {
            operator delete((void *)__dst);
          }
        }

        else
        {
          __int128 v10 = __dst;
          *(void *)(v9 + 16) = v14;
          *(_OWORD *)unint64_t v9 = v10;
          *((void *)this + 47) = v9 + 24;
        }

        return;
      }
    }

    memcpy(p_dst, __s, v5);
    goto LABEL_10;
  }

void RNBContext::PushArgument(RNBContext *this, const char *__s)
{
  if (__s)
  {
    size_t v4 = strlen(__s);
    if (v4 >= 0x7FFFFFFFFFFFFFF8LL) {
      abort();
    }
    size_t v5 = v4;
    if (v4 >= 0x17)
    {
      uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8LL) + 8;
      if ((v4 | 7) != 0x17) {
        uint64_t v7 = v4 | 7;
      }
      uint64_t v8 = v7 + 1;
      p_dst = (__int128 *)operator new(v7 + 1);
      *((void *)&__dst + 1) = v5;
      unint64_t v14 = v8 | 0x8000000000000000LL;
      *(void *)&__int128 __dst = p_dst;
    }

    else
    {
      HIBYTE(v14) = v4;
      p_dst = &__dst;
      if (!v4)
      {
LABEL_10:
        *((_BYTE *)p_dst + v5) = 0;
        unint64_t v9 = *((void *)this + 44);
        if (v9 >= *((void *)this + 45))
        {
          uint64_t v11 = std::vector<std::string>::__push_back_slow_path<std::string>((void **)this + 43, (uint64_t)&__dst);
          int v12 = SHIBYTE(v14);
          *((void *)this + 44) = v11;
          if (v12 < 0) {
            operator delete((void *)__dst);
          }
        }

        else
        {
          __int128 v10 = __dst;
          *(void *)(v9 + 16) = v14;
          *(_OWORD *)unint64_t v9 = v10;
          *((void *)this + 44) = v9 + 24;
        }

        return;
      }
    }

    memcpy(p_dst, __s, v5);
    goto LABEL_10;
  }

BOOL ConnectRemote( RNBRemote *a1, char *a2, uint64_t a3, uint64_t a4, const char *a5, const char *a6, uint64_t a7, uint64_t a8)
{
  if (*((_DWORD *)a1 + 118) != -1) {
    return 1LL;
  }
  unsigned __int16 v9 = a3;
  int v12 = (RNBRemote *)((char *)a1 + 472);
  if (!(_DWORD)a4)
  {
    if ((_DWORD)a3)
    {
      if (!g_isatty)
      {
        _DNBLog( 0LL,  (uint64_t)"Listening to port %i for a connection from %s...\n",  a3,  a4,  (uint64_t)a5,  (uint64_t)a6,  a7,  a8,  a3);
        if (!a6) {
          goto LABEL_22;
        }
        goto LABEL_15;
      }

      uint64_t v15 = "127.0.0.1";
      if (a2) {
        uint64_t v15 = a2;
      }
      fprintf(__stdoutp, "Listening to port %i for a connection from %s...\n", a3, v15);
    }

    if (!a6) {
      goto LABEL_22;
    }
LABEL_15:
    if (*a6)
    {
      if (!RNBSocket::Listen( v12,  a2,  v9,  (void (*)(const void *, unsigned __int16))PortWasBoundCallbackUnixSocket,  a6)) {
        goto LABEL_17;
      }
LABEL_23:
      if (g_isatty) {
        fwrite("Failed to get connection from a remote gdb process.\n", 0x34uLL, 1uLL, __stderrp);
      }
      else {
        _DNBLog( 0LL,  (uint64_t)"Failed to get connection from a remote gdb process.\n",  v16,  v17,  v18,  v19,  v20,  v21,  v22);
      }
      return 0LL;
    }

LABEL_22:
    if (!RNBSocket::Listen( v12,  a2,  v9,  (void (*)(const void *, unsigned __int16))PortWasBoundCallbackNamedPipe,  a5)) {
      goto LABEL_17;
    }
    goto LABEL_23;
  }

  if ((_DWORD)a3)
  {
    if (RNBSocket::Connect( (RNBRemote *)((char *)a1 + 472),  (lldb_private::SocketAddress *)a2,  (unsigned __int16)a3))
    {
      BOOL result = DNBLogEnabled();
      if (result)
      {
        _DNBLogThreaded("Failed to reverse connect to %s:%i.\n");
        return 0LL;
      }

      return result;
    }

  const char *v15 = &v9[v14];
  return result;
}

  int v34 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v55, (uint64_t)"ptrsize:", 8LL);
  *(_DWORD *)((char *)v34 + *(void *)(*v34 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v34 + *(void *)(*v34 - 24LL) + 8) & 0xFFFFFFB5 | 2;
  int v35 = (void *)std::ostream::operator<<(v34, v28);
  v58.__r_.__value_.__s.__data_[0] = 59;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v35, (uint64_t)&v58, 1LL);
  if ((_DWORD)CPUType == 12 || (_DWORD)CPUType == 33554444 || (_DWORD)CPUType == 16777228)
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v55, (uint64_t)"ostype:tvos;", 12LL);
    int v3 = v45;
  }

  else
  {
    int v3 = v45;
    if ((CPUType & 0xFEFFFFFF) == 7)
    {
      uint64_t v59 = 0x3100000001LL;
      uint64_t v60 = v6;
      uint64_t v49 = 0x2000LL;
      if (!sysctl((int *)&v59, 3u, &v58, &v49, 0LL, 0LL))
      {
        DNBDataRef::DNBDataRef((DNBDataRef *)&v47, (const unsigned __int8 *)&v58, v49, 0);
        v46 = 0;
        uint64_t v36 = DNBDataRef::Get32((DNBDataRef *)&v47, &v46);
        if (DNBDataRef::GetCStr((DNBDataRef *)&v47, &v46, 0))
        {
          if (v47)
          {
            uint64_t v37 = v46;
            if (v48 - v47 > (unint64_t)v46)
            {
              size_t v38 = v46 + 1;
              do
              {
                if (*(_BYTE *)(v47 + v37)) {
                  break;
                }
                v46 = v38;
                uint64_t v37 = v38++;
              }

              while (v48 - v47 > v37);
            }
          }

          for (; v36; --v36)
            DNBDataRef::GetCStr((DNBDataRef *)&v47, &v46, 0);
          do
          {
            CStr = (const char *)DNBDataRef::GetCStr((DNBDataRef *)&v47, &v46, 0);
            if (!CStr) {
              break;
            }
            v40 = CStr;
            if (!strncmp(CStr, "SIMULATOR_UDID=", 0xFuLL))
            {
              DNBDataRef::~DNBDataRef((DNBDataRef *)&v47);
              uint64_t v41 = "ostype:tvos;";
              uint64_t v42 = 12LL;
              goto LABEL_41;
            }
          }

          while (*v40);
        }

        DNBDataRef::~DNBDataRef((DNBDataRef *)&v47);
      }
    }

    uint64_t v41 = "ostype:macosx;";
    uint64_t v42 = 14LL;
LABEL_41:
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v55, (uint64_t)v41, v42);
  }

  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v55, (uint64_t)"vendor:apple;", 13LL);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v55, (uint64_t)"endian:little;", 14LL);
  std::stringbuf::str(&v58, &v56);
LABEL_43:
  int v43 = RNBRemote::SendPacket((uint64_t)this, &v58);
  std::streambuf::~streambuf(&v56);
  std::ios::~ios(v3);
  return v43;
}

  *(void *)size_t v4 = *a2;
  a1[2] += 8;
}

  const char *v15 = &v9[v14];
  return result;
}

  if (SHIBYTE(v10) < 0) {
    operator delete(__p[1]);
  }
  return v4 != 0;
}

LABEL_17:
    RNBRemote::StartReadRemoteDataThread(a1);
    return 1LL;
  }

  BOOL result = DNBLogEnabled();
  if (result)
  {
    _DNBLogThreaded("error: invalid port supplied for reverse connection: %i.\n");
    return 0LL;
  }

  return result;
}

  size_t v5 = (void **)this[47];
  int v6 = v3;
  if (v5 != v3)
  {
    do
    {
      v5 -= 3;
    }

    while (v5 != v3);
    int v6 = (void **)this[46];
  }

  this[47] = v3;
  operator delete(v6);
  size_t v4 = (void **)this[43];
  if (!v4)
  {
LABEL_9:
    goto LABEL_35;
  }

  std::string::append(this, "proc_profile_data ");
  if ((a2 & 0x20) == 0)
  {
LABEL_9:
    if ((a2 & 0x40) == 0) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }

      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        uint64_t v13 = __ldaxr(p_shared_owners);
      while (__stlxr(v13 - 1, p_shared_owners));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
        if (!v10) {
          goto LABEL_24;
        }
        goto LABEL_21;
      }

      goto LABEL_20;
    }

    uint64_t v8 = 1;
    goto LABEL_11;
  }

      v7.__r_.__value_.__s.__size_ = 2;
      strcpy((char *)&v7, "OK");
      goto LABEL_18;
  }

  v7.__r_.__value_.__s.__size_ = 3;
  LODWORD(v7.__r_.__value_.__l.__data_) = 3618117;
LABEL_18:
  int v3 = RNBRemote::SendPacket((uint64_t)this, &v7);
  StdStringExtractor::~StdStringExtractor((void **)&__p.__r_.__value_.__l.__data_);
  return v3;
}

  if ((size & 0x80u) == 0) {
    uint64_t v13 = __str;
  }
  else {
    uint64_t v13 = (std::string *)__str->__r_.__value_.__r.__words[0];
  }
  unint64_t v14 = v13->__r_.__value_.__s.__data_[0];
  if (v14 < 0)
  {
    if (__maskrune(v14, 0x100uLL)) {
      goto LABEL_28;
    }
  }

  else if ((_DefaultRuneLocale.__runetype[v14] & 0x100) != 0)
  {
    goto LABEL_28;
  }

  if ((__str->__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v15 = __str;
  }
  else {
    uint64_t v15 = (std::string *)__str->__r_.__value_.__r.__words[0];
  }
  if (v15->__r_.__value_.__s.__data_[0] != 95) {
    goto LABEL_43;
  }
LABEL_28:
  uint64_t v16 = 1LL;
  if (v12 != 1)
  {
    while (1)
    {
      if ((__str->__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v18 = __str;
      }
      else {
        uint64_t v18 = (std::string *)__str->__r_.__value_.__r.__words[0];
      }
      uint64_t v19 = v18->__r_.__value_.__s.__data_[v16];
      if (v19 < 0)
      {
        if (!__maskrune(v19, 0x500uLL))
        {
LABEL_30:
          if ((__str->__r_.__value_.__s.__size_ & 0x80u) == 0) {
            uint64_t v17 = __str;
          }
          else {
            uint64_t v17 = (std::string *)__str->__r_.__value_.__r.__words[0];
          }
          if (v17->__r_.__value_.__s.__data_[v16] != 95) {
            break;
          }
        }
      }

      else if ((_DefaultRuneLocale.__runetype[v19] & 0x500) == 0)
      {
        goto LABEL_30;
      }

      if (v12 == ++v16)
      {
        uint64_t v16 = v12;
        break;
      }
    }
  }

  uint64_t v11 = 34;
  return std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)&v11, 1LL);
}

  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 456));
  return a3;
}

char *std::vector<std::string>::__push_back_slow_path<std::string>(void **a1, uint64_t a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * (((_BYTE *)a1[1] - (_BYTE *)*a1) >> 3);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556LL * (((_BYTE *)a1[2] - (_BYTE *)*a1) >> 3) > v3) {
    unint64_t v3 = 0x5555555555555556LL * (((_BYTE *)a1[2] - (_BYTE *)*a1) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((_BYTE *)a1[2] - (_BYTE *)*a1) >> 3) >= 0x555555555555555LL) {
    unint64_t v6 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v6 = v3;
  }
  if (v6)
  {
    if (v6 > 0xAAAAAAAAAAAAAAALL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v7 = (char *)operator new(24 * v6);
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  uint64_t v8 = &v7[24 * v2];
  unsigned __int16 v9 = &v7[24 * v6];
  *(_OWORD *)uint64_t v8 = *(_OWORD *)a2;
  *((void *)v8 + 2) = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0LL;
  *(void *)(a2 + 16) = 0LL;
  *(void *)a2 = 0LL;
  __int128 v10 = v8 + 24;
  uint64_t v11 = (void **)*a1;
  int v12 = (void **)a1[1];
  if (v12 == *a1)
  {
    *a1 = v8;
    a1[1] = v10;
    a1[2] = v9;
  }

  else
  {
    do
    {
      __int128 v13 = *(_OWORD *)(v12 - 3);
      *((void *)v8 - 1) = *(v12 - 1);
      *(_OWORD *)(v8 - 24) = v13;
      v8 -= 24;
      *(v12 - 2) = 0LL;
      *(v12 - 1) = 0LL;
      *(v12 - 3) = 0LL;
      v12 -= 3;
    }

    while (v12 != v11);
    int v12 = (void **)*a1;
    unint64_t v14 = (void **)a1[1];
    *a1 = v8;
    a1[1] = v10;
    a1[2] = v9;
    while (v14 != v12)
    {
      v14 -= 3;
    }
  }

  if (v12) {
    operator delete(v12);
  }
  return v10;
}

void std::__throw_bad_array_new_length[abi:nn180100]()
{
}

const char *PortWasBoundCallbackUnixSocket(const char *result, unsigned int a2)
{
  if (result)
  {
    unint64_t v2 = result;
    if (*result)
    {
      int v4 = socket(1, 1, 0);
      if (v4 < 0) {
        PortWasBoundCallbackUnixSocket();
      }
      int v5 = v4;
      v15.sa_family = 1;
      strlcpy(v15.sa_data, v2, 0x67uLL);
      char v16 = 0;
      v15.sa_len = strlen(v15.sa_data) + 2;
      int v6 = strlen(v15.sa_data);
      if (connect(v5, &v15, v6 + 2) < 0) {
        PortWasBoundCallbackUnixSocket();
      }
      if (g_isatty) {
        fprintf(__stdoutp, "Listening to port %i...\n", a2);
      }
      else {
        _DNBLog(0LL, (uint64_t)"Listening to port %i...\n", v7, v8, v9, v10, v11, v12, a2);
      }
      size_t v13 = snprintf(__str, 0x40uLL, "%u", a2);
      if (send(v5, __str, v13, 0) != v13) {
        PortWasBoundCallbackUnixSocket();
      }
      return (const char *)close(v5);
    }
  }

  return result;
}

const char *PortWasBoundCallbackNamedPipe(const char *result, int a2)
{
  if (result && *result)
  {
    BOOL result = (const char *)open(result, 1);
    if ((result & 0x80000000) == 0)
    {
      int v3 = (int)result;
      int v4 = snprintf(__str, 0x40uLL, "%u", a2);
      write(v3, __str, v4 + 1LL);
      return (const char *)close(v3);
    }
  }

  return result;
}

void std::__shared_ptr_emplace<RNBRemote>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_100060C10;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<RNBRemote>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_100060C10;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_emplace<RNBRemote>::__on_zero_shared(uint64_t a1)
{
}

void OUTLINED_FUNCTION_0()
{
}

uint64_t _GLOBAL__sub_I_debugserver_cpp()
{
  return __cxa_atexit( (void (*)(void *))std::shared_ptr<RNBRemote>::~shared_ptr[abi:nn180100],  &g_remoteSP,  (void *)&_mh_execute_header);
}

uint64_t std::map<unsigned int,DNBArchPluginInfoTag>::~map[abi:nn180100](uint64_t a1)
{
  return a1;
}

uint64_t DNBArchProtocol::GetCPUType(DNBArchProtocol *this)
{
  return g_current_cpu_type;
}

uint64_t DNBArchProtocol::GetCPUSubType(DNBArchProtocol *this)
{
  return g_current_cpu_subtype;
}

uint64_t DNBArchProtocol::SetArchitecture(DNBArchProtocol *this, int a2)
{
  int v3 = (int)this;
  g_current_cpu_type = (int)this;
  g_current_cpu_subtype = a2;
  uint64_t v4 = qword_1000716C0;
  if (!qword_1000716C0) {
    goto LABEL_12;
  }
  int v5 = &qword_1000716C0;
  do
  {
    unsigned int v6 = *(_DWORD *)(v4 + 32);
    BOOL v7 = v6 >= this;
    else {
      uint64_t v8 = (uint64_t *)(v4 + 8);
    }
    if (v7) {
      int v5 = (uint64_t *)v4;
    }
    uint64_t v4 = *v8;
  }

  while (*v8);
  else {
LABEL_12:
  }
    uint64_t v9 = 0LL;
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("DNBArchProtocol::SetDefaultArchitecture (cpu_type=0x%8.8x, cpu_subtype=0x%8.8x) => %i", v3, a2, v9);
  }
  return v9;
}

void DNBArchProtocol::EnableAMXRegisters(DNBArchProtocol *this)
{
  enable_amx = 1;
}

__n128 DNBArchProtocol::RegisterArchPlugin(unsigned int *a1)
{
  unsigned int v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = qword_1000716C0;
    if (qword_1000716C0)
    {
      while (1)
      {
        while (1)
        {
          int v5 = (uint64_t *)v3;
          unsigned int v6 = *(_DWORD *)(v3 + 32);
          if (v1 >= v6) {
            break;
          }
          uint64_t v3 = *v5;
          uint64_t v4 = v5;
          if (!*v5) {
            goto LABEL_9;
          }
        }

        if (v6 >= v1) {
          break;
        }
        uint64_t v3 = v5[1];
        if (!v3)
        {
          uint64_t v4 = v5 + 1;
          goto LABEL_9;
        }
      }
    }

    else
    {
      uint64_t v4 = &qword_1000716C0;
      int v5 = &qword_1000716C0;
LABEL_9:
      BOOL v7 = v5;
      int v5 = (uint64_t *)operator new(0x48uLL);
      *((_DWORD *)v5 + 8) = v1;
      *(_OWORD *)(v5 + 5) = 0u;
      *(_OWORD *)(v5 + 7) = 0u;
      *int v5 = 0LL;
      v5[1] = 0LL;
      v5[2] = (uint64_t)v7;
      *uint64_t v4 = (uint64_t)v5;
      uint64_t v8 = v5;
      if (*(void *)g_arch_plugins)
      {
        g_arch_plugins = *(void *)g_arch_plugins;
        uint64_t v8 = (uint64_t *)*v4;
      }

      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)qword_1000716C0, v8);
      ++qword_1000716C8;
    }

    __n128 result = *(__n128 *)a1;
    *(_OWORD *)(v5 + 7) = *((_OWORD *)a1 + 1);
    *(__n128 *)(v5 + 5) = result;
  }

  return result;
}

uint64_t DNBArchProtocol::GetRegisterCPUType(DNBArchProtocol *this)
{
  uint64_t v1 = qword_1000716C0;
  if (!qword_1000716C0) {
    return 0LL;
  }
  unint64_t v2 = &qword_1000716C0;
  do
  {
    unsigned int v3 = *(_DWORD *)(v1 + 32);
    BOOL v4 = v3 >= g_current_cpu_type;
    if (v3 >= g_current_cpu_type) {
      int v5 = (uint64_t *)v1;
    }
    else {
      int v5 = (uint64_t *)(v1 + 8);
    }
    if (v4) {
      unint64_t v2 = (uint64_t *)v1;
    }
    uint64_t v1 = *v5;
  }

  while (*v5);
  else {
    return 0LL;
  }
}

uint64_t DNBArchProtocol::GetRegisterSetInfo(DNBArchProtocol *this, unint64_t *a2)
{
  uint64_t v2 = qword_1000716C0;
  if (qword_1000716C0)
  {
    unsigned int v3 = &qword_1000716C0;
    do
    {
      unsigned int v4 = *(_DWORD *)(v2 + 32);
      BOOL v5 = v4 >= g_current_cpu_type;
      if (v4 >= g_current_cpu_type) {
        unsigned int v6 = (uint64_t *)v2;
      }
      else {
        unsigned int v6 = (uint64_t *)(v2 + 8);
      }
      if (v5) {
        unsigned int v3 = (uint64_t *)v2;
      }
      uint64_t v2 = *v6;
    }

    while (*v6);
  }

  *(void *)this = 0LL;
  return 0LL;
}

uint64_t DNBArchProtocol::Create()
{
  uint64_t v0 = qword_1000716C0;
  if (!qword_1000716C0) {
    return 0LL;
  }
  uint64_t v1 = &qword_1000716C0;
  do
  {
    unsigned int v2 = *(_DWORD *)(v0 + 32);
    BOOL v3 = v2 >= g_current_cpu_type;
    if (v2 >= g_current_cpu_type) {
      unsigned int v4 = (uint64_t *)v0;
    }
    else {
      unsigned int v4 = (uint64_t *)(v0 + 8);
    }
    if (v3) {
      uint64_t v1 = (uint64_t *)v0;
    }
    uint64_t v0 = *v4;
  }

  while (*v4);
  else {
    return 0LL;
  }
}

uint64_t DNBArchProtocol::GetBreakpointOpcode(DNBArchProtocol *this)
{
  uint64_t v1 = qword_1000716C0;
  if (!qword_1000716C0) {
    return 0LL;
  }
  unsigned int v2 = &qword_1000716C0;
  do
  {
    unsigned int v3 = *(_DWORD *)(v1 + 32);
    BOOL v4 = v3 >= g_current_cpu_type;
    if (v3 >= g_current_cpu_type) {
      BOOL v5 = (uint64_t *)v1;
    }
    else {
      BOOL v5 = (uint64_t *)(v1 + 8);
    }
    if (v4) {
      unsigned int v2 = (uint64_t *)v1;
    }
    uint64_t v1 = *v5;
  }

  while (*v5);
  else {
    return 0LL;
  }
}

void std::__tree<std::__value_type<unsigned int,DNBArchPluginInfoTag>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,DNBArchPluginInfoTag>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,DNBArchPluginInfoTag>>>::destroy( uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<unsigned int,DNBArchPluginInfoTag>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,DNBArchPluginInfoTag>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,DNBArchPluginInfoTag>>>::destroy( a1,  *a2);
    std::__tree<std::__value_type<unsigned int,DNBArchPluginInfoTag>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,DNBArchPluginInfoTag>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,DNBArchPluginInfoTag>>>::destroy( a1,  a2[1]);
    operator delete(a2);
  }

uint64_t *std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>( uint64_t *result, uint64_t *a2)
{
  *((_BYTE *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      uint64_t v2 = a2[2];
      if (*(_BYTE *)(v2 + 24)) {
        break;
      }
      unsigned int v3 = *(uint64_t **)(v2 + 16);
      uint64_t v4 = *v3;
      if (*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), BOOL v5 = (_BYTE *)(v7 + 24), v8))
        {
          if (*(uint64_t **)v2 == a2)
          {
            uint64_t v9 = (uint64_t *)a2[2];
          }

          else
          {
            uint64_t v9 = *(uint64_t **)(v2 + 8);
            uint64_t v10 = *v9;
            *(void *)(v2 + 8) = *v9;
            if (v10)
            {
              *(void *)(v10 + 16) = v2;
              unsigned int v3 = *(uint64_t **)(v2 + 16);
            }

            v9[2] = (uint64_t)v3;
            *(void *)(*(void *)(v2 + 16) + 8LL * (**(void **)(v2 + 16) != v2)) = v9;
            *uint64_t v9 = v2;
            *(void *)(v2 + 16) = v9;
            unsigned int v3 = (uint64_t *)v9[2];
            uint64_t v2 = *v3;
          }

          *((_BYTE *)v9 + 24) = 1;
          *((_BYTE *)v3 + 24) = 0;
          uint64_t v14 = *(void *)(v2 + 8);
          *unsigned int v3 = v14;
          if (v14) {
            *(void *)(v14 + 16) = v3;
          }
          *(void *)(v2 + 16) = v3[2];
          *(void *)(v3[2] + 8LL * (*(void *)v3[2] != (void)v3)) = v2;
          *(void *)(v2 + 8) = v3;
          v3[2] = v2;
          return result;
        }
      }

      else if (!v4 || (v6 = *(unsigned __int8 *)(v4 + 24), BOOL v5 = (_BYTE *)(v4 + 24), v6))
      {
        if (*(uint64_t **)v2 == a2)
        {
          uint64_t v11 = a2[1];
          *(void *)uint64_t v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            unsigned int v3 = *(uint64_t **)(v2 + 16);
          }

          a2[2] = (uint64_t)v3;
          *(void *)(*(void *)(v2 + 16) + 8LL * (**(void **)(v2 + 16) != v2)) = a2;
          a2[1] = v2;
          *(void *)(v2 + 16) = a2;
          unsigned int v3 = (uint64_t *)a2[2];
        }

        else
        {
          a2 = (uint64_t *)a2[2];
        }

        *((_BYTE *)a2 + 24) = 1;
        *((_BYTE *)v3 + 24) = 0;
        uint64_t v12 = (uint64_t *)v3[1];
        uint64_t v13 = *v12;
        v3[1] = *v12;
        if (v13) {
          *(void *)(v13 + 16) = v3;
        }
        v12[2] = v3[2];
        *(void *)(v3[2] + 8LL * (*(void *)v3[2] != (void)v3)) = v12;
        uint64_t *v12 = (uint64_t)v3;
        v3[2] = (uint64_t)v12;
        return result;
      }

      *(_BYTE *)(v2 + 24) = 1;
      a2 = v3;
      *((_BYTE *)v3 + 24) = v3 == result;
      *BOOL v5 = 1;
    }

    while (v3 != result);
  }

  return result;
}

uint64_t _GLOBAL__sub_I_DNBArch_cpp()
{
  qword_1000716C8 = 0LL;
  qword_1000716C0 = 0LL;
  g_arch_plugins = (uint64_t)&qword_1000716C0;
  return __cxa_atexit( (void (*)(void *))std::map<unsigned int,DNBArchPluginInfoTag>::~map[abi:nn180100],  &g_arch_plugins,  (void *)&_mh_execute_header);
}

void DNBBreakpointList::DNBBreakpointList(DNBBreakpointList *this)
{
  *((void *)this + 2) = 0LL;
  *((void *)this + 1) = 0LL;
  *(void *)this = (char *)this + 8;
}

void DNBBreakpointList::~DNBBreakpointList(DNBBreakpointList *this)
{
}

char *DNBBreakpointList::Add(uint64_t **this, unint64_t a2, int a3, int a4)
{
  if (a4) {
    char v7 = 2;
  }
  else {
    char v7 = 0;
  }
  uint64_t v9 = (char *)(this + 1);
  int v8 = this[1];
  uint64_t v10 = this + 1;
  uint64_t v11 = this + 1;
  if (v8)
  {
    uint64_t v12 = this[1];
    while (1)
    {
      while (1)
      {
        uint64_t v11 = (uint64_t **)v12;
        unint64_t v13 = v12[4];
        if (v13 <= a2) {
          break;
        }
        uint64_t v12 = *v11;
        uint64_t v10 = v11;
        if (!*v11) {
          goto LABEL_11;
        }
      }

      if (v13 >= a2) {
        break;
      }
      uint64_t v12 = v11[1];
      if (!v12)
      {
        uint64_t v10 = v11 + 1;
        goto LABEL_11;
      }
    }
  }

  else
  {
LABEL_11:
    uint64_t v14 = operator new(0x48uLL);
    v14[4] = a2;
    *((_DWORD *)v14 + 10) = 1;
    *((_DWORD *)v14 + 11) = a3;
    v14[6] = 0LL;
    v14[7] = a2;
    *((_BYTE *)v14 + 64) = v7;
    *((_DWORD *)v14 + 17) = -1;
    *uint64_t v14 = 0LL;
    v14[1] = 0LL;
    v14[2] = v11;
    *uint64_t v10 = v14;
    sockaddr v15 = (uint64_t *)**this;
    if (v15)
    {
      *this = v15;
      char v16 = *v10;
    }

    else
    {
      char v16 = v14;
    }

    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(this[1], v16);
    int v8 = this[1];
    this[2] = (uint64_t *)((char *)this[2] + 1);
  }

  if (!v8) {
    goto LABEL_26;
  }
  uint64_t v17 = v9;
  do
  {
    unint64_t v18 = v8[4];
    BOOL v19 = v18 >= a2;
    if (v18 >= a2) {
      uint64_t v20 = (uint64_t **)v8;
    }
    else {
      uint64_t v20 = (uint64_t **)(v8 + 1);
    }
    if (v19) {
      uint64_t v17 = (char *)v8;
    }
    int v8 = *v20;
  }

  while (*v20);
  if (v17 == v9 || *((void *)v17 + 4) > a2) {
LABEL_26:
  }
    uint64_t v17 = v9;
  return v17 + 40;
}

uint64_t DNBBreakpointList::Remove(DNBBreakpointList *this, unint64_t a2)
{
  uint64_t v4 = (uint64_t *)((char *)this + 8);
  uint64_t result = *((void *)this + 1);
  if (result)
  {
    BOOL v5 = v4;
    uint64_t v6 = result;
    do
    {
      unint64_t v7 = *(void *)(v6 + 32);
      BOOL v8 = v7 >= a2;
      if (v7 >= a2) {
        uint64_t v9 = (uint64_t *)v6;
      }
      else {
        uint64_t v9 = (uint64_t *)(v6 + 8);
      }
      if (v8) {
        BOOL v5 = (uint64_t *)v6;
      }
      uint64_t v6 = *v9;
    }

    while (*v9);
    if (v5 == v4 || v5[4] > a2)
    {
      return 0LL;
    }

    else
    {
      uint64_t v10 = (uint64_t *)v5[1];
      if (v10)
      {
        do
        {
          uint64_t v11 = v10;
          uint64_t v10 = (uint64_t *)*v10;
        }

        while (v10);
      }

      else
      {
        uint64_t v12 = v5;
        do
        {
          uint64_t v11 = (uint64_t *)v12[2];
          BOOL v13 = *v11 == (void)v12;
          uint64_t v12 = v11;
        }

        while (!v13);
      }

      --*((void *)this + 2);
      std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)result, v5);
      operator delete(v5);
      return 1LL;
    }
  }

  return result;
}

char *DNBBreakpointList::FindByAddress(DNBBreakpointList *this, unint64_t a2)
{
  uint64_t v4 = (void *)*((void *)this + 1);
  uint64_t v2 = (char *)this + 8;
  unsigned int v3 = v4;
  if (!v4) {
    return 0LL;
  }
  BOOL v5 = v2;
  do
  {
    unint64_t v6 = v3[4];
    BOOL v7 = v6 >= a2;
    if (v6 >= a2) {
      BOOL v8 = v3;
    }
    else {
      BOOL v8 = v3 + 1;
    }
    if (v7) {
      BOOL v5 = (char *)v3;
    }
    unsigned int v3 = (void *)*v8;
  }

  while (*v8);
  if (v5 == v2) {
    return 0LL;
  }
  unint64_t v9 = *((void *)v5 + 4);
  uint64_t v10 = v5 + 40;
  if (v9 <= a2) {
    return v10;
  }
  else {
    return 0LL;
  }
}

char *DNBBreakpointList::FindByHardwareIndex(DNBBreakpointList *this, int a2)
{
  uint64_t v4 = *(char **)this;
  uint64_t v2 = (char *)this + 8;
  unsigned int v3 = v4;
  if (v4 == v2) {
    return 0LL;
  }
  while (*((_DWORD *)v3 + 17) != a2)
  {
    unint64_t v6 = (char *)*((void *)v3 + 1);
    if (v6)
    {
      do
      {
        BOOL v7 = v6;
        unint64_t v6 = *(char **)v6;
      }

      while (v6);
    }

    else
    {
      do
      {
        BOOL v7 = (char *)*((void *)v3 + 2);
        BOOL v8 = *(void *)v7 == (void)v3;
        unsigned int v3 = v7;
      }

      while (!v8);
    }

    unsigned int v3 = v7;
    if (v7 == v2) {
      return 0LL;
    }
  }

  return v3 + 40;
}

char *DNBBreakpointList::FindNearestWatchpoint(DNBBreakpointList *this, unint64_t a2)
{
  uint64_t v4 = *(char **)this;
  uint64_t v2 = (char *)this + 8;
  unsigned int v3 = v4;
  if (v4 == v2) {
    return 0LL;
  }
  BOOL v5 = v3;
  do
  {
    if ((v5[64] & 1) != 0)
    {
      unint64_t v6 = *((void *)v5 + 7);
    }

    BOOL v8 = (char *)*((void *)v5 + 1);
    if (v8)
    {
      do
      {
        unint64_t v9 = v8;
        BOOL v8 = *(char **)v8;
      }

      while (v8);
    }

    else
    {
      do
      {
        unint64_t v9 = (char *)*((void *)v5 + 2);
        BOOL v10 = *(void *)v9 == (void)v5;
        BOOL v5 = v9;
      }

      while (!v10);
    }

    BOOL v5 = v9;
  }

  while (v9 != v2);
  if (v3 == v2) {
    return 0LL;
  }
  uint64_t v11 = 0LL;
  unsigned int v12 = -1;
  do
  {
    if ((v3[64] & 1) != 0)
    {
      unint64_t v13 = *((void *)v3 + 7);
      if (v13 <= a2) {
        unsigned int v14 = a2 - (v13 + *((_DWORD *)v3 + 11));
      }
      else {
        unsigned int v14 = v13 - a2;
      }
      if (v12 > v14) {
        uint64_t v11 = v3 + 40;
      }
      if (v12 >= v14) {
        unsigned int v12 = v14;
      }
    }

    sockaddr v15 = (char *)*((void *)v3 + 1);
    if (v15)
    {
      do
      {
        char v16 = v15;
        sockaddr v15 = *(char **)v15;
      }

      while (v15);
    }

    else
    {
      do
      {
        char v16 = (char *)*((void *)v3 + 2);
        BOOL v10 = *(void *)v16 == (void)v3;
        unsigned int v3 = v16;
      }

      while (!v10);
    }

    unsigned int v3 = v16;
  }

  while (v16 != v2);
  return (char *)v11;
}

uint64_t DNBBreakpointList::FindBreakpointsThatOverlapRange( void *a1, unint64_t a2, unint64_t a3, uint64_t a4)
{
  BOOL v5 = *(void **)a4;
  *(void *)(a4 + 8) = *(void *)a4;
  BOOL v7 = a1 + 1;
  unint64_t v6 = (void *)a1[1];
  if (v6)
  {
    BOOL v10 = a1 + 1;
    do
    {
      unint64_t v11 = v6[4];
      BOOL v12 = v11 >= a2;
      if (v11 >= a2) {
        unint64_t v13 = v6;
      }
      else {
        unint64_t v13 = v6 + 1;
      }
      if (v12) {
        BOOL v10 = v6;
      }
      unint64_t v6 = (void *)*v13;
    }

    while (*v13);
    if (v10 != v7)
    {
      if (v10 != (void *)*a1)
      {
        uint64_t v14 = *v10;
        if (*v10)
        {
          do
          {
            uint64_t v15 = v14;
            uint64_t v14 = *(void *)(v14 + 8);
          }

          while (v14);
        }

        else
        {
          char v16 = v10;
          do
          {
            uint64_t v15 = v16[2];
            BOOL v17 = *(void *)v15 == (void)v16;
            char v16 = (void *)v15;
          }

          while (v17);
        }

        if ((*(_BYTE *)(v15 + 64) & 5) == 1 && *(_DWORD *)(v15 + 68) == -1)
        {
          uint64_t v47 = *(unsigned int *)(v15 + 44);
          if ((_DWORD)v47)
          {
            unint64_t v48 = *(void *)(v15 + 56);
            if (a3 + a2 > v48 && v48 + v47 > a2)
            {
              uint64_t v49 = v10 + 5;
              unint64_t v50 = *(void *)(a4 + 16);
              if ((unint64_t)v5 >= v50)
              {
                uint64_t v52 = v50 - (void)v5;
                uint64_t v53 = v52 >> 2;
                BOOL v12 = (unint64_t)v52 >= 0x7FFFFFFFFFFFFFF8LL;
                unint64_t v54 = 0x1FFFFFFFFFFFFFFFLL;
                if (!v12) {
                  unint64_t v54 = v53;
                }
                if (v54 >> 61) {
LABEL_78:
                }
                  std::__throw_bad_array_new_length[abi:nn180100]();
                uint64_t v55 = v54;
                uint64_t v56 = operator new(8 * v54);
                uint64_t v57 = &v56[v55];
                *uint64_t v56 = v49;
                uint64_t v51 = v56 + 1;
                *(void *)a4 = v56;
                *(void *)(a4 + 8) = v56 + 1;
                *(void *)(a4 + 16) = v57;
                if (v5) {
                  operator delete(v5);
                }
              }

              else
              {
                *BOOL v5 = v49;
                uint64_t v51 = v5 + 1;
              }

              *(void *)(a4 + 8) = v51;
              BOOL v5 = v51;
            }
          }
        }
      }

      unint64_t v18 = a3 + a2;
      while (1)
      {
        unint64_t v19 = v10[7];
        if (v19 - a2 >= a3) {
          return ((uint64_t)v5 - *(void *)a4) >> 3;
        }
        if ((v10[8] & 5) == 1 && *((_DWORD *)v10 + 17) == -1)
        {
          uint64_t v20 = *((unsigned int *)v10 + 11);
          if ((_DWORD)v20)
          {
            if (v18 > v19 && v19 + v20 > a2) {
              break;
            }
          }
        }

void *DNBBreakpointList::DisableAll(DNBBreakpointList *this)
{
  unsigned int v3 = *(void **)this;
  uint64_t result = (void *)((char *)this + 8);
  uint64_t v2 = v3;
  if (v3 != result)
  {
    do
    {
      *((_DWORD *)v2 + 17) = -1;
      *((_BYTE *)v2 + 64) &= ~1u;
      uint64_t v4 = (void *)v2[1];
      if (v4)
      {
        do
        {
          BOOL v5 = v4;
          uint64_t v4 = (void *)*v4;
        }

        while (v4);
      }

      else
      {
        do
        {
          BOOL v5 = (void *)v2[2];
          BOOL v6 = *v5 == (void)v2;
          uint64_t v2 = v5;
        }

        while (!v6);
      }

      uint64_t v2 = v5;
    }

    while (v5 != result);
  }

  return result;
}

void *DNBBreakpointList::RemoveTrapsFromBuffer(void *this, unint64_t a2, uint64_t a3, char *a4)
{
  BOOL v5 = (char *)(this + 1);
  uint64_t v4 = (void *)this[1];
  if (v4)
  {
    BOOL v8 = (char *)(this + 1);
    do
    {
      unint64_t v9 = v4[4];
      BOOL v10 = v9 >= a2;
      if (v9 >= a2) {
        unint64_t v11 = v4;
      }
      else {
        unint64_t v11 = v4 + 1;
      }
      if (v10) {
        BOOL v8 = (char *)v4;
      }
      uint64_t v4 = (void *)*v11;
    }

    while (*v11);
    if (v8 != v5)
    {
      unint64_t v12 = a3 + a2;
      do
      {
        if (*((void *)v8 + 4) >= v12) {
          break;
        }
        if ((v8[64] & 5) == 1 && *((_DWORD *)v8 + 17) == -1)
        {
          unint64_t v16 = *((unsigned int *)v8 + 11);
          if ((_DWORD)v16)
          {
            unint64_t v17 = *((void *)v8 + 7);
            if (v12 > v17 && v17 + v16 > a2)
            {
              if (v12 >= v17 + v16) {
                unint64_t v18 = v17 + v16;
              }
              else {
                unint64_t v18 = v12;
              }
              if (v17 <= a2) {
                unint64_t v19 = a2;
              }
              else {
                unint64_t v19 = *((void *)v8 + 7);
              }
              BOOL v10 = a2 >= v17;
              unint64_t v20 = a2 - v17;
              if (!v10) {
                unint64_t v20 = 0LL;
              }
              if (v19 >= v12) {
                DNBBreakpointList::RemoveTrapsFromBuffer();
              }
              if (v18 <= a2) {
                DNBBreakpointList::RemoveTrapsFromBuffer();
              }
              if (v20 + v18 - v19 > v16) {
                DNBBreakpointList::RemoveTrapsFromBuffer();
              }
              this = memcpy(&a4[v19 - a2], &v8[v20 + 48], v18 - v19);
            }
          }
        }

        unint64_t v13 = (char *)*((void *)v8 + 1);
        if (v13)
        {
          do
          {
            uint64_t v14 = v13;
            unint64_t v13 = *(char **)v13;
          }

          while (v13);
        }

        else
        {
          do
          {
            uint64_t v14 = (char *)*((void *)v8 + 2);
            BOOL v15 = *(void *)v14 == (void)v8;
            BOOL v8 = v14;
          }

          while (!v15);
        }

        BOOL v8 = v14;
      }

      while (v14 != v5);
    }
  }

  return this;
}

uint64_t DNBBreakpointList::DisableAllBreakpoints(uint64_t this, MachProcess *a2)
{
  uint64_t v2 = (void *)(this + 8);
  unsigned int v3 = *(void **)this;
  if (*(void *)this != this + 8)
  {
    do
    {
      this = MachProcess::DisableBreakpoint(a2, v3[7], 0);
      BOOL v5 = (void *)v3[1];
      if (v5)
      {
        do
        {
          BOOL v6 = v5;
          BOOL v5 = (void *)*v5;
        }

        while (v5);
      }

      else
      {
        do
        {
          BOOL v6 = (void *)v3[2];
          BOOL v7 = *v6 == (void)v3;
          unsigned int v3 = v6;
        }

        while (!v7);
      }

      unsigned int v3 = v6;
    }

    while (v6 != v2);
  }

  return this;
}

uint64_t DNBBreakpointList::DisableAllWatchpoints(uint64_t this, MachProcess *a2)
{
  uint64_t v2 = (void *)(this + 8);
  unsigned int v3 = *(void **)this;
  if (*(void *)this != this + 8)
  {
    do
    {
      this = MachProcess::DisableWatchpoint(a2, v3[7], 0);
      BOOL v5 = (void *)v3[1];
      if (v5)
      {
        do
        {
          BOOL v6 = v5;
          BOOL v5 = (void *)*v5;
        }

        while (v5);
      }

      else
      {
        do
        {
          BOOL v6 = (void *)v3[2];
          BOOL v7 = *v6 == (void)v3;
          unsigned int v3 = v6;
        }

        while (!v7);
      }

      unsigned int v3 = v6;
    }

    while (v6 != v2);
  }

  return this;
}

void DNBBreakpointList::RemoveDisabled(DNBBreakpointList *this)
{
  uint64_t v2 = (char *)this + 8;
  uint64_t v1 = *(char **)this;
  if (*(DNBBreakpointList **)this != (DNBBreakpointList *)((char *)this + 8))
  {
    do
    {
      BOOL v5 = (char *)*((void *)v1 + 1);
      if ((v1[64] & 1) != 0)
      {
        if (v5)
        {
          do
          {
            BOOL v7 = v5;
            BOOL v5 = *(char **)v5;
          }

          while (v5);
        }

        else
        {
          do
          {
            BOOL v7 = (char *)*((void *)v1 + 2);
            BOOL v8 = *(void *)v7 == (void)v1;
            uint64_t v1 = v7;
          }

          while (!v8);
        }
      }

      else
      {
        BOOL v6 = v1;
        if (v5)
        {
          do
          {
            BOOL v7 = v5;
            BOOL v5 = *(char **)v5;
          }

          while (v5);
        }

        else
        {
          do
          {
            BOOL v7 = (char *)*((void *)v6 + 2);
            BOOL v8 = *(void *)v7 == (void)v6;
            BOOL v6 = v7;
          }

          while (!v8);
        }

        uint64_t v4 = (uint64_t *)*((void *)this + 1);
        --*((void *)this + 2);
        std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v4, (uint64_t *)v1);
        operator delete(v1);
      }

      uint64_t v1 = v7;
    }

    while (v7 != v2);
  }

uint64_t *std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  unsigned int v3 = a2;
  if (*a2)
  {
    uint64_t v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      unsigned int v3 = a2;
      goto LABEL_7;
    }

    do
    {
      unsigned int v3 = v4;
      uint64_t v4 = (uint64_t *)*v4;
    }

    while (v4);
  }

  uint64_t v2 = v3[1];
  if (v2)
  {
LABEL_7:
    int v5 = 0;
    *(void *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }

  int v5 = 1;
LABEL_8:
  BOOL v6 = (uint64_t **)v3[2];
  BOOL v7 = *v6;
  if (*v6 == v3)
  {
    *BOOL v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      BOOL v7 = 0LL;
      uint64_t result = (uint64_t *)v2;
    }

    else
    {
      BOOL v7 = v6[1];
    }
  }

  else
  {
    v6[1] = (uint64_t *)v2;
  }

  int v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    uint64_t v9 = a2[2];
    v3[2] = v9;
    *(void *)(v9 + 8LL * (*(void *)a2[2] != (void)a2)) = v3;
    uint64_t v11 = *a2;
    uint64_t v10 = a2[1];
    *(void *)(v11 + 16) = v3;
    *unsigned int v3 = v11;
    v3[1] = v10;
    if (v10) {
      *(void *)(v10 + 16) = v3;
    }
    *((_BYTE *)v3 + 24) = *((_BYTE *)a2 + 24);
    if (result == a2) {
      uint64_t result = v3;
    }
  }

  if (!v8 || !result) {
    return result;
  }
  if (!v5)
  {
    *(_BYTE *)(v2 + 24) = 1;
    return result;
  }

  while (1)
  {
    uint64_t v14 = (uint64_t **)v7[2];
    if (*v14 == v7) {
      break;
    }
    if (*((_BYTE *)v7 + 24))
    {
      BOOL v15 = (void *)*v7;
      if (!*v7) {
        goto LABEL_40;
      }
    }

    else
    {
      *((_BYTE *)v7 + 24) = 1;
      *((_BYTE *)v14 + 24) = 0;
      unint64_t v17 = v14[1];
      unint64_t v18 = (uint64_t *)*v17;
      v14[1] = (uint64_t *)*v17;
      if (v18) {
        v18[2] = (uint64_t)v14;
      }
      v17[2] = (uint64_t)v14[2];
      v14[2][*v14[2] != (void)v14] = (uint64_t)v17;
      *unint64_t v17 = (uint64_t)v14;
      v14[2] = v17;
      BOOL v7 = *(uint64_t **)(*v7 + 8);
      BOOL v15 = (void *)*v7;
      if (!*v7) {
        goto LABEL_40;
      }
    }

    if (!*((_BYTE *)v15 + 24))
    {
      unint64_t v19 = (uint64_t *)v7[1];
      if (!v19) {
        goto LABEL_64;
      }
LABEL_63:
      if (*((_BYTE *)v19 + 24))
      {
LABEL_64:
        *((_BYTE *)v15 + 24) = 1;
        *((_BYTE *)v7 + 24) = 0;
        uint64_t v23 = v15[1];
        *BOOL v7 = v23;
        if (v23) {
          *(void *)(v23 + 16) = v7;
        }
        v15[2] = v7[2];
        *(void *)(v7[2] + 8LL * (*(void *)v7[2] != (void)v7)) = v15;
        v15[1] = v7;
        v7[2] = (uint64_t)v15;
        unint64_t v19 = v7;
      }

      else
      {
        BOOL v15 = v7;
      }

      uint64_t v27 = v15[2];
      *((_BYTE *)v15 + 24) = *(_BYTE *)(v27 + 24);
      *(_BYTE *)(v27 + 24) = 1;
      *((_BYTE *)v19 + 24) = 1;
      uint64_t v28 = *(uint64_t **)(v27 + 8);
      uint64_t v29 = *v28;
      *(void *)(v27 + 8) = *v28;
      if (v29) {
        *(void *)(v29 + 16) = v27;
      }
      v28[2] = *(void *)(v27 + 16);
      *(void *)(*(void *)(v27 + 16) + 8LL * (**(void **)(v27 + 16) != v27)) = v28;
      *uint64_t v28 = v27;
      *(void *)(v27 + 16) = v28;
      return result;
    }

LABEL_40:
    unint64_t v19 = (uint64_t *)v7[1];
    if (v19 && !*((_BYTE *)v19 + 24)) {
      goto LABEL_63;
    }
    *((_BYTE *)v7 + 24) = 0;
    unint64_t v12 = (uint64_t *)v7[2];
    if (v12 == result)
    {
      unint64_t v12 = result;
LABEL_61:
      *((_BYTE *)v12 + 24) = 1;
      return result;
    }

    if (!*((_BYTE *)v12 + 24)) {
      goto LABEL_61;
    }
LABEL_26:
    BOOL v7 = *(uint64_t **)(v12[2] + 8LL * (*(void *)v12[2] == (void)v12));
  }

  if (*((_BYTE *)v7 + 24))
  {
    unint64_t v16 = (void *)*v7;
    if (!*v7) {
      goto LABEL_51;
    }
LABEL_50:
    if (!*((_BYTE *)v16 + 24)) {
      goto LABEL_67;
    }
  }

  else
  {
    *((_BYTE *)v7 + 24) = 1;
    *((_BYTE *)v14 + 24) = 0;
    unint64_t v20 = (uint64_t *)v7[1];
    *uint64_t v14 = v20;
    if (v20) {
      v20[2] = (uint64_t)v14;
    }
    v7[2] = (uint64_t)v14[2];
    v14[2][*v14[2] != (void)v14] = (uint64_t)v7;
    v7[1] = (uint64_t)v14;
    v14[2] = v7;
    BOOL v7 = *v14;
    unint64_t v16 = (void *)**v14;
    if (v16) {
      goto LABEL_50;
    }
  }

    int v5 = RNBRemote::HandlePacket_ILLFORMED( v15,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v16,  v6,  v12);
    unint64_t v19 = 0;
LABEL_9:
    if ((v19 & 1) == 0) {
      return v5;
    }
  }

  v27.__r_.__value_.__s.__size_ = 2;
  strcpy((char *)&v27, "OK");
  RNBRemote::SendPacket((uint64_t)this, &v27);
  return 0LL;
}

    DNBError::LogThreaded( a13,  "::posix_spawnattr_setbinpref_np(&attr, 1, cpu_type = 0x%8.8x, count => %llu)",  v49,  v53[0]);
    goto LABEL_41;
  }

LABEL_51:
  uint64_t v21 = (uint64_t *)v7[1];
  if (!v21 || *((_BYTE *)v21 + 24))
  {
    *((_BYTE *)v7 + 24) = 0;
    unint64_t v12 = (uint64_t *)v7[2];
    if (*((_BYTE *)v12 + 24)) {
      BOOL v13 = v12 == result;
    }
    else {
      BOOL v13 = 1;
    }
    if (v13) {
      goto LABEL_61;
    }
    goto LABEL_26;
  }

  if (v16 && !*((_BYTE *)v16 + 24))
  {
LABEL_67:
    uint64_t v21 = v7;
  }

  else
  {
    *((_BYTE *)v21 + 24) = 1;
    *((_BYTE *)v7 + 24) = 0;
    uint64_t v22 = *v21;
    v7[1] = *v21;
    if (v22) {
      *(void *)(v22 + 16) = v7;
    }
    v21[2] = v7[2];
    *(void *)(v7[2] + 8LL * (*(void *)v7[2] != (void)v7)) = v21;
    uint64_t *v21 = (uint64_t)v7;
    v7[2] = (uint64_t)v21;
    unint64_t v16 = v7;
  }

  uint64_t v24 = (uint64_t *)v21[2];
  *((_BYTE *)v21 + 24) = *((_BYTE *)v24 + 24);
  *((_BYTE *)v24 + 24) = 1;
  *((_BYTE *)v16 + 24) = 1;
  uint64_t v25 = *v24;
  uint64_t v26 = *(void *)(*v24 + 8);
  uint64_t *v24 = v26;
  if (v26) {
    *(void *)(v26 + 16) = v24;
  }
  *(void *)(v25 + 16) = v24[2];
  *(void *)(v24[2] + 8LL * (*(void *)v24[2] != (void)v24)) = v25;
  *(void *)(v25 + 8) = v24;
  v24[2] = v25;
  return result;
}

        uint64_t v37 = v27 - 1;
        do
        {
          size_t v38 = *--v19;
          *v37-- = v38;
        }

        while (v19 != v21);
LABEL_53:
        unint64_t v19 = v72;
        uint64_t v27 = v26;
        goto LABEL_54;
      }

      v63 = "E80";
    }

    else
    {
      v63 = "E79";
    }

    std::string::basic_string[abi:nn180100]<0>(v71, v63);
    uint64_t v61 = RNBRemote::SendPacket((uint64_t)this, v71);
    if ((char)v71[0].__r_.__value_.__s.__size_ < 0)
    {
      uint64_t v69 = (char *)v71[0].__r_.__value_.__r.__words[0];
LABEL_103:
      operator delete(v69);
    }

  memset(&v48, 0, sizeof(v48));
  if ((size & 0x80) != 0)
  {
LABEL_55:
    uint64_t v26 = v52.__r_.__value_.__l.__size_;
    if (!v52.__r_.__value_.__l.__size_) {
      goto LABEL_67;
    }
    uint64_t v27 = (std::string *)v52.__r_.__value_.__r.__words[0];
    goto LABEL_57;
  }

  if (!size) {
    goto LABEL_65;
  }
  uint64_t v26 = size;
  uint64_t v27 = &v52;
LABEL_57:
  uint64_t v28 = k_space_delimiters;
  uint64_t v29 = strlen(k_space_delimiters);
  uint64_t v30 = v27;
  if (v29)
  {
    unint64_t v31 = v29;
    uint64_t v30 = v27;
    while (memchr(v28, v30->__r_.__value_.__s.__data_[0], v31))
    {
      uint64_t v30 = (std::string *)((char *)v30 + 1);
      if (!--v26)
      {
        unint64_t v32 = -1LL;
        goto LABEL_63;
      }
    }
  }

  unint64_t v32 = (char *)v30 - (char *)v27;
  if (v30 != v27)
  {
LABEL_63:
    std::string::erase(&v52, 0LL, v32);
    size_t size = v52.__r_.__value_.__s.__size_;
  }

  if ((size & 0x80) == 0)
  {
LABEL_65:
    if (!size) {
      goto LABEL_67;
    }
    goto LABEL_66;
  }

  if (v52.__r_.__value_.__l.__size_)
  {
LABEL_66:
    unint64_t v48 = v52;
    memset(&v52, 0, sizeof(v52));
  }

    int v5 = v3 >= 0;
    BOOL v6 = v4 >= 0;
  }

  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("MachProcess::%s (%p): thread exiting...", "STDIOThread", this);
  }
LABEL_55:
  if (SHIBYTE(v21) < 0) {
    operator delete(__p[1]);
  }
  return 0LL;
}

uint64_t kqueue_thread(void *a1)
{
  int v1 = (int)a1;
  pthread_setname_np("kqueue thread");
  int v21 = 0;
  uint64_t v2 = pthread_self();
  if (!pthread_getschedparam(v2, &v21, &v22))
  {
    v22.sched_priority = 47;
    unsigned int v3 = pthread_self();
    pthread_setschedparam(v3, v21, &v22);
  }

  do
  {
    while (kevent(v1, 0LL, 0, &eventlist, 1, 0LL) != -1)
    {
      if ((eventlist.flags & 0x4000) != 0)
      {
        int data = eventlist.data;
        uint64_t v10 = strerror(eventlist.data);
        if (DNBLogEnabled())
        {
          uint64_t v11 = "Unknown error";
          if (v10) {
            uint64_t v11 = v10;
          }
          _DNBLogError("Failed to initialize kqueue event: (%d): %s", data, v11);
        }

        return 0LL;
      }

      int v19 = 0;
      int ident = eventlist.ident;
      pid_t v5 = waitpid(eventlist.ident, &v19, 0);
      int v6 = v19 & 0x7F;
      if (v6 == 127)
      {
        int v8 = v19 >> 8;
        if (v19 >> 8 != 19 && DNBLogEnabledForAny(2)) {
          _DNBLogThreaded("waitpid (%i) -> STOPPED (signal = %i)", v5, v8);
        }
      }

      else
      {
        if ((v19 & 0x7F) == 0)
        {
          int v15 = BYTE1(v19);
          if (DNBLogEnabledForAny(2)) {
            _DNBLogThreaded("waitpid (%i) -> EXITED (status = %i)", v5, v15);
          }
          int v16 = eventlist.data;
          if ((eventlist.data & 0x20000) == 0) {
            goto LABEL_26;
          }
LABEL_32:
          unint64_t v17 = "Terminated due to memory issue";
          goto LABEL_34;
        }

        if (ident < 0) {
          int ident = -ident;
        }
        BOOL v7 = DNBLogEnabledForAny(2);
        if (v5 == ident)
        {
          if (v7) {
            _DNBLogThreaded("waitpid (%i) -> SIGNALED and EXITED (signal = %i)", v5, v6);
          }
          snprintf(__str, 0x40uLL, "Terminated due to signal %i", v6);
          DNBProcessSetExitInfo(v5, __str);
          int v15 = 127;
          int v16 = eventlist.data;
          if ((eventlist.data & 0x20000) != 0) {
            goto LABEL_32;
          }
LABEL_26:
          if ((v16 & 0x10000) == 0)
          {
            if ((v16 & 0x40000) != 0)
            {
              unint64_t v17 = "Terminated due to code signing error";
              goto LABEL_34;
            }

LABEL_35:
            if (DNBLogEnabledForAny(2)) {
              _DNBLogThreaded("waitpid_process_thread (): setting exit status for pid = %i to %i", v5, v15);
            }
            DNBProcessSetExitStatus(v5, v19);
            return 0LL;
          }

          unint64_t v17 = "Terminated due to decrypt failure";
LABEL_34:
          DNBProcessSetExitInfo(v5, v17);
          goto LABEL_35;
        }

        if (v7) {
          _DNBLogThreaded("waitpid (%i) -> SIGNALED (signal = %i)", v5, v6);
        }
      }
    }
  }

  while (*__error() == 4);
  if (DNBLogEnabled())
  {
    int v12 = *__error();
    BOOL v13 = __error();
    uint64_t v14 = strerror(*v13);
    _DNBLogError("kqueue failed with error: (%d): %s", v12, v14);
  }

  return 0LL;
}

    abort();
  }

  if (v8 <= 1) {
    uint64_t v9 = 1LL;
  }
  else {
    uint64_t v9 = (v6 - *a1) / 24;
  }
  uint64_t v10 = *a1;
  while (1)
  {
    uint64_t v11 = *(void *)v10;
    v10 += 24;
    if (!v11) {
      return 0LL;
    }
    if (!--v9) {
      goto LABEL_8;
    }
  }

    unint64_t v20 = v30;
    operator delete(v18);
LABEL_38:
    unint64_t v18 = v29;
    int v12 = v45;
    BOOL v13 = a5;
LABEL_14:
    ++v17;
  }

  while (v17 != v48);
  if (v44 == (v20 - v18) >> 2)
  {
    LoHi[*(unsigned int *)v18] = *((_DWORD *)v18 + 1);
    uint64_t v14 = *(unsigned int *)v18;
    goto LABEL_50;
  }

  if (v18 != v20)
  {
    uint64_t v41 = v18;
    do
    {
      uint64_t v42 = *(_DWORD *)v41;
      v41 += 4;
      (*(void (**)(DNBArchMachARM64 *, void, uint64_t))(*(void *)this + 176LL))(this, v42, a6);
    }

    while (v41 != v20);
  }

  uint64_t v14 = 0xFFFFFFFFLL;
  if (v18) {
LABEL_50:
  }
    operator delete(v18);
LABEL_51:
  if (v12) {
LABEL_52:
  }
    operator delete(v12);
  return v14;
}

uint64_t DNBProcessSetExitInfo(int a1, const char *a2)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      int v6 = (uint64_t *)v2;
    }
    else {
      int v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }

  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return 0LL;
  }
  int v8 = *(MachProcess **)(v3 + 40);
  uint64_t v9 = *(std::__shared_weak_count **)(v3 + 48);
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
    MachProcess::SetExitInfo(v8, a2);
    do
      unint64_t v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

  else
  {
    MachProcess::SetExitInfo(v8, a2);
  }

  return 1LL;
}

uint64_t DNBProcessSetExitStatus(int a1, int a2)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      int v6 = (uint64_t *)v2;
    }
    else {
      int v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }

  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return 0LL;
  }
  uint64_t v8 = *(void *)(v3 + 40);
  uint64_t v9 = *(std::__shared_weak_count **)(v3 + 48);
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
    *(_DWORD *)(v8 + 72) = a2;
    MachProcess::SetState(v8, 9u);
    do
      unint64_t v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

  else
  {
    *(_DWORD *)(v8 + 72) = a2;
    MachProcess::SetState(v8, 9u);
  }

  return 1LL;
}

const char **DNBProcessLaunch( RNBContext *a1, char *a2, const char **a3, const char **a4, const char **a5, char *a6, char *a7, char *a8, char a9, int a10, char *a11, char *a12, size_t a13)
{
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded( "%s(path='%s', argv = %p, envp = %p, working_dir=%s, stdin=%s, stdout=%s, stderr=%s, no-stdio=%i, launch_flavor = %u, disable_aslr = %d, err = %p, err_len = %llu) called...",  "DNBProcessLaunch",  a2,  a3,  a4,  (const char *)a5,  a6,  a7,  a8,  a9,  *((_DWORD *)a1 + 76),  a10,  a12,  a13);
  }
  if (a12) {
    BOOL v21 = a13 == 0;
  }
  else {
    BOOL v21 = 1;
  }
  int v22 = !v21;
  if (!v21) {
    *a12 = 0;
  }
  if (stat(a2, &v42) == -1)
  {
    uint64_t v30 = __error();
    strerror_r(*v30, (char *)__p, 0x100uLL);
    snprintf(a12, a13, "%s (%s)", (const char *)__p, a2);
    return 0LL;
  }

  int v40 = v22;
  uint64_t v23 = (char *)operator new(0x710uLL);
  v41[0] = (uint64_t)MachProcess::MachProcess((MachProcess *)v23);
  uint64_t v24 = (std::__shared_weak_count *)operator new(0x20uLL);
  uint64_t v25 = a8;
  uint64_t v26 = v24;
  v24->__shared_owners_ = 0LL;
  p_shared_owners = (unint64_t *)&v24->__shared_owners_;
  v24->__vftable = (std::__shared_weak_count_vtbl *)off_100060C48;
  v24->__shared_weak_owners_ = 0LL;
  v24[1].__vftable = (std::__shared_weak_count_vtbl *)v23;
  v41[1] = (uint64_t)v24;
  *(_OWORD *)std::string __p = 0u;
  __int128 v44 = 0u;
  uint64_t v28 = MachProcess::LaunchForDebug( (unsigned int *)v23,  a2,  a3,  a4,  a5,  a6,  a7,  v25,  a9,  *((_DWORD *)a1 + 76),  a10,  a11,  (int8x16_t **)a1 + 56,  (uint64_t)__p);
  if (a12)
  {
    *a12 = 0;
    if (LODWORD(__p[0]))
    {
      uint64_t v29 = (const char *)DNBError::AsString((DNBError *)__p);
      if (v29)
      {
        strlcpy(a12, v29, a13 - 1);
        a12[a13 - 1] = 0;
      }
    }
  }

  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("(DebugNub) new pid is %d...", (_DWORD)v28);
  }
  if (!(_DWORD)v28) {
    goto LABEL_30;
  }
  spawn_waitpid_thread((int)v28);
  if (!MachTask::TaskPortForProcessID((MachTask *)(v23 + 104), (DNBError *)__p, 0))
  {
    if (DNBLogEnabled()) {
      _DNBLog( 0LL,  (uint64_t)"Could not get task port for process, sending SIGKILL and exiting.",  v31,  v32,  v33,  v34,  v35,  v36,  v39);
    }
    kill(9, (int)v28);
    if (v40)
    {
      if (DNBError::AsString((DNBError *)__p))
      {
        DNBError::AsString((DNBError *)__p);
        snprintf(a12, a13, "failed to get the task for process %i (%s)");
      }

      else
      {
        snprintf(a12, a13, "failed to get the task for process %i");
      }
    }

LABEL_30:
    if (SHIBYTE(v44) < 0) {
      operator delete(__p[1]);
    }
    uint64_t v28 = 0LL;
    goto LABEL_33;
  }

  if (SHIBYTE(v44) < 0) {
    operator delete(__p[1]);
  }
  do
LABEL_33:
    unint64_t v37 = __ldaxr(p_shared_owners);
  while (__stlxr(v37 - 1, p_shared_owners));
  if (!v37)
  {
    ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
    std::__shared_weak_count::__release_weak(v26);
  }

  return v28;
}

        if (((char)v27.__r_.__value_.__s.__size_ & 0x80000000) == 0)
        {
LABEL_32:
          StdStringExtractor::~StdStringExtractor(v28);
          return v14;
        }

      v13 += v67.cmdsize;
      ++v15;
      uint64_t result = 1LL;
      if (v15 >= *(_DWORD *)(a5 + 16)) {
        return result;
      }
    }

    int v19 = MachTask::ReadMemory(v8, v13, 0x38uLL, (char *)&v68);
    if (!v19) {
      return 0LL;
    }
    DNBBreakpointList::RemoveTrapsFromBuffer((void *)(a1 + 1640), v13, v19, (char *)&v68);
    if (v19 != 56) {
      return 0LL;
    }
    memset(v77, 0, 24);
    uint64_t v76 = 0;
    *(_OWORD *)__s = *(_OWORD *)&v68.__r_.__value_.__r.__words[1];
    std::string::assign((std::string *)v77, __s);
    *(void *)&unint64_t v20 = v69;
    *((void *)&v20 + 1) = DWORD1(v69);
    *(_OWORD *)&v77[24] = v20;
    *(void *)&unint64_t v20 = DWORD2(v69);
    *((void *)&v20 + 1) = HIDWORD(v69);
    uint64_t v78 = v20;
    *(void *)&unint64_t v20 = (int)v70;
    *((void *)&v20 + 1) = SDWORD1(v70);
    uint64_t v79 = v20;
    *(void *)&unint64_t v20 = DWORD2(v70);
    *((void *)&v20 + 1) = HIDWORD(v70);
    uint64_t v80 = v20;
    BOOL v21 = *(void *)(a5 + 40);
    if (v21 >= *(void *)(a5 + 48))
    {
      uint64_t v23 = std::vector<MachProcess::mach_o_segment>::__push_back_slow_path<MachProcess::mach_o_segment const&>( v64,  (uint64_t)v77);
    }

    else
    {
      if ((v77[23] & 0x80000000) != 0)
      {
        std::string::__init_copy_ctor_external( *(std::string **)(a5 + 40),  *(const std::string::value_type **)v77,  *(std::string::size_type *)&v77[8]);
      }

      else
      {
        int v22 = *(_OWORD *)v77;
        *(void *)(v21 + 16) = *(void *)&v77[16];
        *(_OWORD *)BOOL v21 = v22;
      }

      uint64_t v24 = *(_OWORD *)&v77[24];
      uint64_t v25 = v78;
      uint64_t v26 = v79;
      *(_OWORD *)(v21 + 72) = v80;
      *(_OWORD *)(v21 + 56) = v26;
      *(_OWORD *)(v21 + 40) = v25;
      *(_OWORD *)(v21 + 24) = v24;
      uint64_t v23 = (char *)(v21 + 88);
      *(void *)(a5 + 40) = v21 + 88;
    }

    *(void *)(a5 + 40) = v23;
    uint64_t v27 = v77[23];
    if ((v77[23] & 0x80000000) != 0)
    {
      if (*(void *)&v77[8] != 16LL) {
        goto LABEL_52;
      }
      uint64_t v28 = *(uint64_t **)v77;
    }

    else
    {
      if (v77[23] != 16) {
        goto LABEL_53;
      }
      uint64_t v28 = (uint64_t *)v77;
    }

    uint64_t v30 = *v28;
    uint64_t v29 = v28[1];
    if (v30 == 0x7274784563657845LL && v29 == 0x646E657073755361LL)
    {
      *(_BYTE *)(a1 + 412) = 1;
      if ((v27 & 0x80000000) == 0) {
        goto LABEL_53;
      }
      goto LABEL_52;
    }

    if ((v77[23] & 0x80000000) != 0) {
LABEL_52:
    }
      operator delete(*(void **)v77);
LABEL_53:
    cmd = v67.cmd;
    goto LABEL_54;
  }

  return 0LL;
}

uint64_t spawn_waitpid_thread(int a1)
{
  int v2 = kqueue();
  if (v2 == -1)
  {
    if (DNBLogEnabled()) {
      _DNBLogError("Could not get kqueue for pid = %i.", a1);
    }
    int v4 = (void *)a1;
  }

  else
  {
    int v3 = v2;
    pthread_t v10 = 0LL;
    int v4 = (void *)a1;
    changelist.int ident = a1;
    *(void *)&changelist.filter = 0x860000000001FFFBLL;
    changelist.int data = 0LL;
    changelist.uint data = 0LL;
    int v5 = kevent(v2, &changelist, 1, 0LL, 0, 0LL);
    if (v5)
    {
      int v6 = v5;
      if (DNBLogEnabled()) {
        _DNBLogError("Failed to register kqueue NOTE_EXIT event for pid %i, error: %d.", a1, v6);
      }
    }

    else if (!pthread_create(&v10, 0LL, (void *(__cdecl *)(void *))kqueue_thread, (void *)v3))
    {
      int ident = v10;
      return pthread_detach(ident);
    }
  }

  changelist.int ident = 0LL;
  uint64_t result = pthread_create((pthread_t *)&changelist, 0LL, (void *(__cdecl *)(void *))waitpid_thread, v4);
  if ((_DWORD)result) {
    return result;
  }
  int ident = (_opaque_pthread_t *)changelist.ident;
  return pthread_detach(ident);
}

uint64_t AddProcessToMap(int a1, uint64_t *a2)
{
  uint64_t v4 = GetProcessMap(BOOL)::g_process_map_ptr;
  if (!GetProcessMap(BOOL)::g_process_map_ptr)
  {
    pthread_mutex_lock(&GetProcessMap(BOOL)::g_process_map_mutex);
    if (!GetProcessMap(BOOL)::g_process_map_ptr)
    {
      int v5 = operator new(0x18uLL);
      v5[2] = 0LL;
      v5[1] = 0LL;
      *int v5 = v5 + 1;
      GetProcessMap(BOOL)::g_process_map_ptr = (uint64_t)v5;
    }

    pthread_mutex_unlock(&GetProcessMap(BOOL)::g_process_map_mutex);
    uint64_t v4 = GetProcessMap(BOOL)::g_process_map_ptr;
    if (!GetProcessMap(BOOL)::g_process_map_ptr) {
      return 0LL;
    }
  }

  uint64_t v7 = *a2;
  int v6 = (std::__shared_weak_count *)a2[1];
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      unint64_t v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }

  unint64_t v11 = (uint64_t **)(v4 + 8);
  pthread_t v10 = *(uint64_t **)(v4 + 8);
  if (v10)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v12 = (uint64_t **)v10;
        int v13 = *((_DWORD *)v10 + 8);
        if (v13 <= a1) {
          break;
        }
        pthread_t v10 = *v12;
        unint64_t v11 = v12;
        if (!*v12) {
          goto LABEL_15;
        }
      }

      if (v13 >= a1) {
        break;
      }
      pthread_t v10 = v12[1];
      if (!v10)
      {
        unint64_t v11 = v12 + 1;
        goto LABEL_15;
      }
    }

    if (v6)
    {
      unint64_t v18 = (unint64_t *)&v6->__shared_owners_;
      do
        unint64_t v19 = __ldaxr(v18);
      while (__stlxr(v19 - 1, v18));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }

  else
  {
    unint64_t v12 = (uint64_t **)(v4 + 8);
LABEL_15:
    uint64_t v14 = operator new(0x38uLL);
    v14[8] = a1;
    *((void *)v14 + 5) = v7;
    *((void *)v14 + 6) = v6;
    *(void *)uint64_t v14 = 0LL;
    *((void *)v14 + 1) = 0LL;
    *((void *)v14 + 2) = v12;
    *unint64_t v11 = (uint64_t *)v14;
    uint64_t v15 = **(void **)v4;
    if (v15)
    {
      *(void *)uint64_t v4 = v15;
      int v16 = *v11;
    }

    else
    {
      int v16 = (uint64_t *)v14;
    }

    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v4 + 8), v16);
    ++*(void *)(v4 + 16);
  }

  return 1LL;
}

uint64_t DNBProcessGetPIDByName(char *a1)
{
  if (GetAllInfosMatchingName(a1, __p) == 1)
  {
    uint64_t v1 = *((unsigned int *)__p[0] + 10);
LABEL_4:
    operator delete(__p[0]);
    return v1;
  }

  uint64_t v1 = 0LL;
  uint64_t v2 = 0LL;
  if (__p[0]) {
    goto LABEL_4;
  }
  return v2;
}

uint64_t GetAllInfosMatchingName(char *__s, void *a2)
{
  uint64_t v2 = (char *)*a2;
  a2[1] = *a2;
  if (__s)
  {
    int v3 = __s;
    uint64_t v4 = v2;
    if (*__s)
    {
      int v6 = strrchr(__s, 47);
      if (v6) {
        int v3 = v6 + 1;
      }
      size_t v7 = strlen(v3);
      std::string __p = 0LL;
      unint64_t v37 = 0LL;
      uint64_t v38 = 0LL;
      uint64_t v8 = DNBGetAllInfos((char **)&__p);
      if (v8)
      {
        unint64_t v9 = v8;
        uint64_t v10 = 0LL;
        unsigned int v11 = 0;
        size_t v35 = v7;
        do
        {
          int v13 = (char *)__p + 648 * v10;
          if (v13[36]) {
            BOOL v14 = v13[36] == 5;
          }
          else {
            BOOL v14 = 1;
          }
          if (v14 || strncasecmp(v3, v13 + 243, 0x10uLL)) {
            goto LABEL_10;
          }
          if (v7 < 0x11)
          {
            unint64_t v18 = (char *)a2[1];
            unint64_t v25 = a2[2];
            if ((unint64_t)v18 >= v25)
            {
              uint64_t v26 = (char *)*a2;
              uint64_t v27 = 0x2C3F35BA781948B1LL * ((uint64_t)&v18[-*a2] >> 3);
              unint64_t v28 = v27 + 1;
              if ((unint64_t)(v27 + 1) > 0x6522C3F35BA781LL) {
LABEL_57:
              }
                abort();
              unint64_t v29 = 0x2C3F35BA781948B1LL * ((uint64_t)(v25 - (void)v26) >> 3);
              if (2 * v29 > v28) {
                unint64_t v28 = 2 * v29;
              }
              if (v29 >= 0x329161F9ADD3C0LL) {
                unint64_t v23 = 0x6522C3F35BA781LL;
              }
              else {
                unint64_t v23 = v28;
              }
              if (v23)
              {
                if (v23 > 0x6522C3F35BA781LL) {
LABEL_58:
                }
                  std::__throw_bad_array_new_length[abi:nn180100]();
                uint64_t v30 = (char *)operator new(648 * v23);
              }

              else
              {
                uint64_t v30 = 0LL;
              }

              uint64_t v34 = v30;
              uint64_t v31 = &v30[648 * v27];
              memcpy(v31, v13, 0x288uLL);
              uint64_t v32 = v31;
              if (v18 != v26)
              {
                do
                {
                  v18 -= 648;
                  v32 -= 648;
                  memcpy(v32, v18, 0x288uLL);
                }

                while (v18 != v26);
LABEL_45:
                unint64_t v18 = (char *)*a2;
              }

LABEL_46:
              unint64_t v12 = v31 + 648;
              *a2 = v32;
              a2[1] = v31 + 648;
              a2[2] = &v34[648 * v23];
              if (v18) {
                operator delete(v18);
              }
              size_t v7 = v35;
              goto LABEL_9;
            }
          }

          else
          {
            if (proc_pidpath(*((_DWORD *)v13 + 10), buffer, 0x400u) < 1) {
              goto LABEL_10;
            }
            uint64_t v15 = strrchr(buffer, 47);
            int v16 = v15 ? v15 + 1 : buffer;
            if (strncasecmp(v3, v16, 0x400uLL)) {
              goto LABEL_10;
            }
            int v13 = (char *)__p + 648 * v10;
            unint64_t v18 = (char *)a2[1];
            unint64_t v17 = a2[2];
            if ((unint64_t)v18 >= v17)
            {
              unint64_t v19 = (char *)*a2;
              uint64_t v20 = 0x2C3F35BA781948B1LL * ((uint64_t)&v18[-*a2] >> 3);
              unint64_t v21 = v20 + 1;
              unint64_t v22 = 0x2C3F35BA781948B1LL * ((uint64_t)(v17 - (void)v19) >> 3);
              if (2 * v22 > v21) {
                unint64_t v21 = 2 * v22;
              }
              if (v22 >= 0x329161F9ADD3C0LL) {
                unint64_t v23 = 0x6522C3F35BA781LL;
              }
              else {
                unint64_t v23 = v21;
              }
              if (v23)
              {
                if (v23 > 0x6522C3F35BA781LL) {
                  goto LABEL_58;
                }
                uint64_t v24 = (char *)operator new(648 * v23);
              }

              else
              {
                uint64_t v24 = 0LL;
              }

              uint64_t v34 = v24;
              uint64_t v31 = &v24[648 * v20];
              memcpy(v31, v13, 0x288uLL);
              uint64_t v32 = v31;
              if (v18 != v19)
              {
                do
                {
                  v18 -= 648;
                  v32 -= 648;
                  memcpy(v32, v18, 0x288uLL);
                }

                while (v18 != v19);
                goto LABEL_45;
              }

              goto LABEL_46;
            }
          }

          memcpy(v18, v13, 0x288uLL);
          unint64_t v12 = v18 + 648;
LABEL_9:
          a2[1] = v12;
LABEL_10:
          uint64_t v10 = ++v11;
        }

        while (v9 > v11);
      }

      if (__p)
      {
        unint64_t v37 = __p;
        operator delete(__p);
      }

      uint64_t v2 = (char *)*a2;
      uint64_t v4 = (char *)a2[1];
    }
  }

  else
  {
    uint64_t v4 = v2;
  }

  return 0x2C3F35BA781948B1LL * ((v4 - v2) >> 3);
}

      uint64_t v56 = 0LL;
      uint64_t v57 = 0LL;
      unint64_t v58 = 0LL;
      unint64_t v59 = -1LL;
      uint64_t v62 = 0LL;
      v63 = 0LL;
      uint64_t v61 = 0LL;
      v64 = 0u;
      v65 = 0u;
      uint64_t v66 = 0u;
      uint64_t v67 = 0;
      unint64_t v59 = *(void *)(*a3 + 8 * v21);
      uint64_t v33 = v51;
      if ((unint64_t)v51 >= v52)
      {
        uint64_t v34 = (std::string *)std::vector<MachProcess::binary_image_information>::__push_back_slow_path<MachProcess::binary_image_information const&>( (void **)&v50,  (uint64_t)&v56);
      }

      else
      {
        v51->__r_.__value_.__r.__words[0] = 0LL;
        v33->__r_.__value_.__l.__size_ = 0LL;
        v33->__r_.__value_.__l.__cap_ = 0LL;
        v33[1].__r_.__value_.__r.__words[0] = v59;
        MachProcess::mach_o_information::mach_o_information((uint64_t)&v33[1].__r_.__value_.__l.__size_, (uint64_t)&v60);
        v33[6].__r_.__value_.__s.__data_[8] = v67;
        uint64_t v34 = (std::string *)((char *)v33 + 160);
      }

      uint64_t v51 = v34;
      if (SHIBYTE(v66) < 0)
      {
        operator delete(*((void **)&v65 + 1));
        if ((SBYTE7(v65) & 0x80000000) == 0)
        {
LABEL_51:
          size_t v35 = (void **)v61;
          if (v61) {
            goto LABEL_55;
          }
          goto LABEL_29;
        }
      }

      else if ((SBYTE7(v65) & 0x80000000) == 0)
      {
        goto LABEL_51;
      }

      operator delete((void *)v64);
      size_t v35 = (void **)v61;
      if (v61)
      {
LABEL_55:
        uint64_t v36 = v62;
        unint64_t v37 = v35;
        if (v62 != v35)
        {
          do
          {
            v36 -= 11;
          }

          while (v36 != v35);
          unint64_t v37 = v61;
        }

        uint64_t v62 = v35;
        operator delete(v37);
        if ((SHIBYTE(v58) & 0x80000000) == 0) {
          goto LABEL_30;
        }
LABEL_62:
        operator delete(v56);
        goto LABEL_30;
      }

uint64_t DNBProcessAttachByName(char *__s, const timespec *a2, int8x16_t **a3, char *a4, size_t a5)
{
  if (a4 && a5) {
    *a4 = 0;
  }
  memset(__p, 0, sizeof(__p));
  uint64_t AllInfosMatchingName = GetAllInfosMatchingName(__s, __p);
  if (AllInfosMatchingName == 1)
  {
    BOOL v14 = __p[0];
    uint64_t v12 = DNBProcessAttach(*((unsigned int *)__p[0] + 10), a2, a3, a4, a5);
LABEL_11:
    operator delete(v14);
    return v12;
  }

  uint64_t v11 = AllInfosMatchingName;
  if (AllInfosMatchingName)
  {
    if (DNBLogEnabled()) {
      _DNBLogError("error: %llu processes match '%s':\n", v11, __s);
    }
    uint64_t v15 = (char *)__p[0] + 243;
    do
    {
      if (DNBLogEnabled()) {
        _DNBLogError("%6u - %s\n", *(_DWORD *)(v15 - 203), v15);
      }
      v15 += 648;
      --v11;
    }

    while (v11);
  }

  else if (DNBLogEnabled())
  {
    _DNBLogError("error: no processes match '%s'\n", __s);
  }

  uint64_t v12 = 0LL;
  uint64_t result = 0LL;
  BOOL v14 = __p[0];
  if (__p[0]) {
    goto LABEL_11;
  }
  return result;
}

uint64_t DNBProcessAttach(uint64_t a1, const timespec *a2, int8x16_t **a3, char *a4, size_t a5)
{
  if (a4) {
    BOOL v10 = a5 == 0;
  }
  else {
    BOOL v10 = 1;
  }
  char v11 = !v10;
  if (!v10) {
    *a4 = 0;
  }
  if (!getenv("LLDB_DEBUGSERVER_PATH"))
  {
    *(void *)v63 = 0xE00000001LL;
    int v64 = 1;
    int v65 = a1;
    size_t v57 = 648LL;
    if (!sysctl(v63, 4u, &v60, &v57, 0LL, 0LL) && v57 && (v62 & 2) != 0)
    {
      if (communication_fd == -1)
      {
        fwrite( "Trying to attach to a translated process with the native debugserver, exiting...\n",  0x51uLL,  1uLL,  __stderrp);
        exit(1);
      }

      DNBProcessAttach(v59, communication_fd, v58, a1);
    }
  }

  v63[0] = 0;
  size_t v60 = 4LL;
  if (sysctlbyname("sysctl.proc_translated", v63, &v60, 0LL, 0LL) != -1 && v63[0] == 1) {
    return 0xFFFFFFFFLL;
  }
  int v13 = (MachProcess *)operator new(0x710uLL);
  size_t v60 = (size_t)MachProcess::MachProcess(v13);
  BOOL v14 = (std::__shared_weak_count *)operator new(0x20uLL);
  v14->__vftable = (std::__shared_weak_count_vtbl *)off_100060C48;
  v14->__shared_owners_ = 0LL;
  v14->__shared_weak_owners_ = 0LL;
  v14[1].__vftable = (std::__shared_weak_count_vtbl *)v13;
  uint64_t v61 = v14;
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("(DebugNub) attaching to pid %d...", a1);
  }
  uint64_t v15 = MachProcess::AttachForDebug(v13, a1, a3, a4, a5);
  uint64_t v12 = v15;
  if ((_DWORD)v15)
  {
    unint64_t v54 = a4;
    size_t v55 = a5;
    char v56 = v11;
    spawn_waitpid_thread(v12);
    int v16 = "%s DNBProcessWaitForEvent (%4.4x, eEventProcessRunningStateChanged | eEventProcessStoppedStateChanged, true, INFINITE)...";
    unint64_t v17 = "%s DNBProcessWaitForEvent (%4.4x, eEventProcessRunningStateChanged | eEventProcessStoppedStateChanged, true, I"
          "NFINITE) => 0x%8.8x";
    unint64_t v18 = "nub_state_t ???";
    uint64_t v19 = v12;
    while (1)
    {
      if (DNBLogEnabledForAny(2)) {
        _DNBLogThreaded(v16, "DNBProcessAttach", v12);
      }
      if (!GetProcessMap(BOOL)::g_process_map_ptr) {
        goto LABEL_35;
      }
      uint64_t v20 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
      if (!v20) {
        goto LABEL_35;
      }
      uint64_t v21 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
      do
      {
        int v22 = *(_DWORD *)(v20 + 32);
        BOOL v23 = v22 < (int)v12;
        else {
          uint64_t v24 = (uint64_t *)(v20 + 8);
        }
        if (!v23) {
          uint64_t v21 = v20;
        }
        uint64_t v20 = *v24;
      }

      while (*v24);
      if (v21 != GetProcessMap(BOOL)::g_process_map_ptr + 8 && *(_DWORD *)(v21 + 32) <= (int)v12)
      {
        uint64_t v33 = *(void *)(v21 + 40);
        uint64_t v34 = *(std::__shared_weak_count **)(v21 + 48);
        if (v34)
        {
          uint64_t v35 = v19;
          uint64_t v36 = v18;
          unint64_t v37 = v17;
          uint64_t v38 = v16;
          p_shared_owners = (unint64_t *)&v34->__shared_owners_;
          do
            unint64_t v40 = __ldxr(p_shared_owners);
          while (__stxr(v40 + 1, p_shared_owners));
          uint64_t v25 = PThreadEvent::WaitForSetEvents((pthread_mutex_t *)(v33 + 1288), 3u, a2);
          do
            unint64_t v41 = __ldaxr(p_shared_owners);
          while (__stlxr(v41 - 1, p_shared_owners));
          if (!v41)
          {
            ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
            std::__shared_weak_count::__release_weak(v34);
          }

          int v16 = v38;
          unint64_t v17 = v37;
          unint64_t v18 = v36;
          uint64_t v19 = v35;
        }

        else
        {
          uint64_t v25 = PThreadEvent::WaitForSetEvents((pthread_mutex_t *)(v33 + 1288), 3u, a2);
        }
      }

      else
      {
LABEL_35:
        uint64_t v25 = 0LL;
      }

      if (DNBLogEnabledForAny(2)) {
        _DNBLogThreaded(v17, "DNBProcessAttach", v19, v25);
      }
      if (!(_DWORD)v25) {
        break;
      }
      if ((v25 & 3) != 0)
      {
        if (!GetProcessMap(BOOL)::g_process_map_ptr) {
          goto LABEL_51;
        }
        uint64_t v26 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
        if (!v26) {
          goto LABEL_51;
        }
        uint64_t v27 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
        do
        {
          int v28 = *(_DWORD *)(v26 + 32);
          BOOL v29 = v28 < (int)v12;
          else {
            uint64_t v30 = (uint64_t *)(v26 + 8);
          }
          if (!v29) {
            uint64_t v27 = v26;
          }
          uint64_t v26 = *v30;
        }

        while (*v30);
        if (v27 != GetProcessMap(BOOL)::g_process_map_ptr + 8 && *(_DWORD *)(v27 + 32) <= (int)v12)
        {
          stat v42 = v17;
          int v43 = v16;
          __int128 v44 = *(MachProcess **)(v27 + 40);
          __int128 v45 = *(std::__shared_weak_count **)(v27 + 48);
          if (v45)
          {
            uint64_t v53 = a2;
            v46 = (unint64_t *)&v45->__shared_owners_;
            do
              unint64_t v47 = __ldxr(v46);
            while (__stxr(v47 + 1, v46));
            unsigned int State = MachProcess::GetState(v44);
            do
              unint64_t v48 = __ldaxr(v46);
            while (__stlxr(v48 - 1, v46));
            if (!v48)
            {
              ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
              std::__shared_weak_count::__release_weak(v45);
            }

            a2 = v53;
          }

          else
          {
            unsigned int State = MachProcess::GetState(v44);
          }

          int v16 = v43;
          unint64_t v17 = v42;
          unint64_t v18 = "nub_state_t ???";
        }

        else
        {
LABEL_51:
          unsigned int State = 0;
        }

        if (DNBLogEnabledForAny(2))
        {
          uint64_t v32 = v18;
          if (State <= 0xA) {
            uint64_t v32 = off_100060C70[State];
          }
          _DNBLogThreaded( "%s process %4.4x state changed (eEventProcessStateChanged): %s",  "DNBProcessAttach",  v12,  v32);
        }

        if (State - 8 < 2)
        {
          if ((v56 & 1) != 0) {
            snprintf(v54, v55, "process exited");
          }
          goto LABEL_83;
        }

        if (State == 4 || State == 7) {
          goto LABEL_84;
        }
      }

      DNBProcessResetEvents(v12, v25);
    }

    if ((v56 & 1) != 0) {
      snprintf(v54, v55, "attached to process, but could not pause execution; attach failed");
    }
LABEL_83:
    uint64_t v12 = 0LL;
  }

LABEL_84:
  uint64_t v49 = v61;
  if (v61)
  {
    unint64_t v50 = (unint64_t *)&v61->__shared_owners_;
    do
      unint64_t v51 = __ldaxr(v50);
    while (__stlxr(v51 - 1, v50));
    if (!v51)
    {
      ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
      std::__shared_weak_count::__release_weak(v49);
    }
  }

  return v12;
}

BOOL DNBDebugserverIsTranslated(void)
{
  int v3 = 0;
  size_t v2 = 4LL;
  return sysctlbyname("sysctl.proc_translated", &v3, &v2, 0LL, 0LL) != -1 && v3 == 1;
}

uint64_t DNBProcessWaitForEvents(int a1, unsigned int a2, int a3, timespec *a4)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v4 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v4) {
    return 0LL;
  }
  uint64_t v5 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v6 = *(_DWORD *)(v4 + 32);
    BOOL v7 = v6 < a1;
    if (v6 >= a1) {
      uint64_t v8 = (uint64_t *)v4;
    }
    else {
      uint64_t v8 = (uint64_t *)(v4 + 8);
    }
    if (!v7) {
      uint64_t v5 = v4;
    }
    uint64_t v4 = *v8;
  }

  while (*v8);
  if (v5 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v5 + 32) > a1) {
    return 0LL;
  }
  uint64_t v11 = *(void *)(v5 + 40);
  uint64_t v12 = *(std::__shared_weak_count **)(v5 + 48);
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      unint64_t v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
  }

  uint64_t v15 = (pthread_mutex_t *)(v11 + 1288);
  if (a3)
  {
    uint64_t v9 = PThreadEvent::WaitForSetEvents(v15, a2, a4);
    if (!v12) {
      return v9;
    }
  }

  else
  {
    uint64_t v9 = PThreadEvent::WaitForEventsToReset(v15, a2, a4);
    if (!v12) {
      return v9;
    }
  }

  int v16 = (unint64_t *)&v12->__shared_owners_;
  do
    unint64_t v17 = __ldaxr(v16);
  while (__stlxr(v17 - 1, v16));
  if (!v17)
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }

  return v9;
}

uint64_t DNBProcessGetState(int a1)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v1 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v1) {
    return 0LL;
  }
  uint64_t v2 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v3 = *(_DWORD *)(v1 + 32);
    BOOL v4 = v3 < a1;
    if (v3 >= a1) {
      uint64_t v5 = (uint64_t *)v1;
    }
    else {
      uint64_t v5 = (uint64_t *)(v1 + 8);
    }
    if (!v4) {
      uint64_t v2 = v1;
    }
    uint64_t v1 = *v5;
  }

  while (*v5);
  if (v2 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v2 + 32) > a1) {
    return 0LL;
  }
  uint64_t v8 = *(MachProcess **)(v2 + 40);
  uint64_t v9 = *(std::__shared_weak_count **)(v2 + 48);
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
    uint64_t State = MachProcess::GetState(v8);
    do
      unint64_t v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }

    return State;
  }

  return MachProcess::GetState(v8);
}

const char *DNBStateAsString(unsigned int a1)
{
  if (a1 > 0xA) {
    return "nub_state_t ???";
  }
  else {
    return off_100060C70[a1];
  }
}

void DNBProcessResetEvents(int a1, int a2)
{
  if (GetProcessMap(BOOL)::g_process_map_ptr)
  {
    uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
    if (v2)
    {
      uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
      do
      {
        int v4 = *(_DWORD *)(v2 + 32);
        BOOL v5 = v4 < a1;
        if (v4 >= a1) {
          int v6 = (uint64_t *)v2;
        }
        else {
          int v6 = (uint64_t *)(v2 + 8);
        }
        if (!v5) {
          uint64_t v3 = v2;
        }
        uint64_t v2 = *v6;
      }

      while (*v6);
      if (v3 != GetProcessMap(BOOL)::g_process_map_ptr + 8 && *(_DWORD *)(v3 + 32) <= a1)
      {
        uint64_t v7 = *(void *)(v3 + 40);
        uint64_t v8 = *(std::__shared_weak_count **)(v3 + 48);
        if (v8)
        {
          p_shared_owners = (unint64_t *)&v8->__shared_owners_;
          do
            unint64_t v10 = __ldxr(p_shared_owners);
          while (__stxr(v10 + 1, p_shared_owners));
          PThreadEvent::ResetEvents((pthread_mutex_t *)(v7 + 1288), a2);
          do
            unint64_t v11 = __ldaxr(p_shared_owners);
          while (__stlxr(v11 - 1, p_shared_owners));
          if (!v11)
          {
            ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
            std::__shared_weak_count::__release_weak(v8);
          }
        }

        else
        {
          PThreadEvent::ResetEvents((pthread_mutex_t *)(v7 + 1288), a2);
        }
      }
    }
  }

uint64_t DNBGetAllInfos(char **a1)
{
  int v11 = 0;
  size_t v9 = 0LL;
  *(void *)unint64_t v10 = 0xE00000001LL;
  if (sysctl(v10, 3u, 0LL, &v9, 0LL, 0LL) < 0)
  {
    a1[1] = *a1;
    perror("sysctl (mib, miblen, NULL, &num_processes, NULL, 0)");
    return 0LL;
  }

  else
  {
    uint64_t v2 = *a1;
    uint64_t v3 = a1[1];
    size_t v4 = 0x2C3F35BA781948B1LL * ((v3 - *a1) >> 3);
    if (v9 / 0x288 <= v4)
    {
      if (v9 / 0x288 < v4)
      {
        uint64_t v3 = &v2[648 * (v9 / 0x288)];
        a1[1] = v3;
      }
    }

    else
    {
      std::vector<kinfo_proc>::__append(a1, v9 / 0x288 - v4);
      uint64_t v2 = *a1;
      uint64_t v3 = a1[1];
    }

    size_t v9 = v3 - v2;
    if (sysctl(v10, 3u, v2, &v9, 0LL, 0LL) < 0)
    {
      uint64_t result = 0LL;
      a1[1] = *a1;
    }

    else
    {
      BOOL v5 = *a1;
      int v6 = a1[1];
      size_t v7 = 0x2C3F35BA781948B1LL * ((v6 - *a1) >> 3);
      if (v9 / 0x288 <= v7)
      {
        if (v9 / 0x288 < v7)
        {
          int v6 = &v5[648 * (v9 / 0x288)];
          a1[1] = v6;
        }
      }

      else
      {
        std::vector<kinfo_proc>::__append(a1, v9 / 0x288 - v7);
        BOOL v5 = *a1;
        int v6 = a1[1];
      }

      return 0x2C3F35BA781948B1LL * ((v6 - v5) >> 3);
    }
  }

  return result;
}

double DNBGetDyldProcessState@<D0>(int a1@<W0>, uint64_t a2@<X8>, __n128 a3@<Q0>)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    goto LABEL_12;
  }
  uint64_t v3 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v3) {
    goto LABEL_12;
  }
  uint64_t v4 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v5 = *(_DWORD *)(v3 + 32);
    BOOL v6 = v5 < a1;
    if (v5 >= a1) {
      size_t v7 = (uint64_t *)v3;
    }
    else {
      size_t v7 = (uint64_t *)(v3 + 8);
    }
    if (!v6) {
      uint64_t v4 = v3;
    }
    uint64_t v3 = *v7;
  }

  while (*v7);
  if (v4 != GetProcessMap(BOOL)::g_process_map_ptr + 8 && *(_DWORD *)(v4 + 32) <= a1)
  {
    uint64_t v8 = *(MachProcess **)(v4 + 40);
    size_t v9 = *(std::__shared_weak_count **)(v4 + 48);
    if (v9)
    {
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        unint64_t v11 = __ldxr(p_shared_owners);
      while (__stxr(v11 + 1, p_shared_owners));
      a3.n128_f64[0] = MachProcess::GetDyldProcessState(v8, (_OWORD *)a2);
      do
        unint64_t v12 = __ldaxr(p_shared_owners);
      while (__stlxr(v12 - 1, p_shared_owners));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *, __n128))v9->__on_zero_shared)(v9, a3);
        std::__shared_weak_count::__release_weak(v9);
      }
    }

    else
    {
      a3.n128_f64[0] = MachProcess::GetDyldProcessState(v8, (_OWORD *)a2);
    }
  }

  else
  {
LABEL_12:
    *(void *)a2 = 0LL;
    *(void *)(a2 + 8) = 0LL;
  }

  return a3.n128_f64[0];
}

uint64_t DNBProcessAttachWait( RNBContext *a1, char *a2, int a3, timespec *a4, useconds_t a5, char *a6, size_t a7, unsigned int (*a8)(void *), void *a9)
{
  *(_OWORD *)unint64_t v40 = 0u;
  __int128 v41 = 0u;
  memset(v39, 0, sizeof(v39));
  int v17 = *((_DWORD *)a1 + 76);
  unint64_t v18 = MachProcess::PrepareForAttach(a2, v17, 1, (uint64_t)v40);
  if (LODWORD(v40[0]))
  {
    if (DNBLogEnabled())
    {
      uint64_t v19 = (const char *)DNBError::AsString((DNBError *)v40);
      _DNBLogError("Error in PrepareForAttach: %s", v19);
    }

    uint64_t v20 = 0LL;
    goto LABEL_51;
  }

  uint64_t v21 = (MachProcess *)v18;
  if (v18) {
    BOOL v22 = 1;
  }
  else {
    BOOL v22 = a3 == 0;
  }
  size_t v35 = a7;
  if (v22) {
    uint64_t AllInfosMatchingName = 0LL;
  }
  else {
    uint64_t AllInfosMatchingName = GetAllInfosMatchingName(a2, v39);
  }
  uint64_t v33 = a1;
  uint64_t v34 = a6;
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("Waiting for '%s' to appear...\n", a2);
  }
  uint64_t v36 = (void *)v39[0];
  uint64_t v24 = v39[0] + 40LL;
  while (1)
  {
    if (v21)
    {
      id v25 = MachProcess::CheckForProcess((uint64_t)v21, v17);
      if ((_DWORD)v25)
      {
        uint64_t v31 = (uint64_t)v25;
LABEL_46:
        if (DNBLogEnabledForAny(2)) {
          _DNBLogThreaded("Attaching to %s with pid %i...\n", a2, v31);
        }
        usleep(a5);
        uint64_t v20 = DNBProcessAttach(v31, a4, (int8x16_t **)v33 + 56, v34, v35);
        uint64_t v30 = v36;
        goto LABEL_49;
      }
    }

    else
    {
      __p.tv_sec = 0LL;
      *(void *)&__p.tv_usec = 0LL;
      uint64_t v38 = 0LL;
      uint64_t v26 = GetAllInfosMatchingName(a2, &__p);
      if (v26)
      {
        for (uint64_t i = 0LL; i != v26; ++i)
        {
          uint64_t v31 = *(unsigned int *)(__p.tv_sec + 648 * i + 40);
          int v28 = (_DWORD *)v24;
          uint64_t v29 = AllInfosMatchingName;
          if (AllInfosMatchingName)
          {
            while ((_DWORD)v31 != *v28)
            {
              v28 += 162;
              if (!--v29) {
                goto LABEL_20;
              }
            }
          }

          else
          {
LABEL_20:
            if ((_DWORD)v31) {
              goto LABEL_27;
            }
          }
        }
      }

      uint64_t v31 = 0LL;
LABEL_27:
      if (__p.tv_sec) {
        operator delete((void *)__p.tv_sec);
      }
      if ((_DWORD)v31) {
        goto LABEL_46;
      }
    }

    if (a4)
    {
      gettimeofday(&__p, 0LL);
      if (__p.tv_sec > a4->tv_sec || __p.tv_sec >= a4->tv_sec && a4->tv_nsec < 1000LL * __p.tv_usec) {
        break;
      }
    }

    if (a8 && a8(a9))
    {
      uint64_t v30 = v36;
      if (DNBLogEnabledForAny(2)) {
        _DNBLogThreaded("DNBProcessAttachWait cancelled by should_cancel callback.");
      }
      uint64_t v20 = 0LL;
LABEL_49:
      MachProcess::CleanupAfterAttach(v21, v17, (DNBError *)((_DWORD)v20 != 0), (DNBError *)v40);
      if (!v30) {
        goto LABEL_51;
      }
      goto LABEL_50;
    }

    usleep(a5);
  }

  if (v34 && v35) {
    snprintf(v34, v35, "operation timed out");
  }
  uint64_t v30 = v36;
  if (DNBLogEnabled()) {
    _DNBLogError("error: waiting for process '%s' timed out.\n", a2);
  }
  uint64_t v20 = 0LL;
  if (v36) {
LABEL_50:
  }
    operator delete(v30);
LABEL_51:
  if (SHIBYTE(v41) < 0) {
    operator delete(v40[1]);
  }
  return v20;
}

uint64_t DNBProcessDetach(int a1)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v1 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v1) {
    return 0LL;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v1 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      BOOL v6 = (uint64_t *)v1;
    }
    else {
      BOOL v6 = (uint64_t *)(v1 + 8);
    }
    if (!v5) {
      uint64_t v3 = v1;
    }
    uint64_t v1 = *v6;
  }

  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return 0LL;
  }
  unint64_t v10 = *(MachProcess **)(v3 + 40);
  size_t v9 = *(std::__shared_weak_count **)(v3 + 48);
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }

  if (DNBLogEnabled()) {
    _DNBLogThreaded("Disabling breakpoints and watchpoints, and detaching from %d.", a1);
  }
  MachProcess::DisableAllBreakpoints(v10, 1);
  MachProcess::DisableAllWatchpoints(v10, 1);
  uint64_t v7 = MachProcess::Detach(v10);
  if (v9)
  {
    int v13 = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

  return v7;
}

uint64_t DNBProcessKill(int a1)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v1 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v1) {
    return 0LL;
  }
  uint64_t v2 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v3 = *(_DWORD *)(v1 + 32);
    BOOL v4 = v3 < a1;
    if (v3 >= a1) {
      BOOL v5 = (uint64_t *)v1;
    }
    else {
      BOOL v5 = (uint64_t *)(v1 + 8);
    }
    if (!v4) {
      uint64_t v2 = v1;
    }
    uint64_t v1 = *v5;
  }

  while (*v5);
  if (v2 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v2 + 32) > a1) {
    return 0LL;
  }
  uint64_t v8 = *(MachProcess **)(v2 + 40);
  size_t v9 = *(std::__shared_weak_count **)(v2 + 48);
  if (!v9) {
    return MachProcess::Kill(v8, 0LL);
  }
  p_shared_owners = (unint64_t *)&v9->__shared_owners_;
  do
    unint64_t v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  uint64_t v6 = MachProcess::Kill(v8, 0LL);
  do
    unint64_t v12 = __ldaxr(p_shared_owners);
  while (__stlxr(v12 - 1, p_shared_owners));
  if (!v12)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }

  return v6;
}

BOOL DNBProcessSignal(int a1, int a2)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      uint64_t v6 = (uint64_t *)v2;
    }
    else {
      uint64_t v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }

  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return 0LL;
  }
  size_t v9 = *(MachProcess **)(v3 + 40);
  unint64_t v10 = *(std::__shared_weak_count **)(v3 + 48);
  if (!v10) {
    return MachProcess::Signal(v9, a2, 0LL);
  }
  p_shared_owners = (unint64_t *)&v10->__shared_owners_;
  do
    unint64_t v12 = __ldxr(p_shared_owners);
  while (__stxr(v12 + 1, p_shared_owners));
  BOOL v7 = MachProcess::Signal(v9, a2, 0LL);
  do
    unint64_t v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }

  return v7;
}

BOOL DNBProcessInterrupt(int a1)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v1 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v1) {
    return 0LL;
  }
  uint64_t v2 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v3 = *(_DWORD *)(v1 + 32);
    BOOL v4 = v3 < a1;
    if (v3 >= a1) {
      BOOL v5 = (uint64_t *)v1;
    }
    else {
      BOOL v5 = (uint64_t *)(v1 + 8);
    }
    if (!v4) {
      uint64_t v2 = v1;
    }
    uint64_t v1 = *v5;
  }

  while (*v5);
  if (v2 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v2 + 32) > a1) {
    return 0LL;
  }
  uint64_t v8 = *(MachProcess **)(v2 + 40);
  size_t v9 = *(std::__shared_weak_count **)(v2 + 48);
  if (!v9) {
    return MachProcess::Interrupt(v8);
  }
  p_shared_owners = (unint64_t *)&v9->__shared_owners_;
  do
    unint64_t v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  BOOL v6 = MachProcess::Interrupt(v8);
  do
    unint64_t v12 = __ldaxr(p_shared_owners);
  while (__stlxr(v12 - 1, p_shared_owners));
  if (!v12)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }

  return v6;
}

BOOL DNBProcessSendEvent(int a1, char *a2)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      BOOL v6 = (uint64_t *)v2;
    }
    else {
      BOOL v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }

  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return 0LL;
  }
  size_t v9 = *(MachProcess **)(v3 + 40);
  unint64_t v10 = *(std::__shared_weak_count **)(v3 + 48);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }

  *(_OWORD *)timeval __p = 0u;
  __int128 v16 = 0u;
  BOOL v7 = MachProcess::SendEvent(v9, a2, (DNBError *)__p);
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[1]);
  }
  if (v10)
  {
    unint64_t v13 = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  return v7;
}

BOOL DNBProcessGetExitStatus(int a1, int *a2)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0LL;
  }
  uint64_t v4 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v5 = *(_DWORD *)(v2 + 32);
    BOOL v6 = v5 < a1;
    if (v5 >= a1) {
      BOOL v7 = (uint64_t *)v2;
    }
    else {
      BOOL v7 = (uint64_t *)(v2 + 8);
    }
    if (!v6) {
      uint64_t v4 = v2;
    }
    uint64_t v2 = *v7;
  }

  while (*v7);
  if (v4 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v4 + 32) > a1) {
    return 0LL;
  }
  unint64_t v11 = *(MachProcess **)(v4 + 40);
  unint64_t v10 = *(std::__shared_weak_count **)(v4 + 48);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
  }

  int State = MachProcess::GetState(v11);
  BOOL v8 = State == 9;
  if (a2 && State == 9) {
    *a2 = *((_DWORD *)v11 + 18);
  }
  if (v10)
  {
    uint64_t v15 = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  return v8;
}

void *DNBProcessGetExitInfo(int a1)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v1 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v1) {
    return 0LL;
  }
  uint64_t v2 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v3 = *(_DWORD *)(v1 + 32);
    BOOL v4 = v3 < a1;
    if (v3 >= a1) {
      int v5 = (uint64_t *)v1;
    }
    else {
      int v5 = (uint64_t *)(v1 + 8);
    }
    if (!v4) {
      uint64_t v2 = v1;
    }
    uint64_t v1 = *v5;
  }

  while (*v5);
  if (v2 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v2 + 32) > a1) {
    return 0LL;
  }
  uint64_t v8 = *(void *)(v2 + 40);
  size_t v9 = *(std::__shared_weak_count **)(v2 + 48);
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }

  BOOL v6 = (void *)(v8 + 80);
  if (v9)
  {
    unint64_t v12 = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

  return v6;
}

uint64_t DNBThreadGetName(int a1, uint64_t a2)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      BOOL v6 = (uint64_t *)v2;
    }
    else {
      BOOL v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }

  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return 0LL;
  }
  size_t v9 = *(MachProcess **)(v3 + 40);
  unint64_t v10 = *(std::__shared_weak_count **)(v3 + 48);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
    uint64_t Name = MachProcess::ThreadGetName(v9, a2);
    do
      unint64_t v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }

    return Name;
  }

  return MachProcess::ThreadGetName(v9, a2);
}

BOOL DNBThreadGetIdentifierInfo(int a1, uint64_t a2, thread_identifier_info *a3)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v3 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v3) {
    return 0LL;
  }
  uint64_t v4 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v5 = *(_DWORD *)(v3 + 32);
    BOOL v6 = v5 < a1;
    if (v5 >= a1) {
      BOOL v7 = (uint64_t *)v3;
    }
    else {
      BOOL v7 = (uint64_t *)(v3 + 8);
    }
    if (!v6) {
      uint64_t v4 = v3;
    }
    uint64_t v3 = *v7;
  }

  while (*v7);
  if (v4 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v4 + 32) > a1) {
    return 0LL;
  }
  uint64_t v10 = *(void *)(v4 + 40);
  unint64_t v11 = *(std::__shared_weak_count **)(v4 + 48);
  if (!v11) {
    return MachThreadList::GetIdentifierInfo((MachThreadList *)(v10 + 968), a2, a3);
  }
  p_shared_owners = (unint64_t *)&v11->__shared_owners_;
  do
    unint64_t v13 = __ldxr(p_shared_owners);
  while (__stxr(v13 + 1, p_shared_owners));
  BOOL IdentifierInfo = MachThreadList::GetIdentifierInfo((MachThreadList *)(v10 + 968), a2, a3);
  do
    unint64_t v14 = __ldaxr(p_shared_owners);
  while (__stlxr(v14 - 1, p_shared_owners));
  if (!v14)
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }

  return IdentifierInfo;
}

uint64_t DNBThreadGetState(int a1, uint64_t a2)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      BOOL v6 = (uint64_t *)v2;
    }
    else {
      BOOL v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }

  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return 0LL;
  }
  size_t v9 = *(MachProcess **)(v3 + 40);
  uint64_t v10 = *(std::__shared_weak_count **)(v3 + 48);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
    uint64_t State = MachProcess::ThreadGetState(v9, a2);
    do
      unint64_t v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }

    return State;
  }

  return MachProcess::ThreadGetState(v9, a2);
}

double DNBGetGenealogyInfoForThread@<D0>( BOOL *a1@<X2>, int a2@<W0>, unint64_t a3@<X1>, void *a4@<X8>)
{
  *a4 = 0LL;
  a4[1] = 0LL;
  if (GetProcessMap(BOOL)::g_process_map_ptr)
  {
    uint64_t v5 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
    if (v5)
    {
      uint64_t v6 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
      do
      {
        int v7 = *(_DWORD *)(v5 + 32);
        BOOL v8 = v7 < a2;
        if (v7 >= a2) {
          size_t v9 = (uint64_t *)v5;
        }
        else {
          size_t v9 = (uint64_t *)(v5 + 8);
        }
        if (!v8) {
          uint64_t v6 = v5;
        }
        uint64_t v5 = *v9;
      }

      while (*v9);
      if (v6 != GetProcessMap(BOOL)::g_process_map_ptr + 8 && *(_DWORD *)(v6 + 32) <= a2)
      {
        uint64_t v10 = *(MachProcess **)(v6 + 40);
        unint64_t v11 = *(std::__shared_weak_count **)(v6 + 48);
        if (v11)
        {
          p_shared_owners = (unint64_t *)&v11->__shared_owners_;
          do
            unint64_t v13 = __ldxr(p_shared_owners);
          while (__stxr(v13 + 1, p_shared_owners));
          MachProcess::GetGenealogyInfoForThread(v10, a1, a3, &v17);
          double result = *(double *)&v17;
          *(_OWORD *)a4 = v17;
          uint64_t v15 = (unint64_t *)&v11->__shared_owners_;
          do
            unint64_t v16 = __ldaxr(v15);
          while (__stlxr(v16 - 1, v15));
          if (!v16)
          {
            ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
            std::__shared_weak_count::__release_weak(v11);
          }
        }

        else
        {
          MachProcess::GetGenealogyInfoForThread(v10, a1, a3, &v17);
          double result = *(double *)&v17;
          *(_OWORD *)a4 = v17;
        }
      }
    }
  }

  return result;
}

double DNBGetGenealogyImageInfo@<D0>(int a1@<W0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  *a3 = 0LL;
  a3[1] = 0LL;
  if (GetProcessMap(BOOL)::g_process_map_ptr)
  {
    uint64_t v4 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
    if (v4)
    {
      uint64_t v5 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
      do
      {
        int v6 = *(_DWORD *)(v4 + 32);
        BOOL v7 = v6 < a1;
        if (v6 >= a1) {
          BOOL v8 = (uint64_t *)v4;
        }
        else {
          BOOL v8 = (uint64_t *)(v4 + 8);
        }
        if (!v7) {
          uint64_t v5 = v4;
        }
        uint64_t v4 = *v8;
      }

      while (*v8);
      if (v5 != GetProcessMap(BOOL)::g_process_map_ptr + 8 && *(_DWORD *)(v5 + 32) <= a1)
      {
        size_t v9 = *(MachProcess **)(v5 + 40);
        uint64_t v10 = *(std::__shared_weak_count **)(v5 + 48);
        if (v10)
        {
          p_shared_owners = (unint64_t *)&v10->__shared_owners_;
          do
            unint64_t v12 = __ldxr(p_shared_owners);
          while (__stxr(v12 + 1, p_shared_owners));
          MachProcess::GetGenealogyImageInfo(v9, a2, &v16);
          double result = *(double *)&v16;
          *(_OWORD *)a3 = v16;
          unint64_t v14 = (unint64_t *)&v10->__shared_owners_;
          do
            unint64_t v15 = __ldaxr(v14);
          while (__stlxr(v15 - 1, v14));
          if (!v15)
          {
            ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
            std::__shared_weak_count::__release_weak(v10);
          }
        }

        else
        {
          MachProcess::GetGenealogyImageInfo(v9, a2, &v16);
          double result = *(double *)&v16;
          *(_OWORD *)a3 = v16;
        }
      }
    }
  }

  return result;
}

void DNBGetRequestedQoSForThread( int a1@<W0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    goto LABEL_12;
  }
  uint64_t v5 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v5) {
    goto LABEL_12;
  }
  uint64_t v6 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v7 = *(_DWORD *)(v5 + 32);
    BOOL v8 = v7 < a1;
    if (v7 >= a1) {
      size_t v9 = (uint64_t *)v5;
    }
    else {
      size_t v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }

  while (*v9);
  if (v6 != GetProcessMap(BOOL)::g_process_map_ptr + 8 && *(_DWORD *)(v6 + 32) <= a1)
  {
    uint64_t v10 = *(MachProcess **)(v6 + 40);
    unint64_t v11 = *(std::__shared_weak_count **)(v6 + 48);
    if (v11)
    {
      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
      MachProcess::GetRequestedQoS(v10, a2, a3, a4, a5);
      do
        unint64_t v14 = __ldaxr(p_shared_owners);
      while (__stlxr(v14 - 1, p_shared_owners));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }

    else
    {
      MachProcess::GetRequestedQoS(v10, a2, a3, a4, a5);
    }
  }

  else
  {
LABEL_12:
    *(_OWORD *)(a5 + 16) = 0u;
    *(_OWORD *)(a5 + 32) = 0u;
    *(_OWORD *)a5 = 0u;
    *(_DWORD *)(a5 + 48) = -1;
  }

uint64_t DNBGetPThreadT(int a1, uint64_t a2)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return -1LL;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return -1LL;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      uint64_t v6 = (uint64_t *)v2;
    }
    else {
      uint64_t v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }

  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return -1LL;
  }
  size_t v9 = *(MachProcess **)(v3 + 40);
  uint64_t v10 = *(std::__shared_weak_count **)(v3 + 48);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
    uint64_t PThreadT = MachProcess::GetPThreadT(v9, a2);
    do
      unint64_t v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }

    return PThreadT;
  }

  return MachProcess::GetPThreadT(v9, a2);
}

uint64_t DNBGetDispatchQueueT(int a1, uint64_t a2)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return -1LL;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return -1LL;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      uint64_t v6 = (uint64_t *)v2;
    }
    else {
      uint64_t v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }

  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return -1LL;
  }
  size_t v9 = *(MachProcess **)(v3 + 40);
  uint64_t v10 = *(std::__shared_weak_count **)(v3 + 48);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
    uint64_t DispatchQueueT = MachProcess::GetDispatchQueueT(v9, a2);
    do
      unint64_t v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }

    return DispatchQueueT;
  }

  return MachProcess::GetDispatchQueueT(v9, a2);
}

uint64_t DNBGetTSDAddressForThread(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return -1LL;
  }
  uint64_t v5 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v5) {
    return -1LL;
  }
  uint64_t v6 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v7 = *(_DWORD *)(v5 + 32);
    BOOL v8 = v7 < a1;
    if (v7 >= a1) {
      size_t v9 = (uint64_t *)v5;
    }
    else {
      size_t v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }

  while (*v9);
  if (v6 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v6 + 32) > a1) {
    return -1LL;
  }
  unint64_t v12 = *(MachProcess **)(v6 + 40);
  unint64_t v13 = *(std::__shared_weak_count **)(v6 + 48);
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      unint64_t v15 = __ldxr(p_shared_owners);
    while (__stxr(v15 + 1, p_shared_owners));
    uint64_t TSDAddressForThread = MachProcess::GetTSDAddressForThread(v12, a2, a3, a4, a5);
    do
      unint64_t v16 = __ldaxr(p_shared_owners);
    while (__stlxr(v16 - 1, p_shared_owners));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }

    return TSDAddressForThread;
  }

  return MachProcess::GetTSDAddressForThread(v12, a2, a3, a4, a5);
}

void DNBGetAllLoadedLibrariesInfos(int a1@<W0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    goto LABEL_12;
  }
  uint64_t v3 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v3) {
    goto LABEL_12;
  }
  uint64_t v6 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v7 = *(_DWORD *)(v3 + 32);
    BOOL v8 = v7 < a1;
    if (v7 >= a1) {
      size_t v9 = (uint64_t *)v3;
    }
    else {
      size_t v9 = (uint64_t *)(v3 + 8);
    }
    if (!v8) {
      uint64_t v6 = v3;
    }
    uint64_t v3 = *v9;
  }

  while (*v9);
  if (v6 != GetProcessMap(BOOL)::g_process_map_ptr + 8 && *(_DWORD *)(v6 + 32) <= a1)
  {
    uint64_t v10 = *(MachProcess **)(v6 + 40);
    unint64_t v11 = *(std::__shared_weak_count **)(v6 + 48);
    if (v11)
    {
      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
      MachProcess::GetAllLoadedLibrariesInfos(v10, a1, a2, (_OWORD *)a3);
      do
        unint64_t v14 = __ldaxr(p_shared_owners);
      while (__stlxr(v14 - 1, p_shared_owners));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }

    else
    {
      MachProcess::GetAllLoadedLibrariesInfos(v10, a1, a2, (_OWORD *)a3);
    }
  }

  else
  {
LABEL_12:
    *(void *)a3 = 0LL;
    *(void *)(a3 + 8) = 0LL;
  }

void DNBGetLibrariesInfoForAddresses(int a1@<W0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    goto LABEL_12;
  }
  uint64_t v3 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v3) {
    goto LABEL_12;
  }
  uint64_t v6 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v7 = *(_DWORD *)(v3 + 32);
    BOOL v8 = v7 < a1;
    if (v7 >= a1) {
      size_t v9 = (uint64_t *)v3;
    }
    else {
      size_t v9 = (uint64_t *)(v3 + 8);
    }
    if (!v8) {
      uint64_t v6 = v3;
    }
    uint64_t v3 = *v9;
  }

  while (*v9);
  if (v6 != GetProcessMap(BOOL)::g_process_map_ptr + 8 && *(_DWORD *)(v6 + 32) <= a1)
  {
    uint64_t v10 = *(void *)(v6 + 40);
    unint64_t v11 = *(std::__shared_weak_count **)(v6 + 48);
    if (v11)
    {
      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
      MachProcess::GetLibrariesInfoForAddresses(v10, a1, a2, (_OWORD *)a3);
      do
        unint64_t v14 = __ldaxr(p_shared_owners);
      while (__stlxr(v14 - 1, p_shared_owners));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }

    else
    {
      MachProcess::GetLibrariesInfoForAddresses(v10, a1, a2, (_OWORD *)a3);
    }
  }

  else
  {
LABEL_12:
    *(void *)a3 = 0LL;
    *(void *)(a3 + 8) = 0LL;
  }

double DNBGetSharedCacheInfo@<D0>(int a1@<W0>, uint64_t a2@<X8>, __n128 a3@<Q0>)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    goto LABEL_12;
  }
  uint64_t v3 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v3) {
    goto LABEL_12;
  }
  uint64_t v4 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v5 = *(_DWORD *)(v3 + 32);
    BOOL v6 = v5 < a1;
    if (v5 >= a1) {
      int v7 = (uint64_t *)v3;
    }
    else {
      int v7 = (uint64_t *)(v3 + 8);
    }
    if (!v6) {
      uint64_t v4 = v3;
    }
    uint64_t v3 = *v7;
  }

  while (*v7);
  if (v4 != GetProcessMap(BOOL)::g_process_map_ptr + 8 && *(_DWORD *)(v4 + 32) <= a1)
  {
    BOOL v8 = *(MachProcess **)(v4 + 40);
    size_t v9 = *(std::__shared_weak_count **)(v4 + 48);
    if (v9)
    {
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        unint64_t v11 = __ldxr(p_shared_owners);
      while (__stxr(v11 + 1, p_shared_owners));
      a3.n128_f64[0] = MachProcess::GetSharedCacheInfo(v8, (_OWORD *)a2);
      do
        unint64_t v12 = __ldaxr(p_shared_owners);
      while (__stlxr(v12 - 1, p_shared_owners));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *, __n128))v9->__on_zero_shared)(v9, a3);
        std::__shared_weak_count::__release_weak(v9);
      }
    }

    else
    {
      a3.n128_f64[0] = MachProcess::GetSharedCacheInfo(v8, (_OWORD *)a2);
    }
  }

  else
  {
LABEL_12:
    *(void *)a2 = 0LL;
    *(void *)(a2 + 8) = 0LL;
  }

  return a3.n128_f64[0];
}

BOOL DNBProcessResume(int a1, char *a2, size_t a3)
{
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("%s(pid = %4.4x)", "DNBProcessResume", a1);
  }
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v6 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v6) {
    return 0LL;
  }
  uint64_t v7 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v8 = *(_DWORD *)(v6 + 32);
    BOOL v9 = v8 < a1;
    if (v8 >= a1) {
      uint64_t v10 = (uint64_t *)v6;
    }
    else {
      uint64_t v10 = (uint64_t *)(v6 + 8);
    }
    if (!v9) {
      uint64_t v7 = v6;
    }
    uint64_t v6 = *v10;
  }

  while (*v10);
  if (v7 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v7 + 32) > a1) {
    return 0LL;
  }
  unint64_t v14 = *(MachProcess **)(v7 + 40);
  unint64_t v13 = *(std::__shared_weak_count **)(v7 + 48);
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      unint64_t v16 = __ldxr(p_shared_owners);
    while (__stxr(v16 + 1, p_shared_owners));
  }

  DNBThreadResumeActions::DNBThreadResumeActions((uint64_t)&v20, a2, a3);
  if (v20 == v21) {
    int v17 = 5;
  }
  else {
    int v17 = 4;
  }
  DNBThreadResumeActions::SetDefaultThreadActionIfNeeded((char **)&v20, v17, 0);
  BOOL v11 = MachProcess::Resume(v14, (char **)&v20);
  if (__p) {
    operator delete(__p);
  }
  if (v20)
  {
    uint64_t v21 = v20;
    operator delete(v20);
  }

  if (v13)
  {
    unint64_t v18 = (unint64_t *)&v13->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }

  return v11;
}

BOOL DNBBreakpointSet(int a1, unint64_t a2, uint64_t a3, int a4)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v4 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v4) {
    return 0LL;
  }
  uint64_t v5 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v6 = *(_DWORD *)(v4 + 32);
    BOOL v7 = v6 < a1;
    if (v6 >= a1) {
      int v8 = (uint64_t *)v4;
    }
    else {
      int v8 = (uint64_t *)(v4 + 8);
    }
    if (!v7) {
      uint64_t v5 = v4;
    }
    uint64_t v4 = *v8;
  }

  while (*v8);
  if (v5 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v5 + 32) > a1) {
    return 0LL;
  }
  BOOL v11 = *(uint64_t ***)(v5 + 40);
  unint64_t v12 = *(std::__shared_weak_count **)(v5 + 48);
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      unint64_t v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
  }

  BOOL v9 = MachProcess::CreateBreakpoint(v11, a2, a3, a4 != 0) != 0LL;
  if (v12)
  {
    unint64_t v15 = (unint64_t *)&v12->__shared_owners_;
    do
      unint64_t v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

  return v9;
}

BOOL DNBBreakpointClear(int a1, unint64_t a2)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      int v6 = (uint64_t *)v2;
    }
    else {
      int v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }

  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return 0LL;
  }
  BOOL v9 = *(MachProcess **)(v3 + 40);
  uint64_t v10 = *(std::__shared_weak_count **)(v3 + 48);
  if (!v10) {
    return MachProcess::DisableBreakpoint(v9, a2, 1);
  }
  p_shared_owners = (unint64_t *)&v10->__shared_owners_;
  do
    unint64_t v12 = __ldxr(p_shared_owners);
  while (__stxr(v12 + 1, p_shared_owners));
  BOOL v7 = MachProcess::DisableBreakpoint(v9, a2, 1);
  do
    unint64_t v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }

  return v7;
}

BOOL DNBWatchpointSet(int a1, unint64_t a2, uint64_t a3, int a4, int a5)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v5 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v5) {
    return 0LL;
  }
  uint64_t v6 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v7 = *(_DWORD *)(v5 + 32);
    BOOL v8 = v7 < a1;
    if (v7 >= a1) {
      BOOL v9 = (uint64_t *)v5;
    }
    else {
      BOOL v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }

  while (*v9);
  if (v6 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v6 + 32) > a1) {
    return 0LL;
  }
  unint64_t v12 = *(uint64_t ***)(v6 + 40);
  unint64_t v13 = *(std::__shared_weak_count **)(v6 + 48);
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      unint64_t v15 = __ldxr(p_shared_owners);
    while (__stxr(v15 + 1, p_shared_owners));
  }

  BOOL v10 = MachProcess::CreateWatchpoint(v12, a2, a3, a4, a5 != 0) != 0LL;
  if (v13)
  {
    unint64_t v16 = (unint64_t *)&v13->__shared_owners_;
    do
      unint64_t v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }

  return v10;
}

BOOL DNBWatchpointClear(int a1, unint64_t a2)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      uint64_t v6 = (uint64_t *)v2;
    }
    else {
      uint64_t v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }

  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return 0LL;
  }
  BOOL v9 = *(MachProcess **)(v3 + 40);
  BOOL v10 = *(std::__shared_weak_count **)(v3 + 48);
  if (!v10) {
    return MachProcess::DisableWatchpoint(v9, a2, 1);
  }
  p_shared_owners = (unint64_t *)&v10->__shared_owners_;
  do
    unint64_t v12 = __ldxr(p_shared_owners);
  while (__stxr(v12 + 1, p_shared_owners));
  BOOL v7 = MachProcess::DisableWatchpoint(v9, a2, 1);
  do
    unint64_t v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }

  return v7;
}

uint64_t DNBWatchpointGetNumSupportedHWP(int a1)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v1 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v1) {
    return 0LL;
  }
  uint64_t v2 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v3 = *(_DWORD *)(v1 + 32);
    BOOL v4 = v3 < a1;
    if (v3 >= a1) {
      BOOL v5 = (uint64_t *)v1;
    }
    else {
      BOOL v5 = (uint64_t *)(v1 + 8);
    }
    if (!v4) {
      uint64_t v2 = v1;
    }
    uint64_t v1 = *v5;
  }

  while (*v5);
  if (v2 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v2 + 32) > a1) {
    return 0LL;
  }
  BOOL v8 = *(MachThread ****)(v2 + 40);
  BOOL v9 = *(std::__shared_weak_count **)(v2 + 48);
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
    uint64_t NumSupportedHardwareWatchpoints = MachProcess::GetNumSupportedHardwareWatchpoints(v8);
    do
      unint64_t v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }

    return NumSupportedHardwareWatchpoints;
  }

  return MachProcess::GetNumSupportedHardwareWatchpoints(v8);
}

unint64_t DNBProcessMemoryRead(int a1, mach_vm_address_t a2, unint64_t a3, char *a4)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v4 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v4) {
    return 0LL;
  }
  uint64_t v5 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v6 = *(_DWORD *)(v4 + 32);
    BOOL v7 = v6 < a1;
    if (v6 >= a1) {
      BOOL v8 = (uint64_t *)v4;
    }
    else {
      BOOL v8 = (uint64_t *)(v4 + 8);
    }
    if (!v7) {
      uint64_t v5 = v4;
    }
    uint64_t v4 = *v8;
  }

  while (*v8);
  if (v5 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v5 + 32) > a1) {
    return 0LL;
  }
  unint64_t v11 = *(MachProcess **)(v5 + 40);
  unint64_t v12 = *(std::__shared_weak_count **)(v5 + 48);
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      unint64_t v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
    unint64_t Memory = MachProcess::ReadMemory(v11, a2, a3, a4);
    do
      unint64_t v15 = __ldaxr(p_shared_owners);
    while (__stlxr(v15 - 1, p_shared_owners));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }

    return Memory;
  }

  return MachProcess::ReadMemory(v11, a2, a3, a4);
}

uint64_t DNBProcessMemoryReadInteger(int a1, mach_vm_address_t a2, unint64_t a3, uint64_t a4)
{
  if (a3 <= 8 && DNBProcessMemoryRead(a1, a2, a3, (char *)&v7) == a3)
  {
    switch(a3)
    {
      case 1uLL:
        a4 = v7;
        break;
      case 2uLL:
        a4 = (unsigned __int16)v7;
        break;
      case 3uLL:
        a4 = v7 & 0xFFFFFF;
        break;
      case 4uLL:
      case 5uLL:
      case 6uLL:
      case 7uLL:
        a4 = v7;
        break;
      case 8uLL:
        a4 = v7;
        break;
      default:
        return a4;
    }
  }

  return a4;
}

uint64_t DNBProcessMemoryReadPointer(int a1, mach_vm_address_t a2)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0LL;
  }
  uint64_t v5 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v6 = *(_DWORD *)(v2 + 32);
    BOOL v7 = v6 < a1;
    if (v6 >= a1) {
      BOOL v8 = (uint64_t *)v2;
    }
    else {
      BOOL v8 = (uint64_t *)(v2 + 8);
    }
    if (!v7) {
      uint64_t v5 = v2;
    }
    uint64_t v2 = *v8;
  }

  while (*v8);
  if (v5 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v5 + 32) > a1) {
    return 0LL;
  }
  BOOL v9 = *(MachProcess **)(v5 + 40);
  BOOL v10 = *(std::__shared_weak_count **)(v5 + 48);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
    int CPUType = MachProcess::GetCPUType(v9);
    do
      unint64_t v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  else
  {
    int CPUType = MachProcess::GetCPUType(v9);
  }

  if (!CPUType) {
    return 0LL;
  }
  unint64_t v15 = (CPUType & 0x1000000) != 0 ? 8LL : 4LL;
  if ((CPUType & 0x1000000) != 0) {
    return v17;
  }
  return v17;
}

uint64_t DNBProcessGetCPUType(int a1)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v1 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v1) {
    return 0LL;
  }
  uint64_t v2 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v3 = *(_DWORD *)(v1 + 32);
    BOOL v4 = v3 < a1;
    if (v3 >= a1) {
      uint64_t v5 = (uint64_t *)v1;
    }
    else {
      uint64_t v5 = (uint64_t *)(v1 + 8);
    }
    if (!v4) {
      uint64_t v2 = v1;
    }
    uint64_t v1 = *v5;
  }

  while (*v5);
  if (v2 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v2 + 32) > a1) {
    return 0LL;
  }
  BOOL v8 = *(MachProcess **)(v2 + 40);
  BOOL v9 = *(std::__shared_weak_count **)(v2 + 48);
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
    uint64_t CPUType = MachProcess::GetCPUType(v8);
    do
      unint64_t v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }

    return CPUType;
  }

  return MachProcess::GetCPUType(v8);
}

uint64_t DNBProcessMemoryReadCString@<X0>(int a1@<W0>, mach_vm_address_t a2@<X1>, std::string *a3@<X8>)
{
  a3->__r_.__value_.__r.__words[0] = 0LL;
  a3->__r_.__value_.__l.__size_ = 0LL;
  a3->__r_.__value_.__l.__cap_ = 0LL;
  __s[255] = 0;
  do
  {
    uint64_t result = DNBProcessMemoryRead(a1, a2, 0xFFuLL, __s);
    if (!result) {
      break;
    }
    size_t v7 = strlen(__s);
    uint64_t result = (uint64_t)std::string::append(a3, __s, v7);
    a2 += v7;
  }

  while (v7 == 255);
  return result;
}

std::string *DNBProcessMemoryReadCStringFixed@<X0>(std::string *a1@<X8>)
{
  a1->__r_.__value_.__r.__words[0] = 0LL;
  a1->__r_.__value_.__l.__size_ = 0LL;
  a1->__r_.__value_.__l.__cap_ = 0LL;
  int v2 = __chkstk_darwin();
  BOOL v4 = (char *)&v7 - ((v3 + 16) & 0xFFFFFFFFFFFFFFF0LL);
  v4[v3] = 0;
  uint64_t result = (std::string *)DNBProcessMemoryRead(v2, v5, v3, v4);
  if (result) {
    return std::string::assign(a1, v4);
  }
  return result;
}

unint64_t DNBProcessMemoryWrite(int a1, unint64_t a2, unint64_t a3, char *a4)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v4 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v4) {
    return 0LL;
  }
  uint64_t v5 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v6 = *(_DWORD *)(v4 + 32);
    BOOL v7 = v6 < a1;
    if (v6 >= a1) {
      BOOL v8 = (uint64_t *)v4;
    }
    else {
      BOOL v8 = (uint64_t *)(v4 + 8);
    }
    if (!v7) {
      uint64_t v5 = v4;
    }
    uint64_t v4 = *v8;
  }

  while (*v8);
  if (v5 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v5 + 32) > a1) {
    return 0LL;
  }
  unint64_t v11 = *(MachProcess **)(v5 + 40);
  unint64_t v12 = *(std::__shared_weak_count **)(v5 + 48);
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      unint64_t v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
    unint64_t v9 = MachProcess::WriteMemory(v11, a2, a3, a4);
    do
      unint64_t v15 = __ldaxr(p_shared_owners);
    while (__stlxr(v15 - 1, p_shared_owners));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }

    return v9;
  }

  return MachProcess::WriteMemory(v11, a2, a3, a4);
}

mach_vm_address_t DNBProcessMemoryAllocate(int a1, mach_vm_size_t a2, unsigned int a3)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v3 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v3) {
    return 0LL;
  }
  uint64_t v4 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v5 = *(_DWORD *)(v3 + 32);
    BOOL v6 = v5 < a1;
    if (v5 >= a1) {
      BOOL v7 = (uint64_t *)v3;
    }
    else {
      BOOL v7 = (uint64_t *)(v3 + 8);
    }
    if (!v6) {
      uint64_t v4 = v3;
    }
    uint64_t v3 = *v7;
  }

  while (*v7);
  if (v4 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v4 + 32) > a1) {
    return 0LL;
  }
  uint64_t v10 = *(void *)(v4 + 40);
  unint64_t v11 = *(std::__shared_weak_count **)(v4 + 48);
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      unint64_t v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
    mach_vm_address_t Memory = MachTask::AllocateMemory((MachTask *)(v10 + 104), a2, a3);
    do
      unint64_t v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }

    return Memory;
  }

  return MachTask::AllocateMemory((MachTask *)(v10 + 104), a2, a3);
}

BOOL DNBProcessMemoryDeallocate(int a1, mach_vm_address_t a2)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      BOOL v6 = (uint64_t *)v2;
    }
    else {
      BOOL v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }

  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return 0LL;
  }
  uint64_t v9 = *(void *)(v3 + 40);
  uint64_t v10 = *(std::__shared_weak_count **)(v3 + 48);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
    BOOL v7 = MachTask::DeallocateMemory((MachTask *)(v9 + 104), a2);
    do
      unint64_t v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }

    return v7;
  }

  return MachTask::DeallocateMemory((MachTask *)(v9 + 104), a2);
}

uint64_t DNBProcessMemoryRegionInfo(int a1, unint64_t a2, uint64_t a3)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v5 = *(_DWORD *)(v3 + 32);
    BOOL v6 = v5 < a1;
    if (v5 >= a1) {
      BOOL v7 = (uint64_t *)v3;
    }
    else {
      BOOL v7 = (uint64_t *)(v3 + 8);
    }
    if (!v6) {
      uint64_t v4 = v3;
    }
    uint64_t v3 = *v7;
  }

  while (*v7);
  if (v4 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v4 + 32) > a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v10 = *(void *)(v4 + 40);
  unint64_t v11 = *(std::__shared_weak_count **)(v4 + 48);
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      unint64_t v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
    uint64_t MemoryRegionInfo = MachTask::GetMemoryRegionInfo(v10 + 104, a2, a3);
    do
      unint64_t v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }

    return MemoryRegionInfo;
  }

  return MachTask::GetMemoryRegionInfo(v10 + 104, a2, a3);
}

void DNBProcessGetProfileData(int a1@<W0>, __int16 a2@<W1>, task_basic_info *a3@<X2>, uint64_t a4@<X8>)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    goto LABEL_12;
  }
  uint64_t v4 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v4) {
    goto LABEL_12;
  }
  uint64_t v5 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v6 = *(_DWORD *)(v4 + 32);
    BOOL v7 = v6 < a1;
    if (v6 >= a1) {
      BOOL v8 = (uint64_t *)v4;
    }
    else {
      BOOL v8 = (uint64_t *)(v4 + 8);
    }
    if (!v7) {
      uint64_t v5 = v4;
    }
    uint64_t v4 = *v8;
  }

  while (*v8);
  if (v5 != GetProcessMap(BOOL)::g_process_map_ptr + 8 && *(_DWORD *)(v5 + 32) <= a1)
  {
    uint64_t v9 = *(void *)(v5 + 40);
    uint64_t v10 = *(std::__shared_weak_count **)(v5 + 48);
    if (v10)
    {
      p_shared_owners = (unint64_t *)&v10->__shared_owners_;
      do
        unint64_t v12 = __ldxr(p_shared_owners);
      while (__stxr(v12 + 1, p_shared_owners));
      MachTask::GetProfileData(v9 + 104, a2, a3, (void *)a4);
      do
        unint64_t v13 = __ldaxr(p_shared_owners);
      while (__stlxr(v13 - 1, p_shared_owners));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }

    else
    {
      MachTask::GetProfileData(v9 + 104, a2, a3, (void *)a4);
    }
  }

  else
  {
LABEL_12:
    *(_BYTE *)(a4 + 23) = 0;
    *(_BYTE *)a4 = 0;
  }

uint64_t DNBProcessSetEnableAsyncProfiling(int a1, int a2, int a3, int a4)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v4 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v4) {
    return 0LL;
  }
  uint64_t v5 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v6 = *(_DWORD *)(v4 + 32);
    BOOL v7 = v6 < a1;
    if (v6 >= a1) {
      BOOL v8 = (uint64_t *)v4;
    }
    else {
      BOOL v8 = (uint64_t *)(v4 + 8);
    }
    if (!v7) {
      uint64_t v5 = v4;
    }
    uint64_t v4 = *v8;
  }

  while (*v8);
  if (v5 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v5 + 32) > a1) {
    return 0LL;
  }
  uint64_t v10 = *(pthread_mutex_t **)(v5 + 40);
  unint64_t v11 = *(std::__shared_weak_count **)(v5 + 48);
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      unint64_t v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
    MachProcess::SetEnableAsyncProfiling(v10, a2 != 0, a3, a4);
    do
      unint64_t v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }

  else
  {
    MachProcess::SetEnableAsyncProfiling(v10, a2 != 0, a3, a4);
  }

  return 1LL;
}

uint64_t DNBProcessGetNumThreads(int a1)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v1 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v1) {
    return 0LL;
  }
  uint64_t v2 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v3 = *(_DWORD *)(v1 + 32);
    BOOL v4 = v3 < a1;
    if (v3 >= a1) {
      uint64_t v5 = (uint64_t *)v1;
    }
    else {
      uint64_t v5 = (uint64_t *)(v1 + 8);
    }
    if (!v4) {
      uint64_t v2 = v1;
    }
    uint64_t v1 = *v5;
  }

  while (*v5);
  if (v2 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v2 + 32) > a1) {
    return 0LL;
  }
  BOOL v8 = *(MachProcess **)(v2 + 40);
  uint64_t v9 = *(std::__shared_weak_count **)(v2 + 48);
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
    uint64_t NumThreads = MachProcess::GetNumThreads(v8);
    do
      unint64_t v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }

    return NumThreads;
  }

  return MachProcess::GetNumThreads(v8);
}

uint64_t DNBProcessGetCurrentThread(int a1)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v1 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v1) {
    return 0LL;
  }
  uint64_t v2 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v3 = *(_DWORD *)(v1 + 32);
    BOOL v4 = v3 < a1;
    if (v3 >= a1) {
      uint64_t v5 = (uint64_t *)v1;
    }
    else {
      uint64_t v5 = (uint64_t *)(v1 + 8);
    }
    if (!v4) {
      uint64_t v2 = v1;
    }
    uint64_t v1 = *v5;
  }

  while (*v5);
  if (v2 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v2 + 32) > a1) {
    return 0LL;
  }
  BOOL v8 = *(MachProcess **)(v2 + 40);
  uint64_t v9 = *(std::__shared_weak_count **)(v2 + 48);
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
    uint64_t CurrentThread = MachProcess::GetCurrentThread(v8);
    do
      unint64_t v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }

    return CurrentThread;
  }

  return MachProcess::GetCurrentThread(v8);
}

uint64_t DNBProcessSetCurrentThread(int a1, uint64_t a2)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      int v6 = (uint64_t *)v2;
    }
    else {
      int v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }

  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return 0LL;
  }
  uint64_t v9 = *(MachProcess **)(v3 + 40);
  uint64_t v10 = *(std::__shared_weak_count **)(v3 + 48);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
    uint64_t v7 = MachProcess::SetCurrentThread(v9, a2);
    do
      unint64_t v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }

    return v7;
  }

  return MachProcess::SetCurrentThread(v9, a2);
}

uint64_t DNBThreadGetStopReason(int a1, uint64_t a2, _DWORD *a3)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v3 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v3) {
    return 0LL;
  }
  uint64_t v4 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v5 = *(_DWORD *)(v3 + 32);
    BOOL v6 = v5 < a1;
    if (v5 >= a1) {
      uint64_t v7 = (uint64_t *)v3;
    }
    else {
      uint64_t v7 = (uint64_t *)(v3 + 8);
    }
    if (!v6) {
      uint64_t v4 = v3;
    }
    uint64_t v3 = *v7;
  }

  while (*v7);
  if (v4 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v4 + 32) > a1) {
    return 0LL;
  }
  uint64_t v10 = *(void *)(v4 + 40);
  unint64_t v11 = *(std::__shared_weak_count **)(v4 + 48);
  if (!v11) {
    return MachProcess::GetThreadStoppedReason(v10, a2, a3);
  }
  p_shared_owners = (unint64_t *)&v11->__shared_owners_;
  do
    unint64_t v13 = __ldxr(p_shared_owners);
  while (__stxr(v13 + 1, p_shared_owners));
  uint64_t ThreadStoppedReason = MachProcess::GetThreadStoppedReason(v10, a2, a3);
  do
    unint64_t v14 = __ldaxr(p_shared_owners);
  while (__stlxr(v14 - 1, p_shared_owners));
  if (!v14)
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }

  return ThreadStoppedReason;
}

char *DNBThreadGetInfo(int a1, uint64_t a2)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      BOOL v6 = (uint64_t *)v2;
    }
    else {
      BOOL v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }

  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return 0LL;
  }
  uint64_t v9 = *(MachProcess **)(v3 + 40);
  uint64_t v10 = *(std::__shared_weak_count **)(v3 + 48);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
    ThreadInfo = MachProcess::GetThreadInfo(v9, a2);
    do
      unint64_t v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }

    return ThreadInfo;
  }

  return MachProcess::GetThreadInfo(v9, a2);
}

uint64_t DNBProcessGetThreadAtIndex(int a1, unint64_t a2)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      BOOL v6 = (uint64_t *)v2;
    }
    else {
      BOOL v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }

  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return 0LL;
  }
  uint64_t v9 = *(MachProcess **)(v3 + 40);
  uint64_t v10 = *(std::__shared_weak_count **)(v3 + 48);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
    uint64_t ThreadAtIndex = MachProcess::GetThreadAtIndex(v9, a2);
    do
      unint64_t v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }

    return ThreadAtIndex;
  }

  return MachProcess::GetThreadAtIndex(v9, a2);
}

BOOL DNBProcessSyncThreadState(int a1, uint64_t a2)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      BOOL v6 = (uint64_t *)v2;
    }
    else {
      BOOL v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }

  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return 0LL;
  }
  uint64_t v9 = *(MachProcess **)(v3 + 40);
  uint64_t v10 = *(std::__shared_weak_count **)(v3 + 48);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
    BOOL v7 = MachProcess::SyncThreadState(v9, a2);
    do
      unint64_t v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }

    return v7;
  }

  return MachProcess::SyncThreadState(v9, a2);
}

uint64_t DNBProcessGetSharedLibraryInfoAddress(int a1)
{
  *(_OWORD *)timeval __p = 0u;
  __int128 v15 = 0u;
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return -1LL;
  }
  uint64_t v1 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v1) {
    return -1LL;
  }
  uint64_t v2 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v3 = *(_DWORD *)(v1 + 32);
    BOOL v4 = v3 < a1;
    if (v3 >= a1) {
      BOOL v5 = (uint64_t *)v1;
    }
    else {
      BOOL v5 = (uint64_t *)(v1 + 8);
    }
    if (!v4) {
      uint64_t v2 = v1;
    }
    uint64_t v1 = *v5;
  }

  while (*v5);
  if (v2 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v2 + 32) > a1) {
    return -1LL;
  }
  uint64_t v8 = *(void *)(v2 + 40);
  uint64_t v9 = *(std::__shared_weak_count **)(v2 + 48);
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }

  uint64_t DYLDAllImageInfosAddress = MachTask::GetDYLDAllImageInfosAddress((MachTask *)(v8 + 104), (DNBError *)__p);
  if (SHIBYTE(v15) < 0) {
    operator delete(__p[1]);
  }
  if (v9)
  {
    unint64_t v12 = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

  return DYLDAllImageInfosAddress;
}

uint64_t DNBThreadGetRegisterValueByID(int a1, uint64_t a2, int a3, int a4, void *a5)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v7 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v7) {
    return 0LL;
  }
  uint64_t v8 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v9 = *(_DWORD *)(v7 + 32);
    BOOL v10 = v9 < a1;
    if (v9 >= a1) {
      unint64_t v11 = (uint64_t *)v7;
    }
    else {
      unint64_t v11 = (uint64_t *)(v7 + 8);
    }
    if (!v10) {
      uint64_t v8 = v7;
    }
    uint64_t v7 = *v11;
  }

  while (*v11);
  if (v8 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v8 + 32) > a1) {
    return 0LL;
  }
  uint64_t v14 = *(void *)(v8 + 40);
  __int128 v15 = *(std::__shared_weak_count **)(v8 + 48);
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      unint64_t v17 = __ldxr(p_shared_owners);
    while (__stxr(v17 + 1, p_shared_owners));
  }

  if (a2)
  {
    uint64_t RegisterValue = MachProcess::GetRegisterValue(v14, a2);
    if (!v15) {
      return RegisterValue;
    }
  }

  else
  {
    uint64_t RegisterValue = 0LL;
    if (!v15) {
      return RegisterValue;
    }
  }

  unint64_t v18 = (unint64_t *)&v15->__shared_owners_;
  do
    unint64_t v19 = __ldaxr(v18);
  while (__stlxr(v19 - 1, v18));
  if (!v19)
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }

  return RegisterValue;
}

uint64_t DNBThreadSetRegisterValueByID(int a1, uint64_t a2)
{
  if (!a2) {
    return 0LL;
  }
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      BOOL v6 = (uint64_t *)v2;
    }
    else {
      BOOL v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }

  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return 0LL;
  }
  uint64_t v9 = *(void *)(v3 + 40);
  BOOL v10 = *(std::__shared_weak_count **)(v3 + 48);
  if (!v10) {
    return MachProcess::SetRegisterValue(v9, a2);
  }
  p_shared_owners = (unint64_t *)&v10->__shared_owners_;
  do
    unint64_t v12 = __ldxr(p_shared_owners);
  while (__stxr(v12 + 1, p_shared_owners));
  uint64_t v7 = MachProcess::SetRegisterValue(v9, a2);
  do
    unint64_t v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }

  return v7;
}

uint64_t DNBThreadGetRegisterContext(int a1, uint64_t a2, void *a3, size_t a4)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    goto LABEL_12;
  }
  uint64_t v4 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v4) {
    goto LABEL_12;
  }
  uint64_t v5 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v6 = *(_DWORD *)(v4 + 32);
    BOOL v7 = v6 < a1;
    if (v6 >= a1) {
      uint64_t v8 = (uint64_t *)v4;
    }
    else {
      uint64_t v8 = (uint64_t *)(v4 + 8);
    }
    if (!v7) {
      uint64_t v5 = v4;
    }
    uint64_t v4 = *v8;
  }

  while (*v8);
  if (v5 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v5 + 32) > a1)
  {
LABEL_12:
    uint64_t v9 = 0LL;
    goto LABEL_13;
  }

  uint64_t v14 = *(void *)(v5 + 40);
  uint64_t v9 = *(std::__shared_weak_count **)(v5 + 48);
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v16 = __ldxr(p_shared_owners);
    while (__stxr(v16 + 1, p_shared_owners));
  }

  if (!a2)
  {
LABEL_13:
    bzero(a3, a4);
    uint64_t RegisterContext = 0LL;
    if (!v9) {
      return RegisterContext;
    }
    goto LABEL_14;
  }

  uint64_t RegisterContext = MachThreadList::GetRegisterContext((MachThreadList *)(v14 + 968), a2, a3);
  if (!v9) {
    return RegisterContext;
  }
LABEL_14:
  unint64_t v11 = (unint64_t *)&v9->__shared_owners_;
  do
    unint64_t v12 = __ldaxr(v11);
  while (__stlxr(v12 - 1, v11));
  if (!v12)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }

  return RegisterContext;
}

uint64_t DNBThreadSetRegisterContext(int a1, uint64_t a2, const void *a3)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v3 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v3) {
    return 0LL;
  }
  uint64_t v4 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v5 = *(_DWORD *)(v3 + 32);
    BOOL v6 = v5 < a1;
    if (v5 >= a1) {
      BOOL v7 = (uint64_t *)v3;
    }
    else {
      BOOL v7 = (uint64_t *)(v3 + 8);
    }
    if (!v6) {
      uint64_t v4 = v3;
    }
    uint64_t v3 = *v7;
  }

  while (*v7);
  if (v4 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v4 + 32) > a1) {
    return 0LL;
  }
  uint64_t v10 = *(void *)(v4 + 40);
  unint64_t v11 = *(std::__shared_weak_count **)(v4 + 48);
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      unint64_t v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
  }

  if (a2)
  {
    uint64_t v8 = MachThreadList::SetRegisterContext((MachThreadList *)(v10 + 968), a2, a3);
    if (!v11) {
      return v8;
    }
  }

  else
  {
    uint64_t v8 = 0LL;
    if (!v11) {
      return v8;
    }
  }

  uint64_t v14 = (unint64_t *)&v11->__shared_owners_;
  do
    unint64_t v15 = __ldaxr(v14);
  while (__stlxr(v15 - 1, v14));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }

  return v8;
}

uint64_t DNBThreadSaveRegisterState(int a1, uint64_t a2)
{
  if (!a2) {
    return 0LL;
  }
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      BOOL v6 = (uint64_t *)v2;
    }
    else {
      BOOL v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }

  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return 0LL;
  }
  uint64_t v9 = *(void *)(v3 + 40);
  uint64_t v10 = *(std::__shared_weak_count **)(v3 + 48);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
    uint64_t v7 = MachThreadList::SaveRegisterState((MachThreadList *)(v9 + 968), a2);
    do
      unint64_t v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }

    return v7;
  }

  return MachThreadList::SaveRegisterState((MachThreadList *)(v9 + 968), a2);
}

uint64_t DNBThreadRestoreRegisterState(int a1, uint64_t a2)
{
  if (!a2) {
    return 0LL;
  }
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      BOOL v6 = (uint64_t *)v2;
    }
    else {
      BOOL v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }

  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return 0LL;
  }
  uint64_t v9 = *(void *)(v3 + 40);
  uint64_t v10 = *(std::__shared_weak_count **)(v3 + 48);
  if (!v10) {
    return MachThreadList::RestoreRegisterState((MachThreadList *)(v9 + 968), a2);
  }
  p_shared_owners = (unint64_t *)&v10->__shared_owners_;
  do
    unint64_t v12 = __ldxr(p_shared_owners);
  while (__stxr(v12 + 1, p_shared_owners));
  uint64_t v7 = MachThreadList::RestoreRegisterState((MachThreadList *)(v9 + 968), a2);
  do
    unint64_t v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }

  return v7;
}

size_t DNBProcessGetAvailableSTDOUT(int a1, char *a2, size_t a3)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v3 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v3) {
    return 0LL;
  }
  uint64_t v4 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v5 = *(_DWORD *)(v3 + 32);
    BOOL v6 = v5 < a1;
    if (v5 >= a1) {
      uint64_t v7 = (uint64_t *)v3;
    }
    else {
      uint64_t v7 = (uint64_t *)(v3 + 8);
    }
    if (!v6) {
      uint64_t v4 = v3;
    }
    uint64_t v3 = *v7;
  }

  while (*v7);
  if (v4 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v4 + 32) > a1) {
    return 0LL;
  }
  uint64_t v10 = *(MachProcess **)(v4 + 40);
  unint64_t v11 = *(std::__shared_weak_count **)(v4 + 48);
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      unint64_t v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
    size_t AvailableSTDOUT = MachProcess::GetAvailableSTDOUT(v10, a2, a3);
    do
      unint64_t v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }

    return AvailableSTDOUT;
  }

  return MachProcess::GetAvailableSTDOUT(v10, a2, a3);
}

uint64_t DNBProcessGetAvailableSTDERR(int a1, char *a2)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v4 = *(_DWORD *)(v2 + 32);
    BOOL v5 = v4 < a1;
    if (v4 >= a1) {
      BOOL v6 = (uint64_t *)v2;
    }
    else {
      BOOL v6 = (uint64_t *)(v2 + 8);
    }
    if (!v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = *v6;
  }

  while (*v6);
  if (v3 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v3 + 32) > a1) {
    return 0LL;
  }
  uint64_t v9 = *(MachProcess **)(v3 + 40);
  uint64_t v10 = *(std::__shared_weak_count **)(v3 + 48);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
    uint64_t AvailableSTDERR = MachProcess::GetAvailableSTDERR(v9, a2);
    do
      unint64_t v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }

    return AvailableSTDERR;
  }

  return MachProcess::GetAvailableSTDERR(v9, a2);
}

size_t DNBProcessGetAvailableProfileData(int a1, char *a2, size_t a3)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0LL;
  }
  uint64_t v3 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v3) {
    return 0LL;
  }
  uint64_t v4 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v5 = *(_DWORD *)(v3 + 32);
    BOOL v6 = v5 < a1;
    if (v5 >= a1) {
      uint64_t v7 = (uint64_t *)v3;
    }
    else {
      uint64_t v7 = (uint64_t *)(v3 + 8);
    }
    if (!v6) {
      uint64_t v4 = v3;
    }
    uint64_t v3 = *v7;
  }

  while (*v7);
  if (v4 == GetProcessMap(BOOL)::g_process_map_ptr + 8 || *(_DWORD *)(v4 + 32) > a1) {
    return 0LL;
  }
  uint64_t v10 = *(MachProcess **)(v4 + 40);
  unint64_t v11 = *(std::__shared_weak_count **)(v4 + 48);
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      unint64_t v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
    size_t AsyncProfileData = MachProcess::GetAsyncProfileData(v10, a2, a3);
    do
      unint64_t v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }

    return AsyncProfileData;
  }

  return MachProcess::GetAsyncProfileData(v10, a2, a3);
}

uint64_t DNBProcessGetStopCount(int a1)
{
  if (!GetProcessMap(BOOL)::g_process_map_ptr) {
    return 0;
  }
  uint64_t v1 = *(void *)(GetProcessMap(BOOL)::g_process_map_ptr + 8);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = GetProcessMap(BOOL)::g_process_map_ptr + 8;
  do
  {
    int v3 = *(_DWORD *)(v1 + 32);
    BOOL v4 = v3 < a1;
    if (v3 >= a1) {
      int v5 = (uint64_t *)v1;
    }
    else {
      int v5 = (uint64_t *)(v1 + 8);
    }
    if (!v4) {
      uint64_t v2 = v1;
    }
    uint64_t v1 = *v5;
  }

  while (*v5);
  if (v2 != GetProcessMap(BOOL)::g_process_map_ptr + 8 && *(_DWORD *)(v2 + 32) <= a1)
  {
    uint64_t v8 = *(void *)(v2 + 40);
    uint64_t v9 = *(std::__shared_weak_count **)(v2 + 48);
    if (v9)
    {
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        unint64_t v11 = __ldxr(p_shared_owners);
      while (__stxr(v11 + 1, p_shared_owners));
      unsigned int v6 = *(_DWORD *)(v8 + 444);
      do
        unint64_t v12 = __ldaxr(p_shared_owners);
      while (__stlxr(v12 - 1, p_shared_owners));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }

    else
    {
      return *(unsigned int *)(v8 + 444);
    }
  }

  else
  {
    return 0;
  }

  return v6;
}

BOOL DNBResolveExecutablePath(const char *a1, char *a2, size_t a3)
{
  if (!a1 || !*a1) {
    return 0LL;
  }
  memset(&v22, 0, sizeof(v22));
  CFString::GlobPath(a1, &v22);
  std::string::size_type size = v22.__r_.__value_.__s.__size_;
  if ((v22.__r_.__value_.__s.__size_ & 0x80u) != 0) {
    std::string::size_type size = v22.__r_.__value_.__l.__size_;
  }
  if (!size) {
    std::string::assign(&v22, a1);
  }
  if (stat(a1, &v21) || (v21.st_mode & 0xF000) != 0x4000) {
    goto LABEL_15;
  }
  CFBundle::CFBundle((CFBundle *)__source, a1);
  uint64_t v7 = CFBundle::CopyExecutableURL((CFBundle *)__source);
  if (!v7 || (uint64_t v8 = v7, v9 = CFURLGetFileSystemRepresentation(v7, 1u, (UInt8 *)a2, a3), CFRelease(v8), !v9))
  {
    CFBundle::~CFBundle((CFBundle *)__source);
LABEL_15:
    if (realpath_DARWIN_EXTSN(a1, __source))
    {
      strlcpy(a2, __source, a3);
      size_t v11 = strlen(a2) + 1;
LABEL_17:
      BOOL v10 = v11 < a3;
    }

    else
    {
      unint64_t v13 = getenv("PATH");
      if (v13)
      {
        unint64_t v14 = v13;
        while (*v14)
        {
          unint64_t v15 = strchr(v14, 58);
          if (v15)
          {
            unint64_t v16 = v15;
            if (v15 <= v14) {
              break;
            }
            std::string::assign(&v22, v14, v15 - v14);
            unint64_t v14 = v16 + 1;
          }

          else
          {
            std::string::assign(&v22, v14);
            unint64_t v14 = 0LL;
          }

          std::string::push_back(&v22, 47);
          std::string::append(&v22, a1);
          if ((v22.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            unint64_t v17 = &v22;
          }
          else {
            unint64_t v17 = (std::string *)v22.__r_.__value_.__r.__words[0];
          }
          if (!stat((const char *)v17, &v20))
          {
            if ((v22.__r_.__value_.__s.__size_ & 0x80u) == 0) {
              unint64_t v18 = &v22;
            }
            else {
              unint64_t v18 = (std::string *)v22.__r_.__value_.__r.__words[0];
            }
            strlcpy(a2, (const char *)v18, a3);
            std::string::size_type v19 = v22.__r_.__value_.__s.__size_;
            if ((v22.__r_.__value_.__s.__size_ & 0x80u) != 0) {
              std::string::size_type v19 = v22.__r_.__value_.__l.__size_;
            }
            size_t v11 = v19 + 1;
            goto LABEL_17;
          }

          if (!v14) {
            break;
          }
        }
      }

      BOOL v10 = 0LL;
    }

    return v10;
  }

  CFBundle::~CFBundle((CFBundle *)__source);
  BOOL v10 = 1LL;
  if ((char)v22.__r_.__value_.__s.__size_ < 0) {
LABEL_18:
  }
    operator delete(v22.__r_.__value_.__l.__data_);
  return v10;
}

double DNBInitialize(void)
{
  BOOL v0 = DNBLogEnabledForAny(2);
  if (v0) {
    _DNBLogThreaded("DNBInitialize ()");
  }
  return DNBArchMachARM64::Initialize((DNBArchMachARM64 *)v0);
}

const char *DNBSetArchitecture(const char *result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (!*result) {
      return 0LL;
    }
    if (!strcasecmp(result, "i386"))
    {
      uint64_t v2 = 7LL;
      int v3 = 0;
    }

    else if (!strcasecmp(v1, "x86_64"))
    {
      uint64_t v2 = 16777223LL;
      int v3 = 3;
    }

    else if (!strcasecmp(v1, "x86_64h"))
    {
      uint64_t v2 = 16777223LL;
      int v3 = 8;
    }

    else if (!strncmp(v1, "arm64_32", 8uLL) || !strncmp(v1, "aarch64_32", 0xAuLL))
    {
      uint64_t v2 = 33554444LL;
      int v3 = 0;
    }

    else if (!strncmp(v1, "arm64e", 6uLL))
    {
      uint64_t v2 = 16777228LL;
      int v3 = 2;
    }

    else if (!strncmp(v1, "arm64", 5uLL) || !strncmp(v1, "aarch64", 7uLL))
    {
      uint64_t v2 = 16777228LL;
      int v3 = 0;
    }

    else if (!strncmp(v1, "armv8", 5uLL))
    {
      uint64_t v2 = 16777228LL;
      int v3 = 1;
    }

    else if (!strncmp(v1, "armv7em", 7uLL))
    {
      uint64_t v2 = 12LL;
      int v3 = 16;
    }

    else if (!strncmp(v1, "armv7m", 6uLL))
    {
      uint64_t v2 = 12LL;
      int v3 = 15;
    }

    else if (!strncmp(v1, "armv7k", 6uLL))
    {
      uint64_t v2 = 12LL;
      int v3 = 12;
    }

    else if (!strncmp(v1, "armv7s", 6uLL))
    {
      uint64_t v2 = 12LL;
      int v3 = 11;
    }

    else if (!strncmp(v1, "armv7", 5uLL))
    {
      uint64_t v2 = 12LL;
      int v3 = 9;
    }

    else if (!strncmp(v1, "armv6m", 6uLL))
    {
      uint64_t v2 = 12LL;
      int v3 = 14;
    }

    else if (!strncmp(v1, "armv6", 5uLL))
    {
      uint64_t v2 = 12LL;
      int v3 = 6;
    }

    else if (!strncmp(v1, "armv5", 5uLL))
    {
      uint64_t v2 = 12LL;
      int v3 = 7;
    }

    else if (!strncmp(v1, "armv4t", 6uLL))
    {
      uint64_t v2 = 12LL;
      int v3 = 5;
    }

    else
    {
      if (strncmp(v1, "arm", 3uLL)) {
        return 0LL;
      }
      uint64_t v2 = 12LL;
      int v3 = 0;
    }

    return (const char *)DNBArchProtocol::SetArchitecture((DNBArchProtocol *)v2, v3);
  }

  return result;
}

BOOL DNBGetAddressingBits(unsigned int *a1)
{
  unint64_t v2 = atomic_load(&DNBGetAddressingBits(unsigned int &)::g_once_flag);
  if (v2 != -1LL)
  {
    uint64_t v7 = &v5;
    unsigned int v6 = &v7;
    std::__call_once( &DNBGetAddressingBits(unsigned int &)::g_once_flag,  &v6,  (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<DNBGetAddressingBits(unsigned int &)::$_0 &&>>);
  }

  int v3 = DNBGetAddressingBits(unsigned int &)::g_addressing_bits;
  *a1 = DNBGetAddressingBits(unsigned int &)::g_addressing_bits;
  return v3 != 0;
}

uint64_t waitpid_thread(void *a1)
{
  pid_t v1 = (int)a1;
  int v13 = 0;
  pthread_setname_np("waitpid thread");
  int v11 = 0;
  unint64_t v2 = pthread_self();
  if (!pthread_getschedparam(v2, &v11, &v12))
  {
    v12.sched_priority = 47;
    int v3 = pthread_self();
    pthread_setschedparam(v3, v11, &v12);
  }

  do
  {
    while (1)
    {
      pid_t v4 = waitpid(v1, &v13, 0);
      if (DNBLogEnabledForAny(2))
      {
        int v5 = v13;
        unsigned int v6 = __error();
        _DNBLogThreaded( "waitpid_thread (): waitpid (pid = %i, &status, 0) => %i, status = %i, errno = %i",  v1,  v4,  v5,  *v6);
      }

      if (v4 < 0) {
        break;
      }
      if ((~v13 & 0x7F) != 0 || (v13 & 0xFFFFFF00) == 4864)
      {
        if (DNBLogEnabledForAny(2)) {
          _DNBLogThreaded("waitpid_thread (): setting exit status for pid = %i to %i", v4, v13);
        }
        int v8 = v13;
        int v9 = v4;
        goto LABEL_19;
      }
    }
  }

  while (*__error() == 4);
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("waitpid_thread (): main loop exited, setting exit status to an invalid value (-1) for pid %i", v1);
  }
  int v9 = v1;
  int v8 = -1;
LABEL_19:
  DNBProcessSetExitStatus(v9, v8);
  return 0LL;
}

void std::__shared_ptr_pointer<MachProcess *,std::shared_ptr<MachProcess>::__shared_ptr_default_delete<MachProcess,MachProcess>,std::allocator<MachProcess>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void std::__shared_ptr_pointer<MachProcess *,std::shared_ptr<MachProcess>::__shared_ptr_default_delete<MachProcess,MachProcess>,std::allocator<MachProcess>>::__on_zero_shared( uint64_t a1)
{
  pid_t v1 = *(MachProcess **)(a1 + 24);
  if (v1)
  {
    MachProcess::~MachProcess(v1);
    operator delete(v2);
  }

void std::vector<kinfo_proc>::__append(char **a1, unint64_t a2)
{
  int v5 = a1[1];
  pid_t v4 = a1[2];
  if (0x2C3F35BA781948B1LL * ((v4 - v5) >> 3) >= a2)
  {
    if (a2)
    {
      size_t v12 = 648 * ((648 * a2 - 648) / 0x288) + 648;
      bzero(a1[1], v12);
      v5 += v12;
    }

    a1[1] = v5;
  }

  else
  {
    unsigned int v6 = *a1;
    uint64_t v7 = 0x2C3F35BA781948B1LL * ((v5 - *a1) >> 3);
    unint64_t v8 = v7 + a2;
    if (v7 + a2 > 0x6522C3F35BA781LL) {
      abort();
    }
    unint64_t v9 = 0x2C3F35BA781948B1LL * ((v4 - v6) >> 3);
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x329161F9ADD3C0LL) {
      unint64_t v10 = 0x6522C3F35BA781LL;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 > 0x6522C3F35BA781LL) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      int v11 = (char *)operator new(648 * v10);
    }

    else
    {
      int v11 = 0LL;
    }

    int v13 = &v11[648 * v7];
    unint64_t v14 = &v11[648 * v10];
    size_t v15 = 648 * ((648 * a2 - 648) / 0x288) + 648;
    bzero(v13, v15);
    unint64_t v16 = &v13[v15];
    if (v5 != v6)
    {
      do
      {
        v5 -= 648;
        v13 -= 648;
        memcpy(v13, v5, 0x288uLL);
      }

      while (v5 != v6);
      int v5 = *a1;
    }

    *a1 = v13;
    a1[1] = v16;
    a1[2] = v14;
    if (v5) {
      operator delete(v5);
    }
  }

uint64_t std::__call_once_proxy[abi:nn180100]<std::tuple<DNBGetAddressingBits(unsigned int &)::$_0 &&>>()
{
  size_t v1 = 4LL;
  uint64_t result = sysctlbyname( "machdep.virtual_address_size",  &DNBGetAddressingBits(unsigned int &)::g_addressing_bits,  &v1,  0LL,  0LL);
  if ((_DWORD)result) {
    DNBGetAddressingBits(unsigned int &)::g_addressing_bits = 0;
  }
  return result;
}

void DNBDataRef::DNBDataRef(DNBDataRef *this, const unsigned __int8 *a2, uint64_t a3, char a4)
{
  *(void *)this = a2;
  *((void *)this + 1) = &a2[a3];
  *((_BYTE *)this + 16) = a4;
  *((_BYTE *)this + 17) = 0;
  *((void *)this + 3) = -1LL;
  *((void *)this + 4) = -1LL;
  *((void *)this + 5) = -1LL;
}

uint64_t DNBDataRef::Get32(DNBDataRef *this, unsigned int *a2)
{
  unint64_t v2 = *a2;
  unint64_t v3 = *((void *)this + 1) - *(void *)this;
  BOOL v4 = v3 >= v2;
  unint64_t v5 = v3 - v2;
  if (!v4) {
    unint64_t v5 = 0LL;
  }
  if (v5 < 4) {
    return 0LL;
  }
  unsigned int v6 = *(_DWORD *)(*(void *)this + v2);
  unsigned int v7 = bswap32(v6);
  if (*((_BYTE *)this + 16)) {
    uint64_t result = v7;
  }
  else {
    uint64_t result = v6;
  }
  *a2 = v2 + 4;
  return result;
}

unint64_t DNBDataRef::GetMax64(DNBDataRef *this, unsigned int *a2, int a3)
{
  switch(a3)
  {
    case 1:
      unint64_t v3 = *a2;
      if (*((void *)this + 1) - *(void *)this <= v3) {
        return 0LL;
      }
      unint64_t v4 = *(unsigned __int8 *)(*(void *)this + v3);
      unsigned int v5 = v3 + 1;
LABEL_17:
      *a2 = v5;
      return v4;
    case 2:
      unint64_t v4 = 0LL;
      unint64_t v15 = *a2;
      unint64_t v16 = *((void *)this + 1) - *(void *)this;
      BOOL v8 = v16 >= v15;
      unint64_t v17 = v16 - v15;
      if (!v8) {
        unint64_t v17 = 0LL;
      }
      if (v17 >= 2)
      {
        LODWORD(v4) = *(unsigned __int16 *)(*(void *)this + v15);
        unsigned int v18 = bswap32(v4) >> 16;
        if (*((_BYTE *)this + 16)) {
          LOWORD(v4) = v18;
        }
        *a2 = v15 + 2;
        return (unsigned __int16)v4;
      }

      return v4;
    case 4:
      unint64_t v4 = 0LL;
      unint64_t v6 = *a2;
      unint64_t v7 = *((void *)this + 1) - *(void *)this;
      BOOL v8 = v7 >= v6;
      unint64_t v9 = v7 - v6;
      if (!v8) {
        unint64_t v9 = 0LL;
      }
      if (v9 < 4) {
        return v4;
      }
      LODWORD(v4) = *(_DWORD *)(*(void *)this + v6);
      unsigned int v10 = bswap32(v4);
      if (*((_BYTE *)this + 16)) {
        unint64_t v4 = v10;
      }
      else {
        unint64_t v4 = v4;
      }
      unsigned int v5 = v6 + 4;
      goto LABEL_17;
    case 8:
      unint64_t v4 = 0LL;
      unint64_t v11 = *a2;
      unint64_t v12 = *((void *)this + 1) - *(void *)this;
      BOOL v8 = v12 >= v11;
      unint64_t v13 = v12 - v11;
      if (!v8) {
        unint64_t v13 = 0LL;
      }
      if (v13 < 8) {
        return v4;
      }
      unint64_t v4 = *(void *)(*(void *)this + v11);
      unint64_t v14 = bswap64(v4);
      if (*((_BYTE *)this + 16)) {
        unint64_t v4 = v14;
      }
      unsigned int v5 = v11 + 8;
      goto LABEL_17;
    default:
      DNBDataRef::GetMax64();
  }

uint64_t DNBDataRef::GetCStr(DNBDataRef *this, unsigned int *a2, int a3)
{
  uint64_t v3 = *(void *)this;
  if (*(void *)this >= *((void *)this + 1)) {
    return 0LL;
  }
  uint64_t v5 = *a2;
  uint64_t v6 = v3 + v5;
  if (a3) {
    unsigned int v7 = v5 + a3;
  }
  else {
    unsigned int v7 = v5 + strlen((const char *)(v3 + v5)) + 1;
  }
  *a2 = v7;
  return v6;
}

uint64_t DNBDataRef::Dump( uint64_t *a1, uint64_t a2, unsigned int a3, uint64_t a4, unsigned int a5, unsigned int a6, const char *a7)
{
  int v7 = a2;
  __str[0] = 0;
  unsigned int v91 = a2;
  unint64_t v9 = a2;
  unsigned int v13 = 0;
  unint64_t v14 = 0LL;
  if (a7) {
    unint64_t v15 = a7;
  }
  else {
    unint64_t v15 = " %lld";
  }
  unint64_t v16 = " 0x%llx";
  if (a7) {
    unint64_t v16 = a7;
  }
  uint64_t v89 = v16;
  unint64_t v17 = " %16.16llx";
  if (a7) {
    unint64_t v17 = a7;
  }
  __format = (char *)v17;
  uint64_t v87 = v15;
  if (a7) {
    unsigned int v18 = a7;
  }
  else {
    unsigned int v18 = " %8.8x";
  }
  std::string::size_type v19 = " %4.4x";
  if (a7) {
    std::string::size_type v19 = a7;
  }
  v84 = v19;
  uint64_t v85 = v18;
  if (a7) {
    stat v20 = a7;
  }
  else {
    stat v20 = " %c";
  }
  stat v21 = " %2.2x";
  if (a7) {
    stat v21 = a7;
  }
  uint64_t v82 = v21;
  uint64_t v83 = (char *)v20;
  LODWORD(v22) = a2;
  int v88 = a2;
  do
  {
    if (v13 % a6)
    {
      if (v14 >= 0x400) {
        goto LABEL_30;
      }
    }

    else
    {
      if (__str[0] && DNBLogEnabled()) {
        _DNBLog(0LL, (uint64_t)"%s", v31, v32, v33, v34, v35, v36, (uint64_t)__str);
      }
      unint64_t v14 = snprintf(__str, 0x400uLL, "0x%8.8llx:", (v22 - v7) + a4);
      if (v14 >= 0x400)
      {
LABEL_30:
        if (DNBLogEnabled()) {
          _DNBLog(0LL, (uint64_t)"%s", v25, v26, v27, v28, v29, v30, (uint64_t)__str);
        }
        unint64_t v14 = 0LL;
        __str[0] = 0;
        if (a5 > 7) {
          goto LABEL_23;
        }
      }
    }

    switch(a5)
    {
      case 0u:
        if (a1[1] - *a1 <= v9)
        {
          uint64_t v37 = 0LL;
        }

        else
        {
          uint64_t v37 = *(unsigned __int8 *)(*a1 + v9);
          unsigned int v91 = v22 + 1;
        }

        int v23 = snprintf(&__str[v14], 1024 - v14, v82, v37);
        goto LABEL_22;
      case 1u:
        if (a1[1] - *a1 <= v9)
        {
          unsigned int v38 = 0;
          uint64_t v39 = &__str[v14];
          size_t v40 = 1024 - v14;
        }

        else
        {
          unsigned int v38 = *(char *)(*a1 + v9);
          unsigned int v91 = v22 + 1;
          uint64_t v39 = &__str[v14];
          size_t v40 = 1024 - v14;
          if ((v38 & 0x80000000) != 0)
          {
            __uint32_t v41 = __maskrune(v38, 0x40000uLL);
            goto LABEL_80;
          }
        }

        __uint32_t v41 = _DefaultRuneLocale.__runetype[v38] & 0x40000;
LABEL_80:
        if (v41) {
          uint64_t v70 = v38;
        }
        else {
          uint64_t v70 = 32LL;
        }
        v14 += snprintf(v39, v40, v83, v70);
        int v7 = v88;
        goto LABEL_23;
      case 2u:
        unint64_t v42 = a1[1] - *a1;
        BOOL v43 = v42 >= v9;
        unint64_t v44 = v42 - v9;
        if (!v43) {
          unint64_t v44 = 0LL;
        }
        if (v44 < 2)
        {
          LOWORD(v45) = 0;
        }

        else
        {
          unsigned int v45 = *(unsigned __int16 *)(*a1 + v9);
          unsigned int v46 = bswap32(v45) >> 16;
          if (*((_BYTE *)a1 + 16)) {
            LOWORD(v45) = v46;
          }
          unsigned int v91 = v22 + 2;
        }

        int v23 = snprintf(&__str[v14], 1024 - v14, v84, (unsigned __int16)v45);
        goto LABEL_22;
      case 3u:
        unint64_t v47 = a1[1] - *a1;
        BOOL v43 = v47 >= v9;
        unint64_t v48 = v47 - v9;
        if (!v43) {
          unint64_t v48 = 0LL;
        }
        if (v48 < 4)
        {
          uint64_t v49 = 0LL;
        }

        else
        {
          LODWORD(v49) = *(_DWORD *)(*a1 + v9);
          unsigned int v50 = bswap32(v49);
          if (*((_BYTE *)a1 + 16)) {
            uint64_t v49 = v50;
          }
          else {
            uint64_t v49 = v49;
          }
          unsigned int v91 = v22 + 4;
        }

        int v23 = snprintf(&__str[v14], 1024 - v14, v85, v49);
        goto LABEL_22;
      case 4u:
        unint64_t v51 = 0LL;
        unint64_t v52 = a1[1] - *a1;
        BOOL v43 = v52 >= v9;
        unint64_t v53 = v52 - v9;
        if (!v43) {
          unint64_t v53 = 0LL;
        }
        if (v53 >= 8)
        {
          unint64_t v51 = *(void *)(*a1 + v9);
          unint64_t v54 = bswap64(v51);
          if (*((_BYTE *)a1 + 16)) {
            unint64_t v51 = v54;
          }
          unsigned int v91 = v22 + 8;
        }

        int v23 = snprintf(&__str[v14], 1024 - v14, __format, v51);
        goto LABEL_22;
      case 5u:
        if (!*((_BYTE *)a1 + 17)) {
          DNBDataRef::Dump();
        }
        unint64_t Max64 = DNBDataRef::GetMax64((DNBDataRef *)a1, &v91, *((unsigned __int8 *)a1 + 17));
        int v7 = v88;
        int v23 = snprintf(&__str[v14], 1024 - v14, v89, Max64);
        goto LABEL_22;
      case 6u:
        unint64_t v55 = a1[1];
        if (*a1 >= v55)
        {
          uint64_t v58 = 0LL;
        }

        else
        {
          uint64_t v56 = 0LL;
          uint64_t v57 = 0LL;
          uint64_t v58 = 0LL;
          unint64_t v59 = *a1 + v9;
          do
          {
            if (v59 + v56 >= v55) {
              break;
            }
            char v60 = *(_BYTE *)(v59 + v56);
            v58 |= (unint64_t)(v60 & 0x7F) << v57;
            v57 += 7LL;
            ++v56;
          }

          while (v60 < 0);
          unsigned int v91 = v56 + v22;
        }

        int v23 = snprintf(&__str[v14], 1024 - v14, v89, v58);
        goto LABEL_22;
      case 7u:
        uint64_t v61 = *a1;
        unint64_t v62 = a1[1];
        if (*a1 >= v62)
        {
          uint64_t v71 = 0LL;
          goto LABEL_99;
        }

        uint64_t v63 = v61 + v9;
        if (v61 + v9 >= v62)
        {
          uint64_t v66 = 0LL;
          int v68 = 0;
          int v67 = 0;
          BOOL v72 = 1;
          goto LABEL_94;
        }

        uint64_t v64 = 0LL;
        int v65 = 0;
        uint64_t v66 = 0LL;
        int v67 = v62 - (v22 + v61);
        int v68 = 7 * v67;
        break;
      default:
        goto LABEL_23;
    }

    while (1)
    {
      char v69 = *(_BYTE *)(v63 + v64);
      v66 |= (unint64_t)(v69 & 0x7F) << v65;
      if ((v69 & 0x80) == 0) {
        break;
      }
      ++v64;
      v65 += 7;
      if (v63 + v64 >= v62) {
        goto LABEL_93;
      }
    }

    int v68 = v65 + 7;
    int v67 = v64 + 1;
LABEL_93:
    BOOL v72 = (v69 & 0x40) == 0;
LABEL_94:
    if (v68 > 31) {
      BOOL v72 = 1;
    }
    uint64_t v73 = -1LL << v68;
    if (v72) {
      uint64_t v73 = 0LL;
    }
    uint64_t v71 = v73 | v66;
    unsigned int v91 = v67 + v22;
LABEL_99:
    int v23 = snprintf(&__str[v14], 1024 - v14, v87, v71);
LABEL_22:
    v14 += v23;
LABEL_23:
    ++v13;
    uint64_t v22 = v91;
    BOOL v24 = v91 < a3 && a1[1] - *a1 > (unint64_t)v91;
    unint64_t v9 = v91;
  }

  while (v24);
  if (__str[0] && DNBLogEnabled()) {
    _DNBLog(0LL, (uint64_t)"%s", v74, v75, v76, v77, v78, v79, (uint64_t)__str);
  }
  return v22;
}

uint64_t DNBError::AsString(DNBError *this)
{
  mach_error_t v2 = *(_DWORD *)this;
  if (!v2) {
    return 0LL;
  }
  if (*((char *)this + 31) < 0)
  {
    if (*((void *)this + 2)) {
      goto LABEL_13;
    }
  }

  else if (*((_BYTE *)this + 31))
  {
    goto LABEL_13;
  }

  uint64_t v3 = "Should have set BackBoard error when making the error string.";
  switch(*((_DWORD *)this + 1))
  {
    case 1:
      unint64_t v4 = mach_error_string(v2);
      goto LABEL_9;
    case 2:
      unint64_t v4 = strerror(v2);
LABEL_9:
      uint64_t v3 = v4;
      if (!v4) {
        break;
      }
      goto LABEL_12;
    case 4:
      goto LABEL_12;
    case 5:
      uint64_t v3 = "Should have set FrontBoard error when making the error string.";
LABEL_12:
      std::string::assign((std::string *)((char *)this + 8), v3);
      break;
    default:
      break;
  }

void DNBError::LogThreadedIfError(DNBError *this, const char *a2, ...)
{
  if (*(_DWORD *)this)
  {
    uint64_t v5 = 0LL;
    vasprintf(&v5, a2, va);
    if (v5)
    {
      uint64_t v3 = DNBError::AsString(this);
      if (DNBLogEnabled())
      {
        unint64_t v4 = "???";
        if (v3) {
          unint64_t v4 = (const char *)v3;
        }
        _DNBLogThreaded("error: %s err = %s (0x%8.8x)", v5, v4, *(_DWORD *)this);
      }

      free(v5);
    }
  }

void DNBError::LogThreaded(DNBError *this, const char *a2, ...)
{
  uint64_t v3 = 0LL;
  vasprintf(&v3, a2, va);
  if (v3)
  {
    if (*(_DWORD *)this)
    {
      DNBError::AsString(this);
      if (DNBLogEnabled()) {
        _DNBLogThreaded("error: %s err = %s (0x%8.8x)");
      }
    }

    else if (DNBLogEnabled())
    {
      _DNBLogThreaded("%s err = 0x%8.8x");
    }

    free(v3);
  }

uint64_t DNBLogSetDebug(uint64_t result)
{
  g_debug = result;
  return result;
}

uint64_t DNBLogSetVerbose(uint64_t result)
{
  g_verbose = result;
  return result;
}

BOOL DNBLogCheckLogBit(int a1)
{
  return (g_log_bits & a1) != 0;
}

uint64_t DNBLogSetLogMask(int a1)
{
  uint64_t v1 = g_log_bits;
  g_log_bits = a1;
  return v1;
}

void *DNBLogSetLogCallback(void *result, uint64_t a2)
{
  g_log_callback = result;
  g_log_baton = a2;
  return result;
}

void *DNBLogGetLogCallback()
{
  return g_log_callback;
}

BOOL DNBLogEnabled()
{
  return g_log_callback != 0LL;
}

BOOL DNBLogEnabledForAny(int a1)
{
  return (g_log_bits & a1) != 0 && g_log_callback != 0LL;
}

uint64_t _DNBLog( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if ((v11 & 1) == 0
  {
    PThreadMutex::PThreadMutex((PThreadMutex *)&_DNBLogVAPrintf(unsigned int,char const*,char *)::g_LogThreadedMutex, 2);
    __cxa_atexit( (void (*)(void *))PThreadMutex::~PThreadMutex,  &_DNBLogVAPrintf(unsigned int,char const*,char *)::g_LogThreadedMutex,  (void *)&_mh_execute_header);
  }

  pthread_mutex_lock(&_DNBLogVAPrintf(unsigned int,char const*,char *)::g_LogThreadedMutex);
  if (g_log_callback) {
    g_log_callback(g_log_baton, a1, a2, &a9);
  }
  return pthread_mutex_unlock(&_DNBLogVAPrintf(unsigned int,char const*,char *)::g_LogThreadedMutex);
}

uint64_t _DNBLogDebug( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  unint64_t v9 = off_100071000;
  if (g_log_callback) {
    BOOL v10 = g_debug == 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (!v10)
  {
    uint64_t v11 = result;
    if ((v12 & 1) == 0
    {
      PThreadMutex::PThreadMutex( (PThreadMutex *)&_DNBLogVAPrintf(unsigned int,char const*,char *)::g_LogThreadedMutex,  2);
      unint64_t v9 = off_100071000;
      __cxa_atexit( (void (*)(void *))PThreadMutex::~PThreadMutex,  &_DNBLogVAPrintf(unsigned int,char const*,char *)::g_LogThreadedMutex,  (void *)&_mh_execute_header);
    }

    pthread_mutex_lock(&_DNBLogVAPrintf(unsigned int,char const*,char *)::g_LogThreadedMutex);
    unsigned int v13 = v9[228];
    if (v13) {
      ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t *))v13)(g_log_baton, 8LL, v11, &a9);
    }
    return pthread_mutex_unlock(&_DNBLogVAPrintf(unsigned int,char const*,char *)::g_LogThreadedMutex);
  }

  return result;
}

void _DNBLogThreaded(char *a1, ...)
{
  if (g_log_callback)
  {
    BOOL v10 = 0LL;
    vasprintf(&v10, a1, va);
    if (v10)
    {
      gettimeofday((timeval *)&_DNBLogThreaded::tv, 0LL);
      int v1 = _DNBLogThreaded::g_timeval;
      if ((void)_DNBLogThreaded::g_timeval)
      {
        _DNBLogThreaded::delta = _DNBLogThreaded::tv - _DNBLogThreaded::g_timeval;
        _DNBLogThreaded::delta = DWORD2(_DNBLogThreaded::tv) - DWORD2(_DNBLogThreaded::g_timeval);
        if (DWORD2(_DNBLogThreaded::tv) - DWORD2(_DNBLogThreaded::g_timeval) >= 0)
        {
LABEL_8:
          _DNBLogThreaded::g_timeval = _DNBLogThreaded::tv;
          mach_port_name_t v2 = mach_thread_self();
          uint64_t v3 = ++g_message_id;
          getpid();
          _DNBLog(32LL, (uint64_t)"%u +%lu.%06u sec [%4.4x/%4.4x]: %s", v4, v5, v6, v7, v8, v9, v3);
          mach_port_deallocate(mach_task_self_, v2);
          free(v10);
          return;
        }

        _DNBLogThreaded::delta = _DNBLogThreaded::tv - _DNBLogThreaded::g_timeval - 1;
        int v1 = DWORD2(_DNBLogThreaded::tv) - DWORD2(_DNBLogThreaded::g_timeval) + 1000000;
      }

      else
      {
        _DNBLogThreaded::delta = 0LL;
      }

      _DNBLogThreaded::delta = v1;
      goto LABEL_8;
    }
  }

void _DNBLogError(char *a1, ...)
{
  if (g_log_callback)
  {
    uint64_t v7 = 0LL;
    vasprintf(&v7, a1, va);
    if (v7)
    {
      _DNBLog(2LL, (uint64_t)"error: %s", v1, v2, v3, v4, v5, v6, (uint64_t)v7);
      free(v7);
    }
  }

void _DNBLogWarning(char *a1, ...)
{
  if (g_log_callback)
  {
    uint64_t v7 = 0LL;
    vasprintf(&v7, a1, va);
    if (v7)
    {
      _DNBLog(4LL, (uint64_t)"warning: %s", v1, v2, v3, v4, v5, v6, (uint64_t)v7);
      free(v7);
    }
  }

void PThreadMutex::~PThreadMutex(pthread_mutex_t *this)
{
  if (pthread_mutex_destroy(this))
  {
    if (!pthread_mutex_unlock(this)) {
      pthread_mutex_destroy(this);
    }
  }

void PThreadMutex::PThreadMutex(PThreadMutex *this, int a2)
{
  if (pthread_mutexattr_init(&v4)) {
    PThreadMutex::PThreadMutex();
  }
  if (pthread_mutexattr_settype(&v4, a2)) {
    PThreadMutex::PThreadMutex();
  }
  if (pthread_mutex_init((pthread_mutex_t *)this, &v4)) {
    PThreadMutex::PThreadMutex();
  }
  if (pthread_mutexattr_destroy(&v4)) {
    PThreadMutex::PThreadMutex();
  }
}

void DNBThreadResumeActions::DNBThreadResumeActions(DNBThreadResumeActions *this)
{
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
}

void std::vector<BOOL>::assign(char **a1, unint64_t a2, unsigned __int8 *a3)
{
  a1[1] = 0LL;
  if (a2)
  {
    uint64_t v6 = a1[2];
    unint64_t v7 = (void)v6 << 6;
    if ((void)v6 << 6 >= a2)
    {
      a1[1] = (char *)a2;
    }

    else
    {
      unsigned int v18 = 0LL;
      __int128 v19 = 0uLL;
      if ((a2 & 0x8000000000000000LL) != 0) {
        abort();
      }
      unint64_t v8 = (void)v6 << 7;
      if (v8 <= ((a2 + 63) & 0xFFFFFFFFFFFFFFC0LL)) {
        unint64_t v8 = (a2 + 63) & 0xFFFFFFFFFFFFFFC0LL;
      }
      if (v7 <= 0x3FFFFFFFFFFFFFFELL) {
        unint64_t v9 = v8;
      }
      else {
        unint64_t v9 = 0x7FFFFFFFFFFFFFFFLL;
      }
      std::vector<BOOL>::reserve((uint64_t)&v18, v9);
      uint64_t v11 = v18;
      unsigned __int8 v12 = (char *)*((void *)&v19 + 1);
      unsigned int v18 = *a1;
      BOOL v10 = v18;
      __int128 v13 = *(_OWORD *)(a1 + 1);
      *a1 = v11;
      a1[1] = (char *)a2;
      a1[2] = v12;
      __int128 v19 = v13;
      if (v10) {
        operator delete(v10);
      }
    }

    unint64_t v14 = *a1;
    int v15 = *a3;
    unint64_t v16 = a2 >> 6;
    if (v15)
    {
      size_t v17 = 8 * v16;
      if (a2 >= 0x40) {
        memset(v14, 255, v17);
      }
      if ((a2 & 0x3F) != 0) {
        *(void *)&v14[v17] |= 0xFFFFFFFFFFFFFFFFLL >> -(a2 & 0x3F);
      }
    }

    else
    {
      if (a2 >= 0x40) {
        bzero(v14, 8 * v16);
      }
      if ((a2 & 0x3F) != 0) {
        *(void *)&v14[8 * v16] &= ~(0xFFFFFFFFFFFFFFFFLL >> -(a2 & 0x3F));
      }
    }
  }

uint64_t DNBThreadResumeActions::DNBThreadResumeActions(uint64_t a1, char *a2, size_t __sz)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  if (a2 && __sz)
  {
    std::vector<DNBThreadResumeAction>::__assign_with_size[abi:nn180100]<DNBThreadResumeAction const*,DNBThreadResumeAction const*>( (void *)a1,  a2,  &a2[24 * __sz],  __sz);
    unsigned __int8 v6 = 0;
    std::vector<BOOL>::assign((char **)(a1 + 24), __sz, &v6);
  }

  return a1;
}

uint64_t DNBThreadResumeActions::SetDefaultThreadActionIfNeeded(char **a1, int a2, int a3)
{
  unint64_t v7 = *a1;
  unsigned __int8 v6 = a1[1];
  unint64_t v8 = (v6 - *a1) / 24;
  if (v6 == *a1)
  {
LABEL_8:
    unint64_t v12 = (unint64_t)a1[2];
    if ((unint64_t)v6 >= v12)
    {
      unint64_t v14 = v8 + 1;
      if (v8 + 1 > 0xAAAAAAAAAAAAAAALL) {
        goto LABEL_35;
      }
      unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v12 - (void)v7) >> 3);
      if (2 * v15 > v14) {
        unint64_t v14 = 2 * v15;
      }
      if (v15 >= 0x555555555555555LL) {
        unint64_t v16 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v16 = v14;
      }
      if (v16)
      {
        if (v16 > 0xAAAAAAAAAAAAAAALL) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        size_t v17 = (char *)operator new(24 * v16);
      }

      else
      {
        size_t v17 = 0LL;
      }

      __int128 v19 = &v17[24 * v8];
      *(void *)__int128 v19 = 0LL;
      *((_DWORD *)v19 + 2) = a2;
      *((_DWORD *)v19 + 3) = a3;
      *((void *)v19 + 2) = -1LL;
      __int128 v13 = v19 + 24;
      if (v6 != v7)
      {
        do
        {
          __int128 v20 = *(_OWORD *)(v6 - 24);
          *((void *)v19 - 1) = *((void *)v6 - 1);
          *(_OWORD *)(v19 - 24) = v20;
          v19 -= 24;
          v6 -= 24;
        }

        while (v6 != v7);
        unsigned __int8 v6 = *a1;
      }

      *a1 = v19;
      a1[1] = v13;
      a1[2] = &v17[24 * v16];
      if (v6) {
        operator delete(v6);
      }
    }

    else
    {
      *(void *)unsigned __int8 v6 = 0LL;
      *((_DWORD *)v6 + 2) = a2;
      *((_DWORD *)v6 + 3) = a3;
      *((void *)v6 + 2) = -1LL;
      __int128 v13 = v6 + 24;
    }

    a1[1] = v13;
    unint64_t v21 = (unint64_t)a1[4];
    uint64_t v22 = a1[5];
    if (v21 != (void)v22 << 6)
    {
LABEL_34:
      a1[4] = (char *)(v21 + 1);
      uint64_t result = 1LL;
      *(void *)&a1[3][(v21 >> 3) & 0x1FFFFFFFFFFFFFF8LL] &= ~(1LL << v21);
      return result;
    }

    if ((uint64_t)(v21 + 1) >= 0)
    {
      unint64_t v23 = (void)v22 << 7;
      if (v23 <= (v21 & 0xFFFFFFFFFFFFFFC0LL) + 64) {
        unint64_t v23 = (v21 & 0xFFFFFFFFFFFFFFC0LL) + 64;
      }
      if (v21 <= 0x3FFFFFFFFFFFFFFELL) {
        unint64_t v24 = v23;
      }
      else {
        unint64_t v24 = 0x7FFFFFFFFFFFFFFFLL;
      }
      std::vector<BOOL>::reserve((uint64_t)(a1 + 3), v24);
      unint64_t v21 = (unint64_t)a1[4];
      goto LABEL_34;
    }

uint64_t DNBThreadResumeActions::DNBThreadResumeActions(uint64_t a1, int a2, int a3)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  DNBThreadResumeActions::SetDefaultThreadActionIfNeeded((char **)a1, a2, a3);
  return a1;
}

void DNBThreadResumeActions::Append(char **a1, __int128 *a2)
{
  uint64_t v5 = a1[1];
  unint64_t v4 = (unint64_t)a1[2];
  if ((unint64_t)v5 >= v4)
  {
    unint64_t v8 = *a1;
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 3);
    unint64_t v10 = v9 + 1;
    if (v9 + 1 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_27;
    }
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v4 - (void)v8) >> 3);
    if (2 * v11 > v10) {
      unint64_t v10 = 2 * v11;
    }
    if (v11 >= 0x555555555555555LL) {
      unint64_t v12 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      if (v12 > 0xAAAAAAAAAAAAAAALL) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      __int128 v13 = (char *)operator new(24 * v12);
    }

    else
    {
      __int128 v13 = 0LL;
    }

    unint64_t v14 = &v13[24 * v9];
    *(_OWORD *)unint64_t v14 = *a2;
    *((void *)v14 + 2) = *((void *)a2 + 2);
    unint64_t v7 = v14 + 24;
    if (v5 != v8)
    {
      do
      {
        __int128 v15 = *(_OWORD *)(v5 - 24);
        *((void *)v14 - 1) = *((void *)v5 - 1);
        *(_OWORD *)(v14 - 24) = v15;
        v14 -= 24;
        v5 -= 24;
      }

      while (v5 != v8);
      uint64_t v5 = *a1;
    }

    *a1 = v14;
    a1[1] = v7;
    a1[2] = &v13[24 * v12];
    if (v5) {
      operator delete(v5);
    }
  }

  else
  {
    __int128 v6 = *a2;
    *((void *)v5 + 2) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v5 = v6;
    unint64_t v7 = v5 + 24;
  }

  a1[1] = v7;
  unint64_t v16 = (unint64_t)a1[4];
  size_t v17 = a1[5];
  if (v16 != (void)v17 << 6) {
    goto LABEL_26;
  }
  if ((uint64_t)(v16 + 1) < 0) {
LABEL_27:
  }
    abort();
  unint64_t v18 = (void)v17 << 7;
  if (v18 <= (v16 & 0xFFFFFFFFFFFFFFC0LL) + 64) {
    unint64_t v18 = (v16 & 0xFFFFFFFFFFFFFFC0LL) + 64;
  }
  if (v16 <= 0x3FFFFFFFFFFFFFFELL) {
    unint64_t v19 = v18;
  }
  else {
    unint64_t v19 = 0x7FFFFFFFFFFFFFFFLL;
  }
  std::vector<BOOL>::reserve((uint64_t)(a1 + 3), v19);
  unint64_t v16 = (unint64_t)a1[4];
LABEL_26:
  a1[4] = (char *)(v16 + 1);
  *(void *)&a1[3][(v16 >> 3) & 0x1FFFFFFFFFFFFFF8LL] &= ~(1LL << v16);
}

void DNBThreadResumeActions::AppendAction( char **a1, uint64_t a2, unsigned int a3, unsigned int a4, uint64_t a5)
{
  *(void *)&__int128 v5 = a2;
  *((void *)&v5 + 1) = __PAIR64__(a4, a3);
  uint64_t v6 = a5;
  DNBThreadResumeActions::Append(a1, &v5);
}

void *DNBThreadResumeActions::GetActionForThread(DNBThreadResumeActions *this, uint64_t a2, int a3)
{
  uint64_t v3 = *(void **)this;
  unint64_t v4 = (void *)*((void *)this + 1);
  unint64_t v5 = ((uint64_t)v4 - *(void *)this) / 24;
  if (v4 == *(void **)this)
  {
LABEL_8:
    uint64_t result = 0LL;
    if (a2 && a3 && v4 != v3)
    {
      if (v5 <= 1) {
        uint64_t v8 = 1LL;
      }
      else {
        uint64_t v8 = v5;
      }
      while (*v3)
      {
        v3 += 3;
        if (!--v8) {
          return 0LL;
        }
      }

      return v3;
    }
  }

  else
  {
    if (v5 <= 1) {
      uint64_t v6 = 1LL;
    }
    else {
      uint64_t v6 = ((uint64_t)v4 - *(void *)this) / 24;
    }
    uint64_t result = *(void **)this;
    while (*result != a2)
    {
      result += 3;
      if (!--v6) {
        goto LABEL_8;
      }
    }
  }

  return result;
}

uint64_t DNBThreadResumeActions::NumActionsWithState(uint64_t *a1, int a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1] - *a1;
  if (!v3) {
    return 0LL;
  }
  unint64_t v4 = v3 / 24;
  if (v4 <= 1) {
    unint64_t v4 = 1LL;
  }
  if (v4 < 2)
  {
    unint64_t v5 = 0LL;
    uint64_t result = 0LL;
LABEL_14:
    unint64_t v14 = v4 - v5;
    __int128 v15 = (int *)(v2 + 24 * v5 + 8);
    do
    {
      int v16 = *v15;
      v15 += 6;
      if (v16 == a2) {
        ++result;
      }
      --v14;
    }

    while (v14);
    return result;
  }

  uint64_t v7 = 0LL;
  uint64_t v8 = 0LL;
  unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
  unint64_t v9 = (int *)(v2 + 32);
  unint64_t v10 = v4 & 0xFFFFFFFFFFFFFFFELL;
  do
  {
    int v11 = *(v9 - 6);
    int v13 = *v9;
    v9 += 12;
    int v12 = v13;
    if (v11 == a2) {
      ++v7;
    }
    if (v12 == a2) {
      ++v8;
    }
    v10 -= 2LL;
  }

  while (v10);
  uint64_t result = v8 + v7;
  if (v4 != v5) {
    goto LABEL_14;
  }
  return result;
}

uint64_t DNBThreadResumeActions::SetSignalHandledForThread(uint64_t this, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(uint64_t **)this;
    uint64_t v3 = *(void *)(this + 8);
    uint64_t v4 = v3 - *(void *)this;
    if (v3 != *(void *)this)
    {
      unint64_t v5 = 0LL;
      unint64_t v6 = v4 / 24;
      if (v6 <= 1) {
        unint64_t v6 = 1LL;
      }
      do
      {
        uint64_t v7 = *v2;
        v2 += 3;
        if (v7 == a2) {
          *(void *)(*(void *)(this + 24) + ((v5 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v5;
        }
        ++v5;
      }

      while (v6 != v5);
    }
  }

  return this;
}

void *std::vector<DNBThreadResumeAction>::__assign_with_size[abi:nn180100]<DNBThreadResumeAction const*,DNBThreadResumeAction const*>( void *result, char *__src, char *a3, size_t __sz)
{
  unint64_t v6 = __src;
  uint64_t v7 = result;
  uint64_t v8 = result[2];
  unint64_t v9 = (char *)*result;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - *result) >> 3) < __sz)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      uint64_t v8 = 0LL;
      *uint64_t v7 = 0LL;
      v7[1] = 0LL;
      v7[2] = 0LL;
    }

    if (__sz > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_23;
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 3);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= __sz) {
      uint64_t v11 = __sz;
    }
    unint64_t v12 = v10 >= 0x555555555555555LL ? 0xAAAAAAAAAAAAAAALL : v11;
    if (v12 > 0xAAAAAAAAAAAAAAALL) {
LABEL_23:
    }
      abort();
    uint64_t v13 = 3 * v12;
    uint64_t result = operator new(24 * v12);
    unint64_t v9 = (char *)result;
    *uint64_t v7 = result;
    v7[1] = result;
    v7[2] = &result[v13];
    size_t v14 = a3 - v6;
    if (v14) {
      uint64_t result = memcpy(result, v6, v14);
    }
    __int128 v15 = (void **)(v7 + 1);
    goto LABEL_22;
  }

  __int128 v15 = (void **)(result + 1);
  int v16 = (_BYTE *)result[1];
  if (0xAAAAAAAAAAAAAAABLL * ((v16 - v9) >> 3) >= __sz)
  {
    size_t v14 = a3 - __src;
    if (a3 == __src) {
      goto LABEL_22;
    }
    unint64_t v18 = (void *)*result;
LABEL_21:
    uint64_t result = memmove(v18, __src, v14);
    goto LABEL_22;
  }

  size_t v17 = &__src[8 * ((v16 - v9) >> 3)];
  if (v16 != v9)
  {
    uint64_t result = memmove((void *)*result, __src, v16 - v9);
    unint64_t v9 = (char *)*v15;
  }

  size_t v14 = a3 - v17;
  if (v14)
  {
    unint64_t v18 = v9;
    __src = v17;
    goto LABEL_21;
  }

void std::vector<BOOL>::reserve(uint64_t a1, unint64_t a2)
{
  if (a2 > *(void *)(a1 + 16) << 6)
  {
    if ((a2 & 0x8000000000000000LL) != 0) {
      abort();
    }
    unint64_t v3 = ((a2 - 1) >> 6) + 1;
    uint64_t v4 = (uint64_t *)operator new(8 * v3);
    unint64_t v5 = *(void **)a1;
    unint64_t v6 = *(void *)(a1 + 8);
    int v7 = v6 & 0x3F;
    unint64_t v8 = (v6 - 1) >> 6;
    if (v6 < 0x41) {
      unint64_t v8 = 0LL;
    }
    v4[v8] = 0LL;
    if (v6 > 0x3F || (v6 & 0x3F) != 0)
    {
      int v9 = 0;
      int v10 = 0;
      uint64_t v11 = &v5[v6 >> 6];
      unint64_t v12 = v4;
      uint64_t v13 = v5;
      do
      {
        uint64_t v14 = 1LL << v9;
        if (((*v13 >> v10) & 1) != 0) {
          uint64_t v15 = *v12 | v14;
        }
        else {
          uint64_t v15 = *v12 & ~v14;
        }
        uint64_t *v12 = v15;
        v13 += v10 == 63;
        if (v10 == 63) {
          int v10 = 0;
        }
        else {
          ++v10;
        }
        v12 += v9 == 63;
        if (v9 == 63) {
          int v9 = 0;
        }
        else {
          ++v9;
        }
      }

      while (v10 != v7 || v13 != v11);
    }

    *(void *)a1 = v4;
    *(void *)(a1 + 16) = v3;
    if (v5) {
      operator delete(v5);
    }
  }

void StdStringExtractor::StdStringExtractor(StdStringExtractor *this, const char *a2)
{
  *(void *)this = off_100060CD8;
  *(_OWORD *)((char *)this + 8) = 0u;
  unint64_t v3 = (std::string *)((char *)this + 8);
  *(_OWORD *)((char *)this + 24) = 0u;
  if (a2) {
    std::string::assign(v3, a2);
  }
}

void StdStringExtractor::~StdStringExtractor(void **this)
{
  *this = off_100060CD8;
}

{
  *this = off_100060CD8;
  operator delete(this);
}

uint64_t StdStringExtractor::GetChar(StdStringExtractor *this, char a2)
{
  unint64_t v2 = *((void *)this + 4);
  unint64_t v3 = *((unsigned __int8 *)this + 31);
  if (*((char *)this + 31) < 0)
  {
    if (v2 < *((void *)this + 2)) {
      goto LABEL_3;
    }
LABEL_7:
    uint64_t v5 = -1LL;
    goto LABEL_8;
  }

  if (v2 >= v3) {
    goto LABEL_7;
  }
LABEL_3:
  uint64_t v4 = (void *)((char *)this + 8);
  if ((v3 & 0x80) != 0) {
    uint64_t v4 = (void *)*v4;
  }
  a2 = *((_BYTE *)v4 + v2);
  uint64_t v5 = v2 + 1;
LABEL_8:
  *((void *)this + 4) = v5;
  return a2;
}

uint64_t StdStringExtractor::DecodeHexU8(StdStringExtractor *this)
{
  int v2 = *((char *)this + 31);
  if (v2 < 0) {
    unint64_t v3 = *((void *)this + 2);
  }
  else {
    unint64_t v3 = *((unsigned __int8 *)this + 31);
  }
  uint64_t v4 = (char *)this + 8;
  unint64_t v5 = *((void *)this + 4);
  if (v5 < v3)
  {
    while (1)
    {
      if (*((char *)this + 31) < 0)
      {
        __darwin_ct_rune_t v7 = *(char *)(*(void *)v4 + v5);
        if (v7 < 0)
        {
LABEL_6:
          int v6 = __maskrune(v7, 0x4000uLL);
          unint64_t v5 = *((void *)this + 4);
          if (!v6) {
            goto LABEL_13;
          }
          goto LABEL_7;
        }
      }

      else
      {
        __darwin_ct_rune_t v7 = v4[v5];
        if (v7 < 0) {
          goto LABEL_6;
        }
      }

      if ((_DefaultRuneLocale.__runetype[v7] & 0x4000) == 0)
      {
LABEL_13:
        LOBYTE(v2) = *((_BYTE *)this + 31);
        break;
      }

LABEL_7:
      *((void *)this + 4) = ++v5;
      if (v5 >= v3) {
        goto LABEL_13;
      }
    }
  }

  if ((v2 & 0x80) != 0)
  {
    unint64_t v8 = *((void *)this + 2);
    if (v5 >= v8) {
      return 0xFFFFFFFFLL;
    }
  }

  else
  {
    unint64_t v8 = v2;
  }

  if (v8 - v5 < 2) {
    return 0xFFFFFFFFLL;
  }
  int v10 = (char *)this + 8;
  if ((v2 & 0x80) != 0) {
    int v10 = *(char **)v4;
  }
  int v11 = v10[v5];
  unsigned int v12 = v11 - 97;
  int v13 = v11 - 48;
  else {
    int v14 = v13;
  }
  int v15 = v11 - 87;
  if (v12 > 5) {
    int v15 = v14;
  }
  if ((v2 & 0x80) != 0) {
    uint64_t v4 = *(char **)v4;
  }
  int v16 = v4[v5 + 1];
  unsigned int v17 = v16 - 97;
  int v18 = v16 - 48;
  else {
    int v19 = v18;
  }
  int v20 = v16 - 87;
  if (v17 > 5) {
    int v20 = v19;
  }
  uint64_t result = 0xFFFFFFFFLL;
  if (v15 != -1 && v20 != -1)
  {
    *((void *)this + 4) = v5 + 2;
    return (v20 + 16 * v15);
  }

  return result;
}

        lldb_private::SocketAddress::~SocketAddress((lldb_private::SocketAddress *)&v107);
LABEL_8:
        lldb_private::SocketAddress::~SocketAddress((lldb_private::SocketAddress *)&v99);
        v14 += 8;
      }

      while (v14 != v13);
    }

    uint64_t v33 = v96;
    if (!v96)
    {
      LODWORD(v97[0]) = *__error();
      HIDWORD(v97[0]) = 2;
      if (SHIBYTE(v98) < 0)
      {
        *(_BYTE *)v97[1] = 0;
        *(void *)&uint64_t v98 = 0LL;
      }

      else
      {
        LOBYTE(v97[1]) = 0;
        HIBYTE(v98) = 0;
      }

      DNBError::LogThreaded((DNBError *)v97, "::listen or ::bind failed");
      uint64_t v77 = 1LL;
      uint64_t v79 = (char *)v92;
      if (!v92) {
        goto LABEL_124;
      }
      goto LABEL_120;
    }

    if (a4)
    {
      a4(v83, Port);
      uint64_t v33 = v96;
      *(void *)uint64_t v89 = 0LL;
      uint64_t v90 = 0LL;
      unsigned int v91 = 0LL;
      if (!v96)
      {
LABEL_35:
        uint64_t v34 = v94;
        if (v94 != (uint64_t *)&v95)
        {
          uint64_t v35 = 0LL;
          p_filter = &v99.filter;
          do
          {
            uint64_t v37 = *((_OWORD *)v34 + 8);
            uint64_t v103 = *((_OWORD *)v34 + 7);
            uint64_t v104 = v37;
            uint64_t v105 = *((_OWORD *)v34 + 9);
            uint64_t v106 = v34[20];
            unsigned int v38 = *((_OWORD *)v34 + 3);
            uint64_t v39 = *((_OWORD *)v34 + 5);
            size_t v40 = *((_OWORD *)v34 + 6);
            uint64_t v100 = *((_OWORD *)v34 + 4);
            uint64_t v101 = v39;
            v102 = v40;
            *(_OWORD *)&v99.int ident = *((_OWORD *)v34 + 2);
            *(_OWORD *)&v99.int data = v38;
            __uint32_t v41 = *(void *)v89 + 32 * v35;
            *(void *)__uint32_t v41 = SLODWORD(v99.ident);
            *(_DWORD *)(v41 + 8) = 0x1FFFF;
            *(void *)(v41 + 20) = 0LL;
            *(void *)(v41 + 12) = 0LL;
            *(_DWORD *)(v41 + 28) = 0;
            lldb_private::SocketAddress::~SocketAddress((lldb_private::SocketAddress *)p_filter);
            unint64_t v42 = (uint64_t *)v34[1];
            if (v42)
            {
              do
              {
                BOOL v43 = v42;
                unint64_t v42 = (uint64_t *)*v42;
              }

              while (v42);
            }

            else
            {
              do
              {
                BOOL v43 = (uint64_t *)v34[2];
                unint64_t v44 = *v43 == (void)v34;
                uint64_t v34 = v43;
              }

              while (!v44);
            }

            ++v35;
            uint64_t v34 = v43;
          }

          while (v43 != (uint64_t *)&v95);
        }

        while (1)
        {
          *__error() = 0;
          unsigned int v45 = kevent(v10, *(const kevent **)v89, ((unint64_t)v90 - *(void *)v89) >> 5, &v99, 4, 0LL);
          if (v45 == -1)
          {
            if (*__error() != 35 && *__error() != 35 && *__error() != 4) {
              goto LABEL_91;
            }
          }

          else
          {
            if ((v45 & 0x80000000) == 0)
            {
              if (!v45) {
                goto LABEL_95;
              }
              unsigned int v46 = 0LL;
              unint64_t v47 = 0;
              unint64_t v48 = v45;
              while (2)
              {
                uint64_t v49 = v95;
                if (v95)
                {
                  unsigned int v50 = *((_DWORD *)&v99.ident + 8 * v46);
                  unint64_t v51 = (unsigned __int8 *)&v95;
                  do
                  {
                    unint64_t v52 = (unsigned __int8 *)v49;
                    unint64_t v53 = v51;
                    unint64_t v54 = *((_DWORD *)v49 + 8);
                    unint64_t v55 = (unsigned __int8 *)(v49 + 1);
                    if (v54 >= v50)
                    {
                      unint64_t v55 = v52;
                      unint64_t v51 = v52;
                    }

                    uint64_t v49 = *(void **)v55;
                  }

                  while (v49);
                  if (v51 != (unsigned __int8 *)&v95)
                  {
                    if (v54 < v50) {
                      unint64_t v52 = v53;
                    }
                    if (*((_DWORD *)v52 + 8) <= v50)
                    {
                      lldb_private::SocketAddress::SocketAddress((lldb_private::SocketAddress *)&v107);
                      MaxLength = 0;
                      MaxLength = lldb_private::SocketAddress::GetMaxLength(v56);
                      uint64_t v57 = accept(v50, &v107, &MaxLength);
                      *int v9 = v57;
                      if (v57 == -1)
                      {
                        LODWORD(v97[0]) = *__error();
                        HIDWORD(v97[0]) = 2;
                        if (SHIBYTE(v98) < 0)
                        {
                          *(_BYTE *)v97[1] = 0;
                          *(void *)&uint64_t v98 = 0LL;
                        }

                        else
                        {
                          LOBYTE(v97[1]) = 0;
                          HIBYTE(v98) = 0;
                        }

                        DNBError::LogThreaded((DNBError *)v97, "error: Socket accept failed.");
                      }

                      uint64_t v58 = (unint64_t)(v51 + 40);
                      if (lldb_private::SocketAddress::IsAnyAddr((lldb_private::SocketAddress *)(v51 + 40))
                        || lldb_private::SocketAddress::operator==(&v107.sa_len, v51 + 40))
                      {
                        unint64_t v47 = 1;
                      }

                      else
                      {
                        close(*v9);
                        unint64_t v59 = v9;
                        *int v9 = -1;
                        char v60 = __stderrp;
                        lldb_private::SocketAddress::GetIPAddress((unint64_t)&v107, v86);
                        uint64_t v61 = v87;
                        unint64_t v62 = (void **)v86[0];
                        lldb_private::SocketAddress::GetIPAddress(v58, __p);
                        uint64_t v63 = v86;
                        if (v61 < 0) {
                          uint64_t v63 = v62;
                        }
                        uint64_t v64 = __p;
                        if (v85 < 0) {
                          uint64_t v64 = (void **)__p[0];
                        }
                        fprintf( v60,  "error: rejecting incoming connection from %s (expecting %s)\n",  (const char *)v63,  (const char *)v64);
                        if (v85 < 0) {
                          operator delete(__p[0]);
                        }
                        int v9 = v59;
                        if (v87 < 0) {
                          operator delete(v86[0]);
                        }
                        if (DNBLogEnabled())
                        {
                          lldb_private::SocketAddress::GetIPAddress((unint64_t)&v107, v86);
                          int v65 = v87;
                          uint64_t v66 = (void **)v86[0];
                          lldb_private::SocketAddress::GetIPAddress(v58, __p);
                          int v67 = v86;
                          if (v65 < 0) {
                            int v67 = v66;
                          }
                          int v68 = __p;
                          if (v85 < 0) {
                            int v68 = (void **)__p[0];
                          }
                          _DNBLogThreaded( "error: rejecting connection from %s (expecting %s)\n",  (const char *)v67,  (const char *)v68);
                          int v9 = v59;
                          if (v85 < 0)
                          {
                            operator delete(__p[0]);
                            if ((v87 & 0x80000000) == 0) {
                              goto LABEL_86;
                            }
                          }

                          else if ((v87 & 0x80000000) == 0)
                          {
                            goto LABEL_86;
                          }

                          operator delete(v86[0]);
                        }

    int v6 = 0;
    goto LABEL_8;
  }

  if (v5 == a2)
  {
    if (DNBLogEnabledForAny(2))
    {
      DNBStateAsString(a2);
      _DNBLogThreaded("MachProcess::SetState(%s) ignoring redundant state change...");
    }

    goto LABEL_7;
  }

  if (a2 - 1 > 8) {
    int v6 = 1;
  }
  else {
    int v6 = dword_100051F38[a2 - 1];
  }
  if (DNBLogEnabledForAny(2))
  {
    int v11 = DNBStateAsString(a2);
    unsigned int v12 = DNBStateAsString(v5);
    _DNBLogThreaded( "MachProcess::SetState(%s) upating state (previous state was %s), event_mask = 0x%8.8x",  v11,  v12,  v6);
  }

  *(_DWORD *)(a1 + 1216) = a2;
  if (a2 == 4) {
    ++*(_DWORD *)(a1 + 444);
  }
LABEL_8:
  uint64_t result = pthread_mutex_unlock(v4);
  if (v6)
  {
    unint64_t v8 = (PThreadEvent *)(a1 + 1288);
    PThreadEvent::SetEvents((pthread_mutex_t *)(a1 + 1288), v6);
    int v9 = (pthread_mutex_t *)(a1 + 1464);
    PThreadEvent::SetEvents(v9, v6);
    if (v6 == 2) {
      int v10 = 1;
    }
    else {
      int v10 = 2;
    }
    PThreadEvent::ResetEvents(v9, v10);
    return PThreadEvent::WaitForResetAck(v8, v6, 0LL);
  }

  return result;
}

unint64_t StdStringExtractor::GetU32(StdStringExtractor *this, uint64_t a2, int a3)
{
  unint64_t v5 = *((void *)this + 4);
  int v6 = (char *)this + 8;
  if (*((char *)this + 31) < 0)
  {
    if (v5 >= *((void *)this + 2)) {
      return a2;
    }
    __endptr = 0LL;
    int v6 = *(const char **)v6;
  }

  else
  {
    __endptr = 0LL;
  }

  __darwin_ct_rune_t v7 = (char *)&v6[v5];
  unint64_t v8 = strtoul(&v6[v5], &__endptr, a3);
  if (__endptr && __endptr != v7)
  {
    *((void *)this + 4) = __endptr - v6;
    return v8;
  }

  return a2;
}

uint64_t StdStringExtractor::GetHexMaxU32(StdStringExtractor *this, char a2, uint64_t a3)
{
  else {
    unint64_t v6 = *((unsigned __int8 *)this + 31);
  }
  __darwin_ct_rune_t v7 = (char **)((char *)this + 8);
  for (unint64_t i = *((void *)this + 4); i < v6; *((void *)this + 4) = i)
  {
    if (*((char *)this + 31) < 0)
    {
      __darwin_ct_rune_t v9 = (*v7)[i];
      if (v9 < 0)
      {
LABEL_6:
        if (!__maskrune(v9, 0x4000uLL)) {
          break;
        }
        goto LABEL_7;
      }
    }

    else
    {
      __darwin_ct_rune_t v9 = *((char *)v7 + i);
      if (v9 < 0) {
        goto LABEL_6;
      }
    }

    if ((_DefaultRuneLocale.__runetype[v9] & 0x4000) == 0) {
      break;
    }
LABEL_7:
    unint64_t i = *((void *)this + 4) + 1LL;
  }

  unint64_t v10 = *((unsigned __int8 *)this + 31);
  unint64_t v11 = *((void *)this + 4);
  if ((a2 & 1) != 0)
  {
    uint64_t v12 = 0LL;
    unsigned int v13 = 0;
    char v14 = 0;
    while (1)
    {
      unint64_t v18 = v10;
      if ((v10 & 0x80) != 0) {
        unint64_t v18 = *((void *)this + 2);
      }
      if (v11 >= v18) {
        return v12;
      }
      int v19 = (char *)this + 8;
      if ((v10 & 0x80) != 0) {
        int v19 = *v7;
      }
      int v20 = v19[v11];
      if (v13 > 7) {
        goto LABEL_74;
      }
      unint64_t v21 = (char *)this + 8;
      if ((v10 & 0x80) != 0) {
        unint64_t v21 = *v7;
      }
      int v22 = v21[v11];
      unsigned int v23 = v22 - 97;
      char v24 = v22 - 48;
      else {
        char v25 = v24;
      }
      unsigned __int8 v26 = v22 - 87;
      if (v23 <= 5) {
        unsigned __int8 v27 = v26;
      }
      else {
        unsigned __int8 v27 = v25;
      }
      unint64_t v28 = v11 + 1;
      *((void *)this + 4) = v11 + 1;
      if ((v10 & 0x80) != 0)
      {
        if (v28 >= *((void *)this + 2)) {
          goto LABEL_15;
        }
      }

      else if (v28 >= v10)
      {
        goto LABEL_15;
      }

      if ((v10 & 0x80) != 0)
      {
        int v29 = (*v7)[v28];
        if (v29 < 0) {
          goto LABEL_15;
        }
      }

      else
      {
        int v29 = *((char *)v7 + v28);
        if (v29 < 0) {
          goto LABEL_15;
        }
      }

      if ((_DefaultRuneLocale.__runetype[v29] & 0x10000) == 0)
      {
LABEL_15:
        int v15 = v27 << v14;
        char v16 = 4;
        int v17 = 1;
        goto LABEL_16;
      }

      uint64_t v30 = (char *)this + 8;
      if ((v10 & 0x80) != 0) {
        uint64_t v30 = *v7;
      }
      int v31 = v30[v28];
      if ((v31 - 97) > 5)
      {
        unsigned int v33 = v31 - 65;
        char v34 = v31 - 48;
        unsigned __int8 v35 = v31 - 55;
        if (v33 <= 5) {
          unsigned __int8 v32 = v35;
        }
        else {
          unsigned __int8 v32 = v34;
        }
      }

      else
      {
        unsigned __int8 v32 = v31 - 87;
      }

      unint64_t v28 = v11 + 2;
      *((void *)this + 4) = v11 + 2;
      int v15 = (v27 << (v14 + 4)) | (v32 << v14);
      char v16 = 8;
      int v17 = 2;
LABEL_16:
      v13 += v17;
      v14 += v16;
      uint64_t v12 = v15 | v12;
      unint64_t v11 = v28;
    }
  }

  uint64_t v36 = 0LL;
  uint64_t v12 = 0LL;
  while (1)
  {
    unint64_t v42 = v10;
    if ((v10 & 0x80) != 0) {
      unint64_t v42 = *((void *)this + 2);
    }
    if (v11 + v36 >= v42) {
      return v12;
    }
    BOOL v43 = (char *)this + 8;
    if ((v10 & 0x80) != 0) {
      BOOL v43 = *v7;
    }
    int v44 = v43[v11 + v36];
    if ((_DWORD)v36 == 8) {
      break;
    }
    unsigned int v45 = (char *)this + 8;
    if ((v10 & 0x80) != 0) {
      unsigned int v45 = *v7;
    }
    int v37 = v45[v11 + v36];
    unsigned int v38 = v37 - 97;
    char v39 = v37 - 48;
    else {
      char v40 = v39;
    }
    unsigned __int8 v41 = v37 - 87;
    if (v38 > 5) {
      unsigned __int8 v41 = v40;
    }
    uint64_t v12 = v41 | (16 * v12);
    *((void *)this + 4) = v11 + v36++ + 1;
  }

LABEL_74:
  *((void *)this + 4) = -1LL;
  return a3;
}

  if (((char)v53.__r_.__value_.__s.__size_ & 0x80000000) == 0)
  {
    unsigned int v38 = v53.__r_.__value_.__s.__size_;
    char v39 = v48;
    if (v11 <= v53.__r_.__value_.__s.__size_)
    {
      char v40 = &v53;
      goto LABEL_79;
    }

    goto LABEL_101;
  }

  unsigned int v38 = v53.__r_.__value_.__l.__size_;
  char v39 = v48;
  if (v53.__r_.__value_.__l.__size_ < v11) {
    goto LABEL_101;
  }
  char v40 = (std::string *)v53.__r_.__value_.__r.__words[0];
LABEL_79:
  unsigned __int8 v41 = v38 - v11;
  if (v38 - v11 > 0x7FFFFFFFFFFFFFF7LL) {
LABEL_101:
  }
    abort();
  if (v41 >= 0x17)
  {
    BOOL v43 = (v41 & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((v41 | 7) != 0x17) {
      BOOL v43 = v41 | 7;
    }
    int v44 = v43 + 1;
    unint64_t v42 = operator new(v43 + 1);
    *(void *)&__dst.tv_usec = v41;
    unint64_t v52 = v44 | 0x8000000000000000LL;
    __dst.tv_sec = (__darwin_time_t)v42;
    goto LABEL_86;
  }

  HIBYTE(v52) = v38 - v11;
  unint64_t v42 = &__dst;
  if (v38 != v11) {
LABEL_86:
  }
    memmove(v42, (char *)v40 + v11, v41);
  *((_BYTE *)v42 + v41) = 0;
  if (v52 >= 0) {
    unsigned int v45 = (const std::string::value_type *)&__dst;
  }
  else {
    unsigned int v45 = (const std::string::value_type *)__dst.tv_sec;
  }
  if (v52 >= 0) {
    unsigned int v46 = HIBYTE(v52);
  }
  else {
    unsigned int v46 = *(void *)&__dst.tv_usec;
  }
  std::string::append(v39, v45, v46);
  if (SHIBYTE(v52) < 0) {
    operator delete((void *)__dst.tv_sec);
  }
LABEL_95:
  std::string::size_type size = v53.__r_.__value_.__s.__size_;
  uint64_t v4 = v49;
LABEL_96:
  if ((size & 0x80) != 0) {
    operator delete(v53.__r_.__value_.__l.__data_);
  }
  uint64_t result = (pthread_mutex_t *)pthread_mutex_unlock(v4);
  if (*(void *)(a1 + 736)) {
    return PThreadEvent::SetEvents((pthread_mutex_t *)(a1 + 120), 32);
  }
  return result;
}

unint64_t StdStringExtractor::GetHexMaxU64(StdStringExtractor *this, char a2, uint64_t a3)
{
  else {
    unint64_t v6 = *((unsigned __int8 *)this + 31);
  }
  __darwin_ct_rune_t v7 = (char **)((char *)this + 8);
  for (unint64_t i = *((void *)this + 4); i < v6; *((void *)this + 4) = i)
  {
    if (*((char *)this + 31) < 0)
    {
      __darwin_ct_rune_t v9 = (*v7)[i];
      if (v9 < 0)
      {
LABEL_6:
        if (!__maskrune(v9, 0x4000uLL)) {
          break;
        }
        goto LABEL_7;
      }
    }

    else
    {
      __darwin_ct_rune_t v9 = *((char *)v7 + i);
      if (v9 < 0) {
        goto LABEL_6;
      }
    }

    if ((_DefaultRuneLocale.__runetype[v9] & 0x4000) == 0) {
      break;
    }
LABEL_7:
    unint64_t i = *((void *)this + 4) + 1LL;
  }

  unint64_t v10 = *((unsigned __int8 *)this + 31);
  unint64_t v11 = *((void *)this + 4);
  if ((a2 & 1) != 0)
  {
    unint64_t v12 = 0LL;
    unsigned int v13 = 0;
    char v14 = 0;
    while (1)
    {
      unint64_t v18 = v10;
      if ((v10 & 0x80) != 0) {
        unint64_t v18 = *((void *)this + 2);
      }
      if (v11 >= v18) {
        return v12;
      }
      int v19 = (char *)this + 8;
      if ((v10 & 0x80) != 0) {
        int v19 = *v7;
      }
      int v20 = v19[v11];
      if (v13 > 0xF) {
        goto LABEL_75;
      }
      unint64_t v21 = (char *)this + 8;
      if ((v10 & 0x80) != 0) {
        unint64_t v21 = *v7;
      }
      int v22 = v21[v11];
      unsigned int v23 = v22 - 97;
      char v24 = v22 - 48;
      else {
        char v25 = v24;
      }
      unsigned __int8 v26 = v22 - 87;
      if (v23 <= 5) {
        unsigned __int8 v27 = v26;
      }
      else {
        unsigned __int8 v27 = v25;
      }
      unint64_t v28 = v11 + 1;
      *((void *)this + 4) = v11 + 1;
      if ((v10 & 0x80) != 0)
      {
        if (v28 >= *((void *)this + 2)) {
          goto LABEL_15;
        }
      }

      else if (v28 >= v10)
      {
        goto LABEL_15;
      }

      if ((v10 & 0x80) != 0)
      {
        int v29 = (*v7)[v28];
        if (v29 < 0) {
          goto LABEL_15;
        }
      }

      else
      {
        int v29 = *((char *)v7 + v28);
        if (v29 < 0) {
          goto LABEL_15;
        }
      }

      if ((_DefaultRuneLocale.__runetype[v29] & 0x10000) == 0)
      {
LABEL_15:
        unint64_t v15 = (unint64_t)v27 << v14;
        char v16 = 4;
        int v17 = 1;
        goto LABEL_16;
      }

      uint64_t v30 = (char *)this + 8;
      if ((v10 & 0x80) != 0) {
        uint64_t v30 = *v7;
      }
      int v31 = v30[v28];
      unsigned int v32 = v31 - 97;
      char v33 = v31 - 48;
      else {
        char v34 = v33;
      }
      unsigned __int8 v35 = v31 - 87;
      if (v32 <= 5) {
        unsigned __int8 v36 = v35;
      }
      else {
        unsigned __int8 v36 = v34;
      }
      unint64_t v28 = v11 + 2;
      *((void *)this + 4) = v11 + 2;
      unint64_t v15 = ((unint64_t)v27 << (v14 + 4)) | ((unint64_t)v36 << v14);
      char v16 = 8;
      int v17 = 2;
LABEL_16:
      v13 += v17;
      v14 += v16;
      v12 |= v15;
      unint64_t v11 = v28;
    }
  }

  uint64_t v37 = 0LL;
  unint64_t v12 = 0LL;
  while (1)
  {
    unint64_t v43 = v10;
    if ((v10 & 0x80) != 0) {
      unint64_t v43 = *((void *)this + 2);
    }
    if (v11 + v37 >= v43) {
      return v12;
    }
    int v44 = (char *)this + 8;
    if ((v10 & 0x80) != 0) {
      int v44 = *v7;
    }
    int v45 = v44[v11 + v37];
    if ((_DWORD)v37 == 16) {
      break;
    }
    unsigned int v46 = (char *)this + 8;
    if ((v10 & 0x80) != 0) {
      unsigned int v46 = *v7;
    }
    int v38 = v46[v11 + v37];
    unsigned int v39 = v38 - 97;
    char v40 = v38 - 48;
    else {
      char v41 = v40;
    }
    unsigned __int8 v42 = v38 - 87;
    if (v39 > 5) {
      unsigned __int8 v42 = v41;
    }
    unint64_t v12 = v42 | (16 * v12);
    *((void *)this + 4) = v11 + v37++ + 1;
  }

LABEL_75:
  *((void *)this + 4) = -1LL;
  return a3;
}

                              LOBYTE(v43) = 1;
                              if ((SHIBYTE(v72) & 0x80000000) == 0)
                              {
LABEL_65:
                                if ((v43 & 1) != 0) {
                                  goto LABEL_66;
                                }
LABEL_77:
                                int v44 = 0;
                                if ((SHIBYTE(v74) & 0x80000000) == 0)
                                {
LABEL_67:
                                  if ((v44 & 1) != 0) {
                                    goto LABEL_68;
                                  }
LABEL_79:
                                  int v45 = 0;
                                  if ((SHIBYTE(v77) & 0x80000000) == 0)
                                  {
LABEL_70:
                                    if (!v45) {
                                      return v2;
                                    }
                                    goto LABEL_71;
                                  }

                    unint64_t v52 = SLODWORD(v150.__vftable) + (uint64_t)(int)v149;
                    unint64_t v53 = HIDWORD(v150.__vftable) + HIDWORD(v149);
                    if (HIDWORD(v150.__vftable) + HIDWORD(v149) > 999999)
                    {
                      unint64_t v53 = HIDWORD(v150.__vftable) + HIDWORD(v149) - 1000000;
                      ++v52;
                    }

                    unint64_t v54 = 1000000 * v52 + v53;
                    unint64_t v55 = v148;
                    if ((unint64_t)v148 < v44)
                    {
                      uint64_t v146 = (char *)v44;
                      *uint64_t v148 = v54;
                      unint64_t v15 = v148 + 1;
LABEL_20:
                      uint64_t v163 = v15;
                      uint64_t v148 = v15;
                      goto LABEL_21;
                    }

                    uint64_t v56 = (uint64_t *)v162;
                    uint64_t v57 = (char *)v148 - (_BYTE *)v162;
                    uint64_t v58 = ((char *)v148 - (_BYTE *)v162) >> 3;
                    unint64_t v59 = v58 + 1;
                    if ((unint64_t)(v58 + 1) >> 61) {
LABEL_173:
                    }
                      std::vector<kevent>::__throw_length_error[abi:ne180100]();
                    else {
                      char v60 = v59;
                    }
                    if (v60)
                    {
                      if (v60 >> 61) {
LABEL_172:
                      }
                        std::__throw_bad_array_new_length[abi:ne180100]();
                      uint64_t v61 = operator new(8 * v60);
                      unint64_t v55 = v148;
                    }

                    else
                    {
                      uint64_t v61 = 0LL;
                    }

                    unint64_t v62 = (uint64_t *)&v61[8 * v58];
                    *unint64_t v62 = v54;
                    unint64_t v15 = v62 + 1;
                    if (v55 != v56)
                    {
                      uint64_t v63 = (char *)v55 - (char *)v56 - 8;
                      if (v63 >= 0x168)
                      {
                        int v67 = v55 - 1;
                        int v68 = ((char *)(v55 - 1) - (char *)v56) & 0xFFFFFFFFFFFFFFF8LL;
                        if (&v61[v57 - 8 - v68] > &v61[v57 - 8])
                        {
                          uint64_t v64 = v148;
                        }

                        else if ((uint64_t *)((char *)v67 - v68) > v67)
                        {
                          uint64_t v64 = v148;
                        }

                        else if ((unint64_t)((char *)v148 - v61 - v57) >= 0x20)
                        {
                          char v69 = (v63 >> 3) + 1;
                          uint64_t v70 = 8 * (v69 & 0x3FFFFFFFFFFFFFFCLL);
                          uint64_t v64 = &v148[v70 / 0xFFFFFFFFFFFFFFF8LL];
                          unint64_t v62 = (uint64_t *)((char *)v62 - v70);
                          uint64_t v71 = &v61[8 * v58 - 16];
                          BOOL v72 = v148 - 2;
                          uint64_t v73 = v69 & 0x3FFFFFFFFFFFFFFCLL;
                          do
                          {
                            uint64_t v74 = *(_OWORD *)v72;
                            *(v71 - 1) = *((_OWORD *)v72 - 1);
                            *uint64_t v71 = v74;
                            v71 -= 2;
                            v72 -= 4;
                            v73 -= 4LL;
                          }

                          while (v73);
                          if (v69 == (v69 & 0x3FFFFFFFFFFFFFFCLL)) {
                            goto LABEL_92;
                          }
                        }

                        else
                        {
                          uint64_t v64 = v148;
                        }
                      }

                      else
                      {
                        uint64_t v64 = v55;
                      }

                      do
                      {
                        int v65 = *--v64;
                        *--unint64_t v62 = v65;
                      }

                      while (v64 != v56);
                    }

unint64_t StdStringExtractor::GetHexBytes( StdStringExtractor *this, _BYTE *a2, unint64_t a3, int __c)
{
  if (a3)
  {
    unint64_t v8 = 0LL;
    unint64_t v9 = *((void *)this + 4);
    while (1)
    {
      if (*((char *)this + 31) < 0)
      {
        unint64_t v10 = *((void *)this + 2);
        if (v9 >= v10) {
          break;
        }
      }

      else
      {
        unint64_t v10 = *((unsigned __int8 *)this + 31);
        if (v9 >= v10) {
          break;
        }
      }

      if (v10 == v9) {
        break;
      }
      int v11 = StdStringExtractor::DecodeHexU8(this);
      if (v11 == -1)
      {
        *((void *)this + 4) = -1LL;
        LOBYTE(v11) = __c;
      }

      a2[v8] = v11;
      unint64_t v9 = *((void *)this + 4);
      if (v9 == -1LL) {
        break;
      }
      if (a3 == ++v8) {
        return a3;
      }
    }
  }

  else
  {
    unint64_t v8 = 0LL;
  }

  if (a3 > v8) {
    memset(&a2[v8], __c, a3 - v8);
  }
  return v8;
}

std::string::size_type StdStringExtractor::GetHexByteString(uint64_t a1, std::string *this)
{
  if ((char)this->__r_.__value_.__s.__size_ < 0)
  {
    *this->__r_.__value_.__l.__data_ = 0;
    this->__r_.__value_.__l.__size_ = 0LL;
  }

  else
  {
    this->__r_.__value_.__s.__data_[0] = 0;
    this->__r_.__value_.__s.__size_ = 0;
  }

  unint64_t v4 = *(void *)(a1 + 32);
  if (*(char *)(a1 + 31) < 0)
  {
    unint64_t v5 = *(void *)(a1 + 16);
    if (v4 < v5) {
      goto LABEL_6;
    }
LABEL_8:
    std::string::size_type v6 = 0LL;
    goto LABEL_9;
  }

  unint64_t v5 = *(unsigned __int8 *)(a1 + 31);
  if (v4 >= v5) {
    goto LABEL_8;
  }
LABEL_6:
  std::string::size_type v6 = (v5 - v4) >> 1;
LABEL_9:
  std::string::reserve(this, v6);
  while (1)
  {
    int v7 = StdStringExtractor::DecodeHexU8((StdStringExtractor *)a1);
    if (v7 == -1) {
      break;
    }
    if (!(_BYTE)v7) {
      goto LABEL_14;
    }
    std::string::append(this, 1uLL, v7);
  }

  *(void *)(a1 + 32) = -1LL;
LABEL_14:
  if ((this->__r_.__value_.__s.__size_ & 0x80u) == 0) {
    return this->__r_.__value_.__s.__size_;
  }
  else {
    return this->__r_.__value_.__l.__size_;
  }
}

uint64_t StdStringExtractor::GetNameColonValue(uint64_t a1, std::string *a2, std::string *a3)
{
  std::string::size_type v6 = *(void *)(a1 + 32);
  if (*(char *)(a1 + 31) < 0)
  {
    if (v6 >= *(void *)(a1 + 16))
    {
LABEL_8:
      uint64_t result = 0LL;
      uint64_t v11 = -1LL;
      goto LABEL_9;
    }
  }

  else if (v6 >= *(unsigned __int8 *)(a1 + 31))
  {
    goto LABEL_8;
  }

  std::string::size_type v7 = std::string::find((const std::string *)(a1 + 8), 58, v6);
  if (v7 == -1LL) {
    goto LABEL_8;
  }
  std::string::size_type v8 = v7;
  std::string::size_type v9 = std::string::find((const std::string *)(a1 + 8), 59, v7);
  if (v9 == -1LL) {
    goto LABEL_8;
  }
  std::string::size_type v10 = v9;
  std::string::assign(a2, (const std::string *)(a1 + 8), *(void *)(a1 + 32), v8 - *(void *)(a1 + 32));
  std::string::assign(a3, (const std::string *)(a1 + 8), v8 + 1, v10 - (v8 + 1));
  uint64_t v11 = v10 + 1;
  uint64_t result = 1LL;
LABEL_9:
  *(void *)(a1 + 32) = v11;
  return result;
}

double lldb_private::SocketAddress::SocketAddress(lldb_private::SocketAddress *this)
{
  double result = 0.0;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

uint64_t lldb_private::SocketAddress::GetLength(lldb_private::SocketAddress *this)
{
  return *(unsigned __int8 *)this;
}

uint64_t lldb_private::SocketAddress::GetMaxLength(lldb_private::SocketAddress *this)
{
  return 128LL;
}

uint64_t lldb_private::SocketAddress::GetFamily(lldb_private::SocketAddress *this)
{
  return *((unsigned __int8 *)this + 1);
}

unint64_t lldb_private::SocketAddress::GetIPAddress@<X0>(unint64_t this@<X0>, _BYTE *a2@<X8>)
{
  int v3 = *(unsigned __int8 *)(this + 1);
  if (v3 == 30)
  {
    unint64_t v4 = (const void *)(this + 8);
    int v5 = 30;
  }

  else
  {
    if (v3 != 2)
    {
LABEL_10:
      a2[23] = 0;
      *a2 = 0;
      return this;
    }

    unint64_t v4 = (const void *)(this + 4);
    int v5 = 2;
  }

  this = (unint64_t)inet_ntop(v5, v4, (char *)v10, 0x2Eu);
  if (!this) {
    goto LABEL_10;
  }
  this = strlen((const char *)v10);
  if (this > 0x7FFFFFFFFFFFFFF7LL) {
    abort();
  }
  size_t v6 = this;
  if (this >= 0x17)
  {
    uint64_t v7 = (this & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((this | 7) != 0x17) {
      uint64_t v7 = this | 7;
    }
    uint64_t v8 = v7 + 1;
    std::string::size_type v9 = operator new(v7 + 1);
    *((void *)a2 + 1) = v6;
    *((void *)a2 + 2) = v8 | 0x8000000000000000LL;
    *(void *)a2 = v9;
    a2 = v9;
  }

  else
  {
    a2[23] = this;
    if (!this) {
      goto LABEL_15;
    }
  }

  this = (unint64_t)memcpy(a2, v10, v6);
LABEL_15:
  a2[v6] = 0;
  return this;
}

uint64_t lldb_private::SocketAddress::GetPort(lldb_private::SocketAddress *this)
{
  int v1 = *((unsigned __int8 *)this + 1);
  if (v1 == 30 || v1 == 2) {
    return bswap32(*((unsigned __int16 *)this + 1)) >> 16;
  }
  else {
    return 0LL;
  }
}

uint64_t lldb_private::SocketAddress::SetPort(lldb_private::SocketAddress *this, unsigned int a2)
{
  int v2 = *((unsigned __int8 *)this + 1);
  if (v2 != 30 && v2 != 2) {
    return 0LL;
  }
  *((_WORD *)this + 1) = __rev16(a2);
  return 1LL;
}

void lldb_private::SocketAddress::GetAddressInfo( lldb_private::SocketAddress *this@<X0>, const char *a2@<X1>, const char *a3@<X2>, int a4@<W3>, int a5@<W4>, int a6@<W5>, char **a7@<X8>)
{
  *a7 = 0LL;
  a7[1] = 0LL;
  a7[2] = 0LL;
  memset(&v40.ai_addrlen, 0, 32);
  v40.ai_socktype = a4;
  v40.ai_protocol = a5;
  v40.ai_flags = a6;
  v40.ai_family = (int)a3;
  unsigned int v39 = 0LL;
  int v8 = getaddrinfo((const char *)this, a2, &v40, &v39);
  std::string::size_type v9 = v39;
  if (!v8 && v39)
  {
    std::string::size_type v10 = 0LL;
    uint64_t v11 = 0LL;
    unint64_t v12 = 0LL;
    do
    {
      __int128 v47 = 0u;
      __int128 v48 = 0u;
      __int128 v46 = 0u;
      __int128 v44 = 0u;
      __int128 v45 = 0u;
      __int128 v42 = 0u;
      __int128 v43 = 0u;
      __int128 __dst = 0u;
      ai_addr = v9->ai_addr;
      if (ai_addr)
      {
        size_t ai_addrlen = v9->ai_addrlen;
      }

      if (v10 < v11)
      {
        __int128 v13 = __dst;
        __int128 v14 = v42;
        __int128 v15 = v44;
        *((_OWORD *)v10 + 2) = v43;
        *((_OWORD *)v10 + 3) = v15;
        *(_OWORD *)std::string::size_type v10 = v13;
        *((_OWORD *)v10 + 1) = v14;
        __int128 v16 = v45;
        __int128 v17 = v46;
        __int128 v18 = v48;
        *((_OWORD *)v10 + 6) = v47;
        *((_OWORD *)v10 + 7) = v18;
        *((_OWORD *)v10 + 4) = v16;
        *((_OWORD *)v10 + 5) = v17;
        int v19 = v10 + 128;
      }

      else
      {
        uint64_t v22 = (v10 - v12) >> 7;
        unint64_t v23 = v22 + 1;
        if ((v11 - v12) >> 6 > v23) {
          unint64_t v23 = (v11 - v12) >> 6;
        }
        else {
          unint64_t v24 = v23;
        }
        if (v24)
        {
          if (v24 >> 57) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          char v25 = (char *)operator new(v24 << 7);
        }

        else
        {
          char v25 = 0LL;
        }

        unsigned __int8 v26 = &v25[128 * v22];
        __int128 v27 = v46;
        __int128 v28 = v47;
        *((_OWORD *)v26 + 4) = v45;
        *((_OWORD *)v26 + 5) = v27;
        __int128 v29 = v48;
        *((_OWORD *)v26 + 6) = v28;
        *((_OWORD *)v26 + 7) = v29;
        __int128 v30 = v42;
        *(_OWORD *)unsigned __int8 v26 = __dst;
        *((_OWORD *)v26 + 1) = v30;
        __int128 v31 = v44;
        *((_OWORD *)v26 + 2) = v43;
        *((_OWORD *)v26 + 3) = v31;
        if (v10 == v12)
        {
          unint64_t v12 = &v25[128 * v22];
        }

        else
        {
          unsigned int v32 = &v25[128 * v22];
          do
          {
            __int128 v33 = *((_OWORD *)v10 - 8);
            __int128 v34 = *((_OWORD *)v10 - 7);
            __int128 v35 = *((_OWORD *)v10 - 5);
            *((_OWORD *)v32 - 6) = *((_OWORD *)v10 - 6);
            *((_OWORD *)v32 - 5) = v35;
            *((_OWORD *)v32 - 8) = v33;
            *((_OWORD *)v32 - 7) = v34;
            __int128 v36 = *((_OWORD *)v10 - 4);
            __int128 v37 = *((_OWORD *)v10 - 3);
            __int128 v38 = *((_OWORD *)v10 - 1);
            *((_OWORD *)v32 - 2) = *((_OWORD *)v10 - 2);
            *((_OWORD *)v32 - 1) = v38;
            *((_OWORD *)v32 - 4) = v36;
            *((_OWORD *)v32 - 3) = v37;
            v32 -= 128;
            v10 -= 128;
          }

          while (v10 != v12);
          std::string::size_type v10 = v12;
          unint64_t v12 = v32;
        }

        uint64_t v11 = &v25[128 * v24];
        int v19 = v26 + 128;
        *a7 = v12;
        a7[1] = v26 + 128;
        a7[2] = v11;
        if (v10) {
          operator delete(v10);
        }
      }

      a7[1] = v19;
      std::string::size_type v9 = v9->ai_next;
      std::string::size_type v10 = v19;
    }

    while (v9);
    std::string::size_type v9 = v39;
  }

  if (v9) {
    freeaddrinfo(v9);
  }
}

uint64_t lldb_private::SocketAddress::SetToAnyAddress( lldb_private::SocketAddress *this, int a2, unsigned int a3)
{
  if (a2 == 30)
  {
    *(_WORD *)this = 7708;
    *((_WORD *)this + 1) = __rev16(a3);
    *(in6_addr *)((char *)this + 8) = in6addr_any;
    return 1LL;
  }

  else if (a2 == 2)
  {
    *(_WORD *)this = 528;
    *((_WORD *)this + 1) = __rev16(a3);
    *((_DWORD *)this + 1) = 0;
    return 1LL;
  }

  else
  {
    *((_OWORD *)this + 6) = 0u;
    *((_OWORD *)this + 7) = 0u;
    *((_OWORD *)this + 4) = 0u;
    *((_OWORD *)this + 5) = 0u;
    *((_OWORD *)this + 2) = 0u;
    *((_OWORD *)this + 3) = 0u;
    *(_OWORD *)this = 0u;
    *((_OWORD *)this + 1) = 0u;
    return 0LL;
  }

BOOL lldb_private::SocketAddress::IsAnyAddr(lldb_private::SocketAddress *this)
{
  if (*((_BYTE *)this + 1) == 2)
  {
    int v1 = *((_DWORD *)this + 1);
  }

  else
  {
    unint64_t v2 = bswap64(*((void *)this + 1));
    unint64_t v3 = bswap64(*(unint64_t *)in6addr_any.__u6_addr8);
    if (v2 == v3
      && (v2 = bswap64(*((void *)this + 2)), unint64_t v3 = bswap64(*(void *)&in6addr_any.__u6_addr32[2]), v2 == v3))
    {
      int v1 = 0;
    }

    else if (v2 < v3)
    {
      int v1 = -1;
    }

    else
    {
      int v1 = 1;
    }
  }

  return v1 == 0;
}

BOOL lldb_private::SocketAddress::IsLocalhost(lldb_private::SocketAddress *this)
{
  if (*((_BYTE *)this + 1) == 2) {
    return *((_DWORD *)this + 1) == 16777343;
  }
  return *((void *)this + 1) == *(void *)in6addr_loopback.__u6_addr8
      && *((void *)this + 2) == *(void *)&in6addr_loopback.__u6_addr32[2];
}

BOOL lldb_private::SocketAddress::operator==(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v2 = a1[1];
  if (v2 != a2[1] || *a1 != *a2) {
    return 0LL;
  }
  if (v2 != 30)
  {
    if (v2 == 2) {
      return *((_DWORD *)a1 + 1) == *((_DWORD *)a2 + 1);
    }
    return 0LL;
  }

  return *((void *)a1 + 1) == *((void *)a2 + 1) && *((void *)a1 + 2) == *((void *)a2 + 2);
}

void PseudoTerminal::PseudoTerminal(PseudoTerminal *this)
{
  *(void *)this = -1LL;
}

void PseudoTerminal::~PseudoTerminal(PseudoTerminal *this)
{
  int v2 = *(_DWORD *)this;
  if (v2 >= 1)
  {
    close(v2);
    *(_DWORD *)this = -1;
  }

  int v3 = *((_DWORD *)this + 1);
  if (v3 >= 1)
  {
    close(v3);
    *((_DWORD *)this + 1) = -1;
  }

uint64_t PseudoTerminal::OpenFirstAvailablePrimary(PseudoTerminal *this, int a2)
{
  int v3 = posix_openpt(a2);
  *(_DWORD *)this = v3;
  if (v3 < 0) {
    return 4294967294LL;
  }
  int v4 = grantpt(v3);
  int v5 = *(_DWORD *)this;
  if (v4 < 0)
  {
    uint64_t v6 = 4294967293LL;
    if (v5 <= 0) {
      return v6;
    }
LABEL_7:
    close(v5);
    *(_DWORD *)this = -1;
    return v6;
  }

  if (unlockpt(v5) < 0)
  {
    int v5 = *(_DWORD *)this;
    uint64_t v6 = 4294967292LL;
    goto LABEL_7;
  }

  return 0LL;
}

char *PseudoTerminal::SecondaryName(PseudoTerminal *this)
{
  int v1 = *(_DWORD *)this;
  if (v1 < 0) {
    return 0LL;
  }
  else {
    return ptsname(v1);
  }
}

uint64_t PseudoTerminal::Fork(int *a1, int *a2)
{
  int v4 = posix_openpt(131074);
  *a1 = v4;
  if (v4 < 0)
  {
    uint64_t result = 0xFFFFFFFFLL;
    int v12 = -2;
    goto LABEL_33;
  }

  int v5 = grantpt(v4);
  int v6 = *a1;
  if (v5 < 0)
  {
    int v12 = -3;
    if (v6 <= 0)
    {
LABEL_29:
      uint64_t result = 0xFFFFFFFFLL;
      goto LABEL_33;
    }

LABEL_27:
    close(v6);
    uint64_t result = 0xFFFFFFFFLL;
    *a1 = -1;
    goto LABEL_33;
  }

  if (unlockpt(v6) < 0)
  {
    int v6 = *a1;
    int v12 = -4;
    if (*a1 < 1) {
      goto LABEL_29;
    }
    goto LABEL_27;
  }

  *a2 = 0;
  uint64_t result = fork();
  if ((result & 0x80000000) != 0)
  {
    int v12 = -7;
  }

  else
  {
    if ((_DWORD)result) {
      return result;
    }
    setsid();
    int v8 = a1[1];
    if (v8 >= 1)
    {
      close(v8);
      a1[1] = -1;
    }

    if (*a1 < 0)
    {
      uint64_t result = 0LL;
    }

    else
    {
      uint64_t result = (uint64_t)ptsname(*a1);
      if (result)
      {
        int v9 = open((const char *)result, 2);
        a1[1] = v9;
        if (v9 < 0)
        {
          uint64_t result = 0LL;
          int v12 = -6;
        }

        else
        {
          *a2 = 0;
          if (*a1 >= 1)
          {
            close(*a1);
            *a1 = -1;
            int v9 = a1[1];
          }

          if (ioctl(v9, 0x20007461uLL, 0LL) < 0) {
            *a2 = -9;
          }
          if (dup2(a1[1], 0))
          {
            int v10 = *a2;
            if (!*a2) {
              int v10 = -10;
            }
            *a2 = v10;
          }

          if (dup2(a1[1], 1) != 1)
          {
            int v11 = *a2;
            if (!*a2) {
              int v11 = -11;
            }
            *a2 = v11;
          }

          if (dup2(a1[1], 2) == 2) {
            return 0LL;
          }
          uint64_t result = 0LL;
          if (*a2) {
            int v12 = *a2;
          }
          else {
            int v12 = -12;
          }
        }

        goto LABEL_33;
      }
    }

    int v12 = -5;
  }

        __p.__r_.__value_.__s.__size_ = 2;
        strcpy((char *)&__p, "OK");
        goto LABEL_31;
      }
    }

    int v11 = (v9 & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((v9 | 7) != 0x17) {
      int v11 = v9 | 7;
    }
    int v12 = v11 + 1;
    p_p = (std::string *)operator new(v11 + 1);
    __p.__r_.__value_.__l.__size_ = v9;
    __p.__r_.__value_.__l.__cap_ = v12 | 0x8000000000000000LL;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)p_p;
LABEL_15:
    memmove(p_p, v4, v9);
    goto LABEL_16;
  }

  __p.__r_.__value_.__s.__size_ = 3;
  int v3 = 3486533;
LABEL_30:
  LODWORD(__p.__r_.__value_.__l.__data_) = v3;
LABEL_31:
  __int128 v14 = RNBRemote::SendPacket((uint64_t)this, &__p);
  return v14;
}

  char v25 = v14 - 1;
  do
  {
    unsigned __int8 v26 = *--v6;
    *v25-- = v26;
  }

  while (v6 != v8);
LABEL_29:
  int v6 = (char *)*a1;
LABEL_30:
  *a1 = v13;
  a1[1] = v7;
  a1[2] = v15;
  if (v6) {
    operator delete(v6);
  }
LABEL_32:
  a1[1] = v7;
}

      CFRelease(v9);
      a1 = v29;
    }

    if (v7) {
      CFRelease(v7);
    }
  }

  else
  {
    GetProcesses(Mutable, 1);
  }

  XMLData = CFPropertyListCreateXMLData(kCFAllocatorDefault, Mutable);
  if (XMLData)
  {
    unint64_t v23 = XMLData;
    Length = CFDataGetLength(XMLData);
    BytePtr = CFDataGetBytePtr(v23);
    if (BytePtr) {
      unsigned __int8 v26 = Length <= 0;
    }
    else {
      unsigned __int8 v26 = 1;
    }
    if (v26)
    {
      if (DNBLogEnabled()) {
        _DNBLogError("empty application property list.");
      }
      __int128 v27 = 4294967294LL;
    }

    else
    {
      std::string::assign(a1, (const std::string::value_type *)BytePtr, Length);
      __int128 v27 = 0LL;
    }

    CFRelease(v23);
    if (Mutable) {
LABEL_44:
    }
      CFRelease(Mutable);
  }

  else
  {
    if (DNBLogEnabled()) {
      _DNBLogError("serializing task list.");
    }
    __int128 v27 = 4294967293LL;
    if (Mutable) {
      goto LABEL_44;
    }
  }

  return v27;
}

LABEL_33:
  *a2 = v12;
  return result;
}

void PThreadEvent::PThreadEvent(PThreadEvent *this, int a2, int a3)
{
  if (pthread_mutex_init((pthread_mutex_t *)this, 0LL)) {
    PThreadEvent::PThreadEvent();
  }
  pthread_cond_init((pthread_cond_t *)((char *)this + 64), 0LL);
  pthread_cond_init((pthread_cond_t *)((char *)this + 112), 0LL);
  *((_DWORD *)this + 40) = a2;
  *((_DWORD *)this + 41) = a3;
  *((_DWORD *)this + 42) = 0;
}

void PThreadEvent::~PThreadEvent(PThreadEvent *this)
{
  if (pthread_mutex_destroy((pthread_mutex_t *)this))
  {
    if (!pthread_mutex_unlock((pthread_mutex_t *)this)) {
      pthread_mutex_destroy((pthread_mutex_t *)this);
    }
  }

uint64_t PThreadEvent::GetEventBits(pthread_mutex_t *this)
{
  uint64_t v2 = *(unsigned int *)&this[2].__opaque[24];
  pthread_mutex_unlock(this);
  return v2;
}

pthread_mutex_t *PThreadEvent::SetEvents(pthread_mutex_t *this, int a2)
{
  if (a2)
  {
    int v3 = this;
    pthread_mutex_lock(this);
    int v4 = *(_DWORD *)&v3[2].__opaque[24];
    *(_DWORD *)&v3[2].__opaque[24] = v4 | a2;
    if (v4 != (v4 | a2)) {
      pthread_cond_broadcast((pthread_cond_t *)&v3[1]);
    }
    return (pthread_mutex_t *)pthread_mutex_unlock(v3);
  }

  return this;
}

pthread_mutex_t *PThreadEvent::ResetEvents(pthread_mutex_t *this, int a2)
{
  if (a2)
  {
    int v3 = this;
    pthread_mutex_lock(this);
    int v4 = *(_DWORD *)&v3[2].__opaque[24];
    int v5 = v4 & ~a2;
    *(_DWORD *)&v3[2].__opaque[24] = v5;
    if (v4 != v5) {
      pthread_cond_broadcast((pthread_cond_t *)&v3[1].__opaque[40]);
    }
    return (pthread_mutex_t *)pthread_mutex_unlock(v3);
  }

  return this;
}

uint64_t PThreadEvent::WaitForSetEvents(pthread_mutex_t *this, unsigned int a2, const timespec *a3)
{
  while (1)
  {
    int v7 = *(_DWORD *)&this[2].__opaque[24];
    uint64_t v8 = v7 & a2;
    if ((v7 & a2) != 0) {
      break;
    }
    int v9 = (pthread_cond_t *)&this[1];
    if (a3)
    {
      int v6 = pthread_cond_timedwait(v9, this, a3);
      if (v6 == 60)
      {
        uint64_t v8 = *(_DWORD *)&this[2].__opaque[24] & a2;
        break;
      }
    }

    else
    {
      int v6 = pthread_cond_wait(v9, this);
    }

    if (v6)
    {
      uint64_t v8 = 0LL;
      break;
    }
  }

  pthread_mutex_unlock(this);
  return v8;
}

uint64_t PThreadEvent::WaitForEventsToReset(pthread_mutex_t *this, unsigned int a2, const timespec *a3)
{
  while ((*(_DWORD *)&this[2].__opaque[24] & a2) != 0)
  {
    int v6 = (pthread_cond_t *)&this[1].__opaque[40];
    if (a3)
    {
      if (pthread_cond_timedwait(v6, this, a3))
      {
LABEL_6:
        uint64_t v7 = *(_DWORD *)&this[2].__opaque[24] & a2;
        goto LABEL_8;
      }
    }

    else if (pthread_cond_wait(v6, this))
    {
      goto LABEL_6;
    }
  }

  uint64_t v7 = 0LL;
LABEL_8:
  pthread_mutex_unlock(this);
  return v7;
}

uint64_t PThreadEvent::WaitForResetAck(PThreadEvent *this, int a2, const timespec *a3)
{
  int v3 = *((_DWORD *)this + 42) & a2;
  if (!v3) {
    return 0LL;
  }
  pthread_mutex_lock((pthread_mutex_t *)this);
  while ((*((_DWORD *)this + 40) & v3) != 0)
  {
    int v6 = (pthread_cond_t *)((char *)this + 112);
    if (a3)
    {
      if (pthread_cond_timedwait(v6, (pthread_mutex_t *)this, a3))
      {
LABEL_7:
        uint64_t v7 = *((_DWORD *)this + 40) & v3;
        goto LABEL_10;
      }
    }

    else if (pthread_cond_wait(v6, (pthread_mutex_t *)this))
    {
      goto LABEL_7;
    }
  }

  uint64_t v7 = 0LL;
LABEL_10:
  pthread_mutex_unlock((pthread_mutex_t *)this);
  return v7;
}

void RNBContext::~RNBContext(void **this)
{
  *this = off_100060CF8;
  if (*((_DWORD *)this + 3)) {
    RNBContext::StopProcessStatusThread((RNBContext *)this);
  }
  *((_DWORD *)this + 3) = 0;
  uint64_t v2 = this[56];
  if (v2)
  {
    this[57] = v2;
    operator delete(v2);
  }

  if (*((char *)this + 439) < 0)
  {
    operator delete(this[52]);
    if ((*((char *)this + 415) & 0x80000000) == 0)
    {
LABEL_7:
      int v3 = (void **)this[46];
      if (!v3) {
        goto LABEL_8;
      }
      goto LABEL_17;
    }
  }

  else if ((*((char *)this + 415) & 0x80000000) == 0)
  {
    goto LABEL_7;
  }

  operator delete(this[49]);
  int v3 = (void **)this[46];
  if (!v3)
  {
LABEL_8:
    int v4 = (void **)this[43];
    if (!v4) {
      goto LABEL_9;
    }
    goto LABEL_28;
  }

{
  void *v1;
  RNBContext::~RNBContext(this);
  operator delete(v1);
}

LABEL_28:
  uint64_t v7 = (void **)this[44];
  uint64_t v8 = v4;
  if (v7 != v4)
  {
    do
    {
      v7 -= 3;
    }

    while (v7 != v4);
    uint64_t v8 = (void **)this[43];
  }

  this[44] = v4;
  operator delete(v8);
  if (*((char *)this + 343) < 0) {
LABEL_35:
  }
    operator delete(this[40]);
LABEL_10:
  PThreadEvent::~PThreadEvent((PThreadEvent *)(this + 15));
  if (*((char *)this + 111) < 0)
  {
    operator delete(this[11]);
    if ((*((char *)this + 87) & 0x80000000) == 0)
    {
LABEL_12:
      goto LABEL_24;
    }
  }

  else if ((*((char *)this + 87) & 0x80000000) == 0)
  {
    goto LABEL_12;
  }

  operator delete(this[8]);
  if ((*((char *)this + 63) & 0x80000000) == 0)
  {
LABEL_13:
LABEL_25:
    operator delete(this[2]);
    return;
  }

  int v6 = v21;
LABEL_29:
  pthread_mutex_unlock(v6);
  return v12;
}

LABEL_24:
  operator delete(this[5]);
}

  int v12 = 1;
  __int128 v13 = v25;
  if (v25)
  {
LABEL_25:
    unsigned __int8 v26 = v13;
    operator delete(v13);
  }

  unint64_t v21 = (const std::string::value_type *)(*(uint64_t (**)(__int128 *))(v4 + 48))(a2);
  if (v21) {
    std::string::assign(&__p, v21);
  }
  uint64_t v22 = *(void *)(*(void *)(v3 + 32) + 8LL);
  unint64_t v23 = *(void *)(v22 + 48);
  if (v23 >= *(void *)(v22 + 56))
  {
    __int128 v28 = std::vector<Genealogy::Message>::__push_back_slow_path<Genealogy::Message const&>(v22 + 40, (uint64_t)&v33);
  }

  else
  {
    unint64_t v24 = v33;
    char v25 = v34;
    *(void *)(v23 + 32) = v35;
    *(_OWORD *)unint64_t v23 = v24;
    *(_OWORD *)(v23 + 16) = v25;
    unsigned __int8 v26 = (std::string *)(v23 + 40);
    if ((char)__p.__r_.__value_.__s.__size_ < 0)
    {
      std::string::__init_copy_ctor_external(v26, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }

    else
    {
      __int128 v27 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *(void *)(v23 + 56) = __p.__r_.__value_.__l.__cap_;
      *(_OWORD *)&v26->__r_.__value_.__l.__data_ = v27;
    }

    __int128 v28 = (char *)(v23 + 64);
  }

  *(void *)(v22 + 48) = v28;
  return 1LL;
}

  unint64_t v21 = (const std::string::value_type *)(*(uint64_t (**)(__int128 *))(v4 + 48))(a2);
  if (v21) {
    std::string::assign(&__p, v21);
  }
  uint64_t v22 = *(void *)(*(void *)(v3 + 32) + 8LL);
  unint64_t v23 = *(void *)(v22 + 48);
  if (v23 >= *(void *)(v22 + 56))
  {
    __int128 v28 = std::vector<Genealogy::Message>::__push_back_slow_path<Genealogy::Message const&>(v22 + 40, (uint64_t)&v33);
  }

  else
  {
    unint64_t v24 = v33;
    char v25 = v34;
    *(void *)(v23 + 32) = v35;
    *(_OWORD *)unint64_t v23 = v24;
    *(_OWORD *)(v23 + 16) = v25;
    unsigned __int8 v26 = (std::string *)(v23 + 40);
    if ((char)__p.__r_.__value_.__s.__size_ < 0)
    {
      std::string::__init_copy_ctor_external(v26, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }

    else
    {
      __int128 v27 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *(void *)(v23 + 56) = __p.__r_.__value_.__l.__cap_;
      *(_OWORD *)&v26->__r_.__value_.__l.__data_ = v27;
    }

    __int128 v28 = (char *)(v23 + 64);
  }

  *(void *)(v22 + 48) = v28;
  return 1LL;
}

void RNBContext::SetProcessID(RNBContext *this, int a2)
{
  if (*((_DWORD *)this + 3)) {
    RNBContext::StopProcessStatusThread(this);
  }
  *((_DWORD *)this + 3) = a2;
  if (a2) {
    RNBContext::StartProcessStatusThread((pthread_t *)this);
  }
}

char *RNBContext::EnvironmentAtIndex(RNBContext *this, unint64_t a2)
{
  uint64_t v2 = *((void *)this + 46);
  if (0xAAAAAAAAAAAAAAABLL * ((*((void *)this + 47) - v2) >> 3) <= a2) {
    return 0LL;
  }
  uint64_t result = (char *)(v2 + 24 * a2);
  if (result[23] < 0) {
    return *(char **)result;
  }
  return result;
}

void RNBContext::PushEnvironmentIfNeeded(RNBContext *this, const char *__s)
{
  if (!__s) {
    return;
  }
  size_t v4 = strlen(__s);
  if (v4 > 0x7FFFFFFFFFFFFFF7LL) {
LABEL_58:
  }
    abort();
  std::string::size_type v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    p_dst = (std::string *)operator new(v7 + 1);
    __dst.__r_.__value_.__l.__size_ = v5;
    __dst.__r_.__value_.__l.__cap_ = v8 | 0x8000000000000000LL;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_9;
  }

  __dst.__r_.__value_.__s.__size_ = v4;
  p_dst = &__dst;
  if (v4) {
LABEL_9:
  }
    memcpy(p_dst, __s, v5);
  p_dst->__r_.__value_.__s.__data_[v5] = 0;
  GetEnvironmentKey(&__dst, (uint64_t *)&__p);
  int v9 = (const std::string *)*((void *)this + 46);
  int v10 = (const std::string *)*((void *)this + 47);
  __int128 v37 = this;
  if (v9 != v10)
  {
    int v11 = (char)v42;
    size_t v12 = v41;
    __s1 = __p;
    if ((v42 & 0x80u) == 0) {
      size_t v13 = v42;
    }
    else {
      size_t v13 = v41;
    }
    uint64_t v14 = v42 - 1LL;
    do
    {
      GetEnvironmentKey(v9, (uint64_t *)&__dst);
      std::string::size_type size = __dst.__r_.__value_.__s.__size_;
      int v16 = (char)__dst.__r_.__value_.__s.__size_;
      if ((__dst.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        std::string::size_type size = __dst.__r_.__value_.__l.__size_;
      }
      if (v13 == size)
      {
        if ((__dst.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          __int128 v17 = &__dst;
        }
        else {
          __int128 v17 = (std::string *)__dst.__r_.__value_.__r.__words[0];
        }
        if (v11 < 0)
        {
          BOOL v26 = memcmp(__s1, v17, v12) == 0;
        }

        else
        {
          if (!v11)
          {
            BOOL v26 = 1;
LABEL_36:
            operator delete(__dst.__r_.__value_.__l.__data_);
            goto LABEL_37;
          }

          p_p = &__p;
          uint64_t v19 = v14;
          do
          {
            int v21 = *(unsigned __int8 *)p_p;
            p_p = (void **)((char *)p_p + 1);
            int v20 = v21;
            int v23 = v17->__r_.__value_.__s.__data_[0];
            __int128 v17 = (std::string *)((char *)v17 + 1);
            int v22 = v23;
            BOOL v25 = v19-- != 0;
            BOOL v26 = v20 == v22;
          }

          while (v20 == v22 && v25);
        }

        if (v16 < 0) {
          goto LABEL_36;
        }
      }

      else
      {
        BOOL v26 = 0;
      }

LABEL_37:
      if (v26) {
        goto LABEL_55;
      }
      ++v9;
    }

    while (v9 != v10);
  }

  size_t v27 = strlen(__s);
  if (v27 > 0x7FFFFFFFFFFFFFF7LL) {
    goto LABEL_58;
  }
  std::string::size_type v28 = v27;
  if (v27 >= 0x17)
  {
    uint64_t v31 = (v27 & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((v27 | 7) != 0x17) {
      uint64_t v31 = v27 | 7;
    }
    uint64_t v32 = v31 + 1;
    __int128 v29 = (std::string *)operator new(v31 + 1);
    __dst.__r_.__value_.__l.__size_ = v28;
    __dst.__r_.__value_.__l.__cap_ = v32 | 0x8000000000000000LL;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v29;
    __int128 v30 = v37;
    goto LABEL_49;
  }

  __dst.__r_.__value_.__s.__size_ = v27;
  __int128 v29 = &__dst;
  __int128 v30 = v37;
  if (v27) {
LABEL_49:
  }
    memcpy(v29, __s, v28);
  v29->__r_.__value_.__s.__data_[v28] = 0;
  unint64_t v33 = *((void *)v30 + 47);
  if (v33 >= *((void *)v30 + 48))
  {
    __int128 v35 = std::vector<std::string>::__push_back_slow_path<std::string>((void **)v30 + 46, (uint64_t)&__dst);
    int v36 = (char)__dst.__r_.__value_.__s.__size_;
    *((void *)v30 + 47) = v35;
    if (v36 < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
  }

  else
  {
    __int128 v34 = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
    *(void *)(v33 + 16) = __dst.__r_.__value_.__l.__cap_;
    *(_OWORD *)unint64_t v33 = v34;
    *((void *)v30 + 47) = v33 + 24;
  }

  LOBYTE(v11) = v42;
LABEL_55:
  if ((v11 & 0x80) != 0) {
    operator delete(__p);
  }
}

  if (DNBLogEnabledForAny(0x800000))
  {
    unint64_t v24 = &__str;
    if ((__str.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      unint64_t v24 = (std::string *)__str.__r_.__value_.__r.__words[0];
    }
    _DNBLogThreaded("unimplemented packet: '%s'", (const char *)v24);
  }

  if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    BOOL v25 = &__str;
  }
  else {
    BOOL v25 = (std::string *)__str.__r_.__value_.__r.__words[0];
  }
  RNBRemote::HandlePacket_UNIMPLEMENTED((RNBRemote *)a1, (const char *)v25);
  int v9 = 1LL;
LABEL_45:
  if ((char)__str.__r_.__value_.__s.__size_ < 0) {
LABEL_46:
  }
    operator delete(__str.__r_.__value_.__l.__data_);
  return v9;
}

  if (*((_BYTE *)this + 1752))
  {
    size_t v27 = *(_DWORD *)this;
    __int128 v46 = 0u;
    __int128 v47 = 0u;
    *(_OWORD *)timeval __p = 0u;
    v41.tv_sec = 12LL;
    if (sysctlnametomib("sysctl.proc_cputype", (int *)__p, (size_t *)&v41))
    {
      std::string::size_type v28 = 0LL;
    }

    else
    {
      tv_sec = v41.tv_sec;
      *((_DWORD *)__p + v41.tv_sec) = v27;
      v41.tv_sec = tv_sec + 1;
      __int128 v44 = 0;
      __int128 v43 = 4LL;
      else {
        std::string::size_type v28 = (DNBArchProtocol *)v44;
      }
    }

    if (*((_DWORD *)this + 1) != (_DWORD)v28)
    {
      if (DNBLogEnabled()) {
        _DNBLog( 0LL,  (uint64_t)"arch changed from 0x%8.8x to 0x%8.8x",  v30,  v31,  v32,  v33,  v34,  v35,  *((unsigned int *)this + 1));
      }
      *((_DWORD *)this + 1) = (_DWORD)v28;
      DNBArchProtocol::SetArchitecture(v28, 0);
    }

    MachThreadList::Clear((MachProcess *)((char *)this + 968));
    Genealogy::Clear((MachProcess *)((char *)this + 1080));
    DNBBreakpointList::DisableAll((MachProcess *)((char *)this + 1640));
    MachTask::ClearAllocations((MachProcess *)((char *)this + 104));
  }

  if (!*((_DWORD *)this + 436)) {
    goto LABEL_59;
  }
  if ((v7 & 1) == 0)
  {
    if (DNBLogEnabledForAny(2)) {
      _DNBLogThreaded( "MachProcess::ExceptionMessageBundleComplete(): didn't get signal %i after MachProcess::Interrupt()",  *((_DWORD *)this + 436));
    }
    goto LABEL_59;
  }

  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded( "MachProcess::ExceptionMessageBundleComplete(): process successfully interrupted with signal %i",  *((_DWORD *)this + 436));
  }
  *((_DWORD *)this + 436) = 0;
  if (!*((_DWORD *)this + 437))
  {
LABEL_59:
    int v36 = 0;
    goto LABEL_60;
  }

  int v36 = v6 == 1;
  if (v6 == 1 && DNBLogEnabledForAny(2)) {
    _DNBLogThreaded( "MachProcess::ExceptionMessageBundleComplete(): auto resuming due to unhandled interrupt signal %i",  *((_DWORD *)this + 437));
  }
  *((_DWORD *)this + 437) = 0;
LABEL_60:
  MachThreadList::ProcessDidStop((MachProcess *)((char *)this + 968), this);
  Genealogy::Clear((MachProcess *)((char *)this + 1080));
  __int128 v37 = *((void *)this + 110);
  if (*((void *)this + 111) != v37)
  {
    __int128 v38 = 0LL;
    unsigned int v39 = 2048LL;
    do
    {
      if (*(_DWORD *)(v37 + v39) == v5) {
        MachThreadList::NotifyException((MachProcess *)((char *)this + 968), (MachException::Data *)(v37 + v39));
      }
      if (DNBLogCheckLogBit(8)) {
        MachException::Message::Dump((MachException::Message *)(*((void *)this + 110) + v39 - 2048));
      }
      ++v38;
      __int128 v37 = *((void *)this + 110);
      v39 += 2088LL;
    }

    while (v38 < 0x77A9AF922545A3CDLL * ((*((void *)this + 111) - v37) >> 3));
  }

  if (DNBLogCheckLogBit(4)) {
    MachThreadList::Dump((MachProcess *)((char *)this + 968));
  }
  LOBYTE(v43) = 0;
  if (((v36 | !MachThreadList::ShouldStop((MachProcess *)((char *)this + 968), (BOOL *)&v43)) & 1) != 0)
  {
    MachProcess::PrivateResume(this);
  }

  else
  {
    gettimeofday((timeval *)__p, 0LL);
    v41.tv_sec = (__darwin_time_t)__p[0] + SLODWORD(__p[1]) / 1000000 + 1;
    v41.tv_nsec = 1000 * LODWORD(__p[1]) % 1000000000;
    PThreadEvent::WaitForEventsToReset((pthread_mutex_t *)((char *)this + 1288), 1u, &v41);
    MachProcess::SetState((uint64_t)this, 4u);
  }

  uint64_t v2 = v42;
  int v20 = *((unsigned int *)this + 30);
  if (v42) {
LABEL_73:
  }
    pthread_mutex_unlock(v2);
  return v20;
}

std::string::size_type GetEnvironmentKey@<X0>(const std::string *a1@<X0>, uint64_t *a2@<X8>)
{
  std::string::size_type result = std::string::find(a1, 61, 0LL);
  size_t size = a1->__r_.__value_.__s.__size_;
  int v6 = (char)size;
  if ((size & 0x80u) != 0LL) {
    size_t size = a1->__r_.__value_.__l.__size_;
  }
  if (v6 >= 0) {
    uint64_t v7 = a1;
  }
  else {
    uint64_t v7 = (const std::string *)a1->__r_.__value_.__r.__words[0];
  }
  if (size >= result) {
    size_t v8 = result;
  }
  else {
    size_t v8 = size;
  }
  if (v8 >= 0x7FFFFFFFFFFFFFF8LL) {
    abort();
  }
  if (v8 >= 0x17)
  {
    uint64_t v10 = (v8 & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v10 = v8 | 7;
    }
    uint64_t v11 = v10 + 1;
    int v9 = operator new(v10 + 1);
    a2[1] = v8;
    a2[2] = v11 | 0x8000000000000000LL;
    *a2 = (uint64_t)v9;
    goto LABEL_16;
  }

  *((_BYTE *)a2 + 23) = v8;
  int v9 = a2;
  if (v8) {
LABEL_16:
  }
    std::string::size_type result = (std::string::size_type)memmove(v9, v7, v8);
  *((_BYTE *)v9 + v8) = 0;
  if (*((char *)a2 + 23) < 0)
  {
    uint64_t v14 = a2[1];
    if (v14)
    {
      __int128 v15 = (uint64_t *)*a2;
      if (*(_BYTE *)(*a2 + v14 - 1) == 61)
      {
        uint64_t v13 = v14 - 1;
        a2[1] = v13;
        a2 = v15;
        goto LABEL_24;
      }
    }
  }

  else
  {
    uint64_t v12 = *((unsigned __int8 *)a2 + 23);
    if (*((_BYTE *)a2 + 23) && *((_BYTE *)a2 + v12 - 1) == 61)
    {
      uint64_t v13 = v12 - 1;
      *((_BYTE *)a2 + 23) = v13;
LABEL_24:
      *((_BYTE *)a2 + v13) = 0;
    }
  }

  return result;
}

char *RNBContext::ArgumentAtIndex(RNBContext *this, unint64_t a2)
{
  uint64_t v2 = *((void *)this + 43);
  if (0xAAAAAAAAAAAAAAABLL * ((*((void *)this + 44) - v2) >> 3) <= a2) {
    return 0LL;
  }
  std::string::size_type result = (char *)(v2 + 24 * a2);
  if (result[23] < 0) {
    return *(char **)result;
  }
  return result;
}

BOOL RNBContext::SetWorkingDirectory(RNBContext *this, const char *a2)
{
  int v4 = stat(a2, &v6);
  if (v4)
  {
    if (*((char *)this + 415) < 0)
    {
      **((_BYTE **)this + 49) = 0;
      *((void *)this + 50) = 0LL;
    }

    else
    {
      *((_BYTE *)this + 392) = 0;
      *((_BYTE *)this + 415) = 0;
    }
  }

  else
  {
    std::string::assign((std::string *)((char *)this + 392), a2);
  }

  return v4 == 0;
}

void RNBContext::StopProcessStatusThread(RNBContext *this)
{
  if (DNBLogEnabledForAny(0x400000)) {
    _DNBLogThreaded("RNBContext::%s called", "StopProcessStatusThread");
  }
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 120);
  if ((PThreadEvent::GetEventBits(v2) & 2) != 0)
  {
    gettimeofday(&v5, 0LL);
    v4.tv_sec = v5.tv_sec + v5.tv_usec / 1000000 + 2;
    v4.tv_nsec = 1000 * v5.tv_usec % 1000000000;
    int v3 = PThreadEvent::WaitForSetEvents(v2, 4u, &v4);
    if (DNBLogEnabledForAny(0x400000))
    {
      if (v3 == 4) {
        _DNBLogThreaded("RNBContext::%s thread stopped as requeseted");
      }
      else {
        _DNBLogThreaded("RNBContext::%s thread did not stop in 2 seconds...");
      }
    }
  }

void RNBContext::StartProcessStatusThread(pthread_t *this)
{
  if (DNBLogEnabledForAny(0x400000)) {
    _DNBLogThreaded("RNBContext::%s called", "StartProcessStatusThread");
  }
  uint64_t v2 = (pthread_mutex_t *)(this + 15);
  if ((PThreadEvent::GetEventBits((pthread_mutex_t *)(this + 15)) & 2) == 0)
  {
    int v3 = pthread_create(this + 37, 0LL, (void *(__cdecl *)(void *))RNBContext::ThreadFunctionProcessStatus, this);
    if (v3)
    {
      int v4 = v3;
      if (DNBLogEnabledForAny(0x400000)) {
        _DNBLogThreaded("RNBContext::%s thread failed to start: err = %i", "StartProcessStatusThread", v4);
      }
      PThreadEvent::ResetEvents(v2, 2);
      PThreadEvent::SetEvents(v2, 4);
    }

    else
    {
      PThreadEvent::WaitForSetEvents((pthread_mutex_t *)(this + 15), 2u, 0LL);
      if (DNBLogEnabledForAny(0x400000)) {
        _DNBLogThreaded("RNBContext::%s thread got started!", "StartProcessStatusThread");
      }
    }
  }

uint64_t RNBContext::ThreadFunctionProcessStatus(RNBContext *this, void *a2)
{
  uint64_t v4 = g_remoteSP;
  int v3 = (std::__shared_weak_count *)qword_1000716A0;
  if (qword_1000716A0)
  {
    timeval v5 = (unint64_t *)(qword_1000716A0 + 8);
    do
      unint64_t v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }

  if (v4)
  {
    int v7 = *(_DWORD *)(v4 + 12);
    if (DNBLogEnabledForAny(0x400000)) {
      _DNBLogThreaded("RNBContext::%s (arg=%p, pid=%4.4x): thread starting...", "ThreadFunctionProcessStatus", this, v7);
    }
    size_t v8 = (pthread_mutex_t *)(v4 + 120);
    PThreadEvent::SetEvents(v8, 2);
    pthread_setname_np("child process status watcher thread");
    int v17 = 0;
    int v9 = pthread_self();
    if (!pthread_getschedparam(v9, &v17, &v18))
    {
      v18.sched_priority = 47;
      uint64_t v10 = pthread_self();
      pthread_setschedparam(v10, v17, &v18);
    }

    while (1)
    {
      if (DNBLogEnabledForAny(0x400000)) {
        _DNBLogThreaded( "RNBContext::%s calling DNBProcessWaitForEvent(pid, eEventProcessRunningStateChanged | eEventProcessStoppedStat eChanged | eEventStdioAvailable | eEventProfileDataAvailable, true)...",  "ThreadFunctionProcessStatus");
      }
      int v11 = DNBProcessWaitForEvents(v7, 0x1Bu, 1, 0LL);
      if (DNBLogEnabledForAny(0x400000))
      {
        _DNBLogThreaded( "RNBContext::%s calling DNBProcessWaitForEvent(pid, eEventProcessRunningStateChanged | eEventProcessStoppedStat eChanged | eEventStdioAvailable | eEventProfileDataAvailable, true) => 0x%8.8x",  "ThreadFunctionProcessStatus",  v11);
        if (!v11) {
          goto LABEL_19;
        }
LABEL_14:
        if ((v11 & 8) != 0)
        {
          if (DNBLogEnabledForAny(0x400000)) {
            _DNBLogThreaded( "RNBContext::%s (pid=%4.4x) got stdio available event....",  "ThreadFunctionProcessStatus",  v7);
          }
          PThreadEvent::SetEvents(v8, 8);
          PThreadEvent::WaitForResetAck((PThreadEvent *)v8, 8, 0LL);
          if ((v11 & 0x10) != 0)
          {
LABEL_24:
            if (DNBLogEnabledForAny(0x400000)) {
              _DNBLogThreaded( "RNBContext::%s (pid=%4.4x) got profile data event....",  "ThreadFunctionProcessStatus",  v7);
            }
            PThreadEvent::SetEvents(v8, 16);
            PThreadEvent::WaitForResetAck((PThreadEvent *)v8, 16, 0LL);
            if ((v11 & 3) == 0) {
              goto LABEL_9;
            }
            goto LABEL_27;
          }
        }

        else if ((v11 & 0x10) != 0)
        {
          goto LABEL_24;
        }

        if ((v11 & 3) == 0) {
          goto LABEL_9;
        }
LABEL_27:
        unsigned int State = DNBProcessGetState(v7);
        if (DNBLogEnabledForAny(0x400000))
        {
          uint64_t v13 = DNBStateAsString(State);
          _DNBLogThreaded( "RNBContext::%s (pid=%4.4x) got process state change: %s",  "ThreadFunctionProcessStatus",  v7,  v13);
        }

        PThreadEvent::SetEvents(v8, 1);
        PThreadEvent::WaitForResetAck((PThreadEvent *)v8, 1, 0LL);
        if (State <= 9 && ((1 << State) & 0x301) != 0)
        {
          DNBProcessResetEvents(v7, v11);
          if (DNBLogEnabledForAny(0x400000)) {
            _DNBLogThreaded( "RNBContext::%s (arg=%p, pid=%4.4x): thread exiting...",  "ThreadFunctionProcessStatus",  this,  v7);
          }
          PThreadEvent::ResetEvents(v8, 2);
          PThreadEvent::SetEvents(v8, 4);
          break;
        }

LABEL_9:
        DNBProcessResetEvents(v7, v11);
      }

      else
      {
        if (v11) {
          goto LABEL_14;
        }
LABEL_19:
        if (DNBLogEnabledForAny(0x400000)) {
          _DNBLogThreaded( "RNBContext::%s (pid=%4.4x) got ZERO back from DNBProcessWaitForEvent....",  "ThreadFunctionProcessStatus",  v7);
        }
      }
    }
  }

  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v15 = __ldaxr(p_shared_owners);
    while (__stlxr(v15 - 1, p_shared_owners));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *, void *))v3->__on_zero_shared)(v3, a2);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

  return 0LL;
}

  get_identifier(&v52, &__str);
  if (((char)__str.__r_.__value_.__s.__size_ & 0x80000000) == 0)
  {
    if (__str.__r_.__value_.__s.__size_ == 3)
    {
      p_str = &__str;
      goto LABEL_14;
    }

std::string *RNBContext::EventsAsString(int a1, char a2, std::string *this)
{
  if (((char)this->__r_.__value_.__s.__size_ & 0x80000000) == 0)
  {
    this->__r_.__value_.__s.__data_[0] = 0;
    this->__r_.__value_.__s.__size_ = 0;
    if ((a2 & 1) == 0) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }

  *this->__r_.__value_.__l.__data_ = 0;
  this->__r_.__value_.__l.__size_ = 0LL;
  if ((a2 & 1) != 0) {
LABEL_3:
  }
    std::string::append(this, "proc_state_changed ");
LABEL_4:
  if ((a2 & 2) != 0)
  {
    std::string::append(this, "proc_thread_running ");
    if ((a2 & 4) == 0)
    {
LABEL_6:
      if ((a2 & 8) == 0) {
        goto LABEL_7;
      }
      goto LABEL_16;
    }
  }

  else if ((a2 & 4) == 0)
  {
    goto LABEL_6;
  }

  std::string::append(this, "proc_thread_exiting ");
  if ((a2 & 8) == 0)
  {
LABEL_7:
    if ((a2 & 0x10) == 0) {
      goto LABEL_8;
    }
    goto LABEL_17;
  }

LABEL_16:
  std::string::append(this, "proc_stdio_available ");
  if ((a2 & 0x10) == 0)
  {
LABEL_8:
    if ((a2 & 0x20) == 0) {
      goto LABEL_9;
    }
    goto LABEL_18;
  }

  if (!pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 552))
    || pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 552)))
  {
    goto LABEL_19;
  }

  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 552));
  if (*((char *)this + 535) < 0) {
LABEL_19:
  }
    operator delete(*((void **)this + 64));
LABEL_20:
  RNBSocket::Disconnect((RNBRemote *)((char *)this + 472));
  timeval v5 = (pthread_mutex_t *)*((void *)this + 61);
  *((void *)this + 61) = 0LL;
  if (v5)
  {
    if (pthread_mutex_destroy(v5) && !pthread_mutex_unlock(v5)) {
      pthread_mutex_destroy(v5);
    }
    operator delete(v5);
  }

  RNBContext::~RNBContext(this);
}

      if (!(_BYTE)v5) {
        break;
      }
      goto LABEL_17;
    case 'I':
      StdStringExtractor::GetHexByteString((uint64_t)&__p, (std::string *)((char *)this + 16));
      if (*((char *)this + 39) < 0)
      {
        if (!*((void *)this + 3)) {
          break;
        }
      }

      else if (!*((_BYTE *)this + 39))
      {
        break;
      }

  uint64_t v12 = __str->__r_.__value_.__l.__size_;
  if (!v12)
  {
LABEL_43:
    int v16 = 0LL;
    goto LABEL_45;
  }

        unint64_t v15 = v8;
        unint64_t v6 = &v15;
        goto LABEL_7;
      }

      uint64_t v13 = 125;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)&v13, 1LL);
      uint64_t v14 = v8 ^ 0x20;
      unint64_t v6 = &v14;
LABEL_7:
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)v6, 1LL);
    }
  }

  v18.__r_.__value_.__s.__size_ = 15;
  strcpy((char *)&v18, "no_shared_cache");
  JSONGenerator::Dictionary::AddBooleanItem(v24, &v18, v28);
  unint64_t v15 = v24;
  v17.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x20uLL);
  *(_OWORD *)&v17.__r_.__value_.__r.__words[1] = xmmword_100051FA0;
  strcpy(v17.__r_.__value_.__l.__data_, "shared_cache_private_cache");
  JSONGenerator::Dictionary::AddBooleanItem(v15, &v17, v29);
  (*((void (**)(uint64_t))this + 222))(v7);
LABEL_21:
  std::string::size_type result = *(double *)&v24;
  *a2 = v24;
  return result;
}

LABEL_18:
  std::string::append(this, "read_packet_available ");
  if ((a2 & 0x40) != 0)
  {
LABEL_10:
    std::string::append(this, "read_thread_running ");
    std::string::append(this, "read_thread_running ");
  }

    __p.__r_.__value_.__s.__size_ = 3;
    LODWORD(__p.__r_.__value_.__l.__data_) = 3749445;
    uint64_t v14 = RNBRemote::SendPacket((uint64_t)this, &__p);
    goto LABEL_19;
  }

  if (__str.__r_.__value_.__l.__size_ != 3) {
    goto LABEL_18;
  }
  p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
LABEL_14:
  data_low = LOWORD(p_str->__r_.__value_.__l.__data_);
  uint64_t v12 = p_str->__r_.__value_.__s.__data_[2];
  if (data_low != 25971 || v12 != 116) {
    goto LABEL_18;
  }
  get_identifier(&v52, &__p);
  memset(&v49, 0, sizeof(v49));
  size_t size = v52.__r_.__value_.__s.__size_;
  if ((v52.__r_.__value_.__s.__size_ & 0x80) != 0)
  {
    sched_param v18 = v52.__r_.__value_.__l.__size_;
    if (!v52.__r_.__value_.__l.__size_)
    {
      memset(&v48, 0, sizeof(v48));
      goto LABEL_55;
    }

    int v17 = (std::string *)v52.__r_.__value_.__r.__words[0];
  }

  else
  {
    if (!v52.__r_.__value_.__s.__size_) {
      goto LABEL_44;
    }
    int v17 = &v52;
    sched_param v18 = v52.__r_.__value_.__s.__size_;
  }

  uint64_t v19 = k_space_delimiters;
  int v20 = strlen(k_space_delimiters);
  int v21 = v17;
  if (v20)
  {
    int v22 = v20;
    int v21 = v17;
    while (memchr(v19, v21->__r_.__value_.__s.__data_[0], v22))
    {
      int v21 = (std::string *)((char *)v21 + 1);
      if (!--v18)
      {
        int v23 = -1LL;
        goto LABEL_42;
      }
    }
  }

  int v23 = (char *)v21 - (char *)v17;
  if (v21 != v17)
  {
LABEL_42:
    std::string::erase(&v52, 0LL, v23);
    size_t size = v52.__r_.__value_.__s.__size_;
  }

  if ((size & 0x80) == 0)
  {
LABEL_44:
    unint64_t v24 = 0;
    if (!size) {
      goto LABEL_51;
    }
    goto LABEL_47;
  }

  unint64_t v24 = 1;
  if (!v52.__r_.__value_.__l.__size_) {
    goto LABEL_51;
  }
LABEL_47:
  int v9 = v24 == 0;
  BOOL v25 = &v52;
  if (!v9) {
    BOOL v25 = (std::string *)v52.__r_.__value_.__r.__words[0];
  }
  if (v25->__r_.__value_.__s.__data_[0] == 61)
  {
    std::string::operator=(&v49, 61);
    std::string::erase(&v52, 0LL, 1uLL);
    size_t size = v52.__r_.__value_.__s.__size_;
  }

    uint64_t v10 = 1;
    int v11 = v22;
    if (!v22) {
      goto LABEL_25;
    }
    goto LABEL_21;
  }

    int v20 = v10 - 1;
    do
    {
      int v21 = *--v5;
      *v20-- = v21;
    }

    while (v5 != v2);
LABEL_20:
    int v9 = v6;
LABEL_21:
    *(void *)a1 = v9;
    *(void *)(a1 + 8) = v8;
    *(void *)(a1 + 16) = &v6[__sz];
    if (v2) {
      operator delete(v2);
    }
  }

  if (v10 == v8) {
    goto LABEL_69;
  }
  uint64_t v12 = v10 - v6;
  if (v12 == -1LL) {
    goto LABEL_69;
  }
  if (v4 < 0)
  {
    uint64_t v2 = (void **)*__src;
    timeval v5 = (unint64_t)__src[1];
LABEL_25:
    if (v5 >= v12 + 4) {
      uint64_t v13 = v12 + 4;
    }
    else {
      uint64_t v13 = v5;
    }
    if (v13 > 0x7FFFFFFFFFFFFFF7LL) {
      goto LABEL_81;
    }
    goto LABEL_29;
  }

  if (v12 == v5 - 4) {
    goto LABEL_25;
  }
  while (1)
  {
LABEL_32:
    uint64_t v14 = v2;
    if ((v5 & 0x80) != 0) {
      uint64_t v14 = (void **)*v2;
    }
    if (*((_BYTE *)v14 + v12 + 4) == 47) {
      break;
    }
    unint64_t v15 = v2;
    if ((char)v5 < 0)
    {
      unint64_t v15 = (void **)*v2;
      timeval v5 = (unint64_t)v2[1];
    }

    if (v5 >= v12) {
      int v16 = v12;
    }
    else {
      int v16 = v5;
    }
    if (v16 > 0x7FFFFFFFFFFFFFF7LL) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    if (v16 >= 0x17)
    {
      sched_param v18 = (v16 & 0xFFFFFFFFFFFFFFF8LL) + 8;
      if ((v16 | 7) != 0x17) {
        sched_param v18 = v16 | 7;
      }
      uint64_t v19 = v18 + 1;
      p_dst = (__int128 *)operator new(v18 + 1);
      *((void *)&__dst + 1) = v16;
      uint64_t v31 = v19 | 0x8000000000000000LL;
      *(void *)&std::string __dst = p_dst;
    }

    else
    {
      HIBYTE(v31) = v16;
      p_dst = &__dst;
      if (!v16) {
        goto LABEL_48;
      }
    }

    memmove(p_dst, v15, v16);
LABEL_48:
    *((_BYTE *)p_dst + v16) = 0;
    *(_OWORD *)uint64_t v2 = __dst;
    v2[2] = (void *)v31;
    timeval v5 = *((unsigned __int8 *)v2 + 23);
    if (*((char *)v2 + 23) < 0)
    {
      int v20 = (char *)*v2;
      int v21 = (char *)v2[1];
      if (!v21) {
        goto LABEL_69;
      }
    }

    else
    {
      int v20 = (char *)v2;
      int v21 = (char *)*((unsigned __int8 *)v2 + 23);
      if (!*((_BYTE *)v2 + 23)) {
        goto LABEL_69;
      }
    }

    int v22 = &v21[(void)v20];
    int v23 = v20;
    unint64_t v24 = &v21[(void)v20];
    while (2)
    {
      for (j = v23 + 3; ; ++j)
      {
        int v23 = j - 2;
        if (*(j - 3) != 46)
        {
          if (v23 == v22) {
            goto LABEL_67;
          }
          continue;
        }

        if (v23 == v22) {
          goto LABEL_67;
        }
        if (*v23 == 97)
        {
          if (j - 1 == v22) {
            goto LABEL_67;
          }
          if (*(j - 1) == 112) {
            break;
          }
        }
      }

      if (j != v22)
      {
        if (*j == 112) {
          unint64_t v24 = j - 3;
        }
        continue;
      }

      break;
    }

  MachVMRegion::~MachVMRegion((MachVMRegion *)v16);
  return v10;
}

std::string *RNBContext::LaunchStatusAsString(uint64_t a1, std::string *a2)
{
  if ((char)a2->__r_.__value_.__s.__size_ < 0)
  {
    *a2->__r_.__value_.__l.__data_ = 0;
    a2->__r_.__value_.__l.__size_ = 0LL;
  }

  else
  {
    a2->__r_.__value_.__s.__data_[0] = 0;
    a2->__r_.__value_.__s.__size_ = 0;
  }

  int v3 = (_DWORD *)(a1 + 312);
  uint64_t v4 = DNBError::AsString((DNBError *)(a1 + 312));
  if (v4)
  {
    timeval v5 = (char *)v4;
  }

  else
  {
    snprintf(__str, 0x40uLL, "%u", *v3);
    timeval v5 = __str;
  }

  std::string::assign(a2, v5);
  if ((a2->__r_.__value_.__s.__size_ & 0x80u) == 0) {
    return a2;
  }
  else {
    return (std::string *)a2->__r_.__value_.__r.__words[0];
  }
}

BOOL RNBContext::ProcessStateRunning(RNBContext *this)
{
  return DNBProcessGetState(*((_DWORD *)this + 3)) - 5 < 2;
}

BOOL RNBContext::AddIgnoredException(RNBContext *this, MachException *a2)
{
  int v3 = MachException::ExceptionMask(a2, (const char *)a2);
  int v4 = v3;
  if (v3)
  {
    unint64_t v6 = (char *)*((void *)this + 57);
    unint64_t v5 = *((void *)this + 58);
    if ((unint64_t)v6 >= v5)
    {
      size_t v8 = (char *)*((void *)this + 56);
      uint64_t v9 = (v6 - v8) >> 2;
      unint64_t v10 = v9 + 1;
      uint64_t v11 = v5 - (void)v8;
      if (v11 >> 1 > v10) {
        unint64_t v10 = v11 >> 1;
      }
      else {
        unint64_t v12 = v10;
      }
      if (v12)
      {
        if (v12 >> 62) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        uint64_t v13 = operator new(4 * v12);
      }

      else
      {
        uint64_t v13 = 0LL;
      }

      uint64_t v14 = &v13[4 * v9];
      unint64_t v15 = &v13[4 * v12];
      *uint64_t v14 = v4;
      int v7 = v14 + 1;
      if (v6 != v8)
      {
        unint64_t v16 = v6 - v8 - 4;
        if (v16 < 0x2C) {
          goto LABEL_29;
        }
        uint64_t v17 = (v16 >> 2) + 1;
        uint64_t v18 = 4 * (v17 & 0x7FFFFFFFFFFFFFF8LL);
        uint64_t v19 = &v6[-v18];
        uint64_t v14 = (_DWORD *)((char *)v14 - v18);
        int v20 = &v13[4 * v9 - 16];
        int v21 = v6 - 16;
        uint64_t v22 = v17 & 0x7FFFFFFFFFFFFFF8LL;
        do
        {
          __int128 v23 = *(_OWORD *)v21;
          *(v20 - 1) = *((_OWORD *)v21 - 1);
          *int v20 = v23;
          v20 -= 2;
          v21 -= 32;
          v22 -= 8LL;
        }

        while (v22);
        unint64_t v6 = v19;
        if (v17 != (v17 & 0x7FFFFFFFFFFFFFF8LL))
        {
LABEL_29:
          do
          {
            int v24 = *((_DWORD *)v6 - 1);
            v6 -= 4;
            *--uint64_t v14 = v24;
          }

          while (v6 != v8);
        }
      }

      *((void *)this + 56) = v14;
      *((void *)this + 57) = v7;
      *((void *)this + 58) = v15;
      if (v8) {
        operator delete(v8);
      }
    }

    else
    {
      *(_DWORD *)unint64_t v6 = v3;
      int v7 = v6 + 4;
    }

    *((void *)this + 57) = v7;
  }

  return v4 != 0;
}

void RNBContext::AddDefaultIgnoredExceptions(RNBContext *this)
{
  int v3 = (char *)*((void *)this + 57);
  uint64_t v2 = (char *)*((void *)this + 58);
  int v4 = v3;
  if (v3 >= v2)
  {
    unint64_t v6 = (char *)*((void *)this + 56);
    uint64_t v7 = (v3 - v6) >> 2;
    unint64_t v8 = v7 + 1;
    uint64_t v9 = v2 - v6;
    if (v9 >> 1 > v8) {
      unint64_t v8 = v9 >> 1;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 >> 62) {
        goto LABEL_70;
      }
      uint64_t v11 = operator new(4 * v10);
    }

    else
    {
      uint64_t v11 = 0LL;
    }

    unint64_t v12 = &v11[4 * v7];
    uint64_t v2 = &v11[4 * v10];
    _DWORD *v12 = 2;
    unint64_t v5 = (char *)(v12 + 1);
    if (v3 != v6)
    {
      unint64_t v13 = v3 - v6 - 4;
      if (v13 < 0x2C) {
        goto LABEL_73;
      }
      uint64_t v14 = (v13 >> 2) + 1;
      uint64_t v15 = 4 * (v14 & 0x7FFFFFFFFFFFFFF8LL);
      int v4 = &v3[-v15];
      unint64_t v12 = (_DWORD *)((char *)v12 - v15);
      unint64_t v16 = &v11[4 * v7 - 16];
      uint64_t v17 = (__int128 *)(v3 - 16);
      uint64_t v18 = v14 & 0x7FFFFFFFFFFFFFF8LL;
      do
      {
        __int128 v19 = *v17;
        *(v16 - 1) = *(v17 - 1);
        _OWORD *v16 = v19;
        v16 -= 2;
        v17 -= 2;
        v18 -= 8LL;
      }

      while (v18);
      if (v14 != (v14 & 0x7FFFFFFFFFFFFFF8LL))
      {
LABEL_73:
        do
        {
          int v20 = *((_DWORD *)v4 - 1);
          v4 -= 4;
          *--unint64_t v12 = v20;
        }

        while (v4 != v6);
      }
    }

    *((void *)this + 56) = v12;
    *((void *)this + 57) = v5;
    *((void *)this + 58) = v2;
    if (v6)
    {
      operator delete(v6);
      uint64_t v2 = (char *)*((void *)this + 58);
    }
  }

  else
  {
    *(_DWORD *)int v3 = 2;
    unint64_t v5 = v3 + 4;
  }

  *((void *)this + 57) = v5;
  if (v5 < v2)
  {
    *(_DWORD *)unint64_t v5 = 4;
    int v21 = v5 + 4;
    goto LABEL_45;
  }

  uint64_t v22 = (char *)*((void *)this + 56);
  uint64_t v23 = (v5 - v22) >> 2;
  unint64_t v24 = v23 + 1;
  uint64_t v25 = v2 - v22;
  if (v25 >> 1 > v24) {
    unint64_t v24 = v25 >> 1;
  }
  else {
    unint64_t v26 = v24;
  }
  if (v26)
  {
    if (v26 >> 62) {
      goto LABEL_70;
    }
    size_t v27 = operator new(4 * v26);
  }

  else
  {
    size_t v27 = 0LL;
  }

  std::string::size_type v28 = &v27[4 * v23];
  uint64_t v2 = &v27[4 * v26];
  *std::string::size_type v28 = 4;
  int v21 = (char *)(v28 + 1);
  if (v5 != v22)
  {
    unint64_t v29 = v5 - v22 - 4;
    if (v29 < 0x2C)
    {
      __int128 v30 = v5;
      goto LABEL_42;
    }

    if ((unint64_t)(v22 - v27) < 0x20)
    {
      __int128 v30 = v5;
      do
      {
LABEL_42:
        int v37 = *((_DWORD *)v30 - 1);
        v30 -= 4;
        *--std::string::size_type v28 = v37;
      }

      while (v30 != v22);
      goto LABEL_43;
    }

    uint64_t v31 = (v29 >> 2) + 1;
    uint64_t v32 = 4 * (v31 & 0x7FFFFFFFFFFFFFF8LL);
    __int128 v30 = &v5[-v32];
    std::string::size_type v28 = (_DWORD *)((char *)v28 - v32);
    unint64_t v33 = &v27[4 * v23 - 16];
    __int128 v34 = v5 - 16;
    uint64_t v35 = v31 & 0x7FFFFFFFFFFFFFF8LL;
    do
    {
      __int128 v36 = *(_OWORD *)v34;
      *(v33 - 1) = *((_OWORD *)v34 - 1);
      *unint64_t v33 = v36;
      v33 -= 2;
      v34 -= 32;
      v35 -= 8LL;
    }

    while (v35);
    if (v31 != (v31 & 0x7FFFFFFFFFFFFFF8LL)) {
      goto LABEL_42;
    }
  }

LABEL_43:
  *((void *)this + 56) = v28;
  *((void *)this + 57) = v21;
  *((void *)this + 58) = v2;
  if (v22)
  {
    operator delete(v22);
    uint64_t v2 = (char *)*((void *)this + 58);
  }

    ++v36;
  }

  while (v36 != v35);
  LOBYTE(v127.tv_sec) = 59;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)&v127, 1LL);
  if (v35 == (v38 - v37) >> 3)
  {
    *(_DWORD *)((char *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24)) = *(_DWORD *)((_BYTE *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24)) & 0xFFFFFFB5 | 8;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"thread-pcs:", 11LL);
    uint64_t v58 = *(void *)v37;
    *(_DWORD *)((char *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24)) = *(_DWORD *)((_BYTE *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24)) & 0xFFFFFFB5 | 8;
    std::ostream::operator<<(__p, v58);
    unint64_t v59 = v35 - 1;
    uint64_t v2 = v124;
    if (v35 != 1)
    {
      char v60 = (uint64_t *)(v37 + 8);
      do
      {
        LOBYTE(v127.tv_sec) = 44;
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)&v127, 1LL);
        *(_DWORD *)((char *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24)) = *(_DWORD *)((_BYTE *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24)) & 0xFFFFFFB5 | 8;
        uint64_t v61 = *v60++;
        std::ostream::operator<<(__p, v61);
        --v59;
      }

      while (v59);
    }

    LOBYTE(v127.tv_sec) = 59;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)&v127, 1LL);
LABEL_84:
    operator delete(v37);
  }

  else
  {
    uint64_t v2 = v124;
    if (v37) {
      goto LABEL_84;
    }
  }

  int v4 = v123;
  if (v35 >= 2)
  {
    RNBRemote::GetJSONThreadsInfo(v2, 1, &v134);
    unint64_t v62 = v134;
    if (v134)
    {
      *(_DWORD *)((char *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24)) = *(_DWORD *)((_BYTE *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24)) & 0xFFFFFFB5 | 8;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"jstopinfo:", 10LL);
      v127.tv_sec = v121;
      *(__darwin_time_t *)((char *)&v127.tv_sec + *(void *)(v121 - 24)) = v120;
      uint64_t v63 = (std::ios_base *)((char *)&v127 + *(void *)(v127.tv_sec - 24));
      std::ios_base::init(v63, &v127.tv_usec);
      v63[1].__vftable = 0LL;
      v63[1].__fmtflags_ = -1;
      std::streambuf::basic_streambuf(&v127.tv_usec);
      *(_OWORD *)uint64_t v130 = 0u;
      uint64_t v131 = 0u;
      int v132 = 16;
      ((void (*)(std::__shared_weak_count *, timeval *))v62->__on_zero_shared_weak)(v62, &v127);
      ((void (*)(std::__shared_weak_count *))v62->__get_deleter)(v62);
      std::stringbuf::str(&v126, (const std::stringbuf *)&v127.tv_usec);
      append_hexified_string((uint64_t)__p, (unsigned __int8 *)&v126);
      v126.__r_.__value_.__s.__data_[0] = 59;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)&v126, 1LL);
      if (SBYTE7(v131) < 0) {
        operator delete(v130[0]);
      }
      std::streambuf::~streambuf(&v127.tv_usec);
      std::ios::~ios(v133);
      int v4 = v123;
    }

    uint64_t v64 = v135;
    uint64_t v2 = v124;
    if (v135)
    {
      p_shared_owners = (unint64_t *)&v135->__shared_owners_;
      do
        uint64_t v66 = __ldaxr(p_shared_owners);
      while (__stlxr(v66 - 1, p_shared_owners));
      if (!v66)
      {
        ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
        std::__shared_weak_count::__release_weak(v64);
      }
    }
  }

      JSONGenerator::Dictionary::AddItem(a1, (uint64_t)&v48, &v46);
      int v37 = v47;
      if (!v47) {
        goto LABEL_47;
      }
      __int128 v38 = (unint64_t *)&v47->__shared_owners_;
      do
        unsigned int v39 = __ldaxr(v38);
      while (__stlxr(v39 - 1, v38));
      if (!v39)
      {
        ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
        std::__shared_weak_count::__release_weak(v37);
        if (((char)v45.__r_.__value_.__s.__size_ & 0x80000000) == 0)
        {
LABEL_48:
          if (((char)v48.__r_.__value_.__s.__size_ & 0x80000000) == 0)
          {
LABEL_50:
            *(void (__cdecl ***)(std::ostringstream *__hidden))((char *)&v49
            std::streambuf::~streambuf(&v50);
            std::ios::~ios(&v51);
            return;
          }

  PseudoTerminal::PseudoTerminal((PseudoTerminal *)&v44);
  unint64_t v43 = 0LL;
  unint64_t v29 = posix_spawn_file_actions_init(&v43);
  __int128 v30 = v29;
  *(_DWORD *)a13 = v29;
  *((_DWORD *)a13 + 1) = 2;
  if (*((char *)a13 + 31) < 0)
  {
    **((_BYTE **)a13 + 1) = 0;
    *((void *)a13 + 2) = 0LL;
    __int128 v30 = *(_DWORD *)a13;
    if (*(_DWORD *)a13) {
      goto LABEL_48;
    }
  }

  else
  {
    *((_BYTE *)a13 + 8) = 0;
    *((_BYTE *)a13 + 31) = 0;
    if (v29) {
      goto LABEL_48;
    }
  }

  if (!DNBLogCheckLogBit(2))
  {
    uint64_t v42 = 0;
    goto LABEL_59;
  }

LABEL_45:
  *((void *)this + 57) = v21;
  if (v21 < v2)
  {
    *(_DWORD *)int v21 = 8;
    __int128 v38 = v21 + 4;
    goto LABEL_68;
  }

  unsigned int v39 = (char *)*((void *)this + 56);
  uint64_t v40 = (v21 - v39) >> 2;
  unint64_t v41 = v40 + 1;
  if ((unint64_t)(v40 + 1) >> 62) {
LABEL_69:
  }
    abort();
  uint64_t v42 = v2 - v39;
  if (v42 >> 1 > v41) {
    unint64_t v41 = v42 >> 1;
  }
  else {
    unint64_t v43 = v41;
  }
  if (v43)
  {
    if (!(v43 >> 62))
    {
      __int128 v44 = operator new(4 * v43);
      goto LABEL_57;
    }

  std::string::assign(a2, __str, 0LL, v16);
  return std::string::erase(__str, 0LL, v16);
}

LABEL_51:
    operator delete(__str.__r_.__value_.__l.__data_);
LABEL_46:
    if (DNBLogEnabled())
    {
      int v37 = getpid();
      _DNBLogError( "[LaunchAttach] END (%d) unable to launch the application with CFBundleIdentifier '%s' bks_error = %ld",  v37,  v12,  *((unsigned int *)v53 + 6));
    }

    goto LABEL_20;
  }

  if (DNBLogEnabled())
  {
    __int128 v30 = getpid();
    _DNBLogError("[LaunchAttach] END (%d) timed out trying to send openApplication to %s.", v30, v12);
  }

  *(void *)a3 = 111LL;
  if (*(char *)(a3 + 31) < 0)
  {
    **(_BYTE **)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0LL;
  }

  else
  {
    *(_BYTE *)(a3 + 8) = 0;
    *(_BYTE *)(a3 + 31) = 0;
  }

  std::string::assign((std::string *)(a3 + 8), "timed out trying to launch app");
LABEL_20:
  uint64_t v32 = 0LL;
LABEL_21:
  _Block_object_dispose(&v41, 8);
  _Block_object_dispose(&v45, 8);
  if (SHIBYTE(v51) < 0) {
    operator delete(*((void **)&v50 + 1));
  }
  _Block_object_dispose(&v52, 8);
  _Block_object_dispose(&v56, 8);
  return v32;
}

LABEL_70:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }

  __int128 v44 = 0LL;
LABEL_57:
  __int128 v45 = &v44[4 * v40];
  __int128 v46 = &v44[4 * v43];
  _DWORD *v45 = 8;
  __int128 v38 = v45 + 1;
  if (v21 == v39) {
    goto LABEL_66;
  }
  unint64_t v47 = v21 - v39 - 4;
  if (v47 < 0x2C)
  {
    __int128 v48 = v21;
    goto LABEL_65;
  }

  if ((unint64_t)(v39 - v44) < 0x20)
  {
    __int128 v48 = v21;
    do
    {
LABEL_65:
      int v55 = *((_DWORD *)v48 - 1);
      v48 -= 4;
      *--__int128 v45 = v55;
    }

    while (v48 != v39);
    goto LABEL_66;
  }

  uint64_t v49 = (v47 >> 2) + 1;
  uint64_t v50 = 4 * (v49 & 0x7FFFFFFFFFFFFFF8LL);
  __int128 v48 = &v21[-v50];
  __int128 v45 = (_DWORD *)((char *)v45 - v50);
  unint64_t v51 = &v44[4 * v40 - 16];
  unint64_t v52 = v21 - 16;
  uint64_t v53 = v49 & 0x7FFFFFFFFFFFFFF8LL;
  do
  {
    __int128 v54 = *(_OWORD *)v52;
    *(v51 - 1) = *((_OWORD *)v52 - 1);
    *unint64_t v51 = v54;
    v51 -= 2;
    v52 -= 32;
    v53 -= 8LL;
  }

  while (v53);
  if (v49 != (v49 & 0x7FFFFFFFFFFFFFF8LL)) {
    goto LABEL_65;
  }
LABEL_66:
  *((void *)this + 56) = v45;
  *((void *)this + 57) = v38;
  *((void *)this + 58) = v46;
  if (v39) {
    operator delete(v39);
  }
LABEL_68:
  *((void *)this + 57) = v38;
}

    a7 = "/dev/null";
    goto LABEL_71;
  }

  if (a6) {
    chdir((const char *)a6);
  }
  uint64_t v31 = posix_spawnp(&v42, (const char *)this, 0LL, &v47, a4, (char *const *)a5);
  *(_DWORD *)a13 = v31;
  *((_DWORD *)a13 + 1) = 2;
  if (*((char *)a13 + 31) < 0)
  {
    **((_BYTE **)a13 + 1) = 0;
    *((void *)a13 + 2) = 0LL;
    if (!*(_DWORD *)a13) {
      goto LABEL_55;
    }
LABEL_56:
    DNBError::LogThreaded( a13,  "::posix_spawnp(pid => %i, path = '%s', file_actions = %p, attr = %p, argv = %p, envp = %p)",  v42,  (const char *)this,  0LL,  &v47,  a4,  a5);
    goto LABEL_57;
  }

  *((_BYTE *)a13 + 8) = 0;
  *((_BYTE *)a13 + 31) = 0;
  if (v31) {
    goto LABEL_56;
  }
LABEL_55:
  if (DNBLogCheckLogBit(2)) {
    goto LABEL_56;
  }
LABEL_57:
  AvailablePrimary = -1;
LABEL_105:
  if (*(_DWORD *)a13) {
    uint64_t v42 = 0;
  }
  if (a11 && !AvailablePrimary)
  {
    __int128 v36 = v44;
    __int128 v44 = -1;
    a11[3] = v36;
    a11[4] = v36;
    a11[5] = v36;
  }

  posix_spawnattr_destroy(&v47);
  int v37 = v42;
  if (v42)
  {
    __int128 v54 = 0u;
    int v55 = 0u;
    *(_OWORD *)uint64_t v53 = 0u;
    unint64_t v52 = 12LL;
    if (sysctlnametomib("sysctl.proc_cputype", (int *)v53, &v52))
    {
      __int128 v38 = 0LL;
    }

    else
    {
      unsigned int v39 = v52;
      *((_DWORD *)v53 + v52) = v37;
      unint64_t v52 = v39 + 1;
      unint64_t v51 = 0;
      uint64_t v50 = 4LL;
      else {
        __int128 v38 = (DNBArchProtocol *)v51;
      }
    }

    if (DNBLogEnabledForAny(2)) {
      _DNBLogThreaded( "MachProcess::%s() pid=%i, cpu_type=0x%8.8x",  "PosixSpawnChildForPTraceDebugging",  v42,  (_DWORD)v38);
    }
    if ((_DWORD)v38) {
      DNBArchProtocol::SetArchitecture(v38, 0);
    }
  }

  if (!v30)
  {
    *(_OWORD *)uint64_t v53 = 0u;
    __int128 v54 = 0u;
    v53[0] = posix_spawn_file_actions_destroy(&v43) | 0x200000000LL;
    LOBYTE(v53[1]) = 0;
    HIBYTE(v54) = 0;
    if (LODWORD(v53[0]) || DNBLogCheckLogBit(2))
    {
      DNBError::LogThreaded((DNBError *)v53, "::posix_spawn_file_actions_destroy(&file_actions)");
      if (SHIBYTE(v54) < 0) {
        operator delete((void *)v53[1]);
      }
    }
  }

  unint64_t v24 = v42;
  PseudoTerminal::~PseudoTerminal((PseudoTerminal *)&v44);
  return v24;
}

void *std::string::basic_string[abi:nn180100]<0>(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8LL) {
    abort();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    unint64_t v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000LL;
    *a1 = v6;
  }

  else
  {
    *((_BYTE *)a1 + 23) = v4;
    unint64_t v6 = a1;
    if (!v4) {
      goto LABEL_9;
    }
  }

  memmove(v6, __s, v5);
LABEL_9:
  *((_BYTE *)v6 + v5) = 0;
  return a1;
}

void RNBRemote::RNBRemote(RNBRemote *this)
{
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 440) = 0u;
  *(_OWORD *)((char *)this + 456) = 0u;
  *(_OWORD *)((char *)this + 408) = 0u;
  *(_OWORD *)((char *)this + 424) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(void *)this = off_100060CF8;
  *(_OWORD *)((char *)this + 12) = 0u;
  *(_OWORD *)((char *)this + 28) = 0u;
  *(_OWORD *)((char *)this + 44) = 0u;
  *(_OWORD *)((char *)this + 60) = 0u;
  *(_OWORD *)((char *)this + 76) = 0u;
  *(_OWORD *)((char *)this + 92) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  PThreadEvent::PThreadEvent((RNBRemote *)((char *)this + 120), 0, 255);
  *((_DWORD *)this + 76) = 0;
  *((void *)this + 56) = 0LL;
  *(_OWORD *)((char *)this + 456) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 408) = 0u;
  *(_OWORD *)((char *)this + 424) = 0u;
  *((_BYTE *)this + 440) = 0;
  *((_DWORD *)this + 118) = -1;
  *((_WORD *)this + 238) = 0;
  *((void *)this + 60) = 0LL;
  DNBTimer::DNBTimer((RNBRemote *)((char *)this + 488), 1);
  *((void *)this + 66) = 0LL;
  *((_OWORD *)this + 32) = 0u;
  *((void *)this + 67) = -1LL;
  *((void *)this + 68) = -1LL;
  *((_WORD *)this + 324) = -1;
  *(void *)&__int128 v2 = -1LL;
  *((void *)&v2 + 1) = -1LL;
  *(_OWORD *)((char *)this + 616) = v2;
  *(_OWORD *)((char *)this + 632) = v2;
  *((void *)this + 82) = -1LL;
  *((_DWORD *)this + 166) = -1;
  *(_OWORD *)((char *)this + 668) = 0u;
  *(_OWORD *)((char *)this + 684) = 0u;
  *(_OWORD *)((char *)this + 700) = 0u;
  *(_OWORD *)((char *)this + 716) = 0u;
  *(_OWORD *)((char *)this + 732) = 0u;
  *(_OWORD *)((char *)this + 748) = 0u;
  *(_OWORD *)((char *)this + 760) = 0u;
  *((void *)this + 97) = 395LL;
  *((void *)this + 98) = 384LL;
  *((_BYTE *)this + 792) = 0;
  *((_DWORD *)this + 199) = 4;
  if (DNBLogEnabledForAny(0x100000)) {
    _DNBLogThreaded("%s", "RNBRemote::RNBRemote()");
  }
  RNBRemote::CreatePacketTable(this);
}

void RNBRemote::CreatePacketTable(RNBRemote *this)
{
  __int128 v2 = (void **)((char *)this + 672);
  RNBRemote::Packet::Packet((uint64_t)&v634, 1, 0LL, 0LL, 0LL, 0LL, "+", "ACK");
  int v3 = (char **)((char *)this + 680);
  unint64_t v4 = *((void *)this + 85);
  if (v4 < *((void *)this + 86))
  {
    __int128 v5 = v634;
    __int128 v6 = v635;
    *(void *)(v4 + 32) = v636;
    *(_OWORD *)unint64_t v4 = v5;
    *(_OWORD *)(v4 + 16) = v6;
    __int128 v7 = *(_OWORD *)__p;
    *(void *)(v4 + 56) = v638;
    *(_OWORD *)(v4 + 40) = v7;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v8 = v640;
    *(_OWORD *)(v4 + 64) = *(_OWORD *)v639;
    *(void *)(v4 + 80) = v8;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v4 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }

  uint64_t v9 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v10 = SHIBYTE(v640);
  *int v3 = v9;
  if ((v10 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_6:
  }
    operator delete(__p[0]);
LABEL_7:
  RNBRemote::Packet::Packet((uint64_t)&v634, 2, 0LL, 0LL, 0LL, 0LL, "-", "!ACK");
  unint64_t v11 = *((void *)this + 85);
  if (v11 < *((void *)this + 86))
  {
    __int128 v12 = v634;
    __int128 v13 = v635;
    *(void *)(v11 + 32) = v636;
    *(_OWORD *)unint64_t v11 = v12;
    *(_OWORD *)(v11 + 16) = v13;
    __int128 v14 = *(_OWORD *)__p;
    *(void *)(v11 + 56) = v638;
    *(_OWORD *)(v11 + 40) = v14;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v15 = v640;
    *(_OWORD *)(v11 + 64) = *(_OWORD *)v639;
    *(void *)(v11 + 80) = v15;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v11 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }

  unint64_t v16 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v17 = SHIBYTE(v640);
  *int v3 = v16;
  if ((v17 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_12:
  }
    operator delete(__p[0]);
LABEL_13:
  RNBRemote::Packet::Packet((uint64_t)&v634, 17, (uint64_t)RNBRemote::HandlePacket_m, 0LL, 0LL, 0LL, "m", "Read memory");
  unint64_t v18 = *((void *)this + 85);
  if (v18 < *((void *)this + 86))
  {
    __int128 v19 = v634;
    __int128 v20 = v635;
    *(void *)(v18 + 32) = v636;
    *(_OWORD *)unint64_t v18 = v19;
    *(_OWORD *)(v18 + 16) = v20;
    __int128 v21 = *(_OWORD *)__p;
    *(void *)(v18 + 56) = v638;
    *(_OWORD *)(v18 + 40) = v21;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v22 = v640;
    *(_OWORD *)(v18 + 64) = *(_OWORD *)v639;
    *(void *)(v18 + 80) = v22;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v18 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }

  uint64_t v23 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v24 = SHIBYTE(v640);
  *int v3 = v23;
  if ((v24 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_18:
  }
    operator delete(__p[0]);
LABEL_19:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  19,  (uint64_t)RNBRemote::HandlePacket_p,  0LL,  0LL,  0LL,  "p",  "Read one register");
  unint64_t v25 = *((void *)this + 85);
  if (v25 < *((void *)this + 86))
  {
    __int128 v26 = v634;
    __int128 v27 = v635;
    *(void *)(v25 + 32) = v636;
    *(_OWORD *)unint64_t v25 = v26;
    *(_OWORD *)(v25 + 16) = v27;
    __int128 v28 = *(_OWORD *)__p;
    *(void *)(v25 + 56) = v638;
    *(_OWORD *)(v25 + 40) = v28;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v29 = v640;
    *(_OWORD *)(v25 + 64) = *(_OWORD *)v639;
    *(void *)(v25 + 80) = v29;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v25 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }

  __int128 v30 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v31 = SHIBYTE(v640);
  *int v3 = v30;
  if ((v31 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_24:
  }
    operator delete(__p[0]);
LABEL_25:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  11,  (uint64_t)RNBRemote::HandlePacket_g,  0LL,  0LL,  0LL,  "g",  "Read registers");
  unint64_t v32 = *((void *)this + 85);
  if (v32 < *((void *)this + 86))
  {
    __int128 v33 = v634;
    __int128 v34 = v635;
    *(void *)(v32 + 32) = v636;
    *(_OWORD *)unint64_t v32 = v33;
    *(_OWORD *)(v32 + 16) = v34;
    __int128 v35 = *(_OWORD *)__p;
    *(void *)(v32 + 56) = v638;
    *(_OWORD *)(v32 + 40) = v35;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v36 = v640;
    *(_OWORD *)(v32 + 64) = *(_OWORD *)v639;
    *(void *)(v32 + 80) = v36;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v32 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_31;
    }
    goto LABEL_30;
  }

  int v37 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v38 = SHIBYTE(v640);
  *int v3 = v37;
  if ((v38 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_31;
    }
    goto LABEL_30;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_30:
  }
    operator delete(__p[0]);
LABEL_31:
  RNBRemote::Packet::Packet((uint64_t)&v634, 18, (uint64_t)RNBRemote::HandlePacket_M, 0LL, 0LL, 0LL, "M", "Write memory");
  unint64_t v39 = *((void *)this + 85);
  if (v39 < *((void *)this + 86))
  {
    __int128 v40 = v634;
    __int128 v41 = v635;
    *(void *)(v39 + 32) = v636;
    *(_OWORD *)unint64_t v39 = v40;
    *(_OWORD *)(v39 + 16) = v41;
    __int128 v42 = *(_OWORD *)__p;
    *(void *)(v39 + 56) = v638;
    *(_OWORD *)(v39 + 40) = v42;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v43 = v640;
    *(_OWORD *)(v39 + 64) = *(_OWORD *)v639;
    *(void *)(v39 + 80) = v43;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v39 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_37;
    }
    goto LABEL_36;
  }

  __int128 v44 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v45 = SHIBYTE(v640);
  *int v3 = v44;
  if ((v45 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_37;
    }
    goto LABEL_36;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_36:
  }
    operator delete(__p[0]);
LABEL_37:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  20,  (uint64_t)RNBRemote::HandlePacket_P,  0LL,  0LL,  0LL,  "P",  "Write one register");
  unint64_t v46 = *((void *)this + 85);
  if (v46 < *((void *)this + 86))
  {
    __int128 v47 = v634;
    __int128 v48 = v635;
    *(void *)(v46 + 32) = v636;
    *(_OWORD *)unint64_t v46 = v47;
    *(_OWORD *)(v46 + 16) = v48;
    __int128 v49 = *(_OWORD *)__p;
    *(void *)(v46 + 56) = v638;
    *(_OWORD *)(v46 + 40) = v49;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v50 = v640;
    *(_OWORD *)(v46 + 64) = *(_OWORD *)v639;
    *(void *)(v46 + 80) = v50;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v46 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_43;
    }
    goto LABEL_42;
  }

  unint64_t v51 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v52 = SHIBYTE(v640);
  *int v3 = v51;
  if ((v52 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_43;
    }
    goto LABEL_42;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_42:
  }
    operator delete(__p[0]);
LABEL_43:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  12,  (uint64_t)RNBRemote::HandlePacket_G,  0LL,  0LL,  0LL,  "G",  "Write registers");
  unint64_t v53 = *((void *)this + 85);
  if (v53 < *((void *)this + 86))
  {
    __int128 v54 = v634;
    __int128 v55 = v635;
    *(void *)(v53 + 32) = v636;
    *(_OWORD *)unint64_t v53 = v54;
    *(_OWORD *)(v53 + 16) = v55;
    __int128 v56 = *(_OWORD *)__p;
    *(void *)(v53 + 56) = v638;
    *(_OWORD *)(v53 + 40) = v56;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v57 = v640;
    *(_OWORD *)(v53 + 64) = *(_OWORD *)v639;
    *(void *)(v53 + 80) = v57;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v53 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_49;
    }
    goto LABEL_48;
  }

  uint64_t v58 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v59 = SHIBYTE(v640);
  *int v3 = v58;
  if ((v59 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_49;
    }
    goto LABEL_48;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_48:
  }
    operator delete(__p[0]);
LABEL_49:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  34,  (uint64_t)RNBRemote::HandlePacket_z,  0LL,  0LL,  0LL,  "Z0",  "Insert memory breakpoint");
  unint64_t v60 = *((void *)this + 85);
  if (v60 < *((void *)this + 86))
  {
    __int128 v61 = v634;
    __int128 v62 = v635;
    *(void *)(v60 + 32) = v636;
    *(_OWORD *)unint64_t v60 = v61;
    *(_OWORD *)(v60 + 16) = v62;
    __int128 v63 = *(_OWORD *)__p;
    *(void *)(v60 + 56) = v638;
    *(_OWORD *)(v60 + 40) = v63;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v64 = v640;
    *(_OWORD *)(v60 + 64) = *(_OWORD *)v639;
    *(void *)(v60 + 80) = v64;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v60 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_55;
    }
    goto LABEL_54;
  }

  int v65 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v66 = SHIBYTE(v640);
  *int v3 = v65;
  if ((v66 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_55;
    }
    goto LABEL_54;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_54:
  }
    operator delete(__p[0]);
LABEL_55:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  35,  (uint64_t)RNBRemote::HandlePacket_z,  0LL,  0LL,  0LL,  "z0",  "Remove memory breakpoint");
  unint64_t v67 = *((void *)this + 85);
  if (v67 < *((void *)this + 86))
  {
    __int128 v68 = v634;
    __int128 v69 = v635;
    *(void *)(v67 + 32) = v636;
    *(_OWORD *)unint64_t v67 = v68;
    *(_OWORD *)(v67 + 16) = v69;
    __int128 v70 = *(_OWORD *)__p;
    *(void *)(v67 + 56) = v638;
    *(_OWORD *)(v67 + 40) = v70;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v71 = v640;
    *(_OWORD *)(v67 + 64) = *(_OWORD *)v639;
    *(void *)(v67 + 80) = v71;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v67 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_61;
    }
    goto LABEL_60;
  }

  BOOL v72 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v73 = SHIBYTE(v640);
  *int v3 = v72;
  if ((v73 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_61;
    }
    goto LABEL_60;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_60:
  }
    operator delete(__p[0]);
LABEL_61:
  RNBRemote::Packet::Packet((uint64_t)&v634, 22, (uint64_t)RNBRemote::HandlePacket_s, 0LL, 0LL, 0LL, "s", "Single step");
  unint64_t v74 = *((void *)this + 85);
  if (v74 < *((void *)this + 86))
  {
    __int128 v75 = v634;
    __int128 v76 = v635;
    *(void *)(v74 + 32) = v636;
    *(_OWORD *)unint64_t v74 = v75;
    *(_OWORD *)(v74 + 16) = v76;
    __int128 v77 = *(_OWORD *)__p;
    *(void *)(v74 + 56) = v638;
    *(_OWORD *)(v74 + 40) = v77;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v78 = v640;
    *(_OWORD *)(v74 + 64) = *(_OWORD *)v639;
    *(void *)(v74 + 80) = v78;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v74 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_67;
    }
    goto LABEL_66;
  }

  uint64_t v79 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v80 = SHIBYTE(v640);
  *int v3 = v79;
  if ((v80 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_67;
    }
    goto LABEL_66;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_66:
  }
    operator delete(__p[0]);
LABEL_67:
  RNBRemote::Packet::Packet((uint64_t)&v634, 8, (uint64_t)RNBRemote::HandlePacket_c, 0LL, 0LL, 0LL, "c", "continue");
  unint64_t v81 = *((void *)this + 85);
  if (v81 < *((void *)this + 86))
  {
    __int128 v82 = v634;
    __int128 v83 = v635;
    *(void *)(v81 + 32) = v636;
    *(_OWORD *)unint64_t v81 = v82;
    *(_OWORD *)(v81 + 16) = v83;
    __int128 v84 = *(_OWORD *)__p;
    *(void *)(v81 + 56) = v638;
    *(_OWORD *)(v81 + 40) = v84;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v85 = v640;
    *(_OWORD *)(v81 + 64) = *(_OWORD *)v639;
    *(void *)(v81 + 80) = v85;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v81 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_73;
    }
    goto LABEL_72;
  }

  uint64_t v86 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v87 = SHIBYTE(v640);
  *int v3 = v86;
  if ((v87 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_73;
    }
    goto LABEL_72;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_72:
  }
    operator delete(__p[0]);
LABEL_73:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  23,  (uint64_t)RNBRemote::HandlePacket_S,  0LL,  0LL,  0LL,  "S",  "Single step with signal");
  unint64_t v88 = *((void *)this + 85);
  if (v88 < *((void *)this + 86))
  {
    __int128 v89 = v634;
    __int128 v90 = v635;
    *(void *)(v88 + 32) = v636;
    *(_OWORD *)unint64_t v88 = v89;
    *(_OWORD *)(v88 + 16) = v90;
    __int128 v91 = *(_OWORD *)__p;
    *(void *)(v88 + 56) = v638;
    *(_OWORD *)(v88 + 40) = v91;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v92 = v640;
    *(_OWORD *)(v88 + 64) = *(_OWORD *)v639;
    *(void *)(v88 + 80) = v92;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v88 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_79;
    }
    goto LABEL_78;
  }

  v93 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v94 = SHIBYTE(v640);
  *int v3 = v93;
  if ((v94 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_79;
    }
    goto LABEL_78;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_78:
  }
    operator delete(__p[0]);
LABEL_79:
  RNBRemote::Packet::Packet((uint64_t)&v634, 13, (uint64_t)RNBRemote::HandlePacket_H, 0LL, 0LL, 0LL, "H", "Set thread");
  unint64_t v95 = *((void *)this + 85);
  if (v95 < *((void *)this + 86))
  {
    __int128 v96 = v634;
    __int128 v97 = v635;
    *(void *)(v95 + 32) = v636;
    *(_OWORD *)unint64_t v95 = v96;
    *(_OWORD *)(v95 + 16) = v97;
    __int128 v98 = *(_OWORD *)__p;
    *(void *)(v95 + 56) = v638;
    *(_OWORD *)(v95 + 40) = v98;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v99 = v640;
    *(_OWORD *)(v95 + 64) = *(_OWORD *)v639;
    *(void *)(v95 + 80) = v99;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v95 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_85;
    }
    goto LABEL_84;
  }

  uint64_t v100 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v101 = SHIBYTE(v640);
  *int v3 = v100;
  if ((v101 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_85;
    }
    goto LABEL_84;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_84:
  }
    operator delete(__p[0]);
LABEL_85:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  3,  (uint64_t)RNBRemote::HandlePacket_last_signal,  0LL,  (uint64_t)RNBRemote::HandlePacket_stop_process,  0LL,  "\x03",  "^C");
  unint64_t v102 = *((void *)this + 85);
  if (v102 < *((void *)this + 86))
  {
    __int128 v103 = v634;
    __int128 v104 = v635;
    *(void *)(v102 + 32) = v636;
    *(_OWORD *)unint64_t v102 = v103;
    *(_OWORD *)(v102 + 16) = v104;
    __int128 v105 = *(_OWORD *)__p;
    *(void *)(v102 + 56) = v638;
    *(_OWORD *)(v102 + 40) = v105;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v106 = v640;
    *(_OWORD *)(v102 + 64) = *(_OWORD *)v639;
    *(void *)(v102 + 80) = v106;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v102 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_91;
    }
    goto LABEL_90;
  }

  uint64_t v107 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v108 = SHIBYTE(v640);
  *int v3 = v107;
  if ((v108 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_91;
    }
    goto LABEL_90;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_90:
  }
    operator delete(__p[0]);
LABEL_91:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  5,  (uint64_t)RNBRemote::HandlePacket_last_signal,  0LL,  0LL,  0LL,  "?",  "Why did target halt");
  unint64_t v109 = *((void *)this + 85);
  if (v109 < *((void *)this + 86))
  {
    __int128 v110 = v634;
    __int128 v111 = v635;
    *(void *)(v109 + 32) = v636;
    *(_OWORD *)unint64_t v109 = v110;
    *(_OWORD *)(v109 + 16) = v111;
    __int128 v112 = *(_OWORD *)__p;
    *(void *)(v109 + 56) = v638;
    *(_OWORD *)(v109 + 40) = v112;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v113 = v640;
    *(_OWORD *)(v109 + 64) = *(_OWORD *)v639;
    *(void *)(v109 + 80) = v113;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v109 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_97;
    }
    goto LABEL_96;
  }

  uint64_t v114 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v115 = SHIBYTE(v640);
  *int v3 = v114;
  if ((v115 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_97;
    }
    goto LABEL_96;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_96:
  }
    operator delete(__p[0]);
LABEL_97:
  RNBRemote::Packet::Packet((uint64_t)&v634, 6, (uint64_t)RNBRemote::HandlePacket_A, 0LL, 0LL, 0LL, "A", "Set argv");
  unint64_t v116 = *((void *)this + 85);
  if (v116 < *((void *)this + 86))
  {
    __int128 v117 = v634;
    __int128 v118 = v635;
    *(void *)(v116 + 32) = v636;
    *(_OWORD *)unint64_t v116 = v117;
    *(_OWORD *)(v116 + 16) = v118;
    __int128 v119 = *(_OWORD *)__p;
    *(void *)(v116 + 56) = v638;
    *(_OWORD *)(v116 + 40) = v119;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v120 = v640;
    *(_OWORD *)(v116 + 64) = *(_OWORD *)v639;
    *(void *)(v116 + 80) = v120;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v116 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_103;
    }
    goto LABEL_102;
  }

  uint64_t v121 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v122 = SHIBYTE(v640);
  *int v3 = v121;
  if ((v122 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_103;
    }
    goto LABEL_102;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_102:
  }
    operator delete(__p[0]);
LABEL_103:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  9,  (uint64_t)RNBRemote::HandlePacket_C,  0LL,  0LL,  0LL,  "C",  "Continue with signal");
  unint64_t v123 = *((void *)this + 85);
  if (v123 < *((void *)this + 86))
  {
    __int128 v124 = v634;
    __int128 v125 = v635;
    *(void *)(v123 + 32) = v636;
    *(_OWORD *)unint64_t v123 = v124;
    *(_OWORD *)(v123 + 16) = v125;
    __int128 v126 = *(_OWORD *)__p;
    *(void *)(v123 + 56) = v638;
    *(_OWORD *)(v123 + 40) = v126;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v127 = v640;
    *(_OWORD *)(v123 + 64) = *(_OWORD *)v639;
    *(void *)(v123 + 80) = v127;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v123 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_109;
    }
    goto LABEL_108;
  }

  uint64_t v128 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v129 = SHIBYTE(v640);
  *int v3 = v128;
  if ((v129 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_109;
    }
    goto LABEL_108;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_108:
  }
    operator delete(__p[0]);
LABEL_109:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  10,  (uint64_t)RNBRemote::HandlePacket_D,  0LL,  0LL,  0LL,  "D",  "Detach gdb from remote system");
  unint64_t v130 = *((void *)this + 85);
  if (v130 < *((void *)this + 86))
  {
    __int128 v131 = v634;
    __int128 v132 = v635;
    *(void *)(v130 + 32) = v636;
    *(_OWORD *)unint64_t v130 = v131;
    *(_OWORD *)(v130 + 16) = v132;
    __int128 v133 = *(_OWORD *)__p;
    *(void *)(v130 + 56) = v638;
    *(_OWORD *)(v130 + 40) = v133;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v134 = v640;
    *(_OWORD *)(v130 + 64) = *(_OWORD *)v639;
    *(void *)(v130 + 80) = v134;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v130 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_115;
    }
    goto LABEL_114;
  }

  uint64_t v135 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v136 = SHIBYTE(v640);
  *int v3 = v135;
  if ((v136 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_115;
    }
    goto LABEL_114;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_114:
  }
    operator delete(__p[0]);
LABEL_115:
  RNBRemote::Packet::Packet((uint64_t)&v634, 16, (uint64_t)RNBRemote::HandlePacket_k, 0LL, 0LL, 0LL, "k", "Kill");
  unint64_t v137 = *((void *)this + 85);
  if (v137 < *((void *)this + 86))
  {
    __int128 v138 = v634;
    __int128 v139 = v635;
    *(void *)(v137 + 32) = v636;
    *(_OWORD *)unint64_t v137 = v138;
    *(_OWORD *)(v137 + 16) = v139;
    __int128 v140 = *(_OWORD *)__p;
    *(void *)(v137 + 56) = v638;
    *(_OWORD *)(v137 + 40) = v140;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v141 = v640;
    *(_OWORD *)(v137 + 64) = *(_OWORD *)v639;
    *(void *)(v137 + 80) = v141;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v137 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_121;
    }
    goto LABEL_120;
  }

  BOOL v142 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v143 = SHIBYTE(v640);
  *int v3 = v142;
  if ((v143 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_121;
    }
    goto LABEL_120;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_120:
  }
    operator delete(__p[0]);
LABEL_121:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  25,  (uint64_t)RNBRemote::HandlePacket_T,  0LL,  0LL,  0LL,  "T",  "Is thread alive");
  unint64_t v144 = *((void *)this + 85);
  if (v144 < *((void *)this + 86))
  {
    __int128 v145 = v634;
    __int128 v146 = v635;
    *(void *)(v144 + 32) = v636;
    *(_OWORD *)unint64_t v144 = v145;
    *(_OWORD *)(v144 + 16) = v146;
    __int128 v147 = *(_OWORD *)__p;
    *(void *)(v144 + 56) = v638;
    *(_OWORD *)(v144 + 40) = v147;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v148 = v640;
    *(_OWORD *)(v144 + 64) = *(_OWORD *)v639;
    *(void *)(v144 + 80) = v148;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v144 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_127;
    }
    goto LABEL_126;
  }

  v149 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v150 = SHIBYTE(v640);
  *int v3 = v149;
  if ((v150 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_127;
    }
    goto LABEL_126;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_126:
  }
    operator delete(__p[0]);
LABEL_127:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  58,  (uint64_t)RNBRemote::HandlePacket_qSupported,  0LL,  0LL,  0LL,  "qSupported",  "Query about supported features");
  unint64_t v151 = *((void *)this + 85);
  if (v151 < *((void *)this + 86))
  {
    __int128 v152 = v634;
    __int128 v153 = v635;
    *(void *)(v151 + 32) = v636;
    *(_OWORD *)unint64_t v151 = v152;
    *(_OWORD *)(v151 + 16) = v153;
    __int128 v154 = *(_OWORD *)__p;
    *(void *)(v151 + 56) = v638;
    *(_OWORD *)(v151 + 40) = v154;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v155 = v640;
    *(_OWORD *)(v151 + 64) = *(_OWORD *)v639;
    *(void *)(v151 + 80) = v155;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v151 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_133;
    }
    goto LABEL_132;
  }

  uint64_t v156 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v157 = SHIBYTE(v640);
  *int v3 = v156;
  if ((v157 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_133;
    }
    goto LABEL_132;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_132:
  }
    operator delete(__p[0]);
LABEL_133:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  26,  (uint64_t)RNBRemote::HandlePacket_v,  0LL,  0LL,  0LL,  "vAttach",  "Attach to a new process");
  unint64_t v158 = *((void *)this + 85);
  if (v158 < *((void *)this + 86))
  {
    __int128 v159 = v634;
    __int128 v160 = v635;
    *(void *)(v158 + 32) = v636;
    *(_OWORD *)unint64_t v158 = v159;
    *(_OWORD *)(v158 + 16) = v160;
    __int128 v161 = *(_OWORD *)__p;
    *(void *)(v158 + 56) = v638;
    *(_OWORD *)(v158 + 40) = v161;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v162 = v640;
    *(_OWORD *)(v158 + 64) = *(_OWORD *)v639;
    *(void *)(v158 + 80) = v162;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v158 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_139;
    }
    goto LABEL_138;
  }

  uint64_t v163 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v164 = SHIBYTE(v640);
  *int v3 = v163;
  if ((v164 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_139;
    }
    goto LABEL_138;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_138:
  }
    operator delete(__p[0]);
LABEL_139:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  27,  (uint64_t)RNBRemote::HandlePacket_v,  0LL,  0LL,  0LL,  "vAttachWait",  "Wait for a process to start up then attach to it");
  unint64_t v165 = *((void *)this + 85);
  if (v165 < *((void *)this + 86))
  {
    __int128 v166 = v634;
    __int128 v167 = v635;
    *(void *)(v165 + 32) = v636;
    *(_OWORD *)unint64_t v165 = v166;
    *(_OWORD *)(v165 + 16) = v167;
    __int128 v168 = *(_OWORD *)__p;
    *(void *)(v165 + 56) = v638;
    *(_OWORD *)(v165 + 40) = v168;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v169 = v640;
    *(_OWORD *)(v165 + 64) = *(_OWORD *)v639;
    *(void *)(v165 + 80) = v169;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v165 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_145;
    }
    goto LABEL_144;
  }

  uint64_t v170 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v171 = SHIBYTE(v640);
  *int v3 = v170;
  if ((v171 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_145;
    }
    goto LABEL_144;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_144:
  }
    operator delete(__p[0]);
LABEL_145:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  28,  (uint64_t)RNBRemote::HandlePacket_v,  0LL,  0LL,  0LL,  "vAttachOrWait",  "Attach to the process or if it doesn't exist, wait for the process to start up then attach to it");
  unint64_t v172 = *((void *)this + 85);
  if (v172 < *((void *)this + 86))
  {
    __int128 v173 = v634;
    __int128 v174 = v635;
    *(void *)(v172 + 32) = v636;
    *(_OWORD *)unint64_t v172 = v173;
    *(_OWORD *)(v172 + 16) = v174;
    __int128 v175 = *(_OWORD *)__p;
    *(void *)(v172 + 56) = v638;
    *(_OWORD *)(v172 + 40) = v175;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v176 = v640;
    *(_OWORD *)(v172 + 64) = *(_OWORD *)v639;
    *(void *)(v172 + 80) = v176;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v172 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_151;
    }
    goto LABEL_150;
  }

  uint64_t v177 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v178 = SHIBYTE(v640);
  *int v3 = v177;
  if ((v178 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_151;
    }
    goto LABEL_150;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_150:
  }
    operator delete(__p[0]);
LABEL_151:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  29,  (uint64_t)RNBRemote::HandlePacket_v,  0LL,  0LL,  0LL,  "vAttachName",  "Attach to an existing process by name");
  unint64_t v179 = *((void *)this + 85);
  if (v179 < *((void *)this + 86))
  {
    __int128 v180 = v634;
    __int128 v181 = v635;
    *(void *)(v179 + 32) = v636;
    *(_OWORD *)unint64_t v179 = v180;
    *(_OWORD *)(v179 + 16) = v181;
    __int128 v182 = *(_OWORD *)__p;
    *(void *)(v179 + 56) = v638;
    *(_OWORD *)(v179 + 40) = v182;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v183 = v640;
    *(_OWORD *)(v179 + 64) = *(_OWORD *)v639;
    *(void *)(v179 + 80) = v183;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v179 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_157;
    }
    goto LABEL_156;
  }

  uint64_t v184 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v185 = SHIBYTE(v640);
  *int v3 = v184;
  if ((v185 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_157;
    }
    goto LABEL_156;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_156:
  }
    operator delete(__p[0]);
LABEL_157:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  31,  (uint64_t)RNBRemote::HandlePacket_v,  0LL,  0LL,  0LL,  "vCont;",
    "Verbose resume with thread actions");
  unint64_t v186 = *((void *)this + 85);
  if (v186 < *((void *)this + 86))
  {
    __int128 v187 = v634;
    __int128 v188 = v635;
    *(void *)(v186 + 32) = v636;
    *(_OWORD *)unint64_t v186 = v187;
    *(_OWORD *)(v186 + 16) = v188;
    __int128 v189 = *(_OWORD *)__p;
    *(void *)(v186 + 56) = v638;
    *(_OWORD *)(v186 + 40) = v189;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v190 = v640;
    *(_OWORD *)(v186 + 64) = *(_OWORD *)v639;
    *(void *)(v186 + 80) = v190;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v186 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_163;
    }
    goto LABEL_162;
  }

  uint64_t v191 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v192 = SHIBYTE(v640);
  *int v3 = v191;
  if ((v192 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_163;
    }
    goto LABEL_162;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_162:
  }
    operator delete(__p[0]);
LABEL_163:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  31,  (uint64_t)RNBRemote::HandlePacket_v,  0LL,  0LL,  0LL,  "vCont?",  "List valid continue-with-thread-actions actions");
  unint64_t v193 = *((void *)this + 85);
  if (v193 < *((void *)this + 86))
  {
    __int128 v194 = v634;
    __int128 v195 = v635;
    *(void *)(v193 + 32) = v636;
    *(_OWORD *)unint64_t v193 = v194;
    *(_OWORD *)(v193 + 16) = v195;
    __int128 v196 = *(_OWORD *)__p;
    *(void *)(v193 + 56) = v638;
    *(_OWORD *)(v193 + 40) = v196;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v197 = v640;
    *(_OWORD *)(v193 + 64) = *(_OWORD *)v639;
    *(void *)(v193 + 80) = v197;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v193 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_169;
    }
    goto LABEL_168;
  }

  v198 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v199 = SHIBYTE(v640);
  *int v3 = v198;
  if ((v199 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_169;
    }
    goto LABEL_168;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_168:
  }
    operator delete(__p[0]);
LABEL_169:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  32,  (uint64_t)RNBRemote::HandlePacket_x,  0LL,  0LL,  0LL,  "x",  "Read data from memory");
  unint64_t v200 = *((void *)this + 85);
  if (v200 < *((void *)this + 86))
  {
    __int128 v201 = v634;
    __int128 v202 = v635;
    *(void *)(v200 + 32) = v636;
    *(_OWORD *)unint64_t v200 = v201;
    *(_OWORD *)(v200 + 16) = v202;
    __int128 v203 = *(_OWORD *)__p;
    *(void *)(v200 + 56) = v638;
    *(_OWORD *)(v200 + 40) = v203;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v204 = v640;
    *(_OWORD *)(v200 + 64) = *(_OWORD *)v639;
    *(void *)(v200 + 80) = v204;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v200 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_175;
    }
    goto LABEL_174;
  }

  uint64_t v205 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v206 = SHIBYTE(v640);
  *int v3 = v205;
  if ((v206 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_175;
    }
    goto LABEL_174;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_174:
  }
    operator delete(__p[0]);
LABEL_175:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  33,  (uint64_t)RNBRemote::HandlePacket_X,  0LL,  0LL,  0LL,  "X",  "Write data to memory");
  unint64_t v207 = *((void *)this + 85);
  if (v207 < *((void *)this + 86))
  {
    __int128 v208 = v634;
    __int128 v209 = v635;
    *(void *)(v207 + 32) = v636;
    *(_OWORD *)unint64_t v207 = v208;
    *(_OWORD *)(v207 + 16) = v209;
    __int128 v210 = *(_OWORD *)__p;
    *(void *)(v207 + 56) = v638;
    *(_OWORD *)(v207 + 40) = v210;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v211 = v640;
    *(_OWORD *)(v207 + 64) = *(_OWORD *)v639;
    *(void *)(v207 + 80) = v211;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v207 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_181;
    }
    goto LABEL_180;
  }

  v212 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v213 = SHIBYTE(v640);
  *int v3 = v212;
  if ((v213 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_181;
    }
    goto LABEL_180;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_180:
  }
    operator delete(__p[0]);
LABEL_181:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  36,  (uint64_t)RNBRemote::HandlePacket_z,  0LL,  0LL,  0LL,  "Z1",  "Insert hardware breakpoint");
  unint64_t v214 = *((void *)this + 85);
  if (v214 < *((void *)this + 86))
  {
    __int128 v215 = v634;
    __int128 v216 = v635;
    *(void *)(v214 + 32) = v636;
    *(_OWORD *)unint64_t v214 = v215;
    *(_OWORD *)(v214 + 16) = v216;
    __int128 v217 = *(_OWORD *)__p;
    *(void *)(v214 + 56) = v638;
    *(_OWORD *)(v214 + 40) = v217;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v218 = v640;
    *(_OWORD *)(v214 + 64) = *(_OWORD *)v639;
    *(void *)(v214 + 80) = v218;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v214 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_187;
    }
    goto LABEL_186;
  }

  uint64_t v219 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v220 = SHIBYTE(v640);
  *int v3 = v219;
  if ((v220 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_187;
    }
    goto LABEL_186;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_186:
  }
    operator delete(__p[0]);
LABEL_187:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  37,  (uint64_t)RNBRemote::HandlePacket_z,  0LL,  0LL,  0LL,  "z1",  "Remove hardware breakpoint");
  unint64_t v221 = *((void *)this + 85);
  if (v221 < *((void *)this + 86))
  {
    __int128 v222 = v634;
    __int128 v223 = v635;
    *(void *)(v221 + 32) = v636;
    *(_OWORD *)unint64_t v221 = v222;
    *(_OWORD *)(v221 + 16) = v223;
    __int128 v224 = *(_OWORD *)__p;
    *(void *)(v221 + 56) = v638;
    *(_OWORD *)(v221 + 40) = v224;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v225 = v640;
    *(_OWORD *)(v221 + 64) = *(_OWORD *)v639;
    *(void *)(v221 + 80) = v225;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v221 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_193;
    }
    goto LABEL_192;
  }

  uint64_t v226 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v227 = SHIBYTE(v640);
  *int v3 = v226;
  if ((v227 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_193;
    }
    goto LABEL_192;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_192:
  }
    operator delete(__p[0]);
LABEL_193:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  38,  (uint64_t)RNBRemote::HandlePacket_z,  0LL,  0LL,  0LL,  "Z2",  "Insert write watchpoint");
  unint64_t v228 = *((void *)this + 85);
  if (v228 < *((void *)this + 86))
  {
    __int128 v229 = v634;
    __int128 v230 = v635;
    *(void *)(v228 + 32) = v636;
    *(_OWORD *)unint64_t v228 = v229;
    *(_OWORD *)(v228 + 16) = v230;
    __int128 v231 = *(_OWORD *)__p;
    *(void *)(v228 + 56) = v638;
    *(_OWORD *)(v228 + 40) = v231;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v232 = v640;
    *(_OWORD *)(v228 + 64) = *(_OWORD *)v639;
    *(void *)(v228 + 80) = v232;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v228 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_199;
    }
    goto LABEL_198;
  }

  uint64_t v233 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v234 = SHIBYTE(v640);
  *int v3 = v233;
  if ((v234 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_199;
    }
    goto LABEL_198;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_198:
  }
    operator delete(__p[0]);
LABEL_199:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  39,  (uint64_t)RNBRemote::HandlePacket_z,  0LL,  0LL,  0LL,  "z2",  "Remove write watchpoint");
  unint64_t v235 = *((void *)this + 85);
  if (v235 < *((void *)this + 86))
  {
    __int128 v236 = v634;
    __int128 v237 = v635;
    *(void *)(v235 + 32) = v636;
    *(_OWORD *)unint64_t v235 = v236;
    *(_OWORD *)(v235 + 16) = v237;
    __int128 v238 = *(_OWORD *)__p;
    *(void *)(v235 + 56) = v638;
    *(_OWORD *)(v235 + 40) = v238;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v239 = v640;
    *(_OWORD *)(v235 + 64) = *(_OWORD *)v639;
    *(void *)(v235 + 80) = v239;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v235 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_205;
    }
    goto LABEL_204;
  }

  uint64_t v240 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v241 = SHIBYTE(v640);
  *int v3 = v240;
  if ((v241 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_205;
    }
    goto LABEL_204;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_204:
  }
    operator delete(__p[0]);
LABEL_205:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  40,  (uint64_t)RNBRemote::HandlePacket_z,  0LL,  0LL,  0LL,  "Z3",  "Insert read watchpoint");
  unint64_t v242 = *((void *)this + 85);
  if (v242 < *((void *)this + 86))
  {
    __int128 v243 = v634;
    __int128 v244 = v635;
    *(void *)(v242 + 32) = v636;
    *(_OWORD *)unint64_t v242 = v243;
    *(_OWORD *)(v242 + 16) = v244;
    __int128 v245 = *(_OWORD *)__p;
    *(void *)(v242 + 56) = v638;
    *(_OWORD *)(v242 + 40) = v245;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v246 = v640;
    *(_OWORD *)(v242 + 64) = *(_OWORD *)v639;
    *(void *)(v242 + 80) = v246;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v242 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_211;
    }
    goto LABEL_210;
  }

  v247 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v248 = SHIBYTE(v640);
  *int v3 = v247;
  if ((v248 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_211;
    }
    goto LABEL_210;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_210:
  }
    operator delete(__p[0]);
LABEL_211:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  41,  (uint64_t)RNBRemote::HandlePacket_z,  0LL,  0LL,  0LL,  "z3",  "Remove read watchpoint");
  unint64_t v249 = *((void *)this + 85);
  if (v249 < *((void *)this + 86))
  {
    __int128 v250 = v634;
    __int128 v251 = v635;
    *(void *)(v249 + 32) = v636;
    *(_OWORD *)unint64_t v249 = v250;
    *(_OWORD *)(v249 + 16) = v251;
    __int128 v252 = *(_OWORD *)__p;
    *(void *)(v249 + 56) = v638;
    *(_OWORD *)(v249 + 40) = v252;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v253 = v640;
    *(_OWORD *)(v249 + 64) = *(_OWORD *)v639;
    *(void *)(v249 + 80) = v253;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v249 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_217;
    }
    goto LABEL_216;
  }

  uint64_t v254 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v255 = SHIBYTE(v640);
  *int v3 = v254;
  if ((v255 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_217;
    }
    goto LABEL_216;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_216:
  }
    operator delete(__p[0]);
LABEL_217:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  42,  (uint64_t)RNBRemote::HandlePacket_z,  0LL,  0LL,  0LL,  "Z4",  "Insert access watchpoint");
  unint64_t v256 = *((void *)this + 85);
  if (v256 < *((void *)this + 86))
  {
    __int128 v257 = v634;
    __int128 v258 = v635;
    *(void *)(v256 + 32) = v636;
    *(_OWORD *)unint64_t v256 = v257;
    *(_OWORD *)(v256 + 16) = v258;
    __int128 v259 = *(_OWORD *)__p;
    *(void *)(v256 + 56) = v638;
    *(_OWORD *)(v256 + 40) = v259;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v260 = v640;
    *(_OWORD *)(v256 + 64) = *(_OWORD *)v639;
    *(void *)(v256 + 80) = v260;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v256 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_223;
    }
    goto LABEL_222;
  }

  size_t v261 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v262 = SHIBYTE(v640);
  *int v3 = v261;
  if ((v262 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_223;
    }
    goto LABEL_222;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_222:
  }
    operator delete(__p[0]);
LABEL_223:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  43,  (uint64_t)RNBRemote::HandlePacket_z,  0LL,  0LL,  0LL,  "z4",  "Remove access watchpoint");
  unint64_t v263 = *((void *)this + 85);
  if (v263 < *((void *)this + 86))
  {
    __int128 v264 = v634;
    __int128 v265 = v635;
    *(void *)(v263 + 32) = v636;
    *(_OWORD *)unint64_t v263 = v264;
    *(_OWORD *)(v263 + 16) = v265;
    __int128 v266 = *(_OWORD *)__p;
    *(void *)(v263 + 56) = v638;
    *(_OWORD *)(v263 + 40) = v266;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v267 = v640;
    *(_OWORD *)(v263 + 64) = *(_OWORD *)v639;
    *(void *)(v263 + 80) = v267;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v263 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_229;
    }
    goto LABEL_228;
  }

  uint64_t v268 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v269 = SHIBYTE(v640);
  *int v3 = v268;
  if ((v269 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_229;
    }
    goto LABEL_228;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_228:
  }
    operator delete(__p[0]);
LABEL_229:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  44,  (uint64_t)RNBRemote::HandlePacket_qRcmd,  0LL,  0LL,  0LL,  "qRcmd",  "Monitor command");
  unint64_t v270 = *((void *)this + 85);
  if (v270 < *((void *)this + 86))
  {
    __int128 v271 = v634;
    __int128 v272 = v635;
    *(void *)(v270 + 32) = v636;
    *(_OWORD *)unint64_t v270 = v271;
    *(_OWORD *)(v270 + 16) = v272;
    __int128 v273 = *(_OWORD *)__p;
    *(void *)(v270 + 56) = v638;
    *(_OWORD *)(v270 + 40) = v273;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v274 = v640;
    *(_OWORD *)(v270 + 64) = *(_OWORD *)v639;
    *(void *)(v270 + 80) = v274;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v270 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_235;
    }
    goto LABEL_234;
  }

  int v275 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v276 = SHIBYTE(v640);
  *int v3 = v275;
  if ((v276 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_235;
    }
    goto LABEL_234;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_234:
  }
    operator delete(__p[0]);
LABEL_235:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  45,  (uint64_t)RNBRemote::HandlePacket_qC,  0LL,  0LL,  0LL,  "qC",  "Query current thread ID");
  unint64_t v277 = *((void *)this + 85);
  if (v277 < *((void *)this + 86))
  {
    __int128 v278 = v634;
    __int128 v279 = v635;
    *(void *)(v277 + 32) = v636;
    *(_OWORD *)unint64_t v277 = v278;
    *(_OWORD *)(v277 + 16) = v279;
    __int128 v280 = *(_OWORD *)__p;
    *(void *)(v277 + 56) = v638;
    *(_OWORD *)(v277 + 40) = v280;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v281 = v640;
    *(_OWORD *)(v277 + 64) = *(_OWORD *)v639;
    *(void *)(v277 + 80) = v281;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v277 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_241;
    }
    goto LABEL_240;
  }

  uint64_t v282 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v283 = SHIBYTE(v640);
  *int v3 = v282;
  if ((v283 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_241;
    }
    goto LABEL_240;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_240:
  }
    operator delete(__p[0]);
LABEL_241:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  47,  (uint64_t)RNBRemote::HandlePacket_qEcho,  0LL,  0LL,  0LL,  "qEcho:",  "Echo the packet back to allow the debugger to sync up with this server");
  unint64_t v284 = *((void *)this + 85);
  if (v284 < *((void *)this + 86))
  {
    __int128 v285 = v634;
    __int128 v286 = v635;
    *(void *)(v284 + 32) = v636;
    *(_OWORD *)unint64_t v284 = v285;
    *(_OWORD *)(v284 + 16) = v286;
    __int128 v287 = *(_OWORD *)__p;
    *(void *)(v284 + 56) = v638;
    *(_OWORD *)(v284 + 40) = v287;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v288 = v640;
    *(_OWORD *)(v284 + 64) = *(_OWORD *)v639;
    *(void *)(v284 + 80) = v288;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v284 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_247;
    }
    goto LABEL_246;
  }

  std::string::size_type v289 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v290 = SHIBYTE(v640);
  *int v3 = v289;
  if ((v290 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_247;
    }
    goto LABEL_246;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_246:
  }
    operator delete(__p[0]);
LABEL_247:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  46,  (uint64_t)RNBRemote::HandlePacket_qGetPid,  0LL,  0LL,  0LL,  "qGetPid",  "Query process id");
  unint64_t v291 = *((void *)this + 85);
  if (v291 < *((void *)this + 86))
  {
    __int128 v292 = v634;
    __int128 v293 = v635;
    *(void *)(v291 + 32) = v636;
    *(_OWORD *)unint64_t v291 = v292;
    *(_OWORD *)(v291 + 16) = v293;
    __int128 v294 = *(_OWORD *)__p;
    *(void *)(v291 + 56) = v638;
    *(_OWORD *)(v291 + 40) = v294;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v295 = v640;
    *(_OWORD *)(v291 + 64) = *(_OWORD *)v639;
    *(void *)(v291 + 80) = v295;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v291 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_253;
    }
    goto LABEL_252;
  }

  uint64_t v296 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v297 = SHIBYTE(v640);
  *int v3 = v296;
  if ((v297 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_253;
    }
    goto LABEL_252;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_252:
  }
    operator delete(__p[0]);
LABEL_253:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  48,  (uint64_t)RNBRemote::HandlePacket_qThreadInfo,  0LL,  0LL,  0LL,  "qfThreadInfo",  "Get list of active threads (first req)");
  unint64_t v298 = *((void *)this + 85);
  if (v298 < *((void *)this + 86))
  {
    __int128 v299 = v634;
    __int128 v300 = v635;
    *(void *)(v298 + 32) = v636;
    *(_OWORD *)unint64_t v298 = v299;
    *(_OWORD *)(v298 + 16) = v300;
    __int128 v301 = *(_OWORD *)__p;
    *(void *)(v298 + 56) = v638;
    *(_OWORD *)(v298 + 40) = v301;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v302 = v640;
    *(_OWORD *)(v298 + 64) = *(_OWORD *)v639;
    *(void *)(v298 + 80) = v302;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v298 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_259;
    }
    goto LABEL_258;
  }

  uint64_t v303 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v304 = SHIBYTE(v640);
  *int v3 = v303;
  if ((v304 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_259;
    }
    goto LABEL_258;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_258:
  }
    operator delete(__p[0]);
LABEL_259:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  49,  (uint64_t)RNBRemote::HandlePacket_qThreadInfo,  0LL,  0LL,  0LL,  "qsThreadInfo",  "Get list of active threads (subsequent req)");
  unint64_t v305 = *((void *)this + 85);
  if (v305 < *((void *)this + 86))
  {
    __int128 v306 = v634;
    __int128 v307 = v635;
    *(void *)(v305 + 32) = v636;
    *(_OWORD *)unint64_t v305 = v306;
    *(_OWORD *)(v305 + 16) = v307;
    __int128 v308 = *(_OWORD *)__p;
    *(void *)(v305 + 56) = v638;
    *(_OWORD *)(v305 + 40) = v308;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v309 = v640;
    *(_OWORD *)(v305 + 64) = *(_OWORD *)v639;
    *(void *)(v305 + 80) = v309;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v305 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_265;
    }
    goto LABEL_264;
  }

  uint64_t v310 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v311 = SHIBYTE(v640);
  *int v3 = v310;
  if ((v311 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_265;
    }
    goto LABEL_264;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_264:
  }
    operator delete(__p[0]);
LABEL_265:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  51,  (uint64_t)RNBRemote::HandlePacket_qThreadStopInfo,  0LL,  0LL,  0LL,  "qThreadStopInfo",  "Get detailed info on why the specified thread stopped");
  unint64_t v312 = *((void *)this + 85);
  if (v312 < *((void *)this + 86))
  {
    __int128 v313 = v634;
    __int128 v314 = v635;
    *(void *)(v312 + 32) = v636;
    *(_OWORD *)unint64_t v312 = v313;
    *(_OWORD *)(v312 + 16) = v314;
    __int128 v315 = *(_OWORD *)__p;
    *(void *)(v312 + 56) = v638;
    *(_OWORD *)(v312 + 40) = v315;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v316 = v640;
    *(_OWORD *)(v312 + 64) = *(_OWORD *)v639;
    *(void *)(v312 + 80) = v316;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v312 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_271;
    }
    goto LABEL_270;
  }

  uint64_t v317 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v318 = SHIBYTE(v640);
  *int v3 = v317;
  if ((v318 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_271;
    }
    goto LABEL_270;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_270:
  }
    operator delete(__p[0]);
LABEL_271:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  50,  (uint64_t)RNBRemote::HandlePacket_qThreadExtraInfo,  0LL,  0LL,  0LL,  "qThreadExtraInfo",  "Get printable status of a thread");
  unint64_t v319 = *((void *)this + 85);
  if (v319 < *((void *)this + 86))
  {
    __int128 v320 = v634;
    __int128 v321 = v635;
    *(void *)(v319 + 32) = v636;
    *(_OWORD *)unint64_t v319 = v320;
    *(_OWORD *)(v319 + 16) = v321;
    __int128 v322 = *(_OWORD *)__p;
    *(void *)(v319 + 56) = v638;
    *(_OWORD *)(v319 + 40) = v322;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v323 = v640;
    *(_OWORD *)(v319 + 64) = *(_OWORD *)v639;
    *(void *)(v319 + 80) = v323;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v319 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_277;
    }
    goto LABEL_276;
  }

  v324 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v325 = SHIBYTE(v640);
  *int v3 = v324;
  if ((v325 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_277;
    }
    goto LABEL_276;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_276:
  }
    operator delete(__p[0]);
LABEL_277:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  54,  (uint64_t)RNBRemote::HandlePacket_qLaunchSuccess,  0LL,  0LL,  0LL,  "qLaunchSuccess",  "Report the success or failure of the launch attempt");
  unint64_t v326 = *((void *)this + 85);
  if (v326 < *((void *)this + 86))
  {
    __int128 v327 = v634;
    __int128 v328 = v635;
    *(void *)(v326 + 32) = v636;
    *(_OWORD *)unint64_t v326 = v327;
    *(_OWORD *)(v326 + 16) = v328;
    __int128 v329 = *(_OWORD *)__p;
    *(void *)(v326 + 56) = v638;
    *(_OWORD *)(v326 + 40) = v329;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v330 = v640;
    *(_OWORD *)(v326 + 64) = *(_OWORD *)v639;
    *(void *)(v326 + 80) = v330;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v326 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_283;
    }
    goto LABEL_282;
  }

  uint64_t v331 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v332 = SHIBYTE(v640);
  *int v3 = v331;
  if ((v332 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_283;
    }
    goto LABEL_282;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_282:
  }
    operator delete(__p[0]);
LABEL_283:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  55,  (uint64_t)RNBRemote::HandlePacket_qRegisterInfo,  0LL,  0LL,  0LL,  "qRegisterInfo",  "Dynamically discover remote register context information.");
  unint64_t v333 = *((void *)this + 85);
  if (v333 < *((void *)this + 86))
  {
    __int128 v334 = v634;
    __int128 v335 = v635;
    *(void *)(v333 + 32) = v636;
    *(_OWORD *)unint64_t v333 = v334;
    *(_OWORD *)(v333 + 16) = v335;
    __int128 v336 = *(_OWORD *)__p;
    *(void *)(v333 + 56) = v638;
    *(_OWORD *)(v333 + 40) = v336;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v337 = v640;
    *(_OWORD *)(v333 + 64) = *(_OWORD *)v639;
    *(void *)(v333 + 80) = v337;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v333 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_289;
    }
    goto LABEL_288;
  }

  uint64_t v338 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v339 = SHIBYTE(v640);
  *int v3 = v338;
  if ((v339 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_289;
    }
    goto LABEL_288;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_288:
  }
    operator delete(__p[0]);
LABEL_289:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  56,  (uint64_t)RNBRemote::HandlePacket_qShlibInfoAddr,  0LL,  0LL,  0LL,  "qShlibInfoAddr",  "Returns the address that contains info needed for getting shared library notifications");
  unint64_t v340 = *((void *)this + 85);
  if (v340 < *((void *)this + 86))
  {
    __int128 v341 = v634;
    __int128 v342 = v635;
    *(void *)(v340 + 32) = v636;
    *(_OWORD *)unint64_t v340 = v341;
    *(_OWORD *)(v340 + 16) = v342;
    __int128 v343 = *(_OWORD *)__p;
    *(void *)(v340 + 56) = v638;
    *(_OWORD *)(v340 + 40) = v343;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v344 = v640;
    *(_OWORD *)(v340 + 64) = *(_OWORD *)v639;
    *(void *)(v340 + 80) = v344;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v340 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_295;
    }
    goto LABEL_294;
  }

  uint64_t v345 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v346 = SHIBYTE(v640);
  *int v3 = v345;
  if ((v346 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_295;
    }
    goto LABEL_294;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_294:
  }
    operator delete(__p[0]);
LABEL_295:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  57,  (uint64_t)RNBRemote::HandlePacket_qStepPacketSupported,  0LL,  0LL,  0LL,  "qStepPacketSupported",  "Replys with OK if the 's' packet is supported.");
  unint64_t v347 = *((void *)this + 85);
  if (v347 < *((void *)this + 86))
  {
    __int128 v348 = v634;
    __int128 v349 = v635;
    *(void *)(v347 + 32) = v636;
    *(_OWORD *)unint64_t v347 = v348;
    *(_OWORD *)(v347 + 16) = v349;
    __int128 v350 = *(_OWORD *)__p;
    *(void *)(v347 + 56) = v638;
    *(_OWORD *)(v347 + 40) = v350;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v351 = v640;
    *(_OWORD *)(v347 + 64) = *(_OWORD *)v639;
    *(void *)(v347 + 80) = v351;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v347 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_301;
    }
    goto LABEL_300;
  }

  v352 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v353 = SHIBYTE(v640);
  *int v3 = v352;
  if ((v353 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_301;
    }
    goto LABEL_300;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_300:
  }
    operator delete(__p[0]);
LABEL_301:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  59,  (uint64_t)RNBRemote::HandlePacket_qVAttachOrWaitSupported,  0LL,  0LL,  0LL,  "qVAttachOrWaitSupported",  "Replys with OK if the 'vAttachOrWait' packet is supported.");
  unint64_t v354 = *((void *)this + 85);
  if (v354 < *((void *)this + 86))
  {
    __int128 v355 = v634;
    __int128 v356 = v635;
    *(void *)(v354 + 32) = v636;
    *(_OWORD *)unint64_t v354 = v355;
    *(_OWORD *)(v354 + 16) = v356;
    __int128 v357 = *(_OWORD *)__p;
    *(void *)(v354 + 56) = v638;
    *(_OWORD *)(v354 + 40) = v357;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v358 = v640;
    *(_OWORD *)(v354 + 64) = *(_OWORD *)v639;
    *(void *)(v354 + 80) = v358;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v354 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_307;
    }
    goto LABEL_306;
  }

  uint64_t v359 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v360 = SHIBYTE(v640);
  *int v3 = v359;
  if ((v360 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_307;
    }
    goto LABEL_306;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_306:
  }
    operator delete(__p[0]);
LABEL_307:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  60,  (uint64_t)RNBRemote::HandlePacket_qSyncThreadStateSupported,  0LL,  0LL,  0LL,  "qSyncThreadStateSupported",  "Replys with OK if the 'QSyncThreadState:' packet is supported.");
  unint64_t v361 = *((void *)this + 85);
  if (v361 < *((void *)this + 86))
  {
    __int128 v362 = v634;
    __int128 v363 = v635;
    *(void *)(v361 + 32) = v636;
    *(_OWORD *)unint64_t v361 = v362;
    *(_OWORD *)(v361 + 16) = v363;
    __int128 v364 = *(_OWORD *)__p;
    *(void *)(v361 + 56) = v638;
    *(_OWORD *)(v361 + 40) = v364;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v365 = v640;
    *(_OWORD *)(v361 + 64) = *(_OWORD *)v639;
    *(void *)(v361 + 80) = v365;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v361 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_313;
    }
    goto LABEL_312;
  }

  uint64_t v366 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v367 = SHIBYTE(v640);
  *int v3 = v366;
  if ((v367 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_313;
    }
    goto LABEL_312;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_312:
  }
    operator delete(__p[0]);
LABEL_313:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  61,  (uint64_t)RNBRemote::HandlePacket_qHostInfo,  0LL,  0LL,  0LL,  "qHostInfo",  "Replies with multiple 'key:value;' tuples appended to each other.");
  unint64_t v368 = *((void *)this + 85);
  if (v368 < *((void *)this + 86))
  {
    __int128 v369 = v634;
    __int128 v370 = v635;
    *(void *)(v368 + 32) = v636;
    *(_OWORD *)unint64_t v368 = v369;
    *(_OWORD *)(v368 + 16) = v370;
    __int128 v371 = *(_OWORD *)__p;
    *(void *)(v368 + 56) = v638;
    *(_OWORD *)(v368 + 40) = v371;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v372 = v640;
    *(_OWORD *)(v368 + 64) = *(_OWORD *)v639;
    *(void *)(v368 + 80) = v372;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v368 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_319;
    }
    goto LABEL_318;
  }

  uint64_t v373 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v374 = SHIBYTE(v640);
  *int v3 = v373;
  if ((v374 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_319;
    }
    goto LABEL_318;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_318:
  }
    operator delete(__p[0]);
LABEL_319:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  62,  (uint64_t)RNBRemote::HandlePacket_qGDBServerVersion,  0LL,  0LL,  0LL,  "qGDBServerVersion",  "Replies with multiple 'key:value;' tuples appended to each other.");
  unint64_t v375 = *((void *)this + 85);
  if (v375 < *((void *)this + 86))
  {
    __int128 v376 = v634;
    __int128 v377 = v635;
    *(void *)(v375 + 32) = v636;
    *(_OWORD *)unint64_t v375 = v376;
    *(_OWORD *)(v375 + 16) = v377;
    __int128 v378 = *(_OWORD *)__p;
    *(void *)(v375 + 56) = v638;
    *(_OWORD *)(v375 + 40) = v378;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v379 = v640;
    *(_OWORD *)(v375 + 64) = *(_OWORD *)v639;
    *(void *)(v375 + 80) = v379;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v375 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_325;
    }
    goto LABEL_324;
  }

  uint64_t v380 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v381 = SHIBYTE(v640);
  *int v3 = v380;
  if ((v381 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_325;
    }
    goto LABEL_324;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_324:
  }
    operator delete(__p[0]);
LABEL_325:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  63,  (uint64_t)RNBRemote::HandlePacket_qProcessInfo,  0LL,  0LL,  0LL,  "qProcessInfo",  "Replies with multiple 'key:value;' tuples appended to each other.");
  unint64_t v382 = *((void *)this + 85);
  if (v382 < *((void *)this + 86))
  {
    __int128 v383 = v634;
    __int128 v384 = v635;
    *(void *)(v382 + 32) = v636;
    *(_OWORD *)unint64_t v382 = v383;
    *(_OWORD *)(v382 + 16) = v384;
    __int128 v385 = *(_OWORD *)__p;
    *(void *)(v382 + 56) = v638;
    *(_OWORD *)(v382 + 40) = v385;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v386 = v640;
    *(_OWORD *)(v382 + 64) = *(_OWORD *)v639;
    *(void *)(v382 + 80) = v386;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v382 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_331;
    }
    goto LABEL_330;
  }

  uint64_t v387 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v388 = SHIBYTE(v640);
  *int v3 = v387;
  if ((v388 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_331;
    }
    goto LABEL_330;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_330:
  }
    operator delete(__p[0]);
LABEL_331:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  53,  (uint64_t)RNBRemote::HandlePacket_qSymbol,  0LL,  0LL,  0LL,  "qSymbol:",  "Notify that host debugger is ready to do symbol lookups");
  unint64_t v389 = *((void *)this + 85);
  if (v389 < *((void *)this + 86))
  {
    __int128 v390 = v634;
    __int128 v391 = v635;
    *(void *)(v389 + 32) = v636;
    *(_OWORD *)unint64_t v389 = v390;
    *(_OWORD *)(v389 + 16) = v391;
    __int128 v392 = *(_OWORD *)__p;
    *(void *)(v389 + 56) = v638;
    *(_OWORD *)(v389 + 40) = v392;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v393 = v640;
    *(_OWORD *)(v389 + 64) = *(_OWORD *)v639;
    *(void *)(v389 + 80) = v393;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v389 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_337;
    }
    goto LABEL_336;
  }

  char v394 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v395 = SHIBYTE(v640);
  *int v3 = v394;
  if ((v395 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_337;
    }
    goto LABEL_336;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_336:
  }
    operator delete(__p[0]);
LABEL_337:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  64,  (uint64_t)RNBRemote::HandlePacket_jThreadExtendedInfo,  0LL,  0LL,  0LL,  "jThreadExtendedInfo",  "Replies with JSON data of thread extended information.");
  unint64_t v396 = *((void *)this + 85);
  if (v396 < *((void *)this + 86))
  {
    __int128 v397 = v634;
    __int128 v398 = v635;
    *(void *)(v396 + 32) = v636;
    *(_OWORD *)unint64_t v396 = v397;
    *(_OWORD *)(v396 + 16) = v398;
    __int128 v399 = *(_OWORD *)__p;
    *(void *)(v396 + 56) = v638;
    *(_OWORD *)(v396 + 40) = v399;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v400 = v640;
    *(_OWORD *)(v396 + 64) = *(_OWORD *)v639;
    *(void *)(v396 + 80) = v400;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v396 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_343;
    }
    goto LABEL_342;
  }

  int v401 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v402 = SHIBYTE(v640);
  *int v3 = v401;
  if ((v402 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_343;
    }
    goto LABEL_342;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_342:
  }
    operator delete(__p[0]);
LABEL_343:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  65,  (uint64_t)RNBRemote::HandlePacket_jGetLoadedDynamicLibrariesInfos,  0LL,  0LL,  0LL,  "jGetLoadedDynamicLibrariesInfos",  "Replies with JSON data of all the shared libraries loaded in this process.");
  unint64_t v403 = *((void *)this + 85);
  if (v403 < *((void *)this + 86))
  {
    __int128 v404 = v634;
    __int128 v405 = v635;
    *(void *)(v403 + 32) = v636;
    *(_OWORD *)unint64_t v403 = v404;
    *(_OWORD *)(v403 + 16) = v405;
    __int128 v406 = *(_OWORD *)__p;
    *(void *)(v403 + 56) = v638;
    *(_OWORD *)(v403 + 40) = v406;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v407 = v640;
    *(_OWORD *)(v403 + 64) = *(_OWORD *)v639;
    *(void *)(v403 + 80) = v407;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v403 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_349;
    }
    goto LABEL_348;
  }

  int v408 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v409 = SHIBYTE(v640);
  *int v3 = v408;
  if ((v409 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_349;
    }
    goto LABEL_348;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_348:
  }
    operator delete(__p[0]);
LABEL_349:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  66,  (uint64_t)RNBRemote::HandlePacket_jThreadsInfo,  0LL,  0LL,  0LL,  "jThreadsInfo",  "Replies with JSON data with information about all threads.");
  unint64_t v410 = *((void *)this + 85);
  if (v410 < *((void *)this + 86))
  {
    __int128 v411 = v634;
    __int128 v412 = v635;
    *(void *)(v410 + 32) = v636;
    *(_OWORD *)unint64_t v410 = v411;
    *(_OWORD *)(v410 + 16) = v412;
    __int128 v413 = *(_OWORD *)__p;
    *(void *)(v410 + 56) = v638;
    *(_OWORD *)(v410 + 40) = v413;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v414 = v640;
    *(_OWORD *)(v410 + 64) = *(_OWORD *)v639;
    *(void *)(v410 + 80) = v414;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v410 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_355;
    }
    goto LABEL_354;
  }

  uint64_t v415 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v416 = SHIBYTE(v640);
  *int v3 = v415;
  if ((v416 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_355;
    }
    goto LABEL_354;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_354:
  }
    operator delete(__p[0]);
LABEL_355:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  67,  (uint64_t)RNBRemote::HandlePacket_jGetSharedCacheInfo,  0LL,  0LL,  0LL,  "jGetSharedCacheInfo",  "Replies with JSON data about the location and uuid of the shared cache in the inferior process.");
  unint64_t v417 = *((void *)this + 85);
  if (v417 < *((void *)this + 86))
  {
    __int128 v418 = v634;
    __int128 v419 = v635;
    *(void *)(v417 + 32) = v636;
    *(_OWORD *)unint64_t v417 = v418;
    *(_OWORD *)(v417 + 16) = v419;
    __int128 v420 = *(_OWORD *)__p;
    *(void *)(v417 + 56) = v638;
    *(_OWORD *)(v417 + 40) = v420;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v421 = v640;
    *(_OWORD *)(v417 + 64) = *(_OWORD *)v639;
    *(void *)(v417 + 80) = v421;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v417 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_361;
    }
    goto LABEL_360;
  }

  uint64_t v422 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v423 = SHIBYTE(v640);
  *int v3 = v422;
  if ((v423 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_361;
    }
    goto LABEL_360;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_360:
  }
    operator delete(__p[0]);
LABEL_361:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  69,  (uint64_t)RNBRemote::HandlePacket_QStartNoAckMode,  0LL,  0LL,  0LL,  "QStartNoAckMode",  "Request that debugserver stop acking remote protocol packets");
  unint64_t v424 = *((void *)this + 85);
  if (v424 < *((void *)this + 86))
  {
    __int128 v425 = v634;
    __int128 v426 = v635;
    *(void *)(v424 + 32) = v636;
    *(_OWORD *)unint64_t v424 = v425;
    *(_OWORD *)(v424 + 16) = v426;
    __int128 v427 = *(_OWORD *)__p;
    *(void *)(v424 + 56) = v638;
    *(_OWORD *)(v424 + 40) = v427;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v428 = v640;
    *(_OWORD *)(v424 + 64) = *(_OWORD *)v639;
    *(void *)(v424 + 80) = v428;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v424 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_367;
    }
    goto LABEL_366;
  }

  sched_param v429 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v430 = SHIBYTE(v640);
  *int v3 = v429;
  if ((v430 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_367;
    }
    goto LABEL_366;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_366:
  }
    operator delete(__p[0]);
LABEL_367:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  70,  (uint64_t)RNBRemote::HandlePacket_QThreadSuffixSupported,  0LL,  0LL,  0LL,  "QThreadSuffixSupported",  "Check if thread specific packets (register packets 'g', 'G', 'p', and 'P') support having the thread ID appended to the end of the command");
  unint64_t v431 = *((void *)this + 85);
  if (v431 < *((void *)this + 86))
  {
    __int128 v432 = v634;
    __int128 v433 = v635;
    *(void *)(v431 + 32) = v636;
    *(_OWORD *)unint64_t v431 = v432;
    *(_OWORD *)(v431 + 16) = v433;
    __int128 v434 = *(_OWORD *)__p;
    *(void *)(v431 + 56) = v638;
    *(_OWORD *)(v431 + 40) = v434;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v435 = v640;
    *(_OWORD *)(v431 + 64) = *(_OWORD *)v639;
    *(void *)(v431 + 80) = v435;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v431 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_373;
    }
    goto LABEL_372;
  }

  v436 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v437 = SHIBYTE(v640);
  *int v3 = v436;
  if ((v437 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_373;
    }
    goto LABEL_372;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_372:
  }
    operator delete(__p[0]);
LABEL_373:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  71,  (uint64_t)RNBRemote::HandlePacket_QSetLogging,  0LL,  0LL,  0LL,  "QSetLogging:",  "Turn on log channels in debugserver");
  unint64_t v438 = *((void *)this + 85);
  if (v438 < *((void *)this + 86))
  {
    __int128 v439 = v634;
    __int128 v440 = v635;
    *(void *)(v438 + 32) = v636;
    *(_OWORD *)unint64_t v438 = v439;
    *(_OWORD *)(v438 + 16) = v440;
    __int128 v441 = *(_OWORD *)__p;
    *(void *)(v438 + 56) = v638;
    *(_OWORD *)(v438 + 40) = v441;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v442 = v640;
    *(_OWORD *)(v438 + 64) = *(_OWORD *)v639;
    *(void *)(v438 + 80) = v442;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v438 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_379;
    }
    goto LABEL_378;
  }

  v443 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v444 = SHIBYTE(v640);
  *int v3 = v443;
  if ((v444 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_379;
    }
    goto LABEL_378;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_378:
  }
    operator delete(__p[0]);
LABEL_379:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  72,  (uint64_t)RNBRemote::HandlePacket_QSetIgnoredExceptions,  0LL,  0LL,  0LL,  "QSetIgnoredExceptions:",  "Set the exception types debugserver won't wait for, allowing them to be turned into the equivalent BSD signals by the normal means.");
  unint64_t v445 = *((void *)this + 85);
  if (v445 < *((void *)this + 86))
  {
    __int128 v446 = v634;
    __int128 v447 = v635;
    *(void *)(v445 + 32) = v636;
    *(_OWORD *)unint64_t v445 = v446;
    *(_OWORD *)(v445 + 16) = v447;
    __int128 v448 = *(_OWORD *)__p;
    *(void *)(v445 + 56) = v638;
    *(_OWORD *)(v445 + 40) = v448;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v449 = v640;
    *(_OWORD *)(v445 + 64) = *(_OWORD *)v639;
    *(void *)(v445 + 80) = v449;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v445 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_385;
    }
    goto LABEL_384;
  }

  v450 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v451 = SHIBYTE(v640);
  *int v3 = v450;
  if ((v451 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_385;
    }
    goto LABEL_384;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_384:
  }
    operator delete(__p[0]);
LABEL_385:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  73,  (uint64_t)RNBRemote::HandlePacket_QSetMaxPacketSize,  0LL,  0LL,  0LL,  "QSetMaxPacketSize:",  "Tell debugserver the max sized packet gdb can handle");
  unint64_t v452 = *((void *)this + 85);
  if (v452 < *((void *)this + 86))
  {
    __int128 v453 = v634;
    __int128 v454 = v635;
    *(void *)(v452 + 32) = v636;
    *(_OWORD *)unint64_t v452 = v453;
    *(_OWORD *)(v452 + 16) = v454;
    __int128 v455 = *(_OWORD *)__p;
    *(void *)(v452 + 56) = v638;
    *(_OWORD *)(v452 + 40) = v455;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v456 = v640;
    *(_OWORD *)(v452 + 64) = *(_OWORD *)v639;
    *(void *)(v452 + 80) = v456;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v452 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_391;
    }
    goto LABEL_390;
  }

  v457 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v458 = SHIBYTE(v640);
  *int v3 = v457;
  if ((v458 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_391;
    }
    goto LABEL_390;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_390:
  }
    operator delete(__p[0]);
LABEL_391:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  74,  (uint64_t)RNBRemote::HandlePacket_QSetMaxPayloadSize,  0LL,  0LL,  0LL,  "QSetMaxPayloadSize:",  "Tell debugserver the max sized payload gdb can handle");
  unint64_t v459 = *((void *)this + 85);
  if (v459 < *((void *)this + 86))
  {
    __int128 v460 = v634;
    __int128 v461 = v635;
    *(void *)(v459 + 32) = v636;
    *(_OWORD *)unint64_t v459 = v460;
    *(_OWORD *)(v459 + 16) = v461;
    __int128 v462 = *(_OWORD *)__p;
    *(void *)(v459 + 56) = v638;
    *(_OWORD *)(v459 + 40) = v462;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v463 = v640;
    *(_OWORD *)(v459 + 64) = *(_OWORD *)v639;
    *(void *)(v459 + 80) = v463;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v459 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_397;
    }
    goto LABEL_396;
  }

  v464 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v465 = SHIBYTE(v640);
  *int v3 = v464;
  if ((v465 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_397;
    }
    goto LABEL_396;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_396:
  }
    operator delete(__p[0]);
LABEL_397:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  75,  (uint64_t)RNBRemote::HandlePacket_QEnvironment,  0LL,  0LL,  0LL,  "QEnvironment:",  "Add an environment variable to the inferior's environment");
  unint64_t v466 = *((void *)this + 85);
  if (v466 < *((void *)this + 86))
  {
    __int128 v467 = v634;
    __int128 v468 = v635;
    *(void *)(v466 + 32) = v636;
    *(_OWORD *)unint64_t v466 = v467;
    *(_OWORD *)(v466 + 16) = v468;
    __int128 v469 = *(_OWORD *)__p;
    *(void *)(v466 + 56) = v638;
    *(_OWORD *)(v466 + 40) = v469;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v470 = v640;
    *(_OWORD *)(v466 + 64) = *(_OWORD *)v639;
    *(void *)(v466 + 80) = v470;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v466 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_403;
    }
    goto LABEL_402;
  }

  v471 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v472 = SHIBYTE(v640);
  *int v3 = v471;
  if ((v472 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_403;
    }
    goto LABEL_402;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_402:
  }
    operator delete(__p[0]);
LABEL_403:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  76,  (uint64_t)RNBRemote::HandlePacket_QEnvironmentHexEncoded,  0LL,  0LL,  0LL,  "QEnvironmentHexEncoded:",  "Add an environment variable to the inferior's environment");
  unint64_t v473 = *((void *)this + 85);
  if (v473 < *((void *)this + 86))
  {
    __int128 v474 = v634;
    __int128 v475 = v635;
    *(void *)(v473 + 32) = v636;
    *(_OWORD *)unint64_t v473 = v474;
    *(_OWORD *)(v473 + 16) = v475;
    __int128 v476 = *(_OWORD *)__p;
    *(void *)(v473 + 56) = v638;
    *(_OWORD *)(v473 + 40) = v476;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v477 = v640;
    *(_OWORD *)(v473 + 64) = *(_OWORD *)v639;
    *(void *)(v473 + 80) = v477;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v473 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_409;
    }
    goto LABEL_408;
  }

  v478 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v479 = SHIBYTE(v640);
  *int v3 = v478;
  if ((v479 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_409;
    }
    goto LABEL_408;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_408:
  }
    operator delete(__p[0]);
LABEL_409:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  77,  (uint64_t)RNBRemote::HandlePacket_QLaunchArch,  0LL,  0LL,  0LL,  "QLaunchArch:",  "Set the architecture to use when launching a process for hosts that can run multiple architecture slices from universal files.");
  unint64_t v480 = *((void *)this + 85);
  if (v480 < *((void *)this + 86))
  {
    __int128 v481 = v634;
    __int128 v482 = v635;
    *(void *)(v480 + 32) = v636;
    *(_OWORD *)unint64_t v480 = v481;
    *(_OWORD *)(v480 + 16) = v482;
    __int128 v483 = *(_OWORD *)__p;
    *(void *)(v480 + 56) = v638;
    *(_OWORD *)(v480 + 40) = v483;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v484 = v640;
    *(_OWORD *)(v480 + 64) = *(_OWORD *)v639;
    *(void *)(v480 + 80) = v484;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v480 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_415;
    }
    goto LABEL_414;
  }

  v485 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v486 = SHIBYTE(v640);
  *int v3 = v485;
  if ((v486 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_415;
    }
    goto LABEL_414;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_414:
  }
    operator delete(__p[0]);
LABEL_415:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  78,  (uint64_t)RNBRemote::HandlePacket_QSetDisableASLR,  0LL,  0LL,  0LL,  "QSetDisableASLR:",  "Set whether to disable ASLR when launching the process with the set argv ('A') packet");
  unint64_t v487 = *((void *)this + 85);
  if (v487 < *((void *)this + 86))
  {
    __int128 v488 = v634;
    __int128 v489 = v635;
    *(void *)(v487 + 32) = v636;
    *(_OWORD *)unint64_t v487 = v488;
    *(_OWORD *)(v487 + 16) = v489;
    __int128 v490 = *(_OWORD *)__p;
    *(void *)(v487 + 56) = v638;
    *(_OWORD *)(v487 + 40) = v490;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v491 = v640;
    *(_OWORD *)(v487 + 64) = *(_OWORD *)v639;
    *(void *)(v487 + 80) = v491;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v487 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_421;
    }
    goto LABEL_420;
  }

  v492 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v493 = SHIBYTE(v640);
  *int v3 = v492;
  if ((v493 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_421;
    }
    goto LABEL_420;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_420:
  }
    operator delete(__p[0]);
LABEL_421:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  79,  (uint64_t)RNBRemote::HandlePacket_QSetSTDIO,  0LL,  0LL,  0LL,  "QSetSTDIN:",  "Set the standard input for a process to be launched with the 'A' packet");
  unint64_t v494 = *((void *)this + 85);
  if (v494 < *((void *)this + 86))
  {
    __int128 v495 = v634;
    __int128 v496 = v635;
    *(void *)(v494 + 32) = v636;
    *(_OWORD *)unint64_t v494 = v495;
    *(_OWORD *)(v494 + 16) = v496;
    __int128 v497 = *(_OWORD *)__p;
    *(void *)(v494 + 56) = v638;
    *(_OWORD *)(v494 + 40) = v497;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v498 = v640;
    *(_OWORD *)(v494 + 64) = *(_OWORD *)v639;
    *(void *)(v494 + 80) = v498;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v494 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_427;
    }
    goto LABEL_426;
  }

  v499 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v500 = SHIBYTE(v640);
  *int v3 = v499;
  if ((v500 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_427;
    }
    goto LABEL_426;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_426:
  }
    operator delete(__p[0]);
LABEL_427:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  80,  (uint64_t)RNBRemote::HandlePacket_QSetSTDIO,  0LL,  0LL,  0LL,  "QSetSTDOUT:",  "Set the standard output for a process to be launched with the 'A' packet");
  unint64_t v501 = *((void *)this + 85);
  if (v501 < *((void *)this + 86))
  {
    __int128 v502 = v634;
    __int128 v503 = v635;
    *(void *)(v501 + 32) = v636;
    *(_OWORD *)unint64_t v501 = v502;
    *(_OWORD *)(v501 + 16) = v503;
    __int128 v504 = *(_OWORD *)__p;
    *(void *)(v501 + 56) = v638;
    *(_OWORD *)(v501 + 40) = v504;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v505 = v640;
    *(_OWORD *)(v501 + 64) = *(_OWORD *)v639;
    *(void *)(v501 + 80) = v505;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v501 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_433;
    }
    goto LABEL_432;
  }

  v506 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v507 = SHIBYTE(v640);
  *int v3 = v506;
  if ((v507 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_433;
    }
    goto LABEL_432;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_432:
  }
    operator delete(__p[0]);
LABEL_433:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  81,  (uint64_t)RNBRemote::HandlePacket_QSetSTDIO,  0LL,  0LL,  0LL,  "QSetSTDERR:",  "Set the standard error for a process to be launched with the 'A' packet");
  unint64_t v508 = *((void *)this + 85);
  if (v508 < *((void *)this + 86))
  {
    __int128 v509 = v634;
    __int128 v510 = v635;
    *(void *)(v508 + 32) = v636;
    *(_OWORD *)unint64_t v508 = v509;
    *(_OWORD *)(v508 + 16) = v510;
    __int128 v511 = *(_OWORD *)__p;
    *(void *)(v508 + 56) = v638;
    *(_OWORD *)(v508 + 40) = v511;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v512 = v640;
    *(_OWORD *)(v508 + 64) = *(_OWORD *)v639;
    *(void *)(v508 + 80) = v512;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v508 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_439;
    }
    goto LABEL_438;
  }

  v513 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v514 = SHIBYTE(v640);
  *int v3 = v513;
  if ((v514 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_439;
    }
    goto LABEL_438;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_438:
  }
    operator delete(__p[0]);
LABEL_439:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  82,  (uint64_t)RNBRemote::HandlePacket_QSetWorkingDir,  0LL,  0LL,  0LL,  "QSetWorkingDir:",  "Set the working directory for a process to be launched with the 'A' packet");
  unint64_t v515 = *((void *)this + 85);
  if (v515 < *((void *)this + 86))
  {
    __int128 v516 = v634;
    __int128 v517 = v635;
    *(void *)(v515 + 32) = v636;
    *(_OWORD *)unint64_t v515 = v516;
    *(_OWORD *)(v515 + 16) = v517;
    __int128 v518 = *(_OWORD *)__p;
    *(void *)(v515 + 56) = v638;
    *(_OWORD *)(v515 + 40) = v518;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v519 = v640;
    *(_OWORD *)(v515 + 64) = *(_OWORD *)v639;
    *(void *)(v515 + 80) = v519;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v515 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_445;
    }
    goto LABEL_444;
  }

  v520 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v521 = SHIBYTE(v640);
  *int v3 = v520;
  if ((v521 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_445;
    }
    goto LABEL_444;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_444:
  }
    operator delete(__p[0]);
LABEL_445:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  83,  (uint64_t)RNBRemote::HandlePacket_QListThreadsInStopReply,  0LL,  0LL,  0LL,  "QListThreadsInStopReply",  "Set if the 'threads' key should be added to the stop reply packets with a list of all thread IDs.");
  unint64_t v522 = *((void *)this + 85);
  if (v522 < *((void *)this + 86))
  {
    __int128 v523 = v634;
    __int128 v524 = v635;
    *(void *)(v522 + 32) = v636;
    *(_OWORD *)unint64_t v522 = v523;
    *(_OWORD *)(v522 + 16) = v524;
    __int128 v525 = *(_OWORD *)__p;
    *(void *)(v522 + 56) = v638;
    *(_OWORD *)(v522 + 40) = v525;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v526 = v640;
    *(_OWORD *)(v522 + 64) = *(_OWORD *)v639;
    *(void *)(v522 + 80) = v526;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v522 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_451;
    }
    goto LABEL_450;
  }

  v527 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v528 = SHIBYTE(v640);
  *int v3 = v527;
  if ((v528 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_451;
    }
    goto LABEL_450;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_450:
  }
    operator delete(__p[0]);
LABEL_451:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  84,  (uint64_t)RNBRemote::HandlePacket_QSyncThreadState,  0LL,  0LL,  0LL,  "QSyncThreadState:",  "Do whatever is necessary to make sure 'thread' is in a safe state to call functions on.");
  unint64_t v529 = *((void *)this + 85);
  if (v529 < *((void *)this + 86))
  {
    __int128 v530 = v634;
    __int128 v531 = v635;
    *(void *)(v529 + 32) = v636;
    *(_OWORD *)unint64_t v529 = v530;
    *(_OWORD *)(v529 + 16) = v531;
    __int128 v532 = *(_OWORD *)__p;
    *(void *)(v529 + 56) = v638;
    *(_OWORD *)(v529 + 40) = v532;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v533 = v640;
    *(_OWORD *)(v529 + 64) = *(_OWORD *)v639;
    *(void *)(v529 + 80) = v533;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v529 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_457;
    }
    goto LABEL_456;
  }

  v534 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v535 = SHIBYTE(v640);
  *int v3 = v534;
  if ((v535 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_457;
    }
    goto LABEL_456;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_456:
  }
    operator delete(__p[0]);
LABEL_457:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  90,  (uint64_t)RNBRemote::HandlePacket_AllocateMemory,  0LL,  0LL,  0LL,  "_M",  "Allocate memory in the inferior process.");
  unint64_t v536 = *((void *)this + 85);
  if (v536 < *((void *)this + 86))
  {
    __int128 v537 = v634;
    __int128 v538 = v635;
    *(void *)(v536 + 32) = v636;
    *(_OWORD *)unint64_t v536 = v537;
    *(_OWORD *)(v536 + 16) = v538;
    __int128 v539 = *(_OWORD *)__p;
    *(void *)(v536 + 56) = v638;
    *(_OWORD *)(v536 + 40) = v539;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v540 = v640;
    *(_OWORD *)(v536 + 64) = *(_OWORD *)v639;
    *(void *)(v536 + 80) = v540;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v536 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_463;
    }
    goto LABEL_462;
  }

  v541 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v542 = SHIBYTE(v640);
  *int v3 = v541;
  if ((v542 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_463;
    }
    goto LABEL_462;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_462:
  }
    operator delete(__p[0]);
LABEL_463:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  91,  (uint64_t)RNBRemote::HandlePacket_DeallocateMemory,  0LL,  0LL,  0LL,  "_m",  "Deallocate memory in the inferior process.");
  unint64_t v543 = *((void *)this + 85);
  if (v543 < *((void *)this + 86))
  {
    __int128 v544 = v634;
    __int128 v545 = v635;
    *(void *)(v543 + 32) = v636;
    *(_OWORD *)unint64_t v543 = v544;
    *(_OWORD *)(v543 + 16) = v545;
    __int128 v546 = *(_OWORD *)__p;
    *(void *)(v543 + 56) = v638;
    *(_OWORD *)(v543 + 40) = v546;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v547 = v640;
    *(_OWORD *)(v543 + 64) = *(_OWORD *)v639;
    *(void *)(v543 + 80) = v547;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v543 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_469;
    }
    goto LABEL_468;
  }

  v548 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v549 = SHIBYTE(v640);
  *int v3 = v548;
  if ((v549 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_469;
    }
    goto LABEL_468;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_468:
  }
    operator delete(__p[0]);
LABEL_469:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  93,  (uint64_t)RNBRemote::HandlePacket_SaveRegisterState,  0LL,  0LL,  0LL,  "QSaveRegisterState",  "Save the register state for the current thread and return a decimal save ID.");
  unint64_t v550 = *((void *)this + 85);
  if (v550 < *((void *)this + 86))
  {
    __int128 v551 = v634;
    __int128 v552 = v635;
    *(void *)(v550 + 32) = v636;
    *(_OWORD *)unint64_t v550 = v551;
    *(_OWORD *)(v550 + 16) = v552;
    __int128 v553 = *(_OWORD *)__p;
    *(void *)(v550 + 56) = v638;
    *(_OWORD *)(v550 + 40) = v553;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v554 = v640;
    *(_OWORD *)(v550 + 64) = *(_OWORD *)v639;
    *(void *)(v550 + 80) = v554;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v550 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_475;
    }
    goto LABEL_474;
  }

  v555 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v556 = SHIBYTE(v640);
  *int v3 = v555;
  if ((v556 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_475;
    }
    goto LABEL_474;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_474:
  }
    operator delete(__p[0]);
LABEL_475:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  94,  (uint64_t)RNBRemote::HandlePacket_RestoreRegisterState,  0LL,  0LL,  0LL,  "QRestoreRegisterState:",  "Restore the register state given a save ID previously returned from a call to QSaveRegisterState.");
  unint64_t v557 = *((void *)this + 85);
  if (v557 < *((void *)this + 86))
  {
    __int128 v558 = v634;
    __int128 v559 = v635;
    *(void *)(v557 + 32) = v636;
    *(_OWORD *)unint64_t v557 = v558;
    *(_OWORD *)(v557 + 16) = v559;
    __int128 v560 = *(_OWORD *)__p;
    *(void *)(v557 + 56) = v638;
    *(_OWORD *)(v557 + 40) = v560;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v561 = v640;
    *(_OWORD *)(v557 + 64) = *(_OWORD *)v639;
    *(void *)(v557 + 80) = v561;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v557 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_481;
    }
    goto LABEL_480;
  }

  v562 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v563 = SHIBYTE(v640);
  *int v3 = v562;
  if ((v563 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_481;
    }
    goto LABEL_480;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_480:
  }
    operator delete(__p[0]);
LABEL_481:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  85,  (uint64_t)RNBRemote::HandlePacket_MemoryRegionInfo,  0LL,  0LL,  0LL,  "qMemoryRegionInfo",  "Return size and attributes of a memory region that contains the given address");
  unint64_t v564 = *((void *)this + 85);
  if (v564 < *((void *)this + 86))
  {
    __int128 v565 = v634;
    __int128 v566 = v635;
    *(void *)(v564 + 32) = v636;
    *(_OWORD *)unint64_t v564 = v565;
    *(_OWORD *)(v564 + 16) = v566;
    __int128 v567 = *(_OWORD *)__p;
    *(void *)(v564 + 56) = v638;
    *(_OWORD *)(v564 + 40) = v567;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v568 = v640;
    *(_OWORD *)(v564 + 64) = *(_OWORD *)v639;
    *(void *)(v564 + 80) = v568;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v564 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_487;
    }
    goto LABEL_486;
  }

  v569 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v570 = SHIBYTE(v640);
  *int v3 = v569;
  if ((v570 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_487;
    }
    goto LABEL_486;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_486:
  }
    operator delete(__p[0]);
LABEL_487:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  86,  (uint64_t)RNBRemote::HandlePacket_GetProfileData,  0LL,  0LL,  0LL,  "qGetProfileData",  "Return profiling data of the current target.");
  unint64_t v571 = *((void *)this + 85);
  if (v571 < *((void *)this + 86))
  {
    __int128 v572 = v634;
    __int128 v573 = v635;
    *(void *)(v571 + 32) = v636;
    *(_OWORD *)unint64_t v571 = v572;
    *(_OWORD *)(v571 + 16) = v573;
    __int128 v574 = *(_OWORD *)__p;
    *(void *)(v571 + 56) = v638;
    *(_OWORD *)(v571 + 40) = v574;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v575 = v640;
    *(_OWORD *)(v571 + 64) = *(_OWORD *)v639;
    *(void *)(v571 + 80) = v575;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v571 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_493;
    }
    goto LABEL_492;
  }

  v576 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v577 = SHIBYTE(v640);
  *int v3 = v576;
  if ((v577 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_493;
    }
    goto LABEL_492;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_492:
  }
    operator delete(__p[0]);
LABEL_493:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  87,  (uint64_t)RNBRemote::HandlePacket_SetEnableAsyncProfiling,  0LL,  0LL,  0LL,  "QSetEnableAsyncProfiling",  "Enable or disable the profiling of current target.");
  unint64_t v578 = *((void *)this + 85);
  if (v578 < *((void *)this + 86))
  {
    __int128 v579 = v634;
    __int128 v580 = v635;
    *(void *)(v578 + 32) = v636;
    *(_OWORD *)unint64_t v578 = v579;
    *(_OWORD *)(v578 + 16) = v580;
    __int128 v581 = *(_OWORD *)__p;
    *(void *)(v578 + 56) = v638;
    *(_OWORD *)(v578 + 40) = v581;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v582 = v640;
    *(_OWORD *)(v578 + 64) = *(_OWORD *)v639;
    *(void *)(v578 + 80) = v582;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v578 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_499;
    }
    goto LABEL_498;
  }

  v583 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v584 = SHIBYTE(v640);
  *int v3 = v583;
  if ((v584 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_499;
    }
    goto LABEL_498;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_498:
  }
    operator delete(__p[0]);
LABEL_499:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  88,  (uint64_t)RNBRemote::HandlePacket_QEnableCompression,  0LL,  0LL,  0LL,  "QEnableCompression:",  "Enable compression for the remainder of the connection");
  unint64_t v585 = *((void *)this + 85);
  if (v585 < *((void *)this + 86))
  {
    __int128 v586 = v634;
    __int128 v587 = v635;
    *(void *)(v585 + 32) = v636;
    *(_OWORD *)unint64_t v585 = v586;
    *(_OWORD *)(v585 + 16) = v587;
    __int128 v588 = *(_OWORD *)__p;
    *(void *)(v585 + 56) = v638;
    *(_OWORD *)(v585 + 40) = v588;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v589 = v640;
    *(_OWORD *)(v585 + 64) = *(_OWORD *)v639;
    *(void *)(v585 + 80) = v589;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v585 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_505;
    }
    goto LABEL_504;
  }

  v590 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v591 = SHIBYTE(v640);
  *int v3 = v590;
  if ((v591 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_505;
    }
    goto LABEL_504;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_504:
  }
    operator delete(__p[0]);
LABEL_505:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  89,  (uint64_t)RNBRemote::HandlePacket_WatchpointSupportInfo,  0LL,  0LL,  0LL,  "qWatchpointSupportInfo",  "Return the number of supported hardware watchpoints");
  unint64_t v592 = *((void *)this + 85);
  if (v592 < *((void *)this + 86))
  {
    __int128 v593 = v634;
    __int128 v594 = v635;
    *(void *)(v592 + 32) = v636;
    *(_OWORD *)unint64_t v592 = v593;
    *(_OWORD *)(v592 + 16) = v594;
    __int128 v595 = *(_OWORD *)__p;
    *(void *)(v592 + 56) = v638;
    *(_OWORD *)(v592 + 40) = v595;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v596 = v640;
    *(_OWORD *)(v592 + 64) = *(_OWORD *)v639;
    *(void *)(v592 + 80) = v596;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v592 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_511;
    }
    goto LABEL_510;
  }

  v597 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v598 = SHIBYTE(v640);
  *int v3 = v597;
  if ((v598 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_511;
    }
    goto LABEL_510;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_510:
  }
    operator delete(__p[0]);
LABEL_511:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  92,  (uint64_t)RNBRemote::HandlePacket_QSetProcessEvent,  0LL,  0LL,  0LL,  "QSetProcessEvent:",  "Set a process event, to be passed to the process, can be set before the process is started, or after.");
  unint64_t v599 = *((void *)this + 85);
  if (v599 < *((void *)this + 86))
  {
    __int128 v600 = v634;
    __int128 v601 = v635;
    *(void *)(v599 + 32) = v636;
    *(_OWORD *)unint64_t v599 = v600;
    *(_OWORD *)(v599 + 16) = v601;
    __int128 v602 = *(_OWORD *)__p;
    *(void *)(v599 + 56) = v638;
    *(_OWORD *)(v599 + 40) = v602;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v603 = v640;
    *(_OWORD *)(v599 + 64) = *(_OWORD *)v639;
    *(void *)(v599 + 80) = v603;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v599 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_517;
    }
    goto LABEL_516;
  }

  v604 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v605 = SHIBYTE(v640);
  *int v3 = v604;
  if ((v605 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_517;
    }
    goto LABEL_516;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_516:
  }
    operator delete(__p[0]);
LABEL_517:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  96,  (uint64_t)RNBRemote::HandlePacket_QSetDetachOnError,  0LL,  0LL,  0LL,  "QSetDetachOnError:",  "Set whether debugserver will detach (1) or kill (0) from the process it is controlling if it loses connection to lldb.");
  unint64_t v606 = *((void *)this + 85);
  if (v606 < *((void *)this + 86))
  {
    __int128 v607 = v634;
    __int128 v608 = v635;
    *(void *)(v606 + 32) = v636;
    *(_OWORD *)unint64_t v606 = v607;
    *(_OWORD *)(v606 + 16) = v608;
    __int128 v609 = *(_OWORD *)__p;
    *(void *)(v606 + 56) = v638;
    *(_OWORD *)(v606 + 40) = v609;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v610 = v640;
    *(_OWORD *)(v606 + 64) = *(_OWORD *)v639;
    *(void *)(v606 + 80) = v610;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v606 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_523;
    }
    goto LABEL_522;
  }

  v611 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v612 = SHIBYTE(v640);
  *int v3 = v611;
  if ((v612 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_523;
    }
    goto LABEL_522;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_522:
  }
    operator delete(__p[0]);
LABEL_523:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  95,  (uint64_t)RNBRemote::HandlePacket_qSpeedTest,  0LL,  0LL,  0LL,  "qSpeedTest:",  "Test the maximum speed at which packet can be sent/received.");
  unint64_t v613 = *((void *)this + 85);
  if (v613 < *((void *)this + 86))
  {
    __int128 v614 = v634;
    __int128 v615 = v635;
    *(void *)(v613 + 32) = v636;
    *(_OWORD *)unint64_t v613 = v614;
    *(_OWORD *)(v613 + 16) = v615;
    __int128 v616 = *(_OWORD *)__p;
    *(void *)(v613 + 56) = v638;
    *(_OWORD *)(v613 + 40) = v616;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v617 = v640;
    *(_OWORD *)(v613 + 64) = *(_OWORD *)v639;
    *(void *)(v613 + 80) = v617;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v613 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_529;
    }
    goto LABEL_528;
  }

  v618 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v619 = SHIBYTE(v640);
  *int v3 = v618;
  if ((v619 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_529;
    }
    goto LABEL_528;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_528:
  }
    operator delete(__p[0]);
LABEL_529:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  97,  (uint64_t)RNBRemote::HandlePacket_qXfer,  0LL,  0LL,  0LL,  "qXfer:",  "Support the qXfer packet.");
  unint64_t v620 = *((void *)this + 85);
  if (v620 < *((void *)this + 86))
  {
    __int128 v621 = v634;
    __int128 v622 = v635;
    *(void *)(v620 + 32) = v636;
    *(_OWORD *)unint64_t v620 = v621;
    *(_OWORD *)(v620 + 16) = v622;
    __int128 v623 = *(_OWORD *)__p;
    *(void *)(v620 + 56) = v638;
    *(_OWORD *)(v620 + 40) = v623;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v624 = v640;
    *(_OWORD *)(v620 + 64) = *(_OWORD *)v639;
    *(void *)(v620 + 80) = v624;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v620 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_535;
    }
    goto LABEL_534;
  }

  v625 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v626 = SHIBYTE(v640);
  *int v3 = v625;
  if ((v626 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      goto LABEL_535;
    }
    goto LABEL_534;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_534:
  }
    operator delete(__p[0]);
LABEL_535:
  RNBRemote::Packet::Packet( (uint64_t)&v634,  98,  (uint64_t)RNBRemote::HandlePacket_jGetDyldProcessState,  0LL,  0LL,  0LL,  "jGetDyldProcessState",  "Query the process state from dyld.");
  unint64_t v627 = *((void *)this + 85);
  if (v627 < *((void *)this + 86))
  {
    __int128 v628 = v634;
    __int128 v629 = v635;
    *(void *)(v627 + 32) = v636;
    *(_OWORD *)unint64_t v627 = v628;
    *(_OWORD *)(v627 + 16) = v629;
    __int128 v630 = *(_OWORD *)__p;
    *(void *)(v627 + 56) = v638;
    *(_OWORD *)(v627 + 40) = v630;
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v631 = v640;
    *(_OWORD *)(v627 + 64) = *(_OWORD *)v639;
    *(void *)(v627 + 80) = v631;
    uint64_t v638 = 0LL;
    v639[0] = 0LL;
    v639[1] = 0LL;
    uint64_t v640 = 0LL;
    *int v3 = (char *)(v627 + 88);
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      return;
    }
    goto LABEL_540;
  }

  v632 = std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(v2, (uint64_t)&v634);
  int v633 = SHIBYTE(v640);
  *int v3 = v632;
  if ((v633 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v638) & 0x80000000) == 0) {
      return;
    }
    goto LABEL_540;
  }

  operator delete(v639[0]);
  if (SHIBYTE(v638) < 0) {
LABEL_540:
  }
    operator delete(__p[0]);
}

void RNBRemote::~RNBRemote(RNBRemote *this)
{
  if (DNBLogEnabledForAny(0x100000)) {
    _DNBLogThreaded("%s", "RNBRemote::~RNBRemote()");
  }
  RNBRemote::StopReadRemoteDataThread(this);
  std::deque<std::string>::~deque[abi:nn180100]((uint64_t)this + 696);
  uint64_t v2 = *((void *)this + 84);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 85);
    unint64_t v4 = (void *)*((void *)this + 84);
    if (v3 == v2)
    {
LABEL_15:
      *((void *)this + 85) = v2;
      operator delete(v4);
      goto LABEL_16;
    }

    while (1)
    {
      if (*(char *)(v3 - 1) < 0)
      {
        operator delete(*(void **)(v3 - 24));
        if (*(char *)(v3 - 25) < 0) {
LABEL_13:
        }
          operator delete(*(void **)(v3 - 48));
      }

      else if (*(char *)(v3 - 25) < 0)
      {
        goto LABEL_13;
      }

      v3 -= 88LL;
      if (v3 == v2)
      {
        unint64_t v4 = (void *)*((void *)this + 84);
        goto LABEL_15;
      }
    }
  }

uint64_t RNBRemote::StopReadRemoteDataThread(RNBRemote *this)
{
  if (DNBLogEnabledForAny(0x100000))
  {
    uint64_t v2 = (pthread_mutex_t *)*((void *)this + 61);
    if (v2) {
      pthread_mutex_lock(*((pthread_mutex_t **)this + 61));
    }
    gettimeofday(&v16, 0LL);
    int tv_sec = v16.tv_sec;
    __darwin_suseconds_t tv_usec = v16.tv_usec;
    uint64_t v5 = *((void *)this + 62);
    int v6 = *((_DWORD *)this + 126);
    *((timeval *)this + 31) = v16;
    if (v2) {
      pthread_mutex_unlock(v2);
    }
    _DNBLogThreaded("%8u RNBRemote::%s called", tv_usec - v6 + 1000000 * (tv_sec - v5), "StopReadRemoteDataThread");
  }

  uint64_t result = PThreadEvent::GetEventBits((pthread_mutex_t *)((char *)this + 120));
  if ((result & 0x40) != 0)
  {
    if (DNBLogEnabled()) {
      _DNBLog( 0LL,  (uint64_t)"debugserver about to shut down packet communications to lldb.",  v8,  v9,  v10,  v11,  v12,  v13,  v14);
    }
    RNBSocket::Disconnect((RNBRemote *)((char *)this + 472));
    gettimeofday(&v16, 0LL);
    v15.int tv_sec = v16.tv_sec + v16.tv_usec / 1000000 + 2;
    v15.tv_nsec = 1000 * v16.tv_usec % 1000000000;
    return PThreadEvent::WaitForSetEvents((pthread_mutex_t *)((char *)this + 120), 0x80u, &v15);
  }

  return result;
}

uint64_t RNBRemote::HandlePacket_m(RNBRemote *this, const char *__s, uint64_t a3, uint64_t a4, const char *a5)
{
  if (!__s || !*__s || strlen(__s) <= 2)
  {
    __int128 v7 = this;
    int v8 = 3100;
    uint64_t v9 = __s;
    return RNBRemote::HandlePacket_ILLFORMED( v7,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v8,  v9,  a5);
  }

  __endptr = 0LL;
  uint64_t v11 = __s + 1;
  *__error() = 0;
  mach_vm_address_t v12 = strtoull(__s + 1, &__endptr, 16);
  if (*__error() && !v12)
  {
    __int128 v7 = this;
    int v8 = 3108;
LABEL_14:
    uint64_t v9 = v11;
    return RNBRemote::HandlePacket_ILLFORMED( v7,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v8,  v9,  a5);
  }

  if (*__endptr != 44)
  {
    __int128 v7 = this;
    int v8 = 3112;
    goto LABEL_14;
  }

  uint64_t v11 = __endptr + 1;
  *__error() = 0;
  size_t v13 = strtoul(v11, 0LL, 16);
  if (*__error() && !v13)
  {
    __int128 v7 = this;
    int v8 = 3122;
    goto LABEL_14;
  }

  if (v13)
  {
    std::basic_string<unsigned char>::basic_string[abi:nn180100](&__b, v13, 0);
    if ((char)v30 < 0)
    {
      unint64_t v14 = v29;
      if (v29)
      {
        p_b = __b;
        goto LABEL_23;
      }
    }

    else
    {
      unint64_t v14 = v30;
      if (v30)
      {
        p_b = (char *)&__b;
LABEL_23:
        unint64_t v18 = DNBProcessMemoryRead(*((_DWORD *)this + 3), v12, v14, p_b);
        if (v18)
        {
          unint64_t v19 = v18;
          std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)__p);
          for (uint64_t i = 0LL; i != v19; ++i)
          {
            std::string::size_type v22 = __p[0].__r_.__value_.__r.__words[0];
            uint64_t v23 = (char *)__p + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24);
            if (*((_DWORD *)v23 + 36) == -1)
            {
              std::ios_base::getloc((const std::ios_base *)((char *)__p
                                                          + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24)));
              int v24 = std::locale::use_facet((const std::locale *)&v26, &std::ctype<char>::id);
              ((void (*)(const std::locale::facet *, uint64_t))v24->__vftable[2].~facet_0)(v24, 32LL);
              std::locale::~locale((std::locale *)&v26);
              std::string::size_type v22 = __p[0].__r_.__value_.__r.__words[0];
            }

            *((_DWORD *)v23 + 36) = 48;
            *(_DWORD *)((char *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(v22 - 24)) = *(_DWORD *)((_BYTE *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(v22 - 24)) & 0xFFFFFFB5 | 8;
            *(_DWORD *)((char *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(v22 - 24)) = *(_DWORD *)((_BYTE *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(v22 - 24)) & 0xFFFFFF4F | 0x80;
            *(std::string::size_type *)((char *)__p[1].__r_.__value_.__r.__words + *(void *)(v22 - 24)) = 2LL;
            if ((v30 & 0x80u) == 0) {
              __int128 v21 = &__b;
            }
            else {
              __int128 v21 = __b;
            }
            std::ostream::operator<<(__p, *((unsigned __int8 *)v21 + i));
          }

          std::stringbuf::str(&v26, (const std::stringbuf *)&__p[0].__r_.__value_.__r.__words[1]);
          uint64_t v16 = RNBRemote::SendPacket((uint64_t)this, &v26);
          std::ostringstream::~ostringstream((uint64_t)__p);
          goto LABEL_38;
        }

        unint64_t v25 = "E08";
LABEL_36:
        std::string::basic_string[abi:nn180100]<0>(__p, v25);
        uint64_t v16 = RNBRemote::SendPacket((uint64_t)this, __p);
LABEL_38:
        if ((char)v30 < 0)
        {
          int v17 = __b;
          goto LABEL_40;
        }

        return v16;
      }
    }

    unint64_t v25 = "E78";
    goto LABEL_36;
  }

  std::string::basic_string[abi:nn180100]<0>(__p, (char *)&unk_1000528BD);
  uint64_t v16 = RNBRemote::SendPacket((uint64_t)this, __p);
  if ((char)__p[0].__r_.__value_.__s.__size_ < 0)
  {
    int v17 = (char *)__p[0].__r_.__value_.__r.__words[0];
LABEL_40:
    operator delete(v17);
  }

  return v16;
}

uint64_t RNBRemote::HandlePacket_p(RNBRemote *this, const char *a2, uint64_t a3, uint64_t a4, const char *a5)
{
  if (g_num_reg_entries)
  {
    if (!a2) {
      return RNBRemote::HandlePacket_ILLFORMED( this,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  4100,  a2,  a5);
    }
  }

  else
  {
    RNBRemote::InitializeRegisters(this, 0);
    if (!a2) {
      return RNBRemote::HandlePacket_ILLFORMED( this,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  4100,  a2,  a5);
    }
  }

  if (!*a2) {
    return RNBRemote::HandlePacket_ILLFORMED( this,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  4100,  a2,  a5);
  }
  int v7 = *((_DWORD *)this + 3);
  if (!v7)
  {
    __p[0].__r_.__value_.__s.__size_ = 3;
    LODWORD(__p[0].__r_.__value_.__l.__data_) = 3486021;
    uint64_t v13 = RNBRemote::SendPacket((uint64_t)this, __p);
    return v13;
  }

  *__error() = 0;
  __endptr = 0LL;
  unsigned int v8 = strtoul(a2 + 1, &__endptr, 16);
  if (!*__error() || v8)
  {
    if (*((_BYTE *)this + 782))
    {
      if (!__endptr || (unint64_t v14 = strstr(__endptr, "thread:")) == 0LL || (CurrentThread = strtoul(v14 + 7, 0LL, 16)) == 0)
      {
LABEL_24:
        uint64_t v10 = this;
        int v11 = 4117;
        return RNBRemote::HandlePacket_ILLFORMED( v10,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v11,  a2,  v9);
      }
    }

    else
    {
      unint64_t CurrentThread = *((void *)this + 68);
      if (CurrentThread + 1 <= 1)
      {
        unint64_t CurrentThread = DNBProcessGetCurrentThread(*((_DWORD *)this + 3));
        if (!CurrentThread) {
          goto LABEL_24;
        }
      }
    }

    unint64_t v24 = g_num_reg_entries;
    uint64_t v16 = g_reg_entries;
    __p[0].__r_.__value_.__r.__words[0] = v17;
    *(std::string::size_type *)((char *)__p[0].__r_.__value_.__r.__words + *(void *)(v17 - 24)) = v18;
    unint64_t v19 = (std::ios_base *)((char *)__p + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24));
    std::ios_base::init(v19, &__p[0].__r_.__value_.__r.__words[1]);
    v19[1].__vftable = 0LL;
    v19[1].__fmtflags_ = -1;
    std::streambuf::basic_streambuf(&__p[0].__r_.__value_.__r.__words[1]);
    *(_OWORD *)__int128 v27 = 0u;
    __int128 v28 = 0u;
    int v29 = 16;
    if (v8 < v24 && v16)
    {
      unint64_t v20 = v16 + ((unint64_t)v8 << 7);
      if (*(_DWORD *)(v20 + 12) == -1)
      {
        size_t v21 = *(unsigned int *)(v20 + 36);
        if ((_DWORD)v21)
        {
          std::basic_string<unsigned char>::basic_string[abi:nn180100](&__b, v21, 0);
          std::string::size_type v22 = (__b.__r_.__value_.__s.__size_ & 0x80u) == 0
              ? &__b
              : (std::stringbuf::string_type *)__b.__r_.__value_.__r.__words[0];
          uint64_t v23 = (__b.__r_.__value_.__s.__size_ & 0x80u) == 0
              ? __b.__r_.__value_.__s.__size_
              : __b.__r_.__value_.__l.__size_;
          append_hex_value((uint64_t)__p, (unsigned __int8 *)v22, v23, 0);
        }
      }

      else
      {
        register_value_in_hex_fixed_width((uint64_t)__p, v7, CurrentThread, v16 + ((unint64_t)v8 << 7), 0LL);
      }
    }

    else
    {
      if (DNBLogEnabled()) {
        _DNBLogError("RNBRemote::HandlePacket_p(%s): unknown register number %u requested\n", a2, v8);
      }
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"00000000", 8LL);
    }

    std::stringbuf::str(&__b, (const std::stringbuf *)&__p[0].__r_.__value_.__r.__words[1]);
    uint64_t v13 = RNBRemote::SendPacket((uint64_t)this, &__b);
    *(std::string::size_type *)((char *)__p[0].__r_.__value_.__r.__words
    if (SBYTE7(v28) < 0) {
      operator delete(v27[0]);
    }
    std::streambuf::~streambuf(&__p[0].__r_.__value_.__r.__words[1]);
    std::ios::~ios(&v30);
    return v13;
  }

  uint64_t v10 = this;
  int v11 = 4112;
  return RNBRemote::HandlePacket_ILLFORMED( v10,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v11,  a2,  v9);
}

uint64_t RNBRemote::HandlePacket_g(RNBRemote *this, const char *a2)
{
  unint64_t v19 = v4;
  *(void (__cdecl ***)(std::ostringstream *__hidden))((char *)&v19 + (void)*(v4 - 3)) = v5;
  int v6 = (std::ios_base *)((char *)&v19 + (void)*(v19 - 3));
  std::ios_base::init(v6, &v20);
  v6[1].__vftable = 0LL;
  v6[1].__fmtflags_ = -1;
  std::streambuf::basic_streambuf(&v20);
  memset(&v20.__str_, 0, 32);
  v20.__mode_ = 16;
  int v7 = *((_DWORD *)this + 3);
  if (!v7)
  {
    __p.__r_.__value_.__s.__size_ = 3;
    int v11 = 3223877;
    goto LABEL_20;
  }

  if (g_num_reg_entries)
  {
    if (*((_BYTE *)this + 782))
    {
LABEL_4:
      unsigned int v8 = strstr(a2 + 1, "thread:");
      if (!v8 || (unint64_t CurrentThread = strtoul(v8 + 7, 0LL, 16)) == 0)
      {
LABEL_17:
        uint64_t v15 = RNBRemote::HandlePacket_ILLFORMED( this,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  3295,  a2,  v9);
        goto LABEL_23;
      }

      goto LABEL_11;
    }
  }

  else
  {
    RNBRemote::InitializeRegisters(this, 0);
    int v7 = *((_DWORD *)this + 3);
    if (*((_BYTE *)this + 782)) {
      goto LABEL_4;
    }
  }

  unint64_t CurrentThread = *((void *)this + 68);
  if (CurrentThread + 1 <= 1)
  {
    unint64_t CurrentThread = DNBProcessGetCurrentThread(v7);
    if (!CurrentThread) {
      goto LABEL_17;
    }
  }

uint64_t RNBRemote::HandlePacket_M(RNBRemote *this, const char *__s, uint64_t a3, uint64_t a4, const char *a5)
{
  if (!__s || !*__s || strlen(__s) <= 2)
  {
    int v7 = this;
    int v8 = 3027;
    uint64_t v9 = __s;
    return RNBRemote::HandlePacket_ILLFORMED( v7,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v8,  v9,  a5);
  }

  __endptr = 0LL;
  int v11 = __s + 1;
  *__error() = 0;
  unint64_t v12 = strtoull(__s + 1, &__endptr, 16);
  if (*__error() && !v12)
  {
    int v7 = this;
    int v8 = 3035;
LABEL_14:
    uint64_t v9 = v11;
    return RNBRemote::HandlePacket_ILLFORMED( v7,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v8,  v9,  a5);
  }

  if (*__endptr != 44)
  {
    int v7 = this;
    int v8 = 3039;
    goto LABEL_14;
  }

  size_t v13 = __endptr + 1;
  *__error() = 0;
  unint64_t v14 = strtoul(v13, &__endptr, 16);
  if (*__error() && !v14)
  {
    int v7 = this;
    int v8 = 3049;
    uint64_t v9 = v13;
    return RNBRemote::HandlePacket_ILLFORMED( v7,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v8,  v9,  a5);
  }

  if (!v14) {
    goto LABEL_28;
  }
  if (*__endptr != 58)
  {
    int v7 = this;
    int v8 = 3057;
    uint64_t v9 = v13;
    return RNBRemote::HandlePacket_ILLFORMED( v7,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v8,  v9,  a5);
  }

  uint64_t v15 = __endptr + 1;
  size_t v16 = strlen(__endptr + 1);
  if ((v16 & 1) != 0)
  {
    int v7 = this;
    int v8 = 3065;
    uint64_t v9 = __endptr + 1;
    return RNBRemote::HandlePacket_ILLFORMED( v7,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v8,  v9,  a5);
  }

  if (!v16) {
    goto LABEL_28;
  }
  __chkstk_darwin(v16);
  std::string::size_type v18 = (char *)&v27 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  bzero(v18, v17);
  std::string::value_type v19 = *v15;
  if (*v15)
  {
    std::stringbuf v20 = v18;
    do
    {
      unsigned __int8 v21 = v15[1];
      if (!v21) {
        break;
      }
      __str.__r_.__value_.__s.__data_[0] = v19;
      *(_WORD *)((char *)&__str.__r_.__value_.__l.__data_ + 1) = v21;
      *__error() = 0;
      char v22 = strtoul((const char *)&__str, 0LL, 16);
      if (*__error()) {
        BOOL v23 = v22 == 0LL;
      }
      else {
        BOOL v23 = 0;
      }
      if (v23)
      {
        int v7 = this;
        int v8 = 3083;
        uint64_t v9 = v15;
        return RNBRemote::HandlePacket_ILLFORMED( v7,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v8,  v9,  a5);
      }

      *v20++ = v22;
      int v24 = v15[2];
      v15 += 2;
      std::string::value_type v19 = v24;
    }

    while (v24);
  }

  if (DNBProcessMemoryWrite(*((_DWORD *)this + 3), v12, v14, v18) != v14) {
    unint64_t v25 = "E09";
  }
  else {
LABEL_28:
  }
    unint64_t v25 = "OK";
  std::string::basic_string[abi:nn180100]<0>(&__str, v25);
  uint64_t v26 = RNBRemote::SendPacket((uint64_t)this, &__str);
  return v26;
}

uint64_t RNBRemote::HandlePacket_P(RNBRemote *this, const char *a2, uint64_t a3, uint64_t a4, const char *a5)
{
  if (g_num_reg_entries)
  {
    if (!a2) {
      return RNBRemote::HandlePacket_ILLFORMED( this,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  4153,  a2,  a5);
    }
  }

  else
  {
    RNBRemote::InitializeRegisters(this, 0);
    if (!a2) {
      return RNBRemote::HandlePacket_ILLFORMED( this,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  4153,  a2,  a5);
    }
  }

  if (!*a2) {
    return RNBRemote::HandlePacket_ILLFORMED( this,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  4153,  a2,  a5);
  }
  int v7 = *((_DWORD *)this + 3);
  if (!v7)
  {
    BYTE7(v28) = 3;
    LODWORD(__p[0]) = 3682885;
    uint64_t v20 = RNBRemote::SendPacket((uint64_t)this, (std::string *)__p);
    if (SBYTE7(v28) < 0) {
      operator delete(__p[0]);
    }
    return v20;
  }

  StdStringExtractor::StdStringExtractor((StdStringExtractor *)v33, a2);
  int Char = StdStringExtractor::GetChar(v8, 0);
  unsigned int HexMaxU32 = StdStringExtractor::GetHexMaxU32((StdStringExtractor *)v33, 0, 0xFFFFFFFFLL);
  int v11 = StdStringExtractor::GetChar((StdStringExtractor *)v33, 0);
  if (Char != 80)
  {
    unsigned __int8 v21 = this;
    int v22 = 4169;
LABEL_20:
    uint64_t v20 = RNBRemote::HandlePacket_ILLFORMED( v21,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v22,  a2,  v12);
    goto LABEL_29;
  }

  if (HexMaxU32 == -1)
  {
    BYTE7(v28) = 3;
    int v23 = 3748421;
LABEL_23:
    LODWORD(__p[0]) = v23;
    goto LABEL_26;
  }

  if (v11 != 61)
  {
    BYTE7(v28) = 3;
    int v23 = 3158853;
    goto LABEL_23;
  }

  if (g_num_reg_entries <= (unint64_t)HexMaxU32)
  {
    int v24 = "E47";
  }

  else
  {
    unint64_t v13 = g_reg_entries + ((unint64_t)HexMaxU32 << 7);
    if (*(_DWORD *)(v13 + 8) != -1 || *(_DWORD *)(v13 + 12) != -1)
    {
      *(_OWORD *)std::stringbuf::string_type __p = *(_OWORD *)(v13 + 8);
      __int128 v14 = *(_OWORD *)(v13 + 24);
      __int128 v15 = *(_OWORD *)(v13 + 40);
      __int128 v16 = *(_OWORD *)(v13 + 56);
      uint64_t v31 = *(void *)(v13 + 72);
      __int128 v29 = v15;
      __int128 v30 = v16;
      __int128 v28 = v14;
      StdStringExtractor::GetHexBytes((StdStringExtractor *)v33, v32, *(unsigned int *)(v13 + 36), 204);
      ThreadIDFromThreadSuffix = RNBRemote::ExtractThreadIDFromThreadSuffix(this, a2);
      if (ThreadIDFromThreadSuffix)
      {
        else {
          std::string::size_type v18 = "E32";
        }
        std::string::basic_string[abi:nn180100]<0>(&v26, v18);
        uint64_t v20 = RNBRemote::SendPacket((uint64_t)this, &v26);
        unint64_t v25 = (void *)v26.__r_.__value_.__r.__words[0];
        goto LABEL_28;
      }

      unsigned __int8 v21 = this;
      int v22 = 4199;
      goto LABEL_20;
    }

    if (DNBLogEnabled()) {
      _DNBLogError("RNBRemote::HandlePacket_P(%s): unknown register number %u requested\n", a2, HexMaxU32);
    }
    int v24 = "E48";
  }

  std::string::basic_string[abi:nn180100]<0>(__p, v24);
LABEL_26:
  uint64_t v20 = RNBRemote::SendPacket((uint64_t)this, (std::string *)__p);
  if (SBYTE7(v28) < 0)
  {
    unint64_t v25 = __p[0];
LABEL_28:
    operator delete(v25);
  }

LABEL_29:
  StdStringExtractor::~StdStringExtractor(v33);
  return v20;
}

      StdStringExtractor::~StdStringExtractor(v11);
      return v3;
    }

    if (*((char *)this + 111) < 0)
    {
      if (*((void *)this + 12)) {
        uint64_t v5 = (const char *)*((void *)this + 11);
      }
      else {
        uint64_t v5 = 0LL;
      }
    }

    else if (*((_BYTE *)this + 111))
    {
      uint64_t v5 = (char *)this + 88;
    }

    else
    {
      uint64_t v5 = 0LL;
    }

    if (stat(v5, &__p) == -1)
    {
      if (*((char *)this + 111) < 0)
      {
        **((_BYTE **)this + 11) = 0;
        *((void *)this + 12) = 0LL;
      }

      else
      {
        *((_BYTE *)this + 88) = 0;
        *((_BYTE *)this + 111) = 0;
      }

      v9.__r_.__value_.__s.__size_ = 3;
      int v7 = 3225157;
    }

    else
    {
      if ((__p.st_mode & 0xF000) == 0x4000)
      {
        v9.__r_.__value_.__s.__size_ = 2;
        strcpy((char *)&v9, "OK");
        goto LABEL_26;
      }

      if (*((char *)this + 111) < 0)
      {
        **((_BYTE **)this + 11) = 0;
        *((void *)this + 12) = 0LL;
      }

      else
      {
        *((_BYTE *)this + 88) = 0;
        *((_BYTE *)this + 111) = 0;
      }

      v9.__r_.__value_.__s.__size_ = 3;
      int v7 = 3290693;
    }

    LODWORD(v9.__r_.__value_.__l.__data_) = v7;
LABEL_26:
    uint64_t v3 = RNBRemote::SendPacket((uint64_t)this, &v9);
    if ((char)v9.__r_.__value_.__s.__size_ < 0)
    {
      int v6 = (void *)v9.__r_.__value_.__r.__words[0];
      goto LABEL_28;
    }

    goto LABEL_29;
  }

  HIBYTE(__p.st_gid) = 3;
  __p.st_dev = 3159621;
  uint64_t v3 = RNBRemote::SendPacket((uint64_t)this, (std::string *)&__p);
  if (SHIBYTE(__p.st_gid) < 0) {
    operator delete(*(void **)&__p.st_dev);
  }
  return v3;
}

  if (__p)
  {
    int v23 = __p;
    operator delete(__p);
  }

  return 0LL;
}

      if (SHIBYTE(v58) < 0) {
        goto LABEL_62;
      }
LABEL_30:
      if (++v21 == v25)
      {
        a4 = v48;
        if (v51 != (std::string *)v50)
        {
          int v38 = 0LL;
          else {
            unint64_t v39 = (uint64_t)((uint64_t)v51 - v50) / 160;
          }
          do
          {
            if (MachProcess::GetMachOInformationFromMemory( v47,  v15,  *(void *)(v50 + v38 + 24),  v46,  v50 + v38 + 32)) {
              *(_BYTE *)(v50 + v38 + 152) = 1;
            }
            v38 += 160LL;
            --v39;
          }

          while (v39);
        }

        break;
      }
    }
  }

  MachProcess::FormatDynamicLibrariesIntoJSON(&v50, 1LL, a4);
  __int128 v40 = (std::string *)v50;
  if (v50)
  {
    __int128 v41 = v51;
    __int128 v42 = (void *)v50;
    if (v51 != (std::string *)v50)
    {
      do
      {
        __int128 v41 = (std::string *)((char *)v41 - 160);
        std::allocator<MachProcess::binary_image_information>::destroy[abi:ne180100]((uint64_t)&v52, (uint64_t)v41);
      }

      while (v41 != v40);
      __int128 v42 = (void *)v50;
    }

    unint64_t v51 = v40;
    operator delete(v42);
  }

  uint64_t v43 = v53;
  if (v53)
  {
    __int128 v44 = (uint64_t)v54;
    int v45 = v53;
    if (v54 != v53)
    {
      do
      {
        v44 -= 160LL;
        std::allocator<MachProcess::binary_image_information>::destroy[abi:ne180100]((uint64_t)&v55, v44);
      }

      while ((_BYTE *)v44 != v43);
      int v45 = v53;
    }

    __int128 v54 = v43;
    operator delete(v45);
  }

uint64_t RNBRemote::HandlePacket_G(RNBRemote *this, const char *a2)
{
  if (*((_DWORD *)this + 3))
  {
    if (!g_num_reg_entries) {
      RNBRemote::InitializeRegisters(this, 0);
    }
    StdStringExtractor::StdStringExtractor((StdStringExtractor *)&__p, a2);
    uint64_t v19 = 1LL;
    int v5 = *((_DWORD *)this + 3);
    if (*((_BYTE *)this + 782))
    {
      if (!a2 || (int v6 = strstr(a2, "thread:")) == 0LL || (CurrentThread = strtoul(v6 + 7, 0LL, 16)) == 0)
      {
LABEL_18:
        uint64_t v8 = RNBRemote::HandlePacket_ILLFORMED( this,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  3333,  a2,  v4);
LABEL_30:
        StdStringExtractor::~StdStringExtractor((void **)&__p.__r_.__value_.__l.__data_);
        return v8;
      }
    }

    else
    {
      unint64_t CurrentThread = *((void *)this + 68);
      if (CurrentThread + 1 <= 1)
      {
        unint64_t CurrentThread = DNBProcessGetCurrentThread(*((_DWORD *)this + 3));
        if (!CurrentThread) {
          goto LABEL_18;
        }
      }
    }

    size_t RegisterContext = DNBThreadGetRegisterContext(v5, CurrentThread, 0LL, 0LL);
    if (!RegisterContext)
    {
      v17.__r_.__value_.__s.__size_ = 3;
      LODWORD(v17.__r_.__value_.__l.__data_) = 3487301;
      uint64_t v8 = RNBRemote::SendPacket((uint64_t)this, &v17);
      unint64_t v13 = (void *)v17.__r_.__value_.__r.__words[0];
LABEL_29:
      operator delete(v13);
      goto LABEL_30;
    }

    size_t v10 = RegisterContext;
    if ((RegisterContext & 0x8000000000000000LL) != 0) {
      abort();
    }
    int v11 = operator new(RegisterContext);
    bzero(v11, v10);
    unint64_t HexBytes = StdStringExtractor::GetHexBytes((StdStringExtractor *)&__p, v11, v10, 204);
    if (HexBytes == v10)
    {
      if (DNBThreadSetRegisterContext(v5, CurrentThread, v11) == v10)
      {
        v17.__r_.__value_.__s.__size_ = 2;
        strcpy((char *)&v17, "OK");
LABEL_26:
        uint64_t v8 = RNBRemote::SendPacket((uint64_t)this, &v17);
        unint64_t v13 = v11;
        goto LABEL_29;
      }

      v17.__r_.__value_.__s.__size_ = 3;
      int v15 = 3487045;
    }

    else
    {
      unint64_t v14 = HexBytes;
      if (DNBLogEnabled()) {
        _DNBLogError("RNBRemote::HandlePacket_G(%s): extracted %llu of %llu bytes, size mismatch\n", a2, v14, v10);
      }
      v17.__r_.__value_.__s.__size_ = 3;
      int v15 = 3421765;
    }

    LODWORD(v17.__r_.__value_.__l.__data_) = v15;
    goto LABEL_26;
  }

  __p.__r_.__value_.__s.__size_ = 3;
  LODWORD(__p.__r_.__value_.__l.__data_) = 3223877;
  uint64_t v8 = RNBRemote::SendPacket((uint64_t)this, &__p);
  return v8;
}

uint64_t RNBRemote::HandlePacket_z(RNBRemote *this, const char *a2, uint64_t a3, uint64_t a4, const char *a5)
{
  int v5 = a2;
  if (!a2 || (int v7 = *(unsigned __int8 *)a2, !*a2))
  {
    int v15 = 3968;
    return RNBRemote::HandlePacket_ILLFORMED( this,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v15,  v5,  a5);
  }

  int v8 = *((_DWORD *)this + 3);
  if (!v8)
  {
    __p.__r_.__value_.__s.__size_ = 3;
    LODWORD(__p.__r_.__value_.__l.__data_) = 3486021;
    goto LABEL_11;
  }

  uint64_t v9 = a2 + 3;
  if (a2[2] != 44)
  {
    int v15 = 3978;
    int v5 = a2 + 3;
    return RNBRemote::HandlePacket_ILLFORMED( this,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v15,  v5,  a5);
  }

  int v10 = a2[1];
  int v23 = 0LL;
  *__error() = 0;
  unint64_t v11 = strtoull(v9, &v23, 16);
  if (!*__error() || v11)
  {
    uint64_t v9 = v23 + 1;
    if (*v23 != 44)
    {
      unint64_t v13 = this;
      int v14 = 3990;
      return RNBRemote::HandlePacket_ILLFORMED( v13,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v14,  v9,  v12);
    }

    *__error() = 0;
    unint64_t v18 = strtoul(v9, &v23, 16);
    if (*__error() && !v18)
    {
      unint64_t v13 = this;
      int v14 = 3996;
      return RNBRemote::HandlePacket_ILLFORMED( v13,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v14,  v9,  v12);
    }

    if (v7 != 122)
    {
      if (v7 == 90)
      {
        if ((v10 - 50) < 3)
        {
          if (v10 == 51) {
            int v20 = 1;
          }
          else {
            int v20 = 3;
          }
          if (v10 == 50) {
            int v21 = 2;
          }
          else {
            int v21 = v20;
          }
          goto LABEL_41;
        }

        if ((v10 - 48) <= 1)
        {
          if (!DNBBreakpointSet(v8, v11, v18, v10 == 49))
          {
LABEL_38:
            int v22 = "E09";
LABEL_44:
            std::string::basic_string[abi:nn180100]<0>(&__p, v22);
LABEL_11:
            uint64_t v17 = RNBRemote::SendPacket((uint64_t)this, &__p);
            return v17;
          }

uint64_t RNBRemote::HandlePacket_s(RNBRemote *this, const char *a2)
{
  int v3 = *((_DWORD *)this + 3);
  if (v3)
  {
    uint64_t CurrentThread = *((void *)this + 67);
    if ((unint64_t)(CurrentThread + 1) > 1
      || (uint64_t CurrentThread = *((void *)this + 68), (unint64_t)(CurrentThread + 1) > 1)
      || (uint64_t CurrentThread = DNBProcessGetCurrentThread(*((_DWORD *)this + 3))) != 0)
    {
      DNBThreadResumeActions::DNBThreadResumeActions((DNBThreadResumeActions *)&v11);
      DNBThreadResumeActions::AppendAction(&v11.__r_.__value_.__l.__data_, CurrentThread, 6u, 0, -1LL);
      DNBThreadResumeActions::SetDefaultThreadActionIfNeeded(&v11.__r_.__value_.__l.__data_, 4, 0);
      BOOL v5 = DNBProcessResume( v3,  v11.__r_.__value_.__l.__data_,  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11.__r_.__value_.__l.__size_ - v11.__r_.__value_.__r.__words[0]) >> 3));
      uint64_t v6 = 0LL;
      if (!v5)
      {
        __p.__r_.__value_.__s.__size_ = 3;
        LODWORD(__p.__r_.__value_.__l.__data_) = 3748933;
        uint64_t v6 = RNBRemote::SendPacket((uint64_t)this, &__p);
      }

      if (v12) {
        operator delete(v12);
      }
      int v7 = (void *)v11.__r_.__value_.__r.__words[0];
      if (v11.__r_.__value_.__r.__words[0])
      {
        v11.__r_.__value_.__l.__size_ = v11.__r_.__value_.__r.__words[0];
LABEL_15:
        operator delete(v7);
        return v6;
      }

      return v6;
    }

    v11.__r_.__value_.__s.__size_ = 3;
    int v8 = 3355461;
  }

  else
  {
    v11.__r_.__value_.__s.__size_ = 3;
    int v8 = 3289925;
  }

  LODWORD(v11.__r_.__value_.__l.__data_) = v8;
  uint64_t v6 = RNBRemote::SendPacket((uint64_t)this, &v11);
  if ((char)v11.__r_.__value_.__s.__size_ < 0)
  {
    int v7 = (void *)v11.__r_.__value_.__r.__words[0];
    goto LABEL_15;
  }

  return v6;
}

uint64_t RNBRemote::HandlePacket_c(RNBRemote *this, const char *a2)
{
  int v3 = *((_DWORD *)this + 3);
  if (!v3)
  {
    v13.__r_.__value_.__s.__size_ = 3;
    LODWORD(v13.__r_.__value_.__l.__data_) = 3355205;
    uint64_t v8 = RNBRemote::SendPacket((uint64_t)this, &v13);
    int v10 = (void *)v13.__r_.__value_.__r.__words[0];
LABEL_15:
    operator delete(v10);
    return v8;
  }

  __int128 v15 = xmmword_100051E80;
  uint64_t v16 = -1LL;
  BOOL v5 = a2 + 1;
  if (a2[1])
  {
    *(void *)&__int128 v15 = *((void *)this + 67);
    *__error() = 0;
    unint64_t v6 = strtoull(v5, 0LL, 16);
    uint64_t v16 = v6;
    if (*__error())
    {
      if (!v6) {
        return RNBRemote::HandlePacket_ILLFORMED( this,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  4226,  a2,  v7);
      }
    }
  }

  DNBThreadResumeActions::DNBThreadResumeActions((DNBThreadResumeActions *)&v13);
  DNBThreadResumeActions::Append(&v13.__r_.__value_.__l.__data_, &v15);
  DNBThreadResumeActions::SetDefaultThreadActionIfNeeded(&v13.__r_.__value_.__l.__data_, 5, 0);
  BOOL v9 = DNBProcessResume( v3,  v13.__r_.__value_.__l.__data_,  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13.__r_.__value_.__l.__size_ - v13.__r_.__value_.__r.__words[0]) >> 3));
  uint64_t v8 = 0LL;
  if (!v9)
  {
    __p.__r_.__value_.__s.__size_ = 3;
    LODWORD(__p.__r_.__value_.__l.__data_) = 3486277;
    uint64_t v8 = RNBRemote::SendPacket((uint64_t)this, &__p);
  }

  if (v14) {
    operator delete(v14);
  }
  int v10 = (void *)v13.__r_.__value_.__r.__words[0];
  if (v13.__r_.__value_.__r.__words[0])
  {
    v13.__r_.__value_.__l.__size_ = v13.__r_.__value_.__r.__words[0];
    goto LABEL_15;
  }

  return v8;
}

uint64_t RNBRemote::HandlePacket_S(RNBRemote *this, const char *a2)
{
  int v3 = *((_DWORD *)this + 3);
  if (!v3)
  {
    __endptr.__r_.__value_.__s.__size_ = 3;
    int v9 = 3552069;
LABEL_19:
    LODWORD(__endptr.__r_.__value_.__l.__data_) = v9;
    uint64_t v8 = RNBRemote::SendPacket((uint64_t)this, &__endptr);
    __int128 v15 = (void *)__endptr.__r_.__value_.__r.__words[0];
LABEL_21:
    operator delete(v15);
    return v8;
  }

  __int128 v21 = xmmword_100051E98;
  uint64_t v22 = -1LL;
  BOOL v5 = a2 + 1;
  if (a2[1])
  {
    __endptr.__r_.__value_.__r.__words[0] = 0LL;
    *__error() = 0;
    HIDWORD(v21) = strtoul(v5, &__endptr.__r_.__value_.__l.__data_, 16);
    if (*__error())
    {
      int v7 = 4617;
      return RNBRemote::HandlePacket_ILLFORMED( this,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v7,  a2,  v6);
    }

    std::string::size_type v10 = __endptr.__r_.__value_.__r.__words[0];
    if (*__endptr.__r_.__value_.__l.__data_ == 59)
    {
      *__error() = 0;
      unint64_t v11 = strtoull((const char *)(v10 + 1), 0LL, 16);
      uint64_t v22 = v11;
      if (*__error())
      {
        if (!v11)
        {
          int v7 = 4623;
          return RNBRemote::HandlePacket_ILLFORMED( this,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v7,  a2,  v6);
        }
      }
    }
  }

  uint64_t v12 = *((void *)this + 67);
  *(void *)&__int128 v21 = v12;
  if ((unint64_t)(v12 + 1) <= 1)
  {
    __endptr.__r_.__value_.__s.__size_ = 3;
    int v9 = 3159109;
    goto LABEL_19;
  }

  int State = DNBThreadGetState(v3, v12);
  if (State == 9 || State == 0)
  {
    __endptr.__r_.__value_.__s.__size_ = 3;
    int v9 = 3617605;
    goto LABEL_19;
  }

  DNBThreadResumeActions::DNBThreadResumeActions((DNBThreadResumeActions *)&__endptr);
  DNBThreadResumeActions::Append(&__endptr.__r_.__value_.__l.__data_, &v21);
  DNBThreadResumeActions::SetDefaultThreadActionIfNeeded(&__endptr.__r_.__value_.__l.__data_, 4, 0);
  BOOL v17 = DNBProcessResume( v3,  __endptr.__r_.__value_.__l.__data_,  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(__endptr.__r_.__value_.__l.__size_ - __endptr.__r_.__value_.__r.__words[0]) >> 3));
  uint64_t v8 = 0LL;
  if (!v17)
  {
    __p.__r_.__value_.__s.__size_ = 3;
    LODWORD(__p.__r_.__value_.__l.__data_) = 3748677;
    uint64_t v8 = RNBRemote::SendPacket((uint64_t)this, &__p);
  }

  if (v20) {
    operator delete(v20);
  }
  __int128 v15 = (void *)__endptr.__r_.__value_.__r.__words[0];
  if (__endptr.__r_.__value_.__r.__words[0])
  {
    __endptr.__r_.__value_.__l.__size_ = __endptr.__r_.__value_.__r.__words[0];
    goto LABEL_21;
  }

  return v8;
}

uint64_t RNBRemote::HandlePacket_H(RNBRemote *this, const char *a2, uint64_t a3, uint64_t a4, const char *a5)
{
  BOOL v5 = this;
  unint64_t v6 = a2 + 1;
  if ((*((unsigned __int8 *)a2 + 1) | 4) != 0x67)
  {
    int v13 = 1539;
    return RNBRemote::HandlePacket_ILLFORMED( this,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v13,  v6,  a5);
  }

  *__error() = 0;
  unint64_t v8 = strtoul(a2 + 2, 0LL, 16);
  if (*__error()) {
    BOOL v9 = v8 == 0;
  }
  else {
    BOOL v9 = 0;
  }
  if (v9)
  {
    this = v5;
    int v13 = 1552;
    return RNBRemote::HandlePacket_ILLFORMED( this,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v13,  v6,  a5);
  }

  int v10 = *(unsigned __int8 *)v6;
  if (v10 == 99)
  {
    *((void *)v5 + 67) = v8;
    int v10 = *(unsigned __int8 *)v6;
  }

  if (v10 == 103)
  {
    DNBProcessSetCurrentThread(*((_DWORD *)v5 + 3), v8);
    *((void *)v5 + 68) = v8;
  }

  __p.__r_.__value_.__s.__size_ = 2;
  strcpy((char *)&__p, "OK");
  uint64_t v11 = RNBRemote::SendPacket((uint64_t)v5, &__p);
  return v11;
}

uint64_t RNBRemote::HandlePacket_last_signal(RNBRemote *this, const char *a2)
{
  int v3 = *((_DWORD *)this + 3);
  if (!v3)
  {
    __dst[0].__r_.__value_.__s.__size_ = 3;
    LODWORD(__dst[0].__r_.__value_.__l.__data_) = 3289157;
    goto LABEL_41;
  }

  unsigned int State = DNBProcessGetState(*((_DWORD *)this + 3));
  uint64_t v5 = 0LL;
  if (State > 0xA) {
    return v5;
  }
  if (((1 << State) & 0x203) == 0)
  {
    if (((1 << State) & 0x490) != 0)
    {
      uint64_t CurrentThread = DNBProcessGetCurrentThread(v3);
      DNBProcessSetCurrentThread(*((_DWORD *)this + 3), CurrentThread);
      *((void *)this + 68) = CurrentThread;
      RNBRemote::SendStopReplyPacketForThread(this, CurrentThread);
      return 0LL;
    }

    return v5;
  }

  *(void *)std::string __str = 0LL;
  uint64_t v36 = 0LL;
  int v34 = 0;
  if (DNBProcessGetExitStatus(v3, &v34))
  {
    if (v34)
    {
      if ((v34 & 0x7F) == 0x7F)
      {
        if (v34 >> 8 != 19) {
          snprintf(__str, 0x10uLL, "S%02x");
        }
      }

      else if ((v34 & 0x7F) != 0)
      {
        snprintf(__str, 0x10uLL, "X%02x");
      }

      else
      {
        snprintf(__str, 0x10uLL, "W%02x");
      }
    }
  }

  else
  {
    int v34 = 0;
  }

  if (!__str[0])
  {
    strcpy(__str, "W00");
    HIBYTE(v36) = 0;
  }

  ExitInfo = DNBProcessGetExitInfo(v3);
  if (ExitInfo)
  {
    unint64_t v8 = ExitInfo;
    if (*(_BYTE *)ExitInfo)
    {
      __dst[0].__r_.__value_.__r.__words[0] = v9;
      *(std::string::size_type *)((char *)__dst[0].__r_.__value_.__r.__words + *(void *)(v9 - 24)) = v10;
      uint64_t v11 = (std::ios_base *)((char *)__dst + *(void *)(__dst[0].__r_.__value_.__r.__words[0] - 24));
      std::ios_base::init(v11, &__dst[0].__r_.__value_.__r.__words[1]);
      v11[1].__vftable = 0LL;
      v11[1].__fmtflags_ = -1;
      std::streambuf::basic_streambuf(&__dst[0].__r_.__value_.__r.__words[1]);
      *(_OWORD *)std::string __p = 0u;
      __int128 v31 = 0u;
      int v32 = 16;
      size_t v12 = strlen(__str);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__dst, (uint64_t)__str, v12);
      v28.__r_.__value_.__s.__data_[0] = 59;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__dst, (uint64_t)&v28, 1LL);
      std::string::size_type v13 = __dst[0].__r_.__value_.__r.__words[0];
      int v14 = (char *)__dst + *(void *)(__dst[0].__r_.__value_.__r.__words[0] - 24);
      if (*((_DWORD *)v14 + 36) == -1)
      {
        std::ios_base::getloc((const std::ios_base *)((char *)__dst
                                                    + *(void *)(__dst[0].__r_.__value_.__r.__words[0] - 24)));
        __int128 v15 = std::locale::use_facet((const std::locale *)&v28, &std::ctype<char>::id);
        ((void (*)(const std::locale::facet *, uint64_t))v15->__vftable[2].~facet_0)(v15, 32LL);
        std::locale::~locale((std::locale *)&v28);
        std::string::size_type v13 = __dst[0].__r_.__value_.__r.__words[0];
      }

      *((_DWORD *)v14 + 36) = 48;
      *(_DWORD *)((char *)&__dst[0].__r_.__value_.__r.__words[1] + *(void *)(v13 - 24)) = *(_DWORD *)((_BYTE *)&__dst[0].__r_.__value_.__r.__words[1] + *(void *)(v13 - 24)) & 0xFFFFFFB5 | 8;
      *(_DWORD *)((char *)&__dst[0].__r_.__value_.__r.__words[1] + *(void *)(v13 - 24)) = *(_DWORD *)((_BYTE *)&__dst[0].__r_.__value_.__r.__words[1] + *(void *)(v13 - 24)) & 0xFFFFFF4F | 0x80;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__dst, (uint64_t)"description", 11LL);
      v28.__r_.__value_.__s.__data_[0] = 58;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__dst, (uint64_t)&v28, 1LL);
      uint64_t v16 = *v8;
      if (*v8)
      {
        BOOL v17 = v8 + 1;
        do
        {
          std::string::size_type v19 = __dst[0].__r_.__value_.__r.__words[0];
          int v20 = (char *)__dst + *(void *)(__dst[0].__r_.__value_.__r.__words[0] - 24);
          if (*((_DWORD *)v20 + 36) == -1)
          {
            std::ios_base::getloc((const std::ios_base *)((char *)__dst
                                                        + *(void *)(__dst[0].__r_.__value_.__r.__words[0] - 24)));
            __int128 v21 = std::locale::use_facet((const std::locale *)&v28, &std::ctype<char>::id);
            ((void (*)(const std::locale::facet *, uint64_t))v21->__vftable[2].~facet_0)(v21, 32LL);
            std::locale::~locale((std::locale *)&v28);
            std::string::size_type v19 = __dst[0].__r_.__value_.__r.__words[0];
            uint64_t v16 = *(v17 - 1);
          }

          *((_DWORD *)v20 + 36) = 48;
          *(_DWORD *)((char *)&__dst[0].__r_.__value_.__r.__words[1] + *(void *)(v19 - 24)) = *(_DWORD *)((_BYTE *)&__dst[0].__r_.__value_.__r.__words[1] + *(void *)(v19 - 24)) & 0xFFFFFFB5 | 8;
          *(_DWORD *)((char *)&__dst[0].__r_.__value_.__r.__words[1] + *(void *)(v19 - 24)) = *(_DWORD *)((_BYTE *)&__dst[0].__r_.__value_.__r.__words[1] + *(void *)(v19 - 24)) & 0xFFFFFF4F | 0x80;
          *(std::string::size_type *)((char *)__dst[1].__r_.__value_.__r.__words + *(void *)(v19 - 24)) = 2LL;
          std::ostream::operator<<(__dst, v16);
          unsigned int v18 = *v17++;
          uint64_t v16 = v18;
        }

        while (v18);
      }

      v28.__r_.__value_.__s.__data_[0] = 59;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__dst, (uint64_t)&v28, 1LL);
      std::stringbuf::str(&v28, (const std::stringbuf *)&__dst[0].__r_.__value_.__r.__words[1]);
      uint64_t v5 = RNBRemote::SendPacket((uint64_t)this, &v28);
      *(std::string::size_type *)((char *)__dst[0].__r_.__value_.__r.__words
      if (SBYTE7(v31) < 0) {
        operator delete(__p[0]);
      }
      std::streambuf::~streambuf(&__dst[0].__r_.__value_.__r.__words[1]);
      std::ios::~ios(&v33);
      return v5;
    }
  }

  size_t v22 = strlen(__str);
  if (v22 >= 0x7FFFFFFFFFFFFFF8LL) {
    abort();
  }
  std::string::size_type v23 = v22;
  if (v22 >= 0x17)
  {
    uint64_t v25 = (v22 & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((v22 | 7) != 0x17) {
      uint64_t v25 = v22 | 7;
    }
    uint64_t v26 = v25 + 1;
    int v24 = (std::string *)operator new(v25 + 1);
    __dst[0].__r_.__value_.__l.__size_ = v23;
    __dst[0].__r_.__value_.__l.__cap_ = v26 | 0x8000000000000000LL;
    __dst[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v24;
  }

  else
  {
    __dst[0].__r_.__value_.__s.__size_ = v22;
    int v24 = __dst;
    if (!v22) {
      goto LABEL_40;
    }
  }

  memcpy(v24, __str, v23);
LABEL_40:
  v24->__r_.__value_.__s.__data_[v23] = 0;
LABEL_41:
  uint64_t v5 = RNBRemote::SendPacket((uint64_t)this, __dst);
  return v5;
}

uint64_t RNBRemote::HandlePacket_stop_process(RNBRemote *this, const char *a2)
{
  if (!DNBProcessInterrupt(*((_DWORD *)this + 3)))
  {
    if (DNBLogEnabled()) {
      _DNBLogThreaded("RNBRemote::HandlePacket_stop_process() sending extra stop reply because DNBProcessInterrupt returned false");
    }
    RNBRemote::HandlePacket_last_signal(this, v3);
  }

  return 0LL;
}

uint64_t RNBRemote::HandlePacket_A(RNBRemote *this, const char *a2, uint64_t a3, uint64_t a4, const char *a5)
{
  unint64_t v6 = a2;
  if (!a2 || !*a2)
  {
    int v8 = 1459;
    return RNBRemote::HandlePacket_ILLFORMED( this,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v8,  v6,  a5);
  }

  unint64_t v6 = a2 + 1;
  if (a2[1] < 1 || (_DefaultRuneLocale.__runetype[*((unsigned __int8 *)a2 + 1)] & 0x400) == 0)
  {
    int v8 = 1464;
    return RNBRemote::HandlePacket_ILLFORMED( this,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v8,  v6,  a5);
  }

  std::string::size_type v10 = a2 + 1;
  while (*v10)
  {
    memset(&v27, 0, sizeof(v27));
    std::string __endptr = 0LL;
    *__error() = 0;
    int64_t v11 = strtoul(v10, &__endptr, 10);
    if (*__error()) {
      BOOL v13 = v11 == 0;
    }
    else {
      BOOL v13 = 0;
    }
    if (v13)
    {
      __int128 v15 = this;
      int v16 = 1483;
    }

    else if (*__endptr == 44)
    {
      std::string::size_type v10 = __endptr + 1;
      *__error() = 0;
      unint64_t v14 = strtoul(v10, &__endptr, 10);
      if (!*__error() || v14)
      {
        if (*__endptr == 44)
        {
          BOOL v17 = __endptr + 1;
          std::string __endptr = v17;
          std::string::size_type v10 = &v17[v11];
          if (v11 >= 1)
          {
            do
            {
              char v20 = *v17;
              __int128 v21 = v17 + 1;
              if (!*v17 || v21 >= v10) {
                break;
              }
              char v23 = *v21;
              if (!*v21) {
                break;
              }
              __str[0] = v20;
              __str[1] = v23;
              __str[2] = 0;
              *__error() = 0;
              int v24 = strtoul(__str, 0LL, 16);
              if (*__error() && !v24)
              {
                __int128 v15 = this;
                int v16 = 1515;
                goto LABEL_40;
              }

              std::string::push_back(&v27, v24);
              BOOL v17 = (char *)(v21 + 1);
            }

            while (v21 + 1 < v10);
          }

          if ((v27.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            unsigned int v18 = &v27;
          }
          else {
            unsigned int v18 = (std::string *)v27.__r_.__value_.__r.__words[0];
          }
          RNBContext::PushArgument(this, (const char *)v18);
          if (*v10 == 44) {
            ++v10;
          }
          char v19 = 1;
LABEL_41:
          operator delete(v27.__r_.__value_.__l.__data_);
          goto LABEL_9;
        }

        __int128 v15 = this;
        int v16 = 1499;
      }

      else
      {
        __int128 v15 = this;
        int v16 = 1495;
      }
    }

    else
    {
      __int128 v15 = this;
      int v16 = 1487;
    }

uint64_t RNBRemote::HandlePacket_C(RNBRemote *this, const char *a2)
{
  int v3 = *((_DWORD *)this + 3);
  if (!v3)
  {
    __endptr.__r_.__value_.__s.__size_ = 3;
    LODWORD(__endptr.__r_.__value_.__l.__data_) = 3552069;
    uint64_t v9 = RNBRemote::SendPacket((uint64_t)this, &__endptr);
    std::string::size_type v10 = (void *)__endptr.__r_.__value_.__r.__words[0];
LABEL_24:
    operator delete(v10);
    return v9;
  }

  __int128 v18 = xmmword_100051E80;
  uint64_t v19 = -1LL;
  uint64_t v5 = a2 + 1;
  if (a2[1])
  {
    *(void *)&__int128 v18 = *((void *)this + 67);
    __endptr.__r_.__value_.__r.__words[0] = 0LL;
    *__error() = 0;
    int v6 = strtoul(v5, &__endptr.__r_.__value_.__l.__data_, 16);
    if (*__error())
    {
      int v8 = 4501;
      return RNBRemote::HandlePacket_ILLFORMED( this,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v8,  a2,  v7);
    }

    std::string::size_type v11 = __endptr.__r_.__value_.__r.__words[0];
    if (*__endptr.__r_.__value_.__l.__data_ == 59)
    {
      *__error() = 0;
      unint64_t v12 = strtoull((const char *)(v11 + 1), 0LL, 16);
      uint64_t v19 = v12;
      if (*__error())
      {
        if (!v12)
        {
          int v8 = 4507;
          return RNBRemote::HandlePacket_ILLFORMED( this,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v8,  a2,  v7);
        }
      }
    }
  }

  else
  {
    int v6 = -1;
  }

  DNBThreadResumeActions::DNBThreadResumeActions((DNBThreadResumeActions *)&__endptr);
  DNBThreadResumeActions::Append(&__endptr.__r_.__value_.__l.__data_, &v18);
  DNBThreadResumeActions::SetDefaultThreadActionIfNeeded(&__endptr.__r_.__value_.__l.__data_, 5, SHIDWORD(v18));
  if (DNBProcessSignal(v3, v6))
  {
    if (DNBProcessResume( v3,  __endptr.__r_.__value_.__l.__data_,  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(__endptr.__r_.__value_.__l.__size_ - __endptr.__r_.__value_.__r.__words[0]) >> 3)))
    {
      uint64_t v9 = 0LL;
      goto LABEL_20;
    }

    __p.__r_.__value_.__s.__size_ = 3;
    int v13 = 3683141;
  }

  else
  {
    __p.__r_.__value_.__s.__size_ = 3;
    int v13 = 3290437;
  }

  LODWORD(__p.__r_.__value_.__l.__data_) = v13;
  uint64_t v9 = RNBRemote::SendPacket((uint64_t)this, &__p);
LABEL_20:
  if (v17) {
    operator delete(v17);
  }
  std::string::size_type v10 = (void *)__endptr.__r_.__value_.__r.__words[0];
  if (__endptr.__r_.__value_.__r.__words[0])
  {
    __endptr.__r_.__value_.__l.__size_ = __endptr.__r_.__value_.__r.__words[0];
    goto LABEL_24;
  }

  return v9;
}

uint64_t RNBRemote::HandlePacket_D(RNBRemote *this, const char *a2)
{
  if (*((_DWORD *)this + 3))
  {
    if (DNBLogEnabled()) {
      _DNBLog( 0LL,  (uint64_t)"detaching from pid %u due to D packet",  v3,  v4,  v5,  v6,  v7,  v8,  *((unsigned int *)this + 3));
    }
    if (DNBProcessDetach(*((_DWORD *)this + 3)))
    {
      __p.__r_.__value_.__s.__size_ = 2;
      strcpy((char *)&__p, "OK");
      goto LABEL_9;
    }

    if (DNBLogEnabled()) {
      _DNBLog( 0LL,  (uint64_t)"error while detaching from pid %u due to D packet",  v9,  v10,  v11,  v12,  v13,  v14,  *((unsigned int *)this + 3));
    }
  }

  __p.__r_.__value_.__s.__size_ = 1;
  LOWORD(__p.__r_.__value_.__l.__data_) = 69;
LABEL_9:
  RNBRemote::SendPacket((uint64_t)this, &__p);
  return 0LL;
}

uint64_t RNBRemote::HandlePacket_k(RNBRemote *this, const char *a2)
{
  if (DNBLogEnabled()) {
    _DNBLog(0LL, (uint64_t)"Got a 'k' packet, killing the inferior process.", v3, v4, v5, v6, v7, v8, v11);
  }
  int v9 = *((_DWORD *)this + 3);
  if (v9) {
    DNBProcessKill(v9);
  }
  __p.__r_.__value_.__s.__size_ = 3;
  LODWORD(__p.__r_.__value_.__l.__data_) = 3747928;
  RNBRemote::SendPacket((uint64_t)this, &__p);
  return 0LL;
}

uint64_t RNBRemote::HandlePacket_T(RNBRemote *this, const char *a2, uint64_t a3, uint64_t a4, const char *a5)
{
  uint64_t v5 = (int *)this;
  uint64_t v6 = a2 + 1;
  if (!a2[1])
  {
    int v8 = 3944;
    return RNBRemote::HandlePacket_ILLFORMED( this,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v8,  v6,  a5);
  }

  if (*((_DWORD *)this + 3))
  {
    *__error() = 0;
    unint64_t v7 = strtoul(v6, 0LL, 16);
    if (*__error() && !v7)
    {
      this = (RNBRemote *)v5;
      int v8 = 3953;
      return RNBRemote::HandlePacket_ILLFORMED( this,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v8,  v6,  a5);
    }

    unsigned int State = DNBThreadGetState(v5[3], v7);
    if (State <= 9 && ((1 << State) & 0x281) != 0)
    {
      __p.__r_.__value_.__s.__size_ = 3;
      LODWORD(__p.__r_.__value_.__l.__data_) = 3551557;
    }

    else
    {
      __p.__r_.__value_.__s.__size_ = 2;
      strcpy((char *)&__p, "OK");
    }
  }

  else
  {
    __p.__r_.__value_.__s.__size_ = 3;
    LODWORD(__p.__r_.__value_.__l.__data_) = 3486021;
  }

  uint64_t v11 = RNBRemote::SendPacket((uint64_t)v5, &__p);
  return v11;
}

uint64_t RNBRemote::HandlePacket_qSupported(RNBRemote *this, const char *__big)
{
  uint64_t v3 = strstr(__big, "amx+");
  if (v3) {
    DNBArchProtocol::EnableAMXRegisters((DNBArchProtocol *)v3);
  }
  snprintf(__str, 0x100uLL, "qXfer:features:read+;PacketSize=%x;qEcho+;native-signals+", 0x20000);
  strcat(__str, ";SupportedCompressions=lzfse,zlib-deflate,lz4,lzma;DefaultCompressionMinSize=");
  snprintf((char *)&__s2, 0x10uLL, "%zu", *((void *)this + 98));
  __s2.__r_.__value_.__s.__data_[15] = 0;
  strcat(__str, (const char *)&__s2);
  size_t v4 = strlen(__str);
  if (v4 >= 0x7FFFFFFFFFFFFFF8LL) {
    abort();
  }
  std::string::size_type v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    p_s2 = (std::string *)operator new(v7 + 1);
    __s2.__r_.__value_.__l.__size_ = v5;
    __s2.__r_.__value_.__l.__cap_ = v8 | 0x8000000000000000LL;
    __s2.__r_.__value_.__r.__words[0] = (std::string::size_type)p_s2;
    goto LABEL_10;
  }

  __s2.__r_.__value_.__s.__size_ = v4;
  p_s2 = &__s2;
  if (v4) {
LABEL_10:
  }
    memcpy(p_s2, __str, v5);
  p_s2->__r_.__value_.__s.__data_[v5] = 0;
  uint64_t v9 = RNBRemote::SendPacket((uint64_t)this, &__s2);
  return v9;
}

uint64_t RNBRemote::HandlePacket_v(int8x16_t **this, const char *__s1)
{
    return RNBRemote::HandlePacket_c((RNBRemote *)this, "c");
  if (!strcmp(__s1, "vCont;s")) {
    return RNBRemote::HandlePacket_s((RNBRemote *)this, v4);
  }
  if (strncmp(__s1, "vCont", 5uLL))
  {
    if (strncmp(__s1, "vAttach", 7uLL)) {
      return RNBRemote::HandlePacket_UNIMPLEMENTED((RNBRemote *)this, __s1);
    }
    bzero(__s, 0x400uLL);
    memset(&__p, 0, sizeof(__p));
    if (!strncmp(__s1, "vAttachWait;", 0xCuLL))
    {
      int v18 = *((unsigned __int8 *)__s1 + 12);
      BOOL v17 = (char *)(__s1 + 12);
      std::string::value_type v16 = v18;
      __int128 v118 = v17;
      if (!v18)
      {
LABEL_42:
        if (DNBLogEnabled())
        {
          uint64_t v23 = getpid();
          _DNBLog( 0LL,  (uint64_t)"[LaunchAttach] START %d vAttachWait for process name '%s'",  v24,  v25,  v26,  v27,  v28,  v29,  v23);
        }

        if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          p_p = &__p;
        }
        else {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        uint64_t v31 = DNBProcessAttachWait( (RNBContext *)this,  (char *)p_p,  1,  0LL,  0x3E8u,  __s,  0x400uLL,  (unsigned int (*)(void *))RNBRemoteShouldCancelCallback,  0LL);
        goto LABEL_61;
      }

      while (1)
      {
        __endptr.__r_.__value_.__s.__data_[0] = v16;
        *(_WORD *)((char *)&__endptr.__r_.__value_.__l.__data_ + 1) = v17[1];
        *__error() = 0;
        int v19 = strtoul((const char *)&__endptr, 0LL, 16);
        if (*__error() && v19 == 0LL) {
          break;
        }
        std::string::push_back(&__p, v19);
        int v22 = v17[2];
        v17 += 2;
        std::string::value_type v16 = v22;
        if (!v22)
        {
          __int128 v118 = v17;
          goto LABEL_42;
        }
      }

      int v65 = (RNBRemote *)this;
      int v66 = 3770;
    }

    else
    {
      if (strncmp(__s1, "vAttachOrWait;", 0xEuLL))
      {
        if (strncmp(__s1, "vAttachName;", 0xCuLL))
        {
          if (strncmp(__s1, "vAttach;", 8uLL))
          {
            uint64_t v9 = RNBRemote::HandlePacket_UNIMPLEMENTED((RNBRemote *)this, __s1);
            goto LABEL_132;
          }

          unint64_t v67 = __s1 + 8;
          __int128 v118 = (char *)(__s1 + 8);
          v113.__r_.__value_.__r.__words[0] = 0LL;
          unint64_t v46 = strtoul(__s1 + 8, &v113.__r_.__value_.__l.__data_, 16);
          if (v67 == v113.__r_.__value_.__l.__data_ || *v113.__r_.__value_.__l.__data_)
          {
            uint64_t v45 = 0LL;
          }

          else
          {
            gettimeofday((timeval *)&__endptr, 0LL);
            v115.__r_.__value_.__r.__words[0] = __endptr.__r_.__value_.__r.__words[0]
                                              + SLODWORD(__endptr.__r_.__value_.__r.__words[1]) / 1000000
                                              + 30;
            v115.__r_.__value_.__l.__size_ = 1000 * LODWORD(__endptr.__r_.__value_.__r.__words[1]) % 1000000000;
            if (DNBLogEnabled())
            {
              uint64_t v101 = getpid();
              _DNBLog( 0LL,  (uint64_t)"[LaunchAttach] START %d vAttach to pid %d",  v102,  v103,  v104,  v105,  v106,  v107,  v101);
            }

            uint64_t v45 = DNBProcessAttach(v46, (const timespec *)&v115, this + 56, __s, 0x400uLL);
          }

LABEL_62:
          if ((_DWORD)v45)
          {
            if ((_DWORD)v45 == -1)
            {
              if (DNBLogEnabled()) {
                _DNBLogError("debugserver is x86_64 binary running in translation, attach failed.");
              }
              std::string::basic_string[abi:nn180100]<0>(&__endptr, "E96;");
              cstring_to_asciihex_string("debugserver is x86_64 binary running in translation, attach failed.", &v115);
              if ((v115.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                __int128 v47 = &v115;
              }
              else {
                __int128 v47 = (std::string *)v115.__r_.__value_.__r.__words[0];
              }
              if ((v115.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                std::string::size_type size = v115.__r_.__value_.__s.__size_;
              }
              else {
                std::string::size_type size = v115.__r_.__value_.__l.__size_;
              }
              std::string::append(&__endptr, (const std::string::value_type *)v47, size);
              if ((__endptr.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                p_endptr = &__endptr;
              }
              else {
                p_endptr = (std::string *)__endptr.__r_.__value_.__r.__words[0];
              }
              std::string::basic_string[abi:nn180100]<0>(&v115, (char *)p_endptr);
              RNBRemote::SendPacket((uint64_t)this, &v115);
              goto LABEL_78;
            }

            if (*((_DWORD *)this + 3) != (_DWORD)v45) {
              RNBContext::SetProcessID((RNBContext *)this, v45);
            }
            if (DNBLogEnabled()) {
              _DNBLog(0LL, (uint64_t)"Successfully attached to pid %d", v51, v52, v53, v54, v55, v56, v45);
            }
            RNBRemote::HandlePacket_last_signal((RNBRemote *)this, v50);
            uint64_t v9 = 0LL;
LABEL_132:
            if ((char)__p.__r_.__value_.__s.__size_ < 0)
            {
              __int128 v15 = (void *)__p.__r_.__value_.__r.__words[0];
LABEL_134:
              operator delete(v15);
            }

            return v9;
          }

          if (DNBLogEnabled()) {
            _DNBLogError("Attach failed");
          }
          this[39] = (int8x16_t *)0xFFFFFFFFLL;
          if (*((char *)this + 343) < 0)
          {
            this[40]->i8[0] = 0;
            this[41] = 0LL;
          }

          else
          {
            *((_BYTE *)this + 320) = 0;
            *((_BYTE *)this + 343) = 0;
          }

          if (__s[0]) {
            __int128 v70 = __s;
          }
          else {
            __int128 v70 = "attach failed";
          }
          DNBError::SetErrorString((std::string *)this + 13, v70);
          if (!(_DWORD)v46)
          {
            if ((char)__p.__r_.__value_.__s.__size_ < 0)
            {
              if (!__p.__r_.__value_.__l.__size_) {
                goto LABEL_183;
              }
              unint64_t v74 = (std::string *)__p.__r_.__value_.__r.__words[0];
            }

            else
            {
              if (!__p.__r_.__value_.__s.__size_) {
                goto LABEL_183;
              }
              unint64_t v74 = &__p;
            }

            LODWORD(vmemset(v10, 0, 46) = DNBProcessGetPIDByName((char *)v74);
            if (!(_DWORD)v46) {
              goto LABEL_183;
            }
          }

          if (process_does_not_exist(v46))
          {
            if (DNBLogEnabled()) {
              _DNBLogError("Tried to attach to pid that doesn't exist");
            }
            std::string::basic_string[abi:nn180100]<0>(&__endptr, "E96;");
            uint64_t v71 = "no such process.";
LABEL_121:
            cstring_to_asciihex_string(v71, &v115);
            if ((v115.__r_.__value_.__s.__size_ & 0x80u) == 0) {
              BOOL v72 = &v115;
            }
            else {
              BOOL v72 = (std::string *)v115.__r_.__value_.__r.__words[0];
            }
            if ((v115.__r_.__value_.__s.__size_ & 0x80u) == 0) {
              std::string::size_type v73 = v115.__r_.__value_.__s.__size_;
            }
            else {
              std::string::size_type v73 = v115.__r_.__value_.__l.__size_;
            }
            std::string::append(&__endptr, (const std::string::value_type *)v72, v73);
            uint64_t v9 = RNBRemote::SendPacket((uint64_t)this, &__endptr);
            goto LABEL_130;
          }

          if (process_is_already_being_debugged(v46))
          {
            if (DNBLogEnabled()) {
              _DNBLogError("Tried to attach to process already being debugged");
            }
            std::string::basic_string[abi:nn180100]<0>(&__endptr, "E96;");
            uint64_t v71 = "tried to attach to process already being debugged";
            goto LABEL_121;
          }

          *(void *)__val = 0LL;
          if (attach_failed_due_to_uid_mismatch(v46, &__val[1], __val))
          {
            uid_t v75 = __val[1];
            std::to_string(&v115, __val[1]);
            __int128 v76 = std::string::insert(&v115, 0LL, "uid ");
            std::string::size_type cap = v76->__r_.__value_.__l.__cap_;
            *(_OWORD *)&__endptr.__r_.__value_.__l.__data_ = *(_OWORD *)&v76->__r_.__value_.__l.__data_;
            __endptr.__r_.__value_.__l.__cap_ = cap;
            v76->__r_.__value_.__l.__size_ = 0LL;
            v76->__r_.__value_.__l.__cap_ = 0LL;
            v76->__r_.__value_.__r.__words[0] = 0LL;
            uid_t v78 = __val[0];
            std::to_string(&v113, __val[0]);
            uint64_t v79 = std::string::insert(&v113, 0LL, "uid ");
            std::string::size_type v80 = v79->__r_.__value_.__l.__cap_;
            *(_OWORD *)&v115.__r_.__value_.__l.__data_ = *(_OWORD *)&v79->__r_.__value_.__l.__data_;
            v115.__r_.__value_.__l.__cap_ = v80;
            v79->__r_.__value_.__l.__size_ = 0LL;
            v79->__r_.__value_.__l.__cap_ = 0LL;
            v79->__r_.__value_.__r.__words[0] = 0LL;
            unint64_t v81 = getpwuid(v75);
            if (v81 && v81->pw_name) {
              std::string::assign(&__endptr, v81->pw_name);
            }
            __int128 v82 = getpwuid(v78);
            if (v82 && v82->pw_name) {
              std::string::assign(&v115, v82->pw_name);
            }
            if (DNBLogEnabled()) {
              _DNBLogError("Tried to attach to process with uid mismatch");
            }
            std::string::basic_string[abi:nn180100]<0>(&v113, "E96;");
            std::operator+<char>(&v108, "tried to attach to process as user '", &__endptr);
            __int128 v83 = std::string::append(&v108, "' and process is running as user '");
            std::string::size_type v84 = v83->__r_.__value_.__l.__cap_;
            *(_OWORD *)&v109.__r_.__value_.__l.__data_ = *(_OWORD *)&v83->__r_.__value_.__l.__data_;
            v109.__r_.__value_.__l.__cap_ = v84;
            v83->__r_.__value_.__l.__size_ = 0LL;
            v83->__r_.__value_.__l.__cap_ = 0LL;
            v83->__r_.__value_.__r.__words[0] = 0LL;
            if ((v115.__r_.__value_.__s.__size_ & 0x80u) == 0) {
              uint64_t v85 = &v115;
            }
            else {
              uint64_t v85 = (std::string *)v115.__r_.__value_.__r.__words[0];
            }
            if ((v115.__r_.__value_.__s.__size_ & 0x80u) == 0) {
              std::string::size_type v86 = v115.__r_.__value_.__s.__size_;
            }
            else {
              std::string::size_type v86 = v115.__r_.__value_.__l.__size_;
            }
            int v87 = std::string::append(&v109, (const std::string::value_type *)v85, v86);
            std::string::size_type v88 = v87->__r_.__value_.__l.__cap_;
            *(_OWORD *)&v110.__r_.__value_.__l.__data_ = *(_OWORD *)&v87->__r_.__value_.__l.__data_;
            v110.__r_.__value_.__l.__cap_ = v88;
            v87->__r_.__value_.__l.__size_ = 0LL;
            v87->__r_.__value_.__l.__cap_ = 0LL;
            v87->__r_.__value_.__r.__words[0] = 0LL;
            __int128 v89 = std::string::append(&v110, "'");
            std::string::size_type v90 = v89->__r_.__value_.__l.__cap_;
            *(_OWORD *)__int128 v111 = *(_OWORD *)&v89->__r_.__value_.__l.__data_;
            int64_t v112 = v90;
            v89->__r_.__value_.__l.__size_ = 0LL;
            v89->__r_.__value_.__l.__cap_ = 0LL;
            v89->__r_.__value_.__r.__words[0] = 0LL;
            if ((char)v110.__r_.__value_.__s.__size_ < 0)
            {
              operator delete(v110.__r_.__value_.__l.__data_);
              if (((char)v109.__r_.__value_.__s.__size_ & 0x80000000) == 0)
              {
LABEL_160:
LABEL_218:
                operator delete(v108.__r_.__value_.__l.__data_);
LABEL_161:
                if (v112 >= 0) {
                  __int128 v91 = v111;
                }
                else {
                  __int128 v91 = (void **)v111[0];
                }
                cstring_to_asciihex_string((const char *)v91, &v110);
                if ((v110.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                  uint64_t v92 = &v110;
                }
                else {
                  uint64_t v92 = (std::string *)v110.__r_.__value_.__r.__words[0];
                }
                if ((v110.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                  std::string::size_type v93 = v110.__r_.__value_.__s.__size_;
                }
                else {
                  std::string::size_type v93 = v110.__r_.__value_.__l.__size_;
                }
                std::string::append(&v113, (const std::string::value_type *)v92, v93);
                uint64_t v9 = RNBRemote::SendPacket((uint64_t)this, &v113);
                if (SHIBYTE(v112) < 0)
                {
                  operator delete(v111[0]);
                  if (((char)v113.__r_.__value_.__s.__size_ & 0x80000000) == 0)
                  {
LABEL_174:
LABEL_221:
                    operator delete(v115.__r_.__value_.__l.__data_);
LABEL_130:
                    goto LABEL_132;
                  }
                }

                else if (((char)v113.__r_.__value_.__s.__size_ & 0x80000000) == 0)
                {
                  goto LABEL_174;
                }

                operator delete(v113.__r_.__value_.__l.__data_);
                goto LABEL_221;
              }
            }

            else if (((char)v109.__r_.__value_.__s.__size_ & 0x80000000) == 0)
            {
              goto LABEL_160;
            }

            operator delete(v109.__r_.__value_.__l.__data_);
            goto LABEL_218;
          }

LABEL_183:
          std::string::basic_string[abi:nn180100]<0>(&__endptr, "attach failed");
          if (__s[0])
          {
            if (*(void *)__s == 0x7420656C62616E75LL
              && *(void *)&__s[8] == 0x207472617473206FLL
              && *(void *)&__s[16] == 0x6563786520656874LL
              && *(void *)&__s[24] == 0x6874206E6F697470LL
              && *(void *)&__s[29] == 0x64616572687420LL)
            {
              strcpy( __s,  "Not allowed to attach to process.  Look in the console messages (Console.app), near the debugserver entr ies, when the attach failed.  The subsystem that denied the attach permission will likely have logged an informative message about why it was denied.");
              __s[1023] = 0;
            }

            std::string::append(&__endptr, " (");
            std::string::append(&__endptr, __s);
            std::string::append(&__endptr, ")");
          }

          std::string::basic_string[abi:nn180100]<0>(&v115, "E96;");
          if ((__endptr.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            __int128 v98 = &__endptr;
          }
          else {
            __int128 v98 = (std::string *)__endptr.__r_.__value_.__r.__words[0];
          }
          cstring_to_asciihex_string((const char *)v98, &v113);
          if ((v113.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            uint64_t v99 = &v113;
          }
          else {
            uint64_t v99 = (std::string *)v113.__r_.__value_.__r.__words[0];
          }
          if ((v113.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            std::string::size_type v100 = v113.__r_.__value_.__s.__size_;
          }
          else {
            std::string::size_type v100 = v113.__r_.__value_.__l.__size_;
          }
          std::string::append(&v115, (const std::string::value_type *)v99, v100);
          RNBRemote::SendPacket((uint64_t)this, &v115);
          if (DNBLogEnabled()) {
            _DNBLogError("Attach failed: %s.", __s);
          }
LABEL_78:
          if ((char)v115.__r_.__value_.__s.__size_ < 0)
          {
            operator delete(v115.__r_.__value_.__l.__data_);
          }

          else if (((char)__endptr.__r_.__value_.__s.__size_ & 0x80000000) == 0)
          {
LABEL_80:
            uint64_t v9 = 1LL;
            goto LABEL_132;
          }

          operator delete(__endptr.__r_.__value_.__l.__data_);
          goto LABEL_80;
        }

        __int128 v118 = (char *)(__s1 + 12);
        if ((GetProcessNameFrom_vAttach(&v118, &__p) & 1) != 0)
        {
          if (DNBLogEnabled())
          {
            uint64_t v57 = getpid();
            _DNBLog( 0LL,  (uint64_t)"[LaunchAttach] START %d vAttachName attach to process name '%s'",  v58,  v59,  v60,  v61,  v62,  v63,  v57);
          }

          if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            uint64_t v64 = &__p;
          }
          else {
            uint64_t v64 = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          uint64_t v31 = DNBProcessAttachByName((char *)v64, 0LL, this + 56, __s, 0x400uLL);
LABEL_61:
          uint64_t v45 = v31;
          LODWORD(vmemset(v10, 0, 46) = 0;
          goto LABEL_62;
        }

        __int128 v69 = v118;
        int v65 = (RNBRemote *)this;
        int v66 = 3797;
LABEL_107:
        uint64_t v9 = RNBRemote::HandlePacket_ILLFORMED( v65,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v66,  v69,  v20);
        goto LABEL_132;
      }

      int v33 = *((unsigned __int8 *)__s1 + 14);
      BOOL v17 = (char *)(__s1 + 14);
      std::string::value_type v32 = v33;
      __int128 v118 = v17;
      if (!v33)
      {
LABEL_55:
        if (DNBLogEnabled())
        {
          uint64_t v37 = getpid();
          _DNBLog( 0LL,  (uint64_t)"[LaunchAttach] START %d vAttachWaitOrWait for process name '%s'",  v38,  v39,  v40,  v41,  v42,  v43,  v37);
        }

        if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          __int128 v44 = &__p;
        }
        else {
          __int128 v44 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        uint64_t v31 = DNBProcessAttachWait( (RNBContext *)this,  (char *)v44,  0,  0LL,  0x3E8u,  __s,  0x400uLL,  (unsigned int (*)(void *))RNBRemoteShouldCancelCallback,  0LL);
        goto LABEL_61;
      }

      while (1)
      {
        __endptr.__r_.__value_.__s.__data_[0] = v32;
        *(_WORD *)((char *)&__endptr.__r_.__value_.__l.__data_ + 1) = v17[1];
        *__error() = 0;
        int v34 = strtoul((const char *)&__endptr, 0LL, 16);
        if (*__error() && v34 == 0LL) {
          break;
        }
        std::string::push_back(&__p, v34);
        int v36 = v17[2];
        v17 += 2;
        std::string::value_type v32 = v36;
        if (!v36)
        {
          __int128 v118 = v17;
          goto LABEL_55;
        }
      }

      int v65 = (RNBRemote *)this;
      int v66 = 3783;
    }

    __int128 v69 = v17;
    goto LABEL_107;
  }

  DNBThreadResumeActions::DNBThreadResumeActions((DNBThreadResumeActions *)__s);
  uint64_t v6 = __s1 + 5;
  __int128 v118 = (char *)(__s1 + 5);
  __endptr.__r_.__value_.__r.__words[0] = (std::string::size_type)(__s1 + 5);
  int64_t v7 = strlen(__s1 + 5);
  if (__s1[5] == 63)
  {
    __p.__r_.__value_.__s.__size_ = 13;
    strcpy((char *)&__p, "vCont;c;C;s;S");
    uint64_t v9 = RNBRemote::SendPacket((uint64_t)this, &__p);
    if ((char)__p.__r_.__value_.__s.__size_ < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
      uint64_t v10 = *(void **)&__s[24];
      if (!*(void *)&__s[24]) {
        goto LABEL_33;
      }
LABEL_32:
      operator delete(v10);
      goto LABEL_33;
    }

uint64_t RNBRemote::HandlePacket_x(RNBRemote *this, const char *__s, uint64_t a3, uint64_t a4, const char *a5)
{
  if (!__s || !*__s || strlen(__s) <= 2)
  {
    int64_t v7 = this;
    int v8 = 3162;
    uint64_t v9 = __s;
    return RNBRemote::HandlePacket_ILLFORMED( v7,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v8,  v9,  a5);
  }

  std::string __endptr = 0LL;
  uint64_t v11 = __s + 1;
  *__error() = 0;
  mach_vm_address_t v12 = strtoull(__s + 1, &__endptr, 16);
  if (*__error())
  {
    int64_t v7 = this;
    int v8 = 3170;
LABEL_12:
    uint64_t v9 = v11;
    return RNBRemote::HandlePacket_ILLFORMED( v7,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v8,  v9,  a5);
  }

  if (*__endptr != 44)
  {
    int64_t v7 = this;
    int v8 = 3174;
    goto LABEL_12;
  }

  uint64_t v11 = __endptr + 1;
  *__error() = 0;
  size_t v13 = strtoul(v11, 0LL, 16);
  if (*__error())
  {
    int64_t v7 = this;
    int v8 = 3184;
    goto LABEL_12;
  }

  if (v13)
  {
    std::vector<unsigned char>::vector(&v75, v13);
    if (v77 - (void)v75 == v13)
    {
      unint64_t v14 = DNBProcessMemoryRead(*((_DWORD *)this + 3), v12, v76 - v75, v75);
      if (v14)
      {
        unint64_t v15 = v14;
        BOOL v72 = 0LL;
        std::string::size_type v73 = 0LL;
        unint64_t v74 = 0LL;
        std::vector<unsigned char>::reserve((uint64_t)&v72, v14 + 30);
        uint64_t v16 = 0LL;
        while (1)
        {
          unsigned int v17 = v75[v16];
          BOOL v18 = v17 > 0x2A || ((1LL << v17) & 0x41800000000LL) == 0;
          if (v18 && v17 != 125)
          {
            std::vector<unsigned char>::push_back[abi:nn180100](&v72, &v75[v16]);
            goto LABEL_18;
          }

          int v19 = v73;
          if (v73 >= v74) {
            break;
          }
          *std::string::size_type v73 = 125;
          char v20 = v19 + 1;
LABEL_56:
          std::string::size_type v73 = v20;
          char v39 = v75[v16] ^ 0x20;
          if (v20 >= v74)
          {
            uint64_t v40 = v72;
            unint64_t v41 = v20 - v72;
            uint64_t v42 = v20 - v72 + 1;
            if (v42 < 0) {
LABEL_108:
            }
              abort();
            unint64_t v43 = v74 - v72;
            if (v43 >= 0x3FFFFFFFFFFFFFFFLL) {
              size_t v44 = 0x7FFFFFFFFFFFFFFFLL;
            }
            else {
              size_t v44 = v42;
            }
            if (v44) {
              uint64_t v45 = (char *)operator new(v44);
            }
            else {
              uint64_t v45 = 0LL;
            }
            unint64_t v46 = &v45[v41];
            __int128 v47 = &v45[v44];
            v45[v41] = v39;
            uint64_t v48 = (uint64_t)&v45[v41 + 1];
            if (v20 == v40)
            {
              BOOL v72 = &v45[v41];
              std::string::size_type v73 = &v45[v41 + 1];
              unint64_t v74 = v47;
            }

            else
            {
              if (v41 < 8 || (unint64_t)(v40 - v45) < 0x20)
              {
                __int128 v49 = v20;
                goto LABEL_70;
              }

              if (v41 >= 0x20)
              {
                unint64_t v52 = v41 & 0xFFFFFFFFFFFFFFE0LL;
                uint64_t v53 = &v45[v41 - 16];
                uint64_t v54 = (__int128 *)(v20 - 16);
                unint64_t v55 = v41 & 0xFFFFFFFFFFFFFFE0LL;
                do
                {
                  __int128 v56 = *v54;
                  *((_OWORD *)v53 - 1) = *(v54 - 1);
                  *(_OWORD *)uint64_t v53 = v56;
                  v53 -= 32;
                  v54 -= 2;
                  v55 -= 32LL;
                }

                while (v55);
                if (v41 != v52)
                {
                  if ((v41 & 0x18) == 0)
                  {
                    v46 -= v52;
                    __int128 v49 = &v20[-v52];
                    goto LABEL_70;
                  }

                  goto LABEL_83;
                }
              }

              else
              {
                unint64_t v52 = 0LL;
LABEL_83:
                __int128 v49 = &v20[-(v41 & 0xFFFFFFFFFFFFFFF8LL)];
                v46 -= v41 & 0xFFFFFFFFFFFFFFF8LL;
                uint64_t v57 = &v45[&v20[-v52] - v40 - 8];
                uint64_t v58 = (uint64_t *)&v20[-v52 - 8];
                unint64_t v59 = v52 - (v41 & 0xFFFFFFFFFFFFFFF8LL);
                do
                {
                  uint64_t v60 = *v58--;
                  *(void *)uint64_t v57 = v60;
                  v57 -= 8;
                  v59 += 8LL;
                }

                while (v59);
                if (v41 != (v41 & 0xFFFFFFFFFFFFFFF8LL))
                {
LABEL_70:
                  uint64_t v50 = v46 - 1;
                  do
                  {
                    char v51 = *--v49;
                    *v50-- = v51;
                  }

                  while (v49 != v40);
                }
              }

              char v20 = v72;
              BOOL v72 = v45;
              std::string::size_type v73 = &v45[v41 + 1];
              unint64_t v74 = v47;
              if (!v20)
              {
LABEL_76:
                std::string::size_type v73 = (char *)v48;
                goto LABEL_18;
              }
            }

            operator delete(v20);
            goto LABEL_76;
          }

          *char v20 = v39;
          std::string::size_type v73 = v20 + 1;
LABEL_18:
          if (++v16 == v15)
          {
            int v65 = v72;
            uint64_t v64 = v73;
            std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v71);
            unint64_t v66 = v64 - v65;
            if (v64 != v65)
            {
              uint64_t v67 = 0LL;
              if (v66 <= 1) {
                uint64_t v68 = 1LL;
              }
              else {
                uint64_t v68 = v66;
              }
              do
              {
                __p.__r_.__value_.__s.__data_[0] = v72[v67];
                std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v71, (uint64_t)&__p, 1LL);
                ++v67;
              }

              while (v68 != v67);
            }

            std::stringbuf::str(&__p, (const std::stringbuf *)&v71[0].__r_.__value_.__r.__words[1]);
            uint64_t v61 = RNBRemote::SendPacket((uint64_t)this, &__p);
            std::ostringstream::~ostringstream((uint64_t)v71);
            __int128 v69 = v72;
            if (v72)
            {
              std::string::size_type v73 = v72;
              goto LABEL_103;
            }

            goto LABEL_104;
          }
        }

        __int128 v21 = v72;
        unint64_t v22 = v73 - v72;
        uint64_t v23 = v73 - v72 + 1;
        if (v23 < 0) {
          goto LABEL_108;
        }
        unint64_t v24 = v74 - v72;
        if (v24 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v25 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v25 = v23;
        }
        if (v25) {
          uint64_t v26 = (char *)operator new(v25);
        }
        else {
          uint64_t v26 = 0LL;
        }
        uint64_t v27 = &v26[v22];
        v26[v22] = 125;
        char v20 = &v26[v22 + 1];
        if (v19 == v21)
        {
LABEL_54:
          BOOL v72 = v27;
          std::string::size_type v73 = &v26[v22 + 1];
          unint64_t v74 = &v26[v25];
          if (v19) {
            operator delete(v19);
          }
          goto LABEL_56;
        }

        if (v22 >= 8 && (unint64_t)(v21 - v26) >= 0x20)
        {
          if (v22 < 0x20)
          {
            unint64_t v28 = 0LL;
            goto LABEL_46;
          }

          unint64_t v28 = v22 & 0xFFFFFFFFFFFFFFE0LL;
          uint64_t v29 = &v26[v22 - 16];
          __int128 v30 = v19 - 16;
          unint64_t v31 = v22 & 0xFFFFFFFFFFFFFFE0LL;
          do
          {
            __int128 v32 = *(_OWORD *)v30;
            *((_OWORD *)v29 - 1) = *((_OWORD *)v30 - 1);
            *(_OWORD *)uint64_t v29 = v32;
            v29 -= 32;
            v30 -= 32;
            v31 -= 32LL;
          }

          while (v31);
          if (v22 == v28) {
            goto LABEL_53;
          }
          if ((v22 & 0x18) != 0)
          {
LABEL_46:
            v27 -= v22 & 0xFFFFFFFFFFFFFFF8LL;
            int v33 = &v26[&v19[-v28] - v21 - 8];
            int v34 = &v19[-v28 - 8];
            unint64_t v35 = v28 - (v22 & 0xFFFFFFFFFFFFFFF8LL);
            do
            {
              uint64_t v36 = *(void *)v34;
              v34 -= 8;
              *(void *)int v33 = v36;
              v33 -= 8;
              v35 += 8LL;
            }

            while (v35);
            v19 -= v22 & 0xFFFFFFFFFFFFFFF8LL;
            if (v22 == (v22 & 0xFFFFFFFFFFFFFFF8LL)) {
              goto LABEL_53;
            }
            goto LABEL_51;
          }

          v27 -= v28;
          v19 -= v28;
        }

LABEL_104:
    uint64_t v62 = v75;
    if (v75)
    {
      __int128 v76 = v75;
      goto LABEL_106;
    }
  }

  else
  {
    std::string::basic_string[abi:nn180100]<0>(v71, "OK");
    uint64_t v61 = RNBRemote::SendPacket((uint64_t)this, v71);
    if ((char)v71[0].__r_.__value_.__s.__size_ < 0)
    {
      uint64_t v62 = (char *)v71[0].__r_.__value_.__r.__words[0];
LABEL_106:
      operator delete(v62);
    }
  }

  return v61;
}

uint64_t RNBRemote::HandlePacket_X(RNBRemote *this, const char *__s, uint64_t a3, uint64_t a4, const char *a5)
{
  std::string::size_type v5 = __s;
  if (!__s || !*__s || strlen(__s) <= 2)
  {
    int64_t v7 = this;
    int v8 = 3226;
    return RNBRemote::HandlePacket_ILLFORMED( v7,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v8,  v5,  a5);
  }

  std::string __endptr = 0LL;
  ++v5;
  *__error() = 0;
  unint64_t v10 = strtoull(v5, &__endptr, 16);
  if (*__error() && !v10)
  {
    int64_t v7 = this;
    int v8 = 3234;
    return RNBRemote::HandlePacket_ILLFORMED( v7,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v8,  v5,  a5);
  }

  uint64_t v11 = __endptr;
  if (*__endptr != 44)
  {
    int64_t v7 = this;
    int v8 = 3238;
    return RNBRemote::HandlePacket_ILLFORMED( v7,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v8,  v5,  a5);
  }

  std::string::size_type v5 = __endptr + 1;
  *__error() = 0;
  unint64_t v12 = strtoul(v11 + 1, 0LL, 16);
  if (*__error() && !v12)
  {
    int64_t v7 = this;
    int v8 = 3252;
    return RNBRemote::HandlePacket_ILLFORMED( v7,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v8,  v5,  a5);
  }

  if (v12)
  {
    decode_binary_data(v11, 0xFFFFFFFFFFFFFFFFLL, (unint64_t *)&v35);
    __int128 v13 = *(_OWORD *)&v35.__r_.__value_.__l.__data_;
    __chkstk_darwin(v14);
    uint64_t v16 = (char *)&v34 - v15;
    bzero((char *)&v34 - v15, v17);
    unint64_t v18 = *((void *)&v13 + 1) - v13;
    if (*((void *)&v13 + 1) == (void)v13) {
      goto LABEL_32;
    }
    int v19 = v16;
    char v20 = (char *)v13;
    if (v18 < 8) {
      goto LABEL_31;
    }
    int v19 = v16;
    char v20 = (char *)v13;
    if (v18 >= 0x20)
    {
      unint64_t v21 = v18 & 0xFFFFFFFFFFFFFFE0LL;
      unint64_t v24 = (__int128 *)(v13 + 16);
      size_t v25 = v16 + 16;
      unint64_t v26 = v18 & 0xFFFFFFFFFFFFFFE0LL;
      do
      {
        __int128 v27 = *v24;
        *(v25 - 1) = *(v24 - 1);
        *size_t v25 = v27;
        v24 += 2;
        v25 += 2;
        v26 -= 32LL;
      }

      while (v26);
      if (v18 == v21)
      {
LABEL_32:
        if (DNBProcessMemoryWrite(*((_DWORD *)this + 3), v10, *((void *)&v13 + 1) - v13, v16) == v18) {
          int v33 = "OK";
        }
        else {
          int v33 = "E08";
        }
        std::string::basic_string[abi:nn180100]<0>(&v34, v33);
        uint64_t v22 = RNBRemote::SendPacket((uint64_t)this, &v34);
        if (!(void)v13) {
          return v22;
        }
        uint64_t v23 = (void *)v13;
        goto LABEL_39;
      }

      if ((v18 & 0x18) == 0)
      {
        char v20 = (char *)(v13 + v21);
        int v19 = &v16[v21];
        goto LABEL_31;
      }
    }

    else
    {
      unint64_t v21 = 0LL;
    }

    int v19 = &v16[v18 & 0xFFFFFFFFFFFFFFF8LL];
    char v20 = (char *)(v13 + (v18 & 0xFFFFFFFFFFFFFFF8LL));
    unint64_t v28 = (uint64_t *)(v13 + v21);
    uint64_t v29 = &v16[v21];
    unint64_t v30 = v21 - (v18 & 0xFFFFFFFFFFFFFFF8LL);
    do
    {
      uint64_t v31 = *v28++;
      *(void *)uint64_t v29 = v31;
      v29 += 8;
      v30 += 8LL;
    }

    while (v30);
    if (v18 == (v18 & 0xFFFFFFFFFFFFFFF8LL)) {
      goto LABEL_32;
    }
    do
    {
LABEL_31:
      char v32 = *v20++;
      *v19++ = v32;
    }

    while (v20 != *((char **)&v13 + 1));
    goto LABEL_32;
  }

  std::string::basic_string[abi:nn180100]<0>(&v35, "OK");
  uint64_t v22 = RNBRemote::SendPacket((uint64_t)this, &v35);
  if ((char)v35.__r_.__value_.__s.__size_ < 0)
  {
    uint64_t v23 = (void *)v35.__r_.__value_.__r.__words[0];
LABEL_39:
    operator delete(v23);
  }

  return v22;
}

uint64_t RNBRemote::HandlePacket_qRcmd(RNBRemote *this, const char *a2)
{
  LOBYTE(v3) = a2[6];
  if ((_BYTE)v3)
  {
    std::string::size_type v5 = a2 + 8;
    while (1)
    {
      unsigned __int8 v6 = *(v5 - 1);
      if (!v6)
      {
        __str.__r_.__value_.__s.__size_ = 3;
        strcpy((char *)&__str, "E73");
        uint64_t v14 = RNBRemote::SendPacket((uint64_t)this, &__str);
        goto LABEL_27;
      }

      __str.__r_.__value_.__s.__data_[0] = v3;
      *(_WORD *)((char *)&__str.__r_.__value_.__l.__data_ + 1) = v6;
      *__error() = 0;
      int v7 = strtoul((const char *)&__str, 0LL, 16);
      BOOL v9 = *__error() && v7 == 0LL;
      if (v9) {
        break;
      }
      std::string::push_back(&v52, v7);
      int v3 = *(unsigned __int8 *)v5;
      v5 += 2;
      if (!v3) {
        goto LABEL_9;
      }
    }

    uint64_t v14 = RNBRemote::HandlePacket_ILLFORMED( this,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  1742,  a2,  v8);
    goto LABEL_22;
  }

LABEL_67:
  if ((char)__p.__r_.__value_.__s.__size_ < 0)
  {
    if (__p.__r_.__value_.__l.__size_ == 7)
    {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      if (*(_DWORD *)__p.__r_.__value_.__l.__data_ != 1718054764
        || *(_DWORD *)(__p.__r_.__value_.__r.__words[0] + 3) != 1701603686)
      {
        goto LABEL_79;
      }

            operator delete(v37);
            goto LABEL_68;
          }
        }

        do
        {
          uint64_t v50 = *((void *)v49 - 1);
          v49 -= 8;
          *((void *)v46 - 1) = v50;
          v46 -= 8;
        }

        while (v49 != v37);
        goto LABEL_66;
      }
    }

  -[NSAutoreleasePool drain](v6, "drain");
  return 0LL;
}

    if (v24 != v22)
    {
      int v12 = v24 - v20;
      if (v12 != -1LL) {
        continue;
      }
    }

LABEL_94:
      if ((v48.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v40 = &v48;
      }
      else {
        uint64_t v40 = (std::string *)v48.__r_.__value_.__r.__words[0];
      }
      unint64_t v41 = fopen((const char *)v40, "w");
      if (!v41)
      {
        v47.__r_.__value_.__s.__size_ = 3;
        int v39 = 3225413;
        goto LABEL_84;
      }

      DNBLogSetLogCallback(FileLogCallback, (uint64_t)v41);
      v47.__r_.__value_.__s.__size_ = 2;
      strcpy((char *)&v47, "OK");
      goto LABEL_85;
    }

LABEL_83:
    v47.__r_.__value_.__s.__size_ = 3;
    int v39 = 3159877;
LABEL_84:
    LODWORD(v47.__r_.__value_.__l.__data_) = v39;
    goto LABEL_85;
  }

  if (__p.__r_.__value_.__s.__size_ != 7) {
    goto LABEL_83;
  }
  if (LODWORD(__p.__r_.__value_.__l.__data_) == 1718054764
    && *(_DWORD *)((char *)__p.__r_.__value_.__r.__words + 3) == 1701603686)
  {
    goto LABEL_94;
  }

  p_p = &__p;
LABEL_79:
  int data = (int)p_p->__r_.__value_.__l.__data_;
  int v37 = *(_DWORD *)((char *)p_p->__r_.__value_.__r.__words + 3);
  if (data != 1835495276 || v37 != 1802723693) {
    goto LABEL_83;
  }
  unint64_t v46 = 0LL;
  *__error() = 0;
  if ((v48.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v42 = &v48;
  }
  else {
    uint64_t v42 = (std::string *)v48.__r_.__value_.__r.__words[0];
  }
  int v43 = strtoul((const char *)v42, &v46, 0);
  if (*__error() || !v46 || *v46)
  {
    *__error() = 0;
    if ((v48.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v44 = &v48;
    }
    else {
      size_t v44 = (std::string *)v48.__r_.__value_.__r.__words[0];
    }
    int v45 = strtoul((const char *)v44, &v46, 16);
    if (*__error() || !v46 || *v46)
    {
      v47.__r_.__value_.__s.__size_ = 3;
      int v39 = 3290949;
      goto LABEL_84;
    }

    DNBLogSetLogMask(v45);
  }

  else
  {
    DNBLogSetLogMask(v43);
    if (!DNBLogGetLogCallback()) {
      DNBLogSetLogCallback(ASLLogCallback, 0LL);
    }
  }

  std::string::basic_string[abi:nn180100]<0>(&v47, "OK");
LABEL_85:
  uint64_t v14 = RNBRemote::SendPacket((uint64_t)this, &v47);
  if (((char)v47.__r_.__value_.__s.__size_ & 0x80000000) == 0)
  {
LABEL_90:
    operator delete(v48.__r_.__value_.__l.__data_);
    goto LABEL_91;
  }

  operator delete(v47.__r_.__value_.__l.__data_);
LABEL_87:
LABEL_91:
  operator delete(v49.__r_.__value_.__l.__data_);
LABEL_19:
  if (((char)__p.__r_.__value_.__s.__size_ & 0x80000000) == 0)
  {
LABEL_27:
    operator delete(__str.__r_.__value_.__l.__data_);
    goto LABEL_22;
  }

  operator delete(__p.__r_.__value_.__l.__data_);
LABEL_21:
  if ((char)v52.__r_.__value_.__s.__size_ < 0) {
LABEL_22:
  }
    operator delete(v52.__r_.__value_.__l.__data_);
  return v14;
}

      unint64_t v95 = 0;
      a4 = (const char **)*a1;
      if ((SHIBYTE(v117) & 0x80000000) == 0) {
        goto LABEL_91;
      }
LABEL_84:
      operator delete((void *)__dst);
      if ((v95 & 1) != 0)
      {
LABEL_92:
        if (!*a1)
        {
LABEL_31:
          if (!*(_DWORD *)a14)
          {
            *(void *)a14 = 0xFFFFFFFFLL;
            if (*(char *)(a14 + 31) < 0)
            {
              **(_BYTE **)(a14 + 8) = 0;
              *(void *)(a14 + 16) = 0LL;
            }

            else
            {
              *(_BYTE *)(a14 + 8) = 0;
              *(_BYTE *)(a14 + 31) = 0;
            }
          }

          return (const char **)*a1;
        }

uint64_t RNBRemote::HandlePacket_qC(RNBRemote *this, const char *a2)
{
  int v12 = v3;
  *(void (__cdecl ***)(std::ostringstream *__hidden))((char *)&v12 + (void)*(v3 - 3)) = v4;
  std::string::size_type v5 = (std::ios_base *)((char *)&v12 + (void)*(v12 - 3));
  std::ios_base::init(v5, &v13);
  v5[1].__vftable = 0LL;
  v5[1].__fmtflags_ = -1;
  std::streambuf::basic_streambuf(&v13);
  memset(&v13.__str_, 0, 32);
  v13.__mode_ = 16;
  int v6 = *((_DWORD *)this + 3);
  if (v6)
  {
    uint64_t CurrentThread = DNBProcessGetCurrentThread(v6);
    DNBProcessSetCurrentThread(*((_DWORD *)this + 3), CurrentThread);
    *((void *)this + 68) = CurrentThread;
  }

  else
  {
    uint64_t CurrentThread = 0LL;
  }

  int v8 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v12, (uint64_t)"QC", 2LL);
  *(_DWORD *)((char *)v8 + *(void *)(*v8 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v8 + *(void *)(*v8 - 24LL) + 8) & 0xFFFFFFB5 | 8;
  std::ostream::operator<<(v8, CurrentThread);
  std::stringbuf::str(&__p, &v13);
  uint64_t v9 = RNBRemote::SendPacket((uint64_t)this, &__p);
  std::streambuf::~streambuf(&v13);
  std::ios::~ios(&v14);
  return v9;
}

uint64_t RNBRemote::HandlePacket_qEcho(RNBRemote *this, const char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8LL) {
    abort();
  }
  std::string::size_type v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    p_dst = (std::string *)operator new(v7 + 1);
    __dst.__r_.__value_.__l.__size_ = v5;
    __dst.__r_.__value_.__l.__cap_ = v8 | 0x8000000000000000LL;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_8;
  }

  __dst.__r_.__value_.__s.__size_ = v4;
  p_dst = &__dst;
  if (v4) {
LABEL_8:
  }
    memcpy(p_dst, __s, v5);
  p_dst->__r_.__value_.__s.__data_[v5] = 0;
  uint64_t v9 = RNBRemote::SendPacket((uint64_t)this, &__dst);
  return v9;
}

uint64_t RNBRemote::HandlePacket_qGetPid(RNBRemote *this, const char *a2)
{
  unint64_t v10 = v3;
  *(void (__cdecl ***)(std::ostringstream *__hidden))((char *)&v10 + (void)*(v3 - 3)) = v4;
  std::string::size_type v5 = (std::ios_base *)((char *)&v10 + (void)*(v10 - 3));
  std::ios_base::init(v5, &v11);
  v5[1].__vftable = 0LL;
  v5[1].__fmtflags_ = -1;
  std::streambuf::basic_streambuf(&v11);
  memset(&v11.__str_, 0, 32);
  v11.__mode_ = 16;
  uint64_t v6 = *((unsigned int *)this + 3);
  *(_DWORD *)((char *)&v10 + (void)*(v10 - 3) + 8) = *(_DWORD *)((_BYTE *)&v10 + (void)*(v10 - 3) + 8) & 0xFFFFFFB5 | 8;
  std::ostream::operator<<(&v10, v6);
  std::stringbuf::str(&__p, &v11);
  uint64_t v7 = RNBRemote::SendPacket((uint64_t)this, &__p);
  std::streambuf::~streambuf(&v11);
  std::ios::~ios(&v12);
  return v7;
}

uint64_t RNBRemote::HandlePacket_qThreadInfo(RNBRemote *this, const char *a2)
{
  int v3 = *((_DWORD *)this + 3);
  if (v3)
  {
    if (a2[1] == 102)
    {
      uint64_t NumThreads = DNBProcessGetNumThreads(*((_DWORD *)this + 3));
      v14[0].__r_.__value_.__r.__words[0] = v5;
      *(std::string::size_type *)((char *)v14[0].__r_.__value_.__r.__words + *(void *)(v5 - 24)) = v6;
      uint64_t v7 = (std::ios_base *)((char *)v14 + *(void *)(v14[0].__r_.__value_.__r.__words[0] - 24));
      std::ios_base::init(v7, &v14[0].__r_.__value_.__r.__words[1]);
      v7[1].__vftable = 0LL;
      v7[1].__fmtflags_ = -1;
      std::streambuf::basic_streambuf(&v14[0].__r_.__value_.__r.__words[1]);
      *(_OWORD *)std::stringbuf::string_type __p = 0u;
      __int128 v16 = 0u;
      int v17 = 16;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)"m", 1LL);
      if (NumThreads)
      {
        uint64_t ThreadAtIndex = DNBProcessGetThreadAtIndex(v3, 0LL);
        *(_DWORD *)((char *)&v14[0].__r_.__value_.__r.__words[1] + *(void *)(v14[0].__r_.__value_.__r.__words[0] - 24)) = *(_DWORD *)((_BYTE *)&v14[0].__r_.__value_.__r.__words[1] + *(void *)(v14[0].__r_.__value_.__r.__words[0] - 24)) & 0xFFFFFFB5 | 8;
        std::ostream::operator<<(v14, ThreadAtIndex);
        if (NumThreads != 1)
        {
          for (unint64_t i = 1LL; i != NumThreads; ++i)
          {
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)",", 1LL);
            uint64_t v10 = DNBProcessGetThreadAtIndex(v3, i);
            *(_DWORD *)((char *)&v14[0].__r_.__value_.__r.__words[1]
                      + *(void *)(v14[0].__r_.__value_.__r.__words[0] - 24)) = *(_DWORD *)((_BYTE *)&v14[0].__r_.__value_.__r.__words[1]
                                                                                           + *(void *)(v14[0].__r_.__value_.__r.__words[0] - 24)) & 0xFFFFFFB5 | 8;
            std::ostream::operator<<(v14, v10);
          }
        }
      }

      std::stringbuf::str(&v13, (const std::stringbuf *)&v14[0].__r_.__value_.__r.__words[1]);
      uint64_t v11 = RNBRemote::SendPacket((uint64_t)this, &v13);
      *(std::string::size_type *)((char *)v14[0].__r_.__value_.__r.__words
      if (SBYTE7(v16) < 0) {
        operator delete(__p[0]);
      }
      std::streambuf::~streambuf(&v14[0].__r_.__value_.__r.__words[1]);
      std::ios::~ios(&v18);
      return v11;
    }

    v14[0].__r_.__value_.__s.__size_ = 1;
    LOWORD(v14[0].__r_.__value_.__l.__data_) = 108;
  }

  else
  {
    v14[0].__r_.__value_.__s.__size_ = 2;
    strcpy((char *)v14, "OK");
  }

  uint64_t v11 = RNBRemote::SendPacket((uint64_t)this, v14);
  return v11;
}

uint64_t RNBRemote::HandlePacket_qThreadStopInfo(RNBRemote *this, const char *a2)
{
  unint64_t v3 = strtoul(a2 + 15, 0LL, 16);
  return RNBRemote::SendStopReplyPacketForThread(this, v3);
}

uint64_t RNBRemote::HandlePacket_qThreadExtraInfo( RNBRemote *this, const char *a2, uint64_t a3, uint64_t a4, const char *a5)
{
  std::string::size_type v5 = this;
  int v6 = *((_DWORD *)this + 3);
  if (v6)
  {
    uint64_t v7 = a2 + 17;
    if (a2[16] != 44)
    {
      int v9 = 1659;
      return RNBRemote::HandlePacket_ILLFORMED( this,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v9,  v7,  a5);
    }

    *__error() = 0;
    unint64_t v8 = strtoul(v7, 0LL, 16);
    if (*__error() && !v8)
    {
      this = v5;
      int v9 = 1665;
      return RNBRemote::HandlePacket_ILLFORMED( this,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v9,  v7,  a5);
    }

    Info = DNBThreadGetInfo(v6, v8);
    if (Info)
    {
      int v12 = (unsigned __int8 *)Info;
      if (*Info)
      {
        size_t v13 = strlen(Info);
        return RNBRemote::SendHexEncodedBytePacket(v5, 0LL, v12, v13, 0LL);
      }
    }

    __p.__r_.__value_.__s.__size_ = 4;
    strcpy((char *)&__p, "4f6b");
  }

  else
  {
    __p.__r_.__value_.__s.__size_ = 2;
    strcpy((char *)&__p, "OK");
  }

  uint64_t v14 = RNBRemote::SendPacket((uint64_t)v5, &__p);
  return v14;
}

uint64_t RNBRemote::HandlePacket_qLaunchSuccess(RNBRemote *this, const char *a2)
{
  if (!*((_DWORD *)this + 3) && *((_DWORD *)this + 78))
  {
    __p[0].__r_.__value_.__r.__words[0] = v4;
    *(std::string::size_type *)((char *)__p[0].__r_.__value_.__r.__words + *(void *)(v4 - 24)) = v5;
    int v6 = (std::ios_base *)((char *)__p + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24));
    std::ios_base::init(v6, &__p[0].__r_.__value_.__r.__words[1]);
    v6[1].__vftable = 0LL;
    v6[1].__fmtflags_ = -1;
    std::streambuf::basic_streambuf(&__p[0].__r_.__value_.__r.__words[1]);
    __int128 v29 = 0u;
    __int128 v30 = 0u;
    int v31 = 16;
    memset(&v27, 0, sizeof(v27));
    uint64_t v7 = RNBContext::LaunchStatusAsString((uint64_t)this, &v27);
    size_t v8 = strlen((const char *)v7);
    if (v8 >= 0x7FFFFFFFFFFFFFF8LL) {
      abort();
    }
    std::string::size_type v9 = v8;
    if (v8 >= 0x17)
    {
      uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8LL) + 8;
      if ((v8 | 7) != 0x17) {
        uint64_t v11 = v8 | 7;
      }
      uint64_t v12 = v11 + 1;
      p_dst = (std::stringbuf::string_type *)operator new(v11 + 1);
      __dst.__r_.__value_.__l.__size_ = v9;
      __dst.__r_.__value_.__l.__cap_ = v12 | 0x8000000000000000LL;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }

    else
    {
      __dst.__r_.__value_.__s.__size_ = v8;
      p_dst = &__dst;
      if (!v8)
      {
LABEL_13:
        p_dst->__r_.__value_.__s.__data_[v9] = 0;
        memset(&v26, 0, sizeof(v26));
        int size = (char)__dst.__r_.__value_.__s.__size_;
        uint64_t v14 = (void *)__dst.__r_.__value_.__r.__words[0];
        if ((__dst.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          std::string::size_type v15 = __dst.__r_.__value_.__s.__size_;
        }
        else {
          std::string::size_type v15 = __dst.__r_.__value_.__l.__size_;
        }
        if ((__dst.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          __int128 v16 = &__dst;
        }
        else {
          __int128 v16 = (std::stringbuf::string_type *)__dst.__r_.__value_.__r.__words[0];
        }
        for (; v15; --v15)
        {
          unsigned int v18 = v16->__r_.__value_.__s.__data_[0];
          __int128 v16 = (std::stringbuf::string_type *)((char *)v16 + 1);
          unsigned int v17 = v18;
          uint64_t v19 = (1LL << v18) & 0x41800000000LL;
          BOOL v20 = v18 > 0x2A || v19 == 0;
          if (!v20 || v17 == 125)
          {
            std::string::push_back(&v26, 125);
            LOBYTE(v17) = v17 ^ 0x20;
          }

          std::string::push_back(&v26, v17);
        }

        if (size < 0) {
          operator delete(v14);
        }
        unint64_t v21 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"E", 1LL);
        if ((v26.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          size_t v22 = &v26;
        }
        else {
          size_t v22 = (std::string *)v26.__r_.__value_.__r.__words[0];
        }
        if ((v26.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          uint64_t v23 = v26.__r_.__value_.__s.__size_;
        }
        else {
          uint64_t v23 = v26.__r_.__value_.__l.__size_;
        }
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v21, (uint64_t)v22, v23);
        std::stringbuf::str(&__dst, (const std::stringbuf *)&__p[0].__r_.__value_.__r.__words[1]);
        uint64_t v3 = RNBRemote::SendPacket((uint64_t)this, &__dst);
        if ((char)__dst.__r_.__value_.__s.__size_ < 0)
        {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }

        else if (((char)v26.__r_.__value_.__s.__size_ & 0x80000000) == 0)
        {
LABEL_40:
          *(std::string::size_type *)((char *)__p[0].__r_.__value_.__r.__words
          if (SBYTE7(v30) < 0) {
            operator delete((void *)v29);
          }
          std::streambuf::~streambuf(&__p[0].__r_.__value_.__r.__words[1]);
          std::ios::~ios(&v32);
          return v3;
        }

        operator delete(v26.__r_.__value_.__l.__data_);
        goto LABEL_40;
      }
    }

    memmove(p_dst, v7, v9);
    goto LABEL_13;
  }

  __p[0].__r_.__value_.__s.__size_ = 2;
  strcpy((char *)__p, "OK");
  uint64_t v3 = RNBRemote::SendPacket((uint64_t)this, __p);
  return v3;
}

uint64_t RNBRemote::HandlePacket_qRegisterInfo(RNBRemote *this, const char *a2)
{
  if (!g_num_reg_entries) {
    RNBRemote::InitializeRegisters(this, 0);
  }
  unint64_t v79 = 0LL;
  uint64_t v4 = DNBGetRegisterSetInfo(&v79);
  unint64_t v5 = strtoul(a2 + 13, 0LL, 16);
  if (v5 >= g_num_reg_entries)
  {
    __p[0].__r_.__value_.__s.__size_ = 3;
    LODWORD(__p[0].__r_.__value_.__l.__data_) = 3486789;
    uint64_t v26 = RNBRemote::SendPacket((uint64_t)this, __p);
  }

  else
  {
    BOOL v72 = this;
    uint64_t v6 = g_reg_entries;
    __p[0].__r_.__value_.__r.__words[0] = v7;
    *(std::string::size_type *)((char *)__p[0].__r_.__value_.__r.__words + *(void *)(v7 - 24)) = v8;
    std::string::size_type v9 = (std::ios_base *)((char *)__p + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24));
    std::ios_base::init(v9, &__p[0].__r_.__value_.__r.__words[1]);
    v9[1].__vftable = 0LL;
    v9[1].__fmtflags_ = -1;
    std::streambuf::basic_streambuf(&__p[0].__r_.__value_.__r.__words[1]);
    *(_OWORD *)uid_t v75 = 0u;
    __int128 v76 = 0u;
    int v77 = 16;
    unint64_t v10 = v6 + (v5 << 7);
    uint64_t v11 = (const char **)(v10 + 16);
    if (*(void *)(v10 + 16))
    {
      uint64_t v12 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"name:", 5LL);
      size_t v13 = strlen(*v11);
      uint64_t v14 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v12, (uint64_t)*v11, v13);
      v73.__r_.__value_.__s.__data_[0] = 59;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)&v73, 1LL);
    }

    uint64_t v16 = *(void *)(v10 + 24);
    std::string::size_type v15 = (const char **)(v10 + 24);
    if (v16)
    {
      unsigned int v17 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"alt-name:", 9LL);
      size_t v18 = strlen(*v15);
      uint64_t v19 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v17, (uint64_t)*v15, v18);
      v73.__r_.__value_.__s.__data_[0] = 59;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)&v73, 1LL);
    }

    BOOL v20 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"bitsize:", 8LL);
    *(_DWORD *)((char *)v20 + *(void *)(*v20 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v20 + *(void *)(*v20 - 24LL) + 8) & 0xFFFFFFB5 | 2;
    unint64_t v21 = v6 + (v5 << 7);
    size_t v22 = (void *)std::ostream::operator<<(v20, (8 * *(_DWORD *)(v21 + 36)));
    v73.__r_.__value_.__s.__data_[0] = 59;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v22, (uint64_t)&v73, 1LL);
    uint64_t v23 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"offset:", 7LL);
    *(_DWORD *)((char *)v23 + *(void *)(*v23 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v23 + *(void *)(*v23 - 24LL) + 8) & 0xFFFFFFB5 | 2;
    int v24 = (void *)std::ostream::operator<<(v23, *(unsigned int *)(v21 + 4));
    v73.__r_.__value_.__s.__data_[0] = 59;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v24, (uint64_t)&v73, 1LL);
    switch(*(_WORD *)(v21 + 32))
    {
      case 1:
        size_t v25 = "encoding:uint;";
        goto LABEL_13;
      case 2:
        size_t v25 = "encoding:sint;";
LABEL_13:
        uint64_t v27 = 14LL;
        goto LABEL_16;
      case 3:
        size_t v25 = "encoding:ieee754;";
        uint64_t v27 = 17LL;
        goto LABEL_16;
      case 4:
        size_t v25 = "encoding:vector;";
        uint64_t v27 = 16LL;
LABEL_16:
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)v25, v27);
        break;
      default:
        break;
    }

    switch(*(_WORD *)(v21 + 34))
    {
      case 1:
        unint64_t v28 = "format:binary;";
        uint64_t v29 = 14LL;
        goto LABEL_33;
      case 2:
        unint64_t v28 = "format:decimal;";
        uint64_t v29 = 15LL;
        goto LABEL_33;
      case 3:
        unint64_t v28 = "format:hex;";
        uint64_t v29 = 11LL;
        goto LABEL_33;
      case 4:
        unint64_t v28 = "format:float;";
        uint64_t v29 = 13LL;
        goto LABEL_33;
      case 5:
        unint64_t v28 = "format:vector-sint8;";
        goto LABEL_24;
      case 6:
        unint64_t v28 = "format:vector-uint8;";
LABEL_24:
        uint64_t v29 = 20LL;
        goto LABEL_33;
      case 7:
        unint64_t v28 = "format:vector-sint16;";
        goto LABEL_29;
      case 8:
        unint64_t v28 = "format:vector-uint16;";
        goto LABEL_29;
      case 9:
        unint64_t v28 = "format:vector-sint32;";
        goto LABEL_29;
      case 0xA:
        unint64_t v28 = "format:vector-uint32;";
LABEL_29:
        uint64_t v29 = 21LL;
        goto LABEL_33;
      case 0xB:
        unint64_t v28 = "format:vector-float32;";
        goto LABEL_32;
      case 0xC:
        unint64_t v28 = "format:vector-uint128;";
LABEL_32:
        uint64_t v29 = 22LL;
LABEL_33:
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)v28, v29);
        break;
      default:
        break;
    }

    if (v4 && v79 > *((unsigned int *)v11 - 2))
    {
      __int128 v30 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"set:", 4LL);
      int v31 = *(const char **)(v4 + 24LL * *((unsigned int *)v11 - 2));
      size_t v32 = strlen(v31);
      int v33 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v30, (uint64_t)v31, v32);
      v73.__r_.__value_.__s.__data_[0] = 59;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v33, (uint64_t)&v73, 1LL);
    }

    unint64_t v34 = v6 + (v5 << 7);
    if (*(_DWORD *)(v34 + 44) != -1)
    {
      std::string v35 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"ehframe:", 8LL);
      *(_DWORD *)((char *)v35 + *(void *)(*v35 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v35 + *(void *)(*v35 - 24LL) + 8) & 0xFFFFFFB5 | 2;
      uint64_t v36 = (void *)std::ostream::operator<<(v35, *(unsigned int *)(v34 + 44));
      v73.__r_.__value_.__s.__data_[0] = 59;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v36, (uint64_t)&v73, 1LL);
    }

    int v38 = *(_DWORD *)(v34 + 48);
    int v37 = (unsigned int *)(v34 + 48);
    if (v38 != -1)
    {
      int v39 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"dwarf:", 6LL);
      *(_DWORD *)((char *)v39 + *(void *)(*v39 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v39 + *(void *)(*v39 - 24LL) + 8) & 0xFFFFFFB5 | 2;
      uint64_t v40 = (void *)std::ostream::operator<<(v39, *v37);
      v73.__r_.__value_.__s.__data_[0] = 59;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v40, (uint64_t)&v73, 1LL);
    }

    unint64_t v41 = v6 + (v5 << 7);
    switch(*(_DWORD *)(v41 + 52))
    {
      case 0:
        uint64_t v42 = "generic:pc;";
        goto LABEL_46;
      case 1:
        uint64_t v42 = "generic:sp;";
        goto LABEL_46;
      case 2:
        uint64_t v42 = "generic:fp;";
        goto LABEL_46;
      case 3:
        uint64_t v42 = "generic:ra;";
LABEL_46:
        uint64_t v43 = 11LL;
        goto LABEL_57;
      case 4:
        uint64_t v42 = "generic:flags;";
        uint64_t v43 = 14LL;
        goto LABEL_57;
      case 5:
        uint64_t v42 = "generic:arg1;";
        goto LABEL_56;
      case 6:
        uint64_t v42 = "generic:arg2;";
        goto LABEL_56;
      case 7:
        uint64_t v42 = "generic:arg3;";
        goto LABEL_56;
      case 8:
        uint64_t v42 = "generic:arg4;";
        goto LABEL_56;
      case 9:
        uint64_t v42 = "generic:arg5;";
        goto LABEL_56;
      case 0xA:
        uint64_t v42 = "generic:arg6;";
        goto LABEL_56;
      case 0xB:
        uint64_t v42 = "generic:arg7;";
        goto LABEL_56;
      case 0xC:
        uint64_t v42 = "generic:arg8;";
LABEL_56:
        uint64_t v43 = 13LL;
LABEL_57:
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)v42, v43);
        break;
      default:
        break;
    }

    int v45 = *(unsigned int **)(v41 + 80);
    size_t v44 = (unsigned int **)(v41 + 80);
    unint64_t v46 = v44 + 1;
    if (v45 != v44[1])
    {
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"container-regs:", 15LL);
      std::string v47 = (char *)*v44;
      uint64_t v48 = (char *)*v46 - (char *)*v44;
      if (*v46 != *v44)
      {
        else {
          uint64_t v49 = v48 >> 2;
        }
        std::string::size_type v50 = __p[0].__r_.__value_.__r.__words[0];
        char v51 = (char *)__p + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24);
        if (*((_DWORD *)v51 + 36) == -1)
        {
          std::ios_base::getloc((const std::ios_base *)((char *)__p
                                                      + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24)));
          std::string v52 = std::locale::use_facet((const std::locale *)&v73, &std::ctype<char>::id);
          ((void (*)(const std::locale::facet *, uint64_t))v52->__vftable[2].~facet_0)(v52, 32LL);
          std::locale::~locale((std::locale *)&v73);
          std::string::size_type v50 = __p[0].__r_.__value_.__r.__words[0];
          std::string v47 = (char *)*v44;
        }

        *((_DWORD *)v51 + 36) = 48;
        *(_DWORD *)((char *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(v50 - 24)) = *(_DWORD *)((_BYTE *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(v50 - 24)) & 0xFFFFFFB5 | 8;
        *(_DWORD *)((char *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(v50 - 24)) = *(_DWORD *)((_BYTE *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(v50 - 24)) & 0xFFFFFF4F | 0x80;
        std::ostream::operator<<(__p, *(unsigned int *)v47);
        if ((unint64_t)v48 >= 8)
        {
          uint64_t v64 = 1LL;
          do
          {
            v73.__r_.__value_.__s.__data_[0] = 44;
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)&v73, 1LL);
            std::string::size_type v65 = __p[0].__r_.__value_.__r.__words[0];
            unint64_t v66 = (char *)__p + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24);
            if (*((_DWORD *)v66 + 36) == -1)
            {
              std::ios_base::getloc((const std::ios_base *)((char *)__p
                                                          + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24)));
              uint64_t v67 = std::locale::use_facet((const std::locale *)&v73, &std::ctype<char>::id);
              ((void (*)(const std::locale::facet *, uint64_t))v67->__vftable[2].~facet_0)(v67, 32LL);
              std::locale::~locale((std::locale *)&v73);
              std::string::size_type v65 = __p[0].__r_.__value_.__r.__words[0];
            }

            *((_DWORD *)v66 + 36) = 48;
            *(_DWORD *)((char *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(v65 - 24)) = *(_DWORD *)((_BYTE *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(v65 - 24)) & 0xFFFFFFB5 | 8;
            *(_DWORD *)((char *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(v65 - 24)) = *(_DWORD *)((_BYTE *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(v65 - 24)) & 0xFFFFFF4F | 0x80;
            std::ostream::operator<<(__p, (*v44)[v64++]);
          }

          while (v49 != v64);
        }
      }

      v73.__r_.__value_.__s.__data_[0] = 59;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)&v73, 1LL);
    }

    unint64_t v53 = v6 + (v5 << 7);
    unint64_t v55 = *(unsigned int **)(v53 + 104);
    uint64_t v54 = (unsigned int **)(v53 + 104);
    __int128 v56 = v54 + 1;
    if (v55 != v54[1])
    {
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"invalidate-regs:", 16LL);
      uint64_t v57 = (char *)*v54;
      uint64_t v58 = (char *)*v56 - (char *)*v54;
      if (*v56 != *v54)
      {
        else {
          uint64_t v59 = v58 >> 2;
        }
        std::string::size_type v60 = __p[0].__r_.__value_.__r.__words[0];
        uint64_t v61 = (char *)__p + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24);
        if (*((_DWORD *)v61 + 36) == -1)
        {
          std::ios_base::getloc((const std::ios_base *)((char *)__p
                                                      + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24)));
          uint64_t v62 = std::locale::use_facet((const std::locale *)&v73, &std::ctype<char>::id);
          ((void (*)(const std::locale::facet *, uint64_t))v62->__vftable[2].~facet_0)(v62, 32LL);
          std::locale::~locale((std::locale *)&v73);
          std::string::size_type v60 = __p[0].__r_.__value_.__r.__words[0];
          uint64_t v57 = (char *)*v54;
        }

        *((_DWORD *)v61 + 36) = 48;
        *(_DWORD *)((char *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(v60 - 24)) = *(_DWORD *)((_BYTE *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(v60 - 24)) & 0xFFFFFFB5 | 8;
        *(_DWORD *)((char *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(v60 - 24)) = *(_DWORD *)((_BYTE *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(v60 - 24)) & 0xFFFFFF4F | 0x80;
        std::ostream::operator<<(__p, *(unsigned int *)v57);
        if ((unint64_t)v58 >= 8)
        {
          uint64_t v68 = 1LL;
          do
          {
            v73.__r_.__value_.__s.__data_[0] = 44;
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)&v73, 1LL);
            std::string::size_type v69 = __p[0].__r_.__value_.__r.__words[0];
            __int128 v70 = (char *)__p + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24);
            if (*((_DWORD *)v70 + 36) == -1)
            {
              std::ios_base::getloc((const std::ios_base *)((char *)__p
                                                          + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24)));
              uint64_t v71 = std::locale::use_facet((const std::locale *)&v73, &std::ctype<char>::id);
              ((void (*)(const std::locale::facet *, uint64_t))v71->__vftable[2].~facet_0)(v71, 32LL);
              std::locale::~locale((std::locale *)&v73);
              std::string::size_type v69 = __p[0].__r_.__value_.__r.__words[0];
            }

            *((_DWORD *)v70 + 36) = 48;
            *(_DWORD *)((char *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(v69 - 24)) = *(_DWORD *)((_BYTE *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(v69 - 24)) & 0xFFFFFFB5 | 8;
            *(_DWORD *)((char *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(v69 - 24)) = *(_DWORD *)((_BYTE *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(v69 - 24)) & 0xFFFFFF4F | 0x80;
            std::ostream::operator<<(__p, (*v54)[v68++]);
          }

          while (v59 != v68);
        }
      }

      v73.__r_.__value_.__s.__data_[0] = 59;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)&v73, 1LL);
    }

    std::stringbuf::str(&v73, (const std::stringbuf *)&__p[0].__r_.__value_.__r.__words[1]);
    uint64_t v26 = RNBRemote::SendPacket((uint64_t)v72, &v73);
    *(std::string::size_type *)((char *)__p[0].__r_.__value_.__r.__words
    if (SBYTE7(v76) < 0) {
      operator delete(v75[0]);
    }
    std::streambuf::~streambuf(&__p[0].__r_.__value_.__r.__words[1]);
    std::ios::~ios(&v78);
  }

  return v26;
}

uint64_t RNBRemote::HandlePacket_qShlibInfoAddr(RNBRemote *this, const char *a2)
{
  int v3 = *((_DWORD *)this + 3);
  if (!v3 || (uint64_t SharedLibraryInfoAddress = DNBProcessGetSharedLibraryInfoAddress(v3), SharedLibraryInfoAddress == -1))
  {
    v15[0].__r_.__value_.__s.__size_ = 3;
    LODWORD(v15[0].__r_.__value_.__l.__data_) = 3421253;
    uint64_t v12 = RNBRemote::SendPacket((uint64_t)this, v15);
  }

  else
  {
    uint64_t v5 = SharedLibraryInfoAddress;
    v15[0].__r_.__value_.__r.__words[0] = v6;
    *(std::string::size_type *)((char *)v15[0].__r_.__value_.__r.__words + *(void *)(v6 - 24)) = v7;
    std::string::size_type v8 = (std::ios_base *)((char *)v15 + *(void *)(v15[0].__r_.__value_.__r.__words[0] - 24));
    std::ios_base::init(v8, &v15[0].__r_.__value_.__r.__words[1]);
    v8[1].__vftable = 0LL;
    v8[1].__fmtflags_ = -1;
    std::streambuf::basic_streambuf(&v15[0].__r_.__value_.__r.__words[1]);
    *(_OWORD *)uint64_t v16 = 0u;
    __int128 v17 = 0u;
    int v18 = 16;
    std::string::size_type v9 = v15[0].__r_.__value_.__r.__words[0];
    unint64_t v10 = (char *)v15 + *(void *)(v15[0].__r_.__value_.__r.__words[0] - 24);
    if (*((_DWORD *)v10 + 36) == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)v15 + *(void *)(v15[0].__r_.__value_.__r.__words[0] - 24)));
      uint64_t v11 = std::locale::use_facet((const std::locale *)&__p, &std::ctype<char>::id);
      ((void (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 32LL);
      std::locale::~locale((std::locale *)&__p);
      std::string::size_type v9 = v15[0].__r_.__value_.__r.__words[0];
    }

    *((_DWORD *)v10 + 36) = 48;
    *(_DWORD *)((char *)&v15[0].__r_.__value_.__r.__words[1] + *(void *)(v9 - 24)) = *(_DWORD *)((_BYTE *)&v15[0].__r_.__value_.__r.__words[1]
                                                                                                 + *(void *)(v9 - 24)) & 0xFFFFFFB5 | 8;
    *(_DWORD *)((char *)&v15[0].__r_.__value_.__r.__words[1] + *(void *)(v9 - 24)) = *(_DWORD *)((_BYTE *)&v15[0].__r_.__value_.__r.__words[1]
                                                                                                 + *(void *)(v9 - 24)) & 0xFFFFFF4F | 0x80;
    std::ostream::operator<<(v15, v5);
    std::stringbuf::str(&__p, (const std::stringbuf *)&v15[0].__r_.__value_.__r.__words[1]);
    uint64_t v12 = RNBRemote::SendPacket((uint64_t)this, &__p);
    *(std::string::size_type *)((char *)v15[0].__r_.__value_.__r.__words
    if (SBYTE7(v17) < 0) {
      operator delete(v16[0]);
    }
    std::streambuf::~streambuf(&v15[0].__r_.__value_.__r.__words[1]);
    std::ios::~ios(&v19);
  }

  return v12;
}

uint64_t RNBRemote::HandlePacket_qStepPacketSupported(RNBRemote *this, const char *a2)
{
  __p.__r_.__value_.__s.__size_ = 2;
  strcpy((char *)&__p, "OK");
  uint64_t v2 = RNBRemote::SendPacket((uint64_t)this, &__p);
  return v2;
}

uint64_t RNBRemote::HandlePacket_qVAttachOrWaitSupported(RNBRemote *this, const char *a2)
{
  __p.__r_.__value_.__s.__size_ = 2;
  strcpy((char *)&__p, "OK");
  uint64_t v2 = RNBRemote::SendPacket((uint64_t)this, &__p);
  return v2;
}

uint64_t RNBRemote::HandlePacket_qSyncThreadStateSupported(RNBRemote *this, const char *a2)
{
  __p.__r_.__value_.__s.__size_ = 2;
  strcpy((char *)&__p, "OK");
  uint64_t v2 = RNBRemote::SendPacket((uint64_t)this, &__p);
  return v2;
}

uint64_t RNBRemote::HandlePacket_qHostInfo(RNBRemote *this, const char *a2)
{
  unint64_t v46 = v3;
  *(void (__cdecl ***)(std::ostringstream *__hidden))((char *)&v46 + (void)*(v3 - 3)) = v4;
  uint64_t v5 = (std::ios_base *)((char *)&v46 + (void)*(v46 - 3));
  std::ios_base::init(v5, &v47);
  v5[1].__vftable = 0LL;
  v5[1].__fmtflags_ = -1;
  std::streambuf::basic_streambuf(&v47);
  memset(&v47.__str_, 0, 32);
  v47.__mode_ = 16;
  uint64_t v6 = GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_host_cputype;
  if (GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_host_cputype)
  {
    int v7 = GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_promoted_to_64;
    goto LABEL_15;
  }

  GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_promoted_to_64 = 0;
  size_t v39 = 4LL;
  if (!sysctlbyname( "hw.cputype",  &GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_host_cputype,  &v39,  0LL,  0LL))
  {
    size_t v39 = 4LL;
    if (!sysctlbyname( "hw.cpu64bit_capable",  &GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_is_64_bit_capable,  &v39,  0LL,  0LL)
      && GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_is_64_bit_capable
      && (GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_host_cputype & 0x1000000) == 0)
    {
      GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_promoted_to_64 = 1;
      GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_host_cputype |= 0x1000000u;
    }
  }

  size_t v39 = 4LL;
  int v8 = sysctlbyname( "hw.cpusubtype",  &GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_host_cpusubtype,  &v39,  0LL,  0LL);
  uint64_t v6 = GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_host_cputype;
  int v7 = GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_promoted_to_64;
  if (!v8
    && GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_promoted_to_64
    && GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_host_cputype == 16777223
    && GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_host_cpusubtype == 4)
  {
    GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_host_cpusubtype = 3;
    uint64_t v6 = 16777223LL;
    goto LABEL_15;
  }

  if (GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_host_cputype)
  {
LABEL_15:
    uint64_t v9 = GetHostCPUType(unsigned int &,unsigned int &,unsigned int &,BOOL &)::g_host_cpusubtype;
    unint64_t v10 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v46, (uint64_t)"cputype:", 8LL);
    *(_DWORD *)((char *)v10 + *(void *)(*v10 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v10 + *(void *)(*v10 - 24LL) + 8) & 0xFFFFFFB5 | 2;
    uint64_t v11 = (void *)std::ostream::operator<<(v10, v6);
    LOBYTE(v39) = 59;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v11, (uint64_t)&v39, 1LL);
    uint64_t v12 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v46, (uint64_t)"cpusubtype:", 11LL);
    *(_DWORD *)((char *)v12 + *(void *)(*v12 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v12 + *(void *)(*v12 - 24LL) + 8) & 0xFFFFFFB5 | 2;
    size_t v13 = (void *)std::ostream::operator<<(v12, v9);
    LOBYTE(v39) = 59;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v13, (uint64_t)&v39, 1LL);
  }

  unsigned int v45 = 0;
  if (DNBGetAddressingBits(&v45))
  {
    uint64_t v14 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v46,  (uint64_t)"addressing_bits:",  16LL);
    *(_DWORD *)((char *)v14 + *(void *)(*v14 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v14 + *(void *)(*v14 - 24LL) + 8) & 0xFFFFFFB5 | 2;
    std::string::size_type v15 = (void *)std::ostream::operator<<(v14, v45);
    LOBYTE(v39) = 59;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v15, (uint64_t)&v39, 1LL);
  }

  if ((_DWORD)v6 == 12 || (_DWORD)v6 == 33554444 || (_DWORD)v6 == 16777228)
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v46, (uint64_t)"ostype:tvos;", 12LL);
    uint64_t v16 = "watchpoint_exceptions_received:before;";
    uint64_t v17 = 38LL;
  }

  else
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v46, (uint64_t)"ostype:macosx;", 14LL);
    uint64_t v16 = "watchpoint_exceptions_received:after;";
    uint64_t v17 = 37LL;
  }

  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v46, (uint64_t)v16, v17);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v46, (uint64_t)"vendor:apple;", 13LL);
  unint64_t v43 = 0LL;
  unint64_t v44 = 0LL;
  unint64_t v42 = 0LL;
  if (DNBGetOSVersionNumbers(&v44, &v43, &v42))
  {
    int v18 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v46, (uint64_t)"os_version:", 11LL);
    uint64_t v19 = (void *)std::ostream::operator<<(v18, v44);
    BOOL v20 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)".", 1LL);
    std::ostream::operator<<(v20, v43);
    if (v42 != -1LL)
    {
      unint64_t v21 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v46, (uint64_t)".", 1LL);
      std::ostream::operator<<(v21, v42);
    }

    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v46, (uint64_t)";", 1LL);
  }

  DNBGetMacCatalystVersionString();
  if ((char)v41 < 0)
  {
    uint64_t v22 = v40;
    if (v40)
    {
      uint64_t v23 = (unsigned __int8 *)v39;
LABEL_32:
      while (1)
      {
        int v24 = *v23;
        ++v23;
        if (!--v22)
        {
          uint64_t v26 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v46,  (uint64_t)"maccatalyst_version:",  20LL);
          if ((v41 & 0x80u) == 0) {
            uint64_t v27 = (uint64_t)&v39;
          }
          else {
            uint64_t v27 = v39;
          }
          if ((v41 & 0x80u) == 0) {
            uint64_t v28 = v41;
          }
          else {
            uint64_t v28 = v40;
          }
          uint64_t v29 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v26, v27, v28);
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v29, (uint64_t)";", 1LL);
          break;
        }
      }
    }
  }

  else
  {
    uint64_t v22 = v41;
    if (v41)
    {
      uint64_t v23 = (unsigned __int8 *)&v39;
      goto LABEL_32;
    }
  }

  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v46, (uint64_t)"endian:little;", 14LL);
  if (v7)
  {
    p_p = (std::stringbuf::string_type *)"ptrsize:8;";
    int v31 = &v46;
    uint64_t v32 = 10LL;
  }

  else
  {
    int v33 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v46, (uint64_t)"ptrsize:", 8LL);
    *(_DWORD *)((char *)v33 + *(void *)(*v33 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v33 + *(void *)(*v33 - 24LL) + 8) & 0xFFFFFFB5 | 2;
    int v31 = (void (__cdecl ***)(std::ostringstream *__hidden))std::ostream::operator<<();
    __p.__r_.__value_.__s.__data_[0] = 59;
    p_p = &__p;
    uint64_t v32 = 1LL;
  }

  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v31, (uint64_t)p_p, v32);
  unint64_t v34 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v46, (uint64_t)"vm-page-size:", 13LL);
  *(_DWORD *)((char *)v34 + *(void *)(*v34 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v34 + *(void *)(*v34 - 24LL) + 8) & 0xFFFFFFB5 | 2;
  std::string v35 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v35, (uint64_t)";", 1LL);
  std::stringbuf::str(&__p, &v47);
  uint64_t v36 = RNBRemote::SendPacket((uint64_t)this, &__p);
  std::streambuf::~streambuf(&v47);
  std::ios::~ios(&v48);
  return v36;
}

uint64_t RNBRemote::HandlePacket_qGDBServerVersion(RNBRemote *this, const char *a2)
{
  uint64_t v11 = v3;
  *(void (__cdecl ***)(std::ostringstream *__hidden))((char *)&v11 + (void)*(v3 - 3)) = v4;
  uint64_t v5 = (std::ios_base *)((char *)&v11 + (void)*(v11 - 3));
  std::ios_base::init(v5, &v12);
  v5[1].__vftable = 0LL;
  v5[1].__fmtflags_ = -1;
  std::streambuf::basic_streambuf(&v12);
  memset(&v12.__str_, 0, 32);
  v12.__mode_ = 16;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v11, (uint64_t)"name:debugserver;", 17LL);
  uint64_t v6 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v11, (uint64_t)"version:", 8LL);
  int v7 = (void *)std::ostream::operator<<(v6, 1600.2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v7, (uint64_t)";", 1LL);
  std::stringbuf::str(&__p, &v12);
  uint64_t v8 = RNBRemote::SendPacket((uint64_t)this, &__p);
  std::streambuf::~streambuf(&v12);
  std::ios::~ios(&v13);
  return v8;
}

uint64_t RNBRemote::HandlePacket_qProcessInfo(RNBRemote *this, const char *a2)
{
  int v3 = v57;
  *(void (__cdecl ***)(std::ostringstream *__hidden))((char *)&v55 + (void)*(v55 - 3)) = v4;
  uint64_t v5 = (std::ios_base *)((char *)&v55 + (void)*(v55 - 3));
  std::ios_base::init(v5, &v56);
  v5[1].__vftable = 0LL;
  v5[1].__fmtflags_ = -1;
  std::streambuf::basic_streambuf(&v56);
  memset(&v56.__str_, 0, 32);
  v56.__mode_ = 16;
  uint64_t v6 = *((unsigned int *)this + 3);
  if (!(_DWORD)v6)
  {
    v58.__r_.__value_.__s.__size_ = 3;
    LODWORD(v58.__r_.__value_.__l.__data_) = 3683909;
    goto LABEL_43;
  }

  unsigned int v45 = v57;
  int v7 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v55, (uint64_t)"pid:", 4LL);
  *(_DWORD *)((char *)v7 + *(void *)(*v7 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v7 + *(void *)(*v7 - 24LL) + 8) & 0xFFFFFFB5 | 8;
  uint64_t v8 = (void *)std::ostream::operator<<(v7, v6);
  v58.__r_.__value_.__s.__data_[0] = 59;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)&v58, 1LL);
  *(void *)std::string::size_type v65 = 0xE00000001LL;
  v65[2] = 1;
  v65[3] = v6;
  size_t v54 = 648LL;
  if (!sysctl(v65, 4u, v61, &v54, 0LL, 0LL))
  {
    if (v54)
    {
      uint64_t v9 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v55, (uint64_t)"parent-pid:", 11LL);
      *(_DWORD *)((char *)v9 + *(void *)(*v9 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v9 + *(void *)(*v9 - 24LL) + 8) & 0xFFFFFFB5 | 8;
      unint64_t v10 = (void *)std::ostream::operator<<(v9, v64);
      v58.__r_.__value_.__s.__data_[0] = 59;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v10, (uint64_t)&v58, 1LL);
      uint64_t v11 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v55, (uint64_t)"real-uid:", 9LL);
      *(_DWORD *)((char *)v11 + *(void *)(*v11 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v11 + *(void *)(*v11 - 24LL) + 8) & 0xFFFFFFB5 | 8;
      std::stringbuf v12 = (void *)std::ostream::operator<<(v11, v61[98]);
      v58.__r_.__value_.__s.__data_[0] = 59;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v12, (uint64_t)&v58, 1LL);
      size_t v13 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v55, (uint64_t)"real-gid:", 9LL);
      *(_DWORD *)((char *)v13 + *(void *)(*v13 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v13 + *(void *)(*v13 - 24LL) + 8) & 0xFFFFFFB5 | 8;
      uint64_t v14 = (void *)std::ostream::operator<<(v13, v61[100]);
      v58.__r_.__value_.__s.__data_[0] = 59;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)&v58, 1LL);
      std::string::size_type v15 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v55,  (uint64_t)"effective-uid:",  14LL);
      *(_DWORD *)((char *)v15 + *(void *)(*v15 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v15 + *(void *)(*v15 - 24LL) + 8) & 0xFFFFFFB5 | 8;
      uint64_t v16 = (void *)std::ostream::operator<<(v15, v61[105]);
      v58.__r_.__value_.__s.__data_[0] = 59;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v16, (uint64_t)&v58, 1LL);
      if (v62 >= 1)
      {
        uint64_t v17 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v55,  (uint64_t)"effective-gid:",  14LL);
        int v18 = (void *)std::ostream::operator<<(v17, v63);
        v58.__r_.__value_.__s.__data_[0] = 59;
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v18, (uint64_t)&v58, 1LL);
      }
    }
  }

  uint64_t CPUType = DNBProcessGetCPUType(v6);
  if (!(_DWORD)CPUType)
  {
    uint64_t CPUType = 16777228LL;
    if (DNBLogEnabled()) {
      _DNBLog( 0LL,  (uint64_t)"Unable to get the process cpu_type, making a best guess.",  v20,  v21,  v22,  v23,  v24,  v25,  (uint64_t)v57);
    }
  }

  uint64_t v26 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v55, (uint64_t)"cputype:", 8LL);
  *(_DWORD *)((char *)v26 + *(void *)(*v26 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v26 + *(void *)(*v26 - 24LL) + 8) & 0xFFFFFFB5 | 8;
  uint64_t v27 = (void *)std::ostream::operator<<(v26, CPUType);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v27, (uint64_t)";", 1LL);
  if ((CPUType & 0x1000000) != 0) {
    uint64_t v28 = 8LL;
  }
  else {
    uint64_t v28 = 4LL;
  }
  int v53 = 0;
  size_t v52 = 4LL;
  int v29 = sysctlbyname("hw.cpu64bit_capable", &v53, &v52, 0LL, 0LL);
  int v30 = v53;
  unsigned int v51 = 0;
  size_t v50 = 4LL;
  if (!sysctlbyname("hw.cpusubtype", &v51, &v50, 0LL, 0LL))
  {
    if (v29 || !v30) {
      goto LABEL_21;
    }
    if ((_DWORD)CPUType == 12)
    {
      int v31 = 12;
    }

    else
    {
      if ((_DWORD)CPUType != 7)
      {
LABEL_21:
        uint64_t v32 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v55,  (uint64_t)"cpusubtype:",  11LL);
        int v33 = (void *)std::ostream::operator<<(v32, v51);
        v58.__r_.__value_.__s.__data_[0] = 59;
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v33, (uint64_t)&v58, 1LL);
        goto LABEL_22;
      }

      int v31 = 3;
    }

    unsigned int v51 = v31;
    goto LABEL_21;
  }

uint64_t RNBRemote::HandlePacket_qSymbol(RNBRemote *this, const char *a2)
{
  int v3 = a2 + 8;
  uint64_t v4 = strchr(a2 + 8, 58);
  memset(&v45, 0, sizeof(v45));
  memset(&v44, 0, sizeof(v44));
  if (v4 > v3) {
    std::string::assign(&v44, v3, v4 - v3);
  }
  int v6 = v4[1];
  uint64_t v5 = v4 + 1;
  if (!v6)
  {
    int v13 = 0;
    *((_DWORD *)this + 166) = 0;
    goto LABEL_44;
  }

  uint64_t v7 = 0LL;
  memset(&v38, 0, sizeof(v38));
  do
  {
    int v8 = v5[v7];
    if ((v8 - 97) > 5)
    {
      if ((v8 - 65) > 5)
      {
        unsigned int v9 = v8 - 48;
        if (v9 > 9) {
          break;
        }
      }

      else
      {
        unsigned int v9 = v8 - 55;
      }
    }

    else
    {
      unsigned int v9 = v8 - 87;
    }

    if (v9 == -1) {
      break;
    }
    int v10 = v5[v7 + 1];
    if ((v10 - 97) > 5)
    {
      if ((v10 - 65) > 5)
      {
        unsigned int v11 = v10 - 48;
        if (v11 > 9) {
          break;
        }
      }

      else
      {
        unsigned int v11 = v10 - 55;
      }
    }

    else
    {
      unsigned int v11 = v10 - 87;
    }

    if (v11 == -1) {
      break;
    }
    std::string::push_back(&v38, v11 + 16 * v9);
    v7 += 2LL;
  }

  while (v7 < 0x1FFFFFFFELL);
  std::string v45 = v38;
  if ((char)v44.__r_.__value_.__s.__size_ < 0)
  {
    if (!v44.__r_.__value_.__l.__size_) {
      goto LABEL_40;
    }
    std::stringbuf v12 = (std::string *)v44.__r_.__value_.__r.__words[0];
  }

  else
  {
    if (!v44.__r_.__value_.__s.__size_) {
      goto LABEL_40;
    }
    std::stringbuf v12 = &v44;
  }

  unint64_t v14 = strtoull((const char *)v12, 0LL, 16);
  if (v14)
  {
    int size = (char)v45.__r_.__value_.__s.__size_;
    if (((char)v45.__r_.__value_.__s.__size_ & 0x80000000) == 0)
    {
LABEL_26:
      if (size != 22)
      {
        int v13 = *((_DWORD *)this + 166) + 1;
        *((_DWORD *)this + 166) = v13;
LABEL_44:
        LOBYTE(v22) = 0;
        v45.__r_.__value_.__s.__data_[0] = 0;
        v45.__r_.__value_.__s.__size_ = 0;
        if (v13) {
          goto LABEL_48;
        }
        goto LABEL_45;
      }

      uint64_t v16 = &v45;
      goto LABEL_31;
    }
  }

  else
  {
    __error();
    int size = (char)v45.__r_.__value_.__s.__size_;
  }

  if (v45.__r_.__value_.__l.__size_ != 22) {
    goto LABEL_40;
  }
  uint64_t v16 = (std::string *)v45.__r_.__value_.__r.__words[0];
LABEL_31:
  std::string::size_type v17 = v16->__r_.__value_.__r.__words[0];
  std::string::size_type v18 = v16->__r_.__value_.__l.__size_;
  uint64_t v19 = *(std::string::size_type *)((char *)&v16->__r_.__value_.__r.__words[1] + 6);
  if (v17 == 0x6863746170736964LL && v18 == 0x6F5F65756575715FLL && v19 == 0x7374657366666F5FLL) {
    *((void *)this + 82) = v14;
  }
LABEL_40:
  LODWORD(v22) = (char)v45.__r_.__value_.__s.__size_;
  int v13 = *((_DWORD *)this + 166) + 1;
  *((_DWORD *)this + 166) = v13;
  if ((v22 & 0x80000000) == 0) {
    goto LABEL_44;
  }
  *v45.__r_.__value_.__l.__data_ = 0;
  v45.__r_.__value_.__l.__size_ = 0LL;
  if (*((_DWORD *)this + 166)) {
    goto LABEL_48;
  }
LABEL_45:
  if (*((void *)this + 82) == -1LL)
  {
    std::string::assign(&v45, "dispatch_queue_offsets");
    LOBYTE(v22) = v45.__r_.__value_.__s.__size_;
  }

  else
  {
    *((_DWORD *)this + 166) = 1;
  }

LABEL_48:
  std::string::size_type v22 = v22;
  if ((v22 & 0x80u) != 0LL) {
    std::string::size_type v22 = v45.__r_.__value_.__l.__size_;
  }
  if (v22)
  {
    int v36 = this;
    v38.__r_.__value_.__r.__words[0] = v23;
    *(std::string::size_type *)((char *)v38.__r_.__value_.__r.__words + *(void *)(v23 - 24)) = v24;
    uint64_t v25 = (std::ios_base *)((char *)&v38 + *(void *)(v38.__r_.__value_.__r.__words[0] - 24));
    std::ios_base::init(v25, &v38.__r_.__value_.__r.__words[1]);
    v25[1].__vftable = 0LL;
    v25[1].__fmtflags_ = -1;
    std::streambuf::basic_streambuf(&v38.__r_.__value_.__r.__words[1]);
    *(_OWORD *)std::stringbuf::string_type __p = 0u;
    __int128 v41 = 0u;
    int v42 = 16;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v38, (uint64_t)"qSymbol:", 8LL);
    std::string::size_type v26 = v45.__r_.__value_.__s.__size_;
    signed __int8 v27 = v45.__r_.__value_.__s.__size_;
    if ((v45.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      std::string::size_type v26 = v45.__r_.__value_.__l.__size_;
    }
    if (v26)
    {
      std::string::size_type v28 = 0LL;
      do
      {
        std::string::size_type v31 = v38.__r_.__value_.__r.__words[0];
        uint64_t v32 = (char *)&v38 + *(void *)(v38.__r_.__value_.__r.__words[0] - 24);
        if (*((_DWORD *)v32 + 36) == -1)
        {
          std::ios_base::getloc((const std::ios_base *)((char *)&v38 + *(void *)(v38.__r_.__value_.__r.__words[0] - 24)));
          int v33 = std::locale::use_facet((const std::locale *)&v37, &std::ctype<char>::id);
          ((void (*)(const std::locale::facet *, uint64_t))v33->__vftable[2].~facet_0)(v33, 32LL);
          std::locale::~locale((std::locale *)&v37);
          std::string::size_type v31 = v38.__r_.__value_.__r.__words[0];
          signed __int8 v27 = v45.__r_.__value_.__s.__size_;
        }

        *((_DWORD *)v32 + 36) = 48;
        *(_DWORD *)((char *)&v38.__r_.__value_.__r.__words[1] + *(void *)(v31 - 24)) = *(_DWORD *)((_BYTE *)&v38.__r_.__value_.__r.__words[1] + *(void *)(v31 - 24)) & 0xFFFFFFB5 | 8;
        *(_DWORD *)((char *)&v38.__r_.__value_.__r.__words[1] + *(void *)(v31 - 24)) = *(_DWORD *)((_BYTE *)&v38.__r_.__value_.__r.__words[1] + *(void *)(v31 - 24)) & 0xFFFFFF4F | 0x80;
        *(void *)&v39[*(void *)(v31 - 24)] = 2LL;
        if (v27 >= 0) {
          int v29 = &v45;
        }
        else {
          int v29 = (std::string *)v45.__r_.__value_.__r.__words[0];
        }
        std::ostream::operator<<(&v38, v29->__r_.__value_.__s.__data_[v28++]);
        std::string::size_type v30 = v45.__r_.__value_.__s.__size_;
        signed __int8 v27 = v45.__r_.__value_.__s.__size_;
        if ((v45.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          std::string::size_type v30 = v45.__r_.__value_.__l.__size_;
        }
      }

      while (v28 < v30);
    }

    std::stringbuf::str(&v37, (const std::stringbuf *)&v38.__r_.__value_.__r.__words[1]);
    uint64_t v34 = RNBRemote::SendPacket((uint64_t)v36, &v37);
    *(std::string::size_type *)((char *)v38.__r_.__value_.__r.__words
    if (SBYTE7(v41) < 0) {
      operator delete(__p[0]);
    }
    std::streambuf::~streambuf(&v38.__r_.__value_.__r.__words[1]);
    std::ios::~ios(&v43);
    if ((char)v44.__r_.__value_.__s.__size_ < 0)
    {
LABEL_74:
      operator delete(v44.__r_.__value_.__l.__data_);
      return v34;
    }
  }

  else
  {
    v38.__r_.__value_.__s.__size_ = 2;
    strcpy((char *)&v38, "OK");
    uint64_t v34 = RNBRemote::SendPacket((uint64_t)this, &v38);
    if ((char)v38.__r_.__value_.__s.__size_ < 0)
    {
      operator delete(v38.__r_.__value_.__l.__data_);
    }

    else if ((char)v44.__r_.__value_.__s.__size_ < 0)
    {
      goto LABEL_74;
    }
  }

  if ((char)v45.__r_.__value_.__s.__size_ < 0) {
LABEL_75:
  }
    operator delete(v45.__r_.__value_.__l.__data_);
  return v34;
}

      std::string v38 = (uint64_t *)v34;
      uint64_t v34 = (uint64_t **)operator new(0x38uLL);
      v34[5] = 0LL;
      v34[6] = 0LL;
      v34[4] = v13;
      void *v34 = 0LL;
      v34[1] = 0LL;
      v34[2] = v38;
      *int v36 = (uint64_t *)v34;
      size_t v39 = **((void **)this + 10);
      uint64_t v40 = (uint64_t *)v34;
      if (v39)
      {
        *((void *)this + 10) = v39;
        uint64_t v40 = *v36;
      }

      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 11), v40);
      ++*((void *)this + 12);
      do
LABEL_51:
        __int128 v41 = __ldxr(p_shared_owners);
      while (__stxr(v41 + 1, p_shared_owners));
      int v42 = (std::__shared_weak_count *)v34[6];
      v34[5] = (uint64_t *)v15;
      v34[6] = (uint64_t *)v16;
      if (v42)
      {
        uint64_t v43 = (unint64_t *)&v42->__shared_owners_;
        do
          std::string v44 = __ldaxr(v43);
        while (__stlxr(v44 - 1, v43));
        if (!v44)
        {
          ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
          std::__shared_weak_count::__release_weak(v42);
        }
      }

      do
        std::string v45 = __ldaxr(p_shared_owners);
      while (__stlxr(v45 - 1, p_shared_owners));
      if (v45)
      {
LABEL_59:
        unsigned int v46 = (uint64_t *)v10[1];
        if (!v46) {
          goto LABEL_63;
        }
      }

      else
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
        unsigned int v46 = (uint64_t *)v10[1];
        if (!v46)
        {
          do
          {
LABEL_63:
            uint64_t v47 = (uint64_t *)v10[2];
            uint64_t v48 = *v47 == (void)v10;
            int v10 = v47;
          }

          while (!v48);
          goto LABEL_14;
        }
      }

      do
      {
        uint64_t v47 = v46;
        unsigned int v46 = (uint64_t *)*v46;
      }

      while (v46);
LABEL_14:
      int v10 = v47;
    }

    while (v47 != v62 + 6);
  }

  DNBError::LogThreaded(a13, "::posix_spawn_file_actions_init(&file_actions)");
  int v42 = 0;
  if (!v30)
  {
LABEL_59:
    AvailablePrimary = -1;
    if (!a7 && !a8 && !a9)
    {
      if ((a10 & 1) != 0)
      {
        a8 = 0LL;
        uint64_t v19 = 0LL;
        AvailablePrimary = -1;
        goto LABEL_70;
      }

      AvailablePrimary = PseudoTerminal::OpenFirstAvailablePrimary((PseudoTerminal *)&v44, 131074);
      if (AvailablePrimary)
      {
        a8 = 0LL;
        uint64_t v19 = 0LL;
        goto LABEL_70;
      }

      uint64_t v19 = PseudoTerminal::SecondaryName((PseudoTerminal *)&v44);
      AvailablePrimary = 0;
      a8 = v19;
      a7 = v19;
    }

    if ((a10 & 1) == 0 && a7 && *a7)
    {
LABEL_71:
      uint64_t v32 = posix_spawn_file_actions_addopen(&v43, 0, a7, 0x20000, 0);
      *(_DWORD *)a13 = v32;
      *((_DWORD *)a13 + 1) = 2;
      if (*((char *)a13 + 31) < 0)
      {
        **((_BYTE **)a13 + 1) = 0;
        *((void *)a13 + 2) = 0LL;
        if (!*(_DWORD *)a13) {
          goto LABEL_83;
        }
      }

      else
      {
        *((_BYTE *)a13 + 8) = 0;
        *((_BYTE *)a13 + 31) = 0;
        if (!v32)
        {
LABEL_83:
          if (!DNBLogCheckLogBit(2)) {
            goto LABEL_85;
          }
        }
      }

      DNBError::LogThreaded( a13,  "::posix_spawn_file_actions_addopen (&file_actions, filedes=STDIN_FILENO, path='%s')",  a7);
LABEL_85:
      int v33 = posix_spawn_file_actions_addopen(&v43, 1, a8, 131585, 0x1A0u);
      *(_DWORD *)a13 = v33;
      *((_DWORD *)a13 + 1) = 2;
      if (*((char *)a13 + 31) < 0)
      {
        **((_BYTE **)a13 + 1) = 0;
        *((void *)a13 + 2) = 0LL;
        if (!*(_DWORD *)a13) {
          goto LABEL_89;
        }
      }

      else
      {
        *((_BYTE *)a13 + 8) = 0;
        *((_BYTE *)a13 + 31) = 0;
        if (!v33)
        {
LABEL_89:
          if (!DNBLogCheckLogBit(2)) {
            goto LABEL_91;
          }
        }
      }

      DNBError::LogThreaded( a13,  "::posix_spawn_file_actions_addopen (&file_actions, filedes=STDOUT_FILENO, path='%s')",  a8);
LABEL_91:
      uint64_t v34 = posix_spawn_file_actions_addopen(&v43, 2, v19, 131585, 0x1A0u);
      *(_DWORD *)a13 = v34;
      *((_DWORD *)a13 + 1) = 2;
      if (*((char *)a13 + 31) < 0)
      {
        **((_BYTE **)a13 + 1) = 0;
        *((void *)a13 + 2) = 0LL;
        if (!*(_DWORD *)a13) {
          goto LABEL_95;
        }
      }

      else
      {
        *((_BYTE *)a13 + 8) = 0;
        *((_BYTE *)a13 + 31) = 0;
        if (!v34)
        {
LABEL_95:
          if (!DNBLogCheckLogBit(2)) {
            goto LABEL_97;
          }
        }
      }

      DNBError::LogThreaded( a13,  "::posix_spawn_file_actions_addopen (&file_actions, filedes=STDERR_FILENO, path='%s')",  v19);
LABEL_97:
      if (a6) {
        chdir((const char *)a6);
      }
      std::string v35 = posix_spawnp(&v42, (const char *)this, &v43, &v47, a4, (char *const *)a5);
      *(_DWORD *)a13 = v35;
      *((_DWORD *)a13 + 1) = 2;
      if (*((char *)a13 + 31) < 0)
      {
        **((_BYTE **)a13 + 1) = 0;
        *((void *)a13 + 2) = 0LL;
        if (*(_DWORD *)a13) {
          goto LABEL_104;
        }
      }

      else
      {
        *((_BYTE *)a13 + 8) = 0;
        *((_BYTE *)a13 + 31) = 0;
        if (v35) {
          goto LABEL_104;
        }
      }

      if (!DNBLogCheckLogBit(2)) {
        goto LABEL_105;
      }
LABEL_104:
      DNBError::LogThreaded( a13,  "::posix_spawnp(pid => %i, path = '%s', file_actions = %p, attr = %p, argv = %p, envp = %p)",  v42,  (const char *)this,  &v43,  &v47,  a4,  a5);
      goto LABEL_105;
    }

    if (*(char *)(a3 + 31) < 0)
    {
      **(_BYTE **)(a3 + 8) = 0;
      *(void *)(a3 + 16) = 0LL;
    }

    else
    {
      *(_BYTE *)(a3 + 8) = 0;
      *(_BYTE *)(a3 + 31) = 0;
    }

uint64_t RNBRemote::HandlePacket_jThreadExtendedInfo(RNBRemote *this, const char *a2)
{
  unint64_t v151 = v4;
  *(void (__cdecl ***)(std::ostringstream *__hidden))((char *)&v151 + (void)*(v4 - 3)) = v5;
  int v6 = (std::ios_base *)((char *)&v151 + (void)*(v151 - 3));
  std::ios_base::init(v6, &v152);
  v6[1].__vftable = 0LL;
  v6[1].__fmtflags_ = -1;
  std::streambuf::basic_streambuf(&v152);
  memset(&v152.__str_, 0, 32);
  uint64_t v7 = this;
  v152.__mode_ = 16;
  int v8 = *((_DWORD *)this + 3);
  if (v8)
  {
    if (!strncmp(a2, "jThreadExtendedInfo:{", 0x15uLL))
    {
      int v10 = a2 + 21;
      uint64_t integer_value_for_key_name_from_json = get_integer_value_for_key_name_from_json("thread", a2 + 21);
      uint64_t v12 = get_integer_value_for_key_name_from_json("plo_pthread_tsd_base_address_offset", a2 + 21);
      uint64_t v13 = get_integer_value_for_key_name_from_json("plo_pthread_tsd_base_offset", v10);
      uint64_t v14 = get_integer_value_for_key_name_from_json("plo_pthread_tsd_entry_size", v10);
      uint64_t v15 = get_integer_value_for_key_name_from_json("dti_qos_class_index", v10);
      if (integer_value_for_key_name_from_json != -1)
      {
        unint64_t v139 = v15;
        unint64_t v145 = integer_value_for_key_name_from_json;
        uint64_t v16 = DNBGetPThreadT(v8, integer_value_for_key_name_from_json);
        uint64_t v17 = v16;
        uint64_t v144 = (uint64_t)v7;
        if (v14 == -1 || v13 == -1)
        {
          BOOL v19 = 0;
          *(_DWORD *)&v142[8] = 0;
          int v29 = 0LL;
          BOOL v150 = 0;
          *(void *)BOOL v142 = v16 != -1;
          double v20 = 0.0;
          uint64_t v138 = -1LL;
        }

        else
        {
          uint64_t v18 = DNBGetTSDAddressForThread(v8, integer_value_for_key_name_from_json, v12, v13, v14);
          BOOL v150 = 0;
          BOOL v19 = v18 != -1;
          double v20 = 0.0;
          uint64_t v138 = v18;
          if (v17 == -1 || v18 == -1)
          {
            v142[0] = v17 != -1;
            *(void *)&v142[4] = 0LL;
            int v29 = 0LL;
          }

          else
          {
            uint64_t v140 = v17;
            __str.__r_.__value_.__r.__words[0] = 0LL;
            gettimeofday((timeval *)&__str.__r_.__value_.__r.__words[1], 0LL);
            int v21 = v8;
            DNBGetGenealogyInfoForThread(&v150, v8, integer_value_for_key_name_from_json, &v147);
            __darwin_time_t tv_sec = v147.tv_sec;
            *(void *)&v142[4] = *(void *)&v147.tv_usec;
            std::string::size_type v23 = (pthread_mutex_t *)__str.__r_.__value_.__r.__words[0];
            if (__str.__r_.__value_.__r.__words[0]) {
              pthread_mutex_lock((pthread_mutex_t *)__str.__r_.__value_.__l.__data_);
            }
            gettimeofday(&v147, 0LL);
            __darwin_time_t v24 = v147.tv_sec;
            uint64_t tv_usec = v147.tv_usec;
            std::string::size_type size = __str.__r_.__value_.__l.__size_;
            uint64_t v27 = SLODWORD(__str.__r_.__value_.__r.__words[2]);
            if (v23) {
              pthread_mutex_unlock(v23);
            }
            double v28 = (double)(tv_usec - v27 + 1000000 * (v24 - size));
            int v8 = v21;
            int v29 = (const std::string *)tv_sec;
            uint64_t v17 = v140;
            if (v23)
            {
              if (pthread_mutex_destroy(v23) && !pthread_mutex_unlock(v23)) {
                pthread_mutex_destroy(v23);
              }
              operator delete(v23);
            }

            BOOL v19 = 1;
            v142[0] = 1;
            double v20 = v28 / 1000000.0;
          }
        }

        timeval v147 = (timeval)0;
        *(_OWORD *)uint64_t v148 = 0u;
        int v149 = 1065353216;
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v151, (uint64_t)"{", 1LL);
        BOOL v143 = v19;
        if (!v29 || v150)
        {
          uint64_t v34 = v145;
          if (!v150)
          {
            if (!v19)
            {
              if ((v142[0] & 1) == 0)
              {
                uint64_t v39 = DNBGetDispatchQueueT(v8, v145);
                if (v39 == -1) {
                  goto LABEL_162;
                }
                goto LABEL_161;
              }

              goto LABEL_39;
            }

            goto LABEL_134;
          }

          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v151,  (uint64_t)"activity_query_timed_out:true",  31LL);
          if (v20 != 0.0)
          {
            __str.__r_.__value_.__s.__data_[0] = 0;
            snprintf((char *)&__str, 0x40uLL, "%f", v20);
            if (__str.__r_.__value_.__s.__data_[0])
            {
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v151, (uint64_t)",", 1LL);
              std::string v35 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v151,  (uint64_t)"activity_query_duration:",  26LL);
              size_t v36 = strlen((const char *)&__str);
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v35, (uint64_t)&__str, v36);
            }
          }

          BOOL v37 = 1;
          if (v143)
          {
LABEL_132:
            if (v37) {
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v151, (uint64_t)",", 1LL);
            }
LABEL_134:
            std::string v110 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v151,  (uint64_t)"tsd_address:",  14LL);
            std::ostream::operator<<(v110, v138);
            if (v139 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
            {
              DNBGetRequestedQoSForThread(v8, v34, v138, v139, (uint64_t)&__str);
              if (v156 != -1)
              {
                std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v151, (uint64_t)",", 1LL);
                std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v151,  (uint64_t)"requested_qos:{",  17LL);
                __int128 v111 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v151,  (uint64_t)"enum_value:",  13LL);
                int64_t v112 = (void *)std::ostream::operator<<(v111, v156);
                std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v112, (uint64_t)",", 1LL);
                std::string v113 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v151,  (uint64_t)"constant_name:",  17LL);
                json_string_quote_metachars(&__str, &__p);
                if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                  p_p = &__p;
                }
                else {
                  p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
                }
                if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                  uint64_t v115 = __p.__r_.__value_.__s.__size_;
                }
                else {
                  uint64_t v115 = __p.__r_.__value_.__l.__size_;
                }
                unint64_t v116 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( v113,  (uint64_t)p_p,  v115);
                std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v116, (uint64_t)",", 2LL);
                __int128 v117 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v151,  (uint64_t)"printable_name:",  18LL);
                json_string_quote_metachars(&v155, &__p);
                if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                  __int128 v118 = &__p;
                }
                else {
                  __int128 v118 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
                }
                if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                  uint64_t v119 = __p.__r_.__value_.__s.__size_;
                }
                else {
                  uint64_t v119 = __p.__r_.__value_.__l.__size_;
                }
                uint64_t v120 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( v117,  (uint64_t)v118,  v119);
                std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v120, (uint64_t)"", 1LL);
                std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v151, (uint64_t)"}", 1LL);
                uint64_t v34 = v145;
              }
            }

            BOOL v37 = 1;
            if ((v142[0] & 1) == 0)
            {
LABEL_158:
              uint64_t v121 = DNBGetDispatchQueueT(v8, v34);
              if (v121 == -1)
              {
LABEL_162:
                std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v151, (uint64_t)"}", 1LL);
                unint64_t v123 = &__p;
                std::stringbuf::str(&__p, &v152);
                memset(&__str, 0, sizeof(__str));
                unsigned __int8 v124 = __p.__r_.__value_.__s.__size_;
                if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                  std::string::size_type v125 = __p.__r_.__value_.__s.__size_;
                }
                else {
                  std::string::size_type v125 = __p.__r_.__value_.__l.__size_;
                }
                if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                  unint64_t v123 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
                }
                if (v125)
                {
                  do
                  {
                    unsigned int v127 = v123->__r_.__value_.__s.__data_[0];
                    unint64_t v123 = (std::stringbuf::string_type *)((char *)v123 + 1);
                    unsigned int v126 = v127;
                    uint64_t v128 = (1LL << v127) & 0x41800000000LL;
                    BOOL v129 = v127 > 0x2A || v128 == 0;
                    if (!v129 || v126 == 125)
                    {
                      std::string::push_back(&__str, 125);
                      LOBYTE(v126) = v126 ^ 0x20;
                    }

                    std::string::push_back(&__str, v126);
                    --v125;
                  }

                  while (v125);
                  unsigned __int8 v124 = __p.__r_.__value_.__s.__size_;
                }

                if ((v124 & 0x80) != 0) {
                  operator delete(__p.__r_.__value_.__l.__data_);
                }
                uint64_t v9 = RNBRemote::SendPacket(v144, &__str);
                unint64_t v130 = v148[0];
                if (v148[0])
                {
                  do
                  {
                    __int128 v131 = (void *)*v130;
                    operator delete(v130);
                    unint64_t v130 = v131;
                  }

                  while (v131);
                }

                __int128 v132 = (void *)v147.tv_sec;
                v147.__darwin_time_t tv_sec = 0LL;
                if (v132) {
                  operator delete(v132);
                }
                if (*(void *)&v142[4])
                {
                  __int128 v133 = (unint64_t *)(*(void *)&v142[4] + 8LL);
                  do
                    unint64_t v134 = __ldaxr(v133);
                  while (__stlxr(v134 - 1, v133));
                  if (!v134)
                  {
                    (*(void (**)(void))(**(void **)&v142[4] + 16LL))(*(void *)&v142[4]);
                    std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&v142[4]);
                  }
                }

                goto LABEL_192;
              }

              uint64_t v39 = v121;
              if (!v37)
              {
LABEL_161:
                int v122 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v151,  (uint64_t)"dispatch_queue_t:",  19LL);
                std::ostream::operator<<(v122, v39);
                goto LABEL_162;
              }

LABEL_160:
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v151, (uint64_t)",", 1LL);
              goto LABEL_161;
            }

            goto LABEL_37;
          }

LABEL_36:
          if ((v142[0] & 1) == 0) {
            goto LABEL_158;
          }
LABEL_37:
          if (v37) {
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v151, (uint64_t)",", 1LL);
          }
LABEL_39:
          std::string v38 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v151,  (uint64_t)"pthread_t:",  12LL);
          std::ostream::operator<<(v38, v17);
          uint64_t v39 = DNBGetDispatchQueueT(v8, v34);
          if (v39 == -1) {
            goto LABEL_162;
          }
          goto LABEL_160;
        }

        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v151,  (uint64_t)"activity_query_timed_out:false,",  33LL);
        int v137 = v8;
        uint64_t v141 = v17;
        int v136 = v29;
        if (v20 == 0.0)
        {
          if (v29->__r_.__value_.__l.__size_)
          {
LABEL_50:
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v151,  (uint64_t)"activity:{",  12LL);
            uint64_t v40 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v151,  (uint64_t)"start:",  8LL);
            __int128 v41 = (void *)std::ostream::operator<<(v40, v29->__r_.__value_.__r.__words[0]);
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v41, (uint64_t)",", 1LL);
            int v42 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v151,  (uint64_t)"id:",  5LL);
            uint64_t v43 = (void *)std::ostream::operator<<(v42, v29->__r_.__value_.__l.__size_);
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v43, (uint64_t)",", 1LL);
            std::string v44 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v151,  (uint64_t)"parent_id:",  12LL);
            std::string v45 = (void *)std::ostream::operator<<(v44, v29->__r_.__value_.__l.__cap_);
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v45, (uint64_t)",", 1LL);
            unsigned int v46 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v151,  (uint64_t)"name:",  8LL);
            json_string_quote_metachars(v29 + 1, &__str);
            if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
              p_str = &__str;
            }
            else {
              p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
            }
            if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
              uint64_t v48 = __str.__r_.__value_.__s.__size_;
            }
            else {
              uint64_t v48 = __str.__r_.__value_.__l.__size_;
            }
            size_t v49 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v46, (uint64_t)p_str, v48);
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v49, (uint64_t)",", 2LL);
            size_t v50 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v151,  (uint64_t)"reason:",  10LL);
            json_string_quote_metachars(v29 + 2, &__str);
            if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
              unsigned int v51 = &__str;
            }
            else {
              unsigned int v51 = (std::string *)__str.__r_.__value_.__r.__words[0];
            }
            if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
              uint64_t v52 = __str.__r_.__value_.__s.__size_;
            }
            else {
              uint64_t v52 = __str.__r_.__value_.__l.__size_;
            }
            int v53 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v50, (uint64_t)v51, v52);
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v53, (uint64_t)"", 1LL);
            int v54 = 1;
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v151, (uint64_t)"}", 1LL);
            std::string::pointer data = v29[3].__r_.__value_.__l.__data_;
            unint64_t v55 = (std::string::__raw *)&v29[3];
            uint64_t v57 = (const std::string **)&v55->__words[1];
            if ((std::string::pointer)v55->__words[1] != data)
            {
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v151, (uint64_t)",", 1LL);
              goto LABEL_69;
            }

            int v33 = 1;
LABEL_86:
            std::string::size_type v80 = (unsigned int **)&v136[4];
            p_std::string::size_type size = (unsigned int **)&v136[4].__r_.__value_.__l.__size_;
            if (v136[4].__r_.__value_.__l.__size_ - v136[4].__r_.__value_.__r.__words[0] != 48) {
              goto LABEL_102;
            }
            if (!v54) {
              goto LABEL_89;
            }
            goto LABEL_88;
          }

          int v33 = 0;
        }

        else
        {
          __str.__r_.__value_.__s.__data_[0] = 0;
          snprintf((char *)&__str, 0x40uLL, "%f", v20);
          int v30 = __str.__r_.__value_.__s.__data_[0];
          if (__str.__r_.__value_.__s.__data_[0])
          {
            std::string::size_type v31 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v151,  (uint64_t)"activity_query_duration:",  26LL);
            size_t v32 = strlen((const char *)&__str);
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v31, (uint64_t)&__str, v32);
            int v33 = 1;
            if (!v29->__r_.__value_.__l.__size_) {
              goto LABEL_68;
            }
            goto LABEL_48;
          }

          int v33 = 0;
          if (v29->__r_.__value_.__l.__size_)
          {
LABEL_48:
            if (v30) {
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v151, (uint64_t)",", 1LL);
            }
            goto LABEL_50;
          }
        }

        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 3));
        if (v59[0])
        {
          uint64_t v25 = (char *)__p[1];
          if (__p[1] >= v63) {
            goto LABEL_61;
          }
          *(void *)__p[1] = v59[0];
          std::string::size_type v26 = v59[1];
          *((void *)v25 + 1) = v59[1];
          if (v26)
          {
            uint64_t v27 = (unint64_t *)(v26 + 8);
            do
              double v28 = __ldxr(v27);
            while (__stxr(v28 + 1, v27));
          }
        }

        else
        {
          int v29 = operator new(0x198uLL);
          v29[1] = 0LL;
          v29[2] = 0LL;
          *int v29 = off_100061600;
          int v30 = MachThread::MachThread( (MachThread *)(v29 + 3),  a2,  *((_BYTE *)a1 + 104),  GloballyUniqueThreadIDForMachPortID,  v16);
          std::string::size_type v31 = (std::__shared_weak_count *)v59[1];
          v59[0] = (size_t)v30;
          v59[1] = (size_t)v29;
          if (v31)
          {
            p_shared_owners = (unint64_t *)&v31->__shared_owners_;
            do
              int v33 = __ldaxr(p_shared_owners);
            while (__stlxr(v33 - 1, p_shared_owners));
            if (!v33)
            {
              ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
              std::__shared_weak_count::__release_weak(v31);
            }
          }

          if (!MachThread::IsUserReady((MachThread *)v59[0])) {
            goto LABEL_63;
          }
          if (a4)
          {
            uint64_t v34 = *(void **)(a4 + 8);
            if ((unint64_t)v34 >= *(void *)(a4 + 16))
            {
              std::string v38 = std::vector<std::shared_ptr<JSONGenerator::Object>>::__push_back_slow_path<std::shared_ptr<JSONGenerator::Object> const&>( a4,  (__int128 *)v59);
            }

            else
            {
              void *v34 = v59[0];
              std::string v35 = v59[1];
              v34[1] = v59[1];
              if (v35)
              {
                size_t v36 = (unint64_t *)(v35 + 8);
                do
                  BOOL v37 = __ldxr(v36);
                while (__stxr(v37 + 1, v36));
              }

              std::string v38 = v34 + 2;
            }

            *(void *)(a4 + 8) = v38;
          }

          uint64_t v25 = (char *)__p[1];
          if (__p[1] >= v63)
          {
LABEL_61:
            int v42 = std::vector<std::shared_ptr<JSONGenerator::Object>>::__push_back_slow_path<std::shared_ptr<JSONGenerator::Object> const&>( (uint64_t)__p,  (__int128 *)v59);
            goto LABEL_62;
          }

          *(void *)__p[1] = v59[0];
          uint64_t v39 = v59[1];
          *((void *)v25 + 1) = v59[1];
          if (v39)
          {
            uint64_t v40 = (unint64_t *)(v39 + 8);
            do
              __int128 v41 = __ldxr(v40);
            while (__stxr(v41 + 1, v40));
          }
        }

        int v42 = v25 + 16;
LABEL_62:
        __p[1] = v42;
LABEL_63:
        uint64_t v43 = (std::__shared_weak_count *)v59[1];
        if (v59[1])
        {
          std::string v44 = (unint64_t *)(v59[1] + 8);
          do
            std::string v45 = __ldaxr(v44);
          while (__stlxr(v45 - 1, v44));
          if (!v45)
          {
            ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
            std::__shared_weak_count::__release_weak(v43);
          }
        }

        if (++v15 >= (unint64_t)act_listCnt)
        {
          unsigned int v46 = (uint64_t)v63;
          uint64_t v47 = *(_OWORD *)a1;
          *(_OWORD *)a1 = *(_OWORD *)__p;
          *(_OWORD *)std::stringbuf::string_type __p = v47;
          uint64_t v48 = (void *)a1[2];
          a1[2] = v46;
          unsigned int v63 = v48;
          size_t v49 = (std::__shared_weak_count *)a1[12];
          a1[11] = 0LL;
          a1[12] = 0LL;
          if (v49)
          {
            size_t v50 = (unint64_t *)&v49->__shared_owners_;
            do
              unsigned int v51 = __ldaxr(v50);
            while (__stlxr(v51 - 1, v50));
            if (!v51)
            {
              ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
              std::__shared_weak_count::__release_weak(v49);
            }
          }

          vm_deallocate(mach_task_self_, (vm_address_t)act_list, 4LL * act_listCnt);
          uint64_t v52 = (char *)__p[0];
          if (__p[0])
          {
            int v53 = (char *)__p[1];
            int v54 = __p[0];
            if (__p[1] != __p[0])
            {
              do
              {
                unint64_t v55 = (std::__shared_weak_count *)*((void *)v53 - 1);
                if (v55)
                {
                  std::stringbuf v56 = (unint64_t *)&v55->__shared_owners_;
                  do
                    uint64_t v57 = __ldaxr(v56);
                  while (__stlxr(v57 - 1, v56));
                  if (!v57)
                  {
                    ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
                    std::__shared_weak_count::__release_weak(v55);
                  }
                }

                v53 -= 16;
              }

              while (v53 != v52);
              int v54 = __p[0];
            }

            __p[1] = v52;
            operator delete(v54);
          }

          break;
        }
      }
    }

    if (SHIBYTE(v67) < 0) {
      operator delete(v65);
    }
    unsigned int v11 = *a1;
    int v10 = a1[1];
  }

  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 3));
  return (unint64_t)(v10 - v11) >> 4;
}

LABEL_68:
        std::string::pointer v58 = v29[3].__r_.__value_.__l.__data_;
        unint64_t v55 = (std::string::__raw *)&v29[3];
        uint64_t v57 = (const std::string **)&v55->__words[1];
        if ((std::string::pointer)v55->__words[1] != v58)
        {
LABEL_69:
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v151,  (uint64_t)"trace_messages:[",  18LL);
          uint64_t v59 = (const std::string *)v55->__words[0];
          if (v59 != *v57)
          {
            char v60 = 0;
            do
            {
              if ((v60 & 1) != 0) {
                std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v151, (uint64_t)",", 1LL);
              }
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v151, (uint64_t)"{", 1LL);
              uint64_t v61 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v151,  (uint64_t)"timestamp:",  12LL);
              __int16 v62 = (void *)std::ostream::operator<<(v61, v59->__r_.__value_.__r.__words[0]);
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v62, (uint64_t)",", 1LL);
              unsigned int v63 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v151,  (uint64_t)"activity_id:",  14LL);
              unsigned int v64 = (void *)std::ostream::operator<<(v63, v59->__r_.__value_.__l.__size_);
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v64, (uint64_t)",", 1LL);
              std::string::size_type v65 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v151,  (uint64_t)"trace_id:",  11LL);
              unint64_t v66 = (void *)std::ostream::operator<<(v65, v59->__r_.__value_.__l.__cap_);
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v66, (uint64_t)",", 1LL);
              uint64_t v67 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v151,  (uint64_t)"thread:",  9LL);
              uint64_t v68 = (void *)std::ostream::operator<<(v67, v59[1].__r_.__value_.__r.__words[0]);
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v68, (uint64_t)",", 1LL);
              std::string::size_type v69 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v151,  (uint64_t)"type:",  7LL);
              __int128 v70 = (void *)std::ostream::operator<<(v69, v59[1].__r_.__value_.__s.__data_[8]);
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v70, (uint64_t)",", 1LL);
              uint64_t v71 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v151,  (uint64_t)"process_info_index:",  21LL);
              unsigned int v73 = HIDWORD(v59[1].__r_.__value_.__r.__words[1]);
              BOOL v72 = (unsigned int *)&v59[1].__r_.__value_.__r.__words[1] + 1;
              unint64_t v74 = (void *)std::ostream::operator<<(v71, v73);
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v74, (uint64_t)",", 1LL);
              std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>( (uint64_t)&v147,  v72,  v72);
              uid_t v75 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v151,  (uint64_t)"message:",  11LL);
              __int128 v76 = (const std::string *)(v72 + 1);
              json_string_quote_metachars(v76, &__str);
              if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                int v77 = &__str;
              }
              else {
                int v77 = (std::string *)__str.__r_.__value_.__r.__words[0];
              }
              if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                uint64_t v78 = __str.__r_.__value_.__s.__size_;
              }
              else {
                uint64_t v78 = __str.__r_.__value_.__l.__size_;
              }
              unint64_t v79 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v75, (uint64_t)v77, v78);
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)"", 1LL);
              char v60 = 1;
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v151, (uint64_t)"}", 1LL);
              uint64_t v59 = v76 + 1;
            }

            while (v59 != *v57);
          }

          int v54 = 1;
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v151, (uint64_t)"]", 1LL);
          std::string::size_type v80 = (unsigned int **)&v136[4];
          p_std::string::size_type size = (unsigned int **)&v136[4].__r_.__value_.__l.__size_;
          if (v136[4].__r_.__value_.__l.__size_ - v136[4].__r_.__value_.__r.__words[0] != 48)
          {
            int v33 = 1;
LABEL_101:
            uint64_t v17 = v141;
LABEL_102:
            int v8 = v137;
            if (v148[1])
            {
              if (v54) {
                std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v151, (uint64_t)",", 1LL);
              }
              int v94 = (void **)v148[0];
              if (v148[0])
              {
                char v95 = 0;
                do
                {
                  if ((v95 & 1) != 0) {
                    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v151, (uint64_t)",", 1LL);
                  }
                  uint64_t v96 = *((unsigned int *)v94 + 4);
                  v97.n128_f64[0] = DNBGetGenealogyImageInfo(v137, v96, &__str);
                  __int128 v98 = *(_OWORD *)&__str.__r_.__value_.__l.__data_;
                  if (__str.__r_.__value_.__r.__words[0])
                  {
                    if ((v95 & 1) == 0) {
                      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v151,  (uint64_t)"process_infos:[",  17LL);
                    }
                    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v151, (uint64_t)"{", 1LL);
                    uuid_unparse_upper((const unsigned __int8 *)(v98 + 24), (char *)&__str);
                    uint64_t v99 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v151,  (uint64_t)"process_info_index:",  21LL);
                    std::string::size_type v100 = (void *)std::ostream::operator<<(v99, v96);
                    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v100, (uint64_t)",", 1LL);
                    uint64_t v101 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v151,  (uint64_t)"image_path:",  14LL);
                    json_string_quote_metachars((const std::string *)v98, &__p);
                    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                      uint64_t v102 = &__p;
                    }
                    else {
                      uint64_t v102 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
                    }
                    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                      uint64_t v103 = __p.__r_.__value_.__s.__size_;
                    }
                    else {
                      uint64_t v103 = __p.__r_.__value_.__l.__size_;
                    }
                    uint64_t v104 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( v101,  (uint64_t)v102,  v103);
                    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v104, (uint64_t)",", 2LL);
                    uint64_t v105 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v151,  (uint64_t)"image_uuid:",  14LL);
                    size_t v106 = strlen((const char *)&__str);
                    uint64_t v107 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( v105,  (uint64_t)&__str,  v106);
                    char v95 = 1;
                    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v107, (uint64_t)"", 1LL);
                    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v151, (uint64_t)"}", 1LL);
                  }

                  if (*((void *)&v98 + 1))
                  {
                    std::string v108 = (unint64_t *)(*((void *)&v98 + 1) + 8LL);
                    do
                      unint64_t v109 = __ldaxr(v108);
                    while (__stlxr(v109 - 1, v108));
                    if (!v109)
                    {
                      (*(void (**)(void, __n128))(**((void **)&v98 + 1) + 16LL))( *((void *)&v98 + 1),  v97);
                      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v98 + 1));
                    }
                  }

                  int v94 = (void **)*v94;
                }

                while (v94);
                uint64_t v17 = v141;
                if ((v95 & 1) != 0)
                {
                  int v33 = 1;
                  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v151, (uint64_t)"]", 1LL);
                }

                else
                {
                  int v33 = 1;
                }
              }

              else
              {
                int v33 = 1;
              }
            }

            BOOL v37 = v33 != 0;
            uint64_t v34 = v145;
            if (v143) {
              goto LABEL_132;
            }
            goto LABEL_36;
          }

    if (*(void *)v11 == 0x4552415754464F53LL)
    {
      uint64_t v4 = 32LL;
      goto LABEL_88;
    }

    goto LABEL_69;
  }

  uint64_t v13 = *((void *)&__dst + 1);
  if (*((void *)&__dst + 1) == 10LL && *(void *)__dst == 0x454343415F444142LL && *(_WORD *)(__dst + 8) == 21331)
  {
LABEL_50:
    uint64_t v4 = 2LL;
    goto LABEL_88;
  }

  if (*((void *)&__dst + 1) == 15LL)
  {
    if (*(void *)__dst == 0x54534E495F444142LL && *(void *)(__dst + 7) == 0x4E4F495443555254LL)
    {
LABEL_65:
      uint64_t v4 = 4LL;
      goto LABEL_88;
    }

    uint64_t v13 = *((void *)&__dst + 1);
  }

  if (v13 == 10)
  {
    if (*(void *)__dst == 0x54454D4854495241LL && *(_WORD *)(__dst + 8) == 17225)
    {
LABEL_76:
      uint64_t v4 = 8LL;
      goto LABEL_88;
    }

    uint64_t v13 = *((void *)&__dst + 1);
  }

  if (v13 == 9)
  {
    if (*(void *)__dst == 0x4F4954414C554D45LL && *(_BYTE *)(__dst + 8) == 78)
    {
LABEL_66:
      uint64_t v4 = 16LL;
      goto LABEL_88;
    }

    uint64_t v13 = *((void *)&__dst + 1);
  }

  if (v13 == 8)
  {
    unsigned int v11 = (__int128 *)__dst;
    goto LABEL_68;
  }

LABEL_88:
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v151, (uint64_t)",", 1LL);
LABEL_89:
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v151,  (uint64_t)"breadcrumb:{",  14LL);
          __int128 v82 = (const std::string *)*v80;
          if (*v80 != *p_size)
          {
            do
            {
              __int128 v83 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v151,  (uint64_t)"breadcrumb_id:",  16LL);
              std::string::size_type v84 = (void *)std::ostream::operator<<(v83, LODWORD(v82->__r_.__value_.__l.__data_));
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v84, (uint64_t)",", 1LL);
              uint64_t v85 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v151,  (uint64_t)"activity_id:",  14LL);
              std::string::size_type v86 = (void *)std::ostream::operator<<(v85, v82->__r_.__value_.__l.__size_);
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v86, (uint64_t)",", 1LL);
              int v87 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v151,  (uint64_t)"timestamp:",  12LL);
              std::string::size_type v88 = (void *)std::ostream::operator<<(v87, v82->__r_.__value_.__l.__cap_);
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v88, (uint64_t)",", 1LL);
              __int128 v89 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v151,  (uint64_t)"name:",  8LL);
              std::string::size_type v90 = v82 + 1;
              json_string_quote_metachars(v90, &__str);
              if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                __int128 v91 = &__str;
              }
              else {
                __int128 v91 = (std::string *)__str.__r_.__value_.__r.__words[0];
              }
              if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                uint64_t v92 = __str.__r_.__value_.__s.__size_;
              }
              else {
                uint64_t v92 = __str.__r_.__value_.__l.__size_;
              }
              std::string::size_type v93 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v89, (uint64_t)v91, v92);
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v93, (uint64_t)"", 1LL);
              __int128 v82 = v90 + 1;
            }

            while (v82 != (const std::string *)*p_size);
          }

          int v33 = 1;
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v151, (uint64_t)"}", 1LL);
          int v54 = 1;
          goto LABEL_101;
        }

        int v54 = 0;
        goto LABEL_86;
      }
    }

    __str.__r_.__value_.__s.__size_ = 2;
    strcpy((char *)&__str, "OK");
    uint64_t v9 = RNBRemote::SendPacket((uint64_t)v7, &__str);
  }

  else
  {
    __str.__r_.__value_.__s.__size_ = 3;
    strcpy((char *)&__str, "E81");
    uint64_t v9 = RNBRemote::SendPacket((uint64_t)this, &__str);
  }

  if (SHIBYTE(v23) < 0) {
    operator delete((void *)__dst);
  }
  return v4;
}

LABEL_192:
  std::streambuf::~streambuf(&v152);
  std::ios::~ios(&v153);
  return v9;
}

std::string::size_type RNBRemote::HandlePacket_jGetLoadedDynamicLibrariesInfos( RNBRemote *this, const char *__s1)
{
  int v4 = *((_DWORD *)this + 3);
  if (!v4)
  {
    v18[0].__r_.__value_.__s.__size_ = 3;
    LODWORD(v18[0].__r_.__value_.__l.__data_) = 3356741;
    goto LABEL_33;
  }

  if (strncmp(__s1, "jGetLoadedDynamicLibrariesInfos:{", 0x21uLL))
  {
LABEL_32:
    v18[0].__r_.__value_.__s.__size_ = 2;
    strcpy((char *)v18, "OK");
LABEL_33:
    std::string::size_type v2 = RNBRemote::SendPacket((uint64_t)this, v18);
    return v2;
  }

  int v6 = __s1 + 33;
  uint64_t v25 = 0LL;
  std::string::size_type v26 = 0LL;
  uint64_t v27 = 0LL;
  BOOL v24 = 0;
  BOOL v23 = 1;
  get_BOOLean_value_for_key_name_from_json("report_load_commands", v6, &v23);
  if (get_BOOLean_value_for_key_name_from_json("fetch_all_solibs", v6, &v24) && v24)
  {
    DNBGetAllLoadedLibrariesInfos(v4, v23, (uint64_t)v18);
    std::string::size_type size = (std::__shared_weak_count *)v18[0].__r_.__value_.__l.__size_;
    std::string::size_type v2 = v18[0].__r_.__value_.__r.__words[0];
    if (!v18[0].__r_.__value_.__r.__words[0]) {
      goto LABEL_24;
    }
  }

  else
  {
    if (!get_array_of_ints_value_for_key_name_from_json("solib_addresses", v6, (uint64_t)&v25))
    {
      std::string::size_type size = 0LL;
      goto LABEL_24;
    }

    DNBGetLibrariesInfoForAddresses(v4, &v25, (uint64_t)v18);
    std::string::size_type size = (std::__shared_weak_count *)v18[0].__r_.__value_.__l.__size_;
    std::string::size_type v2 = v18[0].__r_.__value_.__r.__words[0];
    if (!v18[0].__r_.__value_.__r.__words[0]) {
      goto LABEL_24;
    }
  }

  v18[0].__r_.__value_.__r.__words[0] = v8;
  *(std::string::size_type *)((char *)v18[0].__r_.__value_.__r.__words + *(void *)(v8 - 24)) = v9;
  int v10 = (std::ios_base *)((char *)v18 + *(void *)(v18[0].__r_.__value_.__r.__words[0] - 24));
  std::ios_base::init(v10, &v18[0].__r_.__value_.__r.__words[1]);
  v10[1].__vftable = 0LL;
  v10[1].__fmtflags_ = -1;
  std::streambuf::basic_streambuf(&v18[0].__r_.__value_.__r.__words[1]);
  *(_OWORD *)BOOL v19 = 0u;
  __int128 v20 = 0u;
  int v21 = 16;
  (*(void (**)(std::string::size_type, std::string *))(*(void *)v2 + 40LL))(v2, v18);
  (*(void (**)(std::string::size_type))(*(void *)v2 + 24LL))(v2);
  std::stringbuf::str(&__p, (const std::stringbuf *)&v18[0].__r_.__value_.__r.__words[1]);
  if ((char)__p.__r_.__value_.__s.__size_ < 0)
  {
    std::string::size_type v2 = __p.__r_.__value_.__l.__size_;
    operator delete(__p.__r_.__value_.__l.__data_);
    if (v2) {
      goto LABEL_12;
    }
  }

  else if (__p.__r_.__value_.__s.__size_)
  {
LABEL_12:
    std::stringbuf::str(&__p, (const std::stringbuf *)&v18[0].__r_.__value_.__r.__words[1]);
    std::string::size_type v2 = RNBRemote::SendPacket((uint64_t)this, &__p);
    int v11 = 0;
    goto LABEL_21;
  }

  __p.__r_.__value_.__s.__size_ = 3;
  LODWORD(__p.__r_.__value_.__l.__data_) = 3422277;
  RNBRemote::SendPacket((uint64_t)this, &__p);
  int v11 = 1;
LABEL_21:
  *(std::string::size_type *)((char *)v18[0].__r_.__value_.__r.__words
  if (SBYTE7(v20) < 0) {
    operator delete(v19[0]);
  }
  std::streambuf::~streambuf(&v18[0].__r_.__value_.__r.__words[1]);
  std::ios::~ios(&v22);
  if (!v11)
  {
    int v12 = 0;
    uint64_t v13 = v25;
    if (!v25) {
      goto LABEL_26;
    }
    goto LABEL_25;
  }

LABEL_26:
  if (size)
  {
    p_shared_owners = (unint64_t *)&size->__shared_owners_;
    do
      unint64_t v15 = __ldaxr(p_shared_owners);
    while (__stlxr(v15 - 1, p_shared_owners));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
      std::__shared_weak_count::__release_weak(size);
    }
  }

  if (v12) {
    goto LABEL_32;
  }
  return v2;
}

  v16[0].__r_.__value_.__s.__size_ = 2;
  strcpy((char *)v16, "OK");
LABEL_27:
  std::string::size_type size = (std::ios_base *)RNBRemote::SendPacket((uint64_t)this, v16);
  return size;
}

      std::string::size_type v9 = *((_DWORD *)this + 2);
      if (v9)
      {
        if (v9 != 6) {
          return v8 | (unint64_t)(Memory << 32);
        }
LABEL_39:
        MachProcess::GetMacCatalystVersionString(&__p);
        if (v22 >= 0) {
          p_p = (const char *)&__p;
        }
        else {
          p_p = (const char *)__p;
        }
        uint64_t v17 = 0LL;
        std::string __endptr = 0LL;
        mach_vm_address_t Memory = strtoul(p_p, &__endptr, 10);
        if (__endptr && *__endptr == 46)
        {
          strtoul(__endptr + 1, &v17, 10);
          if (!v17 || *v17 != 46)
          {
            if ((v22 & 0x80000000) == 0) {
              goto LABEL_50;
            }
            goto LABEL_49;
          }

          strtoul(v17 + 1, 0LL, 10);
          if (v22 < 0) {
LABEL_49:
          }
            operator delete(__p);
        }

        else if (v22 < 0)
        {
          goto LABEL_49;
        }

std::__shared_weak_count *RNBRemote::HandlePacket_jThreadsInfo(RNBRemote *this, const char *a2)
{
  size_t v32 = (void (__cdecl **)(std::ostringstream *__hidden))v2;
  *(void *)((char *)&v33[-1] + *(void *)(v2 - 24)) = v3;
  int v4 = (std::ios_base *)((char *)&v33[-1] + (void)*(v32 - 3));
  std::ios_base::init(v4, v33);
  v4[1].__vftable = 0LL;
  v4[1].__fmtflags_ = -1;
  std::streambuf::basic_streambuf(v33);
  __int128 v34 = 0u;
  __int128 v35 = 0u;
  int v36 = 16;
  std::string::size_type v26 = (void (__cdecl **)(std::ostringstream *__hidden))v2;
  *(void *)((char *)&v27[-1] + *(void *)(v2 - 24)) = v3;
  uint64_t v5 = (std::ios_base *)((char *)&v27[-1] + (void)*(v26 - 3));
  std::ios_base::init(v5, v27);
  v5[1].__vftable = 0LL;
  v5[1].__fmtflags_ = -1;
  std::streambuf::basic_streambuf(v27);
  __int128 v28 = 0u;
  __int128 v29 = 0u;
  int v30 = 16;
  if (*((_DWORD *)this + 3))
  {
    RNBRemote::GetJSONThreadsInfo(this, 0, &v24);
    int v6 = v24;
    if (!v24) {
      goto LABEL_14;
    }
    v19[0].__r_.__value_.__r.__words[0] = v2;
    *(std::string::size_type *)((char *)v19[0].__r_.__value_.__r.__words + *(void *)(v2 - 24)) = v3;
    uint64_t v7 = (std::ios_base *)((char *)v19 + *(void *)(v19[0].__r_.__value_.__r.__words[0] - 24));
    std::ios_base::init(v7, &v19[0].__r_.__value_.__r.__words[1]);
    v7[1].__vftable = 0LL;
    v7[1].__fmtflags_ = -1;
    std::streambuf::basic_streambuf(&v19[0].__r_.__value_.__r.__words[1]);
    *(_OWORD *)std::stringbuf::string_type __p = 0u;
    __int128 v21 = 0u;
    int v22 = 16;
    ((void (*)(std::__shared_weak_count *, std::string *))v6->__vftable[1].~__shared_weak_count)(v6, v19);
    ((void (*)(std::__shared_weak_count *))v6->__get_deleter)(v6);
    std::stringbuf::str(&v18, (const std::stringbuf *)&v19[0].__r_.__value_.__r.__words[1]);
    if ((char)v18.__r_.__value_.__s.__size_ < 0)
    {
      std::string::size_type size = v18.__r_.__value_.__l.__size_;
      operator delete(v18.__r_.__value_.__l.__data_);
      if (size) {
        goto LABEL_5;
      }
    }

    else if (v18.__r_.__value_.__s.__size_)
    {
LABEL_5:
      std::stringbuf::str(&v18, (const std::stringbuf *)&v19[0].__r_.__value_.__r.__words[1]);
      int v6 = (std::__shared_weak_count *)RNBRemote::SendPacket((uint64_t)this, &v18);
      int v8 = 0;
LABEL_11:
      *(std::string::size_type *)((char *)v19[0].__r_.__value_.__r.__words
      if (SBYTE7(v21) < 0) {
        operator delete(__p[0]);
      }
      std::streambuf::~streambuf(&v19[0].__r_.__value_.__r.__words[1]);
      std::ios::~ios(&v23);
      if (!v8)
      {
        int v10 = 0;
        int v11 = v25;
        if (!v25) {
          goto LABEL_20;
        }
        goto LABEL_17;
      }

LABEL_14:
      int v10 = 1;
      int v11 = v25;
      if (!v25)
      {
LABEL_20:
        if (!v10) {
          goto LABEL_24;
        }
        goto LABEL_21;
      }

      uint64_t v14 = this;
      uint64_t v15 = 3470;
      return RNBRemote::HandlePacket_ILLFORMED( v14,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v15,  __big,  a5);
    }
  }

  else
  {
    uint64_t CurrentThread = *((void *)this + 68);
    if (CurrentThread + 1 <= 1)
    {
      uint64_t CurrentThread = DNBProcessGetCurrentThread(*((_DWORD *)this + 3));
      if (!CurrentThread) {
        goto LABEL_13;
      }
    }
  }

  int v10 = DNBThreadSaveRegisterState(v7, CurrentThread);
  if (v10)
  {
    snprintf((char *)__str, 0x40uLL, "%u", v10);
    int v11 = strlen((const char *)__str);
    if (v11 >= 0x7FFFFFFFFFFFFFF8LL) {
      abort();
    }
    int v12 = v11;
    if (v11 >= 0x17)
    {
      BOOL v19 = (v11 & 0xFFFFFFFFFFFFFFF8LL) + 8;
      if ((v11 | 7) != 0x17) {
        BOOL v19 = v11 | 7;
      }
      __int128 v20 = v19 + 1;
      p_dst = (std::string *)operator new(v19 + 1);
      __dst.__r_.__value_.__l.__size_ = v12;
      __dst.__r_.__value_.__l.__cap_ = v20 | 0x8000000000000000LL;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }

    else
    {
      __dst.__r_.__value_.__s.__size_ = v11;
      p_dst = &__dst;
      if (!v11)
      {
LABEL_22:
        p_dst->__r_.__value_.__s.__data_[v12] = 0;
        uint64_t v17 = RNBRemote::SendPacket((uint64_t)this, &__dst);
        if ((char)__dst.__r_.__value_.__s.__size_ < 0)
        {
          std::stringbuf::string_type v18 = (void *)__dst.__r_.__value_.__r.__words[0];
          goto LABEL_24;
        }

        return v17;
      }
    }

    memcpy(p_dst, __str, v12);
    goto LABEL_22;
  }

  __str[0].__r_.__value_.__s.__size_ = 3;
  strcpy((char *)__str, "E75");
  uint64_t v17 = RNBRemote::SendPacket((uint64_t)this, __str);
  if ((char)__str[0].__r_.__value_.__s.__size_ < 0)
  {
    std::stringbuf::string_type v18 = (void *)__str[0].__r_.__value_.__r.__words[0];
LABEL_24:
    operator delete(v18);
  }

  return v17;
}

  int v11 = v10;
  operator delete(v10);
  return v4;
}

  LODWORD(__p[0]) = *__error();
  HIDWORD(__p[0]) = 2;
  LOBYTE(__p[1]) = 0;
  HIBYTE(v15) = 0;
  if (LODWORD(__p[0])) {
    goto LABEL_16;
  }
LABEL_15:
  if (!DNBLogCheckLogBit(0x80000)) {
    goto LABEL_17;
  }
LABEL_16:
  DNBError::LogThreaded((DNBError *)__p, "::read(%i, %p, %llu) => %i", *a1, __s, 1024LL, v5);
LABEL_17:
  if ((unint64_t)(v5 + 1) >= 2)
  {
    while (1)
    {
      if ((char)a2->__r_.__value_.__s.__size_ < 0)
      {
        std::string::size_type size = a2->__r_.__value_.__l.__size_;
        if (!size) {
          break;
        }
      }

      else
      {
        if (!a2->__r_.__value_.__s.__size_) {
          break;
        }
        std::string::size_type size = a2->__r_.__value_.__s.__size_;
      }

      std::string::size_type v9 = (a2->__r_.__value_.__s.__size_ & 0x80u) == 0 ? a2 : (std::string *)a2->__r_.__value_.__r.__words[0];
      int v10 = v9->__r_.__value_.__s.__data_[size - 1];
      if (!(v10 < 0 ? __maskrune(v10, 0x4000uLL) : _DefaultRuneLocale.__runetype[v10] & 0x4000)) {
        break;
      }
      int v12 = a2->__r_.__value_.__s.__size_;
      if ((v12 & 0x80u) != 0LL) {
        int v12 = a2->__r_.__value_.__l.__size_;
      }
      std::string::erase(a2, v12 - 1, 0xFFFFFFFFFFFFFFFFLL);
    }

    if (DNBLogEnabledForAny(0x80000))
    {
      if ((a2->__r_.__value_.__s.__size_ & 0x80u) == 0) {
        unint64_t v13 = (const char *)a2;
      }
      else {
        unint64_t v13 = (const char *)a2->__r_.__value_.__r.__words[0];
      }
      _DNBLogThreaded("read: %s", v13);
    }

    int v6 = 0LL;
    if (SHIBYTE(v15) < 0) {
      goto LABEL_22;
    }
  }

  else
  {
    if (v5) {
      int v6 = 1LL;
    }
    else {
      int v6 = 2LL;
    }
    *a1 = -1;
    if (SHIBYTE(v15) < 0) {
LABEL_22:
    }
      operator delete(__p[1]);
  }

  return v6;
}

std::ios_base *RNBRemote::HandlePacket_jGetSharedCacheInfo(RNBRemote *this, const char *__s1)
{
  int v4 = *((_DWORD *)this + 3);
  if (!v4)
  {
    v16[0].__r_.__value_.__s.__size_ = 3;
    LODWORD(v16[0].__r_.__value_.__l.__data_) = 3487813;
    goto LABEL_27;
  }

  if (!strncmp(__s1, "jGetSharedCacheInfo:{", 0x15uLL))
  {
    v6.n128_f64[0] = DNBGetSharedCacheInfo(v4, (uint64_t)&v21, v5);
    if (!v21) {
      goto LABEL_18;
    }
    v16[0].__r_.__value_.__r.__words[0] = v7;
    *(std::string::size_type *)((char *)v16[0].__r_.__value_.__r.__words + *(void *)(v7 - 24)) = v8;
    std::string::size_type size = (std::ios_base *)((char *)v16 + *(void *)(v16[0].__r_.__value_.__r.__words[0] - 24));
    std::ios_base::init(size, &v16[0].__r_.__value_.__r.__words[1]);
    size[1].__vftable = 0LL;
    size[1].__fmtflags_ = -1;
    std::streambuf::basic_streambuf(&v16[0].__r_.__value_.__r.__words[1]);
    *(_OWORD *)uint64_t v17 = 0u;
    __int128 v18 = 0u;
    int v19 = 16;
    (*(void (**)(uint64_t, std::string *))(*(void *)v21 + 40LL))(v21, v16);
    (*(void (**)(uint64_t))(*(void *)v21 + 24LL))(v21);
    std::stringbuf::str(&__p, (const std::stringbuf *)&v16[0].__r_.__value_.__r.__words[1]);
    if ((char)__p.__r_.__value_.__s.__size_ < 0)
    {
      std::string::size_type size = (std::ios_base *)__p.__r_.__value_.__l.__size_;
      operator delete(__p.__r_.__value_.__l.__data_);
      if (size) {
        goto LABEL_6;
      }
    }

    else if (__p.__r_.__value_.__s.__size_)
    {
LABEL_6:
      std::stringbuf::str(&__p, (const std::stringbuf *)&v16[0].__r_.__value_.__r.__words[1]);
      std::string::size_type size = (std::ios_base *)RNBRemote::SendPacket((uint64_t)this, &__p);
      int v9 = 0;
      goto LABEL_15;
    }

    __p.__r_.__value_.__s.__size_ = 3;
    LODWORD(__p.__r_.__value_.__l.__data_) = 3553349;
    RNBRemote::SendPacket((uint64_t)this, &__p);
    int v9 = 1;
LABEL_15:
    *(std::string::size_type *)((char *)v16[0].__r_.__value_.__r.__words
    if (SBYTE7(v18) < 0) {
      operator delete(v17[0]);
    }
    std::streambuf::~streambuf(&v16[0].__r_.__value_.__r.__words[1]);
    std::ios::~ios(&v20);
    if (!v9)
    {
      int v10 = 0;
      int v11 = v22;
      if (!v22) {
        goto LABEL_25;
      }
LABEL_21:
      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v13 = __ldaxr(p_shared_owners);
      while (__stlxr(v13 - 1, p_shared_owners));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *, __n128))v11->__on_zero_shared)(v11, v6);
        std::__shared_weak_count::__release_weak(v11);
      }

LABEL_25:
      if (!v10) {
        return size;
      }
      goto LABEL_26;
    }

  __str.__r_.__value_.__s.__size_ = 2;
  strcpy((char *)&__str, "OK");
  int v19 = RNBRemote::SendPacket((uint64_t)this, &__str);
  if ((char)__str.__r_.__value_.__s.__size_ < 0)
  {
    operator delete(__str.__r_.__value_.__l.__data_);
    goto LABEL_27;
  }

  if ((char)v22.__r_.__value_.__s.__size_ < 0) {
LABEL_27:
  }
    operator delete(v22.__r_.__value_.__l.__data_);
  return v19;
}

      int v19 = v152;
      __int128 v20 = v151;
      __int128 v146 = v151;
      if (*((void *)&v151 + 1))
      {
        uint64_t v21 = (unint64_t *)(*((void *)&v151 + 1) + 8LL);
        do
          int v22 = __ldxr(v21);
        while (__stxr(v22 + 1, v21));
      }

      BOOL v23 = *(void **)(v19 + 40);
      if ((unint64_t)v23 >= *(void *)(v19 + 48))
      {
        uint64_t v27 = std::vector<std::shared_ptr<JSONGenerator::Object>>::__push_back_slow_path<std::shared_ptr<JSONGenerator::Object> const&>( v19 + 32,  &v146);
      }

      else
      {
        *BOOL v23 = v20;
        BOOL v24 = *((void *)&v146 + 1);
        v23[1] = *((void *)&v146 + 1);
        if (v24)
        {
          uint64_t v25 = (unint64_t *)(v24 + 8);
          do
            std::string::size_type v26 = __ldxr(v25);
          while (__stxr(v26 + 1, v25));
        }

        uint64_t v27 = v23 + 2;
      }

      *(void *)(v19 + 40) = v27;
      __int128 v28 = (std::__shared_weak_count *)*((void *)&v146 + 1);
      if (!*((void *)&v146 + 1))
      {
LABEL_161:
        std::string::size_type v93 = (std::__shared_weak_count *)*((void *)&v151 + 1);
        if (*((void *)&v151 + 1)) {
          goto LABEL_162;
        }
        goto LABEL_6;
      }

      __int128 v29 = (unint64_t *)(*((void *)&v146 + 1) + 8LL);
      do
        int v30 = __ldaxr(v29);
      while (__stlxr(v30 - 1, v29));
LABEL_160:
      if (v30) {
        goto LABEL_161;
      }
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
      std::string::size_type v93 = (std::__shared_weak_count *)*((void *)&v151 + 1);
      if (*((void *)&v151 + 1))
      {
LABEL_162:
        int v94 = (unint64_t *)&v93->__shared_owners_;
        do
          char v95 = __ldaxr(v94);
        while (__stlxr(v95 - 1, v94));
        if (!v95)
        {
          ((void (*)(std::__shared_weak_count *))v93->__on_zero_shared)(v93);
          std::__shared_weak_count::__release_weak(v93);
        }
      }

  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 568));
  return a3;
}

uint64_t RNBRemote::HandlePacket_QStartNoAckMode(RNBRemote *this, const char *a2)
{
  __p.__r_.__value_.__s.__size_ = 2;
  strcpy((char *)&__p, "OK");
  uint64_t v3 = RNBRemote::SendPacket((uint64_t)this, &__p);
  *((_BYTE *)this + 781) = 1;
  return v3;
}

uint64_t RNBRemote::HandlePacket_QThreadSuffixSupported(RNBRemote *this, const char *a2)
{
  *((_BYTE *)this + 782) = 1;
  __p.__r_.__value_.__s.__size_ = 2;
  strcpy((char *)&__p, "OK");
  uint64_t v2 = RNBRemote::SendPacket((uint64_t)this, &__p);
  return v2;
}

uint64_t RNBRemote::HandlePacket_QSetLogging(RNBRemote *this, const char *a2)
{
  __p.__r_.__value_.__s.__size_ = 2;
  strcpy((char *)&__p, "OK");
  uint64_t v3 = RNBRemote::SendPacket((uint64_t)this, &__p);
  return v3;
}

uint64_t RNBRemote::HandlePacket_QSetIgnoredExceptions(RNBRemote *this, const char *a2)
{
  if (!*((_DWORD *)this + 3))
  {
    int v4 = (char *)(a2 + 22);
    while (1)
    {
      std::string::size_type v7 = strchr(v4, 124);
      if (!v7)
      {
        if (!RNBContext::AddIgnoredException(this, (MachException *)v4)) {
          goto LABEL_29;
        }
        goto LABEL_27;
      }

      std::string::size_type v8 = v7;
      std::string::size_type v9 = v7 - v4;
      if (v9 >= 0x17) {
        break;
      }
      __p.__r_.__value_.__s.__size_ = (_BYTE)v7 - (_BYTE)v4;
      p_p = &__p;
      if (v7 != v4) {
        goto LABEL_15;
      }
LABEL_16:
      p_p->__r_.__value_.__s.__data_[v9] = 0;
      if (((char)__p.__r_.__value_.__s.__size_ & 0x80000000) == 0)
      {
        if (!__p.__r_.__value_.__s.__size_) {
          goto LABEL_29;
        }
        unint64_t v13 = (MachException *)&__p;
LABEL_21:
        BOOL v5 = RNBContext::AddIgnoredException(this, v13);
        if (v5)
        {
          int v4 = v8 + 1;
          int v6 = 0;
        }

        else
        {
          int v6 = 3;
        }

        goto LABEL_5;
      }

      if (__p.__r_.__value_.__l.__size_)
      {
        unint64_t v13 = (MachException *)__p.__r_.__value_.__r.__words[0];
        goto LABEL_21;
      }

      BOOL v5 = 0;
      int v6 = 3;
LABEL_5:
      operator delete(__p.__r_.__value_.__l.__data_);
LABEL_6:
      if (v6)
      {
        if (!v5)
        {
LABEL_29:
          __p.__r_.__value_.__s.__size_ = 3;
          int v3 = 3552069;
          goto LABEL_30;
        }

uint64_t RNBRemote::HandlePacket_QSetMaxPacketSize(RNBRemote *this, const char *a2)
{
  int v3 = a2 + 18;
  *__error() = 0;
  int v4 = strtoul(v3, 0LL, 16);
  if (*__error()) {
    BOOL v6 = v4 == 0;
  }
  else {
    BOOL v6 = 0;
  }
  if (v6) {
    return RNBRemote::HandlePacket_ILLFORMED( this,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  2438,  v3,  v5);
  }
  *((_DWORD *)this + 194) = v4 - 5;
  __p.__r_.__value_.__s.__size_ = 2;
  strcpy((char *)&__p, "OK");
  uint64_t v7 = RNBRemote::SendPacket((uint64_t)this, &__p);
  return v7;
}

uint64_t RNBRemote::HandlePacket_QSetMaxPayloadSize(RNBRemote *this, const char *a2)
{
  int v3 = a2 + 19;
  *__error() = 0;
  int v4 = strtoul(v3, 0LL, 16);
  if (*__error()) {
    BOOL v6 = v4 == 0;
  }
  else {
    BOOL v6 = 0;
  }
  if (v6) {
    return RNBRemote::HandlePacket_ILLFORMED( this,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  2424,  v3,  v5);
  }
  *((_DWORD *)this + 194) = v4;
  __p.__r_.__value_.__s.__size_ = 2;
  strcpy((char *)&__p, "OK");
  uint64_t v7 = RNBRemote::SendPacket((uint64_t)this, &__p);
  return v7;
}

uint64_t RNBRemote::HandlePacket_QEnvironment(RNBRemote *this, const char *a2)
{
  if (DNBLogEnabledForAny(0x100000))
  {
    int v4 = (pthread_mutex_t *)*((void *)this + 61);
    if (v4) {
      pthread_mutex_lock(*((pthread_mutex_t **)this + 61));
    }
    gettimeofday((timeval *)&v11, 0LL);
    int data = (int)v11.__r_.__value_.__l.__data_;
    int v6 = v11.__r_.__value_.__r.__words[1];
    uint64_t v7 = *((void *)this + 62);
    int v8 = *((_DWORD *)this + 126);
    *((_OWORD *)this + 31) = *(_OWORD *)&v11.__r_.__value_.__l.__data_;
    if (v4) {
      pthread_mutex_unlock(v4);
    }
    _DNBLogThreaded( "%8u RNBRemote::%s Handling QEnvironment: %s",  v6 - v8 + 1000000 * (data - v7),  "HandlePacket_QEnvironment",  a2);
  }

  RNBContext::PushEnvironment(this, a2 + 13);
  v11.__r_.__value_.__s.__size_ = 2;
  strcpy((char *)&v11, "OK");
  uint64_t v9 = RNBRemote::SendPacket((uint64_t)this, &v11);
  return v9;
}

uint64_t RNBRemote::HandlePacket_QEnvironmentHexEncoded(RNBRemote *this, const char *a2)
{
  if (DNBLogEnabledForAny(0x100000))
  {
    BOOL v5 = (pthread_mutex_t *)*((void *)this + 61);
    if (v5) {
      pthread_mutex_lock(*((pthread_mutex_t **)this + 61));
    }
    gettimeofday((timeval *)&v22, 0LL);
    int data = (int)v22.__r_.__value_.__l.__data_;
    int v7 = v22.__r_.__value_.__r.__words[1];
    uint64_t v8 = *((void *)this + 62);
    int v9 = *((_DWORD *)this + 126);
    *((_OWORD *)this + 31) = *(_OWORD *)&v22.__r_.__value_.__l.__data_;
    if (v5) {
      pthread_mutex_unlock(v5);
    }
    _DNBLogThreaded( "%8u RNBRemote::%s Handling QEnvironmentHexEncoded: %s",  v7 - v9 + 1000000 * (data - v8),  "HandlePacket_QEnvironmentHexEncoded",  a2);
  }

  std::string v11 = a2 + 23;
  int v10 = *((unsigned __int8 *)a2 + 23);
  memset(&v22, 0, sizeof(v22));
  if (v10)
  {
    uint64_t v12 = a2 + 25;
    do
    {
      unsigned __int8 v13 = *(v12 - 1);
      if (!v13)
      {
        uint64_t v17 = this;
        int v18 = 2488;
        goto LABEL_20;
      }

      __str.__r_.__value_.__s.__data_[0] = v10;
      *(_WORD *)((char *)&__str.__r_.__value_.__l.__data_ + 1) = v13;
      *__error() = 0;
      int v14 = strtoul((const char *)&__str, 0LL, 16);
      if (*__error()) {
        BOOL v15 = v14 == 0LL;
      }
      else {
        BOOL v15 = 0;
      }
      if (v15)
      {
        uint64_t v17 = this;
        int v18 = 2499;
LABEL_20:
        uint64_t v19 = RNBRemote::HandlePacket_ILLFORMED( v17,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v18,  v11,  v4);
        goto LABEL_27;
      }

      std::string::push_back(&v22, v14);
      int v10 = *(unsigned __int8 *)v12;
      v12 += 2;
    }

    while (v10);
    if ((char)v22.__r_.__value_.__s.__size_ < 0)
    {
      if (!v22.__r_.__value_.__l.__size_) {
        goto LABEL_25;
      }
      uint64_t v16 = (std::string *)v22.__r_.__value_.__r.__words[0];
    }

    else
    {
      if (!v22.__r_.__value_.__s.__size_) {
        goto LABEL_25;
      }
      uint64_t v16 = &v22;
    }

    RNBContext::PushEnvironment(this, (const char *)v16);
  }

uint64_t RNBRemote::HandlePacket_QLaunchArch(RNBRemote *this, const char *a2)
{
  if (DNBSetArchitecture(a2 + 12))
  {
    __p.__r_.__value_.__s.__size_ = 2;
    strcpy((char *)&__p, "OK");
  }

  else
  {
    __p.__r_.__value_.__s.__size_ = 3;
    LODWORD(__p.__r_.__value_.__l.__data_) = 3356229;
  }

  uint64_t v3 = RNBRemote::SendPacket((uint64_t)this, &__p);
  return v3;
}

uint64_t RNBRemote::HandlePacket_QSetDisableASLR(RNBRemote *this, const char *a2)
{
  int v2 = a2[16];
  if (v2 == 48)
  {
    int v3 = 0;
    goto LABEL_5;
  }

  if (v2 == 49)
  {
    int v3 = 1;
LABEL_5:
    g_disable_aslr = v3;
    __p.__r_.__value_.__s.__size_ = 2;
    strcpy((char *)&__p, "OK");
    goto LABEL_7;
  }

  __p.__r_.__value_.__s.__size_ = 3;
  LODWORD(__p.__r_.__value_.__l.__data_) = 3552581;
LABEL_7:
  uint64_t v4 = RNBRemote::SendPacket((uint64_t)this, &__p);
  return v4;
}

uint64_t RNBRemote::HandlePacket_QSetSTDIO(RNBRemote *this, const char *a2)
{
  if (*((_DWORD *)this + 3))
  {
    __p.__r_.__value_.__s.__size_ = 3;
    LODWORD(__p.__r_.__value_.__l.__data_) = 3683653;
    uint64_t v3 = RNBRemote::SendPacket((uint64_t)this, &__p);
    return v3;
  }

  StdStringExtractor::StdStringExtractor((StdStringExtractor *)&__p, a2);
  uint64_t v9 = 7LL;
  int Char = StdStringExtractor::GetChar((StdStringExtractor *)&__p, 0);
  switch(Char)
  {
    case 'E':
      StdStringExtractor::GetHexByteString((uint64_t)&__p, (std::string *)((char *)this + 64));
      int v5 = *((char *)this + 87);
      if (v5 < 0)
      {
        if (!*((void *)this + 9)) {
          break;
        }
        goto LABEL_17;
      }

      goto LABEL_16;
    case 'O':
      StdStringExtractor::GetHexByteString((uint64_t)&__p, (std::string *)((char *)this + 40));
      int v5 = *((char *)this + 63);
      if (v5 < 0)
      {
        if (!*((void *)this + 6)) {
          break;
        }
        goto LABEL_17;
      }

uint64_t RNBRemote::HandlePacket_QSetWorkingDir(RNBRemote *this, const char *a2)
{
  if (!*((_DWORD *)this + 3))
  {
    StdStringExtractor::StdStringExtractor((StdStringExtractor *)v11, a2 + 15);
    if (!StdStringExtractor::GetHexByteString(v4, (std::string *)((char *)this + 88)))
    {
      HIBYTE(__p.st_gid) = 3;
      __p.st_dev = 3749189;
      uint64_t v3 = RNBRemote::SendPacket((uint64_t)this, (std::string *)&__p);
      if (SHIBYTE(__p.st_gid) < 0)
      {
        int v6 = *(void **)&__p.st_dev;
LABEL_28:
        operator delete(v6);
      }

uint64_t RNBRemote::HandlePacket_QListThreadsInStopReply(RNBRemote *this, const char *a2)
{
  __p.__r_.__value_.__s.__size_ = 2;
  strcpy((char *)&__p, "OK");
  uint64_t v3 = RNBRemote::SendPacket((uint64_t)this, &__p);
  *((_BYTE *)this + 783) = 1;
  return v3;
}

uint64_t RNBRemote::HandlePacket_QSyncThreadState(RNBRemote *this, const char *a2)
{
  if (!*((_DWORD *)this + 3)) {
    goto LABEL_7;
  }
  *__error() = 0;
  uint64_t v4 = a2 + 17;
  unint64_t v5 = strtoul(v4, 0LL, 16);
  if (*__error()) {
    BOOL v7 = v5 == 0;
  }
  else {
    BOOL v7 = 0;
  }
  if (v7) {
    return RNBRemote::HandlePacket_ILLFORMED( this,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  2363,  v4,  v6);
  }
  if (!DNBProcessSyncThreadState(*((_DWORD *)this + 3), v5))
  {
    __p.__r_.__value_.__s.__size_ = 3;
    LODWORD(__p.__r_.__value_.__l.__data_) = 3225157;
  }

  else
  {
LABEL_7:
    __p.__r_.__value_.__s.__size_ = 2;
    strcpy((char *)&__p, "OK");
  }

  uint64_t v8 = RNBRemote::SendPacket((uint64_t)this, &__p);
  return v8;
}

uint64_t RNBRemote::HandlePacket_AllocateMemory(RNBRemote *this, const char *a2)
{
  v25[4] = (void *)2;
  unint64_t HexMaxU64 = StdStringExtractor::GetHexMaxU64(v3, 0, 0LL);
  if (!HexMaxU64) {
    goto LABEL_19;
  }
  mach_vm_size_t v5 = HexMaxU64;
  int Char = StdStringExtractor::GetChar((StdStringExtractor *)v25, 0);
  for (unsigned int i = 0; Char; Char = StdStringExtractor::GetChar((StdStringExtractor *)v25, 0))
  {
    if (Char == 114)
    {
      int v17 = 2;
    }

    else if ((char)Char == 120)
    {
      int v17 = 4;
    }

    else
    {
      int v17 = 1;
    }

    i |= v17;
  }

  mach_vm_address_t v8 = DNBProcessMemoryAllocate(*((_DWORD *)this + 3), v5, i);
  if (v8 != -1LL)
  {
    mach_vm_address_t v9 = v8;
    v20[0].__r_.__value_.__r.__words[0] = v10;
    *(std::string::size_type *)((char *)v20[0].__r_.__value_.__r.__words + *(void *)(v10 - 24)) = v11;
    uint64_t v12 = (std::ios_base *)((char *)v20 + *(void *)(v20[0].__r_.__value_.__r.__words[0] - 24));
    std::ios_base::init(v12, &v20[0].__r_.__value_.__r.__words[1]);
    v12[1].__vftable = 0LL;
    v12[1].__fmtflags_ = -1;
    std::streambuf::basic_streambuf(&v20[0].__r_.__value_.__r.__words[1]);
    *(_OWORD *)std::string __p = 0u;
    __int128 v22 = 0u;
    int v23 = 16;
    std::string::size_type v13 = v20[0].__r_.__value_.__r.__words[0];
    int v14 = (char *)v20 + *(void *)(v20[0].__r_.__value_.__r.__words[0] - 24);
    if (*((_DWORD *)v14 + 36) == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)v20 + *(void *)(v20[0].__r_.__value_.__r.__words[0] - 24)));
      BOOL v15 = std::locale::use_facet((const std::locale *)&v19, &std::ctype<char>::id);
      ((void (*)(const std::locale::facet *, uint64_t))v15->__vftable[2].~facet_0)(v15, 32LL);
      std::locale::~locale((std::locale *)&v19);
      std::string::size_type v13 = v20[0].__r_.__value_.__r.__words[0];
    }

    *((_DWORD *)v14 + 36) = 48;
    *(_DWORD *)((char *)&v20[0].__r_.__value_.__r.__words[1] + *(void *)(v13 - 24)) = *(_DWORD *)((_BYTE *)&v20[0].__r_.__value_.__r.__words[1]
                                                                                                  + *(void *)(v13 - 24)) & 0xFFFFFFB5 | 8;
    *(_DWORD *)((char *)&v20[0].__r_.__value_.__r.__words[1] + *(void *)(v13 - 24)) = *(_DWORD *)((_BYTE *)&v20[0].__r_.__value_.__r.__words[1]
                                                                                                  + *(void *)(v13 - 24)) & 0xFFFFFF4F | 0x80;
    std::ostream::operator<<(v20, v9);
    std::stringbuf::str(&v19, (const std::stringbuf *)&v20[0].__r_.__value_.__r.__words[1]);
    uint64_t v16 = RNBRemote::SendPacket((uint64_t)this, &v19);
    *(std::string::size_type *)((char *)v20[0].__r_.__value_.__r.__words
    if (SBYTE7(v22) < 0) {
      operator delete(__p[0]);
    }
    std::streambuf::~streambuf(&v20[0].__r_.__value_.__r.__words[1]);
    std::ios::~ios(&v24);
  }

  else
  {
LABEL_19:
    v20[0].__r_.__value_.__s.__size_ = 3;
    LODWORD(v20[0].__r_.__value_.__l.__data_) = 3355973;
    uint64_t v16 = RNBRemote::SendPacket((uint64_t)this, v20);
  }

  StdStringExtractor::~StdStringExtractor(v25);
  return v16;
}

uint64_t RNBRemote::HandlePacket_DeallocateMemory(RNBRemote *this, const char *a2)
{
  v7[4] = (void *)2;
  mach_vm_address_t HexMaxU64 = StdStringExtractor::GetHexMaxU64((StdStringExtractor *)v7, 0, -1LL);
  if (HexMaxU64 == -1LL || !DNBProcessMemoryDeallocate(*((_DWORD *)this + 3), HexMaxU64))
  {
    __p.__r_.__value_.__s.__size_ = 3;
    LODWORD(__p.__r_.__value_.__l.__data_) = 3421509;
  }

  else
  {
    __p.__r_.__value_.__s.__size_ = 2;
    strcpy((char *)&__p, "OK");
  }

  uint64_t v4 = RNBRemote::SendPacket((uint64_t)this, &__p);
  StdStringExtractor::~StdStringExtractor(v7);
  return v4;
}

uint64_t RNBRemote::HandlePacket_SaveRegisterState( RNBRemote *this, const char *__big, uint64_t a3, uint64_t a4, const char *a5)
{
  int v7 = *((_DWORD *)this + 3);
  if (*((_BYTE *)this + 782))
  {
    if (!__big) {
      goto LABEL_14;
    }
    mach_vm_address_t v8 = strstr(__big, "thread:");
    if (!v8) {
      goto LABEL_14;
    }
    unint64_t CurrentThread = strtoul(v8 + 7, 0LL, 16);
    if (!CurrentThread)
    {
LABEL_13:
      if (!*((_BYTE *)this + 782))
      {
        int v14 = this;
        int v15 = 3473;
        return RNBRemote::HandlePacket_ILLFORMED( v14,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v15,  __big,  a5);
      }

uint64_t RNBRemote::HandlePacket_RestoreRegisterState( RNBRemote *this, const char *__big, uint64_t a3, uint64_t a4, const char *a5)
{
  int v7 = *((_DWORD *)this + 3);
  if (*((_BYTE *)this + 782))
  {
    if (!__big) {
      goto LABEL_12;
    }
    mach_vm_address_t v8 = strstr(__big, "thread:");
    if (!v8) {
      goto LABEL_12;
    }
    unint64_t CurrentThread = strtoul(v8 + 7, 0LL, 16);
    if (!CurrentThread)
    {
LABEL_11:
      if (!*((_BYTE *)this + 782))
      {
        int v10 = this;
        int v11 = 3514;
        return RNBRemote::HandlePacket_ILLFORMED( v10,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  v11,  __big,  a5);
      }

uint64_t RNBRemote::HandlePacket_MemoryRegionInfo(RNBRemote *this, const char *a2)
{
  if (a2[17])
  {
    if (a2[17] == 58)
    {
      uint64_t v3 = a2 + 18;
      *__error() = 0;
      unint64_t v4 = strtoul(v3, 0LL, 16);
      if (*__error() && !v4) {
        return RNBRemote::HandlePacket_ILLFORMED( this,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  4281,  v3,  v5);
      }
      uint64_t v38 = 0LL;
      uint64_t v39 = 0LL;
      int v40 = 0;
      __int128 v41 = 0u;
      __int128 v42 = 0u;
      __int128 v43 = 0u;
      DNBProcessMemoryRegionInfo(*((_DWORD *)this + 3), v4, (uint64_t)&v38);
      v33[0].__r_.__value_.__r.__words[0] = v9;
      *(std::string::size_type *)((char *)v33[0].__r_.__value_.__r.__words + *(void *)(v9 - 24)) = v10;
      int v11 = (std::ios_base *)((char *)v33 + *(void *)(v33[0].__r_.__value_.__r.__words[0] - 24));
      std::ios_base::init(v11, &v33[0].__r_.__value_.__r.__words[1]);
      v11[1].__vftable = 0LL;
      v11[1].__fmtflags_ = -1;
      std::streambuf::basic_streambuf(&v33[0].__r_.__value_.__r.__words[1]);
      *(_OWORD *)__int128 v34 = 0u;
      __int128 v35 = 0u;
      int v36 = 16;
      std::string::size_type v12 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v33, (uint64_t)"start:", 6LL);
      *(_DWORD *)((char *)v12 + *(void *)(*v12 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v12 + *(void *)(*v12 - 24LL) + 8) & 0xFFFFFFB5 | 8;
      int v13 = (void *)std::ostream::operator<<(v12, v38);
      __p.__r_.__value_.__s.__data_[0] = 59;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v13, (uint64_t)&__p, 1LL);
      if (v39)
      {
        uint64_t v14 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v33, (uint64_t)"size:", 5LL);
        int v15 = (void *)std::ostream::operator<<(v14, v39);
        __p.__r_.__value_.__s.__data_[0] = 59;
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v15, (uint64_t)&__p, 1LL);
      }

      if (!v40) {
        goto LABEL_41;
      }
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v33, (uint64_t)"permissions:", 12LL);
      char v16 = v40;
      if ((v40 & 2) != 0)
      {
        __p.__r_.__value_.__s.__data_[0] = 114;
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v33, (uint64_t)&__p, 1LL);
        char v16 = v40;
        if ((v40 & 1) == 0)
        {
LABEL_18:
          if ((v16 & 4) == 0) {
            goto LABEL_20;
          }
          goto LABEL_19;
        }
      }

      else if ((v40 & 1) == 0)
      {
        goto LABEL_18;
      }

      __p.__r_.__value_.__s.__data_[0] = 119;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v33, (uint64_t)&__p, 1LL);
      if ((v40 & 4) == 0)
      {
LABEL_20:
        __p.__r_.__value_.__s.__data_[0] = 59;
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v33, (uint64_t)&__p, 1LL);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v33, (uint64_t)"dirty-pages:", 12LL);
        uint64_t v17 = (uint64_t *)*((void *)&v41 + 1);
        if (*((void *)&v41 + 1) != (void)v41)
        {
          uint64_t v19 = (uint64_t *)(v41 + 8);
          uint64_t v18 = *(void *)v41;
          *(_DWORD *)((char *)&v33[0].__r_.__value_.__r.__words[1]
                    + *(void *)(v33[0].__r_.__value_.__r.__words[0] - 24)) = *(_DWORD *)((_BYTE *)&v33[0].__r_.__value_.__r.__words[1]
                                                                                         + *(void *)(v33[0].__r_.__value_.__r.__words[0] - 24)) & 0xFFFFFFB5 | 8;
          std::ostream::operator<<(v33, v18);
          while (v19 != v17)
          {
            uint64_t v20 = *v19++;
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v33, (uint64_t)",", 1LL);
            *(_DWORD *)((char *)&v33[0].__r_.__value_.__r.__words[1]
                      + *(void *)(v33[0].__r_.__value_.__r.__words[0] - 24)) = *(_DWORD *)((_BYTE *)&v33[0].__r_.__value_.__r.__words[1]
                                                                                           + *(void *)(v33[0].__r_.__value_.__r.__words[0] - 24)) & 0xFFFFFFB5 | 8;
            std::ostream::operator<<(v33, v20);
          }
        }

        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v33, (uint64_t)";", 1LL);
        if (*((void *)&v42 + 1) != (void)v43)
        {
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v33, (uint64_t)"type:", 5LL);
          if ((void)v43 != *((void *)&v42 + 1))
          {
            int v21 = *(char *)(*((void *)&v42 + 1) + 23LL);
            uint64_t v22 = v21 >= 0 ? *((void *)&v42 + 1) : **((void **)&v42 + 1);
            uint64_t v23 = v21 >= 0
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v33, v22, v23);
            if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v43 - *((void *)&v42 + 1)) >> 3) >= 2)
            {
              uint64_t v24 = 0LL;
              unint64_t v25 = 1LL;
              do
              {
                std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v33, (uint64_t)",", 1LL);
                int v26 = *(char *)(*((void *)&v42 + 1) + v24 + 47);
                if (v26 >= 0) {
                  uint64_t v27 = *((void *)&v42 + 1) + v24 + 24;
                }
                else {
                  uint64_t v27 = *(void *)(*((void *)&v42 + 1) + v24 + 24);
                }
                if (v26 >= 0) {
                  uint64_t v28 = *(unsigned __int8 *)(*((void *)&v42 + 1) + v24 + 47);
                }
                else {
                  uint64_t v28 = *(void *)(*((void *)&v42 + 1) + v24 + 32);
                }
                std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v33, v27, v28);
                ++v25;
                v24 += 24LL;
              }

              while (v25 < 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v43 - *((void *)&v42 + 1)) >> 3));
            }
          }

          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v33, (uint64_t)";", 1LL);
        }

LABEL_19:
      __p.__r_.__value_.__s.__data_[0] = 120;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v33, (uint64_t)&__p, 1LL);
      goto LABEL_20;
    }

    v33[0].__r_.__value_.__s.__size_ = 3;
    LODWORD(v33[0].__r_.__value_.__l.__data_) = 3618373;
  }

  else
  {
    v33[0].__r_.__value_.__s.__size_ = 2;
    strcpy((char *)v33, "OK");
  }

  uint64_t v7 = RNBRemote::SendPacket((uint64_t)this, v33);
  if ((char)v33[0].__r_.__value_.__s.__size_ < 0)
  {
    mach_vm_address_t v8 = (void *)v33[0].__r_.__value_.__r.__words[0];
LABEL_55:
    operator delete(v8);
  }

  return v7;
}

uint64_t RNBRemote::HandlePacket_GetProfileData(RNBRemote *this, const char *a2)
{
  if (*((_DWORD *)this + 3))
  {
    int v16 = *((_DWORD *)this + 3);
    StdStringExtractor::StdStringExtractor((StdStringExtractor *)v28, a2 + 16);
    memset(&v27, 0, sizeof(v27));
    memset(&__str, 0, sizeof(__str));
    __int16 data = -1;
    if (StdStringExtractor::GetNameColonValue(v2, &v27, &__str))
    {
      do
      {
        if ((char)v27.__r_.__value_.__s.__size_ < 0)
        {
          if (v27.__r_.__value_.__l.__size_ == 9)
          {
            uint64_t v7 = (std::string *)v27.__r_.__value_.__r.__words[0];
LABEL_11:
            std::string::size_type v8 = v7->__r_.__value_.__r.__words[0];
            int v9 = v7->__r_.__value_.__s.__data_[8];
            if (v8 == 0x7079745F6E616373LL && v9 == 101)
            {
              v21[0].__r_.__value_.__r.__words[0] = v6;
              *(std::string::size_type *)((char *)v21[0].__r_.__value_.__r.__words + *(void *)(v6 - 24)) = v19;
              v21[0].__r_.__value_.__l.__size_ = 0LL;
              int v11 = (std::ios_base *)((char *)v21 + *(void *)(v21[0].__r_.__value_.__r.__words[0] - 24));
              std::ios_base::init(v11, &v21[0].__r_.__value_.__r.__words[2]);
              v11[1].__vftable = 0LL;
              v11[1].__fmtflags_ = -1;
              std::streambuf::basic_streambuf(&v21[0].__r_.__value_.__r.__words[2]);
              __int128 __p = 0u;
              __int128 v23 = 0u;
              int v24 = 8;
              std::string::operator=((std::string *)&__p, &__str);
              std::stringbuf::__init_buf_ptrs[abi:nn180100]((uint64_t)&v21[0].__r_.__value_.__l.__cap_);
              LODWORD(v20.__r_.__value_.__l.__data_) = 0;
              *(_DWORD *)((char *)&v21[0].__r_.__value_.__r.__words[1]
                        + *(void *)(v21[0].__r_.__value_.__r.__words[0] - 24)) = *(_DWORD *)((_BYTE *)&v21[0].__r_.__value_.__r.__words[1]
                                                                                             + *(void *)(v21[0].__r_.__value_.__r.__words[0] - 24)) & 0xFFFFFFB5 | 8;
              std::string::size_type v12 = (void *)std::istream::operator>>(v21, &v20);
              if ((*(_DWORD *)((_BYTE *)v12 + *(void *)(*v12 - 24LL) + 32) & 5) == 0) {
                __int16 data = (__int16)v20.__r_.__value_.__l.__data_;
              }
              v21[0].__r_.__value_.__r.__words[0] = v5;
              *(std::string::size_type *)((char *)v21[0].__r_.__value_.__r.__words + *(void *)(v5 - 24)) = v18;
              if (SBYTE7(v23) < 0) {
                operator delete((void *)__p);
              }
              std::streambuf::~streambuf(&v21[0].__r_.__value_.__r.__words[2]);
              std::ios::~ios(&v25);
            }
          }
        }

        else if (v27.__r_.__value_.__s.__size_ == 9)
        {
          uint64_t v7 = &v27;
          goto LABEL_11;
        }
      }

      while ((StdStringExtractor::GetNameColonValue((uint64_t)v28, &v27, &__str) & 1) != 0);
    }

    DNBProcessGetProfileData(v16, data, v3, (uint64_t)v21);
    std::string::size_type size = v21[0].__r_.__value_.__s.__size_;
    if ((v21[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
      std::string::size_type size = v21[0].__r_.__value_.__l.__size_;
    }
    if (size)
    {
      uint64_t v14 = RNBRemote::SendPacket((uint64_t)this, v21);
      if ((char)v21[0].__r_.__value_.__s.__size_ < 0)
      {
LABEL_35:
        operator delete(v21[0].__r_.__value_.__l.__data_);
        if ((char)__str.__r_.__value_.__s.__size_ < 0)
        {
LABEL_36:
          operator delete(__str.__r_.__value_.__l.__data_);
          goto LABEL_31;
        }

uint64_t RNBRemote::HandlePacket_SetEnableAsyncProfiling(RNBRemote *this, const char *a2)
{
  int v3 = *((_DWORD *)this + 3);
  if (v3)
  {
    StdStringExtractor::StdStringExtractor((StdStringExtractor *)v35, a2 + 25);
    memset(&__str, 0, sizeof(__str));
    memset(&v34, 0, sizeof(v34));
    if (StdStringExtractor::GetNameColonValue(v4, &v34, &__str))
    {
      unint64_t v26 = 0LL;
      BOOL v25 = 0;
      int v5 = -1;
      while (1)
      {
        if ((char)v34.__r_.__value_.__s.__size_ < 0)
        {
          std::string::size_type size = v34.__r_.__value_.__l.__size_;
          if (v34.__r_.__value_.__l.__size_ == 6
            && *(_DWORD *)v34.__r_.__value_.__l.__data_ == 1650552421
            && *(_WORD *)(v34.__r_.__value_.__r.__words[0] + 4) == 25964)
          {
            goto LABEL_47;
          }

          if (v34.__r_.__value_.__l.__size_ == 13)
          {
            if (*(void *)v34.__r_.__value_.__l.__data_ == 0x6C61767265746E69LL
              && *(void *)(v34.__r_.__value_.__r.__words[0] + 5) == 0x636573755F6C6176LL)
            {
              goto LABEL_4;
            }

            std::string::size_type size = v34.__r_.__value_.__l.__size_;
          }

          if (size == 9)
          {
            std::string::size_type v8 = (std::string *)v34.__r_.__value_.__r.__words[0];
LABEL_32:
            std::string::size_type v12 = v8->__r_.__value_.__r.__words[0];
            int v13 = v8->__r_.__value_.__s.__data_[8];
            if (v12 == 0x7079745F6E616373LL && v13 == 101)
            {
              v28[0].__r_.__value_.__r.__words[0] = v24;
              *(std::string::size_type *)((char *)v28[0].__r_.__value_.__r.__words + *(void *)(v24 - 24)) = v22;
              v28[0].__r_.__value_.__l.__size_ = 0LL;
              int v15 = (std::ios_base *)((char *)v28 + *(void *)(v28[0].__r_.__value_.__r.__words[0] - 24));
              std::ios_base::init(v15, &v28[0].__r_.__value_.__r.__words[2]);
              v15[1].__vftable = 0LL;
              v15[1].__fmtflags_ = -1;
              std::streambuf::basic_streambuf(&v28[0].__r_.__value_.__r.__words[2]);
              __int128 __p = 0u;
              __int128 v30 = 0u;
              int v31 = 8;
              std::string::operator=((std::string *)&__p, &__str);
              std::stringbuf::__init_buf_ptrs[abi:nn180100]((uint64_t)&v28[0].__r_.__value_.__l.__cap_);
              int v27 = 0;
              *(_DWORD *)((char *)&v28[0].__r_.__value_.__r.__words[1]
                        + *(void *)(v28[0].__r_.__value_.__r.__words[0] - 24)) = *(_DWORD *)((_BYTE *)&v28[0].__r_.__value_.__r.__words[1]
                                                                                             + *(void *)(v28[0].__r_.__value_.__r.__words[0] - 24)) & 0xFFFFFFB5 | 8;
              int v16 = (void *)std::istream::operator>>(v28, &v27);
              if ((*(_DWORD *)((_BYTE *)v16 + *(void *)(*v16 - 24LL) + 32) & 5) == 0) {
                int v5 = v27;
              }
              v28[0].__r_.__value_.__r.__words[0] = v23;
              *(std::string::size_type *)((char *)v28[0].__r_.__value_.__r.__words + *(void *)(v23 - 24)) = v21;
              if (SBYTE7(v30) < 0) {
                operator delete((void *)__p);
              }
              std::streambuf::~streambuf(&v28[0].__r_.__value_.__r.__words[2]);
              std::ios::~ios(&v32);
            }
          }
        }

        else
        {
          if (v34.__r_.__value_.__s.__size_ == 6)
          {
            if (LODWORD(v34.__r_.__value_.__l.__data_) != 1650552421
              || WORD2(v34.__r_.__value_.__r.__words[0]) != 25964)
            {
              goto LABEL_8;
            }

LABEL_47:
            if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
              p_str = &__str;
            }
            else {
              p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
            }
            BOOL v25 = strtoul((const char *)p_str, 0LL, 10) != 0;
            goto LABEL_8;
          }

          if (v34.__r_.__value_.__s.__size_ == 9)
          {
            std::string::size_type v8 = &v34;
            goto LABEL_32;
          }

          if (v34.__r_.__value_.__s.__size_ == 13
            && v34.__r_.__value_.__r.__words[0] == 0x6C61767265746E69LL
            && *(std::string::size_type *)((char *)v34.__r_.__value_.__r.__words + 5) == 0x636573755F6C6176LL)
          {
LABEL_4:
            if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
              std::string::size_type v6 = &__str;
            }
            else {
              std::string::size_type v6 = (std::string *)__str.__r_.__value_.__r.__words[0];
            }
            unint64_t v26 = strtoul((const char *)v6, 0LL, 10);
          }
        }

  if ((char)v56.__r_.__value_.__s.__size_ < 0) {
LABEL_72:
  }
    operator delete(v56.__r_.__value_.__l.__data_);
  return v31;
}

LABEL_8:
      }
    }

    BOOL v25 = 0;
    unint64_t v26 = 0LL;
    int v5 = -1;
LABEL_54:
    DNBProcessSetEnableAsyncProfiling(v3, v26 != 0 && v25, v26, v5);
    v28[0].__r_.__value_.__s.__size_ = 2;
    strcpy((char *)v28, "OK");
    uint64_t v19 = RNBRemote::SendPacket((uint64_t)this, v28);
    if ((char)v28[0].__r_.__value_.__s.__size_ < 0)
    {
      operator delete(v28[0].__r_.__value_.__l.__data_);
      if (((char)__str.__r_.__value_.__s.__size_ & 0x80000000) == 0)
      {
LABEL_56:
        if (((char)v34.__r_.__value_.__s.__size_ & 0x80000000) == 0)
        {
LABEL_58:
          StdStringExtractor::~StdStringExtractor(v35);
          return v19;
        }

  int v3 = (void **)this[9];
  uint64_t v4 = v2;
  if (v3 != v2)
  {
    do
    {
      v3 -= 11;
    }

    while (v3 != v2);
    uint64_t v4 = (void **)this[8];
  }

  this[9] = v2;
  operator delete(v4);
}

  uint64_t v4 = *(void ***)(a2 + 72);
  int v5 = v3;
  if (v4 != v3)
  {
    do
    {
      v4 -= 11;
    }

    while (v4 != v3);
    int v5 = *(void ***)(a2 + 64);
  }

  *(void *)(a2 + 72) = v3;
  operator delete(v5);
}

LABEL_57:
        operator delete(v34.__r_.__value_.__l.__data_);
        goto LABEL_58;
      }
    }

    else if (((char)__str.__r_.__value_.__s.__size_ & 0x80000000) == 0)
    {
      goto LABEL_56;
    }

    operator delete(__str.__r_.__value_.__l.__data_);
    goto LABEL_57;
  }

  v28[0].__r_.__value_.__s.__size_ = 2;
  strcpy((char *)v28, "OK");
  uint64_t v19 = RNBRemote::SendPacket((uint64_t)this, v28);
  return v19;
}

    if ((v22 & 1) != 0)
    {
LABEL_58:
      std::string::size_type v8 = 1LL;
LABEL_65:
      -[NSAutoreleasePool drain](v6, "drain");
      return v8;
    }

    goto LABEL_62;
  }

uint64_t RNBRemote::HandlePacket_QEnableCompression(RNBRemote *this, const char *a2)
{
  int v3 = a2 + 19;
  unint64_t v4 = *((void *)this + 98);
  int v5 = strstr(a2 + 19, "minsize:");
  if (v5)
  {
    std::string::size_type v6 = v5 + 8;
    *__error() = 0;
    unint64_t v4 = strtoul(v6, 0LL, 10);
    if (*__error() || v4 == -1LL) {
      unint64_t v4 = *((void *)this + 98);
    }
  }

  if (strstr(v3, "type:zlib-deflate;"))
  {
    *((_DWORD *)this + 199) = 0;
    goto LABEL_13;
  }

  if (strstr(v3, "type:lz4;"))
  {
    *((_DWORD *)this + 199) = 1;
LABEL_13:
    *((_BYTE *)this + 792) = 1;
    *((void *)this + 98) = v4;
LABEL_14:
    __p.__r_.__value_.__s.__size_ = 2;
    strcpy((char *)&__p, "OK");
    goto LABEL_15;
  }

  if (strstr(v3, "type:lzma;"))
  {
    *((_DWORD *)this + 199) = 2;
    *((_BYTE *)this + 792) = 1;
    *((void *)this + 98) = v4;
    goto LABEL_14;
  }

  if (strstr(v3, "type:lzfse;"))
  {
    *((_DWORD *)this + 199) = 3;
    goto LABEL_13;
  }

  __p.__r_.__value_.__s.__size_ = 3;
  LODWORD(__p.__r_.__value_.__l.__data_) = 3684421;
LABEL_15:
  uint64_t v8 = RNBRemote::SendPacket((uint64_t)this, &__p);
  return v8;
}

uint64_t RNBRemote::HandlePacket_WatchpointSupportInfo(RNBRemote *this, const char *a2)
{
  if (a2[22] == 58)
  {
    *__error() = 0;
    uint64_t NumSupportedHWP = DNBWatchpointGetNumSupportedHWP(*((_DWORD *)this + 3));
    v12[0].__r_.__value_.__r.__words[0] = v4;
    *(std::string::size_type *)((char *)v12[0].__r_.__value_.__r.__words + *(void *)(v4 - 24)) = v5;
    std::string::size_type v6 = (std::ios_base *)((char *)v12 + *(void *)(v12[0].__r_.__value_.__r.__words[0] - 24));
    std::ios_base::init(v6, &v12[0].__r_.__value_.__r.__words[1]);
    v6[1].__vftable = 0LL;
    v6[1].__fmtflags_ = -1;
    std::streambuf::basic_streambuf(&v12[0].__r_.__value_.__r.__words[1]);
    *(_OWORD *)int v13 = 0u;
    __int128 v14 = 0u;
    int v15 = 16;
    uint64_t v7 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v12, (uint64_t)"num:", 4LL);
    *(_DWORD *)((char *)v7 + *(void *)(*v7 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v7 + *(void *)(*v7 - 24LL) + 8) & 0xFFFFFFB5 | 2;
    uint64_t v8 = (void *)std::ostream::operator<<(v7, NumSupportedHWP);
    __p.__r_.__value_.__s.__data_[0] = 59;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)&__p, 1LL);
    std::stringbuf::str(&__p, (const std::stringbuf *)&v12[0].__r_.__value_.__r.__words[1]);
    uint64_t v9 = RNBRemote::SendPacket((uint64_t)this, &__p);
    *(std::string::size_type *)((char *)v12[0].__r_.__value_.__r.__words
    if (SBYTE7(v14) < 0) {
      operator delete(v13[0]);
    }
    std::streambuf::~streambuf(&v12[0].__r_.__value_.__r.__words[1]);
    std::ios::~ios(&v16);
  }

  else
  {
    if (a2[22])
    {
      v12[0].__r_.__value_.__s.__size_ = 3;
      LODWORD(v12[0].__r_.__value_.__l.__data_) = 3618373;
    }

    else
    {
      v12[0].__r_.__value_.__s.__size_ = 2;
      strcpy((char *)v12, "OK");
    }

    uint64_t v9 = RNBRemote::SendPacket((uint64_t)this, v12);
  }

  return v9;
}

uint64_t RNBRemote::HandlePacket_QSetProcessEvent(RNBRemote *this, const char *a2)
{
  int v3 = (char *)(a2 + 17);
  int v4 = *((_DWORD *)this + 3);
  if (v4)
  {
    if (!DNBProcessSendEvent(v4, v3))
    {
      __p.__r_.__value_.__s.__size_ = 3;
      LODWORD(__p.__r_.__value_.__l.__data_) = 3160133;
      goto LABEL_6;
    }
  }

  else
  {
    std::string::assign((std::string *)((char *)this + 416), v3);
  }

  __p.__r_.__value_.__s.__size_ = 2;
  strcpy((char *)&__p, "OK");
LABEL_6:
  uint64_t v5 = RNBRemote::SendPacket((uint64_t)this, &__p);
  return v5;
}

uint64_t RNBRemote::HandlePacket_QSetDetachOnError( RNBRemote *this, const char *a2, uint64_t a3, uint64_t a4, const char *a5)
{
  int v5 = a2[18];
  if (v5 == 48)
  {
    char v6 = 0;
  }

  else
  {
    if (v5 != 49) {
      return RNBRemote::HandlePacket_ILLFORMED( this,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  2384,  a2 + 18,  a5);
    }
    char v6 = 1;
  }

  *((_BYTE *)this + 440) = v6;
  __p.__r_.__value_.__s.__size_ = 2;
  strcpy((char *)&__p, "OK");
  uint64_t v7 = RNBRemote::SendPacket((uint64_t)this, &__p);
  return v7;
}

uint64_t RNBRemote::HandlePacket_qSpeedTest(RNBRemote *this, const char *a2)
{
  int v3 = a2 + 25;
  std::string __endptr = 0LL;
  *__error() = 0;
  size_t v4 = strtoul(v3, &__endptr, 16);
  if (*__error()) {
    return RNBRemote::HandlePacket_ILLFORMED( this,  "/Library/Caches/com.apple.xbs/Sources/lldb/llvm-project/lldb/tools/debugserver/source/RNBRemote.cpp",  4444,  v3,  v5);
  }
  if (*__endptr == 59)
  {
    strcpy((char *)&RNBRemote::HandlePacket_qSpeedTest(char const*)::g_data, "data:");
    memset((char *)&word_10007184C + 1, 97, v4);
    *((_BYTE *)&RNBRemote::HandlePacket_qSpeedTest(char const*)::g_data + v4 + 5) = 0;
    size_t v7 = strlen((const char *)&RNBRemote::HandlePacket_qSpeedTest(char const*)::g_data);
    if (v7 >= 0x7FFFFFFFFFFFFFF8LL) {
      abort();
    }
    std::string::size_type v8 = v7;
    if (v7 >= 0x17)
    {
      uint64_t v10 = (v7 & 0xFFFFFFFFFFFFFFF8LL) + 8;
      if ((v7 | 7) != 0x17) {
        uint64_t v10 = v7 | 7;
      }
      uint64_t v11 = v10 + 1;
      p_p = (std::string *)operator new(v10 + 1);
      __p.__r_.__value_.__l.__size_ = v8;
      __p.__r_.__value_.__l.__cap_ = v11 | 0x8000000000000000LL;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)p_p;
    }

    else
    {
      __p.__r_.__value_.__s.__size_ = v7;
      p_p = &__p;
      if (!v7) {
        goto LABEL_13;
      }
    }

    memcpy(p_p, &RNBRemote::HandlePacket_qSpeedTest(char const*)::g_data, v8);
LABEL_13:
    p_p->__r_.__value_.__s.__data_[v8] = 0;
    goto LABEL_14;
  }

  __p.__r_.__value_.__s.__size_ = 3;
  LODWORD(__p.__r_.__value_.__l.__data_) = 3749701;
LABEL_14:
  uint64_t v12 = RNBRemote::SendPacket((uint64_t)this, &__p);
  return v12;
}

const char *RNBRemote::HandlePacket_qXfer(RNBRemote *this, const char *a2)
{
  uint64_t v2 = a2;
  size_t v4 = a2 + 6;
  int v5 = strchr(a2 + 6, 58);
  if (v5)
  {
    char v6 = v5;
    size_t v7 = v5 - v4;
    if (v7 >= 0x17)
    {
      uint64_t v9 = (v7 & 0xFFFFFFFFFFFFFFF8LL) + 8;
      if ((v7 | 7) != 0x17) {
        uint64_t v9 = v7 | 7;
      }
      uint64_t v10 = v9 + 1;
      p_dst = (void **)operator new(v9 + 1);
      size_t v76 = v7;
      unint64_t v77 = v10 | 0x8000000000000000LL;
      std::string __dst = p_dst;
    }

    else
    {
      HIBYTE(v77) = (_BYTE)v5 - (_BYTE)v4;
      p_dst = (void **)&__dst;
      if (v5 == v4)
      {
LABEL_10:
        *((_BYTE *)p_dst + v7) = 0;
        uint64_t v11 = v6 + 1;
        uint64_t v12 = strchr(v6 + 1, 58);
        if (!v12)
        {
          __p[0].__r_.__value_.__s.__size_ = 3;
          LODWORD(__p[0].__r_.__value_.__l.__data_) = 3553349;
          RNBRemote::SendPacket((uint64_t)this, __p);
          goto LABEL_68;
        }

        int v13 = v12;
        size_t v14 = v12 - v11;
        if (v14 >= 0x17)
        {
          uint64_t v16 = (v14 & 0xFFFFFFFFFFFFFFF8LL) + 8;
          if ((v14 | 7) != 0x17) {
            uint64_t v16 = v14 | 7;
          }
          uint64_t v17 = v16 + 1;
          int v15 = (void **)operator new(v16 + 1);
          v73[1] = (void *)v14;
          unint64_t v74 = v17 | 0x8000000000000000LL;
          v73[0] = v15;
        }

        else
        {
          HIBYTE(v74) = (_BYTE)v12 - (_BYTE)v11;
          int v15 = v73;
          if (v12 == v11)
          {
LABEL_22:
            *((_BYTE *)v15 + v14) = 0;
            std::string::size_type v18 = v13 + 1;
            uint64_t v19 = strchr(v13 + 1, 58);
            if (!v19)
            {
              __p[0].__r_.__value_.__s.__size_ = 3;
              LODWORD(__p[0].__r_.__value_.__l.__data_) = 3487813;
              RNBRemote::SendPacket((uint64_t)this, __p);
              goto LABEL_66;
            }

            std::string v20 = v19;
            size_t v21 = v19 - v18;
            if (v21 >= 0x17)
            {
              uint64_t v23 = (v21 & 0xFFFFFFFFFFFFFFF8LL) + 8;
              if ((v21 | 7) != 0x17) {
                uint64_t v23 = v21 | 7;
              }
              uint64_t v24 = v23 + 1;
              std::string::size_type v22 = (void **)operator new(v23 + 1);
              v71[1] = (void *)v21;
              unint64_t v72 = v24 | 0x8000000000000000LL;
              v71[0] = v22;
            }

            else
            {
              HIBYTE(v72) = (_BYTE)v19 - (_BYTE)v18;
              std::string::size_type v22 = v71;
              if (v19 == v18)
              {
LABEL_34:
                *((_BYTE *)v22 + v21) = 0;
                BOOL v25 = v20 + 1;
                unint64_t v26 = strchr(v20 + 1, 44);
                if (!v26) {
                  goto LABEL_75;
                }
                int v27 = v26;
                size_t v28 = v26 - v25;
                if (v28 >= 0x17)
                {
                  uint64_t v30 = (v28 & 0xFFFFFFFFFFFFFFF8LL) + 8;
                  if ((v28 | 7) != 0x17) {
                    uint64_t v30 = v28 | 7;
                  }
                  uint64_t v31 = v30 + 1;
                  uint64_t v29 = (void **)operator new(v30 + 1);
                  v69[1] = (void *)v28;
                  int64_t v70 = v31 | 0x8000000000000000LL;
                  v69[0] = v29;
                }

                else
                {
                  HIBYTE(v70) = (_BYTE)v26 - (_BYTE)v25;
                  uint64_t v29 = v69;
                  if (v26 == v25)
                  {
LABEL_44:
                    *((_BYTE *)v29 + v28) = 0;
                    size_t v32 = v27 + 1;
                    size_t v33 = strlen(v27 + 1);
                    if (v33 <= 0x7FFFFFFFFFFFFFF7LL)
                    {
                      std::string v34 = (void *)v33;
                      if (v33 >= 0x17)
                      {
                        uint64_t v36 = (v33 & 0xFFFFFFFFFFFFFFF8LL) + 8;
                        if ((v33 | 7) != 0x17) {
                          uint64_t v36 = v33 | 7;
                        }
                        uint64_t v37 = v36 + 1;
                        __int128 v35 = (void **)operator new(v36 + 1);
                        v67[1] = v34;
                        int64_t v68 = v37 | 0x8000000000000000LL;
                        v67[0] = v35;
                      }

                      else
                      {
                        HIBYTE(v68) = v33;
                        __int128 v35 = v67;
                        if (!v33)
                        {
LABEL_52:
                          *((_BYTE *)v34 + (void)v35) = 0;
                          std::string __endptr = 0LL;
                          if (v70 >= 0) {
                            uint64_t v38 = (const char *)v69;
                          }
                          else {
                            uint64_t v38 = (const char *)v69[0];
                          }
                          unint64_t v39 = strtoul(v38, &__endptr, 16);
                          if (*__endptr
                            || ((v40 = v39, v68 >= 0) ? (__int128 v41 = (const char *)v67) : (__int128 v41 = (const char *)v67[0]),
                                unint64_t v42 = strtoul(v41, &__endptr, 16),
                                *__endptr))
                          {
                            int v43 = 1;
                            if ((SHIBYTE(v68) & 0x80000000) == 0) {
                              goto LABEL_62;
                            }
                            goto LABEL_61;
                          }

                          std::string::size_type v47 = v42;
                          if (SHIBYTE(v77) < 0)
                          {
                            if (v76 != 8) {
                              goto LABEL_97;
                            }
                            uint64_t v48 = __dst;
                          }

                          else
                          {
                            if (SHIBYTE(v77) != 8) {
                              goto LABEL_97;
                            }
                            uint64_t v48 = (void **)&__dst;
                          }

                          if (*v48 == (void *)0x7365727574616566LL
                            && std::operator==[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>( v73,  "read")
                            && std::operator==[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>( v71,  "target.xml"))
                          {
                            std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)__p);
                            if (v40)
                            {
                              std::string::size_type v49 = *(void *)&g_target_xml[8];
                              if (g_target_xml[23] >= 0) {
                                std::string::size_type v49 = g_target_xml[23];
                              }
                              if (v40 >= v49) {
                                goto LABEL_141;
                              }
                              std::string::basic_string( &v64,  (const std::string *)g_target_xml,  v40,  v47,  (std::allocator<char> *)&v63);
                              std::string::size_type size = v64.__r_.__value_.__s.__size_;
                              if ((v64.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                                std::string::size_type size = v64.__r_.__value_.__l.__size_;
                              }
                              if (size >= v47) {
                                std::string::value_type v51 = 109;
                              }
                              else {
                                std::string::value_type v51 = 108;
                              }
                              v63.__r_.__value_.__s.__data_[0] = v51;
                              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( __p,  (uint64_t)&v63,  1LL);
                              if ((v64.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                                unint64_t v55 = &v64;
                              }
                              else {
                                unint64_t v55 = (std::string *)v64.__r_.__value_.__r.__words[0];
                              }
                              std::string::basic_string[abi:nn180100]<0>(v61, (char *)v55);
                              binary_encode_string((unsigned __int8 *)v61, &v63);
                              if ((v63.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                                std::stringbuf v56 = &v63;
                              }
                              else {
                                std::stringbuf v56 = (std::string *)v63.__r_.__value_.__r.__words[0];
                              }
                              if ((v63.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                                uint64_t v57 = v63.__r_.__value_.__s.__size_;
                              }
                              else {
                                uint64_t v57 = v63.__r_.__value_.__l.__size_;
                              }
                              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( __p,  (uint64_t)v56,  v57);
                              if ((char)v63.__r_.__value_.__s.__size_ < 0)
                              {
                                operator delete(v63.__r_.__value_.__l.__data_);
                                if ((v62 & 0x80000000) == 0)
                                {
LABEL_123:
LABEL_141:
                                  std::stringbuf::str( &v64,  (const std::stringbuf *)&__p[0].__r_.__value_.__r.__words[1]);
                                  goto LABEL_142;
                                }
                              }

                              else if ((v62 & 0x80000000) == 0)
                              {
                                goto LABEL_123;
                              }

                              operator delete(v61[0]);
LABEL_139:
                              char v60 = (void *)v64.__r_.__value_.__r.__words[0];
LABEL_140:
                              operator delete(v60);
                              goto LABEL_141;
                            }

                            RNBRemote::InitializeRegisters(this, 1);
                            UpdateTargetXML();
                            if (g_target_xml[23] < 0)
                            {
                              std::string::size_type v52 = *(void *)&g_target_xml[8];
                              if (*(void *)&g_target_xml[8]) {
                                goto LABEL_102;
                              }
                            }

                            else
                            {
                              std::string::size_type v52 = g_target_xml[23];
                              if (g_target_xml[23])
                              {
LABEL_102:
                                if (v47 <= v52)
                                {
                                  v64.__r_.__value_.__s.__data_[0] = 109;
                                  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( __p,  (uint64_t)&v64,  1LL);
                                  std::string::basic_string( &v63,  (const std::string *)g_target_xml,  0LL,  v47,  (std::allocator<char> *)v61);
                                  binary_encode_string((unsigned __int8 *)&v63, &v64);
                                  if ((v64.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                                    std::string::pointer v58 = &v64;
                                  }
                                  else {
                                    std::string::pointer v58 = (std::string *)v64.__r_.__value_.__r.__words[0];
                                  }
                                  if ((v64.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                                    uint64_t v59 = v64.__r_.__value_.__s.__size_;
                                  }
                                  else {
                                    uint64_t v59 = v64.__r_.__value_.__l.__size_;
                                  }
                                  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( __p,  (uint64_t)v58,  v59);
                                  char v60 = (void *)v63.__r_.__value_.__r.__words[0];
                                  goto LABEL_140;
                                }

                                v64.__r_.__value_.__s.__data_[0] = 108;
                                std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( __p,  (uint64_t)&v64,  1LL);
                                binary_encode_string((unsigned __int8 *)g_target_xml, &v64);
                                if ((v64.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                                  int v53 = &v64;
                                }
                                else {
                                  int v53 = (std::string *)v64.__r_.__value_.__r.__words[0];
                                }
                                if ((v64.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                                  uint64_t v54 = v64.__r_.__value_.__s.__size_;
                                }
                                else {
                                  uint64_t v54 = v64.__r_.__value_.__l.__size_;
                                }
                                std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( __p,  (uint64_t)v53,  v54);
                                goto LABEL_139;
                              }
                            }

                            std::string::basic_string[abi:nn180100]<0>(&v64, "E83");
LABEL_142:
                            uint64_t v2 = (const char *)RNBRemote::SendPacket((uint64_t)this, &v64);
                            std::ostringstream::~ostringstream((uint64_t)__p);
LABEL_98:
                            int v43 = 0;
                            if ((SHIBYTE(v68) & 0x80000000) == 0)
                            {
LABEL_62:
                              if (SHIBYTE(v70) < 0)
                              {
                                operator delete(v69[0]);
                                if (!v43)
                                {
LABEL_64:
                                  if ((SHIBYTE(v72) & 0x80000000) == 0) {
                                    goto LABEL_65;
                                  }
LABEL_76:
                                  operator delete(v71[0]);
                                  if ((v43 & 1) == 0) {
                                    goto LABEL_77;
                                  }
LABEL_66:
                                  char v44 = 1;
                                  if ((SHIBYTE(v74) & 0x80000000) == 0) {
                                    goto LABEL_67;
                                  }
LABEL_78:
                                  operator delete(v73[0]);
                                  if ((v44 & 1) == 0) {
                                    goto LABEL_79;
                                  }
LABEL_68:
                                  int v45 = 1;
                                  if ((SHIBYTE(v77) & 0x80000000) == 0) {
                                    goto LABEL_70;
                                  }
                                  goto LABEL_69;
                                }
                              }

                              else if (!v43)
                              {
                                goto LABEL_64;
                              }

LABEL_69:
                                  operator delete(__dst);
                                  goto LABEL_70;
                                }

                                goto LABEL_78;
                              }

                              goto LABEL_76;
                            }

  if (std::operator==[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(&__dst, "BREAKPOINT"))
  {
    size_t v4 = 64LL;
  }

  else if (std::operator==[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(&__dst, "SYSCALL"))
  {
    size_t v4 = 128LL;
  }

  else if (std::operator==[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(&__dst, "MACH_SYSCALL"))
  {
    size_t v4 = 256LL;
  }

  else if (std::operator==[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(&__dst, "RPC_ALERT"))
  {
    size_t v4 = 512LL;
  }

  else if (std::operator==[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(&__dst, "CRASH"))
  {
    size_t v4 = 1024LL;
  }

  else if (std::operator==[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(&__dst, "RESOURCE"))
  {
    size_t v4 = 2048LL;
  }

  else if (std::operator==[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(&__dst, "GUARD"))
  {
    size_t v4 = 4096LL;
  }

  else if (std::operator==[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(&__dst, "CORPSE_NOTIFY"))
  {
    size_t v4 = 0x2000LL;
  }

  else
  {
    size_t v4 = 0LL;
  }

    *a2 = 0LL;
    a2[1] = 0LL;
    a2[2] = 0LL;
    return;
  }

  if ((char)v5 < 0)
  {
    uint64_t v29 = v2;
    uint64_t v2 = (void **)*v2;
    int v5 = (unint64_t)v29[1];
  }

  if (v5 >= v12 + 4) {
    int v13 = v12 + 4;
  }
  else {
    int v13 = v5;
  }
  if (v13 > 0x7FFFFFFFFFFFFFF7LL) {
LABEL_81:
  }
    std::string::__throw_length_error[abi:ne180100]();
LABEL_29:
  if (v13 >= 0x17)
  {
    unint64_t v26 = (v13 & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((v13 | 7) != 0x17) {
      unint64_t v26 = v13 | 7;
    }
    int v27 = v26 + 1;
    size_t v28 = operator new(v26 + 1);
    a2[1] = v13;
    a2[2] = v27 | 0x8000000000000000LL;
    *a2 = v28;
    a2 = v28;
  }

  else
  {
    *((_BYTE *)a2 + 23) = v13;
    if (!v13) {
      goto LABEL_74;
    }
  }

  memmove(a2, v2, v13);
LABEL_74:
  *((_BYTE *)a2 + v13) = 0;
}

LABEL_61:
                            operator delete(v67[0]);
                            goto LABEL_62;
                          }

LABEL_97:
                          uint64_t v2 = (const char *)RNBRemote::HandlePacket_UNIMPLEMENTED(this, v2);
                          goto LABEL_98;
                        }
                      }

                      memmove(v35, v32, (size_t)v34);
                      goto LABEL_52;
                    }

  if (!g_num_reg_entries) {
    RNBRemote::InitializeRegisters(v2, 0);
  }
  if (g_reg_entries && g_num_reg_entries)
  {
    uint64_t v67 = 0LL;
    int64_t v68 = 1;
    do
    {
      std::string::size_type v69 = g_reg_entries + (v67 << 7);
      int64_t v70 = *(_DWORD *)(v69 + 8);
      if ((v70 & 0xFFFFFFFD) == 1
        && !*(void *)(v69 + 64)
        && DNBThreadGetRegisterValueByID( v125,  v4,  v70,  *(_DWORD *)(g_reg_entries + (v67 << 7) + 12),  &v127))
      {
        debugserver_regnum_with_fixed_width_hex_register_value( (uint64_t *)__p,  v125,  v4,  (unsigned __int8 *)(g_reg_entries + (v67 << 7)),  &v127);
      }

      uint64_t v67 = v68++;
    }

    while (g_num_reg_entries > v67);
  }

  if (data == 3)
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"reason:exec;", 12LL);
  }

  else if (LODWORD(v141[0].__r_.__value_.__l.__data_) == 4)
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"reason:watchpoint;", 18LL);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"description:", 12LL);
    v127.__darwin_time_t tv_sec = v121;
    *(__darwin_time_t *)((char *)&v127.tv_sec + *(void *)(v121 - 24)) = v120;
    uint64_t v71 = (std::ios_base *)((char *)&v127 + *(void *)(v127.tv_sec - 24));
    std::ios_base::init(v71, &v127.tv_usec);
    v71[1].__vftable = 0LL;
    v71[1].__fmtflags_ = -1;
    std::streambuf::basic_streambuf(&v127.tv_usec);
    *(_OWORD *)unint64_t v130 = 0u;
    __int128 v131 = 0u;
    __int128 v132 = 16;
    unint64_t v72 = (void *)std::ostream::operator<<(&v127, v143);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v72, (uint64_t)" ", 1LL);
    unsigned int v73 = (void *)std::ostream::operator<<(&v127, v144);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v73, (uint64_t)" ", 1LL);
    std::ostream::operator<<(&v127, v142);
    std::stringbuf::str(&v126, (const std::stringbuf *)&v127.tv_usec);
    append_hexified_string((uint64_t)__p, (unsigned __int8 *)&v126);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)";", 1LL);
    unint64_t v74 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"watch_addr:", 11LL);
    *(_DWORD *)((char *)v74 + *(void *)(*v74 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v74 + *(void *)(*v74 - 24LL) + 8) & 0xFFFFFFB5 | 8;
    uid_t v75 = (void *)std::ostream::operator<<(v74, v143);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v75, (uint64_t)";", 1LL);
    size_t v76 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"me_watch_addr:", 14LL);
    *(_DWORD *)((char *)v76 + *(void *)(*v76 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v76 + *(void *)(*v76 - 24LL) + 8) & 0xFFFFFFB5 | 8;
    unint64_t v77 = (void *)std::ostream::operator<<(v76, v142);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v77, (uint64_t)";", 1LL);
    uint64_t v78 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"wp_hw_idx:", 10LL);
    *(_DWORD *)((char *)v78 + *(void *)(*v78 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v78 + *(void *)(*v78 - 24LL) + 8) & 0xFFFFFFB5 | 8;
    unint64_t v79 = (void *)std::ostream::operator<<(v78, v144);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)";", 1LL);
    if (BYTE4(v144))
    {
      std::string::size_type v80 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"wp_esr_iss:", 11LL);
      *(_DWORD *)((char *)v80 + *(void *)(*v80 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v80 + *(void *)(*v80 - 24LL) + 8) & 0xFFFFFFB5 | 8;
      unint64_t v81 = (void *)std::ostream::operator<<(v80, v145);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v81, (uint64_t)";", 1LL);
      __int128 v82 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"wp_esr_wpt:", 11LL);
      *(_DWORD *)((char *)v82 + *(void *)(*v82 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v82 + *(void *)(*v82 - 24LL) + 8) & 0xFFFFFFB5 | 8;
      __int128 v83 = (void *)std::ostream::operator<<(v82, v146);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v83, (uint64_t)";", 1LL);
      std::string::size_type v84 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"wp_esr_wptv:", 12LL);
      uint64_t v85 = (void *)std::ostream::operator<<(v84, v147);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v85, (uint64_t)";", 1LL);
      std::string::size_type v86 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"wp_esr_wpf:", 11LL);
      int v87 = (void *)std::ostream::operator<<(v86, v148);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v87, (uint64_t)";", 1LL);
      std::string::size_type v88 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"wp_esr_fnp:", 11LL);
      __int128 v89 = (void *)std::ostream::operator<<(v88, v149);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v89, (uint64_t)";", 1LL);
      std::string::size_type v90 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"wp_esr_vncr:", 12LL);
      __int128 v91 = (void *)std::ostream::operator<<(v90, v150);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v91, (uint64_t)";", 1LL);
      uint64_t v92 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"wp_esr_fnv:", 11LL);
      std::string::size_type v93 = (void *)std::ostream::operator<<(v92, v151);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v93, (uint64_t)";", 1LL);
      int v94 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"wp_esr_cm:", 10LL);
      char v95 = (void *)std::ostream::operator<<(v94, v152);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v95, (uint64_t)";", 1LL);
      uint64_t v96 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"wp_esr_wnr:", 11LL);
      __n128 v97 = (void *)std::ostream::operator<<(v96, v153);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v97, (uint64_t)";", 1LL);
      __int128 v98 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"wp_esr_dfsc:", 12LL);
      *(_DWORD *)((char *)v98 + *(void *)(*v98 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v98 + *(void *)(*v98 - 24LL) + 8) & 0xFFFFFFB5 | 8;
      uint64_t v99 = (void *)std::ostream::operator<<(v98, v154);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v99, (uint64_t)";", 1LL);
    }

    if (SBYTE7(v131) < 0) {
      operator delete(v130[0]);
    }
    std::streambuf::~streambuf(&v127.tv_usec);
    std::ios::~ios(v133);
    size_t v4 = v123;
  }

  else if ((_DWORD)v142)
  {
    std::string::size_type v100 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"metype:", 7LL);
    uint64_t v101 = (void *)std::ostream::operator<<(v100, v142);
    LOBYTE(v127.tv_sec) = 59;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v101, (uint64_t)&v127, 1LL);
    uint64_t v102 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"mecount:", 8LL);
    uint64_t v103 = (void *)std::ostream::operator<<();
    LOBYTE(v127.tv_sec) = 59;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v103, (uint64_t)&v127, 1LL);
    if (v143)
    {
      for (unsigned int i = 0LL; i < v143; ++i)
      {
        uint64_t v105 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"medata:", 7LL);
        *(_DWORD *)((char *)v105 + *(void *)(*v105 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v105
                                                                              + *(void *)(*v105 - 24LL)
                                                                              + 8) & 0xFFFFFFB5 | 8;
        size_t v106 = (void *)std::ostream::operator<<(v105, *(&v144 + i));
        LOBYTE(v127.tv_sec) = 59;
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v106, (uint64_t)&v127, 1LL);
      }
    }
  }

  *(void *)&v127.uint64_t tv_usec = 0LL;
  uint64_t v128 = 0LL;
  v127.__darwin_time_t tv_sec = (__darwin_time_t)&v127.tv_usec;
  ReadStackMemory(v125, v4, (uint64_t **)&v127, 2u);
  if (v128)
  {
    uint64_t v107 = v127.tv_sec;
    if ((__darwin_suseconds_t *)v127.tv_sec != &v127.tv_usec)
    {
      do
      {
        std::string v108 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"memory:", 7LL);
        v126.__r_.__value_.__s.__data_[0] = 48;
        unint64_t v109 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v108, (uint64_t)&v126, 1LL);
        v126.__r_.__value_.__s.__data_[0] = 120;
        std::string v110 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v109, (uint64_t)&v126, 1LL);
        __int128 v111 = v110;
        int64_t v112 = *v110;
        std::string v113 = (char *)v110 + *(void *)(*v110 - 24);
        if (*((_DWORD *)v113 + 36) == -1)
        {
          std::ios_base::getloc((const std::ios_base *)((char *)v110 + *(void *)(*v110 - 24)));
          uint64_t v114 = std::locale::use_facet((const std::locale *)&v126, &std::ctype<char>::id);
          ((void (*)(const std::locale::facet *, uint64_t))v114->__vftable[2].~facet_0)(v114, 32LL);
          std::locale::~locale((std::locale *)&v126);
          int64_t v112 = *v111;
        }

        *((_DWORD *)v113 + 36) = 48;
        *(_DWORD *)((char *)v111 + *(void *)(v112 - 24) + 8) = *(_DWORD *)((_BYTE *)v111 + *(void *)(v112 - 24) + 8) & 0xFFFFFFB5 | 8;
        *(_DWORD *)((char *)v111 + *(void *)(v112 - 24) + 8) = *(_DWORD *)((_BYTE *)v111 + *(void *)(v112 - 24) + 8) & 0xFFFFFF4F | 0x80;
        uint64_t v115 = (void *)std::ostream::operator<<(v111, *(void *)(v107 + 32));
        v126.__r_.__value_.__s.__data_[0] = 61;
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v115, (uint64_t)&v126, 1LL);
        append_hex_value((uint64_t)__p, (unsigned __int8 *)(v107 + 40), *(void *)(v107 + 56), 0);
        v126.__r_.__value_.__s.__data_[0] = 59;
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)&v126, 1LL);
        unint64_t v116 = *(timeval **)(v107 + 8);
        if (v116)
        {
          do
          {
            __int128 v117 = v116;
            unint64_t v116 = (timeval *)v116->tv_sec;
          }

          while (v116);
        }

        else
        {
          do
          {
            __int128 v117 = *(timeval **)(v107 + 16);
            __int128 v118 = v117->tv_sec == v107;
            uint64_t v107 = (__darwin_time_t)v117;
          }

          while (!v118);
        }

        uint64_t v107 = (__darwin_time_t)v117;
      }

      while (v117 != (timeval *)&v127.tv_usec);
    }
  }

  std::stringbuf::str(&v126, (const std::stringbuf *)&__p[0].__r_.__value_.__r.__words[1]);
  uint64_t v16 = RNBRemote::SendPacket((uint64_t)v124, &v126);
  std::__tree<std::__value_type<unsigned int,DNBArchPluginInfoTag>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,DNBArchPluginInfoTag>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,DNBArchPluginInfoTag>>>::destroy( (uint64_t)&v127,  *(void **)&v127.tv_usec);
  *(std::string::size_type *)((char *)__p[0].__r_.__value_.__r.__words
  if (SBYTE7(v138) < 0) {
    operator delete((void *)v137);
  }
  std::streambuf::~streambuf(&__p[0].__r_.__value_.__r.__words[1]);
  std::ios::~ios(&v140);
  return v16;
}

LABEL_145:
                    abort();
                  }
                }

                memmove(v29, v25, v28);
                goto LABEL_44;
              }
            }

            memmove(v22, v18, v21);
            goto LABEL_34;
          }
        }

        memmove(v15, v11, v14);
        goto LABEL_22;
      }
    }

    memcpy(p_dst, v4, v7);
    goto LABEL_10;
  }

LABEL_71:
  __p[0].__r_.__value_.__s.__size_ = 3;
  LODWORD(__p[0].__r_.__value_.__l.__data_) = 3291205;
  uint64_t v2 = (const char *)RNBRemote::SendPacket((uint64_t)this, __p);
  return v2;
}

std::ios_base *RNBRemote::HandlePacket_jGetDyldProcessState(RNBRemote *this, const char *a2, __n128 a3)
{
  int v4 = *((_DWORD *)this + 3);
  if (v4)
  {
    DNBGetDyldProcessState(v4, (uint64_t)&v19, a3);
    if (!v19)
    {
LABEL_15:
      v14[0].__r_.__value_.__s.__size_ = 3;
      LODWORD(v14[0].__r_.__value_.__l.__data_) = 3684421;
      std::string::size_type size = (std::ios_base *)RNBRemote::SendPacket((uint64_t)this, v14);
LABEL_17:
      uint64_t v9 = v20;
      if (v20)
      {
        p_shared_owners = (unint64_t *)&v20->__shared_owners_;
        do
          unint64_t v11 = __ldaxr(p_shared_owners);
        while (__stlxr(v11 - 1, p_shared_owners));
        if (!v11)
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
      }

      return size;
    }

    v14[0].__r_.__value_.__r.__words[0] = v5;
    *(std::string::size_type *)((char *)v14[0].__r_.__value_.__r.__words + *(void *)(v5 - 24)) = v6;
    std::string::size_type size = (std::ios_base *)((char *)v14 + *(void *)(v14[0].__r_.__value_.__r.__words[0] - 24));
    std::ios_base::init(size, &v14[0].__r_.__value_.__r.__words[1]);
    size[1].__vftable = 0LL;
    size[1].__fmtflags_ = -1;
    std::streambuf::basic_streambuf(&v14[0].__r_.__value_.__r.__words[1]);
    *(_OWORD *)int v15 = 0u;
    __int128 v16 = 0u;
    int v17 = 16;
    (*(void (**)(uint64_t, std::string *))(*(void *)v19 + 40LL))(v19, v14);
    (*(void (**)(uint64_t))(*(void *)v19 + 24LL))(v19);
    std::stringbuf::str(&__p, (const std::stringbuf *)&v14[0].__r_.__value_.__r.__words[1]);
    if ((char)__p.__r_.__value_.__s.__size_ < 0)
    {
      std::string::size_type size = (std::ios_base *)__p.__r_.__value_.__l.__size_;
      operator delete(__p.__r_.__value_.__l.__data_);
      if (size) {
        goto LABEL_5;
      }
    }

    else if (__p.__r_.__value_.__s.__size_)
    {
LABEL_5:
      std::stringbuf::str(&__p, (const std::stringbuf *)&v14[0].__r_.__value_.__r.__words[1]);
      std::string::size_type size = (std::ios_base *)RNBRemote::SendPacket((uint64_t)this, &__p);
      int v8 = 0;
LABEL_12:
      *(std::string::size_type *)((char *)v14[0].__r_.__value_.__r.__words
      if (SBYTE7(v16) < 0) {
        operator delete(v15[0]);
      }
      std::streambuf::~streambuf(&v14[0].__r_.__value_.__r.__words[1]);
      std::ios::~ios(&v18);
      if (!v8) {
        goto LABEL_17;
      }
      goto LABEL_15;
    }

    int v8 = 1;
    goto LABEL_12;
  }

  v14[0].__r_.__value_.__s.__size_ = 3;
  LODWORD(v14[0].__r_.__value_.__l.__data_) = 3618885;
  std::string::size_type size = (std::ios_base *)RNBRemote::SendPacket((uint64_t)this, v14);
  return size;
}

int *RNBRemote::FlushSTDIO(int *this)
{
  int v1 = this[3];
  if (v1)
  {
    uint64_t v2 = (RNBRemote *)this;
    size_t AvailableSTDOUT = DNBProcessGetAvailableSTDOUT(this[3], v6, 0x100uLL);
    if (AvailableSTDOUT)
    {
      size_t v4 = AvailableSTDOUT;
      do
      {
        RNBRemote::SendHexEncodedBytePacket(v2, "O", (unsigned __int8 *)v6, v4, 0LL);
        size_t v4 = DNBProcessGetAvailableSTDOUT(v1, v6, 0x100uLL);
      }

      while (v4);
    }

    this = (int *)DNBProcessGetAvailableSTDERR(v1, v6);
    if (this)
    {
      uint64_t v5 = (uint64_t)this;
      do
      {
        RNBRemote::SendHexEncodedBytePacket(v2, "O", (unsigned __int8 *)v6, v5, 0LL);
        this = (int *)DNBProcessGetAvailableSTDERR(v1, v6);
        uint64_t v5 = (uint64_t)this;
      }

      while (this);
    }
  }

  return this;
}

size_t RNBRemote::SendAsyncProfileData(size_t this)
{
  int v1 = *(_DWORD *)(this + 12);
  if (v1)
  {
    uint64_t v2 = this;
    this = DNBProcessGetAvailableProfileData(*(_DWORD *)(this + 12), __s, 0x400uLL);
    if (this)
    {
      std::string::size_type v3 = this;
      do
      {
        __p.__r_.__value_.__s.__size_ = 1;
        LOWORD(__p.__r_.__value_.__l.__data_) = 65;
        std::string::append(&__p, __s, v3);
        RNBRemote::SendPacket(v2, &__p);
        this = DNBProcessGetAvailableProfileData(v1, __s, 0x400uLL);
        std::string::size_type v3 = this;
      }

      while (this);
    }
  }

  return this;
}

uint64_t RNBRemote::SendHexEncodedBytePacket( RNBRemote *this, const char *a2, unsigned __int8 *a3, uint64_t a4, const char *a5)
{
  std::string::size_type v22 = v8;
  *(void (__cdecl ***)(std::ostringstream *__hidden))((char *)&v22 + (void)*(v8 - 3)) = v9;
  uint64_t v10 = (std::ios_base *)((char *)&v22 + (void)*(v22 - 3));
  std::ios_base::init(v10, &v23);
  v10[1].__vftable = 0LL;
  v10[1].__fmtflags_ = -1;
  std::streambuf::basic_streambuf(&v23);
  memset(&v23.__str_, 0, 32);
  v23.__mode_ = 16;
  if (a2 && *a2)
  {
    size_t v11 = strlen(a2);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v22, (uint64_t)a2, v11);
  }

  for (; a4; --a4)
  {
    int v13 = v22;
    size_t v14 = (char *)&v22 + (void)*(v22 - 3);
    if (*((_DWORD *)v14 + 36) == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)&v22 + (void)*(v22 - 3)));
      int v15 = std::locale::use_facet((const std::locale *)&v21, &std::ctype<char>::id);
      ((void (*)(const std::locale::facet *, uint64_t))v15->__vftable[2].~facet_0)(v15, 32LL);
      std::locale::~locale((std::locale *)&v21);
      int v13 = v22;
    }

    *((_DWORD *)v14 + 36) = 48;
    *(_DWORD *)((char *)&v23.__vftable + (void)*(v13 - 3)) = *(_DWORD *)((_BYTE *)&v23.__vftable + (void)*(v13 - 3)) & 0xFFFFFFB5 | 8;
    *(_DWORD *)((char *)&v23.__vftable + (void)*(v13 - 3)) = *(_DWORD *)((_BYTE *)&v23.__vftable + (void)*(v13 - 3)) & 0xFFFFFF4F | 0x80;
    *(std::streambuf::char_type **)((char *)&v23.__binp_ + (void)*(v13 - 3)) = (std::streambuf::char_type *)2;
    unsigned int v12 = *a3++;
    std::ostream::operator<<(&v22, v12);
  }

  if (a5 && *a5)
  {
    size_t v16 = strlen(a5);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v22, (uint64_t)a5, v16);
  }

  std::stringbuf::str(&v21, &v23);
  uint64_t v17 = RNBRemote::SendPacket((uint64_t)this, &v21);
  std::streambuf::~streambuf(&v23);
  std::ios::~ios(&v24);
  return v17;
}

uint64_t std::ostringstream::basic_ostringstream[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  *(void *)a1 = v4;
  *(void *)(a1 + *(void *)(v4 - 24)) = v3;
  uint64_t v5 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24LL));
  std::ios_base::init(v5, (void *)(a1 + 8));
  v5[1].__vftable = 0LL;
  v5[1].__fmtflags_ = -1;
  std::streambuf::basic_streambuf(v2);
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 16;
  return a1;
}

uint64_t RNBRemote::SendPacket(uint64_t a1, std::string *a2)
{
  if (DNBLogEnabledForAny(0x40000))
  {
    uint64_t v4 = *(pthread_mutex_t **)(a1 + 488);
    if (v4) {
      pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 488));
    }
    gettimeofday((timeval *)&v47, 0LL);
    int data = (int)v47.__r_.__value_.__l.__data_;
    int v6 = v47.__r_.__value_.__r.__words[1];
    uint64_t v7 = *(void *)(a1 + 496);
    int v8 = *(_DWORD *)(a1 + 504);
    *(_OWORD *)(a1 + 496) = *(_OWORD *)&v47.__r_.__value_.__l.__data_;
    if (v4) {
      pthread_mutex_unlock(v4);
    }
    if ((a2->__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v9 = (const char *)a2;
    }
    else {
      uint64_t v9 = (const char *)a2->__r_.__value_.__r.__words[0];
    }
    _DNBLogThreaded("%8d RNBRemote::%s (%s) called", v6 - v8 + 1000000 * (data - v7), "SendPacket", v9);
  }

  RNBRemote::CompressString(a2, a1, &v56);
  std::operator+<char>(&v47, "$", &v56);
  uint64_t v10 = std::string::append(&v47, "#");
  std::string::size_type cap = v10->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v55.__r_.__value_.__l.__data_ = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  v55.__r_.__value_.__l.__cap_ = cap;
  v10->__r_.__value_.__l.__size_ = 0LL;
  v10->__r_.__value_.__l.__cap_ = 0LL;
  v10->__r_.__value_.__r.__words[0] = 0LL;
  if ((char)v47.__r_.__value_.__s.__size_ < 0)
  {
    operator delete(v47.__r_.__value_.__l.__data_);
    if (*(_BYTE *)(a1 + 781)) {
      goto LABEL_12;
    }
  }

  else if (*(_BYTE *)(a1 + 781))
  {
LABEL_12:
    unsigned int v12 = "00";
    goto LABEL_31;
  }

  std::string::size_type size = v56.__r_.__value_.__s.__size_;
  if ((v56.__r_.__value_.__s.__size_ & 0x80u) != 0) {
    std::string::size_type size = v56.__r_.__value_.__l.__size_;
  }
  if (size)
  {
    size_t v14 = (std::string *)v56.__r_.__value_.__r.__words[0];
    if (size == 1)
    {
      unint64_t v15 = 0LL;
      unsigned __int8 v16 = 0;
    }

    else
    {
      char v18 = 0;
      char v19 = 0;
      unint64_t v15 = size & 0xFFFFFFFFFFFFFFFELL;
      std::string v20 = &v56;
      if ((v56.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        std::string v20 = (std::string *)v56.__r_.__value_.__r.__words[0];
      }
      std::stringbuf::string_type v21 = &v20->__r_.__value_.__s.__data_[1];
      unint64_t v22 = size & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        std::string::value_type v24 = v20->__r_.__value_.__s.__data_[0];
        std::string v20 = (std::string *)((char *)v20 + 2);
        std::string::value_type v23 = v24;
        std::string::value_type v25 = *v21;
        v21 += 2;
        v18 += v23;
        v19 += v25;
        v22 -= 2LL;
      }

      while (v22);
      unsigned __int8 v16 = v19 + v18;
      if (size == v15) {
        goto LABEL_29;
      }
    }

    if ((v56.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v14 = &v56;
    }
    std::string::size_type v26 = size - v15;
    int v27 = (char *)v14 + v15;
    do
    {
      char v28 = *v27++;
      v16 += v28;
      --v26;
    }

    while (v26);
LABEL_29:
    int v17 = v16;
    goto LABEL_30;
  }

  int v17 = 0;
LABEL_30:
  unsigned int v12 = __str;
  snprintf(__str, 5uLL, "%02x", v17);
LABEL_31:
  std::string::append(&v55, v12);
  if ((v55.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v29 = &v55;
  }
  else {
    uint64_t v29 = (std::string *)v55.__r_.__value_.__r.__words[0];
  }
  if ((v55.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    size_t v30 = v55.__r_.__value_.__s.__size_;
  }
  else {
    size_t v30 = v55.__r_.__value_.__l.__size_;
  }
  uint64_t v31 = RNBSocket::Write((RNBSocket *)(a1 + 472), v29, v30);
  if ((_DWORD)v31) {
    goto LABEL_46;
  }
  if (!*(_BYTE *)(a1 + 781))
  {
    v52[0] = 0LL;
    v52[1] = 0LL;
    uint64_t v53 = 0LL;
    LODWORD(v47.__r_.__value_.__l.__data_) = 0;
    *(_OWORD *)&v47.__r_.__value_.__r.__words[1] = 0u;
    __int128 v48 = 0u;
    *(_OWORD *)std::string::size_type v49 = 0u;
    *(_OWORD *)std::string __p = 0u;
    __int128 v51 = 0u;
    uint64_t Packet = RNBRemote::GetPacket(a1, v52, &v47, 1LL);
    if ((_DWORD)Packet)
    {
      uint64_t v31 = Packet;
      if (!DNBLogEnabledForAny(0x100000))
      {
        if ((SHIBYTE(v51) & 0x80000000) == 0) {
          goto LABEL_44;
        }
LABEL_68:
        operator delete(__p[1]);
        if ((SHIBYTE(__p[0]) & 0x80000000) == 0)
        {
LABEL_45:
          if ((SHIBYTE(v53) & 0x80000000) == 0) {
            goto LABEL_46;
          }
LABEL_70:
          operator delete(v52[0]);
          goto LABEL_47;
        }

        goto LABEL_69;
      }

      __int128 v41 = *(pthread_mutex_t **)(a1 + 488);
      if (v41) {
        pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 488));
      }
      gettimeofday(&v57, 0LL);
      int tv_sec = v57.tv_sec;
      __darwin_suseconds_t tv_usec = v57.tv_usec;
      uint64_t v44 = *(void *)(a1 + 496);
      int v45 = *(_DWORD *)(a1 + 504);
      *(timeval *)(a1 + 496) = v57;
      if (v41) {
        pthread_mutex_unlock(v41);
      }
      unsigned int v46 = &v55;
      if ((v55.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        unsigned int v46 = (std::string *)v55.__r_.__value_.__r.__words[0];
      }
      _DNBLogThreaded( "%8d RNBRemote::%s (%s) got error trying to get reply...",  tv_usec - v45 + 1000000 * (tv_sec - v44),  "SendPacket",  (const char *)v46);
      if (SHIBYTE(v51) < 0) {
        goto LABEL_68;
      }
    }

    else
    {
      if (DNBLogEnabledForAny(0x40000))
      {
        std::string v34 = *(pthread_mutex_t **)(a1 + 488);
        if (v34) {
          pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 488));
        }
        gettimeofday(&v57, 0LL);
        int v35 = v57.tv_sec;
        __darwin_suseconds_t v36 = v57.tv_usec;
        uint64_t v37 = *(void *)(a1 + 496);
        int v38 = *(_DWORD *)(a1 + 504);
        *(timeval *)(a1 + 496) = v57;
        if (v34) {
          pthread_mutex_unlock(v34);
        }
        unint64_t v39 = &v55;
        if ((v55.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          unint64_t v39 = (std::string *)v55.__r_.__value_.__r.__words[0];
        }
        std::string::size_type v40 = v52;
        if (v53 < 0) {
          std::string::size_type v40 = (void **)v52[0];
        }
        _DNBLogThreaded( "%8d RNBRemote::%s (%s) got reply: '%s'",  v36 - v38 + 1000000 * (v35 - v37),  "SendPacket",  (const char *)v39,  (const char *)v40);
      }

      uint64_t v31 = LODWORD(v47.__r_.__value_.__l.__data_) != 1;
      if (SHIBYTE(v51) < 0) {
        goto LABEL_68;
      }
    }

LABEL_44:
    if ((SHIBYTE(__p[0]) & 0x80000000) == 0) {
      goto LABEL_45;
    }
LABEL_69:
    operator delete(v49[0]);
    if (SHIBYTE(v53) < 0) {
      goto LABEL_70;
    }
LABEL_46:
    goto LABEL_47;
  }

  uint64_t v31 = 0LL;
  if ((char)v55.__r_.__value_.__s.__size_ < 0)
  {
LABEL_71:
    operator delete(v55.__r_.__value_.__l.__data_);
    return v31;
  }

    *((_DWORD *)a1 + 110) |= 1u;
    usleep(0x3D090u);
    if (DNBLogEnabled())
    {
      uint64_t v37 = getpid();
      _DNBLog( 0LL,  (uint64_t)"[LaunchAttach] (%d) Done napping after ptrace(PT_ATTACHEXC)'ing",  v38,  v39,  v40,  v41,  v42,  v43,  v37);
    }

    if (DNBLogEnabledForAny(2)) {
      _DNBLogThreaded("successfully attached to pid %d", a2);
    }
    uint64_t v29 = 0;
    a2 = *(unsigned int *)a1;
    if (SHIBYTE(v48) < 0) {
      goto LABEL_53;
    }
    goto LABEL_54;
  }

  __p[0] = (void *)(v18 | 0x100000000LL);
  if (SHIBYTE(v48) < 0)
  {
    *(_BYTE *)__p[1] = 0;
    *(void *)&__int128 v48 = 0LL;
  }

  else
  {
    LOBYTE(__p[1]) = 0;
    HIBYTE(v48) = 0;
  }

  if (DNBLogEnabled())
  {
    size_t v32 = (const char *)DNBError::AsString((DNBError *)__p);
    _DNBLogError("MachProcess::AttachForDebug failed to ptrace(PT_ATTACHEXC) pid %i: %s", a2, v32);
  }

  if (!LODWORD(__p[0])) {
    goto LABEL_44;
  }
LABEL_34:
  size_t v33 = (const char *)DNBError::AsString((DNBError *)__p);
  snprintf(a4, a5, "%s", v33);
  if (DNBLogEnabled())
  {
    std::string v34 = getpid();
    _DNBLogError("[LaunchAttach] (%d) MachProcess::AttachForDebug error: failed to attach to pid %d", v34, a2);
  }

  *(void *)size_t v50 = 0xE00000001LL;
  __int128 v51 = 1;
  std::string::size_type v52 = a2;
  std::string::size_type v49 = 648LL;
  if (!sysctl(v50, 4u, buffer, &v49, 0LL, 0LL) && (v55 & 8) != 0)
  {
    if (proc_pidinfo(a2, 13, 0LL, buffer, 64) == 64) {
      int v35 = v54;
    }
    else {
      int v35 = 0;
    }
    if (v35 == getpid())
    {
      __darwin_suseconds_t v36 = (const char *)DNBError::AsString((DNBError *)__p);
      snprintf( a4,  a5,  "%s - Failed to attach to pid %d, AttachForDebug() unable to ptrace(PT_ATTACHEXC)",  v36,  *(_DWORD *)a1);
    }

    else
    {
      uint64_t v44 = (const char *)DNBError::AsString((DNBError *)__p);
      snprintf(a4, a5, "%s - process %d is already being debugged by pid %d", v44, a2, v35);
      if (DNBLogEnabled())
      {
        int v45 = getpid();
        _DNBLogError( "[LaunchAttach] (%d) MachProcess::AttachForDebug pid %d is already being debugged by pid %d",  v45,  a2,  v35);
      }
    }
  }

  uint64_t v29 = 1;
  if (SHIBYTE(v48) < 0) {
LABEL_53:
  }
    operator delete(__p[1]);
LABEL_54:
  if ((v29 & 1) != 0) {
    return 0LL;
  }
  return a2;
}

uint64_t std::ostringstream::~ostringstream(uint64_t a1)
{
  uint64_t v3 = a1 + 8;
  std::streambuf::~streambuf(v3);
  std::ios::~ios(a1 + 112);
  return a1;
}

void RNBRemote::CompressString(std::string *__str@<X1>, uint64_t a2@<X0>, std::string *a3@<X8>)
{
  a3->__r_.__value_.__r.__words[0] = 0LL;
  a3->__r_.__value_.__l.__size_ = 0LL;
  a3->__r_.__value_.__l.__cap_ = 0LL;
  if (*(_BYTE *)(a2 + 792))
  {
    *(_BYTE *)(a2 + 792) = 0;
LABEL_4:
    std::string::operator=(a3, __str);
    return;
  }

  unsigned int v5 = *(_DWORD *)(a2 + 796);
  if (v5 == 4) {
    goto LABEL_4;
  }
  if (((char)__str->__r_.__value_.__s.__size_ & 0x80000000) == 0)
  {
    std::string::size_type size = __str->__r_.__value_.__s.__size_;
    if (*(void *)(a2 + 784) < size) {
      goto LABEL_7;
    }
LABEL_11:
    std::operator+<char>(__stra, "N", __str);
    *(_OWORD *)&a3->__r_.__value_.__l.__data_ = *(_OWORD *)__stra;
    a3->__r_.__value_.__l.__cap_ = v22;
    return;
  }

  std::string::size_type size = __str->__r_.__value_.__l.__size_;
  if (size <= *(void *)(a2 + 784)) {
    goto LABEL_11;
  }
LABEL_7:
  size_t v7 = size + 128;
  if (size == -128LL)
  {
    int v8 = 0LL;
  }

  else
  {
    if ((v7 & 0x8000000000000000LL) != 0) {
      abort();
    }
    int v8 = (unsigned __int8 *)operator new(size + 128);
    bzero(v8, v7);
  }

  if (RNBRemote::CompressString(std::string const&)::g_libcompress_scratchbuf_type == v5)
  {
LABEL_21:
    if (v5 <= 3)
    {
      int v10 = (char)__str->__r_.__value_.__s.__size_;
      size_t v11 = v10 >= 0 ? __str : (std::string *)__str->__r_.__value_.__r.__words[0];
      size_t v12 = v10 >= 0 ? __str->__r_.__value_.__s.__size_ : __str->__r_.__value_.__l.__size_;
      size_t v13 = compression_encode_buffer( v8,  v7,  (const uint8_t *)v11,  v12,  (void *)RNBRemote::CompressString(std::string const&)::g_libcompress_scratchbuf,  (compression_algorithm)dword_100051ED0[v5]);
      if (v13)
      {
        size_t v14 = v13;
        if ((char)a3->__r_.__value_.__s.__size_ < 0)
        {
          *a3->__r_.__value_.__l.__data_ = 0;
          a3->__r_.__value_.__l.__size_ = 0LL;
        }

        else
        {
          a3->__r_.__value_.__s.__data_[0] = 0;
          a3->__r_.__value_.__s.__size_ = 0;
        }

        std::string::reserve(a3, v13);
        std::string::assign(a3, "C");
        std::string::size_type v15 = __str->__r_.__value_.__s.__size_;
        if ((v15 & 0x80u) != 0LL) {
          std::string::size_type v15 = __str->__r_.__value_.__l.__size_;
        }
        snprintf(__stra, 0x10uLL, "%zu:", v15);
        __stra[15] = 0;
        std::string::append(a3, __stra);
        unsigned __int8 v16 = v8;
        do
        {
          unsigned int v18 = *v16++;
          unsigned int v17 = v18;
          uint64_t v19 = (1LL << v18) & 0x41800000001LL;
          BOOL v20 = v18 > 0x2A || v19 == 0;
          if (!v20 || v17 == 125)
          {
            std::string::push_back(a3, 125);
            LOBYTE(v17) = v17 ^ 0x20;
          }

          std::string::push_back(a3, v17);
          --v14;
        }

        while (v14);
LABEL_34:
        operator delete(v8);
        return;
      }
    }

    goto LABEL_31;
  }

  if (RNBRemote::CompressString(std::string const&)::g_libcompress_scratchbuf)
  {
    free((void *)RNBRemote::CompressString(std::string const&)::g_libcompress_scratchbuf);
    RNBRemote::CompressString(std::string const&)::g_libcompress_scratchbuf = 0LL;
  }

  if (v5 <= 3)
  {
    size_t v9 = compression_encode_scratch_buffer_size((compression_algorithm)dword_100051ED0[v5]);
    if (v9)
    {
      RNBRemote::CompressString(std::string const&)::g_libcompress_scratchbuf = (uint64_t)malloc(v9);
      RNBRemote::CompressString(std::string const&)::g_libcompress_scratchbuf_type = v5;
    }

    goto LABEL_21;
  }

void *std::vector<unsigned char>::vector(void *a1, size_t __sz)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if (__sz)
  {
    if ((__sz & 0x8000000000000000LL) != 0) {
      abort();
    }
    uint64_t v4 = (char *)operator new(__sz);
    *a1 = v4;
    unsigned int v5 = &v4[__sz];
    a1[2] = &v4[__sz];
    bzero(v4, __sz);
    a1[1] = v5;
  }

  return a1;
}

__darwin_time_t DNBTimer::ElapsedMicroSeconds(pthread_mutex_t **this, int a2)
{
  uint64_t v4 = *this;
  if (*this) {
    pthread_mutex_lock(*this);
  }
  gettimeofday(&v12, 0LL);
  size_t v7 = this[1];
  unsigned int v5 = (timeval *)(this + 1);
  int v6 = v7;
  uint64_t tv_usec = v5->tv_usec;
  if (a2) {
    *unsigned int v5 = v12;
  }
  __darwin_time_t tv_sec = v12.tv_sec;
  uint64_t v10 = v12.tv_usec;
  if (v4) {
    pthread_mutex_unlock(v4);
  }
  return v10 - tv_usec + 1000000 * (tv_sec - (void)v6);
}

uint64_t RNBRemote::GetPacket(uint64_t a1, std::string *a2, uint64_t a3, int a4)
{
  if (RNBRemote::GetPacketPayload(a1, &__str))
  {
    char EventBits = PThreadEvent::GetEventBits((pthread_mutex_t *)(a1 + 120));
    uint64_t v9 = 1LL;
    if (!a4 || (EventBits & 0x40) == 0) {
      goto LABEL_45;
    }
    while (1)
    {
      int v10 = PThreadEvent::WaitForSetEvents((pthread_mutex_t *)(a1 + 120), 0xA0u, 0LL);
      if (!v10)
      {
        while (1)
          ;
      }

      char v11 = v10;
      if (v11 < 0)
      {
        uint64_t v9 = 2LL;
        goto LABEL_46;
      }
    }
  }

  timeval v12 = *(__int128 **)(a1 + 672);
  size_t v13 = *(__int128 **)(a1 + 680);
  if (v12 != v13)
  {
    if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_str = &__str;
    }
    else {
      p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
    }
    if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type size = __str.__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type size = __str.__r_.__value_.__l.__size_;
    }
    uint64_t v16 = (uint64_t)v12 + 40;
    while (1)
    {
      if (*(char *)(v16 + 23) < 0)
      {
        std::string::size_type v17 = *(void *)(v16 + 8);
        if (v17 == -1LL) {
          abort();
        }
      }

      else
      {
        std::string::size_type v17 = *(unsigned __int8 *)(v16 + 23);
      }

      size_t v18 = size >= v17 ? v17 : size;
      uint64_t v19 = *(char *)(v16 + 23) >= 0 ? (const void *)v16 : *(const void **)v16;
      if (!memcmp(p_str, v19, v18) && v17 <= size) {
        break;
      }
      std::stringbuf::string_type v21 = (__int128 *)(v16 + 48);
      v16 += 88LL;
      if (v21 == v13) {
        goto LABEL_37;
      }
    }

    timeval v12 = (__int128 *)(v16 - 40);
  }

  if (v12 != v13)
  {
    __int128 v22 = *v12;
    __int128 v23 = v12[1];
    *(void *)(a3 + 32) = *((void *)v12 + 4);
    *(_OWORD *)a3 = v22;
    *(_OWORD *)(a3 + 16) = v23;
    std::string::operator=((std::string *)(a3 + 40), (const std::string *)((char *)v12 + 40));
    std::string::operator=((std::string *)(a3 + 64), (const std::string *)(v12 + 4));
    std::string::operator=(a2, &__str);
    uint64_t v9 = 0LL;
    return v9;
  }

uint64_t RNBRemote::GetPacketPayload(uint64_t a1, std::string *a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 552);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 552));
  if (!*(void *)(a1 + 736))
  {
    PThreadEvent::ResetEvents((pthread_mutex_t *)(a1 + 120), 32);
    pthread_mutex_unlock(v4);
    return 1LL;
  }

  unint64_t v5 = *(void *)(*(void *)(a1 + 704) + 8 * (*(void *)(a1 + 728) / 0xAAuLL))
     + 24 * (*(void *)(a1 + 728) % 0xAAuLL);
  std::string::size_type cap = a2->__r_.__value_.__l.__cap_;
  __int128 v7 = *(_OWORD *)&a2->__r_.__value_.__l.__data_;
  std::string::size_type v8 = *(void *)(v5 + 16);
  *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)v5;
  a2->__r_.__value_.__l.__cap_ = v8;
  *(_OWORD *)unint64_t v5 = v7;
  *(void *)(v5 + 16) = cap;
  unint64_t v9 = *(void *)(a1 + 728);
  unint64_t v10 = *(void *)(*(void *)(a1 + 704) + 8 * (v9 / 0xAA)) + 24 * (v9 % 0xAA);
  if (*(char *)(v10 + 23) < 0)
  {
    operator delete(*(void **)v10);
    unint64_t v9 = *(void *)(a1 + 728);
  }

  --*(void *)(a1 + 736);
  unint64_t v11 = v9 + 1;
  *(void *)(a1 + 728) = v11;
  if (v11 >= 0x154)
  {
    operator delete(**(void ***)(a1 + 704));
    *(void *)(a1 + 704) += 8LL;
    *(void *)(a1 + 728) -= 170LL;
  }

  pthread_mutex_unlock(v4);
  if (!*(void *)(a1 + 736)) {
    PThreadEvent::ResetEvents((pthread_mutex_t *)(a1 + 120), 32);
  }
  uint64_t v12 = 0LL;
  int size = (char)a2->__r_.__value_.__s.__size_;
  size_t v14 = (std::string *)a2->__r_.__value_.__r.__words[0];
  if (size >= 0) {
    std::string::size_type v15 = a2;
  }
  else {
    std::string::size_type v15 = (std::string *)a2->__r_.__value_.__r.__words[0];
  }
  int v16 = v15->__r_.__value_.__s.__data_[0];
  if (v16 > 42)
  {
    if (v16 == 43 || v16 == 45) {
      return v12;
    }
LABEL_20:
    if (DNBLogEnabledForAny(0x100000))
    {
      size_t v18 = *(pthread_mutex_t **)(a1 + 488);
      if (v18) {
        pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 488));
      }
      gettimeofday(&v70, 0LL);
      int tv_sec = v70.tv_sec;
      __darwin_suseconds_t tv_usec = v70.tv_usec;
      uint64_t v21 = *(void *)(a1 + 496);
      int v22 = *(_DWORD *)(a1 + 504);
      *(timeval *)(a1 + 496) = v70;
      if (v18) {
        pthread_mutex_unlock(v18);
      }
      if ((a2->__r_.__value_.__s.__size_ & 0x80u) == 0) {
        __int128 v23 = (const char *)a2;
      }
      else {
        __int128 v23 = (const char *)a2->__r_.__value_.__r.__words[0];
      }
      _DNBLogThreaded( "%8u RNBRemote::%s tossing unexpected packet???? %s",  tv_usec - v22 + 1000000 * (tv_sec - v21),  "GetPacketPayload",  v23);
    }

    if (!*(_BYTE *)(a1 + 781))
    {
LABEL_30:
      uint64_t v12 = 1LL;
      RNBSocket::Write((RNBSocket *)(a1 + 472), "-", 1uLL);
      return v12;
    }

    return 1LL;
  }

  if (v16 == 3) {
    return v12;
  }
  if (v16 != 36) {
    goto LABEL_20;
  }
  if (*(_BYTE *)(a1 + 781))
  {
    uint64_t v17 = 0LL;
    goto LABEL_47;
  }

  unint64_t v24 = a2->__r_.__value_.__s.__size_;
  if (size < 0) {
    unint64_t v24 = a2->__r_.__value_.__l.__size_;
  }
  unint64_t v25 = v24 - 2;
  if (v24 < 2)
  {
LABEL_44:
    if (size >= 0) {
      size_t v14 = a2;
    }
    uint64_t v17 = strtol((const char *)v14 + v25, 0LL, 16);
LABEL_47:
    std::string::erase(a2, 0LL, 1uLL);
    std::string::size_type v30 = a2->__r_.__value_.__s.__size_;
    if ((v30 & 0x80u) != 0LL) {
      std::string::size_type v30 = a2->__r_.__value_.__l.__size_;
    }
    std::string::erase(a2, v30 - 3, 0xFFFFFFFFFFFFFFFFLL);
    if (*(_BYTE *)(a1 + 781)) {
      return 0LL;
    }
    int v31 = (char)a2->__r_.__value_.__s.__size_;
    BOOL v32 = v31 < 0;
    size_t v33 = (std::string *)a2->__r_.__value_.__r.__words[0];
    if (v31 >= 0) {
      size_t v33 = a2;
    }
    unint64_t v34 = a2->__r_.__value_.__s.__size_;
    if (v32) {
      unint64_t v34 = a2->__r_.__value_.__l.__size_;
    }
    if (!v34)
    {
      unsigned int v35 = 0;
LABEL_80:
      if (v17 == v35)
      {
        RNBSocket::Write((RNBSocket *)(a1 + 472), "+", 1uLL);
        return 0LL;
      }

      if (DNBLogEnabledForAny(0x20000))
      {
        int v68 = DNBTimer::ElapsedMicroSeconds((pthread_mutex_t **)(a1 + 488), 1);
        if ((a2->__r_.__value_.__s.__size_ & 0x80u) == 0) {
          std::string::size_type v69 = (const char *)a2;
        }
        else {
          std::string::size_type v69 = (const char *)a2->__r_.__value_.__r.__words[0];
        }
        _DNBLogThreaded( "%8u RNBRemote::%s sending ACK for '%s' (error: packet checksum mismatch  (0x%2.2lx != 0x%2.2x))",  v68,  "GetPacketPayload",  v69,  v17,  v35);
      }

      goto LABEL_30;
    }

    if (v34 < 8)
    {
      unsigned int v35 = 0;
      __darwin_suseconds_t v36 = (char *)v33;
      goto LABEL_78;
    }

    if (v34 >= 0x20)
    {
      int32x4_t v44 = 0uLL;
      unint64_t v43 = v34 & 0xFFFFFFFFFFFFFFE0LL;
      int32x4_t v45 = 0uLL;
      unsigned int v46 = (int8x8_t *)&v33->__r_.__value_.__r.__words[2];
      unint64_t v47 = v34 & 0xFFFFFFFFFFFFFFE0LL;
      int32x4_t v48 = 0uLL;
      int32x4_t v49 = 0uLL;
      int32x4_t v50 = 0uLL;
      int32x4_t v51 = 0uLL;
      int32x4_t v52 = 0uLL;
      int32x4_t v53 = 0uLL;
      do
      {
        int8x16_t v54 = *(int8x16_t *)v46[-2].i8;
        int16x8_t v55 = vmovl_s8(*(int8x8_t *)v54.i8);
        int16x8_t v56 = vmovl_high_s8(v54);
        int16x8_t v57 = vmovl_s8(*v46);
        int16x8_t v58 = vmovl_high_s8(*(int8x16_t *)v46->i8);
        int32x4_t v49 = vaddw_high_s16(v49, v56);
        int32x4_t v48 = vaddw_s16(v48, *(int16x4_t *)v56.i8);
        int32x4_t v45 = vaddw_high_s16(v45, v55);
        int32x4_t v44 = vaddw_s16(v44, *(int16x4_t *)v55.i8);
        int32x4_t v53 = vaddw_high_s16(v53, v58);
        int32x4_t v52 = vaddw_s16(v52, *(int16x4_t *)v58.i8);
        int32x4_t v51 = vaddw_high_s16(v51, v57);
        int32x4_t v50 = vaddw_s16(v50, *(int16x4_t *)v57.i8);
        v46 += 4;
        v47 -= 32LL;
      }

      while (v47);
      unsigned int v35 = vaddvq_s32( vaddq_s32( vaddq_s32(vaddq_s32(v50, v44), vaddq_s32(v52, v48)),  vaddq_s32(vaddq_s32(v51, v45), vaddq_s32(v53, v49))));
      if (v34 == v43) {
        goto LABEL_80;
      }
      if ((v34 & 0x18) == 0)
      {
        __darwin_suseconds_t v36 = (char *)v33 + v43;
LABEL_78:
        std::string::size_type v65 = (char *)v33 + v34;
        do
        {
          int v66 = *v36++;
          v35 += v66;
        }

        while (v36 != v65);
        goto LABEL_80;
      }
    }

    else
    {
      unsigned int v35 = 0;
      unint64_t v43 = 0LL;
    }

    __darwin_suseconds_t v36 = (char *)v33 + (v34 & 0xFFFFFFFFFFFFFFF8LL);
    int32x4_t v59 = 0uLL;
    int32x4_t v60 = (int32x4_t)v35;
    uint64_t v61 = (int8x8_t *)((char *)v33 + v43);
    unint64_t v62 = v43 - (v34 & 0xFFFFFFFFFFFFFFF8LL);
    do
    {
      int8x8_t v63 = *v61++;
      int16x8_t v64 = vmovl_s8(v63);
      int32x4_t v59 = vaddw_high_s16(v59, v64);
      int32x4_t v60 = vaddw_s16(v60, *(int16x4_t *)v64.i8);
      v62 += 8LL;
    }

    while (v62);
    unsigned int v35 = vaddvq_s32(vaddq_s32(v60, v59));
    if (v34 == (v34 & 0xFFFFFFFFFFFFFFF8LL)) {
      goto LABEL_80;
    }
    goto LABEL_78;
  }

  unsigned int v26 = size >> 31;
  while (1)
  {
    int v27 = (v26 & 1) != 0 ? (std::string *)a2->__r_.__value_.__r.__words[0] : a2;
    unsigned __int8 v28 = __tolower(v27->__r_.__value_.__s.__data_[v25]);
    if ((v28 & 0x80) != 0 || (_DefaultRuneLocale.__runetype[v28] & 0x10000) == 0) {
      break;
    }
    ++v25;
    int size = (char)a2->__r_.__value_.__s.__size_;
    unsigned int v26 = size >> 31;
    std::string::size_type v29 = a2->__r_.__value_.__l.__size_;
    if (size >= 0) {
      std::string::size_type v29 = a2->__r_.__value_.__s.__size_;
    }
    if (v25 >= v29)
    {
      size_t v14 = (std::string *)a2->__r_.__value_.__r.__words[0];
      unint64_t v25 = v29 - 2;
      goto LABEL_44;
    }
  }

  uint64_t v12 = 1LL;
  RNBSocket::Write((RNBSocket *)(a1 + 472), "-", 1uLL);
  if (DNBLogEnabledForAny(0x100000))
  {
    uint64_t v37 = *(pthread_mutex_t **)(a1 + 488);
    if (v37) {
      pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 488));
    }
    gettimeofday(&v70, 0LL);
    int v38 = v70.tv_sec;
    __darwin_suseconds_t v39 = v70.tv_usec;
    uint64_t v40 = *(void *)(a1 + 496);
    int v41 = *(_DWORD *)(a1 + 504);
    *(timeval *)(a1 + 496) = v70;
    if (v37) {
      pthread_mutex_unlock(v37);
    }
    if ((a2->__r_.__value_.__s.__size_ & 0x80u) == 0) {
      unint64_t v42 = (const char *)a2;
    }
    else {
      unint64_t v42 = (const char *)a2->__r_.__value_.__r.__words[0];
    }
    _DNBLogThreaded( "%8u RNBRemote::%s error: packet with invalid checksum characters: %s",  v39 - v41 + 1000000 * (v38 - v40),  "GetPacketPayload",  v42);
    return 1LL;
  }

  return v12;
}

uint64_t RNBRemote::HandlePacket_UNIMPLEMENTED(RNBRemote *this, const char *a2)
{
  if (DNBLogEnabledForAny(0x40000))
  {
    uint64_t v4 = (pthread_mutex_t *)*((void *)this + 61);
    if (v4) {
      pthread_mutex_lock(*((pthread_mutex_t **)this + 61));
    }
    gettimeofday((timeval *)&v12, 0LL);
    int data = (int)v12.__r_.__value_.__l.__data_;
    int v6 = v12.__r_.__value_.__r.__words[1];
    uint64_t v7 = *((void *)this + 62);
    int v8 = *((_DWORD *)this + 126);
    *((_OWORD *)this + 31) = *(_OWORD *)&v12.__r_.__value_.__l.__data_;
    if (v4) {
      pthread_mutex_unlock(v4);
    }
    unint64_t v9 = "NULL";
    if (a2) {
      unint64_t v9 = a2;
    }
    _DNBLogThreaded("%8u RNBRemote::%s(%s)", v6 - v8 + 1000000 * (data - v7), "HandlePacket_UNIMPLEMENTED", v9);
  }

  v12.__r_.__value_.__s.__size_ = 0;
  v12.__r_.__value_.__s.__data_[0] = 0;
  uint64_t v10 = RNBRemote::SendPacket((uint64_t)this, &v12);
  return v10;
}

uint64_t RNBRemote::HandlePacket_ILLFORMED( RNBRemote *this, const char *a2, int a3, const char *a4, const char *a5)
{
  if (DNBLogEnabledForAny(0x800000))
  {
    unint64_t v9 = (pthread_mutex_t *)*((void *)this + 61);
    if (v9) {
      pthread_mutex_lock(*((pthread_mutex_t **)this + 61));
    }
    gettimeofday((timeval *)&v16, 0LL);
    int data = (int)v16.__r_.__value_.__l.__data_;
    int v11 = v16.__r_.__value_.__r.__words[1];
    uint64_t v12 = *((void *)this + 62);
    int v13 = *((_DWORD *)this + 126);
    *((_OWORD *)this + 31) = *(_OWORD *)&v16.__r_.__value_.__l.__data_;
    if (v9) {
      pthread_mutex_unlock(v9);
    }
    _DNBLogThreaded( "%8u %s:%i ILLFORMED: '%s' (%s)",  v11 - v13 + 1000000 * (data - v12),  a2,  a3,  "HandlePacket_ILLFORMED",  a4);
  }

  v16.__r_.__value_.__s.__size_ = 3;
  LODWORD(v16.__r_.__value_.__l.__data_) = 3354693;
  uint64_t v14 = RNBRemote::SendPacket((uint64_t)this, &v16);
  return v14;
}

uint64_t RNBRemote::HandleAsyncPacket(uint64_t a1, _DWORD *a2)
{
  if (DNBLogEnabledForAny(0x100000))
  {
    uint64_t v4 = *(pthread_mutex_t **)(a1 + 488);
    if (v4) {
      pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 488));
    }
    gettimeofday((timeval *)v20, 0LL);
    int v5 = *(_DWORD *)v20;
    int v6 = *(_DWORD *)&v20[8];
    uint64_t v7 = *(void *)(a1 + 496);
    int v8 = *(_DWORD *)(a1 + 504);
    *(_OWORD *)(a1 + 496) = *(_OWORD *)v20;
    if (v4) {
      pthread_mutex_unlock(v4);
    }
    _DNBLogThreaded("%8u RNBRemote::%s", v6 - v8 + 1000000 * (v5 - v7), "HandleAsyncPacket");
  }

  if ((v9 & 1) == 0
  {
    DNBTimer::DNBTimer((DNBTimer *)&RNBRemote::HandleAsyncPacket(RNBRemote::PacketEnum *)::g_packetTimer, 1);
    __cxa_atexit( (void (*)(void *))DNBTimer::~DNBTimer,  &RNBRemote::HandleAsyncPacket(RNBRemote::PacketEnum *)::g_packetTimer,  (void *)&_mh_execute_header);
  }

  memset(&v25, 0, sizeof(v25));
  *(_DWORD *)BOOL v20 = 0;
  *(_OWORD *)&v20[8] = 0u;
  __int128 v21 = 0u;
  *(_OWORD *)int v22 = 0u;
  *(_OWORD *)std::string __p = 0u;
  __int128 v24 = 0u;
  uint64_t Packet = RNBRemote::GetPacket(a1, &v25, (uint64_t)v20, 0);
  if (!(_DWORD)Packet)
  {
    if ((char)v25.__r_.__value_.__s.__size_ < 0)
    {
      if (!v25.__r_.__value_.__l.__size_) {
        goto LABEL_23;
      }
      __darwin_ct_rune_t v12 = *v25.__r_.__value_.__l.__data_;
      if ((v12 & 0x80000000) == 0)
      {
LABEL_16:
        if ((_DefaultRuneLocale.__runetype[v12] & 0x40000) == 0)
        {
LABEL_23:
          if (DNBLogEnabledForAny(9437184)) {
            _DNBLogThreaded("HandleAsyncPacket (%s);");
          }
          goto LABEL_25;
        }

void DNBTimer::~DNBTimer(pthread_mutex_t **this)
{
  int v1 = *this;
  *this = 0LL;
  if (v1)
  {
    if (pthread_mutex_destroy(v1))
    {
      if (!pthread_mutex_unlock(v1)) {
        pthread_mutex_destroy(v1);
      }
    }

    operator delete(v1);
  }

uint64_t RNBRemote::HandleReceivedPacket(uint64_t a1, _DWORD *a2)
{
  if ((v4 & 1) == 0
  {
    DNBTimer::DNBTimer((DNBTimer *)&RNBRemote::HandleReceivedPacket(RNBRemote::PacketEnum *)::g_packetTimer, 1);
    __cxa_atexit( (void (*)(void *))DNBTimer::~DNBTimer,  &RNBRemote::HandleReceivedPacket(RNBRemote::PacketEnum *)::g_packetTimer,  (void *)&_mh_execute_header);
  }

  memset(&v21, 0, sizeof(v21));
  int v15 = 0;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  *(_OWORD *)size_t v18 = 0u;
  *(_OWORD *)std::string __p = 0u;
  __int128 v20 = 0u;
  if (RNBRemote::GetPacket(a1, &v21, (uint64_t)&v15, 0))
  {
    uint64_t v5 = 1LL;
    if ((SHIBYTE(v20) & 0x80000000) == 0) {
      goto LABEL_28;
    }
    goto LABEL_27;
  }

  if (DNBLogEnabledForAny(0x100000))
  {
    int v6 = &v21;
    if ((v21.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      int v6 = (std::string *)v21.__r_.__value_.__r.__words[0];
    }
    _DNBLogThreaded("HandleReceivedPacket (%s);", (const char *)v6);
  }

  uint64_t v8 = *((void *)&v16 + 1);
  uint64_t v7 = (uint64_t (*)(void *, std::string *))v16;
  uint64_t v9 = BYTE8(v16) & 1;
  if (*((void *)&v16 + 1)) {
    BOOL v10 = (BYTE8(v16) & 1 | (unint64_t)v16) == 0;
  }
  else {
    BOOL v10 = 1;
  }
  int v11 = !v10;
  if (!(void)v16 && !v11)
  {
    uint64_t v5 = 0LL;
    if ((SHIBYTE(v20) & 0x80000000) == 0) {
      goto LABEL_28;
    }
    goto LABEL_27;
  }

  if (a2) {
    *a2 = v15;
  }
  __darwin_ct_rune_t v12 = (void *)(a1 + (v8 >> 1));
  if (v9) {
    uint64_t v7 = *(uint64_t (**)(void *, std::string *))(*v12 + v7);
  }
  if ((v21.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    int v13 = &v21;
  }
  else {
    int v13 = (std::string *)v21.__r_.__value_.__r.__words[0];
  }
  uint64_t v5 = v7(v12, v13);
  if (SHIBYTE(v20) < 0) {
LABEL_27:
  }
    operator delete(__p[1]);
LABEL_28:
  if (SHIBYTE(__p[0]) < 0)
  {
    operator delete(v18[0]);
LABEL_32:
    operator delete(v21.__r_.__value_.__l.__data_);
    return v5;
  }

  return v5;
}

pthread_mutex_t *RNBRemote::CommDataReceived(uint64_t a1, uint64_t a2)
{
  unsigned __int8 v4 = (pthread_mutex_t *)(a1 + 552);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 552));
  memset(&v53, 0, sizeof(v53));
  if (*(char *)(a1 + 767) < 0)
  {
    uint64_t v5 = (std::string *)(a1 + 744);
    if (!*(void *)(a1 + 752)) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }

  uint64_t v5 = (std::string *)(a1 + 744);
  if (*(_BYTE *)(a1 + 767))
  {
LABEL_3:
    std::string v53 = *v5;
    v5->__r_.__value_.__l.__size_ = 0LL;
    v5->__r_.__value_.__l.__cap_ = 0LL;
    v5->__r_.__value_.__r.__words[0] = 0LL;
  }

LABEL_4:
  int v6 = *(char *)(a2 + 23);
  if (v6 >= 0) {
    uint64_t v7 = (const std::string::value_type *)a2;
  }
  else {
    uint64_t v7 = *(const std::string::value_type **)a2;
  }
  if (v6 >= 0) {
    std::string::size_type v8 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    std::string::size_type v8 = *(void *)(a2 + 8);
  }
  std::string::append(&v53, v7, v8);
  unsigned __int8 size = v53.__r_.__value_.__s.__size_;
  if ((v53.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    unint64_t v10 = v53.__r_.__value_.__s.__size_;
  }
  else {
    unint64_t v10 = v53.__r_.__value_.__l.__size_;
  }
  if (!v10) {
    goto LABEL_96;
  }
  int32x4_t v48 = v5;
  int32x4_t v49 = v4;
  std::string::size_type v11 = 0LL;
  int32x4_t v50 = (timeval *)(a1 + 496);
  while (1)
  {
    if ((v53.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v14 = &v53;
    }
    else {
      uint64_t v14 = (std::string *)v53.__r_.__value_.__r.__words[0];
    }
    int v15 = v14->__r_.__value_.__s.__data_[v11];
    if (v15 > 42)
    {
      if (v15 != 45)
      {
        std::string::size_type v16 = v11;
        if (v15 != 43) {
          goto LABEL_34;
        }
      }

      goto LABEL_33;
    }

    if (v15 != 3) {
      break;
    }
LABEL_33:
    std::string::size_type v16 = v11 + 1;
    if (v11 == -2LL) {
      goto LABEL_74;
    }
LABEL_34:
    if (v16 <= v11)
    {
      if (DNBLogEnabledForAny(0x40000))
      {
        int v22 = *(pthread_mutex_t **)(a1 + 488);
        if (v22) {
          pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 488));
        }
        gettimeofday(&__dst, 0LL);
        int tv_sec = __dst.tv_sec;
        __darwin_suseconds_t tv_usec = __dst.tv_usec;
        uint64_t v25 = *(void *)(a1 + 496);
        int v26 = *(_DWORD *)(a1 + 504);
        *int32x4_t v50 = __dst;
        if (v22) {
          pthread_mutex_unlock(v22);
        }
        if ((v53.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          __darwin_ct_rune_t v12 = &v53;
        }
        else {
          __darwin_ct_rune_t v12 = (std::string *)v53.__r_.__value_.__r.__words[0];
        }
        _DNBLogThreaded( "%8d RNBRemote::%s tossing junk byte at %c",  tv_usec - v26 + 1000000 * (tv_sec - v25),  "CommDataReceived",  v12->__r_.__value_.__s.__data_[v11]);
      }

      std::string::size_type v13 = v11 + 1;
      goto LABEL_20;
    }

    int v18 = *(_DWORD *)(a1 + 668);
    *(_DWORD *)(a1 + 668) = v18 + 1;
    std::string::size_type v13 = v11 + 1;
    std::string::size_type v19 = v53.__r_.__value_.__s.__size_;
    if (v16 != v11 + 1
      || v18
      || ((v53.__r_.__value_.__s.__size_ & 0x80u) == 0
        ? (__int128 v20 = &v53)
        : (__int128 v20 = (std::string *)v53.__r_.__value_.__r.__words[0]),
          v20->__r_.__value_.__s.__data_[v11] != 43))
    {
      if ((v53.__r_.__value_.__s.__size_ & 0x80) != 0)
      {
        std::string::size_type v19 = v53.__r_.__value_.__l.__size_;
        if (v53.__r_.__value_.__l.__size_ < v11) {
          goto LABEL_101;
        }
        std::string v21 = (std::string *)v53.__r_.__value_.__r.__words[0];
      }

      else
      {
        if (v11 > v53.__r_.__value_.__s.__size_) {
          goto LABEL_101;
        }
        std::string v21 = &v53;
      }

      size_t v27 = v19 - v11;
      if (v27 >= v16 - v11) {
        size_t v28 = v16 - v11;
      }
      else {
        size_t v28 = v27;
      }
      if (v28 > 0x7FFFFFFFFFFFFFF7LL) {
        goto LABEL_101;
      }
      if (v28 >= 0x17)
      {
        uint64_t v30 = (v28 & 0xFFFFFFFFFFFFFFF8LL) + 8;
        if ((v28 | 7) != 0x17) {
          uint64_t v30 = v28 | 7;
        }
        uint64_t v31 = v30 + 1;
        p_dst = operator new(v30 + 1);
        *(void *)&__dst.__darwin_suseconds_t tv_usec = v28;
        int64_t v52 = v31 | 0x8000000000000000LL;
        __dst.int tv_sec = (__darwin_time_t)p_dst;
      }

      else
      {
        HIBYTE(v52) = v28;
        p_dst = &__dst;
        if (!v28) {
          goto LABEL_62;
        }
      }

      memmove(p_dst, (char *)v21 + v11, v28);
LABEL_62:
      *((_BYTE *)p_dst + v28) = 0;
      uint64_t v32 = *(void *)(a1 + 704);
      if (*(void *)(a1 + 712) == v32) {
        uint64_t v33 = 0LL;
      }
      else {
        uint64_t v33 = 170 * ((*(void *)(a1 + 712) - v32) >> 3) - 1;
      }
      unint64_t v34 = *(void *)(a1 + 736) + *(void *)(a1 + 728);
      if (v33 == v34)
      {
        std::deque<std::string>::__add_back_capacity(a1 + 696);
        uint64_t v32 = *(void *)(a1 + 704);
        unint64_t v34 = *(void *)(a1 + 736) + *(void *)(a1 + 728);
      }

      unsigned int v35 = (timeval *)(*(void *)(v32 + 8 * (v34 / 0xAA)) + 24 * (v34 % 0xAA));
      *unsigned int v35 = __dst;
      v35[1].int tv_sec = v52;
      ++*(void *)(a1 + 736);
      if (DNBLogEnabledForAny(0x800000))
      {
        unint64_t v36 = *(void *)(a1 + 736) + *(void *)(a1 + 728) - 1LL;
        unint64_t v37 = *(void *)(*(void *)(a1 + 704) + 8 * (v36 / 0xAA)) + 24 * (v36 % 0xAA);
        _DNBLogThreaded("getpkt: %s", (const char *)v37);
      }

      std::string::size_type v13 = v16;
    }

  if ((v6 & 0x10) != 0)
  {
    *(void *)(a1 + 88) = (char *)v4 + v5;
    uint64_t v7 = v3 < 0 ? (*(void *)(a1 + 80) & 0x7FFFFFFFFFFFFFFFLL) - 1 : 22LL;
    std::string::resize(v2, v7, 0);
    std::string::size_type v8 = *(char *)(a1 + 87) < 0 ? *(void *)(a1 + 72) : *(unsigned __int8 *)(a1 + 87);
    *(void *)(a1 + 40) = v4;
    *(void *)(a1 + 48) = v4;
    *(void *)(a1 + 56) = (char *)v4 + v8;
    if ((*(_BYTE *)(a1 + 96) & 3) != 0)
    {
      if (v5 >> 31)
      {
        uint64_t v9 = ((v5 - 0x80000000) * (unsigned __int128)0x200000005uLL) >> 64;
        unint64_t v10 = 0x7FFFFFFF * ((v9 + ((v5 - 0x80000000 - v9) >> 1)) >> 30);
        unsigned __int8 v4 = (std::string *)((char *)v4 + v10 + 0x7FFFFFFF);
        uint64_t v5 = v5 - v10 - 0x7FFFFFFF;
        *(void *)(a1 + 48) = v4;
      }

      if (v5) {
        *(void *)(a1 + 48) = (char *)v4 + v5;
      }
    }
  }

      uint64_t v7 = v8++;
      if (v4 <= v7) {
        goto LABEL_29;
      }
    }

    Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    valuePtr = v10;
    uint64_t v14 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
    CFDictionarySetValue(Mutable, @"pid", v14);
    CFDictionarySetValue(Mutable, @"isFrontApp", kCFBooleanFalse);
    if (proc_pidpath(v10, buffer, 0x400u) < 1)
    {
      std::string::size_type v16 = v9 + 243;
      if (!v9[243]) {
        goto LABEL_23;
      }
    }

    else
    {
      int v15 = strrchr(buffer, 47);
      if (v15) {
        std::string::size_type v16 = v15 + 1;
      }
      else {
        std::string::size_type v16 = buffer;
      }
      CFString::CFString((CFString *)v19, buffer, 0x8000100u);
      if (v20) {
        CFDictionarySetValue(Mutable, @"executablePath", v20);
      }
      CFString::~CFString((CFString *)v19);
      if (!*v16) {
        goto LABEL_23;
      }
    }

    CFString::CFString((CFString *)v19, v16, 0x8000100u);
    CFDictionarySetValue(Mutable, @"displayName", v20);
    CFString::~CFString((CFString *)v19);
LABEL_23:
    CFArrayAppendValue(a1, Mutable);
    if (v14) {
      CFRelease(v14);
    }
    if (Mutable) {
      CFRelease(Mutable);
    }
    goto LABEL_4;
  }

  uint64_t result = &DNBArchMachARM64::g_reg_sets_with_amx;
  unsigned __int8 v4 = 5LL;
LABEL_7:
  *(void *)this = v4;
  return result;
}

LABEL_20:
    std::string::size_type v11 = v13;
    if (v13 >= v10) {
      goto LABEL_95;
    }
  }

  std::string::size_type v16 = v11;
  if (v15 != 36) {
    goto LABEL_34;
  }
  std::string::size_type v17 = std::string::find(&v53, 35, v11 + 1);
  if (v17 != -1LL)
  {
    std::string::size_type v16 = v17 + 3;
    if (v17 + 3 <= v10 && v17 != -4LL) {
      goto LABEL_34;
    }
  }

  JSONGenerator::Dictionary::AddItem(a1, (uint64_t)&v22, &v20);
  std::string::size_type v17 = v21;
  if (!v21) {
    goto LABEL_24;
  }
  int v18 = (unint64_t *)&v21->__shared_owners_;
  do
    std::string::size_type v19 = __ldaxr(v18);
  while (__stlxr(v19 - 1, v18));
  if (v19)
  {
LABEL_24:
    goto LABEL_25;
  }

  ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
  std::__shared_weak_count::__release_weak(v17);
  if ((char)v22.__r_.__value_.__s.__size_ < 0) {
LABEL_25:
  }
    operator delete(v22.__r_.__value_.__l.__data_);
}

  *a1 = v17;
  a1[1] = v18;
  a1[2] = v4;
  a1[3] = &v17[v16];
  if (v5)
  {
    operator delete(v5);
    unsigned __int8 v4 = a1[2];
  }

  if ((char)v14.__r_.__value_.__s.__size_ < 0) {
LABEL_17:
  }
    operator delete(v14.__r_.__value_.__l.__data_);
}

uint64_t RNBRemote::StartReadRemoteDataThread(RNBRemote *this)
{
  if (DNBLogEnabledForAny(0x100000))
  {
    uint64_t v2 = (pthread_mutex_t *)*((void *)this + 61);
    if (v2) {
      pthread_mutex_lock(*((pthread_mutex_t **)this + 61));
    }
    gettimeofday(&v8, 0LL);
    int tv_sec = v8.tv_sec;
    __darwin_suseconds_t tv_usec = v8.tv_usec;
    uint64_t v5 = *((void *)this + 62);
    int v6 = *((_DWORD *)this + 126);
    *((timeval *)this + 31) = v8;
    if (v2) {
      pthread_mutex_unlock(v2);
    }
    _DNBLogThreaded("%8u RNBRemote::%s called", tv_usec - v6 + 1000000 * (tv_sec - v5), "StartReadRemoteDataThread");
  }

  uint64_t result = PThreadEvent::GetEventBits((pthread_mutex_t *)((char *)this + 120));
  if ((result & 0x40) == 0)
  {
    PThreadEvent::ResetEvents((pthread_mutex_t *)((char *)this + 120), 128);
    if (pthread_create( (pthread_t *)this + 96,  0LL,  (void *(__cdecl *)(void *))RNBRemote::ThreadFunctionReadRemoteData,  this))
    {
      PThreadEvent::ResetEvents((pthread_mutex_t *)((char *)this + 120), 64);
      return (uint64_t)PThreadEvent::SetEvents((pthread_mutex_t *)((char *)this + 120), 128);
    }

    else
    {
      return PThreadEvent::WaitForSetEvents((pthread_mutex_t *)((char *)this + 120), 0x40u, 0LL);
    }
  }

  return result;
}

uint64_t RNBRemote::ThreadFunctionReadRemoteData(RNBRemote *this, void *a2)
{
  if (DNBLogEnabledForAny(0x100000)) {
    _DNBLogThreaded("RNBRemote::%s (%p): thread starting...", "ThreadFunctionReadRemoteData", this);
  }
  uint64_t v4 = g_remoteSP;
  uint64_t v3 = (std::__shared_weak_count *)qword_1000716A0;
  if (qword_1000716A0)
  {
    uint64_t v5 = (unint64_t *)(qword_1000716A0 + 8);
    do
      unint64_t v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }

  if (v4)
  {
    pthread_setname_np("read gdb-remote packets thread");
    int v15 = 0;
    uint64_t v7 = pthread_self();
    if (!pthread_getschedparam(v7, &v15, &v16))
    {
      v16.sched_priority = 47;
      timeval v8 = pthread_self();
      pthread_setschedparam(v8, v15, &v16);
    }

    PThreadEvent::SetEvents((pthread_mutex_t *)(v4 + 120), 64);
    while (1)
    {
      memset(&__p, 0, sizeof(__p));
      int v9 = RNBSocket::Read((int *)(v4 + 472), &__p);
      std::string::size_type size = __p.__r_.__value_.__s.__size_;
      unsigned __int8 v11 = __p.__r_.__value_.__s.__size_;
      if (!v9)
      {
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          std::string::size_type size = __p.__r_.__value_.__l.__size_;
        }
        if (size)
        {
          RNBRemote::CommDataReceived(v4, (uint64_t)&__p);
          unsigned __int8 v11 = __p.__r_.__value_.__s.__size_;
        }
      }

      if ((v11 & 0x80) != 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (v9 == 2) {
        break;
      }
      if (v9 == 1)
      {
        if (DNBLogEnabledForAny(0x100000)) {
          _DNBLogThreaded("RNBSocket::GetCommData returned error %u");
        }
        goto LABEL_23;
      }
    }

    if (DNBLogEnabledForAny(0x100000)) {
      _DNBLogThreaded("RNBSocket::GetCommData returned not connected...");
    }
LABEL_23:
    PThreadEvent::ResetEvents((pthread_mutex_t *)(v4 + 120), 64);
    PThreadEvent::SetEvents((pthread_mutex_t *)(v4 + 120), 128);
  }

  if (DNBLogEnabledForAny(0x100000)) {
    _DNBLogThreaded("RNBRemote::%s (%p): thread exiting...", "ThreadFunctionReadRemoteData", this);
  }
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

  return 0LL;
}

void decode_binary_data(const char *__s@<X0>, size_t a2@<X1>, unint64_t *a3@<X8>)
{
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  if (a2)
  {
    size_t v3 = a2;
    uint64_t v4 = __s;
    if (a2 != -1LL || (size_t v3 = strlen(__s)) != 0)
    {
      unint64_t v6 = 0LL;
      while (1)
      {
        timeval v8 = v4;
        size_t v9 = v3;
        int v11 = *(unsigned __int8 *)v4++;
        int v10 = v11;
        if (--v3 && v10 == 125)
        {
          size_t v3 = v9 - 2;
          uint64_t v4 = v8 + 2;
          LOBYTE(v10) = v8[1] ^ 0x20;
        }

        unint64_t v12 = a3[2];
        *unint64_t v6 = v10;
        uint64_t v7 = (uint64_t)(v6 + 1);
LABEL_6:
        a3[1] = v7;
        unint64_t v6 = (_BYTE *)v7;
        if (!v3) {
          return;
        }
      }

      unint64_t v13 = *a3;
      unint64_t v14 = (unint64_t)&v6[-*a3];
      unint64_t v15 = v14 + 1;
      unint64_t v16 = v12 - v13;
      if (2 * v16 > v15) {
        unint64_t v15 = 2 * v16;
      }
      if (v16 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v17 = v15;
      }
      if (v17) {
        int v18 = operator new(v17);
      }
      else {
        int v18 = 0LL;
      }
      std::string::size_type v19 = (char *)v18 + v14;
      *((_BYTE *)v18 + v14) = v10;
      uint64_t v7 = (uint64_t)v18 + v14 + 1;
      if (v6 == (_BYTE *)v13)
      {
LABEL_29:
        *a3 = (unint64_t)v19;
        a3[1] = v7;
        a3[2] = (unint64_t)v18 + v17;
        if (v6) {
          operator delete(v6);
        }
        goto LABEL_6;
      }

      if (v14 < 8
        || (char *)v18 + v14 - 1 - &v6[~v13] > (unint64_t)v18 + v14 - 1
        || v13 > (unint64_t)(v6 - 1)
        || v13 - (unint64_t)v18 < 0x20)
      {
        __int128 v20 = v6;
        goto LABEL_26;
      }

      if (v14 >= 0x20)
      {
        unint64_t v23 = v14 & 0xFFFFFFFFFFFFFFE0LL;
        __int128 v24 = (char *)v18 + v14 - 16;
        uint64_t v25 = (__int128 *)(v6 - 16);
        unint64_t v26 = v14 & 0xFFFFFFFFFFFFFFE0LL;
        do
        {
          __int128 v27 = *v25;
          *(v24 - 1) = *(v25 - 1);
          _OWORD *v24 = v27;
          v24 -= 2;
          v25 -= 2;
          v26 -= 32LL;
        }

        while (v26);
        if (v14 == v23) {
          goto LABEL_28;
        }
        if ((v14 & 0x18) == 0)
        {
          v19 -= v23;
          __int128 v20 = &v6[-v23];
LABEL_26:
          std::string v21 = v19 - 1;
          do
          {
            char v22 = *--v20;
            *v21-- = v22;
          }

          while (v20 != (_BYTE *)v13);
LABEL_28:
          unint64_t v6 = (_BYTE *)*a3;
          std::string::size_type v19 = (char *)v18;
          goto LABEL_29;
        }
      }

      else
      {
        unint64_t v23 = 0LL;
      }

      __int128 v20 = &v6[-(v14 & 0xFFFFFFFFFFFFFFF8LL)];
      v19 -= v14 & 0xFFFFFFFFFFFFFFF8LL;
      size_t v28 = &v6[-v23 - v13 - 8 + (void)v18];
      std::string::size_type v29 = (uint64_t *)&v6[-v23 - 8];
      unint64_t v30 = v23 - (v14 & 0xFFFFFFFFFFFFFFF8LL);
      do
      {
        uint64_t v31 = *v29--;
        *v28-- = v31;
        v30 += 8LL;
      }

      while (v30);
      if (v14 == (v14 & 0xFFFFFFFFFFFFFFF8LL)) {
        goto LABEL_28;
      }
      goto LABEL_26;
    }
  }

void std::vector<unsigned char>::push_back[abi:nn180100](void *a1, char *a2)
{
  uint64_t v5 = (char *)a1[1];
  unint64_t v4 = a1[2];
  unint64_t v6 = v5;
  if ((unint64_t)v5 < v4)
  {
    *uint64_t v5 = *a2;
    uint64_t v7 = (uint64_t)(v5 + 1);
    goto LABEL_32;
  }

  timeval v8 = (char *)*a1;
  unint64_t v9 = (unint64_t)&v5[-*a1];
  unint64_t v10 = v9 + 1;
  unint64_t v11 = v4 - (void)v8;
  if (2 * v11 > v10) {
    unint64_t v10 = 2 * v11;
  }
  if (v11 >= 0x3FFFFFFFFFFFFFFFLL) {
    size_t v12 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    size_t v12 = v10;
  }
  if (v12) {
    unint64_t v13 = operator new(v12);
  }
  else {
    unint64_t v13 = 0LL;
  }
  unint64_t v14 = &v13[v9];
  unint64_t v15 = &v13[v12];
  v13[v9] = *a2;
  uint64_t v7 = (uint64_t)&v13[v9 + 1];
  if (v5 == v8)
  {
    v13 += v9;
    goto LABEL_30;
  }

  if (v9 >= 8 && (unint64_t)(v8 - v13) >= 0x20)
  {
    if (v9 < 0x20)
    {
      unint64_t v16 = 0LL;
      goto LABEL_22;
    }

    unint64_t v16 = v9 & 0xFFFFFFFFFFFFFFE0LL;
    size_t v17 = (__int128 *)(v5 - 16);
    int v18 = &v13[v5 - 16 - v8];
    unint64_t v19 = v9 & 0xFFFFFFFFFFFFFFE0LL;
    do
    {
      __int128 v20 = *v17;
      *(v18 - 1) = *(v17 - 1);
      _OWORD *v18 = v20;
      v18 -= 2;
      v17 -= 2;
      v19 -= 32LL;
    }

    while (v19);
    if (v9 == v16) {
      goto LABEL_29;
    }
    if ((v9 & 0x18) != 0)
    {
LABEL_22:
      unint64_t v6 = &v5[-(v9 & 0xFFFFFFFFFFFFFFF8LL)];
      v14 -= v9 & 0xFFFFFFFFFFFFFFF8LL;
      std::string v21 = &v5[-v16 - 8];
      char v22 = &v13[v21 - v8];
      unint64_t v23 = v16 - (v9 & 0xFFFFFFFFFFFFFFF8LL);
      do
      {
        uint64_t v24 = *(void *)v21;
        v21 -= 8;
        *v22-- = v24;
        v23 += 8LL;
      }

      while (v23);
      if (v9 == (v9 & 0xFFFFFFFFFFFFFFF8LL)) {
        goto LABEL_29;
      }
      goto LABEL_27;
    }

    v14 -= v16;
    unint64_t v6 = &v5[-v16];
  }

void json_string_quote_metachars(const std::string *a1@<X0>, std::string *a2@<X8>)
{
  uint64_t v2 = (const std::string::value_type *)a1;
  if (std::string::find(a1, 34, 0LL) == -1LL)
  {
    if (v2[23] < 0)
    {
      std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)v2, *((void *)v2 + 1));
    }

    else
    {
      *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)v2;
      a2->__r_.__value_.__l.__cap_ = *((void *)v2 + 2);
    }
  }

  else
  {
    a2->__r_.__value_.__r.__words[0] = 0LL;
    a2->__r_.__value_.__l.__size_ = 0LL;
    a2->__r_.__value_.__l.__cap_ = 0LL;
    int v4 = v2[23];
    if (v4 >= 0) {
      uint64_t v5 = *((unsigned __int8 *)v2 + 23);
    }
    else {
      uint64_t v5 = *((void *)v2 + 1);
    }
    if (v4 < 0) {
      uint64_t v2 = *(const std::string::value_type **)v2;
    }
    for (; v5; --v5)
    {
      int v7 = *(unsigned __int8 *)v2++;
      std::string::value_type v6 = v7;
      if (v7 == 34) {
        std::string::push_back(a2, 92);
      }
      std::string::push_back(a2, v6);
    }
  }

void **std::vector<register_map_entry>::~vector[abi:nn180100](void **a1)
{
  uint64_t v2 = (char *)*a1;
  if (*a1)
  {
    size_t v3 = (char *)a1[1];
    int v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = (void *)*((void *)v3 - 3);
        if (v5)
        {
          *((void *)v3 - 2) = v5;
          operator delete(v5);
        }

        std::string::value_type v6 = (void *)*((void *)v3 - 6);
        if (v6)
        {
          *((void *)v3 - 5) = v6;
          operator delete(v6);
        }

        v3 -= 128;
      }

      while (v3 != v2);
      int v4 = *a1;
    }

    a1[1] = v2;
    operator delete(v4);
  }

  return a1;
}

BOOL RNBRemote::InitializeRegisters(RNBRemote *this, int a2)
{
  int v2 = *((_DWORD *)this + 3);
  if (v2)
  {
    int v106 = *((_DWORD *)this + 3);
    if (DNBLogEnabledForAny(0x400000)) {
      _DNBLogThreaded("RNBRemote::%s() getting native registers from DNB interface", "InitializeRegisters");
    }
    uint64_t v4 = g_dynamic_register_map;
    uint64_t v5 = qword_100071828;
    if (a2)
    {
      uint64_t v6 = g_dynamic_register_map;
      if (qword_100071828 != g_dynamic_register_map)
      {
        do
        {
          int v7 = *(void **)(v5 - 24);
          if (v7)
          {
            *(void *)(v5 - 16) = v7;
            operator delete(v7);
          }

          timeval v8 = *(void **)(v5 - 48);
          if (v8)
          {
            *(void *)(v5 - 40) = v8;
            operator delete(v8);
          }

          v5 -= 128LL;
        }

        while (v5 != v4);
        uint64_t v6 = g_dynamic_register_map;
      }

      qword_100071828 = v4;
      g_reg_entries = 0LL;
      g_num_reg_entries = 0LL;
      uint64_t v5 = v4;
      uint64_t v4 = v6;
    }

    int v2 = v106;
    if (v4 == v5)
    {
      unint64_t v120 = 0LL;
      uint64_t v9 = DNBGetRegisterSetInfo(&v120);
      unint64_t v10 = v120;
      if (!v120 || !v9) {
        RNBRemote::InitializeRegisters();
      }
      int v11 = 0;
      unint64_t v12 = 0LL;
      int v110 = 0;
      v119[0] = 0LL;
      v119[1] = 0LL;
      __int128 v118 = v119;
      uint64_t v107 = v9;
      do
      {
        uint64_t v13 = v9 + 24 * v12;
        uint64_t v15 = *(void *)(v13 + 8);
        unint64_t v14 = (void *)(v13 + 8);
        if (v15)
        {
          unint64_t v109 = (unint64_t *)(v9 + 24 * v12 + 16);
          if (*v109)
          {
            unint64_t v108 = v12;
            unint64_t v16 = 0LL;
            unsigned int v17 = 1;
            while (1)
            {
              *(_DWORD *)uint64_t v114 = v110 + v17 - 1;
              *(_DWORD *)&v114[4] = v11;
              uint64_t v18 = *v14 + 72 * v16;
              *(_OWORD *)&v114[8] = *(_OWORD *)v18;
              __int128 v19 = *(_OWORD *)(v18 + 16);
              __int128 v20 = *(_OWORD *)(v18 + 32);
              __int128 v21 = *(_OWORD *)(v18 + 48);
              *(void *)&v114[72] = *(void *)(v18 + 64);
              *(_OWORD *)&v114[40] = v20;
              *(_OWORD *)&v114[56] = v21;
              *(_OWORD *)&v114[24] = v19;
              __int128 v115 = 0u;
              __int128 v116 = 0u;
              __int128 v117 = 0u;
              char v22 = *(const void **)&v114[16];
              size_t v23 = strlen(*(const char **)&v114[16]);
              if (v23 > 0x7FFFFFFFFFFFFFF7LL) {
LABEL_144:
              }
                abort();
              uint64_t v24 = (const void *)v23;
              if (v23 >= 0x17)
              {
                uint64_t v26 = (v23 & 0xFFFFFFFFFFFFFFF8LL) + 8;
                if ((v23 | 7) != 0x17) {
                  uint64_t v26 = v23 | 7;
                }
                uint64_t v27 = v26 + 1;
                uint64_t v25 = (const void **)operator new(v26 + 1);
                __dst[1] = v24;
                unint64_t v113 = v27 | 0x8000000000000000LL;
                __dst[0] = v25;
              }

              else
              {
                HIBYTE(v113) = v23;
                uint64_t v25 = __dst;
                if (!v23) {
                  goto LABEL_32;
                }
              }

              memmove(v25, v22, (size_t)v24);
LABEL_32:
              *((_BYTE *)v24 + (void)v25) = 0;
              uint64_t v121 = __dst;
              *((_DWORD *)std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>( (uint64_t **)&v118,  __dst,  (uint64_t)&std::piecewise_construct,  (_OWORD **)&v121)
              + 14) = v110 + v17 - 1;
              if (SHIBYTE(v113) < 0) {
                operator delete((void *)__dst[0]);
              }
              if (*(void *)&v114[64]) {
                int v28 = 0;
              }
              else {
                int v28 = *(_DWORD *)&v114[36];
              }
              uint64_t v29 = qword_100071828;
              if ((unint64_t)qword_100071828 >= unk_100071830)
              {
                uint64_t v41 = std::vector<register_map_entry>::__push_back_slow_path<register_map_entry const&>( &g_dynamic_register_map,  (uint64_t)v114);
              }

              else
              {
                *(_OWORD *)qword_100071828 = *(_OWORD *)v114;
                __int128 v30 = *(_OWORD *)&v114[16];
                __int128 v31 = *(_OWORD *)&v114[32];
                __int128 v32 = *(_OWORD *)&v114[64];
                *(_OWORD *)(v29 + 48) = *(_OWORD *)&v114[48];
                *(_OWORD *)(v29 + 64) = v32;
                *(_OWORD *)(v29 + 16) = v30;
                *(_OWORD *)(v29 + 32) = v31;
                *(void *)(v29 + 88) = 0LL;
                *(void *)(v29 + 96) = 0LL;
                *(void *)(v29 + 80) = 0LL;
                uint64_t v33 = (const void *)v115;
                int64_t v34 = *((void *)&v115 + 1) - v115;
                if (*((void *)&v115 + 1) != (void)v115)
                {
                  if (v34 < 0) {
                    goto LABEL_144;
                  }
                  unsigned int v35 = (char *)operator new(*((void *)&v115 + 1) - v115);
                  *(void *)(v29 + 80) = v35;
                  *(void *)(v29 + 88) = v35;
                  unint64_t v36 = &v35[4 * (v34 >> 2)];
                  *(void *)(v29 + 96) = v36;
                  memcpy(v35, v33, v34);
                  *(void *)(v29 + 88) = v36;
                }

                *(void *)(v29 + 104) = 0LL;
                *(void *)(v29 + 112) = 0LL;
                *(void *)(v29 + 120) = 0LL;
                unint64_t v37 = (const void *)*((void *)&v116 + 1);
                int64_t v38 = v117 - *((void *)&v116 + 1);
                if ((void)v117 != *((void *)&v116 + 1))
                {
                  if (v38 < 0) {
                    goto LABEL_144;
                  }
                  __darwin_suseconds_t v39 = (char *)operator new(v117 - *((void *)&v116 + 1));
                  *(void *)(v29 + 104) = v39;
                  *(void *)(v29 + 112) = v39;
                  uint64_t v40 = &v39[4 * (v38 >> 2)];
                  *(void *)(v29 + 120) = v40;
                  memcpy(v39, v37, v38);
                  *(void *)(v29 + 112) = v40;
                }

                uint64_t v41 = v29 + 128;
              }

              qword_100071828 = v41;
              if (*((void *)&v116 + 1))
              {
                *(void *)&__int128 v117 = *((void *)&v116 + 1);
                operator delete(*((void **)&v116 + 1));
              }

              if ((void)v115)
              {
                *((void *)&v115 + 1) = v115;
                operator delete((void *)v115);
              }

              v11 += v28;
              unint64_t v16 = v17++;
              if (*v109 <= v16)
              {
                unint64_t v10 = v120;
                int v110 = v110 + v17 - 1;
                uint64_t v9 = v107;
                unint64_t v12 = v108;
                break;
              }
            }
          }
        }

        ++v12;
      }

      while (v12 < v10);
      uint64_t v42 = g_dynamic_register_map;
      uint64_t v111 = qword_100071828;
      if (g_dynamic_register_map != qword_100071828)
      {
LABEL_53:
        uint64_t v43 = *(const char ***)(v42 + 64);
        if (!v43) {
          goto LABEL_100;
        }
        uint64_t v44 = *v43;
        if (!*v43) {
          goto LABEL_96;
        }
        uint64_t v45 = 0LL;
        unsigned int v46 = -1;
        while (2)
        {
          size_t v47 = strlen(v44);
          if (v47 > 0x7FFFFFFFFFFFFFF7LL) {
            goto LABEL_144;
          }
          size_t v48 = v47;
          if (v47 >= 0x17)
          {
            uint64_t v50 = (v47 & 0xFFFFFFFFFFFFFFF8LL) + 8;
            if ((v47 | 7) != 0x17) {
              uint64_t v50 = v47 | 7;
            }
            uint64_t v51 = v50 + 1;
            int32x4_t v49 = operator new(v50 + 1);
            *(void *)&v114[8] = v48;
            *(void *)&v114[16] = v51 | 0x8000000000000000LL;
            *(void *)uint64_t v114 = v49;
          }

          else
          {
            v114[23] = v47;
            int32x4_t v49 = v114;
            if (!v47)
            {
LABEL_65:
              v49[v48] = 0;
              int64_t v52 = (char **)std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::find<std::string>( (uint64_t)&v118,  (uint64_t)v114);
              std::string v53 = v52;
              if ((v114[23] & 0x80000000) != 0)
              {
                operator delete(*(void **)v114);
                if (v119 == v53) {
                  goto LABEL_56;
                }
              }

              else if (v119 == v52)
              {
                goto LABEL_56;
              }

              unint64_t v54 = *((unsigned int *)v53 + 14);
              int16x8_t v56 = *(char **)(v42 + 88);
              unint64_t v55 = *(void *)(v42 + 96);
              if ((unint64_t)v56 >= v55)
              {
                int16x8_t v58 = *(char **)(v42 + 80);
                uint64_t v59 = (v56 - v58) >> 2;
                unint64_t v60 = v59 + 1;
                uint64_t v61 = v55 - (void)v58;
                if (v61 >> 1 > v60) {
                  unint64_t v60 = v61 >> 1;
                }
                else {
                  unint64_t v62 = v60;
                }
                if (v62)
                {
                  if (v62 >> 62) {
LABEL_146:
                  }
                    std::__throw_bad_array_new_length[abi:nn180100]();
                  int8x8_t v63 = operator new(4 * v62);
                }

                else
                {
                  int8x8_t v63 = 0LL;
                }

                int16x8_t v64 = &v63[4 * v59];
                _DWORD *v64 = v54;
                int16x8_t v57 = v64 + 1;
                if (v56 != v58)
                {
                  unint64_t v65 = v56 - v58 - 4;
                  if (v65 < 0x2C) {
                    goto LABEL_149;
                  }
                  uint64_t v66 = (v65 >> 2) + 1;
                  uint64_t v67 = 4 * (v66 & 0x7FFFFFFFFFFFFFF8LL);
                  int v68 = &v56[-v67];
                  int16x8_t v64 = (_DWORD *)((char *)v64 - v67);
                  std::string::size_type v69 = &v63[4 * v59 - 16];
                  timeval v70 = v56 - 16;
                  uint64_t v71 = v66 & 0x7FFFFFFFFFFFFFF8LL;
                  do
                  {
                    __int128 v72 = *(_OWORD *)v70;
                    *(v69 - 1) = *((_OWORD *)v70 - 1);
                    *std::string::size_type v69 = v72;
                    v69 -= 2;
                    v70 -= 32;
                    v71 -= 8LL;
                  }

                  while (v71);
                  int16x8_t v56 = v68;
                  if (v66 != (v66 & 0x7FFFFFFFFFFFFFF8LL))
                  {
LABEL_149:
                    do
                    {
                      int v73 = *((_DWORD *)v56 - 1);
                      v56 -= 4;
                      *--int16x8_t v64 = v73;
                    }

                    while (v56 != v58);
                  }
                }

                *(void *)(v42 + 80) = v64;
                *(void *)(v42 + 88) = v57;
                *(void *)(v42 + 96) = &v63[4 * v62];
                if (v58) {
                  operator delete(v58);
                }
              }

              else
              {
                *(_DWORD *)int16x8_t v56 = v54;
                int16x8_t v57 = v56 + 4;
              }

              *(void *)(v42 + 88) = v57;
              if (v54 < (qword_100071828 - g_dynamic_register_map) >> 7
                && v46 >= *(_DWORD *)(v42 + 40) + *(_DWORD *)(g_dynamic_register_map + (v54 << 7) + 4))
              {
                unsigned int v46 = *(_DWORD *)(v42 + 40) + *(_DWORD *)(g_dynamic_register_map + (v54 << 7) + 4);
              }

LABEL_56:
              ++v45;
              uint64_t v44 = *(const char **)(*(void *)(v42 + 64) + 8 * v45);
              if (v44) {
                continue;
              }
              if (v46 == -1)
              {
LABEL_96:
                if (DNBLogEnabled()) {
                  _DNBLogThreaded("no offset was calculated entry for register %s", *(const char **)(v42 + 16));
                }
                unsigned int v46 = -1;
              }

              *(_DWORD *)(v42 + 4) = v46;
LABEL_100:
              unint64_t v74 = *(const char ***)(v42 + 72);
              if (v74)
              {
                uid_t v75 = *v74;
                if (*v74)
                {
                  uint64_t v76 = 0LL;
                  while (1)
                  {
                    size_t v78 = strlen(v75);
                    if (v78 > 0x7FFFFFFFFFFFFFF7LL) {
                      goto LABEL_144;
                    }
                    size_t v79 = v78;
                    if (v78 >= 0x17) {
                      break;
                    }
                    v114[23] = v78;
                    std::string::size_type v80 = v114;
                    if (v78) {
                      goto LABEL_113;
                    }
LABEL_114:
                    v80[v79] = 0;
                    __int128 v83 = (char **)std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::find<std::string>( (uint64_t)&v118,  (uint64_t)v114);
                    std::string::size_type v84 = v83;
                    if ((v114[23] & 0x80000000) != 0)
                    {
                      operator delete(*(void **)v114);
                      if (v119 == v84) {
                        goto LABEL_105;
                      }
                    }

                    else if (v119 == v83)
                    {
                      goto LABEL_105;
                    }

                    int v85 = *((_DWORD *)v84 + 14);
                    int v87 = *(char **)(v42 + 112);
                    unint64_t v86 = *(void *)(v42 + 120);
                    if ((unint64_t)v87 < v86)
                    {
                      *(_DWORD *)int v87 = v85;
                      unint64_t v77 = v87 + 4;
                    }

                    else
                    {
                      std::string::size_type v88 = *(char **)(v42 + 104);
                      uint64_t v89 = (v87 - v88) >> 2;
                      unint64_t v90 = v89 + 1;
                      uint64_t v91 = v86 - (void)v88;
                      if (v91 >> 1 > v90) {
                        unint64_t v90 = v91 >> 1;
                      }
                      else {
                        unint64_t v92 = v90;
                      }
                      if (v92)
                      {
                        if (v92 >> 62) {
                          goto LABEL_146;
                        }
                        std::string::size_type v93 = operator new(4 * v92);
                      }

                      else
                      {
                        std::string::size_type v93 = 0LL;
                      }

                      int v94 = &v93[4 * v89];
                      _DWORD *v94 = v85;
                      unint64_t v77 = v94 + 1;
                      if (v87 != v88)
                      {
                        unint64_t v95 = v87 - v88 - 4;
                        if (v95 < 0x2C) {
                          goto LABEL_150;
                        }
                        uint64_t v96 = (v95 >> 2) + 1;
                        uint64_t v97 = 4 * (v96 & 0x7FFFFFFFFFFFFFF8LL);
                        __int128 v98 = &v87[-v97];
                        int v94 = (_DWORD *)((char *)v94 - v97);
                        uint64_t v99 = &v93[4 * v89 - 16];
                        std::string::size_type v100 = v87 - 16;
                        uint64_t v101 = v96 & 0x7FFFFFFFFFFFFFF8LL;
                        do
                        {
                          __int128 v102 = *(_OWORD *)v100;
                          *(v99 - 1) = *((_OWORD *)v100 - 1);
                          *uint64_t v99 = v102;
                          v99 -= 2;
                          v100 -= 32;
                          v101 -= 8LL;
                        }

                        while (v101);
                        int v87 = v98;
                        if (v96 != (v96 & 0x7FFFFFFFFFFFFFF8LL))
                        {
LABEL_150:
                          do
                          {
                            int v103 = *((_DWORD *)v87 - 1);
                            v87 -= 4;
                            *--int v94 = v103;
                          }

                          while (v87 != v88);
                        }
                      }

                      *(void *)(v42 + 104) = v94;
                      *(void *)(v42 + 112) = v77;
                      *(void *)(v42 + 120) = &v93[4 * v92];
                      if (v88) {
                        operator delete(v88);
                      }
                    }

                    *(void *)(v42 + 112) = v77;
LABEL_105:
                    ++v76;
                    uid_t v75 = *(const char **)(*(void *)(v42 + 72) + 8 * v76);
                    if (!v75) {
                      goto LABEL_52;
                    }
                  }

                  uint64_t v81 = (v78 & 0xFFFFFFFFFFFFFFF8LL) + 8;
                  if ((v78 | 7) != 0x17) {
                    uint64_t v81 = v78 | 7;
                  }
                  uint64_t v82 = v81 + 1;
                  std::string::size_type v80 = operator new(v81 + 1);
                  *(void *)&v114[8] = v79;
                  *(void *)&v114[16] = v82 | 0x8000000000000000LL;
                  *(void *)uint64_t v114 = v80;
LABEL_113:
                  memmove(v80, v75, v79);
                  goto LABEL_114;
                }
              }

  ++*(void *)(a1 + 24);
  return v10;
}

      unint64_t v16 = 0;
      unsigned int v17 = __p;
      if (!__p) {
        goto LABEL_12;
      }
      goto LABEL_11;
    }

    if (v25 != (_DWORD)v6 && v25 && v26 && v27)
    {
      x[0] = -1;
      if (!pid_for_task(v25, x) && *(_DWORD *)v3 != x[0])
      {
        if (DNBLogEnabled()) {
          _DNBLogError( "Got an exec mach message but the pid of the new task and the pid of the old task do not match, something is wrong.");
        }
LABEL_45:
        unint64_t v16 = 1;
        unsigned int v17 = __p;
        if (!__p) {
          goto LABEL_12;
        }
        goto LABEL_11;
      }

      if (DNBLogEnabledForAny(8)) {
        _DNBLogThreaded("task port changed from 0x%4.4x to 0x%4.4x", (_DWORD)v6, v25);
      }
      uint64_t v6 = (MachTask *)v25;
      *((_DWORD *)this + 4) = v25;
      *((_BYTE *)this + 309) = *((_BYTE *)this + 308);
      *((_BYTE *)this + 308) = 0;
    }

    MachProcess::ExceptionMessageReceived(v3, (const MachException::Message *)v24);
    unint64_t v16 = 0;
    ++v8;
    unsigned int v17 = __p;
    if (!__p) {
      goto LABEL_12;
    }
LABEL_11:
    uint64_t v29 = v17;
    operator delete(v17);
LABEL_12:
    if ((v16 & 1) != 0) {
      break;
    }
  }

  if (DNBLogEnabledForAny(8)) {
    _DNBLogThreaded("MachTask::%s (%p): thread exiting...", "ExceptionThread", this);
  }
  if (cf) {
    CFRelease(cf);
  }
  return 0LL;
}

LABEL_52:
              v42 += 128LL;
              if (v42 != v111) {
                goto LABEL_53;
              }
              uint64_t v104 = g_dynamic_register_map;
              uint64_t v42 = qword_100071828;
              goto LABEL_142;
            }
          }

          break;
        }

        memmove(v49, v44, v48);
        goto LABEL_65;
      }

      uint64_t v104 = g_dynamic_register_map;
LABEL_142:
      g_reg_entries = v104;
      g_num_reg_entries = (v42 - v104) >> 7;
      std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::destroy( (uint64_t)&v118,  v119[0]);
      int v2 = v106;
    }
  }

  return v2 != 0;
}

  LOBYTE(v55.__locale_) = 47;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)&v55, 1LL);
  LOBYTE(v55.__locale_) = 62;
  uint64_t v50 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)&v55, 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v50 + *(void *)(*v50 - 24LL)));
  uint64_t v51 = std::locale::use_facet(&v55, &std::ctype<char>::id);
  int64_t v52 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v51->__vftable[2].~facet_0)(v51, 10LL);
  std::locale::~locale(&v55);
  std::ostream::put(v50, v52);
  return std::ostream::flush(v50);
}

void binary_encode_string(unsigned __int8 *a1@<X0>, std::string *a2@<X8>)
{
  a2->__r_.__value_.__r.__words[0] = 0LL;
  a2->__r_.__value_.__l.__size_ = 0LL;
  a2->__r_.__value_.__l.__cap_ = 0LL;
  int v3 = (char)a1[23];
  if (v3 >= 0) {
    uint64_t v4 = a1[23];
  }
  else {
    uint64_t v4 = *((void *)a1 + 1);
  }
  if (v3 >= 0) {
    uint64_t v5 = a1;
  }
  else {
    uint64_t v5 = *(unsigned __int8 **)a1;
  }
  for (; v4; --v4)
  {
    unsigned int v7 = *v5++;
    unsigned int v6 = v7;
    uint64_t v8 = (1LL << v7) & 0x41800000000LL;
    BOOL v9 = v7 > 0x2A || v8 == 0;
    if (!v9 || v6 == 125)
    {
      std::string::push_back(a2, 125);
      LOBYTE(v6) = v6 ^ 0x20;
    }

    std::string::push_back(a2, v6);
  }

uint64_t RNBRemote::SendStopReplyPacketForThread(RNBRemote *this, uint64_t a2)
{
  int v2 = this;
  int v3 = *((_DWORD *)this + 3);
  if (!v3)
  {
    v141[0].__r_.__value_.__s.__size_ = 3;
    LODWORD(v141[0].__r_.__value_.__l.__data_) = 3159365;
    uint64_t v16 = RNBRemote::SendPacket((uint64_t)this, v141);
    unsigned int v17 = (void *)v141[0].__r_.__value_.__r.__words[0];
LABEL_17:
    operator delete(v17);
    return v16;
  }

  uint64_t v4 = a2;
  if (!DNBThreadGetStopReason(*((_DWORD *)this + 3), a2, v141))
  {
    __p[0].__r_.__value_.__s.__size_ = 3;
    LODWORD(__p[0].__r_.__value_.__l.__data_) = 3224901;
    uint64_t v16 = RNBRemote::SendPacket((uint64_t)v2, __p);
    unsigned int v17 = (void *)__p[0].__r_.__value_.__r.__words[0];
    goto LABEL_17;
  }

  int data = (int)v141[0].__r_.__value_.__l.__data_;
  if (LODWORD(v141[0].__r_.__value_.__l.__data_) == 3)
  {
    RNBRemote::InitializeRegisters(v2, 1);
    *((void *)v2 + 82) = -1LL;
    *(void *)&__int128 v5 = -1LL;
    *((void *)&v5 + 1) = -1LL;
    *(_OWORD *)((char *)v2 + 616) = v5;
    *(_OWORD *)((char *)v2 + 632) = v5;
    *((_WORD *)v2 + 324) = -1;
  }

  __p[0].__r_.__value_.__r.__words[0] = v6;
  __darwin_time_t v120 = v7;
  __darwin_time_t v121 = v6;
  *(std::string::size_type *)((char *)__p[0].__r_.__value_.__r.__words + *(void *)(v6 - 24)) = v7;
  uint64_t v8 = (std::ios_base *)((char *)__p + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24));
  std::ios_base::init(v8, &__p[0].__r_.__value_.__r.__words[1]);
  v8[1].__vftable = 0LL;
  v8[1].__fmtflags_ = -1;
  std::streambuf::basic_streambuf(&__p[0].__r_.__value_.__r.__words[1]);
  __int128 v137 = 0u;
  __int128 v138 = 0u;
  int v139 = 16;
  LOBYTE(v127.tv_sec) = 84;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)&v127, 1LL);
  int v9 = v142;
  uint64_t v123 = v4;
  int v125 = v3;
  if (DNBLogEnabledForAny(0x400000))
  {
    unint64_t v10 = (pthread_mutex_t *)*((void *)v2 + 61);
    if (v10) {
      pthread_mutex_lock(*((pthread_mutex_t **)v2 + 61));
    }
    gettimeofday(&v127, 0LL);
    int tv_sec = v127.tv_sec;
    __darwin_suseconds_t tv_usec = v127.tv_usec;
    uint64_t v13 = *((void *)v2 + 62);
    int v14 = *((_DWORD *)v2 + 126);
    *((timeval *)v2 + 31) = v127;
    if (v10) {
      pthread_mutex_unlock(v10);
    }
    _DNBLogThreaded( "%8d %s got signal signo = %u, exc_type = %u",  tv_usec - v14 + 1000000 * (tv_sec - v13),  "SendStopReplyPacketForThread",  v9,  v142);
    uint64_t v4 = v123;
    int v3 = v125;
  }

  switch((int)v142)
  {
    case 1:
      unsigned __int8 v15 = -111;
      break;
    case 2:
      unsigned __int8 v15 = -110;
      break;
    case 3:
      unsigned __int8 v15 = -109;
      break;
    case 4:
      unsigned __int8 v15 = -108;
      break;
    case 5:
      unsigned __int8 v15 = -107;
      if (v143 == 2 && v144 == 65539) {
        unsigned __int8 v15 = v145;
      }
      break;
    case 6:
      unsigned __int8 v15 = 5;
      break;
    default:
      unsigned __int8 v15 = 0;
      break;
  }

  std::string::size_type v18 = __p[0].__r_.__value_.__r.__words[0];
  __int128 v19 = (char *)__p + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24);
  if (*((_DWORD *)v19 + 36) == -1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)__p + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24)));
    __int128 v20 = std::locale::use_facet((const std::locale *)&v127, &std::ctype<char>::id);
    ((void (*)(const std::locale::facet *, uint64_t))v20->__vftable[2].~facet_0)(v20, 32LL);
    std::locale::~locale((std::locale *)&v127);
    std::string::size_type v18 = __p[0].__r_.__value_.__r.__words[0];
  }

  *((_DWORD *)v19 + 36) = 48;
  *(_DWORD *)((char *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(v18 - 24)) = *(_DWORD *)((_BYTE *)&__p[0].__r_.__value_.__r.__words[1]
                                                                                                + *(void *)(v18 - 24)) & 0xFFFFFFB5 | 8;
  *(_DWORD *)((char *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(v18 - 24)) = *(_DWORD *)((_BYTE *)&__p[0].__r_.__value_.__r.__words[1]
                                                                                                + *(void *)(v18 - 24)) & 0xFFFFFF4F | 0x80;
  *(std::string::size_type *)((char *)__p[1].__r_.__value_.__r.__words + *(void *)(v18 - 24)) = 2LL;
  std::ostream::operator<<(__p, v15);
  *(_DWORD *)((char *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24)) = *(_DWORD *)((_BYTE *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24)) & 0xFFFFFFB5 | 8;
  __int128 v21 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"thread:", 7LL);
  char v22 = (void *)std::ostream::operator<<(v21, v4);
  LOBYTE(v127.tv_sec) = 59;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v22, (uint64_t)&v127, 1LL);
  uint64_t Name = (const char *)DNBThreadGetName(v3, v4);
  unsigned __int8 v124 = v2;
  if (Name)
  {
    uint64_t v24 = Name;
    if (*Name)
    {
      size_t v25 = strlen(Name);
      size_t v26 = strcspn(v24, "$#+-;:");
      *(_DWORD *)((char *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24)) = *(_DWORD *)((_BYTE *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24)) & 0xFFFFFFB5 | 8;
      if (v26 == v25)
      {
        uint64_t v27 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"name:", 5LL);
        size_t v28 = strlen(v24);
        uint64_t v29 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v27, (uint64_t)v24, v28);
        LOBYTE(v127.tv_sec) = 59;
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v29, (uint64_t)&v127, 1LL);
      }

      else
      {
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"hexname:", 8LL);
        for (; v25; --v25)
        {
          std::string::size_type v31 = __p[0].__r_.__value_.__r.__words[0];
          __int128 v32 = (char *)__p + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24);
          if (*((_DWORD *)v32 + 36) == -1)
          {
            std::ios_base::getloc((const std::ios_base *)((char *)__p
                                                        + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24)));
            uint64_t v33 = std::locale::use_facet((const std::locale *)&v127, &std::ctype<char>::id);
            ((void (*)(const std::locale::facet *, uint64_t))v33->__vftable[2].~facet_0)(v33, 32LL);
            std::locale::~locale((std::locale *)&v127);
            std::string::size_type v31 = __p[0].__r_.__value_.__r.__words[0];
          }

          *((_DWORD *)v32 + 36) = 48;
          *(_DWORD *)((char *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(v31 - 24)) = *(_DWORD *)((_BYTE *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(v31 - 24)) & 0xFFFFFFB5 | 8;
          *(_DWORD *)((char *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(v31 - 24)) = *(_DWORD *)((_BYTE *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(v31 - 24)) & 0xFFFFFF4F | 0x80;
          *(std::string::size_type *)((char *)__p[1].__r_.__value_.__r.__words + *(void *)(v31 - 24)) = 2LL;
          unsigned int v30 = *(unsigned __int8 *)v24++;
          std::ostream::operator<<(__p, v30);
        }

        LOBYTE(v127.tv_sec) = 59;
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)&v127, 1LL);
      }

      uint64_t v4 = v123;
    }
  }

  if (!*((_BYTE *)v2 + 783)) {
    goto LABEL_97;
  }
  uint64_t NumThreads = DNBProcessGetNumThreads(v3);
  if (!NumThreads) {
    goto LABEL_97;
  }
  unint64_t v35 = NumThreads;
  *(_DWORD *)((char *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24)) = *(_DWORD *)((_BYTE *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24)) & 0xFFFFFFB5 | 8;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"threads:", 8LL);
  unint64_t v36 = 0LL;
  unint64_t v37 = 0LL;
  int64_t v38 = 0LL;
  __darwin_suseconds_t v39 = 0LL;
  do
  {
    uint64_t ThreadAtIndex = DNBProcessGetThreadAtIndex(v3, v36);
    if (v36)
    {
      LOBYTE(v127.tv_sec) = 44;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)&v127, 1LL);
    }

    *(_DWORD *)((char *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24)) = *(_DWORD *)((_BYTE *)&__p[0].__r_.__value_.__r.__words[1] + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24)) & 0xFFFFFFB5 | 8;
    std::ostream::operator<<(__p, ThreadAtIndex);
    if (DNBThreadGetRegisterValueByID(v3, ThreadAtIndex, -1, 0, &v127))
    {
      uint64_t v41 = v130[0];
      if (v130[0] != (void *)-1LL)
      {
        if (v129 != 8)
        {
          if (v129 != 4) {
            goto LABEL_43;
          }
          uint64_t v41 = (void *)LODWORD(v130[0]);
        }

        if (v38 < v39)
        {
          *(void *)int64_t v38 = v41;
          v38 += 8;
          goto LABEL_43;
        }

        uint64_t v42 = (v38 - v37) >> 3;
        unint64_t v43 = v42 + 1;
        if ((v39 - v37) >> 2 > v43) {
          unint64_t v43 = (v39 - v37) >> 2;
        }
        else {
          unint64_t v44 = v43;
        }
        if (v44)
        {
          if (v44 >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v45 = operator new(8 * v44);
        }

        else
        {
          uint64_t v45 = 0LL;
        }

        unsigned int v46 = &v45[8 * v42];
        *(void *)unsigned int v46 = v41;
        size_t v47 = v46 + 8;
        if (v38 == v37)
        {
          int v3 = v125;
          __darwin_suseconds_t v39 = &v45[8 * v44];
          if (!v37) {
            goto LABEL_68;
          }
          goto LABEL_67;
        }

        unint64_t v48 = v38 - v37 - 8;
        if (v48 < 0x168
          || (unint64_t v51 = (v38 - 8 - v37) & 0xFFFFFFFFFFFFFFF8LL, &v45[v38 - v37 - 8 - v51] > &v45[v38 - v37 - 8])
          || &v38[-v51 - 8] > v38 - 8
          || (unint64_t)(v37 - v45) < 0x20)
        {
          int32x4_t v49 = v38;
          int v3 = v125;
        }

        else
        {
          uint64_t v52 = (v48 >> 3) + 1;
          uint64_t v53 = 8 * (v52 & 0x3FFFFFFFFFFFFFFCLL);
          int32x4_t v49 = &v38[-v53];
          v46 -= v53;
          unint64_t v54 = &v45[8 * v42 - 16];
          unint64_t v55 = v38 - 16;
          uint64_t v56 = v52 & 0x3FFFFFFFFFFFFFFCLL;
          int v3 = v125;
          do
          {
            __int128 v57 = *(_OWORD *)v55;
            *(v54 - 1) = *((_OWORD *)v55 - 1);
            _OWORD *v54 = v57;
            v54 -= 2;
            v55 -= 32;
            v56 -= 4LL;
          }

          while (v56);
          if (v52 == (v52 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_66:
            __darwin_suseconds_t v39 = &v45[8 * v44];
            if (!v37)
            {
LABEL_68:
              int64_t v38 = v47;
              unint64_t v37 = v46;
              goto LABEL_43;
            }

std::string *get_identifier@<X0>(std::string *__str@<X0>, std::string *a2@<X8>)
{
  a2->__r_.__value_.__r.__words[0] = 0LL;
  a2->__r_.__value_.__l.__size_ = 0LL;
  a2->__r_.__value_.__l.__cap_ = 0LL;
  int size = (char)__str->__r_.__value_.__s.__size_;
  if (size < 0)
  {
    std::string::size_type v5 = __str->__r_.__value_.__l.__size_;
    if (!v5) {
      goto LABEL_16;
    }
    std::string::size_type v6 = (std::string *)__str->__r_.__value_.__r.__words[0];
  }

  else
  {
    if (!__str->__r_.__value_.__s.__size_) {
      goto LABEL_14;
    }
    std::string::size_type v5 = __str->__r_.__value_.__s.__size_;
    std::string::size_type v6 = __str;
  }

  std::string::size_type v7 = k_space_delimiters;
  size_t v8 = strlen(k_space_delimiters);
  int v9 = v6;
  if (v8)
  {
    size_t v10 = v8;
    int v9 = v6;
    while (memchr(v7, v9->__r_.__value_.__s.__data_[0], v10))
    {
      int v9 = (std::string *)((char *)v9 + 1);
      if (!--v5)
      {
        std::string::size_type v11 = -1LL;
        goto LABEL_12;
      }
    }
  }

  std::string::size_type v11 = (char *)v9 - (char *)v6;
  if (v9 != v6)
  {
LABEL_12:
    std::string::erase(__str, 0LL, v11);
    LOBYTE(size) = __str->__r_.__value_.__s.__size_;
  }

  if ((size & 0x80) == 0)
  {
LABEL_14:
    std::string::size_type v12 = size;
    if (!(_BYTE)size) {
      goto LABEL_43;
    }
    goto LABEL_17;
  }

BOOL std::operator==[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (*((char *)a1 + 23) < 0)
  {
    if (v4 == a1[1])
    {
      if (v4 == -1LL) {
        goto LABEL_10;
      }
      a1 = (void *)*a1;
      return memcmp(a1, __s, v4) == 0;
    }
  }

  else if (v4 == *((unsigned __int8 *)a1 + 23))
  {
    if (v4 == -1LL) {
LABEL_10:
    }
      abort();
    return memcmp(a1, __s, v4) == 0;
  }

  return 0LL;
}

uint64_t set_logging(const char *__s1)
{
  if (__s1)
  {
    int v1 = __s1;
    if (*__s1)
    {
      int v2 = 0;
      do
      {
        if (strncmp(v1, "bitmask=", 8uLL))
        {
          int v3 = strchr(v1, 59);
          if (v3) {
            int v1 = v3 + 1;
          }
          else {
            v1 += strlen(v1);
          }
          continue;
        }

        v1 += 8;
        while (1)
        {
          int v5 = *(unsigned __int8 *)v1;
          if (v5 != 124) {
            break;
          }
          ++v1;
LABEL_17:
          if (!strncmp(v1, "LOG_VERBOSE", 0xBuLL))
          {
            size_t v4 = (char *)(v1 + 11);
            v2 |= 1u;
          }

          else if (!strncmp(v1, "LOG_PROCESS", 0xBuLL))
          {
            size_t v4 = (char *)(v1 + 11);
            v2 |= 2u;
          }

          else if (!strncmp(v1, "LOG_THREAD", 0xAuLL))
          {
            size_t v4 = (char *)(v1 + 10);
            v2 |= 4u;
          }

          else if (!strncmp(v1, "LOG_EXCEPTIONS", 0xEuLL))
          {
            size_t v4 = (char *)(v1 + 14);
            v2 |= 8u;
          }

          else if (!strncmp(v1, "LOG_SHLIB", 9uLL))
          {
            size_t v4 = (char *)(v1 + 9);
            v2 |= 0x10u;
          }

          else if (!strncmp(v1, "LOG_MEMORY_DATA_SHORT", 0x15uLL))
          {
            size_t v4 = (char *)(v1 + 21);
            v2 |= 0x40u;
          }

          else if (!strncmp(v1, "LOG_MEMORY_DATA_LONG", 0x14uLL))
          {
            size_t v4 = (char *)(v1 + 20);
            v2 |= 0x80u;
          }

          else if (!strncmp(v1, "LOG_MEMORY_PROTECTIONS", 0x16uLL))
          {
            size_t v4 = (char *)(v1 + 22);
            v2 |= 0x100u;
          }

          else if (!strncmp(v1, "LOG_MEMORY", 0xAuLL))
          {
            size_t v4 = (char *)(v1 + 10);
            v2 |= 0x20u;
          }

          else if (!strncmp(v1, "LOG_BREAKPOINTS", 0xFuLL))
          {
            size_t v4 = (char *)(v1 + 15);
            v2 |= 0x200u;
          }

          else if (!strncmp(v1, "LOG_EVENTS", 0xAuLL))
          {
            size_t v4 = (char *)(v1 + 10);
            v2 |= 0x400u;
          }

          else if (!strncmp(v1, "LOG_WATCHPOINTS", 0xFuLL))
          {
            size_t v4 = (char *)(v1 + 15);
            v2 |= 0x800u;
          }

          else if (!strncmp(v1, "LOG_STEP", 8uLL))
          {
            size_t v4 = (char *)(v1 + 8);
            v2 |= 0x1000u;
          }

          else if (!strncmp(v1, "LOG_TASK", 8uLL))
          {
            size_t v4 = (char *)(v1 + 8);
            v2 |= 0x2000u;
          }

          else if (!strncmp(v1, "LOG_ALL", 7uLL))
          {
            size_t v4 = (char *)(v1 + 7);
            int v2 = -1;
          }

          else if (!strncmp(v1, "LOG_DEFAULT", 0xBuLL))
          {
            size_t v4 = (char *)(v1 + 11);
            v2 |= 0x3A3Eu;
          }

          else if (!strncmp(v1, "LOG_NONE", 8uLL))
          {
            int v2 = 0;
            size_t v4 = (char *)(v1 + 8);
          }

          else if (!strncmp(v1, "LOG_RNB_MINIMAL", 0xFuLL))
          {
            size_t v4 = (char *)(v1 + 15);
            v2 |= 0x10000u;
          }

          else if (!strncmp(v1, "LOG_RNB_MEDIUM", 0xEuLL))
          {
            size_t v4 = (char *)(v1 + 14);
            v2 |= 0x20000u;
          }

          else if (!strncmp(v1, "LOG_RNB_MAX", 0xBuLL))
          {
            size_t v4 = (char *)(v1 + 11);
            v2 |= 0x40000u;
          }

          else if (!strncmp(v1, "LOG_RNB_COMM", 0xCuLL))
          {
            size_t v4 = (char *)(v1 + 12);
            v2 |= 0x80000u;
          }

          else if (!strncmp(v1, "LOG_RNB_REMOTE", 0xEuLL))
          {
            size_t v4 = (char *)(v1 + 14);
            v2 |= 0x100000u;
          }

          else if (!strncmp(v1, "LOG_RNB_EVENTS", 0xEuLL))
          {
            size_t v4 = (char *)(v1 + 14);
            v2 |= 0x200000u;
          }

          else if (!strncmp(v1, "LOG_RNB_PROC", 0xCuLL))
          {
            size_t v4 = (char *)(v1 + 12);
            v2 |= 0x400000u;
          }

          else if (!strncmp(v1, "LOG_RNB_PACKETS", 0xFuLL))
          {
            size_t v4 = (char *)(v1 + 15);
            v2 |= 0x800000u;
          }

          else if (!strncmp(v1, "LOG_RNB_ALL", 0xBuLL))
          {
            size_t v4 = (char *)(v1 + 11);
            v2 |= 0xFFFF0000;
          }

          else if (!strncmp(v1, "LOG_RNB_DEFAULT", 0xFuLL))
          {
            size_t v4 = (char *)(v1 + 15);
            v2 |= 0xFFFF0000;
          }

          else if (!strncmp(v1, "LOG_DARWIN_LOG", 0xEuLL))
          {
            size_t v4 = (char *)(v1 + 14);
            v2 |= 0x4000u;
          }

          else if (!strncmp(v1, "LOG_RNB_NONE", 0xCuLL))
          {
            int v2 = 0;
            size_t v4 = (char *)(v1 + 12);
          }

          else
          {
            size_t v4 = strchr(v1, 124);
            if (!v4)
            {
              size_t v4 = strchr(v1, 59);
              if (!v4) {
                size_t v4 = (char *)&v1[strlen(v1)];
              }
            }
          }

          int v1 = v4;
          if (!v4) {
            return 0LL;
          }
        }

        if (!*v1) {
          continue;
        }
        if (v5 != 59) {
          goto LABEL_17;
        }
        if (!DNBLogGetLogCallback())
        {
          LogFunction = (void (*)(void *, char, const char *, va_list))OsLogger::GetLogFunction(0LL);
          if (!LogFunction) {
            LogFunction = ASLLogCallback;
          }
          DNBLogSetLogCallback(LogFunction, 0LL);
        }

        DNBLogSetLogMask(v2);
        ++v1;
      }

      while (*v1);
    }
  }

  return 0LL;
}

uint64_t append_hex_value(uint64_t result, unsigned __int8 *a2, uint64_t a3, char a4)
{
  uint64_t v4 = a3;
  std::string::size_type v6 = (uint64_t *)result;
  if ((a4 & 1) != 0)
  {
    if ((int)a3 >= 1)
    {
      uint64_t v7 = result + 8;
      unint64_t v8 = a3 + 1LL;
      do
      {
        uint64_t v9 = *v6;
        size_t v10 = (char *)v6 + *(void *)(*v6 - 24);
        if (*((_DWORD *)v10 + 36) == -1)
        {
          std::ios_base::getloc((const std::ios_base *)((char *)v6 + *(void *)(*v6 - 24)));
          std::string::size_type v11 = std::locale::use_facet(&v17, &std::ctype<char>::id);
          ((void (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 32LL);
          std::locale::~locale(&v17);
          uint64_t v9 = *v6;
        }

        *((_DWORD *)v10 + 36) = 48;
        *(_DWORD *)(v7 + *(void *)(v9 - 24)) = *(_DWORD *)(v7 + *(void *)(v9 - 24)) & 0xFFFFFFB5 | 8;
        *(_DWORD *)(v7 + *(void *)(v9 - 24)) = *(_DWORD *)(v7 + *(void *)(v9 - 24)) & 0xFFFFFF4F | 0x80;
        *(uint64_t *)((char *)v6 + *(void *)(v9 - 24) + 24) = 2LL;
        uint64_t result = std::ostream::operator<<(v6, a2[(v8-- - 2)]);
      }

      while (v8 > 1);
    }
  }

  else if (a3)
  {
    uint64_t v12 = result + 8;
    do
    {
      uint64_t v14 = *v6;
      unsigned __int8 v15 = (char *)v6 + *(void *)(*v6 - 24);
      if (*((_DWORD *)v15 + 36) == -1)
      {
        std::ios_base::getloc((const std::ios_base *)((char *)v6 + *(void *)(*v6 - 24)));
        std::string::size_type v16 = std::locale::use_facet(&v17, &std::ctype<char>::id);
        ((void (*)(const std::locale::facet *, uint64_t))v16->__vftable[2].~facet_0)(v16, 32LL);
        std::locale::~locale(&v17);
        uint64_t v14 = *v6;
      }

      *((_DWORD *)v15 + 36) = 48;
      *(_DWORD *)(v12 + *(void *)(v14 - 24)) = *(_DWORD *)(v12 + *(void *)(v14 - 24)) & 0xFFFFFFB5 | 8;
      *(_DWORD *)(v12 + *(void *)(v14 - 24)) = *(_DWORD *)(v12 + *(void *)(v14 - 24)) & 0xFFFFFF4F | 0x80;
      *(uint64_t *)((char *)v6 + *(void *)(v14 - 24) + 24) = 2LL;
      unsigned int v13 = *a2++;
      uint64_t result = std::ostream::operator<<(v6, v13);
      --v4;
    }

    while (v4);
  }

  return result;
}

void cstring_to_asciihex_string(const char *a1@<X0>, std::string *a2@<X8>)
{
  a2->__r_.__value_.__r.__words[0] = 0LL;
  a2->__r_.__value_.__l.__size_ = 0LL;
  a2->__r_.__value_.__l.__cap_ = 0LL;
  size_t v4 = strlen(a1);
  std::string::reserve(a2, 2 * v4);
  if (a1)
  {
    int v5 = *(unsigned __int8 *)a1;
    if (*a1)
    {
      std::string::size_type v6 = a1 + 1;
      do
      {
        snprintf(__str, 5uLL, "%02x", v5);
        std::string::append(a2, __str);
        int v7 = *(unsigned __int8 *)v6++;
        int v5 = v7;
      }

      while (v7);
    }
  }

uint64_t append_hexified_string(uint64_t result, unsigned __int8 *a2)
{
  int v2 = (char)a2[23];
  if (v2 >= 0) {
    uint64_t v3 = a2[23];
  }
  else {
    uint64_t v3 = *((void *)a2 + 1);
  }
  if (v2 >= 0) {
    size_t v4 = a2;
  }
  else {
    size_t v4 = *(unsigned __int8 **)a2;
  }
  if (v3)
  {
    int v5 = (uint64_t *)result;
    uint64_t v6 = result + 8;
    uint64_t v7 = result + 24;
    do
    {
      uint64_t v9 = *v5;
      size_t v10 = (char *)v5 + *(void *)(*v5 - 24);
      if (*((_DWORD *)v10 + 36) == -1)
      {
        std::ios_base::getloc((const std::ios_base *)((char *)v5 + *(void *)(*v5 - 24)));
        std::string::size_type v11 = std::locale::use_facet(&v12, &std::ctype<char>::id);
        ((void (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 32LL);
        std::locale::~locale(&v12);
        uint64_t v9 = *v5;
      }

      *((_DWORD *)v10 + 36) = 48;
      *(_DWORD *)(v6 + *(void *)(v9 - 24)) = *(_DWORD *)(v6 + *(void *)(v9 - 24)) & 0xFFFFFFB5 | 8;
      *(_DWORD *)(v6 + *(void *)(v9 - 24)) = *(_DWORD *)(v6 + *(void *)(v9 - 24)) & 0xFFFFFF4F | 0x80;
      *(void *)(v7 + *(void *)(v9 - 24)) = 2LL;
      unsigned int v8 = *v4++;
      uint64_t result = std::ostream::operator<<(v5, v8);
      --v3;
    }

    while (v3);
  }

  return result;
}

void register_value_in_hex_fixed_width(uint64_t a1, int a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  if (a4)
  {
    int v5 = a5;
    if (a5
      || (int v5 = v17, DNBThreadGetRegisterValueByID(a2, a3, *(_DWORD *)(a4 + 8), *(_DWORD *)(a4 + 12), v17)))
    {
      unsigned int v8 = v5 + 72;
      uint64_t v9 = *(unsigned int *)(a4 + 36);
LABEL_5:
      append_hex_value(a1, v8, v9, 0);
      return;
    }

    size_t v10 = *(unsigned int *)(a4 + 36);
    if ((_DWORD)v10)
    {
      if (v10 >= 0x17)
      {
        if ((v10 | 7) == 0x17) {
          uint64_t v12 = (v10 & 0xFFFFFFF8) + 8LL;
        }
        else {
          uint64_t v12 = v10 | 7;
        }
        std::string::size_type v11 = (unsigned __int8 *)operator new(v12 + 1);
        size_t v15 = v10;
        uint64_t v16 = v12 - 0x7FFFFFFFFFFFFFFFLL;
        uint64_t v14 = v11;
      }

      else
      {
        HIBYTE(v16) = v10;
        std::string::size_type v11 = (unsigned __int8 *)&v14;
      }

      bzero(v11, v10);
      v11[v10] = 0;
      if (SHIBYTE(v16) < 0)
      {
        unsigned int v13 = v14;
        append_hex_value(a1, v14, v15, 0);
        operator delete(v13);
        return;
      }

      uint64_t v9 = HIBYTE(v16);
      unsigned int v8 = (unsigned __int8 *)&v14;
      goto LABEL_5;
    }
  }

void *std::basic_string<unsigned char>::basic_string[abi:nn180100](void *__b, size_t __len, int __c)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8LL) {
    abort();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000LL;
    char *__b = v6;
  }

  else
  {
    *((_BYTE *)__b + 23) = __len;
    uint64_t v6 = __b;
    if (!__len) {
      goto LABEL_9;
    }
  }

  memset(v6, __c, __len);
LABEL_9:
  *((_BYTE *)v6 + __len) = 0;
  return __b;
}

uint64_t *debugserver_regnum_with_fixed_width_hex_register_value( uint64_t *result, int a2, uint64_t a3, unsigned __int8 *a4, _BYTE *a5)
{
  if (a4)
  {
    uint64_t v9 = result;
    uint64_t v10 = *result;
    std::string::size_type v11 = (char *)result + *(void *)(*result - 24);
    if (*((_DWORD *)v11 + 36) == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)result + *(void *)(*result - 24)));
      uint64_t v12 = std::locale::use_facet(&v14, &std::ctype<char>::id);
      ((void (*)(const std::locale::facet *, uint64_t))v12->__vftable[2].~facet_0)(v12, 32LL);
      std::locale::~locale(&v14);
      uint64_t v10 = *v9;
    }

    *((_DWORD *)v11 + 36) = 48;
    *(_DWORD *)((char *)v9 + *(void *)(v10 - 24) + 8) = *(_DWORD *)((_BYTE *)v9 + *(void *)(v10 - 24) + 8) & 0xFFFFFFB5 | 8;
    *(_DWORD *)((char *)v9 + *(void *)(v10 - 24) + 8) = *(_DWORD *)((_BYTE *)v9 + *(void *)(v10 - 24) + 8) & 0xFFFFFF4F | 0x80;
    *(uint64_t *)((char *)v9 + *(void *)(v10 - 24) + 24) = 2LL;
    unsigned int v13 = (void *)std::ostream::operator<<(v9, *a4);
    char v15 = 58;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v13, (uint64_t)&v15, 1LL);
    register_value_in_hex_fixed_width((uint64_t)v9, a2, a3, (uint64_t)a4, a5);
    char v16 = 59;
    return std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v9, (uint64_t)&v16, 1LL);
  }

  return result;
}

double RNBRemote::DispatchQueueOffsets::GetThreadQueueInfo( unsigned __int16 *a1, int a2, mach_vm_address_t a3, uint64_t *a4, uint64_t a5, uint64_t *a6, uint64_t *a7)
{
  if (*(char *)(a5 + 23) < 0)
  {
    **(_BYTE **)a5 = 0;
    *(void *)(a5 + 8) = 0LL;
  }

  else
  {
    *(_BYTE *)a5 = 0;
    *(_BYTE *)(a5 + 23) = 0;
  }

  *a6 = 0LL;
  *a7 = 0LL;
  if (a3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && *a1 != 0xFFFF)
  {
    uint64_t Pointer = DNBProcessMemoryReadPointer(a2, a3);
    *a4 = Pointer;
    if (Pointer)
    {
      *a6 = DNBProcessMemoryReadInteger(a2, Pointer + a1[7], a1[8], 0LL);
      *a7 = DNBProcessMemoryReadInteger(a2, *a4 + a1[5], a1[6], 0LL);
      if (*a1 < 4u)
      {
        DNBProcessMemoryReadCStringFixed(&v16);
        if ((*(char *)(a5 + 23) & 0x80000000) == 0)
        {
LABEL_13:
          double result = *(double *)&v16.__r_.__value_.__l.__data_;
          *(std::string *)a5 = v16;
          return result;
        }
      }

      else
      {
        mach_vm_address_t v15 = DNBProcessMemoryReadPointer(a2, *a4 + a1[1]);
        if (!v15) {
          return result;
        }
        DNBProcessMemoryReadCString(a2, v15, &v16);
      }

      operator delete(*(void **)a5);
      goto LABEL_13;
    }
  }

  return result;
}

void RNBRemote::GetJSONThreadsInfo(RNBRemote *this@<X0>, int a2@<W1>, std::__shared_weak_count **a3@<X8>)
{
  if (!*((_DWORD *)this + 3))
  {
    size_t v7 = 0LL;
    uint64_t v9 = 0LL;
    goto LABEL_274;
  }

  uint64_t v6 = (std::__shared_weak_count *)operator new(0x50uLL);
  size_t v7 = v6;
  v6->__shared_owners_ = 0LL;
  p_shared_owners = (unint64_t *)&v6->__shared_owners_;
  v6->__shared_weak_owners_ = 0LL;
  v6->__vftable = (std::__shared_weak_count_vtbl *)off_100060F00;
  v6[1].__vftable = (std::__shared_weak_count_vtbl *)off_100060D90;
  uint64_t v9 = v6 + 1;
  LODWORD(v6[2].__vftable) = 2;
  v6[2].__shared_owners_ = 0LL;
  uint64_t v142 = (uint64_t)&v6[2].__shared_owners_;
  v6[2].__shared_weak_owners_ = 0LL;
  v6[3].__vftable = 0LL;
  do
    unint64_t v10 = __ldxr(p_shared_owners);
  while (__stxr(v10 + 1, p_shared_owners));
  p_shared_weak_owners = (unint64_t *)&v6->__shared_weak_owners_;
  do
    unint64_t v12 = __ldxr(p_shared_weak_owners);
  while (__stxr(v12 + 1, p_shared_weak_owners));
  v6[1].__shared_owners_ = (uint64_t)v9;
  v6[1].__shared_weak_owners_ = (uint64_t)v6;
  do
    unint64_t v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v7);
  }

  int v158 = *((_DWORD *)this + 3);
  uint64_t NumThreads = DNBProcessGetNumThreads(v158);
  if (NumThreads)
  {
    int v139 = v9;
    uint64_t v140 = a3;
    unint64_t v14 = 0LL;
    uint64_t v141 = this;
    mach_vm_address_t v15 = (__int16 *)((char *)this + 616);
    int v146 = a2;
    unsigned int v145 = v7;
    unsigned __int8 v147 = (char *)this + 616;
    while (1)
    {
      uint64_t ThreadAtIndex = (void (__cdecl *)(std::__shared_weak_count *__hidden))DNBProcessGetThreadAtIndex(v158, v14);
      int StopReason = DNBThreadGetStopReason(v158, (uint64_t)ThreadAtIndex, v213);
      int v18 = StopReason;
      if (!a2 || StopReason && v213[0]) {
        break;
      }
LABEL_12:
      if (++v14 == NumThreads)
      {
        uint64_t v9 = v139;
        a3 = v140;
        goto LABEL_274;
      }
    }

    __darwin_ct_rune_t v19 = (std::__shared_weak_count_vtbl *)operator new(0x38uLL);
    LODWORD(v19->__get_deleter) = 7;
    v19->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))off_100060D18;
    v19[1].~__shared_weak_count = 0LL;
    v19[1].~__shared_weak_count_0 = 0LL;
    v19->__on_zero_shared_weak = 0LL;
    __int128 v20 = (std::__shared_weak_count *)operator new(0x20uLL);
    __int128 v21 = v20;
    v20->__shared_owners_ = 0LL;
    char v22 = (unint64_t *)&v20->__shared_owners_;
    v20->__vftable = (std::__shared_weak_count_vtbl *)off_100060F38;
    v20->__shared_weak_owners_ = 0LL;
    v20[1].__vftable = v19;
    do
      unint64_t v23 = __ldxr(v22);
    while (__stxr(v23 + 1, v22));
    uint64_t v24 = (unint64_t *)&v20->__shared_weak_owners_;
    do
      unint64_t v25 = __ldxr(v24);
    while (__stxr(v25 + 1, v24));
    v19->~__shared_weak_count_0 = (void (__cdecl *)(std::__shared_weak_count *__hidden))v19;
    v19->__on_zero_shared = (void (__cdecl *)(std::__shared_count *__hidden))v20;
    do
      unint64_t v26 = __ldaxr(v22);
    while (__stlxr(v26 - 1, v22));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v21);
    }

    __p.__r_.__value_.__s.__size_ = 3;
    LODWORD(__p.__r_.__value_.__l.__data_) = 6580596;
    JSONGenerator::Dictionary::AddIntegerItem((uint64_t)v19, &__p, ThreadAtIndex);
    v211.__r_.__value_.__s.__size_ = 4;
    strcpy((char *)&v211, "none");
    unsigned int v156 = v21;
    uint64_t v157 = (uint64_t)v19;
    if (v18)
    {
      switch(v213[0])
      {
        case 1:
          if (!(_DWORD)v214) {
            goto LABEL_90;
          }
          v210.__r_.__value_.__s.__size_ = 6;
          strcpy((char *)&v210, "signal");
          JSONGenerator::Dictionary::AddIntegerItem( (uint64_t)v19,  &v210,  (void (__cdecl *)(std::__shared_weak_count *__hidden))v214);
          uint64_t v27 = "signal";
LABEL_66:
          std::string::assign(&v211, v27);
          goto LABEL_90;
        case 2:
          if (!(_DWORD)v214) {
            goto LABEL_90;
          }
          unint64_t v152 = v14;
          std::string::assign(&v211, "exception");
          v209.__r_.__value_.__s.__size_ = 6;
          strcpy((char *)&v209, "metype");
          JSONGenerator::Dictionary::AddIntegerItem( (uint64_t)v19,  &v209,  (void (__cdecl *)(std::__shared_weak_count *__hidden))v214);
          size_t v28 = (std::__shared_weak_count_vtbl *)operator new(0x38uLL);
          LODWORD(v28->__get_deleter) = 2;
          v28->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))off_100060D90;
          v28->__on_zero_shared_weak = 0LL;
          v28[1].~__shared_weak_count = 0LL;
          v28[1].~__shared_weak_count_0 = 0LL;
          uint64_t v29 = (std::__shared_weak_count *)operator new(0x20uLL);
          unsigned int v30 = v29;
          v29->__shared_owners_ = 0LL;
          std::string::size_type v31 = (unint64_t *)&v29->__shared_owners_;
          v29->__vftable = (std::__shared_weak_count_vtbl *)off_100060F70;
          v29->__shared_weak_owners_ = 0LL;
          v29[1].__vftable = v28;
          do
            unint64_t v32 = __ldxr(v31);
          while (__stxr(v32 + 1, v31));
          uint64_t v33 = (unint64_t *)&v29->__shared_weak_owners_;
          do
            unint64_t v34 = __ldxr(v33);
          while (__stxr(v34 + 1, v33));
          v28->~__shared_weak_count_0 = (void (__cdecl *)(std::__shared_weak_count *__hidden))v28;
          v28->__on_zero_shared = (void (__cdecl *)(std::__shared_count *__hidden))v29;
          do
            unint64_t v35 = __ldaxr(v31);
          while (__stlxr(v35 - 1, v31));
          *(void *)unsigned int v154 = ThreadAtIndex;
          if (!v35)
          {
            ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
            std::__shared_weak_count::__release_weak(v30);
          }

          unint64_t v143 = v30;
          if (v215)
          {
            for (unint64_t i = 0LL; i < (unint64_t)v215; ++i)
            {
              unint64_t v37 = (std::__shared_weak_count_vtbl *)operator new(0x28uLL);
              int64_t v38 = (void (__cdecl *)(std::__shared_weak_count *__hidden))v216[i];
              LODWORD(v37->__get_deleter) = 3;
              v37->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))off_100060DD0;
              v37->__on_zero_shared_weak = v38;
              __darwin_suseconds_t v39 = (std::__shared_weak_count *)operator new(0x20uLL);
              uint64_t v40 = v39;
              v39->__shared_owners_ = 0LL;
              uint64_t v41 = (unint64_t *)&v39->__shared_owners_;
              v39->__vftable = (std::__shared_weak_count_vtbl *)off_100060FA8;
              v39->__shared_weak_owners_ = 0LL;
              v39[1].__vftable = v37;
              do
                unint64_t v42 = __ldxr(v41);
              while (__stxr(v42 + 1, v41));
              unint64_t v43 = (unint64_t *)&v39->__shared_weak_owners_;
              do
                unint64_t v44 = __ldxr(v43);
              while (__stxr(v44 + 1, v43));
              v37->~__shared_weak_count_0 = (void (__cdecl *)(std::__shared_weak_count *__hidden))v37;
              v37->__on_zero_shared = (void (__cdecl *)(std::__shared_count *__hidden))v39;
              do
                unint64_t v45 = __ldaxr(v41);
              while (__stlxr(v45 - 1, v41));
              if (!v45)
              {
                ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
                std::__shared_weak_count::__release_weak(v40);
              }

              *(void *)&__int128 v208 = v37;
              *((void *)&v208 + 1) = v40;
              unsigned int v46 = (std::__shared_weak_count_vtbl **)v28[1].~__shared_weak_count;
              if ((char *)v46 >= (char *)v28[1].~__shared_weak_count_0)
              {
                unint64_t v48 = (void (__cdecl *)(std::__shared_weak_count *__hidden))std::vector<std::shared_ptr<JSONGenerator::Object>>::__push_back_slow_path<std::shared_ptr<JSONGenerator::Object> const&>( (uint64_t)&v28->__on_zero_shared_weak,  &v208);
              }

              else
              {
                char *v46 = v37;
                v46[1] = (std::__shared_weak_count_vtbl *)v40;
                do
                  unint64_t v47 = __ldxr(v41);
                while (__stxr(v47 + 1, v41));
                unint64_t v48 = (void (__cdecl *)(std::__shared_weak_count *__hidden))(v46 + 2);
              }

              __int128 v21 = v156;
              __darwin_ct_rune_t v19 = (std::__shared_weak_count_vtbl *)v157;
              v28[1].~__shared_weak_count = v48;
              int32x4_t v49 = (std::__shared_weak_count *)*((void *)&v208 + 1);
              if (*((void *)&v208 + 1))
              {
                uint64_t v50 = (unint64_t *)(*((void *)&v208 + 1) + 8LL);
                do
                  unint64_t v51 = __ldaxr(v50);
                while (__stlxr(v51 - 1, v50));
                if (!v51)
                {
                  ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
                  std::__shared_weak_count::__release_weak(v49);
                }
              }
            }
          }

          char v207 = 6;
          strcpy((char *)v206, "medata");
          uint64_t v204 = v28;
          uint64_t v205 = v143;
          do
            unint64_t v55 = __ldxr(v31);
          while (__stxr(v55 + 1, v31));
          JSONGenerator::Dictionary::AddItem((uint64_t)v19, (uint64_t)v206, &v204);
          uint64_t v56 = v205;
          a2 = v146;
          size_t v7 = v145;
          uint64_t ThreadAtIndex = *(void (__cdecl **)(std::__shared_weak_count *__hidden))v154;
          if (!v205) {
            goto LABEL_84;
          }
          __int128 v57 = (unint64_t *)&v205->__shared_owners_;
          do
            unint64_t v58 = __ldaxr(v57);
          while (__stlxr(v58 - 1, v57));
          if (v58)
          {
LABEL_84:
            if ((v207 & 0x80000000) == 0) {
              goto LABEL_87;
            }
LABEL_85:
            operator delete(v206[0]);
            goto LABEL_87;
          }

          ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
          std::__shared_weak_count::__release_weak(v56);
          if (v207 < 0) {
            goto LABEL_85;
          }
          do
LABEL_87:
            unint64_t v59 = __ldaxr(v31);
          while (__stlxr(v59 - 1, v31));
          unint64_t v14 = v152;
          if (!v59)
          {
            ((void (*)(std::__shared_weak_count *))v143->__on_zero_shared)(v143);
            std::__shared_weak_count::__release_weak(v143);
          }

LABEL_90:
          v194.__r_.__value_.__s.__size_ = 6;
          strcpy((char *)&v194, "reason");
          std::string::__init_copy_ctor_external(&v193, v211.__r_.__value_.__l.__data_, v211.__r_.__value_.__l.__size_);
          break;
        case 3:
          uint64_t v27 = "exec";
          goto LABEL_66;
        case 4:
          std::string::assign(&v211, "watchpoint");
          v203.__r_.__value_.__s.__size_ = 10;
          strcpy((char *)&v203, "watchpoint");
          JSONGenerator::Dictionary::AddIntegerItem((uint64_t)v19, &v203, v215);
          v202.__r_.__value_.__s.__size_ = 13;
          strcpy((char *)&v202, "me_watch_addr");
          JSONGenerator::Dictionary::AddIntegerItem((uint64_t)v19, &v202, v214);
          __s[0].__r_.__value_.__r.__words[0] = v151;
          *(std::string::size_type *)((char *)__s[0].__r_.__value_.__r.__words + *(void *)(v151 - 24)) = v149;
          uint64_t v52 = (std::ios_base *)((char *)__s + *(void *)(__s[0].__r_.__value_.__r.__words[0] - 24));
          std::ios_base::init(v52, &__s[0].__r_.__value_.__r.__words[1]);
          v52[1].__vftable = 0LL;
          v52[1].__fmtflags_ = -1;
          std::streambuf::basic_streambuf(&__s[0].__r_.__value_.__r.__words[1]);
          __int128 v198 = 0u;
          __int128 v199 = 0u;
          int v200 = 16;
          uint64_t v53 = (void *)std::ostream::operator<<(__s, v215);
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v53, (uint64_t)" ", 1LL);
          unint64_t v54 = (void *)std::ostream::operator<<(__s, LODWORD(v216[0]));
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v54, (uint64_t)" ", 1LL);
          std::ostream::operator<<(__s, v214);
          v196.__r_.__value_.__s.__size_ = 11;
          strcpy((char *)&v196, "description");
          std::stringbuf::str(&v195, (const std::stringbuf *)&__s[0].__r_.__value_.__r.__words[1]);
          JSONGenerator::Dictionary::AddStringItem((uint64_t)v19, &v196, (uint64_t)&v195);
          mach_vm_address_t v15 = (__int16 *)v147;
          __s[0].__r_.__value_.__r.__words[0] = v150;
          *(std::string::size_type *)((char *)__s[0].__r_.__value_.__r.__words + *(void *)(v150 - 24)) = v148;
          if (SBYTE7(v199) < 0) {
            operator delete((void *)v198);
          }
          std::streambuf::~streambuf(&__s[0].__r_.__value_.__r.__words[1]);
          std::ios::~ios(v201);
          goto LABEL_90;
        default:
          goto LABEL_32;
      }
    }

    else
    {
LABEL_32:
      v194.__r_.__value_.__s.__size_ = 6;
      strcpy((char *)&v194, "reason");
LABEL_91:
      std::string v193 = v211;
    }

    JSONGenerator::Dictionary::AddStringItem((uint64_t)v19, &v194, (uint64_t)&v193);
    if ((char)v193.__r_.__value_.__s.__size_ < 0)
    {
      operator delete(v193.__r_.__value_.__l.__data_);
      if (((char)v194.__r_.__value_.__s.__size_ & 0x80000000) == 0)
      {
LABEL_94:
        if ((a2 & 1) != 0) {
          goto LABEL_255;
        }
        goto LABEL_98;
      }
    }

    else if (((char)v194.__r_.__value_.__s.__size_ & 0x80000000) == 0)
    {
      goto LABEL_94;
    }

    operator delete(v194.__r_.__value_.__l.__data_);
    if ((a2 & 1) != 0)
    {
LABEL_255:
      *(void *)&__int128 v159 = v19;
      *((void *)&v159 + 1) = v21;
      do
        unint64_t v131 = __ldxr(v22);
      while (__stxr(v131 + 1, v22));
      shared_weak_owners = (void *)v7[2].__shared_weak_owners_;
      if ((std::__shared_weak_count_vtbl *)shared_weak_owners >= v7[3].__vftable)
      {
        unint64_t v134 = std::vector<std::shared_ptr<JSONGenerator::Object>>::__push_back_slow_path<std::shared_ptr<JSONGenerator::Object> const&>( v142,  &v159);
      }

      else
      {
        void *shared_weak_owners = v19;
        shared_weak_owners[1] = v21;
        do
          unint64_t v133 = __ldxr(v22);
        while (__stxr(v133 + 1, v22));
        unint64_t v134 = shared_weak_owners + 2;
      }

      v7[2].__shared_weak_owners_ = (uint64_t)v134;
      uint64_t v135 = (std::__shared_weak_count *)*((void *)&v159 + 1);
      if (!*((void *)&v159 + 1)) {
        goto LABEL_266;
      }
      int v136 = (unint64_t *)(*((void *)&v159 + 1) + 8LL);
      do
        unint64_t v137 = __ldaxr(v136);
      while (__stlxr(v137 - 1, v136));
      if (!v137)
      {
        ((void (*)(std::__shared_weak_count *))v135->__on_zero_shared)(v135);
        std::__shared_weak_count::__release_weak(v135);
      }

      else
      {
LABEL_266:
        if (((char)v211.__r_.__value_.__s.__size_ & 0x80000000) == 0)
        {
          do
LABEL_269:
            unint64_t v138 = __ldaxr(v22);
          while (__stlxr(v138 - 1, v22));
          if (!v138)
          {
            ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
            std::__shared_weak_count::__release_weak(v21);
          }

          goto LABEL_12;
        }
      }

      operator delete(v211.__r_.__value_.__l.__data_);
      goto LABEL_269;
    }

      unint64_t v95 = 1;
      if (SHIBYTE(v117) < 0) {
        goto LABEL_84;
      }
LABEL_91:
      if ((v95 & 1) != 0) {
        goto LABEL_92;
      }
      return a4;
    case 5u:
      uint64_t v52 = strlen(a2);
      if (v52 > 0x7FFFFFFFFFFFFFF7LL) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      uint64_t v53 = (void *)v52;
      if (v52 >= 0x17)
      {
        std::string::size_type v84 = (v52 & 0xFFFFFFFFFFFFFFF8LL) + 8;
        if ((v52 | 7) != 0x17) {
          std::string::size_type v84 = v52 | 7;
        }
        unint64_t v85 = v84 + 1;
        unint64_t v54 = operator new(v84 + 1);
        __src[1] = v53;
        unint64_t v115 = v85 | 0x8000000000000000LL;
        __src[0] = v54;
        unint64_t v55 = a14;
      }

      else
      {
        HIBYTE(v115) = v52;
        unint64_t v54 = __src;
        unint64_t v55 = a14;
        if (!v52) {
          goto LABEL_66;
        }
      }

      memcpy(v54, a2, (size_t)v53);
LABEL_66:
      *((_BYTE *)v53 + (void)v54) = 0;
      GetAppBundle(__src, &__dst);
      if (SHIBYTE(v115) < 0)
      {
        operator delete(__src[0]);
        unint64_t v86 = SHIBYTE(v117);
        if ((SHIBYTE(v117) & 0x80000000) == 0) {
          goto LABEL_68;
        }
      }

      else
      {
        unint64_t v86 = SHIBYTE(v117);
        if ((SHIBYTE(v117) & 0x80000000) == 0)
        {
LABEL_68:
          if (!v86) {
            goto LABEL_86;
          }
          a1[110] |= 0x18u;
          unint64_t v87 = (const char *)&__dst;
          goto LABEL_82;
        }
      }

      if (!*((void *)&__dst + 1)) {
        goto LABEL_86;
      }
      a1[110] |= 0x18u;
      unint64_t v87 = (const char *)__dst;
LABEL_82:
      if (!MachProcess::BoardServiceLaunchForDebug( a1,  v87,  (const char **)a3,  a4,  a9,  a11 != 0,  a12,  a13,  v55))
      {
LABEL_86:
        if (DNBLogEnabled())
        {
          unint64_t v102 = &__dst;
          if (v117 < 0) {
            unint64_t v102 = (__int128 *)__dst;
          }
          _DNBLog(0LL, (uint64_t)"Failed to launch '%s' with FBS", v96, v97, v98, v99, v100, v101, (uint64_t)v102);
        }

        goto LABEL_90;
      }

LABEL_98:
    uint64_t Name = (const char *)DNBThreadGetName(v158, (uint64_t)ThreadAtIndex);
    if (!Name || (uint64_t v61 = Name, !*Name))
    {
LABEL_113:
      v188.__r_.__value_.__s.__size_ = 5;
      strcpy((char *)&v188, "qaddr");
      JSONGenerator::Dictionary::AddIntegerItem( (uint64_t)v19,  &v188,  (void (__cdecl *)(std::__shared_weak_count *__hidden))v189.dispatch_qaddr);
      if (*v15 == -1)
      {
        mach_vm_address_t v76 = *((void *)v141 + 82);
        if (v76 == -1LL) {
          goto LABEL_165;
        }
        int v77 = *((_DWORD *)v141 + 3);
        if (!v77) {
          goto LABEL_165;
        }
        if (DNBProcessMemoryRead(v77, v76, 0x22uLL, (char *)v15) != 34)
        {
          v15[16] = -1;
          *(void *)&__int128 v80 = -1LL;
          *((void *)&v80 + 1) = -1LL;
          *(_OWORD *)mach_vm_address_t v15 = v80;
          *((_OWORD *)v15 + 1) = v80;
          goto LABEL_165;
        }

        if (*v15 == -1)
        {
LABEL_165:
          if (!g_reg_entries) {
            goto LABEL_197;
          }
          uint64_t v155 = (uint64_t)ThreadAtIndex;
          uint64_t v81 = (std::__shared_weak_count_vtbl *)operator new(0x38uLL);
          LODWORD(v81->__get_deleter) = 7;
          v81->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))off_100060D18;
          v81[1].~__shared_weak_count = 0LL;
          v81[1].~__shared_weak_count_0 = 0LL;
          v81->__on_zero_shared_weak = 0LL;
          uint64_t v82 = (std::__shared_weak_count *)operator new(0x20uLL);
          __int128 v83 = v82;
          v82->__shared_owners_ = 0LL;
          std::string::size_type v84 = (unint64_t *)&v82->__shared_owners_;
          v82->__vftable = (std::__shared_weak_count_vtbl *)off_100060F38;
          v82->__shared_weak_owners_ = 0LL;
          v82[1].__vftable = v81;
          do
            unint64_t v85 = __ldxr(v84);
          while (__stxr(v85 + 1, v84));
          unint64_t v86 = (unint64_t *)&v82->__shared_weak_owners_;
          do
            unint64_t v87 = __ldxr(v86);
          while (__stxr(v87 + 1, v86));
          v81->~__shared_weak_count_0 = (void (__cdecl *)(std::__shared_weak_count *__hidden))v81;
          v81->__on_zero_shared = (void (__cdecl *)(std::__shared_count *__hidden))v82;
          do
            unint64_t v88 = __ldaxr(v84);
          while (__stlxr(v88 - 1, v84));
          if (!v88)
          {
            ((void (*)(std::__shared_weak_count *))v82->__on_zero_shared)(v82);
            std::__shared_weak_count::__release_weak(v83);
          }

          uint64_t v144 = v83;
          if (g_num_reg_entries)
          {
            unint64_t v89 = 0LL;
            unsigned int v90 = 1;
            do
            {
              uint64_t v91 = g_reg_entries + (v89 << 7);
              if (*(_DWORD *)(v91 + 8) == 1
                && !*(void *)(v91 + 64)
                && DNBThreadGetRegisterValueByID( v158,  v155,  1,  *(_DWORD *)(g_reg_entries + (v89 << 7) + 12),  v172))
              {
                __s[0].__r_.__value_.__r.__words[0] = v151;
                *(std::string::size_type *)((char *)__s[0].__r_.__value_.__r.__words + *(void *)(v151 - 24)) = v149;
                unint64_t v92 = (std::ios_base *)((char *)__s + *(void *)(__s[0].__r_.__value_.__r.__words[0] - 24));
                std::ios_base::init(v92, &__s[0].__r_.__value_.__r.__words[1]);
                v92[1].__vftable = 0LL;
                v92[1].__fmtflags_ = -1;
                std::streambuf::basic_streambuf(&__s[0].__r_.__value_.__r.__words[1]);
                __int128 v198 = 0u;
                __int128 v199 = 0u;
                int v200 = 16;
                *(_DWORD *)((char *)&__s[0].__r_.__value_.__r.__words[1]
                          + *(void *)(__s[0].__r_.__value_.__r.__words[0] - 24)) = *(_DWORD *)((_BYTE *)&__s[0].__r_.__value_.__r.__words[1]
                                                                                               + *(void *)(__s[0].__r_.__value_.__r.__words[0] - 24)) & 0xFFFFFFB5 | 2;
                std::ostream::operator<<(__s, *(unsigned int *)(g_reg_entries + (v89 << 7)));
                std::stringbuf::str(&v171, (const std::stringbuf *)&__s[0].__r_.__value_.__r.__words[1]);
                JSONGenerator::Dictionary::AddBytesAsHexASCIIString( (uint64_t)v81,  &v171,  v173,  *(unsigned int *)(g_reg_entries + (v89 << 7) + 36));
                __s[0].__r_.__value_.__r.__words[0] = v150;
                *(std::string::size_type *)((char *)__s[0].__r_.__value_.__r.__words + *(void *)(v150 - 24)) = v148;
                if (SBYTE7(v199) < 0) {
                  operator delete((void *)v198);
                }
                std::streambuf::~streambuf(&__s[0].__r_.__value_.__r.__words[1]);
                std::ios::~ios(v201);
                mach_vm_address_t v15 = (__int16 *)v147;
                __darwin_ct_rune_t v19 = (std::__shared_weak_count_vtbl *)v157;
              }

              unint64_t v89 = v90++;
            }

            while (g_num_reg_entries > v89);
          }

          char v170 = 9;
          __int128 v167 = v81;
          __int128 v168 = v144;
          strcpy((char *)v169, "registers");
          do
            unint64_t v93 = __ldxr(v84);
          while (__stxr(v93 + 1, v84));
          JSONGenerator::Dictionary::AddItem((uint64_t)v19, (uint64_t)v169, &v167);
          int v94 = v168;
          a2 = v146;
          size_t v7 = v145;
          __int128 v21 = v156;
          if (!v168) {
            goto LABEL_191;
          }
          unint64_t v95 = (unint64_t *)&v168->__shared_owners_;
          do
            unint64_t v96 = __ldaxr(v95);
          while (__stlxr(v96 - 1, v95));
          if (!v96)
          {
            ((void (*)(std::__shared_weak_count *))v94->__on_zero_shared)(v94);
            std::__shared_weak_count::__release_weak(v94);
            if ((v170 & 0x80000000) == 0)
            {
              do
LABEL_194:
                unint64_t v97 = __ldaxr(v84);
              while (__stlxr(v97 - 1, v84));
              uint64_t ThreadAtIndex = (void (__cdecl *)(std::__shared_weak_count *__hidden))v155;
              if (!v97)
              {
                ((void (*)(std::__shared_weak_count *))v144->__on_zero_shared)(v144);
                std::__shared_weak_count::__release_weak(v144);
              }

LABEL_197:
              *(_OWORD *)&__s[0].__r_.__value_.__r.__words[1] = 0uLL;
              __s[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&__s[0].__r_.__value_.__l.__size_;
              ReadStackMemory(v158, (uint64_t)ThreadAtIndex, (uint64_t **)__s, 0x100u);
              if (!__s[0].__r_.__value_.__l.__cap_)
              {
LABEL_254:
                std::__tree<std::__value_type<unsigned int,DNBArchPluginInfoTag>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,DNBArchPluginInfoTag>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,DNBArchPluginInfoTag>>>::destroy( (uint64_t)__s,  (void *)__s[0].__r_.__value_.__l.__size_);
                goto LABEL_255;
              }

              __int128 v98 = (std::__shared_weak_count_vtbl *)operator new(0x38uLL);
              LODWORD(v98->__get_deleter) = 2;
              v98->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))off_100060D90;
              v98->__on_zero_shared_weak = 0LL;
              v98[1].~__shared_weak_count = 0LL;
              v98[1].~__shared_weak_count_0 = 0LL;
              uint64_t v99 = (std::__shared_weak_count *)operator new(0x20uLL);
              std::string::size_type v100 = v99;
              v99->__shared_owners_ = 0LL;
              uint64_t v101 = (unint64_t *)&v99->__shared_owners_;
              v99->__vftable = (std::__shared_weak_count_vtbl *)off_100060F70;
              v99->__shared_weak_owners_ = 0LL;
              v99[1].__vftable = v98;
              do
                unint64_t v102 = __ldxr(v101);
              while (__stxr(v102 + 1, v101));
              int v103 = (unint64_t *)&v99->__shared_weak_owners_;
              do
                unint64_t v104 = __ldxr(v103);
              while (__stxr(v104 + 1, v103));
              v98->~__shared_weak_count_0 = (void (__cdecl *)(std::__shared_weak_count *__hidden))v98;
              v98->__on_zero_shared = (void (__cdecl *)(std::__shared_count *__hidden))v99;
              do
                unint64_t v105 = __ldaxr(v101);
              while (__stlxr(v105 - 1, v101));
              if (!v105)
              {
                ((void (*)(std::__shared_weak_count *))v99->__on_zero_shared)(v99);
                std::__shared_weak_count::__release_weak(v100);
              }

              std::string::size_type v106 = __s[0].__r_.__value_.__r.__words[0];
              if ((std::string::size_type *)__s[0].__r_.__value_.__l.__data_ == &__s[0].__r_.__value_.__r.__words[1])
              {
LABEL_207:
                char v163 = 6;
                strcpy((char *)v162, "memory");
                __int128 v160 = v98;
                __int128 v161 = v100;
                a2 = v146;
                do
                  unint64_t v107 = __ldxr(v101);
                while (__stxr(v107 + 1, v101));
                __darwin_ct_rune_t v19 = (std::__shared_weak_count_vtbl *)v157;
                JSONGenerator::Dictionary::AddItem(v157, (uint64_t)v162, &v160);
                unint64_t v108 = v161;
                size_t v7 = v145;
                if (!v161) {
                  goto LABEL_213;
                }
                unint64_t v109 = (unint64_t *)&v161->__shared_owners_;
                do
                  unint64_t v110 = __ldaxr(v109);
                while (__stlxr(v110 - 1, v109));
                if (!v110)
                {
                  ((void (*)(std::__shared_weak_count *))v108->__on_zero_shared)(v108);
                  std::__shared_weak_count::__release_weak(v108);
                  if ((v163 & 0x80000000) == 0)
                  {
                    do
LABEL_251:
                      unint64_t v130 = __ldaxr(v101);
                    while (__stlxr(v130 - 1, v101));
                    __int128 v21 = v156;
                    if (!v130)
                    {
                      ((void (*)(std::__shared_weak_count *))v100->__on_zero_shared)(v100);
                      std::__shared_weak_count::__release_weak(v100);
                    }

                    goto LABEL_254;
                  }
                }

                else
                {
LABEL_213:
                  if ((v163 & 0x80000000) == 0) {
                    goto LABEL_251;
                  }
                }

                operator delete(v162[0]);
                goto LABEL_251;
              }

              while (1)
              {
                uint64_t v111 = (std::__shared_weak_count_vtbl *)operator new(0x38uLL);
                LODWORD(v111->__get_deleter) = 7;
                v111->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))off_100060D18;
                v111[1].~__shared_weak_count = 0LL;
                v111[1].~__shared_weak_count_0 = 0LL;
                v111->__on_zero_shared_weak = 0LL;
                uint64_t v112 = (std::__shared_weak_count *)operator new(0x20uLL);
                unint64_t v113 = v112;
                v112->__shared_owners_ = 0LL;
                uint64_t v114 = (unint64_t *)&v112->__shared_owners_;
                v112->__vftable = (std::__shared_weak_count_vtbl *)off_100060F38;
                v112->__shared_weak_owners_ = 0LL;
                v112[1].__vftable = v111;
                do
                  unint64_t v115 = __ldxr(v114);
                while (__stxr(v115 + 1, v114));
                __int128 v116 = (unint64_t *)&v112->__shared_weak_owners_;
                do
                  unint64_t v117 = __ldxr(v116);
                while (__stxr(v117 + 1, v116));
                v111->~__shared_weak_count_0 = (void (__cdecl *)(std::__shared_weak_count *__hidden))v111;
                v111->__on_zero_shared = (void (__cdecl *)(std::__shared_count *__hidden))v112;
                do
                  unint64_t v118 = __ldaxr(v114);
                while (__stlxr(v118 - 1, v114));
                if (!v118)
                {
                  ((void (*)(std::__shared_weak_count *))v112->__on_zero_shared)(v112);
                  std::__shared_weak_count::__release_weak(v113);
                }

                v166.__r_.__value_.__s.__size_ = 7;
                strcpy((char *)&v166, "address");
                JSONGenerator::Dictionary::AddIntegerItem( (uint64_t)v111,  &v166,  *(void (__cdecl **)(std::__shared_weak_count *__hidden))(v106 + 32));
                v165.__r_.__value_.__s.__size_ = 5;
                strcpy((char *)&v165, "bytes");
                JSONGenerator::Dictionary::AddBytesAsHexASCIIString( (uint64_t)v111,  &v165,  (unsigned __int8 *)(v106 + 40),  *(void *)(v106 + 56));
                *(void *)&__int128 v164 = v111;
                *((void *)&v164 + 1) = v113;
                do
                  unint64_t v119 = __ldxr(v114);
                while (__stxr(v119 + 1, v114));
                __darwin_time_t v120 = (std::__shared_weak_count_vtbl **)v98[1].~__shared_weak_count;
                if ((char *)v120 >= (char *)v98[1].~__shared_weak_count_0)
                {
                  int v122 = (void (__cdecl *)(std::__shared_weak_count *__hidden))std::vector<std::shared_ptr<JSONGenerator::Object>>::__push_back_slow_path<std::shared_ptr<JSONGenerator::Object> const&>( (uint64_t)&v98->__on_zero_shared_weak,  &v164);
                }

                else
                {
                  *__darwin_time_t v120 = v111;
                  v120[1] = (std::__shared_weak_count_vtbl *)v113;
                  do
                    unint64_t v121 = __ldxr(v114);
                  while (__stxr(v121 + 1, v114));
                  int v122 = (void (__cdecl *)(std::__shared_weak_count *__hidden))(v120 + 2);
                }

                v98[1].~__shared_weak_count = v122;
                uint64_t v123 = (std::__shared_weak_count *)*((void *)&v164 + 1);
                if (*((void *)&v164 + 1))
                {
                  unsigned __int8 v124 = (unint64_t *)(*((void *)&v164 + 1) + 8LL);
                  do
                    unint64_t v125 = __ldaxr(v124);
                  while (__stlxr(v125 - 1, v124));
                  if (!v125)
                  {
                    ((void (*)(std::__shared_weak_count *))v123->__on_zero_shared)(v123);
                    std::__shared_weak_count::__release_weak(v123);
                  }
                }

                do
                  unint64_t v126 = __ldaxr(v114);
                while (__stlxr(v126 - 1, v114));
                if (v126)
                {
                  timeval v127 = *(std::string **)(v106 + 8);
                  if (v127) {
                    goto LABEL_245;
                  }
                }

                else
                {
                  ((void (*)(std::__shared_weak_count *))v113->__on_zero_shared)(v113);
                  std::__shared_weak_count::__release_weak(v113);
                  timeval v127 = *(std::string **)(v106 + 8);
                  if (v127)
                  {
                    do
                    {
LABEL_245:
                      uint64_t v128 = v127;
                      timeval v127 = (std::string *)v127->__r_.__value_.__r.__words[0];
                    }

                    while (v127);
                    goto LABEL_215;
                  }
                }

                do
                {
                  uint64_t v128 = *(std::string **)(v106 + 16);
                  BOOL v129 = v128->__r_.__value_.__r.__words[0] == v106;
                  std::string::size_type v106 = (std::string::size_type)v128;
                }

                while (!v129);
LABEL_215:
                std::string::size_type v106 = (std::string::size_type)v128;
                if (v128 == (std::string *)&__s[0].__r_.__value_.__r.__words[1]) {
                  goto LABEL_207;
                }
              }
            }
          }

          else
          {
LABEL_191:
            if ((v170 & 0x80000000) == 0) {
              goto LABEL_194;
            }
          }

          operator delete(v169[0]);
          goto LABEL_194;
        }
      }

      memset(__s, 0, 24);
      v172[0] = 0LL;
      __int128 v187 = 0LL;
      uint64_t v186 = -1LL;
      RNBRemote::DispatchQueueOffsets::GetThreadQueueInfo( (unsigned __int16 *)v15,  v158,  v189.dispatch_qaddr,  &v186,  (uint64_t)__s,  v172,  (uint64_t *)&v187);
      int v70 = (void (__cdecl *)(std::__shared_weak_count *__hidden))v186;
      if (v186) {
        goto LABEL_124;
      }
      std::string::size_type size = __s[0].__r_.__value_.__s.__size_;
      if ((__s[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
        std::string::size_type size = __s[0].__r_.__value_.__l.__size_;
      }
      if (size | (unint64_t)v187)
      {
LABEL_124:
        __int128 v72 = ThreadAtIndex;
        v184.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x20uLL);
        *(_OWORD *)&v184.__r_.__value_.__r.__words[1] = xmmword_100051EC0;
        strcpy(v184.__r_.__value_.__l.__data_, "associated_with_dispatch_queue");
        JSONGenerator::Dictionary::AddBooleanItem((uint64_t)v19, &v184, 1);
        if ((unint64_t)v70 - 1 > 0xFFFFFFFFFFFFFFFDLL
          || (v183.__r_.__value_.__s.__size_ = 16,
              strcpy((char *)&v183, "dispatch_queue_t"),
              int v73 = &v183,
              JSONGenerator::Dictionary::AddIntegerItem((uint64_t)v19, &v183, v70),
              ((char)v183.__r_.__value_.__s.__size_ & 0x80000000) == 0))
        {
LABEL_129:
          std::string::size_type v74 = __s[0].__r_.__value_.__s.__size_;
          int v75 = (char)__s[0].__r_.__value_.__s.__size_;
          if ((__s[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
            std::string::size_type v74 = __s[0].__r_.__value_.__l.__size_;
          }
          uint64_t ThreadAtIndex = v72;
          if (v74)
          {
            v182.__r_.__value_.__s.__size_ = 5;
            strcpy((char *)&v182, "qname");
            if ((char)__s[0].__r_.__value_.__s.__size_ < 0) {
              std::string::__init_copy_ctor_external( &v181,  __s[0].__r_.__value_.__l.__data_,  __s[0].__r_.__value_.__l.__size_);
            }
            else {
              std::string v181 = __s[0];
            }
            JSONGenerator::Dictionary::AddStringItem((uint64_t)v19, &v182, (uint64_t)&v181);
            if (((char)v181.__r_.__value_.__s.__size_ & 0x80000000) == 0)
            {
LABEL_151:
              operator delete(v182.__r_.__value_.__l.__data_);
              uint64_t v78 = v172[0];
              if (!v172[0]) {
                goto LABEL_158;
              }
              goto LABEL_143;
            }

            operator delete(v181.__r_.__value_.__l.__data_);
          }

LABEL_142:
          uint64_t v78 = v172[0];
          if (!v172[0]) {
            goto LABEL_158;
          }
LABEL_143:
          if (v78 == 1)
          {
            v180.__r_.__value_.__s.__size_ = 5;
            strcpy((char *)&v180, "qkind");
            char v179 = 6;
            strcpy((char *)v178, "serial");
            JSONGenerator::Dictionary::AddStringItem((uint64_t)v19, &v180, (uint64_t)v178);
            if (v179 < 0)
            {
              operator delete(v178[0]);
            }

            else if (((char)v180.__r_.__value_.__s.__size_ & 0x80000000) == 0)
            {
              goto LABEL_158;
            }

            size_t v79 = &v180;
          }

          else
          {
            char v177 = 5;
            strcpy(v176, "\nqkind");
            strcpy((char *)v175, "concurrent");
            JSONGenerator::Dictionary::AddStringItem((uint64_t)v19, (std::string *)&v176[1], (uint64_t)v175);
            if (v176[0] < 0)
            {
              operator delete(v175[0]);
              if ((v177 & 0x80000000) == 0) {
                goto LABEL_158;
              }
            }

            else if ((v177 & 0x80000000) == 0)
            {
              goto LABEL_158;
            }

            size_t v79 = (std::string *)&v176[1];
          }

          operator delete(v79->__r_.__value_.__l.__data_);
LABEL_158:
          if (!v187
            || (v174.__r_.__value_.__s.__size_ = 10,
                strcpy((char *)&v174, "qserialnum"),
                JSONGenerator::Dictionary::AddIntegerItem((uint64_t)v19, &v174, v187),
                ((char)v174.__r_.__value_.__s.__size_ & 0x80000000) == 0))
          {
            if ((v75 & 0x80000000) == 0) {
              goto LABEL_165;
            }
            goto LABEL_161;
          }

          operator delete(v174.__r_.__value_.__l.__data_);
          if (v75 < 0)
          {
LABEL_161:
            operator delete(__s[0].__r_.__value_.__l.__data_);
            goto LABEL_165;
          }

          goto LABEL_165;
        }
      }

      else
      {
        __int128 v72 = ThreadAtIndex;
        v185.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x20uLL);
        *(_OWORD *)&v185.__r_.__value_.__r.__words[1] = xmmword_100051EC0;
        strcpy(v185.__r_.__value_.__l.__data_, "associated_with_dispatch_queue");
        int v73 = &v185;
        JSONGenerator::Dictionary::AddBooleanItem((uint64_t)v19, &v185, 0);
      }

      operator delete(v73->__r_.__value_.__l.__data_);
      goto LABEL_129;
    }

    unint64_t v62 = ThreadAtIndex;
    v192.__r_.__value_.__s.__size_ = 4;
    strcpy((char *)&v192, "name");
    size_t v63 = strlen(Name);
    if (v63 >= 0x7FFFFFFFFFFFFFF8LL) {
      abort();
    }
    int16x8_t v64 = (void *)v63;
    if (v63 >= 0x17)
    {
      uint64_t v66 = (v63 & 0xFFFFFFFFFFFFFFF8LL) + 8;
      if ((v63 | 7) != 0x17) {
        uint64_t v66 = v63 | 7;
      }
      unint64_t v67 = v14;
      uint64_t v68 = v66 + 1;
      unint64_t v65 = (void **)operator new(v66 + 1);
      unint64_t v69 = v68 | 0x8000000000000000LL;
      unint64_t v14 = v67;
      __darwin_ct_rune_t v19 = (std::__shared_weak_count_vtbl *)v157;
      unint64_t v191 = v69;
      __dst[0] = v65;
      __dst[1] = v64;
    }

    else
    {
      HIBYTE(v191) = v63;
      unint64_t v65 = __dst;
      if (!v63) {
        goto LABEL_109;
      }
    }

    memmove(v65, v61, (size_t)v64);
LABEL_109:
    *((_BYTE *)v64 + (void)v65) = 0;
    JSONGenerator::Dictionary::AddStringItem((uint64_t)v19, &v192, (uint64_t)__dst);
    if (SHIBYTE(v191) < 0) {
      operator delete(__dst[0]);
    }
    __int128 v21 = v156;
    uint64_t ThreadAtIndex = v62;
    goto LABEL_113;
  }

LABEL_274:
  *a3 = v9;
  a3[1] = v7;
}

unint64_t ReadStackMemory(int a1, uint64_t a2, uint64_t **a3, unsigned int a4)
{
  unint64_t result = DNBThreadGetRegisterValueByID(a1, a2, -1, 2, v26);
  if ((_DWORD)result)
  {
    int v8 = v27;
    mach_vm_address_t v9 = v27 == 4 ? v28 : v28;
    if (v9)
    {
      int v10 = 0;
      std::string::size_type v11 = a3 + 1;
      do
      {
        if (++v10 > a4) {
          break;
        }
        unint64_t v13 = (2 * v8);
        unint64_t v30 = v13;
        unint64_t result = DNBProcessMemoryRead(a1, v9, v13, (char *)&v29);
        if (result != v13) {
          break;
        }
        unint64_t v14 = *v11;
        mach_vm_address_t v15 = a3 + 1;
        std::string v16 = a3 + 1;
        if (*v11)
        {
          std::locale v17 = a3 + 1;
          int v18 = *v11;
          do
          {
            mach_vm_address_t v19 = v18[4];
            BOOL v20 = v19 >= v9;
            if (v19 >= v9) {
              __int128 v21 = (uint64_t **)v18;
            }
            else {
              __int128 v21 = (uint64_t **)(v18 + 1);
            }
            if (v20) {
              std::locale v17 = (uint64_t **)v18;
            }
            int v18 = *v21;
          }

          while (*v21);
          while (1)
          {
            while (1)
            {
              std::string v16 = v14;
              mach_vm_address_t v22 = v14[4];
              if (v9 >= v22) {
                break;
              }
              unint64_t v14 = (uint64_t *)*v16;
              mach_vm_address_t v15 = (uint64_t **)v16;
              if (!*v16) {
                goto LABEL_31;
              }
            }

            if (v22 >= v9) {
              break;
            }
            unint64_t v14 = (uint64_t *)v16[1];
            if (!v14)
            {
              mach_vm_address_t v15 = (uint64_t **)(v16 + 1);
              goto LABEL_31;
            }
          }
        }

        else
        {
LABEL_31:
          unint64_t v23 = v16;
          std::string v16 = operator new(0x40uLL);
          v16[4] = v9;
          v16[5] = 0LL;
          v16[6] = 0LL;
          v16[7] = 0LL;
          void *v16 = 0LL;
          v16[1] = 0LL;
          v16[2] = v23;
          __int16 *v15 = v16;
          uint64_t v24 = (uint64_t *)**a3;
          unint64_t v25 = v16;
          if (v24)
          {
            *a3 = v24;
            unint64_t v25 = *v15;
          }

          unint64_t result = (unint64_t)std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>( a3[1],  v25);
          a3[2] = (uint64_t *)((char *)a3[2] + 1);
        }

        *(_OWORD *)(v16 + 5) = v29;
        mach_vm_address_t v12 = v29;
        v16[7] = v30;
        int v8 = v27;
        if (v27 == 4) {
          mach_vm_address_t v9 = v12;
        }
        else {
          mach_vm_address_t v9 = v12;
        }
      }

      while (v9);
    }
  }

  return result;
}

void std::vector<unsigned char>::reserve(uint64_t a1, size_t __sz)
{
  int v2 = *(_BYTE **)a1;
  if (*(void *)(a1 + 16) - *(void *)a1 < __sz)
  {
    if ((__sz & 0x8000000000000000LL) != 0) {
      abort();
    }
    int v5 = *(_BYTE **)(a1 + 8);
    uint64_t v6 = operator new(__sz);
    unint64_t v7 = v5 - v2;
    int v8 = &v6[v5 - v2];
    mach_vm_address_t v9 = v8;
    if (v5 == v2) {
      goto LABEL_21;
    }
    if (v7 < 8)
    {
      int v10 = &v6[v5 - v2];
      goto LABEL_18;
    }

    int v10 = &v6[v5 - v2];
    if ((unint64_t)(v2 - v6) >= 0x20)
    {
      if (v7 < 0x20)
      {
        unint64_t v11 = 0LL;
        goto LABEL_13;
      }

      unint64_t v11 = v7 & 0xFFFFFFFFFFFFFFE0LL;
      mach_vm_address_t v12 = (__int128 *)(v5 - 16);
      unint64_t v13 = &v6[v5 - 16 - v2];
      unint64_t v14 = v7 & 0xFFFFFFFFFFFFFFE0LL;
      do
      {
        __int128 v15 = *v12;
        *(v13 - 1) = *(v12 - 1);
        *unint64_t v13 = v15;
        v13 -= 2;
        v12 -= 2;
        v14 -= 32LL;
      }

      while (v14);
      if (v7 == v11) {
        goto LABEL_20;
      }
      if ((v7 & 0x18) != 0)
      {
LABEL_13:
        int v10 = &v8[-(v7 & 0xFFFFFFFFFFFFFFF8LL)];
        std::string v16 = &v5[-v11 - 8];
        int64_t v17 = v16 - v2;
        unint64_t v18 = v11 - (v7 & 0xFFFFFFFFFFFFFFF8LL);
        do
        {
          uint64_t v19 = *(void *)v16;
          v16 -= 8;
          *(void *)&v6[v17] = v19;
          v17 -= 8LL;
          v18 += 8LL;
        }

        while (v18);
        v5 -= v7 & 0xFFFFFFFFFFFFFFF8LL;
        if (v7 == (v7 & 0xFFFFFFFFFFFFFFF8LL)) {
          goto LABEL_20;
        }
        goto LABEL_18;
      }

      int v10 = &v8[-v11];
      v5 -= v11;
    }

char *RNBRemote::ExtractThreadIDFromThreadSuffix(RNBRemote *this, const char *__big)
{
  if (*((_BYTE *)this + 782))
  {
    if (__big)
    {
      unint64_t result = strstr(__big, "thread:");
      if (result) {
        return (char *)strtoul(result + 7, 0LL, 16);
      }
    }

    else
    {
      return 0LL;
    }
  }

  else
  {
    unint64_t result = (char *)*((void *)this + 68);
  }

  return result;
}

uint64_t GetProcessNameFrom_vAttach(char **a1, std::string *a2)
{
  int v2 = *a1;
  char v3 = **a1;
  if (!v3) {
    return 1LL;
  }
  while (1)
  {
    __str[0] = v3;
    __str[1] = v2[1];
    std::string __str[2] = 0;
    *__error() = 0;
    int v6 = strtoul(__str, 0LL, 16);
    if (*__error() && v6 == 0LL) {
      break;
    }
    std::string::push_back(a2, v6);
    int v2 = *a1 + 2;
    *a1 = v2;
    char v3 = *v2;
    if (!*v2) {
      return 1LL;
    }
  }

  return 0LL;
}

BOOL RNBRemoteShouldCancelCallback(void *a1)
{
  uint64_t v1 = g_remoteSP;
  int v2 = (std::__shared_weak_count *)qword_1000716A0;
  if (qword_1000716A0)
  {
    char v3 = (unint64_t *)(qword_1000716A0 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  if (v1)
  {
    BOOL v5 = *(_DWORD *)(v1 + 472) == -1;
    if (!v2) {
      return v5;
    }
  }

  else
  {
    BOOL v5 = 1LL;
    if (!v2) {
      return v5;
    }
  }

  p_shared_owners = (unint64_t *)&v2->__shared_owners_;
  do
    unint64_t v7 = __ldaxr(p_shared_owners);
  while (__stlxr(v7 - 1, p_shared_owners));
  if (!v7)
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }

  return v5;
}

std::string *DNBError::SetErrorString(std::string *this, const char *a2)
{
  if (a2 && *a2) {
    return std::string::assign((std::string *)&this->__r_.__value_.__r.__words[1], a2);
  }
  if (this[1].__r_.__value_.__s.__data_[7] < 0)
  {
    *(_BYTE *)this->__r_.__value_.__l.__size_ = 0;
    this->__r_.__value_.__l.__cap_ = 0LL;
  }

  else
  {
    this->__r_.__value_.__s.__data_[8] = 0;
    this[1].__r_.__value_.__s.__data_[7] = 0;
  }

  return this;
}

BOOL process_does_not_exist(int a1)
{
  int v10 = 0LL;
  unint64_t v11 = 0LL;
  uint64_t v12 = 0LL;
  DNBGetAllInfos(&v10);
  if (v11 == v10)
  {
    BOOL v4 = 1LL;
    if (!v10) {
      return v4;
    }
  }

  else
  {
    unint64_t v2 = (v11 - v10) / 648;
    if (v2 <= 1) {
      uint64_t v3 = 1LL;
    }
    else {
      uint64_t v3 = (v11 - v10) / 648;
    }
    if (*((_DWORD *)v10 + 10) == a1)
    {
      BOOL v4 = 0LL;
    }

    else
    {
      unint64_t v5 = 0LL;
      int v6 = v10 + 688;
      uint64_t v7 = v3 - 1;
      while (v7 != v5)
      {
        int v8 = *(_DWORD *)v6;
        v6 += 648;
        ++v5;
        if (v8 == a1)
        {
          BOOL v4 = v5 >= v2;
          goto LABEL_14;
        }
      }

      BOOL v4 = 1LL;
    }
  }

BOOL process_is_already_being_debugged(int a1)
{
  BOOL result = 0;
  if (DNBProcessIsBeingDebugged(a1))
  {
    int v2 = DNBGetParentProcessID(a1);
    if (v2 != getpid()) {
      return 1;
    }
  }

  return result;
}

uint64_t attach_failed_due_to_uid_mismatch(int a1, unsigned int *a2, unsigned int *a3)
{
  *(void *)int v8 = 0xE00000001LL;
  int v9 = 1;
  int v10 = a1;
  size_t v7 = 648LL;
  if (sysctl(v8, 4u, v11, &v7, 0LL, 0LL)) {
    return 0LL;
  }
  uint64_t result = geteuid();
  *a2 = result;
  if ((_DWORD)result)
  {
    unsigned int v6 = v12;
    *a3 = v12;
    return *a2 != v6;
  }

  return result;
}

void *XMLElementStart(uint64_t *a1, int a2, const char *a3, char a4)
{
  if (a2)
  {
    uint64_t v8 = *a1;
    int v9 = (char *)a1 + *(void *)(*a1 - 24);
    if (*((_DWORD *)v9 + 36) == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
      int v10 = std::locale::use_facet(&v17, &std::ctype<char>::id);
      ((void (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32LL);
      std::locale::~locale(&v17);
      uint64_t v8 = *a1;
    }

    *((_DWORD *)v9 + 36) = 32;
    *(uint64_t *)((char *)a1 + *(void *)(v8 - 24) + 24) = a2;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)&unk_1000528BD, 0LL);
  }

  LOBYTE(v17.__locale_) = 60;
  unint64_t v11 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)&v17, 1LL);
  size_t v12 = strlen(a3);
  uint64_t result = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v11, (uint64_t)a3, v12);
  if ((a4 & 1) == 0)
  {
    LOBYTE(v17.__locale_) = 62;
    unint64_t v14 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)&v17, 1LL);
    std::ios_base::getloc((const std::ios_base *)((char *)v14 + *(void *)(*v14 - 24LL)));
    __int128 v15 = std::locale::use_facet(&v17, &std::ctype<char>::id);
    uint64_t v16 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v15->__vftable[2].~facet_0)(v15, 10LL);
    std::locale::~locale(&v17);
    std::ostream::put(v14, v16);
    return (void *)std::ostream::flush(v14);
  }

  return result;
}

uint64_t XMLElementEnd(uint64_t *a1, int a2, const char *a3)
{
  if (a2)
  {
    uint64_t v6 = *a1;
    size_t v7 = (char *)a1 + *(void *)(*a1 - 24);
    if (*((_DWORD *)v7 + 36) == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
      uint64_t v8 = std::locale::use_facet(&v17, &std::ctype<char>::id);
      ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 32LL);
      std::locale::~locale(&v17);
      uint64_t v6 = *a1;
    }

    *((_DWORD *)v7 + 36) = 32;
    *(uint64_t *)((char *)a1 + *(void *)(v6 - 24) + 24) = a2;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)&unk_1000528BD, 0LL);
  }

  LOBYTE(v17.__locale_) = 60;
  int v9 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)&v17, 1LL);
  LOBYTE(v17.__locale_) = 47;
  int v10 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v9, (uint64_t)&v17, 1LL);
  size_t v11 = strlen(a3);
  size_t v12 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v10, (uint64_t)a3, v11);
  LOBYTE(v17.__locale_) = 62;
  unint64_t v13 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v12, (uint64_t)&v17, 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v13 + *(void *)(*v13 - 24LL)));
  unint64_t v14 = std::locale::use_facet(&v17, &std::ctype<char>::id);
  uint64_t v15 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v14->__vftable[2].~facet_0)(v14, 10LL);
  std::locale::~locale(&v17);
  std::ostream::put(v13, v15);
  return std::ostream::flush(v13);
}

uint64_t XMLAttributeString(uint64_t result, const char *a2, char *__s1, char *__s2)
{
  if (__s1)
  {
    uint64_t v6 = (void *)result;
    if (!__s2 || (uint64_t result = strcmp(__s1, __s2), (_DWORD)result))
    {
      char v13 = 32;
      size_t v7 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v6, (uint64_t)&v13, 1LL);
      size_t v8 = strlen(a2);
      int v9 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v7, (uint64_t)a2, v8);
      int v10 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v9, (uint64_t)"=", 2LL);
      size_t v11 = strlen(__s1);
      size_t v12 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v10, (uint64_t)__s1, v11);
      return (uint64_t)std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v12, (uint64_t)"", 1LL);
    }
  }

  return result;
}

void *XMLAttributeUnsignedDecimal(void *a1, const char *a2, uint64_t a3)
{
  char v14 = 32;
  unint64_t v5 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)&v14, 1LL);
  size_t v6 = strlen(a2);
  size_t v7 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v5, (uint64_t)a2, v6);
  size_t v8 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v7, (uint64_t)"=", 2LL);
  uint64_t v9 = *v8;
  *(_DWORD *)((char *)v8 + *(void *)(*v8 - 24) + 8) = *(_DWORD *)((_BYTE *)v8 + *(void *)(*v8 - 24) + 8) & 0xFFFFFFB5 | 2;
  int v10 = (const std::ios_base *)((char *)v8 + *(void *)(v9 - 24));
  if (v10[1].__fmtflags_ == -1)
  {
    std::ios_base::getloc(v10);
    size_t v11 = std::locale::use_facet(&v15, &std::ctype<char>::id);
    ((void (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 32LL);
    std::locale::~locale(&v15);
  }

  v10[1].__fmtflags_ = 32;
  size_t v12 = (void *)std::ostream::operator<<(v8, a3);
  return std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v12, (uint64_t)"", 1LL);
}

uint64_t GenerateTargetXMLRegister(uint64_t *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v8 = *(unsigned __int16 *)(a5 + 32);
  if (v8 == 4)
  {
    int v10 = "vector";
    if (*(_DWORD *)(a5 + 8)) {
      uint64_t v9 = "vector";
    }
    else {
      uint64_t v9 = "general";
    }
  }

  else if (v8 == 3)
  {
    if (*(_DWORD *)(a5 + 8)) {
      uint64_t v9 = "float";
    }
    else {
      uint64_t v9 = "general";
    }
    int v10 = "ieee754";
  }

  else
  {
    uint64_t v9 = "general";
    if (v8 == 2) {
      int v10 = "sint";
    }
    else {
      int v10 = "uint";
    }
  }

  unsigned int v11 = *(unsigned __int16 *)(a5 + 34) - 1;
  if (v11 > 0xB)
  {
    char v14 = "hex";
    char v13 = "int";
  }

  else
  {
    uint64_t v12 = (__int16)v11;
    char v13 = off_100060FD0[v12];
    char v14 = off_100061030[v12];
  }

  XMLElementStart(a1, 2, "reg", 1);
  XMLAttributeString((uint64_t)a1, "name", *(char **)(a5 + 16), 0LL);
  XMLAttributeUnsignedDecimal(a1, "regnum", a2);
  XMLAttributeUnsignedDecimal(a1, "offset", *(unsigned int *)(a5 + 4));
  XMLAttributeUnsignedDecimal(a1, "bitsize", (8 * *(_DWORD *)(a5 + 36)));
  LOBYTE(v55.__locale_) = 32;
  std::locale v15 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)&v55, 1LL);
  uint64_t v16 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v15, (uint64_t)"group", 5LL);
  std::locale v17 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v16, (uint64_t)"=", 2LL);
  size_t v18 = strlen(v9);
  uint64_t v19 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v17, (uint64_t)v9, v18);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)"", 1LL);
  XMLAttributeString((uint64_t)a1, "type", v13, "int");
  XMLAttributeString((uint64_t)a1, "altname", *(char **)(a5 + 24), 0LL);
  XMLAttributeString((uint64_t)a1, "encoding", v10, "uint");
  XMLAttributeString((uint64_t)a1, "format", v14, "hex");
  XMLAttributeUnsignedDecimal(a1, "group_id", *(unsigned int *)(a5 + 8));
  uint64_t v20 = *(unsigned int *)(a5 + 44);
  if ((_DWORD)v20 != -1) {
    XMLAttributeUnsignedDecimal(a1, "ehframe_regnum", v20);
  }
  uint64_t v21 = *(unsigned int *)(a5 + 48);
  if ((_DWORD)v21 != -1) {
    XMLAttributeUnsignedDecimal(a1, "dwarf_regnum", v21);
  }
  uint64_t v22 = *(int *)(a5 + 52);
  else {
    unint64_t v23 = off_100061090[v22];
  }
  XMLAttributeString((uint64_t)a1, "generic", v23, 0LL);
  if (*(void *)(a5 + 80) == *(void *)(a5 + 88))
  {
    uint64_t v36 = *(void *)(a5 + 104);
    uint64_t v37 = *(void *)(a5 + 112);
    if (v36 == v37) {
      goto LABEL_52;
    }
  }

  else
  {
    v55.__locale_ = v24;
    *(std::locale::__imp **)((char *)&v55.__locale_ + *((void *)v24 - 3)) = v25;
    unint64_t v26 = (std::ios_base *)((char *)&v55 + *((void *)v55.__locale_ - 3));
    std::ios_base::init(v26, &v56);
    v26[1].__vftable = 0LL;
    v26[1].__fmtflags_ = -1;
    std::streambuf::basic_streambuf(&v56);
    memset(&v56.__str_, 0, 32);
    v56.__mode_ = 16;
    locale = v55.__locale_;
    *(_DWORD *)((char *)&v55 + *((void *)v55.__locale_ - 3) + 8) = *(_DWORD *)((char *)&v55
                                                                               + *((void *)v55.__locale_ - 3)
                                                                               + 8) & 0xFFFFFFB5 | 2;
    uint64_t v28 = (const std::ios_base *)((char *)&v55 + *((void *)locale - 3));
    if (v28[1].__fmtflags_ == -1)
    {
      std::ios_base::getloc(v28);
      __int128 v29 = std::locale::use_facet((const std::locale *)&v54, &std::ctype<char>::id);
      ((void (*)(const std::locale::facet *, uint64_t))v29->__vftable[2].~facet_0)(v29, 32LL);
      std::locale::~locale((std::locale *)&v54);
    }

    v28[1].__fmtflags_ = 32;
    unint64_t v30 = *(unsigned int **)(a5 + 80);
    std::string::size_type v31 = *(unsigned int **)(a5 + 88);
    if (v30 != v31)
    {
      unsigned int v33 = *v30;
      unint64_t v32 = v30 + 1;
      std::ostream::operator<<(&v55, v33);
      while (v32 != v31)
      {
        unsigned int v34 = *v32++;
        v54.__r_.__value_.__s.__data_[0] = 44;
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v55, (uint64_t)&v54, 1LL);
        std::ostream::operator<<(&v55, v34);
      }
    }

    std::stringbuf::str(&v54, &v56);
    if ((v54.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      unint64_t v35 = &v54;
    }
    else {
      unint64_t v35 = (std::stringbuf::string_type *)v54.__r_.__value_.__r.__words[0];
    }
    XMLAttributeString((uint64_t)a1, "value_regnums", (char *)v35, 0LL);
    std::streambuf::~streambuf(&v56);
    std::ios::~ios(v57);
    uint64_t v36 = *(void *)(a5 + 104);
    uint64_t v37 = *(void *)(a5 + 112);
  }

  if (v36 != v37)
  {
    v55.__locale_ = v38;
    *(std::locale::__imp **)((char *)&v55.__locale_ + *((void *)v38 - 3)) = v39;
    uint64_t v40 = (std::ios_base *)((char *)&v55 + *((void *)v55.__locale_ - 3));
    std::ios_base::init(v40, &v56);
    v40[1].__vftable = 0LL;
    v40[1].__fmtflags_ = -1;
    std::streambuf::basic_streambuf(&v56);
    memset(&v56.__str_, 0, 32);
    v56.__mode_ = 16;
    uint64_t v41 = v55.__locale_;
    *(_DWORD *)((char *)&v55 + *((void *)v55.__locale_ - 3) + 8) = *(_DWORD *)((char *)&v55
                                                                               + *((void *)v55.__locale_ - 3)
                                                                               + 8) & 0xFFFFFFB5 | 2;
    unint64_t v42 = (const std::ios_base *)((char *)&v55 + *((void *)v41 - 3));
    if (v42[1].__fmtflags_ == -1)
    {
      std::ios_base::getloc(v42);
      unint64_t v43 = std::locale::use_facet((const std::locale *)&v54, &std::ctype<char>::id);
      ((void (*)(const std::locale::facet *, uint64_t))v43->__vftable[2].~facet_0)(v43, 32LL);
      std::locale::~locale((std::locale *)&v54);
    }

    v42[1].__fmtflags_ = 32;
    unint64_t v44 = *(unsigned int **)(a5 + 104);
    unint64_t v45 = *(unsigned int **)(a5 + 112);
    if (v44 != v45)
    {
      unsigned int v47 = *v44;
      unsigned int v46 = v44 + 1;
      std::ostream::operator<<(&v55, v47);
      while (v46 != v45)
      {
        unsigned int v48 = *v46++;
        v54.__r_.__value_.__s.__data_[0] = 44;
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v55, (uint64_t)&v54, 1LL);
        std::ostream::operator<<(&v55, v48);
      }
    }

    std::stringbuf::str(&v54, &v56);
    if ((v54.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      int32x4_t v49 = &v54;
    }
    else {
      int32x4_t v49 = (std::stringbuf::string_type *)v54.__r_.__value_.__r.__words[0];
    }
    XMLAttributeString((uint64_t)a1, "invalidate_regnums", (char *)v49, 0LL);
    std::streambuf::~streambuf(&v56);
    std::ios::~ios(v57);
  }

uint64_t GenerateTargetXMLRegisters(uint64_t *a1)
{
  unint64_t v31 = 0LL;
  uint64_t v2 = DNBGetRegisterSetInfo(&v31);
  uint64_t result = DNBGetRegisterCPUType();
  if (!(_DWORD)result) {
    return result;
  }
  int v4 = result;
  LOBYTE(v28) = 60;
  unint64_t v5 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a1, (uint64_t)&v28, 1LL);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v5, (uint64_t)"feature", 7LL);
  uint64_t v28 = v6;
  *(void (__cdecl ***)(std::ostringstream *__hidden))((char *)&v28 + (void)*(v6 - 3)) = v7;
  int v8 = (std::ios_base *)((char *)&v28 + (void)*(v28 - 3));
  std::ios_base::init(v8, &v29);
  v8[1].__vftable = 0LL;
  v8[1].__fmtflags_ = -1;
  std::streambuf::basic_streambuf(&v29);
  memset(&v29.__str_, 0, 32);
  v29.__mode_ = 16;
  uint64_t v9 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v28,  (uint64_t)"com.apple.debugserver.",  22LL);
  if (v4 <= 16777222)
  {
    if (v4 == 7)
    {
      int v10 = "i386";
      goto LABEL_14;
    }

    if (v4 == 12)
    {
      int v10 = "arm";
      goto LABEL_14;
    }

uint64_t UpdateTargetXML(void)
{
  size_t v11 = v0;
  *(void (__cdecl ***)(std::ostringstream *__hidden))((char *)&v11 + (void)*(v0 - 3)) = (void (__cdecl **)(std::ostringstream *__hidden))v1;
  uint64_t v2 = (std::ios_base *)((char *)&v11 + (void)*(v11 - 3));
  std::ios_base::init(v2, &v12);
  v2[1].__vftable = 0LL;
  v2[1].__fmtflags_ = -1;
  std::streambuf::basic_streambuf(&v12);
  memset(&v12.__str_, 0, 32);
  v12.__mode_ = 16;
  uint64_t v3 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( &v11,  (uint64_t)"<?xml version=1.0?>\n<target version=1.0>",  44LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v3 + *(void *)(*v3 - 24LL)));
  int v4 = std::locale::use_facet((const std::locale *)&v10, &std::ctype<char>::id);
  uint64_t v5 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v4->__vftable[2].~facet_0)(v4, 10LL);
  std::locale::~locale((std::locale *)&v10);
  std::ostream::put(v3, v5);
  std::ostream::flush(v3);
  GenerateTargetXMLRegisters((uint64_t *)&v11);
  size_t v6 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v11, (uint64_t)"</target>", 9LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v6 + *(void *)(*v6 - 24LL)));
  size_t v7 = std::locale::use_facet((const std::locale *)&v10, &std::ctype<char>::id);
  uint64_t v8 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v7->__vftable[2].~facet_0)(v7, 10LL);
  std::locale::~locale((std::locale *)&v10);
  std::ostream::put(v6, v8);
  std::ostream::flush(v6);
  std::stringbuf::str(&v10, &v12);
  if (g_target_xml[23] < 0) {
    operator delete(*(void **)g_target_xml);
  }
  *(std::stringbuf::string_type *)g_target_xml = v10;
  std::streambuf::~streambuf(&v12);
  return std::ios::~ios(&v13);
}

uint64_t get_integer_value_for_key_name_from_json(std::string::value_type *__s, const char *a2)
{
  v14.__r_.__value_.__s.__size_ = 1;
  LOWORD(v14.__r_.__value_.__l.__data_) = 34;
  std::string::append(&v14, __s);
  std::string::append(&v14, "");
  unsigned __int8 size = v14.__r_.__value_.__s.__size_;
  if ((char)v14.__r_.__value_.__s.__size_ < 0)
  {
    int v4 = strstr(a2, v14.__r_.__value_.__l.__data_);
    if (!v4)
    {
      unint64_t v12 = -1LL;
LABEL_24:
      operator delete(v14.__r_.__value_.__l.__data_);
      return v12;
    }

    std::string::size_type v5 = v14.__r_.__value_.__l.__size_;
LABEL_6:
    for (unint64_t i = &v4[v5 + 1]; ; ++i)
    {
      uint64_t v7 = *((unsigned __int8 *)i - 1);
      if (((1LL << v7) & 0x100002600LL) == 0) {
        break;
      }
    }

    if (v7 != 58)
    {
LABEL_16:
      unint64_t v12 = -1LL;
      if ((size & 0x80) == 0) {
        return v12;
      }
      goto LABEL_24;
    }

    while (1)
    {
      unsigned int v8 = *(unsigned __int8 *)i;
      BOOL v9 = v8 > 0x20;
      uint64_t v10 = (1LL << v8) & 0x100002600LL;
      if (v9 || v10 == 0) {
        break;
      }
      ++i;
    }

    *__error() = 0;
    unint64_t v12 = strtoul(i, 0LL, 10);
    if (*__error()) {
      unint64_t v12 = -1LL;
    }
    if ((v14.__r_.__value_.__s.__size_ & 0x80) == 0) {
      return v12;
    }
    goto LABEL_24;
  }

  int v4 = strstr(a2, (const char *)&v14);
  if (v4)
  {
    std::string::size_type v5 = size;
    goto LABEL_6;
  }

  return -1LL;
}

uint64_t get_BOOLean_value_for_key_name_from_json(std::string::value_type *__s, const char *a2, BOOL *a3)
{
  v18.__r_.__value_.__s.__size_ = 1;
  LOWORD(v18.__r_.__value_.__l.__data_) = 34;
  std::string::append(&v18, __s);
  std::string::append(&v18, "");
  std::string::size_type size = v18.__r_.__value_.__s.__size_;
  if ((char)v18.__r_.__value_.__s.__size_ < 0)
  {
    size_t v6 = strstr(a2, v18.__r_.__value_.__l.__data_);
    if (!v6)
    {
      uint64_t v14 = 0LL;
LABEL_25:
      operator delete(v18.__r_.__value_.__l.__data_);
      return v14;
    }

    std::string::size_type v7 = v18.__r_.__value_.__l.__size_;
  }

  else
  {
    size_t v6 = strstr(a2, (const char *)&v18);
    if (!v6) {
      return 0LL;
    }
    std::string::size_type v7 = size;
  }

  for (unint64_t i = &v6[v7 + 1]; ; ++i)
  {
    uint64_t v9 = *((unsigned __int8 *)i - 1);
    if (((1LL << v9) & 0x100002600LL) == 0) {
      break;
    }
  }

  if (v9 != 58)
  {
LABEL_16:
    uint64_t v14 = 0LL;
    goto LABEL_24;
  }

  while (1)
  {
    unsigned int v10 = *(unsigned __int8 *)i;
    BOOL v11 = v10 > 0x20;
    uint64_t v12 = (1LL << v10) & 0x100002600LL;
    if (v11 || v12 == 0) {
      break;
    }
    ++i;
  }

  if (!strncmp(i, "true", 4uLL))
  {
    BOOL v16 = 1;
  }

  else
  {
    int v15 = strncmp(i, "false", 5uLL);
    uint64_t v14 = 0LL;
    if (v15) {
      goto LABEL_24;
    }
    BOOL v16 = 0;
  }

  *a3 = v16;
  uint64_t v14 = 1LL;
LABEL_24:
  if ((size & 0x80) != 0) {
    goto LABEL_25;
  }
  return v14;
}

uint64_t get_array_of_ints_value_for_key_name_from_json( std::string::value_type *__s, const char *a2, uint64_t a3)
{
  v44.__r_.__value_.__s.__size_ = 1;
  LOWORD(v44.__r_.__value_.__l.__data_) = 34;
  std::string::append(&v44, __s);
  std::string::append(&v44, "");
  unsigned __int8 size = v44.__r_.__value_.__s.__size_;
  if ((char)v44.__r_.__value_.__s.__size_ < 0)
  {
    size_t v6 = strstr(a2, v44.__r_.__value_.__l.__data_);
    if (!v6) {
      goto LABEL_65;
    }
    std::string::size_type v7 = v44.__r_.__value_.__l.__size_;
  }

  else
  {
    size_t v6 = strstr(a2, (const char *)&v44);
    if (!v6) {
      return 0LL;
    }
    std::string::size_type v7 = size;
  }

  for (unint64_t i = &v6[v7 + 2]; ; ++i)
  {
    uint64_t v9 = *((unsigned __int8 *)i - 2);
    if (((1LL << v9) & 0x100002600LL) == 0)
    {
      if (v9 != 58) {
        break;
      }
      while (1)
      {
        unsigned int v10 = *((unsigned __int8 *)i - 1);
        if (v10 > 0x20 || ((1LL << v10) & 0x100002600LL) == 0) {
          break;
        }
        ++i;
      }

      if (v10 != 91) {
        break;
      }
      while (1)
      {
        uint64_t v12 = *(unsigned __int8 *)i;
        ++i;
      }

      if ((v12 & 0x80) == 0)
      {
        while ((_DefaultRuneLocale.__runetype[v12] & 0x400) != 0)
        {
          *__error() = 0;
          std::string __endptr = 0LL;
          unint64_t v15 = strtoul(i, &__endptr, 10);
          if (*__error()) {
            goto LABEL_65;
          }
          uint64_t v17 = *(unint64_t **)(a3 + 8);
          unint64_t v16 = *(void *)(a3 + 16);
          if ((unint64_t)v17 >= v16)
          {
            unsigned int v19 = *(unint64_t **)a3;
            uint64_t v20 = (uint64_t)v17 - *(void *)a3;
            uint64_t v21 = v20 >> 3;
            unint64_t v22 = (v20 >> 3) + 1;
            if (v22 >> 61) {
              abort();
            }
            uint64_t v23 = v16 - (void)v19;
            if (v23 >> 2 > v22) {
              unint64_t v22 = v23 >> 2;
            }
            unint64_t v42 = v22;
            if (v22)
            {
              if (v22 >> 61) {
                std::__throw_bad_array_new_length[abi:nn180100]();
              }
              uint64_t v24 = operator new(8 * v22);
            }

            else
            {
              uint64_t v24 = 0LL;
            }

            uint64_t v25 = (unint64_t *)&v24[8 * v21];
            *uint64_t v25 = v15;
            std::string v18 = v25 + 1;
            if (v17 != v19)
            {
              unint64_t v26 = (char *)v17 - (char *)v19 - 8;
              if (v26 < 0x58) {
                goto LABEL_75;
              }
              uint64_t v27 = (v26 >> 3) + 1;
              uint64_t v28 = 8 * (v27 & 0x3FFFFFFFFFFFFFFCLL);
              std::stringbuf v29 = &v17[v28 / 0xFFFFFFFFFFFFFFF8LL];
              uint64_t v25 = (unint64_t *)((char *)v25 - v28);
              unint64_t v30 = &v24[8 * v21 - 16];
              unint64_t v31 = v17 - 2;
              uint64_t v32 = v27 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                __int128 v33 = *(_OWORD *)v31;
                *(v30 - 1) = *((_OWORD *)v31 - 1);
                _OWORD *v30 = v33;
                v30 -= 2;
                v31 -= 4;
                v32 -= 4LL;
              }

              while (v32);
              uint64_t v17 = v29;
              if (v27 != (v27 & 0x3FFFFFFFFFFFFFFCLL))
              {
LABEL_75:
                do
                {
                  unint64_t v34 = *--v17;
                  *--uint64_t v25 = v34;
                }

                while (v17 != v19);
              }
            }

            *(void *)a3 = v25;
            *(void *)(a3 + 8) = v18;
            *(void *)(a3 + 16) = &v24[8 * v42];
            if (v19) {
              operator delete(v19);
            }
          }

          else
          {
            *uint64_t v17 = v15;
            std::string v18 = v17 + 1;
          }

          *(void *)(a3 + 8) = v18;
          unint64_t v35 = __endptr;
          if (__endptr == i || __endptr == 0LL) {
            goto LABEL_65;
          }
          unsigned int v37 = *__endptr;
          if (!*__endptr) {
            goto LABEL_65;
          }
          if (v37 <= 0x20)
          {
            do
            {
              if (((1LL << v37) & 0x100002600LL) == 0) {
                break;
              }
              unsigned int v38 = *++v35;
              unsigned int v37 = v38;
            }

            while (v38 <= 0x20);
          }

          if (v37 == 44) {
            unint64_t i = v35 + 1;
          }
          else {
            unint64_t i = v35;
          }
          while (1)
          {
            unsigned int v39 = *(unsigned __int8 *)i;
            if (v39 > 0x20 || ((1LL << v39) & 0x100002600LL) == 0) {
              break;
            }
            ++i;
          }

          if (v39 == 93) {
            break;
          }
          uint64_t v12 = *(unsigned __int8 *)i;
          uint64_t v14 = 1LL;
          if (*i < 0) {
            goto LABEL_66;
          }
        }
      }

      uint64_t v14 = 1LL;
      goto LABEL_67;
    }
  }

LABEL_65:
  uint64_t v14 = 0LL;
LABEL_66:
  if ((char)v44.__r_.__value_.__s.__size_ < 0) {
LABEL_67:
  }
    operator delete(v44.__r_.__value_.__l.__data_);
  return v14;
}

      std::__throw_bad_array_new_length[abi:nn180100]();
    }

void JSONGenerator::Dictionary::AddIntegerItem( uint64_t a1, std::string *a2, void (__cdecl *a3)(std::__shared_weak_count *__hidden this))
{
  else {
    std::string v18 = *a2;
  }
  std::string::size_type v5 = (std::__shared_weak_count_vtbl *)operator new(0x28uLL);
  LODWORD(v5->__get_deleter) = 3;
  v5->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))off_100060DD0;
  v5->__on_zero_shared_weak = a3;
  unint64_t v16 = v5;
  size_t v6 = (std::__shared_weak_count *)operator new(0x20uLL);
  std::string::size_type v7 = v6;
  v6->__shared_owners_ = 0LL;
  p_shared_owners = (unint64_t *)&v6->__shared_owners_;
  v6->__vftable = (std::__shared_weak_count_vtbl *)off_100060D58;
  v6->__shared_weak_owners_ = 0LL;
  v6[1].__vftable = v5;
  uint64_t v17 = v6;
  do
    unint64_t v9 = __ldxr(p_shared_owners);
  while (__stxr(v9 + 1, p_shared_owners));
  p_shared_weak_owners = (unint64_t *)&v6->__shared_weak_owners_;
  do
    unint64_t v11 = __ldxr(p_shared_weak_owners);
  while (__stxr(v11 + 1, p_shared_weak_owners));
  v5->~__shared_weak_count_0 = (void (__cdecl *)(std::__shared_weak_count *__hidden))v5;
  v5->__on_zero_shared = (void (__cdecl *)(std::__shared_count *__hidden))v6;
  do
    unint64_t v12 = __ldaxr(p_shared_owners);
  while (__stlxr(v12 - 1, p_shared_owners));
  if (!v12)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v7);
  }

  JSONGenerator::Dictionary::AddItem(a1, (uint64_t)&v18, &v16);
  char v13 = v17;
  if (!v17) {
    goto LABEL_16;
  }
  uint64_t v14 = (unint64_t *)&v17->__shared_owners_;
  do
    unint64_t v15 = __ldaxr(v14);
  while (__stlxr(v15 - 1, v14));
  if (v15)
  {
LABEL_16:
    goto LABEL_17;
  }

  ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
  std::__shared_weak_count::__release_weak(v13);
  if ((char)v18.__r_.__value_.__s.__size_ < 0) {
LABEL_17:
  }
    operator delete(v18.__r_.__value_.__l.__data_);
}

void JSONGenerator::Dictionary::AddItem(uint64_t a1, uint64_t a2, void *a3)
{
  else {
    std::string __p = *(std::string *)a2;
  }
  uint64_t v5 = a3[1];
  *(void *)&__int128 v15 = *a3;
  *((void *)&v15 + 1) = v5;
  if (v5)
  {
    size_t v6 = (unint64_t *)(v5 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  unint64_t v8 = *(void *)(a1 + 40);
  if (v8 < *(void *)(a1 + 48))
  {
    __int128 v9 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
    *(void *)(v8 + 16) = __p.__r_.__value_.__l.__cap_;
    *(_OWORD *)unint64_t v8 = v9;
    memset(&__p, 0, sizeof(__p));
    *(_OWORD *)(v8 + 24) = v15;
    __int128 v15 = 0uLL;
    *(void *)(a1 + 40) = v8 + 40;
    goto LABEL_15;
  }

  unsigned int v10 = std::vector<std::pair<std::string,std::shared_ptr<JSONGenerator::Object>>>::__push_back_slow_path<std::pair<std::string,std::shared_ptr<JSONGenerator::Object>>>( (void ***)(a1 + 32),  (uint64_t)&__p);
  unint64_t v11 = (std::__shared_weak_count *)*((void *)&v15 + 1);
  *(void *)(a1 + 40) = v10;
  if (!v11) {
    goto LABEL_14;
  }
  p_shared_owners = (unint64_t *)&v11->__shared_owners_;
  do
    unint64_t v13 = __ldaxr(p_shared_owners);
  while (__stlxr(v13 - 1, p_shared_owners));
  if (v13)
  {
LABEL_14:
    goto LABEL_15;
  }

  ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
  std::__shared_weak_count::__release_weak(v11);
  if ((char)__p.__r_.__value_.__s.__size_ < 0) {
LABEL_15:
  }
    operator delete(__p.__r_.__value_.__l.__data_);
}

void JSONGenerator::Dictionary::AddStringItem(uint64_t a1, std::string *a2, uint64_t a3)
{
  else {
    std::string v22 = *a2;
  }
  uint64_t v5 = (char *)operator new(0x38uLL);
  *((void *)v5 + 2) = 0LL;
  *((_DWORD *)v5 + 6) = 6;
  *(void *)uint64_t v5 = off_100060E10;
  *((void *)v5 + 1) = 0LL;
  size_t v6 = (std::string *)(v5 + 32);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
  }

  else
  {
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    *((void *)v5 + 6) = *(void *)(a3 + 16);
  }

  uint64_t v20 = v5;
  unint64_t v7 = (std::__shared_weak_count *)operator new(0x20uLL);
  v7->__shared_owners_ = 0LL;
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  v7->__vftable = (std::__shared_weak_count_vtbl *)off_100060E50;
  v7->__shared_weak_owners_ = 0LL;
  v7[1].__vftable = (std::__shared_weak_count_vtbl *)v5;
  uint64_t v21 = v7;
  __int128 v9 = (std::__shared_weak_count *)*((void *)v5 + 2);
  if (v9)
  {
    if (v9->__shared_owners_ != -1) {
      goto LABEL_20;
    }
    do
      unint64_t v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v7->__shared_weak_owners_;
    do
      unint64_t v12 = __ldxr(p_shared_weak_owners);
    while (__stxr(v12 + 1, p_shared_weak_owners));
    *((void *)v5 + 1) = v5;
    *((void *)v5 + 2) = v7;
    std::__shared_weak_count::__release_weak(v9);
  }

  else
  {
    do
      unint64_t v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
    uint64_t v14 = (unint64_t *)&v7->__shared_weak_owners_;
    do
      unint64_t v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
    *((void *)v5 + 1) = v5;
    *((void *)v5 + 2) = v7;
  }

  do
    unint64_t v16 = __ldaxr(p_shared_owners);
  while (__stlxr(v16 - 1, p_shared_owners));
  if (!v16)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }

void JSONGenerator::Dictionary::AddBooleanItem(uint64_t a1, std::string *a2, char a3)
{
  else {
    std::string v18 = *a2;
  }
  uint64_t v5 = operator new(0x20uLL);
  v5[6] = 5;
  *(void *)uint64_t v5 = off_100060E88;
  *((_BYTE *)v5 + 28) = a3;
  unint64_t v16 = v5;
  size_t v6 = (std::__shared_weak_count *)operator new(0x20uLL);
  unint64_t v7 = v6;
  v6->__shared_owners_ = 0LL;
  p_shared_owners = (unint64_t *)&v6->__shared_owners_;
  v6->__vftable = (std::__shared_weak_count_vtbl *)off_100060EC8;
  v6->__shared_weak_owners_ = 0LL;
  v6[1].__vftable = (std::__shared_weak_count_vtbl *)v5;
  uint64_t v17 = v6;
  do
    unint64_t v9 = __ldxr(p_shared_owners);
  while (__stxr(v9 + 1, p_shared_owners));
  p_shared_weak_owners = (unint64_t *)&v6->__shared_weak_owners_;
  do
    unint64_t v11 = __ldxr(p_shared_weak_owners);
  while (__stxr(v11 + 1, p_shared_weak_owners));
  *((void *)v5 + 1) = v5;
  *((void *)v5 + 2) = v6;
  do
    unint64_t v12 = __ldaxr(p_shared_owners);
  while (__stlxr(v12 - 1, p_shared_owners));
  if (!v12)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v7);
  }

  JSONGenerator::Dictionary::AddItem(a1, (uint64_t)&v18, &v16);
  unint64_t v13 = v17;
  if (!v17) {
    goto LABEL_16;
  }
  uint64_t v14 = (unint64_t *)&v17->__shared_owners_;
  do
    unint64_t v15 = __ldaxr(v14);
  while (__stlxr(v15 - 1, v14));
  if (v15)
  {
LABEL_16:
    goto LABEL_17;
  }

  ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
  std::__shared_weak_count::__release_weak(v13);
  if ((char)v18.__r_.__value_.__s.__size_ < 0) {
LABEL_17:
  }
    operator delete(v18.__r_.__value_.__l.__data_);
}

void JSONGenerator::Dictionary::AddBytesAsHexASCIIString( uint64_t a1, std::string *a2, unsigned __int8 *a3, uint64_t a4)
{
  if (a3)
  {
    uint64_t v5 = a4;
    if (a4)
    {
      size_t v6 = a3;
      int32x4_t v49 = v7;
      *(void (__cdecl ***)(std::ostringstream *__hidden))((char *)&v49 + (void)*(v7 - 3)) = v8;
      unint64_t v9 = (std::ios_base *)((char *)&v49 + (void)*(v49 - 3));
      std::ios_base::init(v9, &v50);
      v9[1].__vftable = 0LL;
      v9[1].__fmtflags_ = -1;
      std::streambuf::basic_streambuf(&v50);
      memset(&v50.__str_, 0, 32);
      v50.__mode_ = 16;
      do
      {
        unint64_t v11 = v49;
        unint64_t v12 = (char *)&v49 + (void)*(v49 - 3);
        if (*((_DWORD *)v12 + 36) == -1)
        {
          std::ios_base::getloc((const std::ios_base *)((char *)&v49 + (void)*(v49 - 3)));
          unint64_t v13 = std::locale::use_facet((const std::locale *)&v45, &std::ctype<char>::id);
          ((void (*)(const std::locale::facet *, uint64_t))v13->__vftable[2].~facet_0)(v13, 32LL);
          std::locale::~locale((std::locale *)&v45);
          unint64_t v11 = v49;
        }

        *((_DWORD *)v12 + 36) = 48;
        *(_DWORD *)((char *)&v50.__vftable + (void)*(v11 - 3)) = *(_DWORD *)((_BYTE *)&v50.__vftable
                                                                             + (void)*(v11 - 3)) & 0xFFFFFFB5 | 8;
        *(_DWORD *)((char *)&v50.__vftable + (void)*(v11 - 3)) = *(_DWORD *)((_BYTE *)&v50.__vftable
                                                                             + (void)*(v11 - 3)) & 0xFFFFFF4F | 0x80;
        *(std::streambuf::char_type **)((char *)&v50.__binp_ + (void)*(v11 - 3)) = (std::streambuf::char_type *)2;
        unsigned int v10 = *v6++;
        std::ostream::operator<<(&v49, v10);
        --v5;
      }

      while (v5);
      else {
        std::string v48 = *a2;
      }
      uint64_t v25 = (char *)operator new(0x38uLL);
      std::stringbuf::str(&v45, &v50);
      *((void *)v25 + 1) = 0LL;
      *((void *)v25 + 2) = 0LL;
      *((_DWORD *)v25 + 6) = 6;
      *(void *)uint64_t v25 = off_100060E10;
      unint64_t v26 = (std::string *)(v25 + 32);
      if ((char)v45.__r_.__value_.__s.__size_ < 0)
      {
        std::string::__init_copy_ctor_external(v26, v45.__r_.__value_.__l.__data_, v45.__r_.__value_.__l.__size_);
      }

      else
      {
        *(_OWORD *)&v26->__r_.__value_.__l.__data_ = *(_OWORD *)&v45.__r_.__value_.__l.__data_;
        *((void *)v25 + 6) = v45.__r_.__value_.__l.__cap_;
      }

      unsigned int v46 = v25;
      uint64_t v27 = (std::__shared_weak_count *)operator new(0x20uLL);
      v27->__shared_owners_ = 0LL;
      p_shared_owners = (unint64_t *)&v27->__shared_owners_;
      v27->__vftable = (std::__shared_weak_count_vtbl *)off_100060E50;
      v27->__shared_weak_owners_ = 0LL;
      v27[1].__vftable = (std::__shared_weak_count_vtbl *)v25;
      unsigned int v47 = v27;
      std::stringbuf v29 = (std::__shared_weak_count *)*((void *)v25 + 2);
      if (v29)
      {
        if (v29->__shared_owners_ != -1) {
          goto LABEL_43;
        }
        do
          unint64_t v30 = __ldxr(p_shared_owners);
        while (__stxr(v30 + 1, p_shared_owners));
        p_shared_weak_owners = (unint64_t *)&v27->__shared_weak_owners_;
        do
          unint64_t v32 = __ldxr(p_shared_weak_owners);
        while (__stxr(v32 + 1, p_shared_weak_owners));
        *((void *)v25 + 1) = v25;
        *((void *)v25 + 2) = v27;
        std::__shared_weak_count::__release_weak(v29);
      }

      else
      {
        do
          unint64_t v33 = __ldxr(p_shared_owners);
        while (__stxr(v33 + 1, p_shared_owners));
        unint64_t v34 = (unint64_t *)&v27->__shared_weak_owners_;
        do
          unint64_t v35 = __ldxr(v34);
        while (__stxr(v35 + 1, v34));
        *((void *)v25 + 1) = v25;
        *((void *)v25 + 2) = v27;
      }

      do
        unint64_t v36 = __ldaxr(p_shared_owners);
      while (__stlxr(v36 - 1, p_shared_owners));
      if (!v36)
      {
        ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
        std::__shared_weak_count::__release_weak(v27);
      }

LABEL_49:
          operator delete(v48.__r_.__value_.__l.__data_);
          goto LABEL_50;
        }
      }

      else
      {
LABEL_47:
      }

      operator delete(v45.__r_.__value_.__l.__data_);
      goto LABEL_49;
    }
  }

  else {
    std::string v44 = *a2;
  }
  uint64_t v14 = (std::__shared_weak_count_vtbl *)operator new(0x38uLL);
  LODWORD(v14->__get_deleter) = 6;
  v14->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))off_100060E10;
  v14[1].~__shared_weak_count = 0LL;
  v14[1].~__shared_weak_count_0 = 0LL;
  v14->__on_zero_shared_weak = 0LL;
  unint64_t v42 = v14;
  unint64_t v15 = (std::__shared_weak_count *)operator new(0x20uLL);
  unint64_t v16 = v15;
  v15->__shared_owners_ = 0LL;
  uint64_t v17 = (unint64_t *)&v15->__shared_owners_;
  v15->__vftable = (std::__shared_weak_count_vtbl *)off_100060E50;
  v15->__shared_weak_owners_ = 0LL;
  v15[1].__vftable = v14;
  unint64_t v43 = v15;
  do
    unint64_t v18 = __ldxr(v17);
  while (__stxr(v18 + 1, v17));
  unint64_t v19 = (unint64_t *)&v15->__shared_weak_owners_;
  do
    unint64_t v20 = __ldxr(v19);
  while (__stxr(v20 + 1, v19));
  v14->~__shared_weak_count_0 = (void (__cdecl *)(std::__shared_weak_count *__hidden))v14;
  v14->__on_zero_shared = (void (__cdecl *)(std::__shared_count *__hidden))v15;
  do
    unint64_t v21 = __ldaxr(v17);
  while (__stlxr(v21 - 1, v17));
  if (!v21)
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v16);
  }

  JSONGenerator::Dictionary::AddItem(a1, (uint64_t)&v44, &v42);
  std::string v22 = v43;
  if (!v43) {
    goto LABEL_24;
  }
  uint64_t v23 = (unint64_t *)&v43->__shared_owners_;
  do
    unint64_t v24 = __ldaxr(v23);
  while (__stlxr(v24 - 1, v23));
  if (!v24)
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }

  else
  {
LABEL_24:
  }

  operator delete(v44.__r_.__value_.__l.__data_);
}

uint64_t RNBRemote::Packet::Packet( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char *__s, const char *a8)
{
  *(_DWORD *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 16) = a4;
  *(void *)(a1 + 24) = a5;
  *(void *)(a1 + 32) = a6;
  size_t v11 = strlen(__s);
  if (v11 > 0x7FFFFFFFFFFFFFF7LL) {
LABEL_18:
  }
    abort();
  size_t v12 = v11;
  if (v11 >= 0x17)
  {
    uint64_t v14 = (v11 & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((v11 | 7) != 0x17) {
      uint64_t v14 = v11 | 7;
    }
    uint64_t v15 = v14 + 1;
    unint64_t v13 = operator new(v14 + 1);
    *(void *)(a1 + 48) = v12;
    *(void *)(a1 + 56) = v15 | 0x8000000000000000LL;
    *(void *)(a1 + 40) = v13;
    goto LABEL_8;
  }

  unint64_t v13 = (void *)(a1 + 40);
  *(_BYTE *)(a1 + 63) = v11;
  if (v11) {
LABEL_8:
  }
    memmove(v13, __s, v12);
  *((_BYTE *)v13 + v12) = 0;
  size_t v16 = strlen(a8);
  if (v16 > 0x7FFFFFFFFFFFFFF7LL) {
    goto LABEL_18;
  }
  size_t v17 = v16;
  if (v16 >= 0x17)
  {
    uint64_t v19 = (v16 & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((v16 | 7) != 0x17) {
      uint64_t v19 = v16 | 7;
    }
    uint64_t v20 = v19 + 1;
    unint64_t v18 = operator new(v19 + 1);
    *(void *)(a1 + 72) = v17;
    *(void *)(a1 + 80) = v20 | 0x8000000000000000LL;
    *(void *)(a1 + 64) = v18;
  }

  else
  {
    unint64_t v18 = (void *)(a1 + 64);
    *(_BYTE *)(a1 + 87) = v16;
    if (!v16) {
      goto LABEL_17;
    }
  }

  memmove(v18, a8, v17);
LABEL_17:
  *((_BYTE *)v18 + v17) = 0;
  return a1;
}

void DNBTimer::DNBTimer(DNBTimer *this, int a2)
{
  *(void *)this = 0LL;
  if (!a2) {
    goto LABEL_8;
  }
  uint64_t v3 = (PThreadMutex *)operator new(0x40uLL);
  PThreadMutex::PThreadMutex(v3, 2);
  int v4 = *(pthread_mutex_t **)this;
  *(void *)this = v5;
  if (!v4) {
    goto LABEL_7;
  }
  if (pthread_mutex_destroy(v4))
  {
    if (!pthread_mutex_unlock(v4)) {
      pthread_mutex_destroy(v4);
    }
  }

  operator delete(v4);
  uint64_t v3 = *(PThreadMutex **)this;
  if (*(void *)this)
  {
LABEL_7:
    pthread_mutex_lock((pthread_mutex_t *)v3);
    gettimeofday((timeval *)((char *)this + 8), 0LL);
    pthread_mutex_unlock((pthread_mutex_t *)v3);
  }

  else
  {
LABEL_8:
    gettimeofday((timeval *)((char *)this + 8), 0LL);
  }

void JSONGenerator::Dictionary::~Dictionary(JSONGenerator::Dictionary *this)
{
}

{
  void **v2;
  void **v3;
  void *v4;
  void **v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  *(void *)this = off_100060D18;
  uint64_t v2 = (void **)*((void *)this + 4);
  if (v2)
  {
    uint64_t v3 = (void **)*((void *)this + 5);
    int v4 = (void *)*((void *)this + 4);
    if (v3 != v2)
    {
      do
      {
        size_t v6 = (std::__shared_weak_count *)*(v3 - 1);
        if (v6)
        {
          p_shared_owners = (unint64_t *)&v6->__shared_owners_;
          do
            unint64_t v8 = __ldaxr(p_shared_owners);
          while (__stlxr(v8 - 1, p_shared_owners));
          if (!v8)
          {
            ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
            std::__shared_weak_count::__release_weak(v6);
          }
        }

        uint64_t v5 = v3 - 5;
        v3 -= 5;
      }

      while (v5 != v2);
      int v4 = (void *)*((void *)this + 4);
    }

    *((void *)this + 5) = v2;
    operator delete(v4);
  }

  unint64_t v9 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v9) {
    std::__shared_weak_count::__release_weak(v9);
  }
}

uint64_t JSONGenerator::Object::IsValid(JSONGenerator::Object *this)
{
  return 1LL;
}

uint64_t JSONGenerator::Object::Clear(uint64_t this)
{
  *(_DWORD *)(this + 24) = -1;
  return this;
}

void *JSONGenerator::Dictionary::Dump(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4 != *(void *)(a1 + 40))
  {
    uint64_t v5 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"", 1LL);
    size_t v6 = (const char *)v4;
    size_t v7 = strlen(v6);
    unint64_t v8 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v5, (uint64_t)v6, v7);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)":", 2LL);
    (*(void (**)(void, void *))(**(void **)(v4 + 24) + 32LL))(*(void *)(v4 + 24), a2);
    for (uint64_t i = v4 + 40; i != *(void *)(a1 + 40); i += 40LL)
    {
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)",", 1LL);
      size_t v12 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"", 1LL);
      unint64_t v13 = (const char *)i;
      size_t v10 = strlen(v13);
      size_t v11 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v12, (uint64_t)v13, v10);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v11, (uint64_t)":", 2LL);
      (*(void (**)(void, void *))(**(void **)(i + 24) + 32LL))(*(void *)(i + 24), a2);
    }
  }

  return std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"}", 1LL);
}

void *JSONGenerator::Dictionary::DumpBinaryEscaped(uint64_t a1, void *a2)
{
  uint64_t v4 = *(unsigned __int8 **)(a1 + 32);
  if (v4 != *(unsigned __int8 **)(a1 + 40))
  {
    char v5 = 0;
    do
    {
      if ((v5 & 1) != 0) {
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)",", 1LL);
      }
      size_t v6 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"", 1LL);
      memset(&v21, 0, sizeof(v21));
      int v7 = (char)v4[23];
      if (v7 >= 0) {
        uint64_t v8 = v4[23];
      }
      else {
        uint64_t v8 = *((void *)v4 + 1);
      }
      if (v7 >= 0) {
        unint64_t v9 = v4;
      }
      else {
        unint64_t v9 = *(unsigned __int8 **)v4;
      }
      if (v8)
      {
        do
        {
          unsigned int v14 = *v9++;
          unsigned int v13 = v14;
          uint64_t v15 = (1LL << v14) & 0x41800000000LL;
          BOOL v16 = v14 > 0x2A || v15 == 0;
          if (!v16 || v13 == 125)
          {
            std::string::push_back(&v21, 125);
            LOBYTE(v13) = v13 ^ 0x20;
          }

          std::string::push_back(&v21, v13);
          --v8;
        }

        while (v8);
        uint64_t size = v21.__r_.__value_.__s.__size_;
        std::string::size_type v10 = v21.__r_.__value_.__l.__size_;
        std::string::size_type v11 = v21.__r_.__value_.__r.__words[0];
      }

      else
      {
        std::string::size_type v10 = 0LL;
        std::string::size_type v11 = 0LL;
        uint64_t size = 0LL;
      }

      if ((size & 0x80u) == 0LL) {
        size_t v17 = &v21;
      }
      else {
        size_t v17 = (std::string *)v11;
      }
      if ((size & 0x80u) == 0LL) {
        uint64_t v18 = size;
      }
      else {
        uint64_t v18 = v10;
      }
      uint64_t v19 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v6, (uint64_t)v17, v18);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)":", 2LL);
      (*(void (**)(void, void *))(**((void **)v4 + 3) + 40LL))(*((void *)v4 + 3), a2);
      v4 += 40;
      char v5 = 1;
    }

    while (v4 != *(unsigned __int8 **)(a1 + 40));
  }

  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"}", 1LL);
  v21.__r_.__value_.__s.__data_[0] = 93;
  return std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)&v21, 1LL);
}

void std::__shared_ptr_pointer<JSONGenerator::Integer *,std::shared_ptr<JSONGenerator::Object>::__shared_ptr_default_delete<JSONGenerator::Object,JSONGenerator::Integer>,std::allocator<JSONGenerator::Integer>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

uint64_t std::__shared_ptr_pointer<JSONGenerator::Integer *,std::shared_ptr<JSONGenerator::Object>::__shared_ptr_default_delete<JSONGenerator::Object,JSONGenerator::Integer>,std::allocator<JSONGenerator::Integer>>::__on_zero_shared( uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

void JSONGenerator::Array::~Array(JSONGenerator::Array *this)
{
  *(void *)this = off_100060D90;
  uint64_t v2 = *((void *)this + 4);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 5);
    uint64_t v4 = (void *)*((void *)this + 4);
    if (v3 != v2)
    {
      do
      {
        char v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5)
        {
          p_shared_owners = (unint64_t *)&v5->__shared_owners_;
          do
            unint64_t v7 = __ldaxr(p_shared_owners);
          while (__stlxr(v7 - 1, p_shared_owners));
          if (!v7)
          {
            ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
            std::__shared_weak_count::__release_weak(v5);
          }
        }

        v3 -= 16LL;
      }

      while (v3 != v2);
      uint64_t v4 = (void *)*((void *)this + 4);
    }

    *((void *)this + 5) = v2;
    operator delete(v4);
  }

  uint64_t v8 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v8) {
    std::__shared_weak_count::__release_weak(v8);
  }
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  *(void *)this = off_100060D90;
  uint64_t v2 = *((void *)this + 4);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 5);
    uint64_t v4 = (void *)*((void *)this + 4);
    if (v3 != v2)
    {
      do
      {
        char v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5)
        {
          p_shared_owners = (unint64_t *)&v5->__shared_owners_;
          do
            unint64_t v7 = __ldaxr(p_shared_owners);
          while (__stlxr(v7 - 1, p_shared_owners));
          if (!v7)
          {
            ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
            std::__shared_weak_count::__release_weak(v5);
          }
        }

        v3 -= 16LL;
      }

      while (v3 != v2);
      uint64_t v4 = (void *)*((void *)this + 4);
    }

    *((void *)this + 5) = v2;
    operator delete(v4);
  }

  uint64_t v8 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v8) {
    std::__shared_weak_count::__release_weak(v8);
  }
  operator delete(this);
}

void *JSONGenerator::Array::Dump(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 40) - *(void *)(a1 + 32);
  if (v4)
  {
    uint64_t v5 = 0LL;
    uint64_t v6 = 0LL;
    unint64_t v7 = v4 >> 4;
    else {
      uint64_t v8 = v4 >> 4;
    }
    do
    {
      (*(void (**)(void, void *))(**(void **)(*(void *)(a1 + 32) + v5) + 32LL))( *(void *)(*(void *)(a1 + 32) + v5),  a2);
      if (++v6 < v7) {
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)",", 1LL);
      }
      v5 += 16LL;
    }

    while (v8 != v6);
  }

  return std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"]", 1LL);
}

void *JSONGenerator::Array::DumpBinaryEscaped(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 40) - *(void *)(a1 + 32);
  if (v4)
  {
    uint64_t v5 = 0LL;
    uint64_t v6 = 0LL;
    unint64_t v7 = v4 >> 4;
    else {
      uint64_t v8 = v4 >> 4;
    }
    do
    {
      (*(void (**)(void, void *))(**(void **)(*(void *)(a1 + 32) + v5) + 40LL))( *(void *)(*(void *)(a1 + 32) + v5),  a2);
      if (++v6 < v7) {
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)",", 1LL);
      }
      v5 += 16LL;
    }

    while (v8 != v6);
  }

  return std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"]", 1LL);
}

_OWORD *std::vector<std::shared_ptr<JSONGenerator::Object>>::__push_back_slow_path<std::shared_ptr<JSONGenerator::Object> const&>( uint64_t a1, __int128 *a2)
{
  uint64_t v2 = *(void **)a1;
  uint64_t v3 = *(void **)(a1 + 8);
  uint64_t v4 = ((uint64_t)v3 - *(void *)a1) >> 4;
  unint64_t v5 = v4 + 1;
  uint64_t v7 = *(void *)(a1 + 16) - (void)v2;
  if (v7 >> 3 > v5) {
    unint64_t v5 = v7 >> 3;
  }
  if (v5 >> 60) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v9 = 16 * v5;
  std::string::size_type v10 = (char *)operator new(16 * v5);
  std::string::size_type v11 = &v10[16 * v4];
  __int128 v12 = *a2;
  *(_OWORD *)std::string::size_type v11 = *a2;
  if (*((void *)&v12 + 1))
  {
    unsigned int v13 = (unint64_t *)(*((void *)&v12 + 1) + 8LL);
    do
      unint64_t v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
    uint64_t v2 = *(void **)a1;
    uint64_t v3 = *(void **)(a1 + 8);
  }

  uint64_t v15 = &v10[v9];
  BOOL v16 = v11 + 16;
  if (v3 == v2)
  {
    *(void *)a1 = v11;
    *(void *)(a1 + 8) = v16;
    *(void *)(a1 + 16) = v15;
  }

  else
  {
    do
    {
      __int128 v17 = *((_OWORD *)v3 - 1);
      v3 -= 2;
      *((_OWORD *)v11 - 1) = v17;
      v11 -= 16;
      *uint64_t v3 = 0LL;
      v3[1] = 0LL;
    }

    while (v3 != v2);
    uint64_t v2 = *(void **)a1;
    uint64_t v18 = *(void **)(a1 + 8);
    *(void *)a1 = v11;
    *(void *)(a1 + 8) = v16;
    *(void *)(a1 + 16) = v15;
    while (v18 != v2)
    {
      uint64_t v19 = (std::__shared_weak_count *)*(v18 - 1);
      if (v19)
      {
        p_shared_owners = (unint64_t *)&v19->__shared_owners_;
        do
          unint64_t v21 = __ldaxr(p_shared_owners);
        while (__stlxr(v21 - 1, p_shared_owners));
        if (!v21)
        {
          ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
          std::__shared_weak_count::__release_weak(v19);
        }
      }

      v18 -= 2;
    }
  }

  if (v2) {
    operator delete(v2);
  }
  return v16;
}

void JSONGenerator::Integer::~Integer(JSONGenerator::Integer *this)
{
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

{
  std::__shared_weak_count *v2;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  operator delete(this);
}

uint64_t JSONGenerator::Integer::Dump(uint64_t a1, uint64_t a2)
{
  return std::ostream::operator<<(a2, *(void *)(a1 + 32));
}

uint64_t JSONGenerator::Integer::DumpBinaryEscaped(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 32LL))(a1);
}

void **std::vector<std::pair<std::string,std::shared_ptr<JSONGenerator::Object>>>::__push_back_slow_path<std::pair<std::string,std::shared_ptr<JSONGenerator::Object>>>( void ***a1, uint64_t a2)
{
  unint64_t v2 = 0xCCCCCCCCCCCCCCCDLL * (a1[1] - *a1);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0x666666666666666LL) {
    abort();
  }
  if (0x999999999999999ALL * (a1[2] - *a1) > v3) {
    unint64_t v3 = 0x999999999999999ALL * (a1[2] - *a1);
  }
  if (0xCCCCCCCCCCCCCCCDLL * (a1[2] - *a1) >= 0x333333333333333LL) {
    unint64_t v5 = 0x666666666666666LL;
  }
  else {
    unint64_t v5 = v3;
  }
  if (v5 > 0x666666666666666LL) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v7 = 40 * v5;
  uint64_t v8 = (char *)operator new(40 * v5);
  uint64_t v9 = &v8[40 * v2];
  std::string::size_type v10 = (void **)&v8[v7];
  *(_OWORD *)uint64_t v9 = *(_OWORD *)a2;
  *((void *)v9 + 2) = *(void *)(a2 + 16);
  *(void *)a2 = 0LL;
  *(void *)(a2 + 8) = 0LL;
  *(_OWORD *)(v9 + 24) = *(_OWORD *)(a2 + 24);
  *(void *)(a2 + 24) = 0LL;
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 16) = 0LL;
  std::string::size_type v11 = (void **)(v9 + 40);
  __int128 v12 = *a1;
  unsigned int v13 = a1[1];
  if (v13 == *a1)
  {
    *a1 = (void **)v9;
    a1[1] = v11;
    a1[2] = v10;
  }

  else
  {
    do
    {
      __int128 v14 = *(_OWORD *)(v13 - 5);
      *((void *)v9 - 3) = *(v13 - 3);
      *(_OWORD *)(v9 - 40) = v14;
      *(v13 - 4) = 0LL;
      *(v13 - 3) = 0LL;
      *(v13 - 5) = 0LL;
      *((_OWORD *)v9 - 1) = *((_OWORD *)v13 - 1);
      v9 -= 40;
      *(v13 - 2) = 0LL;
      *(v13 - 1) = 0LL;
      v13 -= 5;
    }

    while (v13 != v12);
    unsigned int v13 = *a1;
    uint64_t v15 = a1[1];
    *a1 = (void **)v9;
    a1[1] = v11;
    a1[2] = v10;
    if (v15 != v13)
    {
      do
      {
        __int128 v17 = (std::__shared_weak_count *)*(v15 - 1);
        if (v17)
        {
          p_shared_owners = (unint64_t *)&v17->__shared_owners_;
          do
            unint64_t v19 = __ldaxr(p_shared_owners);
          while (__stlxr(v19 - 1, p_shared_owners));
          if (!v19)
          {
            ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
            std::__shared_weak_count::__release_weak(v17);
          }
        }

        BOOL v16 = v15 - 5;
        v15 -= 5;
      }

      while (v16 != v13);
    }
  }

  if (v13) {
    operator delete(v13);
  }
  return v11;
}

void JSONGenerator::String::~String(void **this)
{
  *this = off_100060E10;
  if (*((char *)this + 55) < 0)
  {
    operator delete(this[4]);
    unint64_t v2 = (std::__shared_weak_count *)this[2];
    if (!v2) {
      return;
    }
  }

  else
  {
    unint64_t v2 = (std::__shared_weak_count *)this[2];
    if (!v2) {
      return;
    }
  }

  std::__shared_weak_count::__release_weak(v2);
}

{
  std::__shared_weak_count *v2;
  *this = off_100060E10;
  if (*((char *)this + 55) < 0)
  {
    operator delete(this[4]);
    unint64_t v2 = (std::__shared_weak_count *)this[2];
    if (!v2) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }

  unint64_t v2 = (std::__shared_weak_count *)this[2];
  if (v2) {
LABEL_3:
  }
    std::__shared_weak_count::__release_weak(v2);
LABEL_4:
  operator delete(this);
}

void *JSONGenerator::String::Dump(uint64_t a1, void *a2)
{
  char v9 = 34;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)&v9, 1LL);
  if (*(char *)(a1 + 55) < 0)
  {
    uint64_t v4 = *(void *)(a1 + 40);
    if (!v4) {
      goto LABEL_11;
    }
  }

  else
  {
    uint64_t v4 = *(unsigned __int8 *)(a1 + 55);
    if (!*(_BYTE *)(a1 + 55)) {
      goto LABEL_11;
    }
  }

  uint64_t v5 = 0LL;
  do
  {
    uint64_t v6 = a1 + 32;
    int v7 = *(unsigned __int8 *)(v6 + v5);
    if (v7 == 34)
    {
      char v11 = 92;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)&v11, 1LL);
    }

    char v12 = v7;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)&v12, 1LL);
    ++v5;
  }

  while (v4 != v5);
LABEL_11:
  char v10 = 34;
  return std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)&v10, 1LL);
}

void *JSONGenerator::String::DumpBinaryEscaped(uint64_t a1, void *a2)
{
  char v10 = 34;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)&v10, 1LL);
  if ((*(char *)(a1 + 55) & 0x80000000) == 0)
  {
    uint64_t v4 = *(unsigned __int8 *)(a1 + 55);
    if (!*(_BYTE *)(a1 + 55)) {
      goto LABEL_17;
    }
    goto LABEL_5;
  }

  uint64_t v4 = *(void *)(a1 + 40);
  if (v4)
  {
LABEL_5:
    for (uint64_t i = 0LL; v4 != i; ++i)
    {
      uint64_t v7 = a1 + 32;
      unsigned int v8 = *(unsigned __int8 *)(v7 + i);
      if (v8 > 0x29)
      {
        if (v8 != 42 && v8 != 125) {
          goto LABEL_16;
        }
      }

      else if (v8 - 35 >= 2)
      {
        if (v8 == 34)
        {
          char v12 = 92;
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)&v12, 1LL);
        }

void std::__shared_ptr_pointer<JSONGenerator::String *,std::shared_ptr<JSONGenerator::Object>::__shared_ptr_default_delete<JSONGenerator::Object,JSONGenerator::String>,std::allocator<JSONGenerator::String>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

uint64_t std::__shared_ptr_pointer<JSONGenerator::String *,std::shared_ptr<JSONGenerator::Object>::__shared_ptr_default_delete<JSONGenerator::Object,JSONGenerator::String>,std::allocator<JSONGenerator::String>>::__on_zero_shared( uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

void JSONGenerator::Boolean::~Boolean(JSONGenerator::Boolean *this)
{
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

{
  std::__shared_weak_count *v2;
  unint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  operator delete(this);
}

void *JSONGenerator::Boolean::Dump(uint64_t a1, void *a2)
{
  if (*(_BYTE *)(a1 + 28)) {
    return std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"true", 4LL);
  }
  else {
    return std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"false", 5LL);
  }
}

uint64_t JSONGenerator::Boolean::DumpBinaryEscaped(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 32LL))(a1);
}

void std::__shared_ptr_pointer<JSONGenerator::Boolean *,std::shared_ptr<JSONGenerator::Object>::__shared_ptr_default_delete<JSONGenerator::Object,JSONGenerator::Boolean>,std::allocator<JSONGenerator::Boolean>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

uint64_t std::__shared_ptr_pointer<JSONGenerator::Boolean *,std::shared_ptr<JSONGenerator::Object>::__shared_ptr_default_delete<JSONGenerator::Object,JSONGenerator::Boolean>,std::allocator<JSONGenerator::Boolean>>::__on_zero_shared( uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

void *std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>( void *a1, uint64_t a2, uint64_t a3)
{
  if (v13[0])
  {
    uint64_t v6 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
    uint64_t v7 = *(void *)(v6 + 40);
    uint64_t v8 = a2 + a3;
    if ((*(_DWORD *)(v6 + 8) & 0xB0) == 0x20) {
      uint64_t v9 = v8;
    }
    else {
      uint64_t v9 = a2;
    }
    int v10 = *(_DWORD *)(v6 + 144);
    if (v10 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24LL)));
      char v11 = std::locale::use_facet(&v14, &std::ctype<char>::id);
      int v10 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 32LL);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v10;
    }

    if (!std::__pad_and_output[abi:nn180100]<char,std::char_traits<char>>(v7, a2, v9, v8, v6, (char)v10)) {
      std::ios_base::clear( (std::ios_base *)((char *)a1 + *(void *)(*a1 - 24LL)),  *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24LL) + 32) | 5);
    }
  }

  std::ostream::sentry::~sentry(v13);
  return a1;
}

uint64_t std::__pad_and_output[abi:nn180100]<char,std::char_traits<char>>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6 = a1;
  if (a1)
  {
    uint64_t v11 = *(void *)(a5 + 24);
    if (v11 <= a4 - a2) {
      size_t v12 = 0LL;
    }
    else {
      size_t v12 = v11 - (a4 - a2);
    }
    if ((uint64_t)v12 >= 1)
    {
      if (v12 >= 0x7FFFFFFFFFFFFFF8LL) {
        abort();
      }
      if (v12 >= 0x17)
      {
        uint64_t v14 = (v12 & 0xFFFFFFFFFFFFFFF8LL) + 8;
        if ((v12 | 7) != 0x17) {
          uint64_t v14 = v12 | 7;
        }
        uint64_t v15 = v14 + 1;
        char v13 = (void **)operator new(v14 + 1);
        __b[1] = (void *)v12;
        int64_t v22 = v15 | 0x8000000000000000LL;
        __b[0] = v13;
      }

      else
      {
        HIBYTE(v22) = v12;
        char v13 = __b;
      }

      memset(v13, __c, v12);
      *((_BYTE *)v13 + v12) = 0;
      if (v22 >= 0) {
        BOOL v16 = __b;
      }
      else {
        BOOL v16 = (void **)__b[0];
      }
      uint64_t v17 = (*(uint64_t (**)(uint64_t, void **, size_t))(*(void *)v6 + 96LL))(v6, v16, v12);
      uint64_t v18 = v17;
      if (SHIBYTE(v22) < 0)
      {
        operator delete(__b[0]);
        if (v18 != v12) {
          return 0LL;
        }
      }

      else if (v17 != v12)
      {
        return 0LL;
      }
    }

    uint64_t v19 = a4 - a3;
    if (v19 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 96LL))(v6, a3, v19) == v19)
    {
      *(void *)(a5 + 24) = 0LL;
      return v6;
    }

    return 0LL;
  }

  return v6;
}

void std::string::__init_copy_ctor_external( std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  uint64_t v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8LL) {
      abort();
    }
    std::string::size_type v6 = (__sz & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((__sz | 7) != 0x17) {
      std::string::size_type v6 = __sz | 7;
    }
    std::string::size_type v7 = v6 + 1;
    uint64_t v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__l.__cap_ = v7 | 0x8000000000000000LL;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    uint64_t v5 = v8;
  }

  else
  {
    this->__r_.__value_.__s.__size_ = __sz;
  }

  memmove(v5, __s, __sz + 1);
}

uint64_t std::deque<std::string>::~deque[abi:nn180100](uint64_t a1)
{
  unint64_t v2 = *(void ***)(a1 + 8);
  unint64_t v3 = *(void ***)(a1 + 16);
  if (v3 == v2)
  {
    uint64_t v4 = (void *)(a1 + 40);
    unint64_t v3 = *(void ***)(a1 + 8);
  }

  else
  {
    uint64_t v4 = (void *)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 32);
    std::string::size_type v6 = &v2[v5 / 0xAA];
    unint64_t v7 = (unint64_t)*v6;
    unint64_t v8 = (unint64_t)*v6 + 24 * (v5 % 0xAA);
    unint64_t v9 = (unint64_t)v2[(*(void *)(a1 + 40) + v5) / 0xAA] + 24 * ((*(void *)(a1 + 40) + v5) % 0xAA);
    if (v8 != v9)
    {
      do
      {
        if (*(char *)(v8 + 23) < 0)
        {
          operator delete(*(void **)v8);
          unint64_t v7 = (unint64_t)*v6;
        }

        v8 += 24LL;
        if (v8 - v7 == 4080)
        {
          unint64_t v10 = (unint64_t)v6[1];
          ++v6;
          unint64_t v7 = v10;
          unint64_t v8 = v10;
        }
      }

      while (v8 != v9);
      unint64_t v2 = *(void ***)(a1 + 8);
      unint64_t v3 = *(void ***)(a1 + 16);
    }
  }

  *uint64_t v4 = 0LL;
  unint64_t v11 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      unint64_t v3 = *(void ***)(a1 + 16);
      unint64_t v2 = (void **)(*(void *)(a1 + 8) + 8LL);
      *(void *)(a1 + 8) = v2;
      unint64_t v11 = (char *)v3 - (char *)v2;
    }

    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }

  unint64_t v12 = v11 >> 3;
  if (v12 == 1)
  {
    uint64_t v13 = 85LL;
    goto LABEL_17;
  }

  if (v12 == 2)
  {
    uint64_t v13 = 170LL;
LABEL_17:
    *(void *)(a1 + 32) = v13;
  }

  if (v2 != v3)
  {
    do
    {
      uint64_t v14 = *v2++;
      operator delete(v14);
    }

    while (v2 != v3);
    uint64_t v16 = *(void *)(a1 + 8);
    uint64_t v15 = *(void *)(a1 + 16);
    if (v15 != v16) {
      *(void *)(a1 + 16) = v15 + ((v16 - v15 + 7) & 0xFFFFFFFFFFFFFFF8LL);
    }
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

char *std::vector<RNBRemote::Packet>::__push_back_slow_path<RNBRemote::Packet>(void **a1, uint64_t a2)
{
  uint64_t v2 = 0x2E8BA2E8BA2E8BA3LL * (((_BYTE *)a1[1] - (_BYTE *)*a1) >> 3);
  unint64_t v3 = v2 + 1;
  if (0x5D1745D1745D1746LL * (((_BYTE *)a1[2] - (_BYTE *)*a1) >> 3) > v3) {
    unint64_t v3 = 0x5D1745D1745D1746LL * (((_BYTE *)a1[2] - (_BYTE *)*a1) >> 3);
  }
  else {
    unint64_t v6 = v3;
  }
  if (v6)
  {
    if (v6 > 0x2E8BA2E8BA2E8BALL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    unint64_t v7 = (char *)operator new(88 * v6);
  }

  else
  {
    unint64_t v7 = 0LL;
  }

  __int128 v8 = *(_OWORD *)(a2 + 16);
  unint64_t v9 = &v7[88 * v2];
  *(_OWORD *)unint64_t v9 = *(_OWORD *)a2;
  *((_OWORD *)v9 + 1) = v8;
  unint64_t v10 = &v7[88 * v6];
  *((void *)v9 + 4) = *(void *)(a2 + 32);
  *(_OWORD *)(v9 + 40) = *(_OWORD *)(a2 + 40);
  *((void *)v9 + 7) = *(void *)(a2 + 56);
  *(void *)(a2 + 40) = 0LL;
  *(void *)(a2 + 48) = 0LL;
  *((_OWORD *)v9 + 4) = *(_OWORD *)(a2 + 64);
  *((void *)v9 + 10) = *(void *)(a2 + 80);
  *(void *)(a2 + 56) = 0LL;
  *(void *)(a2 + 64) = 0LL;
  *(void *)(a2 + 72) = 0LL;
  *(void *)(a2 + 80) = 0LL;
  unint64_t v11 = v9 + 88;
  unint64_t v12 = (void **)*a1;
  uint64_t v13 = (void **)a1[1];
  if (v13 != *a1)
  {
    do
    {
      __int128 v14 = *(_OWORD *)(v13 - 11);
      __int128 v15 = *(_OWORD *)(v13 - 9);
      *((void *)v9 - 7) = *(v13 - 7);
      *(_OWORD *)(v9 - 72) = v15;
      *(_OWORD *)(v9 - 88) = v14;
      __int128 v16 = *((_OWORD *)v13 - 3);
      *((void *)v9 - 4) = *(v13 - 4);
      *((_OWORD *)v9 - 3) = v16;
      *(v13 - 5) = 0LL;
      *(v13 - 4) = 0LL;
      *(v13 - 6) = 0LL;
      __int128 v17 = *(_OWORD *)(v13 - 3);
      *((void *)v9 - 1) = *(v13 - 1);
      *(_OWORD *)(v9 - 24) = v17;
      v9 -= 88;
      *(v13 - 2) = 0LL;
      *(v13 - 1) = 0LL;
      *(v13 - 3) = 0LL;
      v13 -= 11;
    }

    while (v13 != v12);
    uint64_t v13 = (void **)*a1;
    uint64_t v18 = (void **)a1[1];
    *a1 = v9;
    a1[1] = v11;
    a1[2] = v10;
    while (1)
    {
      if (v18 == v13) {
        goto LABEL_22;
      }
      if (*((char *)v18 - 1) < 0)
      {
        operator delete(*(v18 - 3));
      }

      else if ((*((char *)v18 - 25) & 0x80000000) == 0)
      {
        goto LABEL_14;
      }

      operator delete(*(v18 - 6));
LABEL_14:
      v18 -= 11;
    }
  }

  *a1 = v9;
  a1[1] = v11;
  a1[2] = v10;
LABEL_22:
  if (v13) {
    operator delete(v13);
  }
  return v11;
}

void std::deque<std::string>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = v2 >= 0xAA;
  unint64_t v4 = v2 - 170;
  if (v3)
  {
    *(void *)(a1 + 32) = v4;
    unint64_t v6 = *(void **)(a1 + 8);
    unint64_t v5 = *(char **)(a1 + 16);
    unint64_t v7 = (char *)(v6 + 1);
    uint64_t v8 = *v6;
    *(void *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_57:
      *(void *)unint64_t v5 = v8;
      *(void *)(a1 + 16) += 8LL;
      return;
    }

    unint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v30 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v30 = 1LL;
      }
      if (!(v30 >> 61))
      {
        unint64_t v31 = v30 >> 2;
        uint64_t v32 = 8 * v30;
        unint64_t v33 = (char *)operator new(8 * v30);
        unint64_t v34 = &v33[8 * v31];
        unint64_t v35 = &v33[v32];
        int64_t v37 = v5 - v7;
        BOOL v36 = v5 == v7;
        unint64_t v5 = v34;
        if (!v36)
        {
          unint64_t v5 = &v34[v37 & 0xFFFFFFFFFFFFFFF8LL];
          unint64_t v38 = v37 - 8;
          if ((unint64_t)(v37 - 8) >= 0x38)
          {
            uint64_t v52 = &v33[8 * v31];
            unint64_t v39 = v52;
            if ((unint64_t)(v52 - v7) >= 0x20)
            {
              uint64_t v53 = (v38 >> 3) + 1;
              uint64_t v54 = 8 * (v53 & 0x3FFFFFFFFFFFFFFCLL);
              unint64_t v39 = &v34[v54];
              v7 += v54;
              std::locale v55 = (__int128 *)(v6 + 3);
              std::stringbuf v56 = v52 + 16;
              uint64_t v57 = v53 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                __int128 v58 = *v55;
                *(v56 - 1) = *(v55 - 1);
                *std::stringbuf v56 = v58;
                v55 += 2;
                v56 += 2;
                v57 -= 4LL;
              }

              while (v57);
              if (v53 == (v53 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_55;
              }
            }
          }

          else
          {
            unint64_t v39 = &v33[8 * v31];
          }

          do
          {
            uint64_t v59 = *(void *)v7;
            v7 += 8;
            *(void *)unint64_t v39 = v59;
            v39 += 8;
          }

          while (v39 != v5);
        }

        goto LABEL_55;
      }

LABEL_5:
    uint64_t v11 = v10 >> 3;
    if (v11 >= -1) {
      uint64_t v12 = v11 + 1;
    }
    else {
      uint64_t v12 = v11 + 2;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = -v13;
    __int128 v15 = &v7[-8 * v13];
    int64_t v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      unint64_t v7 = *(char **)(a1 + 8);
    }

    unint64_t v5 = &v15[v16];
    *(void *)(a1 + 8) = &v7[8 * v14];
    *(void *)(a1 + 16) = &v15[v16];
    goto LABEL_57;
  }

  uint64_t v18 = *(char **)(a1 + 8);
  __int128 v17 = *(char **)(a1 + 16);
  uint64_t v19 = v17 - v18;
  uint64_t v20 = (v17 - v18) >> 3;
  unint64_t v21 = *(char **)(a1 + 24);
  uint64_t v22 = (uint64_t)&v21[-*(void *)a1];
  if (v20 < (unint64_t)(v22 >> 3))
  {
    if (v21 != v17)
    {
      uint64_t v68 = (char *)operator new(0xFF0uLL);
      std::__split_buffer<std::string *>::push_back((char **)a1, &v68);
      return;
    }

    uint64_t v68 = (char *)operator new(0xFF0uLL);
    std::__split_buffer<std::string *>::push_front((void **)a1, &v68);
    uint64_t v40 = *(void **)(a1 + 8);
    unint64_t v5 = *(char **)(a1 + 16);
    unint64_t v7 = (char *)(v40 + 1);
    uint64_t v8 = *v40;
    *(void *)(a1 + 8) = v40 + 1;
    unint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v41 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v41 = 1LL;
      }
      if (!(v41 >> 61))
      {
        unint64_t v42 = v41 >> 2;
        uint64_t v43 = 8 * v41;
        unint64_t v33 = (char *)operator new(8 * v41);
        unint64_t v34 = &v33[8 * v42];
        unint64_t v35 = &v33[v43];
        int64_t v44 = v5 - v7;
        BOOL v36 = v5 == v7;
        unint64_t v5 = v34;
        if (!v36)
        {
          unint64_t v5 = &v34[v44 & 0xFFFFFFFFFFFFFFF8LL];
          unint64_t v45 = v44 - 8;
          if ((unint64_t)(v44 - 8) >= 0x38)
          {
            unint64_t v60 = &v33[8 * v42];
            unsigned int v46 = v60;
            if ((unint64_t)(v60 - v7) >= 0x20)
            {
              uint64_t v61 = (v45 >> 3) + 1;
              uint64_t v62 = 8 * (v61 & 0x3FFFFFFFFFFFFFFCLL);
              unsigned int v46 = &v34[v62];
              v7 += v62;
              size_t v63 = (__int128 *)(v40 + 3);
              int16x8_t v64 = v60 + 16;
              uint64_t v65 = v61 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                __int128 v66 = *v63;
                *(v64 - 1) = *(v63 - 1);
                _OWORD *v64 = v66;
                v63 += 2;
                v64 += 2;
                v65 -= 4LL;
              }

              while (v65);
              if (v61 == (v61 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_55;
              }
            }
          }

          else
          {
            unsigned int v46 = &v33[8 * v42];
          }

          do
          {
            uint64_t v67 = *(void *)v7;
            v7 += 8;
            *(void *)unsigned int v46 = v67;
            v46 += 8;
          }

          while (v46 != v5);
        }

        std::string::assign((std::string *)a1 + 1, a2);
        unint64_t v29 = (const char *)*a3;
        if (*a3)
        {
          unint64_t v30 = (const char **)(a3 + 1);
          do
          {
            unint64_t v33 = strlen(v29);
            if (v33 > 0x7FFFFFFFFFFFFFF7LL) {
              std::string::__throw_length_error[abi:ne180100]();
            }
            unint64_t v34 = v33;
            if (v33 >= 0x17)
            {
              BOOL v36 = (v33 & 0xFFFFFFFFFFFFFFF8LL) + 8;
              if ((v33 | 7) != 0x17) {
                BOOL v36 = v33 | 7;
              }
              int64_t v37 = v36 + 1;
              unint64_t v35 = (__int128 *)operator new(v36 + 1);
              *((void *)&__dst + 1) = v34;
              unint64_t v117 = v37 | 0x8000000000000000LL;
              *(void *)&timeval __dst = v35;
            }

            else
            {
              HIBYTE(v117) = v33;
              unint64_t v35 = &__dst;
              if (!v33) {
                goto LABEL_17;
              }
            }

            memmove(v35, v29, v34);
LABEL_17:
            *((_BYTE *)v35 + v34) = 0;
            unint64_t v38 = *((void *)a1 + 7);
            if (v38 < *((void *)a1 + 8))
            {
              unint64_t v31 = __dst;
              *(void *)(v38 + 16) = v117;
              *(_OWORD *)unint64_t v38 = v31;
              *((void *)a1 + 7) = v38 + 24;
            }

            else
            {
              unint64_t v39 = std::vector<std::string>::__push_back_slow_path<std::string>((void **)a1 + 6, (uint64_t)&__dst);
              uint64_t v40 = SHIBYTE(v117);
              *((void *)a1 + 7) = v39;
              if (v40 < 0) {
                operator delete((void *)__dst);
              }
            }

            uint64_t v32 = *v30++;
            unint64_t v29 = v32;
          }

          while (v32);
        }

        MachTask::StartExceptionThread((uint64_t)(a1 + 26), a13, a14);
        if (*(_DWORD *)a14)
        {
          if (!DNBError::AsString((DNBError *)a14)) {
            std::string::assign((std::string *)(a14 + 8), "unable to start the exception thread");
          }
          if (DNBLogEnabled()) {
            _DNBLog( 0LL,  (uint64_t)"Could not get inferior's Mach exception port, sending ptrace PT_KILL and exiting.",  v41,  v42,  v43,  v44,  v45,  v46,  (uint64_t)v104);
          }
          ptrace(8, *a1, 0LL, 0);
          a4 = 0LL;
          *a1 = 0;
          return a4;
        }

        if (DNBLogEnabledForAny(2)) {
          _DNBLogThreaded("MachProcess::%s()", "StartSTDIOThread");
        }
        pthread_create((pthread_t *)a1 + 56, 0LL, (void *(__cdecl *)(void *))MachProcess::STDIOThread, a1);
        if (a10 == 1)
        {
          MachProcess::SetState((uint64_t)a1, 2u);
          *__error() = 0;
          if (DNBLogEnabled())
          {
            uint64_t v62 = getpid();
            _DNBLog( 0LL,  (uint64_t)"[LaunchAttach] (%d) About to ptrace(PT_ATTACHEXC, %d)...",  v63,  v64,  v65,  v66,  v67,  v68,  v62);
          }

          unint64_t v69 = ptrace(14, *a1, 0LL, 0);
          int v70 = *__error();
          if (DNBLogEnabled())
          {
            uint64_t v71 = getpid();
            _DNBLog( 0LL,  (uint64_t)"[LaunchAttach] (%d) Completed ptrace(PT_ATTACHEXC, %d) == %d",  v72,  v73,  v74,  v75,  v76,  v77,  v71);
          }

          if (v69)
          {
            MachProcess::SetState((uint64_t)a1, 9u);
            v108[0] = v70;
            v108[1] = 2;
            unint64_t v110 = 0LL;
            uint64_t v111 = 0LL;
            unint64_t v109 = 0LL;
            if (DNBLogEnabledForAny(2))
            {
              uint64_t v78 = *a1;
              size_t v79 = (const char *)DNBError::AsString((DNBError *)v108);
              _DNBLogThreaded( "error: failed to attach to spawned pid %d (err = %i, errno = %i (%s))",  v78,  v69,  v70,  v79);
            }

            snprintf( (char *)&__dst,  0x400uLL,  "Failed to attach to pid %d, LaunchForDebug() unable to ptrace(PT_ATTACHEXC)",  *a1);
            if ((_BYTE)__dst)
            {
              std::string::assign((std::string *)(a14 + 8), (const std::string::value_type *)&__dst);
            }

            else if (*(char *)(a14 + 31) < 0)
            {
              **(_BYTE **)(a14 + 8) = 0;
              *(void *)(a14 + 16) = 0LL;
            }

            else
            {
              *(_BYTE *)(a14 + 8) = 0;
              *(_BYTE *)(a14 + 31) = 0;
            }

            if (SHIBYTE(v111) < 0) {
              operator delete(v109);
            }
            return (const char **)*a1;
          }

          a1[110] |= 1u;
          if (DNBLogEnabledForAny(2)) {
            _DNBLogThreaded("successfully spawned pid %d", *a1);
          }
        }

        *(void *)a14 = 0LL;
        if (*(char *)(a14 + 31) < 0)
        {
          **(_BYTE **)(a14 + 8) = 0;
          *(void *)(a14 + 16) = 0LL;
        }

        else
        {
          *(_BYTE *)(a14 + 8) = 0;
          *(_BYTE *)(a14 + 31) = 0;
        }

        return (const char **)*a1;
      }

      return a4;
    default:
      if (DNBLogEnabled()) {
        _DNBLog(0LL, (uint64_t)"Failed to launch: invalid launch flavor: %d", v56, v57, v58, v59, v60, v61, a10);
      }
      *(void *)a14 = 0xFFFFFFFFLL;
      a4 = 0LL;
      if (*(char *)(a14 + 31) < 0)
      {
        **(_BYTE **)(a14 + 8) = 0;
        *(void *)(a14 + 16) = 0LL;
      }

      else
      {
        *(_BYTE *)(a14 + 8) = 0;
        *(_BYTE *)(a14 + 31) = 0;
      }

      return a4;
  }

LABEL_55:
        *(void *)a1 = v33;
        *(void *)(a1 + 8) = v34;
        *(void *)(a1 + 16) = v5;
        *(void *)(a1 + 24) = v35;
        if (v9)
        {
          operator delete(v9);
          unint64_t v5 = *(char **)(a1 + 16);
        }

        goto LABEL_57;
      }

      goto LABEL_65;
    }

    goto LABEL_5;
  }

  uint64_t v23 = v22 >> 2;
  else {
    unint64_t v24 = v23;
  }
  uint64_t v72 = a1 + 24;
  if (v24 >> 61) {
    goto LABEL_65;
  }
  uint64_t v25 = (char *)operator new(8 * v24);
  unint64_t v26 = &v25[8 * v20];
  uint64_t v68 = v25;
  unint64_t v69 = v26;
  uint64_t v27 = &v25[8 * v24];
  uint64_t v71 = v27;
  uint64_t v28 = operator new(0xFF0uLL);
  if (v20 == v24)
  {
    if (v19 < 1)
    {
      if (v17 == v18) {
        unint64_t v47 = 1LL;
      }
      else {
        unint64_t v47 = v19 >> 2;
      }
      if (v47 >> 61) {
        goto LABEL_65;
      }
      std::string v48 = (char *)operator new(8 * v47);
      unint64_t v26 = &v48[8 * (v47 >> 2)];
      uint64_t v27 = &v48[8 * v47];
      uint64_t v68 = v48;
      unint64_t v69 = v26;
      uint64_t v71 = v27;
      operator delete(v25);
      uint64_t v18 = *(char **)(a1 + 8);
      __int128 v17 = *(char **)(a1 + 16);
      uint64_t v25 = v48;
    }

    else
    {
      unint64_t v29 = v20 + 2;
      if (v20 >= -1) {
        unint64_t v29 = v20 + 1;
      }
      v26 -= 8 * (v29 >> 1);
      unint64_t v69 = v26;
    }
  }

  *(void *)unint64_t v26 = v28;
  int32x4_t v49 = v26 + 8;
  int v70 = v26 + 8;
  if (v17 == v18)
  {
    __int128 v17 = v18;
  }

  else
  {
    do
    {
      v17 -= 8;
      std::__split_buffer<std::string *>::push_front((void **)&v68, v17);
    }

    while (v17 != *(char **)(a1 + 8));
    uint64_t v25 = v68;
    unint64_t v26 = v69;
    uint64_t v18 = *(char **)(a1 + 16);
    int32x4_t v49 = v70;
    uint64_t v27 = v71;
  }

  std::stringbuf v50 = *(char **)a1;
  *(void *)a1 = v25;
  *(void *)(a1 + 8) = v26;
  uint64_t v68 = v50;
  unint64_t v69 = v17;
  unint64_t v51 = *(char **)(a1 + 24);
  *(void *)(a1 + 16) = v49;
  *(void *)(a1 + 24) = v27;
  int v70 = v18;
  uint64_t v71 = v51;
  if (v18 != v17) {
    int v70 = &v18[(v17 - v18 + 7) & 0xFFFFFFFFFFFFFFF8LL];
  }
  if (v50) {
    operator delete(v50);
  }
}

void std::__split_buffer<std::string *>::push_back(char **a1, void *a2)
{
  unint64_t v4 = a1[2];
  if (v4 != a1[3]) {
    goto LABEL_22;
  }
  unint64_t v5 = *a1;
  unint64_t v6 = a1[1];
  if (v6 > *a1)
  {
    uint64_t v7 = (v6 - *a1) >> 3;
    if (v7 >= -1) {
      uint64_t v8 = v7 + 1;
    }
    else {
      uint64_t v8 = v7 + 2;
    }
    uint64_t v9 = v8 >> 1;
    uint64_t v10 = -v9;
    uint64_t v11 = &v6[-8 * v9];
    int64_t v12 = v4 - v6;
    if (v4 != v6)
    {
      memmove(&v6[-8 * v9], a1[1], v4 - v6);
      unint64_t v4 = a1[1];
    }

    uint64_t v13 = &v4[8 * v10];
    unint64_t v4 = &v11[v12];
    a1[1] = v13;
    a1[2] = &v11[v12];
    goto LABEL_22;
  }

  unint64_t v14 = (v4 - v5) >> 2;
  if (v4 == v5) {
    unint64_t v14 = 1LL;
  }
  if (v14 >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  unint64_t v15 = v14 >> 2;
  uint64_t v16 = 8 * v14;
  __int128 v17 = (char *)operator new(8 * v14);
  uint64_t v18 = &v17[8 * v15];
  int64_t v20 = v4 - v6;
  BOOL v19 = v4 == v6;
  unint64_t v4 = v18;
  if (!v19)
  {
    unint64_t v4 = &v18[v20 & 0xFFFFFFFFFFFFFFF8LL];
    unint64_t v21 = v20 - 8;
    if ((unint64_t)(v20 - 8) < 0x38)
    {
      uint64_t v22 = &v17[8 * v15];
      do
      {
LABEL_19:
        uint64_t v31 = *(void *)v6;
        v6 += 8;
        *(void *)uint64_t v22 = v31;
        v22 += 8;
      }

      while (v22 != v4);
      goto LABEL_20;
    }

    uint64_t v23 = &v17[8 * v15];
    uint64_t v22 = v23;
    uint64_t v24 = (v21 >> 3) + 1;
    uint64_t v25 = 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
    uint64_t v22 = &v18[v25];
    unint64_t v26 = &v6[v25];
    uint64_t v27 = (__int128 *)(v6 + 16);
    uint64_t v28 = v23 + 16;
    uint64_t v29 = v24 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      __int128 v30 = *v27;
      *(v28 - 1) = *(v27 - 1);
      *uint64_t v28 = v30;
      v27 += 2;
      v28 += 2;
      v29 -= 4LL;
    }

    while (v29);
    unint64_t v6 = v26;
    if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_19;
    }
  }

void std::__split_buffer<std::string *>::push_front(void **a1, void *a2)
{
  unint64_t v4 = (char *)a1[1];
  if (v4 == *a1)
  {
    uint64_t v7 = a1[2];
    unint64_t v6 = a1[3];
    if (v7 >= v6)
    {
      uint64_t v13 = v6 - v4;
      BOOL v12 = v13 == 0;
      unint64_t v14 = v13 >> 2;
      if (v12) {
        unint64_t v14 = 1LL;
      }
      if (v14 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      unint64_t v15 = (v14 + 3) >> 2;
      uint64_t v16 = 8 * v14;
      __int128 v17 = (char *)operator new(8 * v14);
      unint64_t v5 = &v17[8 * v15];
      uint64_t v18 = v5;
      uint64_t v19 = v7 - v4;
      if (v7 != v4)
      {
        uint64_t v18 = &v5[v19 & 0xFFFFFFFFFFFFFFF8LL];
        unint64_t v20 = v19 - 8;
        unint64_t v21 = &v17[8 * v15];
        uint64_t v22 = v4;
        if (v20 < 0x38) {
          goto LABEL_27;
        }
        uint64_t v23 = &v17[8 * v15];
        unint64_t v21 = v23;
        uint64_t v22 = v4;
        uint64_t v24 = (v20 >> 3) + 1;
        uint64_t v25 = 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        unint64_t v21 = &v5[v25];
        uint64_t v22 = &v4[v25];
        unint64_t v26 = (__int128 *)(v4 + 16);
        uint64_t v27 = v23 + 16;
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          __int128 v29 = *v26;
          *(v27 - 1) = *(v26 - 1);
          _OWORD *v27 = v29;
          v26 += 2;
          v27 += 2;
          v28 -= 4LL;
        }

        while (v28);
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_27:
          do
          {
            uint64_t v30 = *(void *)v22;
            v22 += 8;
            *(void *)unint64_t v21 = v30;
            v21 += 8;
          }

          while (v21 != v18);
        }
      }

      *a1 = v17;
      a1[1] = v5;
      a1[2] = v18;
      a1[3] = &v17[v16];
      if (v4)
      {
        operator delete(v4);
        unint64_t v5 = (char *)a1[1];
      }
    }

    else
    {
      uint64_t v8 = (v6 - v7) >> 3;
      if (v8 >= -1) {
        uint64_t v9 = v8 + 1;
      }
      else {
        uint64_t v9 = v8 + 2;
      }
      uint64_t v10 = v9 >> 1;
      uint64_t v11 = &v7[8 * (v9 >> 1)];
      unint64_t v5 = &v11[-(v7 - v4)];
      if (v7 != v4)
      {
        memmove(&v11[-(v7 - v4)], v4, v7 - v4);
        unint64_t v4 = (char *)a1[2];
      }

      a1[1] = v5;
      a1[2] = &v4[8 * v10];
    }
  }

  else
  {
    unint64_t v5 = (char *)a1[1];
  }

  *((void *)v5 - 1) = *a2;
  a1[1] = (char *)a1[1] - 8;
}

void std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::destroy( uint64_t a1, char *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::destroy( a1,  *(void *)a2);
    std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::destroy( a1,  *((void *)a2 + 1));
    if (a2[55] < 0) {
      operator delete(*((void **)a2 + 4));
    }
    operator delete(a2);
  }

uint64_t **std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>( uint64_t **a1, const void **a2, uint64_t a3, _OWORD **a4)
{
  uint64_t v7 = a1 + 1;
  unint64_t v6 = a1[1];
  if (v6)
  {
    int v8 = *((char *)a2 + 23);
    if (v8 >= 0) {
      size_t v9 = *((unsigned __int8 *)a2 + 23);
    }
    else {
      size_t v9 = (size_t)a2[1];
    }
    if (v8 >= 0) {
      uint64_t v10 = a2;
    }
    else {
      uint64_t v10 = *a2;
    }
    while (1)
    {
      while (1)
      {
        uint64_t v11 = (uint64_t **)v6;
        unint64_t v14 = (const void *)v6[4];
        BOOL v12 = v6 + 4;
        uint64_t v13 = v14;
        int v15 = *((char *)v12 + 23);
        if (v15 >= 0) {
          size_t v16 = *((unsigned __int8 *)v12 + 23);
        }
        else {
          size_t v16 = v12[1];
        }
        if (v15 >= 0) {
          __int128 v17 = v12;
        }
        else {
          __int128 v17 = v13;
        }
        if (v16 >= v9) {
          size_t v18 = v9;
        }
        else {
          size_t v18 = v16;
        }
        int v19 = memcmp(v10, v17, v18);
        BOOL v20 = v9 < v16;
        if (v19) {
          BOOL v20 = v19 < 0;
        }
        if (!v20) {
          break;
        }
        unint64_t v6 = *v11;
        uint64_t v7 = v11;
        if (!*v11) {
          goto LABEL_27;
        }
      }

      int v21 = memcmp(v17, v10, v18);
      BOOL v22 = v16 < v9;
      if (v21) {
        BOOL v22 = v21 < 0;
      }
      if (!v22) {
        break;
      }
      unint64_t v6 = v11[1];
      if (!v6)
      {
        uint64_t v7 = v11 + 1;
        goto LABEL_27;
      }
    }
  }

  else
  {
    uint64_t v11 = a1 + 1;
LABEL_27:
    uint64_t v23 = (uint64_t *)v11;
    uint64_t v11 = (uint64_t **)operator new(0x40uLL);
    uint64_t v24 = *a4;
    uint64_t v25 = (uint64_t *)*((void *)*a4 + 2);
    *((_OWORD *)v11 + 2) = **a4;
    v11[6] = v25;
    void *v24 = 0LL;
    v24[1] = 0LL;
    v24[2] = 0LL;
    *((_DWORD *)v11 + 14) = 0;
    *uint64_t v11 = 0LL;
    v11[1] = 0LL;
    v11[2] = v23;
    *uint64_t v7 = (uint64_t *)v11;
    unint64_t v26 = (uint64_t *)**a1;
    uint64_t v27 = (uint64_t *)v11;
    if (v26)
    {
      *a1 = v26;
      uint64_t v27 = *v7;
    }

    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], v27);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }

  return v11;
}

uint64_t std::vector<register_map_entry>::__push_back_slow_path<register_map_entry const&>( uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = (a1[1] - *a1) >> 7;
  unint64_t v3 = v2 + 1;
  uint64_t v6 = (uint64_t)(a1 + 2);
  uint64_t v7 = a1[2] - *a1;
  if (v7 >> 6 > v3) {
    unint64_t v3 = v7 >> 6;
  }
  else {
    unint64_t v8 = v3;
  }
  if (v8)
  {
    if (v8 >> 57) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    size_t v9 = (char *)operator new(v8 << 7);
  }

  else
  {
    size_t v9 = 0LL;
  }

  uint64_t v10 = (uint64_t)&v9[128 * v2];
  uint64_t v11 = &v9[128 * v8];
  std::allocator<register_map_entry>::construct[abi:nn180100]<register_map_entry,register_map_entry const&>(v6, v10, a2);
  uint64_t v12 = v10 + 128;
  uint64_t v13 = (char *)*a1;
  unint64_t v14 = (char *)a1[1];
  if (v14 == (char *)*a1)
  {
    *a1 = v10;
    a1[1] = v12;
    a1[2] = (uint64_t)v11;
  }

  else
  {
    do
    {
      *(_OWORD *)(v10 - 128) = *((_OWORD *)v14 - 8);
      __int128 v15 = *((_OWORD *)v14 - 7);
      __int128 v16 = *((_OWORD *)v14 - 6);
      __int128 v17 = *((_OWORD *)v14 - 4);
      *(_OWORD *)(v10 - 80) = *((_OWORD *)v14 - 5);
      *(_OWORD *)(v10 - 64) = v17;
      *(_OWORD *)(v10 - 112) = v15;
      *(_OWORD *)(v10 - 96) = v16;
      *(void *)(v10 - 40) = 0LL;
      *(void *)(v10 - 32) = 0LL;
      *(void *)(v10 - 48) = 0LL;
      *(_OWORD *)(v10 - 48) = *((_OWORD *)v14 - 3);
      *(void *)(v10 - 32) = *((void *)v14 - 4);
      *((void *)v14 - 6) = 0LL;
      *((void *)v14 - 5) = 0LL;
      *((void *)v14 - 4) = 0LL;
      *(void *)(v10 - 24) = 0LL;
      *(void *)(v10 - 16) = 0LL;
      *(void *)(v10 - 8) = 0LL;
      *(_OWORD *)(v10 - 24) = *(_OWORD *)(v14 - 24);
      *(void *)(v10 - 8) = *((void *)v14 - 1);
      v10 -= 128LL;
      *((void *)v14 - 3) = 0LL;
      *((void *)v14 - 2) = 0LL;
      *((void *)v14 - 1) = 0LL;
      v14 -= 128;
    }

    while (v14 != v13);
    unint64_t v14 = (char *)*a1;
    size_t v18 = (char *)a1[1];
    *a1 = v10;
    a1[1] = v12;
    a1[2] = (uint64_t)v11;
    while (v18 != v14)
    {
      int v19 = (void *)*((void *)v18 - 3);
      if (v19)
      {
        *((void *)v18 - 2) = v19;
        operator delete(v19);
      }

      BOOL v20 = (void *)*((void *)v18 - 6);
      if (v20)
      {
        *((void *)v18 - 5) = v20;
        operator delete(v20);
      }

      v18 -= 128;
    }
  }

  if (v14) {
    operator delete(v14);
  }
  return v12;
}

void std::allocator<register_map_entry>::construct[abi:nn180100]<register_map_entry,register_map_entry const&>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)a2 = *(_OWORD *)a3;
  __int128 v5 = *(_OWORD *)(a3 + 16);
  __int128 v6 = *(_OWORD *)(a3 + 32);
  __int128 v7 = *(_OWORD *)(a3 + 64);
  *(_OWORD *)(a2 + 48) = *(_OWORD *)(a3 + 48);
  *(_OWORD *)(a2 + 64) = v7;
  *(_OWORD *)(a2 + 16) = v5;
  *(_OWORD *)(a2 + 32) = v6;
  *(void *)(a2 + 88) = 0LL;
  *(void *)(a2 + 96) = 0LL;
  *(void *)(a2 + 80) = 0LL;
  size_t v9 = *(_BYTE **)(a3 + 80);
  unint64_t v8 = *(_BYTE **)(a3 + 88);
  int64_t v10 = v8 - v9;
  if (v8 != v9)
  {
    if (v10 < 0) {
      goto LABEL_8;
    }
    uint64_t v11 = (char *)operator new(v8 - v9);
    *(void *)(a2 + 80) = v11;
    *(void *)(a2 + 88) = v11;
    uint64_t v12 = &v11[4 * (v10 >> 2)];
    *(void *)(a2 + 96) = v12;
    memcpy(v11, v9, v10);
    *(void *)(a2 + 88) = v12;
  }

  *(void *)(a2 + 104) = 0LL;
  *(void *)(a2 + 112) = 0LL;
  *(void *)(a2 + 120) = 0LL;
  unint64_t v14 = *(_BYTE **)(a3 + 104);
  uint64_t v13 = *(_BYTE **)(a3 + 112);
  int64_t v15 = v13 - v14;
  if (v13 == v14) {
    return;
  }
  if (v15 < 0) {
LABEL_8:
  }
    abort();
  __int128 v16 = (char *)operator new(v13 - v14);
  *(void *)(a2 + 104) = v16;
  *(void *)(a2 + 112) = v16;
  __int128 v17 = &v16[4 * (v15 >> 2)];
  *(void *)(a2 + 120) = v17;
  memcpy(v16, v14, v15);
  *(void *)(a2 + 112) = v17;
}

uint64_t std::__tree<std::__value_type<std::string,unsigned int>,std::__map_value_compare<std::string,std::__value_type<std::string,unsigned int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,unsigned int>>>::find<std::string>( uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3) {
    return v2;
  }
  int v4 = *(char *)(a2 + 23);
  size_t v5 = v4 >= 0 ? *(unsigned __int8 *)(a2 + 23) : *(void *)(a2 + 8);
  __int128 v6 = v4 >= 0 ? (const void *)a2 : *(const void **)a2;
  uint64_t v7 = a1 + 8;
  do
  {
    int v8 = *(char *)(v3 + 55);
    if (v8 >= 0) {
      size_t v9 = *(unsigned __int8 *)(v3 + 55);
    }
    else {
      size_t v9 = *(void *)(v3 + 40);
    }
    if (v8 >= 0) {
      int64_t v10 = (const void *)(v3 + 32);
    }
    else {
      int64_t v10 = *(const void **)(v3 + 32);
    }
    if (v5 >= v9) {
      size_t v11 = v9;
    }
    else {
      size_t v11 = v5;
    }
    int v12 = memcmp(v10, v6, v11);
    BOOL v13 = v9 < v5;
    if (v12) {
      BOOL v13 = v12 < 0;
    }
    BOOL v14 = !v13;
    if (v13) {
      int64_t v15 = (uint64_t *)(v3 + 8);
    }
    else {
      int64_t v15 = (uint64_t *)v3;
    }
    if (v14) {
      uint64_t v7 = v3;
    }
    uint64_t v3 = *v15;
  }

  while (*v15);
  if (v7 == v2) {
    return v2;
  }
  int v16 = *(char *)(v7 + 55);
  size_t v17 = v16 >= 0 ? *(unsigned __int8 *)(v7 + 55) : *(void *)(v7 + 40);
  size_t v18 = v16 >= 0 ? (const void *)(v7 + 32) : *(const void **)(v7 + 32);
  size_t v19 = v17 >= v5 ? v5 : v17;
  int v20 = memcmp(v6, v18, v19);
  BOOL v21 = v5 < v17;
  if (v20) {
    BOOL v21 = v20 < 0;
  }
  if (v21) {
    return v2;
  }
  return v7;
}

void std::stringbuf::__init_buf_ptrs[abi:nn180100](uint64_t a1)
{
  *(void *)(a1 + 88) = 0LL;
  uint64_t v2 = (std::string *)(a1 + 64);
  char v3 = *(_BYTE *)(a1 + 87);
  if (v3 < 0)
  {
    int v4 = *(std::string **)(a1 + 64);
    unint64_t v5 = *(void *)(a1 + 72);
    int v6 = *(_DWORD *)(a1 + 96);
    if ((v6 & 8) == 0) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }

  int v4 = v2;
  unint64_t v5 = *(unsigned __int8 *)(a1 + 87);
  int v6 = *(_DWORD *)(a1 + 96);
  if ((v6 & 8) != 0)
  {
LABEL_3:
    *(void *)(a1 + 88) = (char *)v4 + v5;
    *(void *)(a1 + 16) = v4;
    *(void *)(a1 + 24) = v4;
    *(void *)(a1 + 32) = (char *)v4 + v5;
  }

void std::__shared_ptr_emplace<JSONGenerator::Array>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_100060F00;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<JSONGenerator::Array>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_100060F00;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t std::__shared_ptr_emplace<JSONGenerator::Array>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_pointer<JSONGenerator::Dictionary *,std::shared_ptr<JSONGenerator::Dictionary>::__shared_ptr_default_delete<JSONGenerator::Dictionary,JSONGenerator::Dictionary>,std::allocator<JSONGenerator::Dictionary>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

uint64_t std::__shared_ptr_pointer<JSONGenerator::Dictionary *,std::shared_ptr<JSONGenerator::Dictionary>::__shared_ptr_default_delete<JSONGenerator::Dictionary,JSONGenerator::Dictionary>,std::allocator<JSONGenerator::Dictionary>>::__on_zero_shared( uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

void std::__shared_ptr_pointer<JSONGenerator::Array *,std::shared_ptr<JSONGenerator::Array>::__shared_ptr_default_delete<JSONGenerator::Array,JSONGenerator::Array>,std::allocator<JSONGenerator::Array>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

uint64_t std::__shared_ptr_pointer<JSONGenerator::Array *,std::shared_ptr<JSONGenerator::Array>::__shared_ptr_default_delete<JSONGenerator::Array,JSONGenerator::Array>,std::allocator<JSONGenerator::Array>>::__on_zero_shared( uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

void std::__shared_ptr_pointer<JSONGenerator::Integer *,std::shared_ptr<JSONGenerator::Integer>::__shared_ptr_default_delete<JSONGenerator::Integer,JSONGenerator::Integer>,std::allocator<JSONGenerator::Integer>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

uint64_t std::__shared_ptr_pointer<JSONGenerator::Integer *,std::shared_ptr<JSONGenerator::Integer>::__shared_ptr_default_delete<JSONGenerator::Integer,JSONGenerator::Integer>,std::allocator<JSONGenerator::Integer>>::__on_zero_shared( uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

void *std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>( uint64_t a1, unsigned int *a2, _DWORD *a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = *a2;
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
    }

    else
    {
      unint64_t v3 = ((_DWORD)v7 - 1) & v6;
    }

    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == (_DWORD)v6) {
              return v10;
            }
          }

          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }

            else
            {
              v11 &= v7 - 1;
            }

            if (v11 != v3) {
              break;
            }
          }

          unint64_t v10 = (void *)*v10;
        }

        while (v10);
      }
    }
  }

  unint64_t v10 = operator new(0x18uLL);
  *unint64_t v10 = 0LL;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1LL;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t prime = v16;
    }
    else {
      size_t prime = v15;
    }
    if (prime == 1)
    {
      size_t prime = 2LL;
    }

    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }

    if (prime > v7) {
      goto LABEL_41;
    }
    if (prime < v7)
    {
      unint64_t v18 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v19 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v19.i16[0] = vaddlv_u8(v19), v19.u32[0] > 1uLL))
      {
        unint64_t v18 = std::__next_prime(v18);
      }

      else
      {
        uint64_t v20 = 1LL << -(char)__clz(v18 - 1);
        if (v18 >= 2) {
          unint64_t v18 = v20;
        }
      }

      if (prime <= v18) {
        size_t prime = v18;
      }
      if (prime < v7) {
LABEL_41:
      }
        std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__do_rehash<true>( a1,  prime);
    }

    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }

    else
    {
      unint64_t v3 = ((_DWORD)v7 - 1) & v6;
    }
  }

  uint64_t v21 = *(void *)a1;
  BOOL v22 = *(void **)(*(void *)a1 + 8 * v3);
  if (v22)
  {
    *unint64_t v10 = *v22;
LABEL_55:
    *BOOL v22 = v10;
    goto LABEL_56;
  }

  *unint64_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v21 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v23 = *(void *)(*v10 + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v23 >= v7) {
        v23 %= v7;
      }
    }

    else
    {
      v23 &= v7 - 1;
    }

    BOOL v22 = (void *)(*(void *)a1 + 8 * v23);
    goto LABEL_55;
  }

void std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__do_rehash<true>( uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    if (a2 >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    int v4 = operator new(8 * a2);
    unint64_t v5 = *(void **)a1;
    *(void *)a1 = v4;
    if (v5) {
      operator delete(v5);
    }
    uint64_t v6 = 0LL;
    *(void *)(a1 + 8) = a2;
    do
      *(void *)(*(void *)a1 + 8 * v6++) = 0LL;
    while (a2 != v6);
    unint64_t v7 = *(void **)(a1 + 16);
    if (v7)
    {
      unint64_t v8 = v7[1];
      uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2) {
          v8 %= a2;
        }
      }

      else
      {
        v8 &= a2 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v8) = a1 + 16;
      unint64_t v11 = (void *)*v7;
      if (*v7)
      {
        do
        {
          unint64_t v13 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v13 >= a2) {
              v13 %= a2;
            }
          }

          else
          {
            v13 &= a2 - 1;
          }

          if (v13 != v8)
          {
            if (!*(void *)(*(void *)a1 + 8 * v13))
            {
              *(void *)(*(void *)a1 + 8 * v13) = v7;
              goto LABEL_19;
            }

            *unint64_t v7 = *v11;
            uint64_t v12 = 8 * v13;
            *unint64_t v11 = **(void **)(*(void *)a1 + v12);
            **(void **)(*(void *)a1 + v12) = v11;
            unint64_t v11 = v7;
          }

          unint64_t v13 = v8;
LABEL_19:
          unint64_t v7 = v11;
          unint64_t v11 = (void *)*v11;
          unint64_t v8 = v13;
        }

        while (v11);
      }
    }
  }

  else
  {
    unint64_t v10 = *(void **)a1;
    *(void *)a1 = 0LL;
    if (v10) {
      operator delete(v10);
    }
    *(void *)(a1 + 8) = 0LL;
  }

uint64_t _GLOBAL__sub_I_RNBRemote_cpp()
{
  byte_1000717BF = 6;
  strcpy((char *)&OS_LOG_EVENTS_KEY_NAME, "events");
  __cxa_atexit((void (*)(void *))&std::string::~string, &OS_LOG_EVENTS_KEY_NAME, (void *)&_mh_execute_header);
  byte_1000717D7 = 4;
  strcpy((char *)&JSON_ASYNC_TYPE_KEY_NAME, "type");
  __cxa_atexit( (void (*)(void *))&std::string::~string,  &JSON_ASYNC_TYPE_KEY_NAME,  (void *)&_mh_execute_header);
  qword_100071828 = 0LL;
  unk_100071830 = 0LL;
  g_dynamic_register_map = 0LL;
  __cxa_atexit( (void (*)(void *))std::vector<register_map_entry>::~vector[abi:nn180100],  &g_dynamic_register_map,  (void *)&_mh_execute_header);
  *(void *)&g_target_xml[8] = 0LL;
  *(void *)&g_target_xml[16] = 0LL;
  *(void *)g_target_xml = 0LL;
  return __cxa_atexit((void (*)(void *))&std::string::~string, g_target_xml, (void *)&_mh_execute_header);
}

uint64_t GetProcesses(__CFArray *a1, char a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  std::string __p = 0LL;
  unint64_t v23 = 0LL;
  uint64_t v24 = 0LL;
  uint64_t v3 = DNBGetAllInfos((char **)&__p);
  if (v3)
  {
    unint64_t v4 = v3;
    pid_t v5 = getpid();
    uid_t v6 = getuid();
    unint64_t v7 = 0LL;
    unsigned int v8 = 1;
    while (1)
    {
      uint8x8_t v9 = (char *)__p + 648 * v7;
      int v10 = *((_DWORD *)v9 + 10);
      if ((a2 & 1) != 0 || *((_DWORD *)v9 + 98) == v6)
      {
        BOOL v11 = v10 == v5 || v10 == 0;
        BOOL v12 = v11 || v9[36] == 5;
        if (!v12 && (v9[33] & 0x28) == 0) {
          break;
        }
      }

uint64_t ListApplications(std::string *a1, uint64_t a2, uint64_t a3)
{
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  if (getuid())
  {
    unint64_t v7 = (const __CFString *)SBSCopyFrontmostApplicationDisplayIdentifier();
    unsigned int v8 = (const __CFArray *)SBSCopyApplicationDisplayIdentifiers(a2, a3);
    if (v8)
    {
      uint8x8_t v9 = v8;
      __int128 v29 = a1;
      CFIndex Count = CFArrayGetCount(v8);
      if (Count >= 1)
      {
        CFIndex v11 = Count;
        CFIndex v12 = 0LL;
        while (1)
        {
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v9, v12);
          CFNumberRef v14 = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
          int valuePtr = 0;
          if (SBSProcessIDForDisplayIdentifier(ValueAtIndex, &valuePtr) == 1)
          {
            CFNumberRef v15 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
            CFDictionarySetValue(v14, @"pid", v15);
            if (v15) {
              CFRelease(v15);
            }
          }

          if (!v7 || !ValueAtIndex || (v16 = CFStringCompare(v7, ValueAtIndex, 0LL), CFBooleanRef v17 = kCFBooleanTrue, v16)) {
            CFBooleanRef v17 = kCFBooleanFalse;
          }
          CFDictionarySetValue(v14, @"isFrontApp", v17);
          unint64_t v18 = (const void *)SBSCopyExecutablePathForDisplayIdentifier(ValueAtIndex);
          if (v18) {
            CFDictionarySetValue(v14, @"executablePath", v18);
          }
          uint8x8_t v19 = (const void *)SBSCopyIconImagePathForDisplayIdentifier(ValueAtIndex);
          if (v19) {
            CFDictionarySetValue(v14, @"iconPath", v19);
          }
          uint64_t v20 = (const void *)SBSCopyLocalizedApplicationNameForDisplayIdentifier(ValueAtIndex);
          if (!v20) {
            break;
          }
          uint64_t v21 = v20;
          CFDictionarySetValue(v14, @"displayName", v20);
          CFArrayAppendValue(Mutable, v14);
          CFRelease(v21);
          if (v19) {
            goto LABEL_19;
          }
LABEL_20:
          if (v18) {
            CFRelease(v18);
          }
          if (v14) {
            CFRelease(v14);
          }
          if (v11 == ++v12) {
            goto LABEL_27;
          }
        }

        CFArrayAppendValue(Mutable, v14);
        if (!v19) {
          goto LABEL_20;
        }
LABEL_19:
        CFRelease(v19);
        goto LABEL_20;
      }

uint64_t RNBSocket::Listen( RNBSocket *this, char *a2, unsigned __int16 Port, void (*a4)(const void *, unsigned __int16), const void *a5)
{
  uint8x8_t v9 = (int *)this;
  RNBSocket::Disconnect(this);
  *(_OWORD *)unint64_t v97 = 0u;
  __int128 v98 = 0u;
  int v10 = kqueue();
  if ((v10 & 0x80000000) == 0)
  {
    __int128 v83 = a5;
    int v11 = strcmp(a2, "*");
    if (v11) {
      CFIndex v12 = a2;
    }
    else {
      CFIndex v12 = "localhost";
    }
    unint64_t v95 = 0LL;
    size_t v96 = 0LL;
    int v94 = (uint64_t *)&v95;
    lldb_private::SocketAddress::GetAddressInfo((lldb_private::SocketAddress *)v12, 0LL, 0LL, 1, 6, 0, (char **)&v92);
    CFNumberRef v14 = (__int128 *)v92;
    unint64_t v13 = v93;
    if (v92 != v93)
    {
      do
      {
        __int128 v15 = *v14;
        __int128 v16 = v14[1];
        __int128 v17 = v14[3];
        __int128 v100 = v14[2];
        __int128 v101 = v17;
        *(_OWORD *)&v99.int ident = v15;
        *(_OWORD *)&v99.int data = v16;
        __int128 v18 = v14[4];
        __int128 v19 = v14[5];
        __int128 v20 = v14[7];
        __int128 v104 = v14[6];
        __int128 v105 = v20;
        __int128 v102 = v18;
        __int128 v103 = v19;
        LODWORD(v86[0]) = 0;
        int Family = lldb_private::SocketAddress::GetFamily((lldb_private::SocketAddress *)&v99);
        int v22 = socket(Family, 1, 6);
        LODWORD(v86[0]) = v22;
        if (v22 == -1) {
          goto LABEL_8;
        }
        *(_DWORD *)&v107.sa_len = 1;
        setsockopt(v22, 0xFFFF, 4, &v107, 4u);
        __int128 v111 = v102;
        __int128 v112 = v103;
        __int128 v113 = v104;
        __int128 v114 = v105;
        sockaddr v107 = *(sockaddr *)&v99.ident;
        __int128 v108 = *(_OWORD *)&v99.data;
        __int128 v109 = v100;
        __int128 v110 = v101;
        if (v11 && lldb_private::SocketAddress::IsLocalhost((lldb_private::SocketAddress *)&v107))
        {
          lldb_private::SocketAddress::SetPort((lldb_private::SocketAddress *)&v107, Port);
        }

        else
        {
          int v23 = lldb_private::SocketAddress::GetFamily((lldb_private::SocketAddress *)&v107);
          lldb_private::SocketAddress::SetToAnyAddress((lldb_private::SocketAddress *)&v107, v23, Port);
        }

        int v24 = (int)v86[0];
        socklen_t Length = lldb_private::SocketAddress::GetLength((lldb_private::SocketAddress *)&v107);
        if (bind(v24, &v107, Length) == -1)
        {
          if (SLODWORD(v86[0]) >= 1) {
            goto LABEL_20;
          }
        }

        else
        {
          if (listen((int)v86[0], 5) != -1)
          {
            if (!Port)
            {
              v89[0] = 0;
              v89[0] = lldb_private::SocketAddress::GetLength((lldb_private::SocketAddress *)&v99);
              else {
                Port = lldb_private::SocketAddress::GetPort((lldb_private::SocketAddress *)&v99);
              }
            }

            *(void *)unint64_t v89 = v86;
            BOOL v26 = std::__tree<std::__value_type<int,lldb_private::SocketAddress>,std::__map_value_compare<int,std::__value_type<int,lldb_private::SocketAddress>,std::less<int>,true>,std::allocator<std::__value_type<int,lldb_private::SocketAddress>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>( &v94,  (int *)v86,  (uint64_t)&std::piecewise_construct,  (_DWORD **)v89);
            __int128 v28 = v100;
            __int128 v27 = v101;
            __int128 v29 = *(_OWORD *)&v99.data;
            *(_OWORD *)(v26 + 5) = *(_OWORD *)&v99.ident;
            __int128 v31 = v104;
            __int128 v30 = v105;
            __int128 v32 = v103;
            *(_OWORD *)(v26 + 13) = v102;
            *(_OWORD *)(v26 + 15) = v32;
            *(_OWORD *)(v26 + 17) = v31;
            *(_OWORD *)(v26 + 19) = v30;
            *(_OWORD *)(v26 + 7) = v29;
            *(_OWORD *)(v26 + 9) = v28;
            *(_OWORD *)(v26 + 11) = v27;
            goto LABEL_7;
          }

          if (SLODWORD(v86[0]) >= 1)
          {
LABEL_20:
            *__error() = 0;
            close((int)v86[0]);
            LODWORD(v86[0]) = -1;
          }
        }

LABEL_86:
                        v97[0] = 0LL;
                        if (SHIBYTE(v98) < 0)
                        {
                          *(_BYTE *)v97[1] = 0;
                          *(void *)&__int128 v98 = 0LL;
                        }

                        else
                        {
                          LOBYTE(v97[1]) = 0;
                          HIBYTE(v98) = 0;
                        }
                      }

                      lldb_private::SocketAddress::~SocketAddress((lldb_private::SocketAddress *)&v107);
                    }
                  }
                }

                if (++v46 == v48) {
                  goto LABEL_96;
                }
                continue;
              }
            }

LABEL_91:
            LODWORD(v97[0]) = *__error();
            HIDWORD(v97[0]) = 1;
            if (SHIBYTE(v98) < 0)
            {
              *(_BYTE *)v97[1] = 0;
              *(void *)&__int128 v98 = 0LL;
            }

            else
            {
              LOBYTE(v97[1]) = 0;
              HIBYTE(v98) = 0;
            }

            DNBError::LogThreaded((DNBError *)v97, "error: kevent() failed.");
LABEL_95:
            char v47 = 0;
LABEL_96:
            if (LODWORD(v97[0]) || (v47 & 1) != 0)
            {
              unint64_t v69 = v94;
              if (v94 != (uint64_t *)&v95)
              {
                do
                {
                  __int128 v70 = *((_OWORD *)v69 + 8);
                  __int128 v103 = *((_OWORD *)v69 + 7);
                  __int128 v104 = v70;
                  __int128 v105 = *((_OWORD *)v69 + 9);
                  uint64_t v106 = v69[20];
                  __int128 v71 = *((_OWORD *)v69 + 3);
                  __int128 v72 = *((_OWORD *)v69 + 5);
                  __int128 v73 = *((_OWORD *)v69 + 6);
                  __int128 v100 = *((_OWORD *)v69 + 4);
                  __int128 v101 = v72;
                  __int128 v102 = v73;
                  *(_OWORD *)&v99.int ident = *((_OWORD *)v69 + 2);
                  *(_OWORD *)&v99.int data = v71;
                  int ident = v99.ident;
                  if (SLODWORD(v99.ident) >= 1)
                  {
                    *__error() = 0;
                    close(ident);
                  }

                  lldb_private::SocketAddress::~SocketAddress((lldb_private::SocketAddress *)&v99.filter);
                  int v75 = (uint64_t *)v69[1];
                  if (v75)
                  {
                    do
                    {
                      mach_vm_address_t v76 = v75;
                      int v75 = (uint64_t *)*v75;
                    }

                    while (v75);
                  }

                  else
                  {
                    do
                    {
                      mach_vm_address_t v76 = (uint64_t *)v69[2];
                      BOOL v44 = *v76 == (void)v69;
                      unint64_t v69 = v76;
                    }

                    while (!v44);
                  }

                  unint64_t v69 = v76;
                }

                while (v76 != (uint64_t *)&v95);
              }

              uint64_t v77 = 1LL;
              if (!LODWORD(v97[0]))
              {
                int v78 = *v9;
                LODWORD(v99.ident) = 1;
                setsockopt(v78, 6, 1, &v99, 4u);
                uint64_t v77 = 0LL;
              }

              if (*(void *)v89)
              {
                unsigned int v90 = *(const kevent **)v89;
                operator delete(*(void **)v89);
              }

              size_t v79 = (char *)v92;
              if (!v92)
              {
LABEL_124:
                std::__tree<std::__value_type<int,lldb_private::SocketAddress>,std::__map_value_compare<int,std::__value_type<int,lldb_private::SocketAddress>,std::less<int>,true>,std::allocator<std::__value_type<int,lldb_private::SocketAddress>>>::destroy( (uint64_t)&v94,  v95);
                if (SHIBYTE(v98) < 0) {
                  goto LABEL_125;
                }
                return v77;
              }

LABEL_120:
              __int128 v80 = (char *)v93;
              uint64_t v81 = v79;
              if (v93 != (__int128 *)v79)
              {
                do
                  lldb_private::SocketAddress::~SocketAddress((lldb_private::SocketAddress *)(v80 - 128));
                while (v80 != v79);
                uint64_t v81 = v92;
              }

              unint64_t v93 = (__int128 *)v79;
              operator delete(v81);
              goto LABEL_124;
            }
          }
        }
      }
    }

    else
    {
      *(void *)unint64_t v89 = 0LL;
      unsigned int v90 = 0LL;
      uint64_t v91 = 0LL;
    }

    std::vector<kevent>::__append((char **)v89, v33);
    goto LABEL_35;
  }

  LODWORD(v97[0]) = *__error();
  HIDWORD(v97[0]) = 1;
  if (SHIBYTE(v98) < 0)
  {
    *(_BYTE *)v97[1] = 0;
    *(void *)&__int128 v98 = 0LL;
  }

  else
  {
    LOBYTE(v97[1]) = 0;
    HIBYTE(v98) = 0;
  }

  DNBError::LogThreaded((DNBError *)v97, "error: failed to create kqueue.");
  uint64_t v77 = 1LL;
  if (SHIBYTE(v98) < 0) {
LABEL_125:
  }
    operator delete(v97[1]);
  return v77;
}

void sub_10003363C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20, int a21, __int16 a22, char a23, char a24, uint64_t a25, void *__p, uint64_t a27, uint64_t a28, void *a29, uint64_t a30, uint64_t a31, char a32, void *a33, uint64_t a34, uint64_t a35, void *a36, uint64_t a37, int a38, __int16 a39, char a40, char a41, char a42)
{
  if (__p) {
    operator delete(__p);
  }
  std::vector<lldb_private::SocketAddress>::~vector[abi:ne180100](&a29);
  std::__tree<std::__value_type<int,lldb_private::SocketAddress>,std::__map_value_compare<int,std::__value_type<int,lldb_private::SocketAddress>,std::less<int>,true>,std::allocator<std::__value_type<int,lldb_private::SocketAddress>>>::destroy( (uint64_t)&a32,  a33);
  if (a41 < 0) {
    operator delete(a36);
  }
  _Unwind_Resume(a1);
}

BOOL RNBSocket::Disconnect(RNBSocket *this)
{
  if (*((_BYTE *)this + 4))
  {
    if (*((_BYTE *)this + 5))
    {
      close(*(_DWORD *)this);
      sleep(0x1Eu);
      *(_DWORD *)this = -1;
      *((_WORD *)this + 2) = 0;
      BOOL v8 = DNBLogEnabled();
      BOOL result = 0LL;
      if (!v8) {
        return result;
      }
      _DNBLog( 0LL,  (uint64_t)"Shutting down secure socket proxy, SSP finish-callback didn't kill debugserver.",  v2,  v3,  v4,  v5,  v6,  v7,  v11);
    }

    else
    {
      *((_BYTE *)this + 4) = 0;
      *(_DWORD *)this = -1;
      lockdown_disconnect(*((void *)this + 1));
    }
  }

  else if (*(int *)this >= 1)
  {
    *__error() = 0;
    int v10 = close(*(_DWORD *)this);
    *(_DWORD *)this = -1;
    return v10 != 0;
  }

  return 0LL;
}

void **std::vector<lldb_private::SocketAddress>::~vector[abi:ne180100](void **a1)
{
  uint64_t v2 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    uint64_t v4 = v2;
    if (v3 != v2)
    {
      do
        lldb_private::SocketAddress::~SocketAddress((lldb_private::SocketAddress *)(v3 - 128));
      while (v3 != v2);
      uint64_t v4 = *a1;
    }

    a1[1] = v2;
    operator delete(v4);
  }

  return a1;
}

uint64_t RNBSocket::Connect(RNBSocket *this, lldb_private::SocketAddress *a2, unsigned int a3)
{
  uint64_t v6 = v23;
  uint64_t v7 = v24;
  uint64_t v8 = 1LL;
  if (v23 == v24)
  {
    if (v23) {
      goto LABEL_11;
    }
    return v8;
  }

  while (1)
  {
    sockaddr v9 = *(sockaddr *)v6;
    __int128 v10 = *((_OWORD *)v6 + 1);
    __int128 v11 = *((_OWORD *)v6 + 3);
    __int128 v28 = *((_OWORD *)v6 + 2);
    __int128 v29 = v11;
    sockaddr v26 = v9;
    __int128 v27 = v10;
    __int128 v12 = *((_OWORD *)v6 + 4);
    __int128 v13 = *((_OWORD *)v6 + 5);
    __int128 v14 = *((_OWORD *)v6 + 7);
    __int128 v32 = *((_OWORD *)v6 + 6);
    __int128 v33 = v14;
    __int128 v30 = v12;
    __int128 v31 = v13;
    int Family = lldb_private::SocketAddress::GetFamily((lldb_private::SocketAddress *)&v26);
    int v16 = socket(Family, 1, 6);
    *(_DWORD *)this = v16;
    if (v16 != -1) {
      break;
    }
LABEL_4:
    lldb_private::SocketAddress::~SocketAddress((lldb_private::SocketAddress *)&v26);
    v6 += 128;
    if (v6 == v7)
    {
      uint64_t v8 = 1LL;
      goto LABEL_10;
    }
  }

  int v25 = 1;
  setsockopt(v16, 0xFFFF, 4, &v25, 4u);
  lldb_private::SocketAddress::SetPort((lldb_private::SocketAddress *)&v26, a3);
  int v17 = *(_DWORD *)this;
  socklen_t Length = lldb_private::SocketAddress::GetLength((lldb_private::SocketAddress *)&v26);
  if (connect(v17, &v26, Length) == -1)
  {
    RNBSocket::Disconnect(this);
    goto LABEL_4;
  }

  int v19 = *(_DWORD *)this;
  int v25 = 1;
  setsockopt(v19, 6, 1, &v25, 4u);
  lldb_private::SocketAddress::~SocketAddress((lldb_private::SocketAddress *)&v26);
  uint64_t v8 = 0LL;
LABEL_10:
  uint64_t v6 = v23;
  if (v23)
  {
LABEL_11:
    __int128 v20 = v24;
    uint64_t v21 = v6;
    if (v24 != v6)
    {
      do
        lldb_private::SocketAddress::~SocketAddress((lldb_private::SocketAddress *)(v20 - 128));
      while (v20 != v6);
      uint64_t v21 = v23;
    }

    int v24 = v6;
    operator delete(v21);
  }

  return v8;
}

void sub_1000339F8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
}

uint64_t RNBSocket::useFD(RNBSocket *this, int a2)
{
  if (a2 < 0)
  {
    if (DNBLogEnabledForAny(0x80000)) {
      _DNBLogThreaded("Bad file descriptor passed in.");
    }
    return 1LL;
  }

  else
  {
    uint64_t result = 0LL;
    *(_DWORD *)this = a2;
  }

  return result;
}

uint64_t RNBSocket::ConnectToService(RNBSocket *this, int a2)
{
  if (DNBLogEnabled()) {
    _DNBLog(0LL, (uint64_t)"Connecting to com.apple.%s service...", v4, v5, v6, v7, v8, v9, (uint64_t)"debugserver");
  }
  RNBSocket::Disconnect(this);
  if (secure_lockdown_checkin((char *)this + 8, 0LL, 0LL))
  {
    if (DNBLogEnabledForAny(0x80000)) {
      _DNBLogThreaded("::secure_lockdown_checkin(&m_fd, NULL, NULL) failed");
    }
    *(_DWORD *)this = -1;
    return 2LL;
  }

  uint64_t v11 = *((void *)this + 1);
  if (a2)
  {
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 3221225472LL;
    v21[2] = ___ZN9RNBSocket16ConnectToServiceEb_block_invoke;
    std::string v21[3] = &__block_descriptor_40_e5_v8__0l;
    v21[4] = this;
    v23[0] = _NSConcreteStackBlock;
    v23[1] = 3221225472LL;
    v23[2] = ___ZL58DVTSecureSocketProxy_CreateWithLockdownConnectionFunctionsP20_lockdown_connectionPFiS0_EPFlS0_PvmEPFlS0_PKvmEU13block_pointerFvvE_block_invoke;
    v23[3] = &__block_descriptor_48_e12_q24__0_v8Q16l;
    v23[4] = &lockdown_recv;
    v23[5] = v11;
    v22[0] = _NSConcreteStackBlock;
    v22[1] = 3221225472LL;
    v22[2] = ___ZL58DVTSecureSocketProxy_CreateWithLockdownConnectionFunctionsP20_lockdown_connectionPFiS0_EPFlS0_PvmEPFlS0_PKvmEU13block_pointerFvvE_block_invoke_2;
    v22[3] = &__block_descriptor_48_e13_q24__0r_v8Q16l;
    v22[4] = &lockdown_send;
    v22[5] = v11;
    uint64_t socket = lockdown_get_socket(v11);
    *(_DWORD *)this = DVTSecureSocketProxy_Create(socket, v23, v22, v21);
    *((_BYTE *)this + 5) = 1;
    if (DNBLogEnabled()) {
      _DNBLog(0LL, (uint64_t)"Using secure socket proxy.", v13, v14, v15, v16, v17, v18, v20);
    }
    if (*(_DWORD *)this != -1) {
      goto LABEL_12;
    }
LABEL_14:
    if (DNBLogEnabledForAny(0x80000)) {
      _DNBLogThreaded("::lockdown_get_socket() failed");
    }
    return 2LL;
  }

  int v19 = lockdown_get_socket(v11);
  *(_DWORD *)this = v19;
  *((_BYTE *)this + 5) = 0;
  if (v19 == -1) {
    goto LABEL_14;
  }
LABEL_12:
  uint64_t result = 0LL;
  *((_BYTE *)this + 4) = 1;
  return result;
}

void ___ZN9RNBSocket16ConnectToServiceEb_block_invoke(uint64_t a1)
{
  if (DNBLogEnabled())
  {
    _DNBLog(0LL, (uint64_t)"debugserver secure socket proxy finish-block shut down.", v1, v2, v3, v4, v5, v6, vars0);
    if (!DNBLogEnabled()) {
LABEL_3:
    }
      _exit(0);
  }

  else if (!DNBLogEnabled())
  {
    goto LABEL_3;
  }

  _DNBLog(0LL, (uint64_t)"debugserver expedited exit.", v7, v8, v9, v10, v11, v12, vars0);
  _exit(0);
}

uint64_t RNBSocket::OpenFile(RNBSocket *this, const char *a2)
{
  *(_OWORD *)std::string __p = 0u;
  __int128 v7 = 0u;
  int v4 = open(a2, 2);
  *(_DWORD *)this = v4;
  if (v4 == -1)
  {
    LODWORD(__p[0]) = *__error();
    HIDWORD(__p[0]) = 2;
    LOBYTE(__p[1]) = 0;
    HIBYTE(v7) = 0;
    DNBError::LogThreaded((DNBError *)__p, "can't open file '%s'", a2);
    if (SHIBYTE(v7) < 0) {
      operator delete(__p[1]);
    }
    return 2LL;
  }

  else
  {
    if (!tcgetattr(v4, &v8))
    {
      v8.c_lflag &= 0xFFFFFFFFFFFFFEF7LL;
      tcsetattr(*(_DWORD *)this, 0, &v8);
    }

    return 0LL;
  }

void sub_100033D4C(_Unwind_Exception *exception_object)
{
}

void sub_100033D58( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RNBSocket::Read(int *a1, std::string *a2)
{
  if ((char)a2->__r_.__value_.__s.__size_ < 0)
  {
    *a2->__r_.__value_.__l.__data_ = 0;
    a2->__r_.__value_.__l.__size_ = 0LL;
  }

  else
  {
    a2->__r_.__value_.__s.__data_[0] = 0;
    a2->__r_.__value_.__s.__size_ = 0;
  }

  if (*a1 == -1) {
    return 1LL;
  }
  *(_OWORD *)std::string __p = 0u;
  __int128 v15 = 0u;
  while (1)
  {
    *__error() = 0;
    int64_t v4 = read(*a1, __s, 0x400uLL);
    int64_t v5 = v4;
    if (v4 != -1) {
      break;
    }
    if (*__error() != 35 && *__error() != 35 && *__error() != 4) {
      goto LABEL_14;
    }
  }

  if (v4 > 0)
  {
    std::string::append(a2, __s, v4);
    goto LABEL_15;
  }

void sub_100033FC4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RNBSocket::Write(RNBSocket *this, const void *a2, size_t a3)
{
  int v4 = *(_DWORD *)this;
  if (v4 == -1) {
    return 1LL;
  }
  *(_OWORD *)std::string __p = 0u;
  __int128 v11 = 0u;
  ssize_t v7 = write(v4, a2, a3);
  if (v7 < 0
    && (LODWORD(__p[0]) = *__error(), HIDWORD(__p[0]) = 2, LOBYTE(__p[1]) = 0, HIBYTE(v11) = 0, LODWORD(__p[0]))
    || DNBLogCheckLogBit(0x80000))
  {
    DNBError::LogThreaded( (DNBError *)__p,  "::write(uint64_t socket = %i, buffer = %p, length = %llu) => %i",  *(_DWORD *)this,  a2,  a3,  v7);
  }

  uint64_t v8 = 1LL;
  if ((v7 & 0x8000000000000000LL) == 0 && v7 == a3)
  {
    if (DNBLogEnabledForAny(0x800000)) {
      _DNBLogThreaded("putpkt: %*s", a3, (const char *)a2);
    }
    if (DNBLogEnabledForAny(0x80000)) {
      _DNBLogThreaded("sent: %*s", a3, (const char *)a2);
    }
    uint64_t v8 = 0LL;
  }

  if (SHIBYTE(v11) < 0) {
    operator delete(__p[1]);
  }
  return v8;
}

void sub_1000340EC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZL58DVTSecureSocketProxy_CreateWithLockdownConnectionFunctionsP20_lockdown_connectionPFiS0_EPFlS0_PvmEPFlS0_PKvmEU13block_pointerFvvE_block_invoke( uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))(*(void *)(a1 + 40));
}

uint64_t ___ZL58DVTSecureSocketProxy_CreateWithLockdownConnectionFunctionsP20_lockdown_connectionPFiS0_EPFlS0_PvmEPFlS0_PKvmEU13block_pointerFvvE_block_invoke_2( uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))(*(void *)(a1 + 40));
}

void std::__tree<std::__value_type<int,lldb_private::SocketAddress>,std::__map_value_compare<int,std::__value_type<int,lldb_private::SocketAddress>,std::less<int>,true>,std::allocator<std::__value_type<int,lldb_private::SocketAddress>>>::destroy( uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<int,lldb_private::SocketAddress>,std::__map_value_compare<int,std::__value_type<int,lldb_private::SocketAddress>,std::less<int>,true>,std::allocator<std::__value_type<int,lldb_private::SocketAddress>>>::destroy( a1,  *a2);
    std::__tree<std::__value_type<int,lldb_private::SocketAddress>,std::__map_value_compare<int,std::__value_type<int,lldb_private::SocketAddress>,std::less<int>,true>,std::allocator<std::__value_type<int,lldb_private::SocketAddress>>>::destroy( a1,  a2[1]);
    lldb_private::SocketAddress::~SocketAddress((lldb_private::SocketAddress *)(a2 + 5));
    operator delete(a2);
  }

uint64_t **std::__tree<std::__value_type<int,lldb_private::SocketAddress>,std::__map_value_compare<int,std::__value_type<int,lldb_private::SocketAddress>,std::less<int>,true>,std::allocator<std::__value_type<int,lldb_private::SocketAddress>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>( uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  ssize_t v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    int v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        int v10 = *((_DWORD *)v6 + 8);
        if (v8 >= v10) {
          break;
        }
        uint64_t v6 = *v9;
        ssize_t v7 = v9;
        if (!*v9) {
          goto LABEL_9;
        }
      }

      if (v10 >= v8) {
        return v9;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        ssize_t v7 = v9 + 1;
        goto LABEL_9;
      }
    }
  }

  else
  {
    uint64_t v9 = a1 + 1;
LABEL_9:
    __int128 v11 = operator new(0xA8uLL);
    v11[8] = **a4;
    lldb_private::SocketAddress::SocketAddress((lldb_private::SocketAddress *)(v11 + 10));
    *(void *)__int128 v11 = 0LL;
    *((void *)v11 + 1) = 0LL;
    *((void *)v11 + 2) = v9;
    *ssize_t v7 = (uint64_t *)v11;
    std::string::size_type v12 = (uint64_t *)**a1;
    uint64_t v13 = (uint64_t *)v11;
    if (v12)
    {
      *a1 = v12;
      uint64_t v13 = *v7;
    }

    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], v13);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }

  return (uint64_t **)v11;
}

void sub_100034248(_Unwind_Exception *a1)
{
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  uint64_t v1 = std::bad_array_new_length::bad_array_new_length(exception);
}

void std::vector<kevent>::__append(char **a1, unint64_t a2)
{
  int64_t v5 = a1[1];
  int v4 = a1[2];
  if (a2 <= (v4 - v5) >> 5)
  {
    if (a2)
    {
      uint64_t v12 = 32 * a2;
      bzero(a1[1], 32 * a2);
      v5 += v12;
    }

    a1[1] = v5;
  }

  else
  {
    uint64_t v6 = *a1;
    uint64_t v7 = (v5 - *a1) >> 5;
    unint64_t v8 = v7 + a2;
    if ((v7 + a2) >> 59) {
      std::vector<kevent>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v9 = v4 - v6;
    if (v9 >> 4 > v8) {
      unint64_t v8 = v9 >> 4;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 >> 59) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      __int128 v11 = (char *)operator new(32 * v10);
    }

    else
    {
      __int128 v11 = 0LL;
    }

    uint64_t v13 = &v11[32 * v7];
    size_t v14 = 32 * a2;
    __int128 v15 = &v11[32 * v10];
    bzero(v13, v14);
    uint64_t v16 = &v13[v14];
    if (v5 != v6)
    {
      do
      {
        __int128 v17 = *((_OWORD *)v5 - 1);
        *((_OWORD *)v13 - 2) = *((_OWORD *)v5 - 2);
        *((_OWORD *)v13 - 1) = v17;
        v13 -= 32;
        v5 -= 32;
      }

      while (v5 != v6);
      int64_t v5 = *a1;
    }

    *a1 = v13;
    a1[1] = v16;
    a1[2] = v15;
    if (v5) {
      operator delete(v5);
    }
  }

void std::vector<kevent>::__throw_length_error[abi:ne180100]()
{
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
}

void sub_1000343F8(_Unwind_Exception *a1)
{
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  uint64_t result = std::logic_error::logic_error(a1, a2);
  return result;
}

char *SysSignal::Name(SysSignal *this)
{
  else {
    return off_100061158[(int)this - 1];
  }
}

BOOL CFBundle::SetPath(CFBundle *this, const char *a2)
{
  int v4 = (const void *)*((void *)this + 1);
  if (v4)
  {
    CFRelease(v4);
    *((void *)this + 1) = 0LL;
  }

  int64_t v5 = (const void *)*((void *)this + 3);
  if (v5)
  {
    CFRelease(v5);
    *((void *)this + 3) = 0LL;
  }

  CFString::CFString((CFString *)&v12, 0LL);
  CFString::SetFileSystemRepresentation((CFString *)&v12, a2);
  if (filePath)
  {
    uint64_t v6 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, filePath, kCFURLPOSIXPathStyle, 1u);
    uint64_t v7 = (const __CFURL *)*((void *)this + 3);
    if (v7 != v6)
    {
      if (v7) {
        CFRelease(v7);
      }
      *((void *)this + 3) = v6;
    }

    if (v6)
    {
      CFBundleRef v8 = CFBundleCreate(kCFAllocatorDefault, v6);
      CFBundleRef v9 = (CFBundleRef)*((void *)this + 1);
      if (v9 != v8)
      {
        if (v9) {
          CFRelease(v9);
        }
        *((void *)this + 1) = v8;
      }
    }
  }

  BOOL v10 = *((void *)this + 1) != 0LL;
  CFString::~CFString((CFString *)&v12);
  return v10;
}

void CFBundle::CFBundle(CFBundle *this, const char *a2)
{
  *(void *)this = off_100061260;
  *((void *)this + 1) = 0LL;
  *((void *)this + 2) = &off_1000612A0;
  *((void *)this + 3) = 0LL;
  if (a2)
  {
    if (*a2) {
      CFBundle::SetPath(this, a2);
    }
  }

void *CFReleaser<__CFURL const*>::~CFReleaser(void *a1)
{
  *a1 = &off_1000612A0;
  uint64_t v2 = (const void *)a1[1];
  if (v2)
  {
    CFRelease(v2);
    a1[1] = 0LL;
  }

  return a1;
}

void CFBundle::~CFBundle(CFBundle *this)
{
  *(void *)this = off_100061260;
  *((void *)this + 2) = &off_1000612A0;
  uint64_t v2 = (const void *)*((void *)this + 3);
  if (v2)
  {
    CFRelease(v2);
    *((void *)this + 3) = 0LL;
  }

  *(void *)this = &off_100061280;
  uint64_t v3 = (const void *)*((void *)this + 1);
  if (v3)
  {
    CFRelease(v3);
    *((void *)this + 1) = 0LL;
  }

{
  const void *v2;
  const void *v3;
  *(void *)this = off_100061260;
  *((void *)this + 2) = &off_1000612A0;
  uint64_t v2 = (const void *)*((void *)this + 3);
  if (v2)
  {
    CFRelease(v2);
    *((void *)this + 3) = 0LL;
  }

  *(void *)this = &off_100061280;
  uint64_t v3 = (const void *)*((void *)this + 1);
  if (v3) {
    CFRelease(v3);
  }
  operator delete(this);
}

__CFBundle *CFBundle::GetIdentifier(CFBundle *this)
{
  uint64_t result = (__CFBundle *)*((void *)this + 1);
  if (result) {
    return (__CFBundle *)CFBundleGetIdentifier(result);
  }
  return result;
}

__CFBundle *CFBundle::CopyExecutableURL(CFBundle *this)
{
  uint64_t result = (__CFBundle *)*((void *)this + 1);
  if (result) {
    return CFBundleCopyExecutableURL(result);
  }
  return result;
}

void *CFReleaser<__CFBundle *>::~CFReleaser(void *a1)
{
  *a1 = &off_100061280;
  uint64_t v2 = (const void *)a1[1];
  if (v2)
  {
    CFRelease(v2);
    a1[1] = 0LL;
  }

  return a1;
}

void CFReleaser<__CFBundle *>::~CFReleaser(void *__p)
{
  *std::string __p = &off_100061280;
  uint64_t v2 = (const void *)__p[1];
  if (v2) {
    CFRelease(v2);
  }
  operator delete(__p);
}

void CFReleaser<__CFURL const*>::~CFReleaser(void *__p)
{
  *std::string __p = &off_1000612A0;
  uint64_t v2 = (const void *)__p[1];
  if (v2) {
    CFRelease(v2);
  }
  operator delete(__p);
}

void CFString::CFString(CFString *this, const __CFString *a2)
{
  *(void *)this = off_1000612C0;
  *((void *)this + 1) = a2;
}

void CFString::CFString(CFString *this, const char *a2, CFStringEncoding a3)
{
  *(void *)this = off_1000612C0;
  *((void *)this + 1) = 0LL;
  if (a2)
  {
    if (*a2)
    {
      CFStringRef v4 = CFStringCreateWithCString(kCFAllocatorDefault, a2, a3);
      CFStringRef v5 = (CFStringRef)*((void *)this + 1);
      if (v5 != v4)
      {
        if (v5) {
          CFRelease(v5);
        }
        *((void *)this + 1) = v4;
      }
    }
  }

void CFString::~CFString(CFString *this)
{
  *(void *)this = &off_1000612E0;
  uint64_t v2 = (const void *)*((void *)this + 1);
  if (v2)
  {
    CFRelease(v2);
    *((void *)this + 1) = 0LL;
  }

{
  const void *v2;
  *(void *)this = &off_1000612E0;
  uint64_t v2 = (const void *)*((void *)this + 1);
  if (v2) {
    CFRelease(v2);
  }
  operator delete(this);
}

CFStringRef CFString::SetFileSystemRepresentation(CFString *this, const char *a2)
{
  if (a2 && *a2) {
    CFStringRef v3 = CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, a2);
  }
  else {
    CFStringRef v3 = 0LL;
  }
  CFStringRef v4 = (CFStringRef)*((void *)this + 1);
  if (v4 != v3)
  {
    if (v4) {
      CFRelease(v4);
    }
    *((void *)this + 1) = v3;
  }

  return v3;
}

std::string *CFString::GlobPath(const char *a1, std::string *a2)
{
  if (glob(a1, 2048, 0LL, &v4))
  {
    if ((char)a2->__r_.__value_.__s.__size_ < 0)
    {
      *a2->__r_.__value_.__l.__data_ = 0;
      a2->__r_.__value_.__l.__size_ = 0LL;
    }

    else
    {
      a2->__r_.__value_.__s.__data_[0] = 0;
      a2->__r_.__value_.__s.__size_ = 0;
    }
  }

  else
  {
    std::string::assign(a2, *(const std::string::value_type **)v4.gl_pathv);
    globfree(&v4);
  }

  if ((a2->__r_.__value_.__s.__size_ & 0x80u) == 0) {
    return a2;
  }
  else {
    return (std::string *)a2->__r_.__value_.__r.__words[0];
  }
}

const __CFString *CFString::UTF8(const __CFString *result, std::string *a2)
{
  if (!result) {
    return result;
  }
  CFStringRef v3 = result;
  CFIndex Length = CFStringGetLength(result);
  int64_t MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  if (MaximumSizeForEncoding < 1) {
    return 0LL;
  }
  std::string::resize(a2, MaximumSizeForEncoding, 0);
  if (((char)a2->__r_.__value_.__s.__size_ & 0x80000000) == 0)
  {
    CFIndex size = a2->__r_.__value_.__s.__size_;
    if (a2->__r_.__value_.__s.__size_)
    {
      uint64_t v7 = (char *)a2;
      goto LABEL_8;
    }

    return 0LL;
  }

  CFIndex size = a2->__r_.__value_.__l.__size_;
  if (!size) {
    return 0LL;
  }
  uint64_t v7 = (char *)a2->__r_.__value_.__r.__words[0];
LABEL_8:
  if (!CFStringGetCString(v3, v7, size, 0x8000100u)) {
    return 0LL;
  }
  if ((a2->__r_.__value_.__s.__size_ & 0x80u) == 0) {
    CFBundleRef v8 = (const char *)a2;
  }
  else {
    CFBundleRef v8 = (const char *)a2->__r_.__value_.__r.__words[0];
  }
  size_t v9 = strlen(v8);
  std::string::resize(a2, v9, 0);
  if ((a2->__r_.__value_.__s.__size_ & 0x80u) == 0) {
    return (const __CFString *)a2;
  }
  else {
    return (const __CFString *)a2->__r_.__value_.__r.__words[0];
  }
}

void *CFReleaser<__CFString const*>::~CFReleaser(void *a1)
{
  *a1 = &off_1000612E0;
  uint64_t v2 = (const void *)a1[1];
  if (v2)
  {
    CFRelease(v2);
    a1[1] = 0LL;
  }

  return a1;
}

void CFReleaser<__CFString const*>::~CFReleaser(void *__p)
{
  *std::string __p = &off_1000612E0;
  uint64_t v2 = (const void *)__p[1];
  if (v2) {
    CFRelease(v2);
  }
  operator delete(__p);
}

void Genealogy::Genealogy(Genealogy *this)
{
  *((void *)this + 11) = 0LL;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((void *)this + 8) = 0LL;
  *((void *)this + 10) = (char *)this + 88;
  *((void *)this + 12) = 0LL;
  *((void *)this + 13) = 0LL;
  *((void *)this + 14) = 0LL;
  *((void *)this + 15) = 0LL;
  *((_BYTE *)this + 128) = 0;
  *(void *)this = dlsym((void *)0xFFFFFFFFFFFFFFFELL, "os_activity_diagnostic_for_pid");
  *((void *)this + 1) = dlsym((void *)0xFFFFFFFFFFFFFFFELL, "os_activity_iterate_processes");
  *((void *)this + 2) = dlsym((void *)0xFFFFFFFFFFFFFFFELL, "os_activity_iterate_breadcrumbs");
  *((void *)this + 3) = dlsym((void *)0xFFFFFFFFFFFFFFFELL, "os_activity_iterate_messages");
  *((void *)this + 4) = dlsym((void *)0xFFFFFFFFFFFFFFFELL, "os_activity_iterate_activities");
  *((void *)this + 5) = dlsym((void *)0xFFFFFFFFFFFFFFFELL, "os_trace_get_type");
  *((void *)this + 6) = dlsym((void *)0xFFFFFFFFFFFFFFFELL, "os_trace_copy_formatted_message");
  *((void *)this + 7) = dlsym((void *)0xFFFFFFFFFFFFFFFELL, "os_activity_for_thread");
  *((void *)this + 8) = dlsym((void *)0xFFFFFFFFFFFFFFFELL, "os_activity_for_task_thread");
  *((void *)this + 9) = dlsym((void *)0xFFFFFFFFFFFFFFFELL, "os_activity_messages_for_thread");
}

void Genealogy::GetGenealogyInfoForThread( Genealogy *this@<X0>, const MachThreadList *a2@<X3>, BOOL *a3@<X5>, uint64_t a4@<X1>, unint64_t a5@<X2>, int a6@<W4>, void *a7@<X8>)
{
  *a7 = 0LL;
  a7[1] = 0LL;
  if (!*((void *)this + 12) && !*((_BYTE *)this + 128)) {
    Genealogy::GetActivities(this, a4, a2, a6);
  }
  __int128 v11 = (void *)*((void *)this + 11);
  if (v11)
  {
    uint64_t v12 = (void *)((char *)this + 88);
    do
    {
      unint64_t v13 = v11[4];
      BOOL v14 = v13 >= a5;
      if (v13 >= a5) {
        __int128 v15 = v11;
      }
      else {
        __int128 v15 = v11 + 1;
      }
      if (v14) {
        uint64_t v12 = v11;
      }
      __int128 v11 = (void *)*v15;
    }

    while (*v15);
    if (v12 != (void *)((char *)this + 88) && v12[4] <= a5)
    {
      uint64_t v17 = v12[5];
      uint64_t v16 = v12[6];
      if (v16)
      {
        uint64_t v18 = (unint64_t *)(v16 + 8);
        do
          unint64_t v19 = __ldxr(v18);
        while (__stxr(v19 + 1, v18));
      }

      *a7 = v17;
      a7[1] = v16;
    }
  }

  *a3 = *((_BYTE *)this + 128);
}

void Genealogy::GetActivities(Genealogy *this, uint64_t a2, const MachThreadList *a3, int a4)
{
  if (!*(void *)this
    || !*((void *)this + 1)
    || !*((void *)this + 2)
    || !*((void *)this + 3)
    || !*((void *)this + 4)
    || !*((void *)this + 5)
    || !*((void *)this + 6)
    || *(_OWORD *)((char *)this + 56) == 0LL)
  {
    return;
  }

  uint64_t v92 = 0LL;
  unint64_t v93 = &v92;
  uint64_t v94 = 0x2000000000LL;
  dispatch_semaphore_t v95 = 0LL;
  dispatch_semaphore_t v95 = dispatch_semaphore_create(0LL);
  uint64_t v84 = 0LL;
  char v85 = &v84;
  uint64_t v86 = 0x4002000000LL;
  char v87 = __Block_byref_object_copy_;
  unint64_t v88 = __Block_byref_object_dispose_;
  unsigned int v90 = 0LL;
  uint64_t v91 = 0LL;
  unint64_t v89 = 0LL;
  uint64_t v76 = 0LL;
  uint64_t v77 = &v76;
  uint64_t v78 = 0x4002000000LL;
  size_t v79 = __Block_byref_object_copy__10;
  __int128 v80 = __Block_byref_object_dispose__11;
  uint64_t v82 = 0LL;
  uint64_t v83 = 0LL;
  uint64_t v81 = 0LL;
  uint64_t v68 = 0LL;
  unint64_t v69 = &v68;
  uint64_t v70 = 0x4002000000LL;
  __int128 v71 = __Block_byref_object_copy__12;
  __int128 v72 = __Block_byref_object_dispose__13;
  std::string::size_type v74 = 0LL;
  uint64_t v75 = 0LL;
  std::string __p = 0LL;
  uint64_t v61 = 0LL;
  uint64_t v62 = &v61;
  uint64_t v63 = 0x4002000000LL;
  int16x8_t v64 = __Block_byref_object_copy__14;
  int v65 = __Block_byref_object_dispose__15;
  v67[0] = 0LL;
  v67[1] = 0LL;
  __int128 v66 = v67;
  CFBundleRef v8 = *(unsigned int (**)(uint64_t, void, uint64_t, void *))this;
  v58[0] = _NSConcreteStackBlock;
  v58[1] = 1107296256LL;
  v58[2] = ___ZN9Genealogy13GetActivitiesEiRK14MachThreadListj_block_invoke;
  v58[3] = &__block_descriptor_tmp_28;
  v58[4] = &v84;
  v58[5] = &v76;
  v58[9] = this;
  v58[10] = a3;
  int v59 = a2;
  int v60 = a4;
  v58[6] = &v68;
  v58[7] = &v61;
  v58[8] = &v92;
  if (v8(a2, 0LL, 9LL, v58))
  {
    dispatch_time_t v9 = dispatch_time(0LL, 500000000LL);
    if (dispatch_semaphore_wait((dispatch_semaphore_t)v93[3], v9))
    {
      *((_BYTE *)this + 128) = 1;
      goto LABEL_66;
    }
  }

  BOOL v10 = (uint64_t *)v62[5];
  if (v10 != v62 + 6)
  {
    do
    {
      uint64_t v12 = (__int128 *)v77[5];
      __int128 v11 = (__int128 *)v77[6];
      if (v12 == v11) {
        goto LABEL_59;
      }
      unint64_t v13 = (uint64_t *)v10[4];
      uint64_t v14 = v10[5];
      while (*((void *)v12 + 1) != v14)
      {
        uint64_t v12 = (__int128 *)((char *)v12 + 72);
        if (v12 == v11) {
          goto LABEL_59;
        }
      }

      __int128 v15 = operator new(0x78uLL);
      *(_OWORD *)__int128 v15 = 0u;
      *((_OWORD *)v15 + 1) = 0u;
      *((_OWORD *)v15 + 2) = 0u;
      *((_OWORD *)v15 + 4) = 0u;
      *((_OWORD *)v15 + 5) = 0u;
      *((_OWORD *)v15 + 6) = 0u;
      *((void *)v15 + 14) = 0LL;
      *((_OWORD *)v15 + 3) = 0u;
      uint64_t v16 = (std::__shared_weak_count *)operator new(0x20uLL);
      v16->__shared_owners_ = 0LL;
      p_shared_owners = (unint64_t *)&v16->__shared_owners_;
      v16->__vftable = (std::__shared_weak_count_vtbl *)off_100061458;
      v16->__shared_weak_owners_ = 0LL;
      v16[1].__vftable = (std::__shared_weak_count_vtbl *)v15;
      __int128 v18 = *v12;
      *((void *)v15 + 2) = *((void *)v12 + 2);
      *(_OWORD *)__int128 v15 = v18;
      std::string::operator=((std::string *)v15 + 1, (const std::string *)v12 + 1);
      std::string::operator=((std::string *)v15 + 2, (const std::string *)v12 + 2);
      unint64_t v19 = v85;
      uint64_t v20 = v85[5];
      if (v20 != v85[6])
      {
        do
        {
          if (*(void *)(v20 + 8) == v14)
          {
            unint64_t v22 = *((void *)v15 + 13);
            if (v22 >= *((void *)v15 + 14))
            {
              uint64_t v21 = std::vector<Genealogy::Breadcrumb>::__push_back_slow_path<Genealogy::Breadcrumb const&>( (uint64_t)v15 + 96,  v20);
            }

            else
            {
              __int128 v23 = *(_OWORD *)v20;
              *(void *)(v22 + 16) = *(void *)(v20 + 16);
              *(_OWORD *)unint64_t v22 = v23;
              int v24 = (std::string *)(v22 + 24);
              if (*(char *)(v20 + 47) < 0)
              {
                std::string::__init_copy_ctor_external( v24,  *(const std::string::value_type **)(v20 + 24),  *(void *)(v20 + 32));
              }

              else
              {
                __int128 v25 = *(_OWORD *)(v20 + 24);
                *(void *)(v22 + 40) = *(void *)(v20 + 40);
                *(_OWORD *)&v24->__r_.__value_.__l.__data_ = v25;
              }

              uint64_t v21 = (char *)(v22 + 48);
            }

            *((void *)v15 + 13) = v21;
            unint64_t v19 = v85;
          }

          v20 += 48LL;
        }

        while (v20 != v19[6]);
      }

      sockaddr v26 = v69;
      uint64_t v27 = v69[5];
      if (v27 != v69[6])
      {
        do
        {
          if (*(uint64_t **)(v27 + 24) == v13)
          {
            unint64_t v29 = *((void *)v15 + 10);
            if (v29 >= *((void *)v15 + 11))
            {
              __int128 v28 = std::vector<Genealogy::Message>::__push_back_slow_path<Genealogy::Message const&>( (uint64_t)v15 + 72,  v27);
            }

            else
            {
              __int128 v30 = *(_OWORD *)v27;
              __int128 v31 = *(_OWORD *)(v27 + 16);
              *(void *)(v29 + 32) = *(void *)(v27 + 32);
              *(_OWORD *)unint64_t v29 = v30;
              *(_OWORD *)(v29 + 16) = v31;
              __int128 v32 = (std::string *)(v29 + 40);
              if (*(char *)(v27 + 63) < 0)
              {
                std::string::__init_copy_ctor_external( v32,  *(const std::string::value_type **)(v27 + 40),  *(void *)(v27 + 48));
              }

              else
              {
                __int128 v33 = *(_OWORD *)(v27 + 40);
                *(void *)(v29 + 56) = *(void *)(v27 + 56);
                *(_OWORD *)&v32->__r_.__value_.__l.__data_ = v33;
              }

              __int128 v28 = (char *)(v29 + 64);
            }

            *((void *)v15 + 10) = v28;
            sockaddr v26 = v69;
          }

          v27 += 64LL;
        }

        while (v27 != v26[6]);
      }

      unint64_t v34 = (uint64_t **)((char *)this + 88);
      while (1)
      {
        uint64_t v35 = *v34;
        BOOL v36 = v34;
        if (!*v34) {
          break;
        }
        while (1)
        {
          unint64_t v34 = (uint64_t **)v35;
          unint64_t v37 = v35[4];
          uint64_t v35 = v34[1];
          if (!v35)
          {
            BOOL v36 = v34 + 1;
            goto LABEL_48;
          }
        }
      }

LABEL_66:
  _Block_object_dispose(&v61, 8);
  std::__tree<std::__value_type<unsigned int,DNBArchPluginInfoTag>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,DNBArchPluginInfoTag>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,DNBArchPluginInfoTag>>>::destroy( (uint64_t)&v66,  v67[0]);
  _Block_object_dispose(&v68, 8);
  int32x4_t v49 = (void **)__p;
  if (__p)
  {
    int v50 = v74;
    unint64_t v51 = __p;
    if (v74 != __p)
    {
      do
      {
        v50 -= 8;
      }

      while (v50 != v49);
      unint64_t v51 = __p;
    }

    std::string::size_type v74 = v49;
    operator delete(v51);
  }

  _Block_object_dispose(&v76, 8);
  uint64_t v52 = (void **)v81;
  if (!v81) {
    goto LABEL_85;
  }
  uint64_t v53 = v82;
  int v54 = v81;
  if (v82 != v81)
  {
    while (1)
    {
      if (*((char *)v53 - 1) < 0)
      {
        operator delete(*(v53 - 3));
        if (*((char *)v53 - 25) < 0) {
LABEL_82:
        }
          operator delete(*(v53 - 6));
      }

      else if (*((char *)v53 - 25) < 0)
      {
        goto LABEL_82;
      }

      v53 -= 9;
      if (v53 == v52)
      {
        int v54 = v81;
        break;
      }
    }
  }

  uint64_t v82 = v52;
  operator delete(v54);
LABEL_85:
  _Block_object_dispose(&v84, 8);
  std::locale v55 = v89;
  if (v89)
  {
    std::stringbuf v56 = v90;
    int v57 = v89;
    if (v90 != v89)
    {
      do
      {
        v56 -= 6;
      }

      while (v56 != v55);
      int v57 = v89;
    }

    unsigned int v90 = v55;
    operator delete(v57);
  }

  _Block_object_dispose(&v92, 8);
}

void Genealogy::Clear(Genealogy *this)
{
  uint64_t v1 = (char *)this + 88;
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>>>::destroy( (uint64_t)this + 80,  *((void **)this + 11));
  *((void *)v1 - 1) = v1;
  *(void *)uint64_t v1 = 0LL;
  *((void *)v1 + 1) = 0LL;
  v1[40] = 0;
}

__n128 __Block_byref_object_copy_(void *a1, uint64_t a2)
{
  a1[5] = 0LL;
  a1[6] = 0LL;
  a1[7] = 0LL;
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(void *)(a2 + 56);
  *(void *)(a2 + 40) = 0LL;
  *(void *)(a2 + 48) = 0LL;
  *(void *)(a2 + 56) = 0LL;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (v1)
  {
    uint64_t v3 = *(void *)(a1 + 48);
    glob_t v4 = *(void **)(a1 + 40);
    if (v3 != v1)
    {
      do
      {
        v3 -= 48LL;
      }

      while (v3 != v1);
      glob_t v4 = *(void **)(a1 + 40);
    }

    *(void *)(a1 + 48) = v1;
    operator delete(v4);
  }

__n128 __Block_byref_object_copy__10(void *a1, uint64_t a2)
{
  a1[5] = 0LL;
  a1[6] = 0LL;
  a1[7] = 0LL;
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(void *)(a2 + 56);
  *(void *)(a2 + 40) = 0LL;
  *(void *)(a2 + 48) = 0LL;
  *(void *)(a2 + 56) = 0LL;
  return result;
}

void __Block_byref_object_dispose__11(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (v1)
  {
    uint64_t v3 = *(void *)(a1 + 48);
    glob_t v4 = *(void **)(a1 + 40);
    if (v3 == v1)
    {
LABEL_12:
      *(void *)(a1 + 48) = v1;
      operator delete(v4);
      return;
    }

    while (1)
    {
      if (*(char *)(v3 - 1) < 0)
      {
        operator delete(*(void **)(v3 - 24));
        if (*(char *)(v3 - 25) < 0) {
LABEL_9:
        }
          operator delete(*(void **)(v3 - 48));
      }

      else if (*(char *)(v3 - 25) < 0)
      {
        goto LABEL_9;
      }

      v3 -= 72LL;
      if (v3 == v1)
      {
        glob_t v4 = *(void **)(a1 + 40);
        goto LABEL_12;
      }
    }
  }

__n128 __Block_byref_object_copy__12(void *a1, uint64_t a2)
{
  a1[5] = 0LL;
  a1[6] = 0LL;
  a1[7] = 0LL;
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(void *)(a2 + 56);
  *(void *)(a2 + 40) = 0LL;
  *(void *)(a2 + 48) = 0LL;
  *(void *)(a2 + 56) = 0LL;
  return result;
}

void __Block_byref_object_dispose__13(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (v1)
  {
    uint64_t v3 = *(void *)(a1 + 48);
    glob_t v4 = *(void **)(a1 + 40);
    if (v3 != v1)
    {
      do
      {
        v3 -= 64LL;
      }

      while (v3 != v1);
      glob_t v4 = *(void **)(a1 + 40);
    }

    *(void *)(a1 + 48) = v1;
    operator delete(v4);
  }

void *__Block_byref_object_copy__14(void *result, void *a2)
{
  result[5] = a2[5];
  uint64_t v2 = a2 + 6;
  uint64_t v3 = a2[6];
  result[6] = v3;
  glob_t v4 = result + 6;
  uint64_t v5 = a2[7];
  result[7] = v5;
  if (v5)
  {
    *(void *)(v3 + 16) = v4;
    a2[5] = v2;
    void *v2 = 0LL;
    a2[7] = 0LL;
  }

  else
  {
    result[5] = v4;
  }

  return result;
}

void __Block_byref_object_dispose__15(uint64_t a1)
{
}

uint64_t ___ZN9Genealogy13GetActivitiesEiRK14MachThreadListj_block_invoke(uint64_t a1, uint64_t a2, int a3)
{
  if (!a3)
  {
    v8[0] = _NSConcreteStackBlock;
    __int128 v4 = *(_OWORD *)(a1 + 72);
    uint64_t v5 = *(void (**)(uint64_t, void *))(*(void *)(a1 + 72) + 8LL);
    v8[1] = 1107296256LL;
    int v8[2] = ___ZN9Genealogy13GetActivitiesEiRK14MachThreadListj_block_invoke_2;
    v8[3] = &__block_descriptor_tmp_26;
    __int128 v11 = v4;
    uint64_t v12 = *(void *)(a1 + 88);
    __int128 v6 = *(_OWORD *)(a1 + 48);
    __int128 v9 = *(_OWORD *)(a1 + 32);
    __int128 v10 = v6;
    v5(a2, v8);
  }

  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL));
}

uint64_t ___ZN9Genealogy13GetActivitiesEiRK14MachThreadListj_block_invoke_2(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 80) == *(_DWORD *)(a2 + 56))
  {
    uint64_t v3 = *(void *)(a1 + 64);
    __int128 v4 = *(void (**)(uint64_t, void *))(v3 + 16);
    v37[0] = _NSConcreteStackBlock;
    v37[1] = 1107296256LL;
    v37[2] = ___ZN9Genealogy13GetActivitiesEiRK14MachThreadListj_block_invoke_3;
    v37[3] = &__block_descriptor_tmp;
    v37[4] = *(void *)(a1 + 32);
    v4(a2, v37);
    uint64_t v5 = *(void (**)(uint64_t, uint64_t, void *))(v3 + 32);
    uint64_t v6 = *(void *)(a2 + 16);
    v36[0] = _NSConcreteStackBlock;
    v36[1] = 1107296256LL;
    v36[2] = ___ZN9Genealogy13GetActivitiesEiRK14MachThreadListj_block_invoke_17;
    v36[3] = &__block_descriptor_tmp_19;
    v36[4] = *(void *)(a1 + 40);
    v5(v6, a2, v36);
    uint64_t v7 = *(void (**)(uint64_t, uint64_t, void *))(v3 + 24);
    uint64_t v8 = *(void *)(a2 + 8);
    v35[0] = _NSConcreteStackBlock;
    v35[1] = 1107296256LL;
    v35[2] = ___ZN9Genealogy13GetActivitiesEiRK14MachThreadListj_block_invoke_20;
    v35[3] = &__block_descriptor_tmp_22;
    v35[4] = *(void *)(a1 + 48);
    v35[5] = v3;
    v7(v8, a2, v35);
    uint64_t v9 = MachThreadList::NumThreads(*(MachThreadList **)(a1 + 72));
    if (v9)
    {
      uint64_t v10 = v9;
      for (unint64_t i = 0LL; i != v10; ++i)
      {
        unint64_t v12 = MachThreadList::ThreadIDAtIndex(*(MachThreadList **)(a1 + 72), i);
        unint64_t v13 = *(uint64_t (**)(void, unint64_t))(v3 + 64);
        if (v13)
        {
          uint64_t v14 = v13(*(unsigned int *)(a1 + 84), v12);
          if (v14) {
            goto LABEL_12;
          }
        }

        else
        {
          __int128 v15 = *(uint64_t (**)(uint64_t, unint64_t))(v3 + 56);
          if (v15)
          {
            uint64_t v14 = v15(a2, v12);
            if (v14)
            {
LABEL_12:
              uint64_t v16 = *(void *)(*(void *)(a1 + 56) + 8LL);
              __int128 v18 = (uint64_t **)(v16 + 48);
              uint64_t v17 = *(uint64_t **)(v16 + 48);
              if (v17)
              {
                while (1)
                {
                  while (1)
                  {
                    unint64_t v19 = (uint64_t **)v17;
                    unint64_t v20 = v17[4];
                    if (v12 >= v20) {
                      break;
                    }
                    uint64_t v17 = *v19;
                    __int128 v18 = v19;
                    if (!*v19) {
                      goto LABEL_19;
                    }
                  }

                  if (v20 >= v12) {
                    break;
                  }
                  uint64_t v17 = v19[1];
                  if (!v17)
                  {
                    __int128 v18 = v19 + 1;
                    goto LABEL_19;
                  }
                }
              }

              else
              {
                unint64_t v19 = (uint64_t **)(v16 + 48);
LABEL_19:
                uint64_t v21 = (uint64_t *)v19;
                unint64_t v19 = (uint64_t **)operator new(0x30uLL);
                v19[4] = (uint64_t *)v12;
                v19[5] = 0LL;
                *unint64_t v19 = 0LL;
                v19[1] = 0LL;
                v19[2] = v21;
                unint64_t *v18 = (uint64_t *)v19;
                uint64_t v22 = **(void **)(v16 + 40);
                __int128 v23 = (uint64_t *)v19;
                if (v22)
                {
                  *(void *)(v16 + 40) = v22;
                  __int128 v23 = *v18;
                }

                std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>( *(uint64_t **)(v16 + 48),  v23);
                ++*(void *)(v16 + 56);
              }

              v19[5] = (uint64_t *)v14;
            }
          }
        }
      }
    }

    if (*(void *)(a2 + 16))
    {
      int v24 = *(void **)(*(void *)(a1 + 56) + 8LL);
      if (v24[7])
      {
        __int128 v25 = (void *)v24[5];
        if (v25 != v24 + 6)
        {
          do
          {
            uint64_t v26 = v25[5];
            uint64_t v27 = (*(uint64_t (**)(uint64_t, uint64_t, void))(v3 + 72))(a2, v26, v25[4]);
            __int128 v28 = *(void (**)(uint64_t, uint64_t, void *))(v3 + 24);
            v34[0] = _NSConcreteStackBlock;
            v34[1] = 1107296256LL;
            v34[2] = ___ZN9Genealogy13GetActivitiesEiRK14MachThreadListj_block_invoke_23;
            v34[3] = &__block_descriptor_tmp_24;
            v34[5] = v3;
            v34[6] = v26;
            v34[4] = *(void *)(a1 + 48);
            v28(v27, a2, v34);
            unint64_t v29 = (void *)v25[1];
            if (v29)
            {
              do
              {
                __int128 v30 = v29;
                unint64_t v29 = (void *)*v29;
              }

              while (v29);
            }

            else
            {
              do
              {
                __int128 v30 = (void *)v25[2];
                BOOL v31 = *v30 == (void)v25;
                __int128 v25 = v30;
              }

              while (!v31);
            }

            __int128 v25 = v30;
          }

          while (v30 != (void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 48LL));
        }
      }
    }
  }

  return 1LL;
}

uint64_t ___ZN9Genealogy13GetActivitiesEiRK14MachThreadListj_block_invoke_3(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)__int128 v11 = *(_DWORD *)a2;
  *(_OWORD *)&v11[8] = *(_OWORD *)(a2 + 8);
  uint64_t v3 = *(const std::string::value_type **)(a2 + 24);
  if (v3) {
    std::string::assign(&__p, v3);
  }
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8LL);
  unint64_t v5 = *(void *)(v4 + 48);
  if (v5 >= *(void *)(v4 + 56))
  {
    uint64_t v9 = std::vector<Genealogy::Breadcrumb>::__push_back_slow_path<Genealogy::Breadcrumb const&>(v4 + 40, (uint64_t)v11);
  }

  else
  {
    __int128 v6 = *(_OWORD *)v11;
    *(void *)(v5 + 16) = *(void *)&v11[16];
    *(_OWORD *)unint64_t v5 = v6;
    uint64_t v7 = (std::string *)(v5 + 24);
    if ((char)__p.__r_.__value_.__s.__size_ < 0)
    {
      std::string::__init_copy_ctor_external(v7, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }

    else
    {
      __int128 v8 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *(void *)(v5 + 40) = __p.__r_.__value_.__l.__cap_;
      *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v8;
    }

    uint64_t v9 = (char *)(v5 + 48);
  }

  *(void *)(v4 + 48) = v9;
  return 1LL;
}

void __copy_helper_block_8_32r(uint64_t a1, uint64_t a2)
{
}

void __destroy_helper_block_8_32r(uint64_t a1)
{
}

uint64_t ___ZN9Genealogy13GetActivitiesEiRK14MachThreadListj_block_invoke_17(uint64_t a1, __int128 *a2)
{
  *(_OWORD *)__int128 v18 = 0u;
  __int128 v16 = *a2;
  uint64_t v5 = *((void *)a2 + 2);
  uint64_t v4 = (const std::string::value_type *)*((void *)a2 + 3);
  uint64_t v17 = v5;
  if (v4) {
    std::string::assign((std::string *)v18, v4);
  }
  __int128 v6 = (const std::string::value_type *)*((void *)a2 + 4);
  if (v6) {
    std::string::assign((std::string *)&__p[1], v6);
  }
  uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8LL);
  unint64_t v8 = *(void *)(v7 + 48);
  if (v8 >= *(void *)(v7 + 56))
  {
    unint64_t v12 = std::vector<Genealogy::Activity>::__push_back_slow_path<Genealogy::Activity const&>( (void **)(v7 + 40),  (uint64_t)&v16);
  }

  else
  {
    __int128 v9 = v16;
    *(void *)(v8 + 16) = v17;
    *(_OWORD *)unint64_t v8 = v9;
    uint64_t v10 = (std::string *)(v8 + 24);
    if (SHIBYTE(__p[0]) < 0)
    {
      std::string::__init_copy_ctor_external( v10,  (const std::string::value_type *)v18[0],  (std::string::size_type)v18[1]);
    }

    else
    {
      __int128 v11 = *(_OWORD *)v18;
      *(void **)(v8 + 40) = __p[0];
      *(_OWORD *)&v10->__r_.__value_.__l.__data_ = v11;
    }

    unint64_t v13 = (std::string *)(v8 + 48);
    if (SHIBYTE(__p[3]) < 0)
    {
      std::string::__init_copy_ctor_external( v13,  (const std::string::value_type *)__p[1],  (std::string::size_type)__p[2]);
    }

    else
    {
      __int128 v14 = *(_OWORD *)&__p[1];
      *(void **)(v8 + 64) = __p[3];
      *(_OWORD *)&v13->__r_.__value_.__l.__data_ = v14;
    }

    unint64_t v12 = (char *)(v8 + 72);
  }

  *(void *)(v7 + 48) = v12;
  if (SHIBYTE(__p[3]) < 0)
  {
    operator delete(__p[1]);
    if ((SHIBYTE(__p[0]) & 0x80000000) == 0) {
      return 1LL;
    }
LABEL_18:
    operator delete(v18[0]);
    return 1LL;
  }

  if (SHIBYTE(__p[0]) < 0) {
    goto LABEL_18;
  }
  return 1LL;
}

uint64_t ___ZN9Genealogy13GetActivitiesEiRK14MachThreadListj_block_invoke_20(uint64_t a1, __int128 *a2)
{
  uint64_t v3 = a1;
  uint64_t v4 = *(void *)(a1 + 40);
  memset(&__p, 0, sizeof(__p));
  __int128 v33 = *((unint64_t *)a2 + 2);
  __int128 v34 = *a2;
  LOBYTE(v35) = (*(uint64_t (**)(__int128 *))(v4 + 40))(a2);
  uint64_t v5 = (const unsigned __int8 *)*((void *)a2 + 5);
  if (!v5 || !*((void *)a2 + 6)) {
    goto LABEL_24;
  }
  __int128 v6 = operator new(0x28uLL);
  *(_OWORD *)__int128 v6 = 0u;
  *((_OWORD *)v6 + 1) = 0u;
  *((void *)v6 + 4) = 0LL;
  uint64_t v7 = (std::__shared_weak_count *)operator new(0x20uLL);
  v7->__shared_owners_ = 0LL;
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  v7->__vftable = (std::__shared_weak_count_vtbl *)off_100061420;
  v7->__shared_weak_owners_ = 0LL;
  v7[1].__vftable = (std::__shared_weak_count_vtbl *)v6;
  uuid_copy((unsigned __int8 *)v6 + 24, v5);
  std::string::assign((std::string *)v6, *((const std::string::value_type **)a2 + 6));
  *(void *)&__int128 v32 = v6;
  *((void *)&v32 + 1) = v7;
  do
    unint64_t v9 = __ldxr(p_shared_owners);
  while (__stxr(v9 + 1, p_shared_owners));
  uint64_t v10 = *(void **)(v4 + 112);
  unint64_t v11 = (unint64_t)v10 - *(void *)(v4 + 104);
  unint64_t v12 = v11 >> 4;
  if ((v11 >> 4))
  {
    unint64_t v30 = v11 >> 4;
    uint64_t v31 = v3;
    uint64_t v13 = 0LL;
    unint64_t v12 = 0LL;
    uint64_t v14 = (v11 >> 4);
    while (uuid_compare( (const unsigned __int8 *)(*(void *)(*(void *)(v4 + 104) + v13) + 24LL),  (const unsigned __int8 *)v6 + 24))
    {
      ++v12;
      v13 += 16LL;
      if (v14 == v12)
      {
        uint64_t v10 = *(void **)(v4 + 112);
        LODWORD(v12) = v30;
        uint64_t v3 = v31;
        goto LABEL_10;
      }
    }

    uint64_t v3 = v31;
    goto LABEL_15;
  }

uint64_t ___ZN9Genealogy13GetActivitiesEiRK14MachThreadListj_block_invoke_23(uint64_t a1, __int128 *a2)
{
  uint64_t v3 = a1;
  uint64_t v4 = *(void *)(a1 + 40);
  memset(&__p, 0, sizeof(__p));
  *(void *)&__int128 v33 = *((void *)a2 + 2);
  __int128 v34 = *a2;
  LOBYTE(v35) = (*(uint64_t (**)(__int128 *))(v4 + 40))(a2);
  *((void *)&v33 + 1) = *(void *)(v3 + 48);
  uint64_t v5 = (const unsigned __int8 *)*((void *)a2 + 5);
  if (!v5 || !*((void *)a2 + 6)) {
    goto LABEL_24;
  }
  __int128 v6 = operator new(0x28uLL);
  *(_OWORD *)__int128 v6 = 0u;
  *((_OWORD *)v6 + 1) = 0u;
  *((void *)v6 + 4) = 0LL;
  uint64_t v7 = (std::__shared_weak_count *)operator new(0x20uLL);
  v7->__shared_owners_ = 0LL;
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  v7->__vftable = (std::__shared_weak_count_vtbl *)off_100061420;
  v7->__shared_weak_owners_ = 0LL;
  v7[1].__vftable = (std::__shared_weak_count_vtbl *)v6;
  uuid_copy((unsigned __int8 *)v6 + 24, v5);
  std::string::assign((std::string *)v6, *((const std::string::value_type **)a2 + 6));
  *(void *)&__int128 v32 = v6;
  *((void *)&v32 + 1) = v7;
  do
    unint64_t v9 = __ldxr(p_shared_owners);
  while (__stxr(v9 + 1, p_shared_owners));
  uint64_t v10 = *(void **)(v4 + 112);
  unint64_t v11 = (unint64_t)v10 - *(void *)(v4 + 104);
  unint64_t v12 = v11 >> 4;
  if ((v11 >> 4))
  {
    unint64_t v30 = v11 >> 4;
    uint64_t v31 = v3;
    uint64_t v13 = 0LL;
    unint64_t v12 = 0LL;
    uint64_t v14 = (v11 >> 4);
    while (uuid_compare( (const unsigned __int8 *)(*(void *)(*(void *)(v4 + 104) + v13) + 24LL),  (const unsigned __int8 *)v6 + 24))
    {
      ++v12;
      v13 += 16LL;
      if (v14 == v12)
      {
        uint64_t v10 = *(void **)(v4 + 112);
        LODWORD(v12) = v30;
        uint64_t v3 = v31;
        goto LABEL_10;
      }
    }

    uint64_t v3 = v31;
    goto LABEL_15;
  }

void __copy_helper_block_8_32r40r48r56r(uint64_t a1, const void **a2)
{
}

void __destroy_helper_block_8_32r40r48r56r(const void **a1)
{
}

void __copy_helper_block_8_32r40r48r56r64r(uint64_t a1, const void **a2)
{
}

void __destroy_helper_block_8_32r40r48r56r64r(const void **a1)
{
}

uint64_t Genealogy::GetProcessExecutableInfosAtIndex@<X0>( uint64_t this@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  *a3 = 0LL;
  a3[1] = 0LL;
  if (a2)
  {
    uint64_t v3 = a2 - 1;
    uint64_t v4 = *(void *)(this + 104);
    if (a2 - 1 <= (unint64_t)((*(void *)(this + 112) - v4) >> 4))
    {
      __int128 v5 = *(_OWORD *)(v4 + 16 * v3);
      uint64_t v6 = *(void *)(v4 + 16 * v3 + 8);
      if (v6)
      {
        uint64_t v7 = (unint64_t *)(v6 + 8);
        do
          unint64_t v8 = __ldxr(v7);
        while (__stxr(v8 + 1, v7));
      }

      *(_OWORD *)a3 = v5;
    }
  }

  return this;
}

void std::__tree<std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>>>::destroy( uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>>>::destroy( a1,  *a2);
    std::__tree<std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>>>::destroy( a1,  a2[1]);
    uint64_t v4 = (std::__shared_weak_count *)a2[6];
    if (v4)
    {
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        unint64_t v6 = __ldaxr(p_shared_owners);
      while (__stlxr(v6 - 1, p_shared_owners));
      if (!v6)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }

    operator delete(a2);
  }

char *std::vector<Genealogy::Breadcrumb>::__push_back_slow_path<Genealogy::Breadcrumb const&>( uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void ***)a1;
  uint64_t v3 = *(void ***)(a1 + 8);
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v3 - *(void *)a1) >> 4);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x555555555555555LL) {
    abort();
  }
  else {
    unint64_t v8 = v5;
  }
  if (v8)
  {
    if (v8 > 0x555555555555555LL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    unint64_t v9 = (char *)operator new(48 * v8);
  }

  else
  {
    unint64_t v9 = 0LL;
  }

  uint64_t v10 = (std::string *)&v9[48 * v4];
  *(_OWORD *)&v10->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
  v10->__r_.__value_.__l.__cap_ = *(void *)(a2 + 16);
  unint64_t v11 = v10 + 1;
  if (*(char *)(a2 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(v11, *(const std::string::value_type **)(a2 + 24), *(void *)(a2 + 32));
    uint64_t v2 = *(void ***)a1;
    uint64_t v3 = *(void ***)(a1 + 8);
  }

  else
  {
    *(_OWORD *)&v11->__r_.__value_.__l.__data_ = *(_OWORD *)(a2 + 24);
    v10[1].__r_.__value_.__l.__cap_ = *(void *)(a2 + 40);
  }

  unint64_t v12 = &v9[48 * v8];
  uint64_t v13 = (char *)&v10[2];
  if (v3 == v2)
  {
    *(void *)a1 = v10;
    *(void *)(a1 + 8) = v13;
    *(void *)(a1 + 16) = v12;
  }

  else
  {
    do
    {
      __int128 v14 = *((_OWORD *)v3 - 3);
      v10[-2].__r_.__value_.__l.__cap_ = (std::string::size_type)*(v3 - 4);
      *(_OWORD *)&v10[-2].__r_.__value_.__l.__data_ = v14;
      __int128 v15 = *(_OWORD *)(v3 - 3);
      v10[-1].__r_.__value_.__l.__cap_ = (std::string::size_type)*(v3 - 1);
      *(_OWORD *)&v10[-1].__r_.__value_.__l.__data_ = v15;
      v10 -= 2;
      *(v3 - 2) = 0LL;
      *(v3 - 1) = 0LL;
      *(v3 - 3) = 0LL;
      v3 -= 6;
    }

    while (v3 != v2);
    uint64_t v2 = *(void ***)a1;
    __int128 v16 = *(void ***)(a1 + 8);
    *(void *)a1 = v10;
    *(void *)(a1 + 8) = v13;
    *(void *)(a1 + 16) = v12;
    while (v16 != v2)
    {
      v16 -= 6;
    }
  }

  if (v2) {
    operator delete(v2);
  }
  return v13;
}

char *std::vector<Genealogy::Activity>::__push_back_slow_path<Genealogy::Activity const&>( void **a1, uint64_t a2)
{
  unint64_t v2 = 0x8E38E38E38E38E39LL * (((_BYTE *)a1[1] - (_BYTE *)*a1) >> 3);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0x38E38E38E38E38ELL) {
    abort();
  }
  if (0x1C71C71C71C71C72LL * (((_BYTE *)a1[2] - (_BYTE *)*a1) >> 3) > v3) {
    unint64_t v3 = 0x1C71C71C71C71C72LL * (((_BYTE *)a1[2] - (_BYTE *)*a1) >> 3);
  }
  if (0x8E38E38E38E38E39LL * (((_BYTE *)a1[2] - (_BYTE *)*a1) >> 3) >= 0x1C71C71C71C71C7LL) {
    unint64_t v6 = 0x38E38E38E38E38ELL;
  }
  else {
    unint64_t v6 = v3;
  }
  if (v6)
  {
    if (v6 > 0x38E38E38E38E38ELL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v7 = operator new(72 * v6);
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  unint64_t v8 = (std::string *)&v7[9 * v2];
  *(_OWORD *)&v8->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
  v8->__r_.__value_.__l.__cap_ = *(void *)(a2 + 16);
  unint64_t v9 = v8 + 1;
  if (*(char *)(a2 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)(a2 + 24), *(void *)(a2 + 32));
  }

  else
  {
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = *(_OWORD *)(a2 + 24);
    v8[1].__r_.__value_.__l.__cap_ = *(void *)(a2 + 40);
  }

  uint64_t v10 = (std::string *)&v7[9 * v2 + 6];
  if (*(char *)(a2 + 71) < 0)
  {
    std::string::__init_copy_ctor_external(v10, *(const std::string::value_type **)(a2 + 48), *(void *)(a2 + 56));
  }

  else
  {
    *(_OWORD *)&v10->__r_.__value_.__l.__data_ = *(_OWORD *)(a2 + 48);
    v7[9 * v2 + 8] = *(void *)(a2 + 64);
  }

  unint64_t v11 = (char *)&v7[9 * v6];
  unint64_t v12 = (char *)&v8[3];
  uint64_t v13 = (void **)*a1;
  __int128 v14 = (void **)a1[1];
  if (v14 != *a1)
  {
    do
    {
      __int128 v15 = *(_OWORD *)(v14 - 9);
      v8[-3].__r_.__value_.__l.__cap_ = (std::string::size_type)*(v14 - 7);
      *(_OWORD *)&v8[-3].__r_.__value_.__l.__data_ = v15;
      __int128 v16 = *((_OWORD *)v14 - 3);
      v8[-2].__r_.__value_.__l.__cap_ = (std::string::size_type)*(v14 - 4);
      *(_OWORD *)&v8[-2].__r_.__value_.__l.__data_ = v16;
      *(v14 - 5) = 0LL;
      *(v14 - 4) = 0LL;
      *(v14 - 6) = 0LL;
      __int128 v17 = *(_OWORD *)(v14 - 3);
      v8[-1].__r_.__value_.__l.__cap_ = (std::string::size_type)*(v14 - 1);
      *(_OWORD *)&v8[-1].__r_.__value_.__l.__data_ = v17;
      v8 -= 3;
      *(v14 - 2) = 0LL;
      *(v14 - 1) = 0LL;
      *(v14 - 3) = 0LL;
      v14 -= 9;
    }

    while (v14 != v13);
    __int128 v14 = (void **)*a1;
    __int128 v18 = (void **)a1[1];
    *a1 = v8;
    a1[1] = v12;
    a1[2] = v11;
    while (1)
    {
      if (v18 == v14) {
        goto LABEL_28;
      }
      if (*((char *)v18 - 1) < 0)
      {
        operator delete(*(v18 - 3));
      }

      else if ((*((char *)v18 - 25) & 0x80000000) == 0)
      {
        goto LABEL_20;
      }

      operator delete(*(v18 - 6));
LABEL_20:
      v18 -= 9;
    }
  }

  *a1 = v8;
  a1[1] = v12;
  a1[2] = v11;
LABEL_28:
  if (v14) {
    operator delete(v14);
  }
  return v12;
}

void std::__shared_ptr_pointer<Genealogy::ProcessExecutableInfo *,std::shared_ptr<Genealogy::ProcessExecutableInfo>::__shared_ptr_default_delete<Genealogy::ProcessExecutableInfo,Genealogy::ProcessExecutableInfo>,std::allocator<Genealogy::ProcessExecutableInfo>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void std::__shared_ptr_pointer<Genealogy::ProcessExecutableInfo *,std::shared_ptr<Genealogy::ProcessExecutableInfo>::__shared_ptr_default_delete<Genealogy::ProcessExecutableInfo,Genealogy::ProcessExecutableInfo>,std::allocator<Genealogy::ProcessExecutableInfo>>::__on_zero_shared( uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1)
  {
    operator delete((void *)v1);
  }

char *std::vector<Genealogy::Message>::__push_back_slow_path<Genealogy::Message const&>( uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void ***)a1;
  unint64_t v3 = *(void ***)(a1 + 8);
  uint64_t v4 = ((uint64_t)v3 - *(void *)a1) >> 6;
  unint64_t v5 = v4 + 1;
  uint64_t v8 = *(void *)(a1 + 16) - (void)v2;
  if (v8 >> 5 > v5) {
    unint64_t v5 = v8 >> 5;
  }
  else {
    unint64_t v9 = v5;
  }
  if (v9)
  {
    if (v9 >> 58) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v10 = (char *)operator new(v9 << 6);
  }

  else
  {
    uint64_t v10 = 0LL;
  }

  unint64_t v11 = &v10[64 * v4];
  __int128 v12 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)unint64_t v11 = *(_OWORD *)a2;
  *((_OWORD *)v11 + 1) = v12;
  *((void *)v11 + 4) = *(void *)(a2 + 32);
  uint64_t v13 = (std::string *)(v11 + 40);
  if (*(char *)(a2 + 63) < 0)
  {
    std::string::__init_copy_ctor_external(v13, *(const std::string::value_type **)(a2 + 40), *(void *)(a2 + 48));
    unint64_t v2 = *(void ***)a1;
    unint64_t v3 = *(void ***)(a1 + 8);
  }

  else
  {
    *(_OWORD *)&v13->__r_.__value_.__l.__data_ = *(_OWORD *)(a2 + 40);
    *((void *)v11 + 7) = *(void *)(a2 + 56);
  }

  __int128 v14 = &v10[64 * v9];
  __int128 v15 = v11 + 64;
  if (v3 == v2)
  {
    *(void *)a1 = v11;
    *(void *)(a1 + 8) = v15;
    *(void *)(a1 + 16) = v14;
  }

  else
  {
    do
    {
      __int128 v16 = *((_OWORD *)v3 - 4);
      __int128 v17 = *((_OWORD *)v3 - 3);
      *((void *)v11 - 4) = *(v3 - 4);
      *((_OWORD *)v11 - 4) = v16;
      *((_OWORD *)v11 - 3) = v17;
      __int128 v18 = *(_OWORD *)(v3 - 3);
      *((void *)v11 - 1) = *(v3 - 1);
      *(_OWORD *)(v11 - 24) = v18;
      v11 -= 64;
      *(v3 - 2) = 0LL;
      *(v3 - 1) = 0LL;
      *(v3 - 3) = 0LL;
      v3 -= 8;
    }

    while (v3 != v2);
    unint64_t v2 = *(void ***)a1;
    unint64_t v19 = *(void ***)(a1 + 8);
    *(void *)a1 = v11;
    *(void *)(a1 + 8) = v15;
    *(void *)(a1 + 16) = v14;
    while (v19 != v2)
    {
      v19 -= 8;
    }
  }

  if (v2) {
    operator delete(v2);
  }
  return v15;
}

void std::__shared_ptr_pointer<Genealogy::ThreadActivity *,std::shared_ptr<Genealogy::ThreadActivity>::__shared_ptr_default_delete<Genealogy::ThreadActivity,Genealogy::ThreadActivity>,std::allocator<Genealogy::ThreadActivity>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void std::__shared_ptr_pointer<Genealogy::ThreadActivity *,std::shared_ptr<Genealogy::ThreadActivity>::__shared_ptr_default_delete<Genealogy::ThreadActivity,Genealogy::ThreadActivity>,std::allocator<Genealogy::ThreadActivity>>::__on_zero_shared( uint64_t a1)
{
  uint64_t v1 = *(Genealogy::ThreadActivity **)(a1 + 24);
  if (v1)
  {
    Genealogy::ThreadActivity::~ThreadActivity(v1);
    operator delete(v2);
  }

void Genealogy::ThreadActivity::~ThreadActivity(Genealogy::ThreadActivity *this)
{
  uint64_t v2 = *((void *)this + 12);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 13);
    uint64_t v4 = (void *)*((void *)this + 12);
    if (v3 != v2)
    {
      do
      {
        v3 -= 48LL;
      }

      while (v3 != v2);
      uint64_t v4 = (void *)*((void *)this + 12);
    }

    *((void *)this + 13) = v2;
    operator delete(v4);
  }

  uint64_t v5 = *((void *)this + 9);
  if (v5)
  {
    uint64_t v6 = *((void *)this + 10);
    uint64_t v7 = (void *)*((void *)this + 9);
    if (v6 != v5)
    {
      do
      {
        v6 -= 64LL;
      }

      while (v6 != v5);
      uint64_t v7 = (void *)*((void *)this + 9);
    }

    *((void *)this + 10) = v5;
    operator delete(v7);
  }

  if ((*((char *)this + 71) & 0x80000000) == 0)
  {
LABEL_21:
    operator delete(*((void **)this + 3));
    return;
  }

  operator delete(*((void **)this + 6));
}

uint64_t catch_mach_exception_raise_state(int a1, int a2, uint64_t a3, int a4)
{
  if (DNBLogCheckLogBit(8) && DNBLogEnabled())
  {
    else {
      uint64_t v8 = off_100061480[a2 - 1];
    }
    _DNBLogThreaded( "::%s(exc_port = 0x%4.4x, exc_type = %d(%s), exc_int data = 0x%llx, exc_data_count = %d)",  "catch_mach_exception_raise_state",  a1,  a2,  v8,  a3,  a4);
  }

  return 5LL;
}

uint64_t catch_mach_exception_raise_state_identity(int a1, int a2, int a3, int a4, uint64_t *a5, int a6)
{
  if (DNBLogCheckLogBit(8) && DNBLogEnabled())
  {
    else {
      __int128 v12 = off_100061480[a4 - 1];
    }
    uint64_t v13 = 3135093469LL;
    if (a6)
    {
      uint64_t v14 = *a5;
      if (a6 != 1) {
        uint64_t v13 = a5[1];
      }
    }

    else
    {
      uint64_t v14 = 3135093469LL;
    }

    _DNBLogThreaded( "::%s(exc_port = 0x%4.4x, thd_port = 0x%4.4x, tsk_port = 0x%4.4x, exc_type = %d(%s), exc_data[%d] = { 0x%llx, 0x%llx })",  "catch_mach_exception_raise_state_identity",  a1,  a2,  a3,  a4,  v12,  a6,  v14,  v13);
  }

  return 5LL;
}

uint64_t catch_mach_exception_raise( int a1, unsigned int a2, unsigned int a3, unsigned int a4, uint64_t *a5, unsigned int a6)
{
  if (DNBLogCheckLogBit(8) && DNBLogEnabled())
  {
    if (a4 - 1 > 0xC) {
      uint64_t v14 = 0LL;
    }
    else {
      uint64_t v14 = off_100061480[a4 - 1];
    }
    uint64_t v15 = 3135093469LL;
    if (a6)
    {
      uint64_t v16 = *a5;
      if (a6 != 1) {
        uint64_t v15 = a5[1];
      }
    }

    else
    {
      uint64_t v16 = 3135093469LL;
    }

    _DNBLogThreaded( "::%s(exc_port = 0x%4.4x, thd_port = 0x%4.4x, tsk_port = 0x%4.4x, exc_type = %d(%s), exc_data[%d] = { 0x%llx, 0x%llx })",  "catch_mach_exception_raise",  a1,  a2,  a3,  a4,  v14,  a6,  v16,  v15);
  }

  __int128 v17 = (unsigned int *)g_message;
  *(_DWORD *)(g_message + 8) = 0;
  *((void *)v17 + 3) = *((void *)v17 + 2);
  if (*v17 == a3)
  {
    *__int128 v17 = a3;
    v17[1] = a2;
    v17[2] = a4;
    __int128 v18 = a5;
    unsigned int v19 = a6;
LABEL_13:
    MachException::Data::AppendExceptionData((MachException::Data *)v17, v18, v19);
    return 0LL;
  }

  uint64_t result = 5LL;
  if (a4 == 5 && a6 == 2 && *a5 == 65539 && a5[1] == 5)
  {
    uint64_t v21 = g_message;
    *(_DWORD *)g_message = a3;
    *(_DWORD *)(v21 + 4) = a2;
    *(_DWORD *)(v21 + 8) = 5;
    __int128 v17 = (unsigned int *)v21;
    __int128 v18 = a5;
    unsigned int v19 = 2;
    goto LABEL_13;
  }

  return result;
}

void MachException::Data::AppendExceptionData(MachException::Data *this, uint64_t *a2, unsigned int a3)
{
  if (a3)
  {
    uint64_t v5 = 0LL;
    uint64_t v6 = (char *)*((void *)this + 3);
    uint64_t v7 = a3;
    uint64_t v28 = a3;
    while (1)
    {
      uint64_t v9 = a2[v5];
      unint64_t v10 = *((void *)this + 4);
      *(void *)uint64_t v6 = v9;
      uint64_t v8 = v6 + 8;
LABEL_4:
      *((void *)this + 3) = v8;
      ++v5;
      uint64_t v6 = v8;
      if (v5 == v7) {
        return;
      }
    }

    unint64_t v11 = (char *)*((void *)this + 2);
    uint64_t v12 = (v6 - v11) >> 3;
    unint64_t v13 = v12 + 1;
    uint64_t v14 = v10 - (void)v11;
    if (v14 >> 2 > v13) {
      unint64_t v13 = v14 >> 2;
    }
    else {
      unint64_t v15 = v13;
    }
    if (v15)
    {
      if (v15 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v16 = operator new(8 * v15);
    }

    else
    {
      uint64_t v16 = 0LL;
    }

    __int128 v17 = (uint64_t *)&v16[8 * v12];
    *__int128 v17 = v9;
    uint64_t v8 = (char *)(v17 + 1);
    if (v6 == v11) {
      goto LABEL_29;
    }
    unint64_t v18 = v6 - v11 - 8;
    if (v18 < 0x168)
    {
      unsigned int v19 = v6;
      goto LABEL_28;
    }

    unint64_t v20 = (v6 - 8 - v11) & 0xFFFFFFFFFFFFFFF8LL;
    if (&v16[v6 - v11 - 8 - v20] > &v16[v6 - v11 - 8])
    {
      unsigned int v19 = v6;
    }

    else
    {
      if (&v6[-v20 - 8] <= v6 - 8)
      {
        if ((unint64_t)(v11 - v16) < 0x20)
        {
          unsigned int v19 = v6;
          goto LABEL_28;
        }

        uint64_t v21 = (v18 >> 3) + 1;
        uint64_t v22 = 8 * (v21 & 0x3FFFFFFFFFFFFFFCLL);
        unsigned int v19 = &v6[-v22];
        __int128 v17 = (uint64_t *)((char *)v17 - v22);
        unint64_t v23 = &v16[8 * v12 - 16];
        __int128 v24 = v6 - 16;
        uint64_t v25 = v21 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          __int128 v26 = *(_OWORD *)v24;
          *(v23 - 1) = *((_OWORD *)v24 - 1);
          *unint64_t v23 = v26;
          v23 -= 2;
          v24 -= 32;
          v25 -= 4LL;
        }

        while (v25);
        if (v21 != (v21 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_28;
        }
LABEL_29:
        *((void *)this + 2) = v17;
        *((void *)this + 3) = v8;
        *((void *)this + 4) = &v16[8 * v15];
        if (v11) {
          operator delete(v11);
        }
        uint64_t v7 = v28;
        goto LABEL_4;
      }

      unsigned int v19 = v6;
    }

    do
    {
LABEL_28:
      uint64_t v27 = *((void *)v19 - 1);
      v19 -= 8;
      *--__int128 v17 = v27;
    }

    while (v19 != v11);
    goto LABEL_29;
  }

void MachException::Message::Dump(MachException::Message *this)
{
  if (DNBLogEnabledForAny(8)) {
    _DNBLogThreaded( "  exc_msg { bits = 0x%8.8x CFIndex size = 0x%8.8x remote-port = 0x%8.8x local-port = 0x%8.8x reserved = 0x%8.8x id = 0x%8.8x } ",  *(_DWORD *)this,  *((_DWORD *)this + 1),  *((_DWORD *)this + 2),  *((_DWORD *)this + 3),  *((_DWORD *)this + 4),  *((_DWORD *)this + 5));
  }
  if (DNBLogEnabledForAny(8)) {
    _DNBLogThreaded( "reply_msg { bits = 0x%8.8x CFIndex size = 0x%8.8x remote-port = 0x%8.8x local-port = 0x%8.8x reserved = 0x%8.8x id = 0x%8.8x }",  *((_DWORD *)this + 256),  *((_DWORD *)this + 257),  *((_DWORD *)this + 258),  *((_DWORD *)this + 259),  *((_DWORD *)this + 260),  *((_DWORD *)this + 261));
  }
  MachException::Data::Dump((MachException::Message *)((char *)this + 2048));
}

void MachException::Data::Dump(MachException::Data *this)
{
  unsigned int v2 = *((_DWORD *)this + 2) - 1;
  if (v2 > 0xC) {
    uint64_t v3 = "???";
  }
  else {
    uint64_t v3 = off_100061480[v2];
  }
  if (DNBLogEnabledForAny(8)) {
    _DNBLogThreaded( "    state { task_port = 0x%4.4x, thread_port =  0x%4.4x, exc_type = %i (%s) ...",  *(_DWORD *)this,  *((_DWORD *)this + 1),  *((_DWORD *)this + 2),  v3);
  }
  uint64_t v5 = *((void *)this + 2);
  uint64_t v4 = *((void *)this + 3);
  uint64_t v6 = v4 - v5;
  BOOL v7 = *((_DWORD *)this + 2) == 5 && v6 == 16;
  if (v7 && *(void *)v5 == 65539LL && (int v8 = *(_DWORD *)(v5 + 8)) != 0)
  {
    uint64_t v9 = SysSignal::Name((SysSignal *)*(unsigned int *)(v5 + 8));
    if (DNBLogEnabledForAny(8))
    {
      unint64_t v10 = "unknown signal";
      if (v9) {
        unint64_t v10 = v9;
      }
      _DNBLogThreaded("            exc_data: EXC_SOFT_SIGNAL (%i (%s))", v8, v10);
    }
  }

  else if (v4 != v5)
  {
    uint64_t v11 = 0LL;
    unint64_t v12 = v6 >> 3;
    if (v12 <= 1) {
      uint64_t v13 = 1LL;
    }
    else {
      uint64_t v13 = v12;
    }
    do
    {
      if (DNBLogEnabledForAny(8)) {
        _DNBLogThreaded("            exc_data[%llu]: 0x%llx", v11, *(void *)(*((void *)this + 2) + 8 * v11));
      }
      ++v11;
    }

    while (v13 != v11);
  }

uint64_t MachException::Data::GetStopInfo(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 336) = 0LL;
  *(_OWORD *)(a2 + 304) = 0u;
  *(_OWORD *)(a2 + 320) = 0u;
  *(_OWORD *)(a2 + 272) = 0u;
  *(_OWORD *)(a2 + 288) = 0u;
  *(_OWORD *)(a2 + 240) = 0u;
  *(_OWORD *)(a2 + 256) = 0u;
  *(_OWORD *)(a2 + 208) = 0u;
  *(_OWORD *)(a2 + 224) = 0u;
  *(_OWORD *)(a2 + 176) = 0u;
  *(_OWORD *)(a2 + 192) = 0u;
  *(_OWORD *)(a2 + 144) = 0u;
  *(_OWORD *)(a2 + 160) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 128) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + memset(__p, 0, 32) = 0u;
  *(_OWORD *)a2 = 0u;
  int v2 = *(_DWORD *)(a1 + 8);
  if (!v2) {
    return 1LL;
  }
  if (v2 == 6)
  {
    uint64_t v5 = *(void **)(a1 + 16);
    if (*v5 == 258LL && *(void *)(a1 + 24) - (void)v5 >= 9uLL)
    {
      *(_DWORD *)a2 = 4;
      *(void *)(a2 + 264) = v5[1];
      *(void *)(a2 + 272) = -1LL;
      uint64_t v6 = *(void *)(a1 + 16);
      return 1LL;
    }
  }

  *(_DWORD *)a2 = 2;
  *(_DWORD *)(a2 + 264) = v2;
  else {
    int v7 = snprintf((char *)(a2 + 4), 0x100uLL, "%s");
  }
  unint64_t v8 = a2 + 260;
  uint64_t v9 = (char *)(a2 + v7 + 4);
  uint64_t v10 = (uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 3;
  *(void *)(a2 + 272) = v10;
  if (*(_DWORD *)(a1 + 8) == 5
    && (uint64_t v11 = *(void *)(a1 + 16), *(void *)(a1 + 24) - v11 == 16)
    && *(void *)v11 == 65539LL
    && (int v12 = *(_DWORD *)(v11 + 8)) != 0)
  {
    if ((unint64_t)v9 < v8)
    {
      uint64_t v13 = SysSignal::Name((SysSignal *)*(unsigned int *)(v11 + 8));
      uint64_t v14 = "unknown signal";
      if (v13) {
        uint64_t v14 = v13;
      }
      snprintf(v9, v8 - (void)v9, " EXC_SOFT_SIGNAL( %i(%s))", v12, v14);
    }
  }

  else if ((unint64_t)v9 < v8)
  {
    unint64_t v15 = &v9[snprintf((char *)(a2 + v7 + 4), v8 - (void)v9, " data[%llu] = {", v10)];
    if ((unint64_t)v15 < v8)
    {
      unint64_t v16 = 0LL;
      do
      {
        unint64_t v17 = *(void *)(a2 + 272);
        if (v16 >= v17) {
          goto LABEL_27;
        }
        uint64_t v18 = *(void *)(*(void *)(a1 + 16) + 8 * v16++);
        if (v16 == v17) {
          uint64_t v19 = 125LL;
        }
        else {
          uint64_t v19 = 44LL;
        }
        v15 += snprintf(v15, v8 - (void)v15, "0x%llx%c", v18, v19);
      }

      while ((unint64_t)v15 < v8);
    }
  }

  unint64_t v17 = *(void *)(a2 + 272);
LABEL_27:
  if (v17)
  {
    unint64_t v20 = 0LL;
    do
    {
      *(void *)(a2 + 280 + 8 * v20) = *(void *)(*(void *)(a1 + 16) + 8 * v20);
      ++v20;
    }

    while (v20 < *(void *)(a2 + 272));
  }

  return 1LL;
}

uint64_t MachException::Message::Receive( mach_msg_header_t *this, mach_port_name_t a2, mach_msg_option_t a3, int a4, mach_port_name_t a5)
{
  std::string __p = 0LL;
  uint64_t v17 = 0LL;
  uint64_t v18 = 0LL;
  BOOL v10 = DNBLogCheckLogBit(8);
  BOOL v11 = v10;
  mach_msg_timeout_t v12 = a4 & (a3 << 23 >> 31);
  if ((a3 & 0x100) == 0 && v10 && DNBLogEnabled()) {
    _DNBLogThreaded( "::mach_msg(msg->{bits = %#x, CFIndex size = %u remote_port = %#x, local_port = %#x, reserved = 0x%x, id = 0x%x}, option = %#x, send_CFIndex size = 0, rcv_CFIndex size = %llu, rcv_name = %#x, timeout = %u, notify = %#x)",  this->msgh_bits,  this->msgh_size,  this->msgh_remote_port,  this->msgh_local_port,  this->msgh_voucher_port,  this->msgh_id,  a3,  1024LL,  a2,  v12,  a5);
  }
  uint64_t v13 = mach_msg(this, a3, 0, 0x400u, a2, v12, a5);
  v15[0] = v13;
  v15[1] = 1;
  LOBYTE(__p) = 0;
  HIBYTE(v18) = 0;
  if (v11)
  {
    DNBError::LogThreaded( (DNBError *)v15,  "::mach_msg(msg->{bits = %#x, CFIndex size = %u remote_port = %#x, local_port = %#x, reserved = 0x%x, id = 0x%x}, option = %#x, send_CFIndex size = %u, rcv_CFIndex size = %u, rcv_name = %#x, timeout = %u, notify = %#x)",  this->msgh_bits,  this->msgh_size,  this->msgh_remote_port,  this->msgh_local_port,  this->msgh_voucher_port,  this->msgh_id,  a3,  0,  1024,  a2,  v12,  a5);
    uint64_t v13 = v15[0];
    if (SHIBYTE(v18) < 0) {
      operator delete(__p);
    }
  }

  return v13;
}

BOOL MachException::Message::CatchExceptionRaise(MachException::Message *this, int a2)
{
  *((_DWORD *)this + 512) = a2;
  g_message = (uint64_t)this + 2048;
  int v2 = mach_exc_server(this, (uint64_t)this + 1024);
  if (!v2 && DNBLogCheckLogBit(8) && DNBLogEnabled()) {
    _DNBLogThreaded("mach_exc_server returned zero...");
  }
  BOOL result = v2 != 0;
  g_message = 0LL;
  return result;
}

uint64_t MachException::Message::Reply(MachException::Message *this, MachProcess *a2, int a3)
{
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  if (*((_DWORD *)this + 514) != 5) {
    goto LABEL_20;
  }
  uint64_t v5 = *((void *)this + 258);
  if (*((void *)this + 259) - v5 != 16) {
    goto LABEL_20;
  }
  if (*(void *)v5 != 65539LL) {
    goto LABEL_20;
  }
  int v6 = *(_DWORD *)(v5 + 8);
  if (!v6) {
    goto LABEL_20;
  }
  int x = -1;
  mach_port_name_t v7 = *((_DWORD *)this + 512);
  if (*((_DWORD *)a2 + 30) == v7)
  {
    int v9 = *(_DWORD *)a2;
    int x = *(_DWORD *)a2;
  }

  else
  {
    *(void *)&__int128 v14 = pid_for_task(v7, &x) | 0x100000000LL;
    if (SHIBYTE(v15) < 0)
    {
      **((_BYTE **)&v14 + 1) = 0;
      *(void *)&__int128 v15 = 0LL;
    }

    else
    {
      BYTE8(v14) = 0;
      HIBYTE(v15) = 0;
    }

    int v9 = x;
    a3 = v6;
  }

  if (v9 == -1) {
    MachException::Message::Reply();
  }
  *__error() = 0;
  if (!ptrace(13, x, (caddr_t)*((unsigned int *)this + 513), a3))
  {
    *(void *)&__int128 v14 = 0LL;
    if ((SHIBYTE(v15) & 0x80000000) == 0) {
      goto LABEL_14;
    }
LABEL_16:
    **((_BYTE **)&v14 + 1) = 0;
    *(void *)&__int128 v15 = 0LL;
    goto LABEL_17;
  }

  LODWORD(v14) = *__error();
  DWORD1(v14) = 2;
  if (SHIBYTE(v15) < 0) {
    goto LABEL_16;
  }
LABEL_14:
  BYTE8(v14) = 0;
  HIBYTE(v15) = 0;
LABEL_17:
  if (DNBLogCheckLogBit(8) || (_DWORD)v14) {
    DNBError::LogThreaded( (DNBError *)&v14,  "::ptrace (request = PT_THUPDATE, pid = 0x%4.4x, tid = 0x%4.4x, signal = %i)",  x,  *((_DWORD *)this + 513),  a3);
  }
LABEL_20:
  if (DNBLogEnabledForAny(8)) {
    _DNBLogThreaded( "::mach_msg(msg->{bits = %#x, CFIndex size = %u, remote_port = %#x, local_port = %#x, reserved = 0x%x, id = 0x%x}, option = %#x, send_CFIndex size = %u, rcv_CFIndex size = %u, rcv_name = %#x, timeout = %u, notify = %#x)",  *((_DWORD *)this + 256),  *((_DWORD *)this + 257),  *((_DWORD *)this + 258),  *((_DWORD *)this + 259),  *((_DWORD *)this + 260),  *((_DWORD *)this + 261),  65,  *((_DWORD *)this + 257),  0,  0,  0,  0);
  }
  unsigned int v10 = mach_msg((mach_msg_header_t *)((char *)this + 1024), 65, *((_DWORD *)this + 257), 0, 0, 0, 0);
  *(void *)&__int128 v14 = v10 | 0x100000000LL;
  if (SHIBYTE(v15) < 0)
  {
    **((_BYTE **)&v14 + 1) = 0;
    *(void *)&__int128 v15 = 0LL;
    unsigned int v10 = v14;
    if (!(_DWORD)v14) {
      goto LABEL_34;
    }
  }

  else
  {
    BYTE8(v14) = 0;
    HIBYTE(v15) = 0;
    if (!v10) {
      goto LABEL_34;
    }
  }

  if (v10 == 268435463)
  {
    if (DNBLogCheckLogBit(8)) {
      DNBError::LogThreaded((DNBError *)&v14, "::mach_msg() - send interrupted");
    }
  }

  else if (*((_DWORD *)this + 512) == *((_DWORD *)a2 + 30))
  {
    if (DNBLogEnabled()) {
      _DNBLogThreaded("error: mach_msg() returned an error when replying to a mach exception: error = %u", (_DWORD)v14);
    }
  }

  else if (DNBLogCheckLogBit(8))
  {
    DNBError::LogThreaded((DNBError *)&v14, "::mach_msg() - failed (child of task)");
  }

LABEL_34:
  uint64_t v11 = v14;
  if (SHIBYTE(v15) < 0) {
    operator delete(*((void **)&v14 + 1));
  }
  return v11;
}

uint64_t MachException::PortInfo::Save(MachException::PortInfo *this, task_inspect_t a2)
{
  kern_return_t exception_ports;
  uint64_t v5;
  unsigned int v7;
  int v8;
  void *__p;
  uint64_t v10;
  uint64_t v11;
  if (DNBLogEnabledForAny(9)) {
    _DNBLogThreaded("MachException::PortInfo::Save(task = 0x%4.4x)", a2);
  }
  std::string __p = 0LL;
  unsigned int v10 = 0LL;
  uint64_t v11 = 0LL;
  *(_DWORD *)this = 7166;
  *((_DWORD *)this + 57) = 14;
  exception_ports = task_get_exception_ports( a2,  0x1BFEu,  (exception_mask_array_t)this + 1,  (mach_msg_type_number_t *)this + 57,  (exception_handler_array_t)this + 15,  (exception_behavior_array_t)this + 29,  (exception_flavor_array_t)this + 43);
  mach_port_name_t v7 = exception_ports;
  unint64_t v8 = 1;
  LOBYTE(__p) = 0;
  HIBYTE(v11) = 0;
  if (DNBLogCheckLogBit(8) || (uint64_t v5 = 0LL, exception_ports))
  {
    DNBError::LogThreaded( (DNBError *)&v7,  "::task_get_exception_ports(task = 0x%4.4x, mask = 0x%x, maskCnt => %u, ports, behaviors, flavors)",  a2,  *(_DWORD *)this,  *((_DWORD *)this + 57));
    uint64_t v5 = v7;
    if (v7 == 4)
    {
      if (*(_DWORD *)this == 7166)
      {
        uint64_t v5 = 4LL;
LABEL_16:
        *(_DWORD *)this = 0;
        *((_DWORD *)this + 57) = 0;
LABEL_17:
        if (SHIBYTE(v11) < 0) {
          operator delete(__p);
        }
        return v5;
      }

      *(_DWORD *)this = 7166;
      *((_DWORD *)this + 57) = 14;
      mach_port_name_t v7 = task_get_exception_ports( a2,  0x1BFEu,  (exception_mask_array_t)this + 1,  (mach_msg_type_number_t *)this + 57,  (exception_handler_array_t)this + 15,  (exception_behavior_array_t)this + 29,  (exception_flavor_array_t)this + 43);
      unint64_t v8 = 1;
      if (SHIBYTE(v11) < 0)
      {
        *(_BYTE *)std::string __p = 0;
        unsigned int v10 = 0LL;
      }

      else
      {
        LOBYTE(__p) = 0;
        HIBYTE(v11) = 0;
      }

      if (!DNBLogCheckLogBit(8) && !v7)
      {
        uint64_t v5 = 0LL;
        goto LABEL_17;
      }

      DNBError::LogThreaded( (DNBError *)&v7,  "::task_get_exception_ports(task = 0x%4.4x, mask = 0x%x, maskCnt => %u, ports, behaviors, flavors)",  a2,  *(_DWORD *)this,  *((_DWORD *)this + 57));
      uint64_t v5 = v7;
    }

    if (!(_DWORD)v5) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }

  return v5;
}

uint64_t MachException::PortInfo::Restore(MachException::PortInfo *this, task_t a2)
{
  if (DNBLogEnabledForAny(9)) {
    _DNBLogThreaded("MachException::PortInfo::Restore( task = 0x%4.4x)", a2);
  }
  *(_OWORD *)std::string __p = 0u;
  __int128 v10 = 0u;
  if (*((_DWORD *)this + 57))
  {
    uint64_t v4 = 0LL;
    while (1)
    {
      int v6 = (char *)this + 4 * v4;
      __p[0] = (void *)(task_set_exception_ports( a2,  *((_DWORD *)v6 + 1),  *((_DWORD *)v6 + 15),  *((_DWORD *)v6 + 29),  *((_DWORD *)v6 + 43)) | 0x100000000LL);
      if (SHIBYTE(v10) < 0)
      {
        *(_BYTE *)__p[1] = 0;
        *(void *)&__int128 v10 = 0LL;
      }

      else
      {
        LOBYTE(__p[1]) = 0;
        HIBYTE(v10) = 0;
      }

      if (DNBLogCheckLogBit(8) || LODWORD(__p[0]))
      {
        DNBError::LogThreaded( (DNBError *)__p,  "::task_set_exception_ports(task = 0x%4.4x, exception_mask = 0x%8.8x, new_port = 0x%4.4x, behavior = 0x%8.8x, new_flavor = 0x%8.8x)",  a2,  *((_DWORD *)v6 + 1),  *((_DWORD *)v6 + 15),  *((_DWORD *)v6 + 29),  *((_DWORD *)v6 + 43));
        uint64_t v5 = LODWORD(__p[0]);
        if (LODWORD(__p[0])) {
          break;
        }
      }

      if (++v4 >= (unint64_t)*((unsigned int *)this + 57))
      {
        uint64_t v5 = 0LL;
        break;
      }
    }

    int v7 = SHIBYTE(v10);
    *((_DWORD *)this + 57) = 0;
    if (v7 < 0) {
      operator delete(__p[1]);
    }
  }

  else
  {
    uint64_t v5 = 0LL;
    *((_DWORD *)this + 57) = 0;
  }

  return v5;
}

uint64_t MachException::ExceptionMask(MachException *this, const char *a2)
{
  {
    MachException::ExceptionMask(char const*)::prefix_len = 4;
  }

  uint64_t v5 = (char *)this + MachException::ExceptionMask(char const*)::prefix_len;
  size_t v6 = strlen(v5);
  if (v6 >= 0x7FFFFFFFFFFFFFF8LL) {
    abort();
  }
  size_t v7 = v6;
  if (v6 >= 0x17)
  {
    uint64_t v9 = (v6 & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((v6 | 7) != 0x17) {
      uint64_t v9 = v6 | 7;
    }
    uint64_t v10 = v9 + 1;
    p_dst = (__int128 *)operator new(v9 + 1);
    *((void *)&__dst + 1) = v7;
    unint64_t v23 = v10 | 0x8000000000000000LL;
    *(void *)&__int128 __dst = p_dst;
    goto LABEL_11;
  }

  HIBYTE(v23) = v6;
  p_dst = &__dst;
  if (v6) {
LABEL_11:
  }
    memcpy(p_dst, v5, v7);
  *((_BYTE *)p_dst + v7) = 0;
  if ((SHIBYTE(v23) & 0x80000000) == 0)
  {
    uint64_t v11 = &__dst;
    switch(HIBYTE(v23))
    {
      case 8:
        break;
      case 9:
        goto LABEL_14;
      case 0xA:
        if ((void)__dst == 0x454343415F444142LL && WORD4(__dst) == 21331) {
          goto LABEL_50;
        }
        goto LABEL_58;
      case 0xF:
        if (HIBYTE(v23) == 8) {
          goto LABEL_67;
        }
        if (HIBYTE(v23) == 9) {
          goto LABEL_14;
        }
        if (HIBYTE(v23) != 10) {
          goto LABEL_69;
        }
LABEL_58:
        if ((void)__dst == 0x54454D4854495241LL && WORD4(__dst) == 17225) {
          goto LABEL_76;
        }
        if (HIBYTE(v23) == 8) {
          goto LABEL_67;
        }
        if (HIBYTE(v23) != 9) {
          goto LABEL_69;
        }
LABEL_14:
        if ((void)__dst == 0x4F4954414C554D45LL && BYTE8(__dst) == 78) {
          goto LABEL_66;
        }
        if (HIBYTE(v23) != 8) {
          goto LABEL_69;
        }
LABEL_67:
        uint64_t v11 = &__dst;
        break;
      default:
        goto LABEL_69;
    }

void MachProcess::MachProcess(MachProcess *this)
{
  *(void *)this = 0LL;
  *(void *)((char *)this + 12) = -1LL;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((void *)this + 10) = 0LL;
  *((_DWORD *)this + 5) = -1;
  *((void *)this + 11) = 0LL;
  *((void *)this + 12) = 0LL;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  MachTask::MachTask((MachProcess *)((char *)this + 104), this);
  *((_DWORD *)this + 110) = 0;
  *((void *)this + 56) = 0LL;
  PThreadMutex::PThreadMutex((MachProcess *)((char *)this + 456), 2);
  *((_DWORD *)this + 137) = 0;
  *((void *)this + 70) = 0LL;
  *((void *)this + 65) = 0LL;
  *((void *)this + 67) = 0LL;
  *((void *)this + 66) = 0LL;
  *((_BYTE *)this + 544) = 0;
  PThreadMutex::PThreadMutex((MachProcess *)((char *)this + 568), 2);
  *((void *)this + 81) = 0LL;
  *(_OWORD *)((char *)this + 6memset(__p, 0, 32) = 0u;
  PThreadEvent::PThreadEvent((MachProcess *)((char *)this + 656), 0, 1);
  DNBThreadResumeActions::DNBThreadResumeActions((MachProcess *)((char *)this + 832));
  *((void *)this + 112) = 0LL;
  *((_OWORD *)this + 55) = 0u;
  PThreadMutex::PThreadMutex((MachProcess *)((char *)this + 904), 2);
  MachThreadList::MachThreadList((MachProcess *)((char *)this + 968));
  Genealogy::Genealogy((MachProcess *)((char *)this + 1080));
  *((_DWORD *)this + 304) = 1;
  PThreadMutex::PThreadMutex((MachProcess *)((char *)this + 1224), 2);
  PThreadEvent::PThreadEvent((MachProcess *)((char *)this + 1288), 0, 31);
  PThreadEvent::PThreadEvent((MachProcess *)((char *)this + 1464), 0, 31);
  DNBBreakpointList::DNBBreakpointList((MachProcess *)((char *)this + 1640));
  DNBBreakpointList::DNBBreakpointList((MachProcess *)((char *)this + 1664));
  *((void *)this + 225) = 0LL;
  *((_BYTE *)this + 1752) = 0;
  *(_OWORD *)((char *)this + 1688) = 0u;
  *(_OWORD *)((char *)this + 1704) = 0u;
  *(_OWORD *)((char *)this + 1720) = 0u;
  *(_OWORD *)((char *)this + 1736) = 0u;
  *((_OWORD *)this + 110) = 0u;
  *((_OWORD *)this + 111) = 0u;
  *((void *)this + 220) = dlsym((void *)0xFFFFFFFFFFFFFFFELL, "_dyld_process_info_create");
  *((void *)this + 221) = dlsym((void *)0xFFFFFFFFFFFFFFFELL, "_dyld_process_info_for_each_image");
  *((void *)this + 222) = dlsym((void *)0xFFFFFFFFFFFFFFFELL, "_dyld_process_info_release");
  *((void *)this + 223) = dlsym((void *)0xFFFFFFFFFFFFFFFELL, "_dyld_process_info_get_cache");
  *((void *)this + 224) = dlsym((void *)0xFFFFFFFFFFFFFFFELL, "_dyld_process_info_get_platform");
  *((void *)this + 225) = dlsym((void *)0xFFFFFFFFFFFFFFFELL, "_dyld_process_info_get_state");
  if (DNBLogEnabledForAny(3)) {
    _DNBLogThreaded("%s", "MachProcess::MachProcess()");
  }
}

void sub_100038020( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, _Unwind_Exception *exception_object, void **a12, DNBThreadResumeActions *a13, PThreadEvent *a14, void **a15, PThreadMutex *a16, PThreadMutex *a17, MachTask *a18)
{
}

void Genealogy::~Genealogy(Genealogy *this)
{
  uint64_t v2 = *((void *)this + 13);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 14);
    uint64_t v4 = (void *)*((void *)this + 13);
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5)
        {
          p_shared_owners = (unint64_t *)&v5->__shared_owners_;
          do
            unint64_t v7 = __ldaxr(p_shared_owners);
          while (__stlxr(v7 - 1, p_shared_owners));
          if (!v7)
          {
            ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
            std::__shared_weak_count::__release_weak(v5);
          }
        }

        v3 -= 16LL;
      }

      while (v3 != v2);
      uint64_t v4 = (void *)*((void *)this + 13);
    }

    *((void *)this + 14) = v2;
    operator delete(v4);
  }

  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>>>::destroy( (uint64_t)this + 80,  *((void **)this + 11));
}

void **std::vector<MachException::Message>::~vector[abi:ne180100](void **a1)
{
  uint64_t v2 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = (void *)*((void *)v3 - 3);
        if (v5)
        {
          *((void *)v3 - 2) = v5;
          operator delete(v5);
        }

        v3 -= 2088;
      }

      while (v3 != v2);
      uint64_t v4 = *a1;
    }

    a1[1] = v2;
    operator delete(v4);
  }

  return a1;
}

void DNBThreadResumeActions::~DNBThreadResumeActions(DNBThreadResumeActions *this)
{
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2) {
    operator delete(v2);
  }
  uint64_t v3 = *(void **)this;
  if (*(void *)this)
  {
    *((void *)this + 1) = v3;
    operator delete(v3);
  }

void **std::vector<std::string>::~vector[abi:ne180100](void **a1)
{
  uint64_t v2 = (void **)*a1;
  if (*a1)
  {
    uint64_t v3 = (void **)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        v3 -= 3;
      }

      while (v3 != v2);
      uint64_t v4 = *a1;
    }

    a1[1] = v2;
    operator delete(v4);
  }

  return a1;
}

void MachProcess::~MachProcess(MachProcess *this)
{
  if (DNBLogEnabledForAny(3)) {
    _DNBLogThreaded("%s", "MachProcess::~MachProcess()");
  }
  MachProcess::Clear(this, 0);
  DNBBreakpointList::~DNBBreakpointList((MachProcess *)((char *)this + 1664));
  DNBBreakpointList::~DNBBreakpointList((MachProcess *)((char *)this + 1640));
  PThreadEvent::~PThreadEvent((MachProcess *)((char *)this + 1464));
  PThreadEvent::~PThreadEvent((MachProcess *)((char *)this + 1288));
  if (pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 1224))
    && !pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 1224)))
  {
    pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 1224));
  }

  uint64_t v2 = *((void *)this + 148);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 149);
    uint64_t v4 = (void *)*((void *)this + 148);
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5)
        {
          p_shared_owners = (unint64_t *)&v5->__shared_owners_;
          do
            unint64_t v7 = __ldaxr(p_shared_owners);
          while (__stlxr(v7 - 1, p_shared_owners));
          if (!v7)
          {
            ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
            std::__shared_weak_count::__release_weak(v5);
          }
        }

        v3 -= 16LL;
      }

      while (v3 != v2);
      uint64_t v4 = (void *)*((void *)this + 148);
    }

    *((void *)this + 149) = v2;
    operator delete(v4);
  }

  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<Genealogy::ThreadActivity>>>>::destroy( (uint64_t)this + 1160,  *((void **)this + 146));
  MachThreadList::~MachThreadList((MachProcess *)((char *)this + 968));
  if (pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 904))
    && !pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 904)))
  {
    pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 904));
  }

  uint64_t v8 = *((void *)this + 110);
  if (v8)
  {
    uint64_t v9 = *((void *)this + 111);
    uint64_t v10 = (void *)*((void *)this + 110);
    if (v9 != v8)
    {
      do
      {
        uint64_t v11 = *(void **)(v9 - 24);
        if (v11)
        {
          *(void *)(v9 - 16) = v11;
          operator delete(v11);
        }

        v9 -= 2088LL;
      }

      while (v9 != v8);
      uint64_t v10 = (void *)*((void *)this + 110);
    }

    *((void *)this + 111) = v8;
    operator delete(v10);
  }

  mach_msg_timeout_t v12 = (void *)*((void *)this + 107);
  if (v12) {
    operator delete(v12);
  }
  uint64_t v13 = (void *)*((void *)this + 104);
  if (v13)
  {
    *((void *)this + 105) = v13;
    operator delete(v13);
  }

  PThreadEvent::~PThreadEvent((MachProcess *)((char *)this + 656));
  uint64_t v14 = *((void *)this + 79);
  if (v14)
  {
    uint64_t v15 = *((void *)this + 80);
    unint64_t v16 = (void *)*((void *)this + 79);
    if (v15 != v14)
    {
      do
      {
        v15 -= 24LL;
      }

      while (v15 != v14);
      unint64_t v16 = (void *)*((void *)this + 79);
    }

    *((void *)this + 80) = v14;
    operator delete(v16);
  }

  if (pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 568))
    && !pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 568)))
  {
    pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 568));
  }

  if (pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 456))
    && !pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 456)))
  {
    pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 456));
  }

  MachTask::~MachTask((MachProcess *)((char *)this + 104));
  uint64_t v17 = *((void *)this + 6);
  if (v17)
  {
    uint64_t v18 = *((void *)this + 7);
    uint64_t v19 = (void *)*((void *)this + 6);
    if (v18 != v17)
    {
      do
      {
        v18 -= 24LL;
      }

      while (v18 != v17);
      uint64_t v19 = (void *)*((void *)this + 6);
    }

    *((void *)this + 7) = v17;
    operator delete(v19);
  }

void __clang_call_terminate(void *a1)
{
}

void MachProcess::Clear(MachProcess *this, char a2)
{
  *((_DWORD *)this + 2) = 0;
  *(_DWORD *)this = 0;
  if ((a2 & 1) == 0)
  {
    int v4 = *((_DWORD *)this + 3);
    if ((v4 & 0x80000000) == 0)
    {
      close(v4);
      *((_DWORD *)this + 3) = -1;
    }

    int v5 = *((_DWORD *)this + 4);
    if ((v5 & 0x80000000) == 0)
    {
      close(v5);
      *((_DWORD *)this + 4) = -1;
    }

    int v6 = *((_DWORD *)this + 5);
    if ((v6 & 0x80000000) == 0)
    {
      close(v6);
      *((_DWORD *)this + 5) = -1;
    }
  }

  if (*((char *)this + 47) < 0)
  {
    **((_BYTE **)this + 3) = 0;
    *((void *)this + 4) = 0LL;
  }

  else
  {
    *((_BYTE *)this + 24) = 0;
    *((_BYTE *)this + 47) = 0;
  }

  uint64_t v7 = *((void *)this + 6);
  for (uint64_t i = *((void *)this + 7); i != v7; i -= 24LL)
  {
  }

  *((void *)this + 7) = v7;
  MachProcess::SetState((uint64_t)this, 1u);
  *((void *)this + 55) = 0LL;
  MachThreadList::Clear((MachProcess *)((char *)this + 968));
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 904));
  uint64_t v9 = *((void *)this + 111);
  uint64_t v10 = *((void *)this + 110);
  while (v9 != v10)
  {
    uint64_t v11 = *(void **)(v9 - 24);
    if (v11)
    {
      *(void *)(v9 - 16) = v11;
      operator delete(v11);
    }

    v9 -= 2088LL;
  }

  *((void *)this + 111) = v10;
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 904));
  Genealogy::Clear((MachProcess *)((char *)this + 1080));
  if (*((void *)this + 70))
  {
    PThreadEvent::SetEvents((pthread_mutex_t *)((char *)this + 656), 1);
    pthread_join(*((pthread_t *)this + 70), 0LL);
    *((void *)this + 70) = 0LL;
    PThreadEvent::ResetEvents((pthread_mutex_t *)((char *)this + 656), 1);
  }

uint64_t MachProcess::GetState(MachProcess *this)
{
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 1224);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 1224));
  uint64_t v3 = *((unsigned int *)this + 304);
  pthread_mutex_unlock(v2);
  return v3;
}

void PThreadMutex::Locker::~Locker(pthread_mutex_t **this)
{
  uint64_t v1 = *this;
  if (v1) {
    pthread_mutex_unlock(v1);
  }
}

uint64_t MachProcess::ThreadGetName(MachProcess *this, uint64_t a2)
{
  return MachThreadList::GetName((MachProcess *)((char *)this + 968), a2);
}

uint64_t MachProcess::ThreadGetState(MachProcess *this, uint64_t a2)
{
  return MachThreadList::GetState((MachProcess *)((char *)this + 968), a2);
}

uint64_t MachProcess::GetNumThreads(MachProcess *this)
{
  return MachThreadList::NumThreads((MachProcess *)((char *)this + 968));
}

uint64_t MachProcess::GetThreadAtIndex(MachProcess *this, unint64_t a2)
{
  return MachThreadList::ThreadIDAtIndex((MachProcess *)((char *)this + 968), a2);
}

BOOL MachProcess::SyncThreadState(MachProcess *this, uint64_t a2)
{
  kern_return_t v2;
  BOOL v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  thread_act_t *v8;
  std::__shared_weak_count *v9;
  MachThreadList::GetThreadByID((MachProcess *)((char *)this + 968), a2, &v8);
  if (!v8)
  {
    uint64_t v3 = 0LL;
    int v4 = v9;
    if (!v9) {
      return v3;
    }
    goto LABEL_7;
  }

  uint64_t v2 = thread_abort_safely(v8[4]);
  if (DNBLogEnabledForAny(4)) {
    _DNBLogThreaded( "thread = 0x%8.8x calling thread_abort_safely (tid) => %u (GetGPRState() for stop_count = %u)",  v8[4],  v2,  *(_DWORD *)(*(void *)v8 + 444LL));
  }
  uint64_t v3 = v2 == 0;
  int v4 = v9;
  if (v9)
  {
LABEL_7:
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      int v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

  return v3;
}

void sub_1000388E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t std::shared_ptr<MachThread>::~shared_ptr[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      unint64_t v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }

  return a1;
}

void MachProcess::GetRequestedQoS( MachProcess *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
}

uint64_t MachProcess::GetPThreadT(MachProcess *this, uint64_t a2)
{
  return MachThreadList::GetPThreadT((MachProcess *)((char *)this + 968), a2);
}

uint64_t MachProcess::GetDispatchQueueT(MachProcess *this, uint64_t a2)
{
  return MachThreadList::GetDispatchQueueT((MachProcess *)((char *)this + 968), a2);
}

uint64_t MachProcess::GetTSDAddressForThread( MachProcess *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MachThreadList::GetTSDAddressForThread((MachProcess *)((char *)this + 968), a2, a3, a4, a5);
}

unint64_t MachProcess::GetDeploymentInfo( MachProcess *this, const load_command *a2, mach_vm_address_t a3, int a4)
{
  uint64_t Memory = 0LL;
  unsigned __int8 v8 = 0;
  switch(a2->cmd & 0x7FFFFFFF)
  {
    case '$':
      uint64_t Memory = MachTask::ReadMemory((MachProcess *)((char *)this + 104), a3, 0x10uLL, (char *)&__p);
      if (!Memory) {
        goto LABEL_22;
      }
      DNBBreakpointList::RemoveTrapsFromBuffer((void *)this + 205, a3, Memory, (char *)&__p);
      if (Memory != 16) {
        goto LABEL_24;
      }
      uint64_t Memory = HIWORD(v20);
      unsigned __int8 v8 = 1;
      if (a4) {
        goto LABEL_26;
      }
      return v8 | (unint64_t)(Memory << 32);
    case '%':
      uint64_t Memory = MachTask::ReadMemory((MachProcess *)((char *)this + 104), a3, 0x10uLL, (char *)&__p);
      if (!Memory) {
        goto LABEL_22;
      }
      DNBBreakpointList::RemoveTrapsFromBuffer((void *)this + 205, a3, Memory, (char *)&__p);
      if (Memory != 16) {
        goto LABEL_24;
      }
      uint64_t Memory = HIWORD(v20);
      unsigned __int8 v8 = 2;
      if (a4) {
        goto LABEL_26;
      }
      return v8 | (unint64_t)(Memory << 32);
    case '&':
    case '\'':
    case '(':
    case ')':
    case '*':
    case '+':
    case ',':
    case '-':
    case '.':
    case '1':
      goto LABEL_25;
    case '/':
      uint64_t Memory = MachTask::ReadMemory((MachProcess *)((char *)this + 104), a3, 0x10uLL, (char *)&__p);
      if (!Memory) {
        goto LABEL_22;
      }
      DNBBreakpointList::RemoveTrapsFromBuffer((void *)this + 205, a3, Memory, (char *)&__p);
      if (Memory != 16) {
        goto LABEL_24;
      }
      uint64_t Memory = HIWORD(v20);
      unsigned __int8 v8 = 3;
      if (!a4) {
        return v8 | (unint64_t)(Memory << 32);
      }
      goto LABEL_26;
    case '0':
      uint64_t Memory = MachTask::ReadMemory((MachProcess *)((char *)this + 104), a3, 0x10uLL, (char *)&__p);
      if (!Memory) {
        goto LABEL_22;
      }
      DNBBreakpointList::RemoveTrapsFromBuffer((void *)this + 205, a3, Memory, (char *)&__p);
      if (Memory != 16) {
        goto LABEL_24;
      }
      uint64_t Memory = HIWORD(v20);
      unsigned __int8 v8 = 4;
      if (!a4) {
        return v8 | (unint64_t)(Memory << 32);
      }
      goto LABEL_26;
    case '2':
      uint64_t Memory = MachTask::ReadMemory((MachProcess *)((char *)this + 104), a3, 0x18uLL, (char *)&__p);
      if (Memory)
      {
        DNBBreakpointList::RemoveTrapsFromBuffer((void *)this + 205, a3, Memory, (char *)&__p);
        if (Memory == 24)
        {
          unsigned __int8 v8 = v20;
          uint64_t Memory = HIWORD(v21);
          if (!a4) {
            return v8 | (unint64_t)(Memory << 32);
          }
        }

        else
        {
LABEL_24:
          uint64_t Memory = 0LL;
          unsigned __int8 v8 = 0;
LABEL_25:
          if (!a4) {
            return v8 | (unint64_t)(Memory << 32);
          }
        }
      }

      else
      {
LABEL_22:
        unsigned __int8 v8 = 0;
        if (!a4) {
          return v8 | (unint64_t)(Memory << 32);
        }
      }

LABEL_50:
        unsigned __int8 v8 = 6;
        return v8 | (unint64_t)(Memory << 32);
      }

      uint64_t v10 = (uint64_t (*)(void, void, void **))*((void *)this + 220);
      if (v10 && (LODWORD(__p) = 0, (uint64_t v11 = v10(*((unsigned int *)this + 30), 0LL, &__p)) != 0))
      {
        uint64_t v12 = v11;
        uint64_t v13 = (uint64_t (*)(uint64_t))*((void *)this + 224);
        if (v13) {
          int v14 = v13(v11);
        }
        else {
          int v14 = 0;
        }
        (*((void (**)(uint64_t))this + 222))(v12);
      }

      else
      {
        int v14 = 0;
      }

      *((_DWORD *)this + 2) = v14;
      if (v14 == 6) {
        goto LABEL_39;
      }
      return v8 | (unint64_t)(Memory << 32);
    default:
      uint64_t Memory = 0LL;
      unsigned __int8 v8 = 0;
      if (!a4) {
        return v8 | (unint64_t)(Memory << 32);
      }
      goto LABEL_26;
  }

unint64_t MachProcess::ReadMemory( MachProcess *this, mach_vm_address_t a2, unint64_t a3, char *a4)
{
  unint64_t Memory = MachTask::ReadMemory((MachProcess *)((char *)this + 104), a2, a3, a4);
  if (Memory) {
    DNBBreakpointList::RemoveTrapsFromBuffer((void *)this + 205, a2, Memory, a4);
  }
  return Memory;
}

void MachProcess::GetMacCatalystVersionString(void *a1@<X8>)
{
  uint64_t v3 = objc_autoreleasePoolPush();
  unint64_t v4 = (const char *)objc_msgSend( -[NSDictionary objectForKey:]( +[NSDictionary dictionaryWithContentsOfFile:]( NSDictionary,  "dictionaryWithContentsOfFile:",  @"/System/Library/CoreServices/SystemVersion.plist"),  "objectForKey:",  @"iOSSupportVersion"),  "UTF8String");
  if (!v4)
  {
    objc_autoreleasePoolPop(v3);
    *a1 = 0LL;
    a1[1] = 0LL;
    a1[2] = 0LL;
    return;
  }

  int v5 = v4;
  size_t v6 = strlen(v4);
  if (v6 >= 0x7FFFFFFFFFFFFFF8LL) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v7 = v6;
  if (v6 >= 0x17)
  {
    uint64_t v8 = (v6 & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((v6 | 7) != 0x17) {
      uint64_t v8 = v6 | 7;
    }
    uint64_t v9 = v8 + 1;
    uint64_t v10 = operator new(v8 + 1);
    a1[1] = v7;
    a1[2] = v9 | 0x8000000000000000LL;
    *a1 = v10;
    a1 = v10;
  }

  else
  {
    *((_BYTE *)a1 + 23) = v6;
    if (!v6) {
      goto LABEL_11;
    }
  }

  memmove(a1, v5, v7);
LABEL_11:
  *((_BYTE *)a1 + v7) = 0;
  objc_autoreleasePoolPop(v3);
}

uint64_t MachProcess::GetMachOInformationFromMemory( uint64_t a1, int a2, mach_vm_address_t a3, int a4, uint64_t a5)
{
  uint64_t v8 = (MachTask *)(a1 + 104);
  if (a4 != 4)
  {
    unint64_t Memory = MachTask::ReadMemory((MachTask *)(a1 + 104), a3, 0x20uLL, v77);
    if (!Memory) {
      return 0LL;
    }
    DNBBreakpointList::RemoveTrapsFromBuffer((void *)(a1 + 1640), a3, Memory, v77);
    if (Memory != 32) {
      return 0LL;
    }
    int v10 = *(_DWORD *)v77;
    int v11 = *(_DWORD *)&v77[4];
    if (*(int *)&v77[4] <= 16777222)
    {
      if (*(_DWORD *)&v77[4] != 7 && *(_DWORD *)&v77[4] != 12) {
        return 0LL;
      }
    }

    else if (*(_DWORD *)&v77[4] != 16777223 && *(_DWORD *)&v77[4] != 16777228 && *(_DWORD *)&v77[4] != 33554444)
    {
      return 0LL;
    }

    mach_vm_address_t v13 = a3 + 32;
    goto LABEL_28;
  }

  unint64_t v9 = MachTask::ReadMemory((MachTask *)(a1 + 104), a3, 0x1CuLL, v77);
  if (!v9) {
    return 0LL;
  }
  DNBBreakpointList::RemoveTrapsFromBuffer((void *)(a1 + 1640), a3, v9, v77);
  if (v9 != 28) {
    return 0LL;
  }
  int v10 = *(_DWORD *)v77;
  int v11 = *(_DWORD *)&v77[4];
  if (*(int *)&v77[4] <= 16777222)
  {
    if (*(_DWORD *)&v77[4] != 7 && *(_DWORD *)&v77[4] != 12) {
      return 0LL;
    }
    goto LABEL_24;
  }

  if (*(_DWORD *)&v77[4] == 16777223 || *(_DWORD *)&v77[4] == 16777228 || *(_DWORD *)&v77[4] == 33554444)
  {
LABEL_24:
    mach_vm_address_t v13 = a3 + 28;
LABEL_28:
    *(_DWORD *)a5 = v10;
    *(_DWORD *)(a5 + 4) = v11;
    *(_DWORD *)(a5 + 8) = *(_DWORD *)&v77[8] & 0xFFFFFF;
    int v14 = *(_DWORD *)&v77[16];
    *(_OWORD *)(a5 + 12) = *(_OWORD *)&v77[12];
    if (!v14) {
      return 1LL;
    }
    unsigned int v15 = 0;
    int16x8_t v64 = (char **)(a5 + 32);
    int v65 = (void **)(a5 + 72);
    while (1)
    {
      unint64_t v17 = MachTask::ReadMemory(v8, v13, 8uLL, (char *)&v67);
      if (!v17) {
        return 0LL;
      }
      DNBBreakpointList::RemoveTrapsFromBuffer((void *)(a1 + 1640), v13, v17, (char *)&v67);
      if (v17 != 8) {
        return 0LL;
      }
      uint32_t cmd = v67.cmd;
      if (v67.cmd == 1) {
        break;
      }
LABEL_54:
      if (cmd == 25)
      {
        unint64_t v32 = MachTask::ReadMemory(v8, v13, 0x48uLL, (char *)&v68);
        if (!v32) {
          return 0LL;
        }
        DNBBreakpointList::RemoveTrapsFromBuffer((void *)(a1 + 1640), v13, v32, (char *)&v68);
        if (v32 != 72) {
          return 0LL;
        }
        memset(v77, 0, 24);
        char v76 = 0;
        *(_OWORD *)__s = *(_OWORD *)&v68.__r_.__value_.__r.__words[1];
        std::string::assign((std::string *)v77, __s);
        *(_OWORD *)&v77[24] = v69;
        __int128 v78 = v70;
        *(void *)&__int128 v33 = v71;
        *((void *)&v33 + 1) = v72;
        __int128 v79 = v33;
        *(void *)&__int128 v33 = v73;
        *((void *)&v33 + 1) = v74;
        __int128 v80 = v33;
        unint64_t v34 = *(void *)(a5 + 40);
        if (v34 >= *(void *)(a5 + 48))
        {
          BOOL v36 = std::vector<MachProcess::mach_o_segment>::__push_back_slow_path<MachProcess::mach_o_segment const&>( v64,  (uint64_t)v77);
        }

        else
        {
          if ((v77[23] & 0x80000000) != 0)
          {
            std::string::__init_copy_ctor_external( *(std::string **)(a5 + 40),  *(const std::string::value_type **)v77,  *(std::string::size_type *)&v77[8]);
          }

          else
          {
            __int128 v35 = *(_OWORD *)v77;
            *(void *)(v34 + 16) = *(void *)&v77[16];
            *(_OWORD *)unint64_t v34 = v35;
          }

          __int128 v37 = *(_OWORD *)&v77[24];
          __int128 v38 = v78;
          __int128 v39 = v79;
          *(_OWORD *)(v34 + 72) = v80;
          *(_OWORD *)(v34 + 56) = v39;
          *(_OWORD *)(v34 + 40) = v38;
          *(_OWORD *)(v34 + 24) = v37;
          BOOL v36 = (char *)(v34 + 88);
          *(void *)(a5 + 40) = v34 + 88;
        }

        *(void *)(a5 + 40) = v36;
        int v40 = v77[23];
        if ((v77[23] & 0x80000000) == 0)
        {
          if (v77[23] == 16)
          {
            unint64_t v41 = (uint64_t *)v77;
            goto LABEL_70;
          }

LABEL_76:
          uint32_t cmd = v67.cmd;
          goto LABEL_77;
        }

        if (*(void *)&v77[8] == 16LL)
        {
          unint64_t v41 = *(uint64_t **)v77;
LABEL_70:
          uint64_t v43 = *v41;
          uint64_t v42 = v41[1];
          if (v43 == 0x7274784563657845LL && v42 == 0x646E657073755361LL)
          {
            *(_BYTE *)(a1 + 412) = 1;
            if ((v40 & 0x80000000) == 0) {
              goto LABEL_76;
            }
          }

          else if ((v77[23] & 0x80000000) == 0)
          {
            goto LABEL_76;
          }
        }

        operator delete(*(void **)v77);
        goto LABEL_76;
      }

LABEL_77:
      if (cmd == 27)
      {
        unint64_t v45 = MachTask::ReadMemory(v8, v13, 0x18uLL, v77);
        if (v45)
        {
          DNBBreakpointList::RemoveTrapsFromBuffer((void *)(a1 + 1640), v13, v45, v77);
          if (v45 == 24) {
            uuid_copy((unsigned __int8 *)(a5 + 56), &v77[8]);
          }
        }
      }

      unint64_t DeploymentInfo = MachProcess::GetDeploymentInfo((MachProcess *)a1, &v67, v13, *(_DWORD *)(a5 + 12) == 2);
      if (!(_BYTE)DeploymentInfo) {
        goto LABEL_30;
      }
      unint64_t v48 = v46;
      switch((char)DeploymentInfo)
      {
        case 1:
          v77[23] = 6;
          strcpy(v77, "macosx");
          char v49 = 1;
          break;
        case 2:
          v77[23] = 3;
          strcpy(v77, "ios");
          goto LABEL_102;
        case 3:
          v77[23] = 4;
          int v50 = 1936684660;
          goto LABEL_99;
        case 4:
          v77[23] = 7;
          strcpy(v77, "watchos");
          char v49 = 1;
          break;
        case 5:
          v77[23] = 8;
          strcpy(v77, "bridgeos");
          char v49 = 1;
          break;
        case 6:
          v77[23] = 11;
          strcpy(v77, "maccatalyst");
          goto LABEL_102;
        case 7:
          v77[23] = 12;
          strcpy(v77, "iossimulator");
          goto LABEL_102;
        case 8:
          v77[23] = 13;
          unint64_t v51 = "tvossimulator";
          goto LABEL_101;
        case 9:
          v77[23] = 16;
          strcpy(v77, "watchossimulator");
          goto LABEL_102;
        case 10:
          v77[23] = 9;
          strcpy(v77, "driverkit");
          goto LABEL_102;
        case 11:
          v77[23] = 4;
          int v50 = 1936683640;
LABEL_99:
          *(_DWORD *)uint64_t v77 = v50;
          char v49 = 1;
          v77[4] = 0;
          break;
        case 12:
          v77[23] = 13;
          unint64_t v51 = "xrossimulator";
LABEL_101:
          *(void *)uint64_t v77 = *(void *)v51;
          *(void *)&v77[5] = *(void *)(v51 + 5);
          v77[13] = 0;
LABEL_102:
          char v49 = 1;
          break;
        default:
          if (DNBLogEnabled()) {
            _DNBLogError("Unknown platform %u found for one binary", DeploymentInfo);
          }
          char v49 = 0;
          v77[0] = 0;
          break;
      }

      v77[24] = v49;
      if (a2 != 6)
      {
        int v52 = *(char *)(a5 + 95);
        if (v52 < 0)
        {
          if (*(void *)(a5 + 80) == 6LL)
          {
            uint64_t v53 = (unsigned __int16 *)*v65;
LABEL_109:
            int v54 = *(_DWORD *)v53;
            int v55 = v53[2];
            if (v54 == 1868783981 && v55 == 30835) {
              goto LABEL_141;
            }
          }
        }

        else
        {
          uint64_t v53 = (unsigned __int16 *)(a5 + 72);
          if (v52 == 6) {
            goto LABEL_109;
          }
        }
      }

      std::optional<std::string>::value_or[abi:ne180100]<char const(&)[1]>((char *)&unk_1000528BD, (uint64_t)v77, &v68);
      *(_OWORD *)int v65 = *(_OWORD *)&v68.__r_.__value_.__l.__data_;
      *(void *)(a5 + 88) = v68.__r_.__value_.__l.__cap_;
      std::string::assign((std::string *)(a5 + 96), (const std::string::value_type *)&unk_1000528BD);
      std::to_string(&v68, HIDWORD(DeploymentInfo));
      if ((v68.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        int v57 = &v68;
      }
      else {
        int v57 = (std::string *)v68.__r_.__value_.__r.__words[0];
      }
      if ((v68.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        std::string::size_type size = v68.__r_.__value_.__s.__size_;
      }
      else {
        std::string::size_type size = v68.__r_.__value_.__l.__size_;
      }
      std::string::append((std::string *)(a5 + 96), (const std::string::value_type *)v57, size);
      std::string::append((std::string *)(a5 + 96), ".");
      std::to_string(&v68, v48);
      if ((v68.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        int v59 = &v68;
      }
      else {
        int v59 = (std::string *)v68.__r_.__value_.__r.__words[0];
      }
      if ((v68.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        std::string::size_type v60 = v68.__r_.__value_.__s.__size_;
      }
      else {
        std::string::size_type v60 = v68.__r_.__value_.__l.__size_;
      }
      std::string::append((std::string *)(a5 + 96), (const std::string::value_type *)v59, v60);
      if ((char)v68.__r_.__value_.__s.__size_ < 0)
      {
        operator delete(v68.__r_.__value_.__l.__data_);
        unint64_t v61 = HIDWORD(v48);
        if (HIDWORD(v48))
        {
LABEL_133:
          std::string::append((std::string *)(a5 + 96), ".");
          std::to_string(&v68, v61);
          if ((v68.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            uint64_t v62 = &v68;
          }
          else {
            uint64_t v62 = (std::string *)v68.__r_.__value_.__r.__words[0];
          }
          if ((v68.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            std::string::size_type v63 = v68.__r_.__value_.__s.__size_;
          }
          else {
            std::string::size_type v63 = v68.__r_.__value_.__l.__size_;
          }
          std::string::append((std::string *)(a5 + 96), (const std::string::value_type *)v62, v63);
        }
      }

      else
      {
        unint64_t v61 = HIDWORD(v48);
        if (HIDWORD(v48)) {
          goto LABEL_133;
        }
      }

LABEL_141:
      if (v77[24])
      {
        if ((v77[23] & 0x80000000) != 0) {
          operator delete(*(void **)v77);
        }
      }

void sub_100039830( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, void *__p, uint64_t a35, int a36, __int16 a37, char a38, char a39, char a40)
{
  *(void *)(v40 + 40) = v41;
  if (a39 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }

  _Unwind_Resume(exception_object);
}

void std::optional<std::string>::value_or[abi:ne180100]<char const(&)[1]>( char *__s@<X1>, uint64_t a2@<X0>, std::string *a3@<X8>)
{
  uint64_t v3 = a3;
  if (!*(_BYTE *)(a2 + 24))
  {
    size_t v5 = strlen(__s);
    if (v5 >= 0x7FFFFFFFFFFFFFF8LL) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    size_t v6 = v5;
    if (v5 >= 0x17)
    {
      uint64_t v7 = (v5 & 0xFFFFFFFFFFFFFFF8LL) + 8;
      if ((v5 | 7) != 0x17) {
        uint64_t v7 = v5 | 7;
      }
      uint64_t v8 = v7 + 1;
      unint64_t v9 = (std::string *)operator new(v7 + 1);
      v3->__r_.__value_.__l.__size_ = v6;
      v3->__r_.__value_.__l.__cap_ = v8 | 0x8000000000000000LL;
      v3->__r_.__value_.__r.__words[0] = (std::string::size_type)v9;
      uint64_t v3 = v9;
    }

    else
    {
      v3->__r_.__value_.__s.__size_ = v5;
      if (!v5) {
        goto LABEL_13;
      }
    }

    memcpy(v3, __s, v6);
LABEL_13:
    v3->__r_.__value_.__s.__data_[v6] = 0;
    return;
  }

  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(a3, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }

  else
  {
    *(_OWORD *)&a3->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    a3->__r_.__value_.__l.__cap_ = *(void *)(a2 + 16);
  }

void MachProcess::FormatDynamicLibrariesIntoJSON(void *a1@<X1>, uint64_t a2@<X2>, _OWORD *a3@<X8>)
{
  size_t v5 = operator new(0x38uLL);
  v5[2] = 0LL;
  *((_DWORD *)v5 + 6) = 2;
  *size_t v5 = off_100060D90;
  v5[1] = 0LL;
  v5[5] = 0LL;
  v5[6] = 0LL;
  v5[4] = 0LL;
  std::shared_ptr<JSONGenerator::Array>::shared_ptr[abi:ne180100]<JSONGenerator::Array,void>(&v152, (uint64_t)v5);
  uint64_t v6 = a1[1] - *a1;
  if (v6)
  {
    uint64_t v7 = 0LL;
    unint64_t v8 = v6 / 160;
    if (v8 <= 1) {
      uint64_t v9 = 1LL;
    }
    else {
      uint64_t v9 = v8;
    }
    uint64_t v107 = v9;
    do
    {
      if ((_DWORD)a2 && !*(_BYTE *)(*a1 + 160 * v7 + 152)) {
        goto LABEL_6;
      }
      int v10 = operator new(0x38uLL);
      v10[1] = 0LL;
      int v10[2] = 0LL;
      *((_DWORD *)v10 + 6) = 7;
      *int v10 = off_100060D18;
      v10[5] = 0LL;
      v10[6] = 0LL;
      v10[4] = 0LL;
      std::shared_ptr<JSONGenerator::Dictionary>::shared_ptr[abi:ne180100]<JSONGenerator::Dictionary,void>( &v151,  (uint64_t)v10);
      v150.__r_.__value_.__s.__size_ = 12;
      strcpy((char *)&v150, "load_address");
      JSONGenerator::Dictionary::AddIntegerItem( v151,  &v150,  *(void (__cdecl **)(std::__shared_weak_count *__hidden))(*a1 + 160 * v7 + 24));
      v149.__r_.__value_.__s.__size_ = 8;
      strcpy((char *)&v149, "mod_date");
      JSONGenerator::Dictionary::AddIntegerItem(v151, &v149, 0LL);
      uint64_t v11 = v151;
      v148.__r_.__value_.__s.__size_ = 8;
      strcpy((char *)&v148, "pathname");
      uint64_t v12 = *a1 + 160 * v7;
      if (*(char *)(v12 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&v147, *(const std::string::value_type **)v12, *(void *)(v12 + 8));
      }

      else
      {
        __int128 v13 = *(_OWORD *)v12;
        v147.__r_.__value_.__l.__cap_ = *(void *)(v12 + 16);
        *(_OWORD *)&v147.__r_.__value_.__l.__data_ = v13;
      }

      JSONGenerator::Dictionary::AddStringItem(v11, &v148, (uint64_t)&v147);
      if ((char)v147.__r_.__value_.__s.__size_ < 0)
      {
        operator delete(v147.__r_.__value_.__l.__data_);
        if (((char)v148.__r_.__value_.__s.__size_ & 0x80000000) == 0)
        {
LABEL_18:
          if ((a2 & 1) != 0) {
            goto LABEL_19;
          }
          goto LABEL_25;
        }
      }

      else if (((char)v148.__r_.__value_.__s.__size_ & 0x80000000) == 0)
      {
        goto LABEL_18;
      }

      operator delete(v148.__r_.__value_.__l.__data_);
      if ((a2 & 1) != 0)
      {
LABEL_19:
        memset(out, 0, 37);
        uuid_unparse_upper((const unsigned __int8 *)(*a1 + 160 * v7 + 88), out);
        uint64_t v14 = v151;
        __p.__r_.__value_.__s.__size_ = 4;
        strcpy((char *)&__p, "uuid");
        size_t v15 = strlen(out);
        if (v15 >= 0x7FFFFFFFFFFFFFF8LL) {
          std::string::__throw_length_error[abi:ne180100]();
        }
        unint64_t v16 = (void *)v15;
        uint64_t v17 = a2;
        if (v15 >= 0x17)
        {
          uint64_t v31 = (v15 & 0xFFFFFFFFFFFFFFF8LL) + 8;
          if ((v15 | 7) != 0x17) {
            uint64_t v31 = v15 | 7;
          }
          uint64_t v32 = v31 + 1;
          uint64_t v18 = (void **)operator new(v31 + 1);
          unint64_t v144 = v32 | 0x8000000000000000LL;
          __dst[0] = v18;
          __dst[1] = v16;
        }

        else
        {
          HIBYTE(v144) = v15;
          uint64_t v18 = __dst;
          if (!v15)
          {
LABEL_42:
            *((_BYTE *)v16 + (void)v18) = 0;
            JSONGenerator::Dictionary::AddStringItem(v14, &__p, (uint64_t)__dst);
            a2 = v17;
            if (SHIBYTE(v144) < 0) {
              operator delete(__dst[0]);
            }
            uint64_t v33 = *a1 + 160 * v7;
            uint64_t v34 = v33 + 104;
            int v35 = *(char *)(v33 + 127);
            if (v35 < 0)
            {
              if (!*(void *)(v34 + 8)) {
                goto LABEL_66;
              }
            }

            else if (!(_BYTE)v35)
            {
              goto LABEL_66;
            }

            uint64_t v36 = *a1 + 160 * v7;
            if (*(char *)(v36 + 151) < 0)
            {
              if (!*(void *)(v36 + 136)) {
                goto LABEL_66;
              }
            }

            else if (!*(_BYTE *)(v36 + 151))
            {
              goto LABEL_66;
            }

            uint64_t v37 = v151;
            v142.__r_.__value_.__s.__size_ = 19;
            strcpy((char *)&v142, "min_version_os_name");
            if (*(char *)(v34 + 23) < 0)
            {
              std::string::__init_copy_ctor_external( &v141,  *(const std::string::value_type **)v34,  *(void *)(v34 + 8));
            }

            else
            {
              __int128 v38 = *(_OWORD *)v34;
              v141.__r_.__value_.__l.__cap_ = *(void *)(v34 + 16);
              *(_OWORD *)&v141.__r_.__value_.__l.__data_ = v38;
            }

            JSONGenerator::Dictionary::AddStringItem(v37, &v142, (uint64_t)&v141);
            if ((char)v141.__r_.__value_.__s.__size_ < 0)
            {
              operator delete(v141.__r_.__value_.__l.__data_);
            }

            else if (((char)v142.__r_.__value_.__s.__size_ & 0x80000000) == 0)
            {
LABEL_59:
              uint64_t v39 = v151;
              v140.__r_.__value_.__s.__size_ = 18;
              strcpy((char *)&v140, "min_version_os_sdk");
              uint64_t v40 = *a1 + 160 * v7;
              uint64_t v41 = (const std::string::value_type **)(v40 + 128);
              if (*(char *)(v40 + 151) < 0)
              {
                std::string::__init_copy_ctor_external(&v139, *v41, *(void *)(v40 + 136));
              }

              else
              {
                __int128 v42 = *(_OWORD *)v41;
                v139.__r_.__value_.__l.__cap_ = *(void *)(v40 + 144);
                *(_OWORD *)&v139.__r_.__value_.__l.__data_ = v42;
              }

              JSONGenerator::Dictionary::AddStringItem(v39, &v140, (uint64_t)&v139);
              if ((char)v139.__r_.__value_.__s.__size_ < 0)
              {
                operator delete(v139.__r_.__value_.__l.__data_);
              }

              else if (((char)v140.__r_.__value_.__s.__size_ & 0x80000000) == 0)
              {
                goto LABEL_66;
              }

              operator delete(v140.__r_.__value_.__l.__data_);
LABEL_66:
              uint64_t v43 = operator new(0x38uLL);
              v43[1] = 0LL;
              v43[2] = 0LL;
              *((_DWORD *)v43 + 6) = 7;
              *uint64_t v43 = off_100060D18;
              v43[5] = 0LL;
              v43[6] = 0LL;
              v43[4] = 0LL;
              std::shared_ptr<JSONGenerator::Dictionary>::shared_ptr[abi:ne180100]<JSONGenerator::Dictionary,void>( &v137,  (uint64_t)v43);
              v136.__r_.__value_.__s.__size_ = 5;
              strcpy((char *)&v136, "magic");
              JSONGenerator::Dictionary::AddIntegerItem( v137,  &v136,  (void (__cdecl *)(std::__shared_weak_count *__hidden))*(unsigned int *)(*a1 + 160 * v7 + 32));
              v135.__r_.__value_.__s.__size_ = 7;
              strcpy((char *)&v135, "cputype");
              JSONGenerator::Dictionary::AddIntegerItem( v137,  &v135,  (void (__cdecl *)(std::__shared_weak_count *__hidden))*(unsigned int *)(*a1 + 160 * v7 + 36));
              v134.__r_.__value_.__s.__size_ = 10;
              strcpy((char *)&v134, "cpusubtype");
              JSONGenerator::Dictionary::AddIntegerItem( v137,  &v134,  (void (__cdecl *)(std::__shared_weak_count *__hidden))*(unsigned int *)(*a1 + 160 * v7 + 40));
              v133.__r_.__value_.__s.__size_ = 8;
              strcpy((char *)&v133, "filetype");
              JSONGenerator::Dictionary::AddIntegerItem( v137,  &v133,  (void (__cdecl *)(std::__shared_weak_count *__hidden))*(unsigned int *)(*a1 + 160 * v7 + 44));
              v132.__r_.__value_.__s.__size_ = 5;
              strcpy((char *)&v132, "flags");
              JSONGenerator::Dictionary::AddIntegerItem( v137,  &v132,  (void (__cdecl *)(std::__shared_weak_count *__hidden))*(unsigned int *)(*a1 + 160 * v7 + 56));
              uint64_t v44 = v151;
              char v131 = 11;
              uint64_t v128 = v137;
              BOOL v129 = v138;
              strcpy((char *)v130, "mach_header");
              if (v138)
              {
                p_shared_owners = (unint64_t *)&v138->__shared_owners_;
                do
                  unint64_t v46 = __ldxr(p_shared_owners);
                while (__stxr(v46 + 1, p_shared_owners));
              }

              JSONGenerator::Dictionary::AddItem(v44, (uint64_t)v130, &v128);
              char v47 = v129;
              if (!v129) {
                goto LABEL_83;
              }
              unint64_t v48 = (unint64_t *)&v129->__shared_owners_;
              do
                unint64_t v49 = __ldaxr(v48);
              while (__stlxr(v49 - 1, v48));
              if (!v49)
              {
                ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
                std::__shared_weak_count::__release_weak(v47);
                if (v131 < 0) {
LABEL_84:
                }
                  operator delete(v130[0]);
              }

              else
              {
LABEL_83:
                if (v131 < 0) {
                  goto LABEL_84;
                }
              }

              int v50 = operator new(0x38uLL);
              v50[1] = 0LL;
              v50[2] = 0LL;
              *((_DWORD *)v50 + 6) = 2;
              *int v50 = off_100060D90;
              v50[5] = 0LL;
              v50[6] = 0LL;
              v50[4] = 0LL;
              std::shared_ptr<JSONGenerator::Array>::shared_ptr[abi:ne180100]<JSONGenerator::Array,void>( &v126,  (uint64_t)v50);
              if (*(void *)(*a1 + 160 * v7 + 72) != *(void *)(*a1 + 160 * v7 + 64))
              {
                for (unint64_t i = 0LL;
                      i < 0x2E8BA2E8BA2E8BA3LL
                        * ((uint64_t)(*(void *)(*a1 + 160 * v7 + 72) - *(void *)(*a1 + 160 * v7 + 64)) >> 3);
                      ++i)
                {
                  int v52 = operator new(0x38uLL);
                  v52[1] = 0LL;
                  v52[2] = 0LL;
                  *((_DWORD *)v52 + 6) = 7;
                  *int v52 = off_100060D18;
                  v52[5] = 0LL;
                  v52[6] = 0LL;
                  v52[4] = 0LL;
                  std::shared_ptr<JSONGenerator::Dictionary>::shared_ptr[abi:ne180100]<JSONGenerator::Dictionary,void>( &v125,  (uint64_t)v52);
                  uint64_t v53 = v125;
                  v124.__r_.__value_.__s.__size_ = 4;
                  strcpy((char *)&v124, "name");
                  uint64_t v54 = *(void *)(*a1 + 160 * v7 + 64) + 88 * i;
                  if (*(char *)(v54 + 23) < 0)
                  {
                    std::string::__init_copy_ctor_external( &v123,  *(const std::string::value_type **)v54,  *(void *)(v54 + 8));
                  }

                  else
                  {
                    __int128 v55 = *(_OWORD *)v54;
                    v123.__r_.__value_.__l.__cap_ = *(void *)(v54 + 16);
                    *(_OWORD *)&v123.__r_.__value_.__l.__data_ = v55;
                  }

                  JSONGenerator::Dictionary::AddStringItem(v53, &v124, (uint64_t)&v123);
                  if ((char)v123.__r_.__value_.__s.__size_ < 0)
                  {
                    operator delete(v123.__r_.__value_.__l.__data_);
                  }

                  else if (((char)v124.__r_.__value_.__s.__size_ & 0x80000000) == 0)
                  {
                    goto LABEL_93;
                  }

                  operator delete(v124.__r_.__value_.__l.__data_);
LABEL_93:
                  v122.__r_.__value_.__s.__size_ = 6;
                  strcpy((char *)&v122, "vmaddr");
                  JSONGenerator::Dictionary::AddIntegerItem( v125,  &v122,  *(void (__cdecl **)(std::__shared_weak_count *__hidden))(*(void *)(*a1 + 160 * v7 + 64)
                                                                           + 88 * i
                                                                           + 24));
                  v121.__r_.__value_.__s.__size_ = 6;
                  strcpy((char *)&v121, "vmsize");
                  JSONGenerator::Dictionary::AddIntegerItem( v125,  &v121,  *(void (__cdecl **)(std::__shared_weak_count *__hidden))(*(void *)(*a1 + 160 * v7 + 64)
                                                                           + 88 * i
                                                                           + 32));
                  v120.__r_.__value_.__s.__size_ = 7;
                  strcpy((char *)&v120, "fileoff");
                  JSONGenerator::Dictionary::AddIntegerItem( v125,  &v120,  *(void (__cdecl **)(std::__shared_weak_count *__hidden))(*(void *)(*a1 + 160 * v7 + 64)
                                                                           + 88 * i
                                                                           + 40));
                  v119.__r_.__value_.__s.__size_ = 8;
                  strcpy((char *)&v119, "filesize");
                  JSONGenerator::Dictionary::AddIntegerItem( v125,  &v119,  *(void (__cdecl **)(std::__shared_weak_count *__hidden))(*(void *)(*a1 + 160 * v7 + 64)
                                                                           + 88 * i
                                                                           + 48));
                  v118.__r_.__value_.__s.__size_ = 7;
                  strcpy((char *)&v118, "maxprot");
                  JSONGenerator::Dictionary::AddIntegerItem( v125,  &v118,  *(void (__cdecl **)(std::__shared_weak_count *__hidden))(*(void *)(*a1 + 160 * v7 + 64)
                                                                           + 88 * i
                                                                           + 56));
                  uint64_t v56 = v126;
                  uint64_t v57 = v125;
                  __int128 v117 = v125;
                  if (*((void *)&v125 + 1))
                  {
                    unint64_t v58 = (unint64_t *)(*((void *)&v125 + 1) + 8LL);
                    do
                      unint64_t v59 = __ldxr(v58);
                    while (__stxr(v59 + 1, v58));
                  }

                  std::string::size_type v60 = *(void **)(v56 + 40);
                  if ((unint64_t)v60 >= *(void *)(v56 + 48))
                  {
                    int16x8_t v64 = std::vector<std::shared_ptr<JSONGenerator::Object>>::__push_back_slow_path<std::shared_ptr<JSONGenerator::Object> const&>( v56 + 32,  &v117);
                  }

                  else
                  {
                    *std::string::size_type v60 = v57;
                    uint64_t v61 = *((void *)&v117 + 1);
                    v60[1] = *((void *)&v117 + 1);
                    if (v61)
                    {
                      uint64_t v62 = (unint64_t *)(v61 + 8);
                      do
                        unint64_t v63 = __ldxr(v62);
                      while (__stxr(v63 + 1, v62));
                    }

                    int16x8_t v64 = v60 + 2;
                  }

                  *(void *)(v56 + 40) = v64;
                  int v65 = (std::__shared_weak_count *)*((void *)&v117 + 1);
                  if (!*((void *)&v117 + 1)) {
                    goto LABEL_116;
                  }
                  __int128 v66 = (unint64_t *)(*((void *)&v117 + 1) + 8LL);
                  do
                    unint64_t v67 = __ldaxr(v66);
                  while (__stlxr(v67 - 1, v66));
                  if (!v67)
                  {
                    ((void (*)(std::__shared_weak_count *))v65->__on_zero_shared)(v65);
                    std::__shared_weak_count::__release_weak(v65);
                    std::string v68 = (std::__shared_weak_count *)*((void *)&v125 + 1);
                    if (*((void *)&v125 + 1))
                    {
LABEL_117:
                      __int128 v69 = (unint64_t *)&v68->__shared_owners_;
                      do
                        unint64_t v70 = __ldaxr(v69);
                      while (__stlxr(v70 - 1, v69));
                      if (!v70)
                      {
                        ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
                        std::__shared_weak_count::__release_weak(v68);
                      }
                    }
                  }

                  else
                  {
LABEL_116:
                    std::string v68 = (std::__shared_weak_count *)*((void *)&v125 + 1);
                    if (*((void *)&v125 + 1)) {
                      goto LABEL_117;
                    }
                  }
                }
              }

              uint64_t v71 = v151;
              char v116 = 8;
              strcpy((char *)v115, "segments");
              uint64_t v113 = v126;
              __int128 v114 = v127;
              if (v127)
              {
                int v72 = (unint64_t *)&v127->__shared_owners_;
                do
                  unint64_t v73 = __ldxr(v72);
                while (__stxr(v73 + 1, v72));
              }

              JSONGenerator::Dictionary::AddItem(v71, (uint64_t)v115, &v113);
              unsigned int v74 = v114;
              if (!v114) {
                goto LABEL_132;
              }
              uint64_t v75 = (unint64_t *)&v114->__shared_owners_;
              do
                unint64_t v76 = __ldaxr(v75);
              while (__stlxr(v76 - 1, v75));
              if (!v76)
              {
                ((void (*)(std::__shared_weak_count *))v74->__on_zero_shared)(v74);
                std::__shared_weak_count::__release_weak(v74);
                if (v116 < 0) {
LABEL_133:
                }
                  operator delete(v115[0]);
              }

              else
              {
LABEL_132:
                if (v116 < 0) {
                  goto LABEL_133;
                }
              }

              uint64_t v77 = v152;
              uint64_t v78 = v151;
              __int128 v112 = v151;
              if (*((void *)&v151 + 1))
              {
                __int128 v79 = (unint64_t *)(*((void *)&v151 + 1) + 8LL);
                do
                  unint64_t v80 = __ldxr(v79);
                while (__stxr(v80 + 1, v79));
              }

              uint64_t v81 = *(void **)(v77 + 40);
              if ((unint64_t)v81 >= *(void *)(v77 + 48))
              {
                char v85 = std::vector<std::shared_ptr<JSONGenerator::Object>>::__push_back_slow_path<std::shared_ptr<JSONGenerator::Object> const&>( v77 + 32,  &v112);
              }

              else
              {
                *uint64_t v81 = v78;
                uint64_t v82 = *((void *)&v112 + 1);
                v81[1] = *((void *)&v112 + 1);
                if (v82)
                {
                  uint64_t v83 = (unint64_t *)(v82 + 8);
                  do
                    unint64_t v84 = __ldxr(v83);
                  while (__stxr(v84 + 1, v83));
                }

                char v85 = v81 + 2;
              }

              *(void *)(v77 + 40) = v85;
              uint64_t v86 = (std::__shared_weak_count *)*((void *)&v112 + 1);
              if (!*((void *)&v112 + 1)) {
                goto LABEL_147;
              }
              char v87 = (unint64_t *)(*((void *)&v112 + 1) + 8LL);
              do
                unint64_t v88 = __ldaxr(v87);
              while (__stlxr(v88 - 1, v87));
              if (!v88)
              {
                ((void (*)(std::__shared_weak_count *))v86->__on_zero_shared)(v86);
                std::__shared_weak_count::__release_weak(v86);
                unint64_t v89 = v127;
                if (v127)
                {
LABEL_148:
                  unsigned int v90 = (unint64_t *)&v89->__shared_owners_;
                  do
                    unint64_t v91 = __ldaxr(v90);
                  while (__stlxr(v91 - 1, v90));
                  if (!v91)
                  {
                    ((void (*)(std::__shared_weak_count *))v89->__on_zero_shared)(v89);
                    std::__shared_weak_count::__release_weak(v89);
                  }
                }
              }

              else
              {
LABEL_147:
                unint64_t v89 = v127;
                if (v127) {
                  goto LABEL_148;
                }
              }

              uint64_t v28 = v138;
              if (!v138) {
                goto LABEL_161;
              }
              uint64_t v92 = (unint64_t *)&v138->__shared_owners_;
              do
                unint64_t v30 = __ldaxr(v92);
              while (__stlxr(v30 - 1, v92));
              goto LABEL_160;
            }

            operator delete(v142.__r_.__value_.__l.__data_);
            goto LABEL_59;
          }
        }

        memcpy(v18, out, (size_t)v16);
        goto LABEL_42;
      }

LABEL_6:
      ++v7;
    }

    while (v7 != v107);
  }

  size_t v96 = operator new(0x38uLL);
  v96[1] = 0LL;
  v96[2] = 0LL;
  *((_DWORD *)v96 + 6) = 7;
  *size_t v96 = off_100060D18;
  v96[5] = 0LL;
  v96[6] = 0LL;
  v96[4] = 0LL;
  std::shared_ptr<JSONGenerator::Dictionary>::shared_ptr[abi:ne180100]<JSONGenerator::Dictionary,void>( out,  (uint64_t)v96);
  char v111 = 6;
  strcpy((char *)v110, "images");
  uint64_t v97 = *(void *)out;
  uint64_t v108 = v152;
  __int128 v109 = v153;
  if (v153)
  {
    __int128 v98 = (unint64_t *)&v153->__shared_owners_;
    do
      unint64_t v99 = __ldxr(v98);
    while (__stxr(v99 + 1, v98));
  }

  JSONGenerator::Dictionary::AddItem(v97, (uint64_t)v110, &v108);
  __int128 v100 = v109;
  if (!v109) {
    goto LABEL_177;
  }
  __int128 v101 = (unint64_t *)&v109->__shared_owners_;
  do
    unint64_t v102 = __ldaxr(v101);
  while (__stlxr(v102 - 1, v101));
  if (v102)
  {
LABEL_177:
    if ((v111 & 0x80000000) == 0) {
      goto LABEL_179;
    }
    goto LABEL_178;
  }

  ((void (*)(std::__shared_weak_count *))v100->__on_zero_shared)(v100);
  std::__shared_weak_count::__release_weak(v100);
  if (v111 < 0) {
LABEL_178:
  }
    operator delete(v110[0]);
LABEL_179:
  *a3 = *(_OWORD *)out;
  __int128 v103 = v153;
  if (v153)
  {
    __int128 v104 = (unint64_t *)&v153->__shared_owners_;
    do
      unint64_t v105 = __ldaxr(v104);
    while (__stlxr(v105 - 1, v104));
    if (!v105)
    {
      ((void (*)(std::__shared_weak_count *))v103->__on_zero_shared)(v103);
      std::__shared_weak_count::__release_weak(v103);
    }
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

  pthread_mutex_unlock(v3);
  return 1LL;
}

void sub_10003A848( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  std::shared_ptr<MachThread>::~shared_ptr[abi:ne180100](v21 - 144);
  std::shared_ptr<MachThread>::~shared_ptr[abi:ne180100](v21 - 160);
  _Unwind_Resume(a1);
}

void ___ZN11MachProcess30GetAllLoadedBinariesViaDYLDSPIERNSt3__16vectorINS_24binary_image_informationENS0_9allocatorIS2_EEEE_block_invoke( uint64_t a1, uint64_t a2, const unsigned __int8 *a3, std::string::value_type *__s)
{
  uint64_t v15 = -1LL;
  uint64_t v18 = 0LL;
  uint64_t v19 = 0LL;
  std::string __p = 0LL;
  *(_OWORD *)uint64_t v21 = 0u;
  *(_OWORD *)unint64_t v22 = 0u;
  __int128 v23 = 0u;
  char v24 = 0;
  std::string::assign(&v14, __s);
  uuid_copy(v20, a3);
  uint64_t v15 = a2;
  uint64_t v7 = *(void *)(a1 + 32);
  unint64_t v8 = *(void *)(v7 + 8);
  if (v8 >= *(void *)(v7 + 16))
  {
    int v10 = std::vector<MachProcess::binary_image_information>::__push_back_slow_path<MachProcess::binary_image_information const&>( (void **)v7,  (uint64_t)&v14);
  }

  else
  {
    if ((char)v14.__r_.__value_.__s.__size_ < 0)
    {
      std::string::__init_copy_ctor_external( *(std::string **)(v7 + 8),  v14.__r_.__value_.__l.__data_,  v14.__r_.__value_.__l.__size_);
    }

    else
    {
      __int128 v9 = *(_OWORD *)&v14.__r_.__value_.__l.__data_;
      *(void *)(v8 + 16) = v14.__r_.__value_.__l.__cap_;
      *(_OWORD *)unint64_t v8 = v9;
    }

    *(void *)(v8 + 24) = v15;
    MachProcess::mach_o_information::mach_o_information(v8 + 32, (uint64_t)&v16);
    *(_BYTE *)(v8 + 152) = v24;
    int v10 = (char *)(v8 + 160);
    *(void *)(v7 + 8) = v8 + 160;
  }

  *(void *)(v7 + 8) = v10;
  if (SHIBYTE(v23) < 0)
  {
    operator delete(v22[1]);
    if ((SHIBYTE(v22[0]) & 0x80000000) == 0)
    {
LABEL_9:
      uint64_t v11 = (void **)__p;
      if (__p) {
        goto LABEL_10;
      }
      goto LABEL_20;
    }
  }

  else if ((SHIBYTE(v22[0]) & 0x80000000) == 0)
  {
    goto LABEL_9;
  }

  operator delete(v21[0]);
  uint64_t v11 = (void **)__p;
  if (__p)
  {
LABEL_10:
    uint64_t v12 = v18;
    __int128 v13 = v11;
    if (v18 != v11)
    {
      do
      {
        v12 -= 11;
      }

      while (v12 != v11);
      __int128 v13 = __p;
    }

    uint64_t v18 = v11;
    operator delete(v13);
    return;
  }

void sub_10003ACD0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  *(void *)(v2 + 8) = v3;
  MachProcess::binary_image_information::~binary_image_information((void **)va);
  _Unwind_Resume(a1);
}

void MachProcess::binary_image_information::~binary_image_information(void **this)
{
  if (*((char *)this + 151) < 0)
  {
    operator delete(this[16]);
    if ((*((char *)this + 127) & 0x80000000) == 0)
    {
LABEL_3:
      uint64_t v2 = (void **)this[8];
      if (!v2) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }

  else if ((*((char *)this + 127) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }

  operator delete(this[13]);
  uint64_t v2 = (void **)this[8];
  if (!v2)
  {
LABEL_4:
LABEL_15:
    operator delete(*this);
    return;
  }

void MachProcess::GetAllLoadedLibrariesInfos( MachProcess *this@<X0>, int a2@<W1>, uint64_t a3@<X2>, _OWORD *a4@<X8>)
{
  std::string __p = (void *)0xE00000001LL;
  LODWORD(v27) = 1;
  HIDWORD(v27) = a2;
  size_t v25 = 648LL;
  int v7 = sysctl((int *)&__p, 4u, v29, &v25, 0LL, 0LL);
  else {
    int v10 = 8;
  }
  std::string __p = 0LL;
  int v27 = 0LL;
  uint64_t v28 = 0LL;
  uint64_t v11 = (uint64_t (*)(void, void, size_t *))*((void *)this + 220);
  if (v11)
  {
    LODWORD(v25) = 0;
    uint64_t v12 = v11(*((unsigned int *)this + 30), 0LL, &v25);
    uint64_t v13 = v12;
    if (v12)
    {
      std::string v14 = (void (*)(uint64_t, void *))*((void *)this + 221);
      v29[0] = _NSConcreteStackBlock;
      v29[1] = 3221225472LL;
      v29[2] = ___ZN11MachProcess30GetAllLoadedBinariesViaDYLDSPIERNSt3__16vectorINS_24binary_image_informationENS0_9allocatorIS2_EEEE_block_invoke;
      v29[3] = &__block_descriptor_40_e19_v32__0Q8_16C_16r_24l;
      p_p = &__p;
      v14(v12, v29);
      (*((void (**)(uint64_t))this + 222))(v13);
    }
  }

  if ((_DWORD)a3)
  {
    int v15 = *((_DWORD *)this + 2);
    if (!v15)
    {
      uint64_t v16 = (uint64_t (*)(void, void, void *))*((void *)this + 220);
      if (v16 && (LODWORD(v29[0]) = 0, uint64_t v17 = v16(*((unsigned int *)this + 30), 0LL, v29), (v18 = v17) != 0))
      {
        uint64_t v19 = (uint64_t (*)(uint64_t))*((void *)this + 224);
        if (v19) {
          int v15 = v19(v17);
        }
        else {
          int v15 = 0;
        }
        (*((void (**)(uint64_t))this + 222))(v18);
      }

      else
      {
        int v15 = 0;
      }

      *((_DWORD *)this + 2) = v15;
    }

    if (v27 != __p)
    {
      uint64_t v20 = 0LL;
      else {
        uint64_t v21 = (v27 - (_BYTE *)__p) / 160;
      }
      do
      {
        if (MachProcess::GetMachOInformationFromMemory( (uint64_t)this,  v15,  *(void *)((char *)__p + v20 + 24),  v10,  (uint64_t)__p + v20 + 32)) {
          *((_BYTE *)__p + v20 + 152) = 1;
        }
        v20 += 160LL;
        --v21;
      }

      while (v21);
    }
  }

  MachProcess::FormatDynamicLibrariesIntoJSON(&__p, a3, a4);
  unint64_t v22 = __p;
  if (__p)
  {
    uint64_t v23 = (uint64_t)v27;
    char v24 = __p;
    if (v27 != __p)
    {
      do
      {
        v23 -= 160LL;
        std::allocator<MachProcess::binary_image_information>::destroy[abi:ne180100]((uint64_t)&v28, v23);
      }

      while ((_BYTE *)v23 != v22);
      char v24 = __p;
    }

    int v27 = v22;
    operator delete(v24);
  }

void sub_10003B03C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void **std::vector<MachProcess::binary_image_information>::~vector[abi:ne180100](void **a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    unint64_t v4 = *a1;
    if ((void *)v3 != v2)
    {
      do
      {
        v3 -= 160LL;
        std::allocator<MachProcess::binary_image_information>::destroy[abi:ne180100]((uint64_t)(a1 + 2), v3);
      }

      while ((void *)v3 != v2);
      unint64_t v4 = *a1;
    }

    a1[1] = v2;
    operator delete(v4);
  }

  return a1;
}

void MachProcess::GetLibrariesInfoForAddresses( uint64_t a1@<X0>, int a2@<W1>, void *a3@<X2>, _OWORD *a4@<X8>)
{
  uint64_t v53 = (void *)0xE00000001LL;
  LODWORD(v54) = 1;
  HIDWORD(v54) = a2;
  size_t v50 = 648LL;
  int v7 = sysctl((int *)&v53, 4u, &v56, &v50, 0LL, 0LL);
  else {
    int v10 = 8;
  }
  uint64_t v53 = 0LL;
  uint64_t v54 = 0LL;
  uint64_t v55 = 0LL;
  uint64_t v11 = *(uint64_t (**)(void, void, size_t *))(a1 + 1760);
  if (v11)
  {
    LODWORD(v50) = 0;
    uint64_t v12 = v11(*(unsigned int *)(a1 + 120), 0LL, &v50);
    uint64_t v13 = v12;
    if (v12)
    {
      std::string v14 = *(void (**)(uint64_t, void **))(a1 + 1768);
      uint64_t v56 = _NSConcreteStackBlock;
      uint64_t v57 = 3221225472LL;
      unint64_t v58 = ___ZN11MachProcess30GetAllLoadedBinariesViaDYLDSPIERNSt3__16vectorINS_24binary_image_informationENS0_9allocatorIS2_EEEE_block_invoke;
      uint64_t v59 = (uint64_t)&__block_descriptor_40_e19_v32__0Q8_16C_16r_24l;
      std::string::size_type v60 = &v53;
      v14(v12, &v56);
      (*(void (**)(uint64_t))(a1 + 1776))(v13);
    }
  }

  int v15 = *(_DWORD *)(a1 + 8);
  if (!v15)
  {
    uint64_t v16 = *(uint64_t (**)(void, void, void **))(a1 + 1760);
    if (v16 && (LODWORD(v56) = 0, uint64_t v17 = v16(*(unsigned int *)(a1 + 120), 0LL, &v56), (v18 = v17) != 0))
    {
      uint64_t v19 = *(uint64_t (**)(uint64_t))(a1 + 1792);
      if (v19) {
        int v15 = v19(v17);
      }
      else {
        int v15 = 0;
      }
      (*(void (**)(uint64_t))(a1 + 1776))(v18);
    }

    else
    {
      int v15 = 0;
    }

    *(_DWORD *)(a1 + 8) = v15;
  }

  size_t v50 = 0LL;
  unint64_t v51 = 0LL;
  unint64_t v52 = 0LL;
  uint64_t v20 = a3[1] - *a3;
  if (v20)
  {
    int v46 = v10;
    uint64_t v47 = a1;
    unint64_t v48 = a4;
    uint64_t v21 = 0LL;
    unint64_t v22 = v53;
    unint64_t v49 = v54;
    unint64_t v23 = v20 >> 3;
    else {
      uint64_t v24 = (v54 - (_BYTE *)v53) / 160;
    }
    if (v23 <= 1) {
      uint64_t v25 = 1LL;
    }
    else {
      uint64_t v25 = v23;
    }
    while (1)
    {
      if (v49 != v22)
      {
        uint64_t v26 = 0LL;
        char v27 = 0;
        while (2)
        {
          uint64_t v28 = (char *)v53 + 160 * v26;
          uint64_t v29 = v26;
          while (*((void *)v28 + 3) != *(void *)(*a3 + 8 * v21))
          {
            ++v29;
            v28 += 160;
            if (v24 == v29)
            {
              if ((v27 & 1) != 0) {
                goto LABEL_30;
              }
              goto LABEL_46;
            }
          }

          unint64_t v30 = v51;
          if ((unint64_t)v51 >= v52)
          {
            uint64_t v32 = (std::string *)std::vector<MachProcess::binary_image_information>::__push_back_slow_path<MachProcess::binary_image_information const&>( (void **)&v50,  (uint64_t)v28);
          }

          else
          {
            if (v28[23] < 0)
            {
              std::string::__init_copy_ctor_external(v51, *(const std::string::value_type **)v28, *((void *)v28 + 1));
            }

            else
            {
              __int128 v31 = *(_OWORD *)v28;
              v51->__r_.__value_.__l.__cap_ = *((void *)v28 + 2);
              *(_OWORD *)&v30->__r_.__value_.__l.__data_ = v31;
            }

            v30[1].__r_.__value_.__r.__words[0] = *((void *)v28 + 3);
            MachProcess::mach_o_information::mach_o_information( (uint64_t)&v30[1].__r_.__value_.__l.__size_,  (uint64_t)(v28 + 32));
            v30[6].__r_.__value_.__s.__data_[8] = v28[152];
            uint64_t v32 = (std::string *)((char *)v30 + 160);
          }

          unint64_t v51 = v32;
          uint64_t v26 = v29 + 1;
          char v27 = 1;
          if (v24 - 1 != v29) {
            continue;
          }
          goto LABEL_30;
        }
      }

void sub_10003B5E0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

double MachProcess::GetSharedCacheInfo@<D0>(MachProcess *this@<X0>, _OWORD *a2@<X8>)
{
  unint64_t v4 = operator new(0x38uLL);
  v4[2] = 0LL;
  *((_DWORD *)v4 + 6) = 7;
  *unint64_t v4 = off_100060D18;
  v4[1] = 0LL;
  v4[5] = 0LL;
  v4[6] = 0LL;
  v4[4] = 0LL;
  std::shared_ptr<JSONGenerator::Dictionary>::shared_ptr[abi:ne180100]<JSONGenerator::Dictionary,void>( &v24,  (uint64_t)v4);
  size_t v5 = (uint64_t (*)(void, void, int *))*((void *)this + 220);
  if (!v5) {
    goto LABEL_21;
  }
  if (!*((void *)this + 223)) {
    goto LABEL_21;
  }
  int v23 = 0;
  uint64_t v6 = v5(*((unsigned int *)this + 30), 0LL, &v23);
  uint64_t v7 = v6;
  if (!v6) {
    goto LABEL_21;
  }
  (*((void (**)(uint64_t, unsigned __int8 *))this + 223))(v6, uu);
  uint64_t v8 = v24;
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x20uLL);
  *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = xmmword_100051F90;
  strcpy(__p.__r_.__value_.__l.__data_, "shared_cache_base_address");
  JSONGenerator::Dictionary::AddIntegerItem(v8, &__p, v27);
  memset(out, 0, 37);
  uuid_unparse_upper(uu, out);
  uint64_t v9 = v24;
  v21.__r_.__value_.__s.__size_ = 17;
  strcpy((char *)&v21, "shared_cache_uuid");
  size_t v10 = strlen(out);
  if (v10 >= 0x7FFFFFFFFFFFFFF8LL) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  uint64_t v11 = (void *)v10;
  if (v10 >= 0x17)
  {
    uint64_t v13 = (v10 & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((v10 | 7) != 0x17) {
      uint64_t v13 = v10 | 7;
    }
    uint64_t v14 = v13 + 1;
    uint64_t v12 = (void **)operator new(v13 + 1);
    __dst[1] = v11;
    unint64_t v20 = v14 | 0x8000000000000000LL;
    __dst[0] = v12;
    goto LABEL_13;
  }

  HIBYTE(v20) = v10;
  uint64_t v12 = __dst;
  if (v10) {
LABEL_13:
  }
    memcpy(v12, out, (size_t)v11);
  *((_BYTE *)v11 + (void)v12) = 0;
  JSONGenerator::Dictionary::AddStringItem(v9, &v21, (uint64_t)__dst);
  if (SHIBYTE(v20) < 0)
  {
    operator delete(__dst[0]);
LABEL_23:
    operator delete(v21.__r_.__value_.__l.__data_);
    goto LABEL_16;
  }

void sub_10003B954( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, void *a22, uint64_t a23, int a24, __int16 a25, char a26, char a27, uint64_t a28, uint64_t a29, int a30, __int16 a31, char a32, char a33, uint64_t a34, uint64_t a35, uint64_t a36, int a37, __int16 a38, char a39, char a40, uint64_t a41, char a42)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  std::shared_ptr<MachThread>::~shared_ptr[abi:ne180100]((uint64_t)&a42);
  _Unwind_Resume(a1);
}

uint64_t MachProcess::GetCurrentThread(MachProcess *this)
{
  return MachThreadList::CurrentThreadID((MachProcess *)((char *)this + 968));
}

uint64_t MachProcess::SetCurrentThread(MachProcess *this, uint64_t a2)
{
  return MachThreadList::SetCurrentThread((MachProcess *)((char *)this + 968), a2);
}

uint64_t MachProcess::GetThreadStoppedReason(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t ThreadStoppedReason = MachThreadList::GetThreadStoppedReason(a1 + 968, a2, (uint64_t)a3);
  if ((_DWORD)ThreadStoppedReason)
  {
    if (*(_BYTE *)(a1 + 1752))
    {
      *a3 = 3;
    }

    else if (*a3 == 4)
    {
      MachProcess::RefineWatchpointStopInfo(a1, a2, (uint64_t)a3);
    }
  }

  return ThreadStoppedReason;
}

void MachProcess::RefineWatchpointStopInfo(uint64_t a1, uint64_t a2, uint64_t a3)
{
  size_t v5 = (DNBBreakpointList *)(a1 + 1664);
  NearestWatchpoint = DNBBreakpointList::FindNearestWatchpoint((DNBBreakpointList *)(a1 + 1664), *(void *)(a3 + 264));
  if (NearestWatchpoint)
  {
    uint64_t v7 = NearestWatchpoint;
    *(void *)(a3 + 272) = *((void *)NearestWatchpoint + 2);
    *(_DWORD *)(a3 + 280) = *((_DWORD *)NearestWatchpoint + 7);
    if (DNBLogEnabledForAny(2048)) {
      _DNBLogThreaded( "MachProcess::RefineWatchpointStopInfo mach exception addr 0x%llx moved in to nearest watchpoint, 0x%llx-0x%llx",  *(void *)(a3 + 264),  *((void *)v7 + 2),  *((void *)v7 + 2) + *((unsigned int *)v7 + 1) - 1LL);
    }
  }

  else
  {
    *(void *)(a3 + 272) = *(void *)(a3 + 264);
  }

  *(_BYTE *)(a3 + 284) = 0;
  unint64_t v45 = 0LL;
  uint64_t v39 = a1 + 968;
  MachThreadList::GetThreadByID((MachThreadList *)(a1 + 968), a2, &v42);
  if (v42 && *(void *)(v42 + 184))
  {
    uint64_t RegisterSetInfo = DNBArchProtocol::GetRegisterSetInfo((DNBArchProtocol *)&v45, v8);
  }

  else
  {
    uint64_t RegisterSetInfo = 0LL;
    unint64_t v45 = 0LL;
  }

  int v35 = v5;
  size_t v10 = v43;
  if (v43)
  {
    p_shared_owners = (unint64_t *)&v43->__shared_owners_;
    do
      unint64_t v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  unint64_t v13 = v45;
  if (v45)
  {
    uint64_t v36 = a3;
    uint64_t v37 = RegisterSetInfo;
    unint64_t v14 = 0LL;
    char v15 = 0;
    unint64_t v40 = 0LL;
    char v16 = 0;
    uint64_t v38 = 0LL;
    do
    {
      uint64_t v17 = RegisterSetInfo + 24 * v14;
      uint64_t v19 = *(void *)(v17 + 8);
      std::string v18 = (void *)(v17 + 8);
      if (v19)
      {
        uint64_t v20 = RegisterSetInfo + 24 * v14;
        uint64_t v22 = *(void *)(v20 + 16);
        std::string v21 = (unint64_t *)(v20 + 16);
        if (v22)
        {
          unint64_t v23 = 0LL;
          unsigned int v24 = 1;
          do
          {
            uint64_t v25 = *(const char **)(*v18 + 72 * v23 + 8);
            if (!strcmp(v25, "esr"))
            {
              int RegisterValue = MachThreadList::GetRegisterValue(v39, a2);
              unint64_t v27 = v40;
              if (RegisterValue) {
                unint64_t v27 = v44;
              }
              unint64_t v40 = v27;
              if (RegisterValue) {
                char v15 = 1;
              }
              uint64_t v25 = *(const char **)(*v18 + 72 * v23 + 8);
            }

            if (!strcmp(v25, "far"))
            {
              int v28 = MachThreadList::GetRegisterValue(v39, a2);
              unint64_t v29 = v38;
              if (v28) {
                unint64_t v29 = v44;
              }
              uint64_t v38 = v29;
              if (v28) {
                char v16 = 1;
              }
            }

            unint64_t v23 = v24++;
          }

          while (*v21 > v23);
          unint64_t v13 = v45;
          uint64_t RegisterSetInfo = v37;
        }
      }

      ++v14;
    }

    while (v14 < v13);
    if (v15 && v16)
    {
      if (v38 != *(void *)(v36 + 264) && DNBLogEnabledForAny(2048)) {
        _DNBLogThreaded( "MachProcess::RefineWatchpointStopInfo mach exception addr 0x%llx but FAR register has value 0x%llx",  *(void *)(v36 + 264),  v38);
      }
      if ((v40 & 0xFC000000) == 0xD0000000)
      {
        *(_BYTE *)(v36 + 284) = 1;
        *(_DWORD *)(v36 + 288) = v40 & 0xFFFFFF;
        *(_DWORD *)(v36 + 292) = (v40 >> 18) & 0x3F;
        uint64x2_t v30 = (uint64x2_t)vdupq_n_s64(v40);
        int16x8_t v31 = (int16x8_t)vuzp1q_s32( (int32x4_t)vshlq_u64(v30, (uint64x2_t)xmmword_100051FC0),  (int32x4_t)vshlq_u64(v30, (uint64x2_t)xmmword_100051FB0));
        *(int8x8_t *)v31.i8 = vand_s8((int8x8_t)vmovn_s32((int32x4_t)v31), (int8x8_t)0x1000100010001LL);
        *(_DWORD *)(v36 + 296) = vmovn_s16(v31).u32[0];
        *(_BYTE *)(v36 + 300) = (v40 & 0x400) != 0;
        BOOL v32 = (v40 & 0x40) != 0;
        *(_BYTE *)(v36 + 301) = v32;
        *(_BYTE *)(v36 + 302) = v32;
        *(_DWORD *)(v36 + 304) = v40 & 0x3F;
        if (DNBLogEnabledForAny(2048)) {
          _DNBLogThreaded( "ESR watchpoint fields parsed: iss = 0x%x, wpt = %u, wptv = %d, wpf = %d, fnp = %d, vncr = %d, fnv = %d, cm = %d, wnr = %d, dfsc = 0x%x",  *(_DWORD *)(v36 + 288),  *(_DWORD *)(v36 + 292),  *(unsigned __int8 *)(v36 + 296),  *(unsigned __int8 *)(v36 + 297),  *(unsigned __int8 *)(v36 + 298),  *(unsigned __int8 *)(v36 + 299),  *(unsigned __int8 *)(v36 + 300),  *(unsigned __int8 *)(v36 + 301),  *(unsigned __int8 *)(v36 + 302),  *(_DWORD *)(v36 + 304));
        }
        if (*(_BYTE *)(v36 + 296))
        {
          if (DNBLogEnabledForAny(2048)) {
            _DNBLogThreaded("Watchpoint Valid field true, finding startaddr of watchpoint %d", *(_DWORD *)(v36 + 292));
          }
          int v33 = *(_DWORD *)(v36 + 292);
          *(_DWORD *)(v36 + 280) = v33;
          uint64_t v34 = DNBBreakpointList::FindByHardwareIndex(v35, v33);
          if (v34) {
            *(void *)(v36 + 272) = *((void *)v34 + 2);
          }
        }
      }
    }
  }

void sub_10003BE1C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26)
{
}

char *MachProcess::GetThreadInfo(MachProcess *this, uint64_t a2)
{
  return MachThreadList::GetThreadInfo((MachProcess *)((char *)this + 968), a2);
}

uint64_t MachProcess::GetCPUType(MachProcess *this)
{
  uint64_t result = *((unsigned int *)this + 1);
  if (!(_DWORD)result)
  {
    int v3 = *(_DWORD *)this;
    if (*(_DWORD *)this)
    {
      __int128 v9 = 0u;
      __int128 v10 = 0u;
      *(_OWORD *)uint64_t v8 = 0u;
      size_t v7 = 12LL;
      if (sysctlnametomib("sysctl.proc_cputype", v8, &v7))
      {
        uint64_t result = 0LL;
      }

      else
      {
        size_t v4 = v7;
        v8[v7] = v3;
        size_t v7 = v4 + 1;
        unsigned int v6 = 0;
        size_t v5 = 4LL;
        if (sysctl(v8, v4 + 1, &v6, &v5, 0LL, 0LL)) {
          uint64_t result = 0LL;
        }
        else {
          uint64_t result = v6;
        }
      }

      *((_DWORD *)this + 1) = result;
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t MachProcess::GetRegisterValue(uint64_t a1, uint64_t a2)
{
  return MachThreadList::GetRegisterValue(a1 + 968, a2);
}

uint64_t MachProcess::SetRegisterValue(uint64_t a1, uint64_t a2)
{
  return MachThreadList::SetRegisterValue(a1 + 968, a2);
}

uint64_t MachProcess::SetState(uint64_t a1, unsigned int a2)
{
  size_t v4 = (pthread_mutex_t *)(a1 + 1224);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1224));
  unsigned int v5 = *(_DWORD *)(a1 + 1216);
  if (v5 == 9)
  {
    if (DNBLogEnabledForAny(2))
    {
      DNBStateAsString(a2);
      _DNBLogThreaded("MachProcess::SetState(%s) ignoring new state since current state is exited");
    }

void sub_10003C0B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t MachProcess::STDIOThread(MachProcess *this, void *a2)
{
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("MachProcess::%s(arg = %p) thread starting...", "STDIOThread", this);
  }
  pthread_setname_np("stdio monitoring thread");
  *(_OWORD *)std::string __p = 0u;
  __int128 v21 = 0u;
  int v3 = *((_DWORD *)this + 4);
  if (v3 == *((_DWORD *)this + 5)) {
    int v4 = -1;
  }
  else {
    int v4 = *((_DWORD *)this + 5);
  }
  BOOL v5 = v3 >= 0;
  BOOL v6 = v4 >= 0;
  while ((v3 & 0x80000000) == 0 || (v4 & 0x80000000) == 0)
  {
    pthread_testcancel();
    memset(&v19, 0, sizeof(v19));
    if (v5 && __darwin_check_fd_set_overflow(v3, &v19, 0)) {
      v19.fds_bits[v3 >> 5] |= 1 << v3;
    }
    if (v6 && __darwin_check_fd_set_overflow(v4, &v19, 0)) {
      v19.fds_bits[v4 >> 5] |= 1 << v4;
    }
    if (v3 <= v4) {
      int v7 = v4;
    }
    else {
      int v7 = v3;
    }
    int v8 = select(v7 + 1, &v19, 0LL, 0LL, 0LL);
    if (DNBLogEnabledForAny(2)) {
      _DNBLogThreaded("select (nfds, &read_fds, NULL, NULL, NULL) => %d", v8);
    }
    if (v8 < 0)
    {
      unsigned int v11 = *__error();
      if (DNBLogCheckLogBit(2))
      {
        __p[0] = (void *)(v11 | 0x200000000LL);
        if (SHIBYTE(v21) < 0)
        {
          *(_BYTE *)__p[1] = 0;
          *(void *)&__int128 v21 = 0LL;
        }

        else
        {
          LOBYTE(__p[1]) = 0;
          HIBYTE(v21) = 0;
        }

        DNBError::LogThreadedIfError((DNBError *)__p, "select (nfds, &read_fds, NULL, NULL, NULL) => %d", v8);
      }

      if (v11 == 9) {
        goto LABEL_55;
      }
    }

    else if (v8)
    {
      v22[1023] = 0;
      if (v5
        && __darwin_check_fd_set_overflow(v3, &v19, 0)
        && ((v19.fds_bits[v3 >> 5] >> v3) & 1) != 0)
      {
        while (1)
        {
          std::string::size_type v9 = read(v3, v22, 0x3FFuLL);
          std::string::size_type v10 = v9;
          if ((v9 & 0x8000000000000000LL) != 0)
          {
            int v12 = *__error();
            if (DNBLogEnabledForAny(2))
            {
              unint64_t v13 = strerror(v12);
              _DNBLogThreaded("read (stdout_fd,) => %zd   errno: %d (%s)", v10, v12, v13);
            }

            goto LABEL_36;
          }

          if (!v9) {
            break;
          }
          MachProcess::AppendSTDOUT(this, v22, v9);
        }

        if (DNBLogEnabledForAny(2)) {
          _DNBLogThreaded("read (stdout_fd,) => %zd  (reached EOF for child STDOUT)", 0LL);
        }
        int v3 = -1;
        if (v6) {
          goto LABEL_37;
        }
      }

      else
      {
LABEL_36:
        if (v6)
        {
LABEL_37:
          if (__darwin_check_fd_set_overflow(v4, &v19, 0)
            && ((v19.fds_bits[v4 >> 5] >> v4) & 1) != 0)
          {
            while (1)
            {
              std::string::size_type v14 = read(v4, v22, 0x3FFuLL);
              std::string::size_type v15 = v14;
              if ((v14 & 0x8000000000000000LL) != 0) {
                break;
              }
              if (!v14)
              {
                if (DNBLogEnabledForAny(2)) {
                  _DNBLogThreaded("read (stderr_fd,) => %zd  (reached EOF for child STDERR)", 0LL);
                }
                int v4 = -1;
                goto LABEL_51;
              }

              MachProcess::AppendSTDOUT(this, v22, v14);
            }

            int v16 = *__error();
            if (DNBLogEnabledForAny(2))
            {
              uint64_t v17 = strerror(v16);
              _DNBLogThreaded("read (stderr_fd,) => %zd   errno: %d (%s)", v15, v16, v17);
            }
          }
        }
      }
    }

void sub_10003C474( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, void *__p, uint64_t a31, int a32, __int16 a33, char a34, char a35)
{
  if (a35 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

pthread_mutex_t *MachProcess::SetEnableAsyncProfiling(pthread_mutex_t *result, int a2, int a3, int a4)
{
  int v4 = result;
  result[8].__opaque[24] = a2;
  *(_DWORD *)&result[8].__opaque[28] = a3;
  *(_DWORD *)&result[8].__opaque[32] = a4;
  uint64_t v5 = *(void *)&result[8].__opaque[40];
  if (a2)
  {
    if (!v5)
    {
      if (DNBLogEnabledForAny(2)) {
        _DNBLogThreaded("MachProcess::%s()", "StartProfileThread");
      }
      return (pthread_mutex_t *)pthread_create( (pthread_t *)&v4[8].__opaque[40],  0LL,  (void *(__cdecl *)(void *))MachProcess::ProfileThread,  v4);
    }
  }

  else if (v5)
  {
    PThreadEvent::SetEvents((pthread_mutex_t *)((char *)result + 656), 1);
    pthread_join(*(pthread_t *)&v4[8].__opaque[40], 0LL);
    *(void *)&v4[8].__opaque[40] = 0LL;
    return PThreadEvent::ResetEvents((pthread_mutex_t *)((char *)v4 + 656), 1);
  }

  return result;
}

uint64_t MachProcess::ProfileThread(MachProcess *this, void *a2)
{
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("MachProcess::%s(arg = %p) thread starting...", "ProfileThread", this);
  }
  pthread_setname_np("performance profiling thread");
  while (*((_BYTE *)this + 544))
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 1224));
    int v3 = *((_DWORD *)this + 304);
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 1224));
    if (v3 != 5)
    {
      if (v3 == 1 || v3 == 8) {
        return 0LL;
      }
      goto LABEL_17;
    }

    MachTask::GetProfileData((uint64_t)this + 104, *((_DWORD *)this + 138), v4, &__p);
    if (v13 < 0)
    {
      if (!*(void *)&__p.tv_usec) {
        goto LABEL_16;
      }
      int tv_sec = (const char *)__p.tv_sec;
    }

    else
    {
      if (!v13) {
        goto LABEL_17;
      }
      int tv_sec = (const char *)&__p;
    }

    MachProcess::SignalAsyncProfileData(this, tv_sec);
    if (v13 < 0) {
LABEL_16:
    }
      operator delete((void *)__p.tv_sec);
LABEL_17:
    unsigned int v6 = *((_DWORD *)this + 137);
    uint64_t v7 = v6 / 0xF4240;
    uint64_t v8 = v6 % 0xF4240;
    gettimeofday(&__p, 0LL);
    v11.int tv_sec = __p.tv_sec;
    v11.tv_nsec = 1000LL * __p.tv_usec;
    if (v8 | v7)
    {
      uint64_t v9 = 1000LL * __p.tv_usec + v8;
      v11.int tv_sec = __p.tv_sec + v7 + v9 / 1000000000;
      v11.tv_nsec = v9 % 1000000000;
    }
  }

  return 0LL;
}

void sub_10003C6F4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL MachProcess::Resume(MachProcess *this, char **a2)
{
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("MachProcess::Resume ()");
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 1224));
  unsigned int v4 = *((_DWORD *)this + 304);
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 1224));
  if (v4 == 5)
  {
    if (DNBLogEnabled()) {
      _DNBLog( 0LL,  (uint64_t)"Resume() - task 0x%x is already running, ignoring...",  v5,  v6,  v7,  v8,  v9,  v10,  *((unsigned int *)this + 30));
    }
    return 1LL;
  }

  if (v4 == 4)
  {
    if ((char **)((char *)this + 832) != a2) {
      std::vector<DNBThreadResumeAction>::__assign_with_size[abi:ne180100]<DNBThreadResumeAction*,DNBThreadResumeAction*>( (void *)this + 104,  *a2,  a2[1],  0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3));
    }
    std::vector<BOOL>::operator=((uint64_t)this + 856, (uint64_t)(a2 + 3));
    MachProcess::PrivateResume(this);
    return 1LL;
  }

  BOOL result = DNBLogEnabled();
  if (result)
  {
    uint64_t v12 = *((unsigned int *)this + 30);
    DNBStateAsString(v4);
    _DNBLog(0LL, (uint64_t)"Resume() - task 0x%x has state %s, can't continue...", v13, v14, v15, v16, v17, v18, v12);
    return 0LL;
  }

  return result;
}

uint64_t MachProcess::PrivateResume(MachProcess *this)
{
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 904);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 904));
  int v3 = *((_DWORD *)this + 436);
  *((_DWORD *)this + 437) = v3;
  if (v3)
  {
    if (DNBLogEnabledForAny(2)) {
      _DNBLogThreaded( "MachProcess::PrivateResume() - task 0x%x resuming (with unhandled interrupt signal %i)...",  *((_DWORD *)this + 30),  *((_DWORD *)this + 437));
    }
  }

  else if (DNBLogEnabledForAny(2))
  {
    _DNBLogThreaded("MachProcess::PrivateResume() - task 0x%x resuming...", *((_DWORD *)this + 30));
  }

  MachProcess::ReplyToAllExceptions(this);
  MachThreadList::ProcessWillResume((MachProcess *)((char *)this + 968), this, (MachProcess *)((char *)this + 832));
  else {
    unsigned int v4 = 5;
  }
  MachProcess::SetState((uint64_t)this, v4);
  MachTask::Resume((MachProcess *)((char *)this + 104), v5, v6);
  return pthread_mutex_unlock(v2);
}

void sub_10003C8FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t MachProcess::Kill(MachProcess *this, const timespec *a2)
{
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("MachProcess::Kill ()");
  }
  unsigned int v3 = MachProcess::DoSIGSTOP(this, 1, 0, 0LL);
  if (DNBLogEnabledForAny(2))
  {
    unsigned int v4 = DNBStateAsString(v3);
    _DNBLogThreaded("MachProcess::Kill() DoSIGSTOP() state = %s", v4);
  }

  *__error() = 0;
  if (DNBLogEnabled()) {
    _DNBLog( 0LL,  (uint64_t)"Sending ptrace PT_KILL to terminate inferior process pid %d.",  v5,  v6,  v7,  v8,  v9,  v10,  *(unsigned int *)this);
  }
  ptrace(8, *(_DWORD *)this, 0LL, 0);
  *(_OWORD *)uint64_t v34 = 0u;
  __int128 v35 = 0u;
  LODWORD(v34[0]) = *__error();
  HIDWORD(v34[0]) = 2;
  LOBYTE(v34[1]) = 0;
  HIBYTE(v35) = 0;
  BOOL v11 = DNBLogCheckLogBit(2);
  int v12 = (int)v34[0];
  if (LODWORD(v34[0])) {
    int v13 = 1;
  }
  else {
    int v13 = v11;
  }
  if (v13 == 1)
  {
    int v14 = *(_DWORD *)this;
    uint64_t v15 = (const char *)DNBError::AsString((DNBError *)v34);
    DNBError::LogThreaded( (DNBError *)v34,  "MachProcess::Kill() DoSIGSTOP() ::ptrace (PT_KILL, pid=%u, 0, 0) => 0x%8.8x (%s)",  v14,  v12,  v15);
  }

  DNBThreadResumeActions::DNBThreadResumeActions((uint64_t)__p, 5, 0);
  uint64_t v16 = (void *)*((void *)this + 104);
  if (v16)
  {
    *((void *)this + 105) = v16;
    operator delete(v16);
    *((void *)this + 104) = 0LL;
    *((void *)this + 105) = 0LL;
    *((void *)this + 106) = 0LL;
  }

  *((_OWORD *)this + 52) = *(_OWORD *)__p;
  *((void *)this + 106) = v31;
  __p[1] = 0LL;
  uint64_t v31 = 0LL;
  __p[0] = 0LL;
  uint64_t v17 = (void *)*((void *)this + 107);
  if (v17)
  {
    operator delete(v17);
    *((void *)this + 107) = 0LL;
    *((void *)this + 108) = 0LL;
    *((void *)this + 109) = 0LL;
    uint64_t v17 = __p[0];
  }

  *((void *)this + 107) = v32;
  *((_OWORD *)this + 54) = v33;
  __int128 v33 = 0uLL;
  uint64_t v32 = 0LL;
  if (v17)
  {
    __p[1] = v17;
    operator delete(v17);
  }

  MachProcess::PrivateResume(this);
  unsigned int v18 = 0;
  fd_set v19 = (pthread_mutex_t *)((char *)this + 1224);
  while (1)
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 1224));
    int v20 = *((_DWORD *)this + 304);
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 1224));
    if (v20 == 9) {
      break;
    }
    usleep(0x2710u);
    BOOL v21 = v18 >= 0xF1B30;
    v18 += 10000;
    if (v21)
    {
      unsigned int v18 = 1000000;
      break;
    }
  }

  if (DNBLogEnabled())
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 1224));
    unsigned int v22 = *((_DWORD *)this + 304);
    pthread_mutex_unlock(v19);
    DNBStateAsString(v22);
    _DNBLog( 0LL,  (uint64_t)"Waited %u ms for process to be reaped (state = %s)",  v23,  v24,  v25,  v26,  v27,  v28,  v18 / 0x3E8uLL);
  }

  if (SHIBYTE(v35) < 0) {
    operator delete(v34[1]);
  }
  return 1LL;
}

void sub_10003CB88( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p, uint64_t a21, int a22, __int16 a23, char a24, char a25)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MachProcess::DoSIGSTOP(MachProcess *this, int a2, int a3, unsigned int *a4)
{
  uint64_t v8 = (pthread_mutex_t *)((char *)this + 1224);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 1224));
  unsigned int v9 = *((_DWORD *)this + 304);
  pthread_mutex_unlock(v8);
  if (DNBLogEnabledForAny(2))
  {
    uint64_t v10 = DNBStateAsString(v9);
    _DNBLogThreaded("MachProcess::DoSIGSTOP() state = %s", v10);
  }

  if (v9 - 5 >= 2)
  {
    if (a2)
    {
      if (DNBLogEnabledForAny(512)) {
        _DNBLogThreaded("MachProcess::%s (remove = %d)", "DisableAllBreakpoints", 1);
      }
      DNBBreakpointList::DisableAllBreakpoints((uint64_t)this + 1640, this);
      DNBBreakpointList::RemoveDisabled((MachProcess *)((char *)this + 1640));
      if (DNBLogEnabledForAny(2048)) {
        _DNBLogThreaded("MachProcess::%s (remove = %d)", "DisableAllWatchpoints", 1);
      }
      DNBBreakpointList::DisableAllWatchpoints((uint64_t)this + 1664, this);
      DNBBreakpointList::RemoveDisabled((MachProcess *)((char *)this + 1664));
    }

    unsigned int ThreadIndexForThreadStoppedWithSignal = MachThreadList::GetThreadIndexForThreadStoppedWithSignal( (MachProcess *)((char *)this + 968),  17);
    if (a4) {
      *a4 = ThreadIndexForThreadStoppedWithSignal;
    }
    if (ThreadIndexForThreadStoppedWithSignal != -1)
    {
      pthread_mutex_lock(v8);
      uint64_t v12 = *((unsigned int *)this + 304);
      pthread_mutex_unlock(v8);
      return v12;
    }

    if (DNBLogEnabledForAny(2))
    {
      int v13 = DNBStateAsString(v9);
      _DNBLogThreaded("MachProcess::DoSIGSTOP() state = %s -- resuming process", v13);
    }

    if (a3) {
      int v14 = 5;
    }
    else {
      int v14 = 10;
    }
    DNBThreadResumeActions::DNBThreadResumeActions((uint64_t)__p, v14, 0);
    uint64_t v15 = (void *)*((void *)this + 104);
    if (v15)
    {
      *((void *)this + 105) = v15;
      operator delete(v15);
    }

    *((_OWORD *)this + 52) = *(_OWORD *)__p;
    *((void *)this + 106) = v22;
    __p[1] = 0LL;
    uint64_t v22 = 0LL;
    __p[0] = 0LL;
    uint64_t v16 = (void *)*((void *)this + 107);
    if (v16)
    {
      operator delete(v16);
      uint64_t v16 = __p[0];
    }

    *((void *)this + 107) = v23;
    *((_OWORD *)this + 54) = v24;
    __int128 v24 = 0uLL;
    uint64_t v23 = 0LL;
    if (v16)
    {
      __p[1] = v16;
      operator delete(v16);
    }

    MachProcess::PrivateResume(this);
    PThreadEvent::ResetEvents((pthread_mutex_t *)((char *)this + 1288), 1);
    pthread_mutex_lock(v8);
    unsigned int v9 = *((_DWORD *)this + 304);
    pthread_mutex_unlock(v8);
    a2 = 0;
  }

  if (DNBLogEnabledForAny(2))
  {
    uint64_t v17 = DNBStateAsString(v9);
    _DNBLogThreaded("MachProcess::DoSIGSTOP() state = %s -- sending SIGSTOP", v17);
  }

  gettimeofday((timeval *)__p, 0LL);
  v20.int tv_sec = (__darwin_time_t)__p[0] + SLODWORD(__p[1]) / 1000000 + 2;
  v20.tv_nsec = 1000 * LODWORD(__p[1]) % 1000000000;
  MachProcess::Signal(this, 17, &v20);
  if (a2)
  {
    if (DNBLogEnabledForAny(512)) {
      _DNBLogThreaded("MachProcess::%s (remove = %d)", "DisableAllBreakpoints", 1);
    }
    DNBBreakpointList::DisableAllBreakpoints((uint64_t)this + 1640, this);
    DNBBreakpointList::RemoveDisabled((MachProcess *)((char *)this + 1640));
    if (DNBLogEnabledForAny(2048)) {
      _DNBLogThreaded("MachProcess::%s (remove = %d)", "DisableAllWatchpoints", 1);
    }
    DNBBreakpointList::DisableAllWatchpoints((uint64_t)this + 1664, this);
    DNBBreakpointList::RemoveDisabled((MachProcess *)((char *)this + 1664));
  }

  unsigned int v18 = MachThreadList::GetThreadIndexForThreadStoppedWithSignal((MachProcess *)((char *)this + 968), 17);
  if (a4) {
    *a4 = v18;
  }
  pthread_mutex_lock(v8);
  uint64_t v12 = *((unsigned int *)this + 304);
  pthread_mutex_unlock(v8);
  return v12;
}

BOOL MachProcess::Interrupt(MachProcess *this)
{
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 1224);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 1224));
  int v3 = *((_DWORD *)this + 304);
  pthread_mutex_unlock(v2);
  if ((v3 - 5) > 1)
  {
    BOOL result = DNBLogEnabledForAny(2);
    if (!result) {
      return result;
    }
    _DNBLogThreaded("MachProcess::Interrupt() - process already stopped, no interrupt sent");
    return 0LL;
  }

  if (*((_DWORD *)this + 436))
  {
    BOOL result = DNBLogEnabledForAny(2);
    if (!result) {
      return result;
    }
    _DNBLogThreaded( "MachProcess::Interrupt() - previously sent an interrupt signal %i that hasn't been received yet, interrupt aborted");
    return 0LL;
  }

  *((_DWORD *)this + 436) = 17;
  if (MachProcess::Signal(this, 17, 0LL))
  {
    if (DNBLogEnabledForAny(2)) {
      _DNBLogThreaded("MachProcess::Interrupt() - sent %i signal to interrupt process", *((_DWORD *)this + 436));
    }
    return 1LL;
  }

  else
  {
    *((_DWORD *)this + 436) = 0;
    BOOL v5 = DNBLogEnabledForAny(2);
    BOOL result = 0LL;
    if (v5)
    {
      _DNBLogThreaded("MachProcess::Interrupt() - failed to send %i signal to interrupt process");
      return 0LL;
    }
  }

  return result;
}

BOOL MachProcess::Signal(MachProcess *this, int a2, const timespec *a3)
{
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("MachProcess::Signal (signal = %d, timeout = %p)", a2, a3);
  }
  uint64_t v6 = (pthread_mutex_t *)((char *)this + 1224);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 1224));
  int v7 = *((_DWORD *)this + 304);
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 1224));
  if (kill(*(_DWORD *)this, a2))
  {
    v12[0] = *__error();
    v12[1] = 2;
    uint64_t v14 = 0LL;
    uint64_t v15 = 0LL;
    timeval __p = 0LL;
    DNBError::LogThreadedIfError((DNBError *)v12, "kill (pid = %d, signo = %i)", *(_DWORD *)this, a2);
    if (SHIBYTE(v15) < 0) {
      operator delete(__p);
    }
    return 0LL;
  }

  else
  {
    BOOL v9 = DNBLogEnabledForAny(2);
    if (a3 && (v7 - 5) <= 1)
    {
      if (v9) {
        _DNBLogThreaded("MachProcess::Signal (signal = %d, timeout = %p) waiting for signal to stop process...", a2, a3);
      }
      PThreadEvent::WaitForSetEvents((pthread_mutex_t *)((char *)this + 1464), 2u, a3);
      pthread_mutex_lock((pthread_mutex_t *)((char *)this + 1224));
      unsigned int v10 = *((_DWORD *)this + 304);
      pthread_mutex_unlock(v6);
      if (DNBLogEnabledForAny(2))
      {
        BOOL v11 = DNBStateAsString(v10);
        _DNBLogThreaded("MachProcess::Signal (signal = %d, timeout = %p) state = %s", a2, a3, v11);
      }

      return v10 - 7 < 0xFFFFFFFE;
    }

    else
    {
      if (v9) {
        _DNBLogThreaded("MachProcess::Signal (signal = %d, timeout = %p) not waiting...", a2, a3);
      }
      return 1LL;
    }
  }

void sub_10003D19C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL MachProcess::SendEvent(MachProcess *this, char *a2, DNBError *a3)
{
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("MachProcess::SendEvent (event = %s) to pid: %d", a2, *(_DWORD *)this);
  }
  return *(_DWORD *)this && MachProcess::BoardServiceSendEvent(this, a2, a3);
}

BOOL MachProcess::BoardServiceSendEvent(MachProcess *this, char *a2, DNBError *a3)
{
  if (!a2 || !*a2)
  {
    if (DNBLogEnabled()) {
      _DNBLogError("SendEvent called with NULL event data.");
    }
    std::string::assign((std::string *)((char *)a3 + 8), "SendEvent called with empty event data");
    return 0LL;
  }

  uint64_t v6 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  if (!strcmp(a2, "BackgroundApplication"))
  {
    int v9 = *((_DWORD *)this + 110);
    if ((v9 & 0x10) == 0)
    {
      uint64_t v10 = *(unsigned int *)this;
      if ((_DWORD)v10)
      {
        if ([objc_alloc_init(BKSApplicationStateMonitor) mostElevatedApplicationStateForPID:v10])
        {
          int v11 = *((_DWORD *)this + 110) | 8;
        }

        else
        {
          unsigned int v17 = [objc_alloc_init(BKSApplicationStateMonitor) mostElevatedApplicationStateForPID:*(unsigned int *)this];
          int v11 = *((_DWORD *)this + 110);
          if (v17) {
            v11 |= 4u;
          }
        }

        int v9 = v11 | 0x10;
        *((_DWORD *)this + 110) = v9;
      }
    }

    if ((v9 & 4) != 0)
    {
      int v18 = CallBoardSystemServiceOpenApplication<BKSSystemService,BKSOpenApplicationErrorCode,(BKSOpenApplicationErrorCode)0,&(SetBKSError(long,std::string,DNBError &))>( 0LL,  0LL,  (uint64_t)a3,  0LL);
      int v9 = *((_DWORD *)this + 110);
      if ((v9 & 0x10) != 0)
      {
LABEL_48:
        if ((v9 & 8) != 0) {
          int v18 = CallBoardSystemServiceOpenApplication<FBSSystemService,FBSOpenApplicationErrorCode,(FBSOpenApplicationErrorCode)0,&(SetFBSError(long,std::string,DNBError &))>( 0LL,  0LL,  (uint64_t)a3,  0LL);
        }
        BOOL v8 = v18 != 0;
        if (v18) {
          goto LABEL_65;
        }
        if (DNBLogEnabled())
        {
          DNBError::AsString(a3);
          _DNBLogError("Failed to background application, error: %s.");
        }

        goto LABEL_64;
      }
    }

    else
    {
      int v18 = 1;
      if ((v9 & 0x10) != 0) {
        goto LABEL_48;
      }
    }

    uint64_t v19 = *(unsigned int *)this;
    if ((_DWORD)v19)
    {
      if ([objc_alloc_init(BKSApplicationStateMonitor) mostElevatedApplicationStateForPID:v19])
      {
        int v20 = *((_DWORD *)this + 110) | 8;
      }

      else
      {
        unsigned int v26 = [objc_alloc_init(BKSApplicationStateMonitor) mostElevatedApplicationStateForPID:*(unsigned int *)this];
        int v20 = *((_DWORD *)this + 110);
        if (v26) {
          v20 |= 4u;
        }
      }

      int v9 = v20 | 0x10;
      *((_DWORD *)this + 110) = v9;
    }

    goto LABEL_48;
  }

  int v7 = (void *)((char *)this + 1720);
  if (*((char *)this + 1743) < 0)
  {
    if (!*((void *)this + 216)) {
      goto LABEL_21;
    }
    int v7 = (void *)*v7;
  }

  else if (!*((_BYTE *)this + 1743))
  {
LABEL_21:
    if (DNBLogEnabled()) {
      _DNBLogError("Tried to send event %s to a process that has no bundle ID.", a2);
    }
    return 0LL;
  }

  uint64_t v12 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v7);
  int v13 = (NSMutableDictionary *)+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
  int v14 = *((_DWORD *)this + 110);
  if ((v14 & 0x10) == 0)
  {
    uint64_t v15 = *(unsigned int *)this;
    if ((_DWORD)v15)
    {
      if ([objc_alloc_init(BKSApplicationStateMonitor) mostElevatedApplicationStateForPID:v15])
      {
        int v16 = *((_DWORD *)this + 110) | 8;
      }

      else
      {
        unsigned int v21 = [objc_alloc_init(BKSApplicationStateMonitor) mostElevatedApplicationStateForPID:*(unsigned int *)this];
        int v16 = *((_DWORD *)this + 110);
        if (v21) {
          v16 |= 4u;
        }
      }

      int v14 = v16 | 0x10;
      *((_DWORD *)this + 110) = v14;
    }
  }

  if ((v14 & 4) != 0)
  {
    if ((BKSAddEventDataToOptions(v13, a2, a3) & 1) == 0) {
      goto LABEL_67;
    }
    char v22 = CallBoardSystemServiceOpenApplication<BKSSystemService,BKSOpenApplicationErrorCode,(BKSOpenApplicationErrorCode)0,&(SetBKSError(long,std::string,DNBError &))>( v12,  v13,  (uint64_t)a3,  0LL);
    if (DNBLogEnabledForAny(2)) {
      _DNBLogThreaded("Called BKSCallOpenApplicationFunction to send event.");
    }
  }

  else
  {
    char v22 = 1;
  }

  int v23 = *((_DWORD *)this + 110);
  if ((v23 & 0x10) == 0)
  {
    uint64_t v24 = *(unsigned int *)this;
    if ((_DWORD)v24)
    {
      if ([objc_alloc_init(BKSApplicationStateMonitor) mostElevatedApplicationStateForPID:v24])
      {
        int v25 = *((_DWORD *)this + 110) | 8;
      }

      else
      {
        unsigned int v27 = [objc_alloc_init(BKSApplicationStateMonitor) mostElevatedApplicationStateForPID:*(unsigned int *)this];
        int v25 = *((_DWORD *)this + 110);
        if (v27) {
          v25 |= 4u;
        }
      }

      int v23 = v25 | 0x10;
      *((_DWORD *)this + 110) = v23;
    }
  }

  if ((v23 & 8) == 0) {
    goto LABEL_57;
  }
  if ((FBSAddEventDataToOptions(v13, a2, a3) & 1) != 0)
  {
    char v22 = CallBoardSystemServiceOpenApplication<FBSSystemService,FBSOpenApplicationErrorCode,(FBSOpenApplicationErrorCode)0,&(SetFBSError(long,std::string,DNBError &))>( v12,  v13,  (uint64_t)a3,  0LL);
    if (DNBLogEnabledForAny(2))
    {
      _DNBLogThreaded("Called FBSCallOpenApplicationFunction to send event.");
      if ((v22 & 1) != 0) {
        goto LABEL_58;
      }
LABEL_62:
      if (DNBLogEnabled())
      {
        DNBError::AsString(a3);
        _DNBLogError("Failed to send event: %s, error: %s.");
      }

LABEL_64:
      BOOL v8 = 0LL;
      goto LABEL_65;
    }

void MachProcess::DisableAllBreakpoints(MachProcess *this, int a2)
{
  if (DNBLogEnabledForAny(512)) {
    _DNBLogThreaded("MachProcess::%s (remove = %d)", "DisableAllBreakpoints", a2);
  }
  DNBBreakpointList::DisableAllBreakpoints((uint64_t)this + 1640, this);
  if (a2) {
    DNBBreakpointList::RemoveDisabled((MachProcess *)((char *)this + 1640));
  }
}

void MachProcess::DisableAllWatchpoints(MachProcess *this, int a2)
{
  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded("MachProcess::%s (remove = %d)", "DisableAllWatchpoints", a2);
  }
  DNBBreakpointList::DisableAllWatchpoints((uint64_t)this + 1664, this);
  if (a2) {
    DNBBreakpointList::RemoveDisabled((MachProcess *)((char *)this + 1664));
  }
}

uint64_t MachProcess::Detach(MachProcess *this)
{
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("MachProcess::Detach()");
  }
  unsigned int v14 = -1;
  unsigned int v2 = MachProcess::DoSIGSTOP(this, 1, 1, &v14);
  if (DNBLogEnabledForAny(2))
  {
    int v3 = DNBStateAsString(v2);
    _DNBLogThreaded("MachProcess::Detach() DoSIGSTOP() returned %s", v3);
  }

  *((void *)this + 105) = *((void *)this + 104);
  *((void *)this + 108) = 0LL;
  Genealogy::Clear((MachProcess *)((char *)this + 1080));
  *(void *)&__int128 v10 = MachThreadList::ThreadIDAtIndex((MachProcess *)((char *)this + 968), v14);
  *((void *)&v10 + 1) = -4294967291LL;
  uint64_t v11 = -1LL;
  DNBThreadResumeActions::Append((char **)this + 104, &v10);
  DNBThreadResumeActions::SetDefaultThreadActionIfNeeded((char **)this + 104, 5, 0);
  int v13 = (char *)this + 904;
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 904));
  MachProcess::ReplyToAllExceptions(this);
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 904));
  MachTask::ShutDownExcecptionThread((MachProcess *)((char *)this + 104));
  *__error() = 0;
  int v4 = *(_DWORD *)this;
  int v5 = ptrace(11, *(_DWORD *)this, (caddr_t)1, 0);
  unsigned int v6 = *__error();
  __int128 v10 = v6 | 0x200000000uLL;
  uint64_t v11 = 0LL;
  uint64_t v12 = 0LL;
  if (DNBLogCheckLogBit(2) || v6 | v5) {
    DNBError::LogThreaded((DNBError *)&v10, "::ptrace (PT_DETACH, %u, (caddr_t)1, 0)", v4);
  }
  MachTask::Resume((MachProcess *)((char *)this + 104), v7, v8);
  MachTask::Clear((void *)this + 13);
  *((_DWORD *)this + 2) = 0;
  MachProcess::Clear(this, 1);
  MachProcess::SetState((uint64_t)this, 8u);
  if (SHIBYTE(v12) < 0) {
    operator delete(*((void **)&v10 + 1));
  }
  return 1LL;
}

void sub_10003D8D8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10003D8EC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MachProcess::ReplyToAllExceptions(MachProcess *this)
{
  unsigned int v2 = (pthread_mutex_t *)((char *)this + 904);
  int v18 = (char *)this + 904;
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 904));
  uint64_t v3 = *((void *)this + 110);
  uint64_t v4 = *((void *)this + 111);
  if (v3 != v4)
  {
    int v13 = v2;
    uint64_t v5 = 0LL;
    do
    {
      if (DNBLogEnabledForAny(8)) {
        _DNBLogThreaded("Replying to exception %u...", 625320909 * (v5 >> 3));
      }
      uint64_t ThreadIDByMachPortNumber = MachThreadList::GetThreadIDByMachPortNumber( (MachProcess *)((char *)this + 968),  *(_DWORD *)(v3 + v5 + 2052));
      if (ThreadIDByMachPortNumber
        && (ActionForThread = DNBThreadResumeActions::GetActionForThread( (MachProcess *)((char *)this + 832),  ThreadIDByMachPortNumber,  0)) != 0LL)
      {
        int v8 = *((_DWORD *)ActionForThread + 3);
        if (v8) {
          DNBThreadResumeActions::SetSignalHandledForThread((uint64_t)this + 832, ThreadIDByMachPortNumber);
        }
      }

      else
      {
        int v8 = 0;
      }

      int v14 = MachException::Message::Reply((MachException::Message *)(v3 + v5), this, v8);
      uint64_t v16 = 0LL;
      __int128 v15 = 0uLL;
      int v17 = 0;
      if (DNBLogCheckLogBit(8)) {
        DNBError::LogThreadedIfError((DNBError *)&v14, "Error replying to exception");
      }
      if (SHIBYTE(v17) < 0) {
        operator delete(*(void **)((char *)&v15 + 4));
      }
      v5 += 2088LL;
    }

    while (v3 + v5 != v4);
    uint64_t v9 = *((void *)this + 111);
    uint64_t v10 = *((void *)this + 110);
    while (v9 != v10)
    {
      uint64_t v11 = *(void **)(v9 - 24);
      if (v11)
      {
        *(void *)(v9 - 16) = v11;
        operator delete(v11);
      }

      v9 -= 2088LL;
    }

    *((void *)this + 111) = v10;
    unsigned int v2 = v13;
  }

  return pthread_mutex_unlock(v2);
}

void sub_10003DAB0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, pthread_mutex_t *a19)
{
}

unint64_t MachProcess::WriteMemory( MachProcess *this, unint64_t a2, unint64_t a3, char *a4)
{
  timeval __p = 0LL;
  uint64_t v32 = 0LL;
  uint64_t v33 = 0LL;
  uint64_t BreakpointsThatOverlapRange = DNBBreakpointList::FindBreakpointsThatOverlapRange( (void *)this + 205,  a2,  a3,  (uint64_t)&__p);
  if (!BreakpointsThatOverlapRange)
  {
    unint64_t v10 = MachTask::WriteMemory((MachProcess *)((char *)this + 104), a2, a3, a4);
    int v25 = __p;
    if (__p) {
      goto LABEL_29;
    }
    return v10;
  }

  uint64_t v9 = 0LL;
  unint64_t v10 = 0LL;
  unint64_t v29 = a3;
  unint64_t v11 = a3 + a2;
  uint64x2_t v30 = (MachProcess *)((char *)this + 104);
  do
  {
    uint64_t v12 = *((void *)__p + v9);
    if ((*(_BYTE *)(v12 + 24) & 5) != 1
      || *(_DWORD *)(v12 + 28) != -1
      || (unint64_t v13 = *(unsigned int *)(v12 + 4), !(_DWORD)v13)
      || ((unint64_t v14 = *(void *)(v12 + 16), v15 = v14 + v13, v11 > v14) ? (v16 = v15 > a2) : (v16 = 0), !v16))
    {
      int v27 = 1859;
      uint64_t v28 = "intersects";
      goto LABEL_34;
    }

    if (v11 >= v15) {
      unint64_t v17 = v14 + v13;
    }
    else {
      unint64_t v17 = v11;
    }
    if (v14 <= a2) {
      unint64_t v18 = a2;
    }
    else {
      unint64_t v18 = *(void *)(v12 + 16);
    }
    BOOL v19 = a2 >= v14;
    unint64_t v20 = a2 - v14;
    if (v19) {
      unint64_t v21 = v20;
    }
    else {
      unint64_t v21 = 0LL;
    }
    if (v18 >= v11)
    {
      int v27 = 1860;
      uint64_t v28 = "addr <= intersect_addr && intersect_addr < addr + size";
      goto LABEL_34;
    }

    if (v17 <= a2)
    {
      int v27 = 1862;
      uint64_t v28 = "addr < intersect_addr + intersect_size && intersect_addr + intersect_size <= addr + size";
      goto LABEL_34;
    }

    size_t v22 = v17 - v18;
    if (v21 + v17 - v18 > v13)
    {
      int v27 = 1863;
      uint64_t v28 = "opcode_offset + intersect_size <= bp->ByteSize()";
LABEL_34:
      __assert_rtn("WriteMemory", "MachProcess.mm", v27, v28);
    }

    unint64_t v23 = v18 - (v10 + a2);
    if (v18 > v10 + a2)
    {
      unint64_t v24 = MachTask::WriteMemory(v30, v10 + a2, v18 - (v10 + a2), &a4[v10]);
      v10 += v24;
      if (v24 != v23) {
        break;
      }
    }

    memcpy((void *)(v12 + v21 + 8), &a4[v10], v22);
    v10 += v22;
    ++v9;
  }

  while (BreakpointsThatOverlapRange != v9);
  if (v29 > v10) {
    v10 += MachTask::WriteMemory(v30, v10 + a2, v29 - v10, &a4[v10]);
  }
  int v25 = __p;
  if (__p)
  {
LABEL_29:
    uint64_t v32 = v25;
    operator delete(v25);
  }

  return v10;
}

void sub_10003DCE4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *MachProcess::CreateBreakpoint(uint64_t **this, unint64_t a2, uint64_t a3, int a4)
{
  if (DNBLogEnabledForAny(512)) {
    _DNBLogThreaded("MachProcess::CreateBreakpoint(addr = 0x%8.8llx, length = %llu, hardware = %i)", a2, a3, a4);
  }
  int v8 = DNBBreakpointList::FindByAddress((DNBBreakpointList *)(this + 205), a2);
  if (v8)
  {
    uint64_t v9 = v8;
    ++*(_DWORD *)v8;
  }

  else
  {
    uint64_t v9 = DNBBreakpointList::Add(this + 205, a2, a3, a4);
  }

  if (MachProcess::EnableBreakpoint((MachProcess *)this, a2))
  {
    if (DNBLogEnabledForAny(512)) {
      _DNBLogThreaded("MachProcess::CreateBreakpoint(addr = 0x%8.8llx, length = %llu) => %p", a2, a3, v9);
    }
  }

  else
  {
    if (!*(_DWORD *)v9 || (v10 = *(_DWORD *)v9 - 1, (*(_DWORD *)uint64_t v9 = v10) == 0)) {
      DNBBreakpointList::Remove((DNBBreakpointList *)(this + 205), a2);
    }
    return 0LL;
  }

  return v9;
}

uint64_t MachProcess::EnableBreakpoint(MachProcess *this, unint64_t a2)
{
  if (DNBLogEnabledForAny(512)) {
    _DNBLogThreaded("MachProcess::EnableBreakpoint(addr = 0x%8.8llx)", a2);
  }
  uint64_t result = (uint64_t)DNBBreakpointList::FindByAddress((MachProcess *)((char *)this + 1640), a2);
  if (result)
  {
    uint64_t v5 = result;
    if ((*(_BYTE *)(result + 24) & 1) != 0)
    {
      if (DNBLogEnabled()) {
        _DNBLogWarning("MachProcess::EnableBreakpoint(addr = 0x%8.8llx): breakpoint already enabled.", a2);
      }
      return 1LL;
    }

    if ((*(_BYTE *)(result + 24) & 2) != 0)
    {
      int v6 = MachThreadList::EnableHardwareBreakpoint((uint64_t)this + 968, result);
      *(_DWORD *)(v5 + 28) = v6;
      if (v6 != -1)
      {
        *(_BYTE *)(v5 + 24) |= 1u;
        return 1LL;
      }
    }

    unint64_t v7 = *(unsigned int *)(v5 + 4);
    if (!(_DWORD)v7) {
      MachProcess::EnableBreakpoint();
    }
    BreakpointOpcode = (char *)DNBArchProtocol::GetBreakpointOpcode((DNBArchProtocol *)*(unsigned int *)(v5 + 4));
    if (MachTask::ReadMemory((MachProcess *)((char *)this + 104), a2, v7, (char *)(v5 + 8)) != v7)
    {
      uint64_t result = DNBLogEnabled();
      if (!(_DWORD)result) {
        return result;
      }
      _DNBLogError("MachProcess::EnableBreakpoint(addr = 0x%8.8llx): unable to read memory at breakpoint address.");
      return 0LL;
    }

    if (MachTask::WriteMemory((MachProcess *)((char *)this + 104), a2, v7, BreakpointOpcode) != v7)
    {
      uint64_t result = DNBLogEnabled();
      if (!(_DWORD)result) {
        return result;
      }
      _DNBLogError("MachProcess::EnableBreakpoint(addr = 0x%8.8llx): unable to write breakpoint opcode to memory.");
      return 0LL;
    }

    if (MachTask::ReadMemory((MachProcess *)((char *)this + 104), a2, v7, __s2) == v7)
    {
      if (!memcmp(BreakpointOpcode, __s2, v7))
      {
        *(_BYTE *)(v5 + 24) |= 1u;
        MachThreadList::NotifyBreakpointChanged((uint64_t)this + 968);
        if (DNBLogEnabledForAny(512)) {
          _DNBLogThreaded("MachProcess::EnableBreakpoint(addr = 0x%8.8llx) : SUCCESS.", a2);
        }
        return 1LL;
      }

      if (!DNBLogEnabled()) {
        return 0LL;
      }
      uint64_t v9 = "MachProcess::EnableBreakpoint(addr = 0x%8.8llx): breakpoint opcode verification failed.";
    }

    else
    {
      if (!DNBLogEnabled()) {
        return 0LL;
      }
      uint64_t v9 = "MachProcess::EnableBreakpoint(addr = 0x%8.8llx): unable to read memory to verify breakpoint opcode.";
    }

    _DNBLogError(v9, a2);
    return 0LL;
  }

  return result;
}

char *MachProcess::CreateWatchpoint(uint64_t **this, unint64_t a2, uint64_t a3, int a4, int a5)
{
  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded( "MachProcess::CreateWatchpoint(addr = 0x%8.8llx, length = %llu, flags = 0x%8.8x, hardware = %i)",  a2,  a3,  a4,  a5);
  }
  int v10 = (DNBBreakpointList *)(this + 208);
  unint64_t v11 = DNBBreakpointList::Add(this + 208, a2, a3, a5);
  _BYTE v11[24] = (8 * (a4 & 3)) | v11[24] & 0xE7 | 4;
  int v12 = MachProcess::EnableWatchpoint((MachProcess *)this, a2);
  BOOL v13 = DNBLogEnabledForAny(2048);
  if (!v12)
  {
    if (v13) {
      _DNBLogThreaded("MachProcess::CreateWatchpoint(addr = 0x%8.8llx, length = %llu) => FAILED", a2, a3);
    }
    DNBBreakpointList::Remove(v10, a2);
    return 0LL;
  }

  if (v13) {
    _DNBLogThreaded("MachProcess::CreateWatchpoint(addr = 0x%8.8llx, length = %llu) => %p", a2, a3, v11);
  }
  return v11;
}

uint64_t MachProcess::EnableWatchpoint(MachProcess *this, unint64_t a2)
{
  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded("MachProcess::EnableWatchpoint(addr = 0x%8.8llx)", a2);
  }
  uint64_t result = (uint64_t)DNBBreakpointList::FindByAddress((MachProcess *)((char *)this + 1664), a2);
  if (result)
  {
    uint64_t v5 = result;
    if ((*(_BYTE *)(result + 24) & 1) != 0)
    {
      uint64_t v7 = *(void *)(result + 16);
      if (DNBLogEnabled()) {
        _DNBLogWarning("MachProcess::EnableWatchpoint(addr = 0x%8.8llx): watchpoint already enabled.", v7);
      }
      return 1LL;
    }

    int v6 = MachThreadList::EnableHardwareWatchpoint((uint64_t)this + 968, result);
    *(_DWORD *)(v5 + 28) = v6;
    if (v6 != -1)
    {
      *(_BYTE *)(v5 + 24) |= 1u;
      return 1LL;
    }

    return 0LL;
  }

  return result;
}

BOOL MachProcess::DisableBreakpoint(MachProcess *this, unint64_t a2, int a3)
{
  int v6 = (MachProcess *)((char *)this + 1640);
  uint64_t v7 = DNBBreakpointList::FindByAddress((MachProcess *)((char *)this + 1640), a2);
  if (!v7)
  {
    BOOL result = DNBLogEnabled();
    if (!result) {
      return result;
    }
    _DNBLogError("MachProcess::DisableBreakpoint(addr = 0x%8.8llx, remove = %d) invalid breakpoint address", a2, a3);
    return 0LL;
  }

  uint64_t v8 = (uint64_t)v7;
  if ((v7[24] & 1) == 0)
  {
    if (a3)
    {
      if (!*(_DWORD *)v7 || (v9 = *(_DWORD *)v7 - 1, (*(_DWORD *)uint64_t v7 = v9) == 0))
      {
        MachThreadList::NotifyBreakpointChanged((uint64_t)this + 968);
        DNBBreakpointList::Remove(v6, a2);
        return 1LL;
      }
    }

    return 1LL;
  }

  if (a3)
  {
    if (*(_DWORD *)v7)
    {
      int v11 = *(_DWORD *)v7 - 1;
      *(_DWORD *)uint64_t v7 = v11;
      if (v11) {
        return 1LL;
      }
    }
  }

  if (DNBLogEnabledForAny(513)) {
    _DNBLogThreaded("MachProcess::DisableBreakpoint(addr = 0x%8.8llx, remove = %d)", a2, a3);
  }
  if (*(_DWORD *)(v8 + 28) == -1)
  {
    unint64_t v13 = *(unsigned int *)(v8 + 4);
    if (!(_DWORD)v13) {
      MachProcess::DisableBreakpoint();
    }
    BreakpointOpcode = (const void *)DNBArchProtocol::GetBreakpointOpcode((DNBArchProtocol *)*(unsigned int *)(v8 + 4));
    ((void (*)(void))__chkstk_darwin)();
    if (MachTask::ReadMemory((MachProcess *)((char *)this + 104), a2, v13, (char *)&v20 - ((v13 + 15) & 0x1FFFFFFF0LL)) != v13)
    {
      if (DNBLogEnabled()) {
        _DNBLogWarning("MachProcess::DisableBreakpoint: unable to read memory at 0x%8.8llx", a2);
      }
      return 0LL;
    }

    char v15 = *(_BYTE *)(v8 + 24);
    uint64_t v20 = (uint64_t)&v20;
    if ((v15 & 1) != 0)
    {
      if (!memcmp((char *)&v20 - ((v13 + 15) & 0x1FFFFFFF0LL), BreakpointOpcode, v13))
      {
        unint64_t v16 = MachTask::WriteMemory((MachProcess *)((char *)this + 104), a2, v13, (char *)(v8 + 8));
        if (v16 != v13)
        {
          if (DNBLogEnabled()) {
            _DNBLogError( "MachProcess::DisableBreakpoint(addr = 0x%8.8llx, remove = %d) memory write failed when restoring original opcode",  a2,  a3);
          }
          return 0LL;
        }

        int v17 = 1;
LABEL_32:
        __chkstk_darwin(v16);
        if (MachTask::ReadMemory( (MachProcess *)((char *)this + 104),  a2,  v13,  (char *)&v20 - ((v13 + 15) & 0x1FFFFFFF0LL)) == v13)
        {
          if (!memcmp((const void *)(v8 + 8), (char *)&v20 - ((v13 + 15) & 0x1FFFFFFF0LL), v13))
          {
            *(_DWORD *)(v8 + 28) = -1;
            *(_BYTE *)(v8 + 24) &= ~1u;
            if (a3)
            {
              if (!*(_DWORD *)v8 || (v19 = *(_DWORD *)v8 - 1, (*(_DWORD *)uint64_t v8 = v19) == 0))
              {
                MachThreadList::NotifyBreakpointChanged((uint64_t)this + 968);
                DNBBreakpointList::Remove(v6, a2);
              }
            }

            if (DNBLogEnabledForAny(512)) {
              _DNBLogThreaded("MachProcess::DisableBreakpoint(addr = 0x%8.8llx, remove = %d) => success", a2, a3);
            }
            return 1LL;
          }

          BOOL v18 = DNBLogEnabled();
          if (v17)
          {
            if (v18) {
              _DNBLogError("MachProcess::DisableBreakpoint(addr = 0x%8.8llx, remove = %d) : failed to restore original opcode");
            }
          }

          else if (v18)
          {
            _DNBLogError("MachProcess::DisableBreakpoint(addr = 0x%8.8llx, remove = %d) : opcode changed");
          }
        }

        else if (DNBLogEnabled())
        {
          _DNBLogWarning("MachProcess::DisableBreakpoint: unable to disable breakpoint 0x%8.8llx", a2);
        }

        return 0LL;
      }

      unint64_t v16 = DNBLogEnabled();
      if ((_DWORD)v16) {
        _DNBLogWarning( "MachProcess::DisableBreakpoint(addr = 0x%8.8llx, remove = %d) expected a breakpoint opcode but didn't find one.",  a2,  a3);
      }
    }

    else
    {
      unint64_t v16 = DNBLogEnabledForAny(513);
      if ((_DWORD)v16) {
        _DNBLogThreaded("MachProcess::DisableBreakpoint(addr = 0x%8.8llx, remove = %d) is not enabled", a2, a3);
      }
    }

    int v17 = 0;
    goto LABEL_32;
  }

  int v12 = (char *)this + 968;
  BOOL result = MachThreadList::DisableHardwareBreakpoint((uint64_t)v12, v8);
  if (result)
  {
    *(_DWORD *)(v8 + 28) = -1;
    *(_BYTE *)(v8 + 24) &= ~1u;
    if (a3)
    {
      MachThreadList::NotifyBreakpointChanged((uint64_t)v12);
      DNBBreakpointList::Remove(v6, a2);
    }

    if (DNBLogEnabledForAny(512)) {
      _DNBLogThreaded("MachProcess::DisableBreakpoint(addr = 0x%8.8llx, remove = %d) (hardware) => success", a2, a3);
    }
    return 1LL;
  }

  return result;
}

BOOL MachProcess::DisableWatchpoint(MachProcess *this, unint64_t a2, int a3)
{
  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded("MachProcess::%s(addr = 0x%8.8llx, remove = %d)", "DisableWatchpoint", a2, a3);
  }
  int v6 = DNBBreakpointList::FindByAddress((MachProcess *)((char *)this + 1664), a2);
  if (!v6)
  {
    BOOL result = DNBLogEnabled();
    if (!result) {
      return result;
    }
    _DNBLogError("MachProcess::DisableWatchpoint(addr = 0x%8.8llx, remove = %d) invalid watchpoint ID", a2, a3);
    return 0LL;
  }

  uint64_t v7 = (uint64_t)v6;
  if (!a3 || !*(_DWORD *)v6 || (v8 = *(_DWORD *)v6 - 1, (*(_DWORD *)int v6 = v8) == 0))
  {
    unint64_t v9 = *((void *)v6 + 2);
    if (DNBLogEnabledForAny(2048)) {
      _DNBLogThreaded("MachProcess::DisableWatchpoint(addr = 0x%8.8llx, remove = %d)", v9, a3);
    }
    if (*(_DWORD *)(v7 + 28) != -1)
    {
      BOOL result = MachThreadList::DisableHardwareWatchpoint((uint64_t)this + 968, v7);
      if (!result) {
        return result;
      }
      *(_DWORD *)(v7 + 28) = -1;
      *(_BYTE *)(v7 + 24) &= ~1u;
      if (a3) {
        DNBBreakpointList::Remove((MachProcess *)((char *)this + 1664), v9);
      }
      if (DNBLogEnabledForAny(2048))
      {
        _DNBLogThreaded( "MachProcess::Disablewatchpoint(addr = 0x%8.8llx, remove = %d) (hardware) => success",  v9,  a3);
        return 1LL;
      }

      return 1LL;
    }

    return 0LL;
  }

  return 1LL;
}

uint64_t MachProcess::GetNumSupportedHardwareWatchpoints(MachThread ***this)
{
  return MachThreadList::NumSupportedHardwareWatchpoints(this + 121);
}

uint64_t MachProcess::ExceptionMessageReceived(MachProcess *this, const MachException::Message *a2)
{
  uint64_t v4 = (pthread_mutex_t *)((char *)this + 904);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 904));
  if (*((void *)this + 110) == *((void *)this + 111)) {
    MachTask::Suspend((MachProcess *)((char *)this + 104));
  }
  if (DNBLogEnabledForAny(8)) {
    _DNBLogThreaded("MachProcess::ExceptionMessageReceived()");
  }
  unint64_t v5 = *((void *)this + 111);
  if (v5 >= *((void *)this + 112))
  {
    int v12 = std::vector<MachException::Message>::__push_back_slow_path<MachException::Message const&>( (void **)this + 110,  a2);
  }

  else
  {
    memcpy(*((void **)this + 111), a2, 0x800uLL);
    int v6 = *((_DWORD *)a2 + 514);
    *(void *)(v5 + 2048) = *((void *)a2 + 256);
    *(_DWORD *)(v5 + 2056) = v6;
    *(void *)(v5 + 2064) = 0LL;
    *(void *)(v5 + 2080) = 0LL;
    *(void *)(v5 + 2072) = 0LL;
    uint64_t v7 = (_BYTE *)*((void *)a2 + 258);
    int v8 = (_BYTE *)*((void *)a2 + 259);
    int64_t v9 = v8 - v7;
    if (v8 != v7)
    {
      if (v9 < 0) {
        std::vector<kevent>::__throw_length_error[abi:ne180100]();
      }
      int v10 = (char *)operator new(v8 - v7);
      *(void *)(v5 + 2064) = v10;
      *(void *)(v5 + 2072) = v10;
      int v11 = &v10[8 * (v9 >> 3)];
      *(void *)(v5 + 2080) = v11;
      memcpy(v10, v7, v9);
      *(void *)(v5 + 2072) = v11;
    }

    int v12 = (void *)(v5 + 2088);
    *((void *)this + 111) = v5 + 2088;
  }

  *((void *)this + 111) = v12;
  return pthread_mutex_unlock(v4);
}

void sub_10003E828(_Unwind_Exception *a1, uint64_t a2, ...)
{
  int v6 = *v4;
  if (*v4)
  {
    *(void *)(v3 + 2072) = v6;
    operator delete(v6);
  }

  *(void *)(v2 + 888) = v3;
  PThreadMutex::Locker::~Locker((pthread_mutex_t **)va);
  _Unwind_Resume(a1);
}

uint64_t MachProcess::ExceptionMessageBundleComplete(MachProcess *this)
{
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 904);
  uint64_t v42 = (pthread_mutex_t *)((char *)this + 904);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 904));
  if (DNBLogEnabledForAny(8)) {
    _DNBLogThreaded( "%s: %llu exception messages.",  "task_t MachProcess::ExceptionMessageBundleComplete()",  0x77A9AF922545A3CDLL * ((uint64_t)(*((void *)this + 111) - *((void *)this + 110)) >> 3));
  }
  uint64_t v3 = *((void *)this + 110);
  uint64_t v4 = *((void *)this + 111);
  if (v3 == v4)
  {
    if (DNBLogEnabledForAny(8)) {
      _DNBLogThreaded( "%s empty exception messages bundle (%llu exceptions).",  "task_t MachProcess::ExceptionMessageBundleComplete()",  0x77A9AF922545A3CDLL * ((uint64_t)(*((void *)this + 111) - *((void *)this + 110)) >> 3));
    }
    uint64_t v20 = *((unsigned int *)this + 30);
    goto LABEL_73;
  }

  *((_BYTE *)this + 1752) = 0;
  int v5 = *((_DWORD *)this + 30);
  if (!*(_DWORD *)this) {
    goto LABEL_59;
  }
  int v6 = 0;
  char v7 = 0;
  uint64_t v8 = (unsigned __int128)((v4 - v3) * (__int128)0x7D8C42B2836ED5D3LL) >> 64;
  unint64_t v9 = (v8 >> 10) + ((unint64_t)v8 >> 63);
  if (v9 <= 1) {
    unint64_t v9 = 1LL;
  }
  int v10 = (void *)(v3 + 2072);
  while (*((_DWORD *)v10 - 6) != v5)
  {
LABEL_16:
    v10 += 261;
    if (!--v9) {
      goto LABEL_37;
    }
  }

  ++v6;
  if (*((_DWORD *)v10 - 4) != 5 || (uint64_t v15 = *(v10 - 1), *v10 - v15 != 16) || *(void *)v15 != 65539LL)
  {
    int v11 = 0;
LABEL_9:
    int v12 = *((_DWORD *)this + 436);
    if (v12) {
      BOOL v13 = v11 == v12;
    }
    else {
      BOOL v13 = 0;
    }
    char v14 = v13;
    v7 |= v14;
    goto LABEL_16;
  }

  int v11 = *(_DWORD *)(v15 + 8);
  if (v11 != 5) {
    goto LABEL_9;
  }
  *(_OWORD *)timeval __p = 0u;
  __int128 v46 = 0u;
  uint64_t DYLDAllImageInfosAddress = MachTask::GetDYLDAllImageInfosAddress((MachProcess *)((char *)this + 104), (DNBError *)__p);
  if (SHIBYTE(v46) < 0) {
    operator delete(__p[1]);
  }
  if (DYLDAllImageInfosAddress != -1)
  {
    mach_vm_address_t v17 = DYLDAllImageInfosAddress + 4;
    LODWORD(v41.tv_sec) = 0;
    if (MachTask::ReadMemory((MachProcess *)((char *)this + 104), v17, 4uLL, (char *)&v41) == 4)
    {
      if (!LODWORD(v41.tv_sec))
      {
        *((_BYTE *)this + 1752) = 1;
        *(_OWORD *)timeval __p = 0u;
        __int128 v46 = 0u;
        int v18 = *((_DWORD *)this + 30);
        unsigned int v19 = MachTask::TaskPortForProcessID((MachProcess *)((char *)this + 104), (DNBError *)__p, 1);
        if (v18 != v19 && DNBLogEnabledForAny(2)) {
          _DNBLogThreaded("exec: task changed from 0x%4.4x to 0x%4.4x", v18, v19);
        }
        if (SHIBYTE(v46) < 0) {
          operator delete(__p[1]);
        }
      }
    }

    else if (DNBLogEnabled())
    {
      _DNBLog( 0LL,  (uint64_t)"error: failed to read all_image_infos.infoArrayCount from 0x%8.8llx",  v21,  v22,  v23,  v24,  v25,  v26,  v17);
    }
  }

void sub_10003EDF8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, pthread_mutex_t *a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  PThreadMutex::Locker::~Locker(&a14);
  _Unwind_Resume(a1);
}

void MachProcess::SetExitInfo(MachProcess *this, const char *a2)
{
  if (a2 && *a2)
  {
    if (DNBLogEnabledForAny(2)) {
      _DNBLogThreaded("MachProcess::%s(%s)", "SetExitInfo", a2);
    }
    std::string::assign((std::string *)((char *)this + 80), a2);
  }

  else
  {
    if (DNBLogEnabledForAny(2)) {
      _DNBLogThreaded("MachProcess::%s(NULL)", "SetExitInfo");
    }
    if (*((char *)this + 103) < 0)
    {
      **((_BYTE **)this + 10) = 0;
      *((void *)this + 11) = 0LL;
    }

    else
    {
      *((_BYTE *)this + 80) = 0;
      *((_BYTE *)this + 103) = 0;
    }
  }

uint64_t MachProcess::AppendSTDOUT(MachProcess *this, char *a2, std::string::size_type a3)
{
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("MachProcess::%s (<%llu> %s) ...", "AppendSTDOUT", a3, a2);
  }
  int v6 = (pthread_mutex_t *)((char *)this + 456);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 456));
  std::string::append((std::string *)((char *)this + 520), a2, a3);
  char v7 = (pthread_mutex_t *)((char *)this + 1288);
  PThreadEvent::SetEvents(v7, 8);
  PThreadEvent::WaitForResetAck((PThreadEvent *)v7, 8, 0LL);
  return pthread_mutex_unlock(v6);
}

void sub_10003EFB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

size_t MachProcess::GetAvailableSTDOUT(MachProcess *this, char *a2, size_t a3)
{
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("MachProcess::%s (&%p[%llu]) ...", "GetAvailableSTDOUT", a2, a3);
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 456));
  if ((*((char *)this + 543) & 0x80000000) == 0)
  {
    size_t v6 = *((unsigned __int8 *)this + 543);
    if (*((_BYTE *)this + 543)) {
      goto LABEL_5;
    }
LABEL_10:
    a3 = 0LL;
    goto LABEL_17;
  }

  size_t v6 = *((void *)this + 66);
  if (!v6) {
    goto LABEL_10;
  }
LABEL_5:
  char v7 = (char *)this + 520;
  if (v6 <= a3)
  {
    if ((*((_BYTE *)this + 543) & 0x80) != 0) {
      char v7 = *(char **)v7;
    }
    memcpy(a2, v7, v6);
    if (*((char *)this + 543) < 0)
    {
      **((_BYTE **)this + 65) = 0;
      *((void *)this + 66) = 0LL;
    }

    else
    {
      *((_BYTE *)this + 520) = 0;
      *((_BYTE *)this + 543) = 0;
    }

    a3 = v6;
  }

  else
  {
    uint64_t v8 = (char *)this + 520;
    if ((*((_BYTE *)this + 543) & 0x80) != 0) {
      uint64_t v8 = *(char **)v7;
    }
    memcpy(a2, v8, a3);
    std::string::erase((std::string *)((char *)this + 520), 0LL, a3);
  }

void sub_10003F0E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

double MachProcess::GetDyldProcessState@<D0>(MachProcess *this@<X0>, _OWORD *a2@<X8>)
{
  uint64_t v4 = operator new(0x38uLL);
  v4[2] = 0LL;
  *((_DWORD *)v4 + 6) = 7;
  *uint64_t v4 = off_100060D18;
  v4[1] = 0LL;
  v4[5] = 0LL;
  v4[6] = 0LL;
  v4[4] = 0LL;
  std::shared_ptr<JSONGenerator::Dictionary>::shared_ptr[abi:ne180100]<JSONGenerator::Dictionary,void>( &v56,  (uint64_t)v4);
  if (!*((void *)this + 225))
  {
    uint64_t v11 = v56;
    v55.__r_.__value_.__s.__size_ = 5;
    strcpy((char *)&v55, "error");
    uint64_t v53 = (char *)operator new(0x30uLL);
    __int128 v54 = xmmword_100051FF0;
    strcpy(v53, "_dyld_process_info_get_state unavailable");
    JSONGenerator::Dictionary::AddStringItem(v11, &v55, (uint64_t)&v53);
    if (SHIBYTE(v54) < 0)
    {
      operator delete(v53);
    }

    else if (((char)v55.__r_.__value_.__s.__size_ & 0x80000000) == 0)
    {
      goto LABEL_54;
    }

    char v14 = (void *)v55.__r_.__value_.__r.__words[0];
LABEL_27:
    operator delete(v14);
    goto LABEL_54;
  }

  int v5 = (uint64_t (*)(void, void, int *))*((void *)this + 220);
  if (!v5)
  {
    uint64_t v12 = v56;
    v52.__r_.__value_.__s.__size_ = 5;
    strcpy((char *)&v52, "error");
    size_t v50 = (char *)operator new(0x28uLL);
    __int128 v51 = xmmword_100052030;
    strcpy(v50, "_dyld_process_info_create unavailable");
    JSONGenerator::Dictionary::AddStringItem(v12, &v52, (uint64_t)&v50);
    if (SHIBYTE(v51) < 0)
    {
      operator delete(v50);
    }

    else if (((char)v52.__r_.__value_.__s.__size_ & 0x80000000) == 0)
    {
      goto LABEL_54;
    }

    char v14 = (void *)v52.__r_.__value_.__r.__words[0];
    goto LABEL_27;
  }

  int v49 = 0;
  uint64_t v6 = v5(*((unsigned int *)this + 30), 0LL, &v49);
  uint64_t v7 = v6;
  if (!v6 || v49)
  {
    uint64_t v13 = v56;
    v48.__r_.__value_.__s.__size_ = 5;
    strcpy((char *)&v48, "error");
    __int128 v46 = (char *)operator new(0x38uLL);
    __int128 v47 = xmmword_100052020;
    strcpy(v46, "Unable to create dyld_process_info for inferior task");
    JSONGenerator::Dictionary::AddStringItem(v13, &v48, (uint64_t)&v46);
    if (SHIBYTE(v47) < 0)
    {
      operator delete(v46);
    }

    else if (((char)v48.__r_.__value_.__s.__size_ & 0x80000000) == 0)
    {
      goto LABEL_54;
    }

    char v14 = (void *)v48.__r_.__value_.__r.__words[0];
    goto LABEL_27;
  }

  (*((void (**)(uint64_t, _BYTE *))this + 225))(v6, v44);
  __p.__r_.__value_.__s.__size_ = 19;
  strcpy((char *)&__p, "process_state_value");
  JSONGenerator::Dictionary::AddIntegerItem(v56, &__p, (void (__cdecl *)(std::__shared_weak_count *__hidden))v45);
  HIDWORD(v8) = v45;
  LODWORD(v8) = v45;
  switch((v8 >> 4))
  {
    case 0u:
      uint64_t v9 = v56;
      v42.__r_.__value_.__s.__size_ = 20;
      strcpy((char *)&v42, "process_state string");
      unint64_t v40 = operator new(0x20uLL);
      __int128 v41 = xmmword_100051EC0;
      strcpy((char *)v40, "dyld_process_state_not_started");
      JSONGenerator::Dictionary::AddStringItem(v9, &v42, (uint64_t)&v40);
      if (SHIBYTE(v41) < 0) {
        operator delete(v40);
      }
      if ((char)v42.__r_.__value_.__s.__size_ < 0)
      {
        int v10 = &v42;
        goto LABEL_52;
      }

      break;
    case 1u:
      uint64_t v15 = v56;
      v39.__r_.__value_.__s.__size_ = 20;
      strcpy((char *)&v39, "process_state string");
      uint64_t v37 = operator new(0x28uLL);
      __int128 v38 = xmmword_100052010;
      strcpy((char *)v37, "dyld_process_state_dyld_initialized");
      JSONGenerator::Dictionary::AddStringItem(v15, &v39, (uint64_t)&v37);
      if (SHIBYTE(v38) < 0) {
        operator delete(v37);
      }
      if ((char)v39.__r_.__value_.__s.__size_ < 0)
      {
        int v10 = &v39;
        goto LABEL_52;
      }

      break;
    case 2u:
      uint64_t v16 = v56;
      v36.__r_.__value_.__s.__size_ = 20;
      strcpy((char *)&v36, "process_state string");
      uint64_t v34 = operator new(0x30uLL);
      __int128 v35 = xmmword_100052000;
      strcpy((char *)v34, "dyld_process_state_terminated_before_inits");
      JSONGenerator::Dictionary::AddStringItem(v16, &v36, (uint64_t)&v34);
      if (SHIBYTE(v35) < 0) {
        operator delete(v34);
      }
      if ((char)v36.__r_.__value_.__s.__size_ < 0)
      {
        int v10 = &v36;
        goto LABEL_52;
      }

      break;
    case 3u:
      uint64_t v17 = v56;
      v33.__r_.__value_.__s.__size_ = 20;
      strcpy((char *)&v33, "process_state string");
      uint64_t v31 = operator new(0x30uLL);
      __int128 v32 = xmmword_100051FF0;
      strcpy((char *)v31, "dyld_process_state_libSystem_initialized");
      JSONGenerator::Dictionary::AddStringItem(v17, &v33, (uint64_t)&v31);
      if (SHIBYTE(v32) < 0) {
        operator delete(v31);
      }
      if ((char)v33.__r_.__value_.__s.__size_ < 0)
      {
        int v10 = &v33;
        goto LABEL_52;
      }

      break;
    case 4u:
      uint64_t v18 = v56;
      v30.__r_.__value_.__s.__size_ = 20;
      strcpy((char *)&v30, "process_state string");
      uint64_t v28 = operator new(0x28uLL);
      __int128 v29 = xmmword_100051FE0;
      strcpy((char *)v28, "dyld_process_state_running_initializers");
      JSONGenerator::Dictionary::AddStringItem(v18, &v30, (uint64_t)&v28);
      if (SHIBYTE(v29) < 0) {
        operator delete(v28);
      }
      if ((char)v30.__r_.__value_.__s.__size_ < 0)
      {
        int v10 = &v30;
        goto LABEL_52;
      }

      break;
    case 5u:
      uint64_t v19 = v56;
      v27.__r_.__value_.__s.__size_ = 20;
      strcpy((char *)&v27, "process_state string");
      uint64_t v25 = operator new(0x28uLL);
      __int128 v26 = xmmword_100051FD0;
      strcpy((char *)v25, "dyld_process_state_program_running");
      JSONGenerator::Dictionary::AddStringItem(v19, &v27, (uint64_t)&v25);
      if (SHIBYTE(v26) < 0) {
        operator delete(v25);
      }
      if ((char)v27.__r_.__value_.__s.__size_ < 0)
      {
        int v10 = &v27;
        goto LABEL_52;
      }

      break;
    case 6u:
      uint64_t v20 = v56;
      v24.__r_.__value_.__s.__size_ = 20;
      strcpy((char *)&v24, "process_state string");
      uint64_t v22 = operator new(0x28uLL);
      __int128 v23 = xmmword_100051FD0;
      strcpy((char *)v22, "dyld_process_state_dyld_terminated");
      JSONGenerator::Dictionary::AddStringItem(v20, &v24, (uint64_t)&v22);
      if (SHIBYTE(v23) < 0) {
        operator delete(v22);
      }
      if ((char)v24.__r_.__value_.__s.__size_ < 0)
      {
        int v10 = &v24;
LABEL_52:
        operator delete(v10->__r_.__value_.__l.__data_);
      }

      break;
    default:
      break;
  }

  (*((void (**)(uint64_t))this + 222))(v7);
LABEL_54:
  double result = *(double *)&v56;
  *a2 = v56;
  return result;
}

void sub_10003F7F8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  std::shared_ptr<MachThread>::~shared_ptr[abi:ne180100](v21 - 80);
  _Unwind_Resume(a1);
}

uint64_t MachProcess::GetAvailableSTDERR(MachProcess *this, char *a2)
{
  return 0LL;
}

pthread_mutex_t *MachProcess::SignalAsyncProfileData(MachProcess *this, const char *a2)
{
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("MachProcess::%s (%s) ...", "SignalAsyncProfileData", a2);
  }
  uint64_t v17 = (pthread_mutex_t *)((char *)this + 568);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 568));
  size_t v4 = strlen(a2);
  if (v4 >= 0x7FFFFFFFFFFFFFF8LL) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    p_dst = (__int128 *)operator new(v7 + 1);
    *((void *)&__dst + 1) = v5;
    unint64_t v16 = v8 | 0x8000000000000000LL;
    *(void *)&__int128 __dst = p_dst;
    goto LABEL_10;
  }

  HIBYTE(v16) = v4;
  p_dst = &__dst;
  if (v4) {
LABEL_10:
  }
    memcpy(p_dst, a2, v5);
  *((_BYTE *)p_dst + v5) = 0;
  unint64_t v9 = *((void *)this + 80);
  if (v9 >= *((void *)this + 81))
  {
    uint64_t v11 = std::vector<std::string>::__push_back_slow_path<std::string>((void **)this + 79, (uint64_t)&__dst);
    int v12 = SHIBYTE(v16);
    *((void *)this + 80) = v11;
    if (v12 < 0) {
      operator delete((void *)__dst);
    }
  }

  else
  {
    __int128 v10 = __dst;
    *(void *)(v9 + 16) = v16;
    *(_OWORD *)unint64_t v9 = v10;
    *((void *)this + 80) = v9 + 24;
  }

  uint64_t v13 = (pthread_mutex_t *)((char *)this + 1288);
  PThreadEvent::SetEvents(v13, 16);
  PThreadEvent::WaitForResetAck((PThreadEvent *)v13, 16, 0LL);
  double result = v17;
  if (v17) {
    return (pthread_mutex_t *)pthread_mutex_unlock(v17);
  }
  return result;
}

void sub_10003FB6C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, pthread_mutex_t *a17)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  PThreadMutex::Locker::~Locker(&a17);
  _Unwind_Resume(a1);
}

size_t MachProcess::GetAsyncProfileData(MachProcess *this, char *a2, size_t a3)
{
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("MachProcess::%s (&%p[%llu]) ...", "GetAsyncProfileData", a2, a3);
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 568));
  uint64_t v6 = (_BYTE *)*((void *)this + 79);
  if (v6 == *((_BYTE **)this + 80)) {
    goto LABEL_11;
  }
  if (((char)v6[23] & 0x80000000) == 0)
  {
    size_t v7 = v6[23];
    if (v6[23]) {
      goto LABEL_6;
    }
LABEL_11:
    a3 = 0LL;
    goto LABEL_25;
  }

  size_t v7 = *((void *)v6 + 1);
  if (!v7) {
    goto LABEL_11;
  }
LABEL_6:
  if (v7 <= a3)
  {
    if ((v6[23] & 0x80) != 0) {
      uint64_t v6 = *(_BYTE **)v6;
    }
    memcpy(a2, v6, v7);
    uint64_t v8 = *((void *)this + 79);
    uint64_t v9 = v8 + 24;
    __int128 v10 = (char *)*((void *)this + 80);
    if ((char *)(v8 + 24) != v10)
    {
      uint64_t v11 = (char *)(v8 + 23);
      do
      {
        int v12 = (void **)(v11 - 23);
        if (*v11 < 0) {
          operator delete(*v12);
        }
        *(_OWORD *)int v12 = *(_OWORD *)(v11 + 1);
        *(void *)(v11 - 7) = *(void *)(v11 + 17);
        _BYTE v11[24] = 0;
        v11 += 24;
        *(v11 - 23) = 0;
        v8 += 24LL;
      }

      while (v11 + 1 != v10);
      uint64_t v9 = *((void *)this + 80);
    }

    while (v9 != v8)
    {
      v9 -= 24LL;
    }

    *((void *)this + 80) = v8;
    a3 = v7;
  }

  else
  {
    if ((v6[23] & 0x80) != 0) {
      uint64_t v6 = *(_BYTE **)v6;
    }
    memcpy(a2, v6, a3);
    std::string::erase(*((std::string **)this + 79), 0LL, a3);
  }

void sub_10003FD30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t MachProcess::AttachForDebug(MachProcess *a1, uint64_t a2, int8x16_t **a3, char *a4, size_t a5)
{
  if (!(_DWORD)a2) {
    return 0LL;
  }
  *(_OWORD *)std::string __p = 0u;
  __int128 v48 = 0u;
  if (getpgid(a2) < 0)
  {
    LODWORD(__p[0]) = *__error();
    HIDWORD(__p[0]) = 2;
    if (SHIBYTE(v48) < 0)
    {
      *(_BYTE *)__p[1] = 0;
      *(void *)&__int128 v48 = 0LL;
    }

    else
    {
      LOBYTE(__p[1]) = 0;
      HIBYTE(v48) = 0;
    }

    uint64_t v30 = DNBError::AsString((DNBError *)__p);
    uint64_t v31 = "No such process";
    if (v30) {
      uint64_t v31 = (const char *)v30;
    }
    snprintf(a4, a5, "%s", v31);
    if (DNBLogEnabled()) {
      _DNBLogError("MachProcess::AttachForDebug pid %d does not exist", a2);
    }
    a2 = 0LL;
    char v29 = 0;
    if (SHIBYTE(v48) < 0) {
      goto LABEL_53;
    }
    goto LABEL_54;
  }

  MachProcess::SetState((uint64_t)a1, 2u);
  *(_DWORD *)a1 = a2;
  if (!MachTask::StartExceptionThread((uint64_t)a1 + 104, a3, (uint64_t)__p))
  {
    uint64_t v26 = DNBError::AsString((DNBError *)__p);
    std::string v27 = "unable to start the exception thread";
    if (v26) {
      std::string v27 = (const char *)v26;
    }
    snprintf(a4, a5, "%s", v27);
    if (DNBLogEnabledForAny(2)) {
      _DNBLogThreaded("error: failed to attach to pid %d", a2);
    }
    if (DNBLogEnabled())
    {
      pid_t v28 = getpid();
      _DNBLogError( "[LaunchAttach] END (%d) MachProcess::AttachForDebug failed to start exception thread attaching to pid %i: %s",  v28,  a2,  a4);
    }

    a2 = 0LL;
    char v29 = 0;
    *(_DWORD *)a1 = 0;
    if (SHIBYTE(v48) < 0) {
      goto LABEL_53;
    }
    goto LABEL_54;
  }

  if (DNBLogEnabled())
  {
    uint64_t v10 = getpid();
    _DNBLog(0LL, (uint64_t)"[LaunchAttach] (%d) About to ptrace(PT_ATTACHEXC, %d)...", v11, v12, v13, v14, v15, v16, v10);
  }

  *__error() = 0;
  int v17 = ptrace(14, a2, 0LL, 0);
  unsigned int v18 = *__error();
  if (DNBLogEnabled())
  {
    uint64_t v19 = getpid();
    _DNBLog( 0LL,  (uint64_t)"[LaunchAttach] (%d) Completed ptrace(PT_ATTACHEXC, %d) == %d",  v20,  v21,  v22,  v23,  v24,  v25,  v19);
  }

  if (!v17)
  {
    __p[0] = 0LL;
    if (SHIBYTE(v48) < 0)
    {
      *(_BYTE *)__p[1] = 0;
      *(void *)&__int128 v48 = 0LL;
      if (LODWORD(__p[0])) {
        goto LABEL_34;
      }
    }

    else
    {
      LOBYTE(__p[1]) = 0;
      HIBYTE(v48) = 0;
    }

void sub_1000401C4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL MachProcess::ProcessIsBeingDebugged(MachProcess *this)
{
  *(void *)uint64_t v3 = 0xE00000001LL;
  int v4 = 1;
  int v5 = (int)this;
  size_t v2 = 648LL;
  return !sysctl(v3, 4u, v6, &v2, 0LL, 0LL) && (v6[33] & 8) != 0;
}

uint64_t MachProcess::GetParentProcessID(MachProcess *this)
{
  else {
    return 0LL;
  }
}

void MachProcess::GetGenealogyInfoForThread( MachProcess *this@<X0>, BOOL *a2@<X2>, unint64_t a3@<X1>, void *a4@<X8>)
{
}

uint64_t MachProcess::GetGenealogyImageInfo@<X0>(MachProcess *this@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  return Genealogy::GetProcessExecutableInfosAtIndex((uint64_t)this + 1080, a2, a3);
}

uint64_t MachProcess::GetOSVersionNumbers( MachProcess *this, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  size_t v7 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  uint64_t v8 = +[NSProcessInfo processInfo](&OBJC_CLASS___NSProcessInfo, "processInfo");
  if (v8)
  {
    -[NSProcessInfo operatingSystemVersion](v8, "operatingSystemVersion");
    if (!this) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }

  if (this) {
LABEL_3:
  }
    *(void *)this = 0LL;
LABEL_4:
  if (a2) {
    *a2 = 0LL;
  }
  if (a3) {
    *a3 = 0LL;
  }
  -[NSAutoreleasePool drain](v7, "drain");
  return 1LL;
}

const __CFString *MachProcess::PrepareForAttach(const char *a1, int a2, int a3, uint64_t a4)
{
  if (!a3) {
    return 0LL;
  }
  size_t v7 = strlen(a1);
  if (v7 >= 0x7FFFFFFFFFFFFFF8LL) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  uint64_t v8 = (void *)v7;
  if (v7 >= 0x17)
  {
    uint64_t v11 = (v7 & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v11 = v7 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v9 = (void **)operator new(v11 + 1);
    __dst[1] = v8;
    unint64_t v52 = v12 | 0x8000000000000000LL;
    __dst[0] = v9;
    goto LABEL_10;
  }

  HIBYTE(v52) = v7;
  uint64_t v9 = __dst;
  if (v7) {
LABEL_10:
  }
    memcpy(v9, a1, (size_t)v8);
  *((_BYTE *)v8 + (void)v9) = 0;
  GetAppBundle(__dst, v53);
  if (SHIBYTE(v52) < 0) {
    operator delete(__dst[0]);
  }
  unint64_t v13 = v54;
  if ((v54 & 0x80u) != 0) {
    unint64_t v13 = (unint64_t)v53[1];
  }
  if (!v13)
  {
    if (DNBLogEnabledForAny(2)) {
      _DNBLogThreaded( "MachProcess::PrepareForAttach(): path '%s' doesn't contain .app, we can't tell springboard to wait for launch...",  a1);
    }
LABEL_43:
    uint64_t v10 = 0LL;
    return v10;
  }

  if (a2 != 5 && a2) {
    goto LABEL_43;
  }
  if ((v54 & 0x80u) == 0) {
    uint64_t v14 = (const char *)v53;
  }
  else {
    uint64_t v14 = (const char *)v53[0];
  }
  uint64_t v10 = CopyBundleIDForPath(v14, (DNBError *)a4);
  memset(&v50, 0, sizeof(v50));
  CFString::UTF8(v10, &v50);
  if (DNBLogEnabledForAny(2))
  {
    uint64_t v15 = (const char *)v53;
    if ((v54 & 0x80u) != 0) {
      uint64_t v15 = (const char *)v53[0];
    }
    uint64_t v16 = &v50;
    if ((v50.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      uint64_t v16 = (std::string *)v50.__r_.__value_.__r.__words[0];
    }
    _DNBLogThreaded("CopyBundleIDForPath (%s, err_str) returned @%s", v15, (const char *)v16);
  }

  if (v10)
  {
    int v17 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
    unsigned int v18 = -[NSFileManager stringWithFileSystemRepresentation:length:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "stringWithFileSystemRepresentation:length:",  "/dev/null",  9LL);
    id v19 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
    id v20 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
    if (DNBLogEnabledForAny(2))
    {
      uint64_t v21 = &v50;
      if ((v50.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        uint64_t v21 = (std::string *)v50.__r_.__value_.__r.__words[0];
      }
      _DNBLogThreaded( "Calling BKSSystemService openApplication: @%s,options include stdio path: %s, BKSDebugOptionKeyDebugOnNe xtLaunch & BKSDebugOptionKeyWaitForDebugger)",  (const char *)v21,  "/dev/null");
    }

    [v19 setObject:v18 forKey:FBSDebugOptionKeyStandardOutPath];
    [v19 setObject:v18 forKey:FBSDebugOptionKeyStandardErrorPath];
    uint64_t v22 = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 1LL);
    [v19 setObject:v22 forKey:FBSDebugOptionKeyWaitForDebugger];
    uint64_t v23 = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 1LL);
    [v19 setObject:v23 forKey:FBSDebugOptionKeyDebugOnNextLaunch];
    [v20 setObject:v19 forKey:FBSOpenApplicationOptionKeyDebuggingOptions];
    id v24 = objc_alloc_init(&OBJC_CLASS___FBSSystemService);
    id v25 = [v24 createClientPort];
    uint64_t v44 = 0LL;
    pid_t v45 = &v44;
    uint64_t v46 = 0x3052000000LL;
    __int128 v47 = __Block_byref_object_copy__0;
    __int128 v48 = __Block_byref_object_dispose__0;
    dispatch_semaphore_t v49 = 0LL;
    dispatch_semaphore_t v49 = dispatch_semaphore_create(0LL);
    uint64_t v40 = 0LL;
    uint64_t v41 = &v40;
    uint64_t v42 = 0x2020000000LL;
    uint64_t v43 = 0LL;
    if (DNBLogEnabled())
    {
      uint64_t v26 = getpid();
      _DNBLog( 0LL,  (uint64_t)"[LaunchAttach] START (%d) requesting FBS launch of app with bundle ID '%s'",  v27,  v28,  v29,  v30,  v31,  v32,  v26);
    }

    v39[0] = _NSConcreteStackBlock;
    v39[1] = 3254779904LL;
    v39[2] = ___ZN11MachProcess16PrepareForAttachEPKc19nub_launch_flavor_tbR8DNBError_block_invoke;
    void v39[3] = &__block_descriptor_56_e8_32o40r48r_e17_v16__0__NSError_8l;
    v39[4] = v24;
    v39[5] = &v40;
    v39[6] = &v44;
    [v24 openApplication:v10 options:v20 clientPort:v25 withResult:v39];
    dispatch_time_t v33 = dispatch_time(0LL, 9000000000LL);
    if (dispatch_semaphore_wait((dispatch_semaphore_t)v45[5], v33))
    {
      if (DNBLogEnabled())
      {
        pid_t v34 = &v50;
        if ((v50.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          pid_t v34 = (std::string *)v50.__r_.__value_.__r.__words[0];
        }
        _DNBLogError("timed out trying to launch %s.", (const char *)v34);
      }

      std::string::assign((std::string *)(a4 + 8), "debugserver timed out waiting for openApplication to complete.");
      *(void *)a4 = 111LL;
      if (*(char *)(a4 + 31) < 0)
      {
        **(_BYTE **)(a4 + 8) = 0;
        *(void *)(a4 + 16) = 0LL;
      }

      else
      {
        *(_BYTE *)(a4 + 8) = 0;
        *(_BYTE *)(a4 + 31) = 0;
      }
    }

    else
    {
      uint64_t v35 = v41[3];
      if (v35)
      {
        memset(&__p, 0, sizeof(__p));
        SetFBSError(v35, &__p, a4);
        if (DNBLogEnabled())
        {
          std::string v36 = &v50;
          if ((v50.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            std::string v36 = (std::string *)v50.__r_.__value_.__r.__words[0];
          }
          _DNBLogError( "unable to launch the application with CFBundleIdentifier '%s' bks_error = %ld",  (const char *)v36,  v41[3]);
        }
      }
    }

    dispatch_release((dispatch_object_t)v45[5]);
    -[NSAutoreleasePool drain](v17, "drain");
    _Block_object_dispose(&v40, 8);
    _Block_object_dispose(&v44, 8);
    if (DNBLogEnabledForAny(2)) {
      _DNBLogThreaded("Successfully set DebugOnNextLaunch.");
    }
  }

  if ((char)v50.__r_.__value_.__s.__size_ < 0)
  {
    operator delete(v50.__r_.__value_.__l.__data_);
    goto LABEL_57;
  }

  if ((char)v54 < 0) {
LABEL_57:
  }
    operator delete(v53[0]);
  return v10;
}

void sub_1000408D8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Block_object_dispose(&a25, 8);
  _Block_object_dispose(&a29, 8);
  _Unwind_Resume(a1);
}

void GetAppBundle(void **__src@<X0>, void *a2@<X8>)
{
  size_t v2 = __src;
  int v4 = *((char *)__src + 23);
  unint64_t v5 = *((unsigned __int8 *)__src + 23);
  if (v4 < 0)
  {
    uint64_t v6 = (char *)*__src;
    size_t v7 = (char *)__src[1];
    if (!v7) {
      goto LABEL_69;
    }
  }

  else
  {
    uint64_t v6 = (char *)__src;
    size_t v7 = (char *)*((unsigned __int8 *)__src + 23);
    if (!*((_BYTE *)__src + 23)) {
      goto LABEL_69;
    }
  }

  uint64_t v8 = &v7[(void)v6];
  uint64_t v9 = v6;
  uint64_t v10 = &v7[(void)v6];
  while (2)
  {
    for (unint64_t i = v9 + 3; ; ++i)
    {
      uint64_t v9 = i - 2;
      if (*(i - 3) != 46)
      {
        if (v9 == v8) {
          goto LABEL_18;
        }
        continue;
      }

      if (v9 == v8) {
        goto LABEL_18;
      }
      if (*v9 == 97)
      {
        if (i - 1 == v8) {
          goto LABEL_18;
        }
        if (*(i - 1) == 112) {
          break;
        }
      }
    }

    if (i != v8)
    {
      if (*i == 112) {
        uint64_t v10 = i - 3;
      }
      continue;
    }

    break;
  }

CFStringRef CopyBundleIDForPath(const char *a1, DNBError *a2)
{
  Identifier = (const __CFString *)CFBundle::GetIdentifier((CFBundle *)v10);
  memset(&__p, 0, sizeof(__p));
  if (CFString::UTF8(Identifier, &__p))
  {
    if (DNBLogEnabledForAny(2))
    {
      p_p = &__p;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      _DNBLogThreaded("%s() extracted CFBundleIdentifier: %s", "CopyBundleIDForPath", (const char *)p_p);
    }

    CFRetain(Identifier);
LABEL_30:
    operator delete(__p.__r_.__value_.__l.__data_);
    goto LABEL_7;
  }

  if (stat(a1, &v8) < 0)
  {
    *(_DWORD *)a2 = *__error();
    *((_DWORD *)a2 + 1) = 2;
    if (*((char *)a2 + 31) < 0)
    {
      **((_BYTE **)a2 + 1) = 0;
      *((void *)a2 + 2) = 0LL;
    }

    else
    {
      *((_BYTE *)a2 + 8) = 0;
      *((_BYTE *)a2 + 31) = 0;
    }

    size_t v7 = (const char *)DNBError::AsString(a2);
    snprintf(__str, 0x400uLL, "%s: %s", v7, a1);
    if (__str[0])
    {
      std::string::assign((std::string *)((char *)a2 + 8), __str);
    }

    else if (*((char *)a2 + 31) < 0)
    {
      **((_BYTE **)a2 + 1) = 0;
      *((void *)a2 + 2) = 0LL;
    }

    else
    {
      *((_BYTE *)a2 + 8) = 0;
      *((_BYTE *)a2 + 31) = 0;
    }

    if (DNBLogEnabledForAny(2)) {
      _DNBLogThreaded("%s() error: %s", "CopyBundleIDForPath", __str);
    }
  }

  else
  {
    *(void *)a2 = 0xFFFFFFFFLL;
    if (*((char *)a2 + 31) < 0)
    {
      **((_BYTE **)a2 + 1) = 0;
      *((void *)a2 + 2) = 0LL;
    }

    else
    {
      *((_BYTE *)a2 + 8) = 0;
      *((_BYTE *)a2 + 31) = 0;
    }

    snprintf(__str, 0x400uLL, "failed to extract CFBundleIdentifier from %s", a1);
    if (__str[0])
    {
      std::string::assign((std::string *)((char *)a2 + 8), __str);
    }

    else if (*((char *)a2 + 31) < 0)
    {
      **((_BYTE **)a2 + 1) = 0;
      *((void *)a2 + 2) = 0LL;
    }

    else
    {
      *((_BYTE *)a2 + 8) = 0;
      *((_BYTE *)a2 + 31) = 0;
    }

    if (DNBLogEnabledForAny(2)) {
      _DNBLogThreaded("%s() error: failed to extract CFBundleIdentifier from '%s'", "CopyBundleIDForPath", a1);
    }
  }

  Identifier = 0LL;
LABEL_7:
  CFBundle::~CFBundle((CFBundle *)v10);
  return Identifier;
}

void sub_100040F0C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, void *__p, uint64_t a30, int a31, __int16 a32, char a33, char a34, char a35)
{
}

void __Block_byref_object_copy__0(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__0(uint64_t a1)
{
}

uint64_t ___ZN11MachProcess16PrepareForAttachEPKc19nub_launch_flavor_tbR8DNBError_block_invoke( uint64_t a1, void *a2)
{
  if (a2) {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = [a2 code];
  }

  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL));
}

void __copy_helper_block_e8_32o40r48r(uint64_t a1, const void **a2)
{
}

void __destroy_helper_block_e8_32o40r48r(const void **a1)
{
}

void SetFBSError(int a1, const std::string *a2, uint64_t a3)
{
  *(_DWORD *)a3 = a1;
  *(_DWORD *)(a3 + 4) = 5;
  if (*(char *)(a3 + 31) < 0)
  {
    **(_BYTE **)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0LL;
  }

  else
  {
    *(_BYTE *)(a3 + 8) = 0;
    *(_BYTE *)(a3 + 31) = 0;
  }

  unint64_t v5 = (void *)FBSOpenApplicationErrorCodeToString();
  __s.__r_.__value_.__s.__size_ = 17;
  strcpy((char *)&__s, "unknown FBS error");
  if ((char)a2->__r_.__value_.__s.__size_ < 0)
  {
    if (a2->__r_.__value_.__l.__size_) {
      goto LABEL_6;
    }
  }

  else if (a2->__r_.__value_.__s.__size_)
  {
LABEL_6:
    std::string::operator=(&__s, a2);
    goto LABEL_10;
  }

  if (v5) {
    std::string::assign(&__s, (const std::string::value_type *)[v5 UTF8String]);
  }
LABEL_10:
  if ((char)__s.__r_.__value_.__s.__size_ < 0)
  {
    p_s = (std::string *)__s.__r_.__value_.__r.__words[0];
    if (!__s.__r_.__value_.__r.__words[0]) {
      goto LABEL_15;
    }
  }

  else
  {
    p_s = &__s;
  }

  if (p_s->__r_.__value_.__s.__data_[0])
  {
    std::string::assign((std::string *)(a3 + 8), (const std::string::value_type *)p_s);
    goto LABEL_17;
  }

LABEL_15:
  if ((*(char *)(a3 + 31) & 0x80000000) == 0)
  {
    *(_BYTE *)(a3 + 8) = 0;
    *(_BYTE *)(a3 + 31) = 0;
LABEL_17:
    goto LABEL_18;
  }

  **(_BYTE **)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0LL;
  if ((char)__s.__r_.__value_.__s.__size_ < 0) {
LABEL_18:
  }
    operator delete(__s.__r_.__value_.__l.__data_);
}

void sub_100041140( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id MachProcess::CheckForProcess(uint64_t a1, int a2)
{
  if (!a1) {
    return 0LL;
  }
  if (a2 == 5)
  {
    unsigned int v3 = (Class *)&OBJC_CLASS___FBSSystemService_ptr;
    goto LABEL_7;
  }

  if (a2 != 4) {
    return 0LL;
  }
  unsigned int v3 = (Class *)&OBJC_CLASS___BKSSystemService_ptr;
LABEL_7:
  id v5 = objc_alloc_init(*v3);
  id v6 = [v5 pidForApplication:a1];

  return v6;
}

void MachProcess::CleanupAfterAttach(MachProcess *this, int a2, DNBError *a3, DNBError *a4)
{
  if (this)
  {
    if (a2 == 4)
    {
      goto LABEL_9;
    }

    if (a2 == 5)
    {
LABEL_9:
      CFRelease(this);
    }
  }

id MachProcess::FBSCleanupAfterAttach(MachProcess *this, DNBError *a2, DNBError *a3)
{
  id v5 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  id v6 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
  size_t v7 = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 1LL);
  [v6 setObject:v7 forKey:FBSDebugOptionKeyCancelDebugOnNextLaunch];
  id v8 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
  [v8 setObject:v6 forKey:FBSOpenApplicationOptionKeyDebuggingOptions];
  if ((CallBoardSystemServiceOpenApplication<FBSSystemService,FBSOpenApplicationErrorCode,(FBSOpenApplicationErrorCode)0,&(SetFBSError(long,std::string,DNBError &))>( this,  v8,  (uint64_t)a2,  0LL) & 1) == 0 && DNBLogEnabled())
  {
    uint64_t v9 = (const char *)-[MachProcess UTF8String](this, "UTF8String");
    uint64_t v10 = (const char *)DNBError::AsString(a2);
    _DNBLogError("error trying to cancel debug on next launch for %s: %s", v9, v10);
  }

  return -[NSAutoreleasePool drain](v5, "drain");
}

id MachProcess::BKSCleanupAfterAttach(MachProcess *this, DNBError *a2, DNBError *a3)
{
  id v5 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  id v6 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
  size_t v7 = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 1LL);
  [v6 setObject:v7 forKey:BKSDebugOptionKeyCancelDebugOnNextLaunch];
  id v8 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
  [v8 setObject:v6 forKey:BKSOpenApplicationOptionKeyDebuggingOptions];
  if ((CallBoardSystemServiceOpenApplication<BKSSystemService,BKSOpenApplicationErrorCode,(BKSOpenApplicationErrorCode)0,&(SetBKSError(long,std::string,DNBError &))>( this,  v8,  (uint64_t)a2,  0LL) & 1) == 0 && DNBLogEnabled())
  {
    uint64_t v9 = (const char *)-[MachProcess UTF8String](this, "UTF8String");
    uint64_t v10 = (const char *)DNBError::AsString(a2);
    _DNBLogError("error trying to cancel debug on next launch for %s: %s", v9, v10);
  }

  return -[NSAutoreleasePool drain](v5, "drain");
}

const char **MachProcess::LaunchForDebug( unsigned int *a1, char *a2, void *a3, const char **a4, const char **a5, char *a6, char *a7, char *a8, char a9, unsigned int a10, int a11, char *a12, int8x16_t **a13, uint64_t a14)
{
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded( "%s( path = '%s', argv = %p, envp = %p, launch_flavor = %u, disable_aslr = %d)",  "LaunchForDebug",  a2,  a3,  a4,  a10,  a11);
  }
  uint64_t v22 = (DNBArchProtocol *)MachProcess::SetState((uint64_t)a1, 3u);
  switch(a10)
  {
    case 1u:
      uint64_t CPUType = (DNBArchProtocol *)DNBArchProtocol::GetCPUType(v22);
      int CPUSubType = DNBArchProtocol::GetCPUSubType(CPUType);
      LODWORD(v106) = a11;
      LOBYTE(v105) = a9;
      unsigned int v28 = MachProcess::PosixSpawnChildForPTraceDebugging( (MachProcess *)a2,  (const char *)CPUType,  CPUSubType,  (char *const *)a3,  a4,  a5,  a6,  a7,  a8,  v105,  a1,  v106,  (DNBError *)a14,  v107);
      *a1 = v28;
      if (!v28) {
        goto LABEL_31;
      }
      goto LABEL_5;
    case 2u:
      unsigned int v51 = MachProcess::ForkChildForPTraceDebugging( (MachProcess *)a2,  (char *const *)a3,  v23,  (const char **)a1,  v24,  v25);
      *a1 = v51;
      if (!v51) {
        goto LABEL_31;
      }
      goto LABEL_5;
    case 4u:
      size_t v47 = strlen(a2);
      if (v47 > 0x7FFFFFFFFFFFFFF7LL) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      __int128 v48 = (void *)v47;
      if (v47 >= 0x17)
      {
        uint64_t v80 = (v47 & 0xFFFFFFFFFFFFFFF8LL) + 8;
        if ((v47 | 7) != 0x17) {
          uint64_t v80 = v47 | 7;
        }
        uint64_t v81 = v80 + 1;
        dispatch_semaphore_t v49 = operator new(v80 + 1);
        __p[1] = v48;
        unint64_t v113 = v81 | 0x8000000000000000LL;
        __p[0] = v49;
        uint64_t v50 = a14;
      }

      else
      {
        HIBYTE(v1MachTask::Clear((void *)this + 13) = v47;
        dispatch_semaphore_t v49 = __p;
        uint64_t v50 = a14;
        if (!v47) {
          goto LABEL_58;
        }
      }

      memcpy(v49, a2, (size_t)v48);
LABEL_58:
      *((_BYTE *)v48 + (void)v49) = 0;
      GetAppBundle(__p, &__dst);
      if (SHIBYTE(v113) < 0)
      {
        operator delete(__p[0]);
        int v82 = SHIBYTE(v117);
        if ((SHIBYTE(v117) & 0x80000000) == 0) {
          goto LABEL_60;
        }
      }

      else
      {
        int v82 = SHIBYTE(v117);
        if ((SHIBYTE(v117) & 0x80000000) == 0)
        {
LABEL_60:
          if (!v82) {
            goto LABEL_75;
          }
          a1[110] |= 0x14u;
          p_dst = (const char *)&__dst;
          goto LABEL_74;
        }
      }

      if (!*((void *)&__dst + 1)) {
        goto LABEL_75;
      }
      a1[110] |= 0x14u;
      p_dst = (const char *)__dst;
LABEL_74:
      if (MachProcess::BoardServiceLaunchForDebug( a1,  p_dst,  (const char **)a3,  a4,  a9,  a11 != 0,  a12,  a13,  v50)) {
        goto LABEL_83;
      }
LABEL_75:
      if (DNBLogEnabled())
      {
        uint64_t v94 = &__dst;
        if (v117 < 0) {
          uint64_t v94 = (__int128 *)__dst;
        }
        _DNBLog(0LL, (uint64_t)"Failed to launch '%s' with BKS", v88, v89, v90, v91, v92, v93, (uint64_t)v94);
      }

void sub_100041C28( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p, uint64_t a21, int a22, __int16 a23, char a24, char a25, char a26, uint64_t a27, int a28, __int16 a29, char a30, char a31, char a32, uint64_t a33, int a34, __int16 a35, char a36, char a37, uint64_t a38, uint64_t a39, int a40, __int16 a41, char a42, char a43)
{
  if (a25 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }

  _Unwind_Resume(exception_object);
}

uint64_t MachProcess::ForkChildForPTraceDebugging( MachProcess *this, char *const *a2, const char **a3, const char **a4, MachProcess *a5, DNBError *a6)
{
  int v15 = 0;
  PseudoTerminal::PseudoTerminal((PseudoTerminal *)&v14);
  uint64_t v9 = PseudoTerminal::Fork(&v14, &v15);
  uint64_t v10 = v9;
  if ((v9 & 0x80000000) == 0)
  {
    if (!(_DWORD)v9)
    {
      ptrace(0, 0, 0LL, 0);
      ptrace(12, 0, 0LL, 0);
      gid_t v13 = getgid();
      if (!setgid(v13))
      {
        setpgid(0, 0);
        sleep(1u);
        execv((const char *)this, a2);
      }

      exit(127);
    }

    setpgid(v9, v9);
    if (a4)
    {
      int v11 = v14;
      int v14 = -1;
      *((_DWORD *)a4 + 3) = v11;
      *((_DWORD *)a4 + 4) = v11;
      *((_DWORD *)a4 + 5) = v11;
    }
  }

  PseudoTerminal::~PseudoTerminal((PseudoTerminal *)&v14);
  return v10;
}

void sub_100041D90( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, char a10)
{
}

uint64_t MachProcess::BoardServiceLaunchForDebug( unsigned int *a1, const char *a2, const char **a3, const char **a4, char a5, int a6, char *a7, int8x16_t **a8, uint64_t a9)
{
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded("%s( '%s', argv)", "BoardServiceLaunchForDebug", a2);
  }
  MachProcess::SetState((uint64_t)a1, 3u);
  unsigned int v17 = MachProcess::BoardServiceForkChildForPTraceDebugging((MachProcess *)a1, a2, a3, a4, a5, a6, a7, (DNBError *)a9);
  *a1 = v17;
  if (v17)
  {
    std::string::assign((std::string *)a1 + 1, a2);
    uint64_t v18 = *a3;
    if (*a3)
    {
      uint64_t v19 = a3 + 1;
      do
      {
        size_t v22 = strlen(v18);
        if (v22 >= 0x7FFFFFFFFFFFFFF8LL) {
          std::string::__throw_length_error[abi:ne180100]();
        }
        size_t v23 = v22;
        if (v22 >= 0x17)
        {
          uint64_t v25 = (v22 & 0xFFFFFFFFFFFFFFF8LL) + 8;
          if ((v22 | 7) != 0x17) {
            uint64_t v25 = v22 | 7;
          }
          uint64_t v26 = v25 + 1;
          p_dst = (__int128 *)operator new(v25 + 1);
          *((void *)&__dst + 1) = v23;
          unint64_t v67 = v26 | 0x8000000000000000LL;
          *(void *)&__int128 __dst = p_dst;
        }

        else
        {
          HIBYTE(v67) = v22;
          p_dst = &__dst;
          if (!v22) {
            goto LABEL_16;
          }
        }

        memmove(p_dst, v18, v23);
LABEL_16:
        *((_BYTE *)p_dst + v23) = 0;
        unint64_t v27 = *((void *)a1 + 7);
        if (v27 < *((void *)a1 + 8))
        {
          __int128 v20 = __dst;
          *(void *)(v27 + 16) = v67;
          *(_OWORD *)unint64_t v27 = v20;
          *((void *)a1 + 7) = v27 + 24;
        }

        else
        {
          unsigned int v28 = std::vector<std::string>::__push_back_slow_path<std::string>((void **)a1 + 6, (uint64_t)&__dst);
          int v29 = SHIBYTE(v67);
          *((void *)a1 + 7) = v28;
          if (v29 < 0) {
            operator delete((void *)__dst);
          }
        }

        uint64_t v21 = *v19++;
        uint64_t v18 = v21;
      }

      while (v21);
    }

    MachTask::StartExceptionThread((uint64_t)(a1 + 26), a8, a9);
    if (*(_DWORD *)a9)
    {
      if (DNBError::AsString((DNBError *)a9))
      {
        if (!DNBLogEnabled())
        {
LABEL_23:
          ptrace(8, *a1, 0LL, 0);
          uint64_t result = 0LL;
          *a1 = 0;
          return result;
        }
      }

      else
      {
        std::string::assign((std::string *)(a9 + 8), "unable to start the exception thread");
        if (!DNBLogEnabled()) {
          goto LABEL_23;
        }
      }

      uint64_t v30 = getpid();
      _DNBLog( 0LL,  (uint64_t)"[LaunchAttach] END (%d) Could not get inferior's Mach exception port, sending ptrace PT_KILL to pid %i and exiting.",  v31,  v32,  v33,  v34,  v35,  v36,  v30);
      goto LABEL_23;
    }

    if (DNBLogEnabledForAny(2)) {
      _DNBLogThreaded("MachProcess::%s()", "StartSTDIOThread");
    }
    pthread_create((pthread_t *)a1 + 56, 0LL, (void *(__cdecl *)(void *))MachProcess::STDIOThread, a1);
    MachProcess::SetState((uint64_t)a1, 2u);
    if (DNBLogEnabled())
    {
      uint64_t v38 = getpid();
      _DNBLog( 0LL,  (uint64_t)"[LaunchAttach] (%d) About to ptrace(PT_ATTACHEXC, %d)...",  v39,  v40,  v41,  v42,  v43,  v44,  v38);
    }

    int v45 = ptrace(14, *a1, 0LL, 0);
    if (DNBLogEnabled())
    {
      uint64_t v46 = getpid();
      _DNBLog( 0LL,  (uint64_t)"[LaunchAttach] (%d) Completed ptrace(PT_ATTACHEXC, %d) == %d",  v47,  v48,  v49,  v50,  v51,  v52,  v46);
    }

    if (v45)
    {
      std::string::assign( (std::string *)(a9 + 8),  "Failed to attach to pid: BoardServiceLaunchForDebug() unable to ptrace(PT_ATTACHEXC)");
      MachProcess::SetState((uint64_t)a1, 9u);
      if (DNBLogEnabled())
      {
        uint64_t v65 = getpid();
        _DNBLog( 0LL,  (uint64_t)"[LaunchAttach] END (%d) error: failed to attach to pid %d",  v53,  v54,  v55,  v56,  v57,  v58,  v65);
      }
    }

    else
    {
      a1[110] |= 1u;
      if (DNBLogEnabled()) {
        _DNBLog(0LL, (uint64_t)"[LaunchAttach] successfully attached to pid %d", v59, v60, v61, v62, v63, v64, *a1);
      }
    }
  }

  return *a1;
}

void sub_1000420EC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MachProcess::PosixSpawnChildForPTraceDebugging( MachProcess *this, const char *a2, int a3, char *const *a4, const char **a5, const char **a6, char *a7, char *a8, char *a9, const char *a10, _DWORD *a11, MachProcess *a12, DNBError *a13, DNBError *a14)
{
  uint64_t v19 = a9;
  int v48 = a3;
  cpu_type_t v49 = (int)a2;
  if (DNBLogEnabledForAny(2)) {
    _DNBLogThreaded( "%s(path='%s', argv=%p, envp=%p, working_dir=%s, stdin=%s, stdout=%s stderr=%s, no-stdio=%i)",  "PosixSpawnChildForPTraceDebugging",  (const char *)this,  a4,  a5,  (const char *)a6,  a7,  a8,  a9,  a10);
  }
  posix_spawnattr_t v47 = 0LL;
  int v20 = posix_spawnattr_init(&v47);
  *(_DWORD *)a13 = v20;
  *((_DWORD *)a13 + 1) = 2;
  if (*((char *)a13 + 31) < 0)
  {
    **((_BYTE **)a13 + 1) = 0;
    *((void *)a13 + 2) = 0LL;
    if (!*(_DWORD *)a13) {
      goto LABEL_7;
    }
  }

  else
  {
    *((_BYTE *)a13 + 8) = 0;
    *((_BYTE *)a13 + 31) = 0;
    if (!v20)
    {
LABEL_7:
      if (!DNBLogCheckLogBit(2)) {
        goto LABEL_9;
      }
    }
  }

  DNBError::LogThreaded(a13, "::posix_spawnattr_init(&attr)");
LABEL_9:
  if (*(_DWORD *)a13) {
    return 0LL;
  }
  if ((_DWORD)a12) {
    __int16 v21 = 398;
  }
  else {
    __int16 v21 = 142;
  }
  sigset_t v45 = -1;
  sigset_t v46 = 0;
  posix_spawnattr_setsigmask(&v47, &v46);
  posix_spawnattr_setsigdefault(&v47, &v45);
  int v22 = posix_spawnattr_setflags(&v47, v21);
  *(_DWORD *)a13 = v22;
  *((_DWORD *)a13 + 1) = 2;
  if (*((char *)a13 + 31) < 0)
  {
    **((_BYTE **)a13 + 1) = 0;
    *((void *)a13 + 2) = 0LL;
    if (!*(_DWORD *)a13) {
      goto LABEL_17;
    }
  }

  else
  {
    *((_BYTE *)a13 + 8) = 0;
    *((_BYTE *)a13 + 31) = 0;
    if (!v22)
    {
LABEL_17:
      if (!DNBLogCheckLogBit(2)) {
        goto LABEL_21;
      }
    }
  }

  size_t v23 = " | _POSIX_SPAWN_DISABLE_ASLR";
  if (!(_DWORD)a12) {
    size_t v23 = (const char *)&unk_1000528BD;
  }
  DNBError::LogThreaded(a13, "::posix_spawnattr_setflags(&attr, POSIX_SPAWN_START_SUSPENDED%s)", v23);
LABEL_21:
  if (*(_DWORD *)a13) {
    return 0LL;
  }
  if (v49)
  {
    v53[0] = 0LL;
    if (v48)
    {
      uint64_t v26 = (uint64_t (*)(posix_spawnattr_t *, uint64_t, cpu_type_t *, int *, size_t *))dlsym( (void *)0xFFFFFFFFFFFFFFFELL,  "posix_spawnattr_setarchpref_np");
      if (v26)
      {
        int v27 = v26(&v47, 1LL, &v49, &v48, v53);
        *(_DWORD *)a13 = v27;
        *((_DWORD *)a13 + 1) = 1;
        if (*((char *)a13 + 31) < 0)
        {
          **((_BYTE **)a13 + 1) = 0;
          *((void *)a13 + 2) = 0LL;
          int v27 = *(_DWORD *)a13;
        }

        else
        {
          *((_BYTE *)a13 + 8) = 0;
          *((_BYTE *)a13 + 31) = 0;
        }

        if (!v27 && !DNBLogCheckLogBit(2)) {
          goto LABEL_41;
        }
        DNBError::LogThreaded( a13,  "::posix_spawnattr_setarchpref_np(&attr, 1, cpu_type = 0x%8.8x, cpu_subtype = 0x%8.8x, count => %llu)",  v49,  v48,  v53[0]);
        if (*(_DWORD *)a13 || v53[0] != 1) {
          return 0LL;
        }
        if (!v27) {
          goto LABEL_43;
        }
      }
    }

    int v28 = posix_spawnattr_setbinpref_np(&v47, 1uLL, &v49, v53);
    *(_DWORD *)a13 = v28;
    *((_DWORD *)a13 + 1) = 2;
    if (*((char *)a13 + 31) < 0)
    {
      **((_BYTE **)a13 + 1) = 0;
      *((void *)a13 + 2) = 0LL;
      if (!*(_DWORD *)a13) {
        goto LABEL_39;
      }
    }

    else
    {
      *((_BYTE *)a13 + 8) = 0;
      *((_BYTE *)a13 + 31) = 0;
      if (!v28)
      {
LABEL_39:
        if (DNBLogCheckLogBit(2)) {
          goto LABEL_40;
        }
LABEL_41:
        if (*(_DWORD *)a13 || v53[0] != 1) {
          return 0LL;
        }
        goto LABEL_43;
      }
    }

void sub_100042928( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
}

uint64_t MachProcess::BoardServiceForkChildForPTraceDebugging( MachProcess *this, const char *a2, const char **a3, const char **a4, char a5, int a6, char *a7, DNBError *a8)
{
  if (*a3)
  {
    if (DNBLogEnabledForAny(2)) {
      _DNBLogThreaded("%s( '%s', argv, %p)", "BoardServiceForkChildForPTraceDebugging", a2, this);
    }
    uint64_t v68 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
    uint64_t v16 = 0LL;
    uint64_t v17 = -1LL;
    do
    {
      uint64_t v18 = a3[v16++];
      ++v17;
    }

    while (v18);
    int v67 = a6;
    std::string __s = a7;
    if (a3[1])
    {
      unint64_t v19 = v16 - 1;
      int v20 = +[NSMutableArray arrayWithCapacity:]( &OBJC_CLASS___NSMutableArray,  "arrayWithCapacity:",  ~(unint64_t)(v17 != 0) + v16);
      if (v19 >= 2)
      {
        for (uint64_t i = 1LL; i != v19; ++i)
        {
          if (!a3[i]) {
            break;
          }
          int v22 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:");
          if (!v22) {
            break;
          }
          -[NSMutableArray addObject:](v20, "addObject:", v22);
        }
      }
    }

    else
    {
      int v20 = 0LL;
    }

    if (*a4)
    {
      uint64_t v24 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
      uint64_t v25 = *a4;
      if (*a4)
      {
        uint64_t v26 = a4 + 1;
        do
        {
          int v28 = strchr(v25, 61);
          if (v28 && v28 != v25) {
            -[NSMutableDictionary setObject:forKey:]( v24,  "setObject:forKey:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v28 + 1),  -[NSString initWithBytes:length:encoding:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithBytes:length:encoding:",  *(v26 - 1),  (int)v28 - (int)v25,  4LL));
          }
          int v27 = *v26++;
          uint64_t v25 = v27;
        }

        while (v27);
      }
    }

    else
    {
      uint64_t v24 = 0LL;
    }

    int v29 = +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager");
    PseudoTerminal::PseudoTerminal((PseudoTerminal *)&v70);
    int v35 = PseudoTerminal::SecondaryName((PseudoTerminal *)&v70);
    if (DNBLogEnabledForAny(2)) {
      _DNBLogThreaded( "%s() successfully opened primary pty, secondary is %s",  "BoardServiceForkChildForPTraceDebugging",  v35);
    }
    if (!v35
      || !*v35
      || (chmod(v35, 0x1FFu),
          (int v30 = -[NSFileManager stringWithFileSystemRepresentation:length:]( v29,  "stringWithFileSystemRepresentation:length:",  v35,  strlen(v35))) == 0LL))
    {
LABEL_25:
      int v30 = -[NSFileManager stringWithFileSystemRepresentation:length:]( v29,  "stringWithFileSystemRepresentation:length:",  "/dev/null",  9LL);
    }

    int v31 = (__CFString *)CopyBundleIDForPath(a2, a8);
    if (!v31)
    {
      -[NSAutoreleasePool drain](v68, "drain");
      uint64_t v23 = 0LL;
LABEL_76:
      PseudoTerminal::~PseudoTerminal((PseudoTerminal *)&v70);
      return v23;
    }

    unsigned int v69 = 0;
    int v32 = *((_DWORD *)this + 110);
    if ((v32 & 0x10) == 0)
    {
      uint64_t v33 = *(unsigned int *)this;
      if ((_DWORD)v33)
      {
        if ([objc_alloc_init(BKSApplicationStateMonitor) mostElevatedApplicationStateForPID:v33])
        {
          int v34 = *((_DWORD *)this + 110) | 8;
        }

        else
        {
          unsigned int v36 = [objc_alloc_init(BKSApplicationStateMonitor) mostElevatedApplicationStateForPID:*(unsigned int *)this];
          int v34 = *((_DWORD *)this + 110);
          if (v36) {
            v34 |= 4u;
          }
        }

        int v32 = v34 | 0x10;
        *((_DWORD *)this + 110) = v32;
      }
    }

    if ((v32 & 4) != 0)
    {
      id v38 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
      size_t v39 = v38;
      if (v20) {
        [v38 setObject:v20 forKey:BKSDebugOptionKeyArguments];
      }
      if (v24) {
        [v39 setObject:v24 forKey:BKSDebugOptionKeyEnvironment];
      }
      [v39 setObject:v30 forKey:BKSDebugOptionKeyStandardOutPath];
      [v39 setObject:v30 forKey:BKSDebugOptionKeyStandardErrorPath];
      uint64_t v40 = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 1LL);
      [v39 setObject:v40 forKey:BKSDebugOptionKeyWaitForDebugger];
      if (v67)
      {
        uint64_t v41 = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 1LL);
        [v39 setObject:v41 forKey:BKSDebugOptionKeyDisableASLR];
      }

      pid_t v42 = (NSMutableDictionary *)+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
      -[NSMutableDictionary setObject:forKey:]( v42,  "setObject:forKey:",  v39,  BKSOpenApplicationOptionKeyDebuggingOptions);
      posix_spawn_file_actions_t v43 = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 1LL);
      -[NSMutableDictionary setObject:forKey:](v42, "setObject:forKey:", v43, BKSOpenApplicationOptionKeyUnlockDevice);
      *(_OWORD *)std::string __p = 0u;
      __int128 v72 = 0u;
      BKSAddEventDataToOptions(v42, __s, (DNBError *)__p);
      if (SHIBYTE(v72) < 0) {
        operator delete(__p[1]);
      }
      int v37 = CallBoardSystemServiceOpenApplication<BKSSystemService,BKSOpenApplicationErrorCode,(BKSOpenApplicationErrorCode)0,&(SetBKSError(long,std::string,DNBError &))>( v31,  v42,  (uint64_t)a8,  &v69);
      int v32 = *((_DWORD *)this + 110);
      if ((v32 & 0x10) != 0) {
        goto LABEL_59;
      }
    }

    else
    {
      int v37 = 0;
      if ((v32 & 0x10) != 0)
      {
LABEL_59:
        if ((v32 & 8) != 0)
        {
          id v47 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
          int v48 = v47;
          if (v20) {
            [v47 setObject:v20 forKey:FBSDebugOptionKeyArguments];
          }
          if (v24) {
            [v48 setObject:v24 forKey:FBSDebugOptionKeyEnvironment];
          }
          [v48 setObject:v30 forKey:FBSDebugOptionKeyStandardOutPath];
          [v48 setObject:v30 forKey:FBSDebugOptionKeyStandardErrorPath];
          cpu_type_t v49 = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 1LL);
          [v48 setObject:v49 forKey:FBSDebugOptionKeyWaitForDebugger];
          if (v67)
          {
            size_t v50 = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 1LL);
            [v48 setObject:v50 forKey:FBSDebugOptionKeyDisableASLR];
          }

          unsigned int v51 = (NSMutableDictionary *)+[NSMutableDictionary dictionary]( &OBJC_CLASS___NSMutableDictionary,  "dictionary");
          -[NSMutableDictionary setObject:forKey:]( v51,  "setObject:forKey:",  v48,  FBSOpenApplicationOptionKeyDebuggingOptions);
          size_t v52 = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 1LL);
          -[NSMutableDictionary setObject:forKey:]( v51,  "setObject:forKey:",  v52,  FBSOpenApplicationOptionKeyUnlockDevice);
          uint64_t v53 = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 1LL);
          -[NSMutableDictionary setObject:forKey:]( v51,  "setObject:forKey:",  v53,  FBSOpenApplicationOptionKeyPromptUnlockDevice);
          id v54 = +[LSApplicationProxy applicationProxyForBundleURL:]( &OBJC_CLASS___LSApplicationProxy,  "applicationProxyForBundleURL:",  +[NSURL fileURLWithPath:isDirectory:]( &OBJC_CLASS___NSURL,  "fileURLWithPath:isDirectory:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a2),  1LL));
          if (v54)
          {
            if (DNBLogEnabled())
            {
              id v55 = [v54 sequenceNumber];
              objc_msgSend(objc_msgSend(objc_msgSend(v54, "cacheGUID"), "UUIDString"), "UTF8String");
              _DNBLog( 0LL,  (uint64_t)"Sending AppProxy info: sequence no: %lu, GUID: %s.",  v56,  v57,  v58,  v59,  v60,  v61,  (uint64_t)v55);
            }

            uint64_t v62 = +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v54 sequenceNumber]);
            -[NSMutableDictionary setObject:forKey:]( v51,  "setObject:forKey:",  v62,  FBSOpenApplicationOptionKeyLSSequenceNumber);
            id v63 = objc_msgSend(objc_msgSend(v54, "cacheGUID"), "UUIDString");
            -[NSMutableDictionary setObject:forKey:]( v51,  "setObject:forKey:",  v63,  FBSOpenApplicationOptionKeyLSCacheGUID);
          }

          *(_OWORD *)std::string __p = 0u;
          __int128 v72 = 0u;
          FBSAddEventDataToOptions(v51, __s, (DNBError *)__p);
          if (SHIBYTE(v72) < 0) {
            operator delete(__p[1]);
          }
          int v37 = CallBoardSystemServiceOpenApplication<FBSSystemService,FBSOpenApplicationErrorCode,(FBSOpenApplicationErrorCode)0,&(SetFBSError(long,std::string,DNBError &))>( v31,  v51,  (uint64_t)a8,  &v69);
        }

        if (v37)
        {
          int v64 = v70;
          int v70 = -1;
          *((_DWORD *)this + 3) = v64;
          *((_DWORD *)this + 4) = v64;
          *((_DWORD *)this + 5) = v64;
          CFString::UTF8(v31, (std::string *)((char *)this + 1720));
        }

        -[NSAutoreleasePool drain](v68, "drain");
        uint64_t v23 = v69;
        goto LABEL_76;
      }
    }

    uint64_t v44 = *(unsigned int *)this;
    if ((_DWORD)v44)
    {
      if ([objc_alloc_init(BKSApplicationStateMonitor) mostElevatedApplicationStateForPID:v44])
      {
        int v45 = *((_DWORD *)this + 110) | 8;
      }

      else
      {
        unsigned int v46 = [objc_alloc_init(BKSApplicationStateMonitor) mostElevatedApplicationStateForPID:*(unsigned int *)this];
        int v45 = *((_DWORD *)this + 110);
        if (v46) {
          v45 |= 4u;
        }
      }

      int v32 = v45 | 0x10;
      *((_DWORD *)this + 110) = v32;
    }

    goto LABEL_59;
  }

  return 0LL;
}

void sub_1000430A8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23)
{
}

uint64_t MachProcess::ProcessUsingBackBoard(MachProcess *this)
{
  unsigned int v1 = *((_DWORD *)this + 110);
  if ((v1 & 0x10) == 0)
  {
    uint64_t v3 = *(unsigned int *)this;
    if ((_DWORD)v3)
    {
      if ([objc_alloc_init(BKSApplicationStateMonitor) mostElevatedApplicationStateForPID:v3])
      {
        int v4 = *((_DWORD *)this + 110) | 8;
      }

      else
      {
        unsigned int v5 = [objc_alloc_init(BKSApplicationStateMonitor) mostElevatedApplicationStateForPID:*(unsigned int *)this];
        int v4 = *((_DWORD *)this + 110);
        if (v5) {
          v4 |= 4u;
        }
      }

      unsigned int v1 = v4 | 0x10;
      *((_DWORD *)this + 110) = v1;
    }
  }

  return (v1 >> 2) & 1;
}

uint64_t BKSAddEventDataToOptions(NSMutableDictionary *a1, char *__s, DNBError *a3)
{
  std::string __p = 0LL;
  int v32 = 0LL;
  uint64_t v33 = 0LL;
  SplitEventData(__s, (uint64_t)&__p);
  unsigned int v5 = (void **)__p;
  id v6 = v32;
  if (__p == v32)
  {
    char v7 = 0;
    if (__p) {
      goto LABEL_26;
    }
    return v7 & 1;
  }

  char v7 = 0;
  id v8 = (std::string *)((char *)a3 + 8);
  uint64_t v29 = BKSOpenApplicationOptionKeyActivateSuspended;
  uint64_t v9 = BKSActivateForEventOptionTypeBackgroundContentFetching;
  uint64_t v10 = BKSOpenApplicationOptionKeyActivateForEvent;
  do
  {
    if (*((char *)v5 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(&v30, (const std::string::value_type *)*v5, (std::string::size_type)v5[1]);
    }

    else
    {
      __int128 v11 = *(_OWORD *)v5;
      v30.__r_.__value_.__l.__cap_ = (std::string::size_type)v5[2];
      *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v11;
    }

    if (!std::string::compare(&v30, "BackgroundContentFetching"))
    {
      if (DNBLogEnabled()) {
        _DNBLog(0LL, (uint64_t)"Setting ActivateForEvent key in options dictionary.", v13, v14, v15, v16, v17, v18, v28);
      }
      -[NSMutableDictionary setObject:forKey:]( a1,  "setObject:forKey:",  +[NSDictionary dictionaryWithObject:forKey:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObject:forKey:",  +[NSDictionary dictionary](&OBJC_CLASS___NSDictionary, "dictionary"),  v9),  v10);
      char v7 = 1;
LABEL_17:
LABEL_18:
      operator delete(v30.__r_.__value_.__l.__data_);
      goto LABEL_3;
    }

    if (std::string::compare(&v30, "ActivateSuspended"))
    {
      if (DNBLogEnabled())
      {
        size_t v12 = &v30;
        if ((v30.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          size_t v12 = (std::string *)v30.__r_.__value_.__r.__words[0];
        }
        _DNBLogError("Unrecognized event type: %s.  Ignoring.", (const char *)v12);
      }

      std::string::assign(v8, "Unrecognized event data");
      goto LABEL_17;
    }

    if (DNBLogEnabled()) {
      _DNBLog(0LL, (uint64_t)"Setting ActivateSuspended key in options dictionary.", v19, v20, v21, v22, v23, v24, v28);
    }
    -[NSMutableDictionary setObject:forKey:](a1, "setObject:forKey:", &__kCFBooleanTrue, v29);
    char v7 = 1;
LABEL_3:
    v5 += 3;
  }

  while (v5 != v6);
  unsigned int v5 = (void **)__p;
  if (!__p) {
    return v7 & 1;
  }
LABEL_26:
  uint64_t v25 = v32;
  uint64_t v26 = v5;
  if (v32 != v5)
  {
    do
    {
      v25 -= 3;
    }

    while (v25 != v5);
    uint64_t v26 = __p;
  }

  int v32 = v5;
  operator delete(v26);
  return v7 & 1;
}

void sub_1000433A8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17)
{
}

uint64_t FBSAddEventDataToOptions(NSMutableDictionary *a1, char *__s, DNBError *a3)
{
  std::string __p = 0LL;
  int v32 = 0LL;
  uint64_t v33 = 0LL;
  SplitEventData(__s, (uint64_t)&__p);
  unsigned int v5 = (void **)__p;
  id v6 = v32;
  if (__p == v32)
  {
    char v7 = 0;
    if (__p) {
      goto LABEL_26;
    }
    return v7 & 1;
  }

  char v7 = 0;
  id v8 = (std::string *)((char *)a3 + 8);
  uint64_t v29 = FBSOpenApplicationOptionKeyActivateSuspended;
  uint64_t v9 = FBSActivateForEventOptionTypeBackgroundContentFetching;
  uint64_t v10 = FBSOpenApplicationOptionKeyActivateForEvent;
  do
  {
    if (*((char *)v5 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(&v30, (const std::string::value_type *)*v5, (std::string::size_type)v5[1]);
    }

    else
    {
      __int128 v11 = *(_OWORD *)v5;
      v30.__r_.__value_.__l.__cap_ = (std::string::size_type)v5[2];
      *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v11;
    }

    if (!std::string::compare(&v30, "BackgroundContentFetching"))
    {
      if (DNBLogEnabled()) {
        _DNBLog(0LL, (uint64_t)"Setting ActivateForEvent key in options dictionary.", v13, v14, v15, v16, v17, v18, v28);
      }
      -[NSMutableDictionary setObject:forKey:]( a1,  "setObject:forKey:",  +[NSDictionary dictionaryWithObject:forKey:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObject:forKey:",  +[NSDictionary dictionary](&OBJC_CLASS___NSDictionary, "dictionary"),  v9),  v10);
      char v7 = 1;
LABEL_17:
LABEL_18:
      operator delete(v30.__r_.__value_.__l.__data_);
      goto LABEL_3;
    }

    if (std::string::compare(&v30, "ActivateSuspended"))
    {
      if (DNBLogEnabled())
      {
        size_t v12 = &v30;
        if ((v30.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          size_t v12 = (std::string *)v30.__r_.__value_.__r.__words[0];
        }
        _DNBLogError("Unrecognized event type: %s.  Ignoring.", (const char *)v12);
      }

      std::string::assign(v8, "Unrecognized event data.");
      goto LABEL_17;
    }

    if (DNBLogEnabled()) {
      _DNBLog(0LL, (uint64_t)"Setting ActivateSuspended key in options dictionary.", v19, v20, v21, v22, v23, v24, v28);
    }
    -[NSMutableDictionary setObject:forKey:](a1, "setObject:forKey:", &__kCFBooleanTrue, v29);
    char v7 = 1;
LABEL_3:
    v5 += 3;
  }

  while (v5 != v6);
  unsigned int v5 = (void **)__p;
  if (!__p) {
    return v7 & 1;
  }
LABEL_26:
  uint64_t v25 = v32;
  uint64_t v26 = v5;
  if (v32 != v5)
  {
    do
    {
      v25 -= 3;
    }

    while (v25 != v5);
    uint64_t v26 = __p;
  }

  int v32 = v5;
  operator delete(v26);
  return v7 & 1;
}

void sub_100043618( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17)
{
}

void *std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( void *a1, uint64_t a2, uint64_t a3)
{
  if (v13[0])
  {
    uint64_t v6 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
    uint64_t v7 = *(void *)(v6 + 40);
    int v8 = *(_DWORD *)(v6 + 8);
    int v9 = *(_DWORD *)(v6 + 144);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24LL)));
      uint64_t v10 = std::locale::use_facet(&v14, &std::ctype<char>::id);
      int v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32LL);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v9;
    }

    if ((v8 & 0xB0) == 0x20) {
      uint64_t v11 = a2 + a3;
    }
    else {
      uint64_t v11 = a2;
    }
    if (!std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(v7, a2, v11, a2 + a3, v6, (char)v9)) {
      std::ios_base::clear( (std::ios_base *)((char *)a1 + *(void *)(*a1 - 24LL)),  *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24LL) + 32) | 5);
    }
  }

  std::ostream::sentry::~sentry(v13);
  return a1;
}

void sub_10004375C( void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::locale a12)
{
}

void sub_1000437A4(_Unwind_Exception *a1)
{
}

uint64_t std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6 = a1;
  if (a1)
  {
    uint64_t v11 = *(void *)(a5 + 24);
    if (v11 <= a4 - a2) {
      size_t v12 = 0LL;
    }
    else {
      size_t v12 = v11 - (a4 - a2);
    }
    if ((uint64_t)v12 >= 1)
    {
      if (v12 >= 0x7FFFFFFFFFFFFFF8LL) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      if (v12 >= 0x17)
      {
        uint64_t v14 = (v12 & 0xFFFFFFFFFFFFFFF8LL) + 8;
        if ((v12 | 7) != 0x17) {
          uint64_t v14 = v12 | 7;
        }
        uint64_t v15 = v14 + 1;
        uint64_t v13 = (void **)operator new(v14 + 1);
        __b[1] = (void *)v12;
        int64_t v22 = v15 | 0x8000000000000000LL;
        __b[0] = v13;
      }

      else
      {
        HIBYTE(v22) = v12;
        uint64_t v13 = __b;
      }

      memset(v13, __c, v12);
      *((_BYTE *)v13 + v12) = 0;
      if (v22 >= 0) {
        uint64_t v16 = __b;
      }
      else {
        uint64_t v16 = (void **)__b[0];
      }
      uint64_t v17 = (*(uint64_t (**)(uint64_t, void **, size_t))(*(void *)v6 + 96LL))(v6, v16, v12);
      uint64_t v18 = v17;
      if (SHIBYTE(v22) < 0)
      {
        operator delete(__b[0]);
        if (v18 != v12) {
          return 0LL;
        }
      }

      else if (v17 != v12)
      {
        return 0LL;
      }
    }

    uint64_t v19 = a4 - a3;
    if (v19 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 96LL))(v6, a3, v19) == v19)
    {
      *(void *)(a5 + 24) = 0LL;
      return v6;
    }

    return 0LL;
  }

  return v6;
}

void sub_100043940( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::string::__throw_length_error[abi:ne180100]()
{
}

uint64_t std::vector<BOOL>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    unint64_t v4 = *(void *)(a2 + 8);
    if (v4)
    {
      uint64_t v5 = *(void *)(a1 + 16);
      uint64_t v6 = *(void **)a1;
      if (v4 > v5 << 6)
      {
        if (v6)
        {
          operator delete(v6);
          *(void *)a1 = 0LL;
          *(void *)(a1 + 8) = 0LL;
          *(void *)(a1 + 16) = 0LL;
          unint64_t v4 = *(void *)(a2 + 8);
        }

        if ((v4 & 0x8000000000000000LL) != 0) {
          std::vector<kevent>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v7 = ((v4 - 1) >> 6) + 1;
        uint64_t v6 = operator new(8 * v7);
        *(void *)a1 = v6;
        *(void *)(a1 + 8) = 0LL;
        *(void *)(a1 + 16) = v7;
        unint64_t v4 = *(void *)(a2 + 8);
      }

      memmove(v6, *(const void **)a2, (((v4 - 1) >> 3) & 0x1FFFFFFFFFFFFFF8LL) + 8);
      unint64_t v4 = *(void *)(a2 + 8);
    }

    *(void *)(a1 + 8) = v4;
  }

  return a1;
}

void *std::vector<DNBThreadResumeAction>::__assign_with_size[abi:ne180100]<DNBThreadResumeAction*,DNBThreadResumeAction*>( void *result, char *__src, char *a3, size_t __sz)
{
  uint64_t v6 = __src;
  unint64_t v7 = result;
  uint64_t v8 = result[2];
  int v9 = (char *)*result;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - *result) >> 3) < __sz)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      uint64_t v8 = 0LL;
      *unint64_t v7 = 0LL;
      v7[1] = 0LL;
      v7[2] = 0LL;
    }

    if (__sz > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_23;
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 3);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= __sz) {
      uint64_t v11 = __sz;
    }
    unint64_t v12 = v10 >= 0x555555555555555LL ? 0xAAAAAAAAAAAAAAALL : v11;
    if (v12 > 0xAAAAAAAAAAAAAAALL) {
LABEL_23:
    }
      std::vector<kevent>::__throw_length_error[abi:ne180100]();
    uint64_t v13 = 3 * v12;
    uint64_t result = operator new(24 * v12);
    int v9 = (char *)result;
    *unint64_t v7 = result;
    v7[1] = result;
    v7[2] = &result[v13];
    size_t v14 = a3 - v6;
    if (v14) {
      uint64_t result = memcpy(result, v6, v14);
    }
    uint64_t v15 = (void **)(v7 + 1);
    goto LABEL_22;
  }

  uint64_t v15 = (void **)(result + 1);
  uint64_t v16 = (_BYTE *)result[1];
  if (0xAAAAAAAAAAAAAAABLL * ((v16 - v9) >> 3) >= __sz)
  {
    size_t v14 = a3 - __src;
    if (a3 == __src) {
      goto LABEL_22;
    }
    uint64_t v18 = (void *)*result;
LABEL_21:
    uint64_t result = memmove(v18, __src, v14);
    goto LABEL_22;
  }

  uint64_t v17 = &__src[8 * ((v16 - v9) >> 3)];
  if (v16 != v9)
  {
    uint64_t result = memmove((void *)*result, __src, v16 - v9);
    int v9 = (char *)*v15;
  }

  size_t v14 = a3 - v17;
  if (v14)
  {
    uint64_t v18 = v9;
    __src = v17;
    goto LABEL_21;
  }

uint64_t CallBoardSystemServiceOpenApplication<BKSSystemService,BKSOpenApplicationErrorCode,(BKSOpenApplicationErrorCode)0,&(SetBKSError(long,std::string,DNBError &))>( id a1, void *a2, uint64_t a3, _DWORD *a4)
{
  id v8 = objc_alloc_init(&OBJC_CLASS___BKSSystemService);
  int v9 = v8;
  if (!a1)
  {
    a1 = [v8 systemApplicationBundleIdentifier];
    if (!a1)
    {
      std::string::assign((std::string *)(a3 + 8), "No system application to message.");
      return 0LL;
    }
  }

  id v10 = [v9 createClientPort];
  uint64_t v56 = 0LL;
  uint64_t v57 = &v56;
  uint64_t v58 = 0x3052000000LL;
  uint64_t v59 = __Block_byref_object_copy__0;
  uint64_t v60 = __Block_byref_object_dispose__0;
  dispatch_semaphore_t v61 = 0LL;
  dispatch_semaphore_t v61 = dispatch_semaphore_create(0LL);
  uint64_t v52 = 0LL;
  uint64_t v53 = &v52;
  uint64_t v54 = 0x2020000000LL;
  int v55 = 0;
  uint64_t v45 = 0LL;
  unsigned int v46 = (std::string *)&v45;
  uint64_t v47 = 0x4812000000LL;
  int v48 = __Block_byref_object_copy__263;
  cpu_type_t v49 = __Block_byref_object_dispose__264;
  __int128 v50 = 0u;
  __int128 v51 = 0u;
  uint64_t v41 = 0LL;
  pid_t v42 = &v41;
  uint64_t v43 = 0x2020000000LL;
  int v44 = 0;
  uint64_t v11 = (const char *)[a1 UTF8String];
  if (v11) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = "<Unknown Bundle ID>";
  }
  id v13 = [a2 description];
  if (DNBLogEnabled())
  {
    uint64_t v14 = getpid();
    [v13 UTF8String];
    _DNBLog( 0LL,  (uint64_t)"[LaunchAttach] START (%d) templated *Board launcher: app lunch request for '%s' - options:\n%s",  v15,  v16,  v17,  v18,  v19,  v20,  v14);
  }

  v39[0] = _NSConcreteStackBlock;
  v39[1] = 3254779904LL;
  v39[2] = ___ZL37CallBoardSystemServiceOpenApplicationI16BKSSystemService27BKSOpenApplicationErrorCodeLS1_0EXadL_ZL11SetBKSErrorlNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEER8DNBErrorEEEbP8NSStringP12NSDictionarySA_Pi_block_invoke;
  void v39[3] = &__block_descriptor_89_e8_32o40o48r56r64r72r_e17_v16__0__NSError_8l;
  BOOL v40 = a4 != 0LL;
  v39[6] = &v52;
  void v39[7] = &v41;
  v39[4] = a1;
  v39[5] = v9;
  v39[8] = &v45;
  v39[9] = &v56;
  v39[10] = v12;
  [v9 openApplication:a1 options:a2 clientPort:v10 withResult:v39];
  dispatch_time_t v21 = dispatch_time(0LL, 30000000000LL);
  uint64_t v22 = dispatch_semaphore_wait((dispatch_semaphore_t)v57[5], v21);
  dispatch_release((dispatch_object_t)v57[5]);
  if (DNBLogEnabled())
  {
    uint64_t v23 = getpid();
    _DNBLog( 0LL,  (uint64_t)"[LaunchAttach] END (%d) templated *Board launcher finished app lunch request for '%s'",  v24,  v25,  v26,  v27,  v28,  v29,  v23);
  }

  if (!v22)
  {
    uint64_t v31 = *((unsigned int *)v53 + 6);
    if (!(_DWORD)v31)
    {
      if (a4)
      {
        *a4 = *((_DWORD *)v42 + 6);
        if (DNBLogEnabledForAny(2)) {
          _DNBLogThreaded("Out of completion handler, pid from block %d and passing out: %d", *((_DWORD *)v42 + 6), *a4);
        }
      }

      uint64_t v32 = 1LL;
      goto LABEL_21;
    }

    else {
      std::string __str = v46[2];
    }
    *(_DWORD *)a3 = v31;
    *(_DWORD *)(a3 + 4) = 4;
    if (*(char *)(a3 + 31) < 0)
    {
      **(_BYTE **)(a3 + 8) = 0;
      *(void *)(a3 + 16) = 0LL;
    }

    else
    {
      *(_BYTE *)(a3 + 8) = 0;
      *(_BYTE *)(a3 + 31) = 0;
    }

    int v34 = (void *)BKSOpenApplicationErrorCodeToString(v31);
    v62.__r_.__value_.__s.__size_ = 17;
    strcpy((char *)&v62, "unknown BKS error");
    std::string::size_type size = __str.__r_.__value_.__s.__size_;
    if ((__str.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      std::string::size_type size = __str.__r_.__value_.__l.__size_;
    }
    if (size)
    {
      std::string::operator=(&v62, &__str);
    }

    else if (v34)
    {
      std::string::assign(&v62, (const std::string::value_type *)[v34 UTF8String]);
    }

    if ((char)v62.__r_.__value_.__s.__size_ < 0)
    {
      unsigned int v36 = (std::string *)v62.__r_.__value_.__r.__words[0];
      if (!v62.__r_.__value_.__r.__words[0]) {
        goto LABEL_48;
      }
    }

    else
    {
      unsigned int v36 = &v62;
    }

    if (v36->__r_.__value_.__s.__data_[0])
    {
      std::string::assign((std::string *)(a3 + 8), (const std::string::value_type *)v36);
LABEL_50:
      operator delete(v62.__r_.__value_.__l.__data_);
      goto LABEL_51;
    }

void sub_100044030( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31, uint64_t a32, uint64_t a33, uint64_t a34, char a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, void *a41, uint64_t a42, int a43, __int16 a44, char a45, char a46)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose(&a35, 8);
  if (a46 < 0) {
    operator delete(a41);
  }
  _Block_object_dispose((const void *)(v46 - 208), 8);
  _Block_object_dispose((const void *)(v46 - 176), 8);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__263(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a1[3] = result;
  a2[3].n128_u64[1] = 0LL;
  a2[4].n128_u64[0] = 0LL;
  a2[3].n128_u64[0] = 0LL;
  return result;
}

void __Block_byref_object_dispose__264(uint64_t a1)
{
}

uint64_t ___ZL37CallBoardSystemServiceOpenApplicationI16BKSSystemService27BKSOpenApplicationErrorCodeLS1_0EXadL_ZL11SetBKSErrorlNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEER8DNBErrorEEEbP8NSStringP12NSDictionarySA_Pi_block_invoke( uint64_t a1, void *a2)
{
  if (a2) {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = [a2 code];
  }
  if (*(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL))
  {
    unint64_t v4 = (const std::string::value_type *)objc_msgSend(objc_msgSend(a2, "localizedDescription"), "UTF8String");
    if (v4)
    {
      std::string::assign((std::string *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 48LL), v4);
      if (DNBLogEnabled())
      {
        pid_t v5 = getpid();
        _DNBLogError("[LaunchAttach] END (%d) In app launch attempt, got error localizedDescription '%s'.", v5, v4);
      }

      uint64_t v6 = -[NSString UTF8String]( +[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%@", a2),  "UTF8String");
      if (DNBLogEnabled())
      {
        pid_t v7 = getpid();
        _DNBLogError( "[LaunchAttach] END (%d) In app launch attempt, got error NSError object description: '%s'.",  v7,  v6);
      }
    }

    if (DNBLogEnabledForAny(2))
    {
      id v8 = "<unknown error>";
      if (v4) {
        id v8 = v4;
      }
      _DNBLogThreaded( "In completion handler for send event, got error %s(%ld).",  v8,  *(unsigned int *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL));
    }
  }

  else if (*(_BYTE *)(a1 + 88))
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = [*(id *)(a1 + 40) pidForApplication:*(void *)(a1 + 32)];
    if (DNBLogEnabled()) {
      _DNBLog( 0LL,  (uint64_t)"[LaunchAttach] In completion handler, got pid for bundle id '%s', pid: %d.",  v9,  v10,  v11,  v12,  v13,  v14,  *(void *)(a1 + 80));
    }
  }

  else if (DNBLogEnabled())
  {
    _DNBLog( 0LL,  (uint64_t)"[LaunchAttach] In completion handler, launch was successful, debugserver did not ask for the pid",  v15,  v16,  v17,  v18,  v19,  v20,  v22);
  }

  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 40LL));
}

void __copy_helper_block_e8_32o40o48r56r64r72r(uint64_t a1, const void **a2)
{
}

void __destroy_helper_block_e8_32o40o48r56r64r72r(const void **a1)
{
}

uint64_t CallBoardSystemServiceOpenApplication<FBSSystemService,FBSOpenApplicationErrorCode,(FBSOpenApplicationErrorCode)0,&(SetFBSError(long,std::string,DNBError &))>( id a1, void *a2, uint64_t a3, _DWORD *a4)
{
  id v8 = objc_alloc_init(&OBJC_CLASS___FBSSystemService);
  uint64_t v9 = v8;
  if (!a1)
  {
    a1 = [v8 systemApplicationBundleIdentifier];
    if (!a1)
    {
      std::string::assign((std::string *)(a3 + 8), "No system application to message.");
      return 0LL;
    }
  }

  id v10 = [v9 createClientPort];
  uint64_t v53 = 0LL;
  uint64_t v54 = &v53;
  uint64_t v55 = 0x3052000000LL;
  uint64_t v56 = __Block_byref_object_copy__0;
  uint64_t v57 = __Block_byref_object_dispose__0;
  dispatch_semaphore_t v58 = 0LL;
  dispatch_semaphore_t v58 = dispatch_semaphore_create(0LL);
  uint64_t v49 = 0LL;
  __int128 v50 = &v49;
  uint64_t v51 = 0x2020000000LL;
  uint64_t v52 = 0LL;
  uint64_t v42 = 0LL;
  uint64_t v43 = (std::string *)&v42;
  uint64_t v44 = 0x4812000000LL;
  uint64_t v45 = __Block_byref_object_copy__263;
  uint64_t v46 = __Block_byref_object_dispose__264;
  __int128 v47 = 0u;
  __int128 v48 = 0u;
  uint64_t v38 = 0LL;
  size_t v39 = &v38;
  uint64_t v40 = 0x2020000000LL;
  int v41 = 0;
  uint64_t v11 = (const char *)[a1 UTF8String];
  if (v11) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = "<Unknown Bundle ID>";
  }
  id v13 = [a2 description];
  if (DNBLogEnabled())
  {
    uint64_t v14 = getpid();
    [v13 UTF8String];
    _DNBLog( 0LL,  (uint64_t)"[LaunchAttach] START (%d) templated *Board launcher: app lunch request for '%s' - options:\n%s",  v15,  v16,  v17,  v18,  v19,  v20,  v14);
  }

  v36[0] = _NSConcreteStackBlock;
  v36[1] = 3254779904LL;
  v36[2] = ___ZL37CallBoardSystemServiceOpenApplicationI16FBSSystemService27FBSOpenApplicationErrorCodeLS1_0EXadL_ZL11SetFBSErrorlNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEER8DNBErrorEEEbP8NSStringP12NSDictionarySA_Pi_block_invoke;
  v36[3] = &__block_descriptor_89_e8_32o40o48r56r64r72r_e17_v16__0__NSError_8l;
  BOOL v37 = a4 != 0LL;
  v36[6] = &v49;
  v36[7] = &v38;
  v36[4] = a1;
  void v36[5] = v9;
  v36[8] = &v42;
  v36[9] = &v53;
  v36[10] = v12;
  [v9 openApplication:a1 options:a2 clientPort:v10 withResult:v36];
  dispatch_time_t v21 = dispatch_time(0LL, 30000000000LL);
  uint64_t v22 = dispatch_semaphore_wait((dispatch_semaphore_t)v54[5], v21);
  dispatch_release((dispatch_object_t)v54[5]);
  if (DNBLogEnabled())
  {
    uint64_t v23 = getpid();
    _DNBLog( 0LL,  (uint64_t)"[LaunchAttach] END (%d) templated *Board launcher finished app lunch request for '%s'",  v24,  v25,  v26,  v27,  v28,  v29,  v23);
  }

  if (v22)
  {
    if (DNBLogEnabled())
    {
      pid_t v30 = getpid();
      _DNBLogError("[LaunchAttach] END (%d) timed out trying to send openApplication to %s.", v30, v12);
    }

    *(void *)a3 = 111LL;
    if (*(char *)(a3 + 31) < 0)
    {
      **(_BYTE **)(a3 + 8) = 0;
      *(void *)(a3 + 16) = 0LL;
    }

    else
    {
      *(_BYTE *)(a3 + 8) = 0;
      *(_BYTE *)(a3 + 31) = 0;
    }

    std::string::assign((std::string *)(a3 + 8), "timed out trying to launch app");
  }

  else
  {
    uint64_t v31 = v50[3];
    if (!v31)
    {
      if (a4)
      {
        *a4 = *((_DWORD *)v39 + 6);
        if (DNBLogEnabledForAny(2)) {
          _DNBLogThreaded("Out of completion handler, pid from block %d and passing out: %d", *((_DWORD *)v39 + 6), *a4);
        }
      }

      uint64_t v32 = 1LL;
      goto LABEL_21;
    }

    else {
      std::string v35 = v43[2];
    }
    SetFBSError(v31, &v35, a3);
    if (DNBLogEnabled())
    {
      pid_t v34 = getpid();
      _DNBLogError( "[LaunchAttach] END (%d) unable to launch the application with CFBundleIdentifier '%s' bks_error = %ld",  v34,  v12,  v50[3]);
    }
  }

  uint64_t v32 = 0LL;
LABEL_21:
  _Block_object_dispose(&v38, 8);
  _Block_object_dispose(&v42, 8);
  if (SHIBYTE(v48) < 0) {
    operator delete(*((void **)&v47 + 1));
  }
  _Block_object_dispose(&v49, 8);
  _Block_object_dispose(&v53, 8);
  return v32;
}

void sub_1000446F0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31, uint64_t a32, uint64_t a33, uint64_t a34, char a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, void *a41, uint64_t a42, int a43, __int16 a44, char a45, char a46)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose(&a35, 8);
  if (a46 < 0) {
    operator delete(a41);
  }
  _Block_object_dispose((const void *)(v46 - 176), 8);
  _Block_object_dispose((const void *)(v46 - 144), 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZL37CallBoardSystemServiceOpenApplicationI16FBSSystemService27FBSOpenApplicationErrorCodeLS1_0EXadL_ZL11SetFBSErrorlNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEER8DNBErrorEEEbP8NSStringP12NSDictionarySA_Pi_block_invoke( uint64_t a1, void *a2)
{
  if (a2) {
    *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = [a2 code];
  }
  if (*(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL))
  {
    unint64_t v4 = (const std::string::value_type *)objc_msgSend(objc_msgSend(a2, "localizedDescription"), "UTF8String");
    if (v4)
    {
      std::string::assign((std::string *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 48LL), v4);
      if (DNBLogEnabled())
      {
        pid_t v5 = getpid();
        _DNBLogError("[LaunchAttach] END (%d) In app launch attempt, got error localizedDescription '%s'.", v5, v4);
      }

      uint64_t v6 = -[NSString UTF8String]( +[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%@", a2),  "UTF8String");
      if (DNBLogEnabled())
      {
        pid_t v7 = getpid();
        _DNBLogError( "[LaunchAttach] END (%d) In app launch attempt, got error NSError object description: '%s'.",  v7,  v6);
      }
    }

    if (DNBLogEnabledForAny(2))
    {
      id v8 = "<unknown error>";
      if (v4) {
        id v8 = v4;
      }
      _DNBLogThreaded( "In completion handler for send event, got error %s(%ld).",  v8,  *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL));
    }
  }

  else if (*(_BYTE *)(a1 + 88))
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = [*(id *)(a1 + 40) pidForApplication:*(void *)(a1 + 32)];
    if (DNBLogEnabled()) {
      _DNBLog( 0LL,  (uint64_t)"[LaunchAttach] In completion handler, got pid for bundle id '%s', pid: %d.",  v9,  v10,  v11,  v12,  v13,  v14,  *(void *)(a1 + 80));
    }
  }

  else if (DNBLogEnabled())
  {
    _DNBLog( 0LL,  (uint64_t)"[LaunchAttach] In completion handler, launch was successful, debugserver did not ask for the pid",  v15,  v16,  v17,  v18,  v19,  v20,  v22);
  }

  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 40LL));
}

void SplitEventData(char *__s, uint64_t a2)
{
  unint64_t v4 = *(void ***)a2;
  for (uint64_t i = *(void ***)(a2 + 8); i != v4; i -= 3)
  {
  }

  *(void *)(a2 + 8) = v4;
  if (!__s || !*__s) {
    return;
  }
  while (1)
  {
    pid_t v7 = strchr(__s, 58);
    if (!v7) {
      break;
    }
    id v8 = v7;
    size_t v9 = v7 - __s;
    if (v7 != __s)
    {
      if (v9 > 0x7FFFFFFFFFFFFFF7LL) {
        goto LABEL_35;
      }
      if (v9 >= 0x17)
      {
        uint64_t v11 = (v9 & 0xFFFFFFFFFFFFFFF8LL) + 8;
        if ((v9 | 7) != 0x17) {
          uint64_t v11 = v9 | 7;
        }
        uint64_t v12 = v11 + 1;
        p_dst = (__int128 *)operator new(v11 + 1);
        *((void *)&__dst + 1) = v9;
        unint64_t v26 = v12 | 0x8000000000000000LL;
        *(void *)&__int128 __dst = p_dst;
      }

      else
      {
        HIBYTE(v26) = (_BYTE)v7 - (_BYTE)__s;
        p_dst = &__dst;
      }

      memmove(p_dst, __s, v9);
      *((_BYTE *)p_dst + v9) = 0;
      unint64_t v13 = *(void *)(a2 + 8);
      if (v13 < *(void *)(a2 + 16))
      {
        __int128 v6 = __dst;
        *(void *)(v13 + 16) = v26;
        *(_OWORD *)unint64_t v13 = v6;
        *(void *)(a2 + 8) = v13 + 24;
      }

      else
      {
        uint64_t v14 = std::vector<std::string>::__push_back_slow_path<std::string>((void **)a2, (uint64_t)&__dst);
        int v15 = SHIBYTE(v26);
        *(void *)(a2 + 8) = v14;
        if (v15 < 0) {
          operator delete((void *)__dst);
        }
      }
    }

    std::string __s = v8 + 1;
    if (!v8[1]) {
      return;
    }
  }

  size_t v16 = strlen(__s);
  if (v16 > 0x7FFFFFFFFFFFFFF7LL) {
LABEL_35:
  }
    std::string::__throw_length_error[abi:ne180100]();
  size_t v17 = v16;
  if (v16 >= 0x17)
  {
    uint64_t v19 = (v16 & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((v16 | 7) != 0x17) {
      uint64_t v19 = v16 | 7;
    }
    uint64_t v20 = v19 + 1;
    uint64_t v18 = (__int128 *)operator new(v19 + 1);
    *((void *)&__dst + 1) = v17;
    unint64_t v26 = v20 | 0x8000000000000000LL;
    *(void *)&__int128 __dst = v18;
    goto LABEL_29;
  }

  HIBYTE(v26) = v16;
  uint64_t v18 = &__dst;
  if (v16) {
LABEL_29:
  }
    memmove(v18, __s, v17);
  *((_BYTE *)v18 + v17) = 0;
  unint64_t v21 = *(void *)(a2 + 8);
  if (v21 >= *(void *)(a2 + 16))
  {
    uint64_t v23 = std::vector<std::string>::__push_back_slow_path<std::string>((void **)a2, (uint64_t)&__dst);
    int v24 = SHIBYTE(v26);
    *(void *)(a2 + 8) = v23;
    if (v24 < 0) {
      operator delete((void *)__dst);
    }
  }

  else
  {
    __int128 v22 = __dst;
    *(void *)(v21 + 16) = v26;
    *(_OWORD *)unint64_t v21 = v22;
    *(void *)(a2 + 8) = v21 + 24;
  }

void sub_100044AEC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<MachProcess::mach_o_segment>::__push_back_slow_path<MachProcess::mach_o_segment const&>( char **a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = a1[1];
  uint64_t v5 = 0x2E8BA2E8BA2E8BA3LL * ((v4 - *a1) >> 3);
  unint64_t v6 = v5 + 1;
  if (0x5D1745D1745D1746LL * ((a1[2] - v3) >> 3) > v6) {
    unint64_t v6 = 0x5D1745D1745D1746LL * ((a1[2] - v3) >> 3);
  }
  else {
    unint64_t v8 = v6;
  }
  if (v8)
  {
    if (v8 > 0x2E8BA2E8BA2E8BALL) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    size_t v9 = (char *)operator new(88 * v8);
  }

  else
  {
    size_t v9 = 0LL;
  }

  uint64_t v10 = (std::string *)&v9[88 * v5];
  uint64_t v20 = &v9[88 * v8];
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v10, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
    uint64_t v3 = *a1;
    unint64_t v4 = a1[1];
    uint64_t v10 = (std::string *)&v9[88 * v5];
  }

  else
  {
    *(_OWORD *)&v10->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    v10->__r_.__value_.__l.__cap_ = *(void *)(a2 + 16);
  }

  uint64_t v11 = &v9[88 * v5];
  *(_OWORD *)(v11 + 24) = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(v11 + 40) = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(v11 + 56) = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(v11 + 72) = *(_OWORD *)(a2 + 72);
  uint64_t v12 = v11 + 88;
  if (v4 == v3)
  {
    size_t v17 = v3;
  }

  else
  {
    do
    {
      __int128 v13 = *(_OWORD *)(v4 - 88);
      v10[-3].__r_.__value_.__r.__words[0] = *((void *)v4 - 9);
      *(_OWORD *)&v10[-4].__r_.__value_.__r.__words[1] = v13;
      *((void *)v4 - 10) = 0LL;
      *((void *)v4 - 9) = 0LL;
      *((void *)v4 - 11) = 0LL;
      __int128 v14 = *((_OWORD *)v4 - 4);
      __int128 v15 = *((_OWORD *)v4 - 3);
      __int128 v16 = *((_OWORD *)v4 - 1);
      *(_OWORD *)&v10[-2].__r_.__value_.__r.__words[2] = *((_OWORD *)v4 - 2);
      *(_OWORD *)&v10[-1].__r_.__value_.__r.__words[1] = v16;
      *(_OWORD *)&v10[-3].__r_.__value_.__r.__words[1] = v14;
      *(_OWORD *)&v10[-2].__r_.__value_.__l.__data_ = v15;
      uint64_t v10 = (std::string *)((char *)v10 - 88);
      v4 -= 88;
    }

    while (v4 != v3);
    size_t v17 = *a1;
    uint64_t v3 = a1[1];
  }

  *a1 = (char *)v10;
  a1[1] = v12;
  a1[2] = v20;
  if (v3 != v17)
  {
    uint64_t v18 = (void **)(v3 - 88);
    do
    {
      v18 -= 11;
    }

    while (v18 + 11 != (void **)v17);
    uint64_t v3 = v17;
  }

  if (v3) {
    operator delete(v3);
  }
  return v12;
}

void sub_100044D18(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t std::__split_buffer<MachProcess::mach_o_segment>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void ***)(a1 + 8);
  size_t v2 = *(void ***)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      uint64_t v5 = v2 - 11;
      *(void *)(a1 + 16) = v2 - 11;
      if (*((char *)v2 - 65) < 0)
      {
        operator delete(*v5);
        uint64_t v5 = *(void ***)(a1 + 16);
      }

      size_t v2 = v5;
    }

    while (v5 != v3);
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *std::shared_ptr<JSONGenerator::Array>::shared_ptr[abi:ne180100]<JSONGenerator::Array,void>( void *a1, uint64_t a2)
{
  *a1 = a2;
  unint64_t v4 = (std::__shared_weak_count *)operator new(0x20uLL);
  v4->__shared_owners_ = 0LL;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  v4->__vftable = (std::__shared_weak_count_vtbl *)off_100060F70;
  v4->__shared_weak_owners_ = 0LL;
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)a2;
  a1[1] = v4;
  if (a2)
  {
    unint64_t v6 = *(std::__shared_weak_count **)(a2 + 16);
    if (v6)
    {
      if (v6->__shared_owners_ != -1) {
        return a1;
      }
      do
        unint64_t v7 = __ldxr(p_shared_owners);
      while (__stxr(v7 + 1, p_shared_owners));
      p_shared_weak_owners = (unint64_t *)&v4->__shared_weak_owners_;
      do
        unint64_t v9 = __ldxr(p_shared_weak_owners);
      while (__stxr(v9 + 1, p_shared_weak_owners));
      *(void *)(a2 + 8) = a2;
      *(void *)(a2 + 16) = v4;
      std::__shared_weak_count::__release_weak(v6);
    }

    else
    {
      do
        unint64_t v10 = __ldxr(p_shared_owners);
      while (__stxr(v10 + 1, p_shared_owners));
      uint64_t v11 = (unint64_t *)&v4->__shared_weak_owners_;
      do
        unint64_t v12 = __ldxr(v11);
      while (__stxr(v12 + 1, v11));
      *(void *)(a2 + 8) = a2;
      *(void *)(a2 + 16) = v4;
    }

    do
      unint64_t v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

  return a1;
}

void sub_100044E88(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

void *std::shared_ptr<JSONGenerator::Dictionary>::shared_ptr[abi:ne180100]<JSONGenerator::Dictionary,void>( void *a1, uint64_t a2)
{
  *a1 = a2;
  unint64_t v4 = (std::__shared_weak_count *)operator new(0x20uLL);
  v4->__shared_owners_ = 0LL;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  v4->__vftable = (std::__shared_weak_count_vtbl *)off_100060F38;
  v4->__shared_weak_owners_ = 0LL;
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)a2;
  a1[1] = v4;
  if (a2)
  {
    unint64_t v6 = *(std::__shared_weak_count **)(a2 + 16);
    if (v6)
    {
      if (v6->__shared_owners_ != -1) {
        return a1;
      }
      do
        unint64_t v7 = __ldxr(p_shared_owners);
      while (__stxr(v7 + 1, p_shared_owners));
      p_shared_weak_owners = (unint64_t *)&v4->__shared_weak_owners_;
      do
        unint64_t v9 = __ldxr(p_shared_weak_owners);
      while (__stxr(v9 + 1, p_shared_weak_owners));
      *(void *)(a2 + 8) = a2;
      *(void *)(a2 + 16) = v4;
      std::__shared_weak_count::__release_weak(v6);
    }

    else
    {
      do
        unint64_t v10 = __ldxr(p_shared_owners);
      while (__stxr(v10 + 1, p_shared_owners));
      uint64_t v11 = (unint64_t *)&v4->__shared_weak_owners_;
      do
        unint64_t v12 = __ldxr(v11);
      while (__stxr(v12 + 1, v11));
      *(void *)(a2 + 8) = a2;
      *(void *)(a2 + 16) = v4;
    }

    do
      unint64_t v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

  return a1;
}

void sub_100044FA0(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<MachProcess::binary_image_information>::__push_back_slow_path<MachProcess::binary_image_information const&>( void **a1, uint64_t a2)
{
  unint64_t v3 = 0xCCCCCCCCCCCCCCCDLL * (((_BYTE *)a1[1] - (_BYTE *)*a1) >> 5);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0x199999999999999LL) {
    std::vector<kevent>::__throw_length_error[abi:ne180100]();
  }
  if (0x999999999999999ALL * (((_BYTE *)a1[2] - (_BYTE *)*a1) >> 5) > v4) {
    unint64_t v4 = 0x999999999999999ALL * (((_BYTE *)a1[2] - (_BYTE *)*a1) >> 5);
  }
  if (0xCCCCCCCCCCCCCCCDLL * (((_BYTE *)a1[2] - (_BYTE *)*a1) >> 5) >= 0xCCCCCCCCCCCCCCLL) {
    unint64_t v6 = 0x199999999999999LL;
  }
  else {
    unint64_t v6 = v4;
  }
  uint64_t v27 = (uint64_t)(a1 + 2);
  if (v6)
  {
    if (v6 > 0x199999999999999LL) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    unint64_t v7 = operator new(160 * v6);
  }

  else
  {
    unint64_t v7 = 0LL;
  }

  unint64_t v8 = &v7[160 * v3];
  int v24 = v8;
  unint64_t v26 = &v7[160 * v6];
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external( (std::string *)&v7[160 * v3],  *(const std::string::value_type **)a2,  *(void *)(a2 + 8));
  }

  else
  {
    *(_OWORD *)unint64_t v8 = *(_OWORD *)a2;
    *((void *)v8 + 2) = *(void *)(a2 + 16);
  }

  unint64_t v9 = &v7[160 * v3];
  *((void *)v9 + 3) = *(void *)(a2 + 24);
  MachProcess::mach_o_information::mach_o_information((uint64_t)(v9 + 32), a2 + 32);
  v7[160 * v3 + 152] = *(_BYTE *)(a2 + 152);
  unint64_t v10 = &v7[160 * v3];
  uint64_t v25 = v10;
  uint64_t v11 = (char *)*a1;
  unint64_t v12 = (char *)a1[1];
  if (v12 == *a1)
  {
    __int128 v22 = (char *)a1[1];
  }

  else
  {
    uint64_t v13 = 0LL;
    do
    {
      __int128 v14 = &v12[v13];
      __int128 v15 = *(_OWORD *)&v12[v13 - 160];
      __int128 v16 = &v8[v13];
      *((void *)v16 - 18) = *(void *)&v12[v13 - 144];
      *((_OWORD *)v16 - 10) = v15;
      *((void *)v14 - 19) = 0LL;
      *((void *)v14 - 18) = 0LL;
      uint64_t v17 = *(void *)&v12[v13 - 136];
      *((void *)v14 - 20) = 0LL;
      *((void *)v16 - 17) = v17;
      __int128 v18 = *(_OWORD *)&v12[v13 - 128];
      __int128 v19 = *(_OWORD *)&v12[v13 - 112];
      *((void *)v16 - 11) = 0LL;
      *((void *)v16 - 10) = 0LL;
      *((_OWORD *)v16 - 8) = v18;
      *((_OWORD *)v16 - 7) = v19;
      *((void *)v16 - 12) = 0LL;
      *((_OWORD *)v16 - 6) = *(_OWORD *)&v12[v13 - 96];
      *((void *)v16 - 10) = *(void *)&v12[v13 - 80];
      *((void *)v14 - 12) = 0LL;
      *((void *)v14 - 11) = 0LL;
      *((void *)v14 - 10) = 0LL;
      *(_OWORD *)(v16 - 72) = *(_OWORD *)&v12[v13 - 72];
      __int128 v20 = *(_OWORD *)&v12[v13 - 56];
      *((void *)v16 - 5) = *(void *)&v12[v13 - 40];
      *(_OWORD *)(v16 - 56) = v20;
      *((void *)v14 - 6) = 0LL;
      *((void *)v14 - 5) = 0LL;
      *((void *)v14 - 7) = 0LL;
      __int128 v21 = *(_OWORD *)&v12[v13 - 32];
      *((void *)v16 - 2) = *(void *)&v12[v13 - 16];
      *((_OWORD *)v16 - 2) = v21;
      *((void *)v14 - 3) = 0LL;
      *((void *)v14 - 2) = 0LL;
      *((void *)v14 - 4) = 0LL;
      *(v16 - 8) = v12[v13 - 8];
      v13 -= 160LL;
    }

    while (&v12[v13] != v11);
    __int128 v22 = (char *)*a1;
    unint64_t v12 = (char *)a1[1];
    unint64_t v10 = &v24[v13];
  }

  *a1 = v10;
  a1[1] = v25 + 160;
  a1[2] = v26;
  if (v12 != v22)
  {
    do
    {
      v12 -= 160;
      std::allocator<MachProcess::binary_image_information>::destroy[abi:ne180100](v27, (uint64_t)v12);
    }

    while (v12 != v22);
    unint64_t v12 = v22;
  }

  if (v12) {
    operator delete(v12);
  }
  return v25 + 160;
}

void sub_1000451FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t MachProcess::mach_o_information::mach_o_information(uint64_t a1, uint64_t a2)
{
  __int128 v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  *(void *)(a1 + memset(__p, 0, 32) = 0LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 48) = 0LL;
  std::vector<MachProcess::mach_o_segment>::__init_with_size[abi:ne180100]<MachProcess::mach_o_segment*,MachProcess::mach_o_segment*>( (void *)(a1 + 32),  *(void *)(a2 + 32),  *(void *)(a2 + 40),  0x2E8BA2E8BA2E8BA3LL * ((uint64_t)(*(void *)(a2 + 40) - *(void *)(a2 + 32)) >> 3));
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  if (*(char *)(a2 + 95) < 0)
  {
    std::string::__init_copy_ctor_external( (std::string *)(a1 + 72),  *(const std::string::value_type **)(a2 + 72),  *(void *)(a2 + 80));
  }

  else
  {
    __int128 v5 = *(_OWORD *)(a2 + 72);
    *(void *)(a1 + 88) = *(void *)(a2 + 88);
    *(_OWORD *)(a1 + 72) = v5;
  }

  unint64_t v6 = (std::string *)(a1 + 96);
  if (*(char *)(a2 + 119) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)(a2 + 96), *(void *)(a2 + 104));
  }

  else
  {
    __int128 v7 = *(_OWORD *)(a2 + 96);
    *(void *)(a1 + 112) = *(void *)(a2 + 112);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }

  return a1;
}

void sub_100045300(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 95) < 0)
  {
    operator delete(*v3);
    __int128 v5 = (void **)*v2;
    if (!*v2) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }

  else
  {
    __int128 v5 = (void **)*v2;
    if (!*v2) {
      goto LABEL_3;
    }
  }

  unint64_t v6 = *(void ***)(v1 + 40);
  __int128 v7 = v5;
  if (v6 != v5)
  {
    do
    {
      v6 -= 11;
    }

    while (v6 != v5);
    __int128 v7 = *v2;
  }

  *(void *)(v1 + 40) = v5;
  operator delete(v7);
  _Unwind_Resume(exception_object);
}

void std::vector<MachProcess::mach_o_segment>::__init_with_size[abi:ne180100]<MachProcess::mach_o_segment*,MachProcess::mach_o_segment*>( void *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >= 0x2E8BA2E8BA2E8BBLL) {
      std::vector<kevent>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v8 = (char *)operator new(88 * a4);
    *a1 = v8;
    a1[1] = v8;
    a1[2] = &v8[88 * a4];
    if (a2 != a3)
    {
      uint64_t v9 = 0LL;
      do
      {
        uint64_t v11 = (std::string *)&v8[v9];
        uint64_t v12 = a2 + v9;
        if (*(char *)(a2 + v9 + 23) < 0)
        {
          std::string::__init_copy_ctor_external(v11, *(const std::string::value_type **)v12, *(void *)(v12 + 8));
        }

        else
        {
          *(_OWORD *)&v11->__r_.__value_.__l.__data_ = *(_OWORD *)v12;
          v11->__r_.__value_.__l.__cap_ = *(void *)(v12 + 16);
        }

        unint64_t v10 = &v8[v9];
        *(_OWORD *)(v10 + 24) = *(_OWORD *)(a2 + v9 + 24);
        *(_OWORD *)(v10 + 40) = *(_OWORD *)(a2 + v9 + 40);
        *(_OWORD *)(v10 + 56) = *(_OWORD *)(a2 + v9 + 56);
        *(_OWORD *)(v10 + 72) = *(_OWORD *)(a2 + v9 + 72);
        v9 += 88LL;
      }

      while (a2 + v9 != a3);
      v8 += v9;
    }

    a1[1] = v8;
  }

void sub_100045490( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void ***std::__exception_guard_exceptions<std::vector<MachProcess::mach_o_segment>::__destroy_vector>::~__exception_guard_exceptions[abi:ne180100]( void ***a1)
{
  if (!*((_BYTE *)a1 + 8))
  {
    size_t v2 = *a1;
    unint64_t v3 = (void **)**a1;
    if (v3)
    {
      __int128 v4 = (void **)v2[1];
      __int128 v5 = **a1;
      if (v4 != v3)
      {
        do
        {
          v4 -= 11;
        }

        while (v4 != v3);
        __int128 v5 = **a1;
      }

      v2[1] = v3;
      operator delete(v5);
    }
  }

  return a1;
}

uint64_t std::__split_buffer<MachProcess::binary_image_information>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = *(void *)(a1 + 32);
    *(void *)(a1 + 16) = i - 160;
    std::allocator<MachProcess::binary_image_information>::destroy[abi:ne180100](v4, i - 160);
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::allocator<MachProcess::binary_image_information>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 151) < 0)
  {
    operator delete(*(void **)(a2 + 128));
    if ((*(char *)(a2 + 127) & 0x80000000) == 0)
    {
LABEL_3:
      uint64_t v3 = *(void ***)(a2 + 64);
      if (!v3) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }

  else if ((*(char *)(a2 + 127) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }

  operator delete(*(void **)(a2 + 104));
  uint64_t v3 = *(void ***)(a2 + 64);
  if (!v3)
  {
LABEL_4:
LABEL_15:
    operator delete(*(void **)a2);
    return;
  }

void *std::vector<MachException::Message>::__push_back_slow_path<MachException::Message const&>( void **a1, void *a2)
{
  uint64_t v4 = (char *)*a1;
  uint64_t v3 = (char *)a1[1];
  uint64_t v5 = 0x77A9AF922545A3CDLL * ((v3 - (_BYTE *)*a1) >> 3);
  unint64_t v6 = v5 + 1;
  if (0xEF535F244A8B479ALL * (((_BYTE *)a1[2] - v4) >> 3) > v6) {
    unint64_t v6 = 0xEF535F244A8B479ALL * (((_BYTE *)a1[2] - v4) >> 3);
  }
  else {
    unint64_t v8 = v6;
  }
  if (v8)
  {
    if (v8 > 0x1F6310ACA0DBB5LL) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    uint64_t v9 = (char *)operator new(2088 * v8);
  }

  else
  {
    uint64_t v9 = 0LL;
  }

  unint64_t v10 = &v9[2088 * v5];
  uint64_t v11 = &v9[2088 * v8];
  memcpy(v10, a2, 0x80CuLL);
  *((void *)v10 + 258) = 0LL;
  *((void *)v10 + 260) = 0LL;
  *((void *)v10 + 259) = 0LL;
  uint64_t v12 = (_BYTE *)a2[258];
  uint64_t v13 = (_BYTE *)a2[259];
  int64_t v14 = v13 - v12;
  if (v13 != v12)
  {
    __int128 v15 = (char **)(v10 + 2072);
    if (v14 < 0) {
      std::vector<kevent>::__throw_length_error[abi:ne180100]();
    }
    __int128 v16 = (char *)operator new(v13 - v12);
    *((void *)v10 + 258) = v16;
    const char *v15 = v16;
    uint64_t v17 = &v16[8 * (v14 >> 3)];
    *((void *)v10 + 260) = v17;
    memcpy(v16, v12, v14);
    const char *v15 = v17;
  }

  __int128 v18 = v10 + 2088;
  unint64_t v26 = v10 + 2088;
  if (v3 == v4)
  {
    uint64_t v23 = v3;
  }

  else
  {
    uint64_t v19 = 0LL;
    do
    {
      __int128 v20 = &v10[v19];
      __int128 v21 = &v3[v19];
      memcpy(&v10[v19 - 2088], &v3[v19 - 2088], 0x800uLL);
      int v22 = *(_DWORD *)&v3[v19 - 32];
      *((void *)v20 - 5) = *(void *)&v3[v19 - 40];
      *((_DWORD *)v20 - 8) = v22;
      *((void *)v20 - 2) = 0LL;
      *((void *)v20 - 1) = 0LL;
      *(_OWORD *)(v20 - 24) = *(_OWORD *)&v3[v19 - 24];
      *((void *)v20 - 1) = *(void *)&v3[v19 - 8];
      *((void *)v21 - 3) = 0LL;
      *((void *)v21 - 2) = 0LL;
      *((void *)v21 - 1) = 0LL;
      v19 -= 2088LL;
    }

    while (&v3[v19] != v4);
    uint64_t v23 = (char *)*a1;
    uint64_t v3 = (char *)a1[1];
    v10 += v19;
    __int128 v18 = v26;
  }

  *a1 = v10;
  a1[1] = v18;
  a1[2] = v11;
  if (v3 == v23)
  {
    if (v3) {
LABEL_21:
    }
      operator delete(v3);
  }

  else
  {
    do
    {
      uint64_t v25 = (void *)*((void *)v3 - 3);
      if (v25)
      {
        *((void *)v3 - 2) = v25;
        operator delete(v25);
      }

      v3 -= 2088;
    }

    while (v3 != v23);
    uint64_t v3 = v23;
    if (v23) {
      goto LABEL_21;
    }
  }

  return v18;
}

void sub_1000458B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v5 = *v2;
  if (*v2)
  {
    *uint64_t v3 = v5;
    operator delete(v5);
  }

  std::__split_buffer<MachException::Message>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<MachException::Message>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      while (1)
      {
        uint64_t v4 = v2 - 2088;
        *(void *)(a1 + 16) = v2 - 2088;
        uint64_t v5 = *(void **)(v2 - 24);
        if (!v5) {
          break;
        }
        *(void *)(v2 - 16) = v5;
        operator delete(v5);
        uint64_t v2 = *(void *)(a1 + 16);
        if (v2 == v3) {
          goto LABEL_6;
        }
      }

      v2 -= 2088LL;
    }

    while (v4 != v3);
  }

void MachTask::MachTask(MachTask *this, MachProcess *a2)
{
  *(void *)this = off_100061578;
  *((void *)this + 1) = a2;
  *((_DWORD *)this + 4) = 0;
  MachVMMemory::MachVMMemory((MachTask *)((char *)this + 24));
  *((void *)this + 40) = 0LL;
  *((void *)this + 41) = 0LL;
  *(void *)((char *)this + 302) = 0LL;
  *((void *)this + 39) = (char *)this + 320;
  *((void *)this + 36) = 0LL;
  *((void *)this + 37) = 0LL;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + MachTask::Clear((void *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 17) = 0u;
}

void *MachTask::Clear(void *this)
{
  uint64_t v1 = this;
  uint64_t v2 = this + 37;
  if (this[37]) {
    this = (void *)MachTask::ShutDownExcecptionThread((MachTask *)this);
  }
  *((_DWORD *)v1 + 4) = 0;
  void *v2 = 0LL;
  *(void *)((char *)v2 + 6) = 0LL;
  return this;
}

void MachTask::~MachTask(MachTask *this)
{
  *(void *)this = off_100061578;
  if (*((void *)this + 37)) {
    MachTask::ShutDownExcecptionThread(this);
  }
  *((_DWORD *)this + 4) = 0;
  *((void *)this + 37) = 0LL;
  *(void *)((char *)this + 302) = 0LL;
  std::__tree<std::__value_type<unsigned int,DNBArchPluginInfoTag>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,DNBArchPluginInfoTag>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,DNBArchPluginInfoTag>>>::destroy( (uint64_t)this + 312,  *((void **)this + 40));
  MachVMMemory::~MachVMMemory((void **)this + 3);
}

{
  *(void *)this = off_100061578;
  if (*((void *)this + 37)) {
    MachTask::ShutDownExcecptionThread(this);
  }
  *((_DWORD *)this + 4) = 0;
  *((void *)this + 37) = 0LL;
  *(void *)((char *)this + 302) = 0LL;
  std::__tree<std::__value_type<unsigned int,DNBArchPluginInfoTag>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,DNBArchPluginInfoTag>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,DNBArchPluginInfoTag>>>::destroy( (uint64_t)this + 312,  *((void **)this + 40));
  MachVMMemory::~MachVMMemory((void **)this + 3);
  operator delete(this);
}

uint64_t MachTask::Suspend(MachTask *this)
{
  *(_OWORD *)std::string __p = 0u;
  __int128 v7 = 0u;
  task_t v1 = *((_DWORD *)this + 4);
  __p[0] = (void *)(task_suspend(v1) | 0x100000000LL);
  LOBYTE(__p[1]) = 0;
  HIBYTE(v7) = 0;
  BOOL v2 = DNBLogCheckLogBit(0x2000);
  if (LODWORD(__p[0])) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 != 1) {
    return 0LL;
  }
  DNBError::LogThreaded((DNBError *)__p, "::task_suspend(target_task = 0x%4.4x)", v1);
  uint64_t v4 = LODWORD(__p[0]);
  if (SHIBYTE(v7) < 0) {
    operator delete(__p[1]);
  }
  return v4;
}

void sub_100045B4C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MachTask::Resume(MachTask *this, uint64_t a2, task_basic_info *a3)
{
  int v3 = (MachTask *)*((unsigned int *)this + 4);
  if (!(_DWORD)v3) {
    return 4LL;
  }
  *(_OWORD *)std::string __p = 0u;
  __int128 v13 = 0u;
  LODWORD(__p[0]) = MachTask::BasicInfo(v3, task_info_out, a3);
  HIDWORD(__p[0]) = 1;
  LOBYTE(__p[1]) = 0;
  HIBYTE(vMachTask::Clear((void *)this + 13) = 0;
  if (LODWORD(__p[0])) {
    return LODWORD(__p[0]);
  }
  integer_t v6 = task_info_out[0];
  if (*((_BYTE *)this + 309) && task_info_out[0] == 2)
  {
    __p[0] = (void *)(task_resume((task_t)v3) | 0x100000000LL);
    if (SHIBYTE(v13) < 0)
    {
      *(_BYTE *)__p[1] = 0;
      *(void *)&__int128 v13 = 0LL;
    }

    else
    {
      LOBYTE(__p[1]) = 0;
      HIBYTE(vMachTask::Clear((void *)this + 13) = 0;
    }

    BOOL v7 = DNBLogCheckLogBit(0x2000);
    if (LODWORD(__p[0])) {
      int v8 = 1;
    }
    else {
      int v8 = v7;
    }
    if (v8 == 1) {
      DNBError::LogThreaded( (DNBError *)__p,  "::task_resume double-resume after exec-start-stopped(target_task = 0x%4.4x)",  (_DWORD)v3);
    }
    integer_t v6 = task_info_out[0];
  }

  *((_BYTE *)this + 309) = 0;
  if (v6 >= 1)
  {
    __p[0] = (void *)(task_resume((task_t)v3) | 0x100000000LL);
    if (SHIBYTE(v13) < 0)
    {
      *(_BYTE *)__p[1] = 0;
      *(void *)&__int128 v13 = 0LL;
    }

    else
    {
      LOBYTE(__p[1]) = 0;
      HIBYTE(vMachTask::Clear((void *)this + 13) = 0;
    }

    BOOL v9 = DNBLogCheckLogBit(0x2000);
    int v10 = LODWORD(__p[0]) || v9;
    if (v10 == 1) {
      DNBError::LogThreaded((DNBError *)__p, "::task_resume(target_task = 0x%4.4x)", (_DWORD)v3);
    }
  }

  uint64_t v5 = LODWORD(__p[0]);
  if (SHIBYTE(v13) < 0) {
    operator delete(__p[1]);
  }
  return v5;
}

void sub_100045CC8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MachTask::BasicInfo(MachTask *this, task_info_t task_info_out, task_basic_info *a3)
{
  if (!task_info_out) {
    return 4LL;
  }
  int v4 = (int)this;
  *(_OWORD *)std::string __p = 0u;
  __int128 v17 = 0u;
  mach_msg_type_number_t task_info_outCnt = 10;
  unsigned int v5 = task_info((task_name_t)this, 0x12u, task_info_out, &task_info_outCnt);
  __p[0] = (void *)(v5 | 0x100000000LL);
  LOBYTE(__p[1]) = 0;
  HIBYTE(v17) = 0;
  BOOL v6 = DNBLogCheckLogBit(0x2000);
  if (v5) {
    int v7 = 1;
  }
  else {
    int v7 = v6;
  }
  if (v7 == 1) {
    DNBError::LogThreaded( (DNBError *)__p,  "::task_info(target_task = 0x%4.4x, flavor = TASK_BASIC_INFO, task_info_out => %p, task_info_outCnt => %u)",  v4,  task_info_out,  task_info_outCnt);
  }
  if (DNBLogCheckLogBit(0x2000))
  {
    BOOL v8 = DNBLogCheckLogBit(1);
    if (!LODWORD(__p[0]) && v8)
    {
      int v10 = task_info_out[5];
      int v11 = task_info_out[6];
      if (DNBLogEnabled())
      {
        double v14 = (float)((float)((float)v11 / 1000000.0) + (float)v10);
        _DNBLogThreaded( "task_basic_info = { suspend_count = %i, virtual_std::string::size_type size = 0x%8.8llx, resident_std::string::size_type size = 0x%8.8llx, user_time = %f, s ystem_time = %f }",  *task_info_out,  *(void *)(task_info_out + 1),  *(void *)(task_info_out + 3),  v14,  v14);
      }
    }
  }

  uint64_t v12 = LODWORD(__p[0]);
  if (SHIBYTE(v17) < 0) {
    operator delete(__p[1]);
  }
  return v12;
}

void sub_100045E20( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MachTask::ShutDownExcecptionThread(MachTask *this)
{
  *(_OWORD *)std::string __p = 0u;
  __int128 v14 = 0u;
  LODWORD(__p[0]) = MachException::PortInfo::Restore((MachTask *)((char *)this + 64), *((_DWORD *)this + 4));
  HIDWORD(__p[0]) = 1;
  LOBYTE(__p[1]) = 0;
  HIBYTE(v14) = 0;
  mach_port_name_t v2 = *((_DWORD *)this + 76);
  int v3 = (_opaque_pthread_t *)*((void *)this + 37);
  *((_DWORD *)this + 76) = 0;
  __p[0] = (void *)(pthread_cancel(v3) | 0x200000000LL);
  LOBYTE(__p[1]) = 0;
  HIBYTE(v14) = 0;
  BOOL v4 = DNBLogCheckLogBit(0x2000);
  if (LODWORD(__p[0])) {
    int v5 = 1;
  }
  else {
    int v5 = v4;
  }
  if (v5 == 1) {
    DNBError::LogThreaded((DNBError *)__p, "::pthread_cancel(thread = %p)", *((const void **)this + 37));
  }
  __p[0] = (void *)(pthread_join(*((pthread_t *)this + 37), 0LL) | 0x200000000LL);
  if (SHIBYTE(v14) < 0)
  {
    *(_BYTE *)__p[1] = 0;
    *(void *)&__int128 v14 = 0LL;
  }

  else
  {
    LOBYTE(__p[1]) = 0;
    HIBYTE(v14) = 0;
  }

  BOOL v6 = DNBLogCheckLogBit(0x2000);
  if (LODWORD(__p[0])) {
    int v7 = 1;
  }
  else {
    int v7 = v6;
  }
  if (v7 == 1) {
    DNBError::LogThreaded( (DNBError *)__p,  "::pthread_join(thread = %p, value_ptr = NULL)",  *((const void **)this + 37));
  }
  mach_port_t v8 = mach_task_self_;
  __p[0] = (void *)(mach_port_deallocate(mach_task_self_, v2) | 0x100000000LL);
  if (SHIBYTE(v14) < 0)
  {
    *(_BYTE *)__p[1] = 0;
    *(void *)&__int128 v14 = 0LL;
  }

  else
  {
    LOBYTE(__p[1]) = 0;
    HIBYTE(v14) = 0;
  }

  BOOL v9 = DNBLogCheckLogBit(0x2000);
  if (LODWORD(__p[0])) {
    int v10 = 1;
  }
  else {
    int v10 = v9;
  }
  if (v10 == 1)
  {
    DNBError::LogThreaded((DNBError *)__p, "::mach_port_deallocate(task = 0x%4.4x, name = 0x%4.4x)", v8, v2);
    uint64_t v11 = LODWORD(__p[0]);
  }

  else
  {
    uint64_t v11 = 0LL;
  }

  *((_WORD *)this + 154) = 0;
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[1]);
  }
  return v11;
}

void sub_100045FE4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unint64_t MachTask::ReadMemory(MachTask *this, mach_vm_address_t a2, unint64_t a3, char *a4)
{
  task_name_t v5 = *((_DWORD *)this + 4);
  if (!v5) {
    return 0LL;
  }
  unint64_t v8 = MachVMMemory::Read((vm_size_t *)this + 3, v5, a2, a4, a3);
  if (DNBLogEnabledForAny(32)) {
    _DNBLogThreaded( "MachTask::ReadMemory(addr = 0x%8.8llx, std::string::size_type size = %llu, buf = %p) => %llu bytes read",  a2,  a3,  a4,  v8);
  }
  if (DNBLogCheckLogBit(128) || (BOOL v9 = DNBLogCheckLogBit(64), a3 <= 8) && v9)
  {
    DNBDataRef::DNBDataRef((DNBDataRef *)v11, (const unsigned __int8 *)a4, v8, 0);
    DNBDataRef::Dump(v11, 0LL, v8, a2, 0, 0x10u, 0LL);
    DNBDataRef::~DNBDataRef((DNBDataRef *)v11);
  }

  return v8;
}

void sub_1000460E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

unint64_t MachTask::WriteMemory(MachTask *this, mach_vm_address_t a2, unint64_t a3, char *a4)
{
  task_name_t v5 = *((_DWORD *)this + 4);
  if (!v5) {
    return 0LL;
  }
  unint64_t v8 = MachVMMemory::Write((vm_size_t *)this + 3, v5, a2, a4, a3);
  if (DNBLogEnabledForAny(32)) {
    _DNBLogThreaded( "MachTask::WriteMemory(addr = 0x%8.8llx, std::string::size_type size = %llu, buf = %p) => %llu bytes written",  a2,  a3,  a4,  v8);
  }
  if (DNBLogCheckLogBit(128) || (BOOL v9 = DNBLogCheckLogBit(64), a3 <= 8) && v9)
  {
    DNBDataRef::DNBDataRef((DNBDataRef *)v11, (const unsigned __int8 *)a4, v8, 0);
    DNBDataRef::Dump(v11, 0LL, v8, a2, 0, 0x10u, 0LL);
    DNBDataRef::~DNBDataRef((DNBDataRef *)v11);
  }

  return v8;
}

void sub_1000461CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t MachTask::GetMemoryRegionInfo(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  if (!(_DWORD)v4) {
    return 0xFFFFFFFFLL;
  }
  uint64_t MemoryRegionInfo = MachVMMemory::GetMemoryRegionInfo(a1 + 24, v4, a2, a3);
  if (DNBLogEnabledForAny(32)) {
    _DNBLogThreaded( "MachTask::MemoryRegionInfo(addr = 0x%8.8llx) => %i  (start = 0x%8.8llx, std::string::size_type size = 0x%8.8llx, permissions = %u)",  a2,  MemoryRegionInfo,  *(void *)a3,  *(void *)(a3 + 8),  *(_DWORD *)(a3 + 16));
  }
  return MemoryRegionInfo;
}

void MachTask::GetProfileData(uint64_t a1@<X0>, __int16 a2@<W1>, task_basic_info *a3@<X2>, void *a4@<X8>)
{
  BOOL v6 = a4;
  *a4 = 0LL;
  a4[1] = 0LL;
  a4[2] = 0LL;
  if ((a2 & 1) == 0
    || ((buffer.__darwin_time_t tv_sec = 0x1900000006LL, v149 = 4LL, MachTask::GetProfileData(DNBProfileDataScanType)::numCPU != -1)
     || !sysctl((int *)&buffer, 2u, &MachTask::GetProfileData(DNBProfileDataScanType)::numCPU, &v149, 0LL, 0LL))
    && (mach_port_t v7 = mach_host_self(),
        LODWORD(host_info_outCnt) = 4,
        !host_statistics(v7, 3, host_info_out, (mach_msg_type_number_t *)&host_info_outCnt)))
  {
    task_inspect_t v8 = *(_DWORD *)(a1 + 16);
    if (v8)
    {
      uint64_t v9 = **(unsigned int **)(a1 + 8);
      if (!MachTask::BasicInfo((MachTask *)*(unsigned int *)(a1 + 16), (task_info_t)&task_info_out, a3))
      {
        if ((a2 & 2) != 0)
        {
          uint64_t v12 = SHIDWORD(v172) + (uint64_t)SDWORD1(v172);
          int v13 = v173 + DWORD2(v172);
          if ((int)v173 + DWORD2(v172) > 999999)
          {
            int v13 = v173 + DWORD2(v172) - 1000000;
            ++v12;
          }

          uint64_t v11 = 1000000 * v12 + v13;
          if (gettimeofday(&buffer, 0LL)) {
            __darwin_time_t v10 = 0LL;
          }
          else {
            __darwin_time_t v10 = buffer.tv_usec + 1000000 * buffer.tv_sec;
          }
        }

        else
        {
          __darwin_time_t v10 = 0LL;
          uint64_t v11 = 0LL;
        }

        uint64_t v169 = 0LL;
        __int128 v168 = 0LL;
        char v170 = 0LL;
        std::string v166 = 0LL;
        std::string v165 = 0LL;
        unint64_t v167 = 0LL;
        char v163 = 0LL;
        uint64_t v162 = 0LL;
        __int128 v164 = 0LL;
        unsigned int pid = v9;
        if ((a2 & 4) != 0)
        {
          thread_act_array_t act_list = 0LL;
          act_listCnt[0] = 0;
          if (!task_threads(v8, &act_list, act_listCnt))
          {
            if (act_listCnt[0])
            {
              __darwin_time_t v137 = v10;
              uint64_t v138 = v11;
              task_inspect_t v139 = v8;
              unint64_t v144 = 0LL;
              __int128 v146 = 0LL;
              std::string v148 = 0LL;
              uint64_t v14 = 0LL;
              std::string v141 = v6;
              while (1)
              {
                thread_info_outCnt[0] = 6;
                if (thread_info(act_list[v14], 4u, (thread_info_t)&host_info_outCnt, thread_info_outCnt)) {
                  goto LABEL_22;
                }
                thread_info_outCnt[0] = 10;
                if (thread_info(act_list[v14], 3u, (thread_info_t)&v149, thread_info_outCnt)) {
                  goto LABEL_22;
                }
                if ((BYTE4(v150.__binp_) & 2) == 0) {
                  break;
                }
LABEL_21:
                mach_port_deallocate(mach_task_self_, act_list[v14]);
LABEL_22:
                if (++v14 >= (unint64_t)act_listCnt[0])
                {
                  mach_vm_size_t v75 = 4LL * act_listCnt[0];
                  BOOL v6 = v141;
                  uint64_t v9 = pid;
                  task_inspect_t v8 = v139;
                  __darwin_time_t v10 = v137;
                  uint64_t v11 = v138;
                  goto LABEL_107;
                }
              }

              uint64_t GloballyUniqueThreadIDForMachPortID = MachThread::GetGloballyUniqueThreadIDForMachPortID((MachThread *)act_list[v14]);
              uint64_t v17 = GloballyUniqueThreadIDForMachPortID;
              __int128 v18 = v169;
              if (v169 < v170)
              {
                uint64_t *v169 = GloballyUniqueThreadIDForMachPortID;
                uint64_t v19 = v18 + 1;
                int v20 = pid;
                goto LABEL_49;
              }

              __int128 v21 = (uint64_t *)v168;
              int64_t v22 = (char *)v169 - (_BYTE *)v168;
              uint64_t v23 = ((char *)v169 - (_BYTE *)v168) >> 3;
              unint64_t v24 = v23 + 1;
              uint64_t v25 = (char *)v170 - (_BYTE *)v168;
              else {
                unint64_t v26 = v24;
              }
              if (v26)
              {
                if (v26 >> 61) {
                  goto LABEL_172;
                }
                uint64_t v27 = (char *)operator new(8 * v26);
              }

              else
              {
                uint64_t v27 = 0LL;
              }

              uint64_t v28 = (uint64_t *)&v27[8 * v23];
              *uint64_t v28 = v17;
              uint64_t v19 = v28 + 1;
              if (v18 == v21)
              {
                int v20 = pid;
                goto LABEL_47;
              }

              unint64_t v29 = (char *)v18 - (char *)v21 - 8;
              if (v29 >= 0x58)
              {
                unint64_t v30 = (char *)v18 - v27 - v22;
                int v20 = pid;
                if (v30 >= 0x20)
                {
                  uint64_t v31 = (v29 >> 3) + 1;
                  uint64_t v32 = 8 * (v31 & 0x3FFFFFFFFFFFFFFCLL);
                  uint64_t v33 = &v18[v32 / 0xFFFFFFFFFFFFFFF8LL];
                  uint64_t v28 = (uint64_t *)((char *)v28 - v32);
                  pid_t v34 = &v27[8 * v23 - 16];
                  std::string v35 = v18 - 2;
                  uint64_t v36 = v31 & 0x3FFFFFFFFFFFFFFCLL;
                  do
                  {
                    __int128 v37 = *(_OWORD *)v35;
                    *((_OWORD *)v34 - 1) = *((_OWORD *)v35 - 1);
                    *(_OWORD *)pid_t v34 = v37;
                    v34 -= 32;
                    v35 -= 4;
                    v36 -= 4LL;
                  }

                  while (v36);
                  __int128 v18 = v33;
                  if (v31 == (v31 & 0x3FFFFFFFFFFFFFFCLL))
                  {
LABEL_47:
                    __int128 v168 = v28;
                    char v170 = (uint64_t *)&v27[8 * v26];
                    if (v21) {
                      operator delete(v21);
                    }
LABEL_49:
                    uint64_t v169 = v19;
                    if ((a2 & 8) != 0 && arg)
                    {
                      if (proc_pidinfo(v20, 5, arg, &buffer, 112) && LOBYTE(v180[0]))
                      {
                        size_t v39 = strlen((const char *)v180);
                        if (v39 >= 0x7FFFFFFFFFFFFFF8LL) {
                          std::string::__throw_length_error[abi:ne180100]();
                        }
                        size_t v40 = v39;
                        if (v39 >= 0x17)
                        {
                          uint64_t v48 = (v39 & 0xFFFFFFFFFFFFFFF8LL) + 8;
                          if ((v39 | 7) != 0x17) {
                            uint64_t v48 = v39 | 7;
                          }
                          uint64_t v49 = v48 + 1;
                          p_p = (__int128 *)operator new(v48 + 1);
                          *((void *)&__p + 1) = v40;
                          unint64_t v158 = v49 | 0x8000000000000000LL;
                          *(void *)&__int128 __p = p_p;
                        }

                        else
                        {
                          HIBYTE(v158) = v39;
                          p_p = &__p;
                          if (!v39) {
                            goto LABEL_70;
                          }
                        }

                        memcpy(p_p, v180, v40);
LABEL_70:
                        *((_BYTE *)p_p + v40) = 0;
                        __int128 v50 = v166;
                        if ((unint64_t)v166 >= v167)
                        {
                          std::string v166 = std::vector<std::string>::__push_back_slow_path<std::string>(&v165, (uint64_t)&__p);
                          if (SHIBYTE(v158) < 0) {
                            operator delete((void *)__p);
                          }
                        }

                        else
                        {
                          __int128 v51 = __p;
                          *((void *)v166 + 2) = v158;
                          *__int128 v50 = v51;
                          std::string v166 = (char *)v50 + 24;
                        }

                        std::string v148 = v163;
                        unint64_t v144 = v164;
                        unint64_t v44 = (unint64_t)v164;
                        goto LABEL_75;
                      }

                      HIBYTE(v158) = 0;
                      LOBYTE(__p) = 0;
                      uint64_t v45 = v166;
                      if ((unint64_t)v166 >= v167)
                      {
                        unint64_t v47 = (unint64_t)v144;
                        std::string v166 = std::vector<std::string>::__push_back_slow_path<std::string>(&v165, (uint64_t)&__p);
                        if (SHIBYTE(v158) < 0) {
                          operator delete((void *)__p);
                        }
                      }

                      else
                      {
                        __int128 v46 = __p;
                        *((void *)v166 + 2) = v158;
                        _OWORD *v45 = v46;
                        std::string v166 = (char *)v45 + 24;
                        unint64_t v47 = (unint64_t)v144;
                      }

                      unint64_t v44 = v47;
                    }

                    else
                    {
                      BYTE7(v178) = 0;
                      LOBYTE(buffer.tv_sec) = 0;
                      uint64_t v42 = v166;
                      if ((unint64_t)v166 >= v167)
                      {
                        unint64_t v44 = (unint64_t)v146;
                        std::string v166 = std::vector<std::string>::__push_back_slow_path<std::string>(&v165, (uint64_t)&buffer);
                        if (SBYTE7(v178) < 0) {
                          operator delete((void *)buffer.tv_sec);
                        }
                      }

                      else
                      {
                        timeval v43 = buffer;
                        *((void *)v166 + 2) = v178;
                        *uint64_t v42 = v43;
                        std::string v166 = (char *)v42 + 24;
                        unint64_t v44 = (unint64_t)v146;
                      }
                    }

LABEL_92:
                    uint64_t v66 = &v61[8 * v60];
                    uint64_t v162 = v62;
                    __int128 v164 = v66;
                    unint64_t v144 = v66;
                    if (v56) {
                      operator delete(v56);
                    }
                    __int128 v146 = v66;
                    goto LABEL_20;
                  }
                }
              }

              else
              {
                int v20 = pid;
              }

              do
              {
                uint64_t v38 = *--v18;
                *--uint64_t v28 = v38;
              }

              while (v18 != v21);
              goto LABEL_47;
            }

            mach_vm_size_t v75 = 0LL;
LABEL_107:
            mach_vm_deallocate(mach_task_self_, (mach_vm_address_t)act_list, v75);
          }
        }

        thread_act_array_t act_list = 0LL;
        *(void *)thread_info_outCnt = 0LL;
        *(void *)act_listCnt = 0LL;
        uint64_t v154 = 0LL;
        v152[0] = task_info_out;
        v152[1] = v172;
        uint64_t v153 = v173;
        int CPUType = MachProcess::GetCPUType(*(MachProcess **)(a1 + 8));
        if (MachVMMemory::GetMemoryProfile( (int)a1 + 24,  a2,  v8,  (int)v152,  CPUType,  v9,  (host_info64_t)&__p,  &act_list,  act_listCnt,  thread_info_outCnt,  &v154))
        {
          task_inspect_t v140 = v8;
          std::string v142 = (void **)v6;
          size_t v149 = v77;
          *(size_t *)((char *)&v149 + *(void *)(v77 - 24)) = v78;
          __int128 v79 = (std::ios_base *)((char *)&v149 + *(void *)(v149 - 24));
          std::ios_base::init(v79, &v150);
          v79[1].__vftable = 0LL;
          v79[1].__fmtflags_ = -1;
          std::streambuf::basic_streambuf(&v150);
          memset(&v150.__str_, 0, 32);
          v150.__mode_ = 16;
          if ((a2 & 1) != 0)
          {
            uint64_t v80 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v149,  (uint64_t)"num_cpu:",  8LL);
            uint64_t v81 = (void *)std::ostream::operator<<( v80,  MachTask::GetProfileData(DNBProfileDataScanType)::numCPU);
            LOBYTE(buffer.tv_sec) = 59;
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v81, (uint64_t)&buffer, 1LL);
            int v82 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v149,  (uint64_t)"host_user_ticks:",  16LL);
            uint64_t v83 = (void *)std::ostream::operator<<(v82, host_info_out[0]);
            LOBYTE(buffer.tv_sec) = 59;
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v83, (uint64_t)&buffer, 1LL);
            uint64_t v84 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v149,  (uint64_t)"host_sys_ticks:",  15LL);
            uint64_t v85 = (void *)std::ostream::operator<<(v84, host_info_out[1]);
            LOBYTE(buffer.tv_sec) = 59;
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v85, (uint64_t)&buffer, 1LL);
            int v86 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v149,  (uint64_t)"host_idle_ticks:",  16LL);
            char v87 = (void *)std::ostream::operator<<(v86, host_info_out[2]);
            LOBYTE(buffer.tv_sec) = 59;
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v87, (uint64_t)&buffer, 1LL);
          }

          if ((a2 & 2) != 0)
          {
            uint64_t v88 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v149,  (uint64_t)"elapsed_usec:",  13LL);
            uint64_t v89 = (void *)std::ostream::operator<<(v88, v10);
            LOBYTE(buffer.tv_sec) = 59;
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v89, (uint64_t)&buffer, 1LL);
            uint64_t v90 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v149,  (uint64_t)"task_used_usec:",  15LL);
            uint64_t v91 = (void *)std::ostream::operator<<(v90, v11);
            LOBYTE(buffer.tv_sec) = 59;
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v91, (uint64_t)&buffer, 1LL);
          }

          if ((a2 & 4) != 0)
          {
            uint64_t v92 = v168;
            if (v169 != v168)
            {
              uint64_t v93 = 0LL;
              std::string v147 = v168;
              else {
                uint64_t v94 = ((char *)v169 - (_BYTE *)v168) >> 3;
              }
              char v95 = "thread_used_id:";
              uint64_t v145 = v94;
              do
              {
                uint64_t v96 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v149,  (uint64_t)v95,  15LL);
                *(_DWORD *)((char *)v96 + *(void *)(*v96 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v96
                                                                                    + *(void *)(*v96 - 24LL)
                                                                                    + 8) & 0xFFFFFFB5 | 8;
                uint64_t v97 = (void *)std::ostream::operator<<(v96, v92[v93]);
                *(_DWORD *)((char *)v97 + *(void *)(*v97 - 24LL) + 8) = *(_DWORD *)((_BYTE *)v97
                                                                                    + *(void *)(*v97 - 24LL)
                                                                                    + 8) & 0xFFFFFFB5 | 2;
                LOBYTE(buffer.tv_sec) = 59;
                std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v97, (uint64_t)&buffer, 1LL);
                uint64_t v98 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v149,  (uint64_t)"thread_used_usec:",  17LL);
                uint64_t v99 = (void *)std::ostream::operator<<(v98, *((void *)v162 + v93));
                LOBYTE(buffer.tv_sec) = 59;
                std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v99, (uint64_t)&buffer, 1LL);
                if ((a2 & 8) == 0) {
                  goto LABEL_121;
                }
                std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v149,  (uint64_t)"thread_used_name:",  17LL);
                uint64_t v100 = (unsigned __int8 *)v165 + 24 * v93;
                if ((char)v100[23] < 0)
                {
                  uint64_t v101 = *((void *)v100 + 1);
                  if (v101)
                  {
                    uint64_t v100 = *(unsigned __int8 **)v100;
LABEL_128:
                    unint64_t v102 = v95;
                    size_t v103 = v149;
                    __int128 v104 = (char *)&v149 + *(void *)(v149 - 24);
                    if (*((_DWORD *)v104 + 36) == -1)
                    {
                      std::ios_base::getloc((const std::ios_base *)((char *)&v149 + *(void *)(v149 - 24)));
                      unint64_t v105 = std::locale::use_facet((const std::locale *)&buffer, &std::ctype<char>::id);
                      ((void (*)(const std::locale::facet *, uint64_t))v105->__vftable[2].~facet_0)( v105,  32LL);
                      std::locale::~locale((std::locale *)&buffer);
                      size_t v103 = v149;
                    }

                    *((_DWORD *)v104 + 36) = 48;
                    *(_DWORD *)((char *)&v150.__vftable + *(void *)(v103 - 24)) = *(_DWORD *)((_BYTE *)&v150.__vftable
                                                                                              + *(void *)(v103 - 24)) & 0xFFFFFFB5 | 8;
                    *(_DWORD *)((char *)&v150.__vftable + *(void *)(v103 - 24)) = *(_DWORD *)((_BYTE *)&v150.__vftable
                                                                                              + *(void *)(v103 - 24)) & 0xFFFFFF4F | 0x80;
                    *(std::streambuf::char_type **)((char *)&v150.__binp_ + *(void *)(v103 - 24)) = (std::streambuf::char_type *)2;
                    if (v101)
                    {
                      do
                      {
                        unsigned int v106 = *v100++;
                        std::ostream::operator<<(&v149, v106);
                        --v101;
                      }

                      while (v101);
                      size_t v103 = v149;
                    }

                    *(_DWORD *)((char *)&v150.__vftable + *(void *)(v103 - 24)) = *(_DWORD *)((_BYTE *)&v150.__vftable
                                                                                              + *(void *)(v103 - 24)) & 0xFFFFFFB5 | 2;
                    uint64_t v107 = (const std::ios_base *)((char *)&v149 + *(void *)(v103 - 24));
                    if (v107[1].__fmtflags_ == -1)
                    {
                      std::ios_base::getloc(v107);
                      uint64_t v108 = std::locale::use_facet((const std::locale *)&buffer, &std::ctype<char>::id);
                      ((void (*)(const std::locale::facet *, uint64_t))v108->__vftable[2].~facet_0)( v108,  32LL);
                      std::locale::~locale((std::locale *)&buffer);
                    }

                    v107[1].__fmtflags_ = 32;
                    char v95 = v102;
                    uint64_t v94 = v145;
                    uint64_t v92 = v147;
                  }
                }

                else
                {
                  uint64_t v101 = v100[23];
                  if (v100[23]) {
                    goto LABEL_128;
                  }
                }

                LOBYTE(buffer.tv_sec) = 59;
                std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v149, (uint64_t)&buffer, 1LL);
LABEL_121:
                ++v93;
              }

              while (v93 != v94);
            }
          }

          if ((a2 & 0x20) != 0)
          {
            __int128 v109 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v149,  (uint64_t)"total:",  6LL);
            uint64_t v110 = (void *)std::ostream::operator<<(v109, act_list);
            LOBYTE(buffer.tv_sec) = 59;
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v110, (uint64_t)&buffer, 1LL);
          }

          if ((a2 & 0x40) != 0)
          {
            if ((v111 & 1) == 0
            {
              MachTask::GetProfileData(DNBProfileDataScanType)::pagestd::string::size_type size = vm_kernel_page_size;
            }

            thread_act_array_t v112 = act_list;
            unint64_t v113 = MachTask::GetProfileData(DNBProfileDataScanType)::pagesize;
            int v114 = v160;
            uint64_t v115 = v161;
            int v116 = __p;
            uint64_t v117 = v159;
            std::string v118 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v149,  (uint64_t)"used:",  5LL);
            std::string v119 = (void *)std::ostream::operator<<( v118,  ((unint64_t)v112 / v113 - ((v116 - v114) + v115 + v117))
                             * MachTask::GetProfileData(DNBProfileDataScanType)::pagesize);
            LOBYTE(buffer.tv_sec) = 59;
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v119, (uint64_t)&buffer, 1LL);
            if ((a2 & 0x100) != 0)
            {
              std::string v120 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v149,  (uint64_t)"anonymous:",  10LL);
              std::string v121 = (void *)std::ostream::operator<<(v120, *(void *)act_listCnt);
              LOBYTE(buffer.tv_sec) = 59;
              std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v121, (uint64_t)&buffer, 1LL);
            }

            std::string v122 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v149,  (uint64_t)"phys_footprint:",  15LL);
            std::string v123 = (void *)std::ostream::operator<<(v122, *(void *)thread_info_outCnt);
            LOBYTE(buffer.tv_sec) = 59;
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v123, (uint64_t)&buffer, 1LL);
          }

          if (a2 < 0)
          {
            std::string v124 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v149,  (uint64_t)"mem_cap:",  8LL);
            __int128 v125 = (void *)std::ostream::operator<<(v124, v154);
            LOBYTE(buffer.tv_sec) = 59;
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v125, (uint64_t)&buffer, 1LL);
          }

          if ((a2 & 0x200) != 0 && !proc_pid_rusage(pid, 2, &host_info_outCnt))
          {
            uint64_t v126 = mach_absolute_time();
            uint64_t v181 = 0LL;
            memset(v180, 0, sizeof(v180));
            __int128 v178 = 0u;
            __int128 v179 = 0u;
            timeval buffer = (timeval)0;
            pm_sample_task_and_pid(v140, pid, &buffer, v126, -24LL);
            *(_OWORD *)((char *)&v180[5] + 4) = v184;
            *(int8x16_t *)((char *)&v180[6] + 4) = vextq_s8(v185, v185, 8uLL);
            *(_OWORD *)((char *)&v180[16] + 8) = v187;
            *((void *)&v180[17] + 1) = v186;
            double v127 = pm_energy_impact(&buffer);
            uint64_t v128 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v149,  (uint64_t)"energy:",  7LL);
            BOOL v129 = (void *)std::ostream::operator<<(v128, (unint64_t)(v127 * 1000000000.0));
            char v176 = 59;
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v129, (uint64_t)&v176, 1LL);
          }

          if ((a2 & 0x400) != 0)
          {
            LODWORD(buffer.tv_sec) = -1;
            LODWORD(host_info_outCnt) = -1;
            if (!proc_get_cpumon_params(pid, &buffer, &host_info_outCnt)
              && (buffer.tv_sec & 0x80000000) == 0
              && (host_info_outCnt & 0x80000000) == 0)
            {
              unint64_t v130 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v149,  (uint64_t)"cpu_cap_p:",  10LL);
              char v131 = (void *)std::ostream::operator<<(v130, LODWORD(buffer.tv_sec));
              char v176 = 59;
              std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v131, (uint64_t)&v176, 1LL);
              std::string v132 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>( &v149,  (uint64_t)"cpu_cap_t:",  10LL);
              std::string v133 = (void *)std::ostream::operator<<(v132, host_info_outCnt);
              char v176 = 59;
              std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v133, (uint64_t)&v176, 1LL);
            }
          }

          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v149, (uint64_t)"--end--;", 8LL);
          std::stringbuf::str((std::stringbuf::string_type *)&buffer, &v150);
          *(timeval *)std::string v142 = buffer;
          v142[2] = (void *)v178;
          std::streambuf::~streambuf(&v150);
          std::ios::~ios(&v151);
        }

        if (v162) {
          operator delete(v162);
        }
        std::string v134 = (char *)v165;
        if (v165)
        {
          std::string v135 = v166;
          std::string v136 = v165;
          if (v166 != v165)
          {
            do
            {
              if (*(v135 - 1) < 0) {
                operator delete(*((void **)v135 - 3));
              }
              v135 -= 24;
            }

            while (v135 != v134);
            std::string v136 = v165;
          }

          std::string v166 = v134;
          operator delete(v136);
        }

        if (v168) {
          operator delete(v168);
        }
      }
    }
  }

void sub_1000472C0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (a69 < 0) {
    operator delete(__p);
  }
  uint64_t v70 = (void *)STACK[0x250];
  if (STACK[0x250])
  {
    STACK[0x258] = (unint64_t)v70;
    operator delete(v70);
  }

  std::vector<std::string>::~vector[abi:ne180100]((void **)&STACK[0x268]);
  uint64_t v71 = (void *)STACK[0x280];
  if (STACK[0x280])
  {
    STACK[0x288] = (unint64_t)v71;
    operator delete(v71);
  }

  _Unwind_Resume(a1);
}

MachTask *MachTask::TaskPortForProcessID(MachTask *this, DNBError *a2, int a3)
{
  __n128 result = (MachTask *)*((unsigned int *)this + 4);
  if ((_DWORD)result) {
    BOOL v5 = a3 == 0;
  }
  else {
    BOOL v5 = 0;
  }
  if (!v5)
  {
    BOOL v6 = (unsigned int *)*((void *)this + 1);
    if (v6)
    {
      __n128 result = MachTask::TaskPortForProcessID((MachTask *)*v6, (int)a2, (DNBError *)0xA, 0x2710u);
      *((_DWORD *)this + 4) = (_DWORD)result;
    }
  }

  return result;
}

MachTask *MachTask::TaskPortForProcessID(MachTask *this, int a2, DNBError *a3, useconds_t a4)
{
  if (!(_DWORD)this) {
    return 0LL;
  }
  unsigned int v5 = a3;
  *(_OWORD *)__int128 __p = 0u;
  __int128 v33 = 0u;
  mach_port_name_t v6 = mach_task_self_;
  mach_port_name_t v31 = 0;
  if (!(_DWORD)a3)
  {
LABEL_26:
    BOOL v10 = 0;
    if ((SHIBYTE(v33) & 0x80000000) == 0) {
      goto LABEL_28;
    }
    goto LABEL_27;
  }

  uint64_t v4 = this;
  int v8 = 0;
  int v9 = (int)this;
  int v30 = (int)this;
  BOOL v10 = 1;
  while (1)
  {
    if (DNBLogEnabled())
    {
      uint64_t v11 = getpid();
      _DNBLog(0LL, (uint64_t)"[LaunchAttach] (%d) about to task_for_pid(%d)", v12, v13, v14, v15, v16, v17, v11);
    }

    __p[0] = (void *)(task_for_pid(v6, (int)v4, &v31) | 0x100000000LL);
    if (SHIBYTE(v33) < 0)
    {
      *(_BYTE *)__p[1] = 0;
      *(void *)&__int128 v33 = 0LL;
    }

    else
    {
      LOBYTE(__p[1]) = 0;
      HIBYTE(v33) = 0;
    }

    BOOL v18 = DNBLogCheckLogBit(0x2000);
    int v19 = (int)__p[0];
    int v20 = LODWORD(__p[0]) || v18;
    if (v20 != 1) {
      break;
    }
    if (DNBError::AsString((DNBError *)__p)) {
      __int128 v21 = (const char *)DNBError::AsString((DNBError *)__p);
    }
    else {
      __int128 v21 = "success";
    }
    snprintf( __str,  0x400uLL,  "::task_for_pid(target_tport = 0x%4.4x, unsigned int pid = %d, &task) => err = 0x%8.8x (%s)",  v6,  v9,  v19,  v21);
    if (LODWORD(__p[0]))
    {
      if (__str[0])
      {
        std::string::assign((std::string *)&__p[1], __str);
      }

      else if (SHIBYTE(v33) < 0)
      {
        *(_BYTE *)__p[1] = 0;
        *(void *)&__int128 v33 = 0LL;
      }

      else
      {
        LOBYTE(__p[1]) = 0;
        HIBYTE(v33) = 0;
      }

      if (DNBLogEnabled()) {
        _DNBLogError("[LaunchAttach] MachTask::TaskPortForProcessID task_for_pid(%d) failed: %s", v30, __str);
      }
    }

    DNBError::LogThreaded((DNBError *)__p, __str);
    if (!LODWORD(__p[0])) {
      break;
    }
    usleep(a4);
    BOOL v10 = ++v8 < v5;
    if (v5 == v8) {
      goto LABEL_26;
    }
  }

  if (DNBLogEnabled())
  {
    uint64_t v23 = getpid();
    _DNBLog(0LL, (uint64_t)"[LaunchAttach] (%d) successfully task_for_pid(%d)'ed", v24, v25, v26, v27, v28, v29, v23);
  }

  uint64_t v4 = (MachTask *)v31;
  if (SHIBYTE(v33) < 0) {
LABEL_27:
  }
    operator delete(__p[1]);
LABEL_28:
  if (!v10) {
    return 0LL;
  }
  return v4;
}

void sub_100047678( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

MachTask *MachTask::IsValid(MachTask *this, unsigned int a2, task_basic_info *a3)
{
  if ((_DWORD)this) {
    return (MachTask *)(MachTask::BasicInfo(this, task_info_out, a3) == 0);
  }
  return this;
}

BOOL MachTask::StartExceptionThread(uint64_t a1, int8x16_t **a2, uint64_t a3)
{
  kern_return_t v11;
  unsigned int *v12;
  BOOL result;
  kern_return_t inserted;
  _DWORD *v15;
  exception_mask_t v16;
  int8x16_t *v17;
  int8x16_t *v18;
  unint64_t v19;
  uint64_t v20;
  int8x16_t *v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t *v24;
  uint64_t v25;
  int8x16_t v26;
  __int32 v27;
  int v28;
  integer_t task_info_out[10];
  if (DNBLogEnabledForAny(8)) {
    _DNBLogThreaded("MachTask::%s()", "StartExceptionThread");
  }
  int v8 = (MachTask *)*(unsigned int *)(a1 + 16);
  if (!(_DWORD)v8
    && ((uint64_t v12 = *(unsigned int **)(a1 + 8)) == 0LL
     || (int v8 = MachTask::TaskPortForProcessID((MachTask *)*v12, v6, (DNBError *)0xA, 0x2710u),
         (*(_DWORD *)(a1 + 16) = (_DWORD)v8) == 0))
    || MachTask::BasicInfo(v8, task_info_out, v7))
  {
    __n128 result = DNBLogEnabled();
    if (!result) {
      return result;
    }
    _DNBLogError("MachTask::%s (): task invalid, exception thread start failed.", "StartExceptionThread");
    return 0LL;
  }

  mach_port_t v9 = mach_task_self_;
  BOOL v10 = (mach_port_name_t *)(a1 + 304);
  uint64_t v11 = mach_port_allocate(mach_task_self_, 1u, (mach_port_name_t *)(a1 + 304));
  *(_DWORD *)a3 = v11;
  *(_DWORD *)(a3 + 4) = 1;
  if (*(char *)(a3 + 31) < 0)
  {
    **(_BYTE **)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0LL;
    if (*(_DWORD *)a3) {
      return 0LL;
    }
  }

  else
  {
    *(_BYTE *)(a3 + 8) = 0;
    *(_BYTE *)(a3 + 31) = 0;
    if (v11) {
      return 0LL;
    }
  }

  inserted = mach_port_insert_right(v9, *v10, *v10, 0x14u);
  *(_DWORD *)a3 = inserted;
  *(_DWORD *)(a3 + 4) = 1;
  if (*(char *)(a3 + 31) < 0)
  {
    **(_BYTE **)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0LL;
    if (!*(_DWORD *)a3) {
      goto LABEL_19;
    }
    return 0LL;
  }

  *(_BYTE *)(a3 + 8) = 0;
  *(_BYTE *)(a3 + 31) = 0;
  if (inserted) {
    return 0LL;
  }
LABEL_19:
  uint64_t v15 = (_DWORD *)(a1 + 64);
  MachException::PortInfo::Save((MachException::PortInfo *)(a1 + 64), *(_DWORD *)(a1 + 16));
  uint64_t v16 = *(_DWORD *)(a1 + 64);
  if (!v16)
  {
    std::string::assign((std::string *)(a3 + 8), "failed to get exception port info");
    return 0LL;
  }

  BOOL v18 = *a2;
  uint64_t v17 = a2[1];
  if (*a2 != v17)
  {
    int v19 = (char *)v17 - (char *)v18 - 4;
    if (v19 < 0x3C
      || v15 < (__int32 *)((char *)&v18->i32[1] + (v19 & 0xFFFFFFFFFFFFFFFCLL)) && (unint64_t)v18 < a1 + 68)
    {
      goto LABEL_41;
    }

    int v20 = (v19 >> 2) + 1;
    __int128 v21 = (int8x16_t *)((char *)v18 + 4 * (v20 & 0x7FFFFFFFFFFFFFF8LL));
    v22.i64[0] = -1LL;
    v22.i64[1] = -1LL;
    v23.i32[1] = -1;
    v23.i64[1] = -1LL;
    v23.i32[0] = *(_DWORD *)(a1 + 64);
    uint64_t v24 = v18 + 1;
    uint64_t v25 = v20 & 0x7FFFFFFFFFFFFFF8LL;
    do
    {
      uint64_t v23 = vbicq_s8(v23, v24[-1]);
      int64_t v22 = vbicq_s8(v22, *v24);
      v24 += 2;
      v25 -= 8LL;
    }

    while (v25);
    uint64_t v26 = vandq_s8(v22, v23);
    *(int8x8_t *)v26.i8 = vand_s8(*(int8x8_t *)v26.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL));
    uint64_t v16 = v26.i32[0] & v26.i32[1];
    uint64_t *v15 = v26.i32[0] & v26.i32[1];
    BOOL v18 = v21;
    if (v20 != (v20 & 0x7FFFFFFFFFFFFFF8LL))
    {
LABEL_41:
      do
      {
        uint64_t v27 = v18->i32[0];
        BOOL v18 = (int8x16_t *)((char *)v18 + 4);
        v16 &= ~v27;
        uint64_t *v15 = v16;
      }

      while (v18 != v17);
    }
  }

  *(_DWORD *)a3 = task_set_exception_ports((task_t)v8, v16, *v10, -2147483647, 5);
  *(_DWORD *)(a3 + 4) = 1;
  if (*(char *)(a3 + 31) < 0)
  {
    **(_BYTE **)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0LL;
  }

  else
  {
    *(_BYTE *)(a3 + 8) = 0;
    *(_BYTE *)(a3 + 31) = 0;
  }

  if (DNBLogCheckLogBit(8) || *(_DWORD *)a3)
  {
    DNBError::LogThreaded( (DNBError *)a3,  "::task_set_exception_ports(task = 0x%4.4x, exception_mask = 0x%8.8x, new_port = 0x%4.4x, behavior = 0x%8.8x, new _flavor = 0x%8.8x)",  (_DWORD)v8,  *v15,  *v10,  -2147483647,  5);
    if (*(_DWORD *)a3) {
      return 0LL;
    }
  }

  uint64_t v28 = pthread_create((pthread_t *)(a1 + 296), 0LL, (void *(__cdecl *)(void *))MachTask::ExceptionThread, (void *)a1);
  *(_DWORD *)a3 = v28;
  *(_DWORD *)(a3 + 4) = 1;
  if (*(char *)(a3 + 31) < 0)
  {
    **(_BYTE **)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0LL;
    uint64_t v28 = *(_DWORD *)a3;
  }

  else
  {
    *(_BYTE *)(a3 + 8) = 0;
    *(_BYTE *)(a3 + 31) = 0;
  }

  return v28 == 0;
}

uint64_t MachTask::ExceptionThread(MachTask *this, void *a2)
{
  if (!this) {
    return 0LL;
  }
  int v3 = (MachProcess *)*((void *)this + 1);
  if (DNBLogEnabledForAny(8)) {
    _DNBLogThreaded("MachTask::%s(uint64_t arg = %p) starting thread...", "ExceptionThread", this);
  }
  pthread_setname_np("exception monitoring thread");
  int v21 = 0;
  uint64_t v4 = pthread_self();
  if (!pthread_getschedparam(v4, &v21, &v22))
  {
    v22.sched_priority = 47;
    unsigned int v5 = pthread_self();
    pthread_setschedparam(v5, v21, &v22);
  }

  int v6 = (MachTask *)*((unsigned int *)this + 4);
  if (MachProcess::ProcessUsingBackBoard(v3)
    && (uint64_t v7 = BKSWatchdogAssertionCreateForPID(kCFAllocatorDefault, *(unsigned int *)v3)) != 0)
  {
    CFTypeRef cf = (CFTypeRef)v7;
  }

  else
  {
    CFTypeRef cf = 0LL;
  }

  int v8 = 0;
  while ((*((_DWORD *)this + 76) - 1) <= 0xFFFFFFFD)
  {
    pthread_testcancel();
    __int128 __p = 0LL;
    uint64_t v29 = 0LL;
    uint64_t v30 = 0LL;
    bzero(v24, 0x80CuLL);
    if (v8) {
      mach_msg_option_t v9 = 1282;
    }
    else {
      mach_msg_option_t v9 = 1026;
    }
    int v10 = MachException::Message::Receive(v24, *((_DWORD *)this + 76), v9, v8 != 0, 0);
    if (v10)
    {
      if (v10 == 268451843)
      {
        if (v8)
        {
          uint64_t v12 = (MachTask *)MachProcess::ExceptionMessageBundleComplete(v3);
          int v6 = v12;
          if (!(_DWORD)v12 || MachTask::BasicInfo(v12, x, v13))
          {
            if (DNBLogEnabledForAny(8)) {
              _DNBLogThreaded("task has exited...");
            }
            MachProcess::SetState((uint64_t)v3, 9u);
            int v8 = 0;
            goto LABEL_45;
          }

          if (DNBLogEnabledForAny(8)) {
            _DNBLogThreaded("got a timeout, continuing...");
          }
          int v8 = 0;
        }

        goto LABEL_56;
      }

      if (v10 == 268451845)
      {
        if ((*((_DWORD *)this + 76) - 1) >= 0xFFFFFFFE)
        {
          if (DNBLogEnabledForAny(8)) {
            _DNBLogThreaded("thread cancelled...");
          }
          goto LABEL_45;
        }

        if (!(_DWORD)v6 || MachTask::BasicInfo(v6, x, v11))
        {
          if (DNBLogEnabledForAny(8)) {
            _DNBLogThreaded("task has exited...");
          }
          MachProcess::SetState((uint64_t)v3, 9u);
          goto LABEL_45;
        }

        BOOL v18 = DNBLogEnabledForAny(8);
        uint64_t v15 = "interrupted, but task still valid, continuing...";
        if (!v18) {
          goto LABEL_56;
        }
LABEL_42:
        _DNBLogThreaded(v15);
      }

      else
      {
        BOOL v14 = DNBLogEnabledForAny(8);
        uint64_t v15 = "got some other error, do something about it??? nah, continuing for now...";
        if (v14) {
          goto LABEL_42;
        }
      }

void sub_100047DBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

void *CFReleaser<BKSWatchdogAssertion *>::~CFReleaser(void *a1)
{
  *a1 = &off_1000615A8;
  mach_port_name_t v2 = (const void *)a1[1];
  if (v2)
  {
    CFRelease(v2);
    a1[1] = 0LL;
  }

  return a1;
}

uint64_t MachTask::GetDYLDAllImageInfosAddress(MachTask *this, DNBError *a2)
{
  kern_return_t v7;
  mach_msg_type_number_t task_info_outCnt;
  integer_t task_info_out[4];
  mach_msg_type_number_t task_info_outCnt = 4;
  task_name_t v4 = *((_DWORD *)this + 4);
  if (!v4)
  {
    unsigned int v5 = (unsigned int *)*((void *)this + 1);
    if (!v5)
    {
      task_name_t v4 = 0;
      if (*(_DWORD *)a2) {
        return -1LL;
      }
      goto LABEL_7;
    }

    task_name_t v4 = MachTask::TaskPortForProcessID((MachTask *)*v5, (int)a2, (DNBError *)0xA, 0x2710u);
    *((_DWORD *)this + 4) = v4;
  }

  if (*(_DWORD *)a2) {
    return -1LL;
  }
LABEL_7:
  uint64_t v7 = task_info(v4, 0x11u, task_info_out, &task_info_outCnt);
  *(_DWORD *)a2 = v7;
  *((_DWORD *)a2 + 1) = 1;
  if (*((char *)a2 + 31) < 0)
  {
    **((_BYTE **)a2 + 1) = 0;
    *((void *)a2 + 2) = 0LL;
    uint64_t v7 = *(_DWORD *)a2;
  }

  else
  {
    *((_BYTE *)a2 + 8) = 0;
    *((_BYTE *)a2 + 31) = 0;
  }

  if (v7) {
    return -1LL;
  }
  else {
    return *(void *)task_info_out;
  }
}

mach_vm_address_t MachTask::AllocateMemory(MachTask *this, mach_vm_size_t size, unsigned int a3)
{
  vm_map_t v3 = *((_DWORD *)this + 4);
  if (!v3) {
    return -1LL;
  }
  mach_vm_address_t address = 0LL;
  if (mach_vm_allocate(v3, &address, size, 1)) {
    return -1LL;
  }
  if (mach_vm_protect(v3, address, size, 0, a3 & 4 | (__rbit32(a3) >> 30)))
  {
    mach_vm_deallocate(v3, address, size);
    return -1LL;
  }

  mach_vm_address_t v7 = address;
  mach_msg_option_t v9 = (uint64_t *)*((void *)this + 40);
  if (v9)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v11 = (uint64_t **)v9;
        mach_vm_address_t v12 = v9[4];
        if (address >= v12) {
          break;
        }
        mach_msg_option_t v9 = *v11;
        int v10 = v11;
        if (!*v11) {
          goto LABEL_14;
        }
      }

      if (v12 >= address) {
        break;
      }
      mach_msg_option_t v9 = v11[1];
      if (!v9)
      {
        int v10 = v11 + 1;
        goto LABEL_14;
      }
    }
  }

  else
  {
    int v10 = (uint64_t **)((char *)this + 320);
    uint64_t v11 = (uint64_t **)((char *)this + 320);
LABEL_14:
    uint64_t v13 = (uint64_t *)operator new(0x30uLL);
    v13[4] = v7;
    v13[5] = size;
    *uint64_t v13 = 0LL;
    v13[1] = 0LL;
    v13[2] = (uint64_t)v11;
    *int v10 = v13;
    uint64_t v14 = **((void **)this + 39);
    if (v14)
    {
      *((void *)this + 39) = v14;
      uint64_t v15 = *v10;
    }

    else
    {
      uint64_t v15 = v13;
    }

    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 40), v15);
    ++*((void *)this + 41);
    return address;
  }

  return v7;
}

BOOL MachTask::DeallocateMemory(MachTask *this, mach_vm_address_t a2)
{
  vm_map_t v2 = *((_DWORD *)this + 4);
  if (!v2) {
    return 0LL;
  }
  vm_map_t v3 = (MachTask *)*((void *)this + 39);
  unsigned int v5 = (uint64_t *)*((void *)this + 39);
  while (v5[4] != a2)
  {
    int v6 = (MachTask *)v5[1];
    if (v6)
    {
      do
      {
        mach_vm_address_t v7 = v6;
        int v6 = *(MachTask **)v6;
      }

      while (v6);
    }

    else
    {
      do
      {
        mach_vm_address_t v7 = (MachTask *)v5[2];
        BOOL v8 = *(void *)v7 == (void)v5;
        unsigned int v5 = (uint64_t *)v7;
      }

      while (!v8);
    }

    unsigned int v5 = (uint64_t *)v7;
  }

  int v10 = (uint64_t *)v5[1];
  if (v10)
  {
    do
    {
      uint64_t v11 = v10;
      int v10 = (uint64_t *)*v10;
    }

    while (v10);
  }

  else
  {
    mach_vm_address_t v12 = v5;
    do
    {
      uint64_t v11 = (uint64_t *)v12[2];
      BOOL v8 = *v11 == (void)v12;
      mach_vm_address_t v12 = v11;
    }

    while (!v8);
  }

  mach_vm_size_t v13 = v5[5];
  if (v3 == (MachTask *)v5) {
    *((void *)this + 39) = v11;
  }
  uint64_t v14 = (uint64_t *)*((void *)this + 40);
  --*((void *)this + 41);
  std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v14, v5);
  operator delete(v5);
  if (!getenv("DEBUGSERVER_ZOMBIE_ALLOCATIONS")) {
    return mach_vm_deallocate(v2, a2, v13) == 0;
  }
  mach_vm_protect(v2, a2, v13, 0, 0);
  return 1LL;
}

void MachTask::ClearAllocations(MachTask *this)
{
  *((void *)this + 40) = 0LL;
  *((void *)this + 41) = 0LL;
  *((void *)this + 39) = (char *)this + 320;
}

void CFReleaser<BKSWatchdogAssertion *>::~CFReleaser(void *__p)
{
  *__int128 __p = &off_1000615A8;
  vm_map_t v2 = (const void *)__p[1];
  if (v2) {
    CFRelease(v2);
  }
  operator delete(__p);
}

void MachThread::MachThread(MachThread *this, MachProcess *a2, char a3, uint64_t a4, int a5)
{
  *(void *)this = a2;
  *((void *)this + 1) = a4;
  int v7 = ++GetSequenceID(void)::g_nextID;
  *((_DWORD *)this + 4) = a5;
  *((_DWORD *)this + 5) = v7;
  *((_DWORD *)this + 6) = 1;
  PThreadMutex::PThreadMutex((MachThread *)((char *)this + 32), 2);
  *((_DWORD *)this + 34) = 0;
  *((void *)this + 18) = 0LL;
  *((_DWORD *)this + 38) = 0;
  *((void *)this + 21) = 0LL;
  *((void *)this + 22) = 0LL;
  *((void *)this + 20) = 0LL;
  *((void *)this + 23) = DNBArchProtocol::Create();
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + MachTask::Clear((void *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((_BYTE *)this + 368) = a3;
  *((void *)this + 47) = 0LL;
  uint64_t v12 = 0LL;
  uint64_t RegisterSetInfo = DNBArchProtocol::GetRegisterSetInfo((DNBArchProtocol *)&v12, v8);
  uint64_t v10 = v12;
  *((void *)this + 24) = RegisterSetInfo;
  *((void *)this + 25) = v10;
  *((void *)this + 47) = dlsym((void *)0xFFFFFFFFFFFFFFFELL, "_pthread_qos_class_decode");
  thread_inspect_t v11 = *((_DWORD *)this + 4);
  if (!v11 || (mach_msg_type_number_t thread_info_outCnt = 10, thread_info(v11, 3u, (thread_info_t)this + 24, &thread_info_outCnt)))
  {
    *((void *)this + 16) = 0LL;
    *((_OWORD *)this + 6) = 0u;
    *((_OWORD *)this + 7) = 0u;
  }

  if (DNBLogEnabledForAny(5)) {
    _DNBLogThreaded( "MachThread::MachThread(process = %p, tid = 0x%8.8llx, seq_id = %u)",  this,  *((void *)this + 1),  *((_DWORD *)this + 5));
  }
}

void MachThread::~MachThread(MachThread *this)
{
  if (DNBLogEnabledForAny(5)) {
    _DNBLogThreaded("MachThread::~MachThread() for tid = 0x%8.8llx (%u)", *((void *)this + 1), *((_DWORD *)this + 5));
  }
  uint64_t v2 = *((void *)this + 23);
  *((void *)this + 23) = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  vm_map_t v3 = (void *)*((void *)this + 20);
  if (v3)
  {
    *((void *)this + 21) = v3;
    operator delete(v3);
  }

  if (pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 32)))
  {
  }

void MachThread::Suspend(MachThread *this)
{
  if (DNBLogEnabledForAny(5)) {
    _DNBLogThreaded("MachThread::%s()", "Suspend");
  }
  thread_act_t v2 = *((_DWORD *)this + 4);
  if (v2)
  {
    v3[0] = thread_suspend(v2);
    v3[1] = 1;
    uint64_t v5 = 0LL;
    uint64_t v6 = 0LL;
    __int128 __p = 0LL;
    if (v3[0])
    {
      DNBLogCheckLogBit(4);
    }

    else
    {
      ++*((_DWORD *)this + 34);
      if (!DNBLogCheckLogBit(4)) {
        return;
      }
    }

    DNBError::LogThreaded((DNBError *)v3, "::thread_suspend (%4.4x)", *((_DWORD *)this + 4));
    if (SHIBYTE(v6) < 0) {
      operator delete(__p);
    }
  }

BOOL MachThread::SetSuspendCountBeforeResume(MachThread *this, int a2)
{
  if (DNBLogEnabledForAny(5)) {
    _DNBLogThreaded("MachThread::%s()", "SetSuspendCountBeforeResume");
  }
  *(_OWORD *)__int128 __p = 0u;
  __int128 v10 = 0u;
  thread_inspect_t v4 = *((_DWORD *)this + 4);
  if (v4)
  {
    if (a2)
    {
      uint64_t v5 = (char *)this + 96;
      mach_msg_type_number_t thread_info_outCnt = 10;
      if (thread_info(v4, 3u, (thread_info_t)this + 24, &thread_info_outCnt))
      {
LABEL_6:
        *((void *)v5 + 4) = 0LL;
        *(_OWORD *)uint64_t v5 = 0u;
        *((_OWORD *)v5 + 1) = 0u;
        goto LABEL_22;
      }

      int v6 = *((_DWORD *)this + 32);
      *((_DWORD *)this + 34) -= v6;
      if (v6 >= 1)
      {
LABEL_10:
        uint64_t v5 = (char *)this + 96;
        do
        {
          __p[0] = (void *)(thread_resume(*((_DWORD *)this + 4)) | 0x100000000LL);
          if (SHIBYTE(v10) < 0)
          {
            *(_BYTE *)__p[1] = 0;
            *(void *)&__int128 v10 = 0LL;
          }

          else
          {
            LOBYTE(__p[1]) = 0;
            HIBYTE(v10) = 0;
          }

          if ((DNBLogCheckLogBit(4) || LODWORD(__p[0]))
            && (DNBError::LogThreaded((DNBError *)__p, "::thread_resume (%4.4x)", *((_DWORD *)this + 4)), LODWORD(__p[0])))
          {
            thread_inspect_t v7 = *((_DWORD *)this + 4);
            if (!v7) {
              goto LABEL_6;
            }
            mach_msg_type_number_t thread_info_outCnt = 10;
            if (thread_info(v7, 3u, (thread_info_t)this + 24, &thread_info_outCnt)) {
              goto LABEL_6;
            }
            int v6 = *((_DWORD *)this + 32);
          }

          else
          {
            --v6;
          }
        }

        while (v6 > 0);
      }
    }

    else
    {
      int v6 = *((_DWORD *)this + 34);
      *((_DWORD *)this + 34) = 0;
      if (v6 >= 1) {
        goto LABEL_10;
      }
    }
  }

uint64_t MachThread::RestoreSuspendCountAfterStop(MachThread *this)
{
  if (DNBLogEnabledForAny(5)) {
    _DNBLogThreaded("MachThread::%s()", "RestoreSuspendCountAfterStop");
  }
  *(_OWORD *)__int128 __p = 0u;
  __int128 v11 = 0u;
  if (!*((_DWORD *)this + 4)) {
    goto LABEL_29;
  }
  int v2 = *((_DWORD *)this + 34);
  if (v2 >= 1)
  {
    while (1)
    {
      __p[0] = (void *)(thread_resume(*((_DWORD *)this + 4)) | 0x100000000LL);
      if (SHIBYTE(v11) < 0)
      {
        *(_BYTE *)__p[1] = 0;
        *(void *)&__int128 v11 = 0LL;
      }

      else
      {
        LOBYTE(__p[1]) = 0;
        HIBYTE(v11) = 0;
      }

      if (DNBLogCheckLogBit(4) || LODWORD(__p[0]))
      {
        DNBError::LogThreaded((DNBError *)__p, "::thread_resume (%4.4x)", *((_DWORD *)this + 4));
        if (LODWORD(__p[0])) {
          break;
        }
      }

      int v3 = *((_DWORD *)this + 34);
      BOOL v4 = __OFSUB__(v3--, 1);
      *((_DWORD *)this + 34) = v3;
      if ((v3 < 0) ^ v4 | (v3 == 0))
      {
        uint64_t v5 = 1LL;
        if ((SHIBYTE(v11) & 0x80000000) == 0) {
          return v5;
        }
        goto LABEL_31;
      }
    }

    thread_inspect_t v7 = *((_DWORD *)this + 4);
    if (v7 && (mach_msg_type_number_t thread_info_outCnt = 10, !thread_info(v7, 3u, (thread_info_t)this + 24, &thread_info_outCnt)))
    {
      int v8 = *((_DWORD *)this + 32);
    }

    else
    {
      int v8 = 0;
      *((void *)this + 16) = 0LL;
      *((_OWORD *)this + 6) = 0u;
      *((_OWORD *)this + 7) = 0u;
    }

    uint64_t v5 = 0LL;
    *((_DWORD *)this + 34) = v8;
    if ((SHIBYTE(v11) & 0x80000000) == 0) {
      return v5;
    }
    goto LABEL_31;
  }

  uint64_t v5 = 1LL;
  if ((v2 & 0x80000000) == 0) {
    goto LABEL_30;
  }
  while (1)
  {
    unsigned int v6 = thread_suspend(*((_DWORD *)this + 4));
    __p[0] = (void *)(v6 | 0x100000000LL);
    if (SHIBYTE(v11) < 0) {
      break;
    }
    LOBYTE(__p[1]) = 0;
    HIBYTE(v11) = 0;
    if (v6) {
      goto LABEL_27;
    }
LABEL_21:
    ++*((_DWORD *)this + 34);
    if (DNBLogCheckLogBit(4)) {
      goto LABEL_28;
    }
    if ((*((_DWORD *)this + 34) & 0x80000000) == 0) {
      goto LABEL_30;
    }
  }

  *(_BYTE *)__p[1] = 0;
  *(void *)&__int128 v11 = 0LL;
  if (!LODWORD(__p[0])) {
    goto LABEL_21;
  }
LABEL_27:
  DNBLogCheckLogBit(4);
LABEL_28:
  DNBError::LogThreaded((DNBError *)__p, "::thread_suspend (%4.4x)", *((_DWORD *)this + 4));
LABEL_29:
  uint64_t v5 = 0LL;
LABEL_30:
  if (SHIBYTE(v11) < 0) {
LABEL_31:
  }
    operator delete(__p[1]);
  return v5;
}

char *MachThread::GetBasicInfoAsString(MachThread *this)
{
  thread_inspect_t v2 = *((_DWORD *)this + 4);
  if (!v2) {
    return 0LL;
  }
  mach_msg_type_number_t thread_info_outCnt = 10;
  if (thread_info(v2, 3u, thread_info_out, &thread_info_outCnt)) {
    return 0LL;
  }
  uint64_t v5 = *((void *)this + 1);
  int v3 = MachThread::GetBasicInfoAsString(void)const::g_basic_info_string;
  double v6 = (float)((float)((float)thread_info_out[1] / 1000000.0) + (float)thread_info_out[0]);
  snprintf( MachThread::GetBasicInfoAsString(void)const::g_basic_info_string,  0x400uLL,  "Thread 0x%8.8llx: user=%f system=%f cpu=%d sleep_time=%d",  v5,  v6,  v6,  thread_info_out[4],  thread_info_out[9]);
  return v3;
}

BOOL MachThread::IsUserReady(MachThread *this)
{
  int v2 = *((_DWORD *)this + 30);
  if (!v2)
  {
    thread_inspect_t v5 = *((_DWORD *)this + 4);
    if (!v5 || (mach_msg_type_number_t thread_info_outCnt = 10, thread_info(v5, 3u, (thread_info_t)this + 24, &thread_info_outCnt)))
    {
      *((void *)this + 16) = 0LL;
      *((_OWORD *)this + 6) = 0u;
      *((_OWORD *)this + 7) = 0u;
      return (*(uint64_t (**)(void, void))(**((void **)this + 23) + 88LL))(*((void *)this + 23), 0LL) != 0;
    }

    int v2 = *((_DWORD *)this + 30);
  }

  unsigned int v3 = v2 - 1;
  if (v3 < 5 && ((0x17u >> v3) & 1) != 0) {
    return 1LL;
  }
  return (*(uint64_t (**)(void, void))(**((void **)this + 23) + 88LL))(*((void *)this + 23), 0LL) != 0;
}

void MachThread::Dump(MachThread *this, int a2)
{
  unsigned int v4 = *((_DWORD *)this + 30) - 1;
  if (v4 > 4)
  {
    thread_inspect_t v5 = "???";
    if (!DNBLogEnabled()) {
      return;
    }
    goto LABEL_5;
  }

  thread_inspect_t v5 = off_1000615C8[v4];
  if (DNBLogEnabled())
  {
LABEL_5:
    uint64_t v6 = *((void *)this + 1);
    int v7 = *((_DWORD *)this + 5);
    uint64_t v8 = (*(uint64_t (**)(void, uint64_t))(**((void **)this + 23) + 88LL))(*((void *)this + 23), -1LL);
    uint64_t v9 = (*(uint64_t (**)(void, uint64_t))(**((void **)this + 23) + 104LL))(*((void *)this + 23), -1LL);
    _DNBLogThreaded( "[%3u] #%3u tid: 0x%8.8llx, pc: 0x%16.16llx, sp: 0x%16.16llx, user: %d.%6.6d, system: %d.%6.6d, cpu: %2d, policy: % 2d, run_state: %2d (%s), flags: %2d, suspend_count: %2d (current %2d), sleep_time: %d",  a2,  v7,  v6,  v8,  v9,  *((_DWORD *)this + 24),  *((_DWORD *)this + 25),  *((_DWORD *)this + 26),  *((_DWORD *)this + 27),  *((_DWORD *)this + 28),  *((_DWORD *)this + 29),  *((_DWORD *)this + 30),  v5,  *((_DWORD *)this + 31),  *((_DWORD *)this + 32),  *((_DWORD *)this + 34),  *((_DWORD *)this + 33));
  }

uint64_t MachThread::ThreadWillResume(uint64_t a1, uint64_t a2, int a3)
{
  if (*(void *)(a2 + 16) != -1LL) {
    (*(void (**)(void))(**(void **)(a1 + 184) + 96LL))(*(void *)(a1 + 184));
  }
  unsigned int v6 = *(_DWORD *)(a2 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
  *(_DWORD *)(a1 + 24) = v6;
  if (DNBLogEnabledForAny(4))
  {
    int v7 = DNBStateAsString(v6);
    _DNBLogThreaded("MachThread::SetState(%s) for tid = 0x%8.8llx", v7, *(void *)(a1 + 8));
  }

  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 32));
  int v8 = *(_DWORD *)(a2 + 8);
  if ((v8 - 5) < 2)
  {
    if (DNBLogEnabledForAny(5)) {
      _DNBLogThreaded("MachThread::%s()", "Resume");
    }
    if (*(_DWORD *)(a1 + 16)) {
      MachThread::SetSuspendCountBeforeResume((MachThread *)a1, a3);
    }
  }

  else if (v8 == 10 || v8 == 4)
  {
    if (a3) {
      MachThread::ThreadWillResume();
    }
    MachThread::Suspend((MachThread *)a1);
  }

  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 184) + 112LL))(*(void *)(a1 + 184));
  *(void *)(a1 + 144) = 0LL;
  *(_DWORD *)(a1 + 152) = 0;
  *(void *)(a1 + 168) = *(void *)(a1 + 160);
  return result;
}

BOOL MachThread::ShouldStop(MachThread *this, BOOL *a2)
{
  unsigned int v4 = (DNBBreakpointList *)(*(void *)this + 1640LL);
  unint64_t v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)this + 23) + 88LL))(*((void *)this + 23), -1LL);
  if ((*(unsigned int (**)(void))(**((void **)this + 23) + 192LL))(*((void *)this + 23)))
  {
    BOOL result = 0LL;
    *a2 = 1;
  }

  else
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
    int v7 = *((_DWORD *)this + 6);
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 32));
    return v7 != 5 && *((_DWORD *)this + 36) && *((_DWORD *)this + 37) && *((_DWORD *)this + 38) != 0;
  }

  return result;
}

uint64_t MachThread::GetState(MachThread *this)
{
  int v2 = (pthread_mutex_t *)((char *)this + 32);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  uint64_t v3 = *((unsigned int *)this + 6);
  pthread_mutex_unlock(v2);
  return v3;
}

BOOL MachThread::IsStepping(MachThread *this)
{
  task_t v1 = this;
  int v2 = (pthread_mutex_t *)((char *)this + 32);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  LODWORD(v1) = *((_DWORD *)v1 + 6);
  pthread_mutex_unlock(v2);
  return (_DWORD)v1 == 6;
}

uint64_t MachThread::ThreadDidStop(MachThread *this)
{
  thread_inspect_t v2 = *((_DWORD *)this + 4);
  if (v2 && (mach_msg_type_number_t thread_info_outCnt = 10, !thread_info(v2, 3u, (thread_info_t)this + 24, &thread_info_outCnt)))
  {
    if (*((int *)this + 32) >= 1)
    {
      uint64_t v3 = (pthread_mutex_t *)((char *)this + 32);
      pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
      unsigned int v4 = 10;
      *((_DWORD *)this + 6) = 10;
      if (!DNBLogEnabledForAny(4)) {
        goto LABEL_6;
      }
      goto LABEL_5;
    }
  }

  else
  {
    *((void *)this + 16) = 0LL;
    *((_OWORD *)this + 6) = 0u;
    *((_OWORD *)this + 7) = 0u;
  }

  uint64_t v3 = (pthread_mutex_t *)((char *)this + 32);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  unsigned int v4 = 4;
  *((_DWORD *)this + 6) = 4;
  if (DNBLogEnabledForAny(4))
  {
LABEL_5:
    unint64_t v5 = DNBStateAsString(v4);
    _DNBLogThreaded("MachThread::SetState(%s) for tid = 0x%8.8llx", v5, *((void *)this + 1));
  }

uint64_t MachThread::NotifyException(MachThread *this, MachException::Data *a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(**((void **)this + 23) + 128LL))(*((void *)this + 23));
  unint64_t v5 = (MachThread *)((char *)this + 144);
  if (!*((_DWORD *)this + 36)
    || !*((_DWORD *)this + 37)
    || (int v6 = *((_DWORD *)this + 38)) == 0
    || v6 == 6
    || v6 == 5 && **((void **)this + 20) == 1LL)
  {
    uint64_t v7 = *(void *)a2;
    *((_DWORD *)this + 38) = *((_DWORD *)a2 + 2);
    *(void *)unint64_t v5 = v7;
    if (v5 != a2) {
      std::vector<long long>::__assign_with_size[abi:nn180100]<long long *,long long *>( (void *)this + 20,  *((char **)a2 + 2),  *((char **)a2 + 3),  (uint64_t)(*((void *)a2 + 3) - *((void *)a2 + 2)) >> 3);
    }
  }

  return v4;
}

unint64_t MachThread::GetRegisterInfo(MachThread *this, unint64_t a2, unint64_t a3)
{
  if (*((void *)this + 25) <= a2) {
    return 0LL;
  }
  uint64_t v3 = *((void *)this + 24);
  if (*(void *)(v3 + 24 * a2 + 16) <= a3) {
    return 0LL;
  }
  else {
    return *(void *)(v3 + 24 * a2 + 8) + 72 * a3;
  }
}

uint64_t MachThread::GetRegisterValue(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 184) + 16LL))(*(void *)(a1 + 184));
}

uint64_t MachThread::SetRegisterValue(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 184) + 24LL))(*(void *)(a1 + 184));
}

uint64_t MachThread::GetRegisterContext(MachThread *this, void *a2)
{
  return (*(uint64_t (**)(void, void *))(**((void **)this + 23) + 32LL))(*((void *)this + 23), a2);
}

uint64_t MachThread::SetRegisterContext(MachThread *this, const void *a2)
{
  return (*(uint64_t (**)(void, const void *))(**((void **)this + 23) + 40LL))(*((void *)this + 23), a2);
}

uint64_t MachThread::SaveRegisterState(MachThread *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 23) + 48LL))(*((void *)this + 23));
}

uint64_t MachThread::RestoreRegisterState(MachThread *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 23) + 56LL))(*((void *)this + 23));
}

uint64_t MachThread::EnableHardwareBreakpoint(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a2 || (*(_BYTE *)(a2 + 24) & 4) != 0) {
    return 0xFFFFFFFFLL;
  }
  else {
    return (*(uint64_t (**)(void, void, void, uint64_t))(**(void **)(a1 + 184) + 152LL))( *(void *)(a1 + 184),  *(void *)(a2 + 16),  *(unsigned int *)(a2 + 4),  a3);
  }
}

uint64_t MachThread::EnableHardwareWatchpoint(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 && (unsigned int v3 = *(unsigned __int8 *)(a2 + 24), (v3 & 4) != 0)) {
    return (*(uint64_t (**)(void, void, void, void, void, uint64_t))(**(void **)(a1 + 184) + 160LL))( *(void *)(a1 + 184),  *(void *)(a2 + 16),  *(unsigned int *)(a2 + 4),  (v3 >> 3) & 1,  (v3 >> 4) & 1,  a3);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t MachThread::RollbackTransForHWP(MachThread *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 23) + 208LL))(*((void *)this + 23));
}

uint64_t MachThread::FinishTransForHWP(MachThread *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 23) + 216LL))(*((void *)this + 23));
}

uint64_t MachThread::DisableHardwareBreakpoint(uint64_t a1, uint64_t a2)
{
  if (!a2 || *(_DWORD *)(a2 + 28) == -1) {
    return 0LL;
  }
  else {
    return (*(uint64_t (**)(void))(**(void **)(a1 + 184) + 168LL))(*(void *)(a1 + 184));
  }
}

uint64_t MachThread::DisableHardwareWatchpoint(uint64_t a1, uint64_t a2)
{
  if (!a2 || *(_DWORD *)(a2 + 28) == -1) {
    return 0LL;
  }
  else {
    return (*(uint64_t (**)(void))(**(void **)(a1 + 184) + 176LL))(*(void *)(a1 + 184));
  }
}

uint64_t MachThread::NumSupportedHardwareWatchpoints(MachThread *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 23) + 144LL))(*((void *)this + 23));
}

uint64_t MachThread::GetName(MachThread *this)
{
  mach_msg_type_number_t thread_info_outCnt = 6;
  if (!thread_info(*((_DWORD *)this + 4), 4u, (thread_info_t)this + 52, &thread_info_outCnt)
    && proc_pidinfo(**(_DWORD **)this, 5, *((void *)this + 27), (char *)this + 232, 112)
    && *((_BYTE *)this + 280))
  {
    return (uint64_t)this + 280;
  }

  else
  {
    return 0LL;
  }

uint64_t MachThread::GetGloballyUniqueThreadIDForMachPortID(MachThread *this)
{
  unsigned int v1 = this;
  mach_msg_type_number_t thread_info_outCnt = 6;
  if (thread_info((thread_inspect_t)this, 4u, thread_info_out, &thread_info_outCnt)) {
    return v1;
  }
  else {
    return *(void *)thread_info_out;
  }
}

uint64_t MachThread::GetPThreadT(MachThread *this)
{
  thread_inspect_t v2 = *((_DWORD *)this + 4);
  if (!v2) {
    return -1LL;
  }
  mach_msg_type_number_t thread_info_outCnt = 6;
  if (thread_info(v2, 4u, &thread_info_out, &thread_info_outCnt)) {
    return -1LL;
  }
  if (*((_BYTE *)this + 368))
  {
    *(void *)int v8 = 0LL;
    unint64_t Memory = MachProcess::ReadMemory(*(MachProcess **)this, v11, 8uLL, v8);
    uint64_t v5 = *(void *)v8;
    if (*(void *)v8) {
      BOOL v6 = Memory == 8;
    }
    else {
      BOOL v6 = 0;
    }
  }

  else
  {
    *(_DWORD *)int v8 = 0;
    unint64_t v7 = MachProcess::ReadMemory(*(MachProcess **)this, v11, 4uLL, v8);
    uint64_t v5 = *(unsigned int *)v8;
    if (*(_DWORD *)v8) {
      BOOL v6 = v7 == 4;
    }
    else {
      BOOL v6 = 0;
    }
  }

  if (v6) {
    return v5;
  }
  else {
    return -1LL;
  }
}

uint64_t MachThread::GetTSDAddressForThread(MachThread *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t PThreadT = MachThread::GetPThreadT(this);
  if (a4 != 4) {
    return -1LL;
  }
  unsigned int v17 = 0;
  mach_vm_address_t v10 = PThreadT + a2;
  unint64_t Memory = MachProcess::ReadMemory(*(MachProcess **)this, v10, 4uLL, (char *)&v17);
  if (v17) {
    BOOL v12 = Memory == 4;
  }
  else {
    BOOL v12 = 0;
  }
  if (v12) {
    uint64_t v13 = v17;
  }
  else {
    uint64_t v13 = -1LL;
  }
  *(void *)char v16 = 0LL;
  unint64_t v14 = MachProcess::ReadMemory(*(MachProcess **)this, v10, 8uLL, v16);
  if (*(void *)v16) {
    BOOL v15 = v14 == 8;
  }
  else {
    BOOL v15 = 0;
  }
  if (v15) {
    return *(void *)v16;
  }
  else {
    return v13;
  }
}

uint64_t MachThread::GetDispatchQueueT(MachThread *this)
{
  thread_inspect_t v2 = *((_DWORD *)this + 4);
  if (!v2) {
    return -1LL;
  }
  mach_msg_type_number_t thread_info_outCnt = 6;
  if (thread_info(v2, 4u, thread_info_out, &thread_info_outCnt) || v11 + 1 < 2) {
    return -1LL;
  }
  if (*((_BYTE *)this + 368))
  {
    *(void *)int v8 = 0LL;
    unint64_t Memory = MachProcess::ReadMemory(*(MachProcess **)this, v11, 8uLL, v8);
    uint64_t v5 = *(void *)v8;
    if (*(void *)v8) {
      BOOL v6 = Memory == 8;
    }
    else {
      BOOL v6 = 0;
    }
  }

  else
  {
    *(_DWORD *)int v8 = 0;
    unint64_t v7 = MachProcess::ReadMemory(*(MachProcess **)this, v11, 4uLL, v8);
    uint64_t v5 = *(unsigned int *)v8;
    if (*(_DWORD *)v8) {
      BOOL v6 = v7 == 4;
    }
    else {
      BOOL v6 = 0;
    }
  }

  if (v6) {
    return v5;
  }
  else {
    return -1LL;
  }
}

std::string *MachThread::GetRequestedQoS@<X0>( std::string *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  *(_OWORD *)(a4 + 16) = 0u;
  *(_OWORD *)(a4 + memset(__p, 0, 32) = 0u;
  *(_OWORD *)a4 = 0u;
  *(_DWORD *)(a4 + 48) = -1;
  if (LODWORD(this->__r_.__value_.__r.__words[2]))
  {
    uint64_t v5 = this;
    if (this[15].__r_.__value_.__l.__cap_)
    {
      if (this[15].__r_.__value_.__s.__data_[8])
      {
        uint64_t v14 = 0LL;
        unint64_t Memory = MachProcess::ReadMemory( (MachProcess *)this->__r_.__value_.__l.__data_,  a2 + 8 * a3,  8uLL,  (char *)&v14);
        uint64_t v7 = v14;
        BOOL v8 = Memory == 8;
      }

      else
      {
        unsigned int v13 = 0;
        unint64_t v9 = MachProcess::ReadMemory((MachProcess *)this->__r_.__value_.__l.__data_, a2 + 4 * a3, 4uLL, (char *)&v13);
        uint64_t v7 = v13;
        BOOL v8 = v9 == 4;
      }

      if (v8) {
        uint64_t v10 = v7;
      }
      else {
        uint64_t v10 = 0LL;
      }
      this = (std::string *)((uint64_t (*)(uint64_t, void, void))v5[15].__r_.__value_.__l.__cap_)( v10,  0LL,  0LL);
      unint64_t v11 = "User Interactive";
      BOOL v12 = "QOS_CLASS_USER_INTERACTIVE";
      switch((int)this)
      {
        case 0:
          unint64_t v11 = "Unspecified";
          BOOL v12 = "QOS_CLASS_UNSPECIFIED";
          goto LABEL_15;
        case 9:
          unint64_t v11 = "Background";
          BOOL v12 = "QOS_CLASS_BACKGROUND";
          goto LABEL_15;
        case 17:
          unint64_t v11 = "Utility";
          BOOL v12 = "QOS_CLASS_UTILITY";
          goto LABEL_15;
        case 21:
          unint64_t v11 = "Default";
          BOOL v12 = "QOS_CLASS_DEFAULT";
          goto LABEL_15;
        case 25:
          unint64_t v11 = "User Initiated";
          BOOL v12 = "QOS_CLASS_USER_INITIATED";
          goto LABEL_15;
        case 33:
LABEL_15:
          *(_DWORD *)(a4 + 48) = (_DWORD)this;
          std::string::assign((std::string *)a4, v12);
          this = std::string::assign((std::string *)(a4 + 24), v11);
          break;
        default:
          return this;
      }
    }
  }

  return this;
}

void *std::vector<long long>::__assign_with_size[abi:nn180100]<long long *,long long *>( void *result, char *__src, char *a3, size_t __sz)
{
  BOOL v6 = __src;
  uint64_t v7 = result;
  uint64_t v8 = result[2];
  unint64_t v9 = (char *)*result;
  if (__sz > (v8 - *result) >> 3)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      uint64_t v8 = 0LL;
      *uint64_t v7 = 0LL;
      v7[1] = 0LL;
      v7[2] = 0LL;
    }

    if (__sz >> 61) {
      goto LABEL_22;
    }
    uint64_t v10 = v8 >> 2;
    if (v8 >> 2 <= __sz) {
      uint64_t v10 = __sz;
    }
    BOOL v11 = (unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8LL;
    unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    if (!v11) {
      unint64_t v12 = v10;
    }
    if (v12 >> 61) {
LABEL_22:
    }
      abort();
    uint64_t v13 = v12;
    BOOL result = operator new(8 * v12);
    unint64_t v9 = (char *)result;
    *uint64_t v7 = result;
    v7[1] = result;
    v7[2] = &result[v13];
    size_t v14 = a3 - v6;
    if (v14) {
      BOOL result = memcpy(result, v6, v14);
    }
    BOOL v15 = (void **)(v7 + 1);
    goto LABEL_21;
  }

  BOOL v15 = (void **)(result + 1);
  char v16 = (_BYTE *)result[1];
  unint64_t v17 = (v16 - v9) >> 3;
  if (v17 >= __sz)
  {
    size_t v14 = a3 - __src;
    if (a3 == __src) {
      goto LABEL_21;
    }
    int v19 = (void *)*result;
LABEL_20:
    BOOL result = memmove(v19, __src, v14);
    goto LABEL_21;
  }

  BOOL v18 = &__src[8 * v17];
  if (v16 != v9)
  {
    BOOL result = memmove((void *)*result, __src, v16 - v9);
    unint64_t v9 = (char *)*v15;
  }

  size_t v14 = a3 - v18;
  if (v14)
  {
    int v19 = v9;
    __src = v18;
    goto LABEL_20;
  }

void MachThreadList::MachThreadList(MachThreadList *this)
{
  *(void *)this = 0LL;
  *((void *)this + 1) = 0LL;
  *((void *)this + 2) = 0LL;
  PThreadMutex::PThreadMutex((MachThreadList *)((char *)this + 24), 2);
  *((void *)this + 11) = 0LL;
  *((void *)this + 12) = 0LL;
  *((_BYTE *)this + 104) = 0;
}

void MachThreadList::~MachThreadList(MachThreadList *this)
{
  thread_inspect_t v2 = (std::__shared_weak_count *)*((void *)this + 12);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      unint64_t v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }

  if (pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 24))
    && !pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 24)))
  {
    pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 24));
    uint64_t v5 = *(char **)this;
    if (!*(void *)this) {
      return;
    }
  }

  else
  {
    uint64_t v5 = *(char **)this;
    if (!*(void *)this) {
      return;
    }
  }

  BOOL v6 = (char *)*((void *)this + 1);
  uint64_t v7 = v5;
  if (v6 != v5)
  {
    do
    {
      uint64_t v8 = (std::__shared_weak_count *)*((void *)v6 - 1);
      if (v8)
      {
        unint64_t v9 = (unint64_t *)&v8->__shared_owners_;
        do
          unint64_t v10 = __ldaxr(v9);
        while (__stlxr(v10 - 1, v9));
        if (!v10)
        {
          ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
          std::__shared_weak_count::__release_weak(v8);
        }
      }

      v6 -= 16;
    }

    while (v6 != v5);
    uint64_t v7 = *(char **)this;
  }

  *((void *)this + 1) = v5;
  operator delete(v7);
}

uint64_t MachThreadList::GetState(MachThreadList *this, uint64_t a2)
{
  unint64_t v4 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v5 = *((void *)this + 1) - *(void *)this;
  if (v5)
  {
    unint64_t v6 = v5 >> 4;
    if (v6 <= 1) {
      unint64_t v6 = 1LL;
    }
    uint64_t v7 = (std::__shared_weak_count **)(*(void *)this + 8LL);
    while (1)
    {
      uint64_t v8 = (MachThread *)*(v7 - 1);
      if (*((void *)v8 + 1) == a2) {
        break;
      }
      v7 += 2;
      if (!--v6) {
        goto LABEL_7;
      }
    }

    BOOL v11 = *v7;
    if (*v7)
    {
      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
    }

    pthread_mutex_unlock(v4);
    uint64_t State = MachThread::GetState(v8);
    if (v11)
    {
      size_t v14 = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
  }

  else
  {
LABEL_7:
    pthread_mutex_unlock(v4);
    return 0LL;
  }

  return State;
}

uint64_t MachThreadList::GetThreadByID@<X0>(MachThreadList *this@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  unint64_t v6 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  *a3 = 0LL;
  a3[1] = 0LL;
  uint64_t v7 = *((void *)this + 1) - *(void *)this;
  if (v7)
  {
    unint64_t v8 = v7 >> 4;
    if (v8 <= 1) {
      unint64_t v8 = 1LL;
    }
    for (uint64_t i = (uint64_t *)(*(void *)this + 8LL); ; i += 2)
    {
      uint64_t v10 = *(i - 1);
      if (*(void *)(v10 + 8) == a2) {
        break;
      }
      if (!--v8) {
        return pthread_mutex_unlock(v6);
      }
    }

    uint64_t v11 = *i;
    if (v11)
    {
      unint64_t v12 = (unint64_t *)(v11 + 8);
      do
        unint64_t v13 = __ldxr(v12);
      while (__stxr(v13 + 1, v12));
    }

    *a3 = v10;
    a3[1] = v11;
  }

  return pthread_mutex_unlock(v6);
}

uint64_t MachThreadList::GetName(MachThreadList *this, uint64_t a2)
{
  unint64_t v4 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v5 = *((void *)this + 1) - *(void *)this;
  if (v5)
  {
    unint64_t v6 = v5 >> 4;
    if (v6 <= 1) {
      unint64_t v6 = 1LL;
    }
    uint64_t v7 = (std::__shared_weak_count **)(*(void *)this + 8LL);
    while (1)
    {
      unint64_t v8 = (MachThread *)*(v7 - 1);
      if (*((void *)v8 + 1) == a2) {
        break;
      }
      v7 += 2;
      if (!--v6) {
        goto LABEL_7;
      }
    }

    uint64_t v11 = *v7;
    if (*v7)
    {
      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
    }

    pthread_mutex_unlock(v4);
    uint64_t Name = MachThread::GetName(v8);
    if (v11)
    {
      size_t v14 = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
  }

  else
  {
LABEL_7:
    pthread_mutex_unlock(v4);
    return 0LL;
  }

  return Name;
}

void MachThreadList::GetRequestedQoS( MachThreadList *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v10 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v11 = *((void *)this + 1) - *(void *)this;
  if (v11)
  {
    unint64_t v12 = v11 >> 4;
    if (v12 <= 1) {
      unint64_t v12 = 1LL;
    }
    unint64_t v13 = (std::__shared_weak_count **)(*(void *)this + 8LL);
    while (1)
    {
      size_t v14 = (std::string *)*(v13 - 1);
      if (v14->__r_.__value_.__l.__size_ == a2) {
        break;
      }
      v13 += 2;
      if (!--v12) {
        goto LABEL_7;
      }
    }

    unint64_t v15 = *v13;
    if (*v13)
    {
      p_shared_owners = (unint64_t *)&v15->__shared_owners_;
      do
        unint64_t v17 = __ldxr(p_shared_owners);
      while (__stxr(v17 + 1, p_shared_owners));
      pthread_mutex_unlock(v10);
      MachThread::GetRequestedQoS(v14, a3, a4, a5);
      do
        unint64_t v18 = __ldaxr(p_shared_owners);
      while (__stlxr(v18 - 1, p_shared_owners));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }

    else
    {
      pthread_mutex_unlock(v10);
      MachThread::GetRequestedQoS(v14, a3, a4, a5);
    }
  }

  else
  {
LABEL_7:
    pthread_mutex_unlock(v10);
    *(_OWORD *)a5 = 0u;
    *(_OWORD *)(a5 + 16) = 0u;
    *(_OWORD *)(a5 + memset(__p, 0, 32) = 0u;
    *(_DWORD *)(a5 + 48) = -1;
  }

uint64_t MachThreadList::GetPThreadT(MachThreadList *this, uint64_t a2)
{
  unint64_t v4 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v5 = *((void *)this + 1) - *(void *)this;
  if (v5)
  {
    unint64_t v6 = v5 >> 4;
    if (v6 <= 1) {
      unint64_t v6 = 1LL;
    }
    uint64_t v7 = (std::__shared_weak_count **)(*(void *)this + 8LL);
    while (1)
    {
      unint64_t v8 = (MachThread *)*(v7 - 1);
      if (*((void *)v8 + 1) == a2) {
        break;
      }
      v7 += 2;
      if (!--v6) {
        goto LABEL_7;
      }
    }

    uint64_t v11 = *v7;
    if (*v7)
    {
      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
    }

    pthread_mutex_unlock(v4);
    uint64_t PThreadT = MachThread::GetPThreadT(v8);
    if (v11)
    {
      size_t v14 = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
  }

  else
  {
LABEL_7:
    pthread_mutex_unlock(v4);
    return -1LL;
  }

  return PThreadT;
}

uint64_t MachThreadList::GetDispatchQueueT(MachThreadList *this, uint64_t a2)
{
  unint64_t v4 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v5 = *((void *)this + 1) - *(void *)this;
  if (v5)
  {
    unint64_t v6 = v5 >> 4;
    if (v6 <= 1) {
      unint64_t v6 = 1LL;
    }
    uint64_t v7 = (std::__shared_weak_count **)(*(void *)this + 8LL);
    while (1)
    {
      unint64_t v8 = (MachThread *)*(v7 - 1);
      if (*((void *)v8 + 1) == a2) {
        break;
      }
      v7 += 2;
      if (!--v6) {
        goto LABEL_7;
      }
    }

    uint64_t v11 = *v7;
    if (*v7)
    {
      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
    }

    pthread_mutex_unlock(v4);
    uint64_t DispatchQueueT = MachThread::GetDispatchQueueT(v8);
    if (v11)
    {
      size_t v14 = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
  }

  else
  {
LABEL_7:
    pthread_mutex_unlock(v4);
    return -1LL;
  }

  return DispatchQueueT;
}

uint64_t MachThreadList::GetTSDAddressForThread( MachThreadList *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v11 = *((void *)this + 1) - *(void *)this;
  if (v11)
  {
    unint64_t v12 = v11 >> 4;
    if (v12 <= 1) {
      unint64_t v12 = 1LL;
    }
    unint64_t v13 = (std::__shared_weak_count **)(*(void *)this + 8LL);
    while (1)
    {
      size_t v14 = (MachThread *)*(v13 - 1);
      if (*((void *)v14 + 1) == a2) {
        break;
      }
      v13 += 2;
      if (!--v12) {
        goto LABEL_7;
      }
    }

    unint64_t v17 = *v13;
    if (*v13)
    {
      p_shared_owners = (unint64_t *)&v17->__shared_owners_;
      do
        unint64_t v19 = __ldxr(p_shared_owners);
      while (__stxr(v19 + 1, p_shared_owners));
    }

    pthread_mutex_unlock(v10);
    uint64_t TSDAddressForThread = MachThread::GetTSDAddressForThread(v14, a3, a4, a5);
    if (v17)
    {
      int v20 = (unint64_t *)&v17->__shared_owners_;
      do
        unint64_t v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
      }
    }
  }

  else
  {
LABEL_7:
    pthread_mutex_unlock(v10);
    return -1LL;
  }

  return TSDAddressForThread;
}

uint64_t MachThreadList::SetCurrentThread(MachThreadList *this, uint64_t a2)
{
  unint64_t v4 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v5 = *((void *)this + 1) - *(void *)this;
  if (v5)
  {
    unint64_t v6 = v5 >> 4;
    if (v6 <= 1) {
      unint64_t v6 = 1LL;
    }
    uint64_t v7 = (std::__shared_weak_count **)(*(void *)this + 8LL);
    while (1)
    {
      uint64_t v8 = (uint64_t)*(v7 - 1);
      if (*(void *)(v8 + 8) == a2) {
        break;
      }
      v7 += 2;
      if (!--v6) {
        goto LABEL_7;
      }
    }

    uint64_t v10 = *v7;
    if (*v7)
    {
      p_shared_owners = (unint64_t *)&v10->__shared_owners_;
      do
        unint64_t v12 = __ldxr(p_shared_owners);
      while (__stxr(v12 + 1, p_shared_owners));
      pthread_mutex_unlock(v4);
      do
        unint64_t v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
    }

    else
    {
      pthread_mutex_unlock(v4);
    }

    size_t v14 = (std::__shared_weak_count *)*((void *)this + 12);
    *((void *)this + 11) = v8;
    *((void *)this + 12) = v10;
    if (v14)
    {
      unint64_t v15 = (unint64_t *)&v14->__shared_owners_;
      do
        unint64_t v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }

    if (v10)
    {
      unint64_t v17 = (unint64_t *)&v10->__shared_owners_;
      do
        unint64_t v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
  }

  else
  {
LABEL_7:
    pthread_mutex_unlock(v4);
    return 0LL;
  }

  return a2;
}

uint64_t MachThreadList::GetThreadStoppedReason(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = (pthread_mutex_t *)(a1 + 24);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 24));
  uint64_t v7 = *(void *)(a1 + 8) - *(void *)a1;
  if (v7)
  {
    unint64_t v8 = v7 >> 4;
    if (v8 <= 1) {
      unint64_t v8 = 1LL;
    }
    unint64_t v9 = (std::__shared_weak_count **)(*(void *)a1 + 8LL);
    while (1)
    {
      uint64_t v10 = (uint64_t)*(v9 - 1);
      if (*(void *)(v10 + 8) == a2) {
        break;
      }
      v9 += 2;
      if (!--v8) {
        goto LABEL_7;
      }
    }

    unint64_t v13 = *v9;
    if (*v9)
    {
      p_shared_owners = (unint64_t *)&v13->__shared_owners_;
      do
        unint64_t v15 = __ldxr(p_shared_owners);
      while (__stxr(v15 + 1, p_shared_owners));
    }

    pthread_mutex_unlock(v6);
    uint64_t StopInfo = MachException::Data::GetStopInfo(v10 + 144, a3);
    if (v13)
    {
      unint64_t v16 = (unint64_t *)&v13->__shared_owners_;
      do
        unint64_t v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
  }

  else
  {
LABEL_7:
    pthread_mutex_unlock(v6);
    return 0LL;
  }

  return StopInfo;
}

BOOL MachThreadList::GetIdentifierInfo(MachThreadList *this, uint64_t a2, thread_identifier_info *a3)
{
  unint64_t v6 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v7 = *(void *)this;
  uint64_t v8 = *((void *)this + 1) - *(void *)this;
  if (v8)
  {
    unint64_t v9 = v8 >> 4;
    if (v9 <= 1) {
      unint64_t v9 = 1LL;
    }
    while (*(void *)(*(void *)v7 + 8LL) != a2)
    {
      v7 += 16LL;
      if (!--v9) {
        goto LABEL_6;
      }
    }

    thread_inspect_t v10 = *(_DWORD *)(*(void *)v7 + 16LL);
  }

  else
  {
LABEL_6:
    thread_inspect_t v10 = 0;
  }

  pthread_mutex_unlock(v6);
  mach_msg_type_number_t thread_info_outCnt = 6;
  return thread_info(v10, 4u, (thread_info_t)a3, &thread_info_outCnt) == 0;
}

char *MachThreadList::GetThreadInfo(MachThreadList *this, uint64_t a2)
{
  unint64_t v4 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v5 = *((void *)this + 1) - *(void *)this;
  if (v5)
  {
    unint64_t v6 = v5 >> 4;
    if (v6 <= 1) {
      unint64_t v6 = 1LL;
    }
    uint64_t v7 = (std::__shared_weak_count **)(*(void *)this + 8LL);
    while (1)
    {
      uint64_t v8 = (MachThread *)*(v7 - 1);
      if (*((void *)v8 + 1) == a2) {
        break;
      }
      v7 += 2;
      if (!--v6) {
        goto LABEL_7;
      }
    }

    uint64_t v11 = *v7;
    if (*v7)
    {
      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
    }

    pthread_mutex_unlock(v4);
    BasicInfoAsString = MachThread::GetBasicInfoAsString(v8);
    if (v11)
    {
      size_t v14 = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
  }

  else
  {
LABEL_7:
    pthread_mutex_unlock(v4);
    return 0LL;
  }

  return BasicInfoAsString;
}

uint64_t MachThreadList::GetThreadIDByMachPortNumber(MachThreadList *this, int a2)
{
  unint64_t v4 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v5 = *(void *)this;
  uint64_t v6 = *((void *)this + 1) - *(void *)this;
  if (v6)
  {
    unint64_t v7 = v6 >> 4;
    if (v7 <= 1) {
      unint64_t v7 = 1LL;
    }
    while (*(_DWORD *)(*(void *)v5 + 16LL) != a2)
    {
      v5 += 16LL;
      if (!--v7) {
        goto LABEL_6;
      }
    }

    uint64_t v8 = *(void *)(*(void *)v5 + 8LL);
  }

  else
  {
LABEL_6:
    uint64_t v8 = 0LL;
  }

  pthread_mutex_unlock(v4);
  return v8;
}

uint64_t MachThreadList::GetRegisterValue(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = (pthread_mutex_t *)(a1 + 24);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 24));
  uint64_t v5 = *(void *)(a1 + 8) - *(void *)a1;
  if (v5)
  {
    unint64_t v6 = v5 >> 4;
    if (v6 <= 1) {
      unint64_t v6 = 1LL;
    }
    unint64_t v7 = (std::__shared_weak_count **)(*(void *)a1 + 8LL);
    while (1)
    {
      uint64_t v8 = (uint64_t)*(v7 - 1);
      if (*(void *)(v8 + 8) == a2) {
        break;
      }
      v7 += 2;
      if (!--v6) {
        goto LABEL_7;
      }
    }

    uint64_t v11 = *v7;
    if (*v7)
    {
      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
    }

    pthread_mutex_unlock(v4);
    uint64_t RegisterValue = MachThread::GetRegisterValue(v8);
    if (v11)
    {
      size_t v14 = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
  }

  else
  {
LABEL_7:
    pthread_mutex_unlock(v4);
    return 0LL;
  }

  return RegisterValue;
}

uint64_t MachThreadList::SetRegisterValue(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = (pthread_mutex_t *)(a1 + 24);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 24));
  uint64_t v5 = *(void *)(a1 + 8) - *(void *)a1;
  if (v5)
  {
    unint64_t v6 = v5 >> 4;
    if (v6 <= 1) {
      unint64_t v6 = 1LL;
    }
    unint64_t v7 = (std::__shared_weak_count **)(*(void *)a1 + 8LL);
    while (1)
    {
      uint64_t v8 = (uint64_t)*(v7 - 1);
      if (*(void *)(v8 + 8) == a2) {
        break;
      }
      v7 += 2;
      if (!--v6) {
        goto LABEL_7;
      }
    }

    uint64_t v11 = *v7;
    if (*v7)
    {
      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
    }

    pthread_mutex_unlock(v4);
    uint64_t v9 = MachThread::SetRegisterValue(v8);
    if (v11)
    {
      size_t v14 = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
  }

  else
  {
LABEL_7:
    pthread_mutex_unlock(v4);
    return 0LL;
  }

  return v9;
}

uint64_t MachThreadList::GetRegisterContext(MachThreadList *this, uint64_t a2, void *a3)
{
  unint64_t v6 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v7 = *((void *)this + 1) - *(void *)this;
  if (v7)
  {
    unint64_t v8 = v7 >> 4;
    if (v8 <= 1) {
      unint64_t v8 = 1LL;
    }
    uint64_t v9 = (std::__shared_weak_count **)(*(void *)this + 8LL);
    while (1)
    {
      thread_inspect_t v10 = (MachThread *)*(v9 - 1);
      if (*((void *)v10 + 1) == a2) {
        break;
      }
      v9 += 2;
      if (!--v8) {
        goto LABEL_7;
      }
    }

    unint64_t v13 = *v9;
    if (*v9)
    {
      p_shared_owners = (unint64_t *)&v13->__shared_owners_;
      do
        unint64_t v15 = __ldxr(p_shared_owners);
      while (__stxr(v15 + 1, p_shared_owners));
    }

    pthread_mutex_unlock(v6);
    uint64_t RegisterContext = MachThread::GetRegisterContext(v10, a3);
    if (v13)
    {
      unint64_t v16 = (unint64_t *)&v13->__shared_owners_;
      do
        unint64_t v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
  }

  else
  {
LABEL_7:
    pthread_mutex_unlock(v6);
    return 0LL;
  }

  return RegisterContext;
}

uint64_t MachThreadList::SetRegisterContext(MachThreadList *this, uint64_t a2, const void *a3)
{
  unint64_t v6 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v7 = *((void *)this + 1) - *(void *)this;
  if (v7)
  {
    unint64_t v8 = v7 >> 4;
    if (v8 <= 1) {
      unint64_t v8 = 1LL;
    }
    uint64_t v9 = (std::__shared_weak_count **)(*(void *)this + 8LL);
    while (1)
    {
      thread_inspect_t v10 = (MachThread *)*(v9 - 1);
      if (*((void *)v10 + 1) == a2) {
        break;
      }
      v9 += 2;
      if (!--v8) {
        goto LABEL_7;
      }
    }

    unint64_t v13 = *v9;
    if (*v9)
    {
      p_shared_owners = (unint64_t *)&v13->__shared_owners_;
      do
        unint64_t v15 = __ldxr(p_shared_owners);
      while (__stxr(v15 + 1, p_shared_owners));
    }

    pthread_mutex_unlock(v6);
    uint64_t v11 = MachThread::SetRegisterContext(v10, a3);
    if (v13)
    {
      unint64_t v16 = (unint64_t *)&v13->__shared_owners_;
      do
        unint64_t v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
  }

  else
  {
LABEL_7:
    pthread_mutex_unlock(v6);
    return 0LL;
  }

  return v11;
}

uint64_t MachThreadList::SaveRegisterState(MachThreadList *this, uint64_t a2)
{
  unint64_t v4 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v5 = *((void *)this + 1) - *(void *)this;
  if (v5)
  {
    unint64_t v6 = v5 >> 4;
    if (v6 <= 1) {
      unint64_t v6 = 1LL;
    }
    uint64_t v7 = (std::__shared_weak_count **)(*(void *)this + 8LL);
    while (1)
    {
      unint64_t v8 = (MachThread *)*(v7 - 1);
      if (*((void *)v8 + 1) == a2) {
        break;
      }
      v7 += 2;
      if (!--v6) {
        goto LABEL_7;
      }
    }

    uint64_t v11 = *v7;
    if (*v7)
    {
      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
    }

    pthread_mutex_unlock(v4);
    uint64_t v9 = MachThread::SaveRegisterState(v8);
    if (v11)
    {
      size_t v14 = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
  }

  else
  {
LABEL_7:
    pthread_mutex_unlock(v4);
    return 0LL;
  }

  return v9;
}

uint64_t MachThreadList::RestoreRegisterState(MachThreadList *this, uint64_t a2)
{
  unint64_t v4 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v5 = *((void *)this + 1) - *(void *)this;
  if (v5)
  {
    unint64_t v6 = v5 >> 4;
    if (v6 <= 1) {
      unint64_t v6 = 1LL;
    }
    uint64_t v7 = (std::__shared_weak_count **)(*(void *)this + 8LL);
    while (1)
    {
      unint64_t v8 = (MachThread *)*(v7 - 1);
      if (*((void *)v8 + 1) == a2) {
        break;
      }
      v7 += 2;
      if (!--v6) {
        goto LABEL_7;
      }
    }

    uint64_t v11 = *v7;
    if (*v7)
    {
      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
    }

    pthread_mutex_unlock(v4);
    uint64_t v9 = MachThread::RestoreRegisterState(v8);
    if (v11)
    {
      size_t v14 = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
  }

  else
  {
LABEL_7:
    pthread_mutex_unlock(v4);
    return 0LL;
  }

  return v9;
}

uint64_t MachThreadList::NumThreads(MachThreadList *this)
{
  thread_inspect_t v2 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v3 = (uint64_t)(*((void *)this + 1) - *(void *)this) >> 4;
  pthread_mutex_unlock(v2);
  return v3;
}

uint64_t MachThreadList::ThreadIDAtIndex(MachThreadList *this, unint64_t a2)
{
  unint64_t v4 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  else {
    uint64_t v5 = *(void *)(*(void *)(*(void *)this + 16 * a2) + 8LL);
  }
  pthread_mutex_unlock(v4);
  return v5;
}

uint64_t MachThreadList::CurrentThreadID(MachThreadList *this)
{
  uint64_t v6 = 0LL;
  uint64_t v7 = 0LL;
  MachThreadList::CurrentThread((uint64_t *)this, &v6);
  if (v6)
  {
    uint64_t v1 = *(void *)(v6 + 8);
    thread_inspect_t v2 = v7;
    if (!v7) {
      return v1;
    }
  }

  else
  {
    uint64_t v1 = 0LL;
    thread_inspect_t v2 = v7;
    if (!v7) {
      return v1;
    }
  }

  p_shared_owners = (unint64_t *)&v2->__shared_owners_;
  do
    unint64_t v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }

  return v1;
}

uint64_t MachThreadList::CurrentThread(uint64_t *a1, void *a2)
{
  unint64_t v4 = (pthread_mutex_t *)(a1 + 3);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 3));
  if (!a1[11])
  {
    uint64_t v13 = *a1;
    uint64_t v14 = a1[1];
    uint64_t v15 = v14 - *a1;
    if (v14 != *a1)
    {
      unint64_t v16 = 0LL;
      unint64_t v17 = v15 >> 4;
      unsigned int v18 = 1;
      while (1)
      {
        unint64_t v19 = *(_DWORD **)(v13 + 16 * v16);
        if (v19[36])
        {
          if (v19[37] && v19[38]) {
            break;
          }
        }

        unint64_t v16 = v18++;
        if (v17 <= v16) {
          goto LABEL_2;
        }
      }

      uint64_t v20 = *(void *)(v13 + 16 * v16 + 8);
      if (v20)
      {
        unint64_t v21 = (unint64_t *)(v20 + 8);
        do
          unint64_t v22 = __ldxr(v21);
        while (__stxr(v22 + 1, v21));
      }

      uint64_t v23 = (std::__shared_weak_count *)a1[12];
      a1[11] = (uint64_t)v19;
      a1[12] = v20;
      if (v23)
      {
        p_shared_owners = (unint64_t *)&v23->__shared_owners_;
        do
          unint64_t v25 = __ldaxr(p_shared_owners);
        while (__stlxr(v25 - 1, p_shared_owners));
        if (!v25)
        {
          ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
          std::__shared_weak_count::__release_weak(v23);
        }
      }
    }
  }

LABEL_2:
  uint64_t v6 = a1[11];
  uint64_t v5 = a1[12];
  if (v5)
  {
    uint64_t v7 = (unint64_t *)(v5 + 8);
    do
      unint64_t v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }

  uint64_t v9 = (std::__shared_weak_count *)a2[1];
  *a2 = v6;
  a2[1] = v5;
  if (v9)
  {
    thread_inspect_t v10 = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

  return pthread_mutex_unlock(v4);
}

uint64_t MachThreadList::NotifyException(MachThreadList *this, MachException::Data *a2)
{
  int v4 = *((_DWORD *)a2 + 1);
  uint64_t v5 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v6 = *((void *)this + 1) - *(void *)this;
  if (v6)
  {
    unint64_t v7 = v6 >> 4;
    if (v7 <= 1) {
      unint64_t v7 = 1LL;
    }
    unint64_t v8 = (std::__shared_weak_count **)(*(void *)this + 8LL);
    while (1)
    {
      uint64_t v9 = (MachThread *)*(v8 - 1);
      if (*((_DWORD *)v9 + 4) == v4) {
        break;
      }
      v8 += 2;
      if (!--v7) {
        goto LABEL_7;
      }
    }

    unint64_t v11 = *v8;
    if (*v8)
    {
      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
      pthread_mutex_unlock(v5);
      MachThread::NotifyException(v9, a2);
      do
        unint64_t v14 = __ldaxr(p_shared_owners);
      while (__stlxr(v14 - 1, p_shared_owners));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }

    else
    {
      pthread_mutex_unlock(v5);
      MachThread::NotifyException(v9, a2);
    }

    return 1LL;
  }

  else
  {
LABEL_7:
    pthread_mutex_unlock(v5);
    return 0LL;
  }

uint64_t MachThreadList::Clear(MachThreadList *this)
{
  thread_inspect_t v2 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v3 = *(void *)this;
  for (uint64_t i = *((void *)this + 1); i != v3; i -= 16LL)
  {
    uint64_t v5 = *(std::__shared_weak_count **)(i - 8);
    if (v5)
    {
      p_shared_owners = (unint64_t *)&v5->__shared_owners_;
      do
        unint64_t v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }

  *((void *)this + 1) = v3;
  return pthread_mutex_unlock(v2);
}

unint64_t MachThreadList::UpdateThreadList(uint64_t *a1, MachProcess *a2, int a3, uint64_t a4)
{
  if (DNBLogEnabledForAny(4)) {
    _DNBLogThreaded( "MachThreadList::UpdateThreadList (unsigned int pid = %4.4x, update = %u) process stop count = %u",  *(_DWORD *)a2,  a3,  *((_DWORD *)a2 + 111));
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 3));
  if (!*((_DWORD *)a2 + 111))
  {
    __p[0] = (void *)0xE00000001LL;
    int v8 = *(_DWORD *)a2;
    LODWORD(__p[1]) = 1;
    HIDWORD(__p[1]) = v8;
    v59[0] = 648LL;
    if (*((_BYTE *)a1 + 104))
    {
      uint64_t v9 = 16777228LL;
    }

    else if (MachProcess::GetCPUType(a2) == 33554444)
    {
      uint64_t v9 = 33554444LL;
    }

    else
    {
      uint64_t v9 = 12LL;
    }

    DNBArchProtocol::SetArchitecture((DNBArchProtocol *)v9, 0);
  }

  uint64_t v11 = *a1;
  uint64_t v10 = a1[1];
  if (*a1 == v10 || a3 != 0)
  {
    thread_act_array_t act_list = 0LL;
    mach_msg_type_number_t act_listCnt = 0;
    task_inspect_t v13 = *((_DWORD *)a2 + 30);
    BOOL v14 = 1;
    v64[0] = task_threads(v13, &act_list, &act_listCnt);
    v64[1] = 1;
    uint64_t v66 = 0LL;
    uint64_t v67 = 0LL;
    uint64_t v65 = 0LL;
    if (DNBLogCheckLogBit(4) || v64[0])
    {
      DNBError::LogThreaded( (DNBError *)v64,  "::task_threads(task = 0x%4.4x, thread_list => %p, thread_list_count => %u)",  v13,  act_list,  act_listCnt);
      BOOL v14 = v64[0] == 0;
    }

    if (v14 && act_listCnt)
    {
      uint64_t v15 = 0LL;
      __p[0] = 0LL;
      __p[1] = 0LL;
      unint64_t v63 = 0LL;
      while (1)
      {
        unsigned int v16 = act_list[v15];
        unint64_t GloballyUniqueThreadIDForMachPortID = MachThread::GetGloballyUniqueThreadIDForMachPortID((MachThread *)v16);
        pthread_mutex_lock((pthread_mutex_t *)(a1 + 3));
        v59[0] = 0LL;
        v59[1] = 0LL;
        uint64_t v18 = a1[1] - *a1;
        if (v18)
        {
          unint64_t v19 = v18 >> 4;
          if (v19 <= 1) {
            unint64_t v19 = 1LL;
          }
          uint64_t v20 = (size_t *)(*a1 + 8);
          while (1)
          {
            size_t v21 = *(v20 - 1);
            if (*(void *)(v21 + 8) == GloballyUniqueThreadIDForMachPortID) {
              break;
            }
            v20 += 2;
            if (!--v19) {
              goto LABEL_36;
            }
          }

          size_t v22 = *v20;
          if (*v20)
          {
            uint64_t v23 = (unint64_t *)(v22 + 8);
            do
              unint64_t v24 = __ldxr(v23);
            while (__stxr(v24 + 1, v23));
          }

          v59[0] = v21;
          v59[1] = v22;
        }

uint64_t MachThreadList::Dump(MachThreadList *this)
{
  thread_inspect_t v2 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v3 = *((void *)this + 1);
  uint64_t v4 = v3 - *(void *)this;
  if (v3 != *(void *)this)
  {
    uint64_t v5 = 0LL;
    unsigned int v6 = 0;
    unint64_t v7 = v4 >> 4;
    do
    {
      MachThread::Dump(*(MachThread **)(*(void *)this + 16 * v5), v6++);
      uint64_t v5 = v6;
    }

    while (v7 > v6);
  }

  return pthread_mutex_unlock(v2);
}

uint64_t MachThreadList::ProcessWillResume( MachThreadList *this, MachProcess *a2, const DNBThreadResumeActions *a3)
{
  unsigned int v6 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  __int128 __p = 0LL;
  __int128 v47 = 0LL;
  uint64_t v48 = 0LL;
  if (*((void *)a3 + 1) == *(void *)a3
    || (uint64_t v7 = DNBThreadResumeActions::NumActionsWithState((uint64_t *)a3, 6),
        DNBThreadResumeActions::NumActionsWithState((uint64_t *)a3, 5) + v7 != 1))
  {
    MachThreadList::UpdateThreadList((uint64_t *)this, a2, 1, (uint64_t)&__p);
    uint64_t v11 = 0LL;
    __int128 v44 = xmmword_1000520A0;
    uint64_t v45 = -1LL;
  }

  else
  {
    uint64_t v8 = *((void *)a3 + 1) - *(void *)a3;
    if (v8)
    {
      unint64_t v9 = v8 / 24;
      if (v9 <= 1) {
        unint64_t v9 = 1LL;
      }
      uint64_t v10 = (_DWORD *)(*(void *)a3 + 8LL);
      while ((*v10 - 5) > 1)
      {
        v10 += 6;
        if (!--v9) {
          goto LABEL_9;
        }
      }

      uint64_t v11 = *((void *)v10 - 1);
    }

    else
    {
LABEL_9:
      uint64_t v11 = 0LL;
    }

    MachThreadList::UpdateThreadList((uint64_t *)this, a2, 1, (uint64_t)&__p);
    __int128 v44 = xmmword_1000520A0;
    uint64_t v45 = -1LL;
    DWORD2(v44) = 10;
  }

  task_inspect_t v13 = __p;
  unint64_t v12 = v47;
  unint64_t v14 = (v47 - (_BYTE *)__p) >> 4;
  uint64_t v15 = *((void *)this + 1);
  uint64_t v16 = v15 - *(void *)this;
  if (v15 == *(void *)this)
  {
    unint64_t v28 = (char *)__p;
    int v27 = v47;
  }

  else
  {
    timeval v43 = v6;
    uint64_t v17 = 0LL;
    unsigned int v18 = 0;
    unint64_t v19 = v16 >> 4;
    do
    {
      uint64_t v23 = *(void *)(*(void *)this + 16 * v17);
      if (v12 == v13)
      {
LABEL_21:
        ActionForThread = (__int128 *)DNBThreadResumeActions::GetActionForThread(a3, *(void *)(v23 + 8), 1);
        if (!ActionForThread) {
          MachThreadList::ProcessWillResume();
        }
        uint64_t v20 = ActionForThread;
        BOOL v22 = v11 == *(void *)(v23 + 8);
        uint64_t v21 = v23;
      }

      else
      {
        unint64_t v24 = 0LL;
        unsigned int v25 = 1;
        while (v23 != *((void *)__p + 2 * v24))
        {
          unint64_t v24 = v25++;
          if (v14 <= v24) {
            goto LABEL_21;
          }
        }

        uint64_t v20 = &v44;
        uint64_t v21 = v23;
        BOOL v22 = 0;
      }

      MachThread::ThreadWillResume(v21, (uint64_t)v20, v22);
      uint64_t v17 = ++v18;
    }

    while (v19 > v18);
    unint64_t v28 = (char *)__p;
    int v27 = v47;
    unsigned int v6 = v43;
  }

  if (v27 != v28 && v12 != v13)
  {
    unint64_t v30 = 0LL;
    unsigned int v31 = 1;
    do
    {
      if (DNBLogEnabledForAny(4))
      {
        uint64_t v32 = (MachThread *)*((void *)__p + 2 * v30);
        uint64_t v33 = *((void *)v32 + 1);
        int v34 = *(_DWORD *)a2;
        int v35 = *((_DWORD *)a2 + 111);
        BOOL IsUserReady = MachThread::IsUserReady(v32);
        _DNBLogThreaded( "MachThreadList::ProcessWillResume (unsigned int pid = %4.4x) stop-id=%u, resuming newly discovered thread: 0x%8.8llx, threa d-is-user-ready=%i)",  v34,  v35,  v33,  IsUserReady);
      }

      unint64_t v30 = v31++;
    }

    while (v14 > v30);
    unint64_t v28 = (char *)__p;
  }

  if (v28)
  {
    unint64_t v37 = v47;
    uint64_t v38 = v28;
    if (v47 != v28)
    {
      do
      {
        size_t v39 = (std::__shared_weak_count *)*((void *)v37 - 1);
        if (v39)
        {
          p_shared_owners = (unint64_t *)&v39->__shared_owners_;
          do
            unint64_t v41 = __ldaxr(p_shared_owners);
          while (__stlxr(v41 - 1, p_shared_owners));
          if (!v41)
          {
            ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
            std::__shared_weak_count::__release_weak(v39);
          }
        }

        v37 -= 16;
      }

      while (v37 != v28);
      uint64_t v38 = __p;
    }

    __int128 v47 = v28;
    operator delete(v38);
  }

  return pthread_mutex_unlock(v6);
}

unint64_t MachThreadList::ProcessDidStop(MachThreadList *this, MachProcess *a2)
{
  uint64_t v4 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  unint64_t updated = MachThreadList::UpdateThreadList((uint64_t *)this, a2, 1, 0LL);
  unint64_t v6 = updated;
  if ((_DWORD)updated)
  {
    uint64_t v7 = 0LL;
    uint64_t v8 = 16LL * updated;
    do
    {
      MachThread::ThreadDidStop(*(MachThread **)(*(void *)this + v7));
      v7 += 16LL;
    }

    while (v8 != v7);
  }

  pthread_mutex_unlock(v4);
  return v6;
}

BOOL MachThreadList::ShouldStop(MachThreadList *this, BOOL *a2)
{
  uint64_t v4 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v5 = *((void *)this + 1);
  uint64_t v6 = v5 - *(void *)this;
  if (v5 == *(void *)this)
  {
    BOOL ShouldStop = 0LL;
  }

  else
  {
    unint64_t v7 = 0LL;
    unint64_t v8 = v6 >> 4;
    unsigned int v9 = 1;
    do
    {
      BOOL ShouldStop = MachThread::ShouldStop(*(MachThread **)(*(void *)this + 16 * v7), a2);
      if (ShouldStop) {
        break;
      }
      unint64_t v7 = v9++;
    }

    while (v8 > v7);
  }

  pthread_mutex_unlock(v4);
  return ShouldStop;
}

uint64_t MachThreadList::NotifyBreakpointChanged(uint64_t a1)
{
  uint64_t v1 = (pthread_mutex_t *)(a1 + 24);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 24));
  return pthread_mutex_unlock(v1);
}

uint64_t MachThreadList::DoHardwareBreakpointAction(uint64_t a1, uint64_t a2, int a3)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v6 = (pthread_mutex_t *)(a1 + 24);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 24));
  unint64_t v8 = *(uint64_t **)a1;
  unint64_t v7 = *(uint64_t **)(a1 + 8);
  uint64_t v9 = (uint64_t)v7 - *(void *)a1;
  unint64_t v10 = v9 >> 4;
  if (v7 != *(uint64_t **)a1)
  {
    switch(a3)
    {
      case 0:
        uint64_t v11 = MachThread::EnableHardwareWatchpoint(*v8, a2, 1LL);
        goto LABEL_10;
      case 1:
        uint64_t v13 = MachThread::DisableHardwareWatchpoint(*v8, a2);
        goto LABEL_13;
      case 2:
        uint64_t v11 = MachThread::EnableHardwareBreakpoint(*v8, a2, 1LL);
LABEL_10:
        uint64_t v12 = v11;
        if ((_DWORD)v11 == -1) {
          goto LABEL_29;
        }
        goto LABEL_14;
      case 3:
        uint64_t v13 = MachThread::DisableHardwareBreakpoint(*v8, a2);
LABEL_13:
        uint64_t v12 = v13;
LABEL_14:
        uint64_t v21 = v6;
        if ((unint64_t)v9 >= 0x11)
        {
          unint64_t v14 = 1LL;
          while (2)
          {
            switch(a3)
            {
              case 0:
                uint64_t v16 = MachThread::EnableHardwareWatchpoint(*(void *)(*(void *)a1 + 16 * v14), a2, 0LL);
                goto LABEL_22;
              case 1:
                uint64_t v15 = MachThread::DisableHardwareWatchpoint(*(void *)(*(void *)a1 + 16 * v14), a2);
                goto LABEL_17;
              case 2:
                uint64_t v16 = MachThread::EnableHardwareBreakpoint(*(void *)(*(void *)a1 + 16 * v14), a2, 0LL);
LABEL_22:
                uint64_t v12 = v16;
                if ((_DWORD)v16 != -1) {
                  goto LABEL_18;
                }
                if ((_DWORD)v14)
                {
                  uint64_t v20 = 0LL;
                  do
                  {
                    MachThread::RollbackTransForHWP(*(MachThread **)(*(void *)a1 + v20));
                    v20 += 16LL;
                  }

                  while (16LL * v14 != v20);
                }

                uint64_t v12 = 0xFFFFFFFFLL;
                goto LABEL_28;
              case 3:
                uint64_t v15 = MachThread::DisableHardwareBreakpoint(*(void *)(*(void *)a1 + 16 * v14), a2);
LABEL_17:
                uint64_t v12 = v15;
                goto LABEL_18;
              default:
LABEL_18:
                unint64_t v14 = (v14 + 1);
                if (v10 > v14) {
                  continue;
                }
                goto LABEL_25;
            }
          }
        }

        goto LABEL_25;
      default:
        uint64_t v12 = 0xFFFFFFFFLL;
        goto LABEL_29;
    }
  }

  uint64_t v21 = v6;
  uint64_t v12 = 0xFFFFFFFFLL;
LABEL_25:
  if (v7 != v8)
  {
    unint64_t v17 = 0LL;
    unsigned int v18 = 1;
    do
    {
      MachThread::FinishTransForHWP(*(MachThread **)(*(void *)a1 + 16 * v17));
      unint64_t v17 = v18++;
    }

    while (v10 > v17);
  }

uint64_t MachThreadList::EnableHardwareWatchpoint(uint64_t a1, uint64_t a2)
{
  return MachThreadList::DoHardwareBreakpointAction(a1, a2, 0);
}

BOOL MachThreadList::DisableHardwareWatchpoint(uint64_t a1, uint64_t a2)
{
  return MachThreadList::DoHardwareBreakpointAction(a1, a2, 1) != -1;
}

uint64_t MachThreadList::EnableHardwareBreakpoint(uint64_t a1, uint64_t a2)
{
  return MachThreadList::DoHardwareBreakpointAction(a1, a2, 2);
}

BOOL MachThreadList::DisableHardwareBreakpoint(uint64_t a1, uint64_t a2)
{
  return MachThreadList::DoHardwareBreakpointAction(a1, a2, 3) != -1;
}

uint64_t MachThreadList::NumSupportedHardwareWatchpoints(MachThread ***this)
{
  thread_inspect_t v2 = (pthread_mutex_t *)(this + 3);
  pthread_mutex_lock((pthread_mutex_t *)(this + 3));
  if (this[1] == *this) {
    uint64_t v3 = 0LL;
  }
  else {
    uint64_t v3 = MachThread::NumSupportedHardwareWatchpoints(**this);
  }
  pthread_mutex_unlock(v2);
  return v3;
}

uint64_t MachThreadList::GetThreadIndexForThreadStoppedWithSignal(MachThreadList *this, int a2)
{
  uint64_t v4 = (pthread_mutex_t *)((char *)this + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
  uint64_t v5 = *(void *)this;
  uint64_t v6 = *((void *)this + 1) - *(void *)this;
  if (v6)
  {
    unint64_t v7 = 0LL;
    uint64_t v8 = 0LL;
    unint64_t v9 = v6 >> 4;
    do
    {
      uint64_t v10 = *(void *)(v5 + 16 * v7);
      if (*(_DWORD *)(v10 + 152) == 5
        && (v12 = v10 + 160, uint64_t v11 = *(void *)(v10 + 160), *(void *)(v12 + 8) - v11 == 16)
        && *(void *)v11 == 65539LL)
      {
        if (*(_DWORD *)(v11 + 8) == a2) {
          goto LABEL_11;
        }
      }

      else if (!a2)
      {
        goto LABEL_11;
      }

      unint64_t v7 = (v8 + 1);
      uint64_t v8 = v7;
    }

    while (v9 > v7);
  }

  uint64_t v8 = 0xFFFFFFFFLL;
LABEL_11:
  pthread_mutex_unlock(v4);
  return v8;
}

void std::__shared_ptr_emplace<MachThread>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_100061600;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<MachThread>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_100061600;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_emplace<MachThread>::__on_zero_shared(uint64_t a1)
{
}

void MachVMMemory::MachVMMemory(MachVMMemory *this)
{
  *(void *)this = -1LL;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
}

void MachVMMemory::~MachVMMemory(void **this)
{
}

uint64_t MachVMMemory::PageSize(vm_size_t *this, task_name_t target_task)
{
  kern_return_t v4;
  BOOL v5;
  mach_port_t v6;
  kern_return_t v7;
  integer_t task_info_out[3];
  int v9;
  mach_msg_type_number_t task_info_outCnt;
  uint64_t result = *this;
  if (result != -1) {
    return result;
  }
  if (target_task)
  {
    mach_msg_type_number_t task_info_outCnt = 93;
    uint64_t v4 = task_info(target_task, 0x16u, task_info_out, &task_info_outCnt);
    uint64_t v5 = DNBLogEnabledForAny(0x2000);
    if (!v4)
    {
      if (v5) {
        _DNBLogThreaded("MachVMMemory::PageSize task_info returned page size of 0x%x", v9);
      }
      uint64_t result = v9;
      *this = v9;
      return result;
    }

    if (v5) {
      _DNBLogThreaded( "MachVMMemory::PageSize task_info call failed to get page size, TASK_VM_INFO %d, TASK_VM_INFO_COUNT %d, kern return %d",  22,  93,  v4);
    }
  }

  uint64_t v6 = mach_host_self();
  unint64_t v7 = host_page_size(v6, this);
  *((_DWORD *)this + 2) = v7;
  *((_DWORD *)this + 3) = 1;
  if (*((char *)this + 39) < 0)
  {
    *(_BYTE *)this[2] = 0;
    this[3] = 0LL;
    if (*((_DWORD *)this + 2)) {
      goto LABEL_8;
    }
  }

  else
  {
    *((_BYTE *)this + 16) = 0;
    *((_BYTE *)this + 39) = 0;
    if (v7)
    {
LABEL_8:
      uint64_t result = 0LL;
      *this = 0LL;
      return result;
    }
  }

  return *this;
}

void get_dirty_pages(uint64_t a1@<X0>, uint64_t a2@<X1>, char **a3@<X8>)
{
  uint64_t v43 = a2;
  vm_map_read_t v42 = a1;
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  __chkstk_darwin(a1);
  uint64_t v6 = (char *)&v39 - v5;
  uint64_t v41 = v7;
  unint64_t v8 = v7 + 4095LL;
  if (v8 >= 0x1000)
  {
    unint64_t v9 = 0LL;
    uint64_t v10 = 0LL;
    mach_vm_size_t v11 = v4;
    uint64_t v12 = v8 >> 12;
    if (v8 >> 12 <= 1) {
      uint64_t v12 = 1LL;
    }
    uint64_t v39 = v12;
    mach_vm_size_t v40 = v11;
    uint64_t v45 = (char *)&v39 - v5;
    while (1)
    {
      mach_vm_size_t v13 = v41 - (v10 << 12);
      if (v13 >= v40) {
        mach_vm_size_t v13 = v40;
      }
      mach_vm_size_t dispositions_count = v13;
      mach_vm_offset_t v14 = v43 + vm_page_size * (v10 << 12);
      if (mach_vm_page_range_query(v42, v14, vm_page_size * v13, (mach_vm_address_t)v6, &dispositions_count)) {
        return;
      }
      uint64_t v44 = v10;
      mach_vm_size_t v15 = dispositions_count;
      if (dispositions_count) {
        break;
      }
LABEL_6:
      uint64_t v10 = v44 + 1;
      if (v44 + 1 == v39) {
        return;
      }
    }

    uint64_t v16 = 0LL;
    unint64_t v17 = *a3;
    vm_size_t v18 = vm_page_size;
    mach_vm_offset_t v46 = v14;
    while (1)
    {
      if ((*(_DWORD *)&v6[4 * v16] & 8) == 0) {
        goto LABEL_14;
      }
      mach_vm_offset_t v20 = v14 + v18 * v16;
      unint64_t v21 = (unint64_t)a3[2];
      *(void *)unint64_t v9 = v20;
      unint64_t v19 = v9 + 8;
LABEL_13:
      a3[1] = v19;
      mach_vm_size_t v15 = dispositions_count;
      unint64_t v9 = v19;
LABEL_14:
      if (++v16 >= v15) {
        goto LABEL_6;
      }
    }

    uint64_t v22 = (v9 - v17) >> 3;
    unint64_t v23 = v22 + 1;
    uint64_t v24 = v21 - (void)v17;
    if (v24 >> 2 > v23) {
      unint64_t v23 = v24 >> 2;
    }
    else {
      unint64_t v25 = v23;
    }
    if (v25)
    {
      if (v25 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      vm_size_t v26 = v18;
      int v27 = operator new(8 * v25);
      vm_size_t v18 = v26;
    }

    else
    {
      int v27 = 0LL;
    }

    unint64_t v28 = (mach_vm_offset_t *)&v27[8 * v22];
    *unint64_t v28 = v20;
    unint64_t v19 = (char *)(v28 + 1);
    if (v9 == v17) {
      goto LABEL_40;
    }
    unint64_t v29 = v9 - v17 - 8;
    if (v29 < 0x168)
    {
      unint64_t v30 = v9;
      goto LABEL_39;
    }

    unint64_t v31 = (v9 - 8 - v17) & 0xFFFFFFFFFFFFFFF8LL;
    if (&v27[v9 - v17 - 8 - v31] > &v27[v9 - v17 - 8])
    {
      unint64_t v30 = v9;
    }

    else
    {
      if (&v9[-v31 - 8] <= v9 - 8)
      {
        if ((unint64_t)(v17 - v27) < 0x20)
        {
          unint64_t v30 = v9;
          goto LABEL_39;
        }

        uint64_t v32 = (v29 >> 3) + 1;
        uint64_t v33 = 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        unint64_t v30 = &v9[-v33];
        unint64_t v28 = (mach_vm_offset_t *)((char *)v28 - v33);
        int v34 = &v27[8 * v22 - 16];
        int v35 = v9 - 16;
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          __int128 v37 = *(_OWORD *)v35;
          *(v34 - 1) = *((_OWORD *)v35 - 1);
          _OWORD *v34 = v37;
          v34 -= 2;
          v35 -= 32;
          v36 -= 4LL;
        }

        while (v36);
        if (v32 != (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_39;
        }
LABEL_40:
        *a3 = (char *)v28;
        a3[1] = v19;
        a3[2] = &v27[8 * v25];
        if (v17)
        {
          operator delete(v17);
          vm_size_t v18 = vm_page_size;
        }

        unint64_t v17 = (char *)v28;
        uint64_t v6 = v45;
        mach_vm_offset_t v14 = v46;
        goto LABEL_13;
      }

      unint64_t v30 = v9;
    }

    do
    {
LABEL_39:
      mach_vm_offset_t v38 = *((void *)v30 - 1);
      v30 -= 8;
      *--unint64_t v28 = v38;
    }

    while (v30 != v17);
    goto LABEL_40;
  }

uint64_t MachVMMemory::GetMemoryRegionInfo(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  if (MachVMRegion::GetRegionForAddress((MachVMRegion *)v15, a3))
  {
    *(_OWORD *)a4 = v17;
    *(_DWORD *)(a4 + 16) = MachVMRegion::GetDNBPermissions((MachVMRegion *)v15);
    get_dirty_pages(a2, v17, (char **)&v13);
    int v7 = *(void **)(a4 + 24);
    if (v7)
    {
      *(void *)(a4 + memset(__p, 0, 32) = v7;
      operator delete(v7);
    }

    *(_OWORD *)(a4 + 24) = v13;
    *(void *)(a4 + 40) = v14;
    MachVMRegion::GetMemoryTypes((MachVMRegion *)v15, (uint64_t)&v13);
    uint64_t v8 = *(void *)(a4 + 48);
    if (v8)
    {
      uint64_t v9 = *(void *)(a4 + 56);
      uint64_t v10 = *(void **)(a4 + 48);
      if (v9 != v8)
      {
        do
        {
          v9 -= 24LL;
        }

        while (v9 != v8);
        uint64_t v10 = *(void **)(a4 + 48);
      }

      *(void *)(a4 + 56) = v8;
      operator delete(v10);
    }

    *(_OWORD *)(a4 + 48) = v13;
    *(void *)(a4 + 64) = v14;
  }

  else
  {
    *(void *)a4 = a3;
    *(void *)(a4 + 8) = v11;
    *(_DWORD *)(a4 + 16) = 0;
  }

  MachVMRegion::~MachVMRegion((MachVMRegion *)v15);
  return 1LL;
}

uint64_t MachVMMemory::GetMemoryProfile( int a1, __int16 a2, task_name_t a3, int a4, int a5, uint64_t a6, host_info64_t host_info64_out, void *a8, void *a9, void *a10, void *a11)
{
  if ((a2 & 0x20) != 0)
  {
    if (GetPhysicalMemory(void)::calculated != 1)
    {
      v18[0] = 8LL;
      sysctlbyname("hw.memsize", &GetPhysicalMemory(void)::physical_memory, v18, 0LL, 0LL);
      GetPhysicalMemory(void)::calculated = 1;
    }

    *a8 = GetPhysicalMemory(void)::physical_memory;
  }

  if ((a2 & 0x40) == 0) {
    goto LABEL_8;
  }
  if ((v16 & 1) == 0
  {
    MachVMMemory::GetMemoryProfile(DNBProfileDataScanType,unsigned int,task_basic_info,int,int,vm_statistics64 &,unsigned long long &,unsigned long long &,unsigned long long &,unsigned long long &)::localHost = mach_host_self();
  }

  mach_msg_type_number_t host_info64_outCnt = 38;
  host_statistics64( MachVMMemory::GetMemoryProfile(DNBProfileDataScanType,unsigned int,task_basic_info,int,int,vm_statistics64 &,unsigned long long &,unsigned long long &,unsigned long long &,unsigned long long &)::localHost,  4,  host_info64_out,  &host_info64_outCnt);
  mach_msg_type_number_t task_info_outCnt = 93;
  if (task_info(a3, 0x17u, (task_info_t)v18, &task_info_outCnt))
  {
LABEL_8:
    if ((a2 & 0x8000) == 0) {
      return 1LL;
    }
    goto LABEL_9;
  }

  if ((a2 & 0x100) != 0) {
    *a9 = v18[15] + v18[6] - v18[12];
  }
  *a10 = v18[18];
  if (a2 < 0)
  {
LABEL_9:
    v18[0] = 0LL;
    v18[1] = 0LL;
  }

  return 1LL;
}

unint64_t MachVMMemory::Read( vm_size_t *this, task_name_t target_task, mach_vm_address_t a3, char *a4, unint64_t a5)
{
  unint64_t v5 = 0LL;
  if (a4 && a5)
  {
    int v7 = a4;
    unint64_t v5 = 0LL;
    unint64_t v11 = (DNBError *)(this + 1);
    do
    {
      mach_vm_size_t v14 = a5 - v5;
      unint64_t v15 = MachVMMemory::PageSize(this, target_task);
      if (v15 && v15 + a3 / v15 * v15 - a3 < v14) {
        mach_vm_size_t v14 = v15 + a3 / v15 * v15 - a3;
      }
      LODWORD(__n) = 0;
      __src = 0LL;
      *((_DWORD *)this + 2) = mach_vm_read(target_task, a3, v14, (vm_offset_t *)&__src, (mach_msg_type_number_t *)&__n);
      *((_DWORD *)this + 3) = 1;
      if (*((char *)this + 39) < 0)
      {
        *(_BYTE *)this[2] = 0;
        this[3] = 0LL;
      }

      else
      {
        *((_BYTE *)this + 16) = 0;
        *((_BYTE *)this + 39) = 0;
      }

      if (DNBLogCheckLogBit(32)) {
        DNBError::LogThreaded( v11,  "::mach_vm_read(task = 0x%4.4x, addr = 0x%8.8llx, std::string::size_type size = %llu, data => %8.8p, dataCnt => %i)",  target_task,  a3,  v14,  __src,  __n);
      }
      if (*(_DWORD *)v11) {
        break;
      }
      unsigned int v16 = __n;
      if (v14 != __n)
      {
        BOOL v17 = DNBLogCheckLogBit(32);
        unsigned int v16 = __n;
        if (v17)
        {
          DNBError::LogThreaded( v11,  "::mach_vm_read(task = 0x%4.4x, addr = 0x%8.8llx, std::string::size_type size = %llu, data => %8.8p, dataCnt=>%i) only read %u of %llu bytes",  target_task,  a3,  v14,  __src,  __n,  __n,  v14);
          unsigned int v16 = __n;
        }
      }

      uint64_t v12 = __src;
      vm_size_t v13 = v16;
      memcpy(v7, __src, v16);
      vm_deallocate(mach_task_self_, (vm_address_t)v12, v13);
      v5 += __n;
      a3 += __n;
      v7 += __n;
    }

    while (v5 < a5);
  }

  return v5;
}

unint64_t MachVMMemory::Write( vm_size_t *this, task_name_t a2, mach_vm_address_t a3, char *a4, unint64_t a5)
{
  unint64_t v10 = 0LL;
  if (a5)
  {
    mach_vm_address_t v11 = a3;
    while (MachVMRegion::GetRegionForAddress((MachVMRegion *)v16, v11))
    {
      if (v17 > v11) {
        goto LABEL_18;
      }
      if (v18 + v17 <= v11) {
        goto LABEL_18;
      }
      mach_vm_address_t v12 = v18 + v17 - v11;
      if (!v12) {
        goto LABEL_18;
      }
      if (a5 - v10 >= v12) {
        mach_vm_size_t v13 = v18 + v17 - v11;
      }
      else {
        mach_vm_size_t v13 = a5 - v10;
      }
      if (!MachVMRegion::SetProtections((MachVMRegion *)v16, v11, v13, 3))
      {
        if (DNBLogEnabledForAny(256)) {
          _DNBLogThreaded("Failed to set read/write protections on region for address: [0x%8.8llx-0x%8.8llx)");
        }
        goto LABEL_18;
      }

      unint64_t v14 = MachVMMemory::WriteRegion(this, a2, v11, a4, v13);
      if (v14)
      {
        v10 += v14;
        v11 += v14;
        a4 += v14;
        if (v10 < a5) {
          continue;
        }
      }

      goto LABEL_18;
    }

    if (DNBLogEnabledForAny(256)) {
      _DNBLogThreaded("Failed to get region for address: 0x%8.8llx");
    }
  }

unint64_t MachVMMemory::WriteRegion( vm_size_t *this, task_name_t target_task, mach_vm_address_t a3, char *a4, unint64_t a5)
{
  unint64_t v5 = 0LL;
  if (a4 && a5)
  {
    int v7 = a4;
    unint64_t v5 = 0LL;
    mach_vm_address_t v11 = (DNBError *)(this + 1);
    do
    {
      unint64_t v12 = a5 - v5;
      unint64_t v13 = MachVMMemory::PageSize(this, target_task);
      if (v13 && v13 + a3 / v13 * v13 - a3 < v12) {
        unint64_t v12 = v13 + a3 / v13 * v13 - a3;
      }
      *((_DWORD *)this + 2) = mach_vm_write(target_task, a3, (vm_offset_t)v7, v12);
      *((_DWORD *)this + 3) = 1;
      if (*((char *)this + 39) < 0)
      {
        *(_BYTE *)this[2] = 0;
        this[3] = 0LL;
      }

      else
      {
        *((_BYTE *)this + 16) = 0;
        *((_BYTE *)this + 39) = 0;
      }

      if (DNBLogCheckLogBit(32) || *(_DWORD *)v11) {
        DNBError::LogThreaded( v11,  "::mach_vm_write(task = 0x%4.4x, addr = 0x%8.8llx, int data = %8.8p, dataCnt = %u)",  target_task,  a3,  v7,  v12);
      }
      vm_machine_attribute_val_t value = 6;
      *((_DWORD *)this + 2) = vm_machine_attribute(target_task, a3, v12, 1u, &value);
      *((_DWORD *)this + 3) = 1;
      if (*((char *)this + 39) < 0)
      {
        *(_BYTE *)this[2] = 0;
        this[3] = 0LL;
      }

      else
      {
        *((_BYTE *)this + 16) = 0;
        *((_BYTE *)this + 39) = 0;
      }

      if (DNBLogCheckLogBit(32) || *(_DWORD *)v11)
      {
        DNBError::LogThreaded( v11,  "::vm_machine_attribute(task = 0x%4.4x, addr = 0x%8.8llx, std::string::size_type size = %u, attr = MATTR_CACHE, mattr_value => MATTR _VAL_CACHE_FLUSH)",  target_task,  a3,  v12);
        if (*(_DWORD *)v11) {
          break;
        }
      }

      v5 += v12;
      a3 += v12;
      v7 += v12;
    }

    while (v5 < a5);
  }

  return v5;
}

void MachVMRegion::MachVMRegion(MachVMRegion *this, int a2)
{
  *(_DWORD *)this = a2;
  *((void *)this + 1) = -1LL;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = xmmword_1000520C0;
  *((_DWORD *)this + 16) = -1;
  *((_DWORD *)this + 29) = 0;
  *(_OWORD *)((char *)this + 120) = xmmword_1000520C0;
  *(_OWORD *)((char *)this + 68) = 0u;
  *(_OWORD *)((char *)this + 84) = 0u;
  *(_OWORD *)((char *)this + 100) = 0u;
}

void MachVMRegion::~MachVMRegion(MachVMRegion *this)
{
  *((void *)this + 1) = -1LL;
  *((void *)this + 2) = 0LL;
  if (*((char *)this + 47) < 0)
  {
    **((_BYTE **)this + 3) = 0;
    *((void *)this + 4) = 0LL;
    int v2 = *((char *)this + 47);
    *((_OWORD *)this + 3) = xmmword_1000520C0;
    *((_DWORD *)this + 16) = -1;
    *(_OWORD *)((char *)this + 68) = 0u;
    *(_OWORD *)((char *)this + 84) = 0u;
    *(_OWORD *)((char *)this + 100) = 0u;
    *((_DWORD *)this + 29) = 0;
    *(_OWORD *)((char *)this + 120) = xmmword_1000520C0;
    if (v2 < 0) {
      operator delete(*((void **)this + 3));
    }
  }

  else
  {
    *((_BYTE *)this + 24) = 0;
    *((_BYTE *)this + 47) = 0;
    *((_OWORD *)this + 3) = xmmword_1000520C0;
    *((_DWORD *)this + 16) = -1;
    *(_OWORD *)((char *)this + 68) = 0u;
    *(_OWORD *)((char *)this + 84) = 0u;
    *(_OWORD *)((char *)this + 100) = 0u;
    *((_DWORD *)this + 29) = 0;
    *(_OWORD *)((char *)this + 120) = xmmword_1000520C0;
  }

uint64_t MachVMRegion::RestoreProtections(MachVMRegion *this)
{
  vm_prot_t v2 = *((_DWORD *)this + 17);
  if (*((_DWORD *)this + 29) == v2 || (mach_vm_size_t v3 = *((void *)this + 16)) == 0)
  {
    *((void *)this + 2) = 0LL;
    if (*((char *)this + 47) < 0)
    {
      **((_BYTE **)this + 3) = 0;
      *((void *)this + 4) = 0LL;
    }

    else
    {
      *((_BYTE *)this + 24) = 0;
      *((_BYTE *)this + 47) = 0;
    }
  }

  else
  {
    *((_DWORD *)this + 4) = mach_vm_protect(*(_DWORD *)this, *((void *)this + 15), v3, 0, v2);
    *((_DWORD *)this + 5) = 1;
    if (*((char *)this + 47) < 0)
    {
      **((_BYTE **)this + 3) = 0;
      *((void *)this + 4) = 0LL;
    }

    else
    {
      *((_BYTE *)this + 24) = 0;
      *((_BYTE *)this + 47) = 0;
    }

    if (DNBLogCheckLogBit(256) || *((_DWORD *)this + 4))
    {
      DNBError::LogThreaded( (MachVMRegion *)((char *)this + 16),  "::mach_vm_protect(task = 0x%4.4x, addr = 0x%8.8llx, std::string::size_type size = %llu, set_max = %i, prot = %u)",  *(_DWORD *)this,  *((void *)this + 15),  *((void *)this + 16),  0,  *((_DWORD *)this + 17));
      if (*((_DWORD *)this + 4)) {
        return 0LL;
      }
    }

    *(_OWORD *)((char *)this + 120) = xmmword_1000520C0;
    *((_DWORD *)this + 29) = *((_DWORD *)this + 17);
  }

  return 1LL;
}

BOOL MachVMRegion::SetProtections( MachVMRegion *this, mach_vm_address_t address, mach_vm_size_t a3, vm_prot_t new_protection)
{
  mach_vm_address_t v4 = *((void *)this + 6);
  if (v4 > address) {
    return 0LL;
  }
  uint64_t v7 = *((void *)this + 7);
  if (v7 + v4 <= address) {
    return 0LL;
  }
  if (v4 - address + v7 >= a3) {
    mach_vm_size_t v8 = a3;
  }
  else {
    mach_vm_size_t v8 = v4 - address + v7;
  }
  if (!v8)
  {
    BOOL result = DNBLogEnabledForAny(257);
    if (!result) {
      return result;
    }
    _DNBLogThreaded("%s: Zero size for task 0x%4.4x at address 0x%8.8llx) ", "SetProtections", *(_DWORD *)this, address);
    return 0LL;
  }

  if ((*((_DWORD *)this + 29) & 7) != new_protection)
  {
    *((_DWORD *)this + 4) = mach_vm_protect(*(_DWORD *)this, address, v8, 0, new_protection);
    *((_DWORD *)this + 5) = 1;
    mach_vm_address_t v11 = (_DWORD *)((char *)this + 16);
    if (*((char *)this + 47) < 0)
    {
      **((_BYTE **)this + 3) = 0;
      *((void *)this + 4) = 0LL;
    }

    else
    {
      *((_BYTE *)this + 24) = 0;
      *((_BYTE *)this + 47) = 0;
    }

    if (DNBLogCheckLogBit(256)) {
      DNBError::LogThreaded( (MachVMRegion *)((char *)this + 16),  "::mach_vm_protect(task = 0x%4.4x, addr = 0x%8.8llx, std::string::size_type size = %llu, set_max = %i, prot = %u)",  *(_DWORD *)this,  address,  v8,  0,  new_protection);
    }
    if (!*v11
      || ((*((_DWORD *)this + 4) = mach_vm_protect(*(_DWORD *)this, address, v8, 0, new_protection | 0x10),
           *((_DWORD *)this + 5) = 1,
           *((char *)this + 47) < 0)
        ? (**((_BYTE **)this + 3) = 0, *((void *)this + 4) = 0LL)
        : (*((_BYTE *)this + 24) = 0, *((_BYTE *)this + 47) = 0),
          !DNBLogCheckLogBit(256) && !*v11
       || (DNBError::LogThreaded( (MachVMRegion *)((char *)this + 16),  "::mach_vm_protect(task = 0x%4.4x, addr = 0x%8.8llx, std::string::size_type size = %llu, set_max = %i, prot = %u)",  *(_DWORD *)this,  address,  v8,  0,  new_protection | 0x10),  !*((_DWORD *)this + 4))))
    {
      *((_DWORD *)this + 29) = new_protection;
      BOOL result = 1LL;
      *((void *)this + 15) = address;
      *((void *)this + 16) = v8;
      return result;
    }

    return 0LL;
  }

  if (DNBLogEnabledForAny(257)) {
    _DNBLogThreaded( "MachVMRegion::%s: protections (%u) already sufficient for task 0x%4.4x at address 0x%8.8llx) ",  "SetProtections",  new_protection,  *(_DWORD *)this,  address);
  }
  return 1LL;
}

BOOL MachVMRegion::GetRegionForAddress(MachVMRegion *this, unint64_t a2)
{
  kern_return_t v5;
  kern_return_t v6;
  BOOL v7;
  unint64_t v8;
  mach_msg_type_number_t infoCnt;
  MachVMRegion::RestoreProtections(this);
  *((void *)this + 1) = -1LL;
  if (*((char *)this + 47) < 0)
  {
    **((_BYTE **)this + 3) = 0;
    *((void *)this + 4) = 0LL;
    BOOL v4 = *((char *)this + 47) < 0;
  }

  else
  {
    BOOL v4 = 0;
    *((_BYTE *)this + 24) = 0;
    *((_BYTE *)this + 47) = 0;
  }

  *((void *)this + 7) = 0LL;
  *(_OWORD *)((char *)this + 68) = 0u;
  *(_OWORD *)((char *)this + 84) = 0u;
  *(_OWORD *)((char *)this + 100) = 0u;
  *((_DWORD *)this + 29) = 0;
  *(_OWORD *)((char *)this + 120) = xmmword_1000520C0;
  *((void *)this + 2) = 0LL;
  if (v4)
  {
    **((_BYTE **)this + 3) = 0;
    *((void *)this + 4) = 0LL;
  }

  else
  {
    *((_BYTE *)this + 24) = 0;
    *((_BYTE *)this + 47) = 0;
  }

  *((void *)this + 1) = a2;
  *((void *)this + 6) = a2;
  *((_DWORD *)this + 16) = 1024;
  infoCnt = 12;
  unint64_t v5 = mach_vm_region_recurse( *(_DWORD *)this,  (mach_vm_address_t *)this + 6,  (mach_vm_size_t *)this + 7,  (natural_t *)this + 16,  (vm_region_recurse_info_t)this + 17,  &infoCnt);
  *((_DWORD *)this + 4) = v5;
  *((_DWORD *)this + 5) = 1;
  if (*((char *)this + 47) < 0)
  {
    **((_BYTE **)this + 3) = 0;
    *((void *)this + 4) = 0LL;
    uint64_t v6 = *((_DWORD *)this + 4);
  }

  else
  {
    uint64_t v6 = v5;
    *((_BYTE *)this + 24) = 0;
    *((_BYTE *)this + 47) = 0;
  }

  uint64_t v7 = DNBLogCheckLogBit(256);
  if (v7 || v6)
  {
    DNBError::LogThreaded( (MachVMRegion *)((char *)this + 16),  "::mach_vm_region_recurse(task = 0x%4.4x, address => 0x%8.8llx, size => %llu, nesting_depth => %d, info => %p, in foCnt => %d) addr = 0x%8.8llx ",  *(_DWORD *)this,  *((void *)this + 6),  *((void *)this + 7),  *((_DWORD *)this + 16),  (char *)this + 68,  infoCnt,  a2);
    if (v6) {
      return 0LL;
    }
  }

  if (v7 && DNBLogEnabled()) {
    _DNBLogThreaded( "info = { prot = %u, max_prot = %u, inheritance = 0x%8.8x, offset = 0x%8.8llx, user_tag = 0x%8.8x, ref_count = %u, shadow_depth = %u, ext_pager = %u, share_mode = %u, is_submap = %d, behavior = %d, object_id = 0x%8.8x, user_wired _count = 0x%4.4x }",  *((_DWORD *)this + 17),  *((_DWORD *)this + 18),  *((_DWORD *)this + 19),  *((void *)this + 10),  *((_DWORD *)this + 22),  *((_DWORD *)this + 23),  *((unsigned __int16 *)this + 48),  *((unsigned __int8 *)this + 98),  *((unsigned __int8 *)this + 99),  *((_DWORD *)this + 25),  *((_DWORD *)this + 26),  *((_DWORD *)this + 27),  *((unsigned __int16 *)this + 56));
  }
  *((_DWORD *)this + 29) = *((_DWORD *)this + 17);
  mach_vm_size_t v8 = *((void *)this + 6);
  return v8 <= a2 && *((void *)this + 7) + v8 > a2;
}

uint64_t MachVMRegion::GetDNBPermissions(MachVMRegion *this)
{
  if (*((void *)this + 1) == -1LL || *((void *)this + 6) == -1LL || !*((void *)this + 7)) {
    return 0LL;
  }
  else {
    return *((_DWORD *)this + 17) & 4 | (__rbit32(*((_DWORD *)this + 17)) >> 30);
  }
}

void MachVMRegion::GetMemoryTypes(MachVMRegion *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0LL;
  *(void *)(a2 + 8) = 0LL;
  *(void *)(a2 + 16) = 0LL;
  int v4 = *((_DWORD *)this + 22);
  if (v4 == 30)
  {
    if (*((_DWORD *)this + 17))
    {
      HIBYTE(vmemset(__p, 0, 32) = 5;
      strcpy((char *)__p, "stack");
    }

    else
    {
      HIBYTE(vmemset(__p, 0, 32) = 11;
      strcpy((char *)__p, "stack-guard");
    }

    unint64_t v5 = std::vector<std::string>::__push_back_slow_path<std::string>((void **)a2, (uint64_t)__p);
    int v6 = SHIBYTE(v32);
    *(void *)(a2 + 8) = v5;
    if (v6 < 0) {
      operator delete(__p[0]);
    }
    int v4 = *((_DWORD *)this + 22);
  }

  if (v4 == 1)
  {
    if (*((_DWORD *)this + 17))
    {
      if (*((_BYTE *)this + 99) == 3)
      {
        HIBYTE(vmemset(__p, 0, 32) = 15;
        uint64_t v7 = "malloc-reserved";
      }

      else
      {
        HIBYTE(vmemset(__p, 0, 32) = 15;
        uint64_t v7 = "malloc-metadata";
      }

      __p[0] = *(void **)v7;
      *(void **)((char *)__p + 7) = *(void **)(v7 + 7);
      HIBYTE(__p[1]) = 0;
    }

    else
    {
      HIBYTE(vmemset(__p, 0, 32) = 12;
      strcpy((char *)__p, "malloc-guard");
    }

    unint64_t v8 = *(void *)(a2 + 8);
    if (v8 >= *(void *)(a2 + 16))
    {
      unint64_t v10 = std::vector<std::string>::__push_back_slow_path<std::string>((void **)a2, (uint64_t)__p);
      int v11 = SHIBYTE(v32);
      *(void *)(a2 + 8) = v10;
      if (v11 < 0) {
        operator delete(__p[0]);
      }
    }

    else
    {
      __int128 v9 = *(_OWORD *)__p;
      *(void *)(v8 + 16) = v32;
      *(_OWORD *)unint64_t v8 = v9;
      *(void *)(a2 + 8) = v8 + 24;
    }
  }

  int v12 = *((_DWORD *)this + 22);
  if ((v12 - 2) < 8 || v12 == 11)
  {
    HIBYTE(vmemset(__p, 0, 32) = 4;
    strcpy((char *)__p, "heap");
    unint64_t v14 = *(void *)(a2 + 8);
    if (v14 >= *(void *)(a2 + 16))
    {
      unsigned int v16 = std::vector<std::string>::__push_back_slow_path<std::string>((void **)a2, (uint64_t)__p);
      int v17 = SHIBYTE(v32);
      *(void *)(a2 + 8) = v16;
      if (v17 < 0) {
        operator delete(__p[0]);
      }
    }

    else
    {
      __int128 v15 = *(_OWORD *)__p;
      *(void *)(v14 + 16) = v32;
      *(_OWORD *)unint64_t v14 = v15;
      *(void *)(a2 + 8) = v14 + 24;
    }

    int v18 = *((_DWORD *)this + 22);
    if (v18 == 7)
    {
      HIBYTE(vmemset(__p, 0, 32) = 11;
      strcpy((char *)__p, "malloc-tiny");
      unint64_t v19 = *(void *)(a2 + 8);
      if (v19 >= *(void *)(a2 + 16))
      {
        unint64_t v21 = std::vector<std::string>::__push_back_slow_path<std::string>((void **)a2, (uint64_t)__p);
        int v22 = SHIBYTE(v32);
        *(void *)(a2 + 8) = v21;
        if (v22 < 0) {
          operator delete(__p[0]);
        }
      }

      else
      {
        __int128 v20 = *(_OWORD *)__p;
        *(void *)(v19 + 16) = v32;
        *(_OWORD *)unint64_t v19 = v20;
        *(void *)(a2 + 8) = v19 + 24;
      }

      int v18 = *((_DWORD *)this + 22);
      if (v18 != 3)
      {
LABEL_30:
        if (v18 != 2) {
          return;
        }
        goto LABEL_42;
      }
    }

    else if (v18 != 3)
    {
      goto LABEL_30;
    }

    HIBYTE(vmemset(__p, 0, 32) = 12;
    strcpy((char *)__p, "malloc-large");
    unint64_t v23 = *(void *)(a2 + 8);
    if (v23 >= *(void *)(a2 + 16))
    {
      unint64_t v25 = std::vector<std::string>::__push_back_slow_path<std::string>((void **)a2, (uint64_t)__p);
      int v26 = SHIBYTE(v32);
      *(void *)(a2 + 8) = v25;
      if (v26 < 0) {
        operator delete(__p[0]);
      }
    }

    else
    {
      __int128 v24 = *(_OWORD *)__p;
      *(void *)(v23 + 16) = v32;
      *(_OWORD *)unint64_t v23 = v24;
      *(void *)(a2 + 8) = v23 + 24;
    }

    if (*((_DWORD *)this + 22) != 2) {
      return;
    }
LABEL_42:
    HIBYTE(vmemset(__p, 0, 32) = 12;
    strcpy((char *)__p, "malloc-small");
    unint64_t v27 = *(void *)(a2 + 8);
    if (v27 >= *(void *)(a2 + 16))
    {
      unint64_t v29 = std::vector<std::string>::__push_back_slow_path<std::string>((void **)a2, (uint64_t)__p);
      int v30 = SHIBYTE(v32);
      *(void *)(a2 + 8) = v29;
      if (v30 < 0) {
        operator delete(__p[0]);
      }
    }

    else
    {
      __int128 v28 = *(_OWORD *)__p;
      *(void *)(v27 + 16) = v32;
      *(_OWORD *)unint64_t v27 = v28;
      *(void *)(a2 + 8) = v27 + 24;
    }
  }

uint64_t OsLogger::GetLogFunction(OsLogger *this)
{
  return 0LL;
}

double DNBArchMachARM64::Initialize(DNBArchMachARM64 *this)
{
  v3[0] = unk_100061628;
  v3[1] = *(_OWORD *)&off_100061638;
  DNBArchProtocol::RegisterArchPlugin((unsigned int *)v3);
  v2[0] = unk_100061648;
  v2[1] = *(_OWORD *)&off_100061658;
  *(void *)&double result = DNBArchProtocol::RegisterArchPlugin((unsigned int *)v2).n128_u64[0];
  return result;
}

char *DNBArchMachARM64::Create(DNBArchMachARM64 *this, MachThread *a2)
{
  mach_vm_size_t v3 = (char *)operator new(0x1C80uLL, (std::align_val_t)0x40uLL);
  *((_DWORD *)v3 + 2) = 0;
  *(void *)mach_vm_size_t v3 = off_100065C38;
  *((void *)v3 + 2) = this;
  *((void *)v3 + 829) = -1LL;
  *(void *)&__int128 v4 = -1LL;
  *((void *)&v4 + 1) = -1LL;
  *(_OWORD *)(v3 + 6600) = v4;
  *(_OWORD *)(v3 + 6616) = v4;
  *(_OWORD *)(v3 + 7176) = 0u;
  *(_OWORD *)(v3 + 7192) = 0u;
  *(_OWORD *)(v3 + 7208) = 0u;
  *((_DWORD *)v3 + 1806) = -1;
  *((_WORD *)v3 + 3614) = 0;
  *((void *)v3 + 906) = 0LL;
  *((void *)v3 + 905) = 0LL;
  *((void *)v3 + 904) = v3 + 7240;
  std::vector<DNBArchMachARM64::disabled_watchpoint>::__append((void **)v3 + 897, 0x10uLL);
  uint64_t v5 = *((void *)v3 + 900);
  unint64_t v6 = *((void *)v3 + 901) - v5;
  if (v6 > 0xFF)
  {
    if (v6 != 256) {
      *((void *)v3 + 901) = v5 + 256;
    }
  }

  else
  {
    std::vector<DNBArchMachARM64::disabled_watchpoint>::__append((void **)v3 + 900, 16 - (v6 >> 4));
  }

  bzero(v3 + 6656, 0x208uLL);
  return v3;
}

char **DNBArchMachARM64::GetRegisterSetInfo(DNBArchMachARM64 *this, unint64_t *a2)
{
  if (!(_DWORD)a2) {
    goto LABEL_6;
  }
  if (CPUHasAMX(void)::g_has_avx == -1)
  {
    CPUHasAMX(void)::g_has_avint x = (_get_cpu_capabilities() & 0x78000000) != 0;
LABEL_6:
    double result = &DNBArchMachARM64::g_reg_sets;
    uint64_t v4 = 4LL;
    goto LABEL_7;
  }

void *DNBArchMachARM64::SoftwareBreakpointOpcode(DNBArchMachARM64 *this)
{
  return &g_arm64_breakpoint_opcode;
}

uint64_t DNBArchMachARM64::GetPC(DNBArchMachARM64 *this, uint64_t a2)
{
  return a2;
}

uint64_t DNBArchMachARM64::GetGPRState(DNBArchMachARM64 *this, char a2)
{
  kern_return_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v10;
  natural_t out_state[68];
  mach_msg_type_number_t out_stateCnt;
  mach_msg_type_number_t old_stateCnt;
  if ((a2 & 1) == 0 && !*((_DWORD *)this + 1650)) {
    return 0LL;
  }
  old_stateCnt = 68;
  uint64_t state = thread_get_state(*(_DWORD *)(*((void *)this + 2) + 16LL), 6, (thread_state_t)this + 16, &old_stateCnt);
  if (!(_DWORD)state)
  {
    out_stateCnt = 68;
    uint64_t v4 = thread_convert_thread_state( *(_DWORD *)(*((void *)this + 2) + 16LL),  1,  6,  (thread_state_t)this + 16,  old_stateCnt,  out_state,  &out_stateCnt);
    if (DNBLogEnabledForAny(4)) {
      _DNBLogThreaded( "converted register values to debugserver's keys, return value %d, old count %d new count %d",  v4,  old_stateCnt,  out_stateCnt);
    }
    memcpy((char *)this + 64, out_state, 4 * old_stateCnt);
  }

  if (DNBLogEnabledForAny(4))
  {
    if (DNBLogEnabled()) {
      _DNBLogThreaded( "thread_get_state signed regs \n   fp=%16.16llx\n   lr=%16.16llx\n   sp=%16.16llx\n   pc=%16.16llx",  *((void *)this + 37),  *((void *)this + 38),  *((void *)this + 39),  *((void *)this + 40));
    }
    uint64_t v5 = *((void *)this + 37);
    unint64_t v6 = *((void *)this + 38);
    uint64_t v7 = *((void *)this + 39);
    unint64_t v8 = *((void *)this + 40);
    if (DNBLogEnabled())
    {
      unint64_t v10 = *(_OWORD *)((char *)this + 248);
      _DNBLogThreaded( "thread_get_state(0x%4.4x, %u, &gpr, %u) => 0x%8.8x (count = %u) regs\n x0=%16.16llx\n x1=%16.16llx\n x2=%16.16llx\n x3=%16.16llx\n x4=%16.16llx\n x5=%16.16llx\n x6=%16.16llx\n x7=%16.16llx\n x8=%16.16llx\n x9=%16.16llx\n x10=%16.16llx\n x11=%16.16llx\n x12=%16.16llx\n x13=%16.16llx\n x14=%16.16llx\n x15=%16.16llx\n x16=%16.16llx\n x17=%16.16llx\n x18=%16.16llx\n x19=%16.16llx\n x20=%16.16llx\n x21=%16.16llx\n x22=%16.16llx\n x23=%16.16llx\n x24=%16.16llx\n x25=%16.16llx\n x26=%16.16llx\n x27=%16.16llx\n x28=%16.16llx\n fp=%16.16llx\n lr=%16.16llx\n sp=%16.16llx\n pc=%16.16llx\n cpsr=%8.8x",  *(_DWORD *)(*((void *)this + 2) + 16LL),  1,  68,  state,  old_stateCnt,  *((void *)this + 8),  *((void *)this + 9),  *((void *)this + 10),  *((void *)this + 11),  *((void *)this + 12),  *((void *)this + 13),  *((void *)this + 14),  *((void *)this + 15),  *((void *)this + 16),
        *((void *)this + 17),
        *((void *)this + 8),
        *((void *)this + 19),
        *((void *)this + 20),
        *((void *)this + 21),
        *((void *)this + 22),
        *((void *)this + 23),
        *((void *)this + 24),
        *((void *)this + 25),
        *((void *)this + 26),
        *((void *)this + 27),
        *((void *)this + 28),
        *((void *)this + 29),
        *((void *)this + 30),
        (void)v10,
        *((void *)&v10 + 1),
        *((void *)this + 33),
        *((void *)this + 34),
        *((void *)this + 35),
        *((void *)this + 36),
        v5,
        v6,
        v7,
        v8,
        *((_DWORD *)this + 82));
    }
  }

  *((_DWORD *)this + 1650) = state;
  return state;
}

BOOL DNBArchMachARM64::SetPC(DNBArchMachARM64 *this, uint64_t a2)
{
  kern_return_t v5;
  natural_t __dst[69];
  mach_msg_type_number_t out_stateCnt;
  GPRuint64_t State = DNBArchMachARM64::GetGPRState(this, 0);
  if (!GPRState)
  {
    *((void *)this + 40) = a2;
    out_stateCnt = 68;
    memcpy(__dst, (char *)this + 64, 0x110uLL);
    uint64_t v5 = thread_convert_thread_state( *(_DWORD *)(*((void *)this + 2) + 16LL),  2,  6,  (thread_state_t)this + 16,  0x44u,  __dst,  &out_stateCnt);
    if (DNBLogEnabledForAny(4)) {
      _DNBLogThreaded("converted register values to inferior's keys, return value %d, count %d", v5, out_stateCnt);
    }
    GPRuint64_t State = thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16LL), 6, __dst, 0x44u);
    *((_DWORD *)this + 1651) = GPRState;
    *((_DWORD *)this + 1650) = -1;
  }

  return GPRState == 0;
}

uint64_t DNBArchMachARM64::GetSP(DNBArchMachARM64 *this, uint64_t a2)
{
  return a2;
}

uint64_t DNBArchMachARM64::GetVFPState(DNBArchMachARM64 *this, char a2)
{
  if ((a2 & 1) == 0 && !*((_DWORD *)this + 1652)) {
    return 0LL;
  }
  mach_msg_type_number_t old_stateCnt = 132;
  uint64_t state = thread_get_state(*(_DWORD *)(*((void *)this + 2) + 16LL), 17, (thread_state_t)this + 84, &old_stateCnt);
  if (DNBLogEnabledForAny(4) && DNBLogEnabled())
  {
    __int128 v4 = *((_OWORD *)this + 21);
    __int128 v5 = *((_OWORD *)this + 22);
    __int128 v6 = *((_OWORD *)this + 23);
    __int128 v7 = *((_OWORD *)this + 24);
    __int128 v8 = *((_OWORD *)this + 25);
    __int128 v9 = *((_OWORD *)this + 26);
    __int128 v10 = *((_OWORD *)this + 27);
    __int128 v11 = *((_OWORD *)this + 28);
    __int128 v12 = *((_OWORD *)this + 29);
    __int128 v13 = *((_OWORD *)this + 30);
    __int128 v14 = *((_OWORD *)this + 31);
    __int128 v15 = *((_OWORD *)this + 32);
    __int128 v16 = *((_OWORD *)this + 45);
    __int128 v17 = *((_OWORD *)this + 46);
    __int128 v18 = *((_OWORD *)this + 47);
    __int128 v19 = *((_OWORD *)this + 48);
    __int128 v20 = *((_OWORD *)this + 49);
    __int128 v21 = *((_OWORD *)this + 50);
    __int128 v22 = *((_OWORD *)this + 51);
    _DNBLogThreaded( "thread_get_state(0x%4.4x, %u, &vfp, %u) => 0x%8.8x (count = %u) regs\n q0  = 0x%16.16llx%16.16llx\n q1  = 0x%16.16llx%16.16llx\n q2  = 0x%16.16llx%16.16llx\n q3  = 0x%16.16llx%16.16llx\n q4  = 0x%16.16llx%16.16llx\n q5  = 0x%16.16llx%16.16llx\n q6  = 0x%16.16llx%16.16llx\n q7  = 0x%16.16llx%16.16llx\n q8  = 0x%16.16llx%16.16llx\n q9  = 0x%16.16llx%16.16llx\n q10 = 0x%16.16llx%16.16llx\n q11 = 0x%16.16llx%16.16llx\n q12 = 0x%16.16llx%16.16llx\n q13 = 0x%16.16llx%16.16llx\n q14 = 0x%16.16llx%16.16llx\n q15 = 0x%16.16llx%16.16llx\n q16 = 0x%16.16llx%16.16llx\n q17 = 0x%16.16llx%16.16llx\n q18 = 0x%16.16llx%16.16llx\n q19 = 0x%16.16llx%16.16llx\n q20 = 0x%16.16llx%16.16llx\n q21 = 0x%16.16llx%16.16llx\n q22 = 0x%16.16llx%16.16llx\n q23 = 0x%16.16llx%16.16llx\n q24 = 0x%16.16llx%16.16llx\n q25 = 0x%16.16llx%16.16llx\n q26 = 0x%16.16llx%16.16llx\n q27 = 0x%16.16llx%16.16llx\n q28 = 0x%16.16llx%16.16llx\n q29 = 0x%16.16llx%16.16llx\n q30 = 0x%16.16llx%16.16llx\n q31 = 0x%16.16llx%16.16llx\n fpsr = 0x%8.8x\n fpcr = 0x%8.8x\n \n",  *(_DWORD *)(*((void *)this + 2) + 16LL),  2,  132,  state,  old_stateCnt,  (void)v4,  *((void *)&v4 + 1),  (void)v5,  *((void *)&v5 + 1),  (void)v6,  *((void *)&v6 + 1),  (void)v7,  *((void *)&v7 + 1),
      (void)v8,
      *((void *)&v8 + 1),
      (void)v9,
      *((void *)&v9 + 1),
      (void)v10,
      *((void *)&v10 + 1),
      (void)v11,
      *((void *)&v11 + 1),
      (void)v12,
      *((void *)&v12 + 1),
      (void)v13,
      *((void *)&v13 + 1),
      (void)v14,
      *((void *)&v14 + 1),
      (void)v15,
      *((void *)&v15 + 1),
      *((void *)this + 66),
      *((void *)this + 67),
      *((void *)this + 68),
      *((void *)this + 69),
      *((void *)this + 70),
      *((void *)this + 71),
      *((void *)this + 72),
      *((void *)this + 73),
      *((void *)this + 74),
      *((void *)this + 75),
      *((void *)this + 76),
      *((void *)this + 77),
      *((void *)this + 78),
      *((void *)this + 79),
      *((void *)this + 80),
      *((void *)this + 81),
      *((void *)this + 82),
      *((void *)this + 83),
      *((void *)this + 84),
      *((void *)this + 85),
      *((void *)this + 86),
      *((void *)this + 87),
      *((void *)this + 88),
      *((void *)this + 89),
      (void)v16,
      *((void *)&v16 + 1),
      (void)v17,
      *((void *)&v17 + 1),
      (void)v18,
      *((void *)&v18 + 1),
      (void)v19,
      *((void *)&v19 + 1),
      (void)v20,
      *((void *)&v20 + 1),
      (void)v21,
      *((void *)&v21 + 1),
      (void)v22,
      *((void *)&v22 + 1),
      *((void *)this + 104),
      *((void *)this + 105),
      *((_DWORD *)this + 212),
      *((_DWORD *)this + 213));
  }

  *((_DWORD *)this + 1652) = state;
  return state;
}

void DNBArchMachARM64::ThreadWillResume(DNBArchMachARM64 *this)
{
  kern_return_t state;
  uint64_t v4;
  int v5;
  mach_msg_type_number_t old_stateCnt;
  vm_prot_t v2 = (char *)this + 7228;
  if (MachThread::IsStepping(*((MachThread **)this + 2))) {
    DNBArchMachARM64::EnableHardwareSingleStep((natural_t *)this, 1);
  }
  if (*v2 && (*((_DWORD *)this + 1806) & 0x80000000) == 0)
  {
    mach_msg_type_number_t old_stateCnt = 130;
    uint64_t state = thread_get_state(*(_DWORD *)(*((void *)this + 2) + 16LL), 15, (thread_state_t)this + 1520, &old_stateCnt);
    __int128 v4 = *((unsigned int *)this + 1806);
    if (state || (*((void *)this + v4 + 808) & 1) != 0)
    {
      (*(void (**)(DNBArchMachARM64 *, uint64_t, void))(*(void *)this + 176LL))(this, v4, 0LL);
      if (DNBLogEnabledForAny(2048)) {
        _DNBLogThreaded( "DNBArchMachARM64::ThreadWillResume() DisableHardwareWatchpoint(%d) called",  *((_DWORD *)this + 1806));
      }
      __int128 v5 = DNBArchMachARM64::EnableHardwareSingleStep((natural_t *)this, 1);
      v2[1] = v5 == 0;
      if (v5)
      {
        char *v2 = 0;
        *((_DWORD *)this + 1806) = -1;
        if (DNBLogEnabledForAny(2048)) {
          _DNBLogThreaded("DNBArchMachARM64::ThreadWillResume() failed to enable single step");
        }
      }

      else if (DNBLogEnabledForAny(2048))
      {
        _DNBLogThreaded("DNBArchMachARM64::ThreadWillResume() succeeded to enable single step");
      }
    }

    else
    {
      char *v2 = 0;
      *((_DWORD *)this + 1806) = -1;
    }
  }

uint64_t DNBArchMachARM64::EnableHardwareSingleStep(natural_t *this, int a2)
{
  kern_return_t state;
  uint64_t v5;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  unsigned int GPRState;
  int v11;
  void *__p;
  uint64_t v13;
  uint64_t v14;
  mach_msg_type_number_t old_stateCnt;
  __int128 __p = 0LL;
  __int128 v13 = 0LL;
  __int128 v14 = 0LL;
  if (DNBLogEnabledForAny(4096)) {
    _DNBLogThreaded("%s( enable = %d)", "EnableHardwareSingleStep", a2);
  }
  GPRuint64_t State = DNBArchMachARM64::GetGPRState((DNBArchMachARM64 *)this, 0);
  __int128 v11 = 1;
  LOBYTE(__p) = 0;
  HIBYTE(v14) = 0;
  if (GPRState)
  {
    DNBError::LogThreaded((DNBError *)&GPRState, "%s: failed to read the GPR registers");
    goto LABEL_8;
  }

  mach_msg_type_number_t old_stateCnt = 130;
  uint64_t state = thread_get_state(*(_DWORD *)(*((void *)this + 2) + 16LL), 15, this + 1520, &old_stateCnt);
  GPRuint64_t State = state;
  __int128 v11 = 1;
  if (SHIBYTE(v14) < 0)
  {
    *(_BYTE *)__int128 __p = 0;
    __int128 v13 = 0LL;
    if (GPRState) {
      goto LABEL_7;
    }
LABEL_12:
    __int128 v7 = *((void *)this + 40);
    __int128 v8 = DNBLogEnabledForAny(4096);
    if (a2)
    {
      if (v8) {
        _DNBLogThreaded("%s: Setting MDSCR_EL1 Single Step bit at pc 0x%llx", "EnableHardwareSingleStep", v7);
      }
      __int128 v9 = *((void *)this + 824) | 1LL;
    }

    else
    {
      if (v8) {
        _DNBLogThreaded("%s: Clearing MDSCR_EL1 Single Step bit at pc 0x%llx", "EnableHardwareSingleStep", v7);
      }
      __int128 v9 = *((void *)this + 824) & 0xFFFFFFFELL;
    }

    *((void *)this + 824) = v9;
    __int128 v5 = thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16LL), 15, this + 1520, 0x82u);
    if (SHIBYTE(v14) < 0) {
      goto LABEL_9;
    }
    return v5;
  }

  LOBYTE(__p) = 0;
  HIBYTE(v14) = 0;
  if (!state) {
    goto LABEL_12;
  }
LABEL_7:
  DNBError::LogThreaded((DNBError *)&GPRState, "%s: failed to read the DBG registers");
LABEL_8:
  __int128 v5 = GPRState;
  if (SHIBYTE(v14) < 0) {
LABEL_9:
  }
    operator delete(__p);
  return v5;
}

uint64_t DNBArchMachARM64::NotifyException(DNBArchMachARM64 *this, MachException::Data *a2)
{
  if (*((_DWORD *)a2 + 2) != 6) {
    return 0LL;
  }
  mach_vm_size_t v3 = (void *)*((void *)a2 + 2);
  if (*((void *)a2 + 3) - (void)v3 != 16LL) {
    return 0LL;
  }
  if (*v3 == 1LL)
  {
    unint64_t v15 = (*(uint64_t (**)(DNBArchMachARM64 *, uint64_t))(*(void *)this + 88LL))(this, -1LL);
    if (v15 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      mach_vm_address_t v16 = v15;
      if (!DNBBreakpointList::FindByAddress((DNBBreakpointList *)(**((void **)this + 2) + 1640LL), v15)
        && MachProcess::ReadMemory(**((MachProcess ***)this + 2), v16, 4uLL, (char *)&v39) == 4
        && (_DWORD)v39 == -734134272)
      {
        (*(void (**)(DNBArchMachARM64 *, mach_vm_address_t))(*(void *)this + 96LL))(this, v16 + 4);
      }
    }

    return 0LL;
  }

  if (*v3 != 258LL) {
    return 0LL;
  }
  uint64_t v39 = v3[1];
  unsigned int v5 = (*(uint64_t (**)(DNBArchMachARM64 *, uint64_t *))(*(void *)this + 184LL))(this, &v39);
  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded("DNBArchMachARM64::NotifyException watchpoint %d was hit on address 0x%llx", v5, v39);
  }
  unsigned int v6 = (*(uint64_t (**)(DNBArchMachARM64 *))(*(void *)this + 144LL))(this);
  if (v6)
  {
    unint64_t v7 = 0LL;
    uint64_t v8 = v6;
    __int128 v9 = (char *)this + 6464;
    __int128 v10 = LoHi;
    do
    {
      uint64_t v11 = *v10;
      if (v7 != v11 && (_DWORD)v11 != 0 && (_DWORD)v11 == v5)
      {
        mach_msg_type_number_t old_stateCnt = 130;
        if (!thread_get_state( *(_DWORD *)(*((void *)this + 2) + 16LL),  15,  (thread_state_t)this + 1520,  &old_stateCnt)
          && v7 < (*(unsigned int (**)(DNBArchMachARM64 *))(*(void *)this + 144LL))(this)
          && (*v9 & 1) != 0
          && *((void *)v9 - 16) != -1LL)
        {
          mach_msg_type_number_t old_stateCnt = 130;
          if (!thread_get_state( *(_DWORD *)(*((void *)this + 2) + 16LL),  15,  (thread_state_t)this + 1520,  &old_stateCnt)
            && v7 < (*(unsigned int (**)(DNBArchMachARM64 *))(*(void *)this + 144LL))(this)
            && (*v9 & 1) != 0)
          {
            uint64_t v14 = *((void *)v9 - 16);
          }

          else
          {
            uint64_t v14 = -1LL;
          }

          uint64_t v39 = v14;
          if (DNBLogEnabledForAny(2048)) {
            _DNBLogThreaded( "DNBArchMachARM64::NotifyException It is a linked watchpoint; rewritten to index %d addr 0x%llx",
          }
              *v10,
              v39);
        }
      }

      ++v7;
      ++v10;
      v9 += 8;
    }

    while (v8 != v7);
  }

  if (v5 == -1) {
    return 1LL;
  }
  *((_BYTE *)this + 7228) = 1;
  *((_DWORD *)this + 1806) = v5;
  __int128 v18 = (char *)*((void *)a2 + 2);
  *((void *)v18 + 1) = v39;
  uint64_t v19 = v5;
  __int128 v21 = (char *)*((void *)a2 + 3);
  unint64_t v20 = *((void *)a2 + 4);
  if ((unint64_t)v21 >= v20)
  {
    uint64_t v23 = (v21 - v18) >> 3;
    unint64_t v24 = v23 + 1;
    uint64_t v25 = v20 - (void)v18;
    if (v25 >> 2 > v24) {
      unint64_t v24 = v25 >> 2;
    }
    else {
      unint64_t v26 = v24;
    }
    if (v26)
    {
      if (v26 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      unint64_t v27 = operator new(8 * v26);
    }

    else
    {
      unint64_t v27 = 0LL;
    }

    __int128 v28 = &v27[8 * v23];
    unint64_t v29 = &v27[8 * v26];
    *__int128 v28 = v19;
    __int128 v22 = v28 + 1;
    if (v21 == v18)
    {
      *((void *)a2 + 2) = v28;
      *((void *)a2 + 3) = v22;
      *((void *)a2 + 4) = v29;
    }

    else
    {
      unint64_t v30 = v21 - v18 - 8;
      if (v30 < 0x58) {
        goto LABEL_65;
      }
      uint64_t v31 = (v30 >> 3) + 1;
      uint64_t v32 = 8 * (v31 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v33 = &v21[-v32];
      __int128 v28 = (void *)((char *)v28 - v32);
      int v34 = &v27[v21 - v18 - 16];
      int v35 = v21 - 16;
      uint64_t v36 = v31 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        __int128 v37 = *(_OWORD *)v35;
        *(v34 - 1) = *((_OWORD *)v35 - 1);
        _OWORD *v34 = v37;
        v34 -= 2;
        v35 -= 32;
        v36 -= 4LL;
      }

      while (v36);
      __int128 v21 = v33;
      if (v31 != (v31 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_65:
        do
        {
          uint64_t v38 = *((void *)v21 - 1);
          v21 -= 8;
          *--__int128 v28 = v38;
        }

        while (v21 != v18);
      }

      *((void *)a2 + 2) = v28;
      *((void *)a2 + 3) = v22;
      *((void *)a2 + 4) = v29;
      if (!v18) {
        goto LABEL_59;
      }
    }

    operator delete(v18);
  }

  else
  {
    *(void *)__int128 v21 = v19;
    __int128 v22 = v21 + 8;
  }

LABEL_59:
  *((void *)a2 + 3) = v22;
  return 1LL;
}

BOOL DNBArchMachARM64::ThreadDidStop(DNBArchMachARM64 *this)
{
  vm_prot_t v2 = (_WORD *)((char *)this + 7228);
  *((_DWORD *)this + 1650) = -1;
  *((_DWORD *)this + 1652) = -1;
  *((_DWORD *)this + 1654) = -1;
  *((_DWORD *)this + 1658) = -1;
  *((_DWORD *)this + 1656) = -1;
  if (*((_BYTE *)this + 7229))
  {
    if (DNBArchMachARM64::EnableHardwareSingleStep((natural_t *)this, 0))
    {
      if (DNBLogEnabled()) {
        _DNBLogError("internal error detected: m_watchpoint_resume_step_enabled is true but unable to disable single step!");
      }
    }

    else if (!*(_BYTE *)v2 || (*((_DWORD *)this + 1806) & 0x80000000) != 0)
    {
      if (DNBLogEnabled()) {
        _DNBLogError( "internal error detected: m_watchpoint_resume_step_enabled is true but (m_watchpoint_did_occur && m_watchpoint_ hw_index >= 0) does not hold!");
      }
    }

    else
    {
      (*(void (**)(DNBArchMachARM64 *))(*(void *)this + 224LL))(this);
      _WORD *v2 = 0;
      *((_DWORD *)this + 1806) = -1;
    }
  }

  uint64_t v3 = 1LL;
  return v3;
}

uint64_t DNBArchMachARM64::NumSupportedHardwareWatchpoints(DNBArchMachARM64 *this)
{
  uint64_t result = DNBArchMachARM64::NumSupportedHardwareWatchpoints(void)::g_num_supported_hw_watchpoints;
  if (DNBArchMachARM64::NumSupportedHardwareWatchpoints(void)::g_num_supported_hw_watchpoints == -1)
  {
    DNBArchMachARM64::NumSupportedHardwareWatchpoints(void)::g_num_supported_hw_watchpoints = 0;
    int v2 = 0;
    size_t v3 = 4LL;
    if (!sysctlbyname("hw.optional.watchpoint", &v2, &v3, 0LL, 0LL))
    {
      DNBArchMachARM64::NumSupportedHardwareWatchpoints(void)::g_num_supported_hw_watchpoints = v2;
      if (DNBLogEnabledForAny(4)) {
        _DNBLogThreaded("hw.optional.watchpoint=%u", v2);
      }
    }

    return DNBArchMachARM64::NumSupportedHardwareWatchpoints(void)::g_num_supported_hw_watchpoints;
  }

  return result;
}

uint64_t DNBArchMachARM64::NumSupportedHardwareBreakpoints(DNBArchMachARM64 *this)
{
  uint64_t result = DNBArchMachARM64::NumSupportedHardwareBreakpoints(void)::g_num_supported_hw_breakpoints;
  if (DNBArchMachARM64::NumSupportedHardwareBreakpoints(void)::g_num_supported_hw_breakpoints == -1)
  {
    DNBArchMachARM64::NumSupportedHardwareBreakpoints(void)::g_num_supported_hw_breakpoints = 0;
    int v2 = 0;
    size_t v3 = 4LL;
    if (!sysctlbyname("hw.optional.breakpoint", &v2, &v3, 0LL, 0LL))
    {
      DNBArchMachARM64::NumSupportedHardwareBreakpoints(void)::g_num_supported_hw_breakpoints = v2;
      if (DNBLogEnabledForAny(4)) {
        _DNBLogThreaded("hw.optional.breakpoint=%u", v2);
      }
    }

    return DNBArchMachARM64::NumSupportedHardwareBreakpoints(void)::g_num_supported_hw_breakpoints;
  }

  return result;
}

uint64_t DNBArchMachARM64::EnableHardwareBreakpoint( DNBArchMachARM64 *this, unint64_t a2, uint64_t a3, int a4)
{
  kern_return_t v16;
  kern_return_t v17;
  kern_return_t v18;
  mach_msg_type_number_t old_stateCnt;
  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded("DNBArchMachARM64::EnableHardwareBreakpoint(addr = 0x%8.8llx, std::string::size_type size = %zu)", a2, a3);
  }
  unsigned int v8 = (*(uint64_t (**)(DNBArchMachARM64 *))(*(void *)this + 136LL))(this);
  unint64_t v9 = a2 & 0xFFFFFFFFFFFFFFFELL;
  uint64_t v10 = 103LL;
  if (a3 != 2)
  {
    unint64_t v9 = a2;
    uint64_t v10 = 0LL;
  }

  if (a3 == 4) {
    unint64_t v11 = a2 & 0xFFFFFFFFFFFFFFFCLL;
  }
  else {
    unint64_t v11 = v9;
  }
  if (a3 == 4) {
    uint64_t v12 = 487LL;
  }
  else {
    uint64_t v12 = v10;
  }
  mach_msg_type_number_t old_stateCnt = 130;
  if (thread_get_state(*(_DWORD *)(*((void *)this + 2) + 16LL), 15, (thread_state_t)this + 1520, &old_stateCnt)) {
    return 0xFFFFFFFFLL;
  }
  if (!v8)
  {
LABEL_17:
    if (DNBLogEnabledForAny(2048)) {
      _DNBLogThreaded("DNBArchMachARM64::EnableHardwareBreakpoint(): All hardware resources (%u) are in use.", v8);
    }
    return 0xFFFFFFFFLL;
  }

  uint64_t v14 = 0LL;
  unint64_t v15 = (uint64_t *)((char *)this + 6208);
  while ((*(_BYTE *)v15 & 1) != 0)
  {
    --v14;
    ++v15;
  }

  *(v15 - 16) = v11;
  uint64_t *v15 = v12;
  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded( "DNBArchMachARM64::EnableHardwareBreakpoint() adding breakpoint on address 0x%llx with control register value 0x%x",  *(v15 - 16),  *v15);
  }
  mach_vm_address_t v16 = thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16LL), 15, (thread_state_t)this + 1520, 0x82u);
  if (a4)
  {
    __int128 v17 = task_set_state(*(_DWORD *)(**((void **)this + 2) + 120LL), 15, (thread_state_t)this + 1520, 0x82u);
    if (v17)
    {
      __int128 v18 = v17;
      if (DNBLogEnabledForAny(2048)) {
        _DNBLogThreaded("DNBArchMachARM64::SetDBGState failed to set debug control register state: 0x%8.8x.", v18);
      }
    }
  }

  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded("DNBArchMachARM64::EnableHardwareBreakpoint() SetDBGState() => 0x%8.8x.", v16);
  }
  if (v16) {
    return 0xFFFFFFFFLL;
  }
  return -v14;
}

void DNBArchMachARM64::AlignRequestedWatchpoint( DNBArchMachARM64 *this@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, void *a4@<X8>)
{
  if (!a3)
  {
    *a4 = 0LL;
    a4[1] = 0LL;
    a4[2] = 0LL;
    return;
  }

  uint64_t v7 = 8LL;
  if (a3 > 8) {
    uint64_t v7 = a3;
  }
  uint64_t v8 = 1LL << -(char)__clz(v7 - 1);
  unint64_t v9 = -v8 & a2;
  unint64_t v10 = v9 + v8;
  if (v9 + v8 >= a3 + a2)
  {
    uint64_t v19 = operator new(0x20uLL);
    a4[1] = v19 + 4;
    a4[2] = v19 + 4;
    *uint64_t v19 = v9;
    v19[1] = a2;
    v19[2] = v8;
    std::string v19[3] = a3;
    *a4 = v19;
    return;
  }

  DNBArchMachARM64::AlignRequestedWatchpoint(v21, this, a2, v10 - a2);
  DNBArchMachARM64::AlignRequestedWatchpoint(v20, this, v9 + v8, a3 - (v10 - a2));
  uint64_t v12 = (void *)v21[0];
  __int128 v13 = (void *)v20[0];
  if (v21[1] - v21[0] == 32 && v20[1] - v20[0] == 32)
  {
    __int128 v14 = *(_OWORD *)(v21[0] + 16);
    __int128 v22 = *(_OWORD *)v21[0];
    __int128 v23 = v14;
    __int128 v15 = *(_OWORD *)(v20[0] + 16);
    __int128 v24 = *(_OWORD *)v20[0];
    __int128 v25 = v15;
    mach_vm_address_t v16 = operator new(0x40uLL);
    a4[1] = v16 + 4;
    a4[2] = v16 + 4;
    __int128 v17 = v23;
    _OWORD *v16 = v22;
    v16[1] = v17;
    __int128 v18 = v25;
    v16[2] = v24;
    std::string v16[3] = v18;
    *a4 = v16;
  }

  else
  {
    *a4 = 0LL;
    a4[1] = 0LL;
    a4[2] = 0LL;
    if (!v13) {
      goto LABEL_12;
    }
  }

  operator delete(v13);
LABEL_12:
  if (v12) {
    operator delete(v12);
  }
}

uint64_t DNBArchMachARM64::EnableHardwareWatchpoint( DNBArchMachARM64 *this, unint64_t a2, unint64_t a3, unsigned int a4, unsigned int a5, uint64_t a6)
{
  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded( "DNBArchMachARM64::EnableHardwareWatchpoint(addr = 0x%8.8llx, std::string::size_type size = %zu, read = %u, write = %u)",  a2,  a3,  a4,  a5);
  }
  DNBArchMachARM64::AlignRequestedWatchpoint(this, a2, a3, &v51);
  BOOL v10 = DNBLogEnabledForAny(2048);
  uint64_t v12 = v51;
  unint64_t v11 = v52;
  if (v10) {
    _DNBLogThreaded("DNBArchMachARM64::EnableHardwareWatchpoint() using %zu hardware watchpoints", (v52 - v51) >> 5);
  }
  uint64_t v13 = a5;
  uint64_t v14 = 0xFFFFFFFFLL;
  if ((a4 | a5) != 1) {
    goto LABEL_51;
  }
  uint64_t v15 = v11 - v12;
  if (v11 == v12) {
    goto LABEL_51;
  }
  if (v15 == 32)
  {
    __int128 v16 = *((_OWORD *)v12 + 1);
    if (*((void *)v12 + 2) > 8uLL)
    {
      v49[0] = *(_OWORD *)v12;
      v49[1] = v16;
      uint64_t v14 = DNBArchMachARM64::SetMASKWatchpoint((uint64_t)this, v49, a4, a5, a6);
    }

    else
    {
      v50[0] = *(_OWORD *)v12;
      v50[1] = v16;
      uint64_t v14 = DNBArchMachARM64::SetBASWatchpoint((uint64_t)this, (uint64_t *)v50, a4, a5, a6);
    }

    goto LABEL_52;
  }

  uint64_t v17 = 0LL;
  __int128 v18 = 0LL;
  uint64_t v19 = 0LL;
  unint64_t v20 = 0LL;
  unint64_t v21 = v15 >> 5;
  unint64_t v44 = v21;
  uint64_t v45 = v12;
  if (v21 <= 1) {
    unint64_t v21 = 1LL;
  }
  unint64_t v48 = v21;
  uint64_t v22 = a4;
  do
  {
    int v23 = (*(uint64_t (**)(DNBArchMachARM64 *, void, void, uint64_t, uint64_t, uint64_t))(*(void *)this + 160LL))( this,  *(void *)&v12[32 * v17 + 8],  *(void *)&v12[32 * v17 + 24],  v22,  v13,  a6);
    if (v23 == -1) {
      goto LABEL_14;
    }
    int v24 = v23;
    if (v20 < v19)
    {
      *(_DWORD *)unint64_t v20 = v23;
      v20 += 4;
      goto LABEL_14;
    }

    uint64_t v25 = (v20 - v18) >> 2;
    unint64_t v26 = v25 + 1;
    if ((v19 - v18) >> 1 > v26) {
      unint64_t v26 = (v19 - v18) >> 1;
    }
    else {
      unint64_t v27 = v26;
    }
    if (v27)
    {
      if (v27 >> 62) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      __int128 v28 = operator new(4 * v27);
    }

    else
    {
      __int128 v28 = 0LL;
    }

    unint64_t v29 = &v28[4 * v25];
    *(_DWORD *)unint64_t v29 = v24;
    unint64_t v30 = v29 + 4;
    if (v20 != v18)
    {
      unint64_t v31 = v20 - v18 - 4;
      if (v31 >= 0xBC
        && (unint64_t v32 = (v20 - 4 - v18) & 0xFFFFFFFFFFFFFFFCLL, &v28[v20 - v18 - 4 - v32] <= &v28[v20 - v18 - 4])
        && &v20[-v32 - 4] <= v20 - 4
        && (unint64_t)(v18 - v28) >= 0x20)
      {
        uint64_t v35 = (v31 >> 2) + 1;
        uint64_t v36 = 4 * (v35 & 0x7FFFFFFFFFFFFFF8LL);
        uint64_t v33 = (unsigned int *)&v20[-v36];
        v29 -= v36;
        __int128 v37 = &v28[4 * v25 - 16];
        uint64_t v38 = v20 - 16;
        uint64_t v39 = v35 & 0x7FFFFFFFFFFFFFF8LL;
        do
        {
          __int128 v40 = *(_OWORD *)v38;
          *(v37 - 1) = *((_OWORD *)v38 - 1);
          *__int128 v37 = v40;
          v37 -= 2;
          v38 -= 32;
          v39 -= 8LL;
        }

        while (v39);
        uint64_t v22 = a4;
        if (v35 == (v35 & 0x7FFFFFFFFFFFFFF8LL))
        {
LABEL_34:
          uint64_t v19 = &v28[4 * v27];
          if (!v18) {
            goto LABEL_37;
          }
          goto LABEL_35;
        }
      }

      else
      {
        uint64_t v33 = (unsigned int *)v20;
        uint64_t v22 = a4;
      }

      do
      {
        int v34 = *--v33;
        *((_DWORD *)v29 - 1) = v34;
        v29 -= 4;
      }

      while (v33 != (unsigned int *)v18);
      goto LABEL_34;
    }

    uint64_t v22 = a4;
    uint64_t v19 = &v28[4 * v27];
    if (!v18)
    {
LABEL_37:
      unint64_t v20 = v30;
      goto LABEL_38;
    }

uint64_t DNBArchMachARM64::SetBASWatchpoint(uint64_t a1, uint64_t *a2, int a3, int a4, int a5)
{
  kern_return_t v22;
  kern_return_t v23;
  kern_return_t v24;
  int v26;
  mach_msg_type_number_t old_stateCnt;
  int v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 144LL))(a1);
  uint64_t v12 = *a2;
  uint64_t v11 = a2[1];
  uint64_t v13 = a2[3];
  uint64_t v14 = 0xFFFFFFFFLL;
  mach_msg_type_number_t old_stateCnt = 130;
  if (!thread_get_state(*(_DWORD *)(*(void *)(a1 + 16) + 16LL), 15, (thread_state_t)(a1 + 6080), &old_stateCnt))
  {
    unint64_t v26 = a5;
    if (v10)
    {
      uint64_t v15 = 0LL;
      while ((*(void *)(a1 + 6464 + 8 * v15) & 1) != 0)
      {
        if (v10 == ++v15) {
          goto LABEL_9;
        }
      }
    }

    else
    {
      LODWORD(v15) = 0;
    }

    if ((_DWORD)v15 == v10)
    {
LABEL_9:
      if (DNBLogEnabledForAny(2048)) {
        _DNBLogThreaded("DNBArchMachARM64::SetBASWatchpoint(): All hardware resources (%u) are in use.", v10);
      }
      return 0xFFFFFFFFLL;
    }

    else
    {
      uint64_t v16 = v11 - v12;
      int v17 = ~(-1 << v13) << (v11 - v12);
      if (DNBLogEnabledForAny(2048)) {
        _DNBLogThreaded( "DNBArchMachARM64::SetBASWatchpoint() set hardware register %d to BAS watchpoint aligned start address 0x%llx, watch region start offset %lld, number of bytes %zu",  v15,  v12,  v16,  v13);
      }
      LoHi[v15] = 0;
      uint64_t v18 = a1 + 8LL * v15;
      *(void *)(v18 + 6336) = v12;
      if (a3) {
        int v19 = 8;
      }
      else {
        int v19 = 0;
      }
      int v20 = v19 | (32 * v17);
      if (a4) {
        int v21 = 16;
      }
      else {
        int v21 = 0;
      }
      *(void *)(v18 + 6464) = v20 | v21 | 5u;
      if (DNBLogEnabledForAny(2048)) {
        _DNBLogThreaded( "DNBArchMachARM64::SetBASWatchpoint() adding watchpoint on address 0x%llx with control register value 0x%x",  *(void *)(v18 + 6336),  *(void *)(v18 + 6464));
      }
      uint64_t v22 = thread_set_state(*(_DWORD *)(*(void *)(a1 + 16) + 16LL), 15, (thread_state_t)(a1 + 6080), 0x82u);
      if (v26)
      {
        int v23 = task_set_state(*(_DWORD *)(**(void **)(a1 + 16) + 120LL), 15, (thread_state_t)(a1 + 6080), 0x82u);
        if (v23)
        {
          int v24 = v23;
          if (DNBLogEnabledForAny(2048)) {
            _DNBLogThreaded("DNBArchMachARM64::SetDBGState failed to set debug control register state: 0x%8.8x.", v24);
          }
        }
      }

      if (DNBLogEnabledForAny(2048)) {
        _DNBLogThreaded("DNBArchMachARM64::SetBASWatchpoint() SetDBGState() => 0x%8.8x.", v22);
      }
      if (v22) {
        return 0xFFFFFFFFLL;
      }
      else {
        return v15;
      }
    }
  }

  return v14;
}

uint64_t DNBArchMachARM64::SetMASKWatchpoint(uint64_t a1, void *a2, int a3, int a4, int a5)
{
  kern_return_t v19;
  kern_return_t v20;
  kern_return_t v21;
  mach_msg_type_number_t old_stateCnt;
  int v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 144LL))(a1);
  mach_msg_type_number_t old_stateCnt = 130;
  if (thread_get_state(*(_DWORD *)(*(void *)(a1 + 16) + 16LL), 15, (thread_state_t)(a1 + 6080), &old_stateCnt)) {
    return 0xFFFFFFFFLL;
  }
  if (v10)
  {
    uint64_t v12 = 0LL;
    while ((*(void *)(a1 + 6464 + 8 * v12) & 1) != 0)
    {
      if (v10 == ++v12) {
        goto LABEL_11;
      }
    }
  }

  else
  {
    LODWORD(v12) = 0;
  }

  if ((_DWORD)v12 == v10)
  {
LABEL_11:
    if (DNBLogEnabledForAny(2048)) {
      _DNBLogThreaded("DNBArchMachARM64::SetMASKWatchpoint(): All hardware resources (%u) are in use.", v10);
    }
    return 0xFFFFFFFFLL;
  }

  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded( "DNBArchMachARM64::SetMASKWatchpoint() set hardware register %d to MASK watchpoint aligned start address 0x%llx, aligned size %zu",  v12,  *a2,  a2[2]);
  }
  LoHi[v12] = 0;
  uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)(a2[2] - 1LL));
  v13.i16[0] = vaddlv_u8(v13);
  uint64_t v14 = *a2;
  uint64_t v15 = a1 + 8LL * v12;
  *(void *)(v15 + 6336) = v14;
  uint64_t v16 = 8LL;
  if (!a3) {
    uint64_t v16 = 0LL;
  }
  unint64_t v17 = v16 | ((unint64_t)v13.u32[0] << 24);
  uint64_t v18 = 16LL;
  if (!a4) {
    uint64_t v18 = 0LL;
  }
  *(void *)(v15 + 6464) = v17 | v18 | 0x1FE5;
  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded( "DNBArchMachARM64::SetMASKWatchpoint() adding watchpoint on address 0x%llx with control register value 0x%llx",  *(void *)(v15 + 6336),  *(void *)(v15 + 6464));
  }
  int v19 = thread_set_state(*(_DWORD *)(*(void *)(a1 + 16) + 16LL), 15, (thread_state_t)(a1 + 6080), 0x82u);
  if (a5)
  {
    int v20 = task_set_state(*(_DWORD *)(**(void **)(a1 + 16) + 120LL), 15, (thread_state_t)(a1 + 6080), 0x82u);
    if (v20)
    {
      int v21 = v20;
      if (DNBLogEnabledForAny(2048)) {
        _DNBLogThreaded("DNBArchMachARM64::SetDBGState failed to set debug control register state: 0x%8.8x.", v21);
      }
    }
  }

  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded("DNBArchMachARM64::SetMASKWatchpoint() SetDBGState() => 0x%8.8x.", v19);
  }
  if (v19) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v12;
  }
}

uint64_t DNBArchMachARM64::ReenableHardwareWatchpoint(DNBArchMachARM64 *this, uint64_t a2)
{
  uint64_t v2 = a2;
  if ((*(unsigned int (**)(DNBArchMachARM64 *))(*(void *)this + 144LL))(this) > a2
    && LoHi[v2])
  {
    uint64_t result = (*(uint64_t (**)(DNBArchMachARM64 *, uint64_t))(*(void *)this + 232LL))(this, v2);
    if (!(_DWORD)result) {
      return result;
    }
    uint64_t v2 = LoHi[v2];
  }

  return (*(uint64_t (**)(DNBArchMachARM64 *, uint64_t))(*(void *)this + 232LL))(this, v2);
}

BOOL DNBArchMachARM64::ReenableHardwareWatchpoint_helper(DNBArchMachARM64 *this, unsigned int a2)
{
  mach_msg_type_number_t old_stateCnt = 130;
  if (thread_get_state(*(_DWORD *)(*((void *)this + 2) + 16LL), 15, (thread_state_t)this + 1520, &old_stateCnt)
    || (*(unsigned int (**)(DNBArchMachARM64 *))(*(void *)this + 144LL))(this) <= a2)
  {
    return 0LL;
  }

  uint64_t v4 = *((void *)this + 897) + 16LL * a2;
  unsigned int v5 = (char *)this + 8 * a2;
  *((void *)v5 + 792) = *(void *)v4;
  *((void *)v5 + 808) = *(unsigned int *)(v4 + 8);
  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded( "DNBArchMachARM64::ReenableHardwareWatchpoint_helper( %u) - WVR%u = 0x%8.8llx  WCR%u = 0x%8.8llx",  a2,  a2,  *((void *)v5 + 792),  a2,  *((void *)v5 + 808));
  }
  return thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16LL), 15, (thread_state_t)this + 1520, 0x82u) == 0;
}

BOOL DNBArchMachARM64::DisableHardwareWatchpoint(DNBArchMachARM64 *this, unsigned int a2, int a3)
{
  unsigned int v4 = a2;
  if ((*(unsigned int (**)(DNBArchMachARM64 *))(*(void *)this + 144LL))(this) > a2 && LoHi[v4])
  {
    BOOL result = DNBArchMachARM64::DisableHardwareWatchpoint_helper(this, v4, a3);
    if (!(_DWORD)result) {
      return result;
    }
    unsigned int v4 = LoHi[v4];
  }

  return DNBArchMachARM64::DisableHardwareWatchpoint_helper(this, v4, a3);
}

BOOL DNBArchMachARM64::DisableHardwareWatchpoint_helper(DNBArchMachARM64 *this, unsigned int a2, int a3)
{
  kern_return_t v9;
  kern_return_t v10;
  kern_return_t v11;
  mach_msg_type_number_t old_stateCnt;
  mach_msg_type_number_t old_stateCnt = 130;
  if (thread_get_state(*(_DWORD *)(*((void *)this + 2) + 16LL), 15, (thread_state_t)this + 1520, &old_stateCnt)
    || (*(unsigned int (**)(DNBArchMachARM64 *))(*(void *)this + 144LL))(this) <= a2)
  {
    return 0LL;
  }

  unsigned int v6 = (char *)this + 8 * a2;
  uint64_t v7 = *((void *)this + 897) + 16LL * a2;
  *(void *)uint64_t v7 = *((void *)v6 + 792);
  uint64_t v8 = *((void *)v6 + 808);
  *(_DWORD *)(v7 + 8) = v8;
  *((void *)v6 + 808) = v8 & 0xFFFFFFFFFFFFFFFELL;
  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded( "DNBArchMachARM64::DisableHardwareWatchpoint( %u) - WVR%u = 0x%8.8llx  WCR%u = 0x%8.8llx",  a2,  a2,  *((void *)v6 + 792),  a2,  *((void *)v6 + 808));
  }
  unint64_t v9 = thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16LL), 15, (thread_state_t)this + 1520, 0x82u);
  if (a3)
  {
    int v10 = task_set_state(*(_DWORD *)(**((void **)this + 2) + 120LL), 15, (thread_state_t)this + 1520, 0x82u);
    if (v10)
    {
      uint64_t v11 = v10;
      if (DNBLogEnabledForAny(2048)) {
        _DNBLogThreaded("DNBArchMachARM64::SetDBGState failed to set debug control register state: 0x%8.8x.", v11);
      }
    }
  }

  return v9 == 0;
}

BOOL DNBArchMachARM64::DisableHardwareBreakpoint(DNBArchMachARM64 *this, unsigned int a2, int a3)
{
  kern_return_t v10;
  kern_return_t v11;
  kern_return_t v12;
  mach_msg_type_number_t old_stateCnt;
  mach_msg_type_number_t old_stateCnt = 130;
  unsigned int v6 = (char *)this + 6080;
  if (thread_get_state(*(_DWORD *)(*((void *)this + 2) + 16LL), 15, (thread_state_t)this + 1520, &old_stateCnt)
    || (*(unsigned int (**)(DNBArchMachARM64 *))(*(void *)this + 136LL))(this) <= a2)
  {
    return 0LL;
  }

  uint64_t v7 = 8LL * a2;
  uint64_t v8 = *((void *)this + 900) + 16LL * a2;
  *(void *)uint64_t v8 = *(void *)&v6[v7];
  unint64_t v9 = (char *)this + v7;
  *(_DWORD *)(v8 + 8) = *(void *)((char *)this + v7 + 6208);
  *(void *)((char *)this + v7 + 6208) = 0LL;
  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded( "DNBArchMachARM64::DisableHardwareBreakpoint( %u) - WVR%u = 0x%8.8llx  BCR%u = 0x%8.8llx",  a2,  a2,  *(void *)&v6[8 * a2],  a2,  *((void *)v9 + 776));
  }
  int v10 = thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16LL), 15, (thread_state_t)this + 1520, 0x82u);
  if (a3)
  {
    uint64_t v11 = task_set_state(*(_DWORD *)(**((void **)this + 2) + 120LL), 15, (thread_state_t)this + 1520, 0x82u);
    if (v11)
    {
      uint64_t v12 = v11;
      if (DNBLogEnabledForAny(2048)) {
        _DNBLogThreaded("DNBArchMachARM64::SetDBGState failed to set debug control register state: 0x%8.8x.", v12);
      }
    }
  }

  return v10 == 0;
}

uint64_t DNBArchMachARM64::GetHardwareWatchpointHit(DNBArchMachARM64 *this, unint64_t *a2)
{
  kern_return_t state;
  uint64_t v5;
  unsigned int v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  const char *v14;
  uint64_t v15;
  mach_msg_type_number_t old_stateCnt;
  mach_msg_type_number_t old_stateCnt = 130;
  uint64_t state = thread_get_state(*(_DWORD *)(*((void *)this + 2) + 16LL), 15, (thread_state_t)this + 1520, &old_stateCnt);
  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded("DNBArchMachARM64::GetHardwareWatchpointHit() GetDBGState() => 0x%8.8x.", state);
  }
  if (DNBLogEnabledForAny(2048)) {
    _DNBLogThreaded("DNBArchMachARM64::GetHardwareWatchpointHit() addr = 0x%llx", *a2);
  }
  if (state) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = (*(uint64_t (**)(DNBArchMachARM64 *))(*(void *)this + 144LL))(this);
  if (!v7) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = (void *)((char *)this + 6464);
  unint64_t v9 = -(uint64_t)v7;
  int v10 = 792LL;
  while (1)
  {
    uint64_t v11 = *(v8 - 16);
    if (DNBLogEnabledForAny(2048)) {
      _DNBLogThreaded( "DNBArchImplARM64::GetHardwareWatchpointHit() slot: %u (addr = 0x%llx, WCR = 0x%llx)",  v10 - 792,  v11,  *v8);
    }
    uint64_t v12 = *v8;
    if ((*v8 & 1) == 0) {
      goto LABEL_12;
    }
    uint8x8_t v13 = BYTE3(v12) & 0x1F;
    if (DNBLogEnabledForAny(2048))
    {
      uint64_t v14 = "is MASK watchpoint";
      if (!v13) {
        uint64_t v14 = "is BAS watchpoint";
      }
      _DNBLogThreaded("DNBArchImplARM64::GetHardwareWatchpointHit() slot: %u %s", v10 - 792, v14);
    }

    if (!v13) {
      break;
    }
    if ((unint64_t)(v11 << 15) >> (v13 + 15) == *a2 << 15 >> (v13 + 15))
    {
      unsigned int v5 = v10 - 792;
      if (DNBLogEnabledForAny(2048)) {
        _DNBLogThreaded( "DNBArchImplARM64::GetHardwareWatchpointHit() slot: %u matched MASK ignoring %u low bits",  v10 - 792,  BYTE3(v12) & 0x1F);
      }
      return v5;
    }

unint64_t DNBArchMachARM64::GetRegisterValue(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  unsigned int v5 = a3;
  if ((_DWORD)a2 == -1)
  {
    if (a3 > 0xA) {
      return 0LL;
    }
    unsigned int v5 = dword_1000520F8[a3];
    uint64_t v7 = 1LL;
  }

  else
  {
    uint64_t v7 = a2;
  }

  int v8 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a1 + 64LL))(a1, v7, 0LL);
  unint64_t result = 0LL;
  if (!v8)
  {
    unint64_t result = MachThread::GetRegisterInfo(*(MachThread **)(a1 + 16), v7, v5);
    if (result)
    {
      *(_OWORD *)a4 = *(_OWORD *)result;
      __int128 v10 = *(_OWORD *)(result + 16);
      __int128 v11 = *(_OWORD *)(result + 32);
      __int128 v12 = *(_OWORD *)(result + 48);
      *(void *)(a4 + 64) = *(void *)(result + 64);
      *(_OWORD *)(a4 + memset(__p, 0, 32) = v11;
      *(_OWORD *)(a4 + 48) = v12;
      *(_OWORD *)(a4 + 16) = v10;
      switch((int)v7)
      {
        case 1:
          if (v5 <= 0x20)
          {
            switch(v5)
            {
              case 0x1Du:
                uint64_t v13 = *(void *)(a1 + 296);
                goto LABEL_40;
              case 0x1Eu:
                uint64_t v13 = *(void *)(a1 + 304);
                goto LABEL_40;
              case 0x1Fu:
                uint64_t v13 = *(void *)(a1 + 312);
                goto LABEL_40;
              case 0x20u:
                uint64_t v13 = *(void *)(a1 + 320);
LABEL_40:
                unsigned int v23 = 0;
                if (DNBGetAddressingBits(&v23)) {
                  uint64_t v22 = ~(-1LL << v23);
                }
                else {
                  uint64_t v22 = -1LL;
                }
                uint64_t v14 = v22 & v13;
                break;
              default:
                uint64_t v14 = *(void *)(a1 + 8LL * v5 + 64);
                break;
            }

            goto LABEL_44;
          }

          if (v5 != 33) {
            return 0LL;
          }
          *(_DWORD *)(a4 + 72) = *(_DWORD *)(a1 + 328);
          goto LABEL_45;
        case 2:
          if (v5 <= 0x1F)
          {
            *(_OWORD *)(a4 + 72) = *(_OWORD *)(a1 + 16LL * v5 + 336);
            goto LABEL_45;
          }

          if (v5 == 33)
          {
            *(_DWORD *)(a4 + 72) = *(_DWORD *)(a1 + 852);
            goto LABEL_45;
          }

          if (v5 == 32)
          {
            *(_DWORD *)(a4 + 72) = *(_DWORD *)(a1 + 848);
            goto LABEL_45;
          }

          if (v5 <= 0x41)
          {
            *(_DWORD *)(a4 + 72) = *(_DWORD *)(a1 + 16LL * (v5 - 34) + 336);
            goto LABEL_45;
          }

          if (v5 > 0x61) {
            return 0LL;
          }
          uint64_t v14 = *(void *)(a1 + 16LL * (v5 - 66) + 336);
          goto LABEL_44;
        case 3:
          if (v5 == 2)
          {
            *(_DWORD *)(a4 + 72) = *(_DWORD *)(a1 + 876);
            goto LABEL_45;
          }

          if (v5 == 1)
          {
            *(_DWORD *)(a4 + 72) = *(_DWORD *)(a1 + 872);
            goto LABEL_45;
          }

          if (v5) {
            return 0LL;
          }
          uint64_t v14 = *(void *)(a1 + 864);
          goto LABEL_44;
        case 4:
          if (v5 <= 7)
          {
            uint64_t v15 = (_OWORD *)(a1 + ((unint64_t)v5 << 6));
            __int128 v16 = v15[56];
            __int128 v17 = v15[57];
            __int128 v18 = v15[58];
            __int128 v19 = v15[59];
LABEL_30:
            *(_OWORD *)(a4 + 120) = v19;
            *(_OWORD *)(a4 + 104) = v18;
            *(_OWORD *)(a4 + 88) = v17;
            *(_OWORD *)(a4 + 72) = v16;
            goto LABEL_45;
          }

          if (v5 <= 0xF)
          {
            int v20 = (_OWORD *)(a1 + ((unint64_t)(v5 - 8) << 6));
            __int128 v16 = v20[88];
            __int128 v17 = v20[89];
            __int128 v18 = v20[90];
            __int128 v19 = v20[91];
            goto LABEL_30;
          }

          if (v5 <= 0x4F)
          {
            int v21 = (_OWORD *)(a1 + ((unint64_t)(v5 - 16) << 6));
            __int128 v16 = v21[120];
            __int128 v17 = v21[121];
            __int128 v18 = v21[122];
            __int128 v19 = v21[123];
            goto LABEL_30;
          }

          if (v5 != 80) {
            return 0LL;
          }
          uint64_t v14 = *(void *)(a1 + 6016);
LABEL_44:
          *(void *)(a4 + 72) = v14;
LABEL_45:
          unint64_t result = 1LL;
          break;
        default:
          return 0LL;
      }
    }
  }

  return result;
}

unint64_t DNBArchMachARM64::SetRegisterValue(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  unsigned int v5 = a3;
  if ((_DWORD)a2 == -1)
  {
    if (a3 > 0xA) {
      return 0LL;
    }
    unsigned int v5 = dword_1000520F8[a3];
    uint64_t v7 = 1LL;
  }

  else
  {
    uint64_t v7 = a2;
  }

  int v8 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a1 + 64LL))(a1, v7, 0LL);
  unint64_t result = 0LL;
  if (!v8)
  {
    unint64_t result = MachThread::GetRegisterInfo(*(MachThread **)(a1 + 16), v7, v5);
    if (result)
    {
      switch((int)v7)
      {
        case 1:
          if (v5 > 0x20)
          {
            if (v5 != 33) {
              return 0LL;
            }
            *(_DWORD *)(a1 + 328) = *(_DWORD *)(a4 + 72);
          }

          else
          {
            uint64_t v10 = *(void *)(a4 + 72);
            switch(v5)
            {
              case 0x1Du:
                *(void *)(a1 + 296) = v10;
                break;
              case 0x1Eu:
                *(void *)(a1 + 304) = v10;
                break;
              case 0x1Fu:
                *(void *)(a1 + 312) = v10;
                break;
              case 0x20u:
                *(void *)(a1 + 320) = v10;
                break;
              default:
                *(void *)(a1 + 8LL * v5 + 64) = v10;
                break;
            }
          }

          return (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a1 + 72LL))(a1, v7) == 0;
        case 2:
          if (v5 <= 0x1F)
          {
            *(_OWORD *)(a1 + 16LL * v5 + 336) = *(_OWORD *)(a4 + 72);
            return (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a1 + 72LL))(a1, v7) == 0;
          }

          if (v5 == 33)
          {
            *(_DWORD *)(a1 + 852) = *(_DWORD *)(a4 + 72);
            return (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a1 + 72LL))(a1, v7) == 0;
          }

          if (v5 == 32)
          {
            *(_DWORD *)(a1 + 848) = *(_DWORD *)(a4 + 72);
            return (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a1 + 72LL))(a1, v7) == 0;
          }

          if (v5 <= 0x41)
          {
            *(_DWORD *)(a1 + 16LL * (v5 - 34) + 336) = *(_DWORD *)(a4 + 72);
            return (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a1 + 72LL))(a1, v7) == 0;
          }

          if (v5 > 0x61) {
            return 0LL;
          }
          *(void *)(a1 + 16LL * (v5 - 66) + 336) = *(void *)(a4 + 72);
          return (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a1 + 72LL))(a1, v7) == 0;
        case 3:
          if (v5 == 2)
          {
            *(_DWORD *)(a1 + 876) = *(_DWORD *)(a4 + 72);
          }

          else if (v5 == 1)
          {
            *(_DWORD *)(a1 + 872) = *(_DWORD *)(a4 + 72);
          }

          else
          {
            if (v5) {
              return 0LL;
            }
            *(void *)(a1 + 864) = *(void *)(a4 + 72);
          }

          return (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a1 + 72LL))(a1, v7) == 0;
        case 4:
          if (v5 <= 7)
          {
            __int128 v11 = (_OWORD *)(a1 + ((unint64_t)v5 << 6));
            __int128 v12 = *(_OWORD *)(a4 + 72);
            __int128 v13 = *(_OWORD *)(a4 + 88);
            __int128 v14 = *(_OWORD *)(a4 + 120);
            v11[58] = *(_OWORD *)(a4 + 104);
            v11[59] = v14;
            v11[56] = v12;
            v11[57] = v13;
            return 1LL;
          }

          if (v5 <= 0xF)
          {
            uint64_t v15 = (_OWORD *)(a1 + ((unint64_t)(v5 - 8) << 6));
            __int128 v16 = *(_OWORD *)(a4 + 72);
            __int128 v17 = *(_OWORD *)(a4 + 88);
            __int128 v18 = *(_OWORD *)(a4 + 104);
            v15[91] = *(_OWORD *)(a4 + 120);
            v15[90] = v18;
            v15[89] = v17;
            v15[88] = v16;
            return 1LL;
          }

          if (v5 <= 0x4F)
          {
            __int128 v19 = (_OWORD *)(a1 + ((unint64_t)(v5 - 16) << 6));
            __int128 v20 = *(_OWORD *)(a4 + 72);
            __int128 v21 = *(_OWORD *)(a4 + 88);
            __int128 v22 = *(_OWORD *)(a4 + 104);
            v19[123] = *(_OWORD *)(a4 + 120);
            v19[122] = v22;
            v19[121] = v21;
            v19[120] = v20;
            return 1LL;
          }

          if (v5 != 80) {
            return 0LL;
          }
          *(void *)(a1 + 6016) = *(void *)(a4 + 72);
          unint64_t result = 1LL;
          break;
        default:
          return 0LL;
      }
    }
  }

  return result;
}

uint64_t DNBArchMachARM64::GetRegisterState(natural_t *this, int a2, char a3)
{
  kern_return_t state;
  uint64_t v8;
  thread_act_t v10;
  natural_t *v11;
  thread_state_flavor_t v12;
  mach_msg_type_number_t old_stateCnt;
  switch(a2)
  {
    case 0:
      GPRuint64_t State = DNBArchMachARM64::GetGPRState((DNBArchMachARM64 *)this, a3);
      int v6 = DNBArchMachARM64::GetVFPState((DNBArchMachARM64 *)this, a3) | GPRState;
      if ((a3 & 1) != 0 || this[1656])
      {
        mach_msg_type_number_t old_stateCnt = 4;
        uint64_t state = thread_get_state(*(_DWORD *)(*((void *)this + 2) + 16LL), 7, this + 216, &old_stateCnt);
        this[1656] = state;
      }

      else
      {
        uint64_t state = 0;
      }

      mach_msg_type_number_t old_stateCnt = 130;
      int v8 = v6 | state | thread_get_state( *(_DWORD *)(*((void *)this + 2) + 16LL),  15,  this + 1520,  &old_stateCnt);
      mach_msg_type_number_t old_stateCnt = 1296;
      thread_get_state(*(_DWORD *)(*((void *)this + 2) + 16LL), 25, this + 224, &old_stateCnt);
      return v8;
    case 1:
      return DNBArchMachARM64::GetGPRState((DNBArchMachARM64 *)this, a3);
    case 2:
      return DNBArchMachARM64::GetVFPState((DNBArchMachARM64 *)this, a3);
    case 3:
      if ((a3 & 1) == 0 && !this[1656]) {
        return 0LL;
      }
      mach_msg_type_number_t old_stateCnt = 4;
      int v8 = thread_get_state(*(_DWORD *)(*((void *)this + 2) + 16LL), 7, this + 216, &old_stateCnt);
      this[1656] = v8;
      return v8;
    case 4:
      mach_msg_type_number_t old_stateCnt = 1296;
      uint64_t v10 = *(_DWORD *)(*((void *)this + 2) + 16LL);
      __int128 v11 = this + 224;
      __int128 v12 = 25;
      goto LABEL_13;
    case 5:
      mach_msg_type_number_t old_stateCnt = 130;
      uint64_t v10 = *(_DWORD *)(*((void *)this + 2) + 16LL);
      __int128 v11 = this + 1520;
      __int128 v12 = 15;
LABEL_13:
      int v8 = thread_get_state(v10, v12, v11, &old_stateCnt);
      break;
    default:
      int v8 = 4LL;
      break;
  }

  return v8;
}

uint64_t DNBArchMachARM64::SetRegisterState(DNBArchMachARM64 *this, uint64_t a2)
{
  kern_return_t v5;
  kern_return_t v6;
  kern_return_t v7;
  kern_return_t v8;
  kern_return_t v9;
  kern_return_t v10;
  natural_t __dst[69];
  mach_msg_type_number_t out_stateCnt;
  int v2 = a2;
  uint64_t result = (*(uint64_t (**)(DNBArchMachARM64 *, uint64_t, void))(*(void *)this + 64LL))(this, a2, 0LL);
  if (!(_DWORD)result)
  {
    switch(v2)
    {
      case 0:
        out_stateCnt = 68;
        memcpy(__dst, (char *)this + 64, 0x110uLL);
        unsigned int v5 = thread_convert_thread_state( *(_DWORD *)(*((void *)this + 2) + 16LL),  2,  6,  (thread_state_t)this + 16,  0x44u,  __dst,  &out_stateCnt);
        if (DNBLogEnabledForAny(4)) {
          _DNBLogThreaded("converted register values to inferior's keys, return value %d, count %d", v5, out_stateCnt);
        }
        int v6 = thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16LL), 6, __dst, 0x44u);
        *((_DWORD *)this + 1651) = v6;
        *((_DWORD *)this + 1650) = -1;
        uint64_t v7 = thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16LL), 17, (thread_state_t)this + 84, 0x84u);
        *((_DWORD *)this + 1653) = v7;
        *((_DWORD *)this + 1652) = -1;
        int v8 = thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16LL), 7, (thread_state_t)this + 216, 4u);
        *((_DWORD *)this + 1657) = v8;
        *((_DWORD *)this + 1656) = -1;
        unint64_t v9 = thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16LL), 15, (thread_state_t)this + 1520, 0x82u);
        uint64_t result = v9 | thread_set_state( *(_DWORD *)(*((void *)this + 2) + 16LL),  25,  (thread_state_t)this + 224,  0x510u) | v6 | v7 | v8;
        break;
      case 1:
        out_stateCnt = 68;
        memcpy(__dst, (char *)this + 64, 0x110uLL);
        uint64_t v10 = thread_convert_thread_state( *(_DWORD *)(*((void *)this + 2) + 16LL),  2,  6,  (thread_state_t)this + 16,  0x44u,  __dst,  &out_stateCnt);
        if (DNBLogEnabledForAny(4)) {
          _DNBLogThreaded("converted register values to inferior's keys, return value %d, count %d", v10, out_stateCnt);
        }
        uint64_t result = thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16LL), 6, __dst, 0x44u);
        *((_DWORD *)this + 1651) = result;
        *((_DWORD *)this + 1650) = -1;
        break;
      case 2:
        uint64_t result = thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16LL), 17, (thread_state_t)this + 84, 0x84u);
        *((_DWORD *)this + 1653) = result;
        *((_DWORD *)this + 1652) = -1;
        break;
      case 3:
        uint64_t result = thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16LL), 7, (thread_state_t)this + 216, 4u);
        *((_DWORD *)this + 1657) = result;
        *((_DWORD *)this + 1656) = -1;
        break;
      case 4:
        uint64_t result = thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16LL), 25, (thread_state_t)this + 224, 0x510u);
        break;
      case 5:
        uint64_t result = thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16LL), 15, (thread_state_t)this + 1520, 0x82u);
        break;
      default:
        uint64_t result = 4LL;
        break;
    }
  }

  return result;
}

BOOL DNBArchMachARM64::RegisterSetStateIsValid(DNBArchMachARM64 *this, int a2)
{
  switch(a2)
  {
    case 0:
      int v2 = *((_DWORD *)this + 1652) | *((_DWORD *)this + 1650) | *((_DWORD *)this + 1656) | *((_DWORD *)this + 1658);
      break;
    case 1:
      int v2 = *((_DWORD *)this + 1650);
      break;
    case 2:
      int v2 = *((_DWORD *)this + 1652);
      break;
    case 3:
      int v2 = *((_DWORD *)this + 1656);
      break;
    case 4:
      int v2 = *((_DWORD *)this + 1654);
      break;
    default:
      int v2 = -1;
      break;
  }

  return v2 == 0;
}

uint64_t DNBArchMachARM64::GetRegisterContext(natural_t *this, char *a2, unint64_t a3)
{
  kern_return_t state;
  uint64_t v9;
  mach_msg_type_number_t old_stateCnt;
  mach_msg_type_number_t v12;
  if (a2 && a3)
  {
    GPRuint64_t State = DNBArchMachARM64::GetGPRState((DNBArchMachARM64 *)this, 0);
    int v7 = DNBArchMachARM64::GetVFPState((DNBArchMachARM64 *)this, 0) | GPRState;
    if (this[1656])
    {
      mach_msg_type_number_t old_stateCnt = 4;
      uint64_t state = thread_get_state(*(_DWORD *)(*((void *)this + 2) + 16LL), 7, this + 216, &old_stateCnt);
      this[1656] = state;
      if (v7 | state) {
        return 0LL;
      }
    }

    else if (v7)
    {
      return 0LL;
    }

    __int128 v12 = 1296;
    thread_get_state(*(_DWORD *)(*((void *)this + 2) + 16LL), 25, this + 224, &v12);
    memcpy(a2, this + 16, 0x110uLL);
    memcpy(a2 + 272, this + 84, 0x220uLL);
    memcpy(a2 + 816, this + 224, 0x1440uLL);
    if (a3 >> 4 <= 0x176) {
      DNBArchMachARM64::GetRegisterContext();
    }
  }

  unint64_t v9 = 6000LL;
  if (DNBLogEnabledForAny(4)) {
    _DNBLogThreaded("DNBArchMachARM64::GetRegisterContext (buf = %p, len = %zu) => %zu", a2, a3, 0x1770uLL);
  }
  return v9;
}

uint64_t DNBArchMachARM64::SetRegisterContext(DNBArchMachARM64 *this, char *__src, unint64_t a3)
{
  kern_return_t v8;
  natural_t __dst[69];
  mach_msg_type_number_t out_stateCnt;
  uint64_t v5 = 0LL;
  if (__src && a3)
  {
    int v7 = (char *)this + 64;
    memcpy((char *)this + 64, __src, 0x110uLL);
    memcpy((char *)this + 336, __src + 272, 0x220uLL);
    memcpy((char *)this + 896, __src + 816, 0x1440uLL);
    if (a3 >> 4 <= 0x176) {
      DNBArchMachARM64::SetRegisterContext();
    }
    out_stateCnt = 68;
    memcpy(__dst, v7, 0x110uLL);
    int v8 = thread_convert_thread_state( *(_DWORD *)(*((void *)this + 2) + 16LL),  2,  6,  (thread_state_t)v7,  0x44u,  __dst,  &out_stateCnt);
    if (DNBLogEnabledForAny(4)) {
      _DNBLogThreaded("converted register values to inferior's keys, return value %d, count %d", v8, out_stateCnt);
    }
    *((_DWORD *)this + 1651) = thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16LL), 6, __dst, 0x44u);
    *((_DWORD *)this + 1650) = -1;
    *((_DWORD *)this + 1653) = thread_set_state( *(_DWORD *)(*((void *)this + 2) + 16LL),  17,  (thread_state_t)this + 84,  0x84u);
    *((_DWORD *)this + 1652) = -1;
    *((_DWORD *)this + 1657) = thread_set_state( *(_DWORD *)(*((void *)this + 2) + 16LL),  7,  (thread_state_t)this + 216,  4u);
    *((_DWORD *)this + 1656) = -1;
    thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16LL), 25, (thread_state_t)this + 224, 0x510u);
    uint64_t v5 = 6000LL;
  }

  if (DNBLogEnabledForAny(4)) {
    _DNBLogThreaded("DNBArchMachARM64::SetRegisterContext (buf = %p, len = %zu) => %zu", __src, a3, v5);
  }
  return v5;
}

uint64_t DNBArchMachARM64::SaveRegisterState(DNBArchMachARM64 *this)
{
  kern_return_t v2;
  uint64_t v3;
  char *v5;
  uint64_t **v6;
  uint64_t **v7;
  unsigned int v8;
  char *v9;
  uint64_t v10;
  uint64_t *v11;
  int v2 = thread_abort_safely(*(_DWORD *)(*((void *)this + 2) + 16LL));
  if (DNBLogEnabledForAny(4)) {
    _DNBLogThreaded( "thread = 0x%4.4x calling thread_abort_safely (tid) => %u (SetGPRState() for stop_count = %u)",  *(_DWORD *)(*((void *)this + 2) + 16LL),  v2,  *(_DWORD *)(**((void **)this + 2) + 444LL));
  }
  if (DNBArchMachARM64::GetGPRState(this, 1))
  {
    if (DNBLogEnabledForAny(4)) {
      _DNBLogThreaded("DNBArchMachARM64::SaveRegisterState () error: GPR regs failed to read: %u ");
    }
    return 0xFFFFFFFFLL;
  }

  if (DNBArchMachARM64::GetVFPState(this, 1))
  {
    if (DNBLogEnabledForAny(4)) {
      _DNBLogThreaded("DNBArchMachARM64::SaveRegisterState () error: %s regs failed to read: %u");
    }
    return 0xFFFFFFFFLL;
  }

  size_t v3 = (*((_DWORD *)this + 2) + 1);
  *((_DWORD *)this + 2) = v3;
  uint64_t v5 = (char *)*((void *)this + 905);
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        int v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 16);
        uint64_t v5 = (char *)*v7;
        int v6 = v7;
        if (!*v7) {
          goto LABEL_18;
        }
      }

      uint64_t v5 = (char *)v7[1];
      if (!v5)
      {
        int v6 = v7 + 1;
        goto LABEL_18;
      }
    }
  }

  else
  {
    int v6 = (uint64_t **)((char *)this + 7240);
    int v7 = (uint64_t **)((char *)this + 7240);
LABEL_18:
    unint64_t v9 = (char *)v7;
    int v7 = (uint64_t **)operator new(0x1800uLL, (std::align_val_t)0x40uLL);
    *((_DWORD *)v7 + 16) = v3;
    bzero(v7 + 16, 0x1780uLL);
    *int v7 = 0LL;
    v7[1] = 0LL;
    v7[2] = (uint64_t *)v9;
    *int v6 = (uint64_t *)v7;
    uint64_t v10 = **((void **)this + 904);
    __int128 v11 = (uint64_t *)v7;
    if (v10)
    {
      *((void *)this + 904) = v10;
      __int128 v11 = *v6;
    }

    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 905), v11);
    ++*((void *)this + 906);
  }

  memcpy(v7 + 16, (char *)this + 64, 0x1780uLL);
  return v3;
}

uint64_t DNBArchMachARM64::RestoreRegisterState(DNBArchMachARM64 *this, unsigned int a2)
{
  kern_return_t v10;
  kern_return_t v11;
  kern_return_t v12;
  char *v13;
  char *v14;
  char *v15;
  BOOL v16;
  natural_t __dst[69];
  mach_msg_type_number_t out_stateCnt;
  int v2 = (char *)*((void *)this + 905);
  if (!v2) {
    return 0LL;
  }
  unsigned int v4 = (char *)this + 7240;
  do
  {
    unsigned int v5 = *((_DWORD *)v2 + 16);
    BOOL v6 = v5 >= a2;
    if (v5 >= a2) {
      int v7 = (char **)v2;
    }
    else {
      int v7 = (char **)(v2 + 8);
    }
    if (v6) {
      unsigned int v4 = v2;
    }
    int v2 = *v7;
  }

  while (*v7);
  memcpy((char *)this + 64, v4 + 128, 0x110uLL);
  memcpy((char *)this + 336, v4 + 400, 0x210uLL);
  out_stateCnt = 68;
  memcpy(__dst, (char *)this + 64, 0x110uLL);
  uint64_t v10 = thread_convert_thread_state( *(_DWORD *)(*((void *)this + 2) + 16LL),  2,  6,  (thread_state_t)this + 16,  0x44u,  __dst,  &out_stateCnt);
  if (DNBLogEnabledForAny(4)) {
    _DNBLogThreaded("converted register values to inferior's keys, return value %d, count %d", v10, out_stateCnt);
  }
  __int128 v11 = thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16LL), 6, __dst, 0x44u);
  *((_DWORD *)this + 1651) = v11;
  *((_DWORD *)this + 1650) = -1;
  if (v11)
  {
    if (DNBLogEnabledForAny(4)) {
      _DNBLogThreaded("DNBArchMachARM64::RestoreRegisterState (save_id = %u) error: GPR regs failed to write: %u");
    }
    goto LABEL_22;
  }

  __int128 v12 = thread_set_state(*(_DWORD *)(*((void *)this + 2) + 16LL), 17, (thread_state_t)this + 84, 0x84u);
  *((_DWORD *)this + 1653) = v12;
  *((_DWORD *)this + 1652) = -1;
  if (v12)
  {
    if (DNBLogEnabledForAny(4)) {
      _DNBLogThreaded("DNBArchMachARM64::RestoreRegisterState (save_id = %u) error: %s regs failed to write: %u");
    }
LABEL_22:
    uint64_t v8 = 0LL;
    __int128 v13 = (char *)*((void *)v4 + 1);
    if (v13) {
      goto LABEL_23;
    }
LABEL_26:
    uint64_t v15 = v4;
    do
    {
      __int128 v14 = (char *)*((void *)v15 + 2);
      __int128 v16 = *(void *)v14 == (void)v15;
      uint64_t v15 = v14;
    }

    while (!v16);
    goto LABEL_29;
  }

  uint64_t v8 = 1LL;
  __int128 v13 = (char *)*((void *)v4 + 1);
  if (!v13) {
    goto LABEL_26;
  }
  do
  {
LABEL_23:
    __int128 v14 = v13;
    __int128 v13 = *(char **)v13;
  }

  while (v13);
LABEL_29:
  --*((void *)this + 906);
  std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 905), (uint64_t *)v4);
  operator delete(v4, (std::align_val_t)0x40uLL);
  return v8;
}

void DNBArchMachARM64::~DNBArchMachARM64(DNBArchMachARM64 *this)
{
  *(void *)this = off_100065C38;
  std::__tree<std::__value_type<unsigned int,DNBArchMachARM64::Context>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,DNBArchMachARM64::Context>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,DNBArchMachARM64::Context>>>::destroy( (uint64_t)this + 7232,  *((void **)this + 905));
  int v2 = (void *)*((void *)this + 900);
  if (v2)
  {
    *((void *)this + 901) = v2;
    operator delete(v2);
  }

  size_t v3 = (void *)*((void *)this + 897);
  if (v3)
  {
    *((void *)this + 898) = v3;
    operator delete(v3);
  }

{
  void *v2;
  void *v3;
  *(void *)this = off_100065C38;
  std::__tree<std::__value_type<unsigned int,DNBArchMachARM64::Context>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,DNBArchMachARM64::Context>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,DNBArchMachARM64::Context>>>::destroy( (uint64_t)this + 7232,  *((void **)this + 905));
  int v2 = (void *)*((void *)this + 900);
  if (v2)
  {
    *((void *)this + 901) = v2;
    operator delete(v2);
  }

  size_t v3 = (void *)*((void *)this + 897);
  if (v3)
  {
    *((void *)this + 898) = v3;
    operator delete(v3);
  }

  operator delete(this, (std::align_val_t)0x40uLL);
}

uint64_t DNBArchProtocol::StepNotComplete(DNBArchProtocol *this)
{
  return 0LL;
}

uint64_t DNBArchProtocol::StartTransForHWP(DNBArchProtocol *this)
{
  return 1LL;
}

uint64_t DNBArchProtocol::RollbackTransForHWP(DNBArchProtocol *this)
{
  return 1LL;
}

uint64_t DNBArchProtocol::FinishTransForHWP(DNBArchProtocol *this)
{
  return 1LL;
}

void std::vector<DNBArchMachARM64::disabled_watchpoint>::__append(void **a1, unint64_t a2)
{
  unsigned int v5 = (char *)a1[1];
  unsigned int v4 = a1[2];
  BOOL v6 = v5;
  if (a2 <= (v4 - v5) >> 4)
  {
    if (a2)
    {
      if (((a2 - 1) & 0xFFFFFFFFFFFFFFFLL) == 0) {
        goto LABEL_34;
      }
      uint64_t v13 = ((a2 - 1) & 0xFFFFFFFFFFFFFFFLL) + 1;
      BOOL v6 = &v5[16 * (v13 & 0x1FFFFFFFFFFFFFFELL)];
      __int128 v14 = v5 + 16;
      uint64_t v15 = v13 & 0x1FFFFFFFFFFFFFFELL;
      do
      {
        *((void *)v14 - 2) = 0LL;
        *(void *)__int128 v14 = 0LL;
        *((_DWORD *)v14 - 2) = 0;
        *((_DWORD *)v14 + 2) = 0;
        v14 += 32;
        v15 -= 2LL;
      }

      while (v15);
      if (v13 != (v13 & 0x1FFFFFFFFFFFFFFELL))
      {
LABEL_34:
        do
        {
          *(void *)BOOL v6 = 0LL;
          *((_DWORD *)v6 + 2) = 0;
          v6 += 16;
        }

        while (v6 != &v5[16 * a2]);
      }

      BOOL v6 = &v5[16 * a2];
    }

    a1[1] = v6;
  }

  else
  {
    int v7 = (char *)*a1;
    uint64_t v8 = (v5 - (_BYTE *)*a1) >> 4;
    unint64_t v9 = v8 + a2;
    if ((v8 + a2) >> 60) {
      abort();
    }
    uint64_t v10 = v4 - v7;
    if (v10 >> 3 > v9) {
      unint64_t v9 = v10 >> 3;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11)
    {
      if (v11 >> 60) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      __int128 v12 = (char *)operator new(16 * v11);
    }

    else
    {
      __int128 v12 = 0LL;
    }

    __int128 v16 = &v12[16 * v8];
    __int128 v17 = &v16[16 * a2];
    __int128 v18 = v16;
    if (((a2 - 1) & 0xFFFFFFFFFFFFFFFLL) == 0) {
      goto LABEL_35;
    }
    uint64_t v19 = ((a2 - 1) & 0xFFFFFFFFFFFFFFFLL) + 1;
    __int128 v18 = &v16[16 * (v19 & 0x1FFFFFFFFFFFFFFELL)];
    __int128 v20 = v16 + 16;
    uint64_t v21 = v19 & 0x1FFFFFFFFFFFFFFELL;
    do
    {
      *((void *)v20 - 2) = 0LL;
      *(void *)__int128 v20 = 0LL;
      *((_DWORD *)v20 - 2) = 0;
      *((_DWORD *)v20 + 2) = 0;
      v20 += 32;
      v21 -= 2LL;
    }

    while (v21);
    if (v19 != (v19 & 0x1FFFFFFFFFFFFFFELL))
    {
LABEL_35:
      do
      {
        *(void *)__int128 v18 = 0LL;
        *((_DWORD *)v18 + 2) = 0;
        v18 += 16;
      }

      while (v18 != v17);
    }

    __int128 v22 = &v12[16 * v11];
    if (v5 != v7)
    {
      do
      {
        uint64_t v23 = *((void *)v6 - 2);
        v6 -= 16;
        int v24 = *((_DWORD *)v6 + 2);
        *((void *)v16 - 2) = v23;
        v16 -= 16;
        *((_DWORD *)v16 + 2) = v24;
      }

      while (v6 != v7);
    }

    uint64_t v25 = *a1;
    *a1 = v16;
    a1[1] = v17;
    a1[2] = v22;
    if (v25) {
      operator delete(v25);
    }
  }

void std::__tree<std::__value_type<unsigned int,DNBArchMachARM64::Context>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,DNBArchMachARM64::Context>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,DNBArchMachARM64::Context>>>::destroy( uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<unsigned int,DNBArchMachARM64::Context>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,DNBArchMachARM64::Context>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,DNBArchMachARM64::Context>>>::destroy( a1,  *a2);
    std::__tree<std::__value_type<unsigned int,DNBArchMachARM64::Context>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,DNBArchMachARM64::Context>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,DNBArchMachARM64::Context>>>::destroy( a1,  a2[1]);
    operator delete(a2, (std::align_val_t)0x40uLL);
  }

uint64_t mach_exc_server_routine(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 20);
  else {
    return 0LL;
  }
}

uint64_t _Xmach_exception_raise(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) != 0)
  {
    int v3 = -304;
    if (*(_DWORD *)(result + 24) != 2) {
      goto LABEL_3;
    }
    unsigned int v4 = *(_DWORD *)(result + 4);
    if (v4 < 0x44 || v4 > 0x54) {
      goto LABEL_3;
    }
    if (*(unsigned __int16 *)(result + 38) << 16 != 1114112 || *(unsigned __int16 *)(result + 50) << 16 != 1114112)
    {
      int v3 = -300;
      goto LABEL_3;
    }

    unsigned int v5 = *(_DWORD *)(result + 64);
    if (v5 <= 2 && v5 <= (v4 - 68) >> 3 && v4 == 8 * v5 + 68)
    {
      uint64_t result = catch_mach_exception_raise( *(_DWORD *)(result + 12),  *(_DWORD *)(result + 28),  *(_DWORD *)(result + 40),  *(_DWORD *)(result + 60),  (uint64_t *)(result + 68),  v5);
      *(_DWORD *)(a2 + memset(__p, 0, 32) = result;
      goto LABEL_4;
    }
  }

  int v3 = -304;
LABEL_3:
  *(_DWORD *)(a2 + memset(__p, 0, 32) = v3;
LABEL_4:
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

_DWORD *_Xmach_exception_raise_state(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0) {
    goto LABEL_17;
  }
  unsigned int v3 = result[1];
  BOOL v4 = v3 < 0x30 || v3 > 0x1480;
  if (v4
    || (unsigned int v5 = result[9], v5 > 2)
    || ((unsigned int v6 = 2 * v5, v5 <= (v3 - 48) >> 3) ? (v7 = v3 >= 8 * v5 + 48) : (v7 = 0),
        !v7
     || (uint64_t v8 = &result[v6], v9 = v8[11], v9 > 0x510)
     || ((unsigned int v10 = v3 - v6 * 4, v9 <= (v10 - 48) >> 2) ? (v11 = v10 == 4 * v9 + 48) : (v11 = 0), !v11)))
  {
LABEL_17:
    *(_DWORD *)(a2 + memset(__p, 0, 32) = -304;
    NDR_record_t v12 = NDR_record;
LABEL_18:
    *(NDR_record_t *)(a2 + 24) = v12;
    return result;
  }

  *(_DWORD *)(a2 + 40) = 1296;
  uint64_t v13 = v8 + 10;
  uint64_t result = (_DWORD *)catch_mach_exception_raise_state(result[3], result[8], (uint64_t)(result + 10), v5);
  *(_DWORD *)(a2 + memset(__p, 0, 32) = (_DWORD)result;
  NDR_record_t v12 = NDR_record;
  if ((_DWORD)result) {
    goto LABEL_18;
  }
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  *(_DWORD *)(a2 + 36) = *v13;
  *(_DWORD *)(a2 + 4) = 4 * *(_DWORD *)(a2 + 40) + 44;
  return result;
}

uint64_t _Xmach_exception_raise_state_identity(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0) {
    goto LABEL_2;
  }
  int v3 = -304;
  if (*(_DWORD *)(result + 24) != 2) {
    goto LABEL_3;
  }
  unsigned int v5 = *(_DWORD *)(result + 4);
  if (v5 < 0x4C || v5 > 0x149C) {
    goto LABEL_3;
  }
  if (*(unsigned __int16 *)(result + 38) << 16 != 1114112 || *(unsigned __int16 *)(result + 50) << 16 != 1114112)
  {
    int v3 = -300;
    goto LABEL_3;
  }

  unsigned int v7 = *(_DWORD *)(result + 64);
  if (v7 > 2) {
    goto LABEL_2;
  }
  int v3 = -304;
  if (v7 > (v5 - 76) >> 3) {
    goto LABEL_3;
  }
  unsigned int v8 = 8 * v7;
  if (v5 < 8 * v7 + 76) {
    goto LABEL_3;
  }
  uint64_t v9 = result + v8;
  unsigned int v10 = *(_DWORD *)(v9 + 72);
  if (v10 > 0x510 || (unsigned int v11 = v5 - v8, v10 > (v11 - 76) >> 2) || v11 != 4 * v10 + 76)
  {
LABEL_2:
    int v3 = -304;
LABEL_3:
    *(_DWORD *)(a2 + memset(__p, 0, 32) = v3;
    NDR_record_t v4 = NDR_record;
LABEL_4:
    *(NDR_record_t *)(a2 + 24) = v4;
    return result;
  }

  *(_DWORD *)(a2 + 40) = 1296;
  NDR_record_t v12 = (_DWORD *)(v9 + 68);
  uint64_t result = catch_mach_exception_raise_state_identity( *(_DWORD *)(result + 12),  *(_DWORD *)(result + 28),  *(_DWORD *)(result + 40),  *(_DWORD *)(result + 60),  (uint64_t *)(result + 68),  v7);
  *(_DWORD *)(a2 + memset(__p, 0, 32) = result;
  NDR_record_t v4 = NDR_record;
  if ((_DWORD)result) {
    goto LABEL_4;
  }
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  *(_DWORD *)(a2 + 36) = *v12;
  *(_DWORD *)(a2 + 4) = 4 * *(_DWORD *)(a2 + 40) + 44;
  return result;
}

uint64_t mach_exc_server(_DWORD *a1, uint64_t a2)
{
  int v2 = a1[2];
  *(_DWORD *)a2 = *a1 & 0x1F;
  *(_DWORD *)(a2 + 4) = 36;
  int v3 = a1[5] + 100;
  *(_DWORD *)(a2 + 8) = v2;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = v3;
  int v4 = a1[5];
  if ((v4 - 2411) >= 0xFFFFFFFA
    && (unsigned int v5 = (void (*)(void))*(&catch_mach_exc_subsystem + 5 * (v4 - 2405) + 5)) != 0LL)
  {
    v5();
    return 1LL;
  }

  else
  {
    uint64_t result = 0LL;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    *(_DWORD *)(a2 + memset(__p, 0, 32) = -303;
  }

  return result;
}

void PortWasBoundCallbackUnixSocket()
{
}

{
  perror("error: connect (socket, &saddr_un, saddr_un_len)");
  OUTLINED_FUNCTION_0();
}

{
  perror("error: send (s, pid_str, pid_str_len, 0)");
  OUTLINED_FUNCTION_0();
}

void DNBBreakpointList::RemoveTrapsFromBuffer()
{
  __assert_rtn("RemoveTrapsFromBuffer", "DNBBreakpoint.cpp", 187, "opcode_offset + intersect_size <= bp.ByteSize()");
}

{
  __assert_rtn( "RemoveTrapsFromBuffer",  "DNBBreakpoint.cpp",  186,  "addr < intersect_addr + intersect_size && intersect_addr + intersect_size <= addr + size");
}

{
  __assert_rtn( "RemoveTrapsFromBuffer",  "DNBBreakpoint.cpp",  184,  "addr <= intersect_addr && intersect_addr < addr + size");
}

void DNBProcessLaunch()
{
}

void DNBProcessAttach()
{
}

void DNBProcessAttach(char *a1, int a2, char *a3, int a4)
{
  snprintf(a1, 0x10uLL, "--fd=%d", a2);
  snprintf(a3, 0x10uLL, "--attach=%d", a4);
  execl( "/Library/Apple/usr/libexec/oah/debugserver",  "/Library/Apple/usr/libexec/oah/debugserver",  "--native-regs",  "--setsid",  a1,  "--handoff-attach-from-native",  a3,  0LL);
  if (DNBLogEnabledForAny(2))
  {
    uint64_t v7 = *__error();
    unsigned int v8 = __error();
    uint64_t v9 = strerror(*v8);
    _DNBLogThreaded("Failed to launch debugserver for translated process: ", v7, v9);
  }

  __break(1u);
}

void DNBDataRef::GetMax64()
{
}

void DNBDataRef::Dump()
{
  __assert_rtn("GetPointer", "DNBDataRef.cpp", 146, "m_ptrSize != 0");
}

void PThreadMutex::PThreadMutex()
{
  __assert_rtn("PThreadMutex", "PThreadMutex.h", 96, "err == 0");
}

{
  __assert_rtn("PThreadMutex", "PThreadMutex.h", 94, "err == 0");
}

{
  __assert_rtn("PThreadMutex", "PThreadMutex.h", 92, "err == 0");
}

{
  __assert_rtn("PThreadMutex", "PThreadMutex.h", 90, "err == 0");
}

void PThreadEvent::PThreadEvent()
{
  __assert_rtn("PThreadMutex", "PThreadMutex.h", 83, "err == 0");
}

void RNBRemote::InitializeRegisters()
{
  __assert_rtn("InitializeRegisters", "RNBRemote.cpp", 1343, "num_reg_sets > 0 && reg_sets != NULL");
}

void MachException::Message::Reply()
{
  __assert_rtn("Reply", "MachException.cpp", 325, "state_pid != -1");
}

void MachProcess::EnableBreakpoint()
{
  __assert_rtn("EnableBreakpoint", "MachProcess.mm", 2252, "break_op_size != 0");
}

void MachProcess::DisableBreakpoint()
{
}

void MachThread::ThreadWillResume()
{
  __assert_rtn("ThreadWillResume", "MachThread.cpp", 351, "others_stopped == false");
}

void MachThreadList::ProcessWillResume()
{
}

void DNBArchMachARM64::GetRegisterContext()
{
  __assert_rtn("GetRegisterContext", "DNBArchImplARM64.cpp", 3068, "bytes_written == size");
}

void DNBArchMachARM64::SetRegisterContext()
{
  __assert_rtn("SetRegisterContext", "DNBArchImplARM64.cpp", 3109, "bytes_written == size");
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void operator delete(void *__p, std::align_val_t a2)
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz, std::align_val_t a2)
{
  while (1)
    ;
}

id objc_msgSend_systemApplicationBundleIdentifier(void *a1, const char *a2, ...)
{
  return [a1 systemApplicationBundleIdentifier];
}