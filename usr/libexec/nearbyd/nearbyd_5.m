void sub_100273940(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_10027395C(uint64_t a1@<X8>)
{
  v2 = sub_100288340();
  sub_100288538((uint64_t)v2, 1000LL, (uint64_t)v16);
  int v3 = v16[0];
  if (v25) {
    int v4 = 0;
  }
  else {
    int v4 = -1004;
  }
  if (!v16[0]) {
    int v3 = v4;
  }
  if (v3)
  {
    v15[0] = 0;
    v15[64] = 0;
    *(_DWORD *)a1 = v3;
    sub_10027619C((_BYTE *)(a1 + 8), (uint64_t)v15);
    sub_100189774((uint64_t)v15);
  }

  else
  {
    if (!v25) {
      sub_100006080();
    }
    size_t v5 = v23;
    v12 = 0LL;
    v13 = 0LL;
    uint64_t v14 = 0LL;
    sub_1002761F0(&v12, v18, (uint64_t)&v18[v17], v17);
    v9 = 0LL;
    v10 = 0LL;
    uint64_t v11 = 0LL;
    sub_100030B3C(&v9, v24, (uint64_t)&v24[v5], v5);
    sub_100275FC0((uint64_t)v6, (uint64_t)&v12, v19, v20, v21, v22, (uint64_t)&v9);
    sub_100276064((uint64_t)v15, (uint64_t)v6);
    *(_DWORD *)a1 = 0;
    sub_10027619C((_BYTE *)(a1 + 8), (uint64_t)v15);
    sub_100189774((uint64_t)v15);
    if (__p)
    {
      v8 = __p;
      operator delete(__p);
    }

    if (v6[0])
    {
      v6[1] = v6[0];
      operator delete(v6[0]);
    }

    if (v9)
    {
      v10 = v9;
      operator delete(v9);
    }

    if (v12)
    {
      v13 = v12;
      operator delete(v12);
    }
  }

void sub_100273AD8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20, void *a21, uint64_t a22, uint64_t a23, char a24)
{
  if (__p)
  {
    a19 = (uint64_t)__p;
    operator delete(__p);
  }

  if (a21)
  {
    a22 = (uint64_t)a21;
    operator delete(a21);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_100273B44(uint64_t a1)
{
  v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 48) = v2;
    operator delete(v2);
  }

  int v3 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v3;
    operator delete(v3);
  }

  return a1;
}

uint64_t sub_100273B84(uint64_t a1, uint64_t a2)
{
  int v3 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#rose-ses,AlishaSubsystem: delete keys", v6, 2u);
  }

  int v4 = sub_100288340();
  return sub_100288548((uint64_t)v4, a2, 1000LL);
}

uint64_t sub_100273BFC()
{
  v0 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v3 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_DEFAULT,  "#rose-ses,AlishaSubsystem: delete all keys",  v3,  2u);
  }

  v1 = sub_100288340();
  return sub_100288550((uint64_t)v1, 1000LL);
}

void sub_100273C6C(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  int v4 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    v15 = (const char *)a1;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#rose-ses,AlishaSubsystem: convertBtClkToUwbClk (BT: %llu)",  buf,  0xCu);
  }

  size_t v5 = sub_100288340();
  sub_100288530((uint64_t)v5, 2u, 1u, a1, (uint64_t)v10);
  if (v13)
  {
    if (v10[0] == 2)
    {
      if (v10[1] == 1)
      {
        v6 = (os_log_s *)qword_1008000A0;
        if (v11 == a1)
        {
          if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 134218240;
            v15 = (const char *)a1;
            __int16 v16 = 2048;
            v17[0] = v12;
            _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#rose-ses,AlishaSubsystem: conversion result %llu -> %llu",  buf,  0x16u);
          }

          uint64_t v7 = v12;
          *(_DWORD *)a2 = 0;
          *(void *)(a2 + 8) = v7;
          char v8 = 1;
          goto LABEL_13;
        }

        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT)) {
          sub_1003A3B2C();
        }
        v9 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136315650;
          v15 = "/Library/Caches/com.apple.xbs/Sources/Proximity/Daemon/Services/NearbyInteraction/UWB/NIServerRoseSession.mm";
          __int16 v16 = 1024;
          LODWORD(v17[0]) = 794;
          WORD2(v17[0]) = 2080;
          *(void *)((char *)v17 + 6) = "convertBtClkToUwbClk";
          goto LABEL_26;
        }

uint64_t sub_100273F88(uint64_t a1, uint64_t a2)
{
  int v3 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = *(_DWORD *)a2;
    *(_DWORD *)buf = 67109120;
    int v24 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "#rose-ses,AlishaSubsystem: debug set key for uwb session id: %u",  buf,  8u);
  }

  size_t v5 = sub_100288340();
  sub_100288558((uint64_t)v5, *(_DWORD *)a2, (__int128 *)(a2 + 4), 1000LL, (uint64_t)buf);
  if (v26) {
    unsigned int v6 = 0;
  }
  else {
    unsigned int v6 = -1004;
  }
  if (*(_DWORD *)buf) {
    uint64_t result = *(unsigned int *)buf;
  }
  else {
    uint64_t result = v6;
  }
  if (!(_DWORD)result)
  {
    if (!v26) {
      sub_100006080();
    }
    uint64_t v8 = v24;
    if (v24 != 3)
    {
      v9 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT)) {
        sub_1003A3BB0(v8, v9, v10, v11, v12, v13, v14, v15);
      }
      __int16 v16 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_INFO))
      {
        int v17 = 136315650;
        v18 = "/Library/Caches/com.apple.xbs/Sources/Proximity/Daemon/Services/NearbyInteraction/UWB/NIServerRoseSession.mm";
        __int16 v19 = 1024;
        int v20 = 815;
        __int16 v21 = 2080;
        char v22 = "_debugSetKey";
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_INFO,  "#rose-ses,%s:%d: assertion failure in %s",  (uint8_t *)&v17,  0x1Cu);
      }

      abort();
    }

    return sub_1002BF768(v25);
  }

  return result;
}

uint64_t sub_10027412C(uint64_t a1, uint64_t a2)
{
  int v3 = sub_100288340();
  uint64_t v4 = sub_100288560((uint64_t)v3, a2);
  size_t v5 = (os_log_s *)(id)qword_1008000A0;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    sub_1002BEFAC(v4, __p);
    if (v9 >= 0) {
      unsigned int v6 = __p;
    }
    else {
      unsigned int v6 = (void **)__p[0];
    }
    *(_DWORD *)buf = 134218242;
    uint64_t v11 = a2;
    __int16 v12 = 2080;
    uint64_t v13 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "#rose-ses,AlishaSubsystem: set URSK TTL to %llu. Status code %s",  buf,  0x16u);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
  }

  return v4;
}

void sub_10027422C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *sub_100274244( void *a1, __int128 *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  v58 = 0LL;
  v56 = 0LL;
  sub_10001E914((uint64_t)v53, a5);
  v52 = 0LL;
  v50 = 0LL;
  sub_10001E914((uint64_t)v47, a6);
  sub_10001E914((uint64_t)v45, a7);
  v44 = 0LL;
  v18 = (std::__shared_weak_count *)a11[1];
  v42[0] = *a11;
  v42[1] = v18;
  if (v18)
  {
    p_shared_owners = (unint64_t *)&v18->__shared_owners_;
    do
      unint64_t v20 = __ldxr(p_shared_owners);
    while (__stxr(v20 + 1, p_shared_owners));
  }

  sub_10026F104( (uint64_t)a1,  a2,  a3,  (uint64_t)v59,  (uint64_t)v57,  (uint64_t)v55,  (uint64_t)v53,  (uint64_t)v51,  (uint64_t)v49,  (uint64_t)v47,  (uint64_t)v45,  (uint64_t)v43,  v42);
  if (v18)
  {
    __int16 v21 = (unint64_t *)&v18->__shared_owners_;
    do
      unint64_t v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }

  unsigned __int8 v23 = v44;
  if (v44 == v43)
  {
    uint64_t v24 = 4LL;
    unsigned __int8 v23 = v43;
  }

  else
  {
    if (!v44) {
      goto LABEL_14;
    }
    uint64_t v24 = 5LL;
  }

  (*(void (**)(void))(*v23 + 8 * v24))();
LABEL_14:
  unsigned __int16 v25 = v46;
  if (v46 == v45)
  {
    uint64_t v26 = 4LL;
    unsigned __int16 v25 = v45;
  }

  else
  {
    if (!v46) {
      goto LABEL_19;
    }
    uint64_t v26 = 5LL;
  }

  (*(void (**)(void))(*v25 + 8 * v26))();
LABEL_19:
  v27 = v48;
  if (v48 == v47)
  {
    uint64_t v28 = 4LL;
    v27 = v47;
  }

  else
  {
    if (!v48) {
      goto LABEL_24;
    }
    uint64_t v28 = 5LL;
  }

  (*(void (**)(void))(*v27 + 8 * v28))();
LABEL_24:
  v29 = v50;
  if (v50 == v49)
  {
    uint64_t v30 = 4LL;
    v29 = v49;
  }

  else
  {
    if (!v50) {
      goto LABEL_29;
    }
    uint64_t v30 = 5LL;
  }

  (*(void (**)(void))(*v29 + 8 * v30))();
LABEL_29:
  v31 = v52;
  if (v52 == v51)
  {
    uint64_t v32 = 4LL;
    v31 = v51;
  }

  else
  {
    if (!v52) {
      goto LABEL_34;
    }
    uint64_t v32 = 5LL;
  }

  (*(void (**)(void))(*v31 + 8 * v32))();
LABEL_34:
  v33 = v54;
  if (v54 == v53)
  {
    uint64_t v34 = 4LL;
    v33 = v53;
  }

  else
  {
    if (!v54) {
      goto LABEL_39;
    }
    uint64_t v34 = 5LL;
  }

  (*(void (**)(void))(*v33 + 8 * v34))();
LABEL_39:
  v35 = v56;
  if (v56 == v55)
  {
    uint64_t v36 = 4LL;
    v35 = v55;
  }

  else
  {
    if (!v56) {
      goto LABEL_44;
    }
    uint64_t v36 = 5LL;
  }

  (*(void (**)(void))(*v35 + 8 * v36))();
LABEL_44:
  v37 = v58;
  if (v58 == v57)
  {
    uint64_t v38 = 4LL;
    v37 = v57;
  }

  else
  {
    if (!v58) {
      goto LABEL_49;
    }
    uint64_t v38 = 5LL;
  }

  (*(void (**)(void))(*v37 + 8 * v38))();
LABEL_49:
  v39 = v60;
  if (v60 == v59)
  {
    uint64_t v40 = 4LL;
    v39 = v59;
    goto LABEL_53;
  }

  if (v60)
  {
    uint64_t v40 = 5LL;
LABEL_53:
    (*(void (**)(void))(*v39 + 8 * v40))();
  }

  *a1 = off_1007B96A8;
  a1[1] = off_1007B9770;
  sub_10027477C(a1 + 72, a8);
  sub_100274814(a1 + 76, a9);
  sub_1002748AC(a1 + 80, a10);
  return a1;
}

void sub_10027458C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, char *a19, char a20, uint64_t a21, uint64_t a22, char *a23, char a24, uint64_t a25, uint64_t a26, char *a27, char a28, uint64_t a29, uint64_t a30, char *a31, char a32, uint64_t a33, uint64_t a34, char *a35)
{
  uint64_t v38 = a19;
  if (a19 == v35)
  {
    uint64_t v39 = 4LL;
    uint64_t v38 = &a16;
  }

  else
  {
    if (!a19) {
      goto LABEL_6;
    }
    uint64_t v39 = 5LL;
  }

  (*(void (**)(void))(*(void *)v38 + 8 * v39))();
LABEL_6:
  uint64_t v40 = a23;
  if (a23 == &a20)
  {
    uint64_t v41 = 4LL;
    uint64_t v40 = &a20;
  }

  else
  {
    if (!a23) {
      goto LABEL_11;
    }
    uint64_t v41 = 5LL;
  }

  (*(void (**)(void))(*(void *)v40 + 8 * v41))();
LABEL_11:
  v42 = a27;
  if (a27 == &a24)
  {
    uint64_t v43 = 4LL;
    v42 = &a24;
  }

  else
  {
    if (!a27) {
      goto LABEL_16;
    }
    uint64_t v43 = 5LL;
  }

  (*(void (**)(void))(*(void *)v42 + 8 * v43))();
LABEL_16:
  v44 = a31;
  if (a31 == &a28)
  {
    uint64_t v45 = 4LL;
    v44 = &a28;
  }

  else
  {
    if (!a31) {
      goto LABEL_21;
    }
    uint64_t v45 = 5LL;
  }

  (*(void (**)(void))(*(void *)v44 + 8 * v45))();
LABEL_21:
  v46 = a35;
  if (a35 == &a32)
  {
    uint64_t v47 = 4LL;
    v46 = &a32;
  }

  else
  {
    if (!a35) {
      goto LABEL_26;
    }
    uint64_t v47 = 5LL;
  }

  (*(void (**)(void))(*(void *)v46 + 8 * v47))();
LABEL_26:
  v48 = *(void **)(v36 - 176);
  if (v48 == (void *)(v36 - 200))
  {
    uint64_t v49 = 4LL;
    v48 = (void *)(v36 - 200);
  }

  else
  {
    if (!v48) {
      goto LABEL_31;
    }
    uint64_t v49 = 5LL;
  }

  (*(void (**)(void))(*v48 + 8 * v49))();
LABEL_31:
  v50 = *(void **)(v36 - 144);
  if (v50 == (void *)(v36 - 168))
  {
    uint64_t v51 = 4LL;
    v50 = (void *)(v36 - 168);
  }

  else
  {
    if (!v50) {
      goto LABEL_36;
    }
    uint64_t v51 = 5LL;
  }

  (*(void (**)(void))(*v50 + 8 * v51))();
LABEL_36:
  v52 = *(void **)(v36 - 112);
  if (v52 == (void *)(v36 - 136))
  {
    uint64_t v53 = 4LL;
    v52 = (void *)(v36 - 136);
  }

  else
  {
    if (!v52) {
      goto LABEL_41;
    }
    uint64_t v53 = 5LL;
  }

  (*(void (**)(void))(*v52 + 8 * v53))();
LABEL_41:
  v54 = *(void **)(v36 - 80);
  if (v54 == (void *)(v36 - 104))
  {
    uint64_t v55 = 4LL;
    v54 = (void *)(v36 - 104);
  }

  else
  {
    if (!v54) {
      goto LABEL_46;
    }
    uint64_t v55 = 5LL;
  }

  (*(void (**)(void))(*v54 + 8 * v55))();
LABEL_46:
  _Unwind_Resume(a1);
}

void *sub_10027477C(void *a1, uint64_t a2)
{
  int v3 = v7;
  if (v7 == v6)
  {
    uint64_t v4 = 4LL;
    int v3 = v6;
    goto LABEL_5;
  }

  if (v7)
  {
    uint64_t v4 = 5LL;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  return a1;
}

void *sub_100274814(void *a1, uint64_t a2)
{
  int v3 = v7;
  if (v7 == v6)
  {
    uint64_t v4 = 4LL;
    int v3 = v6;
    goto LABEL_5;
  }

  if (v7)
  {
    uint64_t v4 = 5LL;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  return a1;
}

void *sub_1002748AC(void *a1, uint64_t a2)
{
  int v3 = v7;
  if (v7 == v6)
  {
    uint64_t v4 = 4LL;
    int v3 = v6;
    goto LABEL_5;
  }

  if (v7)
  {
    uint64_t v4 = 5LL;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  return a1;
}

void *sub_100274944( void *a1, __int128 *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  return sub_100274244(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t sub_100274958(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 332)) {
    sub_1003A3C40();
  }
  return *(unsigned int *)(a1 + 328);
}

uint64_t sub_100274978(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 324)) {
    sub_1003A3C40();
  }
  return *(unsigned int *)(a1 + 320);
}

void sub_100274998(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v3 = (os_log_s *)qword_1008000A0;
  if (!*(_BYTE *)(a1 + 682))
  {
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
      sub_1003A3C68();
    }
    char v16 = 0;
    uint64_t v17 = a3;
    *(_DWORD *)a3 = -1000;
LABEL_41:
    *(_BYTE *)(v17 + 8) = 0;
    goto LABEL_44;
  }

  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    *(void *)&uint8_t buf[4] = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "#rose-ses,Alisha range enable. Preferred start time offset usec: %llu",  buf,  0xCu);
  }

  uint64_t v6 = *(void *)(a1 + 560);
  if (v6)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 144LL))(a1);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 64LL))(v6, v7, a2);
  }

  int v8 = 0;
  uint64_t v9 = 1000 * a2;
  uint64_t v20 = v9;
  int v10 = -1000;
  while (v8 <= 8)
  {
    if (v8 >= 1)
    {
      uint64_t v11 = (os_log_s *)(id)qword_1008000A0;
      BOOL v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
      if (v10 == 6)
      {
        if (v12)
        {
          sub_1002BEFAC(6, __p);
          uint64_t v13 = __p;
          if (v22 < 0) {
            uint64_t v13 = (void **)__p[0];
          }
          *(_DWORD *)buf = 136315906;
          *(void *)&uint8_t buf[4] = v13;
          __int16 v26 = 2048;
          *(void *)v27 = a2;
          *(_WORD *)&v27[8] = 1024;
          int v28 = v8;
          __int16 v29 = 1024;
          int v30 = 8;
          _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#rose-ses,Alisha range enable retry. Last status code %s. Sleeping for %llu usec. %d of %d retries.",  buf,  0x22u);
          if (v22 < 0) {
            operator delete(__p[0]);
          }
        }

        if (a2 > 0)
        {
          *(void *)buf = v20;
          std::this_thread::sleep_for ((const std::chrono::nanoseconds *)buf);
        }
      }

      else
      {
        if (v12)
        {
          sub_1002BEFAC(v10, __p);
          uint64_t v14 = __p;
          if (v22 < 0) {
            uint64_t v14 = (void **)__p[0];
          }
          *(_DWORD *)buf = 136315650;
          *(void *)&uint8_t buf[4] = v14;
          __int16 v26 = 1024;
          *(_DWORD *)v27 = v8;
          *(_WORD *)&v27[4] = 1024;
          *(_DWORD *)&v27[6] = 8;
          _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#rose-ses,Alisha range enable retry. Last status code %s. Not sleeping. %d of %d retries.",  buf,  0x18u);
          if (v22 < 0) {
            operator delete(__p[0]);
          }
        }
      }
    }

    if (sub_100270458(a1, 1000LL))
    {
      buf[0] = 0;
      char v31 = 0;
      uint64_t v32 = a2;
      char v33 = 1;
      __int128 v34 = 0u;
      __int128 v35 = 0u;
      __int128 v36 = 0u;
      int v37 = 0;
      sub_100274D58(a1, (__int128 *)buf, (uint64_t)__p);
      int v10 = (int)__p[0];
      if (LODWORD(__p[0]) == -1022 || LODWORD(__p[0]) == 6)
      {
        int v15 = 0;
      }

      else
      {
        if (!LODWORD(__p[0]))
        {
          if (!v24) {
            sub_1003A3C94();
          }
          uint64_t v18 = v23;
          goto LABEL_43;
        }

        int v15 = 3;
      }

      if (LODWORD(__p[0]) != 6 && LODWORD(__p[0]) != -1022) {
        goto LABEL_35;
      }
    }

    else
    {
      int v10 = -1025;
    }

    int v15 = 0;
    ++v8;
LABEL_35:
    if (v15) {
      break;
    }
  }

  if (v10)
  {
    char v16 = 0;
    uint64_t v17 = a3;
    *(_DWORD *)a3 = v10;
    goto LABEL_41;
  }

  uint64_t v18 = 0LL;
LABEL_43:
  uint64_t v17 = a3;
  *(_DWORD *)a3 = 0;
  *(void *)(a3 + 8) = v18;
  char v16 = 1;
LABEL_44:
  *(_BYTE *)(v17 + 16) = v16;
}

void sub_100274D3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100274D58(uint64_t a1@<X0>, __int128 *a2@<X1>, uint64_t a3@<X8>)
{
  if (!*(_BYTE *)(a1 + 682)) {
    sub_1003A3CBC();
  }
  __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 888);
  __lk.__owns_ = 1;
  std::mutex::lock((std::mutex *)(a1 + 888));
  uint64_t v6 = (void **)(a1 + 1056);
  uint64_t v7 = *(void **)(a1 + 1056);
  *(void *)(a1 + 1056) = 0LL;
  if (v7) {
    sub_1002766C4(a1 + 1056, v7);
  }
  if (*(_BYTE *)(a1 + 984))
  {
    *(_BYTE *)(a1 + 984) = 0;
  }

  if (sub_100272BA0(a1, a2))
  {
    int v8 = -1000;
LABEL_10:
    *(_DWORD *)a3 = v8;
    *(_BYTE *)(a3 + 4) = 0;
    *(_BYTE *)(a3 + 38) = 0;
    goto LABEL_58;
  }

  v9.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_ + 1000000000;
  do
  {
    if (*v6 || *(_BYTE *)(a1 + 984)) {
      goto LABEL_31;
    }
    if (std::chrono::steady_clock::now().__d_.__rep_ >= v9.__d_.__rep_) {
      break;
    }
    v10.__d_.__rep_ = v9.__d_.__rep_ - std::chrono::steady_clock::now().__d_.__rep_;
    if (v10.__d_.__rep_ >= 1)
    {
      std::chrono::steady_clock::now();
      v11.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
      if (v11.__d_.__rep_)
      {
        if (v11.__d_.__rep_ < 1)
        {
          if ((unint64_t)v11.__d_.__rep_ < 0xFFDF3B645A1CAC09LL)
          {
            std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v12 = 0x8000000000000000LL;
            goto LABEL_26;
          }
        }

        else if ((unint64_t)v11.__d_.__rep_ > 0x20C49BA5E353F7LL)
        {
          std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v12 = 0x7FFFFFFFFFFFFFFFLL;
          goto LABEL_24;
        }

        std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v12 = 1000 * v11.__d_.__rep_;
      }

      else
      {
        std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v12 = 0LL;
      }

void sub_1002750B8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22, char a23, std::mutex *a24, char a25)
{
  if (a23 && a22 < 0) {
    operator delete(__p);
  }
  if (a25) {
    std::mutex::unlock(a24);
  }
  _Unwind_Resume(a1);
}

void sub_100275110(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

void sub_100275118(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  unsigned __int8 v3 = atomic_load((unsigned __int8 *)(a1 + 836));
  if ((v3 & 1) != 0)
  {
    uint64_t v5 = *(void *)(a1 + 560);
    if (v5)
    {
      uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 144LL))(a1);
      (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 72LL))(v5, v6);
    }

    sub_1002752B4(a1, &v11);
    if (sub_10026FAA8(a1))
    {
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
        sub_1003A3D34();
      }
      v7[0] = 0;
      char v10 = 0;
      *(_DWORD *)a2 = 0;
      sub_1002760F0((__n128 *)(a2 + 8), (uint64_t)v7);
      if (v10 && __p)
      {
        std::chrono::steady_clock::time_point v9 = __p;
        operator delete(__p);
      }
    }

    else
    {
      *(_DWORD *)a2 = 0;
      sub_1002760F0((__n128 *)(a2 + 8), (uint64_t)&v11);
    }
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
      sub_1003A3D08();
    }
    v11.n128_u8[0] = 0;
    char v13 = 0;
    *(_DWORD *)a2 = 0;
    sub_1002760F0((__n128 *)(a2 + 8), (uint64_t)&v11);
  }

  if (v13)
  {
    if (v11.n128_u64[1])
    {
      unint64_t v12 = v11.n128_u64[1];
      operator delete((void *)v11.n128_u64[1]);
    }
  }

void sub_100275260( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, int a17, __int16 a18, char a19, char a20, void *__p, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27)
{
  if (a16) {
    sub_1003A3CE4((uint64_t)&a9);
  }
  if (a27)
  {
    if (__p)
    {
      a22 = (uint64_t)__p;
      operator delete(__p);
    }
  }

  _Unwind_Resume(exception_object);
}

void sub_1002752B4(uint64_t a1@<X0>, __n128 *a2@<X8>)
{
  __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 888);
  __lk.__owns_ = 1;
  std::mutex::lock((std::mutex *)(a1 + 888));
  uint64_t v4 = (unsigned __int8 *)(a1 + 1048);
  if (*(_BYTE *)(a1 + 1048))
  {
    uint64_t v5 = *(void **)(a1 + 1000);
    if (v5)
    {
      *(void *)(a1 + 1008) = v5;
      operator delete(v5);
    }

    *uint64_t v4 = 0;
  }

  uint64_t v6 = sub_100288340();
  int v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 144LL))(a1);
  int v8 = sub_100288578((uint64_t)v6, v7);
  if (!v8)
  {
    v11.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_ + 1000000000;
    while (1)
    {
      if (*v4)
      {
LABEL_36:
        sub_1002760F0(a2, a1 + 992);
        if (!*v4) {
          goto LABEL_15;
        }
        char v16 = *(void **)(a1 + 1000);
        if (v16)
        {
          *(void *)(a1 + 1008) = v16;
          operator delete(v16);
        }

        goto LABEL_14;
      }

      if (std::chrono::steady_clock::now().__d_.__rep_ >= v11.__d_.__rep_) {
        goto LABEL_35;
      }
      v12.__d_.__rep_ = v11.__d_.__rep_ - std::chrono::steady_clock::now().__d_.__rep_;
      if (v12.__d_.__rep_ >= 1) {
        break;
      }
LABEL_34:
      if (std::chrono::steady_clock::now().__d_.__rep_ >= v11.__d_.__rep_)
      {
LABEL_35:
        if (!*v4)
        {
          if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
            sub_1003A3D60();
          }
          goto LABEL_9;
        }

        goto LABEL_36;
      }
    }

    std::chrono::steady_clock::now();
    v13.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
    if (v13.__d_.__rep_)
    {
      if (v13.__d_.__rep_ < 1)
      {
        if ((unint64_t)v13.__d_.__rep_ < 0xFFDF3B645A1CAC09LL)
        {
          std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v14 = 0x8000000000000000LL;
          goto LABEL_32;
        }
      }

      else if ((unint64_t)v13.__d_.__rep_ > 0x20C49BA5E353F7LL)
      {
        std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v14 = 0x7FFFFFFFFFFFFFFFLL;
        goto LABEL_30;
      }

      std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v14 = 1000 * v13.__d_.__rep_;
    }

    else
    {
      std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v14 = 0LL;
    }

void sub_10027552C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::mutex *a13, char a14)
{
  if (a14) {
    std::mutex::unlock(a13);
  }
  _Unwind_Resume(exception_object);
}

void sub_100275560(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
}

uint64_t sub_100275568(uint64_t a1, uint64_t a2)
{
  v2 = (os_log_s *)qword_1008000A0;
  if (*(_BYTE *)(a1 + 682))
  {
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      *(void *)&uint8_t buf[4] = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "#rose-ses,Alisha range enable. Start time bt clk usec: %llu",  buf,  0xCu);
    }

    if (sub_100270458(a1, 1000LL))
    {
      buf[0] = 0;
      buf[40] = 0;
      uint64_t v8 = a2;
      char v9 = 3;
      __int128 v10 = 0u;
      __int128 v11 = 0u;
      __int128 v12 = 0u;
      int v13 = 0;
      sub_100274D58(a1, (__int128 *)buf, (uint64_t)v6);
      return v6[0];
    }

    else
    {
      return 4294966271LL;
    }
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
      sub_1003A3C68();
    }
    return 4294966296LL;
  }

__n128 sub_100275694@<Q0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  unsigned __int8 v3 = (__n128 *)a1[2];
  if (v3)
  {
    uint64_t v4 = a1[1];
    *(_WORD *)a2 = v3->n128_u16[0];
    *(void *)(a2 + 8) = v4;
    uint64_t v5 = (__n128 *)operator new(0x22uLL);
    unsigned __int16 v6 = v3[2].n128_u16[0];
    __n128 result = v3[1];
    *uint64_t v5 = *v3;
    v5[1] = result;
    v5[2].n128_u16[0] = v6;
    *(void *)(a2 + 16) = v5;
    *(void *)(a2 + 24) = 0LL;
    *(void *)(a2 + 40) = 0LL;
LABEL_5:
    *(void *)(a2 + 32) = 0LL;
    return result;
  }

  uint64_t v8 = a1[3];
  if (v8)
  {
    uint64_t v9 = a1[1];
    *(_WORD *)a2 = *(_WORD *)(v8 + 1);
    *(void *)(a2 + 8) = v9;
    *(void *)(a2 + 16) = 0LL;
    __int128 v10 = operator new(0x89uLL);
    _OWORD *v10 = *(_OWORD *)v8;
    __int128 v11 = *(_OWORD *)(v8 + 16);
    __int128 v12 = *(_OWORD *)(v8 + 32);
    __int128 v13 = *(_OWORD *)(v8 + 64);
    v10[3] = *(_OWORD *)(v8 + 48);
    v10[4] = v13;
    v10[1] = v11;
    _BYTE v10[2] = v12;
    __n128 result = *(__n128 *)(v8 + 80);
    __int128 v14 = *(_OWORD *)(v8 + 96);
    __int128 v15 = *(_OWORD *)(v8 + 112);
    *(_OWORD *)((char *)v10 + 121) = *(_OWORD *)(v8 + 121);
    v10[6] = v14;
    v10[7] = v15;
    v10[5] = result;
    *(void *)(a2 + 40) = 0LL;
    *(void *)(a2 + 24) = v10;
    goto LABEL_5;
  }

  uint64_t v16 = a1[4];
  if (v16)
  {
    uint64_t v17 = a1[1];
    *(_WORD *)a2 = *(_WORD *)(v16 + 1);
    *(void *)(a2 + 8) = v17;
    *(void *)(a2 + 16) = 0LL;
    *(void *)(a2 + 24) = 0LL;
    uint64_t v18 = (char *)operator new(0x1AuLL);
    __n128 result = *(__n128 *)v16;
    *(_OWORD *)(v18 + 10) = *(_OWORD *)(v16 + 10);
    *(__n128 *)uint64_t v18 = result;
    *(void *)(a2 + 32) = v18;
    *(void *)(a2 + 40) = 0LL;
  }

  else
  {
    __int16 v19 = (__n128 *)a1[5];
    if (!v19)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error( exception,  "Ill formed AlishaUpdate has no data (range_response, block_complete_event, session_stats, or key_expired_event)");
    }

    uint64_t v20 = a1[1];
    *(_WORD *)a2 = 0;
    *(void *)(a2 + 8) = v20;
    *(void *)(a2 + 16) = 0LL;
    *(void *)(a2 + 24) = 0LL;
    *(void *)(a2 + 32) = 0LL;
    int v21 = (__n128 *)operator new(0x44uLL);
    *int v21 = *v19;
    __n128 result = v19[1];
    __n128 v22 = v19[2];
    __n128 v23 = v19[3];
    v21[4].n128_u32[0] = v19[4].n128_u32[0];
    v21[2] = v22;
    v21[3] = v23;
    v21[1] = result;
    *(void *)(a2 + 40) = v21;
  }

  return result;
}

void sub_100275818(_Unwind_Exception *a1)
{
}

BOOL sub_100275854(uint64_t a1, void *a2)
{
  return *a2 == 2002LL;
}

void *sub_100275870( void *a1, __int128 *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  v54 = 0LL;
  sub_10001E914((uint64_t)v51, a5);
  v50 = 0LL;
  v48 = 0LL;
  sub_10001E914((uint64_t)v45, a7);
  sub_10001E914((uint64_t)v43, a8);
  v42 = 0LL;
  uint64_t v16 = (std::__shared_weak_count *)a9[1];
  v40[0] = *a9;
  v40[1] = v16;
  if (v16)
  {
    p_shared_owners = (unint64_t *)&v16->__shared_owners_;
    do
      unint64_t v18 = __ldxr(p_shared_owners);
    while (__stxr(v18 + 1, p_shared_owners));
  }

  sub_10026F104( (uint64_t)a1,  a2,  a3,  (uint64_t)v57,  (uint64_t)v55,  (uint64_t)v53,  (uint64_t)v51,  (uint64_t)v49,  (uint64_t)v47,  (uint64_t)v45,  (uint64_t)v43,  (uint64_t)v41,  v40);
  if (v16)
  {
    __int16 v19 = (unint64_t *)&v16->__shared_owners_;
    do
      unint64_t v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }

  int v21 = v42;
  if (v42 == v41)
  {
    uint64_t v22 = 4LL;
    int v21 = v41;
  }

  else
  {
    if (!v42) {
      goto LABEL_14;
    }
    uint64_t v22 = 5LL;
  }

  (*(void (**)(void))(*v21 + 8 * v22))();
LABEL_14:
  __n128 v23 = v44;
  if (v44 == v43)
  {
    uint64_t v24 = 4LL;
    __n128 v23 = v43;
  }

  else
  {
    if (!v44) {
      goto LABEL_19;
    }
    uint64_t v24 = 5LL;
  }

  (*(void (**)(void))(*v23 + 8 * v24))();
LABEL_19:
  unsigned __int16 v25 = v46;
  if (v46 == v45)
  {
    uint64_t v26 = 4LL;
    unsigned __int16 v25 = v45;
  }

  else
  {
    if (!v46) {
      goto LABEL_24;
    }
    uint64_t v26 = 5LL;
  }

  (*(void (**)(void))(*v25 + 8 * v26))();
LABEL_24:
  v27 = v48;
  if (v48 == v47)
  {
    uint64_t v28 = 4LL;
    v27 = v47;
  }

  else
  {
    if (!v48) {
      goto LABEL_29;
    }
    uint64_t v28 = 5LL;
  }

  (*(void (**)(void))(*v27 + 8 * v28))();
LABEL_29:
  __int16 v29 = v50;
  if (v50 == v49)
  {
    uint64_t v30 = 4LL;
    __int16 v29 = v49;
  }

  else
  {
    if (!v50) {
      goto LABEL_34;
    }
    uint64_t v30 = 5LL;
  }

  (*(void (**)(void))(*v29 + 8 * v30))();
LABEL_34:
  char v31 = v52;
  if (v52 == v51)
  {
    uint64_t v32 = 4LL;
    char v31 = v51;
  }

  else
  {
    if (!v52) {
      goto LABEL_39;
    }
    uint64_t v32 = 5LL;
  }

  (*(void (**)(void))(*v31 + 8 * v32))();
LABEL_39:
  char v33 = v54;
  if (v54 == v53)
  {
    uint64_t v34 = 4LL;
    char v33 = v53;
  }

  else
  {
    if (!v54) {
      goto LABEL_44;
    }
    uint64_t v34 = 5LL;
  }

  (*(void (**)(void))(*v33 + 8 * v34))();
LABEL_44:
  __int128 v35 = v56;
  if (v56 == v55)
  {
    uint64_t v36 = 4LL;
    __int128 v35 = v55;
  }

  else
  {
    if (!v56) {
      goto LABEL_49;
    }
    uint64_t v36 = 5LL;
  }

  (*(void (**)(void))(*v35 + 8 * v36))();
LABEL_49:
  int v37 = v58;
  if (v58 == v57)
  {
    uint64_t v38 = 4LL;
    int v37 = v57;
    goto LABEL_53;
  }

  if (v58)
  {
    uint64_t v38 = 5LL;
LABEL_53:
    (*(void (**)(void))(*v37 + 8 * v38))();
  }

  *a1 = &off_1007B97A8;
  a1[1] = off_1007B9870;
  return a1;
}

void sub_100275B9C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, char *a19, char a20, uint64_t a21, uint64_t a22, char *a23, char a24, uint64_t a25, uint64_t a26, char *a27, char a28, uint64_t a29, uint64_t a30, char *a31, char a32, uint64_t a33, uint64_t a34, char *a35)
{
  uint64_t v38 = a19;
  if (a19 == v35)
  {
    uint64_t v39 = 4LL;
    uint64_t v38 = &a16;
  }

  else
  {
    if (!a19) {
      goto LABEL_6;
    }
    uint64_t v39 = 5LL;
  }

  (*(void (**)(void))(*(void *)v38 + 8 * v39))();
LABEL_6:
  uint64_t v40 = a23;
  if (a23 == &a20)
  {
    uint64_t v41 = 4LL;
    uint64_t v40 = &a20;
  }

  else
  {
    if (!a23) {
      goto LABEL_11;
    }
    uint64_t v41 = 5LL;
  }

  (*(void (**)(void))(*(void *)v40 + 8 * v41))();
LABEL_11:
  v42 = a27;
  if (a27 == &a24)
  {
    uint64_t v43 = 4LL;
    v42 = &a24;
  }

  else
  {
    if (!a27) {
      goto LABEL_16;
    }
    uint64_t v43 = 5LL;
  }

  (*(void (**)(void))(*(void *)v42 + 8 * v43))();
LABEL_16:
  v44 = a31;
  if (a31 == &a28)
  {
    uint64_t v45 = 4LL;
    v44 = &a28;
  }

  else
  {
    if (!a31) {
      goto LABEL_21;
    }
    uint64_t v45 = 5LL;
  }

  (*(void (**)(void))(*(void *)v44 + 8 * v45))();
LABEL_21:
  v46 = a35;
  if (a35 == &a32)
  {
    uint64_t v47 = 4LL;
    v46 = &a32;
  }

  else
  {
    if (!a35) {
      goto LABEL_26;
    }
    uint64_t v47 = 5LL;
  }

  (*(void (**)(void))(*(void *)v46 + 8 * v47))();
LABEL_26:
  v48 = *(void **)(v36 - 176);
  if (v48 == (void *)(v36 - 200))
  {
    uint64_t v49 = 4LL;
    v48 = (void *)(v36 - 200);
  }

  else
  {
    if (!v48) {
      goto LABEL_31;
    }
    uint64_t v49 = 5LL;
  }

  (*(void (**)(void))(*v48 + 8 * v49))();
LABEL_31:
  v50 = *(void **)(v36 - 144);
  if (v50 == (void *)(v36 - 168))
  {
    uint64_t v51 = 4LL;
    v50 = (void *)(v36 - 168);
  }

  else
  {
    if (!v50) {
      goto LABEL_36;
    }
    uint64_t v51 = 5LL;
  }

  (*(void (**)(void))(*v50 + 8 * v51))();
LABEL_36:
  v52 = *(void **)(v36 - 112);
  if (v52 == (void *)(v36 - 136))
  {
    uint64_t v53 = 4LL;
    v52 = (void *)(v36 - 136);
  }

  else
  {
    if (!v52) {
      goto LABEL_41;
    }
    uint64_t v53 = 5LL;
  }

  (*(void (**)(void))(*v52 + 8 * v53))();
LABEL_41:
  v54 = *(void **)(v36 - 80);
  if (v54 == (void *)(v36 - 104))
  {
    uint64_t v55 = 4LL;
    v54 = (void *)(v36 - 104);
  }

  else
  {
    if (!v54) {
      goto LABEL_46;
    }
    uint64_t v55 = 5LL;
  }

  (*(void (**)(void))(*v54 + 8 * v55))();
LABEL_46:
  _Unwind_Resume(a1);
}

void *sub_100275D84( void *a1, __int128 *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  return sub_100275870(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

uint64_t sub_100275D90(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 392)) {
    sub_1003A3DEC();
  }
  return *(unsigned int *)(a1 + 388);
}

uint64_t sub_100275DB0(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 384)) {
    sub_1003A3DEC();
  }
  return *(unsigned int *)(a1 + 380);
}

void *sub_100275DD0@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_1000065CC(a2, (&off_1007B9BD8)[a1 + 2]);
}

void *sub_100275E00@<X0>(int a1@<W0>, void *a2@<X8>)
{
  if (a1 == -1)
  {
    v2 = "UNDEFINED";
  }

  else
  {
    if (a1 != -2) {
      sub_1003A3E3C();
    }
    v2 = "SERVICE_ERROR";
  }

  return sub_1000065CC(a2, v2);
}

void sub_100275E44(uint64_t a1)
{
  v1 = (void *)sub_10026F6CC(a1);
  operator delete(v1);
}

uint64_t sub_100275E58(uint64_t a1)
{
  return sub_10026F6CC(a1 - 8);
}

void sub_100275E60(uint64_t a1)
{
  v1 = (void *)sub_10026F6CC(a1 - 8);
  operator delete(v1);
}

void sub_100275E7C(uint64_t a1)
{
  v1 = (void *)sub_10026F6CC(a1);
  operator delete(v1);
}

uint64_t sub_100275E90(uint64_t a1)
{
  return sub_10026F6CC(a1 - 8);
}

void sub_100275E98(uint64_t a1)
{
  v1 = (void *)sub_10026F6CC(a1 - 8);
  operator delete(v1);
}

uint64_t sub_100275EB0( uint64_t a1, int a2, char a3, __int16 a4, __int16 *a5, uint64_t a6, __int16 a7, int a8, __int16 a9)
{
  *(_DWORD *)a1 = a2;
  *(_BYTE *)(a1 + 4) = a3;
  *(_WORD *)(a1 + 6) = a4;
  sub_100275F4C((void *)(a1 + 8), a6 + 1);
  *(_WORD *)(a1 + 32) = a7;
  *(double *)(a1 + 40) = (double)a8 * 0.25;
  *(double *)(a1 + 48) = (double)a9 * 0.25;
  __int128 v13 = *(_WORD **)(a1 + 8);
  uint64_t v14 = *(void *)(a1 + 16) - (void)v13;
  if (v14)
  {
    unint64_t v15 = v14 >> 1;
    if (v15 <= 1) {
      unint64_t v15 = 1LL;
    }
    do
    {
      __int16 v16 = *a5++;
      *v13++ = v16;
      --v15;
    }

    while (v15);
  }

  return a1;
}

void *sub_100275F4C(void *a1, uint64_t a2)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if (a2)
  {
    sub_10018963C(a1, a2);
    uint64_t v4 = (char *)a1[1];
    bzero(v4, 2 * a2);
    a1[1] = &v4[2 * a2];
  }

  return a1;
}

void sub_100275FA4(_Unwind_Exception *exception_object)
{
  unsigned __int8 v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_100275FC0(uint64_t a1, uint64_t a2, char a3, int a4, char a5, char a6, uint64_t a7)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  sub_1001896FC( (void *)a1,  *(const void **)a2,  *(void *)(a2 + 8),  (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 1);
  *(void *)(a1 + 40) = 0LL;
  *(_BYTE *)(a1 + 24) = a3;
  *(_DWORD *)(a1 + 28) = a4;
  *(_BYTE *)(a1 + 32) = a5;
  *(_BYTE *)(a1 + 33) = a6;
  *(void *)(a1 + 48) = 0LL;
  *(void *)(a1 + 56) = 0LL;
  sub_1001309C0((void *)(a1 + 40), *(const void **)a7, *(void *)(a7 + 8), *(void *)(a7 + 8) - *(void *)a7);
  return a1;
}

void sub_100276048(_Unwind_Exception *exception_object)
{
  unsigned __int8 v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_100276064(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  sub_1001896FC( (void *)a1,  *(const void **)a2,  *(void *)(a2 + 8),  (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 1);
  uint64_t v4 = *(void *)(a2 + 24);
  __int16 v5 = *(_WORD *)(a2 + 32);
  *(void *)(a1 + 40) = 0LL;
  *(_WORD *)(a1 + 32) = v5;
  *(void *)(a1 + 24) = v4;
  *(void *)(a1 + 48) = 0LL;
  *(void *)(a1 + 56) = 0LL;
  sub_1001309C0( (void *)(a1 + 40),  *(const void **)(a2 + 40),  *(void *)(a2 + 48),  *(void *)(a2 + 48) - *(void *)(a2 + 40));
  *(_BYTE *)(a1 + 64) = 1;
  return a1;
}

void sub_1002760D4(_Unwind_Exception *exception_object)
{
  unsigned __int8 v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

__n128 *sub_1002760F0(__n128 *a1, uint64_t a2)
{
  a1->n128_u8[0] = 0;
  a1[3].n128_u8[8] = 0;
  sub_100276138(a1, a2);
  return a1;
}

void sub_10027611C(_Unwind_Exception *exception_object)
{
  if (*(_BYTE *)(v1 + 56)) {
    sub_1003A3E64(v1);
  }
  _Unwind_Resume(exception_object);
}

__n128 sub_100276138(__n128 *a1, uint64_t a2)
{
  if (*(_BYTE *)(a2 + 56))
  {
    a1->n128_u64[0] = *(void *)a2;
    a1[1].n128_u64[0] = 0LL;
    a1[1].n128_u64[1] = 0LL;
    a1->n128_u64[1] = 0LL;
    sub_1001896FC( &a1->n128_u64[1],  *(const void **)(a2 + 8),  *(void *)(a2 + 16),  (uint64_t)(*(void *)(a2 + 16) - *(void *)(a2 + 8)) >> 1);
    __n128 result = *(__n128 *)(a2 + 32);
    a1[3].n128_u64[0] = *(void *)(a2 + 48);
    a1[2] = result;
    a1[3].n128_u8[8] = 1;
  }

  return result;
}

_BYTE *sub_10027619C(_BYTE *a1, uint64_t a2)
{
  *a1 = 0;
  a1[64] = 0;
  if (*(_BYTE *)(a2 + 64))
  {
    sub_100189678((uint64_t)a1, a2);
    a1[64] = 1;
  }

  return a1;
}

void sub_1002761DC(_Unwind_Exception *a1)
{
}

void *sub_1002761F0(void *result, const void *a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    unsigned __int16 v6 = result;
    __n128 result = sub_10018963C(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }

  return result;
}

void sub_10027624C(_Unwind_Exception *exception_object)
{
  unsigned __int8 v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void *sub_100276268(void *result, void *a2)
{
  if (a2 != result)
  {
    unsigned __int8 v3 = result;
    uint64_t v4 = (void *)result[3];
    __int16 v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24LL))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32LL))(v3[3]);
        v3[3] = 0LL;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24LL))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32LL))(a2[3]);
        a2[3] = 0LL;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24LL))(v6, a2);
        __n128 result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32LL))(v6);
      }

      else
      {
        (*(void (**)(void *, void *))(*result + 24LL))(result, a2);
        __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32LL))(v3[3]);
        v3[3] = a2[3];
      }

      a2[3] = a2;
    }

    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24LL))(a2, result);
      __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32LL))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }

    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }

  return result;
}

void sub_1002763D0(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10000DE88(a1);
}

void *sub_1002763DC(void *result, void *a2)
{
  if (a2 != result)
  {
    unsigned __int8 v3 = result;
    uint64_t v4 = (void *)result[3];
    __int16 v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24LL))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32LL))(v3[3]);
        v3[3] = 0LL;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24LL))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32LL))(a2[3]);
        a2[3] = 0LL;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24LL))(v6, a2);
        __n128 result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32LL))(v6);
      }

      else
      {
        (*(void (**)(void *, void *))(*result + 24LL))(result, a2);
        __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32LL))(v3[3]);
        v3[3] = a2[3];
      }

      a2[3] = a2;
    }

    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24LL))(a2, result);
      __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32LL))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }

    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }

  return result;
}

void sub_100276544(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10000DE88(a1);
}

void *sub_100276550(void *result, void *a2)
{
  if (a2 != result)
  {
    unsigned __int8 v3 = result;
    uint64_t v4 = (void *)result[3];
    __int16 v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24LL))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32LL))(v3[3]);
        v3[3] = 0LL;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24LL))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32LL))(a2[3]);
        a2[3] = 0LL;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24LL))(v6, a2);
        __n128 result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32LL))(v6);
      }

      else
      {
        (*(void (**)(void *, void *))(*result + 24LL))(result, a2);
        __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32LL))(v3[3]);
        v3[3] = a2[3];
      }

      a2[3] = a2;
    }

    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24LL))(a2, result);
      __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32LL))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }

    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }

  return result;
}

void sub_1002766B8(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10000DE88(a1);
}

void sub_1002766C4(int a1, void *__p)
{
  if (__p)
  {
    unsigned __int8 v3 = (void *)__p[5];
    __p[5] = 0LL;
    if (v3) {
      operator delete(v3);
    }
    uint64_t v4 = (void *)__p[4];
    __p[4] = 0LL;
    if (v4) {
      operator delete(v4);
    }
    __int16 v5 = (void *)__p[3];
    __p[3] = 0LL;
    if (v5) {
      operator delete(v5);
    }
    unsigned __int16 v6 = (void *)__p[2];
    __p[2] = 0LL;
    if (v6) {
      operator delete(v6);
    }
    operator delete(__p);
  }

void sub_10027672C()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_1007F1D58);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1007F1D58))
    {
      sub_1000065CC(qword_1007F1D40, "PRRoseProviderNetworkListener");
      __cxa_atexit((void (*)(void *))&std::string::~string, qword_1007F1D40, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_1007F1D58);
    }
  }

void sub_1002767A8(_Unwind_Exception *a1)
{
}

void sub_1002767C0()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_1007F1D78);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1007F1D78))
    {
      qword_1007F1D60 = 0LL;
      qword_1007F1D68 = 0LL;
      qword_1007F1D70 = 0LL;
      uint64_t v1 = operator new(0x30uLL);
      qword_1007F1D68 = (uint64_t)(v1 + 3);
      qword_1007F1D70 = (uint64_t)(v1 + 3);
      _OWORD *v1 = xmmword_10042AD70;
      v1[1] = unk_10042AD80;
      v1[2] = xmmword_10042AD90;
      qword_1007F1D60 = (uint64_t)v1;
      __cxa_atexit((void (*)(void *))sub_1000040CC, &qword_1007F1D60, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_1007F1D78);
    }
  }

void sub_100276860(_Unwind_Exception *a1)
{
}

void sub_100276878()
{
  unsigned __int8 v0 = objc_autoreleasePoolPush();
  sub_100320A4C(0LL, &v37);
  uint64_t v1 = std::string::insert(&v37, 0LL, "reverseLUT_A");
  __int128 v2 = *(_OWORD *)&v1->__r_.__value_.__l.__data_;
  v38.__r_.__value_.__l.__cap_ = v1->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v2;
  v1->__r_.__value_.__l.__size_ = 0LL;
  v1->__r_.__value_.__l.__cap_ = 0LL;
  v1->__r_.__value_.__r.__words[0] = 0LL;
  unsigned __int8 v3 = std::string::append(&v38, ".bin");
  __int128 v4 = *(_OWORD *)&v3->__r_.__value_.__l.__data_;
  qword_1007FC260 = v3->__r_.__value_.__l.__cap_;
  xmmword_1007FC250 = v4;
  v3->__r_.__value_.__l.__size_ = 0LL;
  v3->__r_.__value_.__l.__cap_ = 0LL;
  v3->__r_.__value_.__r.__words[0] = 0LL;
  __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_1007FC250, (void *)&_mh_execute_header);
  sub_100320A4C(1LL, &v37);
  __int16 v5 = std::string::insert(&v37, 0LL, "reverseLUT_A");
  __int128 v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
  v38.__r_.__value_.__l.__cap_ = v5->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v6;
  v5->__r_.__value_.__l.__size_ = 0LL;
  v5->__r_.__value_.__l.__cap_ = 0LL;
  v5->__r_.__value_.__r.__words[0] = 0LL;
  uint64_t v7 = std::string::append(&v38, ".bin");
  __int128 v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
  qword_1007FC278 = v7->__r_.__value_.__l.__cap_;
  xmmword_1007FC268 = v8;
  v7->__r_.__value_.__l.__size_ = 0LL;
  v7->__r_.__value_.__l.__cap_ = 0LL;
  v7->__r_.__value_.__r.__words[0] = 0LL;
  __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_1007FC268, (void *)&_mh_execute_header);
  sub_100320A4C(2LL, &v37);
  uint64_t v9 = std::string::insert(&v37, 0LL, "reverseLUT_A");
  __int128 v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
  v38.__r_.__value_.__l.__cap_ = v9->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v10;
  v9->__r_.__value_.__l.__size_ = 0LL;
  v9->__r_.__value_.__l.__cap_ = 0LL;
  v9->__r_.__value_.__r.__words[0] = 0LL;
  __int128 v11 = std::string::append(&v38, ".bin");
  __int128 v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  qword_1007FC290 = v11->__r_.__value_.__l.__cap_;
  xmmword_1007FC280 = v12;
  v11->__r_.__value_.__l.__size_ = 0LL;
  v11->__r_.__value_.__l.__cap_ = 0LL;
  v11->__r_.__value_.__r.__words[0] = 0LL;
  __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_1007FC280, (void *)&_mh_execute_header);
  sub_100320A4C(3LL, &v37);
  __int128 v13 = std::string::insert(&v37, 0LL, "reverseLUT_A");
  __int128 v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
  v38.__r_.__value_.__l.__cap_ = v13->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v14;
  v13->__r_.__value_.__l.__size_ = 0LL;
  v13->__r_.__value_.__l.__cap_ = 0LL;
  v13->__r_.__value_.__r.__words[0] = 0LL;
  unint64_t v15 = std::string::append(&v38, ".bin");
  __int128 v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  qword_1007FC2A8 = v15->__r_.__value_.__l.__cap_;
  xmmword_1007FC298 = v16;
  v15->__r_.__value_.__l.__size_ = 0LL;
  v15->__r_.__value_.__l.__cap_ = 0LL;
  v15->__r_.__value_.__r.__words[0] = 0LL;
  __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_1007FC298, (void *)&_mh_execute_header);
  sub_100320A4C(4LL, &v37);
  uint64_t v17 = std::string::insert(&v37, 0LL, "reverseLUT_A");
  __int128 v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  v38.__r_.__value_.__l.__cap_ = v17->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v18;
  v17->__r_.__value_.__l.__size_ = 0LL;
  v17->__r_.__value_.__l.__cap_ = 0LL;
  v17->__r_.__value_.__r.__words[0] = 0LL;
  __int16 v19 = std::string::append(&v38, ".bin");
  __int128 v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
  qword_1007FC2C0 = v19->__r_.__value_.__l.__cap_;
  xmmword_1007FC2B0 = v20;
  v19->__r_.__value_.__l.__size_ = 0LL;
  v19->__r_.__value_.__l.__cap_ = 0LL;
  v19->__r_.__value_.__r.__words[0] = 0LL;
  __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_1007FC2B0, (void *)&_mh_execute_header);
  sub_100320A4C(5LL, &v37);
  int v21 = std::string::insert(&v37, 0LL, "reverseLUT_A");
  __int128 v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
  v38.__r_.__value_.__l.__cap_ = v21->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v22;
  v21->__r_.__value_.__l.__size_ = 0LL;
  v21->__r_.__value_.__l.__cap_ = 0LL;
  v21->__r_.__value_.__r.__words[0] = 0LL;
  __n128 v23 = std::string::append(&v38, ".bin");
  __int128 v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
  qword_1007FC2D8 = v23->__r_.__value_.__l.__cap_;
  xmmword_1007FC2C8 = v24;
  v23->__r_.__value_.__l.__size_ = 0LL;
  v23->__r_.__value_.__l.__cap_ = 0LL;
  v23->__r_.__value_.__r.__words[0] = 0LL;
  __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_1007FC2C8, (void *)&_mh_execute_header);
  sub_100320A4C(6LL, &v37);
  unsigned __int16 v25 = std::string::insert(&v37, 0LL, "reverseLUT_A");
  __int128 v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
  v38.__r_.__value_.__l.__cap_ = v25->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v26;
  v25->__r_.__value_.__l.__size_ = 0LL;
  v25->__r_.__value_.__l.__cap_ = 0LL;
  v25->__r_.__value_.__r.__words[0] = 0LL;
  v27 = std::string::append(&v38, ".bin");
  __int128 v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
  qword_1007FC2F0 = v27->__r_.__value_.__l.__cap_;
  xmmword_1007FC2E0 = v28;
  v27->__r_.__value_.__l.__size_ = 0LL;
  v27->__r_.__value_.__l.__cap_ = 0LL;
  v27->__r_.__value_.__r.__words[0] = 0LL;
  __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_1007FC2E0, (void *)&_mh_execute_header);
  sub_100320A4C(7LL, &v37);
  __int16 v29 = std::string::insert(&v37, 0LL, "reverseLUT_A");
  __int128 v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
  v38.__r_.__value_.__l.__cap_ = v29->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v30;
  v29->__r_.__value_.__l.__size_ = 0LL;
  v29->__r_.__value_.__l.__cap_ = 0LL;
  v29->__r_.__value_.__r.__words[0] = 0LL;
  char v31 = std::string::append(&v38, ".bin");
  __int128 v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
  qword_1007FC308 = v31->__r_.__value_.__l.__cap_;
  xmmword_1007FC2F8 = v32;
  v31->__r_.__value_.__l.__size_ = 0LL;
  v31->__r_.__value_.__l.__cap_ = 0LL;
  v31->__r_.__value_.__r.__words[0] = 0LL;
  __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_1007FC2F8, (void *)&_mh_execute_header);
  sub_100320A4C(8LL, &v37);
  char v33 = std::string::insert(&v37, 0LL, "reverseLUT_A");
  __int128 v34 = *(_OWORD *)&v33->__r_.__value_.__l.__data_;
  v38.__r_.__value_.__l.__cap_ = v33->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v34;
  v33->__r_.__value_.__l.__size_ = 0LL;
  v33->__r_.__value_.__l.__cap_ = 0LL;
  v33->__r_.__value_.__r.__words[0] = 0LL;
  __int128 v35 = std::string::append(&v38, ".bin");
  __int128 v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
  qword_1007FC320 = v35->__r_.__value_.__l.__cap_;
  xmmword_1007FC310 = v36;
  v35->__r_.__value_.__l.__size_ = 0LL;
  v35->__r_.__value_.__l.__cap_ = 0LL;
  v35->__r_.__value_.__r.__words[0] = 0LL;
  __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_1007FC310, (void *)&_mh_execute_header);
  objc_autoreleasePoolPop(v0);
}

void sub_100276E6C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100276FB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002772A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100277420( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  if (v18) {
    sub_1003A3E7C((uint64_t)&a18);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002774D0(id a1)
{
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](&OBJC_CLASS___NSUserDefaults, "standardUserDefaults"));
  __int128 v2 = (void *)objc_claimAutoreleasedReturnValue([v1 stringForKey:@"FindingDiscoveryFlowOverride"]);

  if (v2 && (uint64_t v4 = objc_opt_class(&OBJC_CLASS___NSString, v3), (objc_opt_isKindOfClass(v2, v4) & 1) != 0))
  {
    if (![v2 isEqualToString:@"NearbyActionNoWake_SpatialInteraction"])
    {
      if ([v2 isEqualToString:@"SpatialInteraction_BothSides"])
      {
        byte_1007FC330 = 1;
        __int16 v5 = (os_log_s *)qword_1008000A0;
        if (!os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_15;
        }
        if (byte_1007FC330) {
          uint64_t v9 = "SpatialInteraction_BothSides";
        }
        else {
          uint64_t v9 = "NearbyActionNoWake_SpatialInteraction";
        }
        int v11 = 136315138;
        __int128 v12 = v9;
        uint64_t v7 = "#find-common,Discovery flow override: %s";
      }

      else
      {
        __int16 v5 = (os_log_s *)qword_1008000A0;
        if (!os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_15;
        }
        if (byte_1007FC330) {
          __int128 v10 = "SpatialInteraction_BothSides";
        }
        else {
          __int128 v10 = "NearbyActionNoWake_SpatialInteraction";
        }
        int v11 = 136315138;
        __int128 v12 = v10;
        uint64_t v7 = "#find-common,Invalid discovery flow override. Returning discovery flow: %s";
      }

      goto LABEL_14;
    }

    byte_1007FC330 = 0;
    __int16 v5 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      if (byte_1007FC330) {
        __int128 v6 = "SpatialInteraction_BothSides";
      }
      else {
        __int128 v6 = "NearbyActionNoWake_SpatialInteraction";
      }
      int v11 = 136315138;
      __int128 v12 = v6;
      uint64_t v7 = "#find-common,Discovery flow override: %s";
LABEL_14:
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v11, 0xCu);
    }
  }

  else
  {
    __int16 v5 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      if (byte_1007FC330) {
        __int128 v8 = "SpatialInteraction_BothSides";
      }
      else {
        __int128 v8 = "NearbyActionNoWake_SpatialInteraction";
      }
      int v11 = 136315138;
      __int128 v12 = v8;
      uint64_t v7 = "#find-common,No discovery flow override. Returning discovery flow: %s";
      goto LABEL_14;
    }
  }

void sub_100277738(_Unwind_Exception *a1)
{
  __int128 v2 = v1;

  _Unwind_Resume(a1);
}

uint64_t sub_100277758(int a1)
{
  if (qword_1007FC328 != -1) {
    dispatch_once(&qword_1007FC328, &stru_1007B9BF0);
  }
  else {
    return 19LL;
  }
}

double sub_1002777B4(int a1)
{
  if (!a1) {
    return sub_1002777EC(@"PeopleFindingOOBRefreshPeriodSecondsOverride", 2.0);
  }
  if (a1 != 1) {
    sub_1003A3E9C();
  }
  return sub_1002777EC(@"DeviceFindingOOBRefreshPeriodSecondsOverride", 30.0);
}

double sub_1002777EC(void *a1, double a2)
{
  id v3 = a1;
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](&OBJC_CLASS___NSUserDefaults, "standardUserDefaults"));
  __int128 v6 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKey:v3]);
  if (v6)
  {
    uint64_t v7 = objc_opt_class(&OBJC_CLASS___NSNumber, v5);
    if ((objc_opt_isKindOfClass(v6, v7) & 1) != 0)
    {
      [v6 doubleValue];
      a2 = v8;
    }
  }

  return a2;
}

void sub_100277880(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double sub_1002778A8(int a1, int a2)
{
  if (!a2)
  {
    if (!a1) {
      return sub_1002777EC(@"PeopleFindingFindableDeviceKeepAliveOOBTimeoutSecondsOverride", 5.0);
    }
    if (a1 == 1) {
      return sub_1002777EC(@"DeviceFindingFindableDeviceKeepAliveOOBTimeoutSecondsOverride", 0.0);
    }
LABEL_11:
    sub_1003A3EC4();
  }

  if (!a1) {
    return sub_1002777EC(@"PeopleFindingFindableDeviceKeepAliveBluetoothTimeoutSecondsOverride", 10.0);
  }
  if (a1 != 1) {
    goto LABEL_11;
  }
  return sub_1002777EC(@"DeviceFindingFindableDeviceKeepAliveBluetoothTimeoutSecondsOverride", 0.0);
}

uint64_t sub_100277910(int a1)
{
  if (a1)
  {
    if (a1 != 1) {
      sub_1003A3EEC();
    }
    uint64_t v1 = @"DeviceFindingUWBDiscoveryTimeoutSecondsOverride";
  }

  else
  {
    uint64_t v1 = @"PeopleFindingUWBDiscoveryTimeoutSecondsOverride";
  }

  return sub_100277944(v1, 0x78u);
}

uint64_t sub_100277944(void *a1, unsigned __int16 a2)
{
  id v3 = a1;
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](&OBJC_CLASS___NSUserDefaults, "standardUserDefaults"));
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKey:v3]);

  if (v5)
  {
    uint64_t v7 = objc_opt_class(&OBJC_CLASS___NSNumber, v6);
    if ((objc_opt_isKindOfClass(v5, v7) & 1) != 0)
    {
      int v8 = [v5 intValue];
      if (v8 >= 0xFFFF) {
        a2 = -1;
      }
      else {
        a2 = v8;
      }
    }
  }

  return a2;
}

void sub_1002779D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100277A04(int a1)
{
  if (a1)
  {
    if (a1 != 1) {
      sub_1003A3F14();
    }
    uint64_t v1 = @"DeviceFindingUWBReacquisitionTimeoutSecondsOverride";
  }

  else
  {
    uint64_t v1 = @"PeopleFindingUWBReacquisitionTimeoutSecondsOverride";
  }

  return sub_100277944(v1, 0x3Cu);
}

const char *sub_100277A38(int a1)
{
  if (a1) {
    return "Device";
  }
  else {
    return "People";
  }
}

const char *sub_100277A54(int a1)
{
  if (a1) {
    return "Finder";
  }
  else {
    return "Findee";
  }
}

id sub_100277A70(uint64_t a1, int a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  uint64_t v9 = "Findee";
  if (a2) {
    uint64_t v9 = "Finder";
  }
  __int128 v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableString stringWithFormat:]( &OBJC_CLASS___NSMutableString,  "stringWithFormat:",  @"#event %-*s | Role: %-*s",  16LL,  a1,  14LL,  v9));
  if (v7)
  {
    int v11 = (void *)objc_claimAutoreleasedReturnValue([v7 descriptionInternal]);
    [v10 appendFormat:@" | Token: %@", v11];
  }

  if (v8) {
    [v10 appendFormat:@" | %@", v8];
  }

  return v10;
}

void sub_100277B48(_Unwind_Exception *a1)
{
  uint64_t v5 = v4;

  _Unwind_Resume(a1);
}

id sub_100277B78(void *a1)
{
  id v1 = a1;
  if (qword_1007FC338 != -1) {
    dispatch_once(&qword_1007FC338, &stru_1007B9C10);
  }
  __int128 v2 = (void *)objc_claimAutoreleasedReturnValue([(id)qword_1007FC340 stringFromDate:v1]);

  return v2;
}

void sub_100277BE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100277BF0(id a1)
{
  id v1 = objc_opt_new(&OBJC_CLASS___NSDateFormatter);
  __int128 v2 = (void *)qword_1007FC340;
  qword_1007FC340 = (uint64_t)v1;

  [(id)qword_1007FC340 setDateFormat:@"yyyy-MM-dd' 'HH:mm:ss'.'SSS"];
}

void sub_100277C30(void *a1, void *a2)
{
  id v3 = a1;
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now"));
  id v5 = sub_100277B78(v4);
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
  id v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%@ : %@", v6, v3));

  id v8 = v7;
  sub_1000065CC(__p, (char *)[v8 UTF8String]);
  sub_100277D4C(__p);
  sub_100277EE0(a2);
  sub_100277F54(a2, (__int128 *)__p);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100277D08( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  _Unwind_Resume(a1);
}

void sub_100277D4C(void *__dst)
{
  unint64_t v2 = *((unsigned __int8 *)__dst + 23);
  if ((*((char *)__dst + 23) & 0x80000000) == 0)
  {
    unint64_t v3 = v2 | 7;
    if ((v2 | 7) == 0x17)
    {
      unint64_t v4 = v2 & 0xF8;
      if (v4 <= 0xE)
      {
        unint64_t v5 = v4 + 9;
        uint64_t v6 = (void *)*__dst;
        char v7 = 1;
        uint64_t v8 = *((unsigned __int8 *)__dst + 23);
        uint64_t v9 = __dst;
        int v10 = 1;
        goto LABEL_20;
      }

      unint64_t v3 = v4 + 8;
    }

    uint64_t v8 = *((unsigned __int8 *)__dst + 23);
    goto LABEL_16;
  }

  unint64_t v11 = __dst[1];
  if (v11 < 0x17)
  {
    if ((__dst[2] & 0x7FFFFFFFFFFFFFFFLL) == 0x17) {
      return;
    }
    unint64_t v3 = 22LL;
    goto LABEL_13;
  }

  unint64_t v3 = (v11 & 0xFFFFFFFFFFFFFFF8LL) + 8;
  if ((v11 | 7) != 0x17) {
    unint64_t v3 = v11 | 7;
  }
  if (v3 != (__dst[2] & 0x7FFFFFFFFFFFFFFFLL) - 1)
  {
    if (v3 >= 0x17)
    {
      uint64_t v8 = __dst[1];
LABEL_16:
      unint64_t v5 = v3 + 1;
      uint64_t v9 = operator new(v3 + 1);
      char v7 = 0;
      if ((v2 & 0x80) == 0)
      {
        int v10 = 0;
        uint64_t v6 = __dst;
        goto LABEL_20;
      }

      unint64_t v11 = __dst[1];
LABEL_19:
      uint64_t v6 = (void *)*__dst;
      int v10 = 1;
      unint64_t v2 = v11;
LABEL_20:
      if (v2 == -1LL)
      {
        if (!v10) {
          goto LABEL_22;
        }
      }

      else
      {
        memmove(v9, v6, v2 + 1);
        if (!v10)
        {
LABEL_22:
          if ((v7 & 1) != 0)
          {
LABEL_23:
            *((_BYTE *)__dst + 23) = v8 & 0x7F;
            return;
          }

          goto LABEL_26;
        }
      }

      operator delete(v6);
      if ((v7 & 1) != 0) {
        goto LABEL_23;
      }
LABEL_26:
      __dst[1] = v8;
      __dst[2] = v5 | 0x8000000000000000LL;
      *__dst = v9;
      return;
    }

void sub_100277ED0(void *a1)
{
}

uint64_t sub_100277EE0(void *a1)
{
  unint64_t v2 = a1[4];
  unint64_t v3 = *(void *)(a1[1] + 8 * (v2 / 0xAA)) + 24 * (v2 % 0xAA);
  if (*(char *)(v3 + 23) < 0)
  {
    operator delete(*(void **)v3);
    unint64_t v2 = a1[4];
  }

  uint64_t v4 = a1[5] - 1LL;
  a1[4] = v2 + 1;
  a1[5] = v4;
  return sub_1002788FC((uint64_t)a1, 1);
}

void *sub_100277F54(void *a1, __int128 *a2)
{
  uint64_t v4 = a1[1];
  uint64_t v5 = a1[2];
  uint64_t v6 = 170 * ((v5 - v4) >> 3) - 1;
  if (v5 == v4) {
    uint64_t v6 = 0LL;
  }
  if (v6 == a1[5] + a1[4])
  {
    sub_100278958(a1);
    uint64_t v4 = a1[1];
    uint64_t v5 = a1[2];
  }

  if (v5 == v4)
  {
    __n128 result = 0LL;
  }

  else
  {
    unint64_t v7 = a1[5] + a1[4];
    __n128 result = (void *)(*(void *)(v4 + 8 * (v7 / 0xAA)) + 24 * (v7 % 0xAA));
  }

  if (*((char *)a2 + 23) < 0)
  {
    __n128 result = sub_1000063A8(result, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v9 = *a2;
    result[2] = *((void *)a2 + 2);
    *(_OWORD *)__n128 result = v9;
  }

  ++a1[5];
  return result;
}

id sub_10027801C(void *a1, int a2, int a3)
{
  id v5 = a1;
  if (a2 < 1)
  {
    __int128 v12 = "tokensPerLine > 0";
    int v13 = 368;
    goto LABEL_9;
  }

  if (a3 < 0)
  {
    __int128 v12 = "indentLevel >= 0";
    int v13 = 369;
LABEL_9:
    __assert_rtn("printableStringsForTokens", "NIServerFindingCommon.mm", v13, v12);
  }

  uint64_t v22 = 0LL;
  __n128 v23 = &v22;
  uint64_t v24 = 0x3032000000LL;
  unsigned __int16 v25 = sub_10027825C;
  __int128 v26 = sub_10027826C;
  v27 = objc_opt_new(&OBJC_CLASS___NSMutableArray);
  v20[0] = 0LL;
  v20[1] = v20;
  v20[2] = 0x3032000000LL;
  v20[3] = sub_10027825C;
  v20[4] = sub_10027826C;
  int v21 = objc_opt_new(&OBJC_CLASS___NSMutableArray);
  uint64_t v6 = objc_opt_new(&OBJC_CLASS___NSMutableString);
  int v7 = a3 + 1;
  while (--v7)
    -[NSMutableString appendString:](v6, "appendString:", @"    ");
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472LL;
  v14[2] = sub_100278274;
  v14[3] = &unk_1007B9C60;
  uint64_t v17 = v20;
  int v19 = a2;
  id v8 = v5;
  id v15 = v8;
  __int128 v9 = v6;
  __int128 v16 = v9;
  uint64_t v18 = &v22;
  [v8 enumerateObjectsUsingBlock:v14];
  id v10 = (id)v23[5];

  _Block_object_dispose(v20, 8);
  _Block_object_dispose(&v22, 8);

  return v10;
}

void sub_1002781EC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, id a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, id a30)
{
  _Block_object_dispose(&a19, 8);
  _Block_object_dispose(&a25, 8);

  _Unwind_Resume(a1);
}

uint64_t sub_10027825C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_10027826C(uint64_t a1)
{
}

void sub_100278274(uint64_t a1, void *a2, char *a3)
{
  id v5 = a2;
  [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) addObject:v5];
  if ((unint64_t)[*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) count] >= *(int *)(a1 + 64)
    || (char *)[*(id *)(a1 + 32) count] - 1 <= a3)
  {
    uint64_t v8 = 0LL;
    __int128 v9 = &v8;
    uint64_t v10 = 0x3032000000LL;
    unint64_t v11 = sub_10027825C;
    __int128 v12 = sub_10027826C;
    id v13 = [*(id *)(a1 + 40) mutableCopy];
    uint64_t v6 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472LL;
    v7[2] = sub_1002783D8;
    v7[3] = &unk_1007B9C38;
    v7[4] = &v8;
    [v6 enumerateObjectsUsingBlock:v7];
    [*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) addObject:v9[5]];
    [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) removeAllObjects];
    _Block_object_dispose(&v8, 8);
  }
}

void sub_1002783A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002783D8(uint64_t a1, void *a2)
{
  unint64_t v2 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
  id v3 = (id)objc_claimAutoreleasedReturnValue([a2 descriptionInternal]);
  [v2 appendFormat:@"%@ ", v3];
}

void sub_100278428( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

const char *sub_10027843C(int a1)
{
  if (a1 == 19) {
    return "SpatialInteraction";
  }
  else {
    return "NearbyActionNoWake";
  }
}

const char *sub_100278458(int a1)
{
  id v1 = "Unspecified";
  if (a1 == 2) {
    id v1 = "UWB";
  }
  if (a1 == 1) {
    return "NB-UWB";
  }
  else {
    return v1;
  }
}

BOOL sub_100278484(void *a1, int a2)
{
  uint64_t v2 = a1[1];
  if (*a1 == v2) {
    return 0LL;
  }
  uint64_t v3 = *a1 + 4LL;
  do
  {
    int v4 = *(_DWORD *)(v3 - 4);
    BOOL result = v4 == a2;
    BOOL v6 = v4 == a2 || v3 == v2;
    v3 += 4LL;
  }

  while (!v6);
  return result;
}

id sub_1002784B8(void *a1)
{
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1) {
    __assert_rtn("getCBOOBKeyAddressFromDiscoveryToken", "NIServerFindingCommon.mm", 491, "token");
  }
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([v1 getIRK]);
  int v4 = v3;
  if (v3)
  {
    uint64_t v7 = SipHash([v3 bytes], &unk_10042AEA5, 19);
    id v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", &v7, 6LL));
  }

  else
  {
    id v5 = 0LL;
  }

  return v5;
}

void sub_100278578(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100278598()
{
  unsigned __int8 v0 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](&OBJC_CLASS___NSUserDefaults, "standardUserDefaults"));
  if ([v0 BOOLForKey:@"FindingBypassDiscovery"])
  {
    id v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](&OBJC_CLASS___NSUserDefaults, "standardUserDefaults"));
    unsigned int v2 = [v1 BOOLForKey:@"FindingGateObjectUpdatesOnDiscovery"];

    if (v2)
    {
      uint64_t v3 = (os_log_s *)qword_1008000A0;
      uint64_t v4 = 0LL;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v8 = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "#find-common,Cannot set both FindingBypassDiscovery and FindingGateObjectUpdatesOnDiscovery defaults writes, remove one.",  v8,  2u);
        return 0LL;
      }

      return v4;
    }
  }

  else
  {
  }

  id v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](&OBJC_CLASS___NSUserDefaults, "standardUserDefaults"));
  if ([v5 BOOLForKey:@"FindingBypassDiscovery"])
  {
    uint64_t v4 = 1LL;
  }

  else
  {
    BOOL v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](&OBJC_CLASS___NSUserDefaults, "standardUserDefaults"));
    uint64_t v4 = (uint64_t)[v6 BOOLForKey:@"FindingGateObjectUpdatesOnDiscovery"];
  }

  return v4;
}

void sub_1002786B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002786E8(void *a1)
{
  id v1 = a1;
  unsigned int v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](&OBJC_CLASS___NSUserDefaults, "standardUserDefaults"));
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([v2 stringForKey:@"FindableDeviceFilterSingleTokenHash"]);

  if (v3)
  {
    uint64_t v5 = objc_opt_class(&OBJC_CLASS___NSString, v4);
    if ((objc_opt_isKindOfClass(v3, v5) & 1) != 0)
    {
      BOOL v6 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138477827;
        unint64_t v11 = v3;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#find-common,Findable device: override to use only %{private}@",  buf,  0xCu);
      }

      v8[0] = _NSConcreteStackBlock;
      v8[1] = 3221225472LL;
      v8[2] = sub_1002788AC;
      v8[3] = &unk_1007B9C88;
      id v9 = v3;
      uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSPredicate predicateWithBlock:](&OBJC_CLASS___NSPredicate, "predicateWithBlock:", v8));
      [v1 filterUsingPredicate:v7];
    }
  }
}

void sub_100278850( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  uint64_t v17 = v16;

  _Unwind_Resume(a1);
}

id sub_1002788AC(uint64_t a1, void *a2)
{
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([a2 descriptionInternal]);
  id v4 = [v3 isEqualToString:*(void *)(a1 + 32)];

  return v4;
}

void sub_1002788EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1002788FC(uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0xAA) {
    a2 = 1;
  }
  if (v2 < 0x154) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8LL;
    *(void *)(a1 + 32) -= 170LL;
  }

  return v4 ^ 1u;
}

void sub_100278958(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0xAA;
  unint64_t v4 = v2 - 170;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    BOOL v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    uint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    id v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)uint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      __int128 v34 = (char *)sub_1000472C0(v5, v33);
      __int128 v35 = &v34[8 * (v33 >> 2)];
      std::string v37 = &v34[8 * v36];
      std::string v38 = (uint64_t *)a1[1];
      uint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        uint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        uint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)uint64_t v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100278C20( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void *sub_100278C6C@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_1000065CC(a2, off_1007B9D10[a1]);
}

void *sub_100278C80@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_1000065CC(a2, off_1007B9D68[a1]);
}

void *sub_100278C94@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_1000065CC(a2, off_1007B9DB0[a1]);
}

void *sub_100278CA8@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_1000065CC(a2, off_1007B9DD0[a1]);
}

void sub_100278EE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027930C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1002793A4(uint64_t a1)
{
  id v2 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) remote]);
  [v2 didUpdateNearbyObjects:*(void *)(a1 + 40)];
}

void sub_1002793E4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

uint64_t sub_1002795A0(uint64_t result)
{
  *(void *)(*(void *)(*(void *)(result + 40) + 8LL) + 24LL) = *(void *)(*(void *)(result + 32) + 120LL);
  return result;
}

void sub_1002798D4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, id location)
{
  objc_destroyWeak(v27);
  objc_destroyWeak(v26);
  objc_destroyWeak(&location);

  _Unwind_Resume(a1);
}

void sub_10027993C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained _serverConnectionInterrupted];
}

void sub_100279970( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_100279984(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained _serverConnectionInvalidated];
}

void sub_1002799B8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_1002799CC(uint64_t a1, void *a2, void *a3)
{
  id v7 = a2;
  id v5 = a3;
  BOOL v6 = *(void **)(a1 + 32);
  if (v5) {
    [v6 _handleActivationError:v5];
  }
  else {
    [v6 _handleActivationSuccess:v7];
  }
}

void sub_100279A28( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100279A80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100279BBC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20)
{
  _Block_object_dispose(&a15, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100279BFC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_100279C0C(uint64_t a1)
{
}

void sub_100279C14(uint64_t a1, void *a2)
{
  id v4 = a2;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_100279E98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100279ED0(uint64_t a1, void *a2)
{
  id v14 = a2;
  [v14 distance];
  float v4 = v3;
  [v14 horizontalAngle];
  ++*(_DWORD *)(*(void *)(a1 + 32) + 204LL);
  float v6 = NINearbyObjectDistanceNotAvailable;
  if (v4 != NINearbyObjectDistanceNotAvailable)
  {
    ++*(_DWORD *)(*(void *)(a1 + 32) + 208LL);
    *(float *)(*(void *)(a1 + 32) + 220LL) = v4;
    id v7 = *(float **)(a1 + 32);
    if (v7[54] == v6)
    {
      v7[54] = v4;
      id v7 = *(float **)(a1 + 32);
    }

    float v8 = v7[56];
    if (v8 == v6 || v8 > v4)
    {
      v7[56] = v4;
      id v7 = *(float **)(a1 + 32);
    }

    float v10 = v7[57];
    if (v10 == v6 || v10 < v4) {
      v7[57] = v4;
    }
  }

  float v12 = NINearbyObjectAngleNotAvailable;
  if (v5 != NINearbyObjectAngleNotAvailable)
  {
    ++*(_DWORD *)(*(void *)(a1 + 32) + 212LL);
    *(float *)(*(void *)(a1 + 32) + 236LL) = v5;
    uint64_t v13 = *(void *)(a1 + 32);
  }
}

void sub_100279FD8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

id sub_10027A090(uint64_t a1)
{
  float v4 = @"duration";
  id v1 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithDouble:]( &OBJC_CLASS___NSNumber,  "numberWithDouble:",  *(double *)(*(void *)(a1 + 32) + 104LL)));
  float v5 = v1;
  id v2 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v5,  &v4,  1LL));

  return v2;
}

void sub_10027A134(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_10027A1E8(uint64_t a1)
{
  float v4 = @"duration";
  id v1 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithDouble:]( &OBJC_CLASS___NSNumber,  "numberWithDouble:",  *(double *)(*(void *)(a1 + 32) + 104LL)));
  float v5 = v1;
  id v2 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v5,  &v4,  1LL));

  return v2;
}

void sub_10027A28C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027A3E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_10027A438(uint64_t a1)
{
  v8[0] = @"domain";
  id v2 = (id *)(a1 + 32);
  float v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) domain]);
  v9[0] = v3;
  v8[1] = @"code";
  float v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [*v2 code]));
  v8[2] = @"string";
  uint64_t v5 = *(void *)(a1 + 40);
  v9[1] = v4;
  v9[2] = v5;
  float v6 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v9,  v8,  3LL));

  return v6;
}

void sub_10027A524(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_10027A5C4(uint64_t a1)
{
  if (+[NIPlatformInfo isInternalBuild](&OBJC_CLASS___NIPlatformInfo, "isInternalBuild"))
  {
    id v2 = *(os_log_s **)(*(void *)(a1 + 32) + 88LL);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v3 = *(void *)(a1 + 40);
      int v5 = 134283521;
      uint64_t v6 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Set delegate: %{private}p",  (uint8_t *)&v5,  0xCu);
    }
  }

  return objc_storeWeak((id *)(*(void *)(a1 + 32) + 248LL), *(id *)(a1 + 40));
}

void sub_10027A758(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027A768(uint64_t a1)
{
  if (+[NIPlatformInfo isInternalBuild](&OBJC_CLASS___NIPlatformInfo, "isInternalBuild"))
  {
    id v2 = *(os_log_s **)(*(void *)(a1 + 32) + 88LL);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v3 = *(void *)(a1 + 40);
      int v4 = 134283521;
      uint64_t v5 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Set delegate queue: %{private}p",  (uint8_t *)&v4,  0xCu);
    }
  }

  objc_storeStrong((id *)(*(void *)(a1 + 32) + 256LL), *(id *)(a1 + 40));
}

void sub_10027A8A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027A9E8(uint64_t a1)
{
}

void sub_10027AB84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027ABA4(uint64_t a1)
{
}

void sub_10027ABB8(uint64_t a1)
{
  id v1 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _remoteObject]);
  [v1 generateDiscoveryToken];
}

void sub_10027ABF0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10027AC04(uint64_t a1)
{
}

void sub_10027AC9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027AD98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027ADA8(uint64_t a1)
{
  unsigned int v2 = [*(id *)(a1 + 32) internalState];
  if (+[NIPlatformInfo isInternalBuild](&OBJC_CLASS___NIPlatformInfo, "isInternalBuild"))
  {
    uint64_t v3 = *(void **)(*(void *)(a1 + 32) + 88LL);
    if (os_log_type_enabled((os_log_t)v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 16LL);
      if (v2 - 1 > 7) {
        uint64_t v5 = @"Activating";
      }
      else {
        uint64_t v5 = off_1007BA310[v2 - 1];
      }
      uint64_t v6 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 138412802;
      uint64_t v21 = v4;
      __int16 v22 = 2112;
      uint64_t v23 = v5;
      __int16 v24 = 2112;
      uint64_t v25 = v6;
      id v7 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Client: runWithConfiguration [%@]. State: %@. Config: %@.",  buf,  0x20u);
    }
  }

  atomic_store(1u, (unsigned __int8 *)(*(void *)(a1 + 32) + 80LL));
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472LL;
  v18[2] = sub_10027B08C;
  v18[3] = &unk_1007B4400;
  unsigned int v19 = v2;
  AnalyticsSendEventLazy(@"com.apple.nearbyinteraction.session.run", v18);
  switch(v2)
  {
    case 0u:
    case 1u:
    case 4u:
    case 5u:
      goto LABEL_8;
    case 2u:
    case 3u:
LABEL_8:
      [*(id *)(a1 + 32) setInternalState:2];
      id v8 = [*(id *)(a1 + 40) copy];
      id v9 = *(void **)(*(void *)(a1 + 32) + 40LL);
      *(void *)(*(void *)(a1 + 32) + 40LL) = v8;

      [*(id *)(a1 + 32) _logTime];
      float v10 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _remoteObject]);
      uint64_t v11 = *(void *)(a1 + 40);
      v17[0] = _NSConcreteStackBlock;
      v17[1] = 3221225472LL;
      v17[2] = sub_10027B128;
      void v17[3] = &unk_1007B9F20;
      v17[4] = *(void *)(a1 + 32);
      [v10 runWithConfiguration:v11 reply:v17];

      break;
    case 6u:
      [*(id *)(a1 + 32) _reinterruptSessionWithCachedInterruption];
      return;
    case 7u:
    case 8u:
      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) invalidationError]);
      id v14 = *(void **)(a1 + 32);
      if (v13) {
        uint64_t v15 = objc_claimAutoreleasedReturnValue([v14 invalidationError]);
      }
      else {
        uint64_t v15 = objc_claimAutoreleasedReturnValue([v14 _getSessionFailureError]);
      }
      uint64_t v16 = (void *)v15;

      [*(id *)(a1 + 32) _notifyDidInvalidateWithError:v16];
      return;
    default:
LABEL_10:
      if (+[NIPlatformInfo isInternalBuild](&OBJC_CLASS___NIPlatformInfo, "isInternalBuild"))
      {
        float v12 = *(os_log_s **)(*(void *)(a1 + 32) + 88LL);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Not runnable", buf, 2u);
        }
      }

      break;
  }

void sub_10027B060(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_10027B08C(uint64_t a1)
{
  uint64_t v4 = @"state";
  unsigned int v1 = *(_DWORD *)(a1 + 32) - 1;
  if (v1 > 7) {
    unsigned int v2 = @"Activating";
  }
  else {
    unsigned int v2 = off_1007BA310[v1];
  }
  uint64_t v5 = v2;
  return (id)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v5,  &v4,  1LL));
}

void sub_10027B128(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(void **)(a1 + 32);
  id v5 = v3;
  if (v3) {
    [v4 _handleRunSessionError:v3];
  }
  else {
    [v4 _handleRunSessionSuccess];
  }
}

void sub_10027B174( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10027B1E0(uint64_t a1)
{
  unsigned int v2 = [*(id *)(a1 + 32) internalState];
  if (+[NIPlatformInfo isInternalBuild](&OBJC_CLASS___NIPlatformInfo, "isInternalBuild"))
  {
    id v3 = *(void **)(*(void *)(a1 + 32) + 88LL);
    if (os_log_type_enabled((os_log_t)v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 16LL);
      if (v2 - 1 > 7) {
        id v5 = @"Activating";
      }
      else {
        id v5 = off_1007BA310[v2 - 1];
      }
      *(_DWORD *)buf = 138412546;
      uint64_t v16 = v4;
      __int16 v17 = 2112;
      uint64_t v18 = v5;
      uint64_t v6 = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Client: pause [%@]. State: %@.", buf, 0x16u);
    }
  }

  if (v2 - 2 < 2)
  {
    uint64_t v11 = *(void **)(a1 + 32);
    float v10 = (id *)(a1 + 32);
    [v11 setInternalState:4];
    float v12 = (void *)objc_claimAutoreleasedReturnValue([*v10 _remoteObject]);
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 3221225472LL;
    v14[2] = sub_10027B3E4;
    v14[3] = &unk_1007B9F20;
    void v14[4] = *v10;
    [v12 pause:v14];
  }

  else if (v2 - 7 >= 2)
  {
    if (v2 == 6) {
      [*(id *)(a1 + 32) _reinterruptSessionWithCachedInterruption];
    }
  }

  else
  {
    id v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) invalidationError]);
    id v8 = *(void **)(a1 + 32);
    if (v7) {
      uint64_t v9 = objc_claimAutoreleasedReturnValue([v8 invalidationError]);
    }
    else {
      uint64_t v9 = objc_claimAutoreleasedReturnValue([v8 _getSessionFailureError]);
    }
    uint64_t v13 = (void *)v9;

    [*(id *)(a1 + 32) _notifyDidInvalidateWithError:v13];
  }

void sub_10027B3B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027B3E4(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(void **)(a1 + 32);
  id v5 = v3;
  if (v3) {
    [v4 _handlePauseSessionError:v3];
  }
  else {
    [v4 _handlePauseSessionSuccess];
  }
}

void sub_10027B430( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

id sub_10027B49C(uint64_t a1)
{
  if (+[NIPlatformInfo isInternalBuild](&OBJC_CLASS___NIPlatformInfo, "isInternalBuild"))
  {
    unsigned int v2 = (os_log_s *)*(id *)(*(void *)(a1 + 32) + 88LL);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      id v3 = *(void **)(a1 + 32);
      uint64_t v4 = v3[2];
      unsigned int v5 = [v3 internalState] - 1;
      if (v5 > 7) {
        uint64_t v6 = @"Activating";
      }
      else {
        uint64_t v6 = off_1007BA310[v5];
      }
      int v8 = 138412546;
      uint64_t v9 = v4;
      __int16 v10 = 2112;
      uint64_t v11 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Client: invalidate [%@]. State: %@.",  (uint8_t *)&v8,  0x16u);
    }
  }

  return [*(id *)(a1 + 32) _invalidateInternal];
}

void sub_10027B59C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027B67C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
}

void sub_10027B748(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027B928( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, id a22)
{
  _Block_object_dispose(&a17, 8);
  _Unwind_Resume(a1);
}

void sub_10027B960(uint64_t a1)
{
  unsigned int v2 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
  id v5 = (id)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(a1 + 32) + 128) descriptionInternal]);
  [v2 appendFormat:@", Token: %@", v5];

  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
  id v6 = (id)objc_claimAutoreleasedReturnValue([*(id *)(v3 + 40) descriptionInternal]);
  [v4 appendFormat:@", Config: %@", v6];
}

void sub_10027B9E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

void sub_10027BA7C(uint64_t a1)
{
}

void sub_10027BBE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027BD6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027BFB8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20)
{
  _Unwind_Resume(a1);
}

void sub_10027BFF0(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 248LL));
  [WeakRetained session:*(void *)(a1 + 32) didRemoveNearbyObjects:*(void *)(a1 + 40) withReason:0];
}

void sub_10027C034( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10027C048(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 248LL));
  [WeakRetained session:*(void *)(a1 + 32) didRemoveNearbyObjects:*(void *)(a1 + 40) withReason:1];
}

void sub_10027C08C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

id sub_10027C0A0(uint64_t a1)
{
  id v5 = @"reason";
  unsigned int v1 = sub_1002944C0(*(void *)(a1 + 32));
  unsigned int v2 = (void *)objc_claimAutoreleasedReturnValue(v1);
  id v6 = v2;
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v6,  &v5,  1LL));

  return v3;
}

void sub_10027C134(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027C1F8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_10027C21C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 248LL));
  [WeakRetained session:*(void *)(a1 + 32) didUpdateNearbyObjects:*(void *)(a1 + 40)];
}

void sub_10027C25C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10027C2E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027C370(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027C630(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_10027C688(uint64_t a1)
{
  v8[0] = @"reason";
  unsigned int v2 = sub_10029449C(*(void *)(a1 + 40));
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  v9[0] = v3;
  v8[1] = @"reinterrupted";
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", *(unsigned __int8 *)(a1 + 48)));
  v8[2] = @"previousReason";
  uint64_t v5 = *(void *)(a1 + 32);
  v9[1] = v4;
  v9[2] = v5;
  id v6 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v9,  v8,  3LL));

  return v6;
}

void sub_10027C764(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027CA90(_Unwind_Exception *exception_object)
{
}

id sub_10027CAB4(uint64_t a1)
{
  v7[0] = @"reason";
  unsigned int v2 = sub_10029449C(*(void *)(a1 + 32));
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  v7[1] = @"duration";
  v8[0] = v3;
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithDouble:]( &OBJC_CLASS___NSNumber,  "numberWithDouble:",  *(double *)(a1 + 40) - *(double *)(a1 + 48)));
  v8[1] = v4;
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v8,  v7,  2LL));

  return v5;
}

void sub_10027CB80(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;

  _Unwind_Resume(a1);
}

void sub_10027CBA8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 248LL));
  [WeakRetained sessionSuspensionEnded:*(void *)(a1 + 32)];
}

void sub_10027CBE8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10027CBFC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 248LL));
  [WeakRetained session:*(void *)(a1 + 32) suspensionReasonEnded:*(void *)(a1 + 40) isNoLongerSuspended:*(unsigned __int8 *)(a1 + 48)];
}

void sub_10027CC40( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10027CD74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027CD90(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 248LL));
  [WeakRetained sessionDidUpdateDiscoveryToken:*(void *)(a1 + 32)];
}

void sub_10027CDD0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10027CE84( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_10027CEA4(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 248LL));
  [WeakRetained session:*(void *)(a1 + 32) didReceiveRangingAuthRecommendation:*(unsigned __int8 *)(a1 + 48) forObject:*(void *)(a1 + 40)];
}

void sub_10027CEE8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10027D018( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_10027D040(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 248LL));
  [WeakRetained session:*(void *)(a1 + 32) didDiscoverNearbyObject:*(void *)(a1 + 40)];
}

void sub_10027D080( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10027D21C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_10027D25C(void *a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1[4] + 248LL));
  [WeakRetained session:a1[4] object:a1[5] didUpdateRegion:a1[6] previousRegion:a1[7]];
}

void sub_10027D2A0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10027D330(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 248LL));
  [WeakRetained session:*(void *)(a1 + 32) didUpdateLocalMotionState:*(void *)(a1 + 40)];
}

void sub_10027D370( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10027D400(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 248LL));
  [WeakRetained session:*(void *)(a1 + 32) didUpdateHomeDeviceUWBRangingAvailability:*(unsigned __int8 *)(a1 + 40)];
}

void sub_10027D444( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10027D4E4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_10027D4FC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 248LL));
  [WeakRetained session:*(void *)(a1 + 32) relayDCKMessage:*(void *)(a1 + 40)];
}

void sub_10027D53C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10027D5AC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 248LL));
  [WeakRetained session:*(void *)(a1 + 32) didUpdateHealthStatus:*(void *)(a1 + 40)];
}

void sub_10027D5EC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10027D6B8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_10027D6DC(void *a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1[4] + 248LL));
  [WeakRetained session:a1[4] didProcessAcwgM1MsgWithResponse:a1[5] error:a1[6]];
}

void sub_10027D720( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10027D7EC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_10027D810(void *a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1[4] + 248LL));
  [WeakRetained session:a1[4] didProcessAcwgM3MsgWithResponse:a1[5] error:a1[6]];
}

void sub_10027D854( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10027D920( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_10027D944(void *a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1[4] + 248LL));
  [WeakRetained session:a1[4] didProcessAcwgRangingSessionResumeRequestMsgWithResponse:a1[5] error:a1[6]];
}

void sub_10027D988( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10027D9FC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 248LL));
  [WeakRetained session:*(void *)(a1 + 32) requestAcwgRangingSessionSuspend:*(unsigned int *)(a1 + 48) withSuspendTriggerReason:*(void *)(a1 + 40)];
}

void sub_10027DA40( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10027DAB0(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 248LL));
  [WeakRetained session:*(void *)(a1 + 32) didStartAcwgRanging:*(void *)(a1 + 40)];
}

void sub_10027DAF0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10027DB60(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 248LL));
  [WeakRetained session:*(void *)(a1 + 32) didSuspendAcwgRanging:*(void *)(a1 + 40)];
}

void sub_10027DBA0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10027DC48( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_10027DC60(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 248LL));
  [WeakRetained session:*(void *)(a1 + 32) didPrefetchAcwgUrsk:*(unsigned int *)(a1 + 48) error:*(void *)(a1 + 40)];
}

void sub_10027DCA4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10027DE04( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_10027DE38(void *a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1[4] + 248LL));
  [WeakRetained session:a1[4] didGenerateShareableConfigurationData:a1[5] forObject:a1[6]];
}

void sub_10027DE7C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10027DFA4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_10027DFCC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 248LL));
  [WeakRetained systemConfigurator:*(void *)(a1 + 32) didUpdateState:*(void *)(a1 + 40)];
}

void sub_10027E00C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10027E140(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027E160(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 248LL));
  [WeakRetained systemConfigurator:*(void *)(a1 + 32) didUpdateResourceUsageLimitExceeded:*(unsigned __int8 *)(a1 + 48) forSessionConfigurationType:*(void *)(a1 + 40)];
}

void sub_10027E1A4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10027E42C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *a22, void *a23)
{
  _Unwind_Resume(a1);
}

void sub_10027E498(void *a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1[4] + 248LL));
  uint64_t v2 = a1[4];
  uint64_t v3 = -[NIAlgorithmConvergence initWithStatus:andReasons:]( objc_alloc(&OBJC_CLASS___NIAlgorithmConvergence),  "initWithStatus:andReasons:",  a1[7],  a1[5]);
  [WeakRetained session:v2 didUpdateAlgorithmConvergence:v3 forObject:a1[6]];
}

void sub_10027E510( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_10027E530(void *a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1[4] + 248LL));
  [WeakRetained session:a1[4] didUpdateAlgorithmState:a1[5] forObject:a1[6]];
}

void sub_10027E574( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10027E5D4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10027E778(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 248LL));
  [WeakRetained sessionWasSuspended:*(void *)(a1 + 32)];
}

void sub_10027E7B8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10027E7CC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 248LL));
  [WeakRetained session:*(void *)(a1 + 32) suspendedWithReason:*(void *)(a1 + 40)];
}

void sub_10027E80C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10027EB80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027ED00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027EE40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027EFC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027EFDC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 248LL));
  [WeakRetained sessionDidStartRunning:*(void *)(a1 + 32)];
}

void sub_10027F01C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10027F14C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027F294(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027F354( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_10027F4BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027F5F4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_10027F624(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 248LL));
  [WeakRetained session:*(void *)(a1 + 32) didInvalidateWithError:*(void *)(a1 + 40)];
}

void sub_10027F664( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10027F718(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027F958(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027F9E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027FA4C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10027FBCC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027FCDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027FD64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10027FF24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100280058(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100280068(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _remoteObject]);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  v4[2] = sub_1002800EC;
  v4[3] = &unk_1007B9F20;
  uint64_t v3 = *(void *)(a1 + 40);
  v4[4] = *(void *)(a1 + 32);
  [v2 _addObject:v3 reply:v4];
}

void sub_1002800DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002800EC(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (v3)
  {
    uint64_t v5 = *(void **)(a1 + 32);
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472LL;
    v6[2] = sub_10028019C;
    void v6[3] = &unk_1007A2248;
    v6[4] = v5;
    id v7 = v3;
    [v5 _performBlockOnDelegateQueue:v6 ifRespondsToSelector:"session:didFailWithError:"];
  }
}

void sub_100280184( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_10028019C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 248LL));
  [WeakRetained session:*(void *)(a1 + 32) didFailWithError:*(void *)(a1 + 40)];
}

void sub_1002801DC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_1002802C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002802D8(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _remoteObject]);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  v4[2] = sub_10028035C;
  v4[3] = &unk_1007B9F20;
  uint64_t v3 = *(void *)(a1 + 40);
  v4[4] = *(void *)(a1 + 32);
  [v2 _removeObject:v3 reply:v4];
}

void sub_10028034C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10028035C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (v3)
  {
    uint64_t v5 = *(void **)(a1 + 32);
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472LL;
    v6[2] = sub_10028040C;
    void v6[3] = &unk_1007A2248;
    v6[4] = v5;
    id v7 = v3;
    [v5 _performBlockOnDelegateQueue:v6 ifRespondsToSelector:"session:didFailWithError:"];
  }
}

void sub_1002803F4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_10028040C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 248LL));
  [WeakRetained session:*(void *)(a1 + 32) didFailWithError:*(void *)(a1 + 40)];
}

void sub_10028044C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_1002804C0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_100280534( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_1002805FC(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _synchronousRemoteObject]);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  v3[2] = sub_100280680;
  v3[3] = &unk_1007B9FE8;
  __int128 v4 = *(_OWORD *)(a1 + 32);
  [v2 isPreciseRangingAllowed:v3];
}

void sub_100280670(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100280680(uint64_t a1, char a2, void *a3)
{
  id v5 = a3;
  id v6 = v5;
  if (v5) {
    [*(id *)(a1 + 32) _invalidateSessionAndNotifyError:v5];
  }
  else {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = a2;
  }
}

void sub_1002806D8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10028077C(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _synchronousRemoteObject]);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  v3[2] = sub_100280800;
  v3[3] = &unk_1007B9FE8;
  __int128 v4 = *(_OWORD *)(a1 + 32);
  [v2 isExtendedDistanceMeasurementAllowed:v3];
}

void sub_1002807F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100280800(uint64_t a1, char a2, void *a3)
{
  id v5 = a3;
  id v6 = v5;
  if (v5) {
    [*(id *)(a1 + 32) _invalidateSessionAndNotifyError:v5];
  }
  else {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = a2;
  }
}

void sub_100280858( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_1002808C8(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _remoteObject]);
  uint64_t v3 = *(void *)(a1 + 48);
  uint64_t v4 = *(void *)(a1 + 56);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  v6[2] = sub_100280950;
  void v6[3] = &unk_1007BA038;
  uint64_t v5 = *(void *)(a1 + 40);
  v6[4] = *(void *)(a1 + 32);
  [v2 processBluetoothHostTimeSyncWithType:v5 btcClockTicks:v3 eventCounter:v4 reply:v6];
}

void sub_100280940(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100280950(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = *(void **)(a1 + 32);
  if (v6)
  {
    [v7 _invalidateSessionAndNotifyError:v6];
  }

  else
  {
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472LL;
    void v8[2] = sub_100280A38;
    void v8[3] = &unk_1007B14B8;
    void v8[4] = v7;
    id v9 = v5;
    id v10 = 0LL;
    [v7 _performBlockOnDelegateQueue:v8 ifRespondsToSelector:"session:didProcessBluetoothHostTimeSyncWithResponse:error:"];
  }
}

void sub_100280A0C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_100280A38(void *a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1[4] + 248LL));
  [WeakRetained session:a1[4] didProcessBluetoothHostTimeSyncWithResponse:a1[5] error:a1[6]];
}

void sub_100280A7C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_100280AF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100280C90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100280CD4(uint64_t a1)
{
  id v2 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _remoteObject]);
  [v2 _processCarKeyEvent:*(void *)(a1 + 40) reply:&stru_1007BA080];
}

void sub_100280D1C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_100280EC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100280F04(uint64_t a1)
{
  id v2 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _remoteObject]);
  [v2 _processCarKeyEvent:*(void *)(a1 + 40) reply:&stru_1007BA0A0];
}

void sub_100280F4C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_1002810F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100281134(uint64_t a1)
{
  id v2 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _remoteObject]);
  [v2 _processCarKeyEvent:*(void *)(a1 + 40) reply:&stru_1007BA0C0];
}

void sub_10028117C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_100281320(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100281364(uint64_t a1)
{
  id v2 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _remoteObject]);
  [v2 _processCarKeyEvent:*(void *)(a1 + 40) reply:&stru_1007BA0E0];
}

void sub_1002813AC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_100281524(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10028155C(uint64_t a1)
{
  id v2 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _remoteObject]);
  [v2 _processCarKeyEvent:*(void *)(a1 + 40) reply:&stru_1007BA100];
}

void sub_1002815A4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10028171C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100281754(uint64_t a1)
{
  id v2 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _remoteObject]);
  [v2 _processCarKeyEvent:*(void *)(a1 + 40) reply:&stru_1007BA120];
}

void sub_10028179C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_100281954(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100281978(uint64_t a1)
{
  NSErrorUserInfoKey v4 = NSLocalizedDescriptionKey;
  id v5 = @"Received a nil or 0 length DCK message.";
  id v2 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v5,  &v4,  1LL));
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"com.apple.NearbyInteraction",  -19889LL,  v2));

  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void sub_100281A50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100281A74(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _remoteObject]);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  v4[2] = sub_100281B24;
  v4[3] = &unk_1007BA170;
  uint64_t v3 = *(void *)(a1 + 40);
  v4[4] = *(void *)(a1 + 32);
  id v5 = *(id *)(a1 + 48);
  [v2 processDCKMessage:v3 reply:v4];
}

void sub_100281B0C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_100281B24(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = *(void **)(a1 + 40);
  int v8 = *(dispatch_queue_s **)(*(void *)(a1 + 32) + 256LL);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100281BE0;
  block[3] = &unk_1007BA148;
  id v13 = v6;
  id v14 = v7;
  id v12 = v5;
  id v9 = v6;
  id v10 = v5;
  dispatch_async(v8, block);
}

uint64_t sub_100281BE0(void *a1)
{
  return (*(uint64_t (**)(void, void, void))(a1[6] + 16LL))(a1[6], a1[4], a1[5]);
}

void sub_100281CB8(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _synchronousRemoteObject]);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  v3[2] = sub_100281D3C;
  v3[3] = &unk_1007B8CA0;
  void v3[4] = *(void *)(a1 + 40);
  [v2 deleteURSKs:v3];
}

void sub_100281D2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100281D3C(uint64_t a1, void *a2)
{
}

void sub_100281ED8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100281EF0(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _synchronousRemoteObject]);
  uint64_t v3 = *(unsigned int *)(a1 + 56);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_100281F78;
  v5[3] = &unk_1007B8CA0;
  uint64_t v4 = *(void *)(a1 + 40);
  v5[4] = *(void *)(a1 + 48);
  [v2 _setDebugURSK:v4 transactionIdentifier:v3 reply:v5];
}

void sub_100281F68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100281F78(uint64_t a1, void *a2)
{
}

void sub_100282018(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _synchronousRemoteObject]);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  v3[2] = sub_10028209C;
  v3[3] = &unk_1007B9FE8;
  __int128 v4 = *(_OWORD *)(a1 + 32);
  [v2 isRangingLimitExceeded:v3];
}

void sub_10028208C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10028209C(uint64_t a1, char a2, void *a3)
{
  id v5 = a3;
  id v6 = v5;
  if (v5) {
    [*(id *)(a1 + 32) _invalidateSessionAndNotifyError:v5];
  }
  else {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = a2;
  }
}

void sub_1002820F4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_100282208(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _synchronousRemoteObject]);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  v4[2] = sub_10028228C;
  v4[3] = &unk_1007B8CA0;
  uint64_t v3 = *(void *)(a1 + 48);
  v4[4] = *(void *)(a1 + 40);
  [v2 _setURSKTTL:v3 reply:v4];
}

void sub_10028227C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10028228C(uint64_t a1, void *a2)
{
}

void sub_100282300(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10028239C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100282448( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1002825A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002825B0(uint64_t a1)
{
  id v2 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _remoteObject]);
  [v2 processAcwgM1Msg:*(void *)(a1 + 40) withSessionTriggerReason:*(void *)(a1 + 48)];
}

void sub_1002825F0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_1002826DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002826EC(uint64_t a1)
{
  id v2 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _remoteObject]);
  [v2 processAcwgM3Msg:*(void *)(a1 + 40)];
}

void sub_10028272C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10028279C(uint64_t a1)
{
  id v2 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _remoteObject]);
  [v2 suspendAcwgRanging:*(unsigned int *)(a1 + 48) withSuspendTriggerReason:*(void *)(a1 + 40)];
}

void sub_1002827E0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_100282850(uint64_t a1)
{
  id v2 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _remoteObject]);
  [v2 processAcwgRangingSessionResumeRequestMsg:*(unsigned int *)(a1 + 48) withResumeTriggerReason:*(void *)(a1 + 40)];
}

void sub_100282894( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_100282904(uint64_t a1)
{
  id v2 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _remoteObject]);
  [v2 prefetchAcwgUrsk:*(unsigned int *)(a1 + 40)];
}

void sub_100282944( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_1002829B4(uint64_t a1)
{
  id v2 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _remoteObject]);
  [v2 processUpdatedLockState:*(unsigned __int16 *)(a1 + 40)];
}

void sub_1002829F4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_100282B04( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100282BA8(uint64_t a1)
{
  id v2 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _remoteObject]);
  [v2 processVisionInput:*(void *)(a1 + 40)];
}

void sub_100282BE8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_100282C60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100282D68( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_100282D8C(uint64_t a1)
{
  id v2 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _remoteObject]);
  [v2 _processBluetoothSample:*(void *)(a1 + 40)];
}

void sub_100282DCC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_100283014(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002830CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10028346C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10028350C(uint64_t a1)
{
  id v2 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _remoteObject]);
  [v2 _processFindingEvent:*(void *)(a1 + 40) reply:&stru_1007BA230];
}

void sub_100283554( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_100283880(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100283918(uint64_t a1)
{
  id v2 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _remoteObject]);
  [v2 _processFindingEvent:*(void *)(a1 + 40) reply:&stru_1007BA250];
}

void sub_100283960( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_100283B40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100283B8C(uint64_t a1)
{
  id v2 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _remoteObject]);
  [v2 _processFindingEvent:*(void *)(a1 + 40) reply:&stru_1007BA270];
}

void sub_100283BD4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_100283DB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100283E00(uint64_t a1)
{
  id v2 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _remoteObject]);
  [v2 _processFindingEvent:*(void *)(a1 + 40) reply:&stru_1007BA290];
}

void sub_100283E48( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10028409C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002840F0(uint64_t a1)
{
  id v2 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _remoteObject]);
  [v2 _processFindingEvent:*(void *)(a1 + 40) reply:&stru_1007BA2B0];
}

void sub_100284138( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_1002841A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100284208(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002842FC(uint64_t a1)
{
  id v2 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _remoteObject]);
  [v2 _provideTruthTag:*(void *)(a1 + 40)];
}

void sub_10028433C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_1002843B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100284550(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100284594(uint64_t a1)
{
  id v2 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _remoteObject]);
  [v2 _processSystemEvent:*(void *)(a1 + 40) reply:&stru_1007BA2D0];
}

void sub_1002845DC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_1002847B0(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;

  _Unwind_Resume(a1);
}

void sub_100284804(uint64_t a1)
{
  id v2 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) _remoteObject]);
  [v2 _processSystemEvent:*(void *)(a1 + 40) reply:&stru_1007BA2F0];
}

void sub_10028484C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void *sub_1002848B4@<X0>(int a1@<W1>, void *a2@<X8>)
{
  return sub_1000065CC(a2, off_1007BA428[a1]);
}

uint64_t sub_1002848C8(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v5;
  sub_10001E914((uint64_t)v9, a3);
  sub_100284FFC(a1 + 16, (uint64_t)v9);
  id v6 = v10;
  if (v10 == v9)
  {
    uint64_t v7 = 4LL;
    id v6 = v9;
  }

  else
  {
    if (!v10) {
      goto LABEL_6;
    }
    uint64_t v7 = 5LL;
  }

  (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_6:
  if (os_log_type_enabled((os_log_t)qword_1007FC350, OS_LOG_TYPE_DEBUG)) {
    sub_1003A41D0();
  }
  *(_WORD *)a1 = 0;

  return a1;
}

void sub_1002849AC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  uint64_t v16 = a13;
  if (a13 == &a10)
  {
    uint64_t v17 = 4LL;
    uint64_t v16 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v17 = 5LL;
  }

  (*(void (**)(void))(*(void *)v16 + 8 * v17))();
LABEL_6:

  _Unwind_Resume(a1);
}

void sub_100284A08(uint64_t a1, int a2, void **a3, char a4)
{
  int v8 = (os_log_s *)qword_1007FC350;
  if (os_log_type_enabled((os_log_t)qword_1007FC350, OS_LOG_TYPE_DEFAULT))
  {
    else {
      id v9 = *a3;
    }
    *(_DWORD *)buf = 136315138;
    uint64_t v13 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#regulatory,geo,mcc,processIsoCountry isoCountryCode %s",  buf,  0xCu);
  }

  if (*((char *)a3 + 23) < 0)
  {
    sub_1000063A8(__p, *a3, (unint64_t)a3[1]);
  }

  else
  {
    *(_OWORD *)__p = *(_OWORD *)a3;
    uint64_t v11 = a3[2];
  }

  sub_100284B40(a1 + 16, a2, (uint64_t)__p, a4);
  if (SHIBYTE(v11) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100284B1C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

uint64_t sub_100284B40(uint64_t a1, int a2, uint64_t a3, char a4)
{
  int v7 = a2;
  char v6 = a4;
  uint64_t v4 = *(void *)(a1 + 24);
  if (!v4) {
    sub_10001EEF0();
  }
  return (*(uint64_t (**)(uint64_t, int *, uint64_t, char *))(*(void *)v4 + 48LL))(v4, &v7, a3, &v6);
}

uint64_t sub_100284B80(uint64_t a1)
{
  *(_BYTE *)a1 = 1;
  id v2 = sub_1001A8438();
  BOOL v3 = sub_100351338((uint64_t)v2, &v14);
  if ((char)v14.__r_.__value_.__s.__size_ < 0)
  {
    size_t size = v14.__r_.__value_.__l.__size_;
    if (!v14.__r_.__value_.__l.__size_) {
      goto LABEL_19;
    }
    uint64_t v4 = off_1007F4760[0];
    if (strlen(off_1007F4760[0]) == v14.__r_.__value_.__l.__size_)
    {
      if (v14.__r_.__value_.__l.__size_ != -1LL)
      {
        int v7 = (std::string *)v14.__r_.__value_.__r.__words[0];
LABEL_11:
        if (!memcmp(v7, v4, size)) {
          goto LABEL_19;
        }
        goto LABEL_12;
      }

void sub_100284D44(_Unwind_Exception *exception_object)
{
}

id sub_100284D60()
{
  unsigned __int8 v0 = NSTemporaryDirectory();
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue(v0);
  id v2 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@/%s",  v1,  "regulatoryIsoKnown.tok"));

  BOOL v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
  id v4 = [v3 fileExistsAtPath:v2];

  size_t v5 = (os_log_s *)qword_1007FC350;
  if ((_DWORD)v4)
  {
    if (os_log_type_enabled((os_log_t)qword_1007FC350, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "#regulatory,geo,mcc,shouldUsePersistentIsoCountry token found",  buf,  2u);
    }
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1007FC350, OS_LOG_TYPE_DEBUG)) {
      sub_1003A4228();
    }
    char v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
    int v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSData data](&OBJC_CLASS___NSData, "data"));
    unsigned __int8 v8 = [v6 createFileAtPath:v2 contents:v7 attributes:0];

    if ((v8 & 1) == 0 && os_log_type_enabled((os_log_t)qword_1007FC350, OS_LOG_TYPE_ERROR)) {
      sub_1003A41FC();
    }
  }

  return v4;
}

void sub_100284EC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100284EF8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32) + 16LL;
  if (*(char *)(a1 + 63) < 0)
  {
    sub_1000063A8(__p, *(void **)(a1 + 40), *(void *)(a1 + 48));
  }

  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 40);
    uint64_t v3 = *(void *)(a1 + 56);
  }

  sub_100284B40(v1, 0, (uint64_t)__p, 0);
  if (SHIBYTE(v3) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100284F70( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100284F8C()
{
  return sub_100284D60() ^ 1;
}

BOOL sub_100284FA4(_BYTE *a1)
{
  if (*a1) {
    return a1[1] == 0;
  }
  if (os_log_type_enabled((os_log_t)qword_1007FC350, OS_LOG_TYPE_ERROR)) {
    sub_1003A4254();
  }
  return 1LL;
}

uint64_t sub_100284FFC(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 24) = 0LL;
  if (*(void *)(a2 + 24))
  {
    id v4 = operator new(0x28uLL);
    *id v4 = &off_1007BA360;
    sub_10028525C((uint64_t)(v4 + 1), a2);
    *(void *)(a1 + 24) = v4;
  }

  return a1;
}

void *sub_100285058(void *a1)
{
  *a1 = &off_1007BA360;
  id v2 = a1 + 1;
  uint64_t v3 = (void *)a1[4];
  if (v3 == v2)
  {
    uint64_t v4 = 4LL;
    uint64_t v3 = v2;
    goto LABEL_5;
  }

  if (v3)
  {
    uint64_t v4 = 5LL;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  return a1;
}

void sub_1002850B4(char *__p)
{
  *(void *)std::string __p = &off_1007BA360;
  id v2 = __p + 8;
  uint64_t v3 = (char *)*((void *)__p + 4);
  if (v3 == v2)
  {
    uint64_t v4 = 4LL;
    uint64_t v3 = v2;
    goto LABEL_5;
  }

  if (v3)
  {
    uint64_t v4 = 5LL;
LABEL_5:
    (*(void (**)(void))(*(void *)v3 + 8 * v4))();
  }

  operator delete(__p);
}

void *sub_100285110(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  id v2 = operator new(0x28uLL);
  void *v2 = &off_1007BA360;
  sub_10001E914((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100285150(_Unwind_Exception *a1)
{
}

uint64_t sub_100285164(uint64_t a1, void *a2)
{
  *a2 = &off_1007BA360;
  return sub_10001E914((uint64_t)(a2 + 1), a1 + 8);
}

void *sub_100285180(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  BOOL result = *(void **)(a1 + 32);
  if (result == v1)
  {
    uint64_t v3 = 4LL;
    BOOL result = v1;
  }

  else
  {
    if (!result) {
      return result;
    }
    uint64_t v3 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void sub_1002851B4(char *__p)
{
  id v2 = __p + 8;
  uint64_t v3 = (char *)*((void *)__p + 4);
  if (v3 == v2)
  {
    uint64_t v4 = 4LL;
    uint64_t v3 = v2;
    goto LABEL_5;
  }

  if (v3)
  {
    uint64_t v4 = 5LL;
LABEL_5:
    (*(void (**)(void))(*(void *)v3 + 8 * v4))();
  }

  operator delete(__p);
}

uint64_t sub_100285204(uint64_t a1, int *a2, uint64_t a3, char *a4)
{
  return sub_100284B40(a1 + 8, *a2, a3, *a4);
}

uint64_t sub_100285214(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100285250()
{
}

uint64_t sub_10028525C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24LL))(*v3, a1);
      return a1;
    }

    *(void *)(a1 + 24) = v4;
  }

  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }

  *uint64_t v3 = 0LL;
  return a1;
}

void sub_1002852C0()
{
  unsigned __int8 v0 = objc_autoreleasePoolPush();
  qword_1007FC350 = (uint64_t)os_log_create("com.apple.nearbyd", "Regulatory");
  objc_autoreleasePoolPop(v0);
}

void *sub_100285300@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_1000065CC(a2, off_1007BA598[a1]);
}

void *sub_100285314@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_1000065CC(a2, off_1007BA5F0[a1]);
}

void *sub_100285328@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_1000065CC(a2, off_1007BA638[a1]);
}

void *sub_10028533C@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_1000065CC(a2, off_1007BA658[a1]);
}

void *sub_100285350(void *a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  *(void *)a1 = off_1007BA460;
  *((void *)a1 + 1) = off_1007BA4D8;
  id v6 = v5;
  *((void *)a1 + 2) = v6;
  *((void *)a1 + 3) = a3;
  *((_DWORD *)a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = 2;
  int v7 = objc_alloc(&OBJC_CLASS___CBPeripheralManager);
  uint64_t v16 = CBManagerNeedsRestrictedStateOperation;
  uint64_t v17 = &__kCFBooleanTrue;
  unsigned __int8 v8 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v17,  &v16,  1LL));
  *((void *)a1 + 5) = -[CBPeripheralManager initWithDelegate:queue:options:]( v7,  "initWithDelegate:queue:options:",  0LL,  0LL,  v8);

  *((void *)a1 + 6) = -[PRWirelessProximityAdapter initWithQueue:]( objc_alloc(&OBJC_CLASS___PRWirelessProximityAdapter),  "initWithQueue:",  *((void *)a1 + 2));
  *((void *)a1 + 7) = -[PRSettingsObserver initWithSettings:queue:]( objc_alloc(&OBJC_CLASS___PRSettingsObserver),  "initWithSettings:queue:",  *((void *)a1 + 5),  *((void *)a1 + 2));
  if (!*((void *)a1 + 2))
  {
    uint64_t v11 = "fDispatchQueue";
    int v12 = 35;
    goto LABEL_6;
  }

  if (!*((void *)a1 + 3))
  {
    uint64_t v11 = "fBtProxyObject";
    int v12 = 36;
LABEL_6:
    __assert_rtn("PRBluetoothProvider", "PRBluetoothProvider.mm", v12, v11);
  }

  objc_initWeak(&location, *((id *)a1 + 6));
  id v9 = (void *)*((void *)a1 + 6);
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472LL;
  v13[2] = sub_1002855A4;
  v13[3] = &unk_1007BA508;
  v14[1] = a1;
  objc_copyWeak(v14, &location);
  [v9 setWiproxStateHandler:v13];
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);

  return a1;
}

void sub_100285530( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  _Unwind_Resume(a1);
}

void sub_1002855A4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 40);
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  sub_100285600(v3, WeakRetained, a2);
}

void sub_1002855EC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_100285600(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  sub_1000065CC(&v10, "");
  id v6 = "WPStateResetting";
  switch(a3)
  {
    case 0LL:
      std::string::append(&v10, "WPStateUnknown");
      unsigned int v7 = 2;
      goto LABEL_5;
    case 1LL:
      goto LABEL_4;
    case 2LL:
      id v6 = "WPStateOff";
LABEL_4:
      std::string::append(&v10, v6);
      unsigned int v7 = 1;
LABEL_5:
      atomic_store(v7, (unsigned int *)(a1 + 32));
      break;
    case 3LL:
      std::string::append(&v10, "WPStateOn");
      atomic_store(0, (unsigned int *)(a1 + 32));
      [v5 enableSPMIMessagingWithHandler:&stru_1007BA528];
      break;
    default:
      break;
  }

  unsigned __int8 v8 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    id v9 = &v10;
    if ((v10.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      id v9 = (std::string *)v10.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)buf = 136315138;
    int v12 = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "WiProx changed state: %s", buf, 0xCu);
  }
}

void sub_100285774( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_1002857A8(uint64_t a1)
{
  *(void *)a1 = off_1007BA460;
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = off_1007BA4D8;
  [*(id *)(a1 + 48) setWiproxStateHandler:0];

  return a1;
}

uint64_t sub_10028580C(uint64_t a1)
{
  return sub_1002857A8(a1 - 8);
}

void sub_100285814(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1002857A8(a1);
  operator delete(v1);
}

void sub_100285828(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1002857A8(a1 - 8);
  operator delete(v1);
}

uint64_t sub_100285840(uint64_t a1)
{
  if ([*(id *)(a1 + 40) state] == (id)5 || objc_msgSend(*(id *)(a1 + 40), "state") == (id)10)
  {
    uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) advertisingAddress]);
    id v4 = [v3 copy];

    id v5 = [v4 length];
    id v6 = (os_log_s *)qword_1008000A0;
    if (v5 == (id)6)
    {
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t v25 = 138477827;
        *(void *)&v25[4] = v4;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "PRBluetoothProvider: BT Adv Address = %{private}@",  v25,  0xCu);
      }

      unsigned int v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) nonConnectableAdvertisingAddress]);
      unsigned __int8 v8 = (os_log_s *)[v7 copy];

      id v9 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t v25 = 138477827;
        *(void *)&v25[4] = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "PRBluetoothProvider: NonConnectable BT Adv Address = %{private}@",  v25,  0xCu);
      }

      [v4 getBytes:v25 length:6];
      std::string v10 = &v25[5];
      uint64_t v11 = &v25[1];
      do
      {
        char v12 = *(v11 - 1);
        *(v11 - 1) = *v10;
        *v10-- = v12;
      }

      while (v11++ < v10);
      unsigned int v14 = v25[0];
      unint64_t v1 = *(unsigned int *)&v25[1] | ((unint64_t)v25[5] << 32);
      uint64_t v15 = 1LL;
    }

    else
    {
      unsigned __int8 v8 = (os_log_s *)(id)qword_1008000A0;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        sub_1003A4280(v25, (uint64_t)[v4 length], v8);
      }
      uint64_t v15 = 0LL;
      unsigned int v14 = 0;
    }
  }

  else
  {
    uint64_t v16 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
      sub_1003A42D4(v16, v17, v18, v19, v20, v21, v22, v23);
    }
    uint64_t v15 = 0LL;
    unsigned int v14 = 0;
  }

  return ((v1 & 0xFFFFFFFFFFLL) << 8) | (v15 << 48) | v14;
}

void sub_100285A74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100285AC8(uint64_t a1)
{
  return sub_100285840(a1 - 8);
}

void sub_100285AD0(id a1, NSError *a2)
{
  id v2 = a2;
  if (!v2) {
    goto LABEL_5;
  }
  uint64_t v3 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
    sub_1003A4304((uint64_t)v2, v3, v4, v5, v6, v7, v8, v9);
  }
  if (sub_1001CDB48())
  {
    std::string v10 = (const char *)objc_msgSend( objc_claimAutoreleasedReturnValue(-[NSError description](v2, "description")), "UTF8String");
    abort_report_np("Failed to enable SPMI messages via WiProx with error: %s", v10);
    __break(1u);
  }

  else
  {
LABEL_5:
  }

void sub_100285B68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100285B84()
{
  unsigned __int8 v0 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "PRBluetoothProvider: Probe", v2, 2u);
  }

  return 1LL;
}

uint64_t sub_100285BEC(uint64_t a1)
{
  return 1LL;
}

uint64_t sub_100285C10(uint64_t a1)
{
  return 1LL;
}

uint64_t sub_100285C34()
{
  return 1LL;
}

uint64_t sub_100285C3C()
{
  return 1LL;
}

uint64_t sub_100285C44(uint64_t a1, _DWORD *a2)
{
  if (*a2)
  {
    if (*a2 == 1)
    {
      id v2 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
        sub_1003A436C(v2, v3, v4, v5, v6, v7, v8, v9);
      }
    }
  }

  else
  {
    std::string v10 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
      sub_1003A439C(v10, v11, v12, v13, v14, v15, v16, v17);
    }
  }

  return 0LL;
}

void sub_100285FF0(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (+[NIPlatformInfo isInternalBuild](&OBJC_CLASS___NIPlatformInfo, "isInternalBuild"))
  {
    uint64_t v4 = *(os_log_s **)(*(void *)(a1 + 32) + 32LL);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      sub_1003A43CC((uint64_t)v3, v4, v5, v6, v7, v8, v9, v10);
    }
  }
}

void sub_1002860AC(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (+[NIPlatformInfo isInternalBuild](&OBJC_CLASS___NIPlatformInfo, "isInternalBuild"))
  {
    uint64_t v4 = *(os_log_s **)(*(void *)(a1 + 32) + 32LL);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      sub_1003A4434((uint64_t)v3, v4, v5, v6, v7, v8, v9, v10);
    }
  }
}

void *sub_100286544@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_1000065CC(a2, off_1007BAF38[a1]);
}

void *sub_100286558@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_1000065CC(a2, off_1007BAF90[a1]);
}

void *sub_10028656C@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_1000065CC(a2, off_1007BAFD8[a1]);
}

void *sub_100286580@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_1000065CC(a2, off_1007BAFF8[a1]);
}

uint64_t sub_100286594(uint64_t a1)
{
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = off_1007BA768;
  uint64_t v2 = a1 + 8;
  *(void *)(a1 + 16) = off_1007BA790;
  uint64_t v3 = a1 + 16;
  *(void *)(a1 + 24) = off_1007BA7B8;
  uint64_t v4 = a1 + 24;
  *(void *)(a1 + 40) = off_1007BA808;
  uint64_t v5 = a1 + 40;
  *(void *)a1 = off_1007BA6B0;
  *(void *)(a1 + 32) = off_1007BA7E0;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = off_1007BA830;
  dispatch_queue_attr_t v6 = dispatch_queue_attr_make_with_qos_class(0LL, QOS_CLASS_USER_INITIATED, 0);
  uint64_t v7 = (dispatch_queue_attr_s *)objc_claimAutoreleasedReturnValue(v6);
  *(void *)(a1 + 56) = dispatch_queue_create("com.apple.nearbyd.SensorQueue", v7);
  v87 = (void **)(a1 + 56);

  v85 = std::recursive_mutex::recursive_mutex((std::recursive_mutex *)(a1 + 64));
  *(void *)(a1 + 152) = 0LL;
  uint64_t v8 = operator new(0x20uLL);
  void *v8 = &off_1007BAB98;
  v8[1] = sub_100287428;
  void v8[2] = 0LL;
  void v8[3] = a1;
  *(void *)(a1 + 152) = v8;
  uint64_t v103 = v5;
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](&OBJC_CLASS___NSUserDefaults, "standardUserDefaults"));
  LOBYTE(v5) = [v9 BOOLForKey:@"ProtobufLoggingEnabled"];
  uint64_t v10 = (uint64_t *)(a1 + 160);

  if ((v5 & 1) == 0)
  {
    uint64_t v13 = v4;
    uint64_t v14 = v3;
    uint64_t *v10 = 0LL;
    *(void *)(a1 + 16_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
    goto LABEL_57;
  }

  unsigned __int8 v11 = atomic_load((unsigned __int8 *)&qword_1007FDDB0);
  if ((v11 & 1) == 0 && __cxa_guard_acquire(&qword_1007FDDB0))
  {
    sub_100005150();
    sub_100354E4C((uint64_t)&unk_1007FDD98);
    __cxa_atexit((void (*)(void *))&std::string::~string, &unk_1007FDD98, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_1007FDDB0);
  }

  unsigned __int8 v12 = atomic_load((unsigned __int8 *)&qword_1007FDDD0);
  if ((v12 & 1) == 0 && __cxa_guard_acquire(&qword_1007FDDD0))
  {
    sub_1000065CC(&xmmword_1007FDDB8, "nearbyd-new-");
    __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_1007FDDB8, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_1007FDDD0);
  }

  sub_1002B4CFC((char *)&xmmword_1007FDDB8, buf);
  if (SHIBYTE(v102) < 0)
  {
    sub_1000063A8(&__dst, *(void **)buf, *(unint64_t *)&buf[8]);
  }

  else
  {
    __int128 __dst = *(_OWORD *)buf;
    uint64_t v105 = v102;
  }

  sub_10028D1C0((uint64_t)v100, (const void **)&__dst, 1LL);
  if (SHIBYTE(v105) < 0) {
    operator delete((void *)__dst);
  }
  sub_10028D0F8((const void **)&unk_1007FDD98, (const void **)buf, (uint64_t)&__dst);
  uint64_t v15 = operator new(0x50uLL);
  sub_10028D35C((uint64_t)v15, (__int128 *)&unk_1007FDD98, &xmmword_1007FDDB8, v100);
  uint64_t v99 = (uint64_t)v15;
  uint64_t v16 = (std::__shared_weak_count_vtbl *)operator new(8uLL);
  v16->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))&off_1007B4398;
  v98 = v16;
  uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](&OBJC_CLASS___NSUserDefaults, "standardUserDefaults"));
  uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v17 objectForKey:@"enableRemoteProtobuf"]);
  uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v17 objectForKey:@"dontTeeProtobuf"]);
  if (v18 && (uint64_t v21 = objc_opt_class(&OBJC_CLASS___NSNumber, v19), (objc_opt_isKindOfClass(v18, v21) & 1) != 0))
  {
    __int128 v97 = 0uLL;
    if ([v18 BOOLValue])
    {
      if (v20 && (uint64_t v23 = objc_opt_class(&OBJC_CLASS___NSNumber, v22), (objc_opt_isKindOfClass(v20, v23) & 1) != 0)) {
        unsigned __int8 v24 = [v20 BOOLValue];
      }
      else {
        unsigned __int8 v24 = 0;
      }
      unsigned __int8 v95 = v24 ^ 1;
      sub_10028D518(&v103, &v95, &v96);
      __int128 v80 = v96;
      __int128 v96 = 0uLL;
      v81 = (std::__shared_weak_count *)*((void *)&v97 + 1);
      __int128 v97 = v80;
      if (v81)
      {
        p_shared_owners = (unint64_t *)&v81->__shared_owners_;
        do
          unint64_t v83 = __ldaxr(p_shared_owners);
        while (__stlxr(v83 - 1, p_shared_owners));
        if (!v83)
        {
          ((void (*)(std::__shared_weak_count *))v81->__on_zero_shared)(v81);
          std::__shared_weak_count::__release_weak(v81);
        }
      }

      __int16 v29 = (std::__shared_weak_count *)*((void *)&v96 + 1);
      if (*((void *)&v96 + 1))
      {
        v84 = (unint64_t *)(*((void *)&v96 + 1) + 8LL);
        do
          unint64_t v31 = __ldaxr(v84);
        while (__stlxr(v31 - 1, v84));
        goto LABEL_25;
      }

      goto LABEL_27;
    }
  }

  else
  {
    __int128 v97 = 0uLL;
  }

  sub_1000B5734(&v96);
  __int128 v25 = v96;
  __int128 v96 = 0uLL;
  uint64_t v26 = (std::__shared_weak_count *)*((void *)&v97 + 1);
  __int128 v97 = v25;
  if (v26)
  {
    v27 = (unint64_t *)&v26->__shared_owners_;
    do
      unint64_t v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }

  __int16 v29 = (std::__shared_weak_count *)*((void *)&v96 + 1);
  if (*((void *)&v96 + 1))
  {
    __int128 v30 = (unint64_t *)(*((void *)&v96 + 1) + 8LL);
    do
      unint64_t v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
LABEL_25:
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }

void sub_100287120( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::recursive_mutex *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, id *a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, char a28, uint64_t a29, char a30, uint64_t a31, char a32, uint64_t a33, uint64_t a34, char a35, uint64_t a36, char a37)
{
  unint64_t v39 = *(void **)(v37 + 152);
  if (v39 == (void *)(v37 + 128))
  {
    uint64_t v40 = 4LL;
    unint64_t v39 = (void *)(v37 + 128);
  }

  else
  {
    if (!v39) {
      goto LABEL_6;
    }
    uint64_t v40 = 5LL;
  }

  (*(void (**)(void))(*v39 + 8 * v40))();
LABEL_6:
  std::recursive_mutex::~recursive_mutex(a13);

  _Unwind_Resume(a1);
}

void sub_100287428(uint64_t a1, void *a2)
{
  id v2 = a2;
  if (v2)
  {
    uint64_t v3 = (os_log_s *)(id)qword_1008000A0;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v2 localizedDescription]);
      int v6 = 138412290;
      uint64_t v7 = v4;
      _os_log_error_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "PRRangingManager::defaultErrorHandler %@",  (uint8_t *)&v6,  0xCu);
    }
  }

  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, "PRRangingManager::defaultErrorHandler");
}

void sub_1002874F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

char *sub_100287530(uint64_t a1)
{
  id v1 = sub_100287584(*(void *)(a1 + 32));
  id v2 = (void *)objc_claimAutoreleasedReturnValue(v1);
  uint64_t v3 = sub_100023F58(@"PRRangingManager", v2);

  return v3;
}

void sub_100287574(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_100287584(uint64_t a1)
{
  v73 = objc_opt_new(&OBJC_CLASS___NSMutableArray);
  std::recursive_mutex::lock((std::recursive_mutex *)(a1 + 64));
  id v2 = objc_autoreleasePoolPush();
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Total ranging manager clients: %zu",  *(void *)(a1 + 224)));
  -[NSMutableArray addObject:](v73, "addObject:", v3);

  uint64_t v4 = *(void **)(a1 + 208);
  if (v4 != (void *)(a1 + 216))
  {
    do
    {
      uint64_t v5 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"    Client: H<%04x>",  CUObfuscatedPtr(v4[4]));
      int v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
      -[NSMutableArray addObject:](v73, "addObject:", v6);

      uint64_t v7 = (void *)v4[1];
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          uint64_t v7 = (void *)*v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          uint64_t v8 = (void *)v4[2];
          BOOL v9 = *v8 == (void)v4;
          uint64_t v4 = v8;
        }

        while (!v9);
      }

      uint64_t v4 = v8;
    }

    while (v8 != (void *)(a1 + 216));
  }

  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Total service requests: %zu",  *(void *)(a1 + 256)));
  -[NSMutableArray addObject:](v73, "addObject:", v10);

  for (i = *(uint64_t **)(a1 + 248); i; i = (uint64_t *)*i)
  {
    uint64_t v12 = *((unsigned __int16 *)i + 8);
    LOWORD(v74) = *((_WORD *)i + 8);
    uint64_t v13 = (std::__shared_weak_count *)i[3];
    uint64_t v14 = (std::__shared_weak_count *)i[4];
    unint64_t v75 = v13;
    v76 = v14;
    if (v14)
    {
      p_shared_owners = (unint64_t *)&v14->__shared_owners_;
      do
        unint64_t v16 = __ldxr(p_shared_owners);
      while (__stxr(v16 + 1, p_shared_owners));
    }

    uint64_t v17 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"    Ticket: %d. Client: H<%04x>",  v12,  CUObfuscatedPtr(v13));
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
    -[NSMutableArray addObject:](v73, "addObject:", v18);

    if (v14)
    {
      uint64_t v19 = (unint64_t *)&v14->__shared_owners_;
      do
        unint64_t v20 = __ldaxr(v19);
      while (__stlxr(v20 - 1, v19));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
  }

  uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Clients holding service requests: %zu",  *(void *)(a1 + 296)));
  -[NSMutableArray addObject:](v73, "addObject:", v21);

  uint64_t v72 = a1;
  for (j = *(void **)(a1 + 288); j; j = (void *)*j)
  {
    sub_10028E888(&v74, j + 2);
    unsigned int v23 = CUObfuscatedPtr(v74);
    unsigned __int8 v24 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableString stringWithFormat:]( &OBJC_CLASS___NSMutableString,  "stringWithFormat:",  @"    Client: H<%04x> with %zu tickets: [",  v23,  v77[1]));
    __int128 v25 = v76;
    if (v76 != (std::__shared_weak_count *)v77)
    {
      do
      {
        if (v25 == v76) {
          uint64_t v26 = @"%d";
        }
        else {
          uint64_t v26 = @", %d";
        }
        objc_msgSend(v24, "appendFormat:", v26, WORD1(v25[1].__vftable));
        shared_owners = (std::__shared_weak_count *)v25->__shared_owners_;
        if (shared_owners)
        {
          do
          {
            shared_weak_owners = (std::__shared_weak_count **)shared_owners;
            shared_owners = (std::__shared_weak_count *)shared_owners->__vftable;
          }

          while (shared_owners);
        }

        else
        {
          do
          {
            shared_weak_owners = (std::__shared_weak_count **)v25->__shared_weak_owners_;
            BOOL v9 = *shared_weak_owners == v25;
            __int128 v25 = (std::__shared_weak_count *)shared_weak_owners;
          }

          while (!v9);
        }

        __int128 v25 = (std::__shared_weak_count *)shared_weak_owners;
      }

      while (shared_weak_owners != (std::__shared_weak_count **)v77);
    }

    [v24 appendString:@"]"];
    -[NSMutableArray addObject:](v73, "addObject:", v24);

    sub_100034A98((uint64_t)&v76, v77[0]);
    __int16 v29 = v75;
    if (v75)
    {
      __int128 v30 = (unint64_t *)&v75->__shared_owners_;
      do
        unint64_t v31 = __ldaxr(v30);
      while (__stlxr(v31 - 1, v30));
      if (!v31)
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
    }
  }

  objc_autoreleasePoolPop(v2);
  std::recursive_mutex::unlock((std::recursive_mutex *)(a1 + 64));
  __int128 v32 = objc_opt_new(&OBJC_CLASS___NSMutableArray);
  sub_100174758(a1 + 3264, &v74);
  if (v96[119])
  {
    unint64_t v33 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"AOP timestamp: %llu us",  v74));
    -[NSMutableArray addObject:](v32, "addObject:", v33);

    __int128 v34 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"DRAM assertion: %d",  v78));
    -[NSMutableArray addObject:](v32, "addObject:", v34);

    uint64_t v35 = v75;
    char v36 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Total AOP jobs: %d",  v75));
    -[NSMutableArray addObject:](v32, "addObject:", v36);

    if ((_DWORD)v35)
    {
      uint64_t v37 = (unsigned __int8 *)&v75 + 4;
      do
      {
        switch(*(v37 - 1))
        {
          case 0u:
            std::string v38 = "GRBroadcastingBeacon";
            break;
          case 1u:
            std::string v38 = "GRSingleResponseSurvey";
            break;
          case 2u:
            std::string v38 = "GRTranspondingBeacon";
            break;
          case 3u:
            std::string v38 = "GRDoubleResponseSurvey";
            break;
          case 4u:
            std::string v38 = "GRSymmetricalMultiPeer";
            break;
          case 5u:
            std::string v38 = "GRNoDataSymmetricalSinglePeer";
            break;
          default:
            std::string v38 = "Alisha_CCC";
            switch(*(v37 - 1))
            {
              case 'd':
                std::string v38 = "P2P";
                break;
              case 'e':
                std::string v38 = "PTS";
                break;
              case 'g':
                std::string v38 = "FiRa";
                break;
              case 'h':
                std::string v38 = "TestNMI";
                break;
              case 'i':
                std::string v38 = "NMI";
                break;
              case 'j':
                std::string v38 = "Alisha_ACWG";
                break;
              default:
                goto LABEL_53;
            }

            break;
        }

void sub_100287F5C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, std::recursive_mutex *a21, uint64_t a22, void *a23, char a24)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1002880C4(uint64_t a1)
{
  *(void *)a1 = off_1007BA6B0;
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = off_1007BA768;
  *(void *)(a1 + 16) = off_1007BA790;
  *(void *)(a1 + 24) = off_1007BA7B8;
  *(void *)(a1 + 32) = off_1007BA7E0;
  *(void *)(a1 + 40) = off_1007BA808;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = off_1007BA830;
  id v2 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "~PRRangingManager", v6, 2u);
  }

  sub_10025E03C((id *)(a1 + 6480));
  sub_100012390(a1 + 6464);
  sub_100173F18(a1 + 3264);
  sub_100012390(a1 + 3248);
  sub_100295910(a1 + 1064);
  sub_100285808(a1 + 1000);
  sub_100252B48((id *)(a1 + 904));

  sub_10014789C(a1 + 768);
  sub_10014B1FC(a1 + 680);
  *(void *)(a1 + 592) = off_1007AE980;
  std::mutex::~mutex((std::mutex *)(a1 + 616));
  sub_10012AF40(a1 + 504);
  sub_1001479D8(a1 + 408);
  sub_1001484E0(a1 + 312);
  sub_10028DB20(a1 + 272);
  sub_1001BC2B4(a1 + 232);
  sub_10028DAD8(a1 + 208, *(void **)(a1 + 216));

  sub_100012390(a1 + 176);
  sub_100012390(a1 + 160);
  uint64_t v3 = *(void **)(a1 + 152);
  if (v3 == (void *)(a1 + 128))
  {
    uint64_t v4 = 4LL;
    uint64_t v3 = (void *)(a1 + 128);
    goto LABEL_7;
  }

  if (v3)
  {
    uint64_t v4 = 5LL;
LABEL_7:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  std::recursive_mutex::~recursive_mutex((std::recursive_mutex *)(a1 + 64));

  return a1;
}

uint64_t sub_10028826C(uint64_t a1)
{
  return sub_1002880C4(a1 - 8);
}

uint64_t sub_100288274(uint64_t a1)
{
  return sub_1002880C4(a1 - 16);
}

uint64_t sub_10028827C(uint64_t a1)
{
  return sub_1002880C4(a1 - 24);
}

uint64_t sub_100288284(uint64_t a1)
{
  return sub_1002880C4(a1 - 32);
}

uint64_t sub_10028828C(uint64_t a1)
{
  return sub_1002880C4(a1 - 40);
}

uint64_t sub_100288294(uint64_t a1)
{
  return sub_1002880C4(a1 - 48);
}

void sub_10028829C(uint64_t a1)
{
  id v1 = (void *)sub_1002880C4(a1);
  operator delete(v1);
}

void sub_1002882B0(uint64_t a1)
{
  id v1 = (void *)sub_1002880C4(a1 - 8);
  operator delete(v1);
}

void sub_1002882C8(uint64_t a1)
{
  id v1 = (void *)sub_1002880C4(a1 - 16);
  operator delete(v1);
}

void sub_1002882E0(uint64_t a1)
{
  id v1 = (void *)sub_1002880C4(a1 - 24);
  operator delete(v1);
}

void sub_1002882F8(uint64_t a1)
{
  id v1 = (void *)sub_1002880C4(a1 - 32);
  operator delete(v1);
}

void sub_100288310(uint64_t a1)
{
  id v1 = (void *)sub_1002880C4(a1 - 40);
  operator delete(v1);
}

void sub_100288328(uint64_t a1)
{
  id v1 = (void *)sub_1002880C4(a1 - 48);
  operator delete(v1);
}

void *sub_100288340()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_1007FDD88);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_1007FDD88))
  {
    sub_100286594((uint64_t)&unk_1007FC430);
    __cxa_atexit((void (*)(void *))sub_100288268, &unk_1007FC430, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_1007FDD88);
  }

  return &unk_1007FC430;
}

void sub_1002883B8(_Unwind_Exception *a1)
{
}

void *sub_1002883D0(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(a2 + 24)) {
    sub_1003A4520();
  }
  return sub_1002883F0((void *)(a1 + 128), a2);
}

void *sub_1002883F0(void *a1, uint64_t a2)
{
  uint64_t v3 = v7;
  if (v7 == v6)
  {
    uint64_t v4 = 4LL;
    uint64_t v3 = v6;
    goto LABEL_5;
  }

  if (v7)
  {
    uint64_t v4 = 5LL;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  return a1;
}

void sub_100288488(std::recursive_mutex *a1, void *a2)
{
  id v3 = a2;
  std::recursive_mutex::lock(a1 + 1);
  sig = (void *)a1[3].__m_.__sig;
  a1[3].__m_.__sig = (uint64_t)v3;

  std::recursive_mutex::unlock(a1 + 1);
}

void sub_1002884D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_1002884E0(uint64_t a1)
{
  id v2 = (std::recursive_mutex *)(a1 + 64);
  std::recursive_mutex::lock((std::recursive_mutex *)(a1 + 64));
  id v3 = *(id *)(a1 + 192);
  std::recursive_mutex::unlock(v2);
  return v3;
}

id sub_100288520(uint64_t a1)
{
  return sub_1002884E0(a1 - 40);
}

void sub_100288528(uint64_t a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
}

void sub_100288530( uint64_t a1@<X0>, unsigned int a2@<W1>, unsigned int a3@<W2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
}

void sub_100288538(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

void sub_100288540(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
}

uint64_t sub_100288548(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_10017635C(a1 + 3264, a2, a3);
}

uint64_t sub_100288550(uint64_t a1, uint64_t a2)
{
  return sub_100176814(a1 + 3264, a2);
}

void sub_100288558(uint64_t a1@<X0>, int a2@<W1>, __int128 *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
}

uint64_t sub_100288560(uint64_t a1, uint64_t a2)
{
  return sub_100175DF8(a1 + 3264, a2);
}

uint64_t sub_100288568(uint64_t a1, int a2)
{
  return sub_100175E1C(a1 + 3264, a2);
}

unint64_t sub_100288570(uint64_t a1)
{
  return sub_100175E40(a1 + 3264);
}

uint64_t sub_100288578(uint64_t a1, int a2)
{
  return sub_100175CA4(a1 + 3264, a2);
}

uint64_t sub_100288580(uint64_t a1)
{
  return sub_100175668(a1 + 3264);
}

BOOL sub_100288588(uint64_t a1, char a2, __int16 a3)
{
  return sub_100175E70(a1 + 3264, a2, a3);
}

BOOL sub_100288590(uint64_t a1, int a2)
{
  return sub_100175FC8(a1 + 3264, a2);
}

uint64_t sub_100288598(uint64_t a1)
{
  int v3 = 8;
  __int16 v4 = 0;
  char v5 = 0;
  char v6 = 0;
  char v7 = 0;
  char v8 = 0;
  char v9 = 0;
  char v12 = 0;
  char v13 = 0;
  char v16 = 0;
  __int16 v17 = 0;
  char v18 = 0;
  char v19 = 0;
  __int16 v20 = 0;
  char v21 = 0;
  char v22 = 0;
  char v23 = 0;
  char v24 = 0;
  uint64_t v1 = sub_100176BE8(a1 + 3264, (uint64_t)&v3);
  if (v16 && __p)
  {
    uint64_t v15 = __p;
    operator delete(__p);
  }

  if (v12 && v10)
  {
    unsigned __int8 v11 = v10;
    operator delete(v10);
  }

  return v1;
}

void sub_100288674( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100288688(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 200);
  int v3 = (os_log_s *)qword_1008000A0;
  BOOL v4 = os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "PRRangingManager::firstUnlockNotificationAction - unlock notification previously received. Ignore action.",  buf,  2u);
    }
  }

  else
  {
    if (v4)
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "PRRangingManager::firstUnlockNotificationAction - this is the first notification received. Execute action.",  buf,  2u);
    }

    *(_BYTE *)(a1 + 200) = 1;
    sub_100295F28(a1 + 1064);
    uint64_t v5 = *(void *)(a1 + 160);
    if (v5 && !sub_10023C050(v5))
    {
      char v6 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "fPbLogger protobuf exists but it's not open.",  buf,  2u);
      }

      if ((sub_1002335A0(*(void *)(a1 + 160)) & 1) == 0
        && os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR))
      {
        sub_1003A4574();
      }

      char v7 = *(std::__shared_weak_count **)(a1 + 168);
      v14[0] = *(void *)(a1 + 160);
      v14[1] = (uint64_t)v7;
      if (v7)
      {
        p_shared_owners = (unint64_t *)&v7->__shared_owners_;
        do
          unint64_t v9 = __ldxr(p_shared_owners);
        while (__stxr(v9 + 1, p_shared_owners));
      }

      char v10 = sub_100288874(v14);
      if (v7)
      {
        unsigned __int8 v11 = (unint64_t *)&v7->__shared_owners_;
        do
          unint64_t v12 = __ldaxr(v11);
        while (__stlxr(v12 - 1, v11));
        if (!v12)
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
      }

      if ((v10 & 1) == 0 && os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
        sub_1003A4548();
      }
    }

    uint64_t v13 = *(void *)(a1 + 6464);
    if (v13) {
      (*(void (**)(uint64_t))(*(void *)v13 + 88LL))(v13);
    }
  }

void sub_100288860( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100288874(uint64_t *a1)
{
  if (*a1)
  {
    id v2 = sub_1001CD8CC();
    int v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
    id v4 = sub_1001CD8FC();
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
    if (v3) {
      sub_1000065CC(&v9, (char *)[v3 UTF8String]);
    }
    else {
      sub_1000065CC(&v9, "UNKNOWN");
    }
    if (v5) {
      sub_1000065CC(&__p, (char *)[v5 UTF8String]);
    }
    else {
      sub_1000065CC(&__p, "UNKNOWN");
    }
    uint64_t v6 = sub_100233684(*a1, &v9, &__p);
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
      sub_1003A45A0();
    }
    return 0LL;
  }

  return v6;
}

void sub_100288990( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }

  _Unwind_Resume(a1);
}

void sub_1002889DC(uint64_t a1, uint64_t *a2)
{
  uint64_t v21 = 0LL;
  char v22 = 0LL;
  int v3 = (std::__shared_weak_count *)a2[1];
  if (v3 && (uint64_t v5 = std::__shared_weak_count::lock(v3), (v22 = v5) != 0LL) && (v6 = *a2, (v21 = v6) != 0))
  {
    char v7 = v5;
    uint64_t v8 = (*(uint64_t (**)(void))(**(void **)(a1 + 6464) + 72LL))(*(void *)(a1 + 6464));
    std::string v9 = *(dispatch_queue_s **)(a1 + 56);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3321888768LL;
    block[2] = sub_100288B4C;
    block[3] = &unk_1007BA888;
    void block[4] = v6;
    char v19 = v7;
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
    uint64_t v20 = v8;
    dispatch_async(v9, block);
    unint64_t v12 = v19;
    if (v19)
    {
      uint64_t v13 = (unint64_t *)&v19->__shared_owners_;
      do
        unint64_t v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR))
  {
    sub_1003A45CC();
  }

  uint64_t v15 = v22;
  if (v22)
  {
    char v16 = (unint64_t *)&v22->__shared_owners_;
    do
      unint64_t v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }

void sub_100288B38(_Unwind_Exception *a1)
{
}

uint64_t sub_100288B4C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(**(void **)(a1 + 32) + 88LL))( *(void *)(a1 + 32),  *(unsigned int *)(a1 + 48),  *(unsigned int *)(a1 + 52));
}

uint64_t sub_100288B64(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2)
  {
    int v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

uint64_t sub_100288B88(uint64_t a1)
{
  return sub_100012390(a1 + 32);
}

uint64_t sub_100288B90(std::__shared_weak_count *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v25 = 0LL;
  uint64_t v26 = 0LL;
  unint64_t v4 = (std::__shared_weak_count *)a2[1];
  if (v4 && (v26 = std::__shared_weak_count::lock(v4)) != 0LL && (uint64_t v25 = *a2) != 0)
  {
    p_shared_weak_owners = (std::recursive_mutex *)&a1[2].__shared_weak_owners_;
    std::recursive_mutex::lock((std::recursive_mutex *)&a1[2].__shared_weak_owners_);
    (*(void (**)(void *__return_ptr, uint64_t, uint64_t))(*(void *)a1[269].__shared_owners_ + 40LL))( __src,  a1[269].__shared_owners_,  a3);
    if (LODWORD(__src[81]) != 1) {
      sub_10028E120();
    }
    if (LOBYTE(__src[80]))
    {
      *(_WORD *)uint64_t v35 = __src[1];
      *(void *)buf = &v25;
      uint64_t v8 = (uint64_t **)sub_10028E158((uint64_t)&a1[11].__shared_owners_, &v25, (uint64_t)&unk_1004242F8, (void **)buf);
      sub_10028E458(v8 + 4, (unsigned __int16 *)v35, v35);
      if (sub_100132210(&a1[9].__shared_weak_owners_, (unsigned __int16 *)v35))
      {
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
          sub_1003A468C();
        }
        for (uint64_t i = a1[10].__shared_owners_; i; uint64_t i = *(void *)i)
        {
          char v23 = (os_log_s *)qword_1008000A0;
          if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR))
          {
            int v24 = *(unsigned __int16 *)(i + 16);
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = v24;
            _os_log_error_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_ERROR,  "fRequestToClientMap contains ticket Id: %d",  buf,  8u);
          }
        }

        __assert_rtn("registerForService", "PRRangingManager.mm", 342, "false");
      }

      *(void *)buf = v35;
      std::string v9 = sub_10028E510( (uint64_t)&a1[9].__shared_weak_owners_,  (unsigned __int16 *)v35,  (uint64_t)&unk_1004242F8,  (_WORD **)buf);
      sub_100018E60(v9 + 3, &v25);
      sub_10017470C((uint64_t)&a1[136]);
      LOBYTE(a1) = v35[0];
      int v10 = v35[1];
      int v11 = 0x10000;
    }

    else
    {
      unint64_t v12 = (os_log_s *)(id)qword_1008000A0;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        sub_100288FEC(__src, buf);
        sub_1003A4624((uint64_t *)buf, v35, v12);
      }

      shared_owners = (dispatch_queue_s *)a1[2].__shared_owners_;
      block[0] = _NSConcreteStackBlock;
      block[1] = 3321888768LL;
      block[2] = sub_100289034;
      block[3] = &unk_1007BA8B8;
      void block[4] = v25;
      unint64_t v28 = v26;
      p_shared_owners = (unint64_t *)&v26->__shared_owners_;
      do
        unint64_t v15 = __ldxr(p_shared_owners);
      while (__stxr(v15 + 1, p_shared_owners));
      memcpy(v29, __src, sizeof(v29));
      sub_100137614(v30, (uint64_t)&v37);
      dispatch_async(shared_owners, block);
      if (v33 && v32 < 0) {
        operator delete(__p);
      }
      a1 = v28;
      if (v28)
      {
        char v16 = (unint64_t *)&v28->__shared_owners_;
        do
          unint64_t v17 = __ldaxr(v16);
        while (__stlxr(v17 - 1, v16));
        if (!v17)
        {
          ((void (*)(std::__shared_weak_count *))a1->__on_zero_shared)(a1);
          std::__shared_weak_count::__release_weak(a1);
        }

        int v11 = 0;
        LOBYTE(a1) = 0;
      }

      else
      {
        int v11 = 0;
      }

      int v10 = 0;
    }

    if (v40 && v39 < 0) {
      operator delete(v38);
    }
    std::recursive_mutex::unlock(p_shared_weak_owners);
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
      sub_1003A45F8();
    }
    int v11 = 0;
    LOBYTE(a1) = 0;
    int v10 = 0;
  }

  char v18 = v26;
  if (v26)
  {
    char v19 = (unint64_t *)&v26->__shared_owners_;
    do
      unint64_t v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }

  return v11 & 0x10000 | a1 | (v10 << 8);
}

void sub_100288F7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  if (LOBYTE(STACK[0x5F0]))
  {
    if (SLOBYTE(STACK[0x5EF]) < 0) {
      operator delete((void *)STACK[0x5D8]);
    }
  }

  std::recursive_mutex::unlock(v3);
  sub_100012390((uint64_t)va);
  _Unwind_Resume(a1);
}

void *sub_100288FEC@<X0>(void *result@<X0>, void *a2@<X8>)
{
  if (!*((_BYTE *)result + 688)) {
    return sub_1000065CC(a2, "");
  }
  *(_OWORD *)a2 = *(_OWORD *)(result + 83);
  a2[2] = result[85];
  return result;
}

void sub_100289034(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 + 48);
  if (*(_BYTE *)(a1 + 736)) {
    uint64_t v3 = *(void *)(a1 + 704);
  }
  else {
    uint64_t v3 = 1000LL;
  }
  uint64_t v4 = *(void *)(a1 + 32);
  sub_100288FEC(v2, v5);
  uint64_t v7 = v3;
  if (SHIBYTE(v6) < 0)
  {
    sub_1000063A8(&__p, v5[0], (unint64_t)v5[1]);
  }

  else
  {
    __int128 __p = *(_OWORD *)v5;
    uint64_t v9 = v6;
  }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)v4 + 104LL))(v4, &v7);
  if (SHIBYTE(v9) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v6) < 0) {
    operator delete(v5[0]);
  }
}

void sub_1002890E0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

_BYTE *sub_100289114(uint64_t a1, void *a2)
{
  uint64_t v4 = a2[5];
  *(void *)(a1 + 32) = a2[4];
  *(void *)(a1 + 40) = v4;
  if (v4)
  {
    uint64_t v5 = (unint64_t *)(v4 + 8);
    do
      unint64_t v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }

  memcpy((void *)(a1 + 48), a2 + 6, 0x290uLL);
  return sub_100137614((_BYTE *)(a1 + 704), (uint64_t)(a2 + 88));
}

void sub_10028917C(_Unwind_Exception *a1)
{
}

uint64_t sub_100289190(uint64_t a1)
{
  return sub_100012390(a1 + 32);
}

BOOL sub_1002891C8(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  unint64_t v6 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "unregisterForService with ticket id: %d",  buf,  8u);
  }

  uint64_t v39 = 0LL;
  char v40 = 0LL;
  uint64_t v7 = (std::__shared_weak_count *)a2[1];
  if (!v7 || (char v40 = std::__shared_weak_count::lock(v7)) == 0LL || (v39 = *a2) == 0)
  {
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
      sub_1003A46EC();
    }
    BOOL v18 = 0LL;
    goto LABEL_36;
  }

  uint64_t v8 = (std::recursive_mutex *)(a1 + 64);
  std::recursive_mutex::lock((std::recursive_mutex *)(a1 + 64));
  uint64_t v9 = sub_10028E770((void *)(a1 + 272), &v39);
  if (!v9)
  {
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
      sub_1003A4718();
    }
    char v19 = *(dispatch_queue_s **)(a1 + 56);
    v37[0] = _NSConcreteStackBlock;
    v37[1] = 3321888768LL;
    v37[2] = sub_100289674;
    v37[3] = &unk_1007BA8E8;
    v37[4] = v39;
    std::string v38 = v40;
    if (v40)
    {
      p_shared_owners = (unint64_t *)&v40->__shared_owners_;
      do
        unint64_t v21 = __ldxr(p_shared_owners);
      while (__stxr(v21 + 1, p_shared_owners));
    }

    dispatch_async(v19, v37);
    unint64_t v15 = v38;
    if (!v38) {
      goto LABEL_34;
    }
    char v22 = (unint64_t *)&v38->__shared_owners_;
    do
      unint64_t v17 = __ldaxr(v22);
    while (__stlxr(v17 - 1, v22));
    goto LABEL_32;
  }

  int v10 = (uint64_t **)v9[5];
  if (!v10)
  {
LABEL_12:
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
      sub_1003A4744();
    }
    unint64_t v12 = *(dispatch_queue_s **)(a1 + 56);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3321888768LL;
    block[2] = sub_100289744;
    block[3] = &unk_1007BA8E8;
    void block[4] = v39;
    char v36 = v40;
    if (v40)
    {
      uint64_t v13 = (unint64_t *)&v40->__shared_owners_;
      do
        unint64_t v14 = __ldxr(v13);
      while (__stxr(v14 + 1, v13));
    }

    dispatch_async(v12, block);
    unint64_t v15 = v36;
    if (!v36) {
      goto LABEL_34;
    }
    char v16 = (unint64_t *)&v36->__shared_owners_;
    do
      unint64_t v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
LABEL_32:
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }

void sub_100289608( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  if (LOBYTE(STACK[0x640]))
  {
    if (SLOBYTE(STACK[0x63F]) < 0) {
      operator delete((void *)STACK[0x628]);
    }
  }

  std::recursive_mutex::unlock(v16);
  sub_100012390((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100289674(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  sub_1000065CC(v2, "Client asked to cancel service, but has no registered requests.");
  uint64_t v4 = 113LL;
  if (SHIBYTE(v3) < 0)
  {
    sub_1000063A8(&__p, v2[0], (unint64_t)v2[1]);
  }

  else
  {
    __int128 __p = *(_OWORD *)v2;
    uint64_t v6 = v3;
  }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)v1 + 104LL))(v1, &v4);
  if (SHIBYTE(v6) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v3) < 0) {
    operator delete(v2[0]);
  }
}

void sub_100289710( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100289744(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  sub_1000065CC(v2, "Client asked to cancel service with invalid ticket id.");
  uint64_t v4 = 108LL;
  if (SHIBYTE(v3) < 0)
  {
    sub_1000063A8(&__p, v2[0], (unint64_t)v2[1]);
  }

  else
  {
    __int128 __p = *(_OWORD *)v2;
    uint64_t v6 = v3;
  }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)v1 + 104LL))(v1, &v4);
  if (SHIBYTE(v6) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v3) < 0) {
    operator delete(v2[0]);
  }
}

void sub_1002897E0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100289814(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 + 48);
  if (*(_BYTE *)(a1 + 736)) {
    uint64_t v3 = *(void *)(a1 + 704);
  }
  else {
    uint64_t v3 = 1000LL;
  }
  uint64_t v4 = *(void *)(a1 + 32);
  sub_100288FEC(v2, v5);
  uint64_t v7 = v3;
  if (SHIBYTE(v6) < 0)
  {
    sub_1000063A8(&__p, v5[0], (unint64_t)v5[1]);
  }

  else
  {
    __int128 __p = *(_OWORD *)v5;
    uint64_t v9 = v6;
  }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)v4 + 104LL))(v4, &v7);
  if (SHIBYTE(v9) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v6) < 0) {
    operator delete(v5[0]);
  }
}

void sub_1002898C0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

std::__shared_weak_count *sub_1002898F4(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v39 = 0LL;
  char v40 = 0LL;
  uint64_t v5 = (std::__shared_weak_count *)a2[1];
  if (v5 && (char v40 = std::__shared_weak_count::lock(v5)) != 0LL && (v39 = *a2) != 0)
  {
    uint64_t v9 = (std::recursive_mutex *)(a1 + 64);
    std::recursive_mutex::lock((std::recursive_mutex *)(a1 + 64));
    int v10 = sub_10028E770((void *)(a1 + 272), &v39);
    if (v10)
    {
      for (uint64_t i = (uint64_t **)v10[5]; i; uint64_t i = (uint64_t **)*i)
      {
        unsigned int v12 = *((unsigned __int16 *)i + 13);
        if (v12 <= a3)
        {
          if (v12 >= a3)
          {
            (*(void (**)(void *__return_ptr, void, uint64_t, uint64_t))(**(void **)(a1 + 6464) + 56LL))( __src,  *(void *)(a1 + 6464),  a3,  a4);
            if (LODWORD(__src[81])) {
              sub_10028E120();
            }
            char v16 = (std::__shared_weak_count *)(LOBYTE(__src[1]) != 0);
            if (!LOBYTE(__src[1]))
            {
              v27 = (os_log_s *)(id)qword_1008000A0;
              if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
              {
                sub_100288FEC(__src, v34);
                sub_1003A4870();
              }

              unint64_t v28 = *(dispatch_queue_s **)(a1 + 56);
              v41[0] = _NSConcreteStackBlock;
              v41[1] = 3321888768LL;
              v41[2] = sub_100289F14;
              v41[3] = &unk_1007BA8B8;
              v41[4] = v39;
              unint64_t v42 = v40;
              if (v40)
              {
                p_shared_owners = (unint64_t *)&v40->__shared_owners_;
                do
                  unint64_t v30 = __ldxr(p_shared_owners);
                while (__stxr(v30 + 1, p_shared_owners));
              }

              memcpy(v43, __src, sizeof(v43));
              sub_100137614(v44, (uint64_t)&v49);
              dispatch_async(v28, v41);
              if (v47 && v46 < 0) {
                operator delete(v45);
              }
              unint64_t v31 = v42;
              if (v42)
              {
                char v32 = (unint64_t *)&v42->__shared_owners_;
                do
                  unint64_t v33 = __ldaxr(v32);
                while (__stlxr(v33 - 1, v32));
                if (!v33)
                {
                  ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
                  std::__shared_weak_count::__release_weak(v31);
                }
              }
            }

            if (v52 && v51 < 0) {
              operator delete(__p);
            }
            goto LABEL_33;
          }

          ++i;
        }
      }

      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
        sub_1003A480C();
      }
      uint64_t v13 = *(dispatch_queue_s **)(a1 + 56);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3321888768LL;
      block[2] = sub_100289E44;
      block[3] = &unk_1007BA8E8;
      void block[4] = v39;
      char v36 = v40;
      if (v40)
      {
        unint64_t v14 = (unint64_t *)&v40->__shared_owners_;
        do
          unint64_t v15 = __ldxr(v14);
        while (__stxr(v15 + 1, v14));
      }

      dispatch_async(v13, block);
      char v16 = v36;
      if (!v36) {
        goto LABEL_33;
      }
      unint64_t v17 = (unint64_t *)&v36->__shared_owners_;
      do
        unint64_t v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
LABEL_30:
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }

      char v16 = 0LL;
      goto LABEL_33;
    }

    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
      sub_1003A47E0();
    }
    char v19 = *(dispatch_queue_s **)(a1 + 56);
    v37[0] = _NSConcreteStackBlock;
    v37[1] = 3321888768LL;
    v37[2] = sub_100289D74;
    v37[3] = &unk_1007BA8E8;
    v37[4] = v39;
    std::string v38 = v40;
    if (v40)
    {
      unint64_t v20 = (unint64_t *)&v40->__shared_owners_;
      do
        unint64_t v21 = __ldxr(v20);
      while (__stxr(v21 + 1, v20));
    }

    dispatch_async(v19, v37);
    char v16 = v38;
    if (v38)
    {
      char v22 = (unint64_t *)&v38->__shared_owners_;
      do
        unint64_t v18 = __ldaxr(v22);
      while (__stlxr(v18 - 1, v22));
      goto LABEL_30;
    }

void sub_100289D08( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  if (LOBYTE(STACK[0x640]))
  {
    if (SLOBYTE(STACK[0x63F]) < 0) {
      operator delete((void *)STACK[0x628]);
    }
  }

  std::recursive_mutex::unlock(v16);
  sub_100012390((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100289D74(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  sub_1000065CC(v2, "Client asked to trigger service, but has no registered requests.");
  uint64_t v4 = 113LL;
  if (SHIBYTE(v3) < 0)
  {
    sub_1000063A8(&__p, v2[0], (unint64_t)v2[1]);
  }

  else
  {
    __int128 __p = *(_OWORD *)v2;
    uint64_t v6 = v3;
  }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)v1 + 104LL))(v1, &v4);
  if (SHIBYTE(v6) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v3) < 0) {
    operator delete(v2[0]);
  }
}

void sub_100289E10( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100289E44(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  sub_1000065CC(v2, "Client asked to trigger service with invalid ticket id.");
  uint64_t v4 = 108LL;
  if (SHIBYTE(v3) < 0)
  {
    sub_1000063A8(&__p, v2[0], (unint64_t)v2[1]);
  }

  else
  {
    __int128 __p = *(_OWORD *)v2;
    uint64_t v6 = v3;
  }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)v1 + 104LL))(v1, &v4);
  if (SHIBYTE(v6) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v3) < 0) {
    operator delete(v2[0]);
  }
}

void sub_100289EE0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100289F14(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 + 48);
  if (*(_BYTE *)(a1 + 736)) {
    uint64_t v3 = *(void *)(a1 + 704);
  }
  else {
    uint64_t v3 = 1000LL;
  }
  uint64_t v4 = *(void *)(a1 + 32);
  sub_100288FEC(v2, v5);
  uint64_t v7 = v3;
  if (SHIBYTE(v6) < 0)
  {
    sub_1000063A8(&__p, v5[0], (unint64_t)v5[1]);
  }

  else
  {
    __int128 __p = *(_OWORD *)v5;
    uint64_t v9 = v6;
  }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)v4 + 104LL))(v4, &v7);
  if (SHIBYTE(v9) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v6) < 0) {
    operator delete(v5[0]);
  }
}

void sub_100289FC0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

std::__shared_weak_count *sub_100289FF4(uint64_t a1, uint64_t *a2, unsigned __int16 *a3)
{
  uint64_t v31 = 0LL;
  char v32 = 0LL;
  uint64_t v4 = (std::__shared_weak_count *)a2[1];
  if (v4 && (char v32 = std::__shared_weak_count::lock(v4)) != 0LL && (v31 = *a2) != 0)
  {
    uint64_t v7 = (std::recursive_mutex *)(a1 + 64);
    std::recursive_mutex::lock((std::recursive_mutex *)(a1 + 64));
    uint64_t v8 = sub_10028E770((void *)(a1 + 272), &v31);
    if (v8)
    {
      uint64_t v9 = (uint64_t **)v8[5];
      if (v9)
      {
        unsigned int v10 = *a3;
        do
        {
          unsigned int v11 = *((unsigned __int16 *)v9 + 13);
          if (v10 >= v11)
          {
            if (v11 >= v10)
            {
              char v26 = *((_BYTE *)a3 + 2);
              int v33 = 7;
              __int16 v34 = 0;
              char v35 = 0;
              char v36 = 0;
              char v37 = 0;
              char v38 = 0;
              char v39 = 0;
              char v42 = 0;
              char v43 = 0;
              char v46 = 0;
              __int16 v47 = 0;
              __int16 v48 = v10;
              char v49 = v26;
              char v50 = 1;
              __int16 v51 = 0;
              char v52 = 0;
              char v53 = 0;
              char v54 = 0;
              char v55 = 0;
              unint64_t v15 = (std::__shared_weak_count *)sub_100176BE8(a1 + 3264, (uint64_t)&v33);
              if (v46 && __p)
              {
                uint64_t v45 = __p;
                operator delete(__p);
              }

              if (v42 && v40)
              {
                uint64_t v41 = v40;
                operator delete(v40);
              }

              goto LABEL_34;
            }

            ++v9;
          }

          uint64_t v9 = (uint64_t **)*v9;
        }

        while (v9);
      }

      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
        sub_1003A490C();
      }
      unsigned int v12 = *(dispatch_queue_s **)(a1 + 56);
      v27[0] = _NSConcreteStackBlock;
      v27[1] = 3321888768LL;
      v27[2] = sub_10028A438;
      v27[3] = &unk_1007BA8E8;
      v27[4] = v31;
      unint64_t v28 = v32;
      if (v32)
      {
        p_shared_owners = (unint64_t *)&v32->__shared_owners_;
        do
          unint64_t v14 = __ldxr(p_shared_owners);
        while (__stxr(v14 + 1, p_shared_owners));
      }

      dispatch_async(v12, v27);
      unint64_t v15 = v28;
      if (!v28) {
        goto LABEL_34;
      }
      char v16 = (unint64_t *)&v28->__shared_owners_;
      do
        unint64_t v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
LABEL_31:
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }

      unint64_t v15 = 0LL;
      goto LABEL_34;
    }

    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
      sub_1003A48E0();
    }
    unint64_t v18 = *(dispatch_queue_s **)(a1 + 56);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3321888768LL;
    block[2] = sub_10028A368;
    block[3] = &unk_1007BA8E8;
    void block[4] = v31;
    unint64_t v30 = v32;
    if (v32)
    {
      char v19 = (unint64_t *)&v32->__shared_owners_;
      do
        unint64_t v20 = __ldxr(v19);
      while (__stxr(v20 + 1, v19));
    }

    dispatch_async(v18, block);
    unint64_t v15 = v30;
    if (v30)
    {
      unint64_t v21 = (unint64_t *)&v30->__shared_owners_;
      do
        unint64_t v17 = __ldaxr(v21);
      while (__stlxr(v17 - 1, v21));
      goto LABEL_31;
    }

void sub_10028A32C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  uint64_t v15 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  sub_10014438C((uint64_t)va1);
  std::recursive_mutex::unlock(v13);
  sub_100012390((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10028A368(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  sub_1000065CC(v2, "Client asked to trigger service, but has no registered requests.");
  uint64_t v4 = 113LL;
  if (SHIBYTE(v3) < 0)
  {
    sub_1000063A8(&__p, v2[0], (unint64_t)v2[1]);
  }

  else
  {
    __int128 __p = *(_OWORD *)v2;
    uint64_t v6 = v3;
  }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)v1 + 104LL))(v1, &v4);
  if (SHIBYTE(v6) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v3) < 0) {
    operator delete(v2[0]);
  }
}

void sub_10028A404( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10028A438(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  sub_1000065CC(v2, "Client asked to trigger service with invalid ticket id.");
  uint64_t v4 = 108LL;
  if (SHIBYTE(v3) < 0)
  {
    sub_1000063A8(&__p, v2[0], (unint64_t)v2[1]);
  }

  else
  {
    __int128 __p = *(_OWORD *)v2;
    uint64_t v6 = v3;
  }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)v1 + 104LL))(v1, &v4);
  if (SHIBYTE(v6) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v3) < 0) {
    operator delete(v2[0]);
  }
}

void sub_10028A4D4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10028A508(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v33 = 0LL;
  __int16 v34 = 0LL;
  uint64_t v4 = (std::__shared_weak_count *)a2[1];
  if (v4 && (__int16 v34 = std::__shared_weak_count::lock(v4)) != 0LL && (v33 = *a2) != 0)
  {
    uint64_t v7 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "stopUserTriggeredRanging! Ticket: %d",  buf,  8u);
    }

    uint64_t v8 = (std::recursive_mutex *)(a1 + 64);
    std::recursive_mutex::lock((std::recursive_mutex *)(a1 + 64));
    uint64_t v9 = sub_10028E770((void *)(a1 + 272), &v33);
    if (v9)
    {
      unsigned int v10 = (uint64_t **)v9[5];
      if (!v10)
      {
LABEL_12:
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
          sub_1003A4998();
        }
        unsigned int v12 = *(dispatch_queue_s **)(a1 + 56);
        block[0] = _NSConcreteStackBlock;
        block[1] = 3321888768LL;
        block[2] = sub_10028A95C;
        block[3] = &unk_1007BA8E8;
        void block[4] = v33;
        char v32 = v34;
        if (v34)
        {
          p_shared_owners = (unint64_t *)&v34->__shared_owners_;
          do
            unint64_t v14 = __ldxr(p_shared_owners);
          while (__stxr(v14 + 1, p_shared_owners));
        }

        dispatch_async(v12, block);
        uint64_t v15 = (uint64_t)v32;
        if (v32)
        {
          char v16 = (unint64_t *)&v32->__shared_owners_;
          do
            unint64_t v17 = __ldaxr(v16);
          while (__stlxr(v17 - 1, v16));
          if (!v17)
          {
            (*(void (**)(uint64_t))(*(void *)v15 + 16LL))(v15);
            std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v15);
          }

          uint64_t v15 = 0LL;
        }

        goto LABEL_29;
      }

      while (1)
      {
        unsigned int v11 = *((unsigned __int16 *)v10 + 13);
        if (v11 <= a3)
        {
          if (v11 >= a3)
          {
            (*(void (**)(uint8_t *__return_ptr, void, uint64_t))(**(void **)(a1 + 6464) + 64LL))( buf,  *(void *)(a1 + 6464),  a3);
            if (*(_DWORD *)&buf[648]) {
              sub_10028E120();
            }
            uint64_t v15 = buf[8] != 0;
            if (!buf[8])
            {
              char v23 = (os_log_s *)(id)qword_1008000A0;
              if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
              {
                sub_100288FEC(buf, v30);
                sub_1003A49C4();
              }

              unint64_t v24 = *(dispatch_queue_s **)(a1 + 56);
              v35[0] = _NSConcreteStackBlock;
              v35[1] = 3321888768LL;
              uint8_t v35[2] = sub_10028AA2C;
              v35[3] = &unk_1007BA8B8;
              v35[4] = v33;
              char v36 = v34;
              if (v34)
              {
                unint64_t v25 = (unint64_t *)&v34->__shared_owners_;
                do
                  unint64_t v26 = __ldxr(v25);
                while (__stxr(v26 + 1, v25));
              }

              memcpy(v37, buf, sizeof(v37));
              sub_100137614(v38, (uint64_t)&v43);
              dispatch_async(v24, v35);
              if (v41 && v40 < 0) {
                operator delete(v39);
              }
              v27 = v36;
              if (v36)
              {
                unint64_t v28 = (unint64_t *)&v36->__shared_owners_;
                do
                  unint64_t v29 = __ldaxr(v28);
                while (__stlxr(v29 - 1, v28));
                if (!v29)
                {
                  ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
                  std::__shared_weak_count::__release_weak(v27);
                }
              }
            }

            if (v46 && v45 < 0) {
              operator delete(__p);
            }
            goto LABEL_29;
          }

          ++v10;
        }

        unsigned int v10 = (uint64_t **)*v10;
        if (!v10) {
          goto LABEL_12;
        }
      }
    }

    unint64_t v18 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "Client asked to stop service, but has no registered requests. Ignoring.",  buf,  2u);
    }

    uint64_t v15 = 1LL;
LABEL_29:
    std::recursive_mutex::unlock(v8);
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
      sub_1003A496C();
    }
    uint64_t v15 = 0LL;
  }

  char v19 = v34;
  if (v34)
  {
    unint64_t v20 = (unint64_t *)&v34->__shared_owners_;
    do
      unint64_t v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }

  return v15;
}

void sub_10028A8F0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  if (LOBYTE(STACK[0x610]))
  {
    if (SLOBYTE(STACK[0x60F]) < 0) {
      operator delete((void *)STACK[0x5F8]);
    }
  }

  std::recursive_mutex::unlock(v10);
  sub_100012390((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10028A95C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  sub_1000065CC(v2, "Client asked to stop service with invalid ticket id.");
  uint64_t v4 = 108LL;
  if (SHIBYTE(v3) < 0)
  {
    sub_1000063A8(&__p, v2[0], (unint64_t)v2[1]);
  }

  else
  {
    __int128 __p = *(_OWORD *)v2;
    uint64_t v6 = v3;
  }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)v1 + 104LL))(v1, &v4);
  if (SHIBYTE(v6) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v3) < 0) {
    operator delete(v2[0]);
  }
}

void sub_10028A9F8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10028AA2C(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 + 48);
  if (*(_BYTE *)(a1 + 736)) {
    uint64_t v3 = *(void *)(a1 + 704);
  }
  else {
    uint64_t v3 = 1000LL;
  }
  uint64_t v4 = *(void *)(a1 + 32);
  sub_100288FEC(v2, v5);
  uint64_t v7 = v3;
  if (SHIBYTE(v6) < 0)
  {
    sub_1000063A8(&__p, v5[0], (unint64_t)v5[1]);
  }

  else
  {
    __int128 __p = *(_OWORD *)v5;
    uint64_t v9 = v6;
  }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)v4 + 104LL))(v4, &v7);
  if (SHIBYTE(v9) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v6) < 0) {
    operator delete(v5[0]);
  }
}

void sub_10028AAD8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10028AB0C(uint64_t a1, uint64_t a2)
{
  return sub_100177AF0(a1 + 3264, a2);
}

uint64_t sub_10028AB14(uint64_t a1, uint64_t a2)
{
  return sub_100177AF0(a1 + 3232, a2);
}

void sub_10028AB1C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!*(void *)(a3 + 24)) {
    sub_1003A4A08();
  }
  uint64_t v6 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "PRRangingManager::pushBeaconAllowlist ++",  buf,  2u);
  }

  if (*(void *)(a2 + 8) == *(void *)a2)
  {
    v15[0] = NSLocalizedDescriptionKey;
    v15[1] = NSLocalizedFailureReasonErrorKey;
    v16[0] = @"Failed to push beacon allowlist.";
    v16[1] = @"To allowlist, must specify at least one beacon.";
    unsigned int v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v16,  v15,  2LL));
    id v11 = PRErrorWithCodeAndUserInfo(107LL, v10);
    id v8 = (id)objc_claimAutoreleasedReturnValue(v11);

    sub_10028ACE8(a3, v8);
  }

  else
  {
    id v13 = 0LL;
    BOOL v7 = sub_100177D68(a1 + 3264, (int **)a2, &v13);
    id v8 = v13;
    if (v7)
    {
      uint64_t v9 = 0LL;
    }

    else
    {
      BOOL v12 = os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR);
      uint64_t v9 = v8;
      if (v12)
      {
        sub_1003A4A30();
        uint64_t v9 = v8;
      }
    }

    sub_10028ACE8(a3, v9);
  }
}

void sub_10028ACC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10028ACE8(uint64_t a1, void *a2)
{
  id v4 = a2;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    sub_10001EEF0();
  }
  (*(void (**)(uint64_t, id *))(*(void *)v3 + 48LL))(v3, &v4);
}

void sub_10028AD3C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

void sub_10028AD50(uint64_t a1, uint64_t a2)
{
  __int128 __p = 0LL;
  uint64_t v9 = 0LL;
  uint64_t v10 = 0LL;
  id v7 = 0LL;
  BOOL v3 = sub_100177D68(a1 + 3264, (int **)&__p, &v7);
  id v4 = v7;
  if (__p)
  {
    uint64_t v9 = __p;
    operator delete(__p);
  }

  if (v3)
  {
    uint64_t v5 = 0LL;
  }

  else
  {
    BOOL v6 = os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR);
    uint64_t v5 = v4;
    if (v6)
    {
      sub_1003A4A5C();
      uint64_t v5 = v4;
    }
  }

  sub_10028ACE8(a2, v5);
}

void sub_10028AE00( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10028AE28(uint64_t a1)
{
  return sub_100253DD4(a1 + 904);
}

uint64_t sub_10028AE30(std::recursive_mutex *a1, std::string *a2)
{
  id v4 = a1 + 1;
  std::recursive_mutex::lock(a1 + 1);
  uint64_t v5 = sub_1002977BC((uint64_t)&a1[16].__m_.__opaque[32], a2);
  std::recursive_mutex::unlock(v4);
  return v5;
}

void sub_10028AE80(_Unwind_Exception *a1)
{
}

uint64_t sub_10028AE94(uint64_t a1, std::string *a2)
{
  return sub_10028AE30((std::recursive_mutex *)(a1 - 48), a2);
}

id sub_10028AE9C(std::recursive_mutex *a1, uint64_t a2)
{
  id v4 = a1 + 1;
  std::recursive_mutex::lock(a1 + 1);
  id v5 = sub_100297894((uint64_t)&a1[16].__m_.__opaque[32], a2);
  std::recursive_mutex::unlock(v4);
  return v5;
}

void sub_10028AEEC(_Unwind_Exception *a1)
{
}

id sub_10028AF00(uint64_t a1, uint64_t a2)
{
  return sub_10028AE9C((std::recursive_mutex *)(a1 - 48), a2);
}

id sub_10028AF08(std::recursive_mutex *a1)
{
  uint64_t v2 = a1 + 1;
  std::recursive_mutex::lock(a1 + 1);
  id v3 = sub_1002978F4((uint64_t)&a1[16].__m_.__opaque[32]);
  std::recursive_mutex::unlock(v2);
  return v3;
}

void sub_10028AF48(_Unwind_Exception *a1)
{
}

id sub_10028AF5C(uint64_t a1)
{
  return sub_10028AF08((std::recursive_mutex *)(a1 - 48));
}

uint64_t sub_10028AF64(std::recursive_mutex *a1)
{
  uint64_t v2 = a1 + 1;
  std::recursive_mutex::lock(a1 + 1);
  uint64_t v3 = sub_100296DDC((uint64_t)&a1[16].__m_.__opaque[32]);
  std::recursive_mutex::unlock(v2);
  return v3;
}

void sub_10028AFA4(_Unwind_Exception *a1)
{
}

uint64_t sub_10028AFB8(uint64_t a1)
{
  return sub_10028AF64((std::recursive_mutex *)(a1 - 48));
}

uint64_t sub_10028AFC0(std::recursive_mutex *a1)
{
  uint64_t v2 = a1 + 1;
  std::recursive_mutex::lock(a1 + 1);
  uint64_t v3 = sub_100296EAC((uint64_t)&a1[16].__m_.__opaque[32]);
  std::recursive_mutex::unlock(v2);
  return v3;
}

void sub_10028B000(_Unwind_Exception *a1)
{
}

uint64_t sub_10028B014(uint64_t a1)
{
  return sub_10028AFC0((std::recursive_mutex *)(a1 - 48));
}

uint64_t sub_10028B01C(uint64_t a1)
{
  return sub_100173F70(a1 + 3264);
}

uint64_t sub_10028B024(uint64_t a1)
{
  return sub_100174010(a1 + 3264);
}

uint64_t sub_10028B02C(uint64_t a1, uint64_t a2)
{
  return sub_100174018(a1 + 3264, a2);
}

void sub_10028B034(uint64_t a1, void *a2)
{
}

uint64_t sub_10028B03C(uint64_t a1, uint64_t a2, const std::string *a3)
{
  BOOL v6 = (os_log_s *)(id)qword_1008000A0;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    sub_10035F1D8(a2, __p);
    if (v11 >= 0) {
      id v7 = __p;
    }
    else {
      id v7 = (void **)__p[0];
    }
    if ((a3->__r_.__value_.__s.__size_ & 0x80u) == 0) {
      id v8 = a3;
    }
    else {
      id v8 = (const std::string *)a3->__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)buf = 136315394;
    id v13 = v7;
    __int16 v14 = 2080;
    uint64_t v15 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "[Diagnostics] Client triggered log collection. Type: %s, Reason: %s",  buf,  0x16u);
    if (v11 < 0) {
      operator delete(__p[0]);
    }
  }

  return sub_100175660(a1 + 3264, a2, a3);
}

void sub_10028B158(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10028B170(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

uint64_t sub_10028B178(uint64_t a1, BOOL *a2)
{
  return sub_10017416C(a1 + 3264, a2);
}

uint64_t sub_10028B180(uint64_t a1, int a2)
{
  return sub_10017417C(a1 + 3264, a2);
}

uint64_t sub_10028B188(uint64_t a1, _BYTE *a2)
{
  return sub_100174174(a1 + 3264, a2);
}

CFDataRef sub_10028B190(uint64_t a1)
{
  return sub_1001742D4(a1 + 3264);
}

void sub_10028B198(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (qword_1007FDD90 != -1) {
    dispatch_once(&qword_1007FDD90, &stru_1007BA918);
  }
  char v16 = 0LL;
  unint64_t v17 = 0LL;
  uint64_t v18 = 0LL;
  id v4 = [v3 length];
  id v5 = 0LL;
  if (v4)
  {
    sub_1000353EC((unint64_t *)&v16, (size_t)v4);
    id v5 = v16;
  }

  else if (v17 != v16)
  {
    unint64_t v17 = v16;
  }

  objc_msgSend(v3, "getBytes:length:", v5, objc_msgSend(v3, "length"));
  if (byte_1007F4528)
  {
    BOOL v6 = (os_log_s *)(id)qword_1008000A0;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      id v7 = [v3 length];
      id v8 = v16;
      uint64_t v9 = v17;
      sub_1001DF764((uint64_t)&v20);
      char v19 = 48;
      uint64_t v10 = sub_100138E6C(&v20, &v19);
      *(_DWORD *)((char *)v10 + *(void *)(*v10 - 24LL) + _Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)((_BYTE *)v10 + *(void *)(*v10 - 24LL) + 8) & 0xFFFFFFB5 | 8;
      char v11 = (unsigned __int8 *)v16;
      BOOL v12 = v17;
      if (v16 != v17)
      {
        do
        {
          *(std::streambuf::char_type **)((char *)&v21.__binp_ + *(void *)(v20 - 24)) = (std::streambuf::char_type *)2;
          id v13 = (void *)std::ostream::operator<<(&v20, *v11);
          sub_100046B94(v13, (uint64_t)" ", 1LL);
          ++v11;
        }

        while (v11 != v12);
      }

      std::stringbuf::str(&v15, &v21);
      std::streambuf::~streambuf(&v21);
      std::ios::~ios(v22);
      __int16 v14 = &v15;
      if ((v15.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        __int16 v14 = (std::stringbuf::string_type *)v15.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)buf = 134218754;
      *(void *)char v40 = v7;
      *(_WORD *)&v40[8] = 2112;
      *(void *)&v40[10] = v3;
      *(_WORD *)&v40[18] = 2048;
      int64_t v41 = v9 - v8;
      __int16 v42 = 2080;
      uint64_t v43 = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#marconi, sending bytes from marconi.\n Amount: %lu,\n NSData: %@.\n std::vector length: %lu,\n std::vector bytes: %s",  buf,  0x2Au);
    }
  }

  LODWORD(v20) = 5;
  WORD2(v20) = 0;
  LOBYTE(v21.__vftable) = 0;
  v22[400] = 0;
  v22[408] = 0;
  v22[520] = 0;
  *(_DWORD *)buf = 46;
  *(void *)&v40[12] = 0LL;
  int64_t v41 = 0LL;
  *(void *)&v40[4] = 0LL;
  sub_1001309C0(&v40[4], v16, (uint64_t)v17, v17 - (_BYTE *)v16);
  int v23 = *(_DWORD *)buf;
  __int128 v24 = *(_OWORD *)&v40[4];
  int64_t v25 = v41;
  char v26 = 1;
  char v27 = 0;
  char v30 = 0;
  __int16 v31 = 0;
  char v32 = 0;
  char v33 = 0;
  __int16 v34 = 0;
  char v35 = 0;
  char v36 = 0;
  char v37 = 0;
  char v38 = 0;
  sub_100176BE8(a1 + 3264, (uint64_t)&v20);
  if (v30 && v28)
  {
    unint64_t v29 = v28;
    operator delete(v28);
  }

  if (v26 && (void)v24)
  {
    *((void *)&v24 + 1) = v24;
    operator delete((void *)v24);
  }

  if (v16)
  {
    unint64_t v17 = v16;
    operator delete(v16);
  }
}

void sub_10028B538( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_10028B59C(id a1)
{
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](&OBJC_CLASS___NSUserDefaults, "standardUserDefaults"));
  byte_1007F4528 = [v1 BOOLForKey:@"DontLogRawMarconiEvents"] ^ 1;
  uint64_t v2 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1007F4528) {
      id v3 = @"Yes";
    }
    else {
      id v3 = @"No";
    }
    int v4 = 138412290;
    id v5 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "* Log raw Marconi events: %@",  (uint8_t *)&v4,  0xCu);
  }
}

void sub_10028B68C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10028B6A4(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v4 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "#deep-slp PRRangingManager getDeepSleepState",  v4,  2u);
  }

  return sub_100176110(a1 + 3264);
}

uint64_t sub_10028B714(uint64_t a1)
{
  return sub_100176354(a1 + 3264);
}

void sub_10028B720(uint64_t a1, uint64_t a2)
{
  if (v7)
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 16LL))(v7, a2);
    kdebug_trace(728956972LL, 0LL, 0LL, 0LL, 0LL);
  }

  else if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR))
  {
    sub_1003A4A88();
  }

  int v4 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      unint64_t v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

void sub_10028B824( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_10028B83C(uint64_t a1, _OWORD *a2)
{
  int v4 = (char *)operator new(0xB8uLL);
  __int128 v5 = a2[6];
  *(_OWORD *)(v4 + 120) = a2[7];
  __int128 v6 = a2[9];
  *(_OWORD *)(v4 + 136) = a2[8];
  *(_OWORD *)(v4 + 152) = v6;
  *(_OWORD *)(v4 + 16_Block_object_dispose((const void *)(v1 - 112), 8) = a2[10];
  __int128 v7 = a2[2];
  *(_OWORD *)(v4 + 56) = a2[3];
  __int128 v8 = a2[5];
  *(_OWORD *)(v4 + 72) = a2[4];
  *(_OWORD *)(v4 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = v8;
  *(_OWORD *)(v4 + 104) = v5;
  __int128 v9 = a2[1];
  *(_OWORD *)(v4 + _Block_object_dispose((const void *)(v1 - 112), 8) = *a2;
  *(_OWORD *)(v4 + 24) = v9;
  *(void *)int v4 = &off_1007BAEC8;
  *(_OWORD *)(v4 + 40) = v7;
  id v13 = v4;
  sub_10028BD80(a1, (uint64_t)v12);
  BOOL result = v13;
  if (v13 == v12)
  {
    uint64_t v11 = 4LL;
    BOOL result = v12;
  }

  else
  {
    if (!v13) {
      return result;
    }
    uint64_t v11 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v11))();
}

void sub_10028B930( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  __int16 v14 = a13;
  if (a13 == &a10)
  {
    uint64_t v15 = 4LL;
    __int16 v14 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v15 = 5LL;
  }

  (*(void (**)(void))(*(void *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_10028B96C(uint64_t a1, uint64_t a2)
{
  if (v7)
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 32LL))(v7, a2);
  }

  else if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR))
  {
    sub_1003A4AEC();
  }

  int v4 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      unint64_t v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

void sub_10028BA38( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10028BA4C(uint64_t a1@<X0>, unsigned __int16 a2@<W1>, void *a3@<X8>)
{
  unsigned __int16 v10 = a2;
  __int128 v5 = (std::recursive_mutex *)(a1 + 64);
  std::recursive_mutex::lock((std::recursive_mutex *)(a1 + 64));
  unint64_t v6 = sub_100132210((void *)(a1 + 232), &v10);
  if (v6)
  {
    uint64_t v7 = v6[4];
    *a3 = v6[3];
    a3[1] = v7;
    if (v7)
    {
      __int128 v8 = (unint64_t *)(v7 + 1);
      do
        unint64_t v9 = __ldxr(v8);
      while (__stxr(v9 + 1, v8));
    }
  }

  else
  {
    *a3 = 0LL;
    a3[1] = 0LL;
  }

  std::recursive_mutex::unlock(v5);
}

void sub_10028BACC(_Unwind_Exception *a1)
{
}

void sub_10028BAE0(uint64_t a1, unsigned __int16 *a2)
{
  if (v7)
  {
    (*(void (**)(uint64_t, unsigned __int16 *))(*(void *)v7 + 48LL))(v7, a2);
  }

  else if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR))
  {
    sub_1003A4B50();
  }

  int v4 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      unint64_t v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

void sub_10028BBA0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10028BBB4(uint64_t a1, uint64_t a2)
{
  if (v7)
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 40LL))(v7, a2);
  }

  else if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR))
  {
    sub_1003A4BB0();
  }

  int v4 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      unint64_t v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

void sub_10028BC80( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t (***sub_10028BC94(uint64_t a1, int *a2))()
{
  int v4 = *a2;
  uint64_t v7 = &off_1007BAD38;
  int v8 = v4;
  unint64_t v9 = &v7;
  sub_10028BD80(a1, (uint64_t)&v7);
  BOOL result = v9;
  if (v9 == &v7)
  {
    uint64_t v6 = 4LL;
    BOOL result = &v7;
  }

  else
  {
    if (!v9) {
      return result;
    }
    uint64_t v6 = 5LL;
  }

  return (uint64_t (***)())(*result)[v6]();
}

void sub_10028BD44( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  __int16 v14 = a13;
  if (a13 == &a10)
  {
    uint64_t v15 = 4LL;
    __int16 v14 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v15 = 5LL;
  }

  (*(void (**)(void))(*(void *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_10028BD80(uint64_t a1, uint64_t a2)
{
  int v4 = (std::recursive_mutex *)(a1 + 64);
  std::recursive_mutex::lock((std::recursive_mutex *)(a1 + 64));
  if (!*(void *)(a1 + 224))
  {
    __int128 v5 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v11 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "forEachClientWithFunction but no registered clients.",  v11,  2u);
    }
  }

  uint64_t v6 = *(void **)(a1 + 208);
  sub_10001E914((uint64_t)v12, a2);
  sub_10028CFDC(v6, (void *)(a1 + 216), (uint64_t)v12, (uint64_t)v14);
  uint64_t v7 = v15;
  if (v15 == v14)
  {
    uint64_t v8 = 4LL;
    uint64_t v7 = v14;
  }

  else
  {
    if (!v15) {
      goto LABEL_9;
    }
    uint64_t v8 = 5LL;
  }

  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_9:
  unint64_t v9 = v13;
  if (v13 == v12)
  {
    uint64_t v10 = 4LL;
    unint64_t v9 = v12;
    goto LABEL_13;
  }

  if (v13)
  {
    uint64_t v10 = 5LL;
LABEL_13:
    (*(void (**)(void))(*v9 + 8 * v10))();
  }

  std::recursive_mutex::unlock(v4);
}

void sub_10028BEC4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char v16 = a13;
  if (a13 == v14)
  {
    uint64_t v17 = 4LL;
    char v16 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v17 = 5LL;
  }

  (*(void (**)(void))(*(void *)v16 + 8 * v17))();
LABEL_6:
  std::recursive_mutex::unlock(v13);
  _Unwind_Resume(a1);
}

void sub_10028BF0C(uint64_t a1, unsigned __int16 *a2)
{
  if (v7)
  {
    (*(void (**)(uint64_t, unsigned __int16 *))(*(void *)v7 + 56LL))(v7, a2);
  }

  else if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR))
  {
    sub_1003A4C10();
  }

  int v4 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      unint64_t v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

void sub_10028BFCC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10028BFE0(uint64_t a1, unsigned __int16 *a2)
{
}

void sub_10028BFE8(uint64_t a1, unsigned __int16 *a2)
{
  if (v7)
  {
    (*(void (**)(uint64_t, unsigned __int16 *))(*(void *)v7 + 64LL))(v7, a2);
  }

  else if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR))
  {
    sub_1003A4C70();
  }

  int v4 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      unint64_t v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

void sub_10028C0A8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10028C0BC(uint64_t a1, unsigned __int16 *a2)
{
}

void *sub_10028C0C4(uint64_t a1, uint64_t a2)
{
  v6[0] = &off_1007BADC8;
  v6[1] = a2;
  uint64_t v7 = v6;
  sub_10028BD80(a1, (uint64_t)v6);
  BOOL result = v7;
  if (v7 == v6)
  {
    uint64_t v5 = 4LL;
    BOOL result = v6;
  }

  else
  {
    if (!v7) {
      return result;
    }
    uint64_t v5 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v5))();
}

void sub_10028C16C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  __int16 v14 = a13;
  if (a13 == &a10)
  {
    uint64_t v15 = 4LL;
    __int16 v14 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v15 = 5LL;
  }

  (*(void (**)(void))(*(void *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void *sub_10028C1A8(uint64_t a1, uint64_t a2)
{
  return sub_10028C0C4(a1 - 24, a2);
}

void *sub_10028C1B0(uint64_t a1, uint64_t a2)
{
  v6[0] = &off_1007BAE48;
  v6[1] = a2;
  uint64_t v7 = v6;
  sub_10028BD80(a1, (uint64_t)v6);
  BOOL result = v7;
  if (v7 == v6)
  {
    uint64_t v5 = 4LL;
    BOOL result = v6;
  }

  else
  {
    if (!v7) {
      return result;
    }
    uint64_t v5 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v5))();
}

void sub_10028C258( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  __int16 v14 = a13;
  if (a13 == &a10)
  {
    uint64_t v15 = 4LL;
    __int16 v14 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v15 = 5LL;
  }

  (*(void (**)(void))(*(void *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_10028C294(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a2 + 4);
  switch(v4)
  {
    case 1:
      if (!*(_BYTE *)(a2 + 20)) {
        sub_1003A4CD0();
      }
      sub_10028C388(a1, a2 + 8);
      if (!*(_BYTE *)(a2 + 20)) {
        sub_100006080();
      }
      sub_10028C4BC(a1, (unsigned __int16 *)(a2 + 8));
      break;
    case 2:
      if (!*(_BYTE *)(a2 + 56)) {
        sub_1003A4CF8();
      }
      sub_10028C56C(a1, *(_WORD *)a2, a2 + 24);
      break;
    case 0:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "PRRangingService got unspecified service response");
  }

void sub_10028C374(_Unwind_Exception *a1)
{
}

void sub_10028C388(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a2 + 4);
  BOOL v3 = v2 > 9;
  int v4 = (1 << v2) & 0x390;
  if (!v3 && v4 != 0)
  {
    uint64_t v8 = (os_log_s *)(id)qword_1008000A0;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      sub_1000065CC(__p, off_1007BB070[*(int *)(a2 + 4)]);
      if (v11 >= 0) {
        unint64_t v9 = __p;
      }
      else {
        unint64_t v9 = (void **)__p[0];
      }
      *(_DWORD *)buf = 136315138;
      id v13 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "PRRangingManager::handlePossibleRequestInvalidation - %s",  buf,  0xCu);
      if (v11 < 0) {
        operator delete(__p[0]);
      }
    }

    sub_10028C650(a1, *(_WORD *)a2);
  }

void sub_10028C4A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10028C4BC(uint64_t a1, unsigned __int16 *a2)
{
  if (v7) {
    (*(void (**)(uint64_t, unsigned __int16 *))(*(void *)v7 + 80LL))(v7, a2);
  }
  int v4 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      unint64_t v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

void sub_10028C558( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10028C56C(uint64_t a1, unsigned __int16 a2, uint64_t a3)
{
  if (v9)
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v9 + 104LL))(v9, a3);
  }

  else if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR))
  {
    sub_1003A4D20();
  }

  unint64_t v6 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

void sub_10028C638( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10028C650(uint64_t a1, unsigned __int16 a2)
{
  unsigned __int16 v26 = a2;
  BOOL v3 = (std::recursive_mutex *)(a1 + 64);
  std::recursive_mutex::lock((std::recursive_mutex *)(a1 + 64));
  int v4 = sub_100132210((void *)(a1 + 232), &v26);
  uint64_t v5 = v4;
  if (v4)
  {
    uint64_t v6 = (uint64_t)v4[3];
    uint64_t v7 = v4[4];
    uint64_t v24 = v6;
    int64_t v25 = (std::__shared_weak_count *)v7;
    if (v7)
    {
      unint64_t v8 = (unint64_t *)(v7 + 1);
      do
        unint64_t v9 = __ldxr(v8);
      while (__stxr(v9 + 1, v8));
    }

    if (v6)
    {
      uint64_t v10 = sub_10028E770((void *)(a1 + 272), &v24);
      if (v10)
      {
        uint64_t v13 = v10[5];
        char v11 = (uint64_t **)(v10 + 5);
        uint64_t v12 = v13;
        if (!v13) {
          goto LABEL_18;
        }
        __int16 v14 = (uint64_t *)v11;
        do
        {
          unsigned int v15 = *(unsigned __int16 *)(v12 + 26);
          BOOL v16 = v15 >= v26;
          if (v15 >= v26) {
            uint64_t v17 = (uint64_t *)v12;
          }
          else {
            uint64_t v17 = (uint64_t *)(v12 + 8);
          }
          if (v16) {
            __int16 v14 = (uint64_t *)v12;
          }
          uint64_t v12 = *v17;
        }

        while (*v17);
        if (v14 != (uint64_t *)v11 && v26 >= *((unsigned __int16 *)v14 + 13))
        {
          sub_10001EA5C(v11 - 1, v14);
          operator delete(v14);
        }

        else
        {
LABEL_18:
          sub_10028EDF8((void *)(a1 + 272), &v24);
        }
      }

      else
      {
        char v19 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
          sub_1003A4DE4(&v24, v19);
        }
      }
    }

    else if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR))
    {
      sub_1003A4D84();
    }

    uint64_t v20 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      int v28 = v26;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "PRRangingManager: Speculative Cleanup - erasing ticketId (%d) from fRequestToClientMap",  buf,  8u);
    }

    sub_100021814((void *)(a1 + 232), v5, (uint64_t)buf);
    sub_1001B9B74((uint64_t)buf, 0LL);
    sub_10017470C(a1 + 3264);
    std::stringbuf v21 = v25;
    if (v25)
    {
      p_shared_owners = (unint64_t *)&v25->__shared_owners_;
      do
        unint64_t v23 = __ldaxr(p_shared_owners);
      while (__stlxr(v23 - 1, p_shared_owners));
      if (!v23)
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
    }
  }

  else
  {
    uint64_t v18 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      int v28 = v26;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "Speculative Cleanup: no request found with ticket: %d",  buf,  8u);
    }
  }

  std::recursive_mutex::unlock(v3);
}

void sub_10028C8D0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

void sub_10028C904(std::recursive_mutex *a1, uint64_t a2)
{
  int v4 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unint64_t v9 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Enumerating registered service requests",  v9,  2u);
  }

  uint64_t v5 = a1 + 1;
  std::recursive_mutex::lock(a1 + 1);
  uint64_t sig = a1[101].__m_.__sig;
  sub_10001E914((uint64_t)v10, a2);
  (*(void (**)(uint64_t, _BYTE *))(*(void *)sig + 80LL))(sig, v10);
  uint64_t v7 = v11;
  if (v11 == v10)
  {
    uint64_t v8 = 4LL;
    uint64_t v7 = v10;
    goto LABEL_7;
  }

  if (v11)
  {
    uint64_t v8 = 5LL;
LABEL_7:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }

  std::recursive_mutex::unlock(v5);
}

void sub_10028CA0C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  unsigned int v15 = a13;
  if (a13 == &a10)
  {
    uint64_t v16 = 4LL;
    unsigned int v15 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v16 = 5LL;
  }

  (*(void (**)(void))(*(void *)v15 + 8 * v16))();
LABEL_6:
  std::recursive_mutex::unlock(v13);
  _Unwind_Resume(a1);
}

void sub_10028CA60(uint64_t a1, unint64_t *a2)
{
  int v4 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Client connecting.", v5, 2u);
  }

  if (*a2)
  {
    std::recursive_mutex::lock((std::recursive_mutex *)(a1 + 64));
    sub_10028EC78((uint64_t **)(a1 + 208), a2, (uint64_t *)a2);
    std::recursive_mutex::unlock((std::recursive_mutex *)(a1 + 64));
  }

  else if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR))
  {
    sub_1003A4E5C();
  }

void sub_10028CB24(_Unwind_Exception *a1)
{
}

void sub_10028CB38(uint64_t a1, unint64_t *a2)
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003A4EB4();
  }
  if (*a2)
  {
    unint64_t v4 = a2[1];
    unint64_t v10 = *a2;
    char v11 = (std::__shared_weak_count *)v4;
    if (v4)
    {
      uint64_t v5 = (unint64_t *)(v4 + 8);
      do
        unint64_t v6 = __ldxr(v5);
      while (__stxr(v6 + 1, v5));
    }

    sub_10028CC34(a1, &v10);
    uint64_t v7 = v11;
    if (v11)
    {
      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v9 = __ldaxr(p_shared_owners);
      while (__stlxr(v9 - 1, p_shared_owners));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR))
  {
    sub_1003A4E88();
  }

void sub_10028CC20( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10028CC34(uint64_t a1, unint64_t *a2)
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003A4F0C();
  }
  if (*a2)
  {
    unint64_t v4 = (std::recursive_mutex *)(a1 + 64);
    std::recursive_mutex::lock((std::recursive_mutex *)(a1 + 64));
    uint64_t v5 = *(void **)(a1 + 216);
    if (v5)
    {
      unint64_t v6 = *a2;
      uint64_t v7 = (uint64_t *)(a1 + 216);
      do
      {
        unint64_t v8 = v5[4];
        BOOL v9 = v8 >= v6;
        if (v8 >= v6) {
          unint64_t v10 = v5;
        }
        else {
          unint64_t v10 = v5 + 1;
        }
        if (v9) {
          uint64_t v7 = v5;
        }
        uint64_t v5 = (void *)*v10;
      }

      while (*v10);
      if (v7 != (uint64_t *)(a1 + 216) && v6 >= v7[4])
      {
        sub_10001EA5C((uint64_t **)(a1 + 208), v7);
        sub_100012390((uint64_t)(v7 + 4));
        operator delete(v7);
        char v11 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Cleanup: removed from client record",  buf,  2u);
        }
      }
    }

    uint64_t v12 = sub_10028E770((void *)(a1 + 272), a2);
    uint64_t v13 = v12;
    if (v12)
    {
      sub_100131CE8((uint64_t *)&v25, (uint64_t)(v12 + 4));
      __int16 v14 = v25;
      if (v25 != v26)
      {
        do
        {
          int v15 = *((unsigned __int16 *)v14 + 13);
          (*(void (**)(uint8_t *__return_ptr, void, void))(**(void **)(a1 + 6464) + 48LL))( buf,  *(void *)(a1 + 6464),  *((unsigned __int16 *)v14 + 13));
          if (v33) {
            sub_10028E120();
          }
          if (!BYTE4(v32))
          {
            uint64_t v16 = (os_log_s *)(id)qword_1008000A0;
            if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
            {
              sub_100288FEC(buf, v23);
              uint64_t v20 = v23;
              if (v24 < 0) {
                uint64_t v20 = (void **)v23[0];
              }
              *(_DWORD *)char v27 = 67109378;
              int v28 = v15;
              __int16 v29 = 2080;
              char v30 = v20;
              _os_log_error_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_ERROR,  "Cleanup: Failed to unregister for service with ticket: %d. Error: %s",  v27,  0x12u);
              if (v24 < 0) {
                operator delete(v23[0]);
              }
            }

            sub_10028C650(a1, v15);
          }

          if (v36 && v35 < 0) {
            operator delete(__p);
          }
          uint64_t v17 = v14[1];
          if (v17)
          {
            do
            {
              uint64_t v18 = (void **)v17;
              uint64_t v17 = (void *)*v17;
            }

            while (v17);
          }

          else
          {
            do
            {
              uint64_t v18 = (void **)v14[2];
              BOOL v19 = *v18 == v14;
              __int16 v14 = v18;
            }

            while (!v19);
          }

          __int16 v14 = v18;
        }

        while (v18 != v26);
      }

      sub_10028EDB0((void *)(a1 + 272), v13);
      sub_100034A98((uint64_t)&v25, v26[0]);
    }

    else
    {
      std::stringbuf v21 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v22 = *a2;
        *(_DWORD *)buf = 134217984;
        unint64_t v32 = v22;
        _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "Cleanup: no requests found for client %p",  buf,  0xCu);
      }
    }

    std::recursive_mutex::unlock(v4);
  }

  else if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR))
  {
    sub_1003A4EE0();
  }

void sub_10028CF78(_Unwind_Exception *a1)
{
}

uint64_t sub_10028CFDC@<X0>(void *a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  if (a1 != a2)
  {
    uint64_t v7 = a1;
    do
    {
      unint64_t v8 = (std::__shared_weak_count *)v7[5];
      uint64_t v19 = v7[4];
      uint64_t v20 = v8;
      if (v8)
      {
        p_shared_owners = (unint64_t *)&v8->__shared_owners_;
        do
          unint64_t v10 = __ldxr(p_shared_owners);
        while (__stxr(v10 + 1, p_shared_owners));
      }

      uint64_t v11 = *(void *)(a3 + 24);
      if (!v11) {
        sub_10001EEF0();
      }
      (*(void (**)(uint64_t, uint64_t *))(*(void *)v11 + 48LL))(v11, &v19);
      uint64_t v12 = v20;
      if (v20)
      {
        uint64_t v13 = (unint64_t *)&v20->__shared_owners_;
        do
          unint64_t v14 = __ldaxr(v13);
        while (__stlxr(v14 - 1, v13));
        if (!v14)
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
      }

      int v15 = (void *)v7[1];
      if (v15)
      {
        do
        {
          uint64_t v16 = v15;
          int v15 = (void *)*v15;
        }

        while (v15);
      }

      else
      {
        do
        {
          uint64_t v16 = (void *)v7[2];
          BOOL v17 = *v16 == (void)v7;
          uint64_t v7 = v16;
        }

        while (!v17);
      }

      uint64_t v7 = v16;
    }

    while (v16 != a2);
  }

  return sub_10028F000(a4, a3);
}

void sub_10028D0E0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10028D0F8@<X0>(const void **a1@<X0>, const void **a2@<X1>, uint64_t a3@<X8>)
{
  else {
    size_t v5 = (size_t)a1[1];
  }
  else {
    size_t v6 = (size_t)a2[1];
  }
  uint64_t result = sub_10015CEB8(a3, v6 + v5);
  else {
    unint64_t v8 = *(char **)result;
  }
  if (v5)
  {
    else {
      BOOL v9 = *a1;
    }
    uint64_t result = (uint64_t)memmove(v8, v9, v5);
  }

  unint64_t v10 = &v8[v5];
  if (v6)
  {
    else {
      uint64_t v11 = *a2;
    }
    uint64_t result = (uint64_t)memmove(v10, v11, v6);
  }

  v10[v6] = 0;
  return result;
}

uint64_t sub_10028D1C0(uint64_t a1, const void **a2, uint64_t a3)
{
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  unint64_t v4 = (uint64_t *)(a1 + 8);
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = a1 + 8;
  if (a3)
  {
    uint64_t v6 = 24 * a3;
    do
    {
      sub_10028D240((uint64_t **)a1, v4, a2, (uint64_t)a2);
      a2 += 3;
      v6 -= 24LL;
    }

    while (v6);
  }

  return a1;
}

void sub_10028D228(_Unwind_Exception *a1)
{
}

uint64_t *sub_10028D240(uint64_t **a1, uint64_t *a2, const void **a3, uint64_t a4)
{
  uint64_t v6 = (uint64_t **)sub_1002025F4(a1, a2, &v10, &v9, a3);
  uint64_t result = *v6;
  if (!*v6)
  {
    sub_10028D2C0((uint64_t)a1, a4, (uint64_t)&v8);
    sub_10001E548(a1, (uint64_t)v10, v6, v8);
    return v8;
  }

  return result;
}

void *sub_10028D2C0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t v6 = (char *)operator new(0x38uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + _Block_object_dispose((const void *)(v1 - 112), 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  uint64_t result = v6 + 32;
  if (*(char *)(a2 + 23) < 0)
  {
    uint64_t result = sub_1000063A8(result, *(void **)a2, *(void *)(a2 + 8));
  }

  else
  {
    *(_OWORD *)uint64_t result = *(_OWORD *)a2;
    result[2] = *(void *)(a2 + 16);
  }

  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_10028D340(_Unwind_Exception *a1)
{
  void *v1 = 0LL;
  sub_1001AE0A4(v3, v2);
  _Unwind_Resume(a1);
}

uint64_t sub_10028D35C(uint64_t a1, __int128 *a2, __int128 *a3, const void ***a4)
{
  *(void *)a1 = off_1007B1648;
  if (*((char *)a2 + 23) < 0)
  {
    sub_1000063A8((_BYTE *)(a1 + 8), *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v7 = *a2;
    *(void *)(a1 + 24) = *((void *)a2 + 2);
    *(_OWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v7;
  }

  if (*((char *)a3 + 23) < 0)
  {
    sub_1000063A8((_BYTE *)(a1 + 32), *(void **)a3, *((void *)a3 + 1));
  }

  else
  {
    __int128 v8 = *a3;
    *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = *((void *)a3 + 2);
    *(_OWORD *)(a1 + 32) = v8;
  }

  sub_10028D440((uint64_t *)(a1 + 56), a4);
  return a1;
}

void sub_10028D40C(_Unwind_Exception *exception_object)
{
}

uint64_t *sub_10028D440(uint64_t *a1, const void ***a2)
{
  a1[2] = 0LL;
  a1[1] = 0LL;
  *a1 = (uint64_t)(a1 + 1);
  sub_10028D494(a1, *a2, a2 + 1);
  return a1;
}

void sub_10028D47C(_Unwind_Exception *a1)
{
}

uint64_t *sub_10028D494(uint64_t *result, const void **a2, const void ***a3)
{
  if (a2 != (const void **)a3)
  {
    unint64_t v4 = a2;
    uint64_t v5 = (uint64_t **)result;
    uint64_t v6 = result + 1;
    do
    {
      uint64_t result = sub_10028D240(v5, v6, v4 + 4, (uint64_t)(v4 + 4));
      __int128 v7 = (const void **)v4[1];
      if (v7)
      {
        do
        {
          __int128 v8 = (const void ***)v7;
          __int128 v7 = (const void **)*v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          __int128 v8 = (const void ***)v4[2];
          BOOL v9 = *v8 == v4;
          unint64_t v4 = (const void **)v8;
        }

        while (!v9);
      }

      unint64_t v4 = (const void **)v8;
    }

    while (v8 != a3);
  }

  return result;
}

void *sub_10028D518@<X0>(void *a1@<X1>, unsigned __int8 *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x2C8uLL);
  uint64_t result = sub_10028D578(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_10028D564(_Unwind_Exception *a1)
{
}

void *sub_10028D578(void *a1, void *a2, unsigned __int8 *a3)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_1007BAA48;
  sub_1000C9444(a1 + 3, *a2, *a3);
  return a1;
}

void sub_10028D5B4(_Unwind_Exception *a1)
{
}

void sub_10028D5C8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1007BAA48;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10028D5D8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1007BAA48;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_10028D5F8(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void *sub_10028D608@<X0>( uint64_t a1@<X1>, uint64_t *a2@<X2>, std::__shared_weak_count_vtbl **a3@<X3>, uint64_t *a4@<X4>, void *a5@<X8>)
{
  unint64_t v10 = operator new(0xB8uLL);
  uint64_t result = sub_10028D680(v10, a1, a2, a3, a4);
  *a5 = v10 + 3;
  a5[1] = v10;
  return result;
}

void sub_10028D66C(_Unwind_Exception *a1)
{
}

void *sub_10028D680(void *a1, uint64_t a2, uint64_t *a3, std::__shared_weak_count_vtbl **a4, uint64_t *a5)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_1007BAA98;
  sub_10028D728((uint64_t)&v7, (uint64_t)(a1 + 3), a2, a3, a4, a5);
  return a1;
}

void sub_10028D6D4(_Unwind_Exception *a1)
{
}

void sub_10028D6E8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1007BAA98;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10028D6F8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1007BAA98;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_10028D718(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t sub_10028D728( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, std::__shared_weak_count_vtbl **a5, uint64_t *a6)
{
  uint64_t v10 = *a4;
  *a4 = 0LL;
  uint64_t v27 = v10;
  uint64_t v11 = *a5;
  int64_t v25 = v11;
  if (v11)
  {
    uint64_t v12 = (std::__shared_weak_count *)operator new(0x20uLL);
    v12->__vftable = (std::__shared_weak_count_vtbl *)&off_1007BAAE8;
    v12->__shared_owners_ = 0LL;
    v12->__shared_weak_owners_ = 0LL;
    v12[1].__vftable = v11;
  }

  else
  {
    uint64_t v12 = 0LL;
  }

  unsigned __int16 v26 = v12;
  *a5 = 0LL;
  uint64_t v13 = (std::__shared_weak_count *)a6[1];
  uint64_t v23 = *a6;
  char v24 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      unint64_t v15 = __ldxr(p_shared_owners);
    while (__stxr(v15 + 1, p_shared_owners));
  }

  sub_1002334DC(a2, a3, &v27, &v25, &v23);
  uint64_t v16 = v24;
  if (v24)
  {
    BOOL v17 = (unint64_t *)&v24->__shared_owners_;
    do
      unint64_t v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }

  uint64_t v19 = v26;
  if (v26)
  {
    uint64_t v20 = (unint64_t *)&v26->__shared_owners_;
    do
      unint64_t v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }

  uint64_t result = v27;
  uint64_t v27 = 0LL;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

void sub_10028D868( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14)
{
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 8LL))(v14);
  }
  _Unwind_Resume(exception_object);
}

void sub_10028D8AC(std::__shared_weak_count *a1)
{
}

uint64_t sub_10028D8C0(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

uint64_t sub_10028D8D8(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

void *sub_10028D918@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x28uLL);
  uint64_t result = sub_10028D978(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_10028D964(_Unwind_Exception *a1)
{
}

void *sub_10028D978(void *a1, uint64_t a2, uint64_t a3)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_1007BAB48;
  sub_1002669A4(a1 + 3, a2 + 8, a3 + 8);
  return a1;
}

void sub_10028D9B4(_Unwind_Exception *a1)
{
}

void sub_10028D9C8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1007BAB48;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10028D9D8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1007BAB48;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

__n128 sub_10028DA08(uint64_t a1)
{
  unsigned int v2 = (char *)operator new(0x20uLL);
  *(void *)unsigned int v2 = &off_1007BAB98;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + _Block_object_dispose((const void *)(v1 - 112), 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_10028DA48(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &off_1007BAB98;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + _Block_object_dispose((const void *)(v1 - 112), 8) = result;
  return result;
}

uint64_t sub_10028DA70(void *a1, void *a2)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = (uint64_t (*)(void *, void))a1[1];
  unint64_t v4 = (void *)(a1[3] + (v2 >> 1));
  if ((v2 & 1) != 0) {
    uint64_t v3 = *(uint64_t (**)(void *, void))(*v4 + v3);
  }
  return v3(v4, *a2);
}

uint64_t sub_10028DA90(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_10028DACC()
{
}

void sub_10028DAD8(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_10028DAD8(a1, *a2);
    sub_10028DAD8(a1, a2[1]);
    sub_100012390((uint64_t)(a2 + 4));
    operator delete(a2);
  }

uint64_t sub_10028DB20(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_10028DB58(uint64_t a1, void **a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      uint64_t v3 = *v2;
      sub_100034A98((uint64_t)(v2 + 4), v2[5]);
      sub_100012390((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = (void **)v3;
    }

    while (v3);
  }

void *sub_10028DBAC@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t *a3@<X3>, uint64_t *a4@<X4>, uint64_t *a5@<X5>, void *a6@<X8>)
{
  uint64_t v12 = operator new(0x980uLL);
  __n128 result = sub_10028DC34(v12, a1, a2, a3, a4, a5);
  *a6 = v12 + 3;
  a6[1] = v12;
  return result;
}

void sub_10028DC20(_Unwind_Exception *a1)
{
}

void *sub_10028DC34(void *a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_1007BAC48;
  sub_10028DCE0((uint64_t)&v8, (uint64_t)(a1 + 3), a2, a3, a4, a5, a6);
  return a1;
}

void sub_10028DC8C(_Unwind_Exception *a1)
{
}

void sub_10028DCA0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1007BAC48;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10028DCB0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1007BAC48;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_10028DCD0(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void sub_10028DCE0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  uint64_t v8 = *a5;
  uint64_t v9 = *a6;
  uint64_t v10 = (std::__shared_weak_count *)a7[1];
  uint64_t v16 = *a7;
  BOOL v17 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }

  sub_100132F9C(a2, a3, a4, v8, v9, &v16);
  uint64_t v13 = v17;
  if (v17)
  {
    uint64_t v14 = (unint64_t *)&v17->__shared_owners_;
    do
      unint64_t v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }

void sub_10028DD78( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_10028DD8C@<X0>(uint64_t *a1@<X1>, void **a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x48uLL);
  __n128 result = sub_10028DDEC(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_10028DDD8(_Unwind_Exception *a1)
{
}

void *sub_10028DDEC(void *a1, uint64_t *a2, void **a3)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_1007BAC98;
  sub_100136F40(a1 + 3, *a2, *a3);
  return a1;
}

void sub_10028DE28(_Unwind_Exception *a1)
{
}

void sub_10028DE3C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1007BAC98;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10028DE4C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1007BAC98;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_10028DE6C(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void sub_10028DE7C(void *a1@<X8>)
{
  uint64_t v2 = operator new(0x78uLL);
  sub_10028DECC(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  sub_100012538((uint64_t)a1, v2 + 3, (uint64_t)(v2 + 3));
}

void sub_10028DEB8(_Unwind_Exception *a1)
{
}

void *sub_10028DECC(void *a1)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_1007BACE8;
  sub_1001AE634((uint64_t)(a1 + 3));
  return a1;
}

void sub_10028DF00(_Unwind_Exception *a1)
{
}

void sub_10028DF14(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1007BACE8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10028DF24(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1007BACE8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_10028DF44(uint64_t a1)
{
}

void sub_10028DF6C(uint64_t a1, uint64_t a2)
{
  std::mutex::~mutex((std::mutex *)(a2 + 16));
  uint64_t v3 = *(std::__shared_weak_count **)(a2 + 8);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void *sub_10028DFAC(void *result, void *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = result;
    unint64_t v4 = (void *)result[3];
    uint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24LL))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32LL))(v3[3]);
        v3[3] = 0LL;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24LL))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32LL))(a2[3]);
        a2[3] = 0LL;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24LL))(v6, a2);
        __n128 result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32LL))(v6);
      }

      else
      {
        (*(void (**)(void *, void *))(*result + 24LL))(result, a2);
        __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32LL))(v3[3]);
        v3[3] = a2[3];
      }

      a2[3] = a2;
    }

    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24LL))(a2, result);
      __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32LL))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }

    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }

  return result;
}

void sub_10028E114(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_10000DE88(a1);
}

void sub_10028E120()
{
  exception = __cxa_allocate_exception(8uLL);
}

void *sub_10028E158(uint64_t a1, void *a2, uint64_t a3, void **a4)
{
  unint64_t v7 = 0x9DDFEA08EB382D69LL * ((8 * *a2 + 8LL) ^ HIDWORD(*a2));
  unint64_t v8 = 0x9DDFEA08EB382D69LL * (HIDWORD(*a2) ^ (v7 >> 47) ^ v7);
  unint64_t v9 = 0x9DDFEA08EB382D69LL * (v8 ^ (v8 >> 47));
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v4 = 0x9DDFEA08EB382D69LL * (v8 ^ (v8 >> 47));
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
    }

    else
    {
      unint64_t v4 = v9 & (v10 - 1);
    }

    unint64_t v12 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v12)
    {
      for (uint64_t i = *v12; i; uint64_t i = (void *)*i)
      {
        unint64_t v14 = i[1];
        if (v14 == v9)
        {
          if (i[2] == *a2) {
            return i;
          }
        }

        else
        {
          if (v11.u32[0] > 1uLL)
          {
            if (v14 >= v10) {
              v14 %= v10;
            }
          }

          else
          {
            v14 &= v10 - 1;
          }

          if (v14 != v4) {
            break;
          }
        }
      }
    }
  }

  unint64_t v15 = (void *)(a1 + 16);
  uint64_t v16 = operator new(0x38uLL);
  uint64_t i = v16;
  *uint64_t v16 = 0LL;
  v16[1] = v9;
  BOOL v17 = *a4;
  void v16[2] = **a4;
  uint64_t v18 = v17[1];
  v16[3] = v18;
  if (v18)
  {
    uint64_t v19 = (unint64_t *)(v18 + 8);
    do
      unint64_t v20 = __ldxr(v19);
    while (__stxr(v20 + 1, v19));
  }

  v16[5] = 0LL;
  int v16[6] = 0LL;
  v16[4] = v16 + 5;
  float v21 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v22 = *(float *)(a1 + 32);
  if (!v10 || (float)(v22 * (float)v10) < v21)
  {
    BOOL v23 = 1LL;
    if (v10 >= 3) {
      BOOL v23 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v24 = v23 | (2 * v10);
    unint64_t v25 = vcvtps_u32_f32(v21 / v22);
    if (v24 <= v25) {
      size_t v26 = v25;
    }
    else {
      size_t v26 = v24;
    }
    sub_100021B74(a1, v26);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
      else {
        unint64_t v4 = v9;
      }
    }

    else
    {
      unint64_t v4 = (v10 - 1) & v9;
    }
  }

  uint64_t v27 = *(void *)a1;
  int v28 = *(void **)(*(void *)a1 + 8 * v4);
  if (v28)
  {
    void *i = *v28;
LABEL_41:
    *int v28 = i;
    goto LABEL_42;
  }

  void *i = *v15;
  void *v15 = i;
  *(void *)(v27 + 8 * v4) = v15;
  if (*i)
  {
    unint64_t v29 = *(void *)(*i + 8LL);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v29 >= v10) {
        v29 %= v10;
      }
    }

    else
    {
      v29 &= v10 - 1;
    }

    int v28 = (void *)(*(void *)a1 + 8 * v29);
    goto LABEL_41;
  }

void sub_10028E3E8(_Unwind_Exception *a1)
{
}

void sub_10028E404(uint64_t a1, void **a2)
{
  if (*(_BYTE *)(a1 + 8))
  {
    sub_100034A98((uint64_t)(a2 + 4), a2[5]);
    sub_100012390((uint64_t)(a2 + 2));
  }

  else if (!a2)
  {
    return;
  }

  operator delete(a2);
}

uint64_t **sub_10028E458(uint64_t **a1, unsigned __int16 *a2, _WORD *a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    unsigned int v7 = *a2;
    while (1)
    {
      while (1)
      {
        unint64_t v8 = (uint64_t **)v5;
        unsigned int v9 = *((unsigned __int16 *)v5 + 13);
        if (v7 >= v9) {
          break;
        }
        uint64_t v5 = *v8;
        uint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }

      if (v9 >= v7) {
        break;
      }
      uint64_t v5 = v8[1];
      if (!v5)
      {
        uint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    unint64_t v8 = a1 + 1;
LABEL_10:
    unint64_t v10 = (uint64_t *)operator new(0x20uLL);
    *((_WORD *)v10 + 13) = *a3;
    sub_10001E548(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }

  return v8;
}

uint64_t **sub_10028E510(uint64_t a1, unsigned __int16 *a2, uint64_t a3, _WORD **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
    }

    else
    {
      unint64_t v4 = ((_DWORD)v8 - 1) & v7;
    }

    unint64_t v10 = *(uint64_t ****)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      for (uint64_t i = *v10; i; uint64_t i = (uint64_t **)*i)
      {
        unint64_t v12 = (unint64_t)i[1];
        if (v12 == v7)
        {
        }

        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= v8) {
              v12 %= v8;
            }
          }

          else
          {
            v12 &= v8 - 1;
          }

          if (v12 != v4) {
            break;
          }
        }
      }
    }
  }

  uint64_t v13 = a1 + 16;
  unint64_t v14 = operator new(0x28uLL);
  v24[0] = v14;
  v24[1] = a1 + 16;
  *unint64_t v14 = 0LL;
  v14[1] = v7;
  *((_WORD *)v14 + _Block_object_dispose((const void *)(v1 - 112), 8) = **a4;
  v14[3] = 0LL;
  void v14[4] = 0LL;
  char v25 = 1;
  float v15 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v16 = *(float *)(a1 + 32);
  if (!v8 || (float)(v16 * (float)v8) < v15)
  {
    BOOL v17 = 1LL;
    if (v8 >= 3) {
      BOOL v17 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v8);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t v20 = v19;
    }
    else {
      size_t v20 = v18;
    }
    sub_100021B74(a1, v20);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }

    else
    {
      unint64_t v4 = ((_DWORD)v8 - 1) & v7;
    }
  }

  float v21 = *(void **)(*(void *)a1 + 8 * v4);
  if (v21)
  {
    *(void *)v24[0] = *v21;
    *float v21 = v24[0];
  }

  else
  {
    *(void *)v24[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v24[0];
    *(void *)(*(void *)a1 + 8 * v4) = v13;
    if (*(void *)v24[0])
    {
      unint64_t v22 = *(void *)(*(void *)v24[0] + 8LL);
      if ((v8 & (v8 - 1)) != 0)
      {
        if (v22 >= v8) {
          v22 %= v8;
        }
      }

      else
      {
        v22 &= v8 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v22) = v24[0];
    }
  }

  uint64_t i = (uint64_t **)v24[0];
  v24[0] = 0LL;
  ++*(void *)(a1 + 24);
  sub_1001B9B74((uint64_t)v24, 0LL);
  return i;
}

void sub_10028E758(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *sub_10028E770(void *a1, void *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0LL;
  }
  unint64_t v3 = 0x9DDFEA08EB382D69LL * ((8 * *a2 + 8LL) ^ HIDWORD(*a2));
  unint64_t v4 = 0x9DDFEA08EB382D69LL * (HIDWORD(*a2) ^ (v3 >> 47) ^ v3);
  unint64_t v5 = 0x9DDFEA08EB382D69LL * (v4 ^ (v4 >> 47));
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = v5;
    if (v5 >= *(void *)&v2) {
      unint64_t v7 = v5 % *(void *)&v2;
    }
  }

  else
  {
    unint64_t v7 = v5 & (*(void *)&v2 - 1LL);
  }

  unint64_t v8 = *(void **)(*a1 + 8 * v7);
  if (!v8) {
    return 0LL;
  }
  __n128 result = (void *)*v8;
  if (*v8)
  {
    do
    {
      unint64_t v10 = result[1];
      if (v10 == v5)
      {
        if (result[2] == *a2) {
          return result;
        }
      }

      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= *(void *)&v2) {
            v10 %= *(void *)&v2;
          }
        }

        else
        {
          v10 &= *(void *)&v2 - 1LL;
        }

        if (v10 != v7) {
          return 0LL;
        }
      }

      __n128 result = (void *)*result;
    }

    while (result);
  }

  return result;
}

uint64_t sub_10028E85C(uint64_t a1)
{
  return sub_100012390(a1);
}

void *sub_10028E888(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  if (v3)
  {
    unint64_t v4 = (unint64_t *)(v3 + 8);
    do
      unint64_t v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }

  sub_100131CE8(a1 + 2, (uint64_t)(a2 + 2));
  return a1;
}

void sub_10028E8D4(_Unwind_Exception *a1)
{
}

_DWORD *sub_10028E8F0(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  *(void *)__n128 result = &off_1007BAD38;
  result[2] = *(_DWORD *)(a1 + 8);
  return result;
}

uint64_t sub_10028E928(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &off_1007BAD38;
  *(_DWORD *)(a2 + _Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)(result + 8);
  return result;
}

void sub_10028E948(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  unint64_t v4 = (std::__shared_weak_count *)a2[1];
  *a2 = 0LL;
  a2[1] = 0LL;
  if (v3) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 96LL))(v3, a1 + 8);
  }
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      unint64_t v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

void sub_10028E9BC(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_1003A4F38();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10028E9D4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_10028EA10()
{
}

void *sub_10028EA24(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &off_1007BADC8;
  result[1] = v3;
  return result;
}

uint64_t sub_10028EA58(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_1007BADC8;
  a2[1] = v2;
  return result;
}

void sub_10028EA74(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  unint64_t v4 = (std::__shared_weak_count *)a2[1];
  *a2 = 0LL;
  a2[1] = 0LL;
  if (v3) {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 72LL))(v3, *(void *)(a1 + 8));
  }
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      unint64_t v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

void sub_10028EAE8(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_1003A4F38();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10028EB00(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_10028EB3C()
{
}

void *sub_10028EB50(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &off_1007BAE48;
  result[1] = v3;
  return result;
}

uint64_t sub_10028EB84(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_1007BAE48;
  a2[1] = v2;
  return result;
}

void sub_10028EBA0(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  unint64_t v4 = (std::__shared_weak_count *)a2[1];
  *a2 = 0LL;
  a2[1] = 0LL;
  if (v3) {
    (*(void (**)(uint64_t, void, void))(*(void *)v3 + 88LL))( v3,  **(unsigned int **)(a1 + 8),  *(unsigned int *)(*(void *)(a1 + 8) + 4LL));
  }
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      unint64_t v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

void sub_10028EC18(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_1003A4F38();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10028EC30(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_10028EC6C()
{
}

uint64_t *sub_10028EC78(uint64_t **a1, unint64_t *a2, uint64_t *a3)
{
  unint64_t v6 = a1 + 1;
  unint64_t v5 = a1[1];
  unint64_t v7 = a1 + 1;
  unint64_t v8 = a1 + 1;
  if (v5)
  {
    unint64_t v9 = *a2;
    while (1)
    {
      while (1)
      {
        unint64_t v8 = (uint64_t **)v5;
        unint64_t v10 = v5[4];
        if (v9 >= v10) {
          break;
        }
        unint64_t v5 = *v8;
        unint64_t v7 = v8;
        if (!*v8) {
          goto LABEL_9;
        }
      }

      if (v10 >= v9) {
        return (uint64_t *)v8;
      }
      unint64_t v5 = v8[1];
      if (!v5)
      {
        unint64_t v7 = v8 + 1;
        goto LABEL_9;
      }
    }
  }

  else
  {
LABEL_9:
    uint8x8_t v11 = (uint64_t *)operator new(0x30uLL);
    v16[1] = v6;
    uint64_t v12 = a3[1];
    v11[4] = *a3;
    void v11[5] = v12;
    if (v12)
    {
      uint64_t v13 = (unint64_t *)(v12 + 8);
      do
        unint64_t v14 = __ldxr(v13);
      while (__stxr(v14 + 1, v13));
    }

    char v17 = 1;
    sub_10001E548(a1, (uint64_t)v8, v7, v11);
    v16[0] = 0LL;
    sub_10028ED6C((uint64_t)v16, 0LL);
  }

  return v11;
}

void sub_10028ED6C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16)) {
      sub_100012390((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }

uint64_t sub_10028EDB0(void *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  sub_100021814(a1, a2, (uint64_t)&v5);
  uint64_t v3 = v5;
  unint64_t v5 = 0LL;
  if (v3) {
    sub_10028E404((uint64_t)&v6, v3);
  }
  return v2;
}

uint64_t *sub_10028EDF8(void *a1, void *a2)
{
  __n128 result = sub_10028E770(a1, a2);
  if (result)
  {
    sub_10028EDB0(a1, result);
    return (uint64_t *)1;
  }

  return result;
}

__n128 sub_10028EE34(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0xB8uLL);
  *(void *)uint64_t v2 = &off_1007BAEC8;
  *(_OWORD *)(v2 + 120) = *(_OWORD *)(a1 + 120);
  *(_OWORD *)(v2 + 136) = *(_OWORD *)(a1 + 136);
  *(_OWORD *)(v2 + 152) = *(_OWORD *)(a1 + 152);
  *(_OWORD *)(v2 + 16_Block_object_dispose((const void *)(v1 - 112), 8) = *(_OWORD *)(a1 + 168);
  *(_OWORD *)(v2 + 56) = *(_OWORD *)(a1 + 56);
  *(_OWORD *)(v2 + 72) = *(_OWORD *)(a1 + 72);
  *(_OWORD *)(v2 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = *(_OWORD *)(a1 + 88);
  *(_OWORD *)(v2 + 104) = *(_OWORD *)(a1 + 104);
  *(_OWORD *)(v2 + _Block_object_dispose((const void *)(v1 - 112), 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  return result;
}

__n128 sub_10028EEBC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &off_1007BAEC8;
  __int128 v2 = *(_OWORD *)(a1 + 8);
  __int128 v3 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 40) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(_OWORD *)(a2 + _Block_object_dispose((const void *)(v1 - 112), 8) = v2;
  __int128 v4 = *(_OWORD *)(a1 + 56);
  __int128 v5 = *(_OWORD *)(a1 + 72);
  __int128 v6 = *(_OWORD *)(a1 + 88);
  *(_OWORD *)(a2 + 104) = *(_OWORD *)(a1 + 104);
  *(_OWORD *)(a2 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = v6;
  *(_OWORD *)(a2 + 72) = v5;
  *(_OWORD *)(a2 + 56) = v4;
  __n128 result = *(__n128 *)(a1 + 120);
  __int128 v8 = *(_OWORD *)(a1 + 136);
  __int128 v9 = *(_OWORD *)(a1 + 152);
  *(_OWORD *)(a2 + 16_Block_object_dispose((const void *)(v1 - 112), 8) = *(_OWORD *)(a1 + 168);
  *(_OWORD *)(a2 + 152) = v9;
  *(_OWORD *)(a2 + 136) = v8;
  *(__n128 *)(a2 + 120) = result;
  return result;
}

void sub_10028EF2C(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  __int128 v4 = (std::__shared_weak_count *)a2[1];
  *a2 = 0LL;
  a2[1] = 0LL;
  if (v3) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 24LL))(v3, a1 + 8);
  }
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      unint64_t v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

void sub_10028EFA0(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_1003A4F38();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10028EFB8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_10028EFF4()
{
}

uint64_t sub_10028F000(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24LL))(*v3, a1);
      return a1;
    }

    *(void *)(a1 + 24) = v4;
  }

  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }

  *uint64_t v3 = 0LL;
  return a1;
}

void sub_10028F064(float a1, uint64_t a2, void *a3, uint64_t a4)
{
  if (v5 >= 0) {
    unint64_t v6 = a3;
  }
  else {
    unint64_t v6 = (void *)*a3;
  }
  *(float *)a4 = a1;
  *(_DWORD *)(a4 + 4) = v4;
  *(_WORD *)(a4 + _Block_object_dispose((const void *)(v1 - 112), 8) = 2080;
  *(void *)(a4 + 10) = v6;
}

void sub_10028F088(std::__shared_weak_count *this)
{
}

  ;
}

void sub_10028F0A8(void *a1@<X0>, const char *a2@<X3>, uint8_t *a3@<X4>, os_log_s *a4@<X8>)
{
}

  ;
}

void sub_10028F0C4()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_1007F1D58);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1007F1D58))
    {
      sub_1000065CC(qword_1007F1D40, "PRRoseProviderNetworkListener");
      __cxa_atexit((void (*)(void *))&std::string::~string, qword_1007F1D40, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_1007F1D58);
    }
  }

void sub_10028F140(_Unwind_Exception *a1)
{
}

void sub_10028F158()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_1007F1D78);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1007F1D78))
    {
      qword_1007F1D60 = 0LL;
      qword_1007F1D68 = 0LL;
      qword_1007F1D70 = 0LL;
      uint64_t v1 = operator new(0x30uLL);
      qword_1007F1D68 = (uint64_t)(v1 + 3);
      qword_1007F1D70 = (uint64_t)(v1 + 3);
      _OWORD *v1 = xmmword_10042B200;
      v1[1] = *(_OWORD *)algn_10042B210;
      v1[2] = xmmword_10042B220;
      qword_1007F1D60 = (uint64_t)v1;
      __cxa_atexit((void (*)(void *))sub_1000040CC, &qword_1007F1D60, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_1007F1D78);
    }
  }

void sub_10028F1F8(_Unwind_Exception *a1)
{
}

void sub_10028F210()
{
  unsigned __int8 v0 = objc_autoreleasePoolPush();
  sub_100320A4C(0LL, &v37);
  uint64_t v1 = std::string::insert(&v37, 0LL, "reverseLUT_A");
  __int128 v2 = *(_OWORD *)&v1->__r_.__value_.__l.__data_;
  v38.__r_.__value_.__l.__cap_ = v1->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v2;
  v1->__r_.__value_.__l.__size_ = 0LL;
  v1->__r_.__value_.__l.__cap_ = 0LL;
  v1->__r_.__value_.__r.__words[0] = 0LL;
  uint64_t v3 = std::string::append(&v38, ".bin");
  __int128 v4 = *(_OWORD *)&v3->__r_.__value_.__l.__data_;
  qword_1007FC368 = v3->__r_.__value_.__l.__cap_;
  xmmword_1007FC358 = v4;
  v3->__r_.__value_.__l.__size_ = 0LL;
  v3->__r_.__value_.__l.__cap_ = 0LL;
  v3->__r_.__value_.__r.__words[0] = 0LL;
  __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_1007FC358, (void *)&_mh_execute_header);
  sub_100320A4C(1LL, &v37);
  int v5 = std::string::insert(&v37, 0LL, "reverseLUT_A");
  __int128 v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
  v38.__r_.__value_.__l.__cap_ = v5->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v6;
  v5->__r_.__value_.__l.__size_ = 0LL;
  v5->__r_.__value_.__l.__cap_ = 0LL;
  v5->__r_.__value_.__r.__words[0] = 0LL;
  unint64_t v7 = std::string::append(&v38, ".bin");
  __int128 v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
  qword_1007FC380 = v7->__r_.__value_.__l.__cap_;
  xmmword_1007FC370 = v8;
  v7->__r_.__value_.__l.__size_ = 0LL;
  v7->__r_.__value_.__l.__cap_ = 0LL;
  v7->__r_.__value_.__r.__words[0] = 0LL;
  __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_1007FC370, (void *)&_mh_execute_header);
  sub_100320A4C(2LL, &v37);
  __int128 v9 = std::string::insert(&v37, 0LL, "reverseLUT_A");
  __int128 v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
  v38.__r_.__value_.__l.__cap_ = v9->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v10;
  v9->__r_.__value_.__l.__size_ = 0LL;
  v9->__r_.__value_.__l.__cap_ = 0LL;
  v9->__r_.__value_.__r.__words[0] = 0LL;
  uint8x8_t v11 = std::string::append(&v38, ".bin");
  __int128 v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  qword_1007FC398 = v11->__r_.__value_.__l.__cap_;
  xmmword_1007FC388 = v12;
  v11->__r_.__value_.__l.__size_ = 0LL;
  v11->__r_.__value_.__l.__cap_ = 0LL;
  v11->__r_.__value_.__r.__words[0] = 0LL;
  __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_1007FC388, (void *)&_mh_execute_header);
  sub_100320A4C(3LL, &v37);
  uint64_t v13 = std::string::insert(&v37, 0LL, "reverseLUT_A");
  __int128 v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
  v38.__r_.__value_.__l.__cap_ = v13->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v14;
  v13->__r_.__value_.__l.__size_ = 0LL;
  v13->__r_.__value_.__l.__cap_ = 0LL;
  v13->__r_.__value_.__r.__words[0] = 0LL;
  float v15 = std::string::append(&v38, ".bin");
  __int128 v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  qword_1007FC3B0 = v15->__r_.__value_.__l.__cap_;
  xmmword_1007FC3A0 = v16;
  v15->__r_.__value_.__l.__size_ = 0LL;
  v15->__r_.__value_.__l.__cap_ = 0LL;
  v15->__r_.__value_.__r.__words[0] = 0LL;
  __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_1007FC3A0, (void *)&_mh_execute_header);
  sub_100320A4C(4LL, &v37);
  char v17 = std::string::insert(&v37, 0LL, "reverseLUT_A");
  __int128 v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  v38.__r_.__value_.__l.__cap_ = v17->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v18;
  v17->__r_.__value_.__l.__size_ = 0LL;
  v17->__r_.__value_.__l.__cap_ = 0LL;
  v17->__r_.__value_.__r.__words[0] = 0LL;
  unint64_t v19 = std::string::append(&v38, ".bin");
  __int128 v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
  qword_1007FC3C8 = v19->__r_.__value_.__l.__cap_;
  xmmword_1007FC3B8 = v20;
  v19->__r_.__value_.__l.__size_ = 0LL;
  v19->__r_.__value_.__l.__cap_ = 0LL;
  v19->__r_.__value_.__r.__words[0] = 0LL;
  __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_1007FC3B8, (void *)&_mh_execute_header);
  sub_100320A4C(5LL, &v37);
  float v21 = std::string::insert(&v37, 0LL, "reverseLUT_A");
  __int128 v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
  v38.__r_.__value_.__l.__cap_ = v21->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v22;
  v21->__r_.__value_.__l.__size_ = 0LL;
  v21->__r_.__value_.__l.__cap_ = 0LL;
  v21->__r_.__value_.__r.__words[0] = 0LL;
  BOOL v23 = std::string::append(&v38, ".bin");
  __int128 v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
  qword_1007FC3E0 = v23->__r_.__value_.__l.__cap_;
  xmmword_1007FC3D0 = v24;
  v23->__r_.__value_.__l.__size_ = 0LL;
  v23->__r_.__value_.__l.__cap_ = 0LL;
  v23->__r_.__value_.__r.__words[0] = 0LL;
  __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_1007FC3D0, (void *)&_mh_execute_header);
  sub_100320A4C(6LL, &v37);
  char v25 = std::string::insert(&v37, 0LL, "reverseLUT_A");
  __int128 v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
  v38.__r_.__value_.__l.__cap_ = v25->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v26;
  v25->__r_.__value_.__l.__size_ = 0LL;
  v25->__r_.__value_.__l.__cap_ = 0LL;
  v25->__r_.__value_.__r.__words[0] = 0LL;
  uint64_t v27 = std::string::append(&v38, ".bin");
  __int128 v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
  qword_1007FC3F8 = v27->__r_.__value_.__l.__cap_;
  xmmword_1007FC3E8 = v28;
  v27->__r_.__value_.__l.__size_ = 0LL;
  v27->__r_.__value_.__l.__cap_ = 0LL;
  v27->__r_.__value_.__r.__words[0] = 0LL;
  __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_1007FC3E8, (void *)&_mh_execute_header);
  sub_100320A4C(7LL, &v37);
  unint64_t v29 = std::string::insert(&v37, 0LL, "reverseLUT_A");
  __int128 v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
  v38.__r_.__value_.__l.__cap_ = v29->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v30;
  v29->__r_.__value_.__l.__size_ = 0LL;
  v29->__r_.__value_.__l.__cap_ = 0LL;
  v29->__r_.__value_.__r.__words[0] = 0LL;
  __int16 v31 = std::string::append(&v38, ".bin");
  __int128 v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
  qword_1007FC410 = v31->__r_.__value_.__l.__cap_;
  xmmword_1007FC400 = v32;
  v31->__r_.__value_.__l.__size_ = 0LL;
  v31->__r_.__value_.__l.__cap_ = 0LL;
  v31->__r_.__value_.__r.__words[0] = 0LL;
  __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_1007FC400, (void *)&_mh_execute_header);
  sub_100320A4C(8LL, &v37);
  int v33 = std::string::insert(&v37, 0LL, "reverseLUT_A");
  __int128 v34 = *(_OWORD *)&v33->__r_.__value_.__l.__data_;
  v38.__r_.__value_.__l.__cap_ = v33->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v34;
  v33->__r_.__value_.__l.__size_ = 0LL;
  v33->__r_.__value_.__l.__cap_ = 0LL;
  v33->__r_.__value_.__r.__words[0] = 0LL;
  char v35 = std::string::append(&v38, ".bin");
  __int128 v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
  qword_1007FC428 = v35->__r_.__value_.__l.__cap_;
  xmmword_1007FC418 = v36;
  v35->__r_.__value_.__l.__size_ = 0LL;
  v35->__r_.__value_.__l.__cap_ = 0LL;
  v35->__r_.__value_.__r.__words[0] = 0LL;
  __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_1007FC418, (void *)&_mh_execute_header);
  objc_autoreleasePoolPop(v0);
}

void sub_10028F804( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10028F990( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_10028F9BC(uint64_t a1, void *a2, void *a3)
{
  id v12 = a2;
  id v5 = a3;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(*(void *)(a1 + 32) + 8LL));
  if (v12)
  {
    __int128 v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) delegate]);
    char v7 = objc_opt_respondsToSelector(v6, "DataCallback:");

    if ((v7 & 1) != 0)
    {
      __int128 v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) delegate]);
      [v8 DataCallback:v12];
    }
  }

  if (v5)
  {
    __int128 v9 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) delegate]);
    char v10 = objc_opt_respondsToSelector(v9, "ErrorCallback:");

    if ((v10 & 1) != 0)
    {
      uint8x8_t v11 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) delegate]);
      [v11 ErrorCallback:v5];
    }
  }
}

void sub_10028FAA4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_10028FBEC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_10028FC18(uint64_t a1, void *a2, void *a3)
{
  id v12 = a2;
  id v5 = a3;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(*(void *)(a1 + 32) + 8LL));
  if (v12)
  {
    __int128 v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) delegate]);
    char v7 = objc_opt_respondsToSelector(v6, "DataCallback:");

    if ((v7 & 1) != 0)
    {
      __int128 v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) delegate]);
      [v8 DataCallback:v12];
    }
  }

  if (v5)
  {
    __int128 v9 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) delegate]);
    char v10 = objc_opt_respondsToSelector(v9, "ErrorCallback:");

    if ((v10 & 1) != 0)
    {
      uint8x8_t v11 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) delegate]);
      [v11 ErrorCallback:v5];
    }
  }
}

void sub_10028FD00( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_10029004C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9)
{
}

void *sub_100290108(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556LL) {
    sub_10001D350();
  }
  return operator new(48 * a2);
}

void *sub_10029014C@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_1000065CC(a2, off_1007BB268[a1]);
}

void *sub_100290160@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_1000065CC(a2, off_1007BB2C0[a1]);
}

void *sub_100290174@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_1000065CC(a2, off_1007BB308[a1]);
}

void *sub_100290188@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_1000065CC(a2, off_1007BB328[a1]);
}

void sub_1002904D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10029062C(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    __int128 v4 = (void *)sub_100024A24(v3);
    operator delete(v4);
  }

void sub_100290B10( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31, uint64_t a32, uint64_t a33, uint64_t a34)
{
  _Unwind_Resume(a1);
}

void sub_100290DAC(_Unwind_Exception *a1)
{
  id v5 = v3;

  _Unwind_Resume(a1);
}

void sub_100290E8C(_Unwind_Exception *a1)
{
  __int128 v4 = v3;

  _Unwind_Resume(a1);
}

void sub_100290F10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100291018( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_100291180(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002915E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100291854(_Unwind_Exception *a1)
{
  __int128 v6 = v4;

  _Unwind_Resume(a1);
}

void sub_100291A14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100291C48( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_100291D24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100291DC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100291FC0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100291FFC(uint64_t a1)
{
  v5.receiver = *(id *)(a1 + 32);
  v5.super_class = (Class)&OBJC_CLASS____NIServerTestWiFiOnlySession;
  id v2 = objc_msgSendSuper2(&v5, "resourcesManager");
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  __int128 v4 = (void *)objc_claimAutoreleasedReturnValue([v3 remote]);
  [v4 uwbSessionDidFailWithError:*(void *)(a1 + 40)];
}

void sub_10029206C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100292160(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002922C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002923DC(uint64_t a1)
{
  if (*(_BYTE *)(*(void *)(a1 + 32) + 64LL))
  {
    v5.receiver = *(id *)(a1 + 32);
    v5.super_class = (Class)&OBJC_CLASS____NIServerTestWiFiOnlySession;
    id v2 = objc_msgSendSuper2(&v5, "resourcesManager");
    uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
    __int128 v4 = (void *)objc_claimAutoreleasedReturnValue([v3 remote]);
    [v4 didUpdateNearbyObjects:*(void *)(a1 + 40)];
  }

void sub_10029245C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100292540(uint64_t a1)
{
  return a1;
}

void sub_100292568(id *a1)
{
}

void *sub_100292590(uint64_t a1)
{
  id v2 = operator new(0x10uLL);
  void *v2 = off_1007BB0F8;
  v2[1] = *(id *)(a1 + 8);
  return v2;
}

id sub_1002925D4(uint64_t a1, void *a2)
{
  *a2 = off_1007BB0F8;
  id result = *(id *)(a1 + 8);
  a2[1] = result;
  return result;
}

void sub_100292608(uint64_t a1)
{
}

void sub_100292610(id *a1)
{
}

id sub_100292638(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 8) wifiRangingRangeResults:a2];
}

uint64_t sub_100292644(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100292680()
{
  return &off_1007BB158;
}

uint64_t sub_10029268C(uint64_t a1)
{
  return a1;
}

void sub_1002926B4(id *a1)
{
}

void *sub_1002926DC(uint64_t a1)
{
  id v2 = operator new(0x10uLL);
  void *v2 = off_1007BB178;
  v2[1] = *(id *)(a1 + 8);
  return v2;
}

id sub_100292720(uint64_t a1, void *a2)
{
  *a2 = off_1007BB178;
  id result = *(id *)(a1 + 8);
  a2[1] = result;
  return result;
}

void sub_100292754(uint64_t a1)
{
}

void sub_10029275C(id *a1)
{
}

id sub_100292784(uint64_t a1, int *a2)
{
  int v3 = *a2;
  return [*(id *)(a1 + 8) wifiRangingRangeError:&v3];
}

uint64_t sub_1002927B0(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_1002927EC()
{
  return &off_1007BB1D8;
}

uint64_t sub_1002927F8(uint64_t a1)
{
  return a1;
}

void sub_100292820(id *a1)
{
}

void *sub_100292848(uint64_t a1)
{
  id v2 = operator new(0x10uLL);
  void *v2 = off_1007BB1F8;
  v2[1] = *(id *)(a1 + 8);
  return v2;
}

id sub_10029288C(uint64_t a1, void *a2)
{
  *a2 = off_1007BB1F8;
  id result = *(id *)(a1 + 8);
  a2[1] = result;
  return result;
}

void sub_1002928C0(uint64_t a1)
{
}

void sub_1002928C8(id *a1)
{
}

id sub_1002928F0(uint64_t a1, int *a2)
{
  int v3 = *a2;
  return [*(id *)(a1 + 8) wifiRangingReadiness:&v3];
}

uint64_t sub_10029291C(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100292958()
{
  return &off_1007BB258;
}

void sub_100292964()
{
  unsigned __int8 v0 = objc_autoreleasePoolPush();
  v10[0] = xmmword_10042BC78;
  v10[1] = unk_10042BC88;
  sub_10015EABC((uint64_t)&unk_1007FDDD8, (int *)v10, 4LL);
  xmmword_1007FDDF0 = xmmword_100423CB0;
  unk_1007FDE00 = xmmword_100423CC0;
  qword_1007FDE18 = 0LL;
  unk_1007FDE20 = 0LL;
  qword_1007FDE10 = 0x3FD999999999999ALL;
  unk_1007FDE28 = xmmword_100423CD0;
  dword_1007FDE38 = 5;
  qword_1007FDE40 = 0x4000000000000000LL;
  dword_1007FDE48 = 5;
  byte_1007FDE50 = 0;
  *(void *)&algn_1007FDE51[3] = 0x30000000ALL;
  xmmword_1007FDE60 = xmmword_100423CE0;
  unk_1007FDE70 = xmmword_100423CF0;
  xmmword_1007FDE80 = xmmword_100423D00;
  qword_1007FDE90 = 0x3FE3333333333333LL;
  dword_1007FDE98 = 3;
  xmmword_1007FDEA0 = xmmword_100423D10;
  unk_1007FDEB0 = xmmword_100423CF0;
  xmmword_1007FDEC0 = xmmword_100423CE0;
  qword_1007FDED0 = 0x3FE3333333333333LL;
  byte_1007FDED8 = 0;
  xmmword_1007FDEE0 = xmmword_100423D20;
  unk_1007FDEF0 = xmmword_100423D30;
  __asm { FMOV            V0.2D, #1.0 }

  __int128 v8 = _Q0;
  xmmword_1007FDF00 = _Q0;
  qword_1007FDF10 = 0xBFD3333333333333LL;
  xmmword_1007FDF18 = xmmword_100423D40;
  qword_1007FDF28 = 0x3E99999A40000000LL;
  xmmword_1007FDF30 = xmmword_100423CC0;
  qword_1007FDF48 = 0LL;
  unk_1007FDF50 = 0LL;
  qword_1007FDF40 = 0x3FD999999999999ALL;
  xmmword_1007FDF58 = xmmword_100423CD0;
  dword_1007FDF68 = 5;
  qword_1007FDF70 = 0x4000000000000000LL;
  dword_1007FDF78 = 4;
  qword_1007FDF80 = 0x300000008LL;
  qword_1007FDF88 = 0xC04E800000000000LL;
  unint64_t v9 = 0xC04E800000000000LL;
  sub_10015ED64((uint64_t)&unk_1007FDF90, (double *)&v9, 1LL);
  xmmword_1007FDFA8 = xmmword_100423D50;
  qword_1007FDFB8 = 0x4024000000000000LL;
  dword_1007FDFC0 = 45;
  byte_1007FDFC8 = 0;
  byte_1007FDFE0 = 0;
  qword_1007FDFE8 = 0LL;
  byte_1007FDFF0 = 0;
  dword_1007FDFF4 = 1;
  byte_1007FDFF8 = 1;
  xmmword_1007FE000 = xmmword_100423D60;
  unk_1007FE010 = xmmword_100423D70;
  xmmword_1007FE020 = v8;
  qword_1007FE030 = 0xC059000000000000LL;
  xmmword_1007FE038 = xmmword_100423D80;
  qword_1007FE048 = (uint64_t)vdup_n_s32(0x3DCCCCCDu);
  xmmword_1007FE050 = xmmword_100423CC0;
  qword_1007FE060 = 0x3FD999999999999ALL;
  qword_1007FE070 = 0LL;
  qword_1007FE068 = 0LL;
  xmmword_1007FE078 = xmmword_100423CD0;
  dword_1007FE088 = 5;
  qword_1007FE090 = 0x4000000000000000LL;
  dword_1007FE098 = 10;
  qword_1007FE0A0 = 0x4034000000000000LL;
  dword_1007FE0A8 = 3;
  xmmword_1007FE0B0 = xmmword_100423D90;
  __cxa_atexit((void (*)(void *))sub_10015CF8C, &unk_1007FDDD8, (void *)&_mh_execute_header);
  qword_1007FE0C8 = 0LL;
  unk_1007FE0D0 = 0LL;
  qword_1007FE0C0 = 0LL;
  __int128 v6 = operator new(0x40uLL);
  qword_1007FE0C8 = (uint64_t)(v6 + 4);
  unk_1007FE0D0 = v6 + 4;
  _OWORD *v6 = xmmword_10042BC98;
  v6[1] = unk_10042BCA8;
  v6[2] = xmmword_10042BCB8;
  void v6[3] = unk_10042BCC8;
  qword_1007FE0C0 = (uint64_t)v6;
  __cxa_atexit((void (*)(void *))sub_100028CC4, &qword_1007FE0C0, (void *)&_mh_execute_header);
  qword_1007FE0E0 = 0LL;
  unk_1007FE0E8 = 0LL;
  qword_1007FE0D8 = 0LL;
  char v7 = operator new(0x10uLL);
  qword_1007FE0E0 = (uint64_t)(v7 + 1);
  unk_1007FE0E8 = v7 + 1;
  *char v7 = xmmword_10042BCD8;
  qword_1007FE0D8 = (uint64_t)v7;
  __cxa_atexit((void (*)(void *))sub_100028CC4, &qword_1007FE0D8, (void *)&_mh_execute_header);
  objc_autoreleasePoolPop(v0);
}

void sub_100292CC4(_Unwind_Exception *a1)
{
}

void sub_100292D58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100292EA4(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1002930E0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  os_unfair_lock_unlock(v14);
  _Unwind_Resume(a1);
}

void sub_10029311C(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  double v5 = *(double *)(a1 + 40);
  [v4 timestamp];
  if (v5 - v6 <= *(double *)(a1 + 48))
  {
    [*(id *)(a1 + 32) addObject:v4];
  }

  else
  {
    char v7 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 138412290;
      id v9 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "#recent-obj-cache,Result too old: %@",  (uint8_t *)&v8,  0xCu);
    }
  }
}

void sub_1002931F8(_Unwind_Exception *exception_object)
{
}

int64_t sub_100293210(id a1, NINearbyObject *a2, NINearbyObject *a3)
{
  id v4 = a3;
  -[NINearbyObject distance](a2, "distance");
  float v6 = v5;
  -[NINearbyObject distance](v4, "distance");
  if (v6 < v7) {
    int64_t v8 = -1LL;
  }
  else {
    int64_t v8 = v6 > v7;
  }

  return v8;
}

void sub_100293264(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_1002932F0()
{
  unsigned __int8 v0 = (void *)objc_claimAutoreleasedReturnValue( +[NSXPCInterface interfaceWithProtocol:]( &OBJC_CLASS___NSXPCInterface,  "interfaceWithProtocol:",  &OBJC_PROTOCOL___UWBSessionServerProtocol));
  uint64_t v1 = objc_alloc(&OBJC_CLASS___NSSet);
  uint64_t v3 = objc_opt_class(&OBJC_CLASS___NSDictionary, v2);
  uint64_t v5 = objc_opt_class(&OBJC_CLASS___NSString, v4);
  v152 = -[NSSet initWithObjects:](v1, "initWithObjects:", v3, v5, objc_opt_class(&OBJC_CLASS___NSNumber, v6), 0LL);
  objc_msgSend(v0, "setClasses:forSelector:argumentIndex:ofReply:");
  float v7 = objc_alloc(&OBJC_CLASS___NSSet);
  uint64_t v9 = objc_opt_class(&OBJC_CLASS___NSDictionary, v8);
  uint64_t v11 = objc_opt_class(&OBJC_CLASS___NSData, v10);
  uint64_t v13 = objc_opt_class(&OBJC_CLASS___NSString, v12);
  v151 = -[NSSet initWithObjects:]( v7,  "initWithObjects:",  v9,  v11,  v13,  objc_opt_class(&OBJC_CLASS___NSNumber, v14),  0LL);
  objc_msgSend(v0, "setClasses:forSelector:argumentIndex:ofReply:");
  float v15 = objc_alloc(&OBJC_CLASS___NSSet);
  uint64_t v17 = objc_opt_class(&OBJC_CLASS___NSDictionary, v16);
  uint64_t v19 = objc_opt_class(&OBJC_CLASS___NSString, v18);
  v150 = -[NSSet initWithObjects:](v15, "initWithObjects:", v17, v19, objc_opt_class(&OBJC_CLASS___NSNumber, v20), 0LL);
  objc_msgSend(v0, "setClasses:forSelector:argumentIndex:ofReply:");
  float v21 = objc_alloc(&OBJC_CLASS___NSMutableSet);
  uint64_t v23 = objc_opt_class(&OBJC_CLASS___NIConfiguration, v22);
  uint64_t v25 = objc_opt_class(&OBJC_CLASS___NINearbyPeerConfiguration, v24);
  uint64_t v27 = objc_opt_class(&OBJC_CLASS___NIAcwgConfiguration, v26);
  uint64_t v29 = objc_opt_class(&OBJC_CLASS___NSData, v28);
  uint64_t v31 = objc_opt_class(&OBJC_CLASS___NIDiscoveryToken, v30);
  v153 = -[NSMutableSet initWithObjects:]( v21,  "initWithObjects:",  v23,  v25,  v27,  v29,  v31,  objc_opt_class(&OBJC_CLASS___NSDictionary, v32),  0LL);
  v159[0] = objc_opt_class(&OBJC_CLASS___NIHomeDeviceConfiguration, v33);
  v159[1] = objc_opt_class(&OBJC_CLASS___NIRegionPredicate, v34);
  v159[2] = objc_opt_class(&OBJC_CLASS___NSArray, v35);
  v159[3] = objc_opt_class(&OBJC_CLASS___NSString, v36);
  v149 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v159, 4LL));
  -[NSMutableSet addObjectsFromArray:](v153, "addObjectsFromArray:");
  v158[0] = objc_opt_class(&OBJC_CLASS___NICarKeyConfiguration, v37);
  v158[1] = objc_opt_class(&OBJC_CLASS___NSDictionary, v38);
  v158[2] = objc_opt_class(&OBJC_CLASS___NSNumber, v39);
  v148 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v158, 3LL));
  -[NSMutableSet addObjectsFromArray:](v153, "addObjectsFromArray:");
  v157[0] = objc_opt_class(&OBJC_CLASS___NINearbyAccessoryConfiguration, v40);
  v157[1] = objc_opt_class(&OBJC_CLASS___NSUUID, v41);
  v157[2] = objc_opt_class(&OBJC_CLASS___NSDictionary, v42);
  v157[3] = objc_opt_class(&OBJC_CLASS___NSNumber, v43);
  v157[4] = objc_opt_class(&OBJC_CLASS___NSString, v44);
  v157[5] = objc_opt_class(&OBJC_CLASS___NSData, v45);
  v144 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v157, 6LL));
  -[NSMutableSet addObjectsFromArray:](v153, "addObjectsFromArray:");
  v156[0] = objc_opt_class(&OBJC_CLASS___NIDevicePresenceConfiguration, v46);
  v156[1] = objc_opt_class(&OBJC_CLASS___NIRegionPredicate, v47);
  v143 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v156, 2LL));
  -[NSMutableSet addObjectsFromArray:](v153, "addObjectsFromArray:");
  uint64_t v155 = objc_opt_class(&OBJC_CLASS___NIRangingAuthConfiguration, v48);
  v145 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v155, 1LL));
  -[NSMutableSet addObjectsFromArray:](v153, "addObjectsFromArray:");
  v154[0] = objc_opt_class(&OBJC_CLASS___NIFindingConfiguration, v49);
  v154[1] = objc_opt_class(&OBJC_CLASS___NIDiscoveryToken, v50);
  v154[2] = objc_opt_class(&OBJC_CLASS___NSDictionary, v51);
  v146 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v154, 3LL));
  -[NSMutableSet addObjectsFromArray:](v153, "addObjectsFromArray:");
  char v52 = objc_alloc(&OBJC_CLASS___NSSet);
  uint64_t v54 = objc_opt_class(&OBJC_CLASS____NIWiFiRangingTestConfiguration, v53);
  uint64_t v56 = objc_opt_class(&OBJC_CLASS___NSNumber, v55);
  v147 = -[NSSet initWithObjects:](v52, "initWithObjects:", v54, v56, objc_opt_class(&OBJC_CLASS___NSString, v57), 0LL);
  uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableSet setByAddingObjectsFromSet:](v153, "setByAddingObjectsFromSet:"));
  [v0 setClasses:v58 forSelector:"runWithConfiguration:reply:" argumentIndex:0 ofReply:0];

  objc_msgSend( v0,  "setClass:forSelector:argumentIndex:ofReply:",  objc_opt_class(NIDiscoveryToken, v59),  "_addObject:reply:",  0,  0);
  objc_msgSend( v0,  "setClass:forSelector:argumentIndex:ofReply:",  objc_opt_class(NIDiscoveryToken, v60),  "_removeObject:reply:",  0,  0);
  objc_msgSend( v0,  "setClass:forSelector:argumentIndex:ofReply:",  objc_opt_class(NSData, v61),  "processDCKMessage:reply:",  0,  0);
  objc_msgSend( v0,  "setClass:forSelector:argumentIndex:ofReply:",  objc_opt_class(NSData, v62),  "processDCKMessage:reply:",  0,  1);
  objc_msgSend( v0,  "setClass:forSelector:argumentIndex:ofReply:",  objc_opt_class(NSError, v63),  "processDCKMessage:reply:",  1,  1);
  objc_msgSend( v0,  "setClass:forSelector:argumentIndex:ofReply:",  objc_opt_class(NIBluetoothHostTimeSyncResponse, v64),  "processBluetoothHostTimeSyncWithType:btcClockTicks:eventCounter:reply:",  0,  1);
  objc_msgSend( v0,  "setClass:forSelector:argumentIndex:ofReply:",  objc_opt_class(NSError, v65),  "isRangingLimitExceeded:",  1,  1);
  unint64_t v66 = objc_alloc(&OBJC_CLASS___NSSet);
  uint64_t v68 = objc_opt_class(&OBJC_CLASS___NSDictionary, v67);
  uint64_t v70 = objc_opt_class(&OBJC_CLASS___NSString, v69);
  v142 = -[NSSet initWithObjects:](v66, "initWithObjects:", v68, v70, objc_opt_class(&OBJC_CLASS___NSNumber, v71), 0LL);
  objc_msgSend(v0, "setClasses:forSelector:argumentIndex:ofReply:");
  objc_msgSend( v0,  "setClass:forSelector:argumentIndex:ofReply:",  objc_opt_class(NSError, v72),  "_processCarKeyEvent:reply:",  0,  1);
  objc_msgSend( v0,  "setClass:forSelector:argumentIndex:ofReply:",  objc_opt_class(NIAcwgM1Msg, v73),  "processAcwgM1Msg:withSessionTriggerReason:",  0,  0);
  objc_msgSend( v0,  "setClass:forSelector:argumentIndex:ofReply:",  objc_opt_class(NIAcwgM3Msg, v74),  "processAcwgM3Msg:",  0,  0);
  unint64_t v75 = objc_alloc(&OBJC_CLASS___NSSet);
  uint64_t v77 = objc_opt_class(&OBJC_CLASS___NIVisionInput, v76);
  v140 = -[NSSet initWithObjects:](v75, "initWithObjects:", v77, objc_opt_class(&OBJC_CLASS___NSData, v78), 0LL);
  objc_msgSend(v0, "setClasses:forSelector:argumentIndex:ofReply:");
  char v79 = objc_alloc(&OBJC_CLASS___NSSet);
  v141 = -[NSSet initWithObjects:](v79, "initWithObjects:", objc_opt_class(&OBJC_CLASS___NSError, v80), 0LL);
  objc_msgSend(v0, "setClasses:forSelector:argumentIndex:ofReply:");
  unsigned __int8 v81 = objc_alloc(&OBJC_CLASS___NSSet);
  uint64_t v83 = objc_opt_class(&OBJC_CLASS___NIBluetoothSample, v82);
  uint64_t v85 = objc_opt_class(&OBJC_CLASS___NSString, v84);
  v139 = -[NSSet initWithObjects:](v81, "initWithObjects:", v83, v85, objc_opt_class(&OBJC_CLASS___NSData, v86), 0LL);
  objc_msgSend(v0, "setClasses:forSelector:argumentIndex:ofReply:");
  unsigned __int8 v87 = objc_alloc(&OBJC_CLASS___NSSet);
  uint64_t v89 = objc_opt_class(&OBJC_CLASS___NSArray, v88);
  uint64_t v91 = -[NSSet initWithObjects:]( v87,  "initWithObjects:",  v89,  objc_opt_class(&OBJC_CLASS___NIDiscoveryToken, v90),  0LL);
  [v0 setClasses:v91 forSelector:"setLocalDeviceCanInteract:withDiscoveryTokens:reply:" argumentIndex:1 ofReply:0];
  objc_msgSend( v0,  "setClass:forSelector:argumentIndex:ofReply:",  objc_opt_class(NSError, v92),  "setLocalDeviceCanInteract:withDiscoveryTokens:reply:",  0,  1);
  [v0 setClasses:v91 forSelector:"setLocalDeviceInteractableDiscoveryTokens:reply:" argumentIndex:0 ofReply:0];
  objc_msgSend( v0,  "setClass:forSelector:argumentIndex:ofReply:",  objc_opt_class(NSError, v93),  "setLocalDeviceInteractableDiscoveryTokens:reply:",  0,  1);
  [v0 setClasses:v91 forSelector:"getInteractableDiscoveryTokens:" argumentIndex:0 ofReply:1];
  objc_msgSend( v0,  "setClass:forSelector:argumentIndex:ofReply:",  objc_opt_class(NSError, v94),  "getInteractableDiscoveryTokens:",  1,  1);
  [v0 setClasses:v91 forSelector:"getActivelyInteractingDiscoveryTokens:" argumentIndex:0 ofReply:1];
  objc_msgSend( v0,  "setClass:forSelector:argumentIndex:ofReply:",  objc_opt_class(NSError, v95),  "getActivelyInteractingDiscoveryTokens:",  1,  1);
  __int128 v96 = objc_alloc(&OBJC_CLASS___NSSet);
  uint64_t v98 = objc_opt_class(&OBJC_CLASS___NSDictionary, v97);
  uint64_t v100 = objc_opt_class(&OBJC_CLASS___NSArray, v99);
  v138 = -[NSSet initWithObjects:]( v96,  "initWithObjects:",  v98,  v100,  objc_opt_class(&OBJC_CLASS___NSString, v101),  0LL);
  objc_msgSend(v0, "setClasses:forSelector:argumentIndex:ofReply:");
  objc_msgSend( v0,  "setClass:forSelector:argumentIndex:ofReply:",  objc_opt_class(NSError, v102),  "getLocalDevicePrintableState:",  1,  1);
  uint64_t v103 = objc_alloc(&OBJC_CLASS___NSSet);
  uint64_t v105 = objc_opt_class(&OBJC_CLASS___NSDictionary, v104);
  uint64_t v107 = objc_opt_class(&OBJC_CLASS___NIDiscoveryToken, v106);
  uint64_t v109 = objc_opt_class(&OBJC_CLASS___NILocation, v108);
  uint64_t v111 = objc_opt_class(&OBJC_CLASS___NIHeading, v110);
  uint64_t v113 = objc_opt_class(&OBJC_CLASS___NSDate, v112);
  uint64_t v115 = objc_opt_class(&OBJC_CLASS___NSData, v114);
  uint64_t v117 = objc_opt_class(&OBJC_CLASS___NSString, v116);
  v119 = -[NSSet initWithObjects:]( v103,  "initWithObjects:",  v105,  v107,  v109,  v111,  v113,  v115,  v117,  objc_opt_class(&OBJC_CLASS___NSNumber, v118),  0LL);
  [v0 setClasses:v119 forSelector:"_processFindingEvent:reply:" argumentIndex:0 ofReply:0];
  objc_msgSend( v0,  "setClass:forSelector:argumentIndex:ofReply:",  objc_opt_class(NSError, v120),  "_processFindingEvent:reply:",  0,  1);
  v121 = objc_alloc(&OBJC_CLASS___NSSet);
  uint64_t v123 = objc_opt_class(&OBJC_CLASS___NSDictionary, v122);
  uint64_t v125 = objc_opt_class(&OBJC_CLASS___NSString, v124);
  v127 = -[NSSet initWithObjects:]( v121,  "initWithObjects:",  v123,  v125,  objc_opt_class(&OBJC_CLASS___NSNumber, v126),  0LL);
  [v0 setClasses:v127 forSelector:"setLocalDeviceDebugParameters:reply:" argumentIndex:0 ofReply:0];
  objc_msgSend( v0,  "setClass:forSelector:argumentIndex:ofReply:",  objc_opt_class(NSError, v128),  "setLocalDeviceDebugParameters:reply:",  0,  1);
  v129 = objc_alloc(&OBJC_CLASS___NSSet);
  uint64_t v131 = objc_opt_class(&OBJC_CLASS___NSDictionary, v130);
  uint64_t v133 = objc_opt_class(&OBJC_CLASS___NSString, v132);
  v135 = -[NSSet initWithObjects:]( v129,  "initWithObjects:",  v131,  v133,  objc_opt_class(&OBJC_CLASS___NSNumber, v134),  0LL);
  [v0 setClasses:v135 forSelector:"_processSystemEvent:reply:" argumentIndex:0 ofReply:0];
  objc_msgSend( v0,  "setClass:forSelector:argumentIndex:ofReply:",  objc_opt_class(NSError, v136),  "_processSystemEvent:reply:",  0,  1);

  return v0;
}

void sub_100293F64( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20, void *a21, void *a22, void *a23, void *a24, void *a25, void *a26, void *a27, void *a28, void *a29, void *a30, void *a31, void *a32, void *a33)
{
  _Unwind_Resume(a1);
}

id sub_100294100()
{
  unsigned __int8 v0 = (void *)objc_claimAutoreleasedReturnValue( +[NSXPCInterface interfaceWithProtocol:]( &OBJC_CLASS___NSXPCInterface,  "interfaceWithProtocol:",  &OBJC_PROTOCOL___UWBSessionDelegateProxyProtocol));
  objc_msgSend( v0,  "setClass:forSelector:argumentIndex:ofReply:",  objc_opt_class(NIDiscoveryToken, v1),  "didUpdateLocalDiscoveryToken:",  0,  0);
  objc_msgSend( v0,  "setClass:forSelector:argumentIndex:ofReply:",  objc_opt_class(NSError, v2),  "uwbSessionDidInvalidateWithError:",  0,  0);
  objc_msgSend( v0,  "setClass:forSelector:argumentIndex:ofReply:",  objc_opt_class(NSError, v3),  "uwbSessionDidFailWithError:",  0,  0);
  uint64_t v4 = objc_alloc(&OBJC_CLASS___NSSet);
  uint64_t v6 = objc_opt_class(&OBJC_CLASS___NSArray, v5);
  uint64_t v8 = objc_opt_class(&OBJC_CLASS___NINearbyObject, v7);
  uint64_t v10 = objc_opt_class(&OBJC_CLASS___NIDiscoveryToken, v9);
  uint64_t v12 = objc_opt_class(&OBJC_CLASS___NSData, v11);
  uint64_t v14 = objc_opt_class(&OBJC_CLASS___NSString, v13);
  uint64_t v16 = -[NSSet initWithObjects:]( v4,  "initWithObjects:",  v6,  v8,  v10,  v12,  v14,  objc_opt_class(&OBJC_CLASS___NSUUID, v15),  0LL);
  [v0 setClasses:v16 forSelector:"didUpdateNearbyObjects:" argumentIndex:0 ofReply:0];
  [v0 setClasses:v16 forSelector:"didRemoveNearbyObjects:withReason:" argumentIndex:0 ofReply:0];
  objc_msgSend( v0,  "setClass:forSelector:argumentIndex:ofReply:",  objc_opt_class(NINearbyObject, v17),  "didDiscoverNearbyObject:",  0,  0);
  objc_msgSend( v0,  "setClass:forSelector:argumentIndex:ofReply:",  objc_opt_class(NINearbyObject, v18),  "object:didUpdateRegion:previousRegion:",  0,  0);
  objc_msgSend( v0,  "setClass:forSelector:argumentIndex:ofReply:",  objc_opt_class(NIRegionPredicate, v19),  "object:didUpdateRegion:previousRegion:",  1,  0);
  objc_msgSend( v0,  "setClass:forSelector:argumentIndex:ofReply:",  objc_opt_class(NIRegionPredicate, v20),  "object:didUpdateRegion:previousRegion:",  2,  0);
  objc_msgSend( v0,  "setClass:forSelector:argumentIndex:ofReply:",  objc_opt_class(NSData, v21),  "relayDCKMessage:",  0,  0);
  objc_msgSend( v0,  "setClass:forSelector:argumentIndex:ofReply:",  objc_opt_class(NIAcwgM2Msg, v22),  "didProcessAcwgM1MsgWithResponse:error:",  0,  0);
  objc_msgSend( v0,  "setClass:forSelector:argumentIndex:ofReply:",  objc_opt_class(NIAcwgM4Msg, v23),  "didProcessAcwgM3MsgWithResponse:error:",  0,  0);
  objc_msgSend( v0,  "setClass:forSelector:argumentIndex:ofReply:",  objc_opt_class(0x1007F0000, v24),  "didProcessAcwgRangingSessionResumeRequestMsgWithResponse:error:",  0,  0);
  objc_msgSend( v0,  "setClass:forSelector:argumentIndex:ofReply:",  objc_opt_class(NINearbyObject, v25),  "didReceiveRangingAuthRecommendation:forObject:",  1,  0);
  objc_msgSend( v0,  "setClass:forSelector:argumentIndex:ofReply:",  objc_opt_class(NIAlgorithmConvergenceState, v26),  "didUpdateAlgorithmState:forObject:",  0,  0);
  objc_msgSend( v0,  "setClass:forSelector:argumentIndex:ofReply:",  objc_opt_class(NINearbyObject, v27),  "didUpdateAlgorithmState:forObject:",  1,  0);
  objc_msgSend( v0,  "setClass:forSelector:argumentIndex:ofReply:",  objc_opt_class(NISystemState, v28),  "systemDidUpdateState:",  0,  0);
  objc_msgSend( v0,  "setClass:forSelector:argumentIndex:ofReply:",  objc_opt_class(NSString, v29),  "systemDidUpdateResourceUsageLimitExceeded:forSessionConfigurationTypeWithName:",  1,  0);

  return v0;
}

void sub_10029447C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

CFStringRef sub_10029449C(unint64_t a1)
{
  if (a1 > 7) {
    return @"AirplaneModeActive";
  }
  else {
    return *(&off_1007BB3B0 + a1);
  }
}

CFStringRef sub_1002944C0(uint64_t a1)
{
  uint64_t v1 = @"Timeout";
  if (a1 == 1) {
    uint64_t v1 = @"PeerEnded";
  }
  if (a1 == 2) {
    return @"LocalForceRemoved";
  }
  else {
    return v1;
  }
}

uint64_t sub_1002944EC(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  *(void *)a1 = v5;
  sub_10001E914((uint64_t)v9, a3);
  sub_100294D4C(a1 + 8, (uint64_t)v9);
  uint64_t v6 = v10;
  if (v10 == v9)
  {
    uint64_t v7 = 4LL;
    uint64_t v6 = v9;
  }

  else
  {
    if (!v10) {
      goto LABEL_6;
    }
    uint64_t v7 = 5LL;
  }

  (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_6:
  *(void *)(a1 + 64) = 850045863LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  *(_BYTE *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(void *)(a1 + 120) = 0LL;
  if (!*(void *)(a1 + 32)) {
    __assert_rtn("PRWifiIsoMonitor", "PRWifiIsoMonitor.mm", 44, "fOnIsoCountryChange");
  }

  return a1;
}

void sub_100294610( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  uint64_t v17 = a13;
  if (a13 == v15)
  {
    uint64_t v18 = 4LL;
    uint64_t v17 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v18 = 5LL;
  }

  (*(void (**)(char *))(*(void *)v17 + 8 * v18))(v17);
LABEL_6:

  _Unwind_Resume(a1);
}

uint64_t sub_1002946AC(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  *(void *)(a1 + 40) = 0LL;

  std::mutex::~mutex((std::mutex *)(a1 + 64));
  uint64_t v3 = *(void **)(a1 + 32);
  if (v3 == (void *)(a1 + 8))
  {
    uint64_t v4 = 4LL;
    uint64_t v3 = (void *)(a1 + 8);
    goto LABEL_5;
  }

  if (v3)
  {
    uint64_t v4 = 5LL;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  return a1;
}

void sub_100294730(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 64);
  std::mutex::lock((std::mutex *)(a1 + 64));
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) countryCode]);
  uint64_t v4 = (os_log_s *)qword_1007FE0F0;
  if (v3)
  {
    if (os_log_type_enabled((os_log_t)qword_1007FE0F0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v28 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#regulatory,wifiIso,queryCountryCode countryCode:%@",  buf,  0xCu);
    }

    if ([v3 isEqualToString:@"XZ"])
    {
      id v5 = (os_log_s *)qword_1007FE0F0;
      if (os_log_type_enabled((os_log_t)qword_1007FE0F0, OS_LOG_TYPE_ERROR)) {
        sub_1003A53AC(v5, v6, v7, v8, v9, v10, v11, v12);
      }
    }

    else if (([v3 isEqualToString:@"X0"] & 1) != 0 {
           || ([v3 isEqualToString:@"X2"] & 1) != 0
    }
           || [v3 isEqualToString:@"X0"])
    {
      uint64_t v20 = (os_log_s *)qword_1007FE0F0;
      if (os_log_type_enabled((os_log_t)qword_1007FE0F0, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "#regulatory,wifiIso,queryCountryCode unknown countryCode, dropping",  buf,  2u);
      }
    }

    else
    {
      if (!*(_BYTE *)(a1 + 56))
      {
        double v21 = floor(sub_100023CC4() - *(double *)(a1 + 48));
        v26[0] = _NSConcreteStackBlock;
        v26[1] = 3221225472LL;
        v26[2] = sub_1002949A0;
        v26[3] = &unk_1007B5580;
        *(double *)&v26[4] = v21;
        AnalyticsSendEventLazy(@"com.apple.rose.regulatory.wifi.isosearchtime", v26);
        *(_BYTE *)(a1 + 56) = 1;
      }

      uint64_t v22 = *(dispatch_queue_s **)a1;
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_100294A5C;
      block[3] = &unk_1007B14E0;
      uint64_t v25 = a1;
      id v24 = v3;
      dispatch_async(v22, block);
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1007FE0F0, OS_LOG_TYPE_ERROR))
  {
    sub_1003A537C(v4, v13, v14, v15, v16, v17, v18, v19);
  }

  std::mutex::unlock(v2);
}

void sub_100294974(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

id sub_1002949A0(uint64_t a1)
{
  uint64_t v4 = @"WiFiSearchTime";
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  (int)*(double *)(a1 + 32)));
  id v5 = v1;
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v5,  &v4,  1LL));

  return v2;
}

void sub_100294A44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100294A5C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  sub_1000065CC(__p, (char *)[*(id *)(a1 + 32) UTF8String]);
  uint64_t v2 = *(void *)(v1 + 32);
  if (!v2) {
    sub_10001EEF0();
  }
  (*(void (**)(uint64_t, void **))(*(void *)v2 + 48LL))(v2, __p);
  if (v4 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100294AC4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100294AE0(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1007FE0F0;
  if (os_log_type_enabled((os_log_t)qword_1007FE0F0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#regulatory,wifiIso,startMonitoring", buf, 2u);
  }

  *(double *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = sub_100023CC4();
  id v3 = objc_alloc_init(&OBJC_CLASS___CWFInterface);
  char v4 = *(void **)(a1 + 40);
  *(void *)(a1 + 40) = v3;

  [*(id *)(a1 + 40) setInvalidationHandler:&stru_1007BB3F0];
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472LL;
  _OWORD v10[2] = sub_100294C68;
  v10[3] = &unk_1007BB410;
  v10[4] = a1;
  [*(id *)(a1 + 40) setEventHandler:v10];
  [*(id *)(a1 + 40) activate];
  id v5 = *(void **)(a1 + 40);
  id v9 = 0LL;
  [v5 startMonitoringEventType:4 error:&v9];
  id v6 = v9;
  if (v6)
  {
    uint64_t v7 = (os_log_s *)qword_1007FE0F0;
    if (os_log_type_enabled((os_log_t)qword_1007FE0F0, OS_LOG_TYPE_ERROR)) {
      sub_1003A53DC((uint64_t)v6, v7);
    }
  }

  sub_100294730(a1);

  return 1LL;
}

void sub_100294C1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100294C2C(id a1)
{
  uint64_t v1 = (os_log_s *)qword_1007FE0F0;
  if (os_log_type_enabled((os_log_t)qword_1007FE0F0, OS_LOG_TYPE_DEBUG)) {
    sub_1003A5450(v1);
  }
}

void sub_100294C68(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(void *)(a1 + 32);
  id v5 = (os_log_s *)qword_1007FE0F0;
  if (os_log_type_enabled((os_log_t)qword_1007FE0F0, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 138412290;
    id v7 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "#regulatory,wifiIso,startMonitoring eventHandler event = %@",  (uint8_t *)&v6,  0xCu);
  }

  if ([v3 type] == (id)4) {
    sub_100294730(v4);
  }
}

void sub_100294D34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100294D4C(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 24) = 0LL;
  if (*(void *)(a2 + 24))
  {
    uint64_t v4 = operator new(0x28uLL);
    *uint64_t v4 = &off_1007BB440;
    sub_100294FD4((uint64_t)(v4 + 1), a2);
    *(void *)(a1 + 24) = v4;
  }

  return a1;
}

void *sub_100294DAC(void *a1)
{
  *a1 = &off_1007BB440;
  uint64_t v2 = a1 + 1;
  id v3 = (void *)a1[4];
  if (v3 == v2)
  {
    uint64_t v4 = 4LL;
    id v3 = v2;
    goto LABEL_5;
  }

  if (v3)
  {
    uint64_t v4 = 5LL;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  return a1;
}

void sub_100294E0C(char *__p)
{
  *(void *)__int128 __p = &off_1007BB440;
  uint64_t v2 = __p + 8;
  id v3 = (char *)*((void *)__p + 4);
  if (v3 == v2)
  {
    uint64_t v4 = 4LL;
    id v3 = v2;
    goto LABEL_5;
  }

  if (v3)
  {
    uint64_t v4 = 5LL;
LABEL_5:
    (*(void (**)(void))(*(void *)v3 + 8 * v4))();
  }

  operator delete(__p);
}

void *sub_100294E6C(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x28uLL);
  void *v2 = &off_1007BB440;
  sub_10001E914((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_100294EB0(_Unwind_Exception *a1)
{
}

uint64_t sub_100294EC4(uint64_t a1, void *a2)
{
  *a2 = &off_1007BB440;
  return sub_10001E914((uint64_t)(a2 + 1), a1 + 8);
}

void *sub_100294EE4(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 8);
  id result = *(void **)(a1 + 32);
  if (result == v1)
  {
    uint64_t v3 = 4LL;
    id result = v1;
  }

  else
  {
    if (!result) {
      return result;
    }
    uint64_t v3 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void sub_100294F18(char *__p)
{
  uint64_t v2 = __p + 8;
  uint64_t v3 = (char *)*((void *)__p + 4);
  if (v3 == v2)
  {
    uint64_t v4 = 4LL;
    uint64_t v3 = v2;
    goto LABEL_5;
  }

  if (v3)
  {
    uint64_t v4 = 5LL;
LABEL_5:
    (*(void (**)(void))(*(void *)v3 + 8 * v4))();
  }

  operator delete(__p);
}

uint64_t sub_100294F68(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!v1) {
    sub_10001EEF0();
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 48LL))(v1);
}

uint64_t sub_100294F8C(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100294FC8()
{
}

uint64_t sub_100294FD4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24LL))(*v3, a1);
      return a1;
    }

    *(void *)(a1 + 24) = v4;
  }

  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }

  *uint64_t v3 = 0LL;
  return a1;
}

void sub_100295038()
{
  unsigned __int8 v0 = objc_autoreleasePoolPush();
  qword_1007FE0F0 = (uint64_t)os_log_create("com.apple.nearbyd", "Regulatory");
  objc_autoreleasePoolPop(v0);
}

void *sub_100295078@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_1000065CC(a2, (&off_1007BB8B0)[a1]);
}

void *sub_10029508C@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_1000065CC(a2, (&off_1007BB908)[a1]);
}

void *sub_1002950A0@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_1000065CC(a2, (&off_1007BB950)[a1]);
}

void *sub_1002950B4@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_1000065CC(a2, (&off_1007BB970)[a1]);
}

uint64_t sub_1002950C8(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  *(void *)a1 = off_1007BB530;
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = off_1007BB5F8;
  *(void *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 24) = *((_DWORD *)sub_100005150() + 144);
  id v6 = v5;
  *(void *)(a1 + 32) = v6;
  *(void *)(a1 + 40) = dispatch_queue_create("com.apple.nearbyd.regulatory", 0LL);
  sub_10025A90C(a1 + 48);
  *(_BYTE *)(a1 + 272) = 0;
  id v7 = *(void **)(a1 + 40);
  v30[0] = &off_1007BB730;
  v30[1] = a1;
  uint64_t v31 = v30;
  v28[0] = &off_1007BB7B0;
  v28[1] = a1;
  uint64_t v29 = v28;
  v26[0] = &off_1007BB830;
  v26[1] = a1;
  uint64_t v27 = v26;
  sub_1001A8974(a1 + 280, v7, (uint64_t)v30, (uint64_t)v28, (uint64_t)v26);
  uint64_t v8 = v27;
  if (v27 == v26)
  {
    uint64_t v9 = 4LL;
    uint64_t v8 = v26;
  }

  else
  {
    if (!v27) {
      goto LABEL_6;
    }
    uint64_t v9 = 5LL;
  }

  (*(void (**)(void))(*v8 + 8 * v9))();
LABEL_6:
  uint64_t v10 = v29;
  if (v29 == v28)
  {
    uint64_t v11 = 4LL;
    uint64_t v10 = v28;
  }

  else
  {
    if (!v29) {
      goto LABEL_11;
    }
    uint64_t v11 = 5LL;
  }

  (*(void (**)(void))(*v10 + 8 * v11))();
LABEL_11:
  uint64_t v12 = v31;
  if (v31 == v30)
  {
    uint64_t v13 = 4LL;
    uint64_t v12 = v30;
    goto LABEL_15;
  }

  if (v31)
  {
    uint64_t v13 = 5LL;
LABEL_15:
    (*(void (**)(void))(*v12 + 8 * v13))();
  }

  *(void *)(a1 + 2160) = -[PRSystemSettingsMonitor initWithQueue:]( objc_alloc(&OBJC_CLASS___PRSystemSettingsMonitor),  "initWithQueue:",  *(void *)(a1 + 40));
  *(_OWORD *)(a1 + 216_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  uint64_t v14 = *(dispatch_queue_s **)(a1 + 40);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1002954E0;
  block[3] = &unk_1007A2398;
  void block[4] = a1;
  dispatch_sync(v14, block);
  uint64_t v15 = (os_log_s *)(id)qword_1007FE0F8;
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    sub_10032062C(*(unsigned int *)(a1 + 24), &__p);
    uint64_t v16 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0
        ? &__p
        : (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 136315138;
    uint64_t v25 = v16;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "#reg-prov,initialized,fDeviceType=%s",  buf,  0xCu);
  }

  if ((sub_1001CDBE0() & 1) != 0
    || (uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](&OBJC_CLASS___NSUserDefaults, "standardUserDefaults")),
        unsigned int v18 = [v17 BOOLForKey:@"EnableStateDump"],
        v17,
        v18))
  {
    uint64_t v19 = *(void *)(a1 + 40);
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 3221225472LL;
    v21[2] = sub_1002955B4;
    v21[3] = &unk_1007BA868;
    v21[4] = a1;
    os_state_add_handler(v19, v21);
  }

  return a1;
}

void sub_1002953CC(_Unwind_Exception *a1)
{
  sub_1001A8B6C(v4);
  sub_1002957FC(v3);

  _Unwind_Resume(a1);
}

BOOL sub_1002954E0(uint64_t a1)
{
  return sub_1002954E8(*(void *)(a1 + 32));
}

BOOL sub_1002954E8(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 272)) {
    return 1LL;
  }
  uint64_t v4 = (os_log_s *)qword_1007FE0F8;
  if (os_log_type_enabled((os_log_t)qword_1007FE0F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v6 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#reg-prov,regulatory provider processing device unlocked since boot",  v6,  2u);
  }

  id v5 = sub_1001A8438();
  sub_1001A8B70(a1 + 280);
  sub_10034CE4C((uint64_t)v5);
  sub_1001AC368(a1 + 280);
  BOOL result = 1LL;
  *(_BYTE *)(a1 + 272) = 1;
  return result;
}

char *sub_1002955B4(uint64_t a1)
{
  uint64_t v1 = sub_100295608(*(void *)(a1 + 32));
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(v1);
  uint64_t v3 = sub_100024190(@"PRRegulatoryProvider", v2);

  return v3;
}

void sub_1002955F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NSMutableArray *sub_100295608(uint64_t a1)
{
  uint64_t v2 = objc_opt_new(&OBJC_CLASS___NSMutableArray);
  uint64_t v3 = objc_autoreleasePoolPush();
  -[NSMutableArray addObject:](v2, "addObject:", @"GeoMonitor");
  uint64_t v4 = sub_1001AC960(a1 + 280);
  id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 3221225472LL;
  void v16[2] = sub_100297A08;
  v16[3] = &unk_1007B2298;
  id v6 = v2;
  uint64_t v17 = v6;
  [v5 enumerateObjectsUsingBlock:v16];
  -[NSMutableArray addObject:](v6, "addObject:", @"Settings");
  id v7 = sub_10025CB7C(a1 + 48);
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(v7);

  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472LL;
  uint64_t v14[2] = sub_100297A70;
  v14[3] = &unk_1007B2298;
  uint64_t v9 = v6;
  uint64_t v15 = v9;
  [v8 enumerateObjectsUsingBlock:v14];
  if (*(void *)(a1 + 2168))
  {
    -[NSMutableArray addObject:](v9, "addObject:", @"Narrowband SAR");
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 2168) printableStateOnQueue]);

    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472LL;
    v12[2] = sub_100297AD8;
    v12[3] = &unk_1007B2298;
    uint64_t v13 = v9;
    [v10 enumerateObjectsUsingBlock:v12];
  }

  else
  {
    uint64_t v10 = v8;
  }

  objc_autoreleasePoolPop(v3);
  return v9;
}

void sub_1002957A4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, void *a24)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1002957FC(uint64_t a1)
{
  return a1;
}

uint64_t sub_100295868(uint64_t a1)
{
  *(void *)a1 = off_1007BB530;
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = off_1007BB5F8;

  sub_1001A8B6C(a1 + 280);
  std::mutex::~mutex((std::mutex *)(a1 + 200));
  sub_100034A98(a1 + 176, *(void **)(a1 + 184));
  sub_100124FB0(a1 + 152, *(void **)(a1 + 160));
  sub_100034A98(a1 + 128, *(void **)(a1 + 136));
  sub_100124FB0(a1 + 104, *(void **)(a1 + 112));

  return a1;
}

uint64_t sub_100295914(uint64_t a1)
{
  return sub_100295868(a1 - 8);
}

void sub_10029591C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100295868(a1);
  operator delete(v1);
}

void sub_100295930(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100295868(a1 - 8);
  operator delete(v1);
}

id sub_100295948(uint64_t a1)
{
  uint64_t v2 = a1 + 280;
  sub_1001A8B78(a1 + 280);
  sub_100295B40((void *)a1);
  uint64_t v3 = *(void **)(a1 + 2160);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472LL;
  v12[2] = sub_100295C50;
  v12[3] = &unk_1007BB670;
  void v12[4] = a1;
  [v3 setAirplaneModeChangedHandler:v12];
  uint64_t v4 = *(void **)(a1 + 2168);
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472LL;
  v11[2] = sub_100295DD0;
  v11[3] = &unk_1007BB690;
  v11[4] = a1;
  [v4 setStateChangeHandler:v11];
  if (!sub_1003206F4(*(_DWORD *)(a1 + 24)))
  {
    id v7 = (os_log_s *)qword_1007FE0F8;
    if (os_log_type_enabled((os_log_t)qword_1007FE0F8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "#reg-prov,fGeoMonitor startMonitoring,skipped,device does not support UWB.",  buf,  2u);
    }

    goto LABEL_8;
  }

  unsigned int v5 = sub_1001A9058(v2);
  id v6 = (os_log_s *)qword_1007FE0F8;
  if (os_log_type_enabled((os_log_t)qword_1007FE0F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    unsigned int v14 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#reg-prov,fGeoMonitor startMonitoring completed, status, %d",  buf,  8u);
  }

  if (v5) {
LABEL_8:
  }
    unsigned int v5 = [*(id *)(a1 + 2160) startMonitoring];
  uint64_t v8 = (os_log_s *)qword_1007FE0F8;
  if (os_log_type_enabled((os_log_t)qword_1007FE0F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    unsigned int v14 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#reg-prov,fSystemSettingsMonitor startMonitoring done, status, %d",  buf,  8u);
  }

  uint64_t v9 = *(void *)(a1 + 2168);
  if (v9) {
    id result = 0LL;
  }
  else {
    id result = (id)v5;
  }
  if (v9)
  {
    if (((v5 ^ 1) & 1) == 0) {
      return [*(id *)(a1 + 2168) startMonitoring];
    }
  }

  return result;
}

void *sub_100295B40(void *result)
{
  if (!result[272])
  {
    uint64_t v1 = result;
    uint64_t v2 = objc_alloc(&OBJC_CLASS___PRSettingsObserver);
    uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue(+[PRGlobalDebugSettings sharedSettings](&OBJC_CLASS___PRGlobalDebugSettings, "sharedSettings"));
    uint64_t v4 = -[PRSettingsObserver initWithSettings:queue:](v2, "initWithSettings:queue:", v3, v1[5]);
    unsigned int v5 = (void *)v1[272];
    v1[272] = v4;

    id v6 = (void *)v1[272];
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472LL;
    v9[2] = sub_100297170;
    void v9[3] = &unk_1007B2550;
    v9[4] = v1;
    [v6 startObserving:PRDebugConfigArgMcc observeImmediately:0 callback:v9];
    id v7 = (void *)v1[272];
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472LL;
    void v8[2] = sub_100297360;
    void v8[3] = &unk_1007B2550;
    void v8[4] = v1;
    return [v7 startObserving:PRDebugConfigArgIsoCountry observeImmediately:0 callback:v8];
  }

  return result;
}

void sub_100295C40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100295C50(uint64_t a1, uint64_t a2)
{
}

void sub_100295C58(uint64_t a1, uint64_t a2)
{
  BOOL v4 = sub_1003206F4(*(_DWORD *)(a1 + 24));
  unsigned int v5 = (os_log_s *)qword_1007FE0F8;
  if (v4)
  {
    id v6 = (os_log_s *)(id)qword_1007FE0F8;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      id v7 = sub_100265310(a2);
      uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
      int v12 = 138412290;
      uint64_t v13 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#reg-prov,Airplane Mode changed: %@.",  (uint8_t *)&v12,  0xCu);
    }

    BOOL v9 = a2 == 1;
    int v10 = sub_10025B598(a1 + 48, v9);
    if (v9) {
      int v11 = 1;
    }
    else {
      int v11 = 2;
    }
    sub_1001AC620(a1 + 280, v11);
    if ((v10 & 1) != 0) {
      sub_10029608C(a1, 1u, 1);
    }
    if ((v10 & 0x10000) != 0) {
      sub_100296260(a1, 1u, 1);
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1007FE0F8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v12) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "#reg-prov,onAirplaneModeStateChange,exited early,device does not support UWB.",  (uint8_t *)&v12,  2u);
  }

void sub_100295DB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100295DD0(uint64_t a1, int a2)
{
}

void sub_100295DD8(uint64_t a1, int a2)
{
  BOOL v4 = (os_log_s *)qword_1007FE0F8;
  if (os_log_type_enabled((os_log_t)qword_1007FE0F8, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v5) = 67109120;
    DWORD1(v5) = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#reg-prov,onNarrowbandSARChange,index,%d",  (uint8_t *)&v5,  8u);
  }

  *(void *)&__int128 v5 = 0x800000005LL;
  BYTE8(v5) = 1;
  BYTE12(v5) = 0;
  char v6 = 0;
  char v7 = a2;
  char v8 = 1;
  sub_100295FE0(a1, &v5);
}

id sub_100295EB0(uint64_t a1)
{
  return sub_100295948(a1 - 8);
}

uint64_t sub_100295EB8(uint64_t a1)
{
  return 1LL;
}

uint64_t sub_100295EF0(uint64_t a1)
{
  return 1LL;
}

void sub_100295F28(uint64_t a1)
{
  if (sub_1003206F4(*(_DWORD *)(a1 + 24)))
  {
    uint64_t v2 = *(dispatch_queue_s **)(a1 + 40);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_100295FD8;
    block[3] = &unk_1007A2398;
    void block[4] = a1;
    dispatch_async(v2, block);
  }

  else
  {
    uint64_t v3 = (os_log_s *)qword_1007FE0F8;
    if (os_log_type_enabled((os_log_t)qword_1007FE0F8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "#reg-prov,onFirstUnlock,exited early,device does not support UWB.",  buf,  2u);
    }
  }

BOOL sub_100295FD8(uint64_t a1)
{
  return sub_1002954E8(*(void *)(a1 + 32));
}

void sub_100295FE0(uint64_t a1, __int128 *a2)
{
  if (*(void *)(a1 + 16))
  {
    uint64_t v2 = *(dispatch_queue_s **)(a1 + 32);
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472LL;
    v3[2] = sub_100296050;
    v3[3] = &unk_1007BB6B0;
    void v3[4] = a1;
    __int128 v4 = *a2;
    uint64_t v5 = *((void *)a2 + 2);
    dispatch_async(v2, v3);
  }

void sub_100296050(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 16LL);
  __int128 v2 = *(_OWORD *)(a1 + 40);
  uint64_t v3 = *(void *)(a1 + 56);
  sub_1001478FC(v1, (uint64_t)&v2);
}

void sub_10029608C(uint64_t a1, unsigned int a2, int a3)
{
  BOOL v6 = sub_100296218(a1);
  char v7 = (os_log_s *)(id)qword_1007FE0F8;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    if (a2 > 8) {
      char v8 = "Unknown";
    }
    else {
      char v8 = (&off_1007BB990)[a2];
    }
    sub_1000065CC(__p, v8);
    BOOL v9 = (void **)__p[0];
    int v10 = "UWBDisallowed";
    if (v13 >= 0) {
      BOOL v9 = __p;
    }
    if (v6) {
      int v10 = "UWBAllowed";
    }
    *(_DWORD *)buf = 136315650;
    uint64_t v15 = v9;
    __int16 v16 = 2080;
    uint64_t v17 = v10;
    if (a3) {
      int v11 = "yes";
    }
    else {
      int v11 = "no";
    }
    __int16 v18 = 2080;
    uint64_t v19 = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "#reg-prov,relayUwbState,%s,allowed,%s,actionRequired,%s",  buf,  0x20u);
    if (v13 < 0) {
      operator delete(__p[0]);
    }
  }

  *(_DWORD *)buf = v6;
  LODWORD(v15) = a2;
  BYTE4(v15) = a3;
  LOBYTE(v16) = 0;
  BYTE2(v17) = 0;
  HIWORD(v17) = 0;
  sub_100295FE0(a1, (__int128 *)buf);
}

void sub_100296200(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_100296218(uint64_t a1)
{
  int v1 = v3[0];
  if (v5 < 0) {
    operator delete(__p);
  }
  return v1 != 0;
}

void sub_100296260(uint64_t a1, unsigned int a2, int a3)
{
  BOOL v6 = sub_1002963F8(a1);
  char v7 = (os_log_s *)(id)qword_1007FE0F8;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    if (a2 > 8) {
      char v8 = "Unknown";
    }
    else {
      char v8 = (&off_1007BB990)[a2];
    }
    sub_1000065CC(__p, v8);
    BOOL v9 = (void **)__p[0];
    int v10 = "NBDisallowed";
    if (v14 >= 0) {
      BOOL v9 = __p;
    }
    if (v6) {
      int v10 = "NBAllowed";
    }
    *(_DWORD *)buf = 136315650;
    __int16 v16 = v9;
    __int16 v17 = 2080;
    __int16 v18 = v10;
    if (a3) {
      int v11 = "yes";
    }
    else {
      int v11 = "no";
    }
    __int16 v19 = 2080;
    uint64_t v20 = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "#reg-prov,relayNBState,%s,allowed,%s,actionRequired,%s",  buf,  0x20u);
    if (v14 < 0) {
      operator delete(__p[0]);
    }
  }

  if (v6) {
    int v12 = 4;
  }
  else {
    int v12 = 3;
  }
  *(_DWORD *)buf = v12;
  LODWORD(v16) = a2;
  BYTE4(v16) = a3;
  LOBYTE(v17) = 0;
  BYTE2(v1_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  HIWORD(v1_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  sub_100295FE0(a1, (__int128 *)buf);
}

void sub_1002963E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_1002963F8(uint64_t a1)
{
  int v1 = v3[1];
  if (v5 < 0) {
    operator delete(__p);
  }
  return v1 != 0;
}

void sub_100296440(uint64_t a1, uint64_t a2)
{
  __int128 v4 = (os_log_s *)(id)qword_1007FE0F8;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(int *)(a2 + 4);
    else {
      BOOL v6 = (&off_1007BB990)[v5];
    }
    sub_1000065CC(__p, v6);
    if (v11 >= 0) {
      char v7 = __p;
    }
    else {
      char v7 = (void **)__p[0];
    }
    char v8 = &v13;
    if (v14 < 0) {
      char v8 = v13;
    }
    if (*(_BYTE *)(a2 + 8)) {
      BOOL v9 = "yes";
    }
    else {
      BOOL v9 = "no";
    }
    *(_DWORD *)buf = 136315906;
    __int16 v17 = v7;
    __int16 v18 = 2080;
    __int16 v19 = v8;
    __int16 v20 = 1024;
    int v21 = v15;
    __int16 v22 = 2080;
    uint64_t v23 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#reg-prov,relaySettingsChange,%s,country,%s,flags,%d,actionRequired,%s",  buf,  0x26u);
    if (v11 < 0) {
      operator delete(__p[0]);
    }
  }

  sub_100295FE0(a1, (__int128 *)a2);
  if (v14 < 0) {
    operator delete(v13);
  }
}

void sub_1002965C0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1002965E8(uint64_t a1@<X0>, unint64_t *a2@<X8>)
{
  __int128 v4 = sub_1001A8438();
  sub_10025C99C(a1 + 48, (uint64_t)v7);
  if (SHIBYTE(v9) < 0)
  {
    sub_1000063A8(__p, (void *)v8, *((unint64_t *)&v8 + 1));
  }

  else
  {
    *(_OWORD *)std::stringbuf::string_type __p = v8;
    uint64_t v6 = v9;
  }

  sub_100350B78((uint64_t)v4, (uint64_t)__p, a2);
  if (SHIBYTE(v6) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v9) < 0) {
    operator delete((void *)v8);
  }
}

void sub_10029668C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p, uint64_t a21, int a22, __int16 a23, char a24, char a25)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002966C0(uint64_t a1@<X0>, unint64_t *a2@<X8>)
{
}

void sub_1002966C8(uint64_t a1@<X0>, void *a2@<X8>)
{
  __int128 v4 = sub_1001A8438();
  sub_10025C99C(a1 + 48, (uint64_t)v7);
  if (SHIBYTE(v9) < 0)
  {
    sub_1000063A8(__p, (void *)v8, *((unint64_t *)&v8 + 1));
  }

  else
  {
    *(_OWORD *)std::stringbuf::string_type __p = v8;
    uint64_t v6 = v9;
  }

  sub_100350F2C(v4, (uint64_t)__p, a2);
  if (SHIBYTE(v6) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v9) < 0) {
    operator delete((void *)v8);
  }
}

void sub_10029676C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p, uint64_t a21, int a22, __int16 a23, char a24, char a25)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002967A0(uint64_t a1@<X0>, void *a2@<X8>)
{
}

void sub_1002967A8(uint64_t a1, char *a2)
{
  __int128 v4 = (os_log_s *)qword_1007FE0F8;
  if (os_log_type_enabled((os_log_t)qword_1007FE0F8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "#reg-prov,onCountryChange", buf, 2u);
  }

  if ((a2[23] & 0x80000000) == 0)
  {
    if (a2[23])
    {
      std::string __p = *(std::string *)a2;
      goto LABEL_8;
    }

void sub_1002969CC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002969F0(uint64_t a1, int a2)
{
  int v4 = sub_10025B7FC(a1 + 48, a2);
  if ((_BYTE)v4)
  {
    unint64_t v5 = (os_log_s *)(id)qword_1007FE0F8;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a1 + 79) < 0)
      {
        sub_1000063A8(__p, *(void **)(a1 + 56), *(void *)(a1 + 64));
      }

      else
      {
        *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 56);
        uint64_t v10 = *(void *)(a1 + 72);
      }

      unsigned int v6 = __p;
      if (v10 < 0) {
        unsigned int v6 = (void **)__p[0];
      }
      *(_DWORD *)buf = 67109378;
      int v12 = a2;
      __int16 v13 = 2080;
      char v14 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "#reg-prov,onRestrictedRegionChanged,%d,isoCountry,%s,uwbChannelSettingChanged",  buf,  0x12u);
      if (SHIBYTE(v10) < 0) {
        operator delete(__p[0]);
      }
    }

    sub_10029608C(a1, 7u, 1);
  }

  if ((v4 & 0xFF0000) != 0)
  {
    uint64_t v7 = (os_log_s *)(id)qword_1007FE0F8;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a1 + 79) < 0)
      {
        sub_1000063A8(__p, *(void **)(a1 + 56), *(void *)(a1 + 64));
      }

      else
      {
        *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 56);
        uint64_t v10 = *(void *)(a1 + 72);
      }

      __int128 v8 = __p;
      if (v10 < 0) {
        __int128 v8 = (void **)__p[0];
      }
      *(_DWORD *)buf = 67109378;
      int v12 = a2;
      __int16 v13 = 2080;
      char v14 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "#reg-prov,onRestrictedRegionChanged,%d,isoCountry,%s,isNBChannelSettingChanged",  buf,  0x12u);
      if (SHIBYTE(v10) < 0) {
        operator delete(__p[0]);
      }
    }

    sub_100296260(a1, 7u, 1);
  }

void sub_100296BEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100296C08(uint64_t a1)
{
  __int128 v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](&OBJC_CLASS___NSUserDefaults, "standardUserDefaults"));
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([v2 stringForKey:@"RegulatoryGroup"]);
  int v4 = v3;
  if (v3)
  {
    if ([v3 isEqualToString:@"US"])
    {
      int v5 = 0;
      goto LABEL_18;
    }

    if ([v4 isEqualToString:@"EU"])
    {
      int v5 = 1;
      goto LABEL_18;
    }

    if ([v4 isEqualToString:@"TW"])
    {
      int v5 = 2;
      goto LABEL_18;
    }

    if ([v4 isEqualToString:@"CN"])
    {
      int v5 = 3;
      goto LABEL_18;
    }

    if ([v4 isEqualToString:@"JP"])
    {
      int v5 = 4;
      goto LABEL_18;
    }

    if ([v4 isEqualToString:@"KR"])
    {
      int v5 = 5;
      goto LABEL_18;
    }

    if ([v4 isEqualToString:@"RU"])
    {
      int v5 = 6;
      goto LABEL_18;
    }

    if ([v4 isEqualToString:@"AR"])
    {
      int v5 = 7;
LABEL_18:
      unsigned int v6 = (os_log_s *)qword_1007FE0F8;
      if (os_log_type_enabled((os_log_t)qword_1007FE0F8, OS_LOG_TYPE_DEBUG)) {
        sub_1003A54C4((uint64_t)v4, v6);
      }
      goto LABEL_24;
    }
  }

  if (os_log_type_enabled((os_log_t)qword_1007FE0F8, OS_LOG_TYPE_DEBUG)) {
    sub_1003A548C();
  }
  sub_10025C99C(a1 + 48, (uint64_t)&v8);
  int v5 = v11;
  if (v10 < 0) {
    operator delete(__p);
  }
LABEL_24:

  return v5 | 0x100u;
}

void sub_100296DB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100296DD4(uint64_t a1)
{
  return sub_100296C08(a1 - 8);
}

uint64_t sub_100296DDC(uint64_t a1)
{
  uint64_t v5 = 0LL;
  unsigned int v6 = &v5;
  uint64_t v7 = 0x2020000000LL;
  int v1 = *(dispatch_queue_s **)(a1 + 40);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  v4[2] = sub_100296E68;
  v4[3] = &unk_1007B2170;
  v4[4] = &v5;
  void v4[5] = a1;
  dispatch_sync(v1, v4);
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

BOOL sub_100296E68(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  sub_1002954E8(v2);
  BOOL result = sub_100296218(v2);
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

uint64_t sub_100296EA4(uint64_t a1)
{
  return sub_100296DDC(a1 - 8);
}

uint64_t sub_100296EAC(uint64_t a1)
{
  uint64_t v5 = 0LL;
  unsigned int v6 = &v5;
  uint64_t v7 = 0x2020000000LL;
  int v1 = *(dispatch_queue_s **)(a1 + 40);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  v4[2] = sub_100296F38;
  v4[3] = &unk_1007B2170;
  v4[4] = &v5;
  void v4[5] = a1;
  dispatch_sync(v1, v4);
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

BOOL sub_100296F38(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  sub_1002954E8(v2);
  BOOL result = sub_1002963F8(v2);
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

uint64_t sub_100296F74(uint64_t a1)
{
  return sub_100296EAC(a1 - 8);
}

uint64_t *sub_100296F7C(uint64_t a1)
{
  uint64_t v2 = sub_1001A8438();
  sub_10025C99C(a1 + 48, (uint64_t)v7);
  if (SHIBYTE(v9) < 0)
  {
    sub_1000063A8(__p, (void *)v8, *((unint64_t *)&v8 + 1));
  }

  else
  {
    *(_OWORD *)std::string __p = v8;
    uint64_t v6 = v9;
  }

  uint64_t v3 = sub_100350188((uint64_t)v2, (uint64_t *)__p, v10, v11);
  if (SHIBYTE(v6) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v9) < 0) {
    operator delete((void *)v8);
  }
  return v3;
}

void sub_100297020( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p, uint64_t a21, int a22, __int16 a23, char a24, char a25)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_100297054(uint64_t a1)
{
  return sub_100296F7C(a1 - 8);
}

uint64_t sub_10029705C()
{
  return 1LL;
}

uint64_t sub_100297064(uint64_t a1, _DWORD *a2)
{
  if (!*a2 && os_log_type_enabled((os_log_t)qword_1007FE0F8, OS_LOG_TYPE_ERROR)) {
    sub_1003A5538();
  }
  return 0LL;
}

void sub_1002970AC(uint64_t a1)
{
  if (sub_1003206F4(*(_DWORD *)(a1 + 24)))
  {
    uint64_t v2 = *(dispatch_queue_s **)(a1 + 40);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_10029715C;
    block[3] = &unk_1007A2398;
    void block[4] = a1;
    dispatch_async(v2, block);
  }

  else
  {
    uint64_t v3 = (os_log_s *)qword_1007FE0F8;
    if (os_log_type_enabled((os_log_t)qword_1007FE0F8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "#reg-prov,refreshRegulatoryInformation,exited early,device does not support UWB.",  buf,  2u);
    }
  }

uint64_t sub_10029715C(uint64_t a1)
{
  return sub_1001AC368(*(void *)(a1 + 32) + 280LL);
}

void sub_100297168(uint64_t a1)
{
}

void sub_100297170(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(+[PRGlobalDebugSettings sharedSettings](&OBJC_CLASS___PRGlobalDebugSettings, "sharedSettings"));
  id v7 = objc_msgSend(v5, "objectForKey:ofClass:", v3, objc_opt_class(NSString, v6));
  __int128 v8 = (void *)objc_claimAutoreleasedReturnValue(v7);

  uint64_t v9 = (os_log_s *)(id)qword_1007FE0F8;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)[v8 UTF8String];
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#reg-prov,test,received mcc: %s",  (uint8_t *)&__p,  0xCu);
  }

  if (sub_1003206F4(*(_DWORD *)(v4 + 24)))
  {
    sub_1000065CC(&__p, (char *)[v8 UTF8String]);
    sub_1001AB89C((int *)(v4 + 280), &__p);
  }

  else
  {
    unsigned __int16 v10 = (os_log_s *)qword_1007FE0F8;
    if (os_log_type_enabled((os_log_t)qword_1007FE0F8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p.__r_.__value_.__l.__data_) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#reg-prov,test,received mcc,skipped,device does not support UWB",  (uint8_t *)&__p,  2u);
    }
  }
}

void sub_100297300( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_100297360(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(+[PRGlobalDebugSettings sharedSettings](&OBJC_CLASS___PRGlobalDebugSettings, "sharedSettings"));
  id v7 = objc_msgSend(v5, "objectForKey:ofClass:", v3, objc_opt_class(NSString, v6));
  __int128 v8 = (void *)objc_claimAutoreleasedReturnValue(v7);

  uint64_t v9 = (os_log_s *)(id)qword_1007FE0F8;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    id v14 = [v8 UTF8String];
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#reg-prov,test,received isoCountry %s",  buf,  0xCu);
  }

  if (sub_1003206F4(*(_DWORD *)(v4 + 24)))
  {
    sub_1000065CC(__p, (char *)[v8 UTF8String]);
    sub_1002967A8(v4, (char *)__p);
    if (v12 < 0) {
      operator delete(__p[0]);
    }
  }

  else
  {
    unsigned __int16 v10 = (os_log_s *)qword_1007FE0F8;
    if (os_log_type_enabled((os_log_t)qword_1007FE0F8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#reg-prov,test,received isoCountry,skipped,device does not support UWB",  buf,  2u);
    }
  }
}

void sub_1002974F0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_100297544(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  if (v15[4])
  {
    int v3 = 0;
    goto LABEL_8;
  }

  if (!v17)
  {
    if (os_log_type_enabled((os_log_t)qword_1007FE0F8, OS_LOG_TYPE_FAULT)) {
      sub_1003A5564();
    }
    int v8 = 587;
LABEL_32:
    __assert_rtn("toRegulatoryState", "PRRegulatoryProvider.mm", v8, "false");
  }

  if ((v16 - 2) < 2)
  {
    int v3 = 2;
    goto LABEL_8;
  }

  if (!v16)
  {
    if (os_log_type_enabled((os_log_t)qword_1007FE0F8, OS_LOG_TYPE_FAULT)) {
      sub_1003A5590();
    }
    int v8 = 599;
    goto LABEL_32;
  }

  int v3 = 1;
LABEL_8:
  uint64_t v4 = sub_1001A8438();
  if (SHIBYTE(v19) < 0)
  {
    sub_1000063A8(__dst, (void *)v18, *((unint64_t *)&v18 + 1));
  }

  else
  {
    *(_OWORD *)__int128 __dst = v18;
    uint64_t v14 = v19;
  }

  uint64_t v5 = sub_100350188((uint64_t)v4, (uint64_t *)__dst, v20, v21);
  if (SHIBYTE(v19) < 0)
  {
    sub_1000063A8(v11, (void *)v18, *((unint64_t *)&v18 + 1));
  }

  else
  {
    *(_OWORD *)unsigned int v11 = v18;
    uint64_t v12 = v19;
  }

  uint64_t v6 = sub_1003504E0(v4, (uint64_t *)v11, v20, v21);
  if (SHIBYTE(v19) < 0)
  {
    sub_1000063A8(__p, (void *)v18, *((unint64_t *)&v18 + 1));
  }

  else
  {
    *(_OWORD *)std::string __p = v18;
    uint64_t v10 = v19;
  }

  id v7 = sub_10035082C(v4, (uint64_t *)__p, v20, v21);
  sub_100297B40(a2, v3, (uint64_t)v5, (uint64_t)v6, (uint64_t)v7);
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v12) < 0) {
    operator delete(v11[0]);
  }
  if (SHIBYTE(v14) < 0) {
    operator delete(__dst[0]);
  }
  if (SHIBYTE(v19) < 0) {
    operator delete((void *)v18);
  }
}

void sub_10029774C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21, uint64_t a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, void *a34, uint64_t a35, int a36, __int16 a37, char a38, char a39)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  if (a39 < 0) {
    operator delete(a34);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002977B4(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
}

uint64_t sub_1002977BC(uint64_t a1, std::string *a2)
{
  if (sub_10032085C(*(_DWORD *)(a1 + 24)) && sub_1003206F4(*(_DWORD *)(a1 + 24)))
  {
    uint64_t v4 = sub_1001ABD18((int *)(a1 + 280), a2);
    uint64_t v5 = (os_log_s *)qword_1007FE0F8;
    if (os_log_type_enabled((os_log_t)qword_1007FE0F8, OS_LOG_TYPE_DEBUG)) {
      sub_1003A55BC((uint64_t *)a2, v4, v5);
    }
  }

  else
  {
    uint64_t v6 = (os_log_s *)qword_1007FE0F8;
    uint64_t v4 = 0LL;
    if (os_log_type_enabled((os_log_t)qword_1007FE0F8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v8 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#reg-prov,injectIsoCode,exited early,device is not a UWB watch.",  v8,  2u);
      return 0LL;
    }
  }

  return v4;
}

uint64_t sub_10029788C(uint64_t a1, std::string *a2)
{
  return sub_1002977BC(a1 - 8, a2);
}

id sub_100297894(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 2168);
  if (v2) {
    return _[v2 injectNarrowbandSARState:a2];
  }
  if (os_log_type_enabled((os_log_t)qword_1007FE0F8, OS_LOG_TYPE_ERROR)) {
    sub_1003A5654();
  }
  return 0LL;
}

id sub_1002978EC(uint64_t a1, uint64_t a2)
{
  return sub_100297894(a1 - 8, a2);
}

id sub_1002978F4(uint64_t a1)
{
  return _[*(id *)(a1 + 2168) clearSARStateOverride];
}

id sub_1002978FC(uint64_t a1)
{
  return _[*(id *)(a1 + 2160) clearSARStateOverride];
}

id sub_100297904(uint64_t a1)
{
  uint64_t v5 = 0LL;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x3032000000LL;
  int v8 = sub_1002979B8;
  uint64_t v9 = sub_1002979C8;
  id v10 = 0LL;
  int v1 = *(dispatch_queue_s **)(a1 + 40);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  v4[2] = sub_1002979D0;
  v4[3] = &unk_1007B2170;
  v4[4] = &v5;
  void v4[5] = a1;
  dispatch_sync(v1, v4);
  id v2 = (id)v6[5];
  _Block_object_dispose(&v5, 8);

  return v2;
}

uint64_t sub_1002979B8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_1002979C8(uint64_t a1)
{
}

void sub_1002979D0(uint64_t a1)
{
  id v2 = sub_100295608(*(void *)(a1 + 40));
  uint64_t v3 = objc_claimAutoreleasedReturnValue(v2);
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = v3;
}

void sub_100297A08(uint64_t a1, uint64_t a2)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"    %@", a2));
  objc_msgSend(v2, "addObject:");
}

void sub_100297A5C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_100297A70(uint64_t a1, uint64_t a2)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"    %@", a2));
  objc_msgSend(v2, "addObject:");
}

void sub_100297AC4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_100297AD8(uint64_t a1, uint64_t a2)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"    %@", a2));
  objc_msgSend(v2, "addObject:");
}

void sub_100297B2C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

uint64_t sub_100297B40(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(_DWORD *)a1 = a2;
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + 24) = 0LL;
  sub_1001DF3F4( (void *)(a1 + 8),  *(const void **)a3,  *(void *)(a3 + 8),  (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 3);
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  sub_1001DF46C( (void *)(a1 + 32),  *(const void **)a4,  *(void *)(a4 + 8),  (uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 3);
  *(void *)(a1 + 56) = 0LL;
  *(void *)(a1 + 64) = 0LL;
  *(void *)(a1 + 72) = 0LL;
  sub_1001DF4E4( (void *)(a1 + 56),  *(const void **)a5,  *(void *)(a5 + 8),  (uint64_t)(*(void *)(a5 + 8) - *(void *)a5) >> 3);
  return a1;
}

void sub_100297BD8(_Unwind_Exception *exception_object)
{
  uint64_t v5 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 40) = v5;
    operator delete(v5);
  }

  uint64_t v6 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 16) = v6;
    operator delete(v6);
  }

  _Unwind_Resume(exception_object);
}

void *sub_100297C14(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &off_1007BB730;
  result[1] = v3;
  return result;
}

uint64_t sub_100297C48(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_1007BB730;
  a2[1] = v2;
  return result;
}

void sub_100297C64(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (*(char *)(a2 + 23) < 0)
  {
    sub_1000063A8(__p, *(void **)a2, *(void *)(a2 + 8));
  }

  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v4 = *(void *)(a2 + 16);
  }

  sub_1002967A8(v2, (char *)__p);
  if (SHIBYTE(v4) < 0) {
    operator delete(__p[0]);
  }
}

void sub_100297CD0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100297CEC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100297D28()
{
}

void *sub_100297D3C(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &off_1007BB7B0;
  result[1] = v3;
  return result;
}

uint64_t sub_100297D70(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_1007BB7B0;
  a2[1] = v2;
  return result;
}

void sub_100297D8C(uint64_t a1, unsigned __int8 *a2)
{
}

uint64_t sub_100297D98(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100297DD4()
{
}

void *sub_100297DE8(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &off_1007BB830;
  result[1] = v3;
  return result;
}

uint64_t sub_100297E1C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_1007BB830;
  a2[1] = v2;
  return result;
}

void sub_100297E38(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = (_OWORD *)(v3 + 56);
  if (*(char *)(v3 + 79) < 0)
  {
    sub_1000063A8(__s1, *(void **)(v3 + 56), *(void *)(v3 + 64));
  }

  else
  {
    *(_OWORD *)__s1 = *v4;
    uint64_t v24 = *(void *)(v3 + 72);
  }

  uint64_t v5 = (os_log_s *)(id)qword_1007FE0F8;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(v3 + 79) < 0)
    {
      sub_1000063A8(__p, *(void **)(v3 + 56), *(void *)(v3 + 64));
    }

    else
    {
      *(_OWORD *)std::string __p = *v4;
      uint64_t v22 = *(void *)(v3 + 72);
    }

    uint64_t v6 = __p;
    if (v22 < 0) {
      uint64_t v6 = (void **)__p[0];
    }
    *(_DWORD *)buf = 136315138;
    uint64_t v26 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "#reg-prov,IsoCountry %s", buf, 0xCu);
    if (SHIBYTE(v22) < 0) {
      operator delete(__p[0]);
    }
  }

  uint64_t v7 = (void *)strlen(off_1007F4750[0]);
  size_t v8 = (size_t)v7;
  size_t v9 = HIBYTE(v24);
  if ((SHIBYTE(v24) & 0x80000000) == 0)
  {
    if (v7 != (void *)HIBYTE(v24))
    {
      uint64_t v12 = off_1007F4768[0];
      size_t v13 = strlen(off_1007F4768[0]);
LABEL_23:
      if (v13 != v9)
      {
        char v15 = off_1007F4738[0];
        size_t v16 = strlen(off_1007F4738[0]);
LABEL_32:
        if (v16 != v9)
        {
          __int128 v18 = off_1007F4760[0];
          size_t v19 = strlen(off_1007F4760[0]);
          goto LABEL_42;
        }

        char v17 = __s1;
        unsigned int v11 = (void *)v9;
        goto LABEL_40;
      }

      uint64_t v14 = __s1;
      unsigned int v11 = (void *)v9;
      goto LABEL_30;
    }

    if (v7 != (void *)-1LL)
    {
      id v10 = __s1;
      goto LABEL_19;
    }

void sub_1002981AC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a2) {
    sub_10000DE88(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002981F8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100298234()
{
}

void sub_100298240()
{
  unsigned __int8 v0 = objc_autoreleasePoolPush();
  qword_1007FE0F8 = (uint64_t)os_log_create("com.apple.nearbyd", "Regulatory");
  objc_autoreleasePoolPop(v0);
}

void sub_1002982C0(id a1)
{
  id v1 = -[_FindingAdvertiser _initInternal](objc_alloc(&OBJC_CLASS____FindingAdvertiser), "_initInternal");
  uint64_t v2 = (void *)qword_1007FE100;
  qword_1007FE100 = (uint64_t)v1;

  id v3 = (id)objc_claimAutoreleasedReturnValue( +[NIServerSpatialInteractionPayloadAggregator sharedInstance]( &OBJC_CLASS___NIServerSpatialInteractionPayloadAggregator,  "sharedInstance"));
  [v3 addPayloadChangeObserver:qword_1007FE100];
}

void sub_100298320( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_100298480(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100298494(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_1002984A4(uint64_t a1)
{
}

void sub_1002984AC(uint64_t a1)
{
  uint64_t v2 = sub_100277758(*(unsigned __int8 *)(a1 + 64));
  id v3 = *(void **)(a1 + 32);
  id v12 = 0LL;
  id v13 = 0LL;
  uint64_t v4 = (id *)[v3 _peerIndexReferenceForAdvertisementType:v2 outPeers:&v13 outAdvertisements:&v12];
  id v5 = v13;
  id v6 = v12;
  id v7 = [v5 indexOfObject:*(void *)(a1 + 40)];
  if (v7 == (id)0x7FFFFFFFFFFFFFFFLL)
  {
    size_t v8 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(a1 + 32) _configureAdvertiserForType:v2 toPeer:*(void *)(a1 + 40) withAdvertisement:*(void *)(a1 + 48)]);
    if (v8)
    {
      objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 40LL), v8);
    }

    else
    {
      [v5 addObject:*(void *)(a1 + 40)];
      [v6 addObject:*(void *)(a1 + 48)];
      id v11 = [v5 count];
      if (v11 != [v6 count]) {
        __assert_rtn( "-[_FindingAdvertiser startAdvertisingAsFinder:toPeer:withAdvertisement:]_block_invoke",  "NIServerFindingDiscovery.mm",  168,  "_peers.count == _advertisements.count");
      }
      *uint64_t v4 = (char *)[v5 count] - 1;
      if ([*(id *)(a1 + 32) _totalPeers] == (id)1) {
        [*(id *)(a1 + 32) _startRoundRobinTimer];
      }
    }

    goto LABEL_10;
  }

  [v6 setObject:*(void *)(a1 + 48) atIndexedSubscript:v7];
  if (*v4 == v7)
  {
    uint64_t v9 = objc_claimAutoreleasedReturnValue( [*(id *)(a1 + 32) _configureAdvertiserForType:v2 toPeer:*(void *)(a1 + 40) withAdvertisement:*(void *)(a1 + 48)]);
    if (v9)
    {
      uint64_t v10 = *(void *)(*(void *)(a1 + 56) + 8LL);
      size_t v8 = *(void **)(v10 + 40);
      *(void *)(v10 + 40) = v9;
LABEL_10:
    }
  }
}

void sub_100298644(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100298750(uint64_t a1)
{
  uint64_t v2 = sub_100277758(*(unsigned __int8 *)(a1 + 56));
  id v3 = *(void **)(a1 + 32);
  id v16 = 0LL;
  id v17 = 0LL;
  uint64_t v4 = [v3 _peerIndexReferenceForAdvertisementType:v2 outPeers:&v17 outAdvertisements:&v16];
  id v5 = v17;
  id v6 = v16;
  id v7 = [v5 indexOfObject:*(void *)(a1 + 40)];
  if (v7 != (id)0x7FFFFFFFFFFFFFFFLL)
  {
    [v5 removeObjectAtIndex:v7];
    [v6 removeObjectAtIndex:v7];
    id v8 = [v5 count];
    if (v8 != [v6 count]) {
      __assert_rtn( "-[_FindingAdvertiser stopAdvertisingAsFinder:toPeer:]_block_invoke",  "NIServerFindingDiscovery.mm",  202,  "_peers.count == _advertisements.count");
    }
    *uint64_t v4 = 0LL;
    id v9 = [v5 count];
    uint64_t v10 = *(void **)(a1 + 32);
    if (v9)
    {
      id v11 = (void *)objc_claimAutoreleasedReturnValue([v5 firstObject]);
      id v12 = (void *)objc_claimAutoreleasedReturnValue([v6 firstObject]);
      uint64_t v13 = objc_claimAutoreleasedReturnValue([v10 _configureAdvertiserForType:v2 toPeer:v11 withAdvertisement:v12]);

      if (v13)
      {
        uint64_t v14 = *(void *)(*(void *)(a1 + 48) + 8LL);
        char v15 = *(void **)(v14 + 40);
        *(void *)(v14 + 40) = v13;

        goto LABEL_9;
      }
    }

    else
    {
      [*(id *)(a1 + 32) _resetAdvertiserForType:v2];
    }

    if (![*(id *)(a1 + 32) _totalPeers]) {
      [*(id *)(a1 + 32) _stopRoundRobinTimer];
    }
  }

void sub_1002988DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002989CC(uint64_t a1)
{
  uint64_t v2 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
  id v3 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Advertiser singleton. Round robin timer active: %d",  *(void *)(*(void *)(a1 + 32) + 16LL) != 0LL));
  [v2 addObject:v3];

  uint64_t v4 = *(void *)(a1 + 32);
  id v5 = *(void **)(v4 + 24);
  if (v5 && *(_BYTE *)(v4 + 32))
  {
    id v6 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
    id v7 = (void *)objc_claimAutoreleasedReturnValue([v5 advertisingAddressDataConnectable]);
    uint64_t v8 = CUPrintNSDataAddress();
    id v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
    int v10 = [*(id *)(*(void *)(a1 + 32) + 24) advertiseRate];
    if (v10 > 39)
    {
      if (v10 <= 44)
      {
        if (v10 == 40)
        {
          id v11 = "Medium";
          goto LABEL_28;
        }

        if (v10 == 42)
        {
          id v11 = "MediumMid";
          goto LABEL_28;
        }
      }

      else
      {
        switch(v10)
        {
          case '-':
            id v11 = "MediumHigh";
            goto LABEL_28;
          case '2':
            id v11 = "High";
            goto LABEL_28;
          case '<':
            id v11 = "Max";
            goto LABEL_28;
        }
      }
    }

    else if (v10 <= 14)
    {
      if (!v10)
      {
        id v11 = "Default";
        goto LABEL_28;
      }

      if (v10 == 10)
      {
        id v11 = "Periodic";
        goto LABEL_28;
      }
    }

    else
    {
      switch(v10)
      {
        case 15:
          id v11 = "PeriodicHigh";
          goto LABEL_28;
        case 20:
          id v11 = "Background";
          goto LABEL_28;
        case 30:
          id v11 = "Low";
LABEL_28:
          uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"    T26 conn-addr: %@. Adv rate: %s.",  v9,  v11));
          [v6 addObject:v14];

          char v15 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
          id v16 = [*(id *)(*(void *)(a1 + 32) + 24) nearbyActionNoWakeType];
          uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(a1 + 32) + 24) nearbyActionNoWakeAuthTagData]);
          uint64_t v17 = CUPrintNSDataHex(v13, 3LL, 0LL);
          __int128 v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
          id v19 = [*(id *)(*(void *)(a1 + 32) + 24) nearbyActionNWPrecisionFindingStatus];
          unsigned __int16 v20 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(a1 + 32) + 24) nearbyActionNoWakeConfigData]);
          uint64_t v21 = CUPrintNSDataHex(v20, 1LL, 0LL);
          uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue(v21);
          uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"    T26 type: %d. ATag: 0x%@. Status: 0x%02X. Cfg: 0x%@",  v16,  v18,  v19,  v22));
          [v15 addObject:v23];

          goto LABEL_29;
      }
    }

    id v11 = "?";
    goto LABEL_28;
  }

  id v12 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
  uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"    T26 advertiser: %d. Activated: %d",  v5 != 0LL,  *(unsigned __int8 *)(v4 + 32)));
  [v12 addObject:v13];
LABEL_29:

  uint64_t v24 = *(void *)(a1 + 32);
  uint64_t v25 = *(void **)(v24 + 40);
  if (v25 && *(_BYTE *)(v24 + 48))
  {
    uint64_t v26 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
    uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([v25 advertisingAddressData]);
    uint64_t v28 = CUPrintNSDataAddress();
    uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(v28);
    int v30 = [*(id *)(*(void *)(a1 + 32) + 40) advertiseRate];
    if (v30 > 39)
    {
      if (v30 <= 44)
      {
        if (v30 == 40)
        {
          uint64_t v31 = "Medium";
          goto LABEL_56;
        }

        if (v30 == 42)
        {
          uint64_t v31 = "MediumMid";
          goto LABEL_56;
        }
      }

      else
      {
        switch(v30)
        {
          case '-':
            uint64_t v31 = "MediumHigh";
            goto LABEL_56;
          case '2':
            uint64_t v31 = "High";
            goto LABEL_56;
          case '<':
            uint64_t v31 = "Max";
            goto LABEL_56;
        }
      }
    }

    else if (v30 <= 14)
    {
      if (!v30)
      {
        uint64_t v31 = "Default";
        goto LABEL_56;
      }

      if (v30 == 10)
      {
        uint64_t v31 = "Periodic";
        goto LABEL_56;
      }
    }

    else
    {
      switch(v30)
      {
        case 15:
          uint64_t v31 = "PeriodicHigh";
          goto LABEL_56;
        case 20:
          uint64_t v31 = "Background";
          goto LABEL_56;
        case 30:
          uint64_t v31 = "Low";
LABEL_56:
          uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(a1 + 32) + 40) clientIrkData]);
          uint64_t v36 = CUPrintNSObjectMasked(v34, v35);
          uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue(v36);
          uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(a1 + 32) + 40) clientIdentifierData]);
          uint64_t v39 = CUPrintNSDataHex(v38, 3LL, 0LL);
          uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(v39);
          uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"    T19 non-conn-addr: %@. Adv rate: %s. CIRK: %@. CID: %@",  v29,  v31,  v37,  v40));
          [v26 addObject:v41];

          uint64_t v42 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
          id v43 = [*(id *)(*(void *)(a1 + 32) + 40) controlFlags];
          uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(a1 + 32) + 40) uwbConfigData]);
          uint64_t v44 = CUPrintNSDataHex(v33, 5LL, 0LL);
          uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue(v44);
          uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"    T19 control flags: 0x%08X. UWB config data: %@",  v43,  v45));
          [v42 addObject:v46];

          goto LABEL_57;
      }
    }

    uint64_t v31 = "?";
    goto LABEL_56;
  }

  uint64_t v32 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
  uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"    T19 advertiser: %d. Activated: %d",  v25 != 0LL,  *(unsigned __int8 *)(v24 + 48)));
  [v32 addObject:v33];
LABEL_57:

  char v47 = 1;
  do
  {
    char v48 = v47;
    uint64_t v49 = 80LL;
    if ((v47 & 1) != 0)
    {
      uint64_t v49 = 56LL;
      uint64_t v50 = 64LL;
    }

    else
    {
      uint64_t v50 = 88LL;
    }

    if ((v47 & 1) != 0) {
      uint64_t v51 = 72LL;
    }
    else {
      uint64_t v51 = 96LL;
    }
    if ((v47 & 1) != 0) {
      char v52 = @"T26";
    }
    else {
      char v52 = @"T19";
    }
    id v53 = *(id *)(*(void *)(a1 + 32) + v49);
    id v54 = *(id *)(*(void *)(a1 + 32) + v50);
    uint64_t v55 = *(void *)(*(void *)(a1 + 32) + v51);
    id v56 = [v53 count];
    id v57 = [v54 count];
    uint64_t v58 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
    char v67 = v48;
    if (v56 == v57)
    {
      uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"    %@ peers (%d)",  v52,  [v53 count]));
      [v58 addObject:v59];

      for (unint64_t i = 0; i < (unint64_t)[v53 count]; ++i)
      {
        uint64_t v61 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
        if (v55 == i)
        {
          uint64_t v62 = (void *)objc_claimAutoreleasedReturnValue([v53 objectAtIndexedSubscript:v55]);
          uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue([v62 descriptionInternal]);
          uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue([v54 objectAtIndexedSubscript:v55]);
          uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"      > %@: %@",  v63,  v64));
        }

        else
        {
          uint64_t v62 = (void *)objc_claimAutoreleasedReturnValue([v53 objectAtIndexedSubscript:i]);
          uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue([v62 descriptionInternal]);
          uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue([v54 objectAtIndexedSubscript:i]);
          uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"        %@: %@",  v63,  v64));
        }

        [v61 addObject:v65];
      }
    }

    else
    {
      unint64_t v66 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"    %@ state mismatch!!! %d peers, %d advertisements, %d current index",  v52,  [v53 count],  objc_msgSend(v54, "count"),  v55));
      [v58 addObject:v66];
    }

    char v47 = 0;
  }

  while ((v67 & 1) != 0);
}

void sub_10029917C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002993A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100299574(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100299A94( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, id location)
{
  _Unwind_Resume(a1);
}

void sub_100299B54(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained _cbAdvertisingAddressChanged];
}

void sub_100299B88( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_100299B9C(uint64_t a1, void *a2)
{
  id v3 = a2;
  double v4 = sub_100023CC4();
  double v5 = *(double *)(a1 + 48);
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    double v7 = v4 - v5;
    uint64_t v8 = (os_log_s *)qword_1008000A0;
    if (v3)
    {
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT)) {
        sub_1003A5774();
      }
      id v9 = (void *)WeakRetained[3];
      WeakRetained[3] = 0LL;
    }

    else
    {
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        int v10 = 134217984;
        double v11 = v7;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#find-disc,NearbyActionNoWake: activate advertiser complete [%0.6f s]",  (uint8_t *)&v10,  0xCu);
      }

      *((_BYTE *)WeakRetained + 32) = 1;
      [*(id *)(a1 + 32) _updateAdvertisementAfterActivationForType:26];
    }
  }
}

void sub_100299CC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_100299CE4(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  double v5 = v4;
  if (!v3)
  {
    char v15 = "token";
    int v16 = 2463;
    goto LABEL_17;
  }

  if (!v4)
  {
    char v15 = "address";
    int v16 = 2464;
LABEL_17:
    __assert_rtn("_getAuthTagForToken", "NIServerFindingDiscovery.mm", v16, v15);
  }

  id v6 = (void *)objc_claimAutoreleasedReturnValue([v3 getIRK]);
  double v7 = v6;
  if (v6 && [v6 length] == (id)16)
  {
    if (qword_1007FE118 != -1) {
      dispatch_once(&qword_1007FE118, &stru_1007BBB90);
    }
    int v8 = byte_1007FE110;
    id v9 = v7;
    if (v8)
    {
      uint64_t v10 = SipHash([v9 bytes], "StaticSipHashInput", 18);
    }

    else
    {
      id v12 = [v9 bytes];
      id v13 = v5;
      uint64_t v10 = SipHash(v12, [v13 bytes], objc_msgSend(v13, "length"));
    }

    __int16 v17 = v10;
    char v18 = BYTE2(v10);
    double v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", &v17, 3LL));
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT)) {
      sub_1003A57D4();
    }
    double v11 = 0LL;
  }

  return v11;
}

void sub_100299E80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10029A4A8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location)
{
  _Unwind_Resume(a1);
}

void sub_10029A580(uint64_t a1, void *a2)
{
  id v3 = a2;
  double v4 = sub_100023CC4();
  double v5 = *(double *)(a1 + 48);
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    double v7 = v4 - v5;
    int v8 = (os_log_s *)qword_1008000A0;
    if (v3)
    {
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT)) {
        sub_1003A582C();
      }
      id v9 = (void *)WeakRetained[5];
      WeakRetained[5] = 0LL;

      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NIServerSpatialInteractionPayloadAggregator sharedInstance]( &OBJC_CLASS___NIServerSpatialInteractionPayloadAggregator,  "sharedInstance"));
      [v10 setFindingEnabled:0];

      double v11 = (void *)objc_claimAutoreleasedReturnValue( +[NIServerSpatialInteractionPayloadAggregator sharedInstance]( &OBJC_CLASS___NIServerSpatialInteractionPayloadAggregator,  "sharedInstance"));
      [v11 commitChange];
    }

    else
    {
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        int v12 = 134217984;
        double v13 = v7;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#find-disc,SpatialInteraction: activate advertiser complete [%0.6f s]",  (uint8_t *)&v12,  0xCu);
      }

      *((_BYTE *)WeakRetained + 4_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
      [*(id *)(a1 + 32) _updateAdvertisementAfterActivationForType:19];
    }
  }
}

void sub_10029A6DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10029A860(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10029A958(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10029AAA4(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained _roundRobinTimerHandler];
}

void sub_10029AAD8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10029AD10(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_10029AE78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10029B058(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10029B4A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10029B8CC(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v3 - 136));
  _Unwind_Resume(a1);
}

void sub_10029B994(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained _cbInterruptionHandler];
}

void sub_10029B9C8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10029B9DC(uint64_t a1, void *a2)
{
  uint64_t v2 = (id *)(a1 + 32);
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained(v2);
  [WeakRetained _cbErrorHandler:v3];
}

void sub_10029BA24( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_10029BA3C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained _cbBluetoothStateChangedHandler];
}

void sub_10029BA70( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10029BA84(uint64_t a1, void *a2)
{
  id v3 = a2;
  double v4 = sub_100023CC4();
  double v5 = *(double *)(a1 + 40);
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    double v7 = v4 - v5;
    int v8 = (os_log_s *)qword_1008000A0;
    if (v3)
    {
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT)) {
        sub_1003A588C();
      }
      id v9 = (id)*((void *)WeakRetained + 8);
      *((void *)WeakRetained + _Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
      goto LABEL_6;
    }

    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = 134217984;
      double v11 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#find-disc,Activate controller complete [%0.6f s]",  (uint8_t *)&v10,  0xCu);
    }

    *((_BYTE *)WeakRetained + 72) = 1;
    [WeakRetained _cbBluetoothStateChangedHandler];
    if (*((_BYTE *)WeakRetained + 72) && *((_BYTE *)WeakRetained + 88))
    {
      id v9 = objc_loadWeakRetained((id *)WeakRetained + 5);
      [v9 bluetoothDiscoveryFinishedActivating];
LABEL_6:
    }
  }
}

void sub_10029BBC4(_Unwind_Exception *a1)
{
  double v4 = v3;

  _Unwind_Resume(a1);
}

void sub_10029BBF8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained _cbAdvertisingAddressChangedHandler];
}

void sub_10029BC2C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10029BC40(uint64_t a1, void *a2)
{
  id v3 = a2;
  double v4 = sub_100023CC4();
  double v5 = *(double *)(a1 + 40);
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    double v7 = v4 - v5;
    int v8 = (os_log_s *)qword_1008000A0;
    if (v3)
    {
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT)) {
        sub_1003A58EC();
      }
      id v9 = (id)*((void *)WeakRetained + 10);
      *((void *)WeakRetained + 10) = 0LL;
      goto LABEL_6;
    }

    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = 134217984;
      double v11 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#find-disc,Activate address observer complete [%0.6f s]",  (uint8_t *)&v10,  0xCu);
    }

    *((_BYTE *)WeakRetained + 8_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
    [WeakRetained _cbAdvertisingAddressChangedHandler];
    if (*((_BYTE *)WeakRetained + 72) && *((_BYTE *)WeakRetained + 88))
    {
      id v9 = objc_loadWeakRetained((id *)WeakRetained + 5);
      [v9 bluetoothDiscoveryFinishedActivating];
LABEL_6:
    }
  }
}

void sub_10029BD80(_Unwind_Exception *a1)
{
  double v4 = v3;

  _Unwind_Resume(a1);
}

void sub_10029BEC0(uint64_t a1, void *a2)
{
  id v5 = a2;
  id v3 = (void *)objc_claimAutoreleasedReturnValue(+[_FindingAdvertiser sharedInstance](&OBJC_CLASS____FindingAdvertiser, "sharedInstance"));
  id v4 = [v3 stopAdvertisingAsFinder:*(unsigned __int8 *)(*(void *)(a1 + 32) + 32) toPeer:v5];
}

void sub_10029BF20( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_10029C254(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10029C2DC(uint64_t a1, void *a2)
{
  id v3 = a2;
}

void sub_10029C328( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10029C33C(uint64_t a1, void *a2, void *a3)
{
  id v6 = a2;
  id v5 = a3;
  if (([*(id *)(a1 + 32) containsObject:v6] & 1) == 0)
  {
    dispatch_source_cancel(v5);
    [*(id *)(a1 + 40) addObject:v6];
  }
}

void sub_10029C3A0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_10029C664(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10029C6A8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 40LL));
  [WeakRetained didGenerateAdvertisement:*(void *)(a1 + 40) toSendOOBToPeer:*(void *)(a1 + 48)];
  [*(id *)(a1 + 32) _configureAdvertisementOOBRefreshTimerForToken:*(void *)(a1 + 48)];
}

void sub_10029C6F4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10029C90C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10029CA10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10029CBC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10029CDCC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10029CDF8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 40LL));
  [WeakRetained didLosePeer:*(void *)(a1 + 40)];
}

void sub_10029CE38( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10029D888(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v2 - 144), 8);
  _Unwind_Resume(a1);
}

const char *sub_10029D974(unint64_t a1)
{
  if (a1 > 0xA) {
    return "?";
  }
  else {
    return off_1007BBBD0[a1];
  }
}

void sub_10029D998(uint64_t a1, void *a2, void *a3)
{
  id v8 = a3;
  id v5 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
  id v6 = (void *)objc_claimAutoreleasedReturnValue([a2 descriptionInternal]);
  double v7 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"        %@: %@",  v6,  v8));
  [v5 addObject:v7];
}

void sub_10029DA2C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_10029DA58(uint64_t a1, void *a2, void *a3)
{
  id v10 = a3;
  id v5 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
  id v6 = (void *)objc_claimAutoreleasedReturnValue([a2 descriptionInternal]);
  id v7 = sub_100277B78(v10);
  id v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
  id v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"        %@: %@",  v6,  v8));
  [v5 addObject:v9];
}

void sub_10029DAFC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_10029DB34(uint64_t a1, void *a2, void *a3)
{
  id v8 = a3;
  id v5 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
  id v6 = (void *)objc_claimAutoreleasedReturnValue([a2 descriptionInternal]);
  id v7 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"        %@: %@",  v6,  v8));
  [v5 addObject:v7];
}

void sub_10029DBC8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_10029DCB4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_10029DD10(id a1, NIDiscoveryToken *a2, OS_dispatch_source *a3, BOOL *a4)
{
}

void sub_10029DD70(id a1, NIDiscoveryToken *a2, OS_dispatch_source *a3, BOOL *a4)
{
}

void sub_10029DD78(id a1, NIDiscoveryToken *a2, OS_dispatch_source *a3, BOOL *a4)
{
}

void sub_10029E26C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11)
{
  _Unwind_Resume(a1);
}

id sub_10029E2EC(uint64_t a1)
{
  return [*(id *)(a1 + 32) didDiscoverPeer:*(void *)(a1 + 40) advertisement:*(void *)(a1 + 48) overBluetooth:0];
}

void sub_10029E4F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10029E7B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10029E800(uint64_t a1, void *a2)
{
  id v5 = a2;
  id v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(void *)(a1 + 32) + 168), "objectForKey:"));
  id v4 = [v3 copy];

  [v4 setAddress:*(unsigned int *)(a1 + 40) | ((unint64_t)*(unsigned __int16 *)(a1 + 44) << 32)];
  [*(id *)(*(void *)(a1 + 32) + 168) setObject:v4 forKey:v5];
}

void sub_10029E888( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_10029E8B4(uint64_t a1, void *a2, void *a3)
{
  id v8 = a2;
  id v5 = a3;
  id v6 = (void *)objc_claimAutoreleasedReturnValue(+[_FindingAdvertiser sharedInstance](&OBJC_CLASS____FindingAdvertiser, "sharedInstance"));
  id v7 =  [v6 startAdvertisingAsFinder:*(unsigned __int8 *)(*(void *)(a1 + 32) + 32) toPeer:v8 withAdvertisement:v5];
}

void sub_10029E930( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_10029E954(uint64_t a1, void *a2, void *a3)
{
  id v6 = a2;
  id v5 = a3;
  [*(id *)(a1 + 32) didGenerateAdvertisement:v5 toSendOOBToPeer:v6];
  [*(id *)(a1 + 40) _configureAdvertisementOOBRefreshTimerForToken:v6];
}

void sub_10029E9B0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_10029EAB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10029EC64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10029ED8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10029EE50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10029EEF0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_10029EF08(uint64_t a1, void *a2)
{
  id v7 = a2;
  id v3 = (void *)objc_opt_new(&OBJC_CLASS___CBOOBKeyInfo);
  [v3 setKeyType:1];
  id v4 = (void *)objc_claimAutoreleasedReturnValue([v7 getIRK]);
  [v3 setIrkData:v4];

  id v5 = sub_1002784B8(v7);
  id v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
  [v3 setBtAddressData:v6];

  [*(id *)(a1 + 32) addObject:v3];
}

void sub_10029EFA8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_10029F0EC(uint64_t a1)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v2 = WeakRetained;
  if (WeakRetained)
  {
    if (![WeakRetained[17] count]
      && ((unint64_t)[v2[12] discoveryFlags] & 0x200100000) != 0)
    {
      id v3 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        v5[0] = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "#find-disc,NearbyActionNoWake: disabling scan dupes",  (uint8_t *)v5,  2u);
      }

      objc_msgSend( v2[12],  "setDiscoveryFlags:",  (unint64_t)objc_msgSend(v2[12], "discoveryFlags") & 0xFFFFFFFDFFEFFFFFLL);
    }

    id v4 = v2[15];
    v2[15] = 0LL;
  }
}

void sub_10029F1B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10029F5B0(_Unwind_Exception *a1)
{
}

void sub_10029F614(uint64_t a1, void *a2)
{
  uint64_t v2 = (id *)(a1 + 32);
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained(v2);
  [WeakRetained _cbDeviceFoundHandler:v3];
}

void sub_10029F65C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_10029F674(uint64_t a1, void *a2)
{
  id v3 = a2;
  double v4 = sub_100023CC4();
  double v5 = *(double *)(a1 + 40);
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  id v7 = WeakRetained;
  if (WeakRetained)
  {
    double v8 = v4 - v5;
    if (v3)
    {
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT)) {
        sub_1003A5C08();
      }
      id v9 = (os_log_s *)v7[12];
      v7[12] = 0LL;
    }

    else
    {
      *((_BYTE *)WeakRetained + 112) = 1;
      id v10 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained _nearbyActionNoWakeOOBKeysFromEligibleDiscoveryPeers]);
      [v7[12] setOobKeys:v10];

      if (![v7[17] count]) {
        [v7 _nearbyActionNoWakeDisableScanDupesIfNecessary];
      }
      double v11 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        id v12 = v7[12];
        int v14 = 134218243;
        double v15 = v8;
        __int16 v16 = 2113;
        id v17 = v12;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#find-disc,NearbyActionNoWake: activated scanner [%0.6f s]: %{private}@",  (uint8_t *)&v14,  0x16u);
      }

      id v9 = (os_log_s *)(id)qword_1008000A0;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        double v13 = (void *)objc_claimAutoreleasedReturnValue([v7[12] discoveredDevices]);
        int v14 = 138477827;
        double v15 = *(double *)&v13;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#find-disc,NearbyActionNoWake: discovered devices after activating scanner: %{private}@",  (uint8_t *)&v14,  0xCu);
      }
    }
  }
}

void sub_10029F840(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10029FB2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10029FB7C(uint64_t a1, void *a2)
{
  uint64_t v2 = (id *)(a1 + 32);
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained(v2);
  [WeakRetained _cbDeviceFoundHandler:v3];
}

void sub_10029FBC4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_10029FBDC(uint64_t a1, void *a2)
{
  id v3 = a2;
  double v4 = sub_100023CC4();
  double v5 = *(double *)(a1 + 40);
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v7 = WeakRetained;
  if (WeakRetained)
  {
    double v8 = v4 - v5;
    if (v3)
    {
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT)) {
        sub_1003A5C68();
      }
      id v9 = (void *)v7[13];
      v7[13] = 0LL;

      id v10 = (void *)v7[25];
      v7[25] = 0LL;
    }

    else
    {
      *((_BYTE *)WeakRetained + 112) = 1;
      uint64_t v11 = objc_claimAutoreleasedReturnValue(+[NSDate now](&OBJC_CLASS___NSDate, "now"));
      id v12 = (void *)v7[25];
      v7[25] = v11;

      double v13 = (void *)v7[16];
      v16[0] = _NSConcreteStackBlock;
      v16[1] = 3221225472LL;
      void v16[2] = sub_10029FDA0;
      v16[3] = &unk_1007B4198;
      void v16[4] = v7;
      [v13 enumerateObjectsUsingBlock:v16];
      int v14 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v15 = v7[13];
        *(_DWORD *)buf = 134218243;
        double v18 = v8;
        __int16 v19 = 2113;
        uint64_t v20 = v15;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "#find-disc,SpatialInteraction: activated scanner [%0.6f s]: %{private}@",  buf,  0x16u);
      }
    }
  }
}

void sub_10029FD78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_10029FDA0(uint64_t a1, void *a2)
{
  id v3 = a2;
  double v4 = sub_100023CC4();
  double v5 = *(void **)(*(void *)(a1 + 32) + 104LL);
  id v6 = (void *)objc_claimAutoreleasedReturnValue([v3 rawToken]);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472LL;
  void v8[2] = sub_10029FE7C;
  void v8[3] = &unk_1007B5538;
  double v10 = v4;
  id v7 = v3;
  id v9 = v7;
  [v5 addPeerToken:v6 completion:v8];
}

void sub_10029FE58( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_10029FE7C(uint64_t a1, void *a2)
{
  id v3 = a2;
  double v4 = sub_100023CC4() - *(double *)(a1 + 40);
  double v5 = (os_log_s *)qword_1008000A0;
  if (v3)
  {
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT)) {
      sub_1003A5CC8();
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 32);
    int v7 = 138478083;
    uint64_t v8 = v6;
    __int16 v9 = 2048;
    double v10 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "#find-disc,SpatialInteraction: added %{private}@ to scanner [%0.6f s]",  (uint8_t *)&v7,  0x16u);
  }
}

void sub_10029FF78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002A028C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20)
{
  uint64_t v24 = v23;

  _Block_object_dispose(&a15, 8);
  _Unwind_Resume(a1);
}

void sub_1002A0300(uint64_t a1, void *a2)
{
  id v9 = a2;
  id v3 = sub_1002784B8(v9);
  double v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  double v5 = (void *)objc_claimAutoreleasedReturnValue([v9 getIRK]);
  xpc_object_t v6 = xpc_dictionary_create(0LL, 0LL, 0LL);
  id v7 = v4;
  xpc_dictionary_set_data(v6, "btAd", [v7 bytes], (size_t)objc_msgSend(v7, "length"));
  id v8 = v5;
  xpc_dictionary_set_data(v6, "irkD", [v8 bytes], (size_t)objc_msgSend(v8, "length"));
  xpc_dictionary_set_uint64(v6, "irkT", 1uLL);
  xpc_array_set_value(*(xpc_object_t *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL), 0xFFFFFFFFFFFFFFFFLL, v6);
}

void sub_1002A0418( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1002A05B8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  _Unwind_Resume(a1);
}

void sub_1002A05FC(uint64_t a1)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    double v5 = WeakRetained;
    [WeakRetained[22] removeObjectForKey:*(void *)(a1 + 32)];
    id v3 = (void *)objc_claimAutoreleasedReturnValue([v5[21] objectForKey:*(void *)(a1 + 32)]);
    if (v3)
    {
      id v4 = objc_loadWeakRetained(v5 + 5);
      [v4 didGenerateAdvertisement:v3 toSendOOBToPeer:*(void *)(a1 + 32)];
      [v5 _configureAdvertisementOOBRefreshTimerForToken:*(void *)(a1 + 32)];
    }

    id WeakRetained = v5;
  }
}

void sub_1002A0694( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_1002A0850( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  _Unwind_Resume(a1);
}

void sub_1002A0894(uint64_t a1)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    xpc_object_t v6 = WeakRetained;
    [WeakRetained[23] removeObjectForKey:*(void *)(a1 + 32)];
    id v3 = (void *)objc_claimAutoreleasedReturnValue([v6[21] objectForKey:*(void *)(a1 + 32)]);

    id WeakRetained = v6;
    if (v3)
    {
      id v4 = [v6 stopAdvertisingToPeer:*(void *)(a1 + 32)];
      id v5 = objc_loadWeakRetained(v6 + 5);
      [v5 didStopAdvertisingToPeer:*(void *)(a1 + 32)];

      id WeakRetained = v6;
    }
  }
}

void sub_1002A0928( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1002A0AB0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  _Unwind_Resume(a1);
}

void sub_1002A0AF4(uint64_t a1)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    id v5 = WeakRetained;
    [WeakRetained[19] removeObjectForKey:*(void *)(a1 + 32)];
    id v3 = (void *)objc_claimAutoreleasedReturnValue([v5[17] objectForKey:*(void *)(a1 + 32)]);

    [v5 _resetDiscoveryStateForPeer:*(void *)(a1 + 32)];
    id WeakRetained = v5;
    if (v3)
    {
      id v4 = objc_loadWeakRetained(v5 + 5);
      [v4 didLosePeer:*(void *)(a1 + 32)];

      id WeakRetained = v5;
    }
  }
}

void sub_1002A0B80( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1002A0DB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002A0DF8(uint64_t a1, void *a2, _BYTE *a3)
{
  id v11 = a2;
  xpc_object_t v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) btAddressData]);
  id v7 = sub_100299CE4(v11, v6);
  id v8 = (void *)objc_claimAutoreleasedReturnValue(v7);

  id v9 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) nearbyActionNoWakeAuthTagData]);
  unsigned int v10 = [v8 isEqualToData:v9];

  if (v10)
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL), a2);
    *a3 = 1;
  }
}

void sub_1002A0EB0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1002A1144(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002A15B8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  _Unwind_Resume(a1);
}

void sub_1002A1904(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002A1B1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002A1C50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002A1F9C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002A20D0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1002A2404( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_1002A2644(_Unwind_Exception *a1)
{
  if (v3) {

  }
  _Unwind_Resume(a1);
}

void *sub_1002A2768(void *a1, uint64_t a2)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  return sub_1002A2A3C(a1, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
}

char *sub_1002A2798(char *result, uint64_t a2)
{
  return result;
}

void sub_1002A2818(id a1)
{
  if (+[NIPlatformInfo isInternalBuild](&OBJC_CLASS___NIPlatformInfo, "isInternalBuild"))
  {
    id v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](&OBJC_CLASS___NSUserDefaults, "standardUserDefaults"));
    byte_1007FE110 = [v1 BOOLForKey:@"FindingTestModeStaticAuthTag"];

    uint64_t v2 = qword_1008000A0;
    if (!os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    v7[0] = 67109120;
    v7[1] = byte_1007FE110;
    uint64_t v3 = "#find-disc,Static tag test mode: %d";
    id v4 = (os_log_s *)v2;
    uint32_t v5 = 8;
  }

  else
  {
    byte_1007FE110 = 0;
    uint64_t v6 = qword_1008000A0;
    if (!os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    LOWORD(v7[0]) = 0;
    uint64_t v3 = "#find-disc,Static tag test mode never allowed";
    id v4 = (os_log_s *)v6;
    uint32_t v5 = 2;
  }

  _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v3, (uint8_t *)v7, v5);
}

void sub_1002A2940(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002A2958(id a1)
{
  id v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](&OBJC_CLASS___NSUserDefaults, "standardUserDefaults"));
  byte_1007FE128 = [v1 BOOLForKey:@"FindingDisableClientDiscoveryEvents"];

  uint64_t v2 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    v3[0] = 67109120;
    v3[1] = byte_1007FE128;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "#find-disc,Disable client discovery events: %d",  (uint8_t *)v3,  8u);
  }

void sub_1002A2A24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *sub_1002A2A3C(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    BOOL result = sub_1000317D0(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      BOOL result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }

  return result;
}

void sub_1002A2A98(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

char *sub_1002A2AB4(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  id v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 2)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0LL;
      *uint64_t v7 = 0LL;
      v7[1] = 0LL;
      _DWORD v7[2] = 0LL;
    }

    if (a4 >> 62) {
      sub_10001E11C();
    }
    uint64_t v10 = v8 >> 1;
    if (v8 >> 1 <= a4) {
      uint64_t v10 = a4;
    }
    else {
      unint64_t v11 = v10;
    }
    BOOL result = sub_1000317D0(v7, v11);
    double v13 = (char *)v7[1];
    id v12 = (void **)(v7 + 1);
    id v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      double v18 = v9;
      __int16 v19 = __src;
      goto LABEL_18;
    }

    goto LABEL_19;
  }

  id v12 = (void **)(result + 8);
  int v14 = (_BYTE *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 2;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  __int16 v16 = &__src[4 * v15];
  if (v14 != v9)
  {
    BOOL result = (char *)memmove(*(void **)result, __src, v14 - v9);
    id v9 = (char *)*v12;
  }

  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    double v18 = v9;
    __int16 v19 = v16;
LABEL_18:
    BOOL result = (char *)memmove(v18, v19, v17);
  }

void sub_1002A2BBC( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

void *sub_1002A2BCC@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_1000065CC(a2, (&off_1007BBDD8)[a1]);
}

void *sub_1002A2BE0@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_1000065CC(a2, (&off_1007BBE30)[a1]);
}

void *sub_1002A2BF4@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_1000065CC(a2, (&off_1007BBE78)[a1]);
}

void *sub_1002A2C08@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_1000065CC(a2, (&off_1007BBE98)[a1]);
}

void sub_1002A2F44( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11)
{
  _Unwind_Resume(a1);
}

void sub_1002A3214( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, char a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
  if (a12 && __p) {
    operator delete(__p);
  }
  if (a13) {
    operator delete(a13);
  }

  _Unwind_Resume(a1);
}

void sub_1002A37CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

LABEL_213:
  return 0LL;
}

void sub_1002A4FA4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, uint64_t a21, void *a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, void *a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, char a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, void *a41)
{
  STACK[0x400] = (unint64_t)&STACK[0x310];
  sub_1002AE7B4((void ***)&STACK[0x400]);

  _Unwind_Resume(a1);
}

uint64_t sub_1002A54F8(uint64_t *a1, __int128 *a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= v6)
  {
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - *a1) >> 4);
    unint64_t v12 = v11 + 1;
    if (v11 + 1 > 0x555555555555555LL) {
      sub_10001E11C();
    }
    unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 4);
    if (2 * v13 > v12) {
      unint64_t v12 = 2 * v13;
    }
    if (v13 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v14 = 0x555555555555555LL;
    }
    else {
      unint64_t v14 = v12;
    }
    v20[4] = v4;
    if (v14) {
      unint64_t v15 = (char *)sub_100290108(v4, v14);
    }
    else {
      unint64_t v15 = 0LL;
    }
    __int16 v16 = &v15[48 * v11];
    v20[0] = v15;
    v20[1] = v16;
    v20[3] = &v15[48 * v14];
    __int128 v17 = *a2;
    *((void *)v16 + 2) = *((void *)a2 + 2);
    *(_OWORD *)__int16 v16 = v17;
    *((void *)a2 + 1) = 0LL;
    *((void *)a2 + 2) = 0LL;
    *(void *)a2 = 0LL;
    __int128 v18 = *(__int128 *)((char *)a2 + 24);
    *((_WORD *)v16 + 20) = *((_WORD *)a2 + 20);
    *(_OWORD *)(v16 + 24) = v18;
    v20[2] = v16 + 48;
    sub_1002AE840(a1, v20);
    uint64_t v10 = a1[1];
    sub_1002AE9D8((uint64_t)v20);
  }

  else
  {
    __int128 v8 = *a2;
    *(void *)(v7 + 16) = *((void *)a2 + 2);
    *(_OWORD *)unint64_t v7 = v8;
    *((void *)a2 + 1) = 0LL;
    *((void *)a2 + 2) = 0LL;
    *(void *)a2 = 0LL;
    __int128 v9 = *(__int128 *)((char *)a2 + 24);
    *(_WORD *)(v7 + 40) = *((_WORD *)a2 + 20);
    *(_OWORD *)(v7 + 24) = v9;
    uint64_t v10 = v7 + 48;
    a1[1] = v7 + 48;
  }

  a1[1] = v10;
  return v10 - 48;
}

void sub_1002A5640(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_1002A58C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002A663C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002A6850(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002A69A0(_Unwind_Exception *a1)
{
}

void sub_1002A6A88(_Unwind_Exception *a1)
{
}

void sub_1002A6B58(_Unwind_Exception *a1)
{
}

void sub_1002A6C1C(_Unwind_Exception *a1)
{
}

void sub_1002A6CEC(_Unwind_Exception *a1)
{
}

void sub_1002A7344( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, void *__p, uint64_t a22, int a23, __int16 a24, char a25, char a26, void *a27, uint64_t a28, int a29, __int16 a30, char a31, char a32, void *a33, uint64_t a34, int a35, __int16 a36, char a37, char a38, uint64_t a39, void *a40, uint64_t a41, int a42, __int16 a43, char a44, char a45)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  if (a38 < 0) {
    operator delete(a33);
  }

  _Unwind_Resume(a1);
}

void *sub_1002A74A4(void *a1, uint64_t a2, unint64_t a3)
{
  a1[2] = 0LL;
  uint64_t v4 = (uint64_t)(a1 + 2);
  *a1 = 0LL;
  a1[1] = 0LL;
  if (a3)
  {
    sub_1002AFB58(a1, a3);
    a1[1] = sub_1002AFBEC(v4, a2, a2 + 160 * a3, a1[1]);
  }

  return a1;
}

void sub_1002A7520( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + _Block_object_dispose((const void *)(v1 - 112), 8) = v10;
  sub_1002AFD60(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1002A7540@<X0>(int a1@<W0>, std::stringbuf::string_type *a2@<X8>, float a3@<S0>)
{
  uint64_t v6 = v8;
  *(std::locale::__imp **)((char *)&v9.__loc_.__locale_ + *(void *)(v8 - 24)) = (std::locale::__imp *)a1;
  *(_DWORD *)((char *)&v8 + *(void *)(v6 - 24) + _Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)((_BYTE *)&v8 + *(void *)(v6 - 24) + 8) & 0xFFFFFEFB | 4;
  std::ostream::operator<<(a3);
  std::stringbuf::str(a2, &v9);
  std::streambuf::~streambuf(&v9);
  return std::ios::~ios(&v10);
}

void sub_1002A762C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_1002A84E4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, uint64_t a20, uint64_t a21, uint64_t a22, void *a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, void *__p, uint64_t a30)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1002A8994(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002A8B44( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  _Unwind_Resume(a1);
}

void sub_1002A90C0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, void *__p, uint64_t a22, int a23, __int16 a24, char a25, char a26, char a27)
{
  _Unwind_Resume(a1);
}

void *sub_1002A9174()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_1007F4538);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_1007F4538)) {
    __cxa_guard_release(&qword_1007F4538);
  }
  return &unk_1007F4530;
}

void sub_1002A92B4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1002A93CC(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    uint64_t v4 = (void *)sub_10031270C();
    operator delete(v4);
  }

void sub_1002A9E74( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20, void *a21)
{
  _Unwind_Resume(a1);
}

void sub_1002AA304(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002AA480(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002AA6A4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p, uint64_t a21)
{
  sub_10011B2B0(&a11);
  _Unwind_Resume(a1);
}

void sub_1002AADA0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25, void *a26, uint64_t a27, int a28, __int16 a29, char a30, char a31, void *a32, uint64_t a33, int a34, __int16 a35, char a36, char a37, void *a38, uint64_t a39, int a40, __int16 a41, char a42, char a43, void *__p, uint64_t a45)
{
  if (__p) {
    operator delete(__p);
  }

  if (a43 < 0) {
    operator delete(a38);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_1002AAEF8@<X0>(std::stringbuf::string_type *a1@<X8>, double a2@<D0>)
{
  *(void *)((char *)&v6[2] + *(void *)(v6[0] - 24LL)) = 4LL;
  std::ostream::operator<<(&v7, a2);
  std::stringbuf::str(a1, &v8);
  *(void *)((char *)v6
  uint64_t v7 = v4;
  std::streambuf::~streambuf(&v8);
  return std::ios::~ios(&v9);
}

void sub_1002AAFC8(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_1002AB160( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1002AB838( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, void *__p, uint64_t a38)
{
  _Unwind_Resume(a1);
}

void sub_1002ABE94( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, void *__p, uint64_t a48)
{
  _Unwind_Resume(a1);
}

void sub_1002AC2C4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *__p, uint64_t a24)
{
  _Unwind_Resume(a1);
}

void sub_1002ACA20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002ACF40( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_1002AD010( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_1002AD35C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002AD554(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002AD670(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002AD794(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002AD8D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002AD9B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002ADA40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002ADACC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002ADBFC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_1002ADD20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002AE074(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  sub_1001DF850((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1002AE1A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002AE310(_Unwind_Exception *a1)
{
  sub_100034A98(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_1002AE548(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002AE634(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002AE700(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *sub_1002AE73C(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    BOOL result = sub_10011B5D8(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      BOOL result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }

  return result;
}

void sub_1002AE798(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_1002AE7B4(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_1002AE7F4((uint64_t *)v2);
    operator delete(**a1);
  }

void sub_1002AE7F4(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 48LL)
  {
  }

  a1[1] = v2;
}

uint64_t sub_1002AE840(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1002AE8B4((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1002AE8B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&__int128 v16 = a6;
  *((void *)&v16 + 1) = a7;
  __int128 v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 != a5)
  {
    uint64_t v9 = a7;
    do
    {
      __int128 v10 = *(_OWORD *)(a3 - 48);
      *(void *)(v9 - 32) = *(void *)(a3 - 32);
      *(_OWORD *)(v9 - 4_Block_object_dispose((const void *)(v1 - 112), 8) = v10;
      *(void *)(a3 - 40) = 0LL;
      *(void *)(a3 - 32) = 0LL;
      *(void *)(a3 - 4_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
      __int128 v11 = *(_OWORD *)(a3 - 24);
      *(_WORD *)(v9 - _Block_object_dispose((const void *)(v1 - 112), 8) = *(_WORD *)(a3 - 8);
      *(_OWORD *)(v9 - 24) = v11;
      v9 -= 48LL;
      v7 -= 48LL;
      a3 -= 48LL;
    }

    while (a3 != a5);
    *((void *)&v16 + 1) = v9;
  }

  char v14 = 1;
  sub_1002AE960((uint64_t)v13);
  return a6;
}

uint64_t sub_1002AE960(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_1002AE994(a1);
  }
  return a1;
}

void sub_1002AE994(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8LL);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8LL);
  while (v1 != v2)
  {
    v1 += 48LL;
  }

uint64_t sub_1002AE9D8(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1002AEA0C(uint64_t a1, void **a2)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      uint64_t v5 = v2 - 6;
      *(void *)(a1 + 16) = v2 - 6;
      if (*((char *)v2 - 25) < 0)
      {
        operator delete(*v5);
        uint64_t v5 = *(void ***)(a1 + 16);
      }

      uint64_t v2 = v5;
    }

    while (v5 != a2);
  }

uint64_t *sub_1002AEA60(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0LL;
  a1[1] = 0LL;
  *a1 = (uint64_t)(a1 + 1);
  sub_10025D5BC(a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_1002AEA9C(_Unwind_Exception *a1)
{
}

uint64_t sub_1002AEAB4(uint64_t a1)
{
  return a1;
}

void sub_1002AEADC(id *a1)
{
}

void *sub_1002AEB04(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1007BBC38;
  v2[1] = *(id *)(a1 + 8);
  return v2;
}

id sub_1002AEB48(uint64_t a1, void *a2)
{
  *a2 = off_1007BBC38;
  id result = *(id *)(a1 + 8);
  a2[1] = result;
  return result;
}

void sub_1002AEB7C(uint64_t a1)
{
}

void sub_1002AEB84(id *a1)
{
}

void sub_1002AEBAC( uint64_t a1, double *a2, uint64_t *a3, uint64_t a4, uint64_t a5, __int128 *a6, uint64_t *a7, unsigned __int8 *a8)
{
  double v8 = *a2;
  uint64_t v9 = *a3;
  LOBYTE(v30[0]) = 0;
  char v34 = 0;
  if (*(_BYTE *)(a4 + 48))
  {
    *(_OWORD *)int v30 = *(_OWORD *)a4;
    uint64_t v31 = *(void *)(a4 + 16);
    *(void *)(a4 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
    *(void *)(a4 + 16) = 0LL;
    *(void *)a4 = 0LL;
    __int128 v32 = *(_OWORD *)(a4 + 24);
    __int16 v33 = *(_WORD *)(a4 + 40);
    char v34 = 1;
  }

  LOBYTE(__p[0]) = 0;
  char v29 = 0;
  if (*(_BYTE *)(a5 + 48))
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a5;
    uint64_t v26 = *(void *)(a5 + 16);
    *(void *)(a5 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
    *(void *)(a5 + 16) = 0LL;
    *(void *)a5 = 0LL;
    __int128 v27 = *(_OWORD *)(a5 + 24);
    __int16 v28 = *(_WORD *)(a5 + 40);
    char v29 = 1;
  }

  __int128 v21 = a6[8];
  __int128 v22 = a6[9];
  __int128 v23 = a6[10];
  __int128 v24 = a6[11];
  __int128 v17 = a6[4];
  __int128 v18 = a6[5];
  __int128 v19 = a6[6];
  __int128 v20 = a6[7];
  __int128 v13 = *a6;
  __int128 v14 = a6[1];
  __int128 v15 = a6[2];
  __int128 v16 = a6[3];
  uint64_t v10 = *a7;
  int v11 = *a8;
  unint64_t v12 = *(void **)(a1 + 8);
  sub_1002AEE40((char *)v39, (__int128 *)v30);
  sub_1002AEE40((char *)v36, (__int128 *)__p);
  v35[8] = v21;
  v35[9] = v22;
  v35[10] = v23;
  v35[11] = v24;
  v35[4] = v17;
  void v35[5] = v18;
  v35[6] = v19;
  v35[7] = v20;
  v35[0] = v13;
  v35[1] = v14;
  uint8_t v35[2] = v15;
  v35[3] = v16;
  [v12 _handleRegionChangeForDevice:v9 currentRegion:v39 prevRegion:v36 timestamp:v35 rangeResult:v10 intentPrediction:v11 != 0 regionTransitionSuppressed:v8];
  if (v38 && v37 < 0) {
    operator delete(v36[0]);
  }
  if (v41 && v40 < 0) {
    operator delete(v39[0]);
  }
  if (v29 && SHIBYTE(v26) < 0) {
    operator delete(__p[0]);
  }
  if (v34)
  {
    if (SHIBYTE(v31) < 0) {
      operator delete(v30[0]);
    }
  }

void sub_1002AED7C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, void *__p, uint64_t a34, int a35, __int16 a36, char a37, char a38, uint64_t a39, uint64_t a40, uint64_t a41, char a42, uint64_t a43, void *a44, uint64_t a45, int a46, __int16 a47, char a48, char a49, uint64_t a50,uint64_t a51,uint64_t a52,char a53)
{
  if (a42 && a38 < 0) {
    operator delete(__p);
  }
  if (a53)
  {
    if (a49 < 0) {
      operator delete(a44);
    }
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1002AEDF8(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_1002AEE34()
{
  return &off_1007BBCA8;
}

char *sub_1002AEE40(char *a1, __int128 *a2)
{
  *a1 = 0;
  a1[48] = 0;
  sub_1002AEE88(a1, a2);
  return a1;
}

void sub_1002AEE6C(_Unwind_Exception *exception_object)
{
  if (*(_BYTE *)(v1 + 48)) {
    sub_1003A6970((void **)v1);
  }
  _Unwind_Resume(exception_object);
}

__n128 sub_1002AEE88(char *__dst, __int128 *a2)
{
  if (*((_BYTE *)a2 + 48))
  {
    if (*((char *)a2 + 23) < 0)
    {
      sub_1000063A8(__dst, *(void **)a2, *((void *)a2 + 1));
    }

    else
    {
      __int128 v4 = *a2;
      *((void *)__dst + 2) = *((void *)a2 + 2);
      *(_OWORD *)__int128 __dst = v4;
    }

    __n128 result = *(__n128 *)((char *)a2 + 24);
    *((_WORD *)__dst + 20) = *((_WORD *)a2 + 20);
    *(__n128 *)(__dst + 24) = result;
    __dst[48] = 1;
  }

  return result;
}

uint64_t sub_1002AEEF0(uint64_t a1)
{
  return a1;
}

void sub_1002AEF18(id *a1)
{
}

void *sub_1002AEF40(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1007BBCC8;
  v2[1] = *(id *)(a1 + 8);
  return v2;
}

id sub_1002AEF84(uint64_t a1, void *a2)
{
  *a2 = off_1007BBCC8;
  id result = *(id *)(a1 + 8);
  a2[1] = result;
  return result;
}

void sub_1002AEFB8(uint64_t a1)
{
}

void sub_1002AEFC0(id *a1)
{
}

void sub_1002AEFE8( uint64_t a1, unsigned __int8 *a2, uint64_t *a3, double *a4, unsigned int *a5, __int128 *a6, unsigned int *a7)
{
  int v7 = *a2;
  uint64_t v8 = *a3;
  double v9 = *a4;
  uint64_t v10 = *a5;
  LOBYTE(v13) = 0;
  char v15 = 0;
  if (*((_BYTE *)a6 + 24))
  {
    __int128 v13 = *a6;
    uint64_t v14 = *((void *)a6 + 2);
    *((void *)a6 + 1) = 0LL;
    *((void *)a6 + 2) = 0LL;
    *(void *)a6 = 0LL;
    char v15 = 1;
  }

  else if (v7)
  {
    __assert_rtn("operator()", "NIServerNearbyUpdatesEngine.mm", 405, "regionsVector.has_value()");
  }

  uint64_t v11 = *a7;
  unint64_t v12 = *(void **)(a1 + 8);
  sub_1002AF180((char *)v16, (uint64_t)&v13);
  objc_msgSend( v12,  "_handleDeviceMonitorActivation:forDevice:timestamp:regionSizeCategory:regions:predictorType:",  v7 != 0,  v8,  v10,  v16,  v11,  v9,  v13,  v14);
  if (v17)
  {
    __int128 v18 = v16;
    sub_1002AE7B4((void ***)&v18);
  }

  if (v15)
  {
    v16[0] = (void **)&v13;
    sub_1002AE7B4(v16);
  }

void sub_1002AF0F4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, char a17, uint64_t *a18)
{
  if (a17)
  {
    a18 = (uint64_t *)&a14;
    sub_1002AE7B4((void ***)&a18);
  }

  if (a12)
  {
    a18 = &a9;
    sub_1002AE7B4((void ***)&a18);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1002AF138(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_1002AF174()
{
  return &off_1007BBD38;
}

char *sub_1002AF180(char *a1, uint64_t a2)
{
  *a1 = 0;
  a1[24] = 0;
  sub_1002AF1D4(a1, a2);
  return a1;
}

void sub_1002AF1B4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (*(_BYTE *)(v10 + 24))
  {
    a10 = v10;
    sub_1002AE7B4((void ***)&a10);
  }

  _Unwind_Resume(exception_object);
}

char *sub_1002AF1D4(char *result, uint64_t a2)
{
  if (*(_BYTE *)(a2 + 24))
  {
    uint64_t v2 = result;
    *(void *)id result = 0LL;
    *((void *)result + 1) = 0LL;
    *((void *)result + 2) = 0LL;
    id result = sub_1002AF228( result,  *(__int128 **)a2,  *(__int128 **)(a2 + 8),  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4));
    v2[24] = 1;
  }

  return result;
}

char *sub_1002AF228(char *result, __int128 *a2, __int128 *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    sub_1002AF2AC(result, a4);
    id result = sub_1002AF2FC((uint64_t)(v6 + 16), a2, a3, *((char **)v6 + 1));
    *((void *)v6 + 1) = result;
  }

  return result;
}

void sub_1002AF28C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + _Block_object_dispose((const void *)(v1 - 112), 8) = v10;
  sub_1002AE7B4(&a9);
  _Unwind_Resume(a1);
}

char *sub_1002AF2AC(void *a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556LL) {
    sub_10001E11C();
  }
  id result = (char *)sub_100290108((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[48 * v4];
  return result;
}

char *sub_1002AF2FC(uint64_t a1, __int128 *a2, __int128 *a3, char *__dst)
{
  uint64_t v4 = __dst;
  __int128 v13 = __dst;
  uint64_t v14 = __dst;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  char v12 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      if (*((char *)v6 + 23) < 0)
      {
        sub_1000063A8(v4, *(void **)v6, *((void *)v6 + 1));
        uint64_t v8 = v14;
      }

      else
      {
        __int128 v7 = *v6;
        *((void *)v4 + 2) = *((void *)v6 + 2);
        *(_OWORD *)uint64_t v4 = v7;
        uint64_t v8 = v4;
      }

      __int128 v9 = *(__int128 *)((char *)v6 + 24);
      *((_WORD *)v4 + 20) = *((_WORD *)v6 + 20);
      *(_OWORD *)(v4 + 24) = v9;
      v6 += 3;
      uint64_t v4 = v8 + 48;
      uint64_t v14 = v8 + 48;
    }

    while (v6 != a3);
  }

  char v12 = 1;
  sub_1002AF3CC((uint64_t)v11);
  return v4;
}

void sub_1002AF3B8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1002AF3CC(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_1002AF400(a1);
  }
  return a1;
}

void sub_1002AF400(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 16);
  uint64_t v2 = **(void **)(a1 + 8);
  while (v1 != v2)
  {
    v1 -= 48LL;
  }

uint64_t sub_1002AF444(uint64_t a1)
{
  return a1;
}

void sub_1002AF46C(id *a1)
{
}

void *sub_1002AF494(uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_1007BBD58;
  v2[1] = *(id *)(a1 + 8);
  return v2;
}

id sub_1002AF4D8(uint64_t a1, void *a2)
{
  *a2 = off_1007BBD58;
  id result = *(id *)(a1 + 8);
  a2[1] = result;
  return result;
}

void sub_1002AF50C(uint64_t a1)
{
}

void sub_1002AF514(id *a1)
{
}

id sub_1002AF53C(uint64_t a1, double *a2, uint64_t *a3, _OWORD *a4)
{
  double v4 = *a2;
  uint64_t v5 = *a3;
  __int128 v6 = a4[9];
  v13[8] = a4[8];
  v13[9] = v6;
  __int128 v7 = a4[11];
  v13[10] = a4[10];
  v13[11] = v7;
  __int128 v8 = a4[5];
  void v13[4] = a4[4];
  v13[5] = v8;
  __int128 v9 = a4[7];
  v13[6] = a4[6];
  v13[7] = v9;
  __int128 v10 = a4[1];
  v13[0] = *a4;
  v13[1] = v10;
  __int128 v11 = a4[3];
  v13[2] = a4[2];
  void v13[3] = v11;
  return [*(id *)(a1 + 8) _handleBoundedRegionRange:v5 forDevice:v13 rangeResult:v4];
}

uint64_t sub_1002AF598(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_1002AF5D4()
{
  return &off_1007BBDC8;
}

void *sub_1002AF5E0(uint64_t a1, unint64_t *a2, uint64_t a3, void **a4, uint64_t **a5)
{
  unint64_t v9 = *a2;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v5 = *a2;
      if (v9 >= v10) {
        unint64_t v5 = v9 % v10;
      }
    }

    else
    {
      unint64_t v5 = (v10 - 1) & v9;
    }

    char v12 = *(void ***)(*(void *)a1 + 8 * v5);
    if (v12)
    {
      for (uint64_t i = *v12; i; uint64_t i = (void *)*i)
      {
        unint64_t v14 = i[1];
        if (v14 == v9)
        {
          if (i[2] == v9) {
            return i;
          }
        }

        else
        {
          if (v11.u32[0] > 1uLL)
          {
            if (v14 >= v10) {
              v14 %= v10;
            }
          }

          else
          {
            v14 &= v10 - 1;
          }

          if (v14 != v5) {
            break;
          }
        }
      }
    }
  }

  char v15 = (void *)(a1 + 16);
  uint64_t i = operator new(0x20uLL);
  void *i = 0LL;
  i[1] = v9;
  __int128 v16 = *a5;
  i[2] = **a4;
  uint64_t v17 = *v16;
  *__int128 v16 = 0LL;
  i[3] = v17;
  float v18 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v19 = *(float *)(a1 + 32);
  if (!v10 || (float)(v19 * (float)v10) < v18)
  {
    BOOL v20 = 1LL;
    if (v10 >= 3) {
      BOOL v20 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v21 = v20 | (2 * v10);
    unint64_t v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22) {
      size_t v23 = v22;
    }
    else {
      size_t v23 = v21;
    }
    sub_100021B74(a1, v23);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v5 = v9 % v10;
      }
      else {
        unint64_t v5 = v9;
      }
    }

    else
    {
      unint64_t v5 = (v10 - 1) & v9;
    }
  }

  uint64_t v24 = *(void *)a1;
  uint64_t v25 = *(void **)(*(void *)a1 + 8 * v5);
  if (v25)
  {
    void *i = *v25;
LABEL_38:
    *uint64_t v25 = i;
    goto LABEL_39;
  }

  void *i = *v15;
  void *v15 = i;
  *(void *)(v24 + 8 * v5) = v15;
  if (*i)
  {
    unint64_t v26 = *(void *)(*i + 8LL);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v26 >= v10) {
        v26 %= v10;
      }
    }

    else
    {
      v26 &= v10 - 1;
    }

    uint64_t v25 = (void *)(*(void *)a1 + 8 * v26);
    goto LABEL_38;
  }

void sub_1002AF820( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
}

void sub_1002AF83C(uint64_t a1, uint64_t *__p)
{
  if (*(_BYTE *)(a1 + 8)) {
    sub_1002A93CC(__p + 3, 0LL);
  }
  if (__p) {
    operator delete(__p);
  }
}

void sub_1002AF880(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    unint64_t v5 = (void **)(a2 + 528);
    sub_1002AF8FC(&v5);
    sub_100030A5C((void *)(a2 + 456));
    uint64_t v3 = *(void **)(a2 + 136);
    *(void *)(a2 + 136) = 0LL;
    if (v3) {
      operator delete(v3);
    }
    if (*(_BYTE *)(a2 + 128))
    {
      double v4 = *(void **)(a2 + 96);
      if (v4)
      {
        *(void *)(a2 + 104) = v4;
        operator delete(v4);
      }
    }

    sub_1002AF988((uint64_t *)(a2 + 72), 0LL);
    operator delete((void *)a2);
  }

void sub_1002AF8FC(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_1002AF93C((uint64_t *)v2);
    operator delete(**a1);
  }

void sub_1002AF93C(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 96LL)
  {
  }

  a1[1] = v2;
}

void sub_1002AF988(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    double v4 = (void *)sub_1002AF9B4(v3);
    operator delete(v4);
  }

uint64_t sub_1002AF9B4(uint64_t a1)
{
  *(void *)(a1 + 856) = off_1007AED90;
  *(void *)(a1 + 776) = off_1007AED90;
  __int128 v7 = (void **)(a1 + 712);
  sub_1002AFA80(&v7);
  __int128 v7 = (void **)(a1 + 688);
  sub_1002AFAC0(&v7);
  __int128 v7 = (void **)(a1 + 664);
  sub_1002AFA80(&v7);
  *(void *)(a1 + 536) = off_1007AED90;
  *(void *)(a1 + 472) = off_1007AED90;
  *(void *)(a1 + 336) = off_1007AED90;
  *(void *)(a1 + 264) = off_1007AED90;
  *(void *)(a1 + 192) = off_1007AED90;
  __int128 v7 = (void **)(a1 + 168);
  sub_1002AFB04(&v7);
  uint64_t v2 = *(void **)(a1 + 136);
  if (v2)
  {
    *(void *)(a1 + 144) = v2;
    operator delete(v2);
  }

  uint64_t v3 = *(void **)(a1 + 88);
  if (v3)
  {
    *(void *)(a1 + 96) = v3;
    operator delete(v3);
  }

  double v4 = *(void **)(a1 + 40);
  if (v4)
  {
    *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v4;
    operator delete(v4);
  }

  unint64_t v5 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v5;
    operator delete(v5);
  }

  return a1;
}

void sub_1002AFA80(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    v1[1] = v2;
    operator delete(v2);
  }

void sub_1002AFAC0(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    for (uint64_t i = (char *)v1[1]; i != v2; i -= 208)
    {
      *((void *)i - 14) = off_1007AED90;
      *((void *)i - 22) = off_1007AED90;
    }

    v1[1] = v2;
    operator delete(v2);
  }

void sub_1002AFB04(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v3 = (char *)v1[1];
    if (v3 != v2)
    {
      double v4 = v3 - 192;
      do
      {
        *((void *)v4 + 16) = off_1007AED90;
        *(void *)double v4 = off_1007AED90;
        *((void *)v4 - 14) = off_1007AED90;
        *((void *)v4 - 22) = off_1007AED90;
        *((void *)v4 - 30) = off_1007AED90;
        BOOL v5 = v4 - 240 == v2;
        v4 -= 432;
      }

      while (!v5);
    }

    v1[1] = v2;
    operator delete(v2);
  }

char *sub_1002AFB58(void *a1, unint64_t a2)
{
  if (a2 >= 0x19999999999999ALL) {
    sub_10001E11C();
  }
  id result = (char *)sub_1002AFBA8((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[160 * v4];
  return result;
}

void *sub_1002AFBA8(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x19999999999999ALL) {
    sub_10001D350();
  }
  return operator new(160 * a2);
}

uint64_t sub_1002AFBEC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v16 = a4;
  uint64_t v17 = a4;
  v14[0] = a1;
  v14[1] = &v16;
  uint64_t v14[2] = &v17;
  char v15 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      *(void *)uint64_t v4 = 0LL;
      *(void *)(v4 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
      *(void *)(v4 + 16) = 0LL;
      sub_1001309C0((void *)v4, *(const void **)v6, *(void *)(v6 + 8), *(void *)(v6 + 8) - *(void *)v6);
      *(_OWORD *)(v4 + 24) = *(_OWORD *)(v6 + 24);
      __int128 v7 = *(_OWORD *)(v6 + 40);
      __int128 v8 = *(_OWORD *)(v6 + 56);
      __int128 v9 = *(_OWORD *)(v6 + 72);
      *(_OWORD *)(v4 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = *(_OWORD *)(v6 + 88);
      *(_OWORD *)(v4 + 72) = v9;
      *(_OWORD *)(v4 + 56) = v8;
      *(_OWORD *)(v4 + 40) = v7;
      __int128 v10 = *(_OWORD *)(v6 + 104);
      __int128 v11 = *(_OWORD *)(v6 + 120);
      __int128 v12 = *(_OWORD *)(v6 + 136);
      *(_BYTE *)(v4 + 152) = *(_BYTE *)(v6 + 152);
      *(_OWORD *)(v4 + 136) = v12;
      *(_OWORD *)(v4 + 120) = v11;
      *(_OWORD *)(v4 + 104) = v10;
      uint64_t v4 = v17 + 160;
      v17 += 160LL;
      v6 += 160LL;
    }

    while (v6 != a3);
  }

  char v15 = 1;
  sub_1002AFCE0((uint64_t)v14);
  return v4;
}

void sub_1002AFCCC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1002AFCE0(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_1002AFD14(a1);
  }
  return a1;
}

void sub_1002AFD14(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 16);
  uint64_t v2 = **(void **)(a1 + 8);
  if (v1 != v2)
  {
    uint64_t v3 = **(void **)(a1 + 16);
    do
    {
      BOOL v5 = *(void **)(v3 - 160);
      v3 -= 160LL;
      uint64_t v4 = v5;
      if (v5)
      {
        *(void *)(v1 - 152) = v4;
        operator delete(v4);
      }

      uint64_t v1 = v3;
    }

    while (v3 != v2);
  }

void sub_1002AFD60(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_1002AFDA0((uint64_t *)v2);
    operator delete(**a1);
  }

void sub_1002AFDA0(uint64_t *a1)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  if (v2 != *a1)
  {
    uint64_t v4 = a1[1];
    do
    {
      uint64_t v6 = *(void **)(v4 - 160);
      v4 -= 160LL;
      BOOL v5 = v6;
      if (v6)
      {
        *(void *)(v2 - 152) = v5;
        operator delete(v5);
      }

      uint64_t v2 = v4;
    }

    while (v4 != v3);
  }

  a1[1] = v3;
}

void *sub_1002AFDF4(uint64_t a1, unint64_t *a2, uint64_t a3, void **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
    }

    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }

    __int128 v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      for (uint64_t i = *v10; i; uint64_t i = (void *)*i)
      {
        unint64_t v12 = i[1];
        if (v12 == v7)
        {
          if (i[2] == v7) {
            return i;
          }
        }

        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= v8) {
              v12 %= v8;
            }
          }

          else
          {
            v12 &= v8 - 1;
          }

          if (v12 != v4) {
            break;
          }
        }
      }
    }
  }

  __int128 v13 = (void *)(a1 + 16);
  uint64_t i = operator new(0x20uLL);
  void *i = 0LL;
  i[1] = v7;
  i[2] = **a4;
  i[3] = 0LL;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v15 = *(float *)(a1 + 32);
  if (!v8 || (float)(v15 * (float)v8) < v14)
  {
    BOOL v16 = 1LL;
    if (v8 >= 3) {
      BOOL v16 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v8);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t v19 = v18;
    }
    else {
      size_t v19 = v17;
    }
    sub_100021B74(a1, v19);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }

    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }

  uint64_t v20 = *(void *)a1;
  unint64_t v21 = *(void **)(*(void *)a1 + 8 * v4);
  if (v21)
  {
    void *i = *v21;
LABEL_38:
    *unint64_t v21 = i;
    goto LABEL_39;
  }

  void *i = *v13;
  void *v13 = i;
  *(void *)(v20 + 8 * v4) = v13;
  if (*i)
  {
    unint64_t v22 = *(void *)(*i + 8LL);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v22 >= v8) {
        v22 %= v8;
      }
    }

    else
    {
      v22 &= v8 - 1;
    }

    unint64_t v21 = (void *)(*(void *)a1 + 8 * v22);
    goto LABEL_38;
  }

void sub_1002B0020(_Unwind_Exception *a1)
{
}

void *sub_1002B003C(void *a1, unint64_t *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0LL;
  }
  unint64_t v3 = *a2;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = *a2;
    if (v3 >= *(void *)&v2) {
      unint64_t v5 = v3 % *(void *)&v2;
    }
  }

  else
  {
    unint64_t v5 = (*(void *)&v2 - 1LL) & v3;
  }

  uint64_t v6 = *(void **)(*a1 + 8 * v5);
  if (!v6) {
    return 0LL;
  }
  id result = (void *)*v6;
  if (*v6)
  {
    do
    {
      unint64_t v8 = result[1];
      if (v3 == v8)
      {
        if (result[2] == v3) {
          return result;
        }
      }

      else
      {
        if (v4.u32[0] > 1uLL)
        {
          if (v8 >= *(void *)&v2) {
            v8 %= *(void *)&v2;
          }
        }

        else
        {
          v8 &= *(void *)&v2 - 1LL;
        }

        if (v8 != v5) {
          return 0LL;
        }
      }

      id result = (void *)*result;
    }

    while (result);
  }

  return result;
}

void sub_1002B00F0(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1002B00F0(a1, *a2);
    sub_1002B00F0(a1, a2[1]);
    sub_1002B0138((uint64_t)(a2 + 4));
    operator delete(a2);
  }

void sub_1002B0138(uint64_t a1)
{
}

uint64_t *sub_1002B0174(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5 = (uint64_t **)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    double v6 = *(double *)(a2 + 8);
    while (1)
    {
      while (1)
      {
        unint64_t v7 = (uint64_t *)v4;
        double v8 = *(double *)(v4 + 40);
        if (v6 >= v8) {
          break;
        }
        uint64_t v4 = *(void *)v4;
        unint64_t v5 = (uint64_t **)v7;
        if (!*v7) {
          goto LABEL_10;
        }
      }

      if (v8 >= v6) {
        break;
      }
      uint64_t v4 = *(void *)(v4 + 8);
      if (!v4)
      {
        unint64_t v5 = (uint64_t **)(v7 + 1);
        goto LABEL_10;
      }
    }
  }

  else
  {
    unint64_t v7 = (uint64_t *)(a1 + 8);
LABEL_10:
    sub_1002B0234(a1, a3, (uint64_t)v10);
    sub_10001E548((uint64_t **)a1, (uint64_t)v7, v5, v10[0]);
    unint64_t v7 = v10[0];
    v10[0] = 0LL;
    sub_1002B0384((uint64_t)v10, 0LL);
  }

  return v7;
}

void sub_1002B0234(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  double v6 = operator new(0x160uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + _Block_object_dispose((const void *)(v1 - 112), 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  sub_1002B02A0(v5, (uint64_t)v6 + 32, a2);
  *(_BYTE *)(a3 + 16) = 1;
}

void sub_1002B0288(_Unwind_Exception *a1)
{
}

__n128 sub_1002B02A0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)a2 = *(_OWORD *)a3;
  sub_100201E2C((uint64_t *)(a2 + 16), a3 + 16);
  __int128 v5 = *(_OWORD *)(a3 + 40);
  *(_OWORD *)(a2 + 52) = *(_OWORD *)(a3 + 52);
  *(_OWORD *)(a2 + 40) = v5;
  sub_100201F04(a2 + 72, (__int128 *)(a3 + 72));
  __int128 v6 = *(_OWORD *)(a3 + 104);
  *(_OWORD *)(a2 + 120) = *(_OWORD *)(a3 + 120);
  *(_OWORD *)(a2 + 104) = v6;
  __int128 v7 = *(_OWORD *)(a3 + 136);
  __int128 v8 = *(_OWORD *)(a3 + 152);
  __int128 v9 = *(_OWORD *)(a3 + 168);
  *(_OWORD *)(a2 + 184) = *(_OWORD *)(a3 + 184);
  *(_OWORD *)(a2 + 16_Block_object_dispose((const void *)(v1 - 112), 8) = v9;
  *(_OWORD *)(a2 + 152) = v8;
  *(_OWORD *)(a2 + 136) = v7;
  __int128 v10 = *(_OWORD *)(a3 + 200);
  __int128 v11 = *(_OWORD *)(a3 + 216);
  __int128 v12 = *(_OWORD *)(a3 + 232);
  *(_OWORD *)(a2 + 24_Block_object_dispose((const void *)(v1 - 112), 8) = *(_OWORD *)(a3 + 248);
  *(_OWORD *)(a2 + 232) = v12;
  *(_OWORD *)(a2 + 216) = v11;
  *(_OWORD *)(a2 + 200) = v10;
  __n128 result = *(__n128 *)(a3 + 264);
  __int128 v14 = *(_OWORD *)(a3 + 280);
  __int128 v15 = *(_OWORD *)(a3 + 296);
  *(void *)(a2 + 312) = *(void *)(a3 + 312);
  *(_OWORD *)(a2 + 280) = v14;
  *(_OWORD *)(a2 + 296) = v15;
  *(__n128 *)(a2 + 264) = result;
  return result;
}

void sub_1002B036C(_Unwind_Exception *a1)
{
}

void sub_1002B0384(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16)) {
      sub_1002B0138((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }

uint64_t *sub_1002B03C8(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0LL;
  a1[1] = 0LL;
  *a1 = (uint64_t)(a1 + 1);
  sub_1002B041C(a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_1002B0404(_Unwind_Exception *a1)
{
}

uint64_t *sub_1002B041C(uint64_t *result, void *a2, void *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    __int128 v5 = (uint64_t **)result;
    __int128 v6 = (double *)(result + 1);
    do
    {
      __n128 result = sub_1002B04A0(v5, v6, (uint64_t)(v4 + 4), (uint64_t)(v4 + 4));
      __int128 v7 = (void *)v4[1];
      if (v7)
      {
        do
        {
          __int128 v8 = v7;
          __int128 v7 = (void *)*v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          __int128 v8 = (void *)v4[2];
          BOOL v9 = *v8 == (void)v4;
          uint64_t v4 = v8;
        }

        while (!v9);
      }

      uint64_t v4 = v8;
    }

    while (v8 != a3);
  }

  return result;
}

uint64_t *sub_1002B04A0(uint64_t **a1, double *a2, uint64_t a3, uint64_t a4)
{
  __int128 v6 = sub_1002B0534(a1, a2, &v12, &v11, a3);
  __int128 v7 = *(uint64_t **)v6;
  if (!*(void *)v6)
  {
    __int128 v8 = (uint64_t **)v6;
    sub_1002B0234((uint64_t)a1, a4, (uint64_t)v10);
    sub_10001E548(a1, (uint64_t)v12, v8, v10[0]);
    __int128 v7 = v10[0];
    v10[0] = 0LL;
    sub_1002B0384((uint64_t)v10, 0LL);
  }

  return v7;
}

double *sub_1002B0534(void *a1, double *a2, double **a3, double *a4, uint64_t a5)
{
  __int128 v5 = (double *)(a1 + 1);
  if (a1 + 1 == (void *)a2 || (v6 = *(double *)(a5 + 8), double v7 = a2[5], v6 < v7))
  {
    __int128 v8 = *(uint64_t **)a2;
    if ((double *)*a1 == a2)
    {
      __int128 v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }

      else
      {
        *a3 = a2;
        return a2;
      }
    }

    if (v8)
    {
      BOOL v9 = *(uint64_t **)a2;
      do
      {
        __int128 v10 = (double *)v9;
        BOOL v9 = (uint64_t *)v9[1];
      }

      while (v9);
    }

    else
    {
      __int128 v13 = a2;
      do
      {
        __int128 v10 = (double *)*((void *)v13 + 2);
        BOOL v14 = *(void *)v10 == (void)v13;
        __int128 v13 = v10;
      }

      while (v14);
    }

    double v15 = *(double *)(a5 + 8);
    if (v10[5] < v15) {
      goto LABEL_17;
    }
    BOOL v16 = *(double **)v5;
    if (*(void *)v5)
    {
      do
      {
        while (1)
        {
          unint64_t v17 = v16;
          double v18 = v16[5];
          if (v15 >= v18) {
            break;
          }
          BOOL v16 = *(double **)v16;
          __int128 v5 = v17;
          if (!*(void *)v17) {
            goto LABEL_43;
          }
        }

        if (v18 >= v15) {
          break;
        }
        __int128 v5 = v16 + 1;
        BOOL v16 = (double *)*((void *)v16 + 1);
      }

      while (v16);
      goto LABEL_43;
    }

void sub_1002B06D0(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    sub_100164284(a1, *(id **)(a1 + 16));
    *(void *)(a1 + 16) = 0LL;
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      for (uint64_t i = 0LL; i != v2; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0LL;
    }

    *(void *)(a1 + 24) = 0LL;
  }

void sub_1002B0724(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    sub_1002B0778(a1, *(void **)(a1 + 16));
    *(void *)(a1 + 16) = 0LL;
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      for (uint64_t i = 0LL; i != v2; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0LL;
    }

    *(void *)(a1 + 24) = 0LL;
  }

void sub_1002B0778(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      unint64_t v3 = (void *)*v2;
      sub_1002A93CC(v2 + 3, 0LL);
      operator delete(v2);
      uint64_t v2 = v3;
    }

    while (v3);
  }

uint64_t *sub_1002B07B8(uint64_t **a1, uint64_t *a2, uint64_t *a3)
{
  double v6 = a1 + 1;
  __int128 v5 = a1[1];
  if (v5)
  {
    uint64_t v7 = *a2;
    while (1)
    {
      while (1)
      {
        __int128 v8 = (uint64_t **)v5;
        uint64_t v9 = v5[4];
        if (v7 >= v9) {
          break;
        }
        __int128 v5 = *v8;
        double v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }

      if (v9 >= v7) {
        break;
      }
      __int128 v5 = v8[1];
      if (!v5)
      {
        double v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    __int128 v8 = a1 + 1;
LABEL_10:
    __int128 v10 = (uint64_t *)operator new(0x28uLL);
    v10[4] = *a3;
    sub_10001E548(a1, (uint64_t)v8, v6, v10);
    return v10;
  }

  return (uint64_t *)v8;
}

uint64_t sub_1002B0870(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_1002B08A8(void **a1)
{
}

void sub_1002B08B0(void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
}

void sub_1002B08BC()
{
  unsigned __int8 v0 = objc_autoreleasePoolPush();
  sub_1000065CC(&qword_1007FE130, "/System/Library/NearbyInteractionBundles");
  __cxa_atexit((void (*)(void *))&std::string::~string, &qword_1007FE130, (void *)&_mh_execute_header);
  sub_1000065CC(&qword_1007FE148, "BiasEstimatorResourceBundle.bundle");
  __cxa_atexit((void (*)(void *))&std::string::~string, &qword_1007FE148, (void *)&_mh_execute_header);
  v9[0] = xmmword_10042C780;
  v9[1] = unk_10042C790;
  sub_10015EABC((uint64_t)&unk_1007FE160, (int *)v9, 4LL);
  xmmword_1007FE178 = xmmword_100423CB0;
  *(_OWORD *)&qword_1007FE188 = xmmword_100423CC0;
  qword_1007FE1A0 = 0LL;
  unk_1007FE1A8 = 0LL;
  qword_1007FE198 = 0x3FD999999999999ALL;
  unk_1007FE1B0 = xmmword_100423CD0;
  dword_1007FE1C0 = 5;
  qword_1007FE1C8 = 0x4000000000000000LL;
  LODWORD(qword_1007FE1D0) = 5;
  byte_1007FE1D8 = 0;
  unk_1007FE1DC = 0x30000000ALL;
  xmmword_1007FE1E8 = xmmword_100423CE0;
  unk_1007FE1F8 = xmmword_100423CF0;
  xmmword_1007FE208 = xmmword_100423D00;
  qword_1007FE218 = 0x3FE3333333333333LL;
  dword_1007FE220 = 3;
  xmmword_1007FE228 = xmmword_100423D10;
  unk_1007FE238 = xmmword_100423CF0;
  xmmword_1007FE248 = xmmword_100423CE0;
  qword_1007FE258 = 0x3FE3333333333333LL;
  LOBYTE(qword_1007FE260) = 0;
  xmmword_1007FE268 = xmmword_100423D20;
  unk_1007FE278 = xmmword_100423D30;
  __asm { FMOV            V0.2D, #1.0 }

  __int128 v8 = _Q0;
  xmmword_1007FE288 = _Q0;
  qword_1007FE298 = 0xBFD3333333333333LL;
  xmmword_1007FE2A0 = xmmword_100423D40;
  qword_1007FE2B0 = 0x3E99999A40000000LL;
  xmmword_1007FE2B8 = xmmword_100423CC0;
  qword_1007FE2D0 = 0LL;
  unk_1007FE2D8 = 0LL;
  qword_1007FE2C8 = 0x3FD999999999999ALL;
  xmmword_1007FE2E0 = xmmword_100423CD0;
  dword_1007FE2F0 = 5;
  qword_1007FE2F8 = 0x4000000000000000LL;
  dword_1007FE300 = 4;
  *(void *)&xmmword_1007FE308 = 0x300000008LL;
  *((void *)&xmmword_1007FE308 + 1) = 0xC04E800000000000LL;
  __int128 v10 = (char *)0xC04E800000000000LL;
  sub_10015ED64((uint64_t)&unk_1007FE318, (double *)&v10, 1LL);
  xmmword_1007FE330 = xmmword_100423D50;
  qword_1007FE340 = 0x4024000000000000LL;
  dword_1007FE348 = 45;
  LOBYTE(byte_1007FE350) = 0;
  byte_1007FE368 = 0;
  *(void *)&xmmword_1007FE370 = 0LL;
  BYTE8(xmmword_1007FE370) = 0;
  HIDWORD(xmmword_1007FE370) = 1;
  byte_1007FE380 = 1;
  xmmword_1007FE388 = xmmword_100423D60;
  unk_1007FE398 = xmmword_100423D70;
  xmmword_1007FE3A8 = v8;
  qword_1007FE3B8 = 0xC059000000000000LL;
  xmmword_1007FE3C0 = xmmword_100423D80;
  *(int32x2_t *)&xmmword_1007FE3D0 = vdup_n_s32(0x3DCCCCCDu);
  *(__int128 *)((char *)&xmmword_1007FE3D0 + _Block_object_dispose((const void *)(v1 - 112), 8) = xmmword_100423CC0;
  qword_1007FE3E8 = 0x3FD999999999999ALL;
  xmmword_1007FE3F0 = 0uLL;
  xmmword_1007FE400 = xmmword_100423CD0;
  LODWORD(xmmword_1007FE410) = 5;
  *((void *)&xmmword_1007FE410 + 1) = 0x4000000000000000LL;
  dword_1007FE420 = 10;
  qword_1007FE428 = 0x4034000000000000LL;
  LODWORD(xmmword_1007FE430) = 3;
  *(__int128 *)((char *)&xmmword_1007FE430 + _Block_object_dispose((const void *)(v1 - 112), 8) = xmmword_100423D90;
  __cxa_atexit((void (*)(void *))sub_10015CF8C, &unk_1007FE160, (void *)&_mh_execute_header);
  qword_1007FE450 = 0LL;
  unk_1007FE458 = 0LL;
  qword_1007FE448 = 0LL;
  double v6 = operator new(0x40uLL);
  qword_1007FE450 = (uint64_t)(v6 + 4);
  unk_1007FE458 = v6 + 4;
  _OWORD *v6 = xmmword_10042C7A0;
  v6[1] = unk_10042C7B0;
  void v6[2] = xmmword_10042C7C0;
  void v6[3] = unk_10042C7D0;
  qword_1007FE448 = (uint64_t)v6;
  __cxa_atexit((void (*)(void *))sub_100028CC4, &qword_1007FE448, (void *)&_mh_execute_header);
  qword_1007FE468 = 0LL;
  unk_1007FE470 = 0LL;
  qword_1007FE460 = 0LL;
  uint64_t v7 = operator new(0x10uLL);
  qword_1007FE468 = (uint64_t)(v7 + 1);
  unk_1007FE470 = v7 + 1;
  *uint64_t v7 = xmmword_10042C7E0;
  qword_1007FE460 = (uint64_t)v7;
  __cxa_atexit((void (*)(void *))sub_100028CC4, &qword_1007FE460, (void *)&_mh_execute_header);
  *(void *)&v9[0] = "AntennaMask_1_NN_V5_Model_DeviceType_201.mlmodelc/fp16_model.espresso";
  *((void *)&v9[0] + 1) = "net";
  sub_100240590(&qword_1007FE478, (char **)v9);
  __int128 v10 = "AntennaMask_2_NN_V5_Model_DeviceType_201.mlmodelc/fp16_model.espresso";
  uint64_t v11 = "net";
  sub_100240590(qword_1007FE4A8, &v10);
  __cxa_atexit((void (*)(void *))sub_100233260, &qword_1007FE478, (void *)&_mh_execute_header);
  *(void *)&v9[0] = "AntennaMask_1_NN_V5_ScalingModel_DeviceType_201";
  *((void *)&v9[0] + 1) = "mlmodelc";
  sub_100240590(&qword_1007FE4D8, (char **)v9);
  __int128 v10 = "AntennaMask_2_NN_V5_ScalingModel_DeviceType_201";
  uint64_t v11 = "mlmodelc";
  sub_100240590(qword_1007FE508, &v10);
  __cxa_atexit((void (*)(void *))sub_100233260, &qword_1007FE4D8, (void *)&_mh_execute_header);
  sub_1000065CC(qword_1007FE538, "input_1");
  __cxa_atexit((void (*)(void *))&std::string::~string, qword_1007FE538, (void *)&_mh_execute_header);
  sub_1000065CC(qword_1007FE550, "Identity");
  __cxa_atexit((void (*)(void *))&std::string::~string, qword_1007FE550, (void *)&_mh_execute_header);
  objc_autoreleasePoolPop(v0);
}

void sub_1002B0D94(_Unwind_Exception *exception_object)
{
  if (byte_1007FE507 < 0) {
    sub_1003A6980();
  }
  if (byte_1007FE4EF < 0) {
    operator delete((void *)qword_1007FE4D8);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B1044(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1002B1250( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_1002B1614(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002B1A80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002B1DC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002B204C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002B2430( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20, uint64_t a21, void *a22, uint64_t a23, uint64_t a24, void *a25, uint64_t a26, uint64_t a27, void *a28, uint64_t a29, void *a30)
{
  _Unwind_Resume(a1);
}

void sub_1002B287C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002B29D8(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1002B2AA8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_1002B2BAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002B2CDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002B2D9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002B2ED4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002B2FBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002B3118(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1002B31C8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_1002B32C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002B33E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002B3484(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002B3550(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002B3658(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002B36E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002B3754( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_1002B3848(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002B3968(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002B3ABC(id a1)
{
  uint64_t v1 = objc_alloc_init(&OBJC_CLASS___PRGlobalDebugSettings);
  uint64_t v2 = (void *)qword_1007FE578;
  qword_1007FE578 = (uint64_t)v1;
}

void sub_1002B3F14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002B4100(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002B4224(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002B4374(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002B4668(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002B4840(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002B493C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002B4A94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002B4B94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002B4CFC(char *a1@<X0>, void *a2@<X8>)
{
  if (a1[23] >= 0) {
    uint64_t v4 = a1;
  }
  else {
    uint64_t v4 = *(char **)a1;
  }
  __int128 v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithCString:encoding:](&OBJC_CLASS___NSString, "stringWithCString:encoding:", v4, 4LL));
  double v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableString stringWithString:](&OBJC_CLASS___NSMutableString, "stringWithString:", v5));
  uint64_t v7 = objc_alloc_init(&OBJC_CLASS___NSDateFormatter);
  uint64_t v8 = objc_claimAutoreleasedReturnValue( +[NSLocale localeWithLocaleIdentifier:]( &OBJC_CLASS___NSLocale,  "localeWithLocaleIdentifier:",  @"en_US_POSIX"));
  uint64_t v9 = (void *)v8;
  if (v7) {
    BOOL v10 = v8 == 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (v10)
  {
    uint64_t v11 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
      sub_1003A69B8(v11);
    }
    double v12 = sub_100023CC4();
    std::to_string(&v19, v12);
    sub_10028D0F8((const void **)a1, (const void **)&v19.__r_.__value_.__l.__data_, (uint64_t)&__p);
    __int128 v13 = std::string::append(&__p, ".protobuf.log");
    __int128 v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    a2[2] = v13->__r_.__value_.__l.__cap_;
    *(_OWORD *)a2 = v14;
    v13->__r_.__value_.__l.__size_ = 0LL;
    v13->__r_.__value_.__l.__cap_ = 0LL;
    v13->__r_.__value_.__r.__words[0] = 0LL;
  }

  else
  {
    -[NSDateFormatter setLocale:](v7, "setLocale:", v8);
    -[NSDateFormatter setDateFormat:](v7, "setDateFormat:", @"yyyy_MM_dd_HH_mm_ss");
    double v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSTimeZone timeZoneWithName:](&OBJC_CLASS___NSTimeZone, "timeZoneWithName:", @"UTC"));
    -[NSDateFormatter setTimeZone:](v7, "setTimeZone:", v15);

    BOOL v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
    unint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(-[NSDateFormatter stringFromDate:](v7, "stringFromDate:", v16));

    [v6 appendString:v17];
    [v6 appendString:@".protobuf.log"];
    sub_1000065CC(a2, (char *)[v6 UTF8String]);
  }
}

void sub_1002B4F00( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  _Unwind_Resume(a1);
}

void sub_1002B5188(_Unwind_Exception *a1)
{
}

uint64_t sub_1002B519C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16LL))( *(void *)(a1 + 40),  *(void *)(a1 + 32));
}

void sub_1002B5210(_Unwind_Exception *a1)
{
}

void sub_1002B536C(_Unwind_Exception *a1)
{
}

uint64_t sub_1002B5380(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16LL))( *(void *)(a1 + 40),  *(void *)(a1 + 32));
}

id sub_1002B53D8(void *a1, id a2)
{
  id v3 = a1;
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](&OBJC_CLASS___NSUserDefaults, "standardUserDefaults"));
  double v6 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKey:v3]);
  if (v6 && (uint64_t v7 = objc_opt_class(&OBJC_CLASS___NSNumber, v5), (objc_opt_isKindOfClass(v6, v7) & 1) != 0))
  {
    a2 = [v6 intValue];
    uint64_t v8 = 1LL;
  }

  else
  {
    uint64_t v8 = 0LL;
  }

  uint64_t v9 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v10 = off_1007BBFA8[v8];
    int v12 = 138412802;
    id v13 = v3;
    __int16 v14 = 2112;
    double v15 = v10;
    __int16 v16 = 1024;
    int v17 = (int)a2;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#PRDefaults,%@[%@] = %d",  (uint8_t *)&v12,  0x1Cu);
  }

  return a2;
}

void sub_1002B5520(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sub_1002B5554(void *a1, id a2)
{
  id v3 = a1;
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](&OBJC_CLASS___NSUserDefaults, "standardUserDefaults"));
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKey:v3]);

  if (v5) {
    a2 = [v4 BOOLForKey:v3];
  }
  double v6 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = off_1007BBFA8[v5 != 0LL];
    int v9 = 138412802;
    id v10 = v3;
    __int16 v11 = 2112;
    int v12 = v7;
    __int16 v13 = 1024;
    int v14 = (int)a2;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "#PRDefaults,%@[%@] = %d", (uint8_t *)&v9, 0x1Cu);
  }

  return a2;
}

void sub_1002B5680(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double sub_1002B56A8(void *a1, double a2)
{
  id v3 = a1;
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](&OBJC_CLASS___NSUserDefaults, "standardUserDefaults"));
  double v6 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKey:v3]);
  if (v6 && (uint64_t v7 = objc_opt_class(&OBJC_CLASS___NSNumber, v5), (objc_opt_isKindOfClass(v6, v7) & 1) != 0))
  {
    [v6 doubleValue];
    a2 = v8;
    uint64_t v9 = 1LL;
  }

  else
  {
    uint64_t v9 = 0LL;
  }

  id v10 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v11 = off_1007BBFA8[v9];
    int v13 = 138412802;
    id v14 = v3;
    __int16 v15 = 2112;
    __int16 v16 = v11;
    __int16 v17 = 2048;
    double v18 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#PRDefaults,%@[%@] = %f",  (uint8_t *)&v13,  0x20u);
  }

  return a2;
}

void sub_1002B57F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002B5998(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002B5A94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002B5B64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002B5D00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002B5E6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002B5F98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002B6044(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *AONSenseSampleProvider.AONSENSE_FRAMEWORK_AVAILABLE.unsafeMutableAddressor()
{
  return &static AONSenseSampleProvider.AONSENSE_FRAMEWORK_AVAILABLE;
}

uint64_t static AONSenseSampleProvider.AONSENSE_FRAMEWORK_AVAILABLE.getter()
{
  return 1LL;
}

id sub_1002B6104()
{
  id result = [objc_allocWithZone((Class)type metadata accessor for AONSenseSampleProvider()) init];
  static AONSenseSampleProvider.shared = (uint64_t)result;
  return result;
}

id AONSenseSampleProvider.__allocating_init()()
{
  return [objc_allocWithZone(v0) init];
}

uint64_t *AONSenseSampleProvider.shared.unsafeMutableAddressor()
{
  if (qword_1007FE588 != -1) {
    swift_once(&qword_1007FE588, sub_1002B6104);
  }
  return &static AONSenseSampleProvider.shared;
}

id static AONSenseSampleProvider.shared.getter()
{
  if (qword_1007FE588 != -1) {
    swift_once(&qword_1007FE588, sub_1002B6104);
  }
  return (id)static AONSenseSampleProvider.shared;
}

void AONSenseSampleProvider.register(queue:callback:)()
{
  uint64_t v0 = static os_log_type_t.error.getter();
  sub_1002B627C();
  id v1 = (id)static OS_os_log.default.getter();
  os_log(_:dso:log:_:_:)( v0,  &_mh_execute_header,  v1,  "#AONSenseSampleProvider Not registering with AONSense For BT samples - platform not supported",  93LL,  2LL,  &_swiftEmptyArrayStorage);
}

unint64_t sub_1002B627C()
{
  unint64_t result = qword_1007F4540;
  if (!qword_1007F4540)
  {
    uint64_t v1 = objc_opt_self(&OBJC_CLASS___OS_os_log);
    unint64_t result = swift_getObjCClassMetadata(v1);
    atomic_store(result, (unint64_t *)&qword_1007F4540);
  }

  return result;
}

uint64_t variable initialization expression of AONSenseSampleProvider._callout()
{
  return 0LL;
}

uint64_t variable initialization expression of AONSenseSampleProvider._aonSense()
{
  return 0LL;
}

id AONSenseSampleProvider.init()()
{
  uint64_t v1 = &v0[OBJC_IVAR____TtC19ProximityDaemonCore22AONSenseSampleProvider__callout];
  *(void *)uint64_t v1 = 0LL;
  *((void *)v1 + 1) = 0LL;
  *(void *)&v0[OBJC_IVAR____TtC19ProximityDaemonCore22AONSenseSampleProvider__aonSense] = 0LL;
  v3.receiver = v0;
  v3.super_class = (Class)type metadata accessor for AONSenseSampleProvider();
  return objc_msgSendSuper2(&v3, "init");
}

uint64_t type metadata accessor for AONSenseSampleProvider()
{
  return objc_opt_self(&OBJC_CLASS____TtC19ProximityDaemonCore22AONSenseSampleProvider);
}

id AONSenseSampleProvider.__deallocating_deinit()
{
  v2.receiver = v0;
  v2.super_class = (Class)type metadata accessor for AONSenseSampleProvider();
  return objc_msgSendSuper2(&v2, "dealloc");
}

uint64_t sub_1002B64A4(uint64_t result, uint64_t a2)
{
  if (result) {
    return swift_release(a2);
  }
  return result;
}

uint64_t sub_1002B64B4(uint64_t a1, uint64_t a2, void *a3, void *a4, uint64_t a5)
{
  uint64_t v8 = a4[1];
  *(void *)a1 = *a4;
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v8;
  if (v8)
  {
    uint64_t v9 = (unint64_t *)(v8 + 8);
    do
      unint64_t v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }

  uint64_t v11 = a3[1];
  *(void *)(a1 + 16) = *a3;
  *(void *)(a1 + 24) = v11;
  if (v11)
  {
    int v12 = (unint64_t *)(v11 + 8);
    do
      unint64_t v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }

  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  sub_1001896FC( (void *)(a1 + 32),  *(const void **)a2,  *(void *)(a2 + 8),  (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 1);
  uint64_t v14 = *(void *)(a2 + 24);
  __int16 v15 = *(_WORD *)(a2 + 32);
  *(void *)(a1 + 72) = 0LL;
  *(_WORD *)(a1 + 64) = v15;
  *(void *)(a1 + 56) = v14;
  *(void *)(a1 + 80) = 0LL;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  sub_1001309C0( (void *)(a1 + 72),  *(const void **)(a2 + 40),  *(void *)(a2 + 48),  *(void *)(a2 + 48) - *(void *)(a2 + 40));
  *(_DWORD *)(a1 + 96) = 0;
  sub_10001E914(a1 + 104, a5);
  *(_BYTE *)(a1 + 136) = 0;
  *(_BYTE *)(a1 + 144) = 0;
  *(_BYTE *)(a1 + 152) = 0;
  *(_BYTE *)(a1 + 15_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 160) = 0;
  *(_BYTE *)(a1 + 16_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 172) = 0;
  *(_BYTE *)(a1 + 184) = 0;
  *(_BYTE *)(a1 + 18_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 204) = 0;
  if (!*(void *)(a1 + 16))
  {
    __int16 v17 = "_uwbSystem";
    int v18 = 254;
    goto LABEL_14;
  }

  if (!*(void *)a1)
  {
    __int16 v17 = "_configProvider";
    int v18 = 255;
    goto LABEL_14;
  }

  if (!*(void *)(a1 + 128))
  {
    __int16 v17 = "_getTimeCb";
    int v18 = 256;
LABEL_14:
    __assert_rtn("ParameterNegotiator", "AlishaParameterNegotiation.cpp", v18, v17);
  }

  return a1;
}

void sub_1002B6610(_Unwind_Exception *a1)
{
}

uint64_t sub_1002B6690(uint64_t result)
{
  if (*(_BYTE *)(result + 144)) {
    *(_BYTE *)(result + 144) = 0;
  }
  return result;
}

uint64_t sub_1002B66A0(uint64_t result)
{
  *(_DWORD *)(result + 96) = 0;
  if (*(_BYTE *)(result + 158)) {
    *(_BYTE *)(result + 15_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  }
  if (*(_BYTE *)(result + 168)) {
    *(_BYTE *)(result + 16_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  }
  if (*(_BYTE *)(result + 184)) {
    *(_BYTE *)(result + 184) = 0;
  }
  if (*(_BYTE *)(result + 204)) {
    *(_BYTE *)(result + 204) = 0;
  }
  return result;
}

void sub_1002B66D8(uint64_t a1@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *a2;
  if ((_DWORD)v6 == 12) {
    __int16 v7 = 1000;
  }
  else {
    __int16 v7 = 0;
  }
  if ((_DWORD)v6 == 138) {
    __int16 v8 = 0;
  }
  else {
    __int16 v8 = v7;
  }
  if ((_DWORD)v6 == 138) {
    char v9 = 2;
  }
  else {
    char v9 = 0;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  unint64_t v11 = sub_100224968((uint64_t)a2, v6);
  (*(void (**)(void *__return_ptr, uint64_t, unint64_t))(*(void *)v10 + 48LL))(v33, v10, v11);
  if (LODWORD(v33[0]) || !v34)
  {
    unint64_t v22 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR))
    {
      if (*a2 == 12) {
        __int128 v27 = "LESetPHY";
      }
      else {
        __int128 v27 = "ConnCmpltEventCount0";
      }
      sub_1000065CC(buf, v27);
      int v28 = v41[9];
      char v29 = *(_BYTE **)buf;
      unint64_t v31 = sub_100224968((uint64_t)a2, v30);
      __int128 v32 = buf;
      if (v28 < 0) {
        __int128 v32 = v29;
      }
      *(_DWORD *)std::string __p = 136315394;
      *(void *)&__p[4] = v32;
      __int16 v36 = 2048;
      unint64_t v37 = v31;
      _os_log_error_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_ERROR,  "#alisha-param-neg,BT event %s. Failed to convert BT clock %llu [us]",  __p,  0x16u);
      if ((v41[9] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
    }

    uint64_t v23 = 0LL;
    char v24 = 0;
    uint64_t v25 = -1LL;
  }

  else
  {
    uint64_t v12 = v33[1];
    unint64_t v13 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      if (*a2 == 12) {
        uint64_t v14 = "LESetPHY";
      }
      else {
        uint64_t v14 = "ConnCmpltEventCount0";
      }
      sub_1000065CC(__p, v14);
      int v15 = v38;
      __int16 v16 = *(_BYTE **)__p;
      unint64_t v18 = sub_100224968((uint64_t)a2, v17);
      std::string v19 = __p;
      *(_DWORD *)buf = 136315650;
      if (v15 < 0) {
        std::string v19 = v16;
      }
      *(void *)&uint8_t buf[4] = v19;
      __int16 v40 = 2048;
      *(void *)char v41 = v18;
      *(_WORD *)&v41[8] = 2048;
      *(void *)&v41[10] = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "#alisha-param-neg,BT event %s. Converted BT clock %llu [us] to UWB clock %llu [us]",  buf,  0x20u);
      if (v38 < 0) {
        operator delete(*(void **)__p);
      }
    }

    if (*(_BYTE *)(a1 + 144))
    {
      uint64_t v20 = *(void *)(a1 + 136);
      if (v12 < v20)
      {
        double v21 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 134218240;
          *(void *)&uint8_t buf[4] = v12;
          __int16 v40 = 2048;
          *(void *)char v41 = v20;
          _os_log_fault_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_FAULT,  "#alisha-param-neg,BT event UWB clock (%llu [us]) < shared event UWB clock (%llu [us])",  buf,  0x16u);
          double v21 = (os_log_s *)qword_1008000A0;
        }

        if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136315650;
          *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/Proximity/Libraries/AlishaSupport/AlishaParameterNegotiation.cpp";
          __int16 v40 = 1024;
          *(_DWORD *)char v41 = 337;
          *(_WORD *)&v41[4] = 2080;
          *(void *)&v41[6] = "processBluetoothEvent";
          _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_INFO,  "#alisha-param-neg,%s:%d: assertion failure in %s",  buf,  0x1Cu);
        }

        abort();
      }
    }

    else
    {
      unint64_t v26 = (os_log_s *)qword_1008000A0;
      if (!os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT)
        || (*(_WORD *)buf = 0,
            _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "#alisha-param-neg,Setting this BT event as the shared event for sending timing info to vehicle",  buf,  2u),  !*(_BYTE *)(a1 + 144)))
      {
        *(_BYTE *)(a1 + 144) = 1;
      }

      *(void *)(a1 + 136) = v12;
      uint64_t v20 = v12;
    }

    __int16 v8 = 0;
    uint64_t v23 = v12 - v20;
    uint64_t v25 = *((void *)a2 + 5);
    char v24 = 1;
    char v9 = 1;
  }

  *(_DWORD *)a3 = 0;
  *(void *)(a3 + _Block_object_dispose((const void *)(v1 - 112), 8) = v25;
  *(void *)(a3 + 16) = v23;
  *(_BYTE *)(a3 + 24) = 0;
  *(_BYTE *)(a3 + 25) = v24;
  *(_WORD *)(a3 + 26) = 100;
  *(_BYTE *)(a3 + 2_Block_object_dispose((const void *)(v1 - 112), 8) = v9;
  *(_WORD *)(a3 + 30) = v8;
  *(_BYTE *)(a3 + 32) = 1;
}

void sub_1002B6A8C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20, uint64_t a21, int a22, __int16 a23, char a24, char a25)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

const char *sub_1002B6AC4(uint64_t a1, const char **a2)
{
  if (!*(_BYTE *)(a1 + 144))
  {
    __int16 v7 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v8 = *a2;
      int v10 = 134217984;
      unint64_t v11 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "#alisha-param-neg,Setting ranging start time UWB clock (%llu [us]) as the shared event for sending timing info to vehicle",  (uint8_t *)&v10,  0xCu);
      uint64_t v5 = *a2;
      if (*(_BYTE *)(a1 + 144))
      {
LABEL_13:
        *(void *)(a1 + 136) = v5;
        return (const char *)(*a2 - v5);
      }
    }

    else
    {
      uint64_t v5 = *a2;
    }

    *(_BYTE *)(a1 + 144) = 1;
    goto LABEL_13;
  }

  uint64_t v4 = *a2;
  uint64_t v5 = *(const char **)(a1 + 136);
  if ((uint64_t)*a2 < (uint64_t)v5)
  {
    uint64_t v6 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT))
    {
      int v10 = 134218240;
      unint64_t v11 = v4;
      __int16 v12 = 2048;
      v13[0] = v5;
      _os_log_fault_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "#alisha-param-neg,Ranging start time UWB clock (%llu [us]) < shared event UWB clock (%llu [us])",  (uint8_t *)&v10,  0x16u);
      uint64_t v6 = (os_log_s *)qword_1008000A0;
    }

    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      int v10 = 136315650;
      unint64_t v11 = "/Library/Caches/com.apple.xbs/Sources/Proximity/Libraries/AlishaSupport/AlishaParameterNegotiation.cpp";
      __int16 v12 = 1024;
      LODWORD(v13[0]) = 360;
      WORD2(v13[0]) = 2080;
      *(void *)((char *)v13 + 6) = "getUwbTime0";
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "#alisha-param-neg,%s:%d: assertion failure in %s",  (uint8_t *)&v10,  0x1Cu);
    }

    abort();
  }

  return (const char *)(*a2 - v5);
}

uint64_t sub_1002B6C88(uint64_t a1, unsigned __int16 **a2)
{
  if (*(_DWORD *)(a1 + 96))
  {
    LODWORD(v23[0]) = -2000;
    *(void *)((char *)v23 + 4) = 0LL;
    return v23[0];
  }

  (*(void (**)(void **__return_ptr))(**(void **)a1 + 16LL))(&__p);
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  uint64_t v6 = (unsigned __int16 *)__p;
  if (*a2 != v5)
  {
    while (__p == v22)
    {
LABEL_8:
      if (++v4 == v5) {
        goto LABEL_28;
      }
    }

    __int16 v7 = (unsigned __int16 *)__p;
    while (*v4 != *v7)
    {
      if (++v7 == v22) {
        goto LABEL_8;
      }
    }
  }

  if (v4 == v5)
  {
LABEL_28:
    int v16 = -2002;
    goto LABEL_36;
  }

  __int16 v8 = a2[3];
  char v9 = a2[4];
  if (v8 != v9)
  {
    int v10 = *(unsigned __int16 **)(a1 + 40);
    while (*(unsigned __int16 **)(a1 + 32) == v10)
    {
LABEL_17:
      if (++v8 == v9) {
        goto LABEL_34;
      }
    }

    unint64_t v11 = *(unsigned __int16 **)(a1 + 32);
    while (*v8 != *v11)
    {
      if (++v11 == v10) {
        goto LABEL_17;
      }
    }
  }

  if (v8 == v9)
  {
LABEL_34:
    int v16 = -2003;
    goto LABEL_36;
  }

  __int16 v12 = (unsigned __int8 *)a2[6];
  unint64_t v13 = (unsigned __int8 *)a2[7];
  if (v12 != v13)
  {
    uint64_t v14 = *(unsigned __int8 **)(a1 + 80);
    while (*(unsigned __int8 **)(a1 + 72) == v14)
    {
LABEL_26:
      if (++v12 == v13) {
        goto LABEL_35;
      }
    }

    int v15 = *(unsigned __int8 **)(a1 + 72);
    while (*v12 != *v15)
    {
      if (++v15 == v14) {
        goto LABEL_26;
      }
    }
  }

  if (v12 == v13)
  {
LABEL_35:
    int v16 = -2004;
LABEL_36:
    LODWORD(v23[0]) = v16;
    *(void *)((char *)v23 + 4) = 0LL;
    if (!__p) {
      return v23[0];
    }
LABEL_37:
    unint64_t v22 = v6;
    operator delete(v6);
    return v23[0];
  }

  unsigned __int16 v17 = *v4;
  unsigned __int16 v18 = *v8;
  unsigned __int8 v19 = *v12;
  if (!*(_BYTE *)(a1 + 158)) {
    *(_BYTE *)(a1 + 15_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
  }
  *(_WORD *)(a1 + 152) = v17;
  *(_WORD *)(a1 + 154) = v18;
  *(_BYTE *)(a1 + 156) = v19;
  LODWORD(v23[0]) = 0;
  *(void *)((char *)v23 + 4) = *(void *)(a1 + 152);
  if (v6) {
    goto LABEL_37;
  }
  return v23[0];
}

void sub_1002B6E50(void *a1@<X0>, unsigned __int16 *a2@<X1>, uint64_t a3@<X8>)
{
  if (*((_DWORD *)a1 + 24))
  {
    int v4 = -2000;
LABEL_10:
    *(_DWORD *)a3 = v4;
    *(_BYTE *)(a3 + 4) = 0;
    *(_BYTE *)(a3 + 16) = 0;
    return;
  }

  int v7 = *((unsigned __int8 *)a1 + 158);
  __int16 v8 = (os_log_s *)qword_1008000A0;
  BOOL v9 = os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT);
  if (v7)
  {
    if (v9)
    {
      LOWORD(__p) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#alisha-param-neg,Negotiating session parameters WITH a previously cached capability response",  (uint8_t *)&__p,  2u);
      if (!*((_BYTE *)a1 + 158)) {
        sub_100006080();
      }
    }

    if (*a2 != *((unsigned __int16 *)a1 + 76)
      || a2[1] != *((unsigned __int16 *)a1 + 77)
      || *((unsigned __int8 *)a2 + 4) != *((unsigned __int8 *)a1 + 156))
    {
      int v4 = -2005;
      goto LABEL_10;
    }

    goto LABEL_42;
  }

  if (v9)
  {
    LOWORD(__p) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#alisha-param-neg,Negotiating session parameters WITHOUT a previously cached capability response",  (uint8_t *)&__p,  2u);
  }

  (*(void (**)(void **__return_ptr))(*(void *)*a1 + 16LL))(&__p);
  int v10 = (unsigned __int16 *)__p;
  unint64_t v11 = v32;
  if (__p == v32)
  {
    __int16 v12 = (unsigned __int16 *)__p;
  }

  else
  {
    __int16 v12 = (unsigned __int16 *)__p;
    while (*v12 != *a2)
    {
      if (++v12 == v32)
      {
        __int16 v12 = v32;
        break;
      }
    }
  }

  uint64_t v14 = (unsigned __int16 *)a1[4];
  unint64_t v13 = (unsigned __int16 *)a1[5];
  if (v14 != v13)
  {
    while (*v14 != a2[1])
    {
      if (++v14 == v13)
      {
        uint64_t v14 = (unsigned __int16 *)a1[5];
        break;
      }
    }
  }

  int v15 = (void *)a1[10];
  int v16 = memchr((const void *)a1[9], *((char *)a2 + 4), (size_t)v15 - a1[9]);
  if (v16) {
    unsigned __int16 v17 = v16;
  }
  else {
    unsigned __int16 v17 = v15;
  }
  BOOL v19 = v12 == v11 || v14 == v13 || v17 == v15;
  char v20 = v19;
  if (v19)
  {
    *(_DWORD *)a3 = -2020;
    *(_BYTE *)(a3 + 4) = 0;
    *(_BYTE *)(a3 + 16) = 0;
  }

  if (v10)
  {
    __int128 v32 = v10;
    operator delete(v10);
  }

  if ((v20 & 1) == 0)
  {
LABEL_42:
    unsigned int v21 = (a1[8] & *((_BYTE *)a2 + 5));
    (*(void (**)(void **__return_ptr))(*(void *)*a1 + 24LL))(&__p);
    if (v21)
    {
      for (uint64_t i = (unsigned __int16 *)__p; ; uint64_t i = (unsigned __int16 *)((char *)i + 1))
      {
        if (i == v32)
        {
          int v24 = -2008;
          goto LABEL_49;
        }

        char v23 = *(_BYTE *)i;
        if (((v21 >> *(_BYTE *)i) & 1) != 0) {
          break;
        }
      }

      if ((a2[3] & 1) != 0) {
        char v25 = 1;
      }
      else {
        char v25 = a2[3] & 2;
      }
      if (*((_BYTE *)a1 + 168))
      {
        int v26 = *(_DWORD *)a2;
        *(_DWORD *)((char *)a1 + 163) = *(_DWORD *)((char *)a2 + 3);
        *((_DWORD *)a1 + 40) = v26;
      }

      else
      {
        a1[20] = *(void *)a2;
        *((_BYTE *)a1 + 16_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
      }

      char v27 = (*(uint64_t (**)(void))(*(void *)*a1 + 40LL))(*a1);
      char v28 = *((_BYTE *)a1 + 56);
      int v29 = *((_DWORD *)a1 + 15);
      char v30 = *((_BYTE *)a1 + 65);
      if (!*((_BYTE *)a1 + 184)) {
        *((_BYTE *)a1 + 184) = 1;
      }
      *((_BYTE *)a1 + 172) = v27;
      *((_BYTE *)a1 + 173) = v28;
      *((_DWORD *)a1 + 44) = v29;
      *((_BYTE *)a1 + 180) = v23;
      *((_BYTE *)a1 + 181) = v30;
      *((_BYTE *)a1 + 182) = v25;
      *((_DWORD *)a1 + 24) = 1;
      *(_DWORD *)a3 = 0;
      *(_OWORD *)(a3 + 4) = *(_OWORD *)((char *)a1 + 172);
    }

    else
    {
      int v24 = -2016;
LABEL_49:
      *(_DWORD *)a3 = v24;
      *(_BYTE *)(a3 + 4) = 0;
      *(_BYTE *)(a3 + 16) = 0;
    }

    if (__p)
    {
      __int128 v32 = (unsigned __int16 *)__p;
      operator delete(__p);
    }
  }

void sub_1002B7148( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unint64_t sub_1002B7164@<X0>(unint64_t result@<X0>, unsigned __int8 *a2@<X1>, uint64_t a3@<X8>)
{
  if (*(_DWORD *)(result + 96) != 1)
  {
    int v7 = -2000;
    goto LABEL_8;
  }

  int v4 = (void *)result;
  if (!*(_BYTE *)(result + 168) || !*(_BYTE *)(result + 184))
  {
    int v7 = -2001;
    goto LABEL_8;
  }

  unsigned int v6 = *a2;
  if (v6 < *(unsigned __int8 *)(result + 172))
  {
    int v7 = -2007;
LABEL_8:
    *(_DWORD *)a3 = v7;
LABEL_9:
    *(_BYTE *)(a3 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0;
    *(_BYTE *)(a3 + 40) = 0;
    return result;
  }

  int v8 = a2[10];
  if (a2[10]) {
    uint64_t v9 = *(unsigned __int8 *)(result + 182);
  }
  else {
    uint64_t v9 = 0LL;
  }
  unsigned int v10 = a2[1];
  int v11 = -2010;
  if (v10 > 0x18 || ((1 << v10) & 0x1001358) == 0)
  {
LABEL_23:
    *(_DWORD *)a3 = v11;
    goto LABEL_9;
  }

  unsigned int v12 = a2[3];
  int v13 = a2[2];
  if ((v12 > 0x30 || ((1LL << v12) & 0x1001101051350LL) == 0) && v12 != 96 && v12 != 72)
  {
    int v11 = -2009;
    goto LABEL_23;
  }

  int v14 = v13 + (v13 & ((int)((_DWORD)v9 << 30) >> 31)) + 4;
  unsigned __int8 v15 = v13 + 5;
  if ((v9 & 1) == 0) {
    unsigned __int8 v15 = v14;
  }
  if (v12 < v15)
  {
    int v11 = -2012;
    goto LABEL_23;
  }

  if (0x120 % (v12 * v10))
  {
    int v11 = -2011;
    goto LABEL_23;
  }

  char v16 = 1;
  switch(a2[1])
  {
    case 3u:
      goto LABEL_36;
    case 4u:
      char v16 = 2;
      goto LABEL_36;
    case 5u:
    case 7u:
    case 0xAu:
    case 0xBu:
      goto LABEL_31;
    case 6u:
      char v16 = 4;
      goto LABEL_36;
    case 8u:
      char v16 = 8;
      goto LABEL_36;
    case 9u:
      char v16 = 16;
      goto LABEL_36;
    case 0xCu:
      char v16 = 32;
      goto LABEL_36;
    default:
      if (v10 != 24)
      {
LABEL_31:
        int v7 = -2009;
        goto LABEL_8;
      }

      char v16 = 64;
LABEL_36:
      if ((*(_BYTE *)(result + 173) & v16) == 0)
      {
        int v7 = -2017;
        goto LABEL_8;
      }

      int v17 = a2[8];
      int v18 = v17 & 0xE0;
      if (v18 == 32 || v18 == 64)
      {
        if ((((v17 & 0x1F) - 8) & 0xFFFFFFF7) == 0) {
          goto LABEL_41;
        }
LABEL_47:
        int v7 = -2015;
        goto LABEL_8;
      }

      if (v18 != 128)
      {
        int v7 = -2014;
        goto LABEL_8;
      }

      if ((v17 & 0x1F) != 0) {
        goto LABEL_47;
      }
LABEL_41:
      if ((v17 & ~*(unsigned __int8 *)(result + 181)) != 0)
      {
        int v7 = -2019;
        goto LABEL_8;
      }

      if (v8)
      {
        unint64_t result = sub_1002B74F0(a2[9], v9, v6, v10, v12);
        if ((_DWORD)result)
        {
          *(_DWORD *)a3 = result;
          goto LABEL_9;
        }

        unsigned int v20 = HIDWORD(result) & 0xFF000000;
        int v21 = HIDWORD(result) & 0xFFFF00;
        int v19 = BYTE4(result);
      }

      else
      {
        int v19 = 0;
        unsigned int v20 = 0;
        int v21 = 0;
      }

      unint64_t result = (*(uint64_t (**)(void, void))(*(void *)*v4 + 32LL))( *v4,  (*((_DWORD *)a2 + 1) & v4[22]));
      if ((result & 0xFF000000000000LL) != 0) {
        int v11 = 0;
      }
      else {
        int v11 = -1004;
      }
      if ((_DWORD)result) {
        int v11 = result;
      }
      if (v11) {
        goto LABEL_23;
      }
      if ((result & 0xFF000000000000LL) == 0 || !*((_BYTE *)v4 + 184) || !*((_BYTE *)v4 + 168)) {
        sub_100006080();
      }
      unsigned __int8 v24 = a2[8];
      v22.i32[0] = *(_DWORD *)a2;
      *((_BYTE *)v4 + 18_Block_object_dispose((const void *)(v1 - 112), 8) = *((_BYTE *)v4 + 180);
      int v25 = *((_DWORD *)v4 + 40);
      char v26 = *((_BYTE *)v4 + 164);
      int v27 = *((unsigned __int8 *)v4 + 204);
      int16x4_t v28 = (int16x4_t)vmovl_u8(v22).u64[0];
      *((_BYTE *)v4 + 189) = BYTE5(result);
      *(int16x4_t *)v23.i8 = vrev32_s16(v28);
      v23.i32[0] = v28.i32[0];
      *(_DWORD *)((char *)v4 + 190) = v25;
      *(_DWORD *)((char *)v4 + 194) = vmovn_s16(v23).u32[0];
      *((_BYTE *)v4 + 19_Block_object_dispose((const void *)(v1 - 112), 8) = v24;
      *((_BYTE *)v4 + 199) = v26;
      *((_DWORD *)v4 + 50) = v20 | v19 | v21;
      if (!v27) {
        *((_BYTE *)v4 + 204) = 1;
      }
      unint64_t v29 = HIDWORD(result);
      *((_BYTE *)v4 + 16_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
      *((_BYTE *)v4 + 184) = 0;
      unint64_t result = (*(uint64_t (**)(void, uint64_t))(*(void *)*v4 + 48LL))(*v4, (uint64_t)v4 + 188);
      *((_DWORD *)v4 + 24) = 2;
      *(_OWORD *)&v30[7] = *(_OWORD *)((char *)v4 + 188);
      *(_OWORD *)(a3 + 9) = *(_OWORD *)v30;
      *(_DWORD *)a3 = 0;
      *(_BYTE *)(a3 + _Block_object_dispose((const void *)(v1 - 112), 8) = v29;
      *(void *)(a3 + 24) = *(void *)&v30[15];
      *(void *)(a3 + 32) = result;
      *(_BYTE *)(a3 + 40) = 1;
      return result;
  }

uint64_t sub_1002B74F0(unsigned int a1, uint64_t a2, int a3, unsigned int a4, unsigned int a5)
{
  unsigned int v5 = a1 >> 6;
  if (!(a1 >> 6)) {
    return (a2 << 48) | 0x100000000000000LL;
  }
  char v6 = a1;
  uint64_t result = 4294965273LL;
  if (v5 != 1) {
    return 4294965274LL;
  }
  if (!a4) {
    return 4294965286LL;
  }
  if (!a5) {
    return 4294965287LL;
  }
  unsigned int v8 = 288 * a3 / a4;
  if (v8 < a5) {
    return 4294965275LL;
  }
  uint64_t v9 = v6 & 0x3F;
  return result;
}

double sub_1002B7588@<D0>(void *a1@<X0>, unsigned __int8 *a2@<X1>, uint64_t a3@<X8>)
{
  if (*((_DWORD *)a1 + 24) != 2)
  {
    int v9 = -2000;
LABEL_12:
    *(_DWORD *)a3 = v9;
    *(_BYTE *)(a3 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0;
    *(_BYTE *)(a3 + 40) = 0;
    return result;
  }

  if (!*((_BYTE *)a1 + 204))
  {
    int v9 = -2001;
    goto LABEL_12;
  }

  __int128 v14 = *(_OWORD *)((char *)a1 + 188);
  __int16 v6 = a2[1];
  if (a2[1])
  {
    __int16 v6 = *a2;
    if (!*a2)
    {
      int v7 = (os_log_s *)qword_1008000A0;
      if (!os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_8;
      }
      LOWORD(buf[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "#alisha-param-neg,Recovery RAN multiplier of 0 was specified. Using a multiplier of 1 instead.",  (uint8_t *)buf,  2u);
      if (!a2[1]) {
        sub_100006080();
      }
      __int16 v6 = *a2;
      if (!*a2) {
LABEL_8:
      }
        __int16 v6 = 1;
    }

    BYTE6(v14) = v6;
    __int16 v8 = 1;
  }

  else
  {
    __int16 v8 = 0;
  }

  __int16 v10 = v6 | (v8 << 8);
  uint64_t v11 = (*(uint64_t (**)(void, __int128 *))(*(void *)*a1 + 48LL))(*a1, &v14);
  *(_OWORD *)((char *)buf + 6) = v14;
  double result = buf[0];
  *(_OWORD *)(a3 + 10) = *(_OWORD *)buf;
  uint64_t v13 = *(void *)((char *)&buf[1] + 6);
  *(_DWORD *)a3 = 0;
  *(_WORD *)(a3 + _Block_object_dispose((const void *)(v1 - 112), 8) = v10;
  *(void *)(a3 + 24) = v13;
  *(void *)(a3 + 32) = v11;
  *(_BYTE *)(a3 + 40) = 1;
  return result;
}

void *sub_1002B76DC@<X0>(int a1@<W0>, void *a2@<X8>)
{
  if (a1 == 2)
  {
    uint64_t v2 = "RequireCapabilityExchange";
  }

  else if (a1 == 255)
  {
    uint64_t v2 = "WrongParameters";
  }

  else
  {
    uint64_t v2 = "UnsupportedChannelBitmask";
  }

  return sub_1000065CC(a2, v2);
}

void *sub_1002B7718@<X0>(char a1@<W0>, void *a2@<X8>)
{
  return sub_1000065CC(a2, off_1007BC038[a1 - 1]);
}

void sub_1002B7730(unsigned __int8 *a1@<X0>, std::string *a2@<X8>)
{
  int v4 = *a1;
  switch(v4)
  {
    case 3:
      if (!a1[6])
      {
        __int128 v14 = "deviceRangingIntentSubEventCode.has_value()";
        int v15 = 323;
        goto LABEL_36;
      }

      sub_1000065CC(&v18, off_1007BC088[(char)a1[5]]);
      break;
    case 2:
      if (!a1[4])
      {
        __int128 v14 = "rangingSessionStatusChangedSubEventCode.has_value()";
        int v15 = 319;
        goto LABEL_36;
      }

      sub_1002B7718(a1[3], &v18);
      break;
    case 1:
      if (a1[2])
      {
        int v5 = a1[1];
        if (v5 == 2)
        {
          __int16 v6 = "RequireCapabilityExchange";
        }

        else if (v5 == 255)
        {
          __int16 v6 = "WrongParameters";
        }

        else
        {
          __int16 v6 = "UnsupportedChannelBitmask";
        }

        sub_1000065CC(&v18, v6);
        break;
      }

      __int128 v14 = "commandCompleteSubEventCode.has_value()";
      int v15 = 315;
LABEL_36:
      __assert_rtn("toString", "AlishaDCKCoder.cpp", v15, v14);
    default:
      goto LABEL_16;
  }

  std::string v19 = v18;
LABEL_16:
  std::operator+<char>(&v16, "(", v20);
  int v7 = std::string::append(&v16, ", ");
  __int128 v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
  v17.__r_.__value_.__l.__cap_ = v7->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v17.__r_.__value_.__l.__data_ = v8;
  v7->__r_.__value_.__l.__size_ = 0LL;
  v7->__r_.__value_.__l.__cap_ = 0LL;
  v7->__r_.__value_.__r.__words[0] = 0LL;
  if ((v19.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    int v9 = &v19;
  }
  else {
    int v9 = (std::string *)v19.__r_.__value_.__r.__words[0];
  }
  if ((v19.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    std::string::size_type size = v19.__r_.__value_.__s.__size_;
  }
  else {
    std::string::size_type size = v19.__r_.__value_.__l.__size_;
  }
  uint64_t v11 = std::string::append(&v17, (const std::string::value_type *)v9, size);
  __int128 v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  v18.__r_.__value_.__l.__cap_ = v11->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v18.__r_.__value_.__l.__data_ = v12;
  v11->__r_.__value_.__l.__size_ = 0LL;
  v11->__r_.__value_.__l.__cap_ = 0LL;
  v11->__r_.__value_.__r.__words[0] = 0LL;
  uint64_t v13 = std::string::append(&v18, ")");
  *a2 = *v13;
  v13->__r_.__value_.__l.__size_ = 0LL;
  v13->__r_.__value_.__l.__cap_ = 0LL;
  v13->__r_.__value_.__r.__words[0] = 0LL;
  if (v21 < 0) {
    operator delete(v20[0]);
  }
}

void sub_1002B795C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, uint64_t a22, void *__p, uint64_t a24, int a25, __int16 a26, char a27, char a28)
{
}

_WORD *sub_1002B79E4(_WORD *result, __int16 a2)
{
  *double result = a2;
  return result;
}

unint64_t sub_1002B79EC(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = 4294963292LL;
  uint64_t v3 = *a2;
  unint64_t v4 = a2[1] - *a2;
  if (v4 >= 4)
  {
    if (v4 >> 16)
    {
      unsigned int v5 = 0;
      int v6 = 0;
      uint64_t v2 = 4294963295LL;
    }

    else if (v4 == __rev16(*(unsigned __int16 *)(v3 + 2)) + 4LL)
    {
      unsigned int v5 = *(_BYTE *)v3 & 0x3F;
      if (v5 > 5)
      {
        unsigned int v5 = 0;
        int v6 = 0;
        uint64_t v2 = 4294963293LL;
      }

      else
      {
        int v7 = *(unsigned __int8 *)(v3 + 1);
        if ((v7 - 1) > 0x14)
        {
          unsigned int v5 = 0;
          int v6 = 0;
        }

        else
        {
          int v6 = v7 << 8;
          uint64_t v2 = 0x1000000000000LL;
        }
      }
    }

    else
    {
      unsigned int v5 = 0;
      int v6 = 0;
      uint64_t v2 = 4294963294LL;
    }
  }

  else
  {
    unsigned int v5 = 0;
    int v6 = 0;
    uint64_t v2 = 4294963296LL;
  }

  return v2 | ((unint64_t)(v6 | v5) << 32);
}

uint64_t sub_1002B7A9C(int a1)
{
  if (a1 == 256) {
    return 65792LL;
  }
  else {
    return 256LL;
  }
}

void sub_1002B7AB4(__int16 a1, unint64_t *a2)
{
  unint64_t v3 = *a2;
  uint64_t v2 = (_BYTE *)a2[1];
  uint64_t v4 = (uint64_t)&v2[-*a2];
  unint64_t v7 = a2[2];
  if ((unint64_t)v2 >= v7)
  {
    if (v4 <= -2) {
      goto LABEL_41;
    }
    unint64_t v9 = v7 - v3;
    if (2 * v9 <= v4 + 1) {
      uint64_t v10 = v4 + 1;
    }
    else {
      uint64_t v10 = 2 * v9;
    }
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v11 = v10;
    }
    if (v11) {
      unint64_t v12 = (unint64_t)operator new(v11);
    }
    else {
      unint64_t v12 = 0LL;
    }
    uint64_t v13 = (char *)(v12 + v11);
    *(_BYTE *)(v12 + v4) = HIBYTE(a1);
    __int128 v8 = (_BYTE *)(v12 + v4 + 1);
    if (v2 == (_BYTE *)v3)
    {
      v12 += v4;
    }

    else
    {
      __int128 v14 = &v2[~v3];
      do
      {
        char v15 = *--v2;
        (v14--)[v12] = v15;
      }

      while (v2 != (_BYTE *)v3);
      uint64_t v2 = (_BYTE *)*a2;
    }

    *a2 = v12;
    a2[1] = (unint64_t)v8;
    a2[2] = (unint64_t)v13;
    if (v2) {
      operator delete(v2);
    }
  }

  else
  {
    _BYTE *v2 = HIBYTE(a1);
    __int128 v8 = v2 + 1;
  }

  a2[1] = (unint64_t)v8;
  unint64_t v16 = a2[2];
  if ((unint64_t)v8 < v16)
  {
    _BYTE *v8 = a1;
    uint64_t v17 = (uint64_t)(v8 + 1);
    goto LABEL_39;
  }

  unint64_t v18 = *a2;
  std::string v19 = &v8[-*a2];
  unint64_t v20 = (unint64_t)(v19 + 1);
  if ((uint64_t)(v19 + 1) < 0) {
LABEL_41:
  }
    sub_10001E11C();
  unint64_t v21 = v16 - v18;
  if (2 * v21 > v20) {
    unint64_t v20 = 2 * v21;
  }
  if (v21 >= 0x3FFFFFFFFFFFFFFFLL) {
    size_t v22 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    size_t v22 = v20;
  }
  if (v22) {
    unint64_t v23 = (unint64_t)operator new(v22);
  }
  else {
    unint64_t v23 = 0LL;
  }
  unsigned __int8 v24 = (char *)(v23 + v22);
  v19[v23] = a1;
  uint64_t v17 = (uint64_t)&v19[v23 + 1];
  if (v8 == (_BYTE *)v18)
  {
    *a2 = (unint64_t)&v19[v23];
    a2[1] = v17;
    a2[2] = (unint64_t)v24;
LABEL_38:
    operator delete(v8);
    goto LABEL_39;
  }

  int v25 = &v8[~v18];
  do
  {
    char v26 = *--v8;
    (v25--)[v23] = v26;
  }

  while (v8 != (_BYTE *)v18);
  __int128 v8 = (_BYTE *)*a2;
  *a2 = v23;
  a2[1] = v17;
  a2[2] = (unint64_t)v24;
  if (v8) {
    goto LABEL_38;
  }
LABEL_39:
  a2[1] = v17;
}

void sub_1002B7C7C(uint64_t a1@<X1>, _DWORD *a2@<X8>)
{
  LOBYTE(v22) = 0;
  sub_10016C2CC(&__p, 4uLL, &v22);
  sub_1002B7AB4(*(_WORD *)a1, (unint64_t *)&__p);
  sub_1002B7AB4(*(_WORD *)(a1 + 2), (unint64_t *)&__p);
  unint64_t v5 = (unint64_t)__p;
  uint64_t v4 = v27;
  uint64_t v6 = v27 - (_BYTE *)__p;
  if ((unint64_t)(v27 - (_BYTE *)__p - 0xFFFF) < 0xFFFFFFFFFFFF0000LL)
  {
    std::string v19 = "msg.size() + sizeof(data) <= kMaxMessageSize";
    int v20 = 225;
    unint64_t v21 = "append";
    goto LABEL_31;
  }

  char v7 = *(_BYTE *)(a1 + 4);
  if ((unint64_t)v27 >= v28)
  {
    unint64_t v9 = v28 - (void)__p;
    else {
      uint64_t v10 = 2 * v9;
    }
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v11 = v10;
    }
    if (v11) {
      unint64_t v12 = operator new(v11);
    }
    else {
      unint64_t v12 = 0LL;
    }
    uint64_t v13 = (char *)v12 + v11;
    *((_BYTE *)v12 + v6) = v7;
    __int128 v8 = (char *)v12 + v6 + 1;
    if (v4 == (_BYTE *)v5)
    {
      unint64_t v12 = (char *)v12 + v6;
    }

    else
    {
      __int128 v14 = &v4[~v5];
      do
      {
        char v15 = *--v4;
        (v14--)[(void)v12] = v15;
      }

      while (v4 != (_BYTE *)v5);
      uint64_t v4 = __p;
    }

    std::string __p = v12;
    int v27 = v8;
    unint64_t v28 = (unint64_t)v13;
    if (v4) {
      operator delete(v4);
    }
  }

  else
  {
    _BYTE *v27 = v7;
    __int128 v8 = v4 + 1;
  }

  int v27 = v8;
  unint64_t v16 = __p;
  unint64_t v17 = v8 - (_BYTE *)__p;
  if ((unint64_t)(v8 - (_BYTE *)__p) >= 0x10000)
  {
    std::string v19 = "msg.size() <= kMaxMessageSize";
    int v20 = 166;
    unint64_t v21 = "populateHeader";
LABEL_31:
    __assert_rtn(v21, "AlishaDCKCoder.cpp", v20, v19);
  }

  if (v17 <= 3)
  {
    sub_1000353EC((unint64_t *)&__p, 4 - v17);
    unint64_t v16 = __p;
    LOWORD(v17) = (_WORD)v27 - (_WORD)__p;
  }

  __int16 v18 = v17 - 4;
  *unint64_t v16 = 2;
  *((_BYTE *)__p + 1) = 2;
  *((_BYTE *)__p + 2) = HIBYTE(v18);
  *((_BYTE *)__p + 3) = v18;
  size_t v22 = 0LL;
  unint64_t v23 = 0LL;
  uint64_t v24 = 0LL;
  sub_1001309C0(&v22, __p, (uint64_t)v27, v27 - (_BYTE *)__p);
  char v25 = 1;
  *a2 = 0;
  sub_1002BADE0((uint64_t)(a2 + 2), (uint64_t)&v22);
  if (v25 && v22)
  {
    unint64_t v23 = v22;
    operator delete(v22);
  }

  if (__p)
  {
    int v27 = __p;
    operator delete(__p);
  }

void sub_1002B7E94( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13, void *a14, uint64_t a15)
{
  if (a13 && __p) {
    operator delete(__p);
  }
  if (a14) {
    operator delete(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B7ED4(int a1, unint64_t *a2)
{
  unint64_t v3 = *a2;
  uint64_t v2 = (_BYTE *)a2[1];
  uint64_t v4 = (uint64_t)&v2[-*a2];
  unint64_t v7 = a2[2];
  if ((unint64_t)v2 >= v7)
  {
    if (v4 <= -2) {
      goto LABEL_77;
    }
    unint64_t v9 = v7 - v3;
    if (2 * v9 <= v4 + 1) {
      uint64_t v10 = v4 + 1;
    }
    else {
      uint64_t v10 = 2 * v9;
    }
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v11 = v10;
    }
    if (v11) {
      unint64_t v12 = (unint64_t)operator new(v11);
    }
    else {
      unint64_t v12 = 0LL;
    }
    uint64_t v13 = (char *)(v12 + v11);
    *(_BYTE *)(v12 + v4) = HIBYTE(a1);
    __int128 v8 = (_BYTE *)(v12 + v4 + 1);
    if (v2 == (_BYTE *)v3)
    {
      v12 += v4;
    }

    else
    {
      __int128 v14 = &v2[~v3];
      do
      {
        char v15 = *--v2;
        (v14--)[v12] = v15;
      }

      while (v2 != (_BYTE *)v3);
      uint64_t v2 = (_BYTE *)*a2;
    }

    *a2 = v12;
    a2[1] = (unint64_t)v8;
    a2[2] = (unint64_t)v13;
    if (v2) {
      operator delete(v2);
    }
  }

  else
  {
    _BYTE *v2 = HIBYTE(a1);
    __int128 v8 = v2 + 1;
  }

  a2[1] = (unint64_t)v8;
  unint64_t v16 = a2[2];
  if ((unint64_t)v8 < v16)
  {
    _BYTE *v8 = BYTE2(a1);
    unint64_t v17 = v8 + 1;
    goto LABEL_39;
  }

  unint64_t v18 = *a2;
  std::string v19 = &v8[-*a2];
  unint64_t v20 = (unint64_t)(v19 + 1);
  unint64_t v21 = v16 - v18;
  if (2 * v21 > v20) {
    unint64_t v20 = 2 * v21;
  }
  if (v21 >= 0x3FFFFFFFFFFFFFFFLL) {
    size_t v22 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    size_t v22 = v20;
  }
  if (v22) {
    unint64_t v23 = (unint64_t)operator new(v22);
  }
  else {
    unint64_t v23 = 0LL;
  }
  uint64_t v24 = (char *)(v23 + v22);
  v19[v23] = BYTE2(a1);
  unint64_t v17 = &v19[v23 + 1];
  if (v8 == (_BYTE *)v18)
  {
    *a2 = (unint64_t)&v19[v23];
    a2[1] = (unint64_t)v17;
    a2[2] = (unint64_t)v24;
LABEL_38:
    operator delete(v8);
    goto LABEL_39;
  }

  char v25 = &v8[~v18];
  do
  {
    char v26 = *--v8;
    (v25--)[v23] = v26;
  }

  while (v8 != (_BYTE *)v18);
  __int128 v8 = (_BYTE *)*a2;
  *a2 = v23;
  a2[1] = (unint64_t)v17;
  a2[2] = (unint64_t)v24;
  if (v8) {
    goto LABEL_38;
  }
LABEL_39:
  a2[1] = (unint64_t)v17;
  unint64_t v27 = a2[2];
  if ((unint64_t)v17 < v27)
  {
    *unint64_t v17 = BYTE1(a1);
    unint64_t v28 = v17 + 1;
    goto LABEL_57;
  }

  unint64_t v29 = *a2;
  char v30 = &v17[-*a2];
  unint64_t v31 = (unint64_t)(v30 + 1);
  unint64_t v32 = v27 - v29;
  if (2 * v32 > v31) {
    unint64_t v31 = 2 * v32;
  }
  if (v32 >= 0x3FFFFFFFFFFFFFFFLL) {
    size_t v33 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    size_t v33 = v31;
  }
  if (v33) {
    unint64_t v34 = (unint64_t)operator new(v33);
  }
  else {
    unint64_t v34 = 0LL;
  }
  uint64_t v35 = (char *)(v34 + v33);
  v30[v34] = BYTE1(a1);
  unint64_t v28 = &v30[v34 + 1];
  if (v17 == (_BYTE *)v29)
  {
    *a2 = (unint64_t)&v30[v34];
    a2[1] = (unint64_t)v28;
    a2[2] = (unint64_t)v35;
LABEL_56:
    operator delete(v17);
    goto LABEL_57;
  }

  __int16 v36 = &v17[~v29];
  do
  {
    char v37 = *--v17;
    (v36--)[v34] = v37;
  }

  while (v17 != (_BYTE *)v29);
  unint64_t v17 = (_BYTE *)*a2;
  *a2 = v34;
  a2[1] = (unint64_t)v28;
  a2[2] = (unint64_t)v35;
  if (v17) {
    goto LABEL_56;
  }
LABEL_57:
  a2[1] = (unint64_t)v28;
  unint64_t v38 = a2[2];
  if ((unint64_t)v28 < v38)
  {
    *unint64_t v28 = a1;
    uint64_t v39 = (uint64_t)(v28 + 1);
    goto LABEL_75;
  }

  unint64_t v40 = *a2;
  char v41 = &v28[-*a2];
  unint64_t v42 = (unint64_t)(v41 + 1);
  if ((uint64_t)(v41 + 1) < 0) {
LABEL_77:
  }
    sub_10001E11C();
  unint64_t v43 = v38 - v40;
  if (2 * v43 > v42) {
    unint64_t v42 = 2 * v43;
  }
  if (v43 >= 0x3FFFFFFFFFFFFFFFLL) {
    size_t v44 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    size_t v44 = v42;
  }
  if (v44) {
    unint64_t v45 = (unint64_t)operator new(v44);
  }
  else {
    unint64_t v45 = 0LL;
  }
  uint64_t v46 = (char *)(v45 + v44);
  v41[v45] = a1;
  uint64_t v39 = (uint64_t)&v41[v45 + 1];
  if (v28 == (_BYTE *)v40)
  {
    *a2 = (unint64_t)&v41[v45];
    a2[1] = v39;
    a2[2] = (unint64_t)v46;
LABEL_74:
    operator delete(v28);
    goto LABEL_75;
  }

  char v47 = &v28[~v40];
  do
  {
    char v48 = *--v28;
    (v47--)[v45] = v48;
  }

  while (v28 != (_BYTE *)v40);
  unint64_t v28 = (_BYTE *)*a2;
  *a2 = v45;
  a2[1] = v39;
  a2[2] = (unint64_t)v46;
  if (v28) {
    goto LABEL_74;
  }
LABEL_75:
  a2[1] = v39;
}

void sub_1002B821C(char *a1@<X1>, _DWORD *a2@<X8>)
{
  LOBYTE(v56) = 0;
  sub_10016C2CC(&__p, 4uLL, &v56);
  unint64_t v5 = (unint64_t)__p;
  uint64_t v4 = v61;
  uint64_t v6 = v61 - (_BYTE *)__p;
  char v7 = *a1;
  if ((unint64_t)v61 >= v62)
  {
    unint64_t v9 = v62 - (void)__p;
    else {
      uint64_t v10 = 2 * v9;
    }
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v11 = v10;
    }
    if (v11) {
      unint64_t v12 = operator new(v11);
    }
    else {
      unint64_t v12 = 0LL;
    }
    uint64_t v13 = (char *)v12 + v11;
    *((_BYTE *)v12 + v6) = v7;
    __int128 v8 = (char *)v12 + v6 + 1;
    if (v4 == (_BYTE *)v5)
    {
      unint64_t v12 = (char *)v12 + v6;
    }

    else
    {
      __int128 v14 = &v4[~v5];
      do
      {
        char v15 = *--v4;
        (v14--)[(void)v12] = v15;
      }

      while (v4 != (_BYTE *)v5);
      uint64_t v4 = __p;
    }

    std::string __p = v12;
    uint64_t v61 = v8;
    unint64_t v62 = (unint64_t)v13;
    if (v4) {
      operator delete(v4);
    }
  }

  else
  {
    *uint64_t v61 = v7;
    __int128 v8 = v4 + 1;
  }

  uint64_t v61 = v8;
  unint64_t v16 = (unint64_t)__p;
  uint64_t v17 = v8 - (_BYTE *)__p;
  char v18 = a1[1];
  if ((unint64_t)v8 >= v62)
  {
    unint64_t v20 = v62 - (void)__p;
    else {
      uint64_t v21 = 2 * v20;
    }
    if (v20 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v22 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v22 = v21;
    }
    if (v22) {
      unint64_t v23 = operator new(v22);
    }
    else {
      unint64_t v23 = 0LL;
    }
    uint64_t v24 = (char *)v23 + v22;
    *((_BYTE *)v23 + v17) = v18;
    std::string v19 = (char *)v23 + v17 + 1;
    if (v8 == (_BYTE *)v16)
    {
      std::string __p = (char *)v23 + v17;
      uint64_t v61 = (char *)v23 + v17 + 1;
      unint64_t v62 = (unint64_t)v24;
    }

    else
    {
      char v25 = &v8[~v16];
      do
      {
        char v26 = *--v8;
        (v25--)[(void)v23] = v26;
      }

      while (v8 != (_BYTE *)v16);
      __int128 v8 = __p;
      std::string __p = v23;
      uint64_t v61 = (char *)v23 + v17 + 1;
      unint64_t v62 = (unint64_t)v24;
      if (!v8) {
        goto LABEL_39;
      }
    }

    operator delete(v8);
  }

  else
  {
    _BYTE *v8 = v18;
    std::string v19 = v8 + 1;
  }

void sub_1002B8688( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13, void *a14, uint64_t a15)
{
  if (a13 && __p) {
    operator delete(__p);
  }
  if (a14) {
    operator delete(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B86C8(uint64_t a1@<X1>, _DWORD *a2@<X8>)
{
  LOBYTE(v22) = 0;
  sub_10016C2CC(&__p, 4uLL, &v22);
  sub_1002B7ED4(*(_DWORD *)a1, (unint64_t *)&__p);
  sub_1002B8930(*(void *)(a1 + 8), (unint64_t *)&__p);
  sub_1002B7ED4(*(_DWORD *)(a1 + 16), (unint64_t *)&__p);
  unint64_t v5 = (unint64_t)__p;
  uint64_t v4 = v27;
  uint64_t v6 = v27 - (_BYTE *)__p;
  if ((unint64_t)(v27 - (_BYTE *)__p - 0xFFFF) < 0xFFFFFFFFFFFF0000LL)
  {
    std::string v19 = "msg.size() + sizeof(data) <= kMaxMessageSize";
    int v20 = 225;
    uint64_t v21 = "append";
    goto LABEL_31;
  }

  char v7 = *(_BYTE *)(a1 + 20);
  if ((unint64_t)v27 >= v28)
  {
    unint64_t v9 = v28 - (void)__p;
    else {
      uint64_t v10 = 2 * v9;
    }
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v11 = v10;
    }
    if (v11) {
      unint64_t v12 = operator new(v11);
    }
    else {
      unint64_t v12 = 0LL;
    }
    uint64_t v13 = (char *)v12 + v11;
    *((_BYTE *)v12 + v6) = v7;
    __int128 v8 = (char *)v12 + v6 + 1;
    if (v4 == (_BYTE *)v5)
    {
      unint64_t v12 = (char *)v12 + v6;
    }

    else
    {
      __int128 v14 = &v4[~v5];
      do
      {
        char v15 = *--v4;
        (v14--)[(void)v12] = v15;
      }

      while (v4 != (_BYTE *)v5);
      uint64_t v4 = __p;
    }

    std::string __p = v12;
    unint64_t v27 = v8;
    unint64_t v28 = (unint64_t)v13;
    if (v4) {
      operator delete(v4);
    }
  }

  else
  {
    _BYTE *v27 = v7;
    __int128 v8 = v4 + 1;
  }

  unint64_t v27 = v8;
  unint64_t v16 = __p;
  unint64_t v17 = v8 - (_BYTE *)__p;
  if ((unint64_t)(v8 - (_BYTE *)__p) >= 0x10000)
  {
    std::string v19 = "msg.size() <= kMaxMessageSize";
    int v20 = 166;
    uint64_t v21 = "populateHeader";
LABEL_31:
    __assert_rtn(v21, "AlishaDCKCoder.cpp", v20, v19);
  }

  if (v17 <= 3)
  {
    sub_1000353EC((unint64_t *)&__p, 4 - v17);
    unint64_t v16 = __p;
    LOWORD(v17) = (_WORD)v27 - (_WORD)__p;
  }

  __int16 v18 = v17 - 4;
  *unint64_t v16 = 2;
  *((_BYTE *)__p + 1) = 6;
  *((_BYTE *)__p + 2) = HIBYTE(v18);
  *((_BYTE *)__p + 3) = v18;
  size_t v22 = 0LL;
  unint64_t v23 = 0LL;
  uint64_t v24 = 0LL;
  sub_1001309C0(&v22, __p, (uint64_t)v27, v27 - (_BYTE *)__p);
  char v25 = 1;
  *a2 = 0;
  sub_1002BADE0((uint64_t)(a2 + 2), (uint64_t)&v22);
  if (v25 && v22)
  {
    unint64_t v23 = v22;
    operator delete(v22);
  }

  if (__p)
  {
    unint64_t v27 = __p;
    operator delete(__p);
  }

void sub_1002B88F0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13, void *a14, uint64_t a15)
{
  if (a13 && __p) {
    operator delete(__p);
  }
  if (a14) {
    operator delete(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B8930(uint64_t a1, unint64_t *a2)
{
  unint64_t v3 = *a2;
  uint64_t v2 = (_BYTE *)a2[1];
  uint64_t v4 = (uint64_t)&v2[-*a2];
  unint64_t v7 = a2[2];
  if ((unint64_t)v2 >= v7)
  {
    if (v4 <= -2) {
      goto LABEL_149;
    }
    unint64_t v9 = v7 - v3;
    if (2 * v9 <= v4 + 1) {
      uint64_t v10 = v4 + 1;
    }
    else {
      uint64_t v10 = 2 * v9;
    }
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v11 = v10;
    }
    if (v11) {
      unint64_t v12 = (unint64_t)operator new(v11);
    }
    else {
      unint64_t v12 = 0LL;
    }
    uint64_t v13 = (char *)(v12 + v11);
    *(_BYTE *)(v12 + v4) = HIBYTE(a1);
    __int128 v8 = (_BYTE *)(v12 + v4 + 1);
    if (v2 == (_BYTE *)v3)
    {
      v12 += v4;
    }

    else
    {
      __int128 v14 = &v2[~v3];
      do
      {
        char v15 = *--v2;
        (v14--)[v12] = v15;
      }

      while (v2 != (_BYTE *)v3);
      uint64_t v2 = (_BYTE *)*a2;
    }

    *a2 = v12;
    a2[1] = (unint64_t)v8;
    a2[2] = (unint64_t)v13;
    if (v2) {
      operator delete(v2);
    }
  }

  else
  {
    _BYTE *v2 = HIBYTE(a1);
    __int128 v8 = v2 + 1;
  }

  a2[1] = (unint64_t)v8;
  unint64_t v16 = a2[2];
  if ((unint64_t)v8 < v16)
  {
    _BYTE *v8 = BYTE6(a1);
    unint64_t v17 = v8 + 1;
    goto LABEL_39;
  }

  unint64_t v18 = *a2;
  std::string v19 = &v8[-*a2];
  unint64_t v20 = (unint64_t)(v19 + 1);
  unint64_t v21 = v16 - v18;
  if (2 * v21 > v20) {
    unint64_t v20 = 2 * v21;
  }
  if (v21 >= 0x3FFFFFFFFFFFFFFFLL) {
    size_t v22 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    size_t v22 = v20;
  }
  if (v22) {
    unint64_t v23 = (unint64_t)operator new(v22);
  }
  else {
    unint64_t v23 = 0LL;
  }
  uint64_t v24 = (char *)(v23 + v22);
  v19[v23] = BYTE6(a1);
  unint64_t v17 = &v19[v23 + 1];
  if (v8 == (_BYTE *)v18)
  {
    *a2 = (unint64_t)&v19[v23];
    a2[1] = (unint64_t)v17;
    a2[2] = (unint64_t)v24;
LABEL_38:
    operator delete(v8);
    goto LABEL_39;
  }

  char v25 = &v8[~v18];
  do
  {
    char v26 = *--v8;
    (v25--)[v23] = v26;
  }

  while (v8 != (_BYTE *)v18);
  __int128 v8 = (_BYTE *)*a2;
  *a2 = v23;
  a2[1] = (unint64_t)v17;
  a2[2] = (unint64_t)v24;
  if (v8) {
    goto LABEL_38;
  }
LABEL_39:
  a2[1] = (unint64_t)v17;
  unint64_t v27 = a2[2];
  if ((unint64_t)v17 < v27)
  {
    *unint64_t v17 = BYTE5(a1);
    unint64_t v28 = v17 + 1;
    goto LABEL_57;
  }

  unint64_t v29 = *a2;
  char v30 = &v17[-*a2];
  unint64_t v31 = (unint64_t)(v30 + 1);
  unint64_t v32 = v27 - v29;
  if (2 * v32 > v31) {
    unint64_t v31 = 2 * v32;
  }
  if (v32 >= 0x3FFFFFFFFFFFFFFFLL) {
    size_t v33 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    size_t v33 = v31;
  }
  if (v33) {
    unint64_t v34 = (unint64_t)operator new(v33);
  }
  else {
    unint64_t v34 = 0LL;
  }
  uint64_t v35 = (char *)(v34 + v33);
  v30[v34] = BYTE5(a1);
  unint64_t v28 = &v30[v34 + 1];
  if (v17 == (_BYTE *)v29)
  {
    *a2 = (unint64_t)&v30[v34];
    a2[1] = (unint64_t)v28;
    a2[2] = (unint64_t)v35;
LABEL_56:
    operator delete(v17);
    goto LABEL_57;
  }

  __int16 v36 = &v17[~v29];
  do
  {
    char v37 = *--v17;
    (v36--)[v34] = v37;
  }

  while (v17 != (_BYTE *)v29);
  unint64_t v17 = (_BYTE *)*a2;
  *a2 = v34;
  a2[1] = (unint64_t)v28;
  a2[2] = (unint64_t)v35;
  if (v17) {
    goto LABEL_56;
  }
LABEL_57:
  a2[1] = (unint64_t)v28;
  unint64_t v38 = a2[2];
  if ((unint64_t)v28 < v38)
  {
    *unint64_t v28 = BYTE4(a1);
    unint64_t v39 = v28 + 1;
    goto LABEL_75;
  }

  unint64_t v40 = *a2;
  char v41 = &v28[-*a2];
  unint64_t v42 = (unint64_t)(v41 + 1);
  unint64_t v43 = v38 - v40;
  if (2 * v43 > v42) {
    unint64_t v42 = 2 * v43;
  }
  if (v43 >= 0x3FFFFFFFFFFFFFFFLL) {
    size_t v44 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    size_t v44 = v42;
  }
  if (v44) {
    unint64_t v45 = (unint64_t)operator new(v44);
  }
  else {
    unint64_t v45 = 0LL;
  }
  uint64_t v46 = (char *)(v45 + v44);
  v41[v45] = BYTE4(a1);
  unint64_t v39 = &v41[v45 + 1];
  if (v28 == (_BYTE *)v40)
  {
    *a2 = (unint64_t)&v41[v45];
    a2[1] = (unint64_t)v39;
    a2[2] = (unint64_t)v46;
LABEL_74:
    operator delete(v28);
    goto LABEL_75;
  }

  char v47 = &v28[~v40];
  do
  {
    char v48 = *--v28;
    (v47--)[v45] = v48;
  }

  while (v28 != (_BYTE *)v40);
  unint64_t v28 = (_BYTE *)*a2;
  *a2 = v45;
  a2[1] = (unint64_t)v39;
  a2[2] = (unint64_t)v46;
  if (v28) {
    goto LABEL_74;
  }
LABEL_75:
  a2[1] = (unint64_t)v39;
  unint64_t v49 = a2[2];
  if ((unint64_t)v39 < v49)
  {
    _BYTE *v39 = BYTE3(a1);
    uint64_t v50 = v39 + 1;
    goto LABEL_93;
  }

  unint64_t v51 = *a2;
  __int16 v52 = &v39[-*a2];
  unint64_t v53 = (unint64_t)(v52 + 1);
  unint64_t v54 = v49 - v51;
  if (2 * v54 > v53) {
    unint64_t v53 = 2 * v54;
  }
  if (v54 >= 0x3FFFFFFFFFFFFFFFLL) {
    size_t v55 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    size_t v55 = v53;
  }
  if (v55) {
    unint64_t v56 = (unint64_t)operator new(v55);
  }
  else {
    unint64_t v56 = 0LL;
  }
  id v57 = (char *)(v56 + v55);
  v52[v56] = BYTE3(a1);
  uint64_t v50 = &v52[v56 + 1];
  if (v39 == (_BYTE *)v51)
  {
    *a2 = (unint64_t)&v52[v56];
    a2[1] = (unint64_t)v50;
    a2[2] = (unint64_t)v57;
LABEL_92:
    operator delete(v39);
    goto LABEL_93;
  }

  uint64_t v58 = &v39[~v51];
  do
  {
    char v59 = *--v39;
    (v58--)[v56] = v59;
  }

  while (v39 != (_BYTE *)v51);
  unint64_t v39 = (_BYTE *)*a2;
  *a2 = v56;
  a2[1] = (unint64_t)v50;
  a2[2] = (unint64_t)v57;
  if (v39) {
    goto LABEL_92;
  }
LABEL_93:
  a2[1] = (unint64_t)v50;
  unint64_t v60 = a2[2];
  if ((unint64_t)v50 < v60)
  {
    _BYTE *v50 = BYTE2(a1);
    uint64_t v61 = v50 + 1;
    goto LABEL_111;
  }

  unint64_t v62 = *a2;
  uint64_t v63 = &v50[-*a2];
  unint64_t v64 = (unint64_t)(v63 + 1);
  unint64_t v65 = v60 - v62;
  if (2 * v65 > v64) {
    unint64_t v64 = 2 * v65;
  }
  if (v65 >= 0x3FFFFFFFFFFFFFFFLL) {
    size_t v66 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    size_t v66 = v64;
  }
  if (v66) {
    unint64_t v67 = (unint64_t)operator new(v66);
  }
  else {
    unint64_t v67 = 0LL;
  }
  uint64_t v68 = (char *)(v67 + v66);
  v63[v67] = BYTE2(a1);
  uint64_t v61 = &v63[v67 + 1];
  if (v50 == (_BYTE *)v62)
  {
    *a2 = (unint64_t)&v63[v67];
    a2[1] = (unint64_t)v61;
    a2[2] = (unint64_t)v68;
LABEL_110:
    operator delete(v50);
    goto LABEL_111;
  }

  uint64_t v69 = &v50[~v62];
  do
  {
    char v70 = *--v50;
    (v69--)[v67] = v70;
  }

  while (v50 != (_BYTE *)v62);
  uint64_t v50 = (_BYTE *)*a2;
  *a2 = v67;
  a2[1] = (unint64_t)v61;
  a2[2] = (unint64_t)v68;
  if (v50) {
    goto LABEL_110;
  }
LABEL_111:
  a2[1] = (unint64_t)v61;
  unint64_t v71 = a2[2];
  if ((unint64_t)v61 < v71)
  {
    *uint64_t v61 = BYTE1(a1);
    uint64_t v72 = v61 + 1;
    goto LABEL_129;
  }

  unint64_t v73 = *a2;
  uint64_t v74 = &v61[-*a2];
  unint64_t v75 = (unint64_t)(v74 + 1);
  unint64_t v76 = v71 - v73;
  if (2 * v76 > v75) {
    unint64_t v75 = 2 * v76;
  }
  if (v76 >= 0x3FFFFFFFFFFFFFFFLL) {
    size_t v77 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    size_t v77 = v75;
  }
  if (v77) {
    unint64_t v78 = (unint64_t)operator new(v77);
  }
  else {
    unint64_t v78 = 0LL;
  }
  char v79 = (char *)(v78 + v77);
  v74[v78] = BYTE1(a1);
  uint64_t v72 = &v74[v78 + 1];
  if (v61 == (_BYTE *)v73)
  {
    *a2 = (unint64_t)&v74[v78];
    a2[1] = (unint64_t)v72;
    a2[2] = (unint64_t)v79;
LABEL_128:
    operator delete(v61);
    goto LABEL_129;
  }

  uint64_t v80 = &v61[~v73];
  do
  {
    char v81 = *--v61;
    (v80--)[v78] = v81;
  }

  while (v61 != (_BYTE *)v73);
  uint64_t v61 = (_BYTE *)*a2;
  *a2 = v78;
  a2[1] = (unint64_t)v72;
  a2[2] = (unint64_t)v79;
  if (v61) {
    goto LABEL_128;
  }
LABEL_129:
  a2[1] = (unint64_t)v72;
  unint64_t v82 = a2[2];
  if ((unint64_t)v72 < v82)
  {
    *uint64_t v72 = a1;
    uint64_t v83 = (uint64_t)(v72 + 1);
    goto LABEL_147;
  }

  unint64_t v84 = *a2;
  uint64_t v85 = &v72[-*a2];
  unint64_t v86 = (unint64_t)(v85 + 1);
  if ((uint64_t)(v85 + 1) < 0) {
LABEL_149:
  }
    sub_10001E11C();
  unint64_t v87 = v82 - v84;
  if (2 * v87 > v86) {
    unint64_t v86 = 2 * v87;
  }
  if (v87 >= 0x3FFFFFFFFFFFFFFFLL) {
    size_t v88 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    size_t v88 = v86;
  }
  if (v88) {
    unint64_t v89 = (unint64_t)operator new(v88);
  }
  else {
    unint64_t v89 = 0LL;
  }
  uint64_t v90 = (char *)(v89 + v88);
  v85[v89] = a1;
  uint64_t v83 = (uint64_t)&v85[v89 + 1];
  if (v72 == (_BYTE *)v84)
  {
    *a2 = (unint64_t)&v85[v89];
    a2[1] = v83;
    a2[2] = (unint64_t)v90;
LABEL_146:
    operator delete(v72);
    goto LABEL_147;
  }

  uint64_t v91 = &v72[~v84];
  do
  {
    char v92 = *--v72;
    (v91--)[v89] = v92;
  }

  while (v72 != (_BYTE *)v84);
  uint64_t v72 = (_BYTE *)*a2;
  *a2 = v89;
  a2[1] = v83;
  a2[2] = (unint64_t)v90;
  if (v72) {
    goto LABEL_146;
  }
LABEL_147:
  a2[1] = v83;
}

void sub_1002B8F78(int *a1@<X1>, _DWORD *a2@<X8>)
{
  LOBYTE(__p) = 0;
  sub_10016C2CC(&v11, 4uLL, &__p);
  sub_1002B7ED4(*a1, (unint64_t *)&v11);
  uint64_t v4 = v11;
  unint64_t v5 = v12 - (_BYTE *)v11;
  if (v5 <= 3)
  {
    sub_1000353EC((unint64_t *)&v11, 4 - v5);
    uint64_t v4 = v11;
    LOWORD(v5) = (_WORD)v12 - (_WORD)v11;
  }

  __int16 v6 = v5 - 4;
  *uint64_t v4 = 2;
  *((_BYTE *)v11 + 1) = 7;
  *((_BYTE *)v11 + 2) = HIBYTE(v6);
  *((_BYTE *)v11 + 3) = v6;
  std::string __p = 0LL;
  __int128 v8 = 0LL;
  uint64_t v9 = 0LL;
  sub_1001309C0(&__p, v11, (uint64_t)v12, v12 - (_BYTE *)v11);
  char v10 = 1;
  *a2 = 0;
  sub_1002BADE0((uint64_t)(a2 + 2), (uint64_t)&__p);
  if (v10 && __p)
  {
    __int128 v8 = __p;
    operator delete(__p);
  }

  if (v11)
  {
    unint64_t v12 = v11;
    operator delete(v11);
  }

void sub_1002B909C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13, void *a14, uint64_t a15)
{
  if (a13 && __p) {
    operator delete(__p);
  }
  if (a14) {
    operator delete(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B90DC(char *a1@<X1>, _DWORD *a2@<X8>)
{
  LOBYTE(v22) = 0;
  sub_10016C2CC(&__p, 4uLL, &v22);
  unint64_t v5 = (unint64_t)__p;
  uint64_t v4 = v27;
  uint64_t v6 = v27 - (_BYTE *)__p;
  if ((unint64_t)(v27 - (_BYTE *)__p - 0xFFFF) < 0xFFFFFFFFFFFF0000LL)
  {
    std::string v19 = "msg.size() + sizeof(data) <= kMaxMessageSize";
    int v20 = 225;
    unint64_t v21 = "append";
    goto LABEL_31;
  }

  char v7 = *a1;
  if ((unint64_t)v27 >= v28)
  {
    unint64_t v9 = v28 - (void)__p;
    else {
      uint64_t v10 = 2 * v9;
    }
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v11 = v10;
    }
    if (v11) {
      unint64_t v12 = operator new(v11);
    }
    else {
      unint64_t v12 = 0LL;
    }
    uint64_t v13 = (char *)v12 + v11;
    *((_BYTE *)v12 + v6) = v7;
    __int128 v8 = (char *)v12 + v6 + 1;
    if (v4 == (_BYTE *)v5)
    {
      unint64_t v12 = (char *)v12 + v6;
    }

    else
    {
      __int128 v14 = &v4[~v5];
      do
      {
        char v15 = *--v4;
        (v14--)[(void)v12] = v15;
      }

      while (v4 != (_BYTE *)v5);
      uint64_t v4 = __p;
    }

    std::string __p = v12;
    unint64_t v27 = v8;
    unint64_t v28 = (unint64_t)v13;
    if (v4) {
      operator delete(v4);
    }
  }

  else
  {
    _BYTE *v27 = v7;
    __int128 v8 = v4 + 1;
  }

  unint64_t v27 = v8;
  unint64_t v16 = __p;
  unint64_t v17 = v8 - (_BYTE *)__p;
  if ((unint64_t)(v8 - (_BYTE *)__p) >= 0x10000)
  {
    std::string v19 = "msg.size() <= kMaxMessageSize";
    int v20 = 166;
    unint64_t v21 = "populateHeader";
LABEL_31:
    __assert_rtn(v21, "AlishaDCKCoder.cpp", v20, v19);
  }

  if (v17 <= 3)
  {
    sub_1000353EC((unint64_t *)&__p, 4 - v17);
    unint64_t v16 = __p;
    LOWORD(v17) = (_WORD)v27 - (_WORD)__p;
  }

  __int16 v18 = v17 - 4;
  *unint64_t v16 = 2;
  *((_BYTE *)__p + 1) = 8;
  *((_BYTE *)__p + 2) = HIBYTE(v18);
  *((_BYTE *)__p + 3) = v18;
  size_t v22 = 0LL;
  unint64_t v23 = 0LL;
  uint64_t v24 = 0LL;
  sub_1001309C0(&v22, __p, (uint64_t)v27, v27 - (_BYTE *)__p);
  char v25 = 1;
  *a2 = 0;
  sub_1002BADE0((uint64_t)(a2 + 2), (uint64_t)&v22);
  if (v25 && v22)
  {
    unint64_t v23 = v22;
    operator delete(v22);
  }

  if (__p)
  {
    unint64_t v27 = __p;
    operator delete(__p);
  }

void sub_1002B92E0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13, void *a14, uint64_t a15)
{
  if (a13 && __p) {
    operator delete(__p);
  }
  if (a14) {
    operator delete(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B9320(uint64_t a1@<X1>, _DWORD *a2@<X8>)
{
  LOBYTE(__p) = 0;
  sub_10016C2CC(&v11, 4uLL, &__p);
  sub_1002B7ED4(*(_DWORD *)a1, (unint64_t *)&v11);
  sub_1002B8930(*(void *)(a1 + 8), (unint64_t *)&v11);
  uint64_t v4 = v11;
  unint64_t v5 = v12 - (_BYTE *)v11;
  if (v5 <= 3)
  {
    sub_1000353EC((unint64_t *)&v11, 4 - v5);
    uint64_t v4 = v11;
    LOWORD(v5) = (_WORD)v12 - (_WORD)v11;
  }

  __int16 v6 = v5 - 4;
  *uint64_t v4 = 2;
  *((_BYTE *)v11 + 1) = 10;
  *((_BYTE *)v11 + 2) = HIBYTE(v6);
  *((_BYTE *)v11 + 3) = v6;
  std::string __p = 0LL;
  __int128 v8 = 0LL;
  uint64_t v9 = 0LL;
  sub_1001309C0(&__p, v11, (uint64_t)v12, v12 - (_BYTE *)v11);
  char v10 = 1;
  *a2 = 0;
  sub_1002BADE0((uint64_t)(a2 + 2), (uint64_t)&__p);
  if (v10 && __p)
  {
    __int128 v8 = __p;
    operator delete(__p);
  }

  if (v11)
  {
    unint64_t v12 = v11;
    operator delete(v11);
  }

void sub_1002B9450( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13, void *a14, uint64_t a15)
{
  if (a13 && __p) {
    operator delete(__p);
  }
  if (a14) {
    operator delete(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B9490(char *a1@<X1>, _DWORD *a2@<X8>)
{
  LOBYTE(v22) = 0;
  sub_10016C2CC(&__p, 4uLL, &v22);
  unint64_t v5 = (unint64_t)__p;
  uint64_t v4 = v27;
  uint64_t v6 = v27 - (_BYTE *)__p;
  if ((unint64_t)(v27 - (_BYTE *)__p - 0xFFFF) < 0xFFFFFFFFFFFF0000LL)
  {
    std::string v19 = "msg.size() + sizeof(data) <= kMaxMessageSize";
    int v20 = 225;
    unint64_t v21 = "append";
    goto LABEL_31;
  }

  char v7 = *a1;
  if ((unint64_t)v27 >= v28)
  {
    unint64_t v9 = v28 - (void)__p;
    else {
      uint64_t v10 = 2 * v9;
    }
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v11 = v10;
    }
    if (v11) {
      unint64_t v12 = operator new(v11);
    }
    else {
      unint64_t v12 = 0LL;
    }
    uint64_t v13 = (char *)v12 + v11;
    *((_BYTE *)v12 + v6) = v7;
    __int128 v8 = (char *)v12 + v6 + 1;
    if (v4 == (_BYTE *)v5)
    {
      unint64_t v12 = (char *)v12 + v6;
    }

    else
    {
      __int128 v14 = &v4[~v5];
      do
      {
        char v15 = *--v4;
        (v14--)[(void)v12] = v15;
      }

      while (v4 != (_BYTE *)v5);
      uint64_t v4 = __p;
    }

    std::string __p = v12;
    unint64_t v27 = v8;
    unint64_t v28 = (unint64_t)v13;
    if (v4) {
      operator delete(v4);
    }
  }

  else
  {
    _BYTE *v27 = v7;
    __int128 v8 = v4 + 1;
  }

  unint64_t v27 = v8;
  sub_1002B7ED4(*((_DWORD *)a1 + 1), (unint64_t *)&__p);
  sub_1002B8930(*((void *)a1 + 1), (unint64_t *)&__p);
  unint64_t v16 = __p;
  unint64_t v17 = v27 - (_BYTE *)__p;
  if ((unint64_t)(v27 - (_BYTE *)__p) >= 0x10000)
  {
    std::string v19 = "msg.size() <= kMaxMessageSize";
    int v20 = 166;
    unint64_t v21 = "populateHeader";
LABEL_31:
    __assert_rtn(v21, "AlishaDCKCoder.cpp", v20, v19);
  }

  if (v17 <= 3)
  {
    sub_1000353EC((unint64_t *)&__p, 4 - v17);
    unint64_t v16 = __p;
    LOWORD(v17) = (_WORD)v27 - (_WORD)__p;
  }

  __int16 v18 = v17 - 4;
  *unint64_t v16 = 2;
  *((_BYTE *)__p + 1) = 19;
  *((_BYTE *)__p + 2) = HIBYTE(v18);
  *((_BYTE *)__p + 3) = v18;
  size_t v22 = 0LL;
  unint64_t v23 = 0LL;
  uint64_t v24 = 0LL;
  sub_1001309C0(&v22, __p, (uint64_t)v27, v27 - (_BYTE *)__p);
  char v25 = 1;
  *a2 = 0;
  sub_1002BADE0((uint64_t)(a2 + 2), (uint64_t)&v22);
  if (v25 && v22)
  {
    unint64_t v23 = v22;
    operator delete(v22);
  }

  if (__p)
  {
    unint64_t v27 = __p;
    operator delete(__p);
  }

void sub_1002B96B4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13, void *a14, uint64_t a15)
{
  if (a13 && __p) {
    operator delete(__p);
  }
  if (a14) {
    operator delete(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B96F4(uint64_t *a1@<X1>, int *a2@<X8>)
{
  uint64_t v3 = *a1;
  unint64_t v4 = a1[1] - *a1;
  if (v4 < 4)
  {
    int v5 = -4000;
LABEL_17:
    LOBYTE(v49) = 0;
    char v55 = 0;
    *a2 = v5;
    sub_1002BAE6C((uint64_t)(a2 + 2), (uint64_t)&v49);
    sub_1002BAB08((uint64_t)&v49);
    return;
  }

  if (v4 >> 16)
  {
    int v5 = -4001;
    goto LABEL_17;
  }

  if (v4 != __rev16(*(unsigned __int16 *)(v3 + 2)) + 4LL)
  {
    int v5 = -4002;
    goto LABEL_17;
  }

  unint64_t v45 = 0LL;
  uint64_t v46 = 0LL;
  uint64_t v47 = 0LL;
  unint64_t v42 = 0LL;
  unint64_t v43 = 0LL;
  uint64_t v44 = 0LL;
  std::string __p = 0LL;
  unint64_t v40 = 0LL;
  uint64_t v41 = 0LL;
  if (v4 <= 4)
  {
    LOBYTE(v49) = 0;
    char v55 = 0;
    *a2 = -4007;
    sub_1002BAE6C((uint64_t)(a2 + 2), (uint64_t)&v49);
LABEL_52:
    sub_1002BAB08((uint64_t)&v49);
    goto LABEL_53;
  }

  unint64_t v6 = *(unsigned __int8 *)(v3 + 4);
  if (v6 + 4 >= v4)
  {
    LOBYTE(v49) = 0;
    char v55 = 0;
    *a2 = -4011;
    sub_1002BAE6C((uint64_t)(a2 + 2), (uint64_t)&v49);
    goto LABEL_52;
  }

  if (!(_DWORD)v6)
  {
    LOBYTE(v49) = 0;
    char v55 = 0;
    *a2 = -4008;
    sub_1002BAE6C((uint64_t)(a2 + 2), (uint64_t)&v49);
    goto LABEL_52;
  }

  if ((v6 & 1) != 0)
  {
    LOBYTE(v49) = 0;
    char v55 = 0;
    *a2 = -4009;
    sub_1002BAE6C((uint64_t)(a2 + 2), (uint64_t)&v49);
    goto LABEL_52;
  }

  unsigned __int8 v38 = v6;
  sub_1002B9CFC((uint64_t)&v45, v6 >> 1);
  __int128 v8 = v45;
  unint64_t v9 = v46;
  if (v45 != v46)
  {
    uint64_t v10 = *a1;
    unint64_t v11 = a1[1] - *a1;
    unsigned __int16 v12 = 5;
    uint64_t v13 = "msg.size() <= kMaxMessageSize";
    while (!(v11 >> 16))
    {
      if ((unint64_t)v12 + 2 > v11)
      {
        int v29 = 191;
        uint64_t v13 = "offset + sizeof(val) <= msg.size()";
LABEL_49:
        __assert_rtn("readAndAdvance", "AlishaDCKCoder.cpp", v29, v13);
      }

      unsigned __int16 v14 = v12 + 1;
      __int16 v15 = *(unsigned __int8 *)(v10 + v12);
      _WORD *v8 = v15 << 8;
      v12 += 2;
      *v8++ = *(unsigned __int8 *)(v10 + v14) | (unsigned __int16)(v15 << 8);
      if (v8 == v9) {
        goto LABEL_24;
      }
    }

    int v29 = 190;
    goto LABEL_49;
  }

  unsigned __int16 v12 = 5;
LABEL_24:
  unsigned __int16 v48 = v12;
  if (v4 <= v12)
  {
    LOBYTE(v49) = 0;
    char v55 = 0;
    *a2 = -4012;
    sub_1002BAE6C((uint64_t)(a2 + 2), (uint64_t)&v49);
    goto LABEL_52;
  }

  uint64_t v16 = *(unsigned __int8 *)(*a1 + v12);
  if (v16 + (unint64_t)v12 >= v4)
  {
    LOBYTE(v49) = 0;
    char v55 = 0;
    *a2 = -4016;
    sub_1002BAE6C((uint64_t)(a2 + 2), (uint64_t)&v49);
    goto LABEL_52;
  }

  if (!*(_BYTE *)(*a1 + v12))
  {
    LOBYTE(v49) = 0;
    char v55 = 0;
    *a2 = -4013;
    sub_1002BAE6C((uint64_t)(a2 + 2), (uint64_t)&v49);
    goto LABEL_52;
  }

  if ((v16 & 1) != 0)
  {
    LOBYTE(v49) = 0;
    char v55 = 0;
    *a2 = -4014;
    sub_1002BAE6C((uint64_t)(a2 + 2), (uint64_t)&v49);
    goto LABEL_52;
  }

  sub_1002B9CB8(&v38, a1, &v48);
  sub_1002B9CFC((uint64_t)&v42, (unint64_t)v38 >> 1);
  unint64_t v17 = v42;
  __int16 v18 = v43;
  unsigned __int16 v19 = v48;
  if (v42 != v43)
  {
    uint64_t v20 = *a1;
    unint64_t v21 = a1[1] - *a1;
    size_t v22 = "msg.size() <= kMaxMessageSize";
    while (!(v21 >> 16))
    {
      if ((unint64_t)v19 + 2 > v21)
      {
        int v30 = 191;
        size_t v22 = "offset + sizeof(val) <= msg.size()";
LABEL_61:
        __assert_rtn("readAndAdvance", "AlishaDCKCoder.cpp", v30, v22);
      }

      unsigned __int16 v23 = v19 + 1;
      __int16 v24 = *(unsigned __int8 *)(v20 + v19);
      *unint64_t v17 = v24 << 8;
      v19 += 2;
      *v17++ = *(unsigned __int8 *)(v20 + v23) | (unsigned __int16)(v24 << 8);
      if (v17 == v18) {
        goto LABEL_33;
      }
    }

    int v30 = 190;
    goto LABEL_61;
  }

void sub_1002B9C08( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void *__p, uint64_t a22, uint64_t a23, void *a24, uint64_t a25, uint64_t a26, void *a27, uint64_t a28)
{
  if (__p) {
    operator delete(__p);
  }
  if (a24) {
    operator delete(a24);
  }
  if (a27) {
    operator delete(a27);
  }
  _Unwind_Resume(a1);
}

_BYTE *sub_1002B9CB8(_BYTE *result, uint64_t *a2, _WORD *a3)
{
  uint64_t v3 = *a2;
  unint64_t v4 = a2[1] - *a2;
  if (v4 >= 0x10000) {
    sub_1003A6B24();
  }
  unint64_t v5 = (unsigned __int16)*a3;
  if (v4 <= v5) {
    sub_1003A6B4C((uint64_t)result, (uint64_t)a2, (uint64_t)a3);
  }
  *a3 = v5 + 1;
  *double result = *(_BYTE *)(v3 + v5);
  return result;
}

void sub_1002B9CFC(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 1;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = *(void *)a1 + 2 * a2;
    }
  }

  else
  {
    sub_1002BAF74((char **)a1, a2 - v2);
  }

uint64_t sub_1002B9D2C(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }

  uint64_t v3 = *(void **)(a1 + 24);
  if (v3)
  {
    *(void *)(a1 + 32) = v3;
    operator delete(v3);
  }

  unint64_t v4 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v4;
    operator delete(v4);
  }

  return a1;
}

uint64_t sub_1002B9D7C@<X0>(uint64_t result@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v4 = *a2;
  unint64_t v5 = a2[1] - *a2;
  if (v5 < 4)
  {
    int v6 = -4000;
LABEL_16:
    char v14 = 0;
    *(_DWORD *)a4 = v6;
    *(_BYTE *)(a4 + 4) = 0;
    goto LABEL_17;
  }

  if (v5 >> 16)
  {
    int v6 = -4001;
    goto LABEL_16;
  }

  uint64_t v7 = *(unsigned __int8 *)(v4 + 3);
  uint64_t v8 = *(unsigned __int8 *)(v4 + 2);
  if (v5 != (v7 | (v8 << 8)) + 4)
  {
    int v6 = -4002;
    goto LABEL_16;
  }

  if ((v7 | ((_DWORD)v8 << 8)) != 0xA)
  {
    int v6 = -4006;
    goto LABEL_16;
  }

  if (v5 <= 5) {
    sub_1003A6B70(result, (uint64_t)a2, a3);
  }
  if (v5 <= 7) {
    sub_1003A6B70(result, (uint64_t)a2, a3);
  }
  if (v5 <= 0xB) {
    sub_1003A6B94(result, (uint64_t)a2, a3);
  }
  if (v5 == 12) {
    sub_1003A6B4C(result, (uint64_t)a2, a3);
  }
  if (v5 <= 0xD) {
    sub_1003A6B4C(result, (uint64_t)a2, a3);
  }
  if (v5 != 14) {
    sub_1003A6BB8();
  }
  unsigned int v9 = bswap32(*(unsigned __int16 *)(v4 + 4));
  unsigned int v10 = bswap32(*(unsigned __int16 *)(v4 + 6)) >> 16;
  unsigned int v11 = bswap32(*(_DWORD *)(v4 + 8));
  char v12 = *(_BYTE *)(v4 + 12);
  char v13 = *(_BYTE *)(v4 + 13);
  *(_DWORD *)a4 = 0;
  *(_WORD *)(a4 + 4) = HIWORD(v9);
  *(_WORD *)(a4 + 6) = v10;
  *(_DWORD *)(a4 + _Block_object_dispose((const void *)(v1 - 112), 8) = v11;
  *(_BYTE *)(a4 + 12) = v12;
  *(_BYTE *)(a4 + 13) = v13;
  char v14 = 1;
LABEL_17:
  *(_BYTE *)(a4 + 16) = v14;
  return result;
}

uint64_t sub_1002B9E84@<X0>(uint64_t result@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v4 = *a2;
  unint64_t v5 = a2[1] - *a2;
  if (v5 < 4)
  {
    int v6 = -4000;
LABEL_16:
    char v15 = 0;
    *(_DWORD *)a4 = v6;
    *(_BYTE *)(a4 + 4) = 0;
    goto LABEL_17;
  }

  if (v5 >> 16)
  {
    int v6 = -4001;
    goto LABEL_16;
  }

  uint64_t v7 = *(unsigned __int8 *)(v4 + 3);
  uint64_t v8 = *(unsigned __int8 *)(v4 + 2);
  if (v5 != (v7 | (v8 << 8)) + 4)
  {
    int v6 = -4002;
    goto LABEL_16;
  }

  if ((v7 | ((_DWORD)v8 << 8)) != 9)
  {
    int v6 = -4006;
    goto LABEL_16;
  }

  if (v5 <= 4) {
    sub_1003A6B4C(result, (uint64_t)a2, a3);
  }
  if (v5 == 5) {
    sub_1003A6B4C(result, (uint64_t)a2, a3);
  }
  if (v5 <= 6) {
    sub_1003A6B4C(result, (uint64_t)a2, a3);
  }
  if (v5 == 7) {
    sub_1003A6B4C(result, (uint64_t)a2, a3);
  }
  if (v5 <= 0xB) {
    sub_1003A6B94(result, (uint64_t)a2, a3);
  }
  if (v5 != 13)
  {
    if (v5 == 12) {
      sub_1003A6B4C(result, (uint64_t)a2, a3);
    }
    sub_1003A6BE0();
  }

  char v9 = *(_BYTE *)(v4 + 4);
  char v10 = *(_BYTE *)(v4 + 5);
  char v11 = *(_BYTE *)(v4 + 6);
  char v12 = *(_BYTE *)(v4 + 7);
  unsigned int v13 = bswap32(*(_DWORD *)(v4 + 8));
  char v14 = *(_BYTE *)(v4 + 12);
  *(_DWORD *)a4 = 0;
  *(_BYTE *)(a4 + 4) = v9;
  *(_BYTE *)(a4 + 5) = v10;
  *(_BYTE *)(a4 + 6) = v11;
  *(_BYTE *)(a4 + 7) = v12;
  *(_DWORD *)(a4 + _Block_object_dispose((const void *)(v1 - 112), 8) = v13;
  char v15 = 1;
  *(_BYTE *)(a4 + 12) = v14;
LABEL_17:
  *(_BYTE *)(a4 + 16) = v15;
  return result;
}

uint64_t sub_1002B9F90(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = *a2;
  unint64_t v4 = a2[1] - *a2;
  if (v4 < 4)
  {
    int v5 = -4000;
LABEL_12:
    LODWORD(v_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
    LODWORD(sub_1002AF83C(v11, v10) = v5;
    goto LABEL_13;
  }

  if (v4 >> 16)
  {
    int v5 = -4001;
    goto LABEL_12;
  }

  uint64_t v6 = *(unsigned __int8 *)(v3 + 3);
  uint64_t v7 = *(unsigned __int8 *)(v3 + 2);
  if (v4 != (v6 | (v7 << 8)) + 4)
  {
    int v5 = -4002;
    goto LABEL_12;
  }

  if ((v6 | ((_DWORD)v7 << 8)) != 4)
  {
    int v5 = -4006;
    goto LABEL_12;
  }

  if (v4 <= 7) {
    sub_1003A6B94(a1, (uint64_t)a2, a3);
  }
  if (v4 != 8) {
    sub_1003A6C08();
  }
  LODWORD(sub_1002AF83C(v11, v10) = 0;
  unint64_t v8 = bswap32(*(_DWORD *)(v3 + 4)) | (unint64_t)&_mh_execute_header;
LABEL_13:
  HIDWORD(sub_1002AF83C(v11, v10) = v8;
  return v10;
}

unint64_t sub_1002BA044(uint64_t a1, unsigned __int8 **a2, uint64_t a3)
{
  unint64_t result = 4294963290LL;
  unint64_t v4 = *a2;
  unint64_t v5 = a2[1] - *a2;
  if (v5 < 4) {
    return 4294963296LL;
  }
  if (v5 >> 16) {
    return 4294963295LL;
  }
  uint64_t v6 = v4[3];
  uint64_t v7 = v4[2];
  if (v5 != (v6 | (v7 << 8)) + 4) {
    return 4294963294LL;
  }
  if ((v6 | ((_DWORD)v7 << 8)) == 1)
  {
    if (v5 <= 4) {
      sub_1003A6B4C(4294963290LL, (uint64_t)a2, a3);
    }
    if (v5 != 5) {
      sub_1003A6C30();
    }
    return ((unint64_t)v4[4] << 32) | 0x10000000000LL;
  }

  return result;
}

uint64_t sub_1002BA0D0(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = *a2;
  unint64_t v4 = a2[1] - *a2;
  if (v4 < 4)
  {
    int v5 = -4000;
LABEL_12:
    LODWORD(v_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
    LODWORD(sub_1002AF83C(v11, v10) = v5;
    goto LABEL_13;
  }

  if (v4 >> 16)
  {
    int v5 = -4001;
    goto LABEL_12;
  }

  uint64_t v6 = *(unsigned __int8 *)(v3 + 3);
  uint64_t v7 = *(unsigned __int8 *)(v3 + 2);
  if (v4 != (v6 | (v7 << 8)) + 4)
  {
    int v5 = -4002;
    goto LABEL_12;
  }

  if ((v6 | ((_DWORD)v7 << 8)) != 4)
  {
    int v5 = -4006;
    goto LABEL_12;
  }

  if (v4 <= 7) {
    sub_1003A6B94(a1, (uint64_t)a2, a3);
  }
  if (v4 != 8) {
    sub_1003A6C58();
  }
  LODWORD(sub_1002AF83C(v11, v10) = 0;
  unint64_t v8 = bswap32(*(_DWORD *)(v3 + 4)) | (unint64_t)&_mh_execute_header;
LABEL_13:
  HIDWORD(sub_1002AF83C(v11, v10) = v8;
  return v10;
}

uint64_t sub_1002BA184(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = *a2;
  unint64_t v4 = a2[1] - *a2;
  if (v4 < 4)
  {
    int v5 = -4000;
LABEL_12:
    LODWORD(v9) = v5;
    BYTE4(v9) = 0;
    return v9;
  }

  if (v4 >> 16)
  {
    int v5 = -4001;
    goto LABEL_12;
  }

  uint64_t v6 = *(unsigned __int8 *)(v3 + 3);
  uint64_t v7 = *(unsigned __int8 *)(v3 + 2);
  if (v4 != (v6 | (v7 << 8)) + 4)
  {
    int v5 = -4002;
    goto LABEL_12;
  }

  if ((v6 | ((_DWORD)v7 << 8)) != 5)
  {
    int v5 = -4006;
    goto LABEL_12;
  }

  if (v4 <= 7) {
    sub_1003A6B94(a1, (uint64_t)a2, a3);
  }
  if (v4 != 9)
  {
    if (v4 == 8) {
      sub_1003A6B4C(a1, (uint64_t)a2, a3);
    }
    sub_1003A6C80();
  }

  LODWORD(v9) = 0;
  HIDWORD(v9) = bswap32(*(_DWORD *)(v3 + 4));
  return v9;
}

void sub_1002BA24C(char *a1@<X1>, _DWORD *a2@<X8>)
{
  LOBYTE(v49) = 0;
  sub_10016C2CC(&__p, 4uLL, &v49);
  unint64_t v5 = (unint64_t)__p;
  unint64_t v4 = v54;
  uint64_t v6 = v54 - (_BYTE *)__p;
  char v7 = *a1;
  if ((unint64_t)v54 >= v55)
  {
    unint64_t v9 = v55 - (void)__p;
    else {
      uint64_t v10 = 2 * v9;
    }
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v11 = v10;
    }
    if (v11) {
      char v12 = operator new(v11);
    }
    else {
      char v12 = 0LL;
    }
    unsigned int v13 = (char *)v12 + v11;
    *((_BYTE *)v12 + v6) = v7;
    unint64_t v8 = (char *)v12 + v6 + 1;
    if (v4 == (_BYTE *)v5)
    {
      char v12 = (char *)v12 + v6;
    }

    else
    {
      char v14 = &v4[~v5];
      do
      {
        char v15 = *--v4;
        (v14--)[(void)v12] = v15;
      }

      while (v4 != (_BYTE *)v5);
      unint64_t v4 = __p;
    }

    std::string __p = v12;
    uint64_t v54 = v8;
    unint64_t v55 = (unint64_t)v13;
    if (v4) {
      operator delete(v4);
    }
  }

  else
  {
    _BYTE *v54 = v7;
    unint64_t v8 = v4 + 1;
  }

  uint64_t v54 = v8;
  int v16 = *a1;
  if (v16 == 1)
  {
    if (!a1[2])
    {
      uint64_t v46 = "evt.commandCompleteSubEventCode.has_value()";
      int v47 = 984;
      goto LABEL_90;
    }

    unint64_t v29 = (unint64_t)__p;
    uint64_t v30 = v8 - (_BYTE *)__p;
    unsigned __int8 v19 = a1[1];
    unint64_t v32 = v55 - (void)__p;
    else {
      uint64_t v33 = 2 * v32;
    }
    if (v32 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v34 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v34 = v33;
    }
    if (v34) {
      unsigned __int16 v23 = operator new(v34);
    }
    else {
      unsigned __int16 v23 = 0LL;
    }
    uint64_t v35 = (char *)v23 + v30;
    __int128 v36 = (char *)v23 + v34;
    *((_BYTE *)v23 + v30) = v19;
    unint64_t v31 = (char *)v23 + v30 + 1;
    if (v8 == (_BYTE *)v29) {
      goto LABEL_73;
    }
    unint64_t v39 = &v8[~v29];
    do
    {
      char v40 = *--v8;
      (v39--)[(void)v23] = v40;
    }

    while (v8 != (_BYTE *)v29);
    goto LABEL_71;
  }

  if (v16 == 2)
  {
    if (!a1[4])
    {
      uint64_t v46 = "evt.rangingSessionStatusChangedSubEventCode.has_value()";
      int v47 = 989;
LABEL_90:
      unsigned __int16 v48 = "encodeEventNotification";
LABEL_91:
      __assert_rtn(v48, "AlishaDCKCoder.cpp", v47, v46);
    }

    unint64_t v24 = (unint64_t)__p;
    uint64_t v25 = v8 - (_BYTE *)__p;
    unsigned __int8 v19 = a1[3];
    unint64_t v26 = v55 - (void)__p;
    else {
      uint64_t v27 = 2 * v26;
    }
    if (v26 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v28 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v28 = v27;
    }
    if (v28) {
      unsigned __int16 v23 = operator new(v28);
    }
    else {
      unsigned __int16 v23 = 0LL;
    }
    uint64_t v35 = (char *)v23 + v25;
    __int128 v36 = (char *)v23 + v28;
    *((_BYTE *)v23 + v25) = v19;
    unint64_t v31 = (char *)v23 + v25 + 1;
    if (v8 == (_BYTE *)v24) {
      goto LABEL_73;
    }
    uint64_t v37 = &v8[~v24];
    do
    {
      char v38 = *--v8;
      (v37--)[(void)v23] = v38;
    }

    while (v8 != (_BYTE *)v24);
LABEL_71:
    unint64_t v8 = __p;
    std::string __p = v23;
    uint64_t v54 = v31;
    unint64_t v55 = (unint64_t)v36;
    if (!v8) {
      goto LABEL_75;
    }
    goto LABEL_74;
  }

  if (v16 != 3) {
    goto LABEL_76;
  }
  if (!a1[6])
  {
    uint64_t v46 = "evt.deviceRangingIntentSubEventCode.has_value()";
    int v47 = 994;
    goto LABEL_90;
  }

  unint64_t v17 = (unint64_t)__p;
  uint64_t v18 = v8 - (_BYTE *)__p;
  if ((unint64_t)(v8 - (_BYTE *)__p - 0xFFFF) < 0xFFFFFFFFFFFF0000LL)
  {
LABEL_85:
    uint64_t v46 = "msg.size() + sizeof(data) <= kMaxMessageSize";
    int v47 = 225;
    unsigned __int16 v48 = "append";
    goto LABEL_91;
  }

  unsigned __int8 v19 = a1[5];
  if ((unint64_t)v8 >= v55)
  {
    unint64_t v20 = v55 - (void)__p;
    else {
      uint64_t v21 = 2 * v20;
    }
    if (v20 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v22 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v22 = v21;
    }
    if (v22) {
      unsigned __int16 v23 = operator new(v22);
    }
    else {
      unsigned __int16 v23 = 0LL;
    }
    uint64_t v35 = (char *)v23 + v18;
    __int128 v36 = (char *)v23 + v22;
    *((_BYTE *)v23 + v1_Block_object_dispose((const void *)(v1 - 112), 8) = v19;
    unint64_t v31 = (char *)v23 + v18 + 1;
    if (v8 != (_BYTE *)v17)
    {
      uint64_t v41 = &v8[~v17];
      do
      {
        char v42 = *--v8;
        (v41--)[(void)v23] = v42;
      }

      while (v8 != (_BYTE *)v17);
      goto LABEL_71;
    }

void sub_1002BA6C0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13, void *a14, uint64_t a15)
{
  if (a13 && __p) {
    operator delete(__p);
  }
  if (a14) {
    operator delete(a14);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002BA700(uint64_t a1@<X1>, _DWORD *a2@<X8>)
{
  LOBYTE(v45) = 0;
  sub_10016C2CC(&__p, 4uLL, &v45);
  sub_1002B8930(*(void *)a1, (unint64_t *)&__p);
  sub_1002B8930(*(void *)(a1 + 8), (unint64_t *)&__p);
  unint64_t v5 = (unint64_t)__p;
  unint64_t v4 = v50;
  uint64_t v6 = v50 - (_BYTE *)__p;
  char v7 = *(_BYTE *)(a1 + 16);
  if ((unint64_t)v50 >= v51)
  {
    unint64_t v9 = v51 - (void)__p;
    else {
      uint64_t v10 = 2 * v9;
    }
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v11 = v10;
    }
    if (v11) {
      char v12 = operator new(v11);
    }
    else {
      char v12 = 0LL;
    }
    unsigned int v13 = (char *)v12 + v11;
    *((_BYTE *)v12 + v6) = v7;
    unint64_t v8 = (char *)v12 + v6 + 1;
    if (v4 == (_BYTE *)v5)
    {
      char v12 = (char *)v12 + v6;
    }

    else
    {
      char v14 = &v4[~v5];
      do
      {
        char v15 = *--v4;
        (v14--)[(void)v12] = v15;
      }

      while (v4 != (_BYTE *)v5);
      unint64_t v4 = __p;
    }

    std::string __p = v12;
    uint64_t v50 = v8;
    unint64_t v51 = (unint64_t)v13;
    if (v4) {
      operator delete(v4);
    }
  }

  else
  {
    _BYTE *v50 = v7;
    unint64_t v8 = v4 + 1;
  }

  uint64_t v50 = v8;
  unint64_t v16 = (unint64_t)__p;
  uint64_t v17 = v8 - (_BYTE *)__p;
  char v18 = *(_BYTE *)(a1 + 17);
  if ((unint64_t)v8 < v51)
  {
    _BYTE *v8 = v18;
    unsigned __int8 v19 = v8 + 1;
    goto LABEL_39;
  }

  unint64_t v20 = v51 - (void)__p;
  else {
    uint64_t v21 = 2 * v20;
  }
  if (v20 >= 0x3FFFFFFFFFFFFFFFLL) {
    size_t v22 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    size_t v22 = v21;
  }
  if (v22) {
    unsigned __int16 v23 = operator new(v22);
  }
  else {
    unsigned __int16 v23 = 0LL;
  }
  unint64_t v24 = (char *)v23 + v22;
  *((_BYTE *)v23 + v17) = v18;
  unsigned __int8 v19 = (char *)v23 + v17 + 1;
  if (v8 == (_BYTE *)v16)
  {
    std::string __p = (char *)v23 + v17;
    uint64_t v50 = (char *)v23 + v17 + 1;
    unint64_t v51 = (unint64_t)v24;
LABEL_38:
    operator delete(v8);
    goto LABEL_39;
  }

  uint64_t v25 = &v8[~v16];
  do
  {
    char v26 = *--v8;
    (v25--)[(void)v23] = v26;
  }

  while (v8 != (_BYTE *)v16);
  unint64_t v8 = __p;
  std::string __p = v23;
  uint64_t v50 = (char *)v23 + v17 + 1;
  unint64_t v51 = (unint64_t)v24;
  if (v8) {
    goto LABEL_38;
  }
LABEL_39:
  uint64_t v50 = v19;
  sub_1002B7AB4(*(_WORD *)(a1 + 18), (unint64_t *)&__p);
  unint64_t v28 = (unint64_t)__p;
  uint64_t v27 = v50;
  uint64_t v29 = v50 - (_BYTE *)__p;
  if ((unint64_t)(v50 - (_BYTE *)__p - 0xFFFF) < 0xFFFFFFFFFFFF0000LL)
  {
LABEL_67:
    char v42 = "msg.size() + sizeof(data) <= kMaxMessageSize";
    int v43 = 225;
    unint64_t v44 = "append";
    goto LABEL_69;
  }

  char v30 = *(_BYTE *)(a1 + 20);
  if ((unint64_t)v50 >= v51)
  {
    unint64_t v32 = v51 - (void)__p;
    else {
      uint64_t v33 = 2 * v32;
    }
    if (v32 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v34 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v34 = v33;
    }
    if (v34) {
      uint64_t v35 = operator new(v34);
    }
    else {
      uint64_t v35 = 0LL;
    }
    __int128 v36 = (char *)v35 + v34;
    *((_BYTE *)v35 + v29) = v30;
    unint64_t v31 = (char *)v35 + v29 + 1;
    if (v27 == (_BYTE *)v28)
    {
      uint64_t v35 = (char *)v35 + v29;
    }

    else
    {
      uint64_t v37 = &v27[~v28];
      do
      {
        char v38 = *--v27;
        (v37--)[(void)v35] = v38;
      }

      while (v27 != (_BYTE *)v28);
      uint64_t v27 = __p;
    }

    std::string __p = v35;
    uint64_t v50 = v31;
    unint64_t v51 = (unint64_t)v36;
    if (v27) {
      operator delete(v27);
    }
  }

  else
  {
    _BYTE *v50 = v30;
    unint64_t v31 = v27 + 1;
  }

  uint64_t v50 = v31;
  sub_1002B7AB4(*(_WORD *)(a1 + 22), (unint64_t *)&__p);
  unint64_t v39 = __p;
  unint64_t v40 = v50 - (_BYTE *)__p;
  if ((unint64_t)(v50 - (_BYTE *)__p) >= 0x10000)
  {
    char v42 = "msg.size() <= kMaxMessageSize";
    int v43 = 166;
    unint64_t v44 = "populateHeader";
LABEL_69:
    __assert_rtn(v44, "AlishaDCKCoder.cpp", v43, v42);
  }

  if (v40 <= 3)
  {
    sub_1000353EC((unint64_t *)&__p, 4 - v40);
    unint64_t v39 = __p;
    LOWORD(v40) = (_WORD)v50 - (_WORD)__p;
  }

  __int16 v41 = v40 - 4;
  _BYTE *v39 = 5;
  *((_BYTE *)__p + 1) = 13;
  *((_BYTE *)__p + 2) = HIBYTE(v41);
  *((_BYTE *)__p + 3) = v41;
  __int16 v45 = 0LL;
  uint64_t v46 = 0LL;
  uint64_t v47 = 0LL;
  sub_1001309C0(&v45, __p, (uint64_t)v50, v50 - (_BYTE *)__p);
  char v48 = 1;
  *a2 = 0;
  sub_1002BADE0((uint64_t)(a2 + 2), (uint64_t)&v45);
  if (v48 && v45)
  {
    uint64_t v46 = v45;
    operator delete(v45);
  }

  if (__p)
  {
    uint64_t v50 = __p;
    operator delete(__p);
  }

void sub_1002BAAC8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13, void *a14, uint64_t a15)
{
  if (a13 && __p) {
    operator delete(__p);
  }
  if (a14) {
    operator delete(a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002BAB08(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 72))
  {
    unint64_t v2 = *(void **)(a1 + 48);
    if (v2)
    {
      *(void *)(a1 + 56) = v2;
      operator delete(v2);
    }

    uint64_t v3 = *(void **)(a1 + 24);
    if (v3)
    {
      *(void *)(a1 + 32) = v3;
      operator delete(v3);
    }

    unint64_t v4 = *(void **)a1;
    if (*(void *)a1)
    {
      *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v4;
      operator delete(v4);
    }
  }

  return a1;
}

void *sub_1002BAB60(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  sub_1001896FC(a1, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 1);
  a1[3] = 0LL;
  a1[4] = 0LL;
  a1[5] = 0LL;
  sub_1001896FC(a1 + 3, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 1);
  a1[6] = 0LL;
  a1[7] = 0LL;
  a1[8] = 0LL;
  sub_1001309C0(a1 + 6, *(const void **)a4, *(void *)(a4 + 8), *(void *)(a4 + 8) - *(void *)a4);
  return a1;
}

void sub_1002BABE4(_Unwind_Exception *exception_object)
{
  unint64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 32) = v4;
    operator delete(v4);
  }

  unint64_t v5 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v5;
    operator delete(v5);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1002BAC18(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_1002BAC4C(a1);
  }
  return a1;
}

void sub_1002BAC4C(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 16);
  uint64_t v2 = **(void **)(a1 + 8);
  if (v1 != v2)
  {
    uint64_t v3 = **(void **)(a1 + 16);
    do
    {
      unint64_t v5 = *(void **)(v3 - 24);
      v3 -= 24LL;
      unint64_t v4 = v5;
      if (v5)
      {
        *(void *)(v1 - 16) = v4;
        operator delete(v4);
      }

      uint64_t v1 = v3;
    }

    while (v3 != v2);
  }

uint64_t sub_1002BAC98(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1002BAD0C((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1002BAD0C(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&__int128 v14 = a6;
  *((void *)&v14 + 1) = a7;
  __int128 v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }

  else
  {
    do
    {
      *(void *)(v7 - 24) = 0LL;
      *(void *)(v7 - 16) = 0LL;
      *(void *)(v7 - _Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
      __int128 v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(void *)(v7 - _Block_object_dispose((const void *)(v1 - 112), 8) = a3[2];
      *a3 = 0LL;
      a3[1] = 0LL;
      a3[2] = 0LL;
      uint64_t v7 = *((void *)&v14 + 1) - 24LL;
      *((void *)&v14 + 1) -= 24LL;
    }

    while (a3 != a5);
    uint64_t v9 = v14;
  }

  char v12 = 1;
  sub_1002BADAC((uint64_t)v11);
  return v9;
}

uint64_t sub_1002BADAC(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_100129BEC(a1);
  }
  return a1;
}

uint64_t sub_1002BADE0(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1 = 0;
  *(_BYTE *)(a1 + 24) = 0;
  sub_1002BAE28((void *)a1, a2);
  return a1;
}

void sub_1002BAE0C(_Unwind_Exception *exception_object)
{
  if (*(_BYTE *)(v1 + 24)) {
    sub_1003A6CA8(v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1002BAE28(void *result, uint64_t a2)
{
  if (*(_BYTE *)(a2 + 24))
  {
    uint64_t v2 = result;
    *uint64_t result = 0LL;
    result[1] = 0LL;
    result[2] = 0LL;
    uint64_t result = sub_1001309C0(result, *(const void **)a2, *(void *)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
    *((_BYTE *)v2 + 24) = 1;
  }

  return result;
}

uint64_t sub_1002BAE6C(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1 = 0;
  *(_BYTE *)(a1 + 72) = 0;
  if (*(_BYTE *)(a2 + 72))
  {
    sub_1002BAEC0((void *)a1, a2);
    *(_BYTE *)(a1 + 72) = 1;
  }

  return a1;
}

void sub_1002BAEAC(_Unwind_Exception *a1)
{
}

void *sub_1002BAEC0(void *a1, uint64_t a2)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  sub_1001896FC(a1, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 1);
  a1[3] = 0LL;
  a1[4] = 0LL;
  a1[5] = 0LL;
  sub_1001896FC( a1 + 3,  *(const void **)(a2 + 24),  *(void *)(a2 + 32),  (uint64_t)(*(void *)(a2 + 32) - *(void *)(a2 + 24)) >> 1);
  a1[6] = 0LL;
  a1[7] = 0LL;
  a1[8] = 0LL;
  sub_1001309C0(a1 + 6, *(const void **)(a2 + 48), *(void *)(a2 + 56), *(void *)(a2 + 56) - *(void *)(a2 + 48));
  return a1;
}

void sub_1002BAF40(_Unwind_Exception *exception_object)
{
  unint64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 32) = v4;
    operator delete(v4);
  }

  uint64_t v5 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v5;
    operator delete(v5);
  }

  _Unwind_Resume(exception_object);
}

void sub_1002BAF74(char **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 1)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 2 * a2);
      v7 += 2 * a2;
    }

    a1[1] = v7;
  }

  else
  {
    __int128 v8 = *a1;
    uint64_t v9 = v7 - *a1;
    uint64_t v10 = a2 + (v9 >> 1);
    if (v10 < 0) {
      sub_10001E11C();
    }
    uint64_t v11 = v9 >> 1;
    unint64_t v12 = v5 - v8;
    if (v12 > v10) {
      uint64_t v10 = v12;
    }
    if (v12 >= 0x7FFFFFFFFFFFFFFELL) {
      uint64_t v13 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v13 = v10;
    }
    if (v13)
    {
      __int128 v14 = (char *)sub_100137E38(v4, v13);
      __int128 v8 = *a1;
      uint64_t v7 = a1[1];
    }

    else
    {
      __int128 v14 = 0LL;
    }

    char v15 = &v14[2 * v11];
    unint64_t v16 = &v14[2 * v13];
    bzero(v15, 2 * a2);
    uint64_t v17 = &v15[2 * a2];
    while (v7 != v8)
    {
      __int16 v18 = *((_WORD *)v7 - 1);
      v7 -= 2;
      *((_WORD *)v15 - 1) = v18;
      v15 -= 2;
    }

    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8) {
      operator delete(v8);
    }
  }

void sub_1002BB074(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
}

void sub_1002BB07C(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
}

void sub_1002BB084(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
}

uint64_t sub_1002BB08C@<X0>(unsigned __int8 *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  uint64_t v4 = sub_100046B94(&v80, (uint64_t)"{", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v4 + *(void *)(*v4 - 24LL)));
  uint64_t v5 = std::locale::use_facet(&v83, &std::ctype<char>::id);
  uint64_t v6 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v5->__vftable[2].~facet_0)(v5, 10LL);
  std::locale::~locale(&v83);
  std::ostream::put(v4, v6);
  std::ostream::flush(v4);
  LOBYTE(v83.__locale_) = 9;
  uint64_t v7 = sub_100046B94(&v80, (uint64_t)&v83, 1LL);
  __int128 v8 = sub_100046B94(v7, (uint64_t)"Channel: ", 9LL);
  uint64_t v9 = (void *)std::ostream::operator<<(v8, *a1);
  std::ios_base::getloc((const std::ios_base *)((char *)v9 + *(void *)(*v9 - 24LL)));
  uint64_t v10 = std::locale::use_facet(&v83, &std::ctype<char>::id);
  uint64_t v11 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 10LL);
  std::locale::~locale(&v83);
  std::ostream::put(v9, v11);
  std::ostream::flush(v9);
  LOBYTE(v83.__locale_) = 9;
  unint64_t v12 = sub_100046B94(&v80, (uint64_t)&v83, 1LL);
  uint64_t v13 = sub_100046B94(v12, (uint64_t)"Preamble: ", 10LL);
  __int128 v14 = (void *)std::ostream::operator<<(v13, a1[1]);
  std::ios_base::getloc((const std::ios_base *)((char *)v14 + *(void *)(*v14 - 24LL)));
  char v15 = std::locale::use_facet(&v83, &std::ctype<char>::id);
  uint64_t v16 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v15->__vftable[2].~facet_0)(v15, 10LL);
  std::locale::~locale(&v83);
  std::ostream::put(v14, v16);
  std::ostream::flush(v14);
  LOBYTE(v83.__locale_) = 9;
  uint64_t v17 = sub_100046B94(&v80, (uint64_t)&v83, 1LL);
  __int16 v18 = sub_100046B94(v17, (uint64_t)"Selected protocol version: ", 27LL);
  unsigned __int8 v19 = (void *)std::ostream::operator<<(v18, *((unsigned __int16 *)a1 + 1));
  std::ios_base::getloc((const std::ios_base *)((char *)v19 + *(void *)(*v19 - 24LL)));
  unint64_t v20 = std::locale::use_facet(&v83, &std::ctype<char>::id);
  uint64_t v21 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v20->__vftable[2].~facet_0)(v20, 10LL);
  std::locale::~locale(&v83);
  std::ostream::put(v19, v21);
  std::ostream::flush(v19);
  LOBYTE(v83.__locale_) = 9;
  size_t v22 = sub_100046B94(&v80, (uint64_t)&v83, 1LL);
  unsigned __int16 v23 = sub_100046B94(v22, (uint64_t)"Selected UWB config id: ", 24LL);
  unint64_t v24 = (void *)std::ostream::operator<<(v23, *((unsigned __int16 *)a1 + 2));
  std::ios_base::getloc((const std::ios_base *)((char *)v24 + *(void *)(*v24 - 24LL)));
  uint64_t v25 = std::locale::use_facet(&v83, &std::ctype<char>::id);
  uint64_t v26 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v25->__vftable[2].~facet_0)(v25, 10LL);
  std::locale::~locale(&v83);
  std::ostream::put(v24, v26);
  std::ostream::flush(v24);
  LOBYTE(v83.__locale_) = 9;
  uint64_t v27 = sub_100046B94(&v80, (uint64_t)&v83, 1LL);
  unint64_t v28 = sub_100046B94(v27, (uint64_t)"RAN multiplier: ", 16LL);
  uint64_t v29 = (void *)std::ostream::operator<<(v28, a1[6]);
  std::ios_base::getloc((const std::ios_base *)((char *)v29 + *(void *)(*v29 - 24LL)));
  char v30 = std::locale::use_facet(&v83, &std::ctype<char>::id);
  uint64_t v31 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v30->__vftable[2].~facet_0)(v30, 10LL);
  std::locale::~locale(&v83);
  std::ostream::put(v29, v31);
  std::ostream::flush(v29);
  LOBYTE(v83.__locale_) = 9;
  unint64_t v32 = sub_100046B94(&v80, (uint64_t)&v83, 1LL);
  uint64_t v33 = sub_100046B94(v32, (uint64_t)"Num. chaps per slot: ", 21LL);
  size_t v34 = (void *)std::ostream::operator<<(v33, a1[7]);
  std::ios_base::getloc((const std::ios_base *)((char *)v34 + *(void *)(*v34 - 24LL)));
  uint64_t v35 = std::locale::use_facet(&v83, &std::ctype<char>::id);
  uint64_t v36 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v35->__vftable[2].~facet_0)(v35, 10LL);
  std::locale::~locale(&v83);
  std::ostream::put(v34, v36);
  std::ostream::flush(v34);
  LOBYTE(v83.__locale_) = 9;
  uint64_t v37 = sub_100046B94(&v80, (uint64_t)&v83, 1LL);
  char v38 = sub_100046B94(v37, (uint64_t)"Num. slots per round: ", 22LL);
  unint64_t v39 = (void *)std::ostream::operator<<(v38, a1[8]);
  std::ios_base::getloc((const std::ios_base *)((char *)v39 + *(void *)(*v39 - 24LL)));
  unint64_t v40 = std::locale::use_facet(&v83, &std::ctype<char>::id);
  uint64_t v41 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v40->__vftable[2].~facet_0)(v40, 10LL);
  std::locale::~locale(&v83);
  std::ostream::put(v39, v41);
  std::ostream::flush(v39);
  LOBYTE(v83.__locale_) = 9;
  char v42 = sub_100046B94(&v80, (uint64_t)&v83, 1LL);
  int v43 = sub_100046B94(v42, (uint64_t)"Num. responders: ", 17LL);
  unint64_t v44 = (void *)std::ostream::operator<<(v43, a1[9]);
  std::ios_base::getloc((const std::ios_base *)((char *)v44 + *(void *)(*v44 - 24LL)));
  __int16 v45 = std::locale::use_facet(&v83, &std::ctype<char>::id);
  uint64_t v46 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v45->__vftable[2].~facet_0)(v45, 10LL);
  std::locale::~locale(&v83);
  std::ostream::put(v44, v46);
  std::ostream::flush(v44);
  LOBYTE(v83.__locale_) = 9;
  uint64_t v47 = sub_100046B94(&v80, (uint64_t)&v83, 1LL);
  char v48 = sub_100046B94(v47, (uint64_t)"Selected hop config bitmask: ", 29LL);
  __int128 v49 = (void *)std::ostream::operator<<(v48, a1[10]);
  std::ios_base::getloc((const std::ios_base *)((char *)v49 + *(void *)(*v49 - 24LL)));
  uint64_t v50 = std::locale::use_facet(&v83, &std::ctype<char>::id);
  uint64_t v51 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v50->__vftable[2].~facet_0)(v50, 10LL);
  std::locale::~locale(&v83);
  std::ostream::put(v49, v51);
  std::ostream::flush(v49);
  LOBYTE(v83.__locale_) = 9;
  char v52 = sub_100046B94(&v80, (uint64_t)&v83, 1LL);
  __int128 v53 = sub_100046B94(v52, (uint64_t)"Selected pulse shape combo: ", 28LL);
  uint64_t v54 = (void *)std::ostream::operator<<(v53, a1[11]);
  std::ios_base::getloc((const std::ios_base *)((char *)v54 + *(void *)(*v54 - 24LL)));
  unint64_t v55 = std::locale::use_facet(&v83, &std::ctype<char>::id);
  uint64_t v56 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v55->__vftable[2].~facet_0)(v55, 10LL);
  std::locale::~locale(&v83);
  std::ostream::put(v54, v56);
  std::ostream::flush(v54);
  if (a1[15])
  {
    LOBYTE(v83.__locale_) = 9;
    id v57 = sub_100046B94(&v80, (uint64_t)&v83, 1LL);
    uint64_t v58 = sub_100046B94(v57, (uint64_t)"ACWG enable two ranging rounds per block: ", 42LL);
    if (!a1[15]) {
      goto LABEL_17;
    }
    char v59 = a1[12] ? "yes" : "no";
    uint64_t v60 = a1[12] ? 3LL : 2LL;
    uint64_t v61 = sub_100046B94(v58, (uint64_t)v59, v60);
    std::ios_base::getloc((const std::ios_base *)((char *)v61 + *(void *)(*v61 - 24LL)));
    unint64_t v62 = std::locale::use_facet(&v83, &std::ctype<char>::id);
    uint64_t v63 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v62->__vftable[2].~facet_0)(v62, 10LL);
    std::locale::~locale(&v83);
    std::ostream::put(v61, v63);
    std::ostream::flush(v61);
    if (!a1[15]) {
      goto LABEL_17;
    }
    if (a1[12])
    {
      LOBYTE(v83.__locale_) = 9;
      unint64_t v64 = sub_100046B94(&v80, (uint64_t)&v83, 1LL);
      unint64_t v65 = sub_100046B94(v64, (uint64_t)"ACWG offset between ranging rounds: ", 36LL);
      if (!a1[15]) {
        goto LABEL_17;
      }
      LOBYTE(v83.__locale_) = a1[13];
      size_t v66 = sub_100046B94(v65, (uint64_t)&v83, 1LL);
      std::ios_base::getloc((const std::ios_base *)((char *)v66 + *(void *)(*v66 - 24LL)));
      unint64_t v67 = std::locale::use_facet(&v83, &std::ctype<char>::id);
      uint64_t v68 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v67->__vftable[2].~facet_0)(v67, 10LL);
      std::locale::~locale(&v83);
      std::ostream::put(v66, v68);
      std::ostream::flush(v66);
      if (!a1[15]) {
LABEL_17:
      }
        sub_100006080();
    }

    snprintf(__str, 0x80uLL, "ACWG Final Data2 Bitmask: 0x%02x", a1[14]);
    LOBYTE(v83.__locale_) = 9;
    uint64_t v69 = sub_100046B94(&v80, (uint64_t)&v83, 1LL);
    size_t v70 = strlen(__str);
    unint64_t v71 = sub_100046B94(v69, (uint64_t)__str, v70);
    std::ios_base::getloc((const std::ios_base *)((char *)v71 + *(void *)(*v71 - 24LL)));
    uint64_t v72 = std::locale::use_facet(&v83, &std::ctype<char>::id);
    uint64_t v73 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v72->__vftable[2].~facet_0)(v72, 10LL);
    std::locale::~locale(&v83);
    std::ostream::put(v71, v73);
    std::ostream::flush(v71);
  }

  uint64_t v74 = sub_100046B94(&v80, (uint64_t)"}", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v74 + *(void *)(*v74 - 24LL)));
  unint64_t v75 = std::locale::use_facet(&v83, &std::ctype<char>::id);
  uint64_t v76 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v75->__vftable[2].~facet_0)(v75, 10LL);
  std::locale::~locale(&v83);
  std::ostream::put(v74, v76);
  std::ostream::flush(v74);
  std::stringbuf::str(a2, &v81);
  *(void *)((char *)v79
  uint64_t v80 = v77;
  std::streambuf::~streambuf(&v81);
  return std::ios::~ios(&v82);
}

void sub_1002BB9B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_1002BBA18@<X0>(unsigned __int8 *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  uint64_t v4 = sub_100046B94(&v26, (uint64_t)"{", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v4 + *(void *)(*v4 - 24LL)));
  uint64_t v5 = std::locale::use_facet((const std::locale *)&v24, &std::ctype<char>::id);
  uint64_t v6 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v5->__vftable[2].~facet_0)(v5, 10LL);
  std::locale::~locale((std::locale *)&v24);
  std::ostream::put(v4, v6);
  std::ostream::flush(v4);
  v24.__r_.__value_.__s.__data_[0] = 9;
  uint64_t v7 = sub_100046B94(&v26, (uint64_t)&v24, 1LL);
  __int128 v8 = sub_100046B94(v7, (uint64_t)"UWB session id: ", 16LL);
  uint64_t v9 = (void *)std::ostream::operator<<(v8, *(unsigned int *)a1);
  std::ios_base::getloc((const std::ios_base *)((char *)v9 + *(void *)(*v9 - 24LL)));
  uint64_t v10 = std::locale::use_facet((const std::locale *)&v24, &std::ctype<char>::id);
  uint64_t v11 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 10LL);
  std::locale::~locale((std::locale *)&v24);
  std::ostream::put(v9, v11);
  std::ostream::flush(v9);
  v24.__r_.__value_.__s.__data_[0] = 9;
  unint64_t v12 = sub_100046B94(&v26, (uint64_t)&v24, 1LL);
  uint64_t v13 = sub_100046B94(v12, (uint64_t)"Negotiated params: ", 19LL);
  sub_1002BB08C(a1 + 4, &v24);
  if ((v24.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    __int128 v14 = &v24;
  }
  else {
    __int128 v14 = (std::stringbuf::string_type *)v24.__r_.__value_.__r.__words[0];
  }
  if ((v24.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = v24.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = v24.__r_.__value_.__l.__size_;
  }
  uint64_t v16 = sub_100046B94(v13, (uint64_t)v14, size);
  std::ios_base::getloc((const std::ios_base *)((char *)v16 + *(void *)(*v16 - 24LL)));
  uint64_t v17 = std::locale::use_facet(&v29, &std::ctype<char>::id);
  uint64_t v18 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v17->__vftable[2].~facet_0)(v17, 10LL);
  std::locale::~locale(&v29);
  std::ostream::put(v16, v18);
  std::ostream::flush(v16);
  unsigned __int8 v19 = sub_100046B94(&v26, (uint64_t)"}", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v19 + *(void *)(*v19 - 24LL)));
  unint64_t v20 = std::locale::use_facet((const std::locale *)&v24, &std::ctype<char>::id);
  uint64_t v21 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v20->__vftable[2].~facet_0)(v20, 10LL);
  std::locale::~locale((std::locale *)&v24);
  std::ostream::put(v19, v21);
  std::ostream::flush(v19);
  std::stringbuf::str(a2, &v27);
  *(void *)((char *)v25
  uint64_t v26 = v22;
  std::streambuf::~streambuf(&v27);
  return std::ios::~ios(&v28);
}

void sub_1002BBCF4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
}

uint64_t sub_1002BBD4C@<X0>(uint64_t *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  uint64_t v4 = *a1;
  if (a1[1] != *a1)
  {
    unint64_t v5 = 0LL;
    do
    {
      int v6 = *(unsigned __int8 *)(v4 + v5);
      if (v6 == 1)
      {
        uint64_t v7 = "SchedulingConflict";
      }

      else if (v6 == 4)
      {
        uint64_t v7 = "SessionMuted";
      }

      else
      {
        uint64_t v7 = "CoexConflict";
      }

      sub_1000065CC(__p, v7);
      if ((v14 & 0x80u) == 0) {
        __int128 v8 = __p;
      }
      else {
        __int128 v8 = (void **)__p[0];
      }
      if ((v14 & 0x80u) == 0) {
        uint64_t v9 = v14;
      }
      else {
        uint64_t v9 = (uint64_t)__p[1];
      }
      sub_100046B94(&v16, (uint64_t)v8, v9);
      uint64_t v4 = *a1;
      uint64_t v10 = a1[1];
      if (~*a1 + v10 > v5)
      {
        sub_100046B94(&v16, (uint64_t)", ", 2LL);
        uint64_t v4 = *a1;
        uint64_t v10 = a1[1];
      }

      ++v5;
    }

    while (v10 - v4 > v5);
  }

  sub_100046B94(&v16, (uint64_t)"]", 1LL);
  std::stringbuf::str(a2, &v17);
  *(void *)((char *)v15
  uint64_t v16 = v11;
  std::streambuf::~streambuf(&v17);
  return std::ios::~ios(&v18);
}

void sub_1002BBF08( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
}

void sub_1002BBF3C(char a1@<W0>, unint64_t *a2@<X8>)
{
  unint64_t v4 = 0LL;
  unint64_t v5 = 0LL;
  *a2 = 0LL;
  a2[1] = 0LL;
  a2[2] = 0LL;
  if ((a1 & 1) != 0)
  {
    unint64_t v4 = (unint64_t)operator new(1uLL);
    *(_BYTE *)unint64_t v4 = 1;
    unint64_t v5 = (_BYTE *)(v4 + 1);
    a2[1] = v4 + 1;
    a2[2] = v4 + 1;
    *a2 = v4;
  }

  if ((a1 & 2) == 0)
  {
    int v6 = v5;
    if ((a1 & 4) == 0) {
      return;
    }
    goto LABEL_23;
  }

  unint64_t v7 = (unint64_t)&v5[-v4];
  uint64_t v8 = (uint64_t)&v5[-v4 + 1];
  if (v8 < 0) {
    sub_10001E11C();
  }
  if (2 * v7 > v8) {
    uint64_t v8 = 2 * v7;
  }
  if (v7 >= 0x3FFFFFFFFFFFFFFFLL) {
    size_t v9 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    size_t v9 = v8;
  }
  if (v9) {
    unint64_t v10 = (unint64_t)operator new(v9);
  }
  else {
    unint64_t v10 = 0LL;
  }
  uint64_t v11 = (char *)(v10 + v9);
  *(_BYTE *)(v10 + v7) = 2;
  int v6 = (_BYTE *)(v10 + v7 + 1);
  if (v5 == (_BYTE *)v4)
  {
    v10 += v7;
  }

  else
  {
    unint64_t v12 = &v5[~v4];
    do
    {
      char v13 = *--v5;
      (v12--)[v10] = v13;
    }

    while (v5 != (_BYTE *)v4);
  }

  *a2 = v10;
  a2[1] = (unint64_t)v6;
  a2[2] = (unint64_t)v11;
  if (v4) {
    operator delete((void *)v4);
  }
  a2[1] = (unint64_t)v6;
  if ((a1 & 4) != 0)
  {
LABEL_23:
    unint64_t v14 = a2[2];
    if ((unint64_t)v6 >= v14)
    {
      unint64_t v16 = *a2;
      std::stringbuf v17 = &v6[-*a2];
      unint64_t v18 = (unint64_t)(v17 + 1);
      unint64_t v19 = v14 - v16;
      if (2 * v19 > v18) {
        unint64_t v18 = 2 * v19;
      }
      if (v19 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v20 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v20 = v18;
      }
      if (v20) {
        unint64_t v21 = (unint64_t)operator new(v20);
      }
      else {
        unint64_t v21 = 0LL;
      }
      uint64_t v22 = (char *)(v21 + v20);
      v17[v21] = 4;
      uint64_t v15 = (uint64_t)&v17[v21 + 1];
      if (v6 == (_BYTE *)v16)
      {
        v21 += (unint64_t)v17;
      }

      else
      {
        unsigned __int16 v23 = &v6[~v16];
        do
        {
          char v24 = *--v6;
          (v23--)[v21] = v24;
        }

        while (v6 != (_BYTE *)v16);
      }

      *a2 = v21;
      a2[1] = v15;
      a2[2] = (unint64_t)v22;
      if (v16) {
        operator delete((void *)v16);
      }
    }

    else
    {
      _BYTE *v6 = 4;
      uint64_t v15 = (uint64_t)(v6 + 1);
    }

    a2[1] = v15;
  }

void sub_1002BC118(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1002BC13C@<X0>(uint64_t *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  LOBYTE(v48.__locale_) = 48;
  unint64_t v4 = sub_100138E6C(&v45, (char *)&v48);
  *(_DWORD *)((char *)v4 + *(void *)(*v4 - 24LL) + _Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)((_BYTE *)v4 + *(void *)(*v4 - 24LL) + 8) & 0xFFFFFFB5 | 8;
  unint64_t v5 = sub_100046B94(&v45, (uint64_t)"{", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v5 + *(void *)(*v5 - 24LL)));
  int v6 = std::locale::use_facet(&v48, &std::ctype<char>::id);
  uint64_t v7 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v6->__vftable[2].~facet_0)(v6, 10LL);
  std::locale::~locale(&v48);
  std::ostream::put(v5, v7);
  std::ostream::flush(v5);
  LOBYTE(v48.__locale_) = 9;
  uint64_t v8 = sub_100046B94(&v45, (uint64_t)&v48, 1LL);
  sub_100046B94(v8, (uint64_t)"UWB config ids: [", 17LL);
  uint64_t v9 = *a1;
  if (a1[1] != *a1)
  {
    unint64_t v10 = 0LL;
    do
    {
      *(std::streambuf::char_type **)((char *)&v46.__binp_ + *(void *)(v45 - sub_100034A98(v2, *(void **)(v1 + 24)) = (std::streambuf::char_type *)4;
      std::ostream::operator<<(&v45, *(unsigned __int16 *)(v9 + 2 * v10));
      uint64_t v9 = *a1;
      unint64_t v11 = (a1[1] - *a1) >> 1;
      if (v11 - 1 > v10)
      {
        sub_100046B94(&v45, (uint64_t)", ", 2LL);
        uint64_t v9 = *a1;
        unint64_t v11 = (a1[1] - *a1) >> 1;
      }

      ++v10;
    }

    while (v11 > v10);
  }

  unint64_t v12 = sub_100046B94(&v45, (uint64_t)"], ", 3LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v12 + *(void *)(*v12 - 24LL)));
  char v13 = std::locale::use_facet(&v48, &std::ctype<char>::id);
  uint64_t v14 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v13->__vftable[2].~facet_0)(v13, 10LL);
  std::locale::~locale(&v48);
  std::ostream::put(v12, v14);
  std::ostream::flush(v12);
  LOBYTE(v48.__locale_) = 9;
  uint64_t v15 = sub_100046B94(&v45, (uint64_t)&v48, 1LL);
  unint64_t v16 = sub_100046B94(v15, (uint64_t)"Slot bitmask: ", 14LL);
  *(void *)((char *)v16 + *(void *)(*v16 - 24LL) + 24) = 2LL;
  std::stringbuf v17 = (void *)std::ostream::operator<<(v16, *((unsigned __int8 *)a1 + 24));
  std::ios_base::getloc((const std::ios_base *)((char *)v17 + *(void *)(*v17 - 24LL)));
  unint64_t v18 = std::locale::use_facet(&v48, &std::ctype<char>::id);
  uint64_t v19 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v18->__vftable[2].~facet_0)(v18, 10LL);
  std::locale::~locale(&v48);
  std::ostream::put(v17, v19);
  std::ostream::flush(v17);
  LOBYTE(v48.__locale_) = 9;
  size_t v20 = sub_100046B94(&v45, (uint64_t)&v48, 1LL);
  unint64_t v21 = sub_100046B94(v20, (uint64_t)"Sync code index bitmask: ", 25LL);
  *(void *)((char *)v21 + *(void *)(*v21 - 24LL) + 24) = 8LL;
  uint64_t v22 = (void *)std::ostream::operator<<(v21, *((unsigned int *)a1 + 7));
  std::ios_base::getloc((const std::ios_base *)((char *)v22 + *(void *)(*v22 - 24LL)));
  unsigned __int16 v23 = std::locale::use_facet(&v48, &std::ctype<char>::id);
  uint64_t v24 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v23->__vftable[2].~facet_0)(v23, 10LL);
  std::locale::~locale(&v48);
  std::ostream::put(v22, v24);
  std::ostream::flush(v22);
  LOBYTE(v48.__locale_) = 9;
  uint64_t v25 = sub_100046B94(&v45, (uint64_t)&v48, 1LL);
  uint64_t v26 = sub_100046B94(v25, (uint64_t)"RF channel bitmask: ", 20LL);
  *(void *)((char *)v26 + *(void *)(*v26 - 24LL) + 24) = 2LL;
  std::stringbuf v27 = (void *)std::ostream::operator<<(v26, *((unsigned __int8 *)a1 + 32));
  std::ios_base::getloc((const std::ios_base *)((char *)v27 + *(void *)(*v27 - 24LL)));
  uint64_t v28 = std::locale::use_facet(&v48, &std::ctype<char>::id);
  uint64_t v29 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v28->__vftable[2].~facet_0)(v28, 10LL);
  std::locale::~locale(&v48);
  std::ostream::put(v27, v29);
  std::ostream::flush(v27);
  LOBYTE(v48.__locale_) = 9;
  char v30 = sub_100046B94(&v45, (uint64_t)&v48, 1LL);
  uint64_t v31 = sub_100046B94(v30, (uint64_t)"Hop config bitmask: ", 20LL);
  *(void *)((char *)v31 + *(void *)(*v31 - 24LL) + 24) = 2LL;
  unint64_t v32 = (void *)std::ostream::operator<<(v31, *((unsigned __int8 *)a1 + 33));
  std::ios_base::getloc((const std::ios_base *)((char *)v32 + *(void *)(*v32 - 24LL)));
  uint64_t v33 = std::locale::use_facet(&v48, &std::ctype<char>::id);
  uint64_t v34 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v33->__vftable[2].~facet_0)(v33, 10LL);
  std::locale::~locale(&v48);
  std::ostream::put(v32, v34);
  std::ostream::flush(v32);
  LOBYTE(v48.__locale_) = 9;
  uint64_t v35 = sub_100046B94(&v45, (uint64_t)&v48, 1LL);
  sub_100046B94(v35, (uint64_t)"Pulse shape combos: [", 21LL);
  uint64_t v36 = a1[5];
  if (a1[6] != v36)
  {
    unint64_t v37 = 0LL;
    do
    {
      *(std::streambuf::char_type **)((char *)&v46.__binp_ + *(void *)(v45 - sub_100034A98(v2, *(void **)(v1 + 24)) = (std::streambuf::char_type *)2;
      std::ostream::operator<<(&v45, *(unsigned __int8 *)(v36 + v37));
      uint64_t v36 = a1[5];
      uint64_t v38 = a1[6];
      if (~v36 + v38 > v37)
      {
        sub_100046B94(&v45, (uint64_t)", ", 2LL);
        uint64_t v36 = a1[5];
        uint64_t v38 = a1[6];
      }

      ++v37;
    }

    while (v38 - v36 > v37);
  }

  unint64_t v39 = sub_100046B94(&v45, (uint64_t)"]", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v39 + *(void *)(*v39 - 24LL)));
  unint64_t v40 = std::locale::use_facet(&v48, &std::ctype<char>::id);
  uint64_t v41 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v40->__vftable[2].~facet_0)(v40, 10LL);
  std::locale::~locale(&v48);
  std::ostream::put(v39, v41);
  std::ostream::flush(v39);
  sub_100046B94(&v45, (uint64_t)"}", 1LL);
  std::stringbuf::str(a2, &v46);
  *(void *)((char *)v44
  uint64_t v45 = v42;
  std::streambuf::~streambuf(&v46);
  return std::ios::~ios(&v47);
}

void sub_1002BC730( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1002BC790@<X0>(unsigned __int16 *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  unint64_t v4 = std::locale::use_facet((const std::locale *)&v166, &std::ctype<char>::id);
  uint64_t v5 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v4->__vftable[2].~facet_0)(v4, 10LL);
  std::locale::~locale((std::locale *)&v166);
  std::ostream::put(&v168, v5);
  std::ostream::flush(&v168);
  int v6 = sub_100046B94(&v168, (uint64_t)"{", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v6 + *(void *)(*v6 - 24LL)));
  uint64_t v7 = std::locale::use_facet((const std::locale *)&v166, &std::ctype<char>::id);
  uint64_t v8 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v7->__vftable[2].~facet_0)(v7, 10LL);
  std::locale::~locale((std::locale *)&v166);
  std::ostream::put(v6, v8);
  std::ostream::flush(v6);
  v166.__r_.__value_.__s.__data_[0] = 9;
  uint64_t v9 = sub_100046B94(&v168, (uint64_t)&v166, 1LL);
  unint64_t v10 = sub_100046B94(v9, (uint64_t)"Status: ", 8LL);
  int v11 = sub_1002BF768(*a1);
  sub_1002BEFAC(v11, &v166);
  if ((v166.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    unint64_t v12 = &v166;
  }
  else {
    unint64_t v12 = (std::stringbuf::string_type *)v166.__r_.__value_.__r.__words[0];
  }
  if ((v166.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = v166.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = v166.__r_.__value_.__l.__size_;
  }
  uint64_t v14 = sub_100046B94(v10, (uint64_t)v12, size);
  uint64_t v15 = sub_100046B94(v14, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v15 + *(void *)(*v15 - 24LL)));
  unint64_t v16 = std::locale::use_facet(&v171, &std::ctype<char>::id);
  uint64_t v17 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v16->__vftable[2].~facet_0)(v16, 10LL);
  std::locale::~locale(&v171);
  std::ostream::put(v15, v17);
  std::ostream::flush(v15);
  v166.__r_.__value_.__s.__data_[0] = 48;
  unint64_t v18 = sub_100138E6C(&v168, (char *)&v166);
  *(_DWORD *)((char *)v18 + *(void *)(*v18 - 24LL) + _Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)((_BYTE *)v18 + *(void *)(*v18 - 24LL) + 8) & 0xFFFFFFB5 | 8;
  v166.__r_.__value_.__s.__data_[0] = 9;
  uint64_t v19 = sub_100046B94(&v168, (uint64_t)&v166, 1LL);
  size_t v20 = sub_100046B94(v19, (uint64_t)"Session type: 0x", 16LL);
  unint64_t v21 = (void *)std::ostream::operator<<(v20, *((unsigned __int8 *)a1 + 4));
  uint64_t v22 = sub_100046B94(v21, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v22 + *(void *)(*v22 - 24LL)));
  unsigned __int16 v23 = std::locale::use_facet((const std::locale *)&v166, &std::ctype<char>::id);
  uint64_t v24 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v23->__vftable[2].~facet_0)(v23, 10LL);
  std::locale::~locale((std::locale *)&v166);
  std::ostream::put(v22, v24);
  std::ostream::flush(v22);
  *(_DWORD *)((char *)&v168 + *(void *)(v168 - 24) + _Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)((_BYTE *)&v168 + *(void *)(v168 - 24) + 8) & 0xFFFFFFB5 | 2;
  v166.__r_.__value_.__s.__data_[0] = 9;
  uint64_t v25 = sub_100046B94(&v168, (uint64_t)&v166, 1LL);
  uint64_t v26 = sub_100046B94(v25, (uint64_t)"UWB session id: ", 16LL);
  std::stringbuf v27 = (void *)std::ostream::operator<<(v26, *((unsigned int *)a1 + 2));
  uint64_t v28 = sub_100046B94(v27, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v28 + *(void *)(*v28 - 24LL)));
  uint64_t v29 = std::locale::use_facet((const std::locale *)&v166, &std::ctype<char>::id);
  uint64_t v30 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v29->__vftable[2].~facet_0)(v29, 10LL);
  std::locale::~locale((std::locale *)&v166);
  std::ostream::put(v28, v30);
  std::ostream::flush(v28);
  v166.__r_.__value_.__s.__data_[0] = 9;
  uint64_t v31 = sub_100046B94(&v168, (uint64_t)&v166, 1LL);
  unint64_t v32 = sub_100046B94(v31, (uint64_t)"Block start time (R1 ticks): ", 29LL);
  uint64_t v33 = (void *)std::ostream::operator<<(v32, *((void *)a1 + 2));
  uint64_t v34 = sub_100046B94(v33, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v34 + *(void *)(*v34 - 24LL)));
  uint64_t v35 = std::locale::use_facet((const std::locale *)&v166, &std::ctype<char>::id);
  uint64_t v36 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v35->__vftable[2].~facet_0)(v35, 10LL);
  std::locale::~locale((std::locale *)&v166);
  std::ostream::put(v34, v36);
  std::ostream::flush(v34);
  v166.__r_.__value_.__s.__data_[0] = 9;
  unint64_t v37 = sub_100046B94(&v168, (uint64_t)&v166, 1LL);
  uint64_t v38 = sub_100046B94(v37, (uint64_t)"Block index: ", 13LL);
  unint64_t v39 = (void *)std::ostream::operator<<(v38, a1[12]);
  unint64_t v40 = sub_100046B94(v39, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v40 + *(void *)(*v40 - 24LL)));
  uint64_t v41 = std::locale::use_facet((const std::locale *)&v166, &std::ctype<char>::id);
  uint64_t v42 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v41->__vftable[2].~facet_0)(v41, 10LL);
  std::locale::~locale((std::locale *)&v166);
  std::ostream::put(v40, v42);
  std::ostream::flush(v40);
  v166.__r_.__value_.__s.__data_[0] = 9;
  int v43 = sub_100046B94(&v168, (uint64_t)&v166, 1LL);
  unint64_t v44 = sub_100046B94(v43, (uint64_t)"Round index: ", 13LL);
  uint64_t v45 = (void *)std::ostream::operator<<(v44, a1[13]);
  std::stringbuf v46 = sub_100046B94(v45, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v46 + *(void *)(*v46 - 24LL)));
  uint64_t v47 = std::locale::use_facet((const std::locale *)&v166, &std::ctype<char>::id);
  uint64_t v48 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v47->__vftable[2].~facet_0)(v47, 10LL);
  std::locale::~locale((std::locale *)&v166);
  std::ostream::put(v46, v48);
  std::ostream::flush(v46);
  v166.__r_.__value_.__s.__data_[0] = 9;
  __int128 v49 = sub_100046B94(&v168, (uint64_t)&v166, 1LL);
  uint64_t v50 = sub_100046B94(v49, (uint64_t)"Round STS index: ", 17LL);
  uint64_t v51 = (void *)std::ostream::operator<<(v50, *((unsigned int *)a1 + 8));
  char v52 = sub_100046B94(v51, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v52 + *(void *)(*v52 - 24LL)));
  __int128 v53 = std::locale::use_facet((const std::locale *)&v166, &std::ctype<char>::id);
  uint64_t v54 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v53->__vftable[2].~facet_0)(v53, 10LL);
  std::locale::~locale((std::locale *)&v166);
  std::ostream::put(v52, v54);
  std::ostream::flush(v52);
  v166.__r_.__value_.__s.__data_[0] = 9;
  unint64_t v55 = sub_100046B94(&v168, (uint64_t)&v166, 1LL);
  uint64_t v56 = sub_100046B94(v55, (uint64_t)"Ranging event: ", 15LL);
  id v57 = (void *)std::ostream::operator<<(v56, *((unsigned __int8 *)a1 + 29));
  uint64_t v58 = sub_100046B94(v57, (uint64_t)" of ", 4LL);
  char v59 = (void *)std::ostream::operator<<(v58, *((unsigned __int8 *)a1 + 28));
  uint64_t v60 = sub_100046B94(v59, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v60 + *(void *)(*v60 - 24LL)));
  uint64_t v61 = std::locale::use_facet((const std::locale *)&v166, &std::ctype<char>::id);
  uint64_t v62 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v61->__vftable[2].~facet_0)(v61, 10LL);
  std::locale::~locale((std::locale *)&v166);
  std::ostream::put(v60, v62);
  std::ostream::flush(v60);
  if (*((_BYTE *)a1 + 80))
  {
    v166.__r_.__value_.__s.__data_[0] = 9;
    uint64_t v63 = sub_100046B94(&v168, (uint64_t)&v166, 1LL);
    unint64_t v64 = sub_100046B94(v63, (uint64_t)"Range (m): ", 11LL);
    *(void *)((char *)v64 + *(void *)(*v64 - 24LL) + 16) = 5LL;
    if (!*((_BYTE *)a1 + 80)) {
      sub_100006080();
    }
    unint64_t v65 = (void *)std::ostream::operator<<(*((float *)a1 + 19));
    size_t v66 = sub_100046B94(v65, (uint64_t)",", 1LL);
    std::ios_base::getloc((const std::ios_base *)((char *)v66 + *(void *)(*v66 - 24LL)));
    unint64_t v67 = std::locale::use_facet((const std::locale *)&v166, &std::ctype<char>::id);
    uint64_t v68 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v67->__vftable[2].~facet_0)(v67, 10LL);
    std::locale::~locale((std::locale *)&v166);
    std::ostream::put(v66, v68);
    std::ostream::flush(v66);
  }

  v166.__r_.__value_.__s.__data_[0] = 9;
  uint64_t v69 = sub_100046B94(&v168, (uint64_t)&v166, 1LL);
  size_t v70 = sub_100046B94(v69, (uint64_t)"Block size: ", 12LL);
  unint64_t v71 = (void *)std::ostream::operator<<(v70, a1[18]);
  uint64_t v72 = sub_100046B94(v71, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v72 + *(void *)(*v72 - 24LL)));
  uint64_t v73 = std::locale::use_facet((const std::locale *)&v166, &std::ctype<char>::id);
  uint64_t v74 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v73->__vftable[2].~facet_0)(v73, 10LL);
  std::locale::~locale((std::locale *)&v166);
  std::ostream::put(v72, v74);
  std::ostream::flush(v72);
  v166.__r_.__value_.__s.__data_[0] = 9;
  unint64_t v75 = sub_100046B94(&v168, (uint64_t)&v166, 1LL);
  uint64_t v76 = sub_100046B94(v75, (uint64_t)"Round size: ", 12LL);
  uint64_t v77 = (void *)std::ostream::operator<<(v76, a1[19]);
  unint64_t v78 = sub_100046B94(v77, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v78 + *(void *)(*v78 - 24LL)));
  char v79 = std::locale::use_facet((const std::locale *)&v166, &std::ctype<char>::id);
  uint64_t v80 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v79->__vftable[2].~facet_0)(v79, 10LL);
  std::locale::~locale((std::locale *)&v166);
  std::ostream::put(v78, v80);
  std::ostream::flush(v78);
  v166.__r_.__value_.__s.__data_[0] = 9;
  std::stringbuf v81 = sub_100046B94(&v168, (uint64_t)&v166, 1LL);
  uint64_t v82 = sub_100046B94(v81, (uint64_t)"Slot size: ", 11LL);
  std::locale v83 = (void *)std::ostream::operator<<(v82, a1[20]);
  unint64_t v84 = sub_100046B94(v83, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v84 + *(void *)(*v84 - 24LL)));
  uint64_t v85 = std::locale::use_facet((const std::locale *)&v166, &std::ctype<char>::id);
  uint64_t v86 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v85->__vftable[2].~facet_0)(v85, 10LL);
  std::locale::~locale((std::locale *)&v166);
  std::ostream::put(v84, v86);
  std::ostream::flush(v84);
  v166.__r_.__value_.__s.__data_[0] = 9;
  unint64_t v87 = sub_100046B94(&v168, (uint64_t)&v166, 1LL);
  size_t v88 = sub_100046B94(v87, (uint64_t)"Num. RX skips: ", 15LL);
  unint64_t v89 = (void *)std::ostream::operator<<(v88, *((unsigned __int8 *)a1 + 42));
  uint64_t v90 = sub_100046B94(v89, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v90 + *(void *)(*v90 - 24LL)));
  uint64_t v91 = std::locale::use_facet((const std::locale *)&v166, &std::ctype<char>::id);
  uint64_t v92 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v91->__vftable[2].~facet_0)(v91, 10LL);
  std::locale::~locale((std::locale *)&v166);
  std::ostream::put(v90, v92);
  std::ostream::flush(v90);
  v166.__r_.__value_.__s.__data_[0] = 9;
  uint64_t v93 = sub_100046B94(&v168, (uint64_t)&v166, 1LL);
  uint64_t v94 = sub_100046B94(v93, (uint64_t)"RX skip reasons: ", 17LL);
  sub_1002BBD4C((uint64_t *)a1 + 6, &v166);
  if ((v166.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v95 = &v166;
  }
  else {
    uint64_t v95 = (std::stringbuf::string_type *)v166.__r_.__value_.__r.__words[0];
  }
  if ((v166.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v96 = v166.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t v96 = v166.__r_.__value_.__l.__size_;
  }
  uint64_t v97 = sub_100046B94(v94, (uint64_t)v95, v96);
  uint64_t v98 = sub_100046B94(v97, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v98 + *(void *)(*v98 - 24LL)));
  uint64_t v99 = std::locale::use_facet(&v171, &std::ctype<char>::id);
  uint64_t v100 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v99->__vftable[2].~facet_0)(v99, 10LL);
  std::locale::~locale(&v171);
  std::ostream::put(v98, v100);
  std::ostream::flush(v98);
  v166.__r_.__value_.__s.__data_[0] = 9;
  uint64_t v101 = sub_100046B94(&v168, (uint64_t)&v166, 1LL);
  uint64_t v102 = sub_100046B94(v101, (uint64_t)"Next hop flag: ", 15LL);
  uint64_t v103 = (void *)std::ostream::operator<<(v102, *((unsigned __int8 *)a1 + 72));
  uint64_t v104 = sub_100046B94(v103, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v104 + *(void *)(*v104 - 24LL)));
  uint64_t v105 = std::locale::use_facet((const std::locale *)&v166, &std::ctype<char>::id);
  uint64_t v106 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v105->__vftable[2].~facet_0)(v105, 10LL);
  std::locale::~locale((std::locale *)&v166);
  std::ostream::put(v104, v106);
  std::ostream::flush(v104);
  v166.__r_.__value_.__s.__data_[0] = 9;
  uint64_t v107 = sub_100046B94(&v168, (uint64_t)&v166, 1LL);
  uint64_t v108 = sub_100046B94(v107, (uint64_t)"Next round index: ", 18LL);
  uint64_t v109 = (void *)std::ostream::operator<<(v108, a1[37]);
  uint64_t v110 = sub_100046B94(v109, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v110 + *(void *)(*v110 - 24LL)));
  uint64_t v111 = std::locale::use_facet((const std::locale *)&v166, &std::ctype<char>::id);
  uint64_t v112 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v111->__vftable[2].~facet_0)(v111, 10LL);
  std::locale::~locale((std::locale *)&v166);
  std::ostream::put(v110, v112);
  std::ostream::flush(v110);
  v166.__r_.__value_.__s.__data_[0] = 9;
  uint64_t v113 = sub_100046B94(&v168, (uint64_t)&v166, 1LL);
  uint64_t v114 = sub_100046B94(v113, (uint64_t)"Num. successes: ", 16LL);
  uint64_t v115 = (void *)std::ostream::operator<<(v114, *((unsigned __int8 *)a1 + 84));
  uint64_t v116 = sub_100046B94(v115, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v116 + *(void *)(*v116 - 24LL)));
  uint64_t v117 = std::locale::use_facet((const std::locale *)&v166, &std::ctype<char>::id);
  uint64_t v118 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v117->__vftable[2].~facet_0)(v117, 10LL);
  std::locale::~locale((std::locale *)&v166);
  std::ostream::put(v116, v118);
  std::ostream::flush(v116);
  v166.__r_.__value_.__s.__data_[0] = 9;
  v119 = sub_100046B94(&v168, (uint64_t)&v166, 1LL);
  uint64_t v120 = sub_100046B94(v119, (uint64_t)"Responder info: [", 17LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v120 + *(void *)(*v120 - 24LL)));
  v121 = std::locale::use_facet((const std::locale *)&v166, &std::ctype<char>::id);
  uint64_t v122 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v121->__vftable[2].~facet_0)(v121, 10LL);
  std::locale::~locale((std::locale *)&v166);
  std::ostream::put(v120, v122);
  std::ostream::flush(v120);
  uint64_t v123 = (double *)*((void *)a1 + 11);
  for (uint64_t i = (unsigned __int8 *)*((void *)a1 + 12); v123 != (double *)i; v123 += 2)
  {
    v166.__r_.__value_.__s.__data_[0] = 9;
    uint64_t v125 = sub_100046B94(&v168, (uint64_t)&v166, 1LL);
    v166.__r_.__value_.__s.__data_[0] = 9;
    uint64_t v126 = sub_100046B94(v125, (uint64_t)&v166, 1LL);
    v127 = sub_100046B94(v126, (uint64_t)"{", 1LL);
    std::ios_base::getloc((const std::ios_base *)((char *)v127 + *(void *)(*v127 - 24LL)));
    uint64_t v128 = std::locale::use_facet((const std::locale *)&v166, &std::ctype<char>::id);
    uint64_t v129 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v128->__vftable[2].~facet_0)(v128, 10LL);
    std::locale::~locale((std::locale *)&v166);
    std::ostream::put(v127, v129);
    std::ostream::flush(v127);
    v166.__r_.__value_.__s.__data_[0] = 48;
    uint64_t v130 = sub_100138E6C(&v168, (char *)&v166);
    v166.__r_.__value_.__s.__data_[0] = 9;
    uint64_t v131 = sub_100046B94(&v168, (uint64_t)&v166, 1LL);
    v166.__r_.__value_.__s.__data_[0] = 9;
    uint64_t v132 = sub_100046B94(v131, (uint64_t)&v166, 1LL);
    v166.__r_.__value_.__s.__data_[0] = 9;
    uint64_t v133 = sub_100046B94(v132, (uint64_t)&v166, 1LL);
    uint64_t v134 = sub_100046B94(v133, (uint64_t)"RX status: 0x", 13LL);
    *(void *)((char *)v134 + *(void *)(*v134 - 24LL) + 24) = 1LL;
    v135 = (void *)std::ostream::operator<<(v134, *(unsigned __int8 *)v123);
    uint64_t v136 = sub_100046B94(v135, (uint64_t)",", 1LL);
    std::ios_base::getloc((const std::ios_base *)((char *)v136 + *(void *)(*v136 - 24LL)));
    v137 = std::locale::use_facet((const std::locale *)&v166, &std::ctype<char>::id);
    uint64_t v138 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v137->__vftable[2].~facet_0)(v137, 10LL);
    std::locale::~locale((std::locale *)&v166);
    std::ostream::put(v136, v138);
    std::ostream::flush(v136);
    *(_DWORD *)((char *)&v169.__vftable + *(void *)(v168 - sub_100034A98(v2, *(void **)(v1 + 24)) = *(_DWORD *)((_BYTE *)&v169.__vftable
                                                                              + *(void *)(v168 - 24)) & 0xFFFFFFB5 | 2;
    v166.__r_.__value_.__s.__data_[0] = 9;
    v139 = sub_100046B94(&v168, (uint64_t)&v166, 1LL);
    v166.__r_.__value_.__s.__data_[0] = 9;
    v140 = sub_100046B94(v139, (uint64_t)&v166, 1LL);
    v166.__r_.__value_.__s.__data_[0] = 9;
    v141 = sub_100046B94(v140, (uint64_t)&v166, 1LL);
    v142 = sub_100046B94(v141, (uint64_t)"CFO (ppm): ", 11LL);
    v143 = (void *)std::ostream::operator<<(v142, *((char *)v123 + 1));
    v144 = sub_100046B94(v143, (uint64_t)",", 1LL);
    std::ios_base::getloc((const std::ios_base *)((char *)v144 + *(void *)(*v144 - 24LL)));
    v145 = std::locale::use_facet((const std::locale *)&v166, &std::ctype<char>::id);
    uint64_t v146 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v145->__vftable[2].~facet_0)(v145, 10LL);
    std::locale::~locale((std::locale *)&v166);
    std::ostream::put(v144, v146);
    std::ostream::flush(v144);
    v166.__r_.__value_.__s.__data_[0] = 9;
    v147 = sub_100046B94(&v168, (uint64_t)&v166, 1LL);
    v166.__r_.__value_.__s.__data_[0] = 9;
    v148 = sub_100046B94(v147, (uint64_t)&v166, 1LL);
    v166.__r_.__value_.__s.__data_[0] = 9;
    v149 = sub_100046B94(v148, (uint64_t)&v166, 1LL);
    v150 = sub_100046B94(v149, (uint64_t)"soiRssi (dBm): ", 15LL);
    *(void *)((char *)v150 + *(void *)(*v150 - 24LL) + 16) = 5LL;
    v151 = (void *)std::ostream::operator<<(v150, v123[1]);
    v152 = sub_100046B94(v151, (uint64_t)",", 1LL);
    std::ios_base::getloc((const std::ios_base *)((char *)v152 + *(void *)(*v152 - 24LL)));
    v153 = std::locale::use_facet((const std::locale *)&v166, &std::ctype<char>::id);
    uint64_t v154 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v153->__vftable[2].~facet_0)(v153, 10LL);
    std::locale::~locale((std::locale *)&v166);
    std::ostream::put(v152, v154);
    std::ostream::flush(v152);
    v166.__r_.__value_.__s.__data_[0] = 9;
    uint64_t v155 = sub_100046B94(&v168, (uint64_t)&v166, 1LL);
    v166.__r_.__value_.__s.__data_[0] = 9;
    v156 = sub_100046B94(v155, (uint64_t)&v166, 1LL);
    v157 = sub_100046B94(v156, (uint64_t)"}, ", 3LL);
    std::ios_base::getloc((const std::ios_base *)((char *)v157 + *(void *)(*v157 - 24LL)));
    v158 = std::locale::use_facet((const std::locale *)&v166, &std::ctype<char>::id);
    uint64_t v159 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v158->__vftable[2].~facet_0)(v158, 10LL);
    std::locale::~locale((std::locale *)&v166);
    std::ostream::put(v157, v159);
    std::ostream::flush(v157);
  }

  v166.__r_.__value_.__s.__data_[0] = 9;
  v160 = sub_100046B94(&v168, (uint64_t)&v166, 1LL);
  v161 = sub_100046B94(v160, (uint64_t)"]", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v161 + *(void *)(*v161 - 24LL)));
  v162 = std::locale::use_facet((const std::locale *)&v166, &std::ctype<char>::id);
  uint64_t v163 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v162->__vftable[2].~facet_0)(v162, 10LL);
  std::locale::~locale((std::locale *)&v166);
  std::ostream::put(v161, v163);
  std::ostream::flush(v161);
  sub_100046B94(&v168, (uint64_t)"}", 1LL);
  std::stringbuf::str(a2, &v169);
  *(void *)((char *)v167
  uint64_t v168 = v164;
  std::streambuf::~streambuf(&v169);
  return std::ios::~ios(&v170);
}

void sub_1002BD914( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
}

uint64_t sub_1002BD9E4@<X0>(unsigned __int16 *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  unint64_t v4 = sub_100046B94(&v20, (uint64_t)"BI: ", 4LL);
  std::ostream::operator<<(v4, a1[12]);
  uint64_t v5 = sub_100046B94(&v20, (uint64_t)", ", 2LL);
  int v6 = sub_1002BF768(*a1);
  sub_1002BEFAC(v6, __p);
  if ((v18 & 0x80u) == 0) {
    uint64_t v7 = __p;
  }
  else {
    uint64_t v7 = (void **)__p[0];
  }
  if ((v18 & 0x80u) == 0) {
    uint64_t v8 = v18;
  }
  else {
    uint64_t v8 = (uint64_t)__p[1];
  }
  sub_100046B94(v5, (uint64_t)v7, v8);
  uint64_t v9 = (double *)*((void *)a1 + 11);
  for (uint64_t i = (unsigned __int8 *)*((void *)a1 + 12); v9 != (double *)i; v9 += 2)
  {
    LOBYTE(__p[0]) = 48;
    int v11 = sub_100138E6C(&v20, (char *)__p);
    *(_DWORD *)((char *)v11 + *(void *)(*v11 - 24LL) + _Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)((_BYTE *)v11 + *(void *)(*v11 - 24LL) + 8) & 0xFFFFFFB5 | 8;
    unint64_t v12 = sub_100046B94(&v20, (uint64_t)", <RX: 0x", 9LL);
    *(void *)((char *)v12 + *(void *)(*v12 - 24LL) + 24) = 1LL;
    std::ostream::operator<<(v12, *(unsigned __int8 *)v9);
    *(_DWORD *)((char *)&v21.__vftable + *(void *)(v20 - sub_100034A98(v2, *(void **)(v1 + 24)) = *(_DWORD *)((_BYTE *)&v21.__vftable
                                                                            + *(void *)(v20 - 24)) & 0xFFFFFFB5 | 2;
    char v13 = sub_100046B94(&v20, (uint64_t)", SR: ", 6LL);
    *(void *)((char *)v13 + *(void *)(*v13 - 24LL) + 16) = 5LL;
    uint64_t v14 = (void *)std::ostream::operator<<(v13, v9[1]);
    sub_100046B94(v14, (uint64_t)">", 1LL);
  }

  std::stringbuf::str(a2, &v21);
  *(void *)((char *)v19
  uint64_t v20 = v15;
  std::streambuf::~streambuf(&v21);
  return std::ios::~ios(&v22);
}

void sub_1002BDC08( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_100045880((uint64_t)&a16);
  _Unwind_Resume(a1);
}

uint64_t sub_1002BDC48@<X0>(unsigned __int16 *a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  unint64_t v4 = std::locale::use_facet(&v165, &std::ctype<char>::id);
  uint64_t v5 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v4->__vftable[2].~facet_0)(v4, 10LL);
  std::locale::~locale(&v165);
  std::ostream::put(&v169, v5);
  std::ostream::flush(&v169);
  int v6 = sub_100046B94(&v169, (uint64_t)"{", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v6 + *(void *)(*v6 - 24LL)));
  uint64_t v7 = std::locale::use_facet(&v165, &std::ctype<char>::id);
  uint64_t v8 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v7->__vftable[2].~facet_0)(v7, 10LL);
  std::locale::~locale(&v165);
  std::ostream::put(v6, v8);
  std::ostream::flush(v6);
  LOBYTE(v165.__locale_) = 9;
  uint64_t v9 = sub_100046B94(&v169, (uint64_t)&v165, 1LL);
  unint64_t v10 = sub_100046B94(v9, (uint64_t)"Status: ", 8LL);
  int v11 = sub_1002BF768(*a1);
  sub_1002BEFAC(v11, &v165);
  if ((v167 & 0x80u) == 0) {
    locale = &v165;
  }
  else {
    locale = v165.__locale_;
  }
  if ((v167 & 0x80u) == 0) {
    uint64_t v13 = v167;
  }
  else {
    uint64_t v13 = v166;
  }
  uint64_t v14 = sub_100046B94(v10, (uint64_t)locale, v13);
  uint64_t v15 = sub_100046B94(v14, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v15 + *(void *)(*v15 - 24LL)));
  unint64_t v16 = std::locale::use_facet(&v172, &std::ctype<char>::id);
  uint64_t v17 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v16->__vftable[2].~facet_0)(v16, 10LL);
  std::locale::~locale(&v172);
  std::ostream::put(v15, v17);
  std::ostream::flush(v15);
  LOBYTE(v165.__locale_) = 48;
  unsigned __int8 v18 = sub_100138E6C(&v169, (char *)&v165);
  *(_DWORD *)((char *)v18 + *(void *)(*v18 - 24LL) + _Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)((_BYTE *)v18 + *(void *)(*v18 - 24LL) + 8) & 0xFFFFFFB5 | 8;
  LOBYTE(v165.__locale_) = 9;
  uint64_t v19 = sub_100046B94(&v169, (uint64_t)&v165, 1LL);
  uint64_t v20 = sub_100046B94(v19, (uint64_t)"Session type: 0x", 16LL);
  std::stringbuf v21 = (void *)std::ostream::operator<<(v20, *((unsigned __int8 *)a1 + 4));
  uint64_t v22 = sub_100046B94(v21, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v22 + *(void *)(*v22 - 24LL)));
  unsigned __int16 v23 = std::locale::use_facet(&v165, &std::ctype<char>::id);
  uint64_t v24 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v23->__vftable[2].~facet_0)(v23, 10LL);
  std::locale::~locale(&v165);
  std::ostream::put(v22, v24);
  std::ostream::flush(v22);
  *(_DWORD *)((char *)&v169 + *(void *)(v169 - 24) + _Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)((_BYTE *)&v169 + *(void *)(v169 - 24) + 8) & 0xFFFFFFB5 | 2;
  LOBYTE(v165.__locale_) = 9;
  uint64_t v25 = sub_100046B94(&v169, (uint64_t)&v165, 1LL);
  uint64_t v26 = sub_100046B94(v25, (uint64_t)"UWB session id: ", 16LL);
  std::stringbuf v27 = (void *)std::ostream::operator<<(v26, *((unsigned int *)a1 + 2));
  uint64_t v28 = sub_100046B94(v27, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v28 + *(void *)(*v28 - 24LL)));
  uint64_t v29 = std::locale::use_facet(&v165, &std::ctype<char>::id);
  uint64_t v30 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v29->__vftable[2].~facet_0)(v29, 10LL);
  std::locale::~locale(&v165);
  std::ostream::put(v28, v30);
  std::ostream::flush(v28);
  LOBYTE(v165.__locale_) = 9;
  uint64_t v31 = sub_100046B94(&v169, (uint64_t)&v165, 1LL);
  unint64_t v32 = sub_100046B94(v31, (uint64_t)"Responder index: ", 17LL);
  uint64_t v33 = (void *)std::ostream::operator<<(v32, *((unsigned __int8 *)a1 + 12));
  uint64_t v34 = sub_100046B94(v33, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v34 + *(void *)(*v34 - 24LL)));
  uint64_t v35 = std::locale::use_facet(&v165, &std::ctype<char>::id);
  uint64_t v36 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v35->__vftable[2].~facet_0)(v35, 10LL);
  std::locale::~locale(&v165);
  std::ostream::put(v34, v36);
  std::ostream::flush(v34);
  LOBYTE(v165.__locale_) = 9;
  unint64_t v37 = sub_100046B94(&v169, (uint64_t)&v165, 1LL);
  uint64_t v38 = sub_100046B94(v37, (uint64_t)"Block start time (R1 ticks): ", 29LL);
  unint64_t v39 = (void *)std::ostream::operator<<(v38, *((void *)a1 + 2));
  unint64_t v40 = sub_100046B94(v39, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v40 + *(void *)(*v40 - 24LL)));
  uint64_t v41 = std::locale::use_facet(&v165, &std::ctype<char>::id);
  uint64_t v42 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v41->__vftable[2].~facet_0)(v41, 10LL);
  std::locale::~locale(&v165);
  std::ostream::put(v40, v42);
  std::ostream::flush(v40);
  LOBYTE(v165.__locale_) = 9;
  int v43 = sub_100046B94(&v169, (uint64_t)&v165, 1LL);
  unint64_t v44 = sub_100046B94(v43, (uint64_t)"Block index: ", 13LL);
  uint64_t v45 = (void *)std::ostream::operator<<(v44, a1[12]);
  std::stringbuf v46 = sub_100046B94(v45, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v46 + *(void *)(*v46 - 24LL)));
  uint64_t v47 = std::locale::use_facet(&v165, &std::ctype<char>::id);
  uint64_t v48 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v47->__vftable[2].~facet_0)(v47, 10LL);
  std::locale::~locale(&v165);
  std::ostream::put(v46, v48);
  std::ostream::flush(v46);
  LOBYTE(v165.__locale_) = 9;
  __int128 v49 = sub_100046B94(&v169, (uint64_t)&v165, 1LL);
  uint64_t v50 = sub_100046B94(v49, (uint64_t)"Round index: ", 13LL);
  uint64_t v51 = (void *)std::ostream::operator<<(v50, a1[13]);
  char v52 = sub_100046B94(v51, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v52 + *(void *)(*v52 - 24LL)));
  __int128 v53 = std::locale::use_facet(&v165, &std::ctype<char>::id);
  uint64_t v54 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v53->__vftable[2].~facet_0)(v53, 10LL);
  std::locale::~locale(&v165);
  std::ostream::put(v52, v54);
  std::ostream::flush(v52);
  LOBYTE(v165.__locale_) = 9;
  unint64_t v55 = sub_100046B94(&v169, (uint64_t)&v165, 1LL);
  uint64_t v56 = sub_100046B94(v55, (uint64_t)"Round STS index: ", 17LL);
  id v57 = (void *)std::ostream::operator<<(v56, *((unsigned int *)a1 + 7));
  uint64_t v58 = sub_100046B94(v57, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v58 + *(void *)(*v58 - 24LL)));
  char v59 = std::locale::use_facet(&v165, &std::ctype<char>::id);
  uint64_t v60 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v59->__vftable[2].~facet_0)(v59, 10LL);
  std::locale::~locale(&v165);
  std::ostream::put(v58, v60);
  std::ostream::flush(v58);
  LOBYTE(v165.__locale_) = 9;
  uint64_t v61 = sub_100046B94(&v169, (uint64_t)&v165, 1LL);
  uint64_t v62 = sub_100046B94(v61, (uint64_t)"Ranging event: ", 15LL);
  uint64_t v63 = (void *)std::ostream::operator<<(v62, *((unsigned __int8 *)a1 + 43));
  unint64_t v64 = sub_100046B94(v63, (uint64_t)" of ", 4LL);
  unint64_t v65 = (void *)std::ostream::operator<<(v64, *((unsigned __int8 *)a1 + 42));
  size_t v66 = sub_100046B94(v65, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v66 + *(void *)(*v66 - 24LL)));
  unint64_t v67 = std::locale::use_facet(&v165, &std::ctype<char>::id);
  uint64_t v68 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v67->__vftable[2].~facet_0)(v67, 10LL);
  std::locale::~locale(&v165);
  std::ostream::put(v66, v68);
  std::ostream::flush(v66);
  LOBYTE(v165.__locale_) = 9;
  uint64_t v69 = sub_100046B94(&v169, (uint64_t)&v165, 1LL);
  size_t v70 = sub_100046B94(v69, (uint64_t)"Range (m): ", 11LL);
  *(void *)((char *)v70 + *(void *)(*v70 - 24LL) + 16) = 5LL;
  unint64_t v71 = (void *)std::ostream::operator<<(*((float *)a1 + 11));
  uint64_t v72 = sub_100046B94(v71, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v72 + *(void *)(*v72 - 24LL)));
  uint64_t v73 = std::locale::use_facet(&v165, &std::ctype<char>::id);
  uint64_t v74 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v73->__vftable[2].~facet_0)(v73, 10LL);
  std::locale::~locale(&v165);
  std::ostream::put(v72, v74);
  std::ostream::flush(v72);
  LOBYTE(v165.__locale_) = 9;
  unint64_t v75 = sub_100046B94(&v169, (uint64_t)&v165, 1LL);
  uint64_t v76 = sub_100046B94(v75, (uint64_t)"CFO (ppt): ", 11LL);
  uint64_t v77 = (void *)std::ostream::operator<<(v76, *((unsigned int *)a1 + 12));
  unint64_t v78 = sub_100046B94(v77, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v78 + *(void *)(*v78 - 24LL)));
  char v79 = std::locale::use_facet(&v165, &std::ctype<char>::id);
  uint64_t v80 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v79->__vftable[2].~facet_0)(v79, 10LL);
  std::locale::~locale(&v165);
  std::ostream::put(v78, v80);
  std::ostream::flush(v78);
  LOBYTE(v165.__locale_) = 48;
  std::stringbuf v81 = sub_100138E6C(&v169, (char *)&v165);
  *(_DWORD *)((char *)v81 + *(void *)(*v81 - 24LL) + _Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)((_BYTE *)v81 + *(void *)(*v81 - 24LL) + 8) & 0xFFFFFFB5 | 8;
  LOBYTE(v165.__locale_) = 9;
  uint64_t v82 = sub_100046B94(&v169, (uint64_t)&v165, 1LL);
  std::locale v83 = sub_100046B94(v82, (uint64_t)"Pre-poll RX status: 0x", 22LL);
  *(void *)((char *)v83 + *(void *)(*v83 - 24LL) + 24) = 1LL;
  unint64_t v84 = (void *)std::ostream::operator<<(v83, *((unsigned __int8 *)a1 + 52));
  uint64_t v85 = sub_100046B94(v84, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v85 + *(void *)(*v85 - 24LL)));
  uint64_t v86 = std::locale::use_facet(&v165, &std::ctype<char>::id);
  uint64_t v87 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v86->__vftable[2].~facet_0)(v86, 10LL);
  std::locale::~locale(&v165);
  std::ostream::put(v85, v87);
  std::ostream::flush(v85);
  *(_DWORD *)((char *)&v169 + *(void *)(v169 - 24) + _Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)((_BYTE *)&v169 + *(void *)(v169 - 24) + 8) & 0xFFFFFFB5 | 2;
  LOBYTE(v165.__locale_) = 9;
  size_t v88 = sub_100046B94(&v169, (uint64_t)&v165, 1LL);
  unint64_t v89 = sub_100046B94(v88, (uint64_t)"Pre-poll soiRssi (dBm): ", 24LL);
  *(void *)((char *)v89 + *(void *)(*v89 - 24LL) + 16) = 5LL;
  uint64_t v90 = (void *)std::ostream::operator<<(v89, *((double *)a1 + 7));
  uint64_t v91 = sub_100046B94(v90, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v91 + *(void *)(*v91 - 24LL)));
  uint64_t v92 = std::locale::use_facet(&v165, &std::ctype<char>::id);
  uint64_t v93 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v92->__vftable[2].~facet_0)(v92, 10LL);
  std::locale::~locale(&v165);
  std::ostream::put(v91, v93);
  std::ostream::flush(v91);
  LOBYTE(v165.__locale_) = 48;
  uint64_t v94 = sub_100138E6C(&v169, (char *)&v165);
  *(_DWORD *)((char *)v94 + *(void *)(*v94 - 24LL) + _Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)((_BYTE *)v94 + *(void *)(*v94 - 24LL) + 8) & 0xFFFFFFB5 | 8;
  LOBYTE(v165.__locale_) = 9;
  uint64_t v95 = sub_100046B94(&v169, (uint64_t)&v165, 1LL);
  uint64_t v96 = sub_100046B94(v95, (uint64_t)"Poll RX status: 0x", 18LL);
  *(void *)((char *)v96 + *(void *)(*v96 - 24LL) + 24) = 1LL;
  uint64_t v97 = (void *)std::ostream::operator<<(v96, *((unsigned __int8 *)a1 + 64));
  uint64_t v98 = sub_100046B94(v97, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v98 + *(void *)(*v98 - 24LL)));
  uint64_t v99 = std::locale::use_facet(&v165, &std::ctype<char>::id);
  uint64_t v100 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v99->__vftable[2].~facet_0)(v99, 10LL);
  std::locale::~locale(&v165);
  std::ostream::put(v98, v100);
  std::ostream::flush(v98);
  *(_DWORD *)((char *)&v169 + *(void *)(v169 - 24) + _Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)((_BYTE *)&v169 + *(void *)(v169 - 24) + 8) & 0xFFFFFFB5 | 2;
  LOBYTE(v165.__locale_) = 9;
  uint64_t v101 = sub_100046B94(&v169, (uint64_t)&v165, 1LL);
  uint64_t v102 = sub_100046B94(v101, (uint64_t)"Poll soiRssi (dBm): ", 20LL);
  *(void *)((char *)v102 + *(void *)(*v102 - 24LL) + 16) = 5LL;
  uint64_t v103 = (void *)std::ostream::operator<<(v102, *((double *)a1 + 9));
  uint64_t v104 = sub_100046B94(v103, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v104 + *(void *)(*v104 - 24LL)));
  uint64_t v105 = std::locale::use_facet(&v165, &std::ctype<char>::id);
  uint64_t v106 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v105->__vftable[2].~facet_0)(v105, 10LL);
  std::locale::~locale(&v165);
  std::ostream::put(v104, v106);
  std::ostream::flush(v104);
  LOBYTE(v165.__locale_) = 48;
  uint64_t v107 = sub_100138E6C(&v169, (char *)&v165);
  *(_DWORD *)((char *)v107 + *(void *)(*v107 - 24LL) + _Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)((_BYTE *)v107 + *(void *)(*v107 - 24LL) + 8) & 0xFFFFFFB5 | 8;
  LOBYTE(v165.__locale_) = 9;
  uint64_t v108 = sub_100046B94(&v169, (uint64_t)&v165, 1LL);
  uint64_t v109 = sub_100046B94(v108, (uint64_t)"Final RX status: 0x", 19LL);
  *(void *)((char *)v109 + *(void *)(*v109 - 24LL) + 24) = 1LL;
  uint64_t v110 = (void *)std::ostream::operator<<(v109, *((unsigned __int8 *)a1 + 80));
  uint64_t v111 = sub_100046B94(v110, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v111 + *(void *)(*v111 - 24LL)));
  uint64_t v112 = std::locale::use_facet(&v165, &std::ctype<char>::id);
  uint64_t v113 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v112->__vftable[2].~facet_0)(v112, 10LL);
  std::locale::~locale(&v165);
  std::ostream::put(v111, v113);
  std::ostream::flush(v111);
  *(_DWORD *)((char *)&v169 + *(void *)(v169 - 24) + _Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)((_BYTE *)&v169 + *(void *)(v169 - 24) + 8) & 0xFFFFFFB5 | 2;
  LOBYTE(v165.__locale_) = 9;
  uint64_t v114 = sub_100046B94(&v169, (uint64_t)&v165, 1LL);
  uint64_t v115 = sub_100046B94(v114, (uint64_t)"Final soiRssi (dBm): ", 21LL);
  *(void *)((char *)v115 + *(void *)(*v115 - 24LL) + 16) = 5LL;
  uint64_t v116 = (void *)std::ostream::operator<<(v115, *((double *)a1 + 11));
  uint64_t v117 = sub_100046B94(v116, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v117 + *(void *)(*v117 - 24LL)));
  uint64_t v118 = std::locale::use_facet(&v165, &std::ctype<char>::id);
  uint64_t v119 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v118->__vftable[2].~facet_0)(v118, 10LL);
  std::locale::~locale(&v165);
  std::ostream::put(v117, v119);
  std::ostream::flush(v117);
  LOBYTE(v165.__locale_) = 48;
  uint64_t v120 = sub_100138E6C(&v169, (char *)&v165);
  *(_DWORD *)((char *)v120 + *(void *)(*v120 - 24LL) + _Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)((_BYTE *)v120 + *(void *)(*v120 - 24LL) + 8) & 0xFFFFFFB5 | 8;
  LOBYTE(v165.__locale_) = 9;
  v121 = sub_100046B94(&v169, (uint64_t)&v165, 1LL);
  uint64_t v122 = sub_100046B94(v121, (uint64_t)"Final-data RX status: 0x", 24LL);
  *(void *)((char *)v122 + *(void *)(*v122 - 24LL) + 24) = 1LL;
  uint64_t v123 = (void *)std::ostream::operator<<(v122, *((unsigned __int8 *)a1 + 96));
  uint64_t v124 = sub_100046B94(v123, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v124 + *(void *)(*v124 - 24LL)));
  uint64_t v125 = std::locale::use_facet(&v165, &std::ctype<char>::id);
  uint64_t v126 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v125->__vftable[2].~facet_0)(v125, 10LL);
  std::locale::~locale(&v165);
  std::ostream::put(v124, v126);
  std::ostream::flush(v124);
  *(_DWORD *)((char *)&v169 + *(void *)(v169 - 24) + _Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)((_BYTE *)&v169 + *(void *)(v169 - 24) + 8) & 0xFFFFFFB5 | 2;
  LOBYTE(v165.__locale_) = 9;
  v127 = sub_100046B94(&v169, (uint64_t)&v165, 1LL);
  uint64_t v128 = sub_100046B94(v127, (uint64_t)"Final-data soiRssi (dBm): ", 26LL);
  *(void *)((char *)v128 + *(void *)(*v128 - 24LL) + 16) = 5LL;
  uint64_t v129 = (void *)std::ostream::operator<<(v128, *((double *)a1 + 13));
  uint64_t v130 = sub_100046B94(v129, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v130 + *(void *)(*v130 - 24LL)));
  uint64_t v131 = std::locale::use_facet(&v165, &std::ctype<char>::id);
  uint64_t v132 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v131->__vftable[2].~facet_0)(v131, 10LL);
  std::locale::~locale(&v165);
  std::ostream::put(v130, v132);
  std::ostream::flush(v130);
  LOBYTE(v165.__locale_) = 9;
  uint64_t v133 = sub_100046B94(&v169, (uint64_t)&v165, 1LL);
  uint64_t v134 = sub_100046B94(v133, (uint64_t)"Block size: ", 12LL);
  v135 = (void *)std::ostream::operator<<(v134, a1[16]);
  uint64_t v136 = sub_100046B94(v135, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v136 + *(void *)(*v136 - 24LL)));
  v137 = std::locale::use_facet(&v165, &std::ctype<char>::id);
  uint64_t v138 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v137->__vftable[2].~facet_0)(v137, 10LL);
  std::locale::~locale(&v165);
  std::ostream::put(v136, v138);
  std::ostream::flush(v136);
  LOBYTE(v165.__locale_) = 9;
  v139 = sub_100046B94(&v169, (uint64_t)&v165, 1LL);
  v140 = sub_100046B94(v139, (uint64_t)"Round size: ", 12LL);
  v141 = (void *)std::ostream::operator<<(v140, a1[17]);
  v142 = sub_100046B94(v141, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v142 + *(void *)(*v142 - 24LL)));
  v143 = std::locale::use_facet(&v165, &std::ctype<char>::id);
  uint64_t v144 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v143->__vftable[2].~facet_0)(v143, 10LL);
  std::locale::~locale(&v165);
  std::ostream::put(v142, v144);
  std::ostream::flush(v142);
  LOBYTE(v165.__locale_) = 9;
  v145 = sub_100046B94(&v169, (uint64_t)&v165, 1LL);
  uint64_t v146 = sub_100046B94(v145, (uint64_t)"Slot size: ", 11LL);
  v147 = (void *)std::ostream::operator<<(v146, a1[18]);
  v148 = sub_100046B94(v147, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v148 + *(void *)(*v148 - 24LL)));
  v149 = std::locale::use_facet(&v165, &std::ctype<char>::id);
  uint64_t v150 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v149->__vftable[2].~facet_0)(v149, 10LL);
  std::locale::~locale(&v165);
  std::ostream::put(v148, v150);
  std::ostream::flush(v148);
  LOBYTE(v165.__locale_) = 9;
  v151 = sub_100046B94(&v169, (uint64_t)&v165, 1LL);
  v152 = sub_100046B94(v151, (uint64_t)"Next hop flag: ", 15LL);
  v153 = (void *)std::ostream::operator<<(v152, *((unsigned __int8 *)a1 + 38));
  uint64_t v154 = sub_100046B94(v153, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v154 + *(void *)(*v154 - 24LL)));
  uint64_t v155 = std::locale::use_facet(&v165, &std::ctype<char>::id);
  uint64_t v156 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v155->__vftable[2].~facet_0)(v155, 10LL);
  std::locale::~locale(&v165);
  std::ostream::put(v154, v156);
  std::ostream::flush(v154);
  LOBYTE(v165.__locale_) = 9;
  v157 = sub_100046B94(&v169, (uint64_t)&v165, 1LL);
  v158 = sub_100046B94(v157, (uint64_t)"Next round index: ", 18LL);
  uint64_t v159 = (void *)std::ostream::operator<<(v158, a1[20]);
  v160 = sub_100046B94(v159, (uint64_t)",", 1LL);
  std::ios_base::getloc((const std::ios_base *)((char *)v160 + *(void *)(*v160 - 24LL)));
  v161 = std::locale::use_facet(&v165, &std::ctype<char>::id);
  uint64_t v162 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v161->__vftable[2].~facet_0)(v161, 10LL);
  std::locale::~locale(&v165);
  std::ostream::put(v160, v162);
  std::ostream::flush(v160);
  sub_100046B94(&v169, (uint64_t)"}", 1LL);
  std::stringbuf::str(a2, &v170);
  *(void *)((char *)v168
  uint64_t v169 = v163;
  std::streambuf::~streambuf(&v170);
  return std::ios::~ios(&v171);
}

void sub_1002BEEC4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
}

void *sub_1002BEFAC@<X0>(int a1@<W0>, void *a2@<X8>)
{
  if (a1 <= -1034)
  {
    switch(a1)
    {
      case -4026:
        uint64_t v2 = "SPLIT_DCK_MESSAGES_TOO_MANY_BYTES";
        break;
      case -4025:
        uint64_t v2 = "SPLIT_DCK_MESSAGES_NOT_ENOUGH_BYTES";
        break;
      case -4024:
        uint64_t v2 = "INVALID_DCK_SUB_EVENT_CODE";
        break;
      case -4023:
        uint64_t v2 = "INVALID_DCK_SUB_EVENT_CATEGORY";
        break;
      case -4022:
        uint64_t v2 = "DCK_NO_SUB_EVENT_CODE";
        break;
      case -4021:
        uint64_t v2 = "DCK_NO_SUB_EVENT_CATEGORY";
        break;
      case -4020:
        uint64_t v2 = "DCK_PULSE_SHAPE_COMBO_LENGTH_EXCEEDS_MSG_SIZE";
        break;
      case -4019:
        uint64_t v2 = "DCK_PULSE_SHAPE_COMBO_LENGTH_EXCEEDS_UINT8_MAX";
        break;
      case -4018:
        uint64_t v2 = "DCK_PULSE_SHAPE_COMBO_LENGTH_ZERO";
        break;
      case -4017:
        uint64_t v2 = "DCK_NO_PULSE_SHAPE_COMBO_LENGTH";
        break;
      case -4016:
        uint64_t v2 = "DCK_UWB_CONFIG_ID_LENGTH_EXCEEDS_MSG_SIZE";
        break;
      case -4015:
        uint64_t v2 = "DCK_UWB_CONFIG_ID_LENGTH_EXCEEDS_UINT8_MAX";
        break;
      case -4014:
        uint64_t v2 = "DCK_UWB_CONFIG_ID_LENGTH_ODD";
        break;
      case -4013:
        uint64_t v2 = "DCK_UWB_CONFIG_ID_LENGTH_ZERO";
        break;
      case -4012:
        uint64_t v2 = "DCK_NO_UWB_CONFIG_ID_LENGTH";
        break;
      case -4011:
        uint64_t v2 = "DCK_PROTOCOL_VERSION_LENGTH_EXCEEDS_MSG_SIZE";
        break;
      case -4010:
        uint64_t v2 = "DCK_PROTOCOL_VERSION_LENGTH_EXCEEDS_UINT8_MAX";
        break;
      case -4009:
        uint64_t v2 = "DCK_PROTOCOL_VERSION_LENGTH_ODD";
        break;
      case -4008:
        uint64_t v2 = "DCK_PROTOCOL_VERSION_LENGTH_ZERO";
        break;
      case -4007:
        uint64_t v2 = "DCK_NO_PROTOCOL_VERSION_LENGTH";
        break;
      case -4006:
        uint64_t v2 = "DCK_MSG_UNEXPECTED_DATA_LENGTH";
        break;
      case -4005:
        uint64_t v2 = "DCK_HEADER_ID_MISMATCHES";
        break;
      case -4004:
        uint64_t v2 = "INVALID_DCK_MESSAGE_ID";
        break;
      case -4003:
        uint64_t v2 = "INVALID_DCK_PROTOCOL_TYPE";
        break;
      case -4002:
        uint64_t v2 = "DCK_MISMATCHED_DATA_LENGTH";
        break;
      case -4001:
        uint64_t v2 = "DCK_MESSAGE_EXCEEDS_MAX_SIZE";
        break;
      case -4000:
        uint64_t v2 = "DCK_HEADER_TOO_SHORT";
        break;
      default:
        switch(a1)
        {
          case -2024:
            uint64_t v2 = "ACWG_INVALID_FINAL_DATA2_BITMASK";
            break;
          case -2023:
            uint64_t v2 = "ACWG_INVALID_OFFSET_BETWEEN_RANGING_ROUNDS";
            break;
          case -2022:
            uint64_t v2 = "ACWG_INVALID_NUM_RANGING_ROUNDS_PER_BLOCK";
            break;
          case -2021:
            uint64_t v2 = "ACWG_INVALID_TOTAL_NUM_ROUNDS_PER_BLOCK";
            break;
          case -2020:
            uint64_t v2 = "CAPABILITIES_REQUIRE_RENEGOTIATION";
            break;
          case -2019:
            uint64_t v2 = "UNSUPPORTED_HOP_CONFIG";
            break;
          case -2018:
            uint64_t v2 = "UNSUPPORTED_SYNC_CODES";
            break;
          case -2017:
            uint64_t v2 = "UNSUPPORTED_NUM_SLOTS_PER_ROUND";
            break;
          case -2016:
            uint64_t v2 = "UNSUPPORTED_CHANNELS";
            break;
          case -2015:
            uint64_t v2 = "INVALID_HOP_MODE_SEQUENCE_COMBO";
            break;
          case -2014:
            uint64_t v2 = "INVALID_HOP_MODE";
            break;
          case -2013:
            uint64_t v2 = "INVALID_SYNC_CODES";
            break;
          case -2012:
            uint64_t v2 = "INVALID_SLOTS_RESPONDERS_COMBO";
            break;
          case -2011:
            uint64_t v2 = "INVALID_SLOTS_CHAPS_COMBO";
            break;
          case -2010:
            uint64_t v2 = "INVALID_NUM_CHAPS_PER_SLOT";
            break;
          case -2009:
            uint64_t v2 = "INVALID_NUM_SLOTS_PER_ROUND";
            break;
          case -2008:
            uint64_t v2 = "NO_ALLOWED_CHANNELS";
            break;
          case -2007:
            uint64_t v2 = "RAN_MULTIPLIER_TOO_SMALL";
            break;
          case -2006:
            uint64_t v2 = "NO_BT_TIME_SYNC";
            break;
          case -2005:
            uint64_t v2 = "CAPABILITIES_DO_NOT_MATCH_PREVIOUS_SELECTION";
            break;
          case -2004:
            uint64_t v2 = "UNSUPPORTED_PULSE_SHAPE_COMBO";
            break;
          case -2003:
            uint64_t v2 = "UNSUPPORTED_UWB_CFG_ID";
            break;
          case -2002:
            uint64_t v2 = "UNSUPPORTED_DCK_PROTOCOL_VERSION";
            break;
          case -2001:
            uint64_t v2 = "NO_CACHED_NEGOTIATION_PARAMETERS";
            break;
          case -2000:
            uint64_t v2 = "PARAMETER_NEGOTIATION_OUT_OF_ORDER";
            break;
          default:
            switch(a1)
            {
              case -3013:
                uint64_t v2 = "RECOVERY_REQUEST_GET_KEY_FAILURE";
                break;
              case -3012:
                uint64_t v2 = "SESSION_REQUEST_GET_KEY_FAILURE";
                break;
              case -3011:
                uint64_t v2 = "TIMEOUT_FOR_SUSPEND_RESPONSE_NOT_EXPECTED";
                break;
              case -3010:
                uint64_t v2 = "TIMEOUT_AB_WHEN_NOT_RANGING";
                break;
              case -3009:
                uint64_t v2 = "SUSPEND_RESPONSE_NOT_EXPECTED";
                break;
              case -3008:
                uint64_t v2 = "SESSION_SETUP_REQUEST_NOT_EXPECTED";
                break;
              case -3007:
                uint64_t v2 = "SESSION_REQUEST_NOT_EXPECTED";
                break;
              case -3006:
                uint64_t v2 = "RECOVERY_REQUEST_MISMATCHED_UWB_SESSION_ID";
                break;
              case -3005:
                uint64_t v2 = "RECOVERY_REQUEST_WHEN_SESSION_NOT_SUSPENDED";
                break;
              case -3004:
                uint64_t v2 = "RECOVERY_REQUEST_PARAMETER_UPDATE_FAILED";
                break;
              case -3003:
                uint64_t v2 = "NO_CACHED_KEY";
                break;
              case -3002:
                uint64_t v2 = "NO_CACHED_UWB_SESSION_ID";
                break;
              case -3001:
                uint64_t v2 = "SUSPEND_REQUEST_MISMATCHED_UWB_SESSION_ID";
                break;
              case -3000:
                uint64_t v2 = "SUSPEND_REQUEST_WHEN_NOT_RANGING";
                break;
              default:
LABEL_143:
                uint64_t v2 = "UNKNOWN";
                break;
            }

            break;
        }

        break;
    }
  }

  else
  {
    uint64_t v2 = "SUCCESS";
    switch(a1)
    {
      case 0:
        return sub_1000065CC(a2, v2);
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 7:
      case 9:
      case 10:
      case 11:
      case 15:
      case 16:
      case 17:
      case 24:
      case 25:
      case 26:
      case 27:
      case 30:
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 66:
      case 67:
      case 68:
      case 69:
      case 70:
      case 80:
      case 81:
      case 82:
      case 83:
      case 84:
      case 85:
      case 86:
      case 87:
      case 88:
      case 89:
      case 90:
      case 91:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 97:
      case 102:
      case 103:
      case 104:
      case 105:
      case 106:
      case 107:
      case 108:
      case 109:
      case 110:
      case 111:
        goto LABEL_143;
      case 6:
        uint64_t v2 = "HSI_ERR_BUSY";
        break;
      case 8:
        uint64_t v2 = "HSI_ERR_SES_MAX_LIMIT_REACHED";
        break;
      case 12:
        uint64_t v2 = "HSI_ERR_SES_TIMEOUT";
        break;
      case 13:
        uint64_t v2 = "HSI_ERR_SES_SYNC_TIMEOUT";
        break;
      case 14:
        uint64_t v2 = "HSI_ERR_MISSED_RANGING_CYCLE";
        break;
      case 18:
        uint64_t v2 = "HSI_ERR_SES_ALREADY_ACTIVE";
        break;
      case 19:
        uint64_t v2 = "HSI_ERR_SES_ALREADY_DISABLED";
        break;
      case 20:
        uint64_t v2 = "HSI_ERR_SES_SCHEDULING_CONFLICT";
        break;
      case 21:
        uint64_t v2 = "HSI_ERR_SES_COEX_CONFLICT";
        break;
      case 22:
        uint64_t v2 = "HSI_ERR_SES_WRONG_SYNC";
        break;
      case 23:
        uint64_t v2 = "HSI_ERR_START_TIME_ELAPSED";
        break;
      case 28:
        uint64_t v2 = "HSI_ERR_INVALID_SES_ROLE";
        break;
      case 29:
        uint64_t v2 = "HSI_ERR_INVALID_ANTENNA_CFG";
        break;
      case 31:
        uint64_t v2 = "HSI_ERR_INVALID_PREAMBLE";
        break;
      case 32:
        uint64_t v2 = "HSI_ERR_INVALID_FEM_CFG";
        break;
      case 39:
        uint64_t v2 = "HSI_ERR_INVALID_CHANNEL";
        break;
      case 48:
        uint64_t v2 = "HSI_ERR_INVALID_ALISHA_UWB_CFG_ID";
        break;
      case 49:
        uint64_t v2 = "HSI_ERR_INVALID_ALISHA_RAN_MULTIPLIER";
        break;
      case 50:
        uint64_t v2 = "HSI_ERR_INVALID_ALISHA_NRESPONDERS";
        break;
      case 51:
        uint64_t v2 = "HSI_ERR_INVALID_SLOT_SIZE";
        break;
      case 52:
        uint64_t v2 = "HSI_ERR_INVALID_NSLOTS_PER_ROUND";
        break;
      case 53:
        uint64_t v2 = "HSI_ERR_INVALID_RBLOCK_CFG";
        break;
      case 54:
        uint64_t v2 = "HSI_ERR_ALISHA_UWB_SES_ID_NOT_FOUND";
        break;
      case 55:
        uint64_t v2 = "HSI_ERR_ALISHA_UWB_SES_ID_ALREADY_IN_USE";
        break;
      case 56:
        uint64_t v2 = "HSI_ERR_ALISHA_KEY_STORE_FULL";
        break;
      case 57:
        uint64_t v2 = "HSI_ERR_INVALID_ALISHA_RESPONDER_IDX";
        break;
      case 62:
        uint64_t v2 = "HSI_ERR_SLOT_TIME_ELAPSED";
        break;
      case 63:
        uint64_t v2 = "HSI_ERR_INVALID_PULSE_SHAPE_COMBO";
        break;
      case 64:
        uint64_t v2 = "HSI_ERR_INVALID_ALISHA_HOP_MODE";
        break;
      case 65:
        uint64_t v2 = "HSI_ERR_INVALID_ALISHA_HOP_SEQUENCE";
        break;
      case 71:
        uint64_t v2 = "HSI_ERR_ALISHA_URSK_RETRIEVAL_FAILED";
        break;
      case 72:
        uint64_t v2 = "HSI_ERR_ALISHA_GET_KEY_ALREADY_PENDING";
        break;
      case 73:
        uint64_t v2 = "HSI_ERR_STS_INDEX_EXHAUSTED";
        break;
      case 74:
        uint64_t v2 = "HSI_ERR_BLOCK_IDX_EXHAUSTED";
        break;
      case 75:
        uint64_t v2 = "HSI_ERR_ALISHA_URSK_TTL_EXPIRED";
        break;
      case 76:
        uint64_t v2 = "HSI_ERR_INVALID_ALISHA_STS_INDEX_0";
        break;
      case 77:
        uint64_t v2 = "HSI_ERR_ALISHA_RESPONSE_TIMEOUT";
        break;
      case 78:
        uint64_t v2 = "HSI_ERR_ALISHA_TOTAL_TIMEOUT";
        break;
      case 79:
        uint64_t v2 = "HSI_ERR_UNAUTHENTICATED_CAL_BLOB";
        break;
      case 98:
        uint64_t v2 = "HSI_ERR_ALISHA_TIMER_CREATION_FAILED";
        break;
      case 99:
        uint64_t v2 = "HSI_ERR_ALISHA_TIMER_QUERY_FAILED";
        break;
      case 100:
        uint64_t v2 = "HSI_ERR_ALISHA_TIMER_RESP_INVALID";
        break;
      case 101:
        uint64_t v2 = "HSI_ERR_ALISHA_TIMER_DELETION_FAILED";
        break;
      case 112:
        uint64_t v2 = "HSI_ERR_INVALID_ACWG_ROUNDS_OFFSET";
        break;
      case 113:
        uint64_t v2 = "HSI_ERR_INVALID_ACWG_CONFIG";
        break;
      case 114:
        uint64_t v2 = "HSI_ERR_SC_GET_KEY_INVALID_KEY_TYPE";
        break;
      case 115:
        uint64_t v2 = "HSI_ERR_ACWG_FDATA2_RX_FAILED";
        break;
      default:
        switch(a1)
        {
          case -1033:
            uint64_t v2 = "PREWARM_SECURE_ELEMENT_CHANNEL_UNEXPECTED_RSP";
            break;
          case -1032:
            uint64_t v2 = "PREWARM_SECURE_ELEMENT_CHANNEL_EMPTY_RSP";
            break;
          case -1031:
            uint64_t v2 = "PREWARM_SECURE_ELEMENT_CHANNEL_TIMED_OUT";
            break;
          case -1030:
            uint64_t v2 = "PREWARM_SECURE_ELEMENT_CHANNEL_CMD_FAILED";
            break;
          case -1029:
            uint64_t v2 = "GET_TEST_MODE_FAILED";
            break;
          case -1028:
            uint64_t v2 = "SET_TEST_MODE_FAILED";
            break;
          case -1027:
            uint64_t v2 = "CONFIG_MISSING_MANDATORY_ANTENNA_MASK_KEY";
            break;
          case -1026:
            uint64_t v2 = "SUBSYSTEM_TIME_CONVERSION_FAILED";
            break;
          case -1025:
            uint64_t v2 = "TIME_CONVERSION_NOT_READY";
            break;
          case -1024:
            uint64_t v2 = "GET_SESSION_STATS_AOP_COMMAND_FAILED";
            break;
          case -1023:
            uint64_t v2 = "RANGE_ENABLE_UNDEFINED_ERROR";
            break;
          case -1022:
            uint64_t v2 = "RANGE_ENABLE_TIME_CONVERSION_FAILED";
            break;
          case -1021:
            uint64_t v2 = "PASSTHROUGH_SESSION_NOT_SUPPORTED";
            break;
          case -1020:
            uint64_t v2 = "SET_URSK_TTL_NOT_SUPPORTED";
            break;
          case -1019:
            uint64_t v2 = "DELETE_KEYS_TIMED_OUT";
            break;
          case -1018:
            uint64_t v2 = "DELETE_KEYS_ROSE_COMMAND_FAILED";
            break;
          case -1017:
            uint64_t v2 = "SET_URSK_TTL_ROSE_COMMAND_FAILED";
            break;
          case -1016:
            uint64_t v2 = "CONFIG_CONTAINS_INVALID_SYNC_CODE_INDEX";
            break;
          case -1015:
            uint64_t v2 = "CONFIG_MISSING_MANDATORY_ANCHOR_KEY";
            break;
          case -1014:
            uint64_t v2 = "CONFIG_MISSING_MANDATORY_PASSTHROUGH_KEY";
            break;
          case -1013:
            uint64_t v2 = "BUILD_ALISHA_SESSION_FAILED";
            break;
          case -1012:
            uint64_t v2 = "SET_DEBUG_KEY_NOT_SUPPORTED";
            break;
          case -1011:
            uint64_t v2 = "ALISHA_KEY_ROSE_COMMAND_ALREADY_IN_FLIGHT";
            break;
          case -1010:
            uint64_t v2 = "SET_DEBUG_KEY_TIMED_OUT";
            break;
          case -1009:
            uint64_t v2 = "SET_DEBUG_KEY_ROSE_COMMAND_FAILED";
            break;
          case -1008:
            uint64_t v2 = "GET_KEY_RETURNED_WRONG_UWB_SESSION_ID";
            break;
          case -1007:
            uint64_t v2 = "GET_KEY_ROSE_COMMAND_FAILED";
            break;
          case -1006:
            uint64_t v2 = "GET_CAPABILITIES_TIMED_OUT";
            break;
          case -1005:
            uint64_t v2 = "GET_CAPABILITIES_ROSE_COMMAND_FAILED";
            break;
          case -1004:
            uint64_t v2 = "INTERNAL_ERROR_NO_RESULT_PAYLOAD";
            break;
          case -1003:
            uint64_t v2 = "UNKNOWN_HSI_STATUS_CODE";
            break;
          case -1002:
            uint64_t v2 = "GET_KEY_TIMED_OUT";
            break;
          case -1001:
            uint64_t v2 = "RANGE_ENABLE_TIMED_OUT";
            break;
          case -1000:
            uint64_t v2 = "FAILURE";
            break;
          default:
            goto LABEL_143;
        }

        break;
    }
  }

  return sub_1000065CC(a2, v2);
}

uint64_t sub_1002BF768(unsigned int a1)
{
  if (a1 > 0x73) {
    return 4294966293LL;
  }
  else {
    return dword_10042CFC4[(__int16)a1];
  }
}

void *sub_1002BF78C@<X0>(char a1@<W0>, void *a2@<X8>)
{
  return sub_1000065CC(a2, off_1007BC0A0[a1]);
}

uint64_t sub_1002BF7A4( uint64_t a1, void *a2, void *a3, void *a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = a2[1];
  *(void *)a1 = *a2;
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v11;
  if (v11)
  {
    unint64_t v12 = (unint64_t *)(v11 + 8);
    do
      unint64_t v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }

  uint64_t v14 = a3[1];
  *(void *)(a1 + 16) = *a3;
  *(void *)(a1 + 24) = v14;
  uint64_t v15 = (void *)(a1 + 16);
  if (v14)
  {
    unint64_t v16 = (unint64_t *)(v14 + 8);
    do
      unint64_t v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }

  uint64_t v18 = a4[1];
  *(void *)(a1 + 32) = *a4;
  *(void *)(a1 + 40) = v18;
  uint64_t v19 = (void *)(a1 + 32);
  if (v18)
  {
    uint64_t v20 = (unint64_t *)(v18 + 8);
    do
      unint64_t v21 = __ldxr(v20);
    while (__stxr(v21 + 1, v20));
  }

  uint64_t v22 = a5[1];
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = *a5;
  *(void *)(a1 + 56) = v22;
  if (v22)
  {
    unsigned __int16 v23 = (unint64_t *)(v22 + 8);
    do
      unint64_t v24 = __ldxr(v23);
    while (__stxr(v24 + 1, v23));
  }

  sub_10001E914(a1 + 64, a6);
  sub_10001E914(a1 + 96, a7);
  sub_10001E914(a1 + 128, a8);
  *(_BYTE *)(a1 + 160) = 0;
  *(_BYTE *)(a1 + 164) = 0;
  *(_BYTE *)(a1 + 16_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 172) = 0;
  *(_BYTE *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 18_Block_object_dispose((const void *)(v1 - 112), 8) = 3;
  if (!*(void *)a1)
  {
    uint64_t v26 = "_parameterNegotiator";
    int v27 = 56;
    goto LABEL_24;
  }

  if (!*v15)
  {
    uint64_t v26 = "_rangingLimitManager";
    int v27 = 57;
    goto LABEL_24;
  }

  if (!*v19)
  {
    uint64_t v26 = "_uwbSystem";
    int v27 = 58;
    goto LABEL_24;
  }

  if (!*(void *)(a1 + 88))
  {
    uint64_t v26 = "_rangeEnableCallback";
    int v27 = 59;
    goto LABEL_24;
  }

  if (!*(void *)(a1 + 120))
  {
    uint64_t v26 = "_rangeDisableCallback";
    int v27 = 60;
LABEL_24:
    __assert_rtn("StateMachine", "AlishaStateMachine.cpp", v27, v26);
  }

  return a1;
}

void sub_1002BF948(_Unwind_Exception *a1)
{
  uint64_t v8 = *(void **)(v1 + 120);
  if (v8 == v6)
  {
    uint64_t v9 = 4LL;
    uint64_t v8 = v6;
  }

  else
  {
    if (!v8) {
      goto LABEL_6;
    }
    uint64_t v9 = 5LL;
  }

  (*(void (**)(void))(*v8 + 8 * v9))();
LABEL_6:
  unint64_t v10 = *(void **)(v1 + 88);
  if (v10 == v5)
  {
    uint64_t v11 = 4LL;
    unint64_t v10 = v5;
  }

  else
  {
    if (!v10) {
      goto LABEL_11;
    }
    uint64_t v11 = 5LL;
  }

  (*(void (**)(void))(*v10 + 8 * v11))();
LABEL_11:
  sub_100012390(v4);
  sub_100012390(v3);
  sub_100012390(v2);
  sub_100012390(v1);
  _Unwind_Resume(a1);
}

void *sub_1002BFA18(void *a1)
{
  uint64_t v2 = (void *)a1[11];
  a1[11] = 0LL;
  if (v2 == a1 + 8)
  {
    uint64_t v3 = 4LL;
    uint64_t v2 = a1 + 8;
  }

  else
  {
    if (!v2) {
      goto LABEL_6;
    }
    uint64_t v3 = 5LL;
  }

  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_6:
  uint64_t v4 = (void *)a1[15];
  a1[15] = 0LL;
  if (v4 == a1 + 12)
  {
    uint64_t v5 = 4LL;
    uint64_t v4 = a1 + 12;
  }

  else
  {
    if (!v4) {
      goto LABEL_11;
    }
    uint64_t v5 = 5LL;
  }

  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_11:
  uint64_t result = (void *)a1[19];
  a1[19] = 0LL;
  if (result == a1 + 16)
  {
    uint64_t v7 = 4LL;
    uint64_t result = a1 + 16;
  }

  else
  {
    if (!result) {
      return result;
    }
    uint64_t v7 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v7))();
}

uint64_t sub_1002BFAFC(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 160);
  if (!*(_BYTE *)(a1 + 160))
  {
    int v3 = 0;
    goto LABEL_10;
  }

  if (v2 == 5) {
LABEL_4:
  }
    int v3 = 0;
  else {
    int v3 = 1;
  }
  if (*(void *)(a1 + 152)) {
    sub_1002C1B28(a1 + 128, v2, 0);
  }
  *(_BYTE *)(a1 + 160) = 0;
LABEL_10:
  sub_1002B66A0(*(void *)a1);
  if (*(_BYTE *)(a1 + 168)) {
    *(_BYTE *)(a1 + 16_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  }
  if (*(_BYTE *)(a1 + 184)) {
    *(_BYTE *)(a1 + 184) = 0;
  }
  *(_DWORD *)(a1 + 18_Block_object_dispose((const void *)(v1 - 112), 8) = 3;
  if (!v3) {
    return 0LL;
  }
  uint64_t v4 = sub_1002C0768(a1, 3LL);
  uint64_t v5 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    sub_1002BEFAC(v4, __p);
    if (v9 >= 0) {
      int v6 = __p;
    }
    else {
      int v6 = (void **)__p[0];
    }
    *(_DWORD *)buf = 136315138;
    uint64_t v11 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "#alisha-sm,_resetToInitialState called while ranging. rangeDisable returns status code %s",  buf,  0xCu);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
  }

  return v4;
}

uint64_t sub_1002BFC68(uint64_t a1, unsigned __int16 **a2)
{
  uint64_t v4 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    sub_1002BF78C(*(_BYTE *)(a1 + 160), &__p);
    uint64_t v5 = v27 >= 0 ? &__p : (__int128 *)__p;
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#alisha-sm,Processing DCK cap RQ in state %s",  (uint8_t *)&buf,  0xCu);
    if (v27 < 0) {
      operator delete((void *)__p);
    }
  }

  unsigned int v6 = sub_1002BFAFC(a1);
  if (v6)
  {
    sub_1002BFAFC(a1);
    LODWORD(__p) = v6;
    *(void *)((char *)&__p + 4) = 0LL;
    return v6;
  }

  else
  {
    __int128 buf = 0uLL;
    uint64_t v35 = 0LL;
    uint64_t v8 = *a2;
    char v9 = a2[1];
    if (*a2 != v9)
    {
      do
      {
        uint64_t v10 = sub_1002B7A9C(*v8);
        __int16 v11 = v10;
        if ((v10 & 0xFF0000) != 0)
        {
          unint64_t v12 = (char *)*((void *)&buf + 1);
          if (*((void *)&buf + 1) >= (unint64_t)v35)
          {
            uint64_t v14 = (char *)buf;
            uint64_t v15 = *((void *)&buf + 1) - buf;
            uint64_t v16 = v15 >> 1;
            else {
              uint64_t v17 = (uint64_t)&v35[-buf];
            }
            else {
              uint64_t v18 = v17;
            }
            if (v18)
            {
              uint64_t v19 = (char *)sub_100137E38((uint64_t)&v35, v18);
              unint64_t v12 = (char *)*((void *)&buf + 1);
              uint64_t v14 = (char *)buf;
            }

            else
            {
              uint64_t v19 = 0LL;
            }

            uint64_t v20 = &v19[2 * v16];
            *(_WORD *)uint64_t v20 = v11;
            unint64_t v13 = v20 + 2;
            while (v12 != v14)
            {
              __int16 v21 = *((_WORD *)v12 - 1);
              v12 -= 2;
              *((_WORD *)v20 - 1) = v21;
              v20 -= 2;
            }

            *(void *)&__int128 buf = v20;
            *((void *)&buf + 1) = v13;
            uint64_t v35 = &v19[2 * v18];
            if (v14) {
              operator delete(v14);
            }
          }

          else
          {
            **((_WORD **)&buf + 1) = v10;
            unint64_t v13 = v12 + 2;
          }

          *((void *)&buf + 1) = v13;
        }

        ++v8;
      }

      while (v8 != v9);
    }

    sub_1002C1B84(&__p, (uint64_t)&buf, (uint64_t)(a2 + 3), (uint64_t)(a2 + 6));
    unint64_t v22 = sub_1002B6C88(*(void *)a1, (unsigned __int16 **)&__p);
    if ((*(void *)&v23 & 0xFF0000LL) != 0) {
      int v24 = 0;
    }
    else {
      int v24 = -1004;
    }
    if ((_DWORD)v22) {
      unsigned int v25 = v22;
    }
    else {
      unsigned int v25 = v24;
    }
    if (v25)
    {
      sub_1002BFAFC(a1);
      v33[0] = v25;
      *(void *)&v33[1] = 0LL;
      v32[0] = v25;
    }

    else
    {
      if ((*(void *)&v23 & 0xFF0000LL) == 0) {
        sub_100006080();
      }
      LODWORD(v32[0]) = 0;
      *(void *)((char *)v32 + 4) = HIDWORD(v22) & 0xFFFF0000 | WORD2(v22) | ((unint64_t)v23 << 32) | 0x1000000000000LL;
    }

    if (v30)
    {
      uint64_t v31 = v30;
      operator delete(v30);
    }

    if (v28)
    {
      uint64_t v29 = v28;
      operator delete(v28);
    }

    if ((void)__p)
    {
      *((void *)&__p + 1) = __p;
      operator delete((void *)__p);
    }

    if ((void)buf)
    {
      *((void *)&buf + 1) = buf;
      operator delete((void *)buf);
    }

    return v32[0];
  }

void sub_1002BFF3C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *__p, uint64_t a24)
{
  if (__p)
  {
    a24 = (uint64_t)__p;
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1002BFF80(uint64_t a1@<X0>, unsigned __int16 *a2@<X1>, char a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v8 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    sub_1002BF78C(*(_BYTE *)(a1 + 160), __p);
    char v9 = v36 >= 0 ? __p : *(_BYTE **)__p;
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v38 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#alisha-sm,Processing DCK session RQ in state %s",  buf,  0xCu);
    if (v36 < 0) {
      operator delete(*(void **)__p);
    }
  }

  if (*(_BYTE *)(a1 + 160)) {
    sub_1002BFAFC(a1);
  }
  uint64_t v10 = *(void *)(a1 + 48);
  if (v10) {
    (*(void (**)(uint64_t, void))(*(void *)v10 + 16LL))(v10, 0LL);
  }
  uint64_t v11 = sub_1002B7A9C(*a2);
  unsigned __int16 v12 = v11;
  if ((v11 & 0xFF0000) == 0)
  {
    sub_1002BFAFC(a1);
    int v18 = -2002;
LABEL_27:
    *(_DWORD *)a4 = v18;
    *(_BYTE *)(a4 + 4) = 0;
    *(_BYTE *)(a4 + 16) = 0;
    return;
  }

  uint64_t v13 = *(void *)(a1 + 48);
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 104LL))(v13);
  }
  (*(void (**)(_BYTE *__return_ptr, void, void))(**(void **)(a1 + 32) + 24LL))( __p,  *(void *)(a1 + 32),  *((unsigned int *)a2 + 1));
  if (v35) {
    int v14 = 0;
  }
  else {
    int v14 = -1004;
  }
  if (*(_DWORD *)__p) {
    int v15 = *(_DWORD *)__p;
  }
  else {
    int v15 = v14;
  }
  uint64_t v16 = *(void *)(a1 + 48);
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 112LL))(v16);
  }
  if (v15)
  {
    uint64_t v17 = qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
      sub_1003A6CC0(v15, v17);
    }
    sub_1002BFAFC(a1);
    int v18 = -3012;
    goto LABEL_27;
  }

  *(_DWORD *)(a1 + 164) = *((_DWORD *)a2 + 1);
  *(_BYTE *)(a1 + 16_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
  if (!v35) {
    sub_100006080();
  }
  int v19 = *(unsigned __int8 *)(a1 + 184);
  *(void *)(a1 + 172) = *(void *)&__p[4];
  *(_DWORD *)(a1 + 180) = v34;
  if (!v19) {
    *(_BYTE *)(a1 + 184) = 1;
  }
  unsigned __int16 v20 = a2[1];
  unsigned __int16 v21 = a2[4];
  v31[0] = v12;
  v31[1] = v20;
  v31[2] = v21;
  char v32 = a3;
  sub_1002B6E50(*(void **)a1, v31, (uint64_t)buf);
  int v22 = v41;
  if (v41) {
    int v23 = 0;
  }
  else {
    int v23 = -1004;
  }
  if (*(_DWORD *)buf) {
    int v24 = *(_DWORD *)buf;
  }
  else {
    int v24 = v23;
  }
  if (v24)
  {
    sub_1002BFAFC(a1);
    char v25 = 0;
    *(_DWORD *)a4 = v24;
    *(_BYTE *)(a4 + 4) = 0;
  }

  else
  {
    int v26 = *(unsigned __int8 *)(a1 + 160);
    if (v26 != 1)
    {
      if (*(void *)(a1 + 152))
      {
        sub_1002C1B28(a1 + 128, v26, 1);
        int v22 = v41;
      }

      *(_BYTE *)(a1 + 160) = 1;
    }

    if (!v22) {
      sub_100006080();
    }
    char v25 = 1;
    int v27 = 1 << v39;
    __int16 v28 = (__int16)v38;
    int v29 = HIDWORD(v38);
    __int16 v30 = v40;
    *(_DWORD *)a4 = 0;
    *(_WORD *)(a4 + 4) = v28;
    *(_DWORD *)(a4 + _Block_object_dispose((const void *)(v1 - 112), 8) = v29;
    *(_BYTE *)(a4 + 12) = v27;
    *(_WORD *)(a4 + 13) = v30;
  }

  *(_BYTE *)(a4 + 16) = v25;
}

uint64_t sub_1002C0268@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int16 a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v8 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    sub_1002BF78C(*(_BYTE *)(a1 + 160), &__p);
    char v9 = (SBYTE7(v29) & 0x80u) == 0 ? &__p : (void **)__p;
    *(_DWORD *)__int128 buf = 136315138;
    *(void *)unint64_t v37 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#alisha-sm,Processing DCK session setup RQ in state %s",  buf,  0xCu);
    if (SBYTE7(v29) < 0) {
      operator delete(__p);
    }
  }

  if (*(_BYTE *)(a1 + 160) != 1)
  {
    uint64_t result = sub_1002BFAFC(a1);
    int v15 = -3008;
LABEL_22:
    *(_DWORD *)a4 = v15;
    goto LABEL_23;
  }

  if (!*(_BYTE *)(a1 + 168))
  {
    uint64_t result = sub_1002BFAFC(a1);
    int v15 = -3002;
    goto LABEL_22;
  }

  if (!*(_BYTE *)(a1 + 184))
  {
    uint64_t result = sub_1002BFAFC(a1);
    int v15 = -3003;
    goto LABEL_22;
  }

  char v10 = *(_BYTE *)(a2 + 8);
  int v11 = *(_DWORD *)(a2 + 4);
  v32[0] = *(_DWORD *)a2;
  v32[1] = v11;
  char v33 = v10;
  __int16 v34 = a3;
  sub_1002B7164(*(void *)a1, (unsigned __int8 *)v32, (uint64_t)&__p);
  if (v31) {
    int v12 = 0;
  }
  else {
    int v12 = -1004;
  }
  if ((_DWORD)__p) {
    int v13 = (int)__p;
  }
  else {
    int v13 = v12;
  }
  if (v13)
  {
    uint64_t result = sub_1002BFAFC(a1);
LABEL_18:
    *(_DWORD *)a4 = v13;
LABEL_23:
    *(_BYTE *)(a4 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0;
    *(_BYTE *)(a4 + 32) = 0;
    return result;
  }

  if ((*(unsigned int (**)(void))(**(void **)(a1 + 16) + 16LL))(*(void *)(a1 + 16)))
  {
    int v16 = *(unsigned __int8 *)(a1 + 160);
    if (v16 != 2)
    {
      if (*(void *)(a1 + 152)) {
        sub_1002C1B28(a1 + 128, v16, 2);
      }
      *(_BYTE *)(a1 + 160) = 2;
    }

    uint64_t result = *(void *)(a1 + 48);
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 40LL))(result);
    }
    uint64_t v17 = 0LL;
  }

  else
  {
    if (!v31) {
      sub_100006080();
    }
    if (!*(_BYTE *)(a1 + 168)) {
      sub_100006080();
    }
    int v25 = *(_DWORD *)(a1 + 164);
    __int128 v26 = v29;
    char v35 = v30;
    uint64_t v21 = *(void *)(a1 + 88);
    if (!v21) {
      sub_10001EEF0();
    }
    (*(void (**)(uint8_t *__return_ptr, uint64_t, int *, const char **))(*(void *)v21 + 48LL))( buf,  v21,  &v25,  &v35);
    if (v38) {
      int v22 = 0;
    }
    else {
      int v22 = -1004;
    }
    if (*(_DWORD *)buf) {
      int v13 = *(_DWORD *)buf;
    }
    else {
      int v13 = v22;
    }
    if (v13)
    {
      uint64_t result = sub_1002BFAFC(a1);
      goto LABEL_18;
    }

    if (!v38) {
      sub_100006080();
    }
    uint64_t v23 = *(void *)a1;
    char v35 = *(const char **)&v37[4];
    uint64_t v17 = sub_1002B6AC4(v23, &v35);
    int v24 = *(unsigned __int8 *)(a1 + 160);
    if (v24 != 3)
    {
      if (*(void *)(a1 + 152)) {
        sub_1002C1B28(a1 + 128, v24, 3);
      }
      *(_BYTE *)(a1 + 160) = 3;
    }

    (*(void (**)(void))(**(void **)(a1 + 16) + 32LL))(*(void *)(a1 + 16));
    uint64_t result = *(void *)(a1 + 48);
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t, void, void, void))(*(void *)result + 24LL))( result,  BYTE9(v26),  v26,  BYTE6(v26));
    }
  }

  if (!v31) {
    sub_100006080();
  }
  if (!*(_BYTE *)(a1 + 184)) {
    sub_100006080();
  }
  char v18 = v28;
  int v19 = *(_DWORD *)(a1 + 176);
  int v20 = *(_DWORD *)(a1 + 180);
  *(_BYTE *)(a1 + 184) = 0;
  *(_DWORD *)a4 = 0;
  *(_DWORD *)(a4 + _Block_object_dispose((const void *)(v1 - 112), 8) = v19;
  *(void *)(a4 + 16) = v17;
  *(_DWORD *)(a4 + 24) = v20;
  *(_BYTE *)(a4 + 2_Block_object_dispose((const void *)(v1 - 112), 8) = v18;
  *(_BYTE *)(a4 + 32) = 1;
  return result;
}

uint64_t sub_1002C05AC(uint64_t a1, _DWORD *a2)
{
  uint64_t v4 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    sub_1002BF78C(*(_BYTE *)(a1 + 160), __p);
    uint64_t v5 = v11 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)__int128 buf = 136315138;
    int v13 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#alisha-sm,Processing DCK suspend RQ in state %s",  buf,  0xCu);
    if (v11 < 0) {
      operator delete(__p[0]);
    }
  }

  int v6 = *(unsigned __int8 *)(a1 + 160);
  if ((v6 - 3) < 2)
  {
    if (*(_BYTE *)(a1 + 168))
    {
      if (*(_DWORD *)(a1 + 164) == *a2)
      {
        unsigned int v8 = sub_1002C0768(a1, 2LL);
        if (!v8)
        {
          int v9 = *(unsigned __int8 *)(a1 + 160);
          if (v9 == 5) {
            return 0x10000000000LL;
          }
          if (*(void *)(a1 + 152)) {
            sub_1002C1B28(a1 + 128, v9, 5);
          }
          goto LABEL_12;
        }

        sub_1002BFAFC(a1);
        return v8;
      }

      else
      {
        sub_1002BFAFC(a1);
        return 4294964295LL;
      }
    }

    else
    {
      sub_1002BFAFC(a1);
      return 4294964294LL;
    }
  }

  else
  {
    if (v6 != 1)
    {
      if (v6 != 2) {
        return 0x10000000000LL;
      }
      if (*(void *)(a1 + 152)) {
        sub_1002C1B28(a1 + 128, 2, 5);
      }
LABEL_12:
      *(_BYTE *)(a1 + 160) = 5;
      return 0x10000000000LL;
    }

    sub_1002BFAFC(a1);
    return 4294964296LL;
  }

uint64_t sub_1002C0768(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 120);
  if (!v3) {
    sub_10001EEF0();
  }
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v3 + 48LL))(&v8);
  uint64_t v5 = v8;
  (*(void (**)(void))(**(void **)(a1 + 16) + 40LL))(*(void *)(a1 + 16));
  uint64_t v6 = *(void *)(a1 + 48);
  if (v6)
  {
    if (v12)
    {
      (*(void (**)(uint64_t, uint64_t *))(*(void *)v6 + 120LL))(v6, &v9);
      uint64_t v6 = *(void *)(a1 + 48);
    }

    (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 32LL))(v6, a2);
  }

  if (v12 && __p)
  {
    char v11 = __p;
    operator delete(__p);
  }

  return v5;
}

void sub_1002C081C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  if (a18) {
    sub_1003A6D40((uint64_t)&a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002C0838@<X0>(uint64_t a1@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    sub_1002BF78C(*(_BYTE *)(a1 + 160), &__p);
    uint64_t v7 = v16 >= 0 ? &__p : (void **)__p;
    *(_DWORD *)__int128 buf = 136315138;
    int v20 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#alisha-sm,Processing DCK recovery RQ in state %s",  buf,  0xCu);
    if (v16 < 0) {
      operator delete(__p);
    }
  }

  *(_WORD *)__int128 buf = 0;
  uint64_t result = sub_1002C09A0(a1, 1LL, *a2, buf, (uint64_t)&__p);
  if (v18) {
    int v9 = 0;
  }
  else {
    int v9 = -1004;
  }
  if ((_DWORD)__p) {
    int v10 = (int)__p;
  }
  else {
    int v10 = v9;
  }
  if (v10)
  {
    uint64_t result = sub_1002BFAFC(a1);
    char v11 = 0;
    *(_DWORD *)a3 = v10;
    *(_BYTE *)(a3 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  }

  else
  {
    if (!v18) {
      sub_100006080();
    }
    int v12 = v15;
    uint64_t v13 = v17;
    *(_DWORD *)a3 = 0;
    *(_DWORD *)(a3 + _Block_object_dispose((const void *)(v1 - 112), 8) = v12;
    *(void *)(a3 + 16) = v13;
    char v11 = 1;
  }

  *(_BYTE *)(a3 + 24) = v11;
  return result;
}

uint64_t sub_1002C09A0@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned __int8 *a4@<X3>, uint64_t a5@<X8>)
{
  if ((a2 - 3) <= 0xFDu)
  {
    char v32 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT))
    {
      sub_1003A6D64((uint64_t)v32, buf, v33);
      char v32 = *(os_log_s **)buf;
    }

    if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)__int128 buf = 136315650;
      *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/Proximity/Libraries/AlishaSupport/AlishaStateMachine.cpp";
      __int16 v44 = 1024;
      *(_DWORD *)uint64_t v45 = 611;
      *(_WORD *)&v45[4] = 2080;
      *(void *)&v45[6] = "_processRecoveryRequest";
      _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_INFO,  "#alisha-sm,%s:%d: assertion failure in %s",  buf,  0x1Cu);
    }

    abort();
  }

  switch(*(_BYTE *)(a1 + 160))
  {
    case 0:
    case 1:
    case 4:
      uint64_t result = sub_1002BFAFC(a1);
      int v11 = -3005;
      goto LABEL_30;
    case 2:
      if (!*(void *)(a1 + 152)) {
        goto LABEL_9;
      }
      LOBYTE(v14) = 2;
      goto LABEL_8;
    case 3:
      int v12 = sub_1002C0768(a1, 3LL);
      if (v12)
      {
        int v13 = v12;
        uint64_t result = sub_1002BFAFC(a1);
        *(_DWORD *)a5 = v13;
LABEL_31:
        *(_BYTE *)(a5 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0;
        *(_BYTE *)(a5 + 40) = 0;
        return result;
      }

      int v14 = *(unsigned __int8 *)(a1 + 160);
      if (v14 != 5)
      {
        if (*(void *)(a1 + 152)) {
LABEL_8:
        }
          sub_1002C1B28(a1 + 128, v14, 5);
LABEL_9:
        *(_BYTE *)(a1 + 160) = 5;
      }

uint64_t sub_1002C0E60@<X0>(uint64_t a1@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    sub_1002BF78C(*(_BYTE *)(a1 + 160), &__p);
    uint64_t v7 = v17 >= 0 ? &__p : (void **)__p;
    *(_DWORD *)__int128 buf = 136315138;
    int v23 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#alisha-sm,Processing DCK configurable recovery RQ in state %s",  buf,  0xCu);
    if (v17 < 0) {
      operator delete(__p);
    }
  }

  *(_WORD *)__int128 buf = *((unsigned __int8 *)a2 + 4) | 0x100;
  uint64_t result = sub_1002C09A0(a1, 2LL, *a2, buf, (uint64_t)&__p);
  if (v21) {
    int v9 = 0;
  }
  else {
    int v9 = -1004;
  }
  if ((_DWORD)__p) {
    int v10 = (int)__p;
  }
  else {
    int v10 = v9;
  }
  if (v10)
  {
    uint64_t result = sub_1002BFAFC(a1);
    char v11 = 0;
    *(_DWORD *)a3 = v10;
    *(_BYTE *)(a3 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  }

  else
  {
    if (!v21) {
      sub_100006080();
    }
    if (!v20) {
      sub_1003A6E84();
    }
    char v12 = v19;
    int v13 = v16;
    uint64_t v14 = v18;
    *(_DWORD *)a3 = 0;
    *(_BYTE *)(a3 + _Block_object_dispose((const void *)(v1 - 112), 8) = v12;
    *(_DWORD *)(a3 + 12) = v13;
    *(void *)(a3 + 16) = v14;
    char v11 = 1;
  }

  *(_BYTE *)(a3 + 24) = v11;
  return result;
}

uint64_t sub_1002C0FE8(uint64_t a1, _BYTE *a2)
{
  uint64_t v4 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    sub_1002BF78C(*(_BYTE *)(a1 + 160), __p);
    uint64_t v5 = v15 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)__int128 buf = 136315138;
    char v17 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#alisha-sm,Processing DCK suspend RS in state %s",  buf,  0xCu);
    if (v15 < 0) {
      operator delete(__p[0]);
    }
  }

  char v6 = *(_BYTE *)(a1 + 160);
  switch(v6)
  {
    case 0:
    case 5:
      uint64_t v8 = (os_log_s *)qword_1008000A0;
      a2 = 0LL;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        sub_1002BF78C(v6, __p);
        if (v15 >= 0) {
          int v9 = __p;
        }
        else {
          int v9 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 136315138;
        char v17 = v9;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#alisha-sm,processDCKSuspendRS: ignoring suspend response in state %s",  buf,  0xCu);
        if (v15 < 0) {
          operator delete(__p[0]);
        }
        return 0LL;
      }

      return (uint64_t)a2;
    case 1:
    case 2:
    case 3:
      uint64_t v7 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT)) {
        sub_1003A6F2C(v6, v7);
      }
      return 4294964287LL;
    case 4:
      if (*a2)
      {
        if (*(void *)(a1 + 152)) {
          sub_1002C1B28(a1 + 128, 4, 3);
        }
        a2 = 0LL;
        char v10 = 3;
LABEL_22:
        *(_BYTE *)(a1 + 160) = v10;
        return (uint64_t)a2;
      }

      a2 = (_BYTE *)sub_1002C0768(a1, *(unsigned int *)(a1 + 188));
      if (!(_DWORD)a2)
      {
        int v13 = *(unsigned __int8 *)(a1 + 160);
        if (v13 == 5) {
          return 0LL;
        }
        if (*(void *)(a1 + 152)) {
          sub_1002C1B28(a1 + 128, v13, 5);
        }
        a2 = 0LL;
        char v10 = 5;
        goto LABEL_22;
      }

      uint64_t v12 = qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
        sub_1003A6EAC((int)a2, v12);
      }
      return (uint64_t)a2;
    default:
      return (uint64_t)a2;
  }

void sub_1002C1238(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  char v6 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    sub_1000065CC(v35, off_1007BC0D0[a2]);
    int v7 = SBYTE3(v39);
    uint64_t v8 = *(_BYTE **)v35;
    sub_1002BF78C(*(_BYTE *)(a1 + 160), __p);
    int v9 = v35;
    if (v7 < 0) {
      int v9 = v8;
    }
    if (v41 >= 0) {
      char v10 = __p;
    }
    else {
      char v10 = *(_BYTE **)__p;
    }
    *(_DWORD *)__int128 buf = 136315394;
    int v43 = v9;
    __int16 v44 = 2080;
    uint64_t v45 = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#alisha-sm,Suspend on timeout event %s in state %s",  buf,  0x16u);
    if (v41 < 0) {
      operator delete(*(void **)__p);
    }
    if (SBYTE3(v39) < 0) {
      operator delete(*(void **)v35);
    }
  }

  switch(a2)
  {
    case 0:
      uint64_t v33 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT))
      {
        sub_1003A6FC8((uint64_t)v33, v35, v34);
        uint64_t v33 = *(os_log_s **)v35;
      }

      if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)char v35 = 136315650;
        *(void *)&v35[4] = "/Library/Caches/com.apple.xbs/Sources/Proximity/Libraries/AlishaSupport/AlishaStateMachine.cpp";
        __int16 v36 = 1024;
        int v37 = 543;
        __int16 v38 = 2080;
        uint64_t v39 = "suspendOnTimeout";
        _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_INFO,  "#alisha-sm,%s:%d: assertion failure in %s",  v35,  0x1Cu);
      }

      abort();
    case 1:
      if (*(_BYTE *)(a1 + 160) != 2) {
        goto LABEL_50;
      }
      if (*(void *)(a1 + 152)) {
        sub_1002C1B28(a1 + 128, 2, 5);
      }
LABEL_23:
      *(_BYTE *)(a1 + 160) = 5;
LABEL_24:
      *(_DWORD *)a3 = 0;
      *(_DWORD *)(a3 + 4) = 117440514;
      char v15 = 1;
      *(_WORD *)(a3 + _Block_object_dispose((const void *)(v1 - 112), 8) = 1;
      *(_BYTE *)(a3 + 10) = 0;
      *(_DWORD *)(a3 + 12) = 1;
      goto LABEL_52;
    case 2:
    case 3:
      unsigned int v11 = *(unsigned __int8 *)(a1 + 160);
      if (v11 > 5) {
        goto LABEL_26;
      }
      int v12 = 1 << v11;
      if ((v12 & 0x31) != 0) {
        goto LABEL_50;
      }
      if ((v12 & 6) != 0)
      {
        int v13 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR))
        {
          sub_1002C18FC(a2, v35);
          int v23 = SBYTE3(v39);
          int v24 = *(_BYTE **)v35;
          sub_1002BF78C(*(_BYTE *)(a1 + 160), __p);
          int v25 = v35;
          if (v23 < 0) {
            int v25 = v24;
          }
          if (v41 >= 0) {
            __int16 v26 = __p;
          }
          else {
            __int16 v26 = *(_BYTE **)__p;
          }
          *(_DWORD *)__int128 buf = 136315394;
          int v43 = v25;
          __int16 v44 = 2080;
          uint64_t v45 = v26;
          _os_log_error_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_ERROR,  "#alisha-sm,suspendOnTimeout error: %s event is received but state is %s",  buf,  0x16u);
          if (v41 < 0) {
            operator delete(*(void **)__p);
          }
          if (SBYTE3(v39) < 0) {
LABEL_75:
          }
            operator delete(*(void **)v35);
        }

void sub_1002C18D0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1002C18FC@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_1000065CC(a2, off_1007BC0D0[a1]);
}

uint64_t sub_1002C1910(uint64_t a1)
{
  int v2 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    sub_1002BF78C(*(_BYTE *)(a1 + 160), __p);
    uint64_t v3 = v9 >= 0 ? __p : *(_BYTE **)__p;
    *(_DWORD *)__int128 buf = 136315138;
    int v12 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#alisha-sm,Stop ranging in state %s", buf, 0xCu);
    if (v9 < 0) {
      operator delete(*(void **)__p);
    }
  }

  switch(*(_BYTE *)(a1 + 160))
  {
    case 0:
    case 5:
      goto LABEL_9;
    case 1:
      sub_1002BFAFC(a1);
      goto LABEL_9;
    case 2:
      if (*(void *)(a1 + 152)) {
        sub_1002C1B28(a1 + 128, 2, 5);
      }
      *(_BYTE *)(a1 + 160) = 5;
      goto LABEL_21;
    case 3:
      unsigned int v4 = sub_1002C0768(a1, 3LL);
      if (v4) {
        goto LABEL_16;
      }
      int v5 = *(unsigned __int8 *)(a1 + 160);
      if (v5 != 5)
      {
        if (*(void *)(a1 + 152)) {
          sub_1002C1B28(a1 + 128, v5, 5);
        }
        *(_BYTE *)(a1 + 160) = 5;
      }

uint64_t sub_1002C1B28(uint64_t a1, char a2, char a3)
{
  char v6 = a2;
  char v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    sub_10001EEF0();
  }
  return (*(uint64_t (**)(uint64_t, char *, char *))(*(void *)v3 + 48LL))(v3, &v6, &v5);
}

uint64_t sub_1002C1B68(unsigned int a1)
{
  return (a1 > 5) | (0x18u >> a1) & 1;
}

void *sub_1002C1B84(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  sub_1002C1C3C(a1, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 1);
  a1[3] = 0LL;
  a1[4] = 0LL;
  a1[5] = 0LL;
  sub_1001896FC(a1 + 3, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 1);
  a1[6] = 0LL;
  a1[7] = 0LL;
  a1[8] = 0LL;
  sub_1001309C0(a1 + 6, *(const void **)a4, *(void *)(a4 + 8), *(void *)(a4 + 8) - *(void *)a4);
  return a1;
}

void sub_1002C1C08(_Unwind_Exception *exception_object)
{
  unsigned int v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 32) = v4;
    operator delete(v4);
  }

  char v5 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v5;
    operator delete(v5);
  }

  _Unwind_Resume(exception_object);
}

void *sub_1002C1C3C(void *result, const void *a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    char v6 = result;
    uint64_t result = sub_10018963C(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }

  return result;
}

void sub_1002C1C98(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_1002C1CB4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
}

void sub_1002C1CBC( void *a1, int a2, int a3, const char *a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint8_t buf)
{
}

  ;
}

void *sub_1002C1CDC(int a1, uint64_t a2, ...)
{
  return sub_1002BEFAC(a1, (uint64_t *)va);
}

  ;
}

  ;
}

void *sub_1002C1D0C(uint64_t a1, char *a2, uint64_t a3, ...)
{
  return sub_1000065CC((uint64_t *)va, a2);
}

uint64_t sub_1002C1D18(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6)
{
  uint64_t v11 = sub_10001E914(a1, a2);
  sub_10001E914(v11 + 32, a3);
  uint64_t v12 = a4[1];
  *(void *)(a1 + 64) = *a4;
  *(void *)(a1 + 72) = v12;
  if (v12)
  {
    int v13 = (unint64_t *)(v12 + 8);
    do
      unint64_t v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }

  *(void *)(a1 + 80) = 0LL;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  uint64_t v15 = a5[1];
  *(void *)(a1 + 96) = *a5;
  *(void *)(a1 + 104) = v15;
  if (v15)
  {
    int v16 = (unint64_t *)(v15 + 8);
    do
      unint64_t v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }

  uint64_t v18 = a6[1];
  *(void *)(a1 + 112) = *a6;
  *(void *)(a1 + 120) = v18;
  if (v18)
  {
    int v19 = (unint64_t *)(v18 + 8);
    do
      unint64_t v20 = __ldxr(v19);
    while (__stxr(v20 + 1, v19));
  }

  *(_OWORD *)(a1 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_DWORD *)(a1 + 176) = 1065353216;
  int v21 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003A7068(v21, v22, v23, v24, v25, v26, v27, v28);
  }
  if (!*(void *)(a1 + 24))
  {
    uint64_t v30 = "_constructSessionCallback";
    int v31 = 31;
    goto LABEL_21;
  }

  if (!*(void *)(a1 + 64))
  {
    uint64_t v30 = "_uwbSystem";
    int v31 = 32;
    goto LABEL_21;
  }

  if (!*(void *)(a1 + 96))
  {
    uint64_t v30 = "_paramNegotiator";
    int v31 = 33;
    goto LABEL_21;
  }

  if (!*(void *)(a1 + 112))
  {
    uint64_t v30 = "_rangingLimitManager";
    int v31 = 34;
LABEL_21:
    __assert_rtn("AcwgManager", "AcwgManager.cpp", v31, v30);
  }

  return a1;
}

void sub_1002C1EB0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = (void *)v1[3];
  if (v3 == v1)
  {
    uint64_t v4 = 4LL;
  }

  else
  {
    if (!v3) {
      goto LABEL_6;
    }
    uint64_t v4 = 5LL;
    uint64_t v1 = (void *)v1[3];
  }

  (*(void (**)(void *))(*v1 + 8 * v4))(v1);
LABEL_6:
  _Unwind_Resume(exception_object);
}

void *sub_1002C1F74(void *a1)
{
  int v2 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003A70D8(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  sub_1002C2070(a1);
  sub_100021DA8((uint64_t)(a1 + 18));
  char v10 = (void *)a1[17];
  a1[17] = 0LL;
  if (v10) {
    operator delete(v10);
  }
  uint64_t v11 = (void *)a1[16];
  a1[16] = 0LL;
  if (v11) {
    sub_1002C304C((uint64_t)(a1 + 16), v11);
  }
  sub_100012390((uint64_t)(a1 + 14));
  sub_100012390((uint64_t)(a1 + 12));
  sub_100012390((uint64_t)(a1 + 10));
  sub_100012390((uint64_t)(a1 + 8));
  uint64_t v12 = (void *)a1[7];
  if (v12 == a1 + 4)
  {
    uint64_t v13 = 4LL;
    uint64_t v12 = a1 + 4;
  }

  else
  {
    if (!v12) {
      goto LABEL_12;
    }
    uint64_t v13 = 5LL;
  }

  (*(void (**)(void))(*v12 + 8 * v13))();
LABEL_12:
  unint64_t v14 = (void *)a1[3];
  if (v14 == a1)
  {
    uint64_t v15 = 4LL;
    unint64_t v14 = a1;
    goto LABEL_16;
  }

  if (v14)
  {
    uint64_t v15 = 5LL;
LABEL_16:
    (*(void (**)(void))(*v14 + 8 * v15))();
  }

  return a1;
}

void *sub_1002C2070(void *a1)
{
  int v2 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003A7148(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  uint64_t v11 = (void **)(a1 + 16);
  char v10 = (void *)a1[16];
  if (v10)
  {
    sub_1002BFA18(v10);
    uint64_t v12 = *v11;
    *uint64_t v11 = 0LL;
    if (v12) {
      sub_1002C304C((uint64_t)(a1 + 16), v12);
    }
  }

  if (a1[10])
  {
    sub_1002C21A4((uint64_t)a1, (uint64_t)v18);
    if (v21)
    {
      if (__p)
      {
        unint64_t v20 = __p;
        operator delete(__p);
      }
    }
  }

  uint64_t v13 = (void *)a1[17];
  a1[17] = 0LL;
  if (v13) {
    operator delete(v13);
  }
  sub_100046F88(a1 + 18);
  sub_10015D394(a1 + 8);
  sub_10015D394(a1 + 12);
  sub_10015D394(a1 + 14);
  unint64_t v14 = (void *)a1[3];
  a1[3] = 0LL;
  if (v14 == a1)
  {
    uint64_t v15 = 4LL;
    unint64_t v14 = a1;
  }

  else
  {
    if (!v14) {
      goto LABEL_17;
    }
    uint64_t v15 = 5LL;
  }

  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_17:
  uint64_t result = (void *)a1[7];
  a1[7] = 0LL;
  if (result == a1 + 4)
  {
    uint64_t v17 = 4LL;
    uint64_t result = a1 + 4;
  }

  else
  {
    if (!result) {
      return result;
    }
    uint64_t v17 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v17))();
}

void sub_1002C21A4(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003A71B8(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  uint64_t v14 = *(void *)(a1 + 80);
  uint64_t v13 = (void *)(a1 + 80);
  uint64_t v12 = v14;
  if (v14)
  {
    (*(void (**)(uint64_t))(*(void *)v12 + 32LL))(v12);
    sub_10015D394(v13);
  }

  else
  {
    v15[0] = 0;
    char v18 = 0;
    *(_DWORD *)a2 = 0;
    sub_1002760F0((__n128 *)(a2 + 8), (uint64_t)v15);
    if (v18)
    {
      if (__p)
      {
        uint64_t v17 = __p;
        operator delete(__p);
      }
    }
  }

void sub_1002C2250( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
  if (a16) {
    sub_1003A3CE4((uint64_t)&a9);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002C226C(void *a1)
{
  int v2 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003A7228(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  uint64_t v10 = (void **)(a1 + 16);
  if (!a1[16])
  {
    uint64_t v11 = operator new(0xC0uLL);
    uint64_t v12 = (std::__shared_weak_count *)a1[13];
    uint64_t v49 = a1[12];
    uint64_t v50 = v12;
    if (v12)
    {
      p_shared_owners = (unint64_t *)&v12->__shared_owners_;
      do
        unint64_t v14 = __ldxr(p_shared_owners);
      while (__stxr(v14 + 1, p_shared_owners));
    }

    uint64_t v15 = (std::__shared_weak_count *)a1[15];
    uint64_t v47 = a1[14];
    uint64_t v48 = v15;
    if (v15)
    {
      int v16 = (unint64_t *)&v15->__shared_owners_;
      do
        unint64_t v17 = __ldxr(v16);
      while (__stxr(v17 + 1, v16));
    }

    char v18 = (std::__shared_weak_count *)a1[9];
    uint64_t v45 = a1[8];
    std::stringbuf v46 = v18;
    if (v18)
    {
      int v19 = (unint64_t *)&v18->__shared_owners_;
      do
        unint64_t v20 = __ldxr(v19);
      while (__stxr(v20 + 1, v19));
    }

    uint64_t v43 = 0LL;
    __int16 v44 = 0LL;
    v55[0] = &off_1007BC110;
    v55[1] = a1;
    uint64_t v56 = v55;
    char v21 = operator new(0x20uLL);
    *char v21 = &off_1007BC1A0;
    v21[1] = sub_1002C21A4;
    v21[2] = 0LL;
    v21[3] = a1;
    uint64_t v54 = v21;
    uint64_t v22 = operator new(0x20uLL);
    *uint64_t v22 = &off_1007BC260;
    v22[1] = sub_1002C2678;
    v22[2] = 0LL;
    v22[3] = a1;
    char v52 = v22;
    sub_1002BFA14(v11, &v49, &v47, &v45, &v43, v55, v53, v51);
    uint64_t v23 = v52;
    if (v52 == v51)
    {
      uint64_t v24 = 4LL;
      uint64_t v23 = v51;
    }

    else
    {
      if (!v52) {
        goto LABEL_18;
      }
      uint64_t v24 = 5LL;
    }

    (*(void (**)(void))(*v23 + 8 * v24))();
LABEL_18:
    uint64_t v25 = v54;
    if (v54 == v53)
    {
      uint64_t v26 = 4LL;
      uint64_t v25 = v53;
    }

    else
    {
      if (!v54) {
        goto LABEL_23;
      }
      uint64_t v26 = 5LL;
    }

    (*(void (**)(void))(*v25 + 8 * v26))();
LABEL_23:
    uint64_t v27 = v56;
    if (v56 == v55)
    {
      uint64_t v28 = 4LL;
      uint64_t v27 = v55;
    }

    else
    {
      if (!v56) {
        goto LABEL_28;
      }
      uint64_t v28 = 5LL;
    }

    (*(void (**)(void))(*v27 + 8 * v28))();
LABEL_28:
    int v29 = v44;
    if (v44)
    {
      uint64_t v30 = (unint64_t *)&v44->__shared_owners_;
      do
        unint64_t v31 = __ldaxr(v30);
      while (__stlxr(v31 - 1, v30));
      if (!v31)
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
    }

    char v32 = v46;
    if (v46)
    {
      uint64_t v33 = (unint64_t *)&v46->__shared_owners_;
      do
        unint64_t v34 = __ldaxr(v33);
      while (__stlxr(v34 - 1, v33));
      if (!v34)
      {
        ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
        std::__shared_weak_count::__release_weak(v32);
      }
    }

    char v35 = v48;
    if (v48)
    {
      __int16 v36 = (unint64_t *)&v48->__shared_owners_;
      do
        unint64_t v37 = __ldaxr(v36);
      while (__stlxr(v37 - 1, v36));
      if (!v37)
      {
        ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
        std::__shared_weak_count::__release_weak(v35);
      }
    }

    __int16 v38 = v50;
    if (v50)
    {
      uint64_t v39 = (unint64_t *)&v50->__shared_owners_;
      do
        unint64_t v40 = __ldaxr(v39);
      while (__stlxr(v40 - 1, v39));
      if (!v40)
      {
        ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
        std::__shared_weak_count::__release_weak(v38);
      }
    }

    char v41 = *v10;
    void *v10 = v11;
    if (v41) {
      sub_1002C304C((uint64_t)(a1 + 16), v41);
    }
  }

  if (!a1[17]) {
    a1[17] = operator new(1uLL);
  }
  return 0LL;
}

void sub_1002C2594( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, char a14, uint64_t a15, char a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20, char *a21, char a22, uint64_t a23, uint64_t a24, char *a25)
{
  int v29 = a21;
  if (a21 == v26)
  {
    uint64_t v30 = 4LL;
    int v29 = &a18;
  }

  else
  {
    if (!a21) {
      goto LABEL_6;
    }
    uint64_t v30 = 5LL;
  }

  (*(void (**)(void))(*(void *)v29 + 8 * v30))();
LABEL_6:
  unint64_t v31 = a25;
  if (a25 == &a22)
  {
    uint64_t v32 = 4LL;
    unint64_t v31 = &a22;
  }

  else
  {
    if (!a25) {
      goto LABEL_11;
    }
    uint64_t v32 = 5LL;
  }

  (*(void (**)(char *))(*(void *)v31 + 8 * v32))(v31);
LABEL_11:
  uint64_t v33 = *(void **)(v27 - 48);
  if (v33 == (void *)(v27 - 72))
  {
    uint64_t v34 = 4LL;
    uint64_t v33 = (void *)(v27 - 72);
  }

  else
  {
    if (!v33) {
      goto LABEL_16;
    }
    uint64_t v34 = 5LL;
  }

  (*(void (**)(void))(*v33 + 8 * v34))();
LABEL_16:
  sub_100012390((uint64_t)&a10);
  sub_100012390((uint64_t)&a12);
  sub_100012390((uint64_t)&a14);
  sub_100012390((uint64_t)&a16);
  operator delete(v25);
  _Unwind_Resume(a1);
}

uint64_t sub_1002C2678(uint64_t a1, char a2, char a3)
{
  uint64_t v6 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)unint64_t v14 = 136315138;
    *(void *)&void v14[4] = "_stateChangedHandler";
    _os_log_debug_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "#acwg-mgr,In method: '%s'", v14, 0xCu);
    uint64_t v6 = (os_log_s *)qword_1008000A0;
  }

  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    sub_1002BF78C(a2, v14);
    int v7 = v15;
    uint64_t v8 = *(_BYTE **)v14;
    sub_1002BF78C(a3, __p);
    uint64_t v9 = v14;
    if (v7 < 0) {
      uint64_t v9 = v8;
    }
    if (v13 >= 0) {
      uint64_t v10 = __p;
    }
    else {
      uint64_t v10 = (void **)__p[0];
    }
    *(_DWORD *)__int128 buf = 136315394;
    unint64_t v17 = v9;
    __int16 v18 = 2080;
    int v19 = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#acwg-mgr,State machine state changed handler. Old state: %s. New state: %s",  buf,  0x16u);
    if (v13 < 0) {
      operator delete(__p[0]);
    }
    if (v15 < 0) {
      operator delete(*(void **)v14);
    }
  }

  return sub_1002C1B28(a1 + 32, a2, a3);
}

void sub_1002C2808( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002C282C(uint64_t a1)
{
  int v2 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003A72C0(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  uint64_t v10 = *(void *)(a1 + 128);
  if (!v10) {
    sub_1003A7298();
  }
  int v11 = sub_1002C1910(v10);
  return sub_1002C288C(a1, v11);
}

uint64_t sub_1002C288C(uint64_t a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v2 = sub_1002C5708(*(void *)(a1 + 136), a2);
  if ((v3 & 0xFF000000) == 0) {
    goto LABEL_18;
  }
  if (BYTE4(v2) == 3)
  {
    if ((*(void *)&v3 & 0xFF0000LL) != 0)
    {
      if (BYTE1(v3) < 3u) {
        return 4294967196LL;
      }
      goto LABEL_18;
    }

void sub_1002C29E4(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003A7330(v6, v7, v8, v9, v10, v11, v12, v13);
  }
  unint64_t v14 = operator new(2uLL);
  __int16 v44 = v14;
  *unint64_t v14 = 256;
  uint64_t v45 = v14 + 1;
  std::stringbuf v46 = v14 + 1;
  sub_1002BAB60(v39, (uint64_t)&v44, a2, a2 + 24);
  unint64_t v15 = sub_1002BFC68(*(void *)(a1 + 128), (unsigned __int16 **)v39);
  int v17 = v16;
  int v18 = sub_1002C288C(a1, v15);
  if (v18)
  {
    *(_DWORD *)a3 = v18;
    *(_BYTE *)(a3 + 4) = 0;
    *(_BYTE *)(a3 + 16) = 0;
  }

  else
  {
    if ((*(void *)&v17 & 0xFF0000LL) == 0) {
      sub_100006080();
    }
    unint64_t v19 = HIDWORD(v15);
    unint64_t v20 = HIWORD(v15);
    int v21 = *(_DWORD *)(a2 + 52);
    char v22 = *(_BYTE *)(a2 + 48);
    v35[0] = v19;
    v35[1] = v20;
    int v36 = v21;
    char v37 = v17;
    char v38 = v22;
    sub_1002BFF80(*(void *)(a1 + 128), v35, *(_BYTE *)(a2 + 56), (uint64_t)&v29);
    int v23 = sub_1002C288C(a1, v29);
    if (v23)
    {
      char v24 = 0;
      *(_DWORD *)a3 = v23;
      *(_BYTE *)(a3 + 4) = 0;
    }

    else
    {
      if (!v34) {
        sub_100006080();
      }
      __int16 v25 = v30;
      int v26 = v31;
      char v27 = v32;
      __int16 v28 = v33;
      *(_DWORD *)a3 = 0;
      *(_WORD *)(a3 + 4) = v20;
      *(_BYTE *)(a3 + 6) = v17;
      *(_BYTE *)(a3 + 7) = v27;
      *(_DWORD *)(a3 + _Block_object_dispose((const void *)(v1 - 112), 8) = v26;
      *(_WORD *)(a3 + 12) = v25;
      char v24 = 1;
      *(_WORD *)(a3 + 14) = v28;
    }

    *(_BYTE *)(a3 + 16) = v24;
  }

  if (__p)
  {
    uint64_t v43 = __p;
    operator delete(__p);
  }

  if (v40)
  {
    char v41 = v40;
    operator delete(v40);
  }

  if (v39[0])
  {
    v39[1] = v39[0];
    operator delete(v39[0]);
  }

  if (v44)
  {
    uint64_t v45 = v44;
    operator delete(v44);
  }

void sub_1002C2B94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v7 = *(void **)(v5 - 72);
  if (v7)
  {
    *(void *)(v5 - 64) = v7;
    operator delete(v7);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_1002C2BCC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003A73A0(v6, v7, v8, v9, v10, v11, v12, v13);
  }
  char v14 = *(_BYTE *)(a2 + 8);
  int v15 = *(_DWORD *)(a2 + 4);
  v27[0] = *(_DWORD *)a2;
  v27[1] = v15;
  char v28 = v14;
  sub_1002C0268(*(void *)(a1 + 128), (uint64_t)v27, *(unsigned __int8 *)(a2 + 9) | 0x100, (uint64_t)v22);
  uint64_t result = sub_1002C288C(a1, v22[0]);
  if ((_DWORD)result)
  {
    char v17 = 0;
    *(_DWORD *)a3 = result;
    *(_BYTE *)(a3 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  }

  else
  {
    if (!v26) {
      sub_100006080();
    }
    int v18 = v22[2];
    uint64_t v19 = v23;
    int v20 = v24;
    char v21 = v25;
    *(_DWORD *)a3 = 0;
    *(_DWORD *)(a3 + _Block_object_dispose((const void *)(v1 - 112), 8) = v18;
    *(void *)(a3 + 16) = v19;
    *(_DWORD *)(a3 + 24) = v20;
    *(_BYTE *)(a3 + 2_Block_object_dispose((const void *)(v1 - 112), 8) = v21;
    char v17 = 1;
  }

  *(_BYTE *)(a3 + 32) = v17;
  return result;
}

uint64_t sub_1002C2CA8@<X0>(uint64_t a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v6 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003A7410(v6, v7, v8, v9, v10, v11, v12, v13);
  }
  unsigned int v21 = a2;
  sub_1002C0838(*(void *)(a1 + 128), &v21, (uint64_t)v18);
  uint64_t result = sub_1002C288C(a1, v18[0]);
  if ((_DWORD)result)
  {
    char v15 = 0;
    *(_DWORD *)a3 = result;
    *(_BYTE *)(a3 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  }

  else
  {
    if (!v20) {
      sub_100006080();
    }
    int v16 = v18[2];
    uint64_t v17 = v19;
    *(_DWORD *)a3 = 0;
    *(_DWORD *)(a3 + _Block_object_dispose((const void *)(v1 - 112), 8) = v16;
    *(void *)(a3 + 16) = v17;
    char v15 = 1;
  }

  *(_BYTE *)(a3 + 24) = v15;
  return result;
}

void sub_1002C2D60(uint64_t a1@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003A7480(v6, v7, v8, v9, v10, v11, v12, v13);
  }
  sub_1002B66D8(*(void *)(a1 + 96), a2, a3);
}

uint64_t sub_1002C2DC4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 80);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 16LL))(result);
  }
  return result;
}

uint64_t sub_1002C2DDC(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003A7518(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  uint64_t v10 = *(void *)(a1 + 64);
  if (!v10) {
    sub_1003A74F0();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v10 + 32LL))(v10, a1 + 144);
}

uint64_t sub_1002C2E3C(uint64_t a1, uint64_t a2, int *a3)
{
  unsigned int v17 = a2;
  uint64_t v6 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003A7588(v6, v7, v8, v9, v10, v11, v12, v13);
  }
  (*(void (**)(uint64_t *__return_ptr, void, uint64_t))(**(void **)(a1 + 64) + 24LL))( &v16,  *(void *)(a1 + 64),  a2);
  int v14 = v16;
  if (!(_DWORD)v16)
  {
    sub_1002C3784(a1 + 144, &v17, &v17);
    int v14 = v16;
  }

  *a3 = v14;
  return sub_1002C288C(a1, v14);
}

uint64_t sub_1002C2EDC(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG))
  {
    int v5 = 136315138;
    uint64_t v6 = "handleUWBSystemError";
    _os_log_debug_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "#acwg-mgr,In method: '%s'",  (uint8_t *)&v5,  0xCu);
    uint64_t v2 = (os_log_s *)qword_1008000A0;
  }

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v5) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "#acwg-mgr,handleUWBSystemError",  (uint8_t *)&v5,  2u);
  }

  uint64_t v3 = *(void *)(a1 + 96);
  if (v3) {
    sub_1002B6690(v3);
  }
  sub_100046F88((void *)(a1 + 144));
  return 0LL;
}

void *sub_1002C2FE4@<X0>(int a1@<W0>, void *a2@<X8>)
{
  switch(a1)
  {
    case -103:
      uint64_t v2 = "URSK_UNAVAILABLE";
      break;
    case -102:
      uint64_t v2 = "WRONG_PARAMETERS";
      break;
    case -101:
      uint64_t v2 = "RESOURCE_UNAVAILABLE";
      break;
    case -100:
      uint64_t v2 = "UNKNOWN_ERROR";
      break;
    default:
      uint64_t v2 = "SUCCESS";
      break;
  }

  return sub_1000065CC(a2, v2);
}

void sub_1002C304C(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v3 = (void *)a2[19];
    if (v3 == a2 + 16)
    {
      uint64_t v4 = 4LL;
      uint64_t v3 = a2 + 16;
    }

    else
    {
      if (!v3) {
        goto LABEL_8;
      }
      uint64_t v4 = 5LL;
    }

    (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_8:
    int v5 = (void *)a2[15];
    if (v5 == a2 + 12)
    {
      uint64_t v6 = 4LL;
      int v5 = a2 + 12;
    }

    else
    {
      if (!v5) {
        goto LABEL_13;
      }
      uint64_t v6 = 5LL;
    }

    (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_13:
    uint64_t v7 = (void *)a2[11];
    if (v7 == a2 + 8)
    {
      uint64_t v8 = 4LL;
      uint64_t v7 = a2 + 8;
    }

    else
    {
      if (!v7)
      {
LABEL_18:
        sub_100012390((uint64_t)(a2 + 6));
        sub_100012390((uint64_t)(a2 + 4));
        sub_100012390((uint64_t)(a2 + 2));
        uint64_t v9 = (void *)sub_100012390((uint64_t)a2);
        operator delete(v9);
        return;
      }

      uint64_t v8 = 5LL;
    }

    (*(void (**)(void))(*v7 + 8 * v8))();
    goto LABEL_18;
  }

void *sub_1002C3128(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &off_1007BC110;
  result[1] = v3;
  return result;
}

uint64_t sub_1002C315C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_1007BC110;
  a2[1] = v2;
  return result;
}

void sub_1002C3178(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 8);
  if (!*(void *)(v5 + 24)) {
    sub_1003A75F8();
  }
  uint64_t v7 = *a3;
  uint64_t v8 = (void *)(v5 + 80);
  if (*(void *)(v5 + 80))
  {
    sub_1002C21A4(*(void *)(a1 + 8), (uint64_t)v23);
    if (v26)
    {
      if (__p)
      {
        char v25 = __p;
        operator delete(__p);
      }
    }
  }

  uint64_t v9 = *(void *)(v5 + 24);
  if (!v9) {
    sub_10001EEF0();
  }
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v9 + 48LL))(&v19, v9, a2);
  int v10 = v19;
  if (v22) {
    int v11 = 0;
  }
  else {
    int v11 = -1004;
  }
  if (!(_DWORD)v19) {
    int v10 = v11;
  }
  if (v10)
  {
    *(_DWORD *)a4 = v10;
LABEL_14:
    *(_BYTE *)(a4 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0;
    *(_BYTE *)(a4 + 16) = 0;
    goto LABEL_15;
  }

  if (!v22) {
    sub_100006080();
  }
  sub_100018E60((void *)(v5 + 80), &v20);
  if (!*v8)
  {
    *(_DWORD *)a4 = -1013;
    goto LABEL_14;
  }

  (*(void (**)(void, uint64_t))(*(void *)*v8 + 24LL))(*v8, v7);
  if (*(_DWORD *)a4)
  {
    sub_1002C21A4(v5, (uint64_t)v15);
    if (v18 && v16)
    {
      unsigned int v17 = v16;
      operator delete(v16);
    }
  }

  else
  {
    v15[0] = (*(uint64_t (**)(void))(*(void *)*v8 + 16LL))(*v8);
    sub_1002C33B8(v5 + 144, v15, v15);
  }

void sub_1002C3320( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20, char a21)
{
  if (a21 && a20)
  {
    p_shared_owners = (unint64_t *)&a20->__shared_owners_;
    do
      unint64_t v23 = __ldaxr(p_shared_owners);
    while (__stlxr(v23 - 1, p_shared_owners));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))a20->__on_zero_shared)(a20);
      std::__shared_weak_count::__release_weak(a20);
    }
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1002C3370(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_1002C33AC()
{
}

void *sub_1002C33B8(uint64_t a1, unsigned int *a2, _DWORD *a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = *a2;
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
    }

    else
    {
      unint64_t v3 = ((_DWORD)v7 - 1) & v6;
    }

    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      int v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == (_DWORD)v6) {
              return v10;
            }
          }

          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }

            else
            {
              v11 &= v7 - 1;
            }

            if (v11 != v3) {
              break;
            }
          }

          int v10 = (void *)*v10;
        }

        while (v10);
      }
    }
  }

  int v10 = operator new(0x18uLL);
  void *v10 = 0LL;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1LL;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    sub_100021B74(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }

    else
    {
      unint64_t v3 = ((_DWORD)v7 - 1) & v6;
    }
  }

  uint64_t v18 = *(void *)a1;
  uint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    void *v10 = *v19;
LABEL_38:
    *uint64_t v19 = v10;
    goto LABEL_39;
  }

  void *v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }

    else
    {
      v20 &= v7 - 1;
    }

    uint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }

void sub_1002C35C0(_Unwind_Exception *a1)
{
}

__n128 sub_1002C35DC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &off_1007BC1A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + _Block_object_dispose((const void *)(v1 - 112), 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1002C361C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &off_1007BC1A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + _Block_object_dispose((const void *)(v1 - 112), 8) = result;
  return result;
}

uint64_t sub_1002C3644(void *a1)
{
  uint64_t v1 = a1[2];
  uint64_t v2 = (uint64_t (*)(void *))a1[1];
  unint64_t v3 = (void *)(a1[3] + (v1 >> 1));
  if ((v1 & 1) != 0) {
    uint64_t v2 = *(uint64_t (**)(void *))(*v3 + v2);
  }
  return v2(v3);
}

uint64_t sub_1002C3660(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1002C369C()
{
}

__n128 sub_1002C36B0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &off_1007BC260;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + _Block_object_dispose((const void *)(v1 - 112), 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1002C36F0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &off_1007BC260;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + _Block_object_dispose((const void *)(v1 - 112), 8) = result;
  return result;
}

uint64_t sub_1002C3718(void *a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  uint64_t v3 = a1[2];
  uint64_t v4 = (uint64_t (*)(void *, void, void))a1[1];
  uint64_t v5 = (void *)(a1[3] + (v3 >> 1));
  if ((v3 & 1) != 0) {
    uint64_t v4 = *(uint64_t (**)(void *, void, void))(*v5 + v4);
  }
  return v4(v5, *a2, *a3);
}

uint64_t sub_1002C373C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1002C3778()
{
}

void *sub_1002C3784(uint64_t a1, unsigned int *a2, _DWORD *a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = *a2;
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
    }

    else
    {
      unint64_t v3 = ((_DWORD)v7 - 1) & v6;
    }

    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      int v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == (_DWORD)v6) {
              return v10;
            }
          }

          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }

            else
            {
              v11 &= v7 - 1;
            }

            if (v11 != v3) {
              break;
            }
          }

          int v10 = (void *)*v10;
        }

        while (v10);
      }
    }
  }

  int v10 = operator new(0x18uLL);
  void *v10 = 0LL;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1LL;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    sub_100021B74(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }

    else
    {
      unint64_t v3 = ((_DWORD)v7 - 1) & v6;
    }
  }

  uint64_t v18 = *(void *)a1;
  uint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    void *v10 = *v19;
LABEL_38:
    *uint64_t v19 = v10;
    goto LABEL_39;
  }

  void *v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }

    else
    {
      v20 &= v7 - 1;
    }

    uint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }

void sub_1002C398C(_Unwind_Exception *a1)
{
}

uint64_t sub_1002C39A0(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 24))
  {
    uint64_t v2 = *(void **)a1;
    if (*(void *)a1)
    {
      *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v2;
      operator delete(v2);
    }
  }

  return a1;
}

uint64_t sub_1002C39D8( uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8, void *a9)
{
  uint64_t v16 = sub_10001E914(a1, a2);
  sub_10001E914(v16 + 32, a3);
  uint64_t v17 = a4[1];
  *(void *)(a1 + 64) = *a4;
  *(void *)(a1 + 72) = v17;
  if (v17)
  {
    uint64_t v18 = (unint64_t *)(v17 + 8);
    do
      unint64_t v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
  }

  *(void *)(a1 + 80) = 0LL;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  uint64_t v20 = a5[1];
  *(void *)(a1 + 96) = *a5;
  *(void *)(a1 + 104) = v20;
  if (v20)
  {
    unsigned int v21 = (unint64_t *)(v20 + 8);
    do
      unint64_t v22 = __ldxr(v21);
    while (__stxr(v22 + 1, v21));
  }

  uint64_t v23 = a6[1];
  *(void *)(a1 + 112) = *a6;
  *(void *)(a1 + 120) = v23;
  if (v23)
  {
    int v24 = (unint64_t *)(v23 + 8);
    do
      unint64_t v25 = __ldxr(v24);
    while (__stxr(v25 + 1, v24));
  }

  uint64_t v26 = a7[1];
  *(void *)(a1 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = *a7;
  *(void *)(a1 + 136) = v26;
  if (v26)
  {
    char v27 = (unint64_t *)(v26 + 8);
    do
      unint64_t v28 = __ldxr(v27);
    while (__stxr(v28 + 1, v27));
  }

  uint64_t v29 = a8[1];
  *(void *)(a1 + 144) = *a8;
  *(void *)(a1 + 152) = v29;
  if (v29)
  {
    __int16 v30 = (unint64_t *)(v29 + 8);
    do
      unint64_t v31 = __ldxr(v30);
    while (__stxr(v31 + 1, v30));
  }

  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  uint64_t v32 = a9[1];
  *(void *)(a1 + 216) = *a9;
  *(_DWORD *)(a1 + 20_Block_object_dispose((const void *)(v1 - 112), 8) = 1065353216;
  *(void *)(a1 + 224) = v32;
  if (v32)
  {
    __int16 v33 = (unint64_t *)(v32 + 8);
    do
      unint64_t v34 = __ldxr(v33);
    while (__stxr(v34 + 1, v33));
  }

  if (!*(void *)(a1 + 24))
  {
    int v36 = "_constructSessionCallback";
    int v37 = 34;
    goto LABEL_30;
  }

  if (!*(void *)(a1 + 64))
  {
    int v36 = "_system";
    int v37 = 35;
    goto LABEL_30;
  }

  if (!*(void *)(a1 + 96))
  {
    int v36 = "_dckCoder";
    int v37 = 36;
    goto LABEL_30;
  }

  if (!*(void *)(a1 + 112))
  {
    int v36 = "_paramNegotiator";
    int v37 = 37;
    goto LABEL_30;
  }

  if (!*(void *)(a1 + 128))
  {
    int v36 = "_rangingLimitManager";
    int v37 = 38;
LABEL_30:
    __assert_rtn("AlishaManager", "AlishaManager.cpp", v37, v36);
  }

  return a1;
}

void sub_1002C3BE4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  float v12 = (void *)v10[3];
  if (v12 == v10)
  {
    uint64_t v13 = 4LL;
  }

  else
  {
    if (!v12) {
      goto LABEL_6;
    }
    uint64_t v13 = 5LL;
    int v10 = (void *)v10[3];
  }

  (*(void (**)(void *))(*v10 + 8 * v13))(v10);
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002C3CC4( uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6, void *a7, void *a8, void *a9)
{
  return sub_1002C39D8(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

void *sub_1002C3CD0(void *a1)
{
  uint64_t v2 = (void *)a1[21];
  a1[21] = 0LL;
  if (v2) {
    operator delete(v2);
  }
  unint64_t v3 = (void *)a1[20];
  a1[20] = 0LL;
  if (v3) {
    sub_1002C304C((uint64_t)(a1 + 20), v3);
  }
  sub_100012390((uint64_t)(a1 + 18));
  sub_100012390((uint64_t)(a1 + 16));
  sub_100012390((uint64_t)(a1 + 14));
  sub_100012390((uint64_t)(a1 + 12));
  sub_100012390((uint64_t)(a1 + 10));
  sub_100012390((uint64_t)(a1 + 8));
  uint64_t v4 = (void *)a1[7];
  if (v4 == a1 + 4)
  {
    uint64_t v5 = 4LL;
    uint64_t v4 = a1 + 4;
  }

  else
  {
    if (!v4) {
      goto LABEL_10;
    }
    uint64_t v5 = 5LL;
  }

  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_10:
  unint64_t v6 = (void *)a1[3];
  if (v6 == a1)
  {
    uint64_t v7 = 4LL;
    unint64_t v6 = a1;
    goto LABEL_14;
  }

  if (v6)
  {
    uint64_t v7 = 5LL;
LABEL_14:
    (*(void (**)(void))(*v6 + 8 * v7))();
  }

  return a1;
}

void *sub_1002C3DB8(void *a1)
{
  unint64_t v3 = a1 + 20;
  uint64_t v2 = (void *)a1[20];
  if (v2)
  {
    sub_1002BFA18(v2);
    uint64_t v4 = (void *)*v3;
    *unint64_t v3 = 0LL;
    if (v4) {
      sub_1002C304C((uint64_t)v3, v4);
    }
  }

  if (a1[10])
  {
    sub_1002C3EDC((uint64_t)a1, (uint64_t)v10);
    if (v13)
    {
      if (__p)
      {
        float v12 = __p;
        operator delete(__p);
      }
    }
  }

  uint64_t v5 = (void *)a1[21];
  a1[21] = 0LL;
  if (v5) {
    operator delete(v5);
  }
  sub_100046F88(a1 + 22);
  sub_10015D394(a1 + 8);
  sub_10015D394(a1 + 12);
  sub_10015D394(a1 + 14);
  sub_10015D394(a1 + 16);
  sub_10015D394(a1 + 18);
  sub_10015D394(a1 + 27);
  unint64_t v6 = (void *)a1[3];
  a1[3] = 0LL;
  if (v6 == a1)
  {
    uint64_t v7 = 4LL;
    unint64_t v6 = a1;
  }

  else
  {
    if (!v6) {
      goto LABEL_15;
    }
    uint64_t v7 = 5LL;
  }

  (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_15:
  __n128 result = (void *)a1[7];
  a1[7] = 0LL;
  if (result == a1 + 4)
  {
    uint64_t v9 = 4LL;
    __n128 result = a1 + 4;
  }

  else
  {
    if (!result) {
      return result;
    }
    uint64_t v9 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v9))();
}

void sub_1002C3EDC(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t v3 = (void *)(a1 + 80);
  uint64_t v2 = *(void *)(a1 + 80);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 32LL))(v2);
    sub_10015D394(v3);
  }

  else
  {
    v4[0] = 0;
    char v7 = 0;
    *(_DWORD *)a2 = 0;
    sub_1002760F0((__n128 *)(a2 + 8), (uint64_t)v4);
    if (v7)
    {
      if (__p)
      {
        unint64_t v6 = __p;
        operator delete(__p);
      }
    }
  }

void sub_1002C3F58( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
  if (a16) {
    sub_1003A3CE4((uint64_t)&a9);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002C3F74(void *a1)
{
  uint64_t v2 = a1 + 20;
  if (a1[20]) {
    goto LABEL_51;
  }
  unint64_t v3 = operator new(0xC0uLL);
  uint64_t v4 = (std::__shared_weak_count *)a1[15];
  uint64_t v44 = a1[14];
  uint64_t v45 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      unint64_t v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }

  char v7 = (std::__shared_weak_count *)a1[17];
  uint64_t v42 = a1[16];
  uint64_t v43 = v7;
  if (v7)
  {
    uint8x8_t v8 = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }

  int v10 = (std::__shared_weak_count *)a1[9];
  uint64_t v40 = a1[8];
  char v41 = v10;
  if (v10)
  {
    unint64_t v11 = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }

  char v13 = (std::__shared_weak_count *)a1[28];
  uint64_t v38 = a1[27];
  uint64_t v39 = v13;
  if (v13)
  {
    BOOL v14 = (unint64_t *)&v13->__shared_owners_;
    do
      unint64_t v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
  }

  v50[0] = &off_1007BC2F8;
  v50[1] = a1;
  uint64_t v51 = v50;
  uint64_t v16 = operator new(0x20uLL);
  *uint64_t v16 = &off_1007BC378;
  v16[1] = sub_1002C3EDC;
  void v16[2] = 0LL;
  v16[3] = a1;
  uint64_t v49 = v16;
  uint64_t v17 = operator new(0x20uLL);
  *uint64_t v17 = &off_1007BC428;
  v17[1] = sub_1002C4430;
  v17[2] = 0LL;
  void v17[3] = a1;
  uint64_t v47 = v17;
  sub_1002BFA14(v3, &v44, &v42, &v40, &v38, v50, v48, v46);
  uint64_t v18 = v47;
  if (v47 == v46)
  {
    uint64_t v19 = 4LL;
    uint64_t v18 = v46;
  }

  else
  {
    if (!v47) {
      goto LABEL_19;
    }
    uint64_t v19 = 5LL;
  }

  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_19:
  uint64_t v20 = v49;
  if (v49 == v48)
  {
    uint64_t v21 = 4LL;
    uint64_t v20 = v48;
  }

  else
  {
    if (!v49) {
      goto LABEL_24;
    }
    uint64_t v21 = 5LL;
  }

  (*(void (**)(void))(*v20 + 8 * v21))();
LABEL_24:
  unint64_t v22 = v51;
  if (v51 == v50)
  {
    uint64_t v23 = 4LL;
    unint64_t v22 = v50;
  }

  else
  {
    if (!v51) {
      goto LABEL_29;
    }
    uint64_t v23 = 5LL;
  }

  (*(void (**)(void))(*v22 + 8 * v23))();
LABEL_29:
  int v24 = v39;
  if (v39)
  {
    unint64_t v25 = (unint64_t *)&v39->__shared_owners_;
    do
      unint64_t v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }

  char v27 = v41;
  if (v41)
  {
    unint64_t v28 = (unint64_t *)&v41->__shared_owners_;
    do
      unint64_t v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }

  __int16 v30 = v43;
  if (v43)
  {
    unint64_t v31 = (unint64_t *)&v43->__shared_owners_;
    do
      unint64_t v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }

  __int16 v33 = v45;
  if (v45)
  {
    unint64_t v34 = (unint64_t *)&v45->__shared_owners_;
    do
      unint64_t v35 = __ldaxr(v34);
    while (__stlxr(v35 - 1, v34));
    if (!v35)
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v33);
    }
  }

  int v36 = (void *)*v2;
  void *v2 = v3;
  if (v36) {
    sub_1002C304C((uint64_t)v2, v36);
  }
LABEL_51:
  if (!a1[21]) {
    a1[21] = operator new(1uLL);
  }
  return 0LL;
}

void sub_1002C428C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, std::__shared_weak_count *a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, std::__shared_weak_count *a17, char a18, uint64_t a19, uint64_t a20, char *a21, char a22, uint64_t a23, uint64_t a24, char *a25)
{
  unint64_t v29 = a21;
  if (a21 == v26)
  {
    uint64_t v30 = 4LL;
    unint64_t v29 = &a18;
  }

  else
  {
    if (!a21) {
      goto LABEL_6;
    }
    uint64_t v30 = 5LL;
  }

  (*(void (**)(void))(*(void *)v29 + 8 * v30))();
LABEL_6:
  unint64_t v31 = a25;
  if (a25 == &a22)
  {
    uint64_t v32 = 4LL;
    unint64_t v31 = &a22;
  }

  else
  {
    if (!a25) {
      goto LABEL_11;
    }
    uint64_t v32 = 5LL;
  }

  (*(void (**)(char *))(*(void *)v31 + 8 * v32))(v31);
LABEL_11:
  __int16 v33 = *(void **)(v27 - 48);
  if (v33 == (void *)(v27 - 72))
  {
    uint64_t v34 = 4LL;
    __int16 v33 = (void *)(v27 - 72);
  }

  else
  {
    if (!v33)
    {
LABEL_16:
      if (a11)
      {
        p_shared_owners = (unint64_t *)&a11->__shared_owners_;
        do
          unint64_t v36 = __ldaxr(p_shared_owners);
        while (__stlxr(v36 - 1, p_shared_owners));
        if (!v36)
        {
          ((void (*)(std::__shared_weak_count *))a11->__on_zero_shared)(a11);
          std::__shared_weak_count::__release_weak(a11);
        }
      }

      if (a13)
      {
        int v37 = (unint64_t *)&a13->__shared_owners_;
        do
          unint64_t v38 = __ldaxr(v37);
        while (__stlxr(v38 - 1, v37));
        if (!v38)
        {
          ((void (*)(std::__shared_weak_count *))a13->__on_zero_shared)(a13);
          std::__shared_weak_count::__release_weak(a13);
        }
      }

      if (a15)
      {
        uint64_t v39 = (unint64_t *)&a15->__shared_owners_;
        do
          unint64_t v40 = __ldaxr(v39);
        while (__stlxr(v40 - 1, v39));
        if (!v40)
        {
          ((void (*)(std::__shared_weak_count *))a15->__on_zero_shared)(a15);
          std::__shared_weak_count::__release_weak(a15);
        }
      }

      if (a17)
      {
        char v41 = (unint64_t *)&a17->__shared_owners_;
        do
          unint64_t v42 = __ldaxr(v41);
        while (__stlxr(v42 - 1, v41));
        if (!v42)
        {
          ((void (*)(std::__shared_weak_count *))a17->__on_zero_shared)(a17);
          std::__shared_weak_count::__release_weak(a17);
        }
      }

      operator delete(v25);
      _Unwind_Resume(a1);
    }

    uint64_t v34 = 5LL;
  }

  (*(void (**)(void))(*v33 + 8 * v34))();
  goto LABEL_16;
}

uint64_t sub_1002C4430(uint64_t a1, char a2, char a3)
{
  unint64_t v6 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    sub_1002BF78C(a2, v14);
    int v7 = v15;
    uint8x8_t v8 = (void **)v14[0];
    sub_1002BF78C(a3, __p);
    unint64_t v9 = v14;
    if (v7 < 0) {
      unint64_t v9 = v8;
    }
    if (v13 >= 0) {
      int v10 = __p;
    }
    else {
      int v10 = (void **)__p[0];
    }
    *(_DWORD *)__int128 buf = 136315394;
    uint64_t v17 = v9;
    __int16 v18 = 2080;
    uint64_t v19 = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#alisha-mgr,State machine state changed handler. Old state: %s. New state: %s",  buf,  0x16u);
    if (v13 < 0) {
      operator delete(__p[0]);
    }
    if (v15 < 0) {
      operator delete(v14[0]);
    }
  }

  return sub_1002C1B28(a1 + 32, a2, a3);
}

void sub_1002C456C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002C4590(uint64_t a1@<X0>, _DWORD *a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 160);
  if (!v2) {
    sub_1003A7620();
  }
  uint64_t v4 = sub_1002C1910(v2);
  uint64_t v17 = v4;
  int v18 = v5;
  if ((_DWORD)v4) {
    BOOL v6 = 1;
  }
  else {
    BOOL v6 = (v5 & 0xFF000000) == 0LL;
  }
  if (v6)
  {
    *a2 = v4;
    sub_1002BADE0((uint64_t)(a2 + 2), (uint64_t)&unk_1007FE590);
    return;
  }

  sub_1002BA24C((char *)&v17 + 4, &v13);
  if (v13)
  {
    int v7 = "dckEncodedResult.statusCode == StatusCode::SUCCESS";
    int v8 = 143;
    goto LABEL_20;
  }

  if (!v16)
  {
    int v7 = "dckEncodedResult.payload.has_value()";
    int v8 = 144;
LABEL_20:
    __assert_rtn("stopRanging", "AlishaManager.cpp", v8, v7);
  }

  __int128 __p = 0LL;
  int v10 = 0LL;
  uint64_t v11 = 0LL;
  sub_1001309C0(&__p, v14, (uint64_t)v15, v15 - (_BYTE *)v14);
  char v12 = 1;
  *a2 = 0;
  sub_1002BADE0((uint64_t)(a2 + 2), (uint64_t)&__p);
  if (v12 && __p)
  {
    int v10 = __p;
    operator delete(__p);
  }

  if (v16)
  {
    if (v14)
    {
      char v15 = v14;
      operator delete(v14);
    }
  }

void sub_1002C46B8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, char a18)
{
  if (a13 && __p) {
    operator delete(__p);
  }
  if (a18)
  {
    if (a15) {
      operator delete(a15);
    }
  }

  _Unwind_Resume(exception_object);
}

void sub_1002C4700(uint64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = a1[18];
  if (v6) {
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v6 + 16LL))(v6, a2);
  }
  unint64_t v7 = sub_1002B79EC(a1[12], a2);
  if ((v7 & 0xFF000000000000LL) == 0)
  {
    uint64_t v10 = a1[27];
    if (v10) {
      (*(void (**)(uint64_t, unint64_t))(*(void *)v10 + 56LL))(v10, v7);
    }
    *(_DWORD *)a3 = v7;
    uint64_t v11 = a3 + 8;
    goto LABEL_17;
  }

  if ((v7 & 0xFF00000000LL) != 0x200000000LL)
  {
    uint64_t v12 = a1[27];
    if (v12) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 56LL))(v12, 4294963293LL);
    }
    *(_DWORD *)a3 = -4003;
    uint64_t v11 = a3 + 8;
LABEL_17:
    sub_1002BADE0(v11, (uint64_t)&unk_1007FE590);
    return;
  }

  int v35 = -1000;
  sub_1002BADE0((uint64_t)&v36, (uint64_t)&unk_1007FE590);
  switch(BYTE5(v7))
  {
    case 1:
      sub_1002B96F4(a2, (int *)&v31);
      int v35 = v31;
      if (v34)
      {
        uint64_t v23 = sub_1002BFC68(a1[20], (unsigned __int16 **)&v32);
        LODWORD(v24) = v15;
        int v35 = v23;
        if ((*(void *)&v15 & 0xFF0000LL) != 0)
        {
          sub_1002B7C7C((uint64_t)&v23 + 4, &v26);
          sub_1002C4CF8(&v35, (uint64_t)&v26);
          if (v30)
          {
            if (__p)
            {
              unint64_t v28 = __p;
              operator delete(__p);
            }
          }
        }
      }

      sub_1002BAB08((uint64_t)&v32);
      goto LABEL_47;
    case 2:
    case 4:
    case 6:
    case 0xA:
    case 0xB:
    case 0xC:
    case 0xD:
    case 0xE:
    case 0xF:
    case 0x10:
    case 0x11:
    case 0x13:
    case 0x14:
    case 0x15:
      uint64_t v9 = a1[27];
      if (v9) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v9 + 56LL))(v9, 4294963292LL);
      }
      *(_DWORD *)a3 = -4004;
      sub_1002BADE0(a3 + 8, (uint64_t)&unk_1007FE590);
      if (v38 && (void)v36)
      {
        *((void *)&v36 + 1) = v36;
        operator delete((void *)v36);
      }

      return;
    case 3:
      sub_1002B9D7C(a1[12], a2, v8, (uint64_t)&v26);
      int v35 = v26;
      if (!(_BYTE)v28) {
        goto LABEL_47;
      }
      sub_1002BFF80(a1[20], (unsigned __int16 *)&v26 + 2, 0, (uint64_t)&v23);
      int v35 = v23;
      if (!v25) {
        goto LABEL_47;
      }
      sub_1002B821C((char *)&v23 + 4, &v31);
      goto LABEL_38;
    case 5:
      sub_1002B9E84(a1[12], a2, v8, (uint64_t)&v23);
      int v35 = v23;
      if (!v25) {
        goto LABEL_47;
      }
      sub_1002C0268(a1[20], (uint64_t)&v23 + 4, 0, (uint64_t)&v31);
      int v35 = v31;
      if (!v33) {
        goto LABEL_47;
      }
      sub_1002B86C8((uint64_t)&v32, &v26);
      sub_1002C4CF8(&v35, (uint64_t)&v26);
      if (!v30) {
        goto LABEL_47;
      }
      uint64_t v17 = __p;
      if (!__p) {
        goto LABEL_47;
      }
      unint64_t v28 = __p;
      goto LABEL_41;
    case 7:
      uint64_t v26 = sub_1002B9F90(a1[12], a2, v8);
      LODWORD(__p) = v13;
      int v35 = v26;
      if (!(_BYTE)v13) {
        goto LABEL_47;
      }
      uint64_t v23 = sub_1002C05AC(a1[20], (_DWORD *)&v26 + 1);
      int v35 = v23;
      if ((v23 & 0xFF0000000000LL) == 0) {
        goto LABEL_47;
      }
      sub_1002B90DC((char *)&v23 + 4, &v31);
      goto LABEL_38;
    case 8:
      unint64_t v31 = sub_1002BA044(a1[12], (unsigned __int8 **)a2, v8);
      int v35 = v31;
      if ((v31 & 0xFF0000000000LL) != 0) {
        int v35 = sub_1002C0FE8(a1[20], (_BYTE *)&v31 + 4);
      }
      goto LABEL_47;
    case 9:
      uint64_t v23 = sub_1002BA0D0(a1[12], a2, v8);
      LODWORD(v24) = v16;
      int v35 = v23;
      if (!(_BYTE)v16) {
        goto LABEL_47;
      }
      sub_1002C0838(a1[20], (unsigned int *)&v23 + 1, (uint64_t)&v26);
      int v35 = v26;
      if (!v29) {
        goto LABEL_47;
      }
      sub_1002B9320((uint64_t)&__p, &v31);
      goto LABEL_38;
    case 0x12:
      uint64_t v23 = sub_1002BA184(a1[12], a2, v8);
      uint64_t v24 = v14;
      int v35 = v23;
      if ((v14 & 0xFF00000000LL) == 0) {
        goto LABEL_47;
      }
      sub_1002C0E60(a1[20], (unsigned int *)&v23 + 1, (uint64_t)&v26);
      int v35 = v26;
      if (!v29) {
        goto LABEL_47;
      }
      sub_1002B9490((char *)&__p, &v31);
LABEL_38:
      sub_1002C4CF8(&v35, (uint64_t)&v31);
      if (v33)
      {
        uint64_t v17 = (void *)v32.n128_u64[0];
        if (v32.n128_u64[0])
        {
          v32.n128_u64[1] = v32.n128_u64[0];
LABEL_41:
          operator delete(v17);
        }
      }

void sub_1002C4C6C(_Unwind_Exception *exception_object)
{
  if (*(_BYTE *)(v1 - 56))
  {
    unint64_t v3 = *(void **)(v1 - 80);
    if (v3)
    {
      *(void *)(v1 - 72) = v3;
      operator delete(v3);
    }
  }

  _Unwind_Resume(exception_object);
}

_DWORD *sub_1002C4CF8(_DWORD *a1, uint64_t a2)
{
  *a1 = *(_DWORD *)a2;
  sub_1002C5220((uint64_t)(a1 + 2), (__n128 *)(a2 + 8));
  return a1;
}

void sub_1002C4D28(uint64_t a1@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X2>, _DWORD *a4@<X8>)
{
  uint64_t v8 = *(void *)(a1 + 144);
  if (v8) {
    (*(void (**)(uint64_t, unsigned int *))(*(void *)v8 + 32LL))(v8, a2);
  }
  sub_1002B66D8(*(void *)(a1 + 112), a2, (uint64_t)&v13);
  *a4 = v13;
  sub_1002BADE0((uint64_t)(a4 + 2), (uint64_t)&unk_1007FE590);
  if (v16)
  {
    sub_1002BA700((uint64_t)&v14, &v10);
    *a4 = v10;
    sub_1002C5220((uint64_t)(a4 + 2), &__p);
    if (v12 && __p.n128_u64[0])
    {
      __p.n128_u64[1] = __p.n128_u64[0];
      operator delete((void *)__p.n128_u64[0]);
    }

    int v9 = *(unsigned __int8 *)(a3 + 24);
    *(_OWORD *)a3 = v14;
    *(void *)(a3 + 16) = v15;
    if (!v9) {
      *(_BYTE *)(a3 + 24) = 1;
    }
  }

void sub_1002C4E20(_Unwind_Exception *exception_object)
{
  if (*(_BYTE *)(v1 + 32))
  {
    uint64_t v4 = *v2;
    if (*v2)
    {
      *(void *)(v1 + 16) = v4;
      operator delete(v4);
    }
  }

  _Unwind_Resume(exception_object);
}

void sub_1002C4E44(uint64_t a1@<X0>, int a2@<W1>, _DWORD *a3@<X8>)
{
  *a3 = -1000;
  sub_1002BADE0((uint64_t)(a3 + 2), (uint64_t)&unk_1007FE590);
  if ((a2 - 1) >= 5)
  {
    if (!a2)
    {
      int v10 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#alisha-mgr,SessionRequested timeout received",  buf,  2u);
      }

      *a3 = 0;
    }
  }

  else
  {
    uint64_t v6 = *(void *)(a1 + 160);
    if (!v6) {
      return;
    }
    sub_1002C1238(v6, a2, (uint64_t)&v21);
    int v7 = v21;
    if (!v21)
    {
      *a3 = 0;
      if (!v24) {
        return;
      }
      if (v23 == 1)
      {
        sub_1002BA24C((char *)&v22, buf);
        *a3 = *(_DWORD *)buf;
        sub_1002C5220((uint64_t)(a3 + 2), &__p);
      }

      else
      {
        if (v23) {
          __assert_rtn("processTimeoutEvent", "AlishaManager.cpp", 369, "false");
        }
        sub_1002B8F78(&v22, buf);
        *a3 = *(_DWORD *)buf;
        sub_1002C5220((uint64_t)(a3 + 2), &__p);
      }

      goto LABEL_16;
    }

    uint64_t v8 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR))
    {
      sub_1002C18FC(a2, buf);
      int v11 = __p.n128_i8[15];
      char v12 = *(uint8_t **)buf;
      sub_1002BEFAC(v21, &v15);
      int v13 = buf;
      if (v11 < 0) {
        int v13 = v12;
      }
      if (v17 >= 0) {
        __int128 v14 = &v15;
      }
      else {
        __int128 v14 = v15;
      }
      *(_DWORD *)char v25 = 136315394;
      uint64_t v26 = v13;
      __int16 v27 = 2080;
      unint64_t v28 = v14;
      _os_log_error_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "#alisha-mgr,Processing timeout event %s returned non-successful status code %s",  v25,  0x16u);
      if (v17 < 0) {
        operator delete(v15);
      }
      if (__p.n128_i8[15] < 0) {
        operator delete(*(void **)buf);
      }
      int v7 = v21;
    }

    uint64_t v15 = (void *)sub_1002C5708(*(void *)(a1 + 168), v7);
    int v16 = v9;
    *a3 = (_DWORD)v15;
    if ((v9 & 0xFF000000) != 0)
    {
      sub_1002BA24C((char *)&v15 + 4, buf);
      *a3 = *(_DWORD *)buf;
      sub_1002C5220((uint64_t)(a3 + 2), &__p);
LABEL_16:
      if (v20)
      {
        if (__p.n128_u64[0])
        {
          __p.n128_u64[1] = __p.n128_u64[0];
          operator delete((void *)__p.n128_u64[0]);
        }
      }
    }
  }

void sub_1002C5108( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a2) {
    sub_10000DE88(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002C5174(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 64);
  if (!v2) {
    sub_1003A7648();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v2 + 32LL))(v2, a1 + 176);
}

uint64_t sub_1002C51A0(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#alisha-mgr,handleUWBSystemError", v5, 2u);
  }

  uint64_t v3 = *(void *)(a1 + 112);
  if (v3) {
    sub_1002B6690(v3);
  }
  sub_100046F88((void *)(a1 + 176));
  return 0LL;
}

__n128 sub_1002C5220(uint64_t a1, __n128 *a2)
{
  if (*(unsigned __int8 *)(a1 + 24) == a2[1].n128_u8[8])
  {
    if (*(_BYTE *)(a1 + 24)) {
      result.n128_u64[0] = sub_10011B6E4(a1, a2).n128_u64[0];
    }
  }

  else if (*(_BYTE *)(a1 + 24))
  {
    uint64_t v4 = *(void **)a1;
    if (*(void *)a1)
    {
      *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v4;
      operator delete(v4);
    }

    *(_BYTE *)(a1 + 24) = 0;
  }

  else
  {
    *(void *)a1 = 0LL;
    *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
    *(void *)(a1 + 16) = 0LL;
    __n128 result = *a2;
    *(__n128 *)a1 = *a2;
    *(void *)(a1 + 16) = a2[1].n128_u64[0];
    a2->n128_u64[0] = 0LL;
    a2->n128_u64[1] = 0LL;
    a2[1].n128_u64[0] = 0LL;
    *(_BYTE *)(a1 + 24) = 1;
  }

  return result;
}

void *sub_1002C52AC(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &off_1007BC2F8;
  result[1] = v3;
  return result;
}

uint64_t sub_1002C52E0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_1007BC2F8;
  a2[1] = v2;
  return result;
}

void sub_1002C52FC(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 8);
  if (!*(void *)(v5 + 24)) {
    sub_1003A7670();
  }
  uint64_t v7 = *a3;
  uint64_t v8 = (void *)(v5 + 80);
  if (*(void *)(v5 + 80))
  {
    sub_1002C3EDC(*(void *)(a1 + 8), (uint64_t)v23);
    if (v26)
    {
      if (__p)
      {
        char v25 = __p;
        operator delete(__p);
      }
    }
  }

  uint64_t v9 = *(void *)(v5 + 24);
  if (!v9) {
    sub_10001EEF0();
  }
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v9 + 48LL))(&v19, v9, a2);
  int v10 = v19;
  if (v22) {
    int v11 = 0;
  }
  else {
    int v11 = -1004;
  }
  if (!(_DWORD)v19) {
    int v10 = v11;
  }
  if (v10)
  {
    *(_DWORD *)a4 = v10;
LABEL_14:
    *(_BYTE *)(a4 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0;
    *(_BYTE *)(a4 + 16) = 0;
    goto LABEL_15;
  }

  if (!v22) {
    sub_100006080();
  }
  sub_100018E60((void *)(v5 + 80), &v20);
  if (!*v8)
  {
    *(_DWORD *)a4 = -1013;
    goto LABEL_14;
  }

  (*(void (**)(void, uint64_t))(*(void *)*v8 + 24LL))(*v8, v7);
  if (*(_DWORD *)a4)
  {
    sub_1002C3EDC(v5, (uint64_t)v15);
    if (v18 && v16)
    {
      char v17 = v16;
      operator delete(v16);
    }
  }

  else
  {
    v15[0] = (*(uint64_t (**)(void))(*(void *)*v8 + 16LL))(*v8);
    sub_1002C33B8(v5 + 176, v15, v15);
  }

void sub_1002C54A4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20, char a21)
{
  if (a21 && a20)
  {
    p_shared_owners = (unint64_t *)&a20->__shared_owners_;
    do
      unint64_t v23 = __ldaxr(p_shared_owners);
    while (__stlxr(v23 - 1, p_shared_owners));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))a20->__on_zero_shared)(a20);
      std::__shared_weak_count::__release_weak(a20);
    }
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1002C54F4(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_1002C5530()
{
}

__n128 sub_1002C5544(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &off_1007BC378;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + _Block_object_dispose((const void *)(v1 - 112), 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1002C5584(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &off_1007BC378;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + _Block_object_dispose((const void *)(v1 - 112), 8) = result;
  return result;
}

uint64_t sub_1002C55AC(void *a1)
{
  uint64_t v1 = a1[2];
  uint64_t v2 = (uint64_t (*)(void *))a1[1];
  uint64_t v3 = (void *)(a1[3] + (v1 >> 1));
  if ((v1 & 1) != 0) {
    uint64_t v2 = *(uint64_t (**)(void *))(*v3 + v2);
  }
  return v2(v3);
}

uint64_t sub_1002C55C8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1002C5604()
{
}

__n128 sub_1002C5618(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &off_1007BC428;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + _Block_object_dispose((const void *)(v1 - 112), 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1002C5658(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &off_1007BC428;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + _Block_object_dispose((const void *)(v1 - 112), 8) = result;
  return result;
}

uint64_t sub_1002C5680(void *a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  uint64_t v3 = a1[2];
  uint64_t v4 = (uint64_t (*)(void *, void, void))a1[1];
  uint64_t v5 = (void *)(a1[3] + (v3 >> 1));
  if ((v3 & 1) != 0) {
    uint64_t v4 = *(uint64_t (**)(void *, void, void))(*v5 + v4);
  }
  return v4(v5, *a2, *a3);
}

uint64_t sub_1002C56A4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1002C56E0()
{
}

uint64_t sub_1002C56EC()
{
  return __cxa_atexit((void (*)(void *))sub_1002C39A0, &unk_1007FE590, (void *)&_mh_execute_header);
}

uint64_t sub_1002C5708(uint64_t a1, int a2)
{
  if (a2 <= -3014)
  {
    if ((a2 + 4020) < 0x15)
    {
      uint64_t v3 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        sub_1002BEFAC(a2, v41);
        int v4 = v42;
        uint64_t v5 = (void **)v41[0];
        sub_1002B76DC(255, __p);
        uint64_t v6 = v41;
        if (v4 < 0) {
          uint64_t v6 = v5;
        }
        if (v45 >= 0) {
          uint64_t v7 = __p;
        }
        else {
          uint64_t v7 = *(_BYTE **)__p;
        }
        *(_DWORD *)__int128 buf = 136315394;
        uint64_t v47 = v6;
        __int16 v48 = 2080;
        uint64_t v49 = v7;
        _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "#alisha-dck-evt,Got internal status code %s. Returning DCK sub-event code %s.",  buf,  0x16u);
        if (v45 < 0) {
          operator delete(*(void **)__p);
        }
        if (v42 < 0) {
          operator delete(v41[0]);
        }
      }

      LODWORD(v43) = 0;
      unsigned __int16 v8 = -255;
LABEL_14:
      LODWORD(v9) = v8 | 0x10000;
      goto LABEL_90;
    }

    goto LABEL_83;
  }

  if (a2 <= -2021)
  {
    char v16 = a2 - 59;
    if ((a2 + 3013) <= 0xD)
    {
      if (((1 << v16) & 0x3070) != 0)
      {
        unint64_t v23 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
        {
          sub_1002BEFAC(a2, v41);
          int v24 = v42;
          char v25 = (void **)v41[0];
          sub_1002B7718(4, __p);
          char v26 = v41;
          if (v24 < 0) {
            char v26 = v25;
          }
          if (v45 >= 0) {
            __int16 v27 = __p;
          }
          else {
            __int16 v27 = *(_BYTE **)__p;
          }
          *(_DWORD *)__int128 buf = 136315394;
          uint64_t v47 = v26;
          __int16 v48 = 2080;
          uint64_t v49 = v27;
          _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "#alisha-dck-evt,Got internal status code %s. Returning DCK sub-event code %s.",  buf,  0x16u);
          if (v45 < 0) {
            operator delete(*(void **)__p);
          }
          if (v42 < 0) {
            operator delete(v41[0]);
          }
        }

        LODWORD(v43) = 0;
        unsigned int v22 = 67108866;
        goto LABEL_54;
      }

      if (((1 << v16) & 0x381) != 0)
      {
        char v17 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
        {
          sub_1002BEFAC(a2, v41);
          int v18 = v42;
          uint64_t v19 = (void **)v41[0];
          sub_1002B7718(6, __p);
          uint64_t v20 = v41;
          if (v18 < 0) {
            uint64_t v20 = v19;
          }
          if (v45 >= 0) {
            int v21 = __p;
          }
          else {
            int v21 = *(_BYTE **)__p;
          }
          *(_DWORD *)__int128 buf = 136315394;
          uint64_t v47 = v20;
          __int16 v48 = 2080;
          uint64_t v49 = v21;
          _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "#alisha-dck-evt,Got internal status code %s. Returning DCK sub-event code %s.",  buf,  0x16u);
          if (v45 < 0) {
            operator delete(*(void **)__p);
          }
          if (v42 < 0) {
            operator delete(v41[0]);
          }
        }

        LODWORD(v43) = 0;
        unsigned int v22 = 100663298;
LABEL_54:
        unint64_t v9 = (unint64_t)&_mh_execute_header & 0xFFFFFFFFFFFFLL | v22 | 0x100000000000000LL;
        goto LABEL_90;
      }

      if (a2 == -3012) {
        goto LABEL_72;
      }
    }

void sub_1002C5D90( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002C5DC8(uint64_t a1, char a2, char a3, char a4, uint64_t a5, uint64_t a6)
{
  *(_DWORD *)a1 = 65793;
  *(_BYTE *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 40) = 0;
  *(_BYTE *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_BYTE *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0LL;
  int v12 = (uint64_t *)(a1 + 72);
  *(_BYTE *)(a1 + 80) = 0;
  *(_BYTE *)(a1 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(void *)(a1 + 136) = 0LL;
  *(_BYTE *)(a1 + 144) = 0;
  *(_BYTE *)(a1 + 176) = 0;
  *(_BYTE *)(a1 + 184) = 0;
  *(_BYTE *)(a1 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 376) = 0;
  *(_BYTE *)(a1 + 44_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 512) = 0;
  *(_BYTE *)(a1 + 520) = 0;
  *(void *)(a1 + 544) = 0LL;
  *(_OWORD *)(a1 + 52_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_OWORD *)(a1 + 48_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_DWORD *)(a1 + 504) = 0;
  int v13 = operator new(0x3E0uLL);
  sub_1002E54D0(v13, a5, a6);
  sub_1002AF988(v12, (uint64_t)v13);
  unint64_t v14 = operator new(0x188uLL);
  sub_1002E1828();
  uint64_t v15 = *(void **)(a1 + 136);
  *(void *)(a1 + 136) = v14;
  if (v15) {
    operator delete(v15);
  }
  *(void *)(a1 + 552) = 0x3FB999999999999ALL;
  *(_BYTE *)a1 = a2;
  *(_BYTE *)(a1 + 1) = a3;
  *(_BYTE *)(a1 + 2) = a4;
  sub_1002E73A8(*(void *)(a1 + 72), a4);
  char v16 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    char v17 = "true";
    if (*(_BYTE *)a1) {
      int v18 = "true";
    }
    else {
      int v18 = "false";
    }
    int v19 = *(unsigned __int8 *)(a1 + 2);
    if (*(_BYTE *)(a1 + 1)) {
      uint64_t v20 = "true";
    }
    else {
      uint64_t v20 = "false";
    }
    int v22 = 136315650;
    if (!v19) {
      char v17 = "false";
    }
    unint64_t v23 = v18;
    __int16 v24 = 2080;
    char v25 = v20;
    __int16 v26 = 2080;
    __int16 v27 = v17;
    _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "#sa_algo,SA initialized, batchFilter enabled: %s, rangeFilter enabled: %s, straightPathFilter enabled: %s",  (uint8_t *)&v22,  0x20u);
  }

  return a1;
}

void sub_1002C5FD0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  a9 = (void **)(v9 + 528);
  sub_1002AF8FC(&a9);
  sub_100030A5C(v11);
  int v13 = *(void **)(v9 + 136);
  *(void *)(v9 + 136) = 0LL;
  if (v13) {
    operator delete(v13);
  }
  if (*(_BYTE *)(v9 + 128))
  {
    unint64_t v14 = *(void **)(v9 + 96);
    if (v14)
    {
      *(void *)(v9 + 104) = v14;
      operator delete(v14);
    }
  }

  sub_1002AF988(v10, 0LL);
  _Unwind_Resume(a1);
}

uint64_t sub_1002C6050(uint64_t result, double a2)
{
  *(double *)(result + 552) = a2;
  return result;
}

void sub_1002C6058(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 496);
  if (!v4
    || *(double *)a2 > *(double *)(*(void *)(*(void *)(a1 + 464)
                                             + (((unint64_t)(v4 + *(void *)(a1 + 488) - 1) >> 2) & 0x3FFFFFFFFFFFFFF8LL))
                                 + (((v4 + *(void *)(a1 + 488) - 1) & 0x1F) << 7)))
  {
    int v5 = *(_DWORD *)(a1 + 504);
    *(_DWORD *)(a1 + 504) = *(_DWORD *)(a2 + 80);
    uint64_t v6 = *(void *)(a2 + 88);
    *(_BYTE *)(a1 + 520) = *(_BYTE *)(a2 + 96);
    *(void *)(a1 + 512) = v6;
    double v7 = *(double *)a2;
    if (!*(_BYTE *)(a1 + 32) || *(double *)(a1 + 24) < v7)
    {
      *(double *)(a1 + 24) = v7;
      *(_BYTE *)(a1 + 32) = 1;
    }

    int v8 = *(_DWORD *)(a2 + 80);
    if (v5 == v8) {
      goto LABEL_19;
    }
    if (v8 == 2)
    {
      uint64_t v9 = (os_log_s *)qword_1008000A0;
      if (!os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_19;
      }
      double v13 = *(double *)a2;
      *(_DWORD *)__int128 buf = 134217984;
      *(double *)&uint8_t buf[4] = v13;
      int v11 = "#sa_algo,VIO Tracking State changed to Normal at %f s";
    }

    else if (v8 == 1)
    {
      uint64_t v9 = (os_log_s *)qword_1008000A0;
      if (!os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_19;
      }
      double v12 = *(double *)a2;
      *(_DWORD *)__int128 buf = 134217984;
      *(double *)&uint8_t buf[4] = v12;
      int v11 = "#sa_algo,VIO Tracking State changed to Limited at %f s";
    }

    else
    {
      if (v8) {
        goto LABEL_19;
      }
      uint64_t v9 = (os_log_s *)qword_1008000A0;
      if (!os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_19;
      }
      double v10 = *(double *)a2;
      *(_DWORD *)__int128 buf = 134217984;
      *(double *)&uint8_t buf[4] = v10;
      int v11 = "#sa_algo,VIO Tracking State changed to Not Available at %f s";
    }

    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v11, buf, 0xCu);
LABEL_19:
    sub_1002C655C(a1, a2);
    int v19 = *(_DWORD *)(a2 + 80);
    if (v5 == 2 && v19 != 2)
    {
      uint64_t v20 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "#sa_algo,VIO Tracking not normal anymore - resetting",  buf,  2u);
      }

      if (*(_BYTE *)(a1 + 368))
      {
        int v21 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "#sa_algo,VIO Tracking not normal before the cached measurement can be interpolated - passing the cached meas urement to the range filter without VIO",  buf,  2u);
          if (!*(_BYTE *)(a1 + 368)) {
            sub_100006080();
          }
        }

        sub_1002C68A4(a1, a1 + 184);
      }

      sub_1002C6A40(a1);
      int v19 = *(_DWORD *)(a2 + 80);
    }

    if (v19 == 2)
    {
      if (*(_BYTE *)(a2 + 84))
      {
        int v22 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
        {
          double v23 = *(double *)a2;
          if (*(_BYTE *)(a2 + 85)) {
            __int16 v24 = "YES";
          }
          else {
            __int16 v24 = "NO";
          }
          *(_DWORD *)__int128 buf = 134218498;
          *(double *)&uint8_t buf[4] = v23;
          *(_WORD *)&_BYTE buf[12] = 2080;
          *(void *)&buf[14] = "YES";
          *(_WORD *)&buf[22] = 2080;
          *(void *)&buf[24] = v24;
          _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "#sa_algo,VIO reported relocalization event at %f s, MAJOR: %s, MINOR: %s - resetting",  buf,  0x20u);
        }

        sub_1002C6A40(a1);
      }

      else
      {
        if (*(_BYTE *)(a2 + 85))
        {
          char v25 = (os_log_s *)qword_1008000A0;
          if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
          {
            double v26 = *(double *)a2;
            *(_DWORD *)__int128 buf = 134217984;
            *(double *)&uint8_t buf[4] = v26;
            _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "#sa_algo,VIO reported MINOR relocalization event at %f s",  buf,  0xCu);
          }
        }

        uint64_t v27 = 0LL;
        float32x4_t v28 = *(float32x4_t *)(a2 + 16);
        float32x4_t v29 = *(float32x4_t *)(a2 + 32);
        float32x4_t v30 = *(float32x4_t *)(a2 + 48);
        float32x4_t v31 = *(float32x4_t *)(a2 + 64);
        __int128 v43 = xmmword_10042DB30;
        *(_OWORD *)__n128 __p = xmmword_10042DB40;
        __int128 v45 = xmmword_10042DB50;
        __int128 v46 = xmmword_10042DB60;
        do
        {
          *(float32x4_t *)&buf[v27 * 8] = vmlaq_laneq_f32( vmlaq_laneq_f32( vmlaq_lane_f32( vmulq_n_f32(v28, COERCE_FLOAT(*(_OWORD *)&__p[v27 - 2])),  v29,  (float32x2_t)__p[v27 - 2],  1),  v30,  *(float32x4_t *)&__p[v27 - 2],  2),  v31,  *(float32x4_t *)&__p[v27 - 2],  3);
          v27 += 2LL;
        }

        while (v27 != 8);
        __int128 v32 = *(_OWORD *)buf;
        __int128 v33 = *(_OWORD *)&buf[16];
        __int128 v34 = v48;
        __int128 v35 = v49;
        int v36 = *(_DWORD *)(a2 + 80);
        __int16 v37 = *(_WORD *)(a2 + 84);
        *(void *)__int128 buf = *(void *)a2;
        *(_OWORD *)&uint8_t buf[16] = v32;
        __int128 v48 = v33;
        __int128 v49 = v34;
        __int128 v50 = v35;
        int v51 = v36;
        __int16 v52 = v37;
        char v53 = 0;
        char v54 = 0;
        char v55 = 0;
        char v56 = 0;
        char v57 = 0;
        char v58 = 0;
        *(void *)&double v14 = sub_1002C6AFC((void *)(a1 + 456), (__int128 *)buf).n128_u64[0];
        if (!*(_BYTE *)(a1 + 3))
        {
          sub_1002E56D4(*(void *)(a1 + 72), &v43, *(double *)buf, *((float *)&v50 + 1));
          sub_1002C6BA0(a1 + 80, (uint64_t *)&v43);
          if (__p[0])
          {
            __p[1] = __p[0];
            operator delete(__p[0]);
          }
        }
      }
    }

    sub_1002C6C20(a1, v14, v15, v16, v17, v18);
    sub_1002C728C(a1, v38, v39, v40, v41, v42);
    sub_1002C7950((void *)a1);
    return;
  }

  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
    sub_1003A76C0();
  }
}

void sub_1002C6538( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002C655C(uint64_t result, uint64_t a2)
{
  double v3 = *(double *)a2;
  if (!*(_BYTE *)(result + 48) || v3 - *(double *)(result + 40) >= 0.2)
  {
    *(double *)(result + 40) = v3;
    *(_BYTE *)(result + 4_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
    sub_1001DF764((uint64_t)&v26);
    sub_100046B94(&v26, (uint64_t)"tracking state: ", 16LL);
    uint64_t v4 = *(int *)(a2 + 80);
    sub_100046B94(&v26, (uint64_t)", light intensity ", 18LL);
    if (*(_BYTE *)(a2 + 96))
    {
      uint64_t v5 = v26;
      *(_DWORD *)((char *)&v26 + *(void *)(v26 - 24) + _Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)((_BYTE *)&v26 + *(void *)(v26 - 24) + 8) & 0xFFFFFEFB | 4;
      *(std::locale::__imp **)((char *)&v27.__loc_.__locale_ + *(void *)(v5 - sub_100034A98(v2, *(void **)(v1 + 24)) = (std::locale::__imp *)2;
      std::ostream::operator<<(&v26, *(double *)(a2 + 88));
    }

    else
    {
      sub_100046B94(&v26, (uint64_t)"-", 1LL);
    }

    uint64_t v6 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      double v7 = *(double *)a2;
      std::stringbuf::str(&__p, &v27);
      int v8 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0
         ? &__p
         : (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
      double v9 = *(float *)(a2 + 16);
      double v10 = *(float *)(a2 + 20);
      double v11 = *(float *)(a2 + 24);
      double v12 = *(float *)(a2 + 28);
      double v13 = *(float *)(a2 + 32);
      double v14 = *(float *)(a2 + 36);
      double v15 = *(float *)(a2 + 40);
      double v16 = *(float *)(a2 + 44);
      double v17 = *(float *)(a2 + 48);
      double v18 = *(float *)(a2 + 52);
      double v19 = *(float *)(a2 + 56);
      double v20 = *(float *)(a2 + 60);
      double v21 = *(float *)(a2 + 64);
      double v22 = *(float *)(a2 + 68);
      double v23 = *(float *)(a2 + 72);
      double v24 = *(float *)(a2 + 76);
      *(_DWORD *)__int128 buf = 134222338;
      double v30 = v7;
      __int16 v31 = 2080;
      __int128 v32 = v8;
      __int16 v33 = 2048;
      double v34 = v9;
      __int16 v35 = 2048;
      double v36 = v10;
      __int16 v37 = 2048;
      double v38 = v11;
      __int16 v39 = 2048;
      double v40 = v12;
      __int16 v41 = 2048;
      double v42 = v13;
      __int16 v43 = 2048;
      double v44 = v14;
      __int16 v45 = 2048;
      double v46 = v15;
      __int16 v47 = 2048;
      double v48 = v16;
      __int16 v49 = 2048;
      double v50 = v17;
      __int16 v51 = 2048;
      double v52 = v18;
      __int16 v53 = 2048;
      double v54 = v19;
      __int16 v55 = 2048;
      double v56 = v20;
      __int16 v57 = 2048;
      double v58 = v21;
      __int16 v59 = 2048;
      double v60 = v22;
      __int16 v61 = 2048;
      double v62 = v23;
      __int16 v63 = 2048;
      double v64 = v24;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#sa_algo,Pose timestamp: %f, %s, pose [%3.2f, %3.2f, %3.2f, %3.2f, ...\n \t%3.2f, %3.2f, %3.2f, %3.2f, ...\n \t%3.2f, %3.2f, %3.2f, %3.2f, ... \n \t%3.2f, %3.2f, %3.2f, %3.2f]",  buf,  0xB6u);
    }

    std::streambuf::~streambuf(&v27);
    return std::ios::~ios(&v28);
  }

  return result;
}

void sub_1002C6880(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void sub_1002C68A4(uint64_t a1, uint64_t a2)
{
  double v4 = *(double *)(a2 + 8);
  if (*(_BYTE *)(a1 + 176) && (double v5 = *(double *)(a1 + 168), v4 <= v5))
  {
    double v11 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      double v12 = *(float *)(a2 + 16);
      *(_DWORD *)__int128 buf = 134218496;
      *(double *)&uint8_t buf[4] = v12;
      *(_WORD *)&_BYTE buf[12] = 2048;
      *(double *)&buf[14] = v4;
      *(_WORD *)&buf[22] = 2048;
      double v15 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#sa_algo,Not passing range measurement without VIO to range filter, range: %0.2f m, timestamp: %f s, range filter time: %f s",  buf,  0x20u);
    }
  }

  else
  {
    uint64_t v6 = (_OWORD *)(a1 + 144);
    double v7 = *(float *)(a2 + 16);
    *(void *)__int128 buf = *(void *)(a2 + 8);
    *(double *)&uint8_t buf[8] = v7;
    *(void *)&uint8_t buf[16] = 0x3FB999999999999ALL;
    LODWORD(v15) = 0;
    int v8 = *(unsigned __int8 *)(a1 + 3);
    double v9 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)double v13 = 134218240;
      *(double *)&void v13[4] = v7;
      *(_WORD *)&_OWORD v13[12] = 2048;
      *(double *)&v13[14] = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#sa_algo,Passing range measurement without VIO to range filter, range: %0.2f m, timestamp: %f s",  v13,  0x16u);
    }

    sub_1002E2218(*(void *)(a1 + 136), (double *)buf, v8 != 0, 1, (uint64_t)v13);
    __int128 v10 = *(_OWORD *)&v13[16];
    _OWORD *v6 = *(_OWORD *)v13;
    *(_OWORD *)(a1 + 160) = v10;
    *(_BYTE *)(a1 + 176) = 1;
  }

void sub_1002C6A40(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 368)) {
    *(_BYTE *)(a1 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  }
  uint64_t v2 = *(void ***)(a1 + 464);
  uint64_t v3 = *(void *)(a1 + 472);
  *(void *)(a1 + 496) = 0LL;
  unint64_t v4 = v3 - (void)v2;
  if (v4 >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v5 = *(void *)(a1 + 472);
      uint64_t v2 = (void **)(*(void *)(a1 + 464) + 8LL);
      *(void *)(a1 + 464) = v2;
      unint64_t v4 = v5 - (void)v2;
    }

    while (v4 > 0x10);
  }

  if (v4 >> 3 == 1)
  {
    uint64_t v6 = 16LL;
  }

  else
  {
    if (v4 >> 3 != 2) {
      goto LABEL_10;
    }
    uint64_t v6 = 32LL;
  }

  *(void *)(a1 + 48_Block_object_dispose((const void *)(v1 - 112), 8) = v6;
LABEL_10:
  if (*(_BYTE *)(a1 + 128))
  {
    double v7 = *(void **)(a1 + 96);
    if (v7)
    {
      *(void *)(a1 + 104) = v7;
      operator delete(v7);
    }

    *(_BYTE *)(a1 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  }

  sub_1002E5894(*(void *)(a1 + 72));
  if (*(_BYTE *)(a1 + 448))
  {
    *(_DWORD *)(a1 + 40_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
    if (*(_BYTE *)(a1 + 440)) {
      *(_BYTE *)(a1 + 440) = 0;
    }
  }

__n128 sub_1002C6AFC(void *a1, __int128 *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 4 * (v4 - v5) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_1002CAFE8(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  unint64_t v8 = *(void *)(v5 + ((v7 >> 2) & 0x3FFFFFFFFFFFFFF8LL)) + ((v7 & 0x1F) << 7);
  __int128 v9 = *a2;
  __int128 v10 = a2[1];
  __int128 v11 = a2[3];
  *(_OWORD *)(v8 + 32) = a2[2];
  *(_OWORD *)(v8 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v11;
  *(_OWORD *)unint64_t v8 = v9;
  *(_OWORD *)(v8 + 16) = v10;
  __n128 result = (__n128)a2[4];
  __int128 v13 = a2[5];
  __int128 v14 = a2[7];
  *(_OWORD *)(v8 + 96) = a2[6];
  *(_OWORD *)(v8 + 112) = v14;
  *(__n128 *)(v8 + 64) = result;
  *(_OWORD *)(v8 + 80) = v13;
  ++a1[5];
  return result;
}

uint64_t sub_1002C6BA0(uint64_t a1, uint64_t *a2)
{
  if (*(_BYTE *)(a1 + 48))
  {
    uint64_t v4 = *(void **)(a1 + 16);
    if (v4)
    {
      *(void *)(a1 + 24) = v4;
      operator delete(v4);
    }

    *(_BYTE *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  }

  uint64_t v5 = *a2;
  *(void *)(a1 + 5) = *(uint64_t *)((char *)a2 + 5);
  *(void *)a1 = v5;
  *(void *)(a1 + 24) = 0LL;
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  *(_OWORD *)(a1 + 16) = *((_OWORD *)a2 + 1);
  *(void *)(a1 + 32) = a2[4];
  a2[3] = 0LL;
  a2[4] = 0LL;
  a2[2] = 0LL;
  *(void *)(a1 + 40) = a2[5];
  *(_BYTE *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
  return a1;
}

void sub_1002C6C20(uint64_t a1, double a2, double a3, double a4, double a5, double a6)
{
  if (!*(_BYTE *)(a1 + 448)) {
    return;
  }
  if (*(_DWORD *)(a1 + 408) != 1) {
    return;
  }
  uint64_t v7 = *(void *)(a1 + 496);
  if (!v7) {
    return;
  }
  unint64_t v8 = *(void *)(a1 + 488);
  unint64_t v9 = v8 >> 5;
  uint64_t v11 = *(void *)(a1 + 464);
  uint64_t v10 = *(void *)(a1 + 472);
  double v12 = (char *)(v11 + 8 * (v8 >> 5));
  if (v10 == v11)
  {
    uint64_t v13 = 0LL;
    unint64_t v16 = 0LL;
    double v15 = (char *)(v11 + 8 * ((v8 + v7) >> 5));
  }

  else
  {
    uint64_t v13 = *(void *)v12 + ((*(void *)(a1 + 488) & 0x1FLL) << 7);
    char v14 = v8 + v7;
    double v15 = (char *)(v11 + 8 * ((v8 + v7) >> 5));
    unint64_t v16 = *(void *)v15 + ((unint64_t)(v14 & 0x1F) << 7);
  }

  double v18 = *(double *)(a1 + 376);
  double v17 = *(double *)(a1 + 384);
  double v19 = *(double *)(a1 + 392);
  double v20 = *(double *)(a1 + 400);
  *(void *)__int128 buf = v11 + 8 * (v8 >> 5);
  *(void *)&uint8_t buf[8] = v13;
  if (v16 != v13)
  {
    uint64_t v21 = ((uint64_t)(v16 - *(void *)v15) >> 7) + 4 * (v15 - v12);
    uint64_t v22 = v13 - *(void *)v12;
    unint64_t v23 = v21 - (v22 >> 7);
    if (v21 != v22 >> 7)
    {
      do
      {
        unint64_t v24 = v23 >> 1;
        char v25 = sub_1002CBE78((uint64_t)buf, v23 >> 1);
        if (v18 >= *v26)
        {
          std::stringbuf v27 = v26 + 16;
          if ((double *)((char *)v26 - *v25 + 128) == (double *)4096)
          {
            uint64_t v28 = (double *)v25[1];
            ++v25;
            std::stringbuf v27 = v28;
          }

          *(void *)__int128 buf = v25;
          *(void *)&uint8_t buf[8] = v27;
          unint64_t v24 = v23 + ~v24;
        }

        unint64_t v23 = v24;
      }

      while (v24);
      double v12 = *(char **)buf;
      uint64_t v13 = *(void *)&buf[8];
      unint64_t v8 = *(void *)(a1 + 488);
      uint64_t v11 = *(void *)(a1 + 464);
      uint64_t v10 = *(void *)(a1 + 472);
      unint64_t v9 = v8 >> 5;
    }
  }

  if (v10 == v11)
  {
    if (v13)
    {
      uint64_t v30 = 0LL;
      uint64_t v29 = *(void *)(a1 + 496);
      goto LABEL_20;
    }

void sub_1002C728C(uint64_t a1, double a2, double a3, double a4, double a5, double a6)
{
  if (!*(_BYTE *)(a1 + 368)) {
    return;
  }
  uint64_t v7 = *(void *)(a1 + 496);
  if (!v7) {
    return;
  }
  unint64_t v8 = *(void *)(a1 + 488);
  unint64_t v9 = v8 >> 5;
  uint64_t v11 = *(void *)(a1 + 464);
  uint64_t v10 = *(void *)(a1 + 472);
  double v12 = (char *)(v11 + 8 * (v8 >> 5));
  if (v10 == v11)
  {
    uint64_t v13 = 0LL;
    unint64_t v16 = 0LL;
    double v15 = (char *)(v11 + 8 * ((v8 + v7) >> 5));
  }

  else
  {
    uint64_t v13 = *(void *)v12 + ((*(void *)(a1 + 488) & 0x1FLL) << 7);
    char v14 = v8 + v7;
    double v15 = (char *)(v11 + 8 * ((v8 + v7) >> 5));
    unint64_t v16 = *(void *)v15 + ((unint64_t)(v14 & 0x1F) << 7);
  }

  double v17 = *(double *)(a1 + 192);
  float v18 = *(float *)(a1 + 200);
  *(void *)__int128 buf = v11 + 8 * (v8 >> 5);
  *(void *)&uint8_t buf[8] = v13;
  if (v16 != v13)
  {
    uint64_t v19 = ((uint64_t)(v16 - *(void *)v15) >> 7) + 4 * (v15 - v12);
    uint64_t v20 = v13 - *(void *)v12;
    unint64_t v21 = v19 - (v20 >> 7);
    if (v19 != v20 >> 7)
    {
      do
      {
        unint64_t v22 = v21 >> 1;
        unint64_t v23 = sub_1002CBE78((uint64_t)buf, v21 >> 1);
        if (v17 >= *v24)
        {
          char v25 = v24 + 16;
          if ((double *)((char *)v24 - *v23 + 128) == (double *)4096)
          {
            uint64_t v26 = (double *)v23[1];
            ++v23;
            char v25 = v26;
          }

          *(void *)__int128 buf = v23;
          *(void *)&uint8_t buf[8] = v25;
          unint64_t v22 = v21 + ~v22;
        }

        unint64_t v21 = v22;
      }

      while (v22);
      double v12 = *(char **)buf;
      uint64_t v13 = *(void *)&buf[8];
      unint64_t v8 = *(void *)(a1 + 488);
      uint64_t v11 = *(void *)(a1 + 464);
      uint64_t v10 = *(void *)(a1 + 472);
      unint64_t v9 = v8 >> 5;
    }
  }

  if (v10 == v11)
  {
    if (v13)
    {
      uint64_t v28 = 0LL;
      uint64_t v27 = *(void *)(a1 + 496);
LABEL_19:
      if (v28 == v13)
      {
        double v36 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v37 = *(void *)(*(void *)(v11 + (((v8 + v27 - 1) >> 2) & 0x3FFFFFFFFFFFFFF8LL))
                          + (((v8 + v27 - 1) & 0x1F) << 7));
          *(_DWORD *)__int128 buf = 134218240;
          *(double *)&uint8_t buf[4] = v17;
          *(_WORD *)&_BYTE buf[12] = 2048;
          *(void *)&buf[14] = v37;
          _os_log_debug_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEBUG,  "#sa_algo,Measurement at %f s later than the last pose in history at %f s - skipping interpolation",  buf,  0x16u);
        }
      }

      else
      {
        uint64_t v29 = v13 - *(void *)v12;
        uint64_t v30 = v29 >> 7;
        if (v29 < 129)
        {
          unint64_t v38 = 32 - v30;
          uint64_t v32 = &v12[-8 * (v38 >> 5)];
          uint64_t v33 = *(void *)v32;
          uint64_t v34 = ~(_DWORD)v38 & 0x1FLL;
        }

        else
        {
          unint64_t v31 = v30 - 1;
          uint64_t v32 = &v12[8 * (v31 >> 5)];
          uint64_t v33 = *(void *)v32;
          uint64_t v34 = v31 & 0x1F;
        }

        uint64_t v39 = v33 + (v34 << 7);
        float v40 = (v17 - *(double *)v39) / (*(double *)v13 - *(double *)v39);
        float32x4_t v66 = *(float32x4_t *)(v39 + 64);
        float v68 = v40;
        *(double *)v41.i64 = sub_1002C94C0( *(int8x16_t *)(v39 + 16),  *(int8x16_t *)(v39 + 32),  *(__n128 *)(v39 + 48),  *(double *)(v39 + 64),  a6);
        float32x4_t v64 = v41;
        float32x4_t v65 = *(float32x4_t *)(v13 + 64);
        *(double *)v43.i64 = sub_1002C94C0( *(int8x16_t *)(v13 + 16),  *(int8x16_t *)(v13 + 32),  *(__n128 *)(v13 + 48),  *(double *)(v13 + 64),  v42);
        float32x4_t v44 = vmulq_f32(v64, v43);
        float32x4_t v45 = (float32x4_t)vextq_s8((int8x16_t)v44, (int8x16_t)v44, 8uLL);
        *(float32x2_t *)v44.f32 = vadd_f32(*(float32x2_t *)v44.f32, *(float32x2_t *)v45.f32);
        v44.f32[0] = vaddv_f32(*(float32x2_t *)v44.f32);
        v45.i32[0] = 0;
        sub_1002CABC0( v64,  (float32x4_t)vbslq_s8( (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vcgeq_f32(v44, v45)), 0),  (int8x16_t)vnegq_f32(v43),  (int8x16_t)v43),  v68);
        int8x16_t v46 = (int8x16_t)vmlaq_n_f32(v66, vsubq_f32(v65, v66), v68);
        double v47 = *(float *)v46.i32;
        double v49 = *(float *)v48.i32;
        float64x2_t v67 = vcvtq_f64_f32((float32x2_t)vext_s8( *(int8x8_t *)v48.i8,  (int8x8_t)*(_OWORD *)&vextq_s8(v48, v48, 8uLL),  4uLL));
        float64x2_t v69 = vcvtq_f64_f32((float32x2_t)*(_OWORD *)&vextq_s8(v46, v46, 4uLL));
        double v50 = *(float *)&v48.i32[3];
        __int16 v51 = (os_log_s *)qword_1008000A0;
        double v52 = v18;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 134220032;
          *(double *)&uint8_t buf[4] = v52;
          *(_WORD *)&_BYTE buf[12] = 2048;
          *(double *)&buf[14] = v17;
          *(_WORD *)&buf[22] = 2048;
          double v76 = v47;
          __int16 v77 = 2048;
          float64_t v78 = v69.f64[0];
          __int16 v79 = 2048;
          float64_t v80 = v69.f64[1];
          __int16 v81 = 2048;
          double v82 = v49;
          __int16 v83 = 2048;
          float64_t v84 = v67.f64[0];
          __int16 v85 = 2048;
          float64_t v86 = v67.f64[1];
          __int16 v87 = 2048;
          double v88 = v50;
          _os_log_impl( (void *)&_mh_execute_header,  v51,  OS_LOG_TYPE_DEFAULT,  "#sa_algo,Passing range measurement to batch filter and range filter, range: %0.2f m, timestamp: %f s, device position:[%0.2f,%0.2f,%0.2f], device quat:[%0.2f,%0.2f,%0.2f,%0.2f]",  buf,  0x5Cu);
        }

        *(double *)__int128 buf = v17;
        *(double *)&uint8_t buf[8] = v52;
        *(void *)&uint8_t buf[16] = 0x3FB999999999999ALL;
        LODWORD(v76) = 0;
        LOBYTE(v77) = 0;
        BYTE4(v8_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
        float64x2_t v90 = v69;
        double v89 = v47;
        double v91 = v49;
        float64x2_t v92 = v67;
        double v93 = v50;
        if (*(_BYTE *)(a1 + 176))
        {
          char v53 = v17 - *(double *)(a1 + 168) <= 2.0;
          double v54 = *(double *)(a1 + 152);
        }

        else
        {
          char v53 = 0;
          double v54 = 0.0;
        }

        sub_1002E73B0(*(void *)(a1 + 72), v53, v54);
        sub_1002CAD1C(v70, (uint64_t *)(a1 + 80));
        sub_1002E73BC(*(void *)(a1 + 72), (uint64_t)buf, v74);
        sub_1002C6BA0(a1 + 80, (uint64_t *)v74);
        if (*(void *)&v74[16])
        {
          *(void *)&v74[24] = *(void *)&v74[16];
          operator delete(*(void **)&v74[16]);
        }

        sub_1002E182C(*(void *)(a1 + 136), (uint64_t)buf, (uint64_t)v74);
        if (*(_BYTE *)(a1 + 176)) {
          *(_BYTE *)(a1 + 176) = 0;
        }
        __int128 v55 = *(_OWORD *)&v74[16];
        *(_OWORD *)(a1 + 144) = *(_OWORD *)v74;
        *(_OWORD *)(a1 + 160) = v55;
        *(_BYTE *)(a1 + 176) = 1;
        if (!v73) {
          goto LABEL_41;
        }
        if (!*(_BYTE *)(a1 + 128)) {
          sub_100006080();
        }
        if (v70[0] != *(_DWORD *)(a1 + 80)) {
LABEL_41:
        }
          sub_1002CA3A0(a1);
        uint64_t v56 = *(void *)(a1 + 464);
        float v57 = (char *)(v56 + 8LL * (*(void *)(a1 + 488) >> 5));
        if (*(void *)(a1 + 472) == v56) {
          uint64_t v58 = 0LL;
        }
        else {
          uint64_t v58 = *(void *)v57 + ((*(void *)(a1 + 488) & 0x1FLL) << 7);
        }
        sub_1002CA580((void *)(a1 + 456), v57, v58, v32, v39);
        __int128 v59 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v60 = *(void *)(a1 + 464);
          uint64_t v61 = *(void *)(*(void *)(v60 + ((*(void *)(a1 + 488) >> 2) & 0x3FFFFFFFFFFFFFF8LL))
                          + ((*(void *)(a1 + 488) & 0x1FLL) << 7));
          uint64_t v62 = *(void *)(*(void *)(v60
          *(_DWORD *)uint64_t v74 = 134218240;
          *(void *)&v74[4] = v61;
          *(_WORD *)&v74[12] = 2048;
          *(void *)&v74[14] = v62;
          _os_log_debug_impl( (void *)&_mh_execute_header,  v59,  OS_LOG_TYPE_DEBUG,  "#sa_algo,Pose history now between %f s and %f s",  v74,  0x16u);
        }

        if (*(_BYTE *)(a1 + 368)) {
          *(_BYTE *)(a1 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
        }
        if (v73)
        {
          if (v71)
          {
            uint64_t v72 = v71;
            operator delete(v71);
          }
        }
      }

      return;
    }
  }

  else if (*(void *)(v11 + 8 * v9) + ((v8 & 0x1F) << 7) != v13)
  {
    uint64_t v27 = *(void *)(a1 + 496);
    uint64_t v28 = *(void *)(v11 + (((v27 + v8) >> 2) & 0x3FFFFFFFFFFFFFF8LL)) + (((v27 + v8) & 0x1F) << 7);
    goto LABEL_19;
  }

  uint64_t v35 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR))
  {
    uint64_t v63 = *(void *)(*(void *)(v11 + 8 * v9) + ((v8 & 0x1F) << 7));
    *(_DWORD *)__int128 buf = 134218240;
    *(double *)&uint8_t buf[4] = v17;
    *(_WORD *)&_BYTE buf[12] = 2048;
    *(void *)&buf[14] = v63;
    _os_log_error_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_ERROR,  "#sa_algo,Measurement at %f s earlier than the first pose in history at %f s - skipping interpolation and removing range measurement",  buf,  0x16u);
  }

  if (*(_BYTE *)(a1 + 368)) {
    *(_BYTE *)(a1 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  }
}

void sub_1002C7900( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p, uint64_t a21, uint64_t a22, uint64_t a23, char a24, uint64_t a25, uint64_t a26, void *a27, uint64_t a28)
{
  if (a24)
  {
    if (__p) {
      operator delete(__p);
    }
  }

  _Unwind_Resume(exception_object);
}

void sub_1002C7950(void *a1)
{
  uint64_t v1 = a1[62];
  if (v1)
  {
    unint64_t v3 = a1[61];
    uint64_t v4 = a1[58];
    unint64_t v5 = v3 >> 5;
    if (v6 > 5.0)
    {
      uint64_t v7 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t v33 = 134217984;
        *(double *)&_DWORD v33[4] = v6;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "#sa_algo,Pose history spans %f s - pruning down past poses from history",  v33,  0xCu);
        unint64_t v3 = a1[61];
        uint64_t v1 = a1[62];
        uint64_t v4 = a1[58];
        unint64_t v5 = v3 >> 5;
      }

      unint64_t v8 = v3 + v1;
      unint64_t v9 = v3 + v1 - 1;
      uint64_t v10 = *(void *)(v4 + ((v9 >> 2) & 0x3FFFFFFFFFFFFFF8LL));
      unint64_t v11 = (v9 & 0x1F) << 7;
      double v12 = (char *)(v4 + 8 * v5);
      uint64_t v13 = a1[59];
      if (v13 == v4)
      {
        uint64_t v14 = 0LL;
        unint64_t v16 = 0LL;
        double v15 = (char *)(v4 + 8 * (v8 >> 5));
      }

      else
      {
        uint64_t v14 = *(void *)v12 + ((v3 & 0x1F) << 7);
        double v15 = (char *)(v4 + 8 * (v8 >> 5));
        unint64_t v16 = *(void *)v15 + ((v8 & 0x1F) << 7);
      }

      double v17 = *(double *)(v10 + v11);
      *(void *)uint64_t v33 = v4 + 8 * v5;
      *(void *)&v33[8] = v14;
      if (v16 != v14)
      {
        uint64_t v18 = ((uint64_t)(v16 - *(void *)v15) >> 7) + 4 * (v15 - v12);
        uint64_t v19 = v14 - *(void *)v12;
        unint64_t v20 = v18 - (v19 >> 7);
        if (v18 != v19 >> 7)
        {
          double v21 = v17 + -2.0;
          do
          {
            unint64_t v22 = v20 >> 1;
            unint64_t v23 = sub_1002CBE78((uint64_t)v33, v20 >> 1);
            if (v21 >= *v24)
            {
              char v25 = v24 + 16;
              if ((double *)((char *)v24 - *v23 + 128) == (double *)4096)
              {
                uint64_t v26 = (double *)v23[1];
                ++v23;
                char v25 = v26;
              }

              *(void *)uint64_t v33 = v23;
              *(void *)&v33[8] = v25;
              unint64_t v22 = v20 + ~v22;
            }

            unint64_t v20 = v22;
          }

          while (v22);
          double v12 = *(char **)v33;
          uint64_t v14 = *(void *)&v33[8];
          unint64_t v3 = a1[61];
          uint64_t v4 = a1[58];
          uint64_t v13 = a1[59];
          unint64_t v5 = v3 >> 5;
        }
      }

      uint64_t v27 = (char *)(v4 + 8 * v5);
      if (v13 == v4) {
        uint64_t v28 = 0LL;
      }
      else {
        uint64_t v28 = *(void *)v27 + ((v3 & 0x1F) << 7);
      }
      sub_1002CA580(a1 + 57, v27, v28, v12, v14);
      uint64_t v29 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v30 = a1[58];
        uint64_t v31 = *(void *)(*(void *)(v30 + ((a1[61] >> 2) & 0x3FFFFFFFFFFFFFF8LL)) + ((a1[61] & 0x1FLL) << 7));
        *(_DWORD *)uint64_t v33 = 134218240;
        *(void *)&_DWORD v33[4] = v31;
        *(_WORD *)&v33[12] = 2048;
        *(void *)&v33[14] = v32;
        _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "#sa_algo,Pose history now between %f s and %f s",  v33,  0x16u);
      }
    }
  }

void sub_1002C7C24(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a2 + 181))
  {
    unsigned int v4 = *(unsigned __int8 *)(a2 + 180);
    if (v4 <= 2)
    {
      uint64_t v15 = qword_1008000A0;
      if (!os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      int v48 = 67109120;
      LODWORD(v49) = v4;
      unint64_t v16 = "#sa_algo,mmsValStatus %d does not pass check, rejecting range result event";
      double v17 = (os_log_s *)v15;
      uint32_t v18 = 8;
      goto LABEL_8;
    }
  }

  int v5 = *(unsigned __int8 *)(a2 + 36);
  uint64_t v6 = qword_1008000A0;
  BOOL v7 = os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (!v7) {
      goto LABEL_12;
    }
    uint64_t v8 = *(void *)(a2 + 8);
    double v9 = *(float *)(a2 + 16);
    double v10 = *(float *)(a2 + 24);
    double v11 = *(float *)(a2 + 28);
    int v48 = 134218752;
    uint64_t v49 = v8;
    __int16 v50 = 2048;
    double v51 = v9;
    __int16 v52 = 2048;
    double v53 = v10;
    __int16 v54 = 2048;
    double v55 = v11;
    double v12 = "#sa_algo,Received range result at %f s, distance: %0.2f m, az: %3.2f rad, el: %3.2f rad";
    uint64_t v13 = (os_log_s *)v6;
    uint32_t v14 = 42;
  }

  else
  {
    if (!v7) {
      goto LABEL_12;
    }
    uint64_t v19 = *(void *)(a2 + 8);
    double v20 = *(float *)(a2 + 16);
    int v48 = 134218240;
    uint64_t v49 = v19;
    __int16 v50 = 2048;
    double v51 = v20;
    double v12 = "#sa_algo,Received range result at %f s, distance: %0.2f m";
    uint64_t v13 = (os_log_s *)v6;
    uint32_t v14 = 22;
  }

  _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&v48, v14);
LABEL_12:
  if (!*(_BYTE *)(a1 + 16))
  {
    *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = *(void *)a2;
    *(_BYTE *)(a1 + 16) = 1;
  }

  if (*(_BYTE *)(a1 + 3))
  {
    double v21 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v4_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "#sa_algo,Target is moving - passing range measurement to range filter without VIO",  (uint8_t *)&v48,  2u);
    }

    sub_1002C68A4(a1, a2);
    goto LABEL_29;
  }

  if (*(_DWORD *)(a1 + 504) == 2)
  {
    if (!*(void *)(a1 + 496))
    {
      unint64_t v23 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v4_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
        unint64_t v24 = "#sa_algo,Pose history is empty - passing range measurement to range filter without VIO";
        goto LABEL_27;
      }

      goto LABEL_28;
    }

    double v22 = *(double *)(a2 + 8);
    if (v22 < *(double *)(*(void *)(*(void *)(a1 + 464) + ((*(void *)(a1 + 488) >> 2) & 0x3FFFFFFFFFFFFFF8LL))
                         + ((*(void *)(a1 + 488) & 0x1FLL) << 7)))
    {
      unint64_t v23 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v4_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
        unint64_t v24 = "#sa_algo,Measurement earlier than the first pose in history - passing range measurement to range filter without VIO";
LABEL_27:
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, v24, (uint8_t *)&v48, 2u);
        goto LABEL_28;
      }

      goto LABEL_28;
    }

    if (!*(_BYTE *)(a1 + 368))
    {
LABEL_39:
      __int128 v29 = *(_OWORD *)a2;
      __int128 v30 = *(_OWORD *)(a2 + 16);
      __int128 v31 = *(_OWORD *)(a2 + 48);
      *(_OWORD *)(a1 + 216) = *(_OWORD *)(a2 + 32);
      *(_OWORD *)(a1 + 232) = v31;
      *(_OWORD *)(a1 + 184) = v29;
      *(_OWORD *)(a1 + 200) = v30;
      __int128 v32 = *(_OWORD *)(a2 + 64);
      __int128 v33 = *(_OWORD *)(a2 + 80);
      __int128 v34 = *(_OWORD *)(a2 + 112);
      *(_OWORD *)(a1 + 280) = *(_OWORD *)(a2 + 96);
      *(_OWORD *)(a1 + 296) = v34;
      *(_OWORD *)(a1 + 24_Block_object_dispose((const void *)(v1 - 112), 8) = v32;
      *(_OWORD *)(a1 + 264) = v33;
      __int128 v35 = *(_OWORD *)(a2 + 128);
      __int128 v36 = *(_OWORD *)(a2 + 144);
      __int128 v37 = *(_OWORD *)(a2 + 160);
      *(void *)(a1 + 360) = *(void *)(a2 + 176);
      *(_OWORD *)(a1 + 32_Block_object_dispose((const void *)(v1 - 112), 8) = v36;
      *(_OWORD *)(a1 + 344) = v37;
      *(_OWORD *)(a1 + 312) = v35;
      *(_BYTE *)(a1 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
      sub_1002C8054(a1, (float32x2_t *)a2, 1);
      sub_1002C6C20(a1, v38, v39, v40, v41, v42);
      sub_1002C728C(a1, v43, v44, v45, v46, v47);
      goto LABEL_29;
    }

    double v26 = *(double *)(a1 + 192);
    uint64_t v27 = (os_log_s *)qword_1008000A0;
    BOOL v28 = os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT);
    if (v22 > v26)
    {
      if (v28)
      {
        LOWORD(v4_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "#sa_algo,Received a new measurement before the cached one can be interpolated - passing the cached measurement to the range filter without VIO",  (uint8_t *)&v48,  2u);
        if (!*(_BYTE *)(a1 + 368)) {
          sub_100006080();
        }
      }

      sub_1002C68A4(a1, a1 + 184);
      if (*(_BYTE *)(a1 + 368)) {
        *(_BYTE *)(a1 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
      }
      goto LABEL_39;
    }

    if (!v28) {
      return;
    }
    LOWORD(v4_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
    unint64_t v16 = "#sa_algo,Measurement earlier than the cached measurement - rejecting range measurement";
    double v17 = v27;
    uint32_t v18 = 2;
LABEL_8:
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, v16, (uint8_t *)&v48, v18);
    return;
  }

  unint64_t v23 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v4_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
    unint64_t v24 = "#sa_algo,VIO Tracking is not normal - passing range measurement to range filter without VIO";
    goto LABEL_27;
  }

void sub_1002C8054(uint64_t a1, float32x2_t *a2, int a3)
{
  if (a2[4].i8[4])
  {
    double v3 = a2[2].f32[0];
    *(float32x2_t *)(a1 + 376) = a2[1];
    *(double *)(a1 + 384) = v3;
    *(float64x2_t *)(a1 + 392) = vcvtq_f64_f32(a2[3]);
    *(_DWORD *)(a1 + 40_Block_object_dispose((const void *)(v1 - 112), 8) = a3;
    *(_BYTE *)(a1 + 416) = 0;
    *(_BYTE *)(a1 + 440) = 0;
    *(_BYTE *)(a1 + 44_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
    sub_1002C9304(a1);
  }

  else if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG))
  {
    sub_1003A7730();
  }

uint64_t sub_1002C80DC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D4>)
{
  *(_OWORD *)(a2 + 352) = 0u;
  *(_OWORD *)(a2 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_OWORD *)(a2 + 320) = 0u;
  *(_OWORD *)(a2 + 336) = 0u;
  *(_OWORD *)(a2 + 28_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_OWORD *)(a2 + 304) = 0u;
  *(_OWORD *)(a2 + 256) = 0u;
  *(_OWORD *)(a2 + 272) = 0u;
  *(_OWORD *)(a2 + 224) = 0u;
  *(_OWORD *)(a2 + 240) = 0u;
  *(_OWORD *)(a2 + 192) = 0u;
  *(_OWORD *)(a2 + 20_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_OWORD *)(a2 + 160) = 0u;
  *(_OWORD *)(a2 + 176) = 0u;
  *(_OWORD *)(a2 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_OWORD *)(a2 + 144) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  if (*(_BYTE *)a1)
  {
    if (*(_BYTE *)(a1 + 128))
    {
      uint64_t v5 = *(void *)(a1 + 85);
      *(void *)__int128 buf = *(void *)(a1 + 80);
      *(void *)&buf[5] = v5;
      *(void *)&uint8_t buf[16] = 0LL;
      *(void *)&v136[0] = 0LL;
      *(double *)&uint64_t v135 = 0.0;
      uint64_t v6 = (uint64_t)sub_1002CAB48( &buf[16],  *(const void **)(a1 + 96),  *(void *)(a1 + 104),  0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(*(void *)(a1 + 104) - *(void *)(a1 + 96)) >> 3));
      *((void *)&v136[0] + 1) = *(void *)(a1 + 120);
      switch(*(_DWORD *)buf)
      {
        case 0:
        case 1:
        case 6:
          *(_DWORD *)a2 = 0;
          int v7 = 1;
          goto LABEL_7;
        case 2:
        case 3:
          *(_DWORD *)a2 = 0;
          int v7 = 256;
LABEL_7:
          *(_DWORD *)(a2 + 4) = v7;
          goto LABEL_8;
        case 4:
          *(void *)a2 = 0LL;
          goto LABEL_8;
        case 5:
          *(_OWORD *)uint64_t v103 = **(_OWORD **)&buf[16];
          *(void *)&v103[16] = *(void *)(*(void *)&buf[16] + 16LL);
          unint64_t v46 = *(void *)(a1 + 496) + *(void *)(a1 + 488) - 1LL;
          sub_1002C9108( (float64x2_t *)v103,  (float32x4_t *)(*(void *)(*(void *)(a1 + 464) + ((v46 >> 2) & 0x3FFFFFFFFFFFFFF8LL))
                          + ((v46 & 0x1F) << 7)),
            (uint64_t)&v117);
          double v47 = (os_log_s *)qword_1008000A0;
          uint64_t v6 = os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG);
          if ((_DWORD)v6)
          {
            if (!*(_BYTE *)(a1 + 32)) {
              sub_100006080();
            }
            sub_1003A79B4(a1, (float *)&v117, v133, v47);
          }

          if (!*(_BYTE *)(a1 + 16) || !*(_BYTE *)(a1 + 32)) {
            sub_100006080();
          }
          uint64_t v48 = *(void *)(a1 + 8);
          uint64_t v49 = *(void *)(a1 + 24);
          int v50 = (int)v117;
          if (*(_BYTE *)(a2 + 192)) {
            *(_BYTE *)(a2 + 192) = 0;
          }
          *(void *)(a2 + _Block_object_dispose((const void *)(v1 - 112), 8) = v48;
          *(void *)(a2 + 16) = v49;
          *(_DWORD *)(a2 + 24) = v50;
          *(_DWORD *)(a2 + 2_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
          *(_BYTE *)(a2 + 56) = 0;
          *(void *)(a2 + 32) = 0LL;
          *(void *)(a2 + 40) = 0LL;
          *(_BYTE *)(a2 + 60) = 0;
          *(_BYTE *)(a2 + 64) = 0;
          *(_BYTE *)(a2 + 6_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
          *(void *)(a2 + 72) = 0LL;
          *(void *)(a2 + 80) = 0LL;
          *(_WORD *)(a2 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
          *(_OWORD *)(a2 + 96) = 0u;
          *(_OWORD *)(a2 + 112) = 0u;
          *(_OWORD *)(a2 + 121) = 0u;
          *(_BYTE *)(a2 + 160) = 0;
          *(void *)(a2 + 176) = 0LL;
          *(void *)(a2 + 184) = 0LL;
          *(void *)(a2 + 16_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
          *(_BYTE *)(a2 + 192) = 1;
          float v51 = *(float *)&v118;
          if (!*(_BYTE *)(a2 + 224)) {
            *(_BYTE *)(a2 + 224) = 1;
          }
          *(double *)(a2 + 216) = v51;
          if (BYTE8(v118))
          {
            *(double *)(a2 + 200) = *((float *)&v117 + 1) * 180.0 / 3.14159265;
            *(_BYTE *)(a2 + 20_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
            *(_DWORD *)(a2 + 364) = 2;
            *(_BYTE *)(a2 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
            uint64_t v6 = os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG);
            if ((_DWORD)v6) {
              sub_1003A7950();
            }
          }

          if (!*(_BYTE *)(a1 + 128)) {
            sub_100006080();
          }
          int v52 = *(_DWORD *)(a1 + 88);
          if (v52 == 2)
          {
            *(_DWORD *)a2 = 1;
            float v70 = *((float *)&v118 + 1);
            if (!*(_BYTE *)(a2 + 248)) {
              *(_BYTE *)(a2 + 24_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
            }
            *(double *)(a2 + 240) = v70;
            __int128 v71 = (os_log_s *)qword_1008000A0;
            uint64_t v6 = os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG);
            if ((v6 & 1) != 0)
            {
              double v78 = *(double *)&v103[16];
              *(_DWORD *)uint64_t v122 = 134218496;
              float64x2_t v90 = *(float64x2_t *)v103;
              double v123 = *(double *)v103;
              *(_WORD *)uint64_t v124 = 2048;
              *(void *)((unint64_t)v122 | 0xE) = *(void *)&v103[8];
              __int16 v125 = 2048;
              double v126 = v78;
              _os_log_debug_impl( (void *)&_mh_execute_header,  v71,  OS_LOG_TYPE_DEBUG,  "#sa_algo,Populating world position output with SA, object position is [%4.2f, %4.2f, %4.2f] m",  v122,  0x20u);
              float64x2_t v72 = v90;
              double v73 = v78;
            }

            else
            {
              float64x2_t v72 = *(float64x2_t *)v103;
              double v73 = *(double *)&v103[16];
            }

            *(float32x2_t *)&v72.f64[0] = vcvt_f32_f64(v72);
            float v74 = v73;
            *(float *)&v72.f64[1] = v74;
            if (!*(_BYTE *)(a2 + 304)) {
              *(_BYTE *)(a2 + 304) = 1;
            }
            *(float64x2_t *)(a2 + 28_Block_object_dispose((const void *)(v1 - 112), 8) = v72;
            if (v70 >= 2.5)
            {
              int v75 = 2;
            }

            else if (v70 <= -2.5)
            {
              int v75 = 3;
            }

            else
            {
              int v75 = 1;
            }

            *(_DWORD *)(a2 + 232) = v75;
          }

          else
          {
            if (v52 == 1)
            {
              else {
                int v69 = 4;
              }
              *(_DWORD *)(a2 + 232) = v69;
              *(_DWORD *)a2 = 0;
            }

            else
            {
              if (v52) {
                goto LABEL_8;
              }
              *(_DWORD *)a2 = 0;
              *(_DWORD *)(a2 + 232) = 0;
            }

            *(_BYTE *)(a2 + 6) = 1;
          }

void sub_1002C9098(_Unwind_Exception *a1)
{
  uint64_t v2 = (void *)STACK[0x290];
  if (STACK[0x290])
  {
    STACK[0x298] = (unint64_t)v2;
    operator delete(v2);
  }

  _Unwind_Resume(a1);
}

void sub_1002C9108(float64x2_t *a1@<X0>, float32x4_t *a2@<X1>, uint64_t a3@<X8>)
{
  float32x4_t v7 = *(float32x4_t *)a1;
  *(float32x2_t *)v7.f32 = vcvt_f32_f64(*a1);
  float32_t v4 = a1[1].f64[0];
  v7.f32[2] = v4;
  float32x4_t v5 = vsubq_f32(v7, a2[4]);
  float32x4_t v6 = vmulq_f32(v5, v5);
  v7.f32[0] = sqrtf(v6.f32[2] + v6.f32[0]);
  *(float *)a3 = sqrtf(v6.f32[2] + vaddv_f32(*(float32x2_t *)v6.f32));
  *(_DWORD *)(a3 + 4) = 0;
  *(_DWORD *)(a3 + 12) = v5.i32[1];
  *(_DWORD *)(a3 + _Block_object_dispose((const void *)(v1 - 112), 8) = v7.i32[0];
  *(_BYTE *)(a3 + 16) = 1;
  if (v7.f32[0] <= 0.01)
  {
    *(_BYTE *)(a3 + 16) = 0;
  }

  else
  {
    v8.i32[0] = vextq_s8((int8x16_t)v5, (int8x16_t)v5, 8uLL).u32[0];
    v8.i32[1] = v5.i32[0];
    float32x2_t v12 = vdiv_f32(v8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v7.f32, 0));
    float32x2_t v9 = (float32x2_t)sub_1002CA7B4(a2);
    float32x2_t v11 = vmla_lane_f32(vmul_n_f32(v9, v12.f32[0]), v10, v12, 1);
    *(float *)(a3 + 4) = atan2f(v11.f32[1], v11.f32[0]);
  }

void sub_1002C91D0(uint64_t a1, _DWORD *a2)
{
  switch(*a2)
  {
    case 0:
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
        sub_1003A7A14();
      }
      break;
    case 1:
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
        sub_1003A7A78();
      }
      break;
    case 2:
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
        sub_1003A7ADC();
      }
      break;
    case 3:
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
        sub_1003A7B40();
      }
      break;
    case 4:
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
        sub_1003A7BA4();
      }
      break;
    default:
      return;
  }

void *sub_1002C92F4(void *result)
{
  *__n128 result = off_1007AED90;
  return result;
}

void sub_1002C9304(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 448))
  {
    int v2 = *(_DWORD *)(a1 + 408);
    uint64_t v4 = *(void *)(a1 + 416);
    uint64_t v3 = *(void *)(a1 + 424);
    uint64_t v5 = *(void *)(a1 + 432);
    int v6 = *(unsigned __int8 *)(a1 + 440);
    float32x4_t v7 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
      sub_1003A7CE4((void *)a1, v7);
    }
    if (v2 == 2)
    {
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
        sub_1003A7CB8();
      }
    }

    else if (v2 == 1)
    {
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
        sub_1003A7C8C();
      }
    }

    else if (!v2 && os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG))
    {
      sub_1003A7C60();
    }

    float32x2_t v8 = (os_log_s *)qword_1008000A0;
    BOOL v9 = os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG);
    if (v6)
    {
      if (v9)
      {
        int v10 = 134218496;
        uint64_t v11 = v4;
        __int16 v12 = 2048;
        uint64_t v13 = v3;
        __int16 v14 = 2048;
        uint64_t v15 = v5;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "#sa_algo,AoA cache: world position [%3.2f, %3.2f, %3.2f] m",  (uint8_t *)&v10,  0x20u);
      }
    }

    else if (v9)
    {
      sub_1003A7C34();
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG))
  {
    sub_1003A7C08();
  }

double sub_1002C94C0(int8x16_t a1, int8x16_t a2, __n128 a3, double a4, double a5)
{
  float v5 = a3.n128_f32[2] + (float)(*(float *)a1.i32 + *(float *)&a2.i32[1]);
  if (v5 >= 0.0)
  {
    float v14 = sqrtf(v5 + 1.0);
    *(float *)&a5 = v14 + v14;
    float32x2_t v15 = vrecpe_f32(*(float32x2_t *)&a5);
    float32x2_t v16 = vmul_f32(v15, vrecps_f32(*(float32x2_t *)&a5, v15));
    float32x2_t v25 = vmul_n_f32( vsub_f32( (float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(a2, a2, 8uLL), (int32x2_t)a3.n128_u64[0]),  (float32x2_t)vext_s8((int8x8_t)a3.n128_u64[0], (int8x8_t)*(_OWORD *)&vextq_s8(a1, a1, 8uLL), 4uLL)),  vmul_f32(v16, vrecps_f32(*(float32x2_t *)&a5, v16)).f32[0]);
  }

  else if (*(float *)a1.i32 < *(float *)&a2.i32[1] || *(float *)a1.i32 < a3.n128_f32[2])
  {
    float v7 = 1.0 - *(float *)a1.i32;
    if (*(float *)&a2.i32[1] >= a3.n128_f32[2])
    {
      *(float *)&a4 = sqrtf(*(float *)&a2.i32[1] + (float)(v7 - a3.n128_f32[2]));
      *(float *)&a4 = *(float *)&a4 + *(float *)&a4;
      float32x2_t v26 = vrecpe_f32(*(float32x2_t *)&a4);
      float32x2_t v27 = vmul_f32(v26, vrecps_f32(*(float32x2_t *)&a4, v26));
      v27.i32[0] = vmul_f32(v27, vrecps_f32(*(float32x2_t *)&a4, v27)).u32[0];
      v28.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_lane_s32(*(int32x2_t *)a1.i8, 1), *(float32x2_t *)a2.i8).u32[0];
      v28.i32[1] = LODWORD(a4);
      v27.i32[1] = 0.25;
      float32x2_t v25 = vmul_f32(v28, v27);
    }

    else
    {
      a3.n128_u64[0] = (unint64_t)vadd_f32( (float32x2_t)vzip1_s32( (int32x2_t)*(_OWORD *)&vextq_s8(a1, a1, 8uLL),  (int32x2_t)*(_OWORD *)&vextq_s8(a2, a2, 8uLL)),  (float32x2_t)a3.n128_u64[0]);
      float32x2_t v8 = (float32x2_t)__PAIR64__( a1.u32[1],  COERCE_UNSIGNED_INT(sqrtf(a3.n128_f32[2] + (float)(v7 - *(float *)&a2.i32[1]))));
      float32x2_t v9 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)a2.i8, 0);
      float32x2_t v10 = vsub_f32(*(float32x2_t *)a1.i8, v9);
      v9.i32[0] = 2.0;
      v9.i32[0] = vmul_f32(v8, v9).u32[0];
      v9.i32[1] = v10.i32[1];
      float32x2_t v11 = vrecpe_f32(v9);
      float32x2_t v12 = vmul_f32(v11, vrecps_f32(v9, v11));
      float32x2_t v25 = vmul_n_f32((float32x2_t)a3.n128_u64[0], vmul_f32(v12, vrecps_f32(v9, v12)).f32[0]);
      __asm { FMOV            V2.2S, #0.25 }
    }
  }

  else
  {
    float32x2_t v17 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)a2.i8, 0);
    float32x2_t v18 = vadd_f32(*(float32x2_t *)a1.i8, v17);
    v17.i32[0] = 2.0;
    v17.i32[0] = vmul_f32( (float32x2_t)__PAIR64__( a1.u32[1],  COERCE_UNSIGNED_INT(sqrtf(*(float *)a1.i32 + (float)((float)(1.0 - *(float *)&a2.i32[1])
                                                                                     - a3.n128_f32[2])))),
                   v17).u32[0];
    v17.i32[1] = v18.i32[1];
    float32x2_t v19 = vrecpe_f32(v17);
    float32x2_t v20 = vmul_f32(v19, vrecps_f32(v17, v19));
    __asm { FMOV            V5.2S, #0.25 }

    _D5.i32[1] = vmul_f32(v20, vrecps_f32(v17, v20)).u32[0];
    float32x2_t v25 = vmul_f32(v17, _D5);
  }

  return *(double *)&v25;
}

void *sub_1002C9684(void *result)
{
  *__n128 result = off_1007AED90;
  return result;
}

void *sub_1002C9694(void *result)
{
  *__n128 result = off_1007AED90;
  return result;
}

uint64_t sub_1002C96A4(uint64_t result, uint64_t a2)
{
  if (!*(_BYTE *)(result + 32)) {
    return result;
  }
  uint64_t v3 = result;
  double v4 = *(double *)(result + 24);
  if (*(_BYTE *)(result + 64))
  {
  }

  *(double *)(result + 56) = v4;
  *(_BYTE *)(result + 64) = 1;
  sub_1001DF764((uint64_t)&v89);
  sub_1001DF764((uint64_t)&v86);
  sub_1001DF764((uint64_t)&v83);
  sub_1001DF764((uint64_t)&v80);
  sub_1001DF764((uint64_t)&v77);
  sub_1001DF764((uint64_t)&v74);
  sub_1001DF764((uint64_t)&v71);
  sub_1001DF764((uint64_t)&v68);
  uint64_t v5 = v86;
  *(_DWORD *)((char *)&v86 + *(void *)(v86 - 24) + _Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)((_BYTE *)&v86 + *(void *)(v86 - 24) + 8) & 0xFFFFFEFB | 4;
  *(std::locale::__imp **)((char *)&v87.__loc_.__locale_ + *(void *)(v5 - sub_100034A98(v2, *(void **)(v1 + 24)) = (std::locale::__imp *)2;
  uint64_t v6 = v83;
  *(_DWORD *)((char *)&v83 + *(void *)(v83 - 24) + _Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)((_BYTE *)&v83 + *(void *)(v83 - 24) + 8) & 0xFFFFFEFB | 4;
  *(std::locale::__imp **)((char *)&v84.__loc_.__locale_ + *(void *)(v6 - sub_100034A98(v2, *(void **)(v1 + 24)) = (std::locale::__imp *)1;
  uint64_t v7 = v80;
  *(_DWORD *)((char *)&v80 + *(void *)(v80 - 24) + _Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)((_BYTE *)&v80 + *(void *)(v80 - 24) + 8) & 0xFFFFFEFB | 4;
  *(std::locale::__imp **)((char *)&v81.__loc_.__locale_ + *(void *)(v7 - sub_100034A98(v2, *(void **)(v1 + 24)) = (std::locale::__imp *)2;
  uint64_t v8 = v74;
  *(_DWORD *)((char *)&v74 + *(void *)(v74 - 24) + _Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)((_BYTE *)&v74 + *(void *)(v74 - 24) + 8) & 0xFFFFFEFB | 4;
  *(std::locale::__imp **)((char *)&v75.__loc_.__locale_ + *(void *)(v8 - sub_100034A98(v2, *(void **)(v1 + 24)) = (std::locale::__imp *)2;
  uint64_t v9 = v71;
  *(_DWORD *)((char *)&v71 + *(void *)(v71 - 24) + _Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)((_BYTE *)&v71 + *(void *)(v71 - 24) + 8) & 0xFFFFFEFB | 4;
  *(std::locale::__imp **)((char *)&v72.__loc_.__locale_ + *(void *)(v9 - sub_100034A98(v2, *(void **)(v1 + 24)) = (std::locale::__imp *)2;
  uint64_t v10 = v68;
  *(_DWORD *)((char *)&v68 + *(void *)(v68 - 24) + _Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)((_BYTE *)&v68 + *(void *)(v68 - 24) + 8) & 0xFFFFFEFB | 4;
  *(std::locale::__imp **)((char *)&v69.__loc_.__locale_ + *(void *)(v10 - sub_100034A98(v2, *(void **)(v1 + 24)) = (std::locale::__imp *)2;
  if (*(_BYTE *)(a2 + 192))
  {
    std::ostream::operator<<(&v89, *(void *)(a2 + 8));
    if (!*(_BYTE *)(a2 + 192)) {
      goto LABEL_104;
    }
    float32x2_t v11 = (uint64_t *)std::ostream::operator<<(*(float *)(a2 + 24));
    float32x2_t v12 = " m";
    uint64_t v13 = 2LL;
  }

  else
  {
    float32x2_t v12 = "-";
    uint64_t v13 = 1LL;
    sub_100046B94(&v89, (uint64_t)"-", 1LL);
    float32x2_t v11 = &v86;
  }

  sub_100046B94(v11, (uint64_t)v12, v13);
  if (*(_BYTE *)(a2 + 208))
  {
    float v14 = (uint64_t *)std::ostream::operator<<(&v83, *(double *)(a2 + 200));
    float32x2_t v15 = " deg";
    uint64_t v16 = 4LL;
  }

  else
  {
    float32x2_t v15 = "-";
    float v14 = &v83;
    uint64_t v16 = 1LL;
  }

  sub_100046B94(v14, (uint64_t)v15, v16);
  if (*(_BYTE *)(a2 + 224))
  {
    float32x2_t v17 = (uint64_t *)std::ostream::operator<<(&v80, *(double *)(a2 + 216));
    float32x2_t v18 = " m";
    uint64_t v19 = 2LL;
  }

  else
  {
    float32x2_t v18 = "-";
    float32x2_t v17 = &v80;
    uint64_t v19 = 1LL;
  }

  sub_100046B94(v17, (uint64_t)v18, v19);
  if (*(_BYTE *)(a2 + 248))
  {
    float32x2_t v20 = (uint64_t *)std::ostream::operator<<(&v74, *(double *)(a2 + 240));
    uint64_t v21 = " m";
    uint64_t v22 = 2LL;
  }

  else
  {
    uint64_t v21 = "-";
    float32x2_t v20 = &v74;
    uint64_t v22 = 1LL;
  }

  sub_100046B94(v20, (uint64_t)v21, v22);
  uint64_t v23 = *(int *)(a2 + 232);
  if (*(_BYTE *)(a2 + 272))
  {
    sub_100046B94(&v71, (uint64_t)"[", 1LL);
    if (!*(_BYTE *)(a2 + 272)) {
      goto LABEL_104;
    }
    double v24 = (void *)std::ostream::operator<<(*(float *)(a2 + 256));
    sub_100046B94(v24, (uint64_t)", ", 2LL);
    if (!*(_BYTE *)(a2 + 272)) {
      goto LABEL_104;
    }
    float32x2_t v25 = (void *)std::ostream::operator<<(*(float *)(a2 + 260));
    sub_100046B94(v25, (uint64_t)", ", 2LL);
    if (!*(_BYTE *)(a2 + 272)) {
      goto LABEL_104;
    }
    float32x2_t v26 = (uint64_t *)std::ostream::operator<<(*(float *)(a2 + 264));
    float32x2_t v27 = "]";
  }

  else
  {
    float32x2_t v27 = "-";
    float32x2_t v26 = &v71;
  }

  sub_100046B94(v26, (uint64_t)v27, 1LL);
  if (!*(_BYTE *)(a2 + 304))
  {
    __int128 v31 = "-";
    __int128 v30 = &v68;
    uint64_t v32 = 1LL;
    goto LABEL_31;
  }

  sub_100046B94(&v68, (uint64_t)"[", 1LL);
  if (!*(_BYTE *)(a2 + 304)
    || (float32x2_t v28 = (void *)std::ostream::operator<<(*(float *)(a2 + 288)),
        sub_100046B94(v28, (uint64_t)", ", 2LL),
        !*(_BYTE *)(a2 + 304))
    || (__int128 v29 = (void *)std::ostream::operator<<(*(float *)(a2 + 292)),
        sub_100046B94(v29, (uint64_t)", ", 2LL),
        !*(_BYTE *)(a2 + 304)))
  {
LABEL_104:
    sub_100006080();
  }

  __int128 v30 = (uint64_t *)std::ostream::operator<<(*(float *)(a2 + 296));
  __int128 v31 = "] m";
  uint64_t v32 = 3LL;
LABEL_31:
  sub_100046B94(v30, (uint64_t)v31, v32);
  uint64_t v33 = qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    std::stringbuf::str(&v67, &v90);
    if ((v67.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      double v34 = &v67;
    }
    else {
      double v34 = (std::stringbuf::string_type *)v67.__r_.__value_.__r.__words[0];
    }
    if (!*(_BYTE *)(v3 + 32)) {
      sub_100006080();
    }
    uint64_t v35 = *(void *)(v3 + 24);
    if (*(_DWORD *)a2 == 1) {
      double v36 = "YES";
    }
    else {
      double v36 = "NO";
    }
    if (*(_BYTE *)(a2 + 4)) {
      __int128 v37 = "YES";
    }
    else {
      __int128 v37 = "NO";
    }
    if (*(_BYTE *)(a2 + 5)) {
      float v38 = "YES";
    }
    else {
      float v38 = "NO";
    }
    if (*(_BYTE *)(a2 + 6)) {
      float v39 = "YES";
    }
    else {
      float v39 = "NO";
    }
    if (*(_BYTE *)(a2 + 7)) {
      __int128 v40 = "YES";
    }
    else {
      __int128 v40 = "NO";
    }
    std::stringbuf::str(&v66, &v87);
    if ((v66.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      double v41 = &v66;
    }
    else {
      double v41 = (std::stringbuf::string_type *)v66.__r_.__value_.__r.__words[0];
    }
    std::stringbuf::str(&v65, &v84);
    if ((v65.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      double v42 = &v65;
    }
    else {
      double v42 = (std::stringbuf::string_type *)v65.__r_.__value_.__r.__words[0];
    }
    int v59 = v42;
    std::stringbuf::str(&v64, &v81);
    if ((v64.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v43 = &v64;
    }
    else {
      uint64_t v43 = (std::stringbuf::string_type *)v64.__r_.__value_.__r.__words[0];
    }
    unsigned int v57 = (os_log_s *)v33;
    __int128 v58 = v43;
    std::stringbuf::str(&v63, &v75);
    uint64_t v54 = v41;
    float v55 = v40;
    uint64_t v56 = v39;
    if ((v63.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      double v44 = &v63;
    }
    else {
      double v44 = (std::stringbuf::string_type *)v63.__r_.__value_.__r.__words[0];
    }
    uint64_t v45 = &v62;
    std::stringbuf::str(&v62, &v78);
    unint64_t v46 = v36;
    double v47 = v34;
    if ((v62.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      uint64_t v45 = (std::stringbuf::string_type *)v62.__r_.__value_.__r.__words[0];
    }
    std::stringbuf::str(&v61, &v72);
    int size = (char)v61.__r_.__value_.__s.__size_;
    std::string::size_type v49 = v61.__r_.__value_.__r.__words[0];
    std::stringbuf::str(&v60, &v69);
    int v50 = &v61;
    if (size < 0) {
      int v50 = (std::stringbuf::string_type *)v49;
    }
    if ((v60.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      float v51 = &v60;
    }
    else {
      float v51 = (std::stringbuf::string_type *)v60.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)__int128 buf = 136318466;
    double v93 = v47;
    __int16 v94 = 2048;
    uint64_t v95 = v35;
    __int16 v96 = 2080;
    uint64_t v97 = v46;
    __int16 v98 = 2080;
    __int128 v99 = v37;
    __int16 v100 = 2080;
    uint64_t v101 = v38;
    __int16 v102 = 2080;
    uint64_t v103 = v56;
    __int16 v104 = 2080;
    uint64_t v105 = v55;
    __int16 v106 = 2080;
    uint64_t v107 = v54;
    __int16 v108 = 2080;
    uint64_t v109 = v59;
    __int16 v110 = 2080;
    uint64_t v111 = v58;
    __int16 v112 = 2080;
    __int128 v113 = v44;
    __int16 v114 = 2080;
    uint64_t v115 = v45;
    __int16 v116 = 2080;
    uint64_t v117 = v50;
    __int16 v118 = 2080;
    uint64_t v119 = v51;
    _os_log_impl( (void *)&_mh_execute_header,  v57,  OS_LOG_TYPE_DEFAULT,  "#sa_algo,DeviceID: %s\n \tTimestamp: %f\n \tSolution convergence: %s, insufficientDisplacement: %s, insufficientHorizontalPositionDiversity: %s, insufficien tVerticalPositionDiversity: %s, insufficientLighting: %s\n \tRange: %s, Horizontal angle: %s, Horizontal distance: %s, Vertical distance: %s, Vertical state: %s, Direction: %s, World Position: %s",  buf,  0x8Eu);
  }

  std::streambuf::~streambuf(&v69);
  std::ios::~ios(&v70);
  uint64_t v71 = v52;
  *(uint64_t *)((char *)&v71 + *(void *)(v52 - sub_100034A98(v2, *(void **)(v1 + 24)) = v53;
  std::streambuf::~streambuf(&v72);
  std::ios::~ios(&v73);
  uint64_t v74 = v52;
  *(uint64_t *)((char *)&v74 + *(void *)(v52 - sub_100034A98(v2, *(void **)(v1 + 24)) = v53;
  std::streambuf::~streambuf(&v75);
  std::ios::~ios(&v76);
  uint64_t v77 = v52;
  *(uint64_t *)((char *)&v77 + *(void *)(v52 - sub_100034A98(v2, *(void **)(v1 + 24)) = v53;
  std::streambuf::~streambuf(&v78);
  std::ios::~ios(&v79);
  uint64_t v80 = v52;
  *(uint64_t *)((char *)&v80 + *(void *)(v52 - sub_100034A98(v2, *(void **)(v1 + 24)) = v53;
  std::streambuf::~streambuf(&v81);
  std::ios::~ios(&v82);
  uint64_t v83 = v52;
  *(uint64_t *)((char *)&v83 + *(void *)(v52 - sub_100034A98(v2, *(void **)(v1 + 24)) = v53;
  std::streambuf::~streambuf(&v84);
  std::ios::~ios(&v85);
  uint64_t v86 = v52;
  *(uint64_t *)((char *)&v86 + *(void *)(v52 - sub_100034A98(v2, *(void **)(v1 + 24)) = v53;
  std::streambuf::~streambuf(&v87);
  std::ios::~ios(&v88);
  uint64_t v89 = v52;
  *(uint64_t *)((char *)&v89 + *(void *)(v52 - sub_100034A98(v2, *(void **)(v1 + 24)) = v53;
  std::streambuf::~streambuf(&v90);
  return std::ios::~ios(&v91);
}

void sub_1002CA044( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23, void *a24, uint64_t a25, int a26, __int16 a27, char a28, char a29, void *a30, uint64_t a31, int a32, __int16 a33, char a34, char a35, void *a36, uint64_t a37, int a38, __int16 a39, char a40, char a41, void *a42, uint64_t a43, int a44, __int16 a45, char a46, char a47, void *a48, uint64_t a49, int a50,__int16 a51,char a52,char a53,void *a54,uint64_t a55,int a56,__int16 a57,char a58,char a59,char a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (a41 < 0) {
    operator delete(a36);
  }
  if (a47 < 0) {
    operator delete(a42);
  }
  if (a53 < 0) {
    operator delete(a48);
  }
  if (a59 < 0) {
    operator delete(a54);
  }
  sub_1001DF850((uint64_t)&a60);
  sub_1001DF850((uint64_t)&a72);
  sub_1001DF850((uint64_t)&STACK[0x300]);
  sub_1001DF850((uint64_t)&STACK[0x408]);
  sub_1001DF850((uint64_t)&STACK[0x510]);
  sub_1001DF850((uint64_t)&STACK[0x618]);
  sub_1001DF850((uint64_t)&STACK[0x720]);
  sub_1001DF850((uint64_t)&STACK[0x828]);
  _Unwind_Resume(a1);
}

void sub_1002CA180(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  *(_OWORD *)(a3 + 352) = 0u;
  *(_OWORD *)(a3 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_OWORD *)(a3 + 320) = 0u;
  *(_OWORD *)(a3 + 336) = 0u;
  *(_OWORD *)(a3 + 28_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_OWORD *)(a3 + 304) = 0u;
  *(_OWORD *)(a3 + 256) = 0u;
  *(_OWORD *)(a3 + 272) = 0u;
  *(_OWORD *)(a3 + 224) = 0u;
  *(_OWORD *)(a3 + 240) = 0u;
  *(_OWORD *)(a3 + 192) = 0u;
  *(_OWORD *)(a3 + 20_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_OWORD *)(a3 + 160) = 0u;
  *(_OWORD *)(a3 + 176) = 0u;
  *(_OWORD *)(a3 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_OWORD *)(a3 + 144) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  if (*(_BYTE *)(a1 + 1) && *(_BYTE *)(a1 + 176))
  {
    double v5 = *(double *)(a1 + 152);
    double v6 = *(double *)(a1 + 168);
    if (a2)
    {
      *(_DWORD *)(a3 + 364) = 3;
      *(_BYTE *)(a3 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
        sub_1003A7D7C();
      }
      if (*(_BYTE *)(a1 + 16))
      {
        float v7 = v5;
        *(void *)(a3 + _Block_object_dispose((const void *)(v1 - 112), 8) = *(void *)(a1 + 8);
        *(double *)(a3 + 16) = v6;
        *(float *)(a3 + 24) = v7;
        *(_DWORD *)(a3 + 2_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
        *(_BYTE *)(a3 + 56) = 0;
        *(void *)(a3 + 32) = 0LL;
        *(void *)(a3 + 40) = 0LL;
        *(_BYTE *)(a3 + 60) = 0;
        *(_BYTE *)(a3 + 64) = 0;
        *(_BYTE *)(a3 + 6_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
        *(void *)(a3 + 72) = 0LL;
        *(void *)(a3 + 80) = 0LL;
        *(_WORD *)(a3 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
        *(_OWORD *)(a3 + 96) = 0u;
        *(_OWORD *)(a3 + 112) = 0u;
        *(_OWORD *)(a3 + 121) = 0u;
        *(_BYTE *)(a3 + 160) = 0;
        *(void *)(a3 + 16_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
        *(void *)(a3 + 176) = 0LL;
        *(void *)(a3 + 184) = 0LL;
LABEL_15:
        *(_BYTE *)(a3 + 192) = 1;
        return;
      }

      goto LABEL_19;
    }

    if (!*(_BYTE *)(a1 + 32)) {
      goto LABEL_19;
    }
    if (*(double *)(a1 + 24) - v6 < *(double *)(a1 + 552))
    {
      *(_DWORD *)(a3 + 364) = 3;
      *(_BYTE *)(a3 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
        sub_1003A7DE0();
      }
      if (*(_BYTE *)(a1 + 16) && *(_BYTE *)(a1 + 32))
      {
        uint64_t v8 = *(void *)(a1 + 24);
        float v9 = v5;
        *(void *)(a3 + _Block_object_dispose((const void *)(v1 - 112), 8) = *(void *)(a1 + 8);
        *(void *)(a3 + 16) = v8;
        *(float *)(a3 + 24) = v9;
        *(_DWORD *)(a3 + 2_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
        *(_BYTE *)(a3 + 56) = 0;
        *(void *)(a3 + 32) = 0LL;
        *(void *)(a3 + 40) = 0LL;
        *(_BYTE *)(a3 + 60) = 0;
        *(_BYTE *)(a3 + 64) = 0;
        *(_BYTE *)(a3 + 6_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
        *(void *)(a3 + 72) = 0LL;
        *(void *)(a3 + 80) = 0LL;
        *(_WORD *)(a3 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
        *(_OWORD *)(a3 + 96) = 0u;
        *(_OWORD *)(a3 + 112) = 0u;
        *(_OWORD *)(a3 + 121) = 0u;
        *(_BYTE *)(a3 + 160) = 0;
        *(void *)(a3 + 176) = 0LL;
        *(void *)(a3 + 184) = 0LL;
        *(void *)(a3 + 16_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
        goto LABEL_15;
      }

void sub_1002CA3A0(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 128))
  {
    switch(*(_DWORD *)(a1 + 80))
    {
      case 0:
        uint64_t v1 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v10 = 0;
          int v2 = "#sa_algo,Batch solution status: STATIC_AND_UNOBSERVABLE";
          uint64_t v3 = (uint8_t *)&v10;
          goto LABEL_17;
        }

        break;
      case 1:
        uint64_t v1 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v9 = 0;
          int v2 = "#sa_algo,Batch solution status: STATIC";
          uint64_t v3 = (uint8_t *)&v9;
          goto LABEL_17;
        }

        break;
      case 2:
        uint64_t v1 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v8 = 0;
          int v2 = "#sa_algo,Batch solution status: UNOBSERVABLE";
          uint64_t v3 = (uint8_t *)&v8;
          goto LABEL_17;
        }

        break;
      case 3:
        uint64_t v1 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v7 = 0;
          int v2 = "#sa_algo,Batch solution status: DEGENERATE_PATH";
          uint64_t v3 = (uint8_t *)&v7;
          goto LABEL_17;
        }

        break;
      case 4:
        uint64_t v1 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v6 = 0;
          int v2 = "#sa_algo,Batch solution status: NOT_CONVERGED";
          uint64_t v3 = (uint8_t *)&v6;
          goto LABEL_17;
        }

        break;
      case 5:
        uint64_t v1 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v5 = 0;
          int v2 = "#sa_algo,Batch solution status: INITIALIZED";
          uint64_t v3 = (uint8_t *)&v5;
          goto LABEL_17;
        }

        break;
      case 6:
        uint64_t v1 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v4 = 0;
          int v2 = "#sa_algo,Batch solution status: RESET_FROM_HIGH_RESIDUALS";
          uint64_t v3 = (uint8_t *)&v4;
LABEL_17:
          _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, v2, v3, 2u);
        }

        break;
      default:
        return;
    }
  }

void *sub_1002CA580(void *a1, char *a2, uint64_t a3, char *a4, uint64_t a5)
{
  if (a5 == a3) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = ((a5 - *(void *)a4) >> 7) + 4 * (a4 - a2) - ((a3 - *(void *)a2) >> 7);
  }
  uint64_t v7 = a1[1];
  __int16 v8 = (char *)(v7 + 8LL * (a1[4] >> 5));
  if (a1[2] == v7) {
    uint64_t v9 = 0LL;
  }
  else {
    uint64_t v9 = *(void *)v8 + ((a1[4] & 0x1FLL) << 7);
  }
  uint64_t v33 = (char **)(v7 + 8LL * (a1[4] >> 5));
  double v34 = (char *)v9;
  if (v9 == a3) {
    unint64_t v10 = 0LL;
  }
  else {
    unint64_t v10 = ((a3 - *(void *)a2) >> 7) + 4 * (a2 - v8) - ((v9 - *(void *)v8) >> 7);
  }
  float32x2_t v11 = (char **)sub_1002CBE78((uint64_t)&v33, v10);
  v32.n128_u64[0] = (unint64_t)v11;
  v32.n128_u64[1] = (unint64_t)v12;
  if (v6 >= 1)
  {
    if (v10 <= (unint64_t)(a1[5] - v6) >> 1)
    {
      uint64_t v19 = v11;
      float32x2_t v20 = v12;
      uint64_t v21 = v33;
      uint64_t v22 = v34;
      uint64_t v23 = sub_1002CBE78((uint64_t)&v32, v6);
      sub_1002CBF48(v21, v22, v19, v20, v23, v24, &v35);
      float32x2_t v25 = v34;
      if (v34 != v36)
      {
        float32x2_t v26 = v33;
        do
        {
          v25 += 128;
          double v34 = v25;
          if (v25 - *v26 == 4096)
          {
            float32x2_t v27 = v26[1];
            ++v26;
            float32x2_t v25 = v27;
            uint64_t v33 = v26;
            double v34 = v27;
          }
        }

        while (v25 != v36);
      }

      uint64_t v28 = a1[5] - v6;
      a1[4] += v6;
      a1[5] = v28;
    }

    else
    {
      uint64_t v13 = (char **)sub_1002CBE78((uint64_t)&v32, v6);
      unint64_t v15 = a1[4] + a1[5];
      uint64_t v16 = a1[1];
      float32x2_t v17 = (char **)(v16 + 8 * (v15 >> 5));
      if (a1[2] == v16) {
        float32x2_t v18 = 0LL;
      }
      else {
        float32x2_t v18 = &(*v17)[128 * (v15 & 0x1F)];
      }
      __n128 v35 = v32;
      sub_1002CC0D0(v13, v14, v17, v18, (uint64_t)&v35);
      a1[5] -= v6;
      while ((sub_1002CBEDC(a1, 1) & 1) != 0)
        ;
    }
  }

  uint64_t v29 = a1[1];
  if (a1[2] == v29) {
    uint64_t v30 = 0LL;
  }
  else {
    uint64_t v30 = *(void *)(v29 + 8LL * (a1[4] >> 5)) + ((a1[4] & 0x1FLL) << 7);
  }
  v35.n128_u64[0] = v29 + 8LL * (a1[4] >> 5);
  v35.n128_u64[1] = v30;
  return sub_1002CBE78((uint64_t)&v35, v10);
}

int32x2_t sub_1002CA7B4(float32x4_t *a1)
{
  float32x4_t v30 = a1[3];
  float32x4_t v32 = a1[2];
  float v4 = acosf(-v30.f32[1]);
  float32x4_t v7 = v32;
  v1.i32[0] = v32.i32[1];
  v5.i32[0] = vextq_s8((int8x16_t)v7, (int8x16_t)v7, 8uLL).u32[0];
  v5.i32[1] = v32.i32[0];
  float32x4_t v6 = vmulq_f32(v7, v7);
  v7.f32[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2), v6).f32[0]);
  if (fabsf(v32.f32[1]) >= fabsf(a1[1].f32[1]))
  {
    float32x2_t v33 = v5;
    int32x2_t v29 = *(int32x2_t *)v7.f32;
    float v11 = asinf(v7.f32[0]);
    if (v11 >= 0.43633)
    {
      double v8 = COERCE_DOUBLE(vdiv_f32(v33, (float32x2_t)vdup_lane_s32(v29, 0)));
      double v24 = v4;
      if (v4 <= 1.57079633)
      {
        *(float *)&double v24 = -*((float *)&v8 + 1);
        double v25 = COERCE_DOUBLE(vzip1_s32(*(int32x2_t *)&v24, *(int32x2_t *)&v8));
        double v26 = COERCE_DOUBLE(vneg_f32(*(float32x2_t *)&v8));
        LODWORD(v27) = vdup_lane_s32(*(int32x2_t *)&v26, 1).u32[0];
        if (v4 <= 0.7854)
        {
          double v9 = v25;
        }

        else
        {
          double v8 = v26;
          *((float *)&v27 + 1) = -*(float *)&v26;
          double v9 = v27;
        }

        return vzip1_s32(*(int32x2_t *)&v8, *(int32x2_t *)&v9);
      }
    }

    else
    {
      float32x4_t v12 = v30;
      v13.i32[0] = vextq_s8((int8x16_t)v12, (int8x16_t)v12, 8uLL).u32[0];
      v13.i32[1] = v30.i32[0];
      v10.i32[0] = 0;
      float32x2_t v14 = (float32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32(vcgt_f32(v1, v10), 0), (int8x8_t)vneg_f32(v13), (int8x8_t)v13);
      float32x4_t v15 = vmulq_f32(v12, v12);
      v15.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 2), v15).u64[0];
      v15.f32[0] = sqrtf(v15.f32[0]);
      double v8 = COERCE_DOUBLE(vdiv_f32(v14, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v15.f32, 0)));
      if (v11 > 0.2618)
      {
        float32x2_t v16 = (float32x2_t)vbsl_s8((int8x8_t)vcgtd_f64(1.57079633, v4), (int8x8_t)vneg_f32(v33), (int8x8_t)v33);
        float32x2_t v17 = vmul_f32(v16, v16);
        v17.f32[0] = sqrtf(vaddv_f32(v17));
        float32x2_t v18 = vdiv_f32(v16, (float32x2_t)vdup_lane_s32((int32x2_t)v17, 0));
        v16.f32[0] = -v18.f32[1];
        int32x2_t v19 = vzip1_s32((int32x2_t)v16, (int32x2_t)v18);
        float32x2_t v31 = (float32x2_t)v19;
        float32x2_t v34 = v18;
        float32x2_t v20 = (float32x2_t)__PAIR64__(v19.u32[1], v18.u32[1]);
        v18.i32[1] = v19.i32[0];
        float32x2_t v21 = vmla_lane_f32(vmul_n_f32(v18, *(float *)&v8), v20, *(float32x2_t *)&v8, 1);
        float v22 = atan2f(v21.f32[1], v21.f32[0]);
        __float2 v23 = __sincosf_stret((float)((float)(v11 + -0.43633) / -0.17453) * v22);
        double v8 = COERCE_DOUBLE(vmla_n_f32(vmul_n_f32(v31, v23.__sinval), v34, v23.__cosval));
      }
    }

    LODWORD(v9) = vdup_lane_s32(*(int32x2_t *)&v8, 1).u32[0];
    *((float *)&v9 + 1) = -*(float *)&v8;
    return vzip1_s32(*(int32x2_t *)&v8, *(int32x2_t *)&v9);
  }

  double v8 = COERCE_DOUBLE(vdiv_f32(v5, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v7.f32, 0)));
  v7.i32[0] = HIDWORD(v8);
  *(float *)v3.i32 = -*((float *)&v8 + 1);
  double v9 = COERCE_DOUBLE(vzip1_s32(v3, *(int32x2_t *)&v8));
  if (v4 > 0.7854)
  {
    v7.f32[1] = -*(float *)&v8;
    double v9 = *(double *)v7.i64;
  }

  return vzip1_s32(*(int32x2_t *)&v8, *(int32x2_t *)&v9);
}

void sub_1002CA9CC(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 3) != a2)
  {
    int v2 = a2;
    *(_BYTE *)(a1 + 3) = a2;
    float v4 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      float32x2_t v5 = "NO";
      if (v2) {
        float32x2_t v5 = "YES";
      }
      int v8 = 136315138;
      double v9 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#sa_algo,Target motion state changed to %s",  (uint8_t *)&v8,  0xCu);
      int v2 = *(unsigned __int8 *)(a1 + 3);
    }

    if (v2)
    {
      float32x4_t v6 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#sa_algo,Target started moving - resetting",  (uint8_t *)&v8,  2u);
      }

      if (*(_BYTE *)(a1 + 368))
      {
        float32x4_t v7 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "#sa_algo,Target started moving - passing the cached measurement to the range filter without VIO",  (uint8_t *)&v8,  2u);
          if (!*(_BYTE *)(a1 + 368)) {
            sub_100006080();
          }
        }

        sub_1002C68A4(a1, a1 + 184);
      }

      sub_1002C6A40(a1);
    }
  }

void *sub_1002CAB48(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    float32x4_t v6 = result;
    __n128 result = sub_10001EFC0(result, a4);
    uint64_t v7 = v6[1];
    uint64_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8 - 4);
    }
    v6[1] = v7 + v8;
  }

  return result;
}

void sub_1002CABA4(_Unwind_Exception *exception_object)
{
  int32x2_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_1002CABC0(float32x4_t a1, float32x4_t a2, float a3)
{
  float v5 = 1.0 - a3;
  float32x4_t v6 = vsubq_f32(a1, a2);
  int8x16_t v7 = (int8x16_t)vmulq_f32(v6, v6);
  float32x4_t v8 = vaddq_f32(a1, a2);
  int8x16_t v9 = (int8x16_t)vmulq_f32(v8, v8);
  float v10 = atan2f( sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v7.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL)))),  sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v9.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v9, v9, 8uLL)))));
  float v11 = v10 + v10;
  float v12 = v11 * a3;
  if (v12 != 0.0) {
    sinf(v12);
  }
}

_BYTE *sub_1002CAD1C(_BYTE *a1, uint64_t *a2)
{
  *a1 = 0;
  a1[48] = 0;
  sub_1002CAD64((uint64_t)a1, a2);
  return a1;
}

void sub_1002CAD48(_Unwind_Exception *exception_object)
{
  if (*(_BYTE *)(v1 + 48)) {
    sub_1003A7EA8(v1);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002CAD64(uint64_t a1, uint64_t *a2)
{
  if (*((_BYTE *)a2 + 48))
  {
    double v4 = *(double *)a2;
    *(void *)(a1 + 5) = *(uint64_t *)((char *)a2 + 5);
    *(double *)a1 = v4;
    *(void *)(a1 + 24) = 0LL;
    *(void *)(a1 + 32) = 0LL;
    *(void *)(a1 + 16) = 0LL;
    sub_1002CAB48((void *)(a1 + 16), (const void *)a2[2], a2[3], 0xCF3CF3CF3CF3CF3DLL * ((a2[3] - a2[2]) >> 3));
    double result = *((double *)a2 + 5);
    *(double *)(a1 + 40) = result;
    *(_BYTE *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
  }

  return result;
}

uint64_t sub_1002CADE0(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_1002CADEC(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_1002CAE0C(uint64_t a1, char *a2, uint64_t a3)
{
  unsigned int v3 = *(_DWORD *)(a1 + 8);
  if (v3 >= 2)
  {
    unsigned int v5 = *(_DWORD *)(a1 + 12);
    if (v5 >= 2)
    {
      if (!a2) {
        sub_1003A7EC0(a1, 0LL, a3);
      }
      int v7 = v5 + v3 - *(_DWORD *)(a1 + 20);
      if (v7 <= 0) {
        sub_1003A7EE4(a1, (uint64_t)a2, a3);
      }
      bzero(a2, *(unsigned int *)(a1 + 16));
      int v8 = *(_DWORD *)(a1 + 16);
      if (v8 >= 3)
      {
        uint64_t v9 = (v8 - 1);
        uint64_t v10 = *(void *)(a1 + 32);
        uint64_t v11 = 1LL;
        do
        {
          float v12 = &a2[v11];
          if (!a2[v11])
          {
            uint64_t v13 = *(void *)(v10 + 8 * v11);
            int v14 = v11;
            do
            {
              int v14 = v14 * v7 % (int)v9;
              uint64_t v15 = *(void *)(v10 + 8LL * v14);
              *(void *)(v10 + 8LL * v14) = v13;
              char *v12 = 1;
              float v12 = &a2[v14];
              uint64_t v13 = v15;
            }

            while (!*v12);
          }

          ++v11;
        }

        while (v11 != v9);
      }
    }
  }

_DWORD *sub_1002CAEDC(_DWORD *result, int a2, int a3)
{
  if (a2 < 0) {
    sub_1003A7F08();
  }
  if (result[6] < a2) {
    sub_1003A7F30();
  }
  if (a3 < 0) {
    sub_1003A7F58();
  }
  if (result[7] < a3) {
    sub_1003A7F80();
  }
  result[2] = a2;
  result[3] = a3;
  result[4] = a3 * a2;
  result[5] = a2;
  return result;
}

uint64_t sub_1002CAF28(uint64_t result, double a2)
{
  int v2 = *(int64x2_t **)(result + 32);
  if (!v2) {
    sub_1003A7FA8();
  }
  uint64_t v3 = *(unsigned int *)(result + 16);
  if ((int)v3 > 3)
  {
    double v4 = (int64x2_t *)((char *)v2 + 8 * (v3 - 2));
    uint64_t v5 = (v3 - 1) >> 1;
    int64x2_t v6 = vdupq_lane_s64(*(uint64_t *)&a2, 0);
    do
    {
      *v2++ = v6;
      --v5;
    }

    while (v5);
    *double v4 = v6;
  }

  else if ((int)v3 >= 1)
  {
    do
    {
      *(double *)v2->i64 = a2;
      int v2 = (int64x2_t *)((char *)v2 + 8);
      --v3;
    }

    while (v3);
  }

  return result;
}

uint64_t sub_1002CAF90(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_1002CAF9C(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_1002CAFE8(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x20;
  unint64_t v4 = v2 - 32;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    int64x2_t v6 = (char *)a1[3];
    a1[4] = v4;
    int v7 = (void *)a1[1];
    int v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)int v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      float32x2_t v34 = (char *)sub_1000472C0(v5, v33);
      __n128 v35 = &v34[8 * (v33 >> 2)];
      __int128 v37 = &v34[8 * v36];
      float v38 = (uint64_t *)a1[1];
      int v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        int v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        double v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)double v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_1002CB2B0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1002CB300(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_1002CB30C(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t sub_1002CB32C(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2) {
    sub_1003A7FD0();
  }
  if ((a2 & 0x80000000) != 0) {
    sub_1003A7FF8();
  }
  return v2 + 8LL * a2;
}

double *sub_1002CB364(uint64_t a1, _DWORD *a2)
{
  if ((_DWORD *)a1 == a2) {
    sub_1003A8048();
  }
  double result = (double *)sub_1002CAEDC(a2, *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 8));
  int v5 = a2[2];
  if (v5)
  {
    int v6 = 0;
    int v7 = a2[3];
    do
    {
      if (v7)
      {
        for (int i = 0; i != v7; ++i)
        {
          double v9 = sub_10024061C(a1, i, v6);
          double result = (double *)sub_1002CB40C((uint64_t)a2, v6, i);
          *double result = v9;
        }
      }

      ++v6;
    }

    while (v6 != v5);
  }

  return result;
}

uint64_t sub_1002CB40C(uint64_t a1, int a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (!v3) {
    sub_1003A8070();
  }
  unsigned int v4 = a2 + *(_DWORD *)(a1 + 20) * a3;
  if ((v4 & 0x80000000) != 0) {
    sub_1003A8098();
  }
  return v3 + 8LL * v4;
}

float64x2_t sub_1002CB44C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4 = *(_DWORD *)(a1 + 8);
  if (v4 != *(_DWORD *)(a2 + 8)) {
    sub_1003A8160();
  }
  int v7 = *(_DWORD *)(a1 + 12);
  if (v7 != *(_DWORD *)(a2 + 12)) {
    sub_1003A8138();
  }
  if (a1 == a3) {
    sub_1003A80E8();
  }
  if (a2 == a3) {
    sub_1003A8110();
  }
  sub_1002CAEDC((_DWORD *)a3, v4, v7);
  uint64_t v9 = *(unsigned int *)(a3 + 16);
  if ((int)v9 > 3)
  {
    uint64_t v16 = *(float64x2_t **)(a1 + 32);
    uint64_t v17 = *(float64x2_t **)(a2 + 32);
    uint64_t v18 = (float64x2_t *)((char *)v16 + 8 * (v9 - 2));
    int32x2_t v19 = *(float64x2_t **)(a3 + 32);
    int64_t v20 = (float64x2_t *)((char *)v17 + 8 * (v9 - 2));
    uint64_t v21 = (float64x2_t *)((char *)v19 + 8 * (v9 - 2));
    uint64_t v22 = (v9 - 1) >> 1;
    do
    {
      float64x2_t v23 = *v16++;
      float64x2_t v24 = v23;
      float64x2_t v25 = *v17++;
      *v19++ = vsubq_f64(v24, v25);
      --v22;
    }

    while (v22);
    float64x2_t result = vsubq_f64(*v18, *v20);
    *uint64_t v21 = result;
  }

  else if ((int)v9 >= 1)
  {
    uint64_t v10 = *(double **)(a1 + 32);
    uint64_t v11 = *(double **)(a2 + 32);
    uint64_t v12 = *(float64_t **)(a3 + 32);
    do
    {
      double v13 = *v10++;
      double v14 = v13;
      double v15 = *v11++;
      result.f64[0] = v14 - v15;
      *v12++ = result.f64[0];
      --v9;
    }

    while (v9);
  }

  return result;
}

void sub_1002CB548(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t __ldb = *(unsigned int *)(a1 + 12);
  if ((_DWORD)__ldb != *(_DWORD *)(a2 + 8)) {
    sub_1003A81D8();
  }
  if (a1 == a3) {
    sub_1003A8188();
  }
  if (a2 == a3) {
    sub_1003A81B0();
  }
  uint64_t v7 = *(unsigned int *)(a1 + 8);
  uint64_t v8 = *(unsigned int *)(a2 + 12);
  sub_1002CAEDC((_DWORD *)a3, *(_DWORD *)(a1 + 8), *(_DWORD *)(a2 + 12));
  else {
    int v9 = __ldb;
  }
  uint64_t v10 = *(const double **)(a1 + 32);
  if (v9 > 5)
  {
    cblas_dgemm( CblasColMajor,  CblasNoTrans,  CblasNoTrans,  v7,  v8,  __ldb,  1.0,  v10,  v7,  *(const double **)(a2 + 32),  __ldb,  0.0,  *(double **)(a3 + 32),  *(_DWORD *)(a3 + 8));
  }

  else if ((_DWORD)v8)
  {
    uint64_t v11 = 0LL;
    uint64_t v12 = *(double **)(a2 + 32);
    uint64_t v13 = *(void *)(a3 + 32);
    do
    {
      if ((_DWORD)v7)
      {
        uint64_t v14 = 0LL;
        double v15 = (double *)v10;
        do
        {
          double v16 = 0.0;
          if ((_DWORD)__ldb)
          {
            uint64_t v17 = __ldb;
            uint64_t v18 = v12;
            int32x2_t v19 = v15;
            do
            {
              double v20 = *v18++;
              double v16 = v16 + *v19 * v20;
              v19 += v7;
              --v17;
            }

            while (v17);
          }

          *(double *)(v13 + 8 * (v11 * v7 + v14++)) = v16;
          ++v15;
        }

        while (v14 != v7);
      }

      ++v11;
      v12 += __ldb;
    }

    while (v11 != v8);
  }

void sub_1002CB6A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char *__s1)
{
  if (a1 == a2) {
    sub_1003A8200();
  }
  if (a1 == a3) {
    sub_1003A8228();
  }
  if (a1 == a4) {
    sub_1003A8250();
  }
  if (a2 == a3) {
    sub_1003A8278();
  }
  if (a2 == a4) {
    sub_1003A82A0();
  }
  if (a3 == a4) {
    sub_1003A82C8();
  }
  uint64_t v9 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v9)
  {
    uint64_t v11 = *(unsigned int *)(a1 + 8);
    uint64_t v12 = *(unsigned int *)(a1 + 12);
    int v13 = strcmp(__s1, "2");
    if ((_DWORD)v11 == 1 || (_DWORD)v12 == 1)
    {
      if (v13)
      {
        if (!strcmp(__s1, "1"))
        {
          __int128 v37 = *(double **)(a1 + 32);
          double v38 = fabs(*v37);
          if (v9 >= 2)
          {
            uint64_t v39 = v37 + 1;
            uint64_t v40 = v9 - 1;
            do
            {
              double v41 = *v39++;
              double v38 = v38 + fabs(v41);
              --v40;
            }

            while (v40);
          }
        }

        else if (!strcmp(__s1, "inf"))
        {
          uint64_t v53 = *(double **)(a1 + 32);
          double v54 = fabs(*v53);
          if (v9 >= 2)
          {
            __int128 v55 = v53 + 1;
            uint64_t v56 = v9 - 1;
            do
            {
              double v57 = *v55++;
              double v58 = fabs(v57);
              if (v58 > v54) {
                double v54 = v58;
              }
              --v56;
            }

            while (v56);
          }
        }

        else if (!strcmp(__s1, "-inf"))
        {
          int v59 = *(double **)(a1 + 32);
          double v60 = fabs(*v59);
          if (v9 >= 2)
          {
            std::stringbuf::string_type v61 = v59 + 1;
            uint64_t v62 = v9 - 1;
            do
            {
              double v63 = *v61++;
              double v64 = fabs(v63);
              if (v64 < v60) {
                double v60 = v64;
              }
              --v62;
            }

            while (v62);
          }
        }

        else
        {
          double v75 = 0.0;
          if (sscanf(__s1, "%lg", &v75) != 1) {
            sub_1003A8364();
          }
          double v19 = v75;
          if (fabs(v75) >= 2.22044605e-16)
          {
            std::stringbuf::string_type v65 = *(double **)(a1 + 32);
            double v66 = pow(fabs(*v65), v75);
            if (v9 >= 2)
            {
              std::stringbuf::string_type v67 = v65 + 1;
              uint64_t v68 = v9 - 1;
              do
              {
                double v69 = *v67++;
                double v66 = v66 + pow(fabs(v69), v19);
                --v68;
              }

              while (v68);
            }

            pow(v66, 1.0 / v19);
          }
        }
      }

      else
      {
        double v20 = *(double **)(a1 + 32);
        double v21 = *v20 * *v20;
        if (v9 >= 2)
        {
          uint64_t v22 = v20 + 1;
          uint64_t v23 = v9 - 1;
          do
          {
            double v24 = *v22++;
            double v21 = v21 + v24 * v24;
            --v23;
          }

          while (v23);
        }
      }
    }

    else if (v13)
    {
      if (!strcmp(__s1, "1"))
      {
        if ((_DWORD)v12)
        {
          uint64_t v25 = 0LL;
          uint64_t v26 = *(void *)(a1 + 32);
          double v27 = *(double **)(a2 + 32);
          int v28 = 1;
          do
          {
            double v29 = fabs(*(double *)(v26 + 8LL * (v11 * v25)));
            v27[v25] = v29;
            uint64_t v30 = v11 - 1;
            unsigned int v31 = v28;
            if (v11 >= 2)
            {
              do
              {
                double v29 = v29 + fabs(*(double *)(v26 + 8LL * v31));
                v27[v25] = v29;
                ++v31;
                --v30;
              }

              while (v30);
            }

            ++v25;
            v28 += v11;
          }

          while (v25 != v12);
          double v32 = *v27;
          unint64_t v33 = v27 + 1;
          uint64_t v34 = v12 - 1;
          do
          {
            double v35 = *v33++;
            double v36 = v35;
            if (v35 > v32) {
              double v32 = v36;
            }
            --v34;
          }

          while (v34);
        }
      }

      else if (!strcmp(__s1, "inf"))
      {
        if ((_DWORD)v11)
        {
          uint64_t v42 = *(double **)(a1 + 32);
          uint64_t v43 = *(double **)(a2 + 32);
          uint64_t v44 = v11;
          do
          {
            double v45 = *v42++;
            *v43++ = fabs(v45);
            --v44;
          }

          while (v44);
        }

        if (v12 <= 1)
        {
          uint64_t v47 = *(double **)(a2 + 32);
        }

        else
        {
          uint64_t v46 = *(void *)(a1 + 32);
          uint64_t v47 = *(double **)(a2 + 32);
          int v48 = 1;
          unsigned int v49 = v11;
          do
          {
            uint64_t v50 = v11;
            unsigned int v51 = v49;
            uint64_t v52 = v47;
            if ((_DWORD)v11)
            {
              do
              {
                double *v52 = fabs(*(double *)(v46 + 8LL * v51)) + *v52;
                ++v52;
                ++v51;
                --v50;
              }

              while (v50);
            }

            ++v48;
            v49 += v11;
          }

          while (v48 != (_DWORD)v12);
        }

        double v70 = *v47;
        if (v11 >= 2)
        {
          uint64_t v71 = v47 + 1;
          uint64_t v72 = v11 - 1;
          do
          {
            double v73 = *v71++;
            double v74 = v73;
            if (v73 > v70) {
              double v70 = v74;
            }
            --v72;
          }

          while (v72);
        }
      }

      else
      {
        if (strcmp(__s1, "fro")) {
          sub_1003A8318();
        }
        uint64_t v14 = *(double **)(a1 + 32);
        double v15 = *v14 * *v14;
        if (v9 >= 2)
        {
          double v16 = v14 + 1;
          uint64_t v17 = v9 - 1;
          do
          {
            double v18 = *v16++;
            double v15 = v15 + v18 * v18;
            --v17;
          }

          while (v17);
        }
      }
    }

    else
    {
      sub_1002CBB94(a1, a2, a3, a4);
    }
  }

void *sub_1002CBB20(void *result)
{
  *float64x2_t result = off_1007AED90;
  return result;
}

uint64_t sub_1002CBB34(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_1002CBB40(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

_DWORD *sub_1002CBB94(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v5 = *(_DWORD *)(a1 + 12);
  if (v5 <= v6) {
    int v7 = *(_DWORD *)(a1 + 8);
  }
  else {
    int v7 = *(_DWORD *)(a1 + 12);
  }
  if (v5 >= v6) {
    unsigned int v8 = *(_DWORD *)(a1 + 8);
  }
  else {
    unsigned int v8 = *(_DWORD *)(a1 + 12);
  }
  if (a1 == a2) {
    sub_1003A83B0();
  }
  if (a1 == a3) {
    sub_1003A83D8();
  }
  if (a1 == a4) {
    sub_1003A8400();
  }
  if (a2 == a3) {
    sub_1003A8428();
  }
  if (a2 == a4) {
    sub_1003A8450();
  }
  if (a3 == a4) {
    sub_1003A8478();
  }
  unsigned int v11 = *(_DWORD *)(a3 + 28) * *(_DWORD *)(a3 + 24);
  if (!v11) {
    sub_1003A84A0();
  }
  if (v11 < 3 * v8 + v7) {
    sub_1003A84C8();
  }
  if (v11 < 5 * v8) {
    sub_1003A84F0();
  }
  if (*(_DWORD *)(a2 + 24) < v6) {
    sub_1003A8518();
  }
  if (*(_DWORD *)(a2 + 28) < v5) {
    sub_1003A8540();
  }
  if (*(_DWORD *)(a4 + 24) < v8) {
    sub_1003A8568();
  }
  if (!*(_DWORD *)(a4 + 28)) {
    sub_1003A8590();
  }
  sub_1002CBDC8(a2, a1);
  __CLPK_integer v12 = *(_DWORD *)(a2 + 8);
  __CLPK_integer v13 = *(_DWORD *)(a2 + 12);
  uint64_t v14 = *(__CLPK_doublereal **)(a2 + 32);
  double v15 = *(__CLPK_doublereal **)(a4 + 32);
  double v16 = *(__CLPK_doublereal **)(a3 + 32);
  char __jobu = 78;
  char __jobvt = 78;
  __CLPK_integer __n = v13;
  __CLPK_integer __m = v12;
  __CLPK_integer __lda = v12;
  __CLPK_integer __ldvt = 1;
  __CLPK_integer __ldu = 1;
  __lworuint64_t k = v11;
  uint64_t v17 = (cnprint::CNPrinter *)dgesvd_( &__jobu,  &__jobvt,  &__m,  &__n,  v14,  &__lda,  v15,  0LL,  &__ldu,  0LL,  &__ldvt,  v16,  &__lwork,  &v20);
  __CLPK_integer v18 = v20;
  if (v20)
  {
    LOWORD(__m) = 4;
    if (v20 < 0) {
      LOBYTE(__n) = 5;
    }
    else {
      LOBYTE(__n) = 4;
    }
    uint64_t v17 = (cnprint::CNPrinter *)cnprint::CNPrinter::Print(&__m, &__n);
  }

  if (v11 < **(double **)(a3 + 32) && cnprint::CNPrinter::GetLogLevel(v17) <= 1)
  {
    LOWORD(__m) = 4;
    LOBYTE(__n) = 1;
    cnprint::CNPrinter::Print(&__m, &__n);
  }

  if (v18) {
    sub_1003A85B8();
  }
  sub_1002CAEDC((_DWORD *)a3, *(_DWORD *)(a3 + 24), *(_DWORD *)(a3 + 28));
  return sub_1002CAEDC((_DWORD *)a4, v8, 1);
}

__n128 sub_1002CBDC8(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    unsigned int v2 = *(_DWORD *)(a2 + 8);
    if (*(_DWORD *)(a1 + 24) < v2) {
      sub_1003A85E0();
    }
    unsigned int v3 = *(_DWORD *)(a2 + 12);
    if (*(_DWORD *)(a1 + 28) < v3) {
      sub_1003A8608();
    }
    *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v2;
    *(_DWORD *)(a1 + 12) = v3;
    uint64_t v4 = v3 * v2;
    *(_DWORD *)(a1 + 16) = v4;
    *(_DWORD *)(a1 + 20) = v2;
    int v5 = *(_DWORD *)(a2 + 16);
    if (v5 > 3)
    {
      uint64_t v10 = *(_OWORD **)(a1 + 32);
      unsigned int v11 = *(__int128 **)(a2 + 32);
      __CLPK_integer v12 = (__n128 *)((char *)v10 + 8 * (v5 - 2));
      __CLPK_integer v13 = (__n128 *)((char *)v11 + 8 * (v5 - 2));
      uint64_t v14 = (v5 - 1) >> 1;
      do
      {
        __int128 v15 = *v11++;
        *v10++ = v15;
        --v14;
      }

      while (v14);
      __n128 result = *v13;
      __n128 *v12 = *v13;
    }

    else if ((int)v4 >= 1)
    {
      unsigned int v6 = *(unint64_t **)(a2 + 32);
      int v7 = *(unint64_t **)(a1 + 32);
      do
      {
        unint64_t v8 = *v6++;
        result.n128_u64[0] = v8;
        *v7++ = v8;
        --v4;
      }

      while (v4);
    }
  }

  return result;
}

void *sub_1002CBE78(uint64_t a1, uint64_t a2)
{
  __n128 result = *(void **)a1;
  if (a2)
  {
    uint64_t v4 = a2 + ((uint64_t)(*(void *)(a1 + 8) - *result) >> 7);
    if (v4 < 1) {
      result -= (unint64_t)(31 - v4) >> 5;
    }
    else {
      result += (unint64_t)v4 >> 5;
    }
  }

  return result;
}

uint64_t sub_1002CBEDC(void *a1, int a2)
{
  uint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  if (v2 == v3) {
    uint64_t v4 = 0LL;
  }
  else {
    uint64_t v4 = 4 * (v2 - v3) - 1;
  }
  unint64_t v5 = v4 - (a1[5] + a1[4]);
  if (v5 < 0x20) {
    a2 = 1;
  }
  if (v5 < 0x40) {
    int v7 = a2;
  }
  else {
    int v7 = 0;
  }
  if ((v7 & 1) == 0)
  {
    operator delete(*(void **)(v2 - 8));
    a1[2] -= 8LL;
  }

  return v7 ^ 1u;
}

__n128 sub_1002CBF48@<Q0>( char **a1@<X1>, char *a2@<X2>, char **a3@<X3>, char *a4@<X4>, void *a5@<X5>, char *a6@<X6>, __n128 *a7@<X8>)
{
  if (a1 == a3)
  {
    double v19 = a2;
    __CLPK_integer v18 = a4;
    __int128 v15 = a5;
    double v16 = a6;
  }

  else
  {
    __CLPK_integer v13 = a3 - 1;
    __CLPK_integer v12 = *a3;
    uint64_t v14 = a4;
    __int128 v15 = a5;
    double v16 = a6;
    while (1)
    {
      sub_1002CC014(v12, v14, v15, v16, &v21);
      double v16 = (char *)v22.n128_u64[1];
      __int128 v15 = (void *)v22.n128_u64[0];
      if (v13 == a1) {
        break;
      }
      uint64_t v17 = *v13--;
      __CLPK_integer v12 = v17;
      uint64_t v14 = v17 + 4096;
    }

    __CLPK_integer v18 = *a1 + 4096;
    double v19 = a2;
  }

  sub_1002CC014(v19, v18, v15, v16, &v21);
  __n128 result = v22;
  a7->n128_u64[0] = (unint64_t)a3;
  a7->n128_u64[1] = (unint64_t)a4;
  a7[1] = result;
  return result;
}

void *sub_1002CC014@<X0>(char *a1@<X1>, char *a2@<X2>, void *a3@<X3>, char *a4@<X4>, void *a5@<X8>)
{
  unsigned int v6 = a3;
  if (a1 == a2)
  {
    uint64_t v9 = a1;
  }

  else
  {
    uint64_t v9 = a2;
    uint64_t v10 = *a3;
    unsigned int v11 = a2;
    while (1)
    {
      uint64_t v12 = (uint64_t)&a4[-v10];
      if ((v11 - a1) >> 7 >= v12 >> 7) {
        uint64_t v13 = v12 >> 7;
      }
      else {
        uint64_t v13 = (v11 - a1) >> 7;
      }
      v11 -= 128 * v13;
      a4 -= 128 * v13;
      if (v13) {
        __n128 result = memmove(a4, v11, (v13 << 7) - 8);
      }
      if (v11 == a1) {
        break;
      }
      uint64_t v15 = *--v6;
      uint64_t v10 = v15;
      a4 = (char *)(v15 + 4096);
    }

    if ((char *)(*v6 + 4096LL) == a4)
    {
      double v16 = (char *)v6[1];
      ++v6;
      a4 = v16;
    }
  }

  *a5 = v9;
  a5[1] = v6;
  a5[2] = a4;
  return result;
}

double sub_1002CC0D0(char **a1, char *__src, char **a3, char *a4, uint64_t a5)
{
  if (a1 == a3)
  {
    unsigned int v11 = *(void ***)a5;
    uint64_t v12 = *(char **)(a5 + 8);
    uint64_t v10 = __src;
  }

  else
  {
    unint64_t v8 = a1 + 1;
    sub_1002CC19C(__src, *(char **)(a5 + 8), *a1 + 4096, *(void ***)a5, &v14);
    for (*(_OWORD *)a5 = v15; v8 != a3; *(_OWORD *)a5 = v15)
    {
      uint64_t v9 = *v8++;
      sub_1002CC19C(v9, *(char **)(a5 + 8), v9 + 4096, *(void ***)a5, &v14);
    }

    uint64_t v10 = *a3;
    unsigned int v11 = *(void ***)a5;
    uint64_t v12 = *(char **)(a5 + 8);
  }

  sub_1002CC19C(v10, v12, a4, v11, &v14);
  double result = *(double *)&v15;
  *(_OWORD *)a5 = v15;
  return result;
}

char *sub_1002CC19C@<X0>(char *__src@<X0>, char *__dst@<X3>, char *a3@<X1>, void **a4@<X2>, char **a5@<X8>)
{
  unsigned int v6 = a4;
  if (__src != a3)
  {
    uint64_t v9 = __src;
    unsigned int v6 = a4 + 1;
    uint64_t v10 = (char *)*a4;
    while (1)
    {
      uint64_t v11 = v10 - __dst + 4096;
      uint64_t v12 = (a3 - v9) >> 7 >= v11 >> 7 ? v11 >> 7 : (a3 - v9) >> 7;
      if (v12) {
        __src = (char *)memmove(__dst, v9, (v12 << 7) - 8);
      }
      v9 += 128 * v12;
      if (v9 == a3) {
        break;
      }
      uint64_t v13 = (char *)*v6++;
      uint64_t v10 = v13;
      __int128 __dst = v13;
    }

    __dst += 128 * v12;
    else {
      --v6;
    }
  }

  *a5 = a3;
  a5[1] = (char *)v6;
  a5[2] = __dst;
  return __src;
}

float64x2_t sub_1002CC25C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4 = *(_DWORD *)(a1 + 8);
  if (v4 != *(_DWORD *)(a2 + 8)) {
    sub_1003A86A8();
  }
  int v7 = *(_DWORD *)(a1 + 12);
  if (v7 != *(_DWORD *)(a2 + 12)) {
    sub_1003A8680();
  }
  if (a1 == a3) {
    sub_1003A8630();
  }
  if (a2 == a3) {
    sub_1003A8658();
  }
  sub_1002CAEDC((_DWORD *)a3, v4, v7);
  uint64_t v9 = *(unsigned int *)(a3 + 16);
  if ((int)v9 > 3)
  {
    double v16 = *(float64x2_t **)(a1 + 32);
    uint64_t v17 = *(float64x2_t **)(a2 + 32);
    __CLPK_integer v18 = (float64x2_t *)((char *)v16 + 8 * (v9 - 2));
    double v19 = *(float64x2_t **)(a3 + 32);
    __CLPK_integer v20 = (float64x2_t *)((char *)v17 + 8 * (v9 - 2));
    uint64_t v21 = (float64x2_t *)((char *)v19 + 8 * (v9 - 2));
    uint64_t v22 = (v9 - 1) >> 1;
    do
    {
      float64x2_t v23 = *v16++;
      float64x2_t v24 = v23;
      float64x2_t v25 = *v17++;
      *v19++ = vaddq_f64(v24, v25);
      --v22;
    }

    while (v22);
    float64x2_t result = vaddq_f64(*v18, *v20);
    *uint64_t v21 = result;
  }

  else if ((int)v9 >= 1)
  {
    uint64_t v10 = *(double **)(a1 + 32);
    uint64_t v11 = *(double **)(a2 + 32);
    uint64_t v12 = *(float64_t **)(a3 + 32);
    do
    {
      double v13 = *v10++;
      double v14 = v13;
      double v15 = *v11++;
      result.f64[0] = v14 + v15;
      *v12++ = result.f64[0];
      --v9;
    }

    while (v9);
  }

  return result;
}

void sub_1002CC358(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
}

void sub_1002CC360(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
}

uint64_t sub_1002CC368()
{
  return cnprint::CNPrinter::Print(v0 - 4, v0 - 1);
}

uint64_t sub_1002CC374()
{
  qword_1007FE5B0 = 0LL;
  qword_1007FE5B8 = 0LL;
  qword_1007FE5C0 = 0LL;
  uint64_t v0 = operator new(0x40uLL);
  qword_1007FE5B8 = (uint64_t)(v0 + 4);
  qword_1007FE5C0 = (uint64_t)(v0 + 4);
  _OWORD *v0 = xmmword_10042DBC0;
  v0[1] = unk_10042DBD0;
  v0[2] = xmmword_10042DBE0;
  v0[3] = unk_10042DBF0;
  qword_1007FE5B0 = (uint64_t)v0;
  __cxa_atexit((void (*)(void *))sub_100028CC4, &qword_1007FE5B0, (void *)&_mh_execute_header);
  qword_1007FE5D0 = 0LL;
  unk_1007FE5D8 = 0LL;
  qword_1007FE5C8 = 0LL;
  uint64_t v1 = operator new(0x10uLL);
  qword_1007FE5D0 = (uint64_t)(v1 + 1);
  unk_1007FE5D8 = v1 + 1;
  _OWORD *v1 = xmmword_10042DC00;
  qword_1007FE5C8 = (uint64_t)v1;
  return __cxa_atexit((void (*)(void *))sub_100028CC4, &qword_1007FE5C8, (void *)&_mh_execute_header);
}

uint64_t sub_1002CC430(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)a2;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_BYTE *)(a1 + 72) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_BYTE *)(a1 + 64) = 0;
  *(void *)a1 = off_1007BC620;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)a2;
  sub_100201E2C((uint64_t *)(a1 + 96), a2 + 16);
  __int128 v4 = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 132) = *(_OWORD *)(a2 + 52);
  *(_OWORD *)(a1 + 120) = v4;
  sub_100201F04(a1 + 152, (__int128 *)(a2 + 72));
  __int128 v5 = *(_OWORD *)(a2 + 104);
  *(_OWORD *)(a1 + 200) = *(_OWORD *)(a2 + 120);
  *(_OWORD *)(a1 + 184) = v5;
  __int128 v6 = *(_OWORD *)(a2 + 136);
  __int128 v7 = *(_OWORD *)(a2 + 152);
  __int128 v8 = *(_OWORD *)(a2 + 168);
  *(_OWORD *)(a1 + 264) = *(_OWORD *)(a2 + 184);
  *(_OWORD *)(a1 + 24_Block_object_dispose((const void *)(v1 - 112), 8) = v8;
  *(_OWORD *)(a1 + 232) = v7;
  *(_OWORD *)(a1 + 216) = v6;
  __int128 v9 = *(_OWORD *)(a2 + 200);
  __int128 v10 = *(_OWORD *)(a2 + 216);
  __int128 v11 = *(_OWORD *)(a2 + 232);
  *(_OWORD *)(a1 + 32_Block_object_dispose((const void *)(v1 - 112), 8) = *(_OWORD *)(a2 + 248);
  *(_OWORD *)(a1 + 312) = v11;
  *(_OWORD *)(a1 + 296) = v10;
  *(_OWORD *)(a1 + 280) = v9;
  __int128 v12 = *(_OWORD *)(a2 + 264);
  __int128 v13 = *(_OWORD *)(a2 + 280);
  __int128 v14 = *(_OWORD *)(a2 + 296);
  *(void *)(a1 + 392) = *(void *)(a2 + 312);
  *(_OWORD *)(a1 + 360) = v13;
  *(_OWORD *)(a1 + 376) = v14;
  *(_OWORD *)(a1 + 344) = v12;
  *(_BYTE *)(a1 + 400) = 0;
  *(void *)(a1 + 40_Block_object_dispose((const void *)(v1 - 112), 8) = 0x3FB999999999999ALL;
  *(_OWORD *)(a1 + 416) = xmmword_10042DC90;
  *(_OWORD *)(a1 + 432) = xmmword_10042DCA0;
  *(_OWORD *)(a1 + 44_Block_object_dispose((const void *)(v1 - 112), 8) = xmmword_10042DCB0;
  *(_OWORD *)(a1 + 464) = xmmword_100423D40;
  *(int32x2_t *)(a1 + 480) = vdup_n_s32(0x3DCCCCCDu);
  *(void *)(a1 + 48_Block_object_dispose((const void *)(v1 - 112), 8) = 0x3FE8000000000000LL;
  *(int64x2_t *)(a1 + 496) = vdupq_n_s64(0x3FD999999999999AuLL);
  *(void *)(a1 + 512) = 0LL;
  *(void *)(a1 + 520) = 0LL;
  *(_OWORD *)(a1 + 52_Block_object_dispose((const void *)(v1 - 112), 8) = xmmword_100423CD0;
  *(_DWORD *)(a1 + 544) = 5;
  *(void *)(a1 + 552) = 0x4000000000000000LL;
  *(_DWORD *)(a1 + 560) = 0;
  *(_BYTE *)(a1 + 60_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 616) = 0;
  *(_BYTE *)(a1 + 624) = 0;
  *(_BYTE *)(a1 + 632) = 0;
  *(_BYTE *)(a1 + 636) = 0;
  *(_BYTE *)(a1 + 640) = 0;
  *(_BYTE *)(a1 + 64_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 656) = 0;
  *(_BYTE *)(a1 + 664) = 0;
  *(_BYTE *)(a1 + 672) = 0;
  *(_BYTE *)(a1 + 676) = 0;
  *(_BYTE *)(a1 + 600) = 0;
  *(_OWORD *)(a1 + 56_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_OWORD *)(a1 + 584) = 0u;
  sub_1002CD740(a1 + 680, a2);
  int v15 = *(_DWORD *)(a1 + 196);
  if (v15 == 1)
  {
    double v27 = operator new(0x150uLL);
    sub_1002E4578((uint64_t)v27, a1 + 200);
    uint64_t v28 = *(void *)(a1 + 592);
    *(void *)(a1 + 592) = v27;
    if (v28) {
      (*(void (**)(uint64_t))(*(void *)v28 + 8LL))(v28);
    }
    double v29 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
      sub_1003A86D0(v29, v30, v31, v32, v33, v34, v35, v36);
    }
  }

  else if (v15 == 2)
  {
    double v16 = operator new(0x88uLL);
    __n128 v17 = sub_1002E462C((uint64_t)v16, (__n128 *)(a1 + 376));
    uint64_t v18 = *(void *)(a1 + 592);
    *(void *)(a1 + 592) = v16;
    if (v18) {
      (*(void (**)(uint64_t, __n128))(*(void *)v18 + 8LL))(v18, v17);
    }
    double v19 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
      sub_1003A8704(v19, v20, v21, v22, v23, v24, v25, v26);
    }
  }

  (*(void (**)(uint64_t))(*(void *)a1 + 32LL))(a1);
  return a1;
}

void sub_1002CC6DC(_Unwind_Exception *a1)
{
  __int128 v6 = v4;
  operator delete(v6);
  sub_1002CC780(v3);
  uint64_t v8 = v1[74];
  v1[74] = 0LL;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
  }
  __int128 v9 = *v5;
  if (*v5)
  {
    v1[72] = v9;
    operator delete(v9);
  }

  sub_1001FDEF8((uint64_t)(v1 + 10));
  void *v1 = off_1007BD478;
  sub_1001302F0(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_1002CC780(uint64_t a1)
{
  return a1;
}

double sub_1002CC7C8(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 608)) {
    *(_BYTE *)(a1 + 60_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  }
  if (*(_BYTE *)(a1 + 648)) {
    *(_BYTE *)(a1 + 64_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  }
  if (*(_BYTE *)(a1 + 664)) {
    *(_BYTE *)(a1 + 664) = 0;
  }
  if (*(_BYTE *)(a1 + 624)) {
    *(_BYTE *)(a1 + 624) = 0;
  }
  *(void *)(a1 + 576) = *(void *)(a1 + 568);
  (*(void (**)(void))(**(void **)(a1 + 592) + 32LL))(*(void *)(a1 + 592));
  return sub_1002CC830(a1);
}

double sub_1002CC830(uint64_t a1)
{
  uint64_t v2 = (uint64_t *)(a1 + 104);
  sub_100034A98(a1 + 96, *(void **)(a1 + 104));
  uint64_t v3 = v10;
  *(void *)(a1 + 96) = v9;
  *(void *)(a1 + 104) = v3;
  uint64_t v4 = v11;
  *(void *)(a1 + 112) = v11;
  if (v4)
  {
    _DWORD v3[2] = v2;
    __int128 v9 = &v10;
    __int128 v10 = 0LL;
    uint64_t v11 = 0LL;
    uint64_t v3 = 0LL;
  }

  else
  {
    *(void *)(a1 + 96) = v2;
  }

  sub_100034A98((uint64_t)&v9, v3);
  uint64_t v5 = *v2;
  if (*v2)
  {
    do
    {
      uint64_t v6 = v5;
      uint64_t v5 = *(void *)(v5 + 8);
    }

    while (v5);
  }

  else
  {
    do
    {
      uint64_t v6 = v2[2];
      BOOL v7 = *(void *)v6 == (void)v2;
      uint64_t v2 = (uint64_t *)v6;
    }

    while (v7);
  }

  double result = *(double *)(v6 + 32);
  *(double *)(a1 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = result;
  return result;
}

void sub_1002CC8EC(uint64_t a1@<X0>, __int128 *a2@<X1>, uint64_t a3@<X8>)
{
  double v7 = *(double *)a2;
  uint64_t v6 = *((void *)a2 + 1);
  int v8 = *((_DWORD *)a2 + 4);
  __int128 v9 = (void **)(a1 + 568);
  unint64_t v10 = *(void *)(a1 + 576);
  uint64_t v11 = *(void **)(a1 + 568);
  unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - (void)v11) >> 3);
  unint64_t v13 = *(void *)(a1 + 584);
  if (v12 < *(int *)(a1 + 80))
  {
    if (v10 < v13)
    {
      *(double *)unint64_t v10 = v7;
      *(void *)(v10 + _Block_object_dispose((const void *)(v1 - 112), 8) = v6;
      uint64_t v14 = v10 + 24;
      *(_DWORD *)(v10 + 16) = v8;
      goto LABEL_37;
    }

    unint64_t v16 = v12 + 1;
    if (v12 + 1 <= 0xAAAAAAAAAAAAAAALL)
    {
      unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v11) >> 3);
      if (2 * v17 > v16) {
        unint64_t v16 = 2 * v17;
      }
      if (v17 >= 0x555555555555555LL) {
        unint64_t v18 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v18 = v16;
      }
      if (v18)
      {
        double v19 = (char *)sub_10001E130(a1 + 584, v18);
        unint64_t v10 = *(void *)(a1 + 576);
        uint64_t v11 = *(void **)(a1 + 568);
      }

      else
      {
        double v19 = 0LL;
      }

      uint64_t v24 = &v19[24 * v12];
      uint64_t v25 = &v19[24 * v18];
      *(double *)uint64_t v24 = v7;
      *((void *)v24 + 1) = v6;
      *((_DWORD *)v24 + 4) = v8;
      uint64_t v14 = (uint64_t)(v24 + 24);
      if ((void *)v10 != v11)
      {
        do
        {
          __int128 v26 = *(_OWORD *)(v10 - 24);
          *((void *)v24 - 1) = *(void *)(v10 - 8);
          *(_OWORD *)(v24 - 24) = v26;
          v24 -= 24;
          v10 -= 24LL;
        }

        while ((void *)v10 != v11);
        uint64_t v11 = *v9;
      }

      *(void *)(a1 + 56_Block_object_dispose((const void *)(v1 - 112), 8) = v24;
      *(void *)(a1 + 576) = v14;
      *(void *)(a1 + 584) = v25;
      if (v11) {
        operator delete(v11);
      }
      goto LABEL_37;
    }

void sub_1002CCF00( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24)
{
}

unint64_t sub_1002CCF48(unsigned int *a1, double a2, double a3)
{
  uint64_t v5 = (unsigned int *)*((void *)a1 + 5);
  uint64_t v6 = (double *)(a1 + 12);
  if (v5 == a1 + 12)
  {
    int v7 = 0;
  }

  else
  {
    int v7 = 0;
    int v8 = (double *)*((void *)a1 + 5);
    do
    {
      double v9 = v8[4];
      if (v9 < a2) {
        int v10 = v7;
      }
      else {
        int v10 = v7 + 1;
      }
      if (v9 < a2) {
        break;
      }
      uint64_t v11 = (double *)*((void *)v8 + 1);
      if (v11)
      {
        do
        {
          unint64_t v12 = v11;
          uint64_t v11 = *(double **)v11;
        }

        while (v11);
      }

      else
      {
        do
        {
          unint64_t v12 = (double *)*((void *)v8 + 2);
          BOOL v13 = *(void *)v12 == (void)v8;
          int v8 = v12;
        }

        while (!v13);
      }

      int v7 = v10;
      int v8 = v12;
    }

    while (v12 != v6);
  }

  unint64_t v14 = (v7 + 1);
  unint64_t v15 = *((void *)a1 + 7);
  if (v15 >= v14) {
    uint64_t v16 = (v7 + 1);
  }
  else {
    uint64_t v16 = 0LL;
  }
  unint64_t result = *a1;
  if ((_DWORD)result == -1)
  {
    *a1 = v16;
    return v16;
  }

  if ((_DWORD)result == (_DWORD)v16)
  {
    if (*((_BYTE *)a1 + 16)) {
      *((_BYTE *)a1 + 16) = 0;
    }
    a1[86] = 0;
    return v16;
  }

  int v18 = a1[86] + 1;
  a1[86] = v18;
  if (*((_BYTE *)a1 + 16))
  {
    double v19 = *((double *)a1 + 1);
  }

  else
  {
    *((double *)a1 + 1) = a3;
    *((_BYTE *)a1 + 16) = 1;
    double v19 = a3;
  }

  double v20 = a3 - v19;
  double v21 = *((double *)a1 + 8);
  double v22 = v21 - v20;
  if (v21 - v20 < 0.0) {
    double v22 = 0.0;
  }
  double v23 = v22 / v21;
  int v24 = a1[22];
  int v25 = (v24 - v18) & ~((v24 - v18) >> 31);
  else {
    double v26 = (double)v25 / (double)v24;
  }
  if (v15 >= v14)
  {
    if ((_DWORD)result && v7 >= (int)result)
    {
      *(void *)double v41 = v5;
      sub_1002CD838((void **)v41, (int)result - 1LL);
    }

    else
    {
      *(void *)double v41 = v5;
      sub_1002CD838((void **)v41, v7);
    }

    double v29 = *(double *)(*(void *)v41 + 32LL);
    double v30 = vabdd_f64(a2, v29);
    unint64_t result = *a1;
    if ((int)v14 < (int)result || !(_DWORD)result)
    {
      if (v30 >= v26 * *((double *)a1 + 9))
      {
        unint64_t v36 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v37 = a1[86];
          unsigned int v38 = a1[22];
          uint64_t v39 = *((void *)a1 + 7);
          uint64_t v40 = *((void *)a1 + 8);
          *(_DWORD *)double v41 = 134220032;
          *(void *)&v41[4] = v39;
          __int16 v42 = 2048;
          double v43 = a2;
          __int16 v44 = 2048;
          double v45 = v29;
          __int16 v46 = 2048;
          double v47 = v30;
          __int16 v48 = 2048;
          double v49 = v26;
          __int16 v50 = 1024;
          unsigned int v51 = v37;
          __int16 v52 = 1024;
          unsigned int v53 = v38;
          __int16 v54 = 2048;
          double v55 = v20;
          __int16 v56 = 2048;
          uint64_t v57 = v40;
          _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEFAULT,  "#threshold-detector, threshsize:%zu [in] rssi: %f, rssiBorder: %f, rssiDelta: %f, mindecayfactor: %f, sample s: %d/%d, time: %f/%f",  v41,  0x54u);
        }

        *a1 = v14;
        if (*((_BYTE *)a1 + 16)) {
          *((_BYTE *)a1 + 16) = 0;
        }
        return v14;
      }

      return result;
    }
  }

  else
  {
    double v27 = *(double **)v6;
    if (*(void *)v6)
    {
      do
      {
        uint64_t v28 = v27;
        double v27 = (double *)*((void *)v27 + 1);
      }

      while (v27);
    }

    else
    {
      do
      {
        uint64_t v28 = (double *)*((void *)v6 + 2);
        BOOL v13 = *(void *)v28 == (void)v6;
        uint64_t v6 = v28;
      }

      while (v13);
    }

    double v29 = v28[4];
    double v30 = vabdd_f64(a2, v29);
  }

  if (v30 >= v26 * *((double *)a1 + 10))
  {
    size_t v31 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v32 = a1[86];
      unsigned int v33 = a1[22];
      uint64_t v34 = *((void *)a1 + 7);
      uint64_t v35 = *((void *)a1 + 8);
      *(_DWORD *)double v41 = 134220032;
      *(void *)&v41[4] = v34;
      __int16 v42 = 2048;
      double v43 = a2;
      __int16 v44 = 2048;
      double v45 = v29;
      __int16 v46 = 2048;
      double v47 = v30;
      __int16 v48 = 2048;
      double v49 = v26;
      __int16 v50 = 1024;
      unsigned int v51 = v32;
      __int16 v52 = 1024;
      unsigned int v53 = v33;
      __int16 v54 = 2048;
      double v55 = v20;
      __int16 v56 = 2048;
      uint64_t v57 = v35;
      _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEFAULT,  "#threshold-detector, threshsize:%zu [out] rssi: %f, rssiBorder: %f, rssiDelta: %f, mindecayfactor: %f, samples: %d/%d, time: %f/%f",  v41,  0x54u);
    }

    *a1 = v16;
    if (*((_BYTE *)a1 + 16)) {
      *((_BYTE *)a1 + 16) = 0;
    }
    return v16;
  }

  return result;
}

void sub_1002CD2F8(uint64_t a1, double a2)
{
  if (!*(_BYTE *)(a1 + 636)) {
    sub_100006080();
  }
  float v4 = (float)*(unint64_t *)(a1 + 112);
  int v5 = *(_DWORD *)(a1 + 632);
  if (v5 < 2)
  {
    if (v5 == 1)
    {
      double v8 = *(double *)(*(void *)(a1 + 96) + 32LL);
      double v11 = 1.0;
      float v10 = 1.0;
      double v7 = v8;
    }

    else
    {
      uint64_t v12 = a1 + 104;
      uint64_t v13 = *(void *)(a1 + 104);
      if (v13)
      {
        do
        {
          uint64_t v14 = v13;
          uint64_t v13 = *(void *)(v13 + 8);
        }

        while (v13);
      }

      else
      {
        do
        {
          uint64_t v14 = *(void *)(v12 + 16);
          BOOL v15 = *(void *)v14 == v12;
          uint64_t v12 = v14;
        }

        while (v15);
      }

      double v8 = *(double *)(v14 + 32);
      double v7 = v8 - *(double *)(a1 + 368);
      double v11 = 0.0;
      float v10 = 1.0 / v4;
    }
  }

  else
  {
    uint64_t v6 = (void *)(a1 + 96);
    *(void *)double v21 = *(void *)(a1 + 96);
    sub_1002CD838((void **)v21, (v5 - 1));
    double v7 = *(double *)(*(void *)v21 + 32LL);
    *(void *)double v21 = *v6;
    sub_1002CD838((void **)v21, (v5 - 2));
    double v8 = *(double *)(*(void *)v21 + 32LL);
    float v9 = (float)(v4 - (float)((float)v5 + -1.0)) / v4;
    float v10 = (float)(1.0 / v4) + v9;
    double v11 = v9;
  }

  double v16 = v10;
  double v17 = v10;
  if (v8 > a2)
  {
    double v17 = v11;
    if (v7 < a2) {
      double v17 = v11 + (a2 - v7) / (v8 - v7) * (v16 - v11);
    }
  }

  int v18 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG))
  {
    if (!*(_BYTE *)(a1 + 636)) {
      sub_100006080();
    }
    uint64_t v19 = *(void *)(a1 + 112);
    int v20 = *(_DWORD *)(a1 + 632);
    *(_DWORD *)double v21 = 134219776;
    *(void *)&v21[4] = v19;
    __int16 v22 = 1024;
    int v23 = v20;
    __int16 v24 = 2048;
    double v25 = a2;
    __int16 v26 = 2048;
    double v27 = v17;
    __int16 v28 = 2048;
    double v29 = v7;
    __int16 v30 = 2048;
    double v31 = v8;
    __int16 v32 = 2048;
    double v33 = v11;
    __int16 v34 = 2048;
    double v35 = v16;
    _os_log_debug_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEBUG,  "#threshold-detector, threshsize:%zu, inbubblestate: %d, estimaterssi: %f, scaledoutput: %f, lowerbThresh: %f, uppe rbThresh: %f, tmin: %f, tmax: %f",  v21,  0x4Eu);
  }

void sub_1002CD540(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  float v4 = (uint64_t **)(a1 + 40);
  int v5 = *(double **)(a1 + 40);
  double v6 = *(double *)(a1 + 128);
  double v7 = v5[4];
  v18[0] = 0LL;
  v18[1] = 0LL;
  double v17 = (uint64_t *)v18;
  double v8 = (double *)(a1 + 48);
  if (v5 != (double *)(a1 + 48))
  {
    char v9 = 1;
    do
    {
      double v10 = v5[4];
      if ((v9 & 1) != 0) {
        double v10 = v7 - v6;
      }
      *(double *)__int128 buf = v10;
      sub_1002CD978(&v17, (double *)buf, (uint64_t *)buf);
      double v11 = (double *)*((void *)v5 + 1);
      if (v11)
      {
        do
        {
          uint64_t v12 = v11;
          double v11 = *(double **)v11;
        }

        while (v11);
      }

      else
      {
        do
        {
          uint64_t v12 = (double *)*((void *)v5 + 2);
          BOOL v13 = *(void *)v12 == (void)v5;
          int v5 = v12;
        }

        while (!v13);
      }

      char v9 = 0;
      int v5 = v12;
    }

    while (v12 != v8);
  }

  if (v4 != &v17) {
    sub_100201920(v4, v17, v18);
  }
  *(void *)(a1 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  uint64_t v14 = *(double **)(a1 + 48);
  if (v14)
  {
    do
    {
      BOOL v15 = v14;
      uint64_t v14 = (double *)*((void *)v14 + 1);
    }

    while (v14);
  }

  else
  {
    do
    {
      BOOL v15 = (double *)*((void *)v8 + 2);
      BOOL v13 = *(void *)v15 == (void)v8;
      double v8 = v15;
    }

    while (v13);
  }

  *(double *)(a1 + 32) = v15[4];
  double v16 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134218496;
    *(double *)&uint8_t buf[4] = v6;
    __int16 v20 = 2048;
    double v21 = v7;
    __int16 v22 = 2048;
    double v23 = v7 - v6;
    _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "#threshold-detector, resetRssiOffset originalOffset: %f, originalRssiThresh: %f, newRssiThresh: %f",  buf,  0x20u);
  }

  sub_100201E2C(a2, (uint64_t)v4);
  sub_100034A98((uint64_t)&v17, v18[0]);
}

void sub_1002CD718( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_1002CD734()
{
  return 0LL;
}

uint64_t sub_1002CD740(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = -1;
  *(_BYTE *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)a2;
  sub_100201E2C((uint64_t *)(a1 + 40), a2 + 16);
  __int128 v4 = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 76) = *(_OWORD *)(a2 + 52);
  *(_OWORD *)(a1 + 64) = v4;
  sub_100201F04(a1 + 96, (__int128 *)(a2 + 72));
  __int128 v5 = *(_OWORD *)(a2 + 120);
  *(_OWORD *)(a1 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = *(_OWORD *)(a2 + 104);
  *(_OWORD *)(a1 + 144) = v5;
  __int128 v6 = *(_OWORD *)(a2 + 136);
  __int128 v7 = *(_OWORD *)(a2 + 152);
  __int128 v8 = *(_OWORD *)(a2 + 184);
  *(_OWORD *)(a1 + 192) = *(_OWORD *)(a2 + 168);
  *(_OWORD *)(a1 + 20_Block_object_dispose((const void *)(v1 - 112), 8) = v8;
  *(_OWORD *)(a1 + 160) = v6;
  *(_OWORD *)(a1 + 176) = v7;
  __int128 v9 = *(_OWORD *)(a2 + 200);
  __int128 v10 = *(_OWORD *)(a2 + 216);
  __int128 v11 = *(_OWORD *)(a2 + 248);
  *(_OWORD *)(a1 + 256) = *(_OWORD *)(a2 + 232);
  *(_OWORD *)(a1 + 272) = v11;
  *(_OWORD *)(a1 + 224) = v9;
  *(_OWORD *)(a1 + 240) = v10;
  __int128 v12 = *(_OWORD *)(a2 + 264);
  __int128 v13 = *(_OWORD *)(a2 + 280);
  __int128 v14 = *(_OWORD *)(a2 + 296);
  *(void *)(a1 + 336) = *(void *)(a2 + 312);
  *(_OWORD *)(a1 + 304) = v13;
  *(_OWORD *)(a1 + 320) = v14;
  *(_OWORD *)(a1 + 28_Block_object_dispose((const void *)(v1 - 112), 8) = v12;
  *(_DWORD *)(a1 + 344) = 0;
  return a1;
}

void sub_1002CD808(_Unwind_Exception *a1)
{
}

void sub_1002CD824(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1002CD8C4(a1);
  operator delete(v1);
}

void **sub_1002CD838(void **result, uint64_t a2)
{
  if (a2 < 0)
  {
    __int128 v7 = *result;
    do
    {
      __int128 v8 = (void *)*v7;
      if (*v7)
      {
        do
        {
          __int128 v4 = v8;
          __int128 v8 = (void *)v8[1];
        }

        while (v8);
      }

      else
      {
        do
        {
          __int128 v4 = (void *)v7[2];
          BOOL v5 = *v4 == (void)v7;
          __int128 v7 = v4;
        }

        while (v5);
      }

      __int128 v7 = v4;
    }

    while (!__CFADD__(a2++, 1LL));
  }

  else
  {
    if (!a2) {
      return result;
    }
    uint64_t v2 = *result;
    do
    {
      uint64_t v3 = (void *)v2[1];
      if (v3)
      {
        do
        {
          __int128 v4 = v3;
          uint64_t v3 = (void *)*v3;
        }

        while (v3);
      }

      else
      {
        do
        {
          __int128 v4 = (void *)v2[2];
          BOOL v5 = *v4 == (void)v2;
          uint64_t v2 = v4;
        }

        while (!v5);
      }

      uint64_t v2 = v4;
    }

    while (a2-- > 1);
  }

  *unint64_t result = v4;
  return result;
}

uint64_t sub_1002CD8C4(uint64_t a1)
{
  *(void *)a1 = off_1007BC620;
  sub_100034A98(a1 + 720, *(void **)(a1 + 728));
  uint64_t v2 = *(void *)(a1 + 592);
  *(void *)(a1 + 592) = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  uint64_t v3 = *(void **)(a1 + 568);
  if (v3)
  {
    *(void *)(a1 + 576) = v3;
    operator delete(v3);
  }

  sub_100034A98(a1 + 96, *(void **)(a1 + 104));
  *(void *)a1 = off_1007BD478;
  sub_1001302F0((void *)(a1 + 16));
  return a1;
}

uint64_t *sub_1002CD978(uint64_t **a1, double *a2, uint64_t *a3)
{
  __int128 v6 = a1 + 1;
  BOOL v5 = a1[1];
  if (v5)
  {
    double v7 = *a2;
    while (1)
    {
      while (1)
      {
        __int128 v8 = (uint64_t **)v5;
        double v9 = *((double *)v5 + 4);
        if (v7 <= v9) {
          break;
        }
        BOOL v5 = (uint64_t *)*v5;
        __int128 v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }

      if (v9 <= v7) {
        break;
      }
      BOOL v5 = (uint64_t *)v5[1];
      if (!v5)
      {
        __int128 v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    __int128 v8 = a1 + 1;
LABEL_10:
    __int128 v10 = (uint64_t *)operator new(0x28uLL);
    v10[4] = *a3;
    sub_10001E548(a1, (uint64_t)v8, v6, v10);
    return v10;
  }

  return (uint64_t *)v8;
}

uint64_t sub_1002CDA30()
{
  v8[0] = xmmword_10042DCC0;
  v8[1] = unk_10042DCD0;
  sub_10015EABC((uint64_t)&unk_1007FE5E0, (int *)v8, 4LL);
  xmmword_1007FE5F8 = xmmword_100423CB0;
  unk_1007FE608 = xmmword_100423CC0;
  qword_1007FE620 = 0LL;
  unk_1007FE628 = 0LL;
  qword_1007FE618 = 0x3FD999999999999ALL;
  unk_1007FE630 = xmmword_100423CD0;
  dword_1007FE640 = 5;
  qword_1007FE648 = 0x4000000000000000LL;
  dword_1007FE650 = 5;
  byte_1007FE658 = 0;
  unk_1007FE65C = 0x30000000ALL;
  xmmword_1007FE668 = xmmword_100423CE0;
  unk_1007FE678 = xmmword_100423CF0;
  xmmword_1007FE688 = xmmword_100423D00;
  qword_1007FE698 = 0x3FE3333333333333LL;
  dword_1007FE6A0 = 3;
  xmmword_1007FE6A8 = xmmword_100423D10;
  unk_1007FE6B8 = xmmword_100423CF0;
  xmmword_1007FE6C8 = xmmword_100423CE0;
  qword_1007FE6D8 = 0x3FE3333333333333LL;
  byte_1007FE6E0 = 0;
  xmmword_1007FE6E8 = xmmword_100423D20;
  unk_1007FE6F8 = xmmword_100423D30;
  __asm { FMOV            V0.2D, #1.0 }

  __int128 v6 = _Q0;
  xmmword_1007FE708 = _Q0;
  qword_1007FE718 = 0xBFD3333333333333LL;
  xmmword_1007FE720 = xmmword_100423D40;
  qword_1007FE730 = 0x3E99999A40000000LL;
  xmmword_1007FE738 = xmmword_100423CC0;
  qword_1007FE750 = 0LL;
  unk_1007FE758 = 0LL;
  qword_1007FE748 = 0x3FD999999999999ALL;
  xmmword_1007FE760 = xmmword_100423CD0;
  dword_1007FE770 = 5;
  qword_1007FE778 = 0x4000000000000000LL;
  dword_1007FE780 = 4;
  qword_1007FE788 = 0x300000008LL;
  qword_1007FE790 = 0xC04E800000000000LL;
  unint64_t v7 = 0xC04E800000000000LL;
  sub_10015ED64((uint64_t)&unk_1007FE798, (double *)&v7, 1LL);
  xmmword_1007FE7B0 = xmmword_100423D50;
  qword_1007FE7C0 = 0x4024000000000000LL;
  dword_1007FE7C8 = 45;
  byte_1007FE7D0 = 0;
  byte_1007FE7E8 = 0;
  qword_1007FE7F0 = 0LL;
  byte_1007FE7F8 = 0;
  dword_1007FE7FC = 1;
  byte_1007FE800 = 1;
  xmmword_1007FE808 = xmmword_100423D60;
  unk_1007FE818 = xmmword_100423D70;
  xmmword_1007FE828 = v6;
  qword_1007FE838 = 0xC059000000000000LL;
  xmmword_1007FE840 = xmmword_100423D80;
  qword_1007FE850 = (uint64_t)vdup_n_s32(0x3DCCCCCDu);
  xmmword_1007FE858 = xmmword_100423CC0;
  qword_1007FE868 = 0x3FD999999999999ALL;
  qword_1007FE878 = 0LL;
  qword_1007FE870 = 0LL;
  xmmword_1007FE880 = xmmword_100423CD0;
  dword_1007FE890 = 5;
  qword_1007FE898 = 0x4000000000000000LL;
  dword_1007FE8A0 = 10;
  qword_1007FE8A8 = 0x4034000000000000LL;
  dword_1007FE8B0 = 3;
  xmmword_1007FE8B8 = xmmword_100423D90;
  return __cxa_atexit((void (*)(void *))sub_10015CF8C, &unk_1007FE5E0, (void *)&_mh_execute_header);
}

void sub_1002CDCD8(_Unwind_Exception *a1)
{
}

void sub_1002CDCF8(uint64_t a1, double *a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  if (v4)
  {
    unint64_t v5 = *(void *)(a1 + 32);
    if (*a2 - *(double *)(*(void *)(*(void *)(a1 + 8) + 8 * (v5 / 0x1E)) + 136 * (v5 % 0x1E)) > *(double *)(a1 + 368))
    {
      *(void *)(a1 + 32) = v5 + 1;
      *(void *)(a1 + 40) = v4 - 1;
      sub_1002CEB48(a1, 1);
    }
  }

__n128 sub_1002CDD88(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 30 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_1002CE834(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x1E)) + 136 * (v7 % 0x1E);
  *(_OWORD *)unint64_t v8 = *(_OWORD *)a2;
  __int128 v9 = *(_OWORD *)(a2 + 16);
  __int128 v10 = *(_OWORD *)(a2 + 32);
  __int128 v11 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(v8 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v8 + 64) = v11;
  *(_OWORD *)(v8 + 16) = v9;
  *(_OWORD *)(v8 + 32) = v10;
  __n128 result = *(__n128 *)(a2 + 80);
  __int128 v13 = *(_OWORD *)(a2 + 96);
  __int128 v14 = *(_OWORD *)(a2 + 112);
  *(void *)(v8 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = *(void *)(a2 + 128);
  *(_OWORD *)(v8 + 96) = v13;
  *(_OWORD *)(v8 + 112) = v14;
  *(__n128 *)(v8 + 80) = result;
  ++a1[5];
  return result;
}

float32x4_t sub_1002CDE54@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  if (*(_BYTE *)(a2 + 16))
  {
    double v7 = *(double *)(a1 + 376);
    *(float *)&double v7 = v7;
    float32x4_t v8 = vdivq_f32(*(float32x4_t *)a2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v7, 0));
    if (!*(_BYTE *)(a1 + 352)) {
      *(_BYTE *)(a1 + 352) = 1;
    }
    *(float32x4_t *)(a1 + 336) = v8;
  }

  sub_1002CDF50(a1, *(double *)(a2 + 64), a4);
  __n128 v21 = v9;
  __int128 v10 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003A8738(v10, v21);
  }
  int32x4_t v11 = (int32x4_t)vnegq_f32((float32x4_t)v21);
  int8x16_t v12 = (int8x16_t)vtrn2q_s32((int32x4_t)v21, vtrn1q_s32((int32x4_t)v21, v11));
  __int128 v14 = *(_OWORD *)(a2 + 32);
  float32x4_t v13 = *(float32x4_t *)(a2 + 48);
  float32x4_t v15 = vmlaq_n_f32( vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)v21, (int8x16_t)v11, 8uLL), *(float32x2_t *)v13.f32, 1),  (float32x4_t)vextq_s8(v12, v12, 8uLL),  v13.f32[0]);
  float32x4_t v16 = (float32x4_t)vrev64q_s32((int32x4_t)v21);
  v16.i32[0] = v11.i32[1];
  v16.i32[3] = v11.i32[2];
  float32x4_t v17 = vmlaq_laneq_f32(vmulq_laneq_f32((float32x4_t)v21, v13, 3), v16, v13, 2);
  __int128 v18 = *(_OWORD *)(a2 + 64);
  __int128 v19 = *(_OWORD *)(a2 + 16);
  float32x4_t result = vaddq_f32(v15, v17);
  *(_OWORD *)a3 = *(_OWORD *)a2;
  *(_OWORD *)(a3 + 16) = v19;
  *(_OWORD *)(a3 + 32) = v14;
  *(float32x4_t *)(a3 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = result;
  *(_OWORD *)(a3 + 64) = v18;
  *(double *)(a3 + 64) = a4;
  return result;
}

uint64_t sub_1002CDF50(uint64_t a1, double a2, double a3)
{
  return sub_1002CE724(a1, &v6, a3);
}

float32x4_t sub_1002CE058@<Q0>(uint64_t a1@<X0>, __int128 *a2@<X1>, double *a3@<X8>, double a4@<D0>)
{
  double v8 = *(double *)a2;
  sub_1002CDF50(a1, *(double *)a2, a4);
  if (*(_BYTE *)(a1 + 352)) {
    float32x4_t v10 = *(float32x4_t *)(a1 + 336);
  }
  else {
    float32x4_t v10 = 0uLL;
  }
  float32x4_t v130 = v10;
  float32x4_t v126 = (float32x4_t)a2[2];
  float32x4_t v127 = (float32x4_t)a2[1];
  float32x4_t v124 = (float32x4_t)a2[4];
  float32x4_t v125 = (float32x4_t)a2[3];
  *(double *)&__int128 v11 = sub_1002CE658(v9);
  uint64_t v12 = 0LL;
  __int128 v132 = v11;
  __int128 v133 = v13;
  __int128 v134 = v14;
  __int128 v135 = v15;
  do
  {
    *(float32x4_t *)((char *)&v136 + v12) = vmlaq_laneq_f32( vmlaq_laneq_f32( vmlaq_lane_f32( vmulq_n_f32(v127, COERCE_FLOAT(*(__int128 *)((char *)&v132 + v12))),  v126,  *(float32x2_t *)((char *)&v132 + v12),  1),  v125,  *(float32x4_t *)((char *)&v132 + v12),  2),  v124,  *(float32x4_t *)((char *)&v132 + v12),  3);
    v12 += 16LL;
  }

  while (v12 != 64);
  uint64_t v16 = *(void *)(a1 + 8);
  unint64_t v18 = *(void *)(a1 + 32);
  uint64_t v17 = *(void *)(a1 + 40);
  unint64_t v19 = v18 / 0x1E;
  if (v17) {
    double v20 = *(double *)(*(void *)(v16 + 8 * v19) + 136 * (v18 % 0x1E));
  }
  else {
    double v20 = 0.0;
  }
  float32x4_t v21 = v130;
  int32x4_t v120 = v137;
  int32x4_t v121 = v136;
  float32x4_t v118 = v139;
  float32x4_t v119 = v138;
  float32x4_t v22 = 0uLL;
  if (*(void *)(a1 + 16) != v16)
  {
    uint64_t v23 = *(void *)(v16 + 8 * v19);
    uint64_t v24 = v23 + 136 * (v18 % 0x1E);
    unint64_t v25 = *(void *)(v16 + 8 * ((v18 + v17) / 0x1E)) + 136 * ((v18 + v17) % 0x1E);
    if (v24 != v25)
    {
      int v26 = 0;
      double v27 = (uint64_t *)(v16 + 8 * v19);
      float32x4_t v28 = (float32x4_t)vdupq_n_s32(0xBF3504F3);
      v29.i64[0] = 0x8000000080000000LL;
      v29.i64[1] = 0x8000000080000000LL;
      float32x4_t v30 = (float32x4_t)vdupq_n_s32(0x3F3504F3u);
      float32x4_t v31 = (float32x4_t)xmmword_10042DD20;
      float32x4_t v32 = 0uLL;
      float32x4_t v122 = v30;
      float32x4_t v123 = v28;
      do
      {
        double v33 = *(double *)v24;
        if (v8 < *(double *)v24)
        {
          double v35 = *(double *)(v24 + 16);
          double v34 = *(double *)(v24 + 24);
          int8x16_t v36 = (int8x16_t)vcvt_hight_f32_f64( (int32x2_t)vcvt_f32_f64(*(float64x2_t *)(v24 + 56)),  *(float64x2_t *)(v24 + 72));
          int32x4_t v37 = (int32x4_t)vextq_s8(v36, v36, 4uLL);
          int32x4_t v38 = (int32x4_t)vnegq_f32((float32x4_t)v37);
          int8x16_t v39 = (int8x16_t)vtrn2q_s32(v37, vtrn1q_s32(v37, v38));
          float32x4_t v40 = vmlaq_f32( vmulq_f32((float32x4_t)vextq_s8((int8x16_t)v37, (int8x16_t)v38, 8uLL), v29),  v28,  (float32x4_t)vextq_s8(v39, v39, 8uLL));
          float32x4_t v41 = (float32x4_t)vrev64q_s32(v37);
          v41.i32[0] = v38.i32[1];
          double v42 = *(double *)(v24 + 8);
          v41.i32[3] = v38.i32[2];
          float32x4_t v43 = vaddq_f32(vmlaq_f32(vmulq_f32((float32x4_t)v37, v30), v29, v41), v40);
          if (!v26)
          {
            float32x4_t v128 = v22;
            int32x4_t v129 = (int32x4_t)v43;
            float32x4_t v131 = v21;
            *(double *)&__int128 v44 = sub_1002CE658((float32x4_t)xmmword_10042DD40);
            uint64_t v48 = 0LL;
            __int128 v132 = v44;
            __int128 v133 = v49;
            __int128 v134 = v50;
            __int128 v135 = v45;
            do
            {
              *(float32x4_t *)((char *)&v136 + v4_Block_object_dispose((const void *)(v1 - 112), 8) = vmlaq_laneq_f32( vmlaq_laneq_f32( vmlaq_lane_f32( vmulq_n_f32( v127,  COERCE_FLOAT(*(__int128 *)((char *)&v132 + v48))),  v126,  *(float32x2_t *)((char *)&v132 + v48),  1),  v125,  *(float32x4_t *)((char *)&v132 + v48),  2),  v124,  *(float32x4_t *)((char *)&v132 + v48),  3);
              v48 += 16LL;
            }

            while (v48 != 64);
            v46.f32[0] = v138.f32[2] + (float)(*(float *)v136.i32 + *(float *)&v137.i32[1]);
            float32x4_t v31 = (float32x4_t)xmmword_10042DD20;
            float32x4_t v43 = (float32x4_t)v129;
            if (v46.f32[0] >= 0.0)
            {
              float v65 = sqrtf(v46.f32[0] + 1.0);
              v46.f32[0] = v65 + v65;
              float32x2_t v66 = vrecpe_f32(v46);
              *(float32x2_t *)&__int128 v45 = vmul_f32(v66, vrecps_f32(v46, v66));
              LODWORD(v67) = vmul_f32(*(float32x2_t *)&v45, vrecps_f32(v46, *(float32x2_t *)&v45)).u32[0];
              *(float *)&__int128 v45 = vmuls_lane_f32( v67,  (float32x2_t)*(_OWORD *)&vsubq_f32((float32x4_t)vdupq_laneq_s32(v137, 2), v138),  1);
              float v71 = vmuls_n_f32(vsubq_f32(v138, (float32x4_t)vdupq_laneq_s32(v136, 2)).f32[0], v67);
              float v72 = vmuls_n_f32( vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v136.i8, 1), (float32x4_t)v137).f32[0],  v67);
              float v73 = v46.f32[0] * 0.25;
            }

            else if (*(float *)v136.i32 < *(float *)&v137.i32[1] || *(float *)v136.i32 < v138.f32[2])
            {
              v47.f32[0] = sqrtf(v138.f32[2] + (float)((float)(1.0 - *(float *)v136.i32) - *(float *)&v137.i32[1]));
              v47.f32[0] = v47.f32[0] + v47.f32[0];
              float32x2_t v52 = vrecpe_f32(v47);
              float32x2_t v53 = vmul_f32(v52, vrecps_f32(v47, v52));
              v53.i32[0] = vmul_f32(v53, vrecps_f32(v47, v53)).u32[0];
              float32x4_t v54 = (float32x4_t)vdupq_laneq_s32(v136, 2);
              float v55 = vmuls_n_f32(vaddq_f32(v54, v138).f32[0], v53.f32[0]);
              float32x2_t v56 = (float32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32(v137, 2), v138).u64[0];
              float v57 = vmuls_lane_f32(v53.f32[0], v56, 1);
              v47.f32[0] = v47.f32[0] * 0.25;
              float32x4_t v58 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v136.i8, 1);
              float v59 = vmuls_n_f32(vsubq_f32(v58, (float32x4_t)v137).f32[0], v53.f32[0]);
              *(float *)&__int128 v45 = sqrtf(*(float *)&v137.i32[1] + (float)((float)(1.0 - *(float *)v136.i32) - v138.f32[2]));
              *(float *)&__int128 v45 = *(float *)&v45 + *(float *)&v45;
              float32x2_t v60 = vrecpe_f32(*(float32x2_t *)&v45);
              float32x2_t v61 = vmul_f32(v60, vrecps_f32(*(float32x2_t *)&v45, v60));
              v61.i32[0] = vmul_f32(v61, vrecps_f32(*(float32x2_t *)&v45, v61)).u32[0];
              float v62 = vmuls_n_f32(vaddq_f32(v58, (float32x4_t)v137).f32[0], v61.f32[0]);
              float v63 = *(float *)&v45 * 0.25;
              float v64 = vmuls_lane_f32(v61.f32[0], v56, 1);
              float v73 = vmuls_n_f32(vsubq_f32(v138, v54).f32[0], v61.f32[0]);
              else {
                *(float *)&__int128 v45 = v55;
              }
              else {
                float v71 = v57;
              }
              else {
                float v72 = v47.f32[0];
              }
            }

            else
            {
              *(float *)&__int128 v45 = sqrtf(*(float *)v136.i32 + (float)((float)(1.0 - *(float *)&v137.i32[1]) - v138.f32[2]));
              *(float *)&__int128 v45 = *(float *)&v45 + *(float *)&v45;
              float32x2_t v68 = vrecpe_f32(*(float32x2_t *)&v45);
              float32x2_t v69 = vmul_f32(v68, vrecps_f32(*(float32x2_t *)&v45, v68));
              LODWORD(v70) = vmul_f32(v69, vrecps_f32(*(float32x2_t *)&v45, v69)).u32[0];
              *(float *)&__int128 v45 = *(float *)&v45 * 0.25;
              float v71 = vmuls_n_f32( vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v136.i8, 1), (float32x4_t)v137).f32[0],  v70);
              float v72 = vmuls_n_f32(vaddq_f32((float32x4_t)vdupq_laneq_s32(v136, 2), v138).f32[0], v70);
              float v73 = vmuls_lane_f32( v70,  (float32x2_t)*(_OWORD *)&vsubq_f32((float32x4_t)vdupq_laneq_s32(v137, 2), v138),  1);
            }

            float32x4_t v21 = v131;
            float32x4_t v22 = v128;
            float32x4_t v30 = v122;
            float32x4_t v28 = v123;
            v29.i64[0] = 0x8000000080000000LL;
            v29.i64[1] = 0x8000000080000000LL;
            int32x4_t v74 = (int32x4_t)vnegq_f32((float32x4_t)v129);
            int8x16_t v75 = (int8x16_t)vtrn2q_s32(v129, vtrn1q_s32(v129, v74));
            float32x4_t v76 = (float32x4_t)vrev64q_s32(v129);
            v76.i32[0] = v74.i32[1];
            v76.i32[3] = v74.i32[2];
            float32x4_t v32 = vaddq_f32( vmlaq_n_f32( vmulq_n_f32((float32x4_t)vextq_s8((int8x16_t)v129, (int8x16_t)v74, 8uLL), v71),  (float32x4_t)vextq_s8(v75, v75, 8uLL),  *(float *)&v45),  vmlaq_n_f32(vmulq_n_f32((float32x4_t)v129, v73), v76, v72));
            uint64_t v23 = *v27;
            int v26 = 1;
          }

          float v77 = v42;
          float v78 = v35;
          float v79 = v34;
          int32x4_t v80 = (int32x4_t)vmulq_f32(v43, v31);
          int32x4_t v81 = (int32x4_t)vnegq_f32((float32x4_t)v80);
          int8x16_t v82 = (int8x16_t)vtrn2q_s32(v80, vtrn1q_s32(v80, v81));
          float32x4_t v83 = vmlaq_n_f32( vmulq_n_f32((float32x4_t)vextq_s8((int8x16_t)v80, (int8x16_t)v81, 8uLL), v78),  (float32x4_t)vextq_s8(v82, v82, 8uLL),  v77);
          float32x4_t v84 = (float32x4_t)vrev64q_s32(v80);
          v84.i32[0] = v81.i32[1];
          v84.i32[3] = v81.i32[2];
          int32x4_t v85 = (int32x4_t)vmlaq_n_f32(v83, v84, v79);
          int32x4_t v86 = (int32x4_t)vnegq_f32((float32x4_t)v85);
          int8x16_t v87 = (int8x16_t)vtrn2q_s32(v85, vtrn1q_s32(v85, v86));
          float32x4_t v88 = vmlaq_n_f32( vmulq_lane_f32( (float32x4_t)vextq_s8((int8x16_t)v85, (int8x16_t)v86, 8uLL),  *(float32x2_t *)v43.f32,  1),  (float32x4_t)vextq_s8(v87, v87, 8uLL),  v43.f32[0]);
          float32x4_t v89 = (float32x4_t)vrev64q_s32(v85);
          v89.i32[0] = v86.i32[1];
          v89.i32[3] = v86.i32[2];
          float32x4_t v90 = vaddq_f32(vmlaq_laneq_f32(vmulq_laneq_f32((float32x4_t)v85, v43, 3), v89, v43, 2), v88);
          int32x4_t v91 = (int32x4_t)vmulq_f32(v32, v31);
          int32x4_t v92 = (int32x4_t)vnegq_f32((float32x4_t)v91);
          int8x16_t v93 = (int8x16_t)vtrn2q_s32(v91, vtrn1q_s32(v91, v92));
          float32x4_t v94 = vmlaq_n_f32( vmulq_lane_f32( (float32x4_t)vextq_s8((int8x16_t)v91, (int8x16_t)v92, 8uLL),  *(float32x2_t *)v90.f32,  1),  (float32x4_t)vextq_s8(v93, v93, 8uLL),  v90.f32[0]);
          float32x4_t v95 = (float32x4_t)vrev64q_s32(v91);
          v95.i32[0] = v92.i32[1];
          v95.i32[3] = v92.i32[2];
          int32x4_t v96 = (int32x4_t)vmlaq_laneq_f32(v94, v95, v90, 2);
          int32x4_t v97 = (int32x4_t)vnegq_f32((float32x4_t)v96);
          int8x16_t v98 = (int8x16_t)vtrn2q_s32(v96, vtrn1q_s32(v96, v97));
          float32x4_t v99 = vmlaq_n_f32( vmulq_lane_f32( (float32x4_t)vextq_s8((int8x16_t)v96, (int8x16_t)v97, 8uLL),  *(float32x2_t *)v32.f32,  1),  (float32x4_t)vextq_s8(v98, v98, 8uLL),  v32.f32[0]);
          float32x4_t v100 = (float32x4_t)vrev64q_s32(v96);
          v100.i32[0] = v97.i32[1];
          v100.i32[3] = v97.i32[2];
          float32x4_t v101 = vaddq_f32(vmlaq_laneq_f32(vmulq_laneq_f32((float32x4_t)v96, v32, 3), v100, v32, 2), v99);
          v100.f32[0] = v33 - v20;
          float32x4_t v22 = vmlaq_n_f32(v22, v21, v100.f32[0]);
          float32x4_t v21 = vmlaq_n_f32(v21, v101, v100.f32[0]);
        }

        v24 += 136LL;
        if (v24 - v23 == 4080)
        {
          uint64_t v102 = v27[1];
          ++v27;
          uint64_t v23 = v102;
          uint64_t v24 = v102;
        }

        double v20 = v33;
      }

      while (v24 != v25);
    }
  }

  __int128 v103 = a2[5];
  *((_OWORD *)a3 + 4) = a2[4];
  *((_OWORD *)a3 + 5) = v103;
  __int128 v104 = a2[7];
  *((_OWORD *)a3 + 6) = a2[6];
  *((_OWORD *)a3 + 7) = v104;
  __int128 v105 = a2[1];
  *(_OWORD *)a3 = *a2;
  *((_OWORD *)a3 + 1) = v105;
  __int128 v106 = a2[3];
  *((_OWORD *)a3 + 2) = a2[2];
  *((_OWORD *)a3 + 3) = v106;
  uint64_t v107 = (_OWORD *)(a1 + 192);
  __int128 v108 = *a2;
  __int128 v109 = a2[1];
  __int128 v110 = a2[3];
  if (*(_BYTE *)(a1 + 320))
  {
    *(_OWORD *)(a1 + 224) = a2[2];
    *(_OWORD *)(a1 + 240) = v110;
    *uint64_t v107 = v108;
    *(_OWORD *)(a1 + 20_Block_object_dispose((const void *)(v1 - 112), 8) = v109;
    __int128 v111 = a2[4];
    __int128 v112 = a2[5];
    __int128 v113 = a2[6];
    *(void *)(a1 + 304) = *((void *)a2 + 14);
    *(_OWORD *)(a1 + 272) = v112;
    *(_OWORD *)(a1 + 28_Block_object_dispose((const void *)(v1 - 112), 8) = v113;
    *(_OWORD *)(a1 + 256) = v111;
  }

  else
  {
    *(_OWORD *)(a1 + 224) = a2[2];
    *(_OWORD *)(a1 + 240) = v110;
    *uint64_t v107 = v108;
    *(_OWORD *)(a1 + 20_Block_object_dispose((const void *)(v1 - 112), 8) = v109;
    __int128 v114 = a2[4];
    __int128 v115 = a2[5];
    __int128 v116 = a2[7];
    *(_OWORD *)(a1 + 28_Block_object_dispose((const void *)(v1 - 112), 8) = a2[6];
    *(_OWORD *)(a1 + 304) = v116;
    *(_OWORD *)(a1 + 256) = v114;
    *(_OWORD *)(a1 + 272) = v115;
    *(_BYTE *)(a1 + 320) = 1;
  }

  v22.i32[3] = 0;
  float32x4_t result = vaddq_f32(v118, v22);
  *((int32x4_t *)a3 + 1) = v121;
  *((int32x4_t *)a3 + 2) = v120;
  *((float32x4_t *)a3 + 3) = v119;
  *((float32x4_t *)a3 + 4) = result;
  *a3 = a4;
  return result;
}

double sub_1002CE658(float32x4_t _Q0)
{
  _S3 = _Q0.u32[1];
  _S5 = _Q0.u32[2];
  __asm { FMLS            S1, S5, V0.S[2] }

  _S7 = _Q0.u32[3];
  __asm { FMLA            S1, S7, V0.S[3] }

  float v10 = vmlas_n_f32(vmuls_lane_f32(_Q0.f32[2], _Q0, 3), _Q0.f32[1], _Q0.f32[0]);
  LODWORD(v11) = _S1;
  *((float *)&v11 + 1) = v10 + v10;
  __asm
  {
    FMLA            S6, S3, V0.S[1]
    FMLA            S6, S7, V0.S[3]
    FMLS            S6, S0, V0.S[0]
    FMLA            S18, S5, V0.S[1]
    FMLA            S17, S0, V0.S[2]
    FMLA            S16, S5, V0.S[1]
    FMLA            S7, S5, V0.S[2]
    FMLS            S7, S0, V0.S[0]
    FMLS            S7, S3, V0.S[1]
  }

  return v11;
}

uint64_t sub_1002CE724@<X0>(uint64_t result@<X0>, int8x16_t *a2@<X8>, double a3@<D0>)
{
  uint64_t v3 = *(void *)(result + 40);
  if (v3
    && (uint64_t v4 = *(void *)(result + 8),
        unint64_t v5 = *(void *)(result + 32),
        int8x16_t v6 = (unint64_t *)(v4 + 8 * (v5 / 0x1E)),
        unint64_t v7 = *v6,
        unint64_t v8 = *v6 + 136 * (v5 % 0x1E),
        *(double *)v8 <= a3))
  {
    if (*(void *)(result + 16) != v4)
    {
      float32x4_t result = 30LL;
      while (v8 != *(void *)(v4 + 8 * ((v5 + v3) / 0x1E)) + 136 * ((v5 + v3) % 0x1E))
      {
        if (*(double *)v8 > a3)
        {
          float64x2_t v12 = *(float64x2_t *)(v8 + 72);
          float64x2_t v13 = *(float64x2_t *)(v8 + 56);
          goto LABEL_12;
        }

        v8 += 136LL;
        if (v8 - v7 == 4080)
        {
          unint64_t v10 = v6[1];
          ++v6;
          unint64_t v7 = v10;
          unint64_t v8 = v10;
        }
      }
    }

    unint64_t v11 = *(void *)(v4 + 8 * ((v3 + v5 - 1) / 0x1E)) + 136 * ((v3 + v5 - 1) % 0x1E);
    float64x2_t v12 = *(float64x2_t *)(v11 + 72);
    float64x2_t v13 = *(float64x2_t *)(v11 + 56);
LABEL_12:
    int8x16_t v14 = (int8x16_t)vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v13), v12);
    *a2 = vextq_s8(v14, v14, 4uLL);
    char v9 = 1;
  }

  else
  {
    char v9 = 0;
    a2->i8[0] = 0;
  }

  a2[1].i8[0] = v9;
  return result;
}

void sub_1002CE834(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x1E;
  unint64_t v4 = v2 - 30;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    int8x16_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    char v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      double v34 = (char *)sub_1000472C0(v5, v33);
      double v35 = &v34[8 * (v33 >> 2)];
      int32x4_t v37 = &v34[8 * v36];
      int32x4_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        float32x4_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)float32x4_t v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_1002CEAFC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1002CEB48(uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0x1E) {
    a2 = 1;
  }
  if (v2 < 0x3C) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8LL;
    *(void *)(a1 + 32) -= 30LL;
  }

  return v4 ^ 1u;
}

uint64_t sub_1002CEBA4(uint64_t a1, __n128 *a2)
{
  *(_BYTE *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 40) = 0;
  *(void *)a1 = off_1007BC678;
  *(_BYTE *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_BYTE *)(a1 + 64) = 0;
  *(_BYTE *)(a1 + 16_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(void *)(a1 + 184) = 0LL;
  *(void *)(a1 + 176) = a1 + 184;
  *(void *)(a1 + 192) = 0LL;
  *(_BYTE *)(a1 + 200) = 0;
  *(_BYTE *)(a1 + 216) = 0;
  *(_BYTE *)(a1 + 224) = 0;
  *(_BYTE *)(a1 + 240) = 0;
  *(_WORD *)(a1 + 24_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 256) = 0;
  *(_BYTE *)(a1 + 264) = 0;
  *(_BYTE *)(a1 + 272) = 0;
  *(_BYTE *)(a1 + 280) = 0;
  *(_BYTE *)(a1 + 296) = 0;
  *(_BYTE *)(a1 + 304) = 0;
  *(_BYTE *)(a1 + 312) = 0;
  *(_BYTE *)(a1 + 320) = 0;
  *(_BYTE *)(a1 + 44_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 464) = 0;
  *(_BYTE *)(a1 + 480) = 0;
  *(_BYTE *)(a1 + 48_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 496) = 0;
  *(_BYTE *)(a1 + 504) = 0;
  *(_BYTE *)(a1 + 52_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 536) = 0;
  *(_BYTE *)(a1 + 56_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 576) = 0;
  sub_100311650(a1 + 584, a2);
  return a1;
}

void sub_1002CEC6C(_Unwind_Exception *a1)
{
}

void sub_1002CEC88(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003A8A54();
  }
  *(_BYTE *)a2 = 0;
  *(_BYTE *)(a2 + 16) = 0;
  *(_BYTE *)(a2 + 24) = 0;
  *(_BYTE *)(a2 + 72) = 0;
  *(_BYTE *)(a2 + 80) = 0;
  *(_BYTE *)(a2 + 112) = 0;
  *(_BYTE *)(a2 + 160) = 0;
  *(_WORD *)(a2 + 16_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(void *)(a2 + 120) = 0LL;
  *(void *)(a2 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  *(_BYTE *)(a2 + 136) = 0;
  if (*(_BYTE *)(a1 + 56))
  {
    sub_1002CF498(a1, (uint64_t)buf);
    *(_OWORD *)(a2 + 136) = *(_OWORD *)buf;
    *(_OWORD *)(a2 + 145) = *(_OWORD *)&buf[9];
    if (!*(_BYTE *)(a1 + 56)) {
      sub_100006080();
    }
    double v4 = *(double *)(a1 + 48) + dbl_10042DD50[*(_BYTE *)(a1 + 40) == 0];
    if (*(_BYTE *)(a1 + 448) && *(_BYTE *)(a1 + 312))
    {
      double v5 = v4 - *(double *)(a1 + 320);
      if (v5 <= 6.3)
      {
        double v24 = v4 - *(double *)(a1 + 304);
        double v25 = v24 / 0.1;
        BOOL v26 = v24 <= 409.5;
        double v27 = 4095.0;
        if (v26) {
          double v27 = v25;
        }
        double v28 = fmod(round(v27) * 0.1, 409.6);
        if (v28 < 0.0) {
          double v29 = 409.6;
        }
        else {
          double v29 = -0.0;
        }
        double v30 = v28 + v29 + 0.0;
        double v31 = fmod(round(v5 / 0.1) * 0.1, 6.4);
        if (v31 < 0.0) {
          double v32 = 6.4;
        }
        else {
          double v32 = -0.0;
        }
        double v33 = v31 + v32 + 0.0;
        int8x16_t v64 = *(int8x16_t *)(a1 + 384);
        double v34 = fmod(round(*(float *)&v64.i32[1] / 0.1) * 0.1 + 25.6, 51.2);
        if (v34 < 0.0) {
          double v35 = 51.2;
        }
        else {
          double v35 = -0.0;
        }
        double v36 = v34 + v35 + -25.6;
        *(double *)(a2 + 24) = v30;
        *(double *)(a2 + 32) = v33;
        *(_DWORD *)(a2 + 40) = 0;
        v37.i32[0] = vextq_s8(v64, v64, 8uLL).u32[0];
        v37.i32[1] = v64.i32[0];
        float64x2_t v38 = (float64x2_t)vdupq_n_s64(0x3FB999999999999AuLL);
        int8x16_t v65 = (int8x16_t)vaddq_f64( vmulq_f64(vrndaq_f64(vdivq_f64(vcvtq_f64_f32(v37), v38)), v38),  (float64x2_t)vdupq_n_s64(0x407999999999999AuLL));
        double v61 = fmod(*(double *)&v65.i64[1], 819.2);
        v39.f64[0] = fmod(*(double *)v65.i64, 819.2);
        v39.f64[1] = v61;
        *(float64x2_t *)(a2 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = vaddq_f64( vaddq_f64( v39,  (float64x2_t)vbslq_s8( (int8x16_t)vcgezq_f64(v39),  (int8x16_t)vdupq_n_s64(0x8000000000000000LL),  (int8x16_t)vdupq_n_s64(0x408999999999999AuLL))),  (float64x2_t)vdupq_n_s64(0xC07999999999999ALL));
        *(double *)(a2 + 64) = v36;
        *(_BYTE *)(a2 + 72) = 1;
        goto LABEL_57;
      }

      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
        sub_1003A89F0();
      }
    }

    if (!*(_BYTE *)(a1 + 576))
    {
LABEL_14:
      if (*(_BYTE *)(a1 + 568))
      {
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
          sub_1003A88FC();
        }
        double v11 = v4 - *(double *)(a1 + 544);
        if (v11 <= 6.3)
        {
          double v40 = v4 - *(double *)(a1 + 536);
          double v41 = v40 / 0.1;
          BOOL v26 = v40 <= 409.5;
          double v42 = 4095.0;
          if (v26) {
            double v42 = v41;
          }
          double v43 = fmod(round(v42) * 0.1, 409.6);
          if (v43 < 0.0) {
            double v44 = 409.6;
          }
          else {
            double v44 = -0.0;
          }
          double v45 = v43 + v44 + 0.0;
          double v46 = fmod(round(v11 / 0.1) * 0.1, 6.4);
          if (v46 < 0.0) {
            double v47 = 6.4;
          }
          else {
            double v47 = -0.0;
          }
          *(double *)(a2 + 80) = v45;
          *(double *)(a2 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = v46 + v47 + 0.0;
          float64x2_t v48 = (float64x2_t)vdupq_n_s64(0x3FA999999999999AuLL);
          float64x2_t v66 = vaddq_f64( vmulq_f64(vrndaq_f64(vdivq_f64(*(float64x2_t *)(a1 + 552), v48)), v48),  (float64x2_t)vdupq_n_s64(0x401999999999999AuLL));
          double v62 = fmod(v66.f64[1], 12.8);
          v49.f64[0] = fmod(v66.f64[0], 12.8);
          v49.f64[1] = v62;
          *(float64x2_t *)(a2 + 96) = vaddq_f64( vaddq_f64( v49,  (float64x2_t)vbslq_s8( (int8x16_t)vcgezq_f64(v49),  (int8x16_t)vdupq_n_s64(0x8000000000000000LL),  (int8x16_t)vdupq_n_s64(0x402999999999999AuLL))),  (float64x2_t)vdupq_n_s64(0xC01999999999999ALL));
          *(_BYTE *)(a2 + 112) = 1;
        }

        else if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG))
        {
          sub_1003A8898();
        }
      }

      goto LABEL_57;
    }

    double v6 = *(double *)(a1 + 464);
    double v7 = *(double *)(a1 + 472);
    double v8 = v4 - v6;
    char v9 = (os_log_s *)qword_1008000A0;
    BOOL v10 = os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG);
    if (v4 - v6 > 6.3)
    {
      if (v10) {
        sub_1003A898C();
      }
      goto LABEL_14;
    }

    if (v10)
    {
      *(_DWORD *)__int128 buf = 134218496;
      *(double *)&uint8_t buf[4] = v7;
      *(_WORD *)&_BYTE buf[12] = 2048;
      *(double *)&buf[14] = v6;
      *(_WORD *)&buf[22] = 2048;
      *(double *)&_BYTE buf[24] = v4;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "#findalgs-findee, Providing PDR displacement, enter time: %f, applicable time: %f, transmission time: %f",  buf,  0x20u);
    }

    double v12 = 4095.0;
    if (v4 - v7 <= 409.5) {
      double v12 = (v4 - v7) / 0.1;
    }
    double v13 = fmod(round(v12) * 0.1, 409.6);
    if (v13 < 0.0) {
      double v14 = 409.6;
    }
    else {
      double v14 = -0.0;
    }
    double v15 = v13 + v14 + 0.0;
    double v16 = fmod(round(v8 / 0.1) * 0.1, 6.4);
    if (v16 < 0.0) {
      double v17 = 6.4;
    }
    else {
      double v17 = -0.0;
    }
    double v18 = v16 + v17 + 0.0;
    double v19 = fmod(round(*(double *)(a1 + 520) / 0.1) * 0.1 + 25.6, 51.2);
    if (v19 < 0.0) {
      double v20 = 51.2;
    }
    else {
      double v20 = -0.0;
    }
    double v21 = v19 + v20 + -25.6;
    *(double *)(a2 + 24) = v15;
    *(double *)(a2 + 32) = v18;
    *(_DWORD *)(a2 + 40) = 1;
    float64x2_t v22 = (float64x2_t)vdupq_n_s64(0x3FB999999999999AuLL);
    float64x2_t v63 = vaddq_f64( vmulq_f64(vrndaq_f64(vdivq_f64(*(float64x2_t *)(a1 + 504), v22)), v22),  (float64x2_t)vdupq_n_s64(0x407999999999999AuLL));
    double v60 = fmod(v63.f64[1], 819.2);
    v23.f64[0] = fmod(v63.f64[0], 819.2);
    v23.f64[1] = v60;
    *(float64x2_t *)(a2 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = vaddq_f64( vaddq_f64( v23,  (float64x2_t)vbslq_s8( (int8x16_t)vcgezq_f64(v23),  (int8x16_t)vdupq_n_s64(0x8000000000000000LL),  (int8x16_t)vdupq_n_s64(0x408999999999999AuLL))),  (float64x2_t)vdupq_n_s64(0xC07999999999999ALL));
    *(double *)(a2 + 64) = v21;
    *(_BYTE *)(a2 + 72) = 1;
LABEL_57:
    if (*(_BYTE *)(a1 + 248))
    {
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
        sub_1003A886C();
      }
      int v50 = 0;
      unsigned int v51 = (double *)(a1 + 232);
    }

    else
    {
      int v52 = *(unsigned __int8 *)(a1 + 296);
      if (*(_BYTE *)(a1 + 272))
      {
        if (!*(_BYTE *)(a1 + 296))
        {
LABEL_78:
          if (*(_BYTE *)(a1 + 32))
          {
            double v59 = *(double *)(a1 + 8);
            sub_1000065CC(__p, "Findee");
            *(_WORD *)(a2 + 16_Block_object_dispose((const void *)(v1 - 112), 8) = sub_100311754(a1 + 584, (uint64_t *)__p, v59) | 0x100;
            if (v68 < 0) {
              operator delete(__p[0]);
            }
          }

          return;
        }

        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
          sub_1003A8840();
        }
      }

      else
      {
        BOOL v53 = os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG);
        if (v52)
        {
          if (v53) {
            sub_1003A8814();
          }
          unsigned int v51 = (double *)(a1 + 288);
          int v50 = 1;
          goto LABEL_72;
        }

        if (v53) {
          sub_1003A87E8();
        }
      }

      unsigned int v51 = (double *)(a1 + 288);
      int v50 = 2;
    }

void sub_1002CF474( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002CF498(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  if (!*(_BYTE *)(a1 + 168) || !*(_BYTE *)(a1 + 32)) {
    goto LABEL_16;
  }
  if (!sub_10030DADC(a1, &v15, *(double *)(a1 + 80)))
  {
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT)) {
      sub_1003A8C74();
    }
    goto LABEL_16;
  }

  double v4 = vabdd_f64(*(double *)(a1 + 8), v15);
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003A8C10();
  }
  double v5 = 0.0;
  if (v4 > 1.0)
  {
    if (!*(_BYTE *)(a1 + 168)) {
      sub_100006080();
    }
    double v6 = *(double *)(a1 + 104);
    if (v6 <= 3.0)
    {
      double v5 = (v4 + -1.0) * fmax(v6, 2.0);
      double v8 = *(double *)(a1 + 120);
    }

    else
    {
      double v7 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_INFO))
      {
        LODWORD(buf) = 134217984;
        *(double *)((char *)&buf + 4) = v6;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_INFO,  "#findalgs-findee, #clcc,findee location speed exceeds a brisk walking pace,inflating uncertainty before transmitting,%.1lf",  (uint8_t *)&buf,  0xCu);
      }

      double v8 = *(double *)(a1 + 120);
      double v5 = 200.0 - v8;
    }

    if (v5 + v8 > 200.0)
    {
LABEL_16:
      *(_BYTE *)a2 = 0;
      *(_BYTE *)(a2 + 24) = 0;
      return;
    }
  }

  *(void *)&__int128 buf = sub_100026A04(*(double *)(a1 + 64));
  *((void *)&buf + 1) = sub_100026A04(*(double *)(a1 + 72));
  double v9 = sub_1003176B8((double *)&buf);
  double v11 = v10;
  int v12 = sub_100317890(v5 + *(double *)(a1 + 120));
  unint64_t v13 = 0x407FF00000000000LL;
  if (v9 <= 511.0)
  {
    if (v9 >= -512.0)
    {
      unint64_t v14 = *(void *)&v9;
    }

    else
    {
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
        sub_1003A8BAC();
      }
      unint64_t v14 = 0xC080000000000000LL;
    }
  }

  else
  {
    unint64_t v14 = 0x407FF00000000000LL;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
      sub_1003A8B48();
    }
  }

  if (v11 <= 511.0)
  {
    if (v11 >= -512.0)
    {
      unint64_t v13 = *(void *)&v11;
    }

    else
    {
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
        sub_1003A8AE4();
      }
      unint64_t v13 = 0xC080000000000000LL;
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR))
  {
    sub_1003A8A80();
  }

  *(void *)a2 = v14;
  *(void *)(a2 + _Block_object_dispose((const void *)(v1 - 112), 8) = v13;
  *(_DWORD *)(a2 + 16) = v12;
  *(_BYTE *)(a2 + 24) = 1;
}

void sub_1002CF784(uint64_t a1, uint64_t a2)
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003A8CD8();
  }
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = *(void *)(a2 + 8);
  *(_BYTE *)(a1 + 56) = 1;
  if (*(_BYTE *)(a2 + 183))
  {
    if (*(_BYTE *)(a2 + 182) == 1)
    {
      if (!*(_BYTE *)(a1 + 40))
      {
        double v4 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#findalgs-findee, process Range: Setting reduced range rate to true",  buf,  2u);
        }
      }

      *(_BYTE *)(a1 + 40) = 1;
    }

    else
    {
      if (*(_BYTE *)(a1 + 40))
      {
        double v5 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)double v6 = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "#findalgs-findee, process Range: Setting reduced range rate to false",  v6,  2u);
        }
      }

      *(_BYTE *)(a1 + 40) = 0;
    }
  }

  else
  {
    *(_BYTE *)(a1 + 40) = 0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
      sub_1003A8CA0();
    }
  }

void sub_1002CF8BC(uint64_t a1, uint64_t a2)
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003A8D50();
  }
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = *(void *)a2;
  *(_BYTE *)(a1 + 56) = 1;
  char v4 = *(_BYTE *)(a1 + 40);
  if (*(_BYTE *)(a2 + 10) == 1)
  {
    if (!*(_BYTE *)(a1 + 40))
    {
      double v5 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "#findalgs-findee, process missedRange: Setting reduced range rate to true",  buf,  2u);
      }
    }

    char v4 = 1;
  }

  else if (*(_BYTE *)(a1 + 40))
  {
    double v6 = (os_log_s *)qword_1008000A0;
    BOOL v7 = os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT);
    char v4 = 0;
    if (v7)
    {
      *(_WORD *)double v8 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#findalgs-findee, process missedRange: Setting reduced range rate to false",  v8,  2u);
      char v4 = 0;
    }
  }

  *(_BYTE *)(a1 + 40) = v4;
}

void sub_1002CF9CC(uint64_t a1, __int128 *a2)
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003A8E1C();
  }
  char v4 = (double *)(a1 + 320);
  if (!*(_BYTE *)(a1 + 448))
  {
    if (!*((_BYTE *)a2 + 84) && *((_DWORD *)a2 + 20) == 2)
    {
      __int128 v11 = *a2;
      __int128 v12 = a2[1];
      __int128 v13 = a2[3];
      *(_OWORD *)(a1 + 352) = a2[2];
      *(_OWORD *)(a1 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = v13;
      *(_OWORD *)char v4 = v11;
      *(_OWORD *)(a1 + 336) = v12;
      __int128 v14 = a2[4];
      __int128 v15 = a2[5];
      __int128 v16 = a2[7];
      *(_OWORD *)(a1 + 416) = a2[6];
      *(_OWORD *)(a1 + 432) = v16;
      *(_OWORD *)(a1 + 384) = v14;
      *(_OWORD *)(a1 + 400) = v15;
      *(_BYTE *)(a1 + 44_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
LABEL_11:
      if (!*(_BYTE *)(a1 + 312))
      {
        *(void *)(a1 + 304) = *(void *)a2;
        *(_BYTE *)(a1 + 312) = 1;
      }

      return;
    }

    goto LABEL_13;
  }

  if (*(double *)a2 > *v4)
  {
    if (!*((_BYTE *)a2 + 84) && *((_DWORD *)a2 + 20) == 2)
    {
      __int128 v5 = *a2;
      __int128 v6 = a2[1];
      __int128 v7 = a2[3];
      *(_OWORD *)(a1 + 352) = a2[2];
      *(_OWORD *)(a1 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = v7;
      *(_OWORD *)char v4 = v5;
      *(_OWORD *)(a1 + 336) = v6;
      __int128 v8 = a2[4];
      __int128 v9 = a2[5];
      __int128 v10 = a2[6];
      *(void *)(a1 + 432) = *((void *)a2 + 14);
      *(_OWORD *)(a1 + 400) = v9;
      *(_OWORD *)(a1 + 416) = v10;
      *(_OWORD *)(a1 + 384) = v8;
      goto LABEL_11;
    }

void sub_1002CFB5C(uint64_t a1, double *a2)
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003A8E48();
  }
  double v4 = *a2;
  if (*(_BYTE *)(a1 + 240)) {
    *(double *)(a1 + 224) = v4;
  }
  sub_1002CFC40(a1, v4);
  if (*(_BYTE *)(a1 + 448) && *a2 - *(double *)(a1 + 320) > 0.5)
  {
    __int128 v5 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 v6 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "#findalgs-findee, Too much time since last pose was seen.  Resetting.  ",  v6,  2u);
    }

    if (*(_BYTE *)(a1 + 312)) {
      *(_BYTE *)(a1 + 312) = 0;
    }
    if (*(_BYTE *)(a1 + 448)) {
      *(_BYTE *)(a1 + 44_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
    }
  }

void sub_1002CFC40(uint64_t a1, double a2)
{
  uint64_t v4 = *(void *)(a1 + 192);
  if (v4)
  {
    __int128 v5 = (uint64_t *)(a1 + 184);
    if (*(_BYTE *)(a1 + 216))
    {
      uint64_t v6 = *(void *)(a1 + 184);
      if (v6)
      {
        do
        {
          uint64_t v7 = v6;
          uint64_t v6 = *(void *)(v6 + 8);
        }

        while (v6);
      }

      else
      {
        do
        {
          uint64_t v7 = v5[2];
          BOOL v8 = *(void *)v7 == (void)v5;
          __int128 v5 = (uint64_t *)v7;
        }

        while (v8);
      }

      int v9 = *(_DWORD *)(v7 + 40) - *(_DWORD *)(a1 + 208);
      if (v9 >= 16)
      {
        __int128 v10 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
          sub_1003A8E74(v9, v10);
        }
LABEL_18:
        LODWORD(v4) = 1;
        goto LABEL_20;
      }
    }

    else
    {
      uint64_t v11 = *v5;
      if (*v5)
      {
        uint64_t v12 = *v5;
        do
        {
          uint64_t v13 = v12;
          uint64_t v12 = *(void *)(v12 + 8);
        }

        while (v12);
      }

      else
      {
        uint64_t v14 = a1 + 184;
        do
        {
          uint64_t v13 = *(void *)(v14 + 16);
          BOOL v8 = *(void *)v13 == v14;
          uint64_t v14 = v13;
        }

        while (v8);
      }

      if (*(int *)(v13 + 40) >= 16)
      {
        __int128 v15 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG))
        {
          if (v11)
          {
            do
            {
              uint64_t v17 = v11;
              uint64_t v11 = *(void *)(v11 + 8);
            }

            while (v11);
          }

          else
          {
            do
            {
              uint64_t v17 = v5[2];
              BOOL v8 = *(void *)v17 == (void)v5;
              __int128 v5 = (uint64_t *)v17;
            }

            while (v8);
          }

          int v18 = *(_DWORD *)(v17 + 40);
          v19[0] = 67109120;
          v19[1] = v18;
          _os_log_debug_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "#findalgs-findee, Walking set to true, step count seen: %d",  (uint8_t *)v19,  8u);
        }

        goto LABEL_18;
      }
    }

    LODWORD(v4) = 0;
  }

void sub_1002CFE34()
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003A8EE4();
  }
}

__n128 sub_1002CFE74(uint64_t a1, __int128 *a2, int a3)
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG))
  {
    sub_1003A8F3C();
    if (a3)
    {
LABEL_3:
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT)) {
        sub_1003A8F10();
      }
      return result;
    }
  }

  else if (a3)
  {
    goto LABEL_3;
  }

  if (*((_DWORD *)a2 + 23) == 1)
  {
    uint64_t v7 = (_OWORD *)(a1 + 64);
    __int128 v8 = *a2;
    __int128 v9 = a2[2];
    if (*(_BYTE *)(a1 + 168))
    {
      *(_OWORD *)(a1 + 80) = a2[1];
      *(_OWORD *)(a1 + 96) = v9;
      *uint64_t v7 = v8;
      __n128 result = (__n128)a2[3];
      __int128 v10 = a2[4];
      __int128 v11 = a2[5];
      *(_DWORD *)(a1 + 160) = *((_DWORD *)a2 + 24);
      *(_OWORD *)(a1 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = v10;
      *(_OWORD *)(a1 + 144) = v11;
      *(__n128 *)(a1 + 112) = result;
    }

    else
    {
      *(_OWORD *)(a1 + 80) = a2[1];
      *(_OWORD *)(a1 + 96) = v9;
      *uint64_t v7 = v8;
      __n128 result = (__n128)a2[3];
      __int128 v12 = a2[4];
      __int128 v13 = a2[5];
      *(void *)(a1 + 160) = *((void *)a2 + 12);
      *(_OWORD *)(a1 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = v12;
      *(_OWORD *)(a1 + 144) = v13;
      *(__n128 *)(a1 + 112) = result;
      *(_BYTE *)(a1 + 16_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
    }
  }

  return result;
}

void sub_1002CFF68(uint64_t a1, uint64_t a2)
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003A8F68();
  }
  if (*(_BYTE *)(a1 + 32)) {
    sub_1003116C0(a1 + 584, a2, *(double *)(a1 + 8));
  }
}

void sub_1002CFFD0(uint64_t a1, uint64_t a2)
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003A8F94();
  }
  int v4 = *(unsigned __int8 *)(a2 + 16);
  int v5 = *(unsigned __int8 *)(a1 + 248);
  sub_10030DAB8(a1, &v11, *(double *)a2);
  double v6 = v11;
  if (v4 != v5)
  {
    int v7 = *(unsigned __int8 *)(a1 + 240);
    *(double *)(a1 + 224) = v11;
    *(double *)(a1 + 232) = v6;
    if (!v7) {
      *(_BYTE *)(a1 + 240) = 1;
    }
    int v8 = *(unsigned __int8 *)(a2 + 16);
    *(_BYTE *)(a1 + 24_Block_object_dispose((const void *)(v1 - 112), 8) = v8;
    if (v8)
    {
      __int128 v9 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 v10 = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#findalgs-findee, Clearing step history because motion activity changed to stationary",  v10,  2u);
        double v6 = v11;
      }

      sub_1002D00E4(a1, v6, 0.0);
      double v6 = v11;
    }
  }

  *(_BYTE *)(a1 + 249) = *(_BYTE *)(a2 + 18);
  sub_1002CFC40(a1, v6);
}

void sub_1002D00E4(uint64_t a1, double a2, double a3)
{
  int v4 = (uint64_t **)(a1 + 176);
  BOOL v3 = *(uint64_t **)(a1 + 176);
  int v5 = (uint64_t *)(a1 + 184);
  if (v3 != (uint64_t *)(a1 + 184))
  {
    do
    {
      double v9 = *((double *)v3 + 4);
      if (a2 - v9 <= a3) {
        break;
      }
      int v10 = *((_DWORD *)v3 + 10);
      double v11 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 134218240;
        double v15 = v9;
        __int16 v16 = 1024;
        int v17 = v10;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "#findalgs-findee, removing step time: %f, step count: %d",  buf,  0x12u);
      }

      int v12 = *(unsigned __int8 *)(a1 + 216);
      *(double *)(a1 + 200) = v9;
      *(_DWORD *)(a1 + 20_Block_object_dispose((const void *)(v1 - 112), 8) = v10;
      if (!v12) {
        *(_BYTE *)(a1 + 216) = 1;
      }
      __int128 v13 = *v4;
      sub_10001EA5C(v4, *v4);
      operator delete(v13);
      BOOL v3 = *v4;
    }

    while (*v4 != v5);
  }

void sub_1002D0244(uint64_t a1, uint64_t a2)
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003A908C();
  }
  if (*(_BYTE *)(a2 + 32) && *(_BYTE *)(a2 + 48))
  {
    *(_BYTE *)(a1 + 576) = 1;
    int v4 = (double *)(a1 + 504);
    if (!*(_BYTE *)(a1 + 528))
    {
      *int v4 = 0.0;
      *(void *)(a1 + 512) = 0LL;
      *(void *)(a1 + 520) = 0LL;
      *(_BYTE *)(a1 + 52_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
      *(void *)uint64_t v14 = 0LL;
      sub_10030DAB8(a1, (double *)v14, *(double *)a2);
      uint64_t v5 = *(void *)v14;
      int v6 = *(unsigned __int8 *)(a1 + 480);
      *(void *)(a1 + 464) = *(void *)v14;
      *(void *)(a1 + 472) = v5;
      if (!v6) {
        *(_BYTE *)(a1 + 480) = 1;
      }
    }

    if (*(_BYTE *)(a1 + 496)) {
      *(_BYTE *)(a1 + 496) = 0;
    }
    if (*(_BYTE *)(a2 + 32))
    {
      if (*(_BYTE *)(a1 + 528))
      {
        double v7 = *(double *)(a2 + 24) + *v4;
        *int v4 = v7;
        if (*(_BYTE *)(a2 + 48))
        {
          double v8 = *(double *)(a2 + 40) + *(double *)(a1 + 512);
          *(double *)(a1 + 512) = v8;
          if (*(_BYTE *)(a2 + 64)) {
            *(double *)(a1 + 520) = *(double *)(a2 + 56) + *(double *)(a1 + 520);
          }
          double v9 = (os_log_s *)qword_1008000A0;
          if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)uint64_t v14 = 134218240;
            *(double *)&void v14[4] = v7;
            __int16 v15 = 2048;
            double v16 = v8;
            _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#findalgs-findee, integrated PDR, H1 pos: %f, H2 pos: %f",  v14,  0x16u);
          }

          *(void *)uint64_t v14 = 0LL;
          sub_10030DAB8(a1, (double *)v14, *(double *)a2);
          int v10 = *(unsigned __int8 *)(a1 + 480);
          *(void *)(a1 + 464) = *(void *)v14;
          if (!v10) {
            *(_BYTE *)(a1 + 480) = 1;
          }
          if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
            sub_1003A9018();
          }
          return;
        }
      }
    }

void sub_1002D0558()
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003A90B8();
  }
}

void sub_1002D0598(uint64_t a1, uint64_t a2)
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003A90E4();
  }
  double v11 = 0.0;
  sub_10030DADC(a1, &v11, *(double *)(a2 + 8));
  if (*(void *)(a1 + 192))
  {
    uint64_t v5 = *(void **)(a1 + 184);
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 184);
      do
      {
        uint64_t v7 = v6;
        uint64_t v6 = *(void *)(v6 + 8);
      }

      while (v6);
    }

    else
    {
      uint64_t v8 = a1 + 184;
      do
      {
        uint64_t v7 = *(void *)(v8 + 16);
        BOOL v9 = *(void *)v7 == v8;
        uint64_t v8 = v7;
      }

      while (v9);
    }

    if (*(_DWORD *)(a2 + 16) < *(_DWORD *)(v7 + 40))
    {
      sub_100034A98(a1 + 176, v5);
      *(void *)(a1 + 184) = 0LL;
      *(void *)(a1 + 192) = 0LL;
      *(void *)(a1 + 176) = a1 + 184;
      if (*(_BYTE *)(a1 + 216)) {
        *(_BYTE *)(a1 + 216) = 0;
      }
    }
  }

  LODWORD(v4) = *(_DWORD *)(a2 + 16);
  v10[0] = v11;
  v10[1] = (double)v4;
  sub_1002D0828((uint64_t **)(a1 + 176), v10, (uint64_t)v10);
  *(void *)(a1 + 256) = *(void *)(a1 + 8);
  *(_BYTE *)(a1 + 264) = 1;
  sub_1002CFC40(a1, v11);
}

void sub_1002D06B0()
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003A9110();
  }
}

uint64_t sub_1002D06F0()
{
  return 0LL;
}

uint64_t sub_1002D06F8()
{
  return 1LL;
}

uint64_t sub_1002D0700()
{
  return 1LL;
}

uint64_t sub_1002D0708()
{
  return 0LL;
}

uint64_t sub_1002D0710()
{
  return 1LL;
}

uint64_t sub_1002D0718()
{
  return 0LL;
}

uint64_t sub_1002D0720()
{
  return 1LL;
}

uint64_t sub_1002D0728()
{
  return 0LL;
}

uint64_t sub_1002D0730()
{
  return 0LL;
}

uint64_t sub_1002D0738()
{
  return 1LL;
}

uint64_t sub_1002D0740()
{
  return 0LL;
}

uint64_t sub_1002D0748()
{
  return 0LL;
}

uint64_t sub_1002D0750()
{
  return 0LL;
}

uint64_t sub_1002D0758()
{
  return 1LL;
}

uint64_t sub_1002D0760()
{
  return 0LL;
}

uint64_t sub_1002D0768()
{
  return 1LL;
}

uint64_t sub_1002D0770()
{
  return 1LL;
}

uint64_t sub_1002D0778()
{
  return 1LL;
}

uint64_t sub_1002D0780()
{
  return 1LL;
}

uint64_t sub_1002D0788()
{
  return 0LL;
}

uint64_t sub_1002D0790()
{
  return 0LL;
}

uint64_t sub_1002D0798()
{
  return 1LL;
}

uint64_t sub_1002D07A0()
{
  return 1LL;
}

uint64_t sub_1002D07A8()
{
  return 0LL;
}

uint64_t sub_1002D07B0()
{
  return 0LL;
}

uint64_t sub_1002D07B8()
{
  return 0LL;
}

void sub_1002D07C4(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1002D07D8(a1);
  operator delete(v1);
}

uint64_t sub_1002D07D8(uint64_t a1)
{
  *(void *)a1 = off_1007BC678;
  if (*(_BYTE *)(a1 + 616))
  {
    unint64_t v2 = *(void **)(a1 + 584);
    if (v2)
    {
      *(void *)(a1 + 592) = v2;
      operator delete(v2);
    }
  }

  sub_100034A98(a1 + 176, *(void **)(a1 + 184));
  return a1;
}

uint64_t **sub_1002D0828(uint64_t **a1, double *a2, uint64_t a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    double v7 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v5;
        double v9 = *((double *)v5 + 4);
        if (v7 >= v9) {
          break;
        }
        uint64_t v5 = (uint64_t *)*v5;
        uint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }

      if (v9 >= v7) {
        break;
      }
      uint64_t v5 = (uint64_t *)v5[1];
      if (!v5)
      {
        uint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    uint64_t v8 = a1 + 1;
LABEL_10:
    int v10 = operator new(0x30uLL);
    double v11 = *(double *)(a3 + 8);
    v10[4] = *(void *)a3;
    *((_DWORD *)v10 + 10) = (int)v11;
    sub_10001E548(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }

  return v8;
}

void sub_1002D08E8( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

uint64_t sub_1002D090C(uint64_t a1, int a2, int a3)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  sub_1002D6534((void *)a1, (const void *)qword_1007FE8C8, qword_1007FE8D0, (qword_1007FE8D0 - qword_1007FE8C8) >> 4);
  *(void *)(a1 + 96) = &off_1007BC4C0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 2_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 36) = 0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  *(void *)(a1 + 120) = 0x100000003LL;
  *(_OWORD *)(a1 + 104) = xmmword_10042DB70;
  *(void *)(a1 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = a1 + 136;
  sub_1002CAEDC((_DWORD *)(a1 + 96), 3, 1);
  sub_1002CAF28(a1 + 96, 0.0);
  *(void *)(a1 + 240) = &off_1007BC4C0;
  *(void *)(a1 + 184) = 0x100000003LL;
  *(void *)(a1 + 160) = &off_1007BC4C0;
  *(_OWORD *)(a1 + 16_Block_object_dispose((const void *)(v1 - 112), 8) = xmmword_10042DB70;
  *(void *)(a1 + 192) = a1 + 200;
  *(void *)(a1 + 224) = 0LL;
  *(void *)(a1 + 232) = 0LL;
  *(void *)(a1 + 264) = 0x100000003LL;
  *(_OWORD *)(a1 + 24_Block_object_dispose((const void *)(v1 - 112), 8) = xmmword_10042DB70;
  *(void *)(a1 + 272) = a1 + 280;
  *(void *)(a1 + 304) = 0LL;
  *(void *)(a1 + 312) = 0LL;
  *(void *)(a1 + 320) = 0LL;
  *(void *)(a1 + 32_Block_object_dispose((const void *)(v1 - 112), 8) = 0x3FF0000000000000LL;
  *(_OWORD *)(a1 + 336) = xmmword_10042DE50;
  *(_BYTE *)(a1 + 352) = 1;
  *(void *)(a1 + 360) = 0LL;
  *(void *)(a1 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  *(void *)(a1 + 376) = 0LL;
  uint64_t v18 = 0x100000003LL;
  *(void *)__int128 buf = &off_1007BC4C0;
  __int128 v17 = xmmword_10042DB70;
  double v19 = &v20;
  sub_1002CAEDC(buf, 3, 1);
  sub_1002CAF28((uint64_t)buf, 0.0);
  uint64_t v13 = 0x100000003LL;
  double v11 = &off_1007BC4C0;
  __int128 v12 = xmmword_10042DB70;
  uint64_t v14 = &v15;
  sub_1002CAEDC(&v11, 3, 1);
  sub_1002CAF28((uint64_t)&v11, 0.0);
  sub_1002D5C4C(a1 + 384, (uint64_t)buf, (uint64_t)&v11, 0, 0.0, 0.0, 0.0, 0.0);
  unsigned int v6 = 0;
  *(_WORD *)(a1 + 560) = 257;
  *(_DWORD *)(a1 + 562) = 0;
  *(_DWORD *)(a1 + 565) = 0;
  *(void *)(a1 + 576) = 0x1000000032LL;
  *(void *)(a1 + 584) = 0x3F847AE147AE147BLL;
  *(_BYTE *)(a1 + 624) = 1;
  *(_OWORD *)(a1 + 592) = xmmword_10042DE60;
  *(_OWORD *)(a1 + 60_Block_object_dispose((const void *)(v1 - 112), 8) = xmmword_10042DE70;
  do
    *(void *)sub_1002CB32C(a1 + 240, v6++) = 0LL;
  while (v6 != 3);
  sub_1002D0CBC((uint64_t *)(a1 + 360), 4uLL);
  double v7 = &qword_1007FE8E0;
  if (a2) {
    uint64_t v8 = &qword_1007FE8C8;
  }
  else {
    uint64_t v8 = &qword_1007FE8E0;
  }
  if (v8 != (uint64_t *)a1)
  {
    if (a2) {
      double v7 = &qword_1007FE8C8;
    }
    sub_1002D6818((char *)a1, (char *)*v8, v7[1], (v7[1] - *v8) >> 4);
  }

  *(_BYTE *)(a1 + 624) = a3;
  double v9 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = a2;
    LOWORD(v17) = 1024;
    *(_DWORD *)((char *)&v17 + 2) = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_batchfilter_with,SyntheticApertureBatchFilterWithFindeeVIO constructed. Strict box span requirement %d, t hird party behavior %d",  buf,  0xEu);
  }

  return a1;
}

void sub_1002D0C30( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  *(void *)(v11 + 240) = off_1007AED90;
  *(void *)(v11 + 160) = off_1007AED90;
  void *v12 = off_1007AED90;
  sub_1002D65AC((void ***)va);
  uint64_t v15 = *v13;
  if (*v13)
  {
    *(void *)(v11 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v15;
    operator delete(v15);
  }

  double v16 = *(void **)v11;
  if (*(void *)v11)
  {
    *(void *)(v11 + _Block_object_dispose((const void *)(v1 - 112), 8) = v16;
    operator delete(v16);
  }

  _Unwind_Resume(a1);
}

void sub_1002D0CBC(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (0x2E8BA2E8BA2E8BA3LL * ((v4 - *a1) >> 4) < a2)
  {
    if (a2 >= 0x1745D1745D1745ELL) {
      sub_10001E11C();
    }
    uint64_t v5 = a1[1] - *a1;
    uint64_t v13 = v3;
    std::stringbuf::string_type __p = sub_1002D66C0(v3, a2);
    int v10 = (char *)__p + v5;
    uint64_t v11 = (char *)__p + v5;
    __int128 v12 = (char *)__p + 176 * v6;
    sub_1002D664C(a1, &__p);
    double v7 = v10;
    uint64_t v8 = v11;
    if (v11 != v10)
    {
      do
      {
        *((void *)v8 - _Block_object_dispose((const void *)(v1 - 112), 8) = off_1007AED90;
        *((void *)v8 - 17) = off_1007AED90;
        v8 -= 176;
      }

      while (v8 != v7);
      uint64_t v11 = v7;
    }

    if (__p) {
      operator delete(__p);
    }
  }

double sub_1002D0DE4@<D0>( uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D0>, double a4@<D1>, double a5@<D2>, double a6@<D3>)
{
  if (*(double *)(a1 + 224) < a3)
  {
    *(double *)(a1 + 224) = a3;
    *(double *)sub_1002CB32C(a1 + 96, 0) = a4;
    *(double *)sub_1002CB32C(a1 + 96, 1u) = a5;
    *(double *)sub_1002CB32C(a1 + 96, 2u) = a6;
    if (*(_BYTE *)(a1 + 562))
    {
      sub_1002D0EC4(a1);
      sub_1002D144C(a1);
    }
  }

  *(void *)a2 = *(void *)(a1 + 24);
  *(void *)(a2 + 5) = *(void *)(a1 + 29);
  *(void *)(a2 + 24) = 0LL;
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 16) = 0LL;
  sub_1002D5CBC( (void *)(a2 + 16),  *(const void **)(a1 + 40),  *(void *)(a1 + 48),  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 48) - *(void *)(a1 + 40)) >> 6));
  double result = *(double *)(a1 + 64);
  *(double *)(a2 + 40) = result;
  return result;
}

void sub_1002D0EC4(uint64_t a1)
{
  *(_DWORD *)(a1 + 564) = 0;
  *(_BYTE *)(a1 + 56_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  if (*(_BYTE *)(a1 + 562))
  {
    uint64_t v73 = 0x100000003LL;
    float v71 = &off_1007BC4C0;
    __int128 v72 = xmmword_10042DB70;
    int32x4_t v74 = &v75;
    sub_100319B80(*(void *)(a1 + 72), a1 + 160, (uint64_t)&v71);
    uint64_t v68 = 0x100000003LL;
    float64x2_t v66 = &off_1007BC4C0;
    __int128 v67 = xmmword_10042DB70;
    float32x2_t v69 = &v70;
    sub_1002CB44C((uint64_t)&v71, a1 + 96, (uint64_t)&v66);
    double v2 = sub_1002405E4((uint64_t)&v66, 0);
    double v3 = sub_1002405E4((uint64_t)&v66, 0);
    double v4 = sub_1002405E4((uint64_t)&v66, 2u);
    if (sqrt(v4 * sub_1002405E4((uint64_t)&v66, 2u) + v2 * v3) <= 2.0)
    {
      uint64_t v5 = *(void *)(a1 + 72);
      uint64_t v39 = *(void *)(a1 + 80);
      if (v5 != v39)
      {
        __int128 v6 = xmmword_10042DE80;
        while (1)
        {
          uint64_t v63 = 0x100000003LL;
          double v61 = &off_1007BC4C0;
          __int128 v62 = xmmword_10042DB70;
          int8x16_t v64 = &v65;
          uint64_t v58 = 0x400000003LL;
          double v56 = &off_1007BC8A8;
          __int128 v57 = v6;
          double v59 = v60;
          sub_100319DC0(v5, a1 + 160, (uint64_t)&v61, (uint64_t)&v56);
          uint64_t v48 = 0x400000003LL;
          std::stringbuf::string_type __p = &off_1007BC8A8;
          __int128 v47 = xmmword_10042DE80;
          uint64_t v7 = v5 + 136;
          float64x2_t v49 = &v50;
          sub_1002CB548((uint64_t)&v56, v7, (uint64_t)&__p);
          uint64_t v43 = 0x300000004LL;
          double v44 = 0LL;
          unint64_t v41 = 0LL;
          uint64_t v42 = 0LL;
          double v40 = &off_1007BC8F0;
          if (DWORD1(v57) > 4) {
            break;
          }
          if (v57 >= 4)
          {
            int v37 = 423;
            float64x2_t v38 = "this->max_num_cols_ >= num_cols";
LABEL_49:
            __assert_rtn("SetMatrixSize", "cnmatrixbase.h", v37, v38);
          }

          unint64_t v41 = __PAIR64__(v57, DWORD1(v57));
          LODWORD(v42) = v57 * DWORD1(v57);
          HIDWORD(v42) = DWORD1(v57);
          double v44 = &v45;
          sub_1002CB364((uint64_t)&v56, &v40);
          uint64_t v53 = 0x300000003LL;
          unsigned int v51 = &off_1007BC508;
          __int128 v52 = xmmword_10042DE90;
          double v54 = &v55;
          sub_1002CB548((uint64_t)&__p, (uint64_t)&v40, (uint64_t)&v51);
          double v8 = sub_10024061C((uint64_t)&v51, 1, 1);
          double v9 = *(double *)sub_1002CB32C((uint64_t)&v61, 1u);
          int v10 = (double *)sub_1002CB32C(a1 + 96, 1u);
          double v11 = sqrt(v8);
          double v12 = v9 - *v10;
          double v13 = v11 + v12;
          double v14 = v12 - v11;
          if (v14 <= -2.5 && v13 >= -2.5) {
            goto LABEL_19;
          }
          if (v14 <= 2.5 && v13 >= 2.5) {
            goto LABEL_19;
          }
          uint64_t v5 = v7 + 424;
          __int128 v6 = xmmword_10042DE80;
          if (v5 == v39) {
            goto LABEL_18;
          }
        }

        int v37 = 422;
        float64x2_t v38 = "this->max_num_rows_ >= num_rows";
        goto LABEL_49;
      }

void sub_1002D13F8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, void *__p, uint64_t a39)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002D144C(uint64_t a1)
{
  *(_DWORD *)int32x4_t v86 = 0;
  v86[4] = 0;
  *(_DWORD *)&v86[8] = 0;
  *(_OWORD *)std::stringbuf::string_type __p = 0u;
  __int128 v88 = 0u;
  v86[12] = 0;
  if (*(_BYTE *)(a1 + 563))
  {
    int v2 = 6;
LABEL_3:
    *(_DWORD *)int32x4_t v86 = v2;
    goto LABEL_4;
  }

  if (*(_BYTE *)(a1 + 560))
  {
    if (!*(_BYTE *)(a1 + 561))
    {
      int v2 = 1;
      goto LABEL_3;
    }
  }

  else
  {
    if (*(_BYTE *)(a1 + 561))
    {
      double v4 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v5 = *(void *)(a1 + 336);
        *(_DWORD *)__int128 buf = 134217984;
        *(void *)&uint8_t buf[4] = v5;
        _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_batchfilter_with,Linear user path length is %4.2f m",  buf,  0xCu);
      }

      else {
        int v2 = 2;
      }
      goto LABEL_3;
    }

    if (!*(_BYTE *)(a1 + 562))
    {
      int v2 = 4;
      goto LABEL_3;
    }

    *(_DWORD *)int32x4_t v86 = 5;
    *(_DWORD *)&v86[8] = *(_DWORD *)(a1 + 564);
    v86[4] = *(_DWORD *)&v86[8] == 2;
    uint64_t v6 = *(void *)(a1 + 72);
    uint64_t v39 = *(void *)(a1 + 80);
    if (v6 != v39)
    {
      uint64_t v7 = &off_1007BC8A8;
      while (1)
      {
        __int128 v98 = 0u;
        __int128 v97 = 0u;
        __int128 v96 = 0u;
        __int128 v95 = 0u;
        __int128 v94 = 0u;
        __int128 v93 = 0u;
        __int128 v92 = 0u;
        __int128 v91 = 0u;
        __int128 v90 = 0u;
        *(_OWORD *)__int128 buf = 0u;
        LODWORD(v99) = 1;
        __int128 v100 = 0uLL;
        *((void *)&v99 + 1) = 0LL;
        uint64_t v83 = 0x100000003LL;
        int32x4_t v81 = &off_1007BC4C0;
        __int128 v82 = xmmword_10042DB70;
        float32x4_t v84 = &v85;
        uint64_t v78 = 0x400000003LL;
        double v8 = v7;
        float32x4_t v76 = v7;
        __int128 v77 = xmmword_10042DE80;
        float v79 = &v80;
        sub_100319DC0(v6, a1 + 160, (uint64_t)&v81, (uint64_t)&v76);
        uint64_t v73 = 0x100000003LL;
        float v71 = &off_1007BC4C0;
        __int128 v72 = xmmword_10042DB70;
        int32x4_t v74 = &v75;
        uint64_t v68 = 0x300000003LL;
        float64x2_t v66 = &off_1007BC508;
        __int128 v67 = xmmword_10042DE90;
        float32x2_t v69 = &v70;
        uint64_t v63 = 0x100000003LL;
        double v61 = &off_1007BC4C0;
        __int128 v62 = xmmword_10042DB70;
        int8x16_t v64 = v65;
        sub_1002CB44C((uint64_t)&v81, a1 + 96, (uint64_t)&v61);
        sub_10031A418((uint64_t)&v61, (uint64_t)&v71, (uint64_t)&v66);
        uint64_t v63 = 0x400000003LL;
        double v61 = v8;
        __int128 v62 = xmmword_10042DE80;
        int8x16_t v64 = v65;
        sub_1002CB548((uint64_t)&v66, (uint64_t)&v76, (uint64_t)&v61);
        uint64_t v53 = 0x400000003LL;
        unsigned int v51 = v8;
        __int128 v52 = xmmword_10042DE80;
        double v54 = v55;
        sub_1002CB548((uint64_t)&v76, v6 + 136, (uint64_t)&v51);
        uint64_t v48 = 0x300000004LL;
        float64x2_t v49 = 0LL;
        unint64_t v46 = 0LL;
        uint64_t v47 = 0LL;
        uint64_t v45 = &off_1007BC8F0;
        if (DWORD1(v77) > 4) {
          break;
        }
        if (v77 >= 4)
        {
          int v35 = 423;
          double v36 = "this->max_num_cols_ >= num_cols";
LABEL_59:
          __assert_rtn("SetMatrixSize", "cnmatrixbase.h", v35, v36);
        }

        unint64_t v46 = __PAIR64__(v77, DWORD1(v77));
        LODWORD(v47) = v77 * DWORD1(v77);
        HIDWORD(v47) = DWORD1(v77);
        float64x2_t v49 = v50;
        sub_1002CB364((uint64_t)&v76, &v45);
        uint64_t v58 = 0x300000003LL;
        double v56 = &off_1007BC508;
        __int128 v57 = xmmword_10042DE90;
        double v59 = &v60;
        sub_1002CB548((uint64_t)&v51, (uint64_t)&v45, (uint64_t)&v56);
        uint64_t v53 = 0x400000003LL;
        unsigned int v51 = v8;
        __int128 v52 = xmmword_10042DE80;
        double v54 = v55;
        sub_1002CB548((uint64_t)&v61, v6 + 136, (uint64_t)&v51);
        uint64_t v48 = 0x300000004LL;
        float64x2_t v49 = 0LL;
        unint64_t v46 = 0LL;
        uint64_t v47 = 0LL;
        uint64_t v45 = &off_1007BC8F0;
        if (DWORD1(v62) > 4)
        {
          int v37 = 422;
          float64x2_t v38 = "this->max_num_rows_ >= num_rows";
          goto LABEL_62;
        }

        if (v62 >= 4)
        {
          int v37 = 423;
          float64x2_t v38 = "this->max_num_cols_ >= num_cols";
LABEL_62:
          __assert_rtn("SetMatrixSize", "cnmatrixbase.h", v37, v38);
        }

        unint64_t v46 = __PAIR64__(v62, DWORD1(v62));
        LODWORD(v47) = v62 * DWORD1(v62);
        HIDWORD(v47) = DWORD1(v62);
        float64x2_t v49 = v50;
        sub_1002CB364((uint64_t)&v61, &v45);
        uint64_t v42 = 0x300000003LL;
        double v40 = &off_1007BC508;
        __int128 v41 = xmmword_10042DE90;
        uint64_t v43 = &v44;
        sub_1002CB548((uint64_t)&v51, (uint64_t)&v45, (uint64_t)&v40);
        for (uint64_t i = 0LL; i != 3; ++i)
          *(void *)&buf[8 * i] = *(void *)sub_1002CB32C((uint64_t)&v81, i);
        *((void *)&v90 + 1) = sub_10024061C((uint64_t)&v56, 0, 0);
        *(void *)&__int128 v91 = sub_10024061C((uint64_t)&v56, 0, 1);
        *((void *)&v91 + 1) = sub_10024061C((uint64_t)&v56, 0, 2);
        *(void *)&__int128 v92 = sub_10024061C((uint64_t)&v56, 1, 1);
        *((void *)&v92 + 1) = sub_10024061C((uint64_t)&v56, 1, 2);
        *(void *)&__int128 v93 = sub_10024061C((uint64_t)&v56, 2, 2);
        int v10 = v57;
        if ((_DWORD)v57 != DWORD1(v57)) {
          __assert_rtn("Trace", "cnmatrixbase.h", 4977, "A.NumRows() == A.NumCols()");
        }
        if ((int)v57 < 1)
        {
          double v12 = 0.0;
        }

        else
        {
          int v11 = 0;
          double v12 = 0.0;
          do
          {
            double v12 = v12 + sub_1002D6C54((uint64_t)&v56, v11, v11);
            ++v11;
          }

          while (v10 != v11);
        }

        uint64_t v13 = *(void *)(v6 + 416);
        *((void *)&v93 + 1) = sqrt(v12);
        *(void *)&__int128 v94 = v13;
        LODWORD(v99) = *(_DWORD *)(v6 + 424);
        *((void *)&v94 + 1) = *(void *)sub_1002CB32C((uint64_t)&v71, 0);
        *(void *)&__int128 v95 = *(void *)sub_1002CB32C((uint64_t)&v71, 1u);
        *((void *)&v95 + 1) = *(void *)sub_1002CB32C((uint64_t)&v71, 2u);
        *(void *)&__int128 v96 = sqrt(sub_10024061C((uint64_t)&v40, 0, 0));
        *((void *)&v96 + 1) = sqrt(sub_10024061C((uint64_t)&v40, 1, 1));
        uint64_t v14 = 0LL;
        *(void *)&__int128 v97 = sqrt(sub_10024061C((uint64_t)&v40, 2, 2));
        do
        {
          uint64_t v15 = &buf[8 * v14];
          *((void *)v15 + 17) = *(void *)sub_1002CB32C(a1 + 96, v14);
          *((void *)v15 + 21) = *(void *)sub_1002CB32C(a1 + 160, v14++);
        }

        while (v14 != 3);
        double v16 = __p[1];
        if (__p[1] >= (void *)v88)
        {
          uint64_t v18 = __p[0];
          unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * (((char *)__p[1] - (char *)__p[0]) >> 6);
          unint64_t v20 = v19 + 1;
          if (v19 + 1 > 0x155555555555555LL) {
            sub_10001E11C();
          }
          else {
            unint64_t v21 = v20;
          }
          if (v21)
          {
            double v22 = (char *)sub_1002D5D84((uint64_t)&v88, v21);
            double v16 = __p[1];
            uint64_t v18 = __p[0];
          }

          else
          {
            double v22 = 0LL;
          }

          double v23 = &v22[192 * v19];
          *((_OWORD *)v23 + _Block_object_dispose((const void *)(v1 - 112), 8) = v97;
          *((_OWORD *)v23 + 9) = v98;
          *((_OWORD *)v23 + 10) = v99;
          *((_OWORD *)v23 + 11) = v100;
          *((_OWORD *)v23 + 4) = v93;
          *((_OWORD *)v23 + 5) = v94;
          *((_OWORD *)v23 + 6) = v95;
          *((_OWORD *)v23 + 7) = v96;
          *(_OWORD *)double v23 = *(_OWORD *)buf;
          *((_OWORD *)v23 + 1) = v90;
          *((_OWORD *)v23 + 2) = v91;
          *((_OWORD *)v23 + 3) = v92;
          if (v16 == v18)
          {
            double v34 = &v22[192 * v19];
          }

          else
          {
            double v24 = &v22[192 * v19];
            do
            {
              __int128 v25 = *(v16 - 12);
              __int128 v26 = *(v16 - 11);
              __int128 v27 = *(v16 - 9);
              *((_OWORD *)v24 - 10) = *(v16 - 10);
              *((_OWORD *)v24 - 9) = v27;
              *((_OWORD *)v24 - 12) = v25;
              *((_OWORD *)v24 - 11) = v26;
              __int128 v28 = *(v16 - 8);
              __int128 v29 = *(v16 - 7);
              __int128 v30 = *(v16 - 5);
              *((_OWORD *)v24 - 6) = *(v16 - 6);
              *((_OWORD *)v24 - 5) = v30;
              *((_OWORD *)v24 - _Block_object_dispose((const void *)(v1 - 112), 8) = v28;
              *((_OWORD *)v24 - 7) = v29;
              __int128 v31 = *(v16 - 4);
              __int128 v32 = *(v16 - 3);
              __int128 v33 = *(v16 - 1);
              double v34 = v24 - 192;
              *((_OWORD *)v24 - 2) = *(v16 - 2);
              *((_OWORD *)v24 - 1) = v33;
              *((_OWORD *)v24 - 4) = v31;
              *((_OWORD *)v24 - 3) = v32;
              v16 -= 12;
              v24 -= 192;
            }

            while (v16 != v18);
          }

          unint64_t v17 = v23 + 192;
          __p[0] = v34;
          __p[1] = v23 + 192;
          *(void *)&__int128 v88 = &v22[192 * v21];
          if (v18) {
            operator delete(v18);
          }
        }

        else
        {
          *((_OWORD *)__p[1] + _Block_object_dispose((const void *)(v1 - 112), 8) = v97;
          v16[9] = v98;
          v16[10] = v99;
          v16[11] = v100;
          void v16[4] = v93;
          void v16[5] = v94;
          int v16[6] = v95;
          v16[7] = v96;
          *double v16 = *(_OWORD *)buf;
          v16[1] = v90;
          void v16[2] = v91;
          v16[3] = v92;
          unint64_t v17 = v16 + 12;
        }

        __p[1] = v17;
        if (!*(_BYTE *)(a1 + 352)) {
          sub_100006080();
        }
        *((void *)&v88 + 1) = *(void *)(a1 + 344);
        v6 += 560LL;
        uint64_t v7 = v8;
        if (v6 == v39) {
          goto LABEL_4;
        }
      }

      int v35 = 422;
      double v36 = "this->max_num_rows_ >= num_rows";
      goto LABEL_59;
    }
  }

LABEL_4:
  double v3 = (char *)__p[0];
  *(void *)(a1 + 24) = *(void *)v86;
  *(void *)(a1 + 29) = *(void *)&v86[5];
  if ((_BYTE *)(a1 + 24) != v86)
  {
    sub_1002D5DC8((char *)(a1 + 40), v3, (uint64_t)__p[1], 0xAAAAAAAAAAAAAAABLL * (((char *)__p[1] - (char *)v3) >> 6));
    double v3 = (char *)__p[0];
  }

  *(void *)(a1 + 64) = *((void *)&v88 + 1);
  if (v3)
  {
    __p[1] = v3;
    operator delete(v3);
  }

  double result = *v4;
  a2[5] = *(void *)v4;
  return result;
}

void sub_1002D1E04(_Unwind_Exception *a1)
{
  int v2 = (void *)STACK[0x4A0];
  if (STACK[0x4A0])
  {
    STACK[0x4A8] = (unint64_t)v2;
    operator delete(v2);
  }

  _Unwind_Resume(a1);
}

double sub_1002D1E74@<D0>( uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D0>, double a4@<D1>, double a5@<D2>, double a6@<D3>)
{
  if (*(double *)(a1 + 232) < a3)
  {
    *(double *)(a1 + 232) = a3;
    *(double *)sub_1002CB32C(a1 + 160, 0) = a4;
    *(double *)sub_1002CB32C(a1 + 160, 1u) = a5;
    *(double *)sub_1002CB32C(a1 + 160, 2u) = a6;
    sub_1002D0EC4(a1);
    sub_1002D144C(a1);
  }

  *(void *)a2 = *(void *)(a1 + 24);
  *(void *)(a2 + 5) = *(void *)(a1 + 29);
  *(void *)(a2 + 24) = 0LL;
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 16) = 0LL;
  sub_1002D5CBC( (void *)(a2 + 16),  *(const void **)(a1 + 40),  *(void *)(a1 + 48),  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 48) - *(void *)(a1 + 40)) >> 6));
  double result = *(double *)(a1 + 64);
  *(double *)(a2 + 40) = result;
  return result;
}

void *sub_1002D1F4C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  if (*(_BYTE *)(a1 + 563))
  {
    *(_BYTE *)(a1 + 563) = 0;
    if (*(void *)(a1 + 360) != *(void *)(a1 + 368)) {
      sub_1002D2AA0(a1);
    }
  }

  uint64_t v84 = 0x100000003LL;
  __int128 v82 = &off_1007BC4C0;
  __int128 v83 = xmmword_10042DB70;
  uint64_t v85 = &v86;
  sub_1002CAEDC(&v82, 3, 1);
  sub_1002CAF28((uint64_t)&v82, 0.0);
  uint64_t v79 = 0x100000004LL;
  __int128 v77 = &off_1007BC550;
  __int128 v78 = xmmword_10042DB80;
  uint64_t v80 = &v81;
  sub_1002CAEDC(&v77, 4, 1);
  sub_1002CAF28((uint64_t)&v77, 0.0);
  uint64_t v74 = 0x100000003LL;
  __int128 v72 = &off_1007BC4C0;
  __int128 v73 = xmmword_10042DB70;
  uint64_t v75 = &v76;
  sub_1002CAEDC(&v72, 3, 1);
  sub_1002CAF28((uint64_t)&v72, 0.0);
  uint64_t v6 = 0LL;
  uint64_t v7 = (uint64_t *)(a2 + 152);
  do
  {
    uint64_t v8 = *(v7 - 7);
    *(void *)sub_1002CB32C((uint64_t)&v82, v6) = v8;
    uint64_t v9 = *(v7 - 4);
    *(void *)sub_1002CB32C((uint64_t)&v77, v6) = v9;
    uint64_t v10 = *v7;
    *(void *)sub_1002CB32C((uint64_t)&v72, v6++) = v10;
    ++v7;
  }

  while (v6 != 3);
  uint64_t v11 = *(void *)(a2 + 144);
  *(void *)sub_1002CB32C((uint64_t)&v77, 3u) = v11;
  sub_1003198FC((uint64_t)&v77, (uint64_t)v71);
  uint64_t v98 = 0x100000003LL;
  *(void *)__int128 buf = &off_1007BC4C0;
  *(_OWORD *)&uint8_t buf[8] = xmmword_10042DB70;
  __int128 v99 = v100;
  sub_1002CB548((uint64_t)v71, a1 + 240, (uint64_t)buf);
  uint64_t v68 = 0x100000003LL;
  float64x2_t v66 = &off_1007BC4C0;
  __int128 v67 = xmmword_10042DB70;
  float32x2_t v69 = &v70;
  sub_1002CC25C((uint64_t)&v82, (uint64_t)buf, (uint64_t)&v66);
  double v12 = *(double *)a2;
  *(void *)(a1 + 312) = *(void *)a2;
  if (v12 > *(double *)(a1 + 224))
  {
    sub_1002CBDC8(a1 + 96, (uint64_t)&v82);
    double v12 = *(double *)a2;
    *(void *)(a1 + 224) = *(void *)a2;
  }

  if (v12 > *(double *)(a1 + 232))
  {
    sub_1002CBDC8(a1 + 160, (uint64_t)&v72);
    *(void *)(a1 + 232) = *(void *)a2;
  }

  double v13 = *(double *)(a2 + 16);
  if (v13 <= 0.0 || *(double *)(a2 + 8) < -1.0)
  {
    uint64_t v14 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
      sub_1003A9144(a2, v14, v13);
    }
    goto LABEL_68;
  }

  uint64_t v15 = *(void *)(a1 + 368);
  if (v15 == *(void *)(a1 + 360)) {
    goto LABEL_42;
  }
  uint64_t v63 = 0x100000003LL;
  double v61 = &off_1007BC4C0;
  __int128 v62 = xmmword_10042DB70;
  int8x16_t v64 = v65;
  sub_1002CB44C((uint64_t)&v66, v15 - 136, (uint64_t)&v61);
  uint64_t v94 = 0x100000003LL;
  __int128 v92 = &off_1007BC4C0;
  __int128 v93 = xmmword_10042DB70;
  __int128 v95 = v96;
  uint64_t v98 = 0x100000134LL;
  *(void *)__int128 buf = &off_1007BC598;
  *(_OWORD *)&uint8_t buf[8] = xmmword_10042DB90;
  __int128 v99 = v100;
  uint64_t v89 = 0x100000003LL;
  int8x16_t v87 = &off_1007BC4C0;
  __int128 v88 = xmmword_10042DB70;
  __int128 v90 = v91;
  sub_1002CB6A8((uint64_t)&v61, (uint64_t)&v92, (uint64_t)buf, (uint64_t)&v87, "2");
  double v17 = v16;
  uint64_t v63 = 0x100000003LL;
  double v61 = &off_1007BC4C0;
  __int128 v62 = xmmword_10042DB70;
  int8x16_t v64 = v65;
  sub_1002CB44C(a1 + 160, v15 - 64, (uint64_t)&v61);
  uint64_t v94 = 0x100000003LL;
  __int128 v92 = &off_1007BC4C0;
  __int128 v93 = xmmword_10042DB70;
  __int128 v95 = v96;
  uint64_t v98 = 0x100000134LL;
  *(void *)__int128 buf = &off_1007BC598;
  *(_OWORD *)&uint8_t buf[8] = xmmword_10042DB90;
  __int128 v99 = v100;
  uint64_t v89 = 0x100000003LL;
  int8x16_t v87 = &off_1007BC4C0;
  __int128 v88 = xmmword_10042DB70;
  __int128 v90 = v91;
  sub_1002CB6A8((uint64_t)&v61, (uint64_t)&v92, (uint64_t)buf, (uint64_t)&v87, "2");
  double v19 = v17 + v18;
  double v20 = *(double *)(a2 + 8);
  double v21 = *(double *)(v15 - 168);
  double v22 = v20 - v21;
  if (v20 - v21 <= 0.0)
  {
    if ((fabs(v22) - v19) / *(double *)(a2 + 16) > 6.0)
    {
      double v24 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 134218496;
        *(double *)&uint8_t buf[4] = v21;
        *(_WORD *)&_BYTE buf[12] = 2048;
        *(double *)&buf[14] = v20;
        *(_WORD *)&buf[22] = 2048;
        uint64_t v98 = *(void *)&v19;
        _os_log_error_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_ERROR,  "#sa_algo_batchfilter_with,nLoS->LoS event detected by the batch filter: Previous range %f m, Current range %f m, Distance travelled %f m",  buf,  0x20u);
      }

      uint64_t v25 = *(void *)(a1 + 360);
      __int128 i = xmmword_10042DB70;
      if (v25 != *(void *)(a1 + 368))
      {
        do
        {
          uint64_t v63 = 0x100000003LL;
          double v61 = &off_1007BC4C0;
          __int128 v62 = i;
          int8x16_t v64 = v65;
          sub_1002CB44C((uint64_t)&v66, v25 + 40, (uint64_t)&v61);
          uint64_t v94 = 0x100000003LL;
          __int128 v92 = &off_1007BC4C0;
          __int128 v93 = xmmword_10042DB70;
          __int128 v95 = v96;
          uint64_t v98 = 0x100000134LL;
          *(void *)__int128 buf = &off_1007BC598;
          *(_OWORD *)&uint8_t buf[8] = xmmword_10042DB90;
          __int128 v99 = v100;
          uint64_t v89 = 0x100000003LL;
          int8x16_t v87 = &off_1007BC4C0;
          __int128 v88 = xmmword_10042DB70;
          __int128 v90 = v91;
          sub_1002CB6A8((uint64_t)&v61, (uint64_t)&v92, (uint64_t)buf, (uint64_t)&v87, "2");
          double v28 = v27;
          uint64_t v63 = 0x100000003LL;
          double v61 = &off_1007BC4C0;
          __int128 v62 = xmmword_10042DB70;
          int8x16_t v64 = v65;
          sub_1002CB44C((uint64_t)&v72, v25 + 112, (uint64_t)&v61);
          uint64_t v94 = 0x100000003LL;
          __int128 v92 = &off_1007BC4C0;
          __int128 v93 = xmmword_10042DB70;
          __int128 v95 = v96;
          uint64_t v98 = 0x100000134LL;
          *(void *)__int128 buf = &off_1007BC598;
          *(_OWORD *)&uint8_t buf[8] = xmmword_10042DB90;
          __int128 v99 = v100;
          uint64_t v89 = 0x100000003LL;
          int8x16_t v87 = &off_1007BC4C0;
          __int128 v88 = xmmword_10042DB70;
          __int128 v90 = v91;
          sub_1002CB6A8((uint64_t)&v61, (uint64_t)&v92, (uint64_t)buf, (uint64_t)&v87, "2");
          double v30 = v28 + v29;
          double v31 = *(double *)(v25 + 8);
          if ((v31 - *(double *)(a2 + 8) - v30) / *(double *)(a2 + 16) <= 6.0)
          {
            v25 += 176LL;
            uint64_t v34 = *(void *)(a1 + 368);
            __int128 i = xmmword_10042DB70;
          }

          else
          {
            __int128 v32 = a3;
            __int128 v33 = (os_log_s *)qword_1008000A0;
            if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR))
            {
              uint64_t v36 = *(void *)v25;
              *(_DWORD *)__int128 buf = 134218240;
              *(void *)&uint8_t buf[4] = v36;
              *(_WORD *)&_BYTE buf[12] = 2048;
              *(double *)&buf[14] = v31;
              _os_log_error_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_ERROR,  "#sa_algo_batchfilter_with,Removing measurement at time %f s with range %f m",  buf,  0x16u);
            }

            sub_1002D6920((uint64_t)buf, (__int128 *)(v25 + 176), *(__int128 **)(a1 + 368), v25);
            a3 = v32;
            uint64_t v35 = *(void *)(a1 + 368);
            for (__int128 i = xmmword_10042DB70; v35 != v34; v35 -= 176LL)
            {
              *(void *)(v35 - 64) = off_1007AED90;
              *(void *)(v35 - 136) = off_1007AED90;
            }

            *(void *)(a1 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = v34;
          }
        }

        while (v25 != v34);
      }

      sub_1002D2BC4(a1);
      int v37 = *(double **)(a1 + 360);
      float64x2_t v38 = *(double **)(a1 + 368);
      if (v37 == v38)
      {
        *(void *)(a1 + 32_Block_object_dispose((const void *)(v1 - 112), 8) = 0x3FF0000000000000LL;
      }

      else
      {
        uint64_t v39 = v37 + 22;
        double v40 = *(double **)(a1 + 360);
        if (v37 + 22 != v38)
        {
          double v40 = *(double **)(a1 + 360);
          do
          {
            if (v39[1] < v40[1]) {
              double v40 = v39;
            }
            v39 += 22;
          }

          while (v39 != v38);
        }

        double v41 = fmax(v40[1], 1.0);
        if (v41 != *(double *)(a1 + 328))
        {
          *(double *)(a1 + 32_Block_object_dispose((const void *)(v1 - 112), 8) = v41;
          do
          {
            double v42 = sub_100319B40(v37[1] / *(double *)(a1 + 328));
            v37[4] = v42;
            v37[2] = v37[1] / (v42 * v37[3]);
            v37 += 22;
          }

          while (v37 != v38);
        }
      }
    }

    goto LABEL_42;
  }

  if ((v22 - v19) / *(double *)(a2 + 16) <= 6.0)
  {
LABEL_42:
    uint64_t v43 = *(double **)(a1 + 360);
    uint64_t v44 = *(double **)(a1 + 368);
    double v45 = *(double *)(a2 + 8);
    if (v43 == v44)
    {
      double v50 = fmax(v45, 1.0);
      *(double *)(a1 + 32_Block_object_dispose((const void *)(v1 - 112), 8) = v50;
      unsigned int v51 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 134217984;
        *(double *)&uint8_t buf[4] = v50;
        _os_log_impl( (void *)&_mh_execute_header,  v51,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_batchfilter_with,Minimum observed range initialized to %f m",  buf,  0xCu);
      }
    }

    else
    {
      double v46 = *(double *)(a1 + 328);
      if (v45 < v46 && v46 > 1.0)
      {
        double v47 = fmax(v45, 1.0);
        *(double *)(a1 + 32_Block_object_dispose((const void *)(v1 - 112), 8) = v47;
        uint64_t v48 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 134217984;
          *(double *)&uint8_t buf[4] = v47;
          _os_log_impl( (void *)&_mh_execute_header,  v48,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_batchfilter_with,Minimum observed range changed to %f m",  buf,  0xCu);
          uint64_t v43 = *(double **)(a1 + 360);
          uint64_t v44 = *(double **)(a1 + 368);
        }

        while (v43 != v44)
        {
          double v49 = sub_100319B40(v43[1] / *(double *)(a1 + 328));
          v43[4] = v49;
          v43[2] = v43[1] / (v49 * v43[3]);
          v43 += 22;
        }
      }
    }

    double v52 = sub_100319B40(*(double *)(a2 + 8) / *(double *)(a1 + 328));
    double v53 = *(double *)(a2 + 8);
    double v54 = v53 / 10.0 * 0.1;
    if (v53 <= 10.0) {
      double v54 = 0.1;
    }
    sub_1002D5C4C((uint64_t)buf, (uint64_t)&v66, (uint64_t)&v72, *(_DWORD *)(a2 + 24), *(double *)a2, v53, v54, v52);
    unint64_t v55 = *(void *)(a1 + 368);
    if (v55 >= *(void *)(a1 + 376))
    {
      uint64_t v56 = sub_1002D69A4((uint64_t *)(a1 + 360), (__int128 *)buf);
    }

    else
    {
      sub_1002D6B30(a1 + 376, *(void *)(a1 + 368), (__int128 *)buf);
      uint64_t v56 = v55 + 176;
      *(void *)(a1 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = v55 + 176;
    }

    *(void *)(a1 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = v56;
    goto LABEL_58;
  }

  double v23 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)__int128 buf = 134218496;
    *(double *)&uint8_t buf[4] = v21;
    *(_WORD *)&_BYTE buf[12] = 2048;
    *(double *)&buf[14] = v20;
    *(_WORD *)&buf[22] = 2048;
    uint64_t v98 = *(void *)&v19;
    _os_log_error_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_ERROR,  "#sa_algo_batchfilter_with,LoS->nLoS event detected by the batch filter: Previous range %f m, Current range %f m, D istance travelled %f m",  buf,  0x20u);
  }

void sub_1002D2A68(_Unwind_Exception *a1)
{
  *(void *)(v1 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1002D2AA0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 360);
  for (uint64_t i = *(void *)(a1 + 368); i != v2; i -= 176LL)
  {
    *(void *)(i - 64) = off_1007AED90;
    *(void *)(i - 136) = off_1007AED90;
  }

  *(void *)(a1 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = v2;
  sub_1002D2BC4(a1);
  double v4 = *(void **)(a1 + 40);
  *(void *)(a1 + 29) = 0LL;
  *(void *)(a1 + 24) = 0LL;
  if (v4)
  {
    *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v4;
    operator delete(v4);
  }

  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 304) = 0LL;
  *(void *)(a1 + 312) = 0LL;
  *(void *)(a1 + 320) = 0LL;
  *(void *)(a1 + 32_Block_object_dispose((const void *)(v1 - 112), 8) = 0x3FF0000000000000LL;
  uint64_t v5 = *(void **)(a1 + 72);
  uint64_t v6 = *(void **)(a1 + 80);
  if (v6 != v5)
  {
    do
    {
      *(v6 - _Block_object_dispose((const void *)(v1 - 112), 8) = off_1007AED90;
      *(v6 - 16) = off_1007AED90;
      *(v6 - 32) = off_1007AED90;
      uint64_t v7 = v6 - 61;
      uint64_t v8 = v6 - 70;
      *(v6 - 53) = off_1007AED90;
      void *v8 = off_1007AED90;
      v6 -= 70;
      *uint64_t v7 = off_1007AED90;
    }

    while (v8 != v5);
  }

  *(void *)(a1 + 80) = v5;
  if (*(_BYTE *)(a1 + 352)) {
    *(_BYTE *)(a1 + 352) = 0;
  }
  uint64_t v9 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    v10[0] = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_batchfilter_with,Batch filter is reinitialized",  (uint8_t *)v10,  2u);
  }

void sub_1002D2BC4(uint64_t a1)
{
  *(void *)(a1 + 320) = *(void *)(a1 + 304);
  *(_WORD *)(a1 + 560) = 257;
  *(void *)(a1 + 336) = 0LL;
  *(_BYTE *)(a1 + 562) = 0;
  *(_BYTE *)(a1 + 56_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_DWORD *)(a1 + 564) = 0;
  uint64_t v1 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v1,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_batchfilter_with,Batch filter is reset",  v2,  2u);
  }

void sub_1002D2C48(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 360);
  uint64_t v2 = *(void *)(a1 + 368);
  if (v1 != v2)
  {
    if (v1 + 176 != v2)
    {
      uint64_t v3 = v1 + 288;
      do
      {
        __int128 v4 = *(_OWORD *)v1;
        __int128 v5 = *(_OWORD *)(v1 + 16);
        uint64_t v25 = *(void *)(v1 + 32);
        v24[0] = v4;
        v24[1] = v5;
        sub_1002D5F00((uint64_t)&v26, v1 + 40);
        int v27 = *(_DWORD *)(v1 + 104);
        sub_1002D5F00((uint64_t)&v28, v1 + 112);
        __int128 v6 = *(_OWORD *)(v3 - 112);
        __int128 v7 = *(_OWORD *)(v3 - 96);
        uint64_t v20 = *(void *)(v3 - 80);
        v19[0] = v6;
        v19[1] = v7;
        sub_1002D5F00((uint64_t)&v21, v3 - 72);
        int v22 = *(_DWORD *)(v3 - 8);
        sub_1002D5F00((uint64_t)&v23, v3);
        double v23 = off_1007AED90;
        double v21 = off_1007AED90;
        double v28 = off_1007AED90;
        __int128 v26 = off_1007AED90;
        uint64_t v8 = v3 + 64;
        v3 += 176LL;
      }

      while (v8 != v2);
    }

    uint64_t v9 = *(double **)a1;
    uint64_t v10 = *(double **)(a1 + 8);
    if (*(double **)a1 != v10)
    {
      BOOL v11 = 0;
      double v12 = *(double *)(v1 + 8);
      do
      {
        if (v11)
        {
          BOOL v11 = 1;
        }

        else
        {
          LOBYTE(v19[0]) = 1;
          char v18 = 0;
          *(void *)&v24[0] = 0LL;
          sub_1002D5120(*v9, v9[1], a1, (uint64_t *)(a1 + 360), (BOOL *)v19, &v18, (double *)v24);
          int v13 = LOBYTE(v19[0]);
          if (*(_BYTE *)(a1 + 560)) {
            BOOL v14 = LOBYTE(v19[0]) == 0;
          }
          else {
            BOOL v14 = 1;
          }
          char v15 = !v14;
          *(_BYTE *)(a1 + 560) = v15;
          if (!v13)
          {
            if (!v18)
            {
              *(_BYTE *)(a1 + 561) = 0;
              return;
            }

            double v16 = *(double *)(a1 + 336);
            *(double *)(a1 + 336) = v16;
          }

          BOOL v11 = v12 <= v9[1];
        }

        v9 += 2;
      }

      while (v9 != v10);
    }
  }

BOOL sub_1002D2E10(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 360);
  uint64_t v1 = *(void *)(a1 + 368);
  if ((unint64_t)(0x2E8BA2E8BA2E8BA3LL * ((v1 - v2) >> 4)) >= 4)
  {
    uint64_t v120 = 0LL;
    unint64_t v121 = 0LL;
    unint64_t v122 = 0LL;
    __int128 v5 = (uint64_t *)(a1 + 72);
    uint64_t v4 = *(void *)(a1 + 72);
    uint64_t v6 = *(void *)(a1 + 80);
    if (*(_BYTE *)(a1 + 562)) {
      BOOL v7 = 0;
    }
    else {
      BOOL v7 = v4 == v6;
    }
    if (v7)
    {
      if (v2 != v1)
      {
        for (uint64_t i = v2 + 176; i != v1; i += 176LL)
        {
        }
      }

      else {
        double v19 = 0.5;
      }
      sub_1002D5F00((uint64_t)v110, v2 + 40);
      sub_1002D5F00((uint64_t)v119, v2 + 112);
      unsigned int v20 = 0;
      uint64_t v116 = 0LL;
      unint64_t v117 = 0LL;
      unint64_t v118 = 0LL;
      do
      {
        sub_1002D5F00((uint64_t)buf, (uint64_t)v110);
        sub_1002D5F00((uint64_t)&v105, (uint64_t)v110);
        double v21 = *(double *)sub_1002CB32C((uint64_t)buf, v20);
        *(double *)sub_1002CB32C((uint64_t)buf, v20) = v19 + v21;
        double v22 = *(double *)sub_1002CB32C((uint64_t)&v105, v20);
        *(double *)sub_1002CB32C((uint64_t)&v105, v20) = v22 - v19;
        sub_1002D3DB4(&v116, (uint64_t)buf);
        sub_1002D3DB4(&v116, (uint64_t)&v105);
        ++v20;
      }

      while (v20 != 3);
      uint64_t v23 = v116;
      for (uint64_t j = v117; v23 != j; v23 += 64LL)
      {
        for (uint64_t k = 0LL; k != 6; ++k)
        {
          double v25 = *(double *)&qword_10042DFB0[k];
          __double2 v26 = __sincos_stret(v25);
          uint64_t v124 = 0x300000003LL;
          *(void *)__int128 buf = &off_1007BC508;
          *(_OWORD *)&uint8_t buf[8] = xmmword_10042DE90;
          float32x4_t v125 = &v126;
          *(double *)sub_1002CB40C((uint64_t)buf, 0, 0) = v26.__cosval;
          *(void *)sub_1002CB40C((uint64_t)buf, 1, 0) = 0LL;
          *(double *)sub_1002CB40C((uint64_t)buf, 2, 0) = -v26.__sinval;
          *(void *)sub_1002CB40C((uint64_t)buf, 0, 1) = 0LL;
          *(void *)sub_1002CB40C((uint64_t)buf, 1, 1) = 0x3FF0000000000000LL;
          *(void *)sub_1002CB40C((uint64_t)buf, 2, 1) = 0LL;
          *(double *)sub_1002CB40C((uint64_t)buf, 0, 2) = v26.__sinval;
          *(void *)sub_1002CB40C((uint64_t)buf, 1, 2) = 0LL;
          *(double *)sub_1002CB40C((uint64_t)buf, 2, 2) = v26.__cosval;
          uint64_t v107 = 0x100000003LL;
          __int128 v105 = &off_1007BC4C0;
          __int128 v106 = xmmword_10042DB70;
          __int128 v108 = v109;
          sub_1002CB548((uint64_t)buf, (uint64_t)v119, (uint64_t)&v105);
          uint64_t v113 = 0x100000003LL;
          __int128 v111 = &off_1007BC4C0;
          __int128 v112 = xmmword_10042DB70;
          __int128 v114 = &v115;
          sub_1002CB44C(v23, (uint64_t)&v105, (uint64_t)&v111);
          uint64_t v107 = 0x100000004LL;
          __int128 v105 = &off_1007BC550;
          __int128 v106 = xmmword_10042DB80;
          __int128 v108 = v109;
          double v27 = sub_1002405E4((uint64_t)&v111, 0);
          *(double *)sub_1002CB32C((uint64_t)&v105, 0) = v27;
          double v28 = sub_1002405E4((uint64_t)&v111, 1u);
          *(double *)sub_1002CB32C((uint64_t)&v105, 1u) = v28;
          double v29 = sub_1002405E4((uint64_t)&v111, 2u);
          *(double *)sub_1002CB32C((uint64_t)&v105, 2u) = v29;
          *(double *)sub_1002CB32C((uint64_t)&v105, 3u) = v25;
          unint64_t v30 = v121;
          if (v121 >= v122)
          {
            uint64_t v31 = sub_1002D6D20(&v120, (uint64_t)&v105);
          }

          else
          {
            sub_1002D61D4(v121, (uint64_t)&v105);
            uint64_t v31 = v30 + 72;
          }

          unint64_t v121 = v31;
        }
      }

      *(void *)__int128 buf = &v116;
      sub_1002D6F98((void ***)buf);
    }

    else
    {
      if (v4 != v6)
      {
        unint64_t v8 = 0LL;
        do
        {
          if (v8 >= v122)
          {
            unint64_t v8 = sub_1002D6D20(&v120, v4);
          }

          else
          {
            sub_1002D61D4(v8, v4);
            v8 += 72LL;
          }

          unint64_t v121 = v8;
          v4 += 560LL;
        }

        while (v4 != v6);
        uint64_t v6 = *v5;
      }

      sub_1002D61D4((uint64_t)buf, v6);
      uint64_t v9 = &qword_10042DF80;
      do
      {
        uint64_t v10 = 0LL;
        double v11 = *(double *)v9;
        do
        {
          if (v11 != 0.0 || *(double *)&qword_10042DF98[v10] != 0.0)
          {
            sub_1002D61D4((uint64_t)&v105, (uint64_t)buf);
            double v12 = *(double *)sub_1002CB32C((uint64_t)&v105, 1u);
            *(double *)sub_1002CB32C((uint64_t)&v105, 1u) = v11 + v12;
            double v13 = *(double *)sub_1002CB32C((uint64_t)&v105, 3u);
            double v14 = *(double *)&qword_10042DF98[v10];
            *(double *)sub_1002CB32C((uint64_t)&v105, 3u) = v13 + v14;
            unint64_t v15 = v121;
            if (v121 >= v122)
            {
              uint64_t v16 = sub_1002D6D20(&v120, (uint64_t)&v105);
            }

            else
            {
              sub_1002D61D4(v121, (uint64_t)&v105);
              uint64_t v16 = v15 + 72;
            }

            unint64_t v121 = v16;
          }

          ++v10;
        }

        while (v10 != 3);
        ++v9;
      }

      while (v9 != qword_10042DF98);
    }

    __int128 v111 = 0LL;
    __int128 v112 = 0uLL;
    uint64_t v33 = v120;
    unint64_t v32 = v121;
    if (v120 == v121)
    {
      uint64_t v35 = 0LL;
      uint64_t v37 = 0LL;
    }

    else
    {
      do
      {
        sub_1002D3EC4(a1, v33, a1 + 360, (uint64_t)buf);
        uint64_t v34 = v112;
        if ((unint64_t)v112 >= *((void *)&v112 + 1))
        {
          uint64_t v35 = sub_1002D7218((uint64_t *)&v111, (uint64_t)buf);
        }

        else
        {
          sub_1002D733C((uint64_t)&v112 + 8, v112, (uint64_t)buf);
          uint64_t v35 = v34 + 616;
        }

        *(void *)&__int128 v112 = v35;
        v33 += 72LL;
      }

      while (v33 != v32);
      for (m = v111; ; m += 77)
      {
        if (m == (uint64_t (**)())v35)
        {
          uint64_t v37 = v35;
          goto LABEL_63;
        }

        if (!*(_BYTE *)m) {
          break;
        }
      }

      if (m == (uint64_t (**)())v35 || m + 77 == (uint64_t (**)())v35)
      {
        uint64_t v37 = (uint64_t)m;
      }

      else
      {
        uint64_t v37 = (uint64_t)m;
        do
        {
          if (*((_BYTE *)m + 616))
          {
            *(_BYTE *)uint64_t v37 = *((_BYTE *)m + 616);
            sub_1002CBDC8(v37 + 8, (uint64_t)(m + 78));
            sub_1002CBDC8(v37 + 80, (uint64_t)(m + 87));
            sub_1002CBDC8(v37 + 144, (uint64_t)(m + 95));
            sub_1002CBDC8(v37 + 208, (uint64_t)(m + 103));
            sub_1002CBDC8(v37 + 376, (uint64_t)(m + 124));
            sub_1002CBDC8(v37 + 488, (uint64_t)(m + 138));
            float64x2_t v38 = m[152];
            *(_DWORD *)(v37 + 60_Block_object_dispose((const void *)(v1 - 112), 8) = *((_DWORD *)m + 306);
            *(void *)(v37 + 600) = v38;
            v37 += 616LL;
          }

          uint64_t v39 = m + 154;
          m += 77;
        }

        while (v39 != (uint64_t (**)())v35);
        uint64_t v35 = v112;
      }
    }

void sub_1002D3C74( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,char a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  *(void *)(v67 + 176) = &a53;
  sub_1002D71B4(&a67);
  *(void *)(v67 + 176) = v67;
  sub_1002D71B4(&a67);
  *(void *)(v67 + 176) = &a64;
  sub_1002D6C94(&a67);
  _Unwind_Resume(a1);
}

void *sub_1002D3D94(void *result)
{
  *double result = off_1007AED90;
  return result;
}

void *sub_1002D3DA4(void *result)
{
  *double result = off_1007AED90;
  return result;
}

void sub_1002D3DB4(uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= v6)
  {
    uint64_t v9 = (uint64_t)(v7 - *a1) >> 6;
    uint64_t v10 = v5 - *a1;
    uint64_t v11 = v10 >> 5;
    else {
      unint64_t v12 = v11;
    }
    uint64_t v18 = v4;
    if (v12) {
      double v13 = (char *)sub_1002D7098(v4, v12);
    }
    else {
      double v13 = 0LL;
    }
    double v14 = v13;
    unint64_t v15 = &v13[64 * v9];
    BOOL v17 = &v13[64 * v12];
    sub_1002D5F00((uint64_t)v15, a2);
    uint64_t v16 = v15 + 64;
    sub_1002D7024(a1, &v14);
    uint64_t v8 = a1[1];
    sub_1002D7164((uint64_t)&v14);
  }

  else
  {
    sub_1002D5F00(*(void *)(v4 - 8), a2);
    uint64_t v8 = v7 + 64;
    a1[1] = v7 + 64;
  }

  a1[1] = v8;
}

void sub_1002D3EA4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  *(void *)(v10 + _Block_object_dispose((const void *)(v1 - 112), 8) = v11;
  _Unwind_Resume(exception_object);
}

void sub_1002D3EC4(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v92 = 0x100000004LL;
  double v90 = &off_1007BC550;
  __int128 v91 = xmmword_10042DB80;
  uint64_t v93 = &v94;
  double v7 = sub_1002D4A0C(a1, (uint64_t)v95, a3, (uint64_t)&v90);
  uint64_t v87 = 0x100000004LL;
  uint64_t v85 = &off_1007BC550;
  __int128 v86 = xmmword_10042DB80;
  double v88 = &v89;
  if (*(int *)(a1 + 576) < 1)
  {
    char v16 = 0;
    int v30 = 1;
  }

  else
  {
    int v8 = 1;
LABEL_3:
    int v30 = v8;
    sub_1002CBDC8((uint64_t)&v85, (uint64_t)&v90);
    int v9 = 0;
    while (v9 < *(_DWORD *)(a1 + 580))
    {
      uint64_t v98 = 0x100000004LL;
      __int128 v96 = &off_1007BC550;
      __int128 v97 = xmmword_10042DB80;
      __int128 v99 = v100;
      sub_1002CC25C((uint64_t)v95, (uint64_t)&v85, (uint64_t)&v96);
      double v10 = sub_1002D4A0C(a1, (uint64_t)&v96, a3, (uint64_t)&v90);
      if (v10 < v7)
      {
        uint64_t v98 = 0x100000004LL;
        __int128 v96 = &off_1007BC550;
        __int128 v97 = xmmword_10042DB80;
        __int128 v99 = v100;
        sub_1002CC25C((uint64_t)v95, (uint64_t)&v85, (uint64_t)&v96);
        sub_1002CBDC8((uint64_t)v95, (uint64_t)&v96);
        uint64_t v79 = 0x100000004LL;
        uint64_t v77 = &off_1007BC550;
        __int128 v78 = xmmword_10042DB80;
        uint64_t v80 = v81;
        uint64_t v98 = 0x10000018BLL;
        __int128 v96 = &off_1007BC938;
        __int128 v97 = xmmword_10042DEA0;
        __int128 v99 = v100;
        uint64_t v74 = 0x100000004LL;
        __int128 v72 = &off_1007BC550;
        __int128 v73 = xmmword_10042DB80;
        int v75 = v76;
        sub_1002CB6A8((uint64_t)&v85, (uint64_t)&v77, (uint64_t)&v96, (uint64_t)&v72, "2");
        BOOL v13 = v14 < *(double *)(a1 + 584) || (v7 - v10) / v7 < *(double *)(a1 + 592);
        int v8 = v30 + 1;
        double v7 = v10;
LABEL_15:
        if (v8 > *(_DWORD *)(a1 + 576) || v13)
        {
          int v30 = v8;
          char v16 = 0;
          goto LABEL_22;
        }

        goto LABEL_3;
      }

      unsigned int v11 = 0;
      ++v9;
      do
      {
        double v12 = *(double *)sub_1002CB32C((uint64_t)&v85, v11);
        *(double *)sub_1002CB32C((uint64_t)&v85, v11++) = v12 * 0.5;
      }

      while (v11 != 4);
      if (v10 < v7)
      {
        BOOL v13 = 0;
        int v8 = v30;
        goto LABEL_15;
      }
    }

    char v16 = 1;
  }

void sub_1002D4700(_Unwind_Exception *a1)
{
}

uint64_t sub_1002D47F0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 != a3)
  {
    sub_1002D7704((uint64_t)&v9, a3, *(void *)(a1 + 8), a2);
    for (i = *(void *)(a1 + 8); i != v5; *double v7 = off_1007AED90)
    {
      *(void *)(i - 12_Block_object_dispose((const void *)(v1 - 112), 8) = off_1007AED90;
      *(void *)(i - 240) = off_1007AED90;
      double v7 = (void *)(i - 608);
      *(void *)(i - 40_Block_object_dispose((const void *)(v1 - 112), 8) = off_1007AED90;
      *(void *)(i - 472) = off_1007AED90;
      *(void *)(i - 536) = off_1007AED90;
      i -= 616LL;
    }

    *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v5;
  }

  return a2;
}

double sub_1002D488C(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  uint64_t v4 = a3[1];
  if (*a3 == v4)
  {
    double v7 = 0.0;
    uint64_t v12 = *a3;
  }

  else
  {
    uint64_t v6 = a2 + 8;
    double v7 = 0.0;
    do
    {
      uint64_t v21 = 0x100000001LL;
      double v19 = &off_1007BCA50;
      *(void *)&__int128 v8 = 0x100000001LL;
      *((void *)&v8 + 1) = 0x100000001LL;
      __int128 v20 = v8;
      uint64_t v22 = &v23;
      uint64_t v16 = 0x400000001LL;
      double v14 = &off_1007BC818;
      __int128 v15 = xmmword_10042DED0;
      uint64_t v17 = &v18;
      sub_10031A130(v6, v3 + 40, v3 + 112, (uint64_t)&v19, (uint64_t)&v14);
      double v9 = *(double *)(v3 + 32);
      double v10 = *(double *)(v3 + 8);
      unsigned int v11 = (double *)sub_1002CB32C((uint64_t)&v19, 0);
      double v7 = v7 + 1.0 / (v9 * 0.1) * (v10 - *v11) * (1.0 / (v9 * 0.1) * (v10 - *v11));
      v3 += 176LL;
    }

    while (v3 != v4);
    uint64_t v3 = *a3;
    uint64_t v12 = a3[1];
  }

  return sqrt(v7 / (double)(unint64_t)(0x2E8BA2E8BA2E8BA3LL * ((v12 - v3) >> 4) - 3));
}

void *sub_1002D49FC(void *result)
{
  *double result = off_1007AED90;
  return result;
}

double sub_1002D4A0C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v7 = 0x2E8BA2E8BA2E8BA3LL * ((uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 4);
  uint64_t v38 = 0LL;
  unint64_t v37 = 0LL;
  uint64_t v39 = 0LL;
  sub_1002D4D7C((uint64_t *)&v37, v7);
  sub_1002D4EA0(v8, a2, (double **)a3, (uint64_t *)&v37);
  uint64_t v34 = 0x400000004LL;
  __int128 v32 = &off_1007BC860;
  __int128 v33 = xmmword_10042DEB0;
  uint64_t v35 = &v36;
  sub_1002CAEDC(&v32, 4, 4);
  sub_1002CAF28((uint64_t)&v32, 0.0);
  uint64_t v29 = 0x100000004LL;
  int v27 = &off_1007BC550;
  __int128 v28 = xmmword_10042DB80;
  int v30 = &v31;
  sub_1002CAEDC(&v27, 4, 1);
  double v9 = 0.0;
  sub_1002CAF28((uint64_t)&v27, 0.0);
  double v10 = v37;
  for (i = v38; v10 != i; double v10 = (double *)(v13 + 72))
  {
    uint64_t v12 = (uint64_t)(v10 + 10);
    double v14 = *v10;
    uint64_t v13 = (uint64_t)(v10 + 1);
    uint64_t v24 = 0x400000004LL;
    uint64_t v22 = &off_1007BC860;
    __int128 v23 = xmmword_10042DEB0;
    BOOL v25 = v26;
    sub_1002CB548(v12, v13, (uint64_t)&v22);
    uint64_t v42 = 0x400000004LL;
    unint64_t v40 = &off_1007BC860;
    __int128 v41 = xmmword_10042DEB0;
    __int128 v43 = v44;
    sub_1002CC25C((uint64_t)&v32, (uint64_t)&v22, (uint64_t)&v40);
    sub_1002CBDC8((uint64_t)&v32, (uint64_t)&v40);
    uint64_t v24 = 0x100000004LL;
    uint64_t v22 = &off_1007BC550;
    __int128 v23 = xmmword_10042DB80;
    v13 += 72LL;
    BOOL v25 = v26;
    sub_1002DA040(v13, (uint64_t)&v22, v14);
    uint64_t v42 = 0x100000004LL;
    unint64_t v40 = &off_1007BC550;
    __int128 v41 = xmmword_10042DB80;
    __int128 v43 = v44;
    sub_1002CC25C((uint64_t)&v27, (uint64_t)&v22, (uint64_t)&v40);
    sub_1002CBDC8((uint64_t)&v27, (uint64_t)&v40);
    double v9 = v9 + v14 * v14;
  }

  __int128 v15 = (double *)sub_1002CB40C((uint64_t)&v32, 3, 3);
  double *v15 = *v15 + 0.101321184;
  uint64_t v24 = 0x400000004LL;
  uint64_t v22 = &off_1007BC860;
  __int128 v23 = xmmword_10042DEB0;
  BOOL v25 = v26;
  uint64_t v47 = 0x100000004LL;
  double v45 = &off_1007BC980;
  __int128 v46 = xmmword_10042DB80;
  __int128 v48 = &v49;
  uint64_t v42 = 0x100000010LL;
  unint64_t v40 = &off_1007BCA08;
  __int128 v41 = xmmword_10042DEC0;
  __int128 v43 = v44;
  sub_1002D9BF0((uint64_t)&v32, (uint64_t)&v45, (uint64_t)&v40, (uint64_t)&v22);
  uint64_t v19 = 0x100000004LL;
  uint64_t v17 = &off_1007BC550;
  __int128 v18 = xmmword_10042DB80;
  __int128 v20 = &v21;
  sub_1002CB548((uint64_t)&v22, (uint64_t)&v27, (uint64_t)&v17);
  sub_1002CBDC8(a4, (uint64_t)&v17);
  unint64_t v40 = (uint64_t (**)())&v37;
  sub_1002D98CC((void ***)&v40);
  return v9;
}

void sub_1002D4D30(_Unwind_Exception *a1)
{
  STACK[0x220] = (unint64_t)&STACK[0x208];
  sub_1002D98CC((void ***)&STACK[0x220]);
  _Unwind_Resume(a1);
}

void sub_1002D4D7C(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (0x86BCA1AF286BCA1BLL * ((v4 - *a1) >> 3) < a2)
  {
    if (a2 >= 0x1AF286BCA1AF287LL) {
      sub_10001E11C();
    }
    uint64_t v5 = a1[1] - *a1;
    uint64_t v13 = v3;
    std::stringbuf::string_type __p = sub_1001307C0(v3, a2);
    double v10 = (char *)__p + v5;
    unsigned int v11 = (char *)__p + v5;
    uint64_t v12 = (char *)__p + 152 * v6;
    sub_1002D9910(a1, &__p);
    unint64_t v7 = v10;
    uint64_t v8 = v11;
    if (v11 != v10)
    {
      do
      {
        *((void *)v8 - 9) = off_1007AED90;
        *((void *)v8 - 1_Block_object_dispose((const void *)(v1 - 112), 8) = off_1007AED90;
        v8 -= 152;
      }

      while (v8 != v7);
      unsigned int v11 = v7;
    }

    if (__p) {
      operator delete(__p);
    }
  }

void sub_1002D4EA0(uint64_t a1, uint64_t a2, double **a3, uint64_t *a4)
{
  uint64_t v6 = *a4;
  uint64_t v7 = a4[1];
  if (*a4 != v7)
  {
    do
    {
      *(void *)(v7 - 72) = off_1007AED90;
      *(void *)(v7 - 144) = off_1007AED90;
      v7 -= 152LL;
    }

    while (v7 != v6);
    a4[1] = v6;
    sub_1002D4D7C(a4, 0x2E8BA2E8BA2E8BA3LL * (((char *)a3[1] - (char *)*a3) >> 4));
  }

  uint64_t v8 = *a3;
  double v9 = a3[1];
  if (*a3 != v9)
  {
    do
    {
      uint64_t v39 = 0x100000001LL;
      unint64_t v37 = &off_1007BCA50;
      *(void *)&__int128 v10 = 0x100000001LL;
      *((void *)&v10 + 1) = 0x100000001LL;
      __int128 v38 = v10;
      unint64_t v40 = &v41;
      uint64_t v34 = 0x400000001LL;
      __int128 v32 = &off_1007BC818;
      __int128 v33 = xmmword_10042DED0;
      uint64_t v35 = &v36;
      sub_10031A130(a2, (uint64_t)(v8 + 5), (uint64_t)(v8 + 14), (uint64_t)&v37, (uint64_t)&v32);
      double v12 = v8[3];
      double v11 = v8[4];
      double v13 = v8[2];
      double v14 = (double *)sub_1002CB32C((uint64_t)&v37, 0);
      double v15 = 1.0 / (v12 * v11);
      double v31 = v13 - v15 * *v14;
      uint64_t v28 = 0x400000001LL;
      __double2 v26 = &off_1007BC818;
      __int128 v27 = xmmword_10042DED0;
      uint64_t v29 = &v30;
      sub_1002DA040((uint64_t)&v32, (uint64_t)&v26, v15);
      unsigned int v16 = 0;
      uint64_t v23 = 0x100000004LL;
      uint64_t v21 = &off_1007BC550;
      __int128 v22 = xmmword_10042DB80;
      uint64_t v24 = &v25;
      do
      {
        double v17 = sub_1002405E4((uint64_t)&v26, v16);
        *(double *)sub_1002CB32C((uint64_t)&v21, v16++) = v17;
      }

      while (v16 != 4);
      unint64_t v18 = a4[1];
      if (v18 >= a4[2])
      {
        uint64_t v19 = sub_1002DA0FC(a4, &v31, (uint64_t)&v26, (uint64_t)&v21);
      }

      else
      {
        sub_1002DA298((double *)a4[1], (uint64_t)&v26, (uint64_t)&v21, v31);
        uint64_t v19 = v18 + 152;
        a4[1] = v18 + 152;
      }

      a4[1] = v19;
      v8 += 22;
    }

    while (v8 != v9);
  }

void sub_1002D50F8(_Unwind_Exception *a1)
{
  *(void *)(v1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v2;
  _Unwind_Resume(a1);
}

void *sub_1002D5100(void *result)
{
  *double result = off_1007AED90;
  return result;
}

void *sub_1002D5110(void *result)
{
  *double result = off_1007AED90;
  return result;
}

void sub_1002D5120(double a1, double a2, uint64_t a3, uint64_t *a4, BOOL *a5, char *a6, double *a7)
{
  *a5 = 1;
  *a6 = 0;
  *a7 = 0.0;
  uint64_t v7 = a4[1];
  if (*a4 != v7)
  {
    unint64_t v14 = 0x2E8BA2E8BA2E8BA3LL * ((v7 - *a4) >> 4);
    uint64_t v81 = 0LL;
    unint64_t v82 = 0LL;
    unint64_t v83 = 0LL;
    sub_1002D58F0(&v81, v14);
    uint64_t v78 = 0x100000002LL;
    double v76 = &off_1007BCA98;
    __int128 v77 = xmmword_10042DEE0;
    uint64_t v79 = &v80;
    uint64_t v15 = *a4;
    uint64_t v16 = a4[1];
    while (v15 != v16)
    {
      if (*(double *)(v15 + 8) <= a2)
      {
        double v17 = sub_1002405E4(v15 + 40, 2u);
        *(double *)sub_1002CB32C((uint64_t)&v76, 0) = v17;
        double v18 = sub_1002405E4(v15 + 40, 0);
        *(double *)sub_1002CB32C((uint64_t)&v76, 1u) = v18;
        unint64_t v19 = v82;
        if (v82 >= v83)
        {
          uint64_t v20 = sub_1002DA678(&v81, (uint64_t)&v76);
        }

        else
        {
          sub_1002DA48C(v82, (uint64_t)&v76);
          uint64_t v20 = v19 + 56;
        }

        unint64_t v82 = v20;
      }

      v15 += 176LL;
    }

    if (v81 != v82)
    {
      __int128 v53 = a7;
      uint64_t v73 = 0x100000002LL;
      uint64_t v71 = &off_1007BCA98;
      __int128 v72 = xmmword_10042DEE0;
      uint64_t v74 = &v75;
      sub_1002CAEDC(&v71, 2, 1);
      sub_1002CAF28((uint64_t)&v71, 0.0);
      uint64_t v22 = v81;
      for (unint64_t i = v82; v22 != i; v22 += 56LL)
      {
        uint64_t v86 = 0x100000002LL;
        uint64_t v84 = &off_1007BCA98;
        __int128 v85 = xmmword_10042DEE0;
        uint64_t v87 = v88;
        sub_1002CC25C((uint64_t)&v71, v22, (uint64_t)&v84);
        sub_1002CBDC8((uint64_t)&v71, (uint64_t)&v84);
      }

      uint64_t v86 = 0x100000002LL;
      uint64_t v84 = &off_1007BCA98;
      __int128 v85 = xmmword_10042DEE0;
      uint64_t v87 = v88;
      sub_1002DA040((uint64_t)&v71, (uint64_t)&v84, 1.0 / (double)v14);
      sub_1002CBDC8((uint64_t)&v71, (uint64_t)&v84);
      uint64_t v24 = v81;
      unint64_t v23 = v82;
      if (v81 != v82)
      {
        double v25 = 0.0;
        do
        {
          uint64_t v86 = 0x100000002LL;
          uint64_t v84 = &off_1007BCA98;
          __int128 v85 = xmmword_10042DEE0;
          uint64_t v87 = v88;
          sub_1002CB44C(v24, (uint64_t)&v71, (uint64_t)&v84);
          sub_1002CBDC8(v24, (uint64_t)&v84);
          uint64_t v68 = 0x100000002LL;
          uint64_t v66 = &off_1007BCA98;
          __int128 v67 = xmmword_10042DEE0;
          uint64_t v69 = v70;
          uint64_t v86 = 0x1000000E1LL;
          uint64_t v84 = &off_1007BCAE0;
          __int128 v85 = xmmword_10042DEF0;
          uint64_t v87 = v88;
          uint64_t v63 = 0x100000002LL;
          uint64_t v61 = &off_1007BCA98;
          __int128 v62 = xmmword_10042DEE0;
          uint64_t v64 = v65;
          sub_1002CB6A8(v24, (uint64_t)&v66, (uint64_t)&v84, (uint64_t)&v61, "2");
          if (v26 > v25) {
            double v25 = v26;
          }
          v24 += 56LL;
        }

        while (v24 != v23);
        *a5 = v25 < 0.3;
        if (v25 < 0.3) {
          goto LABEL_54;
        }
        uint64_t v86 = 0x200000002LL;
        uint64_t v84 = &off_1007BCB28;
        __int128 v85 = xmmword_10042DF00;
        uint64_t v87 = v88;
        sub_1002CAEDC(&v84, 2, 2);
        sub_1002CAF28((uint64_t)&v84, 0.0);
        uint64_t v27 = v81;
        unint64_t v28 = v82;
        if (v81 != v82)
        {
          while (1)
          {
            unsigned int v30 = *(_DWORD *)(v27 + 8);
            unsigned int v29 = *(_DWORD *)(v27 + 12);
            uint64_t v58 = 0x200000001LL;
            uint64_t v59 = 0LL;
            unint64_t v56 = 0LL;
            uint64_t v57 = 0LL;
            unint64_t v55 = &off_1007BCB70;
            if (v29 > 1) {
              break;
            }
            if (v30 >= 3)
            {
              int v49 = 423;
              unint64_t v50 = "this->max_num_cols_ >= num_cols";
LABEL_58:
              __assert_rtn("SetMatrixSize", "cnmatrixbase.h", v49, v50);
            }

            unint64_t v56 = __PAIR64__(v30, v29);
            LODWORD(v57) = v30 * v29;
            HIDWORD(v57) = v29;
            uint64_t v59 = v60;
            sub_1002CB364(v27, &v55);
            uint64_t v63 = 0x200000002LL;
            uint64_t v61 = &off_1007BCB28;
            __int128 v62 = xmmword_10042DF00;
            uint64_t v64 = v65;
            sub_1002CB548(v27, (uint64_t)&v55, (uint64_t)&v61);
            uint64_t v68 = 0x200000002LL;
            uint64_t v66 = &off_1007BCB28;
            __int128 v67 = xmmword_10042DF00;
            uint64_t v69 = v70;
            sub_1002CC25C((uint64_t)&v84, (uint64_t)&v61, (uint64_t)&v66);
            sub_1002CBDC8((uint64_t)&v84, (uint64_t)&v66);
            v27 += 56LL;
            if (v27 == v28) {
              goto LABEL_23;
            }
          }

          int v49 = 422;
          unint64_t v50 = "this->max_num_rows_ >= num_rows";
          goto LABEL_58;
        }

void sub_1002D586C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void **a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,char a56)
{
  a15 = (void **)&a56;
  sub_1002DA2F4(&a15);
  _Unwind_Resume(a1);
}

uint64_t sub_1002D58F0(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (0x6DB6DB6DB6DB6DB7LL * ((v4 - *a1) >> 3) < a2)
  {
    if (a2 >= 0x492492492492493LL) {
      sub_10001E11C();
    }
    uint64_t v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = sub_10001FD64(result, a2);
    v7[1] = v7[0] + v5;
    _DWORD v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 56 * v6;
    sub_1002DA380(a1, v7);
    return sub_1002DA628((uint64_t)v7);
  }

  return result;
}

void sub_1002D5998(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *sub_1002D59AC(void *result)
{
  *uint64_t result = off_1007AED90;
  return result;
}

void *sub_1002D59BC(void *result)
{
  *uint64_t result = off_1007AED90;
  return result;
}

void *sub_1002D59CC(void *result)
{
  *uint64_t result = off_1007AED90;
  return result;
}

void sub_1002D59DC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v34 = 0x200000002LL;
  __int128 v32 = &off_1007BCB28;
  __int128 v33 = xmmword_10042DF00;
  unint64_t v35 = &v36;
  uint64_t v29 = 0x200000002LL;
  uint64_t v27 = &off_1007BCB28;
  __int128 v28 = xmmword_10042DF00;
  unsigned int v30 = &v31;
  uint64_t v24 = 0x200000002LL;
  uint64_t v22 = &off_1007BCB28;
  __int128 v23 = xmmword_10042DF00;
  double v25 = &v26;
  uint64_t v19 = 0x100000002LL;
  double v17 = &off_1007BCA98;
  __int128 v18 = xmmword_10042DEE0;
  uint64_t v20 = &v21;
  uint64_t v14 = 0x200000002LL;
  double v12 = &off_1007BCB28;
  __int128 v13 = xmmword_10042DF00;
  uint64_t v15 = &v16;
  uint64_t v9 = 0x1000000A8LL;
  uint64_t v7 = &off_1007BCBB8;
  __int128 v8 = xmmword_10042DF10;
  __int128 v10 = &v11;
  sub_1002DA868(a1, (uint64_t)&v32, a3, (uint64_t)&v27, a2, (uint64_t)&v22, (uint64_t)&v17, (uint64_t)&v12, (uint64_t)&v7);
  if (DWORD2(v28))
  {
    unsigned int v3 = 0;
    while (*(double *)sub_1002CB32C((uint64_t)&v27, v3) == 0.0)
    {
      if (++v3 >= DWORD2(v28)) {
        goto LABEL_6;
      }
    }

    __int16 v6 = 4;
    char v5 = 2;
    cnprint::CNPrinter::Print(&v6, &v5);
  }

void sub_1002D5BB8(void **a1, unint64_t a2)
{
  unsigned int v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 3)
  {
    if (a2 >> 61) {
      sub_10001E11C();
    }
    int64_t v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    __int16 v6 = (char *)sub_1000472C0(v3, a2);
    uint64_t v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8LL];
    uint64_t v9 = &v6[8 * v8];
    __int128 v10 = (char *)*a1;
    uint64_t v11 = (char *)a1[1];
    double v12 = v7;
    if (v11 != *a1)
    {
      double v12 = v7;
      do
      {
        uint64_t v13 = *((void *)v11 - 1);
        v11 -= 8;
        *((void *)v12 - 1) = v13;
        v12 -= 8;
      }

      while (v11 != v10);
    }

    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10) {
      operator delete(v10);
    }
  }

uint64_t sub_1002D5C4C( uint64_t a1, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, double a8)
{
  *(double *)a1 = a5;
  *(double *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = a6;
  *(double *)(a1 + 16) = a6 / (a7 * a8);
  *(double *)(a1 + 24) = a7;
  *(double *)(a1 + 32) = a8;
  sub_1002D5F00(a1 + 40, a2);
  *(_DWORD *)(a1 + 104) = a4;
  sub_1002D5F00(a1 + 112, a3);
  return a1;
}

void sub_1002D5CAC(_Unwind_Exception *a1)
{
  void *v1 = off_1007AED90;
  _Unwind_Resume(a1);
}

void *sub_1002D5CBC(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    __int16 v6 = result;
    uint64_t result = sub_1002D5D34(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }

  return result;
}

void sub_1002D5D18(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

char *sub_1002D5D34(void *a1, unint64_t a2)
{
  if (a2 >= 0x155555555555556LL) {
    sub_10001E11C();
  }
  uint64_t result = (char *)sub_1002D5D84((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[192 * v4];
  return result;
}

void *sub_1002D5D84(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x155555555555556LL) {
    sub_10001D350();
  }
  return operator new(192 * a2);
}

char *sub_1002D5DC8(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  uint64_t v9 = *(char **)result;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - *(void *)result) >> 6) < a4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0LL;
      *uint64_t v7 = 0LL;
      v7[1] = 0LL;
      _DWORD v7[2] = 0LL;
    }

    if (a4 > 0x155555555555555LL) {
      sub_10001E11C();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 6);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= a4) {
      uint64_t v11 = a4;
    }
    if (v10 >= 0xAAAAAAAAAAAAAALL) {
      unint64_t v12 = 0x155555555555555LL;
    }
    else {
      unint64_t v12 = v11;
    }
    uint64_t result = sub_1002D5D34(v7, v12);
    uint64_t v14 = (char *)v7[1];
    uint64_t v13 = (void **)(v7 + 1);
    uint64_t v9 = v14;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      __int128 v18 = v9;
      uint64_t v19 = __src;
      goto LABEL_18;
    }

    goto LABEL_19;
  }

  uint64_t v13 = (void **)(result + 8);
  uint64_t v15 = (_BYTE *)*((void *)result + 1);
  if (0xAAAAAAAAAAAAAAABLL * ((v15 - v9) >> 6) >= a4) {
    goto LABEL_16;
  }
  uint64_t v16 = &__src[64 * ((v15 - v9) >> 6)];
  if (v15 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, v15 - v9);
    uint64_t v9 = (char *)*v13;
  }

  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    __int128 v18 = v9;
    uint64_t v19 = v16;
LABEL_18:
    uint64_t result = (char *)memmove(v18, v19, v17);
  }

__n128 sub_1002D5F00(uint64_t a1, uint64_t a2)
{
  result.n128_u64[0] = 0x100000003LL;
  *(void *)(a1 + 24) = 0x100000003LL;
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = &off_1007BC4C0;
  if (a1 == a2)
  {
    uint64_t v16 = "this != &(A)";
    int v17 = 603;
LABEL_21:
    __int128 v18 = "cnmatrix.h";
    uint64_t v19 = "CNMatrix";
LABEL_22:
    __assert_rtn(v19, v18, v17, v16);
  }

  unsigned int v3 = *(_DWORD *)(a2 + 8);
  if (v3 > 3)
  {
    uint64_t v16 = "this->max_num_rows_ >= num_rows";
    int v17 = 422;
LABEL_18:
    __int128 v18 = "cnmatrixbase.h";
    uint64_t v19 = "SetMatrixSize";
    goto LABEL_22;
  }

  unsigned int v4 = *(_DWORD *)(a2 + 12);
  if (v4 >= 2)
  {
    uint64_t v16 = "this->max_num_cols_ >= num_cols";
    int v17 = 423;
    goto LABEL_18;
  }

  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v3;
  *(_DWORD *)(a1 + 12) = v4;
  uint64_t v5 = v4 * v3;
  *(_DWORD *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 20) = v3;
  __int16 v6 = (_OWORD *)(a1 + 40);
  *(void *)(a1 + 32) = a1 + 40;
  if (*(_DWORD *)(a2 + 8) > 3u)
  {
    uint64_t v16 = "this->max_num_rows_ >= A.num_rows_";
    int v17 = 616;
    goto LABEL_21;
  }

  if (*(_DWORD *)(a2 + 12) > 1u)
  {
    uint64_t v16 = "this->max_num_cols_ >= A.num_cols_";
    int v17 = 617;
    goto LABEL_21;
  }

  int v7 = *(_DWORD *)(a2 + 16);
  if (v7 > 3)
  {
    uint64_t v10 = (v7 - 2);
    uint64_t v11 = *(__int128 **)(a2 + 32);
    unint64_t v12 = (__n128 *)((char *)v6 + 8 * v10);
    uint64_t v13 = (v7 - 1) >> 1;
    uint64_t v14 = v11;
    do
    {
      __int128 v15 = *v14++;
      *v6++ = v15;
      --v13;
    }

    while (v13);
    __n128 result = *(__n128 *)((char *)v11 + 8 * v10);
    __n128 *v12 = result;
  }

  else if ((_DWORD)v5)
  {
    uint64_t v8 = *(unint64_t **)(a2 + 32);
    do
    {
      unint64_t v9 = *v8++;
      result.n128_u64[0] = v9;
      *(void *)__int16 v6 = v9;
      __int16 v6 = (_OWORD *)((char *)v6 + 8);
      --v5;
    }

    while (v5);
  }

  return result;
}

void sub_1002D605C(_Unwind_Exception *a1)
{
  void *v1 = off_1007AED90;
  _Unwind_Resume(a1);
}

__n128 sub_1002D606C(uint64_t a1, uint64_t a2)
{
  result.n128_u64[0] = 0x300000003LL;
  *(void *)(a1 + 24) = 0x300000003LL;
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = &off_1007BC508;
  if (a1 == a2)
  {
    uint64_t v16 = "this != &(A)";
    int v17 = 603;
LABEL_21:
    __int128 v18 = "cnmatrix.h";
    uint64_t v19 = "CNMatrix";
LABEL_22:
    __assert_rtn(v19, v18, v17, v16);
  }

  unsigned int v3 = *(_DWORD *)(a2 + 8);
  if (v3 > 3)
  {
    uint64_t v16 = "this->max_num_rows_ >= num_rows";
    int v17 = 422;
LABEL_18:
    __int128 v18 = "cnmatrixbase.h";
    uint64_t v19 = "SetMatrixSize";
    goto LABEL_22;
  }

  unsigned int v4 = *(_DWORD *)(a2 + 12);
  if (v4 >= 4)
  {
    uint64_t v16 = "this->max_num_cols_ >= num_cols";
    int v17 = 423;
    goto LABEL_18;
  }

  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v3;
  *(_DWORD *)(a1 + 12) = v4;
  uint64_t v5 = v4 * v3;
  *(_DWORD *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 20) = v3;
  __int16 v6 = (_OWORD *)(a1 + 40);
  *(void *)(a1 + 32) = a1 + 40;
  if (*(_DWORD *)(a2 + 8) > 3u)
  {
    uint64_t v16 = "this->max_num_rows_ >= A.num_rows_";
    int v17 = 616;
    goto LABEL_21;
  }

  if (*(_DWORD *)(a2 + 12) > 3u)
  {
    uint64_t v16 = "this->max_num_cols_ >= A.num_cols_";
    int v17 = 617;
    goto LABEL_21;
  }

  int v7 = *(_DWORD *)(a2 + 16);
  if (v7 > 3)
  {
    uint64_t v10 = (v7 - 2);
    uint64_t v11 = *(__int128 **)(a2 + 32);
    unint64_t v12 = (__n128 *)((char *)v6 + 8 * v10);
    uint64_t v13 = (v7 - 1) >> 1;
    uint64_t v14 = v11;
    do
    {
      __int128 v15 = *v14++;
      *v6++ = v15;
      --v13;
    }

    while (v13);
    __n128 result = *(__n128 *)((char *)v11 + 8 * v10);
    __n128 *v12 = result;
  }

  else if ((_DWORD)v5)
  {
    uint64_t v8 = *(unint64_t **)(a2 + 32);
    do
    {
      unint64_t v9 = *v8++;
      result.n128_u64[0] = v9;
      *(void *)__int16 v6 = v9;
      __int16 v6 = (_OWORD *)((char *)v6 + 8);
      --v5;
    }

    while (v5);
  }

  return result;
}

void sub_1002D61C4(_Unwind_Exception *a1)
{
  void *v1 = off_1007AED90;
  _Unwind_Resume(a1);
}

__n128 sub_1002D61D4(uint64_t a1, uint64_t a2)
{
  result.n128_u64[0] = 0x100000004LL;
  *(void *)(a1 + 24) = 0x100000004LL;
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = &off_1007BC550;
  if (a1 == a2)
  {
    uint64_t v16 = "this != &(A)";
    int v17 = 603;
LABEL_21:
    __int128 v18 = "cnmatrix.h";
    uint64_t v19 = "CNMatrix";
LABEL_22:
    __assert_rtn(v19, v18, v17, v16);
  }

  unsigned int v3 = *(_DWORD *)(a2 + 8);
  if (v3 > 4)
  {
    uint64_t v16 = "this->max_num_rows_ >= num_rows";
    int v17 = 422;
LABEL_18:
    __int128 v18 = "cnmatrixbase.h";
    uint64_t v19 = "SetMatrixSize";
    goto LABEL_22;
  }

  unsigned int v4 = *(_DWORD *)(a2 + 12);
  if (v4 >= 2)
  {
    uint64_t v16 = "this->max_num_cols_ >= num_cols";
    int v17 = 423;
    goto LABEL_18;
  }

  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v3;
  *(_DWORD *)(a1 + 12) = v4;
  uint64_t v5 = v4 * v3;
  *(_DWORD *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 20) = v3;
  __int16 v6 = (_OWORD *)(a1 + 40);
  *(void *)(a1 + 32) = a1 + 40;
  if (*(_DWORD *)(a2 + 8) > 4u)
  {
    uint64_t v16 = "this->max_num_rows_ >= A.num_rows_";
    int v17 = 616;
    goto LABEL_21;
  }

  if (*(_DWORD *)(a2 + 12) > 1u)
  {
    uint64_t v16 = "this->max_num_cols_ >= A.num_cols_";
    int v17 = 617;
    goto LABEL_21;
  }

  int v7 = *(_DWORD *)(a2 + 16);
  if (v7 > 3)
  {
    uint64_t v10 = (v7 - 2);
    uint64_t v11 = *(__int128 **)(a2 + 32);
    unint64_t v12 = (__n128 *)((char *)v6 + 8 * v10);
    uint64_t v13 = (v7 - 1) >> 1;
    uint64_t v14 = v11;
    do
    {
      __int128 v15 = *v14++;
      *v6++ = v15;
      --v13;
    }

    while (v13);
    __n128 result = *(__n128 *)((char *)v11 + 8 * v10);
    __n128 *v12 = result;
  }

  else if ((_DWORD)v5)
  {
    uint64_t v8 = *(unint64_t **)(a2 + 32);
    do
    {
      unint64_t v9 = *v8++;
      result.n128_u64[0] = v9;
      *(void *)__int16 v6 = v9;
      __int16 v6 = (_OWORD *)((char *)v6 + 8);
      --v5;
    }

    while (v5);
  }

  return result;
}

void sub_1002D6330(_Unwind_Exception *a1)
{
  void *v1 = off_1007AED90;
  _Unwind_Resume(a1);
}

uint64_t sub_1002D6344(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_1002D6350(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t sub_1002D6374(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_1002D6380(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

__n128 sub_1002D63CC(uint64_t a1, uint64_t a2)
{
  result.n128_u64[0] = 0x400000004LL;
  *(void *)(a1 + 24) = 0x400000004LL;
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = &off_1007BC860;
  if (a1 == a2)
  {
    uint64_t v16 = "this != &(A)";
    int v17 = 603;
LABEL_21:
    __int128 v18 = "cnmatrix.h";
    uint64_t v19 = "CNMatrix";
LABEL_22:
    __assert_rtn(v19, v18, v17, v16);
  }

  unsigned int v3 = *(_DWORD *)(a2 + 8);
  if (v3 > 4)
  {
    uint64_t v16 = "this->max_num_rows_ >= num_rows";
    int v17 = 422;
LABEL_18:
    __int128 v18 = "cnmatrixbase.h";
    uint64_t v19 = "SetMatrixSize";
    goto LABEL_22;
  }

  unsigned int v4 = *(_DWORD *)(a2 + 12);
  if (v4 >= 5)
  {
    uint64_t v16 = "this->max_num_cols_ >= num_cols";
    int v17 = 423;
    goto LABEL_18;
  }

  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v3;
  *(_DWORD *)(a1 + 12) = v4;
  uint64_t v5 = v4 * v3;
  *(_DWORD *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 20) = v3;
  __int16 v6 = (_OWORD *)(a1 + 40);
  *(void *)(a1 + 32) = a1 + 40;
  if (*(_DWORD *)(a2 + 8) > 4u)
  {
    uint64_t v16 = "this->max_num_rows_ >= A.num_rows_";
    int v17 = 616;
    goto LABEL_21;
  }

  if (*(_DWORD *)(a2 + 12) > 4u)
  {
    uint64_t v16 = "this->max_num_cols_ >= A.num_cols_";
    int v17 = 617;
    goto LABEL_21;
  }

  int v7 = *(_DWORD *)(a2 + 16);
  if (v7 > 3)
  {
    uint64_t v10 = (v7 - 2);
    uint64_t v11 = *(__int128 **)(a2 + 32);
    unint64_t v12 = (__n128 *)((char *)v6 + 8 * v10);
    uint64_t v13 = (v7 - 1) >> 1;
    uint64_t v14 = v11;
    do
    {
      __int128 v15 = *v14++;
      *v6++ = v15;
      --v13;
    }

    while (v13);
    __n128 result = *(__n128 *)((char *)v11 + 8 * v10);
    __n128 *v12 = result;
  }

  else if ((_DWORD)v5)
  {
    uint64_t v8 = *(unint64_t **)(a2 + 32);
    do
    {
      unint64_t v9 = *v8++;
      result.n128_u64[0] = v9;
      *(void *)__int16 v6 = v9;
      __int16 v6 = (_OWORD *)((char *)v6 + 8);
      --v5;
    }

    while (v5);
  }

  return result;
}

void sub_1002D6524(_Unwind_Exception *a1)
{
  void *v1 = off_1007AED90;
  _Unwind_Resume(a1);
}

void *sub_1002D6534(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    __int16 v6 = result;
    __n128 result = sub_1001205C0(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }

  return result;
}

void sub_1002D6590(_Unwind_Exception *exception_object)
{
  unsigned int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_1002D65AC(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    unsigned int v3 = v1[1];
    if (v3 != v2)
    {
      do
      {
        *(v3 - _Block_object_dispose((const void *)(v1 - 112), 8) = off_1007AED90;
        *(v3 - 16) = off_1007AED90;
        *(v3 - 32) = off_1007AED90;
        unsigned int v4 = v3 - 61;
        uint64_t v5 = v3 - 70;
        *(v3 - 53) = off_1007AED90;
        *uint64_t v5 = off_1007AED90;
        v3 -= 70;
        *unsigned int v4 = off_1007AED90;
      }

      while (v5 != v2);
    }

    v1[1] = v2;
    operator delete(v2);
  }

void sub_1002D6608(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    for (unint64_t i = (char *)v1[1]; i != v2; i -= 176)
    {
      *((void *)i - _Block_object_dispose((const void *)(v1 - 112), 8) = off_1007AED90;
      *((void *)i - 17) = off_1007AED90;
    }

    v1[1] = v2;
    operator delete(v2);
  }

uint64_t sub_1002D664C(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1002D6708((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_1002D66C0(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x1745D1745D1745ELL) {
    sub_10001D350();
  }
  return operator new(176 * a2);
}

uint64_t sub_1002D6708(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = 0LL;
  uint64_t v12 = a7 - 176;
  while (a3 + v11 != a5)
  {
    uint64_t v13 = v12 + v11;
    v11 -= 176LL;
    sub_1002D67AC(a1, v13, (__int128 *)(v11 + a3));
  }

  return a6;
}

double sub_1002D67AC(uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v5 = *a3;
  __int128 v6 = a3[1];
  *(void *)(a2 + 32) = *((void *)a3 + 4);
  *(_OWORD *)a2 = v5;
  *(_OWORD *)(a2 + 16) = v6;
  sub_1002D5F00(a2 + 40, (uint64_t)a3 + 40);
  *(_DWORD *)(a2 + 104) = *((_DWORD *)a3 + 26);
  *(void *)&double result = sub_1002D5F00(a2 + 112, (uint64_t)(a3 + 7)).n128_u64[0];
  return result;
}

void sub_1002D6808(_Unwind_Exception *a1)
{
  void *v1 = off_1007AED90;
  _Unwind_Resume(a1);
}

char *sub_1002D6818(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  unint64_t v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0LL;
      *uint64_t v7 = 0LL;
      v7[1] = 0LL;
      _DWORD v7[2] = 0LL;
    }

    if (a4 >> 60) {
      sub_10001E11C();
    }
    uint64_t v10 = v8 >> 3;
    if (v8 >> 3 <= a4) {
      uint64_t v10 = a4;
    }
    else {
      unint64_t v11 = v10;
    }
    double result = sub_1001205C0(v7, v11);
    uint64_t v13 = (char *)v7[1];
    uint64_t v12 = (void **)(v7 + 1);
    unint64_t v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      __int128 v18 = v9;
      uint64_t v19 = __src;
      goto LABEL_18;
    }

    goto LABEL_19;
  }

  uint64_t v12 = (void **)(result + 8);
  uint64_t v14 = (_BYTE *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 4;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  uint64_t v16 = &__src[16 * v15];
  if (v14 != v9)
  {
    double result = (char *)memmove(*(void **)result, __src, v14 - v9);
    unint64_t v9 = (char *)*v12;
  }

  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    __int128 v18 = v9;
    uint64_t v19 = v16;
LABEL_18:
    double result = (char *)memmove(v18, v19, v17);
  }

__int128 *sub_1002D6920(uint64_t a1, __int128 *a2, __int128 *a3, uint64_t a4)
{
  __int128 v5 = a2;
  if (a2 == a3) {
    return a2;
  }
  __int128 v6 = a3;
  do
  {
    __int128 v7 = *v5;
    __int128 v8 = v5[1];
    *(void *)(a4 + 32) = *((void *)v5 + 4);
    *(_OWORD *)a4 = v7;
    *(_OWORD *)(a4 + 16) = v8;
    sub_1002CBDC8(a4 + 40, (uint64_t)v5 + 40);
    *(_DWORD *)(a4 + 104) = *((_DWORD *)v5 + 26);
    sub_1002CBDC8(a4 + 112, (uint64_t)(v5 + 7));
    a4 += 176LL;
    v5 += 11;
  }

  while (v5 != v6);
  return v6;
}

uint64_t sub_1002D69A4(uint64_t *a1, __int128 *a2)
{
  uint64_t v3 = 0x2E8BA2E8BA2E8BA3LL * ((a1[1] - *a1) >> 4);
  unint64_t v4 = v3 + 1;
  if (0x5D1745D1745D1746LL * ((a1[2] - *a1) >> 4) > v4) {
    unint64_t v4 = 0x5D1745D1745D1746LL * ((a1[2] - *a1) >> 4);
  }
  else {
    unint64_t v6 = v4;
  }
  uint64_t v16 = a1 + 2;
  if (v6) {
    __int128 v7 = (char *)sub_1002D66C0((uint64_t)(a1 + 2), v6);
  }
  else {
    __int128 v7 = 0LL;
  }
  std::stringbuf::string_type __p = v7;
  uint64_t v13 = &v7[176 * v3];
  unint64_t v15 = &v7[176 * v6];
  sub_1002D6B30((uint64_t)(a1 + 2), (uint64_t)v13, a2);
  uint64_t v14 = (uint64_t)(v13 + 176);
  sub_1002D664C(a1, &__p);
  uint64_t v8 = a1[1];
  uint64_t v9 = (uint64_t)v13;
  uint64_t v10 = v14;
  if ((char *)v14 != v13)
  {
    do
    {
      *(void *)(v10 - 64) = off_1007AED90;
      *(void *)(v10 - 136) = off_1007AED90;
      v10 -= 176LL;
    }

    while (v10 != v9);
    uint64_t v14 = v9;
  }

  if (__p) {
    operator delete(__p);
  }
  return v8;
}

double sub_1002D6B30(uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v5 = *a3;
  __int128 v6 = a3[1];
  *(void *)(a2 + 32) = *((void *)a3 + 4);
  *(_OWORD *)a2 = v5;
  *(_OWORD *)(a2 + 16) = v6;
  sub_1002D5F00(a2 + 40, (uint64_t)a3 + 40);
  *(_DWORD *)(a2 + 104) = *((_DWORD *)a3 + 26);
  *(void *)&double result = sub_1002D5F00(a2 + 112, (uint64_t)(a3 + 7)).n128_u64[0];
  return result;
}

void sub_1002D6B8C(_Unwind_Exception *a1)
{
  void *v1 = off_1007AED90;
  _Unwind_Resume(a1);
}

uint64_t sub_1002D6BA0(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_1002D6BAC(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t sub_1002D6BFC(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_1002D6C08(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

double sub_1002D6C54(uint64_t a1, int a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (!v3) {
    sub_1003A91C8();
  }
  unsigned int v4 = a2 + *(_DWORD *)(a1 + 20) * a3;
  if ((v4 & 0x80000000) != 0) {
    sub_1003A91F0();
  }
  return *(double *)(v3 + 8LL * v4);
}

void sub_1002D6C94(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    unsigned int v4 = (char *)v1[1];
    __int128 v5 = **a1;
    if (v4 != v2)
    {
      __int128 v6 = v4 - 72;
      __int128 v7 = v4 - 72;
      do
      {
        uint64_t v8 = *(void (***)(char *))v7;
        v7 -= 72;
        (*v8)(v6);
        BOOL v9 = v6 == v2;
        __int128 v6 = v7;
      }

      while (!v9);
      __int128 v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

uint64_t sub_1002D6D20(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0x8E38E38E38E38E39LL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x38E38E38E38E38ELL) {
    sub_10001E11C();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x8E38E38E38E38E39LL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x1C71C71C71C71C7LL) {
    unint64_t v9 = 0x38E38E38E38E38ELL;
  }
  else {
    unint64_t v9 = v5;
  }
  size_t v17 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)sub_10022F3F4(v7, v9);
  }
  else {
    uint64_t v10 = 0LL;
  }
  uint64_t v13 = v10;
  uint64_t v14 = &v10[72 * v4];
  uint64_t v16 = &v10[72 * v9];
  sub_1002D61D4((uint64_t)v14, a2);
  unint64_t v15 = v14 + 72;
  sub_1002D6E3C(a1, &v13);
  uint64_t v11 = a1[1];
  sub_1002D6F48((uint64_t)&v13);
  return v11;
}

void sub_1002D6E28(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_1002D6E3C(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1002D6EB0((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1002D6EB0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = 0LL;
  uint64_t v11 = a7 - 72;
  while (a3 + v10 != a5)
  {
    uint64_t v12 = v11 + v10;
    v10 -= 72LL;
    sub_1002D61D4(v12, v10 + a3);
  }

  return a6;
}

uint64_t sub_1002D6F48(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    unint64_t v4 = *(void (***)(void))(i - 72);
    *(void *)(a1 + 16) = i - 72;
    (*v4)();
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1002D6F98(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    unint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 64;
      uint64_t v7 = v4 - 64;
      do
      {
        uint64_t v8 = *(void (***)(char *))v7;
        v7 -= 64;
        (*v8)(v6);
        BOOL v9 = v6 == v2;
        uint64_t v6 = v7;
      }

      while (!v9);
      uint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

uint64_t sub_1002D7024(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1002D70CC((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_1002D7098(uint64_t a1, unint64_t a2)
{
  if (a2 >> 58) {
    sub_10001D350();
  }
  return operator new(a2 << 6);
}

uint64_t sub_1002D70CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = 0LL;
  uint64_t v11 = a7 - 64;
  while (a3 + v10 != a5)
  {
    uint64_t v12 = v11 + v10;
    v10 -= 64LL;
    sub_1002D5F00(v12, v10 + a3);
  }

  return a6;
}

uint64_t sub_1002D7164(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    unint64_t v4 = *(void (***)(void))(i - 64);
    *(void *)(a1 + 16) = i - 64;
    (*v4)();
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1002D71B4(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    for (i = (char *)v1[1]; i != v2; *(void *)unint64_t v4 = off_1007AED90)
    {
      *((void *)i - 16) = off_1007AED90;
      *((void *)i - 30) = off_1007AED90;
      unint64_t v4 = i - 608;
      *((void *)i - 51) = off_1007AED90;
      *((void *)i - 59) = off_1007AED90;
      *((void *)i - 67) = off_1007AED90;
      i -= 616;
    }

    v1[1] = v2;
    operator delete(v2);
  }

uint64_t sub_1002D7218(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = 0x4FCACE213F2B3885LL * ((a1[1] - *a1) >> 3);
  unint64_t v4 = v3 + 1;
  if (0x9F959C427E56710ALL * ((a1[2] - *a1) >> 3) > v4) {
    unint64_t v4 = 0x9F959C427E56710ALL * ((a1[2] - *a1) >> 3);
  }
  else {
    unint64_t v6 = v4;
  }
  uint64_t v14 = a1 + 2;
  if (v6) {
    uint64_t v7 = (char *)sub_1002D74B0((uint64_t)(a1 + 2), v6);
  }
  else {
    uint64_t v7 = 0LL;
  }
  uint64_t v10 = v7;
  uint64_t v11 = &v7[616 * v3];
  uint64_t v13 = &v7[616 * v6];
  sub_1002D733C((uint64_t)(a1 + 2), (uint64_t)v11, a2);
  uint64_t v12 = v11 + 616;
  sub_1002D743C(a1, &v10);
  uint64_t v8 = a1[1];
  sub_1002D7688((uint64_t)&v10);
  return v8;
}

void sub_1002D7328(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_1002D733C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a3 + 80;
  *(_BYTE *)a2 = *(_BYTE *)a3;
  uint64_t v6 = a2 + 80;
  sub_1002D61D4(a2 + 8, a3 + 8);
  sub_1002D5F00(v6, v5);
  sub_1002D5F00(a2 + 144, a3 + 144);
  sub_1002D63CC(a2 + 208, a3 + 208);
  sub_1002D606C(a2 + 376, a3 + 376);
  sub_1002D606C(a2 + 488, a3 + 488);
  uint64_t v7 = *(void *)(a3 + 600);
  *(_DWORD *)(a2 + 60_Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)(a3 + 608);
  *(void *)(a2 + 600) = v7;
}

void sub_1002D73EC(_Unwind_Exception *a1)
{
  *uint64_t v5 = off_1007AED90;
  *unint64_t v4 = off_1007AED90;
  *uint64_t v3 = off_1007AED90;
  void *v2 = off_1007AED90;
  void *v1 = off_1007AED90;
  _Unwind_Resume(a1);
}

uint64_t sub_1002D743C(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1002D74F8((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_1002D74B0(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x6A63BD81A98EF7LL) {
    sub_10001D350();
  }
  return operator new(616 * a2);
}

uint64_t sub_1002D74F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  for (uint64_t i = 0LL; a3 + i != a5; sub_1002D7588(a1, i + a7, i + a3))
    i -= 616LL;
  return a6;
}

void sub_1002D7588(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a3 + 80;
  *(_BYTE *)a2 = *(_BYTE *)a3;
  uint64_t v6 = a2 + 80;
  sub_1002D61D4(a2 + 8, a3 + 8);
  sub_1002D5F00(v6, v5);
  sub_1002D5F00(a2 + 144, a3 + 144);
  sub_1002D63CC(a2 + 208, a3 + 208);
  sub_1002D606C(a2 + 376, a3 + 376);
  sub_1002D606C(a2 + 488, a3 + 488);
  uint64_t v7 = *(void *)(a3 + 600);
  *(_DWORD *)(a2 + 60_Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)(a3 + 608);
  *(void *)(a2 + 600) = v7;
}

void sub_1002D7638(_Unwind_Exception *a1)
{
  *uint64_t v5 = off_1007AED90;
  *unint64_t v4 = off_1007AED90;
  *uint64_t v3 = off_1007AED90;
  void *v2 = off_1007AED90;
  void *v1 = off_1007AED90;
  _Unwind_Resume(a1);
}

uint64_t sub_1002D7688(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3 != v2)
  {
    do
    {
      *(void *)(v3 - 12_Block_object_dispose((const void *)(v1 - 112), 8) = off_1007AED90;
      *(void *)(v3 - 240) = off_1007AED90;
      unint64_t v4 = (void *)(v3 - 608);
      *(void *)(v3 - 40_Block_object_dispose((const void *)(v1 - 112), 8) = off_1007AED90;
      *(void *)(v3 - 472) = off_1007AED90;
      *(void *)(v3 - 536) = off_1007AED90;
      v3 -= 616LL;
      *unint64_t v4 = off_1007AED90;
    }

    while (v3 != v2);
    *(void *)(a1 + 16) = v2;
  }

  uint64_t v5 = *(void **)a1;
  if (*(void *)a1) {
    operator delete(v5);
  }
  return a1;
}

uint64_t sub_1002D7704(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a2;
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  do
  {
    *(_BYTE *)a4 = *(_BYTE *)v5;
    sub_1002CBDC8(a4 + 8, v5 + 8);
    sub_1002CBDC8(a4 + 80, v5 + 80);
    sub_1002CBDC8(a4 + 144, v5 + 144);
    sub_1002CBDC8(a4 + 208, v5 + 208);
    sub_1002CBDC8(a4 + 376, v5 + 376);
    sub_1002CBDC8(a4 + 488, v5 + 488);
    int v7 = *(_DWORD *)(v5 + 608);
    *(void *)(a4 + 600) = *(void *)(v5 + 600);
    *(_DWORD *)(a4 + 60_Block_object_dispose((const void *)(v1 - 112), 8) = v7;
    a4 += 616LL;
    v5 += 616LL;
  }

  while (v5 != v6);
  return v6;
}

void sub_1002D77B8(uint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
LABEL_1:
  uint64_t v57 = (char *)(a2 - 616);
  unint64_t v6 = a1;
  while (2)
  {
    a1 = v6;
    uint64_t v7 = a2 - v6;
    unint64_t v8 = 0x4FCACE213F2B3885LL * ((uint64_t)(a2 - v6) >> 3);
    switch(v8)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        if (*(double *)(a2 - 16) < *(double *)(v6 + 600))
        {
          double v40 = (char *)v6;
          double v41 = (char *)(a2 - 616);
          goto LABEL_55;
        }

        return;
      case 3uLL:
        sub_1002D88D0(v6, v6 + 616, (uint64_t)v57);
        return;
      case 4uLL:
        sub_1002D8EDC(v6, v6 + 616, v6 + 1232, (uint64_t)v57);
        return;
      case 5uLL:
        sub_1002D8EDC(v6, v6 + 616, v6 + 1232, v6 + 1848);
        if (*(double *)(a2 - 16) < *(double *)(v6 + 2448))
        {
          sub_1002D8D28((char *)(v6 + 1848), v57);
          if (*(double *)(v6 + 2448) < *(double *)(v6 + 1832))
          {
            sub_1002D8D28((char *)(v6 + 1232), (char *)(v6 + 1848));
            if (*(double *)(v6 + 1832) < *(double *)(v6 + 1216))
            {
              sub_1002D8D28((char *)(v6 + 616), (char *)(v6 + 1232));
              if (*(double *)(v6 + 1216) < *(double *)(v6 + 600))
              {
                double v40 = (char *)v6;
                double v41 = (char *)(v6 + 616);
LABEL_55:
                sub_1002D8D28(v40, v41);
              }
            }
          }
        }

        return;
      default:
        if (v7 <= 14783)
        {
          if ((a4 & 1) != 0)
          {
            if (v6 != a2)
            {
              double v42 = (_BYTE *)(v6 + 616);
              if (v6 + 616 != a2)
              {
                uint64_t v43 = 0LL;
                unint64_t v44 = v6;
                do
                {
                  double v45 = v42;
                  if (*(double *)(v44 + 1216) < *(double *)(v44 + 600))
                  {
                    uint64_t v65 = v42;
                    char v69 = *v42;
                    sub_1002D61D4((uint64_t)v71, v44 + 624);
                    sub_1002D5F00((uint64_t)v72, v44 + 696);
                    sub_1002D5F00((uint64_t)v73, v44 + 760);
                    sub_1002D63CC((uint64_t)v74, v44 + 824);
                    sub_1002D606C((uint64_t)v75, v44 + 992);
                    sub_1002D606C((uint64_t)v76, v44 + 1104);
                    double v77 = *(double *)(v44 + 1216);
                    int v78 = *(_DWORD *)(v44 + 1224);
                    uint64_t v46 = v43;
                    while (1)
                    {
                      uint64_t v47 = v6 + v46;
                      *(_BYTE *)(v6 + v46 + 616) = *(_BYTE *)(v6 + v46);
                      uint64_t v48 = v6 + v46 + 8;
                      sub_1002CBDC8(v6 + v46 + 624, v48);
                      sub_1002CBDC8(v47 + 696, v47 + 80);
                      sub_1002CBDC8(v47 + 760, v47 + 144);
                      sub_1002CBDC8(v47 + 824, v47 + 208);
                      sub_1002CBDC8(v47 + 992, v47 + 376);
                      sub_1002CBDC8(v47 + 1104, v47 + 488);
                      *(void *)(v47 + 1216) = *(void *)(v47 + 600);
                      *(_DWORD *)(v47 + 1224) = *(_DWORD *)(v47 + 608);
                      if (!v46) {
                        break;
                      }
                      v46 -= 616LL;
                      if (v77 >= *(double *)(v47 - 16))
                      {
                        int v49 = (_BYTE *)(v6 + v46 + 616);
                        goto LABEL_73;
                      }
                    }

                    int v49 = (_BYTE *)v6;
LABEL_73:
                    *int v49 = v69;
                    sub_1002CBDC8(v48, (uint64_t)v71);
                    sub_1002CBDC8(v47 + 80, (uint64_t)v72);
                    sub_1002CBDC8(v47 + 144, (uint64_t)v73);
                    sub_1002CBDC8(v47 + 208, (uint64_t)v74);
                    sub_1002CBDC8(v47 + 376, (uint64_t)v75);
                    sub_1002CBDC8(v47 + 488, (uint64_t)v76);
                    int v50 = v78;
                    *(double *)(v47 + 600) = v77;
                    *(_DWORD *)(v47 + 60_Block_object_dispose((const void *)(v1 - 112), 8) = v50;
                    double v45 = v65;
                  }

                  double v42 = v45 + 616;
                  v43 += 616LL;
                  unint64_t v44 = (unint64_t)v45;
                }

                while (v45 + 616 != (_BYTE *)a2);
              }
            }
          }

          else if (v6 != a2)
          {
            uint64_t v51 = (_BYTE *)(v6 + 616);
            if (v6 + 616 != a2)
            {
              unint64_t v52 = v6 - 16;
              do
              {
                __int128 v53 = v51;
                if (*(double *)(a1 + 1216) < *(double *)(a1 + 600))
                {
                  char v70 = *v51;
                  sub_1002D61D4((uint64_t)v71, a1 + 624);
                  sub_1002D5F00((uint64_t)v72, a1 + 696);
                  sub_1002D5F00((uint64_t)v73, a1 + 760);
                  sub_1002D63CC((uint64_t)v74, a1 + 824);
                  sub_1002D606C((uint64_t)v75, a1 + 992);
                  sub_1002D606C((uint64_t)v76, a1 + 1104);
                  double v77 = *(double *)(a1 + 1216);
                  int v78 = *(_DWORD *)(a1 + 1224);
                  unint64_t v54 = v52;
                  do
                  {
                    *(_BYTE *)(v54 + 632) = *(_BYTE *)(v54 + 16);
                    sub_1002CBDC8(v54 + 640, v54 + 24);
                    sub_1002CBDC8(v54 + 712, v54 + 96);
                    sub_1002CBDC8(v54 + 776, v54 + 160);
                    sub_1002CBDC8(v54 + 840, v54 + 224);
                    sub_1002CBDC8(v54 + 1008, v54 + 392);
                    sub_1002CBDC8(v54 + 1120, v54 + 504);
                    *(_DWORD *)(v54 + 1240) = *(_DWORD *)(v54 + 624);
                    *(void *)(v54 + 1232) = *(void *)(v54 + 616);
                    double v55 = *(double *)v54;
                    v54 -= 616LL;
                  }

                  while (v77 < v55);
                  *(_BYTE *)(v54 + 632) = v70;
                  sub_1002CBDC8(v54 + 640, (uint64_t)v71);
                  sub_1002CBDC8(v54 + 712, (uint64_t)v72);
                  sub_1002CBDC8(v54 + 776, (uint64_t)v73);
                  sub_1002CBDC8(v54 + 840, (uint64_t)v74);
                  sub_1002CBDC8(v54 + 1008, (uint64_t)v75);
                  sub_1002CBDC8(v54 + 1120, (uint64_t)v76);
                  int v56 = v78;
                  *(double *)(v54 + 1232) = v77;
                  *(_DWORD *)(v54 + 1240) = v56;
                }

                uint64_t v51 = v53 + 616;
                v52 += 616LL;
                a1 = (uint64_t)v53;
              }

              while (v53 + 616 != (_BYTE *)a2);
            }
          }

          return;
        }

        if (!a3)
        {
          sub_1002D82A4(v6, a2, a2);
          return;
        }

        unint64_t v9 = v8 >> 1;
        uint64_t v10 = (char *)(v6 + 616 * (v8 >> 1));
        if ((unint64_t)v7 < 0x13401)
        {
          sub_1002D88D0((uint64_t)v10, v6, (uint64_t)v57);
        }

        else
        {
          sub_1002D88D0(v6, (uint64_t)v10, (uint64_t)v57);
          uint64_t v11 = 616 * v9;
          sub_1002D88D0(v6 + 616, v11 + v6 - 616, a2 - 1232);
          sub_1002D88D0(v6 + 1232, v6 + 616 + v11, a2 - 1848);
          sub_1002D88D0(v11 + v6 - 616, (uint64_t)v10, v6 + 616 + v11);
          sub_1002D8D28((char *)v6, v10);
        }

        --a3;
        if ((a4 & 1) == 0 && *(double *)(v6 - 16) >= *(double *)(v6 + 600))
        {
          char v68 = *(_BYTE *)v6;
          sub_1002D61D4((uint64_t)v71, v6 + 8);
          sub_1002D5F00((uint64_t)v72, v6 + 80);
          uint64_t v64 = v6 + 144;
          sub_1002D5F00((uint64_t)v73, v6 + 144);
          uint64_t v63 = v6 + 208;
          sub_1002D63CC((uint64_t)v74, v6 + 208);
          uint64_t v61 = v6 + 376;
          sub_1002D606C((uint64_t)v75, v6 + 376);
          uint64_t v59 = v6 + 488;
          sub_1002D606C((uint64_t)v76, v6 + 488);
          double v28 = *(double *)(v6 + 600);
          int v78 = *(_DWORD *)(v6 + 608);
          double v77 = v28;
          if (v28 >= *(double *)(a2 - 16))
          {
            unint64_t v31 = v6 + 616;
            do
            {
              unint64_t v6 = v31;
              if (v31 >= a2) {
                break;
              }
              v31 += 616LL;
            }

            while (v77 >= *(double *)(v6 + 600));
          }

          else
          {
            unint64_t v29 = v6;
            do
            {
              unint64_t v6 = v29 + 616;
              double v30 = *(double *)(v29 + 1216);
              v29 += 616LL;
            }

            while (v77 >= v30);
          }

          __int128 v32 = (char *)a2;
          if (v6 < a2)
          {
            unint64_t v33 = a2;
            do
            {
              __int128 v32 = (char *)(v33 - 616);
              double v34 = *(double *)(v33 - 16);
              v33 -= 616LL;
            }

            while (v77 < v34);
          }

          while (v6 < (unint64_t)v32)
          {
            sub_1002D8D28((char *)v6, v32);
            do
            {
              double v35 = *(double *)(v6 + 1216);
              v6 += 616LL;
            }

            while (v77 >= v35);
            do
            {
              double v36 = *((double *)v32 - 2);
              v32 -= 616;
            }

            while (v77 < v36);
          }

          double v37 = (char *)(v6 - 616);
          if (v6 - 616 != a1)
          {
            *(_BYTE *)a1 = *v37;
            sub_1002CBDC8(a1 + 8, v6 - 608);
            sub_1002CBDC8(a1 + 80, v6 - 536);
            sub_1002CBDC8(v64, v6 - 472);
            sub_1002CBDC8(v63, v6 - 408);
            sub_1002CBDC8(v61, v6 - 240);
            sub_1002CBDC8(v59, v6 - 128);
            int v38 = *(_DWORD *)(v6 - 8);
            *(void *)(a1 + 600) = *(void *)(v6 - 16);
            *(_DWORD *)(a1 + 60_Block_object_dispose((const void *)(v1 - 112), 8) = v38;
          }

          char *v37 = v68;
          sub_1002CBDC8(v6 - 608, (uint64_t)v71);
          sub_1002CBDC8(v6 - 536, (uint64_t)v72);
          sub_1002CBDC8(v6 - 472, (uint64_t)v73);
          sub_1002CBDC8(v6 - 408, (uint64_t)v74);
          sub_1002CBDC8(v6 - 240, (uint64_t)v75);
          sub_1002CBDC8(v6 - 128, (uint64_t)v76);
          a4 = 0;
          int v39 = v78;
          *(double *)(v6 - 16) = v77;
          *(_DWORD *)(v6 - _Block_object_dispose((const void *)(v1 - 112), 8) = v39;
          continue;
        }

        char v67 = *(_BYTE *)v6;
        sub_1002D61D4((uint64_t)v71, v6 + 8);
        sub_1002D5F00((uint64_t)v72, v6 + 80);
        sub_1002D5F00((uint64_t)v73, v6 + 144);
        sub_1002D63CC((uint64_t)v74, v6 + 208);
        sub_1002D606C((uint64_t)v75, v6 + 376);
        sub_1002D606C((uint64_t)v76, v6 + 488);
        uint64_t v12 = 0LL;
        double v13 = *(double *)(v6 + 600);
        int v78 = *(_DWORD *)(v6 + 608);
        double v77 = v13;
        do
        {
          double v14 = *(double *)(v6 + v12 + 1216);
          v12 += 616LL;
        }

        while (v14 < v77);
        unint64_t v15 = v6 + v12;
        unint64_t v16 = a2;
        if (v12 == 616)
        {
          unint64_t v19 = a2;
          while (v15 < v19)
          {
            size_t v17 = (char *)(v19 - 616);
            double v20 = *(double *)(v19 - 16);
            v19 -= 616LL;
            if (v20 < v77) {
              goto LABEL_20;
            }
          }

          size_t v17 = (char *)v19;
        }

        else
        {
          do
          {
            size_t v17 = (char *)(v16 - 616);
            double v18 = *(double *)(v16 - 16);
            v16 -= 616LL;
          }

          while (v18 >= v77);
        }

void sub_1002D82A4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v61 = v3;
    uint64_t v62 = v4;
    uint64_t v6 = a1;
    uint64_t v8 = a2 - a1;
    uint64_t v9 = (a2 - a1) / 616;
    if (a2 - a1 >= 617)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      uint64_t v12 = (double *)(a1 + 616 * v10);
      do
      {
        sub_1002D8F70(v6, v9, v12);
        v12 -= 77;
        --v11;
      }

      while (v11);
    }

    uint64_t v13 = a2;
    if (a2 != a3)
    {
      uint64_t v14 = a2;
      do
      {
        if (*(double *)(v14 + 600) < *(double *)(v6 + 600))
        {
          sub_1002D8D28((char *)v14, (char *)v6);
          sub_1002D8F70(v6, v9, (double *)v6);
        }

        v14 += 616LL;
      }

      while (v14 != a3);
    }

    if (v8 >= 617)
    {
      int64_t v15 = v8 / 0x268uLL;
      uint64_t v38 = v6 + 80;
      uint64_t v39 = v6 + 8;
      uint64_t v36 = v6 + 208;
      uint64_t v37 = v6 + 144;
      uint64_t v34 = v6 + 488;
      uint64_t v35 = v6 + 376;
      uint64_t v32 = v6;
      uint64_t v33 = v6 + 600;
      do
      {
        uint64_t v41 = v13;
        char v43 = *(_BYTE *)v6;
        sub_1002D61D4((uint64_t)v44, v39);
        sub_1002D5F00((uint64_t)v45, v38);
        sub_1002D5F00((uint64_t)v46, v37);
        sub_1002D63CC((uint64_t)v47, v36);
        sub_1002D606C((uint64_t)v48, v35);
        sub_1002D606C((uint64_t)v49, v34);
        uint64_t v16 = 0LL;
        uint64_t v50 = *(void *)v33;
        int v51 = *(_DWORD *)(v33 + 8);
        uint64_t v42 = v15;
        uint64_t v17 = v6;
        do
        {
          uint64_t v18 = v17;
          uint64_t v19 = v16 + 1;
          v17 += 616 * (v16 + 1);
          uint64_t v20 = 2 * v16;
          uint64_t v16 = (2 * v16) | 1;
          int64_t v21 = v20 + 2;
          if (v21 < v15 && *(double *)(v18 + 616 * v19 + 600) < *(double *)(v17 + 1216))
          {
            v17 += 616LL;
            uint64_t v16 = v21;
          }

          *(_BYTE *)uint64_t v18 = *(_BYTE *)v17;
          sub_1002CBDC8(v18 + 8, v17 + 8);
          sub_1002CBDC8(v18 + 80, v17 + 80);
          sub_1002CBDC8(v18 + 144, v17 + 144);
          sub_1002CBDC8(v18 + 208, v17 + 208);
          sub_1002CBDC8(v18 + 376, v17 + 376);
          sub_1002CBDC8(v18 + 488, v17 + 488);
          int v22 = *(_DWORD *)(v17 + 608);
          *(void *)(v18 + 600) = *(void *)(v17 + 600);
          *(_DWORD *)(v18 + 60_Block_object_dispose((const void *)(v1 - 112), 8) = v22;
        }

        while (v16 <= (uint64_t)((unint64_t)(v15 - 2) >> 1));
        double v23 = (void *)(v17 + 600);
        uint64_t v24 = (char *)(v13 - 616);
        if (v17 == v13 - 616)
        {
          *(_BYTE *)uint64_t v17 = v43;
          sub_1002CBDC8(v17 + 8, (uint64_t)v44);
          sub_1002CBDC8(v17 + 80, (uint64_t)v45);
          sub_1002CBDC8(v17 + 144, (uint64_t)v46);
          sub_1002CBDC8(v17 + 208, (uint64_t)v47);
          sub_1002CBDC8(v17 + 376, (uint64_t)v48);
          sub_1002CBDC8(v17 + 488, (uint64_t)v49);
          int v31 = v51;
          *double v23 = v50;
          *(_DWORD *)(v17 + 60_Block_object_dispose((const void *)(v1 - 112), 8) = v31;
          uint64_t v6 = v32;
        }

        else
        {
          *(_BYTE *)uint64_t v17 = *v24;
          sub_1002CBDC8(v17 + 8, v13 - 608);
          sub_1002CBDC8(v17 + 80, v13 - 536);
          sub_1002CBDC8(v17 + 144, v13 - 472);
          sub_1002CBDC8(v17 + 208, v13 - 408);
          sub_1002CBDC8(v17 + 376, v13 - 240);
          sub_1002CBDC8(v17 + 488, v13 - 128);
          uint64_t v25 = *(void *)(v13 - 16);
          *(_DWORD *)(v17 + 60_Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)(v13 - 8);
          double v40 = (double *)(v17 + 600);
          *double v23 = v25;
          *uint64_t v24 = v43;
          sub_1002CBDC8(v13 - 608, (uint64_t)v44);
          sub_1002CBDC8(v13 - 536, (uint64_t)v45);
          sub_1002CBDC8(v13 - 472, (uint64_t)v46);
          sub_1002CBDC8(v13 - 408, (uint64_t)v47);
          sub_1002CBDC8(v13 - 240, (uint64_t)v48);
          sub_1002CBDC8(v13 - 128, (uint64_t)v49);
          *(void *)(v13 - 16) = v50;
          *(_DWORD *)(v13 - _Block_object_dispose((const void *)(v1 - 112), 8) = v51;
          uint64_t v6 = v32;
          uint64_t v26 = v17 - v32 + 616;
          if (v26 >= 617)
          {
            unint64_t v27 = (v26 / 0x268uLL - 2) >> 1;
            if (*(double *)(v32 + 616 * v27 + 600) < *v40)
            {
              char v52 = *(_BYTE *)v17;
              sub_1002D61D4((uint64_t)v53, v17 + 8);
              sub_1002D5F00((uint64_t)v54, v17 + 80);
              sub_1002D5F00((uint64_t)v55, v17 + 144);
              sub_1002D63CC((uint64_t)v56, v17 + 208);
              sub_1002D606C((uint64_t)v57, v17 + 376);
              sub_1002D606C((uint64_t)v58, v17 + 488);
              double v28 = *v40;
              int v60 = *(_DWORD *)(v17 + 608);
              double v59 = v28;
              do
              {
                uint64_t v29 = v17;
                uint64_t v17 = v32 + 616 * v27;
                *(_BYTE *)uint64_t v29 = *(_BYTE *)v17;
                sub_1002CBDC8(v29 + 8, v17 + 8);
                sub_1002CBDC8(v29 + 80, v17 + 80);
                sub_1002CBDC8(v29 + 144, v17 + 144);
                sub_1002CBDC8(v29 + 208, v17 + 208);
                sub_1002CBDC8(v29 + 376, v17 + 376);
                sub_1002CBDC8(v29 + 488, v17 + 488);
                int v30 = *(_DWORD *)(v17 + 608);
                *(void *)(v29 + 600) = *(void *)(v17 + 600);
                *(_DWORD *)(v29 + 60_Block_object_dispose((const void *)(v1 - 112), 8) = v30;
                if (!v27) {
                  break;
                }
                unint64_t v27 = (v27 - 1) >> 1;
              }

              while (*(double *)(v32 + 616 * v27 + 600) < v59);
              *(_BYTE *)uint64_t v17 = v52;
              sub_1002CBDC8(v17 + 8, (uint64_t)v53);
              sub_1002CBDC8(v17 + 80, (uint64_t)v54);
              sub_1002CBDC8(v17 + 144, (uint64_t)v55);
              sub_1002CBDC8(v17 + 208, (uint64_t)v56);
              sub_1002CBDC8(v17 + 376, (uint64_t)v57);
              sub_1002CBDC8(v17 + 488, (uint64_t)v58);
              *(double *)(v17 + 600) = v59;
              *(_DWORD *)(v17 + 60_Block_object_dispose((const void *)(v1 - 112), 8) = v60;
            }
          }
        }

        --v15;
        uint64_t v13 = v41 - 616;
      }

      while (v42 > 2);
    }
  }

void sub_1002D88D0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a1;
  double v6 = *(double *)(a2 + 600);
  double v7 = *(double *)(a3 + 600);
  if (v6 < *(double *)(a1 + 600))
  {
    if (v7 >= v6)
    {
      sub_1002D8D28((char *)a1, (char *)a2);
      a1 = a2;
    }

    uint64_t v8 = (char *)a3;
    goto LABEL_9;
  }

  if (v7 < v6)
  {
    sub_1002D8D28((char *)a2, (char *)a3);
    if (*(double *)(a2 + 600) < *(double *)(v5 + 600))
    {
      a1 = v5;
      uint64_t v8 = (char *)a2;
LABEL_9:
      sub_1002D8D28((char *)a1, v8);
    }
  }

BOOL sub_1002D897C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v4 = 0x4FCACE213F2B3885LL * ((a2 - a1) >> 3);
  BOOL result = 1LL;
  switch(v4)
  {
    case 0LL:
    case 1LL:
      return result;
    case 2LL:
      if (*(double *)(a2 - 16) < *(double *)(a1 + 600))
      {
        double v6 = (char *)(a2 - 616);
        double v7 = (char *)a1;
        goto LABEL_4;
      }

      return result;
    case 3LL:
      sub_1002D88D0(a1, a1 + 616, a2 - 616);
      return 1LL;
    case 4LL:
      sub_1002D8EDC(a1, a1 + 616, a1 + 1232, a2 - 616);
      return 1LL;
    case 5LL:
      sub_1002D8EDC(a1, a1 + 616, a1 + 1232, a1 + 1848);
      if (*(double *)(v2 - 16) < *(double *)(a1 + 2448))
      {
        sub_1002D8D28((char *)(a1 + 1848), (char *)(v2 - 616));
        if (*(double *)(a1 + 2448) < *(double *)(a1 + 1832))
        {
          sub_1002D8D28((char *)(a1 + 1232), (char *)(a1 + 1848));
          if (*(double *)(a1 + 1832) < *(double *)(a1 + 1216))
          {
            sub_1002D8D28((char *)(a1 + 616), (char *)(a1 + 1232));
            if (*(double *)(a1 + 1216) < *(double *)(a1 + 600))
            {
              double v7 = (char *)a1;
              double v6 = (char *)(a1 + 616);
LABEL_4:
              sub_1002D8D28(v7, v6);
            }
          }
        }
      }

      return 1LL;
    default:
      uint64_t v8 = a1 + 1232;
      sub_1002D88D0(a1, a1 + 616, a1 + 1232);
      uint64_t v9 = a1 + 1848;
      if (a1 + 1848 == v2) {
        return 1LL;
      }
      uint64_t v10 = 0LL;
      int v11 = 0;
      uint64_t v15 = v2;
      break;
  }

  while (*(double *)(v9 + 600) >= *(double *)(v8 + 600))
  {
LABEL_16:
    uint64_t v8 = v9;
    v10 += 616LL;
    v9 += 616LL;
    if (v9 == v2) {
      return 1LL;
    }
  }

  int v17 = v11;
  char v18 = *(_BYTE *)v9;
  sub_1002D61D4((uint64_t)v19, v9 + 8);
  sub_1002D5F00((uint64_t)v20, v9 + 80);
  sub_1002D5F00((uint64_t)v21, v9 + 144);
  sub_1002D63CC((uint64_t)v22, v9 + 208);
  sub_1002D606C((uint64_t)v23, v9 + 376);
  sub_1002D606C((uint64_t)v24, v9 + 488);
  double v25 = *(double *)(v9 + 600);
  int v26 = *(_DWORD *)(v9 + 608);
  uint64_t v16 = v10;
  while (1)
  {
    uint64_t v12 = a1 + v10;
    *(_BYTE *)(a1 + v10 + 184_Block_object_dispose((const void *)(v1 - 112), 8) = *(_BYTE *)(a1 + v10 + 1232);
    uint64_t v13 = a1 + v10 + 1240;
    sub_1002CBDC8(a1 + v10 + 1856, v13);
    sub_1002CBDC8(v12 + 1928, v12 + 1312);
    sub_1002CBDC8(v12 + 1992, v12 + 1376);
    sub_1002CBDC8(v12 + 2056, v12 + 1440);
    sub_1002CBDC8(v12 + 2224, v12 + 1608);
    sub_1002CBDC8(v12 + 2336, v12 + 1720);
    *(void *)(v12 + 244_Block_object_dispose((const void *)(v1 - 112), 8) = *(void *)(v12 + 1832);
    *(_DWORD *)(v12 + 2456) = *(_DWORD *)(v12 + 1840);
    if (v10 == -1232) {
      break;
    }
    v10 -= 616LL;
    if (v25 >= *(double *)(v12 + 1216))
    {
      uint64_t v14 = (_BYTE *)(a1 + v10 + 1848);
      goto LABEL_14;
    }
  }

  uint64_t v14 = (_BYTE *)a1;
LABEL_14:
  *uint64_t v14 = v18;
  sub_1002CBDC8(v13, (uint64_t)v19);
  sub_1002CBDC8(v12 + 1312, (uint64_t)v20);
  sub_1002CBDC8(v12 + 1376, (uint64_t)v21);
  sub_1002CBDC8(v12 + 1440, (uint64_t)v22);
  sub_1002CBDC8(v12 + 1608, (uint64_t)v23);
  sub_1002CBDC8(v12 + 1720, (uint64_t)v24);
  *(double *)(v12 + 1832) = v25;
  *(_DWORD *)(v12 + 1840) = v26;
  int v11 = v17 + 1;
  if (v17 != 7)
  {
    uint64_t v2 = v15;
    uint64_t v10 = v16;
    goto LABEL_16;
  }

  return v9 + 616 == v15;
}

void sub_1002D8D28(char *a1, char *a2)
{
  char v5 = *a1;
  sub_1002D61D4((uint64_t)v6, (uint64_t)(a1 + 8));
  sub_1002D5F00((uint64_t)v7, (uint64_t)(a1 + 80));
  sub_1002D5F00((uint64_t)v8, (uint64_t)(a1 + 144));
  sub_1002D63CC((uint64_t)v9, (uint64_t)(a1 + 208));
  sub_1002D606C((uint64_t)v10, (uint64_t)(a1 + 376));
  sub_1002D606C((uint64_t)v11, (uint64_t)(a1 + 488));
  uint64_t v12 = *((void *)a1 + 75);
  int v13 = *((_DWORD *)a1 + 152);
  *a1 = *a2;
  sub_1002CBDC8((uint64_t)(a1 + 8), (uint64_t)(a2 + 8));
  sub_1002CBDC8((uint64_t)(a1 + 80), (uint64_t)(a2 + 80));
  sub_1002CBDC8((uint64_t)(a1 + 144), (uint64_t)(a2 + 144));
  sub_1002CBDC8((uint64_t)(a1 + 208), (uint64_t)(a2 + 208));
  sub_1002CBDC8((uint64_t)(a1 + 376), (uint64_t)(a2 + 376));
  sub_1002CBDC8((uint64_t)(a1 + 488), (uint64_t)(a2 + 488));
  uint64_t v4 = *((void *)a2 + 75);
  *((_DWORD *)a1 + 152) = *((_DWORD *)a2 + 152);
  *((void *)a1 + 75) = v4;
  *a2 = v5;
  sub_1002CBDC8((uint64_t)(a2 + 8), (uint64_t)v6);
  sub_1002CBDC8((uint64_t)(a2 + 80), (uint64_t)v7);
  sub_1002CBDC8((uint64_t)(a2 + 144), (uint64_t)v8);
  sub_1002CBDC8((uint64_t)(a2 + 208), (uint64_t)v9);
  sub_1002CBDC8((uint64_t)(a2 + 376), (uint64_t)v10);
  sub_1002CBDC8((uint64_t)(a2 + 488), (uint64_t)v11);
  *((void *)a2 + 75) = v12;
  *((_DWORD *)a2 + 152) = v13;
}

void sub_1002D8EDC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(double *)(a4 + 600) < *(double *)(a3 + 600))
  {
    sub_1002D8D28((char *)a3, (char *)a4);
    if (*(double *)(a3 + 600) < *(double *)(a2 + 600))
    {
      sub_1002D8D28((char *)a2, (char *)a3);
    }
  }

void sub_1002D8F70(uint64_t a1, uint64_t a2, double *a3)
{
  unint64_t v3 = a2 - 2;
  if (a2 >= 2)
  {
    uint64_t v4 = a3;
    int64_t v18 = v3 >> 1;
    if ((uint64_t)(v3 >> 1) >= 0x4FCACE213F2B3885LL * (((uint64_t)a3 - a1) >> 3))
    {
      int64_t v5 = (0x9F959C427E56710ALL * (((uint64_t)a3 - a1) >> 3)) | 1;
      double v6 = (double *)(a1 + 616 * v5);
      if ((uint64_t)(0x9F959C427E56710ALL * (((uint64_t)a3 - a1) >> 3) + 2) < a2
        && *(double *)(a1 + 616 * v5 + 600) < v6[152])
      {
        v6 += 77;
        int64_t v5 = 0x9F959C427E56710ALL * (((uint64_t)a3 - a1) >> 3) + 2;
      }

      if (v6[75] >= a3[75])
      {
        char v20 = *(_BYTE *)a3;
        sub_1002D61D4((uint64_t)v21, (uint64_t)(a3 + 1));
        sub_1002D5F00((uint64_t)v22, (uint64_t)(v4 + 10));
        sub_1002D5F00((uint64_t)v23, (uint64_t)(v4 + 18));
        sub_1002D63CC((uint64_t)v24, (uint64_t)(v4 + 26));
        sub_1002D606C((uint64_t)v25, (uint64_t)(v4 + 47));
        sub_1002D606C((uint64_t)v26, (uint64_t)(v4 + 61));
        double v27 = v4[75];
        int v28 = *((_DWORD *)v4 + 152);
        do
        {
          double v7 = v6;
          *(_BYTE *)uint64_t v4 = *(_BYTE *)v6;
          uint64_t v8 = (uint64_t)(v6 + 1);
          sub_1002CBDC8((uint64_t)(v4 + 1), (uint64_t)(v6 + 1));
          uint64_t v9 = (uint64_t)(v6 + 10);
          sub_1002CBDC8((uint64_t)(v4 + 10), (uint64_t)(v6 + 10));
          uint64_t v10 = (uint64_t)(v6 + 18);
          sub_1002CBDC8((uint64_t)(v4 + 18), (uint64_t)(v6 + 18));
          uint64_t v11 = (uint64_t)(v6 + 26);
          sub_1002CBDC8((uint64_t)(v4 + 26), (uint64_t)(v6 + 26));
          uint64_t v12 = (uint64_t)(v6 + 47);
          sub_1002CBDC8((uint64_t)(v4 + 47), (uint64_t)(v6 + 47));
          uint64_t v13 = (uint64_t)(v6 + 61);
          sub_1002CBDC8((uint64_t)(v4 + 61), (uint64_t)(v6 + 61));
          int v14 = *((_DWORD *)v6 + 152);
          v4[75] = v6[75];
          *((_DWORD *)v4 + 152) = v14;
          if (v18 < v5) {
            break;
          }
          uint64_t v15 = (2 * v5) | 1;
          double v6 = (double *)(a1 + 616 * v15);
          if (2 * v5 + 2 < a2 && *(double *)(a1 + 616 * v15 + 600) < v6[152])
          {
            v6 += 77;
            uint64_t v15 = 2 * v5 + 2;
          }

          uint64_t v4 = v7;
          int64_t v5 = v15;
        }

        while (v6[75] >= v27);
        *(_BYTE *)double v7 = v20;
        sub_1002CBDC8(v8, (uint64_t)v21);
        sub_1002CBDC8(v9, (uint64_t)v22);
        sub_1002CBDC8(v10, (uint64_t)v23);
        sub_1002CBDC8(v11, (uint64_t)v24);
        sub_1002CBDC8(v12, (uint64_t)v25);
        sub_1002CBDC8(v13, (uint64_t)v26);
        int v16 = v28;
        v7[75] = v27;
        *((_DWORD *)v7 + 152) = v16;
      }
    }
  }

uint64_t sub_1002D921C(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = 0x4FCACE213F2B3885LL * ((a1[1] - *a1) >> 3);
  unint64_t v4 = v3 + 1;
  if (0x9F959C427E56710ALL * ((a1[2] - *a1) >> 3) > v4) {
    unint64_t v4 = 0x9F959C427E56710ALL * ((a1[2] - *a1) >> 3);
  }
  else {
    unint64_t v6 = v4;
  }
  int v14 = a1 + 2;
  if (v6) {
    double v7 = (char *)sub_1002D74B0((uint64_t)(a1 + 2), v6);
  }
  else {
    double v7 = 0LL;
  }
  uint64_t v10 = v7;
  uint64_t v11 = &v7[616 * v3];
  uint64_t v13 = &v7[616 * v6];
  sub_1002D7588((uint64_t)(a1 + 2), (uint64_t)v11, a2);
  uint64_t v12 = v11 + 616;
  sub_1002D743C(a1, &v10);
  uint64_t v8 = a1[1];
  sub_1002D7688((uint64_t)&v10);
  return v8;
}

void sub_1002D932C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_1002D9340( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, double *a6, int *a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = *a1;
  unint64_t v11 = 0xAF8AF8AF8AF8AF8BLL * ((a1[1] - *a1) >> 4);
  unint64_t v12 = v11 + 1;
  if (v11 + 1 > 0x75075075075075LL) {
    sub_10001E11C();
  }
  uint64_t v20 = (uint64_t)(a1 + 2);
  unint64_t v21 = 0xAF8AF8AF8AF8AF8BLL * ((a1[2] - v10) >> 4);
  if (2 * v21 > v12) {
    unint64_t v12 = 2 * v21;
  }
  if (v21 >= 0x3A83A83A83A83ALL) {
    unint64_t v22 = 0x75075075075075LL;
  }
  else {
    unint64_t v22 = v12;
  }
  int v30 = a1 + 2;
  if (v22) {
    double v23 = (char *)sub_1002D9624(v20, v22);
  }
  else {
    double v23 = 0LL;
  }
  int v26 = v23;
  double v27 = &v23[560 * v11];
  uint64_t v28 = (uint64_t)v27;
  uint64_t v29 = &v23[560 * v22];
  sub_1002D94AC((uint64_t)v27, a2, a3, a4, a5, *a7, a8, a9, *a6);
  uint64_t v28 = (uint64_t)(v27 + 560);
  sub_1002D95B0(a1, &v26);
  uint64_t v24 = a1[1];
  sub_1002D97E4((uint64_t)&v26);
  return v24;
}

void sub_1002D9498(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_1002D94AC( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, double a9)
{
  *(double *)(a1 + 416) = a9;
  *(_DWORD *)(a1 + 424) = a6;
  sub_1002D5F00(a1 + 432, a7);
  sub_1002D5F00(a1 + 496, a8);
  return a1;
}

void sub_1002D9560(_Unwind_Exception *a1)
{
  *int64_t v5 = off_1007AED90;
  *unint64_t v4 = off_1007AED90;
  *uint64_t v3 = off_1007AED90;
  void *v2 = off_1007AED90;
  void *v1 = off_1007AED90;
  _Unwind_Resume(a1);
}

uint64_t sub_1002D95B0(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1002D966C((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_1002D9624(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x75075075075076LL) {
    sub_10001D350();
  }
  return operator new(560 * a2);
}

uint64_t sub_1002D966C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  for (uint64_t i = 0LL; a3 + i != a5; sub_1002D96FC(a1, i + a7, i + a3))
    i -= 560LL;
  return a6;
}

double sub_1002D96FC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 416);
  *(_DWORD *)(a2 + 424) = *(_DWORD *)(a3 + 424);
  *(void *)(a2 + 416) = v5;
  sub_1002D5F00(a2 + 432, a3 + 432);
  *(void *)&double result = sub_1002D5F00(a2 + 496, a3 + 496).n128_u64[0];
  return result;
}

void sub_1002D9794(_Unwind_Exception *a1)
{
  *uint64_t v5 = off_1007AED90;
  *unint64_t v4 = off_1007AED90;
  *uint64_t v3 = off_1007AED90;
  void *v2 = off_1007AED90;
  void *v1 = off_1007AED90;
  _Unwind_Resume(a1);
}

uint64_t sub_1002D97E4(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
  uint64_t v3 = *(void **)(a1 + 16);
  if (v3 != v2)
  {
    do
    {
      *(v3 - _Block_object_dispose((const void *)(v1 - 112), 8) = off_1007AED90;
      *(v3 - 16) = off_1007AED90;
      *(v3 - 32) = off_1007AED90;
      unint64_t v4 = v3 - 61;
      uint64_t v5 = v3 - 70;
      *(v3 - 53) = off_1007AED90;
      *uint64_t v5 = off_1007AED90;
      v3 -= 70;
      *unint64_t v4 = off_1007AED90;
    }

    while (v5 != v2);
    *(void *)(a1 + 16) = v2;
  }

  uint64_t v6 = *(void **)a1;
  if (*(void *)a1) {
    operator delete(v6);
  }
  return a1;
}

void *sub_1002D9858(void *result)
{
  *double result = off_1007AED90;
  return result;
}

uint64_t sub_1002D986C(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_1002D9878(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_1002D98CC(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    for (uint64_t i = (char *)v1[1]; i != v2; i -= 152)
    {
      *((void *)i - 9) = off_1007AED90;
      *((void *)i - 1_Block_object_dispose((const void *)(v1 - 112), 8) = off_1007AED90;
    }

    v1[1] = v2;
    operator delete(v2);
  }

uint64_t sub_1002D9910(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1002D9984((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1002D9984(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = 0LL;
  uint64_t v12 = a7 - 152;
  while (a3 + v11 != a5)
  {
    uint64_t v13 = (void *)(v12 + v11);
    v11 -= 152LL;
    sub_1002D9A28(a1, v13, (void *)(v11 + a3));
  }

  return a6;
}

double sub_1002D9A28(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4 = (uint64_t)(a3 + 10);
  *a2 = *a3;
  sub_1002D9A84((uint64_t)(a2 + 1), (uint64_t)(a3 + 1));
  *(void *)&double result = sub_1002D61D4((uint64_t)(a2 + 10), v4).n128_u64[0];
  return result;
}

void sub_1002D9A74(_Unwind_Exception *a1)
{
  void *v1 = off_1007AED90;
  _Unwind_Resume(a1);
}

__n128 sub_1002D9A84(uint64_t a1, uint64_t a2)
{
  result.n128_u64[0] = 0x400000001LL;
  *(void *)(a1 + 24) = 0x400000001LL;
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = &off_1007BC818;
  if (a1 == a2)
  {
    int v16 = "this != &(A)";
    int v17 = 603;
LABEL_21:
    int64_t v18 = "cnmatrix.h";
    uint64_t v19 = "CNMatrix";
LABEL_22:
    __assert_rtn(v19, v18, v17, v16);
  }

  unsigned int v3 = *(_DWORD *)(a2 + 8);
  if (v3 > 1)
  {
    int v16 = "this->max_num_rows_ >= num_rows";
    int v17 = 422;
LABEL_18:
    int64_t v18 = "cnmatrixbase.h";
    uint64_t v19 = "SetMatrixSize";
    goto LABEL_22;
  }

  unsigned int v4 = *(_DWORD *)(a2 + 12);
  if (v4 >= 5)
  {
    int v16 = "this->max_num_cols_ >= num_cols";
    int v17 = 423;
    goto LABEL_18;
  }

  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v3;
  *(_DWORD *)(a1 + 12) = v4;
  uint64_t v5 = v4 * v3;
  *(_DWORD *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 20) = v3;
  uint64_t v6 = (_OWORD *)(a1 + 40);
  *(void *)(a1 + 32) = a1 + 40;
  if (*(_DWORD *)(a2 + 8) > 1u)
  {
    int v16 = "this->max_num_rows_ >= A.num_rows_";
    int v17 = 616;
    goto LABEL_21;
  }

  if (*(_DWORD *)(a2 + 12) > 4u)
  {
    int v16 = "this->max_num_cols_ >= A.num_cols_";
    int v17 = 617;
    goto LABEL_21;
  }

  int v7 = *(_DWORD *)(a2 + 16);
  if (v7 > 3)
  {
    uint64_t v10 = (v7 - 2);
    uint64_t v11 = *(__int128 **)(a2 + 32);
    uint64_t v12 = (__n128 *)((char *)v6 + 8 * v10);
    uint64_t v13 = (v7 - 1) >> 1;
    int v14 = v11;
    do
    {
      __int128 v15 = *v14++;
      *v6++ = v15;
      --v13;
    }

    while (v13);
    __n128 result = *(__n128 *)((char *)v11 + 8 * v10);
    __n128 *v12 = result;
  }

  else if ((_DWORD)v5)
  {
    uint64_t v8 = *(unint64_t **)(a2 + 32);
    do
    {
      unint64_t v9 = *v8++;
      result.n128_u64[0] = v9;
      *(void *)uint64_t v6 = v9;
      uint64_t v6 = (_OWORD *)((char *)v6 + 8);
      --v5;
    }

    while (v5);
  }

  return result;
}

void sub_1002D9BE0(_Unwind_Exception *a1)
{
  void *v1 = off_1007AED90;
  _Unwind_Resume(a1);
}

void sub_1002D9BF0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 == a3) {
    sub_1003A92A0();
  }
  if (a1 == a4) {
    sub_1003A92C8();
  }
  if (a3 == a4) {
    sub_1003A92F0();
  }
  unsigned int v7 = *(_DWORD *)(a1 + 8);
  if (v7 != *(_DWORD *)(a1 + 12)) {
    sub_1003A9430();
  }
  if (*(_DWORD *)(a2 + 28) * *(_DWORD *)(a2 + 24) < v7) {
    sub_1003A9318();
  }
  if (*(_DWORD *)(a3 + 28) * *(_DWORD *)(a3 + 24) < 4 * v7) {
    sub_1003A9340();
  }
  if (*(_DWORD *)(a4 + 24) < v7) {
    sub_1003A9368();
  }
  if (*(_DWORD *)(a4 + 28) < v7) {
    sub_1003A9390();
  }
  sub_1002CBDC8(a4, a1);
  uint64_t v8 = *(unsigned int *)(a4 + 8);
  uint64_t v9 = *(unsigned int *)(a4 + 12);
  uint64_t v10 = *(__CLPK_doublereal **)(a4 + 32);
  __CLPK_integer v11 = *(_DWORD *)(a4 + 20);
  uint64_t v12 = *(void **)(a2 + 32);
  __CLPK_integer __n = *(_DWORD *)(a4 + 12);
  __CLPK_integer __m = v8;
  __CLPK_integer __lda = v11;
  size_t v13 = 4 * v8;
  int v14 = (__CLPK_integer *)operator new[](4 * v8, &std::nothrow);
  if (!v14) {
    sub_1003A93B8();
  }
  __int128 v15 = v14;
  dgetrf_(&__m, &__n, v10, &__lda, v14, &__info);
  memcpy(v12, v15, v13);
  operator delete[](v15);
  if (__info)
  {
    if (__info >= 1)
    {
      LOWORD(__m) = 4;
      LOBYTE(__n) = 2;
      cnprint::CNPrinter::Print(&__m, &__n);
      goto LABEL_14;
    }

void *sub_1002D9E94(void *result)
{
  *__n128 result = off_1007AED90;
  return result;
}

void *sub_1002D9EA4(void *result)
{
  *__n128 result = off_1007BC9D8;
  return result;
}

uint64_t sub_1002D9EB8(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_1002D9EC4(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_1002D9EE4(uint64_t a1, char *a2, uint64_t a3)
{
  unsigned int v3 = *(_DWORD *)(a1 + 8);
  if (v3 >= 2)
  {
    unsigned int v5 = *(_DWORD *)(a1 + 12);
    if (v5 >= 2)
    {
      if (!a2) {
        sub_1003A7EC0(a1, 0LL, a3);
      }
      int v7 = v5 + v3 - *(_DWORD *)(a1 + 20);
      if (v7 <= 0) {
        sub_1003A7EE4(a1, (uint64_t)a2, a3);
      }
      bzero(a2, *(unsigned int *)(a1 + 16));
      int v8 = *(_DWORD *)(a1 + 16);
      if (v8 >= 3)
      {
        uint64_t v9 = (v8 - 1);
        uint64_t v10 = *(void *)(a1 + 32);
        uint64_t v11 = 1LL;
        do
        {
          uint64_t v12 = &a2[v11];
          if (!a2[v11])
          {
            int v13 = *(_DWORD *)(v10 + 4 * v11);
            int v14 = v11;
            do
            {
              int v14 = v14 * v7 % (int)v9;
              int v15 = *(_DWORD *)(v10 + 4LL * v14);
              *(_DWORD *)(v10 + 4LL * v14) = v13;
              char *v12 = 1;
              uint64_t v12 = &a2[v14];
              int v13 = v15;
            }

            while (!*v12);
          }

          ++v11;
        }

        while (v11 != v9);
      }
    }
  }

uint64_t sub_1002D9FB8(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_1002D9FC4(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t sub_1002DA014(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_1002DA020(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

float64x2_t sub_1002DA040(uint64_t a1, uint64_t a2, double a3)
{
  if (a1 == a2) {
    sub_1003A9458();
  }
  sub_1002CAEDC((_DWORD *)a2, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12));
  uint64_t v6 = *(unsigned int *)(a2 + 16);
  if ((int)v6 > 3)
  {
    uint64_t v10 = *(float64x2_t **)(a1 + 32);
    uint64_t v11 = *(float64x2_t **)(a2 + 32);
    uint64_t v12 = (float64x2_t *)((char *)v10 + 8 * (v6 - 2));
    int v13 = (float64x2_t *)((char *)v11 + 8 * (v6 - 2));
    uint64_t v14 = (v6 - 1) >> 1;
    do
    {
      float64x2_t v15 = *v10++;
      *v11++ = vmulq_n_f64(v15, a3);
      --v14;
    }

    while (v14);
    float64x2_t result = vmulq_n_f64(*v12, a3);
    float64x2_t *v13 = result;
  }

  else if ((int)v6 >= 1)
  {
    int v7 = *(double **)(a1 + 32);
    int v8 = *(double **)(a2 + 32);
    do
    {
      double v9 = *v7++;
      result.f64[0] = v9 * a3;
      *v8++ = v9 * a3;
      --v6;
    }

    while (v6);
  }

  return result;
}

uint64_t sub_1002DA0FC(uint64_t *a1, double *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *a1;
  unint64_t v6 = 0x86BCA1AF286BCA1BLL * ((a1[1] - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0x1AF286BCA1AF286LL) {
    sub_10001E11C();
  }
  uint64_t v11 = (uint64_t)(a1 + 2);
  unint64_t v12 = 0x86BCA1AF286BCA1BLL * ((a1[2] - v5) >> 3);
  if (2 * v12 > v7) {
    unint64_t v7 = 2 * v12;
  }
  if (v12 >= 0xD79435E50D7943LL) {
    unint64_t v13 = 0x1AF286BCA1AF286LL;
  }
  else {
    unint64_t v13 = v7;
  }
  int v23 = a1 + 2;
  if (v13) {
    uint64_t v14 = (char *)sub_1001307C0(v11, v13);
  }
  else {
    uint64_t v14 = 0LL;
  }
  std::stringbuf::string_type __p = v14;
  uint64_t v20 = (double *)&v14[152 * v6];
  unint64_t v21 = v20;
  __CLPK_integer v22 = &v14[152 * v13];
  sub_1002DA298(v20, a3, a4, *a2);
  unint64_t v21 = v20 + 19;
  sub_1002D9910(a1, &__p);
  uint64_t v15 = a1[1];
  int v16 = v20;
  __CLPK_integer v17 = v21;
  if (v21 != v20)
  {
    do
    {
      *((void *)v17 - 9) = off_1007AED90;
      *((void *)v17 - 1_Block_object_dispose((const void *)(v1 - 112), 8) = off_1007AED90;
      v17 -= 19;
    }

    while (v17 != v16);
    unint64_t v21 = v16;
  }

  if (__p) {
    operator delete(__p);
  }
  return v15;
}

double *sub_1002DA298(double *a1, uint64_t a2, uint64_t a3, double a4)
{
  *a1 = a4;
  uint64_t v6 = (uint64_t)(a1 + 10);
  sub_1002D9A84((uint64_t)(a1 + 1), a2);
  sub_1002D61D4(v6, a3);
  return a1;
}

void sub_1002DA2E4(_Unwind_Exception *a1)
{
  void *v1 = off_1007AED90;
  _Unwind_Resume(a1);
}

void sub_1002DA2F4(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    unsigned int v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 56;
      unint64_t v7 = v4 - 56;
      do
      {
        int v8 = *(void (***)(char *))v7;
        v7 -= 56;
        (*v8)(v6);
        BOOL v9 = v6 == v2;
        uint64_t v6 = v7;
      }

      while (!v9);
      uint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

uint64_t sub_1002DA380(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1002DA3F4((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1002DA3F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = 0LL;
  uint64_t v11 = a7 - 56;
  while (a3 + v10 != a5)
  {
    uint64_t v12 = v11 + v10;
    v10 -= 56LL;
    sub_1002DA48C(v12, v10 + a3);
  }

  return a6;
}

__n128 sub_1002DA48C(uint64_t a1, uint64_t a2)
{
  result.n128_u64[0] = 0x100000002LL;
  *(void *)(a1 + 24) = 0x100000002LL;
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = &off_1007BCA98;
  if (a1 == a2)
  {
    int v16 = "this != &(A)";
    int v17 = 603;
LABEL_21:
    size_t v18 = "cnmatrix.h";
    uint64_t v19 = "CNMatrix";
LABEL_22:
    __assert_rtn(v19, v18, v17, v16);
  }

  unsigned int v3 = *(_DWORD *)(a2 + 8);
  if (v3 > 2)
  {
    int v16 = "this->max_num_rows_ >= num_rows";
    int v17 = 422;
LABEL_18:
    size_t v18 = "cnmatrixbase.h";
    uint64_t v19 = "SetMatrixSize";
    goto LABEL_22;
  }

  unsigned int v4 = *(_DWORD *)(a2 + 12);
  if (v4 >= 2)
  {
    int v16 = "this->max_num_cols_ >= num_cols";
    int v17 = 423;
    goto LABEL_18;
  }

  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v3;
  *(_DWORD *)(a1 + 12) = v4;
  uint64_t v5 = v4 * v3;
  *(_DWORD *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 20) = v3;
  uint64_t v6 = (_OWORD *)(a1 + 40);
  *(void *)(a1 + 32) = a1 + 40;
  if (*(_DWORD *)(a2 + 8) > 2u)
  {
    int v16 = "this->max_num_rows_ >= A.num_rows_";
    int v17 = 616;
    goto LABEL_21;
  }

  if (*(_DWORD *)(a2 + 12) > 1u)
  {
    int v16 = "this->max_num_cols_ >= A.num_cols_";
    int v17 = 617;
    goto LABEL_21;
  }

  int v7 = *(_DWORD *)(a2 + 16);
  if (v7 > 3)
  {
    uint64_t v10 = (v7 - 2);
    uint64_t v11 = *(__int128 **)(a2 + 32);
    uint64_t v12 = (__n128 *)((char *)v6 + 8 * v10);
    uint64_t v13 = (v7 - 1) >> 1;
    uint64_t v14 = v11;
    do
    {
      __int128 v15 = *v14++;
      *v6++ = v15;
      --v13;
    }

    while (v13);
    __n128 result = *(__n128 *)((char *)v11 + 8 * v10);
    __n128 *v12 = result;
  }

  else if ((_DWORD)v5)
  {
    uint64_t v8 = *(unint64_t **)(a2 + 32);
    do
    {
      unint64_t v9 = *v8++;
      result.n128_u64[0] = v9;
      *(void *)uint64_t v6 = v9;
      uint64_t v6 = (_OWORD *)((char *)v6 + 8);
      --v5;
    }

    while (v5);
  }

  return result;
}

void sub_1002DA5E8(_Unwind_Exception *a1)
{
  void *v1 = off_1007AED90;
  _Unwind_Resume(a1);
}

uint64_t sub_1002DA5FC(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_1002DA608(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t sub_1002DA628(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    unsigned int v4 = *(void (***)(void))(i - 56);
    *(void *)(a1 + 16) = i - 56;
    (*v4)();
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1002DA678(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = 0x6DB6DB6DB6DB6DB7LL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x6DB6DB6DB6DB6DB7LL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x249249249249249LL) {
    unint64_t v9 = 0x492492492492492LL;
  }
  else {
    unint64_t v9 = v5;
  }
  int v17 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)sub_10001FD64(v7, v9);
  }
  else {
    uint64_t v10 = 0LL;
  }
  uint64_t v13 = v10;
  uint64_t v14 = &v10[56 * v4];
  int v16 = &v10[56 * v9];
  sub_1002DA48C((uint64_t)v14, a2);
  __int128 v15 = v14 + 56;
  sub_1002DA380(a1, &v13);
  uint64_t v11 = a1[1];
  sub_1002DA628((uint64_t)&v13);
  return v11;
}

void sub_1002DA780(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *sub_1002DA794(void *result)
{
  *__n128 result = off_1007AED90;
  return result;
}

uint64_t sub_1002DA7A8(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_1002DA7B4(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t sub_1002DA80C(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_1002DA818(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t sub_1002DA83C(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_1002DA848(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

double sub_1002DA868( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a1 == a2) {
    sub_1003A9480();
  }
  if (a1 == a3) {
    sub_1003A94A8();
  }
  if (a1 == a4) {
    sub_1003A94D0();
  }
  if (a1 == a5) {
    sub_1003A94F8();
  }
  if (a1 == a6) {
    sub_1003A9520();
  }
  if (a1 == a7) {
    sub_1003A9548();
  }
  if (a1 == a8) {
    sub_1003A9570();
  }
  if (a1 == a9) {
    sub_1003A9598();
  }
  if (a2 == a3) {
    sub_1003A95C0();
  }
  if (a2 == a4) {
    sub_1003A95E8();
  }
  if (a2 == a5) {
    sub_1003A9610();
  }
  if (a2 == a6) {
    sub_1003A9638();
  }
  if (a2 == a7) {
    sub_1003A9660();
  }
  if (a2 == a8) {
    sub_1003A9688();
  }
  if (a2 == a9) {
    sub_1003A96B0();
  }
  if (a3 == a4) {
    sub_1003A96D8();
  }
  if (a3 == a5) {
    sub_1003A9700();
  }
  if (a3 == a6) {
    sub_1003A9728();
  }
  if (a3 == a7) {
    sub_1003A9750();
  }
  if (a3 == a8) {
    sub_1003A9778();
  }
  if (a3 == a9) {
    sub_1003A97A0();
  }
  if (a4 == a5) {
    sub_1003A97C8();
  }
  if (a4 == a6) {
    sub_1003A97F0();
  }
  if (a4 == a7) {
    sub_1003A9818();
  }
  if (a4 == a8) {
    sub_1003A9840();
  }
  if (a4 == a9) {
    sub_1003A9868();
  }
  if (a5 == a6) {
    sub_1003A9890();
  }
  if (a5 == a7) {
    sub_1003A98B8();
  }
  if (a5 == a8) {
    sub_1003A98E0();
  }
  if (a5 == a9) {
    sub_1003A9908();
  }
  if (a6 == a7) {
    sub_1003A9930();
  }
  if (a6 == a8) {
    sub_1003A9958();
  }
  if (a6 == a9) {
    sub_1003A9980();
  }
  if (a7 == a8) {
    sub_1003A99A8();
  }
  if (a7 == a9) {
    sub_1003A99D0();
  }
  if (a8 == a9) {
    sub_1003A99F8();
  }
  uint64_t v16 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v16 != *(_DWORD *)(a1 + 12)) {
    sub_1003A9CA0();
  }
  unsigned int v17 = *(_DWORD *)(a7 + 24);
  unsigned int v18 = *(_DWORD *)(a8 + 24);
  unsigned int v44 = *(_DWORD *)(a9 + 28) * *(_DWORD *)(a9 + 24);
  sub_1002CBDC8(a2, a1);
  sub_1002CAEDC((_DWORD *)a3, v16, v16);
  sub_1002CAF28(a3, 0.0);
  sub_1002CAEDC((_DWORD *)a4, v16, v16);
  sub_1002CAF28(a4, 0.0);
  sub_1002CAEDC((_DWORD *)a5, v16, v16);
  sub_1002CAF28(a5, 0.0);
  sub_1002CAEDC((_DWORD *)a6, v16, v16);
  sub_1002CAF28(a6, 0.0);
  uint64_t v19 = *(__CLPK_doublereal **)(a3 + 32);
  __wuint64_t i = *(__CLPK_doublereal **)(a4 + 32);
  __scale = *(__CLPK_doublereal **)(a7 + 32);
  __rconde = *(__CLPK_doublereal **)(a8 + 32);
  __woruint64_t k = *(__CLPK_doublereal **)(a9 + 32);
  uint64_t v24 = *(__CLPK_doublereal **)(a2 + 32);
  __CLPK_integer v25 = *(_DWORD *)(a2 + 8);
  int v26 = *(__CLPK_doublereal **)(a5 + 32);
  __CLPK_integer v27 = *(_DWORD *)(a5 + 8);
  qmemcpy(__sense, "NVNB", 4);
  __CLPK_integer __lda = v25;
  __CLPK_integer __n = v16;
  __CLPK_integer __ldvr = v27;
  __CLPK_integer __ldvl = 1;
  unsigned int v47 = v44;
  uint64_t v28 = (cnprint::CNPrinter *)dgeevx_( &__sense[3],  &__sense[2],  &__sense[1],  __sense,  &__n,  v24,  &__lda,  v19,  __wi,  0LL,  &__ldvl,  v26,  &__ldvr,  &v49,  &__ihi,  __scale,  &v45,  __rconde,  &__rconde[(int)v16],  __work,  (__CLPK_integer *)&v47,  0LL,  &v46);
  __CLPK_integer v29 = v46;
  if (v46)
  {
    LOWORD(__n) = 4;
    if (v46 < 0) {
      LOBYTE(__lda) = 5;
    }
    else {
      LOBYTE(__lda) = 4;
    }
    uint64_t v28 = (cnprint::CNPrinter *)cnprint::CNPrinter::Print(&__n, &__lda);
  }

  if (v44 < **(double **)(a9 + 32) && cnprint::CNPrinter::GetLogLevel(v28) <= 1)
  {
    LOWORD(__n) = 4;
    LOBYTE(__lda) = 1;
    cnprint::CNPrinter::Print(&__n, &__lda);
  }

  if (v29) {
    sub_1003A9C78();
  }
  sub_1002CAEDC((_DWORD *)a9, *(_DWORD *)(a9 + 24), *(_DWORD *)(a9 + 28));
  sub_1002CAEDC((_DWORD *)a8, v16, 2);
  sub_1002CAEDC((_DWORD *)a7, v16, 1);
  if ((_DWORD)v16)
  {
    unsigned int v31 = 0;
    uint64_t v32 = *(void *)(a4 + 32);
    uint64_t v33 = *(void *)(a5 + 32);
    uint64_t v34 = *(void *)(a6 + 32);
    do
    {
      double result = *(double *)(v32 + 8LL * v31);
      if (result != 0.0)
      {
        unsigned int v35 = v31 * v16;
        unsigned int v36 = v16 + v31;
        uint64_t v37 = v16;
        do
        {
          *(void *)(v34 + 8LL * v35) = *(void *)(v33 + 8LL * v36);
          *(double *)(v34 + 8LL * v36) = -*(double *)(v33 + 8LL * v36);
          double result = *(double *)(v33 + 8LL * v35++);
          *(double *)(v33 + 8LL * v36++) = result;
          --v37;
        }

        while (v37);
        ++v31;
      }

      ++v31;
    }

    while (v31 < v16);
    if (v16 >= 2)
    {
      uint64_t v38 = *(void *)(a3 + 32);
      uint64_t v39 = *(void *)(a4 + 32);
      int v40 = v16 - 1;
      uint64_t v41 = (double *)(v39 + 8);
      uint64_t v42 = (void *)(v38 + 8);
      int v43 = v16 + 1;
      do
      {
        *(void *)(v38 + 8LL * v43) = *v42;
        double result = *v41;
        *(double *)(v39 + 8LL * v43) = *v41;
        *v42++ = 0LL;
        *v41++ = 0.0;
        v43 += v16 + 1;
        --v40;
      }

      while (v40);
    }
  }

  return result;
}

void *sub_1002DAE38(void *result)
{
  *double result = off_1007AED90;
  return result;
}

uint64_t sub_1002DAE4C(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_1002DAE58(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t sub_1002DAEA4()
{
  qword_1007FE8C8 = 0LL;
  qword_1007FE8D0 = 0LL;
  qword_1007FE8D8 = 0LL;
  uint64_t v0 = operator new(0x40uLL);
  qword_1007FE8D0 = (uint64_t)(v0 + 4);
  qword_1007FE8D8 = (uint64_t)(v0 + 4);
  _OWORD *v0 = xmmword_10042DF30;
  v0[1] = unk_10042DF40;
  v0[2] = xmmword_10042DF50;
  v0[3] = unk_10042DF60;
  qword_1007FE8C8 = (uint64_t)v0;
  __cxa_atexit((void (*)(void *))sub_100028CC4, &qword_1007FE8C8, (void *)&_mh_execute_header);
  qword_1007FE8E8 = 0LL;
  unk_1007FE8F0 = 0LL;
  qword_1007FE8E0 = 0LL;
  uint64_t v1 = operator new(0x10uLL);
  qword_1007FE8E8 = (uint64_t)(v1 + 1);
  unk_1007FE8F0 = v1 + 1;
  _OWORD *v1 = xmmword_10042DF70;
  qword_1007FE8E0 = (uint64_t)v1;
  return __cxa_atexit((void (*)(void *))sub_100028CC4, &qword_1007FE8E0, (void *)&_mh_execute_header);
}

void sub_1002DAF68(uint64_t a1, double a2, double a3)
{
  *(_BYTE *)a1 = 0;
  *(double *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = a3;
  *(double *)(a1 + 16) = a2;
  if (a3 <= 0.0) {
    sub_1003A9CC8();
  }
  if (a2 <= 0.0) {
    sub_1003A9CF0();
  }
  *(double *)(a1 + 24) = 1.0 / a2 / (1.0 / a2 + 1.0 / (a3 * 6.28318531));
  sub_1002DB074(a1);
  *(_BYTE *)a1 = 1;
  uint64_t v6 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 134218240;
    double v8 = a2;
    __int16 v9 = 2048;
    double v10 = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#spatialGesturesPredictor #LPF configured with fs = %f and fc = %f",  (uint8_t *)&v7,  0x16u);
  }

void sub_1002DB074(uint64_t a1)
{
  *(_BYTE *)(a1 + 1) = 0;
  *(void *)(a1 + 32) = 0LL;
  uint64_t v1 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "#spatialGesturesPredictor #LPF reset", v2, 2u);
  }

uint64_t sub_1002DB0E0(uint64_t a1, __int128 *a2, _DWORD *a3)
{
  *(void *)a1 = off_1007BCCD0;
  if (*((char *)a2 + 23) < 0)
  {
    sub_1000063A8((_BYTE *)(a1 + 8), *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v6 = *a2;
    *(void *)(a1 + 24) = *((void *)a2 + 2);
    *(_OWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v6;
  }

  __int128 v7 = *(__int128 *)((char *)a2 + 24);
  uint64_t v8 = *((void *)a2 + 5);
  *(void *)(a1 + 56) = 0LL;
  __int16 v9 = (void *)(a1 + 56);
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v8;
  *(_OWORD *)(a1 + 32) = v7;
  *(void *)(a1 + 64) = 0LL;
  double v10 = (os_log_s *)(id)qword_1008000A0;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = *a3 ? "PredictorSecondary_GestureClassifier" : "PredictorPrimary_GestureClassifier";
    sub_1000065CC(&__p, v11);
    uint64_t v12 = (__p.st_gid & 0x80000000) == 0 ? &__p : *(stat **)&__p.st_dev;
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v32 = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#spatialGesturesPredictor Configuring GestureClassifier for Predictor %s",  buf,  0xCu);
    if (SHIBYTE(__p.st_gid) < 0) {
      operator delete(*(void **)&__p.st_dev);
    }
  }

  if (*a3 == 1)
  {
    uint64_t v20 = operator new(8uLL);
    *uint64_t v20 = &off_1007BCC68;
    uint64_t v21 = *v9;
    void *v9 = v20;
    if (v21) {
      (*(void (**)(uint64_t))(*(void *)v21 + 8LL))(v21);
    }
    __CLPK_integer v22 = (os_log_s *)(id)qword_1008000A0;
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      int v23 = (*(uint64_t (**)(void))(*(void *)*v9 + 24LL))(*v9);
      __p.st_dev = 67109120;
      *(_DWORD *)&__p.st_mode = v23;
      _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "#spatialGesturesPredictor Dim of number of inputs to the model = %d",  (uint8_t *)&__p,  8u);
    }

    uint64_t v19 = (os_log_s *)(id)qword_1008000A0;
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_29;
    }
    goto LABEL_28;
  }

  if (*a3) {
    goto LABEL_30;
  }
  uint64_t v13 = operator new(8uLL);
  void *v13 = &off_1007BCE90;
  uint64_t v14 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = v13;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 8LL))(v14);
  }
  __int128 v15 = operator new(8uLL);
  void *v15 = &off_1007BCC00;
  uint64_t v16 = *v9;
  void *v9 = v15;
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 8LL))(v16);
  }
  unsigned int v17 = (os_log_s *)(id)qword_1008000A0;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    int v18 = (*(uint64_t (**)(void))(*(void *)*v9 + 24LL))(*v9);
    __p.st_dev = 67109120;
    *(_DWORD *)&__p.st_mode = v18;
    _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "#spatialGesturesPredictor Dim of number of inputs to the model = %d",  (uint8_t *)&__p,  8u);
  }

  uint64_t v19 = (os_log_s *)(id)qword_1008000A0;
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
LABEL_28:
    int v24 = (*(uint64_t (**)(void))(*(void *)*v9 + 32LL))(*v9);
    __p.st_dev = 67109120;
    *(_DWORD *)&__p.st_mode = v24;
    _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "#spatialGesturesPredictor Dim of DeviceMotionBuffer = %d",  (uint8_t *)&__p,  8u);
  }

void sub_1002DB5B4(_Unwind_Exception *a1)
{
  uint64_t v6 = *(void *)(v1 + 64);
  *(void *)(v1 + 64) = 0LL;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
  }
  uint64_t v7 = *v4;
  *uint64_t v4 = 0LL;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
  }
  _Unwind_Resume(a1);
}

void sub_1002DB658(uint64_t a1@<X0>, _BYTE *a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, uint64_t a5@<X8>)
{
  __int16 v9 = (os_log_s *)(id)qword_1008000A0;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    if (*(_DWORD *)(a3 + 32)) {
      double v10 = "PredictorSecondary_GestureClassifier";
    }
    else {
      double v10 = "PredictorPrimary_GestureClassifier";
    }
    sub_1000065CC(v63, v10);
    sub_1003A9E3C((char *)v63, buf, v9);
  }

  sub_1002DBDB4(a1, (uint64_t)a2, a3);
  uint64_t v62 = 0LL;
  memset(v61, 0, sizeof(v61));
  uint64_t v54 = (uint64_t)a2;
  if (*(_DWORD *)(a3 + 32))
  {
    uint64_t v64 = 1LL;
    uint64_t v65 = (*(int (**)(void))(**(void **)(a1 + 56) + 24LL))(*(void *)(a1 + 56));
    uint64_t v66 = (*(int (**)(void))(**(void **)(a1 + 56) + 16LL))(*(void *)(a1 + 56));
    int v11 = (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 24LL))(*(void *)(a1 + 56));
    int v12 = (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 16LL))(*(void *)(a1 + 56));
    sub_1002DF884(&__p, v12 * v11);
    uint64_t v13 = a2 + 15056;
    uint64_t v14 = (float *)__p;
    if (!a2[15056]) {
      __assert_rtn( "makePrediction",  "NRBYSpatialGesturePredictor.mm",  182,  "inputObject.deviceMotionBufferSecondary.has_value()");
    }
    uint64_t v15 = 0LL;
    uint64_t v16 = a2 + 10656;
    while (1)
    {
      int v17 = (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 24LL))(*(void *)(a1 + 56));
      if (!*v13) {
        sub_100006080();
      }
      float v18 = *(double *)&v16[8 * v15];
      v14[v15++] = v18;
    }

    uint64_t v19 = "input_1";
  }

  else
  {
    uint64_t v64 = 1LL;
    uint64_t v65 = (*(int (**)(void))(**(void **)(a1 + 56) + 24LL))(*(void *)(a1 + 56));
    uint64_t v66 = 9LL;
    uint64_t v67 = (int)((*(uint64_t (**)(void))(**(void **)(a1 + 56) + 16LL))(*(void *)(a1 + 56)) + 2);
    int v20 = (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 24LL))(*(void *)(a1 + 56));
    uint64_t v53 = a3;
    unint64_t v21 = (int)(9 * v20
                  * ((*(uint64_t (**)(void))(**(void **)(a1 + 56) + 16LL))(*(void *)(a1 + 56)) + 2));
    sub_1002DF884(&__p, v21);
    __CLPK_integer v22 = a2 + 9368;
    uint64_t v14 = (float *)__p;
    if (!a2[9368] || !a2[9544]) {
      __assert_rtn( "makePrediction",  "NRBYSpatialGesturePredictor.mm",  153,  "inputObject.deviceMotionBufferAfterProcessingPrimary.has_value() and inputObject.deltaUwbBufferAfterProcessingPr imary.has_value()");
    }
    unint64_t v52 = v21;
    int v51 = a4;
    int v23 = 0;
    uint64_t v24 = 0LL;
    uint64_t v25 = 0LL;
    int v26 = a2 + 4688;
    __CLPK_integer v27 = a2 + 9464;
    while (v24 < (*(int (**)(void))(**(void **)(a1 + 56) + 24LL))(*(void *)(a1 + 56)))
    {
      int v28 = 0;
      uint64_t v56 = v24;
      uint64_t v29 = 2 * v24;
      int v57 = v23;
      do
      {
        for (int i = 0; i < (*(int (**)(void))(**(void **)(a1 + 56) + 16LL))(*(void *)(a1 + 56)); ++i)
        {
          int v31 = (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 16LL))(*(void *)(a1 + 56));
          if (!*v22) {
            sub_100006080();
          }
          float v32 = *(double *)&v26[8 * i + 8 * v23 * v31];
          v14[v25++] = v32;
        }

        if (!v22[176]) {
          sub_100006080();
        }
        uint64_t v33 = 0LL;
        char v34 = 1;
        do
        {
          char v35 = v34;
          float v36 = *(double *)&v27[8 * (v33 | v29)];
          v14[v25++] = v36;
          uint64_t v33 = 1LL;
          char v34 = 0;
        }

        while ((v35 & 1) != 0);
        ++v28;
        ++v23;
      }

      while (v28 != 9);
      uint64_t v24 = v56 + 1;
      int v23 = v57 + 9;
    }

    if (v25 != v52) {
      __assert_rtn("makePrediction", "NRBYSpatialGesturePredictor.mm", 169, "m == flattenedVectorsize");
    }
    uint64_t v19 = "input_2";
    a4 = v51;
    a3 = v53;
  }

  *(void *)&v61[0] = v14;
  LODWORD(v62) = 65568;
  if (espresso_network_bind_buffer( *(void *)(a1 + 80),  *(void *)(a1 + 88),  v19,  v61,  0x10000LL,  0x20000LL,  0x10000LL)) {
    __assert_rtn("makePrediction", "NRBYSpatialGesturePredictor.mm", 197, "status == ESPRESSO_STATUS_SUCCESS");
  }
  if (espresso_network_bind_buffer( *(void *)(a1 + 80),  *(void *)(a1 + 88),  "Identity",  &v64,  0x20000LL,  0x10000LL,  0x10000LL))
  {
    int v50 = 202;
    goto LABEL_65;
  }

  if (espresso_plan_execute_sync(*(void *)(a1 + 96)))
  {
    int v50 = 206;
LABEL_65:
    __assert_rtn("makePrediction", "NRBYSpatialGesturePredictor.mm", v50, "status == ESPRESSO_STATUS_SUCCESS");
  }

  uint64_t v37 = 0LL;
  stat __p = 0LL;
  double v59 = 0LL;
  int v60 = 0LL;
  if (!*(_DWORD *)(a3 + 32))
  {
    uint64_t v38 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
      sub_1003A9D9C((uint64_t)&v64, v38);
    }
    uint64_t v37 = v59;
  }

  for (uint64_t j = 0LL; j != 3; ++j)
  {
    uint64_t v40 = v64;
    if (v37 >= v60)
    {
      uint64_t v42 = (char *)__p;
      uint64_t v43 = (v37 - (_BYTE *)__p) >> 2;
      unint64_t v44 = v43 + 1;
      uint64_t v45 = v60 - (_BYTE *)__p;
      if ((v60 - (_BYTE *)__p) >> 1 > v44) {
        unint64_t v44 = v45 >> 1;
      }
      else {
        unint64_t v46 = v44;
      }
      if (v46)
      {
        unsigned int v47 = (char *)sub_100031724((uint64_t)&v60, v46);
        uint64_t v42 = (char *)__p;
        uint64_t v37 = v59;
      }

      else
      {
        unsigned int v47 = 0LL;
      }

      uint64_t v48 = &v47[4 * v43];
      *(_DWORD *)uint64_t v48 = *(_DWORD *)(v40 + 4 * j);
      uint64_t v41 = v48 + 4;
      while (v37 != v42)
      {
        int v49 = *((_DWORD *)v37 - 1);
        v37 -= 4;
        *((_DWORD *)v48 - 1) = v49;
        v48 -= 4;
      }

      stat __p = v48;
      double v59 = v41;
      int v60 = &v47[4 * v46];
      if (v42) {
        operator delete(v42);
      }
    }

    else
    {
      *(_DWORD *)uint64_t v37 = *(_DWORD *)(v64 + 4 * j);
      uint64_t v41 = v37 + 4;
    }

    double v59 = v41;
    uint64_t v37 = v41;
  }

  ++*(_DWORD *)(a3 + 8);
  sub_1002DC398(a1, v54, (float **)&__p, a3, a4, a5);
  if (__p)
  {
    double v59 = (char *)__p;
    operator delete(__p);
  }

  if (v14) {
    operator delete(v14);
  }
}

void sub_1002DBD2C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
}

void sub_1002DBDB4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003A9FC4();
  }
  if (!*(_DWORD *)(a3 + 32))
  {
    uint64_t v6 = (_BYTE *)(a2 + 4680);
    if (!*(_BYTE *)(a2 + 4680)) {
      sub_1003A9EAC();
    }
    uint64_t v7 = (_BYTE *)(a2 + 9368);
    if (!*(_BYTE *)(a2 + 9456)) {
      sub_1003A9ED4();
    }
    if (!*(_BYTE *)(a2 + 10632)) {
      sub_1003A9EFC();
    }
    if (*(_BYTE *)(a3 + 4))
    {
      bzero(__dst, 0x1248uLL);
      __int128 v49 = 0u;
      __int128 v50 = 0u;
      __int128 v47 = 0u;
      __int128 v48 = 0u;
      __int128 v46 = 0u;
      int v8 = 9 * (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 16LL))(*(void *)(a1 + 56));
      LODWORD(v9) = (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 32LL))(*(void *)(a1 + 56)) - v8;
      if ((int)v9 < (*(int (**)(void))(**(void **)(a1 + 56) + 32LL))(*(void *)(a1 + 56)))
      {
        uint64_t v9 = (int)v9;
        do
        {
          (*(void (**)(double *__return_ptr))(**(void **)(a1 + 64) + 24LL))(v44);
          double v10 = v44[2
                  * ((int)v9 % (*(int (**)(void))(**(void **)(a1 + 56) + 16LL))(*(void *)(a1 + 56)))];
          (*(void (**)(void *__return_ptr))(**(void **)(a1 + 64) + 24LL))(v43);
          int v11 = (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 16LL))(*(void *)(a1 + 56));
          if (!*v6) {
            goto LABEL_55;
          }
          __dst[v9] = (*(double *)(a2 + 8 * v9) - v10) / *(double *)&v43[2 * ((int)v9 % v11) + 1];
        }

        while (++v9 < (*(int (**)(void))(**(void **)(a1 + 56) + 32LL))(*(void *)(a1 + 56)));
      }

      LODWORD(v12) = (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 40LL))(*(void *)(a1 + 56)) - 2;
      if ((int)v12 < (*(int (**)(void))(**(void **)(a1 + 56) + 40LL))(*(void *)(a1 + 56)))
      {
        uint64_t v12 = (int)v12;
        do
        {
          v44[0] = (*(double (**)(void))(**(void **)(a1 + 64) + 32LL))(*(void *)(a1 + 64));
          uint64_t v45 = v13;
          int v14 = v12 & 1;
          double v15 = v44[2 * v14];
          (*(void (**)(void))(**(void **)(a1 + 64) + 32LL))(*(void *)(a1 + 64));
          if (!*(_BYTE *)(a2 + 9456)) {
            goto LABEL_55;
          }
          double v16 = *(double *)(a2 + 9376 + 8 * v12) - v15;
          *((double *)&v46 + v12++) = v16
                                    / (*(double (**)(void))(**(void **)(a1 + 64) + 16LL))(*(void *)(a1 + 64));
        }

        while (v12 < (*(int (**)(void))(**(void **)(a1 + 56) + 40LL))(*(void *)(a1 + 56)));
      }

      *(_BYTE *)(a3 + 4) = 0;
      goto LABEL_41;
    }

    if (!*v7) {
      sub_1003A9F24();
    }
    if (!*(_BYTE *)(a2 + 9544)) {
      sub_1003A9F4C();
    }
    memcpy(__dst, (const void *)(a2 + 4688), 0x1248uLL);
    __int128 v17 = *(_OWORD *)(a2 + 9512);
    __int128 v48 = *(_OWORD *)(a2 + 9496);
    __int128 v49 = v17;
    __int128 v50 = *(_OWORD *)(a2 + 9528);
    __int128 v18 = *(_OWORD *)(a2 + 9480);
    __int128 v46 = *(_OWORD *)(a2 + 9464);
    __int128 v47 = v18;
    int v19 = 9 * (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 16LL))(*(void *)(a1 + 56));
    if (v19 >= (*(int (**)(void))(**(void **)(a1 + 56) + 32LL))(*(void *)(a1 + 56)))
    {
LABEL_25:
      LODWORD(v22) = (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 32LL))(*(void *)(a1 + 56)) - v19;
      if ((int)v22 >= (*(int (**)(void))(**(void **)(a1 + 56) + 32LL))(*(void *)(a1 + 56)))
      {
LABEL_29:
        if (!*(_BYTE *)(a2 + 10648)) {
          sub_1003A9F74();
        }
        double v25 = *(double *)(a2 + 10640);
        double v26 = *(double *)(a3 + 24);
        if ((*(int (**)(void))(**(void **)(a1 + 56) + 40LL))(*(void *)(a1 + 56)) < 3)
        {
LABEL_34:
          int v30 = (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 40LL))(*(void *)(a1 + 56)) - 2;
          if (v30 >= (*(int (**)(void))(**(void **)(a1 + 56) + 40LL))(*(void *)(a1 + 56)))
          {
LABEL_41:
            int v39 = *v7;
            memcpy((void *)(a2 + 4688), __dst, 0x1248uLL);
            if (!v39) {
              *uint64_t v7 = 1;
            }
            int v40 = *(unsigned __int8 *)(a2 + 9544);
            __int128 v41 = v49;
            *(_OWORD *)(a2 + 9496) = v48;
            *(_OWORD *)(a2 + 9512) = v41;
            *(_OWORD *)(a2 + 952_Block_object_dispose((const void *)(v1 - 112), 8) = v50;
            __int128 v42 = v47;
            *(_OWORD *)(a2 + 9464) = v46;
            *(_OWORD *)(a2 + 9480) = v42;
            if (!v40) {
              *(_BYTE *)(a2 + 9544) = 1;
            }
            if (!*(_BYTE *)(a2 + 10648)) {
              sub_1003A9F9C();
            }
            *(void *)(a3 + 24) = *(void *)(a2 + 10640);
            return;
          }

          uint64_t v31 = v30;
          double v32 = v25 - v26;
          uint64_t v33 = (double *)(a2 + 8LL * v30 + 9376);
          while (1)
          {
            v44[0] = (*(double (**)(void))(**(void **)(a1 + 64) + 40LL))(*(void *)(a1 + 64));
            uint64_t v45 = v34;
            int v35 = (int)v31 >= 0 ? v31 & 1 : -(v31 & 1);
            double v36 = v44[2 * v35];
            (*(void (**)(void))(**(void **)(a1 + 64) + 40LL))(*(void *)(a1 + 64));
            v43[1] = v37;
            v43[3] = v38;
            if (!*(_BYTE *)(a2 + 9456)) {
              break;
            }
            *((double *)&v46 + v31++) = ((*v33 - *(v33 - 2)) / v32 - v36) / *(double *)&v43[2 * v35 + 1];
            ++v33;
          }
        }

        else
        {
          uint64_t v27 = 0LL;
          while (*(_BYTE *)(a2 + 9544))
          {
            *((void *)&v46 + v27) = *(void *)(a2 + 9480 + 8 * v27);
            int v28 = (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 40LL))(*(void *)(a1 + 56));
            uint64_t v29 = v27 + 3;
            ++v27;
            if (v29 >= v28) {
              goto LABEL_34;
            }
          }
        }
      }

      else
      {
        uint64_t v22 = (int)v22;
        while (1)
        {
          (*(void (**)(double *__return_ptr))(**(void **)(a1 + 64) + 24LL))(v44);
          double v23 = v44[2
                  * ((int)v22 % (*(int (**)(void))(**(void **)(a1 + 56) + 16LL))(*(void *)(a1 + 56)))];
          (*(void (**)(void *__return_ptr))(**(void **)(a1 + 64) + 24LL))(v43);
          int v24 = (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 16LL))(*(void *)(a1 + 56));
          if (!*v6) {
            break;
          }
          __dst[v22] = (*(double *)(a2 + 8 * v22) - v23) / *(double *)&v43[2 * ((int)v22 % v24) + 1];
        }
      }
    }

    else
    {
      uint64_t v20 = v19;
      unint64_t v21 = __dst;
      while (*v7)
      {
        *v21++ = *(double *)(a2 + 4688 + 8 * v20);
      }
    }

void sub_1002DC398( uint64_t a1@<X0>, uint64_t a2@<X1>, float **a3@<X2>, uint64_t a4@<X3>, int a5@<W4>, uint64_t a6@<X8>)
{
  int v7 = *(_DWORD *)(a4 + 32);
  if (v7 == 1)
  {
    float v16 = (*a3)[1];
    *(_DWORD *)a6 = **a3 <= v16;
    *(double *)(a6 + _Block_object_dispose((const void *)(v1 - 112), 8) = v16;
    *(_BYTE *)(a6 + 16) = 0;
    return;
  }

  if (!v7)
  {
    uint64_t v12 = *a3;
    float v13 = **a3;
    float v14 = (*a3)[1];
    if (v13 > v14 && v13 > v12[2])
    {
      switch(a5)
      {
        case 0:
        case 2:
        case 4:
          sub_1003AA070();
        case 1:
          int v15 = 0;
          *(void *)(a4 + 16) = 0LL;
          break;
        case 3:
          int v15 = 0;
          double v60 = *(double *)(a4 + 16) + -0.0799999982;
          if (v60 < 0.0) {
            double v60 = 0.0;
          }
          *(double *)(a4 + 16) = v60;
          break;
        default:
          int v15 = 0;
          break;
      }

      goto LABEL_23;
    }

    float v17 = v12[2];
    if (v14 <= v13 || ((float)(v14 - v13) > 0.03 ? (BOOL v18 = v14 <= v17) : (BOOL v18 = 1), v18))
    {
      int v15 = 0;
      BOOL v19 = v17 <= v13 || v17 <= v14;
      if (v19 || (float)(v17 - v13) <= 0.03)
      {
LABEL_23:
        int v24 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v25 = *(void *)(a4 + 16);
          *(_DWORD *)__int128 buf = 134217984;
          *(void *)&uint8_t buf[4] = v25;
          _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "#spatialGesturesPredictor #probabilities hysteresisProb = %f",  buf,  0xCu);
        }

        if (!*(_BYTE *)(a2 + 9456)) {
          sub_1003A9FF0();
        }
        double v73 = 0.0;
        unsigned __int8 v26 = atomic_load((unsigned __int8 *)&qword_1007FE900);
        if ((v26 & 1) == 0 && __cxa_guard_acquire(&qword_1007FE900))
        {
          dword_1007FE8F8 = (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 24LL))(*(void *)(a1 + 56));
          __cxa_guard_release(&qword_1007FE900);
        }

        sub_1002DF8F8(&v71, dword_1007FE8F8);
        sub_1002DF8F8(&v69, dword_1007FE8F8);
        int v27 = dword_1007FE8F8;
        if (dword_1007FE8F8 < 1) {
          goto LABEL_80;
        }
        if (!*(_BYTE *)(a2 + 9456)) {
          sub_100006080();
        }
        uint64_t v28 = 0LL;
        uint64_t v29 = v71;
        int v30 = v69;
        uint64_t v31 = 16LL * dword_1007FE8F8;
        do
        {
          *v29++ = *(void *)(a2 + v28 + 9376);
          *v30++ = *(void *)(a2 + v28 + 9384);
          v28 += 16LL;
        }

        while (v31 != v28);
        if (v27 < 1) {
LABEL_80:
        }
          __assert_rtn("_refineModelPrediction", "NRBYSpatialGesturePredictor.mm", 392, "_dimInputsModel > 0");
        sub_1002DF8F8(&v67, (v27 - 1));
        sub_1002DF8F8(__p, dword_1007FE8F8 - 1LL);
        double v32 = (double *)v67;
        if (dword_1007FE8F8 >= 2)
        {
          uint64_t v33 = (double *)__p[0];
          uint64_t v34 = dword_1007FE8F8 - 1LL;
          int v35 = (double *)((char *)v69 + 8);
          double v36 = (double *)((char *)v71 + 8);
          uint64_t v37 = (double *)v67;
          do
          {
            *v37++ = *(v36 - 1) - *v36;
            *v33++ = *v35 - *(v35 - 1);
            ++v35;
            ++v36;
            --v34;
          }

          while (v34);
        }

        if (v68 == v32)
        {
          int v39 = 0;
          int v38 = 0;
        }

        else
        {
          int v38 = 0;
          int v39 = 0;
          unint64_t v40 = v68 - v32;
          __int128 v41 = (double *)__p[0];
          if (v40 <= 1) {
            unint64_t v40 = 1LL;
          }
          do
          {
            double v42 = *v32++;
            if (v42 > 0.0) {
              ++v38;
            }
            double v43 = *v41++;
            if (v43 > 0.0) {
              ++v39;
            }
            --v40;
          }

          while (v40);
        }

        switch(a5)
        {
          case 0:
          case 2:
          case 4:
            __assert_rtn("_refineModelPrediction", "NRBYSpatialGesturePredictor.mm", 444, "0");
          case 1:
            if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
              sub_1003AA044();
            }
            double v44 = *(double *)(a4 + 16);
            if ((v15 & 1) != 0 || v44 > *(double *)(a1 + 32) * 0.5)
            {
              double v45 = (*(double (**)(void))(**(void **)(a1 + 56) + 48LL))(*(void *)(a1 + 56));
              double v46 = v45 * (double)v38
                  + v44 * 0.55
              double v73 = v46;
              __int128 v47 = (os_log_s *)qword_1008000A0;
              if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)__int128 buf = 134217984;
                *(double *)&uint8_t buf[4] = v46;
                _os_log_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_DEFAULT,  "#spatialGesturesPredictor #probabilities with range and rssi derivatives SinglePredictor handoffConfidence = %f",  buf,  0xCu);
              }

              sub_1002DCB98(a1, a2, v15, &v73, a4, 1, (uint64_t)buf, v48);
LABEL_58:
              *(_OWORD *)a6 = *(_OWORD *)buf;
              *(void *)(a6 + 16) = *(void *)&buf[16];
LABEL_59:
              if (v15)
              {
                uint64_t v54 = (os_log_s *)qword_1008000A0;
                if (!os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_70;
                }
                uint64_t v55 = *(v72 - 1);
                uint64_t v56 = *(v70 - 1);
                uint64_t v57 = *(void *)(a4 + 16);
                uint64_t v58 = *(void *)(a6 + 8);
                *(_DWORD *)__int128 buf = 134218752;
                *(void *)&uint8_t buf[4] = v55;
                *(_WORD *)&_BYTE buf[12] = 2048;
                *(void *)&buf[14] = v56;
                *(_WORD *)&buf[22] = 2048;
                uint64_t v75 = v57;
                __int16 v76 = 2048;
                uint64_t v77 = v58;
                double v59 = "#spatialGesturesPredictor #evaluation distance = %f, rssi = %f, prediction = Handoff, hysteresis p"
                      "rob = %f, handoff confidence = %f";
                goto LABEL_69;
              }
            }

            else
            {
              double v61 = v73;
              *(_DWORD *)a6 = 0;
              *(double *)(a6 + _Block_object_dispose((const void *)(v1 - 112), 8) = v61;
              *(_BYTE *)(a6 + 16) = 0;
            }

            uint64_t v54 = (os_log_s *)qword_1008000A0;
            if (!os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_70;
            }
            uint64_t v62 = *(v72 - 1);
            uint64_t v63 = *(v70 - 1);
            uint64_t v64 = *(void *)(a4 + 16);
            uint64_t v65 = *(void *)(a6 + 8);
            *(_DWORD *)__int128 buf = 134218752;
            *(void *)&uint8_t buf[4] = v62;
            *(_WORD *)&_BYTE buf[12] = 2048;
            *(void *)&buf[14] = v63;
            *(_WORD *)&buf[22] = 2048;
            uint64_t v75 = v64;
            __int16 v76 = 2048;
            uint64_t v77 = v65;
            double v59 = "#spatialGesturesPredictor #evaluation distance = %f, rssi = %f, prediction = Other, hysteresis prob = "
                  "%f, handoff confidence = %f";
LABEL_69:
            _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, v59, buf, 0x2Au);
LABEL_70:
            *(_DWORD *)a4 = *(_DWORD *)a6;
            if (__p[0])
            {
              __p[1] = __p[0];
              operator delete(__p[0]);
            }

            if (v67)
            {
              char v68 = (double *)v67;
              operator delete(v67);
            }

            if (v69)
            {
              char v70 = v69;
              operator delete(v69);
            }

            if (v71)
            {
              __int128 v72 = v71;
              operator delete(v71);
            }

            break;
          case 3:
            if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
              sub_1003AA018();
            }
            double v49 = *(double *)(a4 + 16);
            double v50 = (*(double (**)(void))(**(void **)(a1 + 56) + 48LL))(*(void *)(a1 + 56));
            double v51 = v50 * (double)v38
                + v49 * 0.55
                + (*(double (**)(void))(**(void **)(a1 + 56) + 56LL))(*(void *)(a1 + 56)) * (double)v39;
            double v73 = v51;
            unint64_t v52 = (os_log_s *)qword_1008000A0;
            if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = 134217984;
              *(double *)&uint8_t buf[4] = v51;
              _os_log_impl( (void *)&_mh_execute_header,  v52,  OS_LOG_TYPE_DEFAULT,  "#spatialGesturesPredictor #probabilities with range and rssi derivatives DualAnchorAntennaPredictor hand offConfidence = %f",  buf,  0xCu);
            }

            sub_1002DCB98(a1, a2, v15, &v73, a4, 3, (uint64_t)buf, v53);
            goto LABEL_58;
          default:
            goto LABEL_59;
        }

        return;
      }

      double v20 = v17;
      double v21 = *(double *)(a4 + 16);
      double v22 = 0.0799999982;
    }

    else
    {
      double v20 = v14;
      double v21 = *(double *)(a4 + 16);
      double v22 = 0.100000001;
    }

    double v23 = v21 + v20 * v22;
    if (v23 > 1.0) {
      double v23 = 1.0;
    }
    *(double *)(a4 + 16) = v23;
    int v15 = 1;
    goto LABEL_23;
  }

void sub_1002DCAB4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20)
{
}

double sub_1002DCB44(double *a1, int a2)
{
  switch(a2)
  {
    case 0:
    case 2:
      sub_1003AA098();
    case 1:
      uint64_t v2 = a1 + 4;
      goto LABEL_5;
    case 3:
      uint64_t v2 = a1 + 5;
      goto LABEL_5;
    case 4:
      uint64_t v2 = a1 + 6;
LABEL_5:
      double result = *v2;
      break;
    default:
      return result;
  }

  return result;
}

void sub_1002DCB98( uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, double *a4@<X3>, uint64_t a5@<X4>, int a6@<W5>, uint64_t a7@<X8>, double a8@<D1>)
{
  int v10 = a3;
  switch(a6)
  {
    case 0:
    case 2:
    case 4:
      sub_1003AA0C0();
    case 1:
      float v14 = (double *)(a1 + 32);
      goto LABEL_4;
    case 3:
      float v14 = (double *)(a1 + 40);
LABEL_4:
      a8 = *v14;
      break;
    default:
      break;
  }

  if (a3 == 1 || (double v15 = *a4, *a4 > a8))
  {
    int v16 = (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 24LL))(*(void *)(a1 + 56));
    sub_1002DF8F8(&v39, 9 * v16);
    int v17 = *(_DWORD *)(a5 + 32);
    if (v17)
    {
      if (v17 != 1) {
        goto LABEL_9;
      }
      double v36 = "0";
      int v37 = 500;
    }

    else
    {
      if (*(_BYTE *)(a2 + 4680))
      {
        for (uint64_t i = 0LL;
              i < (int)(9 * (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 24LL))(*(void *)(a1 + 56)));
              ++i)
        {
          if (!*(_BYTE *)(a2 + 4680)) {
            sub_100006080();
          }
          int v24 = (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 16LL))(*(void *)(a1 + 56));
          v39[i] = *(double *)(a2 + 8LL * v24 * (int)i);
        }

void sub_1002DCE04( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002DCE28(uint64_t a1)
{
  *(void *)a1 = off_1007BCCD0;
  if (espresso_plan_destroy(*(void *)(a1 + 96)))
  {
    int v6 = 534;
    goto LABEL_14;
  }

  if (espresso_context_destroy(*(void *)(a1 + 104)))
  {
    int v6 = 537;
LABEL_14:
    __assert_rtn("~GestureClassifier", "NRBYSpatialGesturePredictor.mm", v6, "status == ESPRESSO_STATUS_SUCCESS");
  }

  uint64_t v2 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v7 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "#spatialGesturesPredictor Deleted model network parameters",  v7,  2u);
  }

  uint64_t v3 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  uint64_t v4 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  return a1;
}

void sub_1002DCF2C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1002DCE28(a1);
  operator delete(v1);
}

uint64_t sub_1002DCF40(uint64_t a1, uint64_t *a2, int a3)
{
  uint64_t v5 = 0LL;
  *(void *)a1 = off_1007BCCF8;
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  *(_DWORD *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 2_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
  *(_DWORD *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0LL;
  uint64_t v6 = a1 + 64;
  do
  {
    uint64_t v7 = a1 + v5;
    *(_WORD *)(v7 + 64) = 0;
    *(void *)(v7 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
    *(void *)(v7 + 96) = 0LL;
    v5 += 40LL;
  }

  while (v5 != 360);
  for (uint64_t i = 0LL; i != 80; i += 40LL)
  {
    uint64_t v9 = a1 + i;
    *(_WORD *)(v9 + 424) = 0;
    *(void *)(v9 + 44_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
    *(void *)(v9 + 456) = 0LL;
  }

  *(_OWORD *)(a1 + 9880) = 0u;
  *(_OWORD *)(a1 + 9896) = 0u;
  *(_OWORD *)(a1 + 9864) = 0u;
  *(_OWORD *)(a1 + 11160) = 0u;
  *(_OWORD *)(a1 + 11176) = 0u;
  *(_OWORD *)(a1 + 11192) = 0u;
  *(_BYTE *)(a1 + 1120_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  sub_100018E60((void *)(a1 + 8), a2);
  bzero((void *)(a1 + 10080), 0x438uLL);
  *(_DWORD *)(a1 + 56) = 0;
  bzero((void *)(a1 + 504), 0x2490uLL);
  uint64_t v10 = 0LL;
  *(_OWORD *)(a1 + 10040) = 0u;
  *(_OWORD *)(a1 + 10056) = 0u;
  *(_OWORD *)(a1 + 1000_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_OWORD *)(a1 + 10024) = 0u;
  *(_OWORD *)(a1 + 9976) = 0u;
  *(_OWORD *)(a1 + 9992) = 0u;
  *(_OWORD *)(a1 + 9944) = 0u;
  *(_OWORD *)(a1 + 9960) = 0u;
  *(_OWORD *)(a1 + 9912) = 0u;
  *(_OWORD *)(a1 + 992_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_DWORD *)(a1 + 11212) = a3;
  do
  {
    sub_1002DAF68(v6, 100.0, 50.0);
    int v11 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67109120;
      int v19 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#spatialGesturesPredictor #LPF configured LPF for signal %d in device motion data",  buf,  8u);
    }

    ++v10;
    v6 += 40LL;
  }

  while (v10 != 9);
  uint64_t v12 = 0LL;
  char v13 = 1;
  do
  {
    char v14 = v13;
    sub_1002DAF68(a1 + 424 + 40 * v12, 50.0, 20.0);
    double v15 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67109120;
      int v19 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "#spatialGesturesPredictor #LPF configured LPF for signal %d in UWB data",  buf,  8u);
    }

    char v13 = 0;
    uint64_t v12 = 1LL;
  }

  while ((v14 & 1) != 0);
  int v16 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "#spatialGesturesPredictor GesturePredictor is created",  buf,  2u);
  }

  return a1;
}

void sub_1002DD1E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, void **a11, uint64_t a12)
{
  char v14 = *a10;
  if (*a10)
  {
    *(void *)(v12 + 1116_Block_object_dispose((const void *)(v1 - 112), 8) = v14;
    operator delete(v14);
  }

  double v15 = *(void **)(v12 + 9888);
  if (v15)
  {
    *(void *)(v12 + 9896) = v15;
    operator delete(v15);
  }

  int v16 = *a11;
  if (*a11)
  {
    *(void *)(v12 + 9872) = v16;
    operator delete(v16);
  }

  sub_100012390(a12);
  _Unwind_Resume(a1);
}

void sub_1002DD24C(void *a1, uint64_t a2)
{
  if (*(_BYTE *)(a1[1] + 72LL))
  {
    __int128 v4 = *(_OWORD *)(a2 + 24);
    v70[0] = *(_OWORD *)(a2 + 8);
    v70[1] = v4;
    __int128 v5 = *(_OWORD *)(a2 + 88);
    v70[2] = *(_OWORD *)(a2 + 40);
    v70[3] = v5;
    uint64_t v71 = *(void *)(a2 + 104);
    __int128 v72 = *(_OWORD *)(a2 + 64);
    *(void *)&__int128 v5 = *(void *)(a2 + 56);
    uint64_t v73 = *(void *)(a2 + 80);
    uint64_t v74 = v5;
    sub_1002DD6C4((uint64_t)a1, (uint64_t)v70, (uint64_t)&v63);
    uint64_t v6 = os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG);
    if ((_DWORD)v6) {
      sub_1003AA140();
    }
    unint64_t v7 = a1[1234];
    unint64_t v8 = a1[1235];
    if (v7 >= v8)
    {
      uint64_t v13 = a1[1233];
      uint64_t v14 = 0x4EC4EC4EC4EC4EC5LL * ((uint64_t)(v7 - v13) >> 3);
      unint64_t v15 = v14 + 1;
      unint64_t v16 = 0x4EC4EC4EC4EC4EC5LL * ((uint64_t)(v8 - v13) >> 3);
      if (2 * v16 > v15) {
        unint64_t v15 = 2 * v16;
      }
      if (v16 >= 0x13B13B13B13B13BLL) {
        unint64_t v17 = 0x276276276276276LL;
      }
      else {
        unint64_t v17 = v15;
      }
      if (v17) {
        BOOL v18 = (char *)sub_1002DF96C((uint64_t)(a1 + 1235), v17);
      }
      else {
        BOOL v18 = 0LL;
      }
      int v19 = &v18[104 * v14];
      double v20 = &v18[104 * v17];
      __int128 v21 = v64;
      *(_OWORD *)int v19 = v63;
      *((_OWORD *)v19 + 1) = v21;
      *((void *)v19 + 12) = v69;
      __int128 v22 = v68;
      *((_OWORD *)v19 + 4) = v67;
      *((_OWORD *)v19 + 5) = v22;
      __int128 v23 = v66;
      *((_OWORD *)v19 + 2) = v65;
      *((_OWORD *)v19 + 3) = v23;
      uint64_t v12 = v19 + 104;
      uint64_t v6 = a1[1234];
      uint64_t v24 = a1[1233];
      if (v6 != v24)
      {
        do
        {
          __int128 v25 = *(_OWORD *)(v6 - 104);
          __int128 v26 = *(_OWORD *)(v6 - 88);
          *(_OWORD *)(v19 - 72) = *(_OWORD *)(v6 - 72);
          *(_OWORD *)(v19 - 8_Block_object_dispose((const void *)(v1 - 112), 8) = v26;
          *(_OWORD *)(v19 - 104) = v25;
          __int128 v27 = *(_OWORD *)(v6 - 56);
          __int128 v28 = *(_OWORD *)(v6 - 40);
          __int128 v29 = *(_OWORD *)(v6 - 24);
          *((void *)v19 - 1) = *(void *)(v6 - 8);
          *(_OWORD *)(v19 - 24) = v29;
          *(_OWORD *)(v19 - 40) = v28;
          *(_OWORD *)(v19 - 56) = v27;
          v19 -= 104;
          v6 -= 104LL;
        }

        while (v6 != v24);
        uint64_t v6 = a1[1233];
      }

      a1[1233] = v19;
      a1[1234] = v12;
      a1[1235] = v20;
      if (v6) {
        operator delete((void *)v6);
      }
    }

    else
    {
      __int128 v9 = v68;
      *(_OWORD *)(v7 + 64) = v67;
      *(_OWORD *)(v7 + 80) = v9;
      *(void *)(v7 + 96) = v69;
      __int128 v10 = v64;
      *(_OWORD *)unint64_t v7 = v63;
      *(_OWORD *)(v7 + 16) = v10;
      __int128 v11 = v66;
      uint64_t v12 = (char *)(v7 + 104);
      *(_OWORD *)(v7 + 32) = v65;
      *(_OWORD *)(v7 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v11;
    }

    a1[1234] = v12;
    double v30 = (void *)a1[1237];
    unint64_t v31 = a1[1238];
    if ((unint64_t)v30 >= v31)
    {
      uint64_t v6 = a1[1236];
      uint64_t v33 = ((uint64_t)v30 - v6) >> 3;
      unint64_t v34 = v31 - v6;
      unint64_t v35 = (uint64_t)(v31 - v6) >> 2;
      if (v35 <= v33 + 1) {
        unint64_t v35 = v33 + 1;
      }
      if (v34 >= 0x7FFFFFFFFFFFFFF8LL) {
        unint64_t v36 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v36 = v35;
      }
      if (v36)
      {
        int v37 = (char *)sub_1000472C0((uint64_t)(a1 + 1238), v36);
        double v30 = (void *)a1[1237];
        uint64_t v6 = a1[1236];
      }

      else
      {
        int v37 = 0LL;
      }

      int v38 = &v37[8 * v33];
      int v39 = &v37[8 * v36];
      *(void *)int v38 = *(void *)a2;
      double v32 = v38 + 8;
      while (v30 != (void *)v6)
      {
        uint64_t v40 = *--v30;
        *((void *)v38 - 1) = v40;
        v38 -= 8;
      }

      a1[1236] = v38;
      a1[1237] = v32;
      a1[1238] = v39;
      if (v6) {
        operator delete((void *)v6);
      }
    }

    else
    {
      *double v30 = *(void *)a2;
      double v32 = v30 + 1;
    }

    a1[1237] = v32;
    __int128 v41 = *(_OWORD *)(a2 + 72);
    v62[0] = *(_OWORD *)(a2 + 56);
    v62[1] = v41;
    sub_1002DD7B4(v6, (double *)v62);
    uint64_t v45 = v42;
    uint64_t v46 = v43;
    uint64_t v47 = v44;
    double v48 = (void *)a1[1396];
    unint64_t v49 = a1[1397];
    if ((unint64_t)v48 >= v49)
    {
      uint64_t v51 = a1[1395];
      unint64_t v52 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v48 - v51) >> 3);
      unint64_t v53 = v52 + 1;
      if (v52 + 1 > 0xAAAAAAAAAAAAAAALL) {
        sub_10001E11C();
      }
      unint64_t v54 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v49 - v51) >> 3);
      if (2 * v54 > v53) {
        unint64_t v53 = 2 * v54;
      }
      if (v54 >= 0x555555555555555LL) {
        unint64_t v55 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v55 = v53;
      }
      if (v55) {
        uint64_t v56 = (char *)sub_10001E130((uint64_t)(a1 + 1397), v55);
      }
      else {
        uint64_t v56 = 0LL;
      }
      uint64_t v57 = &v56[24 * v52];
      uint64_t v58 = &v56[24 * v55];
      *(void *)uint64_t v57 = v45;
      *((void *)v57 + 1) = v46;
      *((void *)v57 + 2) = v47;
      double v50 = v57 + 24;
      double v59 = (char *)a1[1396];
      double v60 = (char *)a1[1395];
      if (v59 != v60)
      {
        do
        {
          __int128 v61 = *(_OWORD *)(v59 - 24);
          *((void *)v57 - 1) = *((void *)v59 - 1);
          *(_OWORD *)(v57 - 24) = v61;
          v57 -= 24;
          v59 -= 24;
        }

        while (v59 != v60);
        double v59 = (char *)a1[1395];
      }

      a1[1395] = v57;
      a1[1396] = v50;
      a1[1397] = v58;
      if (v59) {
        operator delete(v59);
      }
    }

    else
    {
      void *v48 = v42;
      v48[1] = v43;
      double v50 = v48 + 3;
      v48[2] = v44;
    }

    a1[1396] = v50;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
      sub_1003AA114();
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR))
  {
    sub_1003AA0E8();
  }

__n128 sub_1002DD6C4@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = 0LL;
  uint64_t v6 = (double *)(a1 + 96);
  do
  {
    if (*((_BYTE *)v6 - 32))
    {
      double v7 = *(double *)(a2 + v5);
      if (*((_BYTE *)v6 - 31)) {
        double v7 = (1.0 - *(v6 - 1)) * *v6 + *(v6 - 1) * v7;
      }
      else {
        *((_BYTE *)v6 - 31) = 1;
      }
      double *v6 = v7;
    }

    else
    {
      unint64_t v8 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
        sub_1003AA16C(&v10, v11, v8);
      }
      double v7 = *(double *)(a2 + v5);
    }

    v6 += 5;
    *(double *)(a3 + v5) = v7;
    v5 += 8LL;
  }

  while (v5 != 72);
  *(_OWORD *)(a3 + 72) = *(_OWORD *)(a2 + 72);
  __n128 result = *(__n128 *)(a2 + 88);
  *(__n128 *)(a3 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = result;
  return result;
}

void sub_1002DD7B4(uint64_t a1, double *a2)
{
  double v2 = *a2;
  double v3 = a2[1];
  double v4 = a2[2];
  double v5 = a2[3];
  double v6 = *a2 * v4 - v5 * v3 + *a2 * v4 - v5 * v3;
  if (fabs(v6) < 1.0) {
    asin(v6);
  }
  atan2(v5 * v4 + v2 * v3 + v5 * v4 + v2 * v3, (v4 * v4 + v3 * v3) * -2.0 + 1.0);
  atan2(v3 * v4 + v2 * v5 + v3 * v4 + v2 * v5, (v5 * v5 + v4 * v4) * -2.0 + 1.0);
}

void sub_1002DD87C(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(*(void *)(a1 + 8) + 72LL))
  {
    uint64_t v4 = a2;
    __int128 v6 = *(_OWORD *)(a1 + 9944);
    __int128 v184 = *(_OWORD *)(a1 + 9928);
    __int128 v185 = v6;
    __int128 v7 = *(_OWORD *)(a1 + 9976);
    __int128 v186 = *(_OWORD *)(a1 + 9960);
    __int128 v187 = v7;
    if (!*(_BYTE *)(a2 + 72)) {
      sub_1003AA1A0();
    }
    switch(*(_DWORD *)(a1 + 11212))
    {
      case 0:
      case 2:
      case 4:
        sub_1003AA1F4();
      case 1:
        double v3 = *(float *)(a2 + 16);
        uint64_t v2 = *(void *)(a2 + 64);
        break;
      case 3:
        uint64_t v8 = *(void *)(a2 + 64);
        *(double *)__int128 __dst = *(float *)(a2 + 16);
        *(void *)&__dst[8] = v8;
        double v3 = sub_1002DE6A8(a1, (uint64_t)__dst);
        uint64_t v2 = v9;
        uint8_t v10 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#spatialGesturesPredictor #LPF UWB signals filtered for DualAnchorAntennaPredictor",  buf,  2u);
        }

        break;
      default:
        break;
    }

    __int128 v11 = v185;
    *(_OWORD *)(a1 + 9912) = v184;
    *(_OWORD *)(a1 + 992_Block_object_dispose((const void *)(v1 - 112), 8) = v11;
    __int128 v12 = v187;
    *(_OWORD *)(a1 + 9944) = v186;
    *(_OWORD *)(a1 + 9960) = v12;
    *(double *)(a1 + 9976) = v3;
    *(void *)(a1 + 9984) = v2;
    uint64_t v13 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 __dst = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "#spatialGesturesPredictor GesturePredictor consumed UWB input",  __dst,  2u);
    }

    bzero(__src, 0x3A8uLL);
    uint64_t v180 = 0LL;
    __int128 v178 = 0u;
    __int128 v179 = 0u;
    __int128 v176 = 0u;
    __int128 v177 = 0u;
    __int128 v174 = 0u;
    __int128 v175 = 0u;
    __int128 v172 = 0u;
    __int128 v173 = 0u;
    __int128 v171 = 0u;
    __int128 v169 = 0u;
    __int128 v170 = 0u;
    __int128 v167 = 0u;
    __int128 v168 = 0u;
    uint64_t v14 = *(void *)(a1 + 9888);
    uint64_t v15 = *(void *)(a1 + 9896) - v14;
    unint64_t v16 = v15 >> 3;
    if (v15)
    {
      uint64_t v17 = 0LL;
      if (v16 <= 1) {
        uint64_t v18 = 1LL;
      }
      else {
        uint64_t v18 = v16;
      }
      while (*(double *)(v14 + 8 * v17) <= *(double *)(v4 + 8))
      {
        if (v18 == ++v17) {
          goto LABEL_19;
        }
      }

      LODWORD(v16) = v17;
    }

void sub_1002DE5FC(_Unwind_Exception *a1)
{
  uint64_t v2 = (void *)STACK[0x4E0];
  if (STACK[0x4E0])
  {
    STACK[0x4E8] = (unint64_t)v2;
    operator delete(v2);
  }

  double v3 = (void *)STACK[0x920];
  if (STACK[0x920])
  {
    STACK[0x928] = (unint64_t)v3;
    operator delete(v3);
  }

  _Unwind_Resume(a1);
}

double sub_1002DE6A8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = 0LL;
  uint64_t v4 = a1 + 424;
  char v5 = 1;
  do
  {
    char v6 = v5;
    if (*(_BYTE *)(v4 + 40 * v3))
    {
      double v7 = *(double *)(a2 + 8 * v3);
      uint64_t v8 = v4 + 40 * v3;
      int v10 = *(unsigned __int8 *)(v8 + 1);
      uint64_t v9 = (_BYTE *)(v8 + 1);
      if (v10)
      {
        uint64_t v11 = v4 + 40 * v3;
        double v7 = (1.0 - *(double *)(v11 + 24)) * *(double *)(v11 + 32) + *(double *)(v11 + 24) * v7;
      }

      else
      {
        _BYTE *v9 = 1;
        uint64_t v11 = v4 + 40 * v3;
      }

      *(double *)(v11 + 32) = v7;
    }

    else
    {
      __int128 v12 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
        sub_1003AA16C(&v14, v15, v12);
      }
      double v7 = *(double *)(a2 + 8 * v3);
    }

    char v5 = 0;
    *(&v16 + v3) = v7;
    uint64_t v3 = 1LL;
  }

  while ((v6 & 1) != 0);
  return v16;
}

void sub_1002DE7AC()
{
  uint64_t v0 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_DEFAULT,  "#spatialGesturesPredictor Gesture changed",  v1,  2u);
  }

double sub_1002DE810(uint64_t a1)
{
  uint64_t v1 = (_BYTE *)(a1 + 11208);
  *(_BYTE *)(a1 + 1120_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  uint64_t v2 = *(_BYTE **)(a1 + 8);
  if (v2[72])
  {
    memcpy(__dst, (const void *)(a1 + 504), 0x1248uLL);
    __dst[4680] = 1;
    memcpy(v21, (const void *)(a1 + 5184), sizeof(v21));
    __int128 v4 = *(_OWORD *)(a1 + 9912);
    __int128 v24 = *(_OWORD *)(a1 + 9928);
    __int128 v5 = *(_OWORD *)(a1 + 9960);
    __int128 v25 = *(_OWORD *)(a1 + 9944);
    char v22 = 1;
    __int128 v26 = v5;
    __int128 v27 = *(_OWORD *)(a1 + 9976);
    __int128 v23 = v4;
    char v28 = 1;
    __int128 v6 = *(_OWORD *)(a1 + 10040);
    __int128 v31 = *(_OWORD *)(a1 + 10024);
    __int128 v32 = v6;
    __int128 v33 = *(_OWORD *)(a1 + 10056);
    __int128 v7 = *(_OWORD *)(a1 + 10008);
    __int128 v29 = *(_OWORD *)(a1 + 9992);
    __int128 v30 = v7;
    char v34 = 1;
    memcpy(v35, (const void *)(a1 + 10080), 0x438uLL);
    v35[1080] = 1;
    uint64_t v36 = *(void *)(a1 + 10072);
    char v37 = 1;
    char v38 = 0;
    char v39 = 0;
    (*(void (**)(void *__return_ptr, _BYTE *, _BYTE *, uint64_t, void))(*(void *)v2 + 16LL))( v18,  v2,  __dst,  a1 + 24,  *(unsigned int *)(a1 + 11212));
    if (!v22) {
      sub_1003AA298();
    }
    memcpy((void *)(a1 + 5184), v21, 0x1248uLL);
    if (!v34) {
      sub_1003AA2C0();
    }
    __int128 v8 = v32;
    *(_OWORD *)(a1 + 10024) = v31;
    *(_OWORD *)(a1 + 10040) = v8;
    *(_OWORD *)(a1 + 10056) = v33;
    __int128 v9 = v30;
    *(_OWORD *)(a1 + 9992) = v29;
    *(_OWORD *)(a1 + 1000_Block_object_dispose((const void *)(v1 - 112), 8) = v9;
    if (!v19)
    {
      double v11 = *(double *)&v18[1];
      double v13 = sub_1002DCB44(*(double **)(a1 + 8), *(_DWORD *)(a1 + 11212));
      uint8_t v14 = (os_log_s *)qword_1008000A0;
      BOOL v15 = os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT);
      if (v11 <= v13)
      {
        if (!v15) {
          return v11;
        }
        *(_DWORD *)__int128 buf = 134217984;
        double v41 = v11;
        double v16 = "#spatialGesturesPredictor Gesture = Other, HandoffConfidence = %f";
      }

      else
      {
        if (!v15) {
          return v11;
        }
        *(_DWORD *)__int128 buf = 134217984;
        double v41 = v11;
        double v16 = "#spatialGesturesPredictor Gesture = Handoff, HandoffConfidence = %f";
      }

      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v16, buf, 0xCu);
      return v11;
    }

    int v10 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#spatialGesturesPredictor #evaluation false positive alert",  buf,  2u);
    }

    _BYTE *v1 = 1;
    return 0.0;
  }

  else
  {
    __int128 v12 = (os_log_s *)qword_1008000A0;
    double v11 = 1.0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
      sub_1003AA21C(v12);
    }
  }

  return v11;
}

uint64_t sub_1002DEB34(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 11208);
}

uint64_t sub_1002DEB40(uint64_t a1)
{
  *(void *)a1 = off_1007BCD40;
  sub_1002DFFE0((void *)(a1 + 64));
  sub_100012390(a1 + 8);
  return a1;
}

void sub_1002DEB90(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1002DEB40(a1);
  operator delete(v1);
}

void sub_1002DEBA4(void *a1, uint64_t a2)
{
  if (*(_BYTE *)(a1[1] + 72LL))
  {
    __int128 v3 = *(_OWORD *)(a2 + 24);
    v7[0] = *(_OWORD *)(a2 + 8);
    v7[1] = v3;
    int8x16_t v4 = vextq_s8(*(int8x16_t *)(a2 + 120), *(int8x16_t *)(a2 + 120), 8uLL);
    _DWORD v7[2] = *(_OWORD *)(a2 + 40);
    v7[3] = v4;
    v7[4] = *(_OWORD *)(a2 + 88);
    uint64_t v8 = *(void *)(a2 + 104);
    uint64_t v5 = (uint64_t)(a1 + 8);
    sub_1002DEC70(a1 + 8, (uint64_t)v7);
    unint64_t v6 = a1[13];
    if (v6 >= 0x33)
    {
      do
      {
        ++a1[12];
        a1[13] = v6 - 1;
        sub_1002E0388(v5, 1);
        unint64_t v6 = a1[13];
      }

      while (v6 > 0x32);
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR))
  {
    sub_1003AA0E8();
  }

__n128 sub_1002DEC70(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 46 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_1002E0074(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x2E)) + 88 * (v7 % 0x2E);
  __int128 v9 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)unint64_t v8 = *(_OWORD *)a2;
  *(_OWORD *)(v8 + 16) = v9;
  __n128 result = *(__n128 *)(a2 + 32);
  __int128 v11 = *(_OWORD *)(a2 + 48);
  __int128 v12 = *(_OWORD *)(a2 + 64);
  *(void *)(v8 + 80) = *(void *)(a2 + 80);
  *(_OWORD *)(v8 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v11;
  *(_OWORD *)(v8 + 64) = v12;
  *(__n128 *)(v8 + 32) = result;
  ++a1[5];
  return result;
}

void sub_1002DED38()
{
  uint64_t v0 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_DEFAULT,  "#spatialGesturesPredictor Gesture changed",  v1,  2u);
  }

double sub_1002DED9C(uint64_t a1)
{
  uint64_t v1 = *(_BYTE **)(a1 + 8);
  if (v1[72])
  {
    if (*(void *)(a1 + 104) == 50LL)
    {
      unint64_t v3 = *(void *)(a1 + 96);
      uint64_t v4 = *(void *)(a1 + 72);
      uint64_t v5 = -4400LL;
      do
      {
        unint64_t v6 = *(void *)(v4 + 8 * (v3 / 0x2E)) + 88 * (v3 % 0x2E);
        __int128 v7 = *(_OWORD *)(v6 + 48);
        unint64_t v8 = &v15[v5];
        *((_OWORD *)v8 + 277) = *(_OWORD *)(v6 + 32);
        *((_OWORD *)v8 + 27_Block_object_dispose((const void *)(v1 - 112), 8) = v7;
        *((_OWORD *)v8 + 279) = *(_OWORD *)(v6 + 64);
        __int128 v9 = *(_OWORD *)(v6 + 16);
        *((_OWORD *)v8 + 275) = *(_OWORD *)v6;
        *((void *)v8 + 560) = *(void *)(v6 + 80);
        *((_OWORD *)v8 + 276) = v9;
        ++v3;
        v5 += 88LL;
      }

      while (v5);
      v13[0] = 0;
      v13[4680] = 0;
      v13[4688] = 0;
      v13[9368] = 0;
      v13[9376] = 0;
      v13[9456] = 0;
      v13[9464] = 0;
      v13[9544] = 0;
      v13[9552] = 0;
      v13[10632] = 0;
      v13[10640] = 0;
      v13[10648] = 0;
      memcpy(v14, v15, 0x1130uLL);
      v14[4400] = 1;
      (*(void (**)(void *__return_ptr, _BYTE *, _BYTE *, uint64_t, void))(*(void *)v1 + 16LL))( v12,  v1,  v13,  a1 + 24,  *(unsigned int *)(a1 + 136));
      return *(double *)&v12[1];
    }

    else
    {
      double v10 = 0.0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
        sub_1003AA314();
      }
    }
  }

  else
  {
    double v10 = 0.0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
      sub_1003AA2E8();
    }
  }

  return v10;
}

uint64_t sub_1002DEF78(uint64_t a1, uint64_t *a2, int a3)
{
  *(void *)a1 = &off_1007BCD88;
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  uint64_t v4 = (uint64_t *)(a1 + 8);
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + 32) = 0LL;
  *(_DWORD *)(a1 + 40) = 0;
  switch(a3)
  {
    case 0:
    case 2:
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
        sub_1003AA340();
      }
      __int128 v30 = "false";
      int v31 = 1050;
      goto LABEL_33;
    case 1:
    case 3:
      uint64_t v7 = *a2;
      if (*a2)
      {
        unint64_t v8 = operator new(0x2BD0uLL);
        uint64_t v9 = (uint64_t)v8;
        double v10 = (std::__shared_weak_count *)a2[1];
        uint64_t v32 = v7;
        __int128 v33 = v10;
        if (v10)
        {
          p_shared_owners = (unint64_t *)&v10->__shared_owners_;
          do
            unint64_t v12 = __ldxr(p_shared_owners);
          while (__stxr(v12 + 1, p_shared_owners));
        }

        sub_1002DCF40((uint64_t)v8, &v32, a3);
        double v13 = v33;
        if (v33)
        {
          uint8_t v14 = (unint64_t *)&v33->__shared_owners_;
          do
            unint64_t v15 = __ldaxr(v14);
          while (__stlxr(v15 - 1, v14));
          if (!v15)
          {
            ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
            std::__shared_weak_count::__release_weak(v13);
          }
        }

        uint64_t v16 = *v4;
        *uint64_t v4 = v9;
        if (v16) {
          (*(void (**)(uint64_t))(*(void *)v16 + 8LL))(v16);
        }
        uint64_t v17 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v32) = 0;
          uint64_t v18 = "#spatialGesturesPredictor Initializing models for UWB based spatial gestures";
LABEL_28:
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, v18, (uint8_t *)&v32, 2u);
          return a1;
        }

        return a1;
      }

      __int128 v30 = "gestureClassifiers[kIdxUwbSpatialGesturePredictor] != NULL";
      int v31 = 1036;
      goto LABEL_33;
    case 4:
      uint64_t v19 = a2[2];
      if (!v19)
      {
        __int128 v30 = "gestureClassifiers[kIdxMotionBasedSpatialGesturePredictor] != NULL";
        int v31 = 1042;
LABEL_33:
        __assert_rtn("GesturePredictorWrapper", "NRBYSpatialGesturePredictor.mm", v31, v30);
      }

      uint64_t v20 = operator new(0x90uLL);
      uint64_t v21 = v20;
      char v22 = (std::__shared_weak_count *)a2[3];
      uint64_t v32 = v19;
      __int128 v33 = v22;
      if (v22)
      {
        __int128 v23 = (unint64_t *)&v22->__shared_owners_;
        do
          unint64_t v24 = __ldxr(v23);
        while (__stxr(v24 + 1, v23));
      }

      *uint64_t v20 = off_1007BCD40;
      v20[2] = 0LL;
      *((_DWORD *)v20 + 6) = 0;
      v20[1] = 0LL;
      *((_BYTE *)v20 + 2_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
      *((_DWORD *)v20 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0;
      void v20[5] = 0LL;
      *((_OWORD *)v20 + 4) = 0u;
      *((_OWORD *)v20 + 5) = 0u;
      *((_OWORD *)v20 + 6) = 0u;
      *((_OWORD *)v20 + 7) = 0u;
      v20[16] = 0LL;
      sub_100018E60(v20 + 1, &v32);
      *((_DWORD *)v21 + 14) = 1;
      *((_DWORD *)v21 + 34) = 4;
      __int128 v25 = v33;
      if (v33)
      {
        __int128 v26 = (unint64_t *)&v33->__shared_owners_;
        do
          unint64_t v27 = __ldaxr(v26);
        while (__stlxr(v27 - 1, v26));
        if (!v27)
        {
          ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
          std::__shared_weak_count::__release_weak(v25);
        }
      }

      uint64_t v28 = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v21;
      if (v28) {
        (*(void (**)(uint64_t))(*(void *)v28 + 8LL))(v28);
      }
      uint64_t v17 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v32) = 0;
        uint64_t v18 = "#spatialGesturesPredictor Initializing models for motion based spatial gestures";
        goto LABEL_28;
      }

      return a1;
    default:
      return a1;
  }

void sub_1002DF244(_Unwind_Exception *exception_object)
{
  uint64_t v3 = 16LL;
  while (1)
  {
    uint64_t v4 = *(void *)(v1 + v3);
    *(void *)(v1 + v3) = 0LL;
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
    }
    v3 -= 8LL;
    if (!v3) {
      _Unwind_Resume(exception_object);
    }
  }

uint64_t sub_1002DF298(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 16LL))(v4, a2);
  }
  uint64_t result = *(void *)(a1 + 16);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 16LL))(result, a2);
  }
  return result;
}

uint64_t sub_1002DF2F0(uint64_t a1, uint64_t a2)
{
  *(double *)(a1 + 24) = *(float *)(a2 + 16);
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 24LL))(result);
  }
  return result;
}

void sub_1002DF314(uint64_t a1, uint64_t a2, uint64_t a3, double a4)
{
  uint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    sub_1002DF6D0(v25, a2);
    sub_1002DF6D0(v20, a3);
    (*(void (**)(uint64_t, _BYTE *, _BYTE *, double))(*(void *)v8 + 32LL))(v8, v25, v20, a4);
    if (v24 && v23 && v22 < 0) {
      operator delete(__p);
    }
    if (v29 && v28 && v27 < 0) {
      operator delete(v26);
    }
  }

  uint64_t v9 = *(void *)(a1 + 16);
  if (v9)
  {
    sub_1002DF6D0(v15, a2);
    sub_1002DF6D0(v10, a3);
    (*(void (**)(uint64_t, _BYTE *, _BYTE *, double))(*(void *)v9 + 32LL))(v9, v15, v10, a4);
    if (v14 && v13 && v12 < 0) {
      operator delete(v11);
    }
    if (v19 && v18 && v17 < 0) {
      operator delete(v16);
    }
  }

void sub_1002DF454( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, int a20, __int16 a21, char a22, char a23, int a24, __int16 a25, char a26, char a27, void *a28, uint64_t a29, int a30, __int16 a31, char a32, char a33, uint64_t a34, uint64_t a35, uint64_t a36, char a37, int a38, __int16 a39, char a40, char a41, uint64_t a42, void *a43, uint64_t a44, int a45, __int16 a46, char a47, char a48, uint64_t a49, uint64_t a50,uint64_t a51,char a52,int a53,__int16 a54,char a55,char a56)
{
  if ((_BYTE)a21 && a19 && a15 < 0) {
    operator delete(__p);
  }
  if ((_BYTE)a39 && a37 && a33 < 0) {
    operator delete(a28);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002DF4F8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 || (uint64_t v2 = *(void *)(a1 + 16)) != 0)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 40LL))(v2);
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT)) {
      sub_1003AA36C();
    }
    return -1.0;
  }

  return result;
}

void sub_1002DF568(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1002DF76C(a1);
  operator delete(v1);
}

uint64_t sub_1002DF580()
{
  return 0LL;
}

void *sub_1002DF588(void *a1)
{
  *a1 = &off_1007BCD88;
  uint64_t v2 = 2LL;
  do
  {
    uint64_t v3 = a1[v2];
    a1[v2] = 0LL;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
    }
    --v2;
  }

  while (v2 * 8);
  return a1;
}

void sub_1002DF5D8(char *__p)
{
  *(void *)stat __p = &off_1007BCD88;
  uint64_t v2 = 16LL;
  do
  {
    uint64_t v3 = *(void *)&__p[v2];
    *(void *)&__p[v2] = 0LL;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
    }
    v2 -= 8LL;
  }

  while (v2);
  operator delete(__p);
}

uint64_t sub_1002DF62C()
{
  return 13LL;
}

uint64_t sub_1002DF634()
{
  return 5LL;
}

uint64_t sub_1002DF63C()
{
  return 585LL;
}

uint64_t sub_1002DF644()
{
  return 10LL;
}

double sub_1002DF64C()
{
  return 0.05625;
}

double sub_1002DF658()
{
  return 0.05625;
}

double sub_1002DF664()
{
  return 0.05625;
}

double sub_1002DF670()
{
  return 0.05625;
}

uint64_t sub_1002DF67C()
{
  return 3LL;
}

uint64_t sub_1002DF688()
{
  return 11LL;
}

uint64_t sub_1002DF690()
{
  return 50LL;
}

uint64_t sub_1002DF698()
{
  return 550LL;
}

uint64_t sub_1002DF6A0()
{
  return 0xFFFFFFFFLL;
}

double sub_1002DF6A8()
{
  return -1.0;
}

double sub_1002DF6B0()
{
  return -1.0;
}

double sub_1002DF6B8()
{
  return -1.0;
}

double sub_1002DF6C0()
{
  return -1.0;
}

uint64_t sub_1002DF6C8()
{
  return 2LL;
}

_BYTE *sub_1002DF6D0(_BYTE *a1, uint64_t a2)
{
  *a1 = 0;
  a1[64] = 0;
  if (*(_BYTE *)(a2 + 64))
  {
    *(void *)a1 = *(void *)a2;
    sub_1002AEE40(a1 + 8, (__int128 *)(a2 + 8));
    a1[64] = 1;
  }

  return a1;
}

void sub_1002DF718(_Unwind_Exception *a1)
{
}

uint64_t sub_1002DF72C(uint64_t a1)
{
  return a1;
}

uint64_t sub_1002DF76C(uint64_t a1)
{
  *(void *)a1 = off_1007BCCF8;
  uint64_t v2 = *(void **)(a1 + 11160);
  if (v2)
  {
    *(void *)(a1 + 1116_Block_object_dispose((const void *)(v1 - 112), 8) = v2;
    operator delete(v2);
  }

  uint64_t v3 = *(void **)(a1 + 9888);
  if (v3)
  {
    *(void *)(a1 + 9896) = v3;
    operator delete(v3);
  }

  uint64_t v4 = *(void **)(a1 + 9864);
  if (v4)
  {
    *(void *)(a1 + 9872) = v4;
    operator delete(v4);
  }

  sub_100012390(a1 + 8);
  return a1;
}

double sub_1002DF7EC()
{
  return 0.40968198;
}

double sub_1002DF7F8@<D0>(_OWORD *a1@<X8>)
{
  a1[10] = xmmword_10042E540;
  a1[11] = unk_10042E550;
  a1[12] = xmmword_10042E560;
  a1[6] = xmmword_10042E500;
  a1[7] = unk_10042E510;
  a1[8] = xmmword_10042E520;
  a1[9] = unk_10042E530;
  a1[2] = xmmword_10042E4C0;
  a1[3] = unk_10042E4D0;
  a1[4] = xmmword_10042E4E0;
  a1[5] = unk_10042E4F0;
  double result = dbl_10042E4B0[0];
  *a1 = xmmword_10042E4A0;
  a1[1] = *(_OWORD *)dbl_10042E4B0;
  return result;
}

double sub_1002DF83C()
{
  return 0.335718321;
}

double sub_1002DF860()
{
  return -0.116659178;
}

void *sub_1002DF884(void *a1, unint64_t a2)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if (a2)
  {
    sub_1000317D0(a1, a2);
    uint64_t v4 = (char *)a1[1];
    bzero(v4, 4 * a2);
    a1[1] = &v4[4 * a2];
  }

  return a1;
}

void sub_1002DF8DC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void *sub_1002DF8F8(void *a1, unint64_t a2)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if (a2)
  {
    sub_10011B5D8(a1, a2);
    uint64_t v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }

  return a1;
}

void sub_1002DF950(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void *sub_1002DF96C(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x276276276276277LL) {
    sub_10001D350();
  }
  return operator new(104 * a2);
}

uint64_t sub_1002DF9B4(unint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((uint64_t)(a2 - a1) >= 5)
  {
    uint64_t v4 = (int *)a1;
    __int128 v12 = xmmword_10042E570;
    unint64_t v5 = a2 - 4;
    if (a2 - 4 > a1)
    {
      uint64_t v7 = ((a2 - a1) >> 2) - 1;
      do
      {
        v11[0] = 0LL;
        v11[1] = v7;
        uint64_t v8 = sub_1002DFA58((uint64_t)&v12, a3, v11);
        if (v8)
        {
          int v9 = *v4;
          *uint64_t v4 = v4[v8];
          v4[v8] = v9;
        }

        ++v4;
        --v7;
      }

      while ((unint64_t)v4 < v5);
    }
  }

  return a2;
}

uint64_t sub_1002DFA58(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t result = a3[1];
  uint64_t v4 = result - *a3;
  if (result != *a3)
  {
    unint64_t v5 = v4 + 1;
    if (v4 == -1)
    {
      sub_1002DFAE0((uint64_t)v10, a2, 0x40uLL);
      return sub_1002DFBD4((uint64_t)v10);
    }

    else
    {
      unint64_t v7 = __clz(v5);
      uint64_t v8 = 63LL;
      if (((v5 << v7) & 0x7FFFFFFFFFFFFFFFLL) != 0) {
        uint64_t v8 = 64LL;
      }
      sub_1002DFAE0((uint64_t)v10, a2, v8 - v7);
      do
        unint64_t v9 = sub_1002DFBD4((uint64_t)v10);
      while (v9 >= v5);
      return *a3 + v9;
    }
  }

  return result;
}

uint64_t sub_1002DFAE0(uint64_t result, uint64_t a2, unint64_t a3)
{
  *(void *)uint64_t result = a2;
  *(void *)(result + _Block_object_dispose((const void *)(v1 - 112), 8) = a3;
  if (a3 % 0x1E) {
    unint64_t v3 = a3 / 0x1E + 1;
  }
  else {
    unint64_t v3 = a3 / 0x1E;
  }
  unint64_t v4 = a3 / v3;
  *(void *)(result + 16) = a3 / v3;
  *(void *)(result + 24) = v3;
  unint64_t v5 = (-1LL << (a3 / v3)) & 0x7FFFFFFE;
  if (a3 / v3 >= 0x40) {
    unint64_t v5 = 0LL;
  }
  *(void *)(result + 40) = v5;
  if ((v5 ^ 0x7FFFFFFE) > v5 / v3)
  {
    ++v3;
    unint64_t v4 = a3 / v3;
    *(void *)(result + 16) = a3 / v3;
    *(void *)(result + 24) = v3;
    if (a3 / v3 > 0x3F)
    {
      unint64_t v6 = 0LL;
      *(void *)(result + 32) = v3 + v4 * v3 - a3;
      *(void *)(result + 40) = 0LL;
      goto LABEL_13;
    }

    *(void *)(result + 40) = (-1LL << v4) & 0x7FFFFFFE;
  }

  *(void *)(result + 32) = v3 + a3 / v3 * v3 - a3;
  if (v4 > 0x3E) {
    unint64_t v6 = 0LL;
  }
  else {
    unint64_t v6 = 0x3FFFFFFFuLL >> v4 << (v4 + 1);
  }
LABEL_13:
  *(void *)(result + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v6;
  unsigned int v7 = 0xFFFFFFFF >> -(char)v4;
  if (!v4) {
    unsigned int v7 = 0;
  }
  if (v4 >= 0x1F) {
    unsigned int v8 = -1;
  }
  else {
    unsigned int v8 = 0xFFFFFFFF >> ~(_BYTE)v4;
  }
  *(_DWORD *)(result + 56) = v7;
  *(_DWORD *)(result + 60) = v8;
  return result;
}

uint64_t sub_1002DFBD4(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    uint64_t result = 0LL;
    uint64_t v4 = 0LL;
    unint64_t v5 = *(void *)(a1 + 16);
    unsigned int v6 = **(_DWORD **)a1;
    do
    {
      do
      {
        unsigned int v7 = v6 / 0xADC8;
        unsigned int v8 = 48271 * (v6 % 0xADC8);
        v7 *= 3399;
        BOOL v9 = v8 >= v7;
        unsigned int v10 = v8 - v7;
        if (v9) {
          int v11 = 0;
        }
        else {
          int v11 = 0x7FFFFFFF;
        }
        unsigned int v6 = v11 + v10;
        unint64_t v12 = v6 - 1;
      }

      while (*(void *)(a1 + 40) <= v12);
      uint64_t v13 = result << v5;
      if (v5 >= 0x40) {
        uint64_t v13 = 0LL;
      }
      uint64_t result = v13 + (*(_DWORD *)(a1 + 56) & v12);
      ++v4;
    }

    while (v4 != v2);
    **(_DWORD **)a1 = v6;
  }

  else
  {
    uint64_t result = 0LL;
  }

  unint64_t v14 = *(void *)(a1 + 24);
  if (v2 < v14)
  {
    unint64_t v15 = *(unsigned int **)a1;
    unint64_t v16 = *(void *)(a1 + 48);
    unint64_t v17 = *(void *)(a1 + 16);
    int v18 = *(_DWORD *)(a1 + 60);
    unsigned int v19 = *v15;
    while (1)
    {
      unsigned int v20 = v19 / 0xADC8;
      unsigned int v21 = 48271 * (v19 % 0xADC8);
      v20 *= 3399;
      BOOL v9 = v21 >= v20;
      unsigned int v22 = v21 - v20;
      if (v9) {
        int v23 = 0;
      }
      else {
        int v23 = 0x7FFFFFFF;
      }
      unsigned int v19 = v23 + v22;
      unint64_t v24 = v19 - 1;
      if (v16 > v24)
      {
        uint64_t v25 = result << (v17 + 1);
        if (v17 >= 0x3F) {
          uint64_t v25 = 0LL;
        }
        uint64_t result = v25 + (v18 & v24);
        if (++v2 == v14) {
          break;
        }
      }
    }

    unsigned int *v15 = v19;
  }

  return result;
}

char *sub_1002DFCFC(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  unsigned int v7 = result;
  uint64_t v8 = *((void *)result + 2);
  BOOL v9 = *(char **)result;
  if (0x4EC4EC4EC4EC4EC5LL * ((v8 - *(void *)result) >> 3) < a4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0LL;
      *unsigned int v7 = 0LL;
      v7[1] = 0LL;
      _DWORD v7[2] = 0LL;
    }

    if (a4 > 0x276276276276276LL) {
      sub_10001E11C();
    }
    unint64_t v10 = 0x4EC4EC4EC4EC4EC5LL * (v8 >> 3);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= a4) {
      uint64_t v11 = a4;
    }
    if (v10 >= 0x13B13B13B13B13BLL) {
      unint64_t v12 = 0x276276276276276LL;
    }
    else {
      unint64_t v12 = v11;
    }
    uint64_t result = sub_1002DFE54(v7, v12);
    unint64_t v14 = (char *)v7[1];
    uint64_t v13 = (void **)(v7 + 1);
    BOOL v9 = v14;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      int v18 = v9;
      unsigned int v19 = __src;
      goto LABEL_18;
    }

    goto LABEL_19;
  }

  uint64_t v13 = (void **)(result + 8);
  unint64_t v15 = (_BYTE *)*((void *)result + 1);
  if (0x4EC4EC4EC4EC4EC5LL * ((v15 - v9) >> 3) >= a4) {
    goto LABEL_16;
  }
  unint64_t v16 = &__src[8 * ((v15 - v9) >> 3)];
  if (v15 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, v15 - v9);
    BOOL v9 = (char *)*v13;
  }

  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    int v18 = v9;
    unsigned int v19 = v16;
LABEL_18:
    uint64_t result = (char *)memmove(v18, v19, v17);
  }

char *sub_1002DFE54(void *a1, unint64_t a2)
{
  if (a2 >= 0x276276276276277LL) {
    sub_10001E11C();
  }
  uint64_t result = (char *)sub_1002DF96C((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[104 * v4];
  return result;
}

char *sub_1002DFEA8(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  unsigned int v7 = result;
  uint64_t v8 = *((void *)result + 2);
  BOOL v9 = *(char **)result;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - *(void *)result) >> 3) < a4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0LL;
      *unsigned int v7 = 0LL;
      v7[1] = 0LL;
      _DWORD v7[2] = 0LL;
    }

    if (a4 > 0xAAAAAAAAAAAAAAALL) {
      sub_10001E11C();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 3);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= a4) {
      uint64_t v11 = a4;
    }
    if (v10 >= 0x555555555555555LL) {
      unint64_t v12 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v12 = v11;
    }
    uint64_t result = sub_10001E0CC(v7, v12);
    unint64_t v14 = (char *)v7[1];
    uint64_t v13 = (void **)(v7 + 1);
    BOOL v9 = v14;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      int v18 = v9;
      unsigned int v19 = __src;
      goto LABEL_18;
    }

    goto LABEL_19;
  }

  uint64_t v13 = (void **)(result + 8);
  unint64_t v15 = (_BYTE *)*((void *)result + 1);
  if (0xAAAAAAAAAAAAAAABLL * ((v15 - v9) >> 3) >= a4) {
    goto LABEL_16;
  }
  unint64_t v16 = &__src[8 * ((v15 - v9) >> 3)];
  if (v15 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, v15 - v9);
    BOOL v9 = (char *)*v13;
  }

  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    int v18 = v9;
    unsigned int v19 = v16;
LABEL_18:
    uint64_t result = (char *)memmove(v18, v19, v17);
  }

uint64_t sub_1002DFFE0(void *a1)
{
  unint64_t v2 = (void **)a1[1];
  unint64_t v3 = (void **)a1[2];
  a1[5] = 0LL;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      unint64_t v3 = (void **)a1[2];
      unint64_t v2 = (void **)(a1[1] + 8LL);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }

    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }

  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 23LL;
  }

  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 46LL;
  }

  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    unsigned int v7 = *v2++;
    operator delete(v7);
  }

  return sub_100030AF0((uint64_t)a1);
}

void sub_1002E0074(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x2E;
  unint64_t v4 = v2 - 46;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unsigned int v7 = (void *)a1[1];
    uint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    BOOL v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)uint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      char v34 = (char *)sub_1000472C0(v5, v33);
      uint64_t v35 = &v34[8 * (v33 >> 2)];
      char v37 = &v34[8 * v36];
      char v38 = (uint64_t *)a1[1];
      uint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        uint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        double v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)double v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_1002E033C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1002E0388(uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0x2E) {
    a2 = 1;
  }
  if (v2 < 0x5C) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8LL;
    *(void *)(a1 + 32) -= 46LL;
  }

  return v4 ^ 1u;
}

void sub_1002E03E4()
{
}

void sub_1002E03F8(uint64_t a1, uint64_t a2, double a3, double a4, double a5, double a6, double a7)
{
  if (*(_BYTE *)(a2 + 192))
  {
    uint64_t v9 = a2 + 8;
    uint64_t v10 = (__int128 *)(a1 + 56);
    if (*(_BYTE *)(a1 + 240))
    {
      __int128 v11 = *(_OWORD *)v9;
      __int128 v12 = *(_OWORD *)(v9 + 16);
      __int128 v13 = *(_OWORD *)(v9 + 48);
      *(_OWORD *)(a1 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = *(_OWORD *)(v9 + 32);
      *(_OWORD *)(a1 + 104) = v13;
      __int128 *v10 = v11;
      *(_OWORD *)(a1 + 72) = v12;
      __int128 v14 = *(_OWORD *)(v9 + 64);
      __int128 v15 = *(_OWORD *)(v9 + 80);
      __int128 v16 = *(_OWORD *)(v9 + 112);
      *(_OWORD *)(a1 + 152) = *(_OWORD *)(v9 + 96);
      *(_OWORD *)(a1 + 16_Block_object_dispose((const void *)(v1 - 112), 8) = v16;
      *(_OWORD *)(a1 + 120) = v14;
      *(_OWORD *)(a1 + 136) = v15;
      __int128 v17 = *(_OWORD *)(v9 + 128);
      __int128 v18 = *(_OWORD *)(v9 + 144);
      __int128 v19 = *(_OWORD *)(v9 + 160);
      *(void *)(a1 + 232) = *(void *)(v9 + 176);
      *(_OWORD *)(a1 + 200) = v18;
      *(_OWORD *)(a1 + 216) = v19;
      *(_OWORD *)(a1 + 184) = v17;
    }

    else
    {
      __int128 v20 = *(_OWORD *)v9;
      __int128 v21 = *(_OWORD *)(v9 + 16);
      __int128 v22 = *(_OWORD *)(v9 + 48);
      *(_OWORD *)(a1 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = *(_OWORD *)(v9 + 32);
      *(_OWORD *)(a1 + 104) = v22;
      __int128 *v10 = v20;
      *(_OWORD *)(a1 + 72) = v21;
      __int128 v23 = *(_OWORD *)(v9 + 64);
      __int128 v24 = *(_OWORD *)(v9 + 80);
      __int128 v25 = *(_OWORD *)(v9 + 112);
      *(_OWORD *)(a1 + 152) = *(_OWORD *)(v9 + 96);
      *(_OWORD *)(a1 + 16_Block_object_dispose((const void *)(v1 - 112), 8) = v25;
      *(_OWORD *)(a1 + 120) = v23;
      *(_OWORD *)(a1 + 136) = v24;
      __int128 v26 = *(_OWORD *)(v9 + 128);
      __int128 v27 = *(_OWORD *)(v9 + 144);
      __int128 v28 = *(_OWORD *)(v9 + 160);
      *(void *)(a1 + 232) = *(void *)(v9 + 176);
      *(_OWORD *)(a1 + 200) = v27;
      *(_OWORD *)(a1 + 216) = v28;
      *(_OWORD *)(a1 + 184) = v26;
      *(_BYTE *)(a1 + 240) = 1;
    }

    if (!*(_BYTE *)(a2 + 192)) {
      sub_100006080();
    }
    sub_1002E4404(a1 + 248, (__int128 *)v9, v30, a7);
    if (v31)
    {
      uint64_t v29 = *(void *)(a1 + 48);
      if (!v29
        || v30[0]
         - *(double *)(*(void *)(*(void *)(a1 + 16) + 8 * ((v29 + *(void *)(a1 + 40) - 1) / 0x38uLL))
                     + 72 * ((v29 + *(void *)(a1 + 40) - 1) % 0x38uLL)) >= 0.25)
      {
        sub_1002E054C((void *)(a1 + 8), (uint64_t)v30);
      }
    }
  }

uint64_t sub_1002E054C(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 56 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_1002E0D34(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x38)) + 72 * (v7 % 0x38);
  *(_OWORD *)unint64_t v8 = *(_OWORD *)a2;
  __int128 v9 = *(_OWORD *)(a2 + 16);
  __int128 v10 = *(_OWORD *)(a2 + 32);
  __int128 v11 = *(_OWORD *)(a2 + 48);
  *(void *)(v8 + 64) = *(void *)(a2 + 64);
  *(_OWORD *)(v8 + 32) = v10;
  *(_OWORD *)(v8 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v11;
  *(_OWORD *)(v8 + 16) = v9;
  uint64_t v12 = a1[4];
  uint64_t v13 = a1[5] + 1LL;
  a1[5] = v13;
  unint64_t v14 = v12 + v13;
  uint64_t v15 = a1[1];
  __int128 v16 = (void *)(v15 + 8 * (v14 / 0x38));
  uint64_t v17 = *v16 + 72 * (v14 % 0x38);
  if (a1[2] == v15) {
    uint64_t v17 = 0LL;
  }
  if (v17 == *v16) {
    uint64_t v17 = *(v16 - 1) + 4032LL;
  }
  return v17 - 72;
}

void sub_1002E064C(void *a1, uint64_t a2, double a3, double a4, double a5, double a6, double a7)
{
  if (v11)
  {
    sub_1002E0704((uint64_t)a1);
  }

  else if (v10)
  {
    uint64_t v8 = a1[6];
    if (!v8
      || v9[0] - *(double *)(*(void *)(a1[2] + 8 * ((v8 + a1[5] - 1) / 0x38uLL)) + 72 * ((v8 + a1[5] - 1) % 0x38uLL)) >= 0.25)
    {
      sub_1002E054C(a1 + 1, (uint64_t)v9);
    }
  }

void sub_1002E0704(uint64_t a1)
{
  unint64_t v2 = *(void ***)(a1 + 16);
  uint64_t v3 = *(void *)(a1 + 24);
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  unint64_t v4 = v3 - (void)v2;
  if (v4 >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v5 = *(void *)(a1 + 24);
      unint64_t v2 = (void **)(*(void *)(a1 + 16) + 8LL);
      *(void *)(a1 + 16) = v2;
      unint64_t v4 = v5 - (void)v2;
    }

    while (v4 > 0x10);
  }

  if (v4 >> 3 == 1)
  {
    uint64_t v6 = 28LL;
  }

  else
  {
    if (v4 >> 3 != 2) {
      goto LABEL_8;
    }
    uint64_t v6 = 56LL;
  }

  *(void *)(a1 + 40) = v6;
LABEL_8:
  if (*(_BYTE *)(a1 + 240)) {
    *(_BYTE *)(a1 + 240) = 0;
  }
}

uint64_t sub_1002E0784(uint64_t a1, double *a2, uint64_t a3, int a4)
{
  if (!*(_BYTE *)(a3 + 208)) {
    return 0LL;
  }
  unint64_t v5 = *(void *)(a1 + 48);
  if (v5 < 5
    || *a2
     - *(double *)(*(void *)(*(void *)(a1 + 16) + 8 * ((v5 + *(void *)(a1 + 40) - 1) / 0x38))
                 + 72 * ((v5 + *(void *)(a1 + 40) - 1) % 0x38)) > 5.0)
  {
    return 2 * (*(_BYTE *)a1 == 0);
  }

  stat __p = 0LL;
  uint64_t v60 = 0LL;
  uint64_t v61 = 0LL;
  if ((sub_1002E0C34(a1, a3, (uint64_t)a2, &v58) & 1) != 0)
  {
    unint64_t v8 = *(void *)(a1 + 40);
    uint64_t v9 = *(void *)(a1 + 16);
    uint64_t v10 = *(void *)(a1 + 24);
    char v11 = (void *)(v9 + 8 * (v8 / 0x38));
    int v56 = a4;
    if (v10 == v9) {
      unint64_t v12 = 0LL;
    }
    else {
      unint64_t v12 = *v11 + 72 * (v8 % 0x38);
    }
LABEL_11:
    uint64_t v57 = v11;
    while (1)
    {
      if (v10 == v9)
      {
        unint64_t v14 = 0LL;
      }

      else
      {
        unint64_t v13 = *(void *)(a1 + 48) + *(void *)(a1 + 40);
        unint64_t v14 = *(void *)(v9 + 8 * (v13 / 0x38)) + 72 * (v13 % 0x38);
      }

      if (v12 == v14) {
        break;
      }
      uint64_t v15 = v12 - *v11;
      unint64_t v16 = 0x8E38E38E38E38E39LL * (v15 >> 3);
      if (v15 < -71)
      {
        unint64_t v22 = 54 - v16;
        unint64_t v23 = (54 - v16) / 0x38;
        __int128 v19 = &v11[-v23];
        uint64_t v20 = *v19;
        uint64_t v21 = *v19 + 72 * (56 * v23 - v22) + 3960;
      }

      else
      {
        unint64_t v17 = v16 + 1;
        unint64_t v18 = (v16 + 1) / 0x38;
        __int128 v19 = &v11[v18];
        uint64_t v20 = *v19;
        uint64_t v21 = *v19 + 72 * (v17 - 56 * v18);
      }

      while (1)
      {
        if (v10 == v9)
        {
          unint64_t v47 = 0LL;
        }

        else
        {
          unint64_t v46 = *(void *)(a1 + 48) + *(void *)(a1 + 40);
          unint64_t v47 = *(void *)(v9 + 8 * (v46 / 0x38)) + 72 * (v46 % 0x38);
        }

        if (v21 == v47) {
          break;
        }
        double v24 = 0.0;
        for (uint64_t i = 16LL; i != 40; i += 8LL)
        {
          double v26 = *(double *)(v12 + i) - *(double *)(v21 + i);
          double v24 = v24 + v26 * v26;
        }

        double v27 = sqrt(v24);
        if (v27 > 2.0 && v27 < 15.0)
        {
          uint64_t v29 = 0LL;
          double v30 = 0.0;
          do
          {
            float64_t v31 = v58.f64[v29] - *(double *)(v21 + 16 + v29 * 8);
            double v30 = v30 + v31 * v31;
            ++v29;
          }

          while (v29 != 3);
          uint64_t v32 = 0LL;
          double v33 = 0.0;
          do
          {
            double v33 = v33
                + (v58.f64[v32] - *(double *)(v12 + v32 * 8 + 16)) * (v58.f64[v32] - *(double *)(v12 + v32 * 8 + 16));
            ++v32;
          }

          while (v32 != 3);
          double v34 = fabs(sqrt(v30) - sqrt(v33) + *(double *)(v12 + 8) - *(double *)(v21 + 8));
          uint64_t v35 = v60;
          if (v60 >= v61)
          {
            char v37 = (double *)__p;
            uint64_t v38 = ((char *)v60 - (_BYTE *)__p) >> 3;
            unint64_t v39 = v38 + 1;
            uint64_t v40 = (char *)v61 - (_BYTE *)__p;
            else {
              unint64_t v41 = v39;
            }
            if (v41)
            {
              uint64_t v42 = (char *)sub_1000472C0((uint64_t)&v61, v41);
              char v37 = (double *)__p;
              uint64_t v35 = v60;
            }

            else
            {
              uint64_t v42 = 0LL;
            }

            uint64_t v43 = (double *)&v42[8 * v38];
            *uint64_t v43 = v34;
            uint64_t v36 = v43 + 1;
            while (v35 != v37)
            {
              uint64_t v44 = *((void *)v35-- - 1);
              *((void *)v43-- - 1) = v44;
            }

            stat __p = v43;
            uint64_t v60 = v36;
            uint64_t v61 = (double *)&v42[8 * v41];
            if (v37) {
              operator delete(v37);
            }
          }

          else
          {
            double *v60 = v34;
            uint64_t v36 = v35 + 1;
          }

          uint64_t v60 = v36;
          uint64_t v20 = *v19;
        }

        v21 += 72LL;
        if (v21 - v20 == 4032)
        {
          uint64_t v45 = v19[1];
          ++v19;
          uint64_t v20 = v45;
          uint64_t v21 = v45;
        }

        uint64_t v9 = *(void *)(a1 + 16);
        uint64_t v10 = *(void *)(a1 + 24);
      }

      v12 += 72LL;
      char v11 = v57;
      if (v12 - *v57 == 4032)
      {
        char v11 = v57 + 1;
        unint64_t v12 = v57[1];
        goto LABEL_11;
      }
    }

    int v48 = (double *)__p;
    if ((unint64_t)((char *)v60 - (_BYTE *)__p) >= 0x28)
    {
      unint64_t v49 = ((char *)v60 - (_BYTE *)__p) >> 3;
      *(_BYTE *)(a1 + 1) = 1;
      if (v49 <= 1) {
        uint64_t v50 = 1LL;
      }
      else {
        uint64_t v50 = v49;
      }
      double v51 = 0.0;
      do
      {
        double v52 = *v48++;
        double v51 = v51 + v52 * v52;
        --v50;
      }

      while (v50);
      double v53 = v51 / (double)v49;
      if (v53 < 3.0) {
        char v54 = v56;
      }
      else {
        char v54 = 0;
      }
      if (v53 < 0.5 || (v54 & 1) != 0)
      {
        *(_BYTE *)a1 = 0;
        uint64_t v6 = 1LL;
      }

      else
      {
        if (v56) {
          sub_1002E0704(a1);
        }
        uint64_t v6 = 0LL;
        *(_BYTE *)a1 = 1;
      }
    }

    else
    {
      uint64_t v6 = 2 * (*(_BYTE *)a1 == 0);
    }
  }

  else
  {
    uint64_t v6 = 2LL;
  }

  if (__p)
  {
    uint64_t v60 = (double *)__p;
    operator delete(__p);
  }

  return v6;
}

void sub_1002E0C10( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002E0C34(uint64_t a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  if (*(_DWORD *)(a3 + 80) != 2) {
    return 0LL;
  }
  float v4 = *(float *)(a2 + 24);
  BOOL v5 = !*(_BYTE *)(a2 + 208) || *(_BYTE *)(a2 + 192) == 0;
  if (v5 || v4 == 1.1755e-38) {
    return 0LL;
  }
  double v9 = v4;
  __double2 v10 = __sincos_stret(*(double *)(a2 + 200) * 3.14159265 / 180.0);
  float v11 = v10.__cosval * v9;
  float v12 = v10.__sinval * v9;
  float v18 = v11;
  float v19 = v12;
  v20.columns[0] = (simd_float2)sub_1002CA7B4((float32x4_t *)a3);
  simd_float2x2 v13 = __invert_f2(v20);
  float32x2_t v14 = vmla_n_f32(vmul_n_f32((float32x2_t)v13.columns[0], v18), (float32x2_t)v13.columns[1], v19);
  __int128 v15 = *(_OWORD *)(a3 + 64);
  float v16 = COERCE_FLOAT(*(void *)(a3 + 72));
  *(float *)&__int128 v15 = *(float *)&v15 + v14.f32[1];
  *a4 = vcvtq_f64_f32(*(float32x2_t *)&v15);
  a4[1].f64[0] = (float)(v16 + v14.f32[0]);
  return 1LL;
}

uint64_t sub_1002E0D1C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 1);
}

uint64_t sub_1002E0D24(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 2);
}

uint64_t sub_1002E0D2C(uint64_t result, char a2)
{
  *(_BYTE *)(result + 2) = a2;
  return result;
}

void sub_1002E0D34(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x38;
  unint64_t v4 = v2 - 56;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    double v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      double v34 = (char *)sub_1000472C0(v5, v33);
      uint64_t v35 = &v34[8 * (v33 >> 2)];
      char v37 = &v34[8 * v36];
      uint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        unint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)unint64_t v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_1002E0FFC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1002E1048()
{
  qword_1007FE908 = 0LL;
  qword_1007FE910 = 0LL;
  qword_1007FE918 = 0LL;
  uint64_t v0 = operator new(0x40uLL);
  qword_1007FE910 = (uint64_t)(v0 + 4);
  qword_1007FE918 = (uint64_t)(v0 + 4);
  _OWORD *v0 = xmmword_10042E580;
  v0[1] = unk_10042E590;
  v0[2] = xmmword_10042E5A0;
  v0[3] = unk_10042E5B0;
  qword_1007FE908 = (uint64_t)v0;
  __cxa_atexit((void (*)(void *))sub_100028CC4, &qword_1007FE908, (void *)&_mh_execute_header);
  qword_1007FE928 = 0LL;
  unk_1007FE930 = 0LL;
  qword_1007FE920 = 0LL;
  uint64_t v1 = operator new(0x10uLL);
  qword_1007FE928 = (uint64_t)(v1 + 1);
  unk_1007FE930 = v1 + 1;
  _OWORD *v1 = xmmword_10042E5C0;
  qword_1007FE920 = (uint64_t)v1;
  return __cxa_atexit((void (*)(void *))sub_100028CC4, &qword_1007FE920, (void *)&_mh_execute_header);
}

uint64_t sub_1002E1104@<X0>(uint64_t a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  *(void *)((char *)&v12[2] + *(void *)(v12[0] - 24LL)) = 2LL;
  unint64_t v4 = sub_100046B94(&v13, (uint64_t)"<", 1LL);
  int v5 = *(char *)(a1 + 23);
  if (v5 >= 0) {
    uint64_t v6 = a1;
  }
  else {
    uint64_t v6 = *(void *)a1;
  }
  if (v5 >= 0) {
    uint64_t v7 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    uint64_t v7 = *(void *)(a1 + 8);
  }
  unint64_t v8 = sub_100046B94(v4, v6, v7);
  sub_100046B94(v8, (uint64_t)" | ", 3LL);
  double v9 = (void *)std::ostream::operator<<(*(float *)(a1 + 24));
  sub_100046B94(v9, (uint64_t)">", 1LL);
  std::stringbuf::str(a2, &v14);
  *(void *)((char *)v12
  uint64_t v13 = v10;
  std::streambuf::~streambuf(&v14);
  return std::ios::~ios(&v15);
}

void sub_1002E121C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_1002E1230(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 40) = 0;
  *(void *)a1 = off_1007BCEF8;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  uint64_t v6 = (uint64_t *)(a1 + 48);
  *(void *)(a1 + 56) = 0LL;
  uint64_t v7 = operator new(0x26B0uLL);
  sub_100305AF4(v7, a2);
  uint64_t v8 = *v6;
  uint64_t *v6 = (uint64_t)v7;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 368LL))(v8);
  }
  double v9 = operator new(0x280uLL);
  sub_1002CEC84(v9, a3);
  uint64_t v10 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = v9;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 368LL))(v10);
  }
  return a1;
}

void sub_1002E12E4(_Unwind_Exception *a1)
{
  uint64_t v5 = *(void *)(v1 + 56);
  *(void *)(v1 + 56) = 0LL;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 368LL))(v5);
  }
  uint64_t v6 = *v3;
  *BOOL v3 = 0LL;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 368LL))(v6);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1002E134C(uint64_t a1)
{
  return (***(uint64_t (****)(void))(a1 + 48))(*(void *)(a1 + 48));
}

uint64_t sub_1002E135C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 8LL))(*(void *)(a1 + 56));
}

uint64_t sub_1002E136C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 56) + 16LL))(*(void *)(a1 + 56), a2);
}

uint64_t sub_1002E13AC(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 24LL))(*(void *)(a1 + 48), a2);
}

uint64_t sub_1002E13EC(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 48LL))(*(void *)(a1 + 48), a2);
}

uint64_t sub_1002E142C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 272LL))(*(void *)(a1 + 48));
}

uint64_t sub_1002E143C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 72LL))(*(void *)(a1 + 56));
}

uint64_t sub_1002E144C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 208LL))(*(void *)(a1 + 56));
}

uint64_t sub_1002E145C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 224LL))(*(void *)(a1 + 56));
}

uint64_t sub_1002E146C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 240LL))(*(void *)(a1 + 56));
}

uint64_t sub_1002E147C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 256LL))(*(void *)(a1 + 56));
}

uint64_t sub_1002E148C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 96LL))(*(void *)(a1 + 56));
}

uint64_t sub_1002E149C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 296LL))(*(void *)(a1 + 56));
}

uint64_t sub_1002E14AC()
{
  return 1LL;
}

uint64_t sub_1002E14B4()
{
  return 1LL;
}

uint64_t sub_1002E14BC()
{
  return 1LL;
}

uint64_t sub_1002E14C4()
{
  return 1LL;
}

uint64_t sub_1002E14CC()
{
  return 1LL;
}

uint64_t sub_1002E14D4()
{
  return 1LL;
}

uint64_t sub_1002E14DC()
{
  return 0LL;
}

uint64_t sub_1002E14E4()
{
  return 0LL;
}

uint64_t sub_1002E14EC()
{
  return 1LL;
}

uint64_t sub_1002E14F4()
{
  return 1LL;
}

uint64_t sub_1002E14FC()
{
  return 1LL;
}

uint64_t sub_1002E1504()
{
  return 1LL;
}

uint64_t sub_1002E150C()
{
  return 1LL;
}

uint64_t sub_1002E1514()
{
  return 1LL;
}

uint64_t sub_1002E151C()
{
  return 1LL;
}

uint64_t sub_1002E1524()
{
  return 1LL;
}

void sub_1002E1530(void *a1)
{
  uint64_t v1 = sub_1002E1544(a1);
  operator delete(v1);
}

void *sub_1002E1544(void *a1)
{
  *a1 = off_1007BCEF8;
  uint64_t v2 = a1[7];
  a1[7] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 368LL))(v2);
  }
  uint64_t v3 = a1[6];
  a1[6] = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 368LL))(v3);
  }
  return a1;
}

uint64_t sub_1002E15A0()
{
  qword_1007FE938 = 0LL;
  qword_1007FE940 = 0LL;
  qword_1007FE948 = 0LL;
  uint64_t v0 = operator new(0x40uLL);
  qword_1007FE940 = (uint64_t)(v0 + 4);
  qword_1007FE948 = (uint64_t)(v0 + 4);
  _OWORD *v0 = xmmword_10042E5D0;
  v0[1] = unk_10042E5E0;
  v0[2] = xmmword_10042E5F0;
  v0[3] = unk_10042E600;
  qword_1007FE938 = (uint64_t)v0;
  __cxa_atexit((void (*)(void *))sub_100028CC4, &qword_1007FE938, (void *)&_mh_execute_header);
  qword_1007FE958 = 0LL;
  unk_1007FE960 = 0LL;
  qword_1007FE950 = 0LL;
  uint64_t v1 = operator new(0x10uLL);
  qword_1007FE958 = (uint64_t)(v1 + 1);
  unk_1007FE960 = v1 + 1;
  _OWORD *v1 = xmmword_10042E610;
  qword_1007FE950 = (uint64_t)v1;
  return __cxa_atexit((void (*)(void *))sub_100028CC4, &qword_1007FE950, (void *)&_mh_execute_header);
}

uint64_t sub_1002E165C(uint64_t a1)
{
  *(_BYTE *)a1 = 0;
  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_OWORD *)(a1 + 16) = xmmword_10042E660;
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + 40) = &off_1007BC4C0;
  uint64_t v2 = a1 + 40;
  *(void *)(a1 + 64) = 0x100000003LL;
  *(_OWORD *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = xmmword_10042DB70;
  *(void *)(a1 + 72) = a1 + 80;
  *(void *)(a1 + 104) = &off_1007BC4C0;
  uint64_t v3 = a1 + 104;
  *(void *)(a1 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = 0x100000003LL;
  *(_OWORD *)(a1 + 112) = xmmword_10042DB70;
  *(void *)(a1 + 136) = a1 + 144;
  *(void *)(a1 + 16_Block_object_dispose((const void *)(v1 - 112), 8) = &off_1007BC4C0;
  uint64_t v4 = a1 + 168;
  *(void *)(a1 + 192) = 0x100000003LL;
  *(_OWORD *)(a1 + 176) = xmmword_10042DB70;
  *(void *)(a1 + 200) = a1 + 208;
  *(_OWORD *)(a1 + 232) = xmmword_10042E670;
  *(void *)(a1 + 24_Block_object_dispose((const void *)(v1 - 112), 8) = 0xBFFBB67AE8584CAALL;
  double v5 = erf(1.73205081);
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(void *)(a1 + 28_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  *(double *)(a1 + 296) = v5;
  double v6 = erf(-1.73205081);
  unsigned int v7 = 0;
  *(_OWORD *)(a1 + 312) = xmmword_10042E6E0;
  *(_OWORD *)(a1 + 32_Block_object_dispose((const void *)(v1 - 112), 8) = unk_10042E6F0;
  *(double *)(a1 + 304) = v6;
  *(void *)(a1 + 344) = 0x3FC5555555555555LL;
  *(_OWORD *)(a1 + 352) = xmmword_10042E708;
  *(_OWORD *)(a1 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = unk_10042E718;
  *(void *)(a1 + 384) = 0x3FC5555555555555LL;
  do
  {
    *(void *)sub_1002CB32C(v3, v7) = 0LL;
    *(void *)sub_1002CB32C(v4, v7) = 0LL;
    *(void *)sub_1002CB32C(v2, v7++) = 0LL;
  }

  while (v7 != 3);
  uint64_t v8 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v10 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_rangefilter,SyntheticApertureRangeFilter constructed",  v10,  2u);
  }

  return a1;
}

void sub_1002E1810(_Unwind_Exception *a1)
{
  *uint64_t v3 = off_1007AED90;
  void *v2 = off_1007AED90;
  void *v1 = off_1007AED90;
  _Unwind_Resume(a1);
}

void sub_1002E182C(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  double v6 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    double v7 = *(double *)a2;
    uint64_t v8 = *(void *)(a2 + 8);
    uint64_t v9 = *(void *)(a2 + 16);
    uint64_t v10 = *(void *)(a2 + 96);
    uint64_t v11 = *(void *)(a2 + 104);
    uint64_t v12 = *(void *)(a2 + 112);
    *(_DWORD *)__int128 buf = 134219264;
    double v47 = v7;
    __int16 v48 = 2048;
    uint64_t v49 = v8;
    __int16 v50 = 2048;
    uint64_t v51 = v9;
    __int16 v52 = 2048;
    uint64_t v53 = v10;
    __int16 v54 = 2048;
    uint64_t v55 = v11;
    __int16 v56 = 2048;
    uint64_t v57 = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_rangefilter,Measurement added with VIO: timestamp %3.2f s, range %3.2f m, uncertainty %3.2f m, position [ %3.2f, %3.2f, %3.2f] m",  buf,  0x3Eu);
  }

  uint64_t v40 = 0x100000003LL;
  uint64_t v38 = &off_1007BC4C0;
  __int128 v39 = xmmword_10042DB70;
  unint64_t v41 = &v42;
  sub_1002CAEDC(&v38, 3, 1);
  sub_1002CAF28((uint64_t)&v38, 0.0);
  uint64_t v35 = 0x100000004LL;
  unint64_t v33 = &off_1007BC550;
  __int128 v34 = xmmword_10042DB80;
  uint64_t v36 = &v37;
  sub_1002CAEDC(&v33, 4, 1);
  sub_1002CAF28((uint64_t)&v33, 0.0);
  for (uint64_t i = 0LL; i != 3; ++i)
  {
    uint64_t v14 = a2 + 8 * i;
    uint64_t v15 = *(void *)(v14 + 96);
    *(void *)sub_1002CB32C((uint64_t)&v38, i) = v15;
    uint64_t v16 = *(void *)(v14 + 120);
    *(void *)sub_1002CB32C((uint64_t)&v33, i) = v16;
  }

  uint64_t v17 = *(void *)(a2 + 144);
  *(void *)sub_1002CB32C((uint64_t)&v33, 3u) = v17;
  sub_1003198FC((uint64_t)&v33, (uint64_t)buf);
  uint64_t v44 = 0x100000003LL;
  *(void *)uint64_t v43 = &off_1007BC4C0;
  *(_OWORD *)&v43[8] = xmmword_10042DB70;
  v45[0] = &v45[1];
  sub_1002CB548((uint64_t)buf, a1 + 104, (uint64_t)v43);
  uint64_t v30 = 0x100000003LL;
  uint64_t v28 = &off_1007BC4C0;
  __int128 v29 = xmmword_10042DB70;
  __int128 v31 = &v32;
  sub_1002CC25C((uint64_t)&v38, (uint64_t)v43, (uint64_t)&v28);
  if (*(_BYTE *)a1)
  {
    int v18 = *(_DWORD *)(a1 + 8);
    if (v18 == 1)
    {
      sub_1002E1D30(a1, (uint64_t)&v28);
    }

    else if (!v18)
    {
      float v19 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v43 = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_rangefilter,Range filter transitioning from non-VIO to VIO mode",  v43,  2u);
      }

      sub_1002E1C34(a1, *(double *)a2);
      sub_1002CBDC8(a1 + 40, (uint64_t)&v28);
    }

    sub_1002E1FC8(a1, 0, *(double *)(a2 + 8), *(double *)(a2 + 16));
  }

  else
  {
    *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 8);
    sub_1002CBDC8(a1 + 40, (uint64_t)&v28);
    *(_BYTE *)a1 = 1;
    int64_t v20 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = *(void *)(a1 + 16);
      uint64_t v22 = *(void *)(a1 + 24);
      *(_DWORD *)uint64_t v43 = 134218240;
      *(void *)&v43[4] = v21;
      *(_WORD *)&v43[12] = 2048;
      *(void *)&v43[14] = v22;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_rangefilter,Initializing range filter with VIO: range %f m, uncertainty %f m",  v43,  0x16u);
    }
  }

  double v23 = *(double *)a2;
  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = 1;
  *(double *)(a1 + 32) = v23;
  uint64_t v24 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v25 = *(void *)(a1 + 16);
    uint64_t v26 = *(void *)(a1 + 24);
    *(_DWORD *)uint64_t v43 = 134218754;
    *(double *)&v43[4] = v23;
    *(_WORD *)&v43[12] = 2048;
    *(void *)&v43[14] = v25;
    *(_WORD *)&v43[22] = 2048;
    uint64_t v44 = v26;
    LOWORD(v45[0]) = 2080;
    *(void *)((char *)v45 + 2) = "YES";
    _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_rangefilter,Filter state after meas with VIO: timestamp %3.2f s, range %3.2f m, uncertainty %3.2f m, with VIO: %s",  v43,  0x2Au);
  }

  __int128 v27 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)a3 = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(a3 + 16) = v27;
  *(double *)(a3 + _Block_object_dispose((const void *)(v1 - 112), 8) = fmax(*(double *)(a3 + 8), 0.0);
}

void sub_1002E1C34(uint64_t a1, double a2)
{
  double v3 = *(double *)(a1 + 32);
  double v4 = *(double *)(a1 + 24) + (a2 - v3) * 0.25;
  *(double *)(a1 + 24) = v4;
  double v5 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 16);
    if (*(_DWORD *)(a1 + 8) == 1) {
      double v7 = "YES";
    }
    else {
      double v7 = "NO";
    }
    int v8 = 134218754;
    double v9 = v3;
    __int16 v10 = 2048;
    uint64_t v11 = v6;
    __int16 v12 = 2048;
    double v13 = v4;
    __int16 v14 = 2080;
    uint64_t v15 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_rangefilter,Filter state after propagation with time: timestamp %3.2f s, range %3.2f m, uncertainty %3.2f m, with VIO: %s",  (uint8_t *)&v8,  0x2Au);
  }

void sub_1002E1D30(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 40;
  uint64_t v21 = 0x100000003LL;
  float v19 = &off_1007BC4C0;
  __int128 v20 = xmmword_10042DB70;
  uint64_t v22 = &v23;
  sub_1002CB44C(a2, a1 + 40, (uint64_t)&v19);
  uint64_t v31 = 0x100000003LL;
  __int128 v29 = &off_1007BC4C0;
  __int128 v30 = xmmword_10042DB70;
  uint64_t v32 = &v33;
  uint64_t v35 = 0x100000134LL;
  *(void *)__int128 buf = &off_1007BC598;
  *(_OWORD *)&uint8_t buf[8] = xmmword_10042DB90;
  v36[0] = &v36[1];
  uint64_t v26 = 0x100000003LL;
  uint64_t v24 = &off_1007BC4C0;
  __int128 v25 = xmmword_10042DB70;
  __int128 v27 = &v28;
  sub_1002CB6A8((uint64_t)&v19, (uint64_t)&v29, (uint64_t)buf, (uint64_t)&v24, "2");
  double v6 = v5;
  sub_1002CBDC8(v4, a2);
  double v8 = *(double *)(a1 + 16);
  double v7 = *(double *)(a1 + 24);
  if (v8 + v7 * -1.73205081 <= 0.0)
  {
    double v15 = sqrt(v6 * 0.5 * (v6 * 0.5) + v7 * v7);
    *(double *)(a1 + 24) = v15;
  }

  else
  {
    uint64_t v9 = 0LL;
    double v10 = 0.0;
    do
    {
      double v11 = v8 + v7 * *(double *)(a1 + v9 + 232);
      double v12 = sqrt(v6 * v6 + v11 * v11 + v6 * -2.0 * v11 * *(double *)(a1 + v9 + 272));
      *(double *)&buf[v9] = v12;
      double v10 = v10 + *(double *)(a1 + v9 + 312) * v12;
      v9 += 8LL;
    }

    while (v9 != 40);
    uint64_t v13 = 0LL;
    double v14 = 0.0;
    do
    {
      double v14 = v14 + *(double *)(a1 + 352 + v13) * (*(double *)&buf[v13] - v10) * (*(double *)&buf[v13] - v10);
      v13 += 8LL;
    }

    while (v13 != 40);
    double v15 = sqrt(v14);
    *(double *)(a1 + 16) = v10;
    *(double *)(a1 + 24) = v15;
    double v8 = v10;
  }

  uint64_t v16 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = *(void *)(a1 + 32);
    if (*(_DWORD *)(a1 + 8) == 1) {
      int v18 = "YES";
    }
    else {
      int v18 = "NO";
    }
    *(_DWORD *)__int128 buf = 134218754;
    *(void *)&uint8_t buf[4] = v17;
    *(_WORD *)&_BYTE buf[12] = 2048;
    *(double *)&buf[14] = v8;
    *(_WORD *)&buf[22] = 2048;
    uint64_t v35 = *(void *)&v15;
    LOWORD(v36[0]) = 2080;
    *(void *)((char *)v36 + 2) = v18;
    _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_rangefilter,Filter state after propagation with pose: timestamp %3.2f s, range %3.2f m, uncertainty %3.2f m, with VIO: %s",  buf,  0x2Au);
  }

void sub_1002E1FC8(uint64_t a1, int a2, double a3, double a4)
{
  double v7 = a4 * a4;
  double v9 = *(double *)(a1 + 16);
  double v8 = *(double *)(a1 + 24);
  double v10 = a4 * a4 + v8 * v8;
  double v11 = sqrt(v10);
  double v12 = (a3 - v9) / v11;
  if (a2 && v12 > 8.0)
  {
    uint64_t v13 = (os_log_s *)qword_1008000A0;
    if (!os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v16 = 134218496;
    double v17 = v9;
    __int16 v18 = 2048;
    double v19 = a3;
    __int16 v20 = 2048;
    double v21 = v12;
    double v14 = "#sa_algo_rangefilter,LoS->nLoS event detected by the range filter for a moving target: Previous range %f m, Cu"
          "rrent range %f m, Normalized change %f";
LABEL_9:
    _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, v14, (uint8_t *)&v16, 0x20u);
    return;
  }

  if ((a2 & 1) == 0 && v12 > 6.0)
  {
    uint64_t v13 = (os_log_s *)qword_1008000A0;
    if (!os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v16 = 134218496;
    double v17 = v9;
    __int16 v18 = 2048;
    double v19 = a3;
    __int16 v20 = 2048;
    double v21 = v12;
    double v14 = "#sa_algo_rangefilter,LoS->nLoS event detected by the range filter for a static target: Previous range %f m, Cu"
          "rrent range %f m, Normalized change %f";
    goto LABEL_9;
  }

  if (v12 >= -6.0)
  {
    *(double *)(a1 + 16) = (v7 * v9 + a3 * (v8 * v8)) / v10;
    *(double *)(a1 + 24) = v8 * a4 / v11;
  }

  else
  {
    double v15 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR))
    {
      int v16 = 134218496;
      double v17 = v9;
      __int16 v18 = 2048;
      double v19 = a3;
      __int16 v20 = 2048;
      double v21 = v12;
      _os_log_error_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "#sa_algo_rangefilter,nLos->LoS event detected by the range filter: Previous range %f m, Current range %f m, Norm alized change %f",  (uint8_t *)&v16,  0x20u);
      double v15 = (os_log_s *)qword_1008000A0;
    }

    *(double *)(a1 + 16) = a3;
    *(double *)(a1 + 24) = a4;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      int v16 = 134218240;
      double v17 = a3;
      __int16 v18 = 2048;
      double v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_rangefilter,Re-initializing range filter: range %f m, uncertainty %f m",  (uint8_t *)&v16,  0x16u);
    }
  }

void sub_1002E2218(uint64_t a1@<X0>, double *a2@<X1>, int a3@<W2>, int a4@<W3>, uint64_t a5@<X8>)
{
  double v10 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    double v11 = *a2;
    uint64_t v12 = *((void *)a2 + 1);
    uint64_t v13 = *((void *)a2 + 2);
    double v14 = "YES";
    if (a3) {
      double v15 = "YES";
    }
    else {
      double v15 = "NO";
    }
    if (!a4) {
      double v14 = "NO";
    }
    int v33 = 134219010;
    double v34 = v11;
    __int16 v35 = 2048;
    uint64_t v36 = v12;
    __int16 v37 = 2048;
    uint64_t v38 = v13;
    __int16 v39 = 2080;
    uint64_t v40 = v15;
    __int16 v41 = 2080;
    uint64_t v42 = v14;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_rangefilter,Measurement added without VIO: timestamp %3.2f s, range %3.2f m, uncertainty %3.2f m, isCompa nionMoving %s, isDeviceMoving %s",  (uint8_t *)&v33,  0x34u);
  }

  if (*(_BYTE *)a1)
  {
    if ((a3 & 1) != 0 || (a4 & 1) != 0)
    {
      sub_1002E1C34(a1, *a2);
      double v19 = a2[1];
      double v20 = a2[2];
      uint64_t v21 = a1;
      int v22 = a3;
    }

    else
    {
      int v16 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        double v17 = a2[1];
        uint64_t v18 = *((void *)a2 + 2);
        int v33 = 134218240;
        double v34 = v17;
        __int16 v35 = 2048;
        uint64_t v36 = v18;
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_rangefilter,Range filter update with stationary companion and device: range %f m, uncertainty %f m",  (uint8_t *)&v33,  0x16u);
      }

      double v19 = a2[1];
      double v20 = a2[2];
      uint64_t v21 = a1;
      int v22 = 0;
    }

    sub_1002E1FC8(v21, v22, v19, v20);
  }

  else
  {
    double v23 = a2[1];
    *(double *)(a1 + 16) = v23;
    uint64_t v24 = *((void *)a2 + 2);
    *(void *)(a1 + 24) = v24;
    *(_BYTE *)a1 = 1;
    __int128 v25 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      int v33 = 134218240;
      double v34 = v23;
      __int16 v35 = 2048;
      uint64_t v36 = v24;
      _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_rangefilter,Initializing range filter without VIO: range %f m, uncertainty %f m",  (uint8_t *)&v33,  0x16u);
    }
  }

  __int128 v27 = (_DWORD *)(a1 + 8);
  int v26 = *(_DWORD *)(a1 + 8);
  *(double *)(a1 + 32) = *a2;
  uint64_t v28 = (os_log_s *)qword_1008000A0;
  if (v26 == 1 && os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v33) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_rangefilter,Range filter transitioning from VIO to non-VIO mode",  (uint8_t *)&v33,  2u);
    uint64_t v28 = (os_log_s *)qword_1008000A0;
  }

  _DWORD *v27 = 0;
  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v30 = *(void *)(a1 + 24);
    double v29 = *(double *)(a1 + 32);
    uint64_t v31 = *(void *)(a1 + 16);
    int v33 = 134218754;
    double v34 = v29;
    __int16 v35 = 2048;
    uint64_t v36 = v31;
    __int16 v37 = 2048;
    uint64_t v38 = v30;
    __int16 v39 = 2080;
    uint64_t v40 = "NO";
    _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_rangefilter,Filter state after meas without VIO: timestamp %3.2f s, range %3.2f m, uncertainty %3.2f m, with VIO: %s",  (uint8_t *)&v33,  0x2Au);
  }

  __int128 v32 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)a5 = *(_OWORD *)v27;
  *(_OWORD *)(a5 + 16) = v32;
  *(double *)(a5 + _Block_object_dispose((const void *)(v1 - 112), 8) = fmax(*(double *)(a5 + 8), 0.0);
}

uint64_t sub_1002E2520()
{
  qword_1007FE968 = 0LL;
  qword_1007FE970 = 0LL;
  qword_1007FE978 = 0LL;
  uint64_t v0 = operator new(0x40uLL);
  qword_1007FE970 = (uint64_t)(v0 + 4);
  qword_1007FE978 = (uint64_t)(v0 + 4);
  _OWORD *v0 = xmmword_10042E690;
  v0[1] = unk_10042E6A0;
  v0[2] = xmmword_10042E6B0;
  v0[3] = unk_10042E6C0;
  qword_1007FE968 = (uint64_t)v0;
  __cxa_atexit((void (*)(void *))sub_100028CC4, &qword_1007FE968, (void *)&_mh_execute_header);
  qword_1007FE988 = 0LL;
  unk_1007FE990 = 0LL;
  qword_1007FE980 = 0LL;
  uint64_t v1 = operator new(0x10uLL);
  qword_1007FE988 = (uint64_t)(v1 + 1);
  unk_1007FE990 = v1 + 1;
  _OWORD *v1 = xmmword_10042E6D0;
  qword_1007FE980 = (uint64_t)v1;
  return __cxa_atexit((void (*)(void *))sub_100028CC4, &qword_1007FE980, (void *)&_mh_execute_header);
}

_BYTE *sub_1002E25DC(_BYTE *a1)
{
  *a1 = 0;
  a1[8] = 0;
  a1[16] = 0;
  a1[64] = 0;
  a1[72] = 0;
  a1[96] = 0;
  a1[104] = 0;
  a1[152] = 0;
  a1[160] = 0;
  a1[344] = 0;
  a1[352] = 0;
  a1[368] = 0;
  a1[376] = 0;
  a1[384] = 0;
  uint64_t v2 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "#cl_algo,CLLocationBasedArrowFilter initialized",  v4,  2u);
  }

  return a1;
}

void sub_1002E2684(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 352) = 0u;
  *(_OWORD *)(a2 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_OWORD *)(a2 + 320) = 0u;
  *(_OWORD *)(a2 + 336) = 0u;
  *(_OWORD *)(a2 + 28_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_OWORD *)(a2 + 304) = 0u;
  *(_OWORD *)(a2 + 256) = 0u;
  *(_OWORD *)(a2 + 272) = 0u;
  *(_OWORD *)(a2 + 224) = 0u;
  *(_OWORD *)(a2 + 240) = 0u;
  *(_OWORD *)(a2 + 192) = 0u;
  *(_OWORD *)(a2 + 20_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_OWORD *)(a2 + 160) = 0u;
  *(_OWORD *)(a2 + 176) = 0u;
  *(_OWORD *)(a2 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_OWORD *)(a2 + 144) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_DWORD *)(a2 + 364) = 4;
  *(_BYTE *)(a2 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
  if (*(_BYTE *)(a1 + 96) && *(_BYTE *)(a1 + 152) && *(_BYTE *)(a1 + 64) && *(_BYTE *)(a1 + 384))
  {
    double v4 = *(double *)(a1 + 48);
    if (v4 > 3.0)
    {
      double v5 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_INFO))
      {
        int v46 = 134217984;
        *(double *)double v47 = v4;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "#cl_algo,#clcc,self location speed exceeds a brisk walking pace,inflating uncertainty,%.1lf",  (uint8_t *)&v46,  0xCu);
      }

      *(double *)(a1 + 40) = fmin(*(double *)(a1 + 40), 200.0);
    }

    double v6 = *(double *)(a1 + 136);
    if (v6 > 3.0)
    {
      double v7 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_INFO))
      {
        int v46 = 134217984;
        *(double *)double v47 = v6;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_INFO,  "#cl_algo,#clcc,peer location speed exceeds a brisk walking pace,inflating uncertainty,%.1lf",  (uint8_t *)&v46,  0xCu);
      }

      *(double *)(a1 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = fmin(*(double *)(a1 + 128), 200.0);
    }

    if (!*(_BYTE *)(a1 + 384) || !*(_BYTE *)(a1 + 96)) {
      goto LABEL_68;
    }
    double v8 = *(double *)(a1 + 376);
    int v9 = *(unsigned __int8 *)(a1 + 344);
    double v10 = *(_BYTE *)(a1 + 344) ? v8 - *(double *)(a1 + 168) : INFINITY;
    if (!*(_BYTE *)(a1 + 64) || !*(_BYTE *)(a1 + 152)) {
      goto LABEL_68;
    }
    double v11 = *(double *)(a1 + 72);
    double v12 = vabdd_f64(v8, v11);
    double v13 = *(double *)(a1 + 16);
    double v14 = vabdd_f64(v8, v13);
    double v15 = *(double *)(a1 + 104);
    double v16 = vabdd_f64(v8, v15);
    double v17 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG))
    {
      if (v9) {
        uint64_t v45 = *(void *)(a1 + 168);
      }
      else {
        uint64_t v45 = 0x7FF0000000000000LL;
      }
      int v46 = 134219520;
      *(double *)double v47 = v8;
      *(_WORD *)&v47[8] = 2048;
      double v48 = v11;
      __int16 v49 = 2048;
      double v50 = v13;
      __int16 v51 = 2048;
      double v52 = v15;
      __int16 v53 = 2048;
      uint64_t v54 = v45;
      __int16 v55 = 2048;
      double v56 = v16;
      __int16 v57 = 2048;
      double v58 = v14;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEBUG,  "#cl_algo,event timestamp: %f, heading timestamp: %f, self loc timestamp: %f, peer loc timestamp: %f, range times tamp: %f, peer loc age, %.1lf, self loc age, %.1lf",  (uint8_t *)&v46,  0x48u);
    }

    if (v12 > 1.0 || v14 > 12.0 || v16 > 12.0)
    {
      uint64_t v20 = qword_1008000A0;
      if (!os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      int v46 = 134218496;
      *(double *)double v47 = v12;
      *(_WORD *)&v47[8] = 2048;
      double v48 = v14;
      __int16 v49 = 2048;
      double v50 = v16;
      uint64_t v21 = "#cl_algo,CLLocationBasedArrowFilter,data stale,not populating a solution,heading_age,%.1lf,abs_self_location"
            "_age_s,%.1lf,abs_peer_location_age_s,%.1lf";
      int v22 = (os_log_s *)v20;
      os_log_type_t v23 = OS_LOG_TYPE_DEFAULT;
      uint32_t v24 = 32;
      goto LABEL_62;
    }

    if (!*(_BYTE *)(a1 + 152)) {
      goto LABEL_68;
    }
    double DistanceCoordinates = CLClientGetDistanceCoordinates( *(double *)(a1 + 24),  *(double *)(a1 + 32),  *(double *)(a1 + 112),  *(double *)(a1 + 120));
    if (*(_BYTE *)(a1 + 344)) {
      double v19 = *(float *)(a1 + 176);
    }
    else {
      double v19 = INFINITY;
    }
    double v25 = 2.0;
    if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 384) && vabdd_f64(*(double *)(a1 + 376), *(double *)(a1 + 352)) < 12.0)
    {
      int v26 = *(_DWORD *)(a1 + 360);
      double v27 = 2.0;
      if (v26 == 1) {
        double v27 = 1.0;
      }
      if (v26) {
        double v25 = v27;
      }
      else {
        double v25 = 0.5;
      }
    }

    if (v19 + v10 * 2.0 >= DistanceCoordinates || *(_BYTE *)(a1 + 344) == 0 || v10 > 60.0) {
      double v30 = DistanceCoordinates;
    }
    else {
      double v30 = v19 + v10 * 2.0;
    }
    uint64_t v31 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_INFO))
    {
      int v46 = 134218752;
      *(double *)double v47 = DistanceCoordinates;
      *(_WORD *)&v47[8] = 2048;
      double v48 = v19;
      __int16 v49 = 2048;
      double v50 = fabs(v10);
      __int16 v51 = 2048;
      double v52 = v30;
      _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_INFO,  "#cl_algo,CLLocationBasedArrowFilter,location_range_m,%.1lf,uwb_range_m,%.1lf,abs_uwb_range_age,%.1lf,fused_range_m,%.1lf",  (uint8_t *)&v46,  0x2Au);
    }

    uint64_t v32 = *(_BYTE *)(a1 + 8) ? *(void *)a1 : 0LL;
    if (!*(_BYTE *)(a1 + 384)) {
      goto LABEL_68;
    }
    double v33 = sqrt( (*(double *)(a1 + 128) + v25 * v16) * (*(double *)(a1 + 128) + v25 * v16)
          + (*(double *)(a1 + 40) + v14 * 2.0) * (*(double *)(a1 + 40) + v14 * 2.0));
    uint64_t v34 = *(void *)(a1 + 376);
    float v35 = DistanceCoordinates;
    *(void *)(a2 + _Block_object_dispose((const void *)(v1 - 112), 8) = v32;
    *(void *)(a2 + 16) = v34;
    *(float *)(a2 + 24) = v35;
    *(_DWORD *)(a2 + 2_Block_object_dispose((const void *)(v1 - 112), 8) = 4;
    *(_BYTE *)(a2 + 56) = 0;
    *(void *)(a2 + 32) = 0LL;
    *(void *)(a2 + 40) = 0LL;
    *(_BYTE *)(a2 + 60) = 0;
    *(_BYTE *)(a2 + 64) = 0;
    *(_BYTE *)(a2 + 6_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
    *(void *)(a2 + 72) = 0LL;
    *(void *)(a2 + 80) = 0LL;
    *(_WORD *)(a2 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
    *(void *)(a2 + 96) = 0LL;
    *(void *)(a2 + 104) = 0LL;
    double v36 = v33 / 1.41421356;
    *(double *)(a2 + 112) = v33 / 1.41421356;
    *(_BYTE *)(a2 + 136) = 0;
    *(void *)(a2 + 120) = 1LL;
    *(void *)(a2 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
    *(_BYTE *)(a2 + 160) = 0;
    *(void *)(a2 + 176) = 0LL;
    *(void *)(a2 + 184) = 0LL;
    *(void *)(a2 + 16_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
    *(_BYTE *)(a2 + 192) = 1;
    if (!*(_BYTE *)(a1 + 152) || (double v37 = sub_1002E2C84(a1 + 16, a1 + 104), !*(_BYTE *)(a1 + 96))) {
LABEL_68:
    }
      sub_100006080();
    double v38 = fmod(v37 + 360.0, 360.0);
    double v39 = fmod(v38 - *(double *)(a1 + 80) + 180.0, 360.0);
    *(_BYTE *)(a2 + 20_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
    if (v39 < 0.0) {
      double v39 = v39 + 360.0;
    }
    *(double *)(a2 + 200) = v39 + -180.0;
    double v40 = v36 / v30 * 57.2957795;
    *(double *)(a2 + 336) = v40;
    *(_BYTE *)(a2 + 344) = 1;
    *(double *)(a2 + 320) = sqrt(*(double *)(a1 + 88) * *(double *)(a1 + 88) + v40 * v40);
    *(_BYTE *)(a2 + 32_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
    int v41 = *(unsigned __int8 *)(a1 + 56);
    if (*(_BYTE *)(a1 + 56)) {
      BOOL v42 = *(_BYTE *)(a1 + 144) != 0;
    }
    else {
      BOOL v42 = 0;
    }
    *(_WORD *)(a2 + 352) = v42 | 0x100;
    uint64_t v43 = qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_INFO))
    {
      int v44 = *(unsigned __int8 *)(a1 + 144);
      int v46 = 67109632;
      *(_DWORD *)double v47 = v42;
      *(_WORD *)&v47[4] = 1024;
      *(_DWORD *)&v47[6] = v41;
      LOWORD(v4_Block_object_dispose((const void *)(v1 - 112), 8) = 1024;
      *(_DWORD *)((char *)&v48 + 2) = v44;
      uint64_t v21 = "#cl_algo,#gri,findee,CLLocationBasedArrowFilter,producedInGoodEnvironmentalConditions,%d,self,%d,peer,%d";
      int v22 = (os_log_s *)v43;
      os_log_type_t v23 = OS_LOG_TYPE_INFO;
      uint32_t v24 = 20;
LABEL_62:
      _os_log_impl((void *)&_mh_execute_header, v22, v23, v21, (uint8_t *)&v46, v24);
    }
  }

double sub_1002E2C84(uint64_t a1, uint64_t a2)
{
  double v2 = *(double *)(a1 + 8) * 3.14159265 / 180.0;
  double v3 = *(double *)(a2 + 8) * 3.14159265 / 180.0;
  __double2 v4 = __sincos_stret(*(double *)(a2 + 16) * 3.14159265 / 180.0 - *(double *)(a1 + 16) * 3.14159265 / 180.0);
  __double2 v5 = __sincos_stret(v3);
  __double2 v6 = __sincos_stret(v2);
  return atan2(v5.__cosval * v4.__sinval, -(v6.__sinval * v5.__cosval) * v4.__cosval + v6.__cosval * v5.__sinval)
       * 180.0
       / 3.14159265;
}

__n128 sub_1002E2D34(uint64_t a1, uint64_t a2)
{
  double v2 = (__n128 *)(a1 + 104);
  if (*(_BYTE *)(a1 + 152))
  {
    __n128 result = *(__n128 *)a2;
    __int128 v4 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)(a1 + 129) = *(_OWORD *)(a2 + 25);
    __n128 *v2 = result;
    *(_OWORD *)(a1 + 120) = v4;
  }

  else
  {
    __n128 result = *(__n128 *)a2;
    __int128 v5 = *(_OWORD *)(a2 + 32);
    *(_OWORD *)(a1 + 120) = *(_OWORD *)(a2 + 16);
    *(_OWORD *)(a1 + 136) = v5;
    __n128 *v2 = result;
    *(_BYTE *)(a1 + 152) = 1;
  }

  return result;
}

uint64_t sub_1002E2D70(uint64_t result, uint64_t a2)
{
  int v2 = *(unsigned __int8 *)(result + 96);
  uint64_t v3 = *(void *)(a2 + 16);
  *(_OWORD *)(result + 72) = *(_OWORD *)a2;
  *(void *)(result + 8_Block_object_dispose((const void *)(v1 - 112), 8) = v3;
  if (!v2) {
    *(_BYTE *)(result + 96) = 1;
  }
  double v4 = *(double *)a2;
  if (!*(_BYTE *)(result + 384) || *(double *)(result + 376) < v4)
  {
    *(double *)(result + 376) = v4;
    *(_BYTE *)(result + 384) = 1;
  }

  return result;
}

uint64_t sub_1002E2DB8(uint64_t result, __int128 *a2)
{
  int v2 = (_OWORD *)(result + 16);
  if (*(_BYTE *)(result + 64))
  {
    __int128 v3 = *a2;
    __int128 v4 = a2[1];
    *(_OWORD *)(result + 41) = *(__int128 *)((char *)a2 + 25);
    _OWORD *v2 = v3;
    *(_OWORD *)(result + 32) = v4;
  }

  else
  {
    __int128 v5 = *a2;
    __int128 v6 = a2[2];
    *(_OWORD *)(result + 32) = a2[1];
    *(_OWORD *)(result + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v6;
    _OWORD *v2 = v5;
    *(_BYTE *)(result + 64) = 1;
  }

  double v7 = *(double *)a2;
  if (!*(_BYTE *)(result + 384) || *(double *)(result + 376) < v7)
  {
    *(double *)(result + 376) = v7;
    *(_BYTE *)(result + 384) = 1;
  }

  return result;
}

uint64_t sub_1002E2E18(uint64_t result, __int128 *a2)
{
  int v2 = *(unsigned __int8 *)(result + 344);
  __int128 v3 = a2[3];
  __int128 v5 = *a2;
  __int128 v4 = a2[1];
  *(_OWORD *)(result + 192) = a2[2];
  *(_OWORD *)(result + 20_Block_object_dispose((const void *)(v1 - 112), 8) = v3;
  *(_OWORD *)(result + 160) = v5;
  *(_OWORD *)(result + 176) = v4;
  __int128 v6 = a2[7];
  __int128 v8 = a2[4];
  __int128 v7 = a2[5];
  *(_OWORD *)(result + 256) = a2[6];
  *(_OWORD *)(result + 272) = v6;
  *(_OWORD *)(result + 224) = v8;
  *(_OWORD *)(result + 240) = v7;
  __int128 v10 = a2[9];
  __int128 v9 = a2[10];
  __int128 v11 = a2[8];
  *(void *)(result + 336) = *((void *)a2 + 22);
  *(_OWORD *)(result + 304) = v10;
  *(_OWORD *)(result + 320) = v9;
  *(_OWORD *)(result + 28_Block_object_dispose((const void *)(v1 - 112), 8) = v11;
  if (!v2) {
    *(_BYTE *)(result + 344) = 1;
  }
  double v12 = *((double *)a2 + 1);
  if (!*(_BYTE *)(result + 384) || *(double *)(result + 376) < v12)
  {
    *(double *)(result + 376) = v12;
    *(_BYTE *)(result + 384) = 1;
  }

  return result;
}

uint64_t sub_1002E2E88(uint64_t result, int *a2, double a3)
{
  if (!*(_BYTE *)(result + 384) || *(double *)(result + 376) < a3)
  {
    *(double *)(result + 376) = a3;
    *(_BYTE *)(result + 384) = 1;
  }

  int v3 = *a2;
  *(double *)(result + 352) = a3;
  *(_DWORD *)(result + 360) = v3;
  *(_BYTE *)(result + 36_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
  return result;
}

uint64_t sub_1002E2EC0(uint64_t result, double a2, double a3, double a4, double a5)
{
  *(double *)(result + _Block_object_dispose((const void *)(v1 - 112), 8) = a2;
  *(double *)(result + 16) = a3;
  *(void *)__n128 result = off_1007BD098;
  *(double *)(result + 24) = a4;
  *(double *)(result + 32) = a5;
  return result;
}

BOOL sub_1002E2ED8(double *a1, __int128 **a2)
{
  double v4 = (*(double (**)(double *))(*(void *)a1 + 16LL))(a1);
  __int128 v5 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 v9 = 134217984;
    *(double *)&v9[4] = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "#dec-proc, WRTT: Estimating shouldUnlock with unlockThreshold: %f",  v9,  0xCu);
  }

  (*(void (**)(_BYTE *__return_ptr, double *))(*(void *)a1 + 32LL))(v9, a1);
  BOOL v6 = sub_1002E3010(a1, (uint64_t *)v9, a2, v4);
  uint64_t v7 = *(void *)v9;
  *(void *)__int128 v9 = 0LL;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
  }
  return v6;
}

void sub_1002E2FE4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    (*(void (**)(uint64_t))(*(void *)a9 + 8LL))(a9);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1002E3010(double *a1, uint64_t *a2, __int128 **a3, double a4)
{
  double v4 = *a3;
  __int128 v5 = a3[1];
  if (*a3 == v5) {
    return 0LL;
  }
  if (!*a2)
  {
    __int16 v49 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_fault_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_FAULT,  "#dec-proc, Assertion failed",  (uint8_t *)__p,  2u);
      __int16 v49 = (os_log_s *)qword_1008000A0;
    }

    if (os_log_type_enabled(v49, OS_LOG_TYPE_INFO))
    {
      LODWORD(__p[0]) = 136315650;
      *(void **)((char *)__p + 4) = "/Library/Caches/com.apple.xbs/Sources/Proximity/Libraries/NearbyAlgorithms/AutoUnloc"
                                    "k/NRBYPeerRangingDecisionProcessor.cpp";
      WORD2(__p[1]) = 1024;
      *(_DWORD *)((char *)&__p[1] + 6) = 40;
      WORD1(__p[2]) = 2080;
      *(void **)((char *)&__p[2] + 4) = "filterRangesAndEstimateUnlock";
      _os_log_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_INFO,  "#dec-proc, %s:%d: assertion failure in %s",  (uint8_t *)__p,  0x1Cu);
    }

    abort();
  }

  __int128 v9 = 0LL;
  memset(__p, 0, 24);
  do
  {
    double v10 = *((float *)v4 + 4);
    if (a1[1] < v10 && a1[2] > v10)
    {
      if (v9 >= __p[2])
      {
        uint64_t v20 = (char *)__p[0];
        unint64_t v21 = 0xD37A6F4DE9BD37A7LL * ((v9 - (char *)__p[0]) >> 3);
        unint64_t v22 = v21 + 1;
        if (v21 + 1 > 0x1642C8590B21642LL) {
          sub_10001E11C();
        }
        else {
          unint64_t v23 = v22;
        }
        if (v23)
        {
          uint32_t v24 = (char *)sub_10015F4D8((uint64_t)&__p[2], v23);
          uint64_t v20 = (char *)__p[0];
          __int128 v9 = (char *)__p[1];
        }

        else
        {
          uint32_t v24 = 0LL;
        }

        double v25 = &v24[184 * v21];
        __int128 v26 = *v4;
        __int128 v27 = v4[1];
        __int128 v28 = v4[3];
        *((_OWORD *)v25 + 2) = v4[2];
        *((_OWORD *)v25 + 3) = v28;
        *(_OWORD *)double v25 = v26;
        *((_OWORD *)v25 + 1) = v27;
        __int128 v29 = v4[4];
        __int128 v30 = v4[5];
        __int128 v31 = v4[7];
        *((_OWORD *)v25 + 6) = v4[6];
        *((_OWORD *)v25 + 7) = v31;
        *((_OWORD *)v25 + 4) = v29;
        *((_OWORD *)v25 + 5) = v30;
        __int128 v32 = v4[8];
        __int128 v33 = v4[9];
        __int128 v34 = v4[10];
        *((void *)v25 + 22) = *((void *)v4 + 22);
        *((_OWORD *)v25 + 9) = v33;
        *((_OWORD *)v25 + 10) = v34;
        *((_OWORD *)v25 + _Block_object_dispose((const void *)(v1 - 112), 8) = v32;
        if (v9 == v20)
        {
          uint64_t v45 = &v24[184 * v21];
        }

        else
        {
          float v35 = &v24[184 * v21];
          do
          {
            __int128 v36 = *(_OWORD *)(v9 - 184);
            __int128 v37 = *(_OWORD *)(v9 - 168);
            __int128 v38 = *(_OWORD *)(v9 - 152);
            *(_OWORD *)(v35 - 136) = *(_OWORD *)(v9 - 136);
            *(_OWORD *)(v35 - 152) = v38;
            *(_OWORD *)(v35 - 16_Block_object_dispose((const void *)(v1 - 112), 8) = v37;
            *(_OWORD *)(v35 - 184) = v36;
            __int128 v39 = *(_OWORD *)(v9 - 120);
            __int128 v40 = *(_OWORD *)(v9 - 104);
            __int128 v41 = *(_OWORD *)(v9 - 88);
            *(_OWORD *)(v35 - 72) = *(_OWORD *)(v9 - 72);
            *(_OWORD *)(v35 - 8_Block_object_dispose((const void *)(v1 - 112), 8) = v41;
            *(_OWORD *)(v35 - 104) = v40;
            *(_OWORD *)(v35 - 120) = v39;
            __int128 v42 = *(_OWORD *)(v9 - 56);
            __int128 v43 = *(_OWORD *)(v9 - 40);
            __int128 v44 = *(_OWORD *)(v9 - 24);
            uint64_t v45 = v35 - 184;
            *((void *)v35 - 1) = *((void *)v9 - 1);
            *(_OWORD *)(v35 - 24) = v44;
            *(_OWORD *)(v35 - 40) = v43;
            *(_OWORD *)(v35 - 56) = v42;
            v9 -= 184;
            v35 -= 184;
          }

          while (v9 != v20);
        }

        __int128 v9 = v25 + 184;
        __p[0] = v45;
        __p[1] = v25 + 184;
        __p[2] = &v24[184 * v23];
        if (v20) {
          operator delete(v20);
        }
      }

      else
      {
        __int128 v11 = *v4;
        __int128 v12 = v4[1];
        __int128 v13 = v4[3];
        *((_OWORD *)v9 + 2) = v4[2];
        *((_OWORD *)v9 + 3) = v13;
        *(_OWORD *)__int128 v9 = v11;
        *((_OWORD *)v9 + 1) = v12;
        __int128 v14 = v4[4];
        __int128 v15 = v4[5];
        __int128 v16 = v4[7];
        *((_OWORD *)v9 + 6) = v4[6];
        *((_OWORD *)v9 + 7) = v16;
        *((_OWORD *)v9 + 4) = v14;
        *((_OWORD *)v9 + 5) = v15;
        __int128 v17 = v4[8];
        __int128 v18 = v4[9];
        __int128 v19 = v4[10];
        *((void *)v9 + 22) = *((void *)v4 + 22);
        *((_OWORD *)v9 + 9) = v18;
        *((_OWORD *)v9 + 10) = v19;
        *((_OWORD *)v9 + _Block_object_dispose((const void *)(v1 - 112), 8) = v17;
        v9 += 184;
      }

      __p[1] = v9;
    }

    double v4 = (__int128 *)((char *)v4 + 184);
  }

  while (v4 != v5);
  uint64_t v46 = *a2;
  (*(void (**)(void **__return_ptr, double *, void **))(*(void *)a1 + 48LL))(v50, a1, __p);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, void **, double))(*(void *)v46 + 16LL))(v51, v46, v50, a4);
  if (v50[0])
  {
    v50[1] = v50[0];
    operator delete(v50[0]);
  }

  BOOL v47 = LOBYTE(v51[0]) != 0;
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

  return v47;
}

void sub_1002E33DC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  if (a15) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

double sub_1002E3420(uint64_t a1)
{
  return *(double *)(a1 + 24);
}

double sub_1002E3428(uint64_t a1)
{
  return *(double *)(a1 + 32);
}

void *sub_1002E3430@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  *a2 = 0LL;
  a2[1] = 0LL;
  a2[2] = 0LL;
  return sub_1002E3464( a2,  *(const void **)a1,  *(void *)(a1 + 8),  0xD37A6F4DE9BD37A7LL * ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3));
}

void *sub_1002E3464(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    BOOL v6 = result;
    __n128 result = sub_1002E34DC(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }

  return result;
}

void sub_1002E34C0(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

char *sub_1002E34DC(void *a1, unint64_t a2)
{
  if (a2 >= 0x1642C8590B21643LL) {
    sub_10001E11C();
  }
  __n128 result = (char *)sub_10015F4D8((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[184 * v4];
  return result;
}

__n128 sub_1002E3530@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X2>, uint64_t a4@<X8>, double a5@<D4>)
{
  *a3 = 0;
  uint64_t v9 = *(void *)(a1 + 232);
  if (!v9
    || *(double *)a2 > *(double *)(*(void *)(*(void *)(a1 + 200)
                                             + (((unint64_t)(v9 + *(void *)(a1 + 224) - 1) >> 2) & 0x3FFFFFFFFFFFFFF8LL))
                                 + (((v9 + *(void *)(a1 + 224) - 1) & 0x1F) << 7)))
  {
    int v10 = *(_DWORD *)(a1 + 240);
    int v11 = *(_DWORD *)(a2 + 80);
    *(_DWORD *)(a1 + 240) = v11;
    if (v10 != v11)
    {
      switch(v11)
      {
        case 2:
          __int128 v12 = (os_log_s *)qword_1008000A0;
          if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
          {
            double v17 = *(double *)a2;
            *(_DWORD *)__int128 buf = 134217984;
            *(double *)&uint8_t buf[4] = v17;
            __int128 v14 = "#findalgs-rangeposeinterpolator,VIO Tracking State changed to Normal at %f s";
            goto LABEL_16;
          }

          break;
        case 1:
          __int128 v12 = (os_log_s *)qword_1008000A0;
          if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
          {
            double v18 = *(double *)a2;
            *(_DWORD *)__int128 buf = 134217984;
            *(double *)&uint8_t buf[4] = v18;
            __int128 v14 = "#findalgs-rangeposeinterpolator,VIO Tracking State changed to Limited at %f s";
            goto LABEL_16;
          }

          break;
        case 0:
          __int128 v12 = (os_log_s *)qword_1008000A0;
          if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
          {
            double v13 = *(double *)a2;
            *(_DWORD *)__int128 buf = 134217984;
            *(double *)&uint8_t buf[4] = v13;
            __int128 v14 = "#findalgs-rangeposeinterpolator,VIO Tracking State changed to Not Available at %f s";
LABEL_16:
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, v14, buf, 0xCu);
          }

          break;
      }
    }

    int v19 = *(_DWORD *)(a2 + 80);
    if (v10 == 2 && v19 != 2)
    {
      unint64_t v21 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "#findalgs-rangeposeinterpolator,VIO Tracking not normal anymore - resetting",  buf,  2u);
      }

      if (*(_BYTE *)(a1 + 184))
      {
        unint64_t v22 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "#findalgs-rangeposeinterpolator,VIO Tracking not normal before the cached measurement can be interpolated - passing the cached measurement to the range filter without VIO",  buf,  2u);
        }
      }

      *a3 = 1;
      sub_1002E3A08(a1);
      int v19 = *(_DWORD *)(a2 + 80);
    }

    if (v19 == 2)
    {
      if (*(_BYTE *)(a2 + 84))
      {
        unint64_t v23 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
        {
          double v24 = *(double *)a2;
          double v25 = "YES";
          if (*(_BYTE *)(a2 + 84)) {
            __int128 v26 = "YES";
          }
          else {
            __int128 v26 = "NO";
          }
          if (!*(_BYTE *)(a2 + 85)) {
            double v25 = "NO";
          }
          *(_DWORD *)__int128 buf = 134218498;
          *(double *)&uint8_t buf[4] = v24;
          *(_WORD *)&_BYTE buf[12] = 2080;
          *(void *)&buf[14] = v26;
          *(_WORD *)&buf[22] = 2080;
          *(void *)&_BYTE buf[24] = v25;
          _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "#findalgs-rangeposeinterpolator,VIO reported relocalization event at %f s, MAJOR: %s, MINOR: %s - resetting",  buf,  0x20u);
        }

        *a3 = 1;
        sub_1002E3A08(a1);
      }

      else
      {
        if (*(_BYTE *)(a2 + 85))
        {
          __int128 v27 = (os_log_s *)qword_1008000A0;
          if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
          {
            double v28 = *(double *)a2;
            *(_DWORD *)__int128 buf = 134217984;
            *(double *)&uint8_t buf[4] = v28;
            _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "#findalgs-rangeposeinterpolator,VIO reported MINOR relocalization event at %f s",  buf,  0xCu);
          }
        }

        uint64_t v29 = 0LL;
        float32x4_t v30 = *(float32x4_t *)(a2 + 16);
        float32x4_t v31 = *(float32x4_t *)(a2 + 32);
        float32x4_t v32 = *(float32x4_t *)(a2 + 48);
        float32x4_t v33 = *(float32x4_t *)(a2 + 64);
        v43[0] = xmmword_10042DB30;
        v43[1] = xmmword_10042DB40;
        v43[2] = xmmword_10042DB50;
        v43[3] = xmmword_10042DB60;
        do
        {
          *(float32x4_t *)&buf[v29 * 16] = vmlaq_laneq_f32( vmlaq_laneq_f32( vmlaq_lane_f32( vmulq_n_f32(v30, COERCE_FLOAT(v43[v29])),  v31,  *(float32x2_t *)&v43[v29],  1),  v32,  (float32x4_t)v43[v29],  2),  v33,  (float32x4_t)v43[v29],  3);
          ++v29;
        }

        while (v29 != 4);
        __int128 v34 = *(_OWORD *)buf;
        __int128 v35 = *(_OWORD *)&buf[16];
        __int128 v36 = v45;
        __int128 v37 = v46;
        int v38 = *(_DWORD *)(a2 + 80);
        __int16 v39 = *(_WORD *)(a2 + 84);
        *(void *)__int128 buf = *(void *)a2;
        *(_OWORD *)&uint8_t buf[16] = v34;
        __int128 v45 = v35;
        __int128 v46 = v36;
        __int128 v47 = v37;
        int v48 = v38;
        __int16 v49 = v39;
        char v50 = 0;
        char v51 = 0;
        char v52 = 0;
        char v53 = 0;
        char v54 = 0;
        char v55 = 0;
        sub_1002C6AFC((void *)(a1 + 192), (__int128 *)buf);
      }
    }

    sub_1002E3A8C(a1, (uint64_t)buf, a5);
    sub_1002E4140((void *)a1);
    __int128 v40 = v46;
    *(_OWORD *)(a4 + 32) = v45;
    *(_OWORD *)(a4 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v40;
    *(_OWORD *)(a4 + 64) = v47;
    __n128 result = *(__n128 *)&buf[16];
    *(_OWORD *)a4 = *(_OWORD *)buf;
    *(__n128 *)(a4 + 16) = result;
    return result;
  }

  __int128 v15 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR))
  {
    unint64_t v41 = *(void *)(a1 + 232) + *(void *)(a1 + 224) - 1LL;
    uint64_t v42 = *(void *)(*(void *)(*(void *)(a1 + 200) + ((v41 >> 2) & 0x3FFFFFFFFFFFFFF8LL)) + ((v41 & 0x1F) << 7));
    *(_DWORD *)__int128 buf = 134217984;
    *(void *)&uint8_t buf[4] = v42;
    _os_log_error_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "#findalgs-rangeposeinterpolator,Received pose earlier than the last pose in history with timestamp: %f - pose rejected",  buf,  0xCu);
  }

  *(_BYTE *)a4 = 0;
  *(_BYTE *)(a4 + 72) = 0;
  return result;
}

void sub_1002E3A08(uint64_t a1)
{
  *(_DWORD *)(a1 + 240) = 0;
  if (*(_BYTE *)(a1 + 184)) {
    *(_BYTE *)(a1 + 184) = 0;
  }
  int v2 = *(void ***)(a1 + 200);
  uint64_t v3 = *(void *)(a1 + 208);
  *(void *)(a1 + 232) = 0LL;
  unint64_t v4 = v3 - (void)v2;
  if (v4 >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v5 = *(void *)(a1 + 208);
      int v2 = (void **)(*(void *)(a1 + 200) + 8LL);
      *(void *)(a1 + 200) = v2;
      unint64_t v4 = v5 - (void)v2;
    }

    while (v4 > 0x10);
  }

  if (v4 >> 3 == 1)
  {
    uint64_t v6 = 16LL;
  }

  else
  {
    if (v4 >> 3 != 2) {
      return;
    }
    uint64_t v6 = 32LL;
  }

  *(void *)(a1 + 224) = v6;
}

void sub_1002E3A8C(uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D4>)
{
  *(_BYTE *)a2 = 0;
  *(_BYTE *)(a2 + 72) = 0;
  if (!*(_BYTE *)(a1 + 184)) {
    return;
  }
  uint64_t v5 = *(void *)(a1 + 232);
  if (!v5) {
    return;
  }
  unint64_t v6 = *(void *)(a1 + 224);
  uint64_t v7 = *(void *)(a1 + 200);
  uint64_t v8 = *(void *)(a1 + 208);
  uint64_t v9 = (char *)(v7 + 8 * (v6 >> 5));
  if (v8 == v7)
  {
    uint64_t v10 = 0LL;
    unint64_t v13 = 0LL;
    __int128 v12 = (char *)(v7 + 8 * ((v6 + v5) >> 5));
  }

  else
  {
    uint64_t v10 = *(void *)v9 + ((*(void *)(a1 + 224) & 0x1FLL) << 7);
    char v11 = v6 + v5;
    __int128 v12 = (char *)(v7 + 8 * ((v6 + v5) >> 5));
    unint64_t v13 = *(void *)v12 + ((unint64_t)(v11 & 0x1F) << 7);
  }

  double v14 = *(double *)(a1 + 8);
  float v15 = *(float *)(a1 + 16);
  *(void *)__int128 buf = v7 + 8 * (v6 >> 5);
  *(void *)&uint8_t buf[8] = v10;
  if (v13 != v10)
  {
    uint64_t v16 = ((uint64_t)(v13 - *(void *)v12) >> 7) + 4 * (v12 - v9);
    uint64_t v17 = v10 - *(void *)v9;
    unint64_t v18 = v16 - (v17 >> 7);
    if (v16 != v17 >> 7)
    {
      do
      {
        unint64_t v19 = v18 >> 1;
        uint64_t v20 = sub_1002CBE78((uint64_t)buf, v18 >> 1);
        if (v14 >= *v21)
        {
          unint64_t v22 = v21 + 16;
          if ((double *)((char *)v21 - *v20 + 128) == (double *)4096)
          {
            unint64_t v23 = (double *)v20[1];
            ++v20;
            unint64_t v22 = v23;
          }

          *(void *)__int128 buf = v20;
          *(void *)&uint8_t buf[8] = v22;
          unint64_t v19 = v18 + ~v19;
        }

        unint64_t v18 = v19;
      }

      while (v19);
      uint64_t v9 = *(char **)buf;
      uint64_t v10 = *(void *)&buf[8];
      unint64_t v6 = *(void *)(a1 + 224);
      uint64_t v7 = *(void *)(a1 + 200);
      uint64_t v8 = *(void *)(a1 + 208);
    }
  }

  if (v8 == v7)
  {
    if (v10)
    {
      uint64_t v24 = 0LL;
      goto LABEL_19;
    }

void sub_1002E4140(void *a1)
{
  uint64_t v1 = a1[29];
  if (v1)
  {
    unint64_t v3 = a1[28];
    if (v4 > 5.0)
    {
      uint64_t v5 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)float32x4_t v31 = 134217984;
        *(double *)&v31[4] = v4;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "#findalgs-rangeposeinterpolator,Pose history spans %f s - pruning down past poses from history",  v31,  0xCu);
      }

      unint64_t v6 = a1[28];
      unint64_t v7 = v6 + a1[29];
      uint64_t v8 = a1[25];
      uint64_t v9 = a1[26];
      unint64_t v10 = v6 >> 5;
      char v11 = (char *)(v8 + 8 * (v6 >> 5));
      if (v9 == v8)
      {
        uint64_t v12 = 0LL;
        unint64_t v14 = 0LL;
        unint64_t v13 = (char *)(v8 + 8 * (v7 >> 5));
      }

      else
      {
        uint64_t v12 = *(void *)v11 + ((a1[28] & 0x1FLL) << 7);
        unint64_t v13 = (char *)(v8 + 8 * (v7 >> 5));
        unint64_t v14 = *(void *)v13 + ((v7 & 0x1F) << 7);
      }

      double v15 = *(double *)(*(void *)(v8 + (((v7 - 1) >> 2) & 0x3FFFFFFFFFFFFFF8LL)) + (((v7 - 1) & 0x1F) << 7));
      *(void *)float32x4_t v31 = v8 + 8 * (v6 >> 5);
      *(void *)&v31[8] = v12;
      if (v14 != v12)
      {
        uint64_t v16 = ((uint64_t)(v14 - *(void *)v13) >> 7) + 4 * (v13 - v11);
        uint64_t v17 = v12 - *(void *)v11;
        unint64_t v18 = v16 - (v17 >> 7);
        if (v16 != v17 >> 7)
        {
          double v19 = v15 + -2.0;
          do
          {
            unint64_t v20 = v18 >> 1;
            unint64_t v21 = sub_1002CBE78((uint64_t)v31, v18 >> 1);
            if (v19 >= *v22)
            {
              unint64_t v23 = v22 + 16;
              if ((double *)((char *)v22 - *v21 + 128) == (double *)4096)
              {
                uint64_t v24 = (double *)v21[1];
                ++v21;
                unint64_t v23 = v24;
              }

              *(void *)float32x4_t v31 = v21;
              *(void *)&v31[8] = v23;
              unint64_t v20 = v18 + ~v20;
            }

            unint64_t v18 = v20;
          }

          while (v20);
          char v11 = *(char **)v31;
          uint64_t v12 = *(void *)&v31[8];
          unint64_t v6 = a1[28];
          uint64_t v8 = a1[25];
          uint64_t v9 = a1[26];
          unint64_t v10 = v6 >> 5;
        }
      }

      uint64_t v25 = (char *)(v8 + 8 * v10);
      if (v9 == v8) {
        uint64_t v26 = 0LL;
      }
      else {
        uint64_t v26 = *(void *)v25 + ((v6 & 0x1F) << 7);
      }
      sub_1002CA580(a1 + 24, v25, v26, v11, v12);
      unint64_t v27 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v28 = a1[25];
        uint64_t v29 = *(void *)(*(void *)(v28 + ((a1[28] >> 2) & 0x3FFFFFFFFFFFFFF8LL)) + ((a1[28] & 0x1FLL) << 7));
        *(_DWORD *)float32x4_t v31 = 134218240;
        *(void *)&v31[4] = v29;
        *(_WORD *)&v31[12] = 2048;
        *(void *)&v31[14] = v30;
        _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "#findalgs-rangeposeinterpolator,Pose history now between %f s and %f s",  v31,  0x16u);
      }
    }
  }

void sub_1002E4404(uint64_t a1@<X0>, __int128 *a2@<X1>, _BYTE *a3@<X8>, double a4@<D4>)
{
  if (*((_BYTE *)a2 + 181)) {
    BOOL v6 = *((unsigned __int8 *)a2 + 180) > 2u;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    int v7 = *(unsigned __int8 *)(a1 + 184);
    __int128 v8 = a2[3];
    __int128 v10 = *a2;
    __int128 v9 = a2[1];
    *(_OWORD *)(a1 + 32) = a2[2];
    *(_OWORD *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v8;
    *(_OWORD *)a1 = v10;
    *(_OWORD *)(a1 + 16) = v9;
    __int128 v11 = a2[7];
    __int128 v13 = a2[4];
    __int128 v12 = a2[5];
    *(_OWORD *)(a1 + 96) = a2[6];
    *(_OWORD *)(a1 + 112) = v11;
    *(_OWORD *)(a1 + 64) = v13;
    *(_OWORD *)(a1 + 80) = v12;
    __int128 v15 = a2[9];
    __int128 v14 = a2[10];
    __int128 v16 = a2[8];
    *(void *)(a1 + 176) = *((void *)a2 + 22);
    *(_OWORD *)(a1 + 144) = v15;
    *(_OWORD *)(a1 + 160) = v14;
    *(_OWORD *)(a1 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = v16;
    if (!v7) {
      *(_BYTE *)(a1 + 184) = 1;
    }
    sub_1002E3A8C(a1, (uint64_t)a3, a4);
  }

  else
  {
    uint64_t v17 = (os_log_s *)(id)qword_1008000A0;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      if (!*((_BYTE *)a2 + 181)) {
        sub_100006080();
      }
      int v19 = *((unsigned __int8 *)a2 + 180);
      v20[0] = 67109120;
      v20[1] = v19;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "#findalgs-rangeposeinterpolator,mmsValStatus %d does not pass check, rejecting range result event",  (uint8_t *)v20,  8u);
    }

    *a3 = 0;
    a3[72] = 0;
  }

void sub_1002E4560(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *sub_1002E4578(uint64_t a1, uint64_t a2)
{
  __n128 result = (void *)sub_100301A48(a1, a2);
  *__n128 result = off_1007BD0F0;
  return result;
}

uint64_t sub_1002E4598@<X0>(uint64_t a1@<X0>, double *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  double v6 = *a2;
  double v5 = a2[1];
  v10[0] = 0;
  v10[88] = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, double, double))(*(void *)a1 + 16LL))( a1,  a3,  v10,  v5,  v6);
  if (v8)
  {
    *(void *)a4 = result;
    char v9 = 1;
    *(_BYTE *)(a4 + _Block_object_dispose((const void *)(v1 - 112), 8) = 1;
    *(_BYTE *)(a4 + 16) = 0;
    *(_BYTE *)(a4 + 24) = 0;
    *(_BYTE *)(a4 + 32) = 0;
    *(_BYTE *)(a4 + 36) = 0;
    *(_BYTE *)(a4 + 40) = 0;
    *(_BYTE *)(a4 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
    *(_BYTE *)(a4 + 56) = 0;
    *(_BYTE *)(a4 + 64) = 0;
    *(_BYTE *)(a4 + 72) = 0;
    *(_BYTE *)(a4 + 76) = 0;
  }

  else
  {
    char v9 = 0;
    *(_BYTE *)a4 = 0;
  }

  *(_BYTE *)(a4 + 80) = v9;
  return result;
}

__n128 sub_1002E462C(uint64_t a1, __n128 *a2)
{
  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = 1;
  *(_BYTE *)(a1 + 72) = 0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_BYTE *)(a1 + 64) = 0;
  *(void *)a1 = off_1007BD130;
  __n128 result = *a2;
  *(void *)(a1 + 96) = a2[1].n128_u64[0];
  *(__n128 *)(a1 + 80) = result;
  *(_BYTE *)(a1 + 104) = 0;
  *(void *)(a1 + 120) = 0LL;
  *(void *)(a1 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  *(void *)(a1 + 112) = 0LL;
  return result;
}

uint64_t sub_1002E4674(uint64_t result)
{
  *(void *)(result + 120) = *(void *)(result + 112);
  *(_BYTE *)(result + 104) = 0;
  return result;
}

void sub_1002E4684(void *a1@<X0>, uint64_t *a2@<X1>, double *a3@<X8>)
{
  uint64_t v6 = *a2;
  uint64_t v5 = a2[1];
  int v7 = *((_DWORD *)a2 + 4);
  char v8 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG))
  {
    int v21 = 134218496;
    uint64_t v22 = v6;
    __int16 v23 = 2048;
    uint64_t v24 = v5;
    __int16 v25 = 1024;
    int v26 = v7;
    _os_log_debug_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "#boundedregiongrange-estimator, Input time: %4.3f s, rssi: %3.1f, channel: %d",  (uint8_t *)&v21,  0x1Cu);
  }

  unint64_t v9 = a1[16];
  __int128 v10 = (char *)a1[15];
  if ((unint64_t)v10 >= v9)
  {
    __int128 v12 = (char *)a1[14];
    unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((v10 - v12) >> 3);
    unint64_t v14 = v13 + 1;
    if (v13 + 1 > 0xAAAAAAAAAAAAAAALL) {
      sub_10001E11C();
    }
    unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v9 - (void)v12) >> 3);
    if (2 * v15 > v14) {
      unint64_t v14 = 2 * v15;
    }
    if (v15 >= 0x555555555555555LL) {
      unint64_t v16 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v16 = v14;
    }
    if (v16)
    {
      uint64_t v17 = (char *)sub_10001E130((uint64_t)(a1 + 16), v16);
      __int128 v12 = (char *)a1[14];
      __int128 v10 = (char *)a1[15];
    }

    else
    {
      uint64_t v17 = 0LL;
    }

    unint64_t v18 = &v17[24 * v13];
    int v19 = &v17[24 * v16];
    *(void *)unint64_t v18 = v6;
    *((void *)v18 + 1) = v5;
    *((_DWORD *)v18 + 4) = v7;
    __int128 v11 = v18 + 24;
    if (v10 != v12)
    {
      do
      {
        __int128 v20 = *(_OWORD *)(v10 - 24);
        *((void *)v18 - 1) = *((void *)v10 - 1);
        *(_OWORD *)(v18 - 24) = v20;
        v18 -= 24;
        v10 -= 24;
      }

      while (v10 != v12);
      __int128 v12 = (char *)a1[14];
    }

    a1[14] = v18;
    a1[15] = v11;
    a1[16] = v19;
    if (v12) {
      operator delete(v12);
    }
  }

  else
  {
    *(void *)__int128 v10 = v6;
    *((void *)v10 + 1) = v5;
    __int128 v11 = v10 + 24;
    *((_DWORD *)v10 + 4) = v7;
  }

  a1[15] = v11;
  sub_1002E4884((uint64_t)a1);
  sub_1002E48F8((uint64_t)a1);
  sub_1002E4A08((uint64_t)a1, a3);
}

void sub_1002E4884(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 104))
  {
    uint64_t v1 = *(double **)(a1 + 112);
    int v2 = *(double **)(a1 + 120);
    if (v1 != v2)
    {
      double v3 = *(v2 - 3) - *v1;
      double v4 = *(double *)(a1 + 88);
      *(_BYTE *)(a1 + 104) = v3 >= v4;
      if (v3 >= v4)
      {
        uint64_t v5 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
          sub_1003AA3AC(v5);
        }
      }
    }
  }

void sub_1002E48F8(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 112);
  uint64_t v2 = *(void *)(a1 + 120);
  uint64_t v1 = (uint64_t **)(a1 + 112);
  if (v3 != v2)
  {
    double v4 = *(double *)(v2 - 24);
    double v5 = *(double *)(a1 + 96);
    if (v4 - *(double *)v3 >= v5)
    {
      while (v4 - *(double *)v3 <= v5)
      {
        v3 += 24LL;
        if (v3 == v2) {
          goto LABEL_14;
        }
      }

      if (v3 != v2)
      {
        uint64_t v6 = v3 + 24;
        if (v3 + 24 != v2)
        {
          do
          {
            if (v4 - *(double *)v6 <= *(double *)(a1 + 96))
            {
              __int128 v7 = *(_OWORD *)v6;
              *(void *)(v3 + 16) = *(void *)(v6 + 16);
              *(_OWORD *)uint64_t v3 = v7;
              v3 += 24LL;
            }

            v6 += 24LL;
          }

          while (v6 != v2);
          uint64_t v2 = *(void *)(a1 + 120);
        }

        if (v3 != v2)
        {
          uint64_t v2 = v3;
          *(void *)(a1 + 120) = v3;
        }
      }

void sub_1002E4A08(uint64_t a1@<X0>, double *a2@<X8>)
{
  *(_BYTE *)a2 = 0;
  *((_BYTE *)a2 + 80) = 0;
  if (*(_BYTE *)(a1 + 104))
  {
    uint64_t v3 = off_1007F3598[*(int *)(a1 + 80)];
    uint64_t v6 = 0LL;
    uint64_t v7 = 0LL;
    stat __p = 0LL;
    sub_10014C4C4( &__p,  *(const void **)(a1 + 112),  *(void *)(a1 + 120),  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 120) - *(void *)(a1 + 112)) >> 3));
    double v4 = (*(double (**)(uint64_t (*)[4], void **))((*v3)[0] + 16))(v3, &__p);
    if (__p)
    {
      uint64_t v6 = __p;
      operator delete(__p);
    }

    *a2 = v4;
    *((_BYTE *)a2 + _Block_object_dispose((const void *)(v1 - 112), 8) = 1;
    *((_BYTE *)a2 + 16) = 0;
    *((_BYTE *)a2 + 24) = 0;
    *((_BYTE *)a2 + 32) = 0;
    *((_BYTE *)a2 + 36) = 0;
    *((_BYTE *)a2 + 40) = 0;
    *((_BYTE *)a2 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
    *((_BYTE *)a2 + 56) = 0;
    *((_BYTE *)a2 + 64) = 0;
    *((_BYTE *)a2 + 72) = 0;
    *((_BYTE *)a2 + 76) = 0;
    *((_BYTE *)a2 + 80) = 1;
  }

void sub_1002E4ADC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002E4AF8()
{
  return 0LL;
}

void sub_1002E4B08(void *a1)
{
  uint64_t v1 = sub_1002E4BC4(a1);
  operator delete(v1);
}

void *sub_1002E4B1C(void *a1)
{
  *a1 = off_1007BD130;
  uint64_t v2 = (void *)a1[14];
  if (v2)
  {
    a1[15] = v2;
    operator delete(v2);
  }

  *a1 = off_1007BD478;
  sub_1001302F0(a1 + 2);
  return a1;
}

void sub_1002E4B70(void *a1)
{
  *a1 = off_1007BD130;
  uint64_t v2 = (void *)a1[14];
  if (v2)
  {
    a1[15] = v2;
    operator delete(v2);
  }

  *a1 = off_1007BD478;
  sub_1001302F0(a1 + 2);
  operator delete(a1);
}

void *sub_1002E4BC4(void *a1)
{
  *a1 = off_1007BD3B8;
  uint64_t v2 = (void *)a1[37];
  if (v2)
  {
    a1[38] = v2;
    operator delete(v2);
  }

  *a1 = off_1007BD478;
  sub_1001302F0(a1 + 2);
  return a1;
}

uint64_t sub_1002E4C1C()
{
  v8[0] = xmmword_10042E738;
  v8[1] = unk_10042E748;
  sub_10015EABC((uint64_t)&unk_1007FE998, (int *)v8, 4LL);
  xmmword_1007FE9B0 = xmmword_100423CB0;
  unk_1007FE9C0 = xmmword_100423CC0;
  qword_1007FE9D8 = 0LL;
  unk_1007FE9E0 = 0LL;
  qword_1007FE9D0 = 0x3FD999999999999ALL;
  unk_1007FE9E8 = xmmword_100423CD0;
  dword_1007FE9F8 = 5;
  qword_1007FEA00 = 0x4000000000000000LL;
  dword_1007FEA08 = 5;
  byte_1007FEA10 = 0;
  *(void *)&algn_1007FEA11[3] = 0x30000000ALL;
  xmmword_1007FEA20 = xmmword_100423CE0;
  unk_1007FEA30 = xmmword_100423CF0;
  xmmword_1007FEA40 = xmmword_100423D00;
  qword_1007FEA50 = 0x3FE3333333333333LL;
  dword_1007FEA58 = 3;
  xmmword_1007FEA60 = xmmword_100423D10;
  unk_1007FEA70 = xmmword_100423CF0;
  xmmword_1007FEA80 = xmmword_100423CE0;
  qword_1007FEA90 = 0x3FE3333333333333LL;
  byte_1007FEA98 = 0;
  xmmword_1007FEAA0 = xmmword_100423D20;
  unk_1007FEAB0 = xmmword_100423D30;
  __asm { FMOV            V0.2D, #1.0 }

  __int128 v6 = _Q0;
  xmmword_1007FEAC0 = _Q0;
  qword_1007FEAD0 = 0xBFD3333333333333LL;
  xmmword_1007FEAD8 = xmmword_100423D40;
  qword_1007FEAE8 = 0x3E99999A40000000LL;
  xmmword_1007FEAF0 = xmmword_100423CC0;
  qword_1007FEB08 = 0LL;
  unk_1007FEB10 = 0LL;
  qword_1007FEB00 = 0x3FD999999999999ALL;
  xmmword_1007FEB18 = xmmword_100423CD0;
  dword_1007FEB28 = 5;
  qword_1007FEB30 = 0x4000000000000000LL;
  dword_1007FEB38 = 4;
  qword_1007FEB40 = 0x300000008LL;
  qword_1007FEB48 = 0xC04E800000000000LL;
  unint64_t v7 = 0xC04E800000000000LL;
  sub_10015ED64((uint64_t)&unk_1007FEB50, (double *)&v7, 1LL);
  xmmword_1007FEB68 = xmmword_100423D50;
  qword_1007FEB78 = 0x4024000000000000LL;
  dword_1007FEB80 = 45;
  byte_1007FEB88 = 0;
  byte_1007FEBA0 = 0;
  qword_1007FEBA8 = 0LL;
  byte_1007FEBB0 = 0;
  dword_1007FEBB4 = 1;
  byte_1007FEBB8 = 1;
  xmmword_1007FEBC0 = xmmword_100423D60;
  unk_1007FEBD0 = xmmword_100423D70;
  xmmword_1007FEBE0 = v6;
  qword_1007FEBF0 = 0xC059000000000000LL;
  xmmword_1007FEBF8 = xmmword_100423D80;
  qword_1007FEC08 = (uint64_t)vdup_n_s32(0x3DCCCCCDu);
  xmmword_1007FEC10 = xmmword_100423CC0;
  qword_1007FEC20 = 0x3FD999999999999ALL;
  qword_1007FEC30 = 0LL;
  qword_1007FEC28 = 0LL;
  xmmword_1007FEC38 = xmmword_100423CD0;
  dword_1007FEC48 = 5;
  qword_1007FEC50 = 0x4000000000000000LL;
  dword_1007FEC58 = 10;
  qword_1007FEC60 = 0x4034000000000000LL;
  dword_1007FEC68 = 3;
  xmmword_1007FEC70 = xmmword_100423D90;
  return __cxa_atexit((void (*)(void *))sub_10015CF8C, &unk_1007FE998, (void *)&_mh_execute_header);
}

void sub_1002E4EC4(_Unwind_Exception *a1)
{
}

uint64_t sub_1002E4EE4(uint64_t a1, int a2, int a3)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  sub_1002D6534((void *)a1, (const void *)qword_1007FEC80, qword_1007FEC88, (qword_1007FEC88 - qword_1007FEC80) >> 4);
  *(_DWORD *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 2_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 36) = 0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_DWORD *)(a1 + 80) = 0;
  *(_BYTE *)(a1 + 84) = 0;
  *(_OWORD *)(a1 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_DWORD *)(a1 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 132) = 0;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 16_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 69) = 0LL;
  *(_OWORD *)(a1 + 104) = 0u;
  *(void *)(a1 + 117) = 0LL;
  *(_OWORD *)(a1 + 152) = 0u;
  *(void *)(a1 + 184) = 0LL;
  *(void *)(a1 + 192) = &off_1007BC4C0;
  *(void *)(a1 + 216) = 0x100000003LL;
  *(_OWORD *)(a1 + 200) = xmmword_10042DB70;
  *(void *)(a1 + 224) = a1 + 232;
  sub_1002CAEDC((_DWORD *)(a1 + 192), 3, 1);
  sub_1002CAF28(a1 + 192, 0.0);
  *(void *)(a1 + 28_Block_object_dispose((const void *)(v1 - 112), 8) = 0x100000004LL;
  *(void *)(a1 + 264) = &off_1007BC550;
  *(_OWORD *)(a1 + 272) = xmmword_10042DB80;
  *(void *)(a1 + 296) = a1 + 304;
  sub_1002CAEDC((_DWORD *)(a1 + 264), 4, 1);
  sub_1002CAF28(a1 + 264, 0.0);
  *(void *)(a1 + 360) = 0x300000003LL;
  *(void *)(a1 + 336) = &off_1007BC508;
  *(_OWORD *)(a1 + 344) = xmmword_10042DE90;
  *(void *)(a1 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = a1 + 376;
  *(void *)(a1 + 44_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  *(_BYTE *)(a1 + 464) = 0;
  *(void *)(a1 + 496) = 0x100000003LL;
  *(void *)(a1 + 472) = &off_1007BC4C0;
  *(_OWORD *)(a1 + 480) = xmmword_10042DB70;
  *(void *)(a1 + 504) = a1 + 512;
  *(void *)(a1 + 560) = 0x100000003LL;
  *(void *)(a1 + 536) = &off_1007BC4C0;
  *(_OWORD *)(a1 + 544) = xmmword_10042DB70;
  *(void *)(a1 + 56_Block_object_dispose((const void *)(v1 - 112), 8) = a1 + 576;
  *(_OWORD *)(a1 + 600) = 0u;
  *(_OWORD *)(a1 + 616) = 0u;
  *(void *)(a1 + 632) = 0x3FF0000000000000LL;
  *(_OWORD *)(a1 + 640) = xmmword_10042DE50;
  *(_BYTE *)(a1 + 656) = 1;
  *(void *)(a1 + 72_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  *(_OWORD *)(a1 + 696) = 0u;
  *(_OWORD *)(a1 + 712) = 0u;
  *(_OWORD *)(a1 + 664) = 0u;
  *(_OWORD *)(a1 + 680) = 0u;
  uint64_t v13 = 0x100000003LL;
  *(void *)__int128 buf = &off_1007BC4C0;
  __int128 v12 = xmmword_10042DB70;
  unint64_t v14 = &v15;
  sub_1002CAEDC(buf, 3, 1);
  sub_1002CAF28((uint64_t)buf, 0.0);
  *(void *)(a1 + 736) = 0LL;
  *(void *)(a1 + 744) = 0LL;
  *(void *)(a1 + 752) = 0x7FF8000000000000LL;
  *(void *)(a1 + 76_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  *(void *)(a1 + 760) = 0LL;
  sub_1002D5F00(a1 + 776, (uint64_t)buf);
  unsigned int v5 = 0;
  *(void *)(a1 + 880) = 0x100000003LL;
  *(void *)(a1 + 856) = &off_1007BC4C0;
  *(_OWORD *)(a1 + 864) = xmmword_10042DB70;
  *(void *)(a1 + 88_Block_object_dispose((const void *)(v1 - 112), 8) = a1 + 896;
  *(_DWORD *)(a1 + 920) = 0x10000;
  *(_WORD *)(a1 + 924) = 257;
  *(_DWORD *)(a1 + 926) = 0;
  *(_DWORD *)(a1 + 929) = 0;
  *(void *)(a1 + 936) = 0x1000000032LL;
  *(void *)(a1 + 976) = 0x4018000000000000LL;
  *(_BYTE *)(a1 + 984) = 1;
  *(_DWORD *)(a1 + 840) = 0;
  *(void *)(a1 + 84_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  *(_OWORD *)(a1 + 944) = xmmword_10042E810;
  *(_OWORD *)(a1 + 960) = xmmword_10042E820;
  do
  {
    *(void *)sub_1002CB32C(a1 + 472, v5) = 0LL;
    *(void *)sub_1002CB32C(a1 + 536, v5++) = 0LL;
  }

  while (v5 != 3);
  sub_1002E53B4((uint64_t *)(a1 + 664), 4uLL);
  __int128 v6 = &qword_1007FEC98;
  if (a2) {
    unint64_t v7 = &qword_1007FEC80;
  }
  else {
    unint64_t v7 = &qword_1007FEC98;
  }
  if (v7 != (uint64_t *)a1)
  {
    if (a2) {
      __int128 v6 = &qword_1007FEC80;
    }
    sub_1002D6818((char *)a1, (char *)*v7, v6[1], (v6[1] - *v7) >> 4);
  }

  *(_BYTE *)(a1 + 984) = a3;
  char v8 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = a2;
    LOWORD(v12) = 1024;
    *(_DWORD *)((char *)&v12 + 2) = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_batchfilter,SyntheticApertureBatchFilter constructed. Strict box span requirement %d, third party behavior %d",  buf,  0xEu);
  }

  return a1;
}

void sub_1002E52CC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, void **a11, uint64_t a12, uint64_t a13, uint64_t a14, void **a15)
{
  a15 = (void **)(v15 + 712);
  sub_1002AFA80(&a15);
  a15 = (void **)(v15 + 688);
  sub_1002AFAC0(&a15);
  sub_1002AFA80(&a15);
  *(void *)(v15 + 536) = off_1007AED90;
  *(void *)(v15 + 472) = off_1007AED90;
  *(void *)(v15 + 336) = off_1007AED90;
  *uint64_t v17 = off_1007AED90;
  *unint64_t v16 = off_1007AED90;
  sub_1002AFB04(&a15);
  __int128 v20 = *v18;
  if (*v18)
  {
    *(void *)(v15 + 144) = v20;
    operator delete(v20);
  }

  int v21 = *a10;
  if (*a10)
  {
    *(void *)(v15 + 96) = v21;
    operator delete(v21);
  }

  uint64_t v22 = *a11;
  if (*a11)
  {
    *(void *)(v15 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v22;
    operator delete(v22);
  }

  __int16 v23 = *(void **)v15;
  if (*(void *)v15)
  {
    *(void *)(v15 + _Block_object_dispose((const void *)(v1 - 112), 8) = v23;
    operator delete(v23);
  }

  _Unwind_Resume(a1);
}

void sub_1002E53B4(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (0x6DB6DB6DB6DB6DB7LL * ((v4 - *a1) >> 4) < a2)
  {
    if (a2 >= 0x24924924924924ALL) {
      sub_10001E11C();
    }
    uint64_t v5 = a1[1] - *a1;
    uint64_t v13 = v3;
    stat __p = sub_1002ED1AC(v3, a2);
    __int128 v10 = (char *)__p + v5;
    __int128 v11 = (char *)__p + v5;
    __int128 v12 = (char *)__p + 112 * v6;
    sub_1002ED138(a1, &__p);
    unint64_t v7 = v10;
    char v8 = v11;
    if (v11 != v10)
    {
      do
      {
        *((void *)v8 - 9) = off_1007AED90;
        v8 -= 112;
      }

      while (v8 != v7);
      __int128 v11 = v7;
    }

    if (__p) {
      operator delete(__p);
    }
  }

double sub_1002E54D4@<D0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  if (*(_BYTE *)(a1 + 927) || *(_BYTE *)(a1 + 926)) {
    goto LABEL_3;
  }
  if (*(_BYTE *)(a1 + 920))
  {
    uint64_t v6 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(a1 + 624);
      int v10 = 134217984;
      uint64_t v11 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_batchfilter,Returning solution from AoA at %f s",  (uint8_t *)&v10,  0xCu);
    }

    *a2 = *(void *)(a1 + 72);
    *(void *)((char *)a2 + 5) = *(void *)(a1 + 77);
    a2[3] = 0LL;
    a2[4] = 0LL;
    a2[2] = 0LL;
    sub_1002CAB48( a2 + 2,  *(const void **)(a1 + 88),  *(void *)(a1 + 96),  0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(*(void *)(a1 + 96) - *(void *)(a1 + 88)) >> 3));
    uint64_t v4 = (double *)(a1 + 112);
  }

  else
  {
    if (!*(_BYTE *)(a1 + 921))
    {
LABEL_3:
      *a2 = *(void *)(a1 + 24);
      *(void *)((char *)a2 + 5) = *(void *)(a1 + 29);
      a2[3] = 0LL;
      a2[4] = 0LL;
      a2[2] = 0LL;
      sub_1002CAB48( a2 + 2,  *(const void **)(a1 + 40),  *(void *)(a1 + 48),  0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(*(void *)(a1 + 48) - *(void *)(a1 + 40)) >> 3));
      uint64_t v4 = (double *)(a1 + 64);
      goto LABEL_4;
    }

    char v8 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void *)(a1 + 848);
      int v10 = 134217984;
      uint64_t v11 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_batchfilter,Returning solution from straight path estimator at %f s",  (uint8_t *)&v10,  0xCu);
    }

    *a2 = *(void *)(a1 + 120);
    *(void *)((char *)a2 + 5) = *(void *)(a1 + 125);
    a2[3] = 0LL;
    a2[4] = 0LL;
    a2[2] = 0LL;
    sub_1002CAB48( a2 + 2,  *(const void **)(a1 + 136),  *(void *)(a1 + 144),  0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(*(void *)(a1 + 144) - *(void *)(a1 + 136)) >> 3));
    uint64_t v4 = (double *)(a1 + 160);
  }

void sub_1002E56D4(uint64_t a1@<X0>, void *a2@<X8>, double a3@<D0>, double a4@<D1>)
{
  *(double *)(a1 + 256) = a4;
  if (a3 - *(double *)(a1 + 608) <= 10.0 || *(void *)(a1 + 672) == *(void *)(a1 + 664))
  {
    if (*(_BYTE *)(a1 + 926))
    {
      *(_BYTE *)(a1 + 36) = 0;
      int v7 = *(_DWORD *)(a1 + 32);
      sub_1002E5A38(a1);
      if (v7 != *(_DWORD *)(a1 + 32))
      {
        char v8 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v11) = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_batchfilter,Vertical state changed with the pose update",  (uint8_t *)&v11,  2u);
        }

        *(_BYTE *)(a1 + 36) = 1;
      }
    }
  }

  else
  {
    sub_1002E5894(a1);
    *(_DWORD *)(a1 + 24) = 0;
    *(_BYTE *)(a1 + 2_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 36) = 0;
    sub_1002ECD2C((char *)(a1 + 40), 0LL, 0LL, 0LL);
    *(void *)(a1 + 64) = 0LL;
  }

  if (*(_BYTE *)(a1 + 920))
  {
    double v9 = *(double *)(a1 + 624);
    if (a3 - v9 > 10.0)
    {
      *(_BYTE *)(a1 + 920) = 0;
      int v10 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        int v11 = 134218240;
        double v12 = v9;
        __int16 v13 = 2048;
        double v14 = a3;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_batchfilter,AoA Solution from AoA at %f s is no longer valid - current time is %f s",  (uint8_t *)&v11,  0x16u);
      }
    }
  }

  sub_1002E54D4(a1, a2);
}

void sub_1002E5894(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 672);
  for (uint64_t i = *(void *)(a1 + 664); v2 != i; v2 -= 112LL)
    *(void *)(v2 - 72) = off_1007AED90;
  *(void *)(a1 + 672) = i;
  uint64_t v4 = *(void *)(a1 + 696);
  for (uint64_t j = *(void *)(a1 + 688); v4 != j; v4 -= 208LL)
  {
    *(void *)(v4 - 112) = off_1007AED90;
    *(void *)(v4 - 176) = off_1007AED90;
  }

  *(void *)(a1 + 696) = j;
  sub_1002E9100(a1);
  uint64_t v6 = *(void **)(a1 + 40);
  *(void *)(a1 + 29) = 0LL;
  *(void *)(a1 + 24) = 0LL;
  if (v6)
  {
    *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v6;
    operator delete(v6);
  }

  __int128 v7 = 0uLL;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  char v8 = *(void **)(a1 + 88);
  *(void *)(a1 + 72) = 0LL;
  *(void *)(a1 + 77) = 0LL;
  if (v8)
  {
    *(void *)(a1 + 96) = v8;
    operator delete(v8);
    __int128 v7 = 0uLL;
  }

  *(_OWORD *)(a1 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = v7;
  *(_OWORD *)(a1 + 104) = v7;
  double v9 = *(void **)(a1 + 136);
  *(void *)(a1 + 120) = 0LL;
  *(void *)(a1 + 125) = 0LL;
  if (v9)
  {
    *(void *)(a1 + 144) = v9;
    operator delete(v9);
  }

  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(void *)(a1 + 256) = 0LL;
  *(_OWORD *)(a1 + 600) = 0u;
  *(_OWORD *)(a1 + 616) = 0u;
  *(void *)(a1 + 632) = 0x3FF0000000000000LL;
  int v10 = *(void **)(a1 + 168);
  int v11 = *(void **)(a1 + 176);
  if (v11 != v10)
  {
    double v12 = v11 - 24;
    do
    {
      v12[16] = off_1007AED90;
      void *v12 = off_1007AED90;
      *(v12 - 14) = off_1007AED90;
      *(v12 - 22) = off_1007AED90;
      *(v12 - 30) = off_1007AED90;
      BOOL v13 = v12 - 30 == v10;
      v12 -= 54;
    }

    while (!v13);
  }

  *(void *)(a1 + 176) = v10;
  if (*(_BYTE *)(a1 + 656)) {
    *(_BYTE *)(a1 + 656) = 0;
  }
  *(_WORD *)(a1 + 920) = 0;
  *(void *)(a1 + 84_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  *(_BYTE *)(a1 + 464) = 0;
  double v14 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    v15[0] = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_batchfilter,Batch filter is reinitialized",  (uint8_t *)v15,  2u);
  }

void sub_1002E5A38(uint64_t a1)
{
  *(_DWORD *)(a1 + 92_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 932) = 0;
  if (*(_BYTE *)(a1 + 926))
  {
    uint64_t v2 = *(void *)(a1 + 168);
    uint64_t v47 = 0x100000003LL;
    float v45 = &off_1007BC4C0;
    __int128 v46 = xmmword_10042DB70;
    int8x16_t v48 = v49;
    sub_1002CB44C(v2, a1 + 192, (uint64_t)&v45);
    double v3 = sub_1002405E4((uint64_t)&v45, 0);
    double v4 = sub_1002405E4((uint64_t)&v45, 0);
    double v5 = sub_1002405E4((uint64_t)&v45, 2u);
    if (sqrt(v5 * sub_1002405E4((uint64_t)&v45, 2u) + v3 * v4) <= 2.0)
    {
      uint64_t v6 = *(void *)(a1 + 168);
      uint64_t v7 = *(void *)(a1 + 176);
      if (v6 == v7)
      {
LABEL_15:
        *(_DWORD *)(a1 + 92_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
      }

      else
      {
        while (1)
        {
          double v8 = sub_10024061C(v6 + 128, 1, 1);
          double v9 = sub_1002405E4(v6, 1u);
          double v10 = sqrt(v8);
          double v11 = v9 - *(double *)(a1 + 256);
          double v12 = v10 + v11;
          double v13 = v11 - v10;
          if (v13 <= -2.5 && v12 >= -2.5) {
            break;
          }
          if (v13 <= 2.5 && v12 >= 2.5) {
            break;
          }
          v6 += 432LL;
          if (v6 == v7) {
            goto LABEL_15;
          }
        }
      }
    }

    unint64_t v16 = 0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(*(void *)(a1 + 672) - *(void *)(a1 + 664)) >> 4);
    stat __p = 0LL;
    float32x4_t v43 = 0LL;
    unint64_t v44 = 0LL;
    sub_1002D5BB8(&__p, v16);
    uint64_t v17 = *(void *)(a1 + 664);
    uint64_t v18 = *(void *)(a1 + 672);
    if (v17 != v18)
    {
      uint64_t v19 = *(void *)(a1 + 168);
      do
      {
        uint64_t v39 = 0x100000003LL;
        uint64_t v37 = &off_1007BC4C0;
        __int128 v38 = xmmword_10042DB70;
        double v40 = &v41;
        sub_1002CB44C(v19, v17 + 40, (uint64_t)&v37);
        double v20 = sub_1002405E4((uint64_t)&v37, 0);
        double v21 = sub_1002405E4((uint64_t)&v37, 2u);
        if (*(_BYTE *)(a1 + 984) || sqrt(v21 * v21 + v20 * v20) <= 4.0)
        {
          double v22 = sub_1002405E4((uint64_t)&v37, 1u);
          double v23 = v22;
          uint64_t v24 = v43;
          if ((unint64_t)v43 >= v44)
          {
            int v26 = (double *)__p;
            int64_t v27 = ((char *)v43 - (_BYTE *)__p) >> 3;
            unint64_t v28 = v27 + 1;
            uint64_t v29 = v44 - (void)__p;
            else {
              unint64_t v30 = v28;
            }
            if (v30)
            {
              float32x4_t v31 = (char *)sub_1000472C0((uint64_t)&v44, v30);
              int v26 = (double *)__p;
              uint64_t v24 = v43;
            }

            else
            {
              float32x4_t v31 = 0LL;
            }

            uint64_t v32 = (double *)&v31[8 * v27];
            *uint64_t v32 = v23;
            __int16 v25 = v32 + 1;
            while (v24 != v26)
            {
              uint64_t v33 = *((void *)v24-- - 1);
              *((void *)v32-- - 1) = v33;
            }

            stat __p = v32;
            float32x4_t v43 = v25;
            unint64_t v44 = (unint64_t)&v31[8 * v30];
            if (v26) {
              operator delete(v26);
            }
          }

          else
          {
            *float32x4_t v43 = v22;
            __int16 v25 = v24 + 1;
          }

          float32x4_t v43 = v25;
        }

        v17 += 112LL;
      }

      while (v17 != v18);
    }

    unint64_t v34 = (double *)__p;
    if (__p != v43)
    {
      v49[31] = 0;
      uint64_t v35 = sub_10011B48C((double *)__p, v43);
      if (*v36 - *v35 >= 0.5)
      {
        *(_DWORD *)(a1 + 92_Block_object_dispose((const void *)(v1 - 112), 8) = 2;
        *(_BYTE *)(a1 + 932) = 1;
      }

      unint64_t v34 = (double *)__p;
    }

    if (v34)
    {
      float32x4_t v43 = v34;
      operator delete(v34);
    }
  }

void sub_1002E5D80( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p, uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002E5DB4(uint64_t **a1@<X1>, uint64_t *a2@<X8>)
{
  double v5 = *a1;
  double v4 = (__int128 *)a1[1];
  a2[1] = 0LL;
  a2[2] = 0LL;
  *a2 = 0LL;
  float32x4_t v63 = v5;
  v64[0] = v5;
  uint64_t v6 = (char *)v4 - (char *)v5;
  if (v4 == (__int128 *)v5)
  {
    double v5 = (uint64_t *)v4;
    uint64_t v7 = (uint64_t *)v4;
    goto LABEL_27;
  }

  uint64_t v7 = v5 + 14;
  int8x16_t v66 = (__int128 *)(v5 + 14);
  if (v5 + 14 == (uint64_t *)v4)
  {
    uint64_t v7 = v5;
    goto LABEL_27;
  }

  if (sub_1002ECE8C(&v66, (uint64_t *)&v63))
  {
    float32x4_t v63 = v5 + 14;
    double v8 = v5;
  }

  else
  {
    v64[0] = v5 + 14;
    double v8 = v5 + 14;
    uint64_t v7 = v5;
  }

  double v9 = (__int128 *)(v5 + 28);
  double v10 = v5 + 42;
  while (1)
  {
    float32x2_t v65 = (__int128 *)(v10 - 14);
    int8x16_t v66 = v9 + 7;
    if (v9 + 7 == v4) {
      break;
    }
    if (sub_1002ECE8C(&v66, (uint64_t *)&v65))
    {
      if (sub_1002ECE8C(&v66, (uint64_t *)&v63))
      {
        float32x4_t v63 = v10;
        uint64_t v7 = v10;
      }

      BOOL v11 = sub_1002ECE8C(&v65, (uint64_t *)v64);
      double v12 = v9;
      if (v11) {
        goto LABEL_20;
      }
    }

    else
    {
      if (sub_1002ECE8C(&v65, (uint64_t *)&v63))
      {
        float32x4_t v63 = v10 - 14;
        uint64_t v7 = v10 - 14;
      }

      BOOL v13 = sub_1002ECE8C(&v66, (uint64_t *)v64);
      double v12 = v10;
      if (v13) {
        goto LABEL_20;
      }
    }

    v64[0] = v12;
    double v8 = v12;
LABEL_20:
    v9 += 14;
    int8x16_t v66 = v9;
    v10 += 28;
    if (v9 == v4) {
      goto LABEL_26;
    }
  }

  if (sub_1002ECE8C(&v65, (uint64_t *)&v63))
  {
    uint64_t v7 = v10 - 14;
  }

  else if (!sub_1002ECE8C(&v65, (uint64_t *)v64))
  {
    double v8 = v10 - 14;
  }

void sub_1002E646C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

double sub_1002E64CC(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a2;
  if (a2[1] == *a2)
  {
    double v7 = 0.0;
  }

  else
  {
    unint64_t v6 = 0LL;
    double v7 = 0.0;
    do
    {
      uint64_t v37 = 0x100000003LL;
      double v35 = &off_1007BC4C0;
      __int128 v36 = xmmword_10042DB70;
      unsigned int v38 = &v39;
      uint64_t v32 = 0x100000003LL;
      unint64_t v30 = &off_1007BC4C0;
      __int128 v31 = xmmword_10042DB70;
      BOOL v33 = &v34;
      uint64_t v8 = *a3;
      uint64_t v9 = 112 * v6;
      double v10 = *(double *)(*a3 + 112 * v6 + 8);
      double v11 = *(double *)(v3 + 112 * v6 + 8);
      double v12 = 3.14159265
          - acos( ((v11 + 0.1) * (v11 + 0.1) + (v10 - v11) * (v10 - v11) - (v10 + -0.1) * (v10 + -0.1))
            / ((v11 + 0.1)
             * (v10 - v11 + v10 - v11)));
      if (v12 <= 1.0) {
        double v13 = 1.0;
      }
      else {
        double v13 = 1.0 / v12;
      }
      if (v10 <= v11) {
        uint64_t v14 = v8;
      }
      else {
        uint64_t v14 = v3;
      }
      sub_1002CBDC8((uint64_t)&v35, v14 + v9 + 40);
      uint64_t v15 = *a3;
      sub_1002CBDC8((uint64_t)&v30, v15 + v9 + 40);
      uint64_t v16 = *a2 + v9;
      uint64_t v17 = *a3 + v9;
      else {
        double v18 = *(double *)(v17 + 8);
      }
      uint64_t v27 = 0x100000003LL;
      __int16 v25 = &off_1007BC4C0;
      __int128 v26 = xmmword_10042DB70;
      unint64_t v28 = &v29;
      sub_1002CB44C((uint64_t)&v35, (uint64_t)&v30, (uint64_t)&v25);
      uint64_t v53 = 0x100000003LL;
      float v51 = &off_1007BC4C0;
      __int128 v52 = xmmword_10042DB70;
      unint64_t v54 = &v55;
      uint64_t v48 = 0x100000134LL;
      float v46 = &off_1007BC598;
      __int128 v47 = xmmword_10042DB90;
      float32x4_t v49 = v50;
      uint64_t v43 = 0x100000003LL;
      double v41 = &off_1007BC4C0;
      __int128 v42 = xmmword_10042DB70;
      float v44 = &v45;
      sub_1002CB6A8((uint64_t)&v25, (uint64_t)&v51, (uint64_t)&v46, (uint64_t)&v41, "2");
      double v20 = v19;
      uint64_t v48 = 0x100000003LL;
      float v46 = &off_1007BC4C0;
      __int128 v47 = xmmword_10042DB70;
      float32x4_t v49 = v50;
      sub_1002CB44C((uint64_t)&v35, (uint64_t)&v30, (uint64_t)&v46);
      uint64_t v21 = 0LL;
      double v7 = v7 + v13;
      do
      {
        double v22 = *(double *)sub_1002CB32C((uint64_t)&v30, v21);
        *(double *)&v40[v21] = *(double *)&v40[v21]
                             + v13 * (v22 + v18 * *(double *)sub_1002CB32C((uint64_t)&v46, v21) / v20);
        ++v21;
      }

      while (v21 != 3);
      ++v6;
      uint64_t v3 = *a2;
    }

    while (0x6DB6DB6DB6DB6DB7LL * ((a2[1] - *a2) >> 4) > v6);
  }

  for (uint64_t i = 0LL; i != 3; ++i)
    *(double *)&v40[i] = *(double *)&v40[i] / v7;
  return *(double *)v40;
}

void sub_1002E6844(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 672);
  uint64_t v2 = *(void *)(a1 + 664);
  unint64_t v3 = 0x6DB6DB6DB6DB6DB7LL * ((v1 - v2) >> 4);
  if (v3 >= 4)
  {
    uint64_t v4 = a1;
    if (*(_BYTE *)(a1 + 922))
    {
      uint64_t v5 = *(void *)(a1 + 720);
      for (uint64_t i = *(void *)(a1 + 712); v5 != i; v5 -= 112LL)
        *(void *)(v5 - 72) = off_1007AED90;
      *(void *)(a1 + 720) = i;
      memset(v105, 0, sizeof(v105));
      sub_1002ED500(v105, v2, v1, v3);
      sub_1002E5DB4(v105, (uint64_t *)buf);
      double v7 = (__int128 **)(v4 + 712);
      sub_1002ED67C((char **)(v4 + 712));
      *(_OWORD *)(v4 + 712) = *(_OWORD *)buf;
      *(void *)(v4 + 72_Block_object_dispose((const void *)(v1 - 112), 8) = *(void *)&buf[16];
      memset(buf, 0, sizeof(buf));
      __int128 v111 = buf;
      sub_1002AFA80((void ***)&v111);
      __int128 v111 = (uint8_t *)v105;
      sub_1002AFA80((void ***)&v111);
      __int16 v102 = 0LL;
      float64_t v103 = 0LL;
      unint64_t v104 = 0LL;
      uint64_t v8 = *(void *)(v4 + 720);
      if (v8 == *(void *)(v4 + 712))
      {
        uint64_t v26 = *(void *)(v4 + 720);
      }

      else
      {
        uint64_t v9 = 0LL;
        unint64_t v10 = 0LL;
        double v11 = v101;
        double v12 = v115;
        double v13 = v119;
        uint64_t v8 = *(void *)(v4 + 712);
        do
        {
          uint64_t v14 = *(void *)(v4 + 672) - 72LL;
          uint64_t v99 = 0x100000003LL;
          float64_t v97 = &off_1007BC4C0;
          __int128 v98 = xmmword_10042DB70;
          __int16 v100 = v11;
          sub_1002CB44C(v8 + v9 * 16 + 40, v14, (uint64_t)&v97);
          uint64_t v113 = 0x100000003LL;
          __int128 v111 = (uint8_t *)&off_1007BC4C0;
          __int128 v112 = xmmword_10042DB70;
          __int128 v114 = v12;
          uint64_t v117 = 0x100000134LL;
          *(void *)__int128 buf = &off_1007BC598;
          *(_OWORD *)&uint8_t buf[8] = xmmword_10042DB90;
          unint64_t v118 = v13;
          uint64_t v108 = 0x100000003LL;
          __int16 v106 = &off_1007BC4C0;
          __int128 v107 = xmmword_10042DB70;
          __int128 v109 = v110;
          sub_1002CB6A8((uint64_t)&v97, (uint64_t)&v111, (uint64_t)buf, (uint64_t)&v106, "2");
          if (v15 < 2.0)
          {
            uint64_t v16 = v13;
            uint64_t v17 = v12;
            double v18 = v11;
            uint64_t v19 = v4;
            double v20 = *v7;
            uint64_t v21 = &(*v7)[v9];
            double v22 = v103;
            if ((unint64_t)v103 >= v104)
            {
              __int16 v25 = (__int128 *)sub_1002ED6D8((uint64_t *)&v102, v21);
            }

            else
            {
              __int128 v23 = *v21;
              __int128 v24 = v21[1];
              *((void *)v103 + 4) = *((void *)v21 + 4);
              *double v22 = v23;
              v22[1] = v24;
              sub_1002D5F00((uint64_t)v22 + 40, (uint64_t)v21 + 40);
              *((_DWORD *)v22 + 26) = DWORD2(v20[v9 + 6]);
              __int16 v25 = v22 + 7;
            }

            uint64_t v4 = v19;
            double v12 = v17;
            float64_t v103 = v25;
            double v11 = v18;
            double v13 = v16;
          }

          ++v10;
          uint64_t v26 = *(void *)(v4 + 720);
          uint64_t v8 = *(void *)(v4 + 712);
          v9 += 7LL;
        }

        while (0x6DB6DB6DB6DB6DB7LL * ((v26 - v8) >> 4) > v10);
      }

      if (v7 != &v102)
      {
        sub_1002ED878((uint64_t)v7, v102, v103, 0x6DB6DB6DB6DB6DB7LL * (v103 - v102));
        uint64_t v26 = *(void *)(v4 + 720);
        uint64_t v8 = *(void *)(v4 + 712);
      }

      uint64_t v27 = 0x6DB6DB6DB6DB6DB7LL * ((v26 - v8) >> 4);
      int v28 = v27 - 2;
      if ((int)v27 >= 2)
      {
        if (v28)
        {
          if (v28 == 1) {
            int v29 = v27;
          }
          else {
            int v29 = ((int)v27 - 1) * (int)v27 / 2;
          }
        }

        else
        {
          int v29 = 1;
        }

        if (v27 >= 5)
        {
          int v83 = v29;
          uint64_t v82 = v4;
          uint64_t v30 = 0LL;
          uint64_t v94 = 0LL;
          unint64_t v95 = 0LL;
          uint64_t v85 = (v27 - 1);
          unint64_t v96 = 0LL;
          uint64_t v91 = 0LL;
          unint64_t v92 = 0LL;
          uint64_t v86 = (int)v27;
          unint64_t v93 = 0LL;
          uint64_t v84 = v27;
          uint64_t v31 = 1LL;
          uint64_t v88 = 112LL;
          do
          {
            uint64_t v87 = v30 + 1;
            if (v30 + 1 < v86)
            {
              uint64_t v32 = v84;
              uint64_t v33 = v88;
              do
              {
                uint64_t v34 = *v7;
                double v35 = (double *)((char *)*v7 + v33);
                double v36 = v35[1];
                double v37 = *((double *)&(*v7)[7 * v30] + 1);
                if (vabdd_f64( 3.14159265,  acos( ((v37 + 0.1) * (v37 + 0.1) + (v36 - v37) * (v36 - v37) - (v36 + -0.1) * (v36 + -0.1))
                       / ((v37 + 0.1)
                        * (v36 - v37 + v36 - v37)))) < 1.22173048)
                {
                  uint64_t v99 = 0x100000003LL;
                  float64_t v97 = &off_1007BC4C0;
                  __int128 v98 = xmmword_10042DB70;
                  __int16 v100 = v101;
                  sub_1002CB44C((uint64_t)&v34[7 * v30 + 2] + 8, (uint64_t)(v35 + 5), (uint64_t)&v97);
                  uint64_t v113 = 0x100000003LL;
                  __int128 v111 = (uint8_t *)&off_1007BC4C0;
                  __int128 v112 = xmmword_10042DB70;
                  __int128 v114 = v115;
                  uint64_t v117 = 0x100000134LL;
                  *(void *)__int128 buf = &off_1007BC598;
                  *(_OWORD *)&uint8_t buf[8] = xmmword_10042DB90;
                  unint64_t v118 = v119;
                  uint64_t v108 = 0x100000003LL;
                  __int16 v106 = &off_1007BC4C0;
                  __int128 v107 = xmmword_10042DB70;
                  __int128 v109 = v110;
                  sub_1002CB6A8((uint64_t)&v97, (uint64_t)&v111, (uint64_t)buf, (uint64_t)&v106, "2");
                  if (vabdd_f64(v38, fmax(v37, v36) - fmin(v37, v36)) < 0.1414)
                  {
                    uint64_t v39 = *v7;
                    uint64_t v40 = (uint64_t)&(*v7)[7 * v30 + 2] + 8;
                    uint64_t v99 = 0x100000003LL;
                    float64_t v97 = &off_1007BC4C0;
                    __int128 v98 = xmmword_10042DB70;
                    __int16 v100 = v101;
                    sub_1002CB44C(v40, (uint64_t)v39 + v33 + 40, (uint64_t)&v97);
                    uint64_t v113 = 0x100000003LL;
                    __int128 v111 = (uint8_t *)&off_1007BC4C0;
                    __int128 v112 = xmmword_10042DB70;
                    __int128 v114 = v115;
                    uint64_t v117 = 0x100000134LL;
                    *(void *)__int128 buf = &off_1007BC598;
                    *(_OWORD *)&uint8_t buf[8] = xmmword_10042DB90;
                    unint64_t v118 = v119;
                    uint64_t v108 = 0x100000003LL;
                    __int16 v106 = &off_1007BC4C0;
                    __int128 v107 = xmmword_10042DB70;
                    __int128 v109 = v110;
                    sub_1002CB6A8((uint64_t)&v97, (uint64_t)&v111, (uint64_t)buf, (uint64_t)&v106, "2");
                    if (v41 > 0.25)
                    {
                      __int128 v42 = *v7;
                      uint64_t v43 = (uint64_t)&(*v7)[7 * v30];
                      unint64_t v44 = v95;
                      if (v95 >= v96)
                      {
                        uint64_t v47 = sub_1002ED6D8(&v94, (__int128 *)v43);
                      }

                      else
                      {
                        __int128 v45 = *(_OWORD *)v43;
                        __int128 v46 = *(_OWORD *)(v43 + 16);
                        *(void *)(v95 + 32) = *(void *)(v43 + 32);
                        *(_OWORD *)unint64_t v44 = v45;
                        *(_OWORD *)(v44 + 16) = v46;
                        sub_1002D5F00(v44 + 40, (uint64_t)&v42[7 * v30 + 2] + 8);
                        *(_DWORD *)(v44 + 104) = DWORD2(v42[7 * v30 + 6]);
                        uint64_t v47 = v44 + 112;
                      }

                      unint64_t v95 = v47;
                      uint64_t v48 = *v7;
                      float32x4_t v49 = (__int128 *)((char *)*v7 + v33);
                      unint64_t v50 = v92;
                      if (v92 >= v93)
                      {
                        uint64_t v53 = sub_1002ED6D8(&v91, v49);
                      }

                      else
                      {
                        __int128 v51 = *v49;
                        __int128 v52 = v49[1];
                        *(void *)(v92 + 32) = *((void *)v49 + 4);
                        *(_OWORD *)unint64_t v50 = v51;
                        *(_OWORD *)(v50 + 16) = v52;
                        sub_1002D5F00(v50 + 40, (uint64_t)v49 + 40);
                        *(_DWORD *)(v50 + 104) = *(_DWORD *)((char *)v48 + v33 + 104);
                        uint64_t v53 = v50 + 112;
                      }

                      unint64_t v92 = v53;
                    }
                  }
                }

                v33 += 112LL;
                --v32;
              }

              while (v31 != v32);
            }

            ++v31;
            v88 += 112LL;
            ++v30;
          }

          while (v87 != v85);
          unint64_t v54 = 0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(v95 - v94) >> 4);
          if (v54 > 5 && (float)((float)((float)v54 / (float)v83) * 100.0) >= 70.0)
          {
            *(_BYTE *)(v82 + 921) = 1;
            *(void *)(v82 + 84_Block_object_dispose((const void *)(v1 - 112), 8) = *(void *)(v82 + 608);
            sub_1002CBDC8(v82 + 856, v82 + 192);
            uint64_t v55 = (os_log_s *)qword_1008000A0;
            if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v56 = *(void *)(v82 + 608);
              *(_DWORD *)__int128 buf = 134217984;
              *(void *)&uint8_t buf[4] = v56;
              _os_log_impl( (void *)&_mh_execute_header,  v55,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_batchfilter,Straight path solution generated at %f s",  buf,  0xCu);
            }

            *(_DWORD *)(v82 + 120) = 5;
            *(_BYTE *)(v82 + 124) = 1;
            *(_DWORD *)(v82 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = 2;
            *(_BYTE *)(v82 + 132) = 0;
            *(void *)(v82 + 160) = 0LL;
            memset(v90, 0, sizeof(v90));
            sub_1002ED500(v90, v94, v95, 0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(v95 - v94) >> 4));
            memset(v89, 0, sizeof(v89));
            uint64_t v57 = sub_1002ED500(v89, v91, v92, 0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(v92 - v91) >> 4));
            double v58 = sub_1002E64CC((uint64_t)v57, v90, v89);
            uint64_t v60 = v59;
            uint64_t v62 = v61;
            *(void *)__int128 buf = v89;
            sub_1002AFA80((void ***)buf);
            *(void *)__int128 buf = v90;
            sub_1002AFA80((void ***)buf);
            unint64_t v63 = *(void *)(v82 + 152);
            unint64_t v64 = *(void *)(v82 + 136);
            *(void *)(v82 + 144) = v64;
            if (v64 >= v63)
            {
              unint64_t v66 = 0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(v63 - v64) >> 3);
              uint64_t v67 = 2 * v66;
              if (2 * v66 <= 1) {
                uint64_t v67 = 1LL;
              }
              if (v66 >= 0xC30C30C30C30C3LL) {
                unint64_t v68 = 0x186186186186186LL;
              }
              else {
                unint64_t v68 = v67;
              }
              float32x2_t v69 = (char *)sub_10001F014(v82 + 152, v68);
              double v71 = &v69[168 * v70];
              *(double *)float32x2_t v69 = v58;
              *((void *)v69 + 1) = v60;
              *((void *)v69 + 2) = v62;
              *((void *)v69 + 4) = 0LL;
              *((void *)v69 + 5) = 0LL;
              *((void *)v69 + 3) = 0x3F847AE147AE147CLL;
              *((_OWORD *)v69 + 3) = xmmword_10042E830;
              *((_OWORD *)v69 + 4) = xmmword_10042E840;
              *((void *)v69 + 10) = 0x3FF0000000000000LL;
              *(_OWORD *)(v69 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
              *(_OWORD *)(v69 + 104) = 0u;
              *(_OWORD *)(v69 + 120) = 0u;
              *(_OWORD *)(v69 + 136) = 0u;
              *((void *)v69 + 19) = 0LL;
              *((_DWORD *)v69 + 40) = 2;
              float32x2_t v65 = v69 + 168;
              double v73 = *(char **)(v82 + 136);
              double v72 = *(char **)(v82 + 144);
              if (v72 != v73)
              {
                do
                {
                  __int128 v74 = *(_OWORD *)(v72 - 168);
                  __int128 v75 = *(_OWORD *)(v72 - 152);
                  *(_OWORD *)(v69 - 136) = *(_OWORD *)(v72 - 136);
                  *(_OWORD *)(v69 - 152) = v75;
                  *(_OWORD *)(v69 - 16_Block_object_dispose((const void *)(v1 - 112), 8) = v74;
                  __int128 v76 = *(_OWORD *)(v72 - 120);
                  __int128 v77 = *(_OWORD *)(v72 - 104);
                  __int128 v78 = *(_OWORD *)(v72 - 88);
                  *(_OWORD *)(v69 - 72) = *(_OWORD *)(v72 - 72);
                  *(_OWORD *)(v69 - 8_Block_object_dispose((const void *)(v1 - 112), 8) = v78;
                  *(_OWORD *)(v69 - 104) = v77;
                  *(_OWORD *)(v69 - 120) = v76;
                  __int128 v79 = *(_OWORD *)(v72 - 56);
                  __int128 v80 = *(_OWORD *)(v72 - 40);
                  __int128 v81 = *(_OWORD *)(v72 - 24);
                  *((_DWORD *)v69 - 2) = *((_DWORD *)v72 - 2);
                  *(_OWORD *)(v69 - 24) = v81;
                  *(_OWORD *)(v69 - 40) = v80;
                  *(_OWORD *)(v69 - 56) = v79;
                  v69 -= 168;
                  v72 -= 168;
                }

                while (v72 != v73);
                double v72 = *(char **)(v82 + 136);
              }

              *(void *)(v82 + 136) = v69;
              *(void *)(v82 + 144) = v65;
              *(void *)(v82 + 152) = v71;
              if (v72) {
                operator delete(v72);
              }
            }

            else
            {
              *(double *)unint64_t v64 = v58;
              *(void *)(v64 + _Block_object_dispose((const void *)(v1 - 112), 8) = v60;
              *(void *)(v64 + 16) = v62;
              *(void *)(v64 + 32) = 0LL;
              *(void *)(v64 + 40) = 0LL;
              *(void *)(v64 + 24) = 0x3F847AE147AE147CLL;
              *(_OWORD *)(v64 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = xmmword_10042E830;
              *(_OWORD *)(v64 + 64) = xmmword_10042E840;
              *(void *)(v64 + 80) = 0x3FF0000000000000LL;
              *(_OWORD *)(v64 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
              *(_OWORD *)(v64 + 104) = 0u;
              *(_OWORD *)(v64 + 120) = 0u;
              *(_OWORD *)(v64 + 136) = 0u;
              *(_DWORD *)(v64 + 160) = 2;
              float32x2_t v65 = (char *)(v64 + 168);
              *(void *)(v64 + 152) = 0LL;
            }

            *(void *)(v82 + 144) = v65;
          }

          *(void *)__int128 buf = &v91;
          sub_1002AFA80((void ***)buf);
          *(void *)__int128 buf = &v94;
          sub_1002AFA80((void ***)buf);
        }
      }

      *(void *)__int128 buf = &v102;
      sub_1002AFA80((void ***)buf);
    }
  }

void sub_1002E72D4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, char a33, uint64_t a34, uint64_t a35, char a36, uint64_t a37, uint64_t a38, void **a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, char a47)
{
  a39 = (void **)&a33;
  sub_1002AFA80(&a39);
  a39 = (void **)&a36;
  sub_1002AFA80(&a39);
  a39 = (void **)&a47;
  sub_1002AFA80(&a39);
  _Unwind_Resume(a1);
}

uint64_t sub_1002E73A8(uint64_t result, char a2)
{
  *(_BYTE *)(result + 922) = a2;
  return result;
}

uint64_t sub_1002E73B0(uint64_t result, char a2, double a3)
{
  *(double *)(result + 456) = a3;
  *(_BYTE *)(result + 464) = a2;
  return result;
}

void sub_1002E73BC(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  if (*(_BYTE *)(a1 + 927))
  {
    *(_BYTE *)(a1 + 927) = 0;
    if (*(void *)(a1 + 664) != *(void *)(a1 + 672)) {
      sub_1002E5894(a1);
    }
  }

  *(void *)(a1 + 256) = *(void *)(a2 + 104);
  uint64_t v200 = 0x100000003LL;
  v198 = &off_1007BC4C0;
  __int128 v199 = xmmword_10042DB70;
  v201 = &v202;
  sub_1002CAEDC(&v198, 3, 1);
  sub_1002CAF28((uint64_t)&v198, 0.0);
  uint64_t v195 = 0x100000004LL;
  v193 = &off_1007BC550;
  __int128 v194 = xmmword_10042DB80;
  v196 = &v197;
  sub_1002CAEDC(&v193, 4, 1);
  sub_1002CAF28((uint64_t)&v193, 0.0);
  for (uint64_t i = 0LL; i != 3; ++i)
  {
    uint64_t v7 = a2 + 8 * i;
    uint64_t v8 = *(void *)(v7 + 96);
    *(void *)sub_1002CB32C((uint64_t)&v198, i) = v8;
    uint64_t v9 = *(void *)(v7 + 120);
    *(void *)sub_1002CB32C((uint64_t)&v193, i) = v9;
  }

  uint64_t v10 = *(void *)(a2 + 144);
  *(void *)sub_1002CB32C((uint64_t)&v193, 3u) = v10;
  sub_1003198FC((uint64_t)&v193, (uint64_t)v192);
  double buf[3] = 0x100000003LL;
  buf[0] = &off_1007BC4C0;
  *(_OWORD *)&buf[1] = xmmword_10042DB70;
  *(void *)&__int128 v209 = (char *)&v209 + 8;
  sub_1002CB548((uint64_t)v192, a1 + 472, (uint64_t)buf);
  uint64_t v189 = 0x100000003LL;
  __int128 v187 = &off_1007BC4C0;
  __int128 v188 = xmmword_10042DB70;
  v190 = &v191;
  sub_1002CC25C((uint64_t)&v198, (uint64_t)buf, (uint64_t)&v187);
  uint64_t v152 = a1 + 192;
  sub_1002CBDC8(a1 + 192, (uint64_t)&v198);
  sub_1002CBDC8(a1 + 264, (uint64_t)&v193);
  sub_1002CBDC8(a1 + 336, (uint64_t)v192);
  double v11 = *(double *)a2;
  *(void *)(a1 + 60_Block_object_dispose((const void *)(v1 - 112), 8) = *(void *)a2;
  if (*(_BYTE *)(a1 + 920))
  {
    double v12 = *(double *)(a1 + 624);
    if (v11 - v12 > 10.0)
    {
      *(_BYTE *)(a1 + 920) = 0;
      double v13 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf[0]) = 134218240;
        *(double *)((char *)buf + 4) = v12;
        WORD2(buf[1]) = 2048;
        *(double *)((char *)&buf[1] + 6) = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_batchfilter,AoA Solution from AoA at %f s is no longer valid - current time is %f s",  (uint8_t *)buf,  0x16u);
      }
    }
  }

  if (*(_BYTE *)(a1 + 921))
  {
    double v14 = *(double *)(a1 + 608) - *(double *)(a1 + 848);
    if (v14 >= 5.0)
    {
      uint64_t v160 = 0x100000003LL;
      v158 = &off_1007BC4C0;
      __int128 v159 = xmmword_10042DB70;
      v161 = v162;
      sub_1002CB44C((uint64_t)&v187, a1 + 856, (uint64_t)&v158);
      *((void *)&v174[1] + 1) = 0x100000003LL;
      *(void *)&v174[0] = &off_1007BC4C0;
      *(_OWORD *)((char *)v174 + _Block_object_dispose((const void *)(v1 - 112), 8) = xmmword_10042DB70;
      *(void *)&__int128 v175 = (char *)&v175 + 8;
      double buf[3] = 0x100000134LL;
      buf[0] = &off_1007BC598;
      *(_OWORD *)&buf[1] = xmmword_10042DB90;
      *(void *)&__int128 v209 = (char *)&v209 + 8;
      uint64_t v165 = 0x100000003LL;
      unint64_t v163 = &off_1007BC4C0;
      __int128 v164 = xmmword_10042DB70;
      unint64_t v166 = v167;
      sub_1002CB6A8((uint64_t)&v158, (uint64_t)v174, (uint64_t)buf, (uint64_t)&v163, "2");
      if (v15 > 1.0)
      {
LABEL_16:
        *(_BYTE *)(a1 + 921) = 0;
        uint64_t v16 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v17 = *(void *)(a1 + 848);
          uint64_t v18 = *(void *)(a1 + 608);
          LODWORD(buf[0]) = 134218240;
          *(void *)((char *)buf + 4) = v17;
          WORD2(buf[1]) = 2048;
          *(void *)((char *)&buf[1] + 6) = v18;
          _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_batchfilter,Straight path solution at %f s is no longer valid - current time is %f s",  (uint8_t *)buf,  0x16u);
        }
      }
    }
  }

  double v19 = *(double *)(a2 + 16);
  if (v19 <= 0.0 || *(double *)(a2 + 8) < -1.0)
  {
    double v20 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
      sub_1003AA490(a2, v20, v19);
    }
    goto LABEL_142;
  }

  uint64_t v21 = *(void *)(a1 + 672);
  if (v21 != *(void *)(a1 + 664))
  {
    uint64_t v160 = 0x100000003LL;
    v158 = &off_1007BC4C0;
    __int128 v159 = xmmword_10042DB70;
    v161 = v162;
    sub_1002CB44C((uint64_t)&v187, v21 - 72, (uint64_t)&v158);
    *((void *)&v174[1] + 1) = 0x100000003LL;
    *(void *)&v174[0] = &off_1007BC4C0;
    *(_OWORD *)((char *)v174 + _Block_object_dispose((const void *)(v1 - 112), 8) = xmmword_10042DB70;
    *(void *)&__int128 v175 = (char *)&v175 + 8;
    double buf[3] = 0x100000134LL;
    buf[0] = &off_1007BC598;
    *(_OWORD *)&buf[1] = xmmword_10042DB90;
    *(void *)&__int128 v209 = (char *)&v209 + 8;
    uint64_t v165 = 0x100000003LL;
    unint64_t v163 = &off_1007BC4C0;
    __int128 v164 = xmmword_10042DB70;
    unint64_t v166 = v167;
    sub_1002CB6A8((uint64_t)&v158, (uint64_t)v174, (uint64_t)buf, (uint64_t)&v163, "2");
    double v23 = v22;
    double v24 = *(double *)(a2 + 8);
    double v25 = *(double *)(v21 - 104);
    double v26 = v24 - v25;
    if (v24 - v25 <= 0.0)
    {
      if ((fabs(v26) - v23) / *(double *)(a2 + 16) > 6.0)
      {
        int v28 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR))
        {
          LODWORD(buf[0]) = 134218496;
          *(double *)((char *)buf + 4) = v25;
          WORD2(buf[1]) = 2048;
          *(double *)((char *)&buf[1] + 6) = v24;
          HIWORD(buf[2]) = 2048;
          *(double *)&double buf[3] = v23;
          _os_log_error_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_ERROR,  "#sa_algo_batchfilter,nLoS->LoS event detected by the batch filter: Previous range %f m, Current range %f m, Distance travelled %f m",  (uint8_t *)buf,  0x20u);
        }

        stat __p = 0LL;
        __int128 v154 = 0uLL;
        uint64_t v29 = *(void *)(a1 + 664);
        if (v29 != *(void *)(a1 + 672))
        {
          do
          {
            uint64_t v160 = 0x100000003LL;
            v158 = &off_1007BC4C0;
            __int128 v159 = xmmword_10042DB70;
            v161 = v162;
            sub_1002CB44C((uint64_t)&v187, v29 + 40, (uint64_t)&v158);
            *((void *)&v174[1] + 1) = 0x100000003LL;
            *(void *)&v174[0] = &off_1007BC4C0;
            *(_OWORD *)((char *)v174 + _Block_object_dispose((const void *)(v1 - 112), 8) = xmmword_10042DB70;
            *(void *)&__int128 v175 = (char *)&v175 + 8;
            double buf[3] = 0x100000134LL;
            buf[0] = &off_1007BC598;
            *(_OWORD *)&buf[1] = xmmword_10042DB90;
            *(void *)&__int128 v209 = (char *)&v209 + 8;
            uint64_t v165 = 0x100000003LL;
            unint64_t v163 = &off_1007BC4C0;
            __int128 v164 = xmmword_10042DB70;
            unint64_t v166 = v167;
            sub_1002CB6A8((uint64_t)&v158, (uint64_t)v174, (uint64_t)buf, (uint64_t)&v163, "2");
            if ((*(double *)(v29 + 8) - *(double *)(a2 + 8) - v30) / *(double *)(a2 + 16) <= 6.0)
            {
              v29 += 112LL;
              uint64_t v48 = *(void *)(a1 + 672);
            }

            else
            {
              int v31 = 0;
              do
              {
                uint64_t v32 = *(void *)(a1 + 688);
                double v33 = *(double *)(v32 + 208LL * v31);
                double v34 = *(double *)v29;
                if (v33 == *(double *)v29)
                {
                  double v35 = (char *)v154;
                  if ((unint64_t)v154 >= *((void *)&v154 + 1))
                  {
                    double v37 = (char *)__p;
                    uint64_t v38 = (uint64_t)(v154 - (void)__p) >> 3;
                    unint64_t v39 = v38 + 1;
                    uint64_t v40 = *((void *)&v154 + 1) - (void)__p;
                    else {
                      unint64_t v41 = v39;
                    }
                    if (v41)
                    {
                      __int128 v42 = (char *)sub_1000472C0((uint64_t)&v154 + 8, v41);
                      double v37 = (char *)__p;
                      double v35 = (char *)v154;
                    }

                    else
                    {
                      __int128 v42 = 0LL;
                    }

                    uint64_t v43 = &v42[8 * v38];
                    *(void *)uint64_t v43 = v31;
                    double v36 = v43 + 8;
                    while (v35 != v37)
                    {
                      uint64_t v44 = *((void *)v35 - 1);
                      v35 -= 8;
                      *((void *)v43 - 1) = v44;
                      v43 -= 8;
                    }

                    stat __p = v43;
                    *(void *)&__int128 v154 = v36;
                    *((void *)&v154 + 1) = &v42[8 * v41];
                    if (v37) {
                      operator delete(v37);
                    }
                  }

                  else
                  {
                    *(void *)__int128 v154 = v31;
                    double v36 = v35 + 8;
                  }

                  *(void *)&__int128 v154 = v36;
                }

                else
                {
                  ++v31;
                }
              }

              while (v33 != v34);
              if (*(_BYTE *)(a1 + 920))
              {
                double v45 = *(double *)(a1 + 624);
                if (*(double *)v29 == v45)
                {
                  *(_BYTE *)(a1 + 920) = 0;
                  __int128 v46 = (os_log_s *)qword_1008000A0;
                  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
                  {
                    LODWORD(buf[0]) = 134217984;
                    *(double *)((char *)buf + 4) = v45;
                    _os_log_impl( (void *)&_mh_execute_header,  v46,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_batchfilter,AoA Solution from AoA at %f s is no longer valid due to multipath",  (uint8_t *)buf,  0xCu);
                  }
                }
              }

              uint64_t v47 = (os_log_s *)qword_1008000A0;
              if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR))
              {
                double v50 = *(double *)v29;
                uint64_t v51 = *(void *)(v29 + 8);
                LODWORD(buf[0]) = 134218240;
                *(double *)((char *)buf + 4) = v50;
                WORD2(buf[1]) = 2048;
                *(void *)((char *)&buf[1] + 6) = v51;
                _os_log_error_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_ERROR,  "#sa_algo_batchfilter,Removing measurement at time %f s with range %f m",  (uint8_t *)buf,  0x16u);
              }

              sub_1002EDA08((__int128 *)(v29 + 112), *(__int128 **)(a1 + 672), v29);
              for (uint64_t j = *(void *)(a1 + 672); j != v48; j -= 112LL)
                *(void *)(j - 72) = off_1007AED90;
              *(void *)(a1 + 672) = v48;
            }
          }

          while (v29 != v48);
          __int128 v52 = (char *)v154;
          if ((void *)v154 != __p)
          {
            uint64_t v53 = *(_OWORD **)(a1 + 696);
            do
            {
              uint64_t v54 = *((void *)v52 - 1);
              v52 -= 8;
              sub_1002EDA80( (uint64_t)buf,  (_OWORD *)(*(void *)(a1 + 688) + 208 * v54 + 208),  v53,  (_OWORD *)(*(void *)(a1 + 688) + 208 * v54));
              uint64_t v53 = v55;
              for (uint64_t k = *(_OWORD **)(a1 + 696); k != v55; k -= 13)
              {
                *((void *)k - 14) = off_1007AED90;
                *((void *)k - 22) = off_1007AED90;
              }

              *(void *)(a1 + 696) = v55;
            }

            while (v52 != __p);
          }
        }

        sub_1002E9100(a1);
        uint64_t v57 = *(double **)(a1 + 664);
        double v58 = *(double **)(a1 + 672);
        if (v57 == v58)
        {
          *(void *)(a1 + 632) = 0x3FF0000000000000LL;
        }

        else
        {
          uint64_t v59 = v57 + 14;
          uint64_t v60 = *(double **)(a1 + 664);
          if (v57 + 14 != v58)
          {
            uint64_t v60 = *(double **)(a1 + 664);
            do
            {
              if (v59[1] < v60[1]) {
                uint64_t v60 = v59;
              }
              v59 += 14;
            }

            while (v59 != v58);
          }

          double v61 = fmax(v60[1], 1.0);
          if (v61 != *(double *)(a1 + 632))
          {
            *(double *)(a1 + 632) = v61;
            do
            {
              double v62 = sub_100319B40(v57[1] / *(double *)(a1 + 632));
              v57[4] = v62;
              v57[2] = v57[1] / (v62 * v57[3]);
              v57 += 14;
            }

            while (v57 != v58);
          }
        }

        if (__p)
        {
          *(void *)&__int128 v154 = __p;
          operator delete(__p);
        }
      }
    }

    else if ((v26 - v23) / *(double *)(a2 + 16) > 6.0)
    {
      uint64_t v27 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf[0]) = 134218496;
        *(double *)((char *)buf + 4) = v25;
        WORD2(buf[1]) = 2048;
        *(double *)((char *)&buf[1] + 6) = v24;
        HIWORD(buf[2]) = 2048;
        *(double *)&double buf[3] = v23;
        _os_log_error_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_ERROR,  "#sa_algo_batchfilter,LoS->nLoS event detected by the batch filter: Previous range %f m, Current range %f m, Di stance travelled %f m",  (uint8_t *)buf,  0x20u);
      }

      goto LABEL_129;
    }
  }

  unint64_t v63 = *(double **)(a1 + 664);
  unint64_t v64 = *(double **)(a1 + 672);
  double v65 = *(double *)(a2 + 8);
  if (v63 == v64)
  {
    double v70 = fmax(v65, 1.0);
    *(double *)(a1 + 632) = v70;
    double v71 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf[0]) = 134217984;
      *(double *)((char *)buf + 4) = v70;
      _os_log_impl( (void *)&_mh_execute_header,  v71,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_batchfilter,Minimum observed range initialized to %f m",  (uint8_t *)buf,  0xCu);
    }
  }

  else
  {
    double v66 = *(double *)(a1 + 632);
    if (v65 < v66 && v66 > 1.0)
    {
      double v67 = fmax(v65, 1.0);
      *(double *)(a1 + 632) = v67;
      unint64_t v68 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf[0]) = 134217984;
        *(double *)((char *)buf + 4) = v67;
        _os_log_impl( (void *)&_mh_execute_header,  v68,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_batchfilter,Minimum observed range changed to %f m",  (uint8_t *)buf,  0xCu);
        unint64_t v63 = *(double **)(a1 + 664);
        unint64_t v64 = *(double **)(a1 + 672);
      }

      while (v63 != v64)
      {
        double v69 = sub_100319B40(v63[1] / *(double *)(a1 + 632));
        v63[4] = v69;
        v63[2] = v63[1] / (v69 * v63[3]);
        v63 += 14;
      }
    }
  }

  double v72 = sub_100319B40(*(double *)(a2 + 8) / *(double *)(a1 + 632));
  double v73 = *(double *)(a2 + 8);
  if (v73 <= 10.0) {
    double v74 = 0.1;
  }
  else {
    double v74 = *(double *)(a2 + 8) / 10.0 * 0.1;
  }
  int v75 = *(_DWORD *)(a2 + 24);
  buf[0] = *(void *)a2;
  *(double *)&buf[1] = v73;
  *(double *)&buf[2] = v73 / (v72 * v74);
  *(double *)&double buf[3] = v74;
  *(double *)&__int128 v209 = v72;
  sub_1002D5F00((uint64_t)&v209 + 8, (uint64_t)&v187);
  DWORD2(v213) = v75;
  unint64_t v76 = *(void *)(a1 + 672);
  if (v76 >= *(void *)(a1 + 680))
  {
    uint64_t v79 = sub_1002EDAF4((uint64_t *)(a1 + 664), (__int128 *)buf);
  }

  else
  {
    __int128 v77 = *(_OWORD *)buf;
    __int128 v78 = *(_OWORD *)&buf[2];
    *(void *)(v76 + 32) = v209;
    *(_OWORD *)unint64_t v76 = v77;
    *(_OWORD *)(v76 + 16) = v78;
    sub_1002D5F00(v76 + 40, (uint64_t)&v209 + 8);
    *(_DWORD *)(v76 + 104) = DWORD2(v213);
    uint64_t v79 = v76 + 112;
    *(void *)(a1 + 672) = v76 + 112;
  }

  *(void *)(a1 + 672) = v79;
  if (*(_BYTE *)(a2 + 88))
  {
    if (*(_BYTE *)(a2 + 80))
    {
      double v80 = *(double *)(a2 + 72);
      if (v80 > 1.1)
      {
        uint64_t v81 = qword_1008000A0;
        if (!os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_129;
        }
        LODWORD(buf[0]) = 134217984;
        *(double *)((char *)buf + 4) = v80;
        uint64_t v82 = "#sa_algo_batchfilter,AoA measurement rejected due to high multipath probability (%4.2f)";
        int v83 = (os_log_s *)v81;
        uint32_t v84 = 12;
        goto LABEL_104;
      }
    }

    double v85 = *(double *)(a2 + 56);
    double v86 = *(double *)(a2 + 64);
    if ((v86 < 450.0 || v85 < 0.0) && (v86 < 200.0 || v85 < 40.0))
    {
      uint64_t v148 = qword_1008000A0;
      if (!os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_129;
      }
      LODWORD(buf[0]) = 134218240;
      *(double *)((char *)buf + 4) = v86;
      WORD2(buf[1]) = 2048;
      *(double *)((char *)&buf[1] + 6) = v85;
      uint64_t v82 = "#sa_algo_batchfilter,AoA measurement rejected due to low track score (%4.1f) or low sweep angle (%4.1f deg)";
      int v83 = (os_log_s *)v148;
      uint32_t v84 = 22;
LABEL_104:
      _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_DEFAULT, v82, (uint8_t *)buf, v84);
      goto LABEL_129;
    }

    uint64_t v87 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf[0]) = 134218240;
      *(double *)((char *)buf + 4) = v86;
      WORD2(buf[1]) = 2048;
      *(double *)((char *)&buf[1] + 6) = v85;
      _os_log_impl( (void *)&_mh_execute_header,  v87,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_batchfilter,AoA measurement accepted: track score (%4.1f) and sweep angle (%4.1f deg)",  (uint8_t *)buf,  0x16u);
    }

    *(_WORD *)(a1 + 920) = 1;
    *(void *)(a1 + 624) = *(void *)a2;
    double buf[3] = 0x100000003LL;
    buf[0] = &off_1007BC4C0;
    *(_OWORD *)&buf[1] = xmmword_10042DB70;
    *(void *)&__int128 v209 = (char *)&v209 + 8;
    sub_1002CB548((uint64_t)v192, a1 + 536, (uint64_t)buf);
    *((void *)&v174[1] + 1) = 0x100000003LL;
    *(void *)&v174[0] = &off_1007BC4C0;
    *(_OWORD *)((char *)v174 + _Block_object_dispose((const void *)(v1 - 112), 8) = xmmword_10042DB70;
    *(void *)&__int128 v175 = (char *)&v175 + 8;
    sub_1002CC25C((uint64_t)&v198, (uint64_t)buf, (uint64_t)v174);
    if (!*(_BYTE *)(a2 + 88)) {
      sub_100006080();
    }
    sub_10031981C( (uint64_t)&v163,  *(double *)(a2 + 8),  *(double *)(a2 + 40) / 180.0 * 3.14159265,  *(double *)(a2 + 32) / 180.0 * 3.14159265);
    double buf[3] = 0x100000003LL;
    buf[0] = &off_1007BC4C0;
    *(_OWORD *)&buf[1] = xmmword_10042DB70;
    *(void *)&__int128 v209 = (char *)&v209 + 8;
    sub_1002CB548((uint64_t)v192, (uint64_t)&v163, (uint64_t)buf);
    uint64_t v160 = 0x100000003LL;
    v158 = &off_1007BC4C0;
    __int128 v159 = xmmword_10042DB70;
    v161 = v162;
    sub_1002CC25C((uint64_t)buf, (uint64_t)v174, (uint64_t)&v158);
    uint64_t v88 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v89 = *(void *)(a1 + 624);
      double v90 = sub_1002405E4((uint64_t)&v158, 0);
      double v91 = sub_1002405E4((uint64_t)&v158, 1u);
      double v92 = sub_1002405E4((uint64_t)&v158, 2u);
      LODWORD(buf[0]) = 134218752;
      *(void *)((char *)buf + 4) = v89;
      WORD2(buf[1]) = 2048;
      *(double *)((char *)&buf[1] + 6) = v90;
      HIWORD(buf[2]) = 2048;
      *(double *)&double buf[3] = v91;
      LOWORD(v209) = 2048;
      *(double *)((char *)&v209 + 2) = v92;
      _os_log_impl( (void *)&_mh_execute_header,  v88,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_batchfilter,Solution from AoA is generated at %f s - device pos is [%f, %f, %f] m",  (uint8_t *)buf,  0x2Au);
    }

    uint64_t v93 = 0LL;
    *(_DWORD *)(a1 + 72) = 5;
    *(_BYTE *)(a1 + 76) = 1;
    *(_DWORD *)(a1 + 80) = 2;
    *(_BYTE *)(a1 + 84) = 0;
    *(void *)(a1 + 112) = 0LL;
    __int128 v215 = 0u;
    __int128 v216 = 0u;
    __int128 v213 = 0u;
    __int128 v214 = 0u;
    __int128 v211 = 0u;
    __int128 v212 = 0u;
    __int128 v209 = 0u;
    __int128 v210 = 0u;
    memset(buf, 0, sizeof(buf));
    do
    {
      *(double *)&buf[v93] = sub_1002405E4((uint64_t)&v158, v93);
      ++v93;
    }

    while (v93 != 3);
    double buf[3] = 0x3F847AE147AE147CLL;
    __int128 v209 = 0uLL;
    __int128 v210 = xmmword_10042E830;
    __int128 v211 = xmmword_10042E840;
    *(void *)&__int128 v212 = 0x3FF0000000000000LL;
    LODWORD(v217) = 0;
    unint64_t v94 = *(void *)(a1 + 104);
    unint64_t v95 = *(void *)(a1 + 88);
    *(void *)(a1 + 96) = v95;
    if (v95 >= v94)
    {
      unint64_t v97 = 0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(v94 - v95) >> 3);
      uint64_t v98 = 2 * v97;
      if (2 * v97 <= 1) {
        uint64_t v98 = 1LL;
      }
      if (v97 >= 0xC30C30C30C30C3LL) {
        unint64_t v99 = 0x186186186186186LL;
      }
      else {
        unint64_t v99 = v98;
      }
      __int16 v100 = (char *)sub_10001F014(a1 + 104, v99);
      __int16 v102 = &v100[168 * v101];
      *((_OWORD *)v100 + 6) = v213;
      *((_OWORD *)v100 + 5) = v212;
      *((_OWORD *)v100 + 4) = v211;
      *((_OWORD *)v100 + 3) = v210;
      *((void *)v100 + 20) = v217;
      *((_OWORD *)v100 + 9) = v216;
      *((_OWORD *)v100 + _Block_object_dispose((const void *)(v1 - 112), 8) = v215;
      *((_OWORD *)v100 + 7) = v214;
      *(_OWORD *)__int16 v100 = *(_OWORD *)buf;
      *((_OWORD *)v100 + 1) = *(_OWORD *)&buf[2];
      *((_OWORD *)v100 + 2) = v209;
      unint64_t v96 = v100 + 168;
      unint64_t v104 = *(char **)(a1 + 88);
      float64_t v103 = *(char **)(a1 + 96);
      if (v103 != v104)
      {
        do
        {
          __int128 v105 = *(_OWORD *)(v103 - 168);
          __int128 v106 = *(_OWORD *)(v103 - 152);
          *(_OWORD *)(v100 - 136) = *(_OWORD *)(v103 - 136);
          *(_OWORD *)(v100 - 152) = v106;
          *(_OWORD *)(v100 - 16_Block_object_dispose((const void *)(v1 - 112), 8) = v105;
          __int128 v107 = *(_OWORD *)(v103 - 120);
          __int128 v108 = *(_OWORD *)(v103 - 104);
          __int128 v109 = *(_OWORD *)(v103 - 88);
          *(_OWORD *)(v100 - 72) = *(_OWORD *)(v103 - 72);
          *(_OWORD *)(v100 - 8_Block_object_dispose((const void *)(v1 - 112), 8) = v109;
          *(_OWORD *)(v100 - 104) = v108;
          *(_OWORD *)(v100 - 120) = v107;
          __int128 v110 = *(_OWORD *)(v103 - 56);
          __int128 v111 = *(_OWORD *)(v103 - 40);
          __int128 v112 = *(_OWORD *)(v103 - 24);
          *((_DWORD *)v100 - 2) = *((_DWORD *)v103 - 2);
          *(_OWORD *)(v100 - 24) = v112;
          *(_OWORD *)(v100 - 40) = v111;
          *(_OWORD *)(v100 - 56) = v110;
          v100 -= 168;
          v103 -= 168;
        }

        while (v103 != v104);
        float64_t v103 = *(char **)(a1 + 88);
      }

      *(void *)(a1 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = v100;
      *(void *)(a1 + 96) = v96;
      *(void *)(a1 + 104) = v102;
      if (v103) {
        operator delete(v103);
      }
    }

    else
    {
      *(_OWORD *)(v95 + 112) = v214;
      *(_OWORD *)(v95 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = v215;
      *(_OWORD *)(v95 + 144) = v216;
      *(void *)(v95 + 160) = v217;
      *(_OWORD *)(v95 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v210;
      *(_OWORD *)(v95 + 64) = v211;
      *(_OWORD *)(v95 + 80) = v212;
      *(_OWORD *)(v95 + 96) = v213;
      *(_OWORD *)unint64_t v95 = *(_OWORD *)buf;
      *(_OWORD *)(v95 + 16) = *(_OWORD *)&buf[2];
      *(_OWORD *)(v95 + 32) = v209;
      unint64_t v96 = (char *)(v95 + 168);
    }

    *(void *)(a1 + 96) = v96;
  }

void sub_1002E8FE4(_Unwind_Exception *a1)
{
}

void sub_1002E9100(uint64_t a1)
{
  *(void *)(a1 + 616) = *(void *)(a1 + 600);
  *(void *)(a1 + 640) = 0LL;
  *(_DWORD *)(a1 + 923) = 65792;
  *(_BYTE *)(a1 + 932) = 0;
  *(_DWORD *)(a1 + 92_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  uint64_t v1 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v1,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_batchfilter,Batch filter is reset",  v2,  2u);
  }

void sub_1002E9188(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 664);
  uint64_t v2 = *(void *)(a1 + 672);
  if (v1 != v2)
  {
    if (v1 + 112 != v2)
    {
      uint64_t v4 = v1 + 152;
      do
      {
        __int128 v5 = *(_OWORD *)v1;
        __int128 v6 = *(_OWORD *)(v1 + 16);
        uint64_t v24 = *(void *)(v1 + 32);
        v23[1] = v6;
        v23[0] = v5;
        sub_1002D5F00((uint64_t)&v25, v1 + 40);
        int v26 = *(_DWORD *)(v1 + 104);
        __int128 v7 = *(_OWORD *)(v4 - 40);
        __int128 v8 = *(_OWORD *)(v4 - 24);
        uint64_t v20 = *(void *)(v4 - 8);
        v19[0] = v7;
        v19[1] = v8;
        sub_1002D5F00((uint64_t)&v21, v4);
        int v22 = *(_DWORD *)(v4 + 64);
        uint64_t v21 = off_1007AED90;
        double v25 = off_1007AED90;
        uint64_t v9 = v4 + 72;
        v4 += 112LL;
      }

      while (v9 != v2);
    }

    uint64_t v10 = *(double **)a1;
    double v11 = *(double **)(a1 + 8);
    if (*(double **)a1 != v11)
    {
      BOOL v12 = 0;
      double v13 = *(double *)(v1 + 8);
      do
      {
        if (v12)
        {
          BOOL v12 = 1;
        }

        else
        {
          LOBYTE(v19[0]) = 1;
          char v18 = 0;
          *(void *)&v23[0] = 0LL;
          sub_1002EC55C(*v10, v10[1], a1, (uint64_t *)(a1 + 664), (BOOL *)v19, &v18, (double *)v23);
          int v14 = LOBYTE(v19[0]);
          if (*(_BYTE *)(a1 + 924)) {
            BOOL v15 = LOBYTE(v19[0]) == 0;
          }
          else {
            BOOL v15 = 1;
          }
          char v16 = !v15;
          *(_BYTE *)(a1 + 924) = v16;
          if (!v14)
          {
            if (!v18)
            {
              *(_BYTE *)(a1 + 925) = 0;
              return;
            }

            double v17 = *(double *)(a1 + 640);
            *(double *)(a1 + 640) = v17;
          }

          BOOL v12 = v13 <= v10[1];
        }

        v10 += 2;
      }

      while (v10 != v11);
    }
  }

BOOL sub_1002E9330(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 672);
  uint64_t v2 = *(void *)(a1 + 664);
  if ((unint64_t)(0x6DB6DB6DB6DB6DB7LL * ((v1 - v2) >> 4)) >= 4)
  {
    uint64_t v129 = 0LL;
    uint64_t v128 = 0LL;
    uint64_t v130 = 0LL;
    uint64_t v4 = *(void *)(a1 + 168);
    unint64_t v99 = (uint64_t *)(a1 + 168);
    uint64_t v5 = *(void *)(a1 + 176);
    if (*(_BYTE *)(a1 + 926)) {
      BOOL v6 = 0;
    }
    else {
      BOOL v6 = v4 == v5;
    }
    if (v6)
    {
      if (v2 != v1)
      {
        for (uint64_t i = v2 + 112; i != v1; i += 112LL)
        {
        }
      }

      else {
        double v11 = 0.5;
      }
      sub_1002D5F00((uint64_t)buf, v2 + 40);
      for (unsigned int j = 0; j != 3; ++j)
      {
        sub_1002D5F00((uint64_t)&v109, (uint64_t)buf);
        sub_1002D5F00((uint64_t)&v104, (uint64_t)buf);
        double v13 = *(double *)sub_1002CB32C((uint64_t)&v109, j);
        *(double *)sub_1002CB32C((uint64_t)&v109, j) = v11 + v13;
        double v14 = *(double *)sub_1002CB32C((uint64_t)&v104, j);
        *(double *)sub_1002CB32C((uint64_t)&v104, j) = v14 - v11;
        sub_1002D3DB4(&v128, (uint64_t)&v109);
        sub_1002D3DB4(&v128, (uint64_t)&v104);
      }
    }

    else
    {
      if (v4 != v5)
      {
        do
        {
          sub_1002D3DB4(&v128, v4);
          v4 += 432LL;
        }

        while (v4 != v5);
        uint64_t v5 = *v99;
      }

      sub_1002D5F00((uint64_t)buf, v5);
      sub_1002D5F00((uint64_t)&v109, (uint64_t)buf);
      sub_1002D5F00((uint64_t)&v104, (uint64_t)buf);
      double v7 = *(double *)sub_1002CB32C((uint64_t)&v109, 1u);
      *(double *)sub_1002CB32C((uint64_t)&v109, 1u) = v7 + 3.0;
      double v8 = *(double *)sub_1002CB32C((uint64_t)&v104, 1u);
      *(double *)sub_1002CB32C((uint64_t)&v104, 1u) = v8 + -3.0;
      sub_1002D3DB4(&v128, (uint64_t)&v109);
      sub_1002D3DB4(&v128, (uint64_t)&v104);
    }

    uint64_t v126 = 0LL;
    uint64_t v125 = 0LL;
    unint64_t v127 = 0LL;
    uint64_t v15 = v128;
    uint64_t v16 = v129;
    if (v128 == v129)
    {
      uint64_t v20 = 0LL;
      uint64_t v21 = 0LL;
    }

    else
    {
      do
      {
        __int128 v109 = 0LL;
        __int128 v110 = 0uLL;
        sub_1002EAD74(a1, v15, a1 + 664, (double **)&v109, (uint64_t)buf);
        double v17 = v126;
        if ((unint64_t)v126 >= v127)
        {
          char v18 = (char *)sub_1002EE13C(&v125, (uint64_t)buf);
        }

        else
        {
          sub_1002EE260((uint64_t)&v127, (uint64_t)v126, (uint64_t)buf);
          char v18 = v17 + 376;
        }

        uint64_t v126 = v18;
        v139[26] = off_1007AED90;
        v139[12] = off_1007AED90;
        v139[4] = off_1007AED90;
        *(void *)&uint8_t buf[8] = off_1007AED90;
        unint64_t v104 = (uint64_t (**)())&v109;
        sub_1002AFAC0((void ***)&v104);
        v15 += 64LL;
      }

      while (v15 != v16);
      uint64_t v19 = v125;
      uint64_t v20 = v126;
      while (1)
      {
        if ((char *)v19 == v126)
        {
          uint64_t v21 = v126;
          goto LABEL_41;
        }

        if (!*(_BYTE *)v19) {
          break;
        }
        v19 += 376LL;
      }

      if ((char *)v19 == v126 || (char *)(v19 + 376) == v126)
      {
        uint64_t v21 = (char *)v19;
      }

      else
      {
        uint64_t v21 = (char *)v19;
        do
        {
          if (*(_BYTE *)(v19 + 376))
          {
            *uint64_t v21 = *(_BYTE *)(v19 + 376);
            sub_1002CBDC8((uint64_t)(v21 + 8), v19 + 384);
            sub_1002CBDC8((uint64_t)(v21 + 72), v19 + 448);
            sub_1002CBDC8((uint64_t)(v21 + 136), v19 + 512);
            sub_1002CBDC8((uint64_t)(v21 + 248), v19 + 624);
            uint64_t v22 = *(void *)(v19 + 736);
            *((_DWORD *)v21 + 92) = *(_DWORD *)(v19 + 744);
            *((void *)v21 + 45) = v22;
            v21 += 376;
          }

          double v23 = (char *)(v19 + 752);
          v19 += 376LL;
        }

        while (v23 != v20);
        uint64_t v20 = v126;
      }
    }

void sub_1002EA4D4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  a69 = (void **)&STACK[0x220];
  sub_1002EE0EC(&a69);
  a69 = (void **)&STACK[0x238];
  sub_1002EE0EC(&a69);
  a69 = (void **)&STACK[0x250];
  sub_1002D6F98(&a69);
  _Unwind_Resume(a1);
}

void sub_1002EA658(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (0xF0F0F0F0F0F0F0F1LL * ((v4 - *a1) >> 3) < a2)
  {
    if (a2 >= 0x1E1E1E1E1E1E1E2LL) {
      sub_10001E11C();
    }
    uint64_t v5 = a1[1] - *a1;
    uint64_t v13 = v3;
    stat __p = sub_1002EDD90(v3, a2);
    uint64_t v10 = (char *)__p + v5;
    double v11 = (char *)__p + v5;
    BOOL v12 = (char *)__p + 136 * v6;
    sub_1002EDD1C(a1, &__p);
    double v7 = v10;
    double v8 = v11;
    if (v11 != v10)
    {
      do
      {
        *((void *)v8 - _Block_object_dispose((const void *)(v1 - 112), 8) = off_1007AED90;
        *((void *)v8 - 16) = off_1007AED90;
        v8 -= 136;
      }

      while (v8 != v7);
      double v11 = v7;
    }

    if (__p) {
      operator delete(__p);
    }
  }

uint64_t sub_1002EA770( uint64_t a1, uint64_t a2, uint64_t a3, double **a4, double **a5, uint64_t *a6, uint64_t *a7)
{
  uint64_t v11 = *a6;
  uint64_t v12 = a6[1];
  if (*a6 != v12)
  {
    do
    {
      *(void *)(v12 - 64) = off_1007AED90;
      *(void *)(v12 - 12_Block_object_dispose((const void *)(v1 - 112), 8) = off_1007AED90;
      v12 -= 136LL;
    }

    while (v12 != v11);
    a6[1] = v11;
    sub_1002EA658(a6, 0x6DB6DB6DB6DB6DB7LL * (((char *)a4[1] - (char *)*a4) >> 4));
  }

  uint64_t v13 = *a7;
  uint64_t v14 = a7[1];
  if (*a7 != v14)
  {
    do
    {
      *(void *)(v14 - 8_Block_object_dispose((const void *)(v1 - 112), 8) = off_1007AED90;
      *(void *)(v14 - 176) = off_1007AED90;
      v14 -= 192LL;
    }

    while (v14 != v13);
    a7[1] = v13;
    sub_1002EBEE8(a7, 0x4EC4EC4EC4EC4EC5LL * (((char *)a5[1] - (char *)*a5) >> 4));
  }

  double v39 = a5;
  uint64_t v71 = 0x100000003LL;
  int v69 = &off_1007BC4C0;
  __int128 v70 = xmmword_10042DB70;
  double v72 = &v73;
  uint64_t v66 = 0x300000003LL;
  __int128 v64 = &off_1007BC508;
  __int128 v65 = xmmword_10042DE90;
  double v67 = &v68;
  uint64_t result = (uint64_t)sub_10031953C(a2, (uint64_t)&v69, (uint64_t)&v64);
  uint64_t v16 = *a4;
  double v17 = a4[1];
  if (*a4 != v17)
  {
    do
    {
      uint64_t v60 = 0x100000001LL;
      uint64_t v58 = &off_1007BCA50;
      *(void *)&__int128 v18 = 0x100000001LL;
      *((void *)&v18 + 1) = 0x100000001LL;
      __int128 v59 = v18;
      unint64_t v61 = v62;
      uint64_t v55 = 0x300000001LL;
      uint64_t v53 = &off_1007BD1A0;
      __int128 v54 = xmmword_10042E860;
      unint64_t v56 = v57;
      uint64_t v49 = 0x100000003LL;
      double v47 = &off_1007BC4C0;
      __int128 v48 = xmmword_10042DB70;
      double v50 = v51;
      sub_1002CB44C((uint64_t)(v16 + 5), a3, (uint64_t)&v47);
      sub_1003193C0(a2, (uint64_t)&v64, (uint64_t)&v69, (uint64_t)&v47, (uint64_t)&v58, (uint64_t)&v53);
      double v20 = v16[3];
      double v19 = v16[4];
      double v21 = v16[2];
      uint64_t v22 = (double *)sub_1002CB32C((uint64_t)&v58, 0);
      double v23 = 1.0 / (v20 * v19);
      double v63 = v21 - v23 * *v22;
      uint64_t v49 = 0x300000001LL;
      double v47 = &off_1007BD1A0;
      __int128 v48 = xmmword_10042E860;
      double v50 = v51;
      sub_1002DA040((uint64_t)&v53, (uint64_t)&v47, v23);
      unsigned int v24 = 0;
      uint64_t v44 = 0x100000003LL;
      double v42 = &off_1007BC4C0;
      __int128 v43 = xmmword_10042DB70;
      double v45 = v46;
      do
      {
        double v25 = sub_1002405E4((uint64_t)&v47, v24);
        *(double *)sub_1002CB32C((uint64_t)&v42, v24++) = v25;
      }

      while (v24 != 3);
      unint64_t v26 = a6[1];
      if (v26 >= a6[2])
      {
        uint64_t result = sub_1002F1EEC(a6, &v63, (uint64_t)&v47, (uint64_t)&v42);
      }

      else
      {
        sub_1002F2070((double *)a6[1], (uint64_t)&v47, (uint64_t)&v42, v63);
        uint64_t result = v26 + 136;
        a6[1] = v26 + 136;
      }

      a6[1] = result;
      v16 += 14;
    }

    while (v16 != v17);
  }

  double v28 = *a5;
  double v27 = a5[1];
  if (*v39 != v27)
  {
    do
    {
      uint64_t v60 = 0x100000002LL;
      uint64_t v58 = &off_1007BCA98;
      __int128 v59 = xmmword_10042DEE0;
      unint64_t v61 = v62;
      uint64_t v55 = 0x300000002LL;
      uint64_t v53 = &off_1007BD1E8;
      __int128 v54 = xmmword_10042E870;
      unint64_t v56 = v57;
      uint64_t v49 = 0x100000003LL;
      double v47 = &off_1007BC4C0;
      __int128 v48 = xmmword_10042DB70;
      double v50 = v51;
      sub_1002CB44C((uint64_t)(v28 + 4), a3, (uint64_t)&v47);
      sub_10031947C(a2, (uint64_t)&v64, (uint64_t)&v69, (uint64_t)&v47, (uint64_t)(v28 + 12), (uint64_t)&v58, (uint64_t)&v53);
      double v29 = v28[3];
      double v30 = v28[1];
      uint64_t v31 = (double *)sub_1002CB32C((uint64_t)&v58, 0);
      double v32 = 1.0 / v29;
      double v33 = fmod(v29 * v30 - *v31 + 3.14159265, 6.28318531);
      if (v33 < 0.0) {
        double v33 = v33 + 6.28318531;
      }
      double v63 = v32 * (v33 + -3.14159265);
      double v34 = v28[2];
      double v52 = v34 - v32 * *(double *)sub_1002CB32C((uint64_t)&v58, 1u);
      uint64_t v49 = 0x300000002LL;
      double v47 = &off_1007BD1E8;
      __int128 v48 = xmmword_10042E870;
      double v50 = v51;
      sub_1002DA040((uint64_t)&v53, (uint64_t)&v47, v32);
      int v35 = 0;
      uint64_t v44 = 0x200000003LL;
      double v42 = &off_1007BD230;
      __int128 v43 = xmmword_10042E880;
      double v45 = v46;
      do
      {
        double v36 = sub_10024061C((uint64_t)&v47, 0, v35);
        *(double *)sub_1002CB40C((uint64_t)&v42, v35, 0) = v36;
        double v37 = sub_10024061C((uint64_t)&v47, 1, v35);
        *(double *)sub_1002CB40C((uint64_t)&v42, v35++, 1) = v37;
      }

      while (v35 != 3);
      unint64_t v38 = a7[1];
      if (v38 >= a7[2])
      {
        uint64_t result = sub_1002F20CC(a7, &v63, &v52, (uint64_t)&v47, (uint64_t)&v42);
      }

      else
      {
        sub_1002F2258((double *)a7[1], (uint64_t)&v47, (uint64_t)&v42, v63, v52);
        uint64_t result = v38 + 192;
        a7[1] = v38 + 192;
      }

      a7[1] = result;
      v28 += 26;
    }

    while (v28 != v27);
  }

  return result;
}

void sub_1002EAD34(_Unwind_Exception *a1)
{
  *(void *)(v1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1002EAD40(_Unwind_Exception *a1)
{
  *(void *)(v1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1002EAD74(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, double **a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v79 = 0x100000003LL;
  unint64_t v77 = &off_1007BC4C0;
  __int128 v78 = xmmword_10042DB70;
  BOOL v80 = &v81;
  double v8 = sub_1002EBA10(a1, (uint64_t)v82, a3, a4, (uint64_t)&v77);
  uint64_t v74 = 0x100000003LL;
  double v72 = &off_1007BC4C0;
  __int128 v73 = xmmword_10042DB70;
  uint64_t v75 = &v76;
  if (*(int *)(a1 + 936) < 1)
  {
    char v17 = 0;
    int v9 = 1;
  }

  else
  {
    int v9 = 1;
LABEL_3:
    sub_1002CBDC8((uint64_t)&v72, (uint64_t)&v77);
    int v10 = 0;
    while (v10 < *(_DWORD *)(a1 + 940))
    {
      uint64_t v85 = 0x100000003LL;
      uint64_t v83 = &off_1007BC4C0;
      __int128 v84 = xmmword_10042DB70;
      double v86 = v87;
      sub_1002CC25C((uint64_t)v82, (uint64_t)&v72, (uint64_t)&v83);
      double v11 = sub_1002EBA10(a1, (uint64_t)&v83, a3, a4, (uint64_t)&v77);
      if (v11 < v8)
      {
        uint64_t v85 = 0x100000003LL;
        uint64_t v83 = &off_1007BC4C0;
        __int128 v84 = xmmword_10042DB70;
        double v86 = v87;
        sub_1002CC25C((uint64_t)v82, (uint64_t)&v72, (uint64_t)&v83);
        sub_1002CBDC8((uint64_t)v82, (uint64_t)&v83);
        uint64_t v63 = 0x100000003LL;
        unint64_t v61 = &off_1007BC4C0;
        __int128 v62 = xmmword_10042DB70;
        __int128 v64 = v65;
        uint64_t v85 = 0x100000134LL;
        uint64_t v83 = &off_1007BC598;
        __int128 v84 = xmmword_10042DB90;
        double v86 = v87;
        uint64_t v58 = 0x100000003LL;
        unint64_t v56 = (void **)&off_1007BC4C0;
        __int128 v57 = xmmword_10042DB70;
        __int128 v59 = v60;
        sub_1002CB6A8((uint64_t)&v72, (uint64_t)&v61, (uint64_t)&v83, (uint64_t)&v56, "2");
        BOOL v14 = v15 < *(double *)(a1 + 944) || (v8 - v11) / v8 < *(double *)(a1 + 952);
        ++v9;
        double v8 = v11;
LABEL_15:
        if (v9 > *(_DWORD *)(a1 + 936) || v14)
        {
          char v17 = 0;
          goto LABEL_22;
        }

        goto LABEL_3;
      }

      unsigned int v12 = 0;
      ++v10;
      do
      {
        double v13 = *(double *)sub_1002CB32C((uint64_t)&v72, v12);
        *(double *)sub_1002CB32C((uint64_t)&v72, v12++) = v13 * 0.5;
      }

      while (v12 != 3);
      if (v11 < v8)
      {
        BOOL v14 = 0;
        goto LABEL_15;
      }
    }

    char v17 = 1;
  }

void sub_1002EB4F4(_Unwind_Exception *a1)
{
}

uint64_t sub_1002EB5E8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 != a3)
  {
    sub_1002EE5A0((uint64_t)&v10, a3, *(void *)(a1 + 8), a2);
    uint64_t v6 = *(void **)(a1 + 8);
    if (v6 != v5)
    {
      double v7 = v6 - 46;
      do
      {
        v7[30] = off_1007AED90;
        uint8_t v7[16] = off_1007AED90;
        _BYTE v7[8] = off_1007AED90;
        *double v7 = off_1007AED90;
        double v8 = v7 - 1;
        v7 -= 47;
      }

      while (v8 != v5);
    }

    *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v5;
  }

  return a2;
}

double sub_1002EB670(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  uint64_t v4 = a3[1];
  if (*a3 == v4)
  {
    double v8 = 0.0;
    uint64_t v14 = *a3;
  }

  else
  {
    uint64_t v6 = a2 + 8;
    uint64_t v7 = v3 + 40;
    double v8 = 0.0;
    do
    {
      uint64_t v23 = 0x100000001LL;
      double v21 = &off_1007BCA50;
      *(void *)&__int128 v9 = 0x100000001LL;
      *((void *)&v9 + 1) = 0x100000001LL;
      __int128 v22 = v9;
      double v24 = &v25;
      uint64_t v18 = 0x300000001LL;
      uint64_t v16 = &off_1007BD1A0;
      __int128 v17 = xmmword_10042E860;
      double v19 = &v20;
      sub_100318EE4(v6, v7, (uint64_t)&v21, (uint64_t)&v16);
      double v10 = *(double *)(v7 - 8);
      double v11 = *(double *)(v7 - 32);
      unsigned int v12 = (double *)sub_1002CB32C((uint64_t)&v21, 0);
      double v8 = v8 + 1.0 / (v10 * 0.1) * (v11 - *v12) * (1.0 / (v10 * 0.1) * (v11 - *v12));
      uint64_t v13 = v7 + 72;
      v7 += 112LL;
    }

    while (v13 != v4);
    uint64_t v3 = *a3;
    uint64_t v14 = a3[1];
  }

  return sqrt(v8 / (double)(unint64_t)(0x6DB6DB6DB6DB6DB7LL * ((v14 - v3) >> 4) - 3));
}

void sub_1002EB7E4(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t *a3@<X8>)
{
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  uint64_t v3 = *(_OWORD **)a2;
  uint64_t v4 = *(_OWORD **)(a2 + 8);
  if (*(_OWORD **)a2 != v4)
  {
    uint64_t v7 = (uint64_t)(a3 + 2);
    do
    {
      if (sub_1002EB8AC(a1, (uint64_t)v3))
      {
        unint64_t v8 = a3[1];
        if (v8 >= a3[2])
        {
          uint64_t v9 = sub_1002F22B0(a3, v3);
        }

        else
        {
          sub_1002F243C(v7, (_OWORD *)a3[1], v3);
          uint64_t v9 = v8 + 208;
          a3[1] = v8 + 208;
        }

        a3[1] = v9;
      }

      v3 += 13;
    }

    while (v3 != v4);
  }

void sub_1002EB888( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  *(void *)(v10 + _Block_object_dispose((const void *)(v1 - 112), 8) = v11;
  a10 = (void **)v10;
  sub_1002AFAC0(&a10);
  _Unwind_Resume(a1);
}

BOOL sub_1002EB8AC(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = 0x100000003LL;
  uint64_t v11 = &off_1007BC4C0;
  __int128 v12 = xmmword_10042DB70;
  uint64_t v14 = &v15;
  sub_1002CB44C(a1, a2 + 32, (uint64_t)&v11);
  uint64_t v8 = 0x100000003LL;
  uint64_t v6 = &off_1007BC4C0;
  __int128 v7 = xmmword_10042DB70;
  uint64_t v9 = &v10;
  sub_1002CB548(a2 + 96, (uint64_t)&v11, (uint64_t)&v6);
  double v3 = sub_1002405E4((uint64_t)&v6, 2u);
  uint64_t v28 = 0x100000003LL;
  unint64_t v26 = &off_1007BC4C0;
  __int128 v27 = xmmword_10042DB70;
  double v29 = &v30;
  uint64_t v23 = 0x100000134LL;
  double v21 = &off_1007BC598;
  __int128 v22 = xmmword_10042DB90;
  double v24 = &v25;
  uint64_t v18 = 0x100000003LL;
  uint64_t v16 = &off_1007BC4C0;
  __int128 v17 = xmmword_10042DB70;
  double v19 = &v20;
  sub_1002CB6A8((uint64_t)&v6, (uint64_t)&v26, (uint64_t)&v21, (uint64_t)&v16, "2");
  return acos(-v3 / v4) * 180.0 / 3.14159265 <= 60.0;
}

double sub_1002EBA10(uint64_t a1, uint64_t a2, uint64_t a3, double **a4, uint64_t a5)
{
  uint64_t v9 = (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 4;
  uint64_t v46 = 0LL;
  double v47 = 0LL;
  uint64_t v48 = 0LL;
  __int128 v43 = 0LL;
  uint64_t v44 = 0LL;
  uint64_t v45 = 0LL;
  sub_1002EA658((uint64_t *)&v46, 0x6DB6DB6DB6DB6DB7LL * v9);
  sub_1002EC000(v10, a2, (double **)a3, a4, (uint64_t *)&v46, (uint64_t *)&v43);
  uint64_t v40 = 0x300000003LL;
  unint64_t v38 = &off_1007BC508;
  __int128 v39 = xmmword_10042DE90;
  uint64_t v41 = &v42;
  sub_1002CAEDC(&v38, 3, 3);
  sub_1002CAF28((uint64_t)&v38, 0.0);
  uint64_t v35 = 0x100000003LL;
  uint64_t v33 = &off_1007BC4C0;
  __int128 v34 = xmmword_10042DB70;
  double v36 = &v37;
  sub_1002CAEDC(&v33, 3, 1);
  double v11 = 0.0;
  sub_1002CAF28((uint64_t)&v33, 0.0);
  __int128 v12 = v46;
  for (i = v47; v12 != i; __int128 v12 = (double *)(v15 + 64))
  {
    uint64_t v14 = (uint64_t)(v12 + 9);
    double v16 = *v12;
    uint64_t v15 = (uint64_t)(v12 + 1);
    uint64_t v30 = 0x300000003LL;
    uint64_t v28 = &off_1007BC508;
    __int128 v29 = xmmword_10042DE90;
    uint64_t v31 = v32;
    sub_1002CB548(v14, v15, (uint64_t)&v28);
    uint64_t v51 = 0x300000003LL;
    uint64_t v49 = &off_1007BC508;
    __int128 v50 = xmmword_10042DE90;
    uint64_t v52 = v53;
    sub_1002CC25C((uint64_t)&v38, (uint64_t)&v28, (uint64_t)&v49);
    sub_1002CBDC8((uint64_t)&v38, (uint64_t)&v49);
    uint64_t v30 = 0x100000003LL;
    uint64_t v28 = &off_1007BC4C0;
    __int128 v29 = xmmword_10042DB70;
    v15 += 64LL;
    uint64_t v31 = v32;
    sub_1002DA040(v15, (uint64_t)&v28, v16);
    uint64_t v51 = 0x100000003LL;
    uint64_t v49 = &off_1007BC4C0;
    __int128 v50 = xmmword_10042DB70;
    uint64_t v52 = v53;
    sub_1002CC25C((uint64_t)&v33, (uint64_t)&v28, (uint64_t)&v49);
    sub_1002CBDC8((uint64_t)&v33, (uint64_t)&v49);
    double v11 = v11 + v16 * v16;
  }

  __int128 v17 = v43;
  uint64_t v18 = v44;
  if (v43 != v44)
  {
    do
    {
      double v19 = *v17;
      double v20 = v17[1];
      uint64_t v30 = 0x300000003LL;
      uint64_t v28 = &off_1007BC508;
      __int128 v29 = xmmword_10042DE90;
      uint64_t v21 = (uint64_t)(v17 + 2);
      uint64_t v31 = v32;
      sub_1002CB548((uint64_t)(v17 + 13), (uint64_t)(v17 + 2), (uint64_t)&v28);
      uint64_t v51 = 0x300000003LL;
      uint64_t v49 = &off_1007BC508;
      __int128 v50 = xmmword_10042DE90;
      uint64_t v52 = v53;
      sub_1002CC25C((uint64_t)&v38, (uint64_t)&v28, (uint64_t)&v49);
      sub_1002CBDC8((uint64_t)&v38, (uint64_t)&v49);
      uint64_t v25 = 0x100000002LL;
      uint64_t v23 = &off_1007BCA98;
      __int128 v24 = xmmword_10042DEE0;
      unint64_t v26 = v27;
      *(double *)sub_1002CB32C((uint64_t)&v23, 0) = v19;
      *(double *)sub_1002CB32C((uint64_t)&v23, 1u) = v20;
      uint64_t v30 = 0x100000003LL;
      uint64_t v28 = &off_1007BC4C0;
      __int128 v29 = xmmword_10042DB70;
      v21 += 88LL;
      uint64_t v31 = v32;
      sub_1002CB548(v21, (uint64_t)&v23, (uint64_t)&v28);
      uint64_t v51 = 0x100000003LL;
      uint64_t v49 = &off_1007BC4C0;
      __int128 v50 = xmmword_10042DB70;
      uint64_t v52 = v53;
      sub_1002CC25C((uint64_t)&v33, (uint64_t)&v28, (uint64_t)&v49);
      sub_1002CBDC8((uint64_t)&v33, (uint64_t)&v49);
      double v11 = v11 + v20 * v20 + v19 * v19;
      __int128 v17 = (double *)(v21 + 88);
    }

    while ((double *)(v21 + 88) != v18);
  }

  uint64_t v30 = 0x300000003LL;
  uint64_t v28 = &off_1007BC508;
  __int128 v29 = xmmword_10042DE90;
  uint64_t v31 = v32;
  uint64_t v56 = 0x100000003LL;
  uint64_t v54 = &off_1007BD278;
  __int128 v55 = xmmword_10042DB70;
  __int128 v57 = &v58;
  uint64_t v51 = 0x10000000CLL;
  uint64_t v49 = &off_1007BD2C0;
  __int128 v50 = xmmword_10042E850;
  uint64_t v52 = v53;
  sub_1002D9BF0((uint64_t)&v38, (uint64_t)&v54, (uint64_t)&v49, (uint64_t)&v28);
  uint64_t v25 = 0x100000003LL;
  uint64_t v23 = &off_1007BC4C0;
  __int128 v24 = xmmword_10042DB70;
  unint64_t v26 = v27;
  sub_1002CB548((uint64_t)&v28, (uint64_t)&v33, (uint64_t)&v23);
  sub_1002CBDC8(a5, (uint64_t)&v23);
  uint64_t v49 = (uint64_t (**)())&v43;
  sub_1002EDCD8((void ***)&v49);
  uint64_t v49 = (uint64_t (**)())&v46;
  sub_1002EDC94((void ***)&v49);
  return v11;
}

void sub_1002EBE74( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,char a60,uint64_t a61,uint64_t a62,char a63)
{
  a66 = (void **)&a60;
  sub_1002EDCD8(&a66);
  a66 = (void **)&a63;
  sub_1002EDC94(&a66);
  _Unwind_Resume(a1);
}

void sub_1002EBEE8(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 6) < a2)
  {
    if (a2 >= 0x155555555555556LL) {
      sub_10001E11C();
    }
    uint64_t v5 = a1[1] - *a1;
    uint64_t v13 = v3;
    stat __p = sub_1002D5D84(v3, a2);
    uint64_t v10 = (char *)__p + v5;
    double v11 = (char *)__p + v5;
    __int128 v12 = (char *)__p + 192 * v6;
    sub_1002F1AA0(a1, &__p);
    __int128 v7 = v10;
    uint64_t v8 = v11;
    if (v11 != v10)
    {
      do
      {
        *((void *)v8 - 11) = off_1007AED90;
        *((void *)v8 - 22) = off_1007AED90;
        v8 -= 192;
      }

      while (v8 != v7);
      double v11 = v7;
    }

    if (__p) {
      operator delete(__p);
    }
  }

void sub_1002EC000(uint64_t a1, uint64_t a2, double **a3, double **a4, uint64_t *a5, uint64_t *a6)
{
  uint64_t v10 = *a5;
  uint64_t v11 = a5[1];
  if (*a5 != v11)
  {
    do
    {
      *(void *)(v11 - 64) = off_1007AED90;
      *(void *)(v11 - 12_Block_object_dispose((const void *)(v1 - 112), 8) = off_1007AED90;
      v11 -= 136LL;
    }

    while (v11 != v10);
    a5[1] = v10;
    sub_1002EA658(a5, 0x6DB6DB6DB6DB6DB7LL * (((char *)a3[1] - (char *)*a3) >> 4));
  }

  uint64_t v12 = *a6;
  uint64_t v13 = a6[1];
  if (*a6 != v13)
  {
    do
    {
      *(void *)(v13 - 8_Block_object_dispose((const void *)(v1 - 112), 8) = off_1007AED90;
      *(void *)(v13 - 176) = off_1007AED90;
      v13 -= 192LL;
    }

    while (v13 != v12);
    a6[1] = v12;
    sub_1002EBEE8(a6, 0x4EC4EC4EC4EC4EC5LL * (((char *)a4[1] - (char *)*a4) >> 4));
  }

  __int128 v39 = a4;
  uint64_t v14 = *a3;
  uint64_t v15 = a3[1];
  if (*a3 != v15)
  {
    do
    {
      uint64_t v59 = 0x100000001LL;
      __int128 v57 = &off_1007BCA50;
      *(void *)&__int128 v16 = 0x100000001LL;
      *((void *)&v16 + 1) = 0x100000001LL;
      __int128 v58 = v16;
      uint64_t v60 = v61;
      uint64_t v54 = 0x300000001LL;
      uint64_t v52 = &off_1007BD1A0;
      __int128 v53 = xmmword_10042E860;
      __int128 v55 = v56;
      sub_100318EE4(a2, (uint64_t)(v14 + 5), (uint64_t)&v57, (uint64_t)&v52);
      double v18 = v14[3];
      double v17 = v14[4];
      double v19 = v14[2];
      double v20 = (double *)sub_1002CB32C((uint64_t)&v57, 0);
      double v21 = 1.0 / (v18 * v17);
      v62[0] = v19 - v21 * *v20;
      uint64_t v48 = 0x300000001LL;
      uint64_t v46 = &off_1007BD1A0;
      __int128 v47 = xmmword_10042E860;
      uint64_t v49 = v50;
      sub_1002DA040((uint64_t)&v52, (uint64_t)&v46, v21);
      unsigned int v22 = 0;
      uint64_t v43 = 0x100000003LL;
      uint64_t v41 = &off_1007BC4C0;
      __int128 v42 = xmmword_10042DB70;
      uint64_t v44 = v45;
      do
      {
        double v23 = sub_1002405E4((uint64_t)&v46, v22);
        *(double *)sub_1002CB32C((uint64_t)&v41, v22++) = v23;
      }

      while (v22 != 3);
      unint64_t v24 = a5[1];
      if (v24 >= a5[2])
      {
        uint64_t v25 = sub_1002F1EEC(a5, v62, (uint64_t)&v46, (uint64_t)&v41);
      }

      else
      {
        sub_1002F2070((double *)a5[1], (uint64_t)&v46, (uint64_t)&v41, v62[0]);
        uint64_t v25 = v24 + 136;
        a5[1] = v24 + 136;
      }

      a5[1] = v25;
      v14 += 14;
    }

    while (v14 != v15);
  }

  __int128 v27 = *a4;
  unint64_t v26 = a4[1];
  if (*v39 != v26)
  {
    do
    {
      uint64_t v59 = 0x100000002LL;
      __int128 v57 = &off_1007BCA98;
      __int128 v58 = xmmword_10042DEE0;
      uint64_t v60 = v61;
      uint64_t v54 = 0x300000002LL;
      uint64_t v52 = &off_1007BD1E8;
      __int128 v53 = xmmword_10042E870;
      __int128 v55 = v56;
      sub_1003190BC(a2, (uint64_t)(v27 + 4), (uint64_t)(v27 + 12), (uint64_t)&v57, (uint64_t)&v52);
      double v28 = v27[3];
      double v29 = v27[1];
      uint64_t v30 = (double *)sub_1002CB32C((uint64_t)&v57, 0);
      double v31 = 1.0 / v28;
      double v32 = fmod(v28 * v29 - *v30 + 3.14159265, 6.28318531);
      if (v32 < 0.0) {
        double v32 = v32 + 6.28318531;
      }
      v62[0] = v31 * (v32 + -3.14159265);
      double v33 = v27[2];
      double v51 = v33 - v31 * *(double *)sub_1002CB32C((uint64_t)&v57, 1u);
      uint64_t v48 = 0x300000002LL;
      uint64_t v46 = &off_1007BD1E8;
      __int128 v47 = xmmword_10042E870;
      uint64_t v49 = v50;
      sub_1002DA040((uint64_t)&v52, (uint64_t)&v46, 1.0 / v28);
      int v34 = 0;
      uint64_t v43 = 0x200000003LL;
      uint64_t v41 = &off_1007BD230;
      __int128 v42 = xmmword_10042E880;
      uint64_t v44 = v45;
      do
      {
        double v35 = sub_10024061C((uint64_t)&v46, 0, v34);
        *(double *)sub_1002CB40C((uint64_t)&v41, v34, 0) = v35;
        double v36 = sub_10024061C((uint64_t)&v46, 1, v34);
        *(double *)sub_1002CB40C((uint64_t)&v41, v34++, 1) = v36;
      }

      while (v34 != 3);
      unint64_t v37 = a6[1];
      if (v37 >= a6[2])
      {
        uint64_t v38 = sub_1002F20CC(a6, v62, &v51, (uint64_t)&v46, (uint64_t)&v41);
      }

      else
      {
        sub_1002F2258((double *)a6[1], (uint64_t)&v46, (uint64_t)&v41, v62[0], v51);
        uint64_t v38 = v37 + 192;
        a6[1] = v37 + 192;
      }

      a6[1] = v38;
      v27 += 26;
    }

    while (v27 != v26);
  }

void sub_1002EC4F4(_Unwind_Exception *a1)
{
  *(void *)(v1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1002EC500(_Unwind_Exception *a1)
{
  *(void *)(v1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v2;
  _Unwind_Resume(a1);
}

void *sub_1002EC52C(void *result)
{
  *uint64_t result = off_1007AED90;
  return result;
}

void *sub_1002EC53C(void *result)
{
  *uint64_t result = off_1007AED90;
  return result;
}

void *sub_1002EC54C(void *result)
{
  *uint64_t result = off_1007AED90;
  return result;
}

void sub_1002EC55C(double a1, double a2, uint64_t a3, uint64_t *a4, BOOL *a5, char *a6, double *a7)
{
  *a5 = 1;
  *a6 = 0;
  *a7 = 0.0;
  uint64_t v7 = a4[1];
  if (*a4 != v7)
  {
    unint64_t v14 = 0x6DB6DB6DB6DB6DB7LL * ((v7 - *a4) >> 4);
    uint64_t v81 = 0LL;
    unint64_t v82 = 0LL;
    unint64_t v83 = 0LL;
    sub_1002D58F0(&v81, v14);
    uint64_t v78 = 0x100000002LL;
    uint64_t v76 = &off_1007BCA98;
    __int128 v77 = xmmword_10042DEE0;
    uint64_t v79 = &v80;
    uint64_t v15 = *a4;
    uint64_t v16 = a4[1];
    while (v15 != v16)
    {
      if (*(double *)(v15 + 8) <= a2)
      {
        double v17 = sub_1002405E4(v15 + 40, 2u);
        *(double *)sub_1002CB32C((uint64_t)&v76, 0) = v17;
        double v18 = sub_1002405E4(v15 + 40, 0);
        *(double *)sub_1002CB32C((uint64_t)&v76, 1u) = v18;
        unint64_t v19 = v82;
        if (v82 >= v83)
        {
          uint64_t v20 = sub_1002DA678(&v81, (uint64_t)&v76);
        }

        else
        {
          sub_1002DA48C(v82, (uint64_t)&v76);
          uint64_t v20 = v19 + 56;
        }

        unint64_t v82 = v20;
      }

      v15 += 112LL;
    }

    if (v81 != v82)
    {
      __int128 v53 = a7;
      uint64_t v73 = 0x100000002LL;
      uint64_t v71 = &off_1007BCA98;
      __int128 v72 = xmmword_10042DEE0;
      uint64_t v74 = &v75;
      sub_1002CAEDC(&v71, 2, 1);
      sub_1002CAF28((uint64_t)&v71, 0.0);
      uint64_t v22 = v81;
      for (unint64_t i = v82; v22 != i; v22 += 56LL)
      {
        uint64_t v86 = 0x100000002LL;
        __int128 v84 = &off_1007BCA98;
        __int128 v85 = xmmword_10042DEE0;
        double v87 = v88;
        sub_1002CC25C((uint64_t)&v71, v22, (uint64_t)&v84);
        sub_1002CBDC8((uint64_t)&v71, (uint64_t)&v84);
      }

      uint64_t v86 = 0x100000002LL;
      __int128 v84 = &off_1007BCA98;
      __int128 v85 = xmmword_10042DEE0;
      double v87 = v88;
      sub_1002DA040((uint64_t)&v71, (uint64_t)&v84, 1.0 / (double)v14);
      sub_1002CBDC8((uint64_t)&v71, (uint64_t)&v84);
      uint64_t v24 = v81;
      unint64_t v23 = v82;
      if (v81 != v82)
      {
        double v25 = 0.0;
        do
        {
          uint64_t v86 = 0x100000002LL;
          __int128 v84 = &off_1007BCA98;
          __int128 v85 = xmmword_10042DEE0;
          double v87 = v88;
          sub_1002CB44C(v24, (uint64_t)&v71, (uint64_t)&v84);
          sub_1002CBDC8(v24, (uint64_t)&v84);
          uint64_t v68 = 0x100000002LL;
          uint64_t v66 = &off_1007BCA98;
          __int128 v67 = xmmword_10042DEE0;
          int v69 = v70;
          uint64_t v86 = 0x1000000E1LL;
          __int128 v84 = &off_1007BCAE0;
          __int128 v85 = xmmword_10042DEF0;
          double v87 = v88;
          uint64_t v63 = 0x100000002LL;
          unint64_t v61 = &off_1007BCA98;
          __int128 v62 = xmmword_10042DEE0;
          __int128 v64 = v65;
          sub_1002CB6A8(v24, (uint64_t)&v66, (uint64_t)&v84, (uint64_t)&v61, "2");
          if (v26 > v25) {
            double v25 = v26;
          }
          v24 += 56LL;
        }

        while (v24 != v23);
        *a5 = v25 < 0.3;
        if (v25 < 0.3) {
          goto LABEL_54;
        }
        uint64_t v86 = 0x200000002LL;
        __int128 v84 = &off_1007BCB28;
        __int128 v85 = xmmword_10042DF00;
        double v87 = v88;
        sub_1002CAEDC(&v84, 2, 2);
        sub_1002CAF28((uint64_t)&v84, 0.0);
        uint64_t v27 = v81;
        unint64_t v28 = v82;
        if (v81 != v82)
        {
          while (1)
          {
            unsigned int v30 = *(_DWORD *)(v27 + 8);
            unsigned int v29 = *(_DWORD *)(v27 + 12);
            uint64_t v58 = 0x200000001LL;
            uint64_t v59 = 0LL;
            unint64_t v56 = 0LL;
            uint64_t v57 = 0LL;
            __int128 v55 = &off_1007BCB70;
            if (v29 > 1) {
              break;
            }
            if (v30 >= 3)
            {
              int v49 = 423;
              __int128 v50 = "this->max_num_cols_ >= num_cols";
LABEL_58:
              __assert_rtn("SetMatrixSize", "cnmatrixbase.h", v49, v50);
            }

            unint64_t v56 = __PAIR64__(v30, v29);
            LODWORD(v57) = v30 * v29;
            HIDWORD(v57) = v29;
            uint64_t v59 = v60;
            sub_1002CB364(v27, &v55);
            uint64_t v63 = 0x200000002LL;
            unint64_t v61 = &off_1007BCB28;
            __int128 v62 = xmmword_10042DF00;
            __int128 v64 = v65;
            sub_1002CB548(v27, (uint64_t)&v55, (uint64_t)&v61);
            uint64_t v68 = 0x200000002LL;
            uint64_t v66 = &off_1007BCB28;
            __int128 v67 = xmmword_10042DF00;
            int v69 = v70;
            sub_1002CC25C((uint64_t)&v84, (uint64_t)&v61, (uint64_t)&v66);
            sub_1002CBDC8((uint64_t)&v84, (uint64_t)&v66);
            v27 += 56LL;
            if (v27 == v28) {
              goto LABEL_23;
            }
          }

          int v49 = 422;
          __int128 v50 = "this->max_num_rows_ >= num_rows";
          goto LABEL_58;
        }

void sub_1002ECCA8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void **a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,char a56)
{
  a15 = (void **)&a56;
  sub_1002DA2F4(&a15);
  _Unwind_Resume(a1);
}

char *sub_1002ECD2C(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  uint64_t v9 = *(char **)result;
  if (0xCF3CF3CF3CF3CF3DLL * ((v8 - *(void *)result) >> 3) < a4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0LL;
      *uint64_t v7 = 0LL;
      v7[1] = 0LL;
      _DWORD v7[2] = 0LL;
    }

    if (a4 > 0x186186186186186LL) {
      sub_10001E11C();
    }
    unint64_t v10 = 0xCF3CF3CF3CF3CF3DLL * (v8 >> 3);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= a4) {
      uint64_t v11 = a4;
    }
    if (v10 >= 0xC30C30C30C30C3LL) {
      unint64_t v12 = 0x186186186186186LL;
    }
    else {
      unint64_t v12 = v11;
    }
    uint64_t result = sub_10001EFC0(v7, v12);
    unint64_t v14 = (char *)v7[1];
    uint64_t v13 = (void **)(v7 + 1);
    uint64_t v9 = v14;
LABEL_16:
    uint64_t v17 = a3 - (void)__src;
    if (v17)
    {
      size_t v18 = v17 - 4;
      unint64_t v19 = v9;
      uint64_t v20 = __src;
      goto LABEL_18;
    }

    goto LABEL_19;
  }

  uint64_t v13 = (void **)(result + 8);
  uint64_t v15 = (_BYTE *)*((void *)result + 1);
  if (0xCF3CF3CF3CF3CF3DLL * ((v15 - v9) >> 3) >= a4) {
    goto LABEL_16;
  }
  uint64_t v16 = &__src[8 * ((v15 - v9) >> 3)];
  if (v15 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, v15 - v9 - 4);
    uint64_t v9 = (char *)*v13;
  }

  uint64_t v17 = a3 - (void)v16;
  if (v17)
  {
    size_t v18 = v17 - 4;
    unint64_t v19 = v9;
    uint64_t v20 = v16;
LABEL_18:
    uint64_t result = (char *)memmove(v19, v20, v18);
  }

BOOL sub_1002ECE8C(__int128 **a1, uint64_t *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *a2;
  __int128 v4 = **a1;
  __int128 v5 = (*a1)[1];
  uint64_t v11 = *((void *)*a1 + 4);
  __int128 v9 = v4;
  __int128 v10 = v5;
  sub_1002D5F00((uint64_t)v12, (uint64_t)v2 + 40);
  v12[16] = *((_DWORD *)v2 + 26);
  sub_1002D5F00((uint64_t)v8, v3 + 40);
  uint8_t v8[16] = *(_DWORD *)(v3 + 104);
  double v6 = sub_1002405E4((uint64_t)v12, 0);
  return v6 < sub_1002405E4((uint64_t)v8, 0);
}

BOOL sub_1002ECF40(__int128 **a1, uint64_t *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *a2;
  __int128 v4 = **a1;
  __int128 v5 = (*a1)[1];
  uint64_t v11 = *((void *)*a1 + 4);
  __int128 v9 = v4;
  __int128 v10 = v5;
  sub_1002D5F00((uint64_t)v12, (uint64_t)v2 + 40);
  v12[16] = *((_DWORD *)v2 + 26);
  sub_1002D5F00((uint64_t)v8, v3 + 40);
  uint8_t v8[16] = *(_DWORD *)(v3 + 104);
  double v6 = sub_1002405E4((uint64_t)v12, 1u);
  return v6 < sub_1002405E4((uint64_t)v8, 1u);
}

BOOL sub_1002ECFF4(__int128 **a1, uint64_t *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *a2;
  __int128 v4 = **a1;
  __int128 v5 = (*a1)[1];
  uint64_t v11 = *((void *)*a1 + 4);
  __int128 v9 = v4;
  __int128 v10 = v5;
  sub_1002D5F00((uint64_t)v12, (uint64_t)v2 + 40);
  v12[16] = *((_DWORD *)v2 + 26);
  sub_1002D5F00((uint64_t)v8, v3 + 40);
  uint8_t v8[16] = *(_DWORD *)(v3 + 104);
  double v6 = sub_1002405E4((uint64_t)v12, 2u);
  return v6 < sub_1002405E4((uint64_t)v8, 2u);
}

uint64_t sub_1002ED0AC(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_1002ED0B8(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t sub_1002ED0DC(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_1002ED0E8(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t sub_1002ED10C(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_1002ED118(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t sub_1002ED138(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1002ED1F4((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_1002ED1AC(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x24924924924924ALL) {
    sub_10001D350();
  }
  return operator new(112 * a2);
}

uint64_t sub_1002ED1F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a3 != a5)
  {
    uint64_t v11 = 0LL;
    do
    {
      uint64_t v12 = a7 + v11;
      __int128 v13 = *(_OWORD *)(a3 + v11 - 112);
      __int128 v14 = *(_OWORD *)(a3 + v11 - 96);
      *(void *)(v12 - 80) = *(void *)(a3 + v11 - 80);
      *(_OWORD *)(v12 - 112) = v13;
      *(_OWORD *)(v12 - 96) = v14;
      sub_1002D5F00(a7 + v11 - 72, a3 + v11 - 72);
      *(_DWORD *)(v12 - _Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)(a3 + v11 - 8);
      v11 -= 112LL;
    }

    while (a3 + v11 != a5);
  }

  return a6;
}

void sub_1002ED288(_Unwind_Exception *a1)
{
  for (; v2; v2 += 112LL)
    *(void *)(v1 + 40 + v2) = off_1007AED90;
  _Unwind_Resume(a1);
}

uint64_t *sub_1002ED2A8(uint64_t **a1, unsigned int *a2, uint64_t *a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    unsigned int v7 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v5;
        unsigned int v9 = *((_DWORD *)v5 + 7);
        if (v7 >= v9) {
          break;
        }
        uint64_t v5 = *v8;
        uint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }

      if (v9 >= v7) {
        break;
      }
      uint64_t v5 = v8[1];
      if (!v5)
      {
        uint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    uint64_t v8 = a1 + 1;
LABEL_10:
    __int128 v10 = (uint64_t *)operator new(0x28uLL);
    *(uint64_t *)((char *)v10 + 2_Block_object_dispose((const void *)(v1 - 112), 8) = *a3;
    sub_10001E548(a1, (uint64_t)v8, v6, v10);
    return v10;
  }

  return (uint64_t *)v8;
}

uint64_t sub_1002ED360(uint64_t *a1, __int128 *a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = 0x6DB6DB6DB6DB6DB7LL * ((a1[1] - *a1) >> 4);
  unint64_t v5 = v4 + 1;
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x6DB6DB6DB6DB6DB7LL * ((a1[2] - v3) >> 4);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x124924924924924LL) {
    unint64_t v9 = 0x249249249249249LL;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v22 = a1 + 2;
  if (v9) {
    __int128 v10 = (char *)sub_1002ED1AC(v7, v9);
  }
  else {
    __int128 v10 = 0LL;
  }
  uint64_t v11 = &v10[112 * v4];
  stat __p = v10;
  unint64_t v19 = v11;
  uint64_t v20 = v11;
  double v21 = &v10[112 * v9];
  __int128 v12 = *a2;
  __int128 v13 = a2[1];
  *((void *)v11 + 4) = *((void *)a2 + 4);
  *(_OWORD *)uint64_t v11 = v12;
  *((_OWORD *)v11 + 1) = v13;
  sub_1002D5F00((uint64_t)(v11 + 40), (uint64_t)a2 + 40);
  *(_DWORD *)&v10[112 * v4 + 104] = *((_DWORD *)a2 + 26);
  v20 += 112;
  sub_1002ED138(a1, &__p);
  uint64_t v14 = a1[1];
  uint64_t v15 = v19;
  uint64_t v16 = v20;
  if (v20 != v19)
  {
    do
    {
      *((void *)v16 - 9) = off_1007AED90;
      v16 -= 112;
    }

    while (v16 != v15);
    uint64_t v20 = v15;
  }

  if (__p) {
    operator delete(__p);
  }
  return v14;
}

void *sub_1002ED500(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    sub_1002ED584(result, a4);
    uint64_t result = (void *)sub_1002ED5D8((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }

  return result;
}

void sub_1002ED564( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + _Block_object_dispose((const void *)(v1 - 112), 8) = v10;
  sub_1002AFA80(&a9);
  _Unwind_Resume(a1);
}

char *sub_1002ED584(void *a1, unint64_t a2)
{
  if (a2 >= 0x24924924924924ALL) {
    sub_10001E11C();
  }
  uint64_t result = (char *)sub_1002ED1AC((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[112 * v4];
  return result;
}

uint64_t sub_1002ED5D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0LL;
    do
    {
      uint64_t v8 = a4 + v7;
      uint64_t v9 = a2 + v7;
      __int128 v10 = *(_OWORD *)(a2 + v7);
      __int128 v11 = *(_OWORD *)(a2 + v7 + 16);
      *(void *)(v8 + 32) = *(void *)(a2 + v7 + 32);
      *(_OWORD *)uint64_t v8 = v10;
      *(_OWORD *)(v8 + 16) = v11;
      sub_1002D5F00(a4 + v7 + 40, a2 + v7 + 40);
      *(_DWORD *)(v8 + 104) = *(_DWORD *)(a2 + v7 + 104);
      v7 += 112LL;
    }

    while (v9 + 112 != a3);
    a4 += v7;
  }

  return a4;
}

void sub_1002ED65C(_Unwind_Exception *a1)
{
  for (; v2; v2 -= 112LL)
    *(void *)(v1 - 72 + v2) = off_1007AED90;
  _Unwind_Resume(a1);
}

void sub_1002ED67C(char **a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    for (unint64_t i = a1[1]; i != v2; i -= 112)
      *((void *)i - 9) = off_1007AED90;
    a1[1] = v2;
    operator delete(v2);
    *a1 = 0LL;
    a1[1] = 0LL;
    a1[2] = 0LL;
  }

uint64_t sub_1002ED6D8(uint64_t *a1, __int128 *a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = 0x6DB6DB6DB6DB6DB7LL * ((a1[1] - *a1) >> 4);
  unint64_t v5 = v4 + 1;
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x6DB6DB6DB6DB6DB7LL * ((a1[2] - v3) >> 4);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x124924924924924LL) {
    unint64_t v9 = 0x249249249249249LL;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v22 = a1 + 2;
  if (v9) {
    __int128 v10 = (char *)sub_1002ED1AC(v7, v9);
  }
  else {
    __int128 v10 = 0LL;
  }
  __int128 v11 = &v10[112 * v4];
  stat __p = v10;
  unint64_t v19 = v11;
  uint64_t v20 = v11;
  double v21 = &v10[112 * v9];
  __int128 v12 = *a2;
  __int128 v13 = a2[1];
  *((void *)v11 + 4) = *((void *)a2 + 4);
  *(_OWORD *)__int128 v11 = v12;
  *((_OWORD *)v11 + 1) = v13;
  sub_1002D5F00((uint64_t)(v11 + 40), (uint64_t)a2 + 40);
  *(_DWORD *)&v10[112 * v4 + 104] = *((_DWORD *)a2 + 26);
  v20 += 112;
  sub_1002ED138(a1, &__p);
  uint64_t v14 = a1[1];
  uint64_t v15 = v19;
  uint64_t v16 = v20;
  if (v20 != v19)
  {
    do
    {
      *((void *)v16 - 9) = off_1007AED90;
      v16 -= 112;
    }

    while (v16 != v15);
    uint64_t v20 = v15;
  }

  if (__p) {
    operator delete(__p);
  }
  return v14;
}

uint64_t sub_1002ED878(uint64_t a1, __int128 *a2, __int128 *a3, unint64_t a4)
{
  uint64_t v8 = a1 + 16;
  unint64_t v9 = *(char **)a1;
  if (0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 4) < a4)
  {
    sub_1002ED67C((char **)a1);
    if (a4 > 0x249249249249249LL) {
      sub_10001E11C();
    }
    unint64_t v10 = 0xDB6DB6DB6DB6DB6ELL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 4);
    if (v10 <= a4) {
      unint64_t v10 = a4;
    }
    else {
      unint64_t v11 = v10;
    }
    sub_1002ED584((void *)a1, v11);
    uint64_t result = sub_1002ED5D8(v8, (uint64_t)a2, (uint64_t)a3, *(void *)(a1 + 8));
    goto LABEL_11;
  }

  if (0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 4) < a4)
  {
    __int128 v13 = &a2[(uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 4];
    sub_1002EDA08(a2, v13, (uint64_t)v9);
    uint64_t result = sub_1002ED5D8(v8, (uint64_t)v13, (uint64_t)a3, *(void *)(a1 + 8));
LABEL_11:
    *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = result;
    return result;
  }

  uint64_t result = (uint64_t)sub_1002EDA08(a2, a3, (uint64_t)v9);
  for (uint64_t i = *(void *)(a1 + 8); i != v14; i -= 112LL)
    *(void *)(i - 72) = off_1007AED90;
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v14;
  return result;
}

void sub_1002ED9F8(_Unwind_Exception *a1)
{
  *(void *)(v1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1002EDA00(_Unwind_Exception *a1)
{
  *(void *)(v1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v2;
  _Unwind_Resume(a1);
}

__int128 *sub_1002EDA08(__int128 *a1, __int128 *a2, uint64_t a3)
{
  uint64_t v4 = a1;
  if (a1 == a2) {
    return a1;
  }
  unint64_t v5 = a2;
  do
  {
    __int128 v6 = *v4;
    __int128 v7 = v4[1];
    *(void *)(a3 + 32) = *((void *)v4 + 4);
    *(_OWORD *)a3 = v6;
    *(_OWORD *)(a3 + 16) = v7;
    sub_1002CBDC8(a3 + 40, (uint64_t)v4 + 40);
    *(_DWORD *)(a3 + 104) = *((_DWORD *)v4 + 26);
    a3 += 112LL;
    v4 += 7;
  }

  while (v4 != v5);
  return v5;
}

_OWORD *sub_1002EDA80(uint64_t a1, _OWORD *a2, _OWORD *a3, _OWORD *a4)
{
  unint64_t v5 = a2;
  if (a2 == a3) {
    return a2;
  }
  __int128 v6 = a3;
  do
  {
    __int128 v7 = v5[1];
    *a4 = *v5;
    a4[1] = v7;
    sub_1002CBDC8((uint64_t)(a4 + 2), (uint64_t)(v5 + 2));
    sub_1002CBDC8((uint64_t)(a4 + 6), (uint64_t)(v5 + 6));
    a4 += 13;
    v5 += 13;
  }

  while (v5 != v6);
  return v6;
}

uint64_t sub_1002EDAF4(uint64_t *a1, __int128 *a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = 0x6DB6DB6DB6DB6DB7LL * ((a1[1] - *a1) >> 4);
  unint64_t v5 = v4 + 1;
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x6DB6DB6DB6DB6DB7LL * ((a1[2] - v3) >> 4);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x124924924924924LL) {
    unint64_t v9 = 0x249249249249249LL;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v22 = a1 + 2;
  if (v9) {
    unint64_t v10 = (char *)sub_1002ED1AC(v7, v9);
  }
  else {
    unint64_t v10 = 0LL;
  }
  unint64_t v11 = &v10[112 * v4];
  stat __p = v10;
  unint64_t v19 = v11;
  uint64_t v20 = v11;
  double v21 = &v10[112 * v9];
  __int128 v12 = *a2;
  __int128 v13 = a2[1];
  *((void *)v11 + 4) = *((void *)a2 + 4);
  *(_OWORD *)unint64_t v11 = v12;
  *((_OWORD *)v11 + 1) = v13;
  sub_1002D5F00((uint64_t)(v11 + 40), (uint64_t)a2 + 40);
  *(_DWORD *)&v10[112 * v4 + 104] = *((_DWORD *)a2 + 26);
  v20 += 112;
  sub_1002ED138(a1, &__p);
  uint64_t v14 = a1[1];
  uint64_t v15 = v19;
  uint64_t v16 = v20;
  if (v20 != v19)
  {
    do
    {
      *((void *)v16 - 9) = off_1007AED90;
      v16 -= 112;
    }

    while (v16 != v15);
    uint64_t v20 = v15;
  }

  if (__p) {
    operator delete(__p);
  }
  return v14;
}

void sub_1002EDC94(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    for (uint64_t i = (char *)v1[1]; i != v2; i -= 136)
    {
      *((void *)i - _Block_object_dispose((const void *)(v1 - 112), 8) = off_1007AED90;
      *((void *)i - 16) = off_1007AED90;
    }

    v1[1] = v2;
    operator delete(v2);
  }

void sub_1002EDCD8(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    for (uint64_t i = (char *)v1[1]; i != v2; i -= 192)
    {
      *((void *)i - 11) = off_1007AED90;
      *((void *)i - 22) = off_1007AED90;
    }

    v1[1] = v2;
    operator delete(v2);
  }

uint64_t sub_1002EDD1C(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1002EDDD4((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_1002EDD90(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x1E1E1E1E1E1E1E2LL) {
    sub_10001D350();
  }
  return operator new(136 * a2);
}

uint64_t sub_1002EDDD4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = 0LL;
  uint64_t v12 = a7 - 136;
  while (a3 + v11 != a5)
  {
    __int128 v13 = (void *)(v12 + v11);
    v11 -= 136LL;
    sub_1002EDE78(a1, v13, (void *)(v11 + a3));
  }

  return a6;
}

double sub_1002EDE78(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4 = (uint64_t)(a3 + 9);
  *a2 = *a3;
  sub_1002EDED4((uint64_t)(a2 + 1), (uint64_t)(a3 + 1));
  *(void *)&double result = sub_1002D5F00((uint64_t)(a2 + 9), v4).n128_u64[0];
  return result;
}

void sub_1002EDEC4(_Unwind_Exception *a1)
{
  void *v1 = off_1007AED90;
  _Unwind_Resume(a1);
}

__n128 sub_1002EDED4(uint64_t a1, uint64_t a2)
{
  result.n128_u64[0] = 0x300000001LL;
  *(void *)(a1 + 24) = 0x300000001LL;
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = &off_1007BD1A0;
  if (a1 == a2)
  {
    uint64_t v16 = "this != &(A)";
    int v17 = 603;
LABEL_21:
    size_t v18 = "cnmatrix.h";
    unint64_t v19 = "CNMatrix";
LABEL_22:
    __assert_rtn(v19, v18, v17, v16);
  }

  unsigned int v3 = *(_DWORD *)(a2 + 8);
  if (v3 > 1)
  {
    uint64_t v16 = "this->max_num_rows_ >= num_rows";
    int v17 = 422;
LABEL_18:
    size_t v18 = "cnmatrixbase.h";
    unint64_t v19 = "SetMatrixSize";
    goto LABEL_22;
  }

  unsigned int v4 = *(_DWORD *)(a2 + 12);
  if (v4 >= 4)
  {
    uint64_t v16 = "this->max_num_cols_ >= num_cols";
    int v17 = 423;
    goto LABEL_18;
  }

  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v3;
  *(_DWORD *)(a1 + 12) = v4;
  uint64_t v5 = v4 * v3;
  *(_DWORD *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 20) = v3;
  uint64_t v6 = (_OWORD *)(a1 + 40);
  *(void *)(a1 + 32) = a1 + 40;
  if (*(_DWORD *)(a2 + 8) > 1u)
  {
    uint64_t v16 = "this->max_num_rows_ >= A.num_rows_";
    int v17 = 616;
    goto LABEL_21;
  }

  if (*(_DWORD *)(a2 + 12) > 3u)
  {
    uint64_t v16 = "this->max_num_cols_ >= A.num_cols_";
    int v17 = 617;
    goto LABEL_21;
  }

  int v7 = *(_DWORD *)(a2 + 16);
  if (v7 > 3)
  {
    uint64_t v10 = (v7 - 2);
    uint64_t v11 = *(__int128 **)(a2 + 32);
    uint64_t v12 = (__n128 *)((char *)v6 + 8 * v10);
    uint64_t v13 = (v7 - 1) >> 1;
    uint64_t v14 = v11;
    do
    {
      __int128 v15 = *v14++;
      *v6++ = v15;
      --v13;
    }

    while (v13);
    __n128 result = *(__n128 *)((char *)v11 + 8 * v10);
    __n128 *v12 = result;
  }

  else if ((_DWORD)v5)
  {
    uint64_t v8 = *(unint64_t **)(a2 + 32);
    do
    {
      unint64_t v9 = *v8++;
      result.n128_u64[0] = v9;
      *(void *)uint64_t v6 = v9;
      uint64_t v6 = (_OWORD *)((char *)v6 + 8);
      --v5;
    }

    while (v5);
  }

  return result;
}

void sub_1002EE030(_Unwind_Exception *a1)
{
  void *v1 = off_1007AED90;
  _Unwind_Resume(a1);
}

void *sub_1002EE040(void *result)
{
  *__n128 result = off_1007AED90;
  return result;
}

void *sub_1002EE050(void *result)
{
  *__n128 result = off_1007BC9D8;
  return result;
}

uint64_t sub_1002EE064(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_1002EE070(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t sub_1002EE094(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_1002EE0A0(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_1002EE0EC(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    unsigned int v3 = (char *)v1[1];
    if (v3 != v2)
    {
      unsigned int v4 = v3 - 368;
      do
      {
        *((void *)v4 + 30) = off_1007AED90;
        *((void *)v4 + 16) = off_1007AED90;
        *((void *)v4 + _Block_object_dispose((const void *)(v1 - 112), 8) = off_1007AED90;
        *(void *)unsigned int v4 = off_1007AED90;
        uint64_t v5 = v4 - 8;
        v4 -= 376;
      }

      while (v5 != v2);
    }

    v1[1] = v2;
    operator delete(v2);
  }

uint64_t sub_1002EE13C(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = 0x51B3BEA3677D46CFLL * ((a1[1] - *a1) >> 3);
  unint64_t v4 = v3 + 1;
  if (0xA3677D46CEFA8D9ELL * ((a1[2] - *a1) >> 3) > v4) {
    unint64_t v4 = 0xA3677D46CEFA8D9ELL * ((a1[2] - *a1) >> 3);
  }
  else {
    unint64_t v6 = v4;
  }
  uint64_t v14 = a1 + 2;
  if (v6) {
    int v7 = (char *)sub_1002EE38C((uint64_t)(a1 + 2), v6);
  }
  else {
    int v7 = 0LL;
  }
  uint64_t v10 = v7;
  uint64_t v11 = &v7[376 * v3];
  uint64_t v13 = &v7[376 * v6];
  sub_1002EE260((uint64_t)(a1 + 2), (uint64_t)v11, a2);
  uint64_t v12 = v11 + 376;
  sub_1002EE318(a1, &v10);
  uint64_t v8 = a1[1];
  sub_1002EE538((uint64_t)&v10);
  return v8;
}

void sub_1002EE24C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_1002EE260(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a3 + 72;
  *(_BYTE *)a2 = *(_BYTE *)a3;
  uint64_t v6 = a2 + 72;
  sub_1002D5F00(a2 + 8, a3 + 8);
  sub_1002D5F00(v6, v5);
  sub_1002D606C(a2 + 136, a3 + 136);
  sub_1002D606C(a2 + 248, a3 + 248);
  uint64_t v7 = *(void *)(a3 + 360);
  *(_DWORD *)(a2 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)(a3 + 368);
  *(void *)(a2 + 360) = v7;
}

void sub_1002EE2E8(_Unwind_Exception *a1)
{
  *uint64_t v3 = off_1007AED90;
  void *v2 = off_1007AED90;
  void *v1 = off_1007AED90;
  _Unwind_Resume(a1);
}

uint64_t sub_1002EE318(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1002EE3D4((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_1002EE38C(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAE4C415C9882BALL) {
    sub_10001D350();
  }
  return operator new(376 * a2);
}

uint64_t sub_1002EE3D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = 0LL;
  uint64_t v12 = a7 - 376;
  while (a3 + v11 != a5)
  {
    uint64_t v13 = v12 + v11;
    v11 -= 376LL;
    sub_1002EE480(a1, v13, v11 + a3);
  }

  return a6;
}

void sub_1002EE480(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a3 + 72;
  *(_BYTE *)a2 = *(_BYTE *)a3;
  uint64_t v6 = a2 + 72;
  sub_1002D5F00(a2 + 8, a3 + 8);
  sub_1002D5F00(v6, v5);
  sub_1002D606C(a2 + 136, a3 + 136);
  sub_1002D606C(a2 + 248, a3 + 248);
  uint64_t v7 = *(void *)(a3 + 360);
  *(_DWORD *)(a2 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)(a3 + 368);
  *(void *)(a2 + 360) = v7;
}

void sub_1002EE508(_Unwind_Exception *a1)
{
  *uint64_t v3 = off_1007AED90;
  void *v2 = off_1007AED90;
  void *v1 = off_1007AED90;
  _Unwind_Resume(a1);
}

uint64_t sub_1002EE538(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
  uint64_t v3 = *(void **)(a1 + 16);
  if (v3 != v2)
  {
    unint64_t v4 = v3 - 46;
    do
    {
      v4[30] = off_1007AED90;
      uint8_t v4[16] = off_1007AED90;
      _BYTE v4[8] = off_1007AED90;
      *unint64_t v4 = off_1007AED90;
      uint64_t v5 = v4 - 1;
      v4 -= 47;
    }

    while (v5 != v2);
    *(void *)(a1 + 16) = v2;
  }

  uint64_t v6 = *(void **)a1;
  if (*(void *)a1) {
    operator delete(v6);
  }
  return a1;
}

uint64_t sub_1002EE5A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a2;
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  do
  {
    *(_BYTE *)a4 = *(_BYTE *)v5;
    sub_1002CBDC8(a4 + 8, v5 + 8);
    sub_1002CBDC8(a4 + 72, v5 + 72);
    sub_1002CBDC8(a4 + 136, v5 + 136);
    sub_1002CBDC8(a4 + 248, v5 + 248);
    int v7 = *(_DWORD *)(v5 + 368);
    *(void *)(a4 + 360) = *(void *)(v5 + 360);
    *(_DWORD *)(a4 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = v7;
    a4 += 376LL;
    v5 += 376LL;
  }

  while (v5 != v6);
  return v6;
}

void sub_1002EE63C(uint64_t a1, char *a2, uint64_t a3, char a4)
{
LABEL_1:
  __int128 v112 = a2 - 376;
  uint64_t v110 = (uint64_t)(a2 - 1128);
  uint64_t v111 = (uint64_t)(a2 - 752);
  unint64_t v6 = a1;
  uint64_t v119 = (uint64_t)a2;
  while (2)
  {
    uint64_t v7 = v6;
    uint64_t v8 = (uint64_t)&a2[-v6];
    unint64_t v9 = 0x51B3BEA3677D46CFLL * ((uint64_t)&a2[-v6] >> 3);
    a1 = v7;
    switch(v9)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        if (*((double *)a2 - 2) < *(double *)(v7 + 360))
        {
          BOOL v48 = (char *)v7;
          int v49 = v112;
          goto LABEL_55;
        }

        return;
      case 3uLL:
        sub_1002EF5F0(v7, v7 + 376, (uint64_t)v112);
        return;
      case 4uLL:
        sub_1002EFB30(v7, v7 + 376, v7 + 752, (uint64_t)v112);
        return;
      case 5uLL:
        __int128 v50 = (char *)(v7 + 752);
        double v51 = (char *)(v7 + 1128);
        sub_1002EFB30(v7, v7 + 376, v7 + 752, v7 + 1128);
        if (*((double *)a2 - 2) < *(double *)(v7 + 1488))
        {
          sub_1002EF9DC(v51, v112);
          if (*(double *)(v7 + 1488) < *(double *)(v7 + 1112))
          {
            sub_1002EF9DC(v50, v51);
            if (*(double *)(v7 + 1112) < *(double *)(v7 + 736))
            {
              sub_1002EF9DC((char *)(v7 + 376), v50);
              if (*(double *)(v7 + 736) < *(double *)(v7 + 360))
              {
                BOOL v48 = (char *)v7;
                int v49 = (char *)(v7 + 376);
LABEL_55:
                sub_1002EF9DC(v48, v49);
              }
            }
          }
        }

        return;
      default:
        if (v8 <= 9023)
        {
          if ((a4 & 1) != 0)
          {
            if ((char *)v7 != a2)
            {
              int v52 = (char *)(v7 + 376);
              if ((char *)(v7 + 376) != a2)
              {
                uint64_t v53 = 0LL;
                uint64_t v54 = v7;
                do
                {
                  __int128 v55 = v52;
                  if (*(double *)(v54 + 736) < *(double *)(v54 + 360))
                  {
                    char v128 = *v52;
                    sub_1002D5F00((uint64_t)v129, v54 + 384);
                    sub_1002D5F00((uint64_t)v130, v54 + 448);
                    sub_1002D606C((uint64_t)v131, v54 + 512);
                    sub_1002D606C((uint64_t)v132, v54 + 624);
                    double v133 = *(double *)(v54 + 736);
                    int v134 = *(_DWORD *)(v54 + 744);
                    uint64_t v56 = v53;
                    while (1)
                    {
                      uint64_t v57 = v7 + v56;
                      *(_BYTE *)(v7 + v56 + 376) = *(_BYTE *)(v7 + v56);
                      sub_1002CBDC8(v7 + v56 + 384, v7 + v56 + 8);
                      sub_1002CBDC8(v57 + 448, v57 + 72);
                      sub_1002CBDC8(v57 + 512, v57 + 136);
                      sub_1002CBDC8(v57 + 624, v57 + 248);
                      *(void *)(v57 + 736) = *(void *)(v57 + 360);
                      *(_DWORD *)(v57 + 744) = *(_DWORD *)(v57 + 368);
                      if (!v56) {
                        break;
                      }
                      v56 -= 376LL;
                      if (v133 >= *(double *)(v57 - 16))
                      {
                        uint64_t v58 = (_BYTE *)(v7 + v56 + 376);
                        goto LABEL_73;
                      }
                    }

                    uint64_t v58 = (_BYTE *)v7;
LABEL_73:
                    a2 = (char *)v119;
                    _BYTE *v58 = v128;
                    sub_1002CBDC8(v57 + 8, (uint64_t)v129);
                    sub_1002CBDC8(v57 + 72, (uint64_t)v130);
                    sub_1002CBDC8(v57 + 136, (uint64_t)v131);
                    sub_1002CBDC8(v57 + 248, (uint64_t)v132);
                    int v59 = v134;
                    *(double *)(v57 + 360) = v133;
                    *(_DWORD *)(v57 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = v59;
                  }

                  int v52 = v55 + 376;
                  v53 += 376LL;
                  uint64_t v54 = (uint64_t)v55;
                }

                while (v55 + 376 != a2);
              }
            }
          }

          else if ((char *)v7 != a2)
          {
            unint64_t v99 = (char *)(v7 + 376);
            if ((char *)(v7 + 376) != a2)
            {
              uint64_t v100 = v7 - 16;
              do
              {
                uint64_t v101 = v99;
                if (*(double *)(a1 + 736) < *(double *)(a1 + 360))
                {
                  char v128 = *v99;
                  sub_1002D5F00((uint64_t)v129, a1 + 384);
                  sub_1002D5F00((uint64_t)v130, a1 + 448);
                  sub_1002D606C((uint64_t)v131, a1 + 512);
                  sub_1002D606C((uint64_t)v132, a1 + 624);
                  double v133 = *(double *)(a1 + 736);
                  int v134 = *(_DWORD *)(a1 + 744);
                  uint64_t v102 = v100;
                  do
                  {
                    *(_BYTE *)(v102 + 392) = *(_BYTE *)(v102 + 16);
                    sub_1002CBDC8(v102 + 400, v102 + 24);
                    sub_1002CBDC8(v102 + 464, v102 + 88);
                    sub_1002CBDC8(v102 + 528, v102 + 152);
                    sub_1002CBDC8(v102 + 640, v102 + 264);
                    *(_DWORD *)(v102 + 760) = *(_DWORD *)(v102 + 384);
                    *(void *)(v102 + 752) = *(void *)(v102 + 376);
                    double v103 = *(double *)v102;
                    v102 -= 376LL;
                  }

                  while (v133 < v103);
                  *(_BYTE *)(v102 + 392) = v128;
                  sub_1002CBDC8(v102 + 400, (uint64_t)v129);
                  sub_1002CBDC8(v102 + 464, (uint64_t)v130);
                  sub_1002CBDC8(v102 + 528, (uint64_t)v131);
                  sub_1002CBDC8(v102 + 640, (uint64_t)v132);
                  int v104 = v134;
                  *(double *)(v102 + 752) = v133;
                  *(_DWORD *)(v102 + 760) = v104;
                  a2 = (char *)v119;
                }

                unint64_t v99 = v101 + 376;
                v100 += 376LL;
                a1 = (uint64_t)v101;
              }

              while (v101 + 376 != a2);
            }
          }

          return;
        }

        if (!a3)
        {
          if ((char *)v7 != a2)
          {
            unint64_t v113 = v8;
            int64_t v60 = (v9 - 2) >> 1;
            int64_t v61 = v60;
            uint64_t v62 = v7;
            do
            {
              int64_t v63 = v61;
              if (v60 >= v61)
              {
                uint64_t v64 = (2 * v61) | 1;
                uint64_t v65 = v62 + 376 * v64;
                if (2 * v61 + 2 < (uint64_t)v9 && *(double *)(v62 + 376 * v64 + 360) < *(double *)(v65 + 736))
                {
                  v65 += 376LL;
                  uint64_t v64 = 2 * v61 + 2;
                }

                uint64_t v66 = v62 + 376 * v61;
                if (*(double *)(v65 + 360) >= *(double *)(v66 + 360))
                {
                  uint64_t v67 = v62 + 376 * v63;
                  uint64_t v68 = v66 + 360;
                  char v128 = *(_BYTE *)v67;
                  int64_t v117 = v63;
                  sub_1002D5F00((uint64_t)v129, v67 + 8);
                  sub_1002D5F00((uint64_t)v130, v67 + 72);
                  sub_1002D606C((uint64_t)v131, v67 + 136);
                  sub_1002D606C((uint64_t)v132, v67 + 248);
                  double v69 = *(double *)v68;
                  int v134 = *(_DWORD *)(v68 + 8);
                  double v133 = v69;
                  do
                  {
                    uint64_t v70 = v65;
                    *(_BYTE *)uint64_t v67 = *(_BYTE *)v65;
                    uint64_t v71 = v65 + 8;
                    sub_1002CBDC8(v67 + 8, v65 + 8);
                    uint64_t v72 = v65 + 72;
                    sub_1002CBDC8(v67 + 72, v65 + 72);
                    uint64_t v73 = v65 + 136;
                    sub_1002CBDC8(v67 + 136, v65 + 136);
                    uint64_t v74 = v65 + 248;
                    sub_1002CBDC8(v67 + 248, v65 + 248);
                    int v75 = *(_DWORD *)(v65 + 368);
                    *(void *)(v67 + 360) = *(void *)(v65 + 360);
                    *(_DWORD *)(v67 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = v75;
                    if (v60 < v64) {
                      break;
                    }
                    uint64_t v76 = (2 * v64) | 1;
                    uint64_t v65 = a1 + 376 * v76;
                    if (2 * v64 + 2 < (uint64_t)v9 && *(double *)(a1 + 376 * v76 + 360) < *(double *)(v65 + 736))
                    {
                      v65 += 376LL;
                      uint64_t v76 = 2 * v64 + 2;
                    }

                    uint64_t v67 = v70;
                    uint64_t v64 = v76;
                  }

                  while (*(double *)(v65 + 360) >= v133);
                  *(_BYTE *)uint64_t v70 = v128;
                  sub_1002CBDC8(v71, (uint64_t)v129);
                  sub_1002CBDC8(v72, (uint64_t)v130);
                  sub_1002CBDC8(v73, (uint64_t)v131);
                  sub_1002CBDC8(v74, (uint64_t)v132);
                  int64_t v63 = v117;
                  int v77 = v134;
                  *(double *)(v70 + 360) = v133;
                  *(_DWORD *)(v70 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = v77;
                  uint64_t v62 = a1;
                }
              }

              int64_t v61 = v63 - 1;
            }

            while (v63);
            int64_t v78 = v113 / 0x178;
            uint64_t v109 = v62 + 8;
            uint64_t v107 = v62 + 136;
            uint64_t v108 = v62 + 72;
            uint64_t v105 = v62 + 360;
            uint64_t v106 = v62 + 248;
            uint64_t v79 = v119;
            do
            {
              uint64_t v114 = v79;
              uint64_t v80 = a1;
              char v121 = *(_BYTE *)a1;
              sub_1002D5F00((uint64_t)v122, v109);
              sub_1002D5F00((uint64_t)v123, v108);
              sub_1002D606C((uint64_t)v124, v107);
              sub_1002D606C((uint64_t)v125, v106);
              uint64_t v81 = 0LL;
              uint64_t v82 = *(void *)v105;
              int v127 = *(_DWORD *)(v105 + 8);
              uint64_t v126 = v82;
              do
              {
                uint64_t v83 = v80;
                uint64_t v84 = v81 + 1;
                v80 += 376 * (v81 + 1);
                uint64_t v85 = 2 * v81;
                uint64_t v81 = (2 * v81) | 1;
                int64_t v86 = v85 + 2;
                if (v86 < v78 && *(double *)(v83 + 376 * v84 + 360) < *(double *)(v80 + 736))
                {
                  v80 += 376LL;
                  uint64_t v81 = v86;
                }

                *(_BYTE *)uint64_t v83 = *(_BYTE *)v80;
                sub_1002CBDC8(v83 + 8, v80 + 8);
                sub_1002CBDC8(v83 + 72, v80 + 72);
                sub_1002CBDC8(v83 + 136, v80 + 136);
                sub_1002CBDC8(v83 + 248, v80 + 248);
                int v87 = *(_DWORD *)(v80 + 368);
                *(void *)(v83 + 360) = *(void *)(v80 + 360);
                *(_DWORD *)(v83 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = v87;
              }

              while (v81 <= (uint64_t)((unint64_t)(v78 - 2) >> 1));
              uint64_t v88 = (_BYTE *)(v114 - 376);
              __int128 v118 = (double *)(v80 + 360);
              if (v80 == v114 - 376)
              {
                *(_BYTE *)uint64_t v80 = v121;
                sub_1002CBDC8(v80 + 8, (uint64_t)v122);
                sub_1002CBDC8(v80 + 72, (uint64_t)v123);
                sub_1002CBDC8(v80 + 136, (uint64_t)v124);
                sub_1002CBDC8(v80 + 248, (uint64_t)v125);
                int v97 = v127;
                *(void *)__int128 v118 = v126;
                *(_DWORD *)(v80 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = v97;
              }

              else
              {
                *(_BYTE *)uint64_t v80 = *v88;
                sub_1002CBDC8(v80 + 8, v114 - 368);
                sub_1002CBDC8(v80 + 72, v114 - 304);
                sub_1002CBDC8(v80 + 136, v114 - 240);
                sub_1002CBDC8(v80 + 248, v114 - 128);
                uint64_t v89 = *(void *)(v114 - 16);
                *(_DWORD *)(v80 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)(v114 - 8);
                *(void *)__int128 v118 = v89;
                *uint64_t v88 = v121;
                sub_1002CBDC8(v114 - 368, (uint64_t)v122);
                sub_1002CBDC8(v114 - 304, (uint64_t)v123);
                sub_1002CBDC8(v114 - 240, (uint64_t)v124);
                sub_1002CBDC8(v114 - 128, (uint64_t)v125);
                int v90 = v127;
                *(void *)(v114 - 16) = v126;
                *(_DWORD *)(v114 - _Block_object_dispose((const void *)(v1 - 112), 8) = v90;
                uint64_t v91 = v80 - a1 + 376;
                if (v91 >= 377)
                {
                  unint64_t v92 = (v91 / 0x178uLL - 2) >> 1;
                  if (*(double *)(a1 + 376 * v92 + 360) < *v118)
                  {
                    char v128 = *(_BYTE *)v80;
                    sub_1002D5F00((uint64_t)v129, v80 + 8);
                    sub_1002D5F00((uint64_t)v130, v80 + 72);
                    sub_1002D606C((uint64_t)v131, v80 + 136);
                    sub_1002D606C((uint64_t)v132, v80 + 248);
                    double v93 = *v118;
                    int v134 = *(_DWORD *)(v80 + 368);
                    double v133 = v93;
                    do
                    {
                      uint64_t v94 = v80;
                      uint64_t v80 = a1 + 376 * v92;
                      *(_BYTE *)uint64_t v94 = *(_BYTE *)v80;
                      sub_1002CBDC8(v94 + 8, v80 + 8);
                      sub_1002CBDC8(v94 + 72, v80 + 72);
                      sub_1002CBDC8(v94 + 136, v80 + 136);
                      sub_1002CBDC8(v94 + 248, v80 + 248);
                      int v95 = *(_DWORD *)(v80 + 368);
                      *(void *)(v94 + 360) = *(void *)(v80 + 360);
                      *(_DWORD *)(v94 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = v95;
                      if (!v92) {
                        break;
                      }
                      unint64_t v92 = (v92 - 1) >> 1;
                    }

                    while (*(double *)(a1 + 376 * v92 + 360) < v133);
                    *(_BYTE *)uint64_t v80 = v128;
                    sub_1002CBDC8(v80 + 8, (uint64_t)v129);
                    sub_1002CBDC8(v80 + 72, (uint64_t)v130);
                    sub_1002CBDC8(v80 + 136, (uint64_t)v131);
                    sub_1002CBDC8(v80 + 248, (uint64_t)v132);
                    int v96 = v134;
                    *(double *)(v80 + 360) = v133;
                    *(_DWORD *)(v80 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = v96;
                  }
                }
              }

              BOOL v98 = v78-- <= 2;
              uint64_t v79 = v114 - 376;
            }

            while (!v98);
          }

          return;
        }

        unint64_t v10 = v9 >> 1;
        if ((unint64_t)v8 < 0xBC01)
        {
          sub_1002EF5F0(v7 + 376 * (v9 >> 1), v7, (uint64_t)v112);
        }

        else
        {
          sub_1002EF5F0(v7, v7 + 376 * (v9 >> 1), (uint64_t)v112);
          uint64_t v11 = 376 * v10;
          uint64_t v12 = 376 * v10 + v7 - 376;
          sub_1002EF5F0(v7 + 376, v12, v111);
          sub_1002EF5F0(v7 + 752, v7 + 376 + v11, v110);
          sub_1002EF5F0(v12, v7 + 376 * (v9 >> 1), v7 + 376 + v11);
          sub_1002EF9DC((char *)v7, (char *)(v7 + 376 * (v9 >> 1)));
        }

        --a3;
        if ((a4 & 1) == 0 && *(double *)(v7 - 16) >= *(double *)(v7 + 360))
        {
          char v128 = *(_BYTE *)v7;
          sub_1002D5F00((uint64_t)v129, v7 + 8);
          sub_1002D5F00((uint64_t)v130, v7 + 72);
          sub_1002D606C((uint64_t)v131, v7 + 136);
          sub_1002D606C((uint64_t)v132, v7 + 248);
          double v35 = *(double *)(v7 + 360);
          int v134 = *(_DWORD *)(v7 + 368);
          double v133 = v35;
          if (v35 >= *((double *)a2 - 2))
          {
            unint64_t v38 = v7 + 376;
            do
            {
              unint64_t v6 = v38;
              double v39 = *(double *)(v38 + 360);
              v38 += 376LL;
            }

            while (v133 >= v39);
          }

          else
          {
            uint64_t v36 = v7;
            do
            {
              unint64_t v6 = v36 + 376;
              double v37 = *(double *)(v36 + 736);
              v36 += 376LL;
            }

            while (v133 >= v37);
          }

          double v40 = a2;
          if (v6 < (unint64_t)a2)
          {
            double v41 = a2;
            do
            {
              double v40 = v41 - 376;
              double v42 = *((double *)v41 - 2);
              v41 -= 376;
            }

            while (v133 < v42);
          }

          while (v6 < (unint64_t)v40)
          {
            sub_1002EF9DC((char *)v6, v40);
            do
            {
              double v43 = *(double *)(v6 + 736);
              v6 += 376LL;
            }

            while (v133 >= v43);
            do
            {
              double v44 = *((double *)v40 - 2);
              v40 -= 376;
            }

            while (v133 < v44);
          }

          double v45 = (char *)(v6 - 376);
          if (v6 - 376 != v7)
          {
            *(_BYTE *)uint64_t v7 = *v45;
            sub_1002CBDC8(v7 + 8, v6 - 368);
            sub_1002CBDC8(v7 + 72, v6 - 304);
            sub_1002CBDC8(v7 + 136, v6 - 240);
            sub_1002CBDC8(v7 + 248, v6 - 128);
            int v46 = *(_DWORD *)(v6 - 8);
            *(void *)(v7 + 360) = *(void *)(v6 - 16);
            *(_DWORD *)(v7 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = v46;
          }

          *double v45 = v128;
          sub_1002CBDC8(v6 - 368, (uint64_t)v129);
          sub_1002CBDC8(v6 - 304, (uint64_t)v130);
          sub_1002CBDC8(v6 - 240, (uint64_t)v131);
          sub_1002CBDC8(v6 - 128, (uint64_t)v132);
          a4 = 0;
          int v47 = v134;
          *(double *)(v6 - 16) = v133;
          *(_DWORD *)(v6 - _Block_object_dispose((const void *)(v1 - 112), 8) = v47;
          continue;
        }

        uint64_t v116 = a3;
        char v128 = *(_BYTE *)v7;
        uint64_t v13 = v7 + 8;
        sub_1002D5F00((uint64_t)v129, v7 + 8);
        uint64_t v14 = v7 + 72;
        sub_1002D5F00((uint64_t)v130, v7 + 72);
        uint64_t v15 = v7 + 136;
        sub_1002D606C((uint64_t)v131, v7 + 136);
        uint64_t v16 = v7 + 248;
        sub_1002D606C((uint64_t)v132, v7 + 248);
        uint64_t v17 = 0LL;
        uint64_t v18 = v7 + 360;
        double v19 = *(double *)(v7 + 360);
        int v134 = *(_DWORD *)(v7 + 368);
        double v133 = v19;
        do
        {
          double v20 = *(double *)(v7 + v17 + 736);
          v17 += 376LL;
        }

        while (v20 < v133);
        unint64_t v21 = v7 + v17;
        uint64_t v22 = v119;
        if (v17 == 376)
        {
          unint64_t v25 = v119;
          while (v21 < v25)
          {
            unint64_t v23 = (char *)(v25 - 376);
            double v26 = *(double *)(v25 - 16);
            v25 -= 376LL;
            if (v26 < v133) {
              goto LABEL_20;
            }
          }

          unint64_t v23 = (char *)v25;
        }

        else
        {
          do
          {
            unint64_t v23 = (char *)(v22 - 376);
            double v24 = *(double *)(v22 - 16);
            v22 -= 376LL;
          }

          while (v24 >= v133);
        }

void sub_1002EF5F0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a1;
  double v6 = *(double *)(a2 + 360);
  double v7 = *(double *)(a3 + 360);
  if (v6 < *(double *)(a1 + 360))
  {
    if (v7 >= v6)
    {
      sub_1002EF9DC((char *)a1, (char *)a2);
      a1 = a2;
    }

    uint64_t v8 = (char *)a3;
    goto LABEL_9;
  }

  if (v7 < v6)
  {
    sub_1002EF9DC((char *)a2, (char *)a3);
    if (*(double *)(a2 + 360) < *(double *)(v5 + 360))
    {
      a1 = v5;
      uint64_t v8 = (char *)a2;
LABEL_9:
      sub_1002EF9DC((char *)a1, v8);
    }
  }

BOOL sub_1002EF69C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v4 = 0x51B3BEA3677D46CFLL * ((a2 - a1) >> 3);
  BOOL result = 1LL;
  switch(v4)
  {
    case 0LL:
    case 1LL:
      return result;
    case 2LL:
      if (*(double *)(a2 - 16) < *(double *)(a1 + 360))
      {
        double v6 = (char *)(a2 - 376);
        double v7 = (char *)a1;
        goto LABEL_4;
      }

      return result;
    case 3LL:
      sub_1002EF5F0(a1, a1 + 376, a2 - 376);
      return 1LL;
    case 4LL:
      sub_1002EFB30(a1, a1 + 376, a1 + 752, a2 - 376);
      return 1LL;
    case 5LL:
      sub_1002EFB30(a1, a1 + 376, a1 + 752, a1 + 1128);
      if (*(double *)(v2 - 16) < *(double *)(a1 + 1488))
      {
        sub_1002EF9DC((char *)(a1 + 1128), (char *)(v2 - 376));
        if (*(double *)(a1 + 1488) < *(double *)(a1 + 1112))
        {
          sub_1002EF9DC((char *)(a1 + 752), (char *)(a1 + 1128));
          if (*(double *)(a1 + 1112) < *(double *)(a1 + 736))
          {
            sub_1002EF9DC((char *)(a1 + 376), (char *)(a1 + 752));
            if (*(double *)(a1 + 736) < *(double *)(a1 + 360))
            {
              double v7 = (char *)a1;
              double v6 = (char *)(a1 + 376);
LABEL_4:
              sub_1002EF9DC(v7, v6);
            }
          }
        }
      }

      return 1LL;
    default:
      uint64_t v8 = a1 + 752;
      sub_1002EF5F0(a1, a1 + 376, a1 + 752);
      uint64_t v9 = a1 + 1128;
      if (a1 + 1128 == v2) {
        return 1LL;
      }
      uint64_t v10 = 0LL;
      int v11 = 0;
      uint64_t v16 = v2;
      break;
  }

  while (*(double *)(v9 + 360) >= *(double *)(v8 + 360))
  {
LABEL_16:
    uint64_t v8 = v9;
    v10 += 376LL;
    v9 += 376LL;
    if (v9 == v2) {
      return 1LL;
    }
  }

  char v17 = *(_BYTE *)v9;
  sub_1002D5F00((uint64_t)v18, v9 + 8);
  sub_1002D5F00((uint64_t)v19, v9 + 72);
  sub_1002D606C((uint64_t)v20, v9 + 136);
  sub_1002D606C((uint64_t)v21, v9 + 248);
  double v22 = *(double *)(v9 + 360);
  int v23 = *(_DWORD *)(v9 + 368);
  uint64_t v12 = v10;
  while (1)
  {
    uint64_t v13 = a1 + v12;
    *(_BYTE *)(a1 + v12 + 112_Block_object_dispose((const void *)(v1 - 112), 8) = *(_BYTE *)(a1 + v12 + 752);
    uint64_t v14 = a1 + v12 + 760;
    sub_1002CBDC8(a1 + v12 + 1136, v14);
    sub_1002CBDC8(v13 + 1200, v13 + 824);
    sub_1002CBDC8(v13 + 1264, v13 + 888);
    sub_1002CBDC8(v13 + 1376, v13 + 1000);
    *(void *)(v13 + 148_Block_object_dispose((const void *)(v1 - 112), 8) = *(void *)(v13 + 1112);
    *(_DWORD *)(v13 + 1496) = *(_DWORD *)(v13 + 1120);
    if (v12 == -752) {
      break;
    }
    v12 -= 376LL;
    if (v22 >= *(double *)(v13 + 736))
    {
      uint64_t v15 = (_BYTE *)(a1 + v12 + 1128);
      goto LABEL_14;
    }
  }

  uint64_t v15 = (_BYTE *)a1;
LABEL_14:
  _BYTE *v15 = v17;
  sub_1002CBDC8(v14, (uint64_t)v18);
  sub_1002CBDC8(v13 + 824, (uint64_t)v19);
  sub_1002CBDC8(v13 + 888, (uint64_t)v20);
  sub_1002CBDC8(v13 + 1000, (uint64_t)v21);
  *(double *)(v13 + 1112) = v22;
  *(_DWORD *)(v13 + 1120) = v23;
  if (++v11 != 8)
  {
    uint64_t v2 = v16;
    goto LABEL_16;
  }

  return v9 + 376 == v16;
}

void sub_1002EF9DC(char *a1, char *a2)
{
  char v5 = *a1;
  sub_1002D5F00((uint64_t)v6, (uint64_t)(a1 + 8));
  sub_1002D5F00((uint64_t)v7, (uint64_t)(a1 + 72));
  sub_1002D606C((uint64_t)v8, (uint64_t)(a1 + 136));
  sub_1002D606C((uint64_t)v9, (uint64_t)(a1 + 248));
  uint64_t v10 = *((void *)a1 + 45);
  int v11 = *((_DWORD *)a1 + 92);
  *a1 = *a2;
  sub_1002CBDC8((uint64_t)(a1 + 8), (uint64_t)(a2 + 8));
  sub_1002CBDC8((uint64_t)(a1 + 72), (uint64_t)(a2 + 72));
  sub_1002CBDC8((uint64_t)(a1 + 136), (uint64_t)(a2 + 136));
  sub_1002CBDC8((uint64_t)(a1 + 248), (uint64_t)(a2 + 248));
  uint64_t v4 = *((void *)a2 + 45);
  *((_DWORD *)a1 + 92) = *((_DWORD *)a2 + 92);
  *((void *)a1 + 45) = v4;
  *a2 = v5;
  sub_1002CBDC8((uint64_t)(a2 + 8), (uint64_t)v6);
  sub_1002CBDC8((uint64_t)(a2 + 72), (uint64_t)v7);
  sub_1002CBDC8((uint64_t)(a2 + 136), (uint64_t)v8);
  sub_1002CBDC8((uint64_t)(a2 + 248), (uint64_t)v9);
  *((void *)a2 + 45) = v10;
  *((_DWORD *)a2 + 92) = v11;
}

void sub_1002EFB30(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(double *)(a4 + 360) < *(double *)(a3 + 360))
  {
    sub_1002EF9DC((char *)a3, (char *)a4);
    if (*(double *)(a3 + 360) < *(double *)(a2 + 360))
    {
      sub_1002EF9DC((char *)a2, (char *)a3);
    }
  }

uint64_t sub_1002EFBC4(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = 0x51B3BEA3677D46CFLL * ((a1[1] - *a1) >> 3);
  unint64_t v4 = v3 + 1;
  if (0xA3677D46CEFA8D9ELL * ((a1[2] - *a1) >> 3) > v4) {
    unint64_t v4 = 0xA3677D46CEFA8D9ELL * ((a1[2] - *a1) >> 3);
  }
  else {
    unint64_t v6 = v4;
  }
  uint64_t v14 = a1 + 2;
  if (v6) {
    double v7 = (char *)sub_1002EE38C((uint64_t)(a1 + 2), v6);
  }
  else {
    double v7 = 0LL;
  }
  uint64_t v10 = v7;
  int v11 = &v7[376 * v3];
  uint64_t v13 = &v7[376 * v6];
  sub_1002EE480((uint64_t)(a1 + 2), (uint64_t)v11, a2);
  uint64_t v12 = v11 + 376;
  sub_1002EE318(a1, &v10);
  uint64_t v8 = a1[1];
  sub_1002EE538((uint64_t)&v10);
  return v8;
}

void sub_1002EFCD4(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_1002EFCE8(char *a1, char *a2, uint64_t a3, char a4)
{
LABEL_1:
  uint64_t v136 = a2 - 376;
  unint64_t v138 = (unint64_t)a2;
  uint64_t v127 = (uint64_t)(a2 - 1128);
  uint64_t v129 = (uint64_t)(a2 - 752);
  float32x4_t v131 = a2 - 384;
  unint64_t k = (unint64_t)a1;
  while (2)
  {
    uint64_t v8 = k;
    uint64_t v9 = (uint64_t)&a2[-k];
    uint64_t v10 = 0x51B3BEA3677D46CFLL * ((uint64_t)&a2[-k] >> 3);
    switch(v10)
    {
      case 0LL:
      case 1LL:
        return;
      case 2LL:
        int v54 = *((_DWORD *)a2 - 2);
        int v55 = *(_DWORD *)(v8 + 368);
        return;
      case 3LL:
        sub_1002F101C(v8, v8 + 376, (uint64_t)v136);
        return;
      case 4LL:
        sub_1002F144C(v8, v8 + 376, v8 + 752, (uint64_t)v136);
        return;
      case 5LL:
        sub_1002F0F00(v8, v8 + 376, v8 + 752, v8 + 1128, (uint64_t)v136);
        return;
      default:
        __int128 v139 = (char *)v8;
        if (v9 <= 9023)
        {
          if ((a4 & 1) != 0)
          {
            if ((char *)v8 != a2)
            {
              uint64_t v56 = (char *)(v8 + 376);
              if ((char *)(v8 + 376) != a2)
              {
                uint64_t v57 = 0LL;
                uint64_t v58 = v148;
                int v59 = (char *)v8;
                do
                {
                  int64_t v60 = v59;
                  int v59 = v56;
                  int v61 = *((_DWORD *)v60 + 186);
                  int v62 = *((_DWORD *)v60 + 92);
                  if (v61 < v62 || v61 <= v62 && *((double *)v60 + 92) < *((double *)v60 + 45))
                  {
                    char v147 = *v59;
                    uint64_t v63 = (uint64_t)v58;
                    sub_1002D5F00((uint64_t)v58, (uint64_t)(v60 + 384));
                    sub_1002D5F00((uint64_t)v149, (uint64_t)(v60 + 448));
                    sub_1002D606C((uint64_t)v150, (uint64_t)(v60 + 512));
                    sub_1002D606C((uint64_t)v151, (uint64_t)(v60 + 624));
                    double v152 = *((double *)v60 + 92);
                    int v153 = *((_DWORD *)v60 + 186);
                    for (uint64_t i = v57; ; i -= 376LL)
                    {
                      uint64_t v65 = v8 + i;
                      *(_BYTE *)(v8 + i + 376) = *(_BYTE *)(v8 + i);
                      uint64_t v66 = v8 + i + 8;
                      sub_1002CBDC8(v8 + i + 384, v66);
                      sub_1002CBDC8(v65 + 448, v65 + 72);
                      sub_1002CBDC8(v65 + 512, v65 + 136);
                      sub_1002CBDC8(v65 + 624, v65 + 248);
                      *(void *)(v65 + 736) = *(void *)(v65 + 360);
                      *(_DWORD *)(v65 + 744) = *(_DWORD *)(v65 + 368);
                      if (!i)
                      {
                        uint64_t v68 = v139;
                        goto LABEL_115;
                      }

                      int v67 = *(_DWORD *)(v65 - 8);
                      uint64_t v8 = (uint64_t)v139;
                    }

                    uint64_t v68 = &v139[i];
LABEL_115:
                    uint64_t v58 = (_BYTE *)v63;
                    *uint64_t v68 = v147;
                    sub_1002CBDC8(v66, v63);
                    sub_1002CBDC8(v65 + 72, (uint64_t)v149);
                    sub_1002CBDC8(v65 + 136, (uint64_t)v150);
                    sub_1002CBDC8(v65 + 248, (uint64_t)v151);
                    int v69 = v153;
                    *(double *)(v65 + 360) = v152;
                    *(_DWORD *)(v65 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = v69;
                    a2 = (char *)v138;
                    uint64_t v8 = (uint64_t)v139;
                  }

                  uint64_t v56 = v59 + 376;
                  v57 += 376LL;
                }

                while (v59 + 376 != a2);
              }
            }
          }

          else if ((char *)v8 != a2)
          {
            uint64_t v115 = v8 + 376;
            if ((char *)(v8 + 376) != a2)
            {
              uint64_t v116 = v8 + 736;
              do
              {
                uint64_t v117 = v8;
                uint64_t v8 = v115;
                int v118 = *(_DWORD *)(v117 + 744);
                int v119 = *(_DWORD *)(v117 + 368);
                if (v118 < v119 || v118 <= v119 && *(double *)(v117 + 736) < *(double *)(v117 + 360))
                {
                  char v147 = *(_BYTE *)v8;
                  sub_1002D5F00((uint64_t)v148, v117 + 384);
                  sub_1002D5F00((uint64_t)v149, v117 + 448);
                  sub_1002D606C((uint64_t)v150, v117 + 512);
                  sub_1002D606C((uint64_t)v151, v117 + 624);
                  double v152 = *(double *)(v117 + 736);
                  int v153 = *(_DWORD *)(v117 + 744);
                  for (uint64_t j = v116; ; j -= 376LL)
                  {
                    *(_BYTE *)(j - 360) = *(_BYTE *)(j - 736);
                    sub_1002CBDC8(j - 352, j - 728);
                    sub_1002CBDC8(j - 288, j - 664);
                    sub_1002CBDC8(j - 224, j - 600);
                    sub_1002CBDC8(j - 112, j - 488);
                    *(_DWORD *)(j + _Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)(j - 368);
                    *(void *)uint64_t j = *(void *)(j - 376);
                    int v121 = *(_DWORD *)(j - 744);
                  }

                  *(_BYTE *)(j - 736) = v147;
                  sub_1002CBDC8(j - 728, (uint64_t)v148);
                  sub_1002CBDC8(j - 664, (uint64_t)v149);
                  sub_1002CBDC8(j - 600, (uint64_t)v150);
                  sub_1002CBDC8(j - 488, (uint64_t)v151);
                  int v122 = v153;
                  *(double *)(j - 376) = v152;
                  *(_DWORD *)(j - 36_Block_object_dispose((const void *)(v1 - 112), 8) = v122;
                  a2 = (char *)v138;
                }

                uint64_t v115 = v8 + 376;
                v116 += 376LL;
              }

              while ((char *)(v8 + 376) != a2);
            }
          }

          return;
        }

        if (!a3)
        {
          if ((char *)v8 != a2)
          {
            int64_t v137 = (unint64_t)(v10 - 2) >> 1;
            int64_t v70 = v137;
            do
            {
              int64_t v71 = v70;
              if (v137 >= v70)
              {
                uint64_t v72 = (2 * v70) | 1;
                uint64_t v73 = (char *)(v8 + 376 * v72);
                if (2 * v70 + 2 < v10)
                {
                  int v74 = *(_DWORD *)(v8 + 376 * v72 + 368);
                  int v75 = *((_DWORD *)v73 + 186);
                  if (v74 < v75 || v74 <= v75 && *(double *)(v8 + 376 * v72 + 360) < *((double *)v73 + 92))
                  {
                    v73 += 376;
                    uint64_t v72 = 2 * v70 + 2;
                  }
                }

                int v76 = *((_DWORD *)v73 + 92);
                int v77 = *(_DWORD *)(v8 + 376 * v71 + 368);
                if (v76 >= v77 && (v76 > v77 || *((double *)v73 + 45) >= *(double *)(v8 + 376 * v71 + 360)))
                {
                  uint64_t v78 = v8 + 376 * v71;
                  char v147 = *(_BYTE *)v78;
                  int64_t v135 = v71;
                  sub_1002D5F00((uint64_t)v148, v78 + 8);
                  sub_1002D5F00((uint64_t)v149, v78 + 72);
                  sub_1002D606C((uint64_t)v150, v78 + 136);
                  sub_1002D606C((uint64_t)v151, v78 + 248);
                  double v79 = *(double *)(v78 + 360);
                  int v153 = *(_DWORD *)(v78 + 368);
                  double v152 = v79;
                  while (1)
                  {
                    uint64_t v80 = (double *)v73;
                    *(_BYTE *)uint64_t v78 = *v73;
                    uint64_t v81 = (uint64_t)(v73 + 8);
                    sub_1002CBDC8(v78 + 8, (uint64_t)(v73 + 8));
                    uint64_t v82 = (uint64_t)(v73 + 72);
                    sub_1002CBDC8(v78 + 72, (uint64_t)(v73 + 72));
                    uint64_t v83 = (uint64_t)(v73 + 136);
                    sub_1002CBDC8(v78 + 136, (uint64_t)(v73 + 136));
                    uint64_t v84 = (uint64_t)(v73 + 248);
                    sub_1002CBDC8(v78 + 248, (uint64_t)(v73 + 248));
                    int v85 = *((_DWORD *)v73 + 92);
                    *(void *)(v78 + 360) = *((void *)v73 + 45);
                    *(_DWORD *)(v78 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = v85;
                    if (v137 < v72) {
                      break;
                    }
                    uint64_t v86 = (2 * v72) | 1;
                    uint64_t v73 = &v139[376 * v86];
                    if (2 * v72 + 2 < v10)
                    {
                      int v87 = *(_DWORD *)&v139[376 * v86 + 368];
                      int v88 = *((_DWORD *)v73 + 186);
                      if (v87 < v88 || v87 <= v88 && *(double *)&v139[376 * v86 + 360] < *((double *)v73 + 92))
                      {
                        v73 += 376;
                        uint64_t v86 = 2 * v72 + 2;
                      }
                    }

                    int v89 = *((_DWORD *)v73 + 92);
                    if (v89 < v153) {
                      break;
                    }
                    uint64_t v78 = (uint64_t)v80;
                    uint64_t v72 = v86;
                    if (v89 <= v153)
                    {
                      uint64_t v78 = (uint64_t)v80;
                      uint64_t v72 = v86;
                    }
                  }

                  *(_BYTE *)uint64_t v80 = v147;
                  sub_1002CBDC8(v81, (uint64_t)v148);
                  sub_1002CBDC8(v82, (uint64_t)v149);
                  sub_1002CBDC8(v83, (uint64_t)v150);
                  sub_1002CBDC8(v84, (uint64_t)v151);
                  int64_t v71 = v135;
                  int v90 = v153;
                  v80[45] = v152;
                  *((_DWORD *)v80 + 92) = v90;
                  a2 = (char *)v138;
                  uint64_t v8 = (uint64_t)v139;
                }
              }

              int64_t v70 = v71 - 1;
            }

            while (v71);
            int64_t v91 = v9 / 0x178uLL;
            uint64_t v128 = v8 + 72;
            uint64_t v130 = v8 + 8;
            uint64_t v125 = v8 + 248;
            uint64_t v126 = v8 + 136;
            uint64_t v124 = v8 + 360;
            do
            {
              double v133 = a2;
              char v140 = *(_BYTE *)v8;
              sub_1002D5F00((uint64_t)v141, v130);
              sub_1002D5F00((uint64_t)v142, v128);
              sub_1002D606C((uint64_t)v143, v126);
              sub_1002D606C((uint64_t)v144, v125);
              uint64_t v92 = 0LL;
              uint64_t v93 = *(void *)v124;
              int v146 = *(_DWORD *)(v124 + 8);
              uint64_t v145 = v93;
              uint64_t v94 = (char *)v8;
              do
              {
                int v95 = v94;
                uint64_t v96 = v92 + 1;
                v94 += 376 * v92 + 376;
                uint64_t v97 = 2 * v92;
                uint64_t v92 = (2 * v92) | 1;
                int64_t v98 = v97 + 2;
                if (v98 < v91)
                {
                  int v99 = *(_DWORD *)&v95[376 * v96 + 368];
                  int v100 = *((_DWORD *)v94 + 186);
                  if (v99 < v100 || v99 <= v100 && *(double *)&v95[376 * v96 + 360] < *((double *)v94 + 92))
                  {
                    v94 += 376;
                    uint64_t v92 = v98;
                  }
                }

                *int v95 = *v94;
                sub_1002CBDC8((uint64_t)(v95 + 8), (uint64_t)(v94 + 8));
                sub_1002CBDC8((uint64_t)(v95 + 72), (uint64_t)(v94 + 72));
                sub_1002CBDC8((uint64_t)(v95 + 136), (uint64_t)(v94 + 136));
                sub_1002CBDC8((uint64_t)(v95 + 248), (uint64_t)(v94 + 248));
                int v101 = *((_DWORD *)v94 + 92);
                *((void *)v95 + 45) = *((void *)v94 + 45);
                *((_DWORD *)v95 + 92) = v101;
              }

              while (v92 <= (uint64_t)((unint64_t)(v91 - 2) >> 1));
              a2 = v133 - 376;
              if (v94 == v133 - 376)
              {
                char *v94 = v140;
                sub_1002CBDC8((uint64_t)(v94 + 8), (uint64_t)v141);
                sub_1002CBDC8((uint64_t)(v94 + 72), (uint64_t)v142);
                sub_1002CBDC8((uint64_t)(v94 + 136), (uint64_t)v143);
                sub_1002CBDC8((uint64_t)(v94 + 248), (uint64_t)v144);
                int v113 = v146;
                *((void *)v94 + 45) = v145;
                *((_DWORD *)v94 + 92) = v113;
                uint64_t v8 = (uint64_t)v139;
              }

              else
              {
                char *v94 = *a2;
                sub_1002CBDC8((uint64_t)(v94 + 8), (uint64_t)(v133 - 368));
                sub_1002CBDC8((uint64_t)(v94 + 72), (uint64_t)(v133 - 304));
                sub_1002CBDC8((uint64_t)(v94 + 136), (uint64_t)(v133 - 240));
                sub_1002CBDC8((uint64_t)(v94 + 248), (uint64_t)(v133 - 128));
                uint64_t v102 = *((void *)v133 - 2);
                *((_DWORD *)v94 + 92) = *((_DWORD *)v133 - 2);
                uint64_t v123 = (double *)(v94 + 360);
                *((void *)v94 + 45) = v102;
                *a2 = v140;
                sub_1002CBDC8((uint64_t)(v133 - 368), (uint64_t)v141);
                sub_1002CBDC8((uint64_t)(v133 - 304), (uint64_t)v142);
                sub_1002CBDC8((uint64_t)(v133 - 240), (uint64_t)v143);
                sub_1002CBDC8((uint64_t)(v133 - 128), (uint64_t)v144);
                int v103 = v146;
                *((void *)v133 - 2) = v145;
                *((_DWORD *)v133 - 2) = v103;
                uint64_t v8 = (uint64_t)v139;
                uint64_t v104 = v94 - v139 + 376;
                if (v104 >= 377)
                {
                  unint64_t v105 = (v104 / 0x178uLL - 2) >> 1;
                  int v106 = *(_DWORD *)&v139[376 * v105 + 368];
                  int v107 = *((_DWORD *)v94 + 92);
                  if (v106 < v107 || v106 <= v107 && *(double *)&v139[376 * v105 + 360] < *v123)
                  {
                    char v147 = *v94;
                    sub_1002D5F00((uint64_t)v148, (uint64_t)(v94 + 8));
                    sub_1002D5F00((uint64_t)v149, (uint64_t)(v94 + 72));
                    sub_1002D606C((uint64_t)v150, (uint64_t)(v94 + 136));
                    sub_1002D606C((uint64_t)v151, (uint64_t)(v94 + 248));
                    double v108 = *v123;
                    int v153 = *((_DWORD *)v94 + 92);
                    double v152 = v108;
                    do
                    {
                      uint64_t v109 = v94;
                      uint64_t v94 = &v139[376 * v105];
                      *uint64_t v109 = *v94;
                      sub_1002CBDC8((uint64_t)(v109 + 8), (uint64_t)(v94 + 8));
                      sub_1002CBDC8((uint64_t)(v109 + 72), (uint64_t)(v94 + 72));
                      sub_1002CBDC8((uint64_t)(v109 + 136), (uint64_t)(v94 + 136));
                      sub_1002CBDC8((uint64_t)(v109 + 248), (uint64_t)(v94 + 248));
                      int v110 = *((_DWORD *)v94 + 92);
                      *((void *)v109 + 45) = *((void *)v94 + 45);
                      *((_DWORD *)v109 + 92) = v110;
                      if (!v105) {
                        break;
                      }
                      unint64_t v105 = (v105 - 1) >> 1;
                      int v111 = *(_DWORD *)&v139[376 * v105 + 368];
                    }

                    while (v111 < v153 || v111 <= v153 && *(double *)&v139[376 * v105 + 360] < v152);
                    char *v94 = v147;
                    sub_1002CBDC8((uint64_t)(v94 + 8), (uint64_t)v148);
                    sub_1002CBDC8((uint64_t)(v94 + 72), (uint64_t)v149);
                    sub_1002CBDC8((uint64_t)(v94 + 136), (uint64_t)v150);
                    sub_1002CBDC8((uint64_t)(v94 + 248), (uint64_t)v151);
                    int v112 = v153;
                    *((double *)v94 + 45) = v152;
                    *((_DWORD *)v94 + 92) = v112;
                    a2 = v133 - 376;
                  }
                }
              }
            }

            while (v91-- > 2);
          }

          return;
        }

        unint64_t v11 = (unint64_t)v10 >> 1;
        uint64_t v12 = (char *)(v8 + 376 * ((unint64_t)v10 >> 1));
        if ((unint64_t)v9 < 0xBC01)
        {
          sub_1002F101C((uint64_t)v12, v8, (uint64_t)v136);
        }

        else
        {
          sub_1002F101C(v8, (uint64_t)v12, (uint64_t)v136);
          uint64_t v13 = 376 * v11;
          uint64_t v14 = 376 * v11 + v8 - 376;
          sub_1002F101C(v8 + 376, v14, v129);
          sub_1002F101C(v8 + 752, v8 + 376 + v13, v127);
          sub_1002F101C(v14, (uint64_t)v12, v8 + 376 + v13);
          sub_1002EF9DC((char *)v8, v12);
        }

        --a3;
        if ((a4 & 1) == 0)
        {
          int v15 = *(_DWORD *)(v8 - 8);
          int v16 = *(_DWORD *)(v8 + 368);
          if (v15 >= v16 && (v15 > v16 || *(double *)(v8 - 16) >= *(double *)(v8 + 360)))
          {
            char v147 = *(_BYTE *)v8;
            sub_1002D5F00((uint64_t)v148, v8 + 8);
            sub_1002D5F00((uint64_t)v149, v8 + 72);
            sub_1002D606C((uint64_t)v150, v8 + 136);
            sub_1002D606C((uint64_t)v151, v8 + 248);
            double v41 = *(double *)(v8 + 360);
            int v153 = *(_DWORD *)(v8 + 368);
            double v152 = v41;
            int v42 = *((_DWORD *)a2 - 2);
            if (v153 < v42 || v153 <= v42 && v152 < *((double *)a2 - 2))
            {
              int v43 = *(_DWORD *)(v8 + 744);
              if (v153 >= v43)
              {
                uint64_t v45 = v8 + 736;
                do
                {
                  int v43 = *(_DWORD *)(v45 + 384);
                  v45 += 376LL;
                }

                while (v153 >= v43);
                unint64_t k = v45 - 360;
              }

              else
              {
                unint64_t k = v8 + 376;
              }
            }

            else
            {
              for (unint64_t k = v8 + 376; k < (unint64_t)a2; k += 376LL)
              {
                int v44 = *(_DWORD *)(k + 368);
              }
            }

            int v46 = a2;
            if (k < (unint64_t)a2)
            {
              int v46 = m + 8;
            }

            while (k < (unint64_t)v46)
            {
              sub_1002EF9DC((char *)k, v46);
              int v48 = *(_DWORD *)(k + 744);
              if (v153 >= v48)
              {
                unint64_t v49 = k + 736;
                do
                {
                  int v48 = *(_DWORD *)(v49 + 384);
                  v49 += 376LL;
                }

                while (v153 >= v48);
                unint64_t k = v49 - 360;
              }

              else
              {
                k += 376LL;
              }

              do
              {
                do
                {
                  v46 -= 376;
                  int v50 = *((_DWORD *)v46 + 92);
                }

                while (v153 < v50);
              }

              while (v153 <= v50 && v152 < *((double *)v46 + 45));
            }

            double v51 = (char *)(k - 376);
            if (k - 376 != v8)
            {
              *(_BYTE *)uint64_t v8 = *v51;
              sub_1002CBDC8(v8 + 8, k - 368);
              sub_1002CBDC8(v8 + 72, k - 304);
              sub_1002CBDC8(v8 + 136, k - 240);
              sub_1002CBDC8(v8 + 248, k - 128);
              int v52 = *(_DWORD *)(k - 8);
              *(void *)(v8 + 360) = *(void *)(k - 16);
              *(_DWORD *)(v8 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = v52;
            }

            *double v51 = v147;
            sub_1002CBDC8(k - 368, (uint64_t)v148);
            sub_1002CBDC8(k - 304, (uint64_t)v149);
            sub_1002CBDC8(k - 240, (uint64_t)v150);
            sub_1002CBDC8(k - 128, (uint64_t)v151);
            a4 = 0;
            int v53 = v153;
            *(double *)(k - 16) = v152;
            *(_DWORD *)(k - _Block_object_dispose((const void *)(v1 - 112), 8) = v53;
            continue;
          }
        }

        uint64_t v134 = a3;
        char v147 = *(_BYTE *)v8;
        uint64_t v17 = v8 + 8;
        sub_1002D5F00((uint64_t)v148, v8 + 8);
        uint64_t v18 = v8 + 72;
        sub_1002D5F00((uint64_t)v149, v8 + 72);
        uint64_t v19 = v8 + 136;
        sub_1002D606C((uint64_t)v150, v8 + 136);
        uint64_t v20 = v8 + 248;
        sub_1002D606C((uint64_t)v151, v8 + 248);
        uint64_t v21 = 0LL;
        uint64_t v22 = v8 + 360;
        double v23 = *(double *)(v8 + 360);
        int v153 = *(_DWORD *)(v8 + 368);
        double v152 = v23;
        while (1)
        {
          int v24 = *(_DWORD *)(v8 + v21 + 744);
          v21 += 376LL;
        }

        unint64_t v25 = v8 + v21 + 376;
        if (v21)
        {
          double v26 = v136;
          int v27 = *(_DWORD *)(v138 - 8);
          double v28 = v131;
          if (v27 >= v153)
          {
            do
            {
              int v27 = *(_DWORD *)v28;
              v28 -= 376;
            }

            while (v27 >= v153);
LABEL_22:
            double v26 = v28 + 8;
          }
        }

        else
        {
          double v26 = (char *)v138;
          if (v25 < v138)
          {
            double v26 = v136;
            int v29 = *(_DWORD *)(v138 - 8);
            if (v29 >= v153)
            {
              double v28 = v131;
              double v26 = v136;
              while (1)
              {
                unint64_t v39 = (unint64_t)(v28 + 8);
                if (v29 <= v153)
                {
                }

                else if (v25 >= v39)
                {
                  goto LABEL_22;
                }

                v26 -= 376;
                int v29 = *(_DWORD *)v28;
                v28 -= 376;
                if (v29 < v153) {
                  goto LABEL_22;
                }
              }
            }
          }
        }

        unint64_t k = v25;
        if (v25 < (unint64_t)v26)
        {
          unsigned int v30 = v26;
          do
          {
            sub_1002EF9DC((char *)k, v30);
            do
            {
              do
              {
                k += 376LL;
                int v31 = *(_DWORD *)(k + 368);
              }

              while (v31 < v153);
            }

            while (v31 <= v153 && *(double *)(k + 360) < v152);
            int v32 = *((_DWORD *)v30 - 2);
            if (v32 >= v153)
            {
              int v33 = v30 - 384;
              do
              {
                int v32 = *(_DWORD *)v33;
                v33 -= 376;
              }

              while (v32 >= v153);
              unsigned int v30 = v33 + 8;
            }

            else
            {
              v30 -= 376;
            }
          }

          while (k < (unint64_t)v30);
        }

        BOOL v34 = (char *)(k - 376);
        a1 = v139;
        if ((char *)(k - 376) != v139)
        {
          char *v139 = *v34;
          sub_1002CBDC8(v17, k - 368);
          sub_1002CBDC8(v18, k - 304);
          sub_1002CBDC8(v19, k - 240);
          sub_1002CBDC8(v20, k - 128);
          int v35 = *(_DWORD *)(k - 8);
          *(void *)uint64_t v22 = *(void *)(k - 16);
          *(_DWORD *)(v22 + _Block_object_dispose((const void *)(v1 - 112), 8) = v35;
        }

        *BOOL v34 = v147;
        sub_1002CBDC8(k - 368, (uint64_t)v148);
        sub_1002CBDC8(k - 304, (uint64_t)v149);
        sub_1002CBDC8(k - 240, (uint64_t)v150);
        __n128 v36 = sub_1002CBDC8(k - 128, (uint64_t)v151);
        a3 = v134;
        int v37 = v153;
        *(double *)(k - 16) = v152;
        *(_DWORD *)(k - _Block_object_dispose((const void *)(v1 - 112), 8) = v37;
        a2 = (char *)v138;
        if (v25 < (unint64_t)v26)
        {
LABEL_44:
          sub_1002EFCE8(v139, k - 376, v134, a4 & 1, v36);
          a4 = 0;
          continue;
        }

        BOOL v38 = sub_1002F1138((uint64_t)v139, k - 376);
        if (!sub_1002F1138(k, v138))
        {
          if (v38) {
            continue;
          }
          goto LABEL_44;
        }

        a2 = (char *)(k - 376);
        if (!v38) {
          goto LABEL_1;
        }
        return;
    }
  }

double sub_1002F0F00(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  double result = sub_1002F144C(a1, a2, a3, a4);
  int v11 = *(_DWORD *)(a5 + 368);
  int v12 = *(_DWORD *)(a4 + 368);
  if (v11 < v12 || v11 <= v12 && (double result = *(double *)(a5 + 360), result < *(double *)(a4 + 360)))
  {
    sub_1002EF9DC((char *)a4, (char *)a5);
    int v13 = *(_DWORD *)(a4 + 368);
    int v14 = *(_DWORD *)(a3 + 368);
    if (v13 < v14 || v13 <= v14 && (double result = *(double *)(a4 + 360), result < *(double *)(a3 + 360)))
    {
      sub_1002EF9DC((char *)a3, (char *)a4);
      int v15 = *(_DWORD *)(a3 + 368);
      int v16 = *(_DWORD *)(a2 + 368);
      if (v15 < v16 || v15 <= v16 && (double result = *(double *)(a3 + 360), result < *(double *)(a2 + 360)))
      {
        sub_1002EF9DC((char *)a2, (char *)a3);
        int v17 = *(_DWORD *)(a2 + 368);
        int v18 = *(_DWORD *)(a1 + 368);
      }
    }
  }

  return result;
}

double sub_1002F101C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a1;
  int v6 = *(_DWORD *)(a2 + 368);
  int v7 = *(_DWORD *)(a1 + 368);
  if (v6 >= v7 && (v6 > v7 || (double result = *(double *)(a2 + 360), result >= *(double *)(a1 + 360))))
  {
    int v10 = *(_DWORD *)(a3 + 368);
    if (v10 < v6 || v10 <= v6 && (double result = *(double *)(a3 + 360), result < *(double *)(a2 + 360)))
    {
      sub_1002EF9DC((char *)a2, (char *)a3);
      int v11 = *(_DWORD *)(a2 + 368);
      int v12 = *(_DWORD *)(v5 + 368);
      if (v11 < v12 || v11 <= v12 && (double result = *(double *)(a2 + 360), result < *(double *)(v5 + 360)))
      {
        a1 = v5;
        int v13 = (char *)a2;
LABEL_18:
        sub_1002EF9DC((char *)a1, v13);
      }
    }
  }

  else
  {
    int v9 = *(_DWORD *)(a3 + 368);
    sub_1002EF9DC((char *)a1, (char *)a2);
    int v14 = *(_DWORD *)(a3 + 368);
    int v15 = *(_DWORD *)(a2 + 368);
    if (v14 < v15 || v14 <= v15 && (double result = *(double *)(a3 + 360), result < *(double *)(a2 + 360)))
    {
      a1 = a2;
LABEL_17:
      int v13 = (char *)a3;
      goto LABEL_18;
    }
  }

  return result;
}

BOOL sub_1002F1138(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v4 = 0x51B3BEA3677D46CFLL * ((a2 - a1) >> 3);
  BOOL result = 1LL;
  switch(v4)
  {
    case 0LL:
    case 1LL:
      return result;
    case 2LL:
      int v6 = *(_DWORD *)(a2 - 8);
      int v7 = *(_DWORD *)(a1 + 368);
      if (v6 < v7 || v6 <= v7 && *(double *)(a2 - 16) < *(double *)(a1 + 360))
      {
        sub_1002EF9DC((char *)a1, (char *)(a2 - 376));
        return 1LL;
      }

      return result;
    case 3LL:
      sub_1002F101C(a1, a1 + 376, a2 - 376);
      return 1LL;
    case 4LL:
      sub_1002F144C(a1, a1 + 376, a1 + 752, a2 - 376);
      return 1LL;
    case 5LL:
      sub_1002F0F00(a1, a1 + 376, a1 + 752, a1 + 1128, a2 - 376);
      return 1LL;
    default:
      uint64_t v8 = a1 + 752;
      sub_1002F101C(a1, a1 + 376, a1 + 752);
      uint64_t v9 = a1 + 1128;
      if (a1 + 1128 == v2) {
        return 1LL;
      }
      uint64_t v10 = 0LL;
      int v11 = 0;
      uint64_t v17 = v2;
      break;
  }

  while (1)
  {
    int v12 = *(_DWORD *)(v9 + 368);
    int v13 = *(_DWORD *)(v8 + 368);
    int v18 = v11;
    char v19 = *(_BYTE *)v9;
    sub_1002D5F00((uint64_t)v20, v9 + 8);
    sub_1002D5F00((uint64_t)v21, v9 + 72);
    sub_1002D606C((uint64_t)v22, v9 + 136);
    sub_1002D606C((uint64_t)v23, v9 + 248);
    double v24 = *(double *)(v9 + 360);
    int v25 = *(_DWORD *)(v9 + 368);
    for (uint64_t i = v10; ; i -= 376LL)
    {
      uint64_t v15 = a1 + i;
      *(_BYTE *)(a1 + i + 112_Block_object_dispose((const void *)(v1 - 112), 8) = *(_BYTE *)(a1 + i + 752);
      sub_1002CBDC8(a1 + i + 1136, a1 + i + 760);
      sub_1002CBDC8(v15 + 1200, v15 + 824);
      sub_1002CBDC8(v15 + 1264, v15 + 888);
      sub_1002CBDC8(v15 + 1376, v15 + 1000);
      *(void *)(v15 + 148_Block_object_dispose((const void *)(v1 - 112), 8) = *(void *)(v15 + 1112);
      *(_DWORD *)(v15 + 1496) = *(_DWORD *)(v15 + 1120);
      if (i == -752) {
        break;
      }
      int v16 = *(_DWORD *)(v15 + 744);
      if (v25 >= v16)
      {
        if (v25 > v16)
        {
          uint64_t v8 = a1 + i + 752;
          goto LABEL_19;
        }
      }

      v8 -= 376LL;
    }

    uint64_t v8 = a1;
LABEL_19:
    *(_BYTE *)uint64_t v8 = v19;
    sub_1002CBDC8(a1 + i + 760, (uint64_t)v20);
    sub_1002CBDC8(v15 + 824, (uint64_t)v21);
    sub_1002CBDC8(v15 + 888, (uint64_t)v22);
    sub_1002CBDC8(v15 + 1000, (uint64_t)v23);
    *(double *)(v15 + 1112) = v24;
    *(_DWORD *)(v15 + 1120) = v25;
    int v11 = v18 + 1;
    if (v18 == 7) {
      return v9 + 376 == v17;
    }
    uint64_t v2 = v17;
LABEL_21:
    uint64_t v8 = v9;
    v10 += 376LL;
    v9 += 376LL;
    if (v9 == v2) {
      return 1LL;
    }
  }

double sub_1002F144C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  double result = sub_1002F101C(a1, a2, a3);
  int v9 = *(_DWORD *)(a4 + 368);
  int v10 = *(_DWORD *)(a3 + 368);
  if (v9 < v10 || v9 <= v10 && (double result = *(double *)(a4 + 360), result < *(double *)(a3 + 360)))
  {
    sub_1002EF9DC((char *)a3, (char *)a4);
    int v11 = *(_DWORD *)(a3 + 368);
    int v12 = *(_DWORD *)(a2 + 368);
    if (v11 < v12 || v11 <= v12 && (double result = *(double *)(a3 + 360), result < *(double *)(a2 + 360)))
    {
      sub_1002EF9DC((char *)a2, (char *)a3);
      int v13 = *(_DWORD *)(a2 + 368);
      int v14 = *(_DWORD *)(a1 + 368);
    }
  }

  return result;
}

uint64_t sub_1002F1520( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, double *a6, int *a7, uint64_t a8)
{
  uint64_t v13 = *(void *)(a1 + 8);
  double v14 = *a6;
  int v15 = *a7;
  sub_1002D5F00((uint64_t)v17, a8);
  uint64_t result = sub_1002F1740(v13, a2, a3, a4, a5, v15, (uint64_t)v17, v14);
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v13 + 432;
  return result;
}

void sub_1002F15B8(_Unwind_Exception *a1)
{
  *(void *)(v1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_1002F15C0( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, double *a6, int *a7, uint64_t a8)
{
  uint64_t v9 = *a1;
  unint64_t v10 = 0x84BDA12F684BDA13LL * ((a1[1] - *a1) >> 4);
  unint64_t v11 = v10 + 1;
  if (v10 + 1 > 0x97B425ED097B42LL) {
    sub_10001E11C();
  }
  uint64_t v19 = (uint64_t)(a1 + 2);
  unint64_t v20 = 0x84BDA12F684BDA13LL * ((a1[2] - v9) >> 4);
  if (2 * v20 > v11) {
    unint64_t v11 = 2 * v20;
  }
  if (v20 >= 0x4BDA12F684BDA1LL) {
    unint64_t v21 = 0x97B425ED097B42LL;
  }
  else {
    unint64_t v21 = v11;
  }
  int v31 = a1 + 2;
  if (v21) {
    uint64_t v22 = (char *)sub_1002F1894(v19, v21);
  }
  else {
    uint64_t v22 = 0LL;
  }
  int v27 = v22;
  double v28 = &v22[432 * v10];
  uint64_t v29 = (uint64_t)v28;
  unsigned int v30 = &v22[432 * v21];
  double v23 = *a6;
  int v24 = *a7;
  sub_1002D5F00((uint64_t)v32, a8);
  sub_1002F1740((uint64_t)v28, a2, a3, a4, a5, v24, (uint64_t)v32, v23);
  uint64_t v29 = (uint64_t)(v28 + 432);
  sub_1002F1820(a1, &v27);
  uint64_t v25 = a1[1];
  sub_1002F1A34((uint64_t)&v27);
  return v25;
}

void sub_1002F172C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_1002F1740( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, double a8)
{
  *(double *)(a1 + 352) = a8;
  *(_DWORD *)(a1 + 360) = a6;
  sub_1002D5F00(a1 + 368, a7);
  return a1;
}

void sub_1002F17E0(_Unwind_Exception *a1)
{
  *uint64_t v4 = off_1007AED90;
  *uint64_t v3 = off_1007AED90;
  void *v2 = off_1007AED90;
  void *v1 = off_1007AED90;
  _Unwind_Resume(a1);
}

uint64_t sub_1002F1820(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1002F18DC((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_1002F1894(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x97B425ED097B43LL) {
    sub_10001D350();
  }
  return operator new(432 * a2);
}

uint64_t sub_1002F18DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  for (uint64_t i = 0LL; a3 + i != a5; sub_1002F196C(a1, i + a7, i + a3))
    i -= 432LL;
  return a6;
}

double sub_1002F196C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a3 + 352);
  *(_DWORD *)(a2 + 360) = *(_DWORD *)(a3 + 360);
  *(void *)(a2 + 352) = v5;
  *(void *)&double result = sub_1002D5F00(a2 + 368, a3 + 368).n128_u64[0];
  return result;
}

void sub_1002F19F4(_Unwind_Exception *a1)
{
  *uint64_t v4 = off_1007AED90;
  *uint64_t v3 = off_1007AED90;
  void *v2 = off_1007AED90;
  void *v1 = off_1007AED90;
  _Unwind_Resume(a1);
}

uint64_t sub_1002F1A34(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
  uint64_t v3 = *(void **)(a1 + 16);
  if (v3 != v2)
  {
    uint64_t v4 = v3 - 24;
    do
    {
      uint8_t v4[16] = off_1007AED90;
      *uint64_t v4 = off_1007AED90;
      *(v4 - 14) = off_1007AED90;
      *(v4 - 22) = off_1007AED90;
      *(v4 - 30) = off_1007AED90;
      BOOL v5 = v4 - 30 == v2;
      v4 -= 54;
    }

    while (!v5);
    *(void *)(a1 + 16) = v2;
  }

  uint64_t v6 = *(void **)a1;
  if (*(void *)a1) {
    operator delete(v6);
  }
  return a1;
}

uint64_t sub_1002F1AA0(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1002F1B14((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1002F1B14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = 0LL;
  uint64_t v12 = a7 - 192;
  while (a3 + v11 != a5)
  {
    uint64_t v13 = (_OWORD *)(v12 + v11);
    v11 -= 192LL;
    sub_1002F1BB8(a1, v13, (_OWORD *)(v11 + a3));
  }

  return a6;
}

double sub_1002F1BB8(uint64_t a1, _OWORD *a2, _OWORD *a3)
{
  *a2 = *a3;
  sub_1002F1C14((uint64_t)(a2 + 1), (uint64_t)(a3 + 1));
  *(void *)&double result = sub_1002F1D80((uint64_t)a2 + 104, (uint64_t)a3 + 104).n128_u64[0];
  return result;
}

void sub_1002F1C04(_Unwind_Exception *a1)
{
  void *v1 = off_1007AED90;
  _Unwind_Resume(a1);
}

__n128 sub_1002F1C14(uint64_t a1, uint64_t a2)
{
  result.n128_u64[0] = 0x300000002LL;
  *(void *)(a1 + 24) = 0x300000002LL;
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = &off_1007BD1E8;
  if (a1 == a2)
  {
    int v16 = "this != &(A)";
    int v17 = 603;
LABEL_21:
    int v18 = "cnmatrix.h";
    uint64_t v19 = "CNMatrix";
LABEL_22:
    __assert_rtn(v19, v18, v17, v16);
  }

  unsigned int v3 = *(_DWORD *)(a2 + 8);
  if (v3 > 2)
  {
    int v16 = "this->max_num_rows_ >= num_rows";
    int v17 = 422;
LABEL_18:
    int v18 = "cnmatrixbase.h";
    uint64_t v19 = "SetMatrixSize";
    goto LABEL_22;
  }

  unsigned int v4 = *(_DWORD *)(a2 + 12);
  if (v4 >= 4)
  {
    int v16 = "this->max_num_cols_ >= num_cols";
    int v17 = 423;
    goto LABEL_18;
  }

  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v3;
  *(_DWORD *)(a1 + 12) = v4;
  uint64_t v5 = v4 * v3;
  *(_DWORD *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 20) = v3;
  uint64_t v6 = (_OWORD *)(a1 + 40);
  *(void *)(a1 + 32) = a1 + 40;
  if (*(_DWORD *)(a2 + 8) > 2u)
  {
    int v16 = "this->max_num_rows_ >= A.num_rows_";
    int v17 = 616;
    goto LABEL_21;
  }

  if (*(_DWORD *)(a2 + 12) > 3u)
  {
    int v16 = "this->max_num_cols_ >= A.num_cols_";
    int v17 = 617;
    goto LABEL_21;
  }

  int v7 = *(_DWORD *)(a2 + 16);
  if (v7 > 3)
  {
    uint64_t v10 = (v7 - 2);
    uint64_t v11 = *(__int128 **)(a2 + 32);
    uint64_t v12 = (__n128 *)((char *)v6 + 8 * v10);
    uint64_t v13 = (v7 - 1) >> 1;
    double v14 = v11;
    do
    {
      __int128 v15 = *v14++;
      *v6++ = v15;
      --v13;
    }

    while (v13);
    __n128 result = *(__n128 *)((char *)v11 + 8 * v10);
    __n128 *v12 = result;
  }

  else if ((_DWORD)v5)
  {
    uint64_t v8 = *(unint64_t **)(a2 + 32);
    do
    {
      unint64_t v9 = *v8++;
      result.n128_u64[0] = v9;
      *(void *)uint64_t v6 = v9;
      uint64_t v6 = (_OWORD *)((char *)v6 + 8);
      --v5;
    }

    while (v5);
  }

  return result;
}

void sub_1002F1D70(_Unwind_Exception *a1)
{
  void *v1 = off_1007AED90;
  _Unwind_Resume(a1);
}

__n128 sub_1002F1D80(uint64_t a1, uint64_t a2)
{
  result.n128_u64[0] = 0x200000003LL;
  *(void *)(a1 + 24) = 0x200000003LL;
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = &off_1007BD230;
  if (a1 == a2)
  {
    int v16 = "this != &(A)";
    int v17 = 603;
LABEL_21:
    int v18 = "cnmatrix.h";
    uint64_t v19 = "CNMatrix";
LABEL_22:
    __assert_rtn(v19, v18, v17, v16);
  }

  unsigned int v3 = *(_DWORD *)(a2 + 8);
  if (v3 > 3)
  {
    int v16 = "this->max_num_rows_ >= num_rows";
    int v17 = 422;
LABEL_18:
    int v18 = "cnmatrixbase.h";
    uint64_t v19 = "SetMatrixSize";
    goto LABEL_22;
  }

  unsigned int v4 = *(_DWORD *)(a2 + 12);
  if (v4 >= 3)
  {
    int v16 = "this->max_num_cols_ >= num_cols";
    int v17 = 423;
    goto LABEL_18;
  }

  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v3;
  *(_DWORD *)(a1 + 12) = v4;
  uint64_t v5 = v4 * v3;
  *(_DWORD *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 20) = v3;
  uint64_t v6 = (_OWORD *)(a1 + 40);
  *(void *)(a1 + 32) = a1 + 40;
  if (*(_DWORD *)(a2 + 8) > 3u)
  {
    int v16 = "this->max_num_rows_ >= A.num_rows_";
    int v17 = 616;
    goto LABEL_21;
  }

  if (*(_DWORD *)(a2 + 12) > 2u)
  {
    int v16 = "this->max_num_cols_ >= A.num_cols_";
    int v17 = 617;
    goto LABEL_21;
  }

  int v7 = *(_DWORD *)(a2 + 16);
  if (v7 > 3)
  {
    uint64_t v10 = (v7 - 2);
    uint64_t v11 = *(__int128 **)(a2 + 32);
    uint64_t v12 = (__n128 *)((char *)v6 + 8 * v10);
    uint64_t v13 = (v7 - 1) >> 1;
    double v14 = v11;
    do
    {
      __int128 v15 = *v14++;
      *v6++ = v15;
      --v13;
    }

    while (v13);
    __n128 result = *(__n128 *)((char *)v11 + 8 * v10);
    __n128 *v12 = result;
  }

  else if ((_DWORD)v5)
  {
    uint64_t v8 = *(unint64_t **)(a2 + 32);
    do
    {
      unint64_t v9 = *v8++;
      result.n128_u64[0] = v9;
      *(void *)uint64_t v6 = v9;
      uint64_t v6 = (_OWORD *)((char *)v6 + 8);
      --v5;
    }

    while (v5);
  }

  return result;
}

void sub_1002F1EDC(_Unwind_Exception *a1)
{
  void *v1 = off_1007AED90;
  _Unwind_Resume(a1);
}

uint64_t sub_1002F1EEC(uint64_t *a1, double *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *a1;
  unint64_t v6 = 0xF0F0F0F0F0F0F0F1LL * ((a1[1] - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0x1E1E1E1E1E1E1E1LL) {
    sub_10001E11C();
  }
  uint64_t v11 = (uint64_t)(a1 + 2);
  unint64_t v12 = 0xF0F0F0F0F0F0F0F1LL * ((a1[2] - v5) >> 3);
  if (2 * v12 > v7) {
    unint64_t v7 = 2 * v12;
  }
  if (v12 >= 0xF0F0F0F0F0F0F0LL) {
    unint64_t v13 = 0x1E1E1E1E1E1E1E1LL;
  }
  else {
    unint64_t v13 = v7;
  }
  double v23 = a1 + 2;
  if (v13) {
    double v14 = (char *)sub_1002EDD90(v11, v13);
  }
  else {
    double v14 = 0LL;
  }
  stat __p = v14;
  unint64_t v20 = (double *)&v14[136 * v6];
  unint64_t v21 = v20;
  uint64_t v22 = &v14[136 * v13];
  sub_1002F2070(v20, a3, a4, *a2);
  unint64_t v21 = v20 + 17;
  sub_1002EDD1C(a1, &__p);
  uint64_t v15 = a1[1];
  int v16 = v20;
  int v17 = v21;
  if (v21 != v20)
  {
    do
    {
      *((void *)v17 - _Block_object_dispose((const void *)(v1 - 112), 8) = off_1007AED90;
      *((void *)v17 - 16) = off_1007AED90;
      v17 -= 17;
    }

    while (v17 != v16);
    unint64_t v21 = v16;
  }

  if (__p) {
    operator delete(__p);
  }
  return v15;
}

double *sub_1002F2070(double *a1, uint64_t a2, uint64_t a3, double a4)
{
  *a1 = a4;
  uint64_t v6 = (uint64_t)(a1 + 9);
  sub_1002EDED4((uint64_t)(a1 + 1), a2);
  sub_1002D5F00(v6, a3);
  return a1;
}

void sub_1002F20BC(_Unwind_Exception *a1)
{
  void *v1 = off_1007AED90;
  _Unwind_Resume(a1);
}

uint64_t sub_1002F20CC(uint64_t *a1, double *a2, double *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = *a1;
  unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 6);
  unint64_t v8 = v7 + 1;
  if (v7 + 1 > 0x155555555555555LL) {
    sub_10001E11C();
  }
  uint64_t v13 = (uint64_t)(a1 + 2);
  unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v6) >> 6);
  if (2 * v14 > v8) {
    unint64_t v8 = 2 * v14;
  }
  if (v14 >= 0xAAAAAAAAAAAAAALL) {
    unint64_t v15 = 0x155555555555555LL;
  }
  else {
    unint64_t v15 = v8;
  }
  uint64_t v25 = a1 + 2;
  if (v15) {
    int v16 = (char *)sub_1002D5D84(v13, v15);
  }
  else {
    int v16 = 0LL;
  }
  stat __p = v16;
  uint64_t v22 = (double *)&v16[192 * v7];
  double v23 = v22;
  int v24 = &v16[192 * v15];
  sub_1002F2258(v22, a4, a5, *a2, *a3);
  double v23 = v22 + 24;
  sub_1002F1AA0(a1, &__p);
  uint64_t v17 = a1[1];
  int v18 = v22;
  uint64_t v19 = v23;
  if (v23 != v22)
  {
    do
    {
      *((void *)v19 - 11) = off_1007AED90;
      *((void *)v19 - 22) = off_1007AED90;
      v19 -= 24;
    }

    while (v19 != v18);
    double v23 = v18;
  }

  if (__p) {
    operator delete(__p);
  }
  return v17;
}

double *sub_1002F2258(double *a1, uint64_t a2, uint64_t a3, double a4, double a5)
{
  *a1 = a4;
  a1[1] = a5;
  sub_1002F1C14((uint64_t)(a1 + 2), a2);
  sub_1002F1D80((uint64_t)(a1 + 13), a3);
  return a1;
}

void sub_1002F22A0(_Unwind_Exception *a1)
{
  void *v1 = off_1007AED90;
  _Unwind_Resume(a1);
}

uint64_t sub_1002F22B0(uint64_t *a1, _OWORD *a2)
{
  uint64_t v3 = 0x4EC4EC4EC4EC4EC5LL * ((a1[1] - *a1) >> 4);
  unint64_t v4 = v3 + 1;
  if (0x9D89D89D89D89D8ALL * ((a1[2] - *a1) >> 4) > v4) {
    unint64_t v4 = 0x9D89D89D89D89D8ALL * ((a1[2] - *a1) >> 4);
  }
  else {
    unint64_t v6 = v4;
  }
  int v16 = a1 + 2;
  if (v6) {
    unint64_t v7 = (char *)sub_1002F250C((uint64_t)(a1 + 2), v6);
  }
  else {
    unint64_t v7 = 0LL;
  }
  stat __p = v7;
  uint64_t v13 = &v7[208 * v3];
  unint64_t v15 = &v7[208 * v6];
  sub_1002F243C((uint64_t)(a1 + 2), v13, a2);
  unint64_t v14 = v13 + 208;
  sub_1002F2498(a1, &__p);
  uint64_t v8 = a1[1];
  unint64_t v9 = v13;
  uint64_t v10 = v14;
  if (v14 != v13)
  {
    do
    {
      *((void *)v10 - 14) = off_1007AED90;
      *((void *)v10 - 22) = off_1007AED90;
      v10 -= 208;
    }

    while (v10 != v9);
    unint64_t v14 = v9;
  }

  if (__p) {
    operator delete(__p);
  }
  return v8;
}

double sub_1002F243C(uint64_t a1, _OWORD *a2, _OWORD *a3)
{
  __int128 v5 = a3[1];
  *a2 = *a3;
  a2[1] = v5;
  sub_1002D5F00((uint64_t)(a2 + 2), (uint64_t)(a3 + 2));
  *(void *)&double result = sub_1002D606C((uint64_t)(a2 + 6), (uint64_t)(a3 + 6)).n128_u64[0];
  return result;
}

void sub_1002F2488(_Unwind_Exception *a1)
{
  void *v1 = off_1007AED90;
  _Unwind_Resume(a1);
}

uint64_t sub_1002F2498(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1002F2554((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_1002F250C(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x13B13B13B13B13CLL) {
    sub_10001D350();
  }
  return operator new(208 * a2);
}

uint64_t sub_1002F2554(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = 0LL;
  uint64_t v12 = a7 - 208;
  while (a3 + v11 != a5)
  {
    uint64_t v13 = (_OWORD *)(v12 + v11);
    v11 -= 208LL;
    sub_1002F243C(a1, v13, (_OWORD *)(v11 + a3));
  }

  return a6;
}

uint64_t sub_1002F25F8()
{
  qword_1007FEC80 = 0LL;
  qword_1007FEC88 = 0LL;
  qword_1007FEC90 = 0LL;
  uint64_t v0 = operator new(0x40uLL);
  qword_1007FEC88 = (uint64_t)(v0 + 4);
  qword_1007FEC90 = (uint64_t)(v0 + 4);
  _OWORD *v0 = xmmword_10042E8B8;
  v0[1] = unk_10042E8C8;
  v0[2] = xmmword_10042E8D8;
  v0[3] = unk_10042E8E8;
  qword_1007FEC80 = (uint64_t)v0;
  __cxa_atexit((void (*)(void *))sub_100028CC4, &qword_1007FEC80, (void *)&_mh_execute_header);
  qword_1007FECA0 = 0LL;
  unk_1007FECA8 = 0LL;
  qword_1007FEC98 = 0LL;
  uint64_t v1 = operator new(0x10uLL);
  qword_1007FECA0 = (uint64_t)(v1 + 1);
  unk_1007FECA8 = v1 + 1;
  _OWORD *v1 = xmmword_10042E8F8;
  qword_1007FEC98 = (uint64_t)v1;
  return __cxa_atexit((void (*)(void *))sub_100028CC4, &qword_1007FEC98, (void *)&_mh_execute_header);
}

uint64_t sub_1002F26B4(uint64_t a1)
{
  *(_BYTE *)a1 = 0;
  *(_BYTE *)(a1 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 144) = 0;
  *(_BYTE *)(a1 + 272) = 0;
  sub_10030C724(a1 + 304);
  *(_BYTE *)(a1 + 84_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 864) = 0;
  *(_BYTE *)(a1 + 992) = 0;
  *(_BYTE *)(a1 + 100_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 1024) = 0;
  *(_OWORD *)(a1 + 672) = 0u;
  *(_OWORD *)(a1 + 68_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_OWORD *)(a1 + 704) = 0u;
  *(_BYTE *)(a1 + 720) = 0;
  *(_OWORD *)(a1 + 1040) = xmmword_10042E980;
  *(void *)(a1 + 1056) = 0x3FF47AE147AE147BLL;
  *(_OWORD *)(a1 + 28_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  return a1;
}

uint64_t sub_1002F2734@<X0>( float32x4_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>, double a5@<D1>)
{
  unint64_t v9 = (float64x2_t *)(a3 + 408);
  uint64_t v10 = (uint64_t)&a1[19];
  sub_10030CB34((uint64_t)&a1[19], a2, (uint64_t)&v126, a4);
  sub_1002CDE54((uint64_t)&a1[42], (uint64_t)&v126, (uint64_t)v124, a5);
  __int128 v76 = *(_OWORD *)&v124[32];
  int8x16_t v77 = *(int8x16_t *)&v124[48];
  uint64_t v11 = *(void *)&v124[64];
  if (!v127) {
    goto LABEL_17;
  }
  __int128 v74 = *(_OWORD *)v124;
  int v12 = v124[16];
  uint64_t result = sub_10030C71C(v10);
  if ((_DWORD)result == 4)
  {
    if (v127)
    {
      int v71 = v12;
      float32x4_t v14 = vaddq_f32(v126, a1[18]);
      a1[18] = v14;
      HIDWORD(v15) = 0;
      *(float *)&__int128 v15 = (float)((float)((float)(*(float *)v131.i32 * *(float *)v131.i32)
                                     - (float)(*(float *)&v131.i32[1] * *(float *)&v131.i32[1]))
      HIDWORD(v16) = 0;
      *((float *)&v15 + 1) = (float)((float)(*(float *)&v131.i32[2] * *(float *)&v131.i32[3])
                                   + (float)(*(float *)v131.i32 * *(float *)&v131.i32[1]))
      *((float *)&v15 + 2) = (float)-(float)((float)(*(float *)&v131.i32[1] * *(float *)&v131.i32[3])
                                           - (float)(*(float *)v131.i32 * *(float *)&v131.i32[2]))
      HIDWORD(v17) = 0;
      *(float *)&__int128 v17 = (float)-(float)((float)(*(float *)&v131.i32[2] * *(float *)&v131.i32[3])
                                     - (float)(*(float *)v131.i32 * *(float *)&v131.i32[1]))
      *((float *)&v17 + 1) = (float)((float)((float)(*(float *)&v131.i32[1] * *(float *)&v131.i32[1])
                                           - (float)(*(float *)&v131.i32[2] * *(float *)&v131.i32[2]))
      *((float *)&v17 + 2) = (float)((float)(*(float *)v131.i32 * *(float *)&v131.i32[3])
                                   + (float)(*(float *)&v131.i32[1] * *(float *)&v131.i32[2]))
      *(float *)&__int128 v16 = (float)((float)(*(float *)&v131.i32[1] * *(float *)&v131.i32[3])
                             + (float)(*(float *)&v131.i32[2] * *(float *)v131.i32))
      *((float *)&v16 + 1) = (float)-(float)((float)(*(float *)v131.i32 * *(float *)&v131.i32[3])
                                           - (float)(*(float *)&v131.i32[1] * *(float *)&v131.i32[2]))
      *((float *)&v16 + 2) = (float)((float)((float)(*(float *)&v131.i32[3] * *(float *)&v131.i32[3])
                                           + (float)(*(float *)&v131.i32[2] * *(float *)&v131.i32[2]))
      v14.i32[3] = 1.0;
      *(void *)uint64_t v124 = v132;
      *(_OWORD *)&v124[16] = v15;
      *(_OWORD *)&v124[32] = v17;
      *(_OWORD *)&v124[48] = v16;
      *(float32x4_t *)&v124[64] = v14;
      *(_DWORD *)&v124[80] = 2;
      *(_WORD *)&v124[84] = 0;
      v124[88] = 0;
      v124[96] = 0;
      v125[15] = 0;
      v125[19] = 0;
      *(_DWORD *)&v125[7] = 1;
      v125[11] = 1;
      sub_1002CE058((uint64_t)&a1[42], (__int128 *)v124, (double *)v122, a5);
      __int128 v118 = *(_OWORD *)&v122[49];
      __int128 v117 = *(_OWORD *)&v122[33];
      __int128 v116 = *(_OWORD *)&v122[17];
      __int128 v114 = *(_OWORD *)&v122[1];
      *(_OWORD *)&v121[15] = *(_OWORD *)&v123[15];
      __int128 v120 = *(_OWORD *)&v122[81];
      *(_OWORD *)int v121 = *(_OWORD *)v123;
      __int128 v119 = *(_OWORD *)&v122[65];
      __int128 v110 = *(_OWORD *)&v124[49];
      __int128 v109 = *(_OWORD *)&v124[33];
      __int128 v108 = *(_OWORD *)&v124[17];
      __int128 v106 = *(_OWORD *)&v124[1];
      *(_OWORD *)&v113[15] = *(_OWORD *)&v125[15];
      *(_OWORD *)int v113 = *(_OWORD *)v125;
      __int128 v112 = *(_OWORD *)&v124[81];
      __int128 v111 = *(_OWORD *)&v124[65];
      if (v127)
      {
        char v18 = *(_BYTE *)(a2 + 32);
        if (v18)
        {
          char v19 = *(_BYTE *)(a2 + 48);
          if (v19)
          {
            char v20 = *(_BYTE *)(a2 + 64);
            if (v20)
            {
              if (*(_BYTE *)(a2 + 80))
              {
                if (*(_BYTE *)(a2 + 96))
                {
                  if (*(_BYTE *)(a2 + 112))
                  {
                    char v57 = v124[0];
                    char v58 = v122[0];
                    char v65 = *(_BYTE *)(a2 + 80);
                    char v67 = *(_BYTE *)(a2 + 96);
                    char v69 = *(_BYTE *)(a2 + 112);
                    uint64_t v21 = *(void *)a2;
                    char v59 = *(_BYTE *)(a2 + 8);
                    char v61 = *(_BYTE *)(a2 + 16);
                    uint64_t v22 = (_DWORD *)(a2 + 17);
                    double v23 = (_DWORD *)(a2 + 33);
                    int v24 = (_DWORD *)(a2 + 49);
                    uint64_t v25 = (_DWORD *)(a2 + 65);
                    double v26 = (_DWORD *)(a2 + 81);
                    int v27 = (_DWORD *)(a2 + 97);
                    double v28 = (_DWORD *)(a2 + 113);
                    uint64_t v29 = (_DWORD *)(a2 + 153);
                    int8x16_t v63 = v131;
                    *(_DWORD *)int v87 = *(_DWORD *)(a2 + 9);
                    *(_DWORD *)&v87[3] = *(_DWORD *)(a2 + 12);
                    *(_DWORD *)uint64_t v86 = *(_DWORD *)(a2 + 17);
                    *(_DWORD *)&v86[3] = *(_DWORD *)(a2 + 20);
                    *(_DWORD *)int v85 = *(_DWORD *)(a2 + 33);
                    *(_DWORD *)&v85[3] = *(_DWORD *)(a2 + 36);
                    *(_DWORD *)&v84[3] = *(_DWORD *)(a2 + 52);
                    *(_DWORD *)uint64_t v84 = *(_DWORD *)(a2 + 49);
                    *(_DWORD *)&v83[3] = *(_DWORD *)(a2 + 68);
                    *(_DWORD *)uint64_t v83 = *(_DWORD *)(a2 + 65);
                    *(_DWORD *)uint64_t v82 = *(_DWORD *)(a2 + 81);
                    *(_DWORD *)&v82[3] = *(_DWORD *)(a2 + 84);
                    *(_DWORD *)uint64_t v81 = *(_DWORD *)(a2 + 97);
                    *(_DWORD *)&v81[3] = *(_DWORD *)(a2 + 100);
                    *(_DWORD *)uint64_t v80 = *(_DWORD *)(a2 + 113);
                    *(_DWORD *)&v80[3] = *(_DWORD *)(a2 + 116);
                    *(_DWORD *)&v79[3] = *(_DWORD *)(a2 + 156);
                    *(_DWORD *)double v79 = *(_DWORD *)(a2 + 153);
                    if (v71)
                    {
                      double v30 = v126.f32[1];
                      *(_DWORD *)int v101 = *(_DWORD *)(a2 + 9);
                      double v52 = v126.f32[2];
                      double v54 = v128;
                      *(_DWORD *)&v101[3] = *(_DWORD *)(a2 + 12);
                      double v55 = v129;
                      double v56 = v126.f32[0];
                      *(_DWORD *)int v99 = *v22;
                      double v72 = v130;
                      else {
                        char v31 = *(_BYTE *)(a2 + 152);
                      }
                      *(_DWORD *)&v99[3] = *(_DWORD *)((char *)v22 + 3);
                      LODWORD(v97) = *v23;
                      *(_DWORD *)((char *)&v97 + 3) = *(_DWORD *)((char *)v23 + 3);
                      *(_DWORD *)((char *)&v95 + 3) = *(_DWORD *)((char *)v24 + 3);
                      LODWORD(v95) = *v24;
                      *(_DWORD *)((char *)&v93 + 3) = *(_DWORD *)((char *)v25 + 3);
                      LODWORD(v93) = *v25;
                      LODWORD(v91) = *v26;
                      *(_DWORD *)((char *)&v91 + 3) = *(_DWORD *)((char *)v26 + 3);
                      LODWORD(v90) = *v27;
                      *(_DWORD *)((char *)&v90 + 3) = *(_DWORD *)((char *)v27 + 3);
                      LODWORD(v89) = *v28;
                      *(_DWORD *)((char *)&v89 + 3) = *(_DWORD *)((char *)v28 + 3);
                      *(_DWORD *)((char *)&v88 + 3) = *(_DWORD *)((char *)v29 + 3);
                      LODWORD(v8_Block_object_dispose((const void *)(v1 - 112), 8) = *v29;
                      uint64_t result = sub_10030C71C(v10);
                      *(_OWORD *)(a3 + 65) = v119;
                      *(_OWORD *)(a3 + 81) = v120;
                      *(_OWORD *)(a3 + 97) = *(_OWORD *)v121;
                      *(_OWORD *)(a3 + 112) = *(_OWORD *)&v121[15];
                      *(_OWORD *)(a3 + 1) = v114;
                      *(_OWORD *)(a3 + 17) = v116;
                      *(_OWORD *)(a3 + 33) = v117;
                      *(_BYTE *)a3 = v58;
                      *(_OWORD *)(a3 + 49) = v118;
                      *(_BYTE *)(a3 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
                      *(_BYTE *)(a3 + 144) = v57;
                      *(_OWORD *)(a3 + 209) = v111;
                      *(_OWORD *)(a3 + 225) = v112;
                      *(_OWORD *)(a3 + 241) = *(_OWORD *)v113;
                      *(_OWORD *)(a3 + 256) = *(_OWORD *)&v113[15];
                      *(_OWORD *)(a3 + 145) = v106;
                      *(_OWORD *)(a3 + 161) = v108;
                      *(_OWORD *)(a3 + 177) = v109;
                      *(_OWORD *)(a3 + 193) = v110;
                      *(_BYTE *)(a3 + 272) = 1;
                      *(void *)(a3 + 28_Block_object_dispose((const void *)(v1 - 112), 8) = v21;
                      *(_BYTE *)(a3 + 296) = v59;
                      *(_DWORD *)(a3 + 300) = *(_DWORD *)&v101[3];
                      *(_DWORD *)(a3 + 297) = *(_DWORD *)v101;
                      *(_BYTE *)(a3 + 304) = v61;
                      *(_DWORD *)(a3 + 30_Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)&v99[3];
                      *(_DWORD *)(a3 + 305) = *(_DWORD *)v99;
                      *(double *)(a3 + 312) = *(float *)&v74;
                      *(_BYTE *)(a3 + 320) = v18;
                      *(_DWORD *)(a3 + 324) = *(_DWORD *)((char *)&v97 + 3);
                      *(_DWORD *)(a3 + 321) = v97;
                      *(double *)(a3 + 32_Block_object_dispose((const void *)(v1 - 112), 8) = *((float *)&v74 + 1);
                      *(_BYTE *)(a3 + 336) = v19;
                      *(_DWORD *)(a3 + 340) = *(_DWORD *)((char *)&v95 + 3);
                      *(_DWORD *)(a3 + 337) = v95;
                      *(double *)(a3 + 344) = *((float *)&v74 + 2);
                      *(_BYTE *)(a3 + 352) = v20;
                      *(_DWORD *)(a3 + 356) = *(_DWORD *)((char *)&v93 + 3);
                      *(_DWORD *)(a3 + 353) = v93;
                      *(double *)(a3 + 360) = *(float *)&v76;
                      *(_BYTE *)(a3 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = v65;
                      *(_DWORD *)(a3 + 372) = *(_DWORD *)((char *)&v91 + 3);
                      *(_DWORD *)(a3 + 369) = v91;
                      *(double *)(a3 + 376) = *((float *)&v76 + 1);
                      *(_BYTE *)(a3 + 384) = v67;
                      *(_DWORD *)(a3 + 38_Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)((char *)&v90 + 3);
                      *(_DWORD *)(a3 + 385) = v90;
                      *(double *)(a3 + 392) = *((float *)&v76 + 2);
                      *(_BYTE *)(a3 + 400) = v69;
                      *(_DWORD *)(a3 + 404) = *(_DWORD *)((char *)&v89 + 3);
                      *(_DWORD *)(a3 + 401) = v89;
                      float64x2_t *v9 = vcvtq_f64_f32((float32x2_t)*(_OWORD *)&vextq_s8(v77, v77, 0xCuLL));
                      v9[1] = vcvtq_f64_f32((float32x2_t)*(_OWORD *)&vextq_s8(v77, v77, 4uLL));
                      *(_BYTE *)(a3 + 440) = v31;
                      *(_DWORD *)(a3 + 444) = *(_DWORD *)((char *)&v88 + 3);
                      *(_DWORD *)(a3 + 441) = v88;
                      *(void *)(a3 + 44_Block_object_dispose((const void *)(v1 - 112), 8) = v21;
                      *(_BYTE *)(a3 + 456) = v59;
                      *(_DWORD *)(a3 + 460) = *(_DWORD *)&v87[3];
                      *(_DWORD *)(a3 + 457) = *(_DWORD *)v87;
                      *(_BYTE *)(a3 + 464) = v61;
                      *(_DWORD *)(a3 + 46_Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)&v86[3];
                      *(_DWORD *)(a3 + 465) = *(_DWORD *)v86;
                      *(double *)(a3 + 472) = v56;
                      *(_BYTE *)(a3 + 480) = v18;
                      *(_DWORD *)(a3 + 484) = *(_DWORD *)&v85[3];
                      *(_DWORD *)(a3 + 481) = *(_DWORD *)v85;
                      *(double *)(a3 + 48_Block_object_dispose((const void *)(v1 - 112), 8) = v30;
                      *(_BYTE *)(a3 + 496) = v19;
                      *(_DWORD *)(a3 + 500) = *(_DWORD *)&v84[3];
                      *(_DWORD *)(a3 + 497) = *(_DWORD *)v84;
                      *(double *)(a3 + 504) = v52;
                      *(_BYTE *)(a3 + 512) = v20;
                      *(_DWORD *)(a3 + 516) = *(_DWORD *)&v83[3];
                      *(_DWORD *)(a3 + 513) = *(_DWORD *)v83;
                      *(double *)(a3 + 520) = v54;
                      *(_BYTE *)(a3 + 52_Block_object_dispose((const void *)(v1 - 112), 8) = v65;
                      *(_DWORD *)(a3 + 532) = *(_DWORD *)&v82[3];
                      *(_DWORD *)(a3 + 529) = *(_DWORD *)v82;
                      *(double *)(a3 + 536) = v55;
                      *(_BYTE *)(a3 + 544) = v67;
                      *(_DWORD *)(a3 + 54_Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)&v81[3];
                      *(_DWORD *)(a3 + 545) = *(_DWORD *)v81;
                      *(double *)(a3 + 552) = v72;
                      *(_BYTE *)(a3 + 560) = v69;
                      *(_DWORD *)(a3 + 564) = *(_DWORD *)&v80[3];
                      *(_DWORD *)(a3 + 561) = *(_DWORD *)v80;
                      v9[10] = vcvtq_f64_f32((float32x2_t)*(_OWORD *)&vextq_s8(v63, v63, 0xCuLL));
                      v9[11] = vcvtq_f64_f32((float32x2_t)*(_OWORD *)&vextq_s8(v63, v63, 4uLL));
                      *(_BYTE *)(a3 + 600) = v31;
                      *(_DWORD *)(a3 + 604) = *(_DWORD *)&v79[3];
                      *(_DWORD *)(a3 + 601) = *(_DWORD *)v79;
                      *(_DWORD *)(a3 + 60_Block_object_dispose((const void *)(v1 - 112), 8) = result;
                      *(_DWORD *)(a3 + 620) = v105;
                      *(void *)(a3 + 612) = v103;
LABEL_24:
                      *(_BYTE *)(a3 + 624) = 1;
                      return result;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    goto LABEL_26;
  }

  if (!v127)
  {
LABEL_17:
    uint64_t result = sub_10030C71C(v10);
    if ((_DWORD)result == 1)
    {
      if (*(_BYTE *)(a2 + 80))
      {
        if (*(_BYTE *)(a2 + 96))
        {
          char v68 = *(_BYTE *)(a2 + 80);
          char v70 = *(_BYTE *)(a2 + 96);
          int v75 = v9;
          char v73 = *(_BYTE *)(a2 + 112);
          if (v73)
          {
            uint64_t v32 = *(void *)a2;
            char v64 = *(_BYTE *)(a2 + 8);
            int v33 = (_OWORD *)(a2 + 17);
            BOOL v34 = (_DWORD *)(a2 + 81);
            int v35 = (_DWORD *)(a2 + 97);
            __n128 v36 = (_DWORD *)(a2 + 113);
            unsigned int v37 = *(unsigned __int8 *)(a2 + 152);
            BOOL v38 = (_DWORD *)(a2 + 153);
            double v39 = v128;
            double v40 = v129;
            double v41 = v130;
            double v66 = *(float *)&v131.i32[2];
            if (v37 <= 1) {
              LOBYTE(v37) = 1;
            }
            char v60 = v37;
            LODWORD(v100) = *(_DWORD *)(a2 + 9);
            *(_DWORD *)((char *)&v100 + 3) = *(_DWORD *)(a2 + 12);
            __int128 v42 = *(_OWORD *)(a2 + 33);
            *(_OWORD *)int v122 = *v33;
            *(_OWORD *)&v122[16] = v42;
            __int128 v44 = *v33;
            __int128 v43 = *(_OWORD *)(a2 + 33);
            *(_OWORD *)&v122[32] = *(_OWORD *)(a2 + 49);
            *(void *)&v122[47] = *(void *)(a2 + 64);
            *(_DWORD *)((char *)&v98 + 3) = *(_DWORD *)(a2 + 84);
            LODWORD(v9_Block_object_dispose((const void *)(v1 - 112), 8) = *v34;
            *(_DWORD *)((char *)&v96 + 3) = *(_DWORD *)(a2 + 100);
            LODWORD(v96) = *v35;
            *(_DWORD *)((char *)&v94 + 3) = *(_DWORD *)(a2 + 116);
            LODWORD(v94) = *v36;
            double v45 = *(float *)&v131.i32[3];
            unint64_t v62 = COERCE_UNSIGNED_INT64(*(float *)&v131.i32[3]) >> 8;
            *(_DWORD *)((char *)&v92 + 3) = *(_DWORD *)(a2 + 156);
            LODWORD(v92) = *v38;
            __int128 v46 = *(_OWORD *)(a2 + 49);
            *(void *)&v124[47] = *(void *)(a2 + 64);
            *(_OWORD *)&v124[16] = v43;
            *(_OWORD *)&v124[32] = v46;
            *(_OWORD *)uint64_t v124 = v44;
            *(_DWORD *)((char *)&v115 + 3) = *(_DWORD *)(a2 + 84);
            LODWORD(v115) = *v34;
            *(_DWORD *)((char *)&v107 + 3) = *(_DWORD *)(a2 + 100);
            LODWORD(v107) = *v35;
            *(_DWORD *)((char *)&v104 + 3) = *(_DWORD *)(a2 + 116);
            LODWORD(v104) = *v36;
            *(_DWORD *)((char *)&v102 + 3) = *(_DWORD *)(a2 + 156);
            int8x16_t v47 = v77;
            float64x2_t v53 = vcvtq_f64_f32((float32x2_t)*(_OWORD *)&vextq_s8(v47, v47, 0xCuLL));
            float64x2_t v51 = vcvtq_f64_f32((float32x2_t)*(_OWORD *)&vextq_s8(v47, v47, 4uLL));
            LODWORD(v102) = *v38;
            float64x2_t v78 = vcvtq_f64_f32(*(float32x2_t *)v131.i8);
            char v48 = *(_BYTE *)(a2 + 16);
            uint64_t result = sub_10030C71C(v10);
            *(_BYTE *)a3 = 0;
            *(_BYTE *)(a3 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
            *(_BYTE *)(a3 + 144) = 0;
            *(_BYTE *)(a3 + 272) = 0;
            *(void *)(a3 + 28_Block_object_dispose((const void *)(v1 - 112), 8) = v32;
            *(void *)(a3 + 296) = v11;
            *(_BYTE *)(a3 + 304) = 1;
            __int128 v49 = *(_OWORD *)&v124[16];
            *(_OWORD *)(a3 + 305) = *(_OWORD *)v124;
            *(_OWORD *)(a3 + 321) = v49;
            *(_OWORD *)(a3 + 337) = *(_OWORD *)&v124[32];
            *(void *)(a3 + 352) = *(void *)&v124[47];
            *(double *)(a3 + 360) = *(float *)&v76;
            *(_BYTE *)(a3 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = v68;
            *(_DWORD *)(a3 + 372) = *(_DWORD *)((char *)&v115 + 3);
            *(_DWORD *)(a3 + 369) = v115;
            *(double *)(a3 + 376) = *((float *)&v76 + 1);
            *(_BYTE *)(a3 + 384) = v70;
            *(_DWORD *)(a3 + 38_Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)((char *)&v107 + 3);
            *(_DWORD *)(a3 + 385) = v107;
            *(double *)(a3 + 392) = *((float *)&v76 + 2);
            *(_BYTE *)(a3 + 400) = v73;
            *(_DWORD *)(a3 + 404) = *(_DWORD *)((char *)&v104 + 3);
            *(_DWORD *)(a3 + 401) = v104;
            *int v75 = v53;
            v75[1] = v51;
            *(_BYTE *)(a3 + 440) = v60;
            *(_DWORD *)(a3 + 444) = *(_DWORD *)((char *)&v102 + 3);
            *(_DWORD *)(a3 + 441) = v102;
            *(void *)(a3 + 44_Block_object_dispose((const void *)(v1 - 112), 8) = v32;
            *(_BYTE *)(a3 + 456) = v64;
            *(_DWORD *)(a3 + 460) = *(_DWORD *)((char *)&v100 + 3);
            *(_DWORD *)(a3 + 457) = v100;
            *(_BYTE *)(a3 + 464) = v48;
            *(void *)(a3 + 512) = *(void *)&v122[47];
            __int128 v50 = *(_OWORD *)&v122[16];
            *(_OWORD *)(a3 + 465) = *(_OWORD *)v122;
            *(_OWORD *)(a3 + 481) = v50;
            *(_OWORD *)(a3 + 497) = *(_OWORD *)&v122[32];
            *(double *)(a3 + 520) = v39;
            *(_BYTE *)(a3 + 52_Block_object_dispose((const void *)(v1 - 112), 8) = v68;
            *(_DWORD *)(a3 + 529) = v98;
            *(_DWORD *)(a3 + 532) = *(_DWORD *)((char *)&v98 + 3);
            *(double *)(a3 + 536) = v40;
            *(_BYTE *)(a3 + 544) = v70;
            *(_DWORD *)(a3 + 545) = v96;
            *(_DWORD *)(a3 + 54_Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)((char *)&v96 + 3);
            *(double *)(a3 + 552) = v41;
            *(_BYTE *)(a3 + 560) = v73;
            *(_DWORD *)(a3 + 561) = v94;
            *(_DWORD *)(a3 + 564) = *(_DWORD *)((char *)&v94 + 3);
            *(_BYTE *)(a3 + 56_Block_object_dispose((const void *)(v1 - 112), 8) = LOBYTE(v45);
            HIBYTE(v75[10].f64[0]) = HIBYTE(v45);
            *(_WORD *)((char *)v75[10].f64 + 5) = HIDWORD(v45) >> 8;
            *(_DWORD *)((char *)v75[10].f64 + 1) = v62;
            *(float64x2_t *)(a3 + 576) = v78;
            *(double *)(a3 + 592) = v66;
            *(_BYTE *)(a3 + 600) = v60;
            *(_DWORD *)(a3 + 604) = *(_DWORD *)((char *)&v92 + 3);
            *(_DWORD *)(a3 + 601) = v92;
            *(_DWORD *)(a3 + 60_Block_object_dispose((const void *)(v1 - 112), 8) = result;
            goto LABEL_24;
          }
        }
      }

uint64_t sub_1002F3360@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = (void *)(a1 + 304);
  sub_10030D41C(a1 + 304, a2, (uint64_t)&v56);
  if ((_DWORD)v61 == 2)
  {
    v6.n128_f64[0] = *(double *)&v56 - *(double *)(a1 + 1056);
    sub_10030CAC4(v5, (uint64_t)&v48, v6);
    int v7 = v55;
    if (v55)
    {
      if (*(_BYTE *)(a1 + 128)) {
        *(float32x4_t *)(a1 + 28_Block_object_dispose((const void *)(v1 - 112), 8) = vaddq_f32(*(float32x4_t *)(a1 + 288), vsubq_f32(v52, *(float32x4_t *)(a1 + 64)));
      }
      __int128 v8 = *(_OWORD *)&v54[16];
      *(_OWORD *)(a1 + 96) = *(_OWORD *)v54;
      *(_OWORD *)(a1 + 112) = v8;
      *(_BYTE *)(a1 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = v55;
      __int128 v9 = v51;
      *(_OWORD *)(a1 + 32) = v50;
      *(_OWORD *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v9;
      __int128 v10 = v53;
      *(float32x4_t *)(a1 + 64) = v52;
      *(_OWORD *)(a1 + 80) = v10;
      __int128 v11 = v49;
      *(_OWORD *)a1 = v48;
      *(_OWORD *)(a1 + 16) = v11;
    }

    __int128 v44 = v48;
    __int128 v45 = v49;
    __int128 v46 = v50;
    __int128 v47 = v51;
    __int128 v33 = v53;
    uint64_t v34 = *(void *)v54;
    int v12 = *(_DWORD *)&v54[8];
    char v13 = v54[12];
    *(_DWORD *)((char *)v43 + 15) = *(_DWORD *)&v54[28];
    float32x4_t v14 = *(float32x4_t *)(a1 + 288);
    v14.i32[3] = 1.0;
    __int128 v39 = v56;
    __int128 v40 = v57;
    __int128 v41 = v58;
    __int128 v42 = v59;
    v43[0] = *(_OWORD *)&v54[13];
    __int128 v31 = v61;
    uint64_t v32 = v62;
    v38[0] = *(_OWORD *)v63;
    *(_DWORD *)((char *)v38 + 15) = *(_DWORD *)&v63[15];
    if (v7)
    {
      int v12 = 0;
      float32x4_t v15 = v14;
      float32x4_t v16 = vaddq_f32(v14, vsubq_f32(v60, v52));
      char v13 = 1;
    }

    else
    {
      float32x4_t v29 = v14;
      float32x4_t v30 = v52;
      sub_10030C844(v5, (uint64_t)v35);
      float32x4_t v16 = v29;
      if (v37)
      {
        float32x4_t v22 = *(float32x4_t *)(a1 + 288);
        v22.i32[3] = 1.0;
        float32x4_t v16 = vaddq_f32(vsubq_f32(v60, v36), v22);
      }

      float32x4_t v15 = v30;
    }

    *(void *)(a3 + 28_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
    *(_BYTE *)(a3 + 296) = 0;
    *(_BYTE *)(a3 + 304) = 0;
    *(_BYTE *)(a3 + 440) = 0;
    *(void *)(a3 + 44_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
    *(_BYTE *)(a3 + 456) = 0;
    *(_BYTE *)(a3 + 464) = 0;
    *(_BYTE *)(a3 + 600) = 0;
    *(_BYTE *)(a3 + 40_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
    *(_OWORD *)(a3 + 312) = 0u;
    *(_OWORD *)(a3 + 32_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
    *(_OWORD *)(a3 + 344) = 0u;
    *(_OWORD *)(a3 + 360) = 0u;
    *(_OWORD *)(a3 + 376) = 0u;
    *(_OWORD *)(a3 + 392) = 0u;
    *(_BYTE *)(a3 + 56_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
    *(_OWORD *)(a3 + 472) = 0u;
    *(_OWORD *)(a3 + 48_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
    *(_OWORD *)(a3 + 504) = 0u;
    *(_OWORD *)(a3 + 520) = 0u;
    *(_OWORD *)(a3 + 536) = 0u;
    *(_OWORD *)(a3 + 552) = 0u;
    __int128 v23 = v40;
    *(_OWORD *)a3 = v39;
    *(_OWORD *)(a3 + 16) = v23;
    __int128 v24 = v42;
    *(_OWORD *)(a3 + 32) = v41;
    *(_OWORD *)(a3 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v24;
    *(float32x4_t *)(a3 + 64) = v16;
    *(_OWORD *)(a3 + 80) = v31;
    *(void *)(a3 + 96) = v32;
    *(_DWORD *)(a3 + 104) = 0;
    *(_BYTE *)(a3 + 10_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
    *(_OWORD *)(a3 + 109) = v38[0];
    *(_DWORD *)(a3 + 124) = *(_DWORD *)((char *)v38 + 15);
    *(_BYTE *)(a3 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
    __int128 v25 = v47;
    *(_OWORD *)(a3 + 176) = v46;
    *(_OWORD *)(a3 + 192) = v25;
    __int128 v26 = v45;
    *(_OWORD *)(a3 + 144) = v44;
    *(_OWORD *)(a3 + 160) = v26;
    *(void *)(a3 + 240) = v34;
    *(float32x4_t *)(a3 + 20_Block_object_dispose((const void *)(v1 - 112), 8) = v15;
    *(_OWORD *)(a3 + 224) = v33;
    *(_DWORD *)(a3 + 24_Block_object_dispose((const void *)(v1 - 112), 8) = v12;
    *(_BYTE *)(a3 + 252) = v13;
    __int128 v27 = v43[0];
    *(_DWORD *)(a3 + 26_Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)((char *)v43 + 15);
    *(_OWORD *)(a3 + 253) = v27;
    *(_BYTE *)(a3 + 272) = v7;
  }

  else
  {
    if (*(_BYTE *)(a1 + 128)) {
      *(_BYTE *)(a1 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
    }
    float32x4_t v52 = v60;
    __int128 v53 = v61;
    *(void *)double v54 = v62;
    __int128 v48 = v56;
    __int128 v49 = v57;
    __int128 v50 = v58;
    __int128 v51 = v59;
    BYTE2(v44) = v63[2];
    LOWORD(v44) = *(_WORD *)v63;
    v35[0] = *(void *)&v63[8];
    *(_DWORD *)((char *)v35 + 7) = *(_DWORD *)&v63[15];
    int v17 = sub_10030C71C((uint64_t)v5);
    *(_BYTE *)(a3 + 144) = 0;
    *(_BYTE *)(a3 + 272) = 0;
    *(void *)(a3 + 28_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
    *(_BYTE *)(a3 + 296) = 0;
    *(_BYTE *)(a3 + 304) = 0;
    *(_BYTE *)(a3 + 440) = 0;
    *(void *)(a3 + 44_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
    *(_BYTE *)(a3 + 456) = 0;
    *(_BYTE *)(a3 + 464) = 0;
    *(_BYTE *)(a3 + 600) = 0;
    *(_OWORD *)(a3 + 312) = 0u;
    *(_OWORD *)(a3 + 32_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
    *(_OWORD *)(a3 + 344) = 0u;
    *(_OWORD *)(a3 + 360) = 0u;
    *(_OWORD *)(a3 + 376) = 0u;
    *(_OWORD *)(a3 + 392) = 0u;
    *(_BYTE *)(a3 + 40_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
    *(_OWORD *)(a3 + 472) = 0u;
    *(_OWORD *)(a3 + 48_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
    *(_OWORD *)(a3 + 504) = 0u;
    *(_OWORD *)(a3 + 520) = 0u;
    *(_OWORD *)(a3 + 536) = 0u;
    *(_OWORD *)(a3 + 552) = 0u;
    *(_BYTE *)(a3 + 56_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
    __int128 v18 = v53;
    *(float32x4_t *)(a3 + 64) = v52;
    *(_OWORD *)(a3 + 80) = v18;
    *(void *)(a3 + 96) = *(void *)v54;
    __int128 v19 = v49;
    *(_OWORD *)a3 = v48;
    *(_OWORD *)(a3 + 16) = v19;
    __int128 v20 = v51;
    *(_OWORD *)(a3 + 32) = v50;
    *(_OWORD *)(a3 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v20;
    *(_DWORD *)(a3 + 104) = 0;
    *(_BYTE *)(a3 + 10_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
    __int16 v21 = v44;
    *(_BYTE *)(a3 + 111) = BYTE2(v44);
    *(_WORD *)(a3 + 109) = v21;
    *(_DWORD *)(a3 + 112) = v17;
    *(_BYTE *)(a3 + 116) = 1;
    *(_DWORD *)(a3 + 124) = *(_DWORD *)((char *)v35 + 7);
    *(void *)(a3 + 117) = v35[0];
    *(_BYTE *)(a3 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
  }

  uint64_t result = sub_10030C71C((uint64_t)v5);
  *(_DWORD *)(a3 + 60_Block_object_dispose((const void *)(v1 - 112), 8) = result;
  return result;
}

__n128 sub_1002F3740(uint64_t a1, uint64_t a2)
{
  __int128 v2 = *(_OWORD *)(a2 + 112);
  v7[6] = *(_OWORD *)(a2 + 96);
  v7[7] = v2;
  uint64_t v8 = *(void *)(a2 + 128);
  __int128 v3 = *(_OWORD *)(a2 + 48);
  _DWORD v7[2] = *(_OWORD *)(a2 + 32);
  v7[3] = v3;
  __int128 v4 = *(_OWORD *)(a2 + 80);
  v7[4] = *(_OWORD *)(a2 + 64);
  _OWORD v7[5] = v4;
  __int128 v5 = *(_OWORD *)(a2 + 16);
  v7[0] = *(_OWORD *)a2;
  v7[1] = v5;
  sub_1002CDCF8(a1 + 672, (double *)v7);
  return result;
}

uint64_t sub_1002F378C(uint64_t result, uint64_t *a2, void *a3, double a4, double a5)
{
  uint64_t v5 = *a2;
  *(void *)__n128 result = off_1007BD308;
  *(void *)(result + _Block_object_dispose((const void *)(v1 - 112), 8) = v5;
  __n128 v6 = a2 + 1;
  uint64_t v7 = a2[1];
  *(void *)(result + 16) = v7;
  uint64_t v8 = result + 16;
  uint64_t v9 = a2[2];
  *(void *)(result + 24) = v9;
  if (v9)
  {
    *(void *)(v7 + 16) = v8;
    *a2 = (uint64_t)v6;
    void *v6 = 0LL;
    a2[2] = 0LL;
  }

  else
  {
    *(void *)(result + _Block_object_dispose((const void *)(v1 - 112), 8) = v8;
  }

  *(void *)(result + 32) = *a3;
  __int128 v10 = a3 + 1;
  uint64_t v11 = a3[1];
  *(void *)(result + 40) = v11;
  uint64_t v12 = result + 40;
  uint64_t v13 = a3[2];
  *(void *)(result + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v13;
  if (v13)
  {
    *(void *)(v11 + 16) = v12;
    *a3 = v10;
    void *v10 = 0LL;
    a3[2] = 0LL;
  }

  else
  {
    *(void *)(result + 32) = v12;
  }

  *(double *)(result + 56) = a4;
  *(double *)(result + 64) = a5;
  return result;
}

void sub_1002F3810(uint64_t a1@<X0>, uint64_t *a2@<X1>, BOOL *a3@<X8>, double a4@<D0>)
{
  uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  if (*a2 == v6)
  {
    *a3 = 0;
    a3[8] = 0;
    a3[16] = 0;
    return;
  }

  uint64_t v9 = 0LL;
  stat __p = 0LL;
  __int128 v44 = 0LL;
  __int128 v45 = 0LL;
  do
  {
    double v10 = *(float *)(v5 + 16);
    if (*(double *)(a1 + 56) <= v10 && *(double *)(a1 + 64) >= v10)
    {
      if (v9 >= v45)
      {
        uint64_t v12 = __p;
        uint64_t v13 = v9 - __p;
        unint64_t v14 = v13 + 1;
        uint64_t v15 = (char *)v45 - (char *)__p;
        else {
          unint64_t v16 = v14;
        }
        if (v16)
        {
          int v17 = (char *)sub_1000472C0((uint64_t)&v45, v16);
          uint64_t v12 = __p;
          uint64_t v9 = v44;
          double v10 = *(float *)(v5 + 16);
        }

        else
        {
          int v17 = 0LL;
        }

        __int128 v18 = (double *)&v17[8 * v13];
        double *v18 = v10;
        uint64_t v11 = v18 + 1;
        while (v9 != v12)
        {
          uint64_t v19 = *((void *)v9-- - 1);
          *((void *)v18-- - 1) = v19;
        }

        stat __p = v18;
        __int128 v45 = (double *)&v17[8 * v16];
        if (v12) {
          operator delete(v12);
        }
      }

      else
      {
        double *v9 = v10;
        uint64_t v11 = v9 + 1;
      }

      __int128 v44 = v11;
      uint64_t v9 = v11;
    }

    v5 += 184LL;
  }

  while (v5 != v6);
  if (__p != v9)
  {
    __int128 v20 = (void *)(a1 + 32);
    double v21 = sub_1002F3B98((void *)(a1 + 32), a4);
    float32x4_t v22 = (void *)(a1 + 8);
    double v23 = sub_1002F3B98(v22, a4);
    if (v23 > 0.0)
    {
      double v24 = log(v21 / v23);
      __int128 v25 = __p;
      if (__p == v44)
      {
        double v28 = 0.0;
        double v27 = 0.0;
      }

      else
      {
        double v26 = v24;
        double v27 = 0.0;
        double v28 = 0.0;
        do
        {
          double v29 = sub_1002F3B98(v20, *v25);
          double v30 = sub_1002F3B98(v22, *v25);
          if (v30 <= 0.0)
          {
            __int128 v31 = (os_log_s *)qword_1008000A0;
            if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT))
            {
              double v32 = *v25;
              *(_DWORD *)__int128 buf = 134283521;
              double v47 = v32;
              _os_log_fault_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_FAULT,  "#hist-unlock, WRTT: Range %{private}f resulted in 0 unlock probability, skipping range",  buf,  0xCu);
            }
          }

          else
          {
            double v27 = v27 + log(v29 / v30);
            double v28 = v26 + v28;
          }

          ++v25;
        }

        while (v25 != v44);
      }

      __int128 v42 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 134218240;
        double v47 = v27;
        __int16 v48 = 2048;
        double v49 = v28;
        _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_DEFAULT,  "#hist-unlock, WRTT: CLHistogramHypothesisTestUnlockEstimator result: logRatio: %f, scaledLogRatio: %f",  buf,  0x16u);
      }

      BOOL v41 = v27 < v28;
      goto LABEL_41;
    }

    __int128 v33 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT)) {
      sub_1003AA540(v33, v34, v35, v36, v37, v38, v39, v40);
    }
  }

  BOOL v41 = 0;
LABEL_41:
  *a3 = v41;
  a3[8] = 0;
  a3[16] = 0;
  if (__p) {
    operator delete(__p);
  }
}

void sub_1002F3B70( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
}

double sub_1002F3B98(void *a1, double a2)
{
  __int128 v3 = (double *)(a1 + 1);
  uint64_t v2 = a1[1];
  if (v2)
  {
    do
    {
      __int128 v4 = (uint64_t *)(v2 + 8);
      if (*(double *)(v2 + 32) > a2)
      {
        __int128 v4 = (uint64_t *)v2;
        __int128 v3 = (double *)v2;
      }

      uint64_t v2 = *v4;
    }

    while (*v4);
  }

  if (v3 == (double *)*a1)
  {
    uint64_t v6 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT)) {
      sub_1003AA5AC(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }

  else
  {
    uint64_t v5 = *(double **)v3;
    if (*(void *)v3)
    {
      do
      {
        __int128 v3 = v5;
        uint64_t v5 = (double *)*((void *)v5 + 1);
      }

      while (v5);
    }

    else
    {
      unint64_t v14 = v3;
      do
      {
        __int128 v3 = (double *)*((void *)v14 + 2);
        BOOL v15 = *(void *)v3 == (void)v14;
        unint64_t v14 = v3;
      }

      while (v15);
    }
  }

  return v3[5];
}

uint64_t sub_1002F3C50(uint64_t a1)
{
  *(void *)a1 = off_1007BD308;
  sub_100034A98(a1 + 32, *(void **)(a1 + 40));
  sub_100034A98(a1 + 8, *(void **)(a1 + 16));
  return a1;
}

void sub_1002F3C90(void **a1)
{
  *a1 = off_1007BD308;
  sub_100034A98((uint64_t)(a1 + 4), a1[5]);
  sub_100034A98((uint64_t)(a1 + 1), a1[2]);
  operator delete(a1);
}

uint64_t sub_1002F3CD0(uint64_t a1)
{
  return a1;
}

void *sub_1002F3CF8(uint64_t a1, double a2, double a3)
{
  __n128 result = (void *)sub_1002E2EC0(a1, -5.0, 10.0, a2, a3);
  *__n128 result = &off_1007BD358;
  return result;
}

void sub_1002F3D28(void *a1@<X8>)
{
  uint64_t v2 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "#decision-proc,WRTT, Using CLHistogramHypothesisTestUnlockEstimator with phone unlock histograms",  buf,  2u);
  }

  sub_1002F3DC0((uint64_t)&unk_1007FECB0, (uint64_t)&unk_1007FECC8, &dbl_10042FCD0, &dbl_10042FCD8, &v3);
  *a1 = v3;
}

void sub_1002F3DC0(uint64_t a1@<X0>, uint64_t a2@<X1>, double *a3@<X2>, double *a4@<X3>, void *a5@<X8>)
{
  uint64_t v10 = operator new(0x48uLL);
  sub_1002F4190(v12, a1);
  sub_1002F4190(v11, a2);
  sub_1002F380C((uint64_t)v10, v12, v11, *a3, *a4);
  *a5 = v10;
  sub_100034A98((uint64_t)v11, (void *)v11[1]);
  sub_100034A98((uint64_t)v12, (void *)v12[1]);
}

void sub_1002F3E5C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, char a12, void *a13)
{
}

void sub_1002F3E98(void *a1@<X8>)
{
  *a1 = v2;
}

uint64_t sub_1002F3EF4(uint64_t a1, double *a2, uint64_t a3)
{
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  __int128 v4 = (double *)(a1 + 8);
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = a1 + 8;
  if (a3)
  {
    uint64_t v6 = 16 * a3;
    do
    {
      sub_1002F3F70((uint64_t **)a1, v4, a2, a2);
      a2 += 2;
      v6 -= 16LL;
    }

    while (v6);
  }

  return a1;
}

void sub_1002F3F58(_Unwind_Exception *a1)
{
}

uint64_t *sub_1002F3F70(uint64_t **a1, double *a2, double *a3, _OWORD *a4)
{
  uint64_t v6 = sub_1002F3FF4(a1, a2, &v11, &v10, a3);
  uint64_t v7 = *(uint64_t **)v6;
  if (!*(void *)v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    uint64_t v7 = (uint64_t *)operator new(0x30uLL);
    *((_OWORD *)v7 + 2) = *a4;
    sub_10001E548(a1, (uint64_t)v11, v8, v7);
  }

  return v7;
}

double *sub_1002F3FF4(void *a1, double *a2, double **a3, double *a4, double *a5)
{
  uint64_t v5 = (double *)(a1 + 1);
  if (a1 + 1 == (void *)a2 || (v6 = *a5, double v7 = a2[4], *a5 < v7))
  {
    uint64_t v8 = *(uint64_t **)a2;
    if ((double *)*a1 == a2)
    {
      double v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }

      else
      {
        *a3 = a2;
        return a2;
      }
    }

    if (v8)
    {
      uint64_t v9 = *(uint64_t **)a2;
      do
      {
        double v10 = (double *)v9;
        uint64_t v9 = (uint64_t *)v9[1];
      }

      while (v9);
    }

    else
    {
      uint64_t v13 = a2;
      do
      {
        double v10 = (double *)*((void *)v13 + 2);
        BOOL v14 = *(void *)v10 == (void)v13;
        uint64_t v13 = v10;
      }

      while (v14);
    }

    double v15 = *a5;
    if (v10[4] < *a5) {
      goto LABEL_17;
    }
    unint64_t v16 = *(double **)v5;
    if (*(void *)v5)
    {
      do
      {
        while (1)
        {
          int v17 = v16;
          double v18 = v16[4];
          if (v15 >= v18) {
            break;
          }
          unint64_t v16 = *(double **)v16;
          uint64_t v5 = v17;
          if (!*(void *)v17) {
            goto LABEL_43;
          }
        }

        if (v18 >= v15) {
          break;
        }
        uint64_t v5 = v16 + 1;
        unint64_t v16 = (double *)*((void *)v16 + 1);
      }

      while (v16);
      goto LABEL_43;
    }

uint64_t *sub_1002F4190(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0LL;
  a1[1] = 0LL;
  *a1 = (uint64_t)(a1 + 1);
  sub_1002F41E4(a1, *(double **)a2, (double *)(a2 + 8));
  return a1;
}

void sub_1002F41CC(_Unwind_Exception *a1)
{
}

uint64_t *sub_1002F41E4(uint64_t *result, double *a2, double *a3)
{
  if (a2 != a3)
  {
    __int128 v4 = a2;
    uint64_t v5 = (uint64_t **)result;
    double v6 = (double *)(result + 1);
    do
    {
      __n128 result = sub_1002F3F70(v5, v6, v4 + 4, (_OWORD *)v4 + 2);
      double v7 = (double *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          double v7 = *(double **)v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          uint64_t v8 = (double *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          __int128 v4 = v8;
        }

        while (!v9);
      }

      __int128 v4 = v8;
    }

    while (v8 != a3);
  }

  return result;
}

uint64_t sub_1002F4268()
{
  return __cxa_atexit((void (*)(void *))sub_1002F3CD0, &unk_1007FECC8, (void *)&_mh_execute_header);
}

void sub_1002F43E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1002F444C(unsigned int *a1, uint64_t a2)
{
  uint64_t v2 = (double *)(a1 + 10);
  int v3 = *((unsigned __int8 *)a1 + 56);
  if (*((_BYTE *)a1 + 56))
  {
    int v4 = *(_DWORD *)(a2 + 8);
    if ((v4 - 1) < 2)
    {
LABEL_5:
      int v3 = 0;
      double v5 = *(double *)a2;
      a1[12] = *(_DWORD *)(a2 + 8);
      double *v2 = v5;
      goto LABEL_10;
    }

    if (v4) {
      goto LABEL_9;
    }
    if (a1[12]) {
      goto LABEL_5;
    }
    if (*(double *)a2 - *v2 <= 0.2)
    {
LABEL_9:
      int v3 = 0;
    }

    else
    {
      double v6 = *(double *)a2;
      a1[12] = *(_DWORD *)(a2 + 8);
      double *v2 = v6;
      int v3 = 1;
    }
  }

  else
  {
    *(_OWORD *)uint64_t v2 = *(_OWORD *)a2;
    *((_BYTE *)a1 + 56) = 1;
  }

void sub_1002F4848(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002F49B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002F4B10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002F5180( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, void *a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, void *a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  sub_1002F52E0((uint64_t)&a34);
  sub_1002F52E0((uint64_t)&a50);
  sub_1002F52E0((uint64_t)&a66);

  _Unwind_Resume(a1);
}

uint64_t sub_1002F52E0(uint64_t a1)
{
  return a1;
}

void sub_1002F55C0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }

  if (a20 < 0) {
    operator delete(a15);
  }

  _Unwind_Resume(a1);
}

void sub_1002F5DD4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20, void *a21, uint64_t a22, uint64_t a23, void *a24, uint64_t a25, uint64_t a26, void *a27, uint64_t a28, uint64_t a29, uint64_t a30, void *a31, uint64_t a32)
{
  _Unwind_Resume(a1);
}

void *sub_1002F5F0C(void *a1, const void *a2, unint64_t a3)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if (a3)
  {
    sub_10011B5D8(a1, a3);
    double v6 = (char *)a1[1];
    memmove(v6, a2, 8 * a3);
    a1[1] = &v6[8 * a3];
  }

  return a1;
}

void sub_1002F5F70(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_1002F6498( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1002F6878(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002F6BCC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  _Unwind_Resume(a1);
}

void sub_1002F73D4(_Unwind_Exception *a1)
{
  *(void *)(v1 - 192) = v1 - 168;
  sub_1002F94B0((void ***)(v1 - 192));
  _Unwind_Resume(a1);
}

void sub_1002F76F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002F7934(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002F7F08( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, void *__p, uint64_t a33)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1002F82B8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }

  _Unwind_Resume(a1);
}

void sub_1002F89CC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, uint64_t a21, void *a22, uint64_t a23)
{
  if (__p) {
    operator delete(__p);
  }
  if (a19) {
    operator delete(a19);
  }
  if (a22) {
    operator delete(a22);
  }

  _Unwind_Resume(a1);
}

double sub_1002F8AAC(double *a1, double *a2)
{
  double v8 = *a1;
  double v9 = a1[1];
  double v10 = a2[1];
  double v12 = *a2;
  double v2 = logb(fmax(fabs(*a2), fabs(v10)));
  if ((*(void *)&v2 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
    int v3 = 0;
    double v4 = v10;
  }

  else
  {
    int v3 = (int)v2;
    double v12 = scalbn(v12, -(int)v2);
    double v4 = scalbn(v10, -v3);
  }

  double v11 = v4;
  double v5 = v4 * v4 + v12 * v12;
  double v6 = scalbn((v9 * v4 + v8 * v12) / v5, -v3);
  scalbn((v9 * v12 - v8 * v11) / v5, -v3);
  return v6;
}

void sub_1002F8FDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002F91B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002F9258( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)&OBJC_CLASS___NeuralNetworkModelWithDataTransformer;
  -[_Unwind_Exception dealloc](&a9, "dealloc");
  _Unwind_Resume(a1);
}

char *sub_1002F92D4(char *__dst, __int128 *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1000063A8(__dst, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)__int128 __dst = v4;
  }

  if (*((char *)a2 + 47) < 0)
  {
    sub_1000063A8(__dst + 24, *((void **)a2 + 3), *((void *)a2 + 4));
  }

  else
  {
    __int128 v5 = *(__int128 *)((char *)a2 + 24);
    *((void *)__dst + 5) = *((void *)a2 + 5);
    *(_OWORD *)(__dst + 24) = v5;
  }

  *((_DWORD *)__dst + 12) = *((_DWORD *)a2 + 12);
  sub_100201F04((uint64_t)(__dst + 56), (__int128 *)((char *)a2 + 56));
  sub_100201F04((uint64_t)(__dst + 88), (__int128 *)((char *)a2 + 88));
  return __dst;
}

void sub_1002F937C(_Unwind_Exception *exception_object)
{
}

void sub_1002F93D0(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    __int128 v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 120LL;
        sub_1002F943C((uint64_t)(a1 + 2), v3);
      }

      while ((void *)v3 != v1);
      __int128 v4 = *a1;
    }

    a1[1] = v1;
    operator delete(v4);
    *a1 = 0LL;
    a1[1] = 0LL;
    a1[2] = 0LL;
  }

void sub_1002F943C(uint64_t a1, uint64_t a2)
{
}

void sub_1002F94B0(void ***a1)
{
  uint64_t v1 = *a1;
  double v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    __int128 v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 120LL;
        sub_1002F943C((uint64_t)(v1 + 2), v4);
      }

      while ((void *)v4 != v2);
      __int128 v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

char *sub_1002F9534(void *a1, unint64_t a2)
{
  if (a2 >= 0x222222222222223LL) {
    sub_10001E11C();
  }
  __n128 result = (char *)sub_1002F9584((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[120 * v4];
  return result;
}

void *sub_1002F9584(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x222222222222223LL) {
    sub_10001D350();
  }
  return operator new(120 * a2);
}

char *sub_1002F95C8(uint64_t a1, __int128 *a2, __int128 *a3, char *__dst)
{
  uint64_t v4 = __dst;
  double v10 = __dst;
  double v11 = __dst;
  v8[0] = a1;
  v8[1] = &v10;
  _OWORD v8[2] = &v11;
  char v9 = 0;
  if (a2 != a3)
  {
    double v6 = a2;
    do
    {
      sub_1002F92D4(v4, v6);
      double v6 = (__int128 *)((char *)v6 + 120);
      uint64_t v4 = v11 + 120;
      v11 += 120;
    }

    while (v6 != a3);
  }

  char v9 = 1;
  sub_1002F9668((uint64_t)v8);
  return v4;
}

void sub_1002F9654( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1002F9668(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_1002F969C((uint64_t *)a1);
  }
  return a1;
}

void sub_1002F969C(uint64_t *a1)
{
  double v2 = (uint64_t *)a1[1];
  uint64_t v1 = (uint64_t *)a1[2];
  uint64_t v3 = *v1;
  uint64_t v4 = *v2;
  if (*v1 != *v2)
  {
    uint64_t v5 = *a1;
    do
    {
      v3 -= 120LL;
      sub_1002F943C(v5, v3);
    }

    while (v3 != v4);
  }

char *sub_1002F96EC(char *result, __int128 *a2, __int128 *a3, unint64_t a4)
{
  if (a4)
  {
    double v6 = result;
    sub_1002F9534(result, a4);
    __n128 result = sub_1002F9770((uint64_t)(v6 + 16), a2, a3, *((char **)v6 + 1));
    *((void *)v6 + 1) = result;
  }

  return result;
}

void sub_1002F9750( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + _Block_object_dispose((const void *)(v1 - 112), 8) = v10;
  sub_1002F94B0(&a9);
  _Unwind_Resume(a1);
}

char *sub_1002F9770(uint64_t a1, __int128 *a2, __int128 *a3, char *__dst)
{
  uint64_t v4 = __dst;
  uint64_t v10 = __dst;
  double v11 = __dst;
  v8[0] = a1;
  v8[1] = &v10;
  _OWORD v8[2] = &v11;
  char v9 = 0;
  if (a2 != a3)
  {
    double v6 = a2;
    do
    {
      sub_1002F92D4(v4, v6);
      double v6 = (__int128 *)((char *)v6 + 120);
      uint64_t v4 = v11 + 120;
      v11 += 120;
    }

    while (v6 != a3);
  }

  char v9 = 1;
  sub_1002F9668((uint64_t)v8);
  return v4;
}

void sub_1002F97FC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_1002F9810(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    double v6 = result;
    __n128 result = sub_1001205C0(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }

  return result;
}

void sub_1002F986C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

char *sub_1002F9888(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  uint64_t v5 = (char *)__dst;
  if (a5 < 1) {
    return v5;
  }
  uint64_t v7 = __src;
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v9 = a1 + 16;
  uint64_t v10 = v11;
  unint64_t v12 = *(void *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 4)
  {
    double v13 = *(void **)a1;
    unint64_t v14 = a5 + ((uint64_t)(v12 - *(void *)a1) >> 4);
    if (v14 >> 60) {
      sub_10001E11C();
    }
    uint64_t v15 = (__dst - (uint64_t)v13) >> 4;
    uint64_t v16 = v10 - (void)v13;
    if (v16 >> 3 > v14) {
      unint64_t v14 = v16 >> 3;
    }
    else {
      unint64_t v17 = v14;
    }
    uint64_t v37 = v9;
    if (v17) {
      char v18 = (char *)sub_10011E44C(v9, v17);
    }
    else {
      char v18 = 0LL;
    }
    double v28 = &v18[16 * v15];
    stat __p = v18;
    uint64_t v34 = v28;
    uint64_t v36 = &v18[16 * v17];
    uint64_t v29 = 16 * a5;
    double v30 = &v28[16 * a5];
    do
    {
      __int128 v31 = *(_OWORD *)v7;
      v7 += 16;
      *(_OWORD *)double v28 = v31;
      v28 += 16;
      v29 -= 16LL;
    }

    while (v29);
    uint64_t v35 = v30;
    uint64_t v5 = (char *)sub_1002F9A94((void **)a1, (uint64_t)&__p, v5);
    if (v35 != v34) {
      v35 += (v34 - v35 + 15) & 0xFFFFFFFFFFFFFFF0LL;
    }
    if (__p) {
      operator delete(__p);
    }
    return v5;
  }

  uint64_t v19 = v12 - __dst;
  uint64_t v20 = (uint64_t)(v12 - __dst) >> 4;
  if (v20 >= a5)
  {
    double v21 = &__src[16 * a5];
    double v23 = *(char **)(v9 - 8);
LABEL_17:
    double v24 = &v5[16 * a5];
    __int128 v25 = &v23[-16 * a5];
    double v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      double v26 = v23;
      do
      {
        __int128 v27 = *(_OWORD *)v25;
        v25 += 16;
        *(_OWORD *)double v26 = v27;
        v26 += 16;
      }

      while ((unint64_t)v25 < v12);
    }

    *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v26;
    if (v23 != v24) {
      memmove(&v23[-16 * ((v23 - v24) >> 4)], v5, v23 - v24);
    }
    if (v21 != v7) {
      memmove(v5, v7, v21 - v7);
    }
    return v5;
  }

  double v21 = &__src[16 * v20];
  int64_t v22 = a4 - v21;
  if (a4 != v21) {
    memmove(*(void **)(v9 - 8), &__src[16 * v20], a4 - v21);
  }
  double v23 = (char *)(v12 + v22);
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v12 + v22;
  if (v19 >= 1) {
    goto LABEL_17;
  }
  return v5;
}

void sub_1002F9A5C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1002F9A94(void **a1, uint64_t a2, char *__src)
{
  uint64_t v5 = *(void **)(a2 + 8);
  double v6 = (char *)*a1;
  uint64_t v7 = v5;
  if (*a1 != __src)
  {
    size_t v8 = __src;
    uint64_t v9 = *(void *)(a2 + 8);
    do
    {
      uint64_t v7 = (void *)(v9 - 16);
      *(_OWORD *)(v9 - 16) = *((_OWORD *)v8 - 1);
      v8 -= 16;
      v9 -= 16LL;
    }

    while (v8 != v6);
  }

  *(void *)(a2 + _Block_object_dispose((const void *)(v1 - 112), 8) = v7;
  uint64_t v10 = a1[1];
  uint64_t v11 = *(void *)(a2 + 16);
  int64_t v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    uint64_t v7 = *(void **)(a2 + 8);
  }

  *(void *)(a2 + 16) = v11 + v12;
  double v13 = (char *)*a1;
  *a1 = v7;
  *(void *)(a2 + _Block_object_dispose((const void *)(v1 - 112), 8) = v13;
  unint64_t v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v14;
  uint64_t v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v15;
  *(void *)a2 = *(void *)(a2 + 8);
  return v5;
}

void sub_1002F9B68()
{
  uint64_t v0 = objc_autoreleasePoolPush();
  uint64_t v3 = "AntennaMask_1_NN_V5_Model_DeviceType_201.mlmodelc/fp16_model.espresso";
  uint64_t v4 = "net";
  sub_100240590(&xmmword_1007FECE0, &v3);
  uint64_t v1 = "AntennaMask_2_NN_V5_Model_DeviceType_201.mlmodelc/fp16_model.espresso";
  double v2 = "net";
  sub_100240590(&xmmword_1007FED10, &v1);
  __cxa_atexit((void (*)(void *))sub_100233260, &xmmword_1007FECE0, (void *)&_mh_execute_header);
  uint64_t v3 = "AntennaMask_1_NN_V5_ScalingModel_DeviceType_201";
  uint64_t v4 = "mlmodelc";
  sub_100240590(&xmmword_1007FED40, &v3);
  uint64_t v1 = "AntennaMask_2_NN_V5_ScalingModel_DeviceType_201";
  double v2 = "mlmodelc";
  sub_100240590(&xmmword_1007FED70, &v1);
  __cxa_atexit((void (*)(void *))sub_100233260, &xmmword_1007FED40, (void *)&_mh_execute_header);
  sub_1000065CC(&qword_1007FEDA0, "input_1");
  __cxa_atexit((void (*)(void *))&std::string::~string, &qword_1007FEDA0, (void *)&_mh_execute_header);
  sub_1000065CC(&qword_1007FEDB8, "Identity");
  __cxa_atexit((void (*)(void *))&std::string::~string, &qword_1007FEDB8, (void *)&_mh_execute_header);
  objc_autoreleasePoolPop(v0);
}

void sub_1002F9CB4(_Unwind_Exception *exception_object)
{
  if (byte_1007FED6F < 0) {
    sub_1003AAB6C();
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002F9CF8(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1 = 0;
  *(_BYTE *)(a1 + 24) = 0;
  uint64_t v3 = (_BYTE *)(a1 + 4112);
  *(void *)(a1 + 32) = *(void *)(a2 + 16);
  *(_BYTE *)(a1 + 40) = 0;
  *(_BYTE *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  *(_BYTE *)(a1 + 80) = 0;
  *(_BYTE *)(a1 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_OWORD *)(a1 + 96) = xmmword_10042FE30;
  *(_OWORD *)(a1 + 112) = xmmword_10042FE40;
  *(_OWORD *)(a1 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = xmmword_10042FE50;
  *(void *)(a1 + 144) = 0x3FD3333333333333LL;
  *(_WORD *)(a1 + 152) = 257;
  *(_OWORD *)(a1 + 160) = xmmword_10042FE60;
  *(_OWORD *)(a1 + 176) = xmmword_10042FE70;
  *(void *)(a1 + 192) = 0LL;
  uint64_t v4 = 1LL;
  *(_BYTE *)(a1 + 200) = 1;
  *(_OWORD *)(a1 + 20_Block_object_dispose((const void *)(v1 - 112), 8) = xmmword_10042FE80;
  *(_OWORD *)(a1 + 224) = xmmword_10042FE90;
  *(_OWORD *)(a1 + 240) = xmmword_10042FEA0;
  *(_OWORD *)(a1 + 256) = xmmword_10042FEB0;
  *(_OWORD *)(a1 + 272) = xmmword_10042FEC0;
  *(_OWORD *)(a1 + 28_Block_object_dispose((const void *)(v1 - 112), 8) = xmmword_10042FED0;
  *(_OWORD *)(a1 + 304) = xmmword_10042FEE0;
  *(_OWORD *)(a1 + 320) = xmmword_10042FEF0;
  *(_WORD *)(a1 + 336) = 1;
  *(_BYTE *)(a1 + 33_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
  *(void *)(a1 + 344) = 0x4024000000000000LL;
  *(_BYTE *)(a1 + 352) = 0;
  *(_BYTE *)(a1 + 360) = 0;
  *(_OWORD *)(a1 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = xmmword_10042FF00;
  *(void *)(a1 + 384) = 0x403E000000000000LL;
  *(_BYTE *)(a1 + 392) = 1;
  __int128 v5 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 400) = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 416) = v5;
  __int128 v6 = *(_OWORD *)(a2 + 32);
  __int128 v7 = *(_OWORD *)(a2 + 48);
  __int128 v8 = *(_OWORD *)(a2 + 64);
  *(void *)(a1 + 480) = *(void *)(a2 + 80);
  *(_OWORD *)(a1 + 44_Block_object_dispose((const void *)(v1 - 112), 8) = v7;
  *(_OWORD *)(a1 + 464) = v8;
  *(_OWORD *)(a1 + 432) = v6;
  *(_BYTE *)(a1 + 48_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 664) = 0;
  *(_BYTE *)(a1 + 680) = 0;
  *(_BYTE *)(a1 + 68_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 704) = 0;
  *(_BYTE *)(a1 + 832) = 0;
  *(_BYTE *)(a1 + 84_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 976) = 0;
  uint64_t v9 = (void *)(a1 + 992);
  unsigned int v10 = 5489;
  uint64_t v11 = 249LL;
  *(_DWORD *)(a1 + 992) = 5489;
  do
  {
    int v12 = 1812433253 * (v10 ^ (v10 >> 30));
    unsigned int v10 = v12 + v4;
    *(_DWORD *)(a1 + 4 * v11) = v11 + v12 - 248;
    ++v4;
    ++v11;
  }

  while (v11 != 872);
  *(_BYTE *)(a1 + 3512) = 0;
  *(_BYTE *)(a1 + 3520) = 0;
  *(_OWORD *)(a1 + 348_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_BYTE *)(a1 + 3504) = 0;
  *(void *)(a1 + 352_Block_object_dispose((const void *)(v1 - 112), 8) = 0xBFF0000000000000LL;
  *(_BYTE *)(a1 + 3536) = 0;
  *(_BYTE *)(a1 + 3544) = 0;
  *(_BYTE *)(a1 + 3552) = 0;
  *(_BYTE *)(a1 + 3560) = 0;
  *(_BYTE *)(a1 + 356_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 3576) = 0;
  *(_BYTE *)(a1 + 3584) = 0;
  *(void *)(a1 + 3592) = 0LL;
  *(_OWORD *)(a1 + 3600) = xmmword_10042FF10;
  *(_DWORD *)(a1 + 3616) = 2;
  *(_BYTE *)(a1 + 3624) = 0;
  *(_BYTE *)(a1 + 3632) = 0;
  *(_WORD *)(a1 + 368_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_OWORD *)(a1 + 3640) = 0u;
  *(_OWORD *)(a1 + 3656) = 0u;
  *(_OWORD *)(a1 + 3672) = 0u;
  *(void *)(a1 + 3696) = 0x3FF0000000000000LL;
  *(_BYTE *)(a1 + 3704) = 0;
  *(_BYTE *)(a1 + 3712) = 0;
  *(_BYTE *)(a1 + 3720) = 0;
  *(_BYTE *)(a1 + 372_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 3736) = 0;
  *(_BYTE *)(a1 + 3744) = 0;
  *(_BYTE *)(a1 + 3752) = 0;
  *(_BYTE *)(a1 + 3912) = 0;
  *(_BYTE *)(a1 + 3920) = 0;
  *(_BYTE *)(a1 + 392_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 3936) = 0;
  *(_BYTE *)(a1 + 3944) = 0;
  *(_OWORD *)(a1 + 3952) = xmmword_10042FF20;
  *(_BYTE *)(a1 + 4080) = 0;
  *(_BYTE *)(a1 + 408_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_OWORD *)(a1 + 396_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_OWORD *)(a1 + 3984) = 0u;
  *(_OWORD *)(a1 + 4000) = 0u;
  *(_OWORD *)(a1 + 4016) = 0u;
  *(_OWORD *)(a1 + 4032) = 0u;
  *(_OWORD *)(a1 + 404_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_OWORD *)(a1 + 4057) = 0u;
  *(void *)(a1 + 4096) = 0x4014000000000000LL;
  *(_DWORD *)(a1 + 4104) = 0;
  *uint64_t v3 = 0;
  v3[8] = 0;
  char v3[16] = 0;
  v3[96] = 0;
  v3[104] = 0;
  v3[184] = 0;
  v3[248] = 0;
  v3[280] = 0;
  *(_BYTE *)(a1 + 4352) = 0;
  *(_OWORD *)(a1 + 4304) = 0u;
  *(_OWORD *)(a1 + 4320) = 0u;
  *(_OWORD *)(a1 + 4336) = 0u;
  *(_OWORD *)(a1 + 4400) = xmmword_10042E660;
  v3[312] = 0;
  v3[320] = 0;
  *(_OWORD *)(a1 + 4440) = 0u;
  *(_OWORD *)(a1 + 4456) = 0u;
  *(_OWORD *)(a1 + 4472) = 0u;
  *(void *)(a1 + 112) = *(void *)(a2 + 8);
  *(_OWORD *)(a1 + 136) = *(_OWORD *)(a2 + 72);
  *(void *)(a1 + 376) = *(void *)(a2 + 48);
  unsigned int v13 = 1;
  uint64_t v14 = 1LL;
  LODWORD(__src[0]) = 1;
  do
  {
    unsigned int v13 = v14 + 1812433253 * (v13 ^ (v13 >> 30));
    *((_DWORD *)__src + v14++) = v13;
  }

  while (v14 != 624);
  __src[312] = 0LL;
  memcpy(v9, __src, 0x9C8uLL);
  sub_1002FA034(a1);
  return a1;
}

uint64_t sub_1002FA034(uint64_t a1)
{
  double v2 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v20[0]) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_particlefilter,particle filter reinitialized",  (uint8_t *)v20,  2u);
  }

  if (*(_BYTE *)(a1 + 664)) {
    *(_BYTE *)(a1 + 664) = 0;
  }
  if (*(_BYTE *)(a1 + 24))
  {
    uint64_t v3 = *(void **)a1;
    if (*(void *)a1)
    {
      *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v3;
      operator delete(v3);
    }

    *(_BYTE *)(a1 + 24) = 0;
  }

  if (*(_BYTE *)(a1 + 688)) {
    *(_BYTE *)(a1 + 68_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  }
  if (*(_BYTE *)(a1 + 832)) {
    *(_BYTE *)(a1 + 832) = 0;
  }
  *(void *)(a1 + 3496) = 0LL;
  *(_BYTE *)(a1 + 3504) = 0;
  if (*(_BYTE *)(a1 + 3520)) {
    *(_BYTE *)(a1 + 3520) = 0;
  }
  *(void *)(a1 + 352_Block_object_dispose((const void *)(v1 - 112), 8) = 0xBFF0000000000000LL;
  *(_BYTE *)(a1 + 392) = 1;
  *(_DWORD *)(a1 + 3616) = 2;
  if (*(_BYTE *)(a1 + 3632)) {
    *(_BYTE *)(a1 + 3632) = 0;
  }
  uint64_t v4 = *(void ***)(a1 + 3648);
  __int128 v5 = *(void ***)(a1 + 3656);
  if (v5 == v4)
  {
    __int128 v8 = (void *)(a1 + 3680);
    __int128 v5 = *(void ***)(a1 + 3648);
  }

  else
  {
    unint64_t v6 = *(void *)(a1 + 3672);
    __int128 v7 = &v4[v6 / 0x49];
    __int128 v8 = (void *)(a1 + 3680);
    unint64_t v9 = (unint64_t)v4[(*(void *)(a1 + 3680) + v6) / 0x49] + 56 * ((*(void *)(a1 + 3680) + v6) % 0x49);
    if ((char *)*v7 + 56 * (v6 % 0x49) != (void *)v9)
    {
      unsigned int v10 = (void (***)(void))((char *)*v7 + 56 * (v6 % 0x49));
      do
      {
        uint64_t v11 = *v10;
        v10 += 7;
        (*v11)();
        if ((char *)v10 - (_BYTE *)*v7 == 4088)
        {
          int v12 = (void (***)(void))v7[1];
          ++v7;
          unsigned int v10 = v12;
        }
      }

      while (v10 != (void (***)(void))v9);
      __int128 v5 = *(void ***)(a1 + 3656);
      uint64_t v4 = *(void ***)(a1 + 3648);
    }
  }

  void *v8 = 0LL;
  unint64_t v13 = (char *)v5 - (char *)v4;
  if (v13 >= 0x11)
  {
    do
    {
      operator delete(*v4);
      uint64_t v4 = (void **)(*(void *)(a1 + 3648) + 8LL);
      *(void *)(a1 + 364_Block_object_dispose((const void *)(v1 - 112), 8) = v4;
      unint64_t v13 = *(void *)(a1 + 3656) - (void)v4;
    }

    while (v13 > 0x10);
  }

  if (v13 >> 3 == 1)
  {
    uint64_t v14 = 36LL;
  }

  else
  {
    if (v13 >> 3 != 2) {
      goto LABEL_32;
    }
    uint64_t v14 = 73LL;
  }

  *(void *)(a1 + 3672) = v14;
LABEL_32:
  *(_WORD *)(a1 + 368_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  if (*(_BYTE *)(a1 + 3728)) {
    *(_BYTE *)(a1 + 372_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  }
  if (*(_BYTE *)(a1 + 3744)) {
    *(_BYTE *)(a1 + 3744) = 0;
  }
  if (*(_BYTE *)(a1 + 3928)) {
    *(_BYTE *)(a1 + 392_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  }
  if (*(_BYTE *)(a1 + 3944)) {
    *(_BYTE *)(a1 + 3944) = 0;
  }
  if (*(_BYTE *)(a1 + 4392)) {
    *(_BYTE *)(a1 + 4392) = 0;
  }
  uint64_t v15 = *(void ***)(a1 + 3984);
  uint64_t v16 = *(void *)(a1 + 3992);
  *(void *)(a1 + 4016) = 0LL;
  unint64_t v17 = v16 - (void)v15;
  if (v17 >= 0x11)
  {
    do
    {
      operator delete(*v15);
      uint64_t v15 = (void **)(*(void *)(a1 + 3984) + 8LL);
      *(void *)(a1 + 3984) = v15;
      unint64_t v17 = *(void *)(a1 + 3992) - (void)v15;
    }

    while (v17 > 0x10);
  }

  if (v17 >> 3 == 1)
  {
    uint64_t v18 = 25LL;
  }

  else
  {
    if (v17 >> 3 != 2) {
      goto LABEL_49;
    }
    uint64_t v18 = 51LL;
  }

  *(void *)(a1 + 400_Block_object_dispose((const void *)(v1 - 112), 8) = v18;
LABEL_49:
  *(_BYTE *)(a1 + 4352) = 0;
  *(_OWORD *)(a1 + 3600) = xmmword_10042FF10;
  *(_BYTE *)(a1 + 3584) = 0;
  memset(v20, 0, sizeof(v20));
  sub_100300314((void *)(a1 + 4440), (uint64_t)v20);
  uint64_t result = sub_100030A5C(v20);
  if (*(_BYTE *)(a1 + 48)) {
    *(_BYTE *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  }
  return result;
}

void sub_1002FA31C(uint64_t a1, double a2, double a3, double a4)
{
  if (!*(_BYTE *)(a1 + 3688) && (!*(_BYTE *)(a1 + 3712) || a4 - *(double *)(a1 + 3704) > 0.5))
  {
    uint64_t v93 = 0x100000002LL;
    uint64_t v91 = &off_1007BCA98;
    __int128 v92 = xmmword_10042DEE0;
    uint64_t v94 = &v95;
    sub_1002CAEDC(&v91, 2, 1);
    sub_1002CAF28((uint64_t)&v91, 0.0);
    *(double *)sub_1002CB32C((uint64_t)&v91, 1u) = a2;
    *(double *)sub_1002CB32C((uint64_t)&v91, 0) = a3;
    sub_1002FAAE0((void *)(a1 + 3640), (uint64_t)&v91);
    *(double *)(a1 + 3704) = a4;
    *(_BYTE *)(a1 + 3712) = 1;
    unint64_t v8 = *(void *)(a1 + 3680);
    if ((double)v8 + (double)v8 > 100.0)
    {
      sub_1002FAB94((int64x2_t *)(a1 + 3640));
      unint64_t v8 = *(void *)(a1 + 3680);
    }

    uint64_t v88 = 0LL;
    unint64_t v89 = 0LL;
    unint64_t v90 = 0LL;
    sub_1002D58F0(&v88, v8);
    uint64_t v85 = 0x100000002LL;
    uint64_t v83 = &off_1007BCA98;
    __int128 v84 = xmmword_10042DEE0;
    uint64_t v86 = &v87;
    uint64_t v9 = *(void *)(a1 + 3648);
    if (*(void *)(a1 + 3656) != v9)
    {
      unint64_t v10 = *(void *)(a1 + 3672);
      uint64_t v11 = *(void *)(v9 + 8 * (v10 / 0x49)) + 56 * (v10 % 0x49);
      unint64_t v12 = *(void *)(v9 + 8 * ((*(void *)(a1 + 3680) + v10) / 0x49)) + 56 * ((*(void *)(a1 + 3680) + v10) % 0x49);
      if (v11 != v12)
      {
        unint64_t v13 = (void *)(v9 + 8 * (v10 / 0x49));
        do
        {
          double v14 = sub_1002405E4(v11, 0);
          *(double *)sub_1002CB32C((uint64_t)&v83, 0) = v14;
          double v15 = sub_1002405E4(v11, 1u);
          *(double *)sub_1002CB32C((uint64_t)&v83, 1u) = v15;
          unint64_t v16 = v89;
          if (v89 >= v90)
          {
            uint64_t v17 = sub_1002DA678(&v88, (uint64_t)&v83);
          }

          else
          {
            sub_1002DA48C(v89, (uint64_t)&v83);
            uint64_t v17 = v16 + 56;
          }

          unint64_t v89 = v17;
          v11 += 56LL;
          if (v11 - *v13 == 4088)
          {
            uint64_t v18 = v13[1];
            ++v13;
            uint64_t v11 = v18;
          }
        }

        while (v11 != v12);
      }
    }

    uint64_t v80 = 0x100000002LL;
    float64x2_t v78 = &off_1007BCA98;
    __int128 v79 = xmmword_10042DEE0;
    uint64_t v81 = &v82;
    sub_1002CAEDC(&v78, 2, 1);
    sub_1002CAF28((uint64_t)&v78, 0.0);
    uint64_t v19 = *(void *)(a1 + 3648);
    if (*(void *)(a1 + 3656) != v19)
    {
      unint64_t v20 = *(void *)(a1 + 3672);
      uint64_t v21 = *(void *)(v19 + 8 * (v20 / 0x49)) + 56 * (v20 % 0x49);
      unint64_t v22 = *(void *)(v19 + 8 * ((*(void *)(a1 + 3680) + v20) / 0x49))
          + 56 * ((*(void *)(a1 + 3680) + v20) % 0x49);
      if (v21 != v22)
      {
        double v23 = (void *)(v19 + 8 * (v20 / 0x49));
        do
        {
          uint64_t v75 = 0x100000002LL;
          char v73 = &off_1007BCA98;
          __int128 v74 = xmmword_10042DEE0;
          __int128 v76 = v77;
          sub_1002CC25C((uint64_t)&v78, v21, (uint64_t)&v73);
          sub_1002CBDC8((uint64_t)&v78, (uint64_t)&v73);
          v21 += 56LL;
          if (v21 - *v23 == 4088)
          {
            uint64_t v24 = v23[1];
            ++v23;
            uint64_t v21 = v24;
          }
        }

        while (v21 != v22);
      }
    }

    double v25 = (double)*(unint64_t *)(a1 + 3680);
    uint64_t v75 = 0x100000002LL;
    char v73 = &off_1007BCA98;
    __int128 v74 = xmmword_10042DEE0;
    __int128 v76 = v77;
    sub_1002DA040((uint64_t)&v78, (uint64_t)&v73, 1.0 / v25);
    sub_1002CBDC8((uint64_t)&v78, (uint64_t)&v73);
    uint64_t v26 = v88;
    if (v89 != v88)
    {
      uint64_t v27 = 0LL;
      unint64_t v28 = 0LL;
      do
      {
        uint64_t v75 = 0x100000002LL;
        char v73 = &off_1007BCA98;
        __int128 v74 = xmmword_10042DEE0;
        __int128 v76 = v77;
        sub_1002CB44C(v26 + v27, (uint64_t)&v78, (uint64_t)&v73);
        sub_1002CBDC8(v88 + v27, (uint64_t)&v73);
        ++v28;
        uint64_t v26 = v88;
        v27 += 56LL;
      }

      while (0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(v89 - v88) >> 3) > v28);
    }

    uint64_t v51 = a1;
    uint64_t v75 = 0x200000002LL;
    char v73 = &off_1007BCB28;
    __int128 v74 = xmmword_10042DF00;
    __int128 v76 = v77;
    sub_1002CAEDC(&v73, 2, 2);
    sub_1002CAF28((uint64_t)&v73, 0.0);
    uint64_t v29 = v88;
    unint64_t v30 = v89;
    if (v88 != v89)
    {
      while (1)
      {
        unsigned int v32 = *(_DWORD *)(v29 + 8);
        unsigned int v31 = *(_DWORD *)(v29 + 12);
        uint64_t v60 = 0x200000001LL;
        __int128 v61 = 0LL;
        unint64_t v58 = 0LL;
        uint64_t v59 = 0LL;
        __int128 v57 = &off_1007BCB70;
        if (v31 > 1) {
          break;
        }
        if (v32 >= 3)
        {
          int v47 = 423;
          __int16 v48 = "this->max_num_cols_ >= num_cols";
LABEL_59:
          __assert_rtn("SetMatrixSize", "cnmatrixbase.h", v47, v48);
        }

        unint64_t v58 = __PAIR64__(v32, v31);
        LODWORD(v59) = v32 * v31;
        HIDWORD(v59) = v31;
        __int128 v61 = v62;
        sub_1002CB364(v29, &v57);
        uint64_t v65 = 0x200000002LL;
        int8x16_t v63 = &off_1007BCB28;
        __int128 v64 = xmmword_10042DF00;
        double v66 = v67;
        sub_1002CB548(v29, (uint64_t)&v57, (uint64_t)&v63);
        uint64_t v70 = 0x200000002LL;
        char v68 = &off_1007BCB28;
        __int128 v69 = xmmword_10042DF00;
        int v71 = v72;
        sub_1002CC25C((uint64_t)&v73, (uint64_t)&v63, (uint64_t)&v68);
        sub_1002CBDC8((uint64_t)&v73, (uint64_t)&v68);
        v29 += 56LL;
        if (v29 == v30) {
          goto LABEL_28;
        }
      }

      int v47 = 422;
      __int16 v48 = "this->max_num_rows_ >= num_rows";
      goto LABEL_59;
    }

void sub_1002FAA68( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, void **a49)
{
  a49 = (void **)(v49 - 216);
  sub_1002DA2F4(&a49);
  _Unwind_Resume(a1);
}

void sub_1002FAAE0(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[1];
  uint64_t v5 = a1[2];
  uint64_t v6 = 73 * ((v5 - v4) >> 3) - 1;
  if (v5 == v4) {
    uint64_t v6 = 0LL;
  }
  if (v6 == a1[5] + a1[4])
  {
    sub_100300550(a1);
    uint64_t v4 = a1[1];
    uint64_t v5 = a1[2];
  }

  if (v5 == v4)
  {
    uint64_t v8 = 0LL;
  }

  else
  {
    unint64_t v7 = a1[5] + a1[4];
    uint64_t v8 = *(void *)(v4 + 8 * (v7 / 0x49)) + 56 * (v7 % 0x49);
  }

  sub_1002DA48C(v8, a2);
  ++a1[5];
}

uint64_t sub_1002FAB94(int64x2_t *a1)
{
  a1[2] = vaddq_s64(a1[2], (int64x2_t)xmmword_100422120);
  return sub_100300864((uint64_t)a1, 1);
}

void sub_1002FAC0C(uint64_t a1, const void *a2)
{
  if (!*(_BYTE *)(a1 + 832)) {
    sub_100006080();
  }
  float32x4_t v3 = *(float32x4_t *)(a1 + 784);
  v10[4] = *(float32x4_t *)(a1 + 768);
  void v10[5] = v3;
  float32x4_t v4 = *(float32x4_t *)(a1 + 816);
  v10[6] = *(float32x4_t *)(a1 + 800);
  v10[7] = v4;
  float32x4_t v5 = *(float32x4_t *)(a1 + 720);
  v10[0] = *(float32x4_t *)(a1 + 704);
  v10[1] = v5;
  float32x4_t v6 = *(float32x4_t *)(a1 + 752);
  double v10[2] = *(float32x4_t *)(a1 + 736);
  v10[3] = v6;
  sub_1002FACD8((uint64_t)__dst, v10, (uint64_t)v8);
  BYTE8(v9) = 1;
  *(void *)&__int128 v9 = 0x4034000000000000LL;
  _DWORD v7[2] = v8[2];
  v7[3] = v8[3];
  v7[0] = v8[0];
  v7[1] = v8[1];
  v7[4] = v9;
  sub_1002FAEEC(a1, (double *)v7);
}

void sub_1002FACD8(uint64_t a1@<X1>, float32x4_t *a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v6 = a2->i64[0];
  float32x4_t v29 = a2[1];
  float32x4_t v30 = a2[2];
  float32x4_t v27 = a2[4];
  float32x4_t v28 = a2[3];
  __int32 v7 = a2[5].i32[0];
  __int8 v8 = a2[5].i8[4];
  __int8 v9 = a2[5].i8[5];
  *(double *)&__int128 v10 = sub_1002CE658((float32x4_t)xmmword_100430180);
  uint64_t v11 = 0LL;
  v31[0] = v10;
  v31[1] = v12;
  v31[2] = v13;
  unsigned __int16 v31[3] = v14;
  do
  {
    *(float32x4_t *)((char *)&v32 + v11 * 16) = vmlaq_laneq_f32( vmlaq_laneq_f32( vmlaq_lane_f32( vmulq_n_f32(v29, COERCE_FLOAT(v31[v11])),  v30,  *(float32x2_t *)&v31[v11],  1),  v28,  (float32x4_t)v31[v11],  2),  v27,  (float32x4_t)v31[v11],  3);
    ++v11;
  }

  while (v11 != 4);
  float32x4_t v15 = v32;
  float32x4_t v16 = v33;
  float32x4_t v17 = v34;
  float32x4_t v18 = v35;
  v32.i64[0] = v6;
  float32x4_t v33 = v15;
  float32x4_t v34 = v16;
  float32x4_t v35 = v17;
  float32x4_t v36 = v18;
  __int32 v37 = v7;
  __int8 v38 = v8;
  __int8 v39 = v9;
  char v40 = 0;
  char v41 = 0;
  char v42 = 0;
  char v43 = 0;
  char v44 = 0;
  char v45 = 0;
  if (!*(_BYTE *)(a1 + 208)) {
    goto LABEL_7;
  }
  if (!*(_BYTE *)(a1 + 192)) {
    goto LABEL_7;
  }
  double v19 = *(double *)(a1 + 200);
  double v20 = *(float *)(a1 + 24);
  v46.columns[0] = (simd_float2)sub_1002CA7B4(&v32);
  simd_float2x2 v21 = __invert_f2(v46);
  *(_BYTE *)(a3 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a3 + 56) = 0;
  *(_BYTE *)(a3 + 64) = 0;
  *(_BYTE *)(a3 + 72) = 0;
  *(double *)a3 = v20;
  if (!*(_BYTE *)(a1 + 192)) {
LABEL_7:
  }
    sub_100006080();
  __double2 v22 = __sincos_stret(v19 * 3.14159265 / 180.0);
  float v23 = v22.__sinval * v20;
  float v24 = v22.__cosval * v20;
  float32x2_t v25 = vmla_n_f32(vmul_n_f32((float32x2_t)v21.columns[0], v24), (float32x2_t)v21.columns[1], v23);
  *(void *)(a3 + _Block_object_dispose((const void *)(v1 - 112), 8) = *(void *)(a1 + 16);
  float32x4_t v26 = a2[4];
  *(double *)(a3 + 32) = COERCE_FLOAT(a2[4].i64[1]);
  *(float64x2_t *)(a3 + 16) = vcvtq_f64_f32(*(float32x2_t *)v26.f32);
  *(double *)(a3 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = (float)(atan2f(v25.f32[0], v25.f32[1]) * 180.0) / 3.14159265;
  *(_BYTE *)(a3 + 56) = 1;
  *(void *)(a3 + 64) = *(void *)(a1 + 320);
  *(_BYTE *)(a3 + 72) = *(_BYTE *)(a1 + 328);
}

void sub_1002FAEEC(uint64_t a1, double *a2)
{
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

  *(_BYTE *)(a1 + 4352) = 0;
  double v4 = *(double *)(a1 + 176);
  v80[0] = 0.0;
  v80[1] = v4;
  char v81 = 0;
  *(_OWORD *)float64x2_t v78 = *(_OWORD *)(a1 + 136);
  char v79 = 0;
  __int128 v76 = xmmword_10042E660;
  char v77 = 0;
  if (*((_BYTE *)a2 + 72))
  {
    *((double *)&v76 + 1) = a2[8] * 3.14159265 / 180.0;
    *(_BYTE *)(a1 + 4352) = 1;
  }

  double v5 = *a2;
  if (*a2 >= 10.0)
  {
    if (v5 >= 20.0)
    {
      double v8 = 0.65;
      if (v5 >= 30.0)
      {
        if (v5 >= 40.0)
        {
          if (v5 >= 50.0)
          {
            double v6 = 7.64;
            double v7 = 9.58;
            double v8 = 1.08;
          }

          else
          {
            double v6 = 2.36;
            double v7 = 2.91;
            double v8 = 0.85;
          }
        }

        else
        {
          double v6 = 2.32;
          double v7 = 2.64;
        }
      }

      else
      {
        double v6 = 1.13;
        double v7 = 1.41;
      }
    }

    else
    {
      double v6 = 0.646;
      double v7 = 0.76;
      double v8 = 0.43;
    }
  }

  else
  {
    double v6 = 0.48;
    double v7 = 0.57;
    double v8 = 0.3;
  }

  double v9 = pow(v8 * (v5 - v6) / v7 + 1.0, -1.0 / v8);
  double v59 = exp(-v9);
  if (*(uint64_t *)(a1 + 32) >= 1)
  {
    uint64_t v10 = 0LL;
    uint64_t v11 = 0LL;
    double v58 = -v8;
    double v54 = v7;
    __int128 v57 = a2;
    double v55 = v8;
    double v56 = v6;
    do
    {
      double v12 = (double)sub_10012ACD8(a1 + 992);
      unsigned int v13 = sub_10012ACD8(a1 + 992);
      double v14 = log(v59 * (((v12 + (double)v13 * 4294967300.0) * 5.42101086e-20 * 6.28318 + 0.0) / 6.28318531));
      double v15 = pow(-v14, v58);
      if (*((_BYTE *)a2 + 56))
      {
        double v16 = a2[6] * 3.14159265 / 180.0;
        double v17 = sub_1003008C0((uint64_t)&v76, a1 + 992, (double *)&v76) + v16;
      }

      else
      {
        double v18 = (double)sub_10012ACD8(a1 + 992);
        double v17 = (v18 + (double)sub_10012ACD8(a1 + 992) * 4294967300.0) * 5.42101086e-20 * 6.28318 + 0.0;
      }

      double v19 = v6 + v7 * (v15 + -1.0) / v8;
      if (v19 >= *a2) {
        double v19 = *a2;
      }
      double v20 = *a2 - v19;
      double v21 = sub_1003008C0((uint64_t)v80, a1 + 992, v80);
      if (fabs(v21) > v20)
      {
        if (v20 <= 10.0) {
          double v22 = v20;
        }
        else {
          double v22 = 10.0;
        }
        double v23 = (double)sub_10012ACD8(a1 + 992);
        double v21 = -(v22
              - (v22 + v22) * ((v23 + (double)sub_10012ACD8(a1 + 992) * 4294967300.0) * 5.42101086e-20));
      }

      double v24 = 0.0;
      if (v20 != 0.0) {
        double v24 = asin(v21 / v20);
      }
      double v25 = a2[2];
      __double2 v26 = __sincos_stret(v17);
      double v27 = cos(v24);
      double v63 = a2[3];
      double v64 = a2[4];
      uint64_t v62 = *(void *)(a1 + 32);
      uint64_t v28 = *(int *)(a1 + 3616);
      double v29 = (double)sub_10012ACD8(a1 + 992);
      double v30 = (v29 + (double)sub_10012ACD8(a1 + 992) * 4294967300.0) * 5.42101086e-20;
      double v31 = 0.0;
      if (v30 + 0.0 <= v60)
      {
        int v36 = 0;
      }

      else
      {
        double v32 = *(double *)(a1 + 208);
        double v33 = v25;
        double v34 = (double)sub_10012ACD8(a1 + 992);
        double v35 = v34 + (double)sub_10012ACD8(a1 + 992) * 4294967300.0;
        double v25 = v33;
        double v31 = v32 + (v35 * 5.42101086e-20 * 6.28318 + 0.0) / 6.28318 * *(double *)(a1 + 216);
        int v36 = 1;
      }

      double v61 = sub_1003008C0((uint64_t)v78, a1 + 992, v78);
      unsigned int v37 = sub_10012ACD8(a1 + 992);
      unsigned int v38 = sub_10012ACD8(a1 + 992);
      unsigned int v39 = sub_10012ACD8(a1 + 992);
      unsigned int v40 = sub_10012ACD8(a1 + 992);
      double v41 = sub_1003008C0((uint64_t)v78, a1 + 992, v78);
      unsigned int v42 = sub_10012ACD8(a1 + 992);
      unsigned int v43 = sub_10012ACD8(a1 + 992);
      if (!*(_BYTE *)(a1 + 24)) {
        sub_100006080();
      }
      __double2 v44 = __sincos_stret(((double)v42 + (double)v43 * 4294967300.0) * 5.42101086e-20 * 6.28318 + 0.0);
      double v45 = exp(v41);
      double v46 = exp(v61);
      uint64_t v47 = *(void *)a1 + v10;
      *(double *)uint64_t v47 = v25 + v26.__cosval * v20 * v27;
      *(double *)(v47 + _Block_object_dispose((const void *)(v1 - 112), 8) = v21 + v63;
      *(double *)(v47 + 16) = v64 + v26.__sinval * v20 * v27;
      *(double *)(v47 + 24) = v31 * v44.__cosval;
      *(double *)(v47 + 32) = v31 * v44.__sinval;
      *(double *)(v47 + 40) = v31;
      *(double *)(v47 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = ((double)v37 + (double)v38 * 4294967300.0) * 5.42101086e-20 * 6.28318 + 0.0;
      *(double *)(v47 + 56) = ((double)v39 + (double)v40 * 4294967300.0) * 5.42101086e-20 * 6.28318 + 0.0;
      *(double *)(v47 + 64) = v46;
      *(double *)(v47 + 72) = v45;
      *(_DWORD *)(v47 + 80) = v36;
      *(double *)(v47 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = 1.0 / (double)v62;
      ++v11;
      v10 += 96LL;
      a2 = v57;
      double v8 = v55;
      double v6 = v56;
      double v7 = v54;
    }

    while (*(void *)(a1 + 32) > v11);
    double v5 = *v57;
  }

  sub_1002FD130(a1, (uint64_t)__p, v5, a2[2], a2[3], a2[4]);
  int v48 = *(unsigned __int8 *)(a1 + 664);
  __int128 v49 = v74;
  *(_OWORD *)(a1 + 616) = v73;
  *(_OWORD *)(a1 + 632) = v49;
  *(_OWORD *)(a1 + 64_Block_object_dispose((const void *)(v1 - 112), 8) = v75;
  __int128 v50 = v70;
  *(_OWORD *)(a1 + 552) = v69;
  *(_OWORD *)(a1 + 56_Block_object_dispose((const void *)(v1 - 112), 8) = v50;
  __int128 v51 = v72;
  *(_OWORD *)(a1 + 584) = v71;
  *(_OWORD *)(a1 + 600) = v51;
  __int128 v52 = v66;
  *(_OWORD *)(a1 + 48_Block_object_dispose((const void *)(v1 - 112), 8) = *(_OWORD *)__p;
  *(_OWORD *)(a1 + 504) = v52;
  __int128 v53 = v68;
  *(_OWORD *)(a1 + 520) = v67;
  *(_OWORD *)(a1 + 536) = v53;
  if (!v48) {
    *(_BYTE *)(a1 + 664) = 1;
  }
}

void sub_1002FB564( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, void *__p, uint64_t a28)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002FB580(uint64_t a1, void *__src)
{
  double v4 = (unsigned __int8 *)(a1 + 4208);
  if (*(_BYTE *)(a1 + 4296)
    && *(_BYTE *)(a1 + 4272)
    && *(_BYTE *)(a1 + 664)
    && (!*(_BYTE *)(a1 + 4088) || *(double *)(a1 + 560) <= *(double *)(a1 + 296)))
  {
    __int128 v5 = *(_OWORD *)(a1 + 4264);
    void v15[2] = *(_OWORD *)(a1 + 4248);
    v15[3] = v5;
    unsigned int v15[4] = *(_OWORD *)(a1 + 4280);
    __int128 v6 = *(_OWORD *)(a1 + 4232);
    v15[0] = *(_OWORD *)(a1 + 4216);
    v15[1] = v6;
    sub_1002FAEEC(a1, (double *)v15);
    v4[144] = 1;
  }

  if (*((_BYTE *)__src + 208) && *((_BYTE *)__src + 328))
  {
    if (*(_BYTE *)(a1 + 832))
    {
      memcpy(__dst, __src, 0x180uLL);
      float32x4_t v7 = *(float32x4_t *)(a1 + 784);
      void v16[4] = *(float32x4_t *)(a1 + 768);
      void v16[5] = v7;
      float32x4_t v8 = *(float32x4_t *)(a1 + 816);
      int v16[6] = *(float32x4_t *)(a1 + 800);
      v16[7] = v8;
      float32x4_t v9 = *(float32x4_t *)(a1 + 720);
      v16[0] = *(float32x4_t *)(a1 + 704);
      v16[1] = v9;
      float32x4_t v10 = *(float32x4_t *)(a1 + 752);
      void v16[2] = *(float32x4_t *)(a1 + 736);
      v16[3] = v10;
      sub_1002FACD8((uint64_t)__dst, v16, (uint64_t)v14);
      int v11 = *v4;
      __int128 v12 = v14[0];
      *(_OWORD *)(a1 + 4144) = v14[1];
      __int128 v13 = v14[3];
      *(_OWORD *)(a1 + 4160) = v14[2];
      *(_OWORD *)(a1 + 4176) = v13;
      *(_OWORD *)(a1 + 4192) = v14[4];
      *(_OWORD *)(a1 + 412_Block_object_dispose((const void *)(v1 - 112), 8) = v12;
      if (!v11) {
        *double v4 = 1;
      }
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT))
  {
    sub_1003AABA4();
  }

void sub_1002FB6FC(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0LL;
  *(_BYTE *)(a2 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a2 + 192) = 0;
  *(_BYTE *)(a2 + 200) = 0;
  *(_BYTE *)(a2 + 20_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a2 + 216) = 0;
  *(_BYTE *)(a2 + 224) = 0;
  *(_DWORD *)(a2 + 232) = 0;
  *(_BYTE *)(a2 + 240) = 0;
  *(_BYTE *)(a2 + 24_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a2 + 256) = 0;
  *(_BYTE *)(a2 + 272) = 0;
  *(_BYTE *)(a2 + 28_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a2 + 304) = 0;
  *(_BYTE *)(a2 + 320) = 0;
  *(_BYTE *)(a2 + 32_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a2 + 336) = 0;
  *(_BYTE *)(a2 + 344) = 0;
  *(_WORD *)(a2 + 352) = 0;
  *(_BYTE *)(a2 + 356) = 0;
  *(_BYTE *)(a2 + 360) = 0;
  *(_BYTE *)(a2 + 364) = 0;
  *(_BYTE *)(a2 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a2 + 372) = 0;
  *(_BYTE *)(a2 + 376) = 0;
  *(_WORD *)(a2 + 380) = 0;
  if (!*(_BYTE *)(a1 + 664) || !*(_BYTE *)(a1 + 832)) {
    return;
  }
  *(_DWORD *)(a2 + 364) = 5;
  *(_BYTE *)(a2 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
  if (*(_BYTE *)(a1 + 3728))
  {
    double v4 = *(double *)(a1 + 3720);
    if (*(_BYTE *)(a1 + 688) && v4 - *(double *)(a1 + 680) > *(double *)(a1 + 344) + 1.38)
    {
      __int128 v5 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_particlefilter,PF reset due to timeout calculated from current time during getFilterSolution",  buf,  2u);
      }

      sub_1002FA034(a1);
      return;
    }

    double v6 = *(double *)(a1 + 584);
    if (*(_BYTE *)(a1 + 3944))
    {
      double v7 = atan2((v4 - *(double *)(a1 + 3936)) * 0.65, *(double *)(a1 + 560)) * 180.0 / 3.14159265;
      double v8 = sqrt(v7 * v7 + v6 * v6);
      float32x4_t v9 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 134218496;
        *(double *)&uint8_t buf[4] = v8;
        *(_WORD *)&_BYTE buf[12] = 2048;
        *(double *)&buf[14] = v6;
        *(_WORD *)&_BYTE buf[22] = 2048;
        *(void *)&_BYTE buf[24] = fabs(v7);
        _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "#sa_algo_particlefilter,total arrow unc: %f, estimator arrow unc: %f, arrow unc from gap between current time and last motion update: %f",  buf,  0x20u);
      }
    }

    else
    {
      double v8 = *(double *)(a1 + 584);
    }

    *(double *)(a2 + 320) = v8;
    *(_BYTE *)(a2 + 32_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
    double v10 = *(double *)(a1 + 288);
    if (*(_BYTE *)(a1 + 4088)) {
      double v10 = v10 + *(double *)(a1 + 4096);
    }
    *(_BYTE *)(a1 + 408_Block_object_dispose((const void *)(v1 - 112), 8) = v8 <= v10;
    if (v8 <= v10)
    {
      if (!*(_BYTE *)(a1 + 664)) {
        goto LABEL_54;
      }
      if (*(double *)(a1 + 560) > *(double *)(a1 + 296))
      {
        if (!*(_BYTE *)(a1 + 832)) {
          goto LABEL_54;
        }
        float32x4_t v42 = *(float32x4_t *)(a1 + 768);
        double v12 = *(double *)(a1 + 488);
        double v11 = *(double *)(a1 + 496);
        *(double *)(a2 + 200) = atan2(v11 - v42.f32[2], v12 - v42.f32[0]) * 180.0 / 3.14159265;
        *(_BYTE *)(a2 + 20_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
        float64x2_t v43 = (float64x2_t)*(unint64_t *)&v12;
        double v44 = v11;
        uint64_t v13 = *(void *)(a1 + 704);
        float32x4_t v40 = *(float32x4_t *)(a1 + 736);
        float32x4_t v41 = *(float32x4_t *)(a1 + 720);
        float32x4_t v39 = *(float32x4_t *)(a1 + 752);
        int v14 = *(_DWORD *)(a1 + 784);
        char v15 = *(_BYTE *)(a1 + 788);
        char v16 = *(_BYTE *)(a1 + 789);
        *(double *)&__int128 v17 = sub_1002CE658((float32x4_t)xmmword_100430180);
        uint64_t v18 = 0LL;
        v45[0] = v17;
        v45[1] = v19;
        v45[2] = v20;
        v45[3] = v21;
        do
        {
          *(float32x4_t *)&buf[v18 * 16] = vmlaq_laneq_f32( vmlaq_laneq_f32( vmlaq_lane_f32( vmulq_n_f32(v41, COERCE_FLOAT(v45[v18])),  v40,  *(float32x2_t *)&v45[v18],  1),  v39,  (float32x4_t)v45[v18],  2),  v42,  (float32x4_t)v45[v18],  3);
          ++v18;
        }

        while (v18 != 4);
        __int128 v22 = *(_OWORD *)buf;
        __int128 v23 = *(_OWORD *)&buf[16];
        __int128 v24 = v47;
        __int128 v25 = v48;
        *(void *)__int128 buf = v13;
        *(_OWORD *)&uint8_t buf[16] = v22;
        __int128 v47 = v23;
        __int128 v48 = v24;
        __int128 v49 = v25;
        int v50 = v14;
        char v51 = v15;
        char v52 = v16;
        char v53 = 0;
        char v54 = 0;
        char v55 = 0;
        char v56 = 0;
        char v57 = 0;
        char v58 = 0;
        sub_1002C9108(&v43, (float32x4_t *)buf, (uint64_t)v45);
        *(double *)(a2 + 200) = (float)(*((float *)v45 + 1) * 180.0) / 3.14159265;
        *(_BYTE *)(a2 + 20_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
      }
    }

    if (*(_BYTE *)(a1 + 832))
    {
      *(double *)&uint64_t v26 = COERCE_DOUBLE(sub_1002FBC8C(a1, (uint64_t *)(a1 + 704)));
      if (v27)
      {
        double v28 = *(double *)&v26;
      }

      else
      {
        if (!*(_BYTE *)(a1 + 664)) {
          goto LABEL_54;
        }
        double v28 = *(double *)(a1 + 560);
      }

      if (*(_BYTE *)(a1 + 832) && *(_BYTE *)(a1 + 664))
      {
        double v29 = *(double *)(a1 + 616);
        if (*(_BYTE *)(a2 + 208))
        {
          *(_DWORD *)a2 = 1;
        }

        else if (*(_BYTE *)(a1 + 3689))
        {
          *(_BYTE *)(a2 + 5) = 1;
        }

        else if (!*(_BYTE *)(a1 + 3688))
        {
          *(_BYTE *)(a2 + 4) = 1;
        }

        uint64_t v30 = *(void *)(a1 + 704);
        float v31 = v28;
        double v32 = sqrt(v29);
        double v33 = *(float *)(a1 + 772);
        double v34 = *(double *)(a1 + 656) - v33;
        if (v34 > 10.0) {
          double v34 = 10.0;
        }
        double v35 = *(double *)(a1 + 648);
        if (v35 <= 0.95)
        {
          if (v35 >= 0.05) {
            goto LABEL_50;
          }
          *(_DWORD *)(a2 + 232) = 1;
          *(double *)(a2 + 240) = *(double *)(a1 + 504) - v33;
        }

        else
        {
          double v36 = *(double *)(a1 + 504) - v33;
          if (v36 <= 2.5)
          {
            if (v36 >= -2.5)
            {
              *(_DWORD *)(a2 + 232) = 4;
LABEL_50:
              int v38 = *(unsigned __int8 *)(a2 + 192);
              *(void *)(a2 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
              *(void *)(a2 + 16) = v30;
              *(float *)(a2 + 24) = v31;
              *(_DWORD *)(a2 + 2_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
              *(_BYTE *)(a2 + 56) = 0;
              *(void *)(a2 + 32) = 0LL;
              *(void *)(a2 + 40) = 0LL;
              *(_BYTE *)(a2 + 60) = 0;
              *(_BYTE *)(a2 + 64) = 0;
              *(_BYTE *)(a2 + 6_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
              *(void *)(a2 + 72) = 0LL;
              *(void *)(a2 + 80) = 0LL;
              *(_WORD *)(a2 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
              *(void *)(a2 + 96) = 0LL;
              *(void *)(a2 + 104) = 0LL;
              *(double *)(a2 + 112) = v32;
              *(_BYTE *)(a2 + 136) = 0;
              *(void *)(a2 + 120) = 1LL;
              *(void *)(a2 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
              *(_BYTE *)(a2 + 160) = 0;
              *(void *)(a2 + 176) = 0LL;
              *(void *)(a2 + 184) = 0LL;
              *(void *)(a2 + 16_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
              if (!v38) {
                *(_BYTE *)(a2 + 192) = 1;
              }
              return;
            }

            int v37 = 3;
          }

          else
          {
            int v37 = 2;
          }

          *(_DWORD *)(a2 + 232) = v37;
          *(double *)(a2 + 240) = v36;
        }

        *(_BYTE *)(a2 + 24_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
        goto LABEL_50;
      }
    }

uint64_t sub_1002FBC8C(uint64_t a1, uint64_t *a2)
{
  if (*(_BYTE *)(a1 + 24))
  {
    BOOL v2 = !byte_1007FEE28 || byte_1007FEE18 == 0;
    if (v2 || *(double *)a2 - *(double *)&qword_1007FEE10 > dbl_10042DD50[*(_BYTE *)(a1 + 4432) == 0])
    {
      if (!*(_BYTE *)(a1 + 832)) {
        sub_100006080();
      }
      float32x4_t v3 = *(double **)a1;
      double v4 = *(double **)(a1 + 8);
      if (*(double **)a1 == v4)
      {
        double v5 = 0.0;
      }

      else
      {
        double v5 = 0.0;
        do
        {
          double v5 = v5
             + sqrt( (v3[1] - *(float *)(a1 + 772)) * (v3[1] - *(float *)(a1 + 772))
               + (*v3 - *(float *)(a1 + 768)) * (*v3 - *(float *)(a1 + 768))
          v3 += 12;
        }

        while (v3 != v4);
      }

      qword_1007FEE20 = *(void *)&v5;
      byte_1007FEE28 = 1;
      qword_1007FEE10 = *a2;
      byte_1007FEE18 = 1;
    }
  }

  return qword_1007FEE20;
}

uint64_t sub_1002FBD8C(uint64_t a1, uint64_t *a2)
{
  int v3 = *(_DWORD *)(a1 + 4104);
  *(_DWORD *)(a1 + 4104) = *((_DWORD *)a2 + 20);
  uint64_t v4 = a2[11];
  *(_BYTE *)(a1 + 4120) = *((_BYTE *)a2 + 96);
  *(void *)(a1 + 4112) = v4;
  int v5 = *((_DWORD *)a2 + 20);
  if (v3 != v5)
  {
    if (v5 == 2)
    {
      double v6 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = *a2;
        int v18 = 134217984;
        uint64_t v19 = v9;
        double v8 = "#sa_algo_particlefilter,VIO Tracking State changed to Normal at %f s";
LABEL_11:
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&v18, 0xCu);
      }
    }

    else
    {
      if (v5 != 1)
      {
        if (v5) {
          return 0LL;
        }
        double v6 = (os_log_s *)qword_1008000A0;
        if (!os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_12;
        }
        uint64_t v7 = *a2;
        int v18 = 134217984;
        uint64_t v19 = v7;
        double v8 = "#sa_algo_particlefilter,VIO Tracking State changed to Not Available at %f s";
        goto LABEL_11;
      }

      double v6 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v10 = *a2;
        int v18 = 134217984;
        uint64_t v19 = v10;
        double v8 = "#sa_algo_particlefilter,VIO Tracking State changed to Limited at %f s";
        goto LABEL_11;
      }
    }

void sub_1002FC004(uint64_t a1, double a2, double a3, double a4, double a5)
{
  if (!*(_BYTE *)(a1 + 24) || !*(_BYTE *)(a1 + 153))
  {
    *(double *)(a1 + 3736) = a4;
    *(_BYTE *)(a1 + 3744) = 1;
    return;
  }

  uint64_t v10 = (_BYTE *)(a1 + 4392);
  if (*(_BYTE *)(a1 + 4392)) {
    _BYTE *v10 = 0;
  }
  double v11 = *(void ***)(a1 + 4032);
  uint64_t v12 = *(void *)(a1 + 4040);
  *(void *)(a1 + 4064) = 0LL;
  unint64_t v13 = v12 - (void)v11;
  if (v13 >= 0x11)
  {
    do
    {
      operator delete(*v11);
      double v11 = (void **)(*(void *)(a1 + 4032) + 8LL);
      *(void *)(a1 + 4032) = v11;
      unint64_t v13 = *(void *)(a1 + 4040) - (void)v11;
    }

    while (v13 > 0x10);
  }

  if (v13 >> 3 == 1)
  {
    uint64_t v14 = 64LL;
    goto LABEL_12;
  }

  if (v13 >> 3 == 2)
  {
    uint64_t v14 = 128LL;
LABEL_12:
    *(void *)(a1 + 4056) = v14;
  }

  if (*(_DWORD *)(a1 + 3616) == 2)
  {
    int v15 = 1;
    *(_DWORD *)(a1 + 3972) = 1;
  }

  else
  {
    int v15 = 0;
  }

  *(_DWORD *)(a1 + 396_Block_object_dispose((const void *)(v1 - 112), 8) = v15;
  char v16 = (os_log_s *)qword_1008000A0;
  double v17 = a3 / a5;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134219008;
    *(double *)&uint8_t buf[4] = a5;
    *(_WORD *)&_BYTE buf[12] = 2048;
    *(double *)&buf[14] = a2;
    *(_WORD *)&_BYTE buf[22] = 2048;
    *(double *)&_BYTE buf[24] = a3;
    *(_WORD *)char v27 = 2048;
    *(double *)&_DWORD v27[2] = a2 / a5;
    *(_WORD *)&_BYTE v27[10] = 2048;
    *(double *)&v27[12] = a3 / a5;
    _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_particlefilter,ingesting peer kinematic data: deltaT: %f, delta Vh1: %f, delta Vh2: %f, accel H1: %f, accel H2: %f ",  buf,  0x34u);
  }

  double v18 = *(double *)(a1 + 232);
  v24[0] = 0.0;
  v24[1] = v18;
  char v25 = 0;
  if (!*(_BYTE *)(a1 + 24)) {
    sub_100006080();
  }
  double v19 = *(double *)a1;
  uint64_t v20 = *(void *)(a1 + 8);
  if (*(void *)a1 != v20)
  {
    while (*(_DWORD *)(a1 + 3616) != 2)
    {
      if (!*(_DWORD *)(*(void *)&v19 + 80LL))
      {
        double v21 = **(double **)&v19;
        **(double **)&double v19 = v21 + sub_1003008C0((uint64_t)v24, a1 + 992, v24);
        double v22 = *(double *)(*(void *)&v19 + 16LL);
        *(double *)(*(void *)&v19 + 16LL) = v22 + sub_1003008C0((uint64_t)v24, a1 + 992, v24);
        goto LABEL_27;
      }

      if (*(_BYTE *)(a1 + 3928))
      {
        sub_1002FC4A8((double *)a1, *(uint64_t *)&v19, (uint64_t)buf, a4 - *(double *)(a1 + 3920));
        goto LABEL_25;
      }

double sub_1002FC32C@<D0>( double *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>, double a5@<D1>, double a6@<D2>)
{
  double v12 = sqrt(a4 / 0.1);
  v29[1] = a1[31];
  v27[1] = v12 * a1[33];
  __int128 v13 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a3 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a3 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v13;
  __int128 v14 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a3 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a3 + 80) = v14;
  __int128 v15 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a3 = *(_OWORD *)a2;
  *(_OWORD *)(a3 + 16) = v15;
  *(void *)&__int128 v13 = *(void *)(a2 + 16);
  double v16 = *(double *)a2 + a4 * *(double *)(a2 + 24);
  v29[0] = 0.0;
  char v30 = 0;
  v27[0] = 0.0;
  char v28 = 0;
  *(double *)a3 = v16;
  *(double *)(a3 + 16) = *(double *)&v13 + a4 * *(double *)(a2 + 32);
  uint64_t v17 = (uint64_t)(a1 + 124);
  double v18 = sub_1003008C0((uint64_t)v29, (uint64_t)(a1 + 124), v29) + a5;
  double v19 = sub_1003008C0((uint64_t)v29, v17, v29) + a6;
  __double2 v20 = __sincos_stret(*(double *)(a2 + 56));
  double v21 = *(double *)(a2 + 24) + a4 * (v20.__cosval * v19 - v20.__sinval * v18);
  double v22 = *(double *)(a2 + 32) + a4 * (v18 * v20.__cosval + v20.__sinval * v19);
  *(double *)(a3 + 24) = v21;
  *(double *)(a3 + 32) = v22;
  double v23 = sqrt(v22 * v22 + v21 * v21);
  if (v23 >= a1[32])
  {
    *(double *)(a3 + 24) = v21 / v23;
    *(double *)(a3 + 32) = v22 / v23;
  }

  *(double *)(a3 + 56) = sub_1003008C0((uint64_t)v27, v17, v27) + *(double *)(a3 + 56);
  double v24 = v12 * a1[13];
  v31[0] = 0.0;
  v31[1] = v24;
  char v32 = 0;
  double v25 = *(double *)(a3 + 8);
  double result = v25 + sub_1003008C0((uint64_t)v31, v17, v31);
  *(double *)(a3 + _Block_object_dispose((const void *)(v1 - 112), 8) = result;
  return result;
}

uint64_t sub_1002FC4A8@<X0>(double *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  double v8 = a1[30];
  v27[0] = 0.0;
  v27[1] = v8;
  char v28 = 0;
  double v9 = a1[33];
  v25[0] = 0.0;
  v25[1] = v9;
  char v26 = 0;
  uint64_t v24 = 0x200000000LL;
  __int128 v10 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a3 = *(_OWORD *)a2;
  *(_OWORD *)(a3 + 16) = v10;
  __int128 v11 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a3 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a3 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v11;
  __int128 v12 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a3 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a3 + 80) = v12;
  double v13 = *(double *)a2;
  double v14 = *(double *)(a2 + 40) * a4;
  __double2 v15 = __sincos_stret(*(double *)(a2 + 48));
  *(double *)a3 = v13 + v14 * v15.__cosval;
  *(double *)(a3 + 16) = *(double *)(a2 + 16) + v14 * v15.__sinval;
  double v16 = sqrt(a4 / 0.1) * a1[13];
  v29[0] = 0.0;
  v29[1] = v16;
  char v30 = 0;
  double v17 = *(double *)(a3 + 8);
  *(double *)(a3 + _Block_object_dispose((const void *)(v1 - 112), 8) = v17 + sub_1003008C0((uint64_t)v29, (uint64_t)(a1 + 124), v29);
  double v18 = sub_1003008C0((uint64_t)v27, (uint64_t)(a1 + 124), v27);
  double v19 = sub_1003008C0((uint64_t)v25, (uint64_t)(a1 + 124), v25) + *(double *)(a2 + 48);
  *(double *)(a3 + 40) = v18 + *(double *)(a2 + 40);
  *(double *)(a3 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v19;
  double v20 = (double)sub_10012ACD8((uint64_t)(a1 + 124));
  uint64_t result = sub_10012ACD8((uint64_t)(a1 + 124));
  double v22 = (v20 + (double)result * 4294967300.0) * 5.42101086e-20;
  double v23 = 0.0;
  if (v22 + 0.0 < a1[34])
  {
    uint64_t result = sub_100142850((uint64_t)&v24, (uint64_t)(a1 + 124), &v24);
    *(double *)(a3 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v23 + *(double *)(a2 + 48);
  }

  return result;
}

void sub_1002FC648(uint64_t a1, __int128 *a2)
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003AABFC();
  }
  sub_10030C89C((int64x2_t *)(a1 + 4440), a2);
}

double sub_1002FC6A8(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a2 + 16))
  {
    uint64_t v4 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
      sub_1003AAC28((void *)a2, v4, v5);
    }
    if (!*(_BYTE *)(a2 + 152)) {
      goto LABEL_8;
    }
    int8x16_t v6 = (int8x16_t)vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(a2 + 120)), *(float64x2_t *)(a2 + 136));
    *(double *)&__int128 v7 = sub_1002CE658((float32x4_t)vextq_s8(v6, v6, 4uLL));
    *(_OWORD *)(a1 + 720) = v7;
    *(_OWORD *)(a1 + 736) = v8;
    *(_OWORD *)(a1 + 752) = v9;
    *(_DWORD *)(a1 + 816) = 1;
    *(_BYTE *)(a1 + 820) = 1;
    *(_DWORD *)(a1 + 80_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
    *(_BYTE *)(a1 + 812) = 1;
    if (!*(_BYTE *)(a2 + 16)) {
LABEL_8:
    }
      sub_100006080();
    double result = *(double *)(a2 + 8);
    *(double *)(a1 + 704) = result;
  }

  return result;
}

void sub_1002FC754(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 24) && *(_BYTE *)(a2 + 80) && *(_BYTE *)(a2 + 96) && *(_BYTE *)(a2 + 112))
  {
    uint64_t v4 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v18 = *(void *)(a2 + 120);
      uint64_t v19 = *(void *)(a2 + 128);
      uint64_t v20 = *(void *)(a2 + 136);
      uint64_t v21 = *(void *)(a2 + 144);
      *(_DWORD *)double v22 = 134218752;
      *(void *)&int v22[4] = v18;
      *(_WORD *)&v22[12] = 2048;
      *(void *)&v22[14] = v19;
      __int16 v23 = 2048;
      uint64_t v24 = v20;
      __int16 v25 = 2048;
      uint64_t v26 = v21;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "#sa_algo_particlefilter,ingesting delayed spliced finder deltav IO data: quatw: %f, quatx: %f, quaty: %f, quatz: %f",  v22,  0x2Au);
      if (!*(_BYTE *)(a2 + 80) || !*(_BYTE *)(a2 + 112)) {
        goto LABEL_21;
      }
    }

    double v5 = *(double *)(a2 + 72);
    double v6 = *(double *)(a2 + 104);
    __int128 v7 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
      sub_1003AACB8(v7, v5, v6);
    }
    uint64_t v8 = *(void *)(a1 + 248);
    *(void *)double v22 = 0LL;
    *(void *)&v22[8] = v8;
    LOBYTE(v24) = 0;
    if (!*(_BYTE *)(a1 + 24)) {
LABEL_21:
    }
      sub_100006080();
    __int128 v9 = *(double **)(a1 + 8);
    if (*(double **)a1 != v9)
    {
      double v10 = v5 / 0.1;
      __int128 v11 = (double *)(*(void *)a1 + 32LL);
      double v12 = v6 / 0.1;
      do
      {
        if (*(_BYTE *)(a1 + 80) && !*(_BYTE *)(a1 + 88))
        {
          double v13 = *(double **)(a1 + 56);
          *(v11 - 1) = *(v11 - 1) - *v13;
          *__int128 v11 = *v11 - v13[2];
        }

        double v14 = v11 - 4;
        double v15 = *(v11 - 2);
        *(v11 - 4) = *(v11 - 4) + *(v11 - 1) * 0.1;
        *(v11 - 2) = v15 + *v11 * 0.1;
        double v16 = v10 + sub_1003008C0((uint64_t)v22, a1 + 992, (double *)v22);
        double v17 = *v11 + (v12 + sub_1003008C0((uint64_t)v22, a1 + 992, (double *)v22)) * -0.1;
        *(v11 - 1) = *(v11 - 1) + v16 * -0.1;
        *__int128 v11 = v17;
        v11 += 12;
      }

      while (v14 + 12 != v9);
    }

    if (*(_BYTE *)(a1 + 80))
    {
      if (!*(_BYTE *)(a1 + 88)) {
        *(_BYTE *)(a1 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
      }
    }
  }

void sub_1002FC9A4(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a2 + 128))
  {
    sub_1002FCC18(a1, *(double *)a2);
    if (!*(_BYTE *)(a2 + 128)) {
      goto LABEL_30;
    }
    sub_1002FCF34(a1, (float *)a2);
    if (*(_BYTE *)(a2 + 116) && !*(_DWORD *)(a2 + 112) && (v4 & 1) == 0)
    {
      sub_1002FA034(a1);
      return;
    }

    if (v4)
    {
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
        sub_1003AAE78();
      }
      *(void *)(a1 + 40) = *(void *)a2;
      *(_BYTE *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
      if (*(_BYTE *)(a1 + 832))
      {
        double v5 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
          sub_1003AAE08(a1, v5, v6, v7, v8, v9, v10);
        }
      }
    }
  }

  char v11 = *(_BYTE *)(a2 + 272);
  if (v11)
  {
    uint64_t v12 = qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
      sub_1003AADC0(v12, (_BYTE *)(a2 + 272));
    }
    sub_1002FC648(a1, (__int128 *)(a2 + 144));
    char v11 = *(_BYTE *)(a2 + 272) != 0;
  }

  if (!*(_BYTE *)(a2 + 128) && (v11 & 1) == 0)
  {
    if (!*(_BYTE *)(a1 + 48))
    {
LABEL_25:
      if (*(_BYTE *)(a1 + 832))
      {
        __int128 v14 = *(_OWORD *)(a2 + 400);
        v31[6] = *(_OWORD *)(a2 + 384);
        v31[7] = v14;
        __int128 v15 = *(_OWORD *)(a2 + 432);
        v31[8] = *(_OWORD *)(a2 + 416);
        v31[9] = v15;
        __int128 v16 = *(_OWORD *)(a2 + 336);
        v31[2] = *(_OWORD *)(a2 + 320);
        double v31[3] = v16;
        __int128 v17 = *(_OWORD *)(a2 + 368);
        _OWORD v31[4] = *(_OWORD *)(a2 + 352);
        v31[5] = v17;
        __int128 v18 = *(_OWORD *)(a2 + 304);
        v31[0] = *(_OWORD *)(a2 + 288);
        v31[1] = v18;
        sub_1002FC6A8(a1, (uint64_t)v31);
        __int128 v19 = *(_OWORD *)(a2 + 560);
        v30[6] = *(_OWORD *)(a2 + 544);
        v30[7] = v19;
        __int128 v20 = *(_OWORD *)(a2 + 592);
        _BYTE v30[8] = *(_OWORD *)(a2 + 576);
        double v30[9] = v20;
        __int128 v21 = *(_OWORD *)(a2 + 496);
        v30[2] = *(_OWORD *)(a2 + 480);
        void v30[3] = v21;
        __int128 v22 = *(_OWORD *)(a2 + 528);
        v30[4] = *(_OWORD *)(a2 + 512);
        v30[5] = v22;
        __int128 v23 = *(_OWORD *)(a2 + 464);
        v30[0] = *(_OWORD *)(a2 + 448);
        v30[1] = v23;
        sub_1002FC754(a1, (uint64_t)v30);
        if (*(_BYTE *)(a1 + 832))
        {
          uint64_t v24 = (os_log_s *)qword_1008000A0;
          if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
            sub_1003AAD50(a1, v24, v25, v26, v27, v28, v29);
          }
        }
      }

      return;
    }

    if (*(_BYTE *)(a1 + 3728))
    {
      if (*(double *)(a1 + 3720) - *(double *)(a1 + 40) > 7.0)
      {
        double v13 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_particlefilter,reinitializing PF due to finder delta V timeout",  buf,  2u);
        }

        sub_1002FA034(a1);
      }

      goto LABEL_25;
    }

void sub_1002FCC18(uint64_t a1, double a2)
{
  if (!*(_BYTE *)(a1 + 3728) || *(double *)(a1 + 3720) < a2)
  {
    *(double *)(a1 + 3720) = a2;
    *(_BYTE *)(a1 + 372_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
    uint64_t v4 = *(void *)(a1 + 4016);
    if (v4)
    {
      unint64_t v5 = *(void *)(a1 + 4008);
      uint64_t v6 = *(void *)(*(void *)(a1 + 3984) + 8 * (v5 / 0x33));
      double v7 = *(double *)(v6 + 80 * (v5 % 0x33) + 8);
      if (a2 - v7 > 1.38)
      {
        double v8 = (uint64_t *)(v6 + 80 * (v5 % 0x33));
        double v9 = *(double *)v8;
        double v10 = *((double *)v8 + 2);
        double v11 = *((double *)v8 + 3);
        double v12 = *((double *)v8 + 4);
        int v13 = *((_DWORD *)v8 + 10);
        __int128 v14 = *(_OWORD *)((char *)v8 + 60);
        __int128 v27 = *(_OWORD *)((char *)v8 + 44);
        __int128 v28 = v14;
        int v29 = *((_DWORD *)v8 + 19);
        *(void *)(a1 + 4016) = v4 - 1;
        *(void *)(a1 + 400_Block_object_dispose((const void *)(v1 - 112), 8) = v5 + 1;
        sub_100126000(a1 + 3976, 1);
        __int128 v15 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 134218496;
          double v31 = v9;
          __int16 v32 = 2048;
          double v33 = v7;
          __int16 v34 = 2048;
          double v35 = a2;
          _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_particlefilter,ingesting measurement,  range: %f, range time: %f, current time: %f",  buf,  0x20u);
        }

        v16.n128_f64[0] = v7;
        sub_10030C984((void *)(a1 + 4440), (uint64_t)buf, v16);
        if (v45 && v44 && v43 == 1)
        {
          int v13 = 0;
          double v10 = v40;
          double v11 = v41;
          double v12 = v42;
        }

        else if (*(_BYTE *)(a1 + 3544) && *(_BYTE *)(a1 + 3576) && *(_BYTE *)(a1 + 3560))
        {
          int v13 = 1;
        }

        *(double *)__int128 v22 = v9;
        *(double *)&v22[1] = v7;
        *(double *)&v22[2] = v10;
        *(double *)&v22[3] = v11;
        *(double *)&int v22[4] = v12;
        int v23 = v13;
        __int128 v24 = v27;
        __int128 v25 = v28;
        int v26 = v29;
        sub_1002FDA7C(a1, (uint64_t)v22);
      }
    }

    uint64_t v17 = *(void *)(a1 + 4064);
    if (v17)
    {
      unint64_t v18 = *(void *)(a1 + 4056);
      __int128 v19 = (double *)(*(void *)(*(void *)(a1 + 4032) + ((v18 >> 4) & 0xFFFFFFFFFFFFFF8LL)) + 32 * (v18 & 0x7F));
      if (a2 - *v19 > 1.38)
      {
        __int128 v20 = *((_OWORD *)v19 + 1);
        __int128 v27 = *(_OWORD *)v19;
        __int128 v28 = v20;
        *(void *)(a1 + 4064) = v17 - 1;
        *(void *)(a1 + 4056) = v18 + 1;
        sub_10030164C(a1 + 4024, 1);
        __int128 v21 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 134219008;
          double v31 = *((double *)&v27 + 1);
          __int16 v32 = 2048;
          double v33 = *(double *)&v28;
          __int16 v34 = 2048;
          double v35 = *((double *)&v28 + 1);
          __int16 v36 = 2048;
          uint64_t v37 = v27;
          __int16 v38 = 2048;
          double v39 = a2;
          _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_particlefilter,ingesting peer vio,  x: %f, y: %f, z: %f, range time: %f, current time: %f",  buf,  0x34u);
        }

        sub_1002FFC78(a1, (uint64_t)&v27);
      }
    }
  }

__n128 sub_1002FCF34(uint64_t a1, float *a2)
{
  if (!*(_BYTE *)(a1 + 360))
  {
    *(void *)(a1 + 352) = *(void *)a2;
    *(_BYTE *)(a1 + 360) = 1;
  }

  if (*(_BYTE *)(a1 + 3520))
  {
    if (*(_BYTE *)(a1 + 24))
    {
      if (*(_BYTE *)(a1 + 688))
      {
        double v4 = *(double *)a2;
        if (*(double *)a2 - *(double *)(a1 + 680) > 1.58 && v4 - *(double *)(a1 + 352) > 0.1)
        {
          *(double *)(a1 + 352) = v4;
          *(_BYTE *)(a1 + 360) = 1;
          sub_1002FD130(a1, (uint64_t)v21, *(double *)(a1 + 3512), a2[16], a2[17], a2[18]);
          int v5 = *(unsigned __int8 *)(a1 + 664);
          __int128 v6 = v21[9];
          *(_OWORD *)(a1 + 616) = v21[8];
          *(_OWORD *)(a1 + 632) = v6;
          *(_OWORD *)(a1 + 64_Block_object_dispose((const void *)(v1 - 112), 8) = v21[10];
          __int128 v7 = v21[5];
          *(_OWORD *)(a1 + 552) = v21[4];
          *(_OWORD *)(a1 + 56_Block_object_dispose((const void *)(v1 - 112), 8) = v7;
          __int128 v8 = v21[7];
          *(_OWORD *)(a1 + 584) = v21[6];
          *(_OWORD *)(a1 + 600) = v8;
          __int128 v9 = v21[1];
          *(_OWORD *)(a1 + 48_Block_object_dispose((const void *)(v1 - 112), 8) = v21[0];
          *(_OWORD *)(a1 + 504) = v9;
          __int128 v10 = v21[3];
          *(_OWORD *)(a1 + 520) = v21[2];
          *(_OWORD *)(a1 + 536) = v10;
          if (!v5) {
            *(_BYTE *)(a1 + 664) = 1;
          }
          *(void *)(a1 + 576) = *(void *)(a1 + 160);
        }
      }
    }
  }

  if (*(_BYTE *)(a1 + 688) && *(double *)a2 - *(double *)(a1 + 680) > *(double *)(a1 + 344) + 1.38)
  {
    double v11 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v21[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_particlefilter,PF reset due to timeout calculated from current pose",  (uint8_t *)v21,  2u);
    }

    sub_1002FA034(a1);
  }

  if (sub_1002FBD8C(a1, (uint64_t *)a2))
  {
    int v13 = (_OWORD *)(a1 + 704);
    __int128 v14 = *(_OWORD *)a2;
    __int128 v15 = *((_OWORD *)a2 + 1);
    __int128 v16 = *((_OWORD *)a2 + 3);
    if (*(_BYTE *)(a1 + 832))
    {
      *(_OWORD *)(a1 + 736) = *((_OWORD *)a2 + 2);
      *(_OWORD *)(a1 + 752) = v16;
      _OWORD *v13 = v14;
      *(_OWORD *)(a1 + 720) = v15;
      __n128 result = *(__n128 *)(a2 + 16);
      __int128 v17 = *((_OWORD *)a2 + 5);
      __int128 v18 = *((_OWORD *)a2 + 6);
      *(void *)(a1 + 816) = *((void *)a2 + 14);
      *(_OWORD *)(a1 + 784) = v17;
      *(_OWORD *)(a1 + 800) = v18;
      *(__n128 *)(a1 + 76_Block_object_dispose((const void *)(v1 - 112), 8) = result;
    }

    else
    {
      *(_OWORD *)(a1 + 736) = *((_OWORD *)a2 + 2);
      *(_OWORD *)(a1 + 752) = v16;
      _OWORD *v13 = v14;
      *(_OWORD *)(a1 + 720) = v15;
      __n128 result = *(__n128 *)(a2 + 16);
      __int128 v19 = *((_OWORD *)a2 + 5);
      __int128 v20 = *((_OWORD *)a2 + 7);
      *(_OWORD *)(a1 + 800) = *((_OWORD *)a2 + 6);
      *(_OWORD *)(a1 + 816) = v20;
      *(__n128 *)(a1 + 76_Block_object_dispose((const void *)(v1 - 112), 8) = result;
      *(_OWORD *)(a1 + 784) = v19;
      *(_BYTE *)(a1 + 832) = 1;
    }
  }

  return result;
}

double sub_1002FD130@<D0>( uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D0>, double a4@<D1>, double a5@<D2>, double a6@<D3>)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_100006080();
  }
  __int128 v8 = *(double **)a1;
  __int128 v9 = *(double **)(a1 + 8);
  if (*(double **)a1 == v9)
  {
    double v51 = 0.0;
    double v52 = 0.0;
    double v55 = 0.0;
    double v56 = 0.0;
    double v20 = 0.0;
    double v16 = 0.0;
    double v12 = 0.0;
    double v10 = 0.0;
LABEL_47:
    double v14 = 0.0;
LABEL_48:
    double v53 = 0.0;
    double v54 = 0.0;
LABEL_49:
    double v25 = 0.0;
    double v48 = 0.0;
    double v49 = 0.0;
LABEL_50:
    double v50 = 0.0;
    goto LABEL_51;
  }

  double v10 = 0.0;
  double v11 = *(double **)a1;
  do
  {
    double v10 = v10 + *v11 * v11[11];
    v11 += 12;
  }

  while (v11 != v9);
  if (v8 == v9)
  {
    double v51 = 0.0;
    double v52 = 0.0;
    double v55 = 0.0;
    double v56 = 0.0;
    double v20 = 0.0;
    double v16 = 0.0;
    double v12 = 0.0;
    goto LABEL_47;
  }

  double v12 = 0.0;
  int v13 = *(double **)a1;
  do
  {
    double v12 = v12 + v13[2] * v13[11];
    v13 += 12;
  }

  while (v13 != v9);
  if (v8 == v9)
  {
    double v51 = 0.0;
    double v52 = 0.0;
    double v55 = 0.0;
    double v56 = 0.0;
    double v20 = 0.0;
    double v16 = 0.0;
    goto LABEL_47;
  }

  double v14 = 0.0;
  __int128 v15 = *(double **)a1;
  do
  {
    double v14 = v14 + v15[1] * v15[11];
    v15 += 12;
  }

  while (v15 != v9);
  if (v8 == v9)
  {
    double v51 = 0.0;
    double v52 = 0.0;
    double v55 = 0.0;
    double v56 = 0.0;
    double v20 = 0.0;
    double v16 = 0.0;
    goto LABEL_48;
  }

  double v16 = 0.0;
  __int128 v17 = *(double **)a1;
  do
  {
    double v16 = v16 + v17[5] * v17[11];
    v17 += 12;
  }

  while (v17 != v9);
  if (v8 == v9)
  {
    double v51 = 0.0;
    double v52 = 0.0;
    double v55 = 0.0;
    double v56 = 0.0;
    double v20 = 0.0;
    goto LABEL_48;
  }

  double v18 = 0.0;
  __int128 v19 = *(double **)a1;
  do
  {
    double v18 = v18 + v19[6] * v19[11];
    v19 += 12;
  }

  while (v19 != v9);
  if (v8 == v9)
  {
    double v51 = 0.0;
    double v52 = 0.0;
    double v55 = 0.0;
    double v56 = 0.0;
    double v20 = 0.0;
    double v53 = 0.0;
    double v54 = v18;
    goto LABEL_49;
  }

  double v20 = 0.0;
  double v21 = 0.0;
  __int128 v22 = *(double **)a1;
  do
  {
    double v23 = sqrt((v22[2] - a6) * (v22[2] - a6) + (*v22 - a4) * (*v22 - a4));
    double v24 = v22[11];
    double v20 = v20 + v23 * v24;
    double v21 = v21 + v23 * v23 * v24;
    v22 += 12;
  }

  while (v22 != v9);
  double v54 = v18;
  if (v8 == v9)
  {
    double v51 = 0.0;
    double v52 = 0.0;
    double v55 = v21;
    double v56 = 0.0;
    double v53 = 0.0;
    goto LABEL_49;
  }

  double v25 = 0.0;
  double v26 = 0.0;
  __int128 v27 = *(double **)a1;
  do
  {
    double v28 = sqrt((v27[1] - a5) * (v27[1] - a5) + (*v27 - a4) * (*v27 - a4) + (v27[2] - a6) * (v27[2] - a6));
    double v29 = v27[11];
    double v25 = v25 + v28 * v29;
    double v26 = v26 + v28 * v28 * v29;
    v27 += 12;
  }

  while (v27 != v9);
  double v55 = v21;
  if (v8 == v9)
  {
    double v51 = 0.0;
    double v52 = 0.0;
    double v56 = 0.0;
    double v48 = 0.0;
    double v49 = 0.0;
    double v50 = 0.0;
    double v53 = v26;
    goto LABEL_51;
  }

  double v30 = 0.0;
  double v31 = *(double **)a1;
  do
  {
    double v30 = v30 + (*v31 - v10) * (*v31 - v10) * v31[11];
    v31 += 12;
  }

  while (v31 != v9);
  double v53 = v26;
  if (v8 == v9)
  {
    double v51 = 0.0;
    double v52 = 0.0;
    double v48 = 0.0;
    double v49 = 0.0;
    double v50 = 0.0;
    double v56 = v30;
    goto LABEL_51;
  }

  double v32 = 0.0;
  double v33 = *(double **)a1;
  do
  {
    double v32 = v32 + (v33[2] - v12) * (v33[2] - v12) * v33[11];
    v33 += 12;
  }

  while (v33 != v9);
  double v56 = v30;
  if (v8 == v9)
  {
    double v51 = 0.0;
    double v52 = 0.0;
    double v48 = 0.0;
    double v49 = v32;
    goto LABEL_50;
  }

  double v34 = 0.0;
  double v35 = *(double **)a1;
  do
  {
    double v34 = v34 + (v35[1] - v14) * (v35[1] - v14) * v35[11];
    v35 += 12;
  }

  while (v35 != v9);
  double v49 = v32;
  if (v8 == v9)
  {
    double v51 = v34;
    double v52 = 0.0;
    double v48 = 0.0;
    goto LABEL_50;
  }

  double v36 = 0.0;
  uint64_t v37 = *(double **)a1;
  do
  {
    double v36 = v36 + (*v37 - v10) * (v37[2] - v12) * v37[11];
    v37 += 12;
  }

  while (v37 != v9);
  double v51 = v34;
  if (v8 == v9)
  {
    double v52 = 0.0;
    double v50 = 0.0;
    double v48 = v36;
  }

  else
  {
    double v38 = 0.0;
    double v39 = *(double **)a1;
    do
    {
      double v40 = -0.0;
      if (vabdd_f64(v39[1], a5) > 2.5) {
        double v40 = v39[11];
      }
      double v38 = v38 + v40;
      v39 += 12;
    }

    while (v39 != v9);
    double v48 = v36;
    if (v8 == v9)
    {
      double v50 = 0.0;
      double v52 = v38;
    }

    else
    {
      double v41 = 0.0;
      do
      {
        double v41 = v41 + fabs(v8[1]) * v8[11];
        v8 += 12;
      }

      while (v8 != v9);
      double v52 = v38;
      double v50 = v41;
    }
  }

uint64_t sub_1002FD658(uint64_t result, double a2)
{
  if (*(_BYTE *)(result + 24))
  {
    uint64_t v2 = *(void *)result;
    uint64_t v3 = *(void *)(result + 8);
    if (*(void *)result != v3)
    {
      uint64_t v5 = result + 992;
      do
      {
        double v6 = (double)sub_10012ACD8(v5);
        double result = sub_10012ACD8(v5);
        *(_DWORD *)(v2 + 80) = (v6 + (double)result * 4294967300.0) * 5.42101086e-20 + 0.0 >= a2;
        v2 += 96LL;
      }

      while (v2 != v3);
    }
  }

  return result;
}

void sub_1002FD6FC(uint64_t a1, int a2, double a3)
{
  int v6 = *(_DWORD *)(a1 + 3616);
  switch(v6)
  {
    case 0:
      if (a2 == 1)
      {
LABEL_8:
        double v7 = 0.5;
LABEL_13:
        sub_1002FD658(a1, v7);
        break;
      }

void sub_1002FD798(uint64_t a1, int a2, double a3, double a4)
{
  __int128 v8 = (_BYTE *)(a1 + 4208);
  sub_1002FCC18(a1, a4);
  v8[224] = a2;
  if (!*(_BYTE *)(a1 + 832)) {
    return;
  }
  LOBYTE(v23) = 0;
  char v24 = 0;
  LOBYTE(v25) = 0;
  char v26 = 0;
  *(double *)__int128 v19 = a3;
  *(double *)&v19[1] = a4;
  __int128 v9 = *(_OWORD *)(a1 + 768);
  double v21 = COERCE_FLOAT(*(void *)(a1 + 776));
  float64x2_t v20 = vcvtq_f64_f32(*(float32x2_t *)&v9);
  if (*(_BYTE *)(a1 + 812))
  {
    int v10 = *(_DWORD *)(a1 + 808);
    if (v10)
    {
      if (v10 != 1) {
        goto LABEL_8;
      }
      int v11 = 0;
    }

    else
    {
      int v11 = 2;
    }

    int v22 = v11;
  }

__n128 sub_1002FD9C0(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 51 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_1003009D8(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x33)) + 80 * (v7 % 0x33);
  *(_OWORD *)unint64_t v8 = *(_OWORD *)a2;
  __n128 result = *(__n128 *)(a2 + 16);
  __int128 v10 = *(_OWORD *)(a2 + 32);
  __int128 v11 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(v8 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v8 + 64) = v11;
  *(__n128 *)(v8 + 16) = result;
  *(_OWORD *)(v8 + 32) = v10;
  ++a1[5];
  return result;
}

void sub_1002FDA7C(uint64_t a1, uint64_t a2)
{
  double v2 = *(double *)a2;
  double v3 = *(double *)(a2 + 8);
  double v4 = *(double *)(a2 + 24);
  double v96 = *(double *)(a2 + 32);
  double v5 = *(double *)(a2 + 16);
  *(double *)(a1 + 356_Block_object_dispose((const void *)(v1 - 112), 8) = v4;
  *(_BYTE *)(a1 + 3576) = 1;
  if (!*(_BYTE *)(a1 + 832)) {
    return;
  }
  double v95 = v5;
  unint64_t v8 = (_BYTE *)(a1 + 832);
  __int128 v9 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003AAED0(v9, v8, v2);
  }
  if (*(_BYTE *)(a1 + 688) && v3 - *(double *)(a1 + 680) > *(double *)(a1 + 344))
  {
    __int128 v10 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_particlefilter,PF reset due to timeout calculated from current range",  buf,  2u);
    }

    sub_1002FA034(a1);
  }

  if (!*(_BYTE *)(a1 + 24))
  {
    __int128 v25 = *(_OWORD *)(a2 + 48);
    v107[2] = *(_OWORD *)(a2 + 32);
    v107[3] = v25;
    v107[4] = *(_OWORD *)(a2 + 64);
    __int128 v26 = *(_OWORD *)(a2 + 16);
    v107[0] = *(_OWORD *)a2;
    v107[1] = v26;
    sub_1002FAEEC(a1, (double *)v107);
    *(double *)(a1 + 680) = v3;
    *(_BYTE *)(a1 + 68_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
    *(void *)(a1 + 3512) = *(void *)a2;
    *(_BYTE *)(a1 + 3520) = 1;
    int v27 = *(unsigned __int8 *)(a1 + 4296);
    *(_OWORD *)(a1 + 4216) = *(_OWORD *)a2;
    __int128 v28 = *(_OWORD *)(a2 + 64);
    __int128 v30 = *(_OWORD *)(a2 + 16);
    __int128 v29 = *(_OWORD *)(a2 + 32);
    *(_OWORD *)(a1 + 4264) = *(_OWORD *)(a2 + 48);
    *(_OWORD *)(a1 + 4280) = v28;
    *(_OWORD *)(a1 + 4232) = v30;
    *(_OWORD *)(a1 + 424_Block_object_dispose((const void *)(v1 - 112), 8) = v29;
    if (!v27) {
      *(_BYTE *)(a1 + 4296) = 1;
    }
    return;
  }

  double v11 = *(double *)(a1 + 232);
  v105[0] = 0.0;
  v105[1] = v11;
  char v106 = 0;
  uint64_t v12 = 3960LL;
  if (!*(_BYTE *)(a1 + 4432)) {
    uint64_t v12 = 3952LL;
  }
  double v13 = *(double *)(a1 + v12);
  if (*(_BYTE *)(a1 + 3928))
  {
    double v14 = *(double *)(a1 + 3920);
    if (v3 - v14 <= v13) {
      goto LABEL_34;
    }
    __int128 v15 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 134218240;
      *(double *)&uint8_t buf[4] = v14;
      *(_WORD *)&_BYTE buf[12] = 2048;
      *(double *)&buf[14] = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_particlefilter,time of last pdr update: %f, current time: %f",  buf,  0x16u);
    }
  }

  if (*(_BYTE *)(a1 + 3944))
  {
    double v16 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      double v17 = v3 - *(double *)(a1 + 3936);
      *(_DWORD *)__int128 buf = 134217984;
      *(double *)&uint8_t buf[4] = v17;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_particlefilter,time since process model update: %f",  buf,  0xCu);
      double v16 = (os_log_s *)qword_1008000A0;
    }

    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_particlefilter,using random motion model",  buf,  2u);
    }

    if (!*(_BYTE *)(a1 + 24)) {
      sub_100006080();
    }
    uint64_t v18 = *(double **)a1;
    __int128 v19 = *(double **)(a1 + 8);
    if (*(double **)a1 != v19)
    {
      do
      {
        if (*((_DWORD *)v18 + 20))
        {
          if (*(_BYTE *)(a1 + 3928))
          {
            sub_1002FC4A8((double *)a1, (uint64_t)v18, (uint64_t)buf, v3 - *(double *)(a1 + 3920));
LABEL_31:
            *((_OWORD *)v18 + 2) = *(_OWORD *)v109;
            *((_OWORD *)v18 + 3) = *(_OWORD *)&v109[16];
            *((_OWORD *)v18 + 4) = *(_OWORD *)&v109[32];
            *((_OWORD *)v18 + 5) = v110;
            *(_OWORD *)uint64_t v18 = *(_OWORD *)buf;
            *((_OWORD *)v18 + 1) = *(_OWORD *)&buf[16];
            *(_DWORD *)(a1 + 396_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
            goto LABEL_32;
          }

          if (*(_BYTE *)(a1 + 688))
          {
            sub_1002FC4A8((double *)a1, (uint64_t)v18, (uint64_t)buf, v3 - *(double *)(a1 + 680));
            goto LABEL_31;
          }
        }

        else
        {
          double v20 = *v18;
          double *v18 = v20 + sub_1003008C0((uint64_t)v105, a1 + 992, v105);
          double v21 = v18[2];
          void v18[2] = v21 + sub_1003008C0((uint64_t)v105, a1 + 992, v105);
        }

void sub_1002FE588( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, void *__p, uint64_t a26)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

  ;
}

double sub_1002FE7B8(void *a1, double *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    sub_100300CEC(a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = a1[4] + v7;
  }

  double result = *a2;
  *(double *)(*(void *)(v5 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8LL)) + 8 * (v8 & 0x1FF)) = *a2;
  a1[5] = v7 + 1;
  return result;
}

uint64_t sub_1002FE83C(uint64_t a1, __n128 *a2)
{
  if (*(_BYTE *)(a1 + 24))
  {
    sub_10011B6E4(a1, a2);
  }

  else
  {
    *(void *)a1 = 0LL;
    *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
    *(void *)(a1 + 16) = 0LL;
    *(__n128 *)a1 = *a2;
    *(void *)(a1 + 16) = a2[1].n128_u64[0];
    a2->n128_u64[0] = 0LL;
    a2->n128_u64[1] = 0LL;
    a2[1].n128_u64[0] = 0LL;
    *(_BYTE *)(a1 + 24) = 1;
  }

  return a1;
}

void sub_1002FE898( uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D0>, double a4@<D1>, double a5@<D2>, double a6@<D3>)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_1003AAF84();
  }
  *(double *)(a1 + 3496) = *(double *)(a1 + 3496) + 1.0;
  __int128 v87 = 0LL;
  uint64_t v88 = 0LL;
  uint64_t v89 = 0LL;
  uint64_t v12 = *(double **)a1;
  double v13 = *(double **)(a1 + 8);
  if (*(double **)a1 == v13)
  {
    __int128 v29 = 0LL;
    stat __p = 0LL;
    __int128 v85 = 0LL;
    __int128 v86 = 0LL;
  }

  else
  {
    double v14 = 0LL;
    do
    {
      double v15 = a3 - sqrt((v12[2] - a5) * (v12[2] - a5) + (*v12 - a4) * (*v12 - a4) + (v12[1] - a6) * (v12[1] - a6));
      if (v14 >= v89)
      {
        double v16 = (double *)v87;
        uint64_t v17 = ((char *)v14 - (_BYTE *)v87) >> 3;
        unint64_t v18 = v17 + 1;
        uint64_t v19 = (char *)v89 - (_BYTE *)v87;
        else {
          unint64_t v20 = v18;
        }
        if (v20)
        {
          double v21 = (char *)sub_1000472C0((uint64_t)&v89, v20);
          double v16 = (double *)v87;
          double v14 = v88;
        }

        else
        {
          double v21 = 0LL;
        }

        double v22 = (double *)&v21[8 * v17];
        *double v22 = v15;
        double v23 = v22 + 1;
        while (v14 != v16)
        {
          uint64_t v24 = *((void *)v14-- - 1);
          *((void *)v22-- - 1) = v24;
        }

        __int128 v87 = v22;
        uint64_t v88 = v23;
        uint64_t v89 = (double *)&v21[8 * v20];
        if (v16) {
          operator delete(v16);
        }
        double v14 = v23;
      }

      else
      {
        *v14++ = v15;
      }

      uint64_t v88 = v14;
      v12 += 12;
    }

    while (v12 != v13);
    __int128 v25 = (double *)v87;
    stat __p = 0LL;
    __int128 v85 = 0LL;
    __int128 v86 = 0LL;
    if (v87 == v14)
    {
      __int128 v29 = 0LL;
    }

    else
    {
      __int128 v26 = 0LL;
      do
      {
        sub_1002FF158(a3, *v25);
        uint64_t v28 = v27;
        if (v26 >= v86)
        {
          __int128 v30 = (char *)__p;
          uint64_t v31 = (v26 - (_BYTE *)__p) >> 3;
          unint64_t v32 = v31 + 1;
          uint64_t v33 = v86 - (_BYTE *)__p;
          if ((v86 - (_BYTE *)__p) >> 2 > v32) {
            unint64_t v32 = v33 >> 2;
          }
          else {
            unint64_t v34 = v32;
          }
          if (v34)
          {
            double v35 = (char *)sub_1000472C0((uint64_t)&v86, v34);
            __int128 v30 = (char *)__p;
            __int128 v26 = v85;
          }

          else
          {
            double v35 = 0LL;
          }

          double v36 = &v35[8 * v31];
          *(void *)double v36 = v28;
          __int128 v29 = v36 + 8;
          while (v26 != v30)
          {
            uint64_t v37 = *((void *)v26 - 1);
            v26 -= 8;
            *((void *)v36 - 1) = v37;
            v36 -= 8;
          }

          stat __p = v36;
          __int128 v85 = v29;
          __int128 v86 = &v35[8 * v34];
          if (v30) {
            operator delete(v30);
          }
        }

        else
        {
          *(void *)__int128 v26 = v27;
          __int128 v29 = v26 + 8;
        }

        __int128 v85 = v29;
        ++v25;
        __int128 v26 = v29;
      }

      while (v25 != v14);
    }
  }

  if (!*(_BYTE *)(a1 + 24)) {
    sub_100006080();
  }
  __int128 v81 = 0LL;
  __int128 v82 = 0LL;
  __int128 v83 = 0LL;
  if (*(void *)(a1 + 8) == *(void *)a1)
  {
    int v41 = 0LL;
  }

  else
  {
    unint64_t v38 = 0LL;
    do
    {
      double v39 = *(double *)(*(void *)a1 + 96 * v38 + 88) * *((double *)__p + v38) + 1.0e-50;
      double v40 = v82;
      if (v82 >= v83)
      {
        __int128 v42 = (double *)v81;
        uint64_t v43 = ((char *)v82 - (_BYTE *)v81) >> 3;
        unint64_t v44 = v43 + 1;
        uint64_t v45 = (char *)v83 - (_BYTE *)v81;
        else {
          unint64_t v46 = v44;
        }
        if (v46)
        {
          __int128 v47 = (char *)sub_1000472C0((uint64_t)&v83, v46);
          __int128 v42 = (double *)v81;
          double v40 = v82;
        }

        else
        {
          __int128 v47 = 0LL;
        }

        double v48 = (double *)&v47[8 * v43];
        double *v48 = v39;
        int v41 = v48 + 1;
        while (v40 != v42)
        {
          uint64_t v49 = *((void *)v40-- - 1);
          *((void *)v48-- - 1) = v49;
        }

        __int128 v81 = v48;
        __int128 v82 = v41;
        __int128 v83 = (double *)&v47[8 * v46];
        if (v42) {
          operator delete(v42);
        }
      }

      else
      {
        *__int128 v82 = v39;
        int v41 = v40 + 1;
      }

      __int128 v82 = v41;
      if (!*(_BYTE *)(a1 + 24)) {
        sub_100006080();
      }
      ++v38;
    }

    while (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 5) > v38);
  }

  double v50 = (double *)v81;
  double v51 = 0.0;
  while (v50 != v41)
  {
    double v52 = *v50++;
    double v51 = v51 + v52;
  }

  double v53 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v77 = (double *)v87;
    double v78 = 0.0;
    while (v77 != v88)
    {
      double v79 = *v77++;
      double v78 = v78 + v79;
    }

    double v80 = (double)*(uint64_t *)(a1 + 32);
    *(_DWORD *)__int128 buf = 134218496;
    *(double *)&uint8_t buf[4] = v78 / v80;
    *(_WORD *)&_BYTE buf[12] = 2048;
    *(double *)&buf[14] = a3;
    *(_WORD *)&_BYTE buf[22] = 2048;
    *(double *)&_BYTE buf[24] = v51;
    _os_log_debug_impl( (void *)&_mh_execute_header,  v53,  OS_LOG_TYPE_DEBUG,  "#sa_algo_particlefilter,average error: %f, measurement: %f m, total likelihood: %f",  buf,  0x20u);
  }

  if (v51 >= 0.009)
  {
    double v57 = (uint64_t *)v81;
    double v58 = v82;
    if (v81 != v82)
    {
      __int128 v59 = (double *)v81;
      do
      {
        double *v59 = *v59 / v51;
        ++v59;
      }

      while (v59 != v58);
    }

    if (!*(_BYTE *)(a1 + 24)) {
      sub_100006080();
    }
    uint64_t v60 = *(void *)(a1 + 8) - *(void *)a1;
    if (v60)
    {
      uint64_t v61 = v60 / 96;
      int64x2_t v62 = (void *)(*(void *)a1 + 88LL);
      do
      {
        uint64_t v63 = *v57++;
        void *v62 = v63;
        v62 += 12;
        --v61;
      }

      while (v61);
    }

    sub_1002FD130(a1, (uint64_t)buf, a3, a4, a6, a5);
    if (!*(_BYTE *)(a1 + 24)) {
      sub_100006080();
    }
    uint64_t v64 = *(double **)a1;
    double v65 = 0.0;
    while (v64 != *(double **)(a1 + 8))
    {
      double v65 = v65 + v64[11] * v64[11];
      v64 += 12;
    }

    double v70 = 0.05;
    if (*(_DWORD *)(a1 + 3968) == 1) {
      double v70 = 0.25;
    }
    *(double *)(a1 + 280) = v70;
    if (1.0 / v65 / (double)*(uint64_t *)(a1 + 32) < v70 && *(double *)(a1 + 3496) > *(double *)(a1 + 312))
    {
      sub_1002FF208(a1, (double **)&v81, a3, a4, a5);
      *(void *)(a1 + 3496) = 0LL;
    }

    double v71 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int v90 = 134218240;
      double v91 = a3;
      __int16 v92 = 2048;
      uint64_t v93 = v99;
      _os_log_impl( (void *)&_mh_execute_header,  v71,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_particlefilter,measurement: %f, uncertainty: %f",  v90,  0x16u);
    }

    __int128 v72 = v102;
    *(_OWORD *)(a2 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = v101;
    *(_OWORD *)(a2 + 144) = v72;
    *(_OWORD *)(a2 + 160) = v103;
    __int128 v73 = v98;
    *(_OWORD *)(a2 + 64) = v97;
    *(_OWORD *)(a2 + 80) = v73;
    __int128 v74 = v100;
    *(_OWORD *)(a2 + 96) = v99;
    *(_OWORD *)(a2 + 112) = v74;
    __int128 v75 = *(_OWORD *)&buf[16];
    *(_OWORD *)a2 = *(_OWORD *)buf;
    *(_OWORD *)(a2 + 16) = v75;
    __int128 v76 = v96;
    *(_OWORD *)(a2 + 32) = v95;
    *(_OWORD *)(a2 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v76;
    *(_BYTE *)(a2 + 176) = 1;
  }

  else
  {
    double v54 = (double *)v87;
    double v55 = 0.0;
    while (v54 != v88)
    {
      double v56 = *v54++;
      double v55 = v55 + v56;
    }

    __int128 v66 = (void *)std::ostream::operator<<(&std::cout, v55 / (double)*(uint64_t *)(a1 + 32));
    std::ios_base::getloc((const std::ios_base *)((char *)v66 + *(void *)(*v66 - 24LL)));
    __int128 v67 = std::locale::use_facet((const std::locale *)buf, &std::ctype<char>::id);
    uint64_t v68 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v67->__vftable[2].~facet_0)(v67, 10LL);
    std::locale::~locale((std::locale *)buf);
    std::ostream::put(v66, v68);
    std::ostream::flush(v66);
    unint64_t v69 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v69,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_particlefilter,PF reset due to minimum likelihood threshold fail",  buf,  2u);
    }

    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 176) = 0;
  }

  if (v81)
  {
    __int128 v82 = (double *)v81;
    operator delete(v81);
  }

  if (__p)
  {
    __int128 v85 = (char *)__p;
    operator delete(__p);
  }

  if (v87)
  {
    uint64_t v88 = (double *)v87;
    operator delete(v87);
  }

void sub_1002FF0CC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, std::locale a23)
{
  if (__p) {
    operator delete(__p);
  }
  if (a13) {
    operator delete(a13);
  }
  if (a16) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002FF158(double a1, double a2)
{
  double v6 = v3 * (a2 - v4) / v5;
  double v7 = v6 + 1.0;
  if (v6 + 1.0 > 0.0)
  {
    double v8 = -1.0 / v3;
    double v9 = pow(v6 + 1.0, -1.0 / v3);
    exp(-v9);
    pow(v7, v8 + -1.0);
  }

void sub_1002FF208(uint64_t a1, double **a2, double a3, double a4, double a5)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_1003AAFAC();
  }
  double v7 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "#sa_algo_particlefilter,resampling with systematic resample method",  buf,  2u);
  }

  sub_1002DF8F8(buf, *(void *)(a1 + 32));
  double v8 = *a2;
  double v9 = a2[1];
  if (*a2 != v9)
  {
    __int128 v10 = *(char **)buf;
    double v12 = *v8;
    double v11 = v8 + 1;
    double v13 = v12;
    **(double **)__int128 buf = v12;
    if (v11 != v9)
    {
      double v14 = (double *)(v10 + 8);
      do
      {
        double v15 = *v11++;
        double v13 = v13 + v15;
        *v14++ = v13;
      }

      while (v11 != v9);
    }
  }

  uint64_t v16 = a1 + 992;
  unsigned int v17 = sub_10012ACD8(a1 + 992);
  unsigned int v18 = sub_10012ACD8(a1 + 992);
  uint64_t v19 = *(void *)(a1 + 32);
  stat __p = 0LL;
  int v90 = 0LL;
  double v91 = 0LL;
  if (v19 <= 0)
  {
    __int128 v86 = 0LL;
    __int128 v87 = 0LL;
    uint64_t v88 = 0LL;
  }

  else
  {
    unint64_t v20 = 0LL;
    uint64_t v21 = 0LL;
    double v22 = (((double)v17 + (double)v18 * 4294967300.0) * 5.42101086e-20 + 0.0) / (double)v19;
    do
    {
      double v23 = v22 + (double)(int)v21 / (double)v19;
      if (v20 >= v91)
      {
        __int128 v25 = (double *)__p;
        uint64_t v26 = ((char *)v20 - (_BYTE *)__p) >> 3;
        unint64_t v27 = v26 + 1;
        uint64_t v28 = (char *)v91 - (_BYTE *)__p;
        else {
          unint64_t v29 = v27;
        }
        if (v29)
        {
          __int128 v30 = (char *)sub_1000472C0((uint64_t)&v91, v29);
          __int128 v25 = (double *)__p;
          unint64_t v20 = v90;
        }

        else
        {
          __int128 v30 = 0LL;
        }

        uint64_t v31 = (double *)&v30[8 * v26];
        double *v31 = v23;
        uint64_t v24 = v31 + 1;
        while (v20 != v25)
        {
          uint64_t v32 = *((void *)v20-- - 1);
          *((void *)v31-- - 1) = v32;
        }

        stat __p = v31;
        int v90 = v24;
        double v91 = (double *)&v30[8 * v29];
        if (v25) {
          operator delete(v25);
        }
      }

      else
      {
        *unint64_t v20 = v23;
        uint64_t v24 = v20 + 1;
      }

      int v90 = v24;
      ++v21;
      uint64_t v19 = *(void *)(a1 + 32);
      unint64_t v20 = v24;
    }

    while (v19 > v21);
    __int128 v86 = 0LL;
    __int128 v87 = 0LL;
    uint64_t v88 = 0LL;
    if (v19 >= 1)
    {
      uint64_t v33 = 0LL;
      int v82 = 0;
      do
      {
        double v34 = *((double *)__p + v33);
        unint64_t v35 = v82;
        if (v34 > *(double *)(*(void *)buf + 8LL * v82))
        {
          unint64_t v36 = (uint64_t)&v93[-*(void *)buf] >> 3;
          if (v36 <= v82) {
            unint64_t v36 = v82;
          }
          while (v36 != v35)
          {
            unint64_t v37 = v35 + 1;
            double v38 = *(double *)(*(void *)buf + 8LL + 8 * v35++);
            if (v34 <= v38) {
              goto LABEL_36;
            }
          }

          unint64_t v37 = v36;
LABEL_36:
          int v82 = v37;
          unint64_t v35 = v37;
        }

        if (!*(_BYTE *)(a1 + 24)) {
          sub_100006080();
        }
        uint64_t v39 = *(void *)a1 + 96 * v35;
        double v40 = *(double *)(v39 + 8);
        double v83 = *(double *)v39;
        double v41 = *(double *)(v39 + 16);
        __int128 v85 = *(_OWORD *)(v39 + 24);
        __int128 v42 = (uint64_t *)(v39 + 56);
        uint64_t v43 = (int *)(v39 + 80);
        uint64_t v44 = *(void *)a1 + 96 * v33;
        if (!*(_BYTE *)(a1 + 337)) {
          uint64_t v43 = (int *)(v44 + 80);
        }
        if (!*(_BYTE *)(a1 + 336)) {
          __int128 v42 = (uint64_t *)(v44 + 56);
        }
        if (!*(_BYTE *)(a1 + 200)) {
          double v40 = *(double *)(*(void *)a1 + 96 * v33 + 8);
        }
        int v45 = *(_DWORD *)(v39 + 84);
        int v46 = *v43;
        uint64_t v48 = *(void *)(v44 + 64);
        uint64_t v47 = *(void *)(v44 + 72);
        uint64_t v50 = *(void *)(v44 + 40);
        double v49 = *(double *)(v44 + 48);
        uint64_t v51 = *v42;
        unsigned int v52 = sub_10012ACD8(v16);
        if (((double)v52 + (double)sub_10012ACD8(v16) * 4294967300.0) * 5.42101086e-20 + 0.0 < 0.5
          && *(_BYTE *)(a1 + 3576)
          && !*(_BYTE *)(a1 + 3584))
        {
          double v40 = *(double *)(a1 + 3568) - (v40 - *(double *)(a1 + 3568));
        }

        unsigned int v53 = sub_10012ACD8(v16);
        if (((double)v53 + (double)sub_10012ACD8(v16) * 4294967300.0) * 5.42101086e-20 + 0.0 < *(double *)(a1 + 304)
          && !*(_BYTE *)(a1 + 3504))
        {
          unsigned int v84 = sub_10012ACD8(v16);
          unsigned int v54 = sub_10012ACD8(v16);
          unsigned int v55 = sub_10012ACD8(v16);
          unsigned int v56 = sub_10012ACD8(v16);
          uint64_t v57 = v16;
          unsigned int v58 = sub_10012ACD8(v16);
          unsigned int v59 = sub_10012ACD8(v57);
          double v60 = ((double)v84 + (double)v54 * 4294967300.0) * 5.42101086e-20 + 0.0;
          double v61 = ((double)v55 + (double)v56 * 4294967300.0) * 5.42101086e-20 + 0.0;
          double v49 = (v61 + v61) * 3.14159265;
          double v62 = (((double)v58 + (double)v59 * 4294967300.0) * 5.42101086e-20 + 0.0) * 2.0 + -1.0 + a3;
          __double2 v63 = __sincos_stret((v60 + v60) * 3.14159265);
          double v83 = a4 + v62 * v63.__cosval;
          double v41 = a5 + v62 * v63.__sinval;
          uint64_t v16 = v57;
        }

        double v64 = 1.0 / (double)v19;
        double v65 = v87;
        if (v87 >= v88)
        {
          unint64_t v67 = 0xAAAAAAAAAAAAAAABLL * (((char *)v87 - (_BYTE *)v86) >> 5);
          unint64_t v68 = v67 + 1;
          if (v67 + 1 > 0x2AAAAAAAAAAAAAALL) {
            sub_10001E11C();
          }
          else {
            unint64_t v69 = v68;
          }
          if (v69) {
            double v70 = (char *)sub_10030105C((uint64_t)&v88, v69);
          }
          else {
            double v70 = 0LL;
          }
          double v71 = &v70[32 * (((char *)v87 - (_BYTE *)v86) >> 5)];
          *(double *)double v71 = v83;
          *((double *)v71 + 1) = v40;
          *((double *)v71 + 2) = v41;
          *(_OWORD *)(v71 + 24) = v85;
          *((void *)v71 + 5) = v50;
          *((double *)v71 + 6) = v49;
          *((void *)v71 + 7) = v51;
          *((void *)v71 + _Block_object_dispose((const void *)(v1 - 112), 8) = v48;
          *((void *)v71 + 9) = v47;
          *((_DWORD *)v71 + 20) = v46;
          *((_DWORD *)v71 + 21) = v45;
          *((double *)v71 + 11) = v64;
          __int128 v73 = (double *)v86;
          __int128 v72 = v87;
          __int128 v74 = &v70[96 * v67];
          if (v87 != v86)
          {
            do
            {
              __int128 v75 = *((_OWORD *)v72 - 5);
              *((_OWORD *)v74 - 6) = *((_OWORD *)v72 - 6);
              *((_OWORD *)v74 - 5) = v75;
              __int128 v76 = *((_OWORD *)v72 - 4);
              __int128 v77 = *((_OWORD *)v72 - 3);
              __int128 v78 = *((_OWORD *)v72 - 1);
              *((_OWORD *)v74 - 2) = *((_OWORD *)v72 - 2);
              *((_OWORD *)v74 - 1) = v78;
              *((_OWORD *)v74 - 4) = v76;
              *((_OWORD *)v74 - 3) = v77;
              v74 -= 96;
              v72 -= 12;
            }

            while (v72 != v73);
            __int128 v72 = v73;
          }

          __int128 v66 = (double *)(v71 + 96);
          __int128 v86 = v74;
          __int128 v87 = (double *)(v71 + 96);
          uint64_t v88 = (double *)&v70[96 * v69];
          if (v72) {
            operator delete(v72);
          }
        }

        else
        {
          *__int128 v87 = v83;
          v65[1] = v40;
          v65[2] = v41;
          *(_OWORD *)(v65 + 3) = v85;
          *((void *)v65 + 5) = v50;
          v65[6] = v49;
          *((void *)v65 + 7) = v51;
          *((void *)v65 + _Block_object_dispose((const void *)(v1 - 112), 8) = v48;
          *((void *)v65 + 9) = v47;
          *((_DWORD *)v65 + 20) = v46;
          *((_DWORD *)v65 + 21) = v45;
          __int128 v66 = v65 + 12;
          v65[11] = v64;
        }

        __int128 v87 = v66;
        ++v33;
        uint64_t v19 = *(void *)(a1 + 32);
      }

      while (v19 > v33);
    }
  }

  sub_1002FF90C(a1, (uint64_t)&v86);
  if (v86)
  {
    __int128 v87 = (double *)v86;
    operator delete(v86);
  }

  if (__p)
  {
    int v90 = (double *)__p;
    operator delete(__p);
  }

  if (*(void *)buf)
  {
    uint64_t v93 = *(char **)buf;
    operator delete(*(void **)buf);
  }

void sub_1002FF8A0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20, uint64_t a21, void *a22, uint64_t a23, uint64_t a24, void *a25, uint64_t a26)
{
  if (__p) {
    operator delete(__p);
  }
  if (a22) {
    operator delete(a22);
  }
  if (a25) {
    operator delete(a25);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002FF90C(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 24))
  {
    if (a1 != a2) {
      sub_1003010A0( (char *)a1,  *(char **)a2,  *(void *)(a2 + 8),  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 5));
    }
  }

  else
  {
    *(void *)a1 = 0LL;
    *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
    *(void *)(a1 + 16) = 0LL;
    sub_100301228( (void *)a1,  *(const void **)a2,  *(void *)(a2 + 8),  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 5));
    *(_BYTE *)(a1 + 24) = 1;
  }

  return a1;
}

uint64_t sub_1002FF998(void *a1)
{
  double v2 = (void **)a1[504];
  uint64_t v3 = a1[505];
  a1[508] = 0LL;
  unint64_t v4 = v3 - (void)v2;
  if (v4 >= 0x11)
  {
    do
    {
      operator delete(*v2);
      double v2 = (void **)(a1[504] + 8LL);
      a1[504] = v2;
      unint64_t v4 = a1[505] - (void)v2;
    }

    while (v4 > 0x10);
  }

  if (v4 >> 3 == 1)
  {
    uint64_t v5 = 64LL;
    goto LABEL_7;
  }

  if (v4 >> 3 == 2)
  {
    uint64_t v5 = 128LL;
LABEL_7:
    a1[507] = v5;
  }

  return sub_1002FFA18((uint64_t)a1);
}

uint64_t sub_1002FFA18(uint64_t result)
{
  if (*(_BYTE *)(result + 24))
  {
    uint64_t v1 = *(void *)result;
    uint64_t v2 = *(void *)(result + 8);
    if (*(void *)result != v2)
    {
      uint64_t v3 = result + 992;
      do
      {
        double v4 = (double)sub_10012ACD8(v3);
        double result = sub_10012ACD8(v3);
        *(double *)(v1 + 56) = (v4 + (double)result * 4294967300.0) * 5.42101086e-20 * 6.28318531 + 0.0;
        v1 += 96LL;
      }

      while (v1 != v2);
    }
  }

  return result;
}

void sub_1002FFBB0(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 3972) != 3)
  {
    if (*(_BYTE *)(a1 + 3928)) {
      *(_BYTE *)(a1 + 392_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
    }
  }

__n128 sub_1002FFBEC(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 16 * (v4 - v5) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_1003012A0(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  double v8 = (_OWORD *)(*(void *)(v5 + ((v7 >> 4) & 0xFFFFFFFFFFFFFF8LL)) + 32 * (v7 & 0x7F));
  __n128 result = *(__n128 *)a2;
  __int128 v10 = *(_OWORD *)(a2 + 16);
  _OWORD *v8 = *(_OWORD *)a2;
  v8[1] = v10;
  ++a1[5];
  return result;
}

void sub_1002FFC78(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 3972) != 3)
  {
    if (*(_BYTE *)(a1 + 4392)) {
      sub_1002FFA18(a1);
    }
  }

  uint64_t v4 = (_OWORD *)(a1 + 4360);
  uint64_t v5 = (_BYTE *)(a1 + 4392);
  if (*(_BYTE *)(a1 + 4392))
  {
    double v6 = *(double *)(a2 + 24) - *(double *)(a1 + 4384);
    double v7 = *(double *)a2;
    double v8 = *(double *)a2 - *(double *)(a1 + 4360);
    BOOL v9 = *(_DWORD *)(a1 + 3972) != 3;
    float64x2_t v13 = vsubq_f64(*(float64x2_t *)(a2 + 8), *(float64x2_t *)(a1 + 4368));
    double v14 = v6;
    int v15 = 1;
    double v16 = v7;
    double v17 = v8;
    BOOL v18 = v9;
    sub_1002FFD5C(a1, (uint64_t)&v13);
    *(_DWORD *)(a1 + 3972) = 3;
    int v10 = *v5;
    __int128 v11 = *(_OWORD *)(a2 + 16);
    *uint64_t v4 = *(_OWORD *)a2;
    *(_OWORD *)(a1 + 4376) = v11;
    if (v10) {
      return;
    }
  }

  else
  {
    __int128 v12 = *(_OWORD *)(a2 + 16);
    *uint64_t v4 = *(_OWORD *)a2;
    *(_OWORD *)(a1 + 4376) = v12;
  }

  *uint64_t v5 = 1;
}

void sub_1002FFD5C(uint64_t a1, uint64_t a2)
{
  double v2 = *(double *)(a2 + 40);
  if (v2 > 0.0 && *(_BYTE *)(a1 + 24))
  {
    uint64_t v5 = *(void *)(a2 + 32);
    double v6 = sqrt(v2 / 0.1);
    double v7 = v6 * *(double *)(a1 + 96);
    uint64_t v35 = 0LL;
    double v36 = v7;
    char v37 = 0;
    if (*(_BYTE *)(a2 + 48) && !*(_DWORD *)(a2 + 24)) {
      double v36 = 1.0;
    }
    double v8 = v6 * *(double *)(a1 + 112);
    uint64_t v32 = 0LL;
    double v33 = v8;
    char v34 = 0;
    *(void *)(a1 + 3920) = v5;
    *(_BYTE *)(a1 + 392_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
    *(void *)(a1 + 3936) = v5;
    *(_BYTE *)(a1 + 3944) = 1;
    BOOL v9 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v17 = *(void *)(a2 + 40);
      double v18 = *(double *)(a2 + 16);
      double v19 = *(double *)(*(void *)a1 + 64LL);
      double v20 = sub_1003008C0((uint64_t)&v35, a1 + 992, (double *)&v35);
      if (!*(_BYTE *)(a1 + 24)) {
        goto LABEL_28;
      }
      double v21 = v20;
      double v22 = *(double *)a2;
      double v23 = *(double *)(*(void *)a1 + 64LL);
      double v24 = sub_1003008C0((uint64_t)&v35, a1 + 992, (double *)&v35);
      if (!*(_BYTE *)(a1 + 24)) {
        goto LABEL_28;
      }
      uint64_t v25 = **(void **)a1;
      uint64_t v26 = *(void *)(*(void *)a1 + 56LL);
      uint64_t v27 = *(void *)(*(void *)a1 + 64LL);
      uint64_t v28 = *(void *)(*(void *)a1 + 16LL);
      uint64_t v29 = *(void *)(*(void *)a1 + 24LL);
      uint64_t v30 = *(void *)(*(void *)a1 + 32LL);
      uint64_t v31 = *(void *)(*(void *)a1 + 40LL);
      *(_DWORD *)__int128 buf = 134220544;
      uint64_t v39 = v17;
      __int16 v40 = 2048;
      double v41 = v8;
      __int16 v42 = 2048;
      double v43 = v21 + v18 * v19;
      __int16 v44 = 2048;
      double v45 = v24 + v22 * v23;
      __int16 v46 = 2048;
      uint64_t v47 = v25;
      __int16 v48 = 2048;
      uint64_t v49 = v28;
      __int16 v50 = 2048;
      uint64_t v51 = v26;
      __int16 v52 = 2048;
      uint64_t v53 = v27;
      __int16 v54 = 2048;
      uint64_t v55 = v31;
      __int16 v56 = 2048;
      uint64_t v57 = v29;
      __int16 v58 = 2048;
      uint64_t v59 = v30;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "#sa_algo_particlefilter,example deltaT: %f, frameRotNoise: %f, deltaZ: %f, deltaX: %f, px: %f, pz: %f, framerot: %f, stepscale: %f, vel: %f, vx: %f, vz: %f",  buf,  0x70u);
    }

    double v10 = *(double *)(a2 + 8) + *(double *)(a1 + 3592);
    *(double *)(a1 + 3592) = v10;
    double v11 = *(double *)(a1 + 3600);
    if (v10 < v11)
    {
      *(double *)(a1 + 3600) = v10;
      double v11 = v10;
    }

    double v12 = *(double *)(a1 + 3608);
    if (v10 > v12)
    {
      *(double *)(a1 + 360_Block_object_dispose((const void *)(v1 - 112), 8) = v10;
      double v12 = v10;
    }

    if (v12 - v11 > 1.0) {
      *(_BYTE *)(a1 + 3584) = 1;
    }
    if (*(_DWORD *)(a2 + 24))
    {
      uint64_t v32 = 0LL;
      double v33 = v6 * 0.01;
      char v34 = 0;
      if (*(_BYTE *)(a1 + 24))
      {
        float64x2_t v13 = *(double **)a1;
        double v14 = *(double **)(a1 + 8);
        while (v13 != v14)
        {
          sub_1003001A8(a1, (double *)a2, v13, (double *)&v35, (double *)&v32, 0);
          v13 += 12;
        }

void sub_100300084(uint64_t a1, double a2, double a3, double a4, double a5, double a6)
{
  double v12 = (_BYTE *)(a1 + 4392);
  if (*(_BYTE *)(a1 + 4392)) {
    _BYTE *v12 = 0;
  }
  float64x2_t v13 = *(void ***)(a1 + 4032);
  uint64_t v14 = *(void *)(a1 + 4040);
  *(void *)(a1 + 4064) = 0LL;
  unint64_t v15 = v14 - (void)v13;
  if (v15 >= 0x11)
  {
    do
    {
      operator delete(*v13);
      float64x2_t v13 = (void **)(*(void *)(a1 + 4032) + 8LL);
      *(void *)(a1 + 4032) = v13;
      unint64_t v15 = *(void *)(a1 + 4040) - (void)v13;
    }

    while (v15 > 0x10);
  }

  if (v15 >> 3 == 1)
  {
    uint64_t v16 = 64LL;
  }

  else
  {
    if (v15 >> 3 != 2) {
      goto LABEL_10;
    }
    uint64_t v16 = 128LL;
  }

  *(void *)(a1 + 4056) = v16;
LABEL_10:
  if (*(_DWORD *)(a1 + 3972) == 3)
  {
    sub_1002FFA18(a1);
    a3 = 0.0;
    a2 = 0.3;
    if (*v12) {
      _BYTE *v12 = 0;
    }
    char v17 = 1;
  }

  else
  {
    char v17 = 0;
  }

  *(void *)(a1 + 396_Block_object_dispose((const void *)(v1 - 112), 8) = 0x200000002LL;
  *(double *)double v18 = a3;
  *(double *)&v18[1] = a4;
  *(double *)&void v18[2] = a2;
  int v19 = 0;
  double v20 = a5;
  double v21 = a6;
  char v22 = v17;
  sub_1002FFD5C(a1, (uint64_t)v18);
}

void sub_1003001A8(uint64_t a1, double *a2, double *a3, double *a4, double *a5, int a6)
{
  if (a6) {
    double v11 = a3[8];
  }
  else {
    double v11 = 1.0;
  }
  double v12 = a2[2];
  uint64_t v13 = a1 + 992;
  double v14 = sub_1003008C0((uint64_t)a4, a1 + 992, a4) + v12 * v11;
  double v15 = *a2;
  double v16 = sub_1003008C0((uint64_t)a4, v13, a4) + v15 * v11;
  __double2 v17 = __sincos_stret(a3[7]);
  *a3 = *a3 + v17.__cosval * v16 - v17.__sinval * v14;
  a3[2] = a3[2] + v14 * v17.__cosval + v17.__sinval * v16;
  a3[7] = sub_1003008C0((uint64_t)a5, v13, a5) + a3[7];
  double v18 = a2[1] + a3[1];
  a3[1] = v18;
  double v19 = sqrt(a2[5] / 0.1);
  double v20 = *(double *)(a1 + 104);
  v23[0] = 0.0;
  v23[1] = v19 * v20;
  char v24 = 0;
  a3[1] = v18 + sub_1003008C0((uint64_t)v23, v13, v23);
  double v21 = a2[5];
  if (v21 > 0.01)
  {
    __double2 v22 = __sincos_stret(a3[7]);
    a3[3] = (v22.__cosval * v16 - v22.__sinval * v14) / v21;
    a3[4] = (v14 * v22.__cosval + v22.__sinval * v16) / v21;
  }

uint64_t sub_100300314(void *a1, uint64_t a2)
{
  uint64_t v4 = (void **)a1[1];
  uint64_t v5 = a1[2];
  a1[5] = 0LL;
  unint64_t v6 = v5 - (void)v4;
  if (v6 >= 0x11)
  {
    do
    {
      operator delete(*v4);
      uint64_t v7 = a1[2];
      uint64_t v4 = (void **)(a1[1] + 8LL);
      a1[1] = v4;
      unint64_t v6 = v7 - (void)v4;
    }

    while (v6 > 0x10);
  }

  if (v6 >> 3 == 1)
  {
    uint64_t v8 = 16LL;
    goto LABEL_7;
  }

  if (v6 >> 3 == 2)
  {
    uint64_t v8 = 32LL;
LABEL_7:
    a1[4] = v8;
  }

  sub_1003003B4(a1);
  uint64_t result = sub_1003004E4((uint64_t)a1, a2);
  a1[4] = *(void *)(a2 + 32);
  a1[5] = *(void *)(a2 + 40);
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_1003003B4(void *a1)
{
  if (a1[5])
  {
    sub_100125ADC((uint64_t)a1, 0);
    sub_1002CBEDC(a1, 0);
  }

  else
  {
    uint64_t v3 = a1[1];
    for (uint64_t i = a1[2]; i != v3; a1[2] = i)
    {
      operator delete(*(void **)(i - 8));
      uint64_t v3 = a1[1];
      uint64_t i = a1[2] - 8LL;
    }

    a1[4] = 0LL;
  }

  sub_100300424((uint64_t)a1);
}

void sub_100300424(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t v2 = a1 + 24;
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a1 + 16);
  unint64_t v6 = (v5 - v4) >> 3;
  if (v6 < (v3 - *(void *)a1) >> 3)
  {
    if (v5 == v4)
    {
      double v10 = 0LL;
      uint64_t v7 = 0LL;
    }

    else
    {
      uint64_t v7 = (char *)sub_1000472C0(v2, v6);
      uint64_t v8 = *(void *)(a1 + 8);
      uint64_t v5 = *(void *)(a1 + 16);
      double v10 = &v7[8 * v9];
      uint64_t v11 = v5 - v8;
      if (v5 != v8)
      {
        uint64_t v12 = 0LL;
        uint64_t v13 = 8 * (v11 >> 3);
        do
        {
          *(void *)&v7[v12] = *(void *)(v8 + v12);
          v12 += 8LL;
        }

        while (v13 != v12);
        uint64_t v5 = *(void *)(a1 + 8);
        uint64_t v14 = *(void *)(a1 + 16);
        goto LABEL_9;
      }
    }

    uint64_t v14 = v5;
LABEL_9:
    uint64_t v15 = v14 - v5;
    double v16 = *(void **)a1;
    *(void *)a1 = v7;
    *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v7;
    *(void *)(a1 + 16) = &v7[v15];
    *(void *)(a1 + 24) = v10;
    if (v16) {
      operator delete(v16);
    }
  }

uint64_t sub_1003004E4(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  if (v4 != v5) {
    *(void *)(a1 + 16) = v4 + ((v5 - v4 + 7) & 0xFFFFFFFFFFFFFFF8LL);
  }
  sub_100300424(a1);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  return a1;
}

void sub_100300550(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x49;
  unint64_t v4 = v2 - 73;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    unint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    uint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)uint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      char v34 = (char *)sub_1000472C0(v5, v33);
      uint64_t v35 = &v34[8 * (v33 >> 2)];
      char v37 = &v34[8 * v36];
      double v38 = (uint64_t *)a1[1];
      uint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        uint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        double v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)double v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100300818( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100300864(uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0x49) {
    a2 = 1;
  }
  if (v2 < 0x92) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8LL;
    *(void *)(a1 + 32) -= 73LL;
  }

  return v4 ^ 1u;
}

double sub_1003008C0(uint64_t a1, uint64_t a2, double *a3)
{
  if (*(_BYTE *)(a1 + 24))
  {
    *(_BYTE *)(a1 + 24) = 0;
    double v5 = *(double *)(a1 + 16);
  }

  else
  {
    do
    {
      do
      {
        double v7 = (double)sub_10012ACD8(a2);
        double v8 = (v7 + (double)sub_10012ACD8(a2) * 4294967300.0) * 5.42101086e-20 * 2.0 + -1.0;
        double v9 = (double)sub_10012ACD8(a2);
        double v10 = (v9 + (double)sub_10012ACD8(a2) * 4294967300.0) * 5.42101086e-20 * 2.0 + -1.0;
        double v11 = v10 * v10 + v8 * v8;
      }

      while (v11 > 1.0);
    }

    while (v11 == 0.0);
    double v12 = sqrt(log(v10 * v10 + v8 * v8) * -2.0 / v11);
    *(double *)(a1 + 16) = v10 * v12;
    *(_BYTE *)(a1 + 24) = 1;
    double v5 = v8 * v12;
  }

  return *a3 + v5 * a3[1];
}

void sub_1003009D8(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x33;
  unint64_t v4 = v2 - 51;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    unint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    double v7 = (void *)a1[1];
    double v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    double v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)double v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      char v34 = (char *)sub_1000472C0(v5, v33);
      uint64_t v35 = &v34[8 * (v33 >> 2)];
      char v37 = &v34[8 * v36];
      double v38 = (uint64_t *)a1[1];
      double v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        double v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        double v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)double v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100300CA0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100300CEC(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    unint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    double v7 = (void *)a1[1];
    double v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    double v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)double v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      char v34 = (char *)sub_1000472C0(v5, v33);
      uint64_t v35 = &v34[8 * (v33 >> 2)];
      char v37 = &v34[8 * v36];
      double v38 = (uint64_t *)a1[1];
      double v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        double v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        double v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)double v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100300FB4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100301000(uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0x200) {
    a2 = 1;
  }
  if (v2 < 0x400) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8LL;
    *(void *)(a1 + 32) -= 512LL;
  }

  return v4 ^ 1u;
}

void *sub_10030105C(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x2AAAAAAAAAAAAABLL) {
    sub_10001D350();
  }
  return operator new(96 * a2);
}

char *sub_1003010A0(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  double v7 = result;
  uint64_t v8 = *((void *)result + 2);
  double v9 = *(char **)result;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - *(void *)result) >> 5) < a4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0LL;
      *double v7 = 0LL;
      v7[1] = 0LL;
      _DWORD v7[2] = 0LL;
    }

    if (a4 > 0x2AAAAAAAAAAAAAALL) {
      sub_10001E11C();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 5);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= a4) {
      uint64_t v11 = a4;
    }
    if (v10 >= 0x155555555555555LL) {
      unint64_t v12 = 0x2AAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v12 = v11;
    }
    uint64_t result = sub_1003011D8(v7, v12);
    BOOL v14 = (char *)v7[1];
    uint64_t v13 = (void **)(v7 + 1);
    double v9 = v14;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      uint64_t v18 = v9;
      double v19 = __src;
      goto LABEL_18;
    }

    goto LABEL_19;
  }

  uint64_t v13 = (void **)(result + 8);
  uint64_t v15 = (_BYTE *)*((void *)result + 1);
  if (0xAAAAAAAAAAAAAAABLL * ((v15 - v9) >> 5) >= a4) {
    goto LABEL_16;
  }
  uint64_t v16 = &__src[32 * ((v15 - v9) >> 5)];
  if (v15 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, v15 - v9);
    double v9 = (char *)*v13;
  }

  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    uint64_t v18 = v9;
    double v19 = v16;
LABEL_18:
    uint64_t result = (char *)memmove(v18, v19, v17);
  }

char *sub_1003011D8(void *a1, unint64_t a2)
{
  if (a2 >= 0x2AAAAAAAAAAAAABLL) {
    sub_10001E11C();
  }
  uint64_t result = (char *)sub_10030105C((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[96 * v4];
  return result;
}

void *sub_100301228(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    uint64_t result = sub_1003011D8(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }

  return result;
}

void sub_100301284(_Unwind_Exception *exception_object)
{
  BOOL v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_1003012A0(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x80;
  unint64_t v4 = v2 - 128;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    unint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    size_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    double v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)size_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      char v34 = (char *)sub_1000472C0(v5, v33);
      uint64_t v35 = &v34[8 * (v33 >> 2)];
      char v37 = &v34[8 * v36];
      double v38 = (uint64_t *)a1[1];
      size_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        size_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        double v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)double v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100301568( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void *sub_1003015B4(void *a1, unint64_t a2)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if (a2)
  {
    sub_1003011D8(a1, a2);
    unint64_t v4 = (char *)a1[1];
    size_t v5 = 96 * ((96 * a2 - 96) / 0x60) + 96;
    bzero(v4, v5);
    a1[1] = &v4[v5];
  }

  return a1;
}

void sub_100301630(_Unwind_Exception *exception_object)
{
  BOOL v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_10030164C(uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0x80) {
    a2 = 1;
  }
  if (v2 < 0x100) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8LL;
    *(void *)(a1 + 32) -= 128LL;
  }

  return v4 ^ 1u;
}

double sub_1003016A8(__n128 a1)
{
  return a1.n128_f32[2];
}

double sub_1003016D8@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D4>)
{
  *(void *)(v3 - 24) = a2;
  return sub_1002C94C0( *(int8x16_t *)(a1 + 720),  *(int8x16_t *)(a1 + 736),  *(__n128 *)(a1 + 752),  *(double *)(a1 + 768),  a3);
}

void sub_100301708(void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
}

uint64_t sub_100301714()
{
  qword_1007FEDE0 = 0LL;
  qword_1007FEDE8 = 0LL;
  qword_1007FEDF0 = 0LL;
  uint64_t v0 = operator new(0x40uLL);
  qword_1007FEDE8 = (uint64_t)(v0 + 4);
  qword_1007FEDF0 = (uint64_t)(v0 + 4);
  _OWORD *v0 = xmmword_1004300C0;
  v0[1] = unk_1004300D0;
  v0[2] = xmmword_1004300E0;
  v0[3] = unk_1004300F0;
  qword_1007FEDE0 = (uint64_t)v0;
  __cxa_atexit((void (*)(void *))sub_100028CC4, &qword_1007FEDE0, (void *)&_mh_execute_header);
  qword_1007FEE00 = 0LL;
  unk_1007FEE08 = 0LL;
  qword_1007FEDF8 = 0LL;
  uint64_t v1 = operator new(0x10uLL);
  qword_1007FEE00 = (uint64_t)(v1 + 1);
  unk_1007FEE08 = v1 + 1;
  _OWORD *v1 = xmmword_100430100;
  qword_1007FEDF8 = (uint64_t)v1;
  return __cxa_atexit((void (*)(void *))sub_100028CC4, &qword_1007FEDF8, (void *)&_mh_execute_header);
}

uint64_t sub_1003017D0(uint64_t a1, uint64_t a2, _OWORD *a3, double a4, double a5)
{
  double v17 = a4;
  if (!*(_BYTE *)(a1 + 72))
  {
    uint64_t v9 = 0LL;
    double v8 = 0.0;
    goto LABEL_5;
  }

  double v8 = a5 - *(double *)(a1 + 64);
  uint64_t v9 = 1LL;
  if (v8 > 0.0)
  {
LABEL_5:
    *(double *)(a1 + 64) = a5;
    *(_BYTE *)(a1 + 72) = 1;
  }

  unint64_t v10 = *(void *)(a1 + 56);
  unint64_t v11 = *(int *)(a1 + 8);
  sub_1003018C8(a1 + 16, &v17);
  if (v10 >= v11)
  {
    --*(void *)(a1 + 56);
    sub_100189FD8((void *)(a1 + 16), 1);
  }

  __int128 v12 = a3[3];
  void v16[2] = a3[2];
  v16[3] = v12;
  __int128 v13 = a3[5];
  void v16[4] = a3[4];
  void v16[5] = v13;
  __int128 v14 = a3[1];
  v16[0] = *a3;
  v16[1] = v14;
  return (*(uint64_t (**)(uint64_t, double, uint64_t, uint64_t, _OWORD *, double))(*(void *)a1 + 40LL))( a1,  COERCE_DOUBLE(*(void *)&v8),  v9,  a2,  v16,  v17);
}

double sub_1003018C8(uint64_t a1, double *a2)
{
  unint64_t v4 = *(void *)(a1 + 32);
  if (!v4)
  {
    sub_10030481C((void **)a1);
    unint64_t v4 = *(void *)(a1 + 32);
  }

  uint64_t v5 = *(void *)(a1 + 8);
  unint64_t v6 = (void *)(v5 + 8 * (v4 >> 9));
  if (*(void *)(a1 + 16) == v5) {
    uint64_t v7 = 0LL;
  }
  else {
    uint64_t v7 = *v6 + 8 * (v4 & 0x1FF);
  }
  if (v7 == *v6) {
    uint64_t v7 = *(v6 - 1) + 4096LL;
  }
  double result = *a2;
  *(double *)(v7 - _Block_object_dispose((const void *)(v1 - 112), 8) = *a2;
  uint64_t v9 = *(void *)(a1 + 40) + 1LL;
  *(void *)(a1 + 32) = v4 - 1;
  *(void *)(a1 + 40) = v9;
  return result;
}

void sub_100301944(_BYTE *a1@<X8>)
{
  *a1 = 0;
  a1[80] = 0;
}

double sub_100301950(void *a1, double result)
{
  unint64_t v2 = a1[7];
  if (v2 >= 2)
  {
    uint64_t v3 = a1[3];
    if (a1[4] == v3)
    {
      double v13 = 0.0;
    }

    else
    {
      unint64_t v4 = a1[6];
      uint64_t v5 = (double **)(v3 + 8 * (v4 >> 9));
      unint64_t v6 = *v5;
      uint64_t v7 = v4 & 0x1FF;
      __int16 v8 = v4 + v2;
      unint64_t v9 = (v4 + v2) >> 9;
      unint64_t v10 = &(*v5)[v7];
      uint64_t v11 = v8 & 0x1FF;
      uint64_t v12 = *(void *)(v3 + 8 * v9) + 8 * v11;
      double v13 = 0.0;
      double v14 = 0.0;
      if (v10 != (double *)v12)
      {
        uint64_t v15 = v5;
        do
        {
          double v16 = *v10++;
          double v17 = v16;
          if ((char *)v10 - (char *)v6 == 4096)
          {
            uint64_t v18 = v15[1];
            ++v15;
            unint64_t v6 = v18;
            unint64_t v10 = v18;
          }

          double v14 = v14 + v17;
        }

        while (v10 != (double *)v12);
      }

      double v19 = *v5;
      int64_t v20 = &(*v5)[v7];
      uint64_t v21 = *(void *)(v3 + 8 * v9) + 8 * v11;
      if (v20 != (double *)v21)
      {
        double v22 = v14 / (double)v2;
        double v13 = 0.0;
        do
        {
          double v23 = *v20++;
          double v24 = v23;
          if ((char *)v20 - (char *)v19 == 4096)
          {
            unint64_t v25 = v5[1];
            ++v5;
            double v19 = v25;
            int64_t v20 = v25;
          }

          double v13 = v13 + (v24 - v22) * (v24 - v22);
        }

        while (v20 != (double *)v21);
      }
    }

    return sqrt(v13 / (double)(v2 - 1));
  }

  return result;
}

uint64_t sub_100301A48(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)(a2 + 160);
  *(_OWORD *)(a1 + 16) = 0u;
  *(_BYTE *)(a1 + 72) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_BYTE *)(a1 + 64) = 0;
  *(void *)a1 = off_1007BD3B8;
  __int128 v3 = *(_OWORD *)(a2 + 144);
  float32x4_t v10[8] = *(_OWORD *)(a2 + 128);
  v10[9] = v3;
  uint64_t v11 = *(void *)(a2 + 160);
  __int128 v4 = *(_OWORD *)(a2 + 80);
  v10[4] = *(_OWORD *)(a2 + 64);
  void v10[5] = v4;
  __int128 v5 = *(_OWORD *)(a2 + 112);
  v10[6] = *(_OWORD *)(a2 + 96);
  v10[7] = v5;
  __int128 v6 = *(_OWORD *)(a2 + 16);
  v10[0] = *(_OWORD *)a2;
  v10[1] = v6;
  __int128 v7 = *(_OWORD *)(a2 + 48);
  double v10[2] = *(_OWORD *)(a2 + 32);
  v10[3] = v7;
  __n128 v8 = sub_100301B5C((uint64_t)v10, a1 + 80);
  *(_BYTE *)(a1 + 24_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 256) = 0;
  *(_BYTE *)(a1 + 264) = 0;
  *(_BYTE *)(a1 + 272) = 0;
  *(_BYTE *)(a1 + 280) = 0;
  *(_BYTE *)(a1 + 28_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(void *)(a1 + 304) = 0LL;
  *(void *)(a1 + 312) = 0LL;
  *(void *)(a1 + 296) = 0LL;
  *(_BYTE *)(a1 + 320) = 0;
  *(void *)(a1 + 32_Block_object_dispose((const void *)(v1 - 112), 8) = 0x4059000000000000LL;
  (*(void (**)(uint64_t, __n128))(*(void *)a1 + 32LL))(a1, v8);
  return a1;
}

void sub_100301B20(_Unwind_Exception *a1)
{
  __int128 v4 = v3;
  __int128 v6 = *v4;
  if (*v4)
  {
    v1[38] = v6;
    operator delete(v6);
  }

  void *v1 = off_1007BD478;
  sub_1001302F0(v2);
  _Unwind_Resume(a1);
}

__n128 sub_100301B5C@<Q0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  if (*(double *)(a1 + 32) >= 0.0
    || *(double *)(a1 + 24) <= 0.0
    || *(double *)(a1 + 16) < 0.0
    || *(double *)(a1 + 8) < 0.0)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error( exception,  "Invalid OneStateKalmanFilterParams parameter: innovNegThresholdStd must be negative, innovPosThresholdStd must be positive, measStd cannot be negative, processStd cannot be negative.");
    goto LABEL_8;
  }

  if (!*(void *)(a1 + 64))
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Invalid nStartupMeasurements paramter: must be greater than 0");
LABEL_8:
  }

  __int128 v2 = *(_OWORD *)(a1 + 144);
  *(_OWORD *)(a2 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = *(_OWORD *)(a1 + 128);
  *(_OWORD *)(a2 + 144) = v2;
  *(void *)(a2 + 160) = *(void *)(a1 + 160);
  __int128 v3 = *(_OWORD *)(a1 + 80);
  *(_OWORD *)(a2 + 64) = *(_OWORD *)(a1 + 64);
  *(_OWORD *)(a2 + 80) = v3;
  __int128 v4 = *(_OWORD *)(a1 + 112);
  *(_OWORD *)(a2 + 96) = *(_OWORD *)(a1 + 96);
  *(_OWORD *)(a2 + 112) = v4;
  __int128 v5 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(_OWORD *)(a2 + 16) = v5;
  __n128 result = *(__n128 *)(a1 + 48);
  *(_OWORD *)(a2 + 32) = *(_OWORD *)(a1 + 32);
  *(__n128 *)(a2 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = result;
  return result;
}

void sub_100301C28(_Unwind_Exception *a1)
{
}

unint64_t sub_100301C44(uint64_t a1, uint64_t a2, char a3, int a4, double a5)
{
  if (a3)
  {
    if (*(double *)&a2 < 0.0)
    {
      LOBYTE(v_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
      unint64_t v9 = 0LL;
      return v9 | LOBYTE(v8);
    }

    if (*(double *)&a2 > (double)*(unint64_t *)(a1 + 152))
    {
      unint64_t v14 = *(void *)(a1 + 144);
      uint64_t v15 = (os_log_s *)qword_1008000A0;
      BOOL v16 = os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT);
      if (v14 >= 2)
      {
        if (v16)
        {
          LOWORD(v82) = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Filter reset after timeout, gathering startup measurements",  (uint8_t *)&v82,  2u);
        }

        *(void *)(a1 + 304) = *(void *)(a1 + 296);
        double v17 = *(void ***)(a1 + 24);
        uint64_t v18 = *(void *)(a1 + 32);
        *(void *)(a1 + 56) = 0LL;
        unint64_t v19 = v18 - (void)v17;
        if (v19 >= 0x11)
        {
          do
          {
            operator delete(*v17);
            uint64_t v20 = *(void *)(a1 + 32);
            double v17 = (void **)(*(void *)(a1 + 24) + 8LL);
            *(void *)(a1 + 24) = v17;
            unint64_t v19 = v20 - (void)v17;
          }

          while (v19 > 0x10);
        }

        if (v19 >> 3 == 1)
        {
          uint64_t v21 = 256LL;
        }

        else
        {
          if (v19 >> 3 != 2)
          {
LABEL_51:
            *(_BYTE *)(a1 + 320) = 1;
            unint64_t v46 = *(double **)(a1 + 304);
            unint64_t v47 = *(void *)(a1 + 312);
            if ((unint64_t)v46 >= v47)
            {
              uint64_t v49 = *(double **)(a1 + 296);
              uint64_t v50 = v46 - v49;
              unint64_t v51 = v47 - (void)v49;
              unint64_t v52 = (uint64_t)(v47 - (void)v49) >> 2;
              if (v52 <= v50 + 1) {
                unint64_t v52 = v50 + 1;
              }
              if (v51 >= 0x7FFFFFFFFFFFFFF8LL) {
                unint64_t v53 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v53 = v52;
              }
              if (v53)
              {
                __int128 v54 = (char *)sub_1000472C0(a1 + 312, v53);
                uint64_t v49 = *(double **)(a1 + 296);
                unint64_t v46 = *(double **)(a1 + 304);
              }

              else
              {
                __int128 v54 = 0LL;
              }

              __int128 v78 = (double *)&v54[8 * v50];
              double v79 = &v54[8 * v53];
              double *v78 = a5;
              __int16 v48 = v78 + 1;
              while (v46 != v49)
              {
                uint64_t v80 = *((void *)v46-- - 1);
                *((void *)v78-- - 1) = v80;
              }

              *(void *)(a1 + 296) = v78;
              *(void *)(a1 + 304) = v48;
              *(void *)(a1 + 312) = v79;
              if (v49) {
                operator delete(v49);
              }
            }

            else
            {
              double *v46 = a5;
              __int16 v48 = v46 + 1;
            }

            *(void *)(a1 + 304) = v48;
            if (*(_BYTE *)(a1 + 256)) {
              *(_BYTE *)(a1 + 256) = 0;
            }
            goto LABEL_98;
          }

          uint64_t v21 = 512LL;
        }

        *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v21;
        goto LABEL_51;
      }

      if (!v16)
      {
LABEL_39:
        *(void *)(a1 + 264) = *(void *)(a1 + 328);
        *(_BYTE *)(a1 + 272) = 1;
        *(double *)(a1 + 24_Block_object_dispose((const void *)(v1 - 112), 8) = a5;
        *(_BYTE *)(a1 + 256) = 1;
        double v8 = a5;
LABEL_99:
        unint64_t v9 = *(void *)&v8 & 0xFFFFFFFFFFFFFF00LL;
        return v9 | LOBYTE(v8);
      }

      LOWORD(v82) = 0;
      double v23 = "Filter reset after timeout, startup filtering not enabled";
      double v24 = v15;
      uint32_t v25 = 2;
LABEL_38:
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, v23, (uint8_t *)&v82, v25);
      goto LABEL_39;
    }

    if (!*(_BYTE *)(a1 + 320))
    {
      sub_100302258(a1, *(double *)&a2);
      sub_1003022E4(a1, a5);
LABEL_98:
      double v8 = *(double *)(a1 + 248);
      goto LABEL_99;
    }

    uint64_t v26 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v82) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "acquiring startup measurements",  (uint8_t *)&v82,  2u);
    }

    uint64_t v27 = *(double **)(a1 + 304);
    unint64_t v28 = *(void *)(a1 + 312);
    if ((unint64_t)v27 >= v28)
    {
      uint64_t v40 = *(double **)(a1 + 296);
      uint64_t v41 = v27 - v40;
      unint64_t v42 = v28 - (void)v40;
      unint64_t v43 = (uint64_t)(v28 - (void)v40) >> 2;
      if (v43 <= v41 + 1) {
        unint64_t v43 = v41 + 1;
      }
      if (v42 >= 0x7FFFFFFFFFFFFFF8LL) {
        unint64_t v44 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v44 = v43;
      }
      if (v44)
      {
        uint64_t v45 = (char *)sub_1000472C0(a1 + 312, v44);
        uint64_t v40 = *(double **)(a1 + 296);
        uint64_t v27 = *(double **)(a1 + 304);
      }

      else
      {
        uint64_t v45 = 0LL;
      }

      __int128 v55 = (double *)&v45[8 * v41];
      __int16 v56 = &v45[8 * v44];
      *__int128 v55 = a5;
      uint64_t v29 = v55 + 1;
      while (v27 != v40)
      {
        uint64_t v57 = *((void *)v27-- - 1);
        *((void *)v55-- - 1) = v57;
      }

      *(void *)(a1 + 296) = v55;
      *(void *)(a1 + 304) = v29;
      *(void *)(a1 + 312) = v56;
      if (v40) {
        operator delete(v40);
      }
    }

    else
    {
      double *v27 = a5;
      uint64_t v29 = v27 + 1;
    }

    *(void *)(a1 + 304) = v29;
    __int16 v58 = *(double **)(a1 + 296);
    unint64_t v59 = v29 - v58;
    if (v59 < *(void *)(a1 + 144) && a4 == 0) {
      goto LABEL_98;
    }
    double v61 = 0.0;
    if (v58 != v29)
    {
      double v62 = *(double **)(a1 + 296);
      do
      {
        double v63 = *v62++;
        double v61 = v61 + v63;
      }

      while (v62 != v29);
    }

    std::__sort<std::__less<double,double> &,double *>();
    double v65 = *(double **)(a1 + 296);
    double v64 = *(double **)(a1 + 304);
    unint64_t v66 = v64 - v65;
    unint64_t v67 = v66 >> 1;
    if ((((_DWORD)v64 - (_DWORD)v65) & 8) != 0) {
      double v68 = v65[v67];
    }
    else {
      double v68 = (v65[v67 - 1] + v65[v67]) * 0.5;
    }
    if (v65 == v64)
    {
      double v69 = 0.0;
    }

    else
    {
      double v69 = 0.0;
      do
      {
        double v70 = *v65++;
        double v69 = v69 + (v70 - v61 / (double)v59) * (v70 - v61 / (double)v59);
      }

      while (v65 != v64);
    }

    double v71 = v69 / (double)(v66 - 1);
    if ((a4 & 1) != 0 && (unint64_t v72 = *(void *)(a1 + 144), v66 < v72))
    {
      uint64_t v73 = qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        int v82 = 134217984;
        unint64_t v83 = v72;
        __int128 v74 = "filter initialized by override before all %llu startup measurements were received";
        __int128 v75 = (os_log_s *)v73;
        uint32_t v76 = 12;
LABEL_88:
        _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, v74, (uint8_t *)&v82, v76);
      }
    }

    else
    {
      uint64_t v77 = qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v82) = 0;
        __int128 v74 = "filter initialized with startup measurements";
        __int128 v75 = (os_log_s *)v77;
        uint32_t v76 = 2;
        goto LABEL_88;
      }
    }

    *(void *)(a1 + 304) = *(void *)(a1 + 296);
    *(_BYTE *)(a1 + 320) = 0;
    *(double *)(a1 + 24_Block_object_dispose((const void *)(v1 - 112), 8) = v68;
    *(_BYTE *)(a1 + 256) = 1;
    *(double *)(a1 + 264) = v71;
    *(_BYTE *)(a1 + 272) = 1;
    goto LABEL_98;
  }

  unint64_t v10 = *(void *)(a1 + 144);
  if (v10 < 2 || (a4 & 1) != 0)
  {
    if (!a4) {
      goto LABEL_39;
    }
    uint64_t v22 = qword_1008000A0;
    if (!os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_39;
    }
    int v82 = 134217984;
    unint64_t v83 = v10;
    double v23 = "filter initialized by override before all %llu startup measurements were received";
    double v24 = (os_log_s *)v22;
    uint32_t v25 = 12;
    goto LABEL_38;
  }

  uint64_t v11 = *(double **)(a1 + 296);
  *(void *)(a1 + 304) = v11;
  *(_BYTE *)(a1 + 320) = 1;
  unint64_t v12 = *(void *)(a1 + 312);
  if ((unint64_t)v11 >= v12)
  {
    uint64_t v30 = a1 + 312;
    uint64_t v31 = v12 - (void)v11;
    uint64_t v32 = v31 >> 2;
    else {
      unint64_t v33 = v32;
    }
    char v34 = (double *)sub_1000472C0(v30, v33);
    uint64_t v35 = *(char **)(a1 + 296);
    uint64_t v36 = *(char **)(a1 + 304);
    double v38 = &v34[v37];
    *char v34 = a5;
    double v13 = v34 + 1;
    while (v36 != v35)
    {
      uint64_t v39 = *((void *)v36 - 1);
      v36 -= 8;
      *((void *)v34-- - 1) = v39;
    }

    *(void *)(a1 + 296) = v34;
    *(void *)(a1 + 304) = v13;
    *(void *)(a1 + 312) = v38;
    if (v35) {
      operator delete(v35);
    }
  }

  else
  {
    *uint64_t v11 = a5;
    double v13 = v11 + 1;
  }

  LOBYTE(v_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  unint64_t v9 = 0LL;
  *(void *)(a1 + 304) = v13;
  return v9 | LOBYTE(v8);
}

void sub_100302258(uint64_t a1, double a2)
{
  if (*(_BYTE *)(a1 + 272) && *(_BYTE *)(a1 + 256))
  {
    double v2 = *(double *)(a1 + 120);
    *(double *)(a1 + 24_Block_object_dispose((const void *)(v1 - 112), 8) = v2 * *(double *)(a1 + 248);
    *(_BYTE *)(a1 + 256) = 1;
    *(double *)(a1 + 264) = *(double *)(a1 + 88) * (*(double *)(a1 + 88) * a2) + v2 * *(double *)(a1 + 264) * v2;
    *(_BYTE *)(a1 + 272) = 1;
  }

  else if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR))
  {
    sub_1003AAFDC();
  }

void sub_1003022E4(uint64_t a1, double a2)
{
  if (*(_BYTE *)(a1 + 272) && *(_BYTE *)(a1 + 256))
  {
    double v2 = *(double *)(a1 + 128);
    double v3 = *(double *)(a1 + 264);
    double v4 = v2 * v3;
    double v5 = *(double *)(a1 + 96) * *(double *)(a1 + 96) + v2 * v3 * v2;
    if (v5 <= 0.0)
    {
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
        sub_1003AB008();
      }
    }

    else
    {
      double v6 = *(double *)(a1 + 248);
      double v7 = a2 - v2 * v6;
      double v8 = v7 * v7 / v5;
      if (v7 < 0.0) {
        double v8 = -v8;
      }
      if (v8 <= -(*(double *)(a1 + 112) * *(double *)(a1 + 112))
        || v8 >= *(double *)(a1 + 104) * *(double *)(a1 + 104)
        || *(double *)(a1 + 136) >= a2)
      {
        unint64_t v9 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)unint64_t v10 = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_INFO,  "Estimator: Measurement failed innovation check and will be rejected",  v10,  2u);
        }
      }

      else
      {
        *(double *)(a1 + 24_Block_object_dispose((const void *)(v1 - 112), 8) = v6 + v4 / v5 * v7;
        *(_BYTE *)(a1 + 256) = 1;
        *(double *)(a1 + 264) = v3 * (1.0 - v4 / v5 * v2);
        *(_BYTE *)(a1 + 272) = 1;
      }
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR))
  {
    sub_1003AAFDC();
  }

_BYTE *sub_10030243C(_BYTE *result)
{
  if (result[256]) {
    result[256] = 0;
  }
  if (result[272]) {
    result[272] = 0;
  }
  if (result[288]) {
    result[288] = 0;
  }
  if (result[72]) {
    result[72] = 0;
  }
  return result;
}

uint64_t sub_100302470(uint64_t a1, uint64_t a2, char a3, double a4, uint64_t a5, uint64_t a6)
{
  double v6 = a4;
  if (*(_BYTE *)(a6 + 88) && *(_BYTE *)(a6 + 16)) {
    double v6 = *(double *)(a6 + 8) + a4;
  }
  if (!*(_BYTE *)(a1 + 184)) {
    goto LABEL_8;
  }
  if (a3 && *(double *)&a2 > 0.0)
  {
    float v8 = *(double *)&a2 / *(float *)(a1 + 84);
    float v9 = powf(*(float *)(a1 + 80), v8);
    double v6 = *(double *)(a1 + 176) * v9 + (float)(1.0 - v9) * v6;
LABEL_8:
    *(double *)(a1 + 176) = v6;
    *(_BYTE *)(a1 + 184) = 1;
  }

  return *(void *)(a1 + 176);
}

void sub_100302510(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 184)) {
    *(_BYTE *)(a1 + 184) = 0;
  }
  double v2 = *(void ***)(a1 + 24);
  uint64_t v3 = *(void *)(a1 + 32);
  *(void *)(a1 + 56) = 0LL;
  unint64_t v4 = v3 - (void)v2;
  if (v4 >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v5 = *(void *)(a1 + 32);
      double v2 = (void **)(*(void *)(a1 + 24) + 8LL);
      *(void *)(a1 + 24) = v2;
      unint64_t v4 = v5 - (void)v2;
    }

    while (v4 > 0x10);
  }

  if (v4 >> 3 == 1)
  {
    uint64_t v6 = 256LL;
  }

  else
  {
    if (v4 >> 3 != 2) {
      return;
    }
    uint64_t v6 = 512LL;
  }

  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v6;
}

uint64_t sub_100302590(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)(a2 + 4);
  *(_OWORD *)(a1 + 16) = 0u;
  *(_BYTE *)(a1 + 72) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_BYTE *)(a1 + 64) = 0;
  *(void *)a1 = off_1007BD3F8;
  *(_DWORD *)(a1 + 80) = 0;
  __int128 v3 = *(_OWORD *)(a2 + 8);
  __int128 v4 = *(_OWORD *)(a2 + 24);
  __int128 v5 = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 136) = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 120) = v5;
  *(_OWORD *)(a1 + 104) = v4;
  *(_OWORD *)(a1 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = v3;
  __int128 v6 = *(_OWORD *)(a2 + 72);
  __int128 v7 = *(_OWORD *)(a2 + 88);
  __int128 v8 = *(_OWORD *)(a2 + 104);
  *(_OWORD *)(a1 + 200) = *(_OWORD *)(a2 + 120);
  *(_OWORD *)(a1 + 184) = v8;
  *(_OWORD *)(a1 + 16_Block_object_dispose((const void *)(v1 - 112), 8) = v7;
  *(_OWORD *)(a1 + 152) = v6;
  *(_DWORD *)(a1 + 224) = 0;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 24_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_DWORD *)(a1 + 216) = 0;
  *(_DWORD *)(a1 + 219) = 0;
  *(void *)(a1 + 304) = 0x100000003LL;
  *(void *)(a1 + 280) = &off_1007BC4C0;
  *(_OWORD *)(a1 + 28_Block_object_dispose((const void *)(v1 - 112), 8) = xmmword_10042DB70;
  *(void *)(a1 + 312) = a1 + 320;
  *(void *)(a1 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = 0x300000003LL;
  *(void *)(a1 + 344) = &off_1007BC508;
  *(_OWORD *)(a1 + 352) = xmmword_10042DE90;
  *(void *)(a1 + 376) = a1 + 384;
  *(void *)(a1 + 480) = 0x300000003LL;
  *(void *)(a1 + 456) = &off_1007BC508;
  *(_OWORD *)(a1 + 464) = xmmword_10042DE90;
  *(void *)(a1 + 48_Block_object_dispose((const void *)(v1 - 112), 8) = a1 + 496;
  *(void *)(a1 + 592) = 0x300000003LL;
  *(void *)(a1 + 56_Block_object_dispose((const void *)(v1 - 112), 8) = &off_1007BC508;
  *(_OWORD *)(a1 + 576) = xmmword_10042DE90;
  *(void *)(a1 + 600) = a1 + 608;
  *(void *)(a1 + 704) = 0x300000001LL;
  *(void *)(a1 + 680) = &off_1007BD1A0;
  *(_OWORD *)(a1 + 68_Block_object_dispose((const void *)(v1 - 112), 8) = xmmword_10042E860;
  *(void *)(a1 + 712) = a1 + 720;
  *(void *)(a1 + 76_Block_object_dispose((const void *)(v1 - 112), 8) = 0x300000001LL;
  *(void *)(a1 + 744) = &off_1007BD1A0;
  *(_OWORD *)(a1 + 752) = xmmword_10042E860;
  *(void *)(a1 + 776) = a1 + 784;
  *(void *)(a1 + 832) = 0x100000001LL;
  *(void *)(a1 + 80_Block_object_dispose((const void *)(v1 - 112), 8) = &off_1007BCA50;
  *(void *)&__int128 v9 = 0x100000001LL;
  *((void *)&v9 + 1) = 0x100000001LL;
  *(_OWORD *)(a1 + 816) = v9;
  *(void *)(a1 + 840) = a1 + 848;
  sub_100302774(a1);
  return a1;
}

void sub_100302728(_Unwind_Exception *a1)
{
  v1[101] = off_1007AED90;
  v1[93] = off_1007AED90;
  v1[85] = off_1007AED90;
  v1[71] = off_1007AED90;
  v1[57] = off_1007AED90;
  v1[43] = off_1007AED90;
  v1[35] = off_1007AED90;
  sub_100304B2C(v3);
  void *v1 = off_1007BD478;
  sub_1001302F0(v2);
  _Unwind_Resume(a1);
}

void sub_100302774(uint64_t a1)
{
  uint64_t v6 = 0x300000003LL;
  *(void *)__int128 buf = &off_1007BC508;
  __int128 v5 = xmmword_10042DE90;
  __int128 v7 = v8;
  sub_1002CAEDC(buf, 3, 3);
  sub_1002CAF28((uint64_t)buf, 0.0);
  for (int i = 0; i != 3; ++i)
    *(void *)sub_100304F3C((uint64_t)buf, i, i) = 0x3FF0000000000000LL;
  sub_1002CBDC8(a1 + 456, (uint64_t)buf);
  uint64_t v6 = 0x300000001LL;
  *(void *)__int128 buf = &off_1007BD1A0;
  __int128 v5 = xmmword_10042E860;
  __int128 v7 = v8;
  sub_1002CAEDC(buf, 1, 3);
  sub_1002CAF28((uint64_t)buf, 0.0);
  sub_1002CBDC8(a1 + 680, (uint64_t)buf);
  *(void *)sub_1002CB40C(a1 + 680, 0, 0) = 0x3FF0000000000000LL;
  uint64_t v6 = 0x300000001LL;
  *(void *)__int128 buf = &off_1007BD1A0;
  __int128 v5 = xmmword_10042E860;
  __int128 v7 = v8;
  sub_1002CAEDC(buf, 1, 3);
  sub_1002CAF28((uint64_t)buf, 0.0);
  sub_1002CBDC8(a1 + 744, (uint64_t)buf);
  *(void *)sub_1002CB40C(a1 + 744, 0, 1) = 0x3FF0000000000000LL;
  uint64_t v6 = 0x300000003LL;
  *(void *)__int128 buf = &off_1007BC508;
  __int128 v5 = xmmword_10042DE90;
  __int128 v7 = v8;
  sub_1002CAEDC(buf, 3, 3);
  sub_1002CAF28((uint64_t)buf, 0.0);
  sub_1002CBDC8(a1 + 568, (uint64_t)buf);
  *(void *)sub_1002CB40C(a1 + 808, 0, 0) = 0LL;
  __int128 v3 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "kalman filter matrices initiated", buf, 2u);
  }

void sub_100302994(uint64_t a1)
{
  *(_DWORD *)(a1 + 224) = 0;
  *(_DWORD *)(a1 + 216) = 0;
  *(_DWORD *)(a1 + 219) = 0;
  double v2 = *(void ***)(a1 + 240);
  uint64_t v3 = *(void *)(a1 + 248);
  *(void *)(a1 + 272) = 0LL;
  unint64_t v4 = v3 - (void)v2;
  if (v4 >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v5 = *(void *)(a1 + 248);
      double v2 = (void **)(*(void *)(a1 + 240) + 8LL);
      *(void *)(a1 + 240) = v2;
      unint64_t v4 = v5 - (void)v2;
    }

    while (v4 > 0x10);
  }

  if (v4 >> 3 == 1)
  {
    uint64_t v6 = 64LL;
  }

  else
  {
    if (v4 >> 3 != 2) {
      goto LABEL_8;
    }
    uint64_t v6 = 128LL;
  }

  *(void *)(a1 + 264) = v6;
LABEL_8:
  __int128 v7 = *(void ***)(a1 + 24);
  uint64_t v8 = *(void *)(a1 + 32);
  *(void *)(a1 + 56) = 0LL;
  unint64_t v9 = v8 - (void)v7;
  if (v9 >= 0x11)
  {
    do
    {
      operator delete(*v7);
      uint64_t v10 = *(void *)(a1 + 32);
      __int128 v7 = (void **)(*(void *)(a1 + 24) + 8LL);
      *(void *)(a1 + 24) = v7;
      unint64_t v9 = v10 - (void)v7;
    }

    while (v9 > 0x10);
  }

  if (v9 >> 3 == 1)
  {
    uint64_t v11 = 256LL;
  }

  else
  {
    if (v9 >> 3 != 2) {
      goto LABEL_15;
    }
    uint64_t v11 = 512LL;
  }

  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v11;
LABEL_15:
  if (*(_BYTE *)(a1 + 72)) {
    *(_BYTE *)(a1 + 72) = 0;
  }
  sub_100302774(a1);
}

unint64_t sub_100302A7C(uint64_t a1, uint64_t a2, double *a3, double a4, double a5)
{
  if (!*((_BYTE *)a3 + 88)) {
    sub_1003AB034();
  }
  if (!*(_BYTE *)(a1 + 72))
  {
    uint64_t v9 = 0LL;
    double v8 = 0.0;
    goto LABEL_6;
  }

  double v8 = a5 - *(double *)(a1 + 64);
  uint64_t v9 = 1LL;
  if (v8 > 0.0)
  {
LABEL_6:
    *(double *)(a1 + 64) = a5;
    *(_BYTE *)(a1 + 72) = 1;
  }

  double v10 = a4;
  if (*((_BYTE *)a3 + 16)) {
    double v10 = a3[1] + a4;
  }
  if (!*((_BYTE *)a3 + 1)) {
    sub_1003AB05C();
  }
  *(double *)&__int128 v22 = a5;
  *((double *)&v22 + 1) = v10;
  double v23 = a4;
  char v24 = *(_BYTE *)a3;
  sub_100302C44(a1 + 232, &v22);
  unint64_t v11 = *(void *)(a1 + 272);
  if (v11 > *(int *)(a1 + 8))
  {
    *(void *)(a1 + 272) = v11 - 1;
    sub_100304ED0((void *)(a1 + 232), 1);
  }

  if (!*((_BYTE *)a3 + 1)) {
    sub_100006080();
  }
  int v12 = *(unsigned __int8 *)a3;
  if (v12 == 2)
  {
    int v13 = 1;
    *(_BYTE *)(a1 + 222) = 1;
    if (!*(_BYTE *)(a1 + 221)) {
      goto LABEL_19;
    }
    goto LABEL_17;
  }

  if (v12 == 1)
  {
    *(_BYTE *)(a1 + 221) = 1;
LABEL_17:
    if (!*(_BYTE *)(a1 + 222))
    {
      *(_DWORD *)(a1 + 80) = 0;
      goto LABEL_24;
    }

    int v13 = 2;
LABEL_19:
    *(_DWORD *)(a1 + 80) = v13;
LABEL_24:
    __int128 v16 = *((_OWORD *)a3 + 3);
    v21[2] = *((_OWORD *)a3 + 2);
    v21[3] = v16;
    __int128 v17 = *((_OWORD *)a3 + 5);
    v21[4] = *((_OWORD *)a3 + 4);
    void v21[5] = v17;
    __int128 v18 = *((_OWORD *)a3 + 1);
    v21[0] = *(_OWORD *)a3;
    v21[1] = v18;
    uint64_t v19 = (*(uint64_t (**)(uint64_t, double, uint64_t, uint64_t, _OWORD *, double))(*(void *)a1 + 40LL))( a1,  COERCE_DOUBLE(*(void *)&v8),  v9,  a2,  v21,  v10);
    unint64_t v14 = v19 & 0xFFFFFFFFFFFFFF00LL;
    uint64_t v15 = v19;
    return v15 | v14;
  }

  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
    sub_1003AB084();
  }
  unint64_t v14 = 0LL;
  uint64_t v15 = 0LL;
  return v15 | v14;
}

int64x2_t sub_100302C44(uint64_t a1, _OWORD *a2)
{
  unint64_t v4 = *(void *)(a1 + 32);
  if (!v4)
  {
    sub_100304BC0((void **)a1);
    unint64_t v4 = *(void *)(a1 + 32);
  }

  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = (void *)(v5 + 8 * (v4 >> 7));
  uint64_t v7 = *v6 + 32 * (v4 & 0x7F);
  if (*(void *)(a1 + 16) == v5) {
    uint64_t v7 = 0LL;
  }
  if (v7 == *v6) {
    uint64_t v7 = *(v6 - 1) + 4096LL;
  }
  __int128 v8 = a2[1];
  *(_OWORD *)(v7 - 32) = *a2;
  *(_OWORD *)(v7 - 16) = v8;
  int64x2_t result = vaddq_s64(*(int64x2_t *)(a1 + 32), (int64x2_t)xmmword_1004301A0);
  *(int64x2_t *)(a1 + 32) = result;
  return result;
}

double sub_100302CC4(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 216)) {
    return 0.0;
  }
  int v1 = *(_DWORD *)(a1 + 80);
  switch(v1)
  {
    case 2:
      uint64_t v3 = a1 + 280;
      double v4 = sub_1002405E4(a1 + 280, 0);
      return (v4 + sub_1002405E4(v3, 1u)) * 0.5;
    case 1:
      return sub_1002405E4(a1 + 280, 1u);
    case 0:
      return sub_1002405E4(a1 + 280, 0);
  }

  return result;
}

uint64_t sub_100302D78(uint64_t a1, uint64_t a2, char a3, double a4, uint64_t a5, unsigned __int8 *a6)
{
  if (!a6[88]) {
    sub_1003AB0B0();
  }
  if (*(_DWORD *)(a1 + 80) == 2) {
    uint64_t v7 = 152LL;
  }
  else {
    uint64_t v7 = 88LL;
  }
  if (*(_DWORD *)(a1 + 80) == 2) {
    uint64_t v8 = a1 + 152;
  }
  else {
    uint64_t v8 = a1 + 88;
  }
  if (!a3)
  {
    *(_DWORD *)(a1 + 216) = 0;
    double v13 = 0.0;
    return *(void *)&v13;
  }

  if (!a6[1]) {
    sub_1003AB0D8();
  }
  int v11 = *a6;
  int v12 = *(_DWORD *)(a1 + 216);
  double v13 = 0.0;
  if (v12 == 2)
  {
    __int128 v14 = *((_OWORD *)a6 + 3);
    v31[2] = *((_OWORD *)a6 + 2);
    double v31[3] = v14;
    __int128 v15 = *((_OWORD *)a6 + 5);
    _OWORD v31[4] = *((_OWORD *)a6 + 4);
    v31[5] = v15;
    __int128 v16 = *((_OWORD *)a6 + 1);
    v31[0] = *(_OWORD *)a6;
    v31[1] = v16;
    __int128 v17 = *((_OWORD *)a6 + 3);
    v30[2] = *((_OWORD *)a6 + 2);
    void v30[3] = v17;
    __int128 v18 = *((_OWORD *)a6 + 5);
    v30[4] = *((_OWORD *)a6 + 4);
    v30[5] = v18;
    __int128 v19 = *((_OWORD *)a6 + 1);
    v30[0] = *(_OWORD *)a6;
    v30[1] = v19;
    goto LABEL_28;
  }

  if (v12 != 1)
  {
    if (v12) {
      return *(void *)&v13;
    }
    if (sub_100303000(a1))
    {
      *(_DWORD *)(a1 + 216) = 1;
      *(_DWORD *)(a1 + 224) = 0;
      *(_BYTE *)(a1 + 220) = 0;
      return *(void *)&v13;
    }

    goto LABEL_28;
  }

  __int128 v20 = *((_OWORD *)a6 + 3);
  _DWORD v32[2] = *((_OWORD *)a6 + 2);
  v32[3] = v20;
  __int128 v21 = *((_OWORD *)a6 + 5);
  v32[4] = *((_OWORD *)a6 + 4);
  v32[5] = v21;
  __int128 v22 = *((_OWORD *)a6 + 1);
  v32[0] = *(_OWORD *)a6;
  v32[1] = v22;
  sub_100302CC4(a1);
  if (!v24) {
    sub_1003AB100();
  }
  if (!a6[32]) {
    sub_1003AB128();
  }
  if (vabdd_f64(v23, *((double *)a6 + 3)) > *(double *)(v8 + 8))
  {
LABEL_25:
    *(_DWORD *)(a1 + 216) = 0;
    return *(void *)&v13;
  }

  int v25 = *(_DWORD *)(a1 + 224) + 1;
  *(_DWORD *)(a1 + 224) = v25;
  if (v25 != *(_DWORD *)(a1 + v7))
  {
LABEL_28:
    if (*(_DWORD *)(a1 + 216) != 2) {
      return *(void *)&v13;
    }
    goto LABEL_29;
  }

  *(_DWORD *)(a1 + 216) = 2;
LABEL_29:
  int v26 = *(_DWORD *)(a1 + 80);
  switch(v26)
  {
    case 2:
      uint64_t v28 = a1 + 280;
      double v29 = *(double *)sub_1002CB32C(v28, 0);
      double v13 = (v29 + *(double *)sub_1002CB32C(v28, 1u)) * 0.5;
      break;
    case 1:
      double v13 = *(double *)sub_1002CB32C(a1 + 280, 1u);
      break;
    case 0:
      double v13 = *(double *)sub_1002CB32C(a1 + 280, 0);
      break;
  }

  return *(void *)&v13;
}

uint64_t sub_100303000(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 80) == 2) {
    int v1 = (double *)(a1 + 152);
  }
  else {
    int v1 = (double *)(a1 + 88);
  }
  unint64_t v2 = *(void *)(a1 + 272);
  if (v2 < 2) {
    return 0LL;
  }
  uint64_t v4 = a1;
  unint64_t v5 = *(void *)(a1 + 264);
  uint64_t v6 = *(void *)(a1 + 240);
  uint64_t v7 = *(void *)(v6 + ((v5 >> 4) & 0xFFFFFFFFFFFFFF8LL));
  uint64_t v8 = v5 & 0x7F;
  int v9 = *(unsigned __int8 *)(v7 + 32 * v8 + 24);
  uint64_t v10 = *(void *)(v6 + (((v5 + 1) >> 4) & 0xFFFFFFFFFFFFFF8LL));
  uint64_t v11 = (v5 + 1) & 0x7F;
  if (*(unsigned __int8 *)(v10 + 32 * v11 + 24) == v9)
  {
    uint64_t v12 = 1LL;
    BOOL v13 = 1;
LABEL_12:
    double v15 = *(double *)(v7 + 32 * v8) - *(double *)(v10 + 32 * v11);
    if (v15 > 0.0 && v15 <= v1[7])
    {
      uint64_t v16 = *(void *)(v7 + 32 * v8 + 8);
      *(void *)sub_1002CB32C(a1 + 280, 0) = v16;
      uint64_t v17 = *(void *)(*(void *)(*(void *)(v4 + 240) + ((*(void *)(v4 + 264) >> 4) & 0xFFFFFFFFFFFFFF8LL))
                      + 32 * (*(void *)(v4 + 264) & 0x7FLL)
                      + 8);
      *(void *)sub_1002CB32C(v4 + 280, 1u) = v17;
      unint64_t v18 = *(void *)(v4 + 264);
      double v19 = (*(double *)(*(void *)(*(void *)(v4 + 240) + ((v18 >> 4) & 0xFFFFFFFFFFFFFF8LL)) + 32 * (v18 & 0x7F) + 8)
           - *(double *)(*(void *)(*(void *)(v4 + 240) + (((v18 + v12) >> 4) & 0xFFFFFFFFFFFFFF8LL))
                       + 32 * ((v18 + v12) & 0x7F)
                       + 8))
          / v15;
      *(double *)sub_1002CB32C(v4 + 280, 2u) = v19;
      uint64_t v27 = 0x300000003LL;
      int v25 = &off_1007BC508;
      __int128 v26 = xmmword_10042DE90;
      uint64_t v28 = &v29;
      sub_1002CAEDC(&v25, 3, 3);
      sub_1002CAF28((uint64_t)&v25, 0.0);
      for (int i = 0; i != 3; ++i)
        *(void *)sub_100304F3C((uint64_t)&v25, i, i) = 0x3FF0000000000000LL;
      uint64_t v21 = v4 + 344;
      sub_1002CBDC8(v4 + 344, (uint64_t)&v25);
      double v22 = v1[3] * v1[3];
      *(double *)sub_1002CB40C(v4 + 344, 2, 2) = v22;
      double v23 = v1[2];
      if (*(_BYTE *)(*(void *)(*(void *)(v4 + 240) + ((*(void *)(v4 + 264) >> 4) & 0xFFFFFFFFFFFFFF8LL))
                    + 32 * (*(void *)(v4 + 264) & 0x7FLL)
                    + 24) == 1)
      {
        *(double *)sub_1002CB40C(v4 + 344, 0, 0) = v23 * v23;
        double v24 = v1[2] + v1[2];
      }

      else
      {
        *(double *)sub_1002CB40C(v4 + 344, 0, 0) = (v23 + v23) * (v23 + v23);
        double v24 = v1[2];
      }

      LODWORD(v4) = 1;
      *(double *)sub_1002CB40C(v21, 1, 1) = v24 * v24;
    }

    else
    {
      LODWORD(v4) = 0;
    }
  }

  else
  {
    uint64_t v14 = 2LL;
    while (v2 != v14)
    {
      uint64_t v10 = *(void *)(v6 + (((v5 + v14) >> 4) & 0xFFFFFFFFFFFFFF8LL));
      uint64_t v11 = (v5 + v14++) & 0x7F;
      if (*(unsigned __int8 *)(v10 + 32 * v11 + 24) == v9)
      {
        uint64_t v12 = v14 - 1;
        BOOL v13 = v2 > v14 - 1;
        goto LABEL_12;
      }
    }

    BOOL v13 = 0;
  }

  return v13 & v4;
}

uint64_t sub_1003032F8(_DWORD *a1, double a2)
{
  if (a1[20] == 2) {
    unint64_t v2 = (double *)(a1 + 38);
  }
  else {
    unint64_t v2 = (double *)(a1 + 22);
  }
  if (a2 <= 0.0 || v2[7] < a2) {
    return 0LL;
  }
  uint64_t v33 = 0x300000003LL;
  uint64_t v31 = &off_1007BC508;
  __int128 v32 = xmmword_10042DE90;
  char v34 = v35;
  sub_1002CAEDC(&v31, 3, 3);
  sub_1002CAF28((uint64_t)&v31, 0.0);
  for (int i = 0; i != 3; ++i)
    *(void *)sub_100304F3C((uint64_t)&v31, i, i) = 0x3FF0000000000000LL;
  sub_1002CBDC8((uint64_t)(a1 + 114), (uint64_t)&v31);
  *(double *)sub_1002CB40C((uint64_t)(a1 + 114), 0, 2) = a2;
  *(double *)sub_1002CB40C((uint64_t)(a1 + 114), 1, 2) = a2;
  uint64_t v33 = 0x100000003LL;
  uint64_t v31 = &off_1007BC4C0;
  __int128 v32 = xmmword_10042DB70;
  char v34 = v35;
  sub_1002CB548((uint64_t)(a1 + 114), (uint64_t)(a1 + 70), (uint64_t)&v31);
  sub_1002CBDC8((uint64_t)(a1 + 70), (uint64_t)&v31);
  double v7 = v2[4];
  double v8 = pow(a2, 3.0);
  uint64_t v33 = 0x300000003LL;
  uint64_t v31 = &off_1007BC508;
  __int128 v32 = xmmword_10042DE90;
  char v34 = v35;
  sub_1002CAEDC(&v31, 3, 3);
  sub_1002CAF28((uint64_t)&v31, 0.0);
  sub_1002CBDC8((uint64_t)(a1 + 142), (uint64_t)&v31);
  double v9 = a2 * a2 * v7 * 0.5;
  double v10 = v8 * v7 / 3.0;
  *(double *)sub_1002CB40C((uint64_t)(a1 + 142), 1, 1) = v10;
  *(double *)sub_1002CB40C((uint64_t)(a1 + 142), 0, 0) = v10;
  *(double *)sub_1002CB40C((uint64_t)(a1 + 142), 2, 2) = v7 * a2;
  *(double *)sub_1002CB40C((uint64_t)(a1 + 142), 2, 1) = v9;
  *(double *)sub_1002CB40C((uint64_t)(a1 + 142), 2, 0) = v9;
  *(double *)sub_1002CB40C((uint64_t)(a1 + 142), 1, 2) = v9;
  *(double *)sub_1002CB40C((uint64_t)(a1 + 142), 0, 2) = v9;
  uint64_t v23 = 0x300000003LL;
  uint64_t v21 = &off_1007BC508;
  __int128 v22 = xmmword_10042DE90;
  double v24 = &v25;
  sub_1002CB548((uint64_t)(a1 + 114), (uint64_t)(a1 + 86), (uint64_t)&v21);
  unsigned int v11 = a1[117];
  unsigned int v12 = a1[116];
  uint64_t v18 = 0x300000003LL;
  BOOL v13 = &off_1007BC508;
  if (v11 > 3) {
    sub_1003AB150(422, "this->max_num_rows_ >= num_rows");
  }
  if (v12 >= 4) {
    sub_1003AB150(423, "this->max_num_cols_ >= num_cols");
  }
  unsigned int v14 = v11;
  unsigned int v15 = v12;
  int v16 = v12 * v11;
  unsigned int v17 = v11;
  double v19 = &v20;
  sub_1002CB364((uint64_t)(a1 + 114), &v13);
  uint64_t v28 = 0x300000003LL;
  __int128 v26 = &off_1007BC508;
  __int128 v27 = xmmword_10042DE90;
  uint64_t v29 = &v30;
  sub_1002CB548((uint64_t)&v21, (uint64_t)&v13, (uint64_t)&v26);
  uint64_t v33 = 0x300000003LL;
  uint64_t v31 = &off_1007BC508;
  __int128 v32 = xmmword_10042DE90;
  char v34 = v35;
  sub_1002CC25C((uint64_t)&v26, (uint64_t)(a1 + 142), (uint64_t)&v31);
  sub_1002CBDC8((uint64_t)(a1 + 86), (uint64_t)&v31);
  return 1LL;
}

uint64_t sub_100303684(uint64_t a1, int a2, uint64_t a3, double a4)
{
  if (*(_DWORD *)(a1 + 80) == 2) {
    uint64_t v4 = a1 + 152;
  }
  else {
    uint64_t v4 = a1 + 88;
  }
  if (a2 == 1) {
    uint64_t v8 = a1 + 680;
  }
  else {
    uint64_t v8 = a1 + 744;
  }
  sub_1002EDED4((uint64_t)v89, v8);
  if (*(_BYTE *)(a3 + 88) && *(_BYTE *)(a3 + 48))
  {
    double v9 = *(double *)(a3 + 40);
    double v10 = (double *)sub_1002CB32C(a1 + 808, 0);
  }

  else
  {
    double v9 = *(double *)(v4 + 40);
    double v10 = (double *)sub_1002CB40C(a1 + 808, 0, 0);
  }

  double *v10 = v9 * v9;
  uint64_t v70 = 0x300000001LL;
  *(void *)__int128 buf = &off_1007BD1A0;
  __int128 v69 = xmmword_10042E860;
  double v71 = v72;
  sub_1002CB548((uint64_t)v89, a1 + 344, (uint64_t)buf);
  uint64_t v65 = 0x100000003LL;
  unint64_t v66 = 0LL;
  __int128 v64 = 0uLL;
  double v63 = &off_1007BC4C0;
  if (v91 > 3)
  {
    uint64_t v49 = "this->max_num_rows_ >= num_rows";
    int v50 = 422;
    goto LABEL_79;
  }

  if (v90 >= 2)
  {
    uint64_t v49 = "this->max_num_cols_ >= num_cols";
    int v50 = 423;
LABEL_79:
    __assert_rtn("SetMatrixSize", "cnmatrixbase.h", v50, v49);
  }

  *(void *)&__int128 v64 = __PAIR64__(v90, v91);
  DWORD2(v64) = v90 * v91;
  HIDWORD(v64) = v91;
  unint64_t v66 = v67;
  sub_1002CB364((uint64_t)v89, &v63);
  uint64_t v60 = 0x100000001LL;
  __int16 v58 = &off_1007BCA50;
  *(void *)&__int128 v11 = 0x100000001LL;
  *((void *)&v11 + 1) = 0x100000001LL;
  __int128 v59 = v11;
  double v61 = v62;
  sub_1002CB548((uint64_t)buf, (uint64_t)&v63, (uint64_t)&v58);
  uint64_t v86 = 0x100000001LL;
  unsigned int v84 = &off_1007BCA50;
  *(void *)&__int128 v12 = 0x100000001LL;
  *((void *)&v12 + 1) = 0x100000001LL;
  __int128 v85 = v12;
  __int128 v87 = &v88;
  sub_1002CC25C((uint64_t)&v58, a1 + 808, (uint64_t)&v84);
  double v13 = sub_10024061C((uint64_t)&v84, 0, 0);
  uint64_t result = 0LL;
  if (v13 <= 0.0) {
    return result;
  }
  uint64_t v60 = 0x100000003LL;
  double v61 = 0LL;
  __int128 v59 = 0uLL;
  __int16 v58 = &off_1007BC4C0;
  if (v91 > 3)
  {
    unint64_t v51 = "this->max_num_rows_ >= num_rows";
    int v52 = 422;
    goto LABEL_82;
  }

  if (v90 >= 2)
  {
    unint64_t v51 = "this->max_num_cols_ >= num_cols";
    int v52 = 423;
LABEL_82:
    __assert_rtn("SetMatrixSize", "cnmatrixbase.h", v52, v51);
  }

  *(void *)&__int128 v59 = __PAIR64__(v90, v91);
  DWORD2(v59) = v90 * v91;
  HIDWORD(v59) = v91;
  double v61 = v62;
  sub_1002CB364((uint64_t)v89, &v58);
  uint64_t v65 = 0x100000003LL;
  double v63 = &off_1007BC4C0;
  __int128 v64 = xmmword_10042DB70;
  unint64_t v66 = v67;
  sub_1002CB548(a1 + 344, (uint64_t)&v58, (uint64_t)&v63);
  uint64_t v76 = 0x100000001LL;
  __int128 v74 = &off_1007BCA50;
  *(void *)&__int128 v15 = 0x100000001LL;
  *((void *)&v15 + 1) = 0x100000001LL;
  __int128 v75 = v15;
  uint64_t v77 = &v78;
  uint64_t v55 = 0x100000001LL;
  unint64_t v53 = &off_1007BD568;
  __int128 v54 = v15;
  __int16 v56 = v57;
  uint64_t v70 = 0x100000004LL;
  *(void *)__int128 buf = &off_1007BC550;
  __int128 v69 = xmmword_10042DB80;
  double v71 = v72;
  sub_1002D9BF0((uint64_t)&v84, (uint64_t)&v53, (uint64_t)buf, (uint64_t)&v74);
  uint64_t v81 = 0x100000003LL;
  double v79 = &off_1007BC4C0;
  __int128 v80 = xmmword_10042DB70;
  int v82 = &v83;
  sub_1002CB548((uint64_t)&v63, (uint64_t)&v74, (uint64_t)&v79);
  uint64_t v70 = 0x100000001LL;
  *(void *)__int128 buf = &off_1007BCA50;
  *(void *)&__int128 v16 = 0x100000001LL;
  *((void *)&v16 + 1) = 0x100000001LL;
  __int128 v69 = v16;
  double v71 = v72;
  sub_1002CB548((uint64_t)v89, a1 + 280, (uint64_t)buf);
  uint64_t v76 = 0x100000001LL;
  __int128 v74 = &off_1007BCA50;
  *(void *)&__int128 v17 = 0x100000001LL;
  *((void *)&v17 + 1) = 0x100000001LL;
  __int128 v75 = v17;
  uint64_t v77 = &v78;
  sub_100304FBC((uint64_t)buf, (uint64_t)&v74, a4);
  if (*(_DWORD *)(a1 + 216) != 2
    || *(_BYTE *)(a1 + 220)
    || fabs(sub_10024061C((uint64_t)&v74, 0, 0)) <= *(double *)(v4 + 48))
  {
    uint64_t v65 = 0x100000003LL;
    double v63 = &off_1007BC4C0;
    __int128 v64 = xmmword_10042DB70;
    unint64_t v66 = v67;
    sub_1002CB548((uint64_t)&v79, (uint64_t)&v74, (uint64_t)&v63);
    uint64_t v70 = 0x100000003LL;
    *(void *)__int128 buf = &off_1007BC4C0;
    __int128 v69 = xmmword_10042DB70;
    double v71 = v72;
    sub_1002CC25C(a1 + 280, (uint64_t)&v63, (uint64_t)buf);
    sub_1002CBDC8(a1 + 280, (uint64_t)buf);
    uint64_t v60 = 0x300000003LL;
    __int16 v58 = &off_1007BC508;
    __int128 v59 = xmmword_10042DE90;
    double v61 = v62;
    sub_1002CAEDC(&v58, 3, 3);
    sub_1002CAF28((uint64_t)&v58, 0.0);
    for (int i = 0; i != 3; ++i)
      *(void *)sub_100304F3C((uint64_t)&v58, i, i) = 0x3FF0000000000000LL;
    uint64_t v55 = 0x300000003LL;
    unint64_t v53 = &off_1007BC508;
    __int128 v54 = xmmword_10042DE90;
    __int16 v56 = v57;
    sub_1002CB548((uint64_t)&v79, (uint64_t)v89, (uint64_t)&v53);
    uint64_t v65 = 0x300000003LL;
    double v63 = &off_1007BC508;
    __int128 v64 = xmmword_10042DE90;
    unint64_t v66 = v67;
    sub_1002CB44C((uint64_t)&v58, (uint64_t)&v53, (uint64_t)&v63);
    uint64_t v70 = 0x300000003LL;
    *(void *)__int128 buf = &off_1007BC508;
    __int128 v69 = xmmword_10042DE90;
    double v71 = v72;
    sub_1002CB548((uint64_t)&v63, a1 + 344, (uint64_t)buf);
    sub_1002CBDC8(a1 + 344, (uint64_t)buf);
    *(_BYTE *)(a1 + 220) = 0;
    return 1LL;
  }

  else
  {
    uint64_t v18 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "innovation testing...", buf, 2u);
    }

    if (*(void *)(a1 + 272) < 4uLL) {
      goto LABEL_68;
    }
    uint64_t v19 = *(void *)(a1 + 240);
    uint64_t v20 = (uint64_t (**)())(v19 + 8LL * (*(void *)(a1 + 264) >> 7));
    uint64_t v21 = *v20;
    uint64_t v22 = (uint64_t)*v20 + 32 * (*(void *)(a1 + 264) & 0x7FLL);
    if (*(void *)(a1 + 248) == v19) {
      uint64_t v22 = 0LL;
    }
    uint64_t v23 = (v22 - (uint64_t)v21) >> 5;
    uint64_t v24 = v22 - (uint64_t)v21 < -95
        ? (uint64_t)v20[-((unint64_t)(124 - v23) >> 7)] + 32 * (~(124 - v23) & 0x7F)
    *(void *)__int128 buf = v20;
    double v63 = (uint64_t (**)())v22;
    __int16 v58 = v20;
    unint64_t v53 = (uint64_t (**)())v22;
    if (v22 == v24) {
      goto LABEL_62;
    }
    uint64_t v26 = v22 + 32;
    if (v22 + 32 - (void)v21 == 4096)
    {
      __int128 v27 = v20[1];
      ++v20;
      uint64_t v21 = v27;
      uint64_t v26 = (uint64_t)v27;
    }

    if (v26 == v24)
    {
LABEL_62:
      uint64_t v34 = v22;
    }

    else
    {
      double v28 = *(double *)(v26 + 16);
      double v29 = *(double *)(v22 + 16);
      uint64_t v30 = (uint8_t *)&v58;
      if (v28 < v29) {
        uint64_t v30 = buf;
      }
      uint64_t v31 = &v63;
      if (v28 < v29)
      {
        uint64_t v32 = v22;
      }

      else
      {
        uint64_t v31 = &v53;
        uint64_t v32 = v26;
      }

      uint64_t v33 = v28 >= v29 ? v22 : v26;
      *(void *)uint64_t v30 = v20;
      double *v31 = (uint64_t (**)())v26;
      uint64_t v34 = (uint64_t)v63;
      uint64_t v35 = v53;
LABEL_45:
      uint64_t v36 = v32;
      uint64_t v22 = (uint64_t)v35;
      while (1)
      {
        uint64_t v35 = (uint64_t (**)())(v26 + 32);
        if (v26 + 32 - (void)v21 == 4096)
        {
          uint64_t v21 = v20[1];
          uint64_t v37 = v20 + 1;
          uint64_t v35 = (uint64_t (**)())v21;
        }

        else
        {
          uint64_t v37 = v20;
        }

        uint64_t v26 = (uint64_t)(v35 + 4);
        uint64_t v20 = v37;
        if ((char *)(v35 + 4) - (char *)v21 == 4096)
        {
          uint64_t v20 = v37 + 1;
          uint64_t v21 = v37[1];
          uint64_t v26 = (uint64_t)v21;
        }

        if (v26 == v24)
        {
          double v63 = (uint64_t (**)())v34;
          unint64_t v53 = (uint64_t (**)())v22;
          double v46 = *((double *)v35 + 2);
          if (v46 >= *(double *)(v33 + 16))
          {
            unint64_t v47 = &v53;
            __int16 v48 = (uint8_t *)&v58;
          }

          else
          {
            unint64_t v47 = &v63;
            __int16 v48 = buf;
          }

          *(void *)__int16 v48 = v37;
          *unint64_t v47 = v35;
          uint64_t v34 = (uint64_t)v63;
          uint64_t v22 = (uint64_t)v53;
          break;
        }

        double v38 = *(double *)(v26 + 16);
        double v39 = *((double *)v35 + 2);
        double v40 = *(double *)(v33 + 16);
        double v41 = *(double *)(v36 + 16);
        if (v38 >= v39)
        {
          if (v39 < v40)
          {
            uint64_t v34 = (uint64_t)v35;
            uint64_t v33 = (uint64_t)v35;
          }

          uint64_t v35 = (uint64_t (**)())v26;
          uint64_t v32 = v26;
          if (v38 >= v41) {
            goto LABEL_45;
          }
        }

        else
        {
          if (v38 < v40)
          {
            uint64_t v34 = v26;
            uint64_t v33 = v26;
          }

          uint64_t v32 = (uint64_t)v35;
          if (v39 >= v41) {
            goto LABEL_45;
          }
        }
      }
    }

    double v42 = *(double *)(v34 + 16);
    double v43 = *(double *)(v22 + 16);
    if (vabdd_f64(v42, v43) >= 0.1 || fabs(a4 + (v42 + v43) * -0.5) >= 0.2)
    {
LABEL_68:
      uint64_t v45 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_DEFAULT,  "innovation test fails, skipping measurement update",  buf,  2u);
      }

      uint64_t result = 1LL;
      *(_BYTE *)(a1 + 220) = 1;
    }

    else
    {
      unint64_t v44 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v73 = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_DEFAULT,  "kalman fitler states might be faulty due to previous range outliers, reset filter",  v73,  2u);
      }

      return 0LL;
    }
  }

  return result;
}

uint64_t sub_100303F7C(uint64_t a1, uint64_t a2)
{
  if (!v4) {
    return 1LL;
  }
  if (!*(_BYTE *)(a2 + 88)) {
    return 1LL;
  }
  if (!*(_BYTE *)(a2 + 32)) {
    return 1LL;
  }
  double v5 = v3;
  if (v3 >= 0.15) {
    return 1LL;
  }
  double v6 = *(double *)(a2 + 24);
  if (vabdd_f64(v3, v6) <= 0.35) {
    return 1LL;
  }
  double v7 = (os_log_s *)qword_1008000A0;
  BOOL v8 = os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0LL;
  if (v8)
  {
    int v10 = 134218240;
    double v11 = v5;
    __int16 v12 = 2048;
    double v13 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "boundary check fails, filtered range: %.2f, expected range: %.2f",  (uint8_t *)&v10,  0x16u);
    return 0LL;
  }

  return result;
}

uint64_t sub_100304090(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = 1;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_BYTE *)(a1 + 72) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_BYTE *)(a1 + 64) = 0;
  *(void *)a1 = off_1007BD438;
  *(_BYTE *)(a1 + 80) = *a3;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = a1 + 96;
  *(void *)(a1 + 104) = 0LL;
  double v6 = operator new(0xC0uLL);
  sub_100305028((uint64_t)v6, a2);
  *(void *)(a1 + 112) = v6;
  double v7 = operator new(0x358uLL);
  sub_100302590((uint64_t)v7, (uint64_t)a3);
  *(void *)(a1 + 120) = v7;
  if (!*(void *)(a1 + 112)) {
    __assert_rtn("HandoffFilter", "NRBYEstimator.cpp", 674, "_efPtr");
  }
  return a1;
}

void sub_10030416C(_Unwind_Exception *a1)
{
  uint64_t v6 = *(void *)(v1 + 112);
  *(void *)(v1 + 112) = 0LL;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
  }
  sub_100034A98(v3, *(void **)(v1 + 96));
  *(void *)uint64_t v1 = off_1007BD478;
  sub_1001302F0(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_100304204(uint64_t a1, uint64_t a2, uint64_t a3, double a4, double a5)
{
  uint64_t v6 = *(void *)(a1 + 112);
  if (v6 && *(void *)(a1 + 120))
  {
    if (*(_BYTE *)(a3 + 88))
    {
      if (!*(_BYTE *)(a3 + 1)) {
        sub_1003AB1F0();
      }
      sub_100305110((uint64_t **)(a1 + 88), (unsigned __int8 *)a3, (_BYTE *)a3);
      uint64_t v6 = *(void *)(a1 + 112);
    }

    __int128 v11 = *(_OWORD *)(a3 + 16);
    v35[0] = *(_OWORD *)a3;
    v35[1] = v11;
    __int128 v12 = *(_OWORD *)(a3 + 80);
    v35[4] = *(_OWORD *)(a3 + 64);
    void v35[5] = v12;
    __int128 v13 = *(_OWORD *)(a3 + 48);
    unsigned __int16 v35[2] = *(_OWORD *)(a3 + 32);
    v35[3] = v13;
    uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, double, double))(*(void *)v6 + 16LL))( v6,  a2,  v35,  a4,  a5);
    if (!v15) {
      sub_1003AB1C8();
    }
    std::string::size_type v16 = v14;
    double v17 = *(double *)&v14;
    if (!*(_BYTE *)(a1 + 80))
    {
      if (!*(_BYTE *)(a3 + 88))
      {
        *(void *)(a3 + 80) = 0LL;
        *(_OWORD *)(a3 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
        *(_OWORD *)(a3 + 64) = 0u;
        *(_OWORD *)(a3 + 16) = 0u;
        *(_OWORD *)(a3 + 32) = 0u;
        *(_OWORD *)a3 = 0u;
        *(_BYTE *)(a3 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
      }

      *(void *)(a3 + 24) = v14;
      *(_BYTE *)(a3 + 32) = 1;
      uint64_t v19 = *(void *)(a1 + 120);
      __int128 v20 = *(_OWORD *)(a3 + 80);
      v34[4] = *(_OWORD *)(a3 + 64);
      v34[5] = v20;
      __int128 v21 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v21;
      __int128 v22 = *(_OWORD *)(a3 + 48);
      void v34[2] = *(_OWORD *)(a3 + 32);
      void v34[3] = v22;
      double v23 = COERCE_DOUBLE( (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, double, double))(*(void *)v19 + 16LL))( v19,  a2,  v34,  a4,  a5));
      char v25 = v24;
      uint64_t v26 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        if (v25)
        {
          std::to_string(&v36, v23);
          if ((v36.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            __int128 v27 = &v36;
          }
          else {
            __int128 v27 = (std::string *)v36.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)__int128 buf = 134218242;
          std::string::size_type v39 = v16;
          __int16 v40 = 2080;
          double v41 = (const char *)v27;
          _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "exp filter output: %f, kalman filter output: %s",  buf,  0x16u);
        }

        else
        {
          *(_DWORD *)__int128 buf = 134218242;
          std::string::size_type v39 = v16;
          __int16 v40 = 2080;
          double v41 = "N/A";
          _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "exp filter output: %f, kalman filter output: %s",  buf,  0x16u);
        }
      }

      if (!*(_BYTE *)(a3 + 88)) {
        sub_100006080();
      }
      if (*(_BYTE *)(a3 + 80))
      {
        int v28 = *(_DWORD *)(a3 + 56);
        std::string::size_type v29 = *(void *)(a3 + 72);
        if (v25)
        {
          int v30 = sub_10030DE94(v28, v23, *(double *)(a3 + 72));
          uint64_t v31 = (os_log_s *)qword_1008000A0;
          if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(v36.__r_.__value_.__l.__data_) = 134218496;
            *(double *)((char *)v36.__r_.__value_.__r.__words + 4) = v23;
            WORD2(v36.__r_.__value_.__r.__words[1]) = 2048;
            *(std::string::size_type *)((char *)&v36.__r_.__value_.__r.__words[1] + 6) = v29;
            HIWORD(v36.__r_.__value_.__r.__words[2]) = 1024;
            int v37 = v30;
            _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEFAULT,  "kf range_m %.2f, mfs %.1f, check result %d",  (uint8_t *)&v36,  0x1Cu);
          }

          if (v30) {
            double v17 = v23;
          }
          else {
            double v17 = 0.0;
          }
        }

        else
        {
          int v32 = sub_10030DE94(v28, v17, *(double *)(a3 + 72));
          uint64_t v33 = (os_log_s *)qword_1008000A0;
          if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(v36.__r_.__value_.__l.__data_) = 134218496;
            *(std::string::size_type *)((char *)v36.__r_.__value_.__r.__words + 4) = v16;
            WORD2(v36.__r_.__value_.__r.__words[1]) = 2048;
            *(std::string::size_type *)((char *)&v36.__r_.__value_.__r.__words[1] + 6) = v29;
            HIWORD(v36.__r_.__value_.__r.__words[2]) = 1024;
            int v37 = v32;
            _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEFAULT,  "ef range_m %.2f, mfs %.1f, check result %d",  (uint8_t *)&v36,  0x1Cu);
          }

          if (!v32) {
            double v17 = 0.0;
          }
        }
      }

      else if (v25)
      {
        double v17 = v23;
      }
    }
  }

  else
  {
    double v17 = 0.0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
      sub_1003AB19C();
    }
  }

  return *(void *)&v17;
}

void sub_10030460C(void *a1)
{
  uint64_t v2 = a1[14];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 32LL))(v2);
  }
  uint64_t v3 = a1[15];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 32LL))(v3);
  }
  double v5 = (void *)a1[12];
  char v4 = a1 + 12;
  sub_100034A98((uint64_t)(v4 - 1), v5);
  *(v4 - 1) = v4;
  *char v4 = 0LL;
  v4[1] = 0LL;
}

void sub_100304664()
{
}

void *sub_10030468C(void *a1)
{
  *a1 = off_1007BD478;
  sub_1001302F0(a1 + 2);
  return a1;
}

void sub_1003046BC(void *a1)
{
  *a1 = off_1007BD478;
  sub_1001302F0(a1 + 2);
  operator delete(a1);
}

void sub_1003046F0(void *a1)
{
  uint64_t v1 = sub_1002E4BC4(a1);
  operator delete(v1);
}

void sub_100304708(void *a1)
{
  uint64_t v1 = sub_100304734(a1);
  operator delete(v1);
}

void sub_100304720(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1003047A0(a1);
  operator delete(v1);
}

void *sub_100304734(void *a1)
{
  *a1 = off_1007BD3F8;
  a1[101] = off_1007AED90;
  a1[93] = off_1007AED90;
  a1[85] = off_1007AED90;
  a1[71] = off_1007AED90;
  a1[57] = off_1007AED90;
  a1[43] = off_1007AED90;
  a1[35] = off_1007AED90;
  sub_100304B2C(a1 + 29);
  *a1 = off_1007BD478;
  sub_1001302F0(a1 + 2);
  return a1;
}

uint64_t sub_1003047A0(uint64_t a1)
{
  *(void *)a1 = off_1007BD438;
  uint64_t v2 = *(void *)(a1 + 120);
  *(void *)(a1 + 120) = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 112);
  *(void *)(a1 + 112) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  sub_100034A98(a1 + 88, *(void **)(a1 + 96));
  *(void *)a1 = off_1007BD478;
  sub_1001302F0((void *)(a1 + 16));
  return a1;
}

void sub_10030481C(void **a1)
{
  uint64_t v2 = a1[1];
  uint64_t v3 = a1[2];
  unint64_t v4 = v3 - v2;
  if (v3 == v2) {
    uint64_t v5 = 0LL;
  }
  else {
    uint64_t v5 = ((v3 - v2) << 6) - 1;
  }
  uint64_t v6 = (char *)a1[4];
  if (v5 - (unint64_t)&v6[(void)a1[5]] < 0x200)
  {
    uint64_t v7 = (uint64_t)(a1 + 3);
    BOOL v8 = a1[3];
    double v9 = *a1;
    uint64_t v10 = v8 - (_BYTE *)*a1;
    if (v4 >= v10)
    {
      if (v8 == v9) {
        unint64_t v11 = 1LL;
      }
      else {
        unint64_t v11 = v10 >> 2;
      }
      double v46 = a1 + 3;
      stat __p = sub_1000472C0(v7, v11);
      double v43 = (char *)__p;
      unint64_t v44 = (char *)__p;
      uint64_t v45 = (char *)__p + 8 * v12;
      double v41 = operator new(0x1000uLL);
      sub_10011CB88(&__p, &v41);
      __int128 v13 = (char *)a1[1];
      uint64_t v14 = v44;
      if (v13 == a1[2])
      {
        uint64_t v33 = (char *)a1[1];
      }

      else
      {
        do
        {
          if (v14 == v45)
          {
            int64_t v15 = v43 - (_BYTE *)__p;
            if (v43 <= __p)
            {
              if (v14 == __p) {
                unint64_t v23 = 1LL;
              }
              else {
                unint64_t v23 = (v14 - (_BYTE *)__p) >> 2;
              }
              char v24 = (char *)sub_1000472C0((uint64_t)v46, v23);
              uint64_t v26 = v43;
              uint64_t v14 = &v24[8 * (v23 >> 2)];
              uint64_t v27 = v44 - v43;
              if (v44 != v43)
              {
                uint64_t v14 = &v24[8 * (v23 >> 2) + (v27 & 0xFFFFFFFFFFFFFFF8LL)];
                uint64_t v28 = 8 * (v27 >> 3);
                std::string::size_type v29 = &v24[8 * (v23 >> 2)];
                do
                {
                  uint64_t v30 = *(void *)v26;
                  v26 += 8;
                  *(void *)std::string::size_type v29 = v30;
                  v29 += 8;
                  v28 -= 8LL;
                }

                while (v28);
              }

              uint64_t v31 = __p;
              stat __p = v24;
              double v43 = &v24[8 * (v23 >> 2)];
              unint64_t v44 = v14;
              uint64_t v45 = &v24[8 * v25];
              if (v31)
              {
                operator delete(v31);
                uint64_t v14 = v44;
              }
            }

            else
            {
              uint64_t v16 = v15 >> 3;
              BOOL v17 = v15 >> 3 < -1;
              uint64_t v18 = (v15 >> 3) + 2;
              if (v17) {
                uint64_t v19 = v18;
              }
              else {
                uint64_t v19 = v16 + 1;
              }
              __int128 v20 = &v43[-8 * (v19 >> 1)];
              int64_t v21 = v14 - v43;
              if (v14 != v43)
              {
                memmove(&v43[-8 * (v19 >> 1)], v43, v14 - v43);
                uint64_t v14 = v43;
              }

              __int128 v22 = &v14[-8 * (v19 >> 1)];
              uint64_t v14 = &v20[v21];
              double v43 = v22;
              unint64_t v44 = &v20[v21];
            }
          }

          uint64_t v32 = *(void *)v13;
          v13 += 8;
          *(void *)uint64_t v14 = v32;
          uint64_t v14 = v44 + 8;
          v44 += 8;
        }

        while (v13 != a1[2]);
        uint64_t v33 = (char *)a1[1];
      }

      std::string v36 = *a1;
      int v37 = v43;
      *a1 = __p;
      a1[1] = v37;
      stat __p = v36;
      double v43 = v33;
      double v38 = (char *)a1[3];
      std::string::size_type v39 = v45;
      a1[2] = v14;
      a1[3] = v39;
      unint64_t v44 = v13;
      uint64_t v45 = v38;
      if (v14 - v37 == 8) {
        uint64_t v40 = 256LL;
      }
      else {
        uint64_t v40 = (uint64_t)a1[4] + 512;
      }
      a1[4] = (void *)v40;
      if (v13 != v33) {
        unint64_t v44 = &v13[(v33 - v13 + 7) & 0xFFFFFFFFFFFFFFF8LL];
      }
      if (v36) {
        operator delete(v36);
      }
    }

    else
    {
      if (v2 == v9)
      {
        stat __p = operator new(0x1000uLL);
        sub_10011C958(a1, &__p);
        uint64_t v34 = a1[2];
        stat __p = (void *)*(v34 - 1);
        a1[2] = v34 - 1;
      }

      else
      {
        stat __p = operator new(0x1000uLL);
      }

      sub_10011CA6C((uint64_t)a1, &__p);
      if ((_BYTE *)a1[2] - (_BYTE *)a1[1] == 8) {
        uint64_t v35 = 256LL;
      }
      else {
        uint64_t v35 = (uint64_t)a1[4] + 512;
      }
      a1[4] = (void *)v35;
    }
  }

  else
  {
    a1[4] = v6 + 512;
    stat __p = (void *)*((void *)v3 - 1);
    a1[2] = v3 - 8;
    sub_10011CA6C((uint64_t)a1, &__p);
  }

void sub_100304AE0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100304B2C(void *a1)
{
  uint64_t v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  a1[5] = 0LL;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8LL);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }

    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }

  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 64LL;
  }

  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 128LL;
  }

  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    uint64_t v7 = *v2++;
    operator delete(v7);
  }

  return sub_100030AF0((uint64_t)a1);
}

void sub_100304BC0(void **a1)
{
  uint64_t v2 = a1[1];
  uint64_t v3 = a1[2];
  unint64_t v4 = v3 - v2;
  if (v3 == v2) {
    uint64_t v5 = 0LL;
  }
  else {
    uint64_t v5 = 16 * (v3 - v2) - 1;
  }
  uint64_t v6 = (char *)a1[4];
  if (v5 - (unint64_t)&v6[(void)a1[5]] < 0x80)
  {
    uint64_t v7 = (uint64_t)(a1 + 3);
    BOOL v8 = a1[3];
    double v9 = *a1;
    uint64_t v10 = v8 - (_BYTE *)*a1;
    if (v4 >= v10)
    {
      if (v8 == v9) {
        unint64_t v11 = 1LL;
      }
      else {
        unint64_t v11 = v10 >> 2;
      }
      double v46 = a1 + 3;
      stat __p = sub_1000472C0(v7, v11);
      double v43 = (char *)__p;
      unint64_t v44 = (char *)__p;
      uint64_t v45 = (char *)__p + 8 * v12;
      double v41 = operator new(0x1000uLL);
      sub_10011CB88(&__p, &v41);
      __int128 v13 = (char *)a1[1];
      uint64_t v14 = v44;
      if (v13 == a1[2])
      {
        uint64_t v33 = (char *)a1[1];
      }

      else
      {
        do
        {
          if (v14 == v45)
          {
            int64_t v15 = v43 - (_BYTE *)__p;
            if (v43 <= __p)
            {
              if (v14 == __p) {
                unint64_t v23 = 1LL;
              }
              else {
                unint64_t v23 = (v14 - (_BYTE *)__p) >> 2;
              }
              char v24 = (char *)sub_1000472C0((uint64_t)v46, v23);
              uint64_t v26 = v43;
              uint64_t v14 = &v24[8 * (v23 >> 2)];
              uint64_t v27 = v44 - v43;
              if (v44 != v43)
              {
                uint64_t v14 = &v24[8 * (v23 >> 2) + (v27 & 0xFFFFFFFFFFFFFFF8LL)];
                uint64_t v28 = 8 * (v27 >> 3);
                std::string::size_type v29 = &v24[8 * (v23 >> 2)];
                do
                {
                  uint64_t v30 = *(void *)v26;
                  v26 += 8;
                  *(void *)std::string::size_type v29 = v30;
                  v29 += 8;
                  v28 -= 8LL;
                }

                while (v28);
              }

              uint64_t v31 = __p;
              stat __p = v24;
              double v43 = &v24[8 * (v23 >> 2)];
              unint64_t v44 = v14;
              uint64_t v45 = &v24[8 * v25];
              if (v31)
              {
                operator delete(v31);
                uint64_t v14 = v44;
              }
            }

            else
            {
              uint64_t v16 = v15 >> 3;
              BOOL v17 = v15 >> 3 < -1;
              uint64_t v18 = (v15 >> 3) + 2;
              if (v17) {
                uint64_t v19 = v18;
              }
              else {
                uint64_t v19 = v16 + 1;
              }
              __int128 v20 = &v43[-8 * (v19 >> 1)];
              int64_t v21 = v14 - v43;
              if (v14 != v43)
              {
                memmove(&v43[-8 * (v19 >> 1)], v43, v14 - v43);
                uint64_t v14 = v43;
              }

              __int128 v22 = &v14[-8 * (v19 >> 1)];
              uint64_t v14 = &v20[v21];
              double v43 = v22;
              unint64_t v44 = &v20[v21];
            }
          }

          uint64_t v32 = *(void *)v13;
          v13 += 8;
          *(void *)uint64_t v14 = v32;
          uint64_t v14 = v44 + 8;
          v44 += 8;
        }

        while (v13 != a1[2]);
        uint64_t v33 = (char *)a1[1];
      }

      std::string v36 = *a1;
      int v37 = v43;
      *a1 = __p;
      a1[1] = v37;
      stat __p = v36;
      double v43 = v33;
      double v38 = (char *)a1[3];
      std::string::size_type v39 = v45;
      a1[2] = v14;
      a1[3] = v39;
      unint64_t v44 = v13;
      uint64_t v45 = v38;
      if (v14 - v37 == 8) {
        uint64_t v40 = 64LL;
      }
      else {
        uint64_t v40 = (uint64_t)a1[4] + 128;
      }
      a1[4] = (void *)v40;
      if (v13 != v33) {
        unint64_t v44 = &v13[(v33 - v13 + 7) & 0xFFFFFFFFFFFFFFF8LL];
      }
      if (v36) {
        operator delete(v36);
      }
    }

    else
    {
      if (v2 == v9)
      {
        stat __p = operator new(0x1000uLL);
        sub_10011C958(a1, &__p);
        uint64_t v34 = a1[2];
        stat __p = (void *)*(v34 - 1);
        a1[2] = v34 - 1;
      }

      else
      {
        stat __p = operator new(0x1000uLL);
      }

      sub_10011CA6C((uint64_t)a1, &__p);
      if ((_BYTE *)a1[2] - (_BYTE *)a1[1] == 8) {
        uint64_t v35 = 64LL;
      }
      else {
        uint64_t v35 = (uint64_t)a1[4] + 128;
      }
      a1[4] = (void *)v35;
    }
  }

  else
  {
    a1[4] = v6 + 128;
    stat __p = (void *)*((void *)v3 - 1);
    a1[2] = v3 - 8;
    sub_10011CA6C((uint64_t)a1, &__p);
  }

void sub_100304E84( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100304ED0(void *a1, int a2)
{
  uint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  if (v2 == v3) {
    uint64_t v4 = 0LL;
  }
  else {
    uint64_t v4 = 16 * (v2 - v3) - 1;
  }
  unint64_t v5 = v4 - (a1[5] + a1[4]);
  if (v5 < 0x80) {
    a2 = 1;
  }
  if (v5 < 0x100) {
    int v7 = a2;
  }
  else {
    int v7 = 0;
  }
  if ((v7 & 1) == 0)
  {
    operator delete(*(void **)(v2 - 8));
    a1[2] -= 8LL;
  }

  return v7 ^ 1u;
}

uint64_t sub_100304F3C(uint64_t a1, int a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (!v3) {
    sub_1003AB218();
  }
  unsigned int v4 = a2 + *(_DWORD *)(a1 + 20) * a3;
  if ((v4 & 0x80000000) != 0) {
    sub_1003AB240();
  }
  return v3 + 8LL * v4;
}

void *sub_100304F7C(void *result)
{
  *uint64_t result = off_1007BC9D8;
  return result;
}

uint64_t sub_100304F90(uint64_t result)
{
  *(void *)(result + 32) = result + 40;
  return result;
}

void sub_100304F9C(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

_DWORD *sub_100304FBC(uint64_t a1, uint64_t a2, double a3)
{
  if (a1 == a2) {
    sub_1003AB290();
  }
  uint64_t result = sub_1002CAEDC((_DWORD *)a2, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12));
  uint64_t v7 = *(unsigned int *)(a2 + 16);
  if ((int)v7 >= 1)
  {
    BOOL v8 = *(double **)(a1 + 32);
    double v9 = *(double **)(a2 + 32);
    do
    {
      double v10 = *v8++;
      *v9++ = a3 - v10;
      --v7;
    }

    while (v7);
  }

  return result;
}

float sub_100305028(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)(a2 + 88);
  *(_OWORD *)(a1 + 16) = 0u;
  *(_BYTE *)(a1 + 72) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_BYTE *)(a1 + 64) = 0;
  *(void *)a1 = off_1007BD4C8;
  __int128 v2 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 80) = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 96) = v2;
  __int128 v3 = *(_OWORD *)(a2 + 32);
  __int128 v4 = *(_OWORD *)(a2 + 48);
  __int128 v5 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 144) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 160) = v5;
  *(_OWORD *)(a1 + 112) = v3;
  *(_OWORD *)(a1 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = v4;
  *(_BYTE *)(a1 + 176) = 0;
  *(_BYTE *)(a1 + 184) = 0;
  float v6 = *(float *)(a1 + 80);
  uint64_t v7 = "_config.alpha >= 0.0 && _config.alpha <= 1.0";
  int v8 = 188;
  if (v6 < 0.0 || v6 > 1.0) {
LABEL_5:
  }
    __assert_rtn("TimeDependentExpFilter", "NRBYEstimator.h", v8, v7);
  float result = *(float *)(a1 + 84);
  if (result <= 0.0)
  {
    uint64_t v7 = "_config.nominalUpdateIntervalSeconds > 0.0";
    int v8 = 189;
    goto LABEL_5;
  }

  return result;
}

void sub_1003050F0(_Unwind_Exception *a1)
{
  void *v1 = off_1007BD478;
  sub_1001302F0(v2);
  _Unwind_Resume(a1);
}

uint64_t **sub_100305110(uint64_t **a1, unsigned __int8 *a2, _BYTE *a3)
{
  float v6 = a1 + 1;
  __int128 v5 = a1[1];
  if (v5)
  {
    unsigned int v7 = *a2;
    while (1)
    {
      while (1)
      {
        int v8 = (uint64_t **)v5;
        unsigned int v9 = *((unsigned __int8 *)v5 + 25);
        if (v7 >= v9) {
          break;
        }
        __int128 v5 = *v8;
        float v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }

      if (v9 >= v7) {
        break;
      }
      __int128 v5 = v8[1];
      if (!v5)
      {
        float v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    int v8 = a1 + 1;
LABEL_10:
    double v10 = (uint64_t *)operator new(0x20uLL);
    *((_BYTE *)v10 + 25) = *a3;
    sub_10001E548(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }

  return v8;
}

uint64_t sub_1003051C8()
{
  v8[0] = xmmword_1004301B0;
  v8[1] = unk_1004301C0;
  sub_10015EABC((uint64_t)&unk_1007FEE30, (int *)v8, 4LL);
  xmmword_1007FEE48 = xmmword_100423CB0;
  unk_1007FEE58 = xmmword_100423CC0;
  qword_1007FEE70 = 0LL;
  unk_1007FEE78 = 0LL;
  qword_1007FEE68 = 0x3FD999999999999ALL;
  unk_1007FEE80 = xmmword_100423CD0;
  dword_1007FEE90 = 5;
  qword_1007FEE98 = 0x4000000000000000LL;
  dword_1007FEEA0 = 5;
  byte_1007FEEA8 = 0;
  unk_1007FEEAC = 0x30000000ALL;
  xmmword_1007FEEB8 = xmmword_100423CE0;
  unk_1007FEEC8 = xmmword_100423CF0;
  xmmword_1007FEED8 = xmmword_100423D00;
  qword_1007FEEE8 = 0x3FE3333333333333LL;
  dword_1007FEEF0 = 3;
  xmmword_1007FEEF8 = xmmword_100423D10;
  unk_1007FEF08 = xmmword_100423CF0;
  xmmword_1007FEF18 = xmmword_100423CE0;
  qword_1007FEF28 = 0x3FE3333333333333LL;
  byte_1007FEF30 = 0;
  xmmword_1007FEF38 = xmmword_100423D20;
  unk_1007FEF48 = xmmword_100423D30;
  __asm { FMOV            V0.2D, #1.0 }

  __int128 v6 = _Q0;
  xmmword_1007FEF58 = _Q0;
  qword_1007FEF68 = 0xBFD3333333333333LL;
  xmmword_1007FEF70 = xmmword_100423D40;
  qword_1007FEF80 = 0x3E99999A40000000LL;
  xmmword_1007FEF88 = xmmword_100423CC0;
  qword_1007FEFA0 = 0LL;
  unk_1007FEFA8 = 0LL;
  qword_1007FEF98 = 0x3FD999999999999ALL;
  xmmword_1007FEFB0 = xmmword_100423CD0;
  dword_1007FEFC0 = 5;
  qword_1007FEFC8 = 0x4000000000000000LL;
  dword_1007FEFD0 = 4;
  qword_1007FEFD8 = 0x300000008LL;
  qword_1007FEFE0 = 0xC04E800000000000LL;
  unint64_t v7 = 0xC04E800000000000LL;
  sub_10015ED64((uint64_t)algn_1007FEFE8, (double *)&v7, 1LL);
  xmmword_1007FF000 = xmmword_100423D50;
  qword_1007FF010 = 0x4024000000000000LL;
  dword_1007FF018 = 45;
  byte_1007FF020 = 0;
  byte_1007FF038 = 0;
  qword_1007FF040 = 0LL;
  byte_1007FF048 = 0;
  dword_1007FF04C = 1;
  byte_1007FF050 = 1;
  xmmword_1007FF058 = xmmword_100423D60;
  unk_1007FF068 = xmmword_100423D70;
  xmmword_1007FF078 = v6;
  qword_1007FF088 = 0xC059000000000000LL;
  xmmword_1007FF090 = xmmword_100423D80;
  qword_1007FF0A0 = (uint64_t)vdup_n_s32(0x3DCCCCCDu);
  xmmword_1007FF0A8 = xmmword_100423CC0;
  qword_1007FF0B8 = 0x3FD999999999999ALL;
  qword_1007FF0C8 = 0LL;
  qword_1007FF0C0 = 0LL;
  xmmword_1007FF0D0 = xmmword_100423CD0;
  dword_1007FF0E0 = 5;
  qword_1007FF0E8 = 0x4000000000000000LL;
  dword_1007FF0F0 = 10;
  qword_1007FF0F8 = 0x4034000000000000LL;
  dword_1007FF100 = 3;
  xmmword_1007FF108 = xmmword_100423D90;
  return __cxa_atexit((void (*)(void *))sub_10015CF8C, &unk_1007FEE30, (void *)&_mh_execute_header);
}

void sub_100305470(_Unwind_Exception *a1)
{
}

uint64_t sub_100305490(int *a1, _BYTE *a2)
{
  if (*a2 && !a2[4] && a2[3])
  {
    sub_1003054DC(a1, a2);
    return *a1;
  }

  else
  {
    uint64_t result = 0LL;
    *a1 = 0;
  }

  return result;
}

int *sub_1003054DC(int *result, _BYTE *a2)
{
  switch(*result)
  {
    case 0:
      if (a2[2]) {
        goto LABEL_20;
      }
      if (a2[1])
      {
        int v2 = 1;
        goto LABEL_21;
      }

      break;
    case 1:
      if (a2[2]) {
        goto LABEL_20;
      }
      break;
    case 2:
      if (a2[1]) {
        BOOL v3 = 0;
      }
      else {
        BOOL v3 = a2[2] == 0;
      }
      if (v3 && a2[5] != 0 && a2[6] == 0)
      {
        int v2 = 3;
        goto LABEL_21;
      }

      break;
    case 3:
      if (!a2[5])
      {
LABEL_20:
        int v2 = 2;
LABEL_21:
        *uint64_t result = v2;
      }

      break;
    default:
      return result;
  }

  return result;
}

uint64_t sub_100305564(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 40) = 0;
  *(void *)a1 = off_1007BD5B0;
  sub_1002E2680((_BYTE *)(a1 + 48));
  sub_1002FA318(a1 + 448, a2 + 64);
  sub_1002C604C( a1 + 4944,  *(unsigned __int8 *)(a2 + 2),  *(unsigned __int8 *)(a2 + 3),  *(unsigned __int8 *)(a2 + 5),  *(unsigned __int8 *)(a2 + 176),  *(unsigned __int8 *)(a2 + 192));
  sub_10031A92C(a1 + 5504, *(unsigned __int8 *)(a2 + 176), *(unsigned __int8 *)(a2 + 192));
  *(_BYTE *)(a1 + 6000) = 0;
  *(_BYTE *)(a1 + 6032) = 0;
  *(_BYTE *)(a1 + 6040) = 0;
  *(_BYTE *)(a1 + 6056) = 0;
  *(_BYTE *)(a1 + 6064) = 0;
  *(_BYTE *)(a1 + 6144) = 0;
  *(_BYTE *)(a1 + 6152) = 0;
  *(_BYTE *)(a1 + 6156) = 0;
  sub_10030C724(a1 + 6160);
  sub_1002F26B4(a1 + 6528);
  *(_BYTE *)(a1 + 768_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 7696) = 0;
  *(_BYTE *)(a1 + 7704) = 0;
  *(_BYTE *)(a1 + 7712) = 0;
  *(_BYTE *)(a1 + 7720) = 0;
  *(_BYTE *)(a1 + 772_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 7736) = 0;
  *(_BYTE *)(a1 + 7744) = 0;
  *(_BYTE *)(a1 + 7752) = 0;
  *(_BYTE *)(a1 + 7760) = 0;
  *(_BYTE *)(a1 + 776_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_OWORD *)(a1 + 7632) = 0u;
  *(_OWORD *)(a1 + 764_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_OWORD *)(a1 + 7664) = 0u;
  *(_BYTE *)(a1 + 7680) = 0;
  sub_100311650(a1 + 7776, (__n128 *)(a2 + 160));
  *(_BYTE *)(a1 + 7832) = 0;
  *(_BYTE *)(a1 + 784_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 7856) = 0;
  *(_BYTE *)(a1 + 8040) = 0;
  *(_BYTE *)(a1 + 8160) = 0;
  *(_BYTE *)(a1 + 820_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 8216) = 0;
  *(_BYTE *)(a1 + 8264) = 0;
  *(_DWORD *)(a1 + 8272) = 0;
  *(_BYTE *)(a1 + 8276) = 0;
  *(_WORD *)(a1 + 8304) = 0;
  *(_BYTE *)(a1 + 8312) = 0;
  *(_BYTE *)(a1 + 8360) = 0;
  *(_BYTE *)(a1 + 836_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 8376) = 0;
  *(_BYTE *)(a1 + 8384) = 0;
  *(_BYTE *)(a1 + 8392) = 0;
  *(_BYTE *)(a1 + 8400) = 0;
  *(_BYTE *)(a1 + 8432) = 0;
  *(_BYTE *)(a1 + 8464) = 0;
  *(_BYTE *)(a1 + 8472) = 0;
  *(_BYTE *)(a1 + 8480) = 0;
  *(_BYTE *)(a1 + 848_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 8496) = 0;
  *(_OWORD *)(a1 + 804_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_OWORD *)(a1 + 8064) = 0u;
  *(_OWORD *)(a1 + 8080) = 0u;
  *(_OWORD *)(a1 + 8096) = 0u;
  *(_OWORD *)(a1 + 8112) = 0u;
  *(_OWORD *)(a1 + 812_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_WORD *)(a1 + 8144) = 0;
  *(_OWORD *)(a1 + 8440) = 0u;
  *(_BYTE *)(a1 + 8456) = 0;
  *(_DWORD *)(a1 + 8512) = 16843009;
  *(_BYTE *)(a1 + 8516) = 1;
  *(_WORD *)(a1 + 8517) = 256;
  *(void *)(a1 + 8520) = 0x3FF0000000000000LL;
  *(int64x2_t *)(a1 + 852_Block_object_dispose((const void *)(v1 - 112), 8) = vdupq_n_s64(0x404A000000000000uLL);
  *(_OWORD *)(a1 + 8544) = xmmword_1004302C0;
  __asm { FMOV            V0.2D, #2.0 }

  *(_OWORD *)(a1 + 8560) = _Q0;
  *(_WORD *)(a1 + 8576) = 0;
  *(void *)(a1 + 8584) = 0x3FA999999999999ALL;
  *(void *)(a1 + 8592) = 20000LL;
  *(void *)(a1 + 8600) = 0x3FA47AE147AE147BLL;
  *(_OWORD *)(a1 + 860_Block_object_dispose((const void *)(v1 - 112), 8) = xmmword_1004302D0;
  *(_OWORD *)(a1 + 8624) = xmmword_1004302E0;
  *(_OWORD *)(a1 + 8640) = xmmword_1004302F0;
  *(void *)(a1 + 8656) = 0x3FD0000000000000LL;
  *(_BYTE *)(a1 + 8664) = 1;
  *(_OWORD *)(a1 + 8672) = xmmword_10042C760;
  *(_BYTE *)(a1 + 868_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
  *(void *)(a1 + 8696) = 0x4024000000000000LL;
  *(_WORD *)(a1 + 8704) = 256;
  *(_BYTE *)(a1 + 8712) = 0;
  *(_BYTE *)(a1 + 8720) = 0;
  *(_BYTE *)(a1 + 884_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 8864) = 0;
  *(_WORD *)(a1 + 8872) = 0;
  *(_BYTE *)(a1 + 8874) = 0;
  *(_BYTE *)(a1 + 9112) = 0;
  *(_BYTE *)(a1 + 9120) = 0;
  *(_BYTE *)(a1 + 9304) = 0;
  *(_DWORD *)(a1 + 9360) = 0;
  *(_OWORD *)(a1 + 9344) = 0u;
  *(_OWORD *)(a1 + 932_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_OWORD *)(a1 + 9312) = 0u;
  *(_BYTE *)(a1 + 892_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_OWORD *)(a1 + 8912) = 0u;
  *(_OWORD *)(a1 + 8896) = 0u;
  *(_OWORD *)(a1 + 8880) = 0u;
  *(_BYTE *)(a1 + 9376) = 0;
  *(_BYTE *)(a1 + 9504) = 0;
  *(_BYTE *)(a1 + 9520) = 0;
  *(_BYTE *)(a1 + 964_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 9664) = 0;
  *(_BYTE *)(a1 + 9792) = 0;
  *(_DWORD *)(a1 + 980_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 9824) = 0;
  *(_BYTE *)(a1 + 9856) = 0;
  *(_BYTE *)(a1 + 9872) = 0;
  *(_BYTE *)(a1 + 9880) = 0;
  *(void *)(a1 + 988_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  sub_1002C6050(a1 + 4944, 2.0);
  *(_OWORD *)(a1 + 8512) = *(_OWORD *)a2;
  __int128 v9 = *(_OWORD *)(a2 + 16);
  __int128 v10 = *(_OWORD *)(a2 + 32);
  __int128 v11 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 8560) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 8576) = v11;
  *(_OWORD *)(a1 + 852_Block_object_dispose((const void *)(v1 - 112), 8) = v9;
  *(_OWORD *)(a1 + 8544) = v10;
  __int128 v12 = *(_OWORD *)(a2 + 80);
  __int128 v13 = *(_OWORD *)(a2 + 96);
  __int128 v14 = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(a1 + 8624) = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(a1 + 8640) = v14;
  *(_OWORD *)(a1 + 8592) = v12;
  *(_OWORD *)(a1 + 860_Block_object_dispose((const void *)(v1 - 112), 8) = v13;
  __int128 v15 = *(_OWORD *)(a2 + 144);
  __int128 v16 = *(_OWORD *)(a2 + 160);
  __int128 v17 = *(_OWORD *)(a2 + 176);
  *(_WORD *)(a1 + 8704) = *(_WORD *)(a2 + 192);
  *(_OWORD *)(a1 + 8672) = v16;
  *(_OWORD *)(a1 + 868_Block_object_dispose((const void *)(v1 - 112), 8) = v17;
  *(_OWORD *)(a1 + 8656) = v15;
  *(_DWORD *)(a1 + 8504) = 0;
  *(_OWORD *)(a1 + 7600) = 0u;
  return a1;
}

void sub_100305930( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12)
{
  if (*(_BYTE *)(v15 + 1808))
  {
    int64_t v21 = *v18;
    if (*v18)
    {
      v12[973] = v21;
      operator delete(v21);
    }
  }

  sub_100030A5C(v17);
  sub_1003059E4(v16);
  sub_100030A5C(v12 + 782);
  sub_100030A5C(v12 + 776);
  sub_100305A1C(a11);
  sub_100305A80(v14);
  sub_10030B03C(a12);
  _Unwind_Resume(a1);
}

void sub_1003059DC()
{
}

void *sub_1003059E4(void *a1)
{
  return a1;
}

uint64_t sub_100305A1C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 120))
  {
    int v2 = *(void **)(a1 + 88);
    if (v2)
    {
      *(void *)(a1 + 96) = v2;
      operator delete(v2);
    }
  }

  BOOL v3 = *(char **)(a1 + 64);
  *(void *)(a1 + 64) = 0LL;
  if (v3) {
    sub_10030AFB0(a1 + 64, v3);
  }
  return a1;
}

uint64_t sub_100305A80(uint64_t a1)
{
  __int128 v5 = (void **)(a1 + 528);
  sub_1002AF8FC(&v5);
  sub_100030A5C((void *)(a1 + 456));
  int v2 = *(void **)(a1 + 136);
  *(void *)(a1 + 136) = 0LL;
  if (v2) {
    operator delete(v2);
  }
  if (*(_BYTE *)(a1 + 128))
  {
    BOOL v3 = *(void **)(a1 + 96);
    if (v3)
    {
      *(void *)(a1 + 104) = v3;
      operator delete(v3);
    }
  }

  sub_1002AF988((uint64_t *)(a1 + 72), 0LL);
  return a1;
}

uint64_t sub_100305AF8(double a1, double a2, double a3, double a4, double a5, double a6, double a7)
{
  double v10 = a3 * a7;
  if (a3 > 0.0 && v10 <= a5 - a4)
  {
    double v13 = a1 - a2;
    if (((*(void *)&a2 ^ *(void *)&a1) & 0x8000000000000000LL) != 0 && fabs(v13 / a3) > a7)
    {
      uint64_t v19 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        int v25 = 134218496;
        double v26 = a1;
        __int16 v27 = 2048;
        double v28 = a2;
        __int16 v29 = 2048;
        double v30 = a3;
        _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "#findalgs-peoplefinder,overflow detected in peer integrated value, currInteVal: %f, prevInteVal: %f, deltaT: %f",  (uint8_t *)&v25,  0x20u);
      }

      double v20 = a4 - (a5 - a1) - a6;
      if (v13 < 0.0) {
        double v20 = a1 - a4 + a5 + a6;
      }
      double v13 = v20 - a2;
    }

    int64_t v21 = (os_log_s *)qword_1008000A0;
    BOOL v22 = os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG);
    double v23 = fabs(v13);
    if (v22)
    {
      int v25 = 134218496;
      double v24 = v23 / a3;
      double v26 = v23 / a3;
      __int16 v27 = 2048;
      double v28 = v13;
      __int16 v29 = 2048;
      double v30 = a3;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEBUG,  "#findalgs-peoplefinder,Delta derivative calculated for overflow detection: %f, corrected delta: %f, deltaT: %f",  (uint8_t *)&v25,  0x20u);
    }

    else
    {
      double v24 = v23 / a3;
    }

    if (v24 > a7) {
      double v13 = 0.0;
    }
  }

  else
  {
    __int128 v12 = (os_log_s *)qword_1008000A0;
    double v13 = 0.0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR))
    {
      int v25 = 134218496;
      double v26 = a3;
      __int16 v27 = 2048;
      double v28 = v10;
      __int16 v29 = 2048;
      double v30 = a5;
      _os_log_error_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "#findalgs-peoplefinder,invalid time delta, deltaT: %f, max potential value change: %f, max integrated value: %f",  (uint8_t *)&v25,  0x20u);
    }
  }

  return *(void *)&v13;
}

BOOL sub_100305D3C(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(a1 + 8360);
  if (*(_BYTE *)(a1 + 8360))
  {
    if (!*(_BYTE *)(a1 + 8376)) {
      goto LABEL_14;
    }
    int v1 = *(double *)(a1 + 8) - *(double *)(a1 + 8368) < 2.38;
  }

  if (!*(_BYTE *)(a1 + 8432))
  {
    BOOL v2 = 0;
    goto LABEL_8;
  }

  if (!*(_BYTE *)(a1 + 8376)) {
LABEL_14:
  }
    sub_100006080();
  BOOL v2 = *(double *)(a1 + 16) - *(double *)(a1 + 8368) < 2.38;
LABEL_8:
  if (*(_BYTE *)(a1 + 7688)) {
    return 1LL;
  }
  if (*(_BYTE *)(a1 + 7704)) {
    int v1 = 1;
  }
  return ((v1 | v2) & 1) != 0 || *(_BYTE *)(a1 + 7720) != 0;
}

void sub_100305DE4(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = a1 + 8304;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003AB368();
  }
  sub_10030644C(a1, &v80);
  int v6 = v92;
  if (*(_BYTE *)(v4 + 360)) {
    BOOL v7 = v92 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7)
  {
    int v8 = 0;
  }

  else
  {
    if (v94) {
      BOOL v9 = v93 == 0;
    }
    else {
      BOOL v9 = 1;
    }
    int v8 = !v9;
  }

  if (*(_BYTE *)(v4 + 212))
  {
    sub_10031C7D8(a1 + 5504, (uint64_t)&v56);
    if ((_BYTE)v69 && *(_BYTE *)(v4 + 1200))
    {
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
        sub_1003AB33C();
      }
      *(_WORD *)uint64_t v4 = 0;
      sub_100306670(a1, (uint64_t)&v56, v10);
      sub_1003067B4(a1, (uint64_t)&v56);
      sub_100306900(a1, (uint64_t)&v56);
      sub_1003069A8(a1, (uint64_t)&v56);
      DWORD1(v7_Block_object_dispose((const void *)(v1 - 112), 8) = *(_DWORD *)(a1 + 9808);
      BYTE8(v7_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
      if (!(_BYTE)v68) {
        goto LABEL_82;
      }
      if (sub_100306A38(a1, 0, *((float *)&v57 + 2)))
      {
        *(void *)(a1 + 8384) = *(void *)(a1 + 8);
        *(_BYTE *)(v4 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
        __int128 v11 = &v56;
LABEL_79:
        memcpy((void *)a2, v11, 0x180uLL);
        return;
      }

      if ((v8 & 1) == 0) {
        goto LABEL_80;
      }
    }
  }

  else
  {
    __int128 v79 = 0u;
    __int128 v78 = 0u;
    __int128 v77 = 0u;
    __int128 v76 = 0u;
    __int128 v75 = 0u;
    __int128 v74 = 0u;
    __int128 v73 = 0u;
    __int128 v72 = 0u;
    __int128 v71 = 0u;
    __int128 v70 = 0u;
    __int128 v69 = 0u;
    __int128 v68 = 0u;
    __int128 v67 = 0u;
    __int128 v66 = 0u;
    __int128 v65 = 0u;
    __int128 v64 = 0u;
    __int128 v63 = 0u;
    __int128 v62 = 0u;
    __int128 v61 = 0u;
    __int128 v60 = 0u;
    __int128 v59 = 0u;
    __int128 v58 = 0u;
    __int128 v57 = 0u;
    __int128 v56 = 0u;
  }

  if (*(_BYTE *)(v4 + 210) || *(_BYTE *)(v4 + 211))
  {
    sub_1002C80DC(a1 + 4944, (uint64_t)__src, v5);
    if ((_BYTE)v45 && *(_BYTE *)(v4 + 1200))
    {
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
        sub_1003AB310();
      }
      *(_WORD *)uint64_t v4 = 0;
      sub_100306670(a1, (uint64_t)__src, v12);
      sub_1003067B4(a1, (uint64_t)__src);
      sub_100306900(a1, (uint64_t)__src);
      sub_1003069A8(a1, (uint64_t)__src);
      DWORD1(v54) = *(_DWORD *)(a1 + 9808);
      BYTE8(v54) = 1;
      if (!LOBYTE(__src[12])) {
        goto LABEL_82;
      }
      if (sub_100306A38(a1, 0, *((float *)&__src[1] + 2)))
      {
        *(void *)(a1 + 8384) = *(void *)(a1 + 8);
        *(_BYTE *)(v4 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
        __int128 v11 = __src;
        goto LABEL_79;
      }

      if ((v8 & 1) == 0) {
        goto LABEL_80;
      }
    }
  }

  else
  {
    __int128 v55 = 0u;
    __int128 v54 = 0u;
    __int128 v53 = 0u;
    __int128 v52 = 0u;
    __int128 v51 = 0u;
    __int128 v50 = 0u;
    __int128 v49 = 0u;
    __int128 v47 = 0u;
    __int128 v48 = 0u;
    __int128 v45 = 0u;
    __int128 v46 = 0u;
    memset(__src, 0, sizeof(__src));
  }

  if (*(_BYTE *)(v4 + 209))
  {
    sub_1002FB6FC(a1 + 448, (uint64_t)&v20);
  }

  else
  {
    double v13 = 0.0;
    __int128 v42 = 0u;
    __int128 v43 = 0u;
    __int128 v40 = 0u;
    __int128 v41 = 0u;
    __int128 v38 = 0u;
    __int128 v39 = 0u;
    __int128 v36 = 0u;
    __int128 v37 = 0u;
    __int128 v34 = 0u;
    __int128 v35 = 0u;
    __int128 v32 = 0u;
    __int128 v33 = 0u;
    __int128 v30 = 0u;
    __int128 v31 = 0u;
    __int128 v28 = 0u;
    __int128 v29 = 0u;
    __int128 v26 = 0u;
    __int128 v27 = 0u;
    __int128 v24 = 0u;
    __int128 v25 = 0u;
    __int128 v22 = 0u;
    __int128 v23 = 0u;
    __int128 v20 = 0u;
    __int128 v21 = 0u;
  }

  if (*(_BYTE *)(v4 + 1200))
  {
    int v14 = *(unsigned __int8 *)(v4 + 1180);
    if (*(_BYTE *)(v4 + 1180)) {
      int v14 = *(_DWORD *)(a1 + 9480) == 1;
    }
  }

  else
  {
    int v14 = 0;
  }

  if (v6) {
    int v15 = v8;
  }
  else {
    int v15 = 1;
  }
  if (v15) {
    BOOL v16 = v6 != 0;
  }
  else {
    BOOL v16 = *(unsigned __int8 *)(v4 + 1200) != 0;
  }
  if ((v16 & v14 & 1) == 0 && (_BYTE)v33 && BYTE8(v40) && *(_BYTE *)(v4 + 1200) && (_BYTE)v32)
  {
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
      sub_1003AB2E4();
    }
    sub_100306670(a1, (uint64_t)&v20, v17);
    sub_1003067B4(a1, (uint64_t)&v20);
    sub_100306900(a1, (uint64_t)&v20);
    sub_1003069A8(a1, (uint64_t)&v20);
    DWORD1(v42) = *(_DWORD *)(a1 + 9808);
    BYTE8(v42) = 1;
    if (!(_BYTE)v32) {
      goto LABEL_82;
    }
    if (sub_100306A38(a1, 0, *((float *)&v21 + 2)))
    {
      *(void *)(a1 + 8384) = *(void *)(a1 + 8);
      *(_BYTE *)(v4 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
      __int128 v11 = &v20;
      goto LABEL_79;
    }

    if ((v8 & 1) == 0) {
      goto LABEL_80;
    }
  }

  if (v16)
  {
    if (LOBYTE(__src[12]) && (!v91[24] || DWORD1(v82) == 4))
    {
      __int128 v89 = *(_OWORD *)((char *)&__src[8] + 8);
      __int128 v90 = *(_OWORD *)((char *)&__src[9] + 8);
      *(_OWORD *)unsigned int v91 = *(_OWORD *)((char *)&__src[10] + 8);
      *(_OWORD *)&v91[9] = *(_OWORD *)((char *)&__src[11] + 1);
      __int128 v85 = *(_OWORD *)((char *)&__src[4] + 8);
      __int128 v86 = *(_OWORD *)((char *)&__src[5] + 8);
      __int128 v87 = *(_OWORD *)((char *)&__src[6] + 8);
      __int128 v88 = *(_OWORD *)((char *)&__src[7] + 8);
      __int128 v81 = *(_OWORD *)((char *)__src + 8);
      __int128 v82 = *(_OWORD *)((char *)&__src[1] + 8);
      double v13 = *((double *)&__src[2] + 1);
      __int128 v83 = *(_OWORD *)((char *)&__src[2] + 8);
      __int128 v84 = *(_OWORD *)((char *)&__src[3] + 8);
      DWORD1(v82) = 1;
    }

    sub_100306670(a1, (uint64_t)&v80, v13);
    sub_1003067B4(a1, (uint64_t)&v80);
    sub_100306900(a1, (uint64_t)&v80);
    sub_1003069A8(a1, (uint64_t)&v80);
    int v95 = *(_DWORD *)(a1 + 9808);
    char v96 = 1;
    if (v91[24])
    {
      if (sub_100306A38(a1, v8, *(float *)&v82))
      {
        *(void *)(a1 + 8384) = *(void *)(a1 + 8);
        *(_BYTE *)(v4 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
        __int128 v11 = (__int128 *)&v80;
        goto LABEL_79;
      }

      goto LABEL_80;
    }

    goto LABEL_82;
  }

  if (*(_BYTE *)(v4 + 1552)) {
    *(_BYTE *)(v4 + 1552) = 0;
  }
  *(_WORD *)uint64_t v4 = 0;
  if (LOBYTE(__src[12]) && *(double *)(a1 + 8) - *(double *)&__src[1] < 2.0)
  {
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
      sub_1003AB2B8();
    }
    sub_100306CF4((unsigned __int8 *)__src, a1, (uint64_t)&v20, (uint64_t)&v56, (uint64_t)v18);
    sub_1003069A8(a1, (uint64_t)v18);
    v18[89] = *(_DWORD *)(a1 + 9808);
    char v19 = 1;
    if (LOBYTE(__src[12]))
    {
      if (sub_100306A38(a1, 0, *((float *)&__src[1] + 2)))
      {
        *(void *)(a1 + 8384) = *(void *)(a1 + 8);
        *(_BYTE *)(v4 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
        __int128 v11 = (__int128 *)v18;
        goto LABEL_79;
      }

void sub_10030644C(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  uint64_t v4 = a1 + 8304;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003AB3C0();
  }
  a2[22] = 0u;
  a2[23] = 0u;
  a2[20] = 0u;
  a2[21] = 0u;
  a2[18] = 0u;
  a2[19] = 0u;
  a2[16] = 0u;
  a2[17] = 0u;
  a2[14] = 0u;
  a2[15] = 0u;
  a2[12] = 0u;
  a2[13] = 0u;
  a2[10] = 0u;
  a2[11] = 0u;
  a2[8] = 0u;
  a2[9] = 0u;
  a2[6] = 0u;
  a2[7] = 0u;
  a2[4] = 0u;
  a2[5] = 0u;
  a2[2] = 0u;
  a2[3] = 0u;
  *a2 = 0u;
  a2[1] = 0u;
  if (*(_BYTE *)(v4 + 211))
  {
    sub_1002CA180(a1 + 4944, 1, (uint64_t)v12);
    if ((_BYTE)v13) {
      sub_1002E2E18(a1 + 48, (__int128 *)((char *)v12 + 8));
    }
  }

  else
  {
    __int128 v23 = 0uLL;
    __int128 v24 = 0uLL;
    __int128 v21 = 0uLL;
    __int128 v22 = 0uLL;
    __int128 v19 = 0uLL;
    __int128 v20 = 0uLL;
    __int128 v17 = 0uLL;
    __int128 v18 = 0uLL;
    __int128 v15 = 0uLL;
    __int128 v16 = 0uLL;
    __int128 v13 = 0uLL;
    __int128 v14 = 0uLL;
    memset(v12, 0, sizeof(v12));
  }

  if (*(_BYTE *)(v4 + 208))
  {
    sub_1002E2684(a1 + 48, (uint64_t)v11);
  }

  else
  {
    double v9 = 0.0;
    memset(v11, 0, sizeof(v11));
  }

  if (*(_BYTE *)(a1 + 32))
  {
    uint64_t v10 = *(void *)(a1 + 24);
    if (LOBYTE(v11[13]))
    {
      memcpy(a2, v11, 0x17EuLL);
      *(void *)(a1 + 828_Block_object_dispose((const void *)(v1 - 112), 8) = v10;
      *(_WORD *)uint64_t v4 = 256;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
        sub_1003AB394();
      }
    }
  }

double sub_100306670(uint64_t a1, uint64_t a2, double result)
{
  uint64_t v3 = a1 + 9504;
  if (*(_BYTE *)(a1 + 9504) && *(_DWORD *)(a1 + 9456) == 2)
  {
    LODWORD(result) = *(_DWORD *)(a2 + 24);
    BOOL v6 = !*(_BYTE *)(a2 + 208) || *(_BYTE *)(a2 + 192) == 0;
    BOOL v7 = v6 || *(float *)&result == 1.1755e-38;
    if (!v7 && *(_BYTE *)(a1 + 32) && sub_10030AC48(a1, a2, (float32x4_t *)(a1 + 9376), (uint64_t)&v17))
    {
      if (*(_BYTE *)(v3 + 352))
      {
        if (*(_BYTE *)(a1 + 32))
        {
          double v8 = *(double *)(a1 + 8);
          double v9 = (v8 - *(double *)(a1 + 9824)) / (v8 - *(double *)(a1 + 9824) + *(double *)(a1 + 8520));
          double v10 = 1.0 - v9;
          *(float *)&double v9 = v9;
          *(float *)&double v10 = v10;
          float32x4_t v11 = vmlaq_n_f32(vmulq_n_f32(*(float32x4_t *)(a1 + 9840), *(float *)&v10), v17, *(float *)&v9);
          *(float32x4_t *)(a1 + 9840) = v11;
          *(double *)(a1 + 9824) = v8;
          float64x2_t v13 = vcvtq_f64_f32(*(float32x2_t *)v11.f32);
          double v14 = v11.f32[2];
          sub_1002C9108(&v13, (float32x4_t *)(a1 + 9376), (uint64_t)v15);
          uint64_t result = sub_100026A20(v16);
          if (*(_BYTE *)(a2 + 208))
          {
            *(double *)(a2 + 200) = result;
            return result;
          }
        }

void sub_1003067B4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1 + 8515;
  if (*(_BYTE *)(a1 + 8515))
  {
    sub_1002CA180(a1 + 4944, 0, (uint64_t)v7);
    float v4 = v7[6];
    if (LOBYTE(v7[48]) && v7[6] != 1.1755e-38)
    {
      if (*(_BYTE *)(a2 + 192))
      {
        if (*(_BYTE *)(v2 + 197)) {
          BOOL v6 = v7[6] > 1.0;
        }
        else {
          BOOL v6 = v7[6] > 0.9;
        }
        if (v6)
        {
          if (v7[6] > 1.5)
          {
            if (v7[6] > 3.0)
            {
LABEL_15:
              *(_BYTE *)(v2 + 197) = 0;
              return;
            }

            float v4 = (1.0 - (3.0 - v7[6]) / 1.5) * *(float *)(a2 + 24) + (3.0 - v7[6]) / 1.5 * v7[6];
          }

          *(float *)(a2 + 24) = v4;
          goto LABEL_15;
        }

        memcpy((void *)a2, v7, 0x17EuLL);
        *(_BYTE *)(v2 + 197) = 1;
      }

      else
      {
        memcpy((void *)a2, v7, 0x17EuLL);
      }
    }
  }

uint64_t sub_100306900(uint64_t result, uint64_t a2)
{
  if (!*(_BYTE *)(result + 32)
    || !*(_BYTE *)(result + 8496)
    || *(double *)(result + 8) - *(double *)(result + 8488) > 10.0)
  {
    *(_DWORD *)(result + 8504) = 0;
  }

  if (!*(_BYTE *)(result + 8704))
  {
    BOOL v3 = *(float *)(a2 + 24) != 1.1755e-38 && *(_BYTE *)(a2 + 192) != 0;
    char v4 = *(_BYTE *)(a2 + 208);
    BOOL v5 = *(_DWORD *)(result + 8504) == 2;
    char v6 = *(_BYTE *)(result + 7720);
    char v7 = *(_BYTE *)(result + 9504);
    __int16 v8 = 0;
    BOOL v9 = v3;
    char v10 = v4;
    BOOL v11 = v5;
    char v12 = v6;
    return sub_10030ABE4(result, a2, &v7);
  }

  return result;
}

void sub_1003069A8(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 9888) == 1)
  {
    char v4 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)BOOL v5 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#findalgs-peoplefinder,Reporting VIO drift in solution",  v5,  2u);
    }

    *(_BYTE *)(a2 + 380) = 1;
    *(_DWORD *)(a1 + 988_Block_object_dispose((const void *)(v1 - 112), 8) = 2;
  }

BOOL sub_100306A38(uint64_t a1, unsigned __int8 a2, double a3)
{
  BOOL v3 = (_BYTE *)(a1 + 8145);
  if (*(_BYTE *)(a1 + 8145)) {
    return 1LL;
  }
  uint64_t v5 = 8560LL;
  if (!*(_BYTE *)(a1 + 40)) {
    uint64_t v5 = 8544LL;
  }
  uint64_t v6 = 8568LL;
  if (!*(_BYTE *)(a1 + 40)) {
    uint64_t v6 = 8552LL;
  }
  uint64_t v7 = 8528LL;
  if (((*(_BYTE *)(a1 + 8664) != 0) & a2) != 0) {
    uint64_t v7 = 8536LL;
  }
  if (*(double *)(a1 + v7) <= a3
    || ((*(_BYTE *)(a1 + 8664) != 0) & a2) == 0
    && *(void *)(a1 + 8136) < (unint64_t)(int)(*(double *)(a1 + v5) * *(double *)(a1 + v6)))
  {
    return 0LL;
  }

  uint64_t v4 = 1LL;
  *BOOL v3 = 1;
  *(void *)(a1 + 8152) = *(void *)(a1 + 8);
  __int16 v8 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)char v10 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#findalgs-peoplefinder,Condition to show find button met",  v10,  2u);
    return *v3 != 0;
  }

  return v4;
}

uint64_t sub_100306B4C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0LL;
  *(_BYTE *)(a2 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a2 + 192) = 0;
  *(_BYTE *)(a2 + 200) = 0;
  *(_BYTE *)(a2 + 20_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a2 + 216) = 0;
  *(_BYTE *)(a2 + 224) = 0;
  *(_DWORD *)(a2 + 232) = 0;
  *(_BYTE *)(a2 + 240) = 0;
  *(_BYTE *)(a2 + 24_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a2 + 256) = 0;
  *(_BYTE *)(a2 + 272) = 0;
  *(_BYTE *)(a2 + 28_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a2 + 304) = 0;
  *(_BYTE *)(a2 + 320) = 0;
  *(_BYTE *)(a2 + 32_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a2 + 336) = 0;
  *(_BYTE *)(a2 + 344) = 0;
  *(_WORD *)(a2 + 352) = 0;
  *(_BYTE *)(a2 + 356) = 0;
  *(_BYTE *)(a2 + 360) = 0;
  *(_BYTE *)(a2 + 372) = 0;
  *(_BYTE *)(a2 + 376) = 0;
  *(_WORD *)(a2 + 380) = 0;
  *(_DWORD *)(a2 + 364) = 0;
  *(_BYTE *)(a2 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
  if (*(_BYTE *)(a1 + 8040)) {
    uint64_t v4 = *(void *)(a1 + 7856);
  }
  else {
    uint64_t v4 = 0LL;
  }
  double v5 = *(double *)(a1 + 8);
  *(void *)(a2 + _Block_object_dispose((const void *)(v1 - 112), 8) = v4;
  *(double *)(a2 + 16) = v5;
  *(_BYTE *)(a2 + 56) = 0;
  *(_BYTE *)(a2 + 60) = 0;
  *(_BYTE *)(a2 + 64) = 0;
  *(_BYTE *)(a2 + 6_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 40) = 0LL;
  *(void *)(a2 + 24) = 0x100800000LL;
  *(void *)(a2 + 72) = 0LL;
  *(void *)(a2 + 80) = 0LL;
  *(_WORD *)(a2 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a2 + 160) = 0;
  *(void *)(a2 + 176) = 0LL;
  *(void *)(a2 + 184) = 0LL;
  *(void *)(a2 + 16_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  *(_OWORD *)(a2 + 121) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_BYTE *)(a2 + 192) = 1;
  if (*(_BYTE *)(a1 + 8392))
  {
    if (v5 - *(double *)(a1 + 8384) > *(double *)(a1 + 8696))
    {
      if (*(_BYTE *)(a1 + 8145))
      {
        *(_BYTE *)(a2 + 381) = 1;
        *(_BYTE *)(a1 + 8145) = 0;
        uint64_t v6 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int16 v8 = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#findalgs-peoplefinder,disableFindButton set to true",  v8,  2u);
        }
      }
    }
  }

  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003AB3EC();
  }
  return sub_100306900(a1, a2);
}

void sub_100306CF4( unsigned __int8 *__src@<X1>, uint64_t a2@<X0>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  char v10 = (char *)(a2 + 7720);
  memcpy((void *)a5, __src, 0x180uLL);
  else {
    BOOL v11 = *(_BYTE *)(a4 + 5) != 0;
  }
  else {
    BOOL v12 = *(_BYTE *)(a4 + 4) != 0;
  }
  if (!v10[984])
  {
    BOOL v14 = *(_DWORD *)(a2 + 8504) == 2;
    char v15 = *v10;
    LOBYTE(v21) = v10[1784];
    BYTE1(v21) = v12;
    BYTE2(v21) = v11;
    *(_WORD *)((char *)&v21 + 3) = 1;
    BYTE5(v21) = v14;
    BYTE6(v21) = v15;
    sub_10030ABE4(a2, a5, &v21);
    goto LABEL_18;
  }

  if (v11)
  {
    __int16 v13 = 256;
  }

  else
  {
    if (!v12) {
      goto LABEL_18;
    }
    __int16 v13 = 1;
  }

  *(_WORD *)(a5 + 4) = v13;
LABEL_18:
  float v16 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG))
  {
    int v17 = *(unsigned __int8 *)(a3 + 4);
    int v18 = *(unsigned __int8 *)(a4 + 4);
    unint64_t v21 = __PAIR64__(__src[4], 67109888);
    __int16 v22 = 1024;
    int v23 = v17;
    __int16 v24 = 1024;
    int v25 = v18;
    __int16 v26 = 1024;
    BOOL v27 = v12;
    _os_log_debug_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEBUG,  "#findalgs-peoplefinder,#convergence_blending, Insufficient Displacement: SA: %d, PF: %d, SAVIO: %d, Blended: %d",  (uint8_t *)&v21,  0x1Au);
    float v16 = (os_log_s *)qword_1008000A0;
  }

  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
  {
    int v19 = *(unsigned __int8 *)(a3 + 5);
    int v20 = *(unsigned __int8 *)(a4 + 5);
    unint64_t v21 = __PAIR64__(__src[5], 67109888);
    __int16 v22 = 1024;
    int v23 = v19;
    __int16 v24 = 1024;
    int v25 = v20;
    __int16 v26 = 1024;
    BOOL v27 = v11;
    _os_log_debug_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEBUG,  "#findalgs-peoplefinder,#convergence_blending, Insufficient Horizontal Displacement: SA: %d, PF: %d, SAVIO: %d, Blended: %d",  (uint8_t *)&v21,  0x1Au);
  }

  *(_DWORD *)(a5 + 232) = *(_DWORD *)(a3 + 232);
}

double sub_100306F4C(uint64_t a1, uint64_t a2)
{
  BOOL v4 = os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG);
  if (v4) {
    sub_1003AB4C8();
  }
  if (*(_BYTE *)(a1 + 32))
  {
    if (*(_BYTE *)(a2 + 183))
    {
      if (*(_BYTE *)(a2 + 182) == 1)
      {
        if (!*(_BYTE *)(a1 + 40))
        {
          uint64_t v6 = (os_log_s *)qword_1008000A0;
          BOOL v4 = os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT);
          if (v4)
          {
            LOWORD(v40) = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#findalgs-peoplefinder,process Range: Setting reduced range rate to true",  (uint8_t *)&v40,  2u);
          }
        }

        *(_BYTE *)(a1 + 40) = 1;
      }

      else
      {
        if (*(_BYTE *)(a1 + 40))
        {
          uint64_t v7 = (os_log_s *)qword_1008000A0;
          BOOL v4 = os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT);
          if (v4)
          {
            LOWORD(v40) = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "#findalgs-peoplefinder,process Range: Setting reduced range rate to false",  (uint8_t *)&v40,  2u);
          }
        }

        *(_BYTE *)(a1 + 40) = 0;
      }
    }

    else
    {
      *(_BYTE *)(a1 + 40) = 0;
      BOOL v4 = os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR);
      if (v4) {
        sub_1003AB49C();
      }
    }

    if (!*(_BYTE *)(a2 + 181)) {
      goto LABEL_22;
    }
    unsigned int v8 = *(unsigned __int8 *)(a2 + 180);
    if (v8 > 2)
    {
      if (*(_BYTE *)(a1 + 8518) && v8 == 7)
      {
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
          sub_1003AB470();
        }
        goto LABEL_35;
      }

unint64_t sub_100307484(double a1, double a2, uint64_t a3, void *a4)
{
  unint64_t v5 = a4[4];
  uint64_t v6 = a4[1];
  uint64_t v7 = a4[2];
  unsigned int v8 = (void *)(v6 + 8 * (v5 / 0x16));
  if (v7 == v6)
  {
    unint64_t v14 = 0LL;
    uint64_t v10 = a4 + 5;
  }

  else
  {
    unint64_t v9 = *(void *)(v6 + 8 * (v5 / 0x16)) + 184 * (v5 % 0x16);
    uint64_t v10 = a4 + 5;
    unint64_t v11 = *(void *)(v6 + 8 * ((a4[5] + v5) / 0x16)) + 184 * ((a4[5] + v5) % 0x16);
    if (v9 != v11)
    {
      while (a1 - *(double *)(v9 + 8) <= a2)
      {
        v9 += 184LL;
        if (v9 - *v8 == 4048)
        {
          unint64_t v12 = v8[1];
          ++v8;
          unint64_t v9 = v12;
        }

        if (v9 == v11) {
          goto LABEL_18;
        }
      }
    }

    uint64_t v13 = v8;
    if (v9 == v11)
    {
LABEL_18:
      unint64_t v14 = *(void *)(v6 + 8 * ((a4[5] + v5) / 0x16)) + 184 * ((a4[5] + v5) % 0x16);
    }

    else
    {
      unint64_t v14 = v9;
      while (1)
      {
        v9 += 184LL;
        if (v9 - *v13 == 4048)
        {
          unint64_t v15 = v13[1];
          ++v13;
          unint64_t v9 = v15;
        }

        if (v9 == v11) {
          break;
        }
        if (a1 - *(double *)(v9 + 8) <= a2)
        {
          __int128 v16 = *(_OWORD *)v9;
          __int128 v17 = *(_OWORD *)(v9 + 16);
          __int128 v18 = *(_OWORD *)(v9 + 48);
          *(_OWORD *)(v14 + 32) = *(_OWORD *)(v9 + 32);
          *(_OWORD *)(v14 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v18;
          *(_OWORD *)unint64_t v14 = v16;
          *(_OWORD *)(v14 + 16) = v17;
          __int128 v19 = *(_OWORD *)(v9 + 64);
          __int128 v20 = *(_OWORD *)(v9 + 80);
          __int128 v21 = *(_OWORD *)(v9 + 112);
          *(_OWORD *)(v14 + 96) = *(_OWORD *)(v9 + 96);
          *(_OWORD *)(v14 + 112) = v21;
          *(_OWORD *)(v14 + 64) = v19;
          *(_OWORD *)(v14 + 80) = v20;
          __int128 v22 = *(_OWORD *)(v9 + 128);
          __int128 v23 = *(_OWORD *)(v9 + 144);
          __int128 v24 = *(_OWORD *)(v9 + 160);
          *(void *)(v14 + 176) = *(void *)(v9 + 176);
          *(_OWORD *)(v14 + 144) = v23;
          *(_OWORD *)(v14 + 160) = v24;
          *(_OWORD *)(v14 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = v22;
          v14 += 184LL;
          if (v14 - *v8 == 4048)
          {
            unint64_t v25 = v8[1];
            ++v8;
            unint64_t v14 = v25;
          }
        }
      }

      unint64_t v5 = a4[4];
      uint64_t v6 = a4[1];
      uint64_t v7 = a4[2];
    }
  }

  unint64_t v26 = v5 + *v10;
  __int128 v27 = (void *)(v6 + 8 * (v26 / 0x16));
  if (v7 == v6) {
    __int128 v28 = 0LL;
  }
  else {
    __int128 v28 = (char *)(*v27 + 184 * (v26 % 0x16));
  }
  return sub_100307740(a4, v8, (char *)v14, v27, v28);
}

uint64_t sub_100307628(void *a1, __int128 *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 22 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_10030B410(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x16)) + 184 * (v7 % 0x16);
  __int128 v9 = *a2;
  __int128 v10 = a2[1];
  __int128 v11 = a2[3];
  *(_OWORD *)(v8 + 32) = a2[2];
  *(_OWORD *)(v8 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v11;
  *(_OWORD *)unint64_t v8 = v9;
  *(_OWORD *)(v8 + 16) = v10;
  __int128 v12 = a2[4];
  __int128 v13 = a2[5];
  __int128 v14 = a2[7];
  *(_OWORD *)(v8 + 96) = a2[6];
  *(_OWORD *)(v8 + 112) = v14;
  *(_OWORD *)(v8 + 64) = v12;
  *(_OWORD *)(v8 + 80) = v13;
  __int128 v15 = a2[8];
  __int128 v16 = a2[9];
  __int128 v17 = a2[10];
  *(void *)(v8 + 176) = *((void *)a2 + 22);
  *(_OWORD *)(v8 + 144) = v16;
  *(_OWORD *)(v8 + 160) = v17;
  *(_OWORD *)(v8 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = v15;
  uint64_t v18 = a1[4];
  uint64_t v19 = a1[5] + 1LL;
  a1[5] = v19;
  unint64_t v20 = v18 + v19;
  uint64_t v21 = a1[1];
  __int128 v22 = (void *)(v21 + 8 * (v20 / 0x16));
  uint64_t v23 = *v22 + 184 * (v20 % 0x16);
  if (a1[2] == v21) {
    uint64_t v23 = 0LL;
  }
  if (v23 == *v22) {
    uint64_t v23 = *(v22 - 1) + 4048LL;
  }
  return v23 - 184;
}

unint64_t sub_100307740(void *a1, void *a2, char *a3, void *a4, char *a5)
{
  if (a5 == a3) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = 22 * (a4 - a2)
  }
  unint64_t v7 = a1[4];
  uint64_t v8 = a1[1];
  __int128 v9 = (char **)(v8 + 8 * (v7 / 0x16));
  if (a1[2] == v8) {
    __int128 v10 = 0LL;
  }
  else {
    __int128 v10 = &(*v9)[184 * (v7 % 0x16)];
  }
  if (a3 == v10) {
    unint64_t v11 = 0LL;
  }
  else {
    unint64_t v11 = 22 * ((char **)a2 - v9)
  }
  v24[0].n128_u64[0] = v8 + 8 * (v7 / 0x16);
  v24[0].n128_u64[1] = (unint64_t)v10;
  sub_10030B7F4(v24, v11);
  if (v6 >= 1)
  {
    __n128 v12 = v24[0];
    if (v11 <= (unint64_t)(a1[5] - v6) >> 1)
    {
      sub_10030B7F4(v24, v6);
      sub_10030B8A8( v9,  v10,  (char **)v12.n128_u64[0],  (char *)v12.n128_u64[1],  v24[0].n128_u64[0],  (char *)v24[0].n128_u64[1],  v24);
      uint64_t v18 = a1[5] - v6;
      a1[4] += v6;
      a1[5] = v18;
    }

    else
    {
      sub_10030B7F4(v24, v6);
      __n128 v13 = v24[0];
      unint64_t v14 = a1[4] + a1[5];
      uint64_t v15 = a1[1];
      __int128 v16 = (_BYTE **)(v15 + 8 * (v14 / 0x16));
      if (a1[2] == v15) {
        __int128 v17 = 0LL;
      }
      else {
        __int128 v17 = &(*v16)[184 * (v14 % 0x16)];
      }
      v24[0] = v12;
      sub_10030BA54(v13.n128_u64[0], (_BYTE *)v13.n128_u64[1], v16, v17, (uint64_t)v24);
      a1[5] -= v6;
      while ((sub_10030B780(a1, 1) & 1) != 0)
        ;
    }
  }

  unint64_t v19 = a1[4];
  uint64_t v20 = a1[1];
  uint64_t v21 = (void *)(v20 + 8 * (v19 / 0x16));
  if (a1[2] == v20) {
    unint64_t v22 = 0LL;
  }
  else {
    unint64_t v22 = *v21 + 184 * (v19 % 0x16);
  }
  v24[0].n128_u64[0] = (unint64_t)v21;
  v24[0].n128_u64[1] = v22;
  sub_10030B7F4(v24, v11);
  return v24[0].n128_u64[0];
}

void sub_1003079E8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (_BYTE *)(a1 + 8705);
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003AB54C();
  }
  if (*v4)
  {
    if (*(_BYTE *)(a2 + 152))
    {
      double v40 = 0.0;
      sub_10030DAB8(a1, &v40, *(double *)a2);
      sub_10030CB34(a1 + 6160, a2, (uint64_t)&v68, v40);
      uint64_t v5 = (double *)(a1 + 8);
      if (!*(_BYTE *)(a1 + 32)) {
        uint64_t v5 = &v40;
      }
      double v6 = *v5;
      sub_1002F2734((float32x4_t *)(a1 + 6528), a2, (uint64_t)&v43, v40, *v5);
      if (v69) {
        *(float32x4_t *)(a1 + 7600) = vaddq_f32(v68, *(float32x4_t *)(a1 + 7600));
      }
      if (v67)
      {
        *(_DWORD *)(a1 + 980_Block_object_dispose((const void *)(v1 - 112), 8) = v66;
        sub_1002FC9A4(a1 + 448, (uint64_t)&v43);
        if (v51)
        {
          float32x4_t v38 = v44;
          float32x4_t v39 = v45;
          float32x4_t v36 = v47;
          float32x4_t v37 = v46;
          *(double *)&__int128 v7 = sub_1002CE658((float32x4_t)xmmword_100430560);
          uint64_t v8 = 0LL;
          v41[0] = v7;
          v41[1] = v9;
          v41[2] = v10;
          v41[3] = v11;
          do
          {
            v42[v8] = vmlaq_laneq_f32( vmlaq_laneq_f32( vmlaq_lane_f32(vmulq_n_f32(v38, COERCE_FLOAT(v41[v8])), v39, *(float32x2_t *)&v41[v8], 1),  v37,  (float32x4_t)v41[v8],  2),  v36,  (float32x4_t)v41[v8],  3);
            ++v8;
          }

          while (v8 != 4);
          __int128 v12 = v42[0];
          __int128 v13 = v42[1];
          __int128 v14 = v42[2];
          __int128 v15 = v42[3];
          int v16 = v4[799];
          *(_OWORD *)(a1 + 9376) = v43;
          __int128 v17 = v49;
          *(_OWORD *)(a1 + 9456) = v48;
          *(_OWORD *)(a1 + 9472) = v17;
          if (v16)
          {
            *(void *)(a1 + 948_Block_object_dispose((const void *)(v1 - 112), 8) = v50;
          }

          else
          {
            *(_OWORD *)(a1 + 948_Block_object_dispose((const void *)(v1 - 112), 8) = v50;
            v4[799] = 1;
          }

          *(_OWORD *)(a1 + 9392) = v12;
          *(_OWORD *)(a1 + 940_Block_object_dispose((const void *)(v1 - 112), 8) = v13;
          *(_OWORD *)(a1 + 9424) = v14;
          *(_OWORD *)(a1 + 9440) = v15;
          uint64_t v18 = (_OWORD *)(a1 + 9520);
          __int128 v19 = v48;
          if (v4[943])
          {
            *(float32x4_t *)(a1 + 9584) = v47;
            *(_OWORD *)(a1 + 9600) = v19;
            *(_OWORD *)(a1 + 9616) = v49;
            *(void *)(a1 + 9632) = v50;
            float32x4_t v20 = v44;
            _OWORD *v18 = v43;
            *(float32x4_t *)(a1 + 9536) = v20;
            float32x4_t v21 = v46;
            *(float32x4_t *)(a1 + 9552) = v45;
            *(float32x4_t *)(a1 + 956_Block_object_dispose((const void *)(v1 - 112), 8) = v21;
          }

          else
          {
            *(float32x4_t *)(a1 + 9584) = v47;
            *(_OWORD *)(a1 + 9600) = v19;
            __int128 v22 = v50;
            *(_OWORD *)(a1 + 9616) = v49;
            *(_OWORD *)(a1 + 9632) = v22;
            float32x4_t v23 = v44;
            _OWORD *v18 = v43;
            *(float32x4_t *)(a1 + 9536) = v23;
            float32x4_t v24 = v46;
            *(float32x4_t *)(a1 + 9552) = v45;
            *(float32x4_t *)(a1 + 956_Block_object_dispose((const void *)(v1 - 112), 8) = v24;
            v4[943] = 1;
          }

          __int128 v25 = v56;
          *(_OWORD *)(a1 + 9744) = v57;
          __int128 v26 = v59;
          *(_OWORD *)(a1 + 9760) = v58;
          *(_OWORD *)(a1 + 9776) = v26;
          __int128 v27 = v52;
          *(_OWORD *)(a1 + 9680) = v53;
          __int128 v28 = v55;
          *(_OWORD *)(a1 + 9696) = v54;
          *(_OWORD *)(a1 + 9712) = v28;
          *(_OWORD *)(a1 + 972_Block_object_dispose((const void *)(v1 - 112), 8) = v25;
          *(_DWORD *)(a1 + 9632) = v66;
          v4[931] = 1;
          *(_OWORD *)(a1 + 9664) = v27;
          *(_BYTE *)(a1 + 9792) = v60;
          *(double *)(a1 + 9872) = v6;
          v4[1175] = 1;
        }

        else if (v66 == 1)
        {
          if (v4[1175] && v6 - *(double *)(a1 + 9872) <= 3.0)
          {
            if (v4[799])
            {
              if (!v65) {
                sub_100006080();
              }
              float v29 = v62;
              float v30 = v63;
              float v31 = v64;
              float v32 = v61;
              *(double *)&__int128 v33 = sub_1002CE658( vaddq_f32( vmlaq_n_f32( vmulq_n_f32((float32x4_t)xmmword_100430300, v30),  (float32x4_t)xmmword_100430310,  v29),  vmlaq_n_f32( vmulq_n_f32((float32x4_t)xmmword_100430320, v32),  (float32x4_t)xmmword_100430330,  v31)));
              *(_OWORD *)(a1 + 9392) = v33;
              *(_OWORD *)(a1 + 940_Block_object_dispose((const void *)(v1 - 112), 8) = v34;
              *(_OWORD *)(a1 + 9424) = v35;
            }
          }

          else if (v4[799])
          {
            v4[799] = 0;
          }
        }
      }
    }

    else if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG))
    {
      sub_1003AB520();
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG))
  {
    sub_1003AB4F4();
  }

double sub_100307DAC(uint64_t a1, uint64_t a2)
{
  *(void *)&double result = sub_1002F3740(a1 + 6528, a2).n128_u64[0];
  return result;
}

void sub_100307DB8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (_BYTE *)(a1 + 7720);
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003AB578();
  }
  if (*(_DWORD *)(a2 + 80) == 2)
  {
    uint64_t v5 = (double *)(a1 + 8720);
    if (v4[1128])
    {
      double v6 = *(double *)a2;
      double v7 = *v5;
      double v8 = *(double *)a2 - *v5;
      if (v8 > 1.0)
      {
        double v9 = *(float *)(a1 + 8788);
        double v10 = *(float *)(a1 + 8792);
        double v11 = *(float *)(a2 + 64);
        double v12 = *(float *)(a2 + 68);
        double v13 = *(float *)(a2 + 72);
        double v14 = sqrt( (v12 - v9) * (v12 - v9)
              + (v11 - *(float *)(a1 + 8784)) * (v11 - *(float *)(a1 + 8784))
              + (v13 - v10) * (v13 - v10))
            / v8;
        if (v14 > 4.0)
        {
          double v111 = *(float *)(a1 + 8784);
          __int128 v27 = (os_log_s *)qword_1008000A0;
          if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 134220032;
            *(double *)&uint8_t buf[4] = v14;
            *(_WORD *)&_BYTE buf[12] = 2048;
            *(double *)&buf[14] = v11;
            *(_WORD *)&_BYTE buf[22] = 2048;
            *(double *)&_BYTE buf[24] = v12;
            *(_WORD *)__int128 v119 = 2048;
            *(double *)&v119[2] = v13;
            *(_WORD *)&v119[10] = 2048;
            *(double *)&v119[12] = v111;
            *(_WORD *)&v119[20] = 2048;
            *(double *)&v119[22] = v9;
            *(_WORD *)&v119[30] = 2048;
            *(double *)uint64_t v120 = v10;
            *(_WORD *)&v120[8] = 2048;
            *(double *)&v120[10] = v6;
            *(_WORD *)&v120[18] = 2048;
            *(double *)&v120[20] = v7;
            _os_log_error_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_ERROR,  "#findalgs-peoplefinder,Maximum VIO speed exceeded, resetting filters: %f m/s, x: %f, y: %f, z: %f, previou s x: %f, previous y: %f, previous z: %f, current time: %f, previous time: %f  ",  buf,  0x5Cu);
          }

          if (v4[1784]) {
            v4[1784] = 0;
          }
          if (v4[2136]) {
            v4[2136] = 0;
          }
          __int128 v28 = *(_OWORD *)(a2 + 64);
          __int128 v139 = *(_OWORD *)(a2 + 80);
          __int128 v138 = v28;
          __int128 v29 = *(_OWORD *)(a2 + 112);
          __int128 v140 = *(_OWORD *)(a2 + 96);
          __int128 v141 = v29;
          __int128 v30 = *(_OWORD *)(a2 + 16);
          __int128 v134 = *(_OWORD *)a2;
          __int128 v135 = v30;
          __int128 v31 = *(_OWORD *)(a2 + 48);
          __int128 v136 = *(_OWORD *)(a2 + 32);
          __int128 v137 = v31;
          LODWORD(v139) = 1;
          v117[2] = v136;
          v117[3] = v31;
          v117[0] = v134;
          v117[1] = v30;
          v117[6] = v140;
          v117[7] = v29;
          v117[4] = v28;
          v117[5] = v139;
          sub_1002F3360(a1 + 6528, (uint64_t)v117, (uint64_t)buf);
          sub_1002FC9A4(a1 + 448, (uint64_t)buf);
          *(_DWORD *)(a1 + 980_Block_object_dispose((const void *)(v1 - 112), 8) = v133;
          sub_1002C6058(a1 + 4944, (uint64_t)&v134);
          sub_1002E064C((void *)(a1 + 8872), (uint64_t)&v134, v32, v33, v34, v35, v36);
          sub_10030C778((void *)(a1 + 6160));
          __int128 v37 = *(_OWORD *)a2;
          __int128 v38 = *(_OWORD *)(a2 + 16);
          __int128 v39 = *(_OWORD *)(a2 + 48);
          if (v4[1128])
          {
            *(_OWORD *)(a1 + 8752) = *(_OWORD *)(a2 + 32);
            *(_OWORD *)(a1 + 876_Block_object_dispose((const void *)(v1 - 112), 8) = v39;
            *(_OWORD *)uint64_t v5 = v37;
            *(_OWORD *)(a1 + 8736) = v38;
            __int128 v40 = *(_OWORD *)(a2 + 64);
            __int128 v41 = *(_OWORD *)(a2 + 80);
            __int128 v42 = *(_OWORD *)(a2 + 96);
            *(void *)(a1 + 8832) = *(void *)(a2 + 112);
            *(_OWORD *)(a1 + 8800) = v41;
            *(_OWORD *)(a1 + 8816) = v42;
            *(_OWORD *)(a1 + 8784) = v40;
          }

          else
          {
            *(_OWORD *)(a1 + 8752) = *(_OWORD *)(a2 + 32);
            *(_OWORD *)(a1 + 876_Block_object_dispose((const void *)(v1 - 112), 8) = v39;
            *(_OWORD *)uint64_t v5 = v37;
            *(_OWORD *)(a1 + 8736) = v38;
            __int128 v43 = *(_OWORD *)(a2 + 64);
            __int128 v44 = *(_OWORD *)(a2 + 80);
            __int128 v45 = *(_OWORD *)(a2 + 112);
            *(_OWORD *)(a1 + 8816) = *(_OWORD *)(a2 + 96);
            *(_OWORD *)(a1 + 8832) = v45;
            *(_OWORD *)(a1 + 8784) = v43;
            *(_OWORD *)(a1 + 8800) = v44;
            v4[1128] = 1;
          }

          v4[1144] = 1;
          if (!*(_DWORD *)(a1 + 9888)) {
            *(_DWORD *)(a1 + 988_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
          }
        }

        else
        {
          __int128 v15 = *(_OWORD *)a2;
          __int128 v16 = *(_OWORD *)(a2 + 16);
          __int128 v17 = *(_OWORD *)(a2 + 48);
          *(_OWORD *)(a1 + 8752) = *(_OWORD *)(a2 + 32);
          *(_OWORD *)(a1 + 876_Block_object_dispose((const void *)(v1 - 112), 8) = v17;
          *(_OWORD *)uint64_t v5 = v15;
          *(_OWORD *)(a1 + 8736) = v16;
          __int128 v18 = *(_OWORD *)(a2 + 64);
          __int128 v19 = *(_OWORD *)(a2 + 80);
          __int128 v20 = *(_OWORD *)(a2 + 96);
          *(void *)(a1 + 8832) = *(void *)(a2 + 112);
          *(_OWORD *)(a1 + 8800) = v19;
          *(_OWORD *)(a1 + 8816) = v20;
          *(_OWORD *)(a1 + 8784) = v18;
          *(_DWORD *)(a1 + 988_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
          v4[1144] = 0;
        }
      }
    }

    else
    {
      __int128 v21 = *(_OWORD *)a2;
      __int128 v22 = *(_OWORD *)(a2 + 16);
      __int128 v23 = *(_OWORD *)(a2 + 48);
      *(_OWORD *)(a1 + 8752) = *(_OWORD *)(a2 + 32);
      *(_OWORD *)(a1 + 876_Block_object_dispose((const void *)(v1 - 112), 8) = v23;
      *(_OWORD *)uint64_t v5 = v21;
      *(_OWORD *)(a1 + 8736) = v22;
      __int128 v24 = *(_OWORD *)(a2 + 64);
      __int128 v25 = *(_OWORD *)(a2 + 80);
      __int128 v26 = *(_OWORD *)(a2 + 112);
      *(_OWORD *)(a1 + 8816) = *(_OWORD *)(a2 + 96);
      *(_OWORD *)(a1 + 8832) = v26;
      *(_OWORD *)(a1 + 8784) = v24;
      *(_OWORD *)(a1 + 8800) = v25;
      v4[1128] = 1;
    }
  }

  else
  {
    if (v4[1128]) {
      v4[1128] = 0;
    }
    v4[1144] = 0;
    *(_DWORD *)(a1 + 988_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  }

  if (!v4[1144])
  {
    sub_10030D41C(a1 + 6160, a2, (uint64_t)buf);
    __int128 v46 = *(_OWORD *)(a2 + 80);
    v116[4] = *(_OWORD *)(a2 + 64);
    v116[5] = v46;
    __int128 v47 = *(_OWORD *)(a2 + 112);
    v116[6] = *(_OWORD *)(a2 + 96);
    v116[7] = v47;
    __int128 v48 = *(_OWORD *)(a2 + 16);
    v116[0] = *(_OWORD *)a2;
    v116[1] = v48;
    __int128 v49 = *(_OWORD *)(a2 + 48);
    v116[2] = *(_OWORD *)(a2 + 32);
    v116[3] = v49;
    sub_1002F3360(a1 + 6528, (uint64_t)v116, (uint64_t)buf);
    *(_DWORD *)(a1 + 980_Block_object_dispose((const void *)(v1 - 112), 8) = v133;
    float32x4_t v50 = (float32x4_t)xmmword_100430560;
    if (!v4[985])
    {
      if (*(_DWORD *)(a2 + 80) != 2 || *(_BYTE *)(a2 + 84))
      {
        if (v4[1784]) {
          v4[1784] = 0;
        }
        if (v4[2136]) {
          v4[2136] = 0;
        }
      }

      else
      {
        float32x4_t v107 = *(float32x4_t *)(a2 + 16);
        float32x4_t v109 = *(float32x4_t *)(a2 + 32);
        float32x4_t v103 = *(float32x4_t *)(a2 + 64);
        float32x4_t v105 = *(float32x4_t *)(a2 + 48);
        *(double *)&__int128 v51 = sub_1002CE658((float32x4_t)xmmword_100430560);
        uint64_t v52 = 0LL;
        __int128 v112 = v51;
        __int128 v113 = v53;
        __int128 v114 = v54;
        __int128 v115 = v55;
        do
        {
          *(__int128 *)((char *)&v134 + v52) = (__int128)vmlaq_laneq_f32( vmlaq_laneq_f32( vmlaq_lane_f32( vmulq_n_f32( v107,  COERCE_FLOAT(*(__int128 *)((char *)&v112 + v52))),  v109,  *(float32x2_t *)((char *)&v112 + v52),  1),  v105,  *(float32x4_t *)((char *)&v112 + v52),  2),  v103,  *(float32x4_t *)((char *)&v112 + v52),  3);
          v52 += 16LL;
        }

        while (v52 != 64);
        __int128 v56 = v134;
        __int128 v57 = v135;
        __int128 v58 = v136;
        __int128 v59 = v137;
        char v60 = *(_BYTE *)(a2 + 85);
        int v61 = v4[1784];
        *(void *)(a1 + 9376) = *(void *)a2;
        *(_OWORD *)(a1 + 9392) = v56;
        *(_OWORD *)(a1 + 940_Block_object_dispose((const void *)(v1 - 112), 8) = v57;
        *(_OWORD *)(a1 + 9424) = v58;
        *(_OWORD *)(a1 + 9440) = v59;
        *(_DWORD *)(a1 + 9456) = 2;
        v4[1740] = 0;
        v4[1741] = v60;
        v4[1744] = 0;
        v4[1752] = 0;
        v4[1760] = 0;
        v4[1764] = 0;
        if (!v61) {
          v4[1784] = 1;
        }
        v4[1768] = 0;
        v4[1772] = 0;
      }

      sub_1002C6058(a1 + 4944, a2);
      if (v123)
      {
        sub_1002FC9A4(a1 + 448, (uint64_t)buf);
        if (*(_DWORD *)&v120[16] == 2)
        {
          if (!v123) {
            goto LABEL_70;
          }
          char v67 = (_OWORD *)(a1 + 9520);
          __int128 v68 = *(_OWORD *)&v120[16];
          if (v4[1928])
          {
            *(_OWORD *)(a1 + 9584) = *(_OWORD *)v120;
            *(_OWORD *)(a1 + 9600) = v68;
            *(_OWORD *)(a1 + 9616) = v121;
            *(void *)(a1 + 9632) = v122;
            __int128 v69 = *(_OWORD *)&buf[16];
            _OWORD *v67 = *(_OWORD *)buf;
            *(_OWORD *)(a1 + 9536) = v69;
            __int128 v70 = *(_OWORD *)&v119[16];
            *(_OWORD *)(a1 + 9552) = *(_OWORD *)v119;
            *(_OWORD *)(a1 + 956_Block_object_dispose((const void *)(v1 - 112), 8) = v70;
          }

          else
          {
            *(_OWORD *)(a1 + 9584) = *(_OWORD *)v120;
            *(_OWORD *)(a1 + 9600) = v68;
            __int128 v71 = v122;
            *(_OWORD *)(a1 + 9616) = v121;
            *(_OWORD *)(a1 + 9632) = v71;
            __int128 v72 = *(_OWORD *)&buf[16];
            _OWORD *v67 = *(_OWORD *)buf;
            *(_OWORD *)(a1 + 9536) = v72;
            __int128 v73 = *(_OWORD *)&v119[16];
            *(_OWORD *)(a1 + 9552) = *(_OWORD *)v119;
            *(_OWORD *)(a1 + 956_Block_object_dispose((const void *)(v1 - 112), 8) = v73;
            v4[1928] = 1;
          }

          __int128 v63 = v128;
          *(_OWORD *)(a1 + 9744) = v129;
          __int128 v74 = v131;
          *(_OWORD *)(a1 + 9760) = v130;
          *(_OWORD *)(a1 + 9776) = v74;
          __int128 v64 = v124;
          *(_OWORD *)(a1 + 9680) = v125;
          double v62 = *(double *)&v126;
          __int128 v65 = v127;
          *(_OWORD *)(a1 + 9696) = v126;
          *(_OWORD *)(a1 + 9712) = v65;
          *(_OWORD *)(a1 + 972_Block_object_dispose((const void *)(v1 - 112), 8) = v63;
          *(_OWORD *)(a1 + 9664) = v64;
          *(_BYTE *)(a1 + 9792) = v132;
        }
      }

      sub_1002E064C((void *)(a1 + 8872), a2, v62, *(double *)&v63, *(double *)&v64, *(double *)&v65, v66);
      float32x4_t v50 = (float32x4_t)xmmword_100430560;
      if (!v4[985]) {
        goto LABEL_63;
      }
    }

    if (!v123) {
      goto LABEL_63;
    }
    if (BYTE4(v122))
    {
      if (!(_DWORD)v122)
      {
        if (v4[1784]) {
          v4[1784] = 0;
        }
        if (v4[2136]) {
          v4[2136] = 0;
        }
        goto LABEL_56;
      }

      if ((_DWORD)v122 == 5)
      {
LABEL_53:
        float32x4_t v108 = *(float32x4_t *)&buf[16];
        float32x4_t v110 = *(float32x4_t *)v119;
        float32x4_t v104 = *(float32x4_t *)v120;
        float32x4_t v106 = *(float32x4_t *)&v119[16];
        *(double *)&__int128 v75 = sub_1002CE658(v50);
        uint64_t v76 = 0LL;
        __int128 v112 = v75;
        __int128 v113 = v77;
        __int128 v114 = v78;
        __int128 v115 = v79;
        do
        {
          *(__int128 *)((char *)&v134 + v76) = (__int128)vmlaq_laneq_f32( vmlaq_laneq_f32( vmlaq_lane_f32( vmulq_n_f32( v108,  COERCE_FLOAT(*(__int128 *)((char *)&v112 + v76))),  v110,  *(float32x2_t *)((char *)&v112 + v76),  1),  v106,  *(float32x4_t *)((char *)&v112 + v76),  2),  v104,  *(float32x4_t *)((char *)&v112 + v76),  3);
          v76 += 16LL;
        }

        while (v76 != 64);
        __int128 v80 = v134;
        __int128 v81 = v135;
        __int128 v82 = *(_OWORD *)v119;
        *(_OWORD *)(a1 + 9392) = *(_OWORD *)&buf[16];
        *(_OWORD *)(a1 + 940_Block_object_dispose((const void *)(v1 - 112), 8) = v82;
        __int128 v83 = *(_OWORD *)v120;
        *(_OWORD *)(a1 + 9424) = *(_OWORD *)&v119[16];
        *(_OWORD *)(a1 + 9440) = v83;
        __int128 v84 = v121;
        *(_OWORD *)(a1 + 9456) = *(_OWORD *)&v120[16];
        __int128 v85 = v136;
        __int128 v86 = v137;
        *(_OWORD *)(a1 + 9472) = v84;
        *(_OWORD *)(a1 + 948_Block_object_dispose((const void *)(v1 - 112), 8) = v122;
        *(_BYTE *)(a1 + 9504) = v123;
        *(_OWORD *)(a1 + 9376) = *(_OWORD *)buf;
        *(_OWORD *)(a1 + 9392) = v80;
        *(_OWORD *)(a1 + 940_Block_object_dispose((const void *)(v1 - 112), 8) = v81;
        *(_OWORD *)(a1 + 9424) = v85;
        *(_OWORD *)(a1 + 9440) = v86;
        *(void *)(a1 + 9872) = *(void *)buf;
        v4[2160] = 1;
      }
    }

void sub_1003085EC(uint64_t a1, double *a2, int a3)
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003AB724();
  }
  BOOL v6 = sub_10030DADC(a1, &v40, a2[2]);
  double v7 = (os_log_s *)qword_1008000A0;
  if (v6)
  {
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = *((_DWORD *)a2 + 23);
      *(_DWORD *)__int128 buf = 67109376;
      *(_DWORD *)__int128 v42 = v8;
      *(_WORD *)&_OWORD v42[4] = 1024;
      *(_DWORD *)&v42[6] = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "#findalgs-peoplefinder,CL location type: %d,isPeer,%d",  buf,  0xEu);
    }

    if ((a3 & 1) != 0)
    {
      uint64_t v9 = *(int *)(a1 + 8272);
      if (v9 < 7 && ((0x5Fu >> v9) & 1) != 0)
      {
        double v11 = dbl_1004304D8[v9];
      }

      else
      {
        double v10 = (os_log_s *)qword_1008000A0;
        double v11 = 20.0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
          sub_1003AB62C(v9, v10);
        }
      }

      __int128 v20 = (double *)(a1 + 8216);
      int v21 = *(unsigned __int8 *)(a1 + 8264);
      if (*(_BYTE *)(a1 + 8264) && (double v22 = *v20, v40 <= *v20))
      {
        __int128 v26 = (os_log_s *)qword_1008000A0;
        if (!os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
          return;
        }
        double v28 = v22;
        double v27 = a2[7];
      }

      else
      {
        double v23 = a2[7];
        if (v23 > 0.0 && v23 < v11)
        {
          char v24 = *(_BYTE *)(a1 + 7848);
          double v25 = v40;
          if (v24) {
            char v24 = vabdd_f64(*(double *)(a1 + 7832), v40) < 3.0 && *(_BYTE *)(a1 + 7840) != 0;
          }
          __int128 v29 = *(_OWORD *)a2;
          uint64_t v30 = *((void *)a2 + 5);
          if (!*(_BYTE *)(a1 + 8264)) {
            *(_BYTE *)(a1 + 8264) = 1;
          }
          *(double *)(a1 + 8216) = v25;
          *(_OWORD *)(a1 + 8224) = v29;
          *(double *)(a1 + 8240) = v23;
          *(void *)(a1 + 824_Block_object_dispose((const void *)(v1 - 112), 8) = v30;
          *(_BYTE *)(a1 + 8256) = v24;
          __int128 v31 = (os_log_s *)qword_1008000A0;
          if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
            sub_1003AB5A4(v31, (_BYTE *)(a1 + 8264), v32, v33, v34, v35, v36, v37);
          }
          sub_1002E2D34(a1 + 48, a1 + 8216);
          return;
        }

        __int128 v26 = (os_log_s *)qword_1008000A0;
        if (!os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
          return;
        }
        double v27 = v23;
        if (v21) {
          double v28 = *v20;
        }
        else {
          double v28 = -1.0;
        }
      }

      *(_DWORD *)__int128 buf = 134218752;
      *(double *)__int128 v42 = v28;
      *(_WORD *)&v42[8] = 2048;
      double v43 = v40;
      __int16 v44 = 2048;
      double v45 = v27;
      __int16 v46 = 2048;
      double v47 = v11;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEBUG,  "#findalgs-peoplefinder,Not injecting peer location received via NI SPI; duplicate, staleness, or uncertainty che"
        "ck failed, last_timestamp,%.2lf,current_timestamp,%.2lf,hUnc,%.1lf,hUncThreshold,%.1lf",
        buf,
        0x2Au);
      return;
    }

    *(_DWORD *)(a1 + 8272) = *((_DWORD *)a2 + 24);
    if (*((_DWORD *)a2 + 23) == 1)
    {
      double v12 = v40;
      if (!*(_BYTE *)(a1 + 8208) || v40 > *(double *)(a1 + 8160))
      {
        uint64_t v13 = *(void *)a2;
        uint64_t v14 = *((void *)a2 + 1);
        uint64_t v15 = *((void *)a2 + 7);
        uint64_t v16 = *((void *)a2 + 5);
        sub_1000065CC(__p, "Finder");
        BOOL v17 = sub_100311754(a1 + 7776, (uint64_t *)__p, v12);
        if (!*(_BYTE *)(a1 + 8208)) {
          *(_BYTE *)(a1 + 820_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
        }
        *(double *)(a1 + 8160) = v12;
        *(void *)(a1 + 816_Block_object_dispose((const void *)(v1 - 112), 8) = v13;
        *(void *)(a1 + 8176) = v14;
        *(void *)(a1 + 8184) = v15;
        *(void *)(a1 + 0x2000) = v16;
        *(_BYTE *)(a1 + 8200) = v17;
        if (v39 < 0) {
          operator delete(__p[0]);
        }
        __int128 v18 = (os_log_s *)qword_1008000A0;
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
        {
          int v19 = *(_DWORD *)(a1 + 8272);
          *(_DWORD *)__int128 buf = 134218240;
          *(double *)__int128 v42 = v40;
          *(_WORD *)&v42[8] = 1024;
          LODWORD(v43) = v19;
          _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "#findalgs-peoplefinder,Pass self location to CL arrow filter, timestamp: %f,signalEnv,%d",  buf,  0x12u);
        }

        if (!*(_BYTE *)(a1 + 8208)) {
          sub_100006080();
        }
        sub_1002E2DB8(a1 + 48, (__int128 *)(a1 + 8160));
      }
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT))
  {
    sub_1003AB69C(a3, v7);
  }

void sub_1003089F8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100308A1C(uint64_t a1, uint64_t a2)
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003AB77C();
  }
  if (sub_10030DADC(a1, (double *)&v9, *(double *)(a2 + 24)))
  {
    __src[0] = v9;
    *(_OWORD *)&__src[1] = *(_OWORD *)(a2 + 8);
    sub_1002E2D70(a1 + 48, (uint64_t)__src);
    if (*(_BYTE *)(a1 + 8576))
    {
      if (*(_BYTE *)(a1 + 8512))
      {
        sub_1002E2684(a1 + 48, (uint64_t)__src);
      }

      else
      {
        double v8 = 0.0;
        memset(__src, 0, 384);
      }

      if (sub_100308B8C(a1, (uint64_t)__src, v8, v4, v5, v6, v7))
      {
        memcpy(__dst, __src, sizeof(__dst));
        sub_1002FB580(a1 + 448, __dst);
      }
    }
  }

  else if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT))
  {
    sub_1003AB750();
  }

uint64_t sub_100308B8C(uint64_t a1, uint64_t a2, double a3, double a4, double a5, double a6, double a7)
{
  if (!*(_BYTE *)(a2 + 208) || !*(_BYTE *)(a2 + 328) || !*(_BYTE *)(a2 + 192) || !*(_BYTE *)(a2 + 344))
  {
LABEL_142:
    uint64_t v80 = a1 + 8872;
    goto LABEL_143;
  }

  uint64_t v9 = (_BYTE *)(a1 + 7752);
  double v10 = (double *)(a1 + 8);
  if (!*(_BYTE *)(a1 + 32)) {
    double v10 = (double *)(a2 + 16);
  }
  double v11 = *v10;
  int v12 = *(unsigned __int8 *)(a1 + 8515);
  if (*(_BYTE *)(a1 + 8515))
  {
    sub_1002CA180(a1 + 4944, 1, (uint64_t)&v121);
    int v12 = v133;
    double v17 = 0.0;
    if ((_BYTE)v133)
    {
      sub_1002E03F8(a1 + 8872, (uint64_t)&v121, v13, v14, v15, v16, a7);
      int v12 = v133;
      if ((_BYTE)v133)
      {
        int v12 = 1;
        double v17 = *(double *)&v122;
      }
    }
  }

  else
  {
    __int128 v143 = 0u;
    __int128 v144 = 0u;
    __int128 v141 = 0u;
    __int128 v142 = 0u;
    __int128 v139 = 0u;
    __int128 v140 = 0u;
    __int128 v137 = 0u;
    __int128 v138 = 0u;
    __int128 v135 = 0u;
    __int128 v136 = 0u;
    __int128 v133 = 0u;
    __int128 v134 = 0u;
    __int128 v131 = 0u;
    __int128 v132 = 0u;
    __int128 v129 = 0u;
    __int128 v130 = 0u;
    __int128 v127 = 0u;
    __int128 v128 = 0u;
    __int128 v125 = 0u;
    __int128 v126 = 0u;
    __int128 v123 = 0u;
    __int128 v124 = 0u;
    __int128 v121 = 0u;
    __int128 v122 = 0u;
    double v17 = 0.0;
  }

  if (*(_BYTE *)(a2 + 192)) {
    float v18 = *(float *)(a2 + 24);
  }
  else {
    float v18 = INFINITY;
  }
  double v19 = v11 - v17;
  if (v19 >= 20.0) {
    int v12 = 0;
  }
  if (*(_BYTE *)(a2 + 192) && v12)
  {
    double v20 = fmax(v19, 0.0);
    a7 = *((float *)&v122 + 2);
    double v21 = fmax(*((float *)&v122 + 2) - (v20 + v20), 0.0);
    double v22 = *(float *)(a2 + 24);
    double v23 = v22 - (v20 * 0.5 + *((float *)&v122 + 2));
    double v24 = v21 - v22;
    if (v23 >= v24) {
      double v24 = v23;
    }
    *(double *)(a1 + 7744) = v24;
    _BYTE *v9 = 1;
  }

  else if (*v9)
  {
    _BYTE *v9 = 0;
  }

  char v25 = *(_BYTE *)(a2 + 120);
  *(void *)(a1 + 7760) = *(void *)(a2 + 112);
  *(_BYTE *)(a1 + 776_Block_object_dispose((const void *)(v1 - 112), 8) = v25;
  if (!*(_BYTE *)(a1 + 8514) && !*(_BYTE *)(a1 + 8515))
  {
    __int128 v119 = 0u;
    __int128 v120 = 0u;
    __int128 v117 = 0u;
    __int128 v118 = 0u;
    __int128 v115 = 0u;
    __int128 v116 = 0u;
    __int128 v113 = 0u;
    __int128 v114 = 0u;
    __int128 v111 = 0u;
    __int128 v112 = 0u;
    __int128 v109 = 0u;
    __int128 v110 = 0u;
    __int128 v107 = 0u;
    __int128 v108 = 0u;
    __int128 v105 = 0u;
    __int128 v106 = 0u;
    __int128 v103 = 0u;
    __int128 v104 = 0u;
    __int128 v101 = 0u;
    __int128 v102 = 0u;
    __int128 v99 = 0u;
    __int128 v100 = 0u;
    __int128 v97 = 0u;
    __int128 v98 = 0u;
    goto LABEL_33;
  }

  sub_1002C80DC(a1 + 4944, (uint64_t)&v97, a7);
  if (!(_BYTE)v109)
  {
LABEL_33:
    float v26 = *(float *)(a2 + 24);
    goto LABEL_34;
  }

  float v26 = *((float *)&v98 + 2);
LABEL_34:
  int v27 = *(_DWORD *)(a1 + 8272) - 1;
  if (v27 < 6 && ((0x2Fu >> v27) & 1) != 0)
  {
    uint64_t v28 = qword_100430510[v27];
  }

  else
  {
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
      sub_1003AB904();
    }
    uint64_t v28 = 2LL;
  }

  __int128 v29 = (char *)&unk_1004303E0 + 64 * v28;
  if (v26 >= 12.5)
  {
    if (v26 >= 15.0)
    {
      if (v26 >= 17.5)
      {
        if (v26 >= 20.0)
        {
          if (v26 >= 25.0)
          {
            if (v26 >= 30.0)
            {
              uint64_t v30 = 7LL;
              if (v26 < 35.0) {
                uint64_t v30 = 6LL;
              }
            }

            else
            {
              uint64_t v30 = 5LL;
            }
          }

          else
          {
            uint64_t v30 = 4LL;
          }
        }

        else
        {
          uint64_t v30 = 3LL;
        }
      }

      else
      {
        uint64_t v30 = 2LL;
      }
    }

    else
    {
      uint64_t v30 = 1LL;
    }
  }

  else
  {
    uint64_t v30 = 0LL;
  }

  double v31 = *(double *)(a2 + 336);
  if (!*(_BYTE *)(a2 + 344)) {
    double v31 = INFINITY;
  }
  int v32 = *v9;
  double v33 = -1.0;
  if (*v9) {
    double v33 = *(double *)(a1 + 7744);
  }
  double v34 = *(double *)&v29[8 * v30];
  double v35 = v18;
  if (*(_BYTE *)(a2 + 120)) {
    double v36 = *(double *)(a2 + 112);
  }
  else {
    double v36 = -1.0;
  }
  int v37 = *(unsigned __int8 *)(a1 + 8305);
  if (*(_BYTE *)(a1 + 8305)) {
    double v38 = 10.0;
  }
  else {
    double v38 = 12.0;
  }
  int v39 = *(unsigned __int8 *)(a2 + 328);
  unint64_t v40 = *(void *)(a2 + 320);
  if (*(_BYTE *)(a2 + 328)) {
    double v41 = *(double *)(a2 + 320);
  }
  else {
    double v41 = INFINITY;
  }
  if (*v9) {
    BOOL v42 = *(double *)(a1 + 7744) > dbl_100430350[v37 == 0];
  }
  else {
    BOOL v42 = 0;
  }
  double v43 = (unsigned __int8 *)(a1 + 8305);
  double v44 = dbl_100430340[*(_BYTE *)(a1 + 8305) == 0];
  if (v38 > v35 || v41 > v44 || v34 * v31 > 30.0 || v42)
  {
    double v82 = v34 * v31;
    __int128 v48 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_INFO))
    {
      unint64_t v49 = v40;
      unint64_t v50 = 0xBFF0000000000000LL;
      if (!v39) {
        unint64_t v49 = 0xBFF0000000000000LL;
      }
      if (*(_BYTE *)(a2 + 192)) {
        double v51 = *(float *)(a2 + 24);
      }
      else {
        double v51 = -1.0;
      }
      if ((_BYTE)v133) {
        double v52 = *((float *)&v122 + 2);
      }
      else {
        double v52 = -1.0;
      }
      if (v32) {
        unint64_t v50 = *(void *)(a1 + 7744);
      }
      *(_DWORD *)__int128 buf = 134219776;
      *(void *)__int128 v84 = v49;
      *(_WORD *)&v84[8] = 2048;
      *(double *)&v84[10] = v51;
      __int16 v85 = 2048;
      double v86 = v52;
      __int16 v87 = 2048;
      double v88 = v35;
      __int16 v89 = 2048;
      double v90 = v34;
      __int16 v91 = 2048;
      double v92 = v82;
      __int16 v93 = 2048;
      double v94 = v33 / v36;
      __int16 v95 = 2048;
      unint64_t v96 = v50;
      _os_log_impl( (void *)&_mh_execute_header,  v48,  OS_LOG_TYPE_INFO,  "#findalgs-peoplefinder,rejecting CL solution,unc = %.1lf,CL range,%.1lf,rangeFilterRange,%.1lf,fusedRange,%.1lf, bearing_scale_factor,%.1lf,scaled_bearing_unc,%.1lf,abs_range_diff_range_unc,%.1lf,absClRangeMinusUWBRangeM,%.1lf",  buf,  0x52u);
    }

    if (v38 > v35)
    {
      __int128 v53 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_INFO))
      {
        int v54 = *v43;
        *(_DWORD *)__int128 buf = 67109376;
        *(_DWORD *)__int128 v84 = v54;
        *(_WORD *)&v84[4] = 2048;
        *(double *)&v84[6] = v35;
        _os_log_impl( (void *)&_mh_execute_header,  v53,  OS_LOG_TYPE_INFO,  "#findalgs-peoplefinder,#clcc,isLastSolFromCL,%d,RANGE_TO_CLOSE_TO_YIELD_CL_FAILURE,%.1lf",  buf,  0x12u);
      }
    }

    if (v41 > v44)
    {
      __int128 v55 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_INFO))
      {
        int v56 = *v43;
        uint64_t v57 = 0x7FF0000000000000LL;
        if (*(_BYTE *)(a2 + 328)) {
          uint64_t v57 = *(void *)(a2 + 320);
        }
        *(_DWORD *)__int128 buf = 67109376;
        *(_DWORD *)__int128 v84 = v56;
        *(_WORD *)&v84[4] = 2048;
        *(void *)&v84[6] = v57;
        _os_log_impl( (void *)&_mh_execute_header,  v55,  OS_LOG_TYPE_INFO,  "#findalgs-peoplefinder,#clcc,isLastSolFromCL,%d,CL_ANGLE_UNCERTAINTY_FAILURE,%.1lf",  buf,  0x12u);
      }
    }

    if (v82 > 30.0)
    {
      __int128 v58 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_INFO))
      {
        int v59 = *v43;
        *(_DWORD *)__int128 buf = 67109376;
        *(_DWORD *)__int128 v84 = v59;
        *(_WORD *)&v84[4] = 2048;
        *(double *)&v84[6] = v82;
        _os_log_impl( (void *)&_mh_execute_header,  v58,  OS_LOG_TYPE_INFO,  "#findalgs-peoplefinder,#clcc,isLastSolFromCL,%d,CL_BEARING_UNCERTAINTY_FAILURE,%.1lf",  buf,  0x12u);
      }
    }

    if (v42)
    {
      char v60 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_INFO))
      {
        int v61 = *(unsigned __int8 *)(a1 + 8305);
        if (*v9) {
          uint64_t v62 = *(void *)(a1 + 7744);
        }
        else {
          uint64_t v62 = 0LL;
        }
        *(_DWORD *)__int128 buf = 67109376;
        *(_DWORD *)__int128 v84 = v61;
        *(_WORD *)&v84[4] = 2048;
        *(void *)&v84[6] = v62;
        _os_log_impl( (void *)&_mh_execute_header,  v60,  OS_LOG_TYPE_INFO,  "#findalgs-peoplefinder,#clcc,isLastSolFromCL,%d,CL_UWB_RANGE_DIFFERENCE_FAILURE,%.1lf",  buf,  0x12u);
      }
    }

    goto LABEL_142;
  }

  if (!*(_BYTE *)(a1 + 9504))
  {
    __int128 v63 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_INFO))
    {
      if (*(_BYTE *)(a2 + 353)) {
        BOOL v64 = *(_BYTE *)(a2 + 352) == 0;
      }
      else {
        BOOL v64 = 1;
      }
      int v65 = !v64;
      *(_DWORD *)__int128 buf = 67109376;
      *(_DWORD *)__int128 v84 = v37;
      *(_WORD *)&v84[4] = 1024;
      *(_DWORD *)&v84[6] = v65;
      _os_log_impl( (void *)&_mh_execute_header,  v63,  OS_LOG_TYPE_INFO,  "#findalgs-peoplefinder,#clcc,isLastSolFromCL,%d,No valid poses to perform arrow range cross check,producedInGood EnvironmentalConditions,%d",  buf,  0xEu);
    }

    if (*(_BYTE *)(a1 + 8664) && *(_BYTE *)(a2 + 353) && *(_BYTE *)(a2 + 352))
    {
      uint64_t v66 = a1 + 8872;
      uint64_t v67 = 1LL;
      goto LABEL_146;
    }

    goto LABEL_142;
  }

  double v45 = (double *)(a1 + 9376);
  if (*(_BYTE *)(a1 + 8664))
  {
    if (*(_BYTE *)(a2 + 353)) {
      BOOL v46 = *(_BYTE *)(a2 + 352) == 0;
    }
    else {
      BOOL v46 = 1;
    }
    int v47 = !v46;
  }

  else
  {
    int v47 = 0;
  }

  uint64_t v68 = a1 + 8872;
  int v69 = sub_1002E0784(v68, v45, a2, v37 != 0);
  if (v69)
  {
    if (v69 != 2) {
      return 1LL;
    }
    __int128 v70 = (os_log_s *)qword_1008000A0;
    BOOL v71 = os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG);
    if (v47)
    {
      if (v71) {
        sub_1003AB810(v43, v70, v72);
      }
      if ((sub_1002E0D1C(v68) & 1) != 0) {
        return 1LL;
      }
      uint64_t v67 = 1LL;
      uint64_t v66 = v68;
LABEL_146:
      sub_1002E0D2C(v66, 1);
      return v67;
    }

    if (v71) {
      sub_1003AB88C(v43, v70, v72);
    }
    if (*v43) {
      sub_1002E0704(v68);
    }
    goto LABEL_139;
  }

  __int128 v73 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003AB7A8((uint64_t)v43, v73, v74, v75, v76, v77, v78, v79);
  }
  if (*v43) {
    sub_1002E0704(v68);
  }
  uint64_t v67 = sub_1002E0D24(v68);
  if (((v67 ^ 1 | v47) & 1) == 0)
  {
LABEL_139:
    uint64_t v80 = v68;
LABEL_143:
    sub_1002E0D2C(v80, 0);
    return 0LL;
  }

  return v67;
}

void sub_100309448(uint64_t a1, uint64_t a2)
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003AB930();
  }
  if (*(_BYTE *)(a1 + 32)) {
    sub_1003116C0(a1 + 7776, a2, *(double *)(a1 + 8));
  }
}

void sub_1003094B4(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003AB95C(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  *(_BYTE *)(a1 + 8276) = 1;
}

void sub_100309514(uint64_t a1, uint64_t a2)
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003ABD00();
  }
  if (*(_BYTE *)(a2 + 128))
  {
    uint64_t v6 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
      sub_1003ABC78(a2 + 120, v6, (_BYTE *)(a2 + 128), v7, v8, v9, v10, v11);
    }
    sub_10030DAB8(a1, &v130, *(double *)(a2 + 120));
    goto LABEL_7;
  }

  if (*(_BYTE *)(a1 + 32))
  {
    double v2 = *(double *)(a1 + 8);
    double v130 = v2;
    double v19 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
      sub_1003ABC10(v19, v20, v21, v22, v23, v24, v25, v26);
    }
LABEL_7:
    double v13 = v130;
    *(double *)(a1 + 848_Block_object_dispose((const void *)(v1 - 112), 8) = v130;
    *(_BYTE *)(a1 + 8496) = 1;
    int v125 = *(unsigned __int8 *)(a2 + 16);
    if (*(_BYTE *)(a2 + 16))
    {
      double v14 = *(double *)a2;
      int v122 = *(_DWORD *)(a2 + 8);
      sub_1002FD6FC(a1 + 448, v122, v13);
      sub_1002E2E88(a1 + 48, (int *)(a2 + 8), v130);
      int v15 = *(_DWORD *)(a2 + 8);
      double v16 = 0.0;
      if (v15 == 2)
      {
        *(_DWORD *)(a1 + 8504) = 2;
        if (*(double *)a2 != 409.5 || !*(_BYTE *)(a1 + 8464) || *(double *)(a1 + 8456) != 409.5)
        {
          int v127 = 0;
          int v17 = 0;
          *(void *)(a1 + 8456) = *(void *)a2;
          *(_BYTE *)(a1 + 8464) = 1;
          double v14 = v130 - *(double *)a2;
          goto LABEL_44;
        }

        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
          sub_1003ABBE4();
        }
LABEL_36:
        int v127 = 0;
        int v17 = 0;
LABEL_44:
        double v123 = 0.0;
        goto LABEL_47;
      }

      if (v15 != 1)
      {
        if (!v15)
        {
          int v17 = 1;
          *(_DWORD *)(a1 + 8504) = 1;
          if (*(double *)a2 == 409.5
            && *(_BYTE *)(a1 + 8464)
            && *(double *)(a1 + 8456) == 409.5
            && *(_BYTE *)(a1 + 7688))
          {
            float v18 = (os_log_s *)qword_1008000A0;
            if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG))
            {
              *(_WORD *)__int128 buf = 0;
              _os_log_debug_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEBUG,  "#findalgs-peoplefinder,Received bounded displacement with max enter timestamp again.",  buf,  2u);
              int v17 = *(unsigned __int8 *)(a1 + 7688);
              if (!*(_BYTE *)(a1 + 7688)) {
                sub_100006080();
              }
            }

            int v127 = 0;
            double v14 = *(double *)(a1 + 7680);
          }

          else
          {
            *(void *)(a1 + 8456) = *(void *)a2;
            *(_BYTE *)(a1 + 8464) = 1;
            double v14 = v130 - *(double *)a2;
            if (*(_BYTE *)(a1 + 7688)
              && (int v12 = *(_BYTE *)(a1 + 40) == 0,
                  double v2 = *(double *)(a1 + 7680),
                  v14 - v2 > dbl_100430360[*(_BYTE *)(a1 + 40) == 0]))
            {
              if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
                sub_1003ABB80();
              }
              int v127 = 0;
              *(double *)(a1 + 7680) = v14;
              *(_BYTE *)(a1 + 768_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
            }

            else
            {
              int v127 = 0;
            }
          }

          double v123 = 0.0;
          double v16 = v14;
          goto LABEL_47;
        }

        goto LABEL_36;
      }

      int v12 = 1;
      int v127 = 1;
      *(_DWORD *)(a1 + 8504) = 1;
      if (*(double *)a2 == 409.5 && *(_BYTE *)(a1 + 8464) && *(double *)(a1 + 8456) == 409.5)
      {
        if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
          sub_1003ABBE4();
        }
        int v17 = 0;
        double v123 = *(double *)(a1 + 7696);
        int v127 = *(unsigned __int8 *)(a1 + 7704);
      }

      else
      {
        int v17 = 0;
        *(void *)(a1 + 8456) = *(void *)a2;
        *(_BYTE *)(a1 + 8464) = 1;
        double v14 = v130 - *(double *)a2;
        double v123 = v14;
      }
    }

    else
    {
      if (*(_BYTE *)(a1 + 8464)) {
        *(_BYTE *)(a1 + 8464) = 0;
      }
      int v127 = 0;
      int v17 = 0;
      *(_DWORD *)(a1 + 8504) = 0;
      double v14 = 0.0;
      double v123 = 0.0;
      double v16 = 0.0;
    }

void sub_10030A6BC(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 8516))
  {
    sub_10031C7D8(a1 + 5504, (uint64_t)__src);
    if (LOBYTE(__src[13]))
    {
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
        sub_1003ABD2C();
      }
      memcpy(v2, __src, sizeof(v2));
      sub_1002FAC0C(a1 + 448, v2);
    }
  }

  else
  {
    memset(__src, 0, sizeof(__src));
  }

  sub_10031B16C(a1 + 5504);
}

void sub_10030A7C4(uint64_t a1, double a2, double a3, double a4, double a5, double a6)
{
  uint64_t v7 = a1 + 8514;
  if (*(_BYTE *)(a1 + 8514))
  {
    sub_1002C80DC(a1 + 4944, (uint64_t)__src, a6);
    if (*(_BYTE *)(v7 + 63)) {
      BOOL v8 = 1;
    }
    else {
      BOOL v8 = LOBYTE(__src[13]) == 0;
    }
    if (!v8)
    {
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
        sub_1003ABD58();
      }
      memcpy(v9, __src, sizeof(v9));
      sub_1002FAC0C(a1 + 448, v9);
    }
  }

  else
  {
    memset(__src, 0, sizeof(__src));
  }

  sub_1002CA9CC(a1 + 4944, 1);
}

void *sub_10030A8E0(void *a1)
{
  double v2 = std::locale::use_facet(&v5, &std::ctype<char>::id);
  uint64_t v3 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v2->__vftable[2].~facet_0)(v2, 10LL);
  std::locale::~locale(&v5);
  std::ostream::put(a1, v3);
  std::ostream::flush(a1);
  return a1;
}

void sub_10030A95C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
}

void sub_10030A970(uint64_t a1, uint64_t a2, int a3, double a4)
{
  BOOL v8 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG)) {
    sub_1003ABD84(a2, a1, v8);
  }
  if (*(_BYTE *)(a2 + 24) && *(_BYTE *)(a1 + 8208))
  {
    unsigned int v9 = *(_DWORD *)(a2 + 16);
    __int128 v23 = *(_OWORD *)a2;
    v22[0] = sub_100026A04(*(double *)(a1 + 8168));
    if (!*(_BYTE *)(a1 + 8208)) {
      goto LABEL_19;
    }
    v22[1] = sub_100026A04(*(double *)(a1 + 8176));
    double v10 = sub_1003178D4(v9);
    double v11 = sub_100317760(v22, (double *)&v23);
    double v13 = v12;
    double v14 = sub_100026A20(v11);
    double v15 = sub_100026A20(v13);
    if (!*(_BYTE *)(a1 + 8264)) {
      *(_BYTE *)(a1 + 8264) = 1;
    }
    *(double *)(a1 + 8216) = a4;
    *(double *)(a1 + 8224) = v14;
    *(double *)(a1 + 8232) = v15;
    *(double *)(a1 + 8240) = v10;
    *(void *)(a1 + 824_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
    *(_BYTE *)(a1 + 8256) = a3;
    double v16 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(__src[0]) = 134218496;
      *(double *)((char *)__src + 4) = a4;
      WORD6(__src[0]) = 2048;
      *(double *)((char *)__src + 14) = v10;
      WORD3(__src[1]) = 1024;
      DWORD2(__src[1]) = a3;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEBUG,  "#findalgs-peoplefinder,#gri,findee,Pass peer location from UWB pipe to CL arrow filter, timestamp: %f, horUncM, %.1lf, goodGnssSignalConditions, %d",  (uint8_t *)__src,  0x1Cu);
      if (!*(_BYTE *)(a1 + 8264)) {
LABEL_19:
      }
        sub_100006080();
    }

    sub_1002E2D34(a1 + 48, a1 + 8216);
    if (!*(_BYTE *)(a1 + 7848)) {
      *(_BYTE *)(a1 + 784_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
    }
    *(double *)(a1 + 7832) = a4;
    *(_BYTE *)(a1 + 7840) = a3;
    if (*(_BYTE *)(a1 + 8576))
    {
      if (*(_BYTE *)(a1 + 8512))
      {
        sub_1002E2684(a1 + 48, (uint64_t)__src);
      }

      else
      {
        double v21 = 0.0;
        memset(__src, 0, sizeof(__src));
      }

      if (sub_100308B8C(a1, (uint64_t)__src, v21, v17, v18, v19, v20))
      {
        memcpy(__dst, __src, sizeof(__dst));
        sub_1002FB580(a1 + 448, __dst);
      }
    }
  }

uint64_t sub_10030ABE4(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  uint64_t result = sub_100305490((int *)(a1 + 9892), a3);
  if (result > 3)
  {
    uint64_t v5 = 0LL;
  }

  else
  {
    uint64_t v5 = qword_100430540[(int)result];
    *(_DWORD *)(a2 + 372) = dword_100430370[(int)result];
    *(_BYTE *)(a2 + 376) = 1;
  }

  *(void *)a2 = v5;
  return result;
}

uint64_t sub_10030AC48(uint64_t a1, uint64_t a2, float32x4_t *a3, uint64_t a4)
{
  if (a3[5].i32[0] != 2) {
    return 0LL;
  }
  float v4 = *(float *)(a2 + 24);
  BOOL v5 = !*(_BYTE *)(a2 + 208) || *(_BYTE *)(a2 + 192) == 0;
  if (v5 || v4 == 1.1755e-38) {
    return 0LL;
  }
  double v9 = v4;
  __double2 v10 = __sincos_stret(*(double *)(a2 + 200) * 3.14159265 / 180.0);
  float v11 = v10.__cosval * v9;
  float v12 = v10.__sinval * v9;
  float v17 = v11;
  float v18 = v12;
  v19.columns[0] = (simd_float2)sub_1002CA7B4(a3);
  simd_float2x2 v13 = __invert_f2(v19);
  float32x2_t v14 = vmla_n_f32(vmul_n_f32((float32x2_t)v13.columns[0], v17), (float32x2_t)v13.columns[1], v18);
  *(float *)&uint64_t v15 = a3[4].f32[0] + v14.f32[1];
  HIDWORD(v15) = a3[4].i32[1];
  *(float *)(a4 + _Block_object_dispose((const void *)(v1 - 112), 8) = a3[4].f32[2] + v14.f32[0];
  *(void *)a4 = v15;
  return 1LL;
}

uint64_t sub_10030AD2C()
{
  return 1LL;
}

uint64_t sub_10030AD34()
{
  return 0LL;
}

uint64_t sub_10030AD3C()
{
  return 1LL;
}

uint64_t sub_10030AD44()
{
  return 1LL;
}

uint64_t sub_10030AD4C()
{
  return 1LL;
}

uint64_t sub_10030AD54()
{
  return 0LL;
}

uint64_t sub_10030AD5C()
{
  return 1LL;
}

uint64_t sub_10030AD64()
{
  return 1LL;
}

uint64_t sub_10030AD6C()
{
  return 1LL;
}

uint64_t sub_10030AD74()
{
  return 1LL;
}

uint64_t sub_10030AD7C()
{
  return 1LL;
}

uint64_t sub_10030AD84()
{
  return 1LL;
}

uint64_t sub_10030AD8C()
{
  return 1LL;
}

uint64_t sub_10030AD94()
{
  return 1LL;
}

uint64_t sub_10030AD9C()
{
  return 0LL;
}

uint64_t sub_10030ADA4()
{
  return 0LL;
}

uint64_t sub_10030ADAC()
{
  return 0LL;
}

uint64_t sub_10030ADB4()
{
  return 1LL;
}

uint64_t sub_10030ADBC()
{
  return 1LL;
}

uint64_t sub_10030ADC4()
{
  return 1LL;
}

uint64_t sub_10030ADCC()
{
  return 0LL;
}

uint64_t sub_10030ADD4()
{
  return 0LL;
}

void sub_10030ADE0(uint64_t a1)
{
  int v1 = (void *)sub_10030B1FC(a1);
  operator delete(v1);
}

uint64_t sub_10030ADF4(void *a1)
{
  double v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  a1[5] = 0LL;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = (void **)a1[2];
      double v2 = (void **)(a1[1] + 8LL);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }

    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }

  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 28LL;
  }

  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 56LL;
  }

  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    uint64_t v7 = *v2++;
    operator delete(v7);
  }

  return sub_100030AF0((uint64_t)a1);
}

uint64_t sub_10030AE88(void *a1)
{
  double v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  a1[5] = 0LL;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = (void **)a1[2];
      double v2 = (void **)(a1[1] + 8LL);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }

    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }

  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 15LL;
  }

  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 30LL;
  }

  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    uint64_t v7 = *v2++;
    operator delete(v7);
  }

  return sub_100030AF0((uint64_t)a1);
}

uint64_t sub_10030AF1C(void *a1)
{
  double v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  a1[5] = 0LL;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = (void **)a1[2];
      double v2 = (void **)(a1[1] + 8LL);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }

    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }

  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 13LL;
  }

  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 26LL;
  }

  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    uint64_t v7 = *v2++;
    operator delete(v7);
  }

  return sub_100030AF0((uint64_t)a1);
}

void sub_10030AFB0(uint64_t a1, char *a2)
{
  if (a2)
  {
    *((void *)a2 + 62) = off_1007AED90;
    *((void *)a2 + 53) = off_1007AED90;
    unint64_t v5 = (void **)(a2 + 360);
    sub_1002D6608(&v5);
    *((void *)a2 + 30) = off_1007AED90;
    *((void *)a2 + 20) = off_1007AED90;
    *((void *)a2 + 12) = off_1007AED90;
    unint64_t v5 = (void **)(a2 + 72);
    sub_1002D65AC(&v5);
    uint64_t v3 = (void *)*((void *)a2 + 5);
    if (v3)
    {
      *((void *)a2 + 6) = v3;
      operator delete(v3);
    }

    unint64_t v4 = *(void **)a2;
    if (*(void *)a2)
    {
      *((void *)a2 + 1) = v4;
      operator delete(v4);
    }

    operator delete(a2);
  }

uint64_t sub_10030B03C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 80))
  {
    double v2 = *(void **)(a1 + 56);
    if (v2)
    {
      *(void *)(a1 + 64) = v2;
      operator delete(v2);
    }
  }

  if (*(_BYTE *)(a1 + 24))
  {
    uint64_t v3 = *(void **)a1;
    if (*(void *)a1)
    {
      *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = v3;
      operator delete(v3);
    }
  }

  return a1;
}

uint64_t sub_10030B0BC(void *a1)
{
  double v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  if (v3 == v2)
  {
    unint64_t v4 = a1 + 5;
    uint64_t v3 = (void **)a1[1];
  }

  else
  {
    unint64_t v4 = a1 + 5;
    unint64_t v5 = a1[4];
    uint64_t v6 = &v2[v5 / 0x49];
    unint64_t v7 = (unint64_t)v2[(a1[5] + v5) / 0x49] + 56 * ((a1[5] + v5) % 0x49);
    if ((char *)*v6 + 56 * (v5 % 0x49) != (void *)v7)
    {
      BOOL v8 = (void (***)(void))((char *)*v6 + 56 * (v5 % 0x49));
      do
      {
        double v9 = *v8;
        v8 += 7;
        (*v9)();
        if ((char *)v8 - (_BYTE *)*v6 == 4088)
        {
          __double2 v10 = (void (***)(void))v6[1];
          ++v6;
          BOOL v8 = v10;
        }
      }

      while (v8 != (void (***)(void))v7);
      double v2 = (void **)a1[1];
      uint64_t v3 = (void **)a1[2];
    }
  }

  *unint64_t v4 = 0LL;
  unint64_t v11 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = (void **)a1[2];
      double v2 = (void **)(a1[1] + 8LL);
      a1[1] = v2;
      unint64_t v11 = (char *)v3 - (char *)v2;
    }

    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }

  unint64_t v12 = v11 >> 3;
  if (v12 == 1)
  {
    uint64_t v13 = 36LL;
  }

  else
  {
    if (v12 != 2) {
      goto LABEL_17;
    }
    uint64_t v13 = 73LL;
  }

  a1[4] = v13;
LABEL_17:
  while (v2 != v3)
  {
    float32x2_t v14 = *v2++;
    operator delete(v14);
  }

  return sub_100030AF0((uint64_t)a1);
}

uint64_t sub_10030B1FC(uint64_t a1)
{
  double v2 = (_BYTE *)(a1 + 5072);
  *(void *)a1 = off_1007BD5B0;
  sub_100030A5C((void *)(a1 + 9312));
  sub_10030ADF4((void *)(a1 + 8880));
  sub_10030B37C((void *)(a1 + 8096));
  sub_10030B37C((void *)(a1 + 8048));
  if (v2[2736])
  {
    uint64_t v3 = *(void **)(a1 + 7776);
    if (v3)
    {
      *(void *)(a1 + 7784) = v3;
      operator delete(v3);
    }
  }

  sub_100030A5C((void *)(a1 + 7632));
  sub_10030AE88((void *)(a1 + 7200));
  sub_100030A5C((void *)(a1 + 6928));
  sub_100030A5C((void *)(a1 + 6880));
  sub_100030A5C((void *)(a1 + 6256));
  sub_100030A5C((void *)(a1 + 6208));
  sub_100304B2C((void *)(a1 + 5944));
  sub_100030A5C((void *)(a1 + 5872));
  sub_10030AF1C((void *)(a1 + 5824));
  if (v2[552])
  {
    unint64_t v4 = *(void **)(a1 + 5592);
    if (v4)
    {
      *(void *)(a1 + 5600) = v4;
      operator delete(v4);
    }
  }

  unint64_t v5 = *(char **)(a1 + 5568);
  *(void *)(a1 + 556_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  if (v5) {
    sub_10030AFB0(a1 + 5568, v5);
  }
  double v9 = (void **)(a1 + 5472);
  sub_1002AF8FC(&v9);
  sub_100030A5C((void *)(a1 + 5400));
  uint64_t v6 = *(void **)(a1 + 5080);
  *(void *)(a1 + 5080) = 0LL;
  if (v6) {
    operator delete(v6);
  }
  if (*v2)
  {
    unint64_t v7 = *(void **)(a1 + 5040);
    if (v7)
    {
      *(void *)(a1 + 504_Block_object_dispose((const void *)(v1 - 112), 8) = v7;
      operator delete(v7);
    }
  }

  sub_1002AF988((uint64_t *)(a1 + 5016), 0LL);
  sub_10030B03C(a1 + 448);
  return a1;
}

uint64_t sub_10030B37C(void *a1)
{
  double v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  a1[5] = 0LL;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = (void **)a1[2];
      double v2 = (void **)(a1[1] + 8LL);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }

    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }

  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 11LL;
  }

  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 22LL;
  }

  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    unint64_t v7 = *v2++;
    operator delete(v7);
  }

  return sub_100030AF0((uint64_t)a1);
}

void sub_10030B410(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x16;
  unint64_t v4 = v2 - 22;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    BOOL v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    double v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)BOOL v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      double v34 = (char *)sub_1000472C0(v5, v33);
      double v35 = &v34[8 * (v33 >> 2)];
      double v37 = &v34[8 * v36];
      double v38 = (uint64_t *)a1[1];
      BOOL v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        BOOL v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        double v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)double v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_10030B6D8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10030B724(uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0x16) {
    a2 = 1;
  }
  if (v2 < 0x2C) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8LL;
    *(void *)(a1 + 32) -= 22LL;
  }

  return v4 ^ 1u;
}

uint64_t sub_10030B780(void *a1, int a2)
{
  uint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  if (v2 == v3) {
    uint64_t v4 = 0LL;
  }
  else {
    uint64_t v4 = 22 * ((v2 - v3) >> 3) - 1;
  }
  unint64_t v5 = v4 - (a1[5] + a1[4]);
  if (v5 < 0x16) {
    a2 = 1;
  }
  if (v5 < 0x2C) {
    int v7 = a2;
  }
  else {
    int v7 = 0;
  }
  if ((v7 & 1) == 0)
  {
    operator delete(*(void **)(v2 - 8));
    a1[2] -= 8LL;
  }

  return v7 ^ 1u;
}

void *sub_10030B7F4(void *result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = (void *)*result;
    unint64_t v3 = a2 - 0x2C8590B21642C859LL * ((uint64_t)(result[1] - *(void *)*result) >> 3);
    if ((uint64_t)v3 < 1)
    {
      unint64_t v5 = 21 - v3;
      uint64_t v6 = &v2[-(v5 / 0x16)];
      *uint64_t result = v6;
      unint64_t v4 = *v6 + 184 * (22 * (v5 / 0x16) - v5) + 3864;
    }

    else
    {
      *uint64_t result = &v2[v3 / 0x16];
      unint64_t v4 = v2[v3 / 0x16] + 184 * (v3 % 0x16);
    }

    result[1] = v4;
  }

  return result;
}

__n128 sub_10030B8A8@<Q0>( char **a1@<X1>, char *a2@<X2>, char **a3@<X3>, char *a4@<X4>, void *a5@<X5>, char *a6@<X6>, __n128 *a7@<X8>)
{
  if (a1 == a3)
  {
    simd_float2x2 v19 = a2;
    uint64_t v18 = a4;
    uint64_t v15 = a5;
    uint64_t v16 = a6;
  }

  else
  {
    uint64_t v13 = a3 - 1;
    uint64_t v12 = *a3;
    BOOL v14 = a4;
    uint64_t v15 = a5;
    uint64_t v16 = a6;
    while (1)
    {
      sub_10030B974(v12, v14, v15, v16, &v21);
      uint64_t v16 = (char *)v22.n128_u64[1];
      uint64_t v15 = (void *)v22.n128_u64[0];
      if (v13 == a1) {
        break;
      }
      uint64_t v17 = *v13--;
      uint64_t v12 = v17;
      BOOL v14 = v17 + 4048;
    }

    uint64_t v18 = *a1 + 4048;
    simd_float2x2 v19 = a2;
  }

  sub_10030B974(v19, v18, v15, v16, &v21);
  __n128 result = v22;
  a7->n128_u64[0] = (unint64_t)a3;
  a7->n128_u64[1] = (unint64_t)a4;
  a7[1] = result;
  return result;
}

void *sub_10030B974@<X0>(char *a1@<X1>, char *a2@<X2>, void *a3@<X3>, char *a4@<X4>, void *a5@<X8>)
{
  uint64_t v6 = a3;
  if (a1 == a2)
  {
    double v9 = a1;
  }

  else
  {
    double v9 = a2;
    uint64_t v10 = *a3;
    uint64_t v11 = a2;
    while (1)
    {
      int64_t v12 = 0xD37A6F4DE9BD37A7LL * ((uint64_t)&a4[-v10] >> 3);
      v11 -= 184 * v12;
      a4 -= 184 * v12;
      if (v12) {
        __n128 result = memmove(a4, v11, 184 * v12);
      }
      if (v11 == a1) {
        break;
      }
      uint64_t v14 = *--v6;
      uint64_t v10 = v14;
      a4 = (char *)(v14 + 4048);
    }

    if ((char *)(*v6 + 4048LL) == a4)
    {
      uint64_t v15 = (char *)v6[1];
      ++v6;
      a4 = v15;
    }
  }

  *a5 = v9;
  a5[1] = v6;
  a5[2] = a4;
  return result;
}

double sub_10030BA54(void *a1, _BYTE *a2, _BYTE **a3, _BYTE *a4, uint64_t a5)
{
  int v7 = *(void ***)a5;
  BOOL v8 = *(char **)(a5 + 8);
  if (a1 != a3)
  {
    uint64_t v10 = a1 + 1;
    for (int i = (_BYTE *)(*a1 + 4048LL); ; int i = v12 + 4048)
    {
      sub_10030BAE4(a2, v8, i, v7, &v14);
      BOOL v8 = (char *)*((void *)&v15 + 1);
      int v7 = (void **)v15;
      *(void *)a5 = v15;
      *(void *)(a5 + _Block_object_dispose((const void *)(v1 - 112), 8) = v8;
      if (v10 == a3) {
        break;
      }
      int64_t v12 = (_BYTE *)*v10++;
      a2 = v12;
    }

    a2 = *a3;
  }

  sub_10030BAE4(a2, v8, a4, v7, &v14);
  double result = *(double *)&v15;
  *(_OWORD *)a5 = v15;
  return result;
}

void *sub_10030BAE4@<X0>( _BYTE *__src@<X1>, char *__dst@<X4>, _BYTE *a3@<X2>, void **a4@<X3>, void *a5@<X8>)
{
  uint64_t v6 = a4;
  int v7 = __src;
  if (__src == a3)
  {
    double v9 = __src;
  }

  else
  {
    double v9 = a3;
    uint64_t v6 = a4 + 1;
    uint64_t v10 = (char *)*a4;
    while (1)
    {
      int64_t v11 = 0xD37A6F4DE9BD37A7LL * ((v10 - __dst + 4048) >> 3);
      unint64_t v12 = (uint64_t)(0xD37A6F4DE9BD37A7LL * ((v9 - v7) >> 3)) >= v11 ? v11 : 0xD37A6F4DE9BD37A7LL * ((v9 - v7) >> 3);
      if (v12) {
        double result = memmove(__dst, v7, 184 * v12);
      }
      v7 += 184 * v12;
      if (v7 == v9) {
        break;
      }
      uint64_t v14 = (char *)*v6++;
      uint64_t v10 = v14;
      __int128 __dst = v14;
    }

    __dst += 184 * v12;
    else {
      --v6;
    }
  }

  *a5 = v9;
  a5[1] = v6;
  a5[2] = __dst;
  return result;
}

void sub_10030BBD0(void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
}

  ;
}

uint64_t sub_10030BBE4()
{
  qword_1007FF118 = 0LL;
  qword_1007FF120 = 0LL;
  qword_1007FF128 = 0LL;
  uint64_t v0 = operator new(0x40uLL);
  qword_1007FF120 = (uint64_t)(v0 + 4);
  qword_1007FF128 = (uint64_t)(v0 + 4);
  _OWORD *v0 = xmmword_100430390;
  v0[1] = unk_1004303A0;
  v0[2] = xmmword_1004303B0;
  v0[3] = unk_1004303C0;
  qword_1007FF118 = (uint64_t)v0;
  __cxa_atexit((void (*)(void *))sub_100028CC4, &qword_1007FF118, (void *)&_mh_execute_header);
  qword_1007FF138 = 0LL;
  unk_1007FF140 = 0LL;
  qword_1007FF130 = 0LL;
  int v1 = operator new(0x10uLL);
  qword_1007FF138 = (uint64_t)(v1 + 1);
  unk_1007FF140 = v1 + 1;
  _OWORD *v1 = xmmword_1004303D0;
  qword_1007FF130 = (uint64_t)v1;
  return __cxa_atexit((void (*)(void *))sub_100028CC4, &qword_1007FF130, (void *)&_mh_execute_header);
}

void sub_10030BCA0(uint64_t a1, double a2, double a3)
{
  double v8 = a2;
  sub_1002FE7B8((void *)(a1 + 40), &v8);
  double v5 = v8 + *(double *)(a1 + 16);
  *(double *)(a1 + 16) = v5;
  *(double *)(a1 + 24) = a3;
  *(_BYTE *)(a1 + 32) = 1;
  unint64_t v6 = *(void *)(a1 + 80);
  if (*(double *)a1 < (double)v6)
  {
    unint64_t v7 = *(void *)(a1 + 72);
    *(double *)(a1 + 16) = v5
    *(void *)(a1 + 72) = v7 + 1;
    *(void *)(a1 + 80) = v6 - 1;
    sub_100301000(a1 + 40, 1);
  }

void sub_10030BD70(uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 48);
  uint64_t v3 = *(void *)(a1 + 56);
  *(void *)(a1 + 80) = 0LL;
  unint64_t v4 = v3 - (void)v2;
  if (v4 >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v5 = *(void *)(a1 + 56);
      uint64_t v2 = (void **)(*(void *)(a1 + 48) + 8LL);
      *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v2;
      unint64_t v4 = v5 - (void)v2;
    }

    while (v4 > 0x10);
  }

  if (v4 >> 3 == 1)
  {
    uint64_t v6 = 256LL;
  }

  else
  {
    if (v4 >> 3 != 2) {
      goto LABEL_8;
    }
    uint64_t v6 = 512LL;
  }

  *(void *)(a1 + 72) = v6;
LABEL_8:
  *(void *)(a1 + 16) = 0LL;
  if (*(_BYTE *)(a1 + 32)) {
    *(_BYTE *)(a1 + 32) = 0;
  }
}

double sub_10030BDF4(uint64_t a1, char a2)
{
  unint64_t v2 = *(void *)(a1 + 80);
  double result = (double)v2;
  else {
    char v4 = a2;
  }
  if (v2)
  {
    if ((v4 & 1) == 0) {
      return *(double *)(a1 + 16) / result;
    }
  }

  return result;
}

uint64_t sub_10030BE44(uint64_t a1, uint64_t a2, __int128 **a3)
{
  *(void *)a1 = off_1007BD750;
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + 24) = 0LL;
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  sub_1002AF228((char *)(a1 + 8), *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * (a3[1] - *a3));
  *(_OWORD *)(a1 + 32) = *(_OWORD *)a2;
  __int128 v5 = *(_OWORD *)(a2 + 16);
  __int128 v6 = *(_OWORD *)(a2 + 32);
  __int128 v7 = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 96) = *(void *)(a2 + 64);
  *(_OWORD *)(a1 + 64) = v6;
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v5;
  *(void *)&__int128 v5 = *(void *)(a2 + 64);
  *(double *)(a1 + 104) = (double)*(int *)(a2 + 56);
  *(void *)(a1 + 112) = v5;
  *(void *)(a1 + 120) = 0LL;
  *(_BYTE *)(a1 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 136) = 0;
  *(_BYTE *)(a1 + 400) = 0;
  *(_BYTE *)(a1 + 40_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 592) = 0;
  *(_BYTE *)(a1 + 600) = 0;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 201) = 0u;
  double v8 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v10 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#handoffPredictor HandoffPredictor is created",  v10,  2u);
  }

  return a1;
}

void sub_10030BF48(uint64_t a1, __int128 *a2)
{
  if (!*(_BYTE *)(a1 + 592)) {
    goto LABEL_32;
  }
  if (!*(_BYTE *)(a1 + 600))
  {
    float v4 = *(float *)(a1 + 424);
    float v5 = *((float *)a2 + 4);
    if (*(double *)(a1 + 64) <= vabds_f32(v5, v4))
    {
      *(_BYTE *)(a1 + 600) = 1;
      *(void *)(a1 + 192) = 0x3FF0000000000000LL;
      __int128 v6 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        int v37 = 134218240;
        double v38 = v5;
        __int16 v39 = 2048;
        double v40 = v4;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#handoffPredictor distance measurements have changed enough - current distance is %f, first distance is %f",  (uint8_t *)&v37,  0x16u);
        if (!*(_BYTE *)(a1 + 592))
        {
LABEL_32:
          __int128 v7 = *a2;
          __int128 v8 = a2[1];
          __int128 v9 = a2[3];
          *(_OWORD *)(a1 + 440) = a2[2];
          *(_OWORD *)(a1 + 456) = v9;
          *(_OWORD *)(a1 + 40_Block_object_dispose((const void *)(v1 - 112), 8) = v7;
          *(_OWORD *)(a1 + 424) = v8;
          __int128 v10 = a2[4];
          __int128 v11 = a2[5];
          __int128 v12 = a2[7];
          *(_OWORD *)(a1 + 504) = a2[6];
          *(_OWORD *)(a1 + 520) = v12;
          *(_OWORD *)(a1 + 472) = v10;
          *(_OWORD *)(a1 + 48_Block_object_dispose((const void *)(v1 - 112), 8) = v11;
          __int128 v13 = a2[8];
          __int128 v14 = a2[9];
          __int128 v15 = a2[10];
          *(void *)(a1 + 584) = *((void *)a2 + 22);
          *(_OWORD *)(a1 + 552) = v14;
          *(_OWORD *)(a1 + 56_Block_object_dispose((const void *)(v1 - 112), 8) = v15;
          *(_OWORD *)(a1 + 536) = v13;
          *(_BYTE *)(a1 + 592) = 1;
          uint64_t v16 = (os_log_s *)qword_1008000A0;
          if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
          {
            double v17 = *(float *)(a1 + 424);
            int v37 = 134217984;
            double v38 = v17;
            _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "#handoffPredictor first distance measurement is %f",  (uint8_t *)&v37,  0xCu);
          }
        }
      }
    }
  }

  if (!*(_BYTE *)(a1 + 400)) {
    goto LABEL_23;
  }
  double v18 = *((double *)a2 + 1);
  float v19 = v18 - *(double *)(a1 + 224);
  if (v19 > 0.0)
  {
    if (*(double *)(a1 + 96) <= v19)
    {
      uint64_t v24 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v37) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "#handoffPredictor velocity measurements stale, clearing velocity buffer and velocity score",  (uint8_t *)&v37,  2u);
      }

      sub_10030BD70(a1 + 104);
    }

    else
    {
      sub_10030BCA0(a1 + 104, (float)((float)-(float)(*((float *)a2 + 4) - *(float *)(a1 + 232)) / v19), v18);
      sub_10030BDF4(a1 + 104, 0);
      if (v21)
      {
        double v22 = 0.0;
        goto LABEL_22;
      }
    }

    double v22 = 0.0;
LABEL_22:
    *(double *)(a1 + 20_Block_object_dispose((const void *)(v1 - 112), 8) = v22;
LABEL_23:
    if (*((_BYTE *)a2 + 36))
    {
      BOOL v25 = fabs(sub_100026A20(*((float *)a2 + 6))) > *(double *)(a1 + 72);
      double v26 = 0.0;
      if (!v25) {
        double v26 = 1.0;
      }
    }

    else
    {
      double v26 = 0.0;
    }

    *(double *)(a1 + 200) = v26;
    int v27 = *(unsigned __int8 *)(a1 + 400);
    __int128 v28 = a2[3];
    __int128 v30 = *a2;
    __int128 v29 = a2[1];
    *(_OWORD *)(a1 + 24_Block_object_dispose((const void *)(v1 - 112), 8) = a2[2];
    *(_OWORD *)(a1 + 264) = v28;
    *(_OWORD *)(a1 + 216) = v30;
    *(_OWORD *)(a1 + 232) = v29;
    __int128 v31 = a2[7];
    __int128 v33 = a2[4];
    __int128 v32 = a2[5];
    *(_OWORD *)(a1 + 312) = a2[6];
    *(_OWORD *)(a1 + 32_Block_object_dispose((const void *)(v1 - 112), 8) = v31;
    *(_OWORD *)(a1 + 280) = v33;
    *(_OWORD *)(a1 + 296) = v32;
    __int128 v35 = a2[9];
    __int128 v34 = a2[10];
    __int128 v36 = a2[8];
    *(void *)(a1 + 392) = *((void *)a2 + 22);
    *(_OWORD *)(a1 + 360) = v35;
    *(_OWORD *)(a1 + 376) = v34;
    *(_OWORD *)(a1 + 344) = v36;
    if (!v27) {
      *(_BYTE *)(a1 + 400) = 1;
    }
    return;
  }

  uint64_t v23 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_ERROR)) {
    sub_1003ABE30(v23);
  }
  sub_10030BD70(a1 + 104);
  *(void *)(a1 + 200) = 0LL;
  *(void *)(a1 + 20_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
}

void sub_10030C284()
{
  uint64_t v0 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v1 = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "#handoffPredictor region changed", v1, 2u);
  }

double sub_10030C2E8(uint64_t a1)
{
  unint64_t v2 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 192);
    uint64_t v4 = *(void *)(a1 + 200);
    uint64_t v5 = *(void *)(a1 + 208);
    int v7 = 134218496;
    uint64_t v8 = v3;
    __int16 v9 = 2048;
    uint64_t v10 = v4;
    __int16 v11 = 2048;
    uint64_t v12 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "#handoffPredictor _distanceChangeScore: %f, _directionScore: %f, _velocityScore: %f",  (uint8_t *)&v7,  0x20u);
  }

  return *(double *)(a1 + 48) * *(double *)(a1 + 200)
}

uint64_t sub_10030C3C0(uint64_t a1)
{
  *(void *)a1 = off_1007BD750;
  sub_1001302F0((void *)(a1 + 144));
  uint64_t v3 = (void **)(a1 + 8);
  sub_1002AE7B4(&v3);
  return a1;
}

void sub_10030C408(char *a1)
{
  *(void *)a1 = off_1007BD750;
  sub_1001302F0((void *)a1 + 18);
  unint64_t v2 = (void **)(a1 + 8);
  sub_1002AE7B4(&v2);
  operator delete(a1);
}

uint64_t sub_10030C454()
{
  v8[0] = xmmword_100430570;
  v8[1] = unk_100430580;
  sub_10015EABC((uint64_t)&unk_1007FF148, (int *)v8, 4LL);
  xmmword_1007FF160 = xmmword_100423CB0;
  *(_OWORD *)algn_1007FF170 = xmmword_100423CC0;
  qword_1007FF188 = 0LL;
  unk_1007FF190 = 0LL;
  qword_1007FF180 = 0x3FD999999999999ALL;
  unk_1007FF198 = xmmword_100423CD0;
  dword_1007FF1A8 = 5;
  qword_1007FF1B0 = 0x4000000000000000LL;
  dword_1007FF1B8 = 5;
  byte_1007FF1C0 = 0;
  *(void *)&algn_1007FF1C1[3] = 0x30000000ALL;
  xmmword_1007FF1D0 = xmmword_100423CE0;
  unk_1007FF1E0 = xmmword_100423CF0;
  xmmword_1007FF1F0 = xmmword_100423D00;
  qword_1007FF200 = 0x3FE3333333333333LL;
  dword_1007FF208 = 3;
  xmmword_1007FF210 = xmmword_100423D10;
  unk_1007FF220 = xmmword_100423CF0;
  xmmword_1007FF230 = xmmword_100423CE0;
  qword_1007FF240 = 0x3FE3333333333333LL;
  byte_1007FF248 = 0;
  xmmword_1007FF250 = xmmword_100423D20;
  unk_1007FF260 = xmmword_100423D30;
  __asm { FMOV            V0.2D, #1.0 }

  __int128 v6 = _Q0;
  xmmword_1007FF270 = _Q0;
  qword_1007FF280 = 0xBFD3333333333333LL;
  xmmword_1007FF288 = xmmword_100423D40;
  qword_1007FF298 = 0x3E99999A40000000LL;
  xmmword_1007FF2A0 = xmmword_100423CC0;
  qword_1007FF2B8 = 0LL;
  unk_1007FF2C0 = 0LL;
  qword_1007FF2B0 = 0x3FD999999999999ALL;
  xmmword_1007FF2C8 = xmmword_100423CD0;
  dword_1007FF2D8 = 5;
  qword_1007FF2E0 = 0x4000000000000000LL;
  dword_1007FF2E8 = 4;
  qword_1007FF2F0 = 0x300000008LL;
  qword_1007FF2F8 = 0xC04E800000000000LL;
  unint64_t v7 = 0xC04E800000000000LL;
  sub_10015ED64((uint64_t)&unk_1007FF300, (double *)&v7, 1LL);
  xmmword_1007FF318 = xmmword_100423D50;
  qword_1007FF328 = 0x4024000000000000LL;
  dword_1007FF330 = 45;
  byte_1007FF338 = 0;
  byte_1007FF350 = 0;
  qword_1007FF358 = 0LL;
  byte_1007FF360 = 0;
  dword_1007FF364 = 1;
  byte_1007FF368 = 1;
  xmmword_1007FF370 = xmmword_100423D60;
  unk_1007FF380 = xmmword_100423D70;
  xmmword_1007FF390 = v6;
  qword_1007FF3A0 = 0xC059000000000000LL;
  xmmword_1007FF3A8 = xmmword_100423D80;
  qword_1007FF3B8 = (uint64_t)vdup_n_s32(0x3DCCCCCDu);
  xmmword_1007FF3C0 = xmmword_100423CC0;
  qword_1007FF3D0 = 0x3FD999999999999ALL;
  qword_1007FF3E0 = 0LL;
  qword_1007FF3D8 = 0LL;
  xmmword_1007FF3E8 = xmmword_100423CD0;
  dword_1007FF3F8 = 5;
  qword_1007FF400 = 0x4000000000000000LL;
  dword_1007FF408 = 10;
  qword_1007FF410 = 0x4034000000000000LL;
  dword_1007FF418 = 3;
  xmmword_1007FF420 = xmmword_100423D90;
  return __cxa_atexit((void (*)(void *))sub_10015CF8C, &unk_1007FF148, (void *)&_mh_execute_header);
}

void sub_10030C6FC(_Unwind_Exception *a1)
{
}

uint64_t sub_10030C71C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 352);
}

double sub_10030C724(uint64_t a1)
{
  *(_BYTE *)(a1 + 160) = 0;
  *(_DWORD *)(a1 + 176) = 0;
  *(_BYTE *)(a1 + 180) = 0;
  *(_BYTE *)(a1 + 184) = 0;
  *(_BYTE *)(a1 + 344) = 0;
  *(_DWORD *)(a1 + 352) = 0;
  *(_OWORD *)(a1 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  *(_BYTE *)(a1 + 144) = 0;
  *(void *)(a1 + 360) = 0x3FB999999999999ALL;
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = xmmword_1004305D0;
  *(_OWORD *)(a1 + 32) = xmmword_10042DB60;
  return result;
}

void sub_10030C778(void *a1)
{
  unint64_t v2 = (void **)a1[7];
  uint64_t v3 = a1[8];
  a1[11] = 0LL;
  unint64_t v4 = v3 - (void)v2;
  if (v4 >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v5 = a1[8];
      unint64_t v2 = (void **)(a1[7] + 8LL);
      a1[7] = v2;
      unint64_t v4 = v5 - (void)v2;
    }

    while (v4 > 0x10);
  }

  if (v4 >> 3 == 1)
  {
    uint64_t v6 = 16LL;
  }

  else
  {
    if (v4 >> 3 != 2) {
      goto LABEL_8;
    }
    uint64_t v6 = 32LL;
  }

  a1[10] = v6;
LABEL_8:
  unint64_t v7 = (void **)a1[13];
  uint64_t v8 = a1[14];
  a1[17] = 0LL;
  unint64_t v9 = v8 - (void)v7;
  if (v9 >= 0x11)
  {
    do
    {
      operator delete(*v7);
      uint64_t v10 = a1[14];
      unint64_t v7 = (void **)(a1[13] + 8LL);
      a1[13] = v7;
      unint64_t v9 = v10 - (void)v7;
    }

    while (v9 > 0x10);
  }

  if (v9 >> 3 == 1)
  {
    uint64_t v11 = 16LL;
  }

  else
  {
    if (v9 >> 3 != 2) {
      return;
    }
    uint64_t v11 = 32LL;
  }

  a1[16] = v11;
}

__n128 sub_10030C844@<Q0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  *(_BYTE *)a2 = 0;
  *(_BYTE *)(a2 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  if (a1[11])
  {
    uint64_t v2 = *(void *)(a1[7] + ((a1[10] >> 2) & 0x3FFFFFFFFFFFFFF8LL)) + ((a1[10] & 0x1FLL) << 7);
    __int128 v3 = *(_OWORD *)(v2 + 80);
    *(_OWORD *)(a2 + 64) = *(_OWORD *)(v2 + 64);
    *(_OWORD *)(a2 + 80) = v3;
    __int128 v4 = *(_OWORD *)(v2 + 112);
    *(_OWORD *)(a2 + 96) = *(_OWORD *)(v2 + 96);
    *(_OWORD *)(a2 + 112) = v4;
    __int128 v5 = *(_OWORD *)(v2 + 16);
    *(_OWORD *)a2 = *(_OWORD *)v2;
    *(_OWORD *)(a2 + 16) = v5;
    __n128 result = *(__n128 *)(v2 + 32);
    __int128 v7 = *(_OWORD *)(v2 + 48);
    *(__n128 *)(a2 + 32) = result;
    *(_OWORD *)(a2 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v7;
    *(_BYTE *)(a2 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
  }

  return result;
}

void sub_10030C89C(int64x2_t *a1, __int128 *a2)
{
  uint64_t v4 = a1->i64[1];
  if (a1[1].i64[0] != v4)
  {
    unint64_t v5 = a1[2].u64[0];
    uint64_t v6 = (void *)(v4 + 8 * (v5 >> 5));
    __int128 v7 = (double *)(*v6 + ((v5 & 0x1F) << 7));
    uint64_t v8 = *(void *)(v4 + (((a1[2].i64[1] + v5) >> 2) & 0x3FFFFFFFFFFFFFF8LL)) + (((a1[2].i64[1] + v5) & 0x1F) << 7);
    while (v7 != (double *)v8)
    {
      a1[2] = vaddq_s64(a1[2], (int64x2_t)xmmword_100422120);
      sub_100125ADC((uint64_t)a1, 1);
      v7 += 16;
      if ((double *)((char *)v7 - *v6) == (double *)4096)
      {
        unint64_t v9 = (double *)v6[1];
        ++v6;
        __int128 v7 = v9;
      }
    }
  }

__n128 sub_10030C984@<Q0>(void *a1@<X0>, uint64_t a2@<X8>, __n128 result@<Q0>)
{
  *(_BYTE *)a2 = 0;
  *(_BYTE *)(a2 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  uint64_t v3 = a1[1];
  if (a1[2] != v3)
  {
    unint64_t v4 = a1[4];
    unint64_t v5 = (void *)(v3 + 8 * (v4 >> 5));
    unint64_t v6 = *v5 + ((v4 & 0x1F) << 7);
    uint64_t v7 = *(void *)(v3 + (((a1[5] + v4) >> 2) & 0x3FFFFFFFFFFFFFF8LL)) + (((a1[5] + v4) & 0x1F) << 7);
    while (v6 != v7)
    {
      double v8 = *(double *)v6;
      uint64_t v17 = *(void *)(v6 + 120);
      __int128 v15 = *(_OWORD *)(v6 + 88);
      __int128 v16 = *(_OWORD *)(v6 + 104);
      __int128 v14 = *(_OWORD *)(v6 + 72);
      __n128 v12 = *(__n128 *)(v6 + 40);
      __int128 v13 = *(_OWORD *)(v6 + 56);
      __int128 v10 = *(_OWORD *)(v6 + 8);
      __int128 v11 = *(_OWORD *)(v6 + 24);
      if (*(double *)v6 > result.n128_f64[0])
      {
        result.n128_f64[0] = v8 - result.n128_f64[0];
        if (result.n128_f64[0] < 0.2)
        {
          *(double *)a2 = v8;
          *(_OWORD *)(a2 + 72) = v14;
          *(_OWORD *)(a2 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = v15;
          *(_OWORD *)(a2 + 104) = v16;
          *(_OWORD *)(a2 + _Block_object_dispose((const void *)(v1 - 112), 8) = v10;
          *(_OWORD *)(a2 + 24) = v11;
          __n128 result = v12;
          *(__n128 *)(a2 + 40) = v12;
          *(void *)(a2 + 120) = v17;
          *(_OWORD *)(a2 + 56) = v13;
          *(_BYTE *)(a2 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
        }

        return result;
      }

      v6 += 128LL;
      if (v6 - *v5 == 4096)
      {
        unint64_t v9 = v5[1];
        ++v5;
        unint64_t v6 = v9;
      }
    }
  }

  return result;
}

__n128 sub_10030CAC4@<Q0>(void *a1@<X0>, uint64_t a2@<X8>, __n128 result@<Q0>)
{
  *(_BYTE *)a2 = 0;
  *(_BYTE *)(a2 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  if (a1[17])
  {
    uint64_t v3 = *(void *)(a1[13] + ((a1[16] >> 2) & 0x3FFFFFFFFFFFFFF8LL)) + ((a1[16] & 0x1FLL) << 7);
    result.n128_f64[0] = *(double *)v3 - result.n128_f64[0];
    if (result.n128_f64[0] < 0.2)
    {
      __int128 v4 = *(_OWORD *)(v3 + 80);
      *(_OWORD *)(a2 + 64) = *(_OWORD *)(v3 + 64);
      *(_OWORD *)(a2 + 80) = v4;
      __int128 v5 = *(_OWORD *)(v3 + 112);
      *(_OWORD *)(a2 + 96) = *(_OWORD *)(v3 + 96);
      *(_OWORD *)(a2 + 112) = v5;
      __int128 v6 = *(_OWORD *)(v3 + 16);
      *(_OWORD *)a2 = *(_OWORD *)v3;
      *(_OWORD *)(a2 + 16) = v6;
      __n128 result = *(__n128 *)(v3 + 32);
      __int128 v7 = *(_OWORD *)(v3 + 48);
      *(__n128 *)(a2 + 32) = result;
      *(_OWORD *)(a2 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v7;
      *(_BYTE *)(a2 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = 1;
    }
  }

  return result;
}

void sub_10030CB34(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  uint64_t v8 = *(void *)(a1 + 88);
  if (v8)
  {
    while (1)
    {
      unint64_t v9 = *(void *)(a1 + 80);
      uint64_t v10 = *(void *)(*(void *)(a1 + 56) + ((v9 >> 2) & 0x3FFFFFFFFFFFFFF8LL));
      double v11 = *(double *)(v10 + ((v9 & 0x1F) << 7));
      if (v11 >= a4) {
        break;
      }
      *(void *)(a1 + 80) = v9 + 1;
      *(void *)(a1 + 8_Block_object_dispose((const void *)(v1 - 112), 8) = v8 - 1;
      sub_100125ADC(a1 + 48, 1);
      uint64_t v8 = *(void *)(a1 + 88);
      if (!v8) {
        goto LABEL_4;
      }
    }

    v64[0].i8[0] = 0;
    char v65 = 0;
    char v12 = 1;
    if (v11 - a4 < 0.1)
    {
      __int128 v15 = (float32x4_t *)(v10 + ((v9 & 0x1F) << 7));
      float32x4_t v16 = v15[5];
      v64[4] = v15[4];
      v64[5] = v16;
      float32x4_t v17 = v15[7];
      v64[6] = v15[6];
      v64[7] = v17;
      float32x4_t v18 = v15[1];
      v64[0] = *v15;
      v64[1] = v18;
      float32x4_t v19 = v15[3];
      v64[2] = v15[2];
      v64[3] = v19;
      char v65 = 1;
      char v12 = 0;
    }
  }

  else
  {
LABEL_4:
    v64[0].i8[0] = 0;
    char v65 = 0;
    char v12 = 1;
  }

  if (*(_BYTE *)(a2 + 32)) {
    BOOL v13 = *(_BYTE *)(a2 + 48) == 0;
  }
  else {
    BOOL v13 = 1;
  }
  BOOL v14 = !v13 && *(_BYTE *)(a2 + 64) != 0;
  switch(*(_DWORD *)(a1 + 352))
  {
    case 0:
      if (!v14) {
        goto LABEL_30;
      }
      *(_OWORD *)(a1 + 16) = xmmword_1004305D0;
LABEL_24:
      int v20 = 4;
      goto LABEL_29;
    case 1:
      if (v14) {
        goto LABEL_24;
      }
      goto LABEL_30;
    case 2:
      if ((v12 & 1) != 0) {
        goto LABEL_30;
      }
      if (!*(_BYTE *)(a1 + 344)) {
        goto LABEL_42;
      }
      sub_10030CF30(a1, v64, a1 + 184);
      if (v14) {
        int v20 = 5;
      }
      else {
        int v20 = 3;
      }
LABEL_29:
      *(_DWORD *)(a1 + 352) = v20;
LABEL_30:
      if (!*(_BYTE *)(a2 + 80)) {
        goto LABEL_42;
      }
      if (!*(_BYTE *)(a2 + 96)) {
        goto LABEL_42;
      }
      if (!*(_BYTE *)(a2 + 112)) {
        goto LABEL_42;
      }
      float v21 = *(double *)(a2 + 72);
      float v22 = *(double *)(a2 + 88);
      float v23 = *(double *)(a2 + 104);
      float32x4_t v24 = *(float32x4_t *)(a1 + 16);
      float32x4_t v25 = vmulq_f32(v24, (float32x4_t)xmmword_10042DD20);
      int32x4_t v26 = (int32x4_t)vnegq_f32(v25);
      int8x16_t v27 = (int8x16_t)vtrn2q_s32((int32x4_t)v25, vtrn1q_s32((int32x4_t)v25, v26));
      float32x4_t v28 = (float32x4_t)vextq_s8(v27, v27, 8uLL);
      float32x4_t v29 = (float32x4_t)vextq_s8((int8x16_t)v25, (int8x16_t)v26, 8uLL);
      float32x4_t v30 = vmulq_n_f32(v29, v22);
      float32x4_t v31 = (float32x4_t)vrev64q_s32((int32x4_t)v25);
      v31.i32[0] = v26.i32[1];
      v31.i32[3] = v26.i32[2];
      float32x4_t v32 = vmlaq_n_f32(vmlaq_n_f32(v30, v28, v21), v31, v23);
      int32x4_t v33 = (int32x4_t)vnegq_f32(v32);
      int8x16_t v34 = (int8x16_t)vtrn2q_s32((int32x4_t)v32, vtrn1q_s32((int32x4_t)v32, v33));
      float32x4_t v35 = vmlaq_n_f32( vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)v32, (int8x16_t)v33, 8uLL), *(float32x2_t *)v24.f32, 1),  (float32x4_t)vextq_s8(v34, v34, 8uLL),  v24.f32[0]);
      float32x4_t v36 = (float32x4_t)vrev64q_s32((int32x4_t)v32);
      v36.i32[0] = v33.i32[1];
      v36.i32[3] = v33.i32[2];
      *(_BYTE *)a3 = 0;
      *(_BYTE *)(a3 + 16) = 0;
      *(double *)(a3 + 64) = a4;
      *(float32x4_t *)(a3 + 32) = vaddq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v32, v24, 3), v36, v24, 2), v35);
      if (!*(_BYTE *)(a2 + 152)) {
        goto LABEL_42;
      }
      float32x4_t v37 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 0);
      float32x4_t v38 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v24, 2);
      float v39 = *(double *)(a2 + 128);
      float v40 = *(double *)(a2 + 136);
      float v41 = *(double *)(a2 + 144);
      float v42 = *(double *)(a2 + 120);
      float32x4_t v43 = vaddq_f32( vmlaq_n_f32(vmulq_n_f32((float32x4_t)xmmword_1004305E0, v40), (float32x4_t)xmmword_1004305F0, v39),  vmlaq_n_f32(vmulq_n_f32((float32x4_t)xmmword_100430600, v42), (float32x4_t)xmmword_100430610, v41));
      int32x4_t v44 = (int32x4_t)vnegq_f32(v43);
      int8x16_t v45 = (int8x16_t)vtrn2q_s32((int32x4_t)v43, vtrn1q_s32((int32x4_t)v43, v44));
      float32x4_t v46 = vmlaq_f32( vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)v43, (int8x16_t)v44, 8uLL), *(float32x2_t *)v24.f32, 1),  (float32x4_t)vextq_s8(v45, v45, 8uLL),  v37);
      float32x4_t v47 = (float32x4_t)vrev64q_s32((int32x4_t)v43);
      v47.i32[0] = v44.i32[1];
      v47.i32[3] = v44.i32[2];
      *(float32x4_t *)(a3 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = vaddq_f32(vmlaq_f32(vmulq_laneq_f32(v43, v24, 3), v47, v38), v46);
      int v48 = *(unsigned __int8 *)(a1 + 344);
      __int128 v49 = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(a1 + 184) = *(_OWORD *)a2;
      *(_OWORD *)(a1 + 200) = v49;
      __int128 v50 = *(_OWORD *)(a2 + 64);
      __int128 v51 = *(_OWORD *)(a2 + 80);
      __int128 v52 = *(_OWORD *)(a2 + 48);
      *(_OWORD *)(a1 + 216) = *(_OWORD *)(a2 + 32);
      *(_OWORD *)(a1 + 264) = v51;
      *(_OWORD *)(a1 + 24_Block_object_dispose((const void *)(v1 - 112), 8) = v50;
      *(_OWORD *)(a1 + 232) = v52;
      __int128 v53 = *(_OWORD *)(a2 + 144);
      __int128 v55 = *(_OWORD *)(a2 + 96);
      __int128 v54 = *(_OWORD *)(a2 + 112);
      *(_OWORD *)(a1 + 312) = *(_OWORD *)(a2 + 128);
      *(_OWORD *)(a1 + 32_Block_object_dispose((const void *)(v1 - 112), 8) = v53;
      *(_OWORD *)(a1 + 280) = v55;
      *(_OWORD *)(a1 + 296) = v54;
      if (!v48) {
        *(_BYTE *)(a1 + 344) = 1;
      }
      *(double *)(a1 + 192) = a4;
      *(_BYTE *)(a1 + 200) = 1;
      if (v14)
      {
        if (!*(_BYTE *)(a2 + 32) || !*(_BYTE *)(a2 + 48) || !*(_BYTE *)(a2 + 64)) {
LABEL_42:
        }
          sub_100006080();
        float v56 = *(double *)(a2 + 24);
        float v57 = *(double *)(a2 + 40);
        float v58 = *(double *)(a2 + 56);
        float32x4_t v59 = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v29, v57), v28, v56), v31, v58);
        int32x4_t v60 = (int32x4_t)vnegq_f32(v59);
        int8x16_t v61 = (int8x16_t)vtrn2q_s32((int32x4_t)v59, vtrn1q_s32((int32x4_t)v59, v60));
        float32x4_t v62 = vmlaq_f32( vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)v59, (int8x16_t)v60, 8uLL), *(float32x2_t *)v24.f32, 1),  (float32x4_t)vextq_s8(v61, v61, 8uLL),  v37);
        float32x4_t v63 = (float32x4_t)vrev64q_s32((int32x4_t)v59);
        v63.i32[0] = v60.i32[1];
        v63.i32[3] = v60.i32[2];
        *(_BYTE *)(a3 + 16) = 1;
        *(float32x4_t *)a3 = vaddq_f32(vmlaq_f32(vmulq_laneq_f32(v59, v24, 3), v63, v38), v62);
      }

      return;
    case 3:
      if (!v14) {
        goto LABEL_30;
      }
      int v20 = 5;
      goto LABEL_29;
    case 4:
      if (v14) {
        goto LABEL_30;
      }
      int v20 = 1;
      goto LABEL_29;
    case 5:
      if (v14) {
        goto LABEL_30;
      }
      int v20 = 3;
      goto LABEL_29;
    default:
      goto LABEL_30;
  }

void sub_10030CF30(uint64_t a1, float32x4_t *a2, uint64_t a3)
{
  float32x4_t v18 = a2[1];
  float32x4_t v19 = a2[2];
  float32x4_t v16 = a2[4];
  float32x4_t v17 = a2[3];
  *(double *)&__int128 v5 = sub_1002CE658((float32x4_t)xmmword_100430670);
  uint64_t v6 = 0LL;
  v20[0] = v5;
  v20[1] = v7;
  _DWORD v20[2] = v8;
  _OWORD v20[3] = v9;
  do
  {
    v21[v6] = (int8x16_t)vmlaq_laneq_f32( vmlaq_laneq_f32( vmlaq_lane_f32(vmulq_n_f32(v18, COERCE_FLOAT(v20[v6])), v19, *(float32x2_t *)&v20[v6], 1),  v17,  (float32x4_t)v20[v6],  2),  v16,  (float32x4_t)v20[v6],  3);
    ++v6;
  }

  while (v6 != 4);
  *(double *)v10.i64 = sub_1002C94C0(v21[0], v21[1], (__n128)v21[2], *(double *)&v22, *(double *)v17.i64);
  int32x4_t v11 = (int32x4_t)vnegq_f32(v10);
  int8x16_t v12 = (int8x16_t)vtrn2q_s32((int32x4_t)v10, vtrn1q_s32((int32x4_t)v10, v11));
  float32x4_t v13 = (float32x4_t)vrev64q_s32((int32x4_t)v10);
  v13.i32[0] = v11.i32[1];
  v13.i32[3] = v11.i32[2];
  *(double *)&__int128 v15 = sub_10030D03C( vaddq_f32( vmlaq_n_f32( vmulq_lane_f32( (float32x4_t)vextq_s8((int8x16_t)v10, (int8x16_t)v11, 8uLL),  *(float32x2_t *)(a1 + 32),  1),  (float32x4_t)vextq_s8(v12, v12, 8uLL),  COERCE_FLOAT(*(_OWORD *)(a1 + 32))),  vmlaq_laneq_f32( vmulq_laneq_f32(v10, *(float32x4_t *)(a1 + 32), 3),  v13,  *(float32x4_t *)(a1 + 32),  2)),  v14,  a3);
  *(_OWORD *)(a1 + 16) = v15;
}

double sub_10030D00C(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 152)) {
    sub_100006080();
  }
  int8x16_t v1 = (int8x16_t)vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(a1 + 120)), *(float64x2_t *)(a1 + 136));
  *(void *)&double result = vextq_s8(v1, v1, 4uLL).u64[0];
  return result;
}

double sub_10030D03C(float32x4_t a1, uint64_t a2, uint64_t a3)
{
  if (!*(_BYTE *)(a3 + 152)) {
    sub_100006080();
  }
  int8x16_t v3 = (int8x16_t)vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(a3 + 120)), *(float64x2_t *)(a3 + 136));
  float32x4_t v4 = (float32x4_t)vextq_s8(v3, v3, 4uLL);
  int32x4_t v5 = (int32x4_t)vnegq_f32(v4);
  int8x16_t v6 = (int8x16_t)vtrn2q_s32((int32x4_t)v4, vtrn1q_s32((int32x4_t)v4, v5));
  v7.i64[0] = 0x8000000080000000LL;
  v7.i64[1] = 0x8000000080000000LL;
  float32x4_t v8 = (float32x4_t)vrev64q_s32((int32x4_t)v4);
  v8.i32[0] = v5.i32[1];
  v8.i32[3] = v5.i32[2];
  float32x4_t v9 = vaddq_f32( vmlaq_f32(vmulq_f32(v4, (float32x4_t)vdupq_n_s32(0x3F3504F3u)), v7, v8),  vmlaq_f32( vmulq_f32((float32x4_t)vextq_s8((int8x16_t)v4, (int8x16_t)v5, 8uLL), v7),  (float32x4_t)vdupq_n_s32(0xBF3504F3),  (float32x4_t)vextq_s8(v6, v6, 8uLL)));
  float32x4_t v10 = vmulq_f32(v9, (float32x4_t)xmmword_10042DD20);
  int8x16_t v11 = (int8x16_t)vmulq_f32(v9, v9);
  *(float32x2_t *)v11.i8 = vadd_f32(*(float32x2_t *)v11.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v11, v11, 8uLL));
  *(float32x2_t *)v11.i8 = vadd_f32(*(float32x2_t *)v11.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v11.i8, 1));
  *(float32x2_t *)v6.i8 = vrecpe_f32(*(float32x2_t *)v11.i8);
  *(float32x2_t *)v6.i8 = vmul_f32(*(float32x2_t *)v6.i8, vrecps_f32(*(float32x2_t *)v11.i8, *(float32x2_t *)v6.i8));
  float32x4_t v12 = vmulq_n_f32( v10,  vmul_f32(*(float32x2_t *)v6.i8, vrecps_f32(*(float32x2_t *)v11.i8, *(float32x2_t *)v6.i8)).f32[0]);
  int32x4_t v13 = (int32x4_t)vnegq_f32(v12);
  int8x16_t v14 = (int8x16_t)vtrn2q_s32((int32x4_t)v12, vtrn1q_s32((int32x4_t)v12, v13));
  float32x4_t v15 = vmlaq_n_f32( vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)v12, (int8x16_t)v13, 8uLL), *(float32x2_t *)a1.f32, 1),  (float32x4_t)vextq_s8(v14, v14, 8uLL),  a1.f32[0]);
  float32x4_t v16 = (float32x4_t)vrev64q_s32((int32x4_t)v12);
  v16.i32[0] = v13.i32[1];
  v16.i32[3] = v13.i32[2];
  float32x4_t v17 = vaddq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v12, a1, 3), v16, a1, 2), v15);
  float32x4_t v18 = vmulq_f32(v17, v17);
  v18.i64[0] = vaddq_f32( (float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 2),  vaddq_f32(v18, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v18.f32, 1))).u64[0];
  *(float32x2_t *)v13.i8 = vrsqrte_f32(*(float32x2_t *)v18.f32);
  *(float32x2_t *)v13.i8 = vmul_f32( *(float32x2_t *)v13.i8,  vrsqrts_f32( *(float32x2_t *)v18.f32,  vmul_f32(*(float32x2_t *)v13.i8, *(float32x2_t *)v13.i8)));
  float32x4_t v19 = vmulq_f32( vmulq_n_f32( v17,  vmul_f32( *(float32x2_t *)v13.i8,  vrsqrts_f32(*(float32x2_t *)v18.f32, vmul_f32(*(float32x2_t *)v13.i8, *(float32x2_t *)v13.i8))).f32[0]),  (float32x4_t)xmmword_10040CBE0);
  float32x4_t v30 = vmulq_n_f32( (float32x4_t)xmmword_10040CBE0,  vaddq_f32( (float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 2),  vaddq_f32(v19, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v19.f32, 1))).f32[0]);
  float v20 = atan2f(sqrtf(v18.f32[0]), v17.f32[3]);
  __float2 v21 = __sincosf_stret((float)(v20 + v20) * 0.5);
  float32x4_t v22 = vmulq_n_f32(v30, v21.__sinval);
  v22.i32[3] = LODWORD(v21.__cosval);
  int8x16_t v23 = (int8x16_t)vmulq_f32(v22, v22);
  float32x2_t v24 = vadd_f32(*(float32x2_t *)v23.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v23, v23, 8uLL));
  if (vaddv_f32(v24) == 0.0)
  {
    float32x4_t v25 = (float32x4_t)xmmword_10042DB60;
  }

  else
  {
    float32x2_t v26 = vadd_f32(v24, (float32x2_t)vdup_lane_s32((int32x2_t)v24, 1));
    float32x2_t v27 = vrsqrte_f32(v26);
    float32x2_t v28 = vmul_f32(v27, vrsqrts_f32(v26, vmul_f32(v27, v27)));
    float32x4_t v25 = vmulq_n_f32(v22, vmul_f32(v28, vrsqrts_f32(v26, vmul_f32(v28, v28))).f32[0]);
  }

  *(void *)&double result = vaddq_f32( vmlaq_n_f32( vmulq_lane_f32((float32x4_t)xmmword_100430620, *(float32x2_t *)v25.f32, 1),  (float32x4_t)xmmword_100430630,  v25.f32[0]),  vmlaq_laneq_f32( vmulq_laneq_f32((float32x4_t)xmmword_1004305D0, v25, 3),  (float32x4_t)xmmword_100430640,  v25,  2)).u64[0];
  return result;
}

BOOL sub_10030D230(float32x4_t *a1, float32x4_t *a2, float32x4_t a3)
{
  __int32 v3 = a2[5].i32[0];
  if (v3 == 2)
  {
    float32x4_t v35 = a2[1];
    float32x4_t v36 = a2[2];
    float32x4_t v33 = a2[4];
    float32x4_t v34 = a2[3];
    *(double *)&__int128 v5 = sub_1002CE658((float32x4_t)xmmword_100430670);
    uint64_t v6 = 0LL;
    v39[0] = v5;
    v39[1] = v7;
    v39[2] = v8;
    v39[3] = v9;
    do
    {
      v40[v6] = (int8x16_t)vmlaq_laneq_f32( vmlaq_laneq_f32( vmlaq_lane_f32(vmulq_n_f32(v35, COERCE_FLOAT(v39[v6])), v36, *(float32x2_t *)&v39[v6], 1),  v34,  (float32x4_t)v39[v6],  2),  v33,  (float32x4_t)v39[v6],  3);
      ++v6;
    }

    while (v6 != 4);
    *(double *)v10.i64 = sub_1002C94C0(v40[0], v40[1], (__n128)v40[2], *(double *)&v41, *(double *)v34.i64);
    float32x4_t v11 = vmulq_f32(v10, (float32x4_t)xmmword_10042DD20);
    int8x16_t v12 = (int8x16_t)vmulq_f32(v10, v10);
    *(float32x2_t *)v12.i8 = vadd_f32(*(float32x2_t *)v12.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v12, v12, 8uLL));
    *(float32x2_t *)v12.i8 = vadd_f32(*(float32x2_t *)v12.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v12.i8, 1));
    float32x2_t v13 = vrecpe_f32(*(float32x2_t *)v12.i8);
    float32x2_t v14 = vmul_f32(v13, vrecps_f32(*(float32x2_t *)v12.i8, v13));
    float32x4_t v15 = vmulq_n_f32(v11, vmul_f32(v14, vrecps_f32(*(float32x2_t *)v12.i8, v14)).f32[0]);
    int32x4_t v16 = (int32x4_t)vnegq_f32(v15);
    int8x16_t v17 = (int8x16_t)vtrn2q_s32((int32x4_t)v15, vtrn1q_s32((int32x4_t)v15, v16));
    float32x4_t v18 = vmlaq_n_f32( vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)v15, (int8x16_t)v16, 8uLL), *(float32x2_t *)a3.f32, 1),  (float32x4_t)vextq_s8(v17, v17, 8uLL),  a3.f32[0]);
    float32x4_t v19 = (float32x4_t)vrev64q_s32((int32x4_t)v15);
    v19.i32[0] = v16.i32[1];
    v19.i32[3] = v16.i32[2];
    float32x4_t v20 = vaddq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(v15, a3, 3), v19, a3, 2), v18);
    float32x4_t v21 = vmulq_f32(v20, v20);
    v21.i64[0] = vaddq_f32( (float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 2),  vaddq_f32(v21, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 1))).u64[0];
    *(float32x2_t *)v19.f32 = vrsqrte_f32(*(float32x2_t *)v21.f32);
    *(float32x2_t *)v19.f32 = vmul_f32( *(float32x2_t *)v19.f32,  vrsqrts_f32( *(float32x2_t *)v21.f32,  vmul_f32(*(float32x2_t *)v19.f32, *(float32x2_t *)v19.f32)));
    float32x4_t v22 = vmulq_f32( vmulq_n_f32( v20,  vmul_f32( *(float32x2_t *)v19.f32,  vrsqrts_f32(*(float32x2_t *)v21.f32, vmul_f32(*(float32x2_t *)v19.f32, *(float32x2_t *)v19.f32))).f32[0]),  (float32x4_t)xmmword_10040CBE0);
    float32x4_t v38 = vmulq_n_f32( (float32x4_t)xmmword_10040CBE0,  vaddq_f32( (float32x4_t)vdupq_laneq_s32((int32x4_t)v22, 2),  vaddq_f32(v22, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v22.f32, 1))).f32[0]);
    float v23 = atan2f(sqrtf(v21.f32[0]), v20.f32[3]);
    __float2 v24 = __sincosf_stret((float)(v23 + v23) * 0.5);
    float32x4_t v25 = vmulq_n_f32(v38, v24.__sinval);
    v25.i32[3] = LODWORD(v24.__cosval);
    int8x16_t v26 = (int8x16_t)vmulq_f32(v25, v25);
    float32x2_t v27 = vadd_f32(*(float32x2_t *)v26.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL));
    if (vaddv_f32(v27) == 0.0)
    {
      float32x4_t v28 = (float32x4_t)xmmword_10042DB60;
    }

    else
    {
      float32x2_t v29 = vadd_f32(v27, (float32x2_t)vdup_lane_s32((int32x2_t)v27, 1));
      float32x2_t v30 = vrsqrte_f32(v29);
      float32x2_t v31 = vmul_f32(v30, vrsqrts_f32(v29, vmul_f32(v30, v30)));
      float32x4_t v28 = vmulq_n_f32(v25, vmul_f32(v31, vrsqrts_f32(v29, vmul_f32(v31, v31))).f32[0]);
    }

    a1[2] = v28;
  }

  return v3 == 2;
}

void sub_10030D41C(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v6 = *(_DWORD *)(a2 + 80);
  int v7 = *(_DWORD *)(a1 + 352);
  switch(v7)
  {
    case 0:
      if (v6 == 2)
      {
        int v24 = 2;
        goto LABEL_17;
      }

      __int128 v46 = *(_OWORD *)(a2 + 80);
      *(_OWORD *)(a3 + 64) = *(_OWORD *)(a2 + 64);
      *(_OWORD *)(a3 + 80) = v46;
      __int128 v47 = *(_OWORD *)(a2 + 112);
      *(_OWORD *)(a3 + 96) = *(_OWORD *)(a2 + 96);
      *(_OWORD *)(a3 + 112) = v47;
      __int128 v48 = *(_OWORD *)(a2 + 16);
      *(_OWORD *)a3 = *(_OWORD *)a2;
      *(_OWORD *)(a3 + 16) = v48;
      __int128 v49 = *(_OWORD *)(a2 + 48);
      *(_OWORD *)(a3 + 32) = *(_OWORD *)(a2 + 32);
      *(_OWORD *)(a3 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v49;
      *(_DWORD *)(a3 + 112) = 0;
      *(_BYTE *)(a3 + 116) = 1;
      goto LABEL_20;
    case 1:
    case 4:
      if (v6 != 2) {
        goto LABEL_18;
      }
      if (!*(_BYTE *)(a1 + 344)) {
        goto LABEL_18;
      }
      if (!*(_BYTE *)(a1 + 200)) {
        goto LABEL_18;
      }
      if (!*(void *)(a1 + 88)) {
        goto LABEL_18;
      }
      uint64_t v8 = *(void *)(*(void *)(a1 + 56) + ((*(void *)(a1 + 80) >> 2) & 0x3FFFFFFFFFFFFFF8LL))
         + ((*(void *)(a1 + 80) & 0x1FLL) << 7);
      __int128 v9 = *(_OWORD *)(v8 + 80);
      __int128 v89 = *(_OWORD *)(v8 + 64);
      __int128 v90 = v9;
      __int128 v10 = *(_OWORD *)(v8 + 112);
      __int128 v91 = *(_OWORD *)(v8 + 96);
      __int128 v92 = v10;
      __int128 v11 = *(_OWORD *)(v8 + 16);
      float32x4_t v85 = *(float32x4_t *)v8;
      __int128 v86 = v11;
      __int128 v12 = *(_OWORD *)(v8 + 48);
      __int128 v87 = *(_OWORD *)(v8 + 32);
      __int128 v88 = v12;
      char v93 = 1;
      __int128 v13 = *(_OWORD *)(a1 + 296);
      __int128 v81 = *(_OWORD *)(a1 + 280);
      __int128 v82 = v13;
      __int128 v14 = *(_OWORD *)(a1 + 328);
      __int128 v83 = *(_OWORD *)(a1 + 312);
      __int128 v84 = v14;
      __int128 v15 = *(_OWORD *)(a1 + 232);
      __int128 v77 = *(_OWORD *)(a1 + 216);
      __int128 v78 = v15;
      __int128 v16 = *(_OWORD *)(a1 + 264);
      __int128 v79 = *(_OWORD *)(a1 + 248);
      __int128 v80 = v16;
      __int128 v17 = *(_OWORD *)(a1 + 200);
      float32x4_t v75 = *(float32x4_t *)(a1 + 184);
      __int128 v76 = v17;
      *(double *)v18.i64 = sub_10030D00C((uint64_t)&v75);
      int32x4_t v19 = (int32x4_t)vnegq_f32(v18);
      int8x16_t v20 = (int8x16_t)vtrn2q_s32((int32x4_t)v18, vtrn1q_s32((int32x4_t)v18, v19));
      float32x4_t v21 = (float32x4_t)vrev64q_s32((int32x4_t)v18);
      v21.i32[0] = v19.i32[1];
      v21.i32[3] = v19.i32[2];
      if (!sub_10030D230( (float32x4_t *)a1,  &v85,  vaddq_f32( vmlaq_n_f32( vmulq_lane_f32( (float32x4_t)vextq_s8((int8x16_t)v18, (int8x16_t)v19, 8uLL),  *(float32x2_t *)(a1 + 16),  1),  (float32x4_t)vextq_s8(v20, v20, 8uLL),  COERCE_FLOAT(*(_OWORD *)(a1 + 16))),  vmlaq_laneq_f32(vmulq_laneq_f32(v18, *(float32x4_t *)(a1 + 16), 3), v21, *(float32x4_t *)(a1 + 16), 2)))) {
        goto LABEL_18;
      }
      int v22 = *(_DWORD *)(a1 + 352);
      if (v22 == 4)
      {
        int v23 = 5;
      }

      else
      {
        if (v22 != 1) {
          goto LABEL_38;
        }
        int v23 = 3;
      }

      *(_DWORD *)(a1 + 352) = v23;
LABEL_38:
      uint64_t v51 = *(void *)(a1 + 56);
      if (*(void *)(a1 + 64) != v51)
      {
        unint64_t v52 = *(void *)(a1 + 80);
        __int128 v53 = (void *)(v51 + 8 * (v52 >> 5));
        __int128 v54 = (__int128 *)(*v53 + ((v52 & 0x1F) << 7));
        uint64_t v55 = *(void *)(v51 + (((*(void *)(a1 + 88) + v52) >> 2) & 0x3FFFFFFFFFFFFFF8LL))
            + (((*(void *)(a1 + 88) + v52) & 0x1F) << 7);
        while (v54 != (__int128 *)v55)
        {
          __int128 v56 = *v54;
          __int128 v66 = v54[2];
          __int128 v67 = v54[1];
          __int128 v64 = v54[4];
          __int128 v65 = v54[3];
          __int128 v57 = v54[6];
          __int128 v73 = v54[7];
          __int128 v74 = v56;
          __int128 v71 = v54[5];
          __int128 v72 = v57;
          v70[0] = v56;
          v70[5] = v71;
          v70[6] = v57;
          v70[7] = v73;
          *(double *)v58.i64 = sub_1002CE658(*(float32x4_t *)(a1 + 32));
          uint64_t v62 = 0LL;
          v68[0] = v67;
          v68[1] = v66;
          v68[2] = v65;
          v68[3] = v64;
          do
          {
            v69[v62] = vmlaq_laneq_f32( vmlaq_laneq_f32( vmlaq_lane_f32(vmulq_n_f32(v58, COERCE_FLOAT(v68[v62])), v59, *(float32x2_t *)&v68[v62], 1),  v60,  (float32x4_t)v68[v62],  2),  v61,  (float32x4_t)v68[v62],  3);
            ++v62;
          }

          while (v62 != 4);
          v70[1] = v69[0];
          v70[2] = v69[1];
          v70[3] = v69[2];
          _OWORD v70[4] = v69[3];
          sub_1002C6AFC((void *)(a1 + 96), v70);
          v54 += 8;
          if ((__int128 *)((char *)v54 - *v53) == (__int128 *)4096)
          {
            float32x4_t v63 = (__int128 *)v53[1];
            ++v53;
            __int128 v54 = v63;
          }
        }
      }

      goto LABEL_18;
    case 2:
      if (v6 == 2) {
        goto LABEL_22;
      }
      *(_OWORD *)(a1 + 16) = xmmword_1004305D0;
      *(_OWORD *)(a1 + 32) = xmmword_10042DB60;
      *(_DWORD *)(a1 + 352) = 0;
      goto LABEL_18;
    case 3:
      if (v6 == 2) {
        goto LABEL_22;
      }
      int v24 = 1;
LABEL_17:
      *(_DWORD *)(a1 + 352) = v24;
      goto LABEL_18;
    case 5:
      if (v6 == 2)
      {
LABEL_22:
        __int128 v29 = *(_OWORD *)(a2 + 80);
        *(_OWORD *)(a3 + 64) = *(_OWORD *)(a2 + 64);
        *(_OWORD *)(a3 + 80) = v29;
        __int128 v30 = *(_OWORD *)(a2 + 112);
        *(_OWORD *)(a3 + 96) = *(_OWORD *)(a2 + 96);
        *(_OWORD *)(a3 + 112) = v30;
        __int128 v31 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a3 = *(_OWORD *)a2;
        *(_OWORD *)(a3 + 16) = v31;
        __int128 v32 = *(_OWORD *)(a2 + 48);
        *(_OWORD *)(a3 + 32) = *(_OWORD *)(a2 + 32);
        *(_OWORD *)(a3 + 4_Block_object_dispose((const void *)(v1 - 112), 8) = v32;
        *(_DWORD *)(a3 + 112) = v7;
        *(_BYTE *)(a3 + 116) = 1;
      }

      else
      {
        *(_DWORD *)(a1 + 352) = 4;
        if (*(_BYTE *)(a1 + 344))
        {
          if (*(_BYTE *)(a1 + 200))
          {
            if (*(void *)(a1 + 88))
            {
              uint64_t v50 = *(void *)(*(void *)(a1 + 56) + ((*(void *)(a1 + 80) >> 2) & 0x3FFFFFFFFFFFFFF8LL))
                  + ((*(void *)(a1 + 80) & 0x1FLL) << 7);
              if (*(double *)v50 - *(double *)(a1 + 192) < *(double *)(a1 + 360))
              {
                __int128 v79 = *(_OWORD *)(v50 + 64);
                __int128 v80 = *(_OWORD *)(v50 + 80);
                __int128 v81 = *(_OWORD *)(v50 + 96);
                __int128 v82 = *(_OWORD *)(v50 + 112);
                float32x4_t v75 = *(float32x4_t *)v50;
                __int128 v76 = *(_OWORD *)(v50 + 16);
                __int128 v77 = *(_OWORD *)(v50 + 32);
                __int128 v78 = *(_OWORD *)(v50 + 48);
                LOBYTE(v83) = 1;
                sub_10030CF30(a1, &v75, a1 + 184);
              }
            }
          }
        }

void sub_10030D980(uint64_t a1@<X8>)
{
  *(void *)a1 = 0LL;
  *(_BYTE *)(a1 + _Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 192) = 0;
  *(_BYTE *)(a1 + 200) = 0;
  *(_BYTE *)(a1 + 20_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 216) = 0;
  *(_BYTE *)(a1 + 224) = 0;
  *(_DWORD *)(a1 + 232) = 0;
  *(_BYTE *)(a1 + 240) = 0;
  *(_BYTE *)(a1 + 24_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 256) = 0;
  *(_BYTE *)(a1 + 272) = 0;
  *(_BYTE *)(a1 + 28_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 304) = 0;
  *(_BYTE *)(a1 + 320) = 0;
  *(_BYTE *)(a1 + 32_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 336) = 0;
  *(_BYTE *)(a1 + 344) = 0;
  *(_WORD *)(a1 + 352) = 0;
  *(_BYTE *)(a1 + 356) = 0;
  *(_BYTE *)(a1 + 360) = 0;
  *(_BYTE *)(a1 + 364) = 0;
  *(_BYTE *)(a1 + 36_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 372) = 0;
  *(_BYTE *)(a1 + 376) = 0;
  *(_WORD *)(a1 + 380) = 0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT)) {
    sub_1003ABE70();
  }
}

void sub_10030DA28(uint64_t a1@<X8>)
{
  *(_BYTE *)a1 = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 72) = 0;
  *(_BYTE *)(a1 + 80) = 0;
  *(_BYTE *)(a1 + 112) = 0;
  *(_BYTE *)(a1 + 160) = 0;
  *(_WORD *)(a1 + 16_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(void *)(a1 + 120) = 0LL;
  *(void *)(a1 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = 0LL;
  *(_BYTE *)(a1 + 136) = 0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT)) {
    sub_1003ABE9C();
  }
}

uint64_t sub_10030DA90(uint64_t result, uint64_t a2)
{
  int v2 = *(unsigned __int8 *)(result + 32);
  uint64_t v3 = *(void *)(a2 + 16);
  *(_OWORD *)(result + _Block_object_dispose((const void *)(v1 - 112), 8) = *(_OWORD *)a2;
  *(void *)(result + 24) = v3;
  if (!v2) {
    *(_BYTE *)(result + 32) = 1;
  }
  return result;
}

BOOL sub_10030DAB8(uint64_t a1, double *a2, double a3)
{
  int v3 = *(unsigned __int8 *)(a1 + 32);
  if (*(_BYTE *)(a1 + 32)) {
    *a2 = a3 - *(double *)(a1 + 16) + *(double *)(a1 + 8);
  }
  return v3 != 0;
}

BOOL sub_10030DADC(uint64_t a1, double *a2, double a3)
{
  int v3 = *(unsigned __int8 *)(a1 + 32);
  if (*(_BYTE *)(a1 + 32)) {
    *a2 = a3 - *(double *)(a1 + 24) + *(double *)(a1 + 8);
  }
  return v3 != 0;
}

void sub_10030DB04()
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT)) {
    sub_1003ABEC8();
  }
}

void sub_10030DB44()
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT)) {
    sub_1003ABEF4();
  }
}

void sub_10030DB84()
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT)) {
    sub_1003ABF20();
  }
}

void sub_10030DBC4()
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT)) {
    sub_1003ABF4C();
  }
}

void sub_10030DC04()
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT)) {
    sub_1003ABF78();
  }
}

void sub_10030DC44()
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT)) {
    sub_1003ABFA4();
  }
}

void sub_10030DC84()
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT)) {
    sub_1003ABFD0();
  }
}

void sub_10030DCC4()
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT)) {
    sub_1003ABFFC();
  }
}

void sub_10030DD04()
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT)) {
    sub_1003AC028();
  }
}

void sub_10030DD44()
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT)) {
    sub_1003AC054();
  }
}

void sub_10030DD84()
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT)) {
    sub_1003AC080();
  }
}

void sub_10030DDC4()
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT)) {
    sub_1003AC0AC();
  }
}

void sub_10030DE04()
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT)) {
    sub_1003AC0D8();
  }
}

void sub_10030DE44()
{
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT)) {
    sub_1003AC104();
  }
}

uint64_t sub_10030DE84()
{
  return 0LL;
}

uint64_t sub_10030DE8C()
{
  return 0LL;
}

uint64_t sub_10030DE94(int a1, double a2, double a3)
{
  if (a1 != 2) {
    return 1LL;
  }
  if (a2 < -1000.0) {
    return 1LL;
  }
  if (a2 > 0.15) {
    return 1LL;
  }
  uint64_t result = 0LL;
  if (a3 <= 10000.0 && a3 >= 350.0) {
    return 1LL;
  }
  return result;
}

void sub_10030DEE8(std::string *a1)
{
  p_data = (void **)&a1[4].__r_.__value_.__l.__data_;
  sub_100311070(&a1[8].__r_.__value_.__s.__data_[16], a1 + 4);
  if (a1[6].__r_.__value_.__s.__data_[0])
  {
    a1[6].__r_.__value_.__s.__data_[0] = 0;
  }

void sub_10030DF30(uint64_t a1@<X0>, uint64_t a2@<X1>, char *a3@<X8>, float a4@<S0>)
{
  uint64_t v8 = *(void *)(a1 + 80);
  __int128 v11 = *(uint64_t ***)(v8 + 8);
  __int128 v10 = (uint64_t *)(v8 + 8);
  __int128 v9 = v11;
  if (v11)
  {
    __int128 v12 = v10;
    do
    {
      __int128 v13 = v9 + 1;
      if (*((float *)v9 + 14) > a4)
      {
        __int128 v13 = v9;
        __int128 v12 = (uint64_t *)v9;
      }

      __int128 v9 = (uint64_t **)*v13;
    }

    while (*v13);
  }

  else
  {
    __int128 v12 = v10;
  }

  int v14 = *(unsigned __int8 *)(a1 + 144);
  LOBYTE(__p) = 0;
  char v57 = 0;
  char v58 = 0;
  __int128 v15 = (__int128 *)v59;
  sub_1002AEE40((char *)v59, &__p);
  if (v57 && v56 < 0) {
    operator delete((void *)__p);
  }
  LOBYTE(v4_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  char v50 = 0;
  char v51 = 1;
  __int128 v16 = (__int128 *)v52;
  sub_1002AEE40((char *)v52, &v48);
  if (v50 && v49 < 0) {
    operator delete((void *)v48);
  }
  if (v12 == v10)
  {
    if (!v14) {
      goto LABEL_48;
    }
    if (!*(_BYTE *)(a1 + 144))
    {
      int v42 = 106;
      goto LABEL_86;
    }

    if ((float)(*(float *)(a1 + 120) + *(float *)a1) < a4)
    {
      sub_100311070((char *)(a1 + 208), (std::string *)(a1 + 96));
      if (*(_BYTE *)(a1 + 144))
      {
        *(_BYTE *)(a1 + 144) = 0;
      }

      uint64_t v27 = *(void *)(a1 + 80);
      uint64_t v30 = *(void *)(v27 + 8);
      uint64_t v28 = v27 + 8;
      uint64_t v29 = v30;
      if (v30)
      {
        do
        {
          uint64_t v31 = v29;
          uint64_t v29 = *(void *)(v29 + 8);
        }

        while (v29);
      }

      else
      {
        do
        {
          uint64_t v31 = *(void *)(v28 + 16);
          BOOL v18 = *(void *)v31 == v28;
          uint64_t v28 = v31;
        }

        while (v18);
      }

      sub_10030E4C8((char *)(a1 + 152), (std::string *)(v31 + 32));
      __int128 v32 = &v51;
      __int128 v15 = (__int128 *)v52;
    }

    else
    {
LABEL_48:
      __int128 v32 = &v58;
    }

    *a3 = *v32;
    sub_1002AEE40(a3 + 8, v15);
    goto LABEL_77;
  }

  __int128 v17 = v12 + 4;
  if (*((_BYTE *)v12 + 72)) {
    BOOL v18 = (a2 & 0xFF00000000LL) == 0;
  }
  else {
    BOOL v18 = 1;
  }
  if (v18 || (double v19 = *(double *)(a1 + 8), v19 <= *(float *)&a2))
  {
    if (!v14)
    {
      uint64_t v33 = *(void *)(a1 + 80);
      uint64_t v36 = *(void *)(v33 + 8);
      uint64_t v34 = v33 + 8;
      uint64_t v35 = v36;
      if (v36)
      {
        do
        {
          uint64_t v37 = v35;
          uint64_t v35 = *(void *)(v35 + 8);
        }

        while (v35);
      }

      else
      {
        do
        {
          uint64_t v37 = *(void *)(v34 + 16);
          BOOL v18 = *(void *)v37 == v34;
          uint64_t v34 = v37;
        }

        while (v18);
      }

      if ((float)(*(float *)(v37 + 56) - *(float *)(a1 + 4)) >= a4)
      {
        sub_100311070((char *)(a1 + 208), (std::string *)(a1 + 96));
        sub_10030E4C8((char *)(a1 + 96), (std::string *)(v12 + 4));
        if (v12 == **(uint64_t ***)(a1 + 80))
        {
          if (*(_BYTE *)(a1 + 200))
          {
            *(_BYTE *)(a1 + 200) = 0;
          }
        }

        else
        {
          __int128 v40 = (uint64_t **)*v12;
          if (*v12)
          {
            do
            {
              __int128 v41 = v40;
              __int128 v40 = (uint64_t **)v40[1];
            }

            while (v40);
          }

          else
          {
            do
            {
              __int128 v41 = (uint64_t **)v12[2];
              BOOL v18 = *v41 == v12;
              __int128 v12 = (uint64_t *)v41;
            }

            while (v18);
          }

          sub_10030E4C8((char *)(a1 + 152), (std::string *)(v41 + 4));
        }

        unint64_t v38 = &v51;
      }

      else
      {
        unint64_t v38 = &v58;
        __int128 v16 = (__int128 *)v59;
      }

      *a3 = *v38;
      sub_1002AEE40(a3 + 8, v16);
      goto LABEL_77;
    }

    if (*(_BYTE *)(a1 + 144))
    {
      buf[0].__r_.__value_.__s.__data_[0] = 0;
      char v63 = 0;
      if (v12 != **(uint64_t ***)(a1 + 80))
      {
        int8x16_t v20 = (uint64_t **)*v12;
        if (*v12)
        {
          do
          {
            float32x4_t v21 = v20;
            int8x16_t v20 = (uint64_t **)v20[1];
          }

          while (v20);
        }

        else
        {
          do
          {
            float32x4_t v21 = (uint64_t **)v12[2];
            BOOL v18 = *v21 == v12;
            __int128 v12 = (uint64_t *)v21;
          }

          while (v18);
        }

        sub_10030E4C8((char *)buf, (std::string *)(v21 + 4));
      }

      int v22 = sub_10030E554(a1, (float *)(a1 + 96), (uint64_t)v17, buf, a4);
      int v23 = &v58;
      if (v22) {
        int v23 = &v51;
      }
      *a3 = *v23;
      int v24 = a3 + 8;
      if (v22) {
        __int128 v25 = (__int128 *)v52;
      }
      else {
        __int128 v25 = (__int128 *)v59;
      }
      sub_1002AEE40(v24, v25);
      if (v63 && (char)buf[0].__r_.__value_.__s.__size_ < 0)
      {
        __int128 v26 = (void *)buf[0].__r_.__value_.__r.__words[0];
LABEL_70:
        operator delete(v26);
        goto LABEL_77;
      }

      goto LABEL_77;
    }

    int v42 = 143;
LABEL_86:
    __assert_rtn("checkForRegionChange", "NRBYDeviceMonitor.cpp", v42, "_currentRegion.has_value()");
  }

  __int128 v39 = (os_log_s *)qword_1008000A0;
  if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf[0].__r_.__value_.__l.__data_) = 134218240;
    *(double *)((char *)buf[0].__r_.__value_.__r.__words + 4) = *(float *)&a2;
    WORD2(buf[0].__r_.__value_.__r.__words[1]) = 2048;
    *(double *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 6) = v19;
    _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_DEFAULT,  "#regionmon region change supressed: intent score: %f, required score: %f",  (uint8_t *)buf,  0x16u);
  }

  if (*((char *)v12 + 55) < 0)
  {
    sub_1000063A8(v43, (void *)v12[4], v12[5]);
  }

  else
  {
    *(_OWORD *)__int128 v43 = *v17;
    uint64_t v44 = v12[6];
  }

  __int128 v45 = *(_OWORD *)(v12 + 7);
  __int16 v46 = *((_WORD *)v12 + 36);
  char v47 = 1;
  *a3 = 0;
  sub_1002AEE40(a3 + 8, (__int128 *)v43);
  if (v47 && SHIBYTE(v44) < 0)
  {
    __int128 v26 = v43[0];
    goto LABEL_70;
  }

void sub_10030E40C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20, uint64_t a21, int a22, __int16 a23, char a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29, uint64_t a30, void *__p, uint64_t a32, int a33, __int16 a34, char a35, char a36, uint64_t a37, uint64_t a38, uint64_t a39, char a40, uint64_t a41, uint64_t a42, int a43, __int16 a44, char a45, char a46, uint64_t a47, uint64_t a48, uint64_t a49, char a50,uint64_t a51,void *a52,uint64_t a53,int a54,__int16 a55,char a56,char a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61)
{
  if (a40 && a36 < 0) {
    operator delete(__p);
  }
  if (a61)
  {
    if (a57 < 0) {
      operator delete(a52);
    }
  }

  _Unwind_Resume(exception_object);
}

char *sub_10030E4C8(char *__dst, std::string *__str)
{
  if (__dst[48])
  {
    std::string::operator=((std::string *)__dst, __str);
    __int16 v4 = __str[1].__r_.__value_.__r.__words[2];
    *(_OWORD *)(__dst + 24) = *(_OWORD *)&__str[1].__r_.__value_.__l.__data_;
    *((_WORD *)__dst + 20) = v4;
  }

  else
  {
    if ((char)__str->__r_.__value_.__s.__size_ < 0)
    {
      sub_1000063A8(__dst, __str->__r_.__value_.__l.__data_, __str->__r_.__value_.__l.__size_);
    }

    else
    {
      __int128 v5 = *(_OWORD *)&__str->__r_.__value_.__l.__data_;
      *((void *)__dst + 2) = __str->__r_.__value_.__l.__cap_;
      *(_OWORD *)__int128 __dst = v5;
    }

    __int128 v6 = *(_OWORD *)&__str[1].__r_.__value_.__l.__data_;
    *((_WORD *)__dst + 20) = __str[1].__r_.__value_.__r.__words[2];
    *(_OWORD *)(__dst + 24) = v6;
    __dst[48] = 1;
  }

  return __dst;
}

uint64_t sub_10030E554(uint64_t a1, float *a2, uint64_t a3, std::string *a4, float a5)
{
  if (*(float *)(a3 + 24) >= a2[6])
  {
    if (!*(_BYTE *)(a1 + 144)) {
      sub_1003AC158();
    }
  }

  else
  {
    if (!*(_BYTE *)(a1 + 200)) {
      sub_1003AC130();
    }
  }

  sub_100311070((char *)(a1 + 208), (std::string *)(a1 + 96));
  sub_10030E4C8((char *)(a1 + 96), (std::string *)a3);
  sub_100311070((char *)(a1 + 152), a4);
  return 1LL;
}

BOOL sub_10030E624(unsigned __int8 *a1, float *a2)
{
  int v2 = a2;
  uint64_t v4 = a1[23];
  if ((v4 & 0x80u) == 0LL) {
    uint64_t v5 = a1[23];
  }
  else {
    uint64_t v5 = *((void *)a1 + 1);
  }
  uint64_t v6 = *((unsigned __int8 *)a2 + 23);
  int v7 = (char)v6;
  if ((v6 & 0x80u) != 0LL) {
    uint64_t v6 = *((void *)a2 + 1);
  }
  if (v5 != v6) {
    return 0LL;
  }
  if (v7 < 0) {
    a2 = *(float **)a2;
  }
  if ((v4 & 0x80) != 0)
  {
    return 0LL;
  }

  if (a1[23])
  {
    for (int i = a1; *i == *(unsigned __int8 *)a2; ++i)
    {
      a2 = (float *)((char *)a2 + 1);
      if (!--v4) {
        return *((_DWORD *)a1 + 9) == *((_DWORD *)v2 + 9);
      }
    }

    return 0LL;
  }

  return *((_DWORD *)a1 + 9) == *((_DWORD *)v2 + 9);
}

uint64_t sub_10030E6E4(uint64_t a1, float a2)
{
  uint64_t v2 = *(void *)(a1 + 80);
  uint64_t v5 = *(uint64_t ***)(v2 + 8);
  int v3 = (uint64_t *)(v2 + 8);
  uint64_t v4 = v5;
  if (!v5) {
    goto LABEL_14;
  }
  uint64_t v6 = v3;
  do
  {
    int v7 = v4 + 1;
    if (*((float *)v4 + 14) > a2)
    {
      int v7 = v4;
      uint64_t v6 = (uint64_t *)v4;
    }

    uint64_t v4 = (uint64_t **)*v7;
  }

  while (*v7);
  if (v6 == v3)
  {
LABEL_14:
    uint64_t v12 = qword_1008000A0;
    BOOL v13 = os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0LL;
    if (!v13) {
      return result;
    }
    LOWORD(v26) = 0;
    int v14 = "#regionmon #spatialGesturesPredictor Current region = candidateOutsideKnownRegions, shouldPredictIntent = false";
    __int128 v15 = (os_log_s *)v12;
    uint32_t v16 = 2;
    goto LABEL_16;
  }

  uint64_t v8 = v6 + 4;
  if (*((_BYTE *)v6 + 72))
  {
    __int128 v9 = (os_log_s *)qword_1008000A0;
    if (!os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT)) {
      return 1LL;
    }
    int v26 = 136315138;
    uint64_t v27 = v8;
    __int128 v10 = "#regionmon #spatialGesturesPredictor Current region = %s, shouldPredictIntent = true, since this region requires user intent";
LABEL_12:
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)&v26, 0xCu);
    return 1LL;
  }

  if (v6 != **(uint64_t ***)(a1 + 80))
  {
    __int128 v17 = (uint64_t *)*v6;
    if (*v6)
    {
      do
      {
        BOOL v18 = v17;
        __int128 v17 = (uint64_t *)v17[1];
      }

      while (v17);
    }

    else
    {
      double v19 = v6;
      do
      {
        BOOL v18 = (uint64_t *)v19[2];
        BOOL v20 = *v18 == (void)v19;
        double v19 = v18;
      }

      while (v20);
    }

    if (*((_BYTE *)v18 + 72))
    {
      __int128 v9 = (os_log_s *)qword_1008000A0;
      if (!os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT)) {
        return 1LL;
      }
      int v26 = 136315138;
      uint64_t v27 = v8;
      __int128 v10 = "#regionmon #spatialGesturesPredictor Current region = %s, shouldPredictIntent = true, since inner adjacent r"
            "egion requires user intent";
      goto LABEL_12;
    }
  }

  float32x4_t v21 = (uint64_t *)v6[1];
  if (v21)
  {
    do
    {
      int v22 = v21;
      float32x4_t v21 = (uint64_t *)*v21;
    }

    while (v21);
  }

  else
  {
    int v23 = v6;
    do
    {
      int v22 = (uint64_t *)v23[2];
      BOOL v20 = *v22 == (void)v23;
      int v23 = v22;
    }

    while (!v20);
  }

  if (v22 != v3 && *((_BYTE *)v22 + 72))
  {
    __int128 v9 = (os_log_s *)qword_1008000A0;
    if (!os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT)) {
      return 1LL;
    }
    int v26 = 136315138;
    uint64_t v27 = v8;
    __int128 v10 = "#regionmon #spatialGesturesPredictor Current region = %s, shouldPredictIntent = true, since outer adjacent reg"
          "ion requires user intent";
    goto LABEL_12;
  }

  uint64_t v24 = qword_1008000A0;
  BOOL v25 = os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0LL;
  if (v25)
  {
    int v26 = 136315138;
    uint64_t v27 = v8;
    int v14 = "#regionmon #spatialGesturesPredictor Current region = %s, shouldPredictIntent = false, since neither this regi"
          "on nor adjacent ones require user intent";
    __int128 v15 = (os_log_s *)v24;
    uint32_t v16 = 12;
LABEL_16:
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, v14, (uint8_t *)&v26, v16);
    return 0LL;
  }

  return result;
}

uint64_t sub_10030E9B0( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t *a5, uint64_t a6, int a7, unsigned int a8, double a9, int a10, uint64_t a11, uint64_t a12)
{
  *(void *)a1 = a2;
  uint64_t v18 = a1 + 40;
  sub_10001E914(a1 + 8, a3);
  sub_10001E914(v18, a4);
  sub_10001E914(a1 + 72, a12);
  *(void *)(a1 + 104) = *a5;
  unint64_t v19 = a5[1];
  __int128 v140 = (void **)(a1 + 104);
  *(void *)(a1 + 112) = v19;
  if (v19)
  {
    BOOL v20 = (unint64_t *)(v19 + 8);
    do
      unint64_t v21 = __ldxr(v20);
    while (__stxr(v21 + 1, v20));
  }

  *(void *)(a1 + 120) = 0LL;
  *(_BYTE *)(a1 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 136) = 0;
  *(_DWORD *)(a1 + 144) = a10;
  int v22 = (_OWORD *)(a1 + 152);
  unint64_t v23 = *a5;
  uint64_t v24 = (std::__shared_weak_count *)a5[1];
  __int128 v139 = (_OWORD *)(a1 + 152);
  if (v24)
  {
    p_shared_owners = (unint64_t *)&v24->__shared_owners_;
    do
      unint64_t v26 = __ldxr(p_shared_owners);
    while (__stxr(v26 + 1, p_shared_owners));
    uint64_t v27 = (_OWORD *)(a6 + 32);
    *int v22 = *(_OWORD *)(a6 + 32);
    __int128 v28 = *(_OWORD *)(a6 + 48);
    __int128 v29 = *(_OWORD *)(a6 + 64);
    __int128 v30 = *(_OWORD *)(a6 + 96);
    *(_OWORD *)(a1 + 200) = *(_OWORD *)(a6 + 80);
    *(_OWORD *)(a1 + 216) = v30;
    *(_OWORD *)(a1 + 16_Block_object_dispose((const void *)(v1 - 112), 8) = v28;
    *(_OWORD *)(a1 + 184) = v29;
    *(void *)(a1 + 232) = v23;
    *(void *)(a1 + 240) = v24;
    uint64_t v31 = a1 + 232;
    do
      unint64_t v32 = __ldxr(p_shared_owners);
    while (__stxr(v32 + 1, p_shared_owners));
  }

  else
  {
    uint64_t v27 = (_OWORD *)(a6 + 32);
    *int v22 = *(_OWORD *)(a6 + 32);
    __int128 v33 = *(_OWORD *)(a6 + 48);
    __int128 v34 = *(_OWORD *)(a6 + 64);
    __int128 v35 = *(_OWORD *)(a6 + 96);
    *(_OWORD *)(a1 + 200) = *(_OWORD *)(a6 + 80);
    *(_OWORD *)(a1 + 216) = v35;
    *(_OWORD *)(a1 + 16_Block_object_dispose((const void *)(v1 - 112), 8) = v33;
    *(_OWORD *)(a1 + 184) = v34;
    *(void *)(a1 + 232) = v23;
    *(void *)(a1 + 240) = 0LL;
    uint64_t v31 = a1 + 232;
  }

  *(_BYTE *)(a1 + 24_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  *(_BYTE *)(a1 + 296) = 0;
  *(_BYTE *)(a1 + 304) = 0;
  *(_BYTE *)(a1 + 352) = 0;
  *(_BYTE *)(a1 + 360) = 0;
  *(_BYTE *)(a1 + 40_Block_object_dispose((const void *)(v1 - 112), 8) = 0;
  if (v24)
  {
    uint64_t v36 = (unint64_t *)&v24->__shared_owners_;
    do
      unint64_t v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }

  *(_BYTE *)(a1 + 416) = 0;
  *(_BYTE *)(a1 + 424) = 0;
  sub_1002AEA60((uint64_t *)(a1 + 432), a6);
  memcpy((void *)(a1 + 456), (const void *)(a6 + 24), 0x18CuLL);
  uint64_t v38 = a6 + 424;
  *(_OWORD *)(a1 + 856) = *(_OWORD *)(a6 + 424);
  sub_100201E2C((uint64_t *)(a1 + 872), a6 + 440);
  __int128 v39 = *(_OWORD *)(a6 + 464);
  *(_OWORD *)(a1 + 90_Block_object_dispose((const void *)(v1 - 112), 8) = *(_OWORD *)(a6 + 476);
  *(_OWORD *)(a1 + 896) = v39;
  sub_100201F04(a1 + 928, (__int128 *)(a6 + 496));
  __int128 v40 = *(_OWORD *)(a6 + 544);
  *(_OWORD *)(a1 + 960) = *(_OWORD *)(a6 + 528);
  *(_OWORD *)(a1 + 976) = v40;
  __int128 v41 = *(_OWORD *)(a6 + 560);
  __int128 v42 = *(_OWORD *)(a6 + 576);
  __int128 v43 = *(_OWORD *)(a6 + 592);
  *(_OWORD *)(a1 + 1040) = *(_OWORD *)(a6 + 608);
  *(_OWORD *)(a1 + 100_Block_object_dispose((const void *)(v1 - 112), 8) = v42;
  *(_OWORD *)(a1 + 1024) = v43;
  *(_OWORD *)(a1 + 992) = v41;
  __int128 v44 = *(_OWORD *)(a6 + 624);
  __int128 v45 = *(_OWORD *)(a6 + 640);
  __int128 v46 = *(_OWORD *)(a6 + 656);
  *(_OWORD *)(a1 + 1104) = *(_OWORD *)(a6 + 672);
  *(_OWORD *)(a1 + 108_Block_object_dispose((const void *)(v1 - 112), 8) = v46;
  *(_OWORD *)(a1 + 1072) = v45;
  *(_OWORD *)(a1 + 1056) = v44;
  __int128 v47 = *(_OWORD *)(a6 + 688);
  __int128 v48 = *(_OWORD *)(a6 + 704);
  __int128 v49 = *(_OWORD *)(a6 + 720);
  *(void *)(a1 + 116_Block_object_dispose((const void *)(v1 - 112), 8) = *(void *)(a6 + 736);
  *(_OWORD *)(a1 + 1152) = v49;
  *(_OWORD *)(a1 + 1136) = v48;
  *(_OWORD *)(a1 + 1120) = v47;
  *(_DWORD *)(a1 + 1176) = a7;
  *(_DWORD *)(a1 + 1184) = a8;
  *(_BYTE *)(a1 + 1192) = 0;
  *(_BYTE *)(a1 + 1200) = 0;
  __int128 v137 = (uint64_t *)(a1 + 1208);
  *(_OWORD *)(a1 + 120_Block_object_dispose((const void *)(v1 - 112), 8) = 0u;
  uint64_t v50 = *(void *)(a1 + 440);
  if (!v50) {
    goto LABEL_174;
  }
  uint64_t v138 = a1 + 360;
  uint64_t v51 = a1 + 440;
  do
  {
    int v52 = *(_DWORD *)(v50 + 28);
    BOOL v53 = v52 < a7;
    if (v52 >= a7) {
      char v54 = (uint64_t *)v50;
    }
    else {
      char v54 = (uint64_t *)(v50 + 8);
    }
    if (!v53) {
      uint64_t v51 = v50;
    }
    uint64_t v50 = *v54;
  }

  while (*v54);
  if (v51 == a1 + 440 || *(_DWORD *)(v51 + 28) > a7)
  {
LABEL_174:
    uint64_t v134 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT)) {
      sub_1003AC180(v134);
    }
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "technology mapping not found for ranging technology.");
  }

  int v55 = *(_DWORD *)(v51 + 32);
  *(_DWORD *)(a1 + 1180) = v55;
  switch(v55)
  {
    case 1:
      __int128 v73 = operator new(0x80uLL);
      sub_100304200(v73, a6 + 24, a6 + 120);
      uint64_t v74 = *(void *)(a1 + 120);
      *(void *)(a1 + 120) = v73;
      if (v74) {
        (*(void (**)(uint64_t))(*(void *)v74 + 8LL))(v74);
      }
      unint64_t v75 = *a5;
      float32x4_t v59 = (std::__shared_weak_count *)a5[1];
      if (v59)
      {
        __int128 v76 = (unint64_t *)&v59->__shared_owners_;
        do
          unint64_t v77 = __ldxr(v76);
        while (__stxr(v77 + 1, v76));
        __int128 v78 = v27[3];
        __int128 v146 = v27[2];
        __int128 v147 = v78;
        __int128 v148 = v27[4];
        __int128 v79 = v27[1];
        *(_OWORD *)__int128 buf = *v27;
        *(_OWORD *)&uint8_t buf[16] = v79;
        *(void *)&__int128 v149 = v75;
        *((void *)&v149 + 1) = v59;
        do
          unint64_t v80 = __ldxr(v76);
        while (__stxr(v80 + 1, v76));
      }

      else
      {
        __int128 v91 = v27[3];
        __int128 v146 = v27[2];
        __int128 v147 = v91;
        __int128 v148 = v27[4];
        __int128 v92 = v27[1];
        *(_OWORD *)__int128 buf = *v27;
        *(_OWORD *)&uint8_t buf[16] = v92;
        __int128 v149 = v75;
      }

      LOBYTE(v150[0]) = 0;
      char v152 = 0;
      LOBYTE(v153[0]) = 0;
      char v155 = 0;
      LOBYTE(__p[0]) = 0;
      char v158 = 0;
      __int128 v93 = v147;
      *(_OWORD *)(a1 + 184) = v146;
      *(_OWORD *)(a1 + 200) = v93;
      *(_OWORD *)(a1 + 216) = v148;
      __int128 v94 = *(_OWORD *)&buf[16];
      _OWORD *v139 = *(_OWORD *)buf;
      *(_OWORD *)(a1 + 16_Block_object_dispose((const void *)(v1 - 112), 8) = v94;
      sub_10000EE54(v31, &v149);
      sub_100311120(a1 + 248, (__int128 *)v150);
      sub_100311120(a1 + 304, (__int128 *)v153);
      __n128 v85 = sub_100311120(v138, (__int128 *)__p);
      if (v158 && v157 < 0) {
        operator delete(__p[0]);
      }
      if (v155 && v154 < 0) {
        operator delete(v153[0]);
      }
      if (v152 && v151 < 0) {
        operator delete(v150[0]);
      }
      double v95 = (std::__shared_weak_count *)*((void *)&v149 + 1);
      if (*((void *)&v149 + 1))
      {
        int v96 = (unint64_t *)(*((void *)&v149 + 1) + 8LL);
        do
          unint64_t v97 = __ldaxr(v96);
        while (__stlxr(v97 - 1, v96));
        if (!v97)
        {
          ((void (*)(std::__shared_weak_count *, __n128))v95->__on_zero_shared)(v95, v85);
          std::__shared_weak_count::__release_weak(v95);
        }
      }

      if (!v59) {
        break;
      }
      double v98 = (unint64_t *)&v59->__shared_owners_;
      do
        unint64_t v90 = __ldaxr(v98);
      while (__stlxr(v90 - 1, v98));
LABEL_109:
      if (!v90)
      {
        ((void (*)(std::__shared_weak_count *, __n128))v59->__on_zero_shared)(v59, v85);
        std::__shared_weak_count::__release_weak(v59);
      }

      break;
    case 3:
      __int128 v65 = operator new(0x408uLL);
      sub_1002CC7C4(v65, v38);
      uint64_t v66 = *(void *)(a1 + 120);
      *(void *)(a1 + 120) = v65;
      if (v66) {
        (*(void (**)(uint64_t))(*(void *)v66 + 8LL))(v66);
      }
      unint64_t v67 = *a5;
      float32x4_t v59 = (std::__shared_weak_count *)a5[1];
      if (v59)
      {
        int v68 = (unint64_t *)&v59->__shared_owners_;
        do
          unint64_t v69 = __ldxr(v68);
        while (__stxr(v69 + 1, v68));
        __int128 v70 = v27[3];
        __int128 v146 = v27[2];
        __int128 v147 = v70;
        __int128 v148 = v27[4];
        __int128 v71 = v27[1];
        *(_OWORD *)__int128 buf = *v27;
        *(_OWORD *)&uint8_t buf[16] = v71;
        *(void *)&__int128 v149 = v67;
        *((void *)&v149 + 1) = v59;
        do
          unint64_t v72 = __ldxr(v68);
        while (__stxr(v72 + 1, v68));
      }

      else
      {
        __int128 v81 = v27[3];
        __int128 v146 = v27[2];
        __int128 v147 = v81;
        __int128 v148 = v27[4];
        __int128 v82 = v27[1];
        *(_OWORD *)__int128 buf = *v27;
        *(_OWORD *)&uint8_t buf[16] = v82;
        __int128 v149 = v67;
      }

      LOBYTE(v150[0]) = 0;
      char v152 = 0;
      LOBYTE(v153[0]) = 0;
      char v155 = 0;
      LOBYTE(__p[0]) = 0;
      char v158 = 0;
      __int128 v83 = v147;
      *(_OWORD *)(a1 + 184) = v146;
      *(_OWORD *)(a1 + 200) = v83;
      *(_OWORD *)(a1 + 216) = v148;
      __int128 v84 = *(_OWORD *)&buf[16];
      _OWORD *v139 = *(_OWORD *)buf;
      *(_OWORD *)(a1 + 16_Block_object_dispose((const void *)(v1 - 112), 8) = v84;
      sub_10000EE54(v31, &v149);
      sub_100311120(a1 + 248, (__int128 *)v150);
      sub_100311120(a1 + 304, (__int128 *)v153);
      __n128 v85 = sub_100311120(v138, (__int128 *)__p);
      if (v158 && v157 < 0) {
        operator delete(__p[0]);
      }
      if (v155 && v154 < 0) {
        operator delete(v153[0]);
      }
      if (v152 && v151 < 0) {
        operator delete(v150[0]);
      }
      __int128 v86 = (std::__shared_weak_count *)*((void *)&v149 + 1);
      if (*((void *)&v149 + 1))
      {
        __int128 v87 = (unint64_t *)(*((void *)&v149 + 1) + 8LL);
        do
          unint64_t v88 = __ldaxr(v87);
        while (__stlxr(v88 - 1, v87));
        if (!v88)
        {
          ((void (*)(std::__shared_weak_count *, __n128))v86->__on_zero_shared)(v86, v85);
          std::__shared_weak_count::__release_weak(v86);
        }
      }

      if (!v59) {
        break;
      }
      __int128 v89 = (unint64_t *)&v59->__shared_owners_;
      do
        unint64_t v90 = __ldaxr(v89);
      while (__stlxr(v90 - 1, v89));
      goto LABEL_109;
    case 2:
      char v56 = operator new(0x150uLL);
      sub_100301C40(v56, a6 + 256);
      uint64_t v57 = *(void *)(a1 + 120);
      *(void *)(a1 + 120) = v56;
      if (v57) {
        (*(void (**)(uint64_t))(*(void *)v57 + 8LL))(v57);
      }
      unint64_t v58 = *a5;
      float32x4_t v59 = (std::__shared_weak_count *)a5[1];
      if (v59)
      {
        char v60 = (unint64_t *)&v59->__shared_owners_;
        do
          unint64_t v61 = __ldxr(v60);
        while (__stxr(v61 + 1, v60));
        __int128 v62 = *(_OWORD *)(a6 + 384);
        __int128 v146 = *(_OWORD *)(a6 + 368);
        __int128 v147 = v62;
        __int128 v148 = *(_OWORD *)(a6 + 400);
        __int128 v63 = *(_OWORD *)(a6 + 352);
        *(_OWORD *)__int128 buf = *(_OWORD *)(a6 + 336);
        *(_OWORD *)&uint8_t buf[16] = v63;
        *(void *)&__int128 v149 = v58;
        *((void *)&v149 + 1) = v59;
        do
          unint64_t v64 = __ldxr(v60);
        while (__stxr(v64 + 1, v60));
      }

      else
      {
        __int128 v99 = *(_OWORD *)(a6 + 384);
        __int128 v146 = *(_OWORD *)(a6 + 368);
        __int128 v147 = v99;
        __int128 v148 = *(_OWORD *)(a6 + 400);
        __int128 v100 = *(_OWORD *)(a6 + 352);
        *(_OWORD *)__int128 buf = *(_OWORD *)(a6 + 336);
        *(_OWORD *)&uint8_t buf[16] = v100;
        __int128 v149 = v58;
      }

      LOBYTE(v150[0]) = 0;
      char v152 = 0;
      LOBYTE(v153[0]) = 0;
      char v155 = 0;
      LOBYTE(__p[0]) = 0;
      char v158 = 0;
      __int128 v101 = v147;
      *(_OWORD *)(a1 + 184) = v146;
      *(_OWORD *)(a1 + 200) = v101;
      *(_OWORD *)(a1 + 216) = v148;
      __int128 v102 = *(_OWORD *)&buf[16];
      _OWORD *v139 = *(_OWORD *)buf;
      *(_OWORD *)(a1 + 16_Block_object_dispose((const void *)(v1 - 112), 8) = v102;
      sub_10000EE54(v31, &v149);
      sub_100311120(a1 + 248, (__int128 *)v150);
      sub_100311120(a1 + 304, (__int128 *)v153);
      __n128 v85 = sub_100311120(v138, (__int128 *)__p);
      if (v158 && v157 < 0) {
        operator delete(__p[0]);
      }
      if (v155 && v154 < 0) {
        operator delete(v153[0]);
      }
      if (v152 && v151 < 0) {
        operator delete(v150[0]);
      }
      __int128 v103 = (std::__shared_weak_count *)*((void *)&v149 + 1);
      if (*((void *)&v149 + 1))
      {
        __int128 v104 = (unint64_t *)(*((void *)&v149 + 1) + 8LL);
        do
          unint64_t v105 = __ldaxr(v104);
        while (__stlxr(v105 - 1, v104));
        if (!v105)
        {
          ((void (*)(std::__shared_weak_count *, __n128))v103->__on_zero_shared)(v103, v85);
          std::__shared_weak_count::__release_weak(v103);
        }
      }

      if (v59)
      {
        uint64_t v106 = (unint64_t *)&v59->__shared_owners_;
        do
          unint64_t v90 = __ldaxr(v106);
        while (__stlxr(v90 - 1, v106));
        goto LABEL_109;
      }

      break;
  }

  uint64_t v142 = 0LL;
  unint64_t v143 = 0LL;
  unint64_t v144 = 0LL;
  uint64_t v107 = (uint64_t)(*v140 + 1);
  double v108 = (void *)**v140;
  if (v108 != (void *)v107)
  {
    unint64_t v109 = 0LL;
    do
    {
      if (*((_BYTE *)v108 + 72))
      {
        __int128 v110 = (__int128 *)(v108 + 4);
        if (v109 >= v144)
        {
          unint64_t v109 = sub_100311250(&v142, v110);
        }

        else
        {
          sub_1003111DC((uint64_t)&v142, v110);
          v109 += 48LL;
        }

        unint64_t v143 = v109;
      }

      int v111 = (void *)v108[1];
      if (v111)
      {
        do
        {
          __int128 v112 = v111;
          int v111 = (void *)*v111;
        }

        while (v111);
      }

      else
      {
        do
        {
          __int128 v112 = (void *)v108[2];
          BOOL v113 = *v112 == (void)v108;
          double v108 = v112;
        }

        while (!v113);
      }

      double v108 = v112;
    }

    while (v112 != (void *)v107);
    if (v142 != v109)
    {
      double v114 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v114,  OS_LOG_TYPE_DEFAULT,  "#regionmon #spatialGesturesPredictor creating deviceMonitor",  buf,  2u);
      }

      uint64_t v115 = a8;
      if (a7 == 4 || a7 == 2)
      {
        if (!a8)
        {
LABEL_130:
          uint64_t v116 = (os_log_s *)qword_1008000A0;
          if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 134217984;
            *(void *)&uint8_t buf[4] = a2;
            _os_log_impl( (void *)&_mh_execute_header,  v116,  OS_LOG_TYPE_DEFAULT,  "#regionmon #spatialGesturesPredictor creating deviceMonitor with intent predictor None for dev %llx",  buf,  0xCu);
          }

LABEL_169:
    abort();
  }

  int v122 = operator new(0x30uLL);
  sub_1002DF294(v122, a11, v115);
  uint64_t v123 = *v137;
  uint64_t *v137 = (uint64_t)v122;
  if (v123) {
    (*(void (**)(uint64_t))(*(void *)v123 + 8LL))(v123);
  }
  *(double *)(a1 + 160) = a9;
  if (!*(void *)(a1 + 96))
  {
    __int128 v131 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_fault_impl( (void *)&_mh_execute_header,  v131,  OS_LOG_TYPE_FAULT,  "#regionmon #spatialGesturesPredictor for intent predictor MotionBasedSpatialGestures, motionTriggeredHandoffCall back must be defined",  buf,  2u);
      __int128 v131 = (os_log_s *)qword_1008000A0;
    }

    if (os_log_type_enabled(v131, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)__int128 buf = 136315650;
      *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/Proximity/Libraries/NearbyAlgorithms/RegionMonitoring/N"
                           "RBYDeviceMonitor.cpp";
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = 377;
      *(_WORD *)&buf[18] = 2080;
      *(void *)&buf[20] = "DeviceMonitor";
      goto LABEL_168;
    }

    goto LABEL_169;
  }

void sub_10030F850( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20, uint64_t a21, uint64_t a22, char *a23)
{
  a23 = &a20;
  sub_1002AE7B4((void ***)&a23);
  uint64_t v26 = 0LL;
  uint64_t v27 = v23 + 152;
  do
  {
    uint64_t v28 = v27[v26];
    v27[v26] = 0LL;
    if (v28) {
      (*(void (**)(uint64_t))(*(void *)v28 + 8LL))(v28);
    }
    --v26;
  }

  while (v26 != -2);
  sub_10015CF8C(a9);
  sub_10030FA5C(a17);
  uint64_t v29 = v23[15];
  v23[15] = 0LL;
  if (v29) {
    (*(void (**)(uint64_t))(*(void *)v29 + 8LL))(v29);
  }
  sub_100012390(a18);
  __int128 v30 = (void *)v23[12];
  if (v30 == a10)
  {
    uint64_t v31 = 4LL;
    __int128 v30 = a10;
  }

  else
  {
    if (!v30) {
      goto LABEL_12;
    }
    uint64_t v31 = 5LL;
  }

  (*(void (**)(void))(*v30 + 8 * v31))();
LABEL_12:
  unint64_t v32 = (void *)v23[8];
  if (v32 == a11)
  {
    uint64_t v33 = 4LL;
    unint64_t v32 = a11;
  }

  else
  {
    if (!v32) {
      goto LABEL_17;
    }
    uint64_t v33 = 5LL;
  }

  (*(void (**)(void))(*v32 + 8 * v33))();
LABEL_17:
  __int128 v34 = (void *)v23[4];
  if (v34 == a12)
  {
    uint64_t v35 = 4LL;
    __int128 v34 = a12;
  }

  else
  {
    if (!v34) {
      goto LABEL_22;
    }
    uint64_t v35 = 5LL;
  }

  (*(void (**)(void))(*v34 + 8 * v35))();
LABEL_22:
  _Unwind_Resume(a1);
}

uint64_t sub_10030FA5C(uint64_t a1)
{
  return a1;
}

uint64_t sub_10030FACC( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t *a5, uint64_t a6, int a7, unsigned int a8, double a9, int a10, uint64_t a11, uint64_t a12)
{
  return sub_10030E9B0(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
}

void sub_10030FAE0(uint64_t a1@<X0>, __int128 *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  float v7 = *((float *)a2 + 4);
  double v8 = *((double *)a2 + 1);
  __int16 v9 = *((_WORD *)a2 + 40);
  *(void *)&v119[6] = *((void *)a2 + 11);
  v119[14] = *((_BYTE *)a2 + 96);
  *(void *)((char *)&v118 + 7) = *((void *)a2 + 13);
  HIBYTE(v11_Block_object_dispose((const void *)(v1 - 112), 8) = *((_BYTE *)a2 + 112);
  *(_OWORD *)((char *)v117 + 7) = a2[8];
  v117[1] = *(__int128 *)((char *)a2 + 137);
  uint64_t v10 = *(void *)(a1 + 120);
  double v11 = v7;
  __int16 v102 = v9;
  *(void *)((char *)v103 + 7) = *(void *)&v119[7];
  v103[0] = *(void *)v119;
  char v104 = 0;
  char v105 = 0;
  __int128 v106 = v118;
  __int128 v108 = v117[1];
  __int128 v107 = v117[0];
  char v109 = 1;
  double v12 = COERCE_DOUBLE( (*(uint64_t (**)(uint64_t, uint64_t, __int16 *, double, double))(*(void *)v10 + 16LL))( v10,  a3,  &v102,  v7,  v8));
  if (!v13)
  {
    *(_BYTE *)a4 = 0;
    *(_BYTE *)(a4 + 184) = 0;
    return;
  }

  float v14 = v12;
  __int128 v15 = a2[9];
  __int128 v98 = a2[8];
  __int128 v99 = v15;
  __int128 v100 = a2[10];
  uint64_t v101 = *((void *)a2 + 22);
  __int128 v16 = a2[5];
  __int128 v94 = a2[4];
  __int128 v95 = v16;
  __int128 v17 = a2[7];
  __int128 v96 = a2[6];
  __int128 v97 = v17;
  __int128 v18 = a2[1];
  __int128 v90 = *a2;
  __int128 v91 = v18;
  __int128 v19 = a2[3];
  __int128 v92 = a2[2];
  __int128 v93 = v19;
  *(float *)&__int128 v91 = v14;
  sub_100301950(*(void **)(a1 + 120), *(double *)&v92);
  unint64_t v21 = 0xBFF0000000000000LL;
  if (v22) {
    unint64_t v21 = v20;
  }
  *((void *)&v92 + 1) = v21;
  int v23 = *(_DWORD *)(a1 + 1184);
  if ((v23 - 1) < 2)
  {
    uint64_t v24 = *(void *)(a1 + 1208);
    if (!v24) {
      goto LABEL_24;
    }
    BOOL v25 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v61 = *(void *)a1;
      *(_DWORD *)__int128 buf = 134217984;
      *(void *)int v111 = v61;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEBUG,  "#regionmon Consuming range result for default intent predictor for device identifier %llu",  buf,  0xCu);
      uint64_t v24 = *(void *)(a1 + 1208);
    }

void sub_1003103A4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, void *__p, uint64_t a34, int a35, __int16 a36, char a37, char a38, uint64_t a39, uint64_t a40, uint64_t a41, char a42, void *a43, uint64_t a44, int a45, __int16 a46, char a47, char a48, uint64_t a49, uint64_t a50,uint64_t a51,char a52)
{
  if (a42 && a38 < 0) {
    operator delete(__p);
  }
  if (a52 && a48 < 0) {
    operator delete(a43);
  }
  if (LOBYTE(STACK[0x290]) && SLOBYTE(STACK[0x277]) < 0) {
    operator delete((void *)STACK[0x260]);
  }
  if (LOBYTE(STACK[0x2C8]) && SLOBYTE(STACK[0x2AF]) < 0) {
    operator delete((void *)STACK[0x298]);
  }
  if (*(_BYTE *)(v52 - 184))
  {
  }

  _Unwind_Resume(a1);
}

uint64_t sub_100310498( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7, double a8)
{
  uint64_t v13 = a6;
  double v12 = a8;
  uint64_t v11 = a2;
  char v10 = a7;
  uint64_t v8 = *(void *)(a1 + 24);
  if (!v8) {
    sub_10001EEF0();
  }
  return (*(uint64_t (**)(uint64_t, double *, uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t *, char *))(*(void *)v8 + 48LL))( v8,  &v12,  &v11,  a3,  a4,  a5,  &v13,  &v10);
}

BOOL sub_1003104F8(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 1184);
  if ((v1 - 1) < 2 || v1 == 4)
  {
    int v3 = (void *)(a1 + 1208);
    return *v3 != 0LL;
  }

  if (v1 == 3 && *(void *)(a1 + 1208))
  {
    int v3 = (void *)(a1 + 1216);
    return *v3 != 0LL;
  }

  return 0LL;
}

void sub_100310540(uint64_t a1, double *a2)
{
  int v4 = *(_DWORD *)(a1 + 1184);
  if ((v4 - 1) < 2)
  {
    uint64_t v6 = *(void *)(a1 + 1208);
    if (!v6) {
      return;
    }
    goto LABEL_9;
  }

  if (v4 != 4)
  {
    if (v4 != 3) {
      return;
    }
    uint64_t v5 = *(void *)(a1 + 1208);
    if (v5) {
      (*(void (**)(uint64_t, double *))(*(void *)v5 + 16LL))(v5, a2);
    }
    uint64_t v6 = *(void *)(a1 + 1216);
    if (!v6) {
      return;
    }
LABEL_9:
    (*(void (**)(uint64_t, double *))(*(void *)v6 + 16LL))(v6, a2);
    return;
  }

  uint64_t v7 = *(void *)(a1 + 1208);
  if (v7)
  {
    (*(void (**)(uint64_t, double *))(*(void *)v7 + 16LL))(v7, a2);
    double v8 = *a2;
    if (!*(_BYTE *)(a1 + 1200) || v8 - *(double *)(a1 + 1192) > 0.100000001)
    {
      *(double *)(a1 + 1192) = v8;
      *(_BYTE *)(a1 + 1200) = 1;
      (*(void (**)(void))(**(void **)(a1 + 1208) + 40LL))(*(void *)(a1 + 1208));
      if (*(void *)(a1 + 96))
      {
        float v10 = v9;
        sub_100310690(a1 + 72, *(void *)a1, v10);
      }
    }
  }

  else
  {
    uint64_t v11 = (os_log_s *)qword_1008000A0;
    if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)double v12 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#regionmon Motion based spatial gestures predictor not defined",  v12,  2u);
    }
  }

uint64_t sub_100310690(uint64_t a1, uint64_t a2, float a3)
{
  uint64_t v6 = a2;
  float v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    sub_10001EEF0();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, float *))(*(void *)v3 + 48LL))(v3, &v6, &v5);
}

BOOL sub_1003106D0(uint64_t a1)
{
  return *(_DWORD *)(a1 + 1180) == 3;
}

BOOL sub_1003106E0(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a2 + 20) == *(_DWORD *)(a1 + 1176);
}

void sub_1003106F4(uint64_t a1, double a2)
{
  uint64_t v4 = *(void *)a1;
  int v5 = *(_DWORD *)(a1 + 144);
  int v6 = *(_DWORD *)(a1 + 1184);
  sub_1002AEE40((char *)v28, (__int128 *)(a1 + 248));
  sub_1002AEE40((char *)v25, (__int128 *)(a1 + 360));
  v7[0] = v4;
  *(double *)&v7[1] = a2;
  char v8 = 0;
  v7[3] = 0LL;
  v7[4] = 0LL;
  _DWORD v7[2] = 0x3C47A0000LL;
  char v9 = 0;
  char v10 = 0;
  char v11 = 0;
  uint64_t v12 = 0LL;
  uint64_t v13 = 0LL;
  __int16 v14 = 0;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  int v17 = v5;
  int v18 = v6;
  char v19 = 0;
  char v20 = 0;
  uint64_t v21 = 0LL;
  uint64_t v22 = 0LL;
  uint64_t v23 = 0LL;
  char v24 = 1;
  sub_100310498(a1 + 8, v4, (uint64_t)v28, (uint64_t)v25, (uint64_t)v7, 0x13F800000LL, 0, a2);
  if (v27 && v26 < 0) {
    operator delete(v25[0]);
  }
  if (v30)
  {
    if (v29 < 0) {
      operator delete(v28[0]);
    }
  }

void sub_100310820(_Unwind_Exception *exception_object)
{
  if (*(_BYTE *)(v1 - 72))
  {
  }

  _Unwind_Resume(exception_object);
}

void sub_100310864(uint64_t a1, __int128 *a2)
{
  double v4 = *(double *)a2;
  uint64_t v5 = *(void *)(a1 + 120);
  __int128 v115 = *a2;
  int v116 = *((_DWORD *)a2 + 4);
  int v6 = (__int128 *)((char *)a2 + 24);
  if (*((char *)a2 + 47) < 0)
  {
    sub_1000063A8(&v117, *((void **)a2 + 3), *((void *)a2 + 4));
  }

  else
  {
    __int128 v117 = *v6;
    uint64_t v118 = *((void *)a2 + 5);
  }

  uint64_t v120 = 0LL;
  __int128 __p = 0LL;
  uint64_t v121 = 0LL;
  sub_1001309C0(&__p, *((const void **)a2 + 6), *((void *)a2 + 7), *((void *)a2 + 7) - *((void *)a2 + 6));
  __int128 v122 = *(__int128 *)((char *)a2 + 72);
  (*(void (**)(void **__return_ptr, uint64_t, __int128 *, void))(*(void *)v5 + 24LL))( &v123,  v5,  &v115,  0LL);
  int v7 = v124;
  double v8 = v125;
  int v34 = v123;
  uint64_t v35 = v126;
  uint64_t v9 = v127;
  int v10 = v128;
  int v11 = v130;
  int v12 = v131;
  int v13 = v132;
  if (__p)
  {
    uint64_t v120 = __p;
    operator delete(__p);
  }

  if (SHIBYTE(v118) < 0)
  {
    operator delete((void *)v117);
    if (!v13) {
      return;
    }
  }

  else if (!v13)
  {
    return;
  }

  if (v10)
  {
    uint64_t v14 = *(void *)(a1 + 104);
    if ((_DWORD)v9)
    {
      uint64_t v123 = *(void **)v14;
      sub_1002CD838(&v123, v9 - 1);
      __int128 v15 = (float *)v123;
    }

    else
    {
      int v18 = *(float **)(v14 + 8);
      __int128 v16 = (float *)(v14 + 8);
      int v17 = v18;
      if (v18)
      {
        do
        {
          __int128 v15 = v17;
          int v17 = (float *)*((void *)v17 + 1);
        }

        while (v17);
      }

      else
      {
        do
        {
          __int128 v15 = (float *)*((void *)v16 + 2);
          BOOL v19 = *(void *)v15 == (void)v16;
          __int128 v16 = v15;
        }

        while (v19);
      }
    }

    float v20 = v15[14] + -0.101;
    sub_10030DF30(a1 + 152, 0x13F800000LL, (char *)&v123, v20);
    if ((_BYTE)v123)
    {
      sub_1002AEE40((char *)v111, (__int128 *)(a1 + 248));
      sub_1002AEE40((char *)v108, (__int128 *)(a1 + 360));
      uint64_t v21 = *(void *)a1;
      float v22 = v113;
      int v23 = *(_DWORD *)(a1 + 144);
      if (v12 && v11 < *(_DWORD *)(a1 + 856))
      {
        char v24 = (os_log_s *)qword_1008000A0;
        if ((_DWORD)v9)
        {
          if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_DEBUG))
          {
            if (!v7) {
              sub_100006080();
            }
            *(_DWORD *)__int128 buf = 134218496;
            double v134 = v22;
            __int16 v135 = 2048;
            __int128 v136 = v34;
            __int16 v137 = 1024;
            LODWORD(v13_Block_object_dispose((const void *)(v1 - 112), 8) = v11;
            _os_log_debug_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEBUG,  "#regionmon BT threshold detector early return with estimate, range:%f  RSSI: %f, numSamples: %d",  buf,  0x1Cu);
          }
        }

        else if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_FAULT))
        {
          if (!v7) {
            sub_100006080();
          }
          sub_1003AC270(v139, (uint64_t)v34, v11, v24);
        }
      }

      int v25 = v23;
      char v26 = (os_log_s *)qword_1008000A0;
      if (os_log_type_enabled((os_log_t)qword_1008000A0, OS_LOG_TYPE_INFO))
      {
        double v27 = *((double *)a2 + 10);
        else {
          uint64_t v28 = (_OWORD *)*((void *)a2 + 3);
        }
        uint64_t v29 = *((void *)a2 + 1);
        *(_DWORD *)__int128 buf = 134218498;
        double v134 = v27;
        __int16 v135 = 2080;
        __int128 v136 = v28;
        __int16 v137 = 2048;
        uint64_t v138 = v29;
        _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_INFO,  "#regionmon Device Monitor suggested region change for device %llu (%s) with current RSSI of %f",  buf,  0x20u);
      }

      uint64_t v30 = *(void *)a1;
      sub_1002AEE40((char *)v105, (__int128 *)v111);
      sub_1002AEE40((char *)v102, (__int128 *)v108);
      v80[0] = v21;
      *(double *)&v80[1] = v4;
      float v81 = v22;
      int v82 = 3;
      char v85 = 0;
      uint64_t v83 = 0LL;
      uint64_t v84 = 0LL;
      char v86 = 0;
      char v87 = 0;
      char v88 = 0;
      uint64_t v89 = 0LL;
      uint64_t v90 = 0LL;
      __int16 v91 = 0;
      __int128 v92 = 0u;
      __int128 v93 = 0u;
      int v94 = v25;
      int v95 = 0;
      char v96 = 0;
      char v97 = 0;
      uint64_t v99 = 0LL;
      uint64_t v98 = 0LL;
      uint64_t v100 = 0LL;
      char v101 = 1;
      sub_100310498(a1 + 8, v30, (uint64_t)v105, (uint64_t)v102, (uint64_t)v80, 0x13F800000LL, 0, v4);
      if (v104 && v103 < 0) {
        operator delete(v102[0]);
      }
      if (v107 && v106 < 0) {
        operator delete(v105[0]);
      }
      if (v110 && v109 < 0) {
        operator delete(v108[0]);
      }
      if (v114 && v112 < 0) {
        operator delete(v111[0]);
      }
    }

    if (!*(_BYTE *)(a1 + 968) || !(_BYTE)v35) {
      goto LABEL_51;
    }
    uint64_t v31 = *(void *)a1;
    int v32 = *(_DWORD *)(a1 + 272);
    int v33 = *(_DWORD *)(a1 + 144);
    if (*(_BYTE *)(a1 + 136))
    {
      v58[0] = *(void *)a1;
      *(double *)&v58[1] = v4;
      int v59 = v32;
      int v60 = 3;
      char v63 = 0;
      uint64_t v61 = 0LL;
      uint64_t v62 = 0LL;
      char v64 = 0;
      char v65 = 0;
      char v66 = 0;
      uint64_t v67 = 0LL;
      uint64_t v68 = 0LL;
      __int16 v69 = 0;
      __int128 v70 = 0u;
      __int128 v71 = 0u;
      int v72 = v33;
      int v73 = 0;
      char v74 = 0;
      char v75 = 0;
      double v76 = v8;
      uint64_t v77 = v35;
      uint64_t v78 = 0LL;
      char v79 = 1;
      sub_100310EFC(a1 + 40, v31, (uint64_t)v58, v4);
    }

    else
    {
      v36[0] = *(void *)a1;
      *(double *)&v36[1] = v4;
      int v37 = v32;
      int v38 = 3;
      char v41 = 0;
      uint64_t v39 = 0LL;
      uint64_t v40 = 0LL;
      char v42 = 0;
      char v43 = 0;
      char v44 = 0;
      uint64_t v45 = 0LL;
      uint64_t v46 = 0LL;
      __int16 v47 = 0;
      __int128 v48 = 0u;
      __int128 v49 = 0u;
      int v50 = v33;
      int v51 = 0;
      char v52 = 0;
      char v53 = 0;
      double v54 = v8;
      uint64_t v55 = v35;
      uint64_t v56 = 0LL;
      char v57 = 1;
      sub_100310EFC(a1 + 40, v31, (uint64_t)v36, v4);
    }

    *(double *)(a1 + 12_Block_object_dispose((const void *)(v1 - 112), 8) = v8;
    *(_BYTE *)(a1 + 136) = 1;
LABEL_51:
    *(double *)(a1 + 416) = v4;
    *(_BYTE *)(a1 + 424) = 1;
    if (v129)
    {
      if (SHIBYTE(v126) < 0) {
        operator delete(v124);
      }
    }
  }